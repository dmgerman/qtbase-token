begin_unit
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  ftraster.c                                                             */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*    The FreeType glyph rasterizer (body).                                */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  Copyright 1996-2001, 2002, 2003, 2005, 2007, 2008, 2009 by             */
end_comment
begin_comment
comment|/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  This file is part of the FreeType project, and may only be used,       */
end_comment
begin_comment
comment|/*  modified, and distributed under the terms of the FreeType project      */
end_comment
begin_comment
comment|/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
end_comment
begin_comment
comment|/*  this file you indicate that you have read the license and              */
end_comment
begin_comment
comment|/*  understand and accept it fully.                                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* This file can be compiled without the rest of the FreeType engine, by */
end_comment
begin_comment
comment|/* defining the _STANDALONE_ macro when compiling it.  You also need to  */
end_comment
begin_comment
comment|/* put the files `ftimage.h' and `ftmisc.h' into the $(incdir)           */
end_comment
begin_comment
comment|/* directory.  Typically, you should do something like                   */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* - copy `src/raster/ftraster.c' (this file) to your current directory  */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* - copy `include/freetype/ftimage.h' and `src/raster/ftmisc.h'         */
end_comment
begin_comment
comment|/*   to your current directory                                           */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* - compile `ftraster' with the _STANDALONE_ macro defined, as in       */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*     cc -c -D_STANDALONE_ ftraster.c                                   */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* The renderer can be initialized with a call to                        */
end_comment
begin_comment
comment|/* `ft_standard_raster.raster_new'; a bitmap can be generated            */
end_comment
begin_comment
comment|/* with a call to `ft_standard_raster.raster_render'.                    */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* See the comments and documentation in the file `ftimage.h' for more   */
end_comment
begin_comment
comment|/* details on how the raster works.                                      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* This is a rewrite of the FreeType 1.x scan-line converter             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|_STANDALONE_
end_ifdef
begin_define
DECL|macro|FT_CONFIG_STANDARD_LIBRARY_H
define|#
directive|define
name|FT_CONFIG_STANDARD_LIBRARY_H
value|<stdlib.h>
end_define
begin_include
include|#
directive|include
file|<string.h>
end_include
begin_comment
comment|/* for memset */
end_comment
begin_include
include|#
directive|include
file|"ftmisc.h"
end_include
begin_include
include|#
directive|include
file|"ftimage.h"
end_include
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* !_STANDALONE_ */
end_comment
begin_include
include|#
directive|include
file|<ft2build.h>
end_include
begin_include
include|#
directive|include
file|"ftraster.h"
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_CALC_H
end_include
begin_comment
comment|/* for FT_MulDiv only */
end_comment
begin_include
include|#
directive|include
file|"rastpic.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* !_STANDALONE_ */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* A simple technical note on how the raster works                       */
end_comment
begin_comment
comment|/* -----------------------------------------------                       */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*   Converting an outline into a bitmap is achieved in several steps:   */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*   1 - Decomposing the outline into successive `profiles'.  Each       */
end_comment
begin_comment
comment|/*       profile is simply an array of scanline intersections on a given */
end_comment
begin_comment
comment|/*       dimension.  A profile's main attributes are                     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*       o its scanline position boundaries, i.e. `Ymin' and `Ymax'      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*       o an array of intersection coordinates for each scanline        */
end_comment
begin_comment
comment|/*         between `Ymin' and `Ymax'                                     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*       o a direction, indicating whether it was built going `up' or    */
end_comment
begin_comment
comment|/*         `down', as this is very important for filling rules           */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*       o its drop-out mode                                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*   2 - Sweeping the target map's scanlines in order to compute segment */
end_comment
begin_comment
comment|/*       `spans' which are then filled.  Additionally, this pass         */
end_comment
begin_comment
comment|/*       performs drop-out control.                                      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*   The outline data is parsed during step 1 only.  The profiles are    */
end_comment
begin_comment
comment|/*   built from the bottom of the render pool, used as a stack.  The     */
end_comment
begin_comment
comment|/*   following graphics shows the profile list under construction:       */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*     __________________________________________________________ _ _    */
end_comment
begin_comment
comment|/*    |         |                 |         |                 |          */
end_comment
begin_comment
comment|/*    | profile | coordinates for | profile | coordinates for |-->       */
end_comment
begin_comment
comment|/*    |    1    |  profile 1      |    2    |  profile 2      |-->       */
end_comment
begin_comment
comment|/*    |_________|_________________|_________|_________________|__ _ _    */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    ^                                                       ^          */
end_comment
begin_comment
comment|/*    |                                                       |          */
end_comment
begin_comment
comment|/* start of render pool                                      top         */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*   The top of the profile stack is kept in the `top' variable.         */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*   As you can see, a profile record is pushed on top of the render     */
end_comment
begin_comment
comment|/*   pool, which is then followed by its coordinates/intersections.  If  */
end_comment
begin_comment
comment|/*   a change of direction is detected in the outline, a new profile is  */
end_comment
begin_comment
comment|/*   generated until the end of the outline.                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*   Note that when all profiles have been generated, the function       */
end_comment
begin_comment
comment|/*   Finalize_Profile_Table() is used to record, for each profile, its   */
end_comment
begin_comment
comment|/*   bottom-most scanline as well as the scanline above its upmost       */
end_comment
begin_comment
comment|/*   boundary.  These positions are called `y-turns' because they (sort  */
end_comment
begin_comment
comment|/*   of) correspond to local extrema.  They are stored in a sorted list  */
end_comment
begin_comment
comment|/*   built from the top of the render pool as a downwards stack:         */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*      _ _ _______________________________________                      */
end_comment
begin_comment
comment|/*                            |                    |                     */
end_comment
begin_comment
comment|/*<--| sorted list of     |                     */
end_comment
begin_comment
comment|/*<--|  extrema scanlines |                     */
end_comment
begin_comment
comment|/*      _ _ __________________|____________________|                     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*                            ^                    ^                     */
end_comment
begin_comment
comment|/*                            |                    |                     */
end_comment
begin_comment
comment|/*                         maxBuff           sizeBuff = end of pool      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*   This list is later used during the sweep phase in order to          */
end_comment
begin_comment
comment|/*   optimize performance (see technical note on the sweep below).       */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*   Of course, the raster detects whether the two stacks collide and    */
end_comment
begin_comment
comment|/*   handles the situation properly.                                     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/**                                                                     **/
end_comment
begin_comment
comment|/**  CONFIGURATION MACROS                                               **/
end_comment
begin_comment
comment|/**                                                                     **/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/* define DEBUG_RASTER if you want to compile a debugging version */
end_comment
begin_comment
comment|/* #define DEBUG_RASTER */
end_comment
begin_comment
comment|/* define FT_RASTER_OPTION_ANTI_ALIASING if you want to support */
end_comment
begin_comment
comment|/* 5-levels anti-aliasing                                       */
end_comment
begin_comment
comment|/* #define FT_RASTER_OPTION_ANTI_ALIASING */
end_comment
begin_comment
comment|/* The size of the two-lines intermediate bitmap used */
end_comment
begin_comment
comment|/* for anti-aliasing, in bytes.                       */
end_comment
begin_define
DECL|macro|RASTER_GRAY_LINES
define|#
directive|define
name|RASTER_GRAY_LINES
value|2048
end_define
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/**                                                                     **/
end_comment
begin_comment
comment|/**  OTHER MACROS (do not change)                                       **/
end_comment
begin_comment
comment|/**                                                                     **/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
end_comment
begin_comment
comment|/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
end_comment
begin_comment
comment|/* messages during execution.                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_undef
DECL|macro|FT_COMPONENT
undef|#
directive|undef
name|FT_COMPONENT
end_undef
begin_define
DECL|macro|FT_COMPONENT
define|#
directive|define
name|FT_COMPONENT
value|trace_raster
end_define
begin_ifdef
ifdef|#
directive|ifdef
name|_STANDALONE_
end_ifdef
begin_comment
comment|/* This macro is used to indicate that a function parameter is unused. */
end_comment
begin_comment
comment|/* Its purpose is simply to reduce compiler warnings.  Note also that  */
end_comment
begin_comment
comment|/* simply defining it as `(void)x' doesn't avoid warnings with certain */
end_comment
begin_comment
comment|/* ANSI compilers (e.g. LCC).                                          */
end_comment
begin_define
DECL|macro|FT_UNUSED
define|#
directive|define
name|FT_UNUSED
parameter_list|(
name|x
parameter_list|)
value|(x) = (x)
end_define
begin_comment
comment|/* Disable the tracing mechanism for simplicity -- developers can      */
end_comment
begin_comment
comment|/* activate it easily by redefining these two macros.                  */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|FT_ERROR
end_ifndef
begin_define
DECL|macro|FT_ERROR
define|#
directive|define
name|FT_ERROR
parameter_list|(
name|x
parameter_list|)
value|do { } while ( 0 )
end_define
begin_comment
DECL|macro|FT_ERROR
comment|/* nothing */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|FT_TRACE
end_ifndef
begin_define
DECL|macro|FT_TRACE
define|#
directive|define
name|FT_TRACE
parameter_list|(
name|x
parameter_list|)
value|do { } while ( 0 )
end_define
begin_comment
DECL|macro|FT_TRACE
comment|/* nothing */
end_comment
begin_define
DECL|macro|FT_TRACE1
define|#
directive|define
name|FT_TRACE1
parameter_list|(
name|x
parameter_list|)
value|do { } while ( 0 )
end_define
begin_comment
DECL|macro|FT_TRACE1
comment|/* nothing */
end_comment
begin_define
DECL|macro|FT_TRACE6
define|#
directive|define
name|FT_TRACE6
parameter_list|(
name|x
parameter_list|)
value|do { } while ( 0 )
end_define
begin_comment
DECL|macro|FT_TRACE6
comment|/* nothing */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|Raster_Err_None
define|#
directive|define
name|Raster_Err_None
value|0
end_define
begin_define
DECL|macro|Raster_Err_Not_Ini
define|#
directive|define
name|Raster_Err_Not_Ini
value|-1
end_define
begin_define
DECL|macro|Raster_Err_Overflow
define|#
directive|define
name|Raster_Err_Overflow
value|-2
end_define
begin_define
DECL|macro|Raster_Err_Neg_Height
define|#
directive|define
name|Raster_Err_Neg_Height
value|-3
end_define
begin_define
DECL|macro|Raster_Err_Invalid
define|#
directive|define
name|Raster_Err_Invalid
value|-4
end_define
begin_define
DECL|macro|Raster_Err_Unsupported
define|#
directive|define
name|Raster_Err_Unsupported
value|-5
end_define
begin_define
DECL|macro|ft_memset
define|#
directive|define
name|ft_memset
value|memset
end_define
begin_define
DECL|macro|FT_DEFINE_RASTER_FUNCS
define|#
directive|define
name|FT_DEFINE_RASTER_FUNCS
parameter_list|(
name|class_
parameter_list|,
name|glyph_format_
parameter_list|,
name|raster_new_
parameter_list|, \
name|raster_reset_
parameter_list|,
name|raster_set_mode_
parameter_list|,    \
name|raster_render_
parameter_list|,
name|raster_done_
parameter_list|)
define|\
value|const FT_Raster_Funcs class_ =                            \           {                                                         \             glyph_format_,                                          \             raster_new_,                                            \             raster_reset_,                                          \             raster_set_mode_,                                       \             raster_render_,                                         \             raster_done_                                            \          };
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* !_STANDALONE_ */
end_comment
begin_include
include|#
directive|include
include|FT_INTERNAL_OBJECTS_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_DEBUG_H
end_include
begin_comment
comment|/* for FT_TRACE() and FT_ERROR() */
end_comment
begin_include
include|#
directive|include
file|"rasterrs.h"
end_include
begin_define
DECL|macro|Raster_Err_None
define|#
directive|define
name|Raster_Err_None
value|Raster_Err_Ok
end_define
begin_define
DECL|macro|Raster_Err_Not_Ini
define|#
directive|define
name|Raster_Err_Not_Ini
value|Raster_Err_Raster_Uninitialized
end_define
begin_define
DECL|macro|Raster_Err_Overflow
define|#
directive|define
name|Raster_Err_Overflow
value|Raster_Err_Raster_Overflow
end_define
begin_define
DECL|macro|Raster_Err_Neg_Height
define|#
directive|define
name|Raster_Err_Neg_Height
value|Raster_Err_Raster_Negative_Height
end_define
begin_define
DECL|macro|Raster_Err_Invalid
define|#
directive|define
name|Raster_Err_Invalid
value|Raster_Err_Invalid_Outline
end_define
begin_define
DECL|macro|Raster_Err_Unsupported
define|#
directive|define
name|Raster_Err_Unsupported
value|Raster_Err_Cannot_Render_Glyph
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* !_STANDALONE_ */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|FT_MEM_SET
end_ifndef
begin_define
DECL|macro|FT_MEM_SET
define|#
directive|define
name|FT_MEM_SET
parameter_list|(
name|d
parameter_list|,
name|s
parameter_list|,
name|c
parameter_list|)
value|ft_memset( d, s, c )
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|FT_MEM_ZERO
end_ifndef
begin_define
DECL|macro|FT_MEM_ZERO
define|#
directive|define
name|FT_MEM_ZERO
parameter_list|(
name|dest
parameter_list|,
name|count
parameter_list|)
value|FT_MEM_SET( dest, 0, count )
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* FMulDiv means `Fast MulDiv'; it is used in case where `b' is       */
end_comment
begin_comment
comment|/* typically a small value and the result of a*b is known to fit into */
end_comment
begin_comment
comment|/* 32 bits.                                                           */
end_comment
begin_define
DECL|macro|FMulDiv
define|#
directive|define
name|FMulDiv
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
value|( (a) * (b) / (c) )
end_define
begin_comment
comment|/* On the other hand, SMulDiv means `Slow MulDiv', and is used typically */
end_comment
begin_comment
comment|/* for clipping computations.  It simply uses the FT_MulDiv() function   */
end_comment
begin_comment
comment|/* defined in `ftcalc.h'.                                                */
end_comment
begin_define
DECL|macro|SMulDiv
define|#
directive|define
name|SMulDiv
value|FT_MulDiv
end_define
begin_comment
comment|/* The rasterizer is a very general purpose component; please leave */
end_comment
begin_comment
comment|/* the following redefinitions there (you never know your target    */
end_comment
begin_comment
comment|/* environment).                                                    */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|TRUE
end_ifndef
begin_define
DECL|macro|TRUE
define|#
directive|define
name|TRUE
value|1
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|FALSE
end_ifndef
begin_define
DECL|macro|FALSE
define|#
directive|define
name|FALSE
value|0
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|NULL
end_ifndef
begin_define
DECL|macro|NULL
define|#
directive|define
name|NULL
value|(void*)0
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|SUCCESS
end_ifndef
begin_define
DECL|macro|SUCCESS
define|#
directive|define
name|SUCCESS
value|0
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|FAILURE
end_ifndef
begin_define
DECL|macro|FAILURE
define|#
directive|define
name|FAILURE
value|1
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|MaxBezier
define|#
directive|define
name|MaxBezier
value|32
end_define
begin_comment
DECL|macro|MaxBezier
comment|/* The maximum number of stacked Bezier curves. */
end_comment
begin_comment
comment|/* Setting this constant to more than 32 is a   */
end_comment
begin_comment
comment|/* pure waste of space.                         */
end_comment
begin_define
DECL|macro|Pixel_Bits
define|#
directive|define
name|Pixel_Bits
value|6
end_define
begin_comment
DECL|macro|Pixel_Bits
comment|/* fractional bits of *input* coordinates */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/**                                                                     **/
end_comment
begin_comment
comment|/**  SIMPLE TYPE DECLARATIONS                                           **/
end_comment
begin_comment
comment|/**                                                                     **/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_typedef
DECL|typedef|Int
typedef|typedef
name|int
name|Int
typedef|;
end_typedef
begin_typedef
DECL|typedef|UInt
typedef|typedef
name|unsigned
name|int
name|UInt
typedef|;
end_typedef
begin_typedef
DECL|typedef|Short
typedef|typedef
name|short
name|Short
typedef|;
end_typedef
begin_typedef
DECL|typedef|UShort
DECL|typedef|PUShort
typedef|typedef
name|unsigned
name|short
name|UShort
typedef|,
modifier|*
name|PUShort
typedef|;
end_typedef
begin_typedef
DECL|typedef|Long
DECL|typedef|PLong
typedef|typedef
name|long
name|Long
typedef|,
modifier|*
name|PLong
typedef|;
end_typedef
begin_typedef
DECL|typedef|ULong
typedef|typedef
name|unsigned
name|long
name|ULong
typedef|;
end_typedef
begin_typedef
DECL|typedef|Byte
DECL|typedef|PByte
typedef|typedef
name|unsigned
name|char
name|Byte
typedef|,
modifier|*
name|PByte
typedef|;
end_typedef
begin_typedef
DECL|typedef|Bool
typedef|typedef
name|char
name|Bool
typedef|;
end_typedef
begin_typedef
DECL|union|Alignment_
typedef|typedef
union|union
name|Alignment_
block|{
DECL|member|l
name|long
name|l
decl_stmt|;
DECL|member|p
name|void
modifier|*
name|p
decl_stmt|;
DECL|member|f
name|void
function_decl|(
modifier|*
name|f
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
block|}
DECL|typedef|Alignment
DECL|typedef|PAlignment
name|Alignment
operator|,
typedef|*
name|PAlignment
typedef|;
end_typedef
begin_typedef
DECL|struct|TPoint_
typedef|typedef
struct|struct
name|TPoint_
block|{
DECL|member|x
name|Long
name|x
decl_stmt|;
DECL|member|y
name|Long
name|y
decl_stmt|;
block|}
DECL|typedef|TPoint
name|TPoint
typedef|;
end_typedef
begin_comment
comment|/* values for the `flags' bit field */
end_comment
begin_define
DECL|macro|Flow_Up
define|#
directive|define
name|Flow_Up
value|0x8
end_define
begin_define
DECL|macro|Overshoot_Top
define|#
directive|define
name|Overshoot_Top
value|0x10
end_define
begin_define
DECL|macro|Overshoot_Bottom
define|#
directive|define
name|Overshoot_Bottom
value|0x20
end_define
begin_comment
comment|/* States of each line, arc, and profile */
end_comment
begin_typedef
DECL|enum|TStates_
typedef|typedef
enum|enum
name|TStates_
block|{
DECL|enumerator|Unknown_State
name|Unknown_State
block|,
DECL|enumerator|Ascending_State
name|Ascending_State
block|,
DECL|enumerator|Descending_State
name|Descending_State
block|,
DECL|enumerator|Flat_State
name|Flat_State
block|}
DECL|typedef|TStates
name|TStates
typedef|;
end_typedef
begin_typedef
DECL|typedef|TProfile
typedef|typedef
name|struct
name|TProfile_
name|TProfile
typedef|;
end_typedef
begin_typedef
DECL|typedef|PProfile
typedef|typedef
name|TProfile
modifier|*
name|PProfile
typedef|;
end_typedef
begin_struct
DECL|struct|TProfile_
struct|struct
name|TProfile_
block|{
DECL|member|X
name|FT_F26Dot6
name|X
decl_stmt|;
comment|/* current coordinate during sweep          */
DECL|member|link
name|PProfile
name|link
decl_stmt|;
comment|/* link to next profile (various purposes)  */
DECL|member|offset
name|PLong
name|offset
decl_stmt|;
comment|/* start of profile's data in render pool   */
DECL|member|flags
name|unsigned
name|flags
decl_stmt|;
comment|/* Bit 0-2: drop-out mode                   */
comment|/* Bit 3: profile orientation (up/down)     */
comment|/* Bit 4: is top profile?                   */
comment|/* Bit 5: is bottom profile?                */
DECL|member|height
name|long
name|height
decl_stmt|;
comment|/* profile's height in scanlines            */
DECL|member|start
name|long
name|start
decl_stmt|;
comment|/* profile's starting scanline              */
DECL|member|countL
name|unsigned
name|countL
decl_stmt|;
comment|/* number of lines to step before this      */
comment|/* profile becomes drawable                 */
DECL|member|next
name|PProfile
name|next
decl_stmt|;
comment|/* next profile in same contour, used       */
comment|/* during drop-out control                  */
block|}
struct|;
end_struct
begin_typedef
DECL|typedef|TProfileList
typedef|typedef
name|PProfile
name|TProfileList
typedef|;
end_typedef
begin_typedef
DECL|typedef|PProfileList
typedef|typedef
name|PProfile
modifier|*
name|PProfileList
typedef|;
end_typedef
begin_comment
comment|/* Simple record used to implement a stack of bands, required */
end_comment
begin_comment
comment|/* by the sub-banding mechanism                               */
end_comment
begin_typedef
DECL|struct|TBand_
typedef|typedef
struct|struct
name|TBand_
block|{
DECL|member|y_min
name|Short
name|y_min
decl_stmt|;
comment|/* band's minimum */
DECL|member|y_max
name|Short
name|y_max
decl_stmt|;
comment|/* band's maximum */
block|}
DECL|typedef|TBand
name|TBand
typedef|;
end_typedef
begin_define
DECL|macro|AlignProfileSize
define|#
directive|define
name|AlignProfileSize
define|\
value|( ( sizeof ( TProfile ) + sizeof ( Alignment ) - 1 ) / sizeof ( long ) )
end_define
begin_ifdef
ifdef|#
directive|ifdef
name|FT_STATIC_RASTER
end_ifdef
begin_define
DECL|macro|RAS_ARGS
define|#
directive|define
name|RAS_ARGS
end_define
begin_comment
DECL|macro|RAS_ARGS
comment|/* void */
end_comment
begin_define
DECL|macro|RAS_ARG
define|#
directive|define
name|RAS_ARG
end_define
begin_comment
DECL|macro|RAS_ARG
comment|/* void */
end_comment
begin_define
DECL|macro|RAS_VARS
define|#
directive|define
name|RAS_VARS
end_define
begin_comment
DECL|macro|RAS_VARS
comment|/* void */
end_comment
begin_define
DECL|macro|RAS_VAR
define|#
directive|define
name|RAS_VAR
end_define
begin_comment
DECL|macro|RAS_VAR
comment|/* void */
end_comment
begin_define
DECL|macro|FT_UNUSED_RASTER
define|#
directive|define
name|FT_UNUSED_RASTER
value|do { } while ( 0 )
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* !FT_STATIC_RASTER */
end_comment
begin_define
DECL|macro|RAS_ARGS
define|#
directive|define
name|RAS_ARGS
value|PWorker    worker,
end_define
begin_define
DECL|macro|RAS_ARG
define|#
directive|define
name|RAS_ARG
value|PWorker    worker
end_define
begin_define
DECL|macro|RAS_VARS
define|#
directive|define
name|RAS_VARS
value|worker,
end_define
begin_define
DECL|macro|RAS_VAR
define|#
directive|define
name|RAS_VAR
value|worker
end_define
begin_define
DECL|macro|FT_UNUSED_RASTER
define|#
directive|define
name|FT_UNUSED_RASTER
value|FT_UNUSED( worker )
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* !FT_STATIC_RASTER */
end_comment
begin_typedef
DECL|typedef|TWorker
DECL|typedef|PWorker
typedef|typedef
name|struct
name|TWorker_
name|TWorker
typedef|,
modifier|*
name|PWorker
typedef|;
end_typedef
begin_comment
comment|/* prototypes used for sweep function dispatch */
end_comment
begin_typedef
typedef|typedef
name|void
DECL|typedef|Function_Sweep_Init
name|Function_Sweep_Init
parameter_list|(
name|RAS_ARGS
name|Short
modifier|*
name|min
parameter_list|,
name|Short
modifier|*
name|max
parameter_list|)
function_decl|;
end_typedef
begin_typedef
typedef|typedef
name|void
DECL|typedef|Function_Sweep_Span
name|Function_Sweep_Span
parameter_list|(
name|RAS_ARGS
name|Short
name|y
parameter_list|,
name|FT_F26Dot6
name|x1
parameter_list|,
name|FT_F26Dot6
name|x2
parameter_list|,
name|PProfile
name|left
parameter_list|,
name|PProfile
name|right
parameter_list|)
function_decl|;
end_typedef
begin_typedef
typedef|typedef
name|void
DECL|typedef|Function_Sweep_Step
name|Function_Sweep_Step
parameter_list|(
name|RAS_ARG
parameter_list|)
function_decl|;
end_typedef
begin_comment
comment|/* NOTE: These operations are only valid on 2's complement processors */
end_comment
begin_define
DECL|macro|FLOOR
define|#
directive|define
name|FLOOR
parameter_list|(
name|x
parameter_list|)
value|( (x)& -ras.precision )
end_define
begin_define
DECL|macro|CEILING
define|#
directive|define
name|CEILING
parameter_list|(
name|x
parameter_list|)
value|( ( (x) + ras.precision - 1 )& -ras.precision )
end_define
begin_define
DECL|macro|TRUNC
define|#
directive|define
name|TRUNC
parameter_list|(
name|x
parameter_list|)
value|( (signed long)(x)>> ras.precision_bits )
end_define
begin_define
DECL|macro|FRAC
define|#
directive|define
name|FRAC
parameter_list|(
name|x
parameter_list|)
value|( (x)& ( ras.precision - 1 ) )
end_define
begin_define
DECL|macro|SCALED
define|#
directive|define
name|SCALED
parameter_list|(
name|x
parameter_list|)
value|( ( (x)<< ras.scale_shift ) - ras.precision_half )
end_define
begin_define
DECL|macro|IS_BOTTOM_OVERSHOOT
define|#
directive|define
name|IS_BOTTOM_OVERSHOOT
parameter_list|(
name|x
parameter_list|)
value|( CEILING( x ) - x>= ras.precision_half )
end_define
begin_define
DECL|macro|IS_TOP_OVERSHOOT
define|#
directive|define
name|IS_TOP_OVERSHOOT
parameter_list|(
name|x
parameter_list|)
value|( x - FLOOR( x )>= ras.precision_half )
end_define
begin_comment
comment|/* The most used variables are positioned at the top of the structure. */
end_comment
begin_comment
comment|/* Thus, their offset can be coded with less opcodes, resulting in a   */
end_comment
begin_comment
comment|/* smaller executable.                                                 */
end_comment
begin_struct
DECL|struct|TWorker_
struct|struct
name|TWorker_
block|{
DECL|member|precision_bits
name|Int
name|precision_bits
decl_stmt|;
comment|/* precision related variables         */
DECL|member|precision
name|Int
name|precision
decl_stmt|;
DECL|member|precision_half
name|Int
name|precision_half
decl_stmt|;
DECL|member|precision_mask
name|Long
name|precision_mask
decl_stmt|;
DECL|member|precision_shift
name|Int
name|precision_shift
decl_stmt|;
DECL|member|precision_step
name|Int
name|precision_step
decl_stmt|;
DECL|member|precision_jitter
name|Int
name|precision_jitter
decl_stmt|;
DECL|member|scale_shift
name|Int
name|scale_shift
decl_stmt|;
comment|/* == precision_shift   for bitmaps    */
comment|/* == precision_shift+1 for pixmaps    */
DECL|member|buff
name|PLong
name|buff
decl_stmt|;
comment|/* The profiles buffer                 */
DECL|member|sizeBuff
name|PLong
name|sizeBuff
decl_stmt|;
comment|/* Render pool size                    */
DECL|member|maxBuff
name|PLong
name|maxBuff
decl_stmt|;
comment|/* Profiles buffer size                */
DECL|member|top
name|PLong
name|top
decl_stmt|;
comment|/* Current cursor in buffer            */
DECL|member|error
name|FT_Error
name|error
decl_stmt|;
DECL|member|numTurns
name|Int
name|numTurns
decl_stmt|;
comment|/* number of Y-turns in outline        */
DECL|member|arc
name|TPoint
modifier|*
name|arc
decl_stmt|;
comment|/* current Bezier arc pointer          */
DECL|member|bWidth
name|UShort
name|bWidth
decl_stmt|;
comment|/* target bitmap width                 */
DECL|member|bTarget
name|PByte
name|bTarget
decl_stmt|;
comment|/* target bitmap buffer                */
DECL|member|gTarget
name|PByte
name|gTarget
decl_stmt|;
comment|/* target pixmap buffer                */
DECL|member|lastX
DECL|member|lastY
name|Long
name|lastX
decl_stmt|,
name|lastY
decl_stmt|;
DECL|member|minY
DECL|member|maxY
name|Long
name|minY
decl_stmt|,
name|maxY
decl_stmt|;
DECL|member|num_Profs
name|UShort
name|num_Profs
decl_stmt|;
comment|/* current number of profiles          */
DECL|member|fresh
name|Bool
name|fresh
decl_stmt|;
comment|/* signals a fresh new profile which   */
comment|/* `start' field must be completed     */
DECL|member|joint
name|Bool
name|joint
decl_stmt|;
comment|/* signals that the last arc ended     */
comment|/* exactly on a scanline.  Allows      */
comment|/* removal of doublets                 */
DECL|member|cProfile
name|PProfile
name|cProfile
decl_stmt|;
comment|/* current profile                     */
DECL|member|fProfile
name|PProfile
name|fProfile
decl_stmt|;
comment|/* head of linked list of profiles     */
DECL|member|gProfile
name|PProfile
name|gProfile
decl_stmt|;
comment|/* contour's first profile in case     */
comment|/* of impact                           */
DECL|member|state
name|TStates
name|state
decl_stmt|;
comment|/* rendering state                     */
DECL|member|target
name|FT_Bitmap
name|target
decl_stmt|;
comment|/* description of target bit/pixmap    */
DECL|member|outline
name|FT_Outline
name|outline
decl_stmt|;
DECL|member|traceOfs
name|Long
name|traceOfs
decl_stmt|;
comment|/* current offset in target bitmap     */
DECL|member|traceG
name|Long
name|traceG
decl_stmt|;
comment|/* current offset in target pixmap     */
DECL|member|traceIncr
name|Short
name|traceIncr
decl_stmt|;
comment|/* sweep's increment in target bitmap  */
DECL|member|gray_min_x
name|Short
name|gray_min_x
decl_stmt|;
comment|/* current min x during gray rendering */
DECL|member|gray_max_x
name|Short
name|gray_max_x
decl_stmt|;
comment|/* current max x during gray rendering */
comment|/* dispatch variables */
DECL|member|Proc_Sweep_Init
name|Function_Sweep_Init
modifier|*
name|Proc_Sweep_Init
decl_stmt|;
DECL|member|Proc_Sweep_Span
name|Function_Sweep_Span
modifier|*
name|Proc_Sweep_Span
decl_stmt|;
DECL|member|Proc_Sweep_Drop
name|Function_Sweep_Span
modifier|*
name|Proc_Sweep_Drop
decl_stmt|;
DECL|member|Proc_Sweep_Step
name|Function_Sweep_Step
modifier|*
name|Proc_Sweep_Step
decl_stmt|;
DECL|member|dropOutControl
name|Byte
name|dropOutControl
decl_stmt|;
comment|/* current drop_out control method     */
DECL|member|second_pass
name|Bool
name|second_pass
decl_stmt|;
comment|/* indicates whether a horizontal pass */
comment|/* should be performed to control      */
comment|/* drop-out accurately when calling    */
comment|/* Render_Glyph.  Note that there is   */
comment|/* no horizontal pass during gray      */
comment|/* rendering.                          */
DECL|member|arcs
name|TPoint
name|arcs
index|[
literal|3
operator|*
name|MaxBezier
operator|+
literal|1
index|]
decl_stmt|;
comment|/* The Bezier stack               */
DECL|member|band_stack
name|TBand
name|band_stack
index|[
literal|16
index|]
decl_stmt|;
comment|/* band stack used for sub-banding     */
DECL|member|band_top
name|Int
name|band_top
decl_stmt|;
comment|/* band stack top                      */
ifdef|#
directive|ifdef
name|FT_RASTER_OPTION_ANTI_ALIASING
DECL|member|grays
name|Byte
modifier|*
name|grays
decl_stmt|;
DECL|member|gray_lines
name|Byte
name|gray_lines
index|[
name|RASTER_GRAY_LINES
index|]
decl_stmt|;
comment|/* Intermediate table used to render the   */
comment|/* graylevels pixmaps.                     */
comment|/* gray_lines is a buffer holding two      */
comment|/* monochrome scanlines                    */
DECL|member|gray_width
name|Short
name|gray_width
decl_stmt|;
comment|/* width in bytes of one monochrome        */
comment|/* intermediate scanline of gray_lines.    */
comment|/* Each gray pixel takes 2 bits long there */
comment|/* The gray_lines must hold 2 lines, thus with size */
comment|/* in bytes of at least `gray_width*2'.             */
endif|#
directive|endif
comment|/* FT_RASTER_ANTI_ALIASING */
block|}
struct|;
end_struct
begin_typedef
DECL|struct|TRaster_
typedef|typedef
struct|struct
name|TRaster_
block|{
DECL|member|buffer
name|char
modifier|*
name|buffer
decl_stmt|;
DECL|member|buffer_size
name|long
name|buffer_size
decl_stmt|;
DECL|member|memory
name|void
modifier|*
name|memory
decl_stmt|;
DECL|member|worker
name|PWorker
name|worker
decl_stmt|;
DECL|member|grays
name|Byte
name|grays
index|[
literal|5
index|]
decl_stmt|;
DECL|member|gray_width
name|Short
name|gray_width
decl_stmt|;
block|}
DECL|typedef|TRaster
DECL|typedef|PRaster
name|TRaster
operator|,
typedef|*
name|PRaster
typedef|;
end_typedef
begin_ifdef
ifdef|#
directive|ifdef
name|FT_STATIC_RASTER
end_ifdef
begin_decl_stmt
DECL|variable|cur_ras
specifier|static
name|TWorker
name|cur_ras
decl_stmt|;
end_decl_stmt
begin_define
DECL|macro|ras
define|#
directive|define
name|ras
value|cur_ras
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* !FT_STATIC_RASTER */
end_comment
begin_define
DECL|macro|ras
define|#
directive|define
name|ras
value|(*worker)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* !FT_STATIC_RASTER */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|FT_RASTER_OPTION_ANTI_ALIASING
end_ifdef
begin_comment
comment|/* A lookup table used to quickly count set bits in four gray 2x2 */
end_comment
begin_comment
comment|/* cells.  The values of the table have been produced with the    */
end_comment
begin_comment
comment|/* following code:                                                */
end_comment
begin_comment
comment|/*                                                                */
end_comment
begin_comment
comment|/*   for ( i = 0; i< 256; i++ )                                  */
end_comment
begin_comment
comment|/*   {                                                            */
end_comment
begin_comment
comment|/*     l = 0;                                                     */
end_comment
begin_comment
comment|/*     j = i;                                                     */
end_comment
begin_comment
comment|/*                                                                */
end_comment
begin_comment
comment|/*     for ( c = 0; c< 4; c++ )                                  */
end_comment
begin_comment
comment|/*     {                                                          */
end_comment
begin_comment
comment|/*       l<<= 4;                                                 */
end_comment
begin_comment
comment|/*                                                                */
end_comment
begin_comment
comment|/*       if ( j& 0x80 ) l++;                                     */
end_comment
begin_comment
comment|/*       if ( j& 0x40 ) l++;                                     */
end_comment
begin_comment
comment|/*                                                                */
end_comment
begin_comment
comment|/*       j = ( j<< 2 )& 0xFF;                                   */
end_comment
begin_comment
comment|/*     }                                                          */
end_comment
begin_comment
comment|/*     printf( "0x%04X", l );                                     */
end_comment
begin_comment
comment|/*   }                                                            */
end_comment
begin_comment
comment|/*                                                                */
end_comment
begin_decl_stmt
DECL|variable|count_table
specifier|static
specifier|const
name|short
name|count_table
index|[
literal|256
index|]
init|=
block|{
literal|0x0000
block|,
literal|0x0001
block|,
literal|0x0001
block|,
literal|0x0002
block|,
literal|0x0010
block|,
literal|0x0011
block|,
literal|0x0011
block|,
literal|0x0012
block|,
literal|0x0010
block|,
literal|0x0011
block|,
literal|0x0011
block|,
literal|0x0012
block|,
literal|0x0020
block|,
literal|0x0021
block|,
literal|0x0021
block|,
literal|0x0022
block|,
literal|0x0100
block|,
literal|0x0101
block|,
literal|0x0101
block|,
literal|0x0102
block|,
literal|0x0110
block|,
literal|0x0111
block|,
literal|0x0111
block|,
literal|0x0112
block|,
literal|0x0110
block|,
literal|0x0111
block|,
literal|0x0111
block|,
literal|0x0112
block|,
literal|0x0120
block|,
literal|0x0121
block|,
literal|0x0121
block|,
literal|0x0122
block|,
literal|0x0100
block|,
literal|0x0101
block|,
literal|0x0101
block|,
literal|0x0102
block|,
literal|0x0110
block|,
literal|0x0111
block|,
literal|0x0111
block|,
literal|0x0112
block|,
literal|0x0110
block|,
literal|0x0111
block|,
literal|0x0111
block|,
literal|0x0112
block|,
literal|0x0120
block|,
literal|0x0121
block|,
literal|0x0121
block|,
literal|0x0122
block|,
literal|0x0200
block|,
literal|0x0201
block|,
literal|0x0201
block|,
literal|0x0202
block|,
literal|0x0210
block|,
literal|0x0211
block|,
literal|0x0211
block|,
literal|0x0212
block|,
literal|0x0210
block|,
literal|0x0211
block|,
literal|0x0211
block|,
literal|0x0212
block|,
literal|0x0220
block|,
literal|0x0221
block|,
literal|0x0221
block|,
literal|0x0222
block|,
literal|0x1000
block|,
literal|0x1001
block|,
literal|0x1001
block|,
literal|0x1002
block|,
literal|0x1010
block|,
literal|0x1011
block|,
literal|0x1011
block|,
literal|0x1012
block|,
literal|0x1010
block|,
literal|0x1011
block|,
literal|0x1011
block|,
literal|0x1012
block|,
literal|0x1020
block|,
literal|0x1021
block|,
literal|0x1021
block|,
literal|0x1022
block|,
literal|0x1100
block|,
literal|0x1101
block|,
literal|0x1101
block|,
literal|0x1102
block|,
literal|0x1110
block|,
literal|0x1111
block|,
literal|0x1111
block|,
literal|0x1112
block|,
literal|0x1110
block|,
literal|0x1111
block|,
literal|0x1111
block|,
literal|0x1112
block|,
literal|0x1120
block|,
literal|0x1121
block|,
literal|0x1121
block|,
literal|0x1122
block|,
literal|0x1100
block|,
literal|0x1101
block|,
literal|0x1101
block|,
literal|0x1102
block|,
literal|0x1110
block|,
literal|0x1111
block|,
literal|0x1111
block|,
literal|0x1112
block|,
literal|0x1110
block|,
literal|0x1111
block|,
literal|0x1111
block|,
literal|0x1112
block|,
literal|0x1120
block|,
literal|0x1121
block|,
literal|0x1121
block|,
literal|0x1122
block|,
literal|0x1200
block|,
literal|0x1201
block|,
literal|0x1201
block|,
literal|0x1202
block|,
literal|0x1210
block|,
literal|0x1211
block|,
literal|0x1211
block|,
literal|0x1212
block|,
literal|0x1210
block|,
literal|0x1211
block|,
literal|0x1211
block|,
literal|0x1212
block|,
literal|0x1220
block|,
literal|0x1221
block|,
literal|0x1221
block|,
literal|0x1222
block|,
literal|0x1000
block|,
literal|0x1001
block|,
literal|0x1001
block|,
literal|0x1002
block|,
literal|0x1010
block|,
literal|0x1011
block|,
literal|0x1011
block|,
literal|0x1012
block|,
literal|0x1010
block|,
literal|0x1011
block|,
literal|0x1011
block|,
literal|0x1012
block|,
literal|0x1020
block|,
literal|0x1021
block|,
literal|0x1021
block|,
literal|0x1022
block|,
literal|0x1100
block|,
literal|0x1101
block|,
literal|0x1101
block|,
literal|0x1102
block|,
literal|0x1110
block|,
literal|0x1111
block|,
literal|0x1111
block|,
literal|0x1112
block|,
literal|0x1110
block|,
literal|0x1111
block|,
literal|0x1111
block|,
literal|0x1112
block|,
literal|0x1120
block|,
literal|0x1121
block|,
literal|0x1121
block|,
literal|0x1122
block|,
literal|0x1100
block|,
literal|0x1101
block|,
literal|0x1101
block|,
literal|0x1102
block|,
literal|0x1110
block|,
literal|0x1111
block|,
literal|0x1111
block|,
literal|0x1112
block|,
literal|0x1110
block|,
literal|0x1111
block|,
literal|0x1111
block|,
literal|0x1112
block|,
literal|0x1120
block|,
literal|0x1121
block|,
literal|0x1121
block|,
literal|0x1122
block|,
literal|0x1200
block|,
literal|0x1201
block|,
literal|0x1201
block|,
literal|0x1202
block|,
literal|0x1210
block|,
literal|0x1211
block|,
literal|0x1211
block|,
literal|0x1212
block|,
literal|0x1210
block|,
literal|0x1211
block|,
literal|0x1211
block|,
literal|0x1212
block|,
literal|0x1220
block|,
literal|0x1221
block|,
literal|0x1221
block|,
literal|0x1222
block|,
literal|0x2000
block|,
literal|0x2001
block|,
literal|0x2001
block|,
literal|0x2002
block|,
literal|0x2010
block|,
literal|0x2011
block|,
literal|0x2011
block|,
literal|0x2012
block|,
literal|0x2010
block|,
literal|0x2011
block|,
literal|0x2011
block|,
literal|0x2012
block|,
literal|0x2020
block|,
literal|0x2021
block|,
literal|0x2021
block|,
literal|0x2022
block|,
literal|0x2100
block|,
literal|0x2101
block|,
literal|0x2101
block|,
literal|0x2102
block|,
literal|0x2110
block|,
literal|0x2111
block|,
literal|0x2111
block|,
literal|0x2112
block|,
literal|0x2110
block|,
literal|0x2111
block|,
literal|0x2111
block|,
literal|0x2112
block|,
literal|0x2120
block|,
literal|0x2121
block|,
literal|0x2121
block|,
literal|0x2122
block|,
literal|0x2100
block|,
literal|0x2101
block|,
literal|0x2101
block|,
literal|0x2102
block|,
literal|0x2110
block|,
literal|0x2111
block|,
literal|0x2111
block|,
literal|0x2112
block|,
literal|0x2110
block|,
literal|0x2111
block|,
literal|0x2111
block|,
literal|0x2112
block|,
literal|0x2120
block|,
literal|0x2121
block|,
literal|0x2121
block|,
literal|0x2122
block|,
literal|0x2200
block|,
literal|0x2201
block|,
literal|0x2201
block|,
literal|0x2202
block|,
literal|0x2210
block|,
literal|0x2211
block|,
literal|0x2211
block|,
literal|0x2212
block|,
literal|0x2210
block|,
literal|0x2211
block|,
literal|0x2211
block|,
literal|0x2212
block|,
literal|0x2220
block|,
literal|0x2221
block|,
literal|0x2221
block|,
literal|0x2222
block|}
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* FT_RASTER_OPTION_ANTI_ALIASING */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/**                                                                     **/
end_comment
begin_comment
comment|/**  PROFILES COMPUTATION                                               **/
end_comment
begin_comment
comment|/**                                                                     **/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    Set_High_Precision                                                 */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Set precision variables according to param flag.                   */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    High :: Set to True for high precision (typically for ppem< 18),  */
end_comment
begin_comment
comment|/*            false otherwise.                                           */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Set_High_Precision
name|Set_High_Precision
parameter_list|(
name|RAS_ARGS
name|Int
name|High
parameter_list|)
block|{
if|if
condition|(
name|High
condition|)
block|{
name|ras
operator|.
name|precision_bits
operator|=
literal|12
expr_stmt|;
name|ras
operator|.
name|precision_step
operator|=
literal|256
expr_stmt|;
name|ras
operator|.
name|precision_jitter
operator|=
literal|50
expr_stmt|;
block|}
else|else
block|{
name|ras
operator|.
name|precision_bits
operator|=
literal|6
expr_stmt|;
name|ras
operator|.
name|precision_step
operator|=
literal|32
expr_stmt|;
name|ras
operator|.
name|precision_jitter
operator|=
literal|2
expr_stmt|;
block|}
name|FT_TRACE6
argument_list|(
operator|(
literal|"Set_High_Precision(%s)\n"
operator|,
name|High
condition|?
literal|"true"
else|:
literal|"false"
operator|)
argument_list|)
expr_stmt|;
name|ras
operator|.
name|precision
operator|=
literal|1
operator|<<
name|ras
operator|.
name|precision_bits
expr_stmt|;
name|ras
operator|.
name|precision_half
operator|=
name|ras
operator|.
name|precision
operator|/
literal|2
expr_stmt|;
name|ras
operator|.
name|precision_shift
operator|=
name|ras
operator|.
name|precision_bits
operator|-
name|Pixel_Bits
expr_stmt|;
name|ras
operator|.
name|precision_mask
operator|=
operator|-
name|ras
operator|.
name|precision
expr_stmt|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    New_Profile                                                        */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Create a new profile in the render pool.                           */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    aState    :: The state/orientation of the new profile.             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    overshoot :: Whether the profile's unrounded start position        */
end_comment
begin_comment
comment|/*                 differs by at least a half pixel.                     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*   SUCCESS on success.  FAILURE in case of overflow or of incoherent   */
end_comment
begin_comment
comment|/*   profile.                                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|Bool
DECL|function|New_Profile
name|New_Profile
parameter_list|(
name|RAS_ARGS
name|TStates
name|aState
parameter_list|,
name|Bool
name|overshoot
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ras
operator|.
name|fProfile
condition|)
block|{
name|ras
operator|.
name|cProfile
operator|=
operator|(
name|PProfile
operator|)
name|ras
operator|.
name|top
expr_stmt|;
name|ras
operator|.
name|fProfile
operator|=
name|ras
operator|.
name|cProfile
expr_stmt|;
name|ras
operator|.
name|top
operator|+=
name|AlignProfileSize
expr_stmt|;
block|}
if|if
condition|(
name|ras
operator|.
name|top
operator|>=
name|ras
operator|.
name|maxBuff
condition|)
block|{
name|ras
operator|.
name|error
operator|=
name|Raster_Err_Overflow
expr_stmt|;
return|return
name|FAILURE
return|;
block|}
name|ras
operator|.
name|cProfile
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|ras
operator|.
name|cProfile
operator|->
name|start
operator|=
literal|0
expr_stmt|;
name|ras
operator|.
name|cProfile
operator|->
name|height
operator|=
literal|0
expr_stmt|;
name|ras
operator|.
name|cProfile
operator|->
name|offset
operator|=
name|ras
operator|.
name|top
expr_stmt|;
name|ras
operator|.
name|cProfile
operator|->
name|link
operator|=
operator|(
name|PProfile
operator|)
literal|0
expr_stmt|;
name|ras
operator|.
name|cProfile
operator|->
name|next
operator|=
operator|(
name|PProfile
operator|)
literal|0
expr_stmt|;
name|ras
operator|.
name|cProfile
operator|->
name|flags
operator|=
name|ras
operator|.
name|dropOutControl
expr_stmt|;
switch|switch
condition|(
name|aState
condition|)
block|{
case|case
name|Ascending_State
case|:
name|ras
operator|.
name|cProfile
operator|->
name|flags
operator||=
name|Flow_Up
expr_stmt|;
if|if
condition|(
name|overshoot
condition|)
name|ras
operator|.
name|cProfile
operator|->
name|flags
operator||=
name|Overshoot_Bottom
expr_stmt|;
name|FT_TRACE6
argument_list|(
operator|(
literal|"New ascending profile = %lx\n"
operator|,
operator|(
name|long
operator|)
name|ras
operator|.
name|cProfile
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|Descending_State
case|:
if|if
condition|(
name|overshoot
condition|)
name|ras
operator|.
name|cProfile
operator|->
name|flags
operator||=
name|Overshoot_Top
expr_stmt|;
name|FT_TRACE6
argument_list|(
operator|(
literal|"New descending profile = %lx\n"
operator|,
operator|(
name|long
operator|)
name|ras
operator|.
name|cProfile
operator|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|FT_ERROR
argument_list|(
operator|(
literal|"New_Profile: invalid profile direction\n"
operator|)
argument_list|)
expr_stmt|;
name|ras
operator|.
name|error
operator|=
name|Raster_Err_Invalid
expr_stmt|;
return|return
name|FAILURE
return|;
block|}
if|if
condition|(
operator|!
name|ras
operator|.
name|gProfile
condition|)
name|ras
operator|.
name|gProfile
operator|=
name|ras
operator|.
name|cProfile
expr_stmt|;
name|ras
operator|.
name|state
operator|=
name|aState
expr_stmt|;
name|ras
operator|.
name|fresh
operator|=
name|TRUE
expr_stmt|;
name|ras
operator|.
name|joint
operator|=
name|FALSE
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    End_Profile                                                        */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Finalize the current profile.                                      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    overshoot :: Whether the profile's unrounded end position differs  */
end_comment
begin_comment
comment|/*                 by at least a half pixel.                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    SUCCESS on success.  FAILURE in case of overflow or incoherency.   */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|Bool
DECL|function|End_Profile
name|End_Profile
parameter_list|(
name|RAS_ARGS
name|Bool
name|overshoot
parameter_list|)
block|{
name|Long
name|h
decl_stmt|;
name|PProfile
name|oldProfile
decl_stmt|;
name|h
operator|=
call|(
name|Long
call|)
argument_list|(
name|ras
operator|.
name|top
operator|-
name|ras
operator|.
name|cProfile
operator|->
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|<
literal|0
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"End_Profile: negative height encountered\n"
operator|)
argument_list|)
expr_stmt|;
name|ras
operator|.
name|error
operator|=
name|Raster_Err_Neg_Height
expr_stmt|;
return|return
name|FAILURE
return|;
block|}
if|if
condition|(
name|h
operator|>
literal|0
condition|)
block|{
name|FT_TRACE6
argument_list|(
operator|(
literal|"Ending profile %lx, start = %ld, height = %ld\n"
operator|,
operator|(
name|long
operator|)
name|ras
operator|.
name|cProfile
operator|,
name|ras
operator|.
name|cProfile
operator|->
name|start
operator|,
name|h
operator|)
argument_list|)
expr_stmt|;
name|ras
operator|.
name|cProfile
operator|->
name|height
operator|=
name|h
expr_stmt|;
if|if
condition|(
name|overshoot
condition|)
block|{
if|if
condition|(
name|ras
operator|.
name|cProfile
operator|->
name|flags
operator|&
name|Flow_Up
condition|)
name|ras
operator|.
name|cProfile
operator|->
name|flags
operator||=
name|Overshoot_Top
expr_stmt|;
else|else
name|ras
operator|.
name|cProfile
operator|->
name|flags
operator||=
name|Overshoot_Bottom
expr_stmt|;
block|}
name|oldProfile
operator|=
name|ras
operator|.
name|cProfile
expr_stmt|;
name|ras
operator|.
name|cProfile
operator|=
operator|(
name|PProfile
operator|)
name|ras
operator|.
name|top
expr_stmt|;
name|ras
operator|.
name|top
operator|+=
name|AlignProfileSize
expr_stmt|;
name|ras
operator|.
name|cProfile
operator|->
name|height
operator|=
literal|0
expr_stmt|;
name|ras
operator|.
name|cProfile
operator|->
name|offset
operator|=
name|ras
operator|.
name|top
expr_stmt|;
name|oldProfile
operator|->
name|next
operator|=
name|ras
operator|.
name|cProfile
expr_stmt|;
name|ras
operator|.
name|num_Profs
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|ras
operator|.
name|top
operator|>=
name|ras
operator|.
name|maxBuff
condition|)
block|{
name|FT_TRACE1
argument_list|(
operator|(
literal|"overflow in End_Profile\n"
operator|)
argument_list|)
expr_stmt|;
name|ras
operator|.
name|error
operator|=
name|Raster_Err_Overflow
expr_stmt|;
return|return
name|FAILURE
return|;
block|}
name|ras
operator|.
name|joint
operator|=
name|FALSE
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    Insert_Y_Turn                                                      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Insert a salient into the sorted list placed on top of the render  */
end_comment
begin_comment
comment|/*    pool.                                                              */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    New y scanline position.                                           */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    SUCCESS on success.  FAILURE in case of overflow.                  */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|Bool
DECL|function|Insert_Y_Turn
name|Insert_Y_Turn
parameter_list|(
name|RAS_ARGS
name|Int
name|y
parameter_list|)
block|{
name|PLong
name|y_turns
decl_stmt|;
name|Int
name|y2
decl_stmt|,
name|n
decl_stmt|;
name|n
operator|=
name|ras
operator|.
name|numTurns
operator|-
literal|1
expr_stmt|;
name|y_turns
operator|=
name|ras
operator|.
name|sizeBuff
operator|-
name|ras
operator|.
name|numTurns
expr_stmt|;
comment|/* look for first y value that is<= */
while|while
condition|(
name|n
operator|>=
literal|0
operator|&&
name|y
operator|<
name|y_turns
index|[
name|n
index|]
condition|)
name|n
operator|--
expr_stmt|;
comment|/* if it is<, simply insert it, ignore if == */
if|if
condition|(
name|n
operator|>=
literal|0
operator|&&
name|y
operator|>
name|y_turns
index|[
name|n
index|]
condition|)
while|while
condition|(
name|n
operator|>=
literal|0
condition|)
block|{
name|y2
operator|=
operator|(
name|Int
operator|)
name|y_turns
index|[
name|n
index|]
expr_stmt|;
name|y_turns
index|[
name|n
index|]
operator|=
name|y
expr_stmt|;
name|y
operator|=
name|y2
expr_stmt|;
name|n
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|ras
operator|.
name|maxBuff
operator|--
expr_stmt|;
if|if
condition|(
name|ras
operator|.
name|maxBuff
operator|<=
name|ras
operator|.
name|top
condition|)
block|{
name|ras
operator|.
name|error
operator|=
name|Raster_Err_Overflow
expr_stmt|;
return|return
name|FAILURE
return|;
block|}
name|ras
operator|.
name|numTurns
operator|++
expr_stmt|;
name|ras
operator|.
name|sizeBuff
index|[
operator|-
name|ras
operator|.
name|numTurns
index|]
operator|=
name|y
expr_stmt|;
block|}
return|return
name|SUCCESS
return|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    Finalize_Profile_Table                                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Adjust all links in the profiles list.                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    SUCCESS on success.  FAILURE in case of overflow.                  */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|Bool
DECL|function|Finalize_Profile_Table
name|Finalize_Profile_Table
parameter_list|(
name|RAS_ARG
parameter_list|)
block|{
name|Int
name|bottom
decl_stmt|,
name|top
decl_stmt|;
name|UShort
name|n
decl_stmt|;
name|PProfile
name|p
decl_stmt|;
name|n
operator|=
name|ras
operator|.
name|num_Profs
expr_stmt|;
name|p
operator|=
name|ras
operator|.
name|fProfile
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|1
operator|&&
name|p
condition|)
block|{
while|while
condition|(
name|n
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|n
operator|>
literal|1
condition|)
name|p
operator|->
name|link
operator|=
call|(
name|PProfile
call|)
argument_list|(
name|p
operator|->
name|offset
operator|+
name|p
operator|->
name|height
argument_list|)
expr_stmt|;
else|else
name|p
operator|->
name|link
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|flags
operator|&
name|Flow_Up
condition|)
block|{
name|bottom
operator|=
operator|(
name|Int
operator|)
name|p
operator|->
name|start
expr_stmt|;
name|top
operator|=
call|(
name|Int
call|)
argument_list|(
name|p
operator|->
name|start
operator|+
name|p
operator|->
name|height
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bottom
operator|=
call|(
name|Int
call|)
argument_list|(
name|p
operator|->
name|start
operator|-
name|p
operator|->
name|height
operator|+
literal|1
argument_list|)
expr_stmt|;
name|top
operator|=
operator|(
name|Int
operator|)
name|p
operator|->
name|start
expr_stmt|;
name|p
operator|->
name|start
operator|=
name|bottom
expr_stmt|;
name|p
operator|->
name|offset
operator|+=
name|p
operator|->
name|height
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|Insert_Y_Turn
argument_list|(
argument|RAS_VARS bottom
argument_list|)
operator|||
name|Insert_Y_Turn
argument_list|(
argument|RAS_VARS top +
literal|1
argument_list|)
condition|)
return|return
name|FAILURE
return|;
name|p
operator|=
name|p
operator|->
name|link
expr_stmt|;
name|n
operator|--
expr_stmt|;
block|}
block|}
else|else
name|ras
operator|.
name|fProfile
operator|=
name|NULL
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    Split_Conic                                                        */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Subdivide one conic Bezier into two joint sub-arcs in the Bezier   */
end_comment
begin_comment
comment|/*    stack.                                                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    None (subdivided Bezier is taken from the top of the stack).       */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Note>                                                                */
end_comment
begin_comment
comment|/*    This routine is the `beef' of this component.  It is  _the_ inner  */
end_comment
begin_comment
comment|/*    loop that should be optimized to hell to get the best performance. */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Split_Conic
name|Split_Conic
parameter_list|(
name|TPoint
modifier|*
name|base
parameter_list|)
block|{
name|Long
name|a
decl_stmt|,
name|b
decl_stmt|;
name|base
index|[
literal|4
index|]
operator|.
name|x
operator|=
name|base
index|[
literal|2
index|]
operator|.
name|x
expr_stmt|;
name|b
operator|=
name|base
index|[
literal|1
index|]
operator|.
name|x
expr_stmt|;
name|a
operator|=
name|base
index|[
literal|3
index|]
operator|.
name|x
operator|=
operator|(
name|base
index|[
literal|2
index|]
operator|.
name|x
operator|+
name|b
operator|)
operator|/
literal|2
expr_stmt|;
name|b
operator|=
name|base
index|[
literal|1
index|]
operator|.
name|x
operator|=
operator|(
name|base
index|[
literal|0
index|]
operator|.
name|x
operator|+
name|b
operator|)
operator|/
literal|2
expr_stmt|;
name|base
index|[
literal|2
index|]
operator|.
name|x
operator|=
operator|(
name|a
operator|+
name|b
operator|)
operator|/
literal|2
expr_stmt|;
name|base
index|[
literal|4
index|]
operator|.
name|y
operator|=
name|base
index|[
literal|2
index|]
operator|.
name|y
expr_stmt|;
name|b
operator|=
name|base
index|[
literal|1
index|]
operator|.
name|y
expr_stmt|;
name|a
operator|=
name|base
index|[
literal|3
index|]
operator|.
name|y
operator|=
operator|(
name|base
index|[
literal|2
index|]
operator|.
name|y
operator|+
name|b
operator|)
operator|/
literal|2
expr_stmt|;
name|b
operator|=
name|base
index|[
literal|1
index|]
operator|.
name|y
operator|=
operator|(
name|base
index|[
literal|0
index|]
operator|.
name|y
operator|+
name|b
operator|)
operator|/
literal|2
expr_stmt|;
name|base
index|[
literal|2
index|]
operator|.
name|y
operator|=
operator|(
name|a
operator|+
name|b
operator|)
operator|/
literal|2
expr_stmt|;
comment|/* hand optimized.  gcc doesn't seem to be too good at common      */
comment|/* expression substitution and instruction scheduling ;-)          */
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    Split_Cubic                                                        */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Subdivide a third-order Bezier arc into two joint sub-arcs in the  */
end_comment
begin_comment
comment|/*    Bezier stack.                                                      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Note>                                                                */
end_comment
begin_comment
comment|/*    This routine is the `beef' of the component.  It is one of _the_   */
end_comment
begin_comment
comment|/*    inner loops that should be optimized like hell to get the best     */
end_comment
begin_comment
comment|/*    performance.                                                       */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Split_Cubic
name|Split_Cubic
parameter_list|(
name|TPoint
modifier|*
name|base
parameter_list|)
block|{
name|Long
name|a
decl_stmt|,
name|b
decl_stmt|,
name|c
decl_stmt|,
name|d
decl_stmt|;
name|base
index|[
literal|6
index|]
operator|.
name|x
operator|=
name|base
index|[
literal|3
index|]
operator|.
name|x
expr_stmt|;
name|c
operator|=
name|base
index|[
literal|1
index|]
operator|.
name|x
expr_stmt|;
name|d
operator|=
name|base
index|[
literal|2
index|]
operator|.
name|x
expr_stmt|;
name|base
index|[
literal|1
index|]
operator|.
name|x
operator|=
name|a
operator|=
operator|(
name|base
index|[
literal|0
index|]
operator|.
name|x
operator|+
name|c
operator|+
literal|1
operator|)
operator|>>
literal|1
expr_stmt|;
name|base
index|[
literal|5
index|]
operator|.
name|x
operator|=
name|b
operator|=
operator|(
name|base
index|[
literal|3
index|]
operator|.
name|x
operator|+
name|d
operator|+
literal|1
operator|)
operator|>>
literal|1
expr_stmt|;
name|c
operator|=
operator|(
name|c
operator|+
name|d
operator|+
literal|1
operator|)
operator|>>
literal|1
expr_stmt|;
name|base
index|[
literal|2
index|]
operator|.
name|x
operator|=
name|a
operator|=
operator|(
name|a
operator|+
name|c
operator|+
literal|1
operator|)
operator|>>
literal|1
expr_stmt|;
name|base
index|[
literal|4
index|]
operator|.
name|x
operator|=
name|b
operator|=
operator|(
name|b
operator|+
name|c
operator|+
literal|1
operator|)
operator|>>
literal|1
expr_stmt|;
name|base
index|[
literal|3
index|]
operator|.
name|x
operator|=
operator|(
name|a
operator|+
name|b
operator|+
literal|1
operator|)
operator|>>
literal|1
expr_stmt|;
name|base
index|[
literal|6
index|]
operator|.
name|y
operator|=
name|base
index|[
literal|3
index|]
operator|.
name|y
expr_stmt|;
name|c
operator|=
name|base
index|[
literal|1
index|]
operator|.
name|y
expr_stmt|;
name|d
operator|=
name|base
index|[
literal|2
index|]
operator|.
name|y
expr_stmt|;
name|base
index|[
literal|1
index|]
operator|.
name|y
operator|=
name|a
operator|=
operator|(
name|base
index|[
literal|0
index|]
operator|.
name|y
operator|+
name|c
operator|+
literal|1
operator|)
operator|>>
literal|1
expr_stmt|;
name|base
index|[
literal|5
index|]
operator|.
name|y
operator|=
name|b
operator|=
operator|(
name|base
index|[
literal|3
index|]
operator|.
name|y
operator|+
name|d
operator|+
literal|1
operator|)
operator|>>
literal|1
expr_stmt|;
name|c
operator|=
operator|(
name|c
operator|+
name|d
operator|+
literal|1
operator|)
operator|>>
literal|1
expr_stmt|;
name|base
index|[
literal|2
index|]
operator|.
name|y
operator|=
name|a
operator|=
operator|(
name|a
operator|+
name|c
operator|+
literal|1
operator|)
operator|>>
literal|1
expr_stmt|;
name|base
index|[
literal|4
index|]
operator|.
name|y
operator|=
name|b
operator|=
operator|(
name|b
operator|+
name|c
operator|+
literal|1
operator|)
operator|>>
literal|1
expr_stmt|;
name|base
index|[
literal|3
index|]
operator|.
name|y
operator|=
operator|(
name|a
operator|+
name|b
operator|+
literal|1
operator|)
operator|>>
literal|1
expr_stmt|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    Line_Up                                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Compute the x-coordinates of an ascending line segment and store   */
end_comment
begin_comment
comment|/*    them in the render pool.                                           */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    x1   :: The x-coordinate of the segment's start point.             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    y1   :: The y-coordinate of the segment's start point.             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    x2   :: The x-coordinate of the segment's end point.               */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    y2   :: The y-coordinate of the segment's end point.               */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    miny :: A lower vertical clipping bound value.                     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    maxy :: An upper vertical clipping bound value.                    */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    SUCCESS on success, FAILURE on render pool overflow.               */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|Bool
DECL|function|Line_Up
name|Line_Up
parameter_list|(
name|RAS_ARGS
name|Long
name|x1
parameter_list|,
name|Long
name|y1
parameter_list|,
name|Long
name|x2
parameter_list|,
name|Long
name|y2
parameter_list|,
name|Long
name|miny
parameter_list|,
name|Long
name|maxy
parameter_list|)
block|{
name|Long
name|Dx
decl_stmt|,
name|Dy
decl_stmt|;
name|Int
name|e1
decl_stmt|,
name|e2
decl_stmt|,
name|f1
decl_stmt|,
name|f2
decl_stmt|,
name|size
decl_stmt|;
comment|/* XXX: is `Short' sufficient? */
name|Long
name|Ix
decl_stmt|,
name|Rx
decl_stmt|,
name|Ax
decl_stmt|;
name|PLong
name|top
decl_stmt|;
name|Dx
operator|=
name|x2
operator|-
name|x1
expr_stmt|;
name|Dy
operator|=
name|y2
operator|-
name|y1
expr_stmt|;
if|if
condition|(
name|Dy
operator|<=
literal|0
operator|||
name|y2
operator|<
name|miny
operator|||
name|y1
operator|>
name|maxy
condition|)
return|return
name|SUCCESS
return|;
if|if
condition|(
name|y1
operator|<
name|miny
condition|)
block|{
comment|/* Take care: miny-y1 can be a very large value; we use     */
comment|/*            a slow MulDiv function to avoid clipping bugs */
name|x1
operator|+=
name|SMulDiv
argument_list|(
name|Dx
argument_list|,
name|miny
operator|-
name|y1
argument_list|,
name|Dy
argument_list|)
expr_stmt|;
name|e1
operator|=
operator|(
name|Int
operator|)
name|TRUNC
argument_list|(
name|miny
argument_list|)
expr_stmt|;
name|f1
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|e1
operator|=
operator|(
name|Int
operator|)
name|TRUNC
argument_list|(
name|y1
argument_list|)
expr_stmt|;
name|f1
operator|=
operator|(
name|Int
operator|)
name|FRAC
argument_list|(
name|y1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|y2
operator|>
name|maxy
condition|)
block|{
comment|/* x2 += FMulDiv( Dx, maxy - y2, Dy );  UNNECESSARY */
name|e2
operator|=
operator|(
name|Int
operator|)
name|TRUNC
argument_list|(
name|maxy
argument_list|)
expr_stmt|;
name|f2
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|e2
operator|=
operator|(
name|Int
operator|)
name|TRUNC
argument_list|(
name|y2
argument_list|)
expr_stmt|;
name|f2
operator|=
operator|(
name|Int
operator|)
name|FRAC
argument_list|(
name|y2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|f1
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|e1
operator|==
name|e2
condition|)
return|return
name|SUCCESS
return|;
else|else
block|{
name|x1
operator|+=
name|FMulDiv
argument_list|(
name|Dx
argument_list|,
name|ras
operator|.
name|precision
operator|-
name|f1
argument_list|,
name|Dy
argument_list|)
expr_stmt|;
name|e1
operator|+=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ras
operator|.
name|joint
condition|)
block|{
name|ras
operator|.
name|top
operator|--
expr_stmt|;
name|ras
operator|.
name|joint
operator|=
name|FALSE
expr_stmt|;
block|}
name|ras
operator|.
name|joint
operator|=
call|(
name|char
call|)
argument_list|(
name|f2
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ras
operator|.
name|fresh
condition|)
block|{
name|ras
operator|.
name|cProfile
operator|->
name|start
operator|=
name|e1
expr_stmt|;
name|ras
operator|.
name|fresh
operator|=
name|FALSE
expr_stmt|;
block|}
name|size
operator|=
name|e2
operator|-
name|e1
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|ras
operator|.
name|top
operator|+
name|size
operator|>=
name|ras
operator|.
name|maxBuff
condition|)
block|{
name|ras
operator|.
name|error
operator|=
name|Raster_Err_Overflow
expr_stmt|;
return|return
name|FAILURE
return|;
block|}
if|if
condition|(
name|Dx
operator|>
literal|0
condition|)
block|{
name|Ix
operator|=
operator|(
name|ras
operator|.
name|precision
operator|*
name|Dx
operator|)
operator|/
name|Dy
expr_stmt|;
name|Rx
operator|=
operator|(
name|ras
operator|.
name|precision
operator|*
name|Dx
operator|)
operator|%
name|Dy
expr_stmt|;
name|Dx
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|Ix
operator|=
operator|-
operator|(
operator|(
name|ras
operator|.
name|precision
operator|*
operator|-
name|Dx
operator|)
operator|/
name|Dy
operator|)
expr_stmt|;
name|Rx
operator|=
operator|(
name|ras
operator|.
name|precision
operator|*
operator|-
name|Dx
operator|)
operator|%
name|Dy
expr_stmt|;
name|Dx
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|Ax
operator|=
operator|-
name|Dy
expr_stmt|;
name|top
operator|=
name|ras
operator|.
name|top
expr_stmt|;
while|while
condition|(
name|size
operator|>
literal|0
condition|)
block|{
operator|*
name|top
operator|++
operator|=
name|x1
expr_stmt|;
name|x1
operator|+=
name|Ix
expr_stmt|;
name|Ax
operator|+=
name|Rx
expr_stmt|;
if|if
condition|(
name|Ax
operator|>=
literal|0
condition|)
block|{
name|Ax
operator|-=
name|Dy
expr_stmt|;
name|x1
operator|+=
name|Dx
expr_stmt|;
block|}
name|size
operator|--
expr_stmt|;
block|}
name|ras
operator|.
name|top
operator|=
name|top
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    Line_Down                                                          */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Compute the x-coordinates of an descending line segment and store  */
end_comment
begin_comment
comment|/*    them in the render pool.                                           */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    x1   :: The x-coordinate of the segment's start point.             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    y1   :: The y-coordinate of the segment's start point.             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    x2   :: The x-coordinate of the segment's end point.               */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    y2   :: The y-coordinate of the segment's end point.               */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    miny :: A lower vertical clipping bound value.                     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    maxy :: An upper vertical clipping bound value.                    */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    SUCCESS on success, FAILURE on render pool overflow.               */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|Bool
DECL|function|Line_Down
name|Line_Down
parameter_list|(
name|RAS_ARGS
name|Long
name|x1
parameter_list|,
name|Long
name|y1
parameter_list|,
name|Long
name|x2
parameter_list|,
name|Long
name|y2
parameter_list|,
name|Long
name|miny
parameter_list|,
name|Long
name|maxy
parameter_list|)
block|{
name|Bool
name|result
decl_stmt|,
name|fresh
decl_stmt|;
name|fresh
operator|=
name|ras
operator|.
name|fresh
expr_stmt|;
name|result
operator|=
name|Line_Up
argument_list|(
argument|RAS_VARS x1
argument_list|,
argument|-y1
argument_list|,
argument|x2
argument_list|,
argument|-y2
argument_list|,
argument|-maxy
argument_list|,
argument|-miny
argument_list|)
expr_stmt|;
if|if
condition|(
name|fresh
operator|&&
operator|!
name|ras
operator|.
name|fresh
condition|)
name|ras
operator|.
name|cProfile
operator|->
name|start
operator|=
operator|-
name|ras
operator|.
name|cProfile
operator|->
name|start
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/* A function type describing the functions used to split Bezier arcs */
end_comment
begin_typedef
DECL|typedef|TSplitter
typedef|typedef
name|void
function_decl|(
modifier|*
name|TSplitter
function_decl|)
parameter_list|(
name|TPoint
modifier|*
name|base
parameter_list|)
function_decl|;
end_typedef
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    Bezier_Up                                                          */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Compute the x-coordinates of an ascending Bezier arc and store     */
end_comment
begin_comment
comment|/*    them in the render pool.                                           */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    degree   :: The degree of the Bezier arc (either 2 or 3).          */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    splitter :: The function to split Bezier arcs.                     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    miny     :: A lower vertical clipping bound value.                 */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    maxy     :: An upper vertical clipping bound value.                */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    SUCCESS on success, FAILURE on render pool overflow.               */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|Bool
DECL|function|Bezier_Up
name|Bezier_Up
parameter_list|(
name|RAS_ARGS
name|Int
name|degree
parameter_list|,
name|TSplitter
name|splitter
parameter_list|,
name|Long
name|miny
parameter_list|,
name|Long
name|maxy
parameter_list|)
block|{
name|Long
name|y1
decl_stmt|,
name|y2
decl_stmt|,
name|e
decl_stmt|,
name|e2
decl_stmt|,
name|e0
decl_stmt|;
name|Short
name|f1
decl_stmt|;
name|TPoint
modifier|*
name|arc
decl_stmt|;
name|TPoint
modifier|*
name|start_arc
decl_stmt|;
name|PLong
name|top
decl_stmt|;
name|arc
operator|=
name|ras
operator|.
name|arc
expr_stmt|;
name|y1
operator|=
name|arc
index|[
name|degree
index|]
operator|.
name|y
expr_stmt|;
name|y2
operator|=
name|arc
index|[
literal|0
index|]
operator|.
name|y
expr_stmt|;
name|top
operator|=
name|ras
operator|.
name|top
expr_stmt|;
if|if
condition|(
name|y2
operator|<
name|miny
operator|||
name|y1
operator|>
name|maxy
condition|)
goto|goto
name|Fin
goto|;
name|e2
operator|=
name|FLOOR
argument_list|(
name|y2
argument_list|)
expr_stmt|;
if|if
condition|(
name|e2
operator|>
name|maxy
condition|)
name|e2
operator|=
name|maxy
expr_stmt|;
name|e0
operator|=
name|miny
expr_stmt|;
if|if
condition|(
name|y1
operator|<
name|miny
condition|)
name|e
operator|=
name|miny
expr_stmt|;
else|else
block|{
name|e
operator|=
name|CEILING
argument_list|(
name|y1
argument_list|)
expr_stmt|;
name|f1
operator|=
call|(
name|Short
call|)
argument_list|(
name|FRAC
argument_list|(
name|y1
argument_list|)
argument_list|)
expr_stmt|;
name|e0
operator|=
name|e
expr_stmt|;
if|if
condition|(
name|f1
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ras
operator|.
name|joint
condition|)
block|{
name|top
operator|--
expr_stmt|;
name|ras
operator|.
name|joint
operator|=
name|FALSE
expr_stmt|;
block|}
operator|*
name|top
operator|++
operator|=
name|arc
index|[
name|degree
index|]
operator|.
name|x
expr_stmt|;
name|e
operator|+=
name|ras
operator|.
name|precision
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ras
operator|.
name|fresh
condition|)
block|{
name|ras
operator|.
name|cProfile
operator|->
name|start
operator|=
name|TRUNC
argument_list|(
name|e0
argument_list|)
expr_stmt|;
name|ras
operator|.
name|fresh
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|e2
operator|<
name|e
condition|)
goto|goto
name|Fin
goto|;
if|if
condition|(
operator|(
name|top
operator|+
name|TRUNC
argument_list|(
name|e2
operator|-
name|e
argument_list|)
operator|+
literal|1
operator|)
operator|>=
name|ras
operator|.
name|maxBuff
condition|)
block|{
name|ras
operator|.
name|top
operator|=
name|top
expr_stmt|;
name|ras
operator|.
name|error
operator|=
name|Raster_Err_Overflow
expr_stmt|;
return|return
name|FAILURE
return|;
block|}
name|start_arc
operator|=
name|arc
expr_stmt|;
while|while
condition|(
name|arc
operator|>=
name|start_arc
operator|&&
name|e
operator|<=
name|e2
condition|)
block|{
name|ras
operator|.
name|joint
operator|=
name|FALSE
expr_stmt|;
name|y2
operator|=
name|arc
index|[
literal|0
index|]
operator|.
name|y
expr_stmt|;
if|if
condition|(
name|y2
operator|>
name|e
condition|)
block|{
name|y1
operator|=
name|arc
index|[
name|degree
index|]
operator|.
name|y
expr_stmt|;
if|if
condition|(
name|y2
operator|-
name|y1
operator|>=
name|ras
operator|.
name|precision_step
condition|)
block|{
name|splitter
argument_list|(
name|arc
argument_list|)
expr_stmt|;
name|arc
operator|+=
name|degree
expr_stmt|;
block|}
else|else
block|{
operator|*
name|top
operator|++
operator|=
name|arc
index|[
name|degree
index|]
operator|.
name|x
operator|+
name|FMulDiv
argument_list|(
name|arc
index|[
literal|0
index|]
operator|.
name|x
operator|-
name|arc
index|[
name|degree
index|]
operator|.
name|x
argument_list|,
name|e
operator|-
name|y1
argument_list|,
name|y2
operator|-
name|y1
argument_list|)
expr_stmt|;
name|arc
operator|-=
name|degree
expr_stmt|;
name|e
operator|+=
name|ras
operator|.
name|precision
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|y2
operator|==
name|e
condition|)
block|{
name|ras
operator|.
name|joint
operator|=
name|TRUE
expr_stmt|;
operator|*
name|top
operator|++
operator|=
name|arc
index|[
literal|0
index|]
operator|.
name|x
expr_stmt|;
name|e
operator|+=
name|ras
operator|.
name|precision
expr_stmt|;
block|}
name|arc
operator|-=
name|degree
expr_stmt|;
block|}
block|}
name|Fin
label|:
name|ras
operator|.
name|top
operator|=
name|top
expr_stmt|;
name|ras
operator|.
name|arc
operator|-=
name|degree
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    Bezier_Down                                                        */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Compute the x-coordinates of an descending Bezier arc and store    */
end_comment
begin_comment
comment|/*    them in the render pool.                                           */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    degree   :: The degree of the Bezier arc (either 2 or 3).          */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    splitter :: The function to split Bezier arcs.                     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    miny     :: A lower vertical clipping bound value.                 */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    maxy     :: An upper vertical clipping bound value.                */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    SUCCESS on success, FAILURE on render pool overflow.               */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|Bool
DECL|function|Bezier_Down
name|Bezier_Down
parameter_list|(
name|RAS_ARGS
name|Int
name|degree
parameter_list|,
name|TSplitter
name|splitter
parameter_list|,
name|Long
name|miny
parameter_list|,
name|Long
name|maxy
parameter_list|)
block|{
name|TPoint
modifier|*
name|arc
init|=
name|ras
operator|.
name|arc
decl_stmt|;
name|Bool
name|result
decl_stmt|,
name|fresh
decl_stmt|;
name|arc
index|[
literal|0
index|]
operator|.
name|y
operator|=
operator|-
name|arc
index|[
literal|0
index|]
operator|.
name|y
expr_stmt|;
name|arc
index|[
literal|1
index|]
operator|.
name|y
operator|=
operator|-
name|arc
index|[
literal|1
index|]
operator|.
name|y
expr_stmt|;
name|arc
index|[
literal|2
index|]
operator|.
name|y
operator|=
operator|-
name|arc
index|[
literal|2
index|]
operator|.
name|y
expr_stmt|;
if|if
condition|(
name|degree
operator|>
literal|2
condition|)
name|arc
index|[
literal|3
index|]
operator|.
name|y
operator|=
operator|-
name|arc
index|[
literal|3
index|]
operator|.
name|y
expr_stmt|;
name|fresh
operator|=
name|ras
operator|.
name|fresh
expr_stmt|;
name|result
operator|=
name|Bezier_Up
argument_list|(
argument|RAS_VARS degree
argument_list|,
argument|splitter
argument_list|,
argument|-maxy
argument_list|,
argument|-miny
argument_list|)
expr_stmt|;
if|if
condition|(
name|fresh
operator|&&
operator|!
name|ras
operator|.
name|fresh
condition|)
name|ras
operator|.
name|cProfile
operator|->
name|start
operator|=
operator|-
name|ras
operator|.
name|cProfile
operator|->
name|start
expr_stmt|;
name|arc
index|[
literal|0
index|]
operator|.
name|y
operator|=
operator|-
name|arc
index|[
literal|0
index|]
operator|.
name|y
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    Line_To                                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Inject a new line segment and adjust the Profiles list.            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*   x :: The x-coordinate of the segment's end point (its start point   */
end_comment
begin_comment
comment|/*        is stored in `lastX').                                         */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*   y :: The y-coordinate of the segment's end point (its start point   */
end_comment
begin_comment
comment|/*        is stored in `lastY').                                         */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*   SUCCESS on success, FAILURE on render pool overflow or incorrect    */
end_comment
begin_comment
comment|/*   profile.                                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|Bool
DECL|function|Line_To
name|Line_To
parameter_list|(
name|RAS_ARGS
name|Long
name|x
parameter_list|,
name|Long
name|y
parameter_list|)
block|{
comment|/* First, detect a change of direction */
switch|switch
condition|(
name|ras
operator|.
name|state
condition|)
block|{
case|case
name|Unknown_State
case|:
if|if
condition|(
name|y
operator|>
name|ras
operator|.
name|lastY
condition|)
block|{
if|if
condition|(
name|New_Profile
argument_list|(
argument|RAS_VARS Ascending_State
argument_list|,
argument|IS_BOTTOM_OVERSHOOT( ras.lastY )
argument_list|)
condition|)
return|return
name|FAILURE
return|;
block|}
else|else
block|{
if|if
condition|(
name|y
operator|<
name|ras
operator|.
name|lastY
condition|)
if|if
condition|(
name|New_Profile
argument_list|(
argument|RAS_VARS Descending_State
argument_list|,
argument|IS_TOP_OVERSHOOT( ras.lastY )
argument_list|)
condition|)
return|return
name|FAILURE
return|;
block|}
break|break;
case|case
name|Ascending_State
case|:
if|if
condition|(
name|y
operator|<
name|ras
operator|.
name|lastY
condition|)
block|{
if|if
condition|(
name|End_Profile
argument_list|(
argument|RAS_VARS IS_TOP_OVERSHOOT( ras.lastY )
argument_list|)
operator|||
name|New_Profile
argument_list|(
argument|RAS_VARS Descending_State
argument_list|,
argument|IS_TOP_OVERSHOOT( ras.lastY )
argument_list|)
condition|)
return|return
name|FAILURE
return|;
block|}
break|break;
case|case
name|Descending_State
case|:
if|if
condition|(
name|y
operator|>
name|ras
operator|.
name|lastY
condition|)
block|{
if|if
condition|(
name|End_Profile
argument_list|(
argument|RAS_VARS IS_BOTTOM_OVERSHOOT( ras.lastY )
argument_list|)
operator|||
name|New_Profile
argument_list|(
argument|RAS_VARS Ascending_State
argument_list|,
argument|IS_BOTTOM_OVERSHOOT( ras.lastY )
argument_list|)
condition|)
return|return
name|FAILURE
return|;
block|}
break|break;
default|default:
empty_stmt|;
block|}
comment|/* Then compute the lines */
switch|switch
condition|(
name|ras
operator|.
name|state
condition|)
block|{
case|case
name|Ascending_State
case|:
if|if
condition|(
name|Line_Up
argument_list|(
argument|RAS_VARS ras.lastX
argument_list|,
argument|ras.lastY
argument_list|,
argument|x
argument_list|,
argument|y
argument_list|,
argument|ras.minY
argument_list|,
argument|ras.maxY
argument_list|)
condition|)
return|return
name|FAILURE
return|;
break|break;
case|case
name|Descending_State
case|:
if|if
condition|(
name|Line_Down
argument_list|(
argument|RAS_VARS ras.lastX
argument_list|,
argument|ras.lastY
argument_list|,
argument|x
argument_list|,
argument|y
argument_list|,
argument|ras.minY
argument_list|,
argument|ras.maxY
argument_list|)
condition|)
return|return
name|FAILURE
return|;
break|break;
default|default:
empty_stmt|;
block|}
name|ras
operator|.
name|lastX
operator|=
name|x
expr_stmt|;
name|ras
operator|.
name|lastY
operator|=
name|y
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    Conic_To                                                           */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Inject a new conic arc and adjust the profile list.                */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*   cx :: The x-coordinate of the arc's new control point.              */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*   cy :: The y-coordinate of the arc's new control point.              */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*   x  :: The x-coordinate of the arc's end point (its start point is   */
end_comment
begin_comment
comment|/*         stored in `lastX').                                           */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*   y  :: The y-coordinate of the arc's end point (its start point is   */
end_comment
begin_comment
comment|/*         stored in `lastY').                                           */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*   SUCCESS on success, FAILURE on render pool overflow or incorrect    */
end_comment
begin_comment
comment|/*   profile.                                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|Bool
DECL|function|Conic_To
name|Conic_To
parameter_list|(
name|RAS_ARGS
name|Long
name|cx
parameter_list|,
name|Long
name|cy
parameter_list|,
name|Long
name|x
parameter_list|,
name|Long
name|y
parameter_list|)
block|{
name|Long
name|y1
decl_stmt|,
name|y2
decl_stmt|,
name|y3
decl_stmt|,
name|x3
decl_stmt|,
name|ymin
decl_stmt|,
name|ymax
decl_stmt|;
name|TStates
name|state_bez
decl_stmt|;
name|ras
operator|.
name|arc
operator|=
name|ras
operator|.
name|arcs
expr_stmt|;
name|ras
operator|.
name|arc
index|[
literal|2
index|]
operator|.
name|x
operator|=
name|ras
operator|.
name|lastX
expr_stmt|;
name|ras
operator|.
name|arc
index|[
literal|2
index|]
operator|.
name|y
operator|=
name|ras
operator|.
name|lastY
expr_stmt|;
name|ras
operator|.
name|arc
index|[
literal|1
index|]
operator|.
name|x
operator|=
name|cx
expr_stmt|;
name|ras
operator|.
name|arc
index|[
literal|1
index|]
operator|.
name|y
operator|=
name|cy
expr_stmt|;
name|ras
operator|.
name|arc
index|[
literal|0
index|]
operator|.
name|x
operator|=
name|x
expr_stmt|;
name|ras
operator|.
name|arc
index|[
literal|0
index|]
operator|.
name|y
operator|=
name|y
expr_stmt|;
do|do
block|{
name|y1
operator|=
name|ras
operator|.
name|arc
index|[
literal|2
index|]
operator|.
name|y
expr_stmt|;
name|y2
operator|=
name|ras
operator|.
name|arc
index|[
literal|1
index|]
operator|.
name|y
expr_stmt|;
name|y3
operator|=
name|ras
operator|.
name|arc
index|[
literal|0
index|]
operator|.
name|y
expr_stmt|;
name|x3
operator|=
name|ras
operator|.
name|arc
index|[
literal|0
index|]
operator|.
name|x
expr_stmt|;
comment|/* first, categorize the Bezier arc */
if|if
condition|(
name|y1
operator|<=
name|y3
condition|)
block|{
name|ymin
operator|=
name|y1
expr_stmt|;
name|ymax
operator|=
name|y3
expr_stmt|;
block|}
else|else
block|{
name|ymin
operator|=
name|y3
expr_stmt|;
name|ymax
operator|=
name|y1
expr_stmt|;
block|}
if|if
condition|(
name|y2
operator|<
name|ymin
operator|||
name|y2
operator|>
name|ymax
condition|)
block|{
comment|/* this arc has no given direction, split it! */
name|Split_Conic
argument_list|(
name|ras
operator|.
name|arc
argument_list|)
expr_stmt|;
name|ras
operator|.
name|arc
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|y1
operator|==
name|y3
condition|)
block|{
comment|/* this arc is flat, ignore it and pop it from the Bezier stack */
name|ras
operator|.
name|arc
operator|-=
literal|2
expr_stmt|;
block|}
else|else
block|{
comment|/* the arc is y-monotonous, either ascending or descending */
comment|/* detect a change of direction                            */
name|state_bez
operator|=
name|y1
operator|<
name|y3
condition|?
name|Ascending_State
else|:
name|Descending_State
expr_stmt|;
if|if
condition|(
name|ras
operator|.
name|state
operator|!=
name|state_bez
condition|)
block|{
name|Bool
name|o
init|=
name|state_bez
operator|==
name|Ascending_State
condition|?
name|IS_BOTTOM_OVERSHOOT
argument_list|(
name|y1
argument_list|)
else|:
name|IS_TOP_OVERSHOOT
argument_list|(
name|y1
argument_list|)
decl_stmt|;
comment|/* finalize current profile if any */
if|if
condition|(
name|ras
operator|.
name|state
operator|!=
name|Unknown_State
operator|&&
name|End_Profile
argument_list|(
argument|RAS_VARS o
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
comment|/* create a new profile */
if|if
condition|(
name|New_Profile
argument_list|(
argument|RAS_VARS state_bez
argument_list|,
argument|o
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
block|}
comment|/* now call the appropriate routine */
if|if
condition|(
name|state_bez
operator|==
name|Ascending_State
condition|)
block|{
if|if
condition|(
name|Bezier_Up
argument_list|(
name|RAS_VARS
literal|2
argument_list|,
name|Split_Conic
argument_list|,
name|ras
operator|.
name|minY
argument_list|,
name|ras
operator|.
name|maxY
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
block|}
elseif|else
if|if
condition|(
name|Bezier_Down
argument_list|(
name|RAS_VARS
literal|2
argument_list|,
name|Split_Conic
argument_list|,
name|ras
operator|.
name|minY
argument_list|,
name|ras
operator|.
name|maxY
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
block|}
block|}
do|while
condition|(
name|ras
operator|.
name|arc
operator|>=
name|ras
operator|.
name|arcs
condition|)
do|;
name|ras
operator|.
name|lastX
operator|=
name|x3
expr_stmt|;
name|ras
operator|.
name|lastY
operator|=
name|y3
expr_stmt|;
return|return
name|SUCCESS
return|;
name|Fail
label|:
return|return
name|FAILURE
return|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    Cubic_To                                                           */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Inject a new cubic arc and adjust the profile list.                */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*   cx1 :: The x-coordinate of the arc's first new control point.       */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*   cy1 :: The y-coordinate of the arc's first new control point.       */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*   cx2 :: The x-coordinate of the arc's second new control point.      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*   cy2 :: The y-coordinate of the arc's second new control point.      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*   x   :: The x-coordinate of the arc's end point (its start point is  */
end_comment
begin_comment
comment|/*          stored in `lastX').                                          */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*   y   :: The y-coordinate of the arc's end point (its start point is  */
end_comment
begin_comment
comment|/*          stored in `lastY').                                          */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*   SUCCESS on success, FAILURE on render pool overflow or incorrect    */
end_comment
begin_comment
comment|/*   profile.                                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|Bool
DECL|function|Cubic_To
name|Cubic_To
parameter_list|(
name|RAS_ARGS
name|Long
name|cx1
parameter_list|,
name|Long
name|cy1
parameter_list|,
name|Long
name|cx2
parameter_list|,
name|Long
name|cy2
parameter_list|,
name|Long
name|x
parameter_list|,
name|Long
name|y
parameter_list|)
block|{
name|Long
name|y1
decl_stmt|,
name|y2
decl_stmt|,
name|y3
decl_stmt|,
name|y4
decl_stmt|,
name|x4
decl_stmt|,
name|ymin1
decl_stmt|,
name|ymax1
decl_stmt|,
name|ymin2
decl_stmt|,
name|ymax2
decl_stmt|;
name|TStates
name|state_bez
decl_stmt|;
name|ras
operator|.
name|arc
operator|=
name|ras
operator|.
name|arcs
expr_stmt|;
name|ras
operator|.
name|arc
index|[
literal|3
index|]
operator|.
name|x
operator|=
name|ras
operator|.
name|lastX
expr_stmt|;
name|ras
operator|.
name|arc
index|[
literal|3
index|]
operator|.
name|y
operator|=
name|ras
operator|.
name|lastY
expr_stmt|;
name|ras
operator|.
name|arc
index|[
literal|2
index|]
operator|.
name|x
operator|=
name|cx1
expr_stmt|;
name|ras
operator|.
name|arc
index|[
literal|2
index|]
operator|.
name|y
operator|=
name|cy1
expr_stmt|;
name|ras
operator|.
name|arc
index|[
literal|1
index|]
operator|.
name|x
operator|=
name|cx2
expr_stmt|;
name|ras
operator|.
name|arc
index|[
literal|1
index|]
operator|.
name|y
operator|=
name|cy2
expr_stmt|;
name|ras
operator|.
name|arc
index|[
literal|0
index|]
operator|.
name|x
operator|=
name|x
expr_stmt|;
name|ras
operator|.
name|arc
index|[
literal|0
index|]
operator|.
name|y
operator|=
name|y
expr_stmt|;
do|do
block|{
name|y1
operator|=
name|ras
operator|.
name|arc
index|[
literal|3
index|]
operator|.
name|y
expr_stmt|;
name|y2
operator|=
name|ras
operator|.
name|arc
index|[
literal|2
index|]
operator|.
name|y
expr_stmt|;
name|y3
operator|=
name|ras
operator|.
name|arc
index|[
literal|1
index|]
operator|.
name|y
expr_stmt|;
name|y4
operator|=
name|ras
operator|.
name|arc
index|[
literal|0
index|]
operator|.
name|y
expr_stmt|;
name|x4
operator|=
name|ras
operator|.
name|arc
index|[
literal|0
index|]
operator|.
name|x
expr_stmt|;
comment|/* first, categorize the Bezier arc */
if|if
condition|(
name|y1
operator|<=
name|y4
condition|)
block|{
name|ymin1
operator|=
name|y1
expr_stmt|;
name|ymax1
operator|=
name|y4
expr_stmt|;
block|}
else|else
block|{
name|ymin1
operator|=
name|y4
expr_stmt|;
name|ymax1
operator|=
name|y1
expr_stmt|;
block|}
if|if
condition|(
name|y2
operator|<=
name|y3
condition|)
block|{
name|ymin2
operator|=
name|y2
expr_stmt|;
name|ymax2
operator|=
name|y3
expr_stmt|;
block|}
else|else
block|{
name|ymin2
operator|=
name|y3
expr_stmt|;
name|ymax2
operator|=
name|y2
expr_stmt|;
block|}
if|if
condition|(
name|ymin2
operator|<
name|ymin1
operator|||
name|ymax2
operator|>
name|ymax1
condition|)
block|{
comment|/* this arc has no given direction, split it! */
name|Split_Cubic
argument_list|(
name|ras
operator|.
name|arc
argument_list|)
expr_stmt|;
name|ras
operator|.
name|arc
operator|+=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|y1
operator|==
name|y4
condition|)
block|{
comment|/* this arc is flat, ignore it and pop it from the Bezier stack */
name|ras
operator|.
name|arc
operator|-=
literal|3
expr_stmt|;
block|}
else|else
block|{
name|state_bez
operator|=
operator|(
name|y1
operator|<=
name|y4
operator|)
condition|?
name|Ascending_State
else|:
name|Descending_State
expr_stmt|;
comment|/* detect a change of direction */
if|if
condition|(
name|ras
operator|.
name|state
operator|!=
name|state_bez
condition|)
block|{
name|Bool
name|o
init|=
name|state_bez
operator|==
name|Ascending_State
condition|?
name|IS_BOTTOM_OVERSHOOT
argument_list|(
name|y1
argument_list|)
else|:
name|IS_TOP_OVERSHOOT
argument_list|(
name|y1
argument_list|)
decl_stmt|;
comment|/* finalize current profile if any */
if|if
condition|(
name|ras
operator|.
name|state
operator|!=
name|Unknown_State
operator|&&
name|End_Profile
argument_list|(
argument|RAS_VARS o
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
if|if
condition|(
name|New_Profile
argument_list|(
argument|RAS_VARS state_bez
argument_list|,
argument|o
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
block|}
comment|/* compute intersections */
if|if
condition|(
name|state_bez
operator|==
name|Ascending_State
condition|)
block|{
if|if
condition|(
name|Bezier_Up
argument_list|(
name|RAS_VARS
literal|3
argument_list|,
name|Split_Cubic
argument_list|,
name|ras
operator|.
name|minY
argument_list|,
name|ras
operator|.
name|maxY
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
block|}
elseif|else
if|if
condition|(
name|Bezier_Down
argument_list|(
name|RAS_VARS
literal|3
argument_list|,
name|Split_Cubic
argument_list|,
name|ras
operator|.
name|minY
argument_list|,
name|ras
operator|.
name|maxY
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
block|}
block|}
do|while
condition|(
name|ras
operator|.
name|arc
operator|>=
name|ras
operator|.
name|arcs
condition|)
do|;
name|ras
operator|.
name|lastX
operator|=
name|x4
expr_stmt|;
name|ras
operator|.
name|lastY
operator|=
name|y4
expr_stmt|;
return|return
name|SUCCESS
return|;
name|Fail
label|:
return|return
name|FAILURE
return|;
block|}
end_function
begin_undef
DECL|macro|SWAP_
undef|#
directive|undef
name|SWAP_
end_undef
begin_define
DECL|macro|SWAP_
define|#
directive|define
name|SWAP_
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|do                \                        {                 \                          Long  swap = x; \                                          \                                          \                          x = y;          \                          y = swap;       \                        } while ( 0 )
end_define
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    Decompose_Curve                                                    */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Scan the outline arrays in order to emit individual segments and   */
end_comment
begin_comment
comment|/*    Beziers by calling Line_To() and Bezier_To().  It handles all      */
end_comment
begin_comment
comment|/*    weird cases, like when the first point is off the curve, or when   */
end_comment
begin_comment
comment|/*    there are simply no `on' points in the contour!                    */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    first   :: The index of the first point in the contour.            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    last    :: The index of the last point in the contour.             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    flipped :: If set, flip the direction of the curve.                */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    SUCCESS on success, FAILURE on error.                              */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|Bool
DECL|function|Decompose_Curve
name|Decompose_Curve
parameter_list|(
name|RAS_ARGS
name|UShort
name|first
parameter_list|,
name|UShort
name|last
parameter_list|,
name|int
name|flipped
parameter_list|)
block|{
name|FT_Vector
name|v_last
decl_stmt|;
name|FT_Vector
name|v_control
decl_stmt|;
name|FT_Vector
name|v_start
decl_stmt|;
name|FT_Vector
modifier|*
name|points
decl_stmt|;
name|FT_Vector
modifier|*
name|point
decl_stmt|;
name|FT_Vector
modifier|*
name|limit
decl_stmt|;
name|char
modifier|*
name|tags
decl_stmt|;
name|unsigned
name|tag
decl_stmt|;
comment|/* current point's state           */
name|points
operator|=
name|ras
operator|.
name|outline
operator|.
name|points
expr_stmt|;
name|limit
operator|=
name|points
operator|+
name|last
expr_stmt|;
name|v_start
operator|.
name|x
operator|=
name|SCALED
argument_list|(
name|points
index|[
name|first
index|]
operator|.
name|x
argument_list|)
expr_stmt|;
name|v_start
operator|.
name|y
operator|=
name|SCALED
argument_list|(
name|points
index|[
name|first
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
name|v_last
operator|.
name|x
operator|=
name|SCALED
argument_list|(
name|points
index|[
name|last
index|]
operator|.
name|x
argument_list|)
expr_stmt|;
name|v_last
operator|.
name|y
operator|=
name|SCALED
argument_list|(
name|points
index|[
name|last
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|flipped
condition|)
block|{
name|SWAP_
argument_list|(
name|v_start
operator|.
name|x
argument_list|,
name|v_start
operator|.
name|y
argument_list|)
expr_stmt|;
name|SWAP_
argument_list|(
name|v_last
operator|.
name|x
argument_list|,
name|v_last
operator|.
name|y
argument_list|)
expr_stmt|;
block|}
name|v_control
operator|=
name|v_start
expr_stmt|;
name|point
operator|=
name|points
operator|+
name|first
expr_stmt|;
name|tags
operator|=
name|ras
operator|.
name|outline
operator|.
name|tags
operator|+
name|first
expr_stmt|;
comment|/* set scan mode if necessary */
if|if
condition|(
name|tags
index|[
literal|0
index|]
operator|&
name|FT_CURVE_TAG_HAS_SCANMODE
condition|)
name|ras
operator|.
name|dropOutControl
operator|=
operator|(
name|Byte
operator|)
name|tags
index|[
literal|0
index|]
operator|>>
literal|5
expr_stmt|;
name|tag
operator|=
name|FT_CURVE_TAG
argument_list|(
name|tags
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* A contour cannot start with a cubic control point! */
if|if
condition|(
name|tag
operator|==
name|FT_CURVE_TAG_CUBIC
condition|)
goto|goto
name|Invalid_Outline
goto|;
comment|/* check first point to determine origin */
if|if
condition|(
name|tag
operator|==
name|FT_CURVE_TAG_CONIC
condition|)
block|{
comment|/* first point is conic control.  Yes, this happens. */
if|if
condition|(
name|FT_CURVE_TAG
argument_list|(
name|ras
operator|.
name|outline
operator|.
name|tags
index|[
name|last
index|]
argument_list|)
operator|==
name|FT_CURVE_TAG_ON
condition|)
block|{
comment|/* start at last point if it is on the curve */
name|v_start
operator|=
name|v_last
expr_stmt|;
name|limit
operator|--
expr_stmt|;
block|}
else|else
block|{
comment|/* if both first and last points are conic,         */
comment|/* start at their middle and record its position    */
comment|/* for closure                                      */
name|v_start
operator|.
name|x
operator|=
operator|(
name|v_start
operator|.
name|x
operator|+
name|v_last
operator|.
name|x
operator|)
operator|/
literal|2
expr_stmt|;
name|v_start
operator|.
name|y
operator|=
operator|(
name|v_start
operator|.
name|y
operator|+
name|v_last
operator|.
name|y
operator|)
operator|/
literal|2
expr_stmt|;
name|v_last
operator|=
name|v_start
expr_stmt|;
block|}
name|point
operator|--
expr_stmt|;
name|tags
operator|--
expr_stmt|;
block|}
name|ras
operator|.
name|lastX
operator|=
name|v_start
operator|.
name|x
expr_stmt|;
name|ras
operator|.
name|lastY
operator|=
name|v_start
operator|.
name|y
expr_stmt|;
while|while
condition|(
name|point
operator|<
name|limit
condition|)
block|{
name|point
operator|++
expr_stmt|;
name|tags
operator|++
expr_stmt|;
name|tag
operator|=
name|FT_CURVE_TAG
argument_list|(
name|tags
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tag
condition|)
block|{
case|case
name|FT_CURVE_TAG_ON
case|:
comment|/* emit a single line_to */
block|{
name|Long
name|x
decl_stmt|,
name|y
decl_stmt|;
name|x
operator|=
name|SCALED
argument_list|(
name|point
operator|->
name|x
argument_list|)
expr_stmt|;
name|y
operator|=
name|SCALED
argument_list|(
name|point
operator|->
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|flipped
condition|)
name|SWAP_
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|Line_To
argument_list|(
argument|RAS_VARS x
argument_list|,
argument|y
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
continue|continue;
block|}
case|case
name|FT_CURVE_TAG_CONIC
case|:
comment|/* consume conic arcs */
name|v_control
operator|.
name|x
operator|=
name|SCALED
argument_list|(
name|point
index|[
literal|0
index|]
operator|.
name|x
argument_list|)
expr_stmt|;
name|v_control
operator|.
name|y
operator|=
name|SCALED
argument_list|(
name|point
index|[
literal|0
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|flipped
condition|)
name|SWAP_
argument_list|(
name|v_control
operator|.
name|x
argument_list|,
name|v_control
operator|.
name|y
argument_list|)
expr_stmt|;
name|Do_Conic
label|:
if|if
condition|(
name|point
operator|<
name|limit
condition|)
block|{
name|FT_Vector
name|v_middle
decl_stmt|;
name|Long
name|x
decl_stmt|,
name|y
decl_stmt|;
name|point
operator|++
expr_stmt|;
name|tags
operator|++
expr_stmt|;
name|tag
operator|=
name|FT_CURVE_TAG
argument_list|(
name|tags
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|x
operator|=
name|SCALED
argument_list|(
name|point
index|[
literal|0
index|]
operator|.
name|x
argument_list|)
expr_stmt|;
name|y
operator|=
name|SCALED
argument_list|(
name|point
index|[
literal|0
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|flipped
condition|)
name|SWAP_
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag
operator|==
name|FT_CURVE_TAG_ON
condition|)
block|{
if|if
condition|(
name|Conic_To
argument_list|(
argument|RAS_VARS v_control.x
argument_list|,
argument|v_control.y
argument_list|,
argument|x
argument_list|,
argument|y
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
continue|continue;
block|}
if|if
condition|(
name|tag
operator|!=
name|FT_CURVE_TAG_CONIC
condition|)
goto|goto
name|Invalid_Outline
goto|;
name|v_middle
operator|.
name|x
operator|=
operator|(
name|v_control
operator|.
name|x
operator|+
name|x
operator|)
operator|/
literal|2
expr_stmt|;
name|v_middle
operator|.
name|y
operator|=
operator|(
name|v_control
operator|.
name|y
operator|+
name|y
operator|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|Conic_To
argument_list|(
argument|RAS_VARS v_control.x
argument_list|,
argument|v_control.y
argument_list|,
argument|v_middle.x
argument_list|,
argument|v_middle.y
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
name|v_control
operator|.
name|x
operator|=
name|x
expr_stmt|;
name|v_control
operator|.
name|y
operator|=
name|y
expr_stmt|;
goto|goto
name|Do_Conic
goto|;
block|}
if|if
condition|(
name|Conic_To
argument_list|(
argument|RAS_VARS v_control.x
argument_list|,
argument|v_control.y
argument_list|,
argument|v_start.x
argument_list|,
argument|v_start.y
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
goto|goto
name|Close
goto|;
default|default:
comment|/* FT_CURVE_TAG_CUBIC */
block|{
name|Long
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|,
name|x3
decl_stmt|,
name|y3
decl_stmt|;
if|if
condition|(
name|point
operator|+
literal|1
operator|>
name|limit
operator|||
name|FT_CURVE_TAG
argument_list|(
name|tags
index|[
literal|1
index|]
argument_list|)
operator|!=
name|FT_CURVE_TAG_CUBIC
condition|)
goto|goto
name|Invalid_Outline
goto|;
name|point
operator|+=
literal|2
expr_stmt|;
name|tags
operator|+=
literal|2
expr_stmt|;
name|x1
operator|=
name|SCALED
argument_list|(
name|point
index|[
operator|-
literal|2
index|]
operator|.
name|x
argument_list|)
expr_stmt|;
name|y1
operator|=
name|SCALED
argument_list|(
name|point
index|[
operator|-
literal|2
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
name|x2
operator|=
name|SCALED
argument_list|(
name|point
index|[
operator|-
literal|1
index|]
operator|.
name|x
argument_list|)
expr_stmt|;
name|y2
operator|=
name|SCALED
argument_list|(
name|point
index|[
operator|-
literal|1
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
name|x3
operator|=
name|SCALED
argument_list|(
name|point
index|[
literal|0
index|]
operator|.
name|x
argument_list|)
expr_stmt|;
name|y3
operator|=
name|SCALED
argument_list|(
name|point
index|[
literal|0
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|flipped
condition|)
block|{
name|SWAP_
argument_list|(
name|x1
argument_list|,
name|y1
argument_list|)
expr_stmt|;
name|SWAP_
argument_list|(
name|x2
argument_list|,
name|y2
argument_list|)
expr_stmt|;
name|SWAP_
argument_list|(
name|x3
argument_list|,
name|y3
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|point
operator|<=
name|limit
condition|)
block|{
if|if
condition|(
name|Cubic_To
argument_list|(
argument|RAS_VARS x1
argument_list|,
argument|y1
argument_list|,
argument|x2
argument_list|,
argument|y2
argument_list|,
argument|x3
argument_list|,
argument|y3
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
continue|continue;
block|}
if|if
condition|(
name|Cubic_To
argument_list|(
argument|RAS_VARS x1
argument_list|,
argument|y1
argument_list|,
argument|x2
argument_list|,
argument|y2
argument_list|,
argument|v_start.x
argument_list|,
argument|v_start.y
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
goto|goto
name|Close
goto|;
block|}
block|}
block|}
comment|/* close the contour with a line segment */
if|if
condition|(
name|Line_To
argument_list|(
argument|RAS_VARS v_start.x
argument_list|,
argument|v_start.y
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
name|Close
label|:
return|return
name|SUCCESS
return|;
name|Invalid_Outline
label|:
name|ras
operator|.
name|error
operator|=
name|Raster_Err_Invalid
expr_stmt|;
name|Fail
label|:
return|return
name|FAILURE
return|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    Convert_Glyph                                                      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Convert a glyph into a series of segments and arcs and make a      */
end_comment
begin_comment
comment|/*    profiles list with them.                                           */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    flipped :: If set, flip the direction of curve.                    */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    SUCCESS on success, FAILURE if any error was encountered during    */
end_comment
begin_comment
comment|/*    rendering.                                                         */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|Bool
DECL|function|Convert_Glyph
name|Convert_Glyph
parameter_list|(
name|RAS_ARGS
name|int
name|flipped
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|start
decl_stmt|;
name|PProfile
name|lastProfile
decl_stmt|;
name|ras
operator|.
name|fProfile
operator|=
name|NULL
expr_stmt|;
name|ras
operator|.
name|joint
operator|=
name|FALSE
expr_stmt|;
name|ras
operator|.
name|fresh
operator|=
name|FALSE
expr_stmt|;
name|ras
operator|.
name|maxBuff
operator|=
name|ras
operator|.
name|sizeBuff
operator|-
name|AlignProfileSize
expr_stmt|;
name|ras
operator|.
name|numTurns
operator|=
literal|0
expr_stmt|;
name|ras
operator|.
name|cProfile
operator|=
operator|(
name|PProfile
operator|)
name|ras
operator|.
name|top
expr_stmt|;
name|ras
operator|.
name|cProfile
operator|->
name|offset
operator|=
name|ras
operator|.
name|top
expr_stmt|;
name|ras
operator|.
name|num_Profs
operator|=
literal|0
expr_stmt|;
name|start
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ras
operator|.
name|outline
operator|.
name|n_contours
condition|;
name|i
operator|++
control|)
block|{
name|Bool
name|o
decl_stmt|;
name|ras
operator|.
name|state
operator|=
name|Unknown_State
expr_stmt|;
name|ras
operator|.
name|gProfile
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|Decompose_Curve
argument_list|(
name|RAS_VARS
argument_list|(
argument|unsigned short
argument_list|)
name|start
argument_list|,
name|ras
operator|.
name|outline
operator|.
name|contours
index|[
name|i
index|]
argument_list|,
name|flipped
argument_list|)
condition|)
return|return
name|FAILURE
return|;
name|start
operator|=
name|ras
operator|.
name|outline
operator|.
name|contours
index|[
name|i
index|]
operator|+
literal|1
expr_stmt|;
comment|/* we must now check whether the extreme arcs join or not */
if|if
condition|(
name|FRAC
argument_list|(
name|ras
operator|.
name|lastY
argument_list|)
operator|==
literal|0
operator|&&
name|ras
operator|.
name|lastY
operator|>=
name|ras
operator|.
name|minY
operator|&&
name|ras
operator|.
name|lastY
operator|<=
name|ras
operator|.
name|maxY
condition|)
if|if
condition|(
name|ras
operator|.
name|gProfile
operator|&&
operator|(
name|ras
operator|.
name|gProfile
operator|->
name|flags
operator|&
name|Flow_Up
operator|)
operator|==
operator|(
name|ras
operator|.
name|cProfile
operator|->
name|flags
operator|&
name|Flow_Up
operator|)
condition|)
name|ras
operator|.
name|top
operator|--
expr_stmt|;
comment|/* Note that ras.gProfile can be nil if the contour was too small */
comment|/* to be drawn.                                                   */
name|lastProfile
operator|=
name|ras
operator|.
name|cProfile
expr_stmt|;
if|if
condition|(
name|ras
operator|.
name|cProfile
operator|->
name|flags
operator|&
name|Flow_Up
condition|)
name|o
operator|=
name|IS_TOP_OVERSHOOT
argument_list|(
name|ras
operator|.
name|lastY
argument_list|)
expr_stmt|;
else|else
name|o
operator|=
name|IS_BOTTOM_OVERSHOOT
argument_list|(
name|ras
operator|.
name|lastY
argument_list|)
expr_stmt|;
if|if
condition|(
name|End_Profile
argument_list|(
argument|RAS_VARS o
argument_list|)
condition|)
return|return
name|FAILURE
return|;
comment|/* close the `next profile in contour' linked list */
if|if
condition|(
name|ras
operator|.
name|gProfile
condition|)
name|lastProfile
operator|->
name|next
operator|=
name|ras
operator|.
name|gProfile
expr_stmt|;
block|}
if|if
condition|(
name|Finalize_Profile_Table
argument_list|(
name|RAS_VAR
argument_list|)
condition|)
return|return
name|FAILURE
return|;
return|return
call|(
name|Bool
call|)
argument_list|(
name|ras
operator|.
name|top
operator|<
name|ras
operator|.
name|maxBuff
condition|?
name|SUCCESS
else|:
name|FAILURE
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/**                                                                     **/
end_comment
begin_comment
comment|/**  SCAN-LINE SWEEPS AND DRAWING                                       **/
end_comment
begin_comment
comment|/**                                                                     **/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*  Init_Linked                                                          */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    Initializes an empty linked list.                                  */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Init_Linked
name|Init_Linked
parameter_list|(
name|TProfileList
modifier|*
name|l
parameter_list|)
block|{
operator|*
name|l
operator|=
name|NULL
expr_stmt|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*  InsNew                                                               */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    Inserts a new profile in a linked list.                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|InsNew
name|InsNew
parameter_list|(
name|PProfileList
name|list
parameter_list|,
name|PProfile
name|profile
parameter_list|)
block|{
name|PProfile
modifier|*
name|old
decl_stmt|,
name|current
decl_stmt|;
name|Long
name|x
decl_stmt|;
name|old
operator|=
name|list
expr_stmt|;
name|current
operator|=
operator|*
name|old
expr_stmt|;
name|x
operator|=
name|profile
operator|->
name|X
expr_stmt|;
while|while
condition|(
name|current
condition|)
block|{
if|if
condition|(
name|x
operator|<
name|current
operator|->
name|X
condition|)
break|break;
name|old
operator|=
operator|&
name|current
operator|->
name|link
expr_stmt|;
name|current
operator|=
operator|*
name|old
expr_stmt|;
block|}
name|profile
operator|->
name|link
operator|=
name|current
expr_stmt|;
operator|*
name|old
operator|=
name|profile
expr_stmt|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*  DelOld                                                               */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    Removes an old profile from a linked list.                         */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|DelOld
name|DelOld
parameter_list|(
name|PProfileList
name|list
parameter_list|,
name|PProfile
name|profile
parameter_list|)
block|{
name|PProfile
modifier|*
name|old
decl_stmt|,
name|current
decl_stmt|;
name|old
operator|=
name|list
expr_stmt|;
name|current
operator|=
operator|*
name|old
expr_stmt|;
while|while
condition|(
name|current
condition|)
block|{
if|if
condition|(
name|current
operator|==
name|profile
condition|)
block|{
operator|*
name|old
operator|=
name|current
operator|->
name|link
expr_stmt|;
return|return;
block|}
name|old
operator|=
operator|&
name|current
operator|->
name|link
expr_stmt|;
name|current
operator|=
operator|*
name|old
expr_stmt|;
block|}
comment|/* we should never get there, unless the profile was not part of */
comment|/* the list.                                                     */
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*  Sort                                                                 */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    Sorts a trace list.  In 95%, the list is already sorted.  We need  */
end_comment
begin_comment
comment|/*    an algorithm which is fast in this case.  Bubble sort is enough    */
end_comment
begin_comment
comment|/*    and simple.                                                        */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Sort
name|Sort
parameter_list|(
name|PProfileList
name|list
parameter_list|)
block|{
name|PProfile
modifier|*
name|old
decl_stmt|,
name|current
decl_stmt|,
name|next
decl_stmt|;
comment|/* First, set the new X coordinate of each profile */
name|current
operator|=
operator|*
name|list
expr_stmt|;
while|while
condition|(
name|current
condition|)
block|{
name|current
operator|->
name|X
operator|=
operator|*
name|current
operator|->
name|offset
expr_stmt|;
name|current
operator|->
name|offset
operator|+=
name|current
operator|->
name|flags
operator|&
name|Flow_Up
condition|?
literal|1
else|:
operator|-
literal|1
expr_stmt|;
name|current
operator|->
name|height
operator|--
expr_stmt|;
name|current
operator|=
name|current
operator|->
name|link
expr_stmt|;
block|}
comment|/* Then sort them */
name|old
operator|=
name|list
expr_stmt|;
name|current
operator|=
operator|*
name|old
expr_stmt|;
if|if
condition|(
operator|!
name|current
condition|)
return|return;
name|next
operator|=
name|current
operator|->
name|link
expr_stmt|;
while|while
condition|(
name|next
condition|)
block|{
if|if
condition|(
name|current
operator|->
name|X
operator|<=
name|next
operator|->
name|X
condition|)
block|{
name|old
operator|=
operator|&
name|current
operator|->
name|link
expr_stmt|;
name|current
operator|=
operator|*
name|old
expr_stmt|;
if|if
condition|(
operator|!
name|current
condition|)
return|return;
block|}
else|else
block|{
operator|*
name|old
operator|=
name|next
expr_stmt|;
name|current
operator|->
name|link
operator|=
name|next
operator|->
name|link
expr_stmt|;
name|next
operator|->
name|link
operator|=
name|current
expr_stmt|;
name|old
operator|=
name|list
expr_stmt|;
name|current
operator|=
operator|*
name|old
expr_stmt|;
block|}
name|next
operator|=
name|current
operator|->
name|link
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*  Vertical Sweep Procedure Set                                         */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*  These four routines are used during the vertical black/white sweep   */
end_comment
begin_comment
comment|/*  phase by the generic Draw_Sweep() function.                          */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_function
specifier|static
name|void
DECL|function|Vertical_Sweep_Init
name|Vertical_Sweep_Init
parameter_list|(
name|RAS_ARGS
name|Short
modifier|*
name|min
parameter_list|,
name|Short
modifier|*
name|max
parameter_list|)
block|{
name|Long
name|pitch
init|=
name|ras
operator|.
name|target
operator|.
name|pitch
decl_stmt|;
name|FT_UNUSED
argument_list|(
name|max
argument_list|)
expr_stmt|;
name|ras
operator|.
name|traceIncr
operator|=
operator|(
name|Short
operator|)
operator|-
name|pitch
expr_stmt|;
name|ras
operator|.
name|traceOfs
operator|=
operator|-
operator|*
name|min
operator|*
name|pitch
expr_stmt|;
if|if
condition|(
name|pitch
operator|>
literal|0
condition|)
name|ras
operator|.
name|traceOfs
operator|+=
operator|(
name|ras
operator|.
name|target
operator|.
name|rows
operator|-
literal|1
operator|)
operator|*
name|pitch
expr_stmt|;
name|ras
operator|.
name|gray_min_x
operator|=
literal|0
expr_stmt|;
name|ras
operator|.
name|gray_max_x
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|Vertical_Sweep_Span
name|Vertical_Sweep_Span
parameter_list|(
name|RAS_ARGS
name|Short
name|y
parameter_list|,
name|FT_F26Dot6
name|x1
parameter_list|,
name|FT_F26Dot6
name|x2
parameter_list|,
name|PProfile
name|left
parameter_list|,
name|PProfile
name|right
parameter_list|)
block|{
name|Long
name|e1
decl_stmt|,
name|e2
decl_stmt|;
name|int
name|c1
decl_stmt|,
name|c2
decl_stmt|;
name|Byte
name|f1
decl_stmt|,
name|f2
decl_stmt|;
name|Byte
modifier|*
name|target
decl_stmt|;
name|FT_UNUSED
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|left
argument_list|)
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|right
argument_list|)
expr_stmt|;
comment|/* Drop-out control */
name|e1
operator|=
name|TRUNC
argument_list|(
name|CEILING
argument_list|(
name|x1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|x2
operator|-
name|x1
operator|-
name|ras
operator|.
name|precision
operator|<=
name|ras
operator|.
name|precision_jitter
condition|)
name|e2
operator|=
name|e1
expr_stmt|;
else|else
name|e2
operator|=
name|TRUNC
argument_list|(
name|FLOOR
argument_list|(
name|x2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|e2
operator|>=
literal|0
operator|&&
name|e1
operator|<
name|ras
operator|.
name|bWidth
condition|)
block|{
if|if
condition|(
name|e1
operator|<
literal|0
condition|)
name|e1
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|e2
operator|>=
name|ras
operator|.
name|bWidth
condition|)
name|e2
operator|=
name|ras
operator|.
name|bWidth
operator|-
literal|1
expr_stmt|;
name|c1
operator|=
call|(
name|Short
call|)
argument_list|(
name|e1
operator|>>
literal|3
argument_list|)
expr_stmt|;
name|c2
operator|=
call|(
name|Short
call|)
argument_list|(
name|e2
operator|>>
literal|3
argument_list|)
expr_stmt|;
name|f1
operator|=
call|(
name|Byte
call|)
argument_list|(
literal|0xFF
operator|>>
operator|(
name|e1
operator|&
literal|7
operator|)
argument_list|)
expr_stmt|;
name|f2
operator|=
operator|(
name|Byte
operator|)
operator|~
operator|(
literal|0x7F
operator|>>
operator|(
name|e2
operator|&
literal|7
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|ras
operator|.
name|gray_min_x
operator|>
name|c1
condition|)
name|ras
operator|.
name|gray_min_x
operator|=
operator|(
name|short
operator|)
name|c1
expr_stmt|;
if|if
condition|(
name|ras
operator|.
name|gray_max_x
operator|<
name|c2
condition|)
name|ras
operator|.
name|gray_max_x
operator|=
operator|(
name|short
operator|)
name|c2
expr_stmt|;
name|target
operator|=
name|ras
operator|.
name|bTarget
operator|+
name|ras
operator|.
name|traceOfs
operator|+
name|c1
expr_stmt|;
name|c2
operator|-=
name|c1
expr_stmt|;
if|if
condition|(
name|c2
operator|>
literal|0
condition|)
block|{
name|target
index|[
literal|0
index|]
operator||=
name|f1
expr_stmt|;
comment|/* memset() is slower than the following code on many platforms. */
comment|/* This is due to the fact that, in the vast majority of cases,  */
comment|/* the span length in bytes is relatively small.                 */
name|c2
operator|--
expr_stmt|;
while|while
condition|(
name|c2
operator|>
literal|0
condition|)
block|{
operator|*
operator|(
operator|++
name|target
operator|)
operator|=
literal|0xFF
expr_stmt|;
name|c2
operator|--
expr_stmt|;
block|}
name|target
index|[
literal|1
index|]
operator||=
name|f2
expr_stmt|;
block|}
else|else
operator|*
name|target
operator||=
operator|(
name|f1
operator|&
name|f2
operator|)
expr_stmt|;
block|}
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|Vertical_Sweep_Drop
name|Vertical_Sweep_Drop
parameter_list|(
name|RAS_ARGS
name|Short
name|y
parameter_list|,
name|FT_F26Dot6
name|x1
parameter_list|,
name|FT_F26Dot6
name|x2
parameter_list|,
name|PProfile
name|left
parameter_list|,
name|PProfile
name|right
parameter_list|)
block|{
name|Long
name|e1
decl_stmt|,
name|e2
decl_stmt|,
name|pxl
decl_stmt|;
name|Short
name|c1
decl_stmt|,
name|f1
decl_stmt|;
comment|/* Drop-out control */
comment|/*   e2            x2                    x1           e1   */
comment|/*                                                         */
comment|/*                 ^                     |                 */
comment|/*                 |                     |                 */
comment|/*   +-------------+---------------------+------------+    */
comment|/*                 |                     |                 */
comment|/*                 |                     v                 */
comment|/*                                                         */
comment|/* pixel         contour              contour       pixel  */
comment|/* center                                           center */
comment|/* drop-out mode    scan conversion rules (as defined in OpenType) */
comment|/* --------------------------------------------------------------- */
comment|/*  0                1, 2, 3                                       */
comment|/*  1                1, 2, 4                                       */
comment|/*  2                1, 2                                          */
comment|/*  3                same as mode 2                                */
comment|/*  4                1, 2, 5                                       */
comment|/*  5                1, 2, 6                                       */
comment|/*  6, 7             same as mode 2                                */
name|e1
operator|=
name|CEILING
argument_list|(
name|x1
argument_list|)
expr_stmt|;
name|e2
operator|=
name|FLOOR
argument_list|(
name|x2
argument_list|)
expr_stmt|;
name|pxl
operator|=
name|e1
expr_stmt|;
if|if
condition|(
name|e1
operator|>
name|e2
condition|)
block|{
name|Int
name|dropOutControl
init|=
name|left
operator|->
name|flags
operator|&
literal|7
decl_stmt|;
if|if
condition|(
name|e1
operator|==
name|e2
operator|+
name|ras
operator|.
name|precision
condition|)
block|{
switch|switch
condition|(
name|dropOutControl
condition|)
block|{
case|case
literal|0
case|:
comment|/* simple drop-outs including stubs */
name|pxl
operator|=
name|e2
expr_stmt|;
break|break;
case|case
literal|4
case|:
comment|/* smart drop-outs including stubs */
name|pxl
operator|=
name|FLOOR
argument_list|(
operator|(
name|x1
operator|+
name|x2
operator|-
literal|1
operator|)
operator|/
literal|2
operator|+
name|ras
operator|.
name|precision_half
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* simple drop-outs excluding stubs */
case|case
literal|5
case|:
comment|/* smart drop-outs excluding stubs  */
comment|/* Drop-out Control Rules #4 and #6 */
comment|/* The specification neither provides an exact definition */
comment|/* of a `stub' nor gives exact rules to exclude them.     */
comment|/*                                                        */
comment|/* Here the constraints we use to recognize a stub.       */
comment|/*                                                        */
comment|/*  upper stub:                                           */
comment|/*                                                        */
comment|/*   - P_Left and P_Right are in the same contour         */
comment|/*   - P_Right is the successor of P_Left in that contour */
comment|/*   - y is the top of P_Left and P_Right                 */
comment|/*                                                        */
comment|/*  lower stub:                                           */
comment|/*                                                        */
comment|/*   - P_Left and P_Right are in the same contour         */
comment|/*   - P_Left is the successor of P_Right in that contour */
comment|/*   - y is the bottom of P_Left                          */
comment|/*                                                        */
comment|/* We draw a stub if the following constraints are met.   */
comment|/*                                                        */
comment|/*   - for an upper or lower stub, there is top or bottom */
comment|/*     overshoot, respectively                            */
comment|/*   - the covered interval is greater or equal to a half */
comment|/*     pixel                                              */
comment|/* upper stub test */
if|if
condition|(
name|left
operator|->
name|next
operator|==
name|right
operator|&&
name|left
operator|->
name|height
operator|<=
literal|0
operator|&&
operator|!
operator|(
name|left
operator|->
name|flags
operator|&
name|Overshoot_Top
operator|&&
name|x2
operator|-
name|x1
operator|>=
name|ras
operator|.
name|precision_half
operator|)
condition|)
return|return;
comment|/* lower stub test */
if|if
condition|(
name|right
operator|->
name|next
operator|==
name|left
operator|&&
name|left
operator|->
name|start
operator|==
name|y
operator|&&
operator|!
operator|(
name|left
operator|->
name|flags
operator|&
name|Overshoot_Bottom
operator|&&
name|x2
operator|-
name|x1
operator|>=
name|ras
operator|.
name|precision_half
operator|)
condition|)
return|return;
if|if
condition|(
name|dropOutControl
operator|==
literal|1
condition|)
name|pxl
operator|=
name|e2
expr_stmt|;
else|else
name|pxl
operator|=
name|FLOOR
argument_list|(
operator|(
name|x1
operator|+
name|x2
operator|-
literal|1
operator|)
operator|/
literal|2
operator|+
name|ras
operator|.
name|precision_half
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* modes 2, 3, 6, 7 */
return|return;
comment|/* no drop-out control */
block|}
comment|/* check that the other pixel isn't set */
name|e1
operator|=
name|pxl
operator|==
name|e1
condition|?
name|e2
else|:
name|e1
expr_stmt|;
name|e1
operator|=
name|TRUNC
argument_list|(
name|e1
argument_list|)
expr_stmt|;
name|c1
operator|=
call|(
name|Short
call|)
argument_list|(
name|e1
operator|>>
literal|3
argument_list|)
expr_stmt|;
name|f1
operator|=
call|(
name|Short
call|)
argument_list|(
name|e1
operator|&
literal|7
argument_list|)
expr_stmt|;
if|if
condition|(
name|e1
operator|>=
literal|0
operator|&&
name|e1
operator|<
name|ras
operator|.
name|bWidth
operator|&&
name|ras
operator|.
name|bTarget
index|[
name|ras
operator|.
name|traceOfs
operator|+
name|c1
index|]
operator|&
operator|(
literal|0x80
operator|>>
name|f1
operator|)
condition|)
return|return;
block|}
else|else
return|return;
block|}
name|e1
operator|=
name|TRUNC
argument_list|(
name|pxl
argument_list|)
expr_stmt|;
if|if
condition|(
name|e1
operator|>=
literal|0
operator|&&
name|e1
operator|<
name|ras
operator|.
name|bWidth
condition|)
block|{
name|c1
operator|=
call|(
name|Short
call|)
argument_list|(
name|e1
operator|>>
literal|3
argument_list|)
expr_stmt|;
name|f1
operator|=
call|(
name|Short
call|)
argument_list|(
name|e1
operator|&
literal|7
argument_list|)
expr_stmt|;
if|if
condition|(
name|ras
operator|.
name|gray_min_x
operator|>
name|c1
condition|)
name|ras
operator|.
name|gray_min_x
operator|=
name|c1
expr_stmt|;
if|if
condition|(
name|ras
operator|.
name|gray_max_x
operator|<
name|c1
condition|)
name|ras
operator|.
name|gray_max_x
operator|=
name|c1
expr_stmt|;
name|ras
operator|.
name|bTarget
index|[
name|ras
operator|.
name|traceOfs
operator|+
name|c1
index|]
operator||=
call|(
name|char
call|)
argument_list|(
literal|0x80
operator|>>
name|f1
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|Vertical_Sweep_Step
name|Vertical_Sweep_Step
parameter_list|(
name|RAS_ARG
parameter_list|)
block|{
name|ras
operator|.
name|traceOfs
operator|+=
name|ras
operator|.
name|traceIncr
expr_stmt|;
block|}
end_function
begin_comment
comment|/***********************************************************************/
end_comment
begin_comment
comment|/*                                                                     */
end_comment
begin_comment
comment|/*  Horizontal Sweep Procedure Set                                     */
end_comment
begin_comment
comment|/*                                                                     */
end_comment
begin_comment
comment|/*  These four routines are used during the horizontal black/white     */
end_comment
begin_comment
comment|/*  sweep phase by the generic Draw_Sweep() function.                  */
end_comment
begin_comment
comment|/*                                                                     */
end_comment
begin_comment
comment|/***********************************************************************/
end_comment
begin_function
specifier|static
name|void
DECL|function|Horizontal_Sweep_Init
name|Horizontal_Sweep_Init
parameter_list|(
name|RAS_ARGS
name|Short
modifier|*
name|min
parameter_list|,
name|Short
modifier|*
name|max
parameter_list|)
block|{
comment|/* nothing, really */
name|FT_UNUSED_RASTER
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|min
argument_list|)
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|max
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|Horizontal_Sweep_Span
name|Horizontal_Sweep_Span
parameter_list|(
name|RAS_ARGS
name|Short
name|y
parameter_list|,
name|FT_F26Dot6
name|x1
parameter_list|,
name|FT_F26Dot6
name|x2
parameter_list|,
name|PProfile
name|left
parameter_list|,
name|PProfile
name|right
parameter_list|)
block|{
name|Long
name|e1
decl_stmt|,
name|e2
decl_stmt|;
name|PByte
name|bits
decl_stmt|;
name|Byte
name|f1
decl_stmt|;
name|FT_UNUSED
argument_list|(
name|left
argument_list|)
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|right
argument_list|)
expr_stmt|;
if|if
condition|(
name|x2
operator|-
name|x1
operator|<
name|ras
operator|.
name|precision
condition|)
block|{
name|e1
operator|=
name|CEILING
argument_list|(
name|x1
argument_list|)
expr_stmt|;
name|e2
operator|=
name|FLOOR
argument_list|(
name|x2
argument_list|)
expr_stmt|;
if|if
condition|(
name|e1
operator|==
name|e2
condition|)
block|{
name|bits
operator|=
name|ras
operator|.
name|bTarget
operator|+
operator|(
name|y
operator|>>
literal|3
operator|)
expr_stmt|;
name|f1
operator|=
call|(
name|Byte
call|)
argument_list|(
literal|0x80
operator|>>
operator|(
name|y
operator|&
literal|7
operator|)
argument_list|)
expr_stmt|;
name|e1
operator|=
name|TRUNC
argument_list|(
name|e1
argument_list|)
expr_stmt|;
if|if
condition|(
name|e1
operator|>=
literal|0
operator|&&
name|e1
operator|<
name|ras
operator|.
name|target
operator|.
name|rows
condition|)
block|{
name|PByte
name|p
decl_stmt|;
name|p
operator|=
name|bits
operator|-
name|e1
operator|*
name|ras
operator|.
name|target
operator|.
name|pitch
expr_stmt|;
if|if
condition|(
name|ras
operator|.
name|target
operator|.
name|pitch
operator|>
literal|0
condition|)
name|p
operator|+=
operator|(
name|ras
operator|.
name|target
operator|.
name|rows
operator|-
literal|1
operator|)
operator|*
name|ras
operator|.
name|target
operator|.
name|pitch
expr_stmt|;
name|p
index|[
literal|0
index|]
operator||=
name|f1
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|Horizontal_Sweep_Drop
name|Horizontal_Sweep_Drop
parameter_list|(
name|RAS_ARGS
name|Short
name|y
parameter_list|,
name|FT_F26Dot6
name|x1
parameter_list|,
name|FT_F26Dot6
name|x2
parameter_list|,
name|PProfile
name|left
parameter_list|,
name|PProfile
name|right
parameter_list|)
block|{
name|Long
name|e1
decl_stmt|,
name|e2
decl_stmt|,
name|pxl
decl_stmt|;
name|PByte
name|bits
decl_stmt|;
name|Byte
name|f1
decl_stmt|;
comment|/* During the horizontal sweep, we only take care of drop-outs */
comment|/* e1     +<-- pixel center */
comment|/*        |                        */
comment|/* x1  ---+--><-- contour      */
comment|/*        |                        */
comment|/*        |                        */
comment|/* x2<--+---<-- contour      */
comment|/*        |                        */
comment|/*        |                        */
comment|/* e2     +<-- pixel center */
name|e1
operator|=
name|CEILING
argument_list|(
name|x1
argument_list|)
expr_stmt|;
name|e2
operator|=
name|FLOOR
argument_list|(
name|x2
argument_list|)
expr_stmt|;
name|pxl
operator|=
name|e1
expr_stmt|;
if|if
condition|(
name|e1
operator|>
name|e2
condition|)
block|{
name|Int
name|dropOutControl
init|=
name|left
operator|->
name|flags
operator|&
literal|7
decl_stmt|;
if|if
condition|(
name|e1
operator|==
name|e2
operator|+
name|ras
operator|.
name|precision
condition|)
block|{
switch|switch
condition|(
name|dropOutControl
condition|)
block|{
case|case
literal|0
case|:
comment|/* simple drop-outs including stubs */
name|pxl
operator|=
name|e2
expr_stmt|;
break|break;
case|case
literal|4
case|:
comment|/* smart drop-outs including stubs */
name|pxl
operator|=
name|FLOOR
argument_list|(
operator|(
name|x1
operator|+
name|x2
operator|-
literal|1
operator|)
operator|/
literal|2
operator|+
name|ras
operator|.
name|precision_half
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* simple drop-outs excluding stubs */
case|case
literal|5
case|:
comment|/* smart drop-outs excluding stubs  */
comment|/* see Vertical_Sweep_Drop for details */
comment|/* rightmost stub test */
if|if
condition|(
name|left
operator|->
name|next
operator|==
name|right
operator|&&
name|left
operator|->
name|height
operator|<=
literal|0
operator|&&
operator|!
operator|(
name|left
operator|->
name|flags
operator|&
name|Overshoot_Top
operator|&&
name|x2
operator|-
name|x1
operator|>=
name|ras
operator|.
name|precision_half
operator|)
condition|)
return|return;
comment|/* leftmost stub test */
if|if
condition|(
name|right
operator|->
name|next
operator|==
name|left
operator|&&
name|left
operator|->
name|start
operator|==
name|y
operator|&&
operator|!
operator|(
name|left
operator|->
name|flags
operator|&
name|Overshoot_Bottom
operator|&&
name|x2
operator|-
name|x1
operator|>=
name|ras
operator|.
name|precision_half
operator|)
condition|)
return|return;
if|if
condition|(
name|dropOutControl
operator|==
literal|1
condition|)
name|pxl
operator|=
name|e2
expr_stmt|;
else|else
name|pxl
operator|=
name|FLOOR
argument_list|(
operator|(
name|x1
operator|+
name|x2
operator|-
literal|1
operator|)
operator|/
literal|2
operator|+
name|ras
operator|.
name|precision_half
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* modes 2, 3, 6, 7 */
return|return;
comment|/* no drop-out control */
block|}
comment|/* check that the other pixel isn't set */
name|e1
operator|=
name|pxl
operator|==
name|e1
condition|?
name|e2
else|:
name|e1
expr_stmt|;
name|e1
operator|=
name|TRUNC
argument_list|(
name|e1
argument_list|)
expr_stmt|;
name|bits
operator|=
name|ras
operator|.
name|bTarget
operator|+
operator|(
name|y
operator|>>
literal|3
operator|)
expr_stmt|;
name|f1
operator|=
call|(
name|Byte
call|)
argument_list|(
literal|0x80
operator|>>
operator|(
name|y
operator|&
literal|7
operator|)
argument_list|)
expr_stmt|;
name|bits
operator|-=
name|e1
operator|*
name|ras
operator|.
name|target
operator|.
name|pitch
expr_stmt|;
if|if
condition|(
name|ras
operator|.
name|target
operator|.
name|pitch
operator|>
literal|0
condition|)
name|bits
operator|+=
operator|(
name|ras
operator|.
name|target
operator|.
name|rows
operator|-
literal|1
operator|)
operator|*
name|ras
operator|.
name|target
operator|.
name|pitch
expr_stmt|;
if|if
condition|(
name|e1
operator|>=
literal|0
operator|&&
name|e1
operator|<
name|ras
operator|.
name|target
operator|.
name|rows
operator|&&
operator|*
name|bits
operator|&
name|f1
condition|)
return|return;
block|}
else|else
return|return;
block|}
name|bits
operator|=
name|ras
operator|.
name|bTarget
operator|+
operator|(
name|y
operator|>>
literal|3
operator|)
expr_stmt|;
name|f1
operator|=
call|(
name|Byte
call|)
argument_list|(
literal|0x80
operator|>>
operator|(
name|y
operator|&
literal|7
operator|)
argument_list|)
expr_stmt|;
name|e1
operator|=
name|TRUNC
argument_list|(
name|pxl
argument_list|)
expr_stmt|;
if|if
condition|(
name|e1
operator|>=
literal|0
operator|&&
name|e1
operator|<
name|ras
operator|.
name|target
operator|.
name|rows
condition|)
block|{
name|bits
operator|-=
name|e1
operator|*
name|ras
operator|.
name|target
operator|.
name|pitch
expr_stmt|;
if|if
condition|(
name|ras
operator|.
name|target
operator|.
name|pitch
operator|>
literal|0
condition|)
name|bits
operator|+=
operator|(
name|ras
operator|.
name|target
operator|.
name|rows
operator|-
literal|1
operator|)
operator|*
name|ras
operator|.
name|target
operator|.
name|pitch
expr_stmt|;
name|bits
index|[
literal|0
index|]
operator||=
name|f1
expr_stmt|;
block|}
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|Horizontal_Sweep_Step
name|Horizontal_Sweep_Step
parameter_list|(
name|RAS_ARG
parameter_list|)
block|{
comment|/* Nothing, really */
name|FT_UNUSED_RASTER
expr_stmt|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|FT_RASTER_OPTION_ANTI_ALIASING
end_ifdef
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*  Vertical Gray Sweep Procedure Set                                    */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*  These two routines are used during the vertical gray-levels sweep    */
end_comment
begin_comment
comment|/*  phase by the generic Draw_Sweep() function.                          */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*  NOTES                                                                */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*  - The target pixmap's width *must* be a multiple of 4.               */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*  - You have to use the function Vertical_Sweep_Span() for the gray    */
end_comment
begin_comment
comment|/*    span call.                                                         */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_function
specifier|static
name|void
DECL|function|Vertical_Gray_Sweep_Init
name|Vertical_Gray_Sweep_Init
parameter_list|(
name|RAS_ARGS
name|Short
modifier|*
name|min
parameter_list|,
name|Short
modifier|*
name|max
parameter_list|)
block|{
name|Long
name|pitch
decl_stmt|,
name|byte_len
decl_stmt|;
operator|*
name|min
operator|=
operator|*
name|min
operator|&
operator|-
literal|2
expr_stmt|;
operator|*
name|max
operator|=
operator|(
operator|*
name|max
operator|+
literal|3
operator|)
operator|&
operator|-
literal|2
expr_stmt|;
name|ras
operator|.
name|traceOfs
operator|=
literal|0
expr_stmt|;
name|pitch
operator|=
name|ras
operator|.
name|target
operator|.
name|pitch
expr_stmt|;
name|byte_len
operator|=
operator|-
name|pitch
expr_stmt|;
name|ras
operator|.
name|traceIncr
operator|=
operator|(
name|Short
operator|)
name|byte_len
expr_stmt|;
name|ras
operator|.
name|traceG
operator|=
operator|(
operator|*
name|min
operator|/
literal|2
operator|)
operator|*
name|byte_len
expr_stmt|;
if|if
condition|(
name|pitch
operator|>
literal|0
condition|)
block|{
name|ras
operator|.
name|traceG
operator|+=
operator|(
name|ras
operator|.
name|target
operator|.
name|rows
operator|-
literal|1
operator|)
operator|*
name|pitch
expr_stmt|;
name|byte_len
operator|=
operator|-
name|byte_len
expr_stmt|;
block|}
name|ras
operator|.
name|gray_min_x
operator|=
operator|(
name|Short
operator|)
name|byte_len
expr_stmt|;
name|ras
operator|.
name|gray_max_x
operator|=
operator|-
operator|(
name|Short
operator|)
name|byte_len
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|Vertical_Gray_Sweep_Step
name|Vertical_Gray_Sweep_Step
parameter_list|(
name|RAS_ARG
parameter_list|)
block|{
name|Int
name|c1
decl_stmt|,
name|c2
decl_stmt|;
name|PByte
name|pix
decl_stmt|,
name|bit
decl_stmt|,
name|bit2
decl_stmt|;
name|short
modifier|*
name|count
init|=
operator|(
name|short
operator|*
operator|)
name|count_table
decl_stmt|;
name|Byte
modifier|*
name|grays
decl_stmt|;
name|ras
operator|.
name|traceOfs
operator|+=
name|ras
operator|.
name|gray_width
expr_stmt|;
if|if
condition|(
name|ras
operator|.
name|traceOfs
operator|>
name|ras
operator|.
name|gray_width
condition|)
block|{
name|pix
operator|=
name|ras
operator|.
name|gTarget
operator|+
name|ras
operator|.
name|traceG
operator|+
name|ras
operator|.
name|gray_min_x
operator|*
literal|4
expr_stmt|;
name|grays
operator|=
name|ras
operator|.
name|grays
expr_stmt|;
if|if
condition|(
name|ras
operator|.
name|gray_max_x
operator|>=
literal|0
condition|)
block|{
name|Long
name|last_pixel
init|=
name|ras
operator|.
name|target
operator|.
name|width
operator|-
literal|1
decl_stmt|;
name|Int
name|last_cell
init|=
name|last_pixel
operator|>>
literal|2
decl_stmt|;
name|Int
name|last_bit
init|=
name|last_pixel
operator|&
literal|3
decl_stmt|;
name|Bool
name|over
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ras
operator|.
name|gray_max_x
operator|>=
name|last_cell
operator|&&
name|last_bit
operator|!=
literal|3
condition|)
block|{
name|ras
operator|.
name|gray_max_x
operator|=
name|last_cell
operator|-
literal|1
expr_stmt|;
name|over
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|ras
operator|.
name|gray_min_x
operator|<
literal|0
condition|)
name|ras
operator|.
name|gray_min_x
operator|=
literal|0
expr_stmt|;
name|bit
operator|=
name|ras
operator|.
name|bTarget
operator|+
name|ras
operator|.
name|gray_min_x
expr_stmt|;
name|bit2
operator|=
name|bit
operator|+
name|ras
operator|.
name|gray_width
expr_stmt|;
name|c1
operator|=
name|ras
operator|.
name|gray_max_x
operator|-
name|ras
operator|.
name|gray_min_x
expr_stmt|;
while|while
condition|(
name|c1
operator|>=
literal|0
condition|)
block|{
name|c2
operator|=
name|count
index|[
operator|*
name|bit
index|]
operator|+
name|count
index|[
operator|*
name|bit2
index|]
expr_stmt|;
if|if
condition|(
name|c2
condition|)
block|{
name|pix
index|[
literal|0
index|]
operator|=
name|grays
index|[
operator|(
name|c2
operator|>>
literal|12
operator|)
operator|&
literal|0x000F
index|]
expr_stmt|;
name|pix
index|[
literal|1
index|]
operator|=
name|grays
index|[
operator|(
name|c2
operator|>>
literal|8
operator|)
operator|&
literal|0x000F
index|]
expr_stmt|;
name|pix
index|[
literal|2
index|]
operator|=
name|grays
index|[
operator|(
name|c2
operator|>>
literal|4
operator|)
operator|&
literal|0x000F
index|]
expr_stmt|;
name|pix
index|[
literal|3
index|]
operator|=
name|grays
index|[
name|c2
operator|&
literal|0x000F
index|]
expr_stmt|;
operator|*
name|bit
operator|=
literal|0
expr_stmt|;
operator|*
name|bit2
operator|=
literal|0
expr_stmt|;
block|}
name|bit
operator|++
expr_stmt|;
name|bit2
operator|++
expr_stmt|;
name|pix
operator|+=
literal|4
expr_stmt|;
name|c1
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|over
condition|)
block|{
name|c2
operator|=
name|count
index|[
operator|*
name|bit
index|]
operator|+
name|count
index|[
operator|*
name|bit2
index|]
expr_stmt|;
if|if
condition|(
name|c2
condition|)
block|{
switch|switch
condition|(
name|last_bit
condition|)
block|{
case|case
literal|2
case|:
name|pix
index|[
literal|2
index|]
operator|=
name|grays
index|[
operator|(
name|c2
operator|>>
literal|4
operator|)
operator|&
literal|0x000F
index|]
expr_stmt|;
case|case
literal|1
case|:
name|pix
index|[
literal|1
index|]
operator|=
name|grays
index|[
operator|(
name|c2
operator|>>
literal|8
operator|)
operator|&
literal|0x000F
index|]
expr_stmt|;
default|default:
name|pix
index|[
literal|0
index|]
operator|=
name|grays
index|[
operator|(
name|c2
operator|>>
literal|12
operator|)
operator|&
literal|0x000F
index|]
expr_stmt|;
block|}
operator|*
name|bit
operator|=
literal|0
expr_stmt|;
operator|*
name|bit2
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
name|ras
operator|.
name|traceOfs
operator|=
literal|0
expr_stmt|;
name|ras
operator|.
name|traceG
operator|+=
name|ras
operator|.
name|traceIncr
expr_stmt|;
name|ras
operator|.
name|gray_min_x
operator|=
literal|32000
expr_stmt|;
name|ras
operator|.
name|gray_max_x
operator|=
operator|-
literal|32000
expr_stmt|;
block|}
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|Horizontal_Gray_Sweep_Span
name|Horizontal_Gray_Sweep_Span
parameter_list|(
name|RAS_ARGS
name|Short
name|y
parameter_list|,
name|FT_F26Dot6
name|x1
parameter_list|,
name|FT_F26Dot6
name|x2
parameter_list|,
name|PProfile
name|left
parameter_list|,
name|PProfile
name|right
parameter_list|)
block|{
comment|/* nothing, really */
name|FT_UNUSED_RASTER
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|x1
argument_list|)
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|x2
argument_list|)
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|left
argument_list|)
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|right
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|Horizontal_Gray_Sweep_Drop
name|Horizontal_Gray_Sweep_Drop
parameter_list|(
name|RAS_ARGS
name|Short
name|y
parameter_list|,
name|FT_F26Dot6
name|x1
parameter_list|,
name|FT_F26Dot6
name|x2
parameter_list|,
name|PProfile
name|left
parameter_list|,
name|PProfile
name|right
parameter_list|)
block|{
name|Long
name|e1
decl_stmt|,
name|e2
decl_stmt|;
name|PByte
name|pixel
decl_stmt|;
name|Byte
name|color
decl_stmt|;
comment|/* During the horizontal sweep, we only take care of drop-outs */
name|e1
operator|=
name|CEILING
argument_list|(
name|x1
argument_list|)
expr_stmt|;
name|e2
operator|=
name|FLOOR
argument_list|(
name|x2
argument_list|)
expr_stmt|;
if|if
condition|(
name|e1
operator|>
name|e2
condition|)
block|{
name|Int
name|dropOutControl
init|=
name|left
operator|->
name|flags
operator|&
literal|7
decl_stmt|;
if|if
condition|(
name|e1
operator|==
name|e2
operator|+
name|ras
operator|.
name|precision
condition|)
block|{
switch|switch
condition|(
name|dropOutControl
condition|)
block|{
case|case
literal|0
case|:
comment|/* simple drop-outs including stubs */
name|e1
operator|=
name|e2
expr_stmt|;
break|break;
case|case
literal|4
case|:
comment|/* smart drop-outs including stubs */
name|e1
operator|=
name|FLOOR
argument_list|(
operator|(
name|x1
operator|+
name|x2
operator|-
literal|1
operator|)
operator|/
literal|2
operator|+
name|ras
operator|.
name|precision_half
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* simple drop-outs excluding stubs */
case|case
literal|5
case|:
comment|/* smart drop-outs excluding stubs  */
comment|/* see Vertical_Sweep_Drop for details */
comment|/* rightmost stub test */
if|if
condition|(
name|left
operator|->
name|next
operator|==
name|right
operator|&&
name|left
operator|->
name|height
operator|<=
literal|0
condition|)
return|return;
comment|/* leftmost stub test */
if|if
condition|(
name|right
operator|->
name|next
operator|==
name|left
operator|&&
name|left
operator|->
name|start
operator|==
name|y
condition|)
return|return;
if|if
condition|(
name|dropOutControl
operator|==
literal|1
condition|)
name|e1
operator|=
name|e2
expr_stmt|;
else|else
name|e1
operator|=
name|FLOOR
argument_list|(
operator|(
name|x1
operator|+
name|x2
operator|-
literal|1
operator|)
operator|/
literal|2
operator|+
name|ras
operator|.
name|precision_half
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* modes 2, 3, 6, 7 */
return|return;
comment|/* no drop-out control */
block|}
block|}
else|else
return|return;
block|}
if|if
condition|(
name|e1
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|x2
operator|-
name|x1
operator|>=
name|ras
operator|.
name|precision_half
condition|)
name|color
operator|=
name|ras
operator|.
name|grays
index|[
literal|2
index|]
expr_stmt|;
else|else
name|color
operator|=
name|ras
operator|.
name|grays
index|[
literal|1
index|]
expr_stmt|;
name|e1
operator|=
name|TRUNC
argument_list|(
name|e1
argument_list|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|e1
operator|<
name|ras
operator|.
name|target
operator|.
name|rows
condition|)
block|{
name|pixel
operator|=
name|ras
operator|.
name|gTarget
operator|-
name|e1
operator|*
name|ras
operator|.
name|target
operator|.
name|pitch
operator|+
name|y
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|ras
operator|.
name|target
operator|.
name|pitch
operator|>
literal|0
condition|)
name|pixel
operator|+=
operator|(
name|ras
operator|.
name|target
operator|.
name|rows
operator|-
literal|1
operator|)
operator|*
name|ras
operator|.
name|target
operator|.
name|pitch
expr_stmt|;
if|if
condition|(
name|pixel
index|[
literal|0
index|]
operator|==
name|ras
operator|.
name|grays
index|[
literal|0
index|]
condition|)
name|pixel
index|[
literal|0
index|]
operator|=
name|color
expr_stmt|;
block|}
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* FT_RASTER_OPTION_ANTI_ALIASING */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*  Generic Sweep Drawing routine                                        */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_function
specifier|static
name|Bool
DECL|function|Draw_Sweep
name|Draw_Sweep
parameter_list|(
name|RAS_ARG
parameter_list|)
block|{
name|Short
name|y
decl_stmt|,
name|y_change
decl_stmt|,
name|y_height
decl_stmt|;
name|PProfile
name|P
decl_stmt|,
name|Q
decl_stmt|,
name|P_Left
decl_stmt|,
name|P_Right
decl_stmt|;
name|Short
name|min_Y
decl_stmt|,
name|max_Y
decl_stmt|,
name|top
decl_stmt|,
name|bottom
decl_stmt|,
name|dropouts
decl_stmt|;
name|Long
name|x1
decl_stmt|,
name|x2
decl_stmt|,
name|xs
decl_stmt|,
name|e1
decl_stmt|,
name|e2
decl_stmt|;
name|TProfileList
name|waiting
decl_stmt|;
name|TProfileList
name|draw_left
decl_stmt|,
name|draw_right
decl_stmt|;
comment|/* initialize empty linked lists */
name|Init_Linked
argument_list|(
operator|&
name|waiting
argument_list|)
expr_stmt|;
name|Init_Linked
argument_list|(
operator|&
name|draw_left
argument_list|)
expr_stmt|;
name|Init_Linked
argument_list|(
operator|&
name|draw_right
argument_list|)
expr_stmt|;
comment|/* first, compute min and max Y */
name|P
operator|=
name|ras
operator|.
name|fProfile
expr_stmt|;
name|max_Y
operator|=
operator|(
name|Short
operator|)
name|TRUNC
argument_list|(
name|ras
operator|.
name|minY
argument_list|)
expr_stmt|;
name|min_Y
operator|=
operator|(
name|Short
operator|)
name|TRUNC
argument_list|(
name|ras
operator|.
name|maxY
argument_list|)
expr_stmt|;
while|while
condition|(
name|P
condition|)
block|{
name|Q
operator|=
name|P
operator|->
name|link
expr_stmt|;
name|bottom
operator|=
operator|(
name|Short
operator|)
name|P
operator|->
name|start
expr_stmt|;
name|top
operator|=
call|(
name|Short
call|)
argument_list|(
name|P
operator|->
name|start
operator|+
name|P
operator|->
name|height
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|min_Y
operator|>
name|bottom
condition|)
name|min_Y
operator|=
name|bottom
expr_stmt|;
if|if
condition|(
name|max_Y
operator|<
name|top
condition|)
name|max_Y
operator|=
name|top
expr_stmt|;
name|P
operator|->
name|X
operator|=
literal|0
expr_stmt|;
name|InsNew
argument_list|(
operator|&
name|waiting
argument_list|,
name|P
argument_list|)
expr_stmt|;
name|P
operator|=
name|Q
expr_stmt|;
block|}
comment|/* check the Y-turns */
if|if
condition|(
name|ras
operator|.
name|numTurns
operator|==
literal|0
condition|)
block|{
name|ras
operator|.
name|error
operator|=
name|Raster_Err_Invalid
expr_stmt|;
return|return
name|FAILURE
return|;
block|}
comment|/* now initialize the sweep */
name|ras
operator|.
name|Proc_Sweep_Init
argument_list|(
name|RAS_VARS
operator|&
name|min_Y
argument_list|,
operator|&
name|max_Y
argument_list|)
expr_stmt|;
comment|/* then compute the distance of each profile from min_Y */
name|P
operator|=
name|waiting
expr_stmt|;
while|while
condition|(
name|P
condition|)
block|{
name|P
operator|->
name|countL
operator|=
call|(
name|UShort
call|)
argument_list|(
name|P
operator|->
name|start
operator|-
name|min_Y
argument_list|)
expr_stmt|;
name|P
operator|=
name|P
operator|->
name|link
expr_stmt|;
block|}
comment|/* let's go */
name|y
operator|=
name|min_Y
expr_stmt|;
name|y_height
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ras
operator|.
name|numTurns
operator|>
literal|0
operator|&&
name|ras
operator|.
name|sizeBuff
index|[
operator|-
name|ras
operator|.
name|numTurns
index|]
operator|==
name|min_Y
condition|)
name|ras
operator|.
name|numTurns
operator|--
expr_stmt|;
while|while
condition|(
name|ras
operator|.
name|numTurns
operator|>
literal|0
condition|)
block|{
comment|/* check waiting list for new activations */
name|P
operator|=
name|waiting
expr_stmt|;
while|while
condition|(
name|P
condition|)
block|{
name|Q
operator|=
name|P
operator|->
name|link
expr_stmt|;
name|P
operator|->
name|countL
operator|-=
name|y_height
expr_stmt|;
if|if
condition|(
name|P
operator|->
name|countL
operator|==
literal|0
condition|)
block|{
name|DelOld
argument_list|(
operator|&
name|waiting
argument_list|,
name|P
argument_list|)
expr_stmt|;
if|if
condition|(
name|P
operator|->
name|flags
operator|&
name|Flow_Up
condition|)
name|InsNew
argument_list|(
operator|&
name|draw_left
argument_list|,
name|P
argument_list|)
expr_stmt|;
else|else
name|InsNew
argument_list|(
operator|&
name|draw_right
argument_list|,
name|P
argument_list|)
expr_stmt|;
block|}
name|P
operator|=
name|Q
expr_stmt|;
block|}
comment|/* sort the drawing lists */
name|Sort
argument_list|(
operator|&
name|draw_left
argument_list|)
expr_stmt|;
name|Sort
argument_list|(
operator|&
name|draw_right
argument_list|)
expr_stmt|;
name|y_change
operator|=
operator|(
name|Short
operator|)
name|ras
operator|.
name|sizeBuff
index|[
operator|-
name|ras
operator|.
name|numTurns
operator|--
index|]
expr_stmt|;
name|y_height
operator|=
call|(
name|Short
call|)
argument_list|(
name|y_change
operator|-
name|y
argument_list|)
expr_stmt|;
while|while
condition|(
name|y
operator|<
name|y_change
condition|)
block|{
comment|/* let's trace */
name|dropouts
operator|=
literal|0
expr_stmt|;
name|P_Left
operator|=
name|draw_left
expr_stmt|;
name|P_Right
operator|=
name|draw_right
expr_stmt|;
while|while
condition|(
name|P_Left
condition|)
block|{
name|x1
operator|=
name|P_Left
operator|->
name|X
expr_stmt|;
name|x2
operator|=
name|P_Right
operator|->
name|X
expr_stmt|;
if|if
condition|(
name|x1
operator|>
name|x2
condition|)
block|{
name|xs
operator|=
name|x1
expr_stmt|;
name|x1
operator|=
name|x2
expr_stmt|;
name|x2
operator|=
name|xs
expr_stmt|;
block|}
name|e1
operator|=
name|FLOOR
argument_list|(
name|x1
argument_list|)
expr_stmt|;
name|e2
operator|=
name|CEILING
argument_list|(
name|x2
argument_list|)
expr_stmt|;
if|if
condition|(
name|x2
operator|-
name|x1
operator|<=
name|ras
operator|.
name|precision
operator|&&
name|e1
operator|!=
name|x1
operator|&&
name|e2
operator|!=
name|x2
condition|)
block|{
if|if
condition|(
name|e1
operator|>
name|e2
operator|||
name|e2
operator|==
name|e1
operator|+
name|ras
operator|.
name|precision
condition|)
block|{
name|Int
name|dropOutControl
init|=
name|P_Left
operator|->
name|flags
operator|&
literal|7
decl_stmt|;
if|if
condition|(
name|dropOutControl
operator|!=
literal|2
condition|)
block|{
comment|/* a drop-out was detected */
name|P_Left
operator|->
name|X
operator|=
name|x1
expr_stmt|;
name|P_Right
operator|->
name|X
operator|=
name|x2
expr_stmt|;
comment|/* mark profile for drop-out processing */
name|P_Left
operator|->
name|countL
operator|=
literal|1
expr_stmt|;
name|dropouts
operator|++
expr_stmt|;
block|}
goto|goto
name|Skip_To_Next
goto|;
block|}
block|}
name|ras
operator|.
name|Proc_Sweep_Span
argument_list|(
argument|RAS_VARS y
argument_list|,
argument|x1
argument_list|,
argument|x2
argument_list|,
argument|P_Left
argument_list|,
argument|P_Right
argument_list|)
expr_stmt|;
name|Skip_To_Next
label|:
name|P_Left
operator|=
name|P_Left
operator|->
name|link
expr_stmt|;
name|P_Right
operator|=
name|P_Right
operator|->
name|link
expr_stmt|;
block|}
comment|/* handle drop-outs _after_ the span drawing --       */
comment|/* drop-out processing has been moved out of the loop */
comment|/* for performance tuning                             */
if|if
condition|(
name|dropouts
operator|>
literal|0
condition|)
goto|goto
name|Scan_DropOuts
goto|;
name|Next_Line
label|:
name|ras
operator|.
name|Proc_Sweep_Step
argument_list|(
name|RAS_VAR
argument_list|)
expr_stmt|;
name|y
operator|++
expr_stmt|;
if|if
condition|(
name|y
operator|<
name|y_change
condition|)
block|{
name|Sort
argument_list|(
operator|&
name|draw_left
argument_list|)
expr_stmt|;
name|Sort
argument_list|(
operator|&
name|draw_right
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* now finalize the profiles that need it */
name|P
operator|=
name|draw_left
expr_stmt|;
while|while
condition|(
name|P
condition|)
block|{
name|Q
operator|=
name|P
operator|->
name|link
expr_stmt|;
if|if
condition|(
name|P
operator|->
name|height
operator|==
literal|0
condition|)
name|DelOld
argument_list|(
operator|&
name|draw_left
argument_list|,
name|P
argument_list|)
expr_stmt|;
name|P
operator|=
name|Q
expr_stmt|;
block|}
name|P
operator|=
name|draw_right
expr_stmt|;
while|while
condition|(
name|P
condition|)
block|{
name|Q
operator|=
name|P
operator|->
name|link
expr_stmt|;
if|if
condition|(
name|P
operator|->
name|height
operator|==
literal|0
condition|)
name|DelOld
argument_list|(
operator|&
name|draw_right
argument_list|,
name|P
argument_list|)
expr_stmt|;
name|P
operator|=
name|Q
expr_stmt|;
block|}
block|}
comment|/* for gray-scaling, flush the bitmap scanline cache */
while|while
condition|(
name|y
operator|<=
name|max_Y
condition|)
block|{
name|ras
operator|.
name|Proc_Sweep_Step
argument_list|(
name|RAS_VAR
argument_list|)
expr_stmt|;
name|y
operator|++
expr_stmt|;
block|}
return|return
name|SUCCESS
return|;
name|Scan_DropOuts
label|:
name|P_Left
operator|=
name|draw_left
expr_stmt|;
name|P_Right
operator|=
name|draw_right
expr_stmt|;
while|while
condition|(
name|P_Left
condition|)
block|{
if|if
condition|(
name|P_Left
operator|->
name|countL
condition|)
block|{
name|P_Left
operator|->
name|countL
operator|=
literal|0
expr_stmt|;
if|#
directive|if
literal|0
block|dropouts--;
comment|/* -- this is useful when debugging only */
endif|#
directive|endif
name|ras
operator|.
name|Proc_Sweep_Drop
argument_list|(
argument|RAS_VARS y
argument_list|,
argument|P_Left->X
argument_list|,
argument|P_Right->X
argument_list|,
argument|P_Left
argument_list|,
argument|P_Right
argument_list|)
expr_stmt|;
block|}
name|P_Left
operator|=
name|P_Left
operator|->
name|link
expr_stmt|;
name|P_Right
operator|=
name|P_Right
operator|->
name|link
expr_stmt|;
block|}
goto|goto
name|Next_Line
goto|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    Render_Single_Pass                                                 */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Perform one sweep with sub-banding.                                */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    flipped :: If set, flip the direction of the outline.              */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    Renderer error code.                                               */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|int
DECL|function|Render_Single_Pass
name|Render_Single_Pass
parameter_list|(
name|RAS_ARGS
name|Bool
name|flipped
parameter_list|)
block|{
name|Short
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
while|while
condition|(
name|ras
operator|.
name|band_top
operator|>=
literal|0
condition|)
block|{
name|ras
operator|.
name|maxY
operator|=
operator|(
name|Long
operator|)
name|ras
operator|.
name|band_stack
index|[
name|ras
operator|.
name|band_top
index|]
operator|.
name|y_max
operator|*
name|ras
operator|.
name|precision
expr_stmt|;
name|ras
operator|.
name|minY
operator|=
operator|(
name|Long
operator|)
name|ras
operator|.
name|band_stack
index|[
name|ras
operator|.
name|band_top
index|]
operator|.
name|y_min
operator|*
name|ras
operator|.
name|precision
expr_stmt|;
name|ras
operator|.
name|top
operator|=
name|ras
operator|.
name|buff
expr_stmt|;
name|ras
operator|.
name|error
operator|=
name|Raster_Err_None
expr_stmt|;
if|if
condition|(
name|Convert_Glyph
argument_list|(
argument|RAS_VARS flipped
argument_list|)
condition|)
block|{
if|if
condition|(
name|ras
operator|.
name|error
operator|!=
name|Raster_Err_Overflow
condition|)
return|return
name|FAILURE
return|;
name|ras
operator|.
name|error
operator|=
name|Raster_Err_None
expr_stmt|;
comment|/* sub-banding */
ifdef|#
directive|ifdef
name|DEBUG_RASTER
name|ClearBand
argument_list|(
argument|RAS_VARS TRUNC( ras.minY )
argument_list|,
argument|TRUNC( ras.maxY )
argument_list|)
empty_stmt|;
endif|#
directive|endif
name|i
operator|=
name|ras
operator|.
name|band_stack
index|[
name|ras
operator|.
name|band_top
index|]
operator|.
name|y_min
expr_stmt|;
name|j
operator|=
name|ras
operator|.
name|band_stack
index|[
name|ras
operator|.
name|band_top
index|]
operator|.
name|y_max
expr_stmt|;
name|k
operator|=
call|(
name|Short
call|)
argument_list|(
operator|(
name|i
operator|+
name|j
operator|)
operator|/
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ras
operator|.
name|band_top
operator|>=
literal|7
operator|||
name|k
operator|<
name|i
condition|)
block|{
name|ras
operator|.
name|band_top
operator|=
literal|0
expr_stmt|;
name|ras
operator|.
name|error
operator|=
name|Raster_Err_Invalid
expr_stmt|;
return|return
name|ras
operator|.
name|error
return|;
block|}
name|ras
operator|.
name|band_stack
index|[
name|ras
operator|.
name|band_top
operator|+
literal|1
index|]
operator|.
name|y_min
operator|=
name|k
expr_stmt|;
name|ras
operator|.
name|band_stack
index|[
name|ras
operator|.
name|band_top
operator|+
literal|1
index|]
operator|.
name|y_max
operator|=
name|j
expr_stmt|;
name|ras
operator|.
name|band_stack
index|[
name|ras
operator|.
name|band_top
index|]
operator|.
name|y_max
operator|=
call|(
name|Short
call|)
argument_list|(
name|k
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ras
operator|.
name|band_top
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ras
operator|.
name|fProfile
condition|)
if|if
condition|(
name|Draw_Sweep
argument_list|(
name|RAS_VAR
argument_list|)
condition|)
return|return
name|ras
operator|.
name|error
return|;
name|ras
operator|.
name|band_top
operator|--
expr_stmt|;
block|}
block|}
return|return
name|SUCCESS
return|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    Render_Glyph                                                       */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Render a glyph in a bitmap.  Sub-banding if needed.                */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    FreeType error code.  0 means success.                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|Render_Glyph
argument_list|(
argument|RAS_ARG
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
decl_stmt|;
name|Set_High_Precision
argument_list|(
argument|RAS_VARS ras.outline.flags&                                  FT_OUTLINE_HIGH_PRECISION
argument_list|)
empty_stmt|;
name|ras
operator|.
name|scale_shift
operator|=
name|ras
operator|.
name|precision_shift
expr_stmt|;
if|if
condition|(
name|ras
operator|.
name|outline
operator|.
name|flags
operator|&
name|FT_OUTLINE_IGNORE_DROPOUTS
condition|)
name|ras
operator|.
name|dropOutControl
operator|=
literal|2
expr_stmt|;
else|else
block|{
if|if
condition|(
name|ras
operator|.
name|outline
operator|.
name|flags
operator|&
name|FT_OUTLINE_SMART_DROPOUTS
condition|)
name|ras
operator|.
name|dropOutControl
operator|=
literal|4
expr_stmt|;
else|else
name|ras
operator|.
name|dropOutControl
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ras
operator|.
name|outline
operator|.
name|flags
operator|&
name|FT_OUTLINE_INCLUDE_STUBS
operator|)
condition|)
name|ras
operator|.
name|dropOutControl
operator|+=
literal|1
expr_stmt|;
block|}
name|ras
operator|.
name|second_pass
operator|=
call|(
name|FT_Byte
call|)
argument_list|(
operator|!
operator|(
name|ras
operator|.
name|outline
operator|.
name|flags
operator|&
name|FT_OUTLINE_SINGLE_PASS
operator|)
argument_list|)
expr_stmt|;
comment|/* Vertical Sweep */
name|ras
operator|.
name|Proc_Sweep_Init
operator|=
name|Vertical_Sweep_Init
expr_stmt|;
name|ras
operator|.
name|Proc_Sweep_Span
operator|=
name|Vertical_Sweep_Span
expr_stmt|;
name|ras
operator|.
name|Proc_Sweep_Drop
operator|=
name|Vertical_Sweep_Drop
expr_stmt|;
name|ras
operator|.
name|Proc_Sweep_Step
operator|=
name|Vertical_Sweep_Step
expr_stmt|;
name|ras
operator|.
name|band_top
operator|=
literal|0
expr_stmt|;
name|ras
operator|.
name|band_stack
index|[
literal|0
index|]
operator|.
name|y_min
operator|=
literal|0
expr_stmt|;
name|ras
operator|.
name|band_stack
index|[
literal|0
index|]
operator|.
name|y_max
operator|=
call|(
name|short
call|)
argument_list|(
name|ras
operator|.
name|target
operator|.
name|rows
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ras
operator|.
name|bWidth
operator|=
operator|(
name|unsigned
name|short
operator|)
name|ras
operator|.
name|target
operator|.
name|width
expr_stmt|;
name|ras
operator|.
name|bTarget
operator|=
operator|(
name|Byte
operator|*
operator|)
name|ras
operator|.
name|target
operator|.
name|buffer
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|Render_Single_Pass
argument_list|(
name|RAS_VARS
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
comment|/* Horizontal Sweep */
if|if
condition|(
name|ras
operator|.
name|second_pass
operator|&&
name|ras
operator|.
name|dropOutControl
operator|!=
literal|2
condition|)
block|{
name|ras
operator|.
name|Proc_Sweep_Init
operator|=
name|Horizontal_Sweep_Init
expr_stmt|;
name|ras
operator|.
name|Proc_Sweep_Span
operator|=
name|Horizontal_Sweep_Span
expr_stmt|;
name|ras
operator|.
name|Proc_Sweep_Drop
operator|=
name|Horizontal_Sweep_Drop
expr_stmt|;
name|ras
operator|.
name|Proc_Sweep_Step
operator|=
name|Horizontal_Sweep_Step
expr_stmt|;
name|ras
operator|.
name|band_top
operator|=
literal|0
expr_stmt|;
name|ras
operator|.
name|band_stack
index|[
literal|0
index|]
operator|.
name|y_min
operator|=
literal|0
expr_stmt|;
name|ras
operator|.
name|band_stack
index|[
literal|0
index|]
operator|.
name|y_max
operator|=
call|(
name|short
call|)
argument_list|(
name|ras
operator|.
name|target
operator|.
name|width
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|Render_Single_Pass
argument_list|(
name|RAS_VARS
literal|1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
block|}
return|return
name|Raster_Err_None
return|;
block|}
end_block
begin_ifdef
ifdef|#
directive|ifdef
name|FT_RASTER_OPTION_ANTI_ALIASING
end_ifdef
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    Render_Gray_Glyph                                                  */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Render a glyph with grayscaling.  Sub-banding if needed.           */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    FreeType error code.  0 means success.                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|Render_Gray_Glyph
argument_list|(
argument|RAS_ARG
argument_list|)
end_macro
begin_block
block|{
name|Long
name|pixel_width
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|Set_High_Precision
argument_list|(
argument|RAS_VARS ras.outline.flags&                                  FT_OUTLINE_HIGH_PRECISION
argument_list|)
empty_stmt|;
name|ras
operator|.
name|scale_shift
operator|=
name|ras
operator|.
name|precision_shift
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|ras
operator|.
name|outline
operator|.
name|flags
operator|&
name|FT_OUTLINE_IGNORE_DROPOUTS
condition|)
name|ras
operator|.
name|dropOutControl
operator|=
literal|2
expr_stmt|;
else|else
block|{
if|if
condition|(
name|ras
operator|.
name|outline
operator|.
name|flags
operator|&
name|FT_OUTLINE_SMART_DROPOUTS
condition|)
name|ras
operator|.
name|dropOutControl
operator|=
literal|4
expr_stmt|;
else|else
name|ras
operator|.
name|dropOutControl
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ras
operator|.
name|outline
operator|.
name|flags
operator|&
name|FT_OUTLINE_INCLUDE_STUBS
operator|)
condition|)
name|ras
operator|.
name|dropOutControl
operator|+=
literal|1
expr_stmt|;
block|}
name|ras
operator|.
name|second_pass
operator|=
operator|!
operator|(
name|ras
operator|.
name|outline
operator|.
name|flags
operator|&
name|FT_OUTLINE_SINGLE_PASS
operator|)
expr_stmt|;
comment|/* Vertical Sweep */
name|ras
operator|.
name|band_top
operator|=
literal|0
expr_stmt|;
name|ras
operator|.
name|band_stack
index|[
literal|0
index|]
operator|.
name|y_min
operator|=
literal|0
expr_stmt|;
name|ras
operator|.
name|band_stack
index|[
literal|0
index|]
operator|.
name|y_max
operator|=
literal|2
operator|*
name|ras
operator|.
name|target
operator|.
name|rows
operator|-
literal|1
expr_stmt|;
name|ras
operator|.
name|bWidth
operator|=
name|ras
operator|.
name|gray_width
expr_stmt|;
name|pixel_width
operator|=
literal|2
operator|*
operator|(
operator|(
name|ras
operator|.
name|target
operator|.
name|width
operator|+
literal|3
operator|)
operator|>>
literal|2
operator|)
expr_stmt|;
if|if
condition|(
name|ras
operator|.
name|bWidth
operator|>
name|pixel_width
condition|)
name|ras
operator|.
name|bWidth
operator|=
name|pixel_width
expr_stmt|;
name|ras
operator|.
name|bWidth
operator|=
name|ras
operator|.
name|bWidth
operator|*
literal|8
expr_stmt|;
name|ras
operator|.
name|bTarget
operator|=
operator|(
name|Byte
operator|*
operator|)
name|ras
operator|.
name|gray_lines
expr_stmt|;
name|ras
operator|.
name|gTarget
operator|=
operator|(
name|Byte
operator|*
operator|)
name|ras
operator|.
name|target
operator|.
name|buffer
expr_stmt|;
name|ras
operator|.
name|Proc_Sweep_Init
operator|=
name|Vertical_Gray_Sweep_Init
expr_stmt|;
name|ras
operator|.
name|Proc_Sweep_Span
operator|=
name|Vertical_Sweep_Span
expr_stmt|;
name|ras
operator|.
name|Proc_Sweep_Drop
operator|=
name|Vertical_Sweep_Drop
expr_stmt|;
name|ras
operator|.
name|Proc_Sweep_Step
operator|=
name|Vertical_Gray_Sweep_Step
expr_stmt|;
name|error
operator|=
name|Render_Single_Pass
argument_list|(
name|RAS_VARS
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
comment|/* Horizontal Sweep */
if|if
condition|(
name|ras
operator|.
name|second_pass
operator|&&
name|ras
operator|.
name|dropOutControl
operator|!=
literal|2
condition|)
block|{
name|ras
operator|.
name|Proc_Sweep_Init
operator|=
name|Horizontal_Sweep_Init
expr_stmt|;
name|ras
operator|.
name|Proc_Sweep_Span
operator|=
name|Horizontal_Gray_Sweep_Span
expr_stmt|;
name|ras
operator|.
name|Proc_Sweep_Drop
operator|=
name|Horizontal_Gray_Sweep_Drop
expr_stmt|;
name|ras
operator|.
name|Proc_Sweep_Step
operator|=
name|Horizontal_Sweep_Step
expr_stmt|;
name|ras
operator|.
name|band_top
operator|=
literal|0
expr_stmt|;
name|ras
operator|.
name|band_stack
index|[
literal|0
index|]
operator|.
name|y_min
operator|=
literal|0
expr_stmt|;
name|ras
operator|.
name|band_stack
index|[
literal|0
index|]
operator|.
name|y_max
operator|=
name|ras
operator|.
name|target
operator|.
name|width
operator|*
literal|2
operator|-
literal|1
expr_stmt|;
name|error
operator|=
name|Render_Single_Pass
argument_list|(
name|RAS_VARS
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
block|}
return|return
name|Raster_Err_None
return|;
block|}
end_block
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* !FT_RASTER_OPTION_ANTI_ALIASING */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|Render_Gray_Glyph
argument_list|(
argument|RAS_ARG
argument_list|)
end_macro
begin_block
block|{
name|FT_UNUSED_RASTER
expr_stmt|;
return|return
name|Raster_Err_Unsupported
return|;
block|}
end_block
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* !FT_RASTER_OPTION_ANTI_ALIASING */
end_comment
begin_function
specifier|static
name|void
DECL|function|ft_black_init
name|ft_black_init
parameter_list|(
name|PRaster
name|raster
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|FT_RASTER_OPTION_ANTI_ALIASING
name|FT_UInt
name|n
decl_stmt|;
comment|/* set default 5-levels gray palette */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|5
condition|;
name|n
operator|++
control|)
name|raster
operator|->
name|grays
index|[
name|n
index|]
operator|=
name|n
operator|*
literal|255
operator|/
literal|4
expr_stmt|;
name|raster
operator|->
name|gray_width
operator|=
name|RASTER_GRAY_LINES
operator|/
literal|2
expr_stmt|;
else|#
directive|else
name|FT_UNUSED
argument_list|(
name|raster
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/**** RASTER OBJECT CREATION: In standalone mode, we simply use *****/
end_comment
begin_comment
comment|/****                         a static object.                  *****/
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|_STANDALONE_
end_ifdef
begin_function
specifier|static
name|int
DECL|function|ft_black_new
name|ft_black_new
parameter_list|(
name|void
modifier|*
name|memory
parameter_list|,
name|FT_Raster
modifier|*
name|araster
parameter_list|)
block|{
specifier|static
name|TRaster
name|the_raster
decl_stmt|;
operator|*
name|araster
operator|=
operator|(
name|FT_Raster
operator|)
operator|&
name|the_raster
expr_stmt|;
name|FT_MEM_ZERO
argument_list|(
operator|&
name|the_raster
argument_list|,
sizeof|sizeof
argument_list|(
name|the_raster
argument_list|)
argument_list|)
expr_stmt|;
name|ft_black_init
argument_list|(
operator|&
name|the_raster
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|ft_black_done
name|ft_black_done
parameter_list|(
name|FT_Raster
name|raster
parameter_list|)
block|{
comment|/* nothing */
name|FT_UNUSED
argument_list|(
name|raster
argument_list|)
expr_stmt|;
block|}
end_function
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* _STANDALONE_ */
end_comment
begin_function
specifier|static
name|int
DECL|function|ft_black_new
name|ft_black_new
parameter_list|(
name|FT_Memory
name|memory
parameter_list|,
name|PRaster
modifier|*
name|araster
parameter_list|)
block|{
name|FT_Error
name|error
decl_stmt|;
name|PRaster
name|raster
decl_stmt|;
operator|*
name|araster
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|FT_NEW
argument_list|(
name|raster
argument_list|)
condition|)
block|{
name|raster
operator|->
name|memory
operator|=
name|memory
expr_stmt|;
name|ft_black_init
argument_list|(
name|raster
argument_list|)
expr_stmt|;
operator|*
name|araster
operator|=
name|raster
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|ft_black_done
name|ft_black_done
parameter_list|(
name|PRaster
name|raster
parameter_list|)
block|{
name|FT_Memory
name|memory
init|=
operator|(
name|FT_Memory
operator|)
name|raster
operator|->
name|memory
decl_stmt|;
name|FT_FREE
argument_list|(
name|raster
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* _STANDALONE_ */
end_comment
begin_function
specifier|static
name|void
DECL|function|ft_black_reset
name|ft_black_reset
parameter_list|(
name|PRaster
name|raster
parameter_list|,
name|char
modifier|*
name|pool_base
parameter_list|,
name|long
name|pool_size
parameter_list|)
block|{
if|if
condition|(
name|raster
condition|)
block|{
if|if
condition|(
name|pool_base
operator|&&
name|pool_size
operator|>=
operator|(
name|long
operator|)
sizeof|sizeof
argument_list|(
name|TWorker
argument_list|)
operator|+
literal|2048
condition|)
block|{
name|PWorker
name|worker
init|=
operator|(
name|PWorker
operator|)
name|pool_base
decl_stmt|;
name|raster
operator|->
name|buffer
operator|=
name|pool_base
operator|+
operator|(
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|worker
argument_list|)
operator|+
literal|7
operator|)
operator|&
operator|~
literal|7
operator|)
expr_stmt|;
name|raster
operator|->
name|buffer_size
operator|=
operator|(
operator|(
name|pool_base
operator|+
name|pool_size
operator|)
operator|-
operator|(
name|char
operator|*
operator|)
name|raster
operator|->
name|buffer
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|Long
argument_list|)
expr_stmt|;
name|raster
operator|->
name|worker
operator|=
name|worker
expr_stmt|;
block|}
else|else
block|{
name|raster
operator|->
name|buffer
operator|=
name|NULL
expr_stmt|;
name|raster
operator|->
name|buffer_size
operator|=
literal|0
expr_stmt|;
name|raster
operator|->
name|worker
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|ft_black_set_mode
name|ft_black_set_mode
parameter_list|(
name|PRaster
name|raster
parameter_list|,
name|unsigned
name|long
name|mode
parameter_list|,
specifier|const
name|char
modifier|*
name|palette
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|FT_RASTER_OPTION_ANTI_ALIASING
if|if
condition|(
name|mode
operator|==
name|FT_MAKE_TAG
argument_list|(
literal|'p'
argument_list|,
literal|'a'
argument_list|,
literal|'l'
argument_list|,
literal|'5'
argument_list|)
condition|)
block|{
comment|/* set 5-levels gray palette */
name|raster
operator|->
name|grays
index|[
literal|0
index|]
operator|=
name|palette
index|[
literal|0
index|]
expr_stmt|;
name|raster
operator|->
name|grays
index|[
literal|1
index|]
operator|=
name|palette
index|[
literal|1
index|]
expr_stmt|;
name|raster
operator|->
name|grays
index|[
literal|2
index|]
operator|=
name|palette
index|[
literal|2
index|]
expr_stmt|;
name|raster
operator|->
name|grays
index|[
literal|3
index|]
operator|=
name|palette
index|[
literal|3
index|]
expr_stmt|;
name|raster
operator|->
name|grays
index|[
literal|4
index|]
operator|=
name|palette
index|[
literal|4
index|]
expr_stmt|;
block|}
else|#
directive|else
name|FT_UNUSED
argument_list|(
name|raster
argument_list|)
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|palette
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|ft_black_render
name|ft_black_render
parameter_list|(
name|PRaster
name|raster
parameter_list|,
specifier|const
name|FT_Raster_Params
modifier|*
name|params
parameter_list|)
block|{
specifier|const
name|FT_Outline
modifier|*
name|outline
init|=
operator|(
specifier|const
name|FT_Outline
operator|*
operator|)
name|params
operator|->
name|source
decl_stmt|;
specifier|const
name|FT_Bitmap
modifier|*
name|target_map
init|=
name|params
operator|->
name|target
decl_stmt|;
name|PWorker
name|worker
decl_stmt|;
if|if
condition|(
operator|!
name|raster
operator|||
operator|!
name|raster
operator|->
name|buffer
operator|||
operator|!
name|raster
operator|->
name|buffer_size
condition|)
return|return
name|Raster_Err_Not_Ini
return|;
if|if
condition|(
operator|!
name|outline
condition|)
return|return
name|Raster_Err_Invalid
return|;
comment|/* return immediately if the outline is empty */
if|if
condition|(
name|outline
operator|->
name|n_points
operator|==
literal|0
operator|||
name|outline
operator|->
name|n_contours
operator|<=
literal|0
condition|)
return|return
name|Raster_Err_None
return|;
if|if
condition|(
operator|!
name|outline
operator|->
name|contours
operator|||
operator|!
name|outline
operator|->
name|points
condition|)
return|return
name|Raster_Err_Invalid
return|;
if|if
condition|(
name|outline
operator|->
name|n_points
operator|!=
name|outline
operator|->
name|contours
index|[
name|outline
operator|->
name|n_contours
operator|-
literal|1
index|]
operator|+
literal|1
condition|)
return|return
name|Raster_Err_Invalid
return|;
name|worker
operator|=
name|raster
operator|->
name|worker
expr_stmt|;
comment|/* this version of the raster does not support direct rendering, sorry */
if|if
condition|(
name|params
operator|->
name|flags
operator|&
name|FT_RASTER_FLAG_DIRECT
condition|)
return|return
name|Raster_Err_Unsupported
return|;
if|if
condition|(
operator|!
name|target_map
condition|)
return|return
name|Raster_Err_Invalid
return|;
comment|/* nothing to do */
if|if
condition|(
operator|!
name|target_map
operator|->
name|width
operator|||
operator|!
name|target_map
operator|->
name|rows
condition|)
return|return
name|Raster_Err_None
return|;
if|if
condition|(
operator|!
name|target_map
operator|->
name|buffer
condition|)
return|return
name|Raster_Err_Invalid
return|;
name|ras
operator|.
name|outline
operator|=
operator|*
name|outline
expr_stmt|;
name|ras
operator|.
name|target
operator|=
operator|*
name|target_map
expr_stmt|;
name|worker
operator|->
name|buff
operator|=
operator|(
name|PLong
operator|)
name|raster
operator|->
name|buffer
expr_stmt|;
name|worker
operator|->
name|sizeBuff
operator|=
name|worker
operator|->
name|buff
operator|+
name|raster
operator|->
name|buffer_size
operator|/
sizeof|sizeof
argument_list|(
name|Long
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FT_RASTER_OPTION_ANTI_ALIASING
name|worker
operator|->
name|grays
operator|=
name|raster
operator|->
name|grays
expr_stmt|;
name|worker
operator|->
name|gray_width
operator|=
name|raster
operator|->
name|gray_width
expr_stmt|;
name|FT_MEM_ZERO
argument_list|(
name|worker
operator|->
name|gray_lines
argument_list|,
name|worker
operator|->
name|gray_width
operator|*
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|params
operator|->
name|flags
operator|&
name|FT_RASTER_FLAG_AA
operator|)
condition|?
name|Render_Gray_Glyph
argument_list|(
name|RAS_VAR
argument_list|)
else|:
name|Render_Glyph
argument_list|(
name|RAS_VAR
argument_list|)
return|;
block|}
end_function
begin_macro
name|FT_DEFINE_RASTER_FUNCS
argument_list|(
argument|ft_standard_raster
argument_list|,
argument|FT_GLYPH_FORMAT_OUTLINE
argument_list|,
argument|(FT_Raster_New_Func)     ft_black_new
argument_list|,
argument|(FT_Raster_Reset_Func)   ft_black_reset
argument_list|,
argument|(FT_Raster_Set_Mode_Func)ft_black_set_mode
argument_list|,
argument|(FT_Raster_Render_Func)  ft_black_render
argument_list|,
argument|(FT_Raster_Done_Func)    ft_black_done
argument_list|)
end_macro
begin_comment
comment|/* END */
end_comment
end_unit
