begin_unit
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  ftraster.c                                                             */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*    The FreeType glyph rasterizer (body).                                */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  Copyright 1996-2015 by                                                 */
end_comment
begin_comment
comment|/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  This file is part of the FreeType project, and may only be used,       */
end_comment
begin_comment
comment|/*  modified, and distributed under the terms of the FreeType project      */
end_comment
begin_comment
comment|/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
end_comment
begin_comment
comment|/*  this file you indicate that you have read the license and              */
end_comment
begin_comment
comment|/*  understand and accept it fully.                                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* This file can be compiled without the rest of the FreeType engine, by */
end_comment
begin_comment
comment|/* defining the _STANDALONE_ macro when compiling it.  You also need to  */
end_comment
begin_comment
comment|/* put the files `ftimage.h' and `ftmisc.h' into the $(incdir)           */
end_comment
begin_comment
comment|/* directory.  Typically, you should do something like                   */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* - copy `src/raster/ftraster.c' (this file) to your current directory  */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* - copy `include/freetype/ftimage.h' and `src/raster/ftmisc.h' to your */
end_comment
begin_comment
comment|/*   current directory                                                   */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* - compile `ftraster' with the _STANDALONE_ macro defined, as in       */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*     cc -c -D_STANDALONE_ ftraster.c                                   */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* The renderer can be initialized with a call to                        */
end_comment
begin_comment
comment|/* `ft_standard_raster.raster_new'; a bitmap can be generated            */
end_comment
begin_comment
comment|/* with a call to `ft_standard_raster.raster_render'.                    */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* See the comments and documentation in the file `ftimage.h' for more   */
end_comment
begin_comment
comment|/* details on how the raster works.                                      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* This is a rewrite of the FreeType 1.x scan-line converter             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|_STANDALONE_
end_ifdef
begin_comment
comment|/* The size in bytes of the render pool used by the scan-line converter  */
end_comment
begin_comment
comment|/* to do all of its work.                                                */
end_comment
begin_define
DECL|macro|FT_RENDER_POOL_SIZE
define|#
directive|define
name|FT_RENDER_POOL_SIZE
value|16384L
end_define
begin_define
DECL|macro|FT_CONFIG_STANDARD_LIBRARY_H
define|#
directive|define
name|FT_CONFIG_STANDARD_LIBRARY_H
value|<stdlib.h>
end_define
begin_include
include|#
directive|include
file|<string.h>
end_include
begin_comment
comment|/* for memset */
end_comment
begin_include
include|#
directive|include
file|"ftmisc.h"
end_include
begin_include
include|#
directive|include
file|"ftimage.h"
end_include
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* !_STANDALONE_ */
end_comment
begin_include
include|#
directive|include
file|<ft2build.h>
end_include
begin_include
include|#
directive|include
file|"ftraster.h"
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_CALC_H
end_include
begin_comment
comment|/* for FT_MulDiv and FT_MulDiv_No_Round */
end_comment
begin_include
include|#
directive|include
file|"rastpic.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* !_STANDALONE_ */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* A simple technical note on how the raster works                       */
end_comment
begin_comment
comment|/* -----------------------------------------------                       */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*   Converting an outline into a bitmap is achieved in several steps:   */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*   1 - Decomposing the outline into successive `profiles'.  Each       */
end_comment
begin_comment
comment|/*       profile is simply an array of scanline intersections on a given */
end_comment
begin_comment
comment|/*       dimension.  A profile's main attributes are                     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*       o its scanline position boundaries, i.e. `Ymin' and `Ymax'      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*       o an array of intersection coordinates for each scanline        */
end_comment
begin_comment
comment|/*         between `Ymin' and `Ymax'                                     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*       o a direction, indicating whether it was built going `up' or    */
end_comment
begin_comment
comment|/*         `down', as this is very important for filling rules           */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*       o its drop-out mode                                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*   2 - Sweeping the target map's scanlines in order to compute segment */
end_comment
begin_comment
comment|/*       `spans' which are then filled.  Additionally, this pass         */
end_comment
begin_comment
comment|/*       performs drop-out control.                                      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*   The outline data is parsed during step 1 only.  The profiles are    */
end_comment
begin_comment
comment|/*   built from the bottom of the render pool, used as a stack.  The     */
end_comment
begin_comment
comment|/*   following graphics shows the profile list under construction:       */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*     __________________________________________________________ _ _    */
end_comment
begin_comment
comment|/*    |         |                 |         |                 |          */
end_comment
begin_comment
comment|/*    | profile | coordinates for | profile | coordinates for |-->       */
end_comment
begin_comment
comment|/*    |    1    |  profile 1      |    2    |  profile 2      |-->       */
end_comment
begin_comment
comment|/*    |_________|_________________|_________|_________________|__ _ _    */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    ^                                                       ^          */
end_comment
begin_comment
comment|/*    |                                                       |          */
end_comment
begin_comment
comment|/* start of render pool                                      top         */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*   The top of the profile stack is kept in the `top' variable.         */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*   As you can see, a profile record is pushed on top of the render     */
end_comment
begin_comment
comment|/*   pool, which is then followed by its coordinates/intersections.  If  */
end_comment
begin_comment
comment|/*   a change of direction is detected in the outline, a new profile is  */
end_comment
begin_comment
comment|/*   generated until the end of the outline.                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*   Note that when all profiles have been generated, the function       */
end_comment
begin_comment
comment|/*   Finalize_Profile_Table() is used to record, for each profile, its   */
end_comment
begin_comment
comment|/*   bottom-most scanline as well as the scanline above its upmost       */
end_comment
begin_comment
comment|/*   boundary.  These positions are called `y-turns' because they (sort  */
end_comment
begin_comment
comment|/*   of) correspond to local extrema.  They are stored in a sorted list  */
end_comment
begin_comment
comment|/*   built from the top of the render pool as a downwards stack:         */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*      _ _ _______________________________________                      */
end_comment
begin_comment
comment|/*                            |                    |                     */
end_comment
begin_comment
comment|/*<--| sorted list of     |                     */
end_comment
begin_comment
comment|/*<--|  extrema scanlines |                     */
end_comment
begin_comment
comment|/*      _ _ __________________|____________________|                     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*                            ^                    ^                     */
end_comment
begin_comment
comment|/*                            |                    |                     */
end_comment
begin_comment
comment|/*                         maxBuff           sizeBuff = end of pool      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*   This list is later used during the sweep phase in order to          */
end_comment
begin_comment
comment|/*   optimize performance (see technical note on the sweep below).       */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*   Of course, the raster detects whether the two stacks collide and    */
end_comment
begin_comment
comment|/*   handles the situation properly.                                     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/**                                                                     **/
end_comment
begin_comment
comment|/**  CONFIGURATION MACROS                                               **/
end_comment
begin_comment
comment|/**                                                                     **/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/* define DEBUG_RASTER if you want to compile a debugging version */
end_comment
begin_comment
comment|/* #define DEBUG_RASTER */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/**                                                                     **/
end_comment
begin_comment
comment|/**  OTHER MACROS (do not change)                                       **/
end_comment
begin_comment
comment|/**                                                                     **/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
end_comment
begin_comment
comment|/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
end_comment
begin_comment
comment|/* messages during execution.                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_undef
DECL|macro|FT_COMPONENT
undef|#
directive|undef
name|FT_COMPONENT
end_undef
begin_define
DECL|macro|FT_COMPONENT
define|#
directive|define
name|FT_COMPONENT
value|trace_raster
end_define
begin_ifdef
ifdef|#
directive|ifdef
name|_STANDALONE_
end_ifdef
begin_comment
comment|/* Auxiliary macros for token concatenation. */
end_comment
begin_define
DECL|macro|FT_ERR_XCAT
define|#
directive|define
name|FT_ERR_XCAT
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|x ## y
end_define
begin_define
DECL|macro|FT_ERR_CAT
define|#
directive|define
name|FT_ERR_CAT
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|FT_ERR_XCAT( x, y )
end_define
begin_define
DECL|macro|FT_MAX
define|#
directive|define
name|FT_MAX
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|( (a)> (b) ? (a) : (b) )
end_define
begin_comment
comment|/* This macro is used to indicate that a function parameter is unused. */
end_comment
begin_comment
comment|/* Its purpose is simply to reduce compiler warnings.  Note also that  */
end_comment
begin_comment
comment|/* simply defining it as `(void)x' doesn't avoid warnings with certain */
end_comment
begin_comment
comment|/* ANSI compilers (e.g. LCC).                                          */
end_comment
begin_define
DECL|macro|FT_UNUSED
define|#
directive|define
name|FT_UNUSED
parameter_list|(
name|x
parameter_list|)
value|(x) = (x)
end_define
begin_comment
comment|/* Disable the tracing mechanism for simplicity -- developers can      */
end_comment
begin_comment
comment|/* activate it easily by redefining these macros.                      */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|FT_ERROR
end_ifndef
begin_define
DECL|macro|FT_ERROR
define|#
directive|define
name|FT_ERROR
parameter_list|(
name|x
parameter_list|)
value|do { } while ( 0 )
end_define
begin_comment
DECL|macro|FT_ERROR
comment|/* nothing */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|FT_TRACE
end_ifndef
begin_define
DECL|macro|FT_TRACE
define|#
directive|define
name|FT_TRACE
parameter_list|(
name|x
parameter_list|)
value|do { } while ( 0 )
end_define
begin_comment
DECL|macro|FT_TRACE
comment|/* nothing */
end_comment
begin_define
DECL|macro|FT_TRACE1
define|#
directive|define
name|FT_TRACE1
parameter_list|(
name|x
parameter_list|)
value|do { } while ( 0 )
end_define
begin_comment
DECL|macro|FT_TRACE1
comment|/* nothing */
end_comment
begin_define
DECL|macro|FT_TRACE6
define|#
directive|define
name|FT_TRACE6
parameter_list|(
name|x
parameter_list|)
value|do { } while ( 0 )
end_define
begin_comment
DECL|macro|FT_TRACE6
comment|/* nothing */
end_comment
begin_define
DECL|macro|FT_TRACE7
define|#
directive|define
name|FT_TRACE7
parameter_list|(
name|x
parameter_list|)
value|do { } while ( 0 )
end_define
begin_comment
DECL|macro|FT_TRACE7
comment|/* nothing */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|FT_THROW
end_ifndef
begin_define
DECL|macro|FT_THROW
define|#
directive|define
name|FT_THROW
parameter_list|(
name|e
parameter_list|)
value|FT_ERR_CAT( Raster_Err_, e )
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|Raster_Err_None
define|#
directive|define
name|Raster_Err_None
value|0
end_define
begin_define
DECL|macro|Raster_Err_Not_Ini
define|#
directive|define
name|Raster_Err_Not_Ini
value|-1
end_define
begin_define
DECL|macro|Raster_Err_Overflow
define|#
directive|define
name|Raster_Err_Overflow
value|-2
end_define
begin_define
DECL|macro|Raster_Err_Neg_Height
define|#
directive|define
name|Raster_Err_Neg_Height
value|-3
end_define
begin_define
DECL|macro|Raster_Err_Invalid
define|#
directive|define
name|Raster_Err_Invalid
value|-4
end_define
begin_define
DECL|macro|Raster_Err_Unsupported
define|#
directive|define
name|Raster_Err_Unsupported
value|-5
end_define
begin_define
DECL|macro|ft_memset
define|#
directive|define
name|ft_memset
value|memset
end_define
begin_define
DECL|macro|FT_DEFINE_RASTER_FUNCS
define|#
directive|define
name|FT_DEFINE_RASTER_FUNCS
parameter_list|(
name|class_
parameter_list|,
name|glyph_format_
parameter_list|,
name|raster_new_
parameter_list|, \
name|raster_reset_
parameter_list|,
name|raster_set_mode_
parameter_list|,    \
name|raster_render_
parameter_list|,
name|raster_done_
parameter_list|)
define|\
value|const FT_Raster_Funcs class_ =                            \           {                                                         \             glyph_format_,                                          \             raster_new_,                                            \             raster_reset_,                                          \             raster_set_mode_,                                       \             raster_render_,                                         \             raster_done_                                            \          };
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* !_STANDALONE_ */
end_comment
begin_include
include|#
directive|include
include|FT_INTERNAL_OBJECTS_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_DEBUG_H
end_include
begin_comment
comment|/* for FT_TRACE, FT_ERROR, and FT_THROW */
end_comment
begin_include
include|#
directive|include
file|"rasterrs.h"
end_include
begin_define
DECL|macro|Raster_Err_None
define|#
directive|define
name|Raster_Err_None
value|FT_Err_Ok
end_define
begin_define
DECL|macro|Raster_Err_Not_Ini
define|#
directive|define
name|Raster_Err_Not_Ini
value|Raster_Err_Raster_Uninitialized
end_define
begin_define
DECL|macro|Raster_Err_Overflow
define|#
directive|define
name|Raster_Err_Overflow
value|Raster_Err_Raster_Overflow
end_define
begin_define
DECL|macro|Raster_Err_Neg_Height
define|#
directive|define
name|Raster_Err_Neg_Height
value|Raster_Err_Raster_Negative_Height
end_define
begin_define
DECL|macro|Raster_Err_Invalid
define|#
directive|define
name|Raster_Err_Invalid
value|Raster_Err_Invalid_Outline
end_define
begin_define
DECL|macro|Raster_Err_Unsupported
define|#
directive|define
name|Raster_Err_Unsupported
value|Raster_Err_Cannot_Render_Glyph
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* !_STANDALONE_ */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|FT_MEM_SET
end_ifndef
begin_define
DECL|macro|FT_MEM_SET
define|#
directive|define
name|FT_MEM_SET
parameter_list|(
name|d
parameter_list|,
name|s
parameter_list|,
name|c
parameter_list|)
value|ft_memset( d, s, c )
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|FT_MEM_ZERO
end_ifndef
begin_define
DECL|macro|FT_MEM_ZERO
define|#
directive|define
name|FT_MEM_ZERO
parameter_list|(
name|dest
parameter_list|,
name|count
parameter_list|)
value|FT_MEM_SET( dest, 0, count )
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* FMulDiv means `Fast MulDiv'; it is used in case where `b' is       */
end_comment
begin_comment
comment|/* typically a small value and the result of a*b is known to fit into */
end_comment
begin_comment
comment|/* 32 bits.                                                           */
end_comment
begin_define
DECL|macro|FMulDiv
define|#
directive|define
name|FMulDiv
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
value|( (a) * (b) / (c) )
end_define
begin_comment
comment|/* On the other hand, SMulDiv means `Slow MulDiv', and is used typically */
end_comment
begin_comment
comment|/* for clipping computations.  It simply uses the FT_MulDiv() function   */
end_comment
begin_comment
comment|/* defined in `ftcalc.h'.                                                */
end_comment
begin_define
DECL|macro|SMulDiv
define|#
directive|define
name|SMulDiv
value|FT_MulDiv
end_define
begin_define
DECL|macro|SMulDiv_No_Round
define|#
directive|define
name|SMulDiv_No_Round
value|FT_MulDiv_No_Round
end_define
begin_comment
comment|/* The rasterizer is a very general purpose component; please leave */
end_comment
begin_comment
comment|/* the following redefinitions there (you never know your target    */
end_comment
begin_comment
comment|/* environment).                                                    */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|TRUE
end_ifndef
begin_define
DECL|macro|TRUE
define|#
directive|define
name|TRUE
value|1
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|FALSE
end_ifndef
begin_define
DECL|macro|FALSE
define|#
directive|define
name|FALSE
value|0
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|NULL
end_ifndef
begin_define
DECL|macro|NULL
define|#
directive|define
name|NULL
value|(void*)0
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|SUCCESS
end_ifndef
begin_define
DECL|macro|SUCCESS
define|#
directive|define
name|SUCCESS
value|0
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|FAILURE
end_ifndef
begin_define
DECL|macro|FAILURE
define|#
directive|define
name|FAILURE
value|1
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|MaxBezier
define|#
directive|define
name|MaxBezier
value|32
end_define
begin_comment
DECL|macro|MaxBezier
comment|/* The maximum number of stacked Bezier curves. */
end_comment
begin_comment
comment|/* Setting this constant to more than 32 is a   */
end_comment
begin_comment
comment|/* pure waste of space.                         */
end_comment
begin_define
DECL|macro|Pixel_Bits
define|#
directive|define
name|Pixel_Bits
value|6
end_define
begin_comment
DECL|macro|Pixel_Bits
comment|/* fractional bits of *input* coordinates */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/**                                                                     **/
end_comment
begin_comment
comment|/**  SIMPLE TYPE DECLARATIONS                                           **/
end_comment
begin_comment
comment|/**                                                                     **/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_typedef
DECL|typedef|Int
typedef|typedef
name|int
name|Int
typedef|;
end_typedef
begin_typedef
DECL|typedef|UInt
typedef|typedef
name|unsigned
name|int
name|UInt
typedef|;
end_typedef
begin_typedef
DECL|typedef|Short
typedef|typedef
name|short
name|Short
typedef|;
end_typedef
begin_typedef
DECL|typedef|UShort
DECL|typedef|PUShort
typedef|typedef
name|unsigned
name|short
name|UShort
typedef|,
modifier|*
name|PUShort
typedef|;
end_typedef
begin_typedef
DECL|typedef|Long
DECL|typedef|PLong
typedef|typedef
name|long
name|Long
typedef|,
modifier|*
name|PLong
typedef|;
end_typedef
begin_typedef
DECL|typedef|ULong
typedef|typedef
name|unsigned
name|long
name|ULong
typedef|;
end_typedef
begin_typedef
DECL|typedef|Byte
DECL|typedef|PByte
typedef|typedef
name|unsigned
name|char
name|Byte
typedef|,
modifier|*
name|PByte
typedef|;
end_typedef
begin_typedef
DECL|typedef|Bool
typedef|typedef
name|char
name|Bool
typedef|;
end_typedef
begin_typedef
DECL|union|Alignment_
typedef|typedef
union|union
name|Alignment_
block|{
DECL|member|l
name|Long
name|l
decl_stmt|;
DECL|member|p
name|void
modifier|*
name|p
decl_stmt|;
DECL|member|f
name|void
function_decl|(
modifier|*
name|f
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
block|}
DECL|typedef|Alignment
DECL|typedef|PAlignment
name|Alignment
operator|,
typedef|*
name|PAlignment
typedef|;
end_typedef
begin_typedef
DECL|struct|TPoint_
typedef|typedef
struct|struct
name|TPoint_
block|{
DECL|member|x
name|Long
name|x
decl_stmt|;
DECL|member|y
name|Long
name|y
decl_stmt|;
block|}
DECL|typedef|TPoint
name|TPoint
typedef|;
end_typedef
begin_comment
comment|/* values for the `flags' bit field */
end_comment
begin_define
DECL|macro|Flow_Up
define|#
directive|define
name|Flow_Up
value|0x08U
end_define
begin_define
DECL|macro|Overshoot_Top
define|#
directive|define
name|Overshoot_Top
value|0x10U
end_define
begin_define
DECL|macro|Overshoot_Bottom
define|#
directive|define
name|Overshoot_Bottom
value|0x20U
end_define
begin_comment
comment|/* States of each line, arc, and profile */
end_comment
begin_typedef
DECL|enum|TStates_
typedef|typedef
enum|enum
name|TStates_
block|{
DECL|enumerator|Unknown_State
name|Unknown_State
block|,
DECL|enumerator|Ascending_State
name|Ascending_State
block|,
DECL|enumerator|Descending_State
name|Descending_State
block|,
DECL|enumerator|Flat_State
name|Flat_State
block|}
DECL|typedef|TStates
name|TStates
typedef|;
end_typedef
begin_typedef
DECL|typedef|TProfile
typedef|typedef
name|struct
name|TProfile_
name|TProfile
typedef|;
end_typedef
begin_typedef
DECL|typedef|PProfile
typedef|typedef
name|TProfile
modifier|*
name|PProfile
typedef|;
end_typedef
begin_struct
DECL|struct|TProfile_
struct|struct
name|TProfile_
block|{
DECL|member|X
name|FT_F26Dot6
name|X
decl_stmt|;
comment|/* current coordinate during sweep          */
DECL|member|link
name|PProfile
name|link
decl_stmt|;
comment|/* link to next profile (various purposes)  */
DECL|member|offset
name|PLong
name|offset
decl_stmt|;
comment|/* start of profile's data in render pool   */
DECL|member|flags
name|UShort
name|flags
decl_stmt|;
comment|/* Bit 0-2: drop-out mode                   */
comment|/* Bit 3: profile orientation (up/down)     */
comment|/* Bit 4: is top profile?                   */
comment|/* Bit 5: is bottom profile?                */
DECL|member|height
name|Long
name|height
decl_stmt|;
comment|/* profile's height in scanlines            */
DECL|member|start
name|Long
name|start
decl_stmt|;
comment|/* profile's starting scanline              */
DECL|member|countL
name|Int
name|countL
decl_stmt|;
comment|/* number of lines to step before this      */
comment|/* profile becomes drawable                 */
DECL|member|next
name|PProfile
name|next
decl_stmt|;
comment|/* next profile in same contour, used       */
comment|/* during drop-out control                  */
block|}
struct|;
end_struct
begin_typedef
DECL|typedef|TProfileList
typedef|typedef
name|PProfile
name|TProfileList
typedef|;
end_typedef
begin_typedef
DECL|typedef|PProfileList
typedef|typedef
name|PProfile
modifier|*
name|PProfileList
typedef|;
end_typedef
begin_comment
comment|/* Simple record used to implement a stack of bands, required */
end_comment
begin_comment
comment|/* by the sub-banding mechanism                               */
end_comment
begin_typedef
DECL|struct|black_TBand_
typedef|typedef
struct|struct
name|black_TBand_
block|{
DECL|member|y_min
name|Short
name|y_min
decl_stmt|;
comment|/* band's minimum */
DECL|member|y_max
name|Short
name|y_max
decl_stmt|;
comment|/* band's maximum */
block|}
DECL|typedef|black_TBand
name|black_TBand
typedef|;
end_typedef
begin_define
DECL|macro|AlignProfileSize
define|#
directive|define
name|AlignProfileSize
define|\
value|( ( sizeof ( TProfile ) + sizeof ( Alignment ) - 1 ) / sizeof ( Long ) )
end_define
begin_undef
DECL|macro|RAS_ARG
undef|#
directive|undef
name|RAS_ARG
end_undef
begin_undef
DECL|macro|RAS_ARGS
undef|#
directive|undef
name|RAS_ARGS
end_undef
begin_undef
DECL|macro|RAS_VAR
undef|#
directive|undef
name|RAS_VAR
end_undef
begin_undef
DECL|macro|RAS_VARS
undef|#
directive|undef
name|RAS_VARS
end_undef
begin_ifdef
ifdef|#
directive|ifdef
name|FT_STATIC_RASTER
end_ifdef
begin_define
DECL|macro|RAS_ARGS
define|#
directive|define
name|RAS_ARGS
end_define
begin_comment
DECL|macro|RAS_ARGS
comment|/* void */
end_comment
begin_define
DECL|macro|RAS_ARG
define|#
directive|define
name|RAS_ARG
end_define
begin_comment
DECL|macro|RAS_ARG
comment|/* void */
end_comment
begin_define
DECL|macro|RAS_VARS
define|#
directive|define
name|RAS_VARS
end_define
begin_comment
DECL|macro|RAS_VARS
comment|/* void */
end_comment
begin_define
DECL|macro|RAS_VAR
define|#
directive|define
name|RAS_VAR
end_define
begin_comment
DECL|macro|RAS_VAR
comment|/* void */
end_comment
begin_define
DECL|macro|FT_UNUSED_RASTER
define|#
directive|define
name|FT_UNUSED_RASTER
value|do { } while ( 0 )
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* !FT_STATIC_RASTER */
end_comment
begin_define
DECL|macro|RAS_ARGS
define|#
directive|define
name|RAS_ARGS
value|black_PWorker  worker,
end_define
begin_define
DECL|macro|RAS_ARG
define|#
directive|define
name|RAS_ARG
value|black_PWorker  worker
end_define
begin_define
DECL|macro|RAS_VARS
define|#
directive|define
name|RAS_VARS
value|worker,
end_define
begin_define
DECL|macro|RAS_VAR
define|#
directive|define
name|RAS_VAR
value|worker
end_define
begin_define
DECL|macro|FT_UNUSED_RASTER
define|#
directive|define
name|FT_UNUSED_RASTER
value|FT_UNUSED( worker )
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* !FT_STATIC_RASTER */
end_comment
begin_typedef
DECL|typedef|black_TWorker
DECL|typedef|black_PWorker
typedef|typedef
name|struct
name|black_TWorker_
name|black_TWorker
typedef|,
modifier|*
name|black_PWorker
typedef|;
end_typedef
begin_comment
comment|/* prototypes used for sweep function dispatch */
end_comment
begin_typedef
typedef|typedef
name|void
DECL|typedef|Function_Sweep_Init
name|Function_Sweep_Init
parameter_list|(
name|RAS_ARGS
name|Short
modifier|*
name|min
parameter_list|,
name|Short
modifier|*
name|max
parameter_list|)
function_decl|;
end_typedef
begin_typedef
typedef|typedef
name|void
DECL|typedef|Function_Sweep_Span
name|Function_Sweep_Span
parameter_list|(
name|RAS_ARGS
name|Short
name|y
parameter_list|,
name|FT_F26Dot6
name|x1
parameter_list|,
name|FT_F26Dot6
name|x2
parameter_list|,
name|PProfile
name|left
parameter_list|,
name|PProfile
name|right
parameter_list|)
function_decl|;
end_typedef
begin_typedef
typedef|typedef
name|void
DECL|typedef|Function_Sweep_Step
name|Function_Sweep_Step
parameter_list|(
name|RAS_ARG
parameter_list|)
function_decl|;
end_typedef
begin_comment
comment|/* NOTE: These operations are only valid on 2's complement processors */
end_comment
begin_undef
DECL|macro|FLOOR
undef|#
directive|undef
name|FLOOR
end_undef
begin_undef
DECL|macro|CEILING
undef|#
directive|undef
name|CEILING
end_undef
begin_undef
DECL|macro|TRUNC
undef|#
directive|undef
name|TRUNC
end_undef
begin_undef
DECL|macro|SCALED
undef|#
directive|undef
name|SCALED
end_undef
begin_define
DECL|macro|FLOOR
define|#
directive|define
name|FLOOR
parameter_list|(
name|x
parameter_list|)
value|( (x)& -ras.precision )
end_define
begin_define
DECL|macro|CEILING
define|#
directive|define
name|CEILING
parameter_list|(
name|x
parameter_list|)
value|( ( (x) + ras.precision - 1 )& -ras.precision )
end_define
begin_define
DECL|macro|TRUNC
define|#
directive|define
name|TRUNC
parameter_list|(
name|x
parameter_list|)
value|( (Long)(x)>> ras.precision_bits )
end_define
begin_define
DECL|macro|FRAC
define|#
directive|define
name|FRAC
parameter_list|(
name|x
parameter_list|)
value|( (x)& ( ras.precision - 1 ) )
end_define
begin_define
DECL|macro|SCALED
define|#
directive|define
name|SCALED
parameter_list|(
name|x
parameter_list|)
value|( ( (x)< 0 ? -( -(x)<< ras.scale_shift )   \                                   :  (  (x)<< ras.scale_shift ) ) \                         - ras.precision_half )
end_define
begin_define
DECL|macro|IS_BOTTOM_OVERSHOOT
define|#
directive|define
name|IS_BOTTOM_OVERSHOOT
parameter_list|(
name|x
parameter_list|)
define|\
value|(Bool)( CEILING( x ) - x>= ras.precision_half )
end_define
begin_define
DECL|macro|IS_TOP_OVERSHOOT
define|#
directive|define
name|IS_TOP_OVERSHOOT
parameter_list|(
name|x
parameter_list|)
define|\
value|(Bool)( x - FLOOR( x )>= ras.precision_half )
end_define
begin_comment
comment|/* The most used variables are positioned at the top of the structure. */
end_comment
begin_comment
comment|/* Thus, their offset can be coded with less opcodes, resulting in a   */
end_comment
begin_comment
comment|/* smaller executable.                                                 */
end_comment
begin_struct
DECL|struct|black_TWorker_
struct|struct
name|black_TWorker_
block|{
DECL|member|precision_bits
name|Int
name|precision_bits
decl_stmt|;
comment|/* precision related variables         */
DECL|member|precision
name|Int
name|precision
decl_stmt|;
DECL|member|precision_half
name|Int
name|precision_half
decl_stmt|;
DECL|member|precision_shift
name|Int
name|precision_shift
decl_stmt|;
DECL|member|precision_step
name|Int
name|precision_step
decl_stmt|;
DECL|member|precision_jitter
name|Int
name|precision_jitter
decl_stmt|;
DECL|member|scale_shift
name|Int
name|scale_shift
decl_stmt|;
comment|/* == precision_shift   for bitmaps    */
comment|/* == precision_shift+1 for pixmaps    */
DECL|member|buff
name|PLong
name|buff
decl_stmt|;
comment|/* The profiles buffer                 */
DECL|member|sizeBuff
name|PLong
name|sizeBuff
decl_stmt|;
comment|/* Render pool size                    */
DECL|member|maxBuff
name|PLong
name|maxBuff
decl_stmt|;
comment|/* Profiles buffer size                */
DECL|member|top
name|PLong
name|top
decl_stmt|;
comment|/* Current cursor in buffer            */
DECL|member|error
name|FT_Error
name|error
decl_stmt|;
DECL|member|numTurns
name|Int
name|numTurns
decl_stmt|;
comment|/* number of Y-turns in outline        */
DECL|member|arc
name|TPoint
modifier|*
name|arc
decl_stmt|;
comment|/* current Bezier arc pointer          */
DECL|member|bWidth
name|UShort
name|bWidth
decl_stmt|;
comment|/* target bitmap width                 */
DECL|member|bTarget
name|PByte
name|bTarget
decl_stmt|;
comment|/* target bitmap buffer                */
DECL|member|gTarget
name|PByte
name|gTarget
decl_stmt|;
comment|/* target pixmap buffer                */
DECL|member|lastX
DECL|member|lastY
name|Long
name|lastX
decl_stmt|,
name|lastY
decl_stmt|;
DECL|member|minY
DECL|member|maxY
name|Long
name|minY
decl_stmt|,
name|maxY
decl_stmt|;
DECL|member|num_Profs
name|UShort
name|num_Profs
decl_stmt|;
comment|/* current number of profiles          */
DECL|member|fresh
name|Bool
name|fresh
decl_stmt|;
comment|/* signals a fresh new profile which   */
comment|/* `start' field must be completed     */
DECL|member|joint
name|Bool
name|joint
decl_stmt|;
comment|/* signals that the last arc ended     */
comment|/* exactly on a scanline.  Allows      */
comment|/* removal of doublets                 */
DECL|member|cProfile
name|PProfile
name|cProfile
decl_stmt|;
comment|/* current profile                     */
DECL|member|fProfile
name|PProfile
name|fProfile
decl_stmt|;
comment|/* head of linked list of profiles     */
DECL|member|gProfile
name|PProfile
name|gProfile
decl_stmt|;
comment|/* contour's first profile in case     */
comment|/* of impact                           */
DECL|member|state
name|TStates
name|state
decl_stmt|;
comment|/* rendering state                     */
DECL|member|target
name|FT_Bitmap
name|target
decl_stmt|;
comment|/* description of target bit/pixmap    */
DECL|member|outline
name|FT_Outline
name|outline
decl_stmt|;
DECL|member|traceOfs
name|Long
name|traceOfs
decl_stmt|;
comment|/* current offset in target bitmap     */
DECL|member|traceG
name|Long
name|traceG
decl_stmt|;
comment|/* current offset in target pixmap     */
DECL|member|traceIncr
name|Short
name|traceIncr
decl_stmt|;
comment|/* sweep's increment in target bitmap  */
comment|/* dispatch variables */
DECL|member|Proc_Sweep_Init
name|Function_Sweep_Init
modifier|*
name|Proc_Sweep_Init
decl_stmt|;
DECL|member|Proc_Sweep_Span
name|Function_Sweep_Span
modifier|*
name|Proc_Sweep_Span
decl_stmt|;
DECL|member|Proc_Sweep_Drop
name|Function_Sweep_Span
modifier|*
name|Proc_Sweep_Drop
decl_stmt|;
DECL|member|Proc_Sweep_Step
name|Function_Sweep_Step
modifier|*
name|Proc_Sweep_Step
decl_stmt|;
DECL|member|dropOutControl
name|Byte
name|dropOutControl
decl_stmt|;
comment|/* current drop_out control method     */
DECL|member|second_pass
name|Bool
name|second_pass
decl_stmt|;
comment|/* indicates whether a horizontal pass */
comment|/* should be performed to control      */
comment|/* drop-out accurately when calling    */
comment|/* Render_Glyph.                       */
DECL|member|arcs
name|TPoint
name|arcs
index|[
literal|3
operator|*
name|MaxBezier
operator|+
literal|1
index|]
decl_stmt|;
comment|/* The Bezier stack               */
DECL|member|band_stack
name|black_TBand
name|band_stack
index|[
literal|16
index|]
decl_stmt|;
comment|/* band stack used for sub-banding     */
DECL|member|band_top
name|Int
name|band_top
decl_stmt|;
comment|/* band stack top                      */
block|}
struct|;
end_struct
begin_typedef
DECL|struct|black_TRaster_
typedef|typedef
struct|struct
name|black_TRaster_
block|{
DECL|member|memory
name|void
modifier|*
name|memory
decl_stmt|;
block|}
DECL|typedef|black_TRaster
DECL|typedef|black_PRaster
name|black_TRaster
operator|,
typedef|*
name|black_PRaster
typedef|;
end_typedef
begin_ifdef
ifdef|#
directive|ifdef
name|FT_STATIC_RASTER
end_ifdef
begin_decl_stmt
DECL|variable|cur_ras
specifier|static
name|black_TWorker
name|cur_ras
decl_stmt|;
end_decl_stmt
begin_define
DECL|macro|ras
define|#
directive|define
name|ras
value|cur_ras
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* !FT_STATIC_RASTER */
end_comment
begin_define
DECL|macro|ras
define|#
directive|define
name|ras
value|(*worker)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* !FT_STATIC_RASTER */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/**                                                                     **/
end_comment
begin_comment
comment|/**  PROFILES COMPUTATION                                               **/
end_comment
begin_comment
comment|/**                                                                     **/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    Set_High_Precision                                                 */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Set precision variables according to param flag.                   */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    High :: Set to True for high precision (typically for ppem< 24),  */
end_comment
begin_comment
comment|/*            false otherwise.                                           */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Set_High_Precision
name|Set_High_Precision
parameter_list|(
name|RAS_ARGS
name|Int
name|High
parameter_list|)
block|{
comment|/*      * `precision_step' is used in `Bezier_Up' to decide when to split a      * given y-monotonous Bezier arc that crosses a scanline before      * approximating it as a straight segment.  The default value of 32 (for      * low accuracy) corresponds to      *      *   32 / 64 == 0.5 pixels,      *      * while for the high accuracy case we have      *      *   256 / (1<< 12) = 0.0625 pixels.      *      * `precision_jitter' is an epsilon threshold used in      * `Vertical_Sweep_Span' to deal with small imperfections in the Bezier      * decomposition (after all, we are working with approximations only);      * it avoids switching on additional pixels which would cause artifacts      * otherwise.      *      * The value of `precision_jitter' has been determined heuristically.      *      */
if|if
condition|(
name|High
condition|)
block|{
name|ras
operator|.
name|precision_bits
operator|=
literal|12
expr_stmt|;
name|ras
operator|.
name|precision_step
operator|=
literal|256
expr_stmt|;
name|ras
operator|.
name|precision_jitter
operator|=
literal|30
expr_stmt|;
block|}
else|else
block|{
name|ras
operator|.
name|precision_bits
operator|=
literal|6
expr_stmt|;
name|ras
operator|.
name|precision_step
operator|=
literal|32
expr_stmt|;
name|ras
operator|.
name|precision_jitter
operator|=
literal|2
expr_stmt|;
block|}
name|FT_TRACE6
argument_list|(
operator|(
literal|"Set_High_Precision(%s)\n"
operator|,
name|High
condition|?
literal|"true"
else|:
literal|"false"
operator|)
argument_list|)
expr_stmt|;
name|ras
operator|.
name|precision
operator|=
literal|1
operator|<<
name|ras
operator|.
name|precision_bits
expr_stmt|;
name|ras
operator|.
name|precision_half
operator|=
name|ras
operator|.
name|precision
operator|/
literal|2
expr_stmt|;
name|ras
operator|.
name|precision_shift
operator|=
name|ras
operator|.
name|precision_bits
operator|-
name|Pixel_Bits
expr_stmt|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    New_Profile                                                        */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Create a new profile in the render pool.                           */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    aState    :: The state/orientation of the new profile.             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    overshoot :: Whether the profile's unrounded start position        */
end_comment
begin_comment
comment|/*                 differs by at least a half pixel.                     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*   SUCCESS on success.  FAILURE in case of overflow or of incoherent   */
end_comment
begin_comment
comment|/*   profile.                                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|Bool
DECL|function|New_Profile
name|New_Profile
parameter_list|(
name|RAS_ARGS
name|TStates
name|aState
parameter_list|,
name|Bool
name|overshoot
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ras
operator|.
name|fProfile
condition|)
block|{
name|ras
operator|.
name|cProfile
operator|=
operator|(
name|PProfile
operator|)
name|ras
operator|.
name|top
expr_stmt|;
name|ras
operator|.
name|fProfile
operator|=
name|ras
operator|.
name|cProfile
expr_stmt|;
name|ras
operator|.
name|top
operator|+=
name|AlignProfileSize
expr_stmt|;
block|}
if|if
condition|(
name|ras
operator|.
name|top
operator|>=
name|ras
operator|.
name|maxBuff
condition|)
block|{
name|ras
operator|.
name|error
operator|=
name|FT_THROW
argument_list|(
name|Overflow
argument_list|)
expr_stmt|;
return|return
name|FAILURE
return|;
block|}
name|ras
operator|.
name|cProfile
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|ras
operator|.
name|cProfile
operator|->
name|start
operator|=
literal|0
expr_stmt|;
name|ras
operator|.
name|cProfile
operator|->
name|height
operator|=
literal|0
expr_stmt|;
name|ras
operator|.
name|cProfile
operator|->
name|offset
operator|=
name|ras
operator|.
name|top
expr_stmt|;
name|ras
operator|.
name|cProfile
operator|->
name|link
operator|=
operator|(
name|PProfile
operator|)
literal|0
expr_stmt|;
name|ras
operator|.
name|cProfile
operator|->
name|next
operator|=
operator|(
name|PProfile
operator|)
literal|0
expr_stmt|;
name|ras
operator|.
name|cProfile
operator|->
name|flags
operator|=
name|ras
operator|.
name|dropOutControl
expr_stmt|;
switch|switch
condition|(
name|aState
condition|)
block|{
case|case
name|Ascending_State
case|:
name|ras
operator|.
name|cProfile
operator|->
name|flags
operator||=
name|Flow_Up
expr_stmt|;
if|if
condition|(
name|overshoot
condition|)
name|ras
operator|.
name|cProfile
operator|->
name|flags
operator||=
name|Overshoot_Bottom
expr_stmt|;
name|FT_TRACE6
argument_list|(
operator|(
literal|"  new ascending profile = %p\n"
operator|,
name|ras
operator|.
name|cProfile
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|Descending_State
case|:
if|if
condition|(
name|overshoot
condition|)
name|ras
operator|.
name|cProfile
operator|->
name|flags
operator||=
name|Overshoot_Top
expr_stmt|;
name|FT_TRACE6
argument_list|(
operator|(
literal|"  new descending profile = %p\n"
operator|,
name|ras
operator|.
name|cProfile
operator|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|FT_ERROR
argument_list|(
operator|(
literal|"New_Profile: invalid profile direction\n"
operator|)
argument_list|)
expr_stmt|;
name|ras
operator|.
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid
argument_list|)
expr_stmt|;
return|return
name|FAILURE
return|;
block|}
if|if
condition|(
operator|!
name|ras
operator|.
name|gProfile
condition|)
name|ras
operator|.
name|gProfile
operator|=
name|ras
operator|.
name|cProfile
expr_stmt|;
name|ras
operator|.
name|state
operator|=
name|aState
expr_stmt|;
name|ras
operator|.
name|fresh
operator|=
name|TRUE
expr_stmt|;
name|ras
operator|.
name|joint
operator|=
name|FALSE
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    End_Profile                                                        */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Finalize the current profile.                                      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    overshoot :: Whether the profile's unrounded end position differs  */
end_comment
begin_comment
comment|/*                 by at least a half pixel.                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    SUCCESS on success.  FAILURE in case of overflow or incoherency.   */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|Bool
DECL|function|End_Profile
name|End_Profile
parameter_list|(
name|RAS_ARGS
name|Bool
name|overshoot
parameter_list|)
block|{
name|Long
name|h
decl_stmt|;
name|h
operator|=
call|(
name|Long
call|)
argument_list|(
name|ras
operator|.
name|top
operator|-
name|ras
operator|.
name|cProfile
operator|->
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|<
literal|0
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"End_Profile: negative height encountered\n"
operator|)
argument_list|)
expr_stmt|;
name|ras
operator|.
name|error
operator|=
name|FT_THROW
argument_list|(
name|Neg_Height
argument_list|)
expr_stmt|;
return|return
name|FAILURE
return|;
block|}
if|if
condition|(
name|h
operator|>
literal|0
condition|)
block|{
name|PProfile
name|oldProfile
decl_stmt|;
name|FT_TRACE6
argument_list|(
operator|(
literal|"  ending profile %p, start = %ld, height = %ld\n"
operator|,
name|ras
operator|.
name|cProfile
operator|,
name|ras
operator|.
name|cProfile
operator|->
name|start
operator|,
name|h
operator|)
argument_list|)
expr_stmt|;
name|ras
operator|.
name|cProfile
operator|->
name|height
operator|=
name|h
expr_stmt|;
if|if
condition|(
name|overshoot
condition|)
block|{
if|if
condition|(
name|ras
operator|.
name|cProfile
operator|->
name|flags
operator|&
name|Flow_Up
condition|)
name|ras
operator|.
name|cProfile
operator|->
name|flags
operator||=
name|Overshoot_Top
expr_stmt|;
else|else
name|ras
operator|.
name|cProfile
operator|->
name|flags
operator||=
name|Overshoot_Bottom
expr_stmt|;
block|}
name|oldProfile
operator|=
name|ras
operator|.
name|cProfile
expr_stmt|;
name|ras
operator|.
name|cProfile
operator|=
operator|(
name|PProfile
operator|)
name|ras
operator|.
name|top
expr_stmt|;
name|ras
operator|.
name|top
operator|+=
name|AlignProfileSize
expr_stmt|;
name|ras
operator|.
name|cProfile
operator|->
name|height
operator|=
literal|0
expr_stmt|;
name|ras
operator|.
name|cProfile
operator|->
name|offset
operator|=
name|ras
operator|.
name|top
expr_stmt|;
name|oldProfile
operator|->
name|next
operator|=
name|ras
operator|.
name|cProfile
expr_stmt|;
name|ras
operator|.
name|num_Profs
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|ras
operator|.
name|top
operator|>=
name|ras
operator|.
name|maxBuff
condition|)
block|{
name|FT_TRACE1
argument_list|(
operator|(
literal|"overflow in End_Profile\n"
operator|)
argument_list|)
expr_stmt|;
name|ras
operator|.
name|error
operator|=
name|FT_THROW
argument_list|(
name|Overflow
argument_list|)
expr_stmt|;
return|return
name|FAILURE
return|;
block|}
name|ras
operator|.
name|joint
operator|=
name|FALSE
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    Insert_Y_Turn                                                      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Insert a salient into the sorted list placed on top of the render  */
end_comment
begin_comment
comment|/*    pool.                                                              */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    New y scanline position.                                           */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    SUCCESS on success.  FAILURE in case of overflow.                  */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|Bool
DECL|function|Insert_Y_Turn
name|Insert_Y_Turn
parameter_list|(
name|RAS_ARGS
name|Int
name|y
parameter_list|)
block|{
name|PLong
name|y_turns
decl_stmt|;
name|Int
name|n
decl_stmt|;
name|n
operator|=
name|ras
operator|.
name|numTurns
operator|-
literal|1
expr_stmt|;
name|y_turns
operator|=
name|ras
operator|.
name|sizeBuff
operator|-
name|ras
operator|.
name|numTurns
expr_stmt|;
comment|/* look for first y value that is<= */
while|while
condition|(
name|n
operator|>=
literal|0
operator|&&
name|y
operator|<
name|y_turns
index|[
name|n
index|]
condition|)
name|n
operator|--
expr_stmt|;
comment|/* if it is<, simply insert it, ignore if == */
if|if
condition|(
name|n
operator|>=
literal|0
operator|&&
name|y
operator|>
name|y_turns
index|[
name|n
index|]
condition|)
do|do
block|{
name|Int
name|y2
init|=
operator|(
name|Int
operator|)
name|y_turns
index|[
name|n
index|]
decl_stmt|;
name|y_turns
index|[
name|n
index|]
operator|=
name|y
expr_stmt|;
name|y
operator|=
name|y2
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|n
operator|>=
literal|0
condition|)
do|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|ras
operator|.
name|maxBuff
operator|--
expr_stmt|;
if|if
condition|(
name|ras
operator|.
name|maxBuff
operator|<=
name|ras
operator|.
name|top
condition|)
block|{
name|ras
operator|.
name|error
operator|=
name|FT_THROW
argument_list|(
name|Overflow
argument_list|)
expr_stmt|;
return|return
name|FAILURE
return|;
block|}
name|ras
operator|.
name|numTurns
operator|++
expr_stmt|;
name|ras
operator|.
name|sizeBuff
index|[
operator|-
name|ras
operator|.
name|numTurns
index|]
operator|=
name|y
expr_stmt|;
block|}
return|return
name|SUCCESS
return|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    Finalize_Profile_Table                                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Adjust all links in the profiles list.                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    SUCCESS on success.  FAILURE in case of overflow.                  */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|Bool
DECL|function|Finalize_Profile_Table
name|Finalize_Profile_Table
parameter_list|(
name|RAS_ARG
parameter_list|)
block|{
name|UShort
name|n
decl_stmt|;
name|PProfile
name|p
decl_stmt|;
name|n
operator|=
name|ras
operator|.
name|num_Profs
expr_stmt|;
name|p
operator|=
name|ras
operator|.
name|fProfile
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|1
operator|&&
name|p
condition|)
block|{
do|do
block|{
name|Int
name|bottom
decl_stmt|,
name|top
decl_stmt|;
if|if
condition|(
name|n
operator|>
literal|1
condition|)
name|p
operator|->
name|link
operator|=
call|(
name|PProfile
call|)
argument_list|(
name|p
operator|->
name|offset
operator|+
name|p
operator|->
name|height
argument_list|)
expr_stmt|;
else|else
name|p
operator|->
name|link
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|flags
operator|&
name|Flow_Up
condition|)
block|{
name|bottom
operator|=
operator|(
name|Int
operator|)
name|p
operator|->
name|start
expr_stmt|;
name|top
operator|=
call|(
name|Int
call|)
argument_list|(
name|p
operator|->
name|start
operator|+
name|p
operator|->
name|height
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bottom
operator|=
call|(
name|Int
call|)
argument_list|(
name|p
operator|->
name|start
operator|-
name|p
operator|->
name|height
operator|+
literal|1
argument_list|)
expr_stmt|;
name|top
operator|=
operator|(
name|Int
operator|)
name|p
operator|->
name|start
expr_stmt|;
name|p
operator|->
name|start
operator|=
name|bottom
expr_stmt|;
name|p
operator|->
name|offset
operator|+=
name|p
operator|->
name|height
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|Insert_Y_Turn
argument_list|(
argument|RAS_VARS bottom
argument_list|)
operator|||
name|Insert_Y_Turn
argument_list|(
argument|RAS_VARS top +
literal|1
argument_list|)
condition|)
return|return
name|FAILURE
return|;
name|p
operator|=
name|p
operator|->
name|link
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|n
condition|)
do|;
block|}
else|else
name|ras
operator|.
name|fProfile
operator|=
name|NULL
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    Split_Conic                                                        */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Subdivide one conic Bezier into two joint sub-arcs in the Bezier   */
end_comment
begin_comment
comment|/*    stack.                                                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    None (subdivided Bezier is taken from the top of the stack).       */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Note>                                                                */
end_comment
begin_comment
comment|/*    This routine is the `beef' of this component.  It is  _the_ inner  */
end_comment
begin_comment
comment|/*    loop that should be optimized to hell to get the best performance. */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Split_Conic
name|Split_Conic
parameter_list|(
name|TPoint
modifier|*
name|base
parameter_list|)
block|{
name|Long
name|a
decl_stmt|,
name|b
decl_stmt|;
name|base
index|[
literal|4
index|]
operator|.
name|x
operator|=
name|base
index|[
literal|2
index|]
operator|.
name|x
expr_stmt|;
name|b
operator|=
name|base
index|[
literal|1
index|]
operator|.
name|x
expr_stmt|;
name|a
operator|=
name|base
index|[
literal|3
index|]
operator|.
name|x
operator|=
operator|(
name|base
index|[
literal|2
index|]
operator|.
name|x
operator|+
name|b
operator|)
operator|/
literal|2
expr_stmt|;
name|b
operator|=
name|base
index|[
literal|1
index|]
operator|.
name|x
operator|=
operator|(
name|base
index|[
literal|0
index|]
operator|.
name|x
operator|+
name|b
operator|)
operator|/
literal|2
expr_stmt|;
name|base
index|[
literal|2
index|]
operator|.
name|x
operator|=
operator|(
name|a
operator|+
name|b
operator|)
operator|/
literal|2
expr_stmt|;
name|base
index|[
literal|4
index|]
operator|.
name|y
operator|=
name|base
index|[
literal|2
index|]
operator|.
name|y
expr_stmt|;
name|b
operator|=
name|base
index|[
literal|1
index|]
operator|.
name|y
expr_stmt|;
name|a
operator|=
name|base
index|[
literal|3
index|]
operator|.
name|y
operator|=
operator|(
name|base
index|[
literal|2
index|]
operator|.
name|y
operator|+
name|b
operator|)
operator|/
literal|2
expr_stmt|;
name|b
operator|=
name|base
index|[
literal|1
index|]
operator|.
name|y
operator|=
operator|(
name|base
index|[
literal|0
index|]
operator|.
name|y
operator|+
name|b
operator|)
operator|/
literal|2
expr_stmt|;
name|base
index|[
literal|2
index|]
operator|.
name|y
operator|=
operator|(
name|a
operator|+
name|b
operator|)
operator|/
literal|2
expr_stmt|;
comment|/* hand optimized.  gcc doesn't seem to be too good at common      */
comment|/* expression substitution and instruction scheduling ;-)          */
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    Split_Cubic                                                        */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Subdivide a third-order Bezier arc into two joint sub-arcs in the  */
end_comment
begin_comment
comment|/*    Bezier stack.                                                      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Note>                                                                */
end_comment
begin_comment
comment|/*    This routine is the `beef' of the component.  It is one of _the_   */
end_comment
begin_comment
comment|/*    inner loops that should be optimized like hell to get the best     */
end_comment
begin_comment
comment|/*    performance.                                                       */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Split_Cubic
name|Split_Cubic
parameter_list|(
name|TPoint
modifier|*
name|base
parameter_list|)
block|{
name|Long
name|a
decl_stmt|,
name|b
decl_stmt|,
name|c
decl_stmt|,
name|d
decl_stmt|;
name|base
index|[
literal|6
index|]
operator|.
name|x
operator|=
name|base
index|[
literal|3
index|]
operator|.
name|x
expr_stmt|;
name|c
operator|=
name|base
index|[
literal|1
index|]
operator|.
name|x
expr_stmt|;
name|d
operator|=
name|base
index|[
literal|2
index|]
operator|.
name|x
expr_stmt|;
name|base
index|[
literal|1
index|]
operator|.
name|x
operator|=
name|a
operator|=
operator|(
name|base
index|[
literal|0
index|]
operator|.
name|x
operator|+
name|c
operator|+
literal|1
operator|)
operator|>>
literal|1
expr_stmt|;
name|base
index|[
literal|5
index|]
operator|.
name|x
operator|=
name|b
operator|=
operator|(
name|base
index|[
literal|3
index|]
operator|.
name|x
operator|+
name|d
operator|+
literal|1
operator|)
operator|>>
literal|1
expr_stmt|;
name|c
operator|=
operator|(
name|c
operator|+
name|d
operator|+
literal|1
operator|)
operator|>>
literal|1
expr_stmt|;
name|base
index|[
literal|2
index|]
operator|.
name|x
operator|=
name|a
operator|=
operator|(
name|a
operator|+
name|c
operator|+
literal|1
operator|)
operator|>>
literal|1
expr_stmt|;
name|base
index|[
literal|4
index|]
operator|.
name|x
operator|=
name|b
operator|=
operator|(
name|b
operator|+
name|c
operator|+
literal|1
operator|)
operator|>>
literal|1
expr_stmt|;
name|base
index|[
literal|3
index|]
operator|.
name|x
operator|=
operator|(
name|a
operator|+
name|b
operator|+
literal|1
operator|)
operator|>>
literal|1
expr_stmt|;
name|base
index|[
literal|6
index|]
operator|.
name|y
operator|=
name|base
index|[
literal|3
index|]
operator|.
name|y
expr_stmt|;
name|c
operator|=
name|base
index|[
literal|1
index|]
operator|.
name|y
expr_stmt|;
name|d
operator|=
name|base
index|[
literal|2
index|]
operator|.
name|y
expr_stmt|;
name|base
index|[
literal|1
index|]
operator|.
name|y
operator|=
name|a
operator|=
operator|(
name|base
index|[
literal|0
index|]
operator|.
name|y
operator|+
name|c
operator|+
literal|1
operator|)
operator|>>
literal|1
expr_stmt|;
name|base
index|[
literal|5
index|]
operator|.
name|y
operator|=
name|b
operator|=
operator|(
name|base
index|[
literal|3
index|]
operator|.
name|y
operator|+
name|d
operator|+
literal|1
operator|)
operator|>>
literal|1
expr_stmt|;
name|c
operator|=
operator|(
name|c
operator|+
name|d
operator|+
literal|1
operator|)
operator|>>
literal|1
expr_stmt|;
name|base
index|[
literal|2
index|]
operator|.
name|y
operator|=
name|a
operator|=
operator|(
name|a
operator|+
name|c
operator|+
literal|1
operator|)
operator|>>
literal|1
expr_stmt|;
name|base
index|[
literal|4
index|]
operator|.
name|y
operator|=
name|b
operator|=
operator|(
name|b
operator|+
name|c
operator|+
literal|1
operator|)
operator|>>
literal|1
expr_stmt|;
name|base
index|[
literal|3
index|]
operator|.
name|y
operator|=
operator|(
name|a
operator|+
name|b
operator|+
literal|1
operator|)
operator|>>
literal|1
expr_stmt|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    Line_Up                                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Compute the x-coordinates of an ascending line segment and store   */
end_comment
begin_comment
comment|/*    them in the render pool.                                           */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    x1   :: The x-coordinate of the segment's start point.             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    y1   :: The y-coordinate of the segment's start point.             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    x2   :: The x-coordinate of the segment's end point.               */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    y2   :: The y-coordinate of the segment's end point.               */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    miny :: A lower vertical clipping bound value.                     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    maxy :: An upper vertical clipping bound value.                    */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    SUCCESS on success, FAILURE on render pool overflow.               */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|Bool
DECL|function|Line_Up
name|Line_Up
parameter_list|(
name|RAS_ARGS
name|Long
name|x1
parameter_list|,
name|Long
name|y1
parameter_list|,
name|Long
name|x2
parameter_list|,
name|Long
name|y2
parameter_list|,
name|Long
name|miny
parameter_list|,
name|Long
name|maxy
parameter_list|)
block|{
name|Long
name|Dx
decl_stmt|,
name|Dy
decl_stmt|;
name|Int
name|e1
decl_stmt|,
name|e2
decl_stmt|,
name|f1
decl_stmt|,
name|f2
decl_stmt|,
name|size
decl_stmt|;
comment|/* XXX: is `Short' sufficient? */
name|Long
name|Ix
decl_stmt|,
name|Rx
decl_stmt|,
name|Ax
decl_stmt|;
name|PLong
name|top
decl_stmt|;
name|Dx
operator|=
name|x2
operator|-
name|x1
expr_stmt|;
name|Dy
operator|=
name|y2
operator|-
name|y1
expr_stmt|;
if|if
condition|(
name|Dy
operator|<=
literal|0
operator|||
name|y2
operator|<
name|miny
operator|||
name|y1
operator|>
name|maxy
condition|)
return|return
name|SUCCESS
return|;
if|if
condition|(
name|y1
operator|<
name|miny
condition|)
block|{
comment|/* Take care: miny-y1 can be a very large value; we use     */
comment|/*            a slow MulDiv function to avoid clipping bugs */
name|x1
operator|+=
name|SMulDiv
argument_list|(
name|Dx
argument_list|,
name|miny
operator|-
name|y1
argument_list|,
name|Dy
argument_list|)
expr_stmt|;
name|e1
operator|=
operator|(
name|Int
operator|)
name|TRUNC
argument_list|(
name|miny
argument_list|)
expr_stmt|;
name|f1
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|e1
operator|=
operator|(
name|Int
operator|)
name|TRUNC
argument_list|(
name|y1
argument_list|)
expr_stmt|;
name|f1
operator|=
operator|(
name|Int
operator|)
name|FRAC
argument_list|(
name|y1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|y2
operator|>
name|maxy
condition|)
block|{
comment|/* x2 += FMulDiv( Dx, maxy - y2, Dy );  UNNECESSARY */
name|e2
operator|=
operator|(
name|Int
operator|)
name|TRUNC
argument_list|(
name|maxy
argument_list|)
expr_stmt|;
name|f2
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|e2
operator|=
operator|(
name|Int
operator|)
name|TRUNC
argument_list|(
name|y2
argument_list|)
expr_stmt|;
name|f2
operator|=
operator|(
name|Int
operator|)
name|FRAC
argument_list|(
name|y2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|f1
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|e1
operator|==
name|e2
condition|)
return|return
name|SUCCESS
return|;
else|else
block|{
name|x1
operator|+=
name|SMulDiv
argument_list|(
name|Dx
argument_list|,
name|ras
operator|.
name|precision
operator|-
name|f1
argument_list|,
name|Dy
argument_list|)
expr_stmt|;
name|e1
operator|+=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ras
operator|.
name|joint
condition|)
block|{
name|ras
operator|.
name|top
operator|--
expr_stmt|;
name|ras
operator|.
name|joint
operator|=
name|FALSE
expr_stmt|;
block|}
name|ras
operator|.
name|joint
operator|=
call|(
name|char
call|)
argument_list|(
name|f2
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ras
operator|.
name|fresh
condition|)
block|{
name|ras
operator|.
name|cProfile
operator|->
name|start
operator|=
name|e1
expr_stmt|;
name|ras
operator|.
name|fresh
operator|=
name|FALSE
expr_stmt|;
block|}
name|size
operator|=
name|e2
operator|-
name|e1
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|ras
operator|.
name|top
operator|+
name|size
operator|>=
name|ras
operator|.
name|maxBuff
condition|)
block|{
name|ras
operator|.
name|error
operator|=
name|FT_THROW
argument_list|(
name|Overflow
argument_list|)
expr_stmt|;
return|return
name|FAILURE
return|;
block|}
if|if
condition|(
name|Dx
operator|>
literal|0
condition|)
block|{
name|Ix
operator|=
name|SMulDiv_No_Round
argument_list|(
name|ras
operator|.
name|precision
argument_list|,
name|Dx
argument_list|,
name|Dy
argument_list|)
expr_stmt|;
name|Rx
operator|=
operator|(
name|ras
operator|.
name|precision
operator|*
name|Dx
operator|)
operator|%
name|Dy
expr_stmt|;
name|Dx
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|Ix
operator|=
operator|-
name|SMulDiv_No_Round
argument_list|(
name|ras
operator|.
name|precision
argument_list|,
operator|-
name|Dx
argument_list|,
name|Dy
argument_list|)
expr_stmt|;
name|Rx
operator|=
operator|(
name|ras
operator|.
name|precision
operator|*
operator|-
name|Dx
operator|)
operator|%
name|Dy
expr_stmt|;
name|Dx
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|Ax
operator|=
operator|-
name|Dy
expr_stmt|;
name|top
operator|=
name|ras
operator|.
name|top
expr_stmt|;
while|while
condition|(
name|size
operator|>
literal|0
condition|)
block|{
operator|*
name|top
operator|++
operator|=
name|x1
expr_stmt|;
name|x1
operator|+=
name|Ix
expr_stmt|;
name|Ax
operator|+=
name|Rx
expr_stmt|;
if|if
condition|(
name|Ax
operator|>=
literal|0
condition|)
block|{
name|Ax
operator|-=
name|Dy
expr_stmt|;
name|x1
operator|+=
name|Dx
expr_stmt|;
block|}
name|size
operator|--
expr_stmt|;
block|}
name|ras
operator|.
name|top
operator|=
name|top
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    Line_Down                                                          */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Compute the x-coordinates of an descending line segment and store  */
end_comment
begin_comment
comment|/*    them in the render pool.                                           */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    x1   :: The x-coordinate of the segment's start point.             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    y1   :: The y-coordinate of the segment's start point.             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    x2   :: The x-coordinate of the segment's end point.               */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    y2   :: The y-coordinate of the segment's end point.               */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    miny :: A lower vertical clipping bound value.                     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    maxy :: An upper vertical clipping bound value.                    */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    SUCCESS on success, FAILURE on render pool overflow.               */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|Bool
DECL|function|Line_Down
name|Line_Down
parameter_list|(
name|RAS_ARGS
name|Long
name|x1
parameter_list|,
name|Long
name|y1
parameter_list|,
name|Long
name|x2
parameter_list|,
name|Long
name|y2
parameter_list|,
name|Long
name|miny
parameter_list|,
name|Long
name|maxy
parameter_list|)
block|{
name|Bool
name|result
decl_stmt|,
name|fresh
decl_stmt|;
name|fresh
operator|=
name|ras
operator|.
name|fresh
expr_stmt|;
name|result
operator|=
name|Line_Up
argument_list|(
argument|RAS_VARS x1
argument_list|,
argument|-y1
argument_list|,
argument|x2
argument_list|,
argument|-y2
argument_list|,
argument|-maxy
argument_list|,
argument|-miny
argument_list|)
expr_stmt|;
if|if
condition|(
name|fresh
operator|&&
operator|!
name|ras
operator|.
name|fresh
condition|)
name|ras
operator|.
name|cProfile
operator|->
name|start
operator|=
operator|-
name|ras
operator|.
name|cProfile
operator|->
name|start
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/* A function type describing the functions used to split Bezier arcs */
end_comment
begin_typedef
DECL|typedef|TSplitter
typedef|typedef
name|void
function_decl|(
modifier|*
name|TSplitter
function_decl|)
parameter_list|(
name|TPoint
modifier|*
name|base
parameter_list|)
function_decl|;
end_typedef
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    Bezier_Up                                                          */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Compute the x-coordinates of an ascending Bezier arc and store     */
end_comment
begin_comment
comment|/*    them in the render pool.                                           */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    degree   :: The degree of the Bezier arc (either 2 or 3).          */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    splitter :: The function to split Bezier arcs.                     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    miny     :: A lower vertical clipping bound value.                 */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    maxy     :: An upper vertical clipping bound value.                */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    SUCCESS on success, FAILURE on render pool overflow.               */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|Bool
DECL|function|Bezier_Up
name|Bezier_Up
parameter_list|(
name|RAS_ARGS
name|Int
name|degree
parameter_list|,
name|TSplitter
name|splitter
parameter_list|,
name|Long
name|miny
parameter_list|,
name|Long
name|maxy
parameter_list|)
block|{
name|Long
name|y1
decl_stmt|,
name|y2
decl_stmt|,
name|e
decl_stmt|,
name|e2
decl_stmt|,
name|e0
decl_stmt|;
name|Short
name|f1
decl_stmt|;
name|TPoint
modifier|*
name|arc
decl_stmt|;
name|TPoint
modifier|*
name|start_arc
decl_stmt|;
name|PLong
name|top
decl_stmt|;
name|arc
operator|=
name|ras
operator|.
name|arc
expr_stmt|;
name|y1
operator|=
name|arc
index|[
name|degree
index|]
operator|.
name|y
expr_stmt|;
name|y2
operator|=
name|arc
index|[
literal|0
index|]
operator|.
name|y
expr_stmt|;
name|top
operator|=
name|ras
operator|.
name|top
expr_stmt|;
if|if
condition|(
name|y2
operator|<
name|miny
operator|||
name|y1
operator|>
name|maxy
condition|)
goto|goto
name|Fin
goto|;
name|e2
operator|=
name|FLOOR
argument_list|(
name|y2
argument_list|)
expr_stmt|;
if|if
condition|(
name|e2
operator|>
name|maxy
condition|)
name|e2
operator|=
name|maxy
expr_stmt|;
name|e0
operator|=
name|miny
expr_stmt|;
if|if
condition|(
name|y1
operator|<
name|miny
condition|)
name|e
operator|=
name|miny
expr_stmt|;
else|else
block|{
name|e
operator|=
name|CEILING
argument_list|(
name|y1
argument_list|)
expr_stmt|;
name|f1
operator|=
call|(
name|Short
call|)
argument_list|(
name|FRAC
argument_list|(
name|y1
argument_list|)
argument_list|)
expr_stmt|;
name|e0
operator|=
name|e
expr_stmt|;
if|if
condition|(
name|f1
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ras
operator|.
name|joint
condition|)
block|{
name|top
operator|--
expr_stmt|;
name|ras
operator|.
name|joint
operator|=
name|FALSE
expr_stmt|;
block|}
operator|*
name|top
operator|++
operator|=
name|arc
index|[
name|degree
index|]
operator|.
name|x
expr_stmt|;
name|e
operator|+=
name|ras
operator|.
name|precision
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ras
operator|.
name|fresh
condition|)
block|{
name|ras
operator|.
name|cProfile
operator|->
name|start
operator|=
name|TRUNC
argument_list|(
name|e0
argument_list|)
expr_stmt|;
name|ras
operator|.
name|fresh
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|e2
operator|<
name|e
condition|)
goto|goto
name|Fin
goto|;
if|if
condition|(
operator|(
name|top
operator|+
name|TRUNC
argument_list|(
name|e2
operator|-
name|e
argument_list|)
operator|+
literal|1
operator|)
operator|>=
name|ras
operator|.
name|maxBuff
condition|)
block|{
name|ras
operator|.
name|top
operator|=
name|top
expr_stmt|;
name|ras
operator|.
name|error
operator|=
name|FT_THROW
argument_list|(
name|Overflow
argument_list|)
expr_stmt|;
return|return
name|FAILURE
return|;
block|}
name|start_arc
operator|=
name|arc
expr_stmt|;
do|do
block|{
name|ras
operator|.
name|joint
operator|=
name|FALSE
expr_stmt|;
name|y2
operator|=
name|arc
index|[
literal|0
index|]
operator|.
name|y
expr_stmt|;
if|if
condition|(
name|y2
operator|>
name|e
condition|)
block|{
name|y1
operator|=
name|arc
index|[
name|degree
index|]
operator|.
name|y
expr_stmt|;
if|if
condition|(
name|y2
operator|-
name|y1
operator|>=
name|ras
operator|.
name|precision_step
condition|)
block|{
name|splitter
argument_list|(
name|arc
argument_list|)
expr_stmt|;
name|arc
operator|+=
name|degree
expr_stmt|;
block|}
else|else
block|{
operator|*
name|top
operator|++
operator|=
name|arc
index|[
name|degree
index|]
operator|.
name|x
operator|+
name|FMulDiv
argument_list|(
name|arc
index|[
literal|0
index|]
operator|.
name|x
operator|-
name|arc
index|[
name|degree
index|]
operator|.
name|x
argument_list|,
name|e
operator|-
name|y1
argument_list|,
name|y2
operator|-
name|y1
argument_list|)
expr_stmt|;
name|arc
operator|-=
name|degree
expr_stmt|;
name|e
operator|+=
name|ras
operator|.
name|precision
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|y2
operator|==
name|e
condition|)
block|{
name|ras
operator|.
name|joint
operator|=
name|TRUE
expr_stmt|;
operator|*
name|top
operator|++
operator|=
name|arc
index|[
literal|0
index|]
operator|.
name|x
expr_stmt|;
name|e
operator|+=
name|ras
operator|.
name|precision
expr_stmt|;
block|}
name|arc
operator|-=
name|degree
expr_stmt|;
block|}
block|}
do|while
condition|(
name|arc
operator|>=
name|start_arc
operator|&&
name|e
operator|<=
name|e2
condition|)
do|;
name|Fin
label|:
name|ras
operator|.
name|top
operator|=
name|top
expr_stmt|;
name|ras
operator|.
name|arc
operator|-=
name|degree
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    Bezier_Down                                                        */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Compute the x-coordinates of an descending Bezier arc and store    */
end_comment
begin_comment
comment|/*    them in the render pool.                                           */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    degree   :: The degree of the Bezier arc (either 2 or 3).          */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    splitter :: The function to split Bezier arcs.                     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    miny     :: A lower vertical clipping bound value.                 */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    maxy     :: An upper vertical clipping bound value.                */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    SUCCESS on success, FAILURE on render pool overflow.               */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|Bool
DECL|function|Bezier_Down
name|Bezier_Down
parameter_list|(
name|RAS_ARGS
name|Int
name|degree
parameter_list|,
name|TSplitter
name|splitter
parameter_list|,
name|Long
name|miny
parameter_list|,
name|Long
name|maxy
parameter_list|)
block|{
name|TPoint
modifier|*
name|arc
init|=
name|ras
operator|.
name|arc
decl_stmt|;
name|Bool
name|result
decl_stmt|,
name|fresh
decl_stmt|;
name|arc
index|[
literal|0
index|]
operator|.
name|y
operator|=
operator|-
name|arc
index|[
literal|0
index|]
operator|.
name|y
expr_stmt|;
name|arc
index|[
literal|1
index|]
operator|.
name|y
operator|=
operator|-
name|arc
index|[
literal|1
index|]
operator|.
name|y
expr_stmt|;
name|arc
index|[
literal|2
index|]
operator|.
name|y
operator|=
operator|-
name|arc
index|[
literal|2
index|]
operator|.
name|y
expr_stmt|;
if|if
condition|(
name|degree
operator|>
literal|2
condition|)
name|arc
index|[
literal|3
index|]
operator|.
name|y
operator|=
operator|-
name|arc
index|[
literal|3
index|]
operator|.
name|y
expr_stmt|;
name|fresh
operator|=
name|ras
operator|.
name|fresh
expr_stmt|;
name|result
operator|=
name|Bezier_Up
argument_list|(
argument|RAS_VARS degree
argument_list|,
argument|splitter
argument_list|,
argument|-maxy
argument_list|,
argument|-miny
argument_list|)
expr_stmt|;
if|if
condition|(
name|fresh
operator|&&
operator|!
name|ras
operator|.
name|fresh
condition|)
name|ras
operator|.
name|cProfile
operator|->
name|start
operator|=
operator|-
name|ras
operator|.
name|cProfile
operator|->
name|start
expr_stmt|;
name|arc
index|[
literal|0
index|]
operator|.
name|y
operator|=
operator|-
name|arc
index|[
literal|0
index|]
operator|.
name|y
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    Line_To                                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Inject a new line segment and adjust the Profiles list.            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*   x :: The x-coordinate of the segment's end point (its start point   */
end_comment
begin_comment
comment|/*        is stored in `lastX').                                         */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*   y :: The y-coordinate of the segment's end point (its start point   */
end_comment
begin_comment
comment|/*        is stored in `lastY').                                         */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*   SUCCESS on success, FAILURE on render pool overflow or incorrect    */
end_comment
begin_comment
comment|/*   profile.                                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|Bool
DECL|function|Line_To
name|Line_To
parameter_list|(
name|RAS_ARGS
name|Long
name|x
parameter_list|,
name|Long
name|y
parameter_list|)
block|{
comment|/* First, detect a change of direction */
switch|switch
condition|(
name|ras
operator|.
name|state
condition|)
block|{
case|case
name|Unknown_State
case|:
if|if
condition|(
name|y
operator|>
name|ras
operator|.
name|lastY
condition|)
block|{
if|if
condition|(
name|New_Profile
argument_list|(
argument|RAS_VARS Ascending_State
argument_list|,
argument|IS_BOTTOM_OVERSHOOT( ras.lastY )
argument_list|)
condition|)
return|return
name|FAILURE
return|;
block|}
else|else
block|{
if|if
condition|(
name|y
operator|<
name|ras
operator|.
name|lastY
condition|)
if|if
condition|(
name|New_Profile
argument_list|(
argument|RAS_VARS Descending_State
argument_list|,
argument|IS_TOP_OVERSHOOT( ras.lastY )
argument_list|)
condition|)
return|return
name|FAILURE
return|;
block|}
break|break;
case|case
name|Ascending_State
case|:
if|if
condition|(
name|y
operator|<
name|ras
operator|.
name|lastY
condition|)
block|{
if|if
condition|(
name|End_Profile
argument_list|(
argument|RAS_VARS IS_TOP_OVERSHOOT( ras.lastY )
argument_list|)
operator|||
name|New_Profile
argument_list|(
argument|RAS_VARS Descending_State
argument_list|,
argument|IS_TOP_OVERSHOOT( ras.lastY )
argument_list|)
condition|)
return|return
name|FAILURE
return|;
block|}
break|break;
case|case
name|Descending_State
case|:
if|if
condition|(
name|y
operator|>
name|ras
operator|.
name|lastY
condition|)
block|{
if|if
condition|(
name|End_Profile
argument_list|(
argument|RAS_VARS IS_BOTTOM_OVERSHOOT( ras.lastY )
argument_list|)
operator|||
name|New_Profile
argument_list|(
argument|RAS_VARS Ascending_State
argument_list|,
argument|IS_BOTTOM_OVERSHOOT( ras.lastY )
argument_list|)
condition|)
return|return
name|FAILURE
return|;
block|}
break|break;
default|default:
empty_stmt|;
block|}
comment|/* Then compute the lines */
switch|switch
condition|(
name|ras
operator|.
name|state
condition|)
block|{
case|case
name|Ascending_State
case|:
if|if
condition|(
name|Line_Up
argument_list|(
argument|RAS_VARS ras.lastX
argument_list|,
argument|ras.lastY
argument_list|,
argument|x
argument_list|,
argument|y
argument_list|,
argument|ras.minY
argument_list|,
argument|ras.maxY
argument_list|)
condition|)
return|return
name|FAILURE
return|;
break|break;
case|case
name|Descending_State
case|:
if|if
condition|(
name|Line_Down
argument_list|(
argument|RAS_VARS ras.lastX
argument_list|,
argument|ras.lastY
argument_list|,
argument|x
argument_list|,
argument|y
argument_list|,
argument|ras.minY
argument_list|,
argument|ras.maxY
argument_list|)
condition|)
return|return
name|FAILURE
return|;
break|break;
default|default:
empty_stmt|;
block|}
name|ras
operator|.
name|lastX
operator|=
name|x
expr_stmt|;
name|ras
operator|.
name|lastY
operator|=
name|y
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    Conic_To                                                           */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Inject a new conic arc and adjust the profile list.                */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*   cx :: The x-coordinate of the arc's new control point.              */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*   cy :: The y-coordinate of the arc's new control point.              */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*   x  :: The x-coordinate of the arc's end point (its start point is   */
end_comment
begin_comment
comment|/*         stored in `lastX').                                           */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*   y  :: The y-coordinate of the arc's end point (its start point is   */
end_comment
begin_comment
comment|/*         stored in `lastY').                                           */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*   SUCCESS on success, FAILURE on render pool overflow or incorrect    */
end_comment
begin_comment
comment|/*   profile.                                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|Bool
DECL|function|Conic_To
name|Conic_To
parameter_list|(
name|RAS_ARGS
name|Long
name|cx
parameter_list|,
name|Long
name|cy
parameter_list|,
name|Long
name|x
parameter_list|,
name|Long
name|y
parameter_list|)
block|{
name|Long
name|y1
decl_stmt|,
name|y2
decl_stmt|,
name|y3
decl_stmt|,
name|x3
decl_stmt|,
name|ymin
decl_stmt|,
name|ymax
decl_stmt|;
name|TStates
name|state_bez
decl_stmt|;
name|ras
operator|.
name|arc
operator|=
name|ras
operator|.
name|arcs
expr_stmt|;
name|ras
operator|.
name|arc
index|[
literal|2
index|]
operator|.
name|x
operator|=
name|ras
operator|.
name|lastX
expr_stmt|;
name|ras
operator|.
name|arc
index|[
literal|2
index|]
operator|.
name|y
operator|=
name|ras
operator|.
name|lastY
expr_stmt|;
name|ras
operator|.
name|arc
index|[
literal|1
index|]
operator|.
name|x
operator|=
name|cx
expr_stmt|;
name|ras
operator|.
name|arc
index|[
literal|1
index|]
operator|.
name|y
operator|=
name|cy
expr_stmt|;
name|ras
operator|.
name|arc
index|[
literal|0
index|]
operator|.
name|x
operator|=
name|x
expr_stmt|;
name|ras
operator|.
name|arc
index|[
literal|0
index|]
operator|.
name|y
operator|=
name|y
expr_stmt|;
do|do
block|{
name|y1
operator|=
name|ras
operator|.
name|arc
index|[
literal|2
index|]
operator|.
name|y
expr_stmt|;
name|y2
operator|=
name|ras
operator|.
name|arc
index|[
literal|1
index|]
operator|.
name|y
expr_stmt|;
name|y3
operator|=
name|ras
operator|.
name|arc
index|[
literal|0
index|]
operator|.
name|y
expr_stmt|;
name|x3
operator|=
name|ras
operator|.
name|arc
index|[
literal|0
index|]
operator|.
name|x
expr_stmt|;
comment|/* first, categorize the Bezier arc */
if|if
condition|(
name|y1
operator|<=
name|y3
condition|)
block|{
name|ymin
operator|=
name|y1
expr_stmt|;
name|ymax
operator|=
name|y3
expr_stmt|;
block|}
else|else
block|{
name|ymin
operator|=
name|y3
expr_stmt|;
name|ymax
operator|=
name|y1
expr_stmt|;
block|}
if|if
condition|(
name|y2
operator|<
name|ymin
operator|||
name|y2
operator|>
name|ymax
condition|)
block|{
comment|/* this arc has no given direction, split it! */
name|Split_Conic
argument_list|(
name|ras
operator|.
name|arc
argument_list|)
expr_stmt|;
name|ras
operator|.
name|arc
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|y1
operator|==
name|y3
condition|)
block|{
comment|/* this arc is flat, ignore it and pop it from the Bezier stack */
name|ras
operator|.
name|arc
operator|-=
literal|2
expr_stmt|;
block|}
else|else
block|{
comment|/* the arc is y-monotonous, either ascending or descending */
comment|/* detect a change of direction                            */
name|state_bez
operator|=
name|y1
operator|<
name|y3
condition|?
name|Ascending_State
else|:
name|Descending_State
expr_stmt|;
if|if
condition|(
name|ras
operator|.
name|state
operator|!=
name|state_bez
condition|)
block|{
name|Bool
name|o
init|=
name|state_bez
operator|==
name|Ascending_State
condition|?
name|IS_BOTTOM_OVERSHOOT
argument_list|(
name|y1
argument_list|)
else|:
name|IS_TOP_OVERSHOOT
argument_list|(
name|y1
argument_list|)
decl_stmt|;
comment|/* finalize current profile if any */
if|if
condition|(
name|ras
operator|.
name|state
operator|!=
name|Unknown_State
operator|&&
name|End_Profile
argument_list|(
argument|RAS_VARS o
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
comment|/* create a new profile */
if|if
condition|(
name|New_Profile
argument_list|(
argument|RAS_VARS state_bez
argument_list|,
argument|o
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
block|}
comment|/* now call the appropriate routine */
if|if
condition|(
name|state_bez
operator|==
name|Ascending_State
condition|)
block|{
if|if
condition|(
name|Bezier_Up
argument_list|(
name|RAS_VARS
literal|2
argument_list|,
name|Split_Conic
argument_list|,
name|ras
operator|.
name|minY
argument_list|,
name|ras
operator|.
name|maxY
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
block|}
elseif|else
if|if
condition|(
name|Bezier_Down
argument_list|(
name|RAS_VARS
literal|2
argument_list|,
name|Split_Conic
argument_list|,
name|ras
operator|.
name|minY
argument_list|,
name|ras
operator|.
name|maxY
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
block|}
block|}
do|while
condition|(
name|ras
operator|.
name|arc
operator|>=
name|ras
operator|.
name|arcs
condition|)
do|;
name|ras
operator|.
name|lastX
operator|=
name|x3
expr_stmt|;
name|ras
operator|.
name|lastY
operator|=
name|y3
expr_stmt|;
return|return
name|SUCCESS
return|;
name|Fail
label|:
return|return
name|FAILURE
return|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    Cubic_To                                                           */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Inject a new cubic arc and adjust the profile list.                */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*   cx1 :: The x-coordinate of the arc's first new control point.       */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*   cy1 :: The y-coordinate of the arc's first new control point.       */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*   cx2 :: The x-coordinate of the arc's second new control point.      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*   cy2 :: The y-coordinate of the arc's second new control point.      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*   x   :: The x-coordinate of the arc's end point (its start point is  */
end_comment
begin_comment
comment|/*          stored in `lastX').                                          */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*   y   :: The y-coordinate of the arc's end point (its start point is  */
end_comment
begin_comment
comment|/*          stored in `lastY').                                          */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*   SUCCESS on success, FAILURE on render pool overflow or incorrect    */
end_comment
begin_comment
comment|/*   profile.                                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|Bool
DECL|function|Cubic_To
name|Cubic_To
parameter_list|(
name|RAS_ARGS
name|Long
name|cx1
parameter_list|,
name|Long
name|cy1
parameter_list|,
name|Long
name|cx2
parameter_list|,
name|Long
name|cy2
parameter_list|,
name|Long
name|x
parameter_list|,
name|Long
name|y
parameter_list|)
block|{
name|Long
name|y1
decl_stmt|,
name|y2
decl_stmt|,
name|y3
decl_stmt|,
name|y4
decl_stmt|,
name|x4
decl_stmt|,
name|ymin1
decl_stmt|,
name|ymax1
decl_stmt|,
name|ymin2
decl_stmt|,
name|ymax2
decl_stmt|;
name|TStates
name|state_bez
decl_stmt|;
name|ras
operator|.
name|arc
operator|=
name|ras
operator|.
name|arcs
expr_stmt|;
name|ras
operator|.
name|arc
index|[
literal|3
index|]
operator|.
name|x
operator|=
name|ras
operator|.
name|lastX
expr_stmt|;
name|ras
operator|.
name|arc
index|[
literal|3
index|]
operator|.
name|y
operator|=
name|ras
operator|.
name|lastY
expr_stmt|;
name|ras
operator|.
name|arc
index|[
literal|2
index|]
operator|.
name|x
operator|=
name|cx1
expr_stmt|;
name|ras
operator|.
name|arc
index|[
literal|2
index|]
operator|.
name|y
operator|=
name|cy1
expr_stmt|;
name|ras
operator|.
name|arc
index|[
literal|1
index|]
operator|.
name|x
operator|=
name|cx2
expr_stmt|;
name|ras
operator|.
name|arc
index|[
literal|1
index|]
operator|.
name|y
operator|=
name|cy2
expr_stmt|;
name|ras
operator|.
name|arc
index|[
literal|0
index|]
operator|.
name|x
operator|=
name|x
expr_stmt|;
name|ras
operator|.
name|arc
index|[
literal|0
index|]
operator|.
name|y
operator|=
name|y
expr_stmt|;
do|do
block|{
name|y1
operator|=
name|ras
operator|.
name|arc
index|[
literal|3
index|]
operator|.
name|y
expr_stmt|;
name|y2
operator|=
name|ras
operator|.
name|arc
index|[
literal|2
index|]
operator|.
name|y
expr_stmt|;
name|y3
operator|=
name|ras
operator|.
name|arc
index|[
literal|1
index|]
operator|.
name|y
expr_stmt|;
name|y4
operator|=
name|ras
operator|.
name|arc
index|[
literal|0
index|]
operator|.
name|y
expr_stmt|;
name|x4
operator|=
name|ras
operator|.
name|arc
index|[
literal|0
index|]
operator|.
name|x
expr_stmt|;
comment|/* first, categorize the Bezier arc */
if|if
condition|(
name|y1
operator|<=
name|y4
condition|)
block|{
name|ymin1
operator|=
name|y1
expr_stmt|;
name|ymax1
operator|=
name|y4
expr_stmt|;
block|}
else|else
block|{
name|ymin1
operator|=
name|y4
expr_stmt|;
name|ymax1
operator|=
name|y1
expr_stmt|;
block|}
if|if
condition|(
name|y2
operator|<=
name|y3
condition|)
block|{
name|ymin2
operator|=
name|y2
expr_stmt|;
name|ymax2
operator|=
name|y3
expr_stmt|;
block|}
else|else
block|{
name|ymin2
operator|=
name|y3
expr_stmt|;
name|ymax2
operator|=
name|y2
expr_stmt|;
block|}
if|if
condition|(
name|ymin2
operator|<
name|ymin1
operator|||
name|ymax2
operator|>
name|ymax1
condition|)
block|{
comment|/* this arc has no given direction, split it! */
name|Split_Cubic
argument_list|(
name|ras
operator|.
name|arc
argument_list|)
expr_stmt|;
name|ras
operator|.
name|arc
operator|+=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|y1
operator|==
name|y4
condition|)
block|{
comment|/* this arc is flat, ignore it and pop it from the Bezier stack */
name|ras
operator|.
name|arc
operator|-=
literal|3
expr_stmt|;
block|}
else|else
block|{
name|state_bez
operator|=
operator|(
name|y1
operator|<=
name|y4
operator|)
condition|?
name|Ascending_State
else|:
name|Descending_State
expr_stmt|;
comment|/* detect a change of direction */
if|if
condition|(
name|ras
operator|.
name|state
operator|!=
name|state_bez
condition|)
block|{
name|Bool
name|o
init|=
name|state_bez
operator|==
name|Ascending_State
condition|?
name|IS_BOTTOM_OVERSHOOT
argument_list|(
name|y1
argument_list|)
else|:
name|IS_TOP_OVERSHOOT
argument_list|(
name|y1
argument_list|)
decl_stmt|;
comment|/* finalize current profile if any */
if|if
condition|(
name|ras
operator|.
name|state
operator|!=
name|Unknown_State
operator|&&
name|End_Profile
argument_list|(
argument|RAS_VARS o
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
if|if
condition|(
name|New_Profile
argument_list|(
argument|RAS_VARS state_bez
argument_list|,
argument|o
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
block|}
comment|/* compute intersections */
if|if
condition|(
name|state_bez
operator|==
name|Ascending_State
condition|)
block|{
if|if
condition|(
name|Bezier_Up
argument_list|(
name|RAS_VARS
literal|3
argument_list|,
name|Split_Cubic
argument_list|,
name|ras
operator|.
name|minY
argument_list|,
name|ras
operator|.
name|maxY
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
block|}
elseif|else
if|if
condition|(
name|Bezier_Down
argument_list|(
name|RAS_VARS
literal|3
argument_list|,
name|Split_Cubic
argument_list|,
name|ras
operator|.
name|minY
argument_list|,
name|ras
operator|.
name|maxY
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
block|}
block|}
do|while
condition|(
name|ras
operator|.
name|arc
operator|>=
name|ras
operator|.
name|arcs
condition|)
do|;
name|ras
operator|.
name|lastX
operator|=
name|x4
expr_stmt|;
name|ras
operator|.
name|lastY
operator|=
name|y4
expr_stmt|;
return|return
name|SUCCESS
return|;
name|Fail
label|:
return|return
name|FAILURE
return|;
block|}
end_function
begin_undef
DECL|macro|SWAP_
undef|#
directive|undef
name|SWAP_
end_undef
begin_define
DECL|macro|SWAP_
define|#
directive|define
name|SWAP_
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|do                \                        {                 \                          Long  swap = x; \                                          \                                          \                          x = y;          \                          y = swap;       \                        } while ( 0 )
end_define
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    Decompose_Curve                                                    */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Scan the outline arrays in order to emit individual segments and   */
end_comment
begin_comment
comment|/*    Beziers by calling Line_To() and Bezier_To().  It handles all      */
end_comment
begin_comment
comment|/*    weird cases, like when the first point is off the curve, or when   */
end_comment
begin_comment
comment|/*    there are simply no `on' points in the contour!                    */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    first   :: The index of the first point in the contour.            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    last    :: The index of the last point in the contour.             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    flipped :: If set, flip the direction of the curve.                */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    SUCCESS on success, FAILURE on error.                              */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|Bool
DECL|function|Decompose_Curve
name|Decompose_Curve
parameter_list|(
name|RAS_ARGS
name|UShort
name|first
parameter_list|,
name|UShort
name|last
parameter_list|,
name|Int
name|flipped
parameter_list|)
block|{
name|FT_Vector
name|v_last
decl_stmt|;
name|FT_Vector
name|v_control
decl_stmt|;
name|FT_Vector
name|v_start
decl_stmt|;
name|FT_Vector
modifier|*
name|points
decl_stmt|;
name|FT_Vector
modifier|*
name|point
decl_stmt|;
name|FT_Vector
modifier|*
name|limit
decl_stmt|;
name|char
modifier|*
name|tags
decl_stmt|;
name|UInt
name|tag
decl_stmt|;
comment|/* current point's state           */
name|points
operator|=
name|ras
operator|.
name|outline
operator|.
name|points
expr_stmt|;
name|limit
operator|=
name|points
operator|+
name|last
expr_stmt|;
name|v_start
operator|.
name|x
operator|=
name|SCALED
argument_list|(
name|points
index|[
name|first
index|]
operator|.
name|x
argument_list|)
expr_stmt|;
name|v_start
operator|.
name|y
operator|=
name|SCALED
argument_list|(
name|points
index|[
name|first
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
name|v_last
operator|.
name|x
operator|=
name|SCALED
argument_list|(
name|points
index|[
name|last
index|]
operator|.
name|x
argument_list|)
expr_stmt|;
name|v_last
operator|.
name|y
operator|=
name|SCALED
argument_list|(
name|points
index|[
name|last
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|flipped
condition|)
block|{
name|SWAP_
argument_list|(
name|v_start
operator|.
name|x
argument_list|,
name|v_start
operator|.
name|y
argument_list|)
expr_stmt|;
name|SWAP_
argument_list|(
name|v_last
operator|.
name|x
argument_list|,
name|v_last
operator|.
name|y
argument_list|)
expr_stmt|;
block|}
name|v_control
operator|=
name|v_start
expr_stmt|;
name|point
operator|=
name|points
operator|+
name|first
expr_stmt|;
name|tags
operator|=
name|ras
operator|.
name|outline
operator|.
name|tags
operator|+
name|first
expr_stmt|;
comment|/* set scan mode if necessary */
if|if
condition|(
name|tags
index|[
literal|0
index|]
operator|&
name|FT_CURVE_TAG_HAS_SCANMODE
condition|)
name|ras
operator|.
name|dropOutControl
operator|=
operator|(
name|Byte
operator|)
name|tags
index|[
literal|0
index|]
operator|>>
literal|5
expr_stmt|;
name|tag
operator|=
name|FT_CURVE_TAG
argument_list|(
name|tags
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* A contour cannot start with a cubic control point! */
if|if
condition|(
name|tag
operator|==
name|FT_CURVE_TAG_CUBIC
condition|)
goto|goto
name|Invalid_Outline
goto|;
comment|/* check first point to determine origin */
if|if
condition|(
name|tag
operator|==
name|FT_CURVE_TAG_CONIC
condition|)
block|{
comment|/* first point is conic control.  Yes, this happens. */
if|if
condition|(
name|FT_CURVE_TAG
argument_list|(
name|ras
operator|.
name|outline
operator|.
name|tags
index|[
name|last
index|]
argument_list|)
operator|==
name|FT_CURVE_TAG_ON
condition|)
block|{
comment|/* start at last point if it is on the curve */
name|v_start
operator|=
name|v_last
expr_stmt|;
name|limit
operator|--
expr_stmt|;
block|}
else|else
block|{
comment|/* if both first and last points are conic,         */
comment|/* start at their middle and record its position    */
comment|/* for closure                                      */
name|v_start
operator|.
name|x
operator|=
operator|(
name|v_start
operator|.
name|x
operator|+
name|v_last
operator|.
name|x
operator|)
operator|/
literal|2
expr_stmt|;
name|v_start
operator|.
name|y
operator|=
operator|(
name|v_start
operator|.
name|y
operator|+
name|v_last
operator|.
name|y
operator|)
operator|/
literal|2
expr_stmt|;
comment|/* v_last = v_start; */
block|}
name|point
operator|--
expr_stmt|;
name|tags
operator|--
expr_stmt|;
block|}
name|ras
operator|.
name|lastX
operator|=
name|v_start
operator|.
name|x
expr_stmt|;
name|ras
operator|.
name|lastY
operator|=
name|v_start
operator|.
name|y
expr_stmt|;
while|while
condition|(
name|point
operator|<
name|limit
condition|)
block|{
name|point
operator|++
expr_stmt|;
name|tags
operator|++
expr_stmt|;
name|tag
operator|=
name|FT_CURVE_TAG
argument_list|(
name|tags
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tag
condition|)
block|{
case|case
name|FT_CURVE_TAG_ON
case|:
comment|/* emit a single line_to */
block|{
name|Long
name|x
decl_stmt|,
name|y
decl_stmt|;
name|x
operator|=
name|SCALED
argument_list|(
name|point
operator|->
name|x
argument_list|)
expr_stmt|;
name|y
operator|=
name|SCALED
argument_list|(
name|point
operator|->
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|flipped
condition|)
name|SWAP_
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|Line_To
argument_list|(
argument|RAS_VARS x
argument_list|,
argument|y
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
continue|continue;
block|}
case|case
name|FT_CURVE_TAG_CONIC
case|:
comment|/* consume conic arcs */
name|v_control
operator|.
name|x
operator|=
name|SCALED
argument_list|(
name|point
index|[
literal|0
index|]
operator|.
name|x
argument_list|)
expr_stmt|;
name|v_control
operator|.
name|y
operator|=
name|SCALED
argument_list|(
name|point
index|[
literal|0
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|flipped
condition|)
name|SWAP_
argument_list|(
name|v_control
operator|.
name|x
argument_list|,
name|v_control
operator|.
name|y
argument_list|)
expr_stmt|;
name|Do_Conic
label|:
if|if
condition|(
name|point
operator|<
name|limit
condition|)
block|{
name|FT_Vector
name|v_middle
decl_stmt|;
name|Long
name|x
decl_stmt|,
name|y
decl_stmt|;
name|point
operator|++
expr_stmt|;
name|tags
operator|++
expr_stmt|;
name|tag
operator|=
name|FT_CURVE_TAG
argument_list|(
name|tags
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|x
operator|=
name|SCALED
argument_list|(
name|point
index|[
literal|0
index|]
operator|.
name|x
argument_list|)
expr_stmt|;
name|y
operator|=
name|SCALED
argument_list|(
name|point
index|[
literal|0
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|flipped
condition|)
name|SWAP_
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag
operator|==
name|FT_CURVE_TAG_ON
condition|)
block|{
if|if
condition|(
name|Conic_To
argument_list|(
argument|RAS_VARS v_control.x
argument_list|,
argument|v_control.y
argument_list|,
argument|x
argument_list|,
argument|y
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
continue|continue;
block|}
if|if
condition|(
name|tag
operator|!=
name|FT_CURVE_TAG_CONIC
condition|)
goto|goto
name|Invalid_Outline
goto|;
name|v_middle
operator|.
name|x
operator|=
operator|(
name|v_control
operator|.
name|x
operator|+
name|x
operator|)
operator|/
literal|2
expr_stmt|;
name|v_middle
operator|.
name|y
operator|=
operator|(
name|v_control
operator|.
name|y
operator|+
name|y
operator|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|Conic_To
argument_list|(
argument|RAS_VARS v_control.x
argument_list|,
argument|v_control.y
argument_list|,
argument|v_middle.x
argument_list|,
argument|v_middle.y
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
name|v_control
operator|.
name|x
operator|=
name|x
expr_stmt|;
name|v_control
operator|.
name|y
operator|=
name|y
expr_stmt|;
goto|goto
name|Do_Conic
goto|;
block|}
if|if
condition|(
name|Conic_To
argument_list|(
argument|RAS_VARS v_control.x
argument_list|,
argument|v_control.y
argument_list|,
argument|v_start.x
argument_list|,
argument|v_start.y
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
goto|goto
name|Close
goto|;
default|default:
comment|/* FT_CURVE_TAG_CUBIC */
block|{
name|Long
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|,
name|x3
decl_stmt|,
name|y3
decl_stmt|;
if|if
condition|(
name|point
operator|+
literal|1
operator|>
name|limit
operator|||
name|FT_CURVE_TAG
argument_list|(
name|tags
index|[
literal|1
index|]
argument_list|)
operator|!=
name|FT_CURVE_TAG_CUBIC
condition|)
goto|goto
name|Invalid_Outline
goto|;
name|point
operator|+=
literal|2
expr_stmt|;
name|tags
operator|+=
literal|2
expr_stmt|;
name|x1
operator|=
name|SCALED
argument_list|(
name|point
index|[
operator|-
literal|2
index|]
operator|.
name|x
argument_list|)
expr_stmt|;
name|y1
operator|=
name|SCALED
argument_list|(
name|point
index|[
operator|-
literal|2
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
name|x2
operator|=
name|SCALED
argument_list|(
name|point
index|[
operator|-
literal|1
index|]
operator|.
name|x
argument_list|)
expr_stmt|;
name|y2
operator|=
name|SCALED
argument_list|(
name|point
index|[
operator|-
literal|1
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|flipped
condition|)
block|{
name|SWAP_
argument_list|(
name|x1
argument_list|,
name|y1
argument_list|)
expr_stmt|;
name|SWAP_
argument_list|(
name|x2
argument_list|,
name|y2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|point
operator|<=
name|limit
condition|)
block|{
name|x3
operator|=
name|SCALED
argument_list|(
name|point
index|[
literal|0
index|]
operator|.
name|x
argument_list|)
expr_stmt|;
name|y3
operator|=
name|SCALED
argument_list|(
name|point
index|[
literal|0
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|flipped
condition|)
name|SWAP_
argument_list|(
name|x3
argument_list|,
name|y3
argument_list|)
expr_stmt|;
if|if
condition|(
name|Cubic_To
argument_list|(
argument|RAS_VARS x1
argument_list|,
argument|y1
argument_list|,
argument|x2
argument_list|,
argument|y2
argument_list|,
argument|x3
argument_list|,
argument|y3
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
continue|continue;
block|}
if|if
condition|(
name|Cubic_To
argument_list|(
argument|RAS_VARS x1
argument_list|,
argument|y1
argument_list|,
argument|x2
argument_list|,
argument|y2
argument_list|,
argument|v_start.x
argument_list|,
argument|v_start.y
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
goto|goto
name|Close
goto|;
block|}
block|}
block|}
comment|/* close the contour with a line segment */
if|if
condition|(
name|Line_To
argument_list|(
argument|RAS_VARS v_start.x
argument_list|,
argument|v_start.y
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
name|Close
label|:
return|return
name|SUCCESS
return|;
name|Invalid_Outline
label|:
name|ras
operator|.
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid
argument_list|)
expr_stmt|;
name|Fail
label|:
return|return
name|FAILURE
return|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    Convert_Glyph                                                      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Convert a glyph into a series of segments and arcs and make a      */
end_comment
begin_comment
comment|/*    profiles list with them.                                           */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    flipped :: If set, flip the direction of curve.                    */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    SUCCESS on success, FAILURE if any error was encountered during    */
end_comment
begin_comment
comment|/*    rendering.                                                         */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|Bool
DECL|function|Convert_Glyph
name|Convert_Glyph
parameter_list|(
name|RAS_ARGS
name|Int
name|flipped
parameter_list|)
block|{
name|Int
name|i
decl_stmt|;
name|UInt
name|start
decl_stmt|;
name|ras
operator|.
name|fProfile
operator|=
name|NULL
expr_stmt|;
name|ras
operator|.
name|joint
operator|=
name|FALSE
expr_stmt|;
name|ras
operator|.
name|fresh
operator|=
name|FALSE
expr_stmt|;
name|ras
operator|.
name|maxBuff
operator|=
name|ras
operator|.
name|sizeBuff
operator|-
name|AlignProfileSize
expr_stmt|;
name|ras
operator|.
name|numTurns
operator|=
literal|0
expr_stmt|;
name|ras
operator|.
name|cProfile
operator|=
operator|(
name|PProfile
operator|)
name|ras
operator|.
name|top
expr_stmt|;
name|ras
operator|.
name|cProfile
operator|->
name|offset
operator|=
name|ras
operator|.
name|top
expr_stmt|;
name|ras
operator|.
name|num_Profs
operator|=
literal|0
expr_stmt|;
name|start
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ras
operator|.
name|outline
operator|.
name|n_contours
condition|;
name|i
operator|++
control|)
block|{
name|PProfile
name|lastProfile
decl_stmt|;
name|Bool
name|o
decl_stmt|;
name|ras
operator|.
name|state
operator|=
name|Unknown_State
expr_stmt|;
name|ras
operator|.
name|gProfile
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|Decompose_Curve
argument_list|(
name|RAS_VARS
argument_list|(
argument|UShort
argument_list|)
name|start
argument_list|,
operator|(
name|UShort
operator|)
name|ras
operator|.
name|outline
operator|.
name|contours
index|[
name|i
index|]
argument_list|,
name|flipped
argument_list|)
condition|)
return|return
name|FAILURE
return|;
name|start
operator|=
operator|(
name|UShort
operator|)
name|ras
operator|.
name|outline
operator|.
name|contours
index|[
name|i
index|]
operator|+
literal|1
expr_stmt|;
comment|/* we must now check whether the extreme arcs join or not */
if|if
condition|(
name|FRAC
argument_list|(
name|ras
operator|.
name|lastY
argument_list|)
operator|==
literal|0
operator|&&
name|ras
operator|.
name|lastY
operator|>=
name|ras
operator|.
name|minY
operator|&&
name|ras
operator|.
name|lastY
operator|<=
name|ras
operator|.
name|maxY
condition|)
if|if
condition|(
name|ras
operator|.
name|gProfile
operator|&&
operator|(
name|ras
operator|.
name|gProfile
operator|->
name|flags
operator|&
name|Flow_Up
operator|)
operator|==
operator|(
name|ras
operator|.
name|cProfile
operator|->
name|flags
operator|&
name|Flow_Up
operator|)
condition|)
name|ras
operator|.
name|top
operator|--
expr_stmt|;
comment|/* Note that ras.gProfile can be nil if the contour was too small */
comment|/* to be drawn.                                                   */
name|lastProfile
operator|=
name|ras
operator|.
name|cProfile
expr_stmt|;
if|if
condition|(
name|ras
operator|.
name|top
operator|!=
name|ras
operator|.
name|cProfile
operator|->
name|offset
operator|&&
operator|(
name|ras
operator|.
name|cProfile
operator|->
name|flags
operator|&
name|Flow_Up
operator|)
condition|)
name|o
operator|=
name|IS_TOP_OVERSHOOT
argument_list|(
name|ras
operator|.
name|lastY
argument_list|)
expr_stmt|;
else|else
name|o
operator|=
name|IS_BOTTOM_OVERSHOOT
argument_list|(
name|ras
operator|.
name|lastY
argument_list|)
expr_stmt|;
if|if
condition|(
name|End_Profile
argument_list|(
argument|RAS_VARS o
argument_list|)
condition|)
return|return
name|FAILURE
return|;
comment|/* close the `next profile in contour' linked list */
if|if
condition|(
name|ras
operator|.
name|gProfile
condition|)
name|lastProfile
operator|->
name|next
operator|=
name|ras
operator|.
name|gProfile
expr_stmt|;
block|}
if|if
condition|(
name|Finalize_Profile_Table
argument_list|(
name|RAS_VAR
argument_list|)
condition|)
return|return
name|FAILURE
return|;
return|return
call|(
name|Bool
call|)
argument_list|(
name|ras
operator|.
name|top
operator|<
name|ras
operator|.
name|maxBuff
condition|?
name|SUCCESS
else|:
name|FAILURE
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/**                                                                     **/
end_comment
begin_comment
comment|/**  SCAN-LINE SWEEPS AND DRAWING                                       **/
end_comment
begin_comment
comment|/**                                                                     **/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*  Init_Linked                                                          */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    Initializes an empty linked list.                                  */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Init_Linked
name|Init_Linked
parameter_list|(
name|TProfileList
modifier|*
name|l
parameter_list|)
block|{
operator|*
name|l
operator|=
name|NULL
expr_stmt|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*  InsNew                                                               */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    Inserts a new profile in a linked list.                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|InsNew
name|InsNew
parameter_list|(
name|PProfileList
name|list
parameter_list|,
name|PProfile
name|profile
parameter_list|)
block|{
name|PProfile
modifier|*
name|old
decl_stmt|,
name|current
decl_stmt|;
name|Long
name|x
decl_stmt|;
name|old
operator|=
name|list
expr_stmt|;
name|current
operator|=
operator|*
name|old
expr_stmt|;
name|x
operator|=
name|profile
operator|->
name|X
expr_stmt|;
while|while
condition|(
name|current
condition|)
block|{
if|if
condition|(
name|x
operator|<
name|current
operator|->
name|X
condition|)
break|break;
name|old
operator|=
operator|&
name|current
operator|->
name|link
expr_stmt|;
name|current
operator|=
operator|*
name|old
expr_stmt|;
block|}
name|profile
operator|->
name|link
operator|=
name|current
expr_stmt|;
operator|*
name|old
operator|=
name|profile
expr_stmt|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*  DelOld                                                               */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    Removes an old profile from a linked list.                         */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|DelOld
name|DelOld
parameter_list|(
name|PProfileList
name|list
parameter_list|,
name|PProfile
name|profile
parameter_list|)
block|{
name|PProfile
modifier|*
name|old
decl_stmt|,
name|current
decl_stmt|;
name|old
operator|=
name|list
expr_stmt|;
name|current
operator|=
operator|*
name|old
expr_stmt|;
while|while
condition|(
name|current
condition|)
block|{
if|if
condition|(
name|current
operator|==
name|profile
condition|)
block|{
operator|*
name|old
operator|=
name|current
operator|->
name|link
expr_stmt|;
return|return;
block|}
name|old
operator|=
operator|&
name|current
operator|->
name|link
expr_stmt|;
name|current
operator|=
operator|*
name|old
expr_stmt|;
block|}
comment|/* we should never get there, unless the profile was not part of */
comment|/* the list.                                                     */
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*  Sort                                                                 */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    Sorts a trace list.  In 95%, the list is already sorted.  We need  */
end_comment
begin_comment
comment|/*    an algorithm which is fast in this case.  Bubble sort is enough    */
end_comment
begin_comment
comment|/*    and simple.                                                        */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Sort
name|Sort
parameter_list|(
name|PProfileList
name|list
parameter_list|)
block|{
name|PProfile
modifier|*
name|old
decl_stmt|,
name|current
decl_stmt|,
name|next
decl_stmt|;
comment|/* First, set the new X coordinate of each profile */
name|current
operator|=
operator|*
name|list
expr_stmt|;
while|while
condition|(
name|current
condition|)
block|{
name|current
operator|->
name|X
operator|=
operator|*
name|current
operator|->
name|offset
expr_stmt|;
name|current
operator|->
name|offset
operator|+=
operator|(
name|current
operator|->
name|flags
operator|&
name|Flow_Up
operator|)
condition|?
literal|1
else|:
operator|-
literal|1
expr_stmt|;
name|current
operator|->
name|height
operator|--
expr_stmt|;
name|current
operator|=
name|current
operator|->
name|link
expr_stmt|;
block|}
comment|/* Then sort them */
name|old
operator|=
name|list
expr_stmt|;
name|current
operator|=
operator|*
name|old
expr_stmt|;
if|if
condition|(
operator|!
name|current
condition|)
return|return;
name|next
operator|=
name|current
operator|->
name|link
expr_stmt|;
while|while
condition|(
name|next
condition|)
block|{
if|if
condition|(
name|current
operator|->
name|X
operator|<=
name|next
operator|->
name|X
condition|)
block|{
name|old
operator|=
operator|&
name|current
operator|->
name|link
expr_stmt|;
name|current
operator|=
operator|*
name|old
expr_stmt|;
if|if
condition|(
operator|!
name|current
condition|)
return|return;
block|}
else|else
block|{
operator|*
name|old
operator|=
name|next
expr_stmt|;
name|current
operator|->
name|link
operator|=
name|next
operator|->
name|link
expr_stmt|;
name|next
operator|->
name|link
operator|=
name|current
expr_stmt|;
name|old
operator|=
name|list
expr_stmt|;
name|current
operator|=
operator|*
name|old
expr_stmt|;
block|}
name|next
operator|=
name|current
operator|->
name|link
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*  Vertical Sweep Procedure Set                                         */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*  These four routines are used during the vertical black/white sweep   */
end_comment
begin_comment
comment|/*  phase by the generic Draw_Sweep() function.                          */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_function
specifier|static
name|void
DECL|function|Vertical_Sweep_Init
name|Vertical_Sweep_Init
parameter_list|(
name|RAS_ARGS
name|Short
modifier|*
name|min
parameter_list|,
name|Short
modifier|*
name|max
parameter_list|)
block|{
name|Long
name|pitch
init|=
name|ras
operator|.
name|target
operator|.
name|pitch
decl_stmt|;
name|FT_UNUSED
argument_list|(
name|max
argument_list|)
expr_stmt|;
name|ras
operator|.
name|traceIncr
operator|=
operator|(
name|Short
operator|)
operator|-
name|pitch
expr_stmt|;
name|ras
operator|.
name|traceOfs
operator|=
operator|-
operator|*
name|min
operator|*
name|pitch
expr_stmt|;
if|if
condition|(
name|pitch
operator|>
literal|0
condition|)
name|ras
operator|.
name|traceOfs
operator|+=
call|(
name|Long
call|)
argument_list|(
name|ras
operator|.
name|target
operator|.
name|rows
operator|-
literal|1
argument_list|)
operator|*
name|pitch
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|Vertical_Sweep_Span
name|Vertical_Sweep_Span
parameter_list|(
name|RAS_ARGS
name|Short
name|y
parameter_list|,
name|FT_F26Dot6
name|x1
parameter_list|,
name|FT_F26Dot6
name|x2
parameter_list|,
name|PProfile
name|left
parameter_list|,
name|PProfile
name|right
parameter_list|)
block|{
name|Long
name|e1
decl_stmt|,
name|e2
decl_stmt|;
name|Byte
modifier|*
name|target
decl_stmt|;
name|Int
name|dropOutControl
init|=
name|left
operator|->
name|flags
operator|&
literal|7
decl_stmt|;
name|FT_UNUSED
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|left
argument_list|)
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|right
argument_list|)
expr_stmt|;
comment|/* in high-precision mode, we need 12 digits after the comma to */
comment|/* represent multiples of 1/(1<<12) = 1/4096                    */
name|FT_TRACE7
argument_list|(
operator|(
literal|"  y=%d x=[%.12f;%.12f], drop-out=%d"
operator|,
name|y
operator|,
name|x1
operator|/
operator|(
name|double
operator|)
name|ras
operator|.
name|precision
operator|,
name|x2
operator|/
operator|(
name|double
operator|)
name|ras
operator|.
name|precision
operator|,
name|dropOutControl
operator|)
argument_list|)
expr_stmt|;
comment|/* Drop-out control */
name|e1
operator|=
name|TRUNC
argument_list|(
name|CEILING
argument_list|(
name|x1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dropOutControl
operator|!=
literal|2
operator|&&
name|x2
operator|-
name|x1
operator|-
name|ras
operator|.
name|precision
operator|<=
name|ras
operator|.
name|precision_jitter
condition|)
name|e2
operator|=
name|e1
expr_stmt|;
else|else
name|e2
operator|=
name|TRUNC
argument_list|(
name|FLOOR
argument_list|(
name|x2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|e2
operator|>=
literal|0
operator|&&
name|e1
operator|<
name|ras
operator|.
name|bWidth
condition|)
block|{
name|Int
name|c1
decl_stmt|,
name|c2
decl_stmt|;
name|Byte
name|f1
decl_stmt|,
name|f2
decl_stmt|;
if|if
condition|(
name|e1
operator|<
literal|0
condition|)
name|e1
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|e2
operator|>=
name|ras
operator|.
name|bWidth
condition|)
name|e2
operator|=
name|ras
operator|.
name|bWidth
operator|-
literal|1
expr_stmt|;
name|FT_TRACE7
argument_list|(
operator|(
literal|" -> x=[%d;%d]"
operator|,
name|e1
operator|,
name|e2
operator|)
argument_list|)
expr_stmt|;
name|c1
operator|=
call|(
name|Short
call|)
argument_list|(
name|e1
operator|>>
literal|3
argument_list|)
expr_stmt|;
name|c2
operator|=
call|(
name|Short
call|)
argument_list|(
name|e2
operator|>>
literal|3
argument_list|)
expr_stmt|;
name|f1
operator|=
call|(
name|Byte
call|)
argument_list|(
literal|0xFF
operator|>>
operator|(
name|e1
operator|&
literal|7
operator|)
argument_list|)
expr_stmt|;
name|f2
operator|=
operator|(
name|Byte
operator|)
operator|~
operator|(
literal|0x7F
operator|>>
operator|(
name|e2
operator|&
literal|7
operator|)
operator|)
expr_stmt|;
name|target
operator|=
name|ras
operator|.
name|bTarget
operator|+
name|ras
operator|.
name|traceOfs
operator|+
name|c1
expr_stmt|;
name|c2
operator|-=
name|c1
expr_stmt|;
if|if
condition|(
name|c2
operator|>
literal|0
condition|)
block|{
name|target
index|[
literal|0
index|]
operator||=
name|f1
expr_stmt|;
comment|/* memset() is slower than the following code on many platforms. */
comment|/* This is due to the fact that, in the vast majority of cases,  */
comment|/* the span length in bytes is relatively small.                 */
name|c2
operator|--
expr_stmt|;
while|while
condition|(
name|c2
operator|>
literal|0
condition|)
block|{
operator|*
operator|(
operator|++
name|target
operator|)
operator|=
literal|0xFF
expr_stmt|;
name|c2
operator|--
expr_stmt|;
block|}
name|target
index|[
literal|1
index|]
operator||=
name|f2
expr_stmt|;
block|}
else|else
operator|*
name|target
operator||=
operator|(
name|f1
operator|&
name|f2
operator|)
expr_stmt|;
block|}
name|FT_TRACE7
argument_list|(
operator|(
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|Vertical_Sweep_Drop
name|Vertical_Sweep_Drop
parameter_list|(
name|RAS_ARGS
name|Short
name|y
parameter_list|,
name|FT_F26Dot6
name|x1
parameter_list|,
name|FT_F26Dot6
name|x2
parameter_list|,
name|PProfile
name|left
parameter_list|,
name|PProfile
name|right
parameter_list|)
block|{
name|Long
name|e1
decl_stmt|,
name|e2
decl_stmt|,
name|pxl
decl_stmt|;
name|Short
name|c1
decl_stmt|,
name|f1
decl_stmt|;
name|FT_TRACE7
argument_list|(
operator|(
literal|"  y=%d x=[%.12f;%.12f]"
operator|,
name|y
operator|,
name|x1
operator|/
operator|(
name|double
operator|)
name|ras
operator|.
name|precision
operator|,
name|x2
operator|/
operator|(
name|double
operator|)
name|ras
operator|.
name|precision
operator|)
argument_list|)
expr_stmt|;
comment|/* Drop-out control */
comment|/*   e2            x2                    x1           e1   */
comment|/*                                                         */
comment|/*                 ^                     |                 */
comment|/*                 |                     |                 */
comment|/*   +-------------+---------------------+------------+    */
comment|/*                 |                     |                 */
comment|/*                 |                     v                 */
comment|/*                                                         */
comment|/* pixel         contour              contour       pixel  */
comment|/* center                                           center */
comment|/* drop-out mode    scan conversion rules (as defined in OpenType) */
comment|/* --------------------------------------------------------------- */
comment|/*  0                1, 2, 3                                       */
comment|/*  1                1, 2, 4                                       */
comment|/*  2                1, 2                                          */
comment|/*  3                same as mode 2                                */
comment|/*  4                1, 2, 5                                       */
comment|/*  5                1, 2, 6                                       */
comment|/*  6, 7             same as mode 2                                */
name|e1
operator|=
name|CEILING
argument_list|(
name|x1
argument_list|)
expr_stmt|;
name|e2
operator|=
name|FLOOR
argument_list|(
name|x2
argument_list|)
expr_stmt|;
name|pxl
operator|=
name|e1
expr_stmt|;
if|if
condition|(
name|e1
operator|>
name|e2
condition|)
block|{
name|Int
name|dropOutControl
init|=
name|left
operator|->
name|flags
operator|&
literal|7
decl_stmt|;
name|FT_TRACE7
argument_list|(
operator|(
literal|", drop-out=%d"
operator|,
name|dropOutControl
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|e1
operator|==
name|e2
operator|+
name|ras
operator|.
name|precision
condition|)
block|{
switch|switch
condition|(
name|dropOutControl
condition|)
block|{
case|case
literal|0
case|:
comment|/* simple drop-outs including stubs */
name|pxl
operator|=
name|e2
expr_stmt|;
break|break;
case|case
literal|4
case|:
comment|/* smart drop-outs including stubs */
name|pxl
operator|=
name|FLOOR
argument_list|(
operator|(
name|x1
operator|+
name|x2
operator|-
literal|1
operator|)
operator|/
literal|2
operator|+
name|ras
operator|.
name|precision_half
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* simple drop-outs excluding stubs */
case|case
literal|5
case|:
comment|/* smart drop-outs excluding stubs  */
comment|/* Drop-out Control Rules #4 and #6 */
comment|/* The specification neither provides an exact definition */
comment|/* of a `stub' nor gives exact rules to exclude them.     */
comment|/*                                                        */
comment|/* Here the constraints we use to recognize a stub.       */
comment|/*                                                        */
comment|/*  upper stub:                                           */
comment|/*                                                        */
comment|/*   - P_Left and P_Right are in the same contour         */
comment|/*   - P_Right is the successor of P_Left in that contour */
comment|/*   - y is the top of P_Left and P_Right                 */
comment|/*                                                        */
comment|/*  lower stub:                                           */
comment|/*                                                        */
comment|/*   - P_Left and P_Right are in the same contour         */
comment|/*   - P_Left is the successor of P_Right in that contour */
comment|/*   - y is the bottom of P_Left                          */
comment|/*                                                        */
comment|/* We draw a stub if the following constraints are met.   */
comment|/*                                                        */
comment|/*   - for an upper or lower stub, there is top or bottom */
comment|/*     overshoot, respectively                            */
comment|/*   - the covered interval is greater or equal to a half */
comment|/*     pixel                                              */
comment|/* upper stub test */
if|if
condition|(
name|left
operator|->
name|next
operator|==
name|right
operator|&&
name|left
operator|->
name|height
operator|<=
literal|0
operator|&&
operator|!
operator|(
name|left
operator|->
name|flags
operator|&
name|Overshoot_Top
operator|&&
name|x2
operator|-
name|x1
operator|>=
name|ras
operator|.
name|precision_half
operator|)
condition|)
goto|goto
name|Exit
goto|;
comment|/* lower stub test */
if|if
condition|(
name|right
operator|->
name|next
operator|==
name|left
operator|&&
name|left
operator|->
name|start
operator|==
name|y
operator|&&
operator|!
operator|(
name|left
operator|->
name|flags
operator|&
name|Overshoot_Bottom
operator|&&
name|x2
operator|-
name|x1
operator|>=
name|ras
operator|.
name|precision_half
operator|)
condition|)
goto|goto
name|Exit
goto|;
if|if
condition|(
name|dropOutControl
operator|==
literal|1
condition|)
name|pxl
operator|=
name|e2
expr_stmt|;
else|else
name|pxl
operator|=
name|FLOOR
argument_list|(
operator|(
name|x1
operator|+
name|x2
operator|-
literal|1
operator|)
operator|/
literal|2
operator|+
name|ras
operator|.
name|precision_half
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* modes 2, 3, 6, 7 */
goto|goto
name|Exit
goto|;
comment|/* no drop-out control */
block|}
comment|/* undocumented but confirmed: If the drop-out would result in a  */
comment|/* pixel outside of the bounding box, use the pixel inside of the */
comment|/* bounding box instead                                           */
if|if
condition|(
name|pxl
operator|<
literal|0
condition|)
name|pxl
operator|=
name|e1
expr_stmt|;
elseif|else
if|if
condition|(
name|TRUNC
argument_list|(
name|pxl
argument_list|)
operator|>=
name|ras
operator|.
name|bWidth
condition|)
name|pxl
operator|=
name|e2
expr_stmt|;
comment|/* check that the other pixel isn't set */
name|e1
operator|=
name|pxl
operator|==
name|e1
condition|?
name|e2
else|:
name|e1
expr_stmt|;
name|e1
operator|=
name|TRUNC
argument_list|(
name|e1
argument_list|)
expr_stmt|;
name|c1
operator|=
call|(
name|Short
call|)
argument_list|(
name|e1
operator|>>
literal|3
argument_list|)
expr_stmt|;
name|f1
operator|=
call|(
name|Short
call|)
argument_list|(
name|e1
operator|&
literal|7
argument_list|)
expr_stmt|;
if|if
condition|(
name|e1
operator|>=
literal|0
operator|&&
name|e1
operator|<
name|ras
operator|.
name|bWidth
operator|&&
name|ras
operator|.
name|bTarget
index|[
name|ras
operator|.
name|traceOfs
operator|+
name|c1
index|]
operator|&
operator|(
literal|0x80
operator|>>
name|f1
operator|)
condition|)
goto|goto
name|Exit
goto|;
block|}
else|else
goto|goto
name|Exit
goto|;
block|}
name|e1
operator|=
name|TRUNC
argument_list|(
name|pxl
argument_list|)
expr_stmt|;
if|if
condition|(
name|e1
operator|>=
literal|0
operator|&&
name|e1
operator|<
name|ras
operator|.
name|bWidth
condition|)
block|{
name|FT_TRACE7
argument_list|(
operator|(
literal|" -> x=%d (drop-out)"
operator|,
name|e1
operator|)
argument_list|)
expr_stmt|;
name|c1
operator|=
call|(
name|Short
call|)
argument_list|(
name|e1
operator|>>
literal|3
argument_list|)
expr_stmt|;
name|f1
operator|=
call|(
name|Short
call|)
argument_list|(
name|e1
operator|&
literal|7
argument_list|)
expr_stmt|;
name|ras
operator|.
name|bTarget
index|[
name|ras
operator|.
name|traceOfs
operator|+
name|c1
index|]
operator||=
call|(
name|char
call|)
argument_list|(
literal|0x80
operator|>>
name|f1
argument_list|)
expr_stmt|;
block|}
name|Exit
label|:
name|FT_TRACE7
argument_list|(
operator|(
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|Vertical_Sweep_Step
name|Vertical_Sweep_Step
parameter_list|(
name|RAS_ARG
parameter_list|)
block|{
name|ras
operator|.
name|traceOfs
operator|+=
name|ras
operator|.
name|traceIncr
expr_stmt|;
block|}
end_function
begin_comment
comment|/***********************************************************************/
end_comment
begin_comment
comment|/*                                                                     */
end_comment
begin_comment
comment|/*  Horizontal Sweep Procedure Set                                     */
end_comment
begin_comment
comment|/*                                                                     */
end_comment
begin_comment
comment|/*  These four routines are used during the horizontal black/white     */
end_comment
begin_comment
comment|/*  sweep phase by the generic Draw_Sweep() function.                  */
end_comment
begin_comment
comment|/*                                                                     */
end_comment
begin_comment
comment|/***********************************************************************/
end_comment
begin_function
specifier|static
name|void
DECL|function|Horizontal_Sweep_Init
name|Horizontal_Sweep_Init
parameter_list|(
name|RAS_ARGS
name|Short
modifier|*
name|min
parameter_list|,
name|Short
modifier|*
name|max
parameter_list|)
block|{
comment|/* nothing, really */
name|FT_UNUSED_RASTER
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|min
argument_list|)
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|max
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|Horizontal_Sweep_Span
name|Horizontal_Sweep_Span
parameter_list|(
name|RAS_ARGS
name|Short
name|y
parameter_list|,
name|FT_F26Dot6
name|x1
parameter_list|,
name|FT_F26Dot6
name|x2
parameter_list|,
name|PProfile
name|left
parameter_list|,
name|PProfile
name|right
parameter_list|)
block|{
name|FT_UNUSED
argument_list|(
name|left
argument_list|)
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|right
argument_list|)
expr_stmt|;
if|if
condition|(
name|x2
operator|-
name|x1
operator|<
name|ras
operator|.
name|precision
condition|)
block|{
name|Long
name|e1
decl_stmt|,
name|e2
decl_stmt|;
name|FT_TRACE7
argument_list|(
operator|(
literal|"  x=%d y=[%.12f;%.12f]"
operator|,
name|y
operator|,
name|x1
operator|/
operator|(
name|double
operator|)
name|ras
operator|.
name|precision
operator|,
name|x2
operator|/
operator|(
name|double
operator|)
name|ras
operator|.
name|precision
operator|)
argument_list|)
expr_stmt|;
name|e1
operator|=
name|CEILING
argument_list|(
name|x1
argument_list|)
expr_stmt|;
name|e2
operator|=
name|FLOOR
argument_list|(
name|x2
argument_list|)
expr_stmt|;
if|if
condition|(
name|e1
operator|==
name|e2
condition|)
block|{
name|e1
operator|=
name|TRUNC
argument_list|(
name|e1
argument_list|)
expr_stmt|;
if|if
condition|(
name|e1
operator|>=
literal|0
operator|&&
operator|(
name|ULong
operator|)
name|e1
operator|<
name|ras
operator|.
name|target
operator|.
name|rows
condition|)
block|{
name|Byte
name|f1
decl_stmt|;
name|PByte
name|bits
decl_stmt|;
name|PByte
name|p
decl_stmt|;
name|FT_TRACE7
argument_list|(
operator|(
literal|" -> y=%d (drop-out)"
operator|,
name|e1
operator|)
argument_list|)
expr_stmt|;
name|bits
operator|=
name|ras
operator|.
name|bTarget
operator|+
operator|(
name|y
operator|>>
literal|3
operator|)
expr_stmt|;
name|f1
operator|=
call|(
name|Byte
call|)
argument_list|(
literal|0x80
operator|>>
operator|(
name|y
operator|&
literal|7
operator|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|bits
operator|-
name|e1
operator|*
name|ras
operator|.
name|target
operator|.
name|pitch
expr_stmt|;
if|if
condition|(
name|ras
operator|.
name|target
operator|.
name|pitch
operator|>
literal|0
condition|)
name|p
operator|+=
call|(
name|Long
call|)
argument_list|(
name|ras
operator|.
name|target
operator|.
name|rows
operator|-
literal|1
argument_list|)
operator|*
name|ras
operator|.
name|target
operator|.
name|pitch
expr_stmt|;
name|p
index|[
literal|0
index|]
operator||=
name|f1
expr_stmt|;
block|}
block|}
name|FT_TRACE7
argument_list|(
operator|(
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|Horizontal_Sweep_Drop
name|Horizontal_Sweep_Drop
parameter_list|(
name|RAS_ARGS
name|Short
name|y
parameter_list|,
name|FT_F26Dot6
name|x1
parameter_list|,
name|FT_F26Dot6
name|x2
parameter_list|,
name|PProfile
name|left
parameter_list|,
name|PProfile
name|right
parameter_list|)
block|{
name|Long
name|e1
decl_stmt|,
name|e2
decl_stmt|,
name|pxl
decl_stmt|;
name|PByte
name|bits
decl_stmt|;
name|Byte
name|f1
decl_stmt|;
name|FT_TRACE7
argument_list|(
operator|(
literal|"  x=%d y=[%.12f;%.12f]"
operator|,
name|y
operator|,
name|x1
operator|/
operator|(
name|double
operator|)
name|ras
operator|.
name|precision
operator|,
name|x2
operator|/
operator|(
name|double
operator|)
name|ras
operator|.
name|precision
operator|)
argument_list|)
expr_stmt|;
comment|/* During the horizontal sweep, we only take care of drop-outs */
comment|/* e1     +<-- pixel center */
comment|/*        |                        */
comment|/* x1  ---+--><-- contour      */
comment|/*        |                        */
comment|/*        |                        */
comment|/* x2<--+---<-- contour      */
comment|/*        |                        */
comment|/*        |                        */
comment|/* e2     +<-- pixel center */
name|e1
operator|=
name|CEILING
argument_list|(
name|x1
argument_list|)
expr_stmt|;
name|e2
operator|=
name|FLOOR
argument_list|(
name|x2
argument_list|)
expr_stmt|;
name|pxl
operator|=
name|e1
expr_stmt|;
if|if
condition|(
name|e1
operator|>
name|e2
condition|)
block|{
name|Int
name|dropOutControl
init|=
name|left
operator|->
name|flags
operator|&
literal|7
decl_stmt|;
name|FT_TRACE7
argument_list|(
operator|(
literal|", dropout=%d"
operator|,
name|dropOutControl
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|e1
operator|==
name|e2
operator|+
name|ras
operator|.
name|precision
condition|)
block|{
switch|switch
condition|(
name|dropOutControl
condition|)
block|{
case|case
literal|0
case|:
comment|/* simple drop-outs including stubs */
name|pxl
operator|=
name|e2
expr_stmt|;
break|break;
case|case
literal|4
case|:
comment|/* smart drop-outs including stubs */
name|pxl
operator|=
name|FLOOR
argument_list|(
operator|(
name|x1
operator|+
name|x2
operator|-
literal|1
operator|)
operator|/
literal|2
operator|+
name|ras
operator|.
name|precision_half
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* simple drop-outs excluding stubs */
case|case
literal|5
case|:
comment|/* smart drop-outs excluding stubs  */
comment|/* see Vertical_Sweep_Drop for details */
comment|/* rightmost stub test */
if|if
condition|(
name|left
operator|->
name|next
operator|==
name|right
operator|&&
name|left
operator|->
name|height
operator|<=
literal|0
operator|&&
operator|!
operator|(
name|left
operator|->
name|flags
operator|&
name|Overshoot_Top
operator|&&
name|x2
operator|-
name|x1
operator|>=
name|ras
operator|.
name|precision_half
operator|)
condition|)
goto|goto
name|Exit
goto|;
comment|/* leftmost stub test */
if|if
condition|(
name|right
operator|->
name|next
operator|==
name|left
operator|&&
name|left
operator|->
name|start
operator|==
name|y
operator|&&
operator|!
operator|(
name|left
operator|->
name|flags
operator|&
name|Overshoot_Bottom
operator|&&
name|x2
operator|-
name|x1
operator|>=
name|ras
operator|.
name|precision_half
operator|)
condition|)
goto|goto
name|Exit
goto|;
if|if
condition|(
name|dropOutControl
operator|==
literal|1
condition|)
name|pxl
operator|=
name|e2
expr_stmt|;
else|else
name|pxl
operator|=
name|FLOOR
argument_list|(
operator|(
name|x1
operator|+
name|x2
operator|-
literal|1
operator|)
operator|/
literal|2
operator|+
name|ras
operator|.
name|precision_half
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* modes 2, 3, 6, 7 */
goto|goto
name|Exit
goto|;
comment|/* no drop-out control */
block|}
comment|/* undocumented but confirmed: If the drop-out would result in a  */
comment|/* pixel outside of the bounding box, use the pixel inside of the */
comment|/* bounding box instead                                           */
if|if
condition|(
name|pxl
operator|<
literal|0
condition|)
name|pxl
operator|=
name|e1
expr_stmt|;
elseif|else
if|if
condition|(
call|(
name|ULong
call|)
argument_list|(
name|TRUNC
argument_list|(
name|pxl
argument_list|)
argument_list|)
operator|>=
name|ras
operator|.
name|target
operator|.
name|rows
condition|)
name|pxl
operator|=
name|e2
expr_stmt|;
comment|/* check that the other pixel isn't set */
name|e1
operator|=
name|pxl
operator|==
name|e1
condition|?
name|e2
else|:
name|e1
expr_stmt|;
name|e1
operator|=
name|TRUNC
argument_list|(
name|e1
argument_list|)
expr_stmt|;
name|bits
operator|=
name|ras
operator|.
name|bTarget
operator|+
operator|(
name|y
operator|>>
literal|3
operator|)
expr_stmt|;
name|f1
operator|=
call|(
name|Byte
call|)
argument_list|(
literal|0x80
operator|>>
operator|(
name|y
operator|&
literal|7
operator|)
argument_list|)
expr_stmt|;
name|bits
operator|-=
name|e1
operator|*
name|ras
operator|.
name|target
operator|.
name|pitch
expr_stmt|;
if|if
condition|(
name|ras
operator|.
name|target
operator|.
name|pitch
operator|>
literal|0
condition|)
name|bits
operator|+=
call|(
name|Long
call|)
argument_list|(
name|ras
operator|.
name|target
operator|.
name|rows
operator|-
literal|1
argument_list|)
operator|*
name|ras
operator|.
name|target
operator|.
name|pitch
expr_stmt|;
if|if
condition|(
name|e1
operator|>=
literal|0
operator|&&
operator|(
name|ULong
operator|)
name|e1
operator|<
name|ras
operator|.
name|target
operator|.
name|rows
operator|&&
operator|*
name|bits
operator|&
name|f1
condition|)
goto|goto
name|Exit
goto|;
block|}
else|else
goto|goto
name|Exit
goto|;
block|}
name|e1
operator|=
name|TRUNC
argument_list|(
name|pxl
argument_list|)
expr_stmt|;
if|if
condition|(
name|e1
operator|>=
literal|0
operator|&&
operator|(
name|ULong
operator|)
name|e1
operator|<
name|ras
operator|.
name|target
operator|.
name|rows
condition|)
block|{
name|FT_TRACE7
argument_list|(
operator|(
literal|" -> y=%d (drop-out)"
operator|,
name|e1
operator|)
argument_list|)
expr_stmt|;
name|bits
operator|=
name|ras
operator|.
name|bTarget
operator|+
operator|(
name|y
operator|>>
literal|3
operator|)
expr_stmt|;
name|f1
operator|=
call|(
name|Byte
call|)
argument_list|(
literal|0x80
operator|>>
operator|(
name|y
operator|&
literal|7
operator|)
argument_list|)
expr_stmt|;
name|bits
operator|-=
name|e1
operator|*
name|ras
operator|.
name|target
operator|.
name|pitch
expr_stmt|;
if|if
condition|(
name|ras
operator|.
name|target
operator|.
name|pitch
operator|>
literal|0
condition|)
name|bits
operator|+=
call|(
name|Long
call|)
argument_list|(
name|ras
operator|.
name|target
operator|.
name|rows
operator|-
literal|1
argument_list|)
operator|*
name|ras
operator|.
name|target
operator|.
name|pitch
expr_stmt|;
name|bits
index|[
literal|0
index|]
operator||=
name|f1
expr_stmt|;
block|}
name|Exit
label|:
name|FT_TRACE7
argument_list|(
operator|(
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|Horizontal_Sweep_Step
name|Horizontal_Sweep_Step
parameter_list|(
name|RAS_ARG
parameter_list|)
block|{
comment|/* Nothing, really */
name|FT_UNUSED_RASTER
expr_stmt|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*  Generic Sweep Drawing routine                                        */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_function
specifier|static
name|Bool
DECL|function|Draw_Sweep
name|Draw_Sweep
parameter_list|(
name|RAS_ARG
parameter_list|)
block|{
name|Short
name|y
decl_stmt|,
name|y_change
decl_stmt|,
name|y_height
decl_stmt|;
name|PProfile
name|P
decl_stmt|,
name|Q
decl_stmt|,
name|P_Left
decl_stmt|,
name|P_Right
decl_stmt|;
name|Short
name|min_Y
decl_stmt|,
name|max_Y
decl_stmt|,
name|top
decl_stmt|,
name|bottom
decl_stmt|,
name|dropouts
decl_stmt|;
name|Long
name|x1
decl_stmt|,
name|x2
decl_stmt|,
name|xs
decl_stmt|,
name|e1
decl_stmt|,
name|e2
decl_stmt|;
name|TProfileList
name|waiting
decl_stmt|;
name|TProfileList
name|draw_left
decl_stmt|,
name|draw_right
decl_stmt|;
comment|/* initialize empty linked lists */
name|Init_Linked
argument_list|(
operator|&
name|waiting
argument_list|)
expr_stmt|;
name|Init_Linked
argument_list|(
operator|&
name|draw_left
argument_list|)
expr_stmt|;
name|Init_Linked
argument_list|(
operator|&
name|draw_right
argument_list|)
expr_stmt|;
comment|/* first, compute min and max Y */
name|P
operator|=
name|ras
operator|.
name|fProfile
expr_stmt|;
name|max_Y
operator|=
operator|(
name|Short
operator|)
name|TRUNC
argument_list|(
name|ras
operator|.
name|minY
argument_list|)
expr_stmt|;
name|min_Y
operator|=
operator|(
name|Short
operator|)
name|TRUNC
argument_list|(
name|ras
operator|.
name|maxY
argument_list|)
expr_stmt|;
while|while
condition|(
name|P
condition|)
block|{
name|Q
operator|=
name|P
operator|->
name|link
expr_stmt|;
name|bottom
operator|=
operator|(
name|Short
operator|)
name|P
operator|->
name|start
expr_stmt|;
name|top
operator|=
call|(
name|Short
call|)
argument_list|(
name|P
operator|->
name|start
operator|+
name|P
operator|->
name|height
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|min_Y
operator|>
name|bottom
condition|)
name|min_Y
operator|=
name|bottom
expr_stmt|;
if|if
condition|(
name|max_Y
operator|<
name|top
condition|)
name|max_Y
operator|=
name|top
expr_stmt|;
name|P
operator|->
name|X
operator|=
literal|0
expr_stmt|;
name|InsNew
argument_list|(
operator|&
name|waiting
argument_list|,
name|P
argument_list|)
expr_stmt|;
name|P
operator|=
name|Q
expr_stmt|;
block|}
comment|/* check the Y-turns */
if|if
condition|(
name|ras
operator|.
name|numTurns
operator|==
literal|0
condition|)
block|{
name|ras
operator|.
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid
argument_list|)
expr_stmt|;
return|return
name|FAILURE
return|;
block|}
comment|/* now initialize the sweep */
name|ras
operator|.
name|Proc_Sweep_Init
argument_list|(
name|RAS_VARS
operator|&
name|min_Y
argument_list|,
operator|&
name|max_Y
argument_list|)
expr_stmt|;
comment|/* then compute the distance of each profile from min_Y */
name|P
operator|=
name|waiting
expr_stmt|;
while|while
condition|(
name|P
condition|)
block|{
name|P
operator|->
name|countL
operator|=
name|P
operator|->
name|start
operator|-
name|min_Y
expr_stmt|;
name|P
operator|=
name|P
operator|->
name|link
expr_stmt|;
block|}
comment|/* let's go */
name|y
operator|=
name|min_Y
expr_stmt|;
name|y_height
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ras
operator|.
name|numTurns
operator|>
literal|0
operator|&&
name|ras
operator|.
name|sizeBuff
index|[
operator|-
name|ras
operator|.
name|numTurns
index|]
operator|==
name|min_Y
condition|)
name|ras
operator|.
name|numTurns
operator|--
expr_stmt|;
while|while
condition|(
name|ras
operator|.
name|numTurns
operator|>
literal|0
condition|)
block|{
comment|/* check waiting list for new activations */
name|P
operator|=
name|waiting
expr_stmt|;
while|while
condition|(
name|P
condition|)
block|{
name|Q
operator|=
name|P
operator|->
name|link
expr_stmt|;
name|P
operator|->
name|countL
operator|-=
name|y_height
expr_stmt|;
if|if
condition|(
name|P
operator|->
name|countL
operator|==
literal|0
condition|)
block|{
name|DelOld
argument_list|(
operator|&
name|waiting
argument_list|,
name|P
argument_list|)
expr_stmt|;
if|if
condition|(
name|P
operator|->
name|flags
operator|&
name|Flow_Up
condition|)
name|InsNew
argument_list|(
operator|&
name|draw_left
argument_list|,
name|P
argument_list|)
expr_stmt|;
else|else
name|InsNew
argument_list|(
operator|&
name|draw_right
argument_list|,
name|P
argument_list|)
expr_stmt|;
block|}
name|P
operator|=
name|Q
expr_stmt|;
block|}
comment|/* sort the drawing lists */
name|Sort
argument_list|(
operator|&
name|draw_left
argument_list|)
expr_stmt|;
name|Sort
argument_list|(
operator|&
name|draw_right
argument_list|)
expr_stmt|;
name|y_change
operator|=
operator|(
name|Short
operator|)
name|ras
operator|.
name|sizeBuff
index|[
operator|-
name|ras
operator|.
name|numTurns
operator|--
index|]
expr_stmt|;
name|y_height
operator|=
call|(
name|Short
call|)
argument_list|(
name|y_change
operator|-
name|y
argument_list|)
expr_stmt|;
while|while
condition|(
name|y
operator|<
name|y_change
condition|)
block|{
comment|/* let's trace */
name|dropouts
operator|=
literal|0
expr_stmt|;
name|P_Left
operator|=
name|draw_left
expr_stmt|;
name|P_Right
operator|=
name|draw_right
expr_stmt|;
while|while
condition|(
name|P_Left
condition|)
block|{
name|x1
operator|=
name|P_Left
operator|->
name|X
expr_stmt|;
name|x2
operator|=
name|P_Right
operator|->
name|X
expr_stmt|;
if|if
condition|(
name|x1
operator|>
name|x2
condition|)
block|{
name|xs
operator|=
name|x1
expr_stmt|;
name|x1
operator|=
name|x2
expr_stmt|;
name|x2
operator|=
name|xs
expr_stmt|;
block|}
name|e1
operator|=
name|FLOOR
argument_list|(
name|x1
argument_list|)
expr_stmt|;
name|e2
operator|=
name|CEILING
argument_list|(
name|x2
argument_list|)
expr_stmt|;
if|if
condition|(
name|x2
operator|-
name|x1
operator|<=
name|ras
operator|.
name|precision
operator|&&
name|e1
operator|!=
name|x1
operator|&&
name|e2
operator|!=
name|x2
condition|)
block|{
if|if
condition|(
name|e1
operator|>
name|e2
operator|||
name|e2
operator|==
name|e1
operator|+
name|ras
operator|.
name|precision
condition|)
block|{
name|Int
name|dropOutControl
init|=
name|P_Left
operator|->
name|flags
operator|&
literal|7
decl_stmt|;
if|if
condition|(
name|dropOutControl
operator|!=
literal|2
condition|)
block|{
comment|/* a drop-out was detected */
name|P_Left
operator|->
name|X
operator|=
name|x1
expr_stmt|;
name|P_Right
operator|->
name|X
operator|=
name|x2
expr_stmt|;
comment|/* mark profile for drop-out processing */
name|P_Left
operator|->
name|countL
operator|=
literal|1
expr_stmt|;
name|dropouts
operator|++
expr_stmt|;
block|}
goto|goto
name|Skip_To_Next
goto|;
block|}
block|}
name|ras
operator|.
name|Proc_Sweep_Span
argument_list|(
argument|RAS_VARS y
argument_list|,
argument|x1
argument_list|,
argument|x2
argument_list|,
argument|P_Left
argument_list|,
argument|P_Right
argument_list|)
expr_stmt|;
name|Skip_To_Next
label|:
name|P_Left
operator|=
name|P_Left
operator|->
name|link
expr_stmt|;
name|P_Right
operator|=
name|P_Right
operator|->
name|link
expr_stmt|;
block|}
comment|/* handle drop-outs _after_ the span drawing --       */
comment|/* drop-out processing has been moved out of the loop */
comment|/* for performance tuning                             */
if|if
condition|(
name|dropouts
operator|>
literal|0
condition|)
goto|goto
name|Scan_DropOuts
goto|;
name|Next_Line
label|:
name|ras
operator|.
name|Proc_Sweep_Step
argument_list|(
name|RAS_VAR
argument_list|)
expr_stmt|;
name|y
operator|++
expr_stmt|;
if|if
condition|(
name|y
operator|<
name|y_change
condition|)
block|{
name|Sort
argument_list|(
operator|&
name|draw_left
argument_list|)
expr_stmt|;
name|Sort
argument_list|(
operator|&
name|draw_right
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* now finalize the profiles that need it */
name|P
operator|=
name|draw_left
expr_stmt|;
while|while
condition|(
name|P
condition|)
block|{
name|Q
operator|=
name|P
operator|->
name|link
expr_stmt|;
if|if
condition|(
name|P
operator|->
name|height
operator|==
literal|0
condition|)
name|DelOld
argument_list|(
operator|&
name|draw_left
argument_list|,
name|P
argument_list|)
expr_stmt|;
name|P
operator|=
name|Q
expr_stmt|;
block|}
name|P
operator|=
name|draw_right
expr_stmt|;
while|while
condition|(
name|P
condition|)
block|{
name|Q
operator|=
name|P
operator|->
name|link
expr_stmt|;
if|if
condition|(
name|P
operator|->
name|height
operator|==
literal|0
condition|)
name|DelOld
argument_list|(
operator|&
name|draw_right
argument_list|,
name|P
argument_list|)
expr_stmt|;
name|P
operator|=
name|Q
expr_stmt|;
block|}
block|}
comment|/* for gray-scaling, flush the bitmap scanline cache */
while|while
condition|(
name|y
operator|<=
name|max_Y
condition|)
block|{
name|ras
operator|.
name|Proc_Sweep_Step
argument_list|(
name|RAS_VAR
argument_list|)
expr_stmt|;
name|y
operator|++
expr_stmt|;
block|}
return|return
name|SUCCESS
return|;
name|Scan_DropOuts
label|:
name|P_Left
operator|=
name|draw_left
expr_stmt|;
name|P_Right
operator|=
name|draw_right
expr_stmt|;
while|while
condition|(
name|P_Left
condition|)
block|{
if|if
condition|(
name|P_Left
operator|->
name|countL
condition|)
block|{
name|P_Left
operator|->
name|countL
operator|=
literal|0
expr_stmt|;
if|#
directive|if
literal|0
block|dropouts--;
comment|/* -- this is useful when debugging only */
endif|#
directive|endif
name|ras
operator|.
name|Proc_Sweep_Drop
argument_list|(
argument|RAS_VARS y
argument_list|,
argument|P_Left->X
argument_list|,
argument|P_Right->X
argument_list|,
argument|P_Left
argument_list|,
argument|P_Right
argument_list|)
expr_stmt|;
block|}
name|P_Left
operator|=
name|P_Left
operator|->
name|link
expr_stmt|;
name|P_Right
operator|=
name|P_Right
operator|->
name|link
expr_stmt|;
block|}
goto|goto
name|Next_Line
goto|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    Render_Single_Pass                                                 */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Perform one sweep with sub-banding.                                */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    flipped :: If set, flip the direction of the outline.              */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    Renderer error code.                                               */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|int
DECL|function|Render_Single_Pass
name|Render_Single_Pass
parameter_list|(
name|RAS_ARGS
name|Bool
name|flipped
parameter_list|)
block|{
name|Short
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
while|while
condition|(
name|ras
operator|.
name|band_top
operator|>=
literal|0
condition|)
block|{
name|ras
operator|.
name|maxY
operator|=
operator|(
name|Long
operator|)
name|ras
operator|.
name|band_stack
index|[
name|ras
operator|.
name|band_top
index|]
operator|.
name|y_max
operator|*
name|ras
operator|.
name|precision
expr_stmt|;
name|ras
operator|.
name|minY
operator|=
operator|(
name|Long
operator|)
name|ras
operator|.
name|band_stack
index|[
name|ras
operator|.
name|band_top
index|]
operator|.
name|y_min
operator|*
name|ras
operator|.
name|precision
expr_stmt|;
name|ras
operator|.
name|top
operator|=
name|ras
operator|.
name|buff
expr_stmt|;
name|ras
operator|.
name|error
operator|=
name|Raster_Err_None
expr_stmt|;
if|if
condition|(
name|Convert_Glyph
argument_list|(
argument|RAS_VARS flipped
argument_list|)
condition|)
block|{
if|if
condition|(
name|ras
operator|.
name|error
operator|!=
name|Raster_Err_Overflow
condition|)
return|return
name|FAILURE
return|;
name|ras
operator|.
name|error
operator|=
name|Raster_Err_None
expr_stmt|;
comment|/* sub-banding */
ifdef|#
directive|ifdef
name|DEBUG_RASTER
name|ClearBand
argument_list|(
argument|RAS_VARS TRUNC( ras.minY )
argument_list|,
argument|TRUNC( ras.maxY )
argument_list|)
empty_stmt|;
endif|#
directive|endif
name|i
operator|=
name|ras
operator|.
name|band_stack
index|[
name|ras
operator|.
name|band_top
index|]
operator|.
name|y_min
expr_stmt|;
name|j
operator|=
name|ras
operator|.
name|band_stack
index|[
name|ras
operator|.
name|band_top
index|]
operator|.
name|y_max
expr_stmt|;
name|k
operator|=
call|(
name|Short
call|)
argument_list|(
operator|(
name|i
operator|+
name|j
operator|)
operator|/
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ras
operator|.
name|band_top
operator|>=
literal|7
operator|||
name|k
operator|<
name|i
condition|)
block|{
name|ras
operator|.
name|band_top
operator|=
literal|0
expr_stmt|;
name|ras
operator|.
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid
argument_list|)
expr_stmt|;
return|return
name|ras
operator|.
name|error
return|;
block|}
name|ras
operator|.
name|band_stack
index|[
name|ras
operator|.
name|band_top
operator|+
literal|1
index|]
operator|.
name|y_min
operator|=
name|k
expr_stmt|;
name|ras
operator|.
name|band_stack
index|[
name|ras
operator|.
name|band_top
operator|+
literal|1
index|]
operator|.
name|y_max
operator|=
name|j
expr_stmt|;
name|ras
operator|.
name|band_stack
index|[
name|ras
operator|.
name|band_top
index|]
operator|.
name|y_max
operator|=
call|(
name|Short
call|)
argument_list|(
name|k
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ras
operator|.
name|band_top
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ras
operator|.
name|fProfile
condition|)
if|if
condition|(
name|Draw_Sweep
argument_list|(
name|RAS_VAR
argument_list|)
condition|)
return|return
name|ras
operator|.
name|error
return|;
name|ras
operator|.
name|band_top
operator|--
expr_stmt|;
block|}
block|}
return|return
name|SUCCESS
return|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    Render_Glyph                                                       */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Render a glyph in a bitmap.  Sub-banding if needed.                */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    FreeType error code.  0 means success.                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|Render_Glyph
name|Render_Glyph
parameter_list|(
name|RAS_ARG
parameter_list|)
block|{
name|FT_Error
name|error
decl_stmt|;
name|Set_High_Precision
argument_list|(
argument|RAS_VARS ras.outline.flags&                                  FT_OUTLINE_HIGH_PRECISION
argument_list|)
empty_stmt|;
name|ras
operator|.
name|scale_shift
operator|=
name|ras
operator|.
name|precision_shift
expr_stmt|;
if|if
condition|(
name|ras
operator|.
name|outline
operator|.
name|flags
operator|&
name|FT_OUTLINE_IGNORE_DROPOUTS
condition|)
name|ras
operator|.
name|dropOutControl
operator|=
literal|2
expr_stmt|;
else|else
block|{
if|if
condition|(
name|ras
operator|.
name|outline
operator|.
name|flags
operator|&
name|FT_OUTLINE_SMART_DROPOUTS
condition|)
name|ras
operator|.
name|dropOutControl
operator|=
literal|4
expr_stmt|;
else|else
name|ras
operator|.
name|dropOutControl
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ras
operator|.
name|outline
operator|.
name|flags
operator|&
name|FT_OUTLINE_INCLUDE_STUBS
operator|)
condition|)
name|ras
operator|.
name|dropOutControl
operator|+=
literal|1
expr_stmt|;
block|}
name|ras
operator|.
name|second_pass
operator|=
call|(
name|Bool
call|)
argument_list|(
operator|!
operator|(
name|ras
operator|.
name|outline
operator|.
name|flags
operator|&
name|FT_OUTLINE_SINGLE_PASS
operator|)
argument_list|)
expr_stmt|;
comment|/* Vertical Sweep */
name|FT_TRACE7
argument_list|(
operator|(
literal|"Vertical pass (ftraster)\n"
operator|)
argument_list|)
expr_stmt|;
name|ras
operator|.
name|Proc_Sweep_Init
operator|=
name|Vertical_Sweep_Init
expr_stmt|;
name|ras
operator|.
name|Proc_Sweep_Span
operator|=
name|Vertical_Sweep_Span
expr_stmt|;
name|ras
operator|.
name|Proc_Sweep_Drop
operator|=
name|Vertical_Sweep_Drop
expr_stmt|;
name|ras
operator|.
name|Proc_Sweep_Step
operator|=
name|Vertical_Sweep_Step
expr_stmt|;
name|ras
operator|.
name|band_top
operator|=
literal|0
expr_stmt|;
name|ras
operator|.
name|band_stack
index|[
literal|0
index|]
operator|.
name|y_min
operator|=
literal|0
expr_stmt|;
name|ras
operator|.
name|band_stack
index|[
literal|0
index|]
operator|.
name|y_max
operator|=
call|(
name|Short
call|)
argument_list|(
name|ras
operator|.
name|target
operator|.
name|rows
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ras
operator|.
name|bWidth
operator|=
operator|(
name|UShort
operator|)
name|ras
operator|.
name|target
operator|.
name|width
expr_stmt|;
name|ras
operator|.
name|bTarget
operator|=
operator|(
name|Byte
operator|*
operator|)
name|ras
operator|.
name|target
operator|.
name|buffer
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|Render_Single_Pass
argument_list|(
name|RAS_VARS
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
comment|/* Horizontal Sweep */
if|if
condition|(
name|ras
operator|.
name|second_pass
operator|&&
name|ras
operator|.
name|dropOutControl
operator|!=
literal|2
condition|)
block|{
name|FT_TRACE7
argument_list|(
operator|(
literal|"Horizontal pass (ftraster)\n"
operator|)
argument_list|)
expr_stmt|;
name|ras
operator|.
name|Proc_Sweep_Init
operator|=
name|Horizontal_Sweep_Init
expr_stmt|;
name|ras
operator|.
name|Proc_Sweep_Span
operator|=
name|Horizontal_Sweep_Span
expr_stmt|;
name|ras
operator|.
name|Proc_Sweep_Drop
operator|=
name|Horizontal_Sweep_Drop
expr_stmt|;
name|ras
operator|.
name|Proc_Sweep_Step
operator|=
name|Horizontal_Sweep_Step
expr_stmt|;
name|ras
operator|.
name|band_top
operator|=
literal|0
expr_stmt|;
name|ras
operator|.
name|band_stack
index|[
literal|0
index|]
operator|.
name|y_min
operator|=
literal|0
expr_stmt|;
name|ras
operator|.
name|band_stack
index|[
literal|0
index|]
operator|.
name|y_max
operator|=
call|(
name|Short
call|)
argument_list|(
name|ras
operator|.
name|target
operator|.
name|width
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|Render_Single_Pass
argument_list|(
name|RAS_VARS
literal|1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
block|}
return|return
name|Raster_Err_None
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|ft_black_init
name|ft_black_init
parameter_list|(
name|black_PRaster
name|raster
parameter_list|)
block|{
name|FT_UNUSED
argument_list|(
name|raster
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/**** RASTER OBJECT CREATION: In standalone mode, we simply use *****/
end_comment
begin_comment
comment|/****                         a static object.                  *****/
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|_STANDALONE_
end_ifdef
begin_function
specifier|static
name|int
DECL|function|ft_black_new
name|ft_black_new
parameter_list|(
name|void
modifier|*
name|memory
parameter_list|,
name|FT_Raster
modifier|*
name|araster
parameter_list|)
block|{
specifier|static
name|black_TRaster
name|the_raster
decl_stmt|;
name|FT_UNUSED
argument_list|(
name|memory
argument_list|)
expr_stmt|;
operator|*
name|araster
operator|=
operator|(
name|FT_Raster
operator|)
operator|&
name|the_raster
expr_stmt|;
name|FT_MEM_ZERO
argument_list|(
operator|&
name|the_raster
argument_list|,
sizeof|sizeof
argument_list|(
name|the_raster
argument_list|)
argument_list|)
expr_stmt|;
name|ft_black_init
argument_list|(
operator|&
name|the_raster
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|ft_black_done
name|ft_black_done
parameter_list|(
name|FT_Raster
name|raster
parameter_list|)
block|{
comment|/* nothing */
name|FT_UNUSED
argument_list|(
name|raster
argument_list|)
expr_stmt|;
block|}
end_function
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* !_STANDALONE_ */
end_comment
begin_function
specifier|static
name|int
DECL|function|ft_black_new
name|ft_black_new
parameter_list|(
name|FT_Memory
name|memory
parameter_list|,
name|black_PRaster
modifier|*
name|araster
parameter_list|)
block|{
name|FT_Error
name|error
decl_stmt|;
name|black_PRaster
name|raster
init|=
name|NULL
decl_stmt|;
operator|*
name|araster
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|FT_NEW
argument_list|(
name|raster
argument_list|)
condition|)
block|{
name|raster
operator|->
name|memory
operator|=
name|memory
expr_stmt|;
name|ft_black_init
argument_list|(
name|raster
argument_list|)
expr_stmt|;
operator|*
name|araster
operator|=
name|raster
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|ft_black_done
name|ft_black_done
parameter_list|(
name|black_PRaster
name|raster
parameter_list|)
block|{
name|FT_Memory
name|memory
init|=
operator|(
name|FT_Memory
operator|)
name|raster
operator|->
name|memory
decl_stmt|;
name|FT_FREE
argument_list|(
name|raster
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* !_STANDALONE_ */
end_comment
begin_function
specifier|static
name|void
DECL|function|ft_black_reset
name|ft_black_reset
parameter_list|(
name|black_PRaster
name|raster
parameter_list|,
name|char
modifier|*
name|pool_base
parameter_list|,
name|Long
name|pool_size
parameter_list|)
block|{
name|FT_UNUSED
argument_list|(
name|raster
argument_list|)
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|pool_base
argument_list|)
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|pool_size
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|ft_black_set_mode
name|ft_black_set_mode
parameter_list|(
name|black_PRaster
name|raster
parameter_list|,
name|ULong
name|mode
parameter_list|,
specifier|const
name|char
modifier|*
name|palette
parameter_list|)
block|{
name|FT_UNUSED
argument_list|(
name|raster
argument_list|)
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|palette
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|ft_black_render
name|ft_black_render
parameter_list|(
name|black_PRaster
name|raster
parameter_list|,
specifier|const
name|FT_Raster_Params
modifier|*
name|params
parameter_list|)
block|{
specifier|const
name|FT_Outline
modifier|*
name|outline
init|=
operator|(
specifier|const
name|FT_Outline
operator|*
operator|)
name|params
operator|->
name|source
decl_stmt|;
specifier|const
name|FT_Bitmap
modifier|*
name|target_map
init|=
name|params
operator|->
name|target
decl_stmt|;
name|black_TWorker
name|worker
index|[
literal|1
index|]
decl_stmt|;
name|Long
name|buffer
index|[
name|FT_MAX
argument_list|(
name|FT_RENDER_POOL_SIZE
argument_list|,
literal|2048
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|Long
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|raster
condition|)
return|return
name|FT_THROW
argument_list|(
name|Not_Ini
argument_list|)
return|;
if|if
condition|(
operator|!
name|outline
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid
argument_list|)
return|;
comment|/* return immediately if the outline is empty */
if|if
condition|(
name|outline
operator|->
name|n_points
operator|==
literal|0
operator|||
name|outline
operator|->
name|n_contours
operator|<=
literal|0
condition|)
return|return
name|Raster_Err_None
return|;
if|if
condition|(
operator|!
name|outline
operator|->
name|contours
operator|||
operator|!
name|outline
operator|->
name|points
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid
argument_list|)
return|;
if|if
condition|(
name|outline
operator|->
name|n_points
operator|!=
name|outline
operator|->
name|contours
index|[
name|outline
operator|->
name|n_contours
operator|-
literal|1
index|]
operator|+
literal|1
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid
argument_list|)
return|;
comment|/* this version of the raster does not support direct rendering, sorry */
if|if
condition|(
name|params
operator|->
name|flags
operator|&
name|FT_RASTER_FLAG_DIRECT
condition|)
return|return
name|FT_THROW
argument_list|(
name|Unsupported
argument_list|)
return|;
if|if
condition|(
name|params
operator|->
name|flags
operator|&
name|FT_RASTER_FLAG_AA
condition|)
return|return
name|FT_THROW
argument_list|(
name|Unsupported
argument_list|)
return|;
if|if
condition|(
operator|!
name|target_map
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid
argument_list|)
return|;
comment|/* nothing to do */
if|if
condition|(
operator|!
name|target_map
operator|->
name|width
operator|||
operator|!
name|target_map
operator|->
name|rows
condition|)
return|return
name|Raster_Err_None
return|;
if|if
condition|(
operator|!
name|target_map
operator|->
name|buffer
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid
argument_list|)
return|;
name|ras
operator|.
name|outline
operator|=
operator|*
name|outline
expr_stmt|;
name|ras
operator|.
name|target
operator|=
operator|*
name|target_map
expr_stmt|;
name|worker
operator|->
name|buff
operator|=
name|buffer
expr_stmt|;
name|worker
operator|->
name|sizeBuff
operator|=
operator|(
operator|&
name|buffer
operator|)
index|[
literal|1
index|]
expr_stmt|;
comment|/* Points to right after buffer. */
return|return
name|Render_Glyph
argument_list|(
name|RAS_VAR
argument_list|)
return|;
block|}
end_function
begin_macro
name|FT_DEFINE_RASTER_FUNCS
argument_list|(
argument|ft_standard_raster
argument_list|,
argument|FT_GLYPH_FORMAT_OUTLINE
argument_list|,
argument|(FT_Raster_New_Func)     ft_black_new
argument_list|,
argument|(FT_Raster_Reset_Func)   ft_black_reset
argument_list|,
argument|(FT_Raster_Set_Mode_Func)ft_black_set_mode
argument_list|,
argument|(FT_Raster_Render_Func)  ft_black_render
argument_list|,
argument|(FT_Raster_Done_Func)    ft_black_done
argument_list|)
end_macro
begin_comment
comment|/* END */
end_comment
end_unit
