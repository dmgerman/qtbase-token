begin_unit
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  psobjs.c                                                               */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*    Auxiliary functions for PostScript fonts (body).                     */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 by */
end_comment
begin_comment
comment|/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  This file is part of the FreeType project, and may only be used,       */
end_comment
begin_comment
comment|/*  modified, and distributed under the terms of the FreeType project      */
end_comment
begin_comment
comment|/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
end_comment
begin_comment
comment|/*  this file you indicate that you have read the license and              */
end_comment
begin_comment
comment|/*  understand and accept it fully.                                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<ft2build.h>
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_POSTSCRIPT_AUX_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_DEBUG_H
end_include
begin_include
include|#
directive|include
file|"psobjs.h"
end_include
begin_include
include|#
directive|include
file|"psconv.h"
end_include
begin_include
include|#
directive|include
file|"psauxerr.h"
end_include
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
end_comment
begin_comment
comment|/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
end_comment
begin_comment
comment|/* messages during execution.                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_undef
DECL|macro|FT_COMPONENT
undef|#
directive|undef
name|FT_COMPONENT
end_undef
begin_define
DECL|macro|FT_COMPONENT
define|#
directive|define
name|FT_COMPONENT
value|trace_psobjs
end_define
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****                             PS_TABLE                          *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    ps_table_new                                                       */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Initializes a PS_Table.                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<InOut>                                                               */
end_comment
begin_comment
comment|/*    table  :: The address of the target table.                         */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    count  :: The table size = the maximum number of elements.         */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    memory :: The memory object to use for all subsequent              */
end_comment
begin_comment
comment|/*              reallocations.                                           */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    FreeType error code.  0 means success.                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|ps_table_new
argument_list|(
argument|PS_Table   table
argument_list|,
argument|FT_Int     count
argument_list|,
argument|FT_Memory  memory
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
decl_stmt|;
name|table
operator|->
name|memory
operator|=
name|memory
expr_stmt|;
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|table
operator|->
name|elements
argument_list|,
name|count
argument_list|)
operator|||
name|FT_NEW_ARRAY
argument_list|(
name|table
operator|->
name|lengths
argument_list|,
name|count
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|table
operator|->
name|max_elems
operator|=
name|count
expr_stmt|;
name|table
operator|->
name|init
operator|=
literal|0xDEADBEEFUL
expr_stmt|;
name|table
operator|->
name|num_elems
operator|=
literal|0
expr_stmt|;
name|table
operator|->
name|block
operator|=
literal|0
expr_stmt|;
name|table
operator|->
name|capacity
operator|=
literal|0
expr_stmt|;
name|table
operator|->
name|cursor
operator|=
literal|0
expr_stmt|;
operator|*
operator|(
name|PS_Table_FuncsRec
operator|*
operator|)
operator|&
name|table
operator|->
name|funcs
operator|=
name|ps_table_funcs
expr_stmt|;
name|Exit
label|:
if|if
condition|(
name|error
condition|)
name|FT_FREE
argument_list|(
name|table
operator|->
name|elements
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_block
begin_function
specifier|static
name|void
DECL|function|shift_elements
name|shift_elements
parameter_list|(
name|PS_Table
name|table
parameter_list|,
name|FT_Byte
modifier|*
name|old_base
parameter_list|)
block|{
name|FT_PtrDist
name|delta
init|=
name|table
operator|->
name|block
operator|-
name|old_base
decl_stmt|;
name|FT_Byte
modifier|*
modifier|*
name|offset
init|=
name|table
operator|->
name|elements
decl_stmt|;
name|FT_Byte
modifier|*
modifier|*
name|limit
init|=
name|offset
operator|+
name|table
operator|->
name|max_elems
decl_stmt|;
for|for
control|(
init|;
name|offset
operator|<
name|limit
condition|;
name|offset
operator|++
control|)
block|{
if|if
condition|(
name|offset
index|[
literal|0
index|]
condition|)
name|offset
index|[
literal|0
index|]
operator|+=
name|delta
expr_stmt|;
block|}
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|reallocate_t1_table
name|reallocate_t1_table
parameter_list|(
name|PS_Table
name|table
parameter_list|,
name|FT_Long
name|new_size
parameter_list|)
block|{
name|FT_Memory
name|memory
init|=
name|table
operator|->
name|memory
decl_stmt|;
name|FT_Byte
modifier|*
name|old_base
init|=
name|table
operator|->
name|block
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
comment|/* allocate new base block */
if|if
condition|(
name|FT_ALLOC
argument_list|(
name|table
operator|->
name|block
argument_list|,
name|new_size
argument_list|)
condition|)
block|{
name|table
operator|->
name|block
operator|=
name|old_base
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* copy elements and shift offsets */
if|if
condition|(
name|old_base
condition|)
block|{
name|FT_MEM_COPY
argument_list|(
name|table
operator|->
name|block
argument_list|,
name|old_base
argument_list|,
name|table
operator|->
name|capacity
argument_list|)
expr_stmt|;
name|shift_elements
argument_list|(
name|table
argument_list|,
name|old_base
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|old_base
argument_list|)
expr_stmt|;
block|}
name|table
operator|->
name|capacity
operator|=
name|new_size
expr_stmt|;
return|return
name|PSaux_Err_Ok
return|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    ps_table_add                                                       */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Adds an object to a PS_Table, possibly growing its memory block.   */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<InOut>                                                               */
end_comment
begin_comment
comment|/*    table  :: The target table.                                        */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    idx    :: The index of the object in the table.                    */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    object :: The address of the object to copy in memory.             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    length :: The length in bytes of the source object.                */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    FreeType error code.  0 means success.  An error is returned if a  */
end_comment
begin_comment
comment|/*    reallocation fails.                                                */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|ps_table_add
argument_list|(
argument|PS_Table    table
argument_list|,
argument|FT_Int      idx
argument_list|,
argument|void*       object
argument_list|,
argument|FT_PtrDist  length
argument_list|)
end_macro
begin_block
block|{
if|if
condition|(
name|idx
operator|<
literal|0
operator|||
name|idx
operator|>=
name|table
operator|->
name|max_elems
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"ps_table_add: invalid index\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|PSaux_Err_Invalid_Argument
return|;
block|}
if|if
condition|(
name|length
operator|<
literal|0
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"ps_table_add: invalid length\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|PSaux_Err_Invalid_Argument
return|;
block|}
comment|/* grow the base block if needed */
if|if
condition|(
name|table
operator|->
name|cursor
operator|+
name|length
operator|>
name|table
operator|->
name|capacity
condition|)
block|{
name|FT_Error
name|error
decl_stmt|;
name|FT_Offset
name|new_size
init|=
name|table
operator|->
name|capacity
decl_stmt|;
name|FT_Long
name|in_offset
decl_stmt|;
name|in_offset
operator|=
call|(
name|FT_Long
call|)
argument_list|(
operator|(
name|FT_Byte
operator|*
operator|)
name|object
operator|-
name|table
operator|->
name|block
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|FT_ULong
operator|)
name|in_offset
operator|>=
name|table
operator|->
name|capacity
condition|)
name|in_offset
operator|=
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|new_size
operator|<
name|table
operator|->
name|cursor
operator|+
name|length
condition|)
block|{
comment|/* increase size by 25% and round up to the nearest multiple            of 1024 */
name|new_size
operator|+=
operator|(
name|new_size
operator|>>
literal|2
operator|)
operator|+
literal|1
expr_stmt|;
name|new_size
operator|=
name|FT_PAD_CEIL
argument_list|(
name|new_size
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|reallocate_t1_table
argument_list|(
name|table
argument_list|,
name|new_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
name|in_offset
operator|>=
literal|0
condition|)
name|object
operator|=
name|table
operator|->
name|block
operator|+
name|in_offset
expr_stmt|;
block|}
comment|/* add the object to the base block and adjust offset */
name|table
operator|->
name|elements
index|[
name|idx
index|]
operator|=
name|table
operator|->
name|block
operator|+
name|table
operator|->
name|cursor
expr_stmt|;
name|table
operator|->
name|lengths
index|[
name|idx
index|]
operator|=
name|length
expr_stmt|;
name|FT_MEM_COPY
argument_list|(
name|table
operator|->
name|block
operator|+
name|table
operator|->
name|cursor
argument_list|,
name|object
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|table
operator|->
name|cursor
operator|+=
name|length
expr_stmt|;
return|return
name|PSaux_Err_Ok
return|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    ps_table_done                                                      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Finalizes a PS_TableRec (i.e., reallocate it to its current        */
end_comment
begin_comment
comment|/*    cursor).                                                           */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<InOut>                                                               */
end_comment
begin_comment
comment|/*    table :: The target table.                                         */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Note>                                                                */
end_comment
begin_comment
comment|/*    This function does NOT release the heap's memory block.  It is up  */
end_comment
begin_comment
comment|/*    to the caller to clean it, or reference it in its own structures.  */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|ps_table_done
name|ps_table_done
argument_list|(
argument|PS_Table  table
argument_list|)
end_macro
begin_block
block|{
name|FT_Memory
name|memory
init|=
name|table
operator|->
name|memory
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|FT_Byte
modifier|*
name|old_base
init|=
name|table
operator|->
name|block
decl_stmt|;
comment|/* should never fail, because rec.cursor<= rec.size */
if|if
condition|(
operator|!
name|old_base
condition|)
return|return;
if|if
condition|(
name|FT_ALLOC
argument_list|(
name|table
operator|->
name|block
argument_list|,
name|table
operator|->
name|cursor
argument_list|)
condition|)
return|return;
name|FT_MEM_COPY
argument_list|(
name|table
operator|->
name|block
argument_list|,
name|old_base
argument_list|,
name|table
operator|->
name|cursor
argument_list|)
expr_stmt|;
name|shift_elements
argument_list|(
name|table
argument_list|,
name|old_base
argument_list|)
expr_stmt|;
name|table
operator|->
name|capacity
operator|=
name|table
operator|->
name|cursor
expr_stmt|;
name|FT_FREE
argument_list|(
name|old_base
argument_list|)
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
end_block
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|ps_table_release
name|ps_table_release
argument_list|(
argument|PS_Table  table
argument_list|)
end_macro
begin_block
block|{
name|FT_Memory
name|memory
init|=
name|table
operator|->
name|memory
decl_stmt|;
if|if
condition|(
operator|(
name|FT_ULong
operator|)
name|table
operator|->
name|init
operator|==
literal|0xDEADBEEFUL
condition|)
block|{
name|FT_FREE
argument_list|(
name|table
operator|->
name|block
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|table
operator|->
name|elements
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|table
operator|->
name|lengths
argument_list|)
expr_stmt|;
name|table
operator|->
name|init
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****                            T1 PARSER                          *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/* first character must be already part of the comment */
end_comment
begin_function
specifier|static
name|void
DECL|function|skip_comment
name|skip_comment
parameter_list|(
name|FT_Byte
modifier|*
modifier|*
name|acur
parameter_list|,
name|FT_Byte
modifier|*
name|limit
parameter_list|)
block|{
name|FT_Byte
modifier|*
name|cur
init|=
operator|*
name|acur
decl_stmt|;
while|while
condition|(
name|cur
operator|<
name|limit
condition|)
block|{
if|if
condition|(
name|IS_PS_NEWLINE
argument_list|(
operator|*
name|cur
argument_list|)
condition|)
break|break;
name|cur
operator|++
expr_stmt|;
block|}
operator|*
name|acur
operator|=
name|cur
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|skip_spaces
name|skip_spaces
parameter_list|(
name|FT_Byte
modifier|*
modifier|*
name|acur
parameter_list|,
name|FT_Byte
modifier|*
name|limit
parameter_list|)
block|{
name|FT_Byte
modifier|*
name|cur
init|=
operator|*
name|acur
decl_stmt|;
while|while
condition|(
name|cur
operator|<
name|limit
condition|)
block|{
if|if
condition|(
operator|!
name|IS_PS_SPACE
argument_list|(
operator|*
name|cur
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|cur
operator|==
literal|'%'
condition|)
comment|/* According to the PLRM, a comment is equal to a space. */
name|skip_comment
argument_list|(
operator|&
name|cur
argument_list|,
name|limit
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
name|cur
operator|++
expr_stmt|;
block|}
operator|*
name|acur
operator|=
name|cur
expr_stmt|;
block|}
end_function
begin_define
DECL|macro|IS_OCTAL_DIGIT
define|#
directive|define
name|IS_OCTAL_DIGIT
parameter_list|(
name|c
parameter_list|)
value|( '0'<= (c)&& (c)<= '7' )
end_define
begin_comment
comment|/* first character must be `(';                               */
end_comment
begin_comment
comment|/* *acur is positioned at the character after the closing `)' */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|skip_literal_string
name|skip_literal_string
parameter_list|(
name|FT_Byte
modifier|*
modifier|*
name|acur
parameter_list|,
name|FT_Byte
modifier|*
name|limit
parameter_list|)
block|{
name|FT_Byte
modifier|*
name|cur
init|=
operator|*
name|acur
decl_stmt|;
name|FT_Int
name|embed
init|=
literal|0
decl_stmt|;
name|FT_Error
name|error
init|=
name|PSaux_Err_Invalid_File_Format
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
while|while
condition|(
name|cur
operator|<
name|limit
condition|)
block|{
name|FT_Byte
name|c
init|=
operator|*
name|cur
decl_stmt|;
operator|++
name|cur
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
comment|/* Red Book 3rd ed., section `Literal Text Strings', p. 29:     */
comment|/* A backslash can introduce three different types              */
comment|/* of escape sequences:                                         */
comment|/*   - a special escaped char like \r, \n, etc.                 */
comment|/*   - a one-, two-, or three-digit octal number                */
comment|/*   - none of the above in which case the backslash is ignored */
if|if
condition|(
name|cur
operator|==
name|limit
condition|)
comment|/* error (or to be ignored?) */
break|break;
switch|switch
condition|(
operator|*
name|cur
condition|)
block|{
comment|/* skip `special' escape */
case|case
literal|'n'
case|:
case|case
literal|'r'
case|:
case|case
literal|'t'
case|:
case|case
literal|'b'
case|:
case|case
literal|'f'
case|:
case|case
literal|'\\'
case|:
case|case
literal|'('
case|:
case|case
literal|')'
case|:
operator|++
name|cur
expr_stmt|;
break|break;
default|default:
comment|/* skip octal escape or ignore backslash */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
operator|&&
name|cur
operator|<
name|limit
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|IS_OCTAL_DIGIT
argument_list|(
operator|*
name|cur
argument_list|)
condition|)
break|break;
operator|++
name|cur
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'('
condition|)
name|embed
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|')'
condition|)
block|{
name|embed
operator|--
expr_stmt|;
if|if
condition|(
name|embed
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|PSaux_Err_Ok
expr_stmt|;
break|break;
block|}
block|}
block|}
operator|*
name|acur
operator|=
name|cur
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_comment
comment|/* first character must be `<' */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|skip_string
name|skip_string
parameter_list|(
name|FT_Byte
modifier|*
modifier|*
name|acur
parameter_list|,
name|FT_Byte
modifier|*
name|limit
parameter_list|)
block|{
name|FT_Byte
modifier|*
name|cur
init|=
operator|*
name|acur
decl_stmt|;
name|FT_Error
name|err
init|=
name|PSaux_Err_Ok
decl_stmt|;
while|while
condition|(
operator|++
name|cur
operator|<
name|limit
condition|)
block|{
comment|/* All whitespace characters are ignored. */
name|skip_spaces
argument_list|(
operator|&
name|cur
argument_list|,
name|limit
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur
operator|>=
name|limit
condition|)
break|break;
if|if
condition|(
operator|!
name|IS_PS_XDIGIT
argument_list|(
operator|*
name|cur
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|cur
operator|<
name|limit
operator|&&
operator|*
name|cur
operator|!=
literal|'>'
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"skip_string: missing closing delimiter `>'\n"
operator|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|PSaux_Err_Invalid_File_Format
expr_stmt|;
block|}
else|else
name|cur
operator|++
expr_stmt|;
operator|*
name|acur
operator|=
name|cur
expr_stmt|;
return|return
name|err
return|;
block|}
end_function
begin_comment
comment|/* first character must be the opening brace that */
end_comment
begin_comment
comment|/* starts the procedure                           */
end_comment
begin_comment
comment|/* NB: [ and ] need not match:                    */
end_comment
begin_comment
comment|/* `/foo {[} def' is a valid PostScript fragment, */
end_comment
begin_comment
comment|/* even within a Type1 font                       */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|skip_procedure
name|skip_procedure
parameter_list|(
name|FT_Byte
modifier|*
modifier|*
name|acur
parameter_list|,
name|FT_Byte
modifier|*
name|limit
parameter_list|)
block|{
name|FT_Byte
modifier|*
name|cur
decl_stmt|;
name|FT_Int
name|embed
init|=
literal|0
decl_stmt|;
name|FT_Error
name|error
init|=
name|PSaux_Err_Ok
decl_stmt|;
name|FT_ASSERT
argument_list|(
operator|*
operator|*
name|acur
operator|==
literal|'{'
argument_list|)
expr_stmt|;
for|for
control|(
name|cur
operator|=
operator|*
name|acur
init|;
name|cur
operator|<
name|limit
operator|&&
name|error
operator|==
name|PSaux_Err_Ok
condition|;
operator|++
name|cur
control|)
block|{
switch|switch
condition|(
operator|*
name|cur
condition|)
block|{
case|case
literal|'{'
case|:
operator|++
name|embed
expr_stmt|;
break|break;
case|case
literal|'}'
case|:
operator|--
name|embed
expr_stmt|;
if|if
condition|(
name|embed
operator|==
literal|0
condition|)
block|{
operator|++
name|cur
expr_stmt|;
goto|goto
name|end
goto|;
block|}
break|break;
case|case
literal|'('
case|:
name|error
operator|=
name|skip_literal_string
argument_list|(
operator|&
name|cur
argument_list|,
name|limit
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
name|error
operator|=
name|skip_string
argument_list|(
operator|&
name|cur
argument_list|,
name|limit
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'%'
case|:
name|skip_comment
argument_list|(
operator|&
name|cur
argument_list|,
name|limit
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|end
label|:
if|if
condition|(
name|embed
operator|!=
literal|0
condition|)
name|error
operator|=
name|PSaux_Err_Invalid_File_Format
expr_stmt|;
operator|*
name|acur
operator|=
name|cur
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_comment
comment|/***********************************************************************/
end_comment
begin_comment
comment|/*                                                                     */
end_comment
begin_comment
comment|/* All exported parsing routines handle leading whitespace and stop at */
end_comment
begin_comment
comment|/* the first character which isn't part of the just handled token.     */
end_comment
begin_comment
comment|/*                                                                     */
end_comment
begin_comment
comment|/***********************************************************************/
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|ps_parser_skip_PS_token
name|ps_parser_skip_PS_token
argument_list|(
argument|PS_Parser  parser
argument_list|)
end_macro
begin_block
block|{
comment|/* Note: PostScript allows any non-delimiting, non-whitespace        */
comment|/*       character in a name (PS Ref Manual, 3rd ed, p31).           */
comment|/*       PostScript delimiters are (, ),<,>, [, ], {, }, /, and %. */
name|FT_Byte
modifier|*
name|cur
init|=
name|parser
operator|->
name|cursor
decl_stmt|;
name|FT_Byte
modifier|*
name|limit
init|=
name|parser
operator|->
name|limit
decl_stmt|;
name|FT_Error
name|error
init|=
name|PSaux_Err_Ok
decl_stmt|;
name|skip_spaces
argument_list|(
operator|&
name|cur
argument_list|,
name|limit
argument_list|)
expr_stmt|;
comment|/* this also skips comments */
if|if
condition|(
name|cur
operator|>=
name|limit
condition|)
goto|goto
name|Exit
goto|;
comment|/* self-delimiting, single-character tokens */
if|if
condition|(
operator|*
name|cur
operator|==
literal|'['
operator|||
operator|*
name|cur
operator|==
literal|']'
condition|)
block|{
name|cur
operator|++
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* skip balanced expressions (procedures and strings) */
if|if
condition|(
operator|*
name|cur
operator|==
literal|'{'
condition|)
comment|/* {...} */
block|{
name|error
operator|=
name|skip_procedure
argument_list|(
operator|&
name|cur
argument_list|,
name|limit
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
operator|*
name|cur
operator|==
literal|'('
condition|)
comment|/* (...) */
block|{
name|error
operator|=
name|skip_literal_string
argument_list|(
operator|&
name|cur
argument_list|,
name|limit
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
operator|*
name|cur
operator|==
literal|'<'
condition|)
comment|/*<...> */
block|{
if|if
condition|(
name|cur
operator|+
literal|1
operator|<
name|limit
operator|&&
operator|*
operator|(
name|cur
operator|+
literal|1
operator|)
operator|==
literal|'<'
condition|)
comment|/*<< */
block|{
name|cur
operator|++
expr_stmt|;
name|cur
operator|++
expr_stmt|;
block|}
else|else
name|error
operator|=
name|skip_string
argument_list|(
operator|&
name|cur
argument_list|,
name|limit
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
operator|*
name|cur
operator|==
literal|'>'
condition|)
block|{
name|cur
operator|++
expr_stmt|;
if|if
condition|(
name|cur
operator|>=
name|limit
operator|||
operator|*
name|cur
operator|!=
literal|'>'
condition|)
comment|/*>> */
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"ps_parser_skip_PS_token: "
literal|"unexpected closing delimiter `>'\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|PSaux_Err_Invalid_File_Format
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|cur
operator|++
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
operator|*
name|cur
operator|==
literal|'/'
condition|)
name|cur
operator|++
expr_stmt|;
comment|/* anything else */
while|while
condition|(
name|cur
operator|<
name|limit
condition|)
block|{
comment|/* *cur might be invalid (e.g., ')' or '}'), but this   */
comment|/* is handled by the test `cur == parser->cursor' below */
if|if
condition|(
name|IS_PS_DELIM
argument_list|(
operator|*
name|cur
argument_list|)
condition|)
break|break;
name|cur
operator|++
expr_stmt|;
block|}
name|Exit
label|:
if|if
condition|(
name|cur
operator|==
name|parser
operator|->
name|cursor
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"ps_parser_skip_PS_token: "
literal|"current token is `%c', which is self-delimiting "
literal|"but invalid at this point\n"
operator|,
operator|*
name|cur
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|PSaux_Err_Invalid_File_Format
expr_stmt|;
block|}
name|parser
operator|->
name|error
operator|=
name|error
expr_stmt|;
name|parser
operator|->
name|cursor
operator|=
name|cur
expr_stmt|;
block|}
end_block
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|ps_parser_skip_spaces
name|ps_parser_skip_spaces
argument_list|(
argument|PS_Parser  parser
argument_list|)
end_macro
begin_block
block|{
name|skip_spaces
argument_list|(
operator|&
name|parser
operator|->
name|cursor
argument_list|,
name|parser
operator|->
name|limit
argument_list|)
expr_stmt|;
block|}
end_block
begin_comment
comment|/* `token' here means either something between balanced delimiters */
end_comment
begin_comment
comment|/* or the next token; the delimiters are not removed.              */
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|ps_parser_to_token
name|ps_parser_to_token
argument_list|(
argument|PS_Parser  parser
argument_list|,
argument|T1_Token   token
argument_list|)
end_macro
begin_block
block|{
name|FT_Byte
modifier|*
name|cur
decl_stmt|;
name|FT_Byte
modifier|*
name|limit
decl_stmt|;
name|FT_Int
name|embed
decl_stmt|;
name|token
operator|->
name|type
operator|=
name|T1_TOKEN_TYPE_NONE
expr_stmt|;
name|token
operator|->
name|start
operator|=
literal|0
expr_stmt|;
name|token
operator|->
name|limit
operator|=
literal|0
expr_stmt|;
comment|/* first of all, skip leading whitespace */
name|ps_parser_skip_spaces
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|cur
operator|=
name|parser
operator|->
name|cursor
expr_stmt|;
name|limit
operator|=
name|parser
operator|->
name|limit
expr_stmt|;
if|if
condition|(
name|cur
operator|>=
name|limit
condition|)
return|return;
switch|switch
condition|(
operator|*
name|cur
condition|)
block|{
comment|/************* check for literal string *****************/
case|case
literal|'('
case|:
name|token
operator|->
name|type
operator|=
name|T1_TOKEN_TYPE_STRING
expr_stmt|;
name|token
operator|->
name|start
operator|=
name|cur
expr_stmt|;
if|if
condition|(
name|skip_literal_string
argument_list|(
operator|&
name|cur
argument_list|,
name|limit
argument_list|)
operator|==
name|PSaux_Err_Ok
condition|)
name|token
operator|->
name|limit
operator|=
name|cur
expr_stmt|;
break|break;
comment|/************* check for programs/array *****************/
case|case
literal|'{'
case|:
name|token
operator|->
name|type
operator|=
name|T1_TOKEN_TYPE_ARRAY
expr_stmt|;
name|token
operator|->
name|start
operator|=
name|cur
expr_stmt|;
if|if
condition|(
name|skip_procedure
argument_list|(
operator|&
name|cur
argument_list|,
name|limit
argument_list|)
operator|==
name|PSaux_Err_Ok
condition|)
name|token
operator|->
name|limit
operator|=
name|cur
expr_stmt|;
break|break;
comment|/************* check for table/array ********************/
comment|/* XXX: in theory we should also look for "<<"          */
comment|/*      since this is semantically equivalent to "[";   */
comment|/*      in practice it doesn't matter (?)               */
case|case
literal|'['
case|:
name|token
operator|->
name|type
operator|=
name|T1_TOKEN_TYPE_ARRAY
expr_stmt|;
name|embed
operator|=
literal|1
expr_stmt|;
name|token
operator|->
name|start
operator|=
name|cur
operator|++
expr_stmt|;
comment|/* we need this to catch `[ ]' */
name|parser
operator|->
name|cursor
operator|=
name|cur
expr_stmt|;
name|ps_parser_skip_spaces
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|cur
operator|=
name|parser
operator|->
name|cursor
expr_stmt|;
while|while
condition|(
name|cur
operator|<
name|limit
operator|&&
operator|!
name|parser
operator|->
name|error
condition|)
block|{
comment|/* XXX: this is wrong because it does not      */
comment|/*      skip comments, procedures, and strings */
if|if
condition|(
operator|*
name|cur
operator|==
literal|'['
condition|)
name|embed
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|cur
operator|==
literal|']'
condition|)
block|{
name|embed
operator|--
expr_stmt|;
if|if
condition|(
name|embed
operator|<=
literal|0
condition|)
block|{
name|token
operator|->
name|limit
operator|=
operator|++
name|cur
expr_stmt|;
break|break;
block|}
block|}
name|parser
operator|->
name|cursor
operator|=
name|cur
expr_stmt|;
name|ps_parser_skip_PS_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* we need this to catch `[XXX ]' */
name|ps_parser_skip_spaces
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|cur
operator|=
name|parser
operator|->
name|cursor
expr_stmt|;
block|}
break|break;
comment|/* ************ otherwise, it is any token **************/
default|default:
name|token
operator|->
name|start
operator|=
name|cur
expr_stmt|;
name|token
operator|->
name|type
operator|=
operator|(
operator|*
name|cur
operator|==
literal|'/'
condition|?
name|T1_TOKEN_TYPE_KEY
else|:
name|T1_TOKEN_TYPE_ANY
operator|)
expr_stmt|;
name|ps_parser_skip_PS_token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|cur
operator|=
name|parser
operator|->
name|cursor
expr_stmt|;
if|if
condition|(
operator|!
name|parser
operator|->
name|error
condition|)
name|token
operator|->
name|limit
operator|=
name|cur
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|token
operator|->
name|limit
condition|)
block|{
name|token
operator|->
name|start
operator|=
literal|0
expr_stmt|;
name|token
operator|->
name|type
operator|=
name|T1_TOKEN_TYPE_NONE
expr_stmt|;
block|}
name|parser
operator|->
name|cursor
operator|=
name|cur
expr_stmt|;
block|}
end_block
begin_comment
comment|/* NB: `tokens' can be NULL if we only want to count */
end_comment
begin_comment
comment|/* the number of array elements                      */
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|ps_parser_to_token_array
name|ps_parser_to_token_array
argument_list|(
argument|PS_Parser  parser
argument_list|,
argument|T1_Token   tokens
argument_list|,
argument|FT_UInt    max_tokens
argument_list|,
argument|FT_Int*    pnum_tokens
argument_list|)
end_macro
begin_block
block|{
name|T1_TokenRec
name|master
decl_stmt|;
operator|*
name|pnum_tokens
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* this also handles leading whitespace */
name|ps_parser_to_token
argument_list|(
name|parser
argument_list|,
operator|&
name|master
argument_list|)
expr_stmt|;
if|if
condition|(
name|master
operator|.
name|type
operator|==
name|T1_TOKEN_TYPE_ARRAY
condition|)
block|{
name|FT_Byte
modifier|*
name|old_cursor
init|=
name|parser
operator|->
name|cursor
decl_stmt|;
name|FT_Byte
modifier|*
name|old_limit
init|=
name|parser
operator|->
name|limit
decl_stmt|;
name|T1_Token
name|cur
init|=
name|tokens
decl_stmt|;
name|T1_Token
name|limit
init|=
name|cur
operator|+
name|max_tokens
decl_stmt|;
comment|/* don't include outermost delimiters */
name|parser
operator|->
name|cursor
operator|=
name|master
operator|.
name|start
operator|+
literal|1
expr_stmt|;
name|parser
operator|->
name|limit
operator|=
name|master
operator|.
name|limit
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|parser
operator|->
name|cursor
operator|<
name|parser
operator|->
name|limit
condition|)
block|{
name|T1_TokenRec
name|token
decl_stmt|;
name|ps_parser_to_token
argument_list|(
name|parser
argument_list|,
operator|&
name|token
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|token
operator|.
name|type
condition|)
break|break;
if|if
condition|(
name|tokens
operator|!=
name|NULL
operator|&&
name|cur
operator|<
name|limit
condition|)
operator|*
name|cur
operator|=
name|token
expr_stmt|;
name|cur
operator|++
expr_stmt|;
block|}
operator|*
name|pnum_tokens
operator|=
call|(
name|FT_Int
call|)
argument_list|(
name|cur
operator|-
name|tokens
argument_list|)
expr_stmt|;
name|parser
operator|->
name|cursor
operator|=
name|old_cursor
expr_stmt|;
name|parser
operator|->
name|limit
operator|=
name|old_limit
expr_stmt|;
block|}
block|}
end_block
begin_comment
comment|/* first character must be a delimiter or a part of a number */
end_comment
begin_comment
comment|/* NB: `coords' can be NULL if we just want to skip the      */
end_comment
begin_comment
comment|/*     array; in this case we ignore `max_coords'            */
end_comment
begin_function
specifier|static
name|FT_Int
DECL|function|ps_tocoordarray
name|ps_tocoordarray
parameter_list|(
name|FT_Byte
modifier|*
modifier|*
name|acur
parameter_list|,
name|FT_Byte
modifier|*
name|limit
parameter_list|,
name|FT_Int
name|max_coords
parameter_list|,
name|FT_Short
modifier|*
name|coords
parameter_list|)
block|{
name|FT_Byte
modifier|*
name|cur
init|=
operator|*
name|acur
decl_stmt|;
name|FT_Int
name|count
init|=
literal|0
decl_stmt|;
name|FT_Byte
name|c
decl_stmt|,
name|ender
decl_stmt|;
if|if
condition|(
name|cur
operator|>=
name|limit
condition|)
goto|goto
name|Exit
goto|;
comment|/* check for the beginning of an array; otherwise, only one number */
comment|/* will be read                                                    */
name|c
operator|=
operator|*
name|cur
expr_stmt|;
name|ender
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'['
condition|)
name|ender
operator|=
literal|']'
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'{'
condition|)
name|ender
operator|=
literal|'}'
expr_stmt|;
if|if
condition|(
name|ender
condition|)
name|cur
operator|++
expr_stmt|;
comment|/* now, read the coordinates */
while|while
condition|(
name|cur
operator|<
name|limit
condition|)
block|{
name|FT_Short
name|dummy
decl_stmt|;
name|FT_Byte
modifier|*
name|old_cur
decl_stmt|;
comment|/* skip whitespace in front of data */
name|skip_spaces
argument_list|(
operator|&
name|cur
argument_list|,
name|limit
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur
operator|>=
name|limit
condition|)
goto|goto
name|Exit
goto|;
if|if
condition|(
operator|*
name|cur
operator|==
name|ender
condition|)
block|{
name|cur
operator|++
expr_stmt|;
break|break;
block|}
name|old_cur
operator|=
name|cur
expr_stmt|;
if|if
condition|(
name|coords
operator|!=
name|NULL
operator|&&
name|count
operator|>=
name|max_coords
condition|)
break|break;
comment|/* call PS_Conv_ToFixed() even if coords == NULL */
comment|/* to properly parse number at `cur'             */
operator|*
operator|(
name|coords
operator|!=
name|NULL
condition|?
operator|&
name|coords
index|[
name|count
index|]
else|:
operator|&
name|dummy
operator|)
operator|=
call|(
name|FT_Short
call|)
argument_list|(
name|PS_Conv_ToFixed
argument_list|(
operator|&
name|cur
argument_list|,
name|limit
argument_list|,
literal|0
argument_list|)
operator|>>
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_cur
operator|==
name|cur
condition|)
block|{
name|count
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
else|else
name|count
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|ender
condition|)
break|break;
block|}
name|Exit
label|:
operator|*
name|acur
operator|=
name|cur
expr_stmt|;
return|return
name|count
return|;
block|}
end_function
begin_comment
comment|/* first character must be a delimiter or a part of a number */
end_comment
begin_comment
comment|/* NB: `values' can be NULL if we just want to skip the      */
end_comment
begin_comment
comment|/*     array; in this case we ignore `max_values'            */
end_comment
begin_function
specifier|static
name|FT_Int
DECL|function|ps_tofixedarray
name|ps_tofixedarray
parameter_list|(
name|FT_Byte
modifier|*
modifier|*
name|acur
parameter_list|,
name|FT_Byte
modifier|*
name|limit
parameter_list|,
name|FT_Int
name|max_values
parameter_list|,
name|FT_Fixed
modifier|*
name|values
parameter_list|,
name|FT_Int
name|power_ten
parameter_list|)
block|{
name|FT_Byte
modifier|*
name|cur
init|=
operator|*
name|acur
decl_stmt|;
name|FT_Int
name|count
init|=
literal|0
decl_stmt|;
name|FT_Byte
name|c
decl_stmt|,
name|ender
decl_stmt|;
if|if
condition|(
name|cur
operator|>=
name|limit
condition|)
goto|goto
name|Exit
goto|;
comment|/* Check for the beginning of an array.  Otherwise, only one number */
comment|/* will be read.                                                    */
name|c
operator|=
operator|*
name|cur
expr_stmt|;
name|ender
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'['
condition|)
name|ender
operator|=
literal|']'
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'{'
condition|)
name|ender
operator|=
literal|'}'
expr_stmt|;
if|if
condition|(
name|ender
condition|)
name|cur
operator|++
expr_stmt|;
comment|/* now, read the values */
while|while
condition|(
name|cur
operator|<
name|limit
condition|)
block|{
name|FT_Fixed
name|dummy
decl_stmt|;
name|FT_Byte
modifier|*
name|old_cur
decl_stmt|;
comment|/* skip whitespace in front of data */
name|skip_spaces
argument_list|(
operator|&
name|cur
argument_list|,
name|limit
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur
operator|>=
name|limit
condition|)
goto|goto
name|Exit
goto|;
if|if
condition|(
operator|*
name|cur
operator|==
name|ender
condition|)
block|{
name|cur
operator|++
expr_stmt|;
break|break;
block|}
name|old_cur
operator|=
name|cur
expr_stmt|;
if|if
condition|(
name|values
operator|!=
name|NULL
operator|&&
name|count
operator|>=
name|max_values
condition|)
break|break;
comment|/* call PS_Conv_ToFixed() even if coords == NULL */
comment|/* to properly parse number at `cur'             */
operator|*
operator|(
name|values
operator|!=
name|NULL
condition|?
operator|&
name|values
index|[
name|count
index|]
else|:
operator|&
name|dummy
operator|)
operator|=
name|PS_Conv_ToFixed
argument_list|(
operator|&
name|cur
argument_list|,
name|limit
argument_list|,
name|power_ten
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_cur
operator|==
name|cur
condition|)
block|{
name|count
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
else|else
name|count
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|ender
condition|)
break|break;
block|}
name|Exit
label|:
operator|*
name|acur
operator|=
name|cur
expr_stmt|;
return|return
name|count
return|;
block|}
end_function
begin_if
if|#
directive|if
literal|0
end_if
begin_comment
unit|static FT_String*   ps_tostring( FT_Byte**  cursor,                FT_Byte*   limit,                FT_Memory  memory )   {     FT_Byte*    cur = *cursor;     FT_PtrDist  len = 0;     FT_Int      count;     FT_String*  result;     FT_Error    error;
comment|/* XXX: some stupid fonts have a `Notice' or `Copyright' string     */
end_comment
begin_comment
comment|/*      that simply doesn't begin with an opening parenthesis, even */
end_comment
begin_comment
comment|/*      though they have a closing one!  E.g. "amuncial.pfb"        */
end_comment
begin_comment
comment|/*                                                                  */
end_comment
begin_comment
comment|/*      We must deal with these ill-fated cases there.  Note that   */
end_comment
begin_comment
comment|/*      these fonts didn't work with the old Type 1 driver as the   */
end_comment
begin_comment
comment|/*      notice/copyright was not recognized as a valid string token */
end_comment
begin_comment
comment|/*      and made the old token parser commit errors.                */
end_comment
begin_comment
unit|while ( cur< limit&& ( *cur == ' ' || *cur == '\t' ) )       cur++;     if ( cur + 1>= limit )       return 0;      if ( *cur == '(' )       cur++;
comment|/* skip the opening parenthesis, if there is one */
end_comment
begin_comment
unit|*cursor = cur;     count   = 0;
comment|/* then, count its length */
end_comment
begin_comment
unit|for ( ; cur< limit; cur++ )     {       if ( *cur == '(' )         count++;        else if ( *cur == ')' )       {         count--;         if ( count< 0 )           break;       }     }      len = cur - *cursor;     if ( cur>= limit || FT_ALLOC( result, len + 1 ) )       return 0;
comment|/* now copy the string */
end_comment
begin_endif
unit|FT_MEM_COPY( result, *cursor, len );     result[len] = '\0';     *cursor = cur;     return result;   }
endif|#
directive|endif
end_endif
begin_comment
comment|/* 0 */
end_comment
begin_function
specifier|static
name|int
DECL|function|ps_tobool
name|ps_tobool
parameter_list|(
name|FT_Byte
modifier|*
modifier|*
name|acur
parameter_list|,
name|FT_Byte
modifier|*
name|limit
parameter_list|)
block|{
name|FT_Byte
modifier|*
name|cur
init|=
operator|*
name|acur
decl_stmt|;
name|FT_Bool
name|result
init|=
literal|0
decl_stmt|;
comment|/* return 1 if we find `true', 0 otherwise */
if|if
condition|(
name|cur
operator|+
literal|3
operator|<
name|limit
operator|&&
name|cur
index|[
literal|0
index|]
operator|==
literal|'t'
operator|&&
name|cur
index|[
literal|1
index|]
operator|==
literal|'r'
operator|&&
name|cur
index|[
literal|2
index|]
operator|==
literal|'u'
operator|&&
name|cur
index|[
literal|3
index|]
operator|==
literal|'e'
condition|)
block|{
name|result
operator|=
literal|1
expr_stmt|;
name|cur
operator|+=
literal|5
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cur
operator|+
literal|4
operator|<
name|limit
operator|&&
name|cur
index|[
literal|0
index|]
operator|==
literal|'f'
operator|&&
name|cur
index|[
literal|1
index|]
operator|==
literal|'a'
operator|&&
name|cur
index|[
literal|2
index|]
operator|==
literal|'l'
operator|&&
name|cur
index|[
literal|3
index|]
operator|==
literal|'s'
operator|&&
name|cur
index|[
literal|4
index|]
operator|==
literal|'e'
condition|)
block|{
name|result
operator|=
literal|0
expr_stmt|;
name|cur
operator|+=
literal|6
expr_stmt|;
block|}
operator|*
name|acur
operator|=
name|cur
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/* load a simple field (i.e. non-table) into the current list of objects */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|ps_parser_load_field
argument_list|(
argument|PS_Parser       parser
argument_list|,
argument|const T1_Field  field
argument_list|,
argument|void**          objects
argument_list|,
argument|FT_UInt         max_objects
argument_list|,
argument|FT_ULong*       pflags
argument_list|)
end_macro
begin_block
block|{
name|T1_TokenRec
name|token
decl_stmt|;
name|FT_Byte
modifier|*
name|cur
decl_stmt|;
name|FT_Byte
modifier|*
name|limit
decl_stmt|;
name|FT_UInt
name|count
decl_stmt|;
name|FT_UInt
name|idx
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
comment|/* this also skips leading whitespace */
name|ps_parser_to_token
argument_list|(
name|parser
argument_list|,
operator|&
name|token
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|token
operator|.
name|type
condition|)
goto|goto
name|Fail
goto|;
name|count
operator|=
literal|1
expr_stmt|;
name|idx
operator|=
literal|0
expr_stmt|;
name|cur
operator|=
name|token
operator|.
name|start
expr_stmt|;
name|limit
operator|=
name|token
operator|.
name|limit
expr_stmt|;
comment|/* we must detect arrays in /FontBBox */
if|if
condition|(
name|field
operator|->
name|type
operator|==
name|T1_FIELD_TYPE_BBOX
condition|)
block|{
name|T1_TokenRec
name|token2
decl_stmt|;
name|FT_Byte
modifier|*
name|old_cur
init|=
name|parser
operator|->
name|cursor
decl_stmt|;
name|FT_Byte
modifier|*
name|old_limit
init|=
name|parser
operator|->
name|limit
decl_stmt|;
comment|/* don't include delimiters */
name|parser
operator|->
name|cursor
operator|=
name|token
operator|.
name|start
operator|+
literal|1
expr_stmt|;
name|parser
operator|->
name|limit
operator|=
name|token
operator|.
name|limit
operator|-
literal|1
expr_stmt|;
name|ps_parser_to_token
argument_list|(
name|parser
argument_list|,
operator|&
name|token2
argument_list|)
expr_stmt|;
name|parser
operator|->
name|cursor
operator|=
name|old_cur
expr_stmt|;
name|parser
operator|->
name|limit
operator|=
name|old_limit
expr_stmt|;
if|if
condition|(
name|token2
operator|.
name|type
operator|==
name|T1_TOKEN_TYPE_ARRAY
condition|)
goto|goto
name|FieldArray
goto|;
block|}
elseif|else
if|if
condition|(
name|token
operator|.
name|type
operator|==
name|T1_TOKEN_TYPE_ARRAY
condition|)
block|{
name|FieldArray
label|:
comment|/* if this is an array and we have no blend, an error occurs */
if|if
condition|(
name|max_objects
operator|==
literal|0
condition|)
goto|goto
name|Fail
goto|;
name|count
operator|=
name|max_objects
expr_stmt|;
name|idx
operator|=
literal|1
expr_stmt|;
comment|/* don't include delimiters */
name|cur
operator|++
expr_stmt|;
name|limit
operator|--
expr_stmt|;
block|}
for|for
control|(
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
operator|,
name|idx
operator|++
control|)
block|{
name|FT_Byte
modifier|*
name|q
init|=
operator|(
name|FT_Byte
operator|*
operator|)
name|objects
index|[
name|idx
index|]
operator|+
name|field
operator|->
name|offset
decl_stmt|;
name|FT_Long
name|val
decl_stmt|;
name|FT_String
modifier|*
name|string
decl_stmt|;
name|skip_spaces
argument_list|(
operator|&
name|cur
argument_list|,
name|limit
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|field
operator|->
name|type
condition|)
block|{
case|case
name|T1_FIELD_TYPE_BOOL
case|:
name|val
operator|=
name|ps_tobool
argument_list|(
operator|&
name|cur
argument_list|,
name|limit
argument_list|)
expr_stmt|;
goto|goto
name|Store_Integer
goto|;
case|case
name|T1_FIELD_TYPE_FIXED
case|:
name|val
operator|=
name|PS_Conv_ToFixed
argument_list|(
operator|&
name|cur
argument_list|,
name|limit
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|Store_Integer
goto|;
case|case
name|T1_FIELD_TYPE_FIXED_1000
case|:
name|val
operator|=
name|PS_Conv_ToFixed
argument_list|(
operator|&
name|cur
argument_list|,
name|limit
argument_list|,
literal|3
argument_list|)
expr_stmt|;
goto|goto
name|Store_Integer
goto|;
case|case
name|T1_FIELD_TYPE_INTEGER
case|:
name|val
operator|=
name|PS_Conv_ToInt
argument_list|(
operator|&
name|cur
argument_list|,
name|limit
argument_list|)
expr_stmt|;
comment|/* fall through */
name|Store_Integer
label|:
switch|switch
condition|(
name|field
operator|->
name|size
condition|)
block|{
case|case
operator|(
literal|8
operator|/
name|FT_CHAR_BIT
operator|)
case|:
operator|*
operator|(
name|FT_Byte
operator|*
operator|)
name|q
operator|=
operator|(
name|FT_Byte
operator|)
name|val
expr_stmt|;
break|break;
case|case
operator|(
literal|16
operator|/
name|FT_CHAR_BIT
operator|)
case|:
operator|*
operator|(
name|FT_UShort
operator|*
operator|)
name|q
operator|=
operator|(
name|FT_UShort
operator|)
name|val
expr_stmt|;
break|break;
case|case
operator|(
literal|32
operator|/
name|FT_CHAR_BIT
operator|)
case|:
operator|*
operator|(
name|FT_UInt32
operator|*
operator|)
name|q
operator|=
operator|(
name|FT_UInt32
operator|)
name|val
expr_stmt|;
break|break;
default|default:
comment|/* for 64-bit systems */
operator|*
operator|(
name|FT_Long
operator|*
operator|)
name|q
operator|=
name|val
expr_stmt|;
block|}
break|break;
case|case
name|T1_FIELD_TYPE_STRING
case|:
case|case
name|T1_FIELD_TYPE_KEY
case|:
block|{
name|FT_Memory
name|memory
init|=
name|parser
operator|->
name|memory
decl_stmt|;
name|FT_UInt
name|len
init|=
call|(
name|FT_UInt
call|)
argument_list|(
name|limit
operator|-
name|cur
argument_list|)
decl_stmt|;
if|if
condition|(
name|cur
operator|>=
name|limit
condition|)
break|break;
comment|/* we allow both a string or a name   */
comment|/* for cases like /FontName (foo) def */
if|if
condition|(
name|token
operator|.
name|type
operator|==
name|T1_TOKEN_TYPE_KEY
condition|)
block|{
comment|/* don't include leading `/' */
name|len
operator|--
expr_stmt|;
name|cur
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|.
name|type
operator|==
name|T1_TOKEN_TYPE_STRING
condition|)
block|{
comment|/* don't include delimiting parentheses    */
comment|/* XXX we don't handle<<...>> here        */
comment|/* XXX should we convert octal escapes?    */
comment|/*     if so, what encoding should we use? */
name|cur
operator|++
expr_stmt|;
name|len
operator|-=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"ps_parser_load_field: expected a name or string "
literal|"but found token of type %d instead\n"
operator|,
name|token
operator|.
name|type
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|PSaux_Err_Invalid_File_Format
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* for this to work (FT_String**)q must have been */
comment|/* initialized to NULL                            */
if|if
condition|(
operator|*
operator|(
name|FT_String
operator|*
operator|*
operator|)
name|q
operator|!=
name|NULL
condition|)
block|{
name|FT_TRACE0
argument_list|(
operator|(
literal|"ps_parser_load_field: overwriting field %s\n"
operator|,
name|field
operator|->
name|ident
operator|)
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
operator|*
operator|(
name|FT_String
operator|*
operator|*
operator|)
name|q
argument_list|)
expr_stmt|;
operator|*
operator|(
name|FT_String
operator|*
operator|*
operator|)
name|q
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|FT_ALLOC
argument_list|(
name|string
argument_list|,
name|len
operator|+
literal|1
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|FT_MEM_COPY
argument_list|(
name|string
argument_list|,
name|cur
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|string
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
operator|*
operator|(
name|FT_String
operator|*
operator|*
operator|)
name|q
operator|=
name|string
expr_stmt|;
block|}
break|break;
case|case
name|T1_FIELD_TYPE_BBOX
case|:
block|{
name|FT_Fixed
name|temp
index|[
literal|4
index|]
decl_stmt|;
name|FT_BBox
modifier|*
name|bbox
init|=
operator|(
name|FT_BBox
operator|*
operator|)
name|q
decl_stmt|;
name|FT_Int
name|result
decl_stmt|;
name|result
operator|=
name|ps_tofixedarray
argument_list|(
operator|&
name|cur
argument_list|,
name|limit
argument_list|,
literal|4
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"ps_parser_load_field: "
literal|"expected four integers in bounding box\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|PSaux_Err_Invalid_File_Format
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|bbox
operator|->
name|xMin
operator|=
name|FT_RoundFix
argument_list|(
name|temp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|bbox
operator|->
name|yMin
operator|=
name|FT_RoundFix
argument_list|(
name|temp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|bbox
operator|->
name|xMax
operator|=
name|FT_RoundFix
argument_list|(
name|temp
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|bbox
operator|->
name|yMax
operator|=
name|FT_RoundFix
argument_list|(
name|temp
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
comment|/* an error occurred */
goto|goto
name|Fail
goto|;
block|}
block|}
if|#
directive|if
literal|0
comment|/* obsolete -- keep for reference */
block|if ( pflags )       *pflags |= 1L<< field->flag_bit;
else|#
directive|else
name|FT_UNUSED
argument_list|(
name|pflags
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|error
operator|=
name|PSaux_Err_Ok
expr_stmt|;
name|Exit
label|:
return|return
name|error
return|;
name|Fail
label|:
name|error
operator|=
name|PSaux_Err_Invalid_File_Format
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
end_block
begin_define
DECL|macro|T1_MAX_TABLE_ELEMENTS
define|#
directive|define
name|T1_MAX_TABLE_ELEMENTS
value|32
end_define
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|ps_parser_load_field_table
argument_list|(
argument|PS_Parser       parser
argument_list|,
argument|const T1_Field  field
argument_list|,
argument|void**          objects
argument_list|,
argument|FT_UInt         max_objects
argument_list|,
argument|FT_ULong*       pflags
argument_list|)
end_macro
begin_block
block|{
name|T1_TokenRec
name|elements
index|[
name|T1_MAX_TABLE_ELEMENTS
index|]
decl_stmt|;
name|T1_Token
name|token
decl_stmt|;
name|FT_Int
name|num_elements
decl_stmt|;
name|FT_Error
name|error
init|=
name|PSaux_Err_Ok
decl_stmt|;
name|FT_Byte
modifier|*
name|old_cursor
decl_stmt|;
name|FT_Byte
modifier|*
name|old_limit
decl_stmt|;
name|T1_FieldRec
name|fieldrec
init|=
operator|*
operator|(
name|T1_Field
operator|)
name|field
decl_stmt|;
name|fieldrec
operator|.
name|type
operator|=
name|T1_FIELD_TYPE_INTEGER
expr_stmt|;
if|if
condition|(
name|field
operator|->
name|type
operator|==
name|T1_FIELD_TYPE_FIXED_ARRAY
operator|||
name|field
operator|->
name|type
operator|==
name|T1_FIELD_TYPE_BBOX
condition|)
name|fieldrec
operator|.
name|type
operator|=
name|T1_FIELD_TYPE_FIXED
expr_stmt|;
name|ps_parser_to_token_array
argument_list|(
name|parser
argument_list|,
name|elements
argument_list|,
name|T1_MAX_TABLE_ELEMENTS
argument_list|,
operator|&
name|num_elements
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_elements
operator|<
literal|0
condition|)
block|{
name|error
operator|=
name|PSaux_Err_Ignore
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
operator|(
name|FT_UInt
operator|)
name|num_elements
operator|>
name|field
operator|->
name|array_max
condition|)
name|num_elements
operator|=
name|field
operator|->
name|array_max
expr_stmt|;
name|old_cursor
operator|=
name|parser
operator|->
name|cursor
expr_stmt|;
name|old_limit
operator|=
name|parser
operator|->
name|limit
expr_stmt|;
comment|/* we store the elements count if necessary;           */
comment|/* we further assume that `count_offset' can't be zero */
if|if
condition|(
name|field
operator|->
name|type
operator|!=
name|T1_FIELD_TYPE_BBOX
operator|&&
name|field
operator|->
name|count_offset
operator|!=
literal|0
condition|)
operator|*
operator|(
name|FT_Byte
operator|*
operator|)
operator|(
operator|(
name|FT_Byte
operator|*
operator|)
name|objects
index|[
literal|0
index|]
operator|+
name|field
operator|->
name|count_offset
operator|)
operator|=
operator|(
name|FT_Byte
operator|)
name|num_elements
expr_stmt|;
comment|/* we now load each element, adjusting the field.offset on each one */
name|token
operator|=
name|elements
expr_stmt|;
for|for
control|(
init|;
name|num_elements
operator|>
literal|0
condition|;
name|num_elements
operator|--
operator|,
name|token
operator|++
control|)
block|{
name|parser
operator|->
name|cursor
operator|=
name|token
operator|->
name|start
expr_stmt|;
name|parser
operator|->
name|limit
operator|=
name|token
operator|->
name|limit
expr_stmt|;
name|ps_parser_load_field
argument_list|(
name|parser
argument_list|,
operator|&
name|fieldrec
argument_list|,
name|objects
argument_list|,
name|max_objects
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fieldrec
operator|.
name|offset
operator|+=
name|fieldrec
operator|.
name|size
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* obsolete -- keep for reference */
block|if ( pflags )       *pflags |= 1L<< field->flag_bit;
else|#
directive|else
name|FT_UNUSED
argument_list|(
name|pflags
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|parser
operator|->
name|cursor
operator|=
name|old_cursor
expr_stmt|;
name|parser
operator|->
name|limit
operator|=
name|old_limit
expr_stmt|;
name|Exit
label|:
return|return
name|error
return|;
block|}
end_block
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Long
argument_list|)
end_macro
begin_macro
name|ps_parser_to_int
argument_list|(
argument|PS_Parser  parser
argument_list|)
end_macro
begin_block
block|{
name|ps_parser_skip_spaces
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return
name|PS_Conv_ToInt
argument_list|(
operator|&
name|parser
operator|->
name|cursor
argument_list|,
name|parser
operator|->
name|limit
argument_list|)
return|;
block|}
end_block
begin_comment
comment|/* first character must be `<' if `delimiters' is non-zero */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|ps_parser_to_bytes
argument_list|(
argument|PS_Parser  parser
argument_list|,
argument|FT_Byte*   bytes
argument_list|,
argument|FT_Long    max_bytes
argument_list|,
argument|FT_Long*   pnum_bytes
argument_list|,
argument|FT_Bool    delimiters
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
init|=
name|PSaux_Err_Ok
decl_stmt|;
name|FT_Byte
modifier|*
name|cur
decl_stmt|;
name|ps_parser_skip_spaces
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|cur
operator|=
name|parser
operator|->
name|cursor
expr_stmt|;
if|if
condition|(
name|cur
operator|>=
name|parser
operator|->
name|limit
condition|)
goto|goto
name|Exit
goto|;
if|if
condition|(
name|delimiters
condition|)
block|{
if|if
condition|(
operator|*
name|cur
operator|!=
literal|'<'
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"ps_parser_to_bytes: Missing starting delimiter `<'\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|PSaux_Err_Invalid_File_Format
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|cur
operator|++
expr_stmt|;
block|}
operator|*
name|pnum_bytes
operator|=
name|PS_Conv_ASCIIHexDecode
argument_list|(
operator|&
name|cur
argument_list|,
name|parser
operator|->
name|limit
argument_list|,
name|bytes
argument_list|,
name|max_bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|delimiters
condition|)
block|{
if|if
condition|(
name|cur
operator|<
name|parser
operator|->
name|limit
operator|&&
operator|*
name|cur
operator|!=
literal|'>'
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"ps_parser_to_bytes: Missing closing delimiter `>'\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|PSaux_Err_Invalid_File_Format
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|cur
operator|++
expr_stmt|;
block|}
name|parser
operator|->
name|cursor
operator|=
name|cur
expr_stmt|;
name|Exit
label|:
return|return
name|error
return|;
block|}
end_block
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Fixed
argument_list|)
end_macro
begin_macro
name|ps_parser_to_fixed
argument_list|(
argument|PS_Parser  parser
argument_list|,
argument|FT_Int     power_ten
argument_list|)
end_macro
begin_block
block|{
name|ps_parser_skip_spaces
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return
name|PS_Conv_ToFixed
argument_list|(
operator|&
name|parser
operator|->
name|cursor
argument_list|,
name|parser
operator|->
name|limit
argument_list|,
name|power_ten
argument_list|)
return|;
block|}
end_block
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Int
argument_list|)
end_macro
begin_macro
name|ps_parser_to_coord_array
argument_list|(
argument|PS_Parser  parser
argument_list|,
argument|FT_Int     max_coords
argument_list|,
argument|FT_Short*  coords
argument_list|)
end_macro
begin_block
block|{
name|ps_parser_skip_spaces
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return
name|ps_tocoordarray
argument_list|(
operator|&
name|parser
operator|->
name|cursor
argument_list|,
name|parser
operator|->
name|limit
argument_list|,
name|max_coords
argument_list|,
name|coords
argument_list|)
return|;
block|}
end_block
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Int
argument_list|)
end_macro
begin_macro
name|ps_parser_to_fixed_array
argument_list|(
argument|PS_Parser  parser
argument_list|,
argument|FT_Int     max_values
argument_list|,
argument|FT_Fixed*  values
argument_list|,
argument|FT_Int     power_ten
argument_list|)
end_macro
begin_block
block|{
name|ps_parser_skip_spaces
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return
name|ps_tofixedarray
argument_list|(
operator|&
name|parser
operator|->
name|cursor
argument_list|,
name|parser
operator|->
name|limit
argument_list|,
name|max_values
argument_list|,
name|values
argument_list|,
name|power_ten
argument_list|)
return|;
block|}
end_block
begin_if
if|#
directive|if
literal|0
end_if
begin_endif
unit|FT_LOCAL_DEF( FT_String* )   T1_ToString( PS_Parser  parser )   {     return ps_tostring(&parser->cursor, parser->limit, parser->memory );   }     FT_LOCAL_DEF( FT_Bool )   T1_ToBool( PS_Parser  parser )   {     return ps_tobool(&parser->cursor, parser->limit );   }
endif|#
directive|endif
end_endif
begin_comment
comment|/* 0 */
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|ps_parser_init
name|ps_parser_init
argument_list|(
argument|PS_Parser  parser
argument_list|,
argument|FT_Byte*   base
argument_list|,
argument|FT_Byte*   limit
argument_list|,
argument|FT_Memory  memory
argument_list|)
end_macro
begin_block
block|{
name|parser
operator|->
name|error
operator|=
name|PSaux_Err_Ok
expr_stmt|;
name|parser
operator|->
name|base
operator|=
name|base
expr_stmt|;
name|parser
operator|->
name|limit
operator|=
name|limit
expr_stmt|;
name|parser
operator|->
name|cursor
operator|=
name|base
expr_stmt|;
name|parser
operator|->
name|memory
operator|=
name|memory
expr_stmt|;
name|parser
operator|->
name|funcs
operator|=
name|ps_parser_funcs
expr_stmt|;
block|}
end_block
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|ps_parser_done
name|ps_parser_done
argument_list|(
argument|PS_Parser  parser
argument_list|)
end_macro
begin_block
block|{
name|FT_UNUSED
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****                            T1 BUILDER                         *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    t1_builder_init                                                    */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Initializes a given glyph builder.                                 */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<InOut>                                                               */
end_comment
begin_comment
comment|/*    builder :: A pointer to the glyph builder to initialize.           */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    face    :: The current face object.                                */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    size    :: The current size object.                                */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    glyph   :: The current glyph object.                               */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    hinting :: Whether hinting should be applied.                      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|t1_builder_init
name|t1_builder_init
argument_list|(
argument|T1_Builder    builder
argument_list|,
argument|FT_Face       face
argument_list|,
argument|FT_Size       size
argument_list|,
argument|FT_GlyphSlot  glyph
argument_list|,
argument|FT_Bool       hinting
argument_list|)
end_macro
begin_block
block|{
name|builder
operator|->
name|parse_state
operator|=
name|T1_Parse_Start
expr_stmt|;
name|builder
operator|->
name|load_points
operator|=
literal|1
expr_stmt|;
name|builder
operator|->
name|face
operator|=
name|face
expr_stmt|;
name|builder
operator|->
name|glyph
operator|=
name|glyph
expr_stmt|;
name|builder
operator|->
name|memory
operator|=
name|face
operator|->
name|memory
expr_stmt|;
if|if
condition|(
name|glyph
condition|)
block|{
name|FT_GlyphLoader
name|loader
init|=
name|glyph
operator|->
name|internal
operator|->
name|loader
decl_stmt|;
name|builder
operator|->
name|loader
operator|=
name|loader
expr_stmt|;
name|builder
operator|->
name|base
operator|=
operator|&
name|loader
operator|->
name|base
operator|.
name|outline
expr_stmt|;
name|builder
operator|->
name|current
operator|=
operator|&
name|loader
operator|->
name|current
operator|.
name|outline
expr_stmt|;
name|FT_GlyphLoader_Rewind
argument_list|(
name|loader
argument_list|)
expr_stmt|;
name|builder
operator|->
name|hints_globals
operator|=
name|size
operator|->
name|internal
expr_stmt|;
name|builder
operator|->
name|hints_funcs
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|hinting
condition|)
name|builder
operator|->
name|hints_funcs
operator|=
name|glyph
operator|->
name|internal
operator|->
name|glyph_hints
expr_stmt|;
block|}
name|builder
operator|->
name|pos_x
operator|=
literal|0
expr_stmt|;
name|builder
operator|->
name|pos_y
operator|=
literal|0
expr_stmt|;
name|builder
operator|->
name|left_bearing
operator|.
name|x
operator|=
literal|0
expr_stmt|;
name|builder
operator|->
name|left_bearing
operator|.
name|y
operator|=
literal|0
expr_stmt|;
name|builder
operator|->
name|advance
operator|.
name|x
operator|=
literal|0
expr_stmt|;
name|builder
operator|->
name|advance
operator|.
name|y
operator|=
literal|0
expr_stmt|;
name|builder
operator|->
name|funcs
operator|=
name|t1_builder_funcs
expr_stmt|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    t1_builder_done                                                    */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Finalizes a given glyph builder.  Its contents can still be used   */
end_comment
begin_comment
comment|/*    after the call, but the function saves important information       */
end_comment
begin_comment
comment|/*    within the corresponding glyph slot.                               */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    builder :: A pointer to the glyph builder to finalize.             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|t1_builder_done
name|t1_builder_done
argument_list|(
argument|T1_Builder  builder
argument_list|)
end_macro
begin_block
block|{
name|FT_GlyphSlot
name|glyph
init|=
name|builder
operator|->
name|glyph
decl_stmt|;
if|if
condition|(
name|glyph
condition|)
name|glyph
operator|->
name|outline
operator|=
operator|*
name|builder
operator|->
name|base
expr_stmt|;
block|}
end_block
begin_comment
comment|/* check that there is enough space for `count' more points */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|t1_builder_check_points
argument_list|(
argument|T1_Builder  builder
argument_list|,
argument|FT_Int      count
argument_list|)
end_macro
begin_block
block|{
return|return
name|FT_GLYPHLOADER_CHECK_POINTS
argument_list|(
name|builder
operator|->
name|loader
argument_list|,
name|count
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_block
begin_comment
comment|/* add a new point, do not check space */
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|t1_builder_add_point
name|t1_builder_add_point
argument_list|(
argument|T1_Builder  builder
argument_list|,
argument|FT_Pos      x
argument_list|,
argument|FT_Pos      y
argument_list|,
argument|FT_Byte     flag
argument_list|)
end_macro
begin_block
block|{
name|FT_Outline
modifier|*
name|outline
init|=
name|builder
operator|->
name|current
decl_stmt|;
if|if
condition|(
name|builder
operator|->
name|load_points
condition|)
block|{
name|FT_Vector
modifier|*
name|point
init|=
name|outline
operator|->
name|points
operator|+
name|outline
operator|->
name|n_points
decl_stmt|;
name|FT_Byte
modifier|*
name|control
init|=
operator|(
name|FT_Byte
operator|*
operator|)
name|outline
operator|->
name|tags
operator|+
name|outline
operator|->
name|n_points
decl_stmt|;
if|if
condition|(
name|builder
operator|->
name|shift
condition|)
block|{
name|x
operator|>>=
literal|16
expr_stmt|;
name|y
operator|>>=
literal|16
expr_stmt|;
block|}
name|point
operator|->
name|x
operator|=
name|x
expr_stmt|;
name|point
operator|->
name|y
operator|=
name|y
expr_stmt|;
operator|*
name|control
operator|=
call|(
name|FT_Byte
call|)
argument_list|(
name|flag
condition|?
name|FT_CURVE_TAG_ON
else|:
name|FT_CURVE_TAG_CUBIC
argument_list|)
expr_stmt|;
name|builder
operator|->
name|last
operator|=
operator|*
name|point
expr_stmt|;
block|}
name|outline
operator|->
name|n_points
operator|++
expr_stmt|;
block|}
end_block
begin_comment
comment|/* check space for a new on-curve point, then add it */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|t1_builder_add_point1
argument_list|(
argument|T1_Builder  builder
argument_list|,
argument|FT_Pos      x
argument_list|,
argument|FT_Pos      y
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
decl_stmt|;
name|error
operator|=
name|t1_builder_check_points
argument_list|(
name|builder
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|t1_builder_add_point
argument_list|(
name|builder
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/* check space for a new contour, then add it */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|t1_builder_add_contour
argument_list|(
argument|T1_Builder  builder
argument_list|)
end_macro
begin_block
block|{
name|FT_Outline
modifier|*
name|outline
init|=
name|builder
operator|->
name|current
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
if|if
condition|(
operator|!
name|builder
operator|->
name|load_points
condition|)
block|{
name|outline
operator|->
name|n_contours
operator|++
expr_stmt|;
return|return
name|PSaux_Err_Ok
return|;
block|}
name|error
operator|=
name|FT_GLYPHLOADER_CHECK_POINTS
argument_list|(
name|builder
operator|->
name|loader
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
if|if
condition|(
name|outline
operator|->
name|n_contours
operator|>
literal|0
condition|)
name|outline
operator|->
name|contours
index|[
name|outline
operator|->
name|n_contours
operator|-
literal|1
index|]
operator|=
call|(
name|short
call|)
argument_list|(
name|outline
operator|->
name|n_points
operator|-
literal|1
argument_list|)
expr_stmt|;
name|outline
operator|->
name|n_contours
operator|++
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/* if a path was begun, add its first on-curve point */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|t1_builder_start_point
argument_list|(
argument|T1_Builder  builder
argument_list|,
argument|FT_Pos      x
argument_list|,
argument|FT_Pos      y
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
init|=
name|PSaux_Err_Invalid_File_Format
decl_stmt|;
comment|/* test whether we are building a new contour */
if|if
condition|(
name|builder
operator|->
name|parse_state
operator|==
name|T1_Parse_Have_Path
condition|)
name|error
operator|=
name|PSaux_Err_Ok
expr_stmt|;
elseif|else
if|if
condition|(
name|builder
operator|->
name|parse_state
operator|==
name|T1_Parse_Have_Moveto
condition|)
block|{
name|builder
operator|->
name|parse_state
operator|=
name|T1_Parse_Have_Path
expr_stmt|;
name|error
operator|=
name|t1_builder_add_contour
argument_list|(
name|builder
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|t1_builder_add_point1
argument_list|(
name|builder
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/* close the current contour */
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|t1_builder_close_contour
name|t1_builder_close_contour
argument_list|(
argument|T1_Builder  builder
argument_list|)
end_macro
begin_block
block|{
name|FT_Outline
modifier|*
name|outline
init|=
name|builder
operator|->
name|current
decl_stmt|;
name|FT_Int
name|first
decl_stmt|;
if|if
condition|(
operator|!
name|outline
condition|)
return|return;
name|first
operator|=
name|outline
operator|->
name|n_contours
operator|<=
literal|1
condition|?
literal|0
else|:
name|outline
operator|->
name|contours
index|[
name|outline
operator|->
name|n_contours
operator|-
literal|2
index|]
operator|+
literal|1
expr_stmt|;
comment|/* We must not include the last point in the path if it */
comment|/* is located on the first point.                       */
if|if
condition|(
name|outline
operator|->
name|n_points
operator|>
literal|1
condition|)
block|{
name|FT_Vector
modifier|*
name|p1
init|=
name|outline
operator|->
name|points
operator|+
name|first
decl_stmt|;
name|FT_Vector
modifier|*
name|p2
init|=
name|outline
operator|->
name|points
operator|+
name|outline
operator|->
name|n_points
operator|-
literal|1
decl_stmt|;
name|FT_Byte
modifier|*
name|control
init|=
operator|(
name|FT_Byte
operator|*
operator|)
name|outline
operator|->
name|tags
operator|+
name|outline
operator|->
name|n_points
operator|-
literal|1
decl_stmt|;
comment|/* `delete' last point only if it coincides with the first */
comment|/* point and it is not a control point (which can happen). */
if|if
condition|(
name|p1
operator|->
name|x
operator|==
name|p2
operator|->
name|x
operator|&&
name|p1
operator|->
name|y
operator|==
name|p2
operator|->
name|y
condition|)
if|if
condition|(
operator|*
name|control
operator|==
name|FT_CURVE_TAG_ON
condition|)
name|outline
operator|->
name|n_points
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|outline
operator|->
name|n_contours
operator|>
literal|0
condition|)
block|{
comment|/* Don't add contours only consisting of one point, i.e., */
comment|/* check whether begin point and last point are the same. */
if|if
condition|(
name|first
operator|==
name|outline
operator|->
name|n_points
operator|-
literal|1
condition|)
block|{
name|outline
operator|->
name|n_contours
operator|--
expr_stmt|;
name|outline
operator|->
name|n_points
operator|--
expr_stmt|;
block|}
else|else
name|outline
operator|->
name|contours
index|[
name|outline
operator|->
name|n_contours
operator|-
literal|1
index|]
operator|=
call|(
name|short
call|)
argument_list|(
name|outline
operator|->
name|n_points
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****                            OTHER                              *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|t1_decrypt
name|t1_decrypt
argument_list|(
argument|FT_Byte*   buffer
argument_list|,
argument|FT_Offset  length
argument_list|,
argument|FT_UShort  seed
argument_list|)
end_macro
begin_block
block|{
name|PS_Conv_EexecDecode
argument_list|(
operator|&
name|buffer
argument_list|,
name|buffer
operator|+
name|length
argument_list|,
name|buffer
argument_list|,
name|length
argument_list|,
operator|&
name|seed
argument_list|)
expr_stmt|;
block|}
end_block
begin_comment
comment|/* END */
end_comment
end_unit
