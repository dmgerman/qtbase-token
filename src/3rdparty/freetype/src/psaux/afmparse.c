begin_unit
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  afmparse.c                                                             */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*    AFM parser (body).                                                   */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  Copyright 2006-2015 by                                                 */
end_comment
begin_comment
comment|/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  This file is part of the FreeType project, and may only be used,       */
end_comment
begin_comment
comment|/*  modified, and distributed under the terms of the FreeType project      */
end_comment
begin_comment
comment|/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
end_comment
begin_comment
comment|/*  this file you indicate that you have read the license and              */
end_comment
begin_comment
comment|/*  understand and accept it fully.                                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<ft2build.h>
end_include
begin_include
include|#
directive|include
include|FT_FREETYPE_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_DEBUG_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_POSTSCRIPT_AUX_H
end_include
begin_include
include|#
directive|include
file|"afmparse.h"
end_include
begin_include
include|#
directive|include
file|"psconv.h"
end_include
begin_include
include|#
directive|include
file|"psauxerr.h"
end_include
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*    AFM_Stream                                                           */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/* The use of AFM_Stream is largely inspired by parseAFM.[ch] from t1lib.  */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_enum
enum|enum
block|{
DECL|enumerator|AFM_STREAM_STATUS_NORMAL
name|AFM_STREAM_STATUS_NORMAL
block|,
DECL|enumerator|AFM_STREAM_STATUS_EOC
name|AFM_STREAM_STATUS_EOC
block|,
DECL|enumerator|AFM_STREAM_STATUS_EOL
name|AFM_STREAM_STATUS_EOL
block|,
DECL|enumerator|AFM_STREAM_STATUS_EOF
name|AFM_STREAM_STATUS_EOF
block|}
enum|;
end_enum
begin_typedef
DECL|struct|AFM_StreamRec_
typedef|typedef
struct|struct
name|AFM_StreamRec_
block|{
DECL|member|cursor
name|FT_Byte
modifier|*
name|cursor
decl_stmt|;
DECL|member|base
name|FT_Byte
modifier|*
name|base
decl_stmt|;
DECL|member|limit
name|FT_Byte
modifier|*
name|limit
decl_stmt|;
DECL|member|status
name|FT_Int
name|status
decl_stmt|;
block|}
DECL|typedef|AFM_StreamRec
name|AFM_StreamRec
typedef|;
end_typedef
begin_ifndef
ifndef|#
directive|ifndef
name|EOF
end_ifndef
begin_define
DECL|macro|EOF
define|#
directive|define
name|EOF
value|-1
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* this works because empty lines are ignored */
end_comment
begin_define
DECL|macro|AFM_IS_NEWLINE
define|#
directive|define
name|AFM_IS_NEWLINE
parameter_list|(
name|ch
parameter_list|)
value|( (ch) == '\r' || (ch) == '\n' )
end_define
begin_define
DECL|macro|AFM_IS_EOF
define|#
directive|define
name|AFM_IS_EOF
parameter_list|(
name|ch
parameter_list|)
value|( (ch) == EOF  || (ch) == '\x1a' )
end_define
begin_define
DECL|macro|AFM_IS_SPACE
define|#
directive|define
name|AFM_IS_SPACE
parameter_list|(
name|ch
parameter_list|)
value|( (ch) == ' '  || (ch) == '\t' )
end_define
begin_comment
comment|/* column separator; there is no `column' in the spec actually */
end_comment
begin_define
DECL|macro|AFM_IS_SEP
define|#
directive|define
name|AFM_IS_SEP
parameter_list|(
name|ch
parameter_list|)
value|( (ch) == ';' )
end_define
begin_define
DECL|macro|AFM_GETC
define|#
directive|define
name|AFM_GETC
parameter_list|()
define|\
value|( ( (stream)->cursor< (stream)->limit ) ? *(stream)->cursor++ \                                                    : EOF )
end_define
begin_define
DECL|macro|AFM_STREAM_KEY_BEGIN
define|#
directive|define
name|AFM_STREAM_KEY_BEGIN
parameter_list|(
name|stream
parameter_list|)
define|\
value|(char*)( (stream)->cursor - 1 )
end_define
begin_define
DECL|macro|AFM_STREAM_KEY_LEN
define|#
directive|define
name|AFM_STREAM_KEY_LEN
parameter_list|(
name|stream
parameter_list|,
name|key
parameter_list|)
define|\
value|(FT_Offset)( (char*)(stream)->cursor - key - 1 )
end_define
begin_define
DECL|macro|AFM_STATUS_EOC
define|#
directive|define
name|AFM_STATUS_EOC
parameter_list|(
name|stream
parameter_list|)
define|\
value|( (stream)->status>= AFM_STREAM_STATUS_EOC )
end_define
begin_define
DECL|macro|AFM_STATUS_EOL
define|#
directive|define
name|AFM_STATUS_EOL
parameter_list|(
name|stream
parameter_list|)
define|\
value|( (stream)->status>= AFM_STREAM_STATUS_EOL )
end_define
begin_define
DECL|macro|AFM_STATUS_EOF
define|#
directive|define
name|AFM_STATUS_EOF
parameter_list|(
name|stream
parameter_list|)
define|\
value|( (stream)->status>= AFM_STREAM_STATUS_EOF )
end_define
begin_function
specifier|static
name|int
DECL|function|afm_stream_skip_spaces
name|afm_stream_skip_spaces
parameter_list|(
name|AFM_Stream
name|stream
parameter_list|)
block|{
name|int
name|ch
init|=
literal|0
decl_stmt|;
comment|/* make stupid compiler happy */
if|if
condition|(
name|AFM_STATUS_EOC
argument_list|(
name|stream
argument_list|)
condition|)
return|return
literal|';'
return|;
while|while
condition|(
literal|1
condition|)
block|{
name|ch
operator|=
name|AFM_GETC
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|AFM_IS_SPACE
argument_list|(
name|ch
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|AFM_IS_NEWLINE
argument_list|(
name|ch
argument_list|)
condition|)
name|stream
operator|->
name|status
operator|=
name|AFM_STREAM_STATUS_EOL
expr_stmt|;
elseif|else
if|if
condition|(
name|AFM_IS_SEP
argument_list|(
name|ch
argument_list|)
condition|)
name|stream
operator|->
name|status
operator|=
name|AFM_STREAM_STATUS_EOC
expr_stmt|;
elseif|else
if|if
condition|(
name|AFM_IS_EOF
argument_list|(
name|ch
argument_list|)
condition|)
name|stream
operator|->
name|status
operator|=
name|AFM_STREAM_STATUS_EOF
expr_stmt|;
return|return
name|ch
return|;
block|}
end_function
begin_comment
comment|/* read a key or value in current column */
end_comment
begin_function
specifier|static
name|char
modifier|*
DECL|function|afm_stream_read_one
name|afm_stream_read_one
parameter_list|(
name|AFM_Stream
name|stream
parameter_list|)
block|{
name|char
modifier|*
name|str
decl_stmt|;
name|afm_stream_skip_spaces
argument_list|(
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|AFM_STATUS_EOC
argument_list|(
name|stream
argument_list|)
condition|)
return|return
name|NULL
return|;
name|str
operator|=
name|AFM_STREAM_KEY_BEGIN
argument_list|(
name|stream
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|ch
init|=
name|AFM_GETC
argument_list|()
decl_stmt|;
if|if
condition|(
name|AFM_IS_SPACE
argument_list|(
name|ch
argument_list|)
condition|)
break|break;
elseif|else
if|if
condition|(
name|AFM_IS_NEWLINE
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|stream
operator|->
name|status
operator|=
name|AFM_STREAM_STATUS_EOL
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|AFM_IS_SEP
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|stream
operator|->
name|status
operator|=
name|AFM_STREAM_STATUS_EOC
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|AFM_IS_EOF
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|stream
operator|->
name|status
operator|=
name|AFM_STREAM_STATUS_EOF
expr_stmt|;
break|break;
block|}
block|}
return|return
name|str
return|;
block|}
end_function
begin_comment
comment|/* read a string (i.e., read to EOL) */
end_comment
begin_function
specifier|static
name|char
modifier|*
DECL|function|afm_stream_read_string
name|afm_stream_read_string
parameter_list|(
name|AFM_Stream
name|stream
parameter_list|)
block|{
name|char
modifier|*
name|str
decl_stmt|;
name|afm_stream_skip_spaces
argument_list|(
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|AFM_STATUS_EOL
argument_list|(
name|stream
argument_list|)
condition|)
return|return
name|NULL
return|;
name|str
operator|=
name|AFM_STREAM_KEY_BEGIN
argument_list|(
name|stream
argument_list|)
expr_stmt|;
comment|/* scan to eol */
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|ch
init|=
name|AFM_GETC
argument_list|()
decl_stmt|;
if|if
condition|(
name|AFM_IS_NEWLINE
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|stream
operator|->
name|status
operator|=
name|AFM_STREAM_STATUS_EOL
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|AFM_IS_EOF
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|stream
operator|->
name|status
operator|=
name|AFM_STREAM_STATUS_EOF
expr_stmt|;
break|break;
block|}
block|}
return|return
name|str
return|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    AFM_Parser                                                         */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* all keys defined in Ch. 7-10 of 5004.AFM_Spec.pdf */
end_comment
begin_typedef
DECL|enum|AFM_Token_
typedef|typedef
enum|enum
name|AFM_Token_
block|{
DECL|enumerator|AFM_TOKEN_ASCENDER
name|AFM_TOKEN_ASCENDER
block|,
DECL|enumerator|AFM_TOKEN_AXISLABEL
name|AFM_TOKEN_AXISLABEL
block|,
DECL|enumerator|AFM_TOKEN_AXISTYPE
name|AFM_TOKEN_AXISTYPE
block|,
DECL|enumerator|AFM_TOKEN_B
name|AFM_TOKEN_B
block|,
DECL|enumerator|AFM_TOKEN_BLENDAXISTYPES
name|AFM_TOKEN_BLENDAXISTYPES
block|,
DECL|enumerator|AFM_TOKEN_BLENDDESIGNMAP
name|AFM_TOKEN_BLENDDESIGNMAP
block|,
DECL|enumerator|AFM_TOKEN_BLENDDESIGNPOSITIONS
name|AFM_TOKEN_BLENDDESIGNPOSITIONS
block|,
DECL|enumerator|AFM_TOKEN_C
name|AFM_TOKEN_C
block|,
DECL|enumerator|AFM_TOKEN_CC
name|AFM_TOKEN_CC
block|,
DECL|enumerator|AFM_TOKEN_CH
name|AFM_TOKEN_CH
block|,
DECL|enumerator|AFM_TOKEN_CAPHEIGHT
name|AFM_TOKEN_CAPHEIGHT
block|,
DECL|enumerator|AFM_TOKEN_CHARWIDTH
name|AFM_TOKEN_CHARWIDTH
block|,
DECL|enumerator|AFM_TOKEN_CHARACTERSET
name|AFM_TOKEN_CHARACTERSET
block|,
DECL|enumerator|AFM_TOKEN_CHARACTERS
name|AFM_TOKEN_CHARACTERS
block|,
DECL|enumerator|AFM_TOKEN_DESCENDER
name|AFM_TOKEN_DESCENDER
block|,
DECL|enumerator|AFM_TOKEN_ENCODINGSCHEME
name|AFM_TOKEN_ENCODINGSCHEME
block|,
DECL|enumerator|AFM_TOKEN_ENDAXIS
name|AFM_TOKEN_ENDAXIS
block|,
DECL|enumerator|AFM_TOKEN_ENDCHARMETRICS
name|AFM_TOKEN_ENDCHARMETRICS
block|,
DECL|enumerator|AFM_TOKEN_ENDCOMPOSITES
name|AFM_TOKEN_ENDCOMPOSITES
block|,
DECL|enumerator|AFM_TOKEN_ENDDIRECTION
name|AFM_TOKEN_ENDDIRECTION
block|,
DECL|enumerator|AFM_TOKEN_ENDFONTMETRICS
name|AFM_TOKEN_ENDFONTMETRICS
block|,
DECL|enumerator|AFM_TOKEN_ENDKERNDATA
name|AFM_TOKEN_ENDKERNDATA
block|,
DECL|enumerator|AFM_TOKEN_ENDKERNPAIRS
name|AFM_TOKEN_ENDKERNPAIRS
block|,
DECL|enumerator|AFM_TOKEN_ENDTRACKKERN
name|AFM_TOKEN_ENDTRACKKERN
block|,
DECL|enumerator|AFM_TOKEN_ESCCHAR
name|AFM_TOKEN_ESCCHAR
block|,
DECL|enumerator|AFM_TOKEN_FAMILYNAME
name|AFM_TOKEN_FAMILYNAME
block|,
DECL|enumerator|AFM_TOKEN_FONTBBOX
name|AFM_TOKEN_FONTBBOX
block|,
DECL|enumerator|AFM_TOKEN_FONTNAME
name|AFM_TOKEN_FONTNAME
block|,
DECL|enumerator|AFM_TOKEN_FULLNAME
name|AFM_TOKEN_FULLNAME
block|,
DECL|enumerator|AFM_TOKEN_ISBASEFONT
name|AFM_TOKEN_ISBASEFONT
block|,
DECL|enumerator|AFM_TOKEN_ISCIDFONT
name|AFM_TOKEN_ISCIDFONT
block|,
DECL|enumerator|AFM_TOKEN_ISFIXEDPITCH
name|AFM_TOKEN_ISFIXEDPITCH
block|,
DECL|enumerator|AFM_TOKEN_ISFIXEDV
name|AFM_TOKEN_ISFIXEDV
block|,
DECL|enumerator|AFM_TOKEN_ITALICANGLE
name|AFM_TOKEN_ITALICANGLE
block|,
DECL|enumerator|AFM_TOKEN_KP
name|AFM_TOKEN_KP
block|,
DECL|enumerator|AFM_TOKEN_KPH
name|AFM_TOKEN_KPH
block|,
DECL|enumerator|AFM_TOKEN_KPX
name|AFM_TOKEN_KPX
block|,
DECL|enumerator|AFM_TOKEN_KPY
name|AFM_TOKEN_KPY
block|,
DECL|enumerator|AFM_TOKEN_L
name|AFM_TOKEN_L
block|,
DECL|enumerator|AFM_TOKEN_MAPPINGSCHEME
name|AFM_TOKEN_MAPPINGSCHEME
block|,
DECL|enumerator|AFM_TOKEN_METRICSSETS
name|AFM_TOKEN_METRICSSETS
block|,
DECL|enumerator|AFM_TOKEN_N
name|AFM_TOKEN_N
block|,
DECL|enumerator|AFM_TOKEN_NOTICE
name|AFM_TOKEN_NOTICE
block|,
DECL|enumerator|AFM_TOKEN_PCC
name|AFM_TOKEN_PCC
block|,
DECL|enumerator|AFM_TOKEN_STARTAXIS
name|AFM_TOKEN_STARTAXIS
block|,
DECL|enumerator|AFM_TOKEN_STARTCHARMETRICS
name|AFM_TOKEN_STARTCHARMETRICS
block|,
DECL|enumerator|AFM_TOKEN_STARTCOMPOSITES
name|AFM_TOKEN_STARTCOMPOSITES
block|,
DECL|enumerator|AFM_TOKEN_STARTDIRECTION
name|AFM_TOKEN_STARTDIRECTION
block|,
DECL|enumerator|AFM_TOKEN_STARTFONTMETRICS
name|AFM_TOKEN_STARTFONTMETRICS
block|,
DECL|enumerator|AFM_TOKEN_STARTKERNDATA
name|AFM_TOKEN_STARTKERNDATA
block|,
DECL|enumerator|AFM_TOKEN_STARTKERNPAIRS
name|AFM_TOKEN_STARTKERNPAIRS
block|,
DECL|enumerator|AFM_TOKEN_STARTKERNPAIRS0
name|AFM_TOKEN_STARTKERNPAIRS0
block|,
DECL|enumerator|AFM_TOKEN_STARTKERNPAIRS1
name|AFM_TOKEN_STARTKERNPAIRS1
block|,
DECL|enumerator|AFM_TOKEN_STARTTRACKKERN
name|AFM_TOKEN_STARTTRACKKERN
block|,
DECL|enumerator|AFM_TOKEN_STDHW
name|AFM_TOKEN_STDHW
block|,
DECL|enumerator|AFM_TOKEN_STDVW
name|AFM_TOKEN_STDVW
block|,
DECL|enumerator|AFM_TOKEN_TRACKKERN
name|AFM_TOKEN_TRACKKERN
block|,
DECL|enumerator|AFM_TOKEN_UNDERLINEPOSITION
name|AFM_TOKEN_UNDERLINEPOSITION
block|,
DECL|enumerator|AFM_TOKEN_UNDERLINETHICKNESS
name|AFM_TOKEN_UNDERLINETHICKNESS
block|,
DECL|enumerator|AFM_TOKEN_VV
name|AFM_TOKEN_VV
block|,
DECL|enumerator|AFM_TOKEN_VVECTOR
name|AFM_TOKEN_VVECTOR
block|,
DECL|enumerator|AFM_TOKEN_VERSION
name|AFM_TOKEN_VERSION
block|,
DECL|enumerator|AFM_TOKEN_W
name|AFM_TOKEN_W
block|,
DECL|enumerator|AFM_TOKEN_W0
name|AFM_TOKEN_W0
block|,
DECL|enumerator|AFM_TOKEN_W0X
name|AFM_TOKEN_W0X
block|,
DECL|enumerator|AFM_TOKEN_W0Y
name|AFM_TOKEN_W0Y
block|,
DECL|enumerator|AFM_TOKEN_W1
name|AFM_TOKEN_W1
block|,
DECL|enumerator|AFM_TOKEN_W1X
name|AFM_TOKEN_W1X
block|,
DECL|enumerator|AFM_TOKEN_W1Y
name|AFM_TOKEN_W1Y
block|,
DECL|enumerator|AFM_TOKEN_WX
name|AFM_TOKEN_WX
block|,
DECL|enumerator|AFM_TOKEN_WY
name|AFM_TOKEN_WY
block|,
DECL|enumerator|AFM_TOKEN_WEIGHT
name|AFM_TOKEN_WEIGHT
block|,
DECL|enumerator|AFM_TOKEN_WEIGHTVECTOR
name|AFM_TOKEN_WEIGHTVECTOR
block|,
DECL|enumerator|AFM_TOKEN_XHEIGHT
name|AFM_TOKEN_XHEIGHT
block|,
DECL|enumerator|N_AFM_TOKENS
name|N_AFM_TOKENS
block|,
DECL|enumerator|AFM_TOKEN_UNKNOWN
name|AFM_TOKEN_UNKNOWN
block|}
DECL|typedef|AFM_Token
name|AFM_Token
typedef|;
end_typedef
begin_decl_stmt
DECL|variable|afm_key_table
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|afm_key_table
index|[
name|N_AFM_TOKENS
index|]
init|=
block|{
literal|"Ascender"
block|,
literal|"AxisLabel"
block|,
literal|"AxisType"
block|,
literal|"B"
block|,
literal|"BlendAxisTypes"
block|,
literal|"BlendDesignMap"
block|,
literal|"BlendDesignPositions"
block|,
literal|"C"
block|,
literal|"CC"
block|,
literal|"CH"
block|,
literal|"CapHeight"
block|,
literal|"CharWidth"
block|,
literal|"CharacterSet"
block|,
literal|"Characters"
block|,
literal|"Descender"
block|,
literal|"EncodingScheme"
block|,
literal|"EndAxis"
block|,
literal|"EndCharMetrics"
block|,
literal|"EndComposites"
block|,
literal|"EndDirection"
block|,
literal|"EndFontMetrics"
block|,
literal|"EndKernData"
block|,
literal|"EndKernPairs"
block|,
literal|"EndTrackKern"
block|,
literal|"EscChar"
block|,
literal|"FamilyName"
block|,
literal|"FontBBox"
block|,
literal|"FontName"
block|,
literal|"FullName"
block|,
literal|"IsBaseFont"
block|,
literal|"IsCIDFont"
block|,
literal|"IsFixedPitch"
block|,
literal|"IsFixedV"
block|,
literal|"ItalicAngle"
block|,
literal|"KP"
block|,
literal|"KPH"
block|,
literal|"KPX"
block|,
literal|"KPY"
block|,
literal|"L"
block|,
literal|"MappingScheme"
block|,
literal|"MetricsSets"
block|,
literal|"N"
block|,
literal|"Notice"
block|,
literal|"PCC"
block|,
literal|"StartAxis"
block|,
literal|"StartCharMetrics"
block|,
literal|"StartComposites"
block|,
literal|"StartDirection"
block|,
literal|"StartFontMetrics"
block|,
literal|"StartKernData"
block|,
literal|"StartKernPairs"
block|,
literal|"StartKernPairs0"
block|,
literal|"StartKernPairs1"
block|,
literal|"StartTrackKern"
block|,
literal|"StdHW"
block|,
literal|"StdVW"
block|,
literal|"TrackKern"
block|,
literal|"UnderlinePosition"
block|,
literal|"UnderlineThickness"
block|,
literal|"VV"
block|,
literal|"VVector"
block|,
literal|"Version"
block|,
literal|"W"
block|,
literal|"W0"
block|,
literal|"W0X"
block|,
literal|"W0Y"
block|,
literal|"W1"
block|,
literal|"W1X"
block|,
literal|"W1Y"
block|,
literal|"WX"
block|,
literal|"WY"
block|,
literal|"Weight"
block|,
literal|"WeightVector"
block|,
literal|"XHeight"
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*    * `afm_parser_read_vals' and `afm_parser_next_key' provide    * high-level operations to an AFM_Stream.  The rest of the    * parser functions should use them without accessing the    * AFM_Stream directly.    */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Int
argument_list|)
end_macro
begin_macro
name|afm_parser_read_vals
argument_list|(
argument|AFM_Parser  parser
argument_list|,
argument|AFM_Value   vals
argument_list|,
argument|FT_Int      n
argument_list|)
end_macro
begin_block
block|{
name|AFM_Stream
name|stream
init|=
name|parser
operator|->
name|stream
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|FT_Int
name|i
decl_stmt|;
if|if
condition|(
name|n
operator|>
name|AFM_MAX_ARGUMENTS
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|FT_Offset
name|len
decl_stmt|;
name|AFM_Value
name|val
init|=
name|vals
operator|+
name|i
decl_stmt|;
if|if
condition|(
name|val
operator|->
name|type
operator|==
name|AFM_VALUE_TYPE_STRING
condition|)
name|str
operator|=
name|afm_stream_read_string
argument_list|(
name|stream
argument_list|)
expr_stmt|;
else|else
name|str
operator|=
name|afm_stream_read_one
argument_list|(
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|str
condition|)
break|break;
name|len
operator|=
name|AFM_STREAM_KEY_LEN
argument_list|(
name|stream
argument_list|,
name|str
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|val
operator|->
name|type
condition|)
block|{
case|case
name|AFM_VALUE_TYPE_STRING
case|:
case|case
name|AFM_VALUE_TYPE_NAME
case|:
block|{
name|FT_Memory
name|memory
init|=
name|parser
operator|->
name|memory
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
if|if
condition|(
operator|!
name|FT_QALLOC
argument_list|(
name|val
operator|->
name|u
operator|.
name|s
argument_list|,
name|len
operator|+
literal|1
argument_list|)
condition|)
block|{
name|ft_memcpy
argument_list|(
name|val
operator|->
name|u
operator|.
name|s
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|val
operator|->
name|u
operator|.
name|s
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
break|break;
case|case
name|AFM_VALUE_TYPE_FIXED
case|:
name|val
operator|->
name|u
operator|.
name|f
operator|=
name|PS_Conv_ToFixed
argument_list|(
operator|(
name|FT_Byte
operator|*
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
operator|&
name|str
argument_list|,
operator|(
name|FT_Byte
operator|*
operator|)
name|str
operator|+
name|len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|AFM_VALUE_TYPE_INTEGER
case|:
name|val
operator|->
name|u
operator|.
name|i
operator|=
name|PS_Conv_ToInt
argument_list|(
operator|(
name|FT_Byte
operator|*
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
operator|&
name|str
argument_list|,
operator|(
name|FT_Byte
operator|*
operator|)
name|str
operator|+
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|AFM_VALUE_TYPE_BOOL
case|:
name|val
operator|->
name|u
operator|.
name|b
operator|=
name|FT_BOOL
argument_list|(
name|len
operator|==
literal|4
operator|&&
operator|!
name|ft_strncmp
argument_list|(
name|str
argument_list|,
literal|"true"
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|AFM_VALUE_TYPE_INDEX
case|:
if|if
condition|(
name|parser
operator|->
name|get_index
condition|)
name|val
operator|->
name|u
operator|.
name|i
operator|=
name|parser
operator|->
name|get_index
argument_list|(
name|str
argument_list|,
name|len
argument_list|,
name|parser
operator|->
name|user_data
argument_list|)
expr_stmt|;
else|else
name|val
operator|->
name|u
operator|.
name|i
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
return|return
name|i
return|;
block|}
end_block
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|char*
argument_list|)
end_macro
begin_macro
DECL|function|afm_parser_next_key
name|afm_parser_next_key
argument_list|(
argument|AFM_Parser  parser
argument_list|,
argument|FT_Bool     line
argument_list|,
argument|FT_Offset*  len
argument_list|)
end_macro
begin_block
block|{
name|AFM_Stream
name|stream
init|=
name|parser
operator|->
name|stream
decl_stmt|;
name|char
modifier|*
name|key
init|=
name|NULL
decl_stmt|;
comment|/* make stupid compiler happy */
if|if
condition|(
name|line
condition|)
block|{
while|while
condition|(
literal|1
condition|)
block|{
comment|/* skip current line */
if|if
condition|(
operator|!
name|AFM_STATUS_EOL
argument_list|(
name|stream
argument_list|)
condition|)
name|afm_stream_read_string
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|stream
operator|->
name|status
operator|=
name|AFM_STREAM_STATUS_NORMAL
expr_stmt|;
name|key
operator|=
name|afm_stream_read_one
argument_list|(
name|stream
argument_list|)
expr_stmt|;
comment|/* skip empty line */
if|if
condition|(
operator|!
name|key
operator|&&
operator|!
name|AFM_STATUS_EOF
argument_list|(
name|stream
argument_list|)
operator|&&
name|AFM_STATUS_EOL
argument_list|(
name|stream
argument_list|)
condition|)
continue|continue;
break|break;
block|}
block|}
else|else
block|{
while|while
condition|(
literal|1
condition|)
block|{
comment|/* skip current column */
while|while
condition|(
operator|!
name|AFM_STATUS_EOC
argument_list|(
name|stream
argument_list|)
condition|)
name|afm_stream_read_one
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|stream
operator|->
name|status
operator|=
name|AFM_STREAM_STATUS_NORMAL
expr_stmt|;
name|key
operator|=
name|afm_stream_read_one
argument_list|(
name|stream
argument_list|)
expr_stmt|;
comment|/* skip empty column */
if|if
condition|(
operator|!
name|key
operator|&&
operator|!
name|AFM_STATUS_EOF
argument_list|(
name|stream
argument_list|)
operator|&&
name|AFM_STATUS_EOC
argument_list|(
name|stream
argument_list|)
condition|)
continue|continue;
break|break;
block|}
block|}
if|if
condition|(
name|len
condition|)
operator|*
name|len
operator|=
operator|(
name|key
operator|)
condition|?
operator|(
name|FT_Offset
operator|)
name|AFM_STREAM_KEY_LEN
argument_list|(
name|stream
argument_list|,
name|key
argument_list|)
else|:
literal|0
expr_stmt|;
return|return
name|key
return|;
block|}
end_block
begin_function
specifier|static
name|AFM_Token
DECL|function|afm_tokenize
name|afm_tokenize
parameter_list|(
specifier|const
name|char
modifier|*
name|key
parameter_list|,
name|FT_Offset
name|len
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|N_AFM_TOKENS
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
operator|*
operator|(
name|afm_key_table
index|[
name|n
index|]
operator|)
operator|==
operator|*
name|key
condition|)
block|{
for|for
control|(
init|;
name|n
operator|<
name|N_AFM_TOKENS
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
operator|*
operator|(
name|afm_key_table
index|[
name|n
index|]
operator|)
operator|!=
operator|*
name|key
condition|)
return|return
name|AFM_TOKEN_UNKNOWN
return|;
if|if
condition|(
name|ft_strncmp
argument_list|(
name|afm_key_table
index|[
name|n
index|]
argument_list|,
name|key
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|AFM_Token
operator|)
name|n
return|;
block|}
block|}
block|}
return|return
name|AFM_TOKEN_UNKNOWN
return|;
block|}
end_function
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|afm_parser_init
argument_list|(
argument|AFM_Parser  parser
argument_list|,
argument|FT_Memory   memory
argument_list|,
argument|FT_Byte*    base
argument_list|,
argument|FT_Byte*    limit
argument_list|)
end_macro
begin_block
block|{
name|AFM_Stream
name|stream
init|=
name|NULL
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
if|if
condition|(
name|FT_NEW
argument_list|(
name|stream
argument_list|)
condition|)
return|return
name|error
return|;
name|stream
operator|->
name|cursor
operator|=
name|stream
operator|->
name|base
operator|=
name|base
expr_stmt|;
name|stream
operator|->
name|limit
operator|=
name|limit
expr_stmt|;
comment|/* don't skip the first line during the first call */
name|stream
operator|->
name|status
operator|=
name|AFM_STREAM_STATUS_EOL
expr_stmt|;
name|parser
operator|->
name|memory
operator|=
name|memory
expr_stmt|;
name|parser
operator|->
name|stream
operator|=
name|stream
expr_stmt|;
name|parser
operator|->
name|FontInfo
operator|=
name|NULL
expr_stmt|;
name|parser
operator|->
name|get_index
operator|=
name|NULL
expr_stmt|;
return|return
name|FT_Err_Ok
return|;
block|}
end_block
begin_macro
name|FT_LOCAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|afm_parser_done
name|afm_parser_done
argument_list|(
argument|AFM_Parser  parser
argument_list|)
end_macro
begin_block
block|{
name|FT_Memory
name|memory
init|=
name|parser
operator|->
name|memory
decl_stmt|;
name|FT_FREE
argument_list|(
name|parser
operator|->
name|stream
argument_list|)
expr_stmt|;
block|}
end_block
begin_function
specifier|static
name|FT_Error
DECL|function|afm_parser_read_int
name|afm_parser_read_int
parameter_list|(
name|AFM_Parser
name|parser
parameter_list|,
name|FT_Int
modifier|*
name|aint
parameter_list|)
block|{
name|AFM_ValueRec
name|val
decl_stmt|;
name|val
operator|.
name|type
operator|=
name|AFM_VALUE_TYPE_INTEGER
expr_stmt|;
if|if
condition|(
name|afm_parser_read_vals
argument_list|(
name|parser
argument_list|,
operator|&
name|val
argument_list|,
literal|1
argument_list|)
operator|==
literal|1
condition|)
block|{
operator|*
name|aint
operator|=
name|val
operator|.
name|u
operator|.
name|i
expr_stmt|;
return|return
name|FT_Err_Ok
return|;
block|}
else|else
return|return
name|FT_THROW
argument_list|(
name|Syntax_Error
argument_list|)
return|;
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|afm_parse_track_kern
name|afm_parse_track_kern
parameter_list|(
name|AFM_Parser
name|parser
parameter_list|)
block|{
name|AFM_FontInfo
name|fi
init|=
name|parser
operator|->
name|FontInfo
decl_stmt|;
name|AFM_TrackKern
name|tk
decl_stmt|;
name|char
modifier|*
name|key
decl_stmt|;
name|FT_Offset
name|len
decl_stmt|;
name|int
name|n
init|=
operator|-
literal|1
decl_stmt|;
name|FT_Int
name|tmp
decl_stmt|;
if|if
condition|(
name|afm_parser_read_int
argument_list|(
name|parser
argument_list|,
operator|&
name|tmp
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
if|if
condition|(
name|tmp
operator|<
literal|0
condition|)
goto|goto
name|Fail
goto|;
name|fi
operator|->
name|NumTrackKern
operator|=
operator|(
name|FT_UInt
operator|)
name|tmp
expr_stmt|;
if|if
condition|(
name|fi
operator|->
name|NumTrackKern
condition|)
block|{
name|FT_Memory
name|memory
init|=
name|parser
operator|->
name|memory
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
if|if
condition|(
name|FT_QNEW_ARRAY
argument_list|(
name|fi
operator|->
name|TrackKerns
argument_list|,
name|fi
operator|->
name|NumTrackKern
argument_list|)
condition|)
return|return
name|error
return|;
block|}
while|while
condition|(
operator|(
name|key
operator|=
name|afm_parser_next_key
argument_list|(
name|parser
argument_list|,
literal|1
argument_list|,
operator|&
name|len
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|AFM_ValueRec
name|shared_vals
index|[
literal|5
index|]
decl_stmt|;
switch|switch
condition|(
name|afm_tokenize
argument_list|(
name|key
argument_list|,
name|len
argument_list|)
condition|)
block|{
case|case
name|AFM_TOKEN_TRACKKERN
case|:
name|n
operator|++
expr_stmt|;
if|if
condition|(
name|n
operator|>=
operator|(
name|int
operator|)
name|fi
operator|->
name|NumTrackKern
condition|)
goto|goto
name|Fail
goto|;
name|tk
operator|=
name|fi
operator|->
name|TrackKerns
operator|+
name|n
expr_stmt|;
name|shared_vals
index|[
literal|0
index|]
operator|.
name|type
operator|=
name|AFM_VALUE_TYPE_INTEGER
expr_stmt|;
name|shared_vals
index|[
literal|1
index|]
operator|.
name|type
operator|=
name|AFM_VALUE_TYPE_FIXED
expr_stmt|;
name|shared_vals
index|[
literal|2
index|]
operator|.
name|type
operator|=
name|AFM_VALUE_TYPE_FIXED
expr_stmt|;
name|shared_vals
index|[
literal|3
index|]
operator|.
name|type
operator|=
name|AFM_VALUE_TYPE_FIXED
expr_stmt|;
name|shared_vals
index|[
literal|4
index|]
operator|.
name|type
operator|=
name|AFM_VALUE_TYPE_FIXED
expr_stmt|;
if|if
condition|(
name|afm_parser_read_vals
argument_list|(
name|parser
argument_list|,
name|shared_vals
argument_list|,
literal|5
argument_list|)
operator|!=
literal|5
condition|)
goto|goto
name|Fail
goto|;
name|tk
operator|->
name|degree
operator|=
name|shared_vals
index|[
literal|0
index|]
operator|.
name|u
operator|.
name|i
expr_stmt|;
name|tk
operator|->
name|min_ptsize
operator|=
name|shared_vals
index|[
literal|1
index|]
operator|.
name|u
operator|.
name|f
expr_stmt|;
name|tk
operator|->
name|min_kern
operator|=
name|shared_vals
index|[
literal|2
index|]
operator|.
name|u
operator|.
name|f
expr_stmt|;
name|tk
operator|->
name|max_ptsize
operator|=
name|shared_vals
index|[
literal|3
index|]
operator|.
name|u
operator|.
name|f
expr_stmt|;
name|tk
operator|->
name|max_kern
operator|=
name|shared_vals
index|[
literal|4
index|]
operator|.
name|u
operator|.
name|f
expr_stmt|;
break|break;
case|case
name|AFM_TOKEN_ENDTRACKKERN
case|:
case|case
name|AFM_TOKEN_ENDKERNDATA
case|:
case|case
name|AFM_TOKEN_ENDFONTMETRICS
case|:
name|fi
operator|->
name|NumTrackKern
operator|=
call|(
name|FT_UInt
call|)
argument_list|(
name|n
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|FT_Err_Ok
return|;
case|case
name|AFM_TOKEN_UNKNOWN
case|:
break|break;
default|default:
goto|goto
name|Fail
goto|;
block|}
block|}
name|Fail
label|:
return|return
name|FT_THROW
argument_list|(
name|Syntax_Error
argument_list|)
return|;
block|}
end_function
begin_undef
DECL|macro|KERN_INDEX
undef|#
directive|undef
name|KERN_INDEX
end_undef
begin_define
DECL|macro|KERN_INDEX
define|#
directive|define
name|KERN_INDEX
parameter_list|(
name|g1
parameter_list|,
name|g2
parameter_list|)
value|( ( (FT_ULong)g1<< 16 ) | g2 )
end_define
begin_comment
comment|/* compare two kerning pairs */
end_comment
begin_macro
name|FT_CALLBACK_DEF
argument_list|(
argument|int
argument_list|)
end_macro
begin_macro
DECL|function|afm_compare_kern_pairs
name|afm_compare_kern_pairs
argument_list|(
argument|const void*  a
argument_list|,
argument|const void*  b
argument_list|)
end_macro
begin_block
block|{
name|AFM_KernPair
name|kp1
init|=
operator|(
name|AFM_KernPair
operator|)
name|a
decl_stmt|;
name|AFM_KernPair
name|kp2
init|=
operator|(
name|AFM_KernPair
operator|)
name|b
decl_stmt|;
name|FT_ULong
name|index1
init|=
name|KERN_INDEX
argument_list|(
name|kp1
operator|->
name|index1
argument_list|,
name|kp1
operator|->
name|index2
argument_list|)
decl_stmt|;
name|FT_ULong
name|index2
init|=
name|KERN_INDEX
argument_list|(
name|kp2
operator|->
name|index1
argument_list|,
name|kp2
operator|->
name|index2
argument_list|)
decl_stmt|;
if|if
condition|(
name|index1
operator|>
name|index2
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|index1
operator|<
name|index2
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_block
begin_function
specifier|static
name|FT_Error
DECL|function|afm_parse_kern_pairs
name|afm_parse_kern_pairs
parameter_list|(
name|AFM_Parser
name|parser
parameter_list|)
block|{
name|AFM_FontInfo
name|fi
init|=
name|parser
operator|->
name|FontInfo
decl_stmt|;
name|AFM_KernPair
name|kp
decl_stmt|;
name|char
modifier|*
name|key
decl_stmt|;
name|FT_Offset
name|len
decl_stmt|;
name|int
name|n
init|=
operator|-
literal|1
decl_stmt|;
name|FT_Int
name|tmp
decl_stmt|;
if|if
condition|(
name|afm_parser_read_int
argument_list|(
name|parser
argument_list|,
operator|&
name|tmp
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
if|if
condition|(
name|tmp
operator|<
literal|0
condition|)
goto|goto
name|Fail
goto|;
name|fi
operator|->
name|NumKernPair
operator|=
operator|(
name|FT_UInt
operator|)
name|tmp
expr_stmt|;
if|if
condition|(
name|fi
operator|->
name|NumKernPair
condition|)
block|{
name|FT_Memory
name|memory
init|=
name|parser
operator|->
name|memory
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
if|if
condition|(
name|FT_QNEW_ARRAY
argument_list|(
name|fi
operator|->
name|KernPairs
argument_list|,
name|fi
operator|->
name|NumKernPair
argument_list|)
condition|)
return|return
name|error
return|;
block|}
while|while
condition|(
operator|(
name|key
operator|=
name|afm_parser_next_key
argument_list|(
name|parser
argument_list|,
literal|1
argument_list|,
operator|&
name|len
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|AFM_Token
name|token
init|=
name|afm_tokenize
argument_list|(
name|key
argument_list|,
name|len
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|token
condition|)
block|{
case|case
name|AFM_TOKEN_KP
case|:
case|case
name|AFM_TOKEN_KPX
case|:
case|case
name|AFM_TOKEN_KPY
case|:
block|{
name|FT_Int
name|r
decl_stmt|;
name|AFM_ValueRec
name|shared_vals
index|[
literal|4
index|]
decl_stmt|;
name|n
operator|++
expr_stmt|;
if|if
condition|(
name|n
operator|>=
operator|(
name|int
operator|)
name|fi
operator|->
name|NumKernPair
condition|)
goto|goto
name|Fail
goto|;
name|kp
operator|=
name|fi
operator|->
name|KernPairs
operator|+
name|n
expr_stmt|;
name|shared_vals
index|[
literal|0
index|]
operator|.
name|type
operator|=
name|AFM_VALUE_TYPE_INDEX
expr_stmt|;
name|shared_vals
index|[
literal|1
index|]
operator|.
name|type
operator|=
name|AFM_VALUE_TYPE_INDEX
expr_stmt|;
name|shared_vals
index|[
literal|2
index|]
operator|.
name|type
operator|=
name|AFM_VALUE_TYPE_INTEGER
expr_stmt|;
name|shared_vals
index|[
literal|3
index|]
operator|.
name|type
operator|=
name|AFM_VALUE_TYPE_INTEGER
expr_stmt|;
name|r
operator|=
name|afm_parser_read_vals
argument_list|(
name|parser
argument_list|,
name|shared_vals
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|3
condition|)
goto|goto
name|Fail
goto|;
comment|/* index values can't be negative */
name|kp
operator|->
name|index1
operator|=
name|shared_vals
index|[
literal|0
index|]
operator|.
name|u
operator|.
name|u
expr_stmt|;
name|kp
operator|->
name|index2
operator|=
name|shared_vals
index|[
literal|1
index|]
operator|.
name|u
operator|.
name|u
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|AFM_TOKEN_KPY
condition|)
block|{
name|kp
operator|->
name|x
operator|=
literal|0
expr_stmt|;
name|kp
operator|->
name|y
operator|=
name|shared_vals
index|[
literal|2
index|]
operator|.
name|u
operator|.
name|i
expr_stmt|;
block|}
else|else
block|{
name|kp
operator|->
name|x
operator|=
name|shared_vals
index|[
literal|2
index|]
operator|.
name|u
operator|.
name|i
expr_stmt|;
name|kp
operator|->
name|y
operator|=
operator|(
name|token
operator|==
name|AFM_TOKEN_KP
operator|&&
name|r
operator|==
literal|4
operator|)
condition|?
name|shared_vals
index|[
literal|3
index|]
operator|.
name|u
operator|.
name|i
else|:
literal|0
expr_stmt|;
block|}
block|}
break|break;
case|case
name|AFM_TOKEN_ENDKERNPAIRS
case|:
case|case
name|AFM_TOKEN_ENDKERNDATA
case|:
case|case
name|AFM_TOKEN_ENDFONTMETRICS
case|:
name|fi
operator|->
name|NumKernPair
operator|=
call|(
name|FT_UInt
call|)
argument_list|(
name|n
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ft_qsort
argument_list|(
name|fi
operator|->
name|KernPairs
argument_list|,
name|fi
operator|->
name|NumKernPair
argument_list|,
sizeof|sizeof
argument_list|(
name|AFM_KernPairRec
argument_list|)
argument_list|,
name|afm_compare_kern_pairs
argument_list|)
expr_stmt|;
return|return
name|FT_Err_Ok
return|;
case|case
name|AFM_TOKEN_UNKNOWN
case|:
break|break;
default|default:
goto|goto
name|Fail
goto|;
block|}
block|}
name|Fail
label|:
return|return
name|FT_THROW
argument_list|(
name|Syntax_Error
argument_list|)
return|;
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|afm_parse_kern_data
name|afm_parse_kern_data
parameter_list|(
name|AFM_Parser
name|parser
parameter_list|)
block|{
name|FT_Error
name|error
decl_stmt|;
name|char
modifier|*
name|key
decl_stmt|;
name|FT_Offset
name|len
decl_stmt|;
while|while
condition|(
operator|(
name|key
operator|=
name|afm_parser_next_key
argument_list|(
name|parser
argument_list|,
literal|1
argument_list|,
operator|&
name|len
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
switch|switch
condition|(
name|afm_tokenize
argument_list|(
name|key
argument_list|,
name|len
argument_list|)
condition|)
block|{
case|case
name|AFM_TOKEN_STARTTRACKKERN
case|:
name|error
operator|=
name|afm_parse_track_kern
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
break|break;
case|case
name|AFM_TOKEN_STARTKERNPAIRS
case|:
case|case
name|AFM_TOKEN_STARTKERNPAIRS0
case|:
name|error
operator|=
name|afm_parse_kern_pairs
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
break|break;
case|case
name|AFM_TOKEN_ENDKERNDATA
case|:
case|case
name|AFM_TOKEN_ENDFONTMETRICS
case|:
return|return
name|FT_Err_Ok
return|;
case|case
name|AFM_TOKEN_UNKNOWN
case|:
break|break;
default|default:
goto|goto
name|Fail
goto|;
block|}
block|}
name|Fail
label|:
return|return
name|FT_THROW
argument_list|(
name|Syntax_Error
argument_list|)
return|;
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|afm_parser_skip_section
name|afm_parser_skip_section
parameter_list|(
name|AFM_Parser
name|parser
parameter_list|,
name|FT_Int
name|n
parameter_list|,
name|AFM_Token
name|end_section
parameter_list|)
block|{
name|char
modifier|*
name|key
decl_stmt|;
name|FT_Offset
name|len
decl_stmt|;
while|while
condition|(
name|n
operator|--
operator|>
literal|0
condition|)
block|{
name|key
operator|=
name|afm_parser_next_key
argument_list|(
name|parser
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|key
condition|)
goto|goto
name|Fail
goto|;
block|}
while|while
condition|(
operator|(
name|key
operator|=
name|afm_parser_next_key
argument_list|(
name|parser
argument_list|,
literal|1
argument_list|,
operator|&
name|len
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|AFM_Token
name|token
init|=
name|afm_tokenize
argument_list|(
name|key
argument_list|,
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
name|token
operator|==
name|end_section
operator|||
name|token
operator|==
name|AFM_TOKEN_ENDFONTMETRICS
condition|)
return|return
name|FT_Err_Ok
return|;
block|}
name|Fail
label|:
return|return
name|FT_THROW
argument_list|(
name|Syntax_Error
argument_list|)
return|;
block|}
end_function
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|afm_parser_parse
argument_list|(
argument|AFM_Parser  parser
argument_list|)
end_macro
begin_block
block|{
name|FT_Memory
name|memory
init|=
name|parser
operator|->
name|memory
decl_stmt|;
name|AFM_FontInfo
name|fi
init|=
name|parser
operator|->
name|FontInfo
decl_stmt|;
name|FT_Error
name|error
init|=
name|FT_ERR
argument_list|(
name|Syntax_Error
argument_list|)
decl_stmt|;
name|char
modifier|*
name|key
decl_stmt|;
name|FT_Offset
name|len
decl_stmt|;
name|FT_Int
name|metrics_sets
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|fi
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_Argument
argument_list|)
return|;
name|key
operator|=
name|afm_parser_next_key
argument_list|(
name|parser
argument_list|,
literal|1
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|key
operator|||
name|len
operator|!=
literal|16
operator|||
name|ft_strncmp
argument_list|(
name|key
argument_list|,
literal|"StartFontMetrics"
argument_list|,
literal|16
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FT_THROW
argument_list|(
name|Unknown_File_Format
argument_list|)
return|;
while|while
condition|(
operator|(
name|key
operator|=
name|afm_parser_next_key
argument_list|(
name|parser
argument_list|,
literal|1
argument_list|,
operator|&
name|len
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|AFM_ValueRec
name|shared_vals
index|[
literal|4
index|]
decl_stmt|;
switch|switch
condition|(
name|afm_tokenize
argument_list|(
name|key
argument_list|,
name|len
argument_list|)
condition|)
block|{
case|case
name|AFM_TOKEN_METRICSSETS
case|:
if|if
condition|(
name|afm_parser_read_int
argument_list|(
name|parser
argument_list|,
operator|&
name|metrics_sets
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
if|if
condition|(
name|metrics_sets
operator|!=
literal|0
operator|&&
name|metrics_sets
operator|!=
literal|2
condition|)
block|{
name|error
operator|=
name|FT_THROW
argument_list|(
name|Unimplemented_Feature
argument_list|)
expr_stmt|;
goto|goto
name|Fail
goto|;
block|}
break|break;
case|case
name|AFM_TOKEN_ISCIDFONT
case|:
name|shared_vals
index|[
literal|0
index|]
operator|.
name|type
operator|=
name|AFM_VALUE_TYPE_BOOL
expr_stmt|;
if|if
condition|(
name|afm_parser_read_vals
argument_list|(
name|parser
argument_list|,
name|shared_vals
argument_list|,
literal|1
argument_list|)
operator|!=
literal|1
condition|)
goto|goto
name|Fail
goto|;
name|fi
operator|->
name|IsCIDFont
operator|=
name|shared_vals
index|[
literal|0
index|]
operator|.
name|u
operator|.
name|b
expr_stmt|;
break|break;
case|case
name|AFM_TOKEN_FONTBBOX
case|:
name|shared_vals
index|[
literal|0
index|]
operator|.
name|type
operator|=
name|AFM_VALUE_TYPE_FIXED
expr_stmt|;
name|shared_vals
index|[
literal|1
index|]
operator|.
name|type
operator|=
name|AFM_VALUE_TYPE_FIXED
expr_stmt|;
name|shared_vals
index|[
literal|2
index|]
operator|.
name|type
operator|=
name|AFM_VALUE_TYPE_FIXED
expr_stmt|;
name|shared_vals
index|[
literal|3
index|]
operator|.
name|type
operator|=
name|AFM_VALUE_TYPE_FIXED
expr_stmt|;
if|if
condition|(
name|afm_parser_read_vals
argument_list|(
name|parser
argument_list|,
name|shared_vals
argument_list|,
literal|4
argument_list|)
operator|!=
literal|4
condition|)
goto|goto
name|Fail
goto|;
name|fi
operator|->
name|FontBBox
operator|.
name|xMin
operator|=
name|shared_vals
index|[
literal|0
index|]
operator|.
name|u
operator|.
name|f
expr_stmt|;
name|fi
operator|->
name|FontBBox
operator|.
name|yMin
operator|=
name|shared_vals
index|[
literal|1
index|]
operator|.
name|u
operator|.
name|f
expr_stmt|;
name|fi
operator|->
name|FontBBox
operator|.
name|xMax
operator|=
name|shared_vals
index|[
literal|2
index|]
operator|.
name|u
operator|.
name|f
expr_stmt|;
name|fi
operator|->
name|FontBBox
operator|.
name|yMax
operator|=
name|shared_vals
index|[
literal|3
index|]
operator|.
name|u
operator|.
name|f
expr_stmt|;
break|break;
case|case
name|AFM_TOKEN_ASCENDER
case|:
name|shared_vals
index|[
literal|0
index|]
operator|.
name|type
operator|=
name|AFM_VALUE_TYPE_FIXED
expr_stmt|;
if|if
condition|(
name|afm_parser_read_vals
argument_list|(
name|parser
argument_list|,
name|shared_vals
argument_list|,
literal|1
argument_list|)
operator|!=
literal|1
condition|)
goto|goto
name|Fail
goto|;
name|fi
operator|->
name|Ascender
operator|=
name|shared_vals
index|[
literal|0
index|]
operator|.
name|u
operator|.
name|f
expr_stmt|;
break|break;
case|case
name|AFM_TOKEN_DESCENDER
case|:
name|shared_vals
index|[
literal|0
index|]
operator|.
name|type
operator|=
name|AFM_VALUE_TYPE_FIXED
expr_stmt|;
if|if
condition|(
name|afm_parser_read_vals
argument_list|(
name|parser
argument_list|,
name|shared_vals
argument_list|,
literal|1
argument_list|)
operator|!=
literal|1
condition|)
goto|goto
name|Fail
goto|;
name|fi
operator|->
name|Descender
operator|=
name|shared_vals
index|[
literal|0
index|]
operator|.
name|u
operator|.
name|f
expr_stmt|;
break|break;
case|case
name|AFM_TOKEN_STARTCHARMETRICS
case|:
block|{
name|FT_Int
name|n
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|afm_parser_read_int
argument_list|(
name|parser
argument_list|,
operator|&
name|n
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
name|error
operator|=
name|afm_parser_skip_section
argument_list|(
name|parser
argument_list|,
name|n
argument_list|,
name|AFM_TOKEN_ENDCHARMETRICS
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
block|}
break|break;
case|case
name|AFM_TOKEN_STARTKERNDATA
case|:
name|error
operator|=
name|afm_parse_kern_data
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Fail
goto|;
comment|/* fall through since we only support kern data */
case|case
name|AFM_TOKEN_ENDFONTMETRICS
case|:
return|return
name|FT_Err_Ok
return|;
default|default:
break|break;
block|}
block|}
name|Fail
label|:
name|FT_FREE
argument_list|(
name|fi
operator|->
name|TrackKerns
argument_list|)
expr_stmt|;
name|fi
operator|->
name|NumTrackKern
operator|=
literal|0
expr_stmt|;
name|FT_FREE
argument_list|(
name|fi
operator|->
name|KernPairs
argument_list|)
expr_stmt|;
name|fi
operator|->
name|NumKernPair
operator|=
literal|0
expr_stmt|;
name|fi
operator|->
name|IsCIDFont
operator|=
literal|0
expr_stmt|;
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/* END */
end_comment
end_unit
