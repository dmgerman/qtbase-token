begin_unit
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  t1decode.c                                                             */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*    PostScript Type 1 decoding routines (body).                          */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  Copyright 2000-2015 by                                                 */
end_comment
begin_comment
comment|/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  This file is part of the FreeType project, and may only be used,       */
end_comment
begin_comment
comment|/*  modified, and distributed under the terms of the FreeType project      */
end_comment
begin_comment
comment|/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
end_comment
begin_comment
comment|/*  this file you indicate that you have read the license and              */
end_comment
begin_comment
comment|/*  understand and accept it fully.                                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<ft2build.h>
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_CALC_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_DEBUG_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_POSTSCRIPT_HINTS_H
end_include
begin_include
include|#
directive|include
include|FT_OUTLINE_H
end_include
begin_include
include|#
directive|include
file|"t1decode.h"
end_include
begin_include
include|#
directive|include
file|"psobjs.h"
end_include
begin_include
include|#
directive|include
file|"psauxerr.h"
end_include
begin_comment
comment|/* ensure proper sign extension */
end_comment
begin_define
DECL|macro|Fix2Int
define|#
directive|define
name|Fix2Int
parameter_list|(
name|f
parameter_list|)
value|( (FT_Int)(FT_Short)( (f)>> 16 ) )
end_define
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
end_comment
begin_comment
comment|/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
end_comment
begin_comment
comment|/* messages during execution.                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_undef
DECL|macro|FT_COMPONENT
undef|#
directive|undef
name|FT_COMPONENT
end_undef
begin_define
DECL|macro|FT_COMPONENT
define|#
directive|define
name|FT_COMPONENT
value|trace_t1decode
end_define
begin_typedef
DECL|enum|T1_Operator_
typedef|typedef
enum|enum
name|T1_Operator_
block|{
DECL|enumerator|op_none
name|op_none
init|=
literal|0
block|,
DECL|enumerator|op_endchar
name|op_endchar
block|,
DECL|enumerator|op_hsbw
name|op_hsbw
block|,
DECL|enumerator|op_seac
name|op_seac
block|,
DECL|enumerator|op_sbw
name|op_sbw
block|,
DECL|enumerator|op_closepath
name|op_closepath
block|,
DECL|enumerator|op_hlineto
name|op_hlineto
block|,
DECL|enumerator|op_hmoveto
name|op_hmoveto
block|,
DECL|enumerator|op_hvcurveto
name|op_hvcurveto
block|,
DECL|enumerator|op_rlineto
name|op_rlineto
block|,
DECL|enumerator|op_rmoveto
name|op_rmoveto
block|,
DECL|enumerator|op_rrcurveto
name|op_rrcurveto
block|,
DECL|enumerator|op_vhcurveto
name|op_vhcurveto
block|,
DECL|enumerator|op_vlineto
name|op_vlineto
block|,
DECL|enumerator|op_vmoveto
name|op_vmoveto
block|,
DECL|enumerator|op_dotsection
name|op_dotsection
block|,
DECL|enumerator|op_hstem
name|op_hstem
block|,
DECL|enumerator|op_hstem3
name|op_hstem3
block|,
DECL|enumerator|op_vstem
name|op_vstem
block|,
DECL|enumerator|op_vstem3
name|op_vstem3
block|,
DECL|enumerator|op_div
name|op_div
block|,
DECL|enumerator|op_callothersubr
name|op_callothersubr
block|,
DECL|enumerator|op_callsubr
name|op_callsubr
block|,
DECL|enumerator|op_pop
name|op_pop
block|,
DECL|enumerator|op_return
name|op_return
block|,
DECL|enumerator|op_setcurrentpoint
name|op_setcurrentpoint
block|,
DECL|enumerator|op_unknown15
name|op_unknown15
block|,
DECL|enumerator|op_max
name|op_max
comment|/* never remove this one */
block|}
DECL|typedef|T1_Operator
name|T1_Operator
typedef|;
end_typedef
begin_decl_stmt
specifier|static
DECL|variable|t1_args_count
specifier|const
name|FT_Int
name|t1_args_count
index|[
name|op_max
index|]
init|=
block|{
literal|0
block|,
comment|/* none */
literal|0
block|,
comment|/* endchar */
literal|2
block|,
comment|/* hsbw */
literal|5
block|,
comment|/* seac */
literal|4
block|,
comment|/* sbw */
literal|0
block|,
comment|/* closepath */
literal|1
block|,
comment|/* hlineto */
literal|1
block|,
comment|/* hmoveto */
literal|4
block|,
comment|/* hvcurveto */
literal|2
block|,
comment|/* rlineto */
literal|2
block|,
comment|/* rmoveto */
literal|6
block|,
comment|/* rrcurveto */
literal|4
block|,
comment|/* vhcurveto */
literal|1
block|,
comment|/* vlineto */
literal|1
block|,
comment|/* vmoveto */
literal|0
block|,
comment|/* dotsection */
literal|2
block|,
comment|/* hstem */
literal|6
block|,
comment|/* hstem3 */
literal|2
block|,
comment|/* vstem */
literal|6
block|,
comment|/* vstem3 */
literal|2
block|,
comment|/* div */
operator|-
literal|1
block|,
comment|/* callothersubr */
literal|1
block|,
comment|/* callsubr */
literal|0
block|,
comment|/* pop */
literal|0
block|,
comment|/* return */
literal|2
block|,
comment|/* setcurrentpoint */
literal|2
comment|/* opcode 15 (undocumented and obsolete) */
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    t1_lookup_glyph_by_stdcharcode                                     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Looks up a given glyph by its StandardEncoding charcode.  Used to  */
end_comment
begin_comment
comment|/*    implement the SEAC Type 1 operator.                                */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    face     :: The current face object.                               */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    charcode :: The character code to look for.                        */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    A glyph index in the font face.  Returns -1 if the corresponding   */
end_comment
begin_comment
comment|/*    glyph wasn't found.                                                */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|FT_Int
DECL|function|t1_lookup_glyph_by_stdcharcode
name|t1_lookup_glyph_by_stdcharcode
parameter_list|(
name|T1_Decoder
name|decoder
parameter_list|,
name|FT_Int
name|charcode
parameter_list|)
block|{
name|FT_UInt
name|n
decl_stmt|;
specifier|const
name|FT_String
modifier|*
name|glyph_name
decl_stmt|;
name|FT_Service_PsCMaps
name|psnames
init|=
name|decoder
operator|->
name|psnames
decl_stmt|;
comment|/* check range of standard char code */
if|if
condition|(
name|charcode
operator|<
literal|0
operator|||
name|charcode
operator|>
literal|255
condition|)
return|return
operator|-
literal|1
return|;
name|glyph_name
operator|=
name|psnames
operator|->
name|adobe_std_strings
argument_list|(
name|psnames
operator|->
name|adobe_std_encoding
index|[
name|charcode
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|decoder
operator|->
name|num_glyphs
condition|;
name|n
operator|++
control|)
block|{
name|FT_String
modifier|*
name|name
init|=
operator|(
name|FT_String
operator|*
operator|)
name|decoder
operator|->
name|glyph_names
index|[
name|n
index|]
decl_stmt|;
if|if
condition|(
name|name
operator|&&
name|name
index|[
literal|0
index|]
operator|==
name|glyph_name
index|[
literal|0
index|]
operator|&&
name|ft_strcmp
argument_list|(
name|name
argument_list|,
name|glyph_name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|FT_Int
operator|)
name|n
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    t1operator_seac                                                    */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Implements the `seac' Type 1 operator for a Type 1 decoder.        */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    decoder :: The current CID decoder.                                */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    asb     :: The accent's side bearing.                              */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    adx     :: The horizontal offset of the accent.                    */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    ady     :: The vertical offset of the accent.                      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    bchar   :: The base character's StandardEncoding charcode.         */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    achar   :: The accent character's StandardEncoding charcode.       */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    FreeType error code.  0 means success.                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|t1operator_seac
name|t1operator_seac
parameter_list|(
name|T1_Decoder
name|decoder
parameter_list|,
name|FT_Pos
name|asb
parameter_list|,
name|FT_Pos
name|adx
parameter_list|,
name|FT_Pos
name|ady
parameter_list|,
name|FT_Int
name|bchar
parameter_list|,
name|FT_Int
name|achar
parameter_list|)
block|{
name|FT_Error
name|error
decl_stmt|;
name|FT_Int
name|bchar_index
decl_stmt|,
name|achar_index
decl_stmt|;
if|#
directive|if
literal|0
block|FT_Int       n_base_points;     FT_Outline*  base = decoder->builder.base;
endif|#
directive|endif
name|FT_Vector
name|left_bearing
decl_stmt|,
name|advance
decl_stmt|;
ifdef|#
directive|ifdef
name|FT_CONFIG_OPTION_INCREMENTAL
name|T1_Face
name|face
init|=
operator|(
name|T1_Face
operator|)
name|decoder
operator|->
name|builder
operator|.
name|face
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|decoder
operator|->
name|seac
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"t1operator_seac: invalid nested seac\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|FT_THROW
argument_list|(
name|Syntax_Error
argument_list|)
return|;
block|}
if|if
condition|(
name|decoder
operator|->
name|builder
operator|.
name|metrics_only
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"t1operator_seac: unexpected seac\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|FT_THROW
argument_list|(
name|Syntax_Error
argument_list|)
return|;
block|}
comment|/* seac weirdness */
name|adx
operator|+=
name|decoder
operator|->
name|builder
operator|.
name|left_bearing
operator|.
name|x
expr_stmt|;
comment|/* `glyph_names' is set to 0 for CID fonts which do not */
comment|/* include an encoding.  How can we deal with these?    */
ifdef|#
directive|ifdef
name|FT_CONFIG_OPTION_INCREMENTAL
if|if
condition|(
name|decoder
operator|->
name|glyph_names
operator|==
literal|0
operator|&&
operator|!
name|face
operator|->
name|root
operator|.
name|internal
operator|->
name|incremental_interface
condition|)
else|#
directive|else
if|if
condition|(
name|decoder
operator|->
name|glyph_names
operator|==
literal|0
condition|)
endif|#
directive|endif
comment|/* FT_CONFIG_OPTION_INCREMENTAL */
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"t1operator_seac:"
literal|" glyph names table not available in this font\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|FT_THROW
argument_list|(
name|Syntax_Error
argument_list|)
return|;
block|}
ifdef|#
directive|ifdef
name|FT_CONFIG_OPTION_INCREMENTAL
if|if
condition|(
name|face
operator|->
name|root
operator|.
name|internal
operator|->
name|incremental_interface
condition|)
block|{
comment|/* the caller must handle the font encoding also */
name|bchar_index
operator|=
name|bchar
expr_stmt|;
name|achar_index
operator|=
name|achar
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|bchar_index
operator|=
name|t1_lookup_glyph_by_stdcharcode
argument_list|(
name|decoder
argument_list|,
name|bchar
argument_list|)
expr_stmt|;
name|achar_index
operator|=
name|t1_lookup_glyph_by_stdcharcode
argument_list|(
name|decoder
argument_list|,
name|achar
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bchar_index
operator|<
literal|0
operator|||
name|achar_index
operator|<
literal|0
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"t1operator_seac:"
literal|" invalid seac character code arguments\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|FT_THROW
argument_list|(
name|Syntax_Error
argument_list|)
return|;
block|}
comment|/* if we are trying to load a composite glyph, do not load the */
comment|/* accent character and return the array of subglyphs.         */
if|if
condition|(
name|decoder
operator|->
name|builder
operator|.
name|no_recurse
condition|)
block|{
name|FT_GlyphSlot
name|glyph
init|=
operator|(
name|FT_GlyphSlot
operator|)
name|decoder
operator|->
name|builder
operator|.
name|glyph
decl_stmt|;
name|FT_GlyphLoader
name|loader
init|=
name|glyph
operator|->
name|internal
operator|->
name|loader
decl_stmt|;
name|FT_SubGlyph
name|subg
decl_stmt|;
comment|/* reallocate subglyph array if necessary */
name|error
operator|=
name|FT_GlyphLoader_CheckSubGlyphs
argument_list|(
name|loader
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|subg
operator|=
name|loader
operator|->
name|current
operator|.
name|subglyphs
expr_stmt|;
comment|/* subglyph 0 = base character */
name|subg
operator|->
name|index
operator|=
name|bchar_index
expr_stmt|;
name|subg
operator|->
name|flags
operator|=
name|FT_SUBGLYPH_FLAG_ARGS_ARE_XY_VALUES
operator||
name|FT_SUBGLYPH_FLAG_USE_MY_METRICS
expr_stmt|;
name|subg
operator|->
name|arg1
operator|=
literal|0
expr_stmt|;
name|subg
operator|->
name|arg2
operator|=
literal|0
expr_stmt|;
name|subg
operator|++
expr_stmt|;
comment|/* subglyph 1 = accent character */
name|subg
operator|->
name|index
operator|=
name|achar_index
expr_stmt|;
name|subg
operator|->
name|flags
operator|=
name|FT_SUBGLYPH_FLAG_ARGS_ARE_XY_VALUES
expr_stmt|;
name|subg
operator|->
name|arg1
operator|=
operator|(
name|FT_Int
operator|)
name|FIXED_TO_INT
argument_list|(
name|adx
operator|-
name|asb
argument_list|)
expr_stmt|;
name|subg
operator|->
name|arg2
operator|=
operator|(
name|FT_Int
operator|)
name|FIXED_TO_INT
argument_list|(
name|ady
argument_list|)
expr_stmt|;
comment|/* set up remaining glyph fields */
name|glyph
operator|->
name|num_subglyphs
operator|=
literal|2
expr_stmt|;
name|glyph
operator|->
name|subglyphs
operator|=
name|loader
operator|->
name|base
operator|.
name|subglyphs
expr_stmt|;
name|glyph
operator|->
name|format
operator|=
name|FT_GLYPH_FORMAT_COMPOSITE
expr_stmt|;
name|loader
operator|->
name|current
operator|.
name|num_subglyphs
operator|=
literal|2
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* First load `bchar' in builder */
comment|/* now load the unscaled outline */
name|FT_GlyphLoader_Prepare
argument_list|(
name|decoder
operator|->
name|builder
operator|.
name|loader
argument_list|)
expr_stmt|;
comment|/* prepare loader */
comment|/* the seac operator must not be nested */
name|decoder
operator|->
name|seac
operator|=
name|TRUE
expr_stmt|;
name|error
operator|=
name|t1_decoder_parse_glyph
argument_list|(
name|decoder
argument_list|,
operator|(
name|FT_UInt
operator|)
name|bchar_index
argument_list|)
expr_stmt|;
name|decoder
operator|->
name|seac
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
comment|/* save the left bearing and width of the base character */
comment|/* as they will be erased by the next load.              */
name|left_bearing
operator|=
name|decoder
operator|->
name|builder
operator|.
name|left_bearing
expr_stmt|;
name|advance
operator|=
name|decoder
operator|->
name|builder
operator|.
name|advance
expr_stmt|;
name|decoder
operator|->
name|builder
operator|.
name|left_bearing
operator|.
name|x
operator|=
literal|0
expr_stmt|;
name|decoder
operator|->
name|builder
operator|.
name|left_bearing
operator|.
name|y
operator|=
literal|0
expr_stmt|;
name|decoder
operator|->
name|builder
operator|.
name|pos_x
operator|=
name|adx
operator|-
name|asb
expr_stmt|;
name|decoder
operator|->
name|builder
operator|.
name|pos_y
operator|=
name|ady
expr_stmt|;
comment|/* Now load `achar' on top of */
comment|/* the base outline           */
comment|/* the seac operator must not be nested */
name|decoder
operator|->
name|seac
operator|=
name|TRUE
expr_stmt|;
name|error
operator|=
name|t1_decoder_parse_glyph
argument_list|(
name|decoder
argument_list|,
operator|(
name|FT_UInt
operator|)
name|achar_index
argument_list|)
expr_stmt|;
name|decoder
operator|->
name|seac
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
comment|/* restore the left side bearing and   */
comment|/* advance width of the base character */
name|decoder
operator|->
name|builder
operator|.
name|left_bearing
operator|=
name|left_bearing
expr_stmt|;
name|decoder
operator|->
name|builder
operator|.
name|advance
operator|=
name|advance
expr_stmt|;
name|decoder
operator|->
name|builder
operator|.
name|pos_x
operator|=
literal|0
expr_stmt|;
name|decoder
operator|->
name|builder
operator|.
name|pos_y
operator|=
literal|0
expr_stmt|;
name|Exit
label|:
return|return
name|error
return|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    t1_decoder_parse_charstrings                                       */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Parses a given Type 1 charstrings program.                         */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    decoder         :: The current Type 1 decoder.                     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    charstring_base :: The base address of the charstring stream.      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    charstring_len  :: The length in bytes of the charstring stream.   */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    FreeType error code.  0 means success.                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|t1_decoder_parse_charstrings
argument_list|(
argument|T1_Decoder  decoder
argument_list|,
argument|FT_Byte*    charstring_base
argument_list|,
argument|FT_UInt     charstring_len
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
decl_stmt|;
name|T1_Decoder_Zone
name|zone
decl_stmt|;
name|FT_Byte
modifier|*
name|ip
decl_stmt|;
name|FT_Byte
modifier|*
name|limit
decl_stmt|;
name|T1_Builder
name|builder
init|=
operator|&
name|decoder
operator|->
name|builder
decl_stmt|;
name|FT_Pos
name|x
decl_stmt|,
name|y
decl_stmt|,
name|orig_x
decl_stmt|,
name|orig_y
decl_stmt|;
name|FT_Int
name|known_othersubr_result_cnt
init|=
literal|0
decl_stmt|;
name|FT_Int
name|unknown_othersubr_result_cnt
init|=
literal|0
decl_stmt|;
name|FT_Bool
name|large_int
decl_stmt|;
name|FT_Fixed
name|seed
decl_stmt|;
name|T1_Hints_Funcs
name|hinter
decl_stmt|;
ifdef|#
directive|ifdef
name|FT_DEBUG_LEVEL_TRACE
name|FT_Bool
name|bol
init|=
name|TRUE
decl_stmt|;
endif|#
directive|endif
comment|/* compute random seed from stack address of parameter */
name|seed
operator|=
call|(
name|FT_Fixed
call|)
argument_list|(
operator|(
call|(
name|FT_Offset
call|)
argument_list|(
name|char
operator|*
argument_list|)
operator|&
name|seed
operator|^
call|(
name|FT_Offset
call|)
argument_list|(
name|char
operator|*
argument_list|)
operator|&
name|decoder
operator|^
call|(
name|FT_Offset
call|)
argument_list|(
name|char
operator|*
argument_list|)
operator|&
name|charstring_base
operator|)
operator|&
name|FT_ULONG_MAX
argument_list|)
expr_stmt|;
name|seed
operator|=
operator|(
name|seed
operator|^
operator|(
name|seed
operator|>>
literal|10
operator|)
operator|^
operator|(
name|seed
operator|>>
literal|20
operator|)
operator|)
operator|&
literal|0xFFFFL
expr_stmt|;
if|if
condition|(
name|seed
operator|==
literal|0
condition|)
name|seed
operator|=
literal|0x7384
expr_stmt|;
comment|/* First of all, initialize the decoder */
name|decoder
operator|->
name|top
operator|=
name|decoder
operator|->
name|stack
expr_stmt|;
name|decoder
operator|->
name|zone
operator|=
name|decoder
operator|->
name|zones
expr_stmt|;
name|zone
operator|=
name|decoder
operator|->
name|zones
expr_stmt|;
name|builder
operator|->
name|parse_state
operator|=
name|T1_Parse_Start
expr_stmt|;
name|hinter
operator|=
operator|(
name|T1_Hints_Funcs
operator|)
name|builder
operator|->
name|hints_funcs
expr_stmt|;
comment|/* a font that reads BuildCharArray without setting */
comment|/* its values first is buggy, but ...               */
name|FT_ASSERT
argument_list|(
operator|(
name|decoder
operator|->
name|len_buildchar
operator|==
literal|0
operator|)
operator|==
operator|(
name|decoder
operator|->
name|buildchar
operator|==
name|NULL
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|decoder
operator|->
name|buildchar
operator|&&
name|decoder
operator|->
name|len_buildchar
operator|>
literal|0
condition|)
name|ft_memset
argument_list|(
operator|&
name|decoder
operator|->
name|buildchar
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|decoder
operator|->
name|buildchar
index|[
literal|0
index|]
argument_list|)
operator|*
name|decoder
operator|->
name|len_buildchar
argument_list|)
expr_stmt|;
name|FT_TRACE4
argument_list|(
operator|(
literal|"\n"
literal|"Start charstring\n"
operator|)
argument_list|)
expr_stmt|;
name|zone
operator|->
name|base
operator|=
name|charstring_base
expr_stmt|;
name|limit
operator|=
name|zone
operator|->
name|limit
operator|=
name|charstring_base
operator|+
name|charstring_len
expr_stmt|;
name|ip
operator|=
name|zone
operator|->
name|cursor
operator|=
name|zone
operator|->
name|base
expr_stmt|;
name|error
operator|=
name|FT_Err_Ok
expr_stmt|;
name|x
operator|=
name|orig_x
operator|=
name|builder
operator|->
name|pos_x
expr_stmt|;
name|y
operator|=
name|orig_y
operator|=
name|builder
operator|->
name|pos_y
expr_stmt|;
comment|/* begin hints recording session, if any */
if|if
condition|(
name|hinter
condition|)
name|hinter
operator|->
name|open
argument_list|(
name|hinter
operator|->
name|hints
argument_list|)
expr_stmt|;
name|large_int
operator|=
name|FALSE
expr_stmt|;
comment|/* now, execute loop */
while|while
condition|(
name|ip
operator|<
name|limit
condition|)
block|{
name|FT_Long
modifier|*
name|top
init|=
name|decoder
operator|->
name|top
decl_stmt|;
name|T1_Operator
name|op
init|=
name|op_none
decl_stmt|;
name|FT_Int32
name|value
init|=
literal|0
decl_stmt|;
name|FT_ASSERT
argument_list|(
name|known_othersubr_result_cnt
operator|==
literal|0
operator|||
name|unknown_othersubr_result_cnt
operator|==
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FT_DEBUG_LEVEL_TRACE
if|if
condition|(
name|bol
condition|)
block|{
name|FT_TRACE5
argument_list|(
operator|(
literal|" (%d)"
operator|,
name|decoder
operator|->
name|top
operator|-
name|decoder
operator|->
name|stack
operator|)
argument_list|)
expr_stmt|;
name|bol
operator|=
name|FALSE
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*********************************************************************/
comment|/*                                                                   */
comment|/* Decode operator or operand                                        */
comment|/*                                                                   */
comment|/*                                                                   */
comment|/* first of all, decompress operator or value */
switch|switch
condition|(
operator|*
name|ip
operator|++
condition|)
block|{
case|case
literal|1
case|:
name|op
operator|=
name|op_hstem
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|op
operator|=
name|op_vstem
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|op
operator|=
name|op_vmoveto
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|op
operator|=
name|op_rlineto
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|op
operator|=
name|op_hlineto
expr_stmt|;
break|break;
case|case
literal|7
case|:
name|op
operator|=
name|op_vlineto
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|op
operator|=
name|op_rrcurveto
expr_stmt|;
break|break;
case|case
literal|9
case|:
name|op
operator|=
name|op_closepath
expr_stmt|;
break|break;
case|case
literal|10
case|:
name|op
operator|=
name|op_callsubr
expr_stmt|;
break|break;
case|case
literal|11
case|:
name|op
operator|=
name|op_return
expr_stmt|;
break|break;
case|case
literal|13
case|:
name|op
operator|=
name|op_hsbw
expr_stmt|;
break|break;
case|case
literal|14
case|:
name|op
operator|=
name|op_endchar
expr_stmt|;
break|break;
case|case
literal|15
case|:
comment|/* undocumented, obsolete operator */
name|op
operator|=
name|op_unknown15
expr_stmt|;
break|break;
case|case
literal|21
case|:
name|op
operator|=
name|op_rmoveto
expr_stmt|;
break|break;
case|case
literal|22
case|:
name|op
operator|=
name|op_hmoveto
expr_stmt|;
break|break;
case|case
literal|30
case|:
name|op
operator|=
name|op_vhcurveto
expr_stmt|;
break|break;
case|case
literal|31
case|:
name|op
operator|=
name|op_hvcurveto
expr_stmt|;
break|break;
case|case
literal|12
case|:
if|if
condition|(
name|ip
operator|>
name|limit
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"t1_decoder_parse_charstrings:"
literal|" invalid escape (12+EOF)\n"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|Syntax_Error
goto|;
block|}
switch|switch
condition|(
operator|*
name|ip
operator|++
condition|)
block|{
case|case
literal|0
case|:
name|op
operator|=
name|op_dotsection
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|op
operator|=
name|op_vstem3
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|op
operator|=
name|op_hstem3
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|op
operator|=
name|op_seac
expr_stmt|;
break|break;
case|case
literal|7
case|:
name|op
operator|=
name|op_sbw
expr_stmt|;
break|break;
case|case
literal|12
case|:
name|op
operator|=
name|op_div
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|op
operator|=
name|op_callothersubr
expr_stmt|;
break|break;
case|case
literal|17
case|:
name|op
operator|=
name|op_pop
expr_stmt|;
break|break;
case|case
literal|33
case|:
name|op
operator|=
name|op_setcurrentpoint
expr_stmt|;
break|break;
default|default:
name|FT_ERROR
argument_list|(
operator|(
literal|"t1_decoder_parse_charstrings:"
literal|" invalid escape (12+%d)\n"
operator|,
name|ip
index|[
operator|-
literal|1
index|]
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|Syntax_Error
goto|;
block|}
break|break;
case|case
literal|255
case|:
comment|/* four bytes integer */
if|if
condition|(
name|ip
operator|+
literal|4
operator|>
name|limit
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"t1_decoder_parse_charstrings:"
literal|" unexpected EOF in integer\n"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|Syntax_Error
goto|;
block|}
name|value
operator|=
call|(
name|FT_Int32
call|)
argument_list|(
operator|(
operator|(
name|FT_UInt32
operator|)
name|ip
index|[
literal|0
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
name|FT_UInt32
operator|)
name|ip
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|FT_UInt32
operator|)
name|ip
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|FT_UInt32
operator|)
name|ip
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|ip
operator|+=
literal|4
expr_stmt|;
comment|/* According to the specification, values> 32000 or< -32000 must */
comment|/* be followed by a `div' operator to make the result be in the    */
comment|/* range [-32000;32000].  We expect that the second argument of    */
comment|/* `div' is not a large number.  Additionally, we don't handle     */
comment|/* stuff like `<large1><large2><num> div<num> div' or           */
comment|/*<large1><large2><num> div div'.  This is probably not allowed */
comment|/* anyway.                                                         */
if|if
condition|(
name|value
operator|>
literal|32000
operator|||
name|value
operator|<
operator|-
literal|32000
condition|)
block|{
if|if
condition|(
name|large_int
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"t1_decoder_parse_charstrings:"
literal|" no `div' after large integer\n"
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
name|large_int
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|large_int
condition|)
name|value
operator|=
call|(
name|FT_Int32
call|)
argument_list|(
operator|(
name|FT_UInt32
operator|)
name|value
operator|<<
literal|16
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
if|if
condition|(
name|ip
index|[
operator|-
literal|1
index|]
operator|>=
literal|32
condition|)
block|{
if|if
condition|(
name|ip
index|[
operator|-
literal|1
index|]
operator|<
literal|247
condition|)
name|value
operator|=
operator|(
name|FT_Int32
operator|)
name|ip
index|[
operator|-
literal|1
index|]
operator|-
literal|139
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|++
name|ip
operator|>
name|limit
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"t1_decoder_parse_charstrings:"
literal|" unexpected EOF in integer\n"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|Syntax_Error
goto|;
block|}
if|if
condition|(
name|ip
index|[
operator|-
literal|2
index|]
operator|<
literal|251
condition|)
name|value
operator|=
operator|(
operator|(
name|ip
index|[
operator|-
literal|2
index|]
operator|-
literal|247
operator|)
operator|*
literal|256
operator|)
operator|+
name|ip
index|[
operator|-
literal|1
index|]
operator|+
literal|108
expr_stmt|;
else|else
name|value
operator|=
operator|-
operator|(
operator|(
operator|(
name|ip
index|[
operator|-
literal|2
index|]
operator|-
literal|251
operator|)
operator|*
literal|256
operator|)
operator|+
name|ip
index|[
operator|-
literal|1
index|]
operator|+
literal|108
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|large_int
condition|)
name|value
operator|=
call|(
name|FT_Int32
call|)
argument_list|(
operator|(
name|FT_UInt32
operator|)
name|value
operator|<<
literal|16
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"t1_decoder_parse_charstrings:"
literal|" invalid byte (%d)\n"
operator|,
name|ip
index|[
operator|-
literal|1
index|]
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|Syntax_Error
goto|;
block|}
block|}
if|if
condition|(
name|unknown_othersubr_result_cnt
operator|>
literal|0
condition|)
block|{
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|op_callsubr
case|:
case|case
name|op_return
case|:
case|case
name|op_none
case|:
case|case
name|op_pop
case|:
break|break;
default|default:
comment|/* all operands have been transferred by previous pops */
name|unknown_othersubr_result_cnt
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|large_int
operator|&&
operator|!
operator|(
name|op
operator|==
name|op_none
operator|||
name|op
operator|==
name|op_div
operator|)
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"t1_decoder_parse_charstrings:"
literal|" no `div' after large integer\n"
operator|)
argument_list|)
expr_stmt|;
name|large_int
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/*********************************************************************/
comment|/*                                                                   */
comment|/*  Push value on stack, or process operator                         */
comment|/*                                                                   */
comment|/*                                                                   */
if|if
condition|(
name|op
operator|==
name|op_none
condition|)
block|{
if|if
condition|(
name|top
operator|-
name|decoder
operator|->
name|stack
operator|>=
name|T1_MAX_CHARSTRINGS_OPERANDS
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"t1_decoder_parse_charstrings: stack overflow\n"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|Syntax_Error
goto|;
block|}
ifdef|#
directive|ifdef
name|FT_DEBUG_LEVEL_TRACE
if|if
condition|(
name|large_int
condition|)
name|FT_TRACE4
argument_list|(
operator|(
literal|" %ld"
operator|,
name|value
operator|)
argument_list|)
expr_stmt|;
else|else
name|FT_TRACE4
argument_list|(
operator|(
literal|" %ld"
operator|,
name|Fix2Int
argument_list|(
name|value
argument_list|)
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|top
operator|++
operator|=
name|value
expr_stmt|;
name|decoder
operator|->
name|top
operator|=
name|top
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|==
name|op_callothersubr
condition|)
comment|/* callothersubr */
block|{
name|FT_Int
name|subr_no
decl_stmt|;
name|FT_Int
name|arg_cnt
decl_stmt|;
ifdef|#
directive|ifdef
name|FT_DEBUG_LEVEL_TRACE
name|FT_TRACE4
argument_list|(
operator|(
literal|" callothersubr\n"
operator|)
argument_list|)
expr_stmt|;
name|bol
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|top
operator|-
name|decoder
operator|->
name|stack
operator|<
literal|2
condition|)
goto|goto
name|Stack_Underflow
goto|;
name|top
operator|-=
literal|2
expr_stmt|;
name|subr_no
operator|=
name|Fix2Int
argument_list|(
name|top
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|arg_cnt
operator|=
name|Fix2Int
argument_list|(
name|top
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/***********************************************************/
comment|/*                                                         */
comment|/* remove all operands to callothersubr from the stack     */
comment|/*                                                         */
comment|/* for handled othersubrs, where we know the number of     */
comment|/* arguments, we increase the stack by the value of        */
comment|/* known_othersubr_result_cnt                              */
comment|/*                                                         */
comment|/* for unhandled othersubrs the following pops adjust the  */
comment|/* stack pointer as necessary                              */
if|if
condition|(
name|arg_cnt
operator|>
name|top
operator|-
name|decoder
operator|->
name|stack
condition|)
goto|goto
name|Stack_Underflow
goto|;
name|top
operator|-=
name|arg_cnt
expr_stmt|;
name|known_othersubr_result_cnt
operator|=
literal|0
expr_stmt|;
name|unknown_othersubr_result_cnt
operator|=
literal|0
expr_stmt|;
comment|/* XXX TODO: The checks to `arg_count ==<whatever>'       */
comment|/* might not be correct; an othersubr expects a certain    */
comment|/* number of operands on the PostScript stack (as opposed  */
comment|/* to the T1 stack) but it doesn't have to put them there  */
comment|/* by itself; previous othersubrs might have left the      */
comment|/* operands there if they were not followed by an          */
comment|/* appropriate number of pops                              */
comment|/*                                                         */
comment|/* On the other hand, Adobe Reader 7.0.8 for Linux doesn't */
comment|/* accept a font that contains charstrings like            */
comment|/*                                                         */
comment|/*     100 200 2 20 callothersubr                          */
comment|/*     300 1 20 callothersubr pop                          */
comment|/*                                                         */
comment|/* Perhaps this is the reason why BuildCharArray exists.   */
switch|switch
condition|(
name|subr_no
condition|)
block|{
case|case
literal|0
case|:
comment|/* end flex feature */
if|if
condition|(
name|arg_cnt
operator|!=
literal|3
condition|)
goto|goto
name|Unexpected_OtherSubr
goto|;
if|if
condition|(
name|decoder
operator|->
name|flex_state
operator|==
literal|0
operator|||
name|decoder
operator|->
name|num_flex_vectors
operator|!=
literal|7
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"t1_decoder_parse_charstrings:"
literal|" unexpected flex end\n"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|Syntax_Error
goto|;
block|}
comment|/* the two `results' are popped by the following setcurrentpoint */
name|top
index|[
literal|0
index|]
operator|=
name|x
expr_stmt|;
name|top
index|[
literal|1
index|]
operator|=
name|y
expr_stmt|;
name|known_othersubr_result_cnt
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* start flex feature */
if|if
condition|(
name|arg_cnt
operator|!=
literal|0
condition|)
goto|goto
name|Unexpected_OtherSubr
goto|;
name|decoder
operator|->
name|flex_state
operator|=
literal|1
expr_stmt|;
name|decoder
operator|->
name|num_flex_vectors
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|t1_builder_start_point
argument_list|(
name|builder
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
operator|)
operator|!=
name|FT_Err_Ok
operator|||
operator|(
name|error
operator|=
name|t1_builder_check_points
argument_list|(
name|builder
argument_list|,
literal|6
argument_list|)
operator|)
operator|!=
name|FT_Err_Ok
condition|)
goto|goto
name|Fail
goto|;
break|break;
case|case
literal|2
case|:
comment|/* add flex vectors */
block|{
name|FT_Int
name|idx
decl_stmt|;
if|if
condition|(
name|arg_cnt
operator|!=
literal|0
condition|)
goto|goto
name|Unexpected_OtherSubr
goto|;
if|if
condition|(
name|decoder
operator|->
name|flex_state
operator|==
literal|0
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"t1_decoder_parse_charstrings:"
literal|" missing flex start\n"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|Syntax_Error
goto|;
block|}
comment|/* note that we should not add a point for index 0; */
comment|/* this will move our current position to the flex  */
comment|/* point without adding any point to the outline    */
name|idx
operator|=
name|decoder
operator|->
name|num_flex_vectors
operator|++
expr_stmt|;
if|if
condition|(
name|idx
operator|>
literal|0
operator|&&
name|idx
operator|<
literal|7
condition|)
name|t1_builder_add_point
argument_list|(
name|builder
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
call|(
name|FT_Byte
call|)
argument_list|(
name|idx
operator|==
literal|3
operator|||
name|idx
operator|==
literal|6
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|3
case|:
comment|/* change hints */
if|if
condition|(
name|arg_cnt
operator|!=
literal|1
condition|)
goto|goto
name|Unexpected_OtherSubr
goto|;
name|known_othersubr_result_cnt
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|hinter
condition|)
name|hinter
operator|->
name|reset
argument_list|(
name|hinter
operator|->
name|hints
argument_list|,
operator|(
name|FT_UInt
operator|)
name|builder
operator|->
name|current
operator|->
name|n_points
argument_list|)
expr_stmt|;
break|break;
case|case
literal|12
case|:
case|case
literal|13
case|:
comment|/* counter control hints, clear stack */
name|top
operator|=
name|decoder
operator|->
name|stack
expr_stmt|;
break|break;
case|case
literal|14
case|:
case|case
literal|15
case|:
case|case
literal|16
case|:
case|case
literal|17
case|:
case|case
literal|18
case|:
comment|/* multiple masters */
block|{
name|PS_Blend
name|blend
init|=
name|decoder
operator|->
name|blend
decl_stmt|;
name|FT_UInt
name|num_points
decl_stmt|,
name|nn
decl_stmt|,
name|mm
decl_stmt|;
name|FT_Long
modifier|*
name|delta
decl_stmt|;
name|FT_Long
modifier|*
name|values
decl_stmt|;
if|if
condition|(
operator|!
name|blend
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"t1_decoder_parse_charstrings:"
literal|" unexpected multiple masters operator\n"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|Syntax_Error
goto|;
block|}
name|num_points
operator|=
operator|(
name|FT_UInt
operator|)
name|subr_no
operator|-
literal|13
operator|+
operator|(
name|subr_no
operator|==
literal|18
operator|)
expr_stmt|;
if|if
condition|(
name|arg_cnt
operator|!=
call|(
name|FT_Int
call|)
argument_list|(
name|num_points
operator|*
name|blend
operator|->
name|num_designs
argument_list|)
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"t1_decoder_parse_charstrings:"
literal|" incorrect number of multiple masters arguments\n"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|Syntax_Error
goto|;
block|}
comment|/* We want to compute                                    */
comment|/*                                                       */
comment|/*   a0*w0 + a1*w1 + ... + ak*wk                         */
comment|/*                                                       */
comment|/* but we only have a0, a1-a0, a2-a0, ..., ak-a0.        */
comment|/*                                                       */
comment|/* However, given that w0 + w1 + ... + wk == 1, we can   */
comment|/* rewrite it easily as                                  */
comment|/*                                                       */
comment|/*   a0 + (a1-a0)*w1 + (a2-a0)*w2 + ... + (ak-a0)*wk     */
comment|/*                                                       */
comment|/* where k == num_designs-1.                             */
comment|/*                                                       */
comment|/* I guess that's why it's written in this `compact'     */
comment|/* form.                                                 */
comment|/*                                                       */
name|delta
operator|=
name|top
operator|+
name|num_points
expr_stmt|;
name|values
operator|=
name|top
expr_stmt|;
for|for
control|(
name|nn
operator|=
literal|0
init|;
name|nn
operator|<
name|num_points
condition|;
name|nn
operator|++
control|)
block|{
name|FT_Long
name|tmp
init|=
name|values
index|[
literal|0
index|]
decl_stmt|;
for|for
control|(
name|mm
operator|=
literal|1
init|;
name|mm
operator|<
name|blend
operator|->
name|num_designs
condition|;
name|mm
operator|++
control|)
name|tmp
operator|+=
name|FT_MulFix
argument_list|(
operator|*
name|delta
operator|++
argument_list|,
name|blend
operator|->
name|weight_vector
index|[
name|mm
index|]
argument_list|)
expr_stmt|;
operator|*
name|values
operator|++
operator|=
name|tmp
expr_stmt|;
block|}
name|known_othersubr_result_cnt
operator|=
operator|(
name|FT_Int
operator|)
name|num_points
expr_stmt|;
break|break;
block|}
case|case
literal|19
case|:
comment|/*<idx> 1 19 callothersubr                             */
comment|/* => replace elements starting from index cvi(<idx> ) */
comment|/*    of BuildCharArray with WeightVector               */
block|{
name|FT_Int
name|idx
decl_stmt|;
name|PS_Blend
name|blend
init|=
name|decoder
operator|->
name|blend
decl_stmt|;
if|if
condition|(
name|arg_cnt
operator|!=
literal|1
operator|||
name|blend
operator|==
name|NULL
condition|)
goto|goto
name|Unexpected_OtherSubr
goto|;
name|idx
operator|=
name|Fix2Int
argument_list|(
name|top
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|<
literal|0
operator|||
operator|(
name|FT_UInt
operator|)
name|idx
operator|+
name|blend
operator|->
name|num_designs
operator|>
name|decoder
operator|->
name|len_buildchar
condition|)
goto|goto
name|Unexpected_OtherSubr
goto|;
name|ft_memcpy
argument_list|(
operator|&
name|decoder
operator|->
name|buildchar
index|[
name|idx
index|]
argument_list|,
name|blend
operator|->
name|weight_vector
argument_list|,
name|blend
operator|->
name|num_designs
operator|*
sizeof|sizeof
argument_list|(
name|blend
operator|->
name|weight_vector
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|20
case|:
comment|/*<arg1><arg2> 2 20 callothersubr pop   */
comment|/* ==> push<arg1> +<arg2> onto T1 stack */
if|if
condition|(
name|arg_cnt
operator|!=
literal|2
condition|)
goto|goto
name|Unexpected_OtherSubr
goto|;
name|top
index|[
literal|0
index|]
operator|+=
name|top
index|[
literal|1
index|]
expr_stmt|;
comment|/* XXX (over|under)flow */
name|known_othersubr_result_cnt
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|21
case|:
comment|/*<arg1><arg2> 2 21 callothersubr pop   */
comment|/* ==> push<arg1> -<arg2> onto T1 stack */
if|if
condition|(
name|arg_cnt
operator|!=
literal|2
condition|)
goto|goto
name|Unexpected_OtherSubr
goto|;
name|top
index|[
literal|0
index|]
operator|-=
name|top
index|[
literal|1
index|]
expr_stmt|;
comment|/* XXX (over|under)flow */
name|known_othersubr_result_cnt
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|22
case|:
comment|/*<arg1><arg2> 2 22 callothersubr pop   */
comment|/* ==> push<arg1> *<arg2> onto T1 stack */
if|if
condition|(
name|arg_cnt
operator|!=
literal|2
condition|)
goto|goto
name|Unexpected_OtherSubr
goto|;
name|top
index|[
literal|0
index|]
operator|=
name|FT_MulFix
argument_list|(
name|top
index|[
literal|0
index|]
argument_list|,
name|top
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|known_othersubr_result_cnt
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|23
case|:
comment|/*<arg1><arg2> 2 23 callothersubr pop   */
comment|/* ==> push<arg1> /<arg2> onto T1 stack */
if|if
condition|(
name|arg_cnt
operator|!=
literal|2
operator|||
name|top
index|[
literal|1
index|]
operator|==
literal|0
condition|)
goto|goto
name|Unexpected_OtherSubr
goto|;
name|top
index|[
literal|0
index|]
operator|=
name|FT_DivFix
argument_list|(
name|top
index|[
literal|0
index|]
argument_list|,
name|top
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|known_othersubr_result_cnt
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|24
case|:
comment|/*<val><idx> 2 24 callothersubr               */
comment|/* ==> set BuildCharArray[cvi(<idx> )] =<val> */
block|{
name|FT_Int
name|idx
decl_stmt|;
name|PS_Blend
name|blend
init|=
name|decoder
operator|->
name|blend
decl_stmt|;
if|if
condition|(
name|arg_cnt
operator|!=
literal|2
operator|||
name|blend
operator|==
name|NULL
condition|)
goto|goto
name|Unexpected_OtherSubr
goto|;
name|idx
operator|=
name|Fix2Int
argument_list|(
name|top
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|<
literal|0
operator|||
operator|(
name|FT_UInt
operator|)
name|idx
operator|>=
name|decoder
operator|->
name|len_buildchar
condition|)
goto|goto
name|Unexpected_OtherSubr
goto|;
name|decoder
operator|->
name|buildchar
index|[
name|idx
index|]
operator|=
name|top
index|[
literal|0
index|]
expr_stmt|;
block|}
break|break;
case|case
literal|25
case|:
comment|/*<idx> 1 25 callothersubr pop        */
comment|/* ==> push BuildCharArray[cvi( idx )] */
comment|/*     onto T1 stack                   */
block|{
name|FT_Int
name|idx
decl_stmt|;
name|PS_Blend
name|blend
init|=
name|decoder
operator|->
name|blend
decl_stmt|;
if|if
condition|(
name|arg_cnt
operator|!=
literal|1
operator|||
name|blend
operator|==
name|NULL
condition|)
goto|goto
name|Unexpected_OtherSubr
goto|;
name|idx
operator|=
name|Fix2Int
argument_list|(
name|top
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|<
literal|0
operator|||
operator|(
name|FT_UInt
operator|)
name|idx
operator|>=
name|decoder
operator|->
name|len_buildchar
condition|)
goto|goto
name|Unexpected_OtherSubr
goto|;
name|top
index|[
literal|0
index|]
operator|=
name|decoder
operator|->
name|buildchar
index|[
name|idx
index|]
expr_stmt|;
block|}
name|known_othersubr_result_cnt
operator|=
literal|1
expr_stmt|;
break|break;
if|#
directive|if
literal|0
block|case 26:
comment|/*<val> mark<idx> ==> set BuildCharArray[cvi(<idx> )] =<val>, */
comment|/*                      leave mark on T1 stack                    */
comment|/*<val><idx>      ==> set BuildCharArray[cvi(<idx> )] =<val>  */
block|XXX which routine has left its mark on the (PostScript) stack?;           break;
endif|#
directive|endif
case|case
literal|27
case|:
comment|/*<res1><res2><val1><val2> 4 27 callothersubr pop */
comment|/* ==> push<res1> onto T1 stack if<val1><=<val2>, */
comment|/*     otherwise push<res2>                          */
if|if
condition|(
name|arg_cnt
operator|!=
literal|4
condition|)
goto|goto
name|Unexpected_OtherSubr
goto|;
if|if
condition|(
name|top
index|[
literal|2
index|]
operator|>
name|top
index|[
literal|3
index|]
condition|)
name|top
index|[
literal|0
index|]
operator|=
name|top
index|[
literal|1
index|]
expr_stmt|;
name|known_othersubr_result_cnt
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|28
case|:
comment|/* 0 28 callothersubr pop                               */
comment|/* => push random value from interval [0, 1) onto stack */
if|if
condition|(
name|arg_cnt
operator|!=
literal|0
condition|)
goto|goto
name|Unexpected_OtherSubr
goto|;
block|{
name|FT_Fixed
name|Rand
decl_stmt|;
name|Rand
operator|=
name|seed
expr_stmt|;
if|if
condition|(
name|Rand
operator|>=
literal|0x8000L
condition|)
name|Rand
operator|++
expr_stmt|;
name|top
index|[
literal|0
index|]
operator|=
name|Rand
expr_stmt|;
name|seed
operator|=
name|FT_MulFix
argument_list|(
name|seed
argument_list|,
literal|0x10000L
operator|-
name|seed
argument_list|)
expr_stmt|;
if|if
condition|(
name|seed
operator|==
literal|0
condition|)
name|seed
operator|+=
literal|0x2873
expr_stmt|;
block|}
name|known_othersubr_result_cnt
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|arg_cnt
operator|>=
literal|0
operator|&&
name|subr_no
operator|>=
literal|0
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"t1_decoder_parse_charstrings:"
literal|" unknown othersubr [%d %d], wish me luck\n"
operator|,
name|arg_cnt
operator|,
name|subr_no
operator|)
argument_list|)
expr_stmt|;
name|unknown_othersubr_result_cnt
operator|=
name|arg_cnt
expr_stmt|;
break|break;
block|}
comment|/* fall through */
name|Unexpected_OtherSubr
label|:
name|FT_ERROR
argument_list|(
operator|(
literal|"t1_decoder_parse_charstrings:"
literal|" invalid othersubr [%d %d]\n"
operator|,
name|arg_cnt
operator|,
name|subr_no
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|Syntax_Error
goto|;
block|}
name|top
operator|+=
name|known_othersubr_result_cnt
expr_stmt|;
name|decoder
operator|->
name|top
operator|=
name|top
expr_stmt|;
block|}
else|else
comment|/* general operator */
block|{
name|FT_Int
name|num_args
init|=
name|t1_args_count
index|[
name|op
index|]
decl_stmt|;
name|FT_ASSERT
argument_list|(
name|num_args
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|top
operator|-
name|decoder
operator|->
name|stack
operator|<
name|num_args
condition|)
goto|goto
name|Stack_Underflow
goto|;
comment|/* XXX Operators usually take their operands from the        */
comment|/*     bottom of the stack, i.e., the operands are           */
comment|/*     decoder->stack[0], ..., decoder->stack[num_args - 1]; */
comment|/*     only div, callsubr, and callothersubr are different.  */
comment|/*     In practice it doesn't matter (?).                    */
ifdef|#
directive|ifdef
name|FT_DEBUG_LEVEL_TRACE
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|op_callsubr
case|:
case|case
name|op_div
case|:
case|case
name|op_callothersubr
case|:
case|case
name|op_pop
case|:
case|case
name|op_return
case|:
break|break;
default|default:
if|if
condition|(
name|top
operator|-
name|decoder
operator|->
name|stack
operator|!=
name|num_args
condition|)
name|FT_TRACE0
argument_list|(
operator|(
literal|"t1_decoder_parse_charstrings:"
literal|" too much operands on the stack"
literal|" (seen %d, expected %d)\n"
operator|,
name|top
operator|-
name|decoder
operator|->
name|stack
operator|,
name|num_args
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* FT_DEBUG_LEVEL_TRACE */
name|top
operator|-=
name|num_args
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|op_endchar
case|:
name|FT_TRACE4
argument_list|(
operator|(
literal|" endchar\n"
operator|)
argument_list|)
expr_stmt|;
name|t1_builder_close_contour
argument_list|(
name|builder
argument_list|)
expr_stmt|;
comment|/* close hints recording session */
if|if
condition|(
name|hinter
condition|)
block|{
if|if
condition|(
name|hinter
operator|->
name|close
argument_list|(
name|hinter
operator|->
name|hints
argument_list|,
operator|(
name|FT_UInt
operator|)
name|builder
operator|->
name|current
operator|->
name|n_points
argument_list|)
condition|)
goto|goto
name|Syntax_Error
goto|;
comment|/* apply hints to the loaded glyph outline now */
name|error
operator|=
name|hinter
operator|->
name|apply
argument_list|(
name|hinter
operator|->
name|hints
argument_list|,
name|builder
operator|->
name|current
argument_list|,
operator|(
name|PSH_Globals
operator|)
name|builder
operator|->
name|hints_globals
argument_list|,
name|decoder
operator|->
name|hint_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Fail
goto|;
block|}
comment|/* add current outline to the glyph slot */
name|FT_GlyphLoader_Add
argument_list|(
name|builder
operator|->
name|loader
argument_list|)
expr_stmt|;
comment|/* the compiler should optimize away this empty loop but ... */
ifdef|#
directive|ifdef
name|FT_DEBUG_LEVEL_TRACE
if|if
condition|(
name|decoder
operator|->
name|len_buildchar
operator|>
literal|0
condition|)
block|{
name|FT_UInt
name|i
decl_stmt|;
name|FT_TRACE4
argument_list|(
operator|(
literal|"BuildCharArray = [ "
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|decoder
operator|->
name|len_buildchar
condition|;
operator|++
name|i
control|)
name|FT_TRACE4
argument_list|(
operator|(
literal|"%d "
operator|,
name|decoder
operator|->
name|buildchar
index|[
name|i
index|]
operator|)
argument_list|)
expr_stmt|;
name|FT_TRACE4
argument_list|(
operator|(
literal|"]\n"
operator|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* FT_DEBUG_LEVEL_TRACE */
name|FT_TRACE4
argument_list|(
operator|(
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* return now! */
return|return
name|FT_Err_Ok
return|;
case|case
name|op_hsbw
case|:
name|FT_TRACE4
argument_list|(
operator|(
literal|" hsbw"
operator|)
argument_list|)
expr_stmt|;
name|builder
operator|->
name|parse_state
operator|=
name|T1_Parse_Have_Width
expr_stmt|;
name|builder
operator|->
name|left_bearing
operator|.
name|x
operator|+=
name|top
index|[
literal|0
index|]
expr_stmt|;
name|builder
operator|->
name|advance
operator|.
name|x
operator|=
name|top
index|[
literal|1
index|]
expr_stmt|;
name|builder
operator|->
name|advance
operator|.
name|y
operator|=
literal|0
expr_stmt|;
name|orig_x
operator|=
name|x
operator|=
name|builder
operator|->
name|pos_x
operator|+
name|top
index|[
literal|0
index|]
expr_stmt|;
name|orig_y
operator|=
name|y
operator|=
name|builder
operator|->
name|pos_y
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|orig_y
argument_list|)
expr_stmt|;
comment|/* the `metrics_only' indicates that we only want to compute */
comment|/* the glyph's metrics (lsb + advance width), not load the   */
comment|/* rest of it; so exit immediately                           */
if|if
condition|(
name|builder
operator|->
name|metrics_only
condition|)
return|return
name|FT_Err_Ok
return|;
break|break;
case|case
name|op_seac
case|:
return|return
name|t1operator_seac
argument_list|(
name|decoder
argument_list|,
name|top
index|[
literal|0
index|]
argument_list|,
name|top
index|[
literal|1
index|]
argument_list|,
name|top
index|[
literal|2
index|]
argument_list|,
name|Fix2Int
argument_list|(
name|top
index|[
literal|3
index|]
argument_list|)
argument_list|,
name|Fix2Int
argument_list|(
name|top
index|[
literal|4
index|]
argument_list|)
argument_list|)
return|;
case|case
name|op_sbw
case|:
name|FT_TRACE4
argument_list|(
operator|(
literal|" sbw"
operator|)
argument_list|)
expr_stmt|;
name|builder
operator|->
name|parse_state
operator|=
name|T1_Parse_Have_Width
expr_stmt|;
name|builder
operator|->
name|left_bearing
operator|.
name|x
operator|+=
name|top
index|[
literal|0
index|]
expr_stmt|;
name|builder
operator|->
name|left_bearing
operator|.
name|y
operator|+=
name|top
index|[
literal|1
index|]
expr_stmt|;
name|builder
operator|->
name|advance
operator|.
name|x
operator|=
name|top
index|[
literal|2
index|]
expr_stmt|;
name|builder
operator|->
name|advance
operator|.
name|y
operator|=
name|top
index|[
literal|3
index|]
expr_stmt|;
name|x
operator|=
name|builder
operator|->
name|pos_x
operator|+
name|top
index|[
literal|0
index|]
expr_stmt|;
name|y
operator|=
name|builder
operator|->
name|pos_y
operator|+
name|top
index|[
literal|1
index|]
expr_stmt|;
comment|/* the `metrics_only' indicates that we only want to compute */
comment|/* the glyph's metrics (lsb + advance width), not load the   */
comment|/* rest of it; so exit immediately                           */
if|if
condition|(
name|builder
operator|->
name|metrics_only
condition|)
return|return
name|FT_Err_Ok
return|;
break|break;
case|case
name|op_closepath
case|:
name|FT_TRACE4
argument_list|(
operator|(
literal|" closepath"
operator|)
argument_list|)
expr_stmt|;
comment|/* if there is no path, `closepath' is a no-op */
if|if
condition|(
name|builder
operator|->
name|parse_state
operator|==
name|T1_Parse_Have_Path
operator|||
name|builder
operator|->
name|parse_state
operator|==
name|T1_Parse_Have_Moveto
condition|)
name|t1_builder_close_contour
argument_list|(
name|builder
argument_list|)
expr_stmt|;
name|builder
operator|->
name|parse_state
operator|=
name|T1_Parse_Have_Width
expr_stmt|;
break|break;
case|case
name|op_hlineto
case|:
name|FT_TRACE4
argument_list|(
operator|(
literal|" hlineto"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|t1_builder_start_point
argument_list|(
name|builder
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
operator|)
operator|!=
name|FT_Err_Ok
condition|)
goto|goto
name|Fail
goto|;
name|x
operator|+=
name|top
index|[
literal|0
index|]
expr_stmt|;
goto|goto
name|Add_Line
goto|;
case|case
name|op_hmoveto
case|:
name|FT_TRACE4
argument_list|(
operator|(
literal|" hmoveto"
operator|)
argument_list|)
expr_stmt|;
name|x
operator|+=
name|top
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|decoder
operator|->
name|flex_state
condition|)
block|{
if|if
condition|(
name|builder
operator|->
name|parse_state
operator|==
name|T1_Parse_Start
condition|)
goto|goto
name|Syntax_Error
goto|;
name|builder
operator|->
name|parse_state
operator|=
name|T1_Parse_Have_Moveto
expr_stmt|;
block|}
break|break;
case|case
name|op_hvcurveto
case|:
name|FT_TRACE4
argument_list|(
operator|(
literal|" hvcurveto"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|t1_builder_start_point
argument_list|(
name|builder
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
operator|)
operator|!=
name|FT_Err_Ok
operator|||
operator|(
name|error
operator|=
name|t1_builder_check_points
argument_list|(
name|builder
argument_list|,
literal|3
argument_list|)
operator|)
operator|!=
name|FT_Err_Ok
condition|)
goto|goto
name|Fail
goto|;
name|x
operator|+=
name|top
index|[
literal|0
index|]
expr_stmt|;
name|t1_builder_add_point
argument_list|(
name|builder
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|x
operator|+=
name|top
index|[
literal|1
index|]
expr_stmt|;
name|y
operator|+=
name|top
index|[
literal|2
index|]
expr_stmt|;
name|t1_builder_add_point
argument_list|(
name|builder
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|y
operator|+=
name|top
index|[
literal|3
index|]
expr_stmt|;
name|t1_builder_add_point
argument_list|(
name|builder
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|op_rlineto
case|:
name|FT_TRACE4
argument_list|(
operator|(
literal|" rlineto"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|t1_builder_start_point
argument_list|(
name|builder
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
operator|)
operator|!=
name|FT_Err_Ok
condition|)
goto|goto
name|Fail
goto|;
name|x
operator|+=
name|top
index|[
literal|0
index|]
expr_stmt|;
name|y
operator|+=
name|top
index|[
literal|1
index|]
expr_stmt|;
name|Add_Line
label|:
if|if
condition|(
operator|(
name|error
operator|=
name|t1_builder_add_point1
argument_list|(
name|builder
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
operator|)
operator|!=
name|FT_Err_Ok
condition|)
goto|goto
name|Fail
goto|;
break|break;
case|case
name|op_rmoveto
case|:
name|FT_TRACE4
argument_list|(
operator|(
literal|" rmoveto"
operator|)
argument_list|)
expr_stmt|;
name|x
operator|+=
name|top
index|[
literal|0
index|]
expr_stmt|;
name|y
operator|+=
name|top
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|decoder
operator|->
name|flex_state
condition|)
block|{
if|if
condition|(
name|builder
operator|->
name|parse_state
operator|==
name|T1_Parse_Start
condition|)
goto|goto
name|Syntax_Error
goto|;
name|builder
operator|->
name|parse_state
operator|=
name|T1_Parse_Have_Moveto
expr_stmt|;
block|}
break|break;
case|case
name|op_rrcurveto
case|:
name|FT_TRACE4
argument_list|(
operator|(
literal|" rrcurveto"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|t1_builder_start_point
argument_list|(
name|builder
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
operator|)
operator|!=
name|FT_Err_Ok
operator|||
operator|(
name|error
operator|=
name|t1_builder_check_points
argument_list|(
name|builder
argument_list|,
literal|3
argument_list|)
operator|)
operator|!=
name|FT_Err_Ok
condition|)
goto|goto
name|Fail
goto|;
name|x
operator|+=
name|top
index|[
literal|0
index|]
expr_stmt|;
name|y
operator|+=
name|top
index|[
literal|1
index|]
expr_stmt|;
name|t1_builder_add_point
argument_list|(
name|builder
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|x
operator|+=
name|top
index|[
literal|2
index|]
expr_stmt|;
name|y
operator|+=
name|top
index|[
literal|3
index|]
expr_stmt|;
name|t1_builder_add_point
argument_list|(
name|builder
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|x
operator|+=
name|top
index|[
literal|4
index|]
expr_stmt|;
name|y
operator|+=
name|top
index|[
literal|5
index|]
expr_stmt|;
name|t1_builder_add_point
argument_list|(
name|builder
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|op_vhcurveto
case|:
name|FT_TRACE4
argument_list|(
operator|(
literal|" vhcurveto"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|t1_builder_start_point
argument_list|(
name|builder
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
operator|)
operator|!=
name|FT_Err_Ok
operator|||
operator|(
name|error
operator|=
name|t1_builder_check_points
argument_list|(
name|builder
argument_list|,
literal|3
argument_list|)
operator|)
operator|!=
name|FT_Err_Ok
condition|)
goto|goto
name|Fail
goto|;
name|y
operator|+=
name|top
index|[
literal|0
index|]
expr_stmt|;
name|t1_builder_add_point
argument_list|(
name|builder
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|x
operator|+=
name|top
index|[
literal|1
index|]
expr_stmt|;
name|y
operator|+=
name|top
index|[
literal|2
index|]
expr_stmt|;
name|t1_builder_add_point
argument_list|(
name|builder
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|x
operator|+=
name|top
index|[
literal|3
index|]
expr_stmt|;
name|t1_builder_add_point
argument_list|(
name|builder
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|op_vlineto
case|:
name|FT_TRACE4
argument_list|(
operator|(
literal|" vlineto"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|t1_builder_start_point
argument_list|(
name|builder
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
operator|)
operator|!=
name|FT_Err_Ok
condition|)
goto|goto
name|Fail
goto|;
name|y
operator|+=
name|top
index|[
literal|0
index|]
expr_stmt|;
goto|goto
name|Add_Line
goto|;
case|case
name|op_vmoveto
case|:
name|FT_TRACE4
argument_list|(
operator|(
literal|" vmoveto"
operator|)
argument_list|)
expr_stmt|;
name|y
operator|+=
name|top
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|decoder
operator|->
name|flex_state
condition|)
block|{
if|if
condition|(
name|builder
operator|->
name|parse_state
operator|==
name|T1_Parse_Start
condition|)
goto|goto
name|Syntax_Error
goto|;
name|builder
operator|->
name|parse_state
operator|=
name|T1_Parse_Have_Moveto
expr_stmt|;
block|}
break|break;
case|case
name|op_div
case|:
name|FT_TRACE4
argument_list|(
operator|(
literal|" div"
operator|)
argument_list|)
expr_stmt|;
comment|/* if `large_int' is set, we divide unscaled numbers; */
comment|/* otherwise, we divide numbers in 16.16 format --    */
comment|/* in both cases, it is the same operation            */
operator|*
name|top
operator|=
name|FT_DivFix
argument_list|(
name|top
index|[
literal|0
index|]
argument_list|,
name|top
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
operator|++
name|top
expr_stmt|;
name|large_int
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|op_callsubr
case|:
block|{
name|FT_Int
name|idx
decl_stmt|;
name|FT_TRACE4
argument_list|(
operator|(
literal|" callsubr"
operator|)
argument_list|)
expr_stmt|;
name|idx
operator|=
name|Fix2Int
argument_list|(
name|top
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|<
literal|0
operator|||
name|idx
operator|>=
name|decoder
operator|->
name|num_subrs
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"t1_decoder_parse_charstrings:"
literal|" invalid subrs index\n"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|Syntax_Error
goto|;
block|}
if|if
condition|(
name|zone
operator|-
name|decoder
operator|->
name|zones
operator|>=
name|T1_MAX_SUBRS_CALLS
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"t1_decoder_parse_charstrings:"
literal|" too many nested subrs\n"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|Syntax_Error
goto|;
block|}
name|zone
operator|->
name|cursor
operator|=
name|ip
expr_stmt|;
comment|/* save current instruction pointer */
name|zone
operator|++
expr_stmt|;
comment|/* The Type 1 driver stores subroutines without the seed bytes. */
comment|/* The CID driver stores subroutines with seed bytes.  This     */
comment|/* case is taken care of when decoder->subrs_len == 0.          */
name|zone
operator|->
name|base
operator|=
name|decoder
operator|->
name|subrs
index|[
name|idx
index|]
expr_stmt|;
if|if
condition|(
name|decoder
operator|->
name|subrs_len
condition|)
name|zone
operator|->
name|limit
operator|=
name|zone
operator|->
name|base
operator|+
name|decoder
operator|->
name|subrs_len
index|[
name|idx
index|]
expr_stmt|;
else|else
block|{
comment|/* We are using subroutines from a CID font.  We must adjust */
comment|/* for the seed bytes.                                       */
name|zone
operator|->
name|base
operator|+=
operator|(
name|decoder
operator|->
name|lenIV
operator|>=
literal|0
condition|?
name|decoder
operator|->
name|lenIV
else|:
literal|0
operator|)
expr_stmt|;
name|zone
operator|->
name|limit
operator|=
name|decoder
operator|->
name|subrs
index|[
name|idx
operator|+
literal|1
index|]
expr_stmt|;
block|}
name|zone
operator|->
name|cursor
operator|=
name|zone
operator|->
name|base
expr_stmt|;
if|if
condition|(
operator|!
name|zone
operator|->
name|base
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"t1_decoder_parse_charstrings:"
literal|" invoking empty subrs\n"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|Syntax_Error
goto|;
block|}
name|decoder
operator|->
name|zone
operator|=
name|zone
expr_stmt|;
name|ip
operator|=
name|zone
operator|->
name|base
expr_stmt|;
name|limit
operator|=
name|zone
operator|->
name|limit
expr_stmt|;
break|break;
block|}
case|case
name|op_pop
case|:
name|FT_TRACE4
argument_list|(
operator|(
literal|" pop"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|known_othersubr_result_cnt
operator|>
literal|0
condition|)
block|{
name|known_othersubr_result_cnt
operator|--
expr_stmt|;
comment|/* ignore, we pushed the operands ourselves */
break|break;
block|}
if|if
condition|(
name|unknown_othersubr_result_cnt
operator|==
literal|0
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"t1_decoder_parse_charstrings:"
literal|" no more operands for othersubr\n"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|Syntax_Error
goto|;
block|}
name|unknown_othersubr_result_cnt
operator|--
expr_stmt|;
name|top
operator|++
expr_stmt|;
comment|/* `push' the operand to callothersubr onto the stack */
break|break;
case|case
name|op_return
case|:
name|FT_TRACE4
argument_list|(
operator|(
literal|" return"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|<=
name|decoder
operator|->
name|zones
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"t1_decoder_parse_charstrings:"
literal|" unexpected return\n"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|Syntax_Error
goto|;
block|}
name|zone
operator|--
expr_stmt|;
name|ip
operator|=
name|zone
operator|->
name|cursor
expr_stmt|;
name|limit
operator|=
name|zone
operator|->
name|limit
expr_stmt|;
name|decoder
operator|->
name|zone
operator|=
name|zone
expr_stmt|;
break|break;
case|case
name|op_dotsection
case|:
name|FT_TRACE4
argument_list|(
operator|(
literal|" dotsection"
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|op_hstem
case|:
name|FT_TRACE4
argument_list|(
operator|(
literal|" hstem"
operator|)
argument_list|)
expr_stmt|;
comment|/* record horizontal hint */
if|if
condition|(
name|hinter
condition|)
block|{
comment|/* top[0] += builder->left_bearing.y; */
name|hinter
operator|->
name|stem
argument_list|(
name|hinter
operator|->
name|hints
argument_list|,
literal|1
argument_list|,
name|top
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|op_hstem3
case|:
name|FT_TRACE4
argument_list|(
operator|(
literal|" hstem3"
operator|)
argument_list|)
expr_stmt|;
comment|/* record horizontal counter-controlled hints */
if|if
condition|(
name|hinter
condition|)
name|hinter
operator|->
name|stem3
argument_list|(
name|hinter
operator|->
name|hints
argument_list|,
literal|1
argument_list|,
name|top
argument_list|)
expr_stmt|;
break|break;
case|case
name|op_vstem
case|:
name|FT_TRACE4
argument_list|(
operator|(
literal|" vstem"
operator|)
argument_list|)
expr_stmt|;
comment|/* record vertical hint */
if|if
condition|(
name|hinter
condition|)
block|{
name|top
index|[
literal|0
index|]
operator|+=
name|orig_x
expr_stmt|;
name|hinter
operator|->
name|stem
argument_list|(
name|hinter
operator|->
name|hints
argument_list|,
literal|0
argument_list|,
name|top
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|op_vstem3
case|:
name|FT_TRACE4
argument_list|(
operator|(
literal|" vstem3"
operator|)
argument_list|)
expr_stmt|;
comment|/* record vertical counter-controlled hints */
if|if
condition|(
name|hinter
condition|)
block|{
name|FT_Pos
name|dx
init|=
name|orig_x
decl_stmt|;
name|top
index|[
literal|0
index|]
operator|+=
name|dx
expr_stmt|;
name|top
index|[
literal|2
index|]
operator|+=
name|dx
expr_stmt|;
name|top
index|[
literal|4
index|]
operator|+=
name|dx
expr_stmt|;
name|hinter
operator|->
name|stem3
argument_list|(
name|hinter
operator|->
name|hints
argument_list|,
literal|0
argument_list|,
name|top
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|op_setcurrentpoint
case|:
name|FT_TRACE4
argument_list|(
operator|(
literal|" setcurrentpoint"
operator|)
argument_list|)
expr_stmt|;
comment|/* From the T1 specification, section 6.4:                */
comment|/*                                                        */
comment|/*   The setcurrentpoint command is used only in          */
comment|/*   conjunction with results from OtherSubrs procedures. */
comment|/* known_othersubr_result_cnt != 0 is already handled     */
comment|/* above.                                                 */
comment|/* Note, however, that both Ghostscript and Adobe         */
comment|/* Distiller handle this situation by silently ignoring   */
comment|/* the inappropriate `setcurrentpoint' instruction.  So   */
comment|/* we do the same.                                        */
if|#
directive|if
literal|0
block|if ( decoder->flex_state != 1 )           {             FT_ERROR(( "t1_decoder_parse_charstrings:"                        " unexpected `setcurrentpoint'\n" ));             goto Syntax_Error;           }           else             ...
endif|#
directive|endif
name|x
operator|=
name|top
index|[
literal|0
index|]
expr_stmt|;
name|y
operator|=
name|top
index|[
literal|1
index|]
expr_stmt|;
name|decoder
operator|->
name|flex_state
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|op_unknown15
case|:
name|FT_TRACE4
argument_list|(
operator|(
literal|" opcode_15"
operator|)
argument_list|)
expr_stmt|;
comment|/* nothing to do except to pop the two arguments */
break|break;
default|default:
name|FT_ERROR
argument_list|(
operator|(
literal|"t1_decoder_parse_charstrings:"
literal|" unhandled opcode %d\n"
operator|,
name|op
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|Syntax_Error
goto|;
block|}
comment|/* XXX Operators usually clear the operand stack;  */
comment|/*     only div, callsubr, callothersubr, pop, and */
comment|/*     return are different.                       */
comment|/*     In practice it doesn't matter (?).          */
name|decoder
operator|->
name|top
operator|=
name|top
expr_stmt|;
ifdef|#
directive|ifdef
name|FT_DEBUG_LEVEL_TRACE
name|FT_TRACE4
argument_list|(
operator|(
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
name|bol
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* general operator processing */
block|}
comment|/* while ip< limit */
name|FT_TRACE4
argument_list|(
operator|(
literal|"..end..\n\n"
operator|)
argument_list|)
expr_stmt|;
name|Fail
label|:
return|return
name|error
return|;
name|Syntax_Error
label|:
return|return
name|FT_THROW
argument_list|(
name|Syntax_Error
argument_list|)
return|;
name|Stack_Underflow
label|:
return|return
name|FT_THROW
argument_list|(
name|Stack_Underflow
argument_list|)
return|;
block|}
end_block
begin_comment
comment|/* parse a single Type 1 glyph */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|t1_decoder_parse_glyph
argument_list|(
argument|T1_Decoder  decoder
argument_list|,
argument|FT_UInt     glyph
argument_list|)
end_macro
begin_block
block|{
return|return
name|decoder
operator|->
name|parse_callback
argument_list|(
name|decoder
argument_list|,
name|glyph
argument_list|)
return|;
block|}
end_block
begin_comment
comment|/* initialize T1 decoder */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|t1_decoder_init
argument_list|(
argument|T1_Decoder           decoder
argument_list|,
argument|FT_Face              face
argument_list|,
argument|FT_Size              size
argument_list|,
argument|FT_GlyphSlot         slot
argument_list|,
argument|FT_Byte**            glyph_names
argument_list|,
argument|PS_Blend             blend
argument_list|,
argument|FT_Bool              hinting
argument_list|,
argument|FT_Render_Mode       hint_mode
argument_list|,
argument|T1_Decoder_Callback  parse_callback
argument_list|)
end_macro
begin_block
block|{
name|FT_MEM_ZERO
argument_list|(
name|decoder
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|decoder
argument_list|)
argument_list|)
expr_stmt|;
comment|/* retrieve PSNames interface from list of current modules */
block|{
name|FT_Service_PsCMaps
name|psnames
decl_stmt|;
name|FT_FACE_FIND_GLOBAL_SERVICE
argument_list|(
name|face
argument_list|,
name|psnames
argument_list|,
name|POSTSCRIPT_CMAPS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|psnames
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"t1_decoder_init:"
literal|" the `psnames' module is not available\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|FT_THROW
argument_list|(
name|Unimplemented_Feature
argument_list|)
return|;
block|}
name|decoder
operator|->
name|psnames
operator|=
name|psnames
expr_stmt|;
block|}
name|t1_builder_init
argument_list|(
operator|&
name|decoder
operator|->
name|builder
argument_list|,
name|face
argument_list|,
name|size
argument_list|,
name|slot
argument_list|,
name|hinting
argument_list|)
expr_stmt|;
comment|/* decoder->buildchar and decoder->len_buildchar have to be  */
comment|/* initialized by the caller since we cannot know the length */
comment|/* of the BuildCharArray                                     */
name|decoder
operator|->
name|num_glyphs
operator|=
operator|(
name|FT_UInt
operator|)
name|face
operator|->
name|num_glyphs
expr_stmt|;
name|decoder
operator|->
name|glyph_names
operator|=
name|glyph_names
expr_stmt|;
name|decoder
operator|->
name|hint_mode
operator|=
name|hint_mode
expr_stmt|;
name|decoder
operator|->
name|blend
operator|=
name|blend
expr_stmt|;
name|decoder
operator|->
name|parse_callback
operator|=
name|parse_callback
expr_stmt|;
name|decoder
operator|->
name|funcs
operator|=
name|t1_decoder_funcs
expr_stmt|;
return|return
name|FT_Err_Ok
return|;
block|}
end_block
begin_comment
comment|/* finalize T1 decoder */
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|t1_decoder_done
name|t1_decoder_done
argument_list|(
argument|T1_Decoder  decoder
argument_list|)
end_macro
begin_block
block|{
name|t1_builder_done
argument_list|(
operator|&
name|decoder
operator|->
name|builder
argument_list|)
expr_stmt|;
block|}
end_block
begin_comment
comment|/* END */
end_comment
end_unit
