begin_unit
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  psconv.c                                                               */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*    Some convenience conversions (body).                                 */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  Copyright 2006-2015 by                                                 */
end_comment
begin_comment
comment|/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  This file is part of the FreeType project, and may only be used,       */
end_comment
begin_comment
comment|/*  modified, and distributed under the terms of the FreeType project      */
end_comment
begin_comment
comment|/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
end_comment
begin_comment
comment|/*  this file you indicate that you have read the license and              */
end_comment
begin_comment
comment|/*  understand and accept it fully.                                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<ft2build.h>
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_POSTSCRIPT_AUX_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_DEBUG_H
end_include
begin_include
include|#
directive|include
file|"psconv.h"
end_include
begin_include
include|#
directive|include
file|"psauxerr.h"
end_include
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
end_comment
begin_comment
comment|/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
end_comment
begin_comment
comment|/* messages during execution.                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_undef
DECL|macro|FT_COMPONENT
undef|#
directive|undef
name|FT_COMPONENT
end_undef
begin_define
DECL|macro|FT_COMPONENT
define|#
directive|define
name|FT_COMPONENT
value|trace_psconv
end_define
begin_comment
comment|/* The following array is used by various functions to quickly convert */
end_comment
begin_comment
comment|/* digits (both decimal and non-decimal) into numbers.                 */
end_comment
begin_if
if|#
directive|if
literal|'A'
operator|==
literal|65
end_if
begin_comment
comment|/* ASCII */
end_comment
begin_decl_stmt
DECL|variable|ft_char_table
specifier|static
specifier|const
name|FT_Char
name|ft_char_table
index|[
literal|128
index|]
init|=
block|{
comment|/* 0x00 */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|16
block|,
literal|17
block|,
literal|18
block|,
literal|19
block|,
literal|20
block|,
literal|21
block|,
literal|22
block|,
literal|23
block|,
literal|24
block|,
literal|25
block|,
literal|26
block|,
literal|27
block|,
literal|28
block|,
literal|29
block|,
literal|30
block|,
literal|31
block|,
literal|32
block|,
literal|33
block|,
literal|34
block|,
literal|35
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|16
block|,
literal|17
block|,
literal|18
block|,
literal|19
block|,
literal|20
block|,
literal|21
block|,
literal|22
block|,
literal|23
block|,
literal|24
block|,
literal|25
block|,
literal|26
block|,
literal|27
block|,
literal|28
block|,
literal|29
block|,
literal|30
block|,
literal|31
block|,
literal|32
block|,
literal|33
block|,
literal|34
block|,
literal|35
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,   }
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* no character>= 0x80 can represent a valid number */
end_comment
begin_define
DECL|macro|OP
define|#
directive|define
name|OP
value|>=
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* 'A' == 65 */
end_comment
begin_if
if|#
directive|if
literal|'A'
operator|==
literal|193
end_if
begin_comment
comment|/* EBCDIC */
end_comment
begin_decl_stmt
DECL|variable|ft_char_table
specifier|static
specifier|const
name|FT_Char
name|ft_char_table
index|[
literal|128
index|]
init|=
block|{
comment|/* 0x80 */
operator|-
literal|1
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|16
block|,
literal|17
block|,
literal|18
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|19
block|,
literal|20
block|,
literal|21
block|,
literal|22
block|,
literal|23
block|,
literal|24
block|,
literal|25
block|,
literal|26
block|,
literal|27
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|28
block|,
literal|29
block|,
literal|30
block|,
literal|31
block|,
literal|32
block|,
literal|33
block|,
literal|34
block|,
literal|35
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|16
block|,
literal|17
block|,
literal|18
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|19
block|,
literal|20
block|,
literal|21
block|,
literal|22
block|,
literal|23
block|,
literal|24
block|,
literal|25
block|,
literal|26
block|,
literal|27
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|28
block|,
literal|29
block|,
literal|30
block|,
literal|31
block|,
literal|32
block|,
literal|33
block|,
literal|34
block|,
literal|35
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,   }
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* no character< 0x80 can represent a valid number */
end_comment
begin_define
DECL|macro|OP
define|#
directive|define
name|OP
value|<
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* 'A' == 193 */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Long
argument_list|)
end_macro
begin_macro
name|PS_Conv_Strtol
argument_list|(
argument|FT_Byte**  cursor
argument_list|,
argument|FT_Byte*   limit
argument_list|,
argument|FT_Long    base
argument_list|)
end_macro
begin_block
block|{
name|FT_Byte
modifier|*
name|p
init|=
operator|*
name|cursor
decl_stmt|;
name|FT_Long
name|num
init|=
literal|0
decl_stmt|;
name|FT_Bool
name|sign
init|=
literal|0
decl_stmt|;
name|FT_Bool
name|have_overflow
init|=
literal|0
decl_stmt|;
name|FT_Long
name|num_limit
decl_stmt|;
name|FT_Char
name|c_limit
decl_stmt|;
if|if
condition|(
name|p
operator|>=
name|limit
condition|)
goto|goto
name|Bad
goto|;
if|if
condition|(
name|base
operator|<
literal|2
operator|||
name|base
operator|>
literal|36
condition|)
block|{
name|FT_TRACE4
argument_list|(
operator|(
literal|"!!!INVALID BASE:!!!"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
operator|||
operator|*
name|p
operator|==
literal|'+'
condition|)
block|{
name|sign
operator|=
name|FT_BOOL
argument_list|(
operator|*
name|p
operator|==
literal|'-'
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|limit
condition|)
goto|goto
name|Bad
goto|;
block|}
name|num_limit
operator|=
literal|0x7FFFFFFFL
operator|/
name|base
expr_stmt|;
name|c_limit
operator|=
call|(
name|FT_Char
call|)
argument_list|(
literal|0x7FFFFFFFL
operator|%
name|base
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|p
operator|<
name|limit
condition|;
name|p
operator|++
control|)
block|{
name|FT_Char
name|c
decl_stmt|;
if|if
condition|(
name|IS_PS_SPACE
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|*
name|p
name|OP
literal|0x80
condition|)
break|break;
name|c
operator|=
name|ft_char_table
index|[
operator|*
name|p
operator|&
literal|0x7F
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|0
operator|||
name|c
operator|>=
name|base
condition|)
break|break;
if|if
condition|(
name|num
operator|>
name|num_limit
operator|||
operator|(
name|num
operator|==
name|num_limit
operator|&&
name|c
operator|>
name|c_limit
operator|)
condition|)
name|have_overflow
operator|=
literal|1
expr_stmt|;
else|else
name|num
operator|=
name|num
operator|*
name|base
operator|+
name|c
expr_stmt|;
block|}
operator|*
name|cursor
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|have_overflow
condition|)
block|{
name|num
operator|=
literal|0x7FFFFFFFL
expr_stmt|;
name|FT_TRACE4
argument_list|(
operator|(
literal|"!!!OVERFLOW:!!!"
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sign
condition|)
name|num
operator|=
operator|-
name|num
expr_stmt|;
return|return
name|num
return|;
name|Bad
label|:
name|FT_TRACE4
argument_list|(
operator|(
literal|"!!!END OF DATA:!!!"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Long
argument_list|)
end_macro
begin_macro
name|PS_Conv_ToInt
argument_list|(
argument|FT_Byte**  cursor
argument_list|,
argument|FT_Byte*   limit
argument_list|)
end_macro
begin_block
block|{
name|FT_Byte
modifier|*
name|p
init|=
operator|*
name|cursor
decl_stmt|;
name|FT_Byte
modifier|*
name|curp
decl_stmt|;
name|FT_Long
name|num
decl_stmt|;
name|curp
operator|=
name|p
expr_stmt|;
name|num
operator|=
name|PS_Conv_Strtol
argument_list|(
operator|&
name|p
argument_list|,
name|limit
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|curp
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|p
operator|<
name|limit
operator|&&
operator|*
name|p
operator|==
literal|'#'
condition|)
block|{
name|p
operator|++
expr_stmt|;
name|curp
operator|=
name|p
expr_stmt|;
name|num
operator|=
name|PS_Conv_Strtol
argument_list|(
operator|&
name|p
argument_list|,
name|limit
argument_list|,
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|curp
condition|)
return|return
literal|0
return|;
block|}
operator|*
name|cursor
operator|=
name|p
expr_stmt|;
return|return
name|num
return|;
block|}
end_block
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Fixed
argument_list|)
end_macro
begin_macro
name|PS_Conv_ToFixed
argument_list|(
argument|FT_Byte**  cursor
argument_list|,
argument|FT_Byte*   limit
argument_list|,
argument|FT_Long    power_ten
argument_list|)
end_macro
begin_block
block|{
name|FT_Byte
modifier|*
name|p
init|=
operator|*
name|cursor
decl_stmt|;
name|FT_Byte
modifier|*
name|curp
decl_stmt|;
name|FT_Fixed
name|integral
init|=
literal|0
decl_stmt|;
name|FT_Long
name|decimal
init|=
literal|0
decl_stmt|;
name|FT_Long
name|divider
init|=
literal|1
decl_stmt|;
name|FT_Bool
name|sign
init|=
literal|0
decl_stmt|;
name|FT_Bool
name|have_overflow
init|=
literal|0
decl_stmt|;
name|FT_Bool
name|have_underflow
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|p
operator|>=
name|limit
condition|)
goto|goto
name|Bad
goto|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
operator|||
operator|*
name|p
operator|==
literal|'+'
condition|)
block|{
name|sign
operator|=
name|FT_BOOL
argument_list|(
operator|*
name|p
operator|==
literal|'-'
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|limit
condition|)
goto|goto
name|Bad
goto|;
block|}
comment|/* read the integer part */
if|if
condition|(
operator|*
name|p
operator|!=
literal|'.'
condition|)
block|{
name|curp
operator|=
name|p
expr_stmt|;
name|integral
operator|=
name|PS_Conv_ToInt
argument_list|(
operator|&
name|p
argument_list|,
name|limit
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|curp
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|integral
operator|>
literal|0x7FFF
condition|)
name|have_overflow
operator|=
literal|1
expr_stmt|;
else|else
name|integral
operator|=
call|(
name|FT_Fixed
call|)
argument_list|(
operator|(
name|FT_UInt32
operator|)
name|integral
operator|<<
literal|16
argument_list|)
expr_stmt|;
block|}
comment|/* read the decimal part */
if|if
condition|(
name|p
operator|<
name|limit
operator|&&
operator|*
name|p
operator|==
literal|'.'
condition|)
block|{
name|p
operator|++
expr_stmt|;
for|for
control|(
init|;
name|p
operator|<
name|limit
condition|;
name|p
operator|++
control|)
block|{
name|FT_Char
name|c
decl_stmt|;
if|if
condition|(
name|IS_PS_SPACE
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|*
name|p
name|OP
literal|0x80
condition|)
break|break;
name|c
operator|=
name|ft_char_table
index|[
operator|*
name|p
operator|&
literal|0x7F
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|0
operator|||
name|c
operator|>=
literal|10
condition|)
break|break;
comment|/* only add digit if we don't overflow */
if|if
condition|(
name|divider
operator|<
literal|0xCCCCCCCL
operator|&&
name|decimal
operator|<
literal|0xCCCCCCCL
condition|)
block|{
name|decimal
operator|=
name|decimal
operator|*
literal|10
operator|+
name|c
expr_stmt|;
if|if
condition|(
operator|!
name|integral
operator|&&
name|power_ten
operator|>
literal|0
condition|)
name|power_ten
operator|--
expr_stmt|;
else|else
name|divider
operator|*=
literal|10
expr_stmt|;
block|}
block|}
block|}
comment|/* read exponent, if any */
if|if
condition|(
name|p
operator|+
literal|1
operator|<
name|limit
operator|&&
operator|(
operator|*
name|p
operator|==
literal|'e'
operator|||
operator|*
name|p
operator|==
literal|'E'
operator|)
condition|)
block|{
name|FT_Long
name|exponent
decl_stmt|;
name|p
operator|++
expr_stmt|;
name|curp
operator|=
name|p
expr_stmt|;
name|exponent
operator|=
name|PS_Conv_ToInt
argument_list|(
operator|&
name|p
argument_list|,
name|limit
argument_list|)
expr_stmt|;
if|if
condition|(
name|curp
operator|==
name|p
condition|)
return|return
literal|0
return|;
comment|/* arbitrarily limit exponent */
if|if
condition|(
name|exponent
operator|>
literal|1000
condition|)
name|have_overflow
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|exponent
operator|<
operator|-
literal|1000
condition|)
name|have_underflow
operator|=
literal|1
expr_stmt|;
else|else
name|power_ten
operator|+=
name|exponent
expr_stmt|;
block|}
operator|*
name|cursor
operator|=
name|p
expr_stmt|;
if|if
condition|(
operator|!
name|integral
operator|&&
operator|!
name|decimal
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|have_overflow
condition|)
goto|goto
name|Overflow
goto|;
if|if
condition|(
name|have_underflow
condition|)
goto|goto
name|Underflow
goto|;
while|while
condition|(
name|power_ten
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|integral
operator|>=
literal|0xCCCCCCCL
condition|)
goto|goto
name|Overflow
goto|;
name|integral
operator|*=
literal|10
expr_stmt|;
if|if
condition|(
name|decimal
operator|>=
literal|0xCCCCCCCL
condition|)
block|{
if|if
condition|(
name|divider
operator|==
literal|1
condition|)
goto|goto
name|Overflow
goto|;
name|divider
operator|/=
literal|10
expr_stmt|;
block|}
else|else
name|decimal
operator|*=
literal|10
expr_stmt|;
name|power_ten
operator|--
expr_stmt|;
block|}
while|while
condition|(
name|power_ten
operator|<
literal|0
condition|)
block|{
name|integral
operator|/=
literal|10
expr_stmt|;
if|if
condition|(
name|divider
operator|<
literal|0xCCCCCCCL
condition|)
name|divider
operator|*=
literal|10
expr_stmt|;
else|else
name|decimal
operator|/=
literal|10
expr_stmt|;
if|if
condition|(
operator|!
name|integral
operator|&&
operator|!
name|decimal
condition|)
goto|goto
name|Underflow
goto|;
name|power_ten
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|decimal
condition|)
block|{
name|decimal
operator|=
name|FT_DivFix
argument_list|(
name|decimal
argument_list|,
name|divider
argument_list|)
expr_stmt|;
comment|/* it's not necessary to check this addition for overflow */
comment|/* due to the structure of the real number representation */
name|integral
operator|+=
name|decimal
expr_stmt|;
block|}
name|Exit
label|:
if|if
condition|(
name|sign
condition|)
name|integral
operator|=
operator|-
name|integral
expr_stmt|;
return|return
name|integral
return|;
name|Bad
label|:
name|FT_TRACE4
argument_list|(
operator|(
literal|"!!!END OF DATA:!!!"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|Overflow
label|:
name|integral
operator|=
literal|0x7FFFFFFFL
expr_stmt|;
name|FT_TRACE4
argument_list|(
operator|(
literal|"!!!OVERFLOW:!!!"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
name|Underflow
label|:
name|FT_TRACE4
argument_list|(
operator|(
literal|"!!!UNDERFLOW:!!!"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block
begin_if
if|#
directive|if
literal|0
end_if
begin_comment
unit|FT_LOCAL_DEF( FT_UInt )   PS_Conv_StringDecode( FT_Byte**  cursor,                         FT_Byte*   limit,                         FT_Byte*   buffer,                         FT_Offset  n )   {     FT_Byte*  p;     FT_UInt   r = 0;       for ( p = *cursor; r< n&& p< limit; p++ )     {       FT_Byte  b;         if ( *p != '\\' )       {         buffer[r++] = *p;          continue;       }        p++;        switch ( *p )       {       case 'n':         b = '\n';         break;       case 'r':         b = '\r';         break;       case 't':         b = '\t';         break;       case 'b':         b = '\b';         break;       case 'f':         b = '\f';         break;       case '\r':         p++;         if ( *p != '\n' )         {           b = *p;            break;         }
comment|/* no break */
end_comment
begin_endif
unit|case '\n':         continue;         break;       default:         if ( IS_PS_DIGIT( *p ) )         {           b = *p - '0';            p++;            if ( IS_PS_DIGIT( *p ) )           {             b = b * 8 + *p - '0';              p++;              if ( IS_PS_DIGIT( *p ) )               b = b * 8 + *p - '0';             else             {               buffer[r++] = b;               b = *p;             }           }           else           {             buffer[r++] = b;             b = *p;           }         }         else           b = *p;         break;       }        buffer[r++] = b;     }      *cursor = p;      return r;   }
endif|#
directive|endif
end_endif
begin_comment
comment|/* 0 */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_UInt
argument_list|)
end_macro
begin_macro
name|PS_Conv_ASCIIHexDecode
argument_list|(
argument|FT_Byte**  cursor
argument_list|,
argument|FT_Byte*   limit
argument_list|,
argument|FT_Byte*   buffer
argument_list|,
argument|FT_Offset  n
argument_list|)
end_macro
begin_block
block|{
name|FT_Byte
modifier|*
name|p
decl_stmt|;
name|FT_UInt
name|r
init|=
literal|0
decl_stmt|;
name|FT_UInt
name|w
init|=
literal|0
decl_stmt|;
name|FT_UInt
name|pad
init|=
literal|0x01
decl_stmt|;
name|n
operator|*=
literal|2
expr_stmt|;
if|#
directive|if
literal|1
name|p
operator|=
operator|*
name|cursor
expr_stmt|;
if|if
condition|(
name|p
operator|>=
name|limit
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|n
operator|>
call|(
name|FT_UInt
call|)
argument_list|(
name|limit
operator|-
name|p
argument_list|)
condition|)
name|n
operator|=
call|(
name|FT_UInt
call|)
argument_list|(
name|limit
operator|-
name|p
argument_list|)
expr_stmt|;
comment|/* we try to process two nibbles at a time to be as fast as possible */
for|for
control|(
init|;
name|r
operator|<
name|n
condition|;
name|r
operator|++
control|)
block|{
name|FT_UInt
name|c
init|=
name|p
index|[
name|r
index|]
decl_stmt|;
if|if
condition|(
name|IS_PS_SPACE
argument_list|(
name|c
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|c
name|OP
literal|0x80
condition|)
break|break;
name|c
operator|=
operator|(
name|FT_UInt
operator|)
name|ft_char_table
index|[
name|c
operator|&
literal|0x7F
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|16
condition|)
break|break;
name|pad
operator|=
operator|(
name|pad
operator|<<
literal|4
operator|)
operator||
name|c
expr_stmt|;
if|if
condition|(
name|pad
operator|&
literal|0x100
condition|)
block|{
name|buffer
index|[
name|w
operator|++
index|]
operator|=
operator|(
name|FT_Byte
operator|)
name|pad
expr_stmt|;
name|pad
operator|=
literal|0x01
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pad
operator|!=
literal|0x01
condition|)
name|buffer
index|[
name|w
operator|++
index|]
operator|=
call|(
name|FT_Byte
call|)
argument_list|(
name|pad
operator|<<
literal|4
argument_list|)
expr_stmt|;
operator|*
name|cursor
operator|=
name|p
operator|+
name|r
expr_stmt|;
return|return
name|w
return|;
else|#
directive|else
comment|/* 0 */
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
name|n
condition|;
name|r
operator|++
control|)
block|{
name|FT_Char
name|c
decl_stmt|;
if|if
condition|(
name|IS_PS_SPACE
argument_list|(
operator|*
name|p
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|*
name|p
name|OP
literal|0x80
condition|)
break|break;
name|c
operator|=
name|ft_char_table
index|[
operator|*
name|p
operator|&
literal|0x7F
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
operator|)
name|c
operator|>=
literal|16
condition|)
break|break;
if|if
condition|(
name|r
operator|&
literal|1
condition|)
block|{
operator|*
name|buffer
operator|=
call|(
name|FT_Byte
call|)
argument_list|(
operator|*
name|buffer
operator|+
name|c
argument_list|)
expr_stmt|;
name|buffer
operator|++
expr_stmt|;
block|}
else|else
operator|*
name|buffer
operator|=
call|(
name|FT_Byte
call|)
argument_list|(
name|c
operator|<<
literal|4
argument_list|)
expr_stmt|;
name|r
operator|++
expr_stmt|;
block|}
operator|*
name|cursor
operator|=
name|p
expr_stmt|;
return|return
operator|(
name|r
operator|+
literal|1
operator|)
operator|/
literal|2
return|;
endif|#
directive|endif
comment|/* 0 */
block|}
end_block
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_UInt
argument_list|)
end_macro
begin_macro
name|PS_Conv_EexecDecode
argument_list|(
argument|FT_Byte**   cursor
argument_list|,
argument|FT_Byte*    limit
argument_list|,
argument|FT_Byte*    buffer
argument_list|,
argument|FT_Offset   n
argument_list|,
argument|FT_UShort*  seed
argument_list|)
end_macro
begin_block
block|{
name|FT_Byte
modifier|*
name|p
decl_stmt|;
name|FT_UInt
name|r
decl_stmt|;
name|FT_UInt
name|s
init|=
operator|*
name|seed
decl_stmt|;
if|#
directive|if
literal|1
name|p
operator|=
operator|*
name|cursor
expr_stmt|;
if|if
condition|(
name|p
operator|>=
name|limit
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|n
operator|>
call|(
name|FT_UInt
call|)
argument_list|(
name|limit
operator|-
name|p
argument_list|)
condition|)
name|n
operator|=
call|(
name|FT_UInt
call|)
argument_list|(
name|limit
operator|-
name|p
argument_list|)
expr_stmt|;
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
name|n
condition|;
name|r
operator|++
control|)
block|{
name|FT_UInt
name|val
init|=
name|p
index|[
name|r
index|]
decl_stmt|;
name|FT_UInt
name|b
init|=
operator|(
name|val
operator|^
operator|(
name|s
operator|>>
literal|8
operator|)
operator|)
decl_stmt|;
name|s
operator|=
operator|(
operator|(
name|val
operator|+
name|s
operator|)
operator|*
literal|52845U
operator|+
literal|22719
operator|)
operator|&
literal|0xFFFFU
expr_stmt|;
name|buffer
index|[
name|r
index|]
operator|=
operator|(
name|FT_Byte
operator|)
name|b
expr_stmt|;
block|}
operator|*
name|cursor
operator|=
name|p
operator|+
name|n
expr_stmt|;
operator|*
name|seed
operator|=
operator|(
name|FT_UShort
operator|)
name|s
expr_stmt|;
else|#
directive|else
comment|/* 0 */
for|for
control|(
name|r
operator|=
literal|0
operator|,
name|p
operator|=
operator|*
name|cursor
init|;
name|r
operator|<
name|n
operator|&&
name|p
operator|<
name|limit
condition|;
name|r
operator|++
operator|,
name|p
operator|++
control|)
block|{
name|FT_Byte
name|b
init|=
call|(
name|FT_Byte
call|)
argument_list|(
operator|*
name|p
operator|^
operator|(
name|s
operator|>>
literal|8
operator|)
argument_list|)
decl_stmt|;
name|s
operator|=
call|(
name|FT_UShort
call|)
argument_list|(
operator|(
operator|*
name|p
operator|+
name|s
operator|)
operator|*
literal|52845U
operator|+
literal|22719
argument_list|)
expr_stmt|;
operator|*
name|buffer
operator|++
operator|=
name|b
expr_stmt|;
block|}
operator|*
name|cursor
operator|=
name|p
expr_stmt|;
operator|*
name|seed
operator|=
name|s
expr_stmt|;
endif|#
directive|endif
comment|/* 0 */
return|return
name|r
return|;
block|}
end_block
begin_comment
comment|/* END */
end_comment
end_unit
