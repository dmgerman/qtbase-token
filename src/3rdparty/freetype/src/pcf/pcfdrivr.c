begin_unit
begin_comment
comment|/*  pcfdrivr.c      FreeType font driver for pcf files      Copyright (C) 2000-2004, 2006-2011, 2013, 2014 by     Francesco Zappa Nardelli  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */
end_comment
begin_include
include|#
directive|include
file|<ft2build.h>
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_DEBUG_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_STREAM_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_OBJECTS_H
end_include
begin_include
include|#
directive|include
include|FT_GZIP_H
end_include
begin_include
include|#
directive|include
include|FT_LZW_H
end_include
begin_include
include|#
directive|include
include|FT_BZIP2_H
end_include
begin_include
include|#
directive|include
include|FT_ERRORS_H
end_include
begin_include
include|#
directive|include
include|FT_BDF_H
end_include
begin_include
include|#
directive|include
include|FT_TRUETYPE_IDS_H
end_include
begin_include
include|#
directive|include
file|"pcf.h"
end_include
begin_include
include|#
directive|include
file|"pcfdrivr.h"
end_include
begin_include
include|#
directive|include
file|"pcfread.h"
end_include
begin_include
include|#
directive|include
file|"pcferror.h"
end_include
begin_include
include|#
directive|include
file|"pcfutil.h"
end_include
begin_undef
DECL|macro|FT_COMPONENT
undef|#
directive|undef
name|FT_COMPONENT
end_undef
begin_define
DECL|macro|FT_COMPONENT
define|#
directive|define
name|FT_COMPONENT
value|trace_pcfread
end_define
begin_include
include|#
directive|include
include|FT_SERVICE_BDF_H
end_include
begin_include
include|#
directive|include
include|FT_SERVICE_XFREE86_NAME_H
end_include
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
end_comment
begin_comment
comment|/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
end_comment
begin_comment
comment|/* messages during execution.                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_undef
DECL|macro|FT_COMPONENT
undef|#
directive|undef
name|FT_COMPONENT
end_undef
begin_define
DECL|macro|FT_COMPONENT
define|#
directive|define
name|FT_COMPONENT
value|trace_pcfdriver
end_define
begin_typedef
DECL|struct|PCF_CMapRec_
typedef|typedef
struct|struct
name|PCF_CMapRec_
block|{
DECL|member|root
name|FT_CMapRec
name|root
decl_stmt|;
DECL|member|num_encodings
name|FT_UInt
name|num_encodings
decl_stmt|;
DECL|member|encodings
name|PCF_Encoding
name|encodings
decl_stmt|;
block|}
DECL|typedef|PCF_CMapRec
DECL|typedef|PCF_CMap
name|PCF_CMapRec
operator|,
typedef|*
name|PCF_CMap
typedef|;
end_typedef
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|pcf_cmap_init
argument_list|(
argument|FT_CMap     pcfcmap
argument_list|,
comment|/* PCF_CMap */
argument|FT_Pointer  init_data
argument_list|)
end_macro
begin_block
block|{
name|PCF_CMap
name|cmap
init|=
operator|(
name|PCF_CMap
operator|)
name|pcfcmap
decl_stmt|;
name|PCF_Face
name|face
init|=
operator|(
name|PCF_Face
operator|)
name|FT_CMAP_FACE
argument_list|(
name|pcfcmap
argument_list|)
decl_stmt|;
name|FT_UNUSED
argument_list|(
name|init_data
argument_list|)
expr_stmt|;
name|cmap
operator|->
name|num_encodings
operator|=
operator|(
name|FT_UInt
operator|)
name|face
operator|->
name|nencodings
expr_stmt|;
name|cmap
operator|->
name|encodings
operator|=
name|face
operator|->
name|encodings
expr_stmt|;
return|return
name|FT_Err_Ok
return|;
block|}
end_block
begin_macro
name|FT_CALLBACK_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|pcf_cmap_done
name|pcf_cmap_done
argument_list|(
argument|FT_CMap  pcfcmap
argument_list|)
end_macro
begin_comment
DECL|function|pcf_cmap_done
comment|/* PCF_CMap */
end_comment
begin_block
block|{
name|PCF_CMap
name|cmap
init|=
operator|(
name|PCF_CMap
operator|)
name|pcfcmap
decl_stmt|;
name|cmap
operator|->
name|encodings
operator|=
name|NULL
expr_stmt|;
name|cmap
operator|->
name|num_encodings
operator|=
literal|0
expr_stmt|;
block|}
end_block
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_UInt
argument_list|)
end_macro
begin_macro
name|pcf_cmap_char_index
argument_list|(
argument|FT_CMap    pcfcmap
argument_list|,
comment|/* PCF_CMap */
argument|FT_UInt32  charcode
argument_list|)
end_macro
begin_block
block|{
name|PCF_CMap
name|cmap
init|=
operator|(
name|PCF_CMap
operator|)
name|pcfcmap
decl_stmt|;
name|PCF_Encoding
name|encodings
init|=
name|cmap
operator|->
name|encodings
decl_stmt|;
name|FT_UInt
name|min
decl_stmt|,
name|max
decl_stmt|,
name|mid
decl_stmt|;
name|FT_UInt
name|result
init|=
literal|0
decl_stmt|;
name|min
operator|=
literal|0
expr_stmt|;
name|max
operator|=
name|cmap
operator|->
name|num_encodings
expr_stmt|;
while|while
condition|(
name|min
operator|<
name|max
condition|)
block|{
name|FT_ULong
name|code
decl_stmt|;
name|mid
operator|=
operator|(
name|min
operator|+
name|max
operator|)
operator|>>
literal|1
expr_stmt|;
name|code
operator|=
name|encodings
index|[
name|mid
index|]
operator|.
name|enc
expr_stmt|;
if|if
condition|(
name|charcode
operator|==
name|code
condition|)
block|{
name|result
operator|=
name|encodings
index|[
name|mid
index|]
operator|.
name|glyph
operator|+
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|charcode
operator|<
name|code
condition|)
name|max
operator|=
name|mid
expr_stmt|;
else|else
name|min
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_block
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_UInt
argument_list|)
end_macro
begin_macro
name|pcf_cmap_char_next
argument_list|(
argument|FT_CMap    pcfcmap
argument_list|,
comment|/* PCF_CMap */
argument|FT_UInt32  *acharcode
argument_list|)
end_macro
begin_block
block|{
name|PCF_CMap
name|cmap
init|=
operator|(
name|PCF_CMap
operator|)
name|pcfcmap
decl_stmt|;
name|PCF_Encoding
name|encodings
init|=
name|cmap
operator|->
name|encodings
decl_stmt|;
name|FT_UInt
name|min
decl_stmt|,
name|max
decl_stmt|,
name|mid
decl_stmt|;
name|FT_ULong
name|charcode
init|=
operator|*
name|acharcode
operator|+
literal|1
decl_stmt|;
name|FT_UInt
name|result
init|=
literal|0
decl_stmt|;
name|min
operator|=
literal|0
expr_stmt|;
name|max
operator|=
name|cmap
operator|->
name|num_encodings
expr_stmt|;
while|while
condition|(
name|min
operator|<
name|max
condition|)
block|{
name|FT_ULong
name|code
decl_stmt|;
name|mid
operator|=
operator|(
name|min
operator|+
name|max
operator|)
operator|>>
literal|1
expr_stmt|;
name|code
operator|=
name|encodings
index|[
name|mid
index|]
operator|.
name|enc
expr_stmt|;
if|if
condition|(
name|charcode
operator|==
name|code
condition|)
block|{
name|result
operator|=
name|encodings
index|[
name|mid
index|]
operator|.
name|glyph
operator|+
literal|1
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|charcode
operator|<
name|code
condition|)
name|max
operator|=
name|mid
expr_stmt|;
else|else
name|min
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
block|}
name|charcode
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|min
operator|<
name|cmap
operator|->
name|num_encodings
condition|)
block|{
name|charcode
operator|=
name|encodings
index|[
name|min
index|]
operator|.
name|enc
expr_stmt|;
name|result
operator|=
name|encodings
index|[
name|min
index|]
operator|.
name|glyph
operator|+
literal|1
expr_stmt|;
block|}
name|Exit
label|:
if|if
condition|(
name|charcode
operator|>
literal|0xFFFFFFFFUL
condition|)
block|{
name|FT_TRACE1
argument_list|(
operator|(
literal|"pcf_cmap_char_next: charcode 0x%x> 32bit API"
operator|)
argument_list|)
expr_stmt|;
operator|*
name|acharcode
operator|=
literal|0
expr_stmt|;
comment|/* XXX: result should be changed to indicate an overflow error */
block|}
else|else
operator|*
name|acharcode
operator|=
operator|(
name|FT_UInt32
operator|)
name|charcode
expr_stmt|;
return|return
name|result
return|;
block|}
end_block
begin_decl_stmt
specifier|static
DECL|variable|pcf_cmap_class
specifier|const
name|FT_CMap_ClassRec
name|pcf_cmap_class
init|=
block|{
sizeof|sizeof
argument_list|(
name|PCF_CMapRec
argument_list|)
block|,
name|pcf_cmap_init
block|,
name|pcf_cmap_done
block|,
name|pcf_cmap_char_index
block|,
name|pcf_cmap_char_next
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt
begin_macro
name|FT_CALLBACK_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|PCF_Face_Done
name|PCF_Face_Done
argument_list|(
argument|FT_Face  pcfface
argument_list|)
end_macro
begin_comment
DECL|function|PCF_Face_Done
comment|/* PCF_Face */
end_comment
begin_block
block|{
name|PCF_Face
name|face
init|=
operator|(
name|PCF_Face
operator|)
name|pcfface
decl_stmt|;
name|FT_Memory
name|memory
decl_stmt|;
if|if
condition|(
operator|!
name|face
condition|)
return|return;
name|memory
operator|=
name|FT_FACE_MEMORY
argument_list|(
name|face
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|face
operator|->
name|encodings
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|face
operator|->
name|metrics
argument_list|)
expr_stmt|;
comment|/* free properties */
if|if
condition|(
name|face
operator|->
name|properties
condition|)
block|{
name|FT_Int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|face
operator|->
name|nprops
condition|;
name|i
operator|++
control|)
block|{
name|PCF_Property
name|prop
init|=
operator|&
name|face
operator|->
name|properties
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|prop
condition|)
block|{
name|FT_FREE
argument_list|(
name|prop
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|prop
operator|->
name|isString
condition|)
name|FT_FREE
argument_list|(
name|prop
operator|->
name|value
operator|.
name|atom
argument_list|)
expr_stmt|;
block|}
block|}
name|FT_FREE
argument_list|(
name|face
operator|->
name|properties
argument_list|)
expr_stmt|;
block|}
name|FT_FREE
argument_list|(
name|face
operator|->
name|toc
operator|.
name|tables
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|pcfface
operator|->
name|family_name
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|pcfface
operator|->
name|style_name
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|pcfface
operator|->
name|available_sizes
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|face
operator|->
name|charset_encoding
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|face
operator|->
name|charset_registry
argument_list|)
expr_stmt|;
comment|/* close compressed stream if any */
if|if
condition|(
name|pcfface
operator|->
name|stream
operator|==
operator|&
name|face
operator|->
name|comp_stream
condition|)
block|{
name|FT_Stream_Close
argument_list|(
operator|&
name|face
operator|->
name|comp_stream
argument_list|)
expr_stmt|;
name|pcfface
operator|->
name|stream
operator|=
name|face
operator|->
name|comp_source
expr_stmt|;
block|}
block|}
end_block
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|PCF_Face_Init
argument_list|(
argument|FT_Stream      stream
argument_list|,
argument|FT_Face        pcfface
argument_list|,
comment|/* PCF_Face */
argument|FT_Int         face_index
argument_list|,
argument|FT_Int         num_params
argument_list|,
argument|FT_Parameter*  params
argument_list|)
end_macro
begin_block
block|{
name|PCF_Face
name|face
init|=
operator|(
name|PCF_Face
operator|)
name|pcfface
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|FT_UNUSED
argument_list|(
name|num_params
argument_list|)
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|params
argument_list|)
expr_stmt|;
name|FT_TRACE2
argument_list|(
operator|(
literal|"PCF driver\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|pcf_load_font
argument_list|(
name|stream
argument_list|,
name|face
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|PCF_Face_Done
argument_list|(
name|pcfface
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|FT_CONFIG_OPTION_USE_ZLIB
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|FT_CONFIG_OPTION_USE_LZW
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|FT_CONFIG_OPTION_USE_BZIP2
argument_list|)
ifdef|#
directive|ifdef
name|FT_CONFIG_OPTION_USE_ZLIB
block|{
name|FT_Error
name|error2
decl_stmt|;
comment|/* this didn't work, try gzip support! */
name|error2
operator|=
name|FT_Stream_OpenGzip
argument_list|(
operator|&
name|face
operator|->
name|comp_stream
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|FT_ERR_EQ
argument_list|(
name|error2
argument_list|,
name|Unimplemented_Feature
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
name|error
operator|=
name|error2
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* FT_CONFIG_OPTION_USE_ZLIB */
ifdef|#
directive|ifdef
name|FT_CONFIG_OPTION_USE_LZW
if|if
condition|(
name|error
condition|)
block|{
name|FT_Error
name|error3
decl_stmt|;
comment|/* this didn't work, try LZW support! */
name|error3
operator|=
name|FT_Stream_OpenLZW
argument_list|(
operator|&
name|face
operator|->
name|comp_stream
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|FT_ERR_EQ
argument_list|(
name|error3
argument_list|,
name|Unimplemented_Feature
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
name|error
operator|=
name|error3
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* FT_CONFIG_OPTION_USE_LZW */
ifdef|#
directive|ifdef
name|FT_CONFIG_OPTION_USE_BZIP2
if|if
condition|(
name|error
condition|)
block|{
name|FT_Error
name|error4
decl_stmt|;
comment|/* this didn't work, try Bzip2 support! */
name|error4
operator|=
name|FT_Stream_OpenBzip2
argument_list|(
operator|&
name|face
operator|->
name|comp_stream
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|FT_ERR_EQ
argument_list|(
name|error4
argument_list|,
name|Unimplemented_Feature
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
name|error
operator|=
name|error4
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* FT_CONFIG_OPTION_USE_BZIP2 */
if|if
condition|(
name|error
condition|)
goto|goto
name|Fail
goto|;
name|face
operator|->
name|comp_source
operator|=
name|stream
expr_stmt|;
name|pcfface
operator|->
name|stream
operator|=
operator|&
name|face
operator|->
name|comp_stream
expr_stmt|;
name|stream
operator|=
name|pcfface
operator|->
name|stream
expr_stmt|;
name|error
operator|=
name|pcf_load_font
argument_list|(
name|stream
argument_list|,
name|face
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Fail
goto|;
else|#
directive|else
comment|/* !(FT_CONFIG_OPTION_USE_ZLIB ||            FT_CONFIG_OPTION_USE_LZW ||            FT_CONFIG_OPTION_USE_BZIP2) */
goto|goto
name|Fail
goto|;
endif|#
directive|endif
block|}
comment|/* PCF could not have multiple face in single font file.      * XXX: non-zero face_index is already invalid argument, but      *      Type1, Type42 driver has a convention to return      *      an invalid argument error when the font could be      *      opened by the specified driver.      */
if|if
condition|(
name|face_index
operator|>
literal|0
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"PCF_Face_Init: invalid face index\n"
operator|)
argument_list|)
expr_stmt|;
name|PCF_Face_Done
argument_list|(
name|pcfface
argument_list|)
expr_stmt|;
return|return
name|FT_THROW
argument_list|(
name|Invalid_Argument
argument_list|)
return|;
block|}
comment|/* set up charmap */
block|{
name|FT_String
modifier|*
name|charset_registry
init|=
name|face
operator|->
name|charset_registry
decl_stmt|;
name|FT_String
modifier|*
name|charset_encoding
init|=
name|face
operator|->
name|charset_encoding
decl_stmt|;
name|FT_Bool
name|unicode_charmap
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|charset_registry
operator|&&
name|charset_encoding
condition|)
block|{
name|char
modifier|*
name|s
init|=
name|charset_registry
decl_stmt|;
comment|/* Uh, oh, compare first letters manually to avoid dependency            on locales. */
if|if
condition|(
operator|(
name|s
index|[
literal|0
index|]
operator|==
literal|'i'
operator|||
name|s
index|[
literal|0
index|]
operator|==
literal|'I'
operator|)
operator|&&
operator|(
name|s
index|[
literal|1
index|]
operator|==
literal|'s'
operator|||
name|s
index|[
literal|1
index|]
operator|==
literal|'S'
operator|)
operator|&&
operator|(
name|s
index|[
literal|2
index|]
operator|==
literal|'o'
operator|||
name|s
index|[
literal|2
index|]
operator|==
literal|'O'
operator|)
condition|)
block|{
name|s
operator|+=
literal|3
expr_stmt|;
if|if
condition|(
operator|!
name|ft_strcmp
argument_list|(
name|s
argument_list|,
literal|"10646"
argument_list|)
operator|||
operator|(
operator|!
name|ft_strcmp
argument_list|(
name|s
argument_list|,
literal|"8859"
argument_list|)
operator|&&
operator|!
name|ft_strcmp
argument_list|(
name|face
operator|->
name|charset_encoding
argument_list|,
literal|"1"
argument_list|)
operator|)
condition|)
name|unicode_charmap
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|{
name|FT_CharMapRec
name|charmap
decl_stmt|;
name|charmap
operator|.
name|face
operator|=
name|FT_FACE
argument_list|(
name|face
argument_list|)
expr_stmt|;
name|charmap
operator|.
name|encoding
operator|=
name|FT_ENCODING_NONE
expr_stmt|;
comment|/* initial platform/encoding should indicate unset status? */
name|charmap
operator|.
name|platform_id
operator|=
name|TT_PLATFORM_APPLE_UNICODE
expr_stmt|;
name|charmap
operator|.
name|encoding_id
operator|=
name|TT_APPLE_ID_DEFAULT
expr_stmt|;
if|if
condition|(
name|unicode_charmap
condition|)
block|{
name|charmap
operator|.
name|encoding
operator|=
name|FT_ENCODING_UNICODE
expr_stmt|;
name|charmap
operator|.
name|platform_id
operator|=
name|TT_PLATFORM_MICROSOFT
expr_stmt|;
name|charmap
operator|.
name|encoding_id
operator|=
name|TT_MS_ID_UNICODE_CS
expr_stmt|;
block|}
name|error
operator|=
name|FT_CMap_New
argument_list|(
operator|&
name|pcf_cmap_class
argument_list|,
name|NULL
argument_list|,
operator|&
name|charmap
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Select default charmap */
block|if ( pcfface->num_charmaps )           pcfface->charmap = pcfface->charmaps[0];
endif|#
directive|endif
block|}
block|}
name|Exit
label|:
return|return
name|error
return|;
name|Fail
label|:
name|FT_TRACE2
argument_list|(
operator|(
literal|"  not a PCF file\n"
operator|)
argument_list|)
expr_stmt|;
name|PCF_Face_Done
argument_list|(
name|pcfface
argument_list|)
expr_stmt|;
name|error
operator|=
name|FT_THROW
argument_list|(
name|Unknown_File_Format
argument_list|)
expr_stmt|;
comment|/* error */
goto|goto
name|Exit
goto|;
block|}
end_block
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|PCF_Size_Select
argument_list|(
argument|FT_Size   size
argument_list|,
argument|FT_ULong  strike_index
argument_list|)
end_macro
begin_block
block|{
name|PCF_Accel
name|accel
init|=
operator|&
operator|(
operator|(
name|PCF_Face
operator|)
name|size
operator|->
name|face
operator|)
operator|->
name|accel
decl_stmt|;
name|FT_Select_Metrics
argument_list|(
name|size
operator|->
name|face
argument_list|,
name|strike_index
argument_list|)
expr_stmt|;
name|size
operator|->
name|metrics
operator|.
name|ascender
operator|=
name|accel
operator|->
name|fontAscent
operator|<<
literal|6
expr_stmt|;
name|size
operator|->
name|metrics
operator|.
name|descender
operator|=
operator|-
name|accel
operator|->
name|fontDescent
operator|<<
literal|6
expr_stmt|;
name|size
operator|->
name|metrics
operator|.
name|max_advance
operator|=
name|accel
operator|->
name|maxbounds
operator|.
name|characterWidth
operator|<<
literal|6
expr_stmt|;
return|return
name|FT_Err_Ok
return|;
block|}
end_block
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|PCF_Size_Request
argument_list|(
argument|FT_Size          size
argument_list|,
argument|FT_Size_Request  req
argument_list|)
end_macro
begin_block
block|{
name|PCF_Face
name|face
init|=
operator|(
name|PCF_Face
operator|)
name|size
operator|->
name|face
decl_stmt|;
name|FT_Bitmap_Size
modifier|*
name|bsize
init|=
name|size
operator|->
name|face
operator|->
name|available_sizes
decl_stmt|;
name|FT_Error
name|error
init|=
name|FT_ERR
argument_list|(
name|Invalid_Pixel_Size
argument_list|)
decl_stmt|;
name|FT_Long
name|height
decl_stmt|;
name|height
operator|=
name|FT_REQUEST_HEIGHT
argument_list|(
name|req
argument_list|)
expr_stmt|;
name|height
operator|=
operator|(
name|height
operator|+
literal|32
operator|)
operator|>>
literal|6
expr_stmt|;
switch|switch
condition|(
name|req
operator|->
name|type
condition|)
block|{
case|case
name|FT_SIZE_REQUEST_TYPE_NOMINAL
case|:
if|if
condition|(
name|height
operator|==
operator|(
operator|(
name|bsize
operator|->
name|y_ppem
operator|+
literal|32
operator|)
operator|>>
literal|6
operator|)
condition|)
name|error
operator|=
name|FT_Err_Ok
expr_stmt|;
break|break;
case|case
name|FT_SIZE_REQUEST_TYPE_REAL_DIM
case|:
if|if
condition|(
name|height
operator|==
operator|(
name|face
operator|->
name|accel
operator|.
name|fontAscent
operator|+
name|face
operator|->
name|accel
operator|.
name|fontDescent
operator|)
condition|)
name|error
operator|=
name|FT_Err_Ok
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|FT_THROW
argument_list|(
name|Unimplemented_Feature
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
else|else
return|return
name|PCF_Size_Select
argument_list|(
name|size
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_block
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|PCF_Glyph_Load
argument_list|(
argument|FT_GlyphSlot  slot
argument_list|,
argument|FT_Size       size
argument_list|,
argument|FT_UInt       glyph_index
argument_list|,
argument|FT_Int32      load_flags
argument_list|)
end_macro
begin_block
block|{
name|PCF_Face
name|face
init|=
operator|(
name|PCF_Face
operator|)
name|FT_SIZE_FACE
argument_list|(
name|size
argument_list|)
decl_stmt|;
name|FT_Stream
name|stream
decl_stmt|;
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
name|FT_Bitmap
modifier|*
name|bitmap
init|=
operator|&
name|slot
operator|->
name|bitmap
decl_stmt|;
name|PCF_Metric
name|metric
decl_stmt|;
name|FT_Offset
name|bytes
decl_stmt|;
name|FT_UNUSED
argument_list|(
name|load_flags
argument_list|)
expr_stmt|;
name|FT_TRACE1
argument_list|(
operator|(
literal|"PCF_Glyph_Load: glyph index %d\n"
operator|,
name|glyph_index
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|face
condition|)
block|{
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Face_Handle
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|glyph_index
operator|>=
operator|(
name|FT_UInt
operator|)
name|face
operator|->
name|root
operator|.
name|num_glyphs
condition|)
block|{
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Argument
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|stream
operator|=
name|face
operator|->
name|root
operator|.
name|stream
expr_stmt|;
if|if
condition|(
name|glyph_index
operator|>
literal|0
condition|)
name|glyph_index
operator|--
expr_stmt|;
name|metric
operator|=
name|face
operator|->
name|metrics
operator|+
name|glyph_index
expr_stmt|;
name|bitmap
operator|->
name|rows
operator|=
name|metric
operator|->
name|ascent
operator|+
name|metric
operator|->
name|descent
expr_stmt|;
name|bitmap
operator|->
name|width
operator|=
name|metric
operator|->
name|rightSideBearing
operator|-
name|metric
operator|->
name|leftSideBearing
expr_stmt|;
name|bitmap
operator|->
name|num_grays
operator|=
literal|1
expr_stmt|;
name|bitmap
operator|->
name|pixel_mode
operator|=
name|FT_PIXEL_MODE_MONO
expr_stmt|;
name|FT_TRACE6
argument_list|(
operator|(
literal|"BIT_ORDER %d ; BYTE_ORDER %d ; GLYPH_PAD %d\n"
operator|,
name|PCF_BIT_ORDER
argument_list|(
name|face
operator|->
name|bitmapsFormat
argument_list|)
operator|,
name|PCF_BYTE_ORDER
argument_list|(
name|face
operator|->
name|bitmapsFormat
argument_list|)
operator|,
name|PCF_GLYPH_PAD
argument_list|(
name|face
operator|->
name|bitmapsFormat
argument_list|)
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|PCF_GLYPH_PAD
argument_list|(
name|face
operator|->
name|bitmapsFormat
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
name|bitmap
operator|->
name|pitch
operator|=
operator|(
name|bitmap
operator|->
name|width
operator|+
literal|7
operator|)
operator|>>
literal|3
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|bitmap
operator|->
name|pitch
operator|=
operator|(
operator|(
name|bitmap
operator|->
name|width
operator|+
literal|15
operator|)
operator|>>
literal|4
operator|)
operator|<<
literal|1
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|bitmap
operator|->
name|pitch
operator|=
operator|(
operator|(
name|bitmap
operator|->
name|width
operator|+
literal|31
operator|)
operator|>>
literal|5
operator|)
operator|<<
literal|2
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|bitmap
operator|->
name|pitch
operator|=
operator|(
operator|(
name|bitmap
operator|->
name|width
operator|+
literal|63
operator|)
operator|>>
literal|6
operator|)
operator|<<
literal|3
expr_stmt|;
break|break;
default|default:
return|return
name|FT_THROW
argument_list|(
name|Invalid_File_Format
argument_list|)
return|;
block|}
comment|/* XXX: to do: are there cases that need repadding the bitmap? */
name|bytes
operator|=
name|bitmap
operator|->
name|pitch
operator|*
name|bitmap
operator|->
name|rows
expr_stmt|;
name|error
operator|=
name|ft_glyphslot_alloc_bitmap
argument_list|(
name|slot
argument_list|,
operator|(
name|FT_ULong
operator|)
name|bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
if|if
condition|(
name|FT_STREAM_SEEK
argument_list|(
name|metric
operator|->
name|bits
argument_list|)
operator|||
name|FT_STREAM_READ
argument_list|(
name|bitmap
operator|->
name|buffer
argument_list|,
name|bytes
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
if|if
condition|(
name|PCF_BIT_ORDER
argument_list|(
name|face
operator|->
name|bitmapsFormat
argument_list|)
operator|!=
name|MSBFirst
condition|)
name|BitOrderInvert
argument_list|(
name|bitmap
operator|->
name|buffer
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|PCF_BYTE_ORDER
argument_list|(
name|face
operator|->
name|bitmapsFormat
argument_list|)
operator|!=
name|PCF_BIT_ORDER
argument_list|(
name|face
operator|->
name|bitmapsFormat
argument_list|)
operator|)
condition|)
block|{
switch|switch
condition|(
name|PCF_SCAN_UNIT
argument_list|(
name|face
operator|->
name|bitmapsFormat
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
break|break;
case|case
literal|2
case|:
name|TwoByteSwap
argument_list|(
name|bitmap
operator|->
name|buffer
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|FourByteSwap
argument_list|(
name|bitmap
operator|->
name|buffer
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|slot
operator|->
name|format
operator|=
name|FT_GLYPH_FORMAT_BITMAP
expr_stmt|;
name|slot
operator|->
name|bitmap_left
operator|=
name|metric
operator|->
name|leftSideBearing
expr_stmt|;
name|slot
operator|->
name|bitmap_top
operator|=
name|metric
operator|->
name|ascent
expr_stmt|;
name|slot
operator|->
name|metrics
operator|.
name|horiAdvance
operator|=
name|metric
operator|->
name|characterWidth
operator|<<
literal|6
expr_stmt|;
name|slot
operator|->
name|metrics
operator|.
name|horiBearingX
operator|=
name|metric
operator|->
name|leftSideBearing
operator|<<
literal|6
expr_stmt|;
name|slot
operator|->
name|metrics
operator|.
name|horiBearingY
operator|=
name|metric
operator|->
name|ascent
operator|<<
literal|6
expr_stmt|;
name|slot
operator|->
name|metrics
operator|.
name|width
operator|=
operator|(
name|metric
operator|->
name|rightSideBearing
operator|-
name|metric
operator|->
name|leftSideBearing
operator|)
operator|<<
literal|6
expr_stmt|;
name|slot
operator|->
name|metrics
operator|.
name|height
operator|=
name|bitmap
operator|->
name|rows
operator|<<
literal|6
expr_stmt|;
name|ft_synthesize_vertical_metrics
argument_list|(
operator|&
name|slot
operator|->
name|metrics
argument_list|,
operator|(
name|face
operator|->
name|accel
operator|.
name|fontAscent
operator|+
name|face
operator|->
name|accel
operator|.
name|fontDescent
operator|)
operator|<<
literal|6
argument_list|)
expr_stmt|;
name|Exit
label|:
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/*   *   *  BDF SERVICE   *   */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|pcf_get_bdf_property
name|pcf_get_bdf_property
parameter_list|(
name|PCF_Face
name|face
parameter_list|,
specifier|const
name|char
modifier|*
name|prop_name
parameter_list|,
name|BDF_PropertyRec
modifier|*
name|aproperty
parameter_list|)
block|{
name|PCF_Property
name|prop
decl_stmt|;
name|prop
operator|=
name|pcf_find_property
argument_list|(
name|face
argument_list|,
name|prop_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|prop
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|prop
operator|->
name|isString
condition|)
block|{
name|aproperty
operator|->
name|type
operator|=
name|BDF_PROPERTY_TYPE_ATOM
expr_stmt|;
name|aproperty
operator|->
name|u
operator|.
name|atom
operator|=
name|prop
operator|->
name|value
operator|.
name|atom
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|prop
operator|->
name|value
operator|.
name|l
operator|>
literal|0x7FFFFFFFL
operator|||
name|prop
operator|->
name|value
operator|.
name|l
operator|<
operator|(
operator|-
literal|1
operator|-
literal|0x7FFFFFFFL
operator|)
condition|)
block|{
name|FT_TRACE1
argument_list|(
operator|(
literal|"pcf_get_bdf_property: "
operator|)
argument_list|)
expr_stmt|;
name|FT_TRACE1
argument_list|(
operator|(
literal|"too large integer 0x%x is truncated\n"
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Apparently, the PCF driver loads all properties as signed integers!          * This really doesn't seem to be a problem, because this is          * sufficient for any meaningful values.          */
name|aproperty
operator|->
name|type
operator|=
name|BDF_PROPERTY_TYPE_INTEGER
expr_stmt|;
name|aproperty
operator|->
name|u
operator|.
name|integer
operator|=
operator|(
name|FT_Int32
operator|)
name|prop
operator|->
name|value
operator|.
name|l
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
return|return
name|FT_THROW
argument_list|(
name|Invalid_Argument
argument_list|)
return|;
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|pcf_get_charset_id
name|pcf_get_charset_id
parameter_list|(
name|PCF_Face
name|face
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|acharset_encoding
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|acharset_registry
parameter_list|)
block|{
operator|*
name|acharset_encoding
operator|=
name|face
operator|->
name|charset_encoding
expr_stmt|;
operator|*
name|acharset_registry
operator|=
name|face
operator|->
name|charset_registry
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|pcf_service_bdf
specifier|static
specifier|const
name|FT_Service_BDFRec
name|pcf_service_bdf
init|=
block|{
operator|(
name|FT_BDF_GetCharsetIdFunc
operator|)
name|pcf_get_charset_id
block|,
operator|(
name|FT_BDF_GetPropertyFunc
operator|)
name|pcf_get_bdf_property
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*   *   *  SERVICE LIST   *   */
end_comment
begin_decl_stmt
DECL|variable|pcf_services
specifier|static
specifier|const
name|FT_ServiceDescRec
name|pcf_services
index|[]
init|=
block|{
block|{
name|FT_SERVICE_ID_BDF
block|,
operator|&
name|pcf_service_bdf
block|}
block|,
block|{
name|FT_SERVICE_ID_XF86_NAME
block|,
name|FT_XF86_FORMAT_PCF
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_Module_Interface
argument_list|)
end_macro
begin_macro
name|pcf_driver_requester
argument_list|(
argument|FT_Module    module
argument_list|,
argument|const char*  name
argument_list|)
end_macro
begin_block
block|{
name|FT_UNUSED
argument_list|(
name|module
argument_list|)
expr_stmt|;
return|return
name|ft_service_list_lookup
argument_list|(
name|pcf_services
argument_list|,
name|name
argument_list|)
return|;
block|}
end_block
begin_decl_stmt
name|FT_CALLBACK_TABLE_DEF
DECL|variable|pcf_driver_class
specifier|const
name|FT_Driver_ClassRec
name|pcf_driver_class
init|=
block|{
block|{
name|FT_MODULE_FONT_DRIVER
operator||
name|FT_MODULE_DRIVER_NO_OUTLINES
block|,
sizeof|sizeof
argument_list|(
name|FT_DriverRec
argument_list|)
block|,
literal|"pcf"
block|,
literal|0x10000L
block|,
literal|0x20000L
block|,
literal|0
block|,
literal|0
block|,
comment|/* FT_Module_Constructor */
literal|0
block|,
comment|/* FT_Module_Destructor  */
name|pcf_driver_requester
block|}
block|,
sizeof|sizeof
argument_list|(
name|PCF_FaceRec
argument_list|)
block|,
sizeof|sizeof
argument_list|(
name|FT_SizeRec
argument_list|)
block|,
sizeof|sizeof
argument_list|(
name|FT_GlyphSlotRec
argument_list|)
block|,
name|PCF_Face_Init
block|,
name|PCF_Face_Done
block|,
literal|0
block|,
comment|/* FT_Size_InitFunc */
literal|0
block|,
comment|/* FT_Size_DoneFunc */
literal|0
block|,
comment|/* FT_Slot_InitFunc */
literal|0
block|,
comment|/* FT_Slot_DoneFunc */
name|PCF_Glyph_Load
block|,
literal|0
block|,
comment|/* FT_Face_GetKerningFunc  */
literal|0
block|,
comment|/* FT_Face_AttachFunc      */
literal|0
block|,
comment|/* FT_Face_GetAdvancesFunc */
name|PCF_Size_Request
block|,
name|PCF_Size_Select
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* END */
end_comment
end_unit
