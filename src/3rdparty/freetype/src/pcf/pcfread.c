begin_unit
begin_comment
comment|/*  pcfread.c      FreeType font driver for pcf fonts    Copyright 2000-2010, 2012-2014 by   Francesco Zappa Nardelli  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */
end_comment
begin_include
include|#
directive|include
file|<ft2build.h>
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_DEBUG_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_STREAM_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_OBJECTS_H
end_include
begin_include
include|#
directive|include
file|"pcf.h"
end_include
begin_include
include|#
directive|include
file|"pcfread.h"
end_include
begin_include
include|#
directive|include
file|"pcferror.h"
end_include
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
end_comment
begin_comment
comment|/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
end_comment
begin_comment
comment|/* messages during execution.                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_undef
DECL|macro|FT_COMPONENT
undef|#
directive|undef
name|FT_COMPONENT
end_undef
begin_define
DECL|macro|FT_COMPONENT
define|#
directive|define
name|FT_COMPONENT
value|trace_pcfread
end_define
begin_ifdef
ifdef|#
directive|ifdef
name|FT_DEBUG_LEVEL_TRACE
end_ifdef
begin_decl_stmt
DECL|variable|tableNames
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|tableNames
index|[]
init|=
block|{
literal|"prop"
block|,
literal|"accl"
block|,
literal|"mtrcs"
block|,
literal|"bmps"
block|,
literal|"imtrcs"
block|,
literal|"enc"
block|,
literal|"swidth"
block|,
literal|"names"
block|,
literal|"accel"
block|}
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_decl_stmt
specifier|static
DECL|variable|pcf_toc_header
specifier|const
name|FT_Frame_Field
name|pcf_toc_header
index|[]
init|=
block|{
DECL|macro|FT_STRUCTURE
undef|#
directive|undef
name|FT_STRUCTURE
DECL|macro|FT_STRUCTURE
define|#
directive|define
name|FT_STRUCTURE
value|PCF_TocRec
name|FT_FRAME_START
argument_list|(
literal|8
argument_list|)
block|,
name|FT_FRAME_ULONG_LE
argument_list|(
name|version
argument_list|)
block|,
name|FT_FRAME_ULONG_LE
argument_list|(
name|count
argument_list|)
block|,
name|FT_FRAME_END
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
specifier|static
DECL|variable|pcf_table_header
specifier|const
name|FT_Frame_Field
name|pcf_table_header
index|[]
init|=
block|{
DECL|macro|FT_STRUCTURE
undef|#
directive|undef
name|FT_STRUCTURE
DECL|macro|FT_STRUCTURE
define|#
directive|define
name|FT_STRUCTURE
value|PCF_TableRec
name|FT_FRAME_START
argument_list|(
literal|16
argument_list|)
block|,
name|FT_FRAME_ULONG_LE
argument_list|(
name|type
argument_list|)
block|,
name|FT_FRAME_ULONG_LE
argument_list|(
name|format
argument_list|)
block|,
name|FT_FRAME_ULONG_LE
argument_list|(
name|size
argument_list|)
block|,
comment|/* rounded up to a multiple of 4 */
name|FT_FRAME_ULONG_LE
argument_list|(
name|offset
argument_list|)
block|,
name|FT_FRAME_END
block|}
decl_stmt|;
end_decl_stmt
begin_function
specifier|static
name|FT_Error
DECL|function|pcf_read_TOC
name|pcf_read_TOC
parameter_list|(
name|FT_Stream
name|stream
parameter_list|,
name|PCF_Face
name|face
parameter_list|)
block|{
name|FT_Error
name|error
decl_stmt|;
name|PCF_Toc
name|toc
init|=
operator|&
name|face
operator|->
name|toc
decl_stmt|;
name|PCF_Table
name|tables
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|FT_FACE
argument_list|(
name|face
argument_list|)
operator|->
name|memory
decl_stmt|;
name|FT_UInt
name|n
decl_stmt|;
name|FT_ULong
name|size
decl_stmt|;
if|if
condition|(
name|FT_STREAM_SEEK
argument_list|(
literal|0
argument_list|)
operator|||
name|FT_STREAM_READ_FIELDS
argument_list|(
name|pcf_toc_header
argument_list|,
name|toc
argument_list|)
condition|)
return|return
name|FT_THROW
argument_list|(
name|Cannot_Open_Resource
argument_list|)
return|;
if|if
condition|(
name|toc
operator|->
name|version
operator|!=
name|PCF_FILE_VERSION
operator|||
name|toc
operator|->
name|count
operator|>
name|FT_ARRAY_MAX
argument_list|(
name|face
operator|->
name|toc
operator|.
name|tables
argument_list|)
operator|||
name|toc
operator|->
name|count
operator|==
literal|0
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_File_Format
argument_list|)
return|;
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|face
operator|->
name|toc
operator|.
name|tables
argument_list|,
name|toc
operator|->
name|count
argument_list|)
condition|)
return|return
name|FT_THROW
argument_list|(
name|Out_Of_Memory
argument_list|)
return|;
name|tables
operator|=
name|face
operator|->
name|toc
operator|.
name|tables
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|toc
operator|->
name|count
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|FT_STREAM_READ_FIELDS
argument_list|(
name|pcf_table_header
argument_list|,
name|tables
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|tables
operator|++
expr_stmt|;
block|}
comment|/* Sort tables and check for overlaps.  Because they are almost      */
comment|/* always ordered already, an in-place bubble sort with simultaneous */
comment|/* boundary checking seems appropriate.                              */
name|tables
operator|=
name|face
operator|->
name|toc
operator|.
name|tables
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|toc
operator|->
name|count
operator|-
literal|1
condition|;
name|n
operator|++
control|)
block|{
name|FT_UInt
name|i
decl_stmt|,
name|have_change
decl_stmt|;
name|have_change
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|toc
operator|->
name|count
operator|-
literal|1
operator|-
name|n
condition|;
name|i
operator|++
control|)
block|{
name|PCF_TableRec
name|tmp
decl_stmt|;
if|if
condition|(
name|tables
index|[
name|i
index|]
operator|.
name|offset
operator|>
name|tables
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|offset
condition|)
block|{
name|tmp
operator|=
name|tables
index|[
name|i
index|]
expr_stmt|;
name|tables
index|[
name|i
index|]
operator|=
name|tables
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|tables
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|tmp
expr_stmt|;
name|have_change
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|tables
index|[
name|i
index|]
operator|.
name|size
operator|>
name|tables
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|offset
operator|)
operator|||
operator|(
name|tables
index|[
name|i
index|]
operator|.
name|offset
operator|>
name|tables
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|offset
operator|-
name|tables
index|[
name|i
index|]
operator|.
name|size
operator|)
condition|)
block|{
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Offset
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
if|if
condition|(
operator|!
name|have_change
condition|)
break|break;
block|}
comment|/*      *  We now check whether the `size' and `offset' values are reasonable:      *  `offset' + `size' must not exceed the stream size.      *      *  Note, however, that X11's `pcfWriteFont' routine (used by the      *  `bdftopcf' program to create PDF font files) has two special      *  features.      *      *  - It always assigns the accelerator table a size of 100 bytes in the      *    TOC, regardless of its real size, which can vary between 34 and 72      *    bytes.      *      *  - Due to the way the routine is designed, it ships out the last font      *    table with its real size, ignoring the TOC's size value.  Since      *    the TOC size values are always rounded up to a multiple of 4, the      *    difference can be up to three bytes for all tables except the      *    accelerator table, for which the difference can be as large as 66      *    bytes.      *      */
name|tables
operator|=
name|face
operator|->
name|toc
operator|.
name|tables
expr_stmt|;
name|size
operator|=
name|stream
operator|->
name|size
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|toc
operator|->
name|count
operator|-
literal|1
condition|;
name|n
operator|++
control|)
block|{
comment|/* we need two checks to avoid overflow */
if|if
condition|(
operator|(
name|tables
operator|->
name|size
operator|>
name|size
operator|)
operator|||
operator|(
name|tables
operator|->
name|offset
operator|>
name|size
operator|-
name|tables
operator|->
name|size
operator|)
condition|)
block|{
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Table
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|tables
operator|++
expr_stmt|;
block|}
comment|/* only check `tables->offset' for last table element ... */
if|if
condition|(
operator|(
name|tables
operator|->
name|offset
operator|>
name|size
operator|)
condition|)
block|{
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Table
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* ... and adjust `tables->size' to the real value if necessary */
if|if
condition|(
name|tables
operator|->
name|size
operator|>
name|size
operator|-
name|tables
operator|->
name|offset
condition|)
name|tables
operator|->
name|size
operator|=
name|size
operator|-
name|tables
operator|->
name|offset
expr_stmt|;
ifdef|#
directive|ifdef
name|FT_DEBUG_LEVEL_TRACE
block|{
name|FT_UInt
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
literal|"?"
decl_stmt|;
name|FT_TRACE4
argument_list|(
operator|(
literal|"pcf_read_TOC:\n"
operator|)
argument_list|)
expr_stmt|;
name|FT_TRACE4
argument_list|(
operator|(
literal|"  number of tables: %ld\n"
operator|,
name|face
operator|->
name|toc
operator|.
name|count
operator|)
argument_list|)
expr_stmt|;
name|tables
operator|=
name|face
operator|->
name|toc
operator|.
name|tables
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|toc
operator|->
name|count
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
sizeof|sizeof
argument_list|(
name|tableNames
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|tableNames
index|[
literal|0
index|]
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|tables
index|[
name|i
index|]
operator|.
name|type
operator|==
call|(
name|FT_UInt
call|)
argument_list|(
literal|1
operator|<<
name|j
argument_list|)
condition|)
name|name
operator|=
name|tableNames
index|[
name|j
index|]
expr_stmt|;
name|FT_TRACE4
argument_list|(
operator|(
literal|"  %d: type=%s, format=0x%X, "
literal|"size=%ld (0x%lX), offset=%ld (0x%lX)\n"
operator|,
name|i
operator|,
name|name
operator|,
name|tables
index|[
name|i
index|]
operator|.
name|format
operator|,
name|tables
index|[
name|i
index|]
operator|.
name|size
operator|,
name|tables
index|[
name|i
index|]
operator|.
name|size
operator|,
name|tables
index|[
name|i
index|]
operator|.
name|offset
operator|,
name|tables
index|[
name|i
index|]
operator|.
name|offset
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
return|return
name|FT_Err_Ok
return|;
name|Exit
label|:
name|FT_FREE
argument_list|(
name|face
operator|->
name|toc
operator|.
name|tables
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_define
DECL|macro|PCF_METRIC_SIZE
define|#
directive|define
name|PCF_METRIC_SIZE
value|12
end_define
begin_decl_stmt
specifier|static
DECL|variable|pcf_metric_header
specifier|const
name|FT_Frame_Field
name|pcf_metric_header
index|[]
init|=
block|{
DECL|macro|FT_STRUCTURE
undef|#
directive|undef
name|FT_STRUCTURE
DECL|macro|FT_STRUCTURE
define|#
directive|define
name|FT_STRUCTURE
value|PCF_MetricRec
name|FT_FRAME_START
argument_list|(
name|PCF_METRIC_SIZE
argument_list|)
block|,
name|FT_FRAME_SHORT_LE
argument_list|(
name|leftSideBearing
argument_list|)
block|,
name|FT_FRAME_SHORT_LE
argument_list|(
name|rightSideBearing
argument_list|)
block|,
name|FT_FRAME_SHORT_LE
argument_list|(
name|characterWidth
argument_list|)
block|,
name|FT_FRAME_SHORT_LE
argument_list|(
name|ascent
argument_list|)
block|,
name|FT_FRAME_SHORT_LE
argument_list|(
name|descent
argument_list|)
block|,
name|FT_FRAME_SHORT_LE
argument_list|(
name|attributes
argument_list|)
block|,
name|FT_FRAME_END
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
specifier|static
DECL|variable|pcf_metric_msb_header
specifier|const
name|FT_Frame_Field
name|pcf_metric_msb_header
index|[]
init|=
block|{
DECL|macro|FT_STRUCTURE
undef|#
directive|undef
name|FT_STRUCTURE
DECL|macro|FT_STRUCTURE
define|#
directive|define
name|FT_STRUCTURE
value|PCF_MetricRec
name|FT_FRAME_START
argument_list|(
name|PCF_METRIC_SIZE
argument_list|)
block|,
name|FT_FRAME_SHORT
argument_list|(
name|leftSideBearing
argument_list|)
block|,
name|FT_FRAME_SHORT
argument_list|(
name|rightSideBearing
argument_list|)
block|,
name|FT_FRAME_SHORT
argument_list|(
name|characterWidth
argument_list|)
block|,
name|FT_FRAME_SHORT
argument_list|(
name|ascent
argument_list|)
block|,
name|FT_FRAME_SHORT
argument_list|(
name|descent
argument_list|)
block|,
name|FT_FRAME_SHORT
argument_list|(
name|attributes
argument_list|)
block|,
name|FT_FRAME_END
block|}
decl_stmt|;
end_decl_stmt
begin_define
DECL|macro|PCF_COMPRESSED_METRIC_SIZE
define|#
directive|define
name|PCF_COMPRESSED_METRIC_SIZE
value|5
end_define
begin_decl_stmt
specifier|static
DECL|variable|pcf_compressed_metric_header
specifier|const
name|FT_Frame_Field
name|pcf_compressed_metric_header
index|[]
init|=
block|{
DECL|macro|FT_STRUCTURE
undef|#
directive|undef
name|FT_STRUCTURE
DECL|macro|FT_STRUCTURE
define|#
directive|define
name|FT_STRUCTURE
value|PCF_Compressed_MetricRec
name|FT_FRAME_START
argument_list|(
name|PCF_COMPRESSED_METRIC_SIZE
argument_list|)
block|,
name|FT_FRAME_BYTE
argument_list|(
name|leftSideBearing
argument_list|)
block|,
name|FT_FRAME_BYTE
argument_list|(
name|rightSideBearing
argument_list|)
block|,
name|FT_FRAME_BYTE
argument_list|(
name|characterWidth
argument_list|)
block|,
name|FT_FRAME_BYTE
argument_list|(
name|ascent
argument_list|)
block|,
name|FT_FRAME_BYTE
argument_list|(
name|descent
argument_list|)
block|,
name|FT_FRAME_END
block|}
decl_stmt|;
end_decl_stmt
begin_function
specifier|static
name|FT_Error
DECL|function|pcf_get_metric
name|pcf_get_metric
parameter_list|(
name|FT_Stream
name|stream
parameter_list|,
name|FT_ULong
name|format
parameter_list|,
name|PCF_Metric
name|metric
parameter_list|)
block|{
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
if|if
condition|(
name|PCF_FORMAT_MATCH
argument_list|(
name|format
argument_list|,
name|PCF_DEFAULT_FORMAT
argument_list|)
condition|)
block|{
specifier|const
name|FT_Frame_Field
modifier|*
name|fields
decl_stmt|;
comment|/* parsing normal metrics */
name|fields
operator|=
name|PCF_BYTE_ORDER
argument_list|(
name|format
argument_list|)
operator|==
name|MSBFirst
condition|?
name|pcf_metric_msb_header
else|:
name|pcf_metric_header
expr_stmt|;
comment|/* the following sets `error' but doesn't return in case of failure */
operator|(
name|void
operator|)
name|FT_STREAM_READ_FIELDS
argument_list|(
name|fields
argument_list|,
name|metric
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PCF_Compressed_MetricRec
name|compr
decl_stmt|;
comment|/* parsing compressed metrics */
if|if
condition|(
name|FT_STREAM_READ_FIELDS
argument_list|(
name|pcf_compressed_metric_header
argument_list|,
operator|&
name|compr
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|metric
operator|->
name|leftSideBearing
operator|=
call|(
name|FT_Short
call|)
argument_list|(
name|compr
operator|.
name|leftSideBearing
operator|-
literal|0x80
argument_list|)
expr_stmt|;
name|metric
operator|->
name|rightSideBearing
operator|=
call|(
name|FT_Short
call|)
argument_list|(
name|compr
operator|.
name|rightSideBearing
operator|-
literal|0x80
argument_list|)
expr_stmt|;
name|metric
operator|->
name|characterWidth
operator|=
call|(
name|FT_Short
call|)
argument_list|(
name|compr
operator|.
name|characterWidth
operator|-
literal|0x80
argument_list|)
expr_stmt|;
name|metric
operator|->
name|ascent
operator|=
call|(
name|FT_Short
call|)
argument_list|(
name|compr
operator|.
name|ascent
operator|-
literal|0x80
argument_list|)
expr_stmt|;
name|metric
operator|->
name|descent
operator|=
call|(
name|FT_Short
call|)
argument_list|(
name|compr
operator|.
name|descent
operator|-
literal|0x80
argument_list|)
expr_stmt|;
name|metric
operator|->
name|attributes
operator|=
literal|0
expr_stmt|;
block|}
name|Exit
label|:
return|return
name|error
return|;
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|pcf_seek_to_table_type
name|pcf_seek_to_table_type
parameter_list|(
name|FT_Stream
name|stream
parameter_list|,
name|PCF_Table
name|tables
parameter_list|,
name|FT_ULong
name|ntables
parameter_list|,
comment|/* same as PCF_Toc->count */
name|FT_ULong
name|type
parameter_list|,
name|FT_ULong
modifier|*
name|aformat
parameter_list|,
name|FT_ULong
modifier|*
name|asize
parameter_list|)
block|{
name|FT_Error
name|error
init|=
name|FT_ERR
argument_list|(
name|Invalid_File_Format
argument_list|)
decl_stmt|;
name|FT_ULong
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntables
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|tables
index|[
name|i
index|]
operator|.
name|type
operator|==
name|type
condition|)
block|{
if|if
condition|(
name|stream
operator|->
name|pos
operator|>
name|tables
index|[
name|i
index|]
operator|.
name|offset
condition|)
block|{
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Stream_Skip
argument_list|)
expr_stmt|;
goto|goto
name|Fail
goto|;
block|}
if|if
condition|(
name|FT_STREAM_SKIP
argument_list|(
name|tables
index|[
name|i
index|]
operator|.
name|offset
operator|-
name|stream
operator|->
name|pos
argument_list|)
condition|)
block|{
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Stream_Skip
argument_list|)
expr_stmt|;
goto|goto
name|Fail
goto|;
block|}
operator|*
name|asize
operator|=
name|tables
index|[
name|i
index|]
operator|.
name|size
expr_stmt|;
operator|*
name|aformat
operator|=
name|tables
index|[
name|i
index|]
operator|.
name|format
expr_stmt|;
return|return
name|FT_Err_Ok
return|;
block|}
name|Fail
label|:
operator|*
name|asize
operator|=
literal|0
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_function
specifier|static
name|FT_Bool
DECL|function|pcf_has_table_type
name|pcf_has_table_type
parameter_list|(
name|PCF_Table
name|tables
parameter_list|,
name|FT_ULong
name|ntables
parameter_list|,
comment|/* same as PCF_Toc->count */
name|FT_ULong
name|type
parameter_list|)
block|{
name|FT_ULong
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntables
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|tables
index|[
name|i
index|]
operator|.
name|type
operator|==
name|type
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function
begin_define
DECL|macro|PCF_PROPERTY_SIZE
define|#
directive|define
name|PCF_PROPERTY_SIZE
value|9
end_define
begin_decl_stmt
specifier|static
DECL|variable|pcf_property_header
specifier|const
name|FT_Frame_Field
name|pcf_property_header
index|[]
init|=
block|{
DECL|macro|FT_STRUCTURE
undef|#
directive|undef
name|FT_STRUCTURE
DECL|macro|FT_STRUCTURE
define|#
directive|define
name|FT_STRUCTURE
value|PCF_ParsePropertyRec
name|FT_FRAME_START
argument_list|(
name|PCF_PROPERTY_SIZE
argument_list|)
block|,
name|FT_FRAME_LONG_LE
argument_list|(
name|name
argument_list|)
block|,
name|FT_FRAME_BYTE
argument_list|(
name|isString
argument_list|)
block|,
name|FT_FRAME_LONG_LE
argument_list|(
name|value
argument_list|)
block|,
name|FT_FRAME_END
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
specifier|static
DECL|variable|pcf_property_msb_header
specifier|const
name|FT_Frame_Field
name|pcf_property_msb_header
index|[]
init|=
block|{
DECL|macro|FT_STRUCTURE
undef|#
directive|undef
name|FT_STRUCTURE
DECL|macro|FT_STRUCTURE
define|#
directive|define
name|FT_STRUCTURE
value|PCF_ParsePropertyRec
name|FT_FRAME_START
argument_list|(
name|PCF_PROPERTY_SIZE
argument_list|)
block|,
name|FT_FRAME_LONG
argument_list|(
name|name
argument_list|)
block|,
name|FT_FRAME_BYTE
argument_list|(
name|isString
argument_list|)
block|,
name|FT_FRAME_LONG
argument_list|(
name|value
argument_list|)
block|,
name|FT_FRAME_END
block|}
decl_stmt|;
end_decl_stmt
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|PCF_Property
argument_list|)
end_macro
begin_macro
name|pcf_find_property
argument_list|(
argument|PCF_Face          face
argument_list|,
argument|const FT_String*  prop
argument_list|)
end_macro
begin_block
block|{
name|PCF_Property
name|properties
init|=
name|face
operator|->
name|properties
decl_stmt|;
name|FT_Bool
name|found
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|face
operator|->
name|nprops
operator|&&
operator|!
name|found
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|ft_strcmp
argument_list|(
name|properties
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|prop
argument_list|)
condition|)
name|found
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|found
condition|)
return|return
name|properties
operator|+
name|i
operator|-
literal|1
return|;
else|else
return|return
name|NULL
return|;
block|}
end_block
begin_function
specifier|static
name|FT_Error
DECL|function|pcf_get_properties
name|pcf_get_properties
parameter_list|(
name|FT_Stream
name|stream
parameter_list|,
name|PCF_Face
name|face
parameter_list|)
block|{
name|PCF_ParseProperty
name|props
init|=
literal|0
decl_stmt|;
name|PCF_Property
name|properties
init|=
name|NULL
decl_stmt|;
name|FT_ULong
name|nprops
decl_stmt|,
name|i
decl_stmt|;
name|FT_ULong
name|format
decl_stmt|,
name|size
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|FT_FACE
argument_list|(
name|face
argument_list|)
operator|->
name|memory
decl_stmt|;
name|FT_ULong
name|string_size
decl_stmt|;
name|FT_String
modifier|*
name|strings
init|=
literal|0
decl_stmt|;
name|error
operator|=
name|pcf_seek_to_table_type
argument_list|(
name|stream
argument_list|,
name|face
operator|->
name|toc
operator|.
name|tables
argument_list|,
name|face
operator|->
name|toc
operator|.
name|count
argument_list|,
name|PCF_PROPERTIES
argument_list|,
operator|&
name|format
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Bail
goto|;
if|if
condition|(
name|FT_READ_ULONG_LE
argument_list|(
name|format
argument_list|)
condition|)
goto|goto
name|Bail
goto|;
name|FT_TRACE4
argument_list|(
operator|(
literal|"pcf_get_properties:\n"
operator|)
argument_list|)
expr_stmt|;
name|FT_TRACE4
argument_list|(
operator|(
literal|"  format = %ld\n"
operator|,
name|format
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PCF_FORMAT_MATCH
argument_list|(
name|format
argument_list|,
name|PCF_DEFAULT_FORMAT
argument_list|)
condition|)
goto|goto
name|Bail
goto|;
if|if
condition|(
name|PCF_BYTE_ORDER
argument_list|(
name|format
argument_list|)
operator|==
name|MSBFirst
condition|)
operator|(
name|void
operator|)
name|FT_READ_ULONG
argument_list|(
name|nprops
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|FT_READ_ULONG_LE
argument_list|(
name|nprops
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Bail
goto|;
name|FT_TRACE4
argument_list|(
operator|(
literal|"  nprop = %d (truncate %d props)\n"
operator|,
operator|(
name|int
operator|)
name|nprops
operator|,
name|nprops
operator|-
operator|(
name|int
operator|)
name|nprops
operator|)
argument_list|)
expr_stmt|;
name|nprops
operator|=
operator|(
name|int
operator|)
name|nprops
expr_stmt|;
comment|/* rough estimate */
if|if
condition|(
name|nprops
operator|>
name|size
operator|/
name|PCF_PROPERTY_SIZE
condition|)
block|{
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Table
argument_list|)
expr_stmt|;
goto|goto
name|Bail
goto|;
block|}
name|face
operator|->
name|nprops
operator|=
operator|(
name|int
operator|)
name|nprops
expr_stmt|;
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|props
argument_list|,
name|nprops
argument_list|)
condition|)
goto|goto
name|Bail
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nprops
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|PCF_BYTE_ORDER
argument_list|(
name|format
argument_list|)
operator|==
name|MSBFirst
condition|)
block|{
if|if
condition|(
name|FT_STREAM_READ_FIELDS
argument_list|(
name|pcf_property_msb_header
argument_list|,
name|props
operator|+
name|i
argument_list|)
condition|)
goto|goto
name|Bail
goto|;
block|}
else|else
block|{
if|if
condition|(
name|FT_STREAM_READ_FIELDS
argument_list|(
name|pcf_property_header
argument_list|,
name|props
operator|+
name|i
argument_list|)
condition|)
goto|goto
name|Bail
goto|;
block|}
block|}
comment|/* pad the property array                                            */
comment|/*                                                                   */
comment|/* clever here - nprops is the same as the number of odd-units read, */
comment|/* as only isStringProp are odd length   (Keith Packard)             */
comment|/*                                                                   */
if|if
condition|(
name|nprops
operator|&
literal|3
condition|)
block|{
name|i
operator|=
literal|4
operator|-
operator|(
name|nprops
operator|&
literal|3
operator|)
expr_stmt|;
if|if
condition|(
name|FT_STREAM_SKIP
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Stream_Skip
argument_list|)
expr_stmt|;
goto|goto
name|Bail
goto|;
block|}
block|}
if|if
condition|(
name|PCF_BYTE_ORDER
argument_list|(
name|format
argument_list|)
operator|==
name|MSBFirst
condition|)
operator|(
name|void
operator|)
name|FT_READ_ULONG
argument_list|(
name|string_size
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|FT_READ_ULONG_LE
argument_list|(
name|string_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Bail
goto|;
name|FT_TRACE4
argument_list|(
operator|(
literal|"  string_size = %ld\n"
operator|,
name|string_size
operator|)
argument_list|)
expr_stmt|;
comment|/* rough estimate */
if|if
condition|(
name|string_size
operator|>
name|size
operator|-
name|nprops
operator|*
name|PCF_PROPERTY_SIZE
condition|)
block|{
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Table
argument_list|)
expr_stmt|;
goto|goto
name|Bail
goto|;
block|}
comment|/* allocate one more byte so that we have a final null byte */
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|strings
argument_list|,
name|string_size
operator|+
literal|1
argument_list|)
condition|)
goto|goto
name|Bail
goto|;
name|error
operator|=
name|FT_Stream_Read
argument_list|(
name|stream
argument_list|,
operator|(
name|FT_Byte
operator|*
operator|)
name|strings
argument_list|,
name|string_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Bail
goto|;
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|properties
argument_list|,
name|nprops
argument_list|)
condition|)
goto|goto
name|Bail
goto|;
name|face
operator|->
name|properties
operator|=
name|properties
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nprops
condition|;
name|i
operator|++
control|)
block|{
name|FT_Long
name|name_offset
init|=
name|props
index|[
name|i
index|]
operator|.
name|name
decl_stmt|;
if|if
condition|(
operator|(
name|name_offset
operator|<
literal|0
operator|)
operator|||
operator|(
operator|(
name|FT_ULong
operator|)
name|name_offset
operator|>
name|string_size
operator|)
condition|)
block|{
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Offset
argument_list|)
expr_stmt|;
goto|goto
name|Bail
goto|;
block|}
if|if
condition|(
name|FT_STRDUP
argument_list|(
name|properties
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|strings
operator|+
name|name_offset
argument_list|)
condition|)
goto|goto
name|Bail
goto|;
name|FT_TRACE4
argument_list|(
operator|(
literal|"  %s:"
operator|,
name|properties
index|[
name|i
index|]
operator|.
name|name
operator|)
argument_list|)
expr_stmt|;
name|properties
index|[
name|i
index|]
operator|.
name|isString
operator|=
name|props
index|[
name|i
index|]
operator|.
name|isString
expr_stmt|;
if|if
condition|(
name|props
index|[
name|i
index|]
operator|.
name|isString
condition|)
block|{
name|FT_Long
name|value_offset
init|=
name|props
index|[
name|i
index|]
operator|.
name|value
decl_stmt|;
if|if
condition|(
operator|(
name|value_offset
operator|<
literal|0
operator|)
operator|||
operator|(
operator|(
name|FT_ULong
operator|)
name|value_offset
operator|>
name|string_size
operator|)
condition|)
block|{
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Offset
argument_list|)
expr_stmt|;
goto|goto
name|Bail
goto|;
block|}
if|if
condition|(
name|FT_STRDUP
argument_list|(
name|properties
index|[
name|i
index|]
operator|.
name|value
operator|.
name|atom
argument_list|,
name|strings
operator|+
name|value_offset
argument_list|)
condition|)
goto|goto
name|Bail
goto|;
name|FT_TRACE4
argument_list|(
operator|(
literal|" `%s'\n"
operator|,
name|properties
index|[
name|i
index|]
operator|.
name|value
operator|.
name|atom
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|properties
index|[
name|i
index|]
operator|.
name|value
operator|.
name|l
operator|=
name|props
index|[
name|i
index|]
operator|.
name|value
expr_stmt|;
name|FT_TRACE4
argument_list|(
operator|(
literal|" %d\n"
operator|,
name|properties
index|[
name|i
index|]
operator|.
name|value
operator|.
name|l
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
name|error
operator|=
name|FT_Err_Ok
expr_stmt|;
name|Bail
label|:
name|FT_FREE
argument_list|(
name|props
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|strings
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|pcf_get_metrics
name|pcf_get_metrics
parameter_list|(
name|FT_Stream
name|stream
parameter_list|,
name|PCF_Face
name|face
parameter_list|)
block|{
name|FT_Error
name|error
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|FT_FACE
argument_list|(
name|face
argument_list|)
operator|->
name|memory
decl_stmt|;
name|FT_ULong
name|format
decl_stmt|,
name|size
decl_stmt|;
name|PCF_Metric
name|metrics
init|=
literal|0
decl_stmt|;
name|FT_ULong
name|nmetrics
decl_stmt|,
name|i
decl_stmt|;
name|error
operator|=
name|pcf_seek_to_table_type
argument_list|(
name|stream
argument_list|,
name|face
operator|->
name|toc
operator|.
name|tables
argument_list|,
name|face
operator|->
name|toc
operator|.
name|count
argument_list|,
name|PCF_METRICS
argument_list|,
operator|&
name|format
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
name|FT_READ_ULONG_LE
argument_list|(
name|format
argument_list|)
condition|)
goto|goto
name|Bail
goto|;
if|if
condition|(
operator|!
name|PCF_FORMAT_MATCH
argument_list|(
name|format
argument_list|,
name|PCF_DEFAULT_FORMAT
argument_list|)
operator|&&
operator|!
name|PCF_FORMAT_MATCH
argument_list|(
name|format
argument_list|,
name|PCF_COMPRESSED_METRICS
argument_list|)
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_File_Format
argument_list|)
return|;
if|if
condition|(
name|PCF_FORMAT_MATCH
argument_list|(
name|format
argument_list|,
name|PCF_DEFAULT_FORMAT
argument_list|)
condition|)
block|{
if|if
condition|(
name|PCF_BYTE_ORDER
argument_list|(
name|format
argument_list|)
operator|==
name|MSBFirst
condition|)
operator|(
name|void
operator|)
name|FT_READ_ULONG
argument_list|(
name|nmetrics
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|FT_READ_ULONG_LE
argument_list|(
name|nmetrics
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|PCF_BYTE_ORDER
argument_list|(
name|format
argument_list|)
operator|==
name|MSBFirst
condition|)
operator|(
name|void
operator|)
name|FT_READ_USHORT
argument_list|(
name|nmetrics
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|FT_READ_USHORT_LE
argument_list|(
name|nmetrics
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_File_Format
argument_list|)
return|;
name|face
operator|->
name|nmetrics
operator|=
name|nmetrics
expr_stmt|;
if|if
condition|(
operator|!
name|nmetrics
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_Table
argument_list|)
return|;
name|FT_TRACE4
argument_list|(
operator|(
literal|"pcf_get_metrics:\n"
operator|)
argument_list|)
expr_stmt|;
name|FT_TRACE4
argument_list|(
operator|(
literal|"  number of metrics: %d\n"
operator|,
name|nmetrics
operator|)
argument_list|)
expr_stmt|;
comment|/* rough estimate */
if|if
condition|(
name|PCF_FORMAT_MATCH
argument_list|(
name|format
argument_list|,
name|PCF_DEFAULT_FORMAT
argument_list|)
condition|)
block|{
if|if
condition|(
name|nmetrics
operator|>
name|size
operator|/
name|PCF_METRIC_SIZE
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_Table
argument_list|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|nmetrics
operator|>
name|size
operator|/
name|PCF_COMPRESSED_METRIC_SIZE
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_Table
argument_list|)
return|;
block|}
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|face
operator|->
name|metrics
argument_list|,
name|nmetrics
argument_list|)
condition|)
return|return
name|FT_THROW
argument_list|(
name|Out_Of_Memory
argument_list|)
return|;
name|metrics
operator|=
name|face
operator|->
name|metrics
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nmetrics
condition|;
name|i
operator|++
operator|,
name|metrics
operator|++
control|)
block|{
name|error
operator|=
name|pcf_get_metric
argument_list|(
name|stream
argument_list|,
name|format
argument_list|,
name|metrics
argument_list|)
expr_stmt|;
name|metrics
operator|->
name|bits
operator|=
literal|0
expr_stmt|;
name|FT_TRACE5
argument_list|(
operator|(
literal|"  idx %d: width=%d, "
literal|"lsb=%d, rsb=%d, ascent=%d, descent=%d, swidth=%d\n"
operator|,
name|i
operator|,
name|metrics
operator|->
name|characterWidth
operator|,
name|metrics
operator|->
name|leftSideBearing
operator|,
name|metrics
operator|->
name|rightSideBearing
operator|,
name|metrics
operator|->
name|ascent
operator|,
name|metrics
operator|->
name|descent
operator|,
name|metrics
operator|->
name|attributes
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
comment|/* sanity checks -- those values are used in `PCF_Glyph_Load' to     */
comment|/* compute a glyph's bitmap dimensions, thus setting them to zero in */
comment|/* case of an error disables this particular glyph only              */
if|if
condition|(
name|metrics
operator|->
name|rightSideBearing
operator|<
name|metrics
operator|->
name|leftSideBearing
operator|||
name|metrics
operator|->
name|ascent
operator|+
name|metrics
operator|->
name|descent
operator|<
literal|0
condition|)
block|{
name|metrics
operator|->
name|characterWidth
operator|=
literal|0
expr_stmt|;
name|metrics
operator|->
name|leftSideBearing
operator|=
literal|0
expr_stmt|;
name|metrics
operator|->
name|rightSideBearing
operator|=
literal|0
expr_stmt|;
name|metrics
operator|->
name|ascent
operator|=
literal|0
expr_stmt|;
name|metrics
operator|->
name|descent
operator|=
literal|0
expr_stmt|;
name|FT_TRACE0
argument_list|(
operator|(
literal|"pcf_get_metrics:"
literal|" invalid metrics for glyph %d\n"
operator|,
name|i
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|error
condition|)
name|FT_FREE
argument_list|(
name|face
operator|->
name|metrics
argument_list|)
expr_stmt|;
name|Bail
label|:
return|return
name|error
return|;
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|pcf_get_bitmaps
name|pcf_get_bitmaps
parameter_list|(
name|FT_Stream
name|stream
parameter_list|,
name|PCF_Face
name|face
parameter_list|)
block|{
name|FT_Error
name|error
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|FT_FACE
argument_list|(
name|face
argument_list|)
operator|->
name|memory
decl_stmt|;
name|FT_Long
modifier|*
name|offsets
init|=
name|NULL
decl_stmt|;
name|FT_Long
name|bitmapSizes
index|[
name|GLYPHPADOPTIONS
index|]
decl_stmt|;
name|FT_ULong
name|format
decl_stmt|,
name|size
decl_stmt|;
name|FT_ULong
name|nbitmaps
decl_stmt|,
name|i
decl_stmt|,
name|sizebitmaps
init|=
literal|0
decl_stmt|;
name|error
operator|=
name|pcf_seek_to_table_type
argument_list|(
name|stream
argument_list|,
name|face
operator|->
name|toc
operator|.
name|tables
argument_list|,
name|face
operator|->
name|toc
operator|.
name|count
argument_list|,
name|PCF_BITMAPS
argument_list|,
operator|&
name|format
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|error
operator|=
name|FT_Stream_EnterFrame
argument_list|(
name|stream
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|format
operator|=
name|FT_GET_ULONG_LE
argument_list|()
expr_stmt|;
if|if
condition|(
name|PCF_BYTE_ORDER
argument_list|(
name|format
argument_list|)
operator|==
name|MSBFirst
condition|)
name|nbitmaps
operator|=
name|FT_GET_ULONG
argument_list|()
expr_stmt|;
else|else
name|nbitmaps
operator|=
name|FT_GET_ULONG_LE
argument_list|()
expr_stmt|;
name|FT_Stream_ExitFrame
argument_list|(
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PCF_FORMAT_MATCH
argument_list|(
name|format
argument_list|,
name|PCF_DEFAULT_FORMAT
argument_list|)
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_File_Format
argument_list|)
return|;
name|FT_TRACE4
argument_list|(
operator|(
literal|"pcf_get_bitmaps:\n"
operator|)
argument_list|)
expr_stmt|;
name|FT_TRACE4
argument_list|(
operator|(
literal|"  number of bitmaps: %d\n"
operator|,
name|nbitmaps
operator|)
argument_list|)
expr_stmt|;
comment|/* XXX: PCF_Face->nmetrics is signed FT_Long, see pcf.h */
if|if
condition|(
name|face
operator|->
name|nmetrics
operator|<
literal|0
operator|||
name|nbitmaps
operator|!=
operator|(
name|FT_ULong
operator|)
name|face
operator|->
name|nmetrics
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_File_Format
argument_list|)
return|;
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|offsets
argument_list|,
name|nbitmaps
argument_list|)
condition|)
return|return
name|error
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbitmaps
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|PCF_BYTE_ORDER
argument_list|(
name|format
argument_list|)
operator|==
name|MSBFirst
condition|)
operator|(
name|void
operator|)
name|FT_READ_LONG
argument_list|(
name|offsets
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|FT_READ_LONG_LE
argument_list|(
name|offsets
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|FT_TRACE5
argument_list|(
operator|(
literal|"  bitmap %d: offset %ld (0x%lX)\n"
operator|,
name|i
operator|,
name|offsets
index|[
name|i
index|]
operator|,
name|offsets
index|[
name|i
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
goto|goto
name|Bail
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GLYPHPADOPTIONS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|PCF_BYTE_ORDER
argument_list|(
name|format
argument_list|)
operator|==
name|MSBFirst
condition|)
operator|(
name|void
operator|)
name|FT_READ_LONG
argument_list|(
name|bitmapSizes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|FT_READ_LONG_LE
argument_list|(
name|bitmapSizes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Bail
goto|;
name|sizebitmaps
operator|=
name|bitmapSizes
index|[
name|PCF_GLYPH_PAD_INDEX
argument_list|(
name|format
argument_list|)
index|]
expr_stmt|;
name|FT_TRACE4
argument_list|(
operator|(
literal|"  padding %d implies a size of %ld\n"
operator|,
name|i
operator|,
name|bitmapSizes
index|[
name|i
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
name|FT_TRACE4
argument_list|(
operator|(
literal|"  %d bitmaps, padding index %ld\n"
operator|,
name|nbitmaps
operator|,
name|PCF_GLYPH_PAD_INDEX
argument_list|(
name|format
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|FT_TRACE4
argument_list|(
operator|(
literal|"  bitmap size = %d\n"
operator|,
name|sizebitmaps
operator|)
argument_list|)
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|sizebitmaps
argument_list|)
expr_stmt|;
comment|/* only used for debugging */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbitmaps
condition|;
name|i
operator|++
control|)
block|{
comment|/* rough estimate */
if|if
condition|(
operator|(
name|offsets
index|[
name|i
index|]
operator|<
literal|0
operator|)
operator|||
operator|(
operator|(
name|FT_ULong
operator|)
name|offsets
index|[
name|i
index|]
operator|>
name|size
operator|)
condition|)
block|{
name|FT_TRACE0
argument_list|(
operator|(
literal|"pcf_get_bitmaps:"
literal|" invalid offset to bitmap data of glyph %d\n"
operator|,
name|i
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
name|face
operator|->
name|metrics
index|[
name|i
index|]
operator|.
name|bits
operator|=
name|stream
operator|->
name|pos
operator|+
name|offsets
index|[
name|i
index|]
expr_stmt|;
block|}
name|face
operator|->
name|bitmapsFormat
operator|=
name|format
expr_stmt|;
name|Bail
label|:
name|FT_FREE
argument_list|(
name|offsets
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|pcf_get_encodings
name|pcf_get_encodings
parameter_list|(
name|FT_Stream
name|stream
parameter_list|,
name|PCF_Face
name|face
parameter_list|)
block|{
name|FT_Error
name|error
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|FT_FACE
argument_list|(
name|face
argument_list|)
operator|->
name|memory
decl_stmt|;
name|FT_ULong
name|format
decl_stmt|,
name|size
decl_stmt|;
name|int
name|firstCol
decl_stmt|,
name|lastCol
decl_stmt|;
name|int
name|firstRow
decl_stmt|,
name|lastRow
decl_stmt|;
name|int
name|nencoding
decl_stmt|,
name|encodingOffset
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|PCF_Encoding
name|encoding
init|=
name|NULL
decl_stmt|;
name|error
operator|=
name|pcf_seek_to_table_type
argument_list|(
name|stream
argument_list|,
name|face
operator|->
name|toc
operator|.
name|tables
argument_list|,
name|face
operator|->
name|toc
operator|.
name|count
argument_list|,
name|PCF_BDF_ENCODINGS
argument_list|,
operator|&
name|format
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|error
operator|=
name|FT_Stream_EnterFrame
argument_list|(
name|stream
argument_list|,
literal|14
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|format
operator|=
name|FT_GET_ULONG_LE
argument_list|()
expr_stmt|;
if|if
condition|(
name|PCF_BYTE_ORDER
argument_list|(
name|format
argument_list|)
operator|==
name|MSBFirst
condition|)
block|{
name|firstCol
operator|=
name|FT_GET_SHORT
argument_list|()
expr_stmt|;
name|lastCol
operator|=
name|FT_GET_SHORT
argument_list|()
expr_stmt|;
name|firstRow
operator|=
name|FT_GET_SHORT
argument_list|()
expr_stmt|;
name|lastRow
operator|=
name|FT_GET_SHORT
argument_list|()
expr_stmt|;
name|face
operator|->
name|defaultChar
operator|=
name|FT_GET_SHORT
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|firstCol
operator|=
name|FT_GET_SHORT_LE
argument_list|()
expr_stmt|;
name|lastCol
operator|=
name|FT_GET_SHORT_LE
argument_list|()
expr_stmt|;
name|firstRow
operator|=
name|FT_GET_SHORT_LE
argument_list|()
expr_stmt|;
name|lastRow
operator|=
name|FT_GET_SHORT_LE
argument_list|()
expr_stmt|;
name|face
operator|->
name|defaultChar
operator|=
name|FT_GET_SHORT_LE
argument_list|()
expr_stmt|;
block|}
name|FT_Stream_ExitFrame
argument_list|(
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PCF_FORMAT_MATCH
argument_list|(
name|format
argument_list|,
name|PCF_DEFAULT_FORMAT
argument_list|)
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_File_Format
argument_list|)
return|;
comment|/* sanity checks */
if|if
condition|(
name|firstCol
operator|<
literal|0
operator|||
name|firstCol
operator|>
name|lastCol
operator|||
name|lastCol
operator|>
literal|0xFF
operator|||
name|firstRow
operator|<
literal|0
operator|||
name|firstRow
operator|>
name|lastRow
operator|||
name|lastRow
operator|>
literal|0xFF
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_Table
argument_list|)
return|;
name|FT_TRACE4
argument_list|(
operator|(
literal|"pdf_get_encodings:\n"
operator|)
argument_list|)
expr_stmt|;
name|FT_TRACE4
argument_list|(
operator|(
literal|"  firstCol %d, lastCol %d, firstRow %d, lastRow %d\n"
operator|,
name|firstCol
operator|,
name|lastCol
operator|,
name|firstRow
operator|,
name|lastRow
operator|)
argument_list|)
expr_stmt|;
name|nencoding
operator|=
operator|(
name|lastCol
operator|-
name|firstCol
operator|+
literal|1
operator|)
operator|*
operator|(
name|lastRow
operator|-
name|firstRow
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|encoding
argument_list|,
name|nencoding
argument_list|)
condition|)
return|return
name|FT_THROW
argument_list|(
name|Out_Of_Memory
argument_list|)
return|;
name|error
operator|=
name|FT_Stream_EnterFrame
argument_list|(
name|stream
argument_list|,
literal|2
operator|*
name|nencoding
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Bail
goto|;
name|k
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|firstRow
init|;
name|i
operator|<=
name|lastRow
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
name|firstCol
init|;
name|j
operator|<=
name|lastCol
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|PCF_BYTE_ORDER
argument_list|(
name|format
argument_list|)
operator|==
name|MSBFirst
condition|)
name|encodingOffset
operator|=
name|FT_GET_SHORT
argument_list|()
expr_stmt|;
else|else
name|encodingOffset
operator|=
name|FT_GET_SHORT_LE
argument_list|()
expr_stmt|;
if|if
condition|(
name|encodingOffset
operator|!=
operator|-
literal|1
condition|)
block|{
name|encoding
index|[
name|k
index|]
operator|.
name|enc
operator|=
name|i
operator|*
literal|256
operator|+
name|j
expr_stmt|;
name|encoding
index|[
name|k
index|]
operator|.
name|glyph
operator|=
operator|(
name|FT_Short
operator|)
name|encodingOffset
expr_stmt|;
name|FT_TRACE5
argument_list|(
operator|(
literal|"  code %d (0x%04X): idx %d\n"
operator|,
name|encoding
index|[
name|k
index|]
operator|.
name|enc
operator|,
name|encoding
index|[
name|k
index|]
operator|.
name|enc
operator|,
name|encoding
index|[
name|k
index|]
operator|.
name|glyph
operator|)
argument_list|)
expr_stmt|;
name|k
operator|++
expr_stmt|;
block|}
block|}
block|}
name|FT_Stream_ExitFrame
argument_list|(
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|FT_RENEW_ARRAY
argument_list|(
name|encoding
argument_list|,
name|nencoding
argument_list|,
name|k
argument_list|)
condition|)
goto|goto
name|Bail
goto|;
name|face
operator|->
name|nencodings
operator|=
name|k
expr_stmt|;
name|face
operator|->
name|encodings
operator|=
name|encoding
expr_stmt|;
return|return
name|error
return|;
name|Bail
label|:
name|FT_FREE
argument_list|(
name|encoding
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_decl_stmt
specifier|static
DECL|variable|pcf_accel_header
specifier|const
name|FT_Frame_Field
name|pcf_accel_header
index|[]
init|=
block|{
DECL|macro|FT_STRUCTURE
undef|#
directive|undef
name|FT_STRUCTURE
DECL|macro|FT_STRUCTURE
define|#
directive|define
name|FT_STRUCTURE
value|PCF_AccelRec
name|FT_FRAME_START
argument_list|(
literal|20
argument_list|)
block|,
name|FT_FRAME_BYTE
argument_list|(
name|noOverlap
argument_list|)
block|,
name|FT_FRAME_BYTE
argument_list|(
name|constantMetrics
argument_list|)
block|,
name|FT_FRAME_BYTE
argument_list|(
name|terminalFont
argument_list|)
block|,
name|FT_FRAME_BYTE
argument_list|(
name|constantWidth
argument_list|)
block|,
name|FT_FRAME_BYTE
argument_list|(
name|inkInside
argument_list|)
block|,
name|FT_FRAME_BYTE
argument_list|(
name|inkMetrics
argument_list|)
block|,
name|FT_FRAME_BYTE
argument_list|(
name|drawDirection
argument_list|)
block|,
name|FT_FRAME_SKIP_BYTES
argument_list|(
literal|1
argument_list|)
block|,
name|FT_FRAME_LONG_LE
argument_list|(
name|fontAscent
argument_list|)
block|,
name|FT_FRAME_LONG_LE
argument_list|(
name|fontDescent
argument_list|)
block|,
name|FT_FRAME_LONG_LE
argument_list|(
name|maxOverlap
argument_list|)
block|,
name|FT_FRAME_END
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
specifier|static
DECL|variable|pcf_accel_msb_header
specifier|const
name|FT_Frame_Field
name|pcf_accel_msb_header
index|[]
init|=
block|{
DECL|macro|FT_STRUCTURE
undef|#
directive|undef
name|FT_STRUCTURE
DECL|macro|FT_STRUCTURE
define|#
directive|define
name|FT_STRUCTURE
value|PCF_AccelRec
name|FT_FRAME_START
argument_list|(
literal|20
argument_list|)
block|,
name|FT_FRAME_BYTE
argument_list|(
name|noOverlap
argument_list|)
block|,
name|FT_FRAME_BYTE
argument_list|(
name|constantMetrics
argument_list|)
block|,
name|FT_FRAME_BYTE
argument_list|(
name|terminalFont
argument_list|)
block|,
name|FT_FRAME_BYTE
argument_list|(
name|constantWidth
argument_list|)
block|,
name|FT_FRAME_BYTE
argument_list|(
name|inkInside
argument_list|)
block|,
name|FT_FRAME_BYTE
argument_list|(
name|inkMetrics
argument_list|)
block|,
name|FT_FRAME_BYTE
argument_list|(
name|drawDirection
argument_list|)
block|,
name|FT_FRAME_SKIP_BYTES
argument_list|(
literal|1
argument_list|)
block|,
name|FT_FRAME_LONG
argument_list|(
name|fontAscent
argument_list|)
block|,
name|FT_FRAME_LONG
argument_list|(
name|fontDescent
argument_list|)
block|,
name|FT_FRAME_LONG
argument_list|(
name|maxOverlap
argument_list|)
block|,
name|FT_FRAME_END
block|}
decl_stmt|;
end_decl_stmt
begin_function
specifier|static
name|FT_Error
DECL|function|pcf_get_accel
name|pcf_get_accel
parameter_list|(
name|FT_Stream
name|stream
parameter_list|,
name|PCF_Face
name|face
parameter_list|,
name|FT_ULong
name|type
parameter_list|)
block|{
name|FT_ULong
name|format
decl_stmt|,
name|size
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|PCF_Accel
name|accel
init|=
operator|&
name|face
operator|->
name|accel
decl_stmt|;
name|error
operator|=
name|pcf_seek_to_table_type
argument_list|(
name|stream
argument_list|,
name|face
operator|->
name|toc
operator|.
name|tables
argument_list|,
name|face
operator|->
name|toc
operator|.
name|count
argument_list|,
name|type
argument_list|,
operator|&
name|format
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Bail
goto|;
if|if
condition|(
name|FT_READ_ULONG_LE
argument_list|(
name|format
argument_list|)
condition|)
goto|goto
name|Bail
goto|;
if|if
condition|(
operator|!
name|PCF_FORMAT_MATCH
argument_list|(
name|format
argument_list|,
name|PCF_DEFAULT_FORMAT
argument_list|)
operator|&&
operator|!
name|PCF_FORMAT_MATCH
argument_list|(
name|format
argument_list|,
name|PCF_ACCEL_W_INKBOUNDS
argument_list|)
condition|)
goto|goto
name|Bail
goto|;
if|if
condition|(
name|PCF_BYTE_ORDER
argument_list|(
name|format
argument_list|)
operator|==
name|MSBFirst
condition|)
block|{
if|if
condition|(
name|FT_STREAM_READ_FIELDS
argument_list|(
name|pcf_accel_msb_header
argument_list|,
name|accel
argument_list|)
condition|)
goto|goto
name|Bail
goto|;
block|}
else|else
block|{
if|if
condition|(
name|FT_STREAM_READ_FIELDS
argument_list|(
name|pcf_accel_header
argument_list|,
name|accel
argument_list|)
condition|)
goto|goto
name|Bail
goto|;
block|}
name|error
operator|=
name|pcf_get_metric
argument_list|(
name|stream
argument_list|,
name|format
operator|&
operator|(
operator|~
name|PCF_FORMAT_MASK
operator|)
argument_list|,
operator|&
operator|(
name|accel
operator|->
name|minbounds
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Bail
goto|;
name|error
operator|=
name|pcf_get_metric
argument_list|(
name|stream
argument_list|,
name|format
operator|&
operator|(
operator|~
name|PCF_FORMAT_MASK
operator|)
argument_list|,
operator|&
operator|(
name|accel
operator|->
name|maxbounds
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Bail
goto|;
if|if
condition|(
name|PCF_FORMAT_MATCH
argument_list|(
name|format
argument_list|,
name|PCF_ACCEL_W_INKBOUNDS
argument_list|)
condition|)
block|{
name|error
operator|=
name|pcf_get_metric
argument_list|(
name|stream
argument_list|,
name|format
operator|&
operator|(
operator|~
name|PCF_FORMAT_MASK
operator|)
argument_list|,
operator|&
operator|(
name|accel
operator|->
name|ink_minbounds
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Bail
goto|;
name|error
operator|=
name|pcf_get_metric
argument_list|(
name|stream
argument_list|,
name|format
operator|&
operator|(
operator|~
name|PCF_FORMAT_MASK
operator|)
argument_list|,
operator|&
operator|(
name|accel
operator|->
name|ink_maxbounds
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Bail
goto|;
block|}
else|else
block|{
name|accel
operator|->
name|ink_minbounds
operator|=
name|accel
operator|->
name|minbounds
expr_stmt|;
comment|/* I'm not sure about this */
name|accel
operator|->
name|ink_maxbounds
operator|=
name|accel
operator|->
name|maxbounds
expr_stmt|;
block|}
name|Bail
label|:
return|return
name|error
return|;
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|pcf_interpret_style
name|pcf_interpret_style
parameter_list|(
name|PCF_Face
name|pcf
parameter_list|)
block|{
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
name|FT_Face
name|face
init|=
name|FT_FACE
argument_list|(
name|pcf
argument_list|)
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|face
operator|->
name|memory
decl_stmt|;
name|PCF_Property
name|prop
decl_stmt|;
name|size_t
name|nn
decl_stmt|,
name|len
decl_stmt|;
name|char
modifier|*
name|strings
index|[
literal|4
index|]
init|=
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
name|size_t
name|lengths
index|[
literal|4
index|]
decl_stmt|;
name|face
operator|->
name|style_flags
operator|=
literal|0
expr_stmt|;
name|prop
operator|=
name|pcf_find_property
argument_list|(
name|pcf
argument_list|,
literal|"SLANT"
argument_list|)
expr_stmt|;
if|if
condition|(
name|prop
operator|&&
name|prop
operator|->
name|isString
operator|&&
operator|(
operator|*
operator|(
name|prop
operator|->
name|value
operator|.
name|atom
operator|)
operator|==
literal|'O'
operator|||
operator|*
operator|(
name|prop
operator|->
name|value
operator|.
name|atom
operator|)
operator|==
literal|'o'
operator|||
operator|*
operator|(
name|prop
operator|->
name|value
operator|.
name|atom
operator|)
operator|==
literal|'I'
operator|||
operator|*
operator|(
name|prop
operator|->
name|value
operator|.
name|atom
operator|)
operator|==
literal|'i'
operator|)
condition|)
block|{
name|face
operator|->
name|style_flags
operator||=
name|FT_STYLE_FLAG_ITALIC
expr_stmt|;
name|strings
index|[
literal|2
index|]
operator|=
operator|(
operator|*
operator|(
name|prop
operator|->
name|value
operator|.
name|atom
operator|)
operator|==
literal|'O'
operator|||
operator|*
operator|(
name|prop
operator|->
name|value
operator|.
name|atom
operator|)
operator|==
literal|'o'
operator|)
condition|?
operator|(
name|char
operator|*
operator|)
literal|"Oblique"
else|:
operator|(
name|char
operator|*
operator|)
literal|"Italic"
expr_stmt|;
block|}
name|prop
operator|=
name|pcf_find_property
argument_list|(
name|pcf
argument_list|,
literal|"WEIGHT_NAME"
argument_list|)
expr_stmt|;
if|if
condition|(
name|prop
operator|&&
name|prop
operator|->
name|isString
operator|&&
operator|(
operator|*
operator|(
name|prop
operator|->
name|value
operator|.
name|atom
operator|)
operator|==
literal|'B'
operator|||
operator|*
operator|(
name|prop
operator|->
name|value
operator|.
name|atom
operator|)
operator|==
literal|'b'
operator|)
condition|)
block|{
name|face
operator|->
name|style_flags
operator||=
name|FT_STYLE_FLAG_BOLD
expr_stmt|;
name|strings
index|[
literal|1
index|]
operator|=
operator|(
name|char
operator|*
operator|)
literal|"Bold"
expr_stmt|;
block|}
name|prop
operator|=
name|pcf_find_property
argument_list|(
name|pcf
argument_list|,
literal|"SETWIDTH_NAME"
argument_list|)
expr_stmt|;
if|if
condition|(
name|prop
operator|&&
name|prop
operator|->
name|isString
operator|&&
operator|*
operator|(
name|prop
operator|->
name|value
operator|.
name|atom
operator|)
operator|&&
operator|!
operator|(
operator|*
operator|(
name|prop
operator|->
name|value
operator|.
name|atom
operator|)
operator|==
literal|'N'
operator|||
operator|*
operator|(
name|prop
operator|->
name|value
operator|.
name|atom
operator|)
operator|==
literal|'n'
operator|)
condition|)
name|strings
index|[
literal|3
index|]
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|prop
operator|->
name|value
operator|.
name|atom
operator|)
expr_stmt|;
name|prop
operator|=
name|pcf_find_property
argument_list|(
name|pcf
argument_list|,
literal|"ADD_STYLE_NAME"
argument_list|)
expr_stmt|;
if|if
condition|(
name|prop
operator|&&
name|prop
operator|->
name|isString
operator|&&
operator|*
operator|(
name|prop
operator|->
name|value
operator|.
name|atom
operator|)
operator|&&
operator|!
operator|(
operator|*
operator|(
name|prop
operator|->
name|value
operator|.
name|atom
operator|)
operator|==
literal|'N'
operator|||
operator|*
operator|(
name|prop
operator|->
name|value
operator|.
name|atom
operator|)
operator|==
literal|'n'
operator|)
condition|)
name|strings
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|prop
operator|->
name|value
operator|.
name|atom
operator|)
expr_stmt|;
for|for
control|(
name|len
operator|=
literal|0
operator|,
name|nn
operator|=
literal|0
init|;
name|nn
operator|<
literal|4
condition|;
name|nn
operator|++
control|)
block|{
name|lengths
index|[
name|nn
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strings
index|[
name|nn
index|]
condition|)
block|{
name|lengths
index|[
name|nn
index|]
operator|=
name|ft_strlen
argument_list|(
name|strings
index|[
name|nn
index|]
argument_list|)
expr_stmt|;
name|len
operator|+=
name|lengths
index|[
name|nn
index|]
operator|+
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|strings
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|*
operator|)
literal|"Regular"
expr_stmt|;
name|lengths
index|[
literal|0
index|]
operator|=
name|ft_strlen
argument_list|(
name|strings
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|len
operator|=
name|lengths
index|[
literal|0
index|]
operator|+
literal|1
expr_stmt|;
block|}
block|{
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|FT_ALLOC
argument_list|(
name|face
operator|->
name|style_name
argument_list|,
name|len
argument_list|)
condition|)
return|return
name|error
return|;
name|s
operator|=
name|face
operator|->
name|style_name
expr_stmt|;
for|for
control|(
name|nn
operator|=
literal|0
init|;
name|nn
operator|<
literal|4
condition|;
name|nn
operator|++
control|)
block|{
name|char
modifier|*
name|src
init|=
name|strings
index|[
name|nn
index|]
decl_stmt|;
name|len
operator|=
name|lengths
index|[
name|nn
index|]
expr_stmt|;
if|if
condition|(
name|src
operator|==
name|NULL
condition|)
continue|continue;
comment|/* separate elements with a space */
if|if
condition|(
name|s
operator|!=
name|face
operator|->
name|style_name
condition|)
operator|*
name|s
operator|++
operator|=
literal|' '
expr_stmt|;
name|ft_memcpy
argument_list|(
name|s
argument_list|,
name|src
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* need to convert spaces to dashes for */
comment|/* add_style_name and setwidth_name     */
if|if
condition|(
name|nn
operator|==
literal|0
operator|||
name|nn
operator|==
literal|3
condition|)
block|{
name|size_t
name|mm
decl_stmt|;
for|for
control|(
name|mm
operator|=
literal|0
init|;
name|mm
operator|<
name|len
condition|;
name|mm
operator|++
control|)
if|if
condition|(
name|s
index|[
name|mm
index|]
operator|==
literal|' '
condition|)
name|s
index|[
name|mm
index|]
operator|=
literal|'-'
expr_stmt|;
block|}
name|s
operator|+=
name|len
expr_stmt|;
block|}
operator|*
name|s
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|pcf_load_font
argument_list|(
argument|FT_Stream  stream
argument_list|,
argument|PCF_Face   face
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|FT_FACE
argument_list|(
name|face
argument_list|)
operator|->
name|memory
decl_stmt|;
name|FT_Bool
name|hasBDFAccelerators
decl_stmt|;
name|error
operator|=
name|pcf_read_TOC
argument_list|(
name|stream
argument_list|,
name|face
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|error
operator|=
name|pcf_get_properties
argument_list|(
name|stream
argument_list|,
name|face
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
comment|/* Use the old accelerators if no BDF accelerators are in the file. */
name|hasBDFAccelerators
operator|=
name|pcf_has_table_type
argument_list|(
name|face
operator|->
name|toc
operator|.
name|tables
argument_list|,
name|face
operator|->
name|toc
operator|.
name|count
argument_list|,
name|PCF_BDF_ACCELERATORS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hasBDFAccelerators
condition|)
block|{
name|error
operator|=
name|pcf_get_accel
argument_list|(
name|stream
argument_list|,
name|face
argument_list|,
name|PCF_ACCELERATORS
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
block|}
comment|/* metrics */
name|error
operator|=
name|pcf_get_metrics
argument_list|(
name|stream
argument_list|,
name|face
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
comment|/* bitmaps */
name|error
operator|=
name|pcf_get_bitmaps
argument_list|(
name|stream
argument_list|,
name|face
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
comment|/* encodings */
name|error
operator|=
name|pcf_get_encodings
argument_list|(
name|stream
argument_list|,
name|face
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
comment|/* BDF style accelerators (i.e. bounds based on encoded glyphs) */
if|if
condition|(
name|hasBDFAccelerators
condition|)
block|{
name|error
operator|=
name|pcf_get_accel
argument_list|(
name|stream
argument_list|,
name|face
argument_list|,
name|PCF_BDF_ACCELERATORS
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
block|}
comment|/* XXX: TO DO: inkmetrics and glyph_names are missing */
comment|/* now construct the face object */
block|{
name|FT_Face
name|root
init|=
name|FT_FACE
argument_list|(
name|face
argument_list|)
decl_stmt|;
name|PCF_Property
name|prop
decl_stmt|;
name|root
operator|->
name|num_faces
operator|=
literal|1
expr_stmt|;
name|root
operator|->
name|face_index
operator|=
literal|0
expr_stmt|;
name|root
operator|->
name|face_flags
operator||=
name|FT_FACE_FLAG_FIXED_SIZES
operator||
name|FT_FACE_FLAG_HORIZONTAL
operator||
name|FT_FACE_FLAG_FAST_GLYPHS
expr_stmt|;
if|if
condition|(
name|face
operator|->
name|accel
operator|.
name|constantWidth
condition|)
name|root
operator|->
name|face_flags
operator||=
name|FT_FACE_FLAG_FIXED_WIDTH
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|pcf_interpret_style
argument_list|(
name|face
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|Exit
goto|;
name|prop
operator|=
name|pcf_find_property
argument_list|(
name|face
argument_list|,
literal|"FAMILY_NAME"
argument_list|)
expr_stmt|;
if|if
condition|(
name|prop
operator|&&
name|prop
operator|->
name|isString
condition|)
block|{
if|if
condition|(
name|FT_STRDUP
argument_list|(
name|root
operator|->
name|family_name
argument_list|,
name|prop
operator|->
name|value
operator|.
name|atom
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
block|}
else|else
name|root
operator|->
name|family_name
operator|=
name|NULL
expr_stmt|;
comment|/*        * Note: We shift all glyph indices by +1 since we must        * respect the convention that glyph 0 always corresponds        * to the `missing glyph'.        *        * This implies bumping the number of `available' glyphs by 1.        */
name|root
operator|->
name|num_glyphs
operator|=
name|face
operator|->
name|nmetrics
operator|+
literal|1
expr_stmt|;
name|root
operator|->
name|num_fixed_sizes
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|root
operator|->
name|available_sizes
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
block|{
name|FT_Bitmap_Size
modifier|*
name|bsize
init|=
name|root
operator|->
name|available_sizes
decl_stmt|;
name|FT_Short
name|resolution_x
init|=
literal|0
decl_stmt|,
name|resolution_y
init|=
literal|0
decl_stmt|;
name|FT_MEM_ZERO
argument_list|(
name|bsize
argument_list|,
sizeof|sizeof
argument_list|(
name|FT_Bitmap_Size
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|bsize->height = face->accel.maxbounds.ascent<< 6;
endif|#
directive|endif
name|bsize
operator|->
name|height
operator|=
call|(
name|FT_Short
call|)
argument_list|(
name|face
operator|->
name|accel
operator|.
name|fontAscent
operator|+
name|face
operator|->
name|accel
operator|.
name|fontDescent
argument_list|)
expr_stmt|;
name|prop
operator|=
name|pcf_find_property
argument_list|(
name|face
argument_list|,
literal|"AVERAGE_WIDTH"
argument_list|)
expr_stmt|;
if|if
condition|(
name|prop
condition|)
name|bsize
operator|->
name|width
operator|=
call|(
name|FT_Short
call|)
argument_list|(
operator|(
name|prop
operator|->
name|value
operator|.
name|l
operator|+
literal|5
operator|)
operator|/
literal|10
argument_list|)
expr_stmt|;
else|else
name|bsize
operator|->
name|width
operator|=
call|(
name|FT_Short
call|)
argument_list|(
name|bsize
operator|->
name|height
operator|*
literal|2
operator|/
literal|3
argument_list|)
expr_stmt|;
name|prop
operator|=
name|pcf_find_property
argument_list|(
name|face
argument_list|,
literal|"POINT_SIZE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|prop
condition|)
comment|/* convert from 722.7 decipoints to 72 points per inch */
name|bsize
operator|->
name|size
operator|=
call|(
name|FT_Pos
call|)
argument_list|(
operator|(
name|prop
operator|->
name|value
operator|.
name|l
operator|*
literal|64
operator|*
literal|7200
operator|+
literal|36135L
operator|)
operator|/
literal|72270L
argument_list|)
expr_stmt|;
name|prop
operator|=
name|pcf_find_property
argument_list|(
name|face
argument_list|,
literal|"PIXEL_SIZE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|prop
condition|)
name|bsize
operator|->
name|y_ppem
operator|=
operator|(
name|FT_Short
operator|)
name|prop
operator|->
name|value
operator|.
name|l
operator|<<
literal|6
expr_stmt|;
name|prop
operator|=
name|pcf_find_property
argument_list|(
name|face
argument_list|,
literal|"RESOLUTION_X"
argument_list|)
expr_stmt|;
if|if
condition|(
name|prop
condition|)
name|resolution_x
operator|=
operator|(
name|FT_Short
operator|)
name|prop
operator|->
name|value
operator|.
name|l
expr_stmt|;
name|prop
operator|=
name|pcf_find_property
argument_list|(
name|face
argument_list|,
literal|"RESOLUTION_Y"
argument_list|)
expr_stmt|;
if|if
condition|(
name|prop
condition|)
name|resolution_y
operator|=
operator|(
name|FT_Short
operator|)
name|prop
operator|->
name|value
operator|.
name|l
expr_stmt|;
if|if
condition|(
name|bsize
operator|->
name|y_ppem
operator|==
literal|0
condition|)
block|{
name|bsize
operator|->
name|y_ppem
operator|=
name|bsize
operator|->
name|size
expr_stmt|;
if|if
condition|(
name|resolution_y
condition|)
name|bsize
operator|->
name|y_ppem
operator|=
name|bsize
operator|->
name|y_ppem
operator|*
name|resolution_y
operator|/
literal|72
expr_stmt|;
block|}
if|if
condition|(
name|resolution_x
operator|&&
name|resolution_y
condition|)
name|bsize
operator|->
name|x_ppem
operator|=
name|bsize
operator|->
name|y_ppem
operator|*
name|resolution_x
operator|/
name|resolution_y
expr_stmt|;
else|else
name|bsize
operator|->
name|x_ppem
operator|=
name|bsize
operator|->
name|y_ppem
expr_stmt|;
block|}
comment|/* set up charset */
block|{
name|PCF_Property
name|charset_registry
init|=
literal|0
decl_stmt|,
name|charset_encoding
init|=
literal|0
decl_stmt|;
name|charset_registry
operator|=
name|pcf_find_property
argument_list|(
name|face
argument_list|,
literal|"CHARSET_REGISTRY"
argument_list|)
expr_stmt|;
name|charset_encoding
operator|=
name|pcf_find_property
argument_list|(
name|face
argument_list|,
literal|"CHARSET_ENCODING"
argument_list|)
expr_stmt|;
if|if
condition|(
name|charset_registry
operator|&&
name|charset_registry
operator|->
name|isString
operator|&&
name|charset_encoding
operator|&&
name|charset_encoding
operator|->
name|isString
condition|)
block|{
if|if
condition|(
name|FT_STRDUP
argument_list|(
name|face
operator|->
name|charset_encoding
argument_list|,
name|charset_encoding
operator|->
name|value
operator|.
name|atom
argument_list|)
operator|||
name|FT_STRDUP
argument_list|(
name|face
operator|->
name|charset_registry
argument_list|,
name|charset_registry
operator|->
name|value
operator|.
name|atom
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
block|}
block|}
block|}
name|Exit
label|:
if|if
condition|(
name|error
condition|)
block|{
comment|/* This is done to respect the behaviour of the original */
comment|/* PCF font driver.                                      */
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_File_Format
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/* END */
end_comment
end_unit
