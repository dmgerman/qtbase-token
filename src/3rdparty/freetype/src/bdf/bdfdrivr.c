begin_unit
begin_comment
comment|/*  bdfdrivr.c      FreeType font driver for bdf files      Copyright (C) 2001-2008, 2011, 2013, 2014 by     Francesco Zappa Nardelli  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */
end_comment
begin_include
include|#
directive|include
file|<ft2build.h>
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_DEBUG_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_STREAM_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_OBJECTS_H
end_include
begin_include
include|#
directive|include
include|FT_BDF_H
end_include
begin_include
include|#
directive|include
include|FT_TRUETYPE_IDS_H
end_include
begin_include
include|#
directive|include
include|FT_SERVICE_BDF_H
end_include
begin_include
include|#
directive|include
include|FT_SERVICE_XFREE86_NAME_H
end_include
begin_include
include|#
directive|include
file|"bdf.h"
end_include
begin_include
include|#
directive|include
file|"bdfdrivr.h"
end_include
begin_include
include|#
directive|include
file|"bdferror.h"
end_include
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
end_comment
begin_comment
comment|/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
end_comment
begin_comment
comment|/* messages during execution.                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_undef
DECL|macro|FT_COMPONENT
undef|#
directive|undef
name|FT_COMPONENT
end_undef
begin_define
DECL|macro|FT_COMPONENT
define|#
directive|define
name|FT_COMPONENT
value|trace_bdfdriver
end_define
begin_typedef
DECL|struct|BDF_CMapRec_
typedef|typedef
struct|struct
name|BDF_CMapRec_
block|{
DECL|member|cmap
name|FT_CMapRec
name|cmap
decl_stmt|;
DECL|member|num_encodings
name|FT_ULong
name|num_encodings
decl_stmt|;
comment|/* ftobjs.h: FT_CMap->clazz->size */
DECL|member|encodings
name|BDF_encoding_el
modifier|*
name|encodings
decl_stmt|;
block|}
DECL|typedef|BDF_CMapRec
DECL|typedef|BDF_CMap
name|BDF_CMapRec
operator|,
typedef|*
name|BDF_CMap
typedef|;
end_typedef
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|bdf_cmap_init
argument_list|(
argument|FT_CMap     bdfcmap
argument_list|,
argument|FT_Pointer  init_data
argument_list|)
end_macro
begin_block
block|{
name|BDF_CMap
name|cmap
init|=
operator|(
name|BDF_CMap
operator|)
name|bdfcmap
decl_stmt|;
name|BDF_Face
name|face
init|=
operator|(
name|BDF_Face
operator|)
name|FT_CMAP_FACE
argument_list|(
name|cmap
argument_list|)
decl_stmt|;
name|FT_UNUSED
argument_list|(
name|init_data
argument_list|)
expr_stmt|;
name|cmap
operator|->
name|num_encodings
operator|=
name|face
operator|->
name|bdffont
operator|->
name|glyphs_used
expr_stmt|;
name|cmap
operator|->
name|encodings
operator|=
name|face
operator|->
name|en_table
expr_stmt|;
return|return
name|FT_Err_Ok
return|;
block|}
end_block
begin_macro
name|FT_CALLBACK_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|bdf_cmap_done
name|bdf_cmap_done
argument_list|(
argument|FT_CMap  bdfcmap
argument_list|)
end_macro
begin_block
block|{
name|BDF_CMap
name|cmap
init|=
operator|(
name|BDF_CMap
operator|)
name|bdfcmap
decl_stmt|;
name|cmap
operator|->
name|encodings
operator|=
name|NULL
expr_stmt|;
name|cmap
operator|->
name|num_encodings
operator|=
literal|0
expr_stmt|;
block|}
end_block
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_UInt
argument_list|)
end_macro
begin_macro
name|bdf_cmap_char_index
argument_list|(
argument|FT_CMap    bdfcmap
argument_list|,
argument|FT_UInt32  charcode
argument_list|)
end_macro
begin_block
block|{
name|BDF_CMap
name|cmap
init|=
operator|(
name|BDF_CMap
operator|)
name|bdfcmap
decl_stmt|;
name|BDF_encoding_el
modifier|*
name|encodings
init|=
name|cmap
operator|->
name|encodings
decl_stmt|;
name|FT_ULong
name|min
decl_stmt|,
name|max
decl_stmt|,
name|mid
decl_stmt|;
comment|/* num_encodings */
name|FT_UShort
name|result
init|=
literal|0
decl_stmt|;
comment|/* encodings->glyph */
name|min
operator|=
literal|0
expr_stmt|;
name|max
operator|=
name|cmap
operator|->
name|num_encodings
expr_stmt|;
while|while
condition|(
name|min
operator|<
name|max
condition|)
block|{
name|FT_ULong
name|code
decl_stmt|;
name|mid
operator|=
operator|(
name|min
operator|+
name|max
operator|)
operator|>>
literal|1
expr_stmt|;
name|code
operator|=
name|encodings
index|[
name|mid
index|]
operator|.
name|enc
expr_stmt|;
if|if
condition|(
name|charcode
operator|==
name|code
condition|)
block|{
comment|/* increase glyph index by 1 --              */
comment|/* we reserve slot 0 for the undefined glyph */
name|result
operator|=
name|encodings
index|[
name|mid
index|]
operator|.
name|glyph
operator|+
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|charcode
operator|<
name|code
condition|)
name|max
operator|=
name|mid
expr_stmt|;
else|else
name|min
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_block
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_UInt
argument_list|)
end_macro
begin_macro
name|bdf_cmap_char_next
argument_list|(
argument|FT_CMap     bdfcmap
argument_list|,
argument|FT_UInt32  *acharcode
argument_list|)
end_macro
begin_block
block|{
name|BDF_CMap
name|cmap
init|=
operator|(
name|BDF_CMap
operator|)
name|bdfcmap
decl_stmt|;
name|BDF_encoding_el
modifier|*
name|encodings
init|=
name|cmap
operator|->
name|encodings
decl_stmt|;
name|FT_ULong
name|min
decl_stmt|,
name|max
decl_stmt|,
name|mid
decl_stmt|;
comment|/* num_encodings */
name|FT_UShort
name|result
init|=
literal|0
decl_stmt|;
comment|/* encodings->glyph */
name|FT_ULong
name|charcode
init|=
operator|*
name|acharcode
operator|+
literal|1
decl_stmt|;
name|min
operator|=
literal|0
expr_stmt|;
name|max
operator|=
name|cmap
operator|->
name|num_encodings
expr_stmt|;
while|while
condition|(
name|min
operator|<
name|max
condition|)
block|{
name|FT_ULong
name|code
decl_stmt|;
comment|/* same as BDF_encoding_el.enc */
name|mid
operator|=
operator|(
name|min
operator|+
name|max
operator|)
operator|>>
literal|1
expr_stmt|;
name|code
operator|=
name|encodings
index|[
name|mid
index|]
operator|.
name|enc
expr_stmt|;
if|if
condition|(
name|charcode
operator|==
name|code
condition|)
block|{
comment|/* increase glyph index by 1 --              */
comment|/* we reserve slot 0 for the undefined glyph */
name|result
operator|=
name|encodings
index|[
name|mid
index|]
operator|.
name|glyph
operator|+
literal|1
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|charcode
operator|<
name|code
condition|)
name|max
operator|=
name|mid
expr_stmt|;
else|else
name|min
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
block|}
name|charcode
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|min
operator|<
name|cmap
operator|->
name|num_encodings
condition|)
block|{
name|charcode
operator|=
name|encodings
index|[
name|min
index|]
operator|.
name|enc
expr_stmt|;
name|result
operator|=
name|encodings
index|[
name|min
index|]
operator|.
name|glyph
operator|+
literal|1
expr_stmt|;
block|}
name|Exit
label|:
if|if
condition|(
name|charcode
operator|>
literal|0xFFFFFFFFUL
condition|)
block|{
name|FT_TRACE1
argument_list|(
operator|(
literal|"bdf_cmap_char_next: charcode 0x%x> 32bit API"
operator|)
argument_list|)
expr_stmt|;
operator|*
name|acharcode
operator|=
literal|0
expr_stmt|;
comment|/* XXX: result should be changed to indicate an overflow error */
block|}
else|else
operator|*
name|acharcode
operator|=
operator|(
name|FT_UInt32
operator|)
name|charcode
expr_stmt|;
return|return
name|result
return|;
block|}
end_block
begin_decl_stmt
specifier|static
DECL|variable|bdf_cmap_class
specifier|const
name|FT_CMap_ClassRec
name|bdf_cmap_class
init|=
block|{
sizeof|sizeof
argument_list|(
name|BDF_CMapRec
argument_list|)
block|,
name|bdf_cmap_init
block|,
name|bdf_cmap_done
block|,
name|bdf_cmap_char_index
block|,
name|bdf_cmap_char_next
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt
begin_function
specifier|static
name|FT_Error
DECL|function|bdf_interpret_style
name|bdf_interpret_style
parameter_list|(
name|BDF_Face
name|bdf
parameter_list|)
block|{
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
name|FT_Face
name|face
init|=
name|FT_FACE
argument_list|(
name|bdf
argument_list|)
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|face
operator|->
name|memory
decl_stmt|;
name|bdf_font_t
modifier|*
name|font
init|=
name|bdf
operator|->
name|bdffont
decl_stmt|;
name|bdf_property_t
modifier|*
name|prop
decl_stmt|;
name|char
modifier|*
name|strings
index|[
literal|4
index|]
init|=
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
name|size_t
name|nn
decl_stmt|,
name|len
decl_stmt|,
name|lengths
index|[
literal|4
index|]
decl_stmt|;
name|face
operator|->
name|style_flags
operator|=
literal|0
expr_stmt|;
name|prop
operator|=
name|bdf_get_font_property
argument_list|(
name|font
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|"SLANT"
argument_list|)
expr_stmt|;
if|if
condition|(
name|prop
operator|&&
name|prop
operator|->
name|format
operator|==
name|BDF_ATOM
operator|&&
name|prop
operator|->
name|value
operator|.
name|atom
operator|&&
operator|(
operator|*
operator|(
name|prop
operator|->
name|value
operator|.
name|atom
operator|)
operator|==
literal|'O'
operator|||
operator|*
operator|(
name|prop
operator|->
name|value
operator|.
name|atom
operator|)
operator|==
literal|'o'
operator|||
operator|*
operator|(
name|prop
operator|->
name|value
operator|.
name|atom
operator|)
operator|==
literal|'I'
operator|||
operator|*
operator|(
name|prop
operator|->
name|value
operator|.
name|atom
operator|)
operator|==
literal|'i'
operator|)
condition|)
block|{
name|face
operator|->
name|style_flags
operator||=
name|FT_STYLE_FLAG_ITALIC
expr_stmt|;
name|strings
index|[
literal|2
index|]
operator|=
operator|(
operator|*
operator|(
name|prop
operator|->
name|value
operator|.
name|atom
operator|)
operator|==
literal|'O'
operator|||
operator|*
operator|(
name|prop
operator|->
name|value
operator|.
name|atom
operator|)
operator|==
literal|'o'
operator|)
condition|?
operator|(
name|char
operator|*
operator|)
literal|"Oblique"
else|:
operator|(
name|char
operator|*
operator|)
literal|"Italic"
expr_stmt|;
block|}
name|prop
operator|=
name|bdf_get_font_property
argument_list|(
name|font
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|"WEIGHT_NAME"
argument_list|)
expr_stmt|;
if|if
condition|(
name|prop
operator|&&
name|prop
operator|->
name|format
operator|==
name|BDF_ATOM
operator|&&
name|prop
operator|->
name|value
operator|.
name|atom
operator|&&
operator|(
operator|*
operator|(
name|prop
operator|->
name|value
operator|.
name|atom
operator|)
operator|==
literal|'B'
operator|||
operator|*
operator|(
name|prop
operator|->
name|value
operator|.
name|atom
operator|)
operator|==
literal|'b'
operator|)
condition|)
block|{
name|face
operator|->
name|style_flags
operator||=
name|FT_STYLE_FLAG_BOLD
expr_stmt|;
name|strings
index|[
literal|1
index|]
operator|=
operator|(
name|char
operator|*
operator|)
literal|"Bold"
expr_stmt|;
block|}
name|prop
operator|=
name|bdf_get_font_property
argument_list|(
name|font
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|"SETWIDTH_NAME"
argument_list|)
expr_stmt|;
if|if
condition|(
name|prop
operator|&&
name|prop
operator|->
name|format
operator|==
name|BDF_ATOM
operator|&&
name|prop
operator|->
name|value
operator|.
name|atom
operator|&&
operator|*
operator|(
name|prop
operator|->
name|value
operator|.
name|atom
operator|)
operator|&&
operator|!
operator|(
operator|*
operator|(
name|prop
operator|->
name|value
operator|.
name|atom
operator|)
operator|==
literal|'N'
operator|||
operator|*
operator|(
name|prop
operator|->
name|value
operator|.
name|atom
operator|)
operator|==
literal|'n'
operator|)
condition|)
name|strings
index|[
literal|3
index|]
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|prop
operator|->
name|value
operator|.
name|atom
operator|)
expr_stmt|;
name|prop
operator|=
name|bdf_get_font_property
argument_list|(
name|font
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|"ADD_STYLE_NAME"
argument_list|)
expr_stmt|;
if|if
condition|(
name|prop
operator|&&
name|prop
operator|->
name|format
operator|==
name|BDF_ATOM
operator|&&
name|prop
operator|->
name|value
operator|.
name|atom
operator|&&
operator|*
operator|(
name|prop
operator|->
name|value
operator|.
name|atom
operator|)
operator|&&
operator|!
operator|(
operator|*
operator|(
name|prop
operator|->
name|value
operator|.
name|atom
operator|)
operator|==
literal|'N'
operator|||
operator|*
operator|(
name|prop
operator|->
name|value
operator|.
name|atom
operator|)
operator|==
literal|'n'
operator|)
condition|)
name|strings
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|prop
operator|->
name|value
operator|.
name|atom
operator|)
expr_stmt|;
for|for
control|(
name|len
operator|=
literal|0
operator|,
name|nn
operator|=
literal|0
init|;
name|nn
operator|<
literal|4
condition|;
name|nn
operator|++
control|)
block|{
name|lengths
index|[
name|nn
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strings
index|[
name|nn
index|]
condition|)
block|{
name|lengths
index|[
name|nn
index|]
operator|=
name|ft_strlen
argument_list|(
name|strings
index|[
name|nn
index|]
argument_list|)
expr_stmt|;
name|len
operator|+=
name|lengths
index|[
name|nn
index|]
operator|+
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|strings
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|*
operator|)
literal|"Regular"
expr_stmt|;
name|lengths
index|[
literal|0
index|]
operator|=
name|ft_strlen
argument_list|(
name|strings
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|len
operator|=
name|lengths
index|[
literal|0
index|]
operator|+
literal|1
expr_stmt|;
block|}
block|{
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|FT_ALLOC
argument_list|(
name|face
operator|->
name|style_name
argument_list|,
name|len
argument_list|)
condition|)
return|return
name|error
return|;
name|s
operator|=
name|face
operator|->
name|style_name
expr_stmt|;
for|for
control|(
name|nn
operator|=
literal|0
init|;
name|nn
operator|<
literal|4
condition|;
name|nn
operator|++
control|)
block|{
name|char
modifier|*
name|src
init|=
name|strings
index|[
name|nn
index|]
decl_stmt|;
name|len
operator|=
name|lengths
index|[
name|nn
index|]
expr_stmt|;
if|if
condition|(
name|src
operator|==
name|NULL
condition|)
continue|continue;
comment|/* separate elements with a space */
if|if
condition|(
name|s
operator|!=
name|face
operator|->
name|style_name
condition|)
operator|*
name|s
operator|++
operator|=
literal|' '
expr_stmt|;
name|ft_memcpy
argument_list|(
name|s
argument_list|,
name|src
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* need to convert spaces to dashes for */
comment|/* add_style_name and setwidth_name     */
if|if
condition|(
name|nn
operator|==
literal|0
operator|||
name|nn
operator|==
literal|3
condition|)
block|{
name|size_t
name|mm
decl_stmt|;
for|for
control|(
name|mm
operator|=
literal|0
init|;
name|mm
operator|<
name|len
condition|;
name|mm
operator|++
control|)
if|if
condition|(
name|s
index|[
name|mm
index|]
operator|==
literal|' '
condition|)
name|s
index|[
name|mm
index|]
operator|=
literal|'-'
expr_stmt|;
block|}
name|s
operator|+=
name|len
expr_stmt|;
block|}
operator|*
name|s
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function
begin_macro
name|FT_CALLBACK_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|BDF_Face_Done
name|BDF_Face_Done
argument_list|(
argument|FT_Face  bdfface
argument_list|)
end_macro
begin_comment
DECL|function|BDF_Face_Done
comment|/* BDF_Face */
end_comment
begin_block
block|{
name|BDF_Face
name|face
init|=
operator|(
name|BDF_Face
operator|)
name|bdfface
decl_stmt|;
name|FT_Memory
name|memory
decl_stmt|;
if|if
condition|(
operator|!
name|face
condition|)
return|return;
name|memory
operator|=
name|FT_FACE_MEMORY
argument_list|(
name|face
argument_list|)
expr_stmt|;
name|bdf_free_font
argument_list|(
name|face
operator|->
name|bdffont
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|face
operator|->
name|en_table
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|face
operator|->
name|charset_encoding
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|face
operator|->
name|charset_registry
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|bdfface
operator|->
name|family_name
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|bdfface
operator|->
name|style_name
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|bdfface
operator|->
name|available_sizes
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|face
operator|->
name|bdffont
argument_list|)
expr_stmt|;
block|}
end_block
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|BDF_Face_Init
argument_list|(
argument|FT_Stream      stream
argument_list|,
argument|FT_Face        bdfface
argument_list|,
comment|/* BDF_Face */
argument|FT_Int         face_index
argument_list|,
argument|FT_Int         num_params
argument_list|,
argument|FT_Parameter*  params
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
name|BDF_Face
name|face
init|=
operator|(
name|BDF_Face
operator|)
name|bdfface
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|FT_FACE_MEMORY
argument_list|(
name|face
argument_list|)
decl_stmt|;
name|bdf_font_t
modifier|*
name|font
init|=
name|NULL
decl_stmt|;
name|bdf_options_t
name|options
decl_stmt|;
name|FT_UNUSED
argument_list|(
name|num_params
argument_list|)
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|params
argument_list|)
expr_stmt|;
name|FT_TRACE2
argument_list|(
operator|(
literal|"BDF driver\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|FT_STREAM_SEEK
argument_list|(
literal|0
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|options
operator|.
name|correct_metrics
operator|=
literal|1
expr_stmt|;
comment|/* FZ XXX: options semantics */
name|options
operator|.
name|keep_unencoded
operator|=
literal|1
expr_stmt|;
name|options
operator|.
name|keep_comments
operator|=
literal|0
expr_stmt|;
name|options
operator|.
name|font_spacing
operator|=
name|BDF_PROPORTIONAL
expr_stmt|;
name|error
operator|=
name|bdf_load_font
argument_list|(
name|stream
argument_list|,
name|memory
argument_list|,
operator|&
name|options
argument_list|,
operator|&
name|font
argument_list|)
expr_stmt|;
if|if
condition|(
name|FT_ERR_EQ
argument_list|(
name|error
argument_list|,
name|Missing_Startfont_Field
argument_list|)
condition|)
block|{
name|FT_TRACE2
argument_list|(
operator|(
literal|"  not a BDF file\n"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|Fail
goto|;
block|}
elseif|else
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
comment|/* we have a bdf font: let's construct the face object */
name|face
operator|->
name|bdffont
operator|=
name|font
expr_stmt|;
comment|/* BDF could not have multiple face in single font file.      * XXX: non-zero face_index is already invalid argument, but      *      Type1, Type42 driver has a convention to return      *      an invalid argument error when the font could be      *      opened by the specified driver.      */
if|if
condition|(
name|face_index
operator|>
literal|0
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"BDF_Face_Init: invalid face index\n"
operator|)
argument_list|)
expr_stmt|;
name|BDF_Face_Done
argument_list|(
name|bdfface
argument_list|)
expr_stmt|;
return|return
name|FT_THROW
argument_list|(
name|Invalid_Argument
argument_list|)
return|;
block|}
block|{
name|bdf_property_t
modifier|*
name|prop
init|=
name|NULL
decl_stmt|;
name|FT_TRACE4
argument_list|(
operator|(
literal|"  number of glyphs: allocated %d (used %d)\n"
operator|,
name|font
operator|->
name|glyphs_size
operator|,
name|font
operator|->
name|glyphs_used
operator|)
argument_list|)
expr_stmt|;
name|FT_TRACE4
argument_list|(
operator|(
literal|"  number of unencoded glyphs: allocated %d (used %d)\n"
operator|,
name|font
operator|->
name|unencoded_size
operator|,
name|font
operator|->
name|unencoded_used
operator|)
argument_list|)
expr_stmt|;
name|bdfface
operator|->
name|num_faces
operator|=
literal|1
expr_stmt|;
name|bdfface
operator|->
name|face_index
operator|=
literal|0
expr_stmt|;
name|bdfface
operator|->
name|face_flags
operator||=
name|FT_FACE_FLAG_FIXED_SIZES
operator||
name|FT_FACE_FLAG_HORIZONTAL
operator||
name|FT_FACE_FLAG_FAST_GLYPHS
expr_stmt|;
name|prop
operator|=
name|bdf_get_font_property
argument_list|(
name|font
argument_list|,
literal|"SPACING"
argument_list|)
expr_stmt|;
if|if
condition|(
name|prop
operator|&&
name|prop
operator|->
name|format
operator|==
name|BDF_ATOM
operator|&&
name|prop
operator|->
name|value
operator|.
name|atom
operator|&&
operator|(
operator|*
operator|(
name|prop
operator|->
name|value
operator|.
name|atom
operator|)
operator|==
literal|'M'
operator|||
operator|*
operator|(
name|prop
operator|->
name|value
operator|.
name|atom
operator|)
operator|==
literal|'m'
operator|||
operator|*
operator|(
name|prop
operator|->
name|value
operator|.
name|atom
operator|)
operator|==
literal|'C'
operator|||
operator|*
operator|(
name|prop
operator|->
name|value
operator|.
name|atom
operator|)
operator|==
literal|'c'
operator|)
condition|)
name|bdfface
operator|->
name|face_flags
operator||=
name|FT_FACE_FLAG_FIXED_WIDTH
expr_stmt|;
comment|/* FZ XXX: TO DO: FT_FACE_FLAGS_VERTICAL   */
comment|/* FZ XXX: I need a font to implement this */
name|prop
operator|=
name|bdf_get_font_property
argument_list|(
name|font
argument_list|,
literal|"FAMILY_NAME"
argument_list|)
expr_stmt|;
if|if
condition|(
name|prop
operator|&&
name|prop
operator|->
name|value
operator|.
name|atom
condition|)
block|{
if|if
condition|(
name|FT_STRDUP
argument_list|(
name|bdfface
operator|->
name|family_name
argument_list|,
name|prop
operator|->
name|value
operator|.
name|atom
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
block|}
else|else
name|bdfface
operator|->
name|family_name
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|bdf_interpret_style
argument_list|(
name|face
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|Exit
goto|;
comment|/* the number of glyphs (with one slot for the undefined glyph */
comment|/* at position 0 and all unencoded glyphs)                     */
name|bdfface
operator|->
name|num_glyphs
operator|=
name|font
operator|->
name|glyphs_size
operator|+
literal|1
expr_stmt|;
name|bdfface
operator|->
name|num_fixed_sizes
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|bdfface
operator|->
name|available_sizes
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
block|{
name|FT_Bitmap_Size
modifier|*
name|bsize
init|=
name|bdfface
operator|->
name|available_sizes
decl_stmt|;
name|FT_Short
name|resolution_x
init|=
literal|0
decl_stmt|,
name|resolution_y
init|=
literal|0
decl_stmt|;
name|FT_MEM_ZERO
argument_list|(
name|bsize
argument_list|,
sizeof|sizeof
argument_list|(
name|FT_Bitmap_Size
argument_list|)
argument_list|)
expr_stmt|;
name|bsize
operator|->
name|height
operator|=
call|(
name|FT_Short
call|)
argument_list|(
name|font
operator|->
name|font_ascent
operator|+
name|font
operator|->
name|font_descent
argument_list|)
expr_stmt|;
name|prop
operator|=
name|bdf_get_font_property
argument_list|(
name|font
argument_list|,
literal|"AVERAGE_WIDTH"
argument_list|)
expr_stmt|;
if|if
condition|(
name|prop
condition|)
name|bsize
operator|->
name|width
operator|=
call|(
name|FT_Short
call|)
argument_list|(
operator|(
name|prop
operator|->
name|value
operator|.
name|l
operator|+
literal|5
operator|)
operator|/
literal|10
argument_list|)
expr_stmt|;
else|else
name|bsize
operator|->
name|width
operator|=
call|(
name|FT_Short
call|)
argument_list|(
name|bsize
operator|->
name|height
operator|*
literal|2
operator|/
literal|3
argument_list|)
expr_stmt|;
name|prop
operator|=
name|bdf_get_font_property
argument_list|(
name|font
argument_list|,
literal|"POINT_SIZE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|prop
condition|)
comment|/* convert from 722.7 decipoints to 72 points per inch */
name|bsize
operator|->
name|size
operator|=
call|(
name|FT_Pos
call|)
argument_list|(
operator|(
name|prop
operator|->
name|value
operator|.
name|l
operator|*
literal|64
operator|*
literal|7200
operator|+
literal|36135L
operator|)
operator|/
literal|72270L
argument_list|)
expr_stmt|;
else|else
name|bsize
operator|->
name|size
operator|=
name|bsize
operator|->
name|width
operator|<<
literal|6
expr_stmt|;
name|prop
operator|=
name|bdf_get_font_property
argument_list|(
name|font
argument_list|,
literal|"PIXEL_SIZE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|prop
condition|)
name|bsize
operator|->
name|y_ppem
operator|=
operator|(
name|FT_Short
operator|)
name|prop
operator|->
name|value
operator|.
name|l
operator|<<
literal|6
expr_stmt|;
name|prop
operator|=
name|bdf_get_font_property
argument_list|(
name|font
argument_list|,
literal|"RESOLUTION_X"
argument_list|)
expr_stmt|;
if|if
condition|(
name|prop
condition|)
name|resolution_x
operator|=
operator|(
name|FT_Short
operator|)
name|prop
operator|->
name|value
operator|.
name|l
expr_stmt|;
name|prop
operator|=
name|bdf_get_font_property
argument_list|(
name|font
argument_list|,
literal|"RESOLUTION_Y"
argument_list|)
expr_stmt|;
if|if
condition|(
name|prop
condition|)
name|resolution_y
operator|=
operator|(
name|FT_Short
operator|)
name|prop
operator|->
name|value
operator|.
name|l
expr_stmt|;
if|if
condition|(
name|bsize
operator|->
name|y_ppem
operator|==
literal|0
condition|)
block|{
name|bsize
operator|->
name|y_ppem
operator|=
name|bsize
operator|->
name|size
expr_stmt|;
if|if
condition|(
name|resolution_y
condition|)
name|bsize
operator|->
name|y_ppem
operator|=
name|bsize
operator|->
name|y_ppem
operator|*
name|resolution_y
operator|/
literal|72
expr_stmt|;
block|}
if|if
condition|(
name|resolution_x
operator|&&
name|resolution_y
condition|)
name|bsize
operator|->
name|x_ppem
operator|=
name|bsize
operator|->
name|y_ppem
operator|*
name|resolution_x
operator|/
name|resolution_y
expr_stmt|;
else|else
name|bsize
operator|->
name|x_ppem
operator|=
name|bsize
operator|->
name|y_ppem
expr_stmt|;
block|}
comment|/* encoding table */
block|{
name|bdf_glyph_t
modifier|*
name|cur
init|=
name|font
operator|->
name|glyphs
decl_stmt|;
name|unsigned
name|long
name|n
decl_stmt|;
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|face
operator|->
name|en_table
argument_list|,
name|font
operator|->
name|glyphs_size
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|face
operator|->
name|default_glyph
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|font
operator|->
name|glyphs_size
condition|;
name|n
operator|++
control|)
block|{
operator|(
name|face
operator|->
name|en_table
index|[
name|n
index|]
operator|)
operator|.
name|enc
operator|=
name|cur
index|[
name|n
index|]
operator|.
name|encoding
expr_stmt|;
name|FT_TRACE4
argument_list|(
operator|(
literal|"  idx %d, val 0x%lX\n"
operator|,
name|n
operator|,
name|cur
index|[
name|n
index|]
operator|.
name|encoding
operator|)
argument_list|)
expr_stmt|;
operator|(
name|face
operator|->
name|en_table
index|[
name|n
index|]
operator|)
operator|.
name|glyph
operator|=
operator|(
name|FT_Short
operator|)
name|n
expr_stmt|;
if|if
condition|(
name|cur
index|[
name|n
index|]
operator|.
name|encoding
operator|==
name|font
operator|->
name|default_char
condition|)
block|{
if|if
condition|(
name|n
operator|<
name|FT_UINT_MAX
condition|)
name|face
operator|->
name|default_glyph
operator|=
operator|(
name|FT_UInt
operator|)
name|n
expr_stmt|;
else|else
name|FT_TRACE1
argument_list|(
operator|(
literal|"BDF_Face_Init:"
literal|" idx %d is too large for this system\n"
operator|,
name|n
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* charmaps */
block|{
name|bdf_property_t
modifier|*
name|charset_registry
init|=
literal|0
decl_stmt|,
modifier|*
name|charset_encoding
init|=
literal|0
decl_stmt|;
name|FT_Bool
name|unicode_charmap
init|=
literal|0
decl_stmt|;
name|charset_registry
operator|=
name|bdf_get_font_property
argument_list|(
name|font
argument_list|,
literal|"CHARSET_REGISTRY"
argument_list|)
expr_stmt|;
name|charset_encoding
operator|=
name|bdf_get_font_property
argument_list|(
name|font
argument_list|,
literal|"CHARSET_ENCODING"
argument_list|)
expr_stmt|;
if|if
condition|(
name|charset_registry
operator|&&
name|charset_encoding
condition|)
block|{
if|if
condition|(
name|charset_registry
operator|->
name|format
operator|==
name|BDF_ATOM
operator|&&
name|charset_encoding
operator|->
name|format
operator|==
name|BDF_ATOM
operator|&&
name|charset_registry
operator|->
name|value
operator|.
name|atom
operator|&&
name|charset_encoding
operator|->
name|value
operator|.
name|atom
condition|)
block|{
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|FT_STRDUP
argument_list|(
name|face
operator|->
name|charset_encoding
argument_list|,
name|charset_encoding
operator|->
name|value
operator|.
name|atom
argument_list|)
operator|||
name|FT_STRDUP
argument_list|(
name|face
operator|->
name|charset_registry
argument_list|,
name|charset_registry
operator|->
name|value
operator|.
name|atom
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
comment|/* Uh, oh, compare first letters manually to avoid dependency */
comment|/* on locales.                                                */
name|s
operator|=
name|face
operator|->
name|charset_registry
expr_stmt|;
if|if
condition|(
operator|(
name|s
index|[
literal|0
index|]
operator|==
literal|'i'
operator|||
name|s
index|[
literal|0
index|]
operator|==
literal|'I'
operator|)
operator|&&
operator|(
name|s
index|[
literal|1
index|]
operator|==
literal|'s'
operator|||
name|s
index|[
literal|1
index|]
operator|==
literal|'S'
operator|)
operator|&&
operator|(
name|s
index|[
literal|2
index|]
operator|==
literal|'o'
operator|||
name|s
index|[
literal|2
index|]
operator|==
literal|'O'
operator|)
condition|)
block|{
name|s
operator|+=
literal|3
expr_stmt|;
if|if
condition|(
operator|!
name|ft_strcmp
argument_list|(
name|s
argument_list|,
literal|"10646"
argument_list|)
operator|||
operator|(
operator|!
name|ft_strcmp
argument_list|(
name|s
argument_list|,
literal|"8859"
argument_list|)
operator|&&
operator|!
name|ft_strcmp
argument_list|(
name|face
operator|->
name|charset_encoding
argument_list|,
literal|"1"
argument_list|)
operator|)
condition|)
name|unicode_charmap
operator|=
literal|1
expr_stmt|;
block|}
block|{
name|FT_CharMapRec
name|charmap
decl_stmt|;
name|charmap
operator|.
name|face
operator|=
name|FT_FACE
argument_list|(
name|face
argument_list|)
expr_stmt|;
name|charmap
operator|.
name|encoding
operator|=
name|FT_ENCODING_NONE
expr_stmt|;
comment|/* initial platform/encoding should indicate unset status? */
name|charmap
operator|.
name|platform_id
operator|=
name|TT_PLATFORM_APPLE_UNICODE
expr_stmt|;
name|charmap
operator|.
name|encoding_id
operator|=
name|TT_APPLE_ID_DEFAULT
expr_stmt|;
if|if
condition|(
name|unicode_charmap
condition|)
block|{
name|charmap
operator|.
name|encoding
operator|=
name|FT_ENCODING_UNICODE
expr_stmt|;
name|charmap
operator|.
name|platform_id
operator|=
name|TT_PLATFORM_MICROSOFT
expr_stmt|;
name|charmap
operator|.
name|encoding_id
operator|=
name|TT_MS_ID_UNICODE_CS
expr_stmt|;
block|}
name|error
operator|=
name|FT_CMap_New
argument_list|(
operator|&
name|bdf_cmap_class
argument_list|,
name|NULL
argument_list|,
operator|&
name|charmap
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Select default charmap */
block|if ( bdfface->num_charmaps )                 bdfface->charmap = bdfface->charmaps[0];
endif|#
directive|endif
block|}
goto|goto
name|Exit
goto|;
block|}
block|}
comment|/* otherwise assume Adobe standard encoding */
block|{
name|FT_CharMapRec
name|charmap
decl_stmt|;
name|charmap
operator|.
name|face
operator|=
name|FT_FACE
argument_list|(
name|face
argument_list|)
expr_stmt|;
name|charmap
operator|.
name|encoding
operator|=
name|FT_ENCODING_ADOBE_STANDARD
expr_stmt|;
name|charmap
operator|.
name|platform_id
operator|=
name|TT_PLATFORM_ADOBE
expr_stmt|;
name|charmap
operator|.
name|encoding_id
operator|=
name|TT_ADOBE_ID_STANDARD
expr_stmt|;
name|error
operator|=
name|FT_CMap_New
argument_list|(
operator|&
name|bdf_cmap_class
argument_list|,
name|NULL
argument_list|,
operator|&
name|charmap
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Select default charmap */
if|if
condition|(
name|bdfface
operator|->
name|num_charmaps
condition|)
name|bdfface
operator|->
name|charmap
operator|=
name|bdfface
operator|->
name|charmaps
index|[
literal|0
index|]
expr_stmt|;
block|}
block|}
block|}
name|Exit
label|:
return|return
name|error
return|;
name|Fail
label|:
name|BDF_Face_Done
argument_list|(
name|bdfface
argument_list|)
expr_stmt|;
return|return
name|FT_THROW
argument_list|(
name|Unknown_File_Format
argument_list|)
return|;
block|}
end_block
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|BDF_Size_Select
argument_list|(
argument|FT_Size   size
argument_list|,
argument|FT_ULong  strike_index
argument_list|)
end_macro
begin_block
block|{
name|bdf_font_t
modifier|*
name|bdffont
init|=
operator|(
operator|(
name|BDF_Face
operator|)
name|size
operator|->
name|face
operator|)
operator|->
name|bdffont
decl_stmt|;
name|FT_Select_Metrics
argument_list|(
name|size
operator|->
name|face
argument_list|,
name|strike_index
argument_list|)
expr_stmt|;
name|size
operator|->
name|metrics
operator|.
name|ascender
operator|=
name|bdffont
operator|->
name|font_ascent
operator|<<
literal|6
expr_stmt|;
name|size
operator|->
name|metrics
operator|.
name|descender
operator|=
operator|-
name|bdffont
operator|->
name|font_descent
operator|<<
literal|6
expr_stmt|;
name|size
operator|->
name|metrics
operator|.
name|max_advance
operator|=
name|bdffont
operator|->
name|bbx
operator|.
name|width
operator|<<
literal|6
expr_stmt|;
return|return
name|FT_Err_Ok
return|;
block|}
end_block
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|BDF_Size_Request
argument_list|(
argument|FT_Size          size
argument_list|,
argument|FT_Size_Request  req
argument_list|)
end_macro
begin_block
block|{
name|FT_Face
name|face
init|=
name|size
operator|->
name|face
decl_stmt|;
name|FT_Bitmap_Size
modifier|*
name|bsize
init|=
name|face
operator|->
name|available_sizes
decl_stmt|;
name|bdf_font_t
modifier|*
name|bdffont
init|=
operator|(
operator|(
name|BDF_Face
operator|)
name|face
operator|)
operator|->
name|bdffont
decl_stmt|;
name|FT_Error
name|error
init|=
name|FT_ERR
argument_list|(
name|Invalid_Pixel_Size
argument_list|)
decl_stmt|;
name|FT_Long
name|height
decl_stmt|;
name|height
operator|=
name|FT_REQUEST_HEIGHT
argument_list|(
name|req
argument_list|)
expr_stmt|;
name|height
operator|=
operator|(
name|height
operator|+
literal|32
operator|)
operator|>>
literal|6
expr_stmt|;
switch|switch
condition|(
name|req
operator|->
name|type
condition|)
block|{
case|case
name|FT_SIZE_REQUEST_TYPE_NOMINAL
case|:
if|if
condition|(
name|height
operator|==
operator|(
operator|(
name|bsize
operator|->
name|y_ppem
operator|+
literal|32
operator|)
operator|>>
literal|6
operator|)
condition|)
name|error
operator|=
name|FT_Err_Ok
expr_stmt|;
break|break;
case|case
name|FT_SIZE_REQUEST_TYPE_REAL_DIM
case|:
if|if
condition|(
name|height
operator|==
operator|(
name|bdffont
operator|->
name|font_ascent
operator|+
name|bdffont
operator|->
name|font_descent
operator|)
condition|)
name|error
operator|=
name|FT_Err_Ok
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|FT_THROW
argument_list|(
name|Unimplemented_Feature
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
else|else
return|return
name|BDF_Size_Select
argument_list|(
name|size
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_block
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|BDF_Glyph_Load
argument_list|(
argument|FT_GlyphSlot  slot
argument_list|,
argument|FT_Size       size
argument_list|,
argument|FT_UInt       glyph_index
argument_list|,
argument|FT_Int32      load_flags
argument_list|)
end_macro
begin_block
block|{
name|BDF_Face
name|bdf
init|=
operator|(
name|BDF_Face
operator|)
name|FT_SIZE_FACE
argument_list|(
name|size
argument_list|)
decl_stmt|;
name|FT_Face
name|face
init|=
name|FT_FACE
argument_list|(
name|bdf
argument_list|)
decl_stmt|;
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
name|FT_Bitmap
modifier|*
name|bitmap
init|=
operator|&
name|slot
operator|->
name|bitmap
decl_stmt|;
name|bdf_glyph_t
name|glyph
decl_stmt|;
name|int
name|bpp
init|=
name|bdf
operator|->
name|bdffont
operator|->
name|bpp
decl_stmt|;
name|FT_UNUSED
argument_list|(
name|load_flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|face
condition|)
block|{
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Face_Handle
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|glyph_index
operator|>=
operator|(
name|FT_UInt
operator|)
name|face
operator|->
name|num_glyphs
condition|)
block|{
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Argument
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|FT_TRACE1
argument_list|(
operator|(
literal|"BDF_Glyph_Load: glyph index %d\n"
operator|,
name|glyph_index
operator|)
argument_list|)
expr_stmt|;
comment|/* index 0 is the undefined glyph */
if|if
condition|(
name|glyph_index
operator|==
literal|0
condition|)
name|glyph_index
operator|=
name|bdf
operator|->
name|default_glyph
expr_stmt|;
else|else
name|glyph_index
operator|--
expr_stmt|;
comment|/* slot, bitmap => freetype, glyph => bdflib */
name|glyph
operator|=
name|bdf
operator|->
name|bdffont
operator|->
name|glyphs
index|[
name|glyph_index
index|]
expr_stmt|;
name|bitmap
operator|->
name|rows
operator|=
name|glyph
operator|.
name|bbx
operator|.
name|height
expr_stmt|;
name|bitmap
operator|->
name|width
operator|=
name|glyph
operator|.
name|bbx
operator|.
name|width
expr_stmt|;
if|if
condition|(
name|glyph
operator|.
name|bpr
operator|>
name|INT_MAX
condition|)
name|FT_TRACE1
argument_list|(
operator|(
literal|"BDF_Glyph_Load: too large pitch %d is truncated\n"
operator|,
name|glyph
operator|.
name|bpr
operator|)
argument_list|)
expr_stmt|;
name|bitmap
operator|->
name|pitch
operator|=
operator|(
name|int
operator|)
name|glyph
operator|.
name|bpr
expr_stmt|;
comment|/* same as FT_Bitmap.pitch */
comment|/* note: we don't allocate a new array to hold the bitmap; */
comment|/*       we can simply point to it                         */
name|ft_glyphslot_set_bitmap
argument_list|(
name|slot
argument_list|,
name|glyph
operator|.
name|bitmap
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|bpp
condition|)
block|{
case|case
literal|1
case|:
name|bitmap
operator|->
name|pixel_mode
operator|=
name|FT_PIXEL_MODE_MONO
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|bitmap
operator|->
name|pixel_mode
operator|=
name|FT_PIXEL_MODE_GRAY2
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|bitmap
operator|->
name|pixel_mode
operator|=
name|FT_PIXEL_MODE_GRAY4
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|bitmap
operator|->
name|pixel_mode
operator|=
name|FT_PIXEL_MODE_GRAY
expr_stmt|;
name|bitmap
operator|->
name|num_grays
operator|=
literal|256
expr_stmt|;
break|break;
block|}
name|slot
operator|->
name|format
operator|=
name|FT_GLYPH_FORMAT_BITMAP
expr_stmt|;
name|slot
operator|->
name|bitmap_left
operator|=
name|glyph
operator|.
name|bbx
operator|.
name|x_offset
expr_stmt|;
name|slot
operator|->
name|bitmap_top
operator|=
name|glyph
operator|.
name|bbx
operator|.
name|ascent
expr_stmt|;
name|slot
operator|->
name|metrics
operator|.
name|horiAdvance
operator|=
name|glyph
operator|.
name|dwidth
operator|<<
literal|6
expr_stmt|;
name|slot
operator|->
name|metrics
operator|.
name|horiBearingX
operator|=
name|glyph
operator|.
name|bbx
operator|.
name|x_offset
operator|<<
literal|6
expr_stmt|;
name|slot
operator|->
name|metrics
operator|.
name|horiBearingY
operator|=
name|glyph
operator|.
name|bbx
operator|.
name|ascent
operator|<<
literal|6
expr_stmt|;
name|slot
operator|->
name|metrics
operator|.
name|width
operator|=
name|bitmap
operator|->
name|width
operator|<<
literal|6
expr_stmt|;
name|slot
operator|->
name|metrics
operator|.
name|height
operator|=
name|bitmap
operator|->
name|rows
operator|<<
literal|6
expr_stmt|;
comment|/*      * XXX DWIDTH1 and VVECTOR should be parsed and      * used here, provided such fonts do exist.      */
name|ft_synthesize_vertical_metrics
argument_list|(
operator|&
name|slot
operator|->
name|metrics
argument_list|,
name|bdf
operator|->
name|bdffont
operator|->
name|bbx
operator|.
name|height
operator|<<
literal|6
argument_list|)
expr_stmt|;
name|Exit
label|:
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/*   *   *  BDF SERVICE   *   */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|bdf_get_bdf_property
name|bdf_get_bdf_property
parameter_list|(
name|BDF_Face
name|face
parameter_list|,
specifier|const
name|char
modifier|*
name|prop_name
parameter_list|,
name|BDF_PropertyRec
modifier|*
name|aproperty
parameter_list|)
block|{
name|bdf_property_t
modifier|*
name|prop
decl_stmt|;
name|FT_ASSERT
argument_list|(
name|face
operator|&&
name|face
operator|->
name|bdffont
argument_list|)
expr_stmt|;
name|prop
operator|=
name|bdf_get_font_property
argument_list|(
name|face
operator|->
name|bdffont
argument_list|,
name|prop_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|prop
condition|)
block|{
switch|switch
condition|(
name|prop
operator|->
name|format
condition|)
block|{
case|case
name|BDF_ATOM
case|:
name|aproperty
operator|->
name|type
operator|=
name|BDF_PROPERTY_TYPE_ATOM
expr_stmt|;
name|aproperty
operator|->
name|u
operator|.
name|atom
operator|=
name|prop
operator|->
name|value
operator|.
name|atom
expr_stmt|;
break|break;
case|case
name|BDF_INTEGER
case|:
if|if
condition|(
name|prop
operator|->
name|value
operator|.
name|l
operator|>
literal|0x7FFFFFFFL
operator|||
name|prop
operator|->
name|value
operator|.
name|l
operator|<
operator|(
operator|-
literal|1
operator|-
literal|0x7FFFFFFFL
operator|)
condition|)
block|{
name|FT_TRACE1
argument_list|(
operator|(
literal|"bdf_get_bdf_property:"
literal|" too large integer 0x%x is truncated\n"
operator|)
argument_list|)
expr_stmt|;
block|}
name|aproperty
operator|->
name|type
operator|=
name|BDF_PROPERTY_TYPE_INTEGER
expr_stmt|;
name|aproperty
operator|->
name|u
operator|.
name|integer
operator|=
operator|(
name|FT_Int32
operator|)
name|prop
operator|->
name|value
operator|.
name|l
expr_stmt|;
break|break;
case|case
name|BDF_CARDINAL
case|:
if|if
condition|(
name|prop
operator|->
name|value
operator|.
name|ul
operator|>
literal|0xFFFFFFFFUL
condition|)
block|{
name|FT_TRACE1
argument_list|(
operator|(
literal|"bdf_get_bdf_property:"
literal|" too large cardinal 0x%x is truncated\n"
operator|)
argument_list|)
expr_stmt|;
block|}
name|aproperty
operator|->
name|type
operator|=
name|BDF_PROPERTY_TYPE_CARDINAL
expr_stmt|;
name|aproperty
operator|->
name|u
operator|.
name|cardinal
operator|=
operator|(
name|FT_UInt32
operator|)
name|prop
operator|->
name|value
operator|.
name|ul
expr_stmt|;
break|break;
default|default:
goto|goto
name|Fail
goto|;
block|}
return|return
literal|0
return|;
block|}
name|Fail
label|:
return|return
name|FT_THROW
argument_list|(
name|Invalid_Argument
argument_list|)
return|;
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|bdf_get_charset_id
name|bdf_get_charset_id
parameter_list|(
name|BDF_Face
name|face
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|acharset_encoding
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|acharset_registry
parameter_list|)
block|{
operator|*
name|acharset_encoding
operator|=
name|face
operator|->
name|charset_encoding
expr_stmt|;
operator|*
name|acharset_registry
operator|=
name|face
operator|->
name|charset_registry
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|bdf_service_bdf
specifier|static
specifier|const
name|FT_Service_BDFRec
name|bdf_service_bdf
init|=
block|{
operator|(
name|FT_BDF_GetCharsetIdFunc
operator|)
name|bdf_get_charset_id
block|,
operator|(
name|FT_BDF_GetPropertyFunc
operator|)
name|bdf_get_bdf_property
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*   *   *  SERVICES LIST   *   */
end_comment
begin_decl_stmt
DECL|variable|bdf_services
specifier|static
specifier|const
name|FT_ServiceDescRec
name|bdf_services
index|[]
init|=
block|{
block|{
name|FT_SERVICE_ID_BDF
block|,
operator|&
name|bdf_service_bdf
block|}
block|,
block|{
name|FT_SERVICE_ID_XF86_NAME
block|,
name|FT_XF86_FORMAT_BDF
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_Module_Interface
argument_list|)
end_macro
begin_macro
name|bdf_driver_requester
argument_list|(
argument|FT_Module    module
argument_list|,
argument|const char*  name
argument_list|)
end_macro
begin_block
block|{
name|FT_UNUSED
argument_list|(
name|module
argument_list|)
expr_stmt|;
return|return
name|ft_service_list_lookup
argument_list|(
name|bdf_services
argument_list|,
name|name
argument_list|)
return|;
block|}
end_block
begin_decl_stmt
name|FT_CALLBACK_TABLE_DEF
DECL|variable|bdf_driver_class
specifier|const
name|FT_Driver_ClassRec
name|bdf_driver_class
init|=
block|{
block|{
name|FT_MODULE_FONT_DRIVER
operator||
name|FT_MODULE_DRIVER_NO_OUTLINES
block|,
sizeof|sizeof
argument_list|(
name|FT_DriverRec
argument_list|)
block|,
literal|"bdf"
block|,
literal|0x10000L
block|,
literal|0x20000L
block|,
literal|0
block|,
literal|0
block|,
comment|/* FT_Module_Constructor */
literal|0
block|,
comment|/* FT_Module_Destructor  */
name|bdf_driver_requester
block|}
block|,
sizeof|sizeof
argument_list|(
name|BDF_FaceRec
argument_list|)
block|,
sizeof|sizeof
argument_list|(
name|FT_SizeRec
argument_list|)
block|,
sizeof|sizeof
argument_list|(
name|FT_GlyphSlotRec
argument_list|)
block|,
name|BDF_Face_Init
block|,
name|BDF_Face_Done
block|,
literal|0
block|,
comment|/* FT_Size_InitFunc */
literal|0
block|,
comment|/* FT_Size_DoneFunc */
literal|0
block|,
comment|/* FT_Slot_InitFunc */
literal|0
block|,
comment|/* FT_Slot_DoneFunc */
name|BDF_Glyph_Load
block|,
literal|0
block|,
comment|/* FT_Face_GetKerningFunc  */
literal|0
block|,
comment|/* FT_Face_AttachFunc      */
literal|0
block|,
comment|/* FT_Face_GetAdvancesFunc */
name|BDF_Size_Request
block|,
name|BDF_Size_Select
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* END */
end_comment
end_unit
