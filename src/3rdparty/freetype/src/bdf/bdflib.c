begin_unit
begin_comment
comment|/*  * Copyright 2000 Computing Research Labs, New Mexico State University  * Copyright 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2009  *   Francesco Zappa Nardelli  *  * Permission is hereby granted, free of charge, to any person obtaining a  * copy of this software and associated documentation files (the "Software"),  * to deal in the Software without restriction, including without limitation  * the rights to use, copy, modify, merge, publish, distribute, sublicense,  * and/or sell copies of the Software, and to permit persons to whom the  * Software is furnished to do so, subject to the following conditions:  *  * The above copyright notice and this permission notice shall be included in  * all copies or substantial portions of the Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL  * THE COMPUTING RESEARCH LAB OR NEW MEXICO STATE UNIVERSITY BE LIABLE FOR ANY  * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT  * OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR  * THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*  This file is based on bdf.c,v 1.22 2000/03/16 20:08:50               */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*  taken from Mark Leisher's xmbdfed package                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<ft2build.h>
end_include
begin_include
include|#
directive|include
include|FT_FREETYPE_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_DEBUG_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_STREAM_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_OBJECTS_H
end_include
begin_include
include|#
directive|include
file|"bdf.h"
end_include
begin_include
include|#
directive|include
file|"bdferror.h"
end_include
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
end_comment
begin_comment
comment|/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
end_comment
begin_comment
comment|/* messages during execution.                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_undef
DECL|macro|FT_COMPONENT
undef|#
directive|undef
name|FT_COMPONENT
end_undef
begin_define
DECL|macro|FT_COMPONENT
define|#
directive|define
name|FT_COMPONENT
value|trace_bdflib
end_define
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* Default BDF font options.                                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_decl_stmt
DECL|variable|_bdf_opts
specifier|static
specifier|const
name|bdf_options_t
name|_bdf_opts
init|=
block|{
literal|1
block|,
comment|/* Correct metrics.               */
literal|1
block|,
comment|/* Preserve unencoded glyphs.     */
literal|0
block|,
comment|/* Preserve comments.             */
name|BDF_PROPORTIONAL
comment|/* Default spacing.               */
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* Builtin BDF font properties.                                          */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/* List of most properties that might appear in a font.  Doesn't include */
end_comment
begin_comment
comment|/* the RAW_* and AXIS_* properties in X11R6 polymorphic fonts.           */
end_comment
begin_decl_stmt
DECL|variable|_bdf_properties
specifier|static
specifier|const
name|bdf_property_t
name|_bdf_properties
index|[]
init|=
block|{
block|{
operator|(
name|char
operator|*
operator|)
literal|"ADD_STYLE_NAME"
block|,
name|BDF_ATOM
block|,
literal|1
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|"AVERAGE_WIDTH"
block|,
name|BDF_INTEGER
block|,
literal|1
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|"AVG_CAPITAL_WIDTH"
block|,
name|BDF_INTEGER
block|,
literal|1
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|"AVG_LOWERCASE_WIDTH"
block|,
name|BDF_INTEGER
block|,
literal|1
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|"CAP_HEIGHT"
block|,
name|BDF_INTEGER
block|,
literal|1
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|"CHARSET_COLLECTIONS"
block|,
name|BDF_ATOM
block|,
literal|1
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|"CHARSET_ENCODING"
block|,
name|BDF_ATOM
block|,
literal|1
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|"CHARSET_REGISTRY"
block|,
name|BDF_ATOM
block|,
literal|1
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|"COMMENT"
block|,
name|BDF_ATOM
block|,
literal|1
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|"COPYRIGHT"
block|,
name|BDF_ATOM
block|,
literal|1
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|"DEFAULT_CHAR"
block|,
name|BDF_CARDINAL
block|,
literal|1
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|"DESTINATION"
block|,
name|BDF_CARDINAL
block|,
literal|1
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|"DEVICE_FONT_NAME"
block|,
name|BDF_ATOM
block|,
literal|1
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|"END_SPACE"
block|,
name|BDF_INTEGER
block|,
literal|1
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|"FACE_NAME"
block|,
name|BDF_ATOM
block|,
literal|1
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|"FAMILY_NAME"
block|,
name|BDF_ATOM
block|,
literal|1
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|"FIGURE_WIDTH"
block|,
name|BDF_INTEGER
block|,
literal|1
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|"FONT"
block|,
name|BDF_ATOM
block|,
literal|1
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|"FONTNAME_REGISTRY"
block|,
name|BDF_ATOM
block|,
literal|1
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|"FONT_ASCENT"
block|,
name|BDF_INTEGER
block|,
literal|1
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|"FONT_DESCENT"
block|,
name|BDF_INTEGER
block|,
literal|1
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|"FOUNDRY"
block|,
name|BDF_ATOM
block|,
literal|1
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|"FULL_NAME"
block|,
name|BDF_ATOM
block|,
literal|1
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|"ITALIC_ANGLE"
block|,
name|BDF_INTEGER
block|,
literal|1
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|"MAX_SPACE"
block|,
name|BDF_INTEGER
block|,
literal|1
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|"MIN_SPACE"
block|,
name|BDF_INTEGER
block|,
literal|1
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|"NORM_SPACE"
block|,
name|BDF_INTEGER
block|,
literal|1
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|"NOTICE"
block|,
name|BDF_ATOM
block|,
literal|1
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|"PIXEL_SIZE"
block|,
name|BDF_INTEGER
block|,
literal|1
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|"POINT_SIZE"
block|,
name|BDF_INTEGER
block|,
literal|1
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|"QUAD_WIDTH"
block|,
name|BDF_INTEGER
block|,
literal|1
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|"RAW_ASCENT"
block|,
name|BDF_INTEGER
block|,
literal|1
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|"RAW_AVERAGE_WIDTH"
block|,
name|BDF_INTEGER
block|,
literal|1
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|"RAW_AVG_CAPITAL_WIDTH"
block|,
name|BDF_INTEGER
block|,
literal|1
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|"RAW_AVG_LOWERCASE_WIDTH"
block|,
name|BDF_INTEGER
block|,
literal|1
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|"RAW_CAP_HEIGHT"
block|,
name|BDF_INTEGER
block|,
literal|1
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|"RAW_DESCENT"
block|,
name|BDF_INTEGER
block|,
literal|1
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|"RAW_END_SPACE"
block|,
name|BDF_INTEGER
block|,
literal|1
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|"RAW_FIGURE_WIDTH"
block|,
name|BDF_INTEGER
block|,
literal|1
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|"RAW_MAX_SPACE"
block|,
name|BDF_INTEGER
block|,
literal|1
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|"RAW_MIN_SPACE"
block|,
name|BDF_INTEGER
block|,
literal|1
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|"RAW_NORM_SPACE"
block|,
name|BDF_INTEGER
block|,
literal|1
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|"RAW_PIXEL_SIZE"
block|,
name|BDF_INTEGER
block|,
literal|1
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|"RAW_POINT_SIZE"
block|,
name|BDF_INTEGER
block|,
literal|1
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|"RAW_PIXELSIZE"
block|,
name|BDF_INTEGER
block|,
literal|1
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|"RAW_POINTSIZE"
block|,
name|BDF_INTEGER
block|,
literal|1
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|"RAW_QUAD_WIDTH"
block|,
name|BDF_INTEGER
block|,
literal|1
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|"RAW_SMALL_CAP_SIZE"
block|,
name|BDF_INTEGER
block|,
literal|1
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|"RAW_STRIKEOUT_ASCENT"
block|,
name|BDF_INTEGER
block|,
literal|1
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|"RAW_STRIKEOUT_DESCENT"
block|,
name|BDF_INTEGER
block|,
literal|1
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|"RAW_SUBSCRIPT_SIZE"
block|,
name|BDF_INTEGER
block|,
literal|1
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|"RAW_SUBSCRIPT_X"
block|,
name|BDF_INTEGER
block|,
literal|1
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|"RAW_SUBSCRIPT_Y"
block|,
name|BDF_INTEGER
block|,
literal|1
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|"RAW_SUPERSCRIPT_SIZE"
block|,
name|BDF_INTEGER
block|,
literal|1
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|"RAW_SUPERSCRIPT_X"
block|,
name|BDF_INTEGER
block|,
literal|1
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|"RAW_SUPERSCRIPT_Y"
block|,
name|BDF_INTEGER
block|,
literal|1
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|"RAW_UNDERLINE_POSITION"
block|,
name|BDF_INTEGER
block|,
literal|1
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|"RAW_UNDERLINE_THICKNESS"
block|,
name|BDF_INTEGER
block|,
literal|1
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|"RAW_X_HEIGHT"
block|,
name|BDF_INTEGER
block|,
literal|1
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|"RELATIVE_SETWIDTH"
block|,
name|BDF_CARDINAL
block|,
literal|1
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|"RELATIVE_WEIGHT"
block|,
name|BDF_CARDINAL
block|,
literal|1
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|"RESOLUTION"
block|,
name|BDF_INTEGER
block|,
literal|1
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|"RESOLUTION_X"
block|,
name|BDF_CARDINAL
block|,
literal|1
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|"RESOLUTION_Y"
block|,
name|BDF_CARDINAL
block|,
literal|1
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|"SETWIDTH_NAME"
block|,
name|BDF_ATOM
block|,
literal|1
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|"SLANT"
block|,
name|BDF_ATOM
block|,
literal|1
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|"SMALL_CAP_SIZE"
block|,
name|BDF_INTEGER
block|,
literal|1
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|"SPACING"
block|,
name|BDF_ATOM
block|,
literal|1
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|"STRIKEOUT_ASCENT"
block|,
name|BDF_INTEGER
block|,
literal|1
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|"STRIKEOUT_DESCENT"
block|,
name|BDF_INTEGER
block|,
literal|1
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|"SUBSCRIPT_SIZE"
block|,
name|BDF_INTEGER
block|,
literal|1
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|"SUBSCRIPT_X"
block|,
name|BDF_INTEGER
block|,
literal|1
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|"SUBSCRIPT_Y"
block|,
name|BDF_INTEGER
block|,
literal|1
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|"SUPERSCRIPT_SIZE"
block|,
name|BDF_INTEGER
block|,
literal|1
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|"SUPERSCRIPT_X"
block|,
name|BDF_INTEGER
block|,
literal|1
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|"SUPERSCRIPT_Y"
block|,
name|BDF_INTEGER
block|,
literal|1
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|"UNDERLINE_POSITION"
block|,
name|BDF_INTEGER
block|,
literal|1
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|"UNDERLINE_THICKNESS"
block|,
name|BDF_INTEGER
block|,
literal|1
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|"WEIGHT"
block|,
name|BDF_CARDINAL
block|,
literal|1
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|"WEIGHT_NAME"
block|,
name|BDF_ATOM
block|,
literal|1
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|"X_HEIGHT"
block|,
name|BDF_INTEGER
block|,
literal|1
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|"_MULE_BASELINE_OFFSET"
block|,
name|BDF_INTEGER
block|,
literal|1
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|"_MULE_RELATIVE_COMPOSE"
block|,
name|BDF_INTEGER
block|,
literal|1
block|,
block|{
literal|0
block|}
block|}
block|,   }
decl_stmt|;
end_decl_stmt
begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|long
DECL|variable|_num_bdf_properties
name|_num_bdf_properties
init|=
sizeof|sizeof
argument_list|(
name|_bdf_properties
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|_bdf_properties
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* Hash table utilities for the properties.                              */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/* XXX: Replace this with FreeType's hash functions */
end_comment
begin_define
DECL|macro|INITIAL_HT_SIZE
define|#
directive|define
name|INITIAL_HT_SIZE
value|241
end_define
begin_typedef
typedef|typedef
name|void
function_decl|(
DECL|typedef|hash_free_func
modifier|*
name|hash_free_func
function_decl|)
parameter_list|(
name|hashnode
name|node
parameter_list|)
function_decl|;
end_typedef
begin_function
specifier|static
name|hashnode
modifier|*
DECL|function|hash_bucket
name|hash_bucket
parameter_list|(
specifier|const
name|char
modifier|*
name|key
parameter_list|,
name|hashtable
modifier|*
name|ht
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|kp
init|=
name|key
decl_stmt|;
name|unsigned
name|long
name|res
init|=
literal|0
decl_stmt|;
name|hashnode
modifier|*
name|bp
init|=
name|ht
operator|->
name|table
decl_stmt|,
modifier|*
name|ndp
decl_stmt|;
comment|/* Mocklisp hash function. */
while|while
condition|(
operator|*
name|kp
condition|)
name|res
operator|=
operator|(
name|res
operator|<<
literal|5
operator|)
operator|-
name|res
operator|+
operator|*
name|kp
operator|++
expr_stmt|;
name|ndp
operator|=
name|bp
operator|+
operator|(
name|res
operator|%
name|ht
operator|->
name|size
operator|)
expr_stmt|;
while|while
condition|(
operator|*
name|ndp
condition|)
block|{
name|kp
operator|=
operator|(
operator|*
name|ndp
operator|)
operator|->
name|key
expr_stmt|;
if|if
condition|(
name|kp
index|[
literal|0
index|]
operator|==
name|key
index|[
literal|0
index|]
operator|&&
name|ft_strcmp
argument_list|(
name|kp
argument_list|,
name|key
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|ndp
operator|--
expr_stmt|;
if|if
condition|(
name|ndp
operator|<
name|bp
condition|)
name|ndp
operator|=
name|bp
operator|+
operator|(
name|ht
operator|->
name|size
operator|-
literal|1
operator|)
expr_stmt|;
block|}
return|return
name|ndp
return|;
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|hash_rehash
name|hash_rehash
parameter_list|(
name|hashtable
modifier|*
name|ht
parameter_list|,
name|FT_Memory
name|memory
parameter_list|)
block|{
name|hashnode
modifier|*
name|obp
init|=
name|ht
operator|->
name|table
decl_stmt|,
modifier|*
name|bp
decl_stmt|,
modifier|*
name|nbp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|sz
init|=
name|ht
operator|->
name|size
decl_stmt|;
name|FT_Error
name|error
init|=
name|BDF_Err_Ok
decl_stmt|;
name|ht
operator|->
name|size
operator|<<=
literal|1
expr_stmt|;
name|ht
operator|->
name|limit
operator|=
name|ht
operator|->
name|size
operator|/
literal|3
expr_stmt|;
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|ht
operator|->
name|table
argument_list|,
name|ht
operator|->
name|size
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|bp
operator|=
name|obp
init|;
name|i
operator|<
name|sz
condition|;
name|i
operator|++
operator|,
name|bp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|bp
condition|)
block|{
name|nbp
operator|=
name|hash_bucket
argument_list|(
operator|(
operator|*
name|bp
operator|)
operator|->
name|key
argument_list|,
name|ht
argument_list|)
expr_stmt|;
operator|*
name|nbp
operator|=
operator|*
name|bp
expr_stmt|;
block|}
block|}
name|FT_FREE
argument_list|(
name|obp
argument_list|)
expr_stmt|;
name|Exit
label|:
return|return
name|error
return|;
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|hash_init
name|hash_init
parameter_list|(
name|hashtable
modifier|*
name|ht
parameter_list|,
name|FT_Memory
name|memory
parameter_list|)
block|{
name|int
name|sz
init|=
name|INITIAL_HT_SIZE
decl_stmt|;
name|FT_Error
name|error
init|=
name|BDF_Err_Ok
decl_stmt|;
name|ht
operator|->
name|size
operator|=
name|sz
expr_stmt|;
name|ht
operator|->
name|limit
operator|=
name|sz
operator|/
literal|3
expr_stmt|;
name|ht
operator|->
name|used
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|ht
operator|->
name|table
argument_list|,
name|sz
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|Exit
label|:
return|return
name|error
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|hash_free
name|hash_free
parameter_list|(
name|hashtable
modifier|*
name|ht
parameter_list|,
name|FT_Memory
name|memory
parameter_list|)
block|{
if|if
condition|(
name|ht
operator|!=
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|,
name|sz
init|=
name|ht
operator|->
name|size
decl_stmt|;
name|hashnode
modifier|*
name|bp
init|=
name|ht
operator|->
name|table
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sz
condition|;
name|i
operator|++
operator|,
name|bp
operator|++
control|)
name|FT_FREE
argument_list|(
operator|*
name|bp
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|ht
operator|->
name|table
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|hash_insert
name|hash_insert
parameter_list|(
name|char
modifier|*
name|key
parameter_list|,
name|size_t
name|data
parameter_list|,
name|hashtable
modifier|*
name|ht
parameter_list|,
name|FT_Memory
name|memory
parameter_list|)
block|{
name|hashnode
name|nn
decl_stmt|,
modifier|*
name|bp
init|=
name|hash_bucket
argument_list|(
name|key
argument_list|,
name|ht
argument_list|)
decl_stmt|;
name|FT_Error
name|error
init|=
name|BDF_Err_Ok
decl_stmt|;
name|nn
operator|=
operator|*
name|bp
expr_stmt|;
if|if
condition|(
operator|!
name|nn
condition|)
block|{
if|if
condition|(
name|FT_NEW
argument_list|(
name|nn
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
operator|*
name|bp
operator|=
name|nn
expr_stmt|;
name|nn
operator|->
name|key
operator|=
name|key
expr_stmt|;
name|nn
operator|->
name|data
operator|=
name|data
expr_stmt|;
if|if
condition|(
name|ht
operator|->
name|used
operator|>=
name|ht
operator|->
name|limit
condition|)
block|{
name|error
operator|=
name|hash_rehash
argument_list|(
name|ht
argument_list|,
name|memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
block|}
name|ht
operator|->
name|used
operator|++
expr_stmt|;
block|}
else|else
name|nn
operator|->
name|data
operator|=
name|data
expr_stmt|;
name|Exit
label|:
return|return
name|error
return|;
block|}
end_function
begin_function
specifier|static
name|hashnode
DECL|function|hash_lookup
name|hash_lookup
parameter_list|(
specifier|const
name|char
modifier|*
name|key
parameter_list|,
name|hashtable
modifier|*
name|ht
parameter_list|)
block|{
name|hashnode
modifier|*
name|np
init|=
name|hash_bucket
argument_list|(
name|key
argument_list|,
name|ht
argument_list|)
decl_stmt|;
return|return
operator|*
name|np
return|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* Utility types and functions.                                          */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/* Function type for parsing lines of a BDF font. */
end_comment
begin_typedef
typedef|typedef
name|FT_Error
function_decl|(
DECL|typedef|_bdf_line_func_t
modifier|*
name|_bdf_line_func_t
function_decl|)
parameter_list|(
name|char
modifier|*
name|line
parameter_list|,
name|unsigned
name|long
name|linelen
parameter_list|,
name|unsigned
name|long
name|lineno
parameter_list|,
name|void
modifier|*
name|call_data
parameter_list|,
name|void
modifier|*
name|client_data
parameter_list|)
function_decl|;
end_typedef
begin_comment
comment|/* List structure for splitting lines into fields. */
end_comment
begin_typedef
DECL|struct|_bdf_list_t_
typedef|typedef
struct|struct
name|_bdf_list_t_
block|{
DECL|member|field
name|char
modifier|*
modifier|*
name|field
decl_stmt|;
DECL|member|size
name|unsigned
name|long
name|size
decl_stmt|;
DECL|member|used
name|unsigned
name|long
name|used
decl_stmt|;
DECL|member|memory
name|FT_Memory
name|memory
decl_stmt|;
block|}
DECL|typedef|_bdf_list_t
name|_bdf_list_t
typedef|;
end_typedef
begin_comment
comment|/* Structure used while loading BDF fonts. */
end_comment
begin_typedef
DECL|struct|_bdf_parse_t_
typedef|typedef
struct|struct
name|_bdf_parse_t_
block|{
DECL|member|flags
name|unsigned
name|long
name|flags
decl_stmt|;
DECL|member|cnt
name|unsigned
name|long
name|cnt
decl_stmt|;
DECL|member|row
name|unsigned
name|long
name|row
decl_stmt|;
DECL|member|minlb
name|short
name|minlb
decl_stmt|;
DECL|member|maxlb
name|short
name|maxlb
decl_stmt|;
DECL|member|maxrb
name|short
name|maxrb
decl_stmt|;
DECL|member|maxas
name|short
name|maxas
decl_stmt|;
DECL|member|maxds
name|short
name|maxds
decl_stmt|;
DECL|member|rbearing
name|short
name|rbearing
decl_stmt|;
DECL|member|glyph_name
name|char
modifier|*
name|glyph_name
decl_stmt|;
DECL|member|glyph_enc
name|long
name|glyph_enc
decl_stmt|;
DECL|member|font
name|bdf_font_t
modifier|*
name|font
decl_stmt|;
DECL|member|opts
name|bdf_options_t
modifier|*
name|opts
decl_stmt|;
DECL|member|have
name|unsigned
name|long
name|have
index|[
literal|2048
index|]
decl_stmt|;
DECL|member|list
name|_bdf_list_t
name|list
decl_stmt|;
DECL|member|memory
name|FT_Memory
name|memory
decl_stmt|;
block|}
DECL|typedef|_bdf_parse_t
name|_bdf_parse_t
typedef|;
end_typedef
begin_define
DECL|macro|setsbit
define|#
directive|define
name|setsbit
parameter_list|(
name|m
parameter_list|,
name|cc
parameter_list|)
define|\
value|( m[(FT_Byte)(cc)>> 3] |= (FT_Byte)( 1<< ( (cc)& 7 ) ) )
end_define
begin_define
DECL|macro|sbitset
define|#
directive|define
name|sbitset
parameter_list|(
name|m
parameter_list|,
name|cc
parameter_list|)
define|\
value|( m[(FT_Byte)(cc)>> 3]& ( 1<< ( (cc)& 7 ) ) )
end_define
begin_function
specifier|static
name|void
DECL|function|_bdf_list_init
name|_bdf_list_init
parameter_list|(
name|_bdf_list_t
modifier|*
name|list
parameter_list|,
name|FT_Memory
name|memory
parameter_list|)
block|{
name|FT_ZERO
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|list
operator|->
name|memory
operator|=
name|memory
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|_bdf_list_done
name|_bdf_list_done
parameter_list|(
name|_bdf_list_t
modifier|*
name|list
parameter_list|)
block|{
name|FT_Memory
name|memory
init|=
name|list
operator|->
name|memory
decl_stmt|;
if|if
condition|(
name|memory
condition|)
block|{
name|FT_FREE
argument_list|(
name|list
operator|->
name|field
argument_list|)
expr_stmt|;
name|FT_ZERO
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|_bdf_list_ensure
name|_bdf_list_ensure
parameter_list|(
name|_bdf_list_t
modifier|*
name|list
parameter_list|,
name|unsigned
name|long
name|num_items
parameter_list|)
comment|/* same as _bdf_list_t.used */
block|{
name|FT_Error
name|error
init|=
name|BDF_Err_Ok
decl_stmt|;
if|if
condition|(
name|num_items
operator|>
name|list
operator|->
name|size
condition|)
block|{
name|unsigned
name|long
name|oldsize
init|=
name|list
operator|->
name|size
decl_stmt|;
comment|/* same as _bdf_list_t.size */
name|unsigned
name|long
name|newsize
init|=
name|oldsize
operator|+
operator|(
name|oldsize
operator|>>
literal|1
operator|)
operator|+
literal|4
decl_stmt|;
name|unsigned
name|long
name|bigsize
init|=
call|(
name|unsigned
name|long
call|)
argument_list|(
name|FT_INT_MAX
operator|/
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|list
operator|->
name|memory
decl_stmt|;
if|if
condition|(
name|oldsize
operator|==
name|bigsize
condition|)
block|{
name|error
operator|=
name|BDF_Err_Out_Of_Memory
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
elseif|else
if|if
condition|(
name|newsize
operator|<
name|oldsize
operator|||
name|newsize
operator|>
name|bigsize
condition|)
name|newsize
operator|=
name|bigsize
expr_stmt|;
if|if
condition|(
name|FT_RENEW_ARRAY
argument_list|(
name|list
operator|->
name|field
argument_list|,
name|oldsize
argument_list|,
name|newsize
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|list
operator|->
name|size
operator|=
name|newsize
expr_stmt|;
block|}
name|Exit
label|:
return|return
name|error
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|_bdf_list_shift
name|_bdf_list_shift
parameter_list|(
name|_bdf_list_t
modifier|*
name|list
parameter_list|,
name|unsigned
name|long
name|n
parameter_list|)
block|{
name|unsigned
name|long
name|i
decl_stmt|,
name|u
decl_stmt|;
if|if
condition|(
name|list
operator|==
literal|0
operator|||
name|list
operator|->
name|used
operator|==
literal|0
operator|||
name|n
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|n
operator|>=
name|list
operator|->
name|used
condition|)
block|{
name|list
operator|->
name|used
operator|=
literal|0
expr_stmt|;
return|return;
block|}
for|for
control|(
name|u
operator|=
name|n
operator|,
name|i
operator|=
literal|0
init|;
name|u
operator|<
name|list
operator|->
name|used
condition|;
name|i
operator|++
operator|,
name|u
operator|++
control|)
name|list
operator|->
name|field
index|[
name|i
index|]
operator|=
name|list
operator|->
name|field
index|[
name|u
index|]
expr_stmt|;
name|list
operator|->
name|used
operator|-=
name|n
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|char
modifier|*
DECL|function|_bdf_list_join
name|_bdf_list_join
parameter_list|(
name|_bdf_list_t
modifier|*
name|list
parameter_list|,
name|int
name|c
parameter_list|,
name|unsigned
name|long
modifier|*
name|alen
parameter_list|)
block|{
name|unsigned
name|long
name|i
decl_stmt|,
name|j
decl_stmt|;
name|char
modifier|*
name|fp
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
operator|*
name|alen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|list
operator|==
literal|0
operator|||
name|list
operator|->
name|used
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|dp
operator|=
name|list
operator|->
name|field
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|list
operator|->
name|used
condition|;
name|i
operator|++
control|)
block|{
name|fp
operator|=
name|list
operator|->
name|field
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|fp
condition|)
name|dp
index|[
name|j
operator|++
index|]
operator|=
operator|*
name|fp
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|+
literal|1
operator|<
name|list
operator|->
name|used
condition|)
name|dp
index|[
name|j
operator|++
index|]
operator|=
operator|(
name|char
operator|)
name|c
expr_stmt|;
block|}
name|dp
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
operator|*
name|alen
operator|=
name|j
expr_stmt|;
return|return
name|dp
return|;
block|}
end_function
begin_comment
comment|/* An empty string for empty fields. */
end_comment
begin_decl_stmt
DECL|variable|empty
specifier|static
specifier|const
name|char
name|empty
index|[
literal|1
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt
begin_comment
DECL|variable|empty
comment|/* XXX eliminate this */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|_bdf_list_split
name|_bdf_list_split
parameter_list|(
name|_bdf_list_t
modifier|*
name|list
parameter_list|,
name|char
modifier|*
name|separators
parameter_list|,
name|char
modifier|*
name|line
parameter_list|,
name|unsigned
name|long
name|linelen
parameter_list|)
block|{
name|int
name|mult
decl_stmt|,
name|final_empty
decl_stmt|;
name|char
modifier|*
name|sp
decl_stmt|,
modifier|*
name|ep
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|char
name|seps
index|[
literal|32
index|]
decl_stmt|;
name|FT_Error
name|error
init|=
name|BDF_Err_Ok
decl_stmt|;
comment|/* Initialize the list. */
name|list
operator|->
name|used
operator|=
literal|0
expr_stmt|;
comment|/* If the line is empty, then simply return. */
if|if
condition|(
name|linelen
operator|==
literal|0
operator|||
name|line
index|[
literal|0
index|]
operator|==
literal|0
condition|)
goto|goto
name|Exit
goto|;
comment|/* In the original code, if the `separators' parameter is NULL or */
comment|/* empty, the list is split into individual bytes.  We don't need */
comment|/* this, so an error is signaled.                                 */
if|if
condition|(
name|separators
operator|==
literal|0
operator|||
operator|*
name|separators
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|BDF_Err_Invalid_Argument
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* Prepare the separator bitmap. */
name|FT_MEM_ZERO
argument_list|(
name|seps
argument_list|,
literal|32
argument_list|)
expr_stmt|;
comment|/* If the very last character of the separator string is a plus, then */
comment|/* set the `mult' flag to indicate that multiple separators should be */
comment|/* collapsed into one.                                                */
for|for
control|(
name|mult
operator|=
literal|0
operator|,
name|sp
operator|=
name|separators
init|;
name|sp
operator|&&
operator|*
name|sp
condition|;
name|sp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|sp
operator|==
literal|'+'
operator|&&
operator|*
operator|(
name|sp
operator|+
literal|1
operator|)
operator|==
literal|0
condition|)
name|mult
operator|=
literal|1
expr_stmt|;
else|else
name|setsbit
argument_list|(
name|seps
argument_list|,
operator|*
name|sp
argument_list|)
expr_stmt|;
block|}
comment|/* Break the line up into fields. */
for|for
control|(
name|final_empty
operator|=
literal|0
operator|,
name|sp
operator|=
name|ep
operator|=
name|line
operator|,
name|end
operator|=
name|sp
operator|+
name|linelen
init|;
name|sp
operator|<
name|end
operator|&&
operator|*
name|sp
condition|;
control|)
block|{
comment|/* Collect everything that is not a separator. */
for|for
control|(
init|;
operator|*
name|ep
operator|&&
operator|!
name|sbitset
argument_list|(
name|seps
argument_list|,
operator|*
name|ep
argument_list|)
condition|;
name|ep
operator|++
control|)
empty_stmt|;
comment|/* Resize the list if necessary. */
if|if
condition|(
name|list
operator|->
name|used
operator|==
name|list
operator|->
name|size
condition|)
block|{
name|error
operator|=
name|_bdf_list_ensure
argument_list|(
name|list
argument_list|,
name|list
operator|->
name|used
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
block|}
comment|/* Assign the field appropriately. */
name|list
operator|->
name|field
index|[
name|list
operator|->
name|used
operator|++
index|]
operator|=
operator|(
name|ep
operator|>
name|sp
operator|)
condition|?
name|sp
else|:
operator|(
name|char
operator|*
operator|)
name|empty
expr_stmt|;
name|sp
operator|=
name|ep
expr_stmt|;
if|if
condition|(
name|mult
condition|)
block|{
comment|/* If multiple separators should be collapsed, do it now by */
comment|/* setting all the separator characters to 0.               */
for|for
control|(
init|;
operator|*
name|ep
operator|&&
name|sbitset
argument_list|(
name|seps
argument_list|,
operator|*
name|ep
argument_list|)
condition|;
name|ep
operator|++
control|)
operator|*
name|ep
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|ep
operator|!=
literal|0
condition|)
comment|/* Don't collapse multiple separators by making them 0, so just */
comment|/* make the one encountered 0.                                  */
operator|*
name|ep
operator|++
operator|=
literal|0
expr_stmt|;
name|final_empty
operator|=
operator|(
name|ep
operator|>
name|sp
operator|&&
operator|*
name|ep
operator|==
literal|0
operator|)
expr_stmt|;
name|sp
operator|=
name|ep
expr_stmt|;
block|}
comment|/* Finally, NULL-terminate the list. */
if|if
condition|(
name|list
operator|->
name|used
operator|+
name|final_empty
operator|>=
name|list
operator|->
name|size
condition|)
block|{
name|error
operator|=
name|_bdf_list_ensure
argument_list|(
name|list
argument_list|,
name|list
operator|->
name|used
operator|+
name|final_empty
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|final_empty
condition|)
name|list
operator|->
name|field
index|[
name|list
operator|->
name|used
operator|++
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|empty
expr_stmt|;
name|list
operator|->
name|field
index|[
name|list
operator|->
name|used
index|]
operator|=
literal|0
expr_stmt|;
name|Exit
label|:
return|return
name|error
return|;
block|}
end_function
begin_define
DECL|macro|NO_SKIP
define|#
directive|define
name|NO_SKIP
value|256
end_define
begin_comment
DECL|macro|NO_SKIP
comment|/* this value cannot be stored in a 'char' */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|_bdf_readstream
name|_bdf_readstream
parameter_list|(
name|FT_Stream
name|stream
parameter_list|,
name|_bdf_line_func_t
name|callback
parameter_list|,
name|void
modifier|*
name|client_data
parameter_list|,
name|unsigned
name|long
modifier|*
name|lno
parameter_list|)
block|{
name|_bdf_line_func_t
name|cb
decl_stmt|;
name|unsigned
name|long
name|lineno
decl_stmt|,
name|buf_size
decl_stmt|;
name|int
name|refill
decl_stmt|,
name|hold
decl_stmt|,
name|to_skip
decl_stmt|;
name|ptrdiff_t
name|bytes
decl_stmt|,
name|start
decl_stmt|,
name|end
decl_stmt|,
name|cursor
decl_stmt|,
name|avail
decl_stmt|;
name|char
modifier|*
name|buf
init|=
literal|0
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|stream
operator|->
name|memory
decl_stmt|;
name|FT_Error
name|error
init|=
name|BDF_Err_Ok
decl_stmt|;
if|if
condition|(
name|callback
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|BDF_Err_Invalid_Argument
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* initial size and allocation of the input buffer */
name|buf_size
operator|=
literal|1024
expr_stmt|;
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|buf
argument_list|,
name|buf_size
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|cb
operator|=
name|callback
expr_stmt|;
name|lineno
operator|=
literal|1
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|start
operator|=
literal|0
expr_stmt|;
name|end
operator|=
literal|0
expr_stmt|;
name|avail
operator|=
literal|0
expr_stmt|;
name|cursor
operator|=
literal|0
expr_stmt|;
name|refill
operator|=
literal|1
expr_stmt|;
name|to_skip
operator|=
name|NO_SKIP
expr_stmt|;
name|bytes
operator|=
literal|0
expr_stmt|;
comment|/* make compiler happy */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|refill
condition|)
block|{
name|bytes
operator|=
operator|(
name|ptrdiff_t
operator|)
name|FT_Stream_TryRead
argument_list|(
name|stream
argument_list|,
operator|(
name|FT_Byte
operator|*
operator|)
name|buf
operator|+
name|cursor
argument_list|,
call|(
name|FT_ULong
call|)
argument_list|(
name|buf_size
operator|-
name|cursor
argument_list|)
argument_list|)
expr_stmt|;
name|avail
operator|=
name|cursor
operator|+
name|bytes
expr_stmt|;
name|cursor
operator|=
literal|0
expr_stmt|;
name|refill
operator|=
literal|0
expr_stmt|;
block|}
name|end
operator|=
name|start
expr_stmt|;
comment|/* should we skip an optional character like \n or \r? */
if|if
condition|(
name|start
operator|<
name|avail
operator|&&
name|buf
index|[
name|start
index|]
operator|==
name|to_skip
condition|)
block|{
name|start
operator|+=
literal|1
expr_stmt|;
name|to_skip
operator|=
name|NO_SKIP
expr_stmt|;
continue|continue;
block|}
comment|/* try to find the end of the line */
while|while
condition|(
name|end
operator|<
name|avail
operator|&&
name|buf
index|[
name|end
index|]
operator|!=
literal|'\n'
operator|&&
name|buf
index|[
name|end
index|]
operator|!=
literal|'\r'
condition|)
name|end
operator|++
expr_stmt|;
comment|/* if we hit the end of the buffer, try shifting its content */
comment|/* or even resizing it                                       */
if|if
condition|(
name|end
operator|>=
name|avail
condition|)
block|{
if|if
condition|(
name|bytes
operator|==
literal|0
condition|)
comment|/* last line in file doesn't end in \r or \n */
break|break;
comment|/* ignore it then exit                       */
if|if
condition|(
name|start
operator|==
literal|0
condition|)
block|{
comment|/* this line is definitely too long; try resizing the input */
comment|/* buffer a bit to handle it.                               */
name|FT_ULong
name|new_size
decl_stmt|;
if|if
condition|(
name|buf_size
operator|>=
literal|65536UL
condition|)
comment|/* limit ourselves to 64KByte */
block|{
name|error
operator|=
name|BDF_Err_Invalid_Argument
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|new_size
operator|=
name|buf_size
operator|*
literal|2
expr_stmt|;
if|if
condition|(
name|FT_RENEW_ARRAY
argument_list|(
name|buf
argument_list|,
name|buf_size
argument_list|,
name|new_size
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|cursor
operator|=
name|buf_size
expr_stmt|;
name|buf_size
operator|=
name|new_size
expr_stmt|;
block|}
else|else
block|{
name|bytes
operator|=
name|avail
operator|-
name|start
expr_stmt|;
name|FT_MEM_COPY
argument_list|(
name|buf
argument_list|,
name|buf
operator|+
name|start
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
name|cursor
operator|=
name|bytes
expr_stmt|;
name|avail
operator|-=
name|bytes
expr_stmt|;
name|start
operator|=
literal|0
expr_stmt|;
block|}
name|refill
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
comment|/* Temporarily NUL-terminate the line. */
name|hold
operator|=
name|buf
index|[
name|end
index|]
expr_stmt|;
name|buf
index|[
name|end
index|]
operator|=
literal|0
expr_stmt|;
comment|/* XXX: Use encoding independent value for 0x1a */
if|if
condition|(
name|buf
index|[
name|start
index|]
operator|!=
literal|'#'
operator|&&
name|buf
index|[
name|start
index|]
operator|!=
literal|0x1a
operator|&&
name|end
operator|>
name|start
condition|)
block|{
name|error
operator|=
call|(
modifier|*
name|cb
call|)
argument_list|(
name|buf
operator|+
name|start
argument_list|,
name|end
operator|-
name|start
argument_list|,
name|lineno
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|cb
argument_list|,
name|client_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
name|lineno
operator|+=
literal|1
expr_stmt|;
name|buf
index|[
name|end
index|]
operator|=
operator|(
name|char
operator|)
name|hold
expr_stmt|;
name|start
operator|=
name|end
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|hold
operator|==
literal|'\n'
condition|)
name|to_skip
operator|=
literal|'\r'
expr_stmt|;
elseif|else
if|if
condition|(
name|hold
operator|==
literal|'\r'
condition|)
name|to_skip
operator|=
literal|'\n'
expr_stmt|;
else|else
name|to_skip
operator|=
name|NO_SKIP
expr_stmt|;
block|}
operator|*
name|lno
operator|=
name|lineno
expr_stmt|;
name|Exit
label|:
name|FT_FREE
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_comment
comment|/* XXX: make this work with EBCDIC also */
end_comment
begin_decl_stmt
DECL|variable|a2i
specifier|static
specifier|const
name|unsigned
name|char
name|a2i
index|[
literal|128
index|]
init|=
block|{
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x01
block|,
literal|0x02
block|,
literal|0x03
block|,
literal|0x04
block|,
literal|0x05
block|,
literal|0x06
block|,
literal|0x07
block|,
literal|0x08
block|,
literal|0x09
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x0a
block|,
literal|0x0b
block|,
literal|0x0c
block|,
literal|0x0d
block|,
literal|0x0e
block|,
literal|0x0f
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x0a
block|,
literal|0x0b
block|,
literal|0x0c
block|,
literal|0x0d
block|,
literal|0x0e
block|,
literal|0x0f
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|odigits
specifier|static
specifier|const
name|unsigned
name|char
name|odigits
index|[
literal|32
index|]
init|=
block|{
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0xff
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,   }
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|ddigits
specifier|static
specifier|const
name|unsigned
name|char
name|ddigits
index|[
literal|32
index|]
init|=
block|{
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0xff
block|,
literal|0x03
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,   }
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|hdigits
specifier|static
specifier|const
name|unsigned
name|char
name|hdigits
index|[
literal|32
index|]
init|=
block|{
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0xff
block|,
literal|0x03
block|,
literal|0x7e
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x7e
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,   }
decl_stmt|;
end_decl_stmt
begin_define
DECL|macro|isdigok
define|#
directive|define
name|isdigok
parameter_list|(
name|m
parameter_list|,
name|d
parameter_list|)
value|(m[(d)>> 3]& ( 1<< ( (d)& 7 ) ) )
end_define
begin_comment
comment|/* Routine to convert an ASCII string into an unsigned long integer. */
end_comment
begin_function
specifier|static
name|unsigned
name|long
DECL|function|_bdf_atoul
name|_bdf_atoul
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|char
modifier|*
modifier|*
name|end
parameter_list|,
name|int
name|base
parameter_list|)
block|{
name|unsigned
name|long
name|v
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|dmap
decl_stmt|;
if|if
condition|(
name|s
operator|==
literal|0
operator|||
operator|*
name|s
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Make sure the radix is something recognizable.  Default to 10. */
switch|switch
condition|(
name|base
condition|)
block|{
case|case
literal|8
case|:
name|dmap
operator|=
name|odigits
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|dmap
operator|=
name|hdigits
expr_stmt|;
break|break;
default|default:
name|base
operator|=
literal|10
expr_stmt|;
name|dmap
operator|=
name|ddigits
expr_stmt|;
break|break;
block|}
comment|/* Check for the special hex prefix. */
if|if
condition|(
operator|*
name|s
operator|==
literal|'0'
operator|&&
operator|(
operator|*
operator|(
name|s
operator|+
literal|1
operator|)
operator|==
literal|'x'
operator|||
operator|*
operator|(
name|s
operator|+
literal|1
operator|)
operator|==
literal|'X'
operator|)
condition|)
block|{
name|base
operator|=
literal|16
expr_stmt|;
name|dmap
operator|=
name|hdigits
expr_stmt|;
name|s
operator|+=
literal|2
expr_stmt|;
block|}
for|for
control|(
name|v
operator|=
literal|0
init|;
name|isdigok
argument_list|(
name|dmap
argument_list|,
operator|*
name|s
argument_list|)
condition|;
name|s
operator|++
control|)
name|v
operator|=
name|v
operator|*
name|base
operator|+
name|a2i
index|[
operator|(
name|int
operator|)
operator|*
name|s
index|]
expr_stmt|;
if|if
condition|(
name|end
operator|!=
literal|0
condition|)
operator|*
name|end
operator|=
name|s
expr_stmt|;
return|return
name|v
return|;
block|}
end_function
begin_comment
comment|/* Routine to convert an ASCII string into an signed long integer. */
end_comment
begin_function
specifier|static
name|long
DECL|function|_bdf_atol
name|_bdf_atol
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|char
modifier|*
modifier|*
name|end
parameter_list|,
name|int
name|base
parameter_list|)
block|{
name|long
name|v
decl_stmt|,
name|neg
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|dmap
decl_stmt|;
if|if
condition|(
name|s
operator|==
literal|0
operator|||
operator|*
name|s
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Make sure the radix is something recognizable.  Default to 10. */
switch|switch
condition|(
name|base
condition|)
block|{
case|case
literal|8
case|:
name|dmap
operator|=
name|odigits
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|dmap
operator|=
name|hdigits
expr_stmt|;
break|break;
default|default:
name|base
operator|=
literal|10
expr_stmt|;
name|dmap
operator|=
name|ddigits
expr_stmt|;
break|break;
block|}
comment|/* Check for a minus sign. */
name|neg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'-'
condition|)
block|{
name|s
operator|++
expr_stmt|;
name|neg
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Check for the special hex prefix. */
if|if
condition|(
operator|*
name|s
operator|==
literal|'0'
operator|&&
operator|(
operator|*
operator|(
name|s
operator|+
literal|1
operator|)
operator|==
literal|'x'
operator|||
operator|*
operator|(
name|s
operator|+
literal|1
operator|)
operator|==
literal|'X'
operator|)
condition|)
block|{
name|base
operator|=
literal|16
expr_stmt|;
name|dmap
operator|=
name|hdigits
expr_stmt|;
name|s
operator|+=
literal|2
expr_stmt|;
block|}
for|for
control|(
name|v
operator|=
literal|0
init|;
name|isdigok
argument_list|(
name|dmap
argument_list|,
operator|*
name|s
argument_list|)
condition|;
name|s
operator|++
control|)
name|v
operator|=
name|v
operator|*
name|base
operator|+
name|a2i
index|[
operator|(
name|int
operator|)
operator|*
name|s
index|]
expr_stmt|;
if|if
condition|(
name|end
operator|!=
literal|0
condition|)
operator|*
name|end
operator|=
name|s
expr_stmt|;
return|return
operator|(
operator|!
name|neg
operator|)
condition|?
name|v
else|:
operator|-
name|v
return|;
block|}
end_function
begin_comment
comment|/* Routine to convert an ASCII string into an signed short integer. */
end_comment
begin_function
specifier|static
name|short
DECL|function|_bdf_atos
name|_bdf_atos
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|char
modifier|*
modifier|*
name|end
parameter_list|,
name|int
name|base
parameter_list|)
block|{
name|short
name|v
decl_stmt|,
name|neg
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|dmap
decl_stmt|;
if|if
condition|(
name|s
operator|==
literal|0
operator|||
operator|*
name|s
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Make sure the radix is something recognizable.  Default to 10. */
switch|switch
condition|(
name|base
condition|)
block|{
case|case
literal|8
case|:
name|dmap
operator|=
name|odigits
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|dmap
operator|=
name|hdigits
expr_stmt|;
break|break;
default|default:
name|base
operator|=
literal|10
expr_stmt|;
name|dmap
operator|=
name|ddigits
expr_stmt|;
break|break;
block|}
comment|/* Check for a minus. */
name|neg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'-'
condition|)
block|{
name|s
operator|++
expr_stmt|;
name|neg
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Check for the special hex prefix. */
if|if
condition|(
operator|*
name|s
operator|==
literal|'0'
operator|&&
operator|(
operator|*
operator|(
name|s
operator|+
literal|1
operator|)
operator|==
literal|'x'
operator|||
operator|*
operator|(
name|s
operator|+
literal|1
operator|)
operator|==
literal|'X'
operator|)
condition|)
block|{
name|base
operator|=
literal|16
expr_stmt|;
name|dmap
operator|=
name|hdigits
expr_stmt|;
name|s
operator|+=
literal|2
expr_stmt|;
block|}
for|for
control|(
name|v
operator|=
literal|0
init|;
name|isdigok
argument_list|(
name|dmap
argument_list|,
operator|*
name|s
argument_list|)
condition|;
name|s
operator|++
control|)
name|v
operator|=
call|(
name|short
call|)
argument_list|(
name|v
operator|*
name|base
operator|+
name|a2i
index|[
operator|(
name|int
operator|)
operator|*
name|s
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
operator|!=
literal|0
condition|)
operator|*
name|end
operator|=
name|s
expr_stmt|;
return|return
call|(
name|short
call|)
argument_list|(
operator|(
operator|!
name|neg
operator|)
condition|?
name|v
else|:
operator|-
name|v
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/* Routine to compare two glyphs by encoding so they can be sorted. */
end_comment
begin_function
specifier|static
name|int
DECL|function|by_encoding
name|by_encoding
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
name|bdf_glyph_t
modifier|*
name|c1
decl_stmt|,
modifier|*
name|c2
decl_stmt|;
name|c1
operator|=
operator|(
name|bdf_glyph_t
operator|*
operator|)
name|a
expr_stmt|;
name|c2
operator|=
operator|(
name|bdf_glyph_t
operator|*
operator|)
name|b
expr_stmt|;
if|if
condition|(
name|c1
operator|->
name|encoding
operator|<
name|c2
operator|->
name|encoding
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|c1
operator|->
name|encoding
operator|>
name|c2
operator|->
name|encoding
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|bdf_create_property
name|bdf_create_property
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|format
parameter_list|,
name|bdf_font_t
modifier|*
name|font
parameter_list|)
block|{
name|size_t
name|n
decl_stmt|;
name|bdf_property_t
modifier|*
name|p
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|font
operator|->
name|memory
decl_stmt|;
name|FT_Error
name|error
init|=
name|BDF_Err_Ok
decl_stmt|;
comment|/* First check to see if the property has      */
comment|/* already been added or not.  If it has, then */
comment|/* simply ignore it.                           */
if|if
condition|(
name|hash_lookup
argument_list|(
name|name
argument_list|,
operator|&
operator|(
name|font
operator|->
name|proptbl
operator|)
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
if|if
condition|(
name|FT_RENEW_ARRAY
argument_list|(
name|font
operator|->
name|user_props
argument_list|,
name|font
operator|->
name|nuser_props
argument_list|,
name|font
operator|->
name|nuser_props
operator|+
literal|1
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|p
operator|=
name|font
operator|->
name|user_props
operator|+
name|font
operator|->
name|nuser_props
expr_stmt|;
name|FT_ZERO
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|n
operator|=
name|ft_strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|FT_ULONG_MAX
condition|)
return|return
name|BDF_Err_Invalid_Argument
return|;
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|p
operator|->
name|name
argument_list|,
name|n
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|FT_MEM_COPY
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
operator|->
name|name
argument_list|,
name|name
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|p
operator|->
name|format
operator|=
name|format
expr_stmt|;
name|p
operator|->
name|builtin
operator|=
literal|0
expr_stmt|;
name|n
operator|=
name|_num_bdf_properties
operator|+
name|font
operator|->
name|nuser_props
expr_stmt|;
name|error
operator|=
name|hash_insert
argument_list|(
name|p
operator|->
name|name
argument_list|,
name|n
argument_list|,
operator|&
operator|(
name|font
operator|->
name|proptbl
operator|)
argument_list|,
name|memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|font
operator|->
name|nuser_props
operator|++
expr_stmt|;
name|Exit
label|:
return|return
name|error
return|;
block|}
end_function
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|bdf_property_t *
argument_list|)
end_macro
begin_macro
DECL|function|bdf_get_property
name|bdf_get_property
argument_list|(
argument|char*        name
argument_list|,
argument|bdf_font_t*  font
argument_list|)
end_macro
begin_block
block|{
name|hashnode
name|hn
decl_stmt|;
name|size_t
name|propid
decl_stmt|;
if|if
condition|(
name|name
operator|==
literal|0
operator|||
operator|*
name|name
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|hn
operator|=
name|hash_lookup
argument_list|(
name|name
argument_list|,
operator|&
operator|(
name|font
operator|->
name|proptbl
operator|)
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|propid
operator|=
name|hn
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|propid
operator|>=
name|_num_bdf_properties
condition|)
return|return
name|font
operator|->
name|user_props
operator|+
operator|(
name|propid
operator|-
name|_num_bdf_properties
operator|)
return|;
return|return
operator|(
name|bdf_property_t
operator|*
operator|)
name|_bdf_properties
operator|+
name|propid
return|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* BDF font file parsing flags and functions.                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/* Parse flags. */
end_comment
begin_define
DECL|macro|_BDF_START
define|#
directive|define
name|_BDF_START
value|0x0001
end_define
begin_define
DECL|macro|_BDF_FONT_NAME
define|#
directive|define
name|_BDF_FONT_NAME
value|0x0002
end_define
begin_define
DECL|macro|_BDF_SIZE
define|#
directive|define
name|_BDF_SIZE
value|0x0004
end_define
begin_define
DECL|macro|_BDF_FONT_BBX
define|#
directive|define
name|_BDF_FONT_BBX
value|0x0008
end_define
begin_define
DECL|macro|_BDF_PROPS
define|#
directive|define
name|_BDF_PROPS
value|0x0010
end_define
begin_define
DECL|macro|_BDF_GLYPHS
define|#
directive|define
name|_BDF_GLYPHS
value|0x0020
end_define
begin_define
DECL|macro|_BDF_GLYPH
define|#
directive|define
name|_BDF_GLYPH
value|0x0040
end_define
begin_define
DECL|macro|_BDF_ENCODING
define|#
directive|define
name|_BDF_ENCODING
value|0x0080
end_define
begin_define
DECL|macro|_BDF_SWIDTH
define|#
directive|define
name|_BDF_SWIDTH
value|0x0100
end_define
begin_define
DECL|macro|_BDF_DWIDTH
define|#
directive|define
name|_BDF_DWIDTH
value|0x0200
end_define
begin_define
DECL|macro|_BDF_BBX
define|#
directive|define
name|_BDF_BBX
value|0x0400
end_define
begin_define
DECL|macro|_BDF_BITMAP
define|#
directive|define
name|_BDF_BITMAP
value|0x0800
end_define
begin_define
DECL|macro|_BDF_SWIDTH_ADJ
define|#
directive|define
name|_BDF_SWIDTH_ADJ
value|0x1000
end_define
begin_define
DECL|macro|_BDF_GLYPH_BITS
define|#
directive|define
name|_BDF_GLYPH_BITS
value|( _BDF_GLYPH    | \                           _BDF_ENCODING | \                           _BDF_SWIDTH   | \                           _BDF_DWIDTH   | \                           _BDF_BBX      | \                           _BDF_BITMAP   )
end_define
begin_define
DECL|macro|_BDF_GLYPH_WIDTH_CHECK
define|#
directive|define
name|_BDF_GLYPH_WIDTH_CHECK
value|0x40000000UL
end_define
begin_define
DECL|macro|_BDF_GLYPH_HEIGHT_CHECK
define|#
directive|define
name|_BDF_GLYPH_HEIGHT_CHECK
value|0x80000000UL
end_define
begin_comment
comment|/* Auto correction messages. */
end_comment
begin_define
DECL|macro|ACMSG1
define|#
directive|define
name|ACMSG1
value|"FONT_ASCENT property missing.  " \                  "Added \"FONT_ASCENT %hd\".\n"
end_define
begin_define
DECL|macro|ACMSG2
define|#
directive|define
name|ACMSG2
value|"FONT_DESCENT property missing.  " \                  "Added \"FONT_DESCENT %hd\".\n"
end_define
begin_define
DECL|macro|ACMSG3
define|#
directive|define
name|ACMSG3
value|"Font width != actual width.  Old: %hd New: %hd.\n"
end_define
begin_define
DECL|macro|ACMSG4
define|#
directive|define
name|ACMSG4
value|"Font left bearing != actual left bearing.  " \                  "Old: %hd New: %hd.\n"
end_define
begin_define
DECL|macro|ACMSG5
define|#
directive|define
name|ACMSG5
value|"Font ascent != actual ascent.  Old: %hd New: %hd.\n"
end_define
begin_define
DECL|macro|ACMSG6
define|#
directive|define
name|ACMSG6
value|"Font descent != actual descent.  Old: %hd New: %hd.\n"
end_define
begin_define
DECL|macro|ACMSG7
define|#
directive|define
name|ACMSG7
value|"Font height != actual height. Old: %hd New: %hd.\n"
end_define
begin_define
DECL|macro|ACMSG8
define|#
directive|define
name|ACMSG8
value|"Glyph scalable width (SWIDTH) adjustments made.\n"
end_define
begin_define
DECL|macro|ACMSG9
define|#
directive|define
name|ACMSG9
value|"SWIDTH field missing at line %ld.  Set automatically.\n"
end_define
begin_define
DECL|macro|ACMSG10
define|#
directive|define
name|ACMSG10
value|"DWIDTH field missing at line %ld.  Set to glyph width.\n"
end_define
begin_define
DECL|macro|ACMSG11
define|#
directive|define
name|ACMSG11
value|"SIZE bits per pixel field adjusted to %hd.\n"
end_define
begin_define
DECL|macro|ACMSG12
define|#
directive|define
name|ACMSG12
value|"Duplicate encoding %ld (%s) changed to unencoded.\n"
end_define
begin_define
DECL|macro|ACMSG13
define|#
directive|define
name|ACMSG13
value|"Glyph %ld extra rows removed.\n"
end_define
begin_define
DECL|macro|ACMSG14
define|#
directive|define
name|ACMSG14
value|"Glyph %ld extra columns removed.\n"
end_define
begin_define
DECL|macro|ACMSG15
define|#
directive|define
name|ACMSG15
value|"Incorrect glyph count: %ld indicated but %ld found.\n"
end_define
begin_comment
comment|/* Error messages. */
end_comment
begin_define
DECL|macro|ERRMSG1
define|#
directive|define
name|ERRMSG1
value|"[line %ld] Missing \"%s\" line.\n"
end_define
begin_define
DECL|macro|ERRMSG2
define|#
directive|define
name|ERRMSG2
value|"[line %ld] Font header corrupted or missing fields.\n"
end_define
begin_define
DECL|macro|ERRMSG3
define|#
directive|define
name|ERRMSG3
value|"[line %ld] Font glyphs corrupted or missing fields.\n"
end_define
begin_define
DECL|macro|ERRMSG4
define|#
directive|define
name|ERRMSG4
value|"[line %ld] BBX too big.\n"
end_define
begin_function
specifier|static
name|FT_Error
DECL|function|_bdf_add_comment
name|_bdf_add_comment
parameter_list|(
name|bdf_font_t
modifier|*
name|font
parameter_list|,
name|char
modifier|*
name|comment
parameter_list|,
name|unsigned
name|long
name|len
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|font
operator|->
name|memory
decl_stmt|;
name|FT_Error
name|error
init|=
name|BDF_Err_Ok
decl_stmt|;
if|if
condition|(
name|FT_RENEW_ARRAY
argument_list|(
name|font
operator|->
name|comments
argument_list|,
name|font
operator|->
name|comments_len
argument_list|,
name|font
operator|->
name|comments_len
operator|+
name|len
operator|+
literal|1
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|cp
operator|=
name|font
operator|->
name|comments
operator|+
name|font
operator|->
name|comments_len
expr_stmt|;
name|FT_MEM_COPY
argument_list|(
name|cp
argument_list|,
name|comment
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|cp
index|[
name|len
index|]
operator|=
literal|'\n'
expr_stmt|;
name|font
operator|->
name|comments_len
operator|+=
name|len
operator|+
literal|1
expr_stmt|;
name|Exit
label|:
return|return
name|error
return|;
block|}
end_function
begin_comment
comment|/* Set the spacing from the font name if it exists, or set it to the */
end_comment
begin_comment
comment|/* default specified in the options.                                 */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|_bdf_set_default_spacing
name|_bdf_set_default_spacing
parameter_list|(
name|bdf_font_t
modifier|*
name|font
parameter_list|,
name|bdf_options_t
modifier|*
name|opts
parameter_list|)
block|{
name|size_t
name|len
decl_stmt|;
name|char
name|name
index|[
literal|256
index|]
decl_stmt|;
name|_bdf_list_t
name|list
decl_stmt|;
name|FT_Memory
name|memory
decl_stmt|;
name|FT_Error
name|error
init|=
name|BDF_Err_Ok
decl_stmt|;
if|if
condition|(
name|font
operator|==
literal|0
operator|||
name|font
operator|->
name|name
operator|==
literal|0
operator|||
name|font
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|BDF_Err_Invalid_Argument
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|memory
operator|=
name|font
operator|->
name|memory
expr_stmt|;
name|_bdf_list_init
argument_list|(
operator|&
name|list
argument_list|,
name|memory
argument_list|)
expr_stmt|;
name|font
operator|->
name|spacing
operator|=
name|opts
operator|->
name|font_spacing
expr_stmt|;
name|len
operator|=
name|ft_strlen
argument_list|(
name|font
operator|->
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* Limit ourselves to 256 characters in the font name. */
if|if
condition|(
name|len
operator|>=
literal|256
condition|)
block|{
name|error
operator|=
name|BDF_Err_Invalid_Argument
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|FT_MEM_COPY
argument_list|(
name|name
argument_list|,
name|font
operator|->
name|name
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|error
operator|=
name|_bdf_list_split
argument_list|(
operator|&
name|list
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|"-"
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Fail
goto|;
if|if
condition|(
name|list
operator|.
name|used
operator|==
literal|15
condition|)
block|{
switch|switch
condition|(
name|list
operator|.
name|field
index|[
literal|11
index|]
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'C'
case|:
case|case
literal|'c'
case|:
name|font
operator|->
name|spacing
operator|=
name|BDF_CHARCELL
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
case|case
literal|'m'
case|:
name|font
operator|->
name|spacing
operator|=
name|BDF_MONOWIDTH
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
case|case
literal|'p'
case|:
name|font
operator|->
name|spacing
operator|=
name|BDF_PROPORTIONAL
expr_stmt|;
break|break;
block|}
block|}
name|Fail
label|:
name|_bdf_list_done
argument_list|(
operator|&
name|list
argument_list|)
expr_stmt|;
name|Exit
label|:
return|return
name|error
return|;
block|}
end_function
begin_comment
comment|/* Determine whether the property is an atom or not.  If it is, then */
end_comment
begin_comment
comment|/* clean it up so the double quotes are removed if they exist.       */
end_comment
begin_function
specifier|static
name|int
DECL|function|_bdf_is_atom
name|_bdf_is_atom
parameter_list|(
name|char
modifier|*
name|line
parameter_list|,
name|unsigned
name|long
name|linelen
parameter_list|,
name|char
modifier|*
modifier|*
name|name
parameter_list|,
name|char
modifier|*
modifier|*
name|value
parameter_list|,
name|bdf_font_t
modifier|*
name|font
parameter_list|)
block|{
name|int
name|hold
decl_stmt|;
name|char
modifier|*
name|sp
decl_stmt|,
modifier|*
name|ep
decl_stmt|;
name|bdf_property_t
modifier|*
name|p
decl_stmt|;
operator|*
name|name
operator|=
name|sp
operator|=
name|ep
operator|=
name|line
expr_stmt|;
while|while
condition|(
operator|*
name|ep
operator|&&
operator|*
name|ep
operator|!=
literal|' '
operator|&&
operator|*
name|ep
operator|!=
literal|'\t'
condition|)
name|ep
operator|++
expr_stmt|;
name|hold
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|ep
condition|)
block|{
name|hold
operator|=
operator|*
name|ep
expr_stmt|;
operator|*
name|ep
operator|=
literal|0
expr_stmt|;
block|}
name|p
operator|=
name|bdf_get_property
argument_list|(
name|sp
argument_list|,
name|font
argument_list|)
expr_stmt|;
comment|/* Restore the character that was saved before any return can happen. */
if|if
condition|(
name|hold
operator|!=
operator|-
literal|1
condition|)
operator|*
name|ep
operator|=
operator|(
name|char
operator|)
name|hold
expr_stmt|;
comment|/* If the property exists and is not an atom, just return here. */
if|if
condition|(
name|p
operator|&&
name|p
operator|->
name|format
operator|!=
name|BDF_ATOM
condition|)
return|return
literal|0
return|;
comment|/* The property is an atom.  Trim all leading and trailing whitespace */
comment|/* and double quotes for the atom value.                              */
name|sp
operator|=
name|ep
expr_stmt|;
name|ep
operator|=
name|line
operator|+
name|linelen
expr_stmt|;
comment|/* Trim the leading whitespace if it exists. */
operator|*
name|sp
operator|++
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|sp
operator|&&
operator|(
operator|*
name|sp
operator|==
literal|' '
operator|||
operator|*
name|sp
operator|==
literal|'\t'
operator|)
condition|)
name|sp
operator|++
expr_stmt|;
comment|/* Trim the leading double quote if it exists. */
if|if
condition|(
operator|*
name|sp
operator|==
literal|'"'
condition|)
name|sp
operator|++
expr_stmt|;
operator|*
name|value
operator|=
name|sp
expr_stmt|;
comment|/* Trim the trailing whitespace if it exists. */
while|while
condition|(
name|ep
operator|>
name|sp
operator|&&
operator|(
operator|*
operator|(
name|ep
operator|-
literal|1
operator|)
operator|==
literal|' '
operator|||
operator|*
operator|(
name|ep
operator|-
literal|1
operator|)
operator|==
literal|'\t'
operator|)
condition|)
operator|*
operator|--
name|ep
operator|=
literal|0
expr_stmt|;
comment|/* Trim the trailing double quote if it exists. */
if|if
condition|(
name|ep
operator|>
name|sp
operator|&&
operator|*
operator|(
name|ep
operator|-
literal|1
operator|)
operator|==
literal|'"'
condition|)
operator|*
operator|--
name|ep
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|_bdf_add_property
name|_bdf_add_property
parameter_list|(
name|bdf_font_t
modifier|*
name|font
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|value
parameter_list|)
block|{
name|size_t
name|propid
decl_stmt|;
name|hashnode
name|hn
decl_stmt|;
name|bdf_property_t
modifier|*
name|prop
decl_stmt|,
modifier|*
name|fp
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|font
operator|->
name|memory
decl_stmt|;
name|FT_Error
name|error
init|=
name|BDF_Err_Ok
decl_stmt|;
comment|/* First, check to see if the property already exists in the font. */
if|if
condition|(
operator|(
name|hn
operator|=
name|hash_lookup
argument_list|(
name|name
argument_list|,
operator|(
name|hashtable
operator|*
operator|)
name|font
operator|->
name|internal
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* The property already exists in the font, so simply replace */
comment|/* the value of the property with the current value.          */
name|fp
operator|=
name|font
operator|->
name|props
operator|+
name|hn
operator|->
name|data
expr_stmt|;
switch|switch
condition|(
name|fp
operator|->
name|format
condition|)
block|{
case|case
name|BDF_ATOM
case|:
comment|/* Delete the current atom if it exists. */
name|FT_FREE
argument_list|(
name|fp
operator|->
name|value
operator|.
name|atom
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|&&
name|value
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|FT_STRDUP
argument_list|(
name|fp
operator|->
name|value
operator|.
name|atom
argument_list|,
name|value
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
block|}
break|break;
case|case
name|BDF_INTEGER
case|:
name|fp
operator|->
name|value
operator|.
name|l
operator|=
name|_bdf_atol
argument_list|(
name|value
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|)
expr_stmt|;
break|break;
case|case
name|BDF_CARDINAL
case|:
name|fp
operator|->
name|value
operator|.
name|ul
operator|=
name|_bdf_atoul
argument_list|(
name|value
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|)
expr_stmt|;
break|break;
default|default:
empty_stmt|;
block|}
goto|goto
name|Exit
goto|;
block|}
comment|/* See whether this property type exists yet or not. */
comment|/* If not, create it.                                */
name|hn
operator|=
name|hash_lookup
argument_list|(
name|name
argument_list|,
operator|&
operator|(
name|font
operator|->
name|proptbl
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hn
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|bdf_create_property
argument_list|(
name|name
argument_list|,
name|BDF_ATOM
argument_list|,
name|font
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|hn
operator|=
name|hash_lookup
argument_list|(
name|name
argument_list|,
operator|&
operator|(
name|font
operator|->
name|proptbl
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Allocate another property if this is overflow. */
if|if
condition|(
name|font
operator|->
name|props_used
operator|==
name|font
operator|->
name|props_size
condition|)
block|{
if|if
condition|(
name|font
operator|->
name|props_size
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|font
operator|->
name|props
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
block|}
else|else
block|{
if|if
condition|(
name|FT_RENEW_ARRAY
argument_list|(
name|font
operator|->
name|props
argument_list|,
name|font
operator|->
name|props_size
argument_list|,
name|font
operator|->
name|props_size
operator|+
literal|1
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
block|}
name|fp
operator|=
name|font
operator|->
name|props
operator|+
name|font
operator|->
name|props_size
expr_stmt|;
name|FT_MEM_ZERO
argument_list|(
name|fp
argument_list|,
sizeof|sizeof
argument_list|(
name|bdf_property_t
argument_list|)
argument_list|)
expr_stmt|;
name|font
operator|->
name|props_size
operator|++
expr_stmt|;
block|}
name|propid
operator|=
name|hn
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|propid
operator|>=
name|_num_bdf_properties
condition|)
name|prop
operator|=
name|font
operator|->
name|user_props
operator|+
operator|(
name|propid
operator|-
name|_num_bdf_properties
operator|)
expr_stmt|;
else|else
name|prop
operator|=
operator|(
name|bdf_property_t
operator|*
operator|)
name|_bdf_properties
operator|+
name|propid
expr_stmt|;
name|fp
operator|=
name|font
operator|->
name|props
operator|+
name|font
operator|->
name|props_used
expr_stmt|;
name|fp
operator|->
name|name
operator|=
name|prop
operator|->
name|name
expr_stmt|;
name|fp
operator|->
name|format
operator|=
name|prop
operator|->
name|format
expr_stmt|;
name|fp
operator|->
name|builtin
operator|=
name|prop
operator|->
name|builtin
expr_stmt|;
switch|switch
condition|(
name|prop
operator|->
name|format
condition|)
block|{
case|case
name|BDF_ATOM
case|:
name|fp
operator|->
name|value
operator|.
name|atom
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|0
operator|&&
name|value
index|[
literal|0
index|]
condition|)
block|{
if|if
condition|(
name|FT_STRDUP
argument_list|(
name|fp
operator|->
name|value
operator|.
name|atom
argument_list|,
name|value
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
block|}
break|break;
case|case
name|BDF_INTEGER
case|:
name|fp
operator|->
name|value
operator|.
name|l
operator|=
name|_bdf_atol
argument_list|(
name|value
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|)
expr_stmt|;
break|break;
case|case
name|BDF_CARDINAL
case|:
name|fp
operator|->
name|value
operator|.
name|ul
operator|=
name|_bdf_atoul
argument_list|(
name|value
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* If the property happens to be a comment, then it doesn't need */
comment|/* to be added to the internal hash table.                       */
if|if
condition|(
name|ft_memcmp
argument_list|(
name|name
argument_list|,
literal|"COMMENT"
argument_list|,
literal|7
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Add the property to the font property table. */
name|error
operator|=
name|hash_insert
argument_list|(
name|fp
operator|->
name|name
argument_list|,
name|font
operator|->
name|props_used
argument_list|,
operator|(
name|hashtable
operator|*
operator|)
name|font
operator|->
name|internal
argument_list|,
name|memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
block|}
name|font
operator|->
name|props_used
operator|++
expr_stmt|;
comment|/* Some special cases need to be handled here.  The DEFAULT_CHAR       */
comment|/* property needs to be located if it exists in the property list, the */
comment|/* FONT_ASCENT and FONT_DESCENT need to be assigned if they are        */
comment|/* present, and the SPACING property should override the default       */
comment|/* spacing.                                                            */
if|if
condition|(
name|ft_memcmp
argument_list|(
name|name
argument_list|,
literal|"DEFAULT_CHAR"
argument_list|,
literal|12
argument_list|)
operator|==
literal|0
condition|)
name|font
operator|->
name|default_char
operator|=
name|fp
operator|->
name|value
operator|.
name|l
expr_stmt|;
elseif|else
if|if
condition|(
name|ft_memcmp
argument_list|(
name|name
argument_list|,
literal|"FONT_ASCENT"
argument_list|,
literal|11
argument_list|)
operator|==
literal|0
condition|)
name|font
operator|->
name|font_ascent
operator|=
name|fp
operator|->
name|value
operator|.
name|l
expr_stmt|;
elseif|else
if|if
condition|(
name|ft_memcmp
argument_list|(
name|name
argument_list|,
literal|"FONT_DESCENT"
argument_list|,
literal|12
argument_list|)
operator|==
literal|0
condition|)
name|font
operator|->
name|font_descent
operator|=
name|fp
operator|->
name|value
operator|.
name|l
expr_stmt|;
elseif|else
if|if
condition|(
name|ft_memcmp
argument_list|(
name|name
argument_list|,
literal|"SPACING"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|fp
operator|->
name|value
operator|.
name|atom
condition|)
block|{
name|error
operator|=
name|BDF_Err_Invalid_File_Format
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|fp
operator|->
name|value
operator|.
name|atom
index|[
literal|0
index|]
operator|==
literal|'p'
operator|||
name|fp
operator|->
name|value
operator|.
name|atom
index|[
literal|0
index|]
operator|==
literal|'P'
condition|)
name|font
operator|->
name|spacing
operator|=
name|BDF_PROPORTIONAL
expr_stmt|;
elseif|else
if|if
condition|(
name|fp
operator|->
name|value
operator|.
name|atom
index|[
literal|0
index|]
operator|==
literal|'m'
operator|||
name|fp
operator|->
name|value
operator|.
name|atom
index|[
literal|0
index|]
operator|==
literal|'M'
condition|)
name|font
operator|->
name|spacing
operator|=
name|BDF_MONOWIDTH
expr_stmt|;
elseif|else
if|if
condition|(
name|fp
operator|->
name|value
operator|.
name|atom
index|[
literal|0
index|]
operator|==
literal|'c'
operator|||
name|fp
operator|->
name|value
operator|.
name|atom
index|[
literal|0
index|]
operator|==
literal|'C'
condition|)
name|font
operator|->
name|spacing
operator|=
name|BDF_CHARCELL
expr_stmt|;
block|}
name|Exit
label|:
return|return
name|error
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|nibble_mask
specifier|static
specifier|const
name|unsigned
name|char
name|nibble_mask
index|[
literal|8
index|]
init|=
block|{
literal|0xFF
block|,
literal|0x80
block|,
literal|0xC0
block|,
literal|0xE0
block|,
literal|0xF0
block|,
literal|0xF8
block|,
literal|0xFC
block|,
literal|0xFE
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* Actually parse the glyph info and bitmaps. */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|_bdf_parse_glyphs
name|_bdf_parse_glyphs
parameter_list|(
name|char
modifier|*
name|line
parameter_list|,
name|unsigned
name|long
name|linelen
parameter_list|,
name|unsigned
name|long
name|lineno
parameter_list|,
name|void
modifier|*
name|call_data
parameter_list|,
name|void
modifier|*
name|client_data
parameter_list|)
block|{
name|int
name|c
decl_stmt|,
name|mask_index
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|unsigned
name|char
modifier|*
name|bp
decl_stmt|;
name|unsigned
name|long
name|i
decl_stmt|,
name|slen
decl_stmt|,
name|nibbles
decl_stmt|;
name|_bdf_parse_t
modifier|*
name|p
decl_stmt|;
name|bdf_glyph_t
modifier|*
name|glyph
decl_stmt|;
name|bdf_font_t
modifier|*
name|font
decl_stmt|;
name|FT_Memory
name|memory
decl_stmt|;
name|FT_Error
name|error
init|=
name|BDF_Err_Ok
decl_stmt|;
name|FT_UNUSED
argument_list|(
name|call_data
argument_list|)
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|lineno
argument_list|)
expr_stmt|;
comment|/* only used in debug mode */
name|p
operator|=
operator|(
name|_bdf_parse_t
operator|*
operator|)
name|client_data
expr_stmt|;
name|font
operator|=
name|p
operator|->
name|font
expr_stmt|;
name|memory
operator|=
name|font
operator|->
name|memory
expr_stmt|;
comment|/* Check for a comment. */
if|if
condition|(
name|ft_memcmp
argument_list|(
name|line
argument_list|,
literal|"COMMENT"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
block|{
name|linelen
operator|-=
literal|7
expr_stmt|;
name|s
operator|=
name|line
operator|+
literal|7
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|0
condition|)
block|{
name|s
operator|++
expr_stmt|;
name|linelen
operator|--
expr_stmt|;
block|}
name|error
operator|=
name|_bdf_add_comment
argument_list|(
name|p
operator|->
name|font
argument_list|,
name|s
argument_list|,
name|linelen
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* The very first thing expected is the number of glyphs. */
if|if
condition|(
operator|!
operator|(
name|p
operator|->
name|flags
operator|&
name|_BDF_GLYPHS
operator|)
condition|)
block|{
if|if
condition|(
name|ft_memcmp
argument_list|(
name|line
argument_list|,
literal|"CHARS"
argument_list|,
literal|5
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"_bdf_parse_glyphs: "
name|ERRMSG1
operator|,
name|lineno
operator|,
literal|"CHARS"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|BDF_Err_Missing_Chars_Field
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|error
operator|=
name|_bdf_list_split
argument_list|(
operator|&
name|p
operator|->
name|list
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|" +"
argument_list|,
name|line
argument_list|,
name|linelen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|p
operator|->
name|cnt
operator|=
name|font
operator|->
name|glyphs_size
operator|=
name|_bdf_atoul
argument_list|(
name|p
operator|->
name|list
operator|.
name|field
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/* Make sure the number of glyphs is non-zero. */
if|if
condition|(
name|p
operator|->
name|cnt
operator|==
literal|0
condition|)
name|font
operator|->
name|glyphs_size
operator|=
literal|64
expr_stmt|;
comment|/* Limit ourselves to 1,114,112 glyphs in the font (this is the */
comment|/* number of code points available in Unicode).                 */
if|if
condition|(
name|p
operator|->
name|cnt
operator|>=
literal|1114112UL
condition|)
block|{
name|error
operator|=
name|BDF_Err_Invalid_Argument
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|font
operator|->
name|glyphs
argument_list|,
name|font
operator|->
name|glyphs_size
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|p
operator|->
name|flags
operator||=
name|_BDF_GLYPHS
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* Check for the ENDFONT field. */
if|if
condition|(
name|ft_memcmp
argument_list|(
name|line
argument_list|,
literal|"ENDFONT"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Sort the glyphs by encoding. */
name|ft_qsort
argument_list|(
operator|(
name|char
operator|*
operator|)
name|font
operator|->
name|glyphs
argument_list|,
name|font
operator|->
name|glyphs_used
argument_list|,
sizeof|sizeof
argument_list|(
name|bdf_glyph_t
argument_list|)
argument_list|,
name|by_encoding
argument_list|)
expr_stmt|;
name|p
operator|->
name|flags
operator|&=
operator|~
name|_BDF_START
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* Check for the ENDCHAR field. */
if|if
condition|(
name|ft_memcmp
argument_list|(
name|line
argument_list|,
literal|"ENDCHAR"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
block|{
name|p
operator|->
name|glyph_enc
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|flags
operator|&=
operator|~
name|_BDF_GLYPH_BITS
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* Check to see whether a glyph is being scanned but should be */
comment|/* ignored because it is an unencoded glyph.                   */
if|if
condition|(
operator|(
name|p
operator|->
name|flags
operator|&
name|_BDF_GLYPH
operator|)
operator|&&
name|p
operator|->
name|glyph_enc
operator|==
operator|-
literal|1
operator|&&
name|p
operator|->
name|opts
operator|->
name|keep_unencoded
operator|==
literal|0
condition|)
goto|goto
name|Exit
goto|;
comment|/* Check for the STARTCHAR field. */
if|if
condition|(
name|ft_memcmp
argument_list|(
name|line
argument_list|,
literal|"STARTCHAR"
argument_list|,
literal|9
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Set the character name in the parse info first until the */
comment|/* encoding can be checked for an unencoded character.      */
name|FT_FREE
argument_list|(
name|p
operator|->
name|glyph_name
argument_list|)
expr_stmt|;
name|error
operator|=
name|_bdf_list_split
argument_list|(
operator|&
name|p
operator|->
name|list
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|" +"
argument_list|,
name|line
argument_list|,
name|linelen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|_bdf_list_shift
argument_list|(
operator|&
name|p
operator|->
name|list
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|s
operator|=
name|_bdf_list_join
argument_list|(
operator|&
name|p
operator|->
name|list
argument_list|,
literal|' '
argument_list|,
operator|&
name|slen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
block|{
name|error
operator|=
name|BDF_Err_Invalid_File_Format
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|p
operator|->
name|glyph_name
argument_list|,
name|slen
operator|+
literal|1
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|FT_MEM_COPY
argument_list|(
name|p
operator|->
name|glyph_name
argument_list|,
name|s
argument_list|,
name|slen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p
operator|->
name|flags
operator||=
name|_BDF_GLYPH
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* Check for the ENCODING field. */
if|if
condition|(
name|ft_memcmp
argument_list|(
name|line
argument_list|,
literal|"ENCODING"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|p
operator|->
name|flags
operator|&
name|_BDF_GLYPH
operator|)
condition|)
block|{
comment|/* Missing STARTCHAR field. */
name|FT_ERROR
argument_list|(
operator|(
literal|"_bdf_parse_glyphs: "
name|ERRMSG1
operator|,
name|lineno
operator|,
literal|"STARTCHAR"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|BDF_Err_Missing_Startchar_Field
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|error
operator|=
name|_bdf_list_split
argument_list|(
operator|&
name|p
operator|->
name|list
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|" +"
argument_list|,
name|line
argument_list|,
name|linelen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|p
operator|->
name|glyph_enc
operator|=
name|_bdf_atol
argument_list|(
name|p
operator|->
name|list
operator|.
name|field
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/* Check that the encoding is in the range [0,65536] because        */
comment|/* otherwise p->have (a bitmap with static size) overflows.         */
if|if
condition|(
operator|(
name|size_t
operator|)
name|p
operator|->
name|glyph_enc
operator|>=
sizeof|sizeof
argument_list|(
name|p
operator|->
name|have
argument_list|)
operator|*
literal|8
condition|)
block|{
name|error
operator|=
name|BDF_Err_Invalid_File_Format
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* Check to see whether this encoding has already been encountered. */
comment|/* If it has then change it to unencoded so it gets added if        */
comment|/* indicated.                                                       */
if|if
condition|(
name|p
operator|->
name|glyph_enc
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|_bdf_glyph_modified
argument_list|(
name|p
operator|->
name|have
argument_list|,
name|p
operator|->
name|glyph_enc
argument_list|)
condition|)
block|{
comment|/* Emit a message saying a glyph has been moved to the */
comment|/* unencoded area.                                     */
name|FT_TRACE2
argument_list|(
operator|(
literal|"_bdf_parse_glyphs: "
name|ACMSG12
operator|,
name|p
operator|->
name|glyph_enc
operator|,
name|p
operator|->
name|glyph_name
operator|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|glyph_enc
operator|=
operator|-
literal|1
expr_stmt|;
name|font
operator|->
name|modified
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|_bdf_set_glyph_modified
argument_list|(
name|p
operator|->
name|have
argument_list|,
name|p
operator|->
name|glyph_enc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|glyph_enc
operator|>=
literal|0
condition|)
block|{
comment|/* Make sure there are enough glyphs allocated in case the */
comment|/* number of characters happen to be wrong.                */
if|if
condition|(
name|font
operator|->
name|glyphs_used
operator|==
name|font
operator|->
name|glyphs_size
condition|)
block|{
if|if
condition|(
name|FT_RENEW_ARRAY
argument_list|(
name|font
operator|->
name|glyphs
argument_list|,
name|font
operator|->
name|glyphs_size
argument_list|,
name|font
operator|->
name|glyphs_size
operator|+
literal|64
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|font
operator|->
name|glyphs_size
operator|+=
literal|64
expr_stmt|;
block|}
name|glyph
operator|=
name|font
operator|->
name|glyphs
operator|+
name|font
operator|->
name|glyphs_used
operator|++
expr_stmt|;
name|glyph
operator|->
name|name
operator|=
name|p
operator|->
name|glyph_name
expr_stmt|;
name|glyph
operator|->
name|encoding
operator|=
name|p
operator|->
name|glyph_enc
expr_stmt|;
comment|/* Reset the initial glyph info. */
name|p
operator|->
name|glyph_name
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Unencoded glyph.  Check to see whether it should */
comment|/* be added or not.                                 */
if|if
condition|(
name|p
operator|->
name|opts
operator|->
name|keep_unencoded
operator|!=
literal|0
condition|)
block|{
comment|/* Allocate the next unencoded glyph. */
if|if
condition|(
name|font
operator|->
name|unencoded_used
operator|==
name|font
operator|->
name|unencoded_size
condition|)
block|{
if|if
condition|(
name|FT_RENEW_ARRAY
argument_list|(
name|font
operator|->
name|unencoded
argument_list|,
name|font
operator|->
name|unencoded_size
argument_list|,
name|font
operator|->
name|unencoded_size
operator|+
literal|4
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|font
operator|->
name|unencoded_size
operator|+=
literal|4
expr_stmt|;
block|}
name|glyph
operator|=
name|font
operator|->
name|unencoded
operator|+
name|font
operator|->
name|unencoded_used
expr_stmt|;
name|glyph
operator|->
name|name
operator|=
name|p
operator|->
name|glyph_name
expr_stmt|;
name|glyph
operator|->
name|encoding
operator|=
name|font
operator|->
name|unencoded_used
operator|++
expr_stmt|;
block|}
else|else
comment|/* Free up the glyph name if the unencoded shouldn't be */
comment|/* kept.                                                */
name|FT_FREE
argument_list|(
name|p
operator|->
name|glyph_name
argument_list|)
expr_stmt|;
name|p
operator|->
name|glyph_name
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Clear the flags that might be added when width and height are */
comment|/* checked for consistency.                                      */
name|p
operator|->
name|flags
operator|&=
operator|~
operator|(
name|_BDF_GLYPH_WIDTH_CHECK
operator||
name|_BDF_GLYPH_HEIGHT_CHECK
operator|)
expr_stmt|;
name|p
operator|->
name|flags
operator||=
name|_BDF_ENCODING
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* Point at the glyph being constructed. */
if|if
condition|(
name|p
operator|->
name|glyph_enc
operator|==
operator|-
literal|1
condition|)
name|glyph
operator|=
name|font
operator|->
name|unencoded
operator|+
operator|(
name|font
operator|->
name|unencoded_used
operator|-
literal|1
operator|)
expr_stmt|;
else|else
name|glyph
operator|=
name|font
operator|->
name|glyphs
operator|+
operator|(
name|font
operator|->
name|glyphs_used
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* Check to see whether a bitmap is being constructed. */
if|if
condition|(
name|p
operator|->
name|flags
operator|&
name|_BDF_BITMAP
condition|)
block|{
comment|/* If there are more rows than are specified in the glyph metrics, */
comment|/* ignore the remaining lines.                                     */
if|if
condition|(
name|p
operator|->
name|row
operator|>=
operator|(
name|unsigned
name|long
operator|)
name|glyph
operator|->
name|bbx
operator|.
name|height
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|p
operator|->
name|flags
operator|&
name|_BDF_GLYPH_HEIGHT_CHECK
operator|)
condition|)
block|{
name|FT_TRACE2
argument_list|(
operator|(
literal|"_bdf_parse_glyphs: "
name|ACMSG13
operator|,
name|glyph
operator|->
name|encoding
operator|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|flags
operator||=
name|_BDF_GLYPH_HEIGHT_CHECK
expr_stmt|;
name|font
operator|->
name|modified
operator|=
literal|1
expr_stmt|;
block|}
goto|goto
name|Exit
goto|;
block|}
comment|/* Only collect the number of nibbles indicated by the glyph     */
comment|/* metrics.  If there are more columns, they are simply ignored. */
name|nibbles
operator|=
name|glyph
operator|->
name|bpr
operator|<<
literal|1
expr_stmt|;
name|bp
operator|=
name|glyph
operator|->
name|bitmap
operator|+
name|p
operator|->
name|row
operator|*
name|glyph
operator|->
name|bpr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nibbles
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
name|line
index|[
name|i
index|]
expr_stmt|;
operator|*
name|bp
operator|=
call|(
name|FT_Byte
call|)
argument_list|(
operator|(
operator|*
name|bp
operator|<<
literal|4
operator|)
operator|+
name|a2i
index|[
name|c
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|+
literal|1
operator|<
name|nibbles
operator|&&
operator|(
name|i
operator|&
literal|1
operator|)
condition|)
operator|*
operator|++
name|bp
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Remove possible garbage at the right. */
name|mask_index
operator|=
operator|(
name|glyph
operator|->
name|bbx
operator|.
name|width
operator|*
name|p
operator|->
name|font
operator|->
name|bpp
operator|)
operator|&
literal|7
expr_stmt|;
if|if
condition|(
name|glyph
operator|->
name|bbx
operator|.
name|width
condition|)
operator|*
name|bp
operator|&=
name|nibble_mask
index|[
name|mask_index
index|]
expr_stmt|;
comment|/* If any line has extra columns, indicate they have been removed. */
if|if
condition|(
operator|(
name|line
index|[
name|nibbles
index|]
operator|==
literal|'0'
operator|||
name|a2i
index|[
operator|(
name|int
operator|)
name|line
index|[
name|nibbles
index|]
index|]
operator|!=
literal|0
operator|)
operator|&&
operator|!
operator|(
name|p
operator|->
name|flags
operator|&
name|_BDF_GLYPH_WIDTH_CHECK
operator|)
condition|)
block|{
name|FT_TRACE2
argument_list|(
operator|(
literal|"_bdf_parse_glyphs: "
name|ACMSG14
operator|,
name|glyph
operator|->
name|encoding
operator|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|flags
operator||=
name|_BDF_GLYPH_WIDTH_CHECK
expr_stmt|;
name|font
operator|->
name|modified
operator|=
literal|1
expr_stmt|;
block|}
name|p
operator|->
name|row
operator|++
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* Expect the SWIDTH (scalable width) field next. */
if|if
condition|(
name|ft_memcmp
argument_list|(
name|line
argument_list|,
literal|"SWIDTH"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|p
operator|->
name|flags
operator|&
name|_BDF_ENCODING
operator|)
condition|)
block|{
comment|/* Missing ENCODING field. */
name|FT_ERROR
argument_list|(
operator|(
literal|"_bdf_parse_glyphs: "
name|ERRMSG1
operator|,
name|lineno
operator|,
literal|"ENCODING"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|BDF_Err_Missing_Encoding_Field
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|error
operator|=
name|_bdf_list_split
argument_list|(
operator|&
name|p
operator|->
name|list
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|" +"
argument_list|,
name|line
argument_list|,
name|linelen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|glyph
operator|->
name|swidth
operator|=
operator|(
name|unsigned
name|short
operator|)
name|_bdf_atoul
argument_list|(
name|p
operator|->
name|list
operator|.
name|field
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|p
operator|->
name|flags
operator||=
name|_BDF_SWIDTH
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* Expect the DWIDTH (scalable width) field next. */
if|if
condition|(
name|ft_memcmp
argument_list|(
name|line
argument_list|,
literal|"DWIDTH"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|_bdf_list_split
argument_list|(
operator|&
name|p
operator|->
name|list
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|" +"
argument_list|,
name|line
argument_list|,
name|linelen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|glyph
operator|->
name|dwidth
operator|=
operator|(
name|unsigned
name|short
operator|)
name|_bdf_atoul
argument_list|(
name|p
operator|->
name|list
operator|.
name|field
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|p
operator|->
name|flags
operator|&
name|_BDF_SWIDTH
operator|)
condition|)
block|{
comment|/* Missing SWIDTH field.  Emit an auto correction message and set */
comment|/* the scalable width from the device width.                      */
name|FT_TRACE2
argument_list|(
operator|(
literal|"_bdf_parse_glyphs: "
name|ACMSG9
operator|,
name|lineno
operator|)
argument_list|)
expr_stmt|;
name|glyph
operator|->
name|swidth
operator|=
operator|(
name|unsigned
name|short
operator|)
name|FT_MulDiv
argument_list|(
name|glyph
operator|->
name|dwidth
argument_list|,
literal|72000L
argument_list|,
call|(
name|FT_Long
call|)
argument_list|(
name|font
operator|->
name|point_size
operator|*
name|font
operator|->
name|resolution_x
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|flags
operator||=
name|_BDF_DWIDTH
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* Expect the BBX field next. */
if|if
condition|(
name|ft_memcmp
argument_list|(
name|line
argument_list|,
literal|"BBX"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|_bdf_list_split
argument_list|(
operator|&
name|p
operator|->
name|list
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|" +"
argument_list|,
name|line
argument_list|,
name|linelen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|glyph
operator|->
name|bbx
operator|.
name|width
operator|=
name|_bdf_atos
argument_list|(
name|p
operator|->
name|list
operator|.
name|field
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|glyph
operator|->
name|bbx
operator|.
name|height
operator|=
name|_bdf_atos
argument_list|(
name|p
operator|->
name|list
operator|.
name|field
index|[
literal|2
index|]
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|glyph
operator|->
name|bbx
operator|.
name|x_offset
operator|=
name|_bdf_atos
argument_list|(
name|p
operator|->
name|list
operator|.
name|field
index|[
literal|3
index|]
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|glyph
operator|->
name|bbx
operator|.
name|y_offset
operator|=
name|_bdf_atos
argument_list|(
name|p
operator|->
name|list
operator|.
name|field
index|[
literal|4
index|]
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/* Generate the ascent and descent of the character. */
name|glyph
operator|->
name|bbx
operator|.
name|ascent
operator|=
call|(
name|short
call|)
argument_list|(
name|glyph
operator|->
name|bbx
operator|.
name|height
operator|+
name|glyph
operator|->
name|bbx
operator|.
name|y_offset
argument_list|)
expr_stmt|;
name|glyph
operator|->
name|bbx
operator|.
name|descent
operator|=
call|(
name|short
call|)
argument_list|(
operator|-
name|glyph
operator|->
name|bbx
operator|.
name|y_offset
argument_list|)
expr_stmt|;
comment|/* Determine the overall font bounding box as the characters are */
comment|/* loaded so corrections can be done later if indicated.         */
name|p
operator|->
name|maxas
operator|=
operator|(
name|short
operator|)
name|FT_MAX
argument_list|(
name|glyph
operator|->
name|bbx
operator|.
name|ascent
argument_list|,
name|p
operator|->
name|maxas
argument_list|)
expr_stmt|;
name|p
operator|->
name|maxds
operator|=
operator|(
name|short
operator|)
name|FT_MAX
argument_list|(
name|glyph
operator|->
name|bbx
operator|.
name|descent
argument_list|,
name|p
operator|->
name|maxds
argument_list|)
expr_stmt|;
name|p
operator|->
name|rbearing
operator|=
call|(
name|short
call|)
argument_list|(
name|glyph
operator|->
name|bbx
operator|.
name|width
operator|+
name|glyph
operator|->
name|bbx
operator|.
name|x_offset
argument_list|)
expr_stmt|;
name|p
operator|->
name|maxrb
operator|=
operator|(
name|short
operator|)
name|FT_MAX
argument_list|(
name|p
operator|->
name|rbearing
argument_list|,
name|p
operator|->
name|maxrb
argument_list|)
expr_stmt|;
name|p
operator|->
name|minlb
operator|=
operator|(
name|short
operator|)
name|FT_MIN
argument_list|(
name|glyph
operator|->
name|bbx
operator|.
name|x_offset
argument_list|,
name|p
operator|->
name|minlb
argument_list|)
expr_stmt|;
name|p
operator|->
name|maxlb
operator|=
operator|(
name|short
operator|)
name|FT_MAX
argument_list|(
name|glyph
operator|->
name|bbx
operator|.
name|x_offset
argument_list|,
name|p
operator|->
name|maxlb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|p
operator|->
name|flags
operator|&
name|_BDF_DWIDTH
operator|)
condition|)
block|{
comment|/* Missing DWIDTH field.  Emit an auto correction message and set */
comment|/* the device width to the glyph width.                           */
name|FT_TRACE2
argument_list|(
operator|(
literal|"_bdf_parse_glyphs: "
name|ACMSG10
operator|,
name|lineno
operator|)
argument_list|)
expr_stmt|;
name|glyph
operator|->
name|dwidth
operator|=
name|glyph
operator|->
name|bbx
operator|.
name|width
expr_stmt|;
block|}
comment|/* If the BDF_CORRECT_METRICS flag is set, then adjust the SWIDTH */
comment|/* value if necessary.                                            */
if|if
condition|(
name|p
operator|->
name|opts
operator|->
name|correct_metrics
operator|!=
literal|0
condition|)
block|{
comment|/* Determine the point size of the glyph. */
name|unsigned
name|short
name|sw
init|=
operator|(
name|unsigned
name|short
operator|)
name|FT_MulDiv
argument_list|(
name|glyph
operator|->
name|dwidth
argument_list|,
literal|72000L
argument_list|,
call|(
name|FT_Long
call|)
argument_list|(
name|font
operator|->
name|point_size
operator|*
name|font
operator|->
name|resolution_x
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|sw
operator|!=
name|glyph
operator|->
name|swidth
condition|)
block|{
name|glyph
operator|->
name|swidth
operator|=
name|sw
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|glyph_enc
operator|==
operator|-
literal|1
condition|)
name|_bdf_set_glyph_modified
argument_list|(
name|font
operator|->
name|umod
argument_list|,
name|font
operator|->
name|unencoded_used
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|_bdf_set_glyph_modified
argument_list|(
name|font
operator|->
name|nmod
argument_list|,
name|glyph
operator|->
name|encoding
argument_list|)
expr_stmt|;
name|p
operator|->
name|flags
operator||=
name|_BDF_SWIDTH_ADJ
expr_stmt|;
name|font
operator|->
name|modified
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|p
operator|->
name|flags
operator||=
name|_BDF_BBX
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* And finally, gather up the bitmap. */
if|if
condition|(
name|ft_memcmp
argument_list|(
name|line
argument_list|,
literal|"BITMAP"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
block|{
name|unsigned
name|long
name|bitmap_size
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|p
operator|->
name|flags
operator|&
name|_BDF_BBX
operator|)
condition|)
block|{
comment|/* Missing BBX field. */
name|FT_ERROR
argument_list|(
operator|(
literal|"_bdf_parse_glyphs: "
name|ERRMSG1
operator|,
name|lineno
operator|,
literal|"BBX"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|BDF_Err_Missing_Bbx_Field
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* Allocate enough space for the bitmap. */
name|glyph
operator|->
name|bpr
operator|=
operator|(
name|glyph
operator|->
name|bbx
operator|.
name|width
operator|*
name|p
operator|->
name|font
operator|->
name|bpp
operator|+
literal|7
operator|)
operator|>>
literal|3
expr_stmt|;
name|bitmap_size
operator|=
name|glyph
operator|->
name|bpr
operator|*
name|glyph
operator|->
name|bbx
operator|.
name|height
expr_stmt|;
if|if
condition|(
name|bitmap_size
operator|>
literal|0xFFFFU
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"_bdf_parse_glyphs: "
name|ERRMSG4
operator|,
name|lineno
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|BDF_Err_Bbx_Too_Big
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
else|else
name|glyph
operator|->
name|bytes
operator|=
operator|(
name|unsigned
name|short
operator|)
name|bitmap_size
expr_stmt|;
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|glyph
operator|->
name|bitmap
argument_list|,
name|glyph
operator|->
name|bytes
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|p
operator|->
name|row
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|flags
operator||=
name|_BDF_BITMAP
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|error
operator|=
name|BDF_Err_Invalid_File_Format
expr_stmt|;
name|Exit
label|:
return|return
name|error
return|;
block|}
end_function
begin_comment
comment|/* Load the font properties. */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|_bdf_parse_properties
name|_bdf_parse_properties
parameter_list|(
name|char
modifier|*
name|line
parameter_list|,
name|unsigned
name|long
name|linelen
parameter_list|,
name|unsigned
name|long
name|lineno
parameter_list|,
name|void
modifier|*
name|call_data
parameter_list|,
name|void
modifier|*
name|client_data
parameter_list|)
block|{
name|unsigned
name|long
name|vlen
decl_stmt|;
name|_bdf_line_func_t
modifier|*
name|next
decl_stmt|;
name|_bdf_parse_t
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
name|char
name|nbuf
index|[
literal|128
index|]
decl_stmt|;
name|FT_Error
name|error
init|=
name|BDF_Err_Ok
decl_stmt|;
name|FT_UNUSED
argument_list|(
name|lineno
argument_list|)
expr_stmt|;
name|next
operator|=
operator|(
name|_bdf_line_func_t
operator|*
operator|)
name|call_data
expr_stmt|;
name|p
operator|=
operator|(
name|_bdf_parse_t
operator|*
operator|)
name|client_data
expr_stmt|;
comment|/* Check for the end of the properties. */
if|if
condition|(
name|ft_memcmp
argument_list|(
name|line
argument_list|,
literal|"ENDPROPERTIES"
argument_list|,
literal|13
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* If the FONT_ASCENT or FONT_DESCENT properties have not been      */
comment|/* encountered yet, then make sure they are added as properties and */
comment|/* make sure they are set from the font bounding box info.          */
comment|/*                                                                  */
comment|/* This is *always* done regardless of the options, because X11     */
comment|/* requires these two fields to compile fonts.                      */
if|if
condition|(
name|bdf_get_font_property
argument_list|(
name|p
operator|->
name|font
argument_list|,
literal|"FONT_ASCENT"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|p
operator|->
name|font
operator|->
name|font_ascent
operator|=
name|p
operator|->
name|font
operator|->
name|bbx
operator|.
name|ascent
expr_stmt|;
name|ft_sprintf
argument_list|(
name|nbuf
argument_list|,
literal|"%hd"
argument_list|,
name|p
operator|->
name|font
operator|->
name|bbx
operator|.
name|ascent
argument_list|)
expr_stmt|;
name|error
operator|=
name|_bdf_add_property
argument_list|(
name|p
operator|->
name|font
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|"FONT_ASCENT"
argument_list|,
name|nbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|FT_TRACE2
argument_list|(
operator|(
literal|"_bdf_parse_properties: "
name|ACMSG1
operator|,
name|p
operator|->
name|font
operator|->
name|bbx
operator|.
name|ascent
operator|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|font
operator|->
name|modified
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|bdf_get_font_property
argument_list|(
name|p
operator|->
name|font
argument_list|,
literal|"FONT_DESCENT"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|p
operator|->
name|font
operator|->
name|font_descent
operator|=
name|p
operator|->
name|font
operator|->
name|bbx
operator|.
name|descent
expr_stmt|;
name|ft_sprintf
argument_list|(
name|nbuf
argument_list|,
literal|"%hd"
argument_list|,
name|p
operator|->
name|font
operator|->
name|bbx
operator|.
name|descent
argument_list|)
expr_stmt|;
name|error
operator|=
name|_bdf_add_property
argument_list|(
name|p
operator|->
name|font
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|"FONT_DESCENT"
argument_list|,
name|nbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|FT_TRACE2
argument_list|(
operator|(
literal|"_bdf_parse_properties: "
name|ACMSG2
operator|,
name|p
operator|->
name|font
operator|->
name|bbx
operator|.
name|descent
operator|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|font
operator|->
name|modified
operator|=
literal|1
expr_stmt|;
block|}
name|p
operator|->
name|flags
operator|&=
operator|~
name|_BDF_PROPS
expr_stmt|;
operator|*
name|next
operator|=
name|_bdf_parse_glyphs
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* Ignore the _XFREE86_GLYPH_RANGES properties. */
if|if
condition|(
name|ft_memcmp
argument_list|(
name|line
argument_list|,
literal|"_XFREE86_GLYPH_RANGES"
argument_list|,
literal|21
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|Exit
goto|;
comment|/* Handle COMMENT fields and properties in a special way to preserve */
comment|/* the spacing.                                                      */
if|if
condition|(
name|ft_memcmp
argument_list|(
name|line
argument_list|,
literal|"COMMENT"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
block|{
name|name
operator|=
name|value
operator|=
name|line
expr_stmt|;
name|value
operator|+=
literal|7
expr_stmt|;
if|if
condition|(
operator|*
name|value
condition|)
operator|*
name|value
operator|++
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|_bdf_add_property
argument_list|(
name|p
operator|->
name|font
argument_list|,
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
block|}
elseif|else
if|if
condition|(
name|_bdf_is_atom
argument_list|(
name|line
argument_list|,
name|linelen
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|value
argument_list|,
name|p
operator|->
name|font
argument_list|)
condition|)
block|{
name|error
operator|=
name|_bdf_add_property
argument_list|(
name|p
operator|->
name|font
argument_list|,
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
block|}
else|else
block|{
name|error
operator|=
name|_bdf_list_split
argument_list|(
operator|&
name|p
operator|->
name|list
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|" +"
argument_list|,
name|line
argument_list|,
name|linelen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|name
operator|=
name|p
operator|->
name|list
operator|.
name|field
index|[
literal|0
index|]
expr_stmt|;
name|_bdf_list_shift
argument_list|(
operator|&
name|p
operator|->
name|list
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|value
operator|=
name|_bdf_list_join
argument_list|(
operator|&
name|p
operator|->
name|list
argument_list|,
literal|' '
argument_list|,
operator|&
name|vlen
argument_list|)
expr_stmt|;
name|error
operator|=
name|_bdf_add_property
argument_list|(
name|p
operator|->
name|font
argument_list|,
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
block|}
name|Exit
label|:
return|return
name|error
return|;
block|}
end_function
begin_comment
comment|/* Load the font header. */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|_bdf_parse_start
name|_bdf_parse_start
parameter_list|(
name|char
modifier|*
name|line
parameter_list|,
name|unsigned
name|long
name|linelen
parameter_list|,
name|unsigned
name|long
name|lineno
parameter_list|,
name|void
modifier|*
name|call_data
parameter_list|,
name|void
modifier|*
name|client_data
parameter_list|)
block|{
name|unsigned
name|long
name|slen
decl_stmt|;
name|_bdf_line_func_t
modifier|*
name|next
decl_stmt|;
name|_bdf_parse_t
modifier|*
name|p
decl_stmt|;
name|bdf_font_t
modifier|*
name|font
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|NULL
decl_stmt|;
name|FT_Error
name|error
init|=
name|BDF_Err_Ok
decl_stmt|;
name|FT_UNUSED
argument_list|(
name|lineno
argument_list|)
expr_stmt|;
comment|/* only used in debug mode */
name|next
operator|=
operator|(
name|_bdf_line_func_t
operator|*
operator|)
name|call_data
expr_stmt|;
name|p
operator|=
operator|(
name|_bdf_parse_t
operator|*
operator|)
name|client_data
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|font
condition|)
name|memory
operator|=
name|p
operator|->
name|font
operator|->
name|memory
expr_stmt|;
comment|/* Check for a comment.  This is done to handle those fonts that have */
comment|/* comments before the STARTFONT line for some reason.                */
if|if
condition|(
name|ft_memcmp
argument_list|(
name|line
argument_list|,
literal|"COMMENT"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|opts
operator|->
name|keep_comments
operator|!=
literal|0
operator|&&
name|p
operator|->
name|font
operator|!=
literal|0
condition|)
block|{
name|linelen
operator|-=
literal|7
expr_stmt|;
name|s
operator|=
name|line
operator|+
literal|7
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|0
condition|)
block|{
name|s
operator|++
expr_stmt|;
name|linelen
operator|--
expr_stmt|;
block|}
name|error
operator|=
name|_bdf_add_comment
argument_list|(
name|p
operator|->
name|font
argument_list|,
name|s
argument_list|,
name|linelen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
comment|/* here font is not defined! */
block|}
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
operator|!
operator|(
name|p
operator|->
name|flags
operator|&
name|_BDF_START
operator|)
condition|)
block|{
name|memory
operator|=
name|p
operator|->
name|memory
expr_stmt|;
if|if
condition|(
name|ft_memcmp
argument_list|(
name|line
argument_list|,
literal|"STARTFONT"
argument_list|,
literal|9
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* No STARTFONT field is a good indication of a problem. */
name|error
operator|=
name|BDF_Err_Missing_Startfont_Field
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|p
operator|->
name|flags
operator|=
name|_BDF_START
expr_stmt|;
name|font
operator|=
name|p
operator|->
name|font
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|FT_NEW
argument_list|(
name|font
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|p
operator|->
name|font
operator|=
name|font
expr_stmt|;
name|font
operator|->
name|memory
operator|=
name|p
operator|->
name|memory
expr_stmt|;
name|p
operator|->
name|memory
operator|=
literal|0
expr_stmt|;
block|{
comment|/* setup */
name|size_t
name|i
decl_stmt|;
name|bdf_property_t
modifier|*
name|prop
decl_stmt|;
name|error
operator|=
name|hash_init
argument_list|(
operator|&
operator|(
name|font
operator|->
name|proptbl
operator|)
argument_list|,
name|memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|prop
operator|=
operator|(
name|bdf_property_t
operator|*
operator|)
name|_bdf_properties
init|;
name|i
operator|<
name|_num_bdf_properties
condition|;
name|i
operator|++
operator|,
name|prop
operator|++
control|)
block|{
name|error
operator|=
name|hash_insert
argument_list|(
name|prop
operator|->
name|name
argument_list|,
name|i
argument_list|,
operator|&
operator|(
name|font
operator|->
name|proptbl
operator|)
argument_list|,
name|memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
block|}
block|}
if|if
condition|(
name|FT_ALLOC
argument_list|(
name|p
operator|->
name|font
operator|->
name|internal
argument_list|,
sizeof|sizeof
argument_list|(
name|hashtable
argument_list|)
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|error
operator|=
name|hash_init
argument_list|(
operator|(
name|hashtable
operator|*
operator|)
name|p
operator|->
name|font
operator|->
name|internal
argument_list|,
name|memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|p
operator|->
name|font
operator|->
name|spacing
operator|=
name|p
operator|->
name|opts
operator|->
name|font_spacing
expr_stmt|;
name|p
operator|->
name|font
operator|->
name|default_char
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* Check for the start of the properties. */
if|if
condition|(
name|ft_memcmp
argument_list|(
name|line
argument_list|,
literal|"STARTPROPERTIES"
argument_list|,
literal|15
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|_bdf_list_split
argument_list|(
operator|&
name|p
operator|->
name|list
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|" +"
argument_list|,
name|line
argument_list|,
name|linelen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
comment|/* at this point, `p->font' can't be NULL */
name|p
operator|->
name|cnt
operator|=
name|p
operator|->
name|font
operator|->
name|props_size
operator|=
name|_bdf_atoul
argument_list|(
name|p
operator|->
name|list
operator|.
name|field
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|p
operator|->
name|font
operator|->
name|props
argument_list|,
name|p
operator|->
name|cnt
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|p
operator|->
name|flags
operator||=
name|_BDF_PROPS
expr_stmt|;
operator|*
name|next
operator|=
name|_bdf_parse_properties
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* Check for the FONTBOUNDINGBOX field. */
if|if
condition|(
name|ft_memcmp
argument_list|(
name|line
argument_list|,
literal|"FONTBOUNDINGBOX"
argument_list|,
literal|15
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|p
operator|->
name|flags
operator|&
name|_BDF_SIZE
operator|)
condition|)
block|{
comment|/* Missing the SIZE field. */
name|FT_ERROR
argument_list|(
operator|(
literal|"_bdf_parse_start: "
name|ERRMSG1
operator|,
name|lineno
operator|,
literal|"SIZE"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|BDF_Err_Missing_Size_Field
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|error
operator|=
name|_bdf_list_split
argument_list|(
operator|&
name|p
operator|->
name|list
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|" +"
argument_list|,
name|line
argument_list|,
name|linelen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|p
operator|->
name|font
operator|->
name|bbx
operator|.
name|width
operator|=
name|_bdf_atos
argument_list|(
name|p
operator|->
name|list
operator|.
name|field
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|p
operator|->
name|font
operator|->
name|bbx
operator|.
name|height
operator|=
name|_bdf_atos
argument_list|(
name|p
operator|->
name|list
operator|.
name|field
index|[
literal|2
index|]
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|p
operator|->
name|font
operator|->
name|bbx
operator|.
name|x_offset
operator|=
name|_bdf_atos
argument_list|(
name|p
operator|->
name|list
operator|.
name|field
index|[
literal|3
index|]
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|p
operator|->
name|font
operator|->
name|bbx
operator|.
name|y_offset
operator|=
name|_bdf_atos
argument_list|(
name|p
operator|->
name|list
operator|.
name|field
index|[
literal|4
index|]
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|p
operator|->
name|font
operator|->
name|bbx
operator|.
name|ascent
operator|=
call|(
name|short
call|)
argument_list|(
name|p
operator|->
name|font
operator|->
name|bbx
operator|.
name|height
operator|+
name|p
operator|->
name|font
operator|->
name|bbx
operator|.
name|y_offset
argument_list|)
expr_stmt|;
name|p
operator|->
name|font
operator|->
name|bbx
operator|.
name|descent
operator|=
call|(
name|short
call|)
argument_list|(
operator|-
name|p
operator|->
name|font
operator|->
name|bbx
operator|.
name|y_offset
argument_list|)
expr_stmt|;
name|p
operator|->
name|flags
operator||=
name|_BDF_FONT_BBX
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* The next thing to check for is the FONT field. */
if|if
condition|(
name|ft_memcmp
argument_list|(
name|line
argument_list|,
literal|"FONT"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|_bdf_list_split
argument_list|(
operator|&
name|p
operator|->
name|list
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|" +"
argument_list|,
name|line
argument_list|,
name|linelen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|_bdf_list_shift
argument_list|(
operator|&
name|p
operator|->
name|list
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|s
operator|=
name|_bdf_list_join
argument_list|(
operator|&
name|p
operator|->
name|list
argument_list|,
literal|' '
argument_list|,
operator|&
name|slen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
block|{
name|error
operator|=
name|BDF_Err_Invalid_File_Format
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|p
operator|->
name|font
operator|->
name|name
argument_list|,
name|slen
operator|+
literal|1
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|FT_MEM_COPY
argument_list|(
name|p
operator|->
name|font
operator|->
name|name
argument_list|,
name|s
argument_list|,
name|slen
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* If the font name is an XLFD name, set the spacing to the one in  */
comment|/* the font name.  If there is no spacing fall back on the default. */
name|error
operator|=
name|_bdf_set_default_spacing
argument_list|(
name|p
operator|->
name|font
argument_list|,
name|p
operator|->
name|opts
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|p
operator|->
name|flags
operator||=
name|_BDF_FONT_NAME
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* Check for the SIZE field. */
if|if
condition|(
name|ft_memcmp
argument_list|(
name|line
argument_list|,
literal|"SIZE"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|p
operator|->
name|flags
operator|&
name|_BDF_FONT_NAME
operator|)
condition|)
block|{
comment|/* Missing the FONT field. */
name|FT_ERROR
argument_list|(
operator|(
literal|"_bdf_parse_start: "
name|ERRMSG1
operator|,
name|lineno
operator|,
literal|"FONT"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|BDF_Err_Missing_Font_Field
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|error
operator|=
name|_bdf_list_split
argument_list|(
operator|&
name|p
operator|->
name|list
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|" +"
argument_list|,
name|line
argument_list|,
name|linelen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|p
operator|->
name|font
operator|->
name|point_size
operator|=
name|_bdf_atoul
argument_list|(
name|p
operator|->
name|list
operator|.
name|field
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|p
operator|->
name|font
operator|->
name|resolution_x
operator|=
name|_bdf_atoul
argument_list|(
name|p
operator|->
name|list
operator|.
name|field
index|[
literal|2
index|]
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|p
operator|->
name|font
operator|->
name|resolution_y
operator|=
name|_bdf_atoul
argument_list|(
name|p
operator|->
name|list
operator|.
name|field
index|[
literal|3
index|]
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/* Check for the bits per pixel field. */
if|if
condition|(
name|p
operator|->
name|list
operator|.
name|used
operator|==
literal|5
condition|)
block|{
name|unsigned
name|short
name|bitcount
decl_stmt|,
name|i
decl_stmt|,
name|shift
decl_stmt|;
name|p
operator|->
name|font
operator|->
name|bpp
operator|=
operator|(
name|unsigned
name|short
operator|)
name|_bdf_atos
argument_list|(
name|p
operator|->
name|list
operator|.
name|field
index|[
literal|4
index|]
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/* Only values 1, 2, 4, 8 are allowed. */
name|shift
operator|=
name|p
operator|->
name|font
operator|->
name|bpp
expr_stmt|;
name|bitcount
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|shift
operator|>
literal|0
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|shift
operator|&
literal|1
condition|)
name|bitcount
operator|=
name|i
expr_stmt|;
name|shift
operator|>>=
literal|1
expr_stmt|;
block|}
name|shift
operator|=
call|(
name|short
call|)
argument_list|(
operator|(
name|bitcount
operator|>
literal|3
operator|)
condition|?
literal|8
else|:
operator|(
literal|1
operator|<<
name|bitcount
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|font
operator|->
name|bpp
operator|>
name|shift
operator|||
name|p
operator|->
name|font
operator|->
name|bpp
operator|!=
name|shift
condition|)
block|{
comment|/* select next higher value */
name|p
operator|->
name|font
operator|->
name|bpp
operator|=
call|(
name|unsigned
name|short
call|)
argument_list|(
name|shift
operator|<<
literal|1
argument_list|)
expr_stmt|;
name|FT_TRACE2
argument_list|(
operator|(
literal|"_bdf_parse_start: "
name|ACMSG11
operator|,
name|p
operator|->
name|font
operator|->
name|bpp
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|p
operator|->
name|font
operator|->
name|bpp
operator|=
literal|1
expr_stmt|;
name|p
operator|->
name|flags
operator||=
name|_BDF_SIZE
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|error
operator|=
name|BDF_Err_Invalid_File_Format
expr_stmt|;
name|Exit
label|:
return|return
name|error
return|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* API.                                                                  */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|bdf_load_font
argument_list|(
argument|FT_Stream       stream
argument_list|,
argument|FT_Memory       extmemory
argument_list|,
argument|bdf_options_t*  opts
argument_list|,
argument|bdf_font_t*    *font
argument_list|)
end_macro
begin_block
block|{
name|unsigned
name|long
name|lineno
init|=
literal|0
decl_stmt|;
comment|/* make compiler happy */
name|_bdf_parse_t
modifier|*
name|p
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|extmemory
decl_stmt|;
name|FT_Error
name|error
init|=
name|BDF_Err_Ok
decl_stmt|;
if|if
condition|(
name|FT_NEW
argument_list|(
name|p
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|memory
operator|=
name|NULL
expr_stmt|;
name|p
operator|->
name|opts
operator|=
operator|(
name|bdf_options_t
operator|*
operator|)
operator|(
operator|(
name|opts
operator|!=
literal|0
operator|)
condition|?
name|opts
else|:
operator|&
name|_bdf_opts
operator|)
expr_stmt|;
name|p
operator|->
name|minlb
operator|=
literal|32767
expr_stmt|;
name|p
operator|->
name|memory
operator|=
name|extmemory
expr_stmt|;
comment|/* only during font creation */
name|_bdf_list_init
argument_list|(
operator|&
name|p
operator|->
name|list
argument_list|,
name|extmemory
argument_list|)
expr_stmt|;
name|error
operator|=
name|_bdf_readstream
argument_list|(
name|stream
argument_list|,
name|_bdf_parse_start
argument_list|,
operator|(
name|void
operator|*
operator|)
name|p
argument_list|,
operator|&
name|lineno
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Fail
goto|;
if|if
condition|(
name|p
operator|->
name|font
operator|!=
literal|0
condition|)
block|{
comment|/* If the font is not proportional, set the font's monowidth */
comment|/* field to the width of the font bounding box.              */
name|memory
operator|=
name|p
operator|->
name|font
operator|->
name|memory
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|font
operator|->
name|spacing
operator|!=
name|BDF_PROPORTIONAL
condition|)
name|p
operator|->
name|font
operator|->
name|monowidth
operator|=
name|p
operator|->
name|font
operator|->
name|bbx
operator|.
name|width
expr_stmt|;
comment|/* If the number of glyphs loaded is not that of the original count, */
comment|/* indicate the difference.                                          */
if|if
condition|(
name|p
operator|->
name|cnt
operator|!=
name|p
operator|->
name|font
operator|->
name|glyphs_used
operator|+
name|p
operator|->
name|font
operator|->
name|unencoded_used
condition|)
block|{
name|FT_TRACE2
argument_list|(
operator|(
literal|"bdf_load_font: "
name|ACMSG15
operator|,
name|p
operator|->
name|cnt
operator|,
name|p
operator|->
name|font
operator|->
name|glyphs_used
operator|+
name|p
operator|->
name|font
operator|->
name|unencoded_used
operator|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|font
operator|->
name|modified
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Once the font has been loaded, adjust the overall font metrics if */
comment|/* necessary.                                                        */
if|if
condition|(
name|p
operator|->
name|opts
operator|->
name|correct_metrics
operator|!=
literal|0
operator|&&
operator|(
name|p
operator|->
name|font
operator|->
name|glyphs_used
operator|>
literal|0
operator|||
name|p
operator|->
name|font
operator|->
name|unencoded_used
operator|>
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|maxrb
operator|-
name|p
operator|->
name|minlb
operator|!=
name|p
operator|->
name|font
operator|->
name|bbx
operator|.
name|width
condition|)
block|{
name|FT_TRACE2
argument_list|(
operator|(
literal|"bdf_load_font: "
name|ACMSG3
operator|,
name|p
operator|->
name|font
operator|->
name|bbx
operator|.
name|width
operator|,
name|p
operator|->
name|maxrb
operator|-
name|p
operator|->
name|minlb
operator|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|font
operator|->
name|bbx
operator|.
name|width
operator|=
call|(
name|unsigned
name|short
call|)
argument_list|(
name|p
operator|->
name|maxrb
operator|-
name|p
operator|->
name|minlb
argument_list|)
expr_stmt|;
name|p
operator|->
name|font
operator|->
name|modified
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|font
operator|->
name|bbx
operator|.
name|x_offset
operator|!=
name|p
operator|->
name|minlb
condition|)
block|{
name|FT_TRACE2
argument_list|(
operator|(
literal|"bdf_load_font: "
name|ACMSG4
operator|,
name|p
operator|->
name|font
operator|->
name|bbx
operator|.
name|x_offset
operator|,
name|p
operator|->
name|minlb
operator|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|font
operator|->
name|bbx
operator|.
name|x_offset
operator|=
name|p
operator|->
name|minlb
expr_stmt|;
name|p
operator|->
name|font
operator|->
name|modified
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|font
operator|->
name|bbx
operator|.
name|ascent
operator|!=
name|p
operator|->
name|maxas
condition|)
block|{
name|FT_TRACE2
argument_list|(
operator|(
literal|"bdf_load_font: "
name|ACMSG5
operator|,
name|p
operator|->
name|font
operator|->
name|bbx
operator|.
name|ascent
operator|,
name|p
operator|->
name|maxas
operator|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|font
operator|->
name|bbx
operator|.
name|ascent
operator|=
name|p
operator|->
name|maxas
expr_stmt|;
name|p
operator|->
name|font
operator|->
name|modified
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|font
operator|->
name|bbx
operator|.
name|descent
operator|!=
name|p
operator|->
name|maxds
condition|)
block|{
name|FT_TRACE2
argument_list|(
operator|(
literal|"bdf_load_font: "
name|ACMSG6
operator|,
name|p
operator|->
name|font
operator|->
name|bbx
operator|.
name|descent
operator|,
name|p
operator|->
name|maxds
operator|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|font
operator|->
name|bbx
operator|.
name|descent
operator|=
name|p
operator|->
name|maxds
expr_stmt|;
name|p
operator|->
name|font
operator|->
name|bbx
operator|.
name|y_offset
operator|=
call|(
name|short
call|)
argument_list|(
operator|-
name|p
operator|->
name|maxds
argument_list|)
expr_stmt|;
name|p
operator|->
name|font
operator|->
name|modified
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|maxas
operator|+
name|p
operator|->
name|maxds
operator|!=
name|p
operator|->
name|font
operator|->
name|bbx
operator|.
name|height
condition|)
block|{
name|FT_TRACE2
argument_list|(
operator|(
literal|"bdf_load_font: "
name|ACMSG7
operator|,
name|p
operator|->
name|font
operator|->
name|bbx
operator|.
name|height
operator|,
name|p
operator|->
name|maxas
operator|+
name|p
operator|->
name|maxds
operator|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|font
operator|->
name|bbx
operator|.
name|height
operator|=
call|(
name|unsigned
name|short
call|)
argument_list|(
name|p
operator|->
name|maxas
operator|+
name|p
operator|->
name|maxds
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|flags
operator|&
name|_BDF_SWIDTH_ADJ
condition|)
name|FT_TRACE2
argument_list|(
operator|(
literal|"bdf_load_font: "
name|ACMSG8
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p
operator|->
name|flags
operator|&
name|_BDF_START
condition|)
block|{
block|{
comment|/* The ENDFONT field was never reached or did not exist. */
if|if
condition|(
operator|!
operator|(
name|p
operator|->
name|flags
operator|&
name|_BDF_GLYPHS
operator|)
condition|)
block|{
comment|/* Error happened while parsing header. */
name|FT_ERROR
argument_list|(
operator|(
literal|"bdf_load_font: "
name|ERRMSG2
operator|,
name|lineno
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|BDF_Err_Corrupted_Font_Header
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
else|else
block|{
comment|/* Error happened when parsing glyphs. */
name|FT_ERROR
argument_list|(
operator|(
literal|"bdf_load_font: "
name|ERRMSG3
operator|,
name|lineno
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|BDF_Err_Corrupted_Font_Glyphs
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
block|}
if|if
condition|(
name|p
operator|->
name|font
operator|!=
literal|0
condition|)
block|{
comment|/* Make sure the comments are NULL terminated if they exist. */
name|memory
operator|=
name|p
operator|->
name|font
operator|->
name|memory
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|font
operator|->
name|comments_len
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|FT_RENEW_ARRAY
argument_list|(
name|p
operator|->
name|font
operator|->
name|comments
argument_list|,
name|p
operator|->
name|font
operator|->
name|comments_len
argument_list|,
name|p
operator|->
name|font
operator|->
name|comments_len
operator|+
literal|1
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
name|p
operator|->
name|font
operator|->
name|comments
index|[
name|p
operator|->
name|font
operator|->
name|comments_len
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|error
operator|==
name|BDF_Err_Ok
condition|)
name|error
operator|=
name|BDF_Err_Invalid_File_Format
expr_stmt|;
operator|*
name|font
operator|=
name|p
operator|->
name|font
expr_stmt|;
name|Exit
label|:
if|if
condition|(
name|p
condition|)
block|{
name|_bdf_list_done
argument_list|(
operator|&
name|p
operator|->
name|list
argument_list|)
expr_stmt|;
name|memory
operator|=
name|extmemory
expr_stmt|;
name|FT_FREE
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
name|Fail
label|:
name|bdf_free_font
argument_list|(
name|p
operator|->
name|font
argument_list|)
expr_stmt|;
name|memory
operator|=
name|extmemory
expr_stmt|;
name|FT_FREE
argument_list|(
name|p
operator|->
name|font
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
end_block
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|bdf_free_font
name|bdf_free_font
argument_list|(
argument|bdf_font_t*  font
argument_list|)
end_macro
begin_block
block|{
name|bdf_property_t
modifier|*
name|prop
decl_stmt|;
name|unsigned
name|long
name|i
decl_stmt|;
name|bdf_glyph_t
modifier|*
name|glyphs
decl_stmt|;
name|FT_Memory
name|memory
decl_stmt|;
if|if
condition|(
name|font
operator|==
literal|0
condition|)
return|return;
name|memory
operator|=
name|font
operator|->
name|memory
expr_stmt|;
name|FT_FREE
argument_list|(
name|font
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* Free up the internal hash table of property names. */
if|if
condition|(
name|font
operator|->
name|internal
condition|)
block|{
name|hash_free
argument_list|(
operator|(
name|hashtable
operator|*
operator|)
name|font
operator|->
name|internal
argument_list|,
name|memory
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|font
operator|->
name|internal
argument_list|)
expr_stmt|;
block|}
comment|/* Free up the comment info. */
name|FT_FREE
argument_list|(
name|font
operator|->
name|comments
argument_list|)
expr_stmt|;
comment|/* Free up the properties. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|font
operator|->
name|props_size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|font
operator|->
name|props
index|[
name|i
index|]
operator|.
name|format
operator|==
name|BDF_ATOM
condition|)
name|FT_FREE
argument_list|(
name|font
operator|->
name|props
index|[
name|i
index|]
operator|.
name|value
operator|.
name|atom
argument_list|)
expr_stmt|;
block|}
name|FT_FREE
argument_list|(
name|font
operator|->
name|props
argument_list|)
expr_stmt|;
comment|/* Free up the character info. */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|glyphs
operator|=
name|font
operator|->
name|glyphs
init|;
name|i
operator|<
name|font
operator|->
name|glyphs_used
condition|;
name|i
operator|++
operator|,
name|glyphs
operator|++
control|)
block|{
name|FT_FREE
argument_list|(
name|glyphs
operator|->
name|name
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|glyphs
operator|->
name|bitmap
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|glyphs
operator|=
name|font
operator|->
name|unencoded
init|;
name|i
operator|<
name|font
operator|->
name|unencoded_used
condition|;
name|i
operator|++
operator|,
name|glyphs
operator|++
control|)
block|{
name|FT_FREE
argument_list|(
name|glyphs
operator|->
name|name
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|glyphs
operator|->
name|bitmap
argument_list|)
expr_stmt|;
block|}
name|FT_FREE
argument_list|(
name|font
operator|->
name|glyphs
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|font
operator|->
name|unencoded
argument_list|)
expr_stmt|;
comment|/* Free up the overflow storage if it was used. */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|glyphs
operator|=
name|font
operator|->
name|overflow
operator|.
name|glyphs
init|;
name|i
operator|<
name|font
operator|->
name|overflow
operator|.
name|glyphs_used
condition|;
name|i
operator|++
operator|,
name|glyphs
operator|++
control|)
block|{
name|FT_FREE
argument_list|(
name|glyphs
operator|->
name|name
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|glyphs
operator|->
name|bitmap
argument_list|)
expr_stmt|;
block|}
name|FT_FREE
argument_list|(
name|font
operator|->
name|overflow
operator|.
name|glyphs
argument_list|)
expr_stmt|;
comment|/* bdf_cleanup */
name|hash_free
argument_list|(
operator|&
operator|(
name|font
operator|->
name|proptbl
operator|)
argument_list|,
name|memory
argument_list|)
expr_stmt|;
comment|/* Free up the user defined properties. */
for|for
control|(
name|prop
operator|=
name|font
operator|->
name|user_props
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|font
operator|->
name|nuser_props
condition|;
name|i
operator|++
operator|,
name|prop
operator|++
control|)
block|{
name|FT_FREE
argument_list|(
name|prop
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|prop
operator|->
name|format
operator|==
name|BDF_ATOM
condition|)
name|FT_FREE
argument_list|(
name|prop
operator|->
name|value
operator|.
name|atom
argument_list|)
expr_stmt|;
block|}
name|FT_FREE
argument_list|(
name|font
operator|->
name|user_props
argument_list|)
expr_stmt|;
comment|/* FREE( font ); */
comment|/* XXX Fixme */
block|}
end_block
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|bdf_property_t *
argument_list|)
end_macro
begin_macro
DECL|function|bdf_get_font_property
name|bdf_get_font_property
argument_list|(
argument|bdf_font_t*  font
argument_list|,
argument|const char*  name
argument_list|)
end_macro
begin_block
block|{
name|hashnode
name|hn
decl_stmt|;
if|if
condition|(
name|font
operator|==
literal|0
operator|||
name|font
operator|->
name|props_size
operator|==
literal|0
operator|||
name|name
operator|==
literal|0
operator|||
operator|*
name|name
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|hn
operator|=
name|hash_lookup
argument_list|(
name|name
argument_list|,
operator|(
name|hashtable
operator|*
operator|)
name|font
operator|->
name|internal
argument_list|)
expr_stmt|;
return|return
name|hn
condition|?
operator|(
name|font
operator|->
name|props
operator|+
name|hn
operator|->
name|data
operator|)
else|:
literal|0
return|;
block|}
end_block
begin_comment
comment|/* END */
end_comment
end_unit
