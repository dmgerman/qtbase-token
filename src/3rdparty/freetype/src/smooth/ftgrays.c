begin_unit
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  ftgrays.c                                                              */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*    A new `perfect' anti-aliasing renderer (body).                       */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  Copyright 2000-2003, 2005-2014 by                                      */
end_comment
begin_comment
comment|/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  This file is part of the FreeType project, and may only be used,       */
end_comment
begin_comment
comment|/*  modified, and distributed under the terms of the FreeType project      */
end_comment
begin_comment
comment|/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
end_comment
begin_comment
comment|/*  this file you indicate that you have read the license and              */
end_comment
begin_comment
comment|/*  understand and accept it fully.                                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* This file can be compiled without the rest of the FreeType engine, by */
end_comment
begin_comment
comment|/* defining the _STANDALONE_ macro when compiling it.  You also need to  */
end_comment
begin_comment
comment|/* put the files `ftgrays.h' and `ftimage.h' into the current            */
end_comment
begin_comment
comment|/* compilation directory.  Typically, you could do something like        */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* - copy `src/smooth/ftgrays.c' (this file) to your current directory   */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* - copy `include/ftimage.h' and `src/smooth/ftgrays.h' to the same     */
end_comment
begin_comment
comment|/*   directory                                                           */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* - compile `ftgrays' with the _STANDALONE_ macro defined, as in        */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*     cc -c -D_STANDALONE_ ftgrays.c                                    */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* The renderer can be initialized with a call to                        */
end_comment
begin_comment
comment|/* `ft_gray_raster.raster_new'; an anti-aliased bitmap can be generated  */
end_comment
begin_comment
comment|/* with a call to `ft_gray_raster.raster_render'.                        */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* See the comments and documentation in the file `ftimage.h' for more   */
end_comment
begin_comment
comment|/* details on how the raster works.                                      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* This is a new anti-aliasing scan-converter for FreeType 2.  The       */
end_comment
begin_comment
comment|/* algorithm used here is _very_ different from the one in the standard  */
end_comment
begin_comment
comment|/* `ftraster' module.  Actually, `ftgrays' computes the _exact_          */
end_comment
begin_comment
comment|/* coverage of the outline on each pixel cell.                           */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* It is based on ideas that I initially found in Raph Levien's          */
end_comment
begin_comment
comment|/* excellent LibArt graphics library (see http://www.levien.com/libart   */
end_comment
begin_comment
comment|/* for more information, though the web pages do not tell anything       */
end_comment
begin_comment
comment|/* about the renderer; you'll have to dive into the source code to       */
end_comment
begin_comment
comment|/* understand how it works).                                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* Note, however, that this is a _very_ different implementation         */
end_comment
begin_comment
comment|/* compared to Raph's.  Coverage information is stored in a very         */
end_comment
begin_comment
comment|/* different way, and I don't use sorted vector paths.  Also, it doesn't */
end_comment
begin_comment
comment|/* use floating point values.                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* This renderer has the following advantages:                           */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* - It doesn't need an intermediate bitmap.  Instead, one can supply a  */
end_comment
begin_comment
comment|/*   callback function that will be called by the renderer to draw gray  */
end_comment
begin_comment
comment|/*   spans on any target surface.  You can thus do direct composition on */
end_comment
begin_comment
comment|/*   any kind of bitmap, provided that you give the renderer the right   */
end_comment
begin_comment
comment|/*   callback.                                                           */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* - A perfect anti-aliaser, i.e., it computes the _exact_ coverage on   */
end_comment
begin_comment
comment|/*   each pixel cell.                                                    */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* - It performs a single pass on the outline (the `standard' FT2        */
end_comment
begin_comment
comment|/*   renderer makes two passes).                                         */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* - It can easily be modified to render to _any_ number of gray levels  */
end_comment
begin_comment
comment|/*   cheaply.                                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* - For small (< 20) pixel sizes, it is faster than the standard        */
end_comment
begin_comment
comment|/*   renderer.                                                           */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
end_comment
begin_comment
comment|/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
end_comment
begin_comment
comment|/* messages during execution.                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_undef
DECL|macro|FT_COMPONENT
undef|#
directive|undef
name|FT_COMPONENT
end_undef
begin_define
DECL|macro|FT_COMPONENT
define|#
directive|define
name|FT_COMPONENT
value|trace_smooth
end_define
begin_ifdef
ifdef|#
directive|ifdef
name|_STANDALONE_
end_ifdef
begin_comment
comment|/* Auxiliary macros for token concatenation. */
end_comment
begin_define
DECL|macro|FT_ERR_XCAT
define|#
directive|define
name|FT_ERR_XCAT
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|x ## y
end_define
begin_define
DECL|macro|FT_ERR_CAT
define|#
directive|define
name|FT_ERR_CAT
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|FT_ERR_XCAT( x, y )
end_define
begin_define
DECL|macro|FT_BEGIN_STMNT
define|#
directive|define
name|FT_BEGIN_STMNT
value|do {
end_define
begin_define
DECL|macro|FT_END_STMNT
define|#
directive|define
name|FT_END_STMNT
value|} while ( 0 )
end_define
begin_comment
comment|/* define this to dump debugging information */
end_comment
begin_comment
comment|/* #define FT_DEBUG_LEVEL_TRACE */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|FT_DEBUG_LEVEL_TRACE
end_ifdef
begin_include
include|#
directive|include
file|<stdio.h>
end_include
begin_include
include|#
directive|include
file|<stdarg.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|<stddef.h>
end_include
begin_include
include|#
directive|include
file|<string.h>
end_include
begin_include
include|#
directive|include
file|<setjmp.h>
end_include
begin_include
include|#
directive|include
file|<limits.h>
end_include
begin_define
DECL|macro|FT_UINT_MAX
define|#
directive|define
name|FT_UINT_MAX
value|UINT_MAX
end_define
begin_define
DECL|macro|FT_INT_MAX
define|#
directive|define
name|FT_INT_MAX
value|INT_MAX
end_define
begin_define
DECL|macro|ft_memset
define|#
directive|define
name|ft_memset
value|memset
end_define
begin_define
DECL|macro|ft_setjmp
define|#
directive|define
name|ft_setjmp
value|setjmp
end_define
begin_define
DECL|macro|ft_longjmp
define|#
directive|define
name|ft_longjmp
value|longjmp
end_define
begin_define
DECL|macro|ft_jmp_buf
define|#
directive|define
name|ft_jmp_buf
value|jmp_buf
end_define
begin_typedef
DECL|typedef|FT_PtrDist
typedef|typedef
name|ptrdiff_t
name|FT_PtrDist
typedef|;
end_typedef
begin_define
DECL|macro|ErrRaster_Invalid_Mode
define|#
directive|define
name|ErrRaster_Invalid_Mode
value|-2
end_define
begin_define
DECL|macro|ErrRaster_Invalid_Outline
define|#
directive|define
name|ErrRaster_Invalid_Outline
value|-1
end_define
begin_define
DECL|macro|ErrRaster_Invalid_Argument
define|#
directive|define
name|ErrRaster_Invalid_Argument
value|-3
end_define
begin_define
DECL|macro|ErrRaster_Memory_Overflow
define|#
directive|define
name|ErrRaster_Memory_Overflow
value|-4
end_define
begin_define
DECL|macro|FT_BEGIN_HEADER
define|#
directive|define
name|FT_BEGIN_HEADER
end_define
begin_define
DECL|macro|FT_END_HEADER
define|#
directive|define
name|FT_END_HEADER
end_define
begin_include
include|#
directive|include
file|"ftimage.h"
end_include
begin_include
include|#
directive|include
file|"ftgrays.h"
end_include
begin_comment
comment|/* This macro is used to indicate that a function parameter is unused. */
end_comment
begin_comment
comment|/* Its purpose is simply to reduce compiler warnings.  Note also that  */
end_comment
begin_comment
comment|/* simply defining it as `(void)x' doesn't avoid warnings with certain */
end_comment
begin_comment
comment|/* ANSI compilers (e.g. LCC).                                          */
end_comment
begin_define
DECL|macro|FT_UNUSED
define|#
directive|define
name|FT_UNUSED
parameter_list|(
name|x
parameter_list|)
value|(x) = (x)
end_define
begin_comment
comment|/* we only use level 5& 7 tracing messages; cf. ftdebug.h */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|FT_DEBUG_LEVEL_TRACE
end_ifdef
begin_function
name|void
DECL|function|FT_Message
name|FT_Message
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* empty function useful for setting a breakpoint to catch errors */
end_comment
begin_function
name|int
DECL|function|FT_Throw
name|FT_Throw
parameter_list|(
name|int
name|error
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|)
block|{
name|FT_UNUSED
argument_list|(
name|error
argument_list|)
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|file
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/* we don't handle tracing levels in stand-alone mode; */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|FT_TRACE5
end_ifndef
begin_define
DECL|macro|FT_TRACE5
define|#
directive|define
name|FT_TRACE5
parameter_list|(
name|varformat
parameter_list|)
value|FT_Message varformat
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|FT_TRACE7
end_ifndef
begin_define
DECL|macro|FT_TRACE7
define|#
directive|define
name|FT_TRACE7
parameter_list|(
name|varformat
parameter_list|)
value|FT_Message varformat
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|FT_ERROR
end_ifndef
begin_define
DECL|macro|FT_ERROR
define|#
directive|define
name|FT_ERROR
parameter_list|(
name|varformat
parameter_list|)
value|FT_Message varformat
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|FT_THROW
define|#
directive|define
name|FT_THROW
parameter_list|(
name|e
parameter_list|)
define|\
value|( FT_Throw( FT_ERR_CAT( ErrRaster, e ),   \                       __LINE__,                     \                       __FILE__ )                  | \             FT_ERR_CAT( ErrRaster, e )            )
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* !FT_DEBUG_LEVEL_TRACE */
end_comment
begin_define
DECL|macro|FT_TRACE5
define|#
directive|define
name|FT_TRACE5
parameter_list|(
name|x
parameter_list|)
value|do { } while ( 0 )
end_define
begin_comment
DECL|macro|FT_TRACE5
comment|/* nothing */
end_comment
begin_define
DECL|macro|FT_TRACE7
define|#
directive|define
name|FT_TRACE7
parameter_list|(
name|x
parameter_list|)
value|do { } while ( 0 )
end_define
begin_comment
DECL|macro|FT_TRACE7
comment|/* nothing */
end_comment
begin_define
DECL|macro|FT_ERROR
define|#
directive|define
name|FT_ERROR
parameter_list|(
name|x
parameter_list|)
value|do { } while ( 0 )
end_define
begin_comment
DECL|macro|FT_ERROR
comment|/* nothing */
end_comment
begin_define
DECL|macro|FT_THROW
define|#
directive|define
name|FT_THROW
parameter_list|(
name|e
parameter_list|)
value|FT_ERR_CAT( ErrRaster_, e )
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* !FT_DEBUG_LEVEL_TRACE */
end_comment
begin_define
DECL|macro|FT_DEFINE_OUTLINE_FUNCS
define|#
directive|define
name|FT_DEFINE_OUTLINE_FUNCS
parameter_list|(
name|class_
parameter_list|,               \
name|move_to_
parameter_list|,
name|line_to_
parameter_list|,   \
name|conic_to_
parameter_list|,
name|cubic_to_
parameter_list|, \
name|shift_
parameter_list|,
name|delta_
parameter_list|)
define|\
value|static const FT_Outline_Funcs class_ =       \           {                                            \             move_to_,                                  \             line_to_,                                  \             conic_to_,                                 \             cubic_to_,                                 \             shift_,                                    \             delta_                                     \          };
end_define
begin_define
DECL|macro|FT_DEFINE_RASTER_FUNCS
define|#
directive|define
name|FT_DEFINE_RASTER_FUNCS
parameter_list|(
name|class_
parameter_list|,
name|glyph_format_
parameter_list|,            \
name|raster_new_
parameter_list|,
name|raster_reset_
parameter_list|,       \
name|raster_set_mode_
parameter_list|,
name|raster_render_
parameter_list|, \
name|raster_done_
parameter_list|)
define|\
value|const FT_Raster_Funcs class_ =                          \           {                                                       \             glyph_format_,                                        \             raster_new_,                                          \             raster_reset_,                                        \             raster_set_mode_,                                     \             raster_render_,                                       \             raster_done_                                          \          };
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* !_STANDALONE_ */
end_comment
begin_include
include|#
directive|include
file|<ft2build.h>
end_include
begin_include
include|#
directive|include
file|"ftgrays.h"
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_OBJECTS_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_DEBUG_H
end_include
begin_include
include|#
directive|include
include|FT_OUTLINE_H
end_include
begin_include
include|#
directive|include
file|"ftsmerrs.h"
end_include
begin_include
include|#
directive|include
file|"ftspic.h"
end_include
begin_define
DECL|macro|Smooth_Err_Invalid_Mode
define|#
directive|define
name|Smooth_Err_Invalid_Mode
value|Smooth_Err_Cannot_Render_Glyph
end_define
begin_define
DECL|macro|Smooth_Err_Memory_Overflow
define|#
directive|define
name|Smooth_Err_Memory_Overflow
value|Smooth_Err_Out_Of_Memory
end_define
begin_define
DECL|macro|ErrRaster_Memory_Overflow
define|#
directive|define
name|ErrRaster_Memory_Overflow
value|Smooth_Err_Out_Of_Memory
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* !_STANDALONE_ */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|FT_MEM_SET
end_ifndef
begin_define
DECL|macro|FT_MEM_SET
define|#
directive|define
name|FT_MEM_SET
parameter_list|(
name|d
parameter_list|,
name|s
parameter_list|,
name|c
parameter_list|)
value|ft_memset( d, s, c )
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|FT_MEM_ZERO
end_ifndef
begin_define
DECL|macro|FT_MEM_ZERO
define|#
directive|define
name|FT_MEM_ZERO
parameter_list|(
name|dest
parameter_list|,
name|count
parameter_list|)
value|FT_MEM_SET( dest, 0, count )
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* as usual, for the speed hungry :-) */
end_comment
begin_undef
DECL|macro|RAS_ARG
undef|#
directive|undef
name|RAS_ARG
end_undef
begin_undef
DECL|macro|RAS_ARG_
undef|#
directive|undef
name|RAS_ARG_
end_undef
begin_undef
DECL|macro|RAS_VAR
undef|#
directive|undef
name|RAS_VAR
end_undef
begin_undef
DECL|macro|RAS_VAR_
undef|#
directive|undef
name|RAS_VAR_
end_undef
begin_ifndef
ifndef|#
directive|ifndef
name|FT_STATIC_RASTER
end_ifndef
begin_define
DECL|macro|RAS_ARG
define|#
directive|define
name|RAS_ARG
value|gray_PWorker  worker
end_define
begin_define
DECL|macro|RAS_ARG_
define|#
directive|define
name|RAS_ARG_
value|gray_PWorker  worker,
end_define
begin_define
DECL|macro|RAS_VAR
define|#
directive|define
name|RAS_VAR
value|worker
end_define
begin_define
DECL|macro|RAS_VAR_
define|#
directive|define
name|RAS_VAR_
value|worker,
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* FT_STATIC_RASTER */
end_comment
begin_define
DECL|macro|RAS_ARG
define|#
directive|define
name|RAS_ARG
end_define
begin_comment
DECL|macro|RAS_ARG
comment|/* empty */
end_comment
begin_define
DECL|macro|RAS_ARG_
define|#
directive|define
name|RAS_ARG_
end_define
begin_comment
DECL|macro|RAS_ARG_
comment|/* empty */
end_comment
begin_define
DECL|macro|RAS_VAR
define|#
directive|define
name|RAS_VAR
end_define
begin_comment
DECL|macro|RAS_VAR
comment|/* empty */
end_comment
begin_define
DECL|macro|RAS_VAR_
define|#
directive|define
name|RAS_VAR_
end_define
begin_comment
DECL|macro|RAS_VAR_
comment|/* empty */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* FT_STATIC_RASTER */
end_comment
begin_comment
comment|/* must be at least 6 bits! */
end_comment
begin_define
DECL|macro|PIXEL_BITS
define|#
directive|define
name|PIXEL_BITS
value|8
end_define
begin_undef
DECL|macro|FLOOR
undef|#
directive|undef
name|FLOOR
end_undef
begin_undef
DECL|macro|CEILING
undef|#
directive|undef
name|CEILING
end_undef
begin_undef
DECL|macro|TRUNC
undef|#
directive|undef
name|TRUNC
end_undef
begin_undef
DECL|macro|SCALED
undef|#
directive|undef
name|SCALED
end_undef
begin_define
DECL|macro|ONE_PIXEL
define|#
directive|define
name|ONE_PIXEL
value|( 1L<< PIXEL_BITS )
end_define
begin_define
DECL|macro|PIXEL_MASK
define|#
directive|define
name|PIXEL_MASK
value|( -1L<< PIXEL_BITS )
end_define
begin_define
DECL|macro|TRUNC
define|#
directive|define
name|TRUNC
parameter_list|(
name|x
parameter_list|)
value|( (TCoord)( (x)>> PIXEL_BITS ) )
end_define
begin_define
DECL|macro|SUBPIXELS
define|#
directive|define
name|SUBPIXELS
parameter_list|(
name|x
parameter_list|)
value|( (TPos)(x)<< PIXEL_BITS )
end_define
begin_define
DECL|macro|FLOOR
define|#
directive|define
name|FLOOR
parameter_list|(
name|x
parameter_list|)
value|( (x)& -ONE_PIXEL )
end_define
begin_define
DECL|macro|CEILING
define|#
directive|define
name|CEILING
parameter_list|(
name|x
parameter_list|)
value|( ( (x) + ONE_PIXEL - 1 )& -ONE_PIXEL )
end_define
begin_define
DECL|macro|ROUND
define|#
directive|define
name|ROUND
parameter_list|(
name|x
parameter_list|)
value|( ( (x) + ONE_PIXEL / 2 )& -ONE_PIXEL )
end_define
begin_if
if|#
directive|if
name|PIXEL_BITS
operator|>=
literal|6
end_if
begin_define
DECL|macro|UPSCALE
define|#
directive|define
name|UPSCALE
parameter_list|(
name|x
parameter_list|)
value|( (x)<< ( PIXEL_BITS - 6 ) )
end_define
begin_define
DECL|macro|DOWNSCALE
define|#
directive|define
name|DOWNSCALE
parameter_list|(
name|x
parameter_list|)
value|( (x)>> ( PIXEL_BITS - 6 ) )
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|UPSCALE
define|#
directive|define
name|UPSCALE
parameter_list|(
name|x
parameter_list|)
value|( (x)>> ( 6 - PIXEL_BITS ) )
end_define
begin_define
DECL|macro|DOWNSCALE
define|#
directive|define
name|DOWNSCALE
parameter_list|(
name|x
parameter_list|)
value|( (x)<< ( 6 - PIXEL_BITS ) )
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* Compute `dividend / divisor' and return both its quotient and     */
end_comment
begin_comment
comment|/* remainder, cast to a specific type.  This macro also ensures that */
end_comment
begin_comment
comment|/* the remainder is always positive.                                 */
end_comment
begin_define
DECL|macro|FT_DIV_MOD
define|#
directive|define
name|FT_DIV_MOD
parameter_list|(
name|type
parameter_list|,
name|dividend
parameter_list|,
name|divisor
parameter_list|,
name|quotient
parameter_list|,
name|remainder
parameter_list|)
define|\
value|FT_BEGIN_STMNT                                                   \     (quotient)  = (type)( (dividend) / (divisor) );                \     (remainder) = (type)( (dividend) % (divisor) );                \     if ( (remainder)< 0 )                                         \     {                                                              \       (quotient)--;                                                \       (remainder) += (type)(divisor);                              \     }                                                              \   FT_END_STMNT
end_define
begin_ifdef
ifdef|#
directive|ifdef
name|__arm__
end_ifdef
begin_comment
comment|/* Work around a bug specific to GCC which make the compiler fail to */
end_comment
begin_comment
comment|/* optimize a division and modulo operation on the same parameters   */
end_comment
begin_comment
comment|/* into a single call to `__aeabi_idivmod'.  See                     */
end_comment
begin_comment
comment|/*                                                                   */
end_comment
begin_comment
comment|/*  http://gcc.gnu.org/bugzilla/show_bug.cgi?id=43721                */
end_comment
begin_undef
DECL|macro|FT_DIV_MOD
undef|#
directive|undef
name|FT_DIV_MOD
end_undef
begin_define
DECL|macro|FT_DIV_MOD
define|#
directive|define
name|FT_DIV_MOD
parameter_list|(
name|type
parameter_list|,
name|dividend
parameter_list|,
name|divisor
parameter_list|,
name|quotient
parameter_list|,
name|remainder
parameter_list|)
define|\
value|FT_BEGIN_STMNT                                                   \     (quotient)  = (type)( (dividend) / (divisor) );                \     (remainder) = (type)( (dividend) - (quotient) * (divisor) );   \     if ( (remainder)< 0 )                                         \     {                                                              \       (quotient)--;                                                \       (remainder) += (type)(divisor);                              \     }                                                              \   FT_END_STMNT
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* __arm__ */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*   TYPE DEFINITIONS                                                    */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* don't change the following types to FT_Int or FT_Pos, since we might */
end_comment
begin_comment
comment|/* need to define them to "float" or "double" when experimenting with   */
end_comment
begin_comment
comment|/* new algorithms                                                       */
end_comment
begin_typedef
DECL|typedef|TCoord
typedef|typedef
name|long
name|TCoord
typedef|;
end_typedef
begin_comment
DECL|typedef|TCoord
comment|/* integer scanline/pixel coordinate */
end_comment
begin_typedef
DECL|typedef|TPos
typedef|typedef
name|long
name|TPos
typedef|;
end_typedef
begin_comment
DECL|typedef|TPos
comment|/* sub-pixel coordinate              */
end_comment
begin_comment
comment|/* determine the type used to store cell areas.  This normally takes at */
end_comment
begin_comment
comment|/* least PIXEL_BITS*2 + 1 bits.  On 16-bit systems, we need to use      */
end_comment
begin_comment
comment|/* `long' instead of `int', otherwise bad things happen                 */
end_comment
begin_if
if|#
directive|if
name|PIXEL_BITS
operator|<=
literal|7
end_if
begin_typedef
DECL|typedef|TArea
typedef|typedef
name|int
name|TArea
typedef|;
end_typedef
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* PIXEL_BITS>= 8 */
end_comment
begin_comment
comment|/* approximately determine the size of integers using an ANSI-C header */
end_comment
begin_if
if|#
directive|if
name|FT_UINT_MAX
operator|==
literal|0xFFFFU
end_if
begin_typedef
DECL|typedef|TArea
typedef|typedef
name|long
name|TArea
typedef|;
end_typedef
begin_else
else|#
directive|else
end_else
begin_typedef
DECL|typedef|TArea
typedef|typedef
name|int
name|TArea
typedef|;
end_typedef
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* PIXEL_BITS>= 8 */
end_comment
begin_comment
comment|/* maximum number of gray spans in a call to the span callback */
end_comment
begin_define
DECL|macro|FT_MAX_GRAY_SPANS
define|#
directive|define
name|FT_MAX_GRAY_SPANS
value|32
end_define
begin_typedef
DECL|typedef|PCell
typedef|typedef
name|struct
name|TCell_
modifier|*
name|PCell
typedef|;
end_typedef
begin_typedef
DECL|struct|TCell_
typedef|typedef
struct|struct
name|TCell_
block|{
DECL|member|x
name|TPos
name|x
decl_stmt|;
comment|/* same with gray_TWorker.ex    */
DECL|member|cover
name|TCoord
name|cover
decl_stmt|;
comment|/* same with gray_TWorker.cover */
DECL|member|area
name|TArea
name|area
decl_stmt|;
DECL|member|next
name|PCell
name|next
decl_stmt|;
block|}
DECL|typedef|TCell
name|TCell
typedef|;
end_typedef
begin_if
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
end_if
begin_comment
comment|/* Visual C++ (and Intel C++) */
end_comment
begin_comment
comment|/* We disable the warning `structure was padded due to   */
end_comment
begin_comment
comment|/* __declspec(align())' in order to compile cleanly with */
end_comment
begin_comment
comment|/* the maximum level of warnings.                        */
end_comment
begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|push
name|)
end_pragma
begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4324
name|)
end_pragma
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* _MSC_VER */
end_comment
begin_typedef
DECL|struct|gray_TWorker_
typedef|typedef
struct|struct
name|gray_TWorker_
block|{
DECL|member|jump_buffer
name|ft_jmp_buf
name|jump_buffer
decl_stmt|;
DECL|member|ex
DECL|member|ey
name|TCoord
name|ex
decl_stmt|,
name|ey
decl_stmt|;
DECL|member|min_ex
DECL|member|max_ex
name|TPos
name|min_ex
decl_stmt|,
name|max_ex
decl_stmt|;
DECL|member|min_ey
DECL|member|max_ey
name|TPos
name|min_ey
decl_stmt|,
name|max_ey
decl_stmt|;
DECL|member|count_ex
DECL|member|count_ey
name|TPos
name|count_ex
decl_stmt|,
name|count_ey
decl_stmt|;
DECL|member|area
name|TArea
name|area
decl_stmt|;
DECL|member|cover
name|TCoord
name|cover
decl_stmt|;
DECL|member|invalid
name|int
name|invalid
decl_stmt|;
DECL|member|cells
name|PCell
name|cells
decl_stmt|;
DECL|member|max_cells
name|FT_PtrDist
name|max_cells
decl_stmt|;
DECL|member|num_cells
name|FT_PtrDist
name|num_cells
decl_stmt|;
DECL|member|cx
DECL|member|cy
name|TCoord
name|cx
decl_stmt|,
name|cy
decl_stmt|;
DECL|member|x
DECL|member|y
name|TPos
name|x
decl_stmt|,
name|y
decl_stmt|;
DECL|member|last_ey
name|TPos
name|last_ey
decl_stmt|;
DECL|member|bez_stack
name|FT_Vector
name|bez_stack
index|[
literal|32
operator|*
literal|3
operator|+
literal|1
index|]
decl_stmt|;
DECL|member|lev_stack
name|int
name|lev_stack
index|[
literal|32
index|]
decl_stmt|;
DECL|member|outline
name|FT_Outline
name|outline
decl_stmt|;
DECL|member|target
name|FT_Bitmap
name|target
decl_stmt|;
DECL|member|clip_box
name|FT_BBox
name|clip_box
decl_stmt|;
DECL|member|gray_spans
name|FT_Span
name|gray_spans
index|[
name|FT_MAX_GRAY_SPANS
index|]
decl_stmt|;
DECL|member|num_gray_spans
name|int
name|num_gray_spans
decl_stmt|;
DECL|member|render_span
name|FT_Raster_Span_Func
name|render_span
decl_stmt|;
DECL|member|render_span_data
name|void
modifier|*
name|render_span_data
decl_stmt|;
DECL|member|span_y
name|int
name|span_y
decl_stmt|;
DECL|member|band_size
name|int
name|band_size
decl_stmt|;
DECL|member|band_shoot
name|int
name|band_shoot
decl_stmt|;
DECL|member|buffer
name|void
modifier|*
name|buffer
decl_stmt|;
DECL|member|buffer_size
name|long
name|buffer_size
decl_stmt|;
DECL|member|ycells
name|PCell
modifier|*
name|ycells
decl_stmt|;
DECL|member|ycount
name|TPos
name|ycount
decl_stmt|;
block|}
DECL|typedef|gray_TWorker
DECL|typedef|gray_PWorker
name|gray_TWorker
operator|,
typedef|*
name|gray_PWorker
typedef|;
end_typedef
begin_if
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
end_if
begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|pop
name|)
end_pragma
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|FT_STATIC_RASTER
end_ifndef
begin_define
DECL|macro|ras
define|#
directive|define
name|ras
value|(*worker)
end_define
begin_else
else|#
directive|else
end_else
begin_decl_stmt
DECL|variable|ras
specifier|static
name|gray_TWorker
name|ras
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_typedef
DECL|struct|gray_TRaster_
typedef|typedef
struct|struct
name|gray_TRaster_
block|{
DECL|member|buffer
name|void
modifier|*
name|buffer
decl_stmt|;
DECL|member|buffer_size
name|long
name|buffer_size
decl_stmt|;
DECL|member|band_size
name|int
name|band_size
decl_stmt|;
DECL|member|memory
name|void
modifier|*
name|memory
decl_stmt|;
DECL|member|worker
name|gray_PWorker
name|worker
decl_stmt|;
block|}
DECL|typedef|gray_TRaster
DECL|typedef|gray_PRaster
name|gray_TRaster
operator|,
typedef|*
name|gray_PRaster
typedef|;
end_typedef
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* Initialize the cells table.                                           */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|gray_init_cells
name|gray_init_cells
parameter_list|(
name|RAS_ARG_
name|void
modifier|*
name|buffer
parameter_list|,
name|long
name|byte_size
parameter_list|)
block|{
name|ras
operator|.
name|buffer
operator|=
name|buffer
expr_stmt|;
name|ras
operator|.
name|buffer_size
operator|=
name|byte_size
expr_stmt|;
name|ras
operator|.
name|ycells
operator|=
operator|(
name|PCell
operator|*
operator|)
name|buffer
expr_stmt|;
name|ras
operator|.
name|cells
operator|=
name|NULL
expr_stmt|;
name|ras
operator|.
name|max_cells
operator|=
literal|0
expr_stmt|;
name|ras
operator|.
name|num_cells
operator|=
literal|0
expr_stmt|;
name|ras
operator|.
name|area
operator|=
literal|0
expr_stmt|;
name|ras
operator|.
name|cover
operator|=
literal|0
expr_stmt|;
name|ras
operator|.
name|invalid
operator|=
literal|1
expr_stmt|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* Compute the outline bounding box.                                     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|gray_compute_cbox
name|gray_compute_cbox
parameter_list|(
name|RAS_ARG
parameter_list|)
block|{
name|FT_Outline
modifier|*
name|outline
init|=
operator|&
name|ras
operator|.
name|outline
decl_stmt|;
name|FT_Vector
modifier|*
name|vec
init|=
name|outline
operator|->
name|points
decl_stmt|;
name|FT_Vector
modifier|*
name|limit
init|=
name|vec
operator|+
name|outline
operator|->
name|n_points
decl_stmt|;
if|if
condition|(
name|outline
operator|->
name|n_points
operator|<=
literal|0
condition|)
block|{
name|ras
operator|.
name|min_ex
operator|=
name|ras
operator|.
name|max_ex
operator|=
literal|0
expr_stmt|;
name|ras
operator|.
name|min_ey
operator|=
name|ras
operator|.
name|max_ey
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|ras
operator|.
name|min_ex
operator|=
name|ras
operator|.
name|max_ex
operator|=
name|vec
operator|->
name|x
expr_stmt|;
name|ras
operator|.
name|min_ey
operator|=
name|ras
operator|.
name|max_ey
operator|=
name|vec
operator|->
name|y
expr_stmt|;
name|vec
operator|++
expr_stmt|;
for|for
control|(
init|;
name|vec
operator|<
name|limit
condition|;
name|vec
operator|++
control|)
block|{
name|TPos
name|x
init|=
name|vec
operator|->
name|x
decl_stmt|;
name|TPos
name|y
init|=
name|vec
operator|->
name|y
decl_stmt|;
if|if
condition|(
name|x
operator|<
name|ras
operator|.
name|min_ex
condition|)
name|ras
operator|.
name|min_ex
operator|=
name|x
expr_stmt|;
if|if
condition|(
name|x
operator|>
name|ras
operator|.
name|max_ex
condition|)
name|ras
operator|.
name|max_ex
operator|=
name|x
expr_stmt|;
if|if
condition|(
name|y
operator|<
name|ras
operator|.
name|min_ey
condition|)
name|ras
operator|.
name|min_ey
operator|=
name|y
expr_stmt|;
if|if
condition|(
name|y
operator|>
name|ras
operator|.
name|max_ey
condition|)
name|ras
operator|.
name|max_ey
operator|=
name|y
expr_stmt|;
block|}
comment|/* truncate the bounding box to integer pixels */
name|ras
operator|.
name|min_ex
operator|=
name|ras
operator|.
name|min_ex
operator|>>
literal|6
expr_stmt|;
name|ras
operator|.
name|min_ey
operator|=
name|ras
operator|.
name|min_ey
operator|>>
literal|6
expr_stmt|;
name|ras
operator|.
name|max_ex
operator|=
operator|(
name|ras
operator|.
name|max_ex
operator|+
literal|63
operator|)
operator|>>
literal|6
expr_stmt|;
name|ras
operator|.
name|max_ey
operator|=
operator|(
name|ras
operator|.
name|max_ey
operator|+
literal|63
operator|)
operator|>>
literal|6
expr_stmt|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* Record the current cell in the table.                                 */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|PCell
DECL|function|gray_find_cell
name|gray_find_cell
parameter_list|(
name|RAS_ARG
parameter_list|)
block|{
name|PCell
modifier|*
name|pcell
decl_stmt|,
name|cell
decl_stmt|;
name|TPos
name|x
init|=
name|ras
operator|.
name|ex
decl_stmt|;
if|if
condition|(
name|x
operator|>
name|ras
operator|.
name|count_ex
condition|)
name|x
operator|=
name|ras
operator|.
name|count_ex
expr_stmt|;
name|pcell
operator|=
operator|&
name|ras
operator|.
name|ycells
index|[
name|ras
operator|.
name|ey
index|]
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|cell
operator|=
operator|*
name|pcell
expr_stmt|;
if|if
condition|(
name|cell
operator|==
name|NULL
operator|||
name|cell
operator|->
name|x
operator|>
name|x
condition|)
break|break;
if|if
condition|(
name|cell
operator|->
name|x
operator|==
name|x
condition|)
goto|goto
name|Exit
goto|;
name|pcell
operator|=
operator|&
name|cell
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|ras
operator|.
name|num_cells
operator|>=
name|ras
operator|.
name|max_cells
condition|)
name|ft_longjmp
argument_list|(
name|ras
operator|.
name|jump_buffer
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cell
operator|=
name|ras
operator|.
name|cells
operator|+
name|ras
operator|.
name|num_cells
operator|++
expr_stmt|;
name|cell
operator|->
name|x
operator|=
name|x
expr_stmt|;
name|cell
operator|->
name|area
operator|=
literal|0
expr_stmt|;
name|cell
operator|->
name|cover
operator|=
literal|0
expr_stmt|;
name|cell
operator|->
name|next
operator|=
operator|*
name|pcell
expr_stmt|;
operator|*
name|pcell
operator|=
name|cell
expr_stmt|;
name|Exit
label|:
return|return
name|cell
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|gray_record_cell
name|gray_record_cell
parameter_list|(
name|RAS_ARG
parameter_list|)
block|{
if|if
condition|(
name|ras
operator|.
name|area
operator||
name|ras
operator|.
name|cover
condition|)
block|{
name|PCell
name|cell
init|=
name|gray_find_cell
argument_list|(
name|RAS_VAR
argument_list|)
decl_stmt|;
name|cell
operator|->
name|area
operator|+=
name|ras
operator|.
name|area
expr_stmt|;
name|cell
operator|->
name|cover
operator|+=
name|ras
operator|.
name|cover
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* Set the current cell to a new position.                               */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|gray_set_cell
name|gray_set_cell
parameter_list|(
name|RAS_ARG_
name|TCoord
name|ex
parameter_list|,
name|TCoord
name|ey
parameter_list|)
block|{
comment|/* Move the cell pointer to a new position.  We set the `invalid'      */
comment|/* flag to indicate that the cell isn't part of those we're interested */
comment|/* in during the render phase.  This means that:                       */
comment|/*                                                                     */
comment|/* . the new vertical position must be within min_ey..max_ey-1.        */
comment|/* . the new horizontal position must be strictly less than max_ex     */
comment|/*                                                                     */
comment|/* Note that if a cell is to the left of the clipping region, it is    */
comment|/* actually set to the (min_ex-1) horizontal position.                 */
comment|/* All cells that are on the left of the clipping region go to the */
comment|/* min_ex - 1 horizontal position.                                 */
name|ey
operator|-=
name|ras
operator|.
name|min_ey
expr_stmt|;
if|if
condition|(
name|ex
operator|>
name|ras
operator|.
name|max_ex
condition|)
name|ex
operator|=
name|ras
operator|.
name|max_ex
expr_stmt|;
name|ex
operator|-=
name|ras
operator|.
name|min_ex
expr_stmt|;
if|if
condition|(
name|ex
operator|<
literal|0
condition|)
name|ex
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* are we moving to a different cell ? */
if|if
condition|(
name|ex
operator|!=
name|ras
operator|.
name|ex
operator|||
name|ey
operator|!=
name|ras
operator|.
name|ey
condition|)
block|{
comment|/* record the current one if it is valid */
if|if
condition|(
operator|!
name|ras
operator|.
name|invalid
condition|)
name|gray_record_cell
argument_list|(
name|RAS_VAR
argument_list|)
expr_stmt|;
name|ras
operator|.
name|area
operator|=
literal|0
expr_stmt|;
name|ras
operator|.
name|cover
operator|=
literal|0
expr_stmt|;
name|ras
operator|.
name|ex
operator|=
name|ex
expr_stmt|;
name|ras
operator|.
name|ey
operator|=
name|ey
expr_stmt|;
block|}
name|ras
operator|.
name|invalid
operator|=
operator|(
operator|(
name|unsigned
operator|)
name|ey
operator|>=
operator|(
name|unsigned
operator|)
name|ras
operator|.
name|count_ey
operator|||
name|ex
operator|>=
name|ras
operator|.
name|count_ex
operator|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* Start a new contour at a given cell.                                  */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|gray_start_cell
name|gray_start_cell
parameter_list|(
name|RAS_ARG_
name|TCoord
name|ex
parameter_list|,
name|TCoord
name|ey
parameter_list|)
block|{
if|if
condition|(
name|ex
operator|>
name|ras
operator|.
name|max_ex
condition|)
name|ex
operator|=
call|(
name|TCoord
call|)
argument_list|(
name|ras
operator|.
name|max_ex
argument_list|)
expr_stmt|;
if|if
condition|(
name|ex
operator|<
name|ras
operator|.
name|min_ex
condition|)
name|ex
operator|=
call|(
name|TCoord
call|)
argument_list|(
name|ras
operator|.
name|min_ex
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ras
operator|.
name|area
operator|=
literal|0
expr_stmt|;
name|ras
operator|.
name|cover
operator|=
literal|0
expr_stmt|;
name|ras
operator|.
name|ex
operator|=
name|ex
operator|-
name|ras
operator|.
name|min_ex
expr_stmt|;
name|ras
operator|.
name|ey
operator|=
name|ey
operator|-
name|ras
operator|.
name|min_ey
expr_stmt|;
name|ras
operator|.
name|last_ey
operator|=
name|SUBPIXELS
argument_list|(
name|ey
argument_list|)
expr_stmt|;
name|ras
operator|.
name|invalid
operator|=
literal|0
expr_stmt|;
name|gray_set_cell
argument_list|(
argument|RAS_VAR_ ex
argument_list|,
argument|ey
argument_list|)
empty_stmt|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* Render a scanline as one or more cells.                               */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|gray_render_scanline
name|gray_render_scanline
parameter_list|(
name|RAS_ARG_
name|TCoord
name|ey
parameter_list|,
name|TPos
name|x1
parameter_list|,
name|TCoord
name|y1
parameter_list|,
name|TPos
name|x2
parameter_list|,
name|TCoord
name|y2
parameter_list|)
block|{
name|TCoord
name|ex1
decl_stmt|,
name|ex2
decl_stmt|,
name|fx1
decl_stmt|,
name|fx2
decl_stmt|,
name|delta
decl_stmt|,
name|mod
decl_stmt|;
name|long
name|p
decl_stmt|,
name|first
decl_stmt|,
name|dx
decl_stmt|;
name|int
name|incr
decl_stmt|;
name|dx
operator|=
name|x2
operator|-
name|x1
expr_stmt|;
name|ex1
operator|=
name|TRUNC
argument_list|(
name|x1
argument_list|)
expr_stmt|;
name|ex2
operator|=
name|TRUNC
argument_list|(
name|x2
argument_list|)
expr_stmt|;
name|fx1
operator|=
call|(
name|TCoord
call|)
argument_list|(
name|x1
operator|-
name|SUBPIXELS
argument_list|(
name|ex1
argument_list|)
argument_list|)
expr_stmt|;
name|fx2
operator|=
call|(
name|TCoord
call|)
argument_list|(
name|x2
operator|-
name|SUBPIXELS
argument_list|(
name|ex2
argument_list|)
argument_list|)
expr_stmt|;
comment|/* trivial case.  Happens often */
if|if
condition|(
name|y1
operator|==
name|y2
condition|)
block|{
name|gray_set_cell
argument_list|(
argument|RAS_VAR_ ex2
argument_list|,
argument|ey
argument_list|)
empty_stmt|;
return|return;
block|}
comment|/* everything is located in a single cell.  That is easy! */
comment|/*                                                        */
if|if
condition|(
name|ex1
operator|==
name|ex2
condition|)
block|{
name|delta
operator|=
name|y2
operator|-
name|y1
expr_stmt|;
name|ras
operator|.
name|area
operator|+=
call|(
name|TArea
call|)
argument_list|(
operator|(
name|fx1
operator|+
name|fx2
operator|)
operator|*
name|delta
argument_list|)
expr_stmt|;
name|ras
operator|.
name|cover
operator|+=
name|delta
expr_stmt|;
return|return;
block|}
comment|/* ok, we'll have to render a run of adjacent cells on the same */
comment|/* scanline...                                                  */
comment|/*                                                              */
name|p
operator|=
operator|(
name|ONE_PIXEL
operator|-
name|fx1
operator|)
operator|*
operator|(
name|y2
operator|-
name|y1
operator|)
expr_stmt|;
name|first
operator|=
name|ONE_PIXEL
expr_stmt|;
name|incr
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|dx
operator|<
literal|0
condition|)
block|{
name|p
operator|=
name|fx1
operator|*
operator|(
name|y2
operator|-
name|y1
operator|)
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
name|incr
operator|=
operator|-
literal|1
expr_stmt|;
name|dx
operator|=
operator|-
name|dx
expr_stmt|;
block|}
name|FT_DIV_MOD
argument_list|(
name|TCoord
argument_list|,
name|p
argument_list|,
name|dx
argument_list|,
name|delta
argument_list|,
name|mod
argument_list|)
expr_stmt|;
name|ras
operator|.
name|area
operator|+=
call|(
name|TArea
call|)
argument_list|(
operator|(
name|fx1
operator|+
name|first
operator|)
operator|*
name|delta
argument_list|)
expr_stmt|;
name|ras
operator|.
name|cover
operator|+=
name|delta
expr_stmt|;
name|ex1
operator|+=
name|incr
expr_stmt|;
name|gray_set_cell
argument_list|(
argument|RAS_VAR_ ex1
argument_list|,
argument|ey
argument_list|)
empty_stmt|;
name|y1
operator|+=
name|delta
expr_stmt|;
if|if
condition|(
name|ex1
operator|!=
name|ex2
condition|)
block|{
name|TCoord
name|lift
decl_stmt|,
name|rem
decl_stmt|;
name|p
operator|=
name|ONE_PIXEL
operator|*
operator|(
name|y2
operator|-
name|y1
operator|+
name|delta
operator|)
expr_stmt|;
name|FT_DIV_MOD
argument_list|(
name|TCoord
argument_list|,
name|p
argument_list|,
name|dx
argument_list|,
name|lift
argument_list|,
name|rem
argument_list|)
expr_stmt|;
name|mod
operator|-=
operator|(
name|int
operator|)
name|dx
expr_stmt|;
while|while
condition|(
name|ex1
operator|!=
name|ex2
condition|)
block|{
name|delta
operator|=
name|lift
expr_stmt|;
name|mod
operator|+=
name|rem
expr_stmt|;
if|if
condition|(
name|mod
operator|>=
literal|0
condition|)
block|{
name|mod
operator|-=
operator|(
name|TCoord
operator|)
name|dx
expr_stmt|;
name|delta
operator|++
expr_stmt|;
block|}
name|ras
operator|.
name|area
operator|+=
call|(
name|TArea
call|)
argument_list|(
name|ONE_PIXEL
operator|*
name|delta
argument_list|)
expr_stmt|;
name|ras
operator|.
name|cover
operator|+=
name|delta
expr_stmt|;
name|y1
operator|+=
name|delta
expr_stmt|;
name|ex1
operator|+=
name|incr
expr_stmt|;
name|gray_set_cell
argument_list|(
argument|RAS_VAR_ ex1
argument_list|,
argument|ey
argument_list|)
empty_stmt|;
block|}
block|}
name|delta
operator|=
name|y2
operator|-
name|y1
expr_stmt|;
name|ras
operator|.
name|area
operator|+=
call|(
name|TArea
call|)
argument_list|(
operator|(
name|fx2
operator|+
name|ONE_PIXEL
operator|-
name|first
operator|)
operator|*
name|delta
argument_list|)
expr_stmt|;
name|ras
operator|.
name|cover
operator|+=
name|delta
expr_stmt|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* Render a given line as a series of scanlines.                         */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|gray_render_line
name|gray_render_line
parameter_list|(
name|RAS_ARG_
name|TPos
name|to_x
parameter_list|,
name|TPos
name|to_y
parameter_list|)
block|{
name|TCoord
name|ey1
decl_stmt|,
name|ey2
decl_stmt|,
name|fy1
decl_stmt|,
name|fy2
decl_stmt|,
name|mod
decl_stmt|;
name|TPos
name|dx
decl_stmt|,
name|dy
decl_stmt|,
name|x
decl_stmt|,
name|x2
decl_stmt|;
name|long
name|p
decl_stmt|,
name|first
decl_stmt|;
name|int
name|delta
decl_stmt|,
name|rem
decl_stmt|,
name|lift
decl_stmt|,
name|incr
decl_stmt|;
name|ey1
operator|=
name|TRUNC
argument_list|(
name|ras
operator|.
name|last_ey
argument_list|)
expr_stmt|;
name|ey2
operator|=
name|TRUNC
argument_list|(
name|to_y
argument_list|)
expr_stmt|;
comment|/* if (ey2>= ras.max_ey) ey2 = ras.max_ey-1; */
name|fy1
operator|=
call|(
name|TCoord
call|)
argument_list|(
name|ras
operator|.
name|y
operator|-
name|ras
operator|.
name|last_ey
argument_list|)
expr_stmt|;
name|fy2
operator|=
call|(
name|TCoord
call|)
argument_list|(
name|to_y
operator|-
name|SUBPIXELS
argument_list|(
name|ey2
argument_list|)
argument_list|)
expr_stmt|;
name|dx
operator|=
name|to_x
operator|-
name|ras
operator|.
name|x
expr_stmt|;
name|dy
operator|=
name|to_y
operator|-
name|ras
operator|.
name|y
expr_stmt|;
comment|/* perform vertical clipping */
block|{
name|TCoord
name|min
decl_stmt|,
name|max
decl_stmt|;
name|min
operator|=
name|ey1
expr_stmt|;
name|max
operator|=
name|ey2
expr_stmt|;
if|if
condition|(
name|ey1
operator|>
name|ey2
condition|)
block|{
name|min
operator|=
name|ey2
expr_stmt|;
name|max
operator|=
name|ey1
expr_stmt|;
block|}
if|if
condition|(
name|min
operator|>=
name|ras
operator|.
name|max_ey
operator|||
name|max
operator|<
name|ras
operator|.
name|min_ey
condition|)
goto|goto
name|End
goto|;
block|}
comment|/* everything is on a single scanline */
if|if
condition|(
name|ey1
operator|==
name|ey2
condition|)
block|{
name|gray_render_scanline
argument_list|(
argument|RAS_VAR_ ey1
argument_list|,
argument|ras.x
argument_list|,
argument|fy1
argument_list|,
argument|to_x
argument_list|,
argument|fy2
argument_list|)
empty_stmt|;
goto|goto
name|End
goto|;
block|}
comment|/* vertical line - avoid calling gray_render_scanline */
name|incr
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|dx
operator|==
literal|0
condition|)
block|{
name|TCoord
name|ex
init|=
name|TRUNC
argument_list|(
name|ras
operator|.
name|x
argument_list|)
decl_stmt|;
name|TCoord
name|two_fx
init|=
call|(
name|TCoord
call|)
argument_list|(
operator|(
name|ras
operator|.
name|x
operator|-
name|SUBPIXELS
argument_list|(
name|ex
argument_list|)
operator|)
operator|<<
literal|1
argument_list|)
decl_stmt|;
name|TArea
name|area
decl_stmt|;
name|first
operator|=
name|ONE_PIXEL
expr_stmt|;
if|if
condition|(
name|dy
operator|<
literal|0
condition|)
block|{
name|first
operator|=
literal|0
expr_stmt|;
name|incr
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|delta
operator|=
call|(
name|int
call|)
argument_list|(
name|first
operator|-
name|fy1
argument_list|)
expr_stmt|;
name|ras
operator|.
name|area
operator|+=
operator|(
name|TArea
operator|)
name|two_fx
operator|*
name|delta
expr_stmt|;
name|ras
operator|.
name|cover
operator|+=
name|delta
expr_stmt|;
name|ey1
operator|+=
name|incr
expr_stmt|;
name|gray_set_cell
argument_list|(
argument|RAS_VAR_ ex
argument_list|,
argument|ey1
argument_list|)
empty_stmt|;
name|delta
operator|=
call|(
name|int
call|)
argument_list|(
name|first
operator|+
name|first
operator|-
name|ONE_PIXEL
argument_list|)
expr_stmt|;
name|area
operator|=
operator|(
name|TArea
operator|)
name|two_fx
operator|*
name|delta
expr_stmt|;
while|while
condition|(
name|ey1
operator|!=
name|ey2
condition|)
block|{
name|ras
operator|.
name|area
operator|+=
name|area
expr_stmt|;
name|ras
operator|.
name|cover
operator|+=
name|delta
expr_stmt|;
name|ey1
operator|+=
name|incr
expr_stmt|;
name|gray_set_cell
argument_list|(
argument|RAS_VAR_ ex
argument_list|,
argument|ey1
argument_list|)
empty_stmt|;
block|}
name|delta
operator|=
call|(
name|int
call|)
argument_list|(
name|fy2
operator|-
name|ONE_PIXEL
operator|+
name|first
argument_list|)
expr_stmt|;
name|ras
operator|.
name|area
operator|+=
operator|(
name|TArea
operator|)
name|two_fx
operator|*
name|delta
expr_stmt|;
name|ras
operator|.
name|cover
operator|+=
name|delta
expr_stmt|;
goto|goto
name|End
goto|;
block|}
comment|/* ok, we have to render several scanlines */
name|p
operator|=
operator|(
name|ONE_PIXEL
operator|-
name|fy1
operator|)
operator|*
name|dx
expr_stmt|;
name|first
operator|=
name|ONE_PIXEL
expr_stmt|;
name|incr
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|dy
operator|<
literal|0
condition|)
block|{
name|p
operator|=
name|fy1
operator|*
name|dx
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
name|incr
operator|=
operator|-
literal|1
expr_stmt|;
name|dy
operator|=
operator|-
name|dy
expr_stmt|;
block|}
name|FT_DIV_MOD
argument_list|(
name|int
argument_list|,
name|p
argument_list|,
name|dy
argument_list|,
name|delta
argument_list|,
name|mod
argument_list|)
expr_stmt|;
name|x
operator|=
name|ras
operator|.
name|x
operator|+
name|delta
expr_stmt|;
name|gray_render_scanline
argument_list|(
argument|RAS_VAR_ ey1
argument_list|,
argument|ras.x
argument_list|,
argument|fy1
argument_list|,
argument|x
argument_list|,
argument|(TCoord)first
argument_list|)
empty_stmt|;
name|ey1
operator|+=
name|incr
expr_stmt|;
name|gray_set_cell
argument_list|(
argument|RAS_VAR_ TRUNC( x )
argument_list|,
argument|ey1
argument_list|)
empty_stmt|;
if|if
condition|(
name|ey1
operator|!=
name|ey2
condition|)
block|{
name|p
operator|=
name|ONE_PIXEL
operator|*
name|dx
expr_stmt|;
name|FT_DIV_MOD
argument_list|(
name|int
argument_list|,
name|p
argument_list|,
name|dy
argument_list|,
name|lift
argument_list|,
name|rem
argument_list|)
expr_stmt|;
name|mod
operator|-=
operator|(
name|int
operator|)
name|dy
expr_stmt|;
while|while
condition|(
name|ey1
operator|!=
name|ey2
condition|)
block|{
name|delta
operator|=
name|lift
expr_stmt|;
name|mod
operator|+=
name|rem
expr_stmt|;
if|if
condition|(
name|mod
operator|>=
literal|0
condition|)
block|{
name|mod
operator|-=
operator|(
name|int
operator|)
name|dy
expr_stmt|;
name|delta
operator|++
expr_stmt|;
block|}
name|x2
operator|=
name|x
operator|+
name|delta
expr_stmt|;
name|gray_render_scanline
argument_list|(
argument|RAS_VAR_ ey1
argument_list|,
argument|x
argument_list|,
argument|(TCoord)( ONE_PIXEL - first )
argument_list|,
argument|x2
argument_list|,
argument|(TCoord)first
argument_list|)
empty_stmt|;
name|x
operator|=
name|x2
expr_stmt|;
name|ey1
operator|+=
name|incr
expr_stmt|;
name|gray_set_cell
argument_list|(
argument|RAS_VAR_ TRUNC( x )
argument_list|,
argument|ey1
argument_list|)
empty_stmt|;
block|}
block|}
name|gray_render_scanline
argument_list|(
argument|RAS_VAR_ ey1
argument_list|,
argument|x
argument_list|,
argument|(TCoord)( ONE_PIXEL - first )
argument_list|,
argument|to_x
argument_list|,
argument|fy2
argument_list|)
empty_stmt|;
name|End
label|:
name|ras
operator|.
name|x
operator|=
name|to_x
expr_stmt|;
name|ras
operator|.
name|y
operator|=
name|to_y
expr_stmt|;
name|ras
operator|.
name|last_ey
operator|=
name|SUBPIXELS
argument_list|(
name|ey2
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|gray_split_conic
name|gray_split_conic
parameter_list|(
name|FT_Vector
modifier|*
name|base
parameter_list|)
block|{
name|TPos
name|a
decl_stmt|,
name|b
decl_stmt|;
name|base
index|[
literal|4
index|]
operator|.
name|x
operator|=
name|base
index|[
literal|2
index|]
operator|.
name|x
expr_stmt|;
name|b
operator|=
name|base
index|[
literal|1
index|]
operator|.
name|x
expr_stmt|;
name|a
operator|=
name|base
index|[
literal|3
index|]
operator|.
name|x
operator|=
operator|(
name|base
index|[
literal|2
index|]
operator|.
name|x
operator|+
name|b
operator|)
operator|/
literal|2
expr_stmt|;
name|b
operator|=
name|base
index|[
literal|1
index|]
operator|.
name|x
operator|=
operator|(
name|base
index|[
literal|0
index|]
operator|.
name|x
operator|+
name|b
operator|)
operator|/
literal|2
expr_stmt|;
name|base
index|[
literal|2
index|]
operator|.
name|x
operator|=
operator|(
name|a
operator|+
name|b
operator|)
operator|/
literal|2
expr_stmt|;
name|base
index|[
literal|4
index|]
operator|.
name|y
operator|=
name|base
index|[
literal|2
index|]
operator|.
name|y
expr_stmt|;
name|b
operator|=
name|base
index|[
literal|1
index|]
operator|.
name|y
expr_stmt|;
name|a
operator|=
name|base
index|[
literal|3
index|]
operator|.
name|y
operator|=
operator|(
name|base
index|[
literal|2
index|]
operator|.
name|y
operator|+
name|b
operator|)
operator|/
literal|2
expr_stmt|;
name|b
operator|=
name|base
index|[
literal|1
index|]
operator|.
name|y
operator|=
operator|(
name|base
index|[
literal|0
index|]
operator|.
name|y
operator|+
name|b
operator|)
operator|/
literal|2
expr_stmt|;
name|base
index|[
literal|2
index|]
operator|.
name|y
operator|=
operator|(
name|a
operator|+
name|b
operator|)
operator|/
literal|2
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|gray_render_conic
name|gray_render_conic
parameter_list|(
name|RAS_ARG_
specifier|const
name|FT_Vector
modifier|*
name|control
parameter_list|,
specifier|const
name|FT_Vector
modifier|*
name|to
parameter_list|)
block|{
name|TPos
name|dx
decl_stmt|,
name|dy
decl_stmt|;
name|TPos
name|min
decl_stmt|,
name|max
decl_stmt|,
name|y
decl_stmt|;
name|int
name|top
decl_stmt|,
name|level
decl_stmt|;
name|int
modifier|*
name|levels
decl_stmt|;
name|FT_Vector
modifier|*
name|arc
decl_stmt|;
name|levels
operator|=
name|ras
operator|.
name|lev_stack
expr_stmt|;
name|arc
operator|=
name|ras
operator|.
name|bez_stack
expr_stmt|;
name|arc
index|[
literal|0
index|]
operator|.
name|x
operator|=
name|UPSCALE
argument_list|(
name|to
operator|->
name|x
argument_list|)
expr_stmt|;
name|arc
index|[
literal|0
index|]
operator|.
name|y
operator|=
name|UPSCALE
argument_list|(
name|to
operator|->
name|y
argument_list|)
expr_stmt|;
name|arc
index|[
literal|1
index|]
operator|.
name|x
operator|=
name|UPSCALE
argument_list|(
name|control
operator|->
name|x
argument_list|)
expr_stmt|;
name|arc
index|[
literal|1
index|]
operator|.
name|y
operator|=
name|UPSCALE
argument_list|(
name|control
operator|->
name|y
argument_list|)
expr_stmt|;
name|arc
index|[
literal|2
index|]
operator|.
name|x
operator|=
name|ras
operator|.
name|x
expr_stmt|;
name|arc
index|[
literal|2
index|]
operator|.
name|y
operator|=
name|ras
operator|.
name|y
expr_stmt|;
name|top
operator|=
literal|0
expr_stmt|;
name|dx
operator|=
name|FT_ABS
argument_list|(
name|arc
index|[
literal|2
index|]
operator|.
name|x
operator|+
name|arc
index|[
literal|0
index|]
operator|.
name|x
operator|-
literal|2
operator|*
name|arc
index|[
literal|1
index|]
operator|.
name|x
argument_list|)
expr_stmt|;
name|dy
operator|=
name|FT_ABS
argument_list|(
name|arc
index|[
literal|2
index|]
operator|.
name|y
operator|+
name|arc
index|[
literal|0
index|]
operator|.
name|y
operator|-
literal|2
operator|*
name|arc
index|[
literal|1
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|dx
operator|<
name|dy
condition|)
name|dx
operator|=
name|dy
expr_stmt|;
if|if
condition|(
name|dx
operator|<
name|ONE_PIXEL
operator|/
literal|4
condition|)
goto|goto
name|Draw
goto|;
comment|/* short-cut the arc that crosses the current band */
name|min
operator|=
name|max
operator|=
name|arc
index|[
literal|0
index|]
operator|.
name|y
expr_stmt|;
name|y
operator|=
name|arc
index|[
literal|1
index|]
operator|.
name|y
expr_stmt|;
if|if
condition|(
name|y
operator|<
name|min
condition|)
name|min
operator|=
name|y
expr_stmt|;
if|if
condition|(
name|y
operator|>
name|max
condition|)
name|max
operator|=
name|y
expr_stmt|;
name|y
operator|=
name|arc
index|[
literal|2
index|]
operator|.
name|y
expr_stmt|;
if|if
condition|(
name|y
operator|<
name|min
condition|)
name|min
operator|=
name|y
expr_stmt|;
if|if
condition|(
name|y
operator|>
name|max
condition|)
name|max
operator|=
name|y
expr_stmt|;
if|if
condition|(
name|TRUNC
argument_list|(
name|min
argument_list|)
operator|>=
name|ras
operator|.
name|max_ey
operator|||
name|TRUNC
argument_list|(
name|max
argument_list|)
operator|<
name|ras
operator|.
name|min_ey
condition|)
goto|goto
name|Draw
goto|;
name|level
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|dx
operator|>>=
literal|2
expr_stmt|;
name|level
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|dx
operator|>
name|ONE_PIXEL
operator|/
literal|4
condition|)
do|;
name|levels
index|[
literal|0
index|]
operator|=
name|level
expr_stmt|;
do|do
block|{
name|level
operator|=
name|levels
index|[
name|top
index|]
expr_stmt|;
if|if
condition|(
name|level
operator|>
literal|0
condition|)
block|{
name|gray_split_conic
argument_list|(
name|arc
argument_list|)
expr_stmt|;
name|arc
operator|+=
literal|2
expr_stmt|;
name|top
operator|++
expr_stmt|;
name|levels
index|[
name|top
index|]
operator|=
name|levels
index|[
name|top
operator|-
literal|1
index|]
operator|=
name|level
operator|-
literal|1
expr_stmt|;
continue|continue;
block|}
name|Draw
label|:
name|gray_render_line
argument_list|(
argument|RAS_VAR_ arc[
literal|0
argument|].x
argument_list|,
argument|arc[
literal|0
argument|].y
argument_list|)
empty_stmt|;
name|top
operator|--
expr_stmt|;
name|arc
operator|-=
literal|2
expr_stmt|;
block|}
do|while
condition|(
name|top
operator|>=
literal|0
condition|)
do|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|gray_split_cubic
name|gray_split_cubic
parameter_list|(
name|FT_Vector
modifier|*
name|base
parameter_list|)
block|{
name|TPos
name|a
decl_stmt|,
name|b
decl_stmt|,
name|c
decl_stmt|,
name|d
decl_stmt|;
name|base
index|[
literal|6
index|]
operator|.
name|x
operator|=
name|base
index|[
literal|3
index|]
operator|.
name|x
expr_stmt|;
name|c
operator|=
name|base
index|[
literal|1
index|]
operator|.
name|x
expr_stmt|;
name|d
operator|=
name|base
index|[
literal|2
index|]
operator|.
name|x
expr_stmt|;
name|base
index|[
literal|1
index|]
operator|.
name|x
operator|=
name|a
operator|=
operator|(
name|base
index|[
literal|0
index|]
operator|.
name|x
operator|+
name|c
operator|)
operator|/
literal|2
expr_stmt|;
name|base
index|[
literal|5
index|]
operator|.
name|x
operator|=
name|b
operator|=
operator|(
name|base
index|[
literal|3
index|]
operator|.
name|x
operator|+
name|d
operator|)
operator|/
literal|2
expr_stmt|;
name|c
operator|=
operator|(
name|c
operator|+
name|d
operator|)
operator|/
literal|2
expr_stmt|;
name|base
index|[
literal|2
index|]
operator|.
name|x
operator|=
name|a
operator|=
operator|(
name|a
operator|+
name|c
operator|)
operator|/
literal|2
expr_stmt|;
name|base
index|[
literal|4
index|]
operator|.
name|x
operator|=
name|b
operator|=
operator|(
name|b
operator|+
name|c
operator|)
operator|/
literal|2
expr_stmt|;
name|base
index|[
literal|3
index|]
operator|.
name|x
operator|=
operator|(
name|a
operator|+
name|b
operator|)
operator|/
literal|2
expr_stmt|;
name|base
index|[
literal|6
index|]
operator|.
name|y
operator|=
name|base
index|[
literal|3
index|]
operator|.
name|y
expr_stmt|;
name|c
operator|=
name|base
index|[
literal|1
index|]
operator|.
name|y
expr_stmt|;
name|d
operator|=
name|base
index|[
literal|2
index|]
operator|.
name|y
expr_stmt|;
name|base
index|[
literal|1
index|]
operator|.
name|y
operator|=
name|a
operator|=
operator|(
name|base
index|[
literal|0
index|]
operator|.
name|y
operator|+
name|c
operator|)
operator|/
literal|2
expr_stmt|;
name|base
index|[
literal|5
index|]
operator|.
name|y
operator|=
name|b
operator|=
operator|(
name|base
index|[
literal|3
index|]
operator|.
name|y
operator|+
name|d
operator|)
operator|/
literal|2
expr_stmt|;
name|c
operator|=
operator|(
name|c
operator|+
name|d
operator|)
operator|/
literal|2
expr_stmt|;
name|base
index|[
literal|2
index|]
operator|.
name|y
operator|=
name|a
operator|=
operator|(
name|a
operator|+
name|c
operator|)
operator|/
literal|2
expr_stmt|;
name|base
index|[
literal|4
index|]
operator|.
name|y
operator|=
name|b
operator|=
operator|(
name|b
operator|+
name|c
operator|)
operator|/
literal|2
expr_stmt|;
name|base
index|[
literal|3
index|]
operator|.
name|y
operator|=
operator|(
name|a
operator|+
name|b
operator|)
operator|/
literal|2
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|gray_render_cubic
name|gray_render_cubic
parameter_list|(
name|RAS_ARG_
specifier|const
name|FT_Vector
modifier|*
name|control1
parameter_list|,
specifier|const
name|FT_Vector
modifier|*
name|control2
parameter_list|,
specifier|const
name|FT_Vector
modifier|*
name|to
parameter_list|)
block|{
name|FT_Vector
modifier|*
name|arc
decl_stmt|;
name|TPos
name|min
decl_stmt|,
name|max
decl_stmt|,
name|y
decl_stmt|;
name|arc
operator|=
name|ras
operator|.
name|bez_stack
expr_stmt|;
name|arc
index|[
literal|0
index|]
operator|.
name|x
operator|=
name|UPSCALE
argument_list|(
name|to
operator|->
name|x
argument_list|)
expr_stmt|;
name|arc
index|[
literal|0
index|]
operator|.
name|y
operator|=
name|UPSCALE
argument_list|(
name|to
operator|->
name|y
argument_list|)
expr_stmt|;
name|arc
index|[
literal|1
index|]
operator|.
name|x
operator|=
name|UPSCALE
argument_list|(
name|control2
operator|->
name|x
argument_list|)
expr_stmt|;
name|arc
index|[
literal|1
index|]
operator|.
name|y
operator|=
name|UPSCALE
argument_list|(
name|control2
operator|->
name|y
argument_list|)
expr_stmt|;
name|arc
index|[
literal|2
index|]
operator|.
name|x
operator|=
name|UPSCALE
argument_list|(
name|control1
operator|->
name|x
argument_list|)
expr_stmt|;
name|arc
index|[
literal|2
index|]
operator|.
name|y
operator|=
name|UPSCALE
argument_list|(
name|control1
operator|->
name|y
argument_list|)
expr_stmt|;
name|arc
index|[
literal|3
index|]
operator|.
name|x
operator|=
name|ras
operator|.
name|x
expr_stmt|;
name|arc
index|[
literal|3
index|]
operator|.
name|y
operator|=
name|ras
operator|.
name|y
expr_stmt|;
comment|/* Short-cut the arc that crosses the current band. */
name|min
operator|=
name|max
operator|=
name|arc
index|[
literal|0
index|]
operator|.
name|y
expr_stmt|;
name|y
operator|=
name|arc
index|[
literal|1
index|]
operator|.
name|y
expr_stmt|;
if|if
condition|(
name|y
operator|<
name|min
condition|)
name|min
operator|=
name|y
expr_stmt|;
if|if
condition|(
name|y
operator|>
name|max
condition|)
name|max
operator|=
name|y
expr_stmt|;
name|y
operator|=
name|arc
index|[
literal|2
index|]
operator|.
name|y
expr_stmt|;
if|if
condition|(
name|y
operator|<
name|min
condition|)
name|min
operator|=
name|y
expr_stmt|;
if|if
condition|(
name|y
operator|>
name|max
condition|)
name|max
operator|=
name|y
expr_stmt|;
name|y
operator|=
name|arc
index|[
literal|3
index|]
operator|.
name|y
expr_stmt|;
if|if
condition|(
name|y
operator|<
name|min
condition|)
name|min
operator|=
name|y
expr_stmt|;
if|if
condition|(
name|y
operator|>
name|max
condition|)
name|max
operator|=
name|y
expr_stmt|;
if|if
condition|(
name|TRUNC
argument_list|(
name|min
argument_list|)
operator|>=
name|ras
operator|.
name|max_ey
operator|||
name|TRUNC
argument_list|(
name|max
argument_list|)
operator|<
name|ras
operator|.
name|min_ey
condition|)
goto|goto
name|Draw
goto|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Decide whether to split or draw. See `Rapid Termination          */
comment|/* Evaluation for Recursive Subdivision of Bezier Curves' by Thomas */
comment|/* F. Hain, at                                                      */
comment|/* http://www.cis.southalabama.edu/~hain/general/Publications/Bezier/Camera-ready%20CISST02%202.pdf */
block|{
name|TPos
name|dx
decl_stmt|,
name|dy
decl_stmt|,
name|dx_
decl_stmt|,
name|dy_
decl_stmt|;
name|TPos
name|dx1
decl_stmt|,
name|dy1
decl_stmt|,
name|dx2
decl_stmt|,
name|dy2
decl_stmt|;
name|TPos
name|L
decl_stmt|,
name|s
decl_stmt|,
name|s_limit
decl_stmt|;
comment|/* dx and dy are x and y components of the P0-P3 chord vector. */
name|dx
operator|=
name|dx_
operator|=
name|arc
index|[
literal|3
index|]
operator|.
name|x
operator|-
name|arc
index|[
literal|0
index|]
operator|.
name|x
expr_stmt|;
name|dy
operator|=
name|dy_
operator|=
name|arc
index|[
literal|3
index|]
operator|.
name|y
operator|-
name|arc
index|[
literal|0
index|]
operator|.
name|y
expr_stmt|;
name|L
operator|=
name|FT_HYPOT
argument_list|(
name|dx_
argument_list|,
name|dy_
argument_list|)
expr_stmt|;
comment|/* Avoid possible arithmetic overflow below by splitting. */
if|if
condition|(
name|L
operator|>
literal|32767
condition|)
goto|goto
name|Split
goto|;
comment|/* Max deviation may be as much as (s/L) * 3/4 (if Hain's v = 1). */
name|s_limit
operator|=
name|L
operator|*
call|(
name|TPos
call|)
argument_list|(
name|ONE_PIXEL
operator|/
literal|6
argument_list|)
expr_stmt|;
comment|/* s is L * the perpendicular distance from P1 to the line P0-P3. */
name|dx1
operator|=
name|arc
index|[
literal|1
index|]
operator|.
name|x
operator|-
name|arc
index|[
literal|0
index|]
operator|.
name|x
expr_stmt|;
name|dy1
operator|=
name|arc
index|[
literal|1
index|]
operator|.
name|y
operator|-
name|arc
index|[
literal|0
index|]
operator|.
name|y
expr_stmt|;
name|s
operator|=
name|FT_ABS
argument_list|(
name|dy
operator|*
name|dx1
operator|-
name|dx
operator|*
name|dy1
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|>
name|s_limit
condition|)
goto|goto
name|Split
goto|;
comment|/* s is L * the perpendicular distance from P2 to the line P0-P3. */
name|dx2
operator|=
name|arc
index|[
literal|2
index|]
operator|.
name|x
operator|-
name|arc
index|[
literal|0
index|]
operator|.
name|x
expr_stmt|;
name|dy2
operator|=
name|arc
index|[
literal|2
index|]
operator|.
name|y
operator|-
name|arc
index|[
literal|0
index|]
operator|.
name|y
expr_stmt|;
name|s
operator|=
name|FT_ABS
argument_list|(
name|dy
operator|*
name|dx2
operator|-
name|dx
operator|*
name|dy2
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|>
name|s_limit
condition|)
goto|goto
name|Split
goto|;
comment|/* Split super curvy segments where the off points are so far            from the chord that the angles P0-P1-P3 or P0-P2-P3 become            acute as detected by appropriate dot products. */
if|if
condition|(
name|dx1
operator|*
operator|(
name|dx1
operator|-
name|dx
operator|)
operator|+
name|dy1
operator|*
operator|(
name|dy1
operator|-
name|dy
operator|)
operator|>
literal|0
operator|||
name|dx2
operator|*
operator|(
name|dx2
operator|-
name|dx
operator|)
operator|+
name|dy2
operator|*
operator|(
name|dy2
operator|-
name|dy
operator|)
operator|>
literal|0
condition|)
goto|goto
name|Split
goto|;
comment|/* No reason to split. */
goto|goto
name|Draw
goto|;
block|}
name|Split
label|:
name|gray_split_cubic
argument_list|(
name|arc
argument_list|)
expr_stmt|;
name|arc
operator|+=
literal|3
expr_stmt|;
continue|continue;
name|Draw
label|:
name|gray_render_line
argument_list|(
argument|RAS_VAR_ arc[
literal|0
argument|].x
argument_list|,
argument|arc[
literal|0
argument|].y
argument_list|)
empty_stmt|;
if|if
condition|(
name|arc
operator|==
name|ras
operator|.
name|bez_stack
condition|)
return|return;
name|arc
operator|-=
literal|3
expr_stmt|;
block|}
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|gray_move_to
name|gray_move_to
parameter_list|(
specifier|const
name|FT_Vector
modifier|*
name|to
parameter_list|,
name|gray_PWorker
name|worker
parameter_list|)
block|{
name|TPos
name|x
decl_stmt|,
name|y
decl_stmt|;
comment|/* record current cell, if any */
if|if
condition|(
operator|!
name|ras
operator|.
name|invalid
condition|)
name|gray_record_cell
argument_list|(
name|RAS_VAR
argument_list|)
expr_stmt|;
comment|/* start to a new position */
name|x
operator|=
name|UPSCALE
argument_list|(
name|to
operator|->
name|x
argument_list|)
expr_stmt|;
name|y
operator|=
name|UPSCALE
argument_list|(
name|to
operator|->
name|y
argument_list|)
expr_stmt|;
name|gray_start_cell
argument_list|(
argument|RAS_VAR_ TRUNC( x )
argument_list|,
argument|TRUNC( y )
argument_list|)
empty_stmt|;
name|worker
operator|->
name|x
operator|=
name|x
expr_stmt|;
name|worker
operator|->
name|y
operator|=
name|y
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|gray_line_to
name|gray_line_to
parameter_list|(
specifier|const
name|FT_Vector
modifier|*
name|to
parameter_list|,
name|gray_PWorker
name|worker
parameter_list|)
block|{
name|gray_render_line
argument_list|(
argument|RAS_VAR_ UPSCALE( to->x )
argument_list|,
argument|UPSCALE( to->y )
argument_list|)
empty_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|gray_conic_to
name|gray_conic_to
parameter_list|(
specifier|const
name|FT_Vector
modifier|*
name|control
parameter_list|,
specifier|const
name|FT_Vector
modifier|*
name|to
parameter_list|,
name|gray_PWorker
name|worker
parameter_list|)
block|{
name|gray_render_conic
argument_list|(
argument|RAS_VAR_ control
argument_list|,
argument|to
argument_list|)
empty_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|gray_cubic_to
name|gray_cubic_to
parameter_list|(
specifier|const
name|FT_Vector
modifier|*
name|control1
parameter_list|,
specifier|const
name|FT_Vector
modifier|*
name|control2
parameter_list|,
specifier|const
name|FT_Vector
modifier|*
name|to
parameter_list|,
name|gray_PWorker
name|worker
parameter_list|)
block|{
name|gray_render_cubic
argument_list|(
argument|RAS_VAR_ control1
argument_list|,
argument|control2
argument_list|,
argument|to
argument_list|)
empty_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|gray_render_span
name|gray_render_span
parameter_list|(
name|int
name|y
parameter_list|,
name|int
name|count
parameter_list|,
specifier|const
name|FT_Span
modifier|*
name|spans
parameter_list|,
name|gray_PWorker
name|worker
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|FT_Bitmap
modifier|*
name|map
init|=
operator|&
name|worker
operator|->
name|target
decl_stmt|;
comment|/* first of all, compute the scanline offset */
name|p
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|map
operator|->
name|buffer
operator|-
name|y
operator|*
name|map
operator|->
name|pitch
expr_stmt|;
if|if
condition|(
name|map
operator|->
name|pitch
operator|>=
literal|0
condition|)
name|p
operator|+=
call|(
name|unsigned
call|)
argument_list|(
operator|(
name|map
operator|->
name|rows
operator|-
literal|1
operator|)
operator|*
name|map
operator|->
name|pitch
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
operator|,
name|spans
operator|++
control|)
block|{
name|unsigned
name|char
name|coverage
init|=
name|spans
operator|->
name|coverage
decl_stmt|;
if|if
condition|(
name|coverage
condition|)
block|{
comment|/* For small-spans it is faster to do it by ourselves than          * calling `memset'.  This is mainly due to the cost of the          * function call.          */
if|if
condition|(
name|spans
operator|->
name|len
operator|>=
literal|8
condition|)
name|FT_MEM_SET
argument_list|(
name|p
operator|+
name|spans
operator|->
name|x
argument_list|,
operator|(
name|unsigned
name|char
operator|)
name|coverage
argument_list|,
name|spans
operator|->
name|len
argument_list|)
expr_stmt|;
else|else
block|{
name|unsigned
name|char
modifier|*
name|q
init|=
name|p
operator|+
name|spans
operator|->
name|x
decl_stmt|;
switch|switch
condition|(
name|spans
operator|->
name|len
condition|)
block|{
case|case
literal|7
case|:
operator|*
name|q
operator|++
operator|=
operator|(
name|unsigned
name|char
operator|)
name|coverage
expr_stmt|;
case|case
literal|6
case|:
operator|*
name|q
operator|++
operator|=
operator|(
name|unsigned
name|char
operator|)
name|coverage
expr_stmt|;
case|case
literal|5
case|:
operator|*
name|q
operator|++
operator|=
operator|(
name|unsigned
name|char
operator|)
name|coverage
expr_stmt|;
case|case
literal|4
case|:
operator|*
name|q
operator|++
operator|=
operator|(
name|unsigned
name|char
operator|)
name|coverage
expr_stmt|;
case|case
literal|3
case|:
operator|*
name|q
operator|++
operator|=
operator|(
name|unsigned
name|char
operator|)
name|coverage
expr_stmt|;
case|case
literal|2
case|:
operator|*
name|q
operator|++
operator|=
operator|(
name|unsigned
name|char
operator|)
name|coverage
expr_stmt|;
case|case
literal|1
case|:
operator|*
name|q
operator|=
operator|(
name|unsigned
name|char
operator|)
name|coverage
expr_stmt|;
default|default:
empty_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|gray_hline
name|gray_hline
parameter_list|(
name|RAS_ARG_
name|TCoord
name|x
parameter_list|,
name|TCoord
name|y
parameter_list|,
name|TPos
name|area
parameter_list|,
name|TCoord
name|acount
parameter_list|)
block|{
name|int
name|coverage
decl_stmt|;
comment|/* compute the coverage line's coverage, depending on the    */
comment|/* outline fill rule                                         */
comment|/*                                                           */
comment|/* the coverage percentage is area/(PIXEL_BITS*PIXEL_BITS*2) */
comment|/*                                                           */
name|coverage
operator|=
call|(
name|int
call|)
argument_list|(
name|area
operator|>>
operator|(
name|PIXEL_BITS
operator|*
literal|2
operator|+
literal|1
operator|-
literal|8
operator|)
argument_list|)
expr_stmt|;
comment|/* use range 0..256 */
if|if
condition|(
name|coverage
operator|<
literal|0
condition|)
name|coverage
operator|=
operator|-
name|coverage
expr_stmt|;
if|if
condition|(
name|ras
operator|.
name|outline
operator|.
name|flags
operator|&
name|FT_OUTLINE_EVEN_ODD_FILL
condition|)
block|{
name|coverage
operator|&=
literal|511
expr_stmt|;
if|if
condition|(
name|coverage
operator|>
literal|256
condition|)
name|coverage
operator|=
literal|512
operator|-
name|coverage
expr_stmt|;
elseif|else
if|if
condition|(
name|coverage
operator|==
literal|256
condition|)
name|coverage
operator|=
literal|255
expr_stmt|;
block|}
else|else
block|{
comment|/* normal non-zero winding rule */
if|if
condition|(
name|coverage
operator|>=
literal|256
condition|)
name|coverage
operator|=
literal|255
expr_stmt|;
block|}
name|y
operator|+=
operator|(
name|TCoord
operator|)
name|ras
operator|.
name|min_ey
expr_stmt|;
name|x
operator|+=
operator|(
name|TCoord
operator|)
name|ras
operator|.
name|min_ex
expr_stmt|;
comment|/* FT_Span.x is a 16-bit short, so limit our coordinates appropriately */
if|if
condition|(
name|x
operator|>=
literal|32767
condition|)
name|x
operator|=
literal|32767
expr_stmt|;
comment|/* FT_Span.y is an integer, so limit our coordinates appropriately */
if|if
condition|(
name|y
operator|>=
name|FT_INT_MAX
condition|)
name|y
operator|=
name|FT_INT_MAX
expr_stmt|;
if|if
condition|(
name|coverage
condition|)
block|{
name|FT_Span
modifier|*
name|span
decl_stmt|;
name|int
name|count
decl_stmt|;
comment|/* see whether we can add this span to the current list */
name|count
operator|=
name|ras
operator|.
name|num_gray_spans
expr_stmt|;
name|span
operator|=
name|ras
operator|.
name|gray_spans
operator|+
name|count
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
operator|&&
name|ras
operator|.
name|span_y
operator|==
name|y
operator|&&
operator|(
name|int
operator|)
name|span
operator|->
name|x
operator|+
name|span
operator|->
name|len
operator|==
operator|(
name|int
operator|)
name|x
operator|&&
name|span
operator|->
name|coverage
operator|==
name|coverage
condition|)
block|{
name|span
operator|->
name|len
operator|=
call|(
name|unsigned
name|short
call|)
argument_list|(
name|span
operator|->
name|len
operator|+
name|acount
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ras
operator|.
name|span_y
operator|!=
name|y
operator|||
name|count
operator|>=
name|FT_MAX_GRAY_SPANS
condition|)
block|{
if|if
condition|(
name|ras
operator|.
name|render_span
operator|&&
name|count
operator|>
literal|0
condition|)
name|ras
operator|.
name|render_span
argument_list|(
name|ras
operator|.
name|span_y
argument_list|,
name|count
argument_list|,
name|ras
operator|.
name|gray_spans
argument_list|,
name|ras
operator|.
name|render_span_data
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FT_DEBUG_LEVEL_TRACE
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|int
name|n
decl_stmt|;
name|FT_TRACE7
argument_list|(
operator|(
literal|"y = %3d "
operator|,
name|ras
operator|.
name|span_y
operator|)
argument_list|)
expr_stmt|;
name|span
operator|=
name|ras
operator|.
name|gray_spans
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
operator|,
name|span
operator|++
control|)
name|FT_TRACE7
argument_list|(
operator|(
literal|"[%d..%d]:%02x "
operator|,
name|span
operator|->
name|x
operator|,
name|span
operator|->
name|x
operator|+
name|span
operator|->
name|len
operator|-
literal|1
operator|,
name|span
operator|->
name|coverage
operator|)
argument_list|)
expr_stmt|;
name|FT_TRACE7
argument_list|(
operator|(
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* FT_DEBUG_LEVEL_TRACE */
name|ras
operator|.
name|num_gray_spans
operator|=
literal|0
expr_stmt|;
name|ras
operator|.
name|span_y
operator|=
operator|(
name|int
operator|)
name|y
expr_stmt|;
name|span
operator|=
name|ras
operator|.
name|gray_spans
expr_stmt|;
block|}
else|else
name|span
operator|++
expr_stmt|;
comment|/* add a gray span to the current list */
name|span
operator|->
name|x
operator|=
operator|(
name|short
operator|)
name|x
expr_stmt|;
name|span
operator|->
name|len
operator|=
operator|(
name|unsigned
name|short
operator|)
name|acount
expr_stmt|;
name|span
operator|->
name|coverage
operator|=
operator|(
name|unsigned
name|char
operator|)
name|coverage
expr_stmt|;
name|ras
operator|.
name|num_gray_spans
operator|++
expr_stmt|;
block|}
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|FT_DEBUG_LEVEL_TRACE
end_ifdef
begin_comment
comment|/* to be called while in the debugger --                                */
end_comment
begin_comment
comment|/* this function causes a compiler warning since it is unused otherwise */
end_comment
begin_function
specifier|static
name|void
DECL|function|gray_dump_cells
name|gray_dump_cells
parameter_list|(
name|RAS_ARG
parameter_list|)
block|{
name|int
name|yindex
decl_stmt|;
for|for
control|(
name|yindex
operator|=
literal|0
init|;
name|yindex
operator|<
name|ras
operator|.
name|ycount
condition|;
name|yindex
operator|++
control|)
block|{
name|PCell
name|cell
decl_stmt|;
name|printf
argument_list|(
literal|"%3d:"
argument_list|,
name|yindex
argument_list|)
expr_stmt|;
for|for
control|(
name|cell
operator|=
name|ras
operator|.
name|ycells
index|[
name|yindex
index|]
init|;
name|cell
operator|!=
name|NULL
condition|;
name|cell
operator|=
name|cell
operator|->
name|next
control|)
name|printf
argument_list|(
literal|" (%3ld, c:%4ld, a:%6d)"
argument_list|,
name|cell
operator|->
name|x
argument_list|,
name|cell
operator|->
name|cover
argument_list|,
name|cell
operator|->
name|area
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* FT_DEBUG_LEVEL_TRACE */
end_comment
begin_function
specifier|static
name|void
DECL|function|gray_sweep
name|gray_sweep
parameter_list|(
name|RAS_ARG_
specifier|const
name|FT_Bitmap
modifier|*
name|target
parameter_list|)
block|{
name|int
name|yindex
decl_stmt|;
name|FT_UNUSED
argument_list|(
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|ras
operator|.
name|num_cells
operator|==
literal|0
condition|)
return|return;
name|ras
operator|.
name|num_gray_spans
operator|=
literal|0
expr_stmt|;
name|FT_TRACE7
argument_list|(
operator|(
literal|"gray_sweep: start\n"
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|yindex
operator|=
literal|0
init|;
name|yindex
operator|<
name|ras
operator|.
name|ycount
condition|;
name|yindex
operator|++
control|)
block|{
name|PCell
name|cell
init|=
name|ras
operator|.
name|ycells
index|[
name|yindex
index|]
decl_stmt|;
name|TCoord
name|cover
init|=
literal|0
decl_stmt|;
name|TCoord
name|x
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|cell
operator|!=
name|NULL
condition|;
name|cell
operator|=
name|cell
operator|->
name|next
control|)
block|{
name|TPos
name|area
decl_stmt|;
if|if
condition|(
name|cell
operator|->
name|x
operator|>
name|x
operator|&&
name|cover
operator|!=
literal|0
condition|)
name|gray_hline
argument_list|(
argument|RAS_VAR_ x
argument_list|,
argument|yindex
argument_list|,
argument|cover * ( ONE_PIXEL *
literal|2
argument|)
argument_list|,
argument|cell->x - x
argument_list|)
empty_stmt|;
name|cover
operator|+=
name|cell
operator|->
name|cover
expr_stmt|;
name|area
operator|=
name|cover
operator|*
operator|(
name|ONE_PIXEL
operator|*
literal|2
operator|)
operator|-
name|cell
operator|->
name|area
expr_stmt|;
if|if
condition|(
name|area
operator|!=
literal|0
operator|&&
name|cell
operator|->
name|x
operator|>=
literal|0
condition|)
name|gray_hline
argument_list|(
argument|RAS_VAR_ cell->x
argument_list|,
argument|yindex
argument_list|,
argument|area
argument_list|,
literal|1
argument_list|)
empty_stmt|;
name|x
operator|=
name|cell
operator|->
name|x
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|cover
operator|!=
literal|0
condition|)
name|gray_hline
argument_list|(
argument|RAS_VAR_ x
argument_list|,
argument|yindex
argument_list|,
argument|cover * ( ONE_PIXEL *
literal|2
argument|)
argument_list|,
argument|ras.count_ex - x
argument_list|)
empty_stmt|;
block|}
if|if
condition|(
name|ras
operator|.
name|render_span
operator|&&
name|ras
operator|.
name|num_gray_spans
operator|>
literal|0
condition|)
name|ras
operator|.
name|render_span
argument_list|(
name|ras
operator|.
name|span_y
argument_list|,
name|ras
operator|.
name|num_gray_spans
argument_list|,
name|ras
operator|.
name|gray_spans
argument_list|,
name|ras
operator|.
name|render_span_data
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FT_DEBUG_LEVEL_TRACE
if|if
condition|(
name|ras
operator|.
name|num_gray_spans
operator|>
literal|0
condition|)
block|{
name|FT_Span
modifier|*
name|span
decl_stmt|;
name|int
name|n
decl_stmt|;
name|FT_TRACE7
argument_list|(
operator|(
literal|"y = %3d "
operator|,
name|ras
operator|.
name|span_y
operator|)
argument_list|)
expr_stmt|;
name|span
operator|=
name|ras
operator|.
name|gray_spans
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|ras
operator|.
name|num_gray_spans
condition|;
name|n
operator|++
operator|,
name|span
operator|++
control|)
name|FT_TRACE7
argument_list|(
operator|(
literal|"[%d..%d]:%02x "
operator|,
name|span
operator|->
name|x
operator|,
name|span
operator|->
name|x
operator|+
name|span
operator|->
name|len
operator|-
literal|1
operator|,
name|span
operator|->
name|coverage
operator|)
argument_list|)
expr_stmt|;
name|FT_TRACE7
argument_list|(
operator|(
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
block|}
name|FT_TRACE7
argument_list|(
operator|(
literal|"gray_sweep: end\n"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* FT_DEBUG_LEVEL_TRACE */
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|_STANDALONE_
end_ifdef
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*  The following function should only compile in stand-alone mode,      */
end_comment
begin_comment
comment|/*  i.e., when building this component without the rest of FreeType.     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    FT_Outline_Decompose                                               */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Walk over an outline's structure to decompose it into individual   */
end_comment
begin_comment
comment|/*    segments and BÃ©zier arcs.  This function is also able to emit      */
end_comment
begin_comment
comment|/*    `move to' and `close to' operations to indicate the start and end  */
end_comment
begin_comment
comment|/*    of new contours in the outline.                                    */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    outline        :: A pointer to the source target.                  */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    func_interface :: A table of `emitters', i.e., function pointers   */
end_comment
begin_comment
comment|/*                      called during decomposition to indicate path     */
end_comment
begin_comment
comment|/*                      operations.                                      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<InOut>                                                               */
end_comment
begin_comment
comment|/*    user           :: A typeless pointer which is passed to each       */
end_comment
begin_comment
comment|/*                      emitter during the decomposition.  It can be     */
end_comment
begin_comment
comment|/*                      used to store the state during the               */
end_comment
begin_comment
comment|/*                      decomposition.                                   */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    Error code.  0 means success.                                      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|int
DECL|function|FT_Outline_Decompose
name|FT_Outline_Decompose
parameter_list|(
specifier|const
name|FT_Outline
modifier|*
name|outline
parameter_list|,
specifier|const
name|FT_Outline_Funcs
modifier|*
name|func_interface
parameter_list|,
name|void
modifier|*
name|user
parameter_list|)
block|{
DECL|macro|SCALED
undef|#
directive|undef
name|SCALED
DECL|macro|SCALED
define|#
directive|define
name|SCALED
parameter_list|(
name|x
parameter_list|)
value|( ( (x)<< shift ) - delta )
name|FT_Vector
name|v_last
decl_stmt|;
name|FT_Vector
name|v_control
decl_stmt|;
name|FT_Vector
name|v_start
decl_stmt|;
name|FT_Vector
modifier|*
name|point
decl_stmt|;
name|FT_Vector
modifier|*
name|limit
decl_stmt|;
name|char
modifier|*
name|tags
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|n
decl_stmt|;
comment|/* index of contour in outline     */
name|int
name|first
decl_stmt|;
comment|/* index of first point in contour */
name|char
name|tag
decl_stmt|;
comment|/* current point's state           */
name|int
name|shift
decl_stmt|;
name|TPos
name|delta
decl_stmt|;
if|if
condition|(
operator|!
name|outline
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_Outline
argument_list|)
return|;
if|if
condition|(
operator|!
name|func_interface
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_Argument
argument_list|)
return|;
name|shift
operator|=
name|func_interface
operator|->
name|shift
expr_stmt|;
name|delta
operator|=
name|func_interface
operator|->
name|delta
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|outline
operator|->
name|n_contours
condition|;
name|n
operator|++
control|)
block|{
name|int
name|last
decl_stmt|;
comment|/* index of last point in contour */
name|FT_TRACE5
argument_list|(
operator|(
literal|"FT_Outline_Decompose: Outline %d\n"
operator|,
name|n
operator|)
argument_list|)
expr_stmt|;
name|last
operator|=
name|outline
operator|->
name|contours
index|[
name|n
index|]
expr_stmt|;
if|if
condition|(
name|last
operator|<
literal|0
condition|)
goto|goto
name|Invalid_Outline
goto|;
name|limit
operator|=
name|outline
operator|->
name|points
operator|+
name|last
expr_stmt|;
name|v_start
operator|=
name|outline
operator|->
name|points
index|[
name|first
index|]
expr_stmt|;
name|v_start
operator|.
name|x
operator|=
name|SCALED
argument_list|(
name|v_start
operator|.
name|x
argument_list|)
expr_stmt|;
name|v_start
operator|.
name|y
operator|=
name|SCALED
argument_list|(
name|v_start
operator|.
name|y
argument_list|)
expr_stmt|;
name|v_last
operator|=
name|outline
operator|->
name|points
index|[
name|last
index|]
expr_stmt|;
name|v_last
operator|.
name|x
operator|=
name|SCALED
argument_list|(
name|v_last
operator|.
name|x
argument_list|)
expr_stmt|;
name|v_last
operator|.
name|y
operator|=
name|SCALED
argument_list|(
name|v_last
operator|.
name|y
argument_list|)
expr_stmt|;
name|v_control
operator|=
name|v_start
expr_stmt|;
name|point
operator|=
name|outline
operator|->
name|points
operator|+
name|first
expr_stmt|;
name|tags
operator|=
name|outline
operator|->
name|tags
operator|+
name|first
expr_stmt|;
name|tag
operator|=
name|FT_CURVE_TAG
argument_list|(
name|tags
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* A contour cannot start with a cubic control point! */
if|if
condition|(
name|tag
operator|==
name|FT_CURVE_TAG_CUBIC
condition|)
goto|goto
name|Invalid_Outline
goto|;
comment|/* check first point to determine origin */
if|if
condition|(
name|tag
operator|==
name|FT_CURVE_TAG_CONIC
condition|)
block|{
comment|/* first point is conic control.  Yes, this happens. */
if|if
condition|(
name|FT_CURVE_TAG
argument_list|(
name|outline
operator|->
name|tags
index|[
name|last
index|]
argument_list|)
operator|==
name|FT_CURVE_TAG_ON
condition|)
block|{
comment|/* start at last point if it is on the curve */
name|v_start
operator|=
name|v_last
expr_stmt|;
name|limit
operator|--
expr_stmt|;
block|}
else|else
block|{
comment|/* if both first and last points are conic,         */
comment|/* start at their middle and record its position    */
comment|/* for closure                                      */
name|v_start
operator|.
name|x
operator|=
operator|(
name|v_start
operator|.
name|x
operator|+
name|v_last
operator|.
name|x
operator|)
operator|/
literal|2
expr_stmt|;
name|v_start
operator|.
name|y
operator|=
operator|(
name|v_start
operator|.
name|y
operator|+
name|v_last
operator|.
name|y
operator|)
operator|/
literal|2
expr_stmt|;
name|v_last
operator|=
name|v_start
expr_stmt|;
block|}
name|point
operator|--
expr_stmt|;
name|tags
operator|--
expr_stmt|;
block|}
name|FT_TRACE5
argument_list|(
operator|(
literal|"  move to (%.2f, %.2f)\n"
operator|,
name|v_start
operator|.
name|x
operator|/
literal|64.0
operator|,
name|v_start
operator|.
name|y
operator|/
literal|64.0
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|func_interface
operator|->
name|move_to
argument_list|(
operator|&
name|v_start
argument_list|,
name|user
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
while|while
condition|(
name|point
operator|<
name|limit
condition|)
block|{
name|point
operator|++
expr_stmt|;
name|tags
operator|++
expr_stmt|;
name|tag
operator|=
name|FT_CURVE_TAG
argument_list|(
name|tags
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tag
condition|)
block|{
case|case
name|FT_CURVE_TAG_ON
case|:
comment|/* emit a single line_to */
block|{
name|FT_Vector
name|vec
decl_stmt|;
name|vec
operator|.
name|x
operator|=
name|SCALED
argument_list|(
name|point
operator|->
name|x
argument_list|)
expr_stmt|;
name|vec
operator|.
name|y
operator|=
name|SCALED
argument_list|(
name|point
operator|->
name|y
argument_list|)
expr_stmt|;
name|FT_TRACE5
argument_list|(
operator|(
literal|"  line to (%.2f, %.2f)\n"
operator|,
name|vec
operator|.
name|x
operator|/
literal|64.0
operator|,
name|vec
operator|.
name|y
operator|/
literal|64.0
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|func_interface
operator|->
name|line_to
argument_list|(
operator|&
name|vec
argument_list|,
name|user
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
continue|continue;
block|}
case|case
name|FT_CURVE_TAG_CONIC
case|:
comment|/* consume conic arcs */
name|v_control
operator|.
name|x
operator|=
name|SCALED
argument_list|(
name|point
operator|->
name|x
argument_list|)
expr_stmt|;
name|v_control
operator|.
name|y
operator|=
name|SCALED
argument_list|(
name|point
operator|->
name|y
argument_list|)
expr_stmt|;
name|Do_Conic
label|:
if|if
condition|(
name|point
operator|<
name|limit
condition|)
block|{
name|FT_Vector
name|vec
decl_stmt|;
name|FT_Vector
name|v_middle
decl_stmt|;
name|point
operator|++
expr_stmt|;
name|tags
operator|++
expr_stmt|;
name|tag
operator|=
name|FT_CURVE_TAG
argument_list|(
name|tags
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|vec
operator|.
name|x
operator|=
name|SCALED
argument_list|(
name|point
operator|->
name|x
argument_list|)
expr_stmt|;
name|vec
operator|.
name|y
operator|=
name|SCALED
argument_list|(
name|point
operator|->
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag
operator|==
name|FT_CURVE_TAG_ON
condition|)
block|{
name|FT_TRACE5
argument_list|(
operator|(
literal|"  conic to (%.2f, %.2f)"
literal|" with control (%.2f, %.2f)\n"
operator|,
name|vec
operator|.
name|x
operator|/
literal|64.0
operator|,
name|vec
operator|.
name|y
operator|/
literal|64.0
operator|,
name|v_control
operator|.
name|x
operator|/
literal|64.0
operator|,
name|v_control
operator|.
name|y
operator|/
literal|64.0
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|func_interface
operator|->
name|conic_to
argument_list|(
operator|&
name|v_control
argument_list|,
operator|&
name|vec
argument_list|,
name|user
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
continue|continue;
block|}
if|if
condition|(
name|tag
operator|!=
name|FT_CURVE_TAG_CONIC
condition|)
goto|goto
name|Invalid_Outline
goto|;
name|v_middle
operator|.
name|x
operator|=
operator|(
name|v_control
operator|.
name|x
operator|+
name|vec
operator|.
name|x
operator|)
operator|/
literal|2
expr_stmt|;
name|v_middle
operator|.
name|y
operator|=
operator|(
name|v_control
operator|.
name|y
operator|+
name|vec
operator|.
name|y
operator|)
operator|/
literal|2
expr_stmt|;
name|FT_TRACE5
argument_list|(
operator|(
literal|"  conic to (%.2f, %.2f)"
literal|" with control (%.2f, %.2f)\n"
operator|,
name|v_middle
operator|.
name|x
operator|/
literal|64.0
operator|,
name|v_middle
operator|.
name|y
operator|/
literal|64.0
operator|,
name|v_control
operator|.
name|x
operator|/
literal|64.0
operator|,
name|v_control
operator|.
name|y
operator|/
literal|64.0
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|func_interface
operator|->
name|conic_to
argument_list|(
operator|&
name|v_control
argument_list|,
operator|&
name|v_middle
argument_list|,
name|user
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|v_control
operator|=
name|vec
expr_stmt|;
goto|goto
name|Do_Conic
goto|;
block|}
name|FT_TRACE5
argument_list|(
operator|(
literal|"  conic to (%.2f, %.2f)"
literal|" with control (%.2f, %.2f)\n"
operator|,
name|v_start
operator|.
name|x
operator|/
literal|64.0
operator|,
name|v_start
operator|.
name|y
operator|/
literal|64.0
operator|,
name|v_control
operator|.
name|x
operator|/
literal|64.0
operator|,
name|v_control
operator|.
name|y
operator|/
literal|64.0
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|func_interface
operator|->
name|conic_to
argument_list|(
operator|&
name|v_control
argument_list|,
operator|&
name|v_start
argument_list|,
name|user
argument_list|)
expr_stmt|;
goto|goto
name|Close
goto|;
default|default:
comment|/* FT_CURVE_TAG_CUBIC */
block|{
name|FT_Vector
name|vec1
decl_stmt|,
name|vec2
decl_stmt|;
if|if
condition|(
name|point
operator|+
literal|1
operator|>
name|limit
operator|||
name|FT_CURVE_TAG
argument_list|(
name|tags
index|[
literal|1
index|]
argument_list|)
operator|!=
name|FT_CURVE_TAG_CUBIC
condition|)
goto|goto
name|Invalid_Outline
goto|;
name|point
operator|+=
literal|2
expr_stmt|;
name|tags
operator|+=
literal|2
expr_stmt|;
name|vec1
operator|.
name|x
operator|=
name|SCALED
argument_list|(
name|point
index|[
operator|-
literal|2
index|]
operator|.
name|x
argument_list|)
expr_stmt|;
name|vec1
operator|.
name|y
operator|=
name|SCALED
argument_list|(
name|point
index|[
operator|-
literal|2
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
name|vec2
operator|.
name|x
operator|=
name|SCALED
argument_list|(
name|point
index|[
operator|-
literal|1
index|]
operator|.
name|x
argument_list|)
expr_stmt|;
name|vec2
operator|.
name|y
operator|=
name|SCALED
argument_list|(
name|point
index|[
operator|-
literal|1
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|point
operator|<=
name|limit
condition|)
block|{
name|FT_Vector
name|vec
decl_stmt|;
name|vec
operator|.
name|x
operator|=
name|SCALED
argument_list|(
name|point
operator|->
name|x
argument_list|)
expr_stmt|;
name|vec
operator|.
name|y
operator|=
name|SCALED
argument_list|(
name|point
operator|->
name|y
argument_list|)
expr_stmt|;
name|FT_TRACE5
argument_list|(
operator|(
literal|"  cubic to (%.2f, %.2f)"
literal|" with controls (%.2f, %.2f) and (%.2f, %.2f)\n"
operator|,
name|vec
operator|.
name|x
operator|/
literal|64.0
operator|,
name|vec
operator|.
name|y
operator|/
literal|64.0
operator|,
name|vec1
operator|.
name|x
operator|/
literal|64.0
operator|,
name|vec1
operator|.
name|y
operator|/
literal|64.0
operator|,
name|vec2
operator|.
name|x
operator|/
literal|64.0
operator|,
name|vec2
operator|.
name|y
operator|/
literal|64.0
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|func_interface
operator|->
name|cubic_to
argument_list|(
operator|&
name|vec1
argument_list|,
operator|&
name|vec2
argument_list|,
operator|&
name|vec
argument_list|,
name|user
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
continue|continue;
block|}
name|FT_TRACE5
argument_list|(
operator|(
literal|"  cubic to (%.2f, %.2f)"
literal|" with controls (%.2f, %.2f) and (%.2f, %.2f)\n"
operator|,
name|v_start
operator|.
name|x
operator|/
literal|64.0
operator|,
name|v_start
operator|.
name|y
operator|/
literal|64.0
operator|,
name|vec1
operator|.
name|x
operator|/
literal|64.0
operator|,
name|vec1
operator|.
name|y
operator|/
literal|64.0
operator|,
name|vec2
operator|.
name|x
operator|/
literal|64.0
operator|,
name|vec2
operator|.
name|y
operator|/
literal|64.0
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|func_interface
operator|->
name|cubic_to
argument_list|(
operator|&
name|vec1
argument_list|,
operator|&
name|vec2
argument_list|,
operator|&
name|v_start
argument_list|,
name|user
argument_list|)
expr_stmt|;
goto|goto
name|Close
goto|;
block|}
block|}
block|}
comment|/* close the contour with a line segment */
name|FT_TRACE5
argument_list|(
operator|(
literal|"  line to (%.2f, %.2f)\n"
operator|,
name|v_start
operator|.
name|x
operator|/
literal|64.0
operator|,
name|v_start
operator|.
name|y
operator|/
literal|64.0
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|func_interface
operator|->
name|line_to
argument_list|(
operator|&
name|v_start
argument_list|,
name|user
argument_list|)
expr_stmt|;
name|Close
label|:
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|first
operator|=
name|last
operator|+
literal|1
expr_stmt|;
block|}
name|FT_TRACE5
argument_list|(
operator|(
literal|"FT_Outline_Decompose: Done\n"
operator|,
name|n
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|Exit
label|:
name|FT_TRACE5
argument_list|(
operator|(
literal|"FT_Outline_Decompose: Error %d\n"
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
return|return
name|error
return|;
name|Invalid_Outline
label|:
return|return
name|FT_THROW
argument_list|(
name|Invalid_Outline
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* _STANDALONE_ */
end_comment
begin_typedef
DECL|struct|gray_TBand_
typedef|typedef
struct|struct
name|gray_TBand_
block|{
DECL|member|min
DECL|member|max
name|TPos
name|min
decl_stmt|,
name|max
decl_stmt|;
block|}
DECL|typedef|gray_TBand
name|gray_TBand
typedef|;
end_typedef
begin_macro
name|FT_DEFINE_OUTLINE_FUNCS
argument_list|(
argument|func_interface
argument_list|,
argument|(FT_Outline_MoveTo_Func) gray_move_to
argument_list|,
DECL|variable|gray_line_to
argument|(FT_Outline_LineTo_Func) gray_line_to
argument_list|,
DECL|variable|gray_conic_to
argument|(FT_Outline_ConicTo_Func)gray_conic_to
argument_list|,
DECL|variable|gray_cubic_to
argument|(FT_Outline_CubicTo_Func)gray_cubic_to
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
end_macro
begin_function
specifier|static
name|int
DECL|function|gray_convert_glyph_inner
name|gray_convert_glyph_inner
parameter_list|(
name|RAS_ARG
parameter_list|)
block|{
specifier|volatile
name|int
name|error
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|FT_CONFIG_OPTION_PIC
name|FT_Outline_Funcs
name|func_interface
decl_stmt|;
name|Init_Class_func_interface
argument_list|(
operator|&
name|func_interface
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ft_setjmp
argument_list|(
name|ras
operator|.
name|jump_buffer
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|FT_Outline_Decompose
argument_list|(
operator|&
name|ras
operator|.
name|outline
argument_list|,
operator|&
name|func_interface
argument_list|,
operator|&
name|ras
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ras
operator|.
name|invalid
condition|)
name|gray_record_cell
argument_list|(
name|RAS_VAR
argument_list|)
expr_stmt|;
block|}
else|else
name|error
operator|=
name|FT_THROW
argument_list|(
name|Memory_Overflow
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|gray_convert_glyph
name|gray_convert_glyph
parameter_list|(
name|RAS_ARG
parameter_list|)
block|{
name|gray_TBand
name|bands
index|[
literal|40
index|]
decl_stmt|;
name|gray_TBand
modifier|*
specifier|volatile
name|band
decl_stmt|;
name|int
specifier|volatile
name|n
decl_stmt|,
name|num_bands
decl_stmt|;
name|TPos
specifier|volatile
name|min
decl_stmt|,
name|max
decl_stmt|,
name|max_y
decl_stmt|;
name|FT_BBox
modifier|*
name|clip
decl_stmt|;
comment|/* Set up state in the raster object */
name|gray_compute_cbox
argument_list|(
name|RAS_VAR
argument_list|)
expr_stmt|;
comment|/* clip to target bitmap, exit if nothing to do */
name|clip
operator|=
operator|&
name|ras
operator|.
name|clip_box
expr_stmt|;
if|if
condition|(
name|ras
operator|.
name|max_ex
operator|<=
name|clip
operator|->
name|xMin
operator|||
name|ras
operator|.
name|min_ex
operator|>=
name|clip
operator|->
name|xMax
operator|||
name|ras
operator|.
name|max_ey
operator|<=
name|clip
operator|->
name|yMin
operator|||
name|ras
operator|.
name|min_ey
operator|>=
name|clip
operator|->
name|yMax
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|ras
operator|.
name|min_ex
operator|<
name|clip
operator|->
name|xMin
condition|)
name|ras
operator|.
name|min_ex
operator|=
name|clip
operator|->
name|xMin
expr_stmt|;
if|if
condition|(
name|ras
operator|.
name|min_ey
operator|<
name|clip
operator|->
name|yMin
condition|)
name|ras
operator|.
name|min_ey
operator|=
name|clip
operator|->
name|yMin
expr_stmt|;
if|if
condition|(
name|ras
operator|.
name|max_ex
operator|>
name|clip
operator|->
name|xMax
condition|)
name|ras
operator|.
name|max_ex
operator|=
name|clip
operator|->
name|xMax
expr_stmt|;
if|if
condition|(
name|ras
operator|.
name|max_ey
operator|>
name|clip
operator|->
name|yMax
condition|)
name|ras
operator|.
name|max_ey
operator|=
name|clip
operator|->
name|yMax
expr_stmt|;
name|ras
operator|.
name|count_ex
operator|=
name|ras
operator|.
name|max_ex
operator|-
name|ras
operator|.
name|min_ex
expr_stmt|;
name|ras
operator|.
name|count_ey
operator|=
name|ras
operator|.
name|max_ey
operator|-
name|ras
operator|.
name|min_ey
expr_stmt|;
comment|/* set up vertical bands */
name|num_bands
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|ras
operator|.
name|max_ey
operator|-
name|ras
operator|.
name|min_ey
operator|)
operator|/
name|ras
operator|.
name|band_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_bands
operator|==
literal|0
condition|)
name|num_bands
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|num_bands
operator|>=
literal|39
condition|)
name|num_bands
operator|=
literal|39
expr_stmt|;
name|ras
operator|.
name|band_shoot
operator|=
literal|0
expr_stmt|;
name|min
operator|=
name|ras
operator|.
name|min_ey
expr_stmt|;
name|max_y
operator|=
name|ras
operator|.
name|max_ey
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|num_bands
condition|;
name|n
operator|++
operator|,
name|min
operator|=
name|max
control|)
block|{
name|max
operator|=
name|min
operator|+
name|ras
operator|.
name|band_size
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|num_bands
operator|-
literal|1
operator|||
name|max
operator|>
name|max_y
condition|)
name|max
operator|=
name|max_y
expr_stmt|;
name|bands
index|[
literal|0
index|]
operator|.
name|min
operator|=
name|min
expr_stmt|;
name|bands
index|[
literal|0
index|]
operator|.
name|max
operator|=
name|max
expr_stmt|;
name|band
operator|=
name|bands
expr_stmt|;
while|while
condition|(
name|band
operator|>=
name|bands
condition|)
block|{
name|TPos
name|bottom
decl_stmt|,
name|top
decl_stmt|,
name|middle
decl_stmt|;
name|int
name|error
decl_stmt|;
block|{
name|PCell
name|cells_max
decl_stmt|;
name|int
name|yindex
decl_stmt|;
name|long
name|cell_start
decl_stmt|,
name|cell_end
decl_stmt|,
name|cell_mod
decl_stmt|;
name|ras
operator|.
name|ycells
operator|=
operator|(
name|PCell
operator|*
operator|)
name|ras
operator|.
name|buffer
expr_stmt|;
name|ras
operator|.
name|ycount
operator|=
name|band
operator|->
name|max
operator|-
name|band
operator|->
name|min
expr_stmt|;
name|cell_start
operator|=
sizeof|sizeof
argument_list|(
name|PCell
argument_list|)
operator|*
name|ras
operator|.
name|ycount
expr_stmt|;
name|cell_mod
operator|=
name|cell_start
operator|%
sizeof|sizeof
argument_list|(
name|TCell
argument_list|)
expr_stmt|;
if|if
condition|(
name|cell_mod
operator|>
literal|0
condition|)
name|cell_start
operator|+=
sizeof|sizeof
argument_list|(
name|TCell
argument_list|)
operator|-
name|cell_mod
expr_stmt|;
name|cell_end
operator|=
name|ras
operator|.
name|buffer_size
expr_stmt|;
name|cell_end
operator|-=
name|cell_end
operator|%
sizeof|sizeof
argument_list|(
name|TCell
argument_list|)
expr_stmt|;
name|cells_max
operator|=
call|(
name|PCell
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ras
operator|.
name|buffer
operator|+
name|cell_end
argument_list|)
expr_stmt|;
name|ras
operator|.
name|cells
operator|=
call|(
name|PCell
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ras
operator|.
name|buffer
operator|+
name|cell_start
argument_list|)
expr_stmt|;
if|if
condition|(
name|ras
operator|.
name|cells
operator|>=
name|cells_max
condition|)
goto|goto
name|ReduceBands
goto|;
name|ras
operator|.
name|max_cells
operator|=
name|cells_max
operator|-
name|ras
operator|.
name|cells
expr_stmt|;
if|if
condition|(
name|ras
operator|.
name|max_cells
operator|<
literal|2
condition|)
goto|goto
name|ReduceBands
goto|;
for|for
control|(
name|yindex
operator|=
literal|0
init|;
name|yindex
operator|<
name|ras
operator|.
name|ycount
condition|;
name|yindex
operator|++
control|)
name|ras
operator|.
name|ycells
index|[
name|yindex
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|ras
operator|.
name|num_cells
operator|=
literal|0
expr_stmt|;
name|ras
operator|.
name|invalid
operator|=
literal|1
expr_stmt|;
name|ras
operator|.
name|min_ey
operator|=
name|band
operator|->
name|min
expr_stmt|;
name|ras
operator|.
name|max_ey
operator|=
name|band
operator|->
name|max
expr_stmt|;
name|ras
operator|.
name|count_ey
operator|=
name|band
operator|->
name|max
operator|-
name|band
operator|->
name|min
expr_stmt|;
name|error
operator|=
name|gray_convert_glyph_inner
argument_list|(
name|RAS_VAR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|gray_sweep
argument_list|(
name|RAS_VAR_
operator|&
name|ras
operator|.
name|target
argument_list|)
expr_stmt|;
name|band
operator|--
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|error
operator|!=
name|ErrRaster_Memory_Overflow
condition|)
return|return
literal|1
return|;
name|ReduceBands
label|:
comment|/* render pool overflow; we will reduce the render band by half */
name|bottom
operator|=
name|band
operator|->
name|min
expr_stmt|;
name|top
operator|=
name|band
operator|->
name|max
expr_stmt|;
name|middle
operator|=
name|bottom
operator|+
operator|(
operator|(
name|top
operator|-
name|bottom
operator|)
operator|>>
literal|1
operator|)
expr_stmt|;
comment|/* This is too complex for a single scanline; there must */
comment|/* be some problems.                                     */
if|if
condition|(
name|middle
operator|==
name|bottom
condition|)
block|{
ifdef|#
directive|ifdef
name|FT_DEBUG_LEVEL_TRACE
name|FT_TRACE7
argument_list|(
operator|(
literal|"gray_convert_glyph: rotten glyph\n"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|1
return|;
block|}
if|if
condition|(
name|bottom
operator|-
name|top
operator|>=
name|ras
operator|.
name|band_size
condition|)
name|ras
operator|.
name|band_shoot
operator|++
expr_stmt|;
name|band
index|[
literal|1
index|]
operator|.
name|min
operator|=
name|bottom
expr_stmt|;
name|band
index|[
literal|1
index|]
operator|.
name|max
operator|=
name|middle
expr_stmt|;
name|band
index|[
literal|0
index|]
operator|.
name|min
operator|=
name|middle
expr_stmt|;
name|band
index|[
literal|0
index|]
operator|.
name|max
operator|=
name|top
expr_stmt|;
name|band
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ras
operator|.
name|band_shoot
operator|>
literal|8
operator|&&
name|ras
operator|.
name|band_size
operator|>
literal|16
condition|)
name|ras
operator|.
name|band_size
operator|=
name|ras
operator|.
name|band_size
operator|/
literal|2
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|gray_raster_render
name|gray_raster_render
parameter_list|(
name|gray_PRaster
name|raster
parameter_list|,
specifier|const
name|FT_Raster_Params
modifier|*
name|params
parameter_list|)
block|{
specifier|const
name|FT_Outline
modifier|*
name|outline
init|=
operator|(
specifier|const
name|FT_Outline
operator|*
operator|)
name|params
operator|->
name|source
decl_stmt|;
specifier|const
name|FT_Bitmap
modifier|*
name|target_map
init|=
name|params
operator|->
name|target
decl_stmt|;
name|gray_PWorker
name|worker
decl_stmt|;
if|if
condition|(
operator|!
name|raster
operator|||
operator|!
name|raster
operator|->
name|buffer
operator|||
operator|!
name|raster
operator|->
name|buffer_size
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_Argument
argument_list|)
return|;
if|if
condition|(
operator|!
name|outline
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_Outline
argument_list|)
return|;
comment|/* return immediately if the outline is empty */
if|if
condition|(
name|outline
operator|->
name|n_points
operator|==
literal|0
operator|||
name|outline
operator|->
name|n_contours
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|outline
operator|->
name|contours
operator|||
operator|!
name|outline
operator|->
name|points
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_Outline
argument_list|)
return|;
if|if
condition|(
name|outline
operator|->
name|n_points
operator|!=
name|outline
operator|->
name|contours
index|[
name|outline
operator|->
name|n_contours
operator|-
literal|1
index|]
operator|+
literal|1
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_Outline
argument_list|)
return|;
name|worker
operator|=
name|raster
operator|->
name|worker
expr_stmt|;
comment|/* if direct mode is not set, we must have a target bitmap */
if|if
condition|(
operator|!
operator|(
name|params
operator|->
name|flags
operator|&
name|FT_RASTER_FLAG_DIRECT
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|target_map
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_Argument
argument_list|)
return|;
comment|/* nothing to do */
if|if
condition|(
operator|!
name|target_map
operator|->
name|width
operator|||
operator|!
name|target_map
operator|->
name|rows
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|target_map
operator|->
name|buffer
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_Argument
argument_list|)
return|;
block|}
comment|/* this version does not support monochrome rendering */
if|if
condition|(
operator|!
operator|(
name|params
operator|->
name|flags
operator|&
name|FT_RASTER_FLAG_AA
operator|)
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_Mode
argument_list|)
return|;
comment|/* compute clipping box */
if|if
condition|(
operator|!
operator|(
name|params
operator|->
name|flags
operator|&
name|FT_RASTER_FLAG_DIRECT
operator|)
condition|)
block|{
comment|/* compute clip box from target pixmap */
name|ras
operator|.
name|clip_box
operator|.
name|xMin
operator|=
literal|0
expr_stmt|;
name|ras
operator|.
name|clip_box
operator|.
name|yMin
operator|=
literal|0
expr_stmt|;
name|ras
operator|.
name|clip_box
operator|.
name|xMax
operator|=
name|target_map
operator|->
name|width
expr_stmt|;
name|ras
operator|.
name|clip_box
operator|.
name|yMax
operator|=
name|target_map
operator|->
name|rows
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|params
operator|->
name|flags
operator|&
name|FT_RASTER_FLAG_CLIP
condition|)
name|ras
operator|.
name|clip_box
operator|=
name|params
operator|->
name|clip_box
expr_stmt|;
else|else
block|{
name|ras
operator|.
name|clip_box
operator|.
name|xMin
operator|=
operator|-
literal|32768L
expr_stmt|;
name|ras
operator|.
name|clip_box
operator|.
name|yMin
operator|=
operator|-
literal|32768L
expr_stmt|;
name|ras
operator|.
name|clip_box
operator|.
name|xMax
operator|=
literal|32767L
expr_stmt|;
name|ras
operator|.
name|clip_box
operator|.
name|yMax
operator|=
literal|32767L
expr_stmt|;
block|}
name|gray_init_cells
argument_list|(
argument|RAS_VAR_ raster->buffer
argument_list|,
argument|raster->buffer_size
argument_list|)
empty_stmt|;
name|ras
operator|.
name|outline
operator|=
operator|*
name|outline
expr_stmt|;
name|ras
operator|.
name|num_cells
operator|=
literal|0
expr_stmt|;
name|ras
operator|.
name|invalid
operator|=
literal|1
expr_stmt|;
name|ras
operator|.
name|band_size
operator|=
name|raster
operator|->
name|band_size
expr_stmt|;
name|ras
operator|.
name|num_gray_spans
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|flags
operator|&
name|FT_RASTER_FLAG_DIRECT
condition|)
block|{
name|ras
operator|.
name|render_span
operator|=
operator|(
name|FT_Raster_Span_Func
operator|)
name|params
operator|->
name|gray_spans
expr_stmt|;
name|ras
operator|.
name|render_span_data
operator|=
name|params
operator|->
name|user
expr_stmt|;
block|}
else|else
block|{
name|ras
operator|.
name|target
operator|=
operator|*
name|target_map
expr_stmt|;
name|ras
operator|.
name|render_span
operator|=
operator|(
name|FT_Raster_Span_Func
operator|)
name|gray_render_span
expr_stmt|;
name|ras
operator|.
name|render_span_data
operator|=
operator|&
name|ras
expr_stmt|;
block|}
return|return
name|gray_convert_glyph
argument_list|(
name|RAS_VAR
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/**** RASTER OBJECT CREATION: In stand-alone mode, we simply use *****/
end_comment
begin_comment
comment|/****                         a static object.                   *****/
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|_STANDALONE_
end_ifdef
begin_function
specifier|static
name|int
DECL|function|gray_raster_new
name|gray_raster_new
parameter_list|(
name|void
modifier|*
name|memory
parameter_list|,
name|FT_Raster
modifier|*
name|araster
parameter_list|)
block|{
specifier|static
name|gray_TRaster
name|the_raster
decl_stmt|;
name|FT_UNUSED
argument_list|(
name|memory
argument_list|)
expr_stmt|;
operator|*
name|araster
operator|=
operator|(
name|FT_Raster
operator|)
operator|&
name|the_raster
expr_stmt|;
name|FT_MEM_ZERO
argument_list|(
operator|&
name|the_raster
argument_list|,
sizeof|sizeof
argument_list|(
name|the_raster
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|gray_raster_done
name|gray_raster_done
parameter_list|(
name|FT_Raster
name|raster
parameter_list|)
block|{
comment|/* nothing */
name|FT_UNUSED
argument_list|(
name|raster
argument_list|)
expr_stmt|;
block|}
end_function
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* !_STANDALONE_ */
end_comment
begin_function
specifier|static
name|int
DECL|function|gray_raster_new
name|gray_raster_new
parameter_list|(
name|FT_Memory
name|memory
parameter_list|,
name|FT_Raster
modifier|*
name|araster
parameter_list|)
block|{
name|FT_Error
name|error
decl_stmt|;
name|gray_PRaster
name|raster
init|=
name|NULL
decl_stmt|;
operator|*
name|araster
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|FT_ALLOC
argument_list|(
name|raster
argument_list|,
sizeof|sizeof
argument_list|(
name|gray_TRaster
argument_list|)
argument_list|)
condition|)
block|{
name|raster
operator|->
name|memory
operator|=
name|memory
expr_stmt|;
operator|*
name|araster
operator|=
operator|(
name|FT_Raster
operator|)
name|raster
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|gray_raster_done
name|gray_raster_done
parameter_list|(
name|FT_Raster
name|raster
parameter_list|)
block|{
name|FT_Memory
name|memory
init|=
call|(
name|FT_Memory
call|)
argument_list|(
operator|(
name|gray_PRaster
operator|)
name|raster
argument_list|)
operator|->
name|memory
decl_stmt|;
name|FT_FREE
argument_list|(
name|raster
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* !_STANDALONE_ */
end_comment
begin_function
specifier|static
name|void
DECL|function|gray_raster_reset
name|gray_raster_reset
parameter_list|(
name|FT_Raster
name|raster
parameter_list|,
name|char
modifier|*
name|pool_base
parameter_list|,
name|long
name|pool_size
parameter_list|)
block|{
name|gray_PRaster
name|rast
init|=
operator|(
name|gray_PRaster
operator|)
name|raster
decl_stmt|;
if|if
condition|(
name|raster
condition|)
block|{
if|if
condition|(
name|pool_base
operator|&&
name|pool_size
operator|>=
operator|(
name|long
operator|)
sizeof|sizeof
argument_list|(
name|gray_TWorker
argument_list|)
operator|+
literal|2048
condition|)
block|{
name|gray_PWorker
name|worker
init|=
operator|(
name|gray_PWorker
operator|)
name|pool_base
decl_stmt|;
name|rast
operator|->
name|worker
operator|=
name|worker
expr_stmt|;
name|rast
operator|->
name|buffer
operator|=
name|pool_base
operator|+
operator|(
operator|(
sizeof|sizeof
argument_list|(
name|gray_TWorker
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|TCell
argument_list|)
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
sizeof|sizeof
argument_list|(
name|TCell
argument_list|)
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|rast
operator|->
name|buffer_size
operator|=
call|(
name|long
call|)
argument_list|(
operator|(
name|pool_base
operator|+
name|pool_size
operator|)
operator|-
operator|(
name|char
operator|*
operator|)
name|rast
operator|->
name|buffer
argument_list|)
operator|&
operator|~
operator|(
sizeof|sizeof
argument_list|(
name|TCell
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
name|rast
operator|->
name|band_size
operator|=
call|(
name|int
call|)
argument_list|(
name|rast
operator|->
name|buffer_size
operator|/
operator|(
sizeof|sizeof
argument_list|(
name|TCell
argument_list|)
operator|*
literal|8
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rast
operator|->
name|buffer
operator|=
name|NULL
expr_stmt|;
name|rast
operator|->
name|buffer_size
operator|=
literal|0
expr_stmt|;
name|rast
operator|->
name|worker
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|gray_raster_set_mode
name|gray_raster_set_mode
parameter_list|(
name|FT_Raster
name|raster
parameter_list|,
name|unsigned
name|long
name|mode
parameter_list|,
name|void
modifier|*
name|args
parameter_list|)
block|{
name|FT_UNUSED
argument_list|(
name|raster
argument_list|)
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|args
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* nothing to do */
block|}
end_function
begin_macro
name|FT_DEFINE_RASTER_FUNCS
argument_list|(
argument|ft_grays_raster
argument_list|,
argument|FT_GLYPH_FORMAT_OUTLINE
argument_list|,
argument|(FT_Raster_New_Func)     gray_raster_new
argument_list|,
argument|(FT_Raster_Reset_Func)   gray_raster_reset
argument_list|,
argument|(FT_Raster_Set_Mode_Func)gray_raster_set_mode
argument_list|,
argument|(FT_Raster_Render_Func)  gray_raster_render
argument_list|,
argument|(FT_Raster_Done_Func)    gray_raster_done
argument_list|)
end_macro
begin_comment
comment|/* END */
end_comment
begin_comment
comment|/* Local Variables: */
end_comment
begin_comment
comment|/* coding: utf-8    */
end_comment
begin_comment
comment|/* End:             */
end_comment
end_unit
