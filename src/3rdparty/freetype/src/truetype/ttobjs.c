begin_unit
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  ttobjs.c                                                               */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*    Objects manager (body).                                              */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  Copyright 1996-2013                                                    */
end_comment
begin_comment
comment|/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  This file is part of the FreeType project, and may only be used,       */
end_comment
begin_comment
comment|/*  modified, and distributed under the terms of the FreeType project      */
end_comment
begin_comment
comment|/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
end_comment
begin_comment
comment|/*  this file you indicate that you have read the license and              */
end_comment
begin_comment
comment|/*  understand and accept it fully.                                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<ft2build.h>
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_DEBUG_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_STREAM_H
end_include
begin_include
include|#
directive|include
include|FT_TRUETYPE_TAGS_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_SFNT_H
end_include
begin_include
include|#
directive|include
include|FT_TRUETYPE_DRIVER_H
end_include
begin_include
include|#
directive|include
file|"ttgload.h"
end_include
begin_include
include|#
directive|include
file|"ttpload.h"
end_include
begin_include
include|#
directive|include
file|"tterrors.h"
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|TT_USE_BYTECODE_INTERPRETER
end_ifdef
begin_include
include|#
directive|include
file|"ttinterp.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_UNPATENTED_HINTING
end_ifdef
begin_include
include|#
directive|include
include|FT_TRUETYPE_UNPATENTED_H
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_GX_VAR_SUPPORT
end_ifdef
begin_include
include|#
directive|include
file|"ttgxvar.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
end_comment
begin_comment
comment|/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
end_comment
begin_comment
comment|/* messages during execution.                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_undef
DECL|macro|FT_COMPONENT
undef|#
directive|undef
name|FT_COMPONENT
end_undef
begin_define
DECL|macro|FT_COMPONENT
define|#
directive|define
name|FT_COMPONENT
value|trace_ttobjs
end_define
begin_ifdef
ifdef|#
directive|ifdef
name|TT_USE_BYTECODE_INTERPRETER
end_ifdef
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*                       GLYPH ZONE FUNCTIONS                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    tt_glyphzone_done                                                  */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Deallocate a glyph zone.                                           */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    zone :: A pointer to the target glyph zone.                        */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|tt_glyphzone_done
name|tt_glyphzone_done
argument_list|(
argument|TT_GlyphZone  zone
argument_list|)
end_macro
begin_block
block|{
name|FT_Memory
name|memory
init|=
name|zone
operator|->
name|memory
decl_stmt|;
if|if
condition|(
name|memory
condition|)
block|{
name|FT_FREE
argument_list|(
name|zone
operator|->
name|contours
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|zone
operator|->
name|tags
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|zone
operator|->
name|cur
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|zone
operator|->
name|org
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|zone
operator|->
name|orus
argument_list|)
expr_stmt|;
name|zone
operator|->
name|max_points
operator|=
name|zone
operator|->
name|n_points
operator|=
literal|0
expr_stmt|;
name|zone
operator|->
name|max_contours
operator|=
name|zone
operator|->
name|n_contours
operator|=
literal|0
expr_stmt|;
name|zone
operator|->
name|memory
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    tt_glyphzone_new                                                   */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Allocate a new glyph zone.                                         */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    memory      :: A handle to the current memory object.              */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    maxPoints   :: The capacity of glyph zone in points.               */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    maxContours :: The capacity of glyph zone in contours.             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Output>                                                              */
end_comment
begin_comment
comment|/*    zone        :: A pointer to the target glyph zone record.          */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    FreeType error code.  0 means success.                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|tt_glyphzone_new
argument_list|(
argument|FT_Memory     memory
argument_list|,
argument|FT_UShort     maxPoints
argument_list|,
argument|FT_Short      maxContours
argument_list|,
argument|TT_GlyphZone  zone
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
decl_stmt|;
name|FT_MEM_ZERO
argument_list|(
name|zone
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|zone
operator|->
name|memory
operator|=
name|memory
expr_stmt|;
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|zone
operator|->
name|org
argument_list|,
name|maxPoints
argument_list|)
operator|||
name|FT_NEW_ARRAY
argument_list|(
name|zone
operator|->
name|cur
argument_list|,
name|maxPoints
argument_list|)
operator|||
name|FT_NEW_ARRAY
argument_list|(
name|zone
operator|->
name|orus
argument_list|,
name|maxPoints
argument_list|)
operator|||
name|FT_NEW_ARRAY
argument_list|(
name|zone
operator|->
name|tags
argument_list|,
name|maxPoints
argument_list|)
operator|||
name|FT_NEW_ARRAY
argument_list|(
name|zone
operator|->
name|contours
argument_list|,
name|maxContours
argument_list|)
condition|)
block|{
name|tt_glyphzone_done
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zone
operator|->
name|max_points
operator|=
name|maxPoints
expr_stmt|;
name|zone
operator|->
name|max_contours
operator|=
name|maxContours
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_block
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* TT_USE_BYTECODE_INTERPRETER */
end_comment
begin_comment
comment|/* Compare the face with a list of well-known `tricky' fonts. */
end_comment
begin_comment
comment|/* This list shall be expanded as we find more of them.       */
end_comment
begin_function
specifier|static
name|FT_Bool
DECL|function|tt_check_trickyness_family
name|tt_check_trickyness_family
parameter_list|(
name|FT_String
modifier|*
name|name
parameter_list|)
block|{
DECL|macro|TRICK_NAMES_MAX_CHARACTERS
define|#
directive|define
name|TRICK_NAMES_MAX_CHARACTERS
value|19
DECL|macro|TRICK_NAMES_COUNT
define|#
directive|define
name|TRICK_NAMES_COUNT
value|9
specifier|static
specifier|const
name|char
name|trick_names
index|[
name|TRICK_NAMES_COUNT
index|]
index|[
name|TRICK_NAMES_MAX_CHARACTERS
operator|+
literal|1
index|]
init|=
block|{
literal|"DFKaiSho-SB"
block|,
comment|/* dfkaisb.ttf */
literal|"DFKaiShu"
block|,
literal|"DFKai-SB"
block|,
comment|/* kaiu.ttf */
literal|"HuaTianKaiTi?"
block|,
comment|/* htkt2.ttf */
literal|"HuaTianSongTi?"
block|,
comment|/* htst3.ttf */
literal|"Ming(for ISO10646)"
block|,
comment|/* hkscsiic.ttf& iicore.ttf */
literal|"MingLiU"
block|,
comment|/* mingliu.ttf& mingliu.ttc */
literal|"PMingLiU"
block|,
comment|/* mingliu.ttc */
literal|"MingLi43"
block|,
comment|/* mingli.ttf */
block|}
decl_stmt|;
name|int
name|nn
decl_stmt|;
for|for
control|(
name|nn
operator|=
literal|0
init|;
name|nn
operator|<
name|TRICK_NAMES_COUNT
condition|;
name|nn
operator|++
control|)
if|if
condition|(
name|ft_strstr
argument_list|(
name|name
argument_list|,
name|trick_names
index|[
name|nn
index|]
argument_list|)
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function
begin_comment
comment|/* XXX: This function should be in the `sfnt' module. */
end_comment
begin_comment
comment|/* Some PDF generators clear the checksums in the TrueType header table. */
end_comment
begin_comment
comment|/* For example, Quartz ContextPDF clears all entries, or Bullzip PDF     */
end_comment
begin_comment
comment|/* Printer clears the entries for subsetted subtables.  We thus have to  */
end_comment
begin_comment
comment|/* recalculate the checksums  where necessary.                           */
end_comment
begin_function
specifier|static
name|FT_UInt32
DECL|function|tt_synth_sfnt_checksum
name|tt_synth_sfnt_checksum
parameter_list|(
name|FT_Stream
name|stream
parameter_list|,
name|FT_ULong
name|length
parameter_list|)
block|{
name|FT_Error
name|error
decl_stmt|;
name|FT_UInt32
name|checksum
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|FT_FRAME_ENTER
argument_list|(
name|length
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
init|;
name|length
operator|>
literal|3
condition|;
name|length
operator|-=
literal|4
control|)
name|checksum
operator|+=
operator|(
name|FT_UInt32
operator|)
name|FT_GET_ULONG
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|3
init|;
name|length
operator|>
literal|0
condition|;
name|length
operator|--
operator|,
name|i
operator|--
control|)
name|checksum
operator|+=
call|(
name|FT_UInt32
call|)
argument_list|(
name|FT_GET_BYTE
argument_list|()
operator|<<
operator|(
name|i
operator|*
literal|8
operator|)
argument_list|)
expr_stmt|;
name|FT_FRAME_EXIT
argument_list|()
expr_stmt|;
return|return
name|checksum
return|;
block|}
end_function
begin_comment
comment|/* XXX: This function should be in the `sfnt' module. */
end_comment
begin_function
specifier|static
name|FT_ULong
DECL|function|tt_get_sfnt_checksum
name|tt_get_sfnt_checksum
parameter_list|(
name|TT_Face
name|face
parameter_list|,
name|FT_UShort
name|i
parameter_list|)
block|{
if|#
directive|if
literal|0
comment|/* if we believe the written value, use following part. */
block|if ( face->dir_tables[i].CheckSum )       return face->dir_tables[i].CheckSum;
endif|#
directive|endif
if|if
condition|(
operator|!
name|face
operator|->
name|goto_table
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|face
operator|->
name|goto_table
argument_list|(
name|face
argument_list|,
name|face
operator|->
name|dir_tables
index|[
name|i
index|]
operator|.
name|Tag
argument_list|,
name|face
operator|->
name|root
operator|.
name|stream
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|FT_ULong
operator|)
name|tt_synth_sfnt_checksum
argument_list|(
name|face
operator|->
name|root
operator|.
name|stream
argument_list|,
name|face
operator|->
name|dir_tables
index|[
name|i
index|]
operator|.
name|Length
argument_list|)
return|;
block|}
end_function
begin_typedef
DECL|struct|tt_sfnt_id_rec_
typedef|typedef
struct|struct
name|tt_sfnt_id_rec_
block|{
DECL|member|CheckSum
name|FT_ULong
name|CheckSum
decl_stmt|;
DECL|member|Length
name|FT_ULong
name|Length
decl_stmt|;
block|}
DECL|typedef|tt_sfnt_id_rec
name|tt_sfnt_id_rec
typedef|;
end_typedef
begin_function
specifier|static
name|FT_Bool
DECL|function|tt_check_trickyness_sfnt_ids
name|tt_check_trickyness_sfnt_ids
parameter_list|(
name|TT_Face
name|face
parameter_list|)
block|{
DECL|macro|TRICK_SFNT_IDS_PER_FACE
define|#
directive|define
name|TRICK_SFNT_IDS_PER_FACE
value|3
DECL|macro|TRICK_SFNT_IDS_NUM_FACES
define|#
directive|define
name|TRICK_SFNT_IDS_NUM_FACES
value|17
specifier|static
specifier|const
name|tt_sfnt_id_rec
name|sfnt_id
index|[
name|TRICK_SFNT_IDS_NUM_FACES
index|]
index|[
name|TRICK_SFNT_IDS_PER_FACE
index|]
init|=
block|{
DECL|macro|TRICK_SFNT_ID_cvt
define|#
directive|define
name|TRICK_SFNT_ID_cvt
value|0
DECL|macro|TRICK_SFNT_ID_fpgm
define|#
directive|define
name|TRICK_SFNT_ID_fpgm
value|1
DECL|macro|TRICK_SFNT_ID_prep
define|#
directive|define
name|TRICK_SFNT_ID_prep
value|2
block|{
comment|/* MingLiU 1995 */
block|{
literal|0x05BCF058UL
block|,
literal|0x000002E4UL
block|}
block|,
comment|/* cvt  */
block|{
literal|0x28233BF1UL
block|,
literal|0x000087C4UL
block|}
block|,
comment|/* fpgm */
block|{
literal|0xA344A1EAUL
block|,
literal|0x000001E1UL
block|}
comment|/* prep */
block|}
block|,
block|{
comment|/* MingLiU 1996- */
block|{
literal|0x05BCF058UL
block|,
literal|0x000002E4UL
block|}
block|,
comment|/* cvt  */
block|{
literal|0x28233BF1UL
block|,
literal|0x000087C4UL
block|}
block|,
comment|/* fpgm */
block|{
literal|0xA344A1EBUL
block|,
literal|0x000001E1UL
block|}
comment|/* prep */
block|}
block|,
block|{
comment|/* DFKaiShu */
block|{
literal|0x11E5EAD4UL
block|,
literal|0x00000350UL
block|}
block|,
comment|/* cvt  */
block|{
literal|0x5A30CA3BUL
block|,
literal|0x00009063UL
block|}
block|,
comment|/* fpgm */
block|{
literal|0x13A42602UL
block|,
literal|0x0000007EUL
block|}
comment|/* prep */
block|}
block|,
block|{
comment|/* HuaTianKaiTi */
block|{
literal|0xFFFBFFFCUL
block|,
literal|0x00000008UL
block|}
block|,
comment|/* cvt  */
block|{
literal|0x9C9E48B8UL
block|,
literal|0x0000BEA2UL
block|}
block|,
comment|/* fpgm */
block|{
literal|0x70020112UL
block|,
literal|0x00000008UL
block|}
comment|/* prep */
block|}
block|,
block|{
comment|/* HuaTianSongTi */
block|{
literal|0xFFFBFFFCUL
block|,
literal|0x00000008UL
block|}
block|,
comment|/* cvt  */
block|{
literal|0x0A5A0483UL
block|,
literal|0x00017C39UL
block|}
block|,
comment|/* fpgm */
block|{
literal|0x70020112UL
block|,
literal|0x00000008UL
block|}
comment|/* prep */
block|}
block|,
block|{
comment|/* NEC fadpop7.ttf */
block|{
literal|0x00000000UL
block|,
literal|0x00000000UL
block|}
block|,
comment|/* cvt  */
block|{
literal|0x40C92555UL
block|,
literal|0x000000E5UL
block|}
block|,
comment|/* fpgm */
block|{
literal|0xA39B58E3UL
block|,
literal|0x0000117CUL
block|}
comment|/* prep */
block|}
block|,
block|{
comment|/* NEC fadrei5.ttf */
block|{
literal|0x00000000UL
block|,
literal|0x00000000UL
block|}
block|,
comment|/* cvt  */
block|{
literal|0x33C41652UL
block|,
literal|0x000000E5UL
block|}
block|,
comment|/* fpgm */
block|{
literal|0x26D6C52AUL
block|,
literal|0x00000F6AUL
block|}
comment|/* prep */
block|}
block|,
block|{
comment|/* NEC fangot7.ttf */
block|{
literal|0x00000000UL
block|,
literal|0x00000000UL
block|}
block|,
comment|/* cvt  */
block|{
literal|0x6DB1651DUL
block|,
literal|0x0000019DUL
block|}
block|,
comment|/* fpgm */
block|{
literal|0x6C6E4B03UL
block|,
literal|0x00002492UL
block|}
comment|/* prep */
block|}
block|,
block|{
comment|/* NEC fangyo5.ttf */
block|{
literal|0x00000000UL
block|,
literal|0x00000000UL
block|}
block|,
comment|/* cvt  */
block|{
literal|0x40C92555UL
block|,
literal|0x000000E5UL
block|}
block|,
comment|/* fpgm */
block|{
literal|0xDE51FAD0UL
block|,
literal|0x0000117CUL
block|}
comment|/* prep */
block|}
block|,
block|{
comment|/* NEC fankyo5.ttf */
block|{
literal|0x00000000UL
block|,
literal|0x00000000UL
block|}
block|,
comment|/* cvt  */
block|{
literal|0x85E47664UL
block|,
literal|0x000000E5UL
block|}
block|,
comment|/* fpgm */
block|{
literal|0xA6C62831UL
block|,
literal|0x00001CAAUL
block|}
comment|/* prep */
block|}
block|,
block|{
comment|/* NEC fanrgo5.ttf */
block|{
literal|0x00000000UL
block|,
literal|0x00000000UL
block|}
block|,
comment|/* cvt  */
block|{
literal|0x2D891CFDUL
block|,
literal|0x0000019DUL
block|}
block|,
comment|/* fpgm */
block|{
literal|0xA0604633UL
block|,
literal|0x00001DE8UL
block|}
comment|/* prep */
block|}
block|,
block|{
comment|/* NEC fangot5.ttc */
block|{
literal|0x00000000UL
block|,
literal|0x00000000UL
block|}
block|,
comment|/* cvt  */
block|{
literal|0x40AA774CUL
block|,
literal|0x000001CBUL
block|}
block|,
comment|/* fpgm */
block|{
literal|0x9B5CAA96UL
block|,
literal|0x00001F9AUL
block|}
comment|/* prep */
block|}
block|,
block|{
comment|/* NEC fanmin3.ttc */
block|{
literal|0x00000000UL
block|,
literal|0x00000000UL
block|}
block|,
comment|/* cvt  */
block|{
literal|0x0D3DE9CBUL
block|,
literal|0x00000141UL
block|}
block|,
comment|/* fpgm */
block|{
literal|0xD4127766UL
block|,
literal|0x00002280UL
block|}
comment|/* prep */
block|}
block|,
block|{
comment|/* NEC FA-Gothic, 1996 */
block|{
literal|0x00000000UL
block|,
literal|0x00000000UL
block|}
block|,
comment|/* cvt  */
block|{
literal|0x4A692698UL
block|,
literal|0x000001F0UL
block|}
block|,
comment|/* fpgm */
block|{
literal|0x340D4346UL
block|,
literal|0x00001FCAUL
block|}
comment|/* prep */
block|}
block|,
block|{
comment|/* NEC FA-Minchou, 1996 */
block|{
literal|0x00000000UL
block|,
literal|0x00000000UL
block|}
block|,
comment|/* cvt  */
block|{
literal|0xCD34C604UL
block|,
literal|0x00000166UL
block|}
block|,
comment|/* fpgm */
block|{
literal|0x6CF31046UL
block|,
literal|0x000022B0UL
block|}
comment|/* prep */
block|}
block|,
block|{
comment|/* NEC FA-RoundGothicB, 1996 */
block|{
literal|0x00000000UL
block|,
literal|0x00000000UL
block|}
block|,
comment|/* cvt  */
block|{
literal|0x5DA75315UL
block|,
literal|0x0000019DUL
block|}
block|,
comment|/* fpgm */
block|{
literal|0x40745A5FUL
block|,
literal|0x000022E0UL
block|}
comment|/* prep */
block|}
block|,
block|{
comment|/* NEC FA-RoundGothicM, 1996 */
block|{
literal|0x00000000UL
block|,
literal|0x00000000UL
block|}
block|,
comment|/* cvt  */
block|{
literal|0xF055FC48UL
block|,
literal|0x000001C2UL
block|}
block|,
comment|/* fpgm */
block|{
literal|0x3900DED3UL
block|,
literal|0x00001E18UL
block|}
comment|/* prep */
block|}
block|}
decl_stmt|;
name|FT_ULong
name|checksum
decl_stmt|;
name|int
name|num_matched_ids
index|[
name|TRICK_SFNT_IDS_NUM_FACES
index|]
decl_stmt|;
name|FT_Bool
name|has_cvt
decl_stmt|,
name|has_fpgm
decl_stmt|,
name|has_prep
decl_stmt|;
name|FT_UShort
name|i
decl_stmt|;
name|int
name|j
decl_stmt|,
name|k
decl_stmt|;
name|FT_MEM_SET
argument_list|(
name|num_matched_ids
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|TRICK_SFNT_IDS_NUM_FACES
argument_list|)
expr_stmt|;
name|has_cvt
operator|=
name|FALSE
expr_stmt|;
name|has_fpgm
operator|=
name|FALSE
expr_stmt|;
name|has_prep
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|face
operator|->
name|num_tables
condition|;
name|i
operator|++
control|)
block|{
name|checksum
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|face
operator|->
name|dir_tables
index|[
name|i
index|]
operator|.
name|Tag
condition|)
block|{
case|case
name|TTAG_cvt
case|:
name|k
operator|=
name|TRICK_SFNT_ID_cvt
expr_stmt|;
name|has_cvt
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|TTAG_fpgm
case|:
name|k
operator|=
name|TRICK_SFNT_ID_fpgm
expr_stmt|;
name|has_fpgm
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|TTAG_prep
case|:
name|k
operator|=
name|TRICK_SFNT_ID_prep
expr_stmt|;
name|has_prep
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
continue|continue;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|TRICK_SFNT_IDS_NUM_FACES
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|face
operator|->
name|dir_tables
index|[
name|i
index|]
operator|.
name|Length
operator|==
name|sfnt_id
index|[
name|j
index|]
index|[
name|k
index|]
operator|.
name|Length
condition|)
block|{
if|if
condition|(
operator|!
name|checksum
condition|)
name|checksum
operator|=
name|tt_get_sfnt_checksum
argument_list|(
name|face
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|sfnt_id
index|[
name|j
index|]
index|[
name|k
index|]
operator|.
name|CheckSum
operator|==
name|checksum
condition|)
name|num_matched_ids
index|[
name|j
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|num_matched_ids
index|[
name|j
index|]
operator|==
name|TRICK_SFNT_IDS_PER_FACE
condition|)
return|return
name|TRUE
return|;
block|}
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|TRICK_SFNT_IDS_NUM_FACES
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|has_cvt
operator|&&
operator|!
name|sfnt_id
index|[
name|j
index|]
index|[
name|TRICK_SFNT_ID_cvt
index|]
operator|.
name|Length
condition|)
name|num_matched_ids
index|[
name|j
index|]
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|has_fpgm
operator|&&
operator|!
name|sfnt_id
index|[
name|j
index|]
index|[
name|TRICK_SFNT_ID_fpgm
index|]
operator|.
name|Length
condition|)
name|num_matched_ids
index|[
name|j
index|]
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|has_prep
operator|&&
operator|!
name|sfnt_id
index|[
name|j
index|]
index|[
name|TRICK_SFNT_ID_prep
index|]
operator|.
name|Length
condition|)
name|num_matched_ids
index|[
name|j
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|num_matched_ids
index|[
name|j
index|]
operator|==
name|TRICK_SFNT_IDS_PER_FACE
condition|)
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function
begin_function
specifier|static
name|FT_Bool
DECL|function|tt_check_trickyness
name|tt_check_trickyness
parameter_list|(
name|FT_Face
name|face
parameter_list|)
block|{
if|if
condition|(
operator|!
name|face
condition|)
return|return
name|FALSE
return|;
comment|/* For first, check the face name for quick check. */
if|if
condition|(
name|face
operator|->
name|family_name
operator|&&
name|tt_check_trickyness_family
argument_list|(
name|face
operator|->
name|family_name
argument_list|)
condition|)
return|return
name|TRUE
return|;
comment|/* Type42 fonts may lack `name' tables, we thus try to identify */
comment|/* tricky fonts by checking the checksums of Type42-persistent  */
comment|/* sfnt tables (`cvt', `fpgm', and `prep').                     */
if|if
condition|(
name|tt_check_trickyness_sfnt_ids
argument_list|(
operator|(
name|TT_Face
operator|)
name|face
argument_list|)
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function
begin_comment
comment|/* Check whether `.notdef' is the only glyph in the `loca' table. */
end_comment
begin_function
specifier|static
name|FT_Bool
DECL|function|tt_check_single_notdef
name|tt_check_single_notdef
parameter_list|(
name|FT_Face
name|ttface
parameter_list|)
block|{
name|FT_Bool
name|result
init|=
name|FALSE
decl_stmt|;
name|TT_Face
name|face
init|=
operator|(
name|TT_Face
operator|)
name|ttface
decl_stmt|;
name|FT_UInt
name|asize
decl_stmt|;
name|FT_ULong
name|i
decl_stmt|;
name|FT_ULong
name|glyph_index
init|=
literal|0
decl_stmt|;
name|FT_UInt
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|face
operator|->
name|num_locations
condition|;
name|i
operator|++
control|)
block|{
name|tt_face_get_location
argument_list|(
name|face
argument_list|,
name|i
argument_list|,
operator|&
name|asize
argument_list|)
expr_stmt|;
if|if
condition|(
name|asize
operator|>
literal|0
condition|)
block|{
name|count
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|1
condition|)
break|break;
name|glyph_index
operator|=
name|i
expr_stmt|;
block|}
block|}
comment|/* Only have a single outline. */
if|if
condition|(
name|count
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|glyph_index
operator|==
literal|0
condition|)
name|result
operator|=
name|TRUE
expr_stmt|;
else|else
block|{
comment|/* FIXME: Need to test glyphname == .notdef ? */
name|FT_Error
name|error
decl_stmt|;
name|char
name|buf
index|[
literal|8
index|]
decl_stmt|;
name|error
operator|=
name|FT_Get_Glyph_Name
argument_list|(
name|ttface
argument_list|,
name|glyph_index
argument_list|,
name|buf
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
name|buf
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
operator|!
name|ft_strncmp
argument_list|(
name|buf
argument_list|,
literal|".notdef"
argument_list|,
literal|8
argument_list|)
condition|)
name|result
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    tt_face_init                                                       */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Initialize a given TrueType face object.                           */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    stream     :: The source font stream.                              */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    face_index :: The index of the font face in the resource.          */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    num_params :: Number of additional generic parameters.  Ignored.   */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    params     :: Additional generic parameters.  Ignored.             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<InOut>                                                               */
end_comment
begin_comment
comment|/*    face       :: The newly built face object.                         */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    FreeType error code.  0 means success.                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|tt_face_init
argument_list|(
argument|FT_Stream      stream
argument_list|,
argument|FT_Face        ttface
argument_list|,
comment|/* TT_Face */
argument|FT_Int         face_index
argument_list|,
argument|FT_Int         num_params
argument_list|,
argument|FT_Parameter*  params
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
decl_stmt|;
name|FT_Library
name|library
decl_stmt|;
name|SFNT_Service
name|sfnt
decl_stmt|;
name|TT_Face
name|face
init|=
operator|(
name|TT_Face
operator|)
name|ttface
decl_stmt|;
name|FT_TRACE2
argument_list|(
operator|(
literal|"TTF driver\n"
operator|)
argument_list|)
expr_stmt|;
name|library
operator|=
name|ttface
operator|->
name|driver
operator|->
name|root
operator|.
name|library
expr_stmt|;
name|sfnt
operator|=
operator|(
name|SFNT_Service
operator|)
name|FT_Get_Module_Interface
argument_list|(
name|library
argument_list|,
literal|"sfnt"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sfnt
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"tt_face_init: cannot access `sfnt' module\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|FT_THROW
argument_list|(
name|Missing_Module
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* create input stream from resource */
if|if
condition|(
name|FT_STREAM_SEEK
argument_list|(
literal|0
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
comment|/* check that we have a valid TrueType file */
name|error
operator|=
name|sfnt
operator|->
name|init_face
argument_list|(
name|stream
argument_list|,
name|face
argument_list|,
name|face_index
argument_list|,
name|num_params
argument_list|,
name|params
argument_list|)
expr_stmt|;
comment|/* Stream may have changed. */
name|stream
operator|=
name|face
operator|->
name|root
operator|.
name|stream
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
comment|/* We must also be able to accept Mac/GX fonts, as well as OT ones. */
comment|/* The 0x00020000 tag is completely undocumented; some fonts from   */
comment|/* Arphic made for Chinese Windows 3.1 have this.                   */
if|if
condition|(
name|face
operator|->
name|format_tag
operator|!=
literal|0x00010000L
operator|&&
comment|/* MS fonts  */
name|face
operator|->
name|format_tag
operator|!=
literal|0x00020000L
operator|&&
comment|/* CJK fonts for Win 3.1 */
name|face
operator|->
name|format_tag
operator|!=
name|TTAG_true
condition|)
comment|/* Mac fonts */
block|{
name|FT_TRACE2
argument_list|(
operator|(
literal|"  not a TTF font\n"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|Bad_Format
goto|;
block|}
ifdef|#
directive|ifdef
name|TT_USE_BYTECODE_INTERPRETER
name|ttface
operator|->
name|face_flags
operator||=
name|FT_FACE_FLAG_HINTER
expr_stmt|;
endif|#
directive|endif
comment|/* If we are performing a simple font format check, exit immediately. */
if|if
condition|(
name|face_index
operator|<
literal|0
condition|)
return|return
name|FT_Err_Ok
return|;
comment|/* Load font directory */
name|error
operator|=
name|sfnt
operator|->
name|load_face
argument_list|(
name|stream
argument_list|,
name|face
argument_list|,
name|face_index
argument_list|,
name|num_params
argument_list|,
name|params
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
if|if
condition|(
name|tt_check_trickyness
argument_list|(
name|ttface
argument_list|)
condition|)
name|ttface
operator|->
name|face_flags
operator||=
name|FT_FACE_FLAG_TRICKY
expr_stmt|;
name|error
operator|=
name|tt_face_load_hdmx
argument_list|(
name|face
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
if|if
condition|(
name|FT_IS_SCALABLE
argument_list|(
name|ttface
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|FT_CONFIG_OPTION_INCREMENTAL
if|if
condition|(
operator|!
name|ttface
operator|->
name|internal
operator|->
name|incremental_interface
condition|)
name|error
operator|=
name|tt_face_load_loca
argument_list|(
name|face
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|tt_face_load_cvt
argument_list|(
name|face
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|tt_face_load_fpgm
argument_list|(
name|face
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|tt_face_load_prep
argument_list|(
name|face
argument_list|,
name|stream
argument_list|)
expr_stmt|;
comment|/* Check the scalable flag based on `loca'. */
if|if
condition|(
operator|!
name|ttface
operator|->
name|internal
operator|->
name|incremental_interface
operator|&&
name|ttface
operator|->
name|num_fixed_sizes
operator|&&
name|face
operator|->
name|glyph_locations
operator|&&
name|tt_check_single_notdef
argument_list|(
name|ttface
argument_list|)
condition|)
block|{
name|FT_TRACE5
argument_list|(
operator|(
literal|"tt_face_init:"
literal|" Only the `.notdef' glyph has an outline.\n"
literal|"             "
literal|" Resetting scalable flag to FALSE.\n"
operator|)
argument_list|)
expr_stmt|;
name|ttface
operator|->
name|face_flags
operator|&=
operator|~
name|FT_FACE_FLAG_SCALABLE
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|tt_face_load_loca
argument_list|(
name|face
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|tt_face_load_cvt
argument_list|(
name|face
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|tt_face_load_fpgm
argument_list|(
name|face
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|tt_face_load_prep
argument_list|(
name|face
argument_list|,
name|stream
argument_list|)
expr_stmt|;
comment|/* Check the scalable flag based on `loca'. */
if|if
condition|(
name|ttface
operator|->
name|num_fixed_sizes
operator|&&
name|face
operator|->
name|glyph_locations
operator|&&
name|tt_check_single_notdef
argument_list|(
name|ttface
argument_list|)
condition|)
block|{
name|FT_TRACE5
argument_list|(
operator|(
literal|"tt_face_init:"
literal|" Only the `.notdef' glyph has an outline.\n"
literal|"             "
literal|" Resetting scalable flag to FALSE.\n"
operator|)
argument_list|)
expr_stmt|;
name|ttface
operator|->
name|face_flags
operator|&=
operator|~
name|FT_FACE_FLAG_SCALABLE
expr_stmt|;
block|}
endif|#
directive|endif
block|}
if|#
directive|if
name|defined
argument_list|(
name|TT_CONFIG_OPTION_UNPATENTED_HINTING
argument_list|)
operator|&&
expr|\
operator|!
name|defined
argument_list|(
name|TT_CONFIG_OPTION_BYTECODE_INTERPRETER
argument_list|)
block|{
name|FT_Bool
name|unpatented_hinting
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Determine whether unpatented hinting is to be used for this face. */
name|unpatented_hinting
operator|=
name|FT_BOOL
argument_list|(
name|library
operator|->
name|debug_hooks
index|[
name|FT_DEBUG_HOOK_UNPATENTED_HINTING
index|]
operator|!=
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_params
operator|&&
operator|!
name|face
operator|->
name|unpatented_hinting
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|params
index|[
name|i
index|]
operator|.
name|tag
operator|==
name|FT_PARAM_TAG_UNPATENTED_HINTING
condition|)
name|unpatented_hinting
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|unpatented_hinting
condition|)
name|ttface
operator|->
name|internal
operator|->
name|ignore_unpatented_hinter
operator|=
name|TRUE
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* TT_CONFIG_OPTION_UNPATENTED_HINTING&&           !TT_CONFIG_OPTION_BYTECODE_INTERPRETER */
comment|/* initialize standard glyph loading routines */
name|TT_Init_Glyph_Loading
argument_list|(
name|face
argument_list|)
expr_stmt|;
name|Exit
label|:
return|return
name|error
return|;
name|Bad_Format
label|:
name|error
operator|=
name|FT_THROW
argument_list|(
name|Unknown_File_Format
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    tt_face_done                                                       */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Finalize a given face object.                                      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    face :: A pointer to the face object to destroy.                   */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|tt_face_done
name|tt_face_done
argument_list|(
argument|FT_Face  ttface
argument_list|)
end_macro
begin_comment
DECL|function|tt_face_done
comment|/* TT_Face */
end_comment
begin_block
block|{
name|TT_Face
name|face
init|=
operator|(
name|TT_Face
operator|)
name|ttface
decl_stmt|;
name|FT_Memory
name|memory
decl_stmt|;
name|FT_Stream
name|stream
decl_stmt|;
name|SFNT_Service
name|sfnt
decl_stmt|;
if|if
condition|(
operator|!
name|face
condition|)
return|return;
name|memory
operator|=
name|ttface
operator|->
name|memory
expr_stmt|;
name|stream
operator|=
name|ttface
operator|->
name|stream
expr_stmt|;
name|sfnt
operator|=
operator|(
name|SFNT_Service
operator|)
name|face
operator|->
name|sfnt
expr_stmt|;
comment|/* for `extended TrueType formats' (i.e. compressed versions) */
if|if
condition|(
name|face
operator|->
name|extra
operator|.
name|finalizer
condition|)
name|face
operator|->
name|extra
operator|.
name|finalizer
argument_list|(
name|face
operator|->
name|extra
operator|.
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|sfnt
condition|)
name|sfnt
operator|->
name|done_face
argument_list|(
name|face
argument_list|)
expr_stmt|;
comment|/* freeing the locations table */
name|tt_face_done_loca
argument_list|(
name|face
argument_list|)
expr_stmt|;
name|tt_face_free_hdmx
argument_list|(
name|face
argument_list|)
expr_stmt|;
comment|/* freeing the CVT */
name|FT_FREE
argument_list|(
name|face
operator|->
name|cvt
argument_list|)
expr_stmt|;
name|face
operator|->
name|cvt_size
operator|=
literal|0
expr_stmt|;
comment|/* freeing the programs */
name|FT_FRAME_RELEASE
argument_list|(
name|face
operator|->
name|font_program
argument_list|)
expr_stmt|;
name|FT_FRAME_RELEASE
argument_list|(
name|face
operator|->
name|cvt_program
argument_list|)
expr_stmt|;
name|face
operator|->
name|font_program_size
operator|=
literal|0
expr_stmt|;
name|face
operator|->
name|cvt_program_size
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_GX_VAR_SUPPORT
name|tt_done_blend
argument_list|(
name|memory
argument_list|,
name|face
operator|->
name|blend
argument_list|)
expr_stmt|;
name|face
operator|->
name|blend
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*                           SIZE  FUNCTIONS                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|TT_USE_BYTECODE_INTERPRETER
end_ifdef
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    tt_size_run_fpgm                                                   */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Run the font program.                                              */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    size     :: A handle to the size object.                           */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    pedantic :: Set if bytecode execution should be pedantic.          */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    FreeType error code.  0 means success.                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|tt_size_run_fpgm
argument_list|(
argument|TT_Size  size
argument_list|,
argument|FT_Bool  pedantic
argument_list|)
end_macro
begin_block
block|{
name|TT_Face
name|face
init|=
operator|(
name|TT_Face
operator|)
name|size
operator|->
name|root
operator|.
name|face
decl_stmt|;
name|TT_ExecContext
name|exec
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
comment|/* debugging instances have their own context */
if|if
condition|(
name|size
operator|->
name|debug
condition|)
name|exec
operator|=
name|size
operator|->
name|context
expr_stmt|;
else|else
name|exec
operator|=
operator|(
operator|(
name|TT_Driver
operator|)
name|FT_FACE_DRIVER
argument_list|(
name|face
argument_list|)
operator|)
operator|->
name|context
expr_stmt|;
if|if
condition|(
operator|!
name|exec
condition|)
return|return
name|FT_THROW
argument_list|(
name|Could_Not_Find_Context
argument_list|)
return|;
name|error
operator|=
name|TT_Load_Context
argument_list|(
name|exec
argument_list|,
name|face
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|exec
operator|->
name|callTop
operator|=
literal|0
expr_stmt|;
name|exec
operator|->
name|top
operator|=
literal|0
expr_stmt|;
name|exec
operator|->
name|period
operator|=
literal|64
expr_stmt|;
name|exec
operator|->
name|phase
operator|=
literal|0
expr_stmt|;
name|exec
operator|->
name|threshold
operator|=
literal|0
expr_stmt|;
name|exec
operator|->
name|instruction_trap
operator|=
name|FALSE
expr_stmt|;
name|exec
operator|->
name|F_dot_P
operator|=
literal|0x4000L
expr_stmt|;
name|exec
operator|->
name|pedantic_hinting
operator|=
name|pedantic
expr_stmt|;
block|{
name|FT_Size_Metrics
modifier|*
name|metrics
init|=
operator|&
name|exec
operator|->
name|metrics
decl_stmt|;
name|TT_Size_Metrics
modifier|*
name|tt_metrics
init|=
operator|&
name|exec
operator|->
name|tt_metrics
decl_stmt|;
name|metrics
operator|->
name|x_ppem
operator|=
literal|0
expr_stmt|;
name|metrics
operator|->
name|y_ppem
operator|=
literal|0
expr_stmt|;
name|metrics
operator|->
name|x_scale
operator|=
literal|0
expr_stmt|;
name|metrics
operator|->
name|y_scale
operator|=
literal|0
expr_stmt|;
name|tt_metrics
operator|->
name|ppem
operator|=
literal|0
expr_stmt|;
name|tt_metrics
operator|->
name|scale
operator|=
literal|0
expr_stmt|;
name|tt_metrics
operator|->
name|ratio
operator|=
literal|0x10000L
expr_stmt|;
block|}
comment|/* allow font program execution */
name|TT_Set_CodeRange
argument_list|(
name|exec
argument_list|,
name|tt_coderange_font
argument_list|,
name|face
operator|->
name|font_program
argument_list|,
name|face
operator|->
name|font_program_size
argument_list|)
expr_stmt|;
comment|/* disable CVT and glyph programs coderange */
name|TT_Clear_CodeRange
argument_list|(
name|exec
argument_list|,
name|tt_coderange_cvt
argument_list|)
expr_stmt|;
name|TT_Clear_CodeRange
argument_list|(
name|exec
argument_list|,
name|tt_coderange_glyph
argument_list|)
expr_stmt|;
if|if
condition|(
name|face
operator|->
name|font_program_size
operator|>
literal|0
condition|)
block|{
name|TT_Goto_CodeRange
argument_list|(
name|exec
argument_list|,
name|tt_coderange_font
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FT_TRACE4
argument_list|(
operator|(
literal|"Executing `fpgm' table.\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|face
operator|->
name|interpreter
argument_list|(
name|exec
argument_list|)
expr_stmt|;
block|}
else|else
name|error
operator|=
name|FT_Err_Ok
expr_stmt|;
name|size
operator|->
name|bytecode_ready
operator|=
name|error
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|TT_Save_Context
argument_list|(
name|exec
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    tt_size_run_prep                                                   */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Run the control value program.                                     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    size     :: A handle to the size object.                           */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    pedantic :: Set if bytecode execution should be pedantic.          */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    FreeType error code.  0 means success.                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|tt_size_run_prep
argument_list|(
argument|TT_Size  size
argument_list|,
argument|FT_Bool  pedantic
argument_list|)
end_macro
begin_block
block|{
name|TT_Face
name|face
init|=
operator|(
name|TT_Face
operator|)
name|size
operator|->
name|root
operator|.
name|face
decl_stmt|;
name|TT_ExecContext
name|exec
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
comment|/* debugging instances have their own context */
if|if
condition|(
name|size
operator|->
name|debug
condition|)
name|exec
operator|=
name|size
operator|->
name|context
expr_stmt|;
else|else
name|exec
operator|=
operator|(
operator|(
name|TT_Driver
operator|)
name|FT_FACE_DRIVER
argument_list|(
name|face
argument_list|)
operator|)
operator|->
name|context
expr_stmt|;
if|if
condition|(
operator|!
name|exec
condition|)
return|return
name|FT_THROW
argument_list|(
name|Could_Not_Find_Context
argument_list|)
return|;
name|error
operator|=
name|TT_Load_Context
argument_list|(
name|exec
argument_list|,
name|face
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|exec
operator|->
name|callTop
operator|=
literal|0
expr_stmt|;
name|exec
operator|->
name|top
operator|=
literal|0
expr_stmt|;
name|exec
operator|->
name|instruction_trap
operator|=
name|FALSE
expr_stmt|;
name|exec
operator|->
name|pedantic_hinting
operator|=
name|pedantic
expr_stmt|;
name|TT_Set_CodeRange
argument_list|(
name|exec
argument_list|,
name|tt_coderange_cvt
argument_list|,
name|face
operator|->
name|cvt_program
argument_list|,
name|face
operator|->
name|cvt_program_size
argument_list|)
expr_stmt|;
name|TT_Clear_CodeRange
argument_list|(
name|exec
argument_list|,
name|tt_coderange_glyph
argument_list|)
expr_stmt|;
if|if
condition|(
name|face
operator|->
name|cvt_program_size
operator|>
literal|0
condition|)
block|{
name|TT_Goto_CodeRange
argument_list|(
name|exec
argument_list|,
name|tt_coderange_cvt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|size
operator|->
name|debug
condition|)
block|{
name|FT_TRACE4
argument_list|(
operator|(
literal|"Executing `prep' table.\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|face
operator|->
name|interpreter
argument_list|(
name|exec
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|error
operator|=
name|FT_Err_Ok
expr_stmt|;
name|size
operator|->
name|cvt_ready
operator|=
name|error
expr_stmt|;
comment|/* UNDOCUMENTED!  The MS rasterizer doesn't allow the following */
comment|/* graphics state variables to be modified by the CVT program.  */
name|exec
operator|->
name|GS
operator|.
name|dualVector
operator|.
name|x
operator|=
literal|0x4000
expr_stmt|;
name|exec
operator|->
name|GS
operator|.
name|dualVector
operator|.
name|y
operator|=
literal|0
expr_stmt|;
name|exec
operator|->
name|GS
operator|.
name|projVector
operator|.
name|x
operator|=
literal|0x4000
expr_stmt|;
name|exec
operator|->
name|GS
operator|.
name|projVector
operator|.
name|y
operator|=
literal|0x0
expr_stmt|;
name|exec
operator|->
name|GS
operator|.
name|freeVector
operator|.
name|x
operator|=
literal|0x4000
expr_stmt|;
name|exec
operator|->
name|GS
operator|.
name|freeVector
operator|.
name|y
operator|=
literal|0x0
expr_stmt|;
name|exec
operator|->
name|GS
operator|.
name|rp0
operator|=
literal|0
expr_stmt|;
name|exec
operator|->
name|GS
operator|.
name|rp1
operator|=
literal|0
expr_stmt|;
name|exec
operator|->
name|GS
operator|.
name|rp2
operator|=
literal|0
expr_stmt|;
name|exec
operator|->
name|GS
operator|.
name|gep0
operator|=
literal|1
expr_stmt|;
name|exec
operator|->
name|GS
operator|.
name|gep1
operator|=
literal|1
expr_stmt|;
name|exec
operator|->
name|GS
operator|.
name|gep2
operator|=
literal|1
expr_stmt|;
name|exec
operator|->
name|GS
operator|.
name|loop
operator|=
literal|1
expr_stmt|;
comment|/* save as default graphics state */
name|size
operator|->
name|GS
operator|=
name|exec
operator|->
name|GS
expr_stmt|;
name|TT_Save_Context
argument_list|(
name|exec
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_block
begin_function
specifier|static
name|void
DECL|function|tt_size_done_bytecode
name|tt_size_done_bytecode
parameter_list|(
name|FT_Size
name|ftsize
parameter_list|)
block|{
name|TT_Size
name|size
init|=
operator|(
name|TT_Size
operator|)
name|ftsize
decl_stmt|;
name|TT_Face
name|face
init|=
operator|(
name|TT_Face
operator|)
name|ftsize
operator|->
name|face
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|face
operator|->
name|root
operator|.
name|memory
decl_stmt|;
if|if
condition|(
name|size
operator|->
name|debug
condition|)
block|{
comment|/* the debug context must be deleted by the debugger itself */
name|size
operator|->
name|context
operator|=
name|NULL
expr_stmt|;
name|size
operator|->
name|debug
operator|=
name|FALSE
expr_stmt|;
block|}
name|FT_FREE
argument_list|(
name|size
operator|->
name|cvt
argument_list|)
expr_stmt|;
name|size
operator|->
name|cvt_size
operator|=
literal|0
expr_stmt|;
comment|/* free storage area */
name|FT_FREE
argument_list|(
name|size
operator|->
name|storage
argument_list|)
expr_stmt|;
name|size
operator|->
name|storage_size
operator|=
literal|0
expr_stmt|;
comment|/* twilight zone */
name|tt_glyphzone_done
argument_list|(
operator|&
name|size
operator|->
name|twilight
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|size
operator|->
name|function_defs
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|size
operator|->
name|instruction_defs
argument_list|)
expr_stmt|;
name|size
operator|->
name|num_function_defs
operator|=
literal|0
expr_stmt|;
name|size
operator|->
name|max_function_defs
operator|=
literal|0
expr_stmt|;
name|size
operator|->
name|num_instruction_defs
operator|=
literal|0
expr_stmt|;
name|size
operator|->
name|max_instruction_defs
operator|=
literal|0
expr_stmt|;
name|size
operator|->
name|max_func
operator|=
literal|0
expr_stmt|;
name|size
operator|->
name|max_ins
operator|=
literal|0
expr_stmt|;
name|size
operator|->
name|bytecode_ready
operator|=
operator|-
literal|1
expr_stmt|;
name|size
operator|->
name|cvt_ready
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function
begin_comment
comment|/* Initialize bytecode-related fields in the size object.       */
end_comment
begin_comment
comment|/* We do this only if bytecode interpretation is really needed. */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|tt_size_init_bytecode
name|tt_size_init_bytecode
parameter_list|(
name|FT_Size
name|ftsize
parameter_list|,
name|FT_Bool
name|pedantic
parameter_list|)
block|{
name|FT_Error
name|error
decl_stmt|;
name|TT_Size
name|size
init|=
operator|(
name|TT_Size
operator|)
name|ftsize
decl_stmt|;
name|TT_Face
name|face
init|=
operator|(
name|TT_Face
operator|)
name|ftsize
operator|->
name|face
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|face
operator|->
name|root
operator|.
name|memory
decl_stmt|;
name|FT_UShort
name|n_twilight
decl_stmt|;
name|TT_MaxProfile
modifier|*
name|maxp
init|=
operator|&
name|face
operator|->
name|max_profile
decl_stmt|;
name|size
operator|->
name|bytecode_ready
operator|=
operator|-
literal|1
expr_stmt|;
name|size
operator|->
name|cvt_ready
operator|=
operator|-
literal|1
expr_stmt|;
name|size
operator|->
name|max_function_defs
operator|=
name|maxp
operator|->
name|maxFunctionDefs
expr_stmt|;
name|size
operator|->
name|max_instruction_defs
operator|=
name|maxp
operator|->
name|maxInstructionDefs
expr_stmt|;
name|size
operator|->
name|num_function_defs
operator|=
literal|0
expr_stmt|;
name|size
operator|->
name|num_instruction_defs
operator|=
literal|0
expr_stmt|;
name|size
operator|->
name|max_func
operator|=
literal|0
expr_stmt|;
name|size
operator|->
name|max_ins
operator|=
literal|0
expr_stmt|;
name|size
operator|->
name|cvt_size
operator|=
name|face
operator|->
name|cvt_size
expr_stmt|;
name|size
operator|->
name|storage_size
operator|=
name|maxp
operator|->
name|maxStorage
expr_stmt|;
comment|/* Set default metrics */
block|{
name|TT_Size_Metrics
modifier|*
name|metrics
init|=
operator|&
name|size
operator|->
name|ttmetrics
decl_stmt|;
name|metrics
operator|->
name|rotated
operator|=
name|FALSE
expr_stmt|;
name|metrics
operator|->
name|stretched
operator|=
name|FALSE
expr_stmt|;
comment|/* set default engine compensation */
name|metrics
operator|->
name|compensations
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* gray     */
name|metrics
operator|->
name|compensations
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* black    */
name|metrics
operator|->
name|compensations
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
comment|/* white    */
name|metrics
operator|->
name|compensations
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
comment|/* reserved */
block|}
comment|/* allocate function defs, instruction defs, cvt, and storage area */
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|size
operator|->
name|function_defs
argument_list|,
name|size
operator|->
name|max_function_defs
argument_list|)
operator|||
name|FT_NEW_ARRAY
argument_list|(
name|size
operator|->
name|instruction_defs
argument_list|,
name|size
operator|->
name|max_instruction_defs
argument_list|)
operator|||
name|FT_NEW_ARRAY
argument_list|(
name|size
operator|->
name|cvt
argument_list|,
name|size
operator|->
name|cvt_size
argument_list|)
operator|||
name|FT_NEW_ARRAY
argument_list|(
name|size
operator|->
name|storage
argument_list|,
name|size
operator|->
name|storage_size
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
comment|/* reserve twilight zone */
name|n_twilight
operator|=
name|maxp
operator|->
name|maxTwilightPoints
expr_stmt|;
comment|/* there are 4 phantom points (do we need this?) */
name|n_twilight
operator|+=
literal|4
expr_stmt|;
name|error
operator|=
name|tt_glyphzone_new
argument_list|(
name|memory
argument_list|,
name|n_twilight
argument_list|,
literal|0
argument_list|,
operator|&
name|size
operator|->
name|twilight
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|size
operator|->
name|twilight
operator|.
name|n_points
operator|=
name|n_twilight
expr_stmt|;
name|size
operator|->
name|GS
operator|=
name|tt_default_graphics_state
expr_stmt|;
comment|/* set `face->interpreter' according to the debug hook present */
block|{
name|FT_Library
name|library
init|=
name|face
operator|->
name|root
operator|.
name|driver
operator|->
name|root
operator|.
name|library
decl_stmt|;
name|face
operator|->
name|interpreter
operator|=
operator|(
name|TT_Interpreter
operator|)
name|library
operator|->
name|debug_hooks
index|[
name|FT_DEBUG_HOOK_TRUETYPE
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|face
operator|->
name|interpreter
condition|)
name|face
operator|->
name|interpreter
operator|=
operator|(
name|TT_Interpreter
operator|)
name|TT_RunIns
expr_stmt|;
block|}
comment|/* Fine, now run the font program! */
name|error
operator|=
name|tt_size_run_fpgm
argument_list|(
name|size
argument_list|,
name|pedantic
argument_list|)
expr_stmt|;
name|Exit
label|:
if|if
condition|(
name|error
condition|)
name|tt_size_done_bytecode
argument_list|(
name|ftsize
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|tt_size_ready_bytecode
argument_list|(
argument|TT_Size  size
argument_list|,
argument|FT_Bool  pedantic
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
if|if
condition|(
name|size
operator|->
name|bytecode_ready
operator|<
literal|0
condition|)
name|error
operator|=
name|tt_size_init_bytecode
argument_list|(
operator|(
name|FT_Size
operator|)
name|size
argument_list|,
name|pedantic
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|size
operator|->
name|bytecode_ready
condition|)
goto|goto
name|Exit
goto|;
comment|/* rescale CVT when needed */
if|if
condition|(
name|size
operator|->
name|cvt_ready
operator|<
literal|0
condition|)
block|{
name|FT_UInt
name|i
decl_stmt|;
name|TT_Face
name|face
init|=
operator|(
name|TT_Face
operator|)
name|size
operator|->
name|root
operator|.
name|face
decl_stmt|;
comment|/* Scale the cvt values to the new ppem.          */
comment|/* We use by default the y ppem to scale the CVT. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
operator|->
name|cvt_size
condition|;
name|i
operator|++
control|)
name|size
operator|->
name|cvt
index|[
name|i
index|]
operator|=
name|FT_MulFix
argument_list|(
name|face
operator|->
name|cvt
index|[
name|i
index|]
argument_list|,
name|size
operator|->
name|ttmetrics
operator|.
name|scale
argument_list|)
expr_stmt|;
comment|/* all twilight points are originally zero */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|FT_UInt
operator|)
name|size
operator|->
name|twilight
operator|.
name|n_points
condition|;
name|i
operator|++
control|)
block|{
name|size
operator|->
name|twilight
operator|.
name|org
index|[
name|i
index|]
operator|.
name|x
operator|=
literal|0
expr_stmt|;
name|size
operator|->
name|twilight
operator|.
name|org
index|[
name|i
index|]
operator|.
name|y
operator|=
literal|0
expr_stmt|;
name|size
operator|->
name|twilight
operator|.
name|cur
index|[
name|i
index|]
operator|.
name|x
operator|=
literal|0
expr_stmt|;
name|size
operator|->
name|twilight
operator|.
name|cur
index|[
name|i
index|]
operator|.
name|y
operator|=
literal|0
expr_stmt|;
block|}
comment|/* clear storage area */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|FT_UInt
operator|)
name|size
operator|->
name|storage_size
condition|;
name|i
operator|++
control|)
name|size
operator|->
name|storage
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|size
operator|->
name|GS
operator|=
name|tt_default_graphics_state
expr_stmt|;
name|error
operator|=
name|tt_size_run_prep
argument_list|(
name|size
argument_list|,
name|pedantic
argument_list|)
expr_stmt|;
block|}
name|Exit
label|:
return|return
name|error
return|;
block|}
end_block
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* TT_USE_BYTECODE_INTERPRETER */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    tt_size_init                                                       */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Initialize a new TrueType size object.                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<InOut>                                                               */
end_comment
begin_comment
comment|/*    size :: A handle to the size object.                               */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    FreeType error code.  0 means success.                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|tt_size_init
argument_list|(
argument|FT_Size  ttsize
argument_list|)
end_macro
begin_comment
comment|/* TT_Size */
end_comment
begin_block
block|{
name|TT_Size
name|size
init|=
operator|(
name|TT_Size
operator|)
name|ttsize
decl_stmt|;
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
ifdef|#
directive|ifdef
name|TT_USE_BYTECODE_INTERPRETER
name|size
operator|->
name|bytecode_ready
operator|=
operator|-
literal|1
expr_stmt|;
name|size
operator|->
name|cvt_ready
operator|=
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
name|size
operator|->
name|ttmetrics
operator|.
name|valid
operator|=
name|FALSE
expr_stmt|;
name|size
operator|->
name|strike_index
operator|=
literal|0xFFFFFFFFUL
expr_stmt|;
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    tt_size_done                                                       */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    The TrueType size object finalizer.                                */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    size :: A handle to the target size object.                        */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|tt_size_done
name|tt_size_done
argument_list|(
argument|FT_Size  ttsize
argument_list|)
end_macro
begin_comment
DECL|function|tt_size_done
comment|/* TT_Size */
end_comment
begin_block
block|{
name|TT_Size
name|size
init|=
operator|(
name|TT_Size
operator|)
name|ttsize
decl_stmt|;
ifdef|#
directive|ifdef
name|TT_USE_BYTECODE_INTERPRETER
name|tt_size_done_bytecode
argument_list|(
name|ttsize
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|size
operator|->
name|ttmetrics
operator|.
name|valid
operator|=
name|FALSE
expr_stmt|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    tt_size_reset                                                      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Reset a TrueType size when resolutions and character dimensions    */
end_comment
begin_comment
comment|/*    have been changed.                                                 */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    size :: A handle to the target size object.                        */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|tt_size_reset
argument_list|(
argument|TT_Size  size
argument_list|)
end_macro
begin_block
block|{
name|TT_Face
name|face
decl_stmt|;
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
name|FT_Size_Metrics
modifier|*
name|metrics
decl_stmt|;
name|size
operator|->
name|ttmetrics
operator|.
name|valid
operator|=
name|FALSE
expr_stmt|;
name|face
operator|=
operator|(
name|TT_Face
operator|)
name|size
operator|->
name|root
operator|.
name|face
expr_stmt|;
name|metrics
operator|=
operator|&
name|size
operator|->
name|metrics
expr_stmt|;
comment|/* copy the result from base layer */
operator|*
name|metrics
operator|=
name|size
operator|->
name|root
operator|.
name|metrics
expr_stmt|;
if|if
condition|(
name|metrics
operator|->
name|x_ppem
operator|<
literal|1
operator|||
name|metrics
operator|->
name|y_ppem
operator|<
literal|1
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_PPem
argument_list|)
return|;
comment|/* This bit flag, if set, indicates that the ppems must be       */
comment|/* rounded to integers.  Nearly all TrueType fonts have this bit */
comment|/* set, as hinting won't work really well otherwise.             */
comment|/*                                                               */
if|if
condition|(
name|face
operator|->
name|header
operator|.
name|Flags
operator|&
literal|8
condition|)
block|{
name|metrics
operator|->
name|x_scale
operator|=
name|FT_DivFix
argument_list|(
name|metrics
operator|->
name|x_ppem
operator|<<
literal|6
argument_list|,
name|face
operator|->
name|root
operator|.
name|units_per_EM
argument_list|)
expr_stmt|;
name|metrics
operator|->
name|y_scale
operator|=
name|FT_DivFix
argument_list|(
name|metrics
operator|->
name|y_ppem
operator|<<
literal|6
argument_list|,
name|face
operator|->
name|root
operator|.
name|units_per_EM
argument_list|)
expr_stmt|;
name|metrics
operator|->
name|ascender
operator|=
name|FT_PIX_ROUND
argument_list|(
name|FT_MulFix
argument_list|(
name|face
operator|->
name|root
operator|.
name|ascender
argument_list|,
name|metrics
operator|->
name|y_scale
argument_list|)
argument_list|)
expr_stmt|;
name|metrics
operator|->
name|descender
operator|=
name|FT_PIX_ROUND
argument_list|(
name|FT_MulFix
argument_list|(
name|face
operator|->
name|root
operator|.
name|descender
argument_list|,
name|metrics
operator|->
name|y_scale
argument_list|)
argument_list|)
expr_stmt|;
name|metrics
operator|->
name|height
operator|=
name|FT_PIX_ROUND
argument_list|(
name|FT_MulFix
argument_list|(
name|face
operator|->
name|root
operator|.
name|height
argument_list|,
name|metrics
operator|->
name|y_scale
argument_list|)
argument_list|)
expr_stmt|;
name|metrics
operator|->
name|max_advance
operator|=
name|FT_PIX_ROUND
argument_list|(
name|FT_MulFix
argument_list|(
name|face
operator|->
name|root
operator|.
name|max_advance_width
argument_list|,
name|metrics
operator|->
name|x_scale
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* compute new transformation */
if|if
condition|(
name|metrics
operator|->
name|x_ppem
operator|>=
name|metrics
operator|->
name|y_ppem
condition|)
block|{
name|size
operator|->
name|ttmetrics
operator|.
name|scale
operator|=
name|metrics
operator|->
name|x_scale
expr_stmt|;
name|size
operator|->
name|ttmetrics
operator|.
name|ppem
operator|=
name|metrics
operator|->
name|x_ppem
expr_stmt|;
name|size
operator|->
name|ttmetrics
operator|.
name|x_ratio
operator|=
literal|0x10000L
expr_stmt|;
name|size
operator|->
name|ttmetrics
operator|.
name|y_ratio
operator|=
name|FT_DivFix
argument_list|(
name|metrics
operator|->
name|y_ppem
argument_list|,
name|metrics
operator|->
name|x_ppem
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|size
operator|->
name|ttmetrics
operator|.
name|scale
operator|=
name|metrics
operator|->
name|y_scale
expr_stmt|;
name|size
operator|->
name|ttmetrics
operator|.
name|ppem
operator|=
name|metrics
operator|->
name|y_ppem
expr_stmt|;
name|size
operator|->
name|ttmetrics
operator|.
name|x_ratio
operator|=
name|FT_DivFix
argument_list|(
name|metrics
operator|->
name|x_ppem
argument_list|,
name|metrics
operator|->
name|y_ppem
argument_list|)
expr_stmt|;
name|size
operator|->
name|ttmetrics
operator|.
name|y_ratio
operator|=
literal|0x10000L
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TT_USE_BYTECODE_INTERPRETER
name|size
operator|->
name|cvt_ready
operator|=
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* TT_USE_BYTECODE_INTERPRETER */
if|if
condition|(
operator|!
name|error
condition|)
name|size
operator|->
name|ttmetrics
operator|.
name|valid
operator|=
name|TRUE
expr_stmt|;
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    tt_driver_init                                                     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Initialize a given TrueType driver object.                         */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    driver :: A handle to the target driver object.                    */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    FreeType error code.  0 means success.                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|tt_driver_init
argument_list|(
argument|FT_Module  ttdriver
argument_list|)
end_macro
begin_comment
comment|/* TT_Driver */
end_comment
begin_block
block|{
ifdef|#
directive|ifdef
name|TT_USE_BYTECODE_INTERPRETER
name|TT_Driver
name|driver
init|=
operator|(
name|TT_Driver
operator|)
name|ttdriver
decl_stmt|;
if|if
condition|(
operator|!
name|TT_New_Context
argument_list|(
name|driver
argument_list|)
condition|)
return|return
name|FT_THROW
argument_list|(
name|Could_Not_Find_Context
argument_list|)
return|;
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_SUBPIXEL_HINTING
name|driver
operator|->
name|interpreter_version
operator|=
name|TT_INTERPRETER_VERSION_38
expr_stmt|;
else|#
directive|else
name|driver
operator|->
name|interpreter_version
operator|=
name|TT_INTERPRETER_VERSION_35
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
comment|/* !TT_USE_BYTECODE_INTERPRETER */
name|FT_UNUSED
argument_list|(
name|ttdriver
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !TT_USE_BYTECODE_INTERPRETER */
return|return
name|FT_Err_Ok
return|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    tt_driver_done                                                     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Finalize a given TrueType driver.                                  */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    driver :: A handle to the target TrueType driver.                  */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|tt_driver_done
name|tt_driver_done
argument_list|(
argument|FT_Module  ttdriver
argument_list|)
end_macro
begin_comment
DECL|function|tt_driver_done
comment|/* TT_Driver */
end_comment
begin_block
block|{
ifdef|#
directive|ifdef
name|TT_USE_BYTECODE_INTERPRETER
name|TT_Driver
name|driver
init|=
operator|(
name|TT_Driver
operator|)
name|ttdriver
decl_stmt|;
comment|/* destroy the execution context */
if|if
condition|(
name|driver
operator|->
name|context
condition|)
block|{
name|TT_Done_Context
argument_list|(
name|driver
operator|->
name|context
argument_list|)
expr_stmt|;
name|driver
operator|->
name|context
operator|=
name|NULL
expr_stmt|;
block|}
else|#
directive|else
name|FT_UNUSED
argument_list|(
name|ttdriver
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    tt_slot_init                                                       */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Initialize a new slot object.                                      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<InOut>                                                               */
end_comment
begin_comment
comment|/*    slot :: A handle to the slot object.                               */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    FreeType error code.  0 means success.                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|tt_slot_init
argument_list|(
argument|FT_GlyphSlot  slot
argument_list|)
end_macro
begin_block
block|{
return|return
name|FT_GlyphLoader_CreateExtra
argument_list|(
name|slot
operator|->
name|internal
operator|->
name|loader
argument_list|)
return|;
block|}
end_block
begin_comment
comment|/* END */
end_comment
end_unit
