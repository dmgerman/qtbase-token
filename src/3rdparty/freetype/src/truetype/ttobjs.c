begin_unit
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  ttobjs.c                                                               */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*    Objects manager (body).                                              */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 by */
end_comment
begin_comment
comment|/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  This file is part of the FreeType project, and may only be used,       */
end_comment
begin_comment
comment|/*  modified, and distributed under the terms of the FreeType project      */
end_comment
begin_comment
comment|/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
end_comment
begin_comment
comment|/*  this file you indicate that you have read the license and              */
end_comment
begin_comment
comment|/*  understand and accept it fully.                                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<ft2build.h>
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_DEBUG_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_STREAM_H
end_include
begin_include
include|#
directive|include
include|FT_TRUETYPE_TAGS_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_SFNT_H
end_include
begin_include
include|#
directive|include
file|"ttgload.h"
end_include
begin_include
include|#
directive|include
file|"ttpload.h"
end_include
begin_include
include|#
directive|include
file|"tterrors.h"
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|TT_USE_BYTECODE_INTERPRETER
end_ifdef
begin_include
include|#
directive|include
file|"ttinterp.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_UNPATENTED_HINTING
end_ifdef
begin_include
include|#
directive|include
include|FT_TRUETYPE_UNPATENTED_H
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_GX_VAR_SUPPORT
end_ifdef
begin_include
include|#
directive|include
file|"ttgxvar.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
end_comment
begin_comment
comment|/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
end_comment
begin_comment
comment|/* messages during execution.                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_undef
DECL|macro|FT_COMPONENT
undef|#
directive|undef
name|FT_COMPONENT
end_undef
begin_define
DECL|macro|FT_COMPONENT
define|#
directive|define
name|FT_COMPONENT
value|trace_ttobjs
end_define
begin_ifdef
ifdef|#
directive|ifdef
name|TT_USE_BYTECODE_INTERPRETER
end_ifdef
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*                       GLYPH ZONE FUNCTIONS                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    tt_glyphzone_done                                                  */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Deallocate a glyph zone.                                           */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    zone :: A pointer to the target glyph zone.                        */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|tt_glyphzone_done
name|tt_glyphzone_done
argument_list|(
argument|TT_GlyphZone  zone
argument_list|)
end_macro
begin_block
block|{
name|FT_Memory
name|memory
init|=
name|zone
operator|->
name|memory
decl_stmt|;
if|if
condition|(
name|memory
condition|)
block|{
name|FT_FREE
argument_list|(
name|zone
operator|->
name|contours
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|zone
operator|->
name|tags
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|zone
operator|->
name|cur
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|zone
operator|->
name|org
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|zone
operator|->
name|orus
argument_list|)
expr_stmt|;
name|zone
operator|->
name|max_points
operator|=
name|zone
operator|->
name|n_points
operator|=
literal|0
expr_stmt|;
name|zone
operator|->
name|max_contours
operator|=
name|zone
operator|->
name|n_contours
operator|=
literal|0
expr_stmt|;
name|zone
operator|->
name|memory
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    tt_glyphzone_new                                                   */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Allocate a new glyph zone.                                         */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    memory      :: A handle to the current memory object.              */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    maxPoints   :: The capacity of glyph zone in points.               */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    maxContours :: The capacity of glyph zone in contours.             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Output>                                                              */
end_comment
begin_comment
comment|/*    zone        :: A pointer to the target glyph zone record.          */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    FreeType error code.  0 means success.                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|tt_glyphzone_new
argument_list|(
argument|FT_Memory     memory
argument_list|,
argument|FT_UShort     maxPoints
argument_list|,
argument|FT_Short      maxContours
argument_list|,
argument|TT_GlyphZone  zone
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
decl_stmt|;
name|FT_MEM_ZERO
argument_list|(
name|zone
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|zone
operator|->
name|memory
operator|=
name|memory
expr_stmt|;
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|zone
operator|->
name|org
argument_list|,
name|maxPoints
argument_list|)
operator|||
name|FT_NEW_ARRAY
argument_list|(
name|zone
operator|->
name|cur
argument_list|,
name|maxPoints
argument_list|)
operator|||
name|FT_NEW_ARRAY
argument_list|(
name|zone
operator|->
name|orus
argument_list|,
name|maxPoints
argument_list|)
operator|||
name|FT_NEW_ARRAY
argument_list|(
name|zone
operator|->
name|tags
argument_list|,
name|maxPoints
argument_list|)
operator|||
name|FT_NEW_ARRAY
argument_list|(
name|zone
operator|->
name|contours
argument_list|,
name|maxContours
argument_list|)
condition|)
block|{
name|tt_glyphzone_done
argument_list|(
name|zone
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zone
operator|->
name|max_points
operator|=
name|maxPoints
expr_stmt|;
name|zone
operator|->
name|max_contours
operator|=
name|maxContours
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_block
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* TT_USE_BYTECODE_INTERPRETER */
end_comment
begin_comment
comment|/* Compare the face with a list of well-known `tricky' fonts. */
end_comment
begin_comment
comment|/* This list shall be expanded as we find more of them.       */
end_comment
begin_function
specifier|static
name|FT_Bool
DECL|function|tt_check_trickyness
name|tt_check_trickyness
parameter_list|(
name|FT_String
modifier|*
name|name
parameter_list|)
block|{
DECL|macro|TRICK_NAMES_MAX_CHARACTERS
define|#
directive|define
name|TRICK_NAMES_MAX_CHARACTERS
value|16
DECL|macro|TRICK_NAMES_COUNT
define|#
directive|define
name|TRICK_NAMES_COUNT
value|7
specifier|static
specifier|const
name|char
name|trick_names
index|[
name|TRICK_NAMES_COUNT
index|]
index|[
name|TRICK_NAMES_MAX_CHARACTERS
operator|+
literal|1
index|]
init|=
block|{
literal|"DFKaiSho-SB"
block|,
comment|/* dfkaisb.ttf */
literal|"DFKaiShu"
block|,
literal|"DFKai-SB"
block|,
comment|/* kaiu.ttf */
literal|"HuaTianSongTi?"
block|,
comment|/* htst3.ttf */
literal|"MingLiU"
block|,
comment|/* mingliu.ttf& mingliu.ttc */
literal|"PMingLiU"
block|,
comment|/* mingliu.ttc */
literal|"MingLi43"
block|,
comment|/* mingli.ttf */
block|}
decl_stmt|;
name|int
name|nn
decl_stmt|;
if|if
condition|(
operator|!
name|name
condition|)
return|return
name|FALSE
return|;
comment|/* Note that we only check the face name at the moment; it might */
comment|/* be worth to do more checks for a few special cases.           */
for|for
control|(
name|nn
operator|=
literal|0
init|;
name|nn
operator|<
name|TRICK_NAMES_COUNT
condition|;
name|nn
operator|++
control|)
if|if
condition|(
name|ft_strstr
argument_list|(
name|name
argument_list|,
name|trick_names
index|[
name|nn
index|]
argument_list|)
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    tt_face_init                                                       */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Initialize a given TrueType face object.                           */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    stream     :: The source font stream.                              */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    face_index :: The index of the font face in the resource.          */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    num_params :: Number of additional generic parameters.  Ignored.   */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    params     :: Additional generic parameters.  Ignored.             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<InOut>                                                               */
end_comment
begin_comment
comment|/*    face       :: The newly built face object.                         */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    FreeType error code.  0 means success.                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|tt_face_init
argument_list|(
argument|FT_Stream      stream
argument_list|,
argument|FT_Face        ttface
argument_list|,
comment|/* TT_Face */
argument|FT_Int         face_index
argument_list|,
argument|FT_Int         num_params
argument_list|,
argument|FT_Parameter*  params
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
decl_stmt|;
name|FT_Library
name|library
decl_stmt|;
name|SFNT_Service
name|sfnt
decl_stmt|;
name|TT_Face
name|face
init|=
operator|(
name|TT_Face
operator|)
name|ttface
decl_stmt|;
name|library
operator|=
name|ttface
operator|->
name|driver
operator|->
name|root
operator|.
name|library
expr_stmt|;
name|sfnt
operator|=
operator|(
name|SFNT_Service
operator|)
name|FT_Get_Module_Interface
argument_list|(
name|library
argument_list|,
literal|"sfnt"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sfnt
condition|)
goto|goto
name|Bad_Format
goto|;
comment|/* create input stream from resource */
if|if
condition|(
name|FT_STREAM_SEEK
argument_list|(
literal|0
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
comment|/* check that we have a valid TrueType file */
name|error
operator|=
name|sfnt
operator|->
name|init_face
argument_list|(
name|stream
argument_list|,
name|face
argument_list|,
name|face_index
argument_list|,
name|num_params
argument_list|,
name|params
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
comment|/* We must also be able to accept Mac/GX fonts, as well as OT ones. */
comment|/* The 0x00020000 tag is completely undocumented; some fonts from   */
comment|/* Arphic made for Chinese Windows 3.1 have this.                   */
if|if
condition|(
name|face
operator|->
name|format_tag
operator|!=
literal|0x00010000L
operator|&&
comment|/* MS fonts  */
name|face
operator|->
name|format_tag
operator|!=
literal|0x00020000L
operator|&&
comment|/* CJK fonts for Win 3.1 */
name|face
operator|->
name|format_tag
operator|!=
name|TTAG_true
condition|)
comment|/* Mac fonts */
block|{
name|FT_TRACE2
argument_list|(
operator|(
literal|"[not a valid TTF font]\n"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|Bad_Format
goto|;
block|}
ifdef|#
directive|ifdef
name|TT_USE_BYTECODE_INTERPRETER
name|ttface
operator|->
name|face_flags
operator||=
name|FT_FACE_FLAG_HINTER
expr_stmt|;
endif|#
directive|endif
comment|/* If we are performing a simple font format check, exit immediately. */
if|if
condition|(
name|face_index
operator|<
literal|0
condition|)
return|return
name|TT_Err_Ok
return|;
comment|/* Load font directory */
name|error
operator|=
name|sfnt
operator|->
name|load_face
argument_list|(
name|stream
argument_list|,
name|face
argument_list|,
name|face_index
argument_list|,
name|num_params
argument_list|,
name|params
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
if|if
condition|(
name|tt_check_trickyness
argument_list|(
name|ttface
operator|->
name|family_name
argument_list|)
condition|)
name|ttface
operator|->
name|face_flags
operator||=
name|FT_FACE_FLAG_TRICKY
expr_stmt|;
name|error
operator|=
name|tt_face_load_hdmx
argument_list|(
name|face
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
if|if
condition|(
name|FT_IS_SCALABLE
argument_list|(
name|ttface
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|FT_CONFIG_OPTION_INCREMENTAL
if|if
condition|(
operator|!
name|ttface
operator|->
name|internal
operator|->
name|incremental_interface
condition|)
name|error
operator|=
name|tt_face_load_loca
argument_list|(
name|face
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|tt_face_load_cvt
argument_list|(
name|face
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|tt_face_load_fpgm
argument_list|(
name|face
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|tt_face_load_prep
argument_list|(
name|face
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|tt_face_load_loca
argument_list|(
name|face
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|tt_face_load_cvt
argument_list|(
name|face
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|tt_face_load_fpgm
argument_list|(
name|face
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|tt_face_load_prep
argument_list|(
name|face
argument_list|,
name|stream
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|#
directive|if
name|defined
argument_list|(
name|TT_CONFIG_OPTION_UNPATENTED_HINTING
argument_list|)
operator|&&
expr|\
operator|!
name|defined
argument_list|(
name|TT_CONFIG_OPTION_BYTECODE_INTERPRETER
argument_list|)
block|{
name|FT_Bool
name|unpatented_hinting
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Determine whether unpatented hinting is to be used for this face. */
name|unpatented_hinting
operator|=
name|FT_BOOL
argument_list|(
name|library
operator|->
name|debug_hooks
index|[
name|FT_DEBUG_HOOK_UNPATENTED_HINTING
index|]
operator|!=
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_params
operator|&&
operator|!
name|face
operator|->
name|unpatented_hinting
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|params
index|[
name|i
index|]
operator|.
name|tag
operator|==
name|FT_PARAM_TAG_UNPATENTED_HINTING
condition|)
name|unpatented_hinting
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|unpatented_hinting
condition|)
name|ttface
operator|->
name|internal
operator|->
name|ignore_unpatented_hinter
operator|=
name|TRUE
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* TT_CONFIG_OPTION_UNPATENTED_HINTING&&           !TT_CONFIG_OPTION_BYTECODE_INTERPRETER */
comment|/* initialize standard glyph loading routines */
name|TT_Init_Glyph_Loading
argument_list|(
name|face
argument_list|)
expr_stmt|;
name|Exit
label|:
return|return
name|error
return|;
name|Bad_Format
label|:
name|error
operator|=
name|TT_Err_Unknown_File_Format
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    tt_face_done                                                       */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Finalize a given face object.                                      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    face :: A pointer to the face object to destroy.                   */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|tt_face_done
name|tt_face_done
argument_list|(
argument|FT_Face  ttface
argument_list|)
end_macro
begin_comment
DECL|function|tt_face_done
comment|/* TT_Face */
end_comment
begin_block
block|{
name|TT_Face
name|face
init|=
operator|(
name|TT_Face
operator|)
name|ttface
decl_stmt|;
name|FT_Memory
name|memory
decl_stmt|;
name|FT_Stream
name|stream
decl_stmt|;
name|SFNT_Service
name|sfnt
decl_stmt|;
if|if
condition|(
operator|!
name|face
condition|)
return|return;
name|memory
operator|=
name|ttface
operator|->
name|memory
expr_stmt|;
name|stream
operator|=
name|ttface
operator|->
name|stream
expr_stmt|;
name|sfnt
operator|=
operator|(
name|SFNT_Service
operator|)
name|face
operator|->
name|sfnt
expr_stmt|;
comment|/* for `extended TrueType formats' (i.e. compressed versions) */
if|if
condition|(
name|face
operator|->
name|extra
operator|.
name|finalizer
condition|)
name|face
operator|->
name|extra
operator|.
name|finalizer
argument_list|(
name|face
operator|->
name|extra
operator|.
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|sfnt
condition|)
name|sfnt
operator|->
name|done_face
argument_list|(
name|face
argument_list|)
expr_stmt|;
comment|/* freeing the locations table */
name|tt_face_done_loca
argument_list|(
name|face
argument_list|)
expr_stmt|;
name|tt_face_free_hdmx
argument_list|(
name|face
argument_list|)
expr_stmt|;
comment|/* freeing the CVT */
name|FT_FREE
argument_list|(
name|face
operator|->
name|cvt
argument_list|)
expr_stmt|;
name|face
operator|->
name|cvt_size
operator|=
literal|0
expr_stmt|;
comment|/* freeing the programs */
name|FT_FRAME_RELEASE
argument_list|(
name|face
operator|->
name|font_program
argument_list|)
expr_stmt|;
name|FT_FRAME_RELEASE
argument_list|(
name|face
operator|->
name|cvt_program
argument_list|)
expr_stmt|;
name|face
operator|->
name|font_program_size
operator|=
literal|0
expr_stmt|;
name|face
operator|->
name|cvt_program_size
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_GX_VAR_SUPPORT
name|tt_done_blend
argument_list|(
name|memory
argument_list|,
name|face
operator|->
name|blend
argument_list|)
expr_stmt|;
name|face
operator|->
name|blend
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*                           SIZE  FUNCTIONS                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|TT_USE_BYTECODE_INTERPRETER
end_ifdef
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    tt_size_run_fpgm                                                   */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Run the font program.                                              */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    size :: A handle to the size object.                               */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    FreeType error code.  0 means success.                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|tt_size_run_fpgm
argument_list|(
argument|TT_Size  size
argument_list|)
end_macro
begin_block
block|{
name|TT_Face
name|face
init|=
operator|(
name|TT_Face
operator|)
name|size
operator|->
name|root
operator|.
name|face
decl_stmt|;
name|TT_ExecContext
name|exec
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
comment|/* debugging instances have their own context */
if|if
condition|(
name|size
operator|->
name|debug
condition|)
name|exec
operator|=
name|size
operator|->
name|context
expr_stmt|;
else|else
name|exec
operator|=
operator|(
operator|(
name|TT_Driver
operator|)
name|FT_FACE_DRIVER
argument_list|(
name|face
argument_list|)
operator|)
operator|->
name|context
expr_stmt|;
if|if
condition|(
operator|!
name|exec
condition|)
return|return
name|TT_Err_Could_Not_Find_Context
return|;
name|TT_Load_Context
argument_list|(
name|exec
argument_list|,
name|face
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|exec
operator|->
name|callTop
operator|=
literal|0
expr_stmt|;
name|exec
operator|->
name|top
operator|=
literal|0
expr_stmt|;
name|exec
operator|->
name|period
operator|=
literal|64
expr_stmt|;
name|exec
operator|->
name|phase
operator|=
literal|0
expr_stmt|;
name|exec
operator|->
name|threshold
operator|=
literal|0
expr_stmt|;
name|exec
operator|->
name|instruction_trap
operator|=
name|FALSE
expr_stmt|;
name|exec
operator|->
name|F_dot_P
operator|=
literal|0x10000L
expr_stmt|;
block|{
name|FT_Size_Metrics
modifier|*
name|metrics
init|=
operator|&
name|exec
operator|->
name|metrics
decl_stmt|;
name|TT_Size_Metrics
modifier|*
name|tt_metrics
init|=
operator|&
name|exec
operator|->
name|tt_metrics
decl_stmt|;
name|metrics
operator|->
name|x_ppem
operator|=
literal|0
expr_stmt|;
name|metrics
operator|->
name|y_ppem
operator|=
literal|0
expr_stmt|;
name|metrics
operator|->
name|x_scale
operator|=
literal|0
expr_stmt|;
name|metrics
operator|->
name|y_scale
operator|=
literal|0
expr_stmt|;
name|tt_metrics
operator|->
name|ppem
operator|=
literal|0
expr_stmt|;
name|tt_metrics
operator|->
name|scale
operator|=
literal|0
expr_stmt|;
name|tt_metrics
operator|->
name|ratio
operator|=
literal|0x10000L
expr_stmt|;
block|}
comment|/* allow font program execution */
name|TT_Set_CodeRange
argument_list|(
name|exec
argument_list|,
name|tt_coderange_font
argument_list|,
name|face
operator|->
name|font_program
argument_list|,
name|face
operator|->
name|font_program_size
argument_list|)
expr_stmt|;
comment|/* disable CVT and glyph programs coderange */
name|TT_Clear_CodeRange
argument_list|(
name|exec
argument_list|,
name|tt_coderange_cvt
argument_list|)
expr_stmt|;
name|TT_Clear_CodeRange
argument_list|(
name|exec
argument_list|,
name|tt_coderange_glyph
argument_list|)
expr_stmt|;
if|if
condition|(
name|face
operator|->
name|font_program_size
operator|>
literal|0
condition|)
block|{
name|error
operator|=
name|TT_Goto_CodeRange
argument_list|(
name|exec
argument_list|,
name|tt_coderange_font
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|face
operator|->
name|interpreter
argument_list|(
name|exec
argument_list|)
expr_stmt|;
block|}
else|else
name|error
operator|=
name|TT_Err_Ok
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|TT_Save_Context
argument_list|(
name|exec
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    tt_size_run_prep                                                   */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Run the control value program.                                     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    size :: A handle to the size object.                               */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    FreeType error code.  0 means success.                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|tt_size_run_prep
argument_list|(
argument|TT_Size  size
argument_list|)
end_macro
begin_block
block|{
name|TT_Face
name|face
init|=
operator|(
name|TT_Face
operator|)
name|size
operator|->
name|root
operator|.
name|face
decl_stmt|;
name|TT_ExecContext
name|exec
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
comment|/* debugging instances have their own context */
if|if
condition|(
name|size
operator|->
name|debug
condition|)
name|exec
operator|=
name|size
operator|->
name|context
expr_stmt|;
else|else
name|exec
operator|=
operator|(
operator|(
name|TT_Driver
operator|)
name|FT_FACE_DRIVER
argument_list|(
name|face
argument_list|)
operator|)
operator|->
name|context
expr_stmt|;
if|if
condition|(
operator|!
name|exec
condition|)
return|return
name|TT_Err_Could_Not_Find_Context
return|;
name|TT_Load_Context
argument_list|(
name|exec
argument_list|,
name|face
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|exec
operator|->
name|callTop
operator|=
literal|0
expr_stmt|;
name|exec
operator|->
name|top
operator|=
literal|0
expr_stmt|;
name|exec
operator|->
name|instruction_trap
operator|=
name|FALSE
expr_stmt|;
name|TT_Set_CodeRange
argument_list|(
name|exec
argument_list|,
name|tt_coderange_cvt
argument_list|,
name|face
operator|->
name|cvt_program
argument_list|,
name|face
operator|->
name|cvt_program_size
argument_list|)
expr_stmt|;
name|TT_Clear_CodeRange
argument_list|(
name|exec
argument_list|,
name|tt_coderange_glyph
argument_list|)
expr_stmt|;
if|if
condition|(
name|face
operator|->
name|cvt_program_size
operator|>
literal|0
condition|)
block|{
name|error
operator|=
name|TT_Goto_CodeRange
argument_list|(
name|exec
argument_list|,
name|tt_coderange_cvt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
operator|!
name|size
operator|->
name|debug
condition|)
name|error
operator|=
name|face
operator|->
name|interpreter
argument_list|(
name|exec
argument_list|)
expr_stmt|;
block|}
else|else
name|error
operator|=
name|TT_Err_Ok
expr_stmt|;
comment|/* save as default graphics state */
name|size
operator|->
name|GS
operator|=
name|exec
operator|->
name|GS
expr_stmt|;
name|TT_Save_Context
argument_list|(
name|exec
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_block
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* TT_USE_BYTECODE_INTERPRETER */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|TT_USE_BYTECODE_INTERPRETER
end_ifdef
begin_function
specifier|static
name|void
DECL|function|tt_size_done_bytecode
name|tt_size_done_bytecode
parameter_list|(
name|FT_Size
name|ftsize
parameter_list|)
block|{
name|TT_Size
name|size
init|=
operator|(
name|TT_Size
operator|)
name|ftsize
decl_stmt|;
name|TT_Face
name|face
init|=
operator|(
name|TT_Face
operator|)
name|ftsize
operator|->
name|face
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|face
operator|->
name|root
operator|.
name|memory
decl_stmt|;
if|if
condition|(
name|size
operator|->
name|debug
condition|)
block|{
comment|/* the debug context must be deleted by the debugger itself */
name|size
operator|->
name|context
operator|=
name|NULL
expr_stmt|;
name|size
operator|->
name|debug
operator|=
name|FALSE
expr_stmt|;
block|}
name|FT_FREE
argument_list|(
name|size
operator|->
name|cvt
argument_list|)
expr_stmt|;
name|size
operator|->
name|cvt_size
operator|=
literal|0
expr_stmt|;
comment|/* free storage area */
name|FT_FREE
argument_list|(
name|size
operator|->
name|storage
argument_list|)
expr_stmt|;
name|size
operator|->
name|storage_size
operator|=
literal|0
expr_stmt|;
comment|/* twilight zone */
name|tt_glyphzone_done
argument_list|(
operator|&
name|size
operator|->
name|twilight
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|size
operator|->
name|function_defs
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|size
operator|->
name|instruction_defs
argument_list|)
expr_stmt|;
name|size
operator|->
name|num_function_defs
operator|=
literal|0
expr_stmt|;
name|size
operator|->
name|max_function_defs
operator|=
literal|0
expr_stmt|;
name|size
operator|->
name|num_instruction_defs
operator|=
literal|0
expr_stmt|;
name|size
operator|->
name|max_instruction_defs
operator|=
literal|0
expr_stmt|;
name|size
operator|->
name|max_func
operator|=
literal|0
expr_stmt|;
name|size
operator|->
name|max_ins
operator|=
literal|0
expr_stmt|;
name|size
operator|->
name|bytecode_ready
operator|=
literal|0
expr_stmt|;
name|size
operator|->
name|cvt_ready
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_comment
comment|/* Initialize bytecode-related fields in the size object.       */
end_comment
begin_comment
comment|/* We do this only if bytecode interpretation is really needed. */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|tt_size_init_bytecode
name|tt_size_init_bytecode
parameter_list|(
name|FT_Size
name|ftsize
parameter_list|)
block|{
name|FT_Error
name|error
decl_stmt|;
name|TT_Size
name|size
init|=
operator|(
name|TT_Size
operator|)
name|ftsize
decl_stmt|;
name|TT_Face
name|face
init|=
operator|(
name|TT_Face
operator|)
name|ftsize
operator|->
name|face
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|face
operator|->
name|root
operator|.
name|memory
decl_stmt|;
name|FT_Int
name|i
decl_stmt|;
name|FT_UShort
name|n_twilight
decl_stmt|;
name|TT_MaxProfile
modifier|*
name|maxp
init|=
operator|&
name|face
operator|->
name|max_profile
decl_stmt|;
name|size
operator|->
name|bytecode_ready
operator|=
literal|1
expr_stmt|;
name|size
operator|->
name|cvt_ready
operator|=
literal|0
expr_stmt|;
name|size
operator|->
name|max_function_defs
operator|=
name|maxp
operator|->
name|maxFunctionDefs
expr_stmt|;
name|size
operator|->
name|max_instruction_defs
operator|=
name|maxp
operator|->
name|maxInstructionDefs
expr_stmt|;
name|size
operator|->
name|num_function_defs
operator|=
literal|0
expr_stmt|;
name|size
operator|->
name|num_instruction_defs
operator|=
literal|0
expr_stmt|;
name|size
operator|->
name|max_func
operator|=
literal|0
expr_stmt|;
name|size
operator|->
name|max_ins
operator|=
literal|0
expr_stmt|;
name|size
operator|->
name|cvt_size
operator|=
name|face
operator|->
name|cvt_size
expr_stmt|;
name|size
operator|->
name|storage_size
operator|=
name|maxp
operator|->
name|maxStorage
expr_stmt|;
comment|/* Set default metrics */
block|{
name|TT_Size_Metrics
modifier|*
name|metrics
init|=
operator|&
name|size
operator|->
name|ttmetrics
decl_stmt|;
name|metrics
operator|->
name|rotated
operator|=
name|FALSE
expr_stmt|;
name|metrics
operator|->
name|stretched
operator|=
name|FALSE
expr_stmt|;
comment|/* set default compensation (all 0) */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|metrics
operator|->
name|compensations
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* allocate function defs, instruction defs, cvt, and storage area */
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|size
operator|->
name|function_defs
argument_list|,
name|size
operator|->
name|max_function_defs
argument_list|)
operator|||
name|FT_NEW_ARRAY
argument_list|(
name|size
operator|->
name|instruction_defs
argument_list|,
name|size
operator|->
name|max_instruction_defs
argument_list|)
operator|||
name|FT_NEW_ARRAY
argument_list|(
name|size
operator|->
name|cvt
argument_list|,
name|size
operator|->
name|cvt_size
argument_list|)
operator|||
name|FT_NEW_ARRAY
argument_list|(
name|size
operator|->
name|storage
argument_list|,
name|size
operator|->
name|storage_size
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
comment|/* reserve twilight zone */
name|n_twilight
operator|=
name|maxp
operator|->
name|maxTwilightPoints
expr_stmt|;
comment|/* there are 4 phantom points (do we need this?) */
name|n_twilight
operator|+=
literal|4
expr_stmt|;
name|error
operator|=
name|tt_glyphzone_new
argument_list|(
name|memory
argument_list|,
name|n_twilight
argument_list|,
literal|0
argument_list|,
operator|&
name|size
operator|->
name|twilight
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|size
operator|->
name|twilight
operator|.
name|n_points
operator|=
name|n_twilight
expr_stmt|;
name|size
operator|->
name|GS
operator|=
name|tt_default_graphics_state
expr_stmt|;
comment|/* set `face->interpreter' according to the debug hook present */
block|{
name|FT_Library
name|library
init|=
name|face
operator|->
name|root
operator|.
name|driver
operator|->
name|root
operator|.
name|library
decl_stmt|;
name|face
operator|->
name|interpreter
operator|=
operator|(
name|TT_Interpreter
operator|)
name|library
operator|->
name|debug_hooks
index|[
name|FT_DEBUG_HOOK_TRUETYPE
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|face
operator|->
name|interpreter
condition|)
name|face
operator|->
name|interpreter
operator|=
operator|(
name|TT_Interpreter
operator|)
name|TT_RunIns
expr_stmt|;
block|}
comment|/* Fine, now run the font program! */
name|error
operator|=
name|tt_size_run_fpgm
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|Exit
label|:
if|if
condition|(
name|error
condition|)
name|tt_size_done_bytecode
argument_list|(
name|ftsize
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|tt_size_ready_bytecode
argument_list|(
argument|TT_Size  size
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
init|=
name|TT_Err_Ok
decl_stmt|;
if|if
condition|(
operator|!
name|size
operator|->
name|bytecode_ready
condition|)
block|{
name|error
operator|=
name|tt_size_init_bytecode
argument_list|(
operator|(
name|FT_Size
operator|)
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
block|}
comment|/* rescale CVT when needed */
if|if
condition|(
operator|!
name|size
operator|->
name|cvt_ready
condition|)
block|{
name|FT_UInt
name|i
decl_stmt|;
name|TT_Face
name|face
init|=
operator|(
name|TT_Face
operator|)
name|size
operator|->
name|root
operator|.
name|face
decl_stmt|;
comment|/* Scale the cvt values to the new ppem.          */
comment|/* We use by default the y ppem to scale the CVT. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
operator|->
name|cvt_size
condition|;
name|i
operator|++
control|)
name|size
operator|->
name|cvt
index|[
name|i
index|]
operator|=
name|FT_MulFix
argument_list|(
name|face
operator|->
name|cvt
index|[
name|i
index|]
argument_list|,
name|size
operator|->
name|ttmetrics
operator|.
name|scale
argument_list|)
expr_stmt|;
comment|/* all twilight points are originally zero */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|FT_UInt
operator|)
name|size
operator|->
name|twilight
operator|.
name|n_points
condition|;
name|i
operator|++
control|)
block|{
name|size
operator|->
name|twilight
operator|.
name|org
index|[
name|i
index|]
operator|.
name|x
operator|=
literal|0
expr_stmt|;
name|size
operator|->
name|twilight
operator|.
name|org
index|[
name|i
index|]
operator|.
name|y
operator|=
literal|0
expr_stmt|;
name|size
operator|->
name|twilight
operator|.
name|cur
index|[
name|i
index|]
operator|.
name|x
operator|=
literal|0
expr_stmt|;
name|size
operator|->
name|twilight
operator|.
name|cur
index|[
name|i
index|]
operator|.
name|y
operator|=
literal|0
expr_stmt|;
block|}
comment|/* clear storage area */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|FT_UInt
operator|)
name|size
operator|->
name|storage_size
condition|;
name|i
operator|++
control|)
name|size
operator|->
name|storage
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|size
operator|->
name|GS
operator|=
name|tt_default_graphics_state
expr_stmt|;
name|error
operator|=
name|tt_size_run_prep
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|size
operator|->
name|cvt_ready
operator|=
literal|1
expr_stmt|;
block|}
name|Exit
label|:
return|return
name|error
return|;
block|}
end_block
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* TT_USE_BYTECODE_INTERPRETER */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    tt_size_init                                                       */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Initialize a new TrueType size object.                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<InOut>                                                               */
end_comment
begin_comment
comment|/*    size :: A handle to the size object.                               */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    FreeType error code.  0 means success.                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|tt_size_init
argument_list|(
argument|FT_Size  ttsize
argument_list|)
end_macro
begin_comment
comment|/* TT_Size */
end_comment
begin_block
block|{
name|TT_Size
name|size
init|=
operator|(
name|TT_Size
operator|)
name|ttsize
decl_stmt|;
name|FT_Error
name|error
init|=
name|TT_Err_Ok
decl_stmt|;
ifdef|#
directive|ifdef
name|TT_USE_BYTECODE_INTERPRETER
name|size
operator|->
name|bytecode_ready
operator|=
literal|0
expr_stmt|;
name|size
operator|->
name|cvt_ready
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|size
operator|->
name|ttmetrics
operator|.
name|valid
operator|=
name|FALSE
expr_stmt|;
name|size
operator|->
name|strike_index
operator|=
literal|0xFFFFFFFFUL
expr_stmt|;
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    tt_size_done                                                       */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    The TrueType size object finalizer.                                */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    size :: A handle to the target size object.                        */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|tt_size_done
name|tt_size_done
argument_list|(
argument|FT_Size  ttsize
argument_list|)
end_macro
begin_comment
DECL|function|tt_size_done
comment|/* TT_Size */
end_comment
begin_block
block|{
name|TT_Size
name|size
init|=
operator|(
name|TT_Size
operator|)
name|ttsize
decl_stmt|;
ifdef|#
directive|ifdef
name|TT_USE_BYTECODE_INTERPRETER
if|if
condition|(
name|size
operator|->
name|bytecode_ready
condition|)
name|tt_size_done_bytecode
argument_list|(
name|ttsize
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|size
operator|->
name|ttmetrics
operator|.
name|valid
operator|=
name|FALSE
expr_stmt|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    tt_size_reset                                                      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Reset a TrueType size when resolutions and character dimensions    */
end_comment
begin_comment
comment|/*    have been changed.                                                 */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    size :: A handle to the target size object.                        */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|tt_size_reset
argument_list|(
argument|TT_Size  size
argument_list|)
end_macro
begin_block
block|{
name|TT_Face
name|face
decl_stmt|;
name|FT_Error
name|error
init|=
name|TT_Err_Ok
decl_stmt|;
name|FT_Size_Metrics
modifier|*
name|metrics
decl_stmt|;
name|size
operator|->
name|ttmetrics
operator|.
name|valid
operator|=
name|FALSE
expr_stmt|;
name|face
operator|=
operator|(
name|TT_Face
operator|)
name|size
operator|->
name|root
operator|.
name|face
expr_stmt|;
name|metrics
operator|=
operator|&
name|size
operator|->
name|metrics
expr_stmt|;
comment|/* copy the result from base layer */
operator|*
name|metrics
operator|=
name|size
operator|->
name|root
operator|.
name|metrics
expr_stmt|;
if|if
condition|(
name|metrics
operator|->
name|x_ppem
operator|<
literal|1
operator|||
name|metrics
operator|->
name|y_ppem
operator|<
literal|1
condition|)
return|return
name|TT_Err_Invalid_PPem
return|;
comment|/* This bit flag, if set, indicates that the ppems must be       */
comment|/* rounded to integers.  Nearly all TrueType fonts have this bit */
comment|/* set, as hinting won't work really well otherwise.             */
comment|/*                                                               */
if|if
condition|(
name|face
operator|->
name|header
operator|.
name|Flags
operator|&
literal|8
condition|)
block|{
name|metrics
operator|->
name|x_scale
operator|=
name|FT_DivFix
argument_list|(
name|metrics
operator|->
name|x_ppem
operator|<<
literal|6
argument_list|,
name|face
operator|->
name|root
operator|.
name|units_per_EM
argument_list|)
expr_stmt|;
name|metrics
operator|->
name|y_scale
operator|=
name|FT_DivFix
argument_list|(
name|metrics
operator|->
name|y_ppem
operator|<<
literal|6
argument_list|,
name|face
operator|->
name|root
operator|.
name|units_per_EM
argument_list|)
expr_stmt|;
name|metrics
operator|->
name|ascender
operator|=
name|FT_PIX_ROUND
argument_list|(
name|FT_MulFix
argument_list|(
name|face
operator|->
name|root
operator|.
name|ascender
argument_list|,
name|metrics
operator|->
name|y_scale
argument_list|)
argument_list|)
expr_stmt|;
name|metrics
operator|->
name|descender
operator|=
name|FT_PIX_ROUND
argument_list|(
name|FT_MulFix
argument_list|(
name|face
operator|->
name|root
operator|.
name|descender
argument_list|,
name|metrics
operator|->
name|y_scale
argument_list|)
argument_list|)
expr_stmt|;
name|metrics
operator|->
name|height
operator|=
name|FT_PIX_ROUND
argument_list|(
name|FT_MulFix
argument_list|(
name|face
operator|->
name|root
operator|.
name|height
argument_list|,
name|metrics
operator|->
name|y_scale
argument_list|)
argument_list|)
expr_stmt|;
name|metrics
operator|->
name|max_advance
operator|=
name|FT_PIX_ROUND
argument_list|(
name|FT_MulFix
argument_list|(
name|face
operator|->
name|root
operator|.
name|max_advance_width
argument_list|,
name|metrics
operator|->
name|x_scale
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* compute new transformation */
if|if
condition|(
name|metrics
operator|->
name|x_ppem
operator|>=
name|metrics
operator|->
name|y_ppem
condition|)
block|{
name|size
operator|->
name|ttmetrics
operator|.
name|scale
operator|=
name|metrics
operator|->
name|x_scale
expr_stmt|;
name|size
operator|->
name|ttmetrics
operator|.
name|ppem
operator|=
name|metrics
operator|->
name|x_ppem
expr_stmt|;
name|size
operator|->
name|ttmetrics
operator|.
name|x_ratio
operator|=
literal|0x10000L
expr_stmt|;
name|size
operator|->
name|ttmetrics
operator|.
name|y_ratio
operator|=
name|FT_MulDiv
argument_list|(
name|metrics
operator|->
name|y_ppem
argument_list|,
literal|0x10000L
argument_list|,
name|metrics
operator|->
name|x_ppem
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|size
operator|->
name|ttmetrics
operator|.
name|scale
operator|=
name|metrics
operator|->
name|y_scale
expr_stmt|;
name|size
operator|->
name|ttmetrics
operator|.
name|ppem
operator|=
name|metrics
operator|->
name|y_ppem
expr_stmt|;
name|size
operator|->
name|ttmetrics
operator|.
name|x_ratio
operator|=
name|FT_MulDiv
argument_list|(
name|metrics
operator|->
name|x_ppem
argument_list|,
literal|0x10000L
argument_list|,
name|metrics
operator|->
name|y_ppem
argument_list|)
expr_stmt|;
name|size
operator|->
name|ttmetrics
operator|.
name|y_ratio
operator|=
literal|0x10000L
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TT_USE_BYTECODE_INTERPRETER
name|size
operator|->
name|cvt_ready
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* TT_USE_BYTECODE_INTERPRETER */
if|if
condition|(
operator|!
name|error
condition|)
name|size
operator|->
name|ttmetrics
operator|.
name|valid
operator|=
name|TRUE
expr_stmt|;
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    tt_driver_init                                                     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Initialize a given TrueType driver object.                         */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    driver :: A handle to the target driver object.                    */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    FreeType error code.  0 means success.                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|tt_driver_init
argument_list|(
argument|FT_Module  ttdriver
argument_list|)
end_macro
begin_comment
comment|/* TT_Driver */
end_comment
begin_block
block|{
ifdef|#
directive|ifdef
name|TT_USE_BYTECODE_INTERPRETER
name|TT_Driver
name|driver
init|=
operator|(
name|TT_Driver
operator|)
name|ttdriver
decl_stmt|;
if|if
condition|(
operator|!
name|TT_New_Context
argument_list|(
name|driver
argument_list|)
condition|)
return|return
name|TT_Err_Could_Not_Find_Context
return|;
else|#
directive|else
name|FT_UNUSED
argument_list|(
name|ttdriver
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|TT_Err_Ok
return|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    tt_driver_done                                                     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Finalize a given TrueType driver.                                  */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    driver :: A handle to the target TrueType driver.                  */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|tt_driver_done
name|tt_driver_done
argument_list|(
argument|FT_Module  ttdriver
argument_list|)
end_macro
begin_comment
DECL|function|tt_driver_done
comment|/* TT_Driver */
end_comment
begin_block
block|{
ifdef|#
directive|ifdef
name|TT_USE_BYTECODE_INTERPRETER
name|TT_Driver
name|driver
init|=
operator|(
name|TT_Driver
operator|)
name|ttdriver
decl_stmt|;
comment|/* destroy the execution context */
if|if
condition|(
name|driver
operator|->
name|context
condition|)
block|{
name|TT_Done_Context
argument_list|(
name|driver
operator|->
name|context
argument_list|)
expr_stmt|;
name|driver
operator|->
name|context
operator|=
name|NULL
expr_stmt|;
block|}
else|#
directive|else
name|FT_UNUSED
argument_list|(
name|ttdriver
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    tt_slot_init                                                       */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Initialize a new slot object.                                      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<InOut>                                                               */
end_comment
begin_comment
comment|/*    slot :: A handle to the slot object.                               */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    FreeType error code.  0 means success.                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|tt_slot_init
argument_list|(
argument|FT_GlyphSlot  slot
argument_list|)
end_macro
begin_block
block|{
return|return
name|FT_GlyphLoader_CreateExtra
argument_list|(
name|slot
operator|->
name|internal
operator|->
name|loader
argument_list|)
return|;
block|}
end_block
begin_comment
comment|/* END */
end_comment
end_unit
