begin_unit
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  ttgxvar.c                                                              */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*    TrueType GX Font Variation loader                                    */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  Copyright 2004-2015 by                                                 */
end_comment
begin_comment
comment|/*  David Turner, Robert Wilhelm, Werner Lemberg, and George Williams.     */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  This file is part of the FreeType project, and may only be used,       */
end_comment
begin_comment
comment|/*  modified, and distributed under the terms of the FreeType project      */
end_comment
begin_comment
comment|/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
end_comment
begin_comment
comment|/*  this file you indicate that you have read the license and              */
end_comment
begin_comment
comment|/*  understand and accept it fully.                                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* Apple documents the `fvar', `gvar', `cvar', and `avar' tables at      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*   https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6[fgca]var.html */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* The documentation for `fvar' is inconsistent.  At one point it says   */
end_comment
begin_comment
comment|/* that `countSizePairs' should be 3, at another point 2.  It should     */
end_comment
begin_comment
comment|/* be 2.                                                                 */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* The documentation for `gvar' is not intelligible; `cvar' refers you   */
end_comment
begin_comment
comment|/* to `gvar' and is thus also incomprehensible.                          */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* The documentation for `avar' appears correct, but Apple has no fonts  */
end_comment
begin_comment
comment|/* with an `avar' table, so it is hard to test.                          */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* Many thanks to John Jenkins (at Apple) in figuring this out.          */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* Apple's `kern' table has some references to tuple indices, but as     */
end_comment
begin_comment
comment|/* there is no indication where these indices are defined, nor how to    */
end_comment
begin_comment
comment|/* interpolate the kerning values (different tuples have different       */
end_comment
begin_comment
comment|/* classes) this issue is ignored.                                       */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<ft2build.h>
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_DEBUG_H
end_include
begin_include
include|#
directive|include
include|FT_CONFIG_CONFIG_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_STREAM_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_SFNT_H
end_include
begin_include
include|#
directive|include
include|FT_TRUETYPE_TAGS_H
end_include
begin_include
include|#
directive|include
include|FT_MULTIPLE_MASTERS_H
end_include
begin_include
include|#
directive|include
file|"ttpload.h"
end_include
begin_include
include|#
directive|include
file|"ttgxvar.h"
end_include
begin_include
include|#
directive|include
file|"tterrors.h"
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_GX_VAR_SUPPORT
end_ifdef
begin_define
DECL|macro|FT_Stream_FTell
define|#
directive|define
name|FT_Stream_FTell
parameter_list|(
name|stream
parameter_list|)
define|\
value|(FT_ULong)( (stream)->cursor - (stream)->base )
end_define
begin_define
DECL|macro|FT_Stream_SeekSet
define|#
directive|define
name|FT_Stream_SeekSet
parameter_list|(
name|stream
parameter_list|,
name|off
parameter_list|)
define|\
value|( (stream)->cursor = (stream)->base + (off) )
end_define
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
end_comment
begin_comment
comment|/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
end_comment
begin_comment
comment|/* messages during execution.                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_undef
DECL|macro|FT_COMPONENT
undef|#
directive|undef
name|FT_COMPONENT
end_undef
begin_define
DECL|macro|FT_COMPONENT
define|#
directive|define
name|FT_COMPONENT
value|trace_ttgxvar
end_define
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****                       Internal Routines                       *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* The macro ALL_POINTS is used in `ft_var_readpackedpoints'.  It        */
end_comment
begin_comment
comment|/* indicates that there is a delta for every point without needing to    */
end_comment
begin_comment
comment|/* enumerate all of them.                                                */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* ensure that value `0' has the same width as a pointer */
end_comment
begin_define
DECL|macro|ALL_POINTS
define|#
directive|define
name|ALL_POINTS
value|(FT_UShort*)~(FT_PtrDist)0
end_define
begin_define
DECL|macro|GX_PT_POINTS_ARE_WORDS
define|#
directive|define
name|GX_PT_POINTS_ARE_WORDS
value|0x80U
end_define
begin_define
DECL|macro|GX_PT_POINT_RUN_COUNT_MASK
define|#
directive|define
name|GX_PT_POINT_RUN_COUNT_MASK
value|0x7FU
end_define
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    ft_var_readpackedpoints                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Read a set of points to which the following deltas will apply.     */
end_comment
begin_comment
comment|/*    Points are packed with a run length encoding.                      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    stream    :: The data stream.                                      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Output>                                                              */
end_comment
begin_comment
comment|/*    point_cnt :: The number of points read.  A zero value means that   */
end_comment
begin_comment
comment|/*                 all points in the glyph will be affected, without     */
end_comment
begin_comment
comment|/*                 enumerating them individually.                        */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    An array of FT_UShort containing the affected points or the        */
end_comment
begin_comment
comment|/*    special value ALL_POINTS.                                          */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|FT_UShort
modifier|*
DECL|function|ft_var_readpackedpoints
name|ft_var_readpackedpoints
parameter_list|(
name|FT_Stream
name|stream
parameter_list|,
name|FT_UInt
modifier|*
name|point_cnt
parameter_list|)
block|{
name|FT_UShort
modifier|*
name|points
init|=
name|NULL
decl_stmt|;
name|FT_UInt
name|n
decl_stmt|;
name|FT_UInt
name|runcnt
decl_stmt|;
name|FT_UInt
name|i
decl_stmt|,
name|j
decl_stmt|;
name|FT_UShort
name|first
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|stream
operator|->
name|memory
decl_stmt|;
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
name|FT_UNUSED
argument_list|(
name|error
argument_list|)
expr_stmt|;
operator|*
name|point_cnt
operator|=
literal|0
expr_stmt|;
name|n
operator|=
name|FT_GET_BYTE
argument_list|()
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return
name|ALL_POINTS
return|;
if|if
condition|(
name|n
operator|&
name|GX_PT_POINTS_ARE_WORDS
condition|)
block|{
name|n
operator|&=
name|GX_PT_POINT_RUN_COUNT_MASK
expr_stmt|;
name|n
operator|<<=
literal|8
expr_stmt|;
name|n
operator||=
name|FT_GET_BYTE
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|points
argument_list|,
name|n
argument_list|)
condition|)
return|return
name|NULL
return|;
operator|*
name|point_cnt
operator|=
name|n
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|n
condition|)
block|{
name|runcnt
operator|=
name|FT_GET_BYTE
argument_list|()
expr_stmt|;
if|if
condition|(
name|runcnt
operator|&
name|GX_PT_POINTS_ARE_WORDS
condition|)
block|{
name|runcnt
operator|&=
name|GX_PT_POINT_RUN_COUNT_MASK
expr_stmt|;
name|first
operator|=
name|FT_GET_USHORT
argument_list|()
expr_stmt|;
name|points
index|[
name|i
operator|++
index|]
operator|=
name|first
expr_stmt|;
if|if
condition|(
name|runcnt
operator|<
literal|1
operator|||
name|i
operator|+
name|runcnt
operator|>
name|n
condition|)
goto|goto
name|Exit
goto|;
comment|/* first point not included in run count */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|runcnt
condition|;
name|j
operator|++
control|)
block|{
name|first
operator|+=
name|FT_GET_USHORT
argument_list|()
expr_stmt|;
name|points
index|[
name|i
operator|++
index|]
operator|=
name|first
expr_stmt|;
block|}
block|}
else|else
block|{
name|first
operator|=
name|FT_GET_BYTE
argument_list|()
expr_stmt|;
name|points
index|[
name|i
operator|++
index|]
operator|=
name|first
expr_stmt|;
if|if
condition|(
name|runcnt
operator|<
literal|1
operator|||
name|i
operator|+
name|runcnt
operator|>
name|n
condition|)
goto|goto
name|Exit
goto|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|runcnt
condition|;
name|j
operator|++
control|)
block|{
name|first
operator|+=
name|FT_GET_BYTE
argument_list|()
expr_stmt|;
name|points
index|[
name|i
operator|++
index|]
operator|=
name|first
expr_stmt|;
block|}
block|}
block|}
name|Exit
label|:
return|return
name|points
return|;
block|}
end_function
begin_define
DECL|macro|GX_DT_DELTAS_ARE_ZERO
define|#
directive|define
name|GX_DT_DELTAS_ARE_ZERO
value|0x80U
end_define
begin_define
DECL|macro|GX_DT_DELTAS_ARE_WORDS
define|#
directive|define
name|GX_DT_DELTAS_ARE_WORDS
value|0x40U
end_define
begin_define
DECL|macro|GX_DT_DELTA_RUN_COUNT_MASK
define|#
directive|define
name|GX_DT_DELTA_RUN_COUNT_MASK
value|0x3FU
end_define
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    ft_var_readpackeddeltas                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Read a set of deltas.  These are packed slightly differently than  */
end_comment
begin_comment
comment|/*    points.  In particular there is no overall count.                  */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    stream    :: The data stream.                                      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    delta_cnt :: The number of deltas to be read.                      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    An array of FT_Short containing the deltas for the affected        */
end_comment
begin_comment
comment|/*    points.  (This only gets the deltas for one dimension.  It will    */
end_comment
begin_comment
comment|/*    generally be called twice, once for x, once for y.  When used in   */
end_comment
begin_comment
comment|/*    cvt table, it will only be called once.)                           */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|FT_Short
modifier|*
DECL|function|ft_var_readpackeddeltas
name|ft_var_readpackeddeltas
parameter_list|(
name|FT_Stream
name|stream
parameter_list|,
name|FT_UInt
name|delta_cnt
parameter_list|)
block|{
name|FT_Short
modifier|*
name|deltas
init|=
name|NULL
decl_stmt|;
name|FT_UInt
name|runcnt
decl_stmt|,
name|cnt
decl_stmt|;
name|FT_UInt
name|i
decl_stmt|,
name|j
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|stream
operator|->
name|memory
decl_stmt|;
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
name|FT_UNUSED
argument_list|(
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|deltas
argument_list|,
name|delta_cnt
argument_list|)
condition|)
return|return
name|NULL
return|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|delta_cnt
condition|)
block|{
name|runcnt
operator|=
name|FT_GET_BYTE
argument_list|()
expr_stmt|;
name|cnt
operator|=
name|runcnt
operator|&
name|GX_DT_DELTA_RUN_COUNT_MASK
expr_stmt|;
if|if
condition|(
name|runcnt
operator|&
name|GX_DT_DELTAS_ARE_ZERO
condition|)
block|{
comment|/* `runcnt' zeroes get added */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|cnt
operator|&&
name|i
operator|<
name|delta_cnt
condition|;
name|j
operator|++
control|)
name|deltas
index|[
name|i
operator|++
index|]
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|runcnt
operator|&
name|GX_DT_DELTAS_ARE_WORDS
condition|)
block|{
comment|/* `runcnt' shorts from the stack */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|cnt
operator|&&
name|i
operator|<
name|delta_cnt
condition|;
name|j
operator|++
control|)
name|deltas
index|[
name|i
operator|++
index|]
operator|=
name|FT_GET_SHORT
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* `runcnt' signed bytes from the stack */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|cnt
operator|&&
name|i
operator|<
name|delta_cnt
condition|;
name|j
operator|++
control|)
name|deltas
index|[
name|i
operator|++
index|]
operator|=
name|FT_GET_CHAR
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|<=
name|cnt
condition|)
block|{
comment|/* bad format */
name|FT_FREE
argument_list|(
name|deltas
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
return|return
name|deltas
return|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    ft_var_load_avar                                                   */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Parse the `avar' table if present.  It need not be, so we return   */
end_comment
begin_comment
comment|/*    nothing.                                                           */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<InOut>                                                               */
end_comment
begin_comment
comment|/*    face :: The font face.                                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|ft_var_load_avar
name|ft_var_load_avar
parameter_list|(
name|TT_Face
name|face
parameter_list|)
block|{
name|FT_Stream
name|stream
init|=
name|FT_FACE_STREAM
argument_list|(
name|face
argument_list|)
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|stream
operator|->
name|memory
decl_stmt|;
name|GX_Blend
name|blend
init|=
name|face
operator|->
name|blend
decl_stmt|;
name|GX_AVarSegment
name|segment
decl_stmt|;
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
name|FT_Long
name|version
decl_stmt|;
name|FT_Long
name|axisCount
decl_stmt|;
name|FT_Int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|FT_ULong
name|table_len
decl_stmt|;
name|FT_UNUSED
argument_list|(
name|error
argument_list|)
expr_stmt|;
name|FT_TRACE2
argument_list|(
operator|(
literal|"AVAR "
operator|)
argument_list|)
expr_stmt|;
name|blend
operator|->
name|avar_checked
operator|=
name|TRUE
expr_stmt|;
name|error
operator|=
name|face
operator|->
name|goto_table
argument_list|(
name|face
argument_list|,
name|TTAG_avar
argument_list|,
name|stream
argument_list|,
operator|&
name|table_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|FT_TRACE2
argument_list|(
operator|(
literal|"is missing\n"
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|FT_FRAME_ENTER
argument_list|(
name|table_len
argument_list|)
condition|)
return|return;
name|version
operator|=
name|FT_GET_LONG
argument_list|()
expr_stmt|;
name|axisCount
operator|=
name|FT_GET_LONG
argument_list|()
expr_stmt|;
if|if
condition|(
name|version
operator|!=
literal|0x00010000L
condition|)
block|{
name|FT_TRACE2
argument_list|(
operator|(
literal|"bad table version\n"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|FT_TRACE2
argument_list|(
operator|(
literal|"loaded\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|axisCount
operator|!=
operator|(
name|FT_Long
operator|)
name|blend
operator|->
name|mmvar
operator|->
name|num_axis
condition|)
block|{
name|FT_TRACE2
argument_list|(
operator|(
literal|"ft_var_load_avar: number of axes in `avar' and `cvar'\n"
literal|"                  table are different\n"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|blend
operator|->
name|avar_segment
argument_list|,
name|axisCount
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|segment
operator|=
operator|&
name|blend
operator|->
name|avar_segment
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|axisCount
condition|;
name|i
operator|++
operator|,
name|segment
operator|++
control|)
block|{
name|FT_TRACE5
argument_list|(
operator|(
literal|"  axis %d:\n"
operator|,
name|i
operator|)
argument_list|)
expr_stmt|;
name|segment
operator|->
name|pairCount
operator|=
name|FT_GET_USHORT
argument_list|()
expr_stmt|;
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|segment
operator|->
name|correspondence
argument_list|,
name|segment
operator|->
name|pairCount
argument_list|)
condition|)
block|{
comment|/* Failure.  Free everything we have done so far.  We must do */
comment|/* it right now since loading the `avar' table is optional.   */
for|for
control|(
name|j
operator|=
name|i
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|FT_FREE
argument_list|(
name|blend
operator|->
name|avar_segment
index|[
name|j
index|]
operator|.
name|correspondence
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|blend
operator|->
name|avar_segment
argument_list|)
expr_stmt|;
name|blend
operator|->
name|avar_segment
operator|=
name|NULL
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|segment
operator|->
name|pairCount
condition|;
name|j
operator|++
control|)
block|{
comment|/* convert to Fixed */
name|segment
operator|->
name|correspondence
index|[
name|j
index|]
operator|.
name|fromCoord
operator|=
name|FT_GET_SHORT
argument_list|()
operator|*
literal|4
expr_stmt|;
name|segment
operator|->
name|correspondence
index|[
name|j
index|]
operator|.
name|toCoord
operator|=
name|FT_GET_SHORT
argument_list|()
operator|*
literal|4
expr_stmt|;
name|FT_TRACE5
argument_list|(
operator|(
literal|"    mapping %.4f to %.4f\n"
operator|,
name|segment
operator|->
name|correspondence
index|[
name|j
index|]
operator|.
name|fromCoord
operator|/
literal|65536.0
operator|,
name|segment
operator|->
name|correspondence
index|[
name|j
index|]
operator|.
name|toCoord
operator|/
literal|65536.0
operator|)
argument_list|)
expr_stmt|;
block|}
name|FT_TRACE5
argument_list|(
operator|(
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
block|}
name|Exit
label|:
name|FT_FRAME_EXIT
argument_list|()
expr_stmt|;
block|}
end_function
begin_typedef
DECL|struct|GX_GVar_Head_
typedef|typedef
struct|struct
name|GX_GVar_Head_
block|{
DECL|member|version
name|FT_Long
name|version
decl_stmt|;
DECL|member|axisCount
name|FT_UShort
name|axisCount
decl_stmt|;
DECL|member|globalCoordCount
name|FT_UShort
name|globalCoordCount
decl_stmt|;
DECL|member|offsetToCoord
name|FT_ULong
name|offsetToCoord
decl_stmt|;
DECL|member|glyphCount
name|FT_UShort
name|glyphCount
decl_stmt|;
DECL|member|flags
name|FT_UShort
name|flags
decl_stmt|;
DECL|member|offsetToData
name|FT_ULong
name|offsetToData
decl_stmt|;
block|}
DECL|typedef|GX_GVar_Head
name|GX_GVar_Head
typedef|;
end_typedef
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    ft_var_load_gvar                                                   */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Parse the `gvar' table if present.  If `fvar' is there, `gvar' had */
end_comment
begin_comment
comment|/*    better be there too.                                               */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<InOut>                                                               */
end_comment
begin_comment
comment|/*    face :: The font face.                                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    FreeType error code.  0 means success.                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|ft_var_load_gvar
name|ft_var_load_gvar
parameter_list|(
name|TT_Face
name|face
parameter_list|)
block|{
name|FT_Stream
name|stream
init|=
name|FT_FACE_STREAM
argument_list|(
name|face
argument_list|)
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|stream
operator|->
name|memory
decl_stmt|;
name|GX_Blend
name|blend
init|=
name|face
operator|->
name|blend
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|FT_UInt
name|i
decl_stmt|,
name|j
decl_stmt|;
name|FT_ULong
name|table_len
decl_stmt|;
name|FT_ULong
name|gvar_start
decl_stmt|;
name|FT_ULong
name|offsetToData
decl_stmt|;
name|GX_GVar_Head
name|gvar_head
decl_stmt|;
specifier|static
specifier|const
name|FT_Frame_Field
name|gvar_fields
index|[]
init|=
block|{
DECL|macro|FT_STRUCTURE
undef|#
directive|undef
name|FT_STRUCTURE
DECL|macro|FT_STRUCTURE
define|#
directive|define
name|FT_STRUCTURE
value|GX_GVar_Head
name|FT_FRAME_START
argument_list|(
literal|20
argument_list|)
block|,
name|FT_FRAME_LONG
argument_list|(
name|version
argument_list|)
block|,
name|FT_FRAME_USHORT
argument_list|(
name|axisCount
argument_list|)
block|,
name|FT_FRAME_USHORT
argument_list|(
name|globalCoordCount
argument_list|)
block|,
name|FT_FRAME_ULONG
argument_list|(
name|offsetToCoord
argument_list|)
block|,
name|FT_FRAME_USHORT
argument_list|(
name|glyphCount
argument_list|)
block|,
name|FT_FRAME_USHORT
argument_list|(
name|flags
argument_list|)
block|,
name|FT_FRAME_ULONG
argument_list|(
name|offsetToData
argument_list|)
block|,
name|FT_FRAME_END
block|}
decl_stmt|;
name|FT_TRACE2
argument_list|(
operator|(
literal|"GVAR "
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|face
operator|->
name|goto_table
argument_list|(
name|face
argument_list|,
name|TTAG_gvar
argument_list|,
name|stream
argument_list|,
operator|&
name|table_len
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|FT_TRACE2
argument_list|(
operator|(
literal|"is missing\n"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|gvar_start
operator|=
name|FT_STREAM_POS
argument_list|( )
expr_stmt|;
if|if
condition|(
name|FT_STREAM_READ_FIELDS
argument_list|(
name|gvar_fields
argument_list|,
operator|&
name|gvar_head
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|blend
operator|->
name|tuplecount
operator|=
name|gvar_head
operator|.
name|globalCoordCount
expr_stmt|;
name|blend
operator|->
name|gv_glyphcnt
operator|=
name|gvar_head
operator|.
name|glyphCount
expr_stmt|;
name|offsetToData
operator|=
name|gvar_start
operator|+
name|gvar_head
operator|.
name|offsetToData
expr_stmt|;
if|if
condition|(
name|gvar_head
operator|.
name|version
operator|!=
literal|0x00010000L
condition|)
block|{
name|FT_TRACE1
argument_list|(
operator|(
literal|"bad table version\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Table
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|FT_TRACE2
argument_list|(
operator|(
literal|"loaded\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|gvar_head
operator|.
name|axisCount
operator|!=
operator|(
name|FT_UShort
operator|)
name|blend
operator|->
name|mmvar
operator|->
name|num_axis
condition|)
block|{
name|FT_TRACE1
argument_list|(
operator|(
literal|"ft_var_load_gvar: number of axes in `gvar' and `cvar'\n"
literal|"                  table are different\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Table
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|FT_TRACE5
argument_list|(
operator|(
literal|"gvar: there are %d shared coordinates:\n"
operator|,
name|blend
operator|->
name|tuplecount
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|blend
operator|->
name|glyphoffsets
argument_list|,
name|blend
operator|->
name|gv_glyphcnt
operator|+
literal|1
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
if|if
condition|(
name|gvar_head
operator|.
name|flags
operator|&
literal|1
condition|)
block|{
comment|/* long offsets (one more offset than glyphs, to mark size of last) */
if|if
condition|(
name|FT_FRAME_ENTER
argument_list|(
operator|(
name|blend
operator|->
name|gv_glyphcnt
operator|+
literal|1
operator|)
operator|*
literal|4L
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|blend
operator|->
name|gv_glyphcnt
condition|;
name|i
operator|++
control|)
name|blend
operator|->
name|glyphoffsets
index|[
name|i
index|]
operator|=
name|offsetToData
operator|+
name|FT_GET_ULONG
argument_list|()
expr_stmt|;
name|FT_FRAME_EXIT
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* short offsets (one more offset than glyphs, to mark size of last) */
if|if
condition|(
name|FT_FRAME_ENTER
argument_list|(
operator|(
name|blend
operator|->
name|gv_glyphcnt
operator|+
literal|1
operator|)
operator|*
literal|2L
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|blend
operator|->
name|gv_glyphcnt
condition|;
name|i
operator|++
control|)
name|blend
operator|->
name|glyphoffsets
index|[
name|i
index|]
operator|=
name|offsetToData
operator|+
name|FT_GET_USHORT
argument_list|()
operator|*
literal|2
expr_stmt|;
comment|/* XXX: Undocumented: `*2'! */
name|FT_FRAME_EXIT
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|blend
operator|->
name|tuplecount
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|blend
operator|->
name|tuplecoords
argument_list|,
name|gvar_head
operator|.
name|axisCount
operator|*
name|blend
operator|->
name|tuplecount
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
if|if
condition|(
name|FT_STREAM_SEEK
argument_list|(
name|gvar_start
operator|+
name|gvar_head
operator|.
name|offsetToCoord
argument_list|)
operator|||
name|FT_FRAME_ENTER
argument_list|(
name|blend
operator|->
name|tuplecount
operator|*
name|gvar_head
operator|.
name|axisCount
operator|*
literal|2L
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|blend
operator|->
name|tuplecount
condition|;
name|i
operator|++
control|)
block|{
name|FT_TRACE5
argument_list|(
operator|(
literal|"  [ "
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
operator|(
name|FT_UInt
operator|)
name|gvar_head
operator|.
name|axisCount
condition|;
name|j
operator|++
control|)
block|{
name|blend
operator|->
name|tuplecoords
index|[
name|i
operator|*
name|gvar_head
operator|.
name|axisCount
operator|+
name|j
index|]
operator|=
name|FT_GET_SHORT
argument_list|()
operator|*
literal|4
expr_stmt|;
comment|/* convert to FT_Fixed */
name|FT_TRACE5
argument_list|(
operator|(
literal|"%.4f "
operator|,
name|blend
operator|->
name|tuplecoords
index|[
name|i
operator|*
name|gvar_head
operator|.
name|axisCount
operator|+
name|j
index|]
operator|/
literal|65536.0
operator|)
argument_list|)
expr_stmt|;
block|}
name|FT_TRACE5
argument_list|(
operator|(
literal|"]\n"
operator|)
argument_list|)
expr_stmt|;
block|}
name|FT_TRACE5
argument_list|(
operator|(
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
name|FT_FRAME_EXIT
argument_list|()
expr_stmt|;
block|}
name|Exit
label|:
return|return
name|error
return|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    ft_var_apply_tuple                                                 */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Figure out whether a given tuple (design) applies to the current   */
end_comment
begin_comment
comment|/*    blend, and if so, what is the scaling factor.                      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    blend           :: The current blend of the font.                  */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    tupleIndex      :: A flag saying whether this is an intermediate   */
end_comment
begin_comment
comment|/*                       tuple or not.                                   */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    tuple_coords    :: The coordinates of the tuple in normalized axis */
end_comment
begin_comment
comment|/*                       units.                                          */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    im_start_coords :: The initial coordinates where this tuple starts */
end_comment
begin_comment
comment|/*                       to apply (for intermediate coordinates).        */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    im_end_coords   :: The final coordinates after which this tuple no */
end_comment
begin_comment
comment|/*                       longer applies (for intermediate coordinates).  */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    An FT_Fixed value containing the scaling factor.                   */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|FT_Fixed
DECL|function|ft_var_apply_tuple
name|ft_var_apply_tuple
parameter_list|(
name|GX_Blend
name|blend
parameter_list|,
name|FT_UShort
name|tupleIndex
parameter_list|,
name|FT_Fixed
modifier|*
name|tuple_coords
parameter_list|,
name|FT_Fixed
modifier|*
name|im_start_coords
parameter_list|,
name|FT_Fixed
modifier|*
name|im_end_coords
parameter_list|)
block|{
name|FT_UInt
name|i
decl_stmt|;
name|FT_Fixed
name|apply
init|=
literal|0x10000L
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|blend
operator|->
name|num_axis
condition|;
name|i
operator|++
control|)
block|{
name|FT_TRACE6
argument_list|(
operator|(
literal|"    axis coordinate %d (%.4f):\n"
operator|,
name|i
operator|,
name|blend
operator|->
name|normalizedcoords
index|[
name|i
index|]
operator|/
literal|65536.0
operator|)
argument_list|)
expr_stmt|;
comment|/* It's not clear why (for intermediate tuples) we don't need     */
comment|/* to check against start/end -- the documentation says we don't. */
comment|/* Similarly, it's unclear why we don't need to scale along the   */
comment|/* axis.                                                          */
if|if
condition|(
name|tuple_coords
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
name|FT_TRACE6
argument_list|(
operator|(
literal|"      tuple coordinate is zero, ignored\n"
operator|,
name|i
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|blend
operator|->
name|normalizedcoords
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
name|FT_TRACE6
argument_list|(
operator|(
literal|"      axis coordinate is zero, stop\n"
operator|)
argument_list|)
expr_stmt|;
name|apply
operator|=
literal|0
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|(
name|blend
operator|->
name|normalizedcoords
index|[
name|i
index|]
operator|<
literal|0
operator|&&
name|tuple_coords
index|[
name|i
index|]
operator|>
literal|0
operator|)
operator|||
operator|(
name|blend
operator|->
name|normalizedcoords
index|[
name|i
index|]
operator|>
literal|0
operator|&&
name|tuple_coords
index|[
name|i
index|]
operator|<
literal|0
operator|)
condition|)
block|{
name|FT_TRACE6
argument_list|(
operator|(
literal|"      tuple coordinate value %.4f is exceeded, stop\n"
operator|,
name|tuple_coords
index|[
name|i
index|]
operator|/
literal|65536.0
operator|)
argument_list|)
expr_stmt|;
name|apply
operator|=
literal|0
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|tupleIndex
operator|&
name|GX_TI_INTERMEDIATE_TUPLE
operator|)
condition|)
block|{
name|FT_TRACE6
argument_list|(
operator|(
literal|"      tuple coordinate value %.4f fits\n"
operator|,
name|tuple_coords
index|[
name|i
index|]
operator|/
literal|65536.0
operator|)
argument_list|)
expr_stmt|;
comment|/* not an intermediate tuple */
name|apply
operator|=
name|FT_MulFix
argument_list|(
name|apply
argument_list|,
name|blend
operator|->
name|normalizedcoords
index|[
name|i
index|]
operator|>
literal|0
condition|?
name|blend
operator|->
name|normalizedcoords
index|[
name|i
index|]
else|:
operator|-
name|blend
operator|->
name|normalizedcoords
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|blend
operator|->
name|normalizedcoords
index|[
name|i
index|]
operator|<
name|im_start_coords
index|[
name|i
index|]
operator|||
name|blend
operator|->
name|normalizedcoords
index|[
name|i
index|]
operator|>
name|im_end_coords
index|[
name|i
index|]
condition|)
block|{
name|FT_TRACE6
argument_list|(
operator|(
literal|"      intermediate tuple range [%.4f;%.4f] is exceeded,"
literal|" stop\n"
operator|,
name|im_start_coords
index|[
name|i
index|]
operator|/
literal|65536.0
operator|,
name|im_end_coords
index|[
name|i
index|]
operator|/
literal|65536.0
operator|)
argument_list|)
expr_stmt|;
name|apply
operator|=
literal|0
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|blend
operator|->
name|normalizedcoords
index|[
name|i
index|]
operator|<
name|tuple_coords
index|[
name|i
index|]
condition|)
block|{
name|FT_TRACE6
argument_list|(
operator|(
literal|"      intermediate tuple range [%.4f;%.4f] fits\n"
operator|,
name|im_start_coords
index|[
name|i
index|]
operator|/
literal|65536.0
operator|,
name|im_end_coords
index|[
name|i
index|]
operator|/
literal|65536.0
operator|)
argument_list|)
expr_stmt|;
name|apply
operator|=
name|FT_MulDiv
argument_list|(
name|apply
argument_list|,
name|blend
operator|->
name|normalizedcoords
index|[
name|i
index|]
operator|-
name|im_start_coords
index|[
name|i
index|]
argument_list|,
name|tuple_coords
index|[
name|i
index|]
operator|-
name|im_start_coords
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|FT_TRACE6
argument_list|(
operator|(
literal|"      intermediate tuple range [%.4f;%.4f] fits\n"
operator|,
name|im_start_coords
index|[
name|i
index|]
operator|/
literal|65536.0
operator|,
name|im_end_coords
index|[
name|i
index|]
operator|/
literal|65536.0
operator|)
argument_list|)
expr_stmt|;
name|apply
operator|=
name|FT_MulDiv
argument_list|(
name|apply
argument_list|,
name|im_end_coords
index|[
name|i
index|]
operator|-
name|blend
operator|->
name|normalizedcoords
index|[
name|i
index|]
argument_list|,
name|im_end_coords
index|[
name|i
index|]
operator|-
name|tuple_coords
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|FT_TRACE6
argument_list|(
operator|(
literal|"    apply factor is %.4f\n"
operator|,
name|apply
operator|/
literal|65536.0
operator|)
argument_list|)
expr_stmt|;
return|return
name|apply
return|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****               MULTIPLE MASTERS SERVICE FUNCTIONS              *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_typedef
DECL|struct|GX_FVar_Head_
typedef|typedef
struct|struct
name|GX_FVar_Head_
block|{
DECL|member|version
name|FT_Long
name|version
decl_stmt|;
DECL|member|offsetToData
name|FT_UShort
name|offsetToData
decl_stmt|;
DECL|member|countSizePairs
name|FT_UShort
name|countSizePairs
decl_stmt|;
DECL|member|axisCount
name|FT_UShort
name|axisCount
decl_stmt|;
DECL|member|axisSize
name|FT_UShort
name|axisSize
decl_stmt|;
DECL|member|instanceCount
name|FT_UShort
name|instanceCount
decl_stmt|;
DECL|member|instanceSize
name|FT_UShort
name|instanceSize
decl_stmt|;
block|}
DECL|typedef|GX_FVar_Head
name|GX_FVar_Head
typedef|;
end_typedef
begin_typedef
DECL|struct|fvar_axis_
typedef|typedef
struct|struct
name|fvar_axis_
block|{
DECL|member|axisTag
name|FT_ULong
name|axisTag
decl_stmt|;
DECL|member|minValue
name|FT_Fixed
name|minValue
decl_stmt|;
DECL|member|defaultValue
name|FT_Fixed
name|defaultValue
decl_stmt|;
DECL|member|maxValue
name|FT_Fixed
name|maxValue
decl_stmt|;
DECL|member|flags
name|FT_UShort
name|flags
decl_stmt|;
DECL|member|nameID
name|FT_UShort
name|nameID
decl_stmt|;
block|}
DECL|typedef|GX_FVar_Axis
name|GX_FVar_Axis
typedef|;
end_typedef
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    TT_Get_MM_Var                                                      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Check that the font's `fvar' table is valid, parse it, and return  */
end_comment
begin_comment
comment|/*    those data.                                                        */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<InOut>                                                               */
end_comment
begin_comment
comment|/*    face   :: The font face.                                           */
end_comment
begin_comment
comment|/*              TT_Get_MM_Var initializes the blend structure.           */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Output>                                                              */
end_comment
begin_comment
comment|/*    master :: The `fvar' data (must be freed by caller).  Can be NULL, */
end_comment
begin_comment
comment|/*              which makes this function simply load MM support.        */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    FreeType error code.  0 means success.                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|TT_Get_MM_Var
argument_list|(
argument|TT_Face      face
argument_list|,
argument|FT_MM_Var*  *master
argument_list|)
end_macro
begin_block
block|{
name|FT_Stream
name|stream
init|=
name|face
operator|->
name|root
operator|.
name|stream
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|face
operator|->
name|root
operator|.
name|memory
decl_stmt|;
name|FT_ULong
name|table_len
decl_stmt|;
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
name|FT_ULong
name|fvar_start
decl_stmt|;
name|FT_Int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|FT_MM_Var
modifier|*
name|mmvar
init|=
name|NULL
decl_stmt|;
name|FT_Fixed
modifier|*
name|next_coords
decl_stmt|;
name|FT_String
modifier|*
name|next_name
decl_stmt|;
name|FT_Var_Axis
modifier|*
name|a
decl_stmt|;
name|FT_Var_Named_Style
modifier|*
name|ns
decl_stmt|;
name|GX_FVar_Head
name|fvar_head
decl_stmt|;
specifier|static
specifier|const
name|FT_Frame_Field
name|fvar_fields
index|[]
init|=
block|{
DECL|macro|FT_STRUCTURE
undef|#
directive|undef
name|FT_STRUCTURE
DECL|macro|FT_STRUCTURE
define|#
directive|define
name|FT_STRUCTURE
value|GX_FVar_Head
name|FT_FRAME_START
argument_list|(
literal|16
argument_list|)
block|,
name|FT_FRAME_LONG
argument_list|(
name|version
argument_list|)
block|,
name|FT_FRAME_USHORT
argument_list|(
name|offsetToData
argument_list|)
block|,
name|FT_FRAME_USHORT
argument_list|(
name|countSizePairs
argument_list|)
block|,
name|FT_FRAME_USHORT
argument_list|(
name|axisCount
argument_list|)
block|,
name|FT_FRAME_USHORT
argument_list|(
name|axisSize
argument_list|)
block|,
name|FT_FRAME_USHORT
argument_list|(
name|instanceCount
argument_list|)
block|,
name|FT_FRAME_USHORT
argument_list|(
name|instanceSize
argument_list|)
block|,
name|FT_FRAME_END
block|}
decl_stmt|;
specifier|static
specifier|const
name|FT_Frame_Field
name|fvaraxis_fields
index|[]
init|=
block|{
DECL|macro|FT_STRUCTURE
undef|#
directive|undef
name|FT_STRUCTURE
DECL|macro|FT_STRUCTURE
define|#
directive|define
name|FT_STRUCTURE
value|GX_FVar_Axis
name|FT_FRAME_START
argument_list|(
literal|20
argument_list|)
block|,
name|FT_FRAME_ULONG
argument_list|(
name|axisTag
argument_list|)
block|,
name|FT_FRAME_LONG
argument_list|(
name|minValue
argument_list|)
block|,
name|FT_FRAME_LONG
argument_list|(
name|defaultValue
argument_list|)
block|,
name|FT_FRAME_LONG
argument_list|(
name|maxValue
argument_list|)
block|,
name|FT_FRAME_USHORT
argument_list|(
name|flags
argument_list|)
block|,
name|FT_FRAME_USHORT
argument_list|(
name|nameID
argument_list|)
block|,
name|FT_FRAME_END
block|}
decl_stmt|;
comment|/* read the font data and set up the internal representation */
comment|/* if not already done                                       */
if|if
condition|(
name|face
operator|->
name|blend
operator|==
name|NULL
condition|)
block|{
name|FT_TRACE2
argument_list|(
operator|(
literal|"FVAR "
operator|)
argument_list|)
expr_stmt|;
comment|/* both `fvar' and `gvar' must be present */
if|if
condition|(
operator|(
name|error
operator|=
name|face
operator|->
name|goto_table
argument_list|(
name|face
argument_list|,
name|TTAG_gvar
argument_list|,
name|stream
argument_list|,
operator|&
name|table_len
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|FT_TRACE1
argument_list|(
operator|(
literal|"\n"
literal|"TT_Get_MM_Var: `gvar' table is missing\n"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|face
operator|->
name|goto_table
argument_list|(
name|face
argument_list|,
name|TTAG_fvar
argument_list|,
name|stream
argument_list|,
operator|&
name|table_len
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|FT_TRACE1
argument_list|(
operator|(
literal|"is missing\n"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|fvar_start
operator|=
name|FT_STREAM_POS
argument_list|( )
expr_stmt|;
if|if
condition|(
name|FT_STREAM_READ_FIELDS
argument_list|(
name|fvar_fields
argument_list|,
operator|&
name|fvar_head
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
if|if
condition|(
name|fvar_head
operator|.
name|version
operator|!=
operator|(
name|FT_Long
operator|)
literal|0x00010000L
operator|||
if|#
directive|if
literal|0
comment|/* fonts like `JamRegular.ttf' have an incorrect value for */
comment|/* `countSizePairs'; since value 2 is hard-coded in `fvar' */
comment|/* version 1.0, we simply ignore it                        */
expr|fvar_head.countSizePairs != 2                                  ||
endif|#
directive|endif
name|fvar_head
operator|.
name|axisSize
operator|!=
literal|20
operator|||
comment|/* axisCount limit implied by 16-bit instanceSize */
name|fvar_head
operator|.
name|axisCount
operator|>
literal|0x3FFE
operator|||
name|fvar_head
operator|.
name|instanceSize
operator|!=
literal|4
operator|+
literal|4
operator|*
name|fvar_head
operator|.
name|axisCount
operator|||
comment|/* instanceCount limit implied by limited range of name IDs */
name|fvar_head
operator|.
name|instanceCount
operator|>
literal|0x7EFF
operator|||
name|fvar_head
operator|.
name|offsetToData
operator|+
name|fvar_head
operator|.
name|axisCount
operator|*
literal|20U
operator|+
name|fvar_head
operator|.
name|instanceCount
operator|*
name|fvar_head
operator|.
name|instanceSize
operator|>
name|table_len
condition|)
block|{
name|FT_TRACE1
argument_list|(
operator|(
literal|"\n"
literal|"TT_Get_MM_Var: invalid `fvar' header\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Table
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|FT_TRACE2
argument_list|(
operator|(
literal|"loaded\n"
operator|)
argument_list|)
expr_stmt|;
name|FT_TRACE5
argument_list|(
operator|(
literal|"number of GX style axes: %d\n"
operator|,
name|fvar_head
operator|.
name|axisCount
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|FT_NEW
argument_list|(
name|face
operator|->
name|blend
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
comment|/* cannot overflow 32-bit arithmetic because of limits above */
name|face
operator|->
name|blend
operator|->
name|mmvar_len
operator|=
sizeof|sizeof
argument_list|(
name|FT_MM_Var
argument_list|)
operator|+
name|fvar_head
operator|.
name|axisCount
operator|*
sizeof|sizeof
argument_list|(
name|FT_Var_Axis
argument_list|)
operator|+
name|fvar_head
operator|.
name|instanceCount
operator|*
sizeof|sizeof
argument_list|(
name|FT_Var_Named_Style
argument_list|)
operator|+
name|fvar_head
operator|.
name|instanceCount
operator|*
name|fvar_head
operator|.
name|axisCount
operator|*
sizeof|sizeof
argument_list|(
name|FT_Fixed
argument_list|)
operator|+
literal|5
operator|*
name|fvar_head
operator|.
name|axisCount
expr_stmt|;
if|if
condition|(
name|FT_ALLOC
argument_list|(
name|mmvar
argument_list|,
name|face
operator|->
name|blend
operator|->
name|mmvar_len
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|face
operator|->
name|blend
operator|->
name|mmvar
operator|=
name|mmvar
expr_stmt|;
comment|/* set up pointers and offsets into the `mmvar' array; */
comment|/* the data gets filled in later on                    */
name|mmvar
operator|->
name|num_axis
operator|=
name|fvar_head
operator|.
name|axisCount
expr_stmt|;
name|mmvar
operator|->
name|num_designs
operator|=
operator|~
literal|0U
expr_stmt|;
comment|/* meaningless in this context; each glyph */
comment|/* may have a different number of designs  */
comment|/* (or tuples, as called by Apple)         */
name|mmvar
operator|->
name|num_namedstyles
operator|=
name|fvar_head
operator|.
name|instanceCount
expr_stmt|;
name|mmvar
operator|->
name|axis
operator|=
operator|(
name|FT_Var_Axis
operator|*
operator|)
operator|&
operator|(
name|mmvar
index|[
literal|1
index|]
operator|)
expr_stmt|;
name|mmvar
operator|->
name|namedstyle
operator|=
operator|(
name|FT_Var_Named_Style
operator|*
operator|)
operator|&
operator|(
name|mmvar
operator|->
name|axis
index|[
name|fvar_head
operator|.
name|axisCount
index|]
operator|)
expr_stmt|;
name|next_coords
operator|=
operator|(
name|FT_Fixed
operator|*
operator|)
operator|&
operator|(
name|mmvar
operator|->
name|namedstyle
index|[
name|fvar_head
operator|.
name|instanceCount
index|]
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fvar_head
operator|.
name|instanceCount
condition|;
name|i
operator|++
control|)
block|{
name|mmvar
operator|->
name|namedstyle
index|[
name|i
index|]
operator|.
name|coords
operator|=
name|next_coords
expr_stmt|;
name|next_coords
operator|+=
name|fvar_head
operator|.
name|axisCount
expr_stmt|;
block|}
name|next_name
operator|=
operator|(
name|FT_String
operator|*
operator|)
name|next_coords
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fvar_head
operator|.
name|axisCount
condition|;
name|i
operator|++
control|)
block|{
name|mmvar
operator|->
name|axis
index|[
name|i
index|]
operator|.
name|name
operator|=
name|next_name
expr_stmt|;
name|next_name
operator|+=
literal|5
expr_stmt|;
block|}
comment|/* now fill in the data */
if|if
condition|(
name|FT_STREAM_SEEK
argument_list|(
name|fvar_start
operator|+
name|fvar_head
operator|.
name|offsetToData
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|a
operator|=
name|mmvar
operator|->
name|axis
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fvar_head
operator|.
name|axisCount
condition|;
name|i
operator|++
control|)
block|{
name|GX_FVar_Axis
name|axis_rec
decl_stmt|;
if|if
condition|(
name|FT_STREAM_READ_FIELDS
argument_list|(
name|fvaraxis_fields
argument_list|,
operator|&
name|axis_rec
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|a
operator|->
name|tag
operator|=
name|axis_rec
operator|.
name|axisTag
expr_stmt|;
name|a
operator|->
name|minimum
operator|=
name|axis_rec
operator|.
name|minValue
expr_stmt|;
name|a
operator|->
name|def
operator|=
name|axis_rec
operator|.
name|defaultValue
expr_stmt|;
name|a
operator|->
name|maximum
operator|=
name|axis_rec
operator|.
name|maxValue
expr_stmt|;
name|a
operator|->
name|strid
operator|=
name|axis_rec
operator|.
name|nameID
expr_stmt|;
name|a
operator|->
name|name
index|[
literal|0
index|]
operator|=
call|(
name|FT_String
call|)
argument_list|(
name|a
operator|->
name|tag
operator|>>
literal|24
argument_list|)
expr_stmt|;
name|a
operator|->
name|name
index|[
literal|1
index|]
operator|=
call|(
name|FT_String
call|)
argument_list|(
operator|(
name|a
operator|->
name|tag
operator|>>
literal|16
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|a
operator|->
name|name
index|[
literal|2
index|]
operator|=
call|(
name|FT_String
call|)
argument_list|(
operator|(
name|a
operator|->
name|tag
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|a
operator|->
name|name
index|[
literal|3
index|]
operator|=
call|(
name|FT_String
call|)
argument_list|(
operator|(
name|a
operator|->
name|tag
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|a
operator|->
name|name
index|[
literal|4
index|]
operator|=
literal|'\0'
expr_stmt|;
name|FT_TRACE5
argument_list|(
operator|(
literal|"  \"%s\": minimum=%.4f, default=%.4f, maximum=%.4f\n"
operator|,
name|a
operator|->
name|name
operator|,
name|a
operator|->
name|minimum
operator|/
literal|65536.0
operator|,
name|a
operator|->
name|def
operator|/
literal|65536.0
operator|,
name|a
operator|->
name|maximum
operator|/
literal|65536.0
operator|)
argument_list|)
expr_stmt|;
name|a
operator|++
expr_stmt|;
block|}
name|FT_TRACE5
argument_list|(
operator|(
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
name|ns
operator|=
name|mmvar
operator|->
name|namedstyle
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fvar_head
operator|.
name|instanceCount
condition|;
name|i
operator|++
operator|,
name|ns
operator|++
control|)
block|{
if|if
condition|(
name|FT_FRAME_ENTER
argument_list|(
literal|4L
operator|+
literal|4L
operator|*
name|fvar_head
operator|.
name|axisCount
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|ns
operator|->
name|strid
operator|=
name|FT_GET_USHORT
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
comment|/* flags = */
name|FT_GET_USHORT
argument_list|()
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|fvar_head
operator|.
name|axisCount
condition|;
name|j
operator|++
control|)
name|ns
operator|->
name|coords
index|[
name|j
index|]
operator|=
name|FT_GET_LONG
argument_list|()
expr_stmt|;
name|FT_FRAME_EXIT
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* fill the output array if requested */
if|if
condition|(
name|master
operator|!=
name|NULL
condition|)
block|{
name|FT_UInt
name|n
decl_stmt|;
if|if
condition|(
name|FT_ALLOC
argument_list|(
name|mmvar
argument_list|,
name|face
operator|->
name|blend
operator|->
name|mmvar_len
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|FT_MEM_COPY
argument_list|(
name|mmvar
argument_list|,
name|face
operator|->
name|blend
operator|->
name|mmvar
argument_list|,
name|face
operator|->
name|blend
operator|->
name|mmvar_len
argument_list|)
expr_stmt|;
name|mmvar
operator|->
name|axis
operator|=
operator|(
name|FT_Var_Axis
operator|*
operator|)
operator|&
operator|(
name|mmvar
index|[
literal|1
index|]
operator|)
expr_stmt|;
name|mmvar
operator|->
name|namedstyle
operator|=
operator|(
name|FT_Var_Named_Style
operator|*
operator|)
operator|&
operator|(
name|mmvar
operator|->
name|axis
index|[
name|mmvar
operator|->
name|num_axis
index|]
operator|)
expr_stmt|;
name|next_coords
operator|=
operator|(
name|FT_Fixed
operator|*
operator|)
operator|&
operator|(
name|mmvar
operator|->
name|namedstyle
index|[
name|mmvar
operator|->
name|num_namedstyles
index|]
operator|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|mmvar
operator|->
name|num_namedstyles
condition|;
name|n
operator|++
control|)
block|{
name|mmvar
operator|->
name|namedstyle
index|[
name|n
index|]
operator|.
name|coords
operator|=
name|next_coords
expr_stmt|;
name|next_coords
operator|+=
name|mmvar
operator|->
name|num_axis
expr_stmt|;
block|}
name|a
operator|=
name|mmvar
operator|->
name|axis
expr_stmt|;
name|next_name
operator|=
operator|(
name|FT_String
operator|*
operator|)
name|next_coords
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|mmvar
operator|->
name|num_axis
condition|;
name|n
operator|++
control|)
block|{
name|a
operator|->
name|name
operator|=
name|next_name
expr_stmt|;
comment|/* standard PostScript names for some standard apple tags */
if|if
condition|(
name|a
operator|->
name|tag
operator|==
name|TTAG_wght
condition|)
name|a
operator|->
name|name
operator|=
operator|(
name|char
operator|*
operator|)
literal|"Weight"
expr_stmt|;
elseif|else
if|if
condition|(
name|a
operator|->
name|tag
operator|==
name|TTAG_wdth
condition|)
name|a
operator|->
name|name
operator|=
operator|(
name|char
operator|*
operator|)
literal|"Width"
expr_stmt|;
elseif|else
if|if
condition|(
name|a
operator|->
name|tag
operator|==
name|TTAG_opsz
condition|)
name|a
operator|->
name|name
operator|=
operator|(
name|char
operator|*
operator|)
literal|"OpticalSize"
expr_stmt|;
elseif|else
if|if
condition|(
name|a
operator|->
name|tag
operator|==
name|TTAG_slnt
condition|)
name|a
operator|->
name|name
operator|=
operator|(
name|char
operator|*
operator|)
literal|"Slant"
expr_stmt|;
name|next_name
operator|+=
literal|5
expr_stmt|;
name|a
operator|++
expr_stmt|;
block|}
operator|*
name|master
operator|=
name|mmvar
expr_stmt|;
block|}
name|Exit
label|:
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    TT_Set_MM_Blend                                                    */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Set the blend (normalized) coordinates for this instance of the    */
end_comment
begin_comment
comment|/*    font.  Check that the `gvar' table is reasonable and does some     */
end_comment
begin_comment
comment|/*    initial preparation.                                               */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<InOut>                                                               */
end_comment
begin_comment
comment|/*    face       :: The font.                                            */
end_comment
begin_comment
comment|/*                  Initialize the blend structure with `gvar' data.     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    num_coords :: The number of available coordinates.  If it is       */
end_comment
begin_comment
comment|/*                  larger than the number of axes, ignore the excess    */
end_comment
begin_comment
comment|/*                  values.  If it is smaller than the number of axes,   */
end_comment
begin_comment
comment|/*                  use the default value (0) for the remaining axes.    */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    coords     :: An array of `num_coords', each between [-1,1].       */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    FreeType error code.  0 means success.                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|TT_Set_MM_Blend
argument_list|(
argument|TT_Face    face
argument_list|,
argument|FT_UInt    num_coords
argument_list|,
argument|FT_Fixed*  coords
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
name|GX_Blend
name|blend
decl_stmt|;
name|FT_MM_Var
modifier|*
name|mmvar
decl_stmt|;
name|FT_UInt
name|i
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|face
operator|->
name|root
operator|.
name|memory
decl_stmt|;
enum|enum
block|{
name|mcvt_retain
block|,
name|mcvt_modify
block|,
name|mcvt_load
block|}
name|manageCvt
enum|;
name|face
operator|->
name|doblend
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|face
operator|->
name|blend
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|TT_Get_MM_Var
argument_list|(
name|face
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|Exit
goto|;
block|}
name|blend
operator|=
name|face
operator|->
name|blend
expr_stmt|;
name|mmvar
operator|=
name|blend
operator|->
name|mmvar
expr_stmt|;
if|if
condition|(
name|num_coords
operator|>
name|mmvar
operator|->
name|num_axis
condition|)
block|{
name|FT_TRACE2
argument_list|(
operator|(
literal|"TT_Set_MM_Blend: only using first %d of %d coordinates\n"
operator|,
name|mmvar
operator|->
name|num_axis
operator|,
name|num_coords
operator|)
argument_list|)
expr_stmt|;
name|num_coords
operator|=
name|mmvar
operator|->
name|num_axis
expr_stmt|;
block|}
name|FT_TRACE5
argument_list|(
operator|(
literal|"normalized design coordinates:\n"
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_coords
condition|;
name|i
operator|++
control|)
block|{
name|FT_TRACE5
argument_list|(
operator|(
literal|"  %.4f\n"
operator|,
name|coords
index|[
name|i
index|]
operator|/
literal|65536.0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|coords
index|[
name|i
index|]
operator|<
operator|-
literal|0x00010000L
operator|||
name|coords
index|[
name|i
index|]
operator|>
literal|0x00010000L
condition|)
block|{
name|FT_TRACE1
argument_list|(
operator|(
literal|"TT_Set_MM_Blend: normalized design coordinate %.4f\n"
literal|"                 is out of range [-1;1]\n"
operator|,
name|coords
index|[
name|i
index|]
operator|/
literal|65536.0
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Argument
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
name|FT_TRACE5
argument_list|(
operator|(
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|blend
operator|->
name|glyphoffsets
operator|==
name|NULL
condition|)
if|if
condition|(
operator|(
name|error
operator|=
name|ft_var_load_gvar
argument_list|(
name|face
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|Exit
goto|;
if|if
condition|(
name|blend
operator|->
name|normalizedcoords
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|blend
operator|->
name|normalizedcoords
argument_list|,
name|mmvar
operator|->
name|num_axis
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|manageCvt
operator|=
name|mcvt_modify
expr_stmt|;
comment|/* If we have not set the blend coordinates before this, then the  */
comment|/* cvt table will still be what we read from the `cvt ' table and  */
comment|/* we don't need to reload it.  We may need to change it though... */
block|}
else|else
block|{
name|manageCvt
operator|=
name|mcvt_retain
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_coords
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|blend
operator|->
name|normalizedcoords
index|[
name|i
index|]
operator|!=
name|coords
index|[
name|i
index|]
condition|)
block|{
name|manageCvt
operator|=
name|mcvt_load
expr_stmt|;
break|break;
block|}
block|}
for|for
control|(
init|;
name|i
operator|<
name|mmvar
operator|->
name|num_axis
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|blend
operator|->
name|normalizedcoords
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
name|manageCvt
operator|=
name|mcvt_load
expr_stmt|;
break|break;
block|}
block|}
comment|/* If we don't change the blend coords then we don't need to do  */
comment|/* anything to the cvt table.  It will be correct.  Otherwise we */
comment|/* no longer have the original cvt (it was modified when we set  */
comment|/* the blend last time), so we must reload and then modify it.   */
block|}
name|blend
operator|->
name|num_axis
operator|=
name|mmvar
operator|->
name|num_axis
expr_stmt|;
name|FT_MEM_COPY
argument_list|(
name|blend
operator|->
name|normalizedcoords
argument_list|,
name|coords
argument_list|,
name|num_coords
operator|*
sizeof|sizeof
argument_list|(
name|FT_Fixed
argument_list|)
argument_list|)
expr_stmt|;
name|face
operator|->
name|doblend
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|face
operator|->
name|cvt
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|manageCvt
condition|)
block|{
case|case
name|mcvt_load
case|:
comment|/* The cvt table has been loaded already; every time we change the */
comment|/* blend we may need to reload and remodify the cvt table.         */
name|FT_FREE
argument_list|(
name|face
operator|->
name|cvt
argument_list|)
expr_stmt|;
name|face
operator|->
name|cvt
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|tt_face_load_cvt
argument_list|(
name|face
argument_list|,
name|face
operator|->
name|root
operator|.
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
name|mcvt_modify
case|:
comment|/* The original cvt table is in memory.  All we need to do is */
comment|/* apply the `cvar' table (if any).                           */
name|error
operator|=
name|tt_face_vary_cvt
argument_list|(
name|face
argument_list|,
name|face
operator|->
name|root
operator|.
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
name|mcvt_retain
case|:
comment|/* The cvt table is correct for this set of coordinates. */
break|break;
block|}
block|}
name|Exit
label|:
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    TT_Set_Var_Design                                                  */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Set the coordinates for the instance, measured in the user         */
end_comment
begin_comment
comment|/*    coordinate system.  Parse the `avar' table (if present) to convert */
end_comment
begin_comment
comment|/*    from user to normalized coordinates.                               */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<InOut>                                                               */
end_comment
begin_comment
comment|/*    face       :: The font face.                                       */
end_comment
begin_comment
comment|/*                  Initialize the blend struct with `gvar' data.        */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    num_coords :: The number of available coordinates.  If it is       */
end_comment
begin_comment
comment|/*                  larger than the number of axes, ignore the excess    */
end_comment
begin_comment
comment|/*                  values.  If it is smaller than the number of axes,   */
end_comment
begin_comment
comment|/*                  use the default values for the remaining axes.       */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    coords     :: A coordinate array with `num_coords' elements.       */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    FreeType error code.  0 means success.                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|TT_Set_Var_Design
argument_list|(
argument|TT_Face    face
argument_list|,
argument|FT_UInt    num_coords
argument_list|,
argument|FT_Fixed*  coords
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
name|FT_Fixed
modifier|*
name|normalized
init|=
name|NULL
decl_stmt|;
name|GX_Blend
name|blend
decl_stmt|;
name|FT_MM_Var
modifier|*
name|mmvar
decl_stmt|;
name|FT_UInt
name|i
decl_stmt|,
name|j
decl_stmt|;
name|FT_Var_Axis
modifier|*
name|a
decl_stmt|;
name|GX_AVarSegment
name|av
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|face
operator|->
name|root
operator|.
name|memory
decl_stmt|;
if|if
condition|(
name|face
operator|->
name|blend
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|TT_Get_MM_Var
argument_list|(
name|face
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|Exit
goto|;
block|}
name|blend
operator|=
name|face
operator|->
name|blend
expr_stmt|;
name|mmvar
operator|=
name|blend
operator|->
name|mmvar
expr_stmt|;
if|if
condition|(
name|num_coords
operator|>
name|mmvar
operator|->
name|num_axis
condition|)
block|{
name|FT_TRACE2
argument_list|(
operator|(
literal|"TT_Set_Var_Design:"
literal|" only using first %d of %d coordinates\n"
operator|,
name|mmvar
operator|->
name|num_axis
operator|,
name|num_coords
operator|)
argument_list|)
expr_stmt|;
name|num_coords
operator|=
name|mmvar
operator|->
name|num_axis
expr_stmt|;
block|}
comment|/* Axis normalization is a two stage process.  First we normalize */
comment|/* based on the [min,def,max] values for the axis to be [-1,0,1]. */
comment|/* Then, if there's an `avar' table, we renormalize this range.   */
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|normalized
argument_list|,
name|mmvar
operator|->
name|num_axis
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|FT_TRACE5
argument_list|(
operator|(
literal|"design coordinates:\n"
operator|)
argument_list|)
expr_stmt|;
name|a
operator|=
name|mmvar
operator|->
name|axis
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_coords
condition|;
name|i
operator|++
operator|,
name|a
operator|++
control|)
block|{
name|FT_TRACE5
argument_list|(
operator|(
literal|"  %.4f\n"
operator|,
name|coords
index|[
name|i
index|]
operator|/
literal|65536.0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|coords
index|[
name|i
index|]
operator|>
name|a
operator|->
name|maximum
operator|||
name|coords
index|[
name|i
index|]
operator|<
name|a
operator|->
name|minimum
condition|)
block|{
name|FT_TRACE1
argument_list|(
operator|(
literal|"TT_Set_Var_Design: normalized design coordinate %.4f\n"
literal|"                   is out of range [%.4f;%.4f]\n"
operator|,
name|coords
index|[
name|i
index|]
operator|/
literal|65536.0
operator|,
name|a
operator|->
name|minimum
operator|/
literal|65536.0
operator|,
name|a
operator|->
name|maximum
operator|/
literal|65536.0
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Argument
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|coords
index|[
name|i
index|]
operator|<
name|a
operator|->
name|def
condition|)
name|normalized
index|[
name|i
index|]
operator|=
operator|-
name|FT_DivFix
argument_list|(
name|coords
index|[
name|i
index|]
operator|-
name|a
operator|->
name|def
argument_list|,
name|a
operator|->
name|minimum
operator|-
name|a
operator|->
name|def
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|a
operator|->
name|maximum
operator|==
name|a
operator|->
name|def
condition|)
name|normalized
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
else|else
name|normalized
index|[
name|i
index|]
operator|=
name|FT_DivFix
argument_list|(
name|coords
index|[
name|i
index|]
operator|-
name|a
operator|->
name|def
argument_list|,
name|a
operator|->
name|maximum
operator|-
name|a
operator|->
name|def
argument_list|)
expr_stmt|;
block|}
name|FT_TRACE5
argument_list|(
operator|(
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|mmvar
operator|->
name|num_axis
condition|;
name|i
operator|++
control|)
name|normalized
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|blend
operator|->
name|avar_checked
condition|)
name|ft_var_load_avar
argument_list|(
name|face
argument_list|)
expr_stmt|;
if|if
condition|(
name|blend
operator|->
name|avar_segment
operator|!=
name|NULL
condition|)
block|{
name|FT_TRACE5
argument_list|(
operator|(
literal|"normalized design coordinates"
literal|" before applying `avar' data:\n"
operator|)
argument_list|)
expr_stmt|;
name|av
operator|=
name|blend
operator|->
name|avar_segment
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mmvar
operator|->
name|num_axis
condition|;
name|i
operator|++
operator|,
name|av
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
operator|(
name|FT_UInt
operator|)
name|av
operator|->
name|pairCount
condition|;
name|j
operator|++
control|)
block|{
name|FT_TRACE5
argument_list|(
operator|(
literal|"  %.4f\n"
operator|,
name|normalized
index|[
name|i
index|]
operator|/
literal|65536.0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|normalized
index|[
name|i
index|]
operator|<
name|av
operator|->
name|correspondence
index|[
name|j
index|]
operator|.
name|fromCoord
condition|)
block|{
name|normalized
index|[
name|i
index|]
operator|=
name|FT_MulDiv
argument_list|(
name|normalized
index|[
name|i
index|]
operator|-
name|av
operator|->
name|correspondence
index|[
name|j
operator|-
literal|1
index|]
operator|.
name|fromCoord
argument_list|,
name|av
operator|->
name|correspondence
index|[
name|j
index|]
operator|.
name|toCoord
operator|-
name|av
operator|->
name|correspondence
index|[
name|j
operator|-
literal|1
index|]
operator|.
name|toCoord
argument_list|,
name|av
operator|->
name|correspondence
index|[
name|j
index|]
operator|.
name|fromCoord
operator|-
name|av
operator|->
name|correspondence
index|[
name|j
operator|-
literal|1
index|]
operator|.
name|fromCoord
argument_list|)
operator|+
name|av
operator|->
name|correspondence
index|[
name|j
operator|-
literal|1
index|]
operator|.
name|toCoord
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
name|error
operator|=
name|TT_Set_MM_Blend
argument_list|(
name|face
argument_list|,
name|mmvar
operator|->
name|num_axis
argument_list|,
name|normalized
argument_list|)
expr_stmt|;
name|Exit
label|:
name|FT_FREE
argument_list|(
name|normalized
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****                     GX VAR PARSING ROUTINES                   *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    tt_face_vary_cvt                                                   */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Modify the loaded cvt table according to the `cvar' table and the  */
end_comment
begin_comment
comment|/*    font's blend.                                                      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<InOut>                                                               */
end_comment
begin_comment
comment|/*    face   :: A handle to the target face object.                      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    stream :: A handle to the input stream.                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    FreeType error code.  0 means success.                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    Most errors are ignored.  It is perfectly valid not to have a      */
end_comment
begin_comment
comment|/*    `cvar' table even if there is a `gvar' and `fvar' table.           */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|tt_face_vary_cvt
argument_list|(
argument|TT_Face    face
argument_list|,
argument|FT_Stream  stream
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|stream
operator|->
name|memory
decl_stmt|;
name|FT_ULong
name|table_start
decl_stmt|;
name|FT_ULong
name|table_len
decl_stmt|;
name|FT_UInt
name|tupleCount
decl_stmt|;
name|FT_ULong
name|offsetToData
decl_stmt|;
name|FT_ULong
name|here
decl_stmt|;
name|FT_UInt
name|i
decl_stmt|,
name|j
decl_stmt|;
name|FT_Fixed
modifier|*
name|tuple_coords
init|=
name|NULL
decl_stmt|;
name|FT_Fixed
modifier|*
name|im_start_coords
init|=
name|NULL
decl_stmt|;
name|FT_Fixed
modifier|*
name|im_end_coords
init|=
name|NULL
decl_stmt|;
name|GX_Blend
name|blend
init|=
name|face
operator|->
name|blend
decl_stmt|;
name|FT_UInt
name|point_count
decl_stmt|;
name|FT_UShort
modifier|*
name|localpoints
decl_stmt|;
name|FT_Short
modifier|*
name|deltas
decl_stmt|;
name|FT_TRACE2
argument_list|(
operator|(
literal|"CVAR "
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|blend
operator|==
name|NULL
condition|)
block|{
name|FT_TRACE2
argument_list|(
operator|(
literal|"\n"
literal|"tt_face_vary_cvt: no blend specified\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|FT_Err_Ok
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|face
operator|->
name|cvt
operator|==
name|NULL
condition|)
block|{
name|FT_TRACE2
argument_list|(
operator|(
literal|"\n"
literal|"tt_face_vary_cvt: no `cvt ' table\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|FT_Err_Ok
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|error
operator|=
name|face
operator|->
name|goto_table
argument_list|(
name|face
argument_list|,
name|TTAG_cvar
argument_list|,
name|stream
argument_list|,
operator|&
name|table_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|FT_TRACE2
argument_list|(
operator|(
literal|"is missing\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|FT_Err_Ok
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|FT_FRAME_ENTER
argument_list|(
name|table_len
argument_list|)
condition|)
block|{
name|error
operator|=
name|FT_Err_Ok
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|table_start
operator|=
name|FT_Stream_FTell
argument_list|(
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|FT_GET_LONG
argument_list|()
operator|!=
literal|0x00010000L
condition|)
block|{
name|FT_TRACE2
argument_list|(
operator|(
literal|"bad table version\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|FT_Err_Ok
expr_stmt|;
goto|goto
name|FExit
goto|;
block|}
name|FT_TRACE2
argument_list|(
operator|(
literal|"loaded\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|tuple_coords
argument_list|,
name|blend
operator|->
name|num_axis
argument_list|)
operator|||
name|FT_NEW_ARRAY
argument_list|(
name|im_start_coords
argument_list|,
name|blend
operator|->
name|num_axis
argument_list|)
operator|||
name|FT_NEW_ARRAY
argument_list|(
name|im_end_coords
argument_list|,
name|blend
operator|->
name|num_axis
argument_list|)
condition|)
goto|goto
name|FExit
goto|;
name|tupleCount
operator|=
name|FT_GET_USHORT
argument_list|()
expr_stmt|;
name|offsetToData
operator|=
name|table_start
operator|+
name|FT_GET_USHORT
argument_list|()
expr_stmt|;
comment|/* The documentation implies there are flags packed into the        */
comment|/* tuplecount, but John Jenkins says that shared points don't apply */
comment|/* to `cvar', and no other flags are defined.                       */
name|FT_TRACE5
argument_list|(
operator|(
literal|"cvar: there are %d tuples:\n"
operator|,
name|tupleCount
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|tupleCount
operator|&
literal|0xFFF
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|FT_UInt
name|tupleDataSize
decl_stmt|;
name|FT_UInt
name|tupleIndex
decl_stmt|;
name|FT_Fixed
name|apply
decl_stmt|;
name|FT_TRACE6
argument_list|(
operator|(
literal|"  tuple %d:\n"
operator|,
name|i
operator|)
argument_list|)
expr_stmt|;
name|tupleDataSize
operator|=
name|FT_GET_USHORT
argument_list|()
expr_stmt|;
name|tupleIndex
operator|=
name|FT_GET_USHORT
argument_list|()
expr_stmt|;
comment|/* There is no provision here for a global tuple coordinate section, */
comment|/* so John says.  There are no tuple indices, just embedded tuples.  */
if|if
condition|(
name|tupleIndex
operator|&
name|GX_TI_EMBEDDED_TUPLE_COORD
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|blend
operator|->
name|num_axis
condition|;
name|j
operator|++
control|)
name|tuple_coords
index|[
name|j
index|]
operator|=
name|FT_GET_SHORT
argument_list|()
operator|*
literal|4
expr_stmt|;
comment|/* convert from        */
comment|/* short frac to fixed */
block|}
else|else
block|{
comment|/* skip this tuple; it makes no sense */
if|if
condition|(
name|tupleIndex
operator|&
name|GX_TI_INTERMEDIATE_TUPLE
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|2
operator|*
name|blend
operator|->
name|num_axis
condition|;
name|j
operator|++
control|)
operator|(
name|void
operator|)
name|FT_GET_SHORT
argument_list|()
expr_stmt|;
name|offsetToData
operator|+=
name|tupleDataSize
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|tupleIndex
operator|&
name|GX_TI_INTERMEDIATE_TUPLE
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|blend
operator|->
name|num_axis
condition|;
name|j
operator|++
control|)
name|im_start_coords
index|[
name|j
index|]
operator|=
name|FT_GET_SHORT
argument_list|()
operator|*
literal|4
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|blend
operator|->
name|num_axis
condition|;
name|j
operator|++
control|)
name|im_end_coords
index|[
name|j
index|]
operator|=
name|FT_GET_SHORT
argument_list|()
operator|*
literal|4
expr_stmt|;
block|}
name|apply
operator|=
name|ft_var_apply_tuple
argument_list|(
name|blend
argument_list|,
operator|(
name|FT_UShort
operator|)
name|tupleIndex
argument_list|,
name|tuple_coords
argument_list|,
name|im_start_coords
argument_list|,
name|im_end_coords
argument_list|)
expr_stmt|;
if|if
condition|(
comment|/* tuple isn't active for our blend */
name|apply
operator|==
literal|0
operator|||
comment|/* global points not allowed,           */
comment|/* if they aren't local, makes no sense */
operator|!
operator|(
name|tupleIndex
operator|&
name|GX_TI_PRIVATE_POINT_NUMBERS
operator|)
condition|)
block|{
name|offsetToData
operator|+=
name|tupleDataSize
expr_stmt|;
continue|continue;
block|}
name|here
operator|=
name|FT_Stream_FTell
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|FT_Stream_SeekSet
argument_list|(
name|stream
argument_list|,
name|offsetToData
argument_list|)
expr_stmt|;
name|localpoints
operator|=
name|ft_var_readpackedpoints
argument_list|(
name|stream
argument_list|,
operator|&
name|point_count
argument_list|)
expr_stmt|;
name|deltas
operator|=
name|ft_var_readpackeddeltas
argument_list|(
name|stream
argument_list|,
name|point_count
operator|==
literal|0
condition|?
name|face
operator|->
name|cvt_size
else|:
name|point_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|localpoints
operator|==
name|NULL
operator|||
name|deltas
operator|==
name|NULL
condition|)
empty_stmt|;
comment|/* failure, ignore it */
elseif|else
if|if
condition|(
name|localpoints
operator|==
name|ALL_POINTS
condition|)
block|{
ifdef|#
directive|ifdef
name|FT_DEBUG_LEVEL_TRACE
name|int
name|count
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|FT_TRACE7
argument_list|(
operator|(
literal|"    CVT deltas:\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* this means that there are deltas for every entry in cvt */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|face
operator|->
name|cvt_size
condition|;
name|j
operator|++
control|)
block|{
name|FT_Long
name|orig_cvt
init|=
name|face
operator|->
name|cvt
index|[
name|j
index|]
decl_stmt|;
name|face
operator|->
name|cvt
index|[
name|j
index|]
operator|=
call|(
name|FT_Short
call|)
argument_list|(
name|orig_cvt
operator|+
name|FT_MulFix
argument_list|(
name|deltas
index|[
name|j
index|]
argument_list|,
name|apply
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FT_DEBUG_LEVEL_TRACE
if|if
condition|(
name|orig_cvt
operator|!=
name|face
operator|->
name|cvt
index|[
name|j
index|]
condition|)
block|{
name|FT_TRACE7
argument_list|(
operator|(
literal|"      %d: %d -> %d\n"
operator|,
name|j
operator|,
name|orig_cvt
operator|,
name|face
operator|->
name|cvt
index|[
name|j
index|]
operator|)
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|FT_DEBUG_LEVEL_TRACE
if|if
condition|(
operator|!
name|count
condition|)
name|FT_TRACE7
argument_list|(
operator|(
literal|"      none\n"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|FT_DEBUG_LEVEL_TRACE
name|int
name|count
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|FT_TRACE7
argument_list|(
operator|(
literal|"    CVT deltas:\n"
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|point_count
condition|;
name|j
operator|++
control|)
block|{
name|int
name|pindex
init|=
name|localpoints
index|[
name|j
index|]
decl_stmt|;
name|FT_Long
name|orig_cvt
init|=
name|face
operator|->
name|cvt
index|[
name|pindex
index|]
decl_stmt|;
name|face
operator|->
name|cvt
index|[
name|pindex
index|]
operator|=
call|(
name|FT_Short
call|)
argument_list|(
name|orig_cvt
operator|+
name|FT_MulFix
argument_list|(
name|deltas
index|[
name|j
index|]
argument_list|,
name|apply
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FT_DEBUG_LEVEL_TRACE
if|if
condition|(
name|orig_cvt
operator|!=
name|face
operator|->
name|cvt
index|[
name|pindex
index|]
condition|)
block|{
name|FT_TRACE7
argument_list|(
operator|(
literal|"      %d: %d -> %d\n"
operator|,
name|pindex
operator|,
name|orig_cvt
operator|,
name|face
operator|->
name|cvt
index|[
name|pindex
index|]
operator|)
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|FT_DEBUG_LEVEL_TRACE
if|if
condition|(
operator|!
name|count
condition|)
name|FT_TRACE7
argument_list|(
operator|(
literal|"      none\n"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|localpoints
operator|!=
name|ALL_POINTS
condition|)
name|FT_FREE
argument_list|(
name|localpoints
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|deltas
argument_list|)
expr_stmt|;
name|offsetToData
operator|+=
name|tupleDataSize
expr_stmt|;
name|FT_Stream_SeekSet
argument_list|(
name|stream
argument_list|,
name|here
argument_list|)
expr_stmt|;
block|}
name|FT_TRACE5
argument_list|(
operator|(
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
name|FExit
label|:
name|FT_FRAME_EXIT
argument_list|()
expr_stmt|;
name|Exit
label|:
name|FT_FREE
argument_list|(
name|tuple_coords
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|im_start_coords
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|im_end_coords
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/* Shift the original coordinates of all points between indices `p1' */
end_comment
begin_comment
comment|/* and `p2', using the same difference as given by index `ref'.      */
end_comment
begin_comment
comment|/* modeled after `af_iup_shift' */
end_comment
begin_function
specifier|static
name|void
DECL|function|tt_delta_shift
name|tt_delta_shift
parameter_list|(
name|int
name|p1
parameter_list|,
name|int
name|p2
parameter_list|,
name|int
name|ref
parameter_list|,
name|FT_Vector
modifier|*
name|in_points
parameter_list|,
name|FT_Vector
modifier|*
name|out_points
parameter_list|)
block|{
name|int
name|p
decl_stmt|;
name|FT_Vector
name|delta
decl_stmt|;
name|delta
operator|.
name|x
operator|=
name|out_points
index|[
name|ref
index|]
operator|.
name|x
operator|-
name|in_points
index|[
name|ref
index|]
operator|.
name|x
expr_stmt|;
name|delta
operator|.
name|y
operator|=
name|out_points
index|[
name|ref
index|]
operator|.
name|y
operator|-
name|in_points
index|[
name|ref
index|]
operator|.
name|y
expr_stmt|;
if|if
condition|(
name|delta
operator|.
name|x
operator|==
literal|0
operator|&&
name|delta
operator|.
name|y
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|p
operator|=
name|p1
init|;
name|p
operator|<
name|ref
condition|;
name|p
operator|++
control|)
block|{
name|out_points
index|[
name|p
index|]
operator|.
name|x
operator|+=
name|delta
operator|.
name|x
expr_stmt|;
name|out_points
index|[
name|p
index|]
operator|.
name|y
operator|+=
name|delta
operator|.
name|y
expr_stmt|;
block|}
for|for
control|(
name|p
operator|=
name|ref
operator|+
literal|1
init|;
name|p
operator|<=
name|p2
condition|;
name|p
operator|++
control|)
block|{
name|out_points
index|[
name|p
index|]
operator|.
name|x
operator|+=
name|delta
operator|.
name|x
expr_stmt|;
name|out_points
index|[
name|p
index|]
operator|.
name|y
operator|+=
name|delta
operator|.
name|y
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/* Interpolate the original coordinates of all points with indices */
end_comment
begin_comment
comment|/* between `p1' and `p2', using `ref1' and `ref2' as the reference */
end_comment
begin_comment
comment|/* point indices.                                                  */
end_comment
begin_comment
comment|/* modeled after `af_iup_interp', `_iup_worker_interpolate', and */
end_comment
begin_comment
comment|/* `Ins_IUP'                                                     */
end_comment
begin_function
specifier|static
name|void
DECL|function|tt_delta_interpolate
name|tt_delta_interpolate
parameter_list|(
name|int
name|p1
parameter_list|,
name|int
name|p2
parameter_list|,
name|int
name|ref1
parameter_list|,
name|int
name|ref2
parameter_list|,
name|FT_Vector
modifier|*
name|in_points
parameter_list|,
name|FT_Vector
modifier|*
name|out_points
parameter_list|)
block|{
name|int
name|p
decl_stmt|,
name|i
decl_stmt|;
name|FT_Pos
name|out
decl_stmt|,
name|in1
decl_stmt|,
name|in2
decl_stmt|,
name|out1
decl_stmt|,
name|out2
decl_stmt|,
name|d1
decl_stmt|,
name|d2
decl_stmt|;
if|if
condition|(
name|p1
operator|>
name|p2
condition|)
return|return;
comment|/* handle both horizontal and vertical coordinates */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
literal|1
condition|;
name|i
operator|++
control|)
block|{
comment|/* shift array pointers so that we can access `foo.y' as `foo.x' */
name|in_points
operator|=
operator|(
name|FT_Vector
operator|*
operator|)
operator|(
operator|(
name|FT_Pos
operator|*
operator|)
name|in_points
operator|+
name|i
operator|)
expr_stmt|;
name|out_points
operator|=
operator|(
name|FT_Vector
operator|*
operator|)
operator|(
operator|(
name|FT_Pos
operator|*
operator|)
name|out_points
operator|+
name|i
operator|)
expr_stmt|;
if|if
condition|(
name|in_points
index|[
name|ref1
index|]
operator|.
name|x
operator|>
name|in_points
index|[
name|ref2
index|]
operator|.
name|x
condition|)
block|{
name|p
operator|=
name|ref1
expr_stmt|;
name|ref1
operator|=
name|ref2
expr_stmt|;
name|ref2
operator|=
name|p
expr_stmt|;
block|}
name|in1
operator|=
name|in_points
index|[
name|ref1
index|]
operator|.
name|x
expr_stmt|;
name|in2
operator|=
name|in_points
index|[
name|ref2
index|]
operator|.
name|x
expr_stmt|;
name|out1
operator|=
name|out_points
index|[
name|ref1
index|]
operator|.
name|x
expr_stmt|;
name|out2
operator|=
name|out_points
index|[
name|ref2
index|]
operator|.
name|x
expr_stmt|;
name|d1
operator|=
name|out1
operator|-
name|in1
expr_stmt|;
name|d2
operator|=
name|out2
operator|-
name|in2
expr_stmt|;
if|if
condition|(
name|out1
operator|==
name|out2
operator|||
name|in1
operator|==
name|in2
condition|)
block|{
for|for
control|(
name|p
operator|=
name|p1
init|;
name|p
operator|<=
name|p2
condition|;
name|p
operator|++
control|)
block|{
name|out
operator|=
name|in_points
index|[
name|p
index|]
operator|.
name|x
expr_stmt|;
if|if
condition|(
name|out
operator|<=
name|in1
condition|)
name|out
operator|+=
name|d1
expr_stmt|;
elseif|else
if|if
condition|(
name|out
operator|>=
name|in2
condition|)
name|out
operator|+=
name|d2
expr_stmt|;
else|else
name|out
operator|=
name|out1
expr_stmt|;
name|out_points
index|[
name|p
index|]
operator|.
name|x
operator|=
name|out
expr_stmt|;
block|}
block|}
else|else
block|{
name|FT_Fixed
name|scale
init|=
name|FT_DivFix
argument_list|(
name|out2
operator|-
name|out1
argument_list|,
name|in2
operator|-
name|in1
argument_list|)
decl_stmt|;
for|for
control|(
name|p
operator|=
name|p1
init|;
name|p
operator|<=
name|p2
condition|;
name|p
operator|++
control|)
block|{
name|out
operator|=
name|in_points
index|[
name|p
index|]
operator|.
name|x
expr_stmt|;
if|if
condition|(
name|out
operator|<=
name|in1
condition|)
name|out
operator|+=
name|d1
expr_stmt|;
elseif|else
if|if
condition|(
name|out
operator|>=
name|in2
condition|)
name|out
operator|+=
name|d2
expr_stmt|;
else|else
name|out
operator|=
name|out1
operator|+
name|FT_MulFix
argument_list|(
name|out
operator|-
name|in1
argument_list|,
name|scale
argument_list|)
expr_stmt|;
name|out_points
index|[
name|p
index|]
operator|.
name|x
operator|=
name|out
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_comment
comment|/* Interpolate points without delta values, similar to */
end_comment
begin_comment
comment|/* the `IUP' hinting instruction.                      */
end_comment
begin_comment
comment|/* modeled after `Ins_IUP */
end_comment
begin_function
specifier|static
name|void
DECL|function|tt_handle_deltas
name|tt_handle_deltas
parameter_list|(
name|FT_Outline
modifier|*
name|outline
parameter_list|,
name|FT_Vector
modifier|*
name|in_points
parameter_list|,
name|FT_Bool
modifier|*
name|has_delta
parameter_list|)
block|{
name|FT_Vector
modifier|*
name|out_points
decl_stmt|;
name|FT_Int
name|first_point
decl_stmt|;
name|FT_Int
name|end_point
decl_stmt|;
name|FT_Int
name|first_delta
decl_stmt|;
name|FT_Int
name|cur_delta
decl_stmt|;
name|FT_Int
name|point
decl_stmt|;
name|FT_Short
name|contour
decl_stmt|;
comment|/* ignore empty outlines */
if|if
condition|(
operator|!
name|outline
operator|->
name|n_contours
condition|)
return|return;
name|out_points
operator|=
name|outline
operator|->
name|points
expr_stmt|;
name|contour
operator|=
literal|0
expr_stmt|;
name|point
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|end_point
operator|=
name|outline
operator|->
name|contours
index|[
name|contour
index|]
expr_stmt|;
name|first_point
operator|=
name|point
expr_stmt|;
comment|/* search first point that has a delta */
while|while
condition|(
name|point
operator|<=
name|end_point
operator|&&
operator|!
name|has_delta
index|[
name|point
index|]
condition|)
name|point
operator|++
expr_stmt|;
if|if
condition|(
name|point
operator|<=
name|end_point
condition|)
block|{
name|first_delta
operator|=
name|point
expr_stmt|;
name|cur_delta
operator|=
name|point
expr_stmt|;
name|point
operator|++
expr_stmt|;
while|while
condition|(
name|point
operator|<=
name|end_point
condition|)
block|{
comment|/* search next point that has a delta  */
comment|/* and interpolate intermediate points */
if|if
condition|(
name|has_delta
index|[
name|point
index|]
condition|)
block|{
name|tt_delta_interpolate
argument_list|(
name|cur_delta
operator|+
literal|1
argument_list|,
name|point
operator|-
literal|1
argument_list|,
name|cur_delta
argument_list|,
name|point
argument_list|,
name|in_points
argument_list|,
name|out_points
argument_list|)
expr_stmt|;
name|cur_delta
operator|=
name|point
expr_stmt|;
block|}
name|point
operator|++
expr_stmt|;
block|}
comment|/* shift contour if we only have a single delta */
if|if
condition|(
name|cur_delta
operator|==
name|first_delta
condition|)
name|tt_delta_shift
argument_list|(
name|first_point
argument_list|,
name|end_point
argument_list|,
name|cur_delta
argument_list|,
name|in_points
argument_list|,
name|out_points
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* otherwise handle remaining points       */
comment|/* at the end and beginning of the contour */
name|tt_delta_interpolate
argument_list|(
name|cur_delta
operator|+
literal|1
argument_list|,
name|end_point
argument_list|,
name|cur_delta
argument_list|,
name|first_delta
argument_list|,
name|in_points
argument_list|,
name|out_points
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_delta
operator|>
literal|0
condition|)
name|tt_delta_interpolate
argument_list|(
name|first_point
argument_list|,
name|first_delta
operator|-
literal|1
argument_list|,
name|cur_delta
argument_list|,
name|first_delta
argument_list|,
name|in_points
argument_list|,
name|out_points
argument_list|)
expr_stmt|;
block|}
block|}
name|contour
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|contour
operator|<
name|outline
operator|->
name|n_contours
condition|)
do|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    TT_Vary_Apply_Glyph_Deltas                                         */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Apply the appropriate deltas to the current glyph.                 */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    face        :: A handle to the target face object.                 */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    glyph_index :: The index of the glyph being modified.              */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    n_points    :: The number of the points in the glyph, including    */
end_comment
begin_comment
comment|/*                   phantom points.                                     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<InOut>                                                               */
end_comment
begin_comment
comment|/*    outline     :: The outline to change.                              */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    FreeType error code.  0 means success.                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|TT_Vary_Apply_Glyph_Deltas
argument_list|(
argument|TT_Face      face
argument_list|,
argument|FT_UInt      glyph_index
argument_list|,
argument|FT_Outline*  outline
argument_list|,
argument|FT_UInt      n_points
argument_list|)
end_macro
begin_block
block|{
name|FT_Stream
name|stream
init|=
name|face
operator|->
name|root
operator|.
name|stream
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|stream
operator|->
name|memory
decl_stmt|;
name|GX_Blend
name|blend
init|=
name|face
operator|->
name|blend
decl_stmt|;
name|FT_Vector
modifier|*
name|points_org
init|=
name|NULL
decl_stmt|;
name|FT_Bool
modifier|*
name|has_delta
init|=
name|NULL
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|FT_ULong
name|glyph_start
decl_stmt|;
name|FT_UInt
name|tupleCount
decl_stmt|;
name|FT_ULong
name|offsetToData
decl_stmt|;
name|FT_ULong
name|here
decl_stmt|;
name|FT_UInt
name|i
decl_stmt|,
name|j
decl_stmt|;
name|FT_Fixed
modifier|*
name|tuple_coords
init|=
name|NULL
decl_stmt|;
name|FT_Fixed
modifier|*
name|im_start_coords
init|=
name|NULL
decl_stmt|;
name|FT_Fixed
modifier|*
name|im_end_coords
init|=
name|NULL
decl_stmt|;
name|FT_UInt
name|point_count
decl_stmt|,
name|spoint_count
init|=
literal|0
decl_stmt|;
name|FT_UShort
modifier|*
name|sharedpoints
init|=
name|NULL
decl_stmt|;
name|FT_UShort
modifier|*
name|localpoints
init|=
name|NULL
decl_stmt|;
name|FT_UShort
modifier|*
name|points
decl_stmt|;
name|FT_Short
modifier|*
name|deltas_x
decl_stmt|,
modifier|*
name|deltas_y
decl_stmt|;
if|if
condition|(
operator|!
name|face
operator|->
name|doblend
operator|||
name|blend
operator|==
name|NULL
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_Argument
argument_list|)
return|;
if|if
condition|(
name|glyph_index
operator|>=
name|blend
operator|->
name|gv_glyphcnt
operator|||
name|blend
operator|->
name|glyphoffsets
index|[
name|glyph_index
index|]
operator|==
name|blend
operator|->
name|glyphoffsets
index|[
name|glyph_index
operator|+
literal|1
index|]
condition|)
block|{
name|FT_TRACE2
argument_list|(
operator|(
literal|"TT_Vary_Apply_Glyph_Deltas:"
literal|" no variation data for this glyph\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|FT_Err_Ok
return|;
block|}
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|points_org
argument_list|,
name|n_points
argument_list|)
operator|||
name|FT_NEW_ARRAY
argument_list|(
name|has_delta
argument_list|,
name|n_points
argument_list|)
condition|)
goto|goto
name|Fail1
goto|;
if|if
condition|(
name|FT_STREAM_SEEK
argument_list|(
name|blend
operator|->
name|glyphoffsets
index|[
name|glyph_index
index|]
argument_list|)
operator|||
name|FT_FRAME_ENTER
argument_list|(
name|blend
operator|->
name|glyphoffsets
index|[
name|glyph_index
operator|+
literal|1
index|]
operator|-
name|blend
operator|->
name|glyphoffsets
index|[
name|glyph_index
index|]
argument_list|)
condition|)
goto|goto
name|Fail1
goto|;
name|glyph_start
operator|=
name|FT_Stream_FTell
argument_list|(
name|stream
argument_list|)
expr_stmt|;
comment|/* each set of glyph variation data is formatted similarly to `cvar' */
comment|/* (except we get shared points and global tuples)                   */
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|tuple_coords
argument_list|,
name|blend
operator|->
name|num_axis
argument_list|)
operator|||
name|FT_NEW_ARRAY
argument_list|(
name|im_start_coords
argument_list|,
name|blend
operator|->
name|num_axis
argument_list|)
operator|||
name|FT_NEW_ARRAY
argument_list|(
name|im_end_coords
argument_list|,
name|blend
operator|->
name|num_axis
argument_list|)
condition|)
goto|goto
name|Fail2
goto|;
name|tupleCount
operator|=
name|FT_GET_USHORT
argument_list|()
expr_stmt|;
name|offsetToData
operator|=
name|glyph_start
operator|+
name|FT_GET_USHORT
argument_list|()
expr_stmt|;
if|if
condition|(
name|tupleCount
operator|&
name|GX_TC_TUPLES_SHARE_POINT_NUMBERS
condition|)
block|{
name|here
operator|=
name|FT_Stream_FTell
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|FT_Stream_SeekSet
argument_list|(
name|stream
argument_list|,
name|offsetToData
argument_list|)
expr_stmt|;
name|sharedpoints
operator|=
name|ft_var_readpackedpoints
argument_list|(
name|stream
argument_list|,
operator|&
name|spoint_count
argument_list|)
expr_stmt|;
name|offsetToData
operator|=
name|FT_Stream_FTell
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|FT_Stream_SeekSet
argument_list|(
name|stream
argument_list|,
name|here
argument_list|)
expr_stmt|;
block|}
name|FT_TRACE5
argument_list|(
operator|(
literal|"gvar: there are %d tuples:\n"
operator|,
name|tupleCount
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|tupleCount
operator|&
name|GX_TC_TUPLE_COUNT_MASK
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|FT_UInt
name|tupleDataSize
decl_stmt|;
name|FT_UInt
name|tupleIndex
decl_stmt|;
name|FT_Fixed
name|apply
decl_stmt|;
name|FT_TRACE6
argument_list|(
operator|(
literal|"  tuple %d:\n"
operator|,
name|i
operator|)
argument_list|)
expr_stmt|;
name|tupleDataSize
operator|=
name|FT_GET_USHORT
argument_list|()
expr_stmt|;
name|tupleIndex
operator|=
name|FT_GET_USHORT
argument_list|()
expr_stmt|;
if|if
condition|(
name|tupleIndex
operator|&
name|GX_TI_EMBEDDED_TUPLE_COORD
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|blend
operator|->
name|num_axis
condition|;
name|j
operator|++
control|)
name|tuple_coords
index|[
name|j
index|]
operator|=
name|FT_GET_SHORT
argument_list|()
operator|*
literal|4
expr_stmt|;
comment|/* convert from        */
comment|/* short frac to fixed */
block|}
elseif|else
if|if
condition|(
operator|(
name|tupleIndex
operator|&
name|GX_TI_TUPLE_INDEX_MASK
operator|)
operator|>=
name|blend
operator|->
name|tuplecount
condition|)
block|{
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Table
argument_list|)
expr_stmt|;
goto|goto
name|Fail2
goto|;
block|}
else|else
name|FT_MEM_COPY
argument_list|(
name|tuple_coords
argument_list|,
operator|&
name|blend
operator|->
name|tuplecoords
index|[
operator|(
name|tupleIndex
operator|&
literal|0xFFF
operator|)
operator|*
name|blend
operator|->
name|num_axis
index|]
argument_list|,
name|blend
operator|->
name|num_axis
operator|*
sizeof|sizeof
argument_list|(
name|FT_Fixed
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tupleIndex
operator|&
name|GX_TI_INTERMEDIATE_TUPLE
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|blend
operator|->
name|num_axis
condition|;
name|j
operator|++
control|)
name|im_start_coords
index|[
name|j
index|]
operator|=
name|FT_GET_SHORT
argument_list|()
operator|*
literal|4
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|blend
operator|->
name|num_axis
condition|;
name|j
operator|++
control|)
name|im_end_coords
index|[
name|j
index|]
operator|=
name|FT_GET_SHORT
argument_list|()
operator|*
literal|4
expr_stmt|;
block|}
name|apply
operator|=
name|ft_var_apply_tuple
argument_list|(
name|blend
argument_list|,
operator|(
name|FT_UShort
operator|)
name|tupleIndex
argument_list|,
name|tuple_coords
argument_list|,
name|im_start_coords
argument_list|,
name|im_end_coords
argument_list|)
expr_stmt|;
if|if
condition|(
name|apply
operator|==
literal|0
condition|)
comment|/* tuple isn't active for our blend */
block|{
name|offsetToData
operator|+=
name|tupleDataSize
expr_stmt|;
continue|continue;
block|}
name|here
operator|=
name|FT_Stream_FTell
argument_list|(
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|tupleIndex
operator|&
name|GX_TI_PRIVATE_POINT_NUMBERS
condition|)
block|{
name|FT_Stream_SeekSet
argument_list|(
name|stream
argument_list|,
name|offsetToData
argument_list|)
expr_stmt|;
name|localpoints
operator|=
name|ft_var_readpackedpoints
argument_list|(
name|stream
argument_list|,
operator|&
name|point_count
argument_list|)
expr_stmt|;
name|points
operator|=
name|localpoints
expr_stmt|;
block|}
else|else
block|{
name|points
operator|=
name|sharedpoints
expr_stmt|;
name|point_count
operator|=
name|spoint_count
expr_stmt|;
block|}
name|deltas_x
operator|=
name|ft_var_readpackeddeltas
argument_list|(
name|stream
argument_list|,
name|point_count
operator|==
literal|0
condition|?
name|n_points
else|:
name|point_count
argument_list|)
expr_stmt|;
name|deltas_y
operator|=
name|ft_var_readpackeddeltas
argument_list|(
name|stream
argument_list|,
name|point_count
operator|==
literal|0
condition|?
name|n_points
else|:
name|point_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|points
operator|==
name|NULL
operator|||
name|deltas_y
operator|==
name|NULL
operator|||
name|deltas_x
operator|==
name|NULL
condition|)
empty_stmt|;
comment|/* failure, ignore it */
elseif|else
if|if
condition|(
name|points
operator|==
name|ALL_POINTS
condition|)
block|{
ifdef|#
directive|ifdef
name|FT_DEBUG_LEVEL_TRACE
name|int
name|count
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|FT_TRACE7
argument_list|(
operator|(
literal|"    point deltas:\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* this means that there are deltas for every point in the glyph */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_points
condition|;
name|j
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|FT_DEBUG_LEVEL_TRACE
name|FT_Vector
name|point_org
init|=
name|outline
operator|->
name|points
index|[
name|j
index|]
decl_stmt|;
endif|#
directive|endif
name|outline
operator|->
name|points
index|[
name|j
index|]
operator|.
name|x
operator|+=
name|FT_MulFix
argument_list|(
name|deltas_x
index|[
name|j
index|]
argument_list|,
name|apply
argument_list|)
expr_stmt|;
name|outline
operator|->
name|points
index|[
name|j
index|]
operator|.
name|y
operator|+=
name|FT_MulFix
argument_list|(
name|deltas_y
index|[
name|j
index|]
argument_list|,
name|apply
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FT_DEBUG_LEVEL_TRACE
if|if
condition|(
operator|(
name|point_org
operator|.
name|x
operator|!=
name|outline
operator|->
name|points
index|[
name|j
index|]
operator|.
name|x
operator|)
operator|||
operator|(
name|point_org
operator|.
name|y
operator|!=
name|outline
operator|->
name|points
index|[
name|j
index|]
operator|.
name|y
operator|)
condition|)
block|{
name|FT_TRACE7
argument_list|(
operator|(
literal|"      %d: (%d, %d) -> (%d, %d)\n"
operator|,
name|j
operator|,
name|point_org
operator|.
name|x
operator|,
name|point_org
operator|.
name|y
operator|,
name|outline
operator|->
name|points
index|[
name|j
index|]
operator|.
name|x
operator|,
name|outline
operator|->
name|points
index|[
name|j
index|]
operator|.
name|y
operator|)
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|FT_DEBUG_LEVEL_TRACE
if|if
condition|(
operator|!
name|count
condition|)
name|FT_TRACE7
argument_list|(
operator|(
literal|"      none\n"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|FT_DEBUG_LEVEL_TRACE
name|int
name|count
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
comment|/* we have to interpolate the missing deltas similar to the */
comment|/* IUP bytecode instruction                                 */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_points
condition|;
name|j
operator|++
control|)
block|{
name|points_org
index|[
name|j
index|]
operator|=
name|outline
operator|->
name|points
index|[
name|j
index|]
expr_stmt|;
name|has_delta
index|[
name|j
index|]
operator|=
name|FALSE
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|point_count
condition|;
name|j
operator|++
control|)
block|{
name|FT_UShort
name|idx
init|=
name|localpoints
index|[
name|j
index|]
decl_stmt|;
if|if
condition|(
name|idx
operator|>=
name|n_points
condition|)
continue|continue;
name|has_delta
index|[
name|idx
index|]
operator|=
name|TRUE
expr_stmt|;
name|outline
operator|->
name|points
index|[
name|idx
index|]
operator|.
name|x
operator|+=
name|FT_MulFix
argument_list|(
name|deltas_x
index|[
name|j
index|]
argument_list|,
name|apply
argument_list|)
expr_stmt|;
name|outline
operator|->
name|points
index|[
name|idx
index|]
operator|.
name|y
operator|+=
name|FT_MulFix
argument_list|(
name|deltas_y
index|[
name|j
index|]
argument_list|,
name|apply
argument_list|)
expr_stmt|;
block|}
comment|/* no need to handle phantom points here,      */
comment|/* since solitary points can't be interpolated */
name|tt_handle_deltas
argument_list|(
name|outline
argument_list|,
name|points_org
argument_list|,
name|has_delta
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FT_DEBUG_LEVEL_TRACE
name|FT_TRACE7
argument_list|(
operator|(
literal|"    point deltas:\n"
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_points
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|points_org
index|[
name|j
index|]
operator|.
name|x
operator|!=
name|outline
operator|->
name|points
index|[
name|j
index|]
operator|.
name|x
operator|)
operator|||
operator|(
name|points_org
index|[
name|j
index|]
operator|.
name|y
operator|!=
name|outline
operator|->
name|points
index|[
name|j
index|]
operator|.
name|y
operator|)
condition|)
block|{
name|FT_TRACE7
argument_list|(
operator|(
literal|"      %d: (%d, %d) -> (%d, %d)\n"
operator|,
name|j
operator|,
name|points_org
index|[
name|j
index|]
operator|.
name|x
operator|,
name|points_org
index|[
name|j
index|]
operator|.
name|y
operator|,
name|outline
operator|->
name|points
index|[
name|j
index|]
operator|.
name|x
operator|,
name|outline
operator|->
name|points
index|[
name|j
index|]
operator|.
name|y
operator|)
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|count
condition|)
name|FT_TRACE7
argument_list|(
operator|(
literal|"      none\n"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|localpoints
operator|!=
name|ALL_POINTS
condition|)
name|FT_FREE
argument_list|(
name|localpoints
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|deltas_x
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|deltas_y
argument_list|)
expr_stmt|;
name|offsetToData
operator|+=
name|tupleDataSize
expr_stmt|;
name|FT_Stream_SeekSet
argument_list|(
name|stream
argument_list|,
name|here
argument_list|)
expr_stmt|;
block|}
name|FT_TRACE5
argument_list|(
operator|(
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
name|Fail2
label|:
name|FT_FREE
argument_list|(
name|tuple_coords
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|im_start_coords
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|im_end_coords
argument_list|)
expr_stmt|;
name|FT_FRAME_EXIT
argument_list|()
expr_stmt|;
name|Fail1
label|:
name|FT_FREE
argument_list|(
name|points_org
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|has_delta
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    tt_done_blend                                                      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Free the blend internal data structure.                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|tt_done_blend
name|tt_done_blend
argument_list|(
argument|FT_Memory  memory
argument_list|,
argument|GX_Blend   blend
argument_list|)
end_macro
begin_block
block|{
if|if
condition|(
name|blend
operator|!=
name|NULL
condition|)
block|{
name|FT_UInt
name|i
decl_stmt|;
name|FT_FREE
argument_list|(
name|blend
operator|->
name|normalizedcoords
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|blend
operator|->
name|mmvar
argument_list|)
expr_stmt|;
if|if
condition|(
name|blend
operator|->
name|avar_segment
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|blend
operator|->
name|num_axis
condition|;
name|i
operator|++
control|)
name|FT_FREE
argument_list|(
name|blend
operator|->
name|avar_segment
index|[
name|i
index|]
operator|.
name|correspondence
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|blend
operator|->
name|avar_segment
argument_list|)
expr_stmt|;
block|}
name|FT_FREE
argument_list|(
name|blend
operator|->
name|tuplecoords
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|blend
operator|->
name|glyphoffsets
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|blend
argument_list|)
expr_stmt|;
block|}
block|}
end_block
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* TT_CONFIG_OPTION_GX_VAR_SUPPORT */
end_comment
begin_comment
comment|/* END */
end_comment
end_unit
