begin_unit
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  ttgxvar.c                                                              */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*    TrueType GX Font Variation loader                                    */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  Copyright 2004, 2005, 2006, 2007, 2008 by                              */
end_comment
begin_comment
comment|/*  David Turner, Robert Wilhelm, Werner Lemberg, and George Williams.     */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  This file is part of the FreeType project, and may only be used,       */
end_comment
begin_comment
comment|/*  modified, and distributed under the terms of the FreeType project      */
end_comment
begin_comment
comment|/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
end_comment
begin_comment
comment|/*  this file you indicate that you have read the license and              */
end_comment
begin_comment
comment|/*  understand and accept it fully.                                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/* Apple documents the `fvar', `gvar', `cvar', and `avar' tables at        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*   http://developer.apple.com/fonts/TTRefMan/RM06/Chap6[fgca]var.html    */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/* The documentation for `fvar' is inconsistent.  At one point it says     */
end_comment
begin_comment
comment|/* that `countSizePairs' should be 3, at another point 2.  It should be 2. */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/* The documentation for `gvar' is not intelligible; `cvar' refers you to  */
end_comment
begin_comment
comment|/* `gvar' and is thus also incomprehensible.                               */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/* The documentation for `avar' appears correct, but Apple has no fonts    */
end_comment
begin_comment
comment|/* with an `avar' table, so it is hard to test.                            */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/* Many thanks to John Jenkins (at Apple) in figuring this out.            */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/* Apple's `kern' table has some references to tuple indices, but as there */
end_comment
begin_comment
comment|/* is no indication where these indices are defined, nor how to            */
end_comment
begin_comment
comment|/* interpolate the kerning values (different tuples have different         */
end_comment
begin_comment
comment|/* classes) this issue is ignored.                                         */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<ft2build.h>
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_DEBUG_H
end_include
begin_include
include|#
directive|include
include|FT_CONFIG_CONFIG_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_STREAM_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_SFNT_H
end_include
begin_include
include|#
directive|include
include|FT_TRUETYPE_IDS_H
end_include
begin_include
include|#
directive|include
include|FT_TRUETYPE_TAGS_H
end_include
begin_include
include|#
directive|include
include|FT_MULTIPLE_MASTERS_H
end_include
begin_include
include|#
directive|include
file|"ttdriver.h"
end_include
begin_include
include|#
directive|include
file|"ttpload.h"
end_include
begin_include
include|#
directive|include
file|"ttgxvar.h"
end_include
begin_include
include|#
directive|include
file|"tterrors.h"
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_GX_VAR_SUPPORT
end_ifdef
begin_define
DECL|macro|FT_Stream_FTell
define|#
directive|define
name|FT_Stream_FTell
parameter_list|(
name|stream
parameter_list|)
define|\
value|( (stream)->cursor - (stream)->base )
end_define
begin_define
DECL|macro|FT_Stream_SeekSet
define|#
directive|define
name|FT_Stream_SeekSet
parameter_list|(
name|stream
parameter_list|,
name|off
parameter_list|)
define|\
value|( (stream)->cursor = (stream)->base+(off) )
end_define
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
end_comment
begin_comment
comment|/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
end_comment
begin_comment
comment|/* messages during execution.                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_undef
DECL|macro|FT_COMPONENT
undef|#
directive|undef
name|FT_COMPONENT
end_undef
begin_define
DECL|macro|FT_COMPONENT
define|#
directive|define
name|FT_COMPONENT
value|trace_ttgxvar
end_define
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****                       Internal Routines                       *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* The macro ALL_POINTS is used in `ft_var_readpackedpoints'.  It        */
end_comment
begin_comment
comment|/* indicates that there is a delta for every point without needing to    */
end_comment
begin_comment
comment|/* enumerate all of them.                                                */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_define
DECL|macro|ALL_POINTS
define|#
directive|define
name|ALL_POINTS
value|(FT_UShort*)( -1 )
end_define
begin_enum
enum|enum
block|{
DECL|enumerator|GX_PT_POINTS_ARE_WORDS
name|GX_PT_POINTS_ARE_WORDS
init|=
literal|0x80
block|,
DECL|enumerator|GX_PT_POINT_RUN_COUNT_MASK
name|GX_PT_POINT_RUN_COUNT_MASK
init|=
literal|0x7F
block|}
enum|;
end_enum
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    ft_var_readpackedpoints                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Read a set of points to which the following deltas will apply.     */
end_comment
begin_comment
comment|/*    Points are packed with a run length encoding.                      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    stream    :: The data stream.                                      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Output>                                                              */
end_comment
begin_comment
comment|/*    point_cnt :: The number of points read.  A zero value means that   */
end_comment
begin_comment
comment|/*                 all points in the glyph will be affected, without     */
end_comment
begin_comment
comment|/*                 enumerating them individually.                        */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    An array of FT_UShort containing the affected points or the        */
end_comment
begin_comment
comment|/*    special value ALL_POINTS.                                          */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|FT_UShort
modifier|*
DECL|function|ft_var_readpackedpoints
name|ft_var_readpackedpoints
parameter_list|(
name|FT_Stream
name|stream
parameter_list|,
name|FT_UInt
modifier|*
name|point_cnt
parameter_list|)
block|{
name|FT_UShort
modifier|*
name|points
decl_stmt|;
name|FT_Int
name|n
decl_stmt|;
name|FT_Int
name|runcnt
decl_stmt|;
name|FT_Int
name|i
decl_stmt|;
name|FT_Int
name|j
decl_stmt|;
name|FT_Int
name|first
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|stream
operator|->
name|memory
decl_stmt|;
name|FT_Error
name|error
init|=
name|TT_Err_Ok
decl_stmt|;
name|FT_UNUSED
argument_list|(
name|error
argument_list|)
expr_stmt|;
operator|*
name|point_cnt
operator|=
name|n
operator|=
name|FT_GET_BYTE
argument_list|()
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return
name|ALL_POINTS
return|;
if|if
condition|(
name|n
operator|&
name|GX_PT_POINTS_ARE_WORDS
condition|)
name|n
operator|=
name|FT_GET_BYTE
argument_list|()
operator||
operator|(
operator|(
name|n
operator|&
name|GX_PT_POINT_RUN_COUNT_MASK
operator|)
operator|<<
literal|8
operator|)
expr_stmt|;
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|points
argument_list|,
name|n
argument_list|)
condition|)
return|return
name|NULL
return|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|n
condition|)
block|{
name|runcnt
operator|=
name|FT_GET_BYTE
argument_list|()
expr_stmt|;
if|if
condition|(
name|runcnt
operator|&
name|GX_PT_POINTS_ARE_WORDS
condition|)
block|{
name|runcnt
operator|=
name|runcnt
operator|&
name|GX_PT_POINT_RUN_COUNT_MASK
expr_stmt|;
name|first
operator|=
name|points
index|[
name|i
operator|++
index|]
operator|=
name|FT_GET_USHORT
argument_list|()
expr_stmt|;
comment|/* first point not included in runcount */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|runcnt
condition|;
operator|++
name|j
control|)
name|points
index|[
name|i
operator|++
index|]
operator|=
call|(
name|FT_UShort
call|)
argument_list|(
name|first
operator|+=
name|FT_GET_USHORT
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|first
operator|=
name|points
index|[
name|i
operator|++
index|]
operator|=
name|FT_GET_BYTE
argument_list|()
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|runcnt
condition|;
operator|++
name|j
control|)
name|points
index|[
name|i
operator|++
index|]
operator|=
call|(
name|FT_UShort
call|)
argument_list|(
name|first
operator|+=
name|FT_GET_BYTE
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|points
return|;
block|}
end_function
begin_enum
enum|enum
block|{
DECL|enumerator|GX_DT_DELTAS_ARE_ZERO
name|GX_DT_DELTAS_ARE_ZERO
init|=
literal|0x80
block|,
DECL|enumerator|GX_DT_DELTAS_ARE_WORDS
name|GX_DT_DELTAS_ARE_WORDS
init|=
literal|0x40
block|,
DECL|enumerator|GX_DT_DELTA_RUN_COUNT_MASK
name|GX_DT_DELTA_RUN_COUNT_MASK
init|=
literal|0x3F
block|}
enum|;
end_enum
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    ft_var_readpackeddeltas                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Read a set of deltas.  These are packed slightly differently than  */
end_comment
begin_comment
comment|/*    points.  In particular there is no overall count.                  */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    stream    :: The data stream.                                      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    delta_cnt :: The number of to be read.                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    An array of FT_Short containing the deltas for the affected        */
end_comment
begin_comment
comment|/*    points.  (This only gets the deltas for one dimension.  It will    */
end_comment
begin_comment
comment|/*    generally be called twice, once for x, once for y.  When used in   */
end_comment
begin_comment
comment|/*    cvt table, it will only be called once.)                           */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|FT_Short
modifier|*
DECL|function|ft_var_readpackeddeltas
name|ft_var_readpackeddeltas
parameter_list|(
name|FT_Stream
name|stream
parameter_list|,
name|FT_Int
name|delta_cnt
parameter_list|)
block|{
name|FT_Short
modifier|*
name|deltas
decl_stmt|;
name|FT_Int
name|runcnt
decl_stmt|;
name|FT_Int
name|i
decl_stmt|;
name|FT_Int
name|j
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|stream
operator|->
name|memory
decl_stmt|;
name|FT_Error
name|error
init|=
name|TT_Err_Ok
decl_stmt|;
name|FT_UNUSED
argument_list|(
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|deltas
argument_list|,
name|delta_cnt
argument_list|)
condition|)
return|return
name|NULL
return|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|delta_cnt
condition|)
block|{
name|runcnt
operator|=
name|FT_GET_BYTE
argument_list|()
expr_stmt|;
if|if
condition|(
name|runcnt
operator|&
name|GX_DT_DELTAS_ARE_ZERO
condition|)
block|{
comment|/* runcnt zeroes get added */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
operator|(
name|runcnt
operator|&
name|GX_DT_DELTA_RUN_COUNT_MASK
operator|)
operator|&&
name|i
operator|<
name|delta_cnt
condition|;
operator|++
name|j
control|)
name|deltas
index|[
name|i
operator|++
index|]
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|runcnt
operator|&
name|GX_DT_DELTAS_ARE_WORDS
condition|)
block|{
comment|/* runcnt shorts from the stack */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
operator|(
name|runcnt
operator|&
name|GX_DT_DELTA_RUN_COUNT_MASK
operator|)
operator|&&
name|i
operator|<
name|delta_cnt
condition|;
operator|++
name|j
control|)
name|deltas
index|[
name|i
operator|++
index|]
operator|=
name|FT_GET_SHORT
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* runcnt signed bytes from the stack */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
operator|(
name|runcnt
operator|&
name|GX_DT_DELTA_RUN_COUNT_MASK
operator|)
operator|&&
name|i
operator|<
name|delta_cnt
condition|;
operator|++
name|j
control|)
name|deltas
index|[
name|i
operator|++
index|]
operator|=
name|FT_GET_CHAR
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|<=
operator|(
name|runcnt
operator|&
name|GX_DT_DELTA_RUN_COUNT_MASK
operator|)
condition|)
block|{
comment|/* Bad format */
name|FT_FREE
argument_list|(
name|deltas
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
return|return
name|deltas
return|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    ft_var_load_avar                                                   */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Parse the `avar' table if present.  It need not be, so we return   */
end_comment
begin_comment
comment|/*    nothing.                                                           */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<InOut>                                                               */
end_comment
begin_comment
comment|/*    face :: The font face.                                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|ft_var_load_avar
name|ft_var_load_avar
parameter_list|(
name|TT_Face
name|face
parameter_list|)
block|{
name|FT_Stream
name|stream
init|=
name|FT_FACE_STREAM
argument_list|(
name|face
argument_list|)
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|stream
operator|->
name|memory
decl_stmt|;
name|GX_Blend
name|blend
init|=
name|face
operator|->
name|blend
decl_stmt|;
name|GX_AVarSegment
name|segment
decl_stmt|;
name|FT_Error
name|error
init|=
name|TT_Err_Ok
decl_stmt|;
name|FT_ULong
name|version
decl_stmt|;
name|FT_Long
name|axisCount
decl_stmt|;
name|FT_Int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|FT_ULong
name|table_len
decl_stmt|;
name|FT_UNUSED
argument_list|(
name|error
argument_list|)
expr_stmt|;
name|blend
operator|->
name|avar_checked
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|face
operator|->
name|goto_table
argument_list|(
name|face
argument_list|,
name|TTAG_avar
argument_list|,
name|stream
argument_list|,
operator|&
name|table_len
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
name|FT_FRAME_ENTER
argument_list|(
name|table_len
argument_list|)
condition|)
return|return;
name|version
operator|=
name|FT_GET_LONG
argument_list|()
expr_stmt|;
name|axisCount
operator|=
name|FT_GET_LONG
argument_list|()
expr_stmt|;
if|if
condition|(
name|version
operator|!=
literal|0x00010000L
operator|||
name|axisCount
operator|!=
operator|(
name|FT_Long
operator|)
name|blend
operator|->
name|mmvar
operator|->
name|num_axis
condition|)
goto|goto
name|Exit
goto|;
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|blend
operator|->
name|avar_segment
argument_list|,
name|axisCount
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|segment
operator|=
operator|&
name|blend
operator|->
name|avar_segment
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|axisCount
condition|;
operator|++
name|i
operator|,
operator|++
name|segment
control|)
block|{
name|segment
operator|->
name|pairCount
operator|=
name|FT_GET_USHORT
argument_list|()
expr_stmt|;
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|segment
operator|->
name|correspondence
argument_list|,
name|segment
operator|->
name|pairCount
argument_list|)
condition|)
block|{
comment|/* Failure.  Free everything we have done so far.  We must do */
comment|/* it right now since loading the `avar' table is optional.   */
for|for
control|(
name|j
operator|=
name|i
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
operator|--
name|j
control|)
name|FT_FREE
argument_list|(
name|blend
operator|->
name|avar_segment
index|[
name|j
index|]
operator|.
name|correspondence
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|blend
operator|->
name|avar_segment
argument_list|)
expr_stmt|;
name|blend
operator|->
name|avar_segment
operator|=
name|NULL
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|segment
operator|->
name|pairCount
condition|;
operator|++
name|j
control|)
block|{
name|segment
operator|->
name|correspondence
index|[
name|j
index|]
operator|.
name|fromCoord
operator|=
name|FT_GET_SHORT
argument_list|()
operator|<<
literal|2
expr_stmt|;
comment|/* convert to Fixed */
name|segment
operator|->
name|correspondence
index|[
name|j
index|]
operator|.
name|toCoord
operator|=
name|FT_GET_SHORT
argument_list|()
operator|<<
literal|2
expr_stmt|;
comment|/* convert to Fixed */
block|}
block|}
name|Exit
label|:
name|FT_FRAME_EXIT
argument_list|()
expr_stmt|;
block|}
end_function
begin_typedef
DECL|struct|GX_GVar_Head_
typedef|typedef
struct|struct
name|GX_GVar_Head_
block|{
DECL|member|version
name|FT_Long
name|version
decl_stmt|;
DECL|member|axisCount
name|FT_UShort
name|axisCount
decl_stmt|;
DECL|member|globalCoordCount
name|FT_UShort
name|globalCoordCount
decl_stmt|;
DECL|member|offsetToCoord
name|FT_ULong
name|offsetToCoord
decl_stmt|;
DECL|member|glyphCount
name|FT_UShort
name|glyphCount
decl_stmt|;
DECL|member|flags
name|FT_UShort
name|flags
decl_stmt|;
DECL|member|offsetToData
name|FT_ULong
name|offsetToData
decl_stmt|;
block|}
DECL|typedef|GX_GVar_Head
name|GX_GVar_Head
typedef|;
end_typedef
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    ft_var_load_gvar                                                   */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Parses the `gvar' table if present.  If `fvar' is there, `gvar'    */
end_comment
begin_comment
comment|/*    had better be there too.                                           */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<InOut>                                                               */
end_comment
begin_comment
comment|/*    face :: The font face.                                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    FreeType error code.  0 means success.                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|ft_var_load_gvar
name|ft_var_load_gvar
parameter_list|(
name|TT_Face
name|face
parameter_list|)
block|{
name|FT_Stream
name|stream
init|=
name|FT_FACE_STREAM
argument_list|(
name|face
argument_list|)
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|stream
operator|->
name|memory
decl_stmt|;
name|GX_Blend
name|blend
init|=
name|face
operator|->
name|blend
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|FT_UInt
name|i
decl_stmt|,
name|j
decl_stmt|;
name|FT_ULong
name|table_len
decl_stmt|;
name|FT_ULong
name|gvar_start
decl_stmt|;
name|FT_ULong
name|offsetToData
decl_stmt|;
name|GX_GVar_Head
name|gvar_head
decl_stmt|;
specifier|static
specifier|const
name|FT_Frame_Field
name|gvar_fields
index|[]
init|=
block|{
DECL|macro|FT_STRUCTURE
undef|#
directive|undef
name|FT_STRUCTURE
DECL|macro|FT_STRUCTURE
define|#
directive|define
name|FT_STRUCTURE
value|GX_GVar_Head
name|FT_FRAME_START
argument_list|(
literal|20
argument_list|)
block|,
name|FT_FRAME_LONG
argument_list|(
name|version
argument_list|)
block|,
name|FT_FRAME_USHORT
argument_list|(
name|axisCount
argument_list|)
block|,
name|FT_FRAME_USHORT
argument_list|(
name|globalCoordCount
argument_list|)
block|,
name|FT_FRAME_ULONG
argument_list|(
name|offsetToCoord
argument_list|)
block|,
name|FT_FRAME_USHORT
argument_list|(
name|glyphCount
argument_list|)
block|,
name|FT_FRAME_USHORT
argument_list|(
name|flags
argument_list|)
block|,
name|FT_FRAME_ULONG
argument_list|(
name|offsetToData
argument_list|)
block|,
name|FT_FRAME_END
block|}
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|face
operator|->
name|goto_table
argument_list|(
name|face
argument_list|,
name|TTAG_gvar
argument_list|,
name|stream
argument_list|,
operator|&
name|table_len
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|Exit
goto|;
name|gvar_start
operator|=
name|FT_STREAM_POS
argument_list|( )
expr_stmt|;
if|if
condition|(
name|FT_STREAM_READ_FIELDS
argument_list|(
name|gvar_fields
argument_list|,
operator|&
name|gvar_head
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|blend
operator|->
name|tuplecount
operator|=
name|gvar_head
operator|.
name|globalCoordCount
expr_stmt|;
name|blend
operator|->
name|gv_glyphcnt
operator|=
name|gvar_head
operator|.
name|glyphCount
expr_stmt|;
name|offsetToData
operator|=
name|gvar_start
operator|+
name|gvar_head
operator|.
name|offsetToData
expr_stmt|;
if|if
condition|(
name|gvar_head
operator|.
name|version
operator|!=
operator|(
name|FT_Long
operator|)
literal|0x00010000L
operator|||
name|gvar_head
operator|.
name|axisCount
operator|!=
operator|(
name|FT_UShort
operator|)
name|blend
operator|->
name|mmvar
operator|->
name|num_axis
condition|)
block|{
name|error
operator|=
name|TT_Err_Invalid_Table
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|blend
operator|->
name|glyphoffsets
argument_list|,
name|blend
operator|->
name|gv_glyphcnt
operator|+
literal|1
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
if|if
condition|(
name|gvar_head
operator|.
name|flags
operator|&
literal|1
condition|)
block|{
comment|/* long offsets (one more offset than glyphs, to mark size of last) */
if|if
condition|(
name|FT_FRAME_ENTER
argument_list|(
operator|(
name|blend
operator|->
name|gv_glyphcnt
operator|+
literal|1
operator|)
operator|*
literal|4L
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|blend
operator|->
name|gv_glyphcnt
condition|;
operator|++
name|i
control|)
name|blend
operator|->
name|glyphoffsets
index|[
name|i
index|]
operator|=
name|offsetToData
operator|+
name|FT_GET_LONG
argument_list|()
expr_stmt|;
name|FT_FRAME_EXIT
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* short offsets (one more offset than glyphs, to mark size of last) */
if|if
condition|(
name|FT_FRAME_ENTER
argument_list|(
operator|(
name|blend
operator|->
name|gv_glyphcnt
operator|+
literal|1
operator|)
operator|*
literal|2L
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|blend
operator|->
name|gv_glyphcnt
condition|;
operator|++
name|i
control|)
name|blend
operator|->
name|glyphoffsets
index|[
name|i
index|]
operator|=
name|offsetToData
operator|+
name|FT_GET_USHORT
argument_list|()
operator|*
literal|2
expr_stmt|;
comment|/* XXX: Undocumented: `*2'! */
name|FT_FRAME_EXIT
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|blend
operator|->
name|tuplecount
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|blend
operator|->
name|tuplecoords
argument_list|,
name|gvar_head
operator|.
name|axisCount
operator|*
name|blend
operator|->
name|tuplecount
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
if|if
condition|(
name|FT_STREAM_SEEK
argument_list|(
name|gvar_start
operator|+
name|gvar_head
operator|.
name|offsetToCoord
argument_list|)
operator|||
name|FT_FRAME_ENTER
argument_list|(
name|blend
operator|->
name|tuplecount
operator|*
name|gvar_head
operator|.
name|axisCount
operator|*
literal|2L
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|blend
operator|->
name|tuplecount
condition|;
operator|++
name|i
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
operator|(
name|FT_UInt
operator|)
name|gvar_head
operator|.
name|axisCount
condition|;
operator|++
name|j
control|)
name|blend
operator|->
name|tuplecoords
index|[
name|i
operator|*
name|gvar_head
operator|.
name|axisCount
operator|+
name|j
index|]
operator|=
name|FT_GET_SHORT
argument_list|()
operator|<<
literal|2
expr_stmt|;
comment|/* convert to FT_Fixed */
name|FT_FRAME_EXIT
argument_list|()
expr_stmt|;
block|}
name|Exit
label|:
return|return
name|error
return|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    ft_var_apply_tuple                                                 */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Figure out whether a given tuple (design) applies to the current   */
end_comment
begin_comment
comment|/*    blend, and if so, what is the scaling factor.                      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    blend           :: The current blend of the font.                  */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    tupleIndex      :: A flag saying whether this is an intermediate   */
end_comment
begin_comment
comment|/*                       tuple or not.                                   */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    tuple_coords    :: The coordinates of the tuple in normalized axis */
end_comment
begin_comment
comment|/*                       units.                                          */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    im_start_coords :: The initial coordinates where this tuple starts */
end_comment
begin_comment
comment|/*                       to apply (for intermediate coordinates).        */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    im_end_coords   :: The final coordinates after which this tuple no */
end_comment
begin_comment
comment|/*                       longer applies (for intermediate coordinates).  */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    An FT_Fixed value containing the scaling factor.                   */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|FT_Fixed
DECL|function|ft_var_apply_tuple
name|ft_var_apply_tuple
parameter_list|(
name|GX_Blend
name|blend
parameter_list|,
name|FT_UShort
name|tupleIndex
parameter_list|,
name|FT_Fixed
modifier|*
name|tuple_coords
parameter_list|,
name|FT_Fixed
modifier|*
name|im_start_coords
parameter_list|,
name|FT_Fixed
modifier|*
name|im_end_coords
parameter_list|)
block|{
name|FT_UInt
name|i
decl_stmt|;
name|FT_Fixed
name|apply
decl_stmt|;
name|FT_Fixed
name|temp
decl_stmt|;
name|apply
operator|=
literal|0x10000L
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|blend
operator|->
name|num_axis
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|tuple_coords
index|[
name|i
index|]
operator|==
literal|0
condition|)
comment|/* It's not clear why (for intermediate tuples) we don't need     */
comment|/* to check against start/end -- the documentation says we don't. */
comment|/* Similarly, it's unclear why we don't need to scale along the   */
comment|/* axis.                                                          */
continue|continue;
elseif|else
if|if
condition|(
name|blend
operator|->
name|normalizedcoords
index|[
name|i
index|]
operator|==
literal|0
operator|||
operator|(
name|blend
operator|->
name|normalizedcoords
index|[
name|i
index|]
operator|<
literal|0
operator|&&
name|tuple_coords
index|[
name|i
index|]
operator|>
literal|0
operator|)
operator|||
operator|(
name|blend
operator|->
name|normalizedcoords
index|[
name|i
index|]
operator|>
literal|0
operator|&&
name|tuple_coords
index|[
name|i
index|]
operator|<
literal|0
operator|)
condition|)
block|{
name|apply
operator|=
literal|0
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|tupleIndex
operator|&
name|GX_TI_INTERMEDIATE_TUPLE
operator|)
condition|)
comment|/* not an intermediate tuple */
name|apply
operator|=
name|FT_MulDiv
argument_list|(
name|apply
argument_list|,
name|blend
operator|->
name|normalizedcoords
index|[
name|i
index|]
operator|>
literal|0
condition|?
name|blend
operator|->
name|normalizedcoords
index|[
name|i
index|]
else|:
operator|-
name|blend
operator|->
name|normalizedcoords
index|[
name|i
index|]
argument_list|,
literal|0x10000L
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|blend
operator|->
name|normalizedcoords
index|[
name|i
index|]
operator|<=
name|im_start_coords
index|[
name|i
index|]
operator|||
name|blend
operator|->
name|normalizedcoords
index|[
name|i
index|]
operator|>=
name|im_end_coords
index|[
name|i
index|]
condition|)
block|{
name|apply
operator|=
literal|0
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|blend
operator|->
name|normalizedcoords
index|[
name|i
index|]
operator|<
name|tuple_coords
index|[
name|i
index|]
condition|)
block|{
name|temp
operator|=
name|FT_MulDiv
argument_list|(
name|blend
operator|->
name|normalizedcoords
index|[
name|i
index|]
operator|-
name|im_start_coords
index|[
name|i
index|]
argument_list|,
literal|0x10000L
argument_list|,
name|tuple_coords
index|[
name|i
index|]
operator|-
name|im_start_coords
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|apply
operator|=
name|FT_MulDiv
argument_list|(
name|apply
argument_list|,
name|temp
argument_list|,
literal|0x10000L
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|temp
operator|=
name|FT_MulDiv
argument_list|(
name|im_end_coords
index|[
name|i
index|]
operator|-
name|blend
operator|->
name|normalizedcoords
index|[
name|i
index|]
argument_list|,
literal|0x10000L
argument_list|,
name|im_end_coords
index|[
name|i
index|]
operator|-
name|tuple_coords
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|apply
operator|=
name|FT_MulDiv
argument_list|(
name|apply
argument_list|,
name|temp
argument_list|,
literal|0x10000L
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|apply
return|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****               MULTIPLE MASTERS SERVICE FUNCTIONS              *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_typedef
DECL|struct|GX_FVar_Head_
typedef|typedef
struct|struct
name|GX_FVar_Head_
block|{
DECL|member|version
name|FT_Long
name|version
decl_stmt|;
DECL|member|offsetToData
name|FT_UShort
name|offsetToData
decl_stmt|;
DECL|member|countSizePairs
name|FT_UShort
name|countSizePairs
decl_stmt|;
DECL|member|axisCount
name|FT_UShort
name|axisCount
decl_stmt|;
DECL|member|axisSize
name|FT_UShort
name|axisSize
decl_stmt|;
DECL|member|instanceCount
name|FT_UShort
name|instanceCount
decl_stmt|;
DECL|member|instanceSize
name|FT_UShort
name|instanceSize
decl_stmt|;
block|}
DECL|typedef|GX_FVar_Head
name|GX_FVar_Head
typedef|;
end_typedef
begin_typedef
DECL|struct|fvar_axis_
typedef|typedef
struct|struct
name|fvar_axis_
block|{
DECL|member|axisTag
name|FT_ULong
name|axisTag
decl_stmt|;
DECL|member|minValue
name|FT_ULong
name|minValue
decl_stmt|;
DECL|member|defaultValue
name|FT_ULong
name|defaultValue
decl_stmt|;
DECL|member|maxValue
name|FT_ULong
name|maxValue
decl_stmt|;
DECL|member|flags
name|FT_UShort
name|flags
decl_stmt|;
DECL|member|nameID
name|FT_UShort
name|nameID
decl_stmt|;
block|}
DECL|typedef|GX_FVar_Axis
name|GX_FVar_Axis
typedef|;
end_typedef
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    TT_Get_MM_Var                                                      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Check that the font's `fvar' table is valid, parse it, and return  */
end_comment
begin_comment
comment|/*    those data.                                                        */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<InOut>                                                               */
end_comment
begin_comment
comment|/*    face   :: The font face.                                           */
end_comment
begin_comment
comment|/*              TT_Get_MM_Var initializes the blend structure.           */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Output>                                                              */
end_comment
begin_comment
comment|/*    master :: The `fvar' data (must be freed by caller).               */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    FreeType error code.  0 means success.                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|TT_Get_MM_Var
argument_list|(
argument|TT_Face      face
argument_list|,
argument|FT_MM_Var*  *master
argument_list|)
end_macro
begin_block
block|{
name|FT_Stream
name|stream
init|=
name|face
operator|->
name|root
operator|.
name|stream
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|face
operator|->
name|root
operator|.
name|memory
decl_stmt|;
name|FT_ULong
name|table_len
decl_stmt|;
name|FT_Error
name|error
init|=
name|TT_Err_Ok
decl_stmt|;
name|FT_ULong
name|fvar_start
decl_stmt|;
name|FT_Int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|FT_MM_Var
modifier|*
name|mmvar
decl_stmt|;
name|FT_Fixed
modifier|*
name|next_coords
decl_stmt|;
name|FT_String
modifier|*
name|next_name
decl_stmt|;
name|FT_Var_Axis
modifier|*
name|a
decl_stmt|;
name|FT_Var_Named_Style
modifier|*
name|ns
decl_stmt|;
name|GX_FVar_Head
name|fvar_head
decl_stmt|;
specifier|static
specifier|const
name|FT_Frame_Field
name|fvar_fields
index|[]
init|=
block|{
DECL|macro|FT_STRUCTURE
undef|#
directive|undef
name|FT_STRUCTURE
DECL|macro|FT_STRUCTURE
define|#
directive|define
name|FT_STRUCTURE
value|GX_FVar_Head
name|FT_FRAME_START
argument_list|(
literal|16
argument_list|)
block|,
name|FT_FRAME_LONG
argument_list|(
name|version
argument_list|)
block|,
name|FT_FRAME_USHORT
argument_list|(
name|offsetToData
argument_list|)
block|,
name|FT_FRAME_USHORT
argument_list|(
name|countSizePairs
argument_list|)
block|,
name|FT_FRAME_USHORT
argument_list|(
name|axisCount
argument_list|)
block|,
name|FT_FRAME_USHORT
argument_list|(
name|axisSize
argument_list|)
block|,
name|FT_FRAME_USHORT
argument_list|(
name|instanceCount
argument_list|)
block|,
name|FT_FRAME_USHORT
argument_list|(
name|instanceSize
argument_list|)
block|,
name|FT_FRAME_END
block|}
decl_stmt|;
specifier|static
specifier|const
name|FT_Frame_Field
name|fvaraxis_fields
index|[]
init|=
block|{
DECL|macro|FT_STRUCTURE
undef|#
directive|undef
name|FT_STRUCTURE
DECL|macro|FT_STRUCTURE
define|#
directive|define
name|FT_STRUCTURE
value|GX_FVar_Axis
name|FT_FRAME_START
argument_list|(
literal|20
argument_list|)
block|,
name|FT_FRAME_ULONG
argument_list|(
name|axisTag
argument_list|)
block|,
name|FT_FRAME_ULONG
argument_list|(
name|minValue
argument_list|)
block|,
name|FT_FRAME_ULONG
argument_list|(
name|defaultValue
argument_list|)
block|,
name|FT_FRAME_ULONG
argument_list|(
name|maxValue
argument_list|)
block|,
name|FT_FRAME_USHORT
argument_list|(
name|flags
argument_list|)
block|,
name|FT_FRAME_USHORT
argument_list|(
name|nameID
argument_list|)
block|,
name|FT_FRAME_END
block|}
decl_stmt|;
if|if
condition|(
name|face
operator|->
name|blend
operator|==
name|NULL
condition|)
block|{
comment|/* both `fvar' and `gvar' must be present */
if|if
condition|(
operator|(
name|error
operator|=
name|face
operator|->
name|goto_table
argument_list|(
name|face
argument_list|,
name|TTAG_gvar
argument_list|,
name|stream
argument_list|,
operator|&
name|table_len
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|Exit
goto|;
if|if
condition|(
operator|(
name|error
operator|=
name|face
operator|->
name|goto_table
argument_list|(
name|face
argument_list|,
name|TTAG_fvar
argument_list|,
name|stream
argument_list|,
operator|&
name|table_len
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|Exit
goto|;
name|fvar_start
operator|=
name|FT_STREAM_POS
argument_list|( )
expr_stmt|;
if|if
condition|(
name|FT_STREAM_READ_FIELDS
argument_list|(
name|fvar_fields
argument_list|,
operator|&
name|fvar_head
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
if|if
condition|(
name|fvar_head
operator|.
name|version
operator|!=
operator|(
name|FT_Long
operator|)
literal|0x00010000L
operator|||
name|fvar_head
operator|.
name|countSizePairs
operator|!=
literal|2
operator|||
name|fvar_head
operator|.
name|axisSize
operator|!=
literal|20
operator|||
name|fvar_head
operator|.
name|instanceSize
operator|!=
literal|4
operator|+
literal|4
operator|*
name|fvar_head
operator|.
name|axisCount
operator|||
name|fvar_head
operator|.
name|offsetToData
operator|+
name|fvar_head
operator|.
name|axisCount
operator|*
literal|20U
operator|+
name|fvar_head
operator|.
name|instanceCount
operator|*
name|fvar_head
operator|.
name|instanceSize
operator|>
name|table_len
condition|)
block|{
name|error
operator|=
name|TT_Err_Invalid_Table
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|FT_NEW
argument_list|(
name|face
operator|->
name|blend
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
comment|/* XXX: TODO - check for overflows */
name|face
operator|->
name|blend
operator|->
name|mmvar_len
operator|=
sizeof|sizeof
argument_list|(
name|FT_MM_Var
argument_list|)
operator|+
name|fvar_head
operator|.
name|axisCount
operator|*
sizeof|sizeof
argument_list|(
name|FT_Var_Axis
argument_list|)
operator|+
name|fvar_head
operator|.
name|instanceCount
operator|*
sizeof|sizeof
argument_list|(
name|FT_Var_Named_Style
argument_list|)
operator|+
name|fvar_head
operator|.
name|instanceCount
operator|*
name|fvar_head
operator|.
name|axisCount
operator|*
sizeof|sizeof
argument_list|(
name|FT_Fixed
argument_list|)
operator|+
literal|5
operator|*
name|fvar_head
operator|.
name|axisCount
expr_stmt|;
if|if
condition|(
name|FT_ALLOC
argument_list|(
name|mmvar
argument_list|,
name|face
operator|->
name|blend
operator|->
name|mmvar_len
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|face
operator|->
name|blend
operator|->
name|mmvar
operator|=
name|mmvar
expr_stmt|;
name|mmvar
operator|->
name|num_axis
operator|=
name|fvar_head
operator|.
name|axisCount
expr_stmt|;
name|mmvar
operator|->
name|num_designs
operator|=
operator|(
name|FT_UInt
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* meaningless in this context; each glyph */
comment|/* may have a different number of designs  */
comment|/* (or tuples, as called by Apple)         */
name|mmvar
operator|->
name|num_namedstyles
operator|=
name|fvar_head
operator|.
name|instanceCount
expr_stmt|;
name|mmvar
operator|->
name|axis
operator|=
operator|(
name|FT_Var_Axis
operator|*
operator|)
operator|&
operator|(
name|mmvar
index|[
literal|1
index|]
operator|)
expr_stmt|;
name|mmvar
operator|->
name|namedstyle
operator|=
operator|(
name|FT_Var_Named_Style
operator|*
operator|)
operator|&
operator|(
name|mmvar
operator|->
name|axis
index|[
name|fvar_head
operator|.
name|axisCount
index|]
operator|)
expr_stmt|;
name|next_coords
operator|=
operator|(
name|FT_Fixed
operator|*
operator|)
operator|&
operator|(
name|mmvar
operator|->
name|namedstyle
index|[
name|fvar_head
operator|.
name|instanceCount
index|]
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fvar_head
operator|.
name|instanceCount
condition|;
operator|++
name|i
control|)
block|{
name|mmvar
operator|->
name|namedstyle
index|[
name|i
index|]
operator|.
name|coords
operator|=
name|next_coords
expr_stmt|;
name|next_coords
operator|+=
name|fvar_head
operator|.
name|axisCount
expr_stmt|;
block|}
name|next_name
operator|=
operator|(
name|FT_String
operator|*
operator|)
name|next_coords
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fvar_head
operator|.
name|axisCount
condition|;
operator|++
name|i
control|)
block|{
name|mmvar
operator|->
name|axis
index|[
name|i
index|]
operator|.
name|name
operator|=
name|next_name
expr_stmt|;
name|next_name
operator|+=
literal|5
expr_stmt|;
block|}
if|if
condition|(
name|FT_STREAM_SEEK
argument_list|(
name|fvar_start
operator|+
name|fvar_head
operator|.
name|offsetToData
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|a
operator|=
name|mmvar
operator|->
name|axis
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fvar_head
operator|.
name|axisCount
condition|;
operator|++
name|i
control|)
block|{
name|GX_FVar_Axis
name|axis_rec
decl_stmt|;
if|if
condition|(
name|FT_STREAM_READ_FIELDS
argument_list|(
name|fvaraxis_fields
argument_list|,
operator|&
name|axis_rec
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|a
operator|->
name|tag
operator|=
name|axis_rec
operator|.
name|axisTag
expr_stmt|;
name|a
operator|->
name|minimum
operator|=
name|axis_rec
operator|.
name|minValue
expr_stmt|;
comment|/* A Fixed */
name|a
operator|->
name|def
operator|=
name|axis_rec
operator|.
name|defaultValue
expr_stmt|;
comment|/* A Fixed */
name|a
operator|->
name|maximum
operator|=
name|axis_rec
operator|.
name|maxValue
expr_stmt|;
comment|/* A Fixed */
name|a
operator|->
name|strid
operator|=
name|axis_rec
operator|.
name|nameID
expr_stmt|;
name|a
operator|->
name|name
index|[
literal|0
index|]
operator|=
call|(
name|FT_String
call|)
argument_list|(
name|a
operator|->
name|tag
operator|>>
literal|24
argument_list|)
expr_stmt|;
name|a
operator|->
name|name
index|[
literal|1
index|]
operator|=
call|(
name|FT_String
call|)
argument_list|(
operator|(
name|a
operator|->
name|tag
operator|>>
literal|16
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|a
operator|->
name|name
index|[
literal|2
index|]
operator|=
call|(
name|FT_String
call|)
argument_list|(
operator|(
name|a
operator|->
name|tag
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|a
operator|->
name|name
index|[
literal|3
index|]
operator|=
call|(
name|FT_String
call|)
argument_list|(
operator|(
name|a
operator|->
name|tag
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|a
operator|->
name|name
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
operator|++
name|a
expr_stmt|;
block|}
name|ns
operator|=
name|mmvar
operator|->
name|namedstyle
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fvar_head
operator|.
name|instanceCount
condition|;
operator|++
name|i
operator|,
operator|++
name|ns
control|)
block|{
if|if
condition|(
name|FT_FRAME_ENTER
argument_list|(
literal|4L
operator|+
literal|4L
operator|*
name|fvar_head
operator|.
name|axisCount
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|ns
operator|->
name|strid
operator|=
name|FT_GET_USHORT
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
comment|/* flags = */
name|FT_GET_USHORT
argument_list|()
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|fvar_head
operator|.
name|axisCount
condition|;
operator|++
name|j
control|)
name|ns
operator|->
name|coords
index|[
name|j
index|]
operator|=
name|FT_GET_ULONG
argument_list|()
expr_stmt|;
comment|/* A Fixed */
name|FT_FRAME_EXIT
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|master
operator|!=
name|NULL
condition|)
block|{
name|FT_UInt
name|n
decl_stmt|;
if|if
condition|(
name|FT_ALLOC
argument_list|(
name|mmvar
argument_list|,
name|face
operator|->
name|blend
operator|->
name|mmvar_len
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|FT_MEM_COPY
argument_list|(
name|mmvar
argument_list|,
name|face
operator|->
name|blend
operator|->
name|mmvar
argument_list|,
name|face
operator|->
name|blend
operator|->
name|mmvar_len
argument_list|)
expr_stmt|;
name|mmvar
operator|->
name|axis
operator|=
operator|(
name|FT_Var_Axis
operator|*
operator|)
operator|&
operator|(
name|mmvar
index|[
literal|1
index|]
operator|)
expr_stmt|;
name|mmvar
operator|->
name|namedstyle
operator|=
operator|(
name|FT_Var_Named_Style
operator|*
operator|)
operator|&
operator|(
name|mmvar
operator|->
name|axis
index|[
name|mmvar
operator|->
name|num_axis
index|]
operator|)
expr_stmt|;
name|next_coords
operator|=
operator|(
name|FT_Fixed
operator|*
operator|)
operator|&
operator|(
name|mmvar
operator|->
name|namedstyle
index|[
name|mmvar
operator|->
name|num_namedstyles
index|]
operator|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|mmvar
operator|->
name|num_namedstyles
condition|;
operator|++
name|n
control|)
block|{
name|mmvar
operator|->
name|namedstyle
index|[
name|n
index|]
operator|.
name|coords
operator|=
name|next_coords
expr_stmt|;
name|next_coords
operator|+=
name|mmvar
operator|->
name|num_axis
expr_stmt|;
block|}
name|a
operator|=
name|mmvar
operator|->
name|axis
expr_stmt|;
name|next_name
operator|=
operator|(
name|FT_String
operator|*
operator|)
name|next_coords
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|mmvar
operator|->
name|num_axis
condition|;
operator|++
name|n
control|)
block|{
name|a
operator|->
name|name
operator|=
name|next_name
expr_stmt|;
comment|/* standard PostScript names for some standard apple tags */
if|if
condition|(
name|a
operator|->
name|tag
operator|==
name|TTAG_wght
condition|)
name|a
operator|->
name|name
operator|=
operator|(
name|char
operator|*
operator|)
literal|"Weight"
expr_stmt|;
elseif|else
if|if
condition|(
name|a
operator|->
name|tag
operator|==
name|TTAG_wdth
condition|)
name|a
operator|->
name|name
operator|=
operator|(
name|char
operator|*
operator|)
literal|"Width"
expr_stmt|;
elseif|else
if|if
condition|(
name|a
operator|->
name|tag
operator|==
name|TTAG_opsz
condition|)
name|a
operator|->
name|name
operator|=
operator|(
name|char
operator|*
operator|)
literal|"OpticalSize"
expr_stmt|;
elseif|else
if|if
condition|(
name|a
operator|->
name|tag
operator|==
name|TTAG_slnt
condition|)
name|a
operator|->
name|name
operator|=
operator|(
name|char
operator|*
operator|)
literal|"Slant"
expr_stmt|;
name|next_name
operator|+=
literal|5
expr_stmt|;
operator|++
name|a
expr_stmt|;
block|}
operator|*
name|master
operator|=
name|mmvar
expr_stmt|;
block|}
name|Exit
label|:
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    TT_Set_MM_Blend                                                    */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Set the blend (normalized) coordinates for this instance of the    */
end_comment
begin_comment
comment|/*    font.  Check that the `gvar' table is reasonable and does some     */
end_comment
begin_comment
comment|/*    initial preparation.                                               */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<InOut>                                                               */
end_comment
begin_comment
comment|/*    face       :: The font.                                            */
end_comment
begin_comment
comment|/*                  Initialize the blend structure with `gvar' data.     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    num_coords :: Must be the axis count of the font.                  */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    coords     :: An array of num_coords, each between [-1,1].         */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    FreeType error code.  0 means success.                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|TT_Set_MM_Blend
argument_list|(
argument|TT_Face    face
argument_list|,
argument|FT_UInt    num_coords
argument_list|,
argument|FT_Fixed*  coords
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
init|=
name|TT_Err_Ok
decl_stmt|;
name|GX_Blend
name|blend
decl_stmt|;
name|FT_MM_Var
modifier|*
name|mmvar
decl_stmt|;
name|FT_UInt
name|i
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|face
operator|->
name|root
operator|.
name|memory
decl_stmt|;
enum|enum
block|{
name|mcvt_retain
block|,
name|mcvt_modify
block|,
name|mcvt_load
block|}
name|manageCvt
enum|;
name|face
operator|->
name|doblend
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|face
operator|->
name|blend
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|TT_Get_MM_Var
argument_list|(
name|face
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|Exit
goto|;
block|}
name|blend
operator|=
name|face
operator|->
name|blend
expr_stmt|;
name|mmvar
operator|=
name|blend
operator|->
name|mmvar
expr_stmt|;
if|if
condition|(
name|num_coords
operator|!=
name|mmvar
operator|->
name|num_axis
condition|)
block|{
name|error
operator|=
name|TT_Err_Invalid_Argument
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_coords
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|coords
index|[
name|i
index|]
operator|<
operator|-
literal|0x00010000L
operator|||
name|coords
index|[
name|i
index|]
operator|>
literal|0x00010000L
condition|)
block|{
name|error
operator|=
name|TT_Err_Invalid_Argument
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|blend
operator|->
name|glyphoffsets
operator|==
name|NULL
condition|)
if|if
condition|(
operator|(
name|error
operator|=
name|ft_var_load_gvar
argument_list|(
name|face
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|Exit
goto|;
if|if
condition|(
name|blend
operator|->
name|normalizedcoords
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|blend
operator|->
name|normalizedcoords
argument_list|,
name|num_coords
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|manageCvt
operator|=
name|mcvt_modify
expr_stmt|;
comment|/* If we have not set the blend coordinates before this, then the  */
comment|/* cvt table will still be what we read from the `cvt ' table and  */
comment|/* we don't need to reload it.  We may need to change it though... */
block|}
else|else
block|{
name|manageCvt
operator|=
name|mcvt_retain
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_coords
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|blend
operator|->
name|normalizedcoords
index|[
name|i
index|]
operator|!=
name|coords
index|[
name|i
index|]
condition|)
block|{
name|manageCvt
operator|=
name|mcvt_load
expr_stmt|;
break|break;
block|}
block|}
comment|/* If we don't change the blend coords then we don't need to do  */
comment|/* anything to the cvt table.  It will be correct.  Otherwise we */
comment|/* no longer have the original cvt (it was modified when we set  */
comment|/* the blend last time), so we must reload and then modify it.   */
block|}
name|blend
operator|->
name|num_axis
operator|=
name|num_coords
expr_stmt|;
name|FT_MEM_COPY
argument_list|(
name|blend
operator|->
name|normalizedcoords
argument_list|,
name|coords
argument_list|,
name|num_coords
operator|*
sizeof|sizeof
argument_list|(
name|FT_Fixed
argument_list|)
argument_list|)
expr_stmt|;
name|face
operator|->
name|doblend
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|face
operator|->
name|cvt
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|manageCvt
condition|)
block|{
case|case
name|mcvt_load
case|:
comment|/* The cvt table has been loaded already; every time we change the */
comment|/* blend we may need to reload and remodify the cvt table.         */
name|FT_FREE
argument_list|(
name|face
operator|->
name|cvt
argument_list|)
expr_stmt|;
name|face
operator|->
name|cvt
operator|=
name|NULL
expr_stmt|;
name|tt_face_load_cvt
argument_list|(
name|face
argument_list|,
name|face
operator|->
name|root
operator|.
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
name|mcvt_modify
case|:
comment|/* The original cvt table is in memory.  All we need to do is */
comment|/* apply the `cvar' table (if any).                           */
name|tt_face_vary_cvt
argument_list|(
name|face
argument_list|,
name|face
operator|->
name|root
operator|.
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
name|mcvt_retain
case|:
comment|/* The cvt table is correct for this set of coordinates. */
break|break;
block|}
block|}
name|Exit
label|:
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    TT_Set_Var_Design                                                  */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Set the coordinates for the instance, measured in the user         */
end_comment
begin_comment
comment|/*    coordinate system.  Parse the `avar' table (if present) to convert */
end_comment
begin_comment
comment|/*    from user to normalized coordinates.                               */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<InOut>                                                               */
end_comment
begin_comment
comment|/*    face       :: The font face.                                       */
end_comment
begin_comment
comment|/*                  Initialize the blend struct with `gvar' data.        */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    num_coords :: This must be the axis count of the font.             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    coords     :: A coordinate array with `num_coords' elements.       */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    FreeType error code.  0 means success.                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|TT_Set_Var_Design
argument_list|(
argument|TT_Face    face
argument_list|,
argument|FT_UInt    num_coords
argument_list|,
argument|FT_Fixed*  coords
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
init|=
name|TT_Err_Ok
decl_stmt|;
name|FT_Fixed
modifier|*
name|normalized
init|=
name|NULL
decl_stmt|;
name|GX_Blend
name|blend
decl_stmt|;
name|FT_MM_Var
modifier|*
name|mmvar
decl_stmt|;
name|FT_UInt
name|i
decl_stmt|,
name|j
decl_stmt|;
name|FT_Var_Axis
modifier|*
name|a
decl_stmt|;
name|GX_AVarSegment
name|av
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|face
operator|->
name|root
operator|.
name|memory
decl_stmt|;
if|if
condition|(
name|face
operator|->
name|blend
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|TT_Get_MM_Var
argument_list|(
name|face
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|Exit
goto|;
block|}
name|blend
operator|=
name|face
operator|->
name|blend
expr_stmt|;
name|mmvar
operator|=
name|blend
operator|->
name|mmvar
expr_stmt|;
if|if
condition|(
name|num_coords
operator|!=
name|mmvar
operator|->
name|num_axis
condition|)
block|{
name|error
operator|=
name|TT_Err_Invalid_Argument
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* Axis normalization is a two stage process.  First we normalize */
comment|/* based on the [min,def,max] values for the axis to be [-1,0,1]. */
comment|/* Then, if there's an `avar' table, we renormalize this range.   */
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|normalized
argument_list|,
name|mmvar
operator|->
name|num_axis
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|a
operator|=
name|mmvar
operator|->
name|axis
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mmvar
operator|->
name|num_axis
condition|;
operator|++
name|i
operator|,
operator|++
name|a
control|)
block|{
if|if
condition|(
name|coords
index|[
name|i
index|]
operator|>
name|a
operator|->
name|maximum
operator|||
name|coords
index|[
name|i
index|]
operator|<
name|a
operator|->
name|minimum
condition|)
block|{
name|error
operator|=
name|TT_Err_Invalid_Argument
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|coords
index|[
name|i
index|]
operator|<
name|a
operator|->
name|def
condition|)
block|{
name|normalized
index|[
name|i
index|]
operator|=
operator|-
name|FT_MulDiv
argument_list|(
name|coords
index|[
name|i
index|]
operator|-
name|a
operator|->
name|def
argument_list|,
literal|0x10000L
argument_list|,
name|a
operator|->
name|minimum
operator|-
name|a
operator|->
name|def
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|a
operator|->
name|maximum
operator|==
name|a
operator|->
name|def
condition|)
name|normalized
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|normalized
index|[
name|i
index|]
operator|=
name|FT_MulDiv
argument_list|(
name|coords
index|[
name|i
index|]
operator|-
name|a
operator|->
name|def
argument_list|,
literal|0x10000L
argument_list|,
name|a
operator|->
name|maximum
operator|-
name|a
operator|->
name|def
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|blend
operator|->
name|avar_checked
condition|)
name|ft_var_load_avar
argument_list|(
name|face
argument_list|)
expr_stmt|;
if|if
condition|(
name|blend
operator|->
name|avar_segment
operator|!=
name|NULL
condition|)
block|{
name|av
operator|=
name|blend
operator|->
name|avar_segment
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mmvar
operator|->
name|num_axis
condition|;
operator|++
name|i
operator|,
operator|++
name|av
control|)
block|{
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
operator|(
name|FT_UInt
operator|)
name|av
operator|->
name|pairCount
condition|;
operator|++
name|j
control|)
if|if
condition|(
name|normalized
index|[
name|i
index|]
operator|<
name|av
operator|->
name|correspondence
index|[
name|j
index|]
operator|.
name|fromCoord
condition|)
block|{
name|normalized
index|[
name|i
index|]
operator|=
name|FT_MulDiv
argument_list|(
name|FT_MulDiv
argument_list|(
name|normalized
index|[
name|i
index|]
operator|-
name|av
operator|->
name|correspondence
index|[
name|j
operator|-
literal|1
index|]
operator|.
name|fromCoord
argument_list|,
literal|0x10000L
argument_list|,
name|av
operator|->
name|correspondence
index|[
name|j
index|]
operator|.
name|fromCoord
operator|-
name|av
operator|->
name|correspondence
index|[
name|j
operator|-
literal|1
index|]
operator|.
name|fromCoord
argument_list|)
argument_list|,
name|av
operator|->
name|correspondence
index|[
name|j
index|]
operator|.
name|toCoord
operator|-
name|av
operator|->
name|correspondence
index|[
name|j
operator|-
literal|1
index|]
operator|.
name|toCoord
argument_list|,
literal|0x10000L
argument_list|)
operator|+
name|av
operator|->
name|correspondence
index|[
name|j
operator|-
literal|1
index|]
operator|.
name|toCoord
expr_stmt|;
break|break;
block|}
block|}
block|}
name|error
operator|=
name|TT_Set_MM_Blend
argument_list|(
name|face
argument_list|,
name|num_coords
argument_list|,
name|normalized
argument_list|)
expr_stmt|;
name|Exit
label|:
name|FT_FREE
argument_list|(
name|normalized
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****                     GX VAR PARSING ROUTINES                   *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    tt_face_vary_cvt                                                   */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Modify the loaded cvt table according to the `cvar' table and the  */
end_comment
begin_comment
comment|/*    font's blend.                                                      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<InOut>                                                               */
end_comment
begin_comment
comment|/*    face   :: A handle to the target face object.                      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    stream :: A handle to the input stream.                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    FreeType error code.  0 means success.                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    Most errors are ignored.  It is perfectly valid not to have a      */
end_comment
begin_comment
comment|/*    `cvar' table even if there is a `gvar' and `fvar' table.           */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|tt_face_vary_cvt
argument_list|(
argument|TT_Face    face
argument_list|,
argument|FT_Stream  stream
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|stream
operator|->
name|memory
decl_stmt|;
name|FT_ULong
name|table_start
decl_stmt|;
name|FT_ULong
name|table_len
decl_stmt|;
name|FT_UInt
name|tupleCount
decl_stmt|;
name|FT_ULong
name|offsetToData
decl_stmt|;
name|FT_ULong
name|here
decl_stmt|;
name|FT_UInt
name|i
decl_stmt|,
name|j
decl_stmt|;
name|FT_Fixed
modifier|*
name|tuple_coords
init|=
name|NULL
decl_stmt|;
name|FT_Fixed
modifier|*
name|im_start_coords
init|=
name|NULL
decl_stmt|;
name|FT_Fixed
modifier|*
name|im_end_coords
init|=
name|NULL
decl_stmt|;
name|GX_Blend
name|blend
init|=
name|face
operator|->
name|blend
decl_stmt|;
name|FT_UInt
name|point_count
decl_stmt|;
name|FT_UShort
modifier|*
name|localpoints
decl_stmt|;
name|FT_Short
modifier|*
name|deltas
decl_stmt|;
name|FT_TRACE2
argument_list|(
operator|(
literal|"CVAR "
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|blend
operator|==
name|NULL
condition|)
block|{
name|FT_TRACE2
argument_list|(
operator|(
literal|"no blend specified!\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|TT_Err_Ok
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|face
operator|->
name|cvt
operator|==
name|NULL
condition|)
block|{
name|FT_TRACE2
argument_list|(
operator|(
literal|"no `cvt ' table!\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|TT_Err_Ok
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|error
operator|=
name|face
operator|->
name|goto_table
argument_list|(
name|face
argument_list|,
name|TTAG_cvar
argument_list|,
name|stream
argument_list|,
operator|&
name|table_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|FT_TRACE2
argument_list|(
operator|(
literal|"is missing!\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|TT_Err_Ok
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|FT_FRAME_ENTER
argument_list|(
name|table_len
argument_list|)
condition|)
block|{
name|error
operator|=
name|TT_Err_Ok
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|table_start
operator|=
name|FT_Stream_FTell
argument_list|(
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|FT_GET_LONG
argument_list|()
operator|!=
literal|0x00010000L
condition|)
block|{
name|FT_TRACE2
argument_list|(
operator|(
literal|"bad table version!\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|TT_Err_Ok
expr_stmt|;
goto|goto
name|FExit
goto|;
block|}
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|tuple_coords
argument_list|,
name|blend
operator|->
name|num_axis
argument_list|)
operator|||
name|FT_NEW_ARRAY
argument_list|(
name|im_start_coords
argument_list|,
name|blend
operator|->
name|num_axis
argument_list|)
operator|||
name|FT_NEW_ARRAY
argument_list|(
name|im_end_coords
argument_list|,
name|blend
operator|->
name|num_axis
argument_list|)
condition|)
goto|goto
name|FExit
goto|;
name|tupleCount
operator|=
name|FT_GET_USHORT
argument_list|()
expr_stmt|;
name|offsetToData
operator|=
name|table_start
operator|+
name|FT_GET_USHORT
argument_list|()
expr_stmt|;
comment|/* The documentation implies there are flags packed into the        */
comment|/* tuplecount, but John Jenkins says that shared points don't apply */
comment|/* to `cvar', and no other flags are defined.                       */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|tupleCount
operator|&
literal|0xFFF
operator|)
condition|;
operator|++
name|i
control|)
block|{
name|FT_UInt
name|tupleDataSize
decl_stmt|;
name|FT_UInt
name|tupleIndex
decl_stmt|;
name|FT_Fixed
name|apply
decl_stmt|;
name|tupleDataSize
operator|=
name|FT_GET_USHORT
argument_list|()
expr_stmt|;
name|tupleIndex
operator|=
name|FT_GET_USHORT
argument_list|()
expr_stmt|;
comment|/* There is no provision here for a global tuple coordinate section, */
comment|/* so John says.  There are no tuple indices, just embedded tuples.  */
if|if
condition|(
name|tupleIndex
operator|&
name|GX_TI_EMBEDDED_TUPLE_COORD
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|blend
operator|->
name|num_axis
condition|;
operator|++
name|j
control|)
name|tuple_coords
index|[
name|j
index|]
operator|=
name|FT_GET_SHORT
argument_list|()
operator|<<
literal|2
expr_stmt|;
comment|/* convert from        */
comment|/* short frac to fixed */
block|}
else|else
block|{
comment|/* skip this tuple; it makes no sense */
if|if
condition|(
name|tupleIndex
operator|&
name|GX_TI_INTERMEDIATE_TUPLE
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|2
operator|*
name|blend
operator|->
name|num_axis
condition|;
operator|++
name|j
control|)
operator|(
name|void
operator|)
name|FT_GET_SHORT
argument_list|()
expr_stmt|;
name|offsetToData
operator|+=
name|tupleDataSize
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|tupleIndex
operator|&
name|GX_TI_INTERMEDIATE_TUPLE
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|blend
operator|->
name|num_axis
condition|;
operator|++
name|j
control|)
name|im_start_coords
index|[
name|j
index|]
operator|=
name|FT_GET_SHORT
argument_list|()
operator|<<
literal|2
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|blend
operator|->
name|num_axis
condition|;
operator|++
name|j
control|)
name|im_end_coords
index|[
name|j
index|]
operator|=
name|FT_GET_SHORT
argument_list|()
operator|<<
literal|2
expr_stmt|;
block|}
name|apply
operator|=
name|ft_var_apply_tuple
argument_list|(
name|blend
argument_list|,
operator|(
name|FT_UShort
operator|)
name|tupleIndex
argument_list|,
name|tuple_coords
argument_list|,
name|im_start_coords
argument_list|,
name|im_end_coords
argument_list|)
expr_stmt|;
if|if
condition|(
comment|/* tuple isn't active for our blend */
name|apply
operator|==
literal|0
operator|||
comment|/* global points not allowed,           */
comment|/* if they aren't local, makes no sense */
operator|!
operator|(
name|tupleIndex
operator|&
name|GX_TI_PRIVATE_POINT_NUMBERS
operator|)
condition|)
block|{
name|offsetToData
operator|+=
name|tupleDataSize
expr_stmt|;
continue|continue;
block|}
name|here
operator|=
name|FT_Stream_FTell
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|FT_Stream_SeekSet
argument_list|(
name|stream
argument_list|,
name|offsetToData
argument_list|)
expr_stmt|;
name|localpoints
operator|=
name|ft_var_readpackedpoints
argument_list|(
name|stream
argument_list|,
operator|&
name|point_count
argument_list|)
expr_stmt|;
name|deltas
operator|=
name|ft_var_readpackeddeltas
argument_list|(
name|stream
argument_list|,
name|point_count
operator|==
literal|0
condition|?
name|face
operator|->
name|cvt_size
else|:
name|point_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|localpoints
operator|==
name|NULL
operator|||
name|deltas
operator|==
name|NULL
condition|)
comment|/* failure, ignore it */
empty_stmt|;
elseif|else
if|if
condition|(
name|localpoints
operator|==
name|ALL_POINTS
condition|)
block|{
comment|/* this means that there are deltas for every entry in cvt */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|face
operator|->
name|cvt_size
condition|;
operator|++
name|j
control|)
name|face
operator|->
name|cvt
index|[
name|j
index|]
operator|=
call|(
name|FT_Short
call|)
argument_list|(
name|face
operator|->
name|cvt
index|[
name|j
index|]
operator|+
name|FT_MulFix
argument_list|(
name|deltas
index|[
name|j
index|]
argument_list|,
name|apply
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|point_count
condition|;
operator|++
name|j
control|)
block|{
name|int
name|pindex
init|=
name|localpoints
index|[
name|j
index|]
decl_stmt|;
name|face
operator|->
name|cvt
index|[
name|pindex
index|]
operator|=
call|(
name|FT_Short
call|)
argument_list|(
name|face
operator|->
name|cvt
index|[
name|pindex
index|]
operator|+
name|FT_MulFix
argument_list|(
name|deltas
index|[
name|j
index|]
argument_list|,
name|apply
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|localpoints
operator|!=
name|ALL_POINTS
condition|)
name|FT_FREE
argument_list|(
name|localpoints
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|deltas
argument_list|)
expr_stmt|;
name|offsetToData
operator|+=
name|tupleDataSize
expr_stmt|;
name|FT_Stream_SeekSet
argument_list|(
name|stream
argument_list|,
name|here
argument_list|)
expr_stmt|;
block|}
name|FExit
label|:
name|FT_FRAME_EXIT
argument_list|()
expr_stmt|;
name|Exit
label|:
name|FT_FREE
argument_list|(
name|tuple_coords
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|im_start_coords
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|im_end_coords
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    TT_Vary_Get_Glyph_Deltas                                           */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Load the appropriate deltas for the current glyph.                 */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    face        :: A handle to the target face object.                 */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    glyph_index :: The index of the glyph being modified.              */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    n_points    :: The number of the points in the glyph, including    */
end_comment
begin_comment
comment|/*                   phantom points.                                     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Output>                                                              */
end_comment
begin_comment
comment|/*    deltas      :: The array of points to change.                      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    FreeType error code.  0 means success.                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|TT_Vary_Get_Glyph_Deltas
argument_list|(
argument|TT_Face      face
argument_list|,
argument|FT_UInt      glyph_index
argument_list|,
argument|FT_Vector*  *deltas
argument_list|,
argument|FT_UInt      n_points
argument_list|)
end_macro
begin_block
block|{
name|FT_Stream
name|stream
init|=
name|face
operator|->
name|root
operator|.
name|stream
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|stream
operator|->
name|memory
decl_stmt|;
name|GX_Blend
name|blend
init|=
name|face
operator|->
name|blend
decl_stmt|;
name|FT_Vector
modifier|*
name|delta_xy
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|FT_ULong
name|glyph_start
decl_stmt|;
name|FT_UInt
name|tupleCount
decl_stmt|;
name|FT_ULong
name|offsetToData
decl_stmt|;
name|FT_ULong
name|here
decl_stmt|;
name|FT_UInt
name|i
decl_stmt|,
name|j
decl_stmt|;
name|FT_Fixed
modifier|*
name|tuple_coords
init|=
name|NULL
decl_stmt|;
name|FT_Fixed
modifier|*
name|im_start_coords
init|=
name|NULL
decl_stmt|;
name|FT_Fixed
modifier|*
name|im_end_coords
init|=
name|NULL
decl_stmt|;
name|FT_UInt
name|point_count
decl_stmt|,
name|spoint_count
init|=
literal|0
decl_stmt|;
name|FT_UShort
modifier|*
name|sharedpoints
init|=
name|NULL
decl_stmt|;
name|FT_UShort
modifier|*
name|localpoints
init|=
name|NULL
decl_stmt|;
name|FT_UShort
modifier|*
name|points
decl_stmt|;
name|FT_Short
modifier|*
name|deltas_x
decl_stmt|,
modifier|*
name|deltas_y
decl_stmt|;
if|if
condition|(
operator|!
name|face
operator|->
name|doblend
operator|||
name|blend
operator|==
name|NULL
condition|)
return|return
name|TT_Err_Invalid_Argument
return|;
comment|/* to be freed by the caller */
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|delta_xy
argument_list|,
name|n_points
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
operator|*
name|deltas
operator|=
name|delta_xy
expr_stmt|;
if|if
condition|(
name|glyph_index
operator|>=
name|blend
operator|->
name|gv_glyphcnt
operator|||
name|blend
operator|->
name|glyphoffsets
index|[
name|glyph_index
index|]
operator|==
name|blend
operator|->
name|glyphoffsets
index|[
name|glyph_index
operator|+
literal|1
index|]
condition|)
return|return
name|TT_Err_Ok
return|;
comment|/* no variation data for this glyph */
if|if
condition|(
name|FT_STREAM_SEEK
argument_list|(
name|blend
operator|->
name|glyphoffsets
index|[
name|glyph_index
index|]
argument_list|)
operator|||
name|FT_FRAME_ENTER
argument_list|(
name|blend
operator|->
name|glyphoffsets
index|[
name|glyph_index
operator|+
literal|1
index|]
operator|-
name|blend
operator|->
name|glyphoffsets
index|[
name|glyph_index
index|]
argument_list|)
condition|)
goto|goto
name|Fail1
goto|;
name|glyph_start
operator|=
name|FT_Stream_FTell
argument_list|(
name|stream
argument_list|)
expr_stmt|;
comment|/* each set of glyph variation data is formatted similarly to `cvar' */
comment|/* (except we get shared points and global tuples)                   */
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|tuple_coords
argument_list|,
name|blend
operator|->
name|num_axis
argument_list|)
operator|||
name|FT_NEW_ARRAY
argument_list|(
name|im_start_coords
argument_list|,
name|blend
operator|->
name|num_axis
argument_list|)
operator|||
name|FT_NEW_ARRAY
argument_list|(
name|im_end_coords
argument_list|,
name|blend
operator|->
name|num_axis
argument_list|)
condition|)
goto|goto
name|Fail2
goto|;
name|tupleCount
operator|=
name|FT_GET_USHORT
argument_list|()
expr_stmt|;
name|offsetToData
operator|=
name|glyph_start
operator|+
name|FT_GET_USHORT
argument_list|()
expr_stmt|;
if|if
condition|(
name|tupleCount
operator|&
name|GX_TC_TUPLES_SHARE_POINT_NUMBERS
condition|)
block|{
name|here
operator|=
name|FT_Stream_FTell
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|FT_Stream_SeekSet
argument_list|(
name|stream
argument_list|,
name|offsetToData
argument_list|)
expr_stmt|;
name|sharedpoints
operator|=
name|ft_var_readpackedpoints
argument_list|(
name|stream
argument_list|,
operator|&
name|spoint_count
argument_list|)
expr_stmt|;
name|offsetToData
operator|=
name|FT_Stream_FTell
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|FT_Stream_SeekSet
argument_list|(
name|stream
argument_list|,
name|here
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|tupleCount
operator|&
name|GX_TC_TUPLE_COUNT_MASK
operator|)
condition|;
operator|++
name|i
control|)
block|{
name|FT_UInt
name|tupleDataSize
decl_stmt|;
name|FT_UInt
name|tupleIndex
decl_stmt|;
name|FT_Fixed
name|apply
decl_stmt|;
name|tupleDataSize
operator|=
name|FT_GET_USHORT
argument_list|()
expr_stmt|;
name|tupleIndex
operator|=
name|FT_GET_USHORT
argument_list|()
expr_stmt|;
if|if
condition|(
name|tupleIndex
operator|&
name|GX_TI_EMBEDDED_TUPLE_COORD
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|blend
operator|->
name|num_axis
condition|;
operator|++
name|j
control|)
name|tuple_coords
index|[
name|j
index|]
operator|=
name|FT_GET_SHORT
argument_list|()
operator|<<
literal|2
expr_stmt|;
comment|/* convert from        */
comment|/* short frac to fixed */
block|}
elseif|else
if|if
condition|(
operator|(
name|tupleIndex
operator|&
name|GX_TI_TUPLE_INDEX_MASK
operator|)
operator|>=
name|blend
operator|->
name|tuplecount
condition|)
block|{
name|error
operator|=
name|TT_Err_Invalid_Table
expr_stmt|;
goto|goto
name|Fail3
goto|;
block|}
else|else
block|{
name|FT_MEM_COPY
argument_list|(
name|tuple_coords
argument_list|,
operator|&
name|blend
operator|->
name|tuplecoords
index|[
operator|(
name|tupleIndex
operator|&
literal|0xFFF
operator|)
operator|*
name|blend
operator|->
name|num_axis
index|]
argument_list|,
name|blend
operator|->
name|num_axis
operator|*
sizeof|sizeof
argument_list|(
name|FT_Fixed
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tupleIndex
operator|&
name|GX_TI_INTERMEDIATE_TUPLE
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|blend
operator|->
name|num_axis
condition|;
operator|++
name|j
control|)
name|im_start_coords
index|[
name|j
index|]
operator|=
name|FT_GET_SHORT
argument_list|()
operator|<<
literal|2
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|blend
operator|->
name|num_axis
condition|;
operator|++
name|j
control|)
name|im_end_coords
index|[
name|j
index|]
operator|=
name|FT_GET_SHORT
argument_list|()
operator|<<
literal|2
expr_stmt|;
block|}
name|apply
operator|=
name|ft_var_apply_tuple
argument_list|(
name|blend
argument_list|,
operator|(
name|FT_UShort
operator|)
name|tupleIndex
argument_list|,
name|tuple_coords
argument_list|,
name|im_start_coords
argument_list|,
name|im_end_coords
argument_list|)
expr_stmt|;
if|if
condition|(
name|apply
operator|==
literal|0
condition|)
comment|/* tuple isn't active for our blend */
block|{
name|offsetToData
operator|+=
name|tupleDataSize
expr_stmt|;
continue|continue;
block|}
name|here
operator|=
name|FT_Stream_FTell
argument_list|(
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|tupleIndex
operator|&
name|GX_TI_PRIVATE_POINT_NUMBERS
condition|)
block|{
name|FT_Stream_SeekSet
argument_list|(
name|stream
argument_list|,
name|offsetToData
argument_list|)
expr_stmt|;
name|localpoints
operator|=
name|ft_var_readpackedpoints
argument_list|(
name|stream
argument_list|,
operator|&
name|point_count
argument_list|)
expr_stmt|;
name|points
operator|=
name|localpoints
expr_stmt|;
block|}
else|else
block|{
name|points
operator|=
name|sharedpoints
expr_stmt|;
name|point_count
operator|=
name|spoint_count
expr_stmt|;
block|}
name|deltas_x
operator|=
name|ft_var_readpackeddeltas
argument_list|(
name|stream
argument_list|,
name|point_count
operator|==
literal|0
condition|?
name|n_points
else|:
name|point_count
argument_list|)
expr_stmt|;
name|deltas_y
operator|=
name|ft_var_readpackeddeltas
argument_list|(
name|stream
argument_list|,
name|point_count
operator|==
literal|0
condition|?
name|n_points
else|:
name|point_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|points
operator|==
name|NULL
operator|||
name|deltas_y
operator|==
name|NULL
operator|||
name|deltas_x
operator|==
name|NULL
condition|)
empty_stmt|;
comment|/* failure, ignore it */
elseif|else
if|if
condition|(
name|points
operator|==
name|ALL_POINTS
condition|)
block|{
comment|/* this means that there are deltas for every point in the glyph */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_points
condition|;
operator|++
name|j
control|)
block|{
name|delta_xy
index|[
name|j
index|]
operator|.
name|x
operator|+=
name|FT_MulFix
argument_list|(
name|deltas_x
index|[
name|j
index|]
argument_list|,
name|apply
argument_list|)
expr_stmt|;
name|delta_xy
index|[
name|j
index|]
operator|.
name|y
operator|+=
name|FT_MulFix
argument_list|(
name|deltas_y
index|[
name|j
index|]
argument_list|,
name|apply
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|point_count
condition|;
operator|++
name|j
control|)
block|{
name|delta_xy
index|[
name|localpoints
index|[
name|j
index|]
index|]
operator|.
name|x
operator|+=
name|FT_MulFix
argument_list|(
name|deltas_x
index|[
name|j
index|]
argument_list|,
name|apply
argument_list|)
expr_stmt|;
name|delta_xy
index|[
name|localpoints
index|[
name|j
index|]
index|]
operator|.
name|y
operator|+=
name|FT_MulFix
argument_list|(
name|deltas_y
index|[
name|j
index|]
argument_list|,
name|apply
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|localpoints
operator|!=
name|ALL_POINTS
condition|)
name|FT_FREE
argument_list|(
name|localpoints
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|deltas_x
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|deltas_y
argument_list|)
expr_stmt|;
name|offsetToData
operator|+=
name|tupleDataSize
expr_stmt|;
name|FT_Stream_SeekSet
argument_list|(
name|stream
argument_list|,
name|here
argument_list|)
expr_stmt|;
block|}
name|Fail3
label|:
name|FT_FREE
argument_list|(
name|tuple_coords
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|im_start_coords
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|im_end_coords
argument_list|)
expr_stmt|;
name|Fail2
label|:
name|FT_FRAME_EXIT
argument_list|()
expr_stmt|;
name|Fail1
label|:
if|if
condition|(
name|error
condition|)
block|{
name|FT_FREE
argument_list|(
name|delta_xy
argument_list|)
expr_stmt|;
operator|*
name|deltas
operator|=
name|NULL
expr_stmt|;
block|}
name|Exit
label|:
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    tt_done_blend                                                      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Frees the blend internal data structure.                           */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|tt_done_blend
name|tt_done_blend
argument_list|(
argument|FT_Memory  memory
argument_list|,
argument|GX_Blend   blend
argument_list|)
end_macro
begin_block
block|{
if|if
condition|(
name|blend
operator|!=
name|NULL
condition|)
block|{
name|FT_UInt
name|i
decl_stmt|;
name|FT_FREE
argument_list|(
name|blend
operator|->
name|normalizedcoords
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|blend
operator|->
name|mmvar
argument_list|)
expr_stmt|;
if|if
condition|(
name|blend
operator|->
name|avar_segment
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|blend
operator|->
name|num_axis
condition|;
operator|++
name|i
control|)
name|FT_FREE
argument_list|(
name|blend
operator|->
name|avar_segment
index|[
name|i
index|]
operator|.
name|correspondence
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|blend
operator|->
name|avar_segment
argument_list|)
expr_stmt|;
block|}
name|FT_FREE
argument_list|(
name|blend
operator|->
name|tuplecoords
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|blend
operator|->
name|glyphoffsets
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|blend
argument_list|)
expr_stmt|;
block|}
block|}
end_block
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* TT_CONFIG_OPTION_GX_VAR_SUPPORT */
end_comment
begin_comment
comment|/* END */
end_comment
end_unit
