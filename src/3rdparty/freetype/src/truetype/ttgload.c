begin_unit
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  ttgload.c                                                              */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*    TrueType Glyph Loader (body).                                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  Copyright 1996-2014                                                    */
end_comment
begin_comment
comment|/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  This file is part of the FreeType project, and may only be used,       */
end_comment
begin_comment
comment|/*  modified, and distributed under the terms of the FreeType project      */
end_comment
begin_comment
comment|/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
end_comment
begin_comment
comment|/*  this file you indicate that you have read the license and              */
end_comment
begin_comment
comment|/*  understand and accept it fully.                                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<ft2build.h>
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_DEBUG_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_CALC_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_STREAM_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_SFNT_H
end_include
begin_include
include|#
directive|include
include|FT_TRUETYPE_TAGS_H
end_include
begin_include
include|#
directive|include
include|FT_OUTLINE_H
end_include
begin_include
include|#
directive|include
include|FT_TRUETYPE_DRIVER_H
end_include
begin_include
include|#
directive|include
file|"ttgload.h"
end_include
begin_include
include|#
directive|include
file|"ttpload.h"
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_GX_VAR_SUPPORT
end_ifdef
begin_include
include|#
directive|include
file|"ttgxvar.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|"tterrors.h"
end_include
begin_include
include|#
directive|include
file|"ttsubpix.h"
end_include
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
end_comment
begin_comment
comment|/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
end_comment
begin_comment
comment|/* messages during execution.                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_undef
DECL|macro|FT_COMPONENT
undef|#
directive|undef
name|FT_COMPONENT
end_undef
begin_define
DECL|macro|FT_COMPONENT
define|#
directive|define
name|FT_COMPONENT
value|trace_ttgload
end_define
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* Composite glyph flags.                                                */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_define
DECL|macro|ARGS_ARE_WORDS
define|#
directive|define
name|ARGS_ARE_WORDS
value|0x0001
end_define
begin_define
DECL|macro|ARGS_ARE_XY_VALUES
define|#
directive|define
name|ARGS_ARE_XY_VALUES
value|0x0002
end_define
begin_define
DECL|macro|ROUND_XY_TO_GRID
define|#
directive|define
name|ROUND_XY_TO_GRID
value|0x0004
end_define
begin_define
DECL|macro|WE_HAVE_A_SCALE
define|#
directive|define
name|WE_HAVE_A_SCALE
value|0x0008
end_define
begin_comment
comment|/* reserved                        0x0010 */
end_comment
begin_define
DECL|macro|MORE_COMPONENTS
define|#
directive|define
name|MORE_COMPONENTS
value|0x0020
end_define
begin_define
DECL|macro|WE_HAVE_AN_XY_SCALE
define|#
directive|define
name|WE_HAVE_AN_XY_SCALE
value|0x0040
end_define
begin_define
DECL|macro|WE_HAVE_A_2X2
define|#
directive|define
name|WE_HAVE_A_2X2
value|0x0080
end_define
begin_define
DECL|macro|WE_HAVE_INSTR
define|#
directive|define
name|WE_HAVE_INSTR
value|0x0100
end_define
begin_define
DECL|macro|USE_MY_METRICS
define|#
directive|define
name|USE_MY_METRICS
value|0x0200
end_define
begin_define
DECL|macro|OVERLAP_COMPOUND
define|#
directive|define
name|OVERLAP_COMPOUND
value|0x0400
end_define
begin_define
DECL|macro|SCALED_COMPONENT_OFFSET
define|#
directive|define
name|SCALED_COMPONENT_OFFSET
value|0x0800
end_define
begin_define
DECL|macro|UNSCALED_COMPONENT_OFFSET
define|#
directive|define
name|UNSCALED_COMPONENT_OFFSET
value|0x1000
end_define
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* Return the horizontal metrics in font units for a given glyph.        */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|TT_Get_HMetrics
name|TT_Get_HMetrics
argument_list|(
argument|TT_Face     face
argument_list|,
argument|FT_UInt     idx
argument_list|,
argument|FT_Short*   lsb
argument_list|,
argument|FT_UShort*  aw
argument_list|)
end_macro
begin_block
block|{
operator|(
operator|(
name|SFNT_Service
operator|)
name|face
operator|->
name|sfnt
operator|)
operator|->
name|get_metrics
argument_list|(
name|face
argument_list|,
literal|0
argument_list|,
name|idx
argument_list|,
name|lsb
argument_list|,
name|aw
argument_list|)
expr_stmt|;
name|FT_TRACE5
argument_list|(
operator|(
literal|"  advance width (font units): %d\n"
operator|,
operator|*
name|aw
operator|)
argument_list|)
expr_stmt|;
name|FT_TRACE5
argument_list|(
operator|(
literal|"  left side bearing (font units): %d\n"
operator|,
operator|*
name|lsb
operator|)
argument_list|)
expr_stmt|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* Return the vertical metrics in font units for a given glyph.          */
end_comment
begin_comment
comment|/* See macro `TT_LOADER_SET_PP' below for explanations.                  */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|TT_Get_VMetrics
name|TT_Get_VMetrics
argument_list|(
argument|TT_Face     face
argument_list|,
argument|FT_UInt     idx
argument_list|,
argument|FT_Pos      yMax
argument_list|,
argument|FT_Short*   tsb
argument_list|,
argument|FT_UShort*  ah
argument_list|)
end_macro
begin_block
block|{
if|if
condition|(
name|face
operator|->
name|vertical_info
condition|)
operator|(
operator|(
name|SFNT_Service
operator|)
name|face
operator|->
name|sfnt
operator|)
operator|->
name|get_metrics
argument_list|(
name|face
argument_list|,
literal|1
argument_list|,
name|idx
argument_list|,
name|tsb
argument_list|,
name|ah
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|face
operator|->
name|os2
operator|.
name|version
operator|!=
literal|0xFFFFU
condition|)
block|{
operator|*
name|tsb
operator|=
call|(
name|FT_Short
call|)
argument_list|(
name|face
operator|->
name|os2
operator|.
name|sTypoAscender
operator|-
name|yMax
argument_list|)
expr_stmt|;
operator|*
name|ah
operator|=
name|face
operator|->
name|os2
operator|.
name|sTypoAscender
operator|-
name|face
operator|->
name|os2
operator|.
name|sTypoDescender
expr_stmt|;
block|}
else|else
block|{
operator|*
name|tsb
operator|=
call|(
name|FT_Short
call|)
argument_list|(
name|face
operator|->
name|horizontal
operator|.
name|Ascender
operator|-
name|yMax
argument_list|)
expr_stmt|;
operator|*
name|ah
operator|=
name|face
operator|->
name|horizontal
operator|.
name|Ascender
operator|-
name|face
operator|->
name|horizontal
operator|.
name|Descender
expr_stmt|;
block|}
name|FT_TRACE5
argument_list|(
operator|(
literal|"  advance height (font units): %d\n"
operator|,
operator|*
name|ah
operator|)
argument_list|)
expr_stmt|;
name|FT_TRACE5
argument_list|(
operator|(
literal|"  top side bearing (font units): %d\n"
operator|,
operator|*
name|tsb
operator|)
argument_list|)
expr_stmt|;
block|}
end_block
begin_function
specifier|static
name|FT_Error
DECL|function|tt_get_metrics
name|tt_get_metrics
parameter_list|(
name|TT_Loader
name|loader
parameter_list|,
name|FT_UInt
name|glyph_index
parameter_list|)
block|{
name|TT_Face
name|face
init|=
operator|(
name|TT_Face
operator|)
name|loader
operator|->
name|face
decl_stmt|;
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_SUBPIXEL_HINTING
name|TT_Driver
name|driver
init|=
operator|(
name|TT_Driver
operator|)
name|FT_FACE_DRIVER
argument_list|(
name|face
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|FT_Error
name|error
decl_stmt|;
name|FT_Stream
name|stream
init|=
name|loader
operator|->
name|stream
decl_stmt|;
name|FT_Short
name|left_bearing
init|=
literal|0
decl_stmt|,
name|top_bearing
init|=
literal|0
decl_stmt|;
name|FT_UShort
name|advance_width
init|=
literal|0
decl_stmt|,
name|advance_height
init|=
literal|0
decl_stmt|;
comment|/* we must preserve the stream position          */
comment|/* (which gets altered by the metrics functions) */
name|FT_ULong
name|pos
init|=
name|FT_STREAM_POS
argument_list|()
decl_stmt|;
name|TT_Get_HMetrics
argument_list|(
name|face
argument_list|,
name|glyph_index
argument_list|,
operator|&
name|left_bearing
argument_list|,
operator|&
name|advance_width
argument_list|)
expr_stmt|;
name|TT_Get_VMetrics
argument_list|(
name|face
argument_list|,
name|glyph_index
argument_list|,
name|loader
operator|->
name|bbox
operator|.
name|yMax
argument_list|,
operator|&
name|top_bearing
argument_list|,
operator|&
name|advance_height
argument_list|)
expr_stmt|;
if|if
condition|(
name|FT_STREAM_SEEK
argument_list|(
name|pos
argument_list|)
condition|)
return|return
name|error
return|;
name|loader
operator|->
name|left_bearing
operator|=
name|left_bearing
expr_stmt|;
name|loader
operator|->
name|advance
operator|=
name|advance_width
expr_stmt|;
name|loader
operator|->
name|top_bearing
operator|=
name|top_bearing
expr_stmt|;
name|loader
operator|->
name|vadvance
operator|=
name|advance_height
expr_stmt|;
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_SUBPIXEL_HINTING
if|if
condition|(
name|driver
operator|->
name|interpreter_version
operator|==
name|TT_INTERPRETER_VERSION_38
condition|)
block|{
if|if
condition|(
name|loader
operator|->
name|exec
condition|)
name|loader
operator|->
name|exec
operator|->
name|sph_tweak_flags
operator|=
literal|0
expr_stmt|;
comment|/* this may not be the right place for this, but it works */
if|if
condition|(
name|loader
operator|->
name|exec
operator|&&
name|loader
operator|->
name|exec
operator|->
name|ignore_x_mode
condition|)
name|sph_set_tweaks
argument_list|(
name|loader
argument_list|,
name|glyph_index
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
if|if
condition|(
operator|!
name|loader
operator|->
name|linear_def
condition|)
block|{
name|loader
operator|->
name|linear_def
operator|=
literal|1
expr_stmt|;
name|loader
operator|->
name|linear
operator|=
name|advance_width
expr_stmt|;
block|}
return|return
name|FT_Err_Ok
return|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|FT_CONFIG_OPTION_INCREMENTAL
end_ifdef
begin_function
specifier|static
name|void
DECL|function|tt_get_metrics_incr_overrides
name|tt_get_metrics_incr_overrides
parameter_list|(
name|TT_Loader
name|loader
parameter_list|,
name|FT_UInt
name|glyph_index
parameter_list|)
block|{
name|TT_Face
name|face
init|=
operator|(
name|TT_Face
operator|)
name|loader
operator|->
name|face
decl_stmt|;
name|FT_Short
name|left_bearing
init|=
literal|0
decl_stmt|,
name|top_bearing
init|=
literal|0
decl_stmt|;
name|FT_UShort
name|advance_width
init|=
literal|0
decl_stmt|,
name|advance_height
init|=
literal|0
decl_stmt|;
comment|/* If this is an incrementally loaded font check whether there are */
comment|/* overriding metrics for this glyph.                              */
if|if
condition|(
name|face
operator|->
name|root
operator|.
name|internal
operator|->
name|incremental_interface
operator|&&
name|face
operator|->
name|root
operator|.
name|internal
operator|->
name|incremental_interface
operator|->
name|funcs
operator|->
name|get_glyph_metrics
condition|)
block|{
name|FT_Incremental_MetricsRec
name|metrics
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|metrics
operator|.
name|bearing_x
operator|=
name|loader
operator|->
name|left_bearing
expr_stmt|;
name|metrics
operator|.
name|bearing_y
operator|=
literal|0
expr_stmt|;
name|metrics
operator|.
name|advance
operator|=
name|loader
operator|->
name|advance
expr_stmt|;
name|metrics
operator|.
name|advance_v
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|face
operator|->
name|root
operator|.
name|internal
operator|->
name|incremental_interface
operator|->
name|funcs
operator|->
name|get_glyph_metrics
argument_list|(
name|face
operator|->
name|root
operator|.
name|internal
operator|->
name|incremental_interface
operator|->
name|object
argument_list|,
name|glyph_index
argument_list|,
name|FALSE
argument_list|,
operator|&
name|metrics
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|left_bearing
operator|=
operator|(
name|FT_Short
operator|)
name|metrics
operator|.
name|bearing_x
expr_stmt|;
name|advance_width
operator|=
operator|(
name|FT_UShort
operator|)
name|metrics
operator|.
name|advance
expr_stmt|;
if|#
directive|if
literal|0
comment|/* GWW: Do I do the same for vertical metrics? */
block|metrics.bearing_x = 0;       metrics.bearing_y = loader->top_bearing;       metrics.advance   = loader->vadvance;        error = face->root.internal->incremental_interface->funcs->get_glyph_metrics(                 face->root.internal->incremental_interface->object,                 glyph_index, TRUE,&metrics );       if ( error )         goto Exit;        top_bearing    = (FT_Short)metrics.bearing_y;       advance_height = (FT_UShort)metrics.advance;
endif|#
directive|endif
comment|/* 0 */
name|loader
operator|->
name|left_bearing
operator|=
name|left_bearing
expr_stmt|;
name|loader
operator|->
name|advance
operator|=
name|advance_width
expr_stmt|;
name|loader
operator|->
name|top_bearing
operator|=
name|top_bearing
expr_stmt|;
name|loader
operator|->
name|vadvance
operator|=
name|advance_height
expr_stmt|;
if|if
condition|(
operator|!
name|loader
operator|->
name|linear_def
condition|)
block|{
name|loader
operator|->
name|linear_def
operator|=
literal|1
expr_stmt|;
name|loader
operator|->
name|linear
operator|=
name|advance_width
expr_stmt|;
block|}
block|}
name|Exit
label|:
return|return;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* FT_CONFIG_OPTION_INCREMENTAL */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* Translates an array of coordinates.                                   */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|translate_array
name|translate_array
parameter_list|(
name|FT_UInt
name|n
parameter_list|,
name|FT_Vector
modifier|*
name|coords
parameter_list|,
name|FT_Pos
name|delta_x
parameter_list|,
name|FT_Pos
name|delta_y
parameter_list|)
block|{
name|FT_UInt
name|k
decl_stmt|;
if|if
condition|(
name|delta_x
condition|)
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|n
condition|;
name|k
operator|++
control|)
name|coords
index|[
name|k
index|]
operator|.
name|x
operator|+=
name|delta_x
expr_stmt|;
if|if
condition|(
name|delta_y
condition|)
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|n
condition|;
name|k
operator|++
control|)
name|coords
index|[
name|k
index|]
operator|.
name|y
operator|+=
name|delta_y
expr_stmt|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* The following functions are used by default with TrueType fonts.      */
end_comment
begin_comment
comment|/* However, they can be replaced by alternatives if we need to support   */
end_comment
begin_comment
comment|/* TrueType-compressed formats (like MicroType) in the future.           */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|TT_Access_Glyph_Frame
argument_list|(
argument|TT_Loader  loader
argument_list|,
argument|FT_UInt    glyph_index
argument_list|,
argument|FT_ULong   offset
argument_list|,
argument|FT_UInt    byte_count
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
decl_stmt|;
name|FT_Stream
name|stream
init|=
name|loader
operator|->
name|stream
decl_stmt|;
comment|/* for non-debug mode */
name|FT_UNUSED
argument_list|(
name|glyph_index
argument_list|)
expr_stmt|;
name|FT_TRACE4
argument_list|(
operator|(
literal|"Glyph %ld\n"
operator|,
name|glyph_index
operator|)
argument_list|)
expr_stmt|;
comment|/* the following line sets the `error' variable through macros! */
if|if
condition|(
name|FT_STREAM_SEEK
argument_list|(
name|offset
argument_list|)
operator|||
name|FT_FRAME_ENTER
argument_list|(
name|byte_count
argument_list|)
condition|)
return|return
name|error
return|;
name|loader
operator|->
name|cursor
operator|=
name|stream
operator|->
name|cursor
expr_stmt|;
name|loader
operator|->
name|limit
operator|=
name|stream
operator|->
name|limit
expr_stmt|;
return|return
name|FT_Err_Ok
return|;
block|}
end_block
begin_macro
name|FT_CALLBACK_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|TT_Forget_Glyph_Frame
name|TT_Forget_Glyph_Frame
argument_list|(
argument|TT_Loader  loader
argument_list|)
end_macro
begin_block
block|{
name|FT_Stream
name|stream
init|=
name|loader
operator|->
name|stream
decl_stmt|;
name|FT_FRAME_EXIT
argument_list|()
expr_stmt|;
block|}
end_block
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|TT_Load_Glyph_Header
argument_list|(
argument|TT_Loader  loader
argument_list|)
end_macro
begin_block
block|{
name|FT_Byte
modifier|*
name|p
init|=
name|loader
operator|->
name|cursor
decl_stmt|;
name|FT_Byte
modifier|*
name|limit
init|=
name|loader
operator|->
name|limit
decl_stmt|;
if|if
condition|(
name|p
operator|+
literal|10
operator|>
name|limit
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_Outline
argument_list|)
return|;
name|loader
operator|->
name|n_contours
operator|=
name|FT_NEXT_SHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|loader
operator|->
name|bbox
operator|.
name|xMin
operator|=
name|FT_NEXT_SHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|loader
operator|->
name|bbox
operator|.
name|yMin
operator|=
name|FT_NEXT_SHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|loader
operator|->
name|bbox
operator|.
name|xMax
operator|=
name|FT_NEXT_SHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|loader
operator|->
name|bbox
operator|.
name|yMax
operator|=
name|FT_NEXT_SHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|FT_TRACE5
argument_list|(
operator|(
literal|"  # of contours: %d\n"
operator|,
name|loader
operator|->
name|n_contours
operator|)
argument_list|)
expr_stmt|;
name|FT_TRACE5
argument_list|(
operator|(
literal|"  xMin: %4d  xMax: %4d\n"
operator|,
name|loader
operator|->
name|bbox
operator|.
name|xMin
operator|,
name|loader
operator|->
name|bbox
operator|.
name|xMax
operator|)
argument_list|)
expr_stmt|;
name|FT_TRACE5
argument_list|(
operator|(
literal|"  yMin: %4d  yMax: %4d\n"
operator|,
name|loader
operator|->
name|bbox
operator|.
name|yMin
operator|,
name|loader
operator|->
name|bbox
operator|.
name|yMax
operator|)
argument_list|)
expr_stmt|;
name|loader
operator|->
name|cursor
operator|=
name|p
expr_stmt|;
return|return
name|FT_Err_Ok
return|;
block|}
end_block
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|TT_Load_Simple_Glyph
argument_list|(
argument|TT_Loader  load
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
decl_stmt|;
name|FT_Byte
modifier|*
name|p
init|=
name|load
operator|->
name|cursor
decl_stmt|;
name|FT_Byte
modifier|*
name|limit
init|=
name|load
operator|->
name|limit
decl_stmt|;
name|FT_GlyphLoader
name|gloader
init|=
name|load
operator|->
name|gloader
decl_stmt|;
name|FT_Int
name|n_contours
init|=
name|load
operator|->
name|n_contours
decl_stmt|;
name|FT_Outline
modifier|*
name|outline
decl_stmt|;
name|FT_UShort
name|n_ins
decl_stmt|;
name|FT_Int
name|n_points
decl_stmt|;
name|FT_ULong
name|tmp
decl_stmt|;
name|FT_Byte
modifier|*
name|flag
decl_stmt|,
modifier|*
name|flag_limit
decl_stmt|;
name|FT_Byte
name|c
decl_stmt|,
name|count
decl_stmt|;
name|FT_Vector
modifier|*
name|vec
decl_stmt|,
modifier|*
name|vec_limit
decl_stmt|;
name|FT_Pos
name|x
decl_stmt|;
name|FT_Short
modifier|*
name|cont
decl_stmt|,
modifier|*
name|cont_limit
decl_stmt|,
name|prev_cont
decl_stmt|;
name|FT_Int
name|xy_size
init|=
literal|0
decl_stmt|;
comment|/* check that we can add the contours to the glyph */
name|error
operator|=
name|FT_GLYPHLOADER_CHECK_POINTS
argument_list|(
name|gloader
argument_list|,
literal|0
argument_list|,
name|n_contours
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Fail
goto|;
comment|/* reading the contours' endpoints& number of points */
name|cont
operator|=
name|gloader
operator|->
name|current
operator|.
name|outline
operator|.
name|contours
expr_stmt|;
name|cont_limit
operator|=
name|cont
operator|+
name|n_contours
expr_stmt|;
comment|/* check space for contours array + instructions count */
if|if
condition|(
name|n_contours
operator|>=
literal|0xFFF
operator|||
name|p
operator|+
operator|(
name|n_contours
operator|+
literal|1
operator|)
operator|*
literal|2
operator|>
name|limit
condition|)
goto|goto
name|Invalid_Outline
goto|;
name|prev_cont
operator|=
name|FT_NEXT_SHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_contours
operator|>
literal|0
condition|)
name|cont
index|[
literal|0
index|]
operator|=
name|prev_cont
expr_stmt|;
if|if
condition|(
name|prev_cont
operator|<
literal|0
condition|)
goto|goto
name|Invalid_Outline
goto|;
for|for
control|(
name|cont
operator|++
init|;
name|cont
operator|<
name|cont_limit
condition|;
name|cont
operator|++
control|)
block|{
name|cont
index|[
literal|0
index|]
operator|=
name|FT_NEXT_SHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|cont
index|[
literal|0
index|]
operator|<=
name|prev_cont
condition|)
block|{
comment|/* unordered contours: this is invalid */
goto|goto
name|Invalid_Outline
goto|;
block|}
name|prev_cont
operator|=
name|cont
index|[
literal|0
index|]
expr_stmt|;
block|}
name|n_points
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|n_contours
operator|>
literal|0
condition|)
block|{
name|n_points
operator|=
name|cont
index|[
operator|-
literal|1
index|]
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|n_points
operator|<
literal|0
condition|)
goto|goto
name|Invalid_Outline
goto|;
block|}
comment|/* note that we will add four phantom points later */
name|error
operator|=
name|FT_GLYPHLOADER_CHECK_POINTS
argument_list|(
name|gloader
argument_list|,
name|n_points
operator|+
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Fail
goto|;
comment|/* reading the bytecode instructions */
name|load
operator|->
name|glyph
operator|->
name|control_len
operator|=
literal|0
expr_stmt|;
name|load
operator|->
name|glyph
operator|->
name|control_data
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p
operator|+
literal|2
operator|>
name|limit
condition|)
goto|goto
name|Invalid_Outline
goto|;
name|n_ins
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|FT_TRACE5
argument_list|(
operator|(
literal|"  Instructions size: %u\n"
operator|,
name|n_ins
operator|)
argument_list|)
expr_stmt|;
comment|/* check it */
if|if
condition|(
operator|(
name|limit
operator|-
name|p
operator|)
operator|<
name|n_ins
condition|)
block|{
name|FT_TRACE0
argument_list|(
operator|(
literal|"TT_Load_Simple_Glyph: instruction count mismatch\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|FT_THROW
argument_list|(
name|Too_Many_Hints
argument_list|)
expr_stmt|;
goto|goto
name|Fail
goto|;
block|}
ifdef|#
directive|ifdef
name|TT_USE_BYTECODE_INTERPRETER
if|if
condition|(
name|IS_HINTED
argument_list|(
name|load
operator|->
name|load_flags
argument_list|)
condition|)
block|{
comment|/* we don't trust `maxSizeOfInstructions' in the `maxp' table */
comment|/* and thus update the bytecode array size by ourselves       */
name|tmp
operator|=
name|load
operator|->
name|exec
operator|->
name|glyphSize
expr_stmt|;
name|error
operator|=
name|Update_Max
argument_list|(
name|load
operator|->
name|exec
operator|->
name|memory
argument_list|,
operator|&
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|FT_Byte
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|load
operator|->
name|exec
operator|->
name|glyphIns
argument_list|,
name|n_ins
argument_list|)
expr_stmt|;
name|load
operator|->
name|exec
operator|->
name|glyphSize
operator|=
operator|(
name|FT_UShort
operator|)
name|tmp
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|load
operator|->
name|glyph
operator|->
name|control_len
operator|=
name|n_ins
expr_stmt|;
name|load
operator|->
name|glyph
operator|->
name|control_data
operator|=
name|load
operator|->
name|exec
operator|->
name|glyphIns
expr_stmt|;
name|FT_MEM_COPY
argument_list|(
name|load
operator|->
name|exec
operator|->
name|glyphIns
argument_list|,
name|p
argument_list|,
operator|(
name|FT_Long
operator|)
name|n_ins
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* TT_USE_BYTECODE_INTERPRETER */
name|p
operator|+=
name|n_ins
expr_stmt|;
name|outline
operator|=
operator|&
name|gloader
operator|->
name|current
operator|.
name|outline
expr_stmt|;
comment|/* reading the point tags */
name|flag
operator|=
operator|(
name|FT_Byte
operator|*
operator|)
name|outline
operator|->
name|tags
expr_stmt|;
name|flag_limit
operator|=
name|flag
operator|+
name|n_points
expr_stmt|;
name|FT_ASSERT
argument_list|(
name|flag
operator|!=
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
name|flag
operator|<
name|flag_limit
condition|)
block|{
if|if
condition|(
name|p
operator|+
literal|1
operator|>
name|limit
condition|)
goto|goto
name|Invalid_Outline
goto|;
operator|*
name|flag
operator|++
operator|=
name|c
operator|=
name|FT_NEXT_BYTE
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|&
literal|8
condition|)
block|{
if|if
condition|(
name|p
operator|+
literal|1
operator|>
name|limit
condition|)
goto|goto
name|Invalid_Outline
goto|;
name|count
operator|=
name|FT_NEXT_BYTE
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
operator|+
operator|(
name|FT_Int
operator|)
name|count
operator|>
name|flag_limit
condition|)
goto|goto
name|Invalid_Outline
goto|;
for|for
control|(
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
control|)
operator|*
name|flag
operator|++
operator|=
name|c
expr_stmt|;
block|}
block|}
comment|/* reading the X coordinates */
name|vec
operator|=
name|outline
operator|->
name|points
expr_stmt|;
name|vec_limit
operator|=
name|vec
operator|+
name|n_points
expr_stmt|;
name|flag
operator|=
operator|(
name|FT_Byte
operator|*
operator|)
name|outline
operator|->
name|tags
expr_stmt|;
name|x
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p
operator|+
name|xy_size
operator|>
name|limit
condition|)
goto|goto
name|Invalid_Outline
goto|;
for|for
control|(
init|;
name|vec
operator|<
name|vec_limit
condition|;
name|vec
operator|++
operator|,
name|flag
operator|++
control|)
block|{
name|FT_Pos
name|y
init|=
literal|0
decl_stmt|;
name|FT_Byte
name|f
init|=
operator|*
name|flag
decl_stmt|;
if|if
condition|(
name|f
operator|&
literal|2
condition|)
block|{
if|if
condition|(
name|p
operator|+
literal|1
operator|>
name|limit
condition|)
goto|goto
name|Invalid_Outline
goto|;
name|y
operator|=
operator|(
name|FT_Pos
operator|)
name|FT_NEXT_BYTE
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|f
operator|&
literal|16
operator|)
operator|==
literal|0
condition|)
name|y
operator|=
operator|-
name|y
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|f
operator|&
literal|16
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|p
operator|+
literal|2
operator|>
name|limit
condition|)
goto|goto
name|Invalid_Outline
goto|;
name|y
operator|=
operator|(
name|FT_Pos
operator|)
name|FT_NEXT_SHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|x
operator|+=
name|y
expr_stmt|;
name|vec
operator|->
name|x
operator|=
name|x
expr_stmt|;
comment|/* the cast is for stupid compilers */
operator|*
name|flag
operator|=
call|(
name|FT_Byte
call|)
argument_list|(
name|f
operator|&
operator|~
operator|(
literal|2
operator||
literal|16
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* reading the Y coordinates */
name|vec
operator|=
name|gloader
operator|->
name|current
operator|.
name|outline
operator|.
name|points
expr_stmt|;
name|vec_limit
operator|=
name|vec
operator|+
name|n_points
expr_stmt|;
name|flag
operator|=
operator|(
name|FT_Byte
operator|*
operator|)
name|outline
operator|->
name|tags
expr_stmt|;
name|x
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|vec
operator|<
name|vec_limit
condition|;
name|vec
operator|++
operator|,
name|flag
operator|++
control|)
block|{
name|FT_Pos
name|y
init|=
literal|0
decl_stmt|;
name|FT_Byte
name|f
init|=
operator|*
name|flag
decl_stmt|;
if|if
condition|(
name|f
operator|&
literal|4
condition|)
block|{
if|if
condition|(
name|p
operator|+
literal|1
operator|>
name|limit
condition|)
goto|goto
name|Invalid_Outline
goto|;
name|y
operator|=
operator|(
name|FT_Pos
operator|)
name|FT_NEXT_BYTE
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|f
operator|&
literal|32
operator|)
operator|==
literal|0
condition|)
name|y
operator|=
operator|-
name|y
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|f
operator|&
literal|32
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|p
operator|+
literal|2
operator|>
name|limit
condition|)
goto|goto
name|Invalid_Outline
goto|;
name|y
operator|=
operator|(
name|FT_Pos
operator|)
name|FT_NEXT_SHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|x
operator|+=
name|y
expr_stmt|;
name|vec
operator|->
name|y
operator|=
name|x
expr_stmt|;
comment|/* the cast is for stupid compilers */
operator|*
name|flag
operator|=
call|(
name|FT_Byte
call|)
argument_list|(
name|f
operator|&
name|FT_CURVE_TAG_ON
argument_list|)
expr_stmt|;
block|}
name|outline
operator|->
name|n_points
operator|=
operator|(
name|FT_UShort
operator|)
name|n_points
expr_stmt|;
name|outline
operator|->
name|n_contours
operator|=
operator|(
name|FT_Short
operator|)
name|n_contours
expr_stmt|;
name|load
operator|->
name|cursor
operator|=
name|p
expr_stmt|;
name|Fail
label|:
return|return
name|error
return|;
name|Invalid_Outline
label|:
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Outline
argument_list|)
expr_stmt|;
goto|goto
name|Fail
goto|;
block|}
end_block
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|TT_Load_Composite_Glyph
argument_list|(
argument|TT_Loader  loader
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
decl_stmt|;
name|FT_Byte
modifier|*
name|p
init|=
name|loader
operator|->
name|cursor
decl_stmt|;
name|FT_Byte
modifier|*
name|limit
init|=
name|loader
operator|->
name|limit
decl_stmt|;
name|FT_GlyphLoader
name|gloader
init|=
name|loader
operator|->
name|gloader
decl_stmt|;
name|FT_SubGlyph
name|subglyph
decl_stmt|;
name|FT_UInt
name|num_subglyphs
decl_stmt|;
name|num_subglyphs
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|FT_Fixed
name|xx
decl_stmt|,
name|xy
decl_stmt|,
name|yy
decl_stmt|,
name|yx
decl_stmt|;
name|FT_UInt
name|count
decl_stmt|;
comment|/* check that we can load a new subglyph */
name|error
operator|=
name|FT_GlyphLoader_CheckSubGlyphs
argument_list|(
name|gloader
argument_list|,
name|num_subglyphs
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Fail
goto|;
comment|/* check space */
if|if
condition|(
name|p
operator|+
literal|4
operator|>
name|limit
condition|)
goto|goto
name|Invalid_Composite
goto|;
name|subglyph
operator|=
name|gloader
operator|->
name|current
operator|.
name|subglyphs
operator|+
name|num_subglyphs
expr_stmt|;
name|subglyph
operator|->
name|arg1
operator|=
name|subglyph
operator|->
name|arg2
operator|=
literal|0
expr_stmt|;
name|subglyph
operator|->
name|flags
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|subglyph
operator|->
name|index
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* check space */
name|count
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|subglyph
operator|->
name|flags
operator|&
name|ARGS_ARE_WORDS
condition|)
name|count
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|subglyph
operator|->
name|flags
operator|&
name|WE_HAVE_A_SCALE
condition|)
name|count
operator|+=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|subglyph
operator|->
name|flags
operator|&
name|WE_HAVE_AN_XY_SCALE
condition|)
name|count
operator|+=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|subglyph
operator|->
name|flags
operator|&
name|WE_HAVE_A_2X2
condition|)
name|count
operator|+=
literal|8
expr_stmt|;
if|if
condition|(
name|p
operator|+
name|count
operator|>
name|limit
condition|)
goto|goto
name|Invalid_Composite
goto|;
comment|/* read arguments */
if|if
condition|(
name|subglyph
operator|->
name|flags
operator|&
name|ARGS_ARE_WORDS
condition|)
block|{
name|subglyph
operator|->
name|arg1
operator|=
name|FT_NEXT_SHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|subglyph
operator|->
name|arg2
operator|=
name|FT_NEXT_SHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|subglyph
operator|->
name|arg1
operator|=
name|FT_NEXT_CHAR
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|subglyph
operator|->
name|arg2
operator|=
name|FT_NEXT_CHAR
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
comment|/* read transform */
name|xx
operator|=
name|yy
operator|=
literal|0x10000L
expr_stmt|;
name|xy
operator|=
name|yx
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|subglyph
operator|->
name|flags
operator|&
name|WE_HAVE_A_SCALE
condition|)
block|{
name|xx
operator|=
operator|(
name|FT_Fixed
operator|)
name|FT_NEXT_SHORT
argument_list|(
name|p
argument_list|)
operator|<<
literal|2
expr_stmt|;
name|yy
operator|=
name|xx
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|subglyph
operator|->
name|flags
operator|&
name|WE_HAVE_AN_XY_SCALE
condition|)
block|{
name|xx
operator|=
operator|(
name|FT_Fixed
operator|)
name|FT_NEXT_SHORT
argument_list|(
name|p
argument_list|)
operator|<<
literal|2
expr_stmt|;
name|yy
operator|=
operator|(
name|FT_Fixed
operator|)
name|FT_NEXT_SHORT
argument_list|(
name|p
argument_list|)
operator|<<
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|subglyph
operator|->
name|flags
operator|&
name|WE_HAVE_A_2X2
condition|)
block|{
name|xx
operator|=
operator|(
name|FT_Fixed
operator|)
name|FT_NEXT_SHORT
argument_list|(
name|p
argument_list|)
operator|<<
literal|2
expr_stmt|;
name|yx
operator|=
operator|(
name|FT_Fixed
operator|)
name|FT_NEXT_SHORT
argument_list|(
name|p
argument_list|)
operator|<<
literal|2
expr_stmt|;
name|xy
operator|=
operator|(
name|FT_Fixed
operator|)
name|FT_NEXT_SHORT
argument_list|(
name|p
argument_list|)
operator|<<
literal|2
expr_stmt|;
name|yy
operator|=
operator|(
name|FT_Fixed
operator|)
name|FT_NEXT_SHORT
argument_list|(
name|p
argument_list|)
operator|<<
literal|2
expr_stmt|;
block|}
name|subglyph
operator|->
name|transform
operator|.
name|xx
operator|=
name|xx
expr_stmt|;
name|subglyph
operator|->
name|transform
operator|.
name|xy
operator|=
name|xy
expr_stmt|;
name|subglyph
operator|->
name|transform
operator|.
name|yx
operator|=
name|yx
expr_stmt|;
name|subglyph
operator|->
name|transform
operator|.
name|yy
operator|=
name|yy
expr_stmt|;
name|num_subglyphs
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|subglyph
operator|->
name|flags
operator|&
name|MORE_COMPONENTS
condition|)
do|;
name|gloader
operator|->
name|current
operator|.
name|num_subglyphs
operator|=
name|num_subglyphs
expr_stmt|;
ifdef|#
directive|ifdef
name|TT_USE_BYTECODE_INTERPRETER
block|{
name|FT_Stream
name|stream
init|=
name|loader
operator|->
name|stream
decl_stmt|;
comment|/* we must undo the FT_FRAME_ENTER in order to point */
comment|/* to the composite instructions, if we find some.   */
comment|/* We will process them later.                       */
comment|/*                                                   */
name|loader
operator|->
name|ins_pos
operator|=
call|(
name|FT_ULong
call|)
argument_list|(
name|FT_STREAM_POS
argument_list|()
operator|+
name|p
operator|-
name|limit
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|loader
operator|->
name|cursor
operator|=
name|p
expr_stmt|;
name|Fail
label|:
return|return
name|error
return|;
name|Invalid_Composite
label|:
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Composite
argument_list|)
expr_stmt|;
goto|goto
name|Fail
goto|;
block|}
end_block
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|TT_Init_Glyph_Loading
name|TT_Init_Glyph_Loading
argument_list|(
argument|TT_Face  face
argument_list|)
end_macro
begin_block
block|{
name|face
operator|->
name|access_glyph_frame
operator|=
name|TT_Access_Glyph_Frame
expr_stmt|;
name|face
operator|->
name|read_glyph_header
operator|=
name|TT_Load_Glyph_Header
expr_stmt|;
name|face
operator|->
name|read_simple_glyph
operator|=
name|TT_Load_Simple_Glyph
expr_stmt|;
name|face
operator|->
name|read_composite_glyph
operator|=
name|TT_Load_Composite_Glyph
expr_stmt|;
name|face
operator|->
name|forget_glyph_frame
operator|=
name|TT_Forget_Glyph_Frame
expr_stmt|;
block|}
end_block
begin_function
specifier|static
name|void
DECL|function|tt_prepare_zone
name|tt_prepare_zone
parameter_list|(
name|TT_GlyphZone
name|zone
parameter_list|,
name|FT_GlyphLoad
name|load
parameter_list|,
name|FT_UInt
name|start_point
parameter_list|,
name|FT_UInt
name|start_contour
parameter_list|)
block|{
name|zone
operator|->
name|n_points
operator|=
call|(
name|FT_UShort
call|)
argument_list|(
name|load
operator|->
name|outline
operator|.
name|n_points
operator|-
name|start_point
argument_list|)
expr_stmt|;
name|zone
operator|->
name|n_contours
operator|=
call|(
name|FT_Short
call|)
argument_list|(
name|load
operator|->
name|outline
operator|.
name|n_contours
operator|-
name|start_contour
argument_list|)
expr_stmt|;
name|zone
operator|->
name|org
operator|=
name|load
operator|->
name|extra_points
operator|+
name|start_point
expr_stmt|;
name|zone
operator|->
name|cur
operator|=
name|load
operator|->
name|outline
operator|.
name|points
operator|+
name|start_point
expr_stmt|;
name|zone
operator|->
name|orus
operator|=
name|load
operator|->
name|extra_points2
operator|+
name|start_point
expr_stmt|;
name|zone
operator|->
name|tags
operator|=
operator|(
name|FT_Byte
operator|*
operator|)
name|load
operator|->
name|outline
operator|.
name|tags
operator|+
name|start_point
expr_stmt|;
name|zone
operator|->
name|contours
operator|=
operator|(
name|FT_UShort
operator|*
operator|)
name|load
operator|->
name|outline
operator|.
name|contours
operator|+
name|start_contour
expr_stmt|;
name|zone
operator|->
name|first_point
operator|=
operator|(
name|FT_UShort
operator|)
name|start_point
expr_stmt|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    TT_Hint_Glyph                                                      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Hint the glyph using the zone prepared by the caller.  Note that   */
end_comment
begin_comment
comment|/*    the zone is supposed to include four phantom points.               */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|TT_Hint_Glyph
name|TT_Hint_Glyph
parameter_list|(
name|TT_Loader
name|loader
parameter_list|,
name|FT_Bool
name|is_composite
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_SUBPIXEL_HINTING
name|TT_Face
name|face
init|=
operator|(
name|TT_Face
operator|)
name|loader
operator|->
name|face
decl_stmt|;
name|TT_Driver
name|driver
init|=
operator|(
name|TT_Driver
operator|)
name|FT_FACE_DRIVER
argument_list|(
name|face
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|TT_GlyphZone
name|zone
init|=
operator|&
name|loader
operator|->
name|zone
decl_stmt|;
ifdef|#
directive|ifdef
name|TT_USE_BYTECODE_INTERPRETER
name|FT_UInt
name|n_ins
decl_stmt|;
else|#
directive|else
name|FT_UNUSED
argument_list|(
name|is_composite
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TT_USE_BYTECODE_INTERPRETER
if|if
condition|(
name|loader
operator|->
name|glyph
operator|->
name|control_len
operator|>
literal|0xFFFFL
condition|)
block|{
name|FT_TRACE1
argument_list|(
operator|(
literal|"TT_Hint_Glyph: too long instructions"
operator|)
argument_list|)
expr_stmt|;
name|FT_TRACE1
argument_list|(
operator|(
literal|" (0x%lx byte) is truncated\n"
operator|,
name|loader
operator|->
name|glyph
operator|->
name|control_len
operator|)
argument_list|)
expr_stmt|;
block|}
name|n_ins
operator|=
call|(
name|FT_UInt
call|)
argument_list|(
name|loader
operator|->
name|glyph
operator|->
name|control_len
argument_list|)
expr_stmt|;
comment|/* save original point position in org */
if|if
condition|(
name|n_ins
operator|>
literal|0
condition|)
name|FT_ARRAY_COPY
argument_list|(
name|zone
operator|->
name|org
argument_list|,
name|zone
operator|->
name|cur
argument_list|,
name|zone
operator|->
name|n_points
argument_list|)
expr_stmt|;
comment|/* Reset graphics state. */
name|loader
operator|->
name|exec
operator|->
name|GS
operator|=
operator|(
operator|(
name|TT_Size
operator|)
name|loader
operator|->
name|size
operator|)
operator|->
name|GS
expr_stmt|;
comment|/* XXX: UNDOCUMENTED! Hinting instructions of a composite glyph */
comment|/*      completely refer to the (already) hinted subglyphs.     */
if|if
condition|(
name|is_composite
condition|)
block|{
name|loader
operator|->
name|exec
operator|->
name|metrics
operator|.
name|x_scale
operator|=
literal|1
operator|<<
literal|16
expr_stmt|;
name|loader
operator|->
name|exec
operator|->
name|metrics
operator|.
name|y_scale
operator|=
literal|1
operator|<<
literal|16
expr_stmt|;
name|FT_ARRAY_COPY
argument_list|(
name|zone
operator|->
name|orus
argument_list|,
name|zone
operator|->
name|cur
argument_list|,
name|zone
operator|->
name|n_points
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|loader
operator|->
name|exec
operator|->
name|metrics
operator|.
name|x_scale
operator|=
operator|(
operator|(
name|TT_Size
operator|)
name|loader
operator|->
name|size
operator|)
operator|->
name|metrics
operator|.
name|x_scale
expr_stmt|;
name|loader
operator|->
name|exec
operator|->
name|metrics
operator|.
name|y_scale
operator|=
operator|(
operator|(
name|TT_Size
operator|)
name|loader
operator|->
name|size
operator|)
operator|->
name|metrics
operator|.
name|y_scale
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* round phantom points */
name|zone
operator|->
name|cur
index|[
name|zone
operator|->
name|n_points
operator|-
literal|4
index|]
operator|.
name|x
operator|=
name|FT_PIX_ROUND
argument_list|(
name|zone
operator|->
name|cur
index|[
name|zone
operator|->
name|n_points
operator|-
literal|4
index|]
operator|.
name|x
argument_list|)
expr_stmt|;
name|zone
operator|->
name|cur
index|[
name|zone
operator|->
name|n_points
operator|-
literal|3
index|]
operator|.
name|x
operator|=
name|FT_PIX_ROUND
argument_list|(
name|zone
operator|->
name|cur
index|[
name|zone
operator|->
name|n_points
operator|-
literal|3
index|]
operator|.
name|x
argument_list|)
expr_stmt|;
name|zone
operator|->
name|cur
index|[
name|zone
operator|->
name|n_points
operator|-
literal|2
index|]
operator|.
name|y
operator|=
name|FT_PIX_ROUND
argument_list|(
name|zone
operator|->
name|cur
index|[
name|zone
operator|->
name|n_points
operator|-
literal|2
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
name|zone
operator|->
name|cur
index|[
name|zone
operator|->
name|n_points
operator|-
literal|1
index|]
operator|.
name|y
operator|=
name|FT_PIX_ROUND
argument_list|(
name|zone
operator|->
name|cur
index|[
name|zone
operator|->
name|n_points
operator|-
literal|1
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TT_USE_BYTECODE_INTERPRETER
if|if
condition|(
name|n_ins
operator|>
literal|0
condition|)
block|{
name|FT_Bool
name|debug
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|FT_GlyphLoader
name|gloader
init|=
name|loader
operator|->
name|gloader
decl_stmt|;
name|FT_Outline
name|current_outline
init|=
name|gloader
operator|->
name|current
operator|.
name|outline
decl_stmt|;
name|TT_Set_CodeRange
argument_list|(
name|loader
operator|->
name|exec
argument_list|,
name|tt_coderange_glyph
argument_list|,
name|loader
operator|->
name|exec
operator|->
name|glyphIns
argument_list|,
name|n_ins
argument_list|)
expr_stmt|;
name|loader
operator|->
name|exec
operator|->
name|is_composite
operator|=
name|is_composite
expr_stmt|;
name|loader
operator|->
name|exec
operator|->
name|pts
operator|=
operator|*
name|zone
expr_stmt|;
name|debug
operator|=
name|FT_BOOL
argument_list|(
operator|!
operator|(
name|loader
operator|->
name|load_flags
operator|&
name|FT_LOAD_NO_SCALE
operator|)
operator|&&
operator|(
operator|(
name|TT_Size
operator|)
name|loader
operator|->
name|size
operator|)
operator|->
name|debug
argument_list|)
expr_stmt|;
name|error
operator|=
name|TT_Run_Context
argument_list|(
name|loader
operator|->
name|exec
argument_list|,
name|debug
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|loader
operator|->
name|exec
operator|->
name|pedantic_hinting
condition|)
return|return
name|error
return|;
comment|/* store drop-out mode in bits 5-7; set bit 2 also as a marker */
name|current_outline
operator|.
name|tags
index|[
literal|0
index|]
operator||=
operator|(
name|loader
operator|->
name|exec
operator|->
name|GS
operator|.
name|scan_type
operator|<<
literal|5
operator|)
operator||
name|FT_CURVE_TAG_HAS_SCANMODE
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* save glyph phantom points */
name|loader
operator|->
name|pp1
operator|=
name|zone
operator|->
name|cur
index|[
name|zone
operator|->
name|n_points
operator|-
literal|4
index|]
expr_stmt|;
name|loader
operator|->
name|pp2
operator|=
name|zone
operator|->
name|cur
index|[
name|zone
operator|->
name|n_points
operator|-
literal|3
index|]
expr_stmt|;
name|loader
operator|->
name|pp3
operator|=
name|zone
operator|->
name|cur
index|[
name|zone
operator|->
name|n_points
operator|-
literal|2
index|]
expr_stmt|;
name|loader
operator|->
name|pp4
operator|=
name|zone
operator|->
name|cur
index|[
name|zone
operator|->
name|n_points
operator|-
literal|1
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_SUBPIXEL_HINTING
if|if
condition|(
name|driver
operator|->
name|interpreter_version
operator|==
name|TT_INTERPRETER_VERSION_38
condition|)
block|{
if|if
condition|(
name|loader
operator|->
name|exec
operator|->
name|sph_tweak_flags
operator|&
name|SPH_TWEAK_DEEMBOLDEN
condition|)
name|FT_Outline_EmboldenXY
argument_list|(
operator|&
name|loader
operator|->
name|gloader
operator|->
name|current
operator|.
name|outline
argument_list|,
operator|-
literal|24
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|loader
operator|->
name|exec
operator|->
name|sph_tweak_flags
operator|&
name|SPH_TWEAK_EMBOLDEN
condition|)
name|FT_Outline_EmboldenXY
argument_list|(
operator|&
name|loader
operator|->
name|gloader
operator|->
name|current
operator|.
name|outline
argument_list|,
literal|24
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
return|return
name|FT_Err_Ok
return|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    TT_Process_Simple_Glyph                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Once a simple glyph has been loaded, it needs to be processed.     */
end_comment
begin_comment
comment|/*    Usually, this means scaling and hinting through bytecode           */
end_comment
begin_comment
comment|/*    interpretation.                                                    */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|TT_Process_Simple_Glyph
name|TT_Process_Simple_Glyph
parameter_list|(
name|TT_Loader
name|loader
parameter_list|)
block|{
name|FT_GlyphLoader
name|gloader
init|=
name|loader
operator|->
name|gloader
decl_stmt|;
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
name|FT_Outline
modifier|*
name|outline
decl_stmt|;
name|FT_Int
name|n_points
decl_stmt|;
name|outline
operator|=
operator|&
name|gloader
operator|->
name|current
operator|.
name|outline
expr_stmt|;
name|n_points
operator|=
name|outline
operator|->
name|n_points
expr_stmt|;
comment|/* set phantom points */
name|outline
operator|->
name|points
index|[
name|n_points
index|]
operator|=
name|loader
operator|->
name|pp1
expr_stmt|;
name|outline
operator|->
name|points
index|[
name|n_points
operator|+
literal|1
index|]
operator|=
name|loader
operator|->
name|pp2
expr_stmt|;
name|outline
operator|->
name|points
index|[
name|n_points
operator|+
literal|2
index|]
operator|=
name|loader
operator|->
name|pp3
expr_stmt|;
name|outline
operator|->
name|points
index|[
name|n_points
operator|+
literal|3
index|]
operator|=
name|loader
operator|->
name|pp4
expr_stmt|;
name|outline
operator|->
name|tags
index|[
name|n_points
index|]
operator|=
literal|0
expr_stmt|;
name|outline
operator|->
name|tags
index|[
name|n_points
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|outline
operator|->
name|tags
index|[
name|n_points
operator|+
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|outline
operator|->
name|tags
index|[
name|n_points
operator|+
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|n_points
operator|+=
literal|4
expr_stmt|;
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_GX_VAR_SUPPORT
if|if
condition|(
operator|(
operator|(
name|TT_Face
operator|)
name|loader
operator|->
name|face
operator|)
operator|->
name|doblend
condition|)
block|{
comment|/* Deltas apply to the unscaled data. */
name|FT_Vector
modifier|*
name|deltas
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|loader
operator|->
name|face
operator|->
name|memory
decl_stmt|;
name|FT_Int
name|i
decl_stmt|;
name|error
operator|=
name|TT_Vary_Get_Glyph_Deltas
argument_list|(
call|(
name|TT_Face
call|)
argument_list|(
name|loader
operator|->
name|face
argument_list|)
argument_list|,
name|loader
operator|->
name|glyph_index
argument_list|,
operator|&
name|deltas
argument_list|,
name|n_points
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_points
condition|;
operator|++
name|i
control|)
block|{
name|outline
operator|->
name|points
index|[
name|i
index|]
operator|.
name|x
operator|+=
name|deltas
index|[
name|i
index|]
operator|.
name|x
expr_stmt|;
name|outline
operator|->
name|points
index|[
name|i
index|]
operator|.
name|y
operator|+=
name|deltas
index|[
name|i
index|]
operator|.
name|y
expr_stmt|;
block|}
name|FT_FREE
argument_list|(
name|deltas
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* TT_CONFIG_OPTION_GX_VAR_SUPPORT */
if|if
condition|(
name|IS_HINTED
argument_list|(
name|loader
operator|->
name|load_flags
argument_list|)
condition|)
block|{
name|tt_prepare_zone
argument_list|(
operator|&
name|loader
operator|->
name|zone
argument_list|,
operator|&
name|gloader
operator|->
name|current
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FT_ARRAY_COPY
argument_list|(
name|loader
operator|->
name|zone
operator|.
name|orus
argument_list|,
name|loader
operator|->
name|zone
operator|.
name|cur
argument_list|,
name|loader
operator|->
name|zone
operator|.
name|n_points
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
block|{
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_SUBPIXEL_HINTING
name|TT_Face
name|face
init|=
operator|(
name|TT_Face
operator|)
name|loader
operator|->
name|face
decl_stmt|;
name|TT_Driver
name|driver
init|=
operator|(
name|TT_Driver
operator|)
name|FT_FACE_DRIVER
argument_list|(
name|face
argument_list|)
decl_stmt|;
name|FT_String
modifier|*
name|family
init|=
name|face
operator|->
name|root
operator|.
name|family_name
decl_stmt|;
name|FT_Int
name|ppem
init|=
name|loader
operator|->
name|size
operator|->
name|metrics
operator|.
name|x_ppem
decl_stmt|;
name|FT_String
modifier|*
name|style
init|=
name|face
operator|->
name|root
operator|.
name|style_name
decl_stmt|;
name|FT_Int
name|x_scale_factor
init|=
literal|1000
decl_stmt|;
endif|#
directive|endif
name|FT_Vector
modifier|*
name|vec
init|=
name|outline
operator|->
name|points
decl_stmt|;
name|FT_Vector
modifier|*
name|limit
init|=
name|outline
operator|->
name|points
operator|+
name|n_points
decl_stmt|;
name|FT_Fixed
name|x_scale
init|=
literal|0
decl_stmt|;
comment|/* pacify compiler */
name|FT_Fixed
name|y_scale
init|=
literal|0
decl_stmt|;
name|FT_Bool
name|do_scale
init|=
name|FALSE
decl_stmt|;
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_SUBPIXEL_HINTING
if|if
condition|(
name|driver
operator|->
name|interpreter_version
operator|==
name|TT_INTERPRETER_VERSION_38
condition|)
block|{
comment|/* scale, but only if enabled and only if TT hinting is being used */
if|if
condition|(
name|IS_HINTED
argument_list|(
name|loader
operator|->
name|load_flags
argument_list|)
condition|)
name|x_scale_factor
operator|=
name|sph_test_tweak_x_scaling
argument_list|(
name|face
argument_list|,
name|family
argument_list|,
name|ppem
argument_list|,
name|style
argument_list|,
name|loader
operator|->
name|glyph_index
argument_list|)
expr_stmt|;
comment|/* scale the glyph */
if|if
condition|(
operator|(
name|loader
operator|->
name|load_flags
operator|&
name|FT_LOAD_NO_SCALE
operator|)
operator|==
literal|0
operator|||
name|x_scale_factor
operator|!=
literal|1000
condition|)
block|{
name|x_scale
operator|=
name|FT_MulDiv
argument_list|(
operator|(
operator|(
name|TT_Size
operator|)
name|loader
operator|->
name|size
operator|)
operator|->
name|metrics
operator|.
name|x_scale
argument_list|,
name|x_scale_factor
argument_list|,
literal|1000
argument_list|)
expr_stmt|;
name|y_scale
operator|=
operator|(
operator|(
name|TT_Size
operator|)
name|loader
operator|->
name|size
operator|)
operator|->
name|metrics
operator|.
name|y_scale
expr_stmt|;
comment|/* compensate for any scaling by de/emboldening; */
comment|/* the amount was determined via experimentation */
if|if
condition|(
name|x_scale_factor
operator|!=
literal|1000
operator|&&
name|ppem
operator|>
literal|11
condition|)
name|FT_Outline_EmboldenXY
argument_list|(
name|outline
argument_list|,
name|FT_MulFix
argument_list|(
literal|1280
operator|*
name|ppem
argument_list|,
literal|1000
operator|-
name|x_scale_factor
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|do_scale
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
comment|/* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
block|{
comment|/* scale the glyph */
if|if
condition|(
operator|(
name|loader
operator|->
name|load_flags
operator|&
name|FT_LOAD_NO_SCALE
operator|)
operator|==
literal|0
condition|)
block|{
name|x_scale
operator|=
operator|(
operator|(
name|TT_Size
operator|)
name|loader
operator|->
name|size
operator|)
operator|->
name|metrics
operator|.
name|x_scale
expr_stmt|;
name|y_scale
operator|=
operator|(
operator|(
name|TT_Size
operator|)
name|loader
operator|->
name|size
operator|)
operator|->
name|metrics
operator|.
name|y_scale
expr_stmt|;
name|do_scale
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|do_scale
condition|)
block|{
for|for
control|(
init|;
name|vec
operator|<
name|limit
condition|;
name|vec
operator|++
control|)
block|{
name|vec
operator|->
name|x
operator|=
name|FT_MulFix
argument_list|(
name|vec
operator|->
name|x
argument_list|,
name|x_scale
argument_list|)
expr_stmt|;
name|vec
operator|->
name|y
operator|=
name|FT_MulFix
argument_list|(
name|vec
operator|->
name|y
argument_list|,
name|y_scale
argument_list|)
expr_stmt|;
block|}
name|loader
operator|->
name|pp1
operator|=
name|outline
operator|->
name|points
index|[
name|n_points
operator|-
literal|4
index|]
expr_stmt|;
name|loader
operator|->
name|pp2
operator|=
name|outline
operator|->
name|points
index|[
name|n_points
operator|-
literal|3
index|]
expr_stmt|;
name|loader
operator|->
name|pp3
operator|=
name|outline
operator|->
name|points
index|[
name|n_points
operator|-
literal|2
index|]
expr_stmt|;
name|loader
operator|->
name|pp4
operator|=
name|outline
operator|->
name|points
index|[
name|n_points
operator|-
literal|1
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
name|IS_HINTED
argument_list|(
name|loader
operator|->
name|load_flags
argument_list|)
condition|)
block|{
name|loader
operator|->
name|zone
operator|.
name|n_points
operator|+=
literal|4
expr_stmt|;
name|error
operator|=
name|TT_Hint_Glyph
argument_list|(
name|loader
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    TT_Process_Composite_Component                                     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Once a composite component has been loaded, it needs to be         */
end_comment
begin_comment
comment|/*    processed.  Usually, this means transforming and translating.      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|TT_Process_Composite_Component
name|TT_Process_Composite_Component
parameter_list|(
name|TT_Loader
name|loader
parameter_list|,
name|FT_SubGlyph
name|subglyph
parameter_list|,
name|FT_UInt
name|start_point
parameter_list|,
name|FT_UInt
name|num_base_points
parameter_list|)
block|{
name|FT_GlyphLoader
name|gloader
init|=
name|loader
operator|->
name|gloader
decl_stmt|;
name|FT_Vector
modifier|*
name|base_vec
init|=
name|gloader
operator|->
name|base
operator|.
name|outline
operator|.
name|points
decl_stmt|;
name|FT_UInt
name|num_points
init|=
name|gloader
operator|->
name|base
operator|.
name|outline
operator|.
name|n_points
decl_stmt|;
name|FT_Bool
name|have_scale
decl_stmt|;
name|FT_Pos
name|x
decl_stmt|,
name|y
decl_stmt|;
name|have_scale
operator|=
name|FT_BOOL
argument_list|(
name|subglyph
operator|->
name|flags
operator|&
operator|(
name|WE_HAVE_A_SCALE
operator||
name|WE_HAVE_AN_XY_SCALE
operator||
name|WE_HAVE_A_2X2
operator|)
argument_list|)
expr_stmt|;
comment|/* perform the transform required for this subglyph */
if|if
condition|(
name|have_scale
condition|)
block|{
name|FT_UInt
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|num_base_points
init|;
name|i
operator|<
name|num_points
condition|;
name|i
operator|++
control|)
name|FT_Vector_Transform
argument_list|(
name|base_vec
operator|+
name|i
argument_list|,
operator|&
name|subglyph
operator|->
name|transform
argument_list|)
expr_stmt|;
block|}
comment|/* get offset */
if|if
condition|(
operator|!
operator|(
name|subglyph
operator|->
name|flags
operator|&
name|ARGS_ARE_XY_VALUES
operator|)
condition|)
block|{
name|FT_UInt
name|k
init|=
name|subglyph
operator|->
name|arg1
decl_stmt|;
name|FT_UInt
name|l
init|=
name|subglyph
operator|->
name|arg2
decl_stmt|;
name|FT_Vector
modifier|*
name|p1
decl_stmt|;
name|FT_Vector
modifier|*
name|p2
decl_stmt|;
comment|/* match l-th point of the newly loaded component to the k-th point */
comment|/* of the previously loaded components.                             */
comment|/* change to the point numbers used by our outline */
name|k
operator|+=
name|start_point
expr_stmt|;
name|l
operator|+=
name|num_base_points
expr_stmt|;
if|if
condition|(
name|k
operator|>=
name|num_base_points
operator|||
name|l
operator|>=
name|num_points
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_Composite
argument_list|)
return|;
name|p1
operator|=
name|gloader
operator|->
name|base
operator|.
name|outline
operator|.
name|points
operator|+
name|k
expr_stmt|;
name|p2
operator|=
name|gloader
operator|->
name|base
operator|.
name|outline
operator|.
name|points
operator|+
name|l
expr_stmt|;
name|x
operator|=
name|p1
operator|->
name|x
operator|-
name|p2
operator|->
name|x
expr_stmt|;
name|y
operator|=
name|p1
operator|->
name|y
operator|-
name|p2
operator|->
name|y
expr_stmt|;
block|}
else|else
block|{
name|x
operator|=
name|subglyph
operator|->
name|arg1
expr_stmt|;
name|y
operator|=
name|subglyph
operator|->
name|arg2
expr_stmt|;
if|if
condition|(
operator|!
name|x
operator|&&
operator|!
name|y
condition|)
return|return
name|FT_Err_Ok
return|;
comment|/* Use a default value dependent on                                  */
comment|/* TT_CONFIG_OPTION_COMPONENT_OFFSET_SCALED.  This is useful for old */
comment|/* TT fonts which don't set the xxx_COMPONENT_OFFSET bit.            */
if|if
condition|(
name|have_scale
operator|&&
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_COMPONENT_OFFSET_SCALED
operator|!
operator|(
name|subglyph
operator|->
name|flags
operator|&
name|UNSCALED_COMPONENT_OFFSET
operator|)
condition|)
else|#
directive|else
operator|(
name|subglyph
operator|->
name|flags
operator|&
name|SCALED_COMPONENT_OFFSET
operator|)
block|)
endif|#
directive|endif
block|{
if|#
directive|if
literal|0
comment|/*******************************************************************/
comment|/*                                                                 */
comment|/* This algorithm is what Apple documents.  But it doesn't work.   */
comment|/*                                                                 */
block|int  a = subglyph->transform.xx> 0 ?  subglyph->transform.xx                                             : -subglyph->transform.xx;         int  b = subglyph->transform.yx> 0 ?  subglyph->transform.yx                                             : -subglyph->transform.yx;         int  c = subglyph->transform.xy> 0 ?  subglyph->transform.xy                                             : -subglyph->transform.xy;         int  d = subglyph->transform.yy> 0 ? subglyph->transform.yy                                             : -subglyph->transform.yy;         int  m = a> b ? a : b;         int  n = c> d ? c : d;           if ( a - b<= 33&& a - b>= -33 )           m *= 2;         if ( c - d<= 33&& c - d>= -33 )           n *= 2;         x = FT_MulFix( x, m );         y = FT_MulFix( y, n );
else|#
directive|else
comment|/* 1 */
comment|/*******************************************************************/
comment|/*                                                                 */
comment|/* This algorithm is a guess and works much better than the above. */
comment|/*                                                                 */
name|FT_Fixed
name|mac_xscale
init|=
name|FT_Hypot
argument_list|(
name|subglyph
operator|->
name|transform
operator|.
name|xx
argument_list|,
name|subglyph
operator|->
name|transform
operator|.
name|xy
argument_list|)
decl_stmt|;
name|FT_Fixed
name|mac_yscale
init|=
name|FT_Hypot
argument_list|(
name|subglyph
operator|->
name|transform
operator|.
name|yy
argument_list|,
name|subglyph
operator|->
name|transform
operator|.
name|yx
argument_list|)
decl_stmt|;
name|x
operator|=
name|FT_MulFix
argument_list|(
name|x
argument_list|,
name|mac_xscale
argument_list|)
expr_stmt|;
name|y
operator|=
name|FT_MulFix
argument_list|(
name|y
argument_list|,
name|mac_yscale
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 1 */
block|}
if|if
condition|(
operator|!
operator|(
name|loader
operator|->
name|load_flags
operator|&
name|FT_LOAD_NO_SCALE
operator|)
condition|)
block|{
name|FT_Fixed
name|x_scale
init|=
operator|(
operator|(
name|TT_Size
operator|)
name|loader
operator|->
name|size
operator|)
operator|->
name|metrics
operator|.
name|x_scale
decl_stmt|;
name|FT_Fixed
name|y_scale
init|=
operator|(
operator|(
name|TT_Size
operator|)
name|loader
operator|->
name|size
operator|)
operator|->
name|metrics
operator|.
name|y_scale
decl_stmt|;
name|x
operator|=
name|FT_MulFix
argument_list|(
name|x
argument_list|,
name|x_scale
argument_list|)
expr_stmt|;
name|y
operator|=
name|FT_MulFix
argument_list|(
name|y
argument_list|,
name|y_scale
argument_list|)
expr_stmt|;
if|if
condition|(
name|subglyph
operator|->
name|flags
operator|&
name|ROUND_XY_TO_GRID
condition|)
block|{
name|x
operator|=
name|FT_PIX_ROUND
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|y
operator|=
name|FT_PIX_ROUND
argument_list|(
name|y
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_if
if|if
condition|(
name|x
operator|||
name|y
condition|)
name|translate_array
argument_list|(
name|num_points
operator|-
name|num_base_points
argument_list|,
name|base_vec
operator|+
name|num_base_points
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
end_if
begin_return
return|return
name|FT_Err_Ok
return|;
end_return
begin_comment
unit|}
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    TT_Process_Composite_Glyph                                         */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    This is slightly different from TT_Process_Simple_Glyph, in that   */
end_comment
begin_comment
comment|/*    its sole purpose is to hint the glyph.  Thus this function is      */
end_comment
begin_comment
comment|/*    only available when bytecode interpreter is enabled.               */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
unit|static
name|FT_Error
DECL|function|TT_Process_Composite_Glyph
name|TT_Process_Composite_Glyph
parameter_list|(
name|TT_Loader
name|loader
parameter_list|,
name|FT_UInt
name|start_point
parameter_list|,
name|FT_UInt
name|start_contour
parameter_list|)
block|{
name|FT_Error
name|error
decl_stmt|;
name|FT_Outline
modifier|*
name|outline
decl_stmt|;
name|FT_UInt
name|i
decl_stmt|;
name|outline
operator|=
operator|&
name|loader
operator|->
name|gloader
operator|->
name|base
operator|.
name|outline
expr_stmt|;
comment|/* make room for phantom points */
name|error
operator|=
name|FT_GLYPHLOADER_CHECK_POINTS
argument_list|(
name|loader
operator|->
name|gloader
argument_list|,
name|outline
operator|->
name|n_points
operator|+
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|outline
operator|->
name|points
index|[
name|outline
operator|->
name|n_points
index|]
operator|=
name|loader
operator|->
name|pp1
expr_stmt|;
name|outline
operator|->
name|points
index|[
name|outline
operator|->
name|n_points
operator|+
literal|1
index|]
operator|=
name|loader
operator|->
name|pp2
expr_stmt|;
name|outline
operator|->
name|points
index|[
name|outline
operator|->
name|n_points
operator|+
literal|2
index|]
operator|=
name|loader
operator|->
name|pp3
expr_stmt|;
name|outline
operator|->
name|points
index|[
name|outline
operator|->
name|n_points
operator|+
literal|3
index|]
operator|=
name|loader
operator|->
name|pp4
expr_stmt|;
name|outline
operator|->
name|tags
index|[
name|outline
operator|->
name|n_points
index|]
operator|=
literal|0
expr_stmt|;
name|outline
operator|->
name|tags
index|[
name|outline
operator|->
name|n_points
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|outline
operator|->
name|tags
index|[
name|outline
operator|->
name|n_points
operator|+
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|outline
operator|->
name|tags
index|[
name|outline
operator|->
name|n_points
operator|+
literal|3
index|]
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|TT_USE_BYTECODE_INTERPRETER
block|{
name|FT_Stream
name|stream
init|=
name|loader
operator|->
name|stream
decl_stmt|;
name|FT_UShort
name|n_ins
decl_stmt|,
name|max_ins
decl_stmt|;
name|FT_ULong
name|tmp
decl_stmt|;
comment|/* TT_Load_Composite_Glyph only gives us the offset of instructions */
comment|/* so we read them here                                             */
if|if
condition|(
name|FT_STREAM_SEEK
argument_list|(
name|loader
operator|->
name|ins_pos
argument_list|)
operator|||
name|FT_READ_USHORT
argument_list|(
name|n_ins
argument_list|)
condition|)
return|return
name|error
return|;
name|FT_TRACE5
argument_list|(
operator|(
literal|"  Instructions size = %d\n"
operator|,
name|n_ins
operator|)
argument_list|)
expr_stmt|;
comment|/* check it */
name|max_ins
operator|=
operator|(
operator|(
name|TT_Face
operator|)
name|loader
operator|->
name|face
operator|)
operator|->
name|max_profile
operator|.
name|maxSizeOfInstructions
expr_stmt|;
if|if
condition|(
name|n_ins
operator|>
name|max_ins
condition|)
block|{
comment|/* don't trust `maxSizeOfInstructions'; */
comment|/* only do a rough safety check         */
if|if
condition|(
operator|(
name|FT_Int
operator|)
name|n_ins
operator|>
name|loader
operator|->
name|byte_len
condition|)
block|{
name|FT_TRACE1
argument_list|(
operator|(
literal|"TT_Process_Composite_Glyph:"
literal|" too many instructions (%d) for glyph with length %d\n"
operator|,
name|n_ins
operator|,
name|loader
operator|->
name|byte_len
operator|)
argument_list|)
expr_stmt|;
return|return
name|FT_THROW
argument_list|(
name|Too_Many_Hints
argument_list|)
return|;
block|}
name|tmp
operator|=
name|loader
operator|->
name|exec
operator|->
name|glyphSize
expr_stmt|;
name|error
operator|=
name|Update_Max
argument_list|(
name|loader
operator|->
name|exec
operator|->
name|memory
argument_list|,
operator|&
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|FT_Byte
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|loader
operator|->
name|exec
operator|->
name|glyphIns
argument_list|,
name|n_ins
argument_list|)
expr_stmt|;
name|loader
operator|->
name|exec
operator|->
name|glyphSize
operator|=
operator|(
name|FT_UShort
operator|)
name|tmp
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
block|}
elseif|else
if|if
condition|(
name|n_ins
operator|==
literal|0
condition|)
return|return
name|FT_Err_Ok
return|;
if|if
condition|(
name|FT_STREAM_READ
argument_list|(
name|loader
operator|->
name|exec
operator|->
name|glyphIns
argument_list|,
name|n_ins
argument_list|)
condition|)
return|return
name|error
return|;
name|loader
operator|->
name|glyph
operator|->
name|control_data
operator|=
name|loader
operator|->
name|exec
operator|->
name|glyphIns
expr_stmt|;
name|loader
operator|->
name|glyph
operator|->
name|control_len
operator|=
name|n_ins
expr_stmt|;
block|}
endif|#
directive|endif
name|tt_prepare_zone
argument_list|(
operator|&
name|loader
operator|->
name|zone
argument_list|,
operator|&
name|loader
operator|->
name|gloader
operator|->
name|base
argument_list|,
name|start_point
argument_list|,
name|start_contour
argument_list|)
expr_stmt|;
comment|/* Some points are likely touched during execution of  */
comment|/* instructions on components.  So let's untouch them. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|loader
operator|->
name|zone
operator|.
name|n_points
condition|;
name|i
operator|++
control|)
name|loader
operator|->
name|zone
operator|.
name|tags
index|[
name|i
index|]
operator|&=
operator|~
name|FT_CURVE_TAG_TOUCH_BOTH
expr_stmt|;
name|loader
operator|->
name|zone
operator|.
name|n_points
operator|+=
literal|4
expr_stmt|;
return|return
name|TT_Hint_Glyph
argument_list|(
name|loader
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*    * Calculate the phantom points    *    * Defining the right side bearing (rsb) as    *    *   rsb = aw - (lsb + xmax - xmin)    *    * (with `aw' the advance width, `lsb' the left side bearing, and `xmin'    * and `xmax' the glyph's minimum and maximum x value), the OpenType    * specification defines the initial position of horizontal phantom points    * as    *    *   pp1 = (round(xmin - lsb), 0)      ,    *   pp2 = (round(pp1 + aw), 0)        .    *    * Note that the rounding to the grid (in the device space) is not    * documented currently in the specification.    *    * However, the specification lacks the precise definition of vertical    * phantom points.  Greg Hitchcock provided the following explanation.    *    * - a `vmtx' table is present    *    *   For any glyph, the minimum and maximum y values (`ymin' and `ymax')    *   are given in the `glyf' table, the top side bearing (tsb) and advance    *   height (ah) are given in the `vmtx' table.  The bottom side bearing    *   (bsb) is then calculated as    *    *     bsb = ah - (tsb + ymax - ymin)       ,    *    *   and the initial position of vertical phantom points is    *    *     pp3 = (x, round(ymax + tsb))       ,    *     pp4 = (x, round(pp3 - ah))         .    *    *   See below for value `x'.    *    * - no `vmtx' table in the font    *    *   If there is an `OS/2' table, we set    *    *     DefaultAscender = sTypoAscender       ,    *     DefaultDescender = sTypoDescender     ,    *    *   otherwise we use data from the `hhea' table:    *    *     DefaultAscender = Ascender         ,    *     DefaultDescender = Descender       .    *    *   With these two variables we can now set    *    *     ah = DefaultAscender - sDefaultDescender    ,    *     tsb = DefaultAscender - yMax                ,    *    *   and proceed as if a `vmtx' table was present.    *    * Usually we have    *    *   x = aw / 2      ,                                                (1)    *    * but there is one compatibility case where it can be set to    *    *   x = -DefaultDescender -    *         ((DefaultAscender - DefaultDescender - aw) / 2)     .      (2)    *    * and another one with    *    *   x = 0     .                                                      (3)    *    * In Windows, the history of those values is quite complicated,    * depending on the hinting engine (that is, the graphics framework).    *    *   framework        from                 to       formula    *  ----------------------------------------------------------    *    GDI       Windows 98               current      (1)    *              (Windows 2000 for NT)    *    GDI+      Windows XP               Windows 7    (2)    *    GDI+      Windows 8                current      (3)    *    DWrite    Windows 7                current      (3)    *    * For simplicity, FreeType uses (1) for grayscale subpixel hinting and    * (3) for everything else.    *    */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_SUBPIXEL_HINTING
end_ifdef
begin_define
DECL|macro|TT_LOADER_SET_PP
define|#
directive|define
name|TT_LOADER_SET_PP
parameter_list|(
name|loader
parameter_list|)
define|\
value|do                                                                \           {                                                                 \             FT_Bool  subpixel_  = loader->exec ? loader->exec->subpixel     \                                                : 0;                         \             FT_Bool  grayscale_ = loader->exec ? loader->exec->grayscale    \                                                : 0;                         \             FT_Bool  use_aw_2_  = (FT_Bool)( subpixel_&& grayscale_ );     \                                                                             \                                                                             \             (loader)->pp1.x = (loader)->bbox.xMin - (loader)->left_bearing; \             (loader)->pp1.y = 0;                                            \             (loader)->pp2.x = (loader)->pp1.x + (loader)->advance;          \             (loader)->pp2.y = 0;                                            \                                                                             \             (loader)->pp3.x = use_aw_2_ ? (loader)->advance / 2 : 0;        \             (loader)->pp3.y = (loader)->bbox.yMax + (loader)->top_bearing;  \             (loader)->pp4.x = use_aw_2_ ? (loader)->advance / 2 : 0;        \             (loader)->pp4.y = (loader)->pp3.y - (loader)->vadvance;         \           } while ( 0 )
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* !TT_CONFIG_OPTION_SUBPIXEL_HINTING */
end_comment
begin_define
DECL|macro|TT_LOADER_SET_PP
define|#
directive|define
name|TT_LOADER_SET_PP
parameter_list|(
name|loader
parameter_list|)
define|\
value|do                                                                \           {                                                                 \             (loader)->pp1.x = (loader)->bbox.xMin - (loader)->left_bearing; \             (loader)->pp1.y = 0;                                            \             (loader)->pp2.x = (loader)->pp1.x + (loader)->advance;          \             (loader)->pp2.y = 0;                                            \                                                                             \             (loader)->pp3.x = 0;                                            \             (loader)->pp3.y = (loader)->bbox.yMax + (loader)->top_bearing;  \             (loader)->pp4.x = 0;                                            \             (loader)->pp4.y = (loader)->pp3.y - (loader)->vadvance;         \           } while ( 0 )
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* !TT_CONFIG_OPTION_SUBPIXEL_HINTING */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    load_truetype_glyph                                                */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Loads a given truetype glyph.  Handles composites and uses a       */
end_comment
begin_comment
comment|/*    TT_Loader object.                                                  */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|load_truetype_glyph
name|load_truetype_glyph
parameter_list|(
name|TT_Loader
name|loader
parameter_list|,
name|FT_UInt
name|glyph_index
parameter_list|,
name|FT_UInt
name|recurse_count
parameter_list|,
name|FT_Bool
name|header_only
parameter_list|)
block|{
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
name|FT_Fixed
name|x_scale
decl_stmt|,
name|y_scale
decl_stmt|;
name|FT_ULong
name|offset
decl_stmt|;
name|TT_Face
name|face
init|=
operator|(
name|TT_Face
operator|)
name|loader
operator|->
name|face
decl_stmt|;
name|FT_GlyphLoader
name|gloader
init|=
name|loader
operator|->
name|gloader
decl_stmt|;
name|FT_Bool
name|opened_frame
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_GX_VAR_SUPPORT
name|FT_Vector
modifier|*
name|deltas
init|=
name|NULL
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|FT_CONFIG_OPTION_INCREMENTAL
name|FT_StreamRec
name|inc_stream
decl_stmt|;
name|FT_Data
name|glyph_data
decl_stmt|;
name|FT_Bool
name|glyph_data_loaded
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
comment|/* some fonts have an incorrect value of `maxComponentDepth', */
comment|/* thus we allow depth 1 to catch the majority of them        */
if|if
condition|(
name|recurse_count
operator|>
literal|1
operator|&&
name|recurse_count
operator|>
name|face
operator|->
name|max_profile
operator|.
name|maxComponentDepth
condition|)
block|{
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Composite
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* check glyph index */
if|if
condition|(
name|glyph_index
operator|>=
operator|(
name|FT_UInt
operator|)
name|face
operator|->
name|root
operator|.
name|num_glyphs
condition|)
block|{
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Glyph_Index
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|loader
operator|->
name|glyph_index
operator|=
name|glyph_index
expr_stmt|;
if|if
condition|(
operator|(
name|loader
operator|->
name|load_flags
operator|&
name|FT_LOAD_NO_SCALE
operator|)
operator|==
literal|0
condition|)
block|{
name|x_scale
operator|=
operator|(
operator|(
name|TT_Size
operator|)
name|loader
operator|->
name|size
operator|)
operator|->
name|metrics
operator|.
name|x_scale
expr_stmt|;
name|y_scale
operator|=
operator|(
operator|(
name|TT_Size
operator|)
name|loader
operator|->
name|size
operator|)
operator|->
name|metrics
operator|.
name|y_scale
expr_stmt|;
block|}
else|else
block|{
name|x_scale
operator|=
literal|0x10000L
expr_stmt|;
name|y_scale
operator|=
literal|0x10000L
expr_stmt|;
block|}
comment|/* Set `offset' to the start of the glyph relative to the start of */
comment|/* the `glyf' table, and `byte_len' to the length of the glyph in  */
comment|/* bytes.                                                          */
ifdef|#
directive|ifdef
name|FT_CONFIG_OPTION_INCREMENTAL
comment|/* If we are loading glyph data via the incremental interface, set */
comment|/* the loader stream to a memory stream reading the data returned  */
comment|/* by the interface.                                               */
if|if
condition|(
name|face
operator|->
name|root
operator|.
name|internal
operator|->
name|incremental_interface
condition|)
block|{
name|error
operator|=
name|face
operator|->
name|root
operator|.
name|internal
operator|->
name|incremental_interface
operator|->
name|funcs
operator|->
name|get_glyph_data
argument_list|(
name|face
operator|->
name|root
operator|.
name|internal
operator|->
name|incremental_interface
operator|->
name|object
argument_list|,
name|glyph_index
argument_list|,
operator|&
name|glyph_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|glyph_data_loaded
operator|=
literal|1
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
name|loader
operator|->
name|byte_len
operator|=
name|glyph_data
operator|.
name|length
expr_stmt|;
name|FT_MEM_ZERO
argument_list|(
operator|&
name|inc_stream
argument_list|,
sizeof|sizeof
argument_list|(
name|inc_stream
argument_list|)
argument_list|)
expr_stmt|;
name|FT_Stream_OpenMemory
argument_list|(
operator|&
name|inc_stream
argument_list|,
name|glyph_data
operator|.
name|pointer
argument_list|,
name|glyph_data
operator|.
name|length
argument_list|)
expr_stmt|;
name|loader
operator|->
name|stream
operator|=
operator|&
name|inc_stream
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* FT_CONFIG_OPTION_INCREMENTAL */
name|offset
operator|=
name|tt_face_get_location
argument_list|(
name|face
argument_list|,
name|glyph_index
argument_list|,
operator|(
name|FT_UInt
operator|*
operator|)
operator|&
name|loader
operator|->
name|byte_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|loader
operator|->
name|byte_len
operator|>
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|FT_CONFIG_OPTION_INCREMENTAL
comment|/* for the incremental interface, `glyf_offset' is always zero */
if|if
condition|(
operator|!
name|loader
operator|->
name|glyf_offset
operator|&&
operator|!
name|face
operator|->
name|root
operator|.
name|internal
operator|->
name|incremental_interface
condition|)
else|#
directive|else
if|if
condition|(
operator|!
name|loader
operator|->
name|glyf_offset
condition|)
endif|#
directive|endif
comment|/* FT_CONFIG_OPTION_INCREMENTAL */
block|{
name|FT_TRACE2
argument_list|(
operator|(
literal|"no `glyf' table but non-zero `loca' entry\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Table
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|error
operator|=
name|face
operator|->
name|access_glyph_frame
argument_list|(
name|loader
argument_list|,
name|glyph_index
argument_list|,
name|loader
operator|->
name|glyf_offset
operator|+
name|offset
argument_list|,
name|loader
operator|->
name|byte_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|opened_frame
operator|=
literal|1
expr_stmt|;
comment|/* read glyph header first */
name|error
operator|=
name|face
operator|->
name|read_glyph_header
argument_list|(
name|loader
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
comment|/* the metrics must be computed after loading the glyph header */
comment|/* since we need the glyph's `yMax' value in case the vertical */
comment|/* metrics must be emulated                                    */
name|error
operator|=
name|tt_get_metrics
argument_list|(
name|loader
argument_list|,
name|glyph_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
if|if
condition|(
name|header_only
condition|)
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|loader
operator|->
name|byte_len
operator|==
literal|0
operator|||
name|loader
operator|->
name|n_contours
operator|==
literal|0
condition|)
block|{
name|loader
operator|->
name|bbox
operator|.
name|xMin
operator|=
literal|0
expr_stmt|;
name|loader
operator|->
name|bbox
operator|.
name|xMax
operator|=
literal|0
expr_stmt|;
name|loader
operator|->
name|bbox
operator|.
name|yMin
operator|=
literal|0
expr_stmt|;
name|loader
operator|->
name|bbox
operator|.
name|yMax
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|tt_get_metrics
argument_list|(
name|loader
argument_list|,
name|glyph_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
if|if
condition|(
name|header_only
condition|)
goto|goto
name|Exit
goto|;
comment|/* must initialize points before (possibly) overriding */
comment|/* glyph metrics from the incremental interface        */
name|TT_LOADER_SET_PP
argument_list|(
name|loader
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FT_CONFIG_OPTION_INCREMENTAL
name|tt_get_metrics_incr_overrides
argument_list|(
name|loader
argument_list|,
name|glyph_index
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_GX_VAR_SUPPORT
if|if
condition|(
operator|(
call|(
name|TT_Face
call|)
argument_list|(
name|loader
operator|->
name|face
argument_list|)
operator|)
operator|->
name|doblend
condition|)
block|{
comment|/* this must be done before scaling */
name|FT_Memory
name|memory
init|=
name|loader
operator|->
name|face
operator|->
name|memory
decl_stmt|;
name|error
operator|=
name|TT_Vary_Get_Glyph_Deltas
argument_list|(
call|(
name|TT_Face
call|)
argument_list|(
name|loader
operator|->
name|face
argument_list|)
argument_list|,
name|glyph_index
argument_list|,
operator|&
name|deltas
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|loader
operator|->
name|pp1
operator|.
name|x
operator|+=
name|deltas
index|[
literal|0
index|]
operator|.
name|x
expr_stmt|;
name|loader
operator|->
name|pp1
operator|.
name|y
operator|+=
name|deltas
index|[
literal|0
index|]
operator|.
name|y
expr_stmt|;
name|loader
operator|->
name|pp2
operator|.
name|x
operator|+=
name|deltas
index|[
literal|1
index|]
operator|.
name|x
expr_stmt|;
name|loader
operator|->
name|pp2
operator|.
name|y
operator|+=
name|deltas
index|[
literal|1
index|]
operator|.
name|y
expr_stmt|;
name|loader
operator|->
name|pp3
operator|.
name|x
operator|+=
name|deltas
index|[
literal|2
index|]
operator|.
name|x
expr_stmt|;
name|loader
operator|->
name|pp3
operator|.
name|y
operator|+=
name|deltas
index|[
literal|2
index|]
operator|.
name|y
expr_stmt|;
name|loader
operator|->
name|pp4
operator|.
name|x
operator|+=
name|deltas
index|[
literal|3
index|]
operator|.
name|x
expr_stmt|;
name|loader
operator|->
name|pp4
operator|.
name|y
operator|+=
name|deltas
index|[
literal|3
index|]
operator|.
name|y
expr_stmt|;
name|FT_FREE
argument_list|(
name|deltas
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* TT_CONFIG_OPTION_GX_VAR_SUPPORT */
comment|/* scale phantom points, if necessary; */
comment|/* they get rounded in `TT_Hint_Glyph' */
if|if
condition|(
operator|(
name|loader
operator|->
name|load_flags
operator|&
name|FT_LOAD_NO_SCALE
operator|)
operator|==
literal|0
condition|)
block|{
name|loader
operator|->
name|pp1
operator|.
name|x
operator|=
name|FT_MulFix
argument_list|(
name|loader
operator|->
name|pp1
operator|.
name|x
argument_list|,
name|x_scale
argument_list|)
expr_stmt|;
name|loader
operator|->
name|pp2
operator|.
name|x
operator|=
name|FT_MulFix
argument_list|(
name|loader
operator|->
name|pp2
operator|.
name|x
argument_list|,
name|x_scale
argument_list|)
expr_stmt|;
comment|/* pp1.y and pp2.y are always zero */
name|loader
operator|->
name|pp3
operator|.
name|x
operator|=
name|FT_MulFix
argument_list|(
name|loader
operator|->
name|pp3
operator|.
name|x
argument_list|,
name|x_scale
argument_list|)
expr_stmt|;
name|loader
operator|->
name|pp3
operator|.
name|y
operator|=
name|FT_MulFix
argument_list|(
name|loader
operator|->
name|pp3
operator|.
name|y
argument_list|,
name|y_scale
argument_list|)
expr_stmt|;
name|loader
operator|->
name|pp4
operator|.
name|x
operator|=
name|FT_MulFix
argument_list|(
name|loader
operator|->
name|pp4
operator|.
name|x
argument_list|,
name|x_scale
argument_list|)
expr_stmt|;
name|loader
operator|->
name|pp4
operator|.
name|y
operator|=
name|FT_MulFix
argument_list|(
name|loader
operator|->
name|pp4
operator|.
name|y
argument_list|,
name|y_scale
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|FT_Err_Ok
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* must initialize phantom points before (possibly) overriding */
comment|/* glyph metrics from the incremental interface                */
name|TT_LOADER_SET_PP
argument_list|(
name|loader
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FT_CONFIG_OPTION_INCREMENTAL
name|tt_get_metrics_incr_overrides
argument_list|(
name|loader
argument_list|,
name|glyph_index
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/***********************************************************************/
comment|/***********************************************************************/
comment|/***********************************************************************/
comment|/* if it is a simple glyph, load it */
if|if
condition|(
name|loader
operator|->
name|n_contours
operator|>
literal|0
condition|)
block|{
name|error
operator|=
name|face
operator|->
name|read_simple_glyph
argument_list|(
name|loader
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
comment|/* all data have been read */
name|face
operator|->
name|forget_glyph_frame
argument_list|(
name|loader
argument_list|)
expr_stmt|;
name|opened_frame
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|TT_Process_Simple_Glyph
argument_list|(
name|loader
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|FT_GlyphLoader_Add
argument_list|(
name|gloader
argument_list|)
expr_stmt|;
block|}
comment|/***********************************************************************/
comment|/***********************************************************************/
comment|/***********************************************************************/
comment|/* otherwise, load a composite! */
elseif|else
if|if
condition|(
name|loader
operator|->
name|n_contours
operator|==
operator|-
literal|1
condition|)
block|{
name|FT_UInt
name|start_point
decl_stmt|;
name|FT_UInt
name|start_contour
decl_stmt|;
name|FT_ULong
name|ins_pos
decl_stmt|;
comment|/* position of composite instructions, if any */
name|start_point
operator|=
name|gloader
operator|->
name|base
operator|.
name|outline
operator|.
name|n_points
expr_stmt|;
name|start_contour
operator|=
name|gloader
operator|->
name|base
operator|.
name|outline
operator|.
name|n_contours
expr_stmt|;
comment|/* for each subglyph, read composite header */
name|error
operator|=
name|face
operator|->
name|read_composite_glyph
argument_list|(
name|loader
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
comment|/* store the offset of instructions */
name|ins_pos
operator|=
name|loader
operator|->
name|ins_pos
expr_stmt|;
comment|/* all data we need are read */
name|face
operator|->
name|forget_glyph_frame
argument_list|(
name|loader
argument_list|)
expr_stmt|;
name|opened_frame
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_GX_VAR_SUPPORT
if|if
condition|(
name|face
operator|->
name|doblend
condition|)
block|{
name|FT_Int
name|i
decl_stmt|,
name|limit
decl_stmt|;
name|FT_SubGlyph
name|subglyph
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|face
operator|->
name|root
operator|.
name|memory
decl_stmt|;
comment|/* this provides additional offsets */
comment|/* for each component's translation */
if|if
condition|(
operator|(
name|error
operator|=
name|TT_Vary_Get_Glyph_Deltas
argument_list|(
name|face
argument_list|,
name|glyph_index
argument_list|,
operator|&
name|deltas
argument_list|,
name|gloader
operator|->
name|current
operator|.
name|num_subglyphs
operator|+
literal|4
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|Exit
goto|;
name|subglyph
operator|=
name|gloader
operator|->
name|current
operator|.
name|subglyphs
operator|+
name|gloader
operator|->
name|base
operator|.
name|num_subglyphs
expr_stmt|;
name|limit
operator|=
name|gloader
operator|->
name|current
operator|.
name|num_subglyphs
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|limit
condition|;
operator|++
name|i
operator|,
operator|++
name|subglyph
control|)
block|{
if|if
condition|(
name|subglyph
operator|->
name|flags
operator|&
name|ARGS_ARE_XY_VALUES
condition|)
block|{
comment|/* XXX: overflow check for subglyph->{arg1,arg2}.   */
comment|/* deltas[i].{x,y} must be within signed 16-bit,    */
comment|/* but the restriction of summed delta is not clear */
name|subglyph
operator|->
name|arg1
operator|+=
operator|(
name|FT_Int16
operator|)
name|deltas
index|[
name|i
index|]
operator|.
name|x
expr_stmt|;
name|subglyph
operator|->
name|arg2
operator|+=
operator|(
name|FT_Int16
operator|)
name|deltas
index|[
name|i
index|]
operator|.
name|y
expr_stmt|;
block|}
block|}
name|loader
operator|->
name|pp1
operator|.
name|x
operator|+=
name|deltas
index|[
name|i
operator|+
literal|0
index|]
operator|.
name|x
expr_stmt|;
name|loader
operator|->
name|pp1
operator|.
name|y
operator|+=
name|deltas
index|[
name|i
operator|+
literal|0
index|]
operator|.
name|y
expr_stmt|;
name|loader
operator|->
name|pp2
operator|.
name|x
operator|+=
name|deltas
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|x
expr_stmt|;
name|loader
operator|->
name|pp2
operator|.
name|y
operator|+=
name|deltas
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|y
expr_stmt|;
name|loader
operator|->
name|pp3
operator|.
name|x
operator|+=
name|deltas
index|[
name|i
operator|+
literal|2
index|]
operator|.
name|x
expr_stmt|;
name|loader
operator|->
name|pp3
operator|.
name|y
operator|+=
name|deltas
index|[
name|i
operator|+
literal|2
index|]
operator|.
name|y
expr_stmt|;
name|loader
operator|->
name|pp4
operator|.
name|x
operator|+=
name|deltas
index|[
name|i
operator|+
literal|3
index|]
operator|.
name|x
expr_stmt|;
name|loader
operator|->
name|pp4
operator|.
name|y
operator|+=
name|deltas
index|[
name|i
operator|+
literal|3
index|]
operator|.
name|y
expr_stmt|;
name|FT_FREE
argument_list|(
name|deltas
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* TT_CONFIG_OPTION_GX_VAR_SUPPORT */
comment|/* scale phantom points, if necessary; */
comment|/* they get rounded in `TT_Hint_Glyph' */
if|if
condition|(
operator|(
name|loader
operator|->
name|load_flags
operator|&
name|FT_LOAD_NO_SCALE
operator|)
operator|==
literal|0
condition|)
block|{
name|loader
operator|->
name|pp1
operator|.
name|x
operator|=
name|FT_MulFix
argument_list|(
name|loader
operator|->
name|pp1
operator|.
name|x
argument_list|,
name|x_scale
argument_list|)
expr_stmt|;
name|loader
operator|->
name|pp2
operator|.
name|x
operator|=
name|FT_MulFix
argument_list|(
name|loader
operator|->
name|pp2
operator|.
name|x
argument_list|,
name|x_scale
argument_list|)
expr_stmt|;
comment|/* pp1.y and pp2.y are always zero */
name|loader
operator|->
name|pp3
operator|.
name|x
operator|=
name|FT_MulFix
argument_list|(
name|loader
operator|->
name|pp3
operator|.
name|x
argument_list|,
name|x_scale
argument_list|)
expr_stmt|;
name|loader
operator|->
name|pp3
operator|.
name|y
operator|=
name|FT_MulFix
argument_list|(
name|loader
operator|->
name|pp3
operator|.
name|y
argument_list|,
name|y_scale
argument_list|)
expr_stmt|;
name|loader
operator|->
name|pp4
operator|.
name|x
operator|=
name|FT_MulFix
argument_list|(
name|loader
operator|->
name|pp4
operator|.
name|x
argument_list|,
name|x_scale
argument_list|)
expr_stmt|;
name|loader
operator|->
name|pp4
operator|.
name|y
operator|=
name|FT_MulFix
argument_list|(
name|loader
operator|->
name|pp4
operator|.
name|y
argument_list|,
name|y_scale
argument_list|)
expr_stmt|;
block|}
comment|/* if the flag FT_LOAD_NO_RECURSE is set, we return the subglyph */
comment|/* `as is' in the glyph slot (the client application will be     */
comment|/* responsible for interpreting these data)...                   */
if|if
condition|(
name|loader
operator|->
name|load_flags
operator|&
name|FT_LOAD_NO_RECURSE
condition|)
block|{
name|FT_GlyphLoader_Add
argument_list|(
name|gloader
argument_list|)
expr_stmt|;
name|loader
operator|->
name|glyph
operator|->
name|format
operator|=
name|FT_GLYPH_FORMAT_COMPOSITE
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/*********************************************************************/
comment|/*********************************************************************/
comment|/*********************************************************************/
block|{
name|FT_UInt
name|n
decl_stmt|,
name|num_base_points
decl_stmt|;
name|FT_SubGlyph
name|subglyph
init|=
literal|0
decl_stmt|;
name|FT_UInt
name|num_points
init|=
name|start_point
decl_stmt|;
name|FT_UInt
name|num_subglyphs
init|=
name|gloader
operator|->
name|current
operator|.
name|num_subglyphs
decl_stmt|;
name|FT_UInt
name|num_base_subgs
init|=
name|gloader
operator|->
name|base
operator|.
name|num_subglyphs
decl_stmt|;
name|FT_Stream
name|old_stream
init|=
name|loader
operator|->
name|stream
decl_stmt|;
name|FT_Int
name|old_byte_len
init|=
name|loader
operator|->
name|byte_len
decl_stmt|;
name|FT_GlyphLoader_Add
argument_list|(
name|gloader
argument_list|)
expr_stmt|;
comment|/* read each subglyph independently */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|num_subglyphs
condition|;
name|n
operator|++
control|)
block|{
name|FT_Vector
name|pp
index|[
literal|4
index|]
decl_stmt|;
comment|/* Each time we call load_truetype_glyph in this loop, the   */
comment|/* value of `gloader.base.subglyphs' can change due to table */
comment|/* reallocations.  We thus need to recompute the subglyph    */
comment|/* pointer on each iteration.                                */
name|subglyph
operator|=
name|gloader
operator|->
name|base
operator|.
name|subglyphs
operator|+
name|num_base_subgs
operator|+
name|n
expr_stmt|;
name|pp
index|[
literal|0
index|]
operator|=
name|loader
operator|->
name|pp1
expr_stmt|;
name|pp
index|[
literal|1
index|]
operator|=
name|loader
operator|->
name|pp2
expr_stmt|;
name|pp
index|[
literal|2
index|]
operator|=
name|loader
operator|->
name|pp3
expr_stmt|;
name|pp
index|[
literal|3
index|]
operator|=
name|loader
operator|->
name|pp4
expr_stmt|;
name|num_base_points
operator|=
name|gloader
operator|->
name|base
operator|.
name|outline
operator|.
name|n_points
expr_stmt|;
name|error
operator|=
name|load_truetype_glyph
argument_list|(
name|loader
argument_list|,
name|subglyph
operator|->
name|index
argument_list|,
name|recurse_count
operator|+
literal|1
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
comment|/* restore subglyph pointer */
name|subglyph
operator|=
name|gloader
operator|->
name|base
operator|.
name|subglyphs
operator|+
name|num_base_subgs
operator|+
name|n
expr_stmt|;
comment|/* restore phantom points if necessary */
if|if
condition|(
operator|!
operator|(
name|subglyph
operator|->
name|flags
operator|&
name|USE_MY_METRICS
operator|)
condition|)
block|{
name|loader
operator|->
name|pp1
operator|=
name|pp
index|[
literal|0
index|]
expr_stmt|;
name|loader
operator|->
name|pp2
operator|=
name|pp
index|[
literal|1
index|]
expr_stmt|;
name|loader
operator|->
name|pp3
operator|=
name|pp
index|[
literal|2
index|]
expr_stmt|;
name|loader
operator|->
name|pp4
operator|=
name|pp
index|[
literal|3
index|]
expr_stmt|;
block|}
name|num_points
operator|=
name|gloader
operator|->
name|base
operator|.
name|outline
operator|.
name|n_points
expr_stmt|;
if|if
condition|(
name|num_points
operator|==
name|num_base_points
condition|)
continue|continue;
comment|/* gloader->base.outline consists of three parts:               */
comment|/* 0 -(1)-> start_point -(2)-> num_base_points -(3)-> n_points. */
comment|/*                                                              */
comment|/* (1): exists from the beginning                               */
comment|/* (2): components that have been loaded so far                 */
comment|/* (3): the newly loaded component                              */
name|error
operator|=
name|TT_Process_Composite_Component
argument_list|(
name|loader
argument_list|,
name|subglyph
argument_list|,
name|start_point
argument_list|,
name|num_base_points
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
block|}
name|loader
operator|->
name|stream
operator|=
name|old_stream
expr_stmt|;
name|loader
operator|->
name|byte_len
operator|=
name|old_byte_len
expr_stmt|;
comment|/* process the glyph */
name|loader
operator|->
name|ins_pos
operator|=
name|ins_pos
expr_stmt|;
if|if
condition|(
name|IS_HINTED
argument_list|(
name|loader
operator|->
name|load_flags
argument_list|)
operator|&&
ifdef|#
directive|ifdef
name|TT_USE_BYTECODE_INTERPRETER
name|subglyph
operator|->
name|flags
operator|&
name|WE_HAVE_INSTR
operator|&&
endif|#
directive|endif
name|num_points
operator|>
name|start_point
condition|)
block|{
name|error
operator|=
name|TT_Process_Composite_Glyph
argument_list|(
name|loader
argument_list|,
name|start_point
argument_list|,
name|start_contour
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
block|}
block|}
block|}
else|else
block|{
comment|/* invalid composite count (negative but not -1) */
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Outline
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/***********************************************************************/
comment|/***********************************************************************/
comment|/***********************************************************************/
name|Exit
label|:
if|if
condition|(
name|opened_frame
condition|)
name|face
operator|->
name|forget_glyph_frame
argument_list|(
name|loader
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FT_CONFIG_OPTION_INCREMENTAL
if|if
condition|(
name|glyph_data_loaded
condition|)
name|face
operator|->
name|root
operator|.
name|internal
operator|->
name|incremental_interface
operator|->
name|funcs
operator|->
name|free_glyph_data
argument_list|(
name|face
operator|->
name|root
operator|.
name|internal
operator|->
name|incremental_interface
operator|->
name|object
argument_list|,
operator|&
name|glyph_data
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|error
return|;
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|compute_glyph_metrics
name|compute_glyph_metrics
parameter_list|(
name|TT_Loader
name|loader
parameter_list|,
name|FT_UInt
name|glyph_index
parameter_list|)
block|{
name|TT_Face
name|face
init|=
operator|(
name|TT_Face
operator|)
name|loader
operator|->
name|face
decl_stmt|;
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_SUBPIXEL_HINTING
name|TT_Driver
name|driver
init|=
operator|(
name|TT_Driver
operator|)
name|FT_FACE_DRIVER
argument_list|(
name|face
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|FT_BBox
name|bbox
decl_stmt|;
name|FT_Fixed
name|y_scale
decl_stmt|;
name|TT_GlyphSlot
name|glyph
init|=
name|loader
operator|->
name|glyph
decl_stmt|;
name|TT_Size
name|size
init|=
operator|(
name|TT_Size
operator|)
name|loader
operator|->
name|size
decl_stmt|;
name|y_scale
operator|=
literal|0x10000L
expr_stmt|;
if|if
condition|(
operator|(
name|loader
operator|->
name|load_flags
operator|&
name|FT_LOAD_NO_SCALE
operator|)
operator|==
literal|0
condition|)
name|y_scale
operator|=
name|size
operator|->
name|root
operator|.
name|metrics
operator|.
name|y_scale
expr_stmt|;
if|if
condition|(
name|glyph
operator|->
name|format
operator|!=
name|FT_GLYPH_FORMAT_COMPOSITE
condition|)
name|FT_Outline_Get_CBox
argument_list|(
operator|&
name|glyph
operator|->
name|outline
argument_list|,
operator|&
name|bbox
argument_list|)
expr_stmt|;
else|else
name|bbox
operator|=
name|loader
operator|->
name|bbox
expr_stmt|;
comment|/* get the device-independent horizontal advance; it is scaled later */
comment|/* by the base layer.                                                */
name|glyph
operator|->
name|linearHoriAdvance
operator|=
name|loader
operator|->
name|linear
expr_stmt|;
name|glyph
operator|->
name|metrics
operator|.
name|horiBearingX
operator|=
name|bbox
operator|.
name|xMin
expr_stmt|;
name|glyph
operator|->
name|metrics
operator|.
name|horiBearingY
operator|=
name|bbox
operator|.
name|yMax
expr_stmt|;
name|glyph
operator|->
name|metrics
operator|.
name|horiAdvance
operator|=
name|loader
operator|->
name|pp2
operator|.
name|x
operator|-
name|loader
operator|->
name|pp1
operator|.
name|x
expr_stmt|;
comment|/* adjust advance width to the value contained in the hdmx table */
if|if
condition|(
operator|!
name|face
operator|->
name|postscript
operator|.
name|isFixedPitch
operator|&&
name|IS_HINTED
argument_list|(
name|loader
operator|->
name|load_flags
argument_list|)
condition|)
block|{
name|FT_Byte
modifier|*
name|widthp
decl_stmt|;
name|widthp
operator|=
name|tt_face_get_device_metrics
argument_list|(
name|face
argument_list|,
name|size
operator|->
name|root
operator|.
name|metrics
operator|.
name|x_ppem
argument_list|,
name|glyph_index
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_SUBPIXEL_HINTING
if|if
condition|(
name|driver
operator|->
name|interpreter_version
operator|==
name|TT_INTERPRETER_VERSION_38
condition|)
block|{
name|FT_Bool
name|ignore_x_mode
decl_stmt|;
name|ignore_x_mode
operator|=
name|FT_BOOL
argument_list|(
name|FT_LOAD_TARGET_MODE
argument_list|(
name|loader
operator|->
name|load_flags
argument_list|)
operator|!=
name|FT_RENDER_MODE_MONO
argument_list|)
expr_stmt|;
if|if
condition|(
name|widthp
operator|&&
operator|(
operator|(
name|ignore_x_mode
operator|&&
name|loader
operator|->
name|exec
operator|->
name|compatible_widths
operator|)
operator|||
operator|!
name|ignore_x_mode
operator|||
name|SPH_OPTION_BITMAP_WIDTHS
operator|)
condition|)
name|glyph
operator|->
name|metrics
operator|.
name|horiAdvance
operator|=
operator|*
name|widthp
operator|<<
literal|6
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
block|{
if|if
condition|(
name|widthp
condition|)
name|glyph
operator|->
name|metrics
operator|.
name|horiAdvance
operator|=
operator|*
name|widthp
operator|<<
literal|6
expr_stmt|;
block|}
block|}
comment|/* set glyph dimensions */
name|glyph
operator|->
name|metrics
operator|.
name|width
operator|=
name|bbox
operator|.
name|xMax
operator|-
name|bbox
operator|.
name|xMin
expr_stmt|;
name|glyph
operator|->
name|metrics
operator|.
name|height
operator|=
name|bbox
operator|.
name|yMax
operator|-
name|bbox
operator|.
name|yMin
expr_stmt|;
comment|/* Now take care of vertical metrics.  In the case where there is */
comment|/* no vertical information within the font (relatively common),   */
comment|/* create some metrics manually                                   */
block|{
name|FT_Pos
name|top
decl_stmt|;
comment|/* scaled vertical top side bearing  */
name|FT_Pos
name|advance
decl_stmt|;
comment|/* scaled vertical advance height    */
comment|/* Get the unscaled top bearing and advance height. */
if|if
condition|(
name|face
operator|->
name|vertical_info
operator|&&
name|face
operator|->
name|vertical
operator|.
name|number_Of_VMetrics
operator|>
literal|0
condition|)
block|{
name|top
operator|=
operator|(
name|FT_Short
operator|)
name|FT_DivFix
argument_list|(
name|loader
operator|->
name|pp3
operator|.
name|y
operator|-
name|bbox
operator|.
name|yMax
argument_list|,
name|y_scale
argument_list|)
expr_stmt|;
if|if
condition|(
name|loader
operator|->
name|pp3
operator|.
name|y
operator|<=
name|loader
operator|->
name|pp4
operator|.
name|y
condition|)
name|advance
operator|=
literal|0
expr_stmt|;
else|else
name|advance
operator|=
operator|(
name|FT_UShort
operator|)
name|FT_DivFix
argument_list|(
name|loader
operator|->
name|pp3
operator|.
name|y
operator|-
name|loader
operator|->
name|pp4
operator|.
name|y
argument_list|,
name|y_scale
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|FT_Pos
name|height
decl_stmt|;
comment|/* XXX Compute top side bearing and advance height in  */
comment|/*     Get_VMetrics instead of here.                   */
comment|/* NOTE: The OS/2 values are the only `portable' ones, */
comment|/*       which is why we use them, if there is an OS/2 */
comment|/*       table in the font.  Otherwise, we use the     */
comment|/*       values defined in the horizontal header.      */
name|height
operator|=
operator|(
name|FT_Short
operator|)
name|FT_DivFix
argument_list|(
name|bbox
operator|.
name|yMax
operator|-
name|bbox
operator|.
name|yMin
argument_list|,
name|y_scale
argument_list|)
expr_stmt|;
if|if
condition|(
name|face
operator|->
name|os2
operator|.
name|version
operator|!=
literal|0xFFFFU
condition|)
name|advance
operator|=
call|(
name|FT_Pos
call|)
argument_list|(
name|face
operator|->
name|os2
operator|.
name|sTypoAscender
operator|-
name|face
operator|->
name|os2
operator|.
name|sTypoDescender
argument_list|)
expr_stmt|;
else|else
name|advance
operator|=
call|(
name|FT_Pos
call|)
argument_list|(
name|face
operator|->
name|horizontal
operator|.
name|Ascender
operator|-
name|face
operator|->
name|horizontal
operator|.
name|Descender
argument_list|)
expr_stmt|;
name|top
operator|=
operator|(
name|advance
operator|-
name|height
operator|)
operator|/
literal|2
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|FT_CONFIG_OPTION_INCREMENTAL
block|{
name|FT_Incremental_InterfaceRec
modifier|*
name|incr
decl_stmt|;
name|FT_Incremental_MetricsRec
name|metrics
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|incr
operator|=
name|face
operator|->
name|root
operator|.
name|internal
operator|->
name|incremental_interface
expr_stmt|;
comment|/* If this is an incrementally loaded font see if there are */
comment|/* overriding metrics for this glyph.                       */
if|if
condition|(
name|incr
operator|&&
name|incr
operator|->
name|funcs
operator|->
name|get_glyph_metrics
condition|)
block|{
name|metrics
operator|.
name|bearing_x
operator|=
literal|0
expr_stmt|;
name|metrics
operator|.
name|bearing_y
operator|=
name|top
expr_stmt|;
name|metrics
operator|.
name|advance
operator|=
name|advance
expr_stmt|;
name|error
operator|=
name|incr
operator|->
name|funcs
operator|->
name|get_glyph_metrics
argument_list|(
name|incr
operator|->
name|object
argument_list|,
name|glyph_index
argument_list|,
name|TRUE
argument_list|,
operator|&
name|metrics
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|top
operator|=
name|metrics
operator|.
name|bearing_y
expr_stmt|;
name|advance
operator|=
name|metrics
operator|.
name|advance
expr_stmt|;
block|}
block|}
comment|/* GWW: Do vertical metrics get loaded incrementally too? */
endif|#
directive|endif
comment|/* FT_CONFIG_OPTION_INCREMENTAL */
name|glyph
operator|->
name|linearVertAdvance
operator|=
name|advance
expr_stmt|;
comment|/* scale the metrics */
if|if
condition|(
operator|!
operator|(
name|loader
operator|->
name|load_flags
operator|&
name|FT_LOAD_NO_SCALE
operator|)
condition|)
block|{
name|top
operator|=
name|FT_MulFix
argument_list|(
name|top
argument_list|,
name|y_scale
argument_list|)
expr_stmt|;
name|advance
operator|=
name|FT_MulFix
argument_list|(
name|advance
argument_list|,
name|y_scale
argument_list|)
expr_stmt|;
block|}
comment|/* XXX: for now, we have no better algorithm for the lsb, but it */
comment|/*      should work fine.                                        */
comment|/*                                                               */
name|glyph
operator|->
name|metrics
operator|.
name|vertBearingX
operator|=
name|glyph
operator|->
name|metrics
operator|.
name|horiBearingX
operator|-
name|glyph
operator|->
name|metrics
operator|.
name|horiAdvance
operator|/
literal|2
expr_stmt|;
name|glyph
operator|->
name|metrics
operator|.
name|vertBearingY
operator|=
name|top
expr_stmt|;
name|glyph
operator|->
name|metrics
operator|.
name|vertAdvance
operator|=
name|advance
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_EMBEDDED_BITMAPS
end_ifdef
begin_function
specifier|static
name|FT_Error
DECL|function|load_sbit_image
name|load_sbit_image
parameter_list|(
name|TT_Size
name|size
parameter_list|,
name|TT_GlyphSlot
name|glyph
parameter_list|,
name|FT_UInt
name|glyph_index
parameter_list|,
name|FT_Int32
name|load_flags
parameter_list|)
block|{
name|TT_Face
name|face
decl_stmt|;
name|SFNT_Service
name|sfnt
decl_stmt|;
name|FT_Stream
name|stream
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|TT_SBit_MetricsRec
name|metrics
decl_stmt|;
name|face
operator|=
operator|(
name|TT_Face
operator|)
name|glyph
operator|->
name|face
expr_stmt|;
name|sfnt
operator|=
operator|(
name|SFNT_Service
operator|)
name|face
operator|->
name|sfnt
expr_stmt|;
name|stream
operator|=
name|face
operator|->
name|root
operator|.
name|stream
expr_stmt|;
name|error
operator|=
name|sfnt
operator|->
name|load_sbit_image
argument_list|(
name|face
argument_list|,
name|size
operator|->
name|strike_index
argument_list|,
name|glyph_index
argument_list|,
operator|(
name|FT_Int
operator|)
name|load_flags
argument_list|,
name|stream
argument_list|,
operator|&
name|glyph
operator|->
name|bitmap
argument_list|,
operator|&
name|metrics
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|glyph
operator|->
name|outline
operator|.
name|n_points
operator|=
literal|0
expr_stmt|;
name|glyph
operator|->
name|outline
operator|.
name|n_contours
operator|=
literal|0
expr_stmt|;
name|glyph
operator|->
name|metrics
operator|.
name|width
operator|=
operator|(
name|FT_Pos
operator|)
name|metrics
operator|.
name|width
operator|<<
literal|6
expr_stmt|;
name|glyph
operator|->
name|metrics
operator|.
name|height
operator|=
operator|(
name|FT_Pos
operator|)
name|metrics
operator|.
name|height
operator|<<
literal|6
expr_stmt|;
name|glyph
operator|->
name|metrics
operator|.
name|horiBearingX
operator|=
operator|(
name|FT_Pos
operator|)
name|metrics
operator|.
name|horiBearingX
operator|<<
literal|6
expr_stmt|;
name|glyph
operator|->
name|metrics
operator|.
name|horiBearingY
operator|=
operator|(
name|FT_Pos
operator|)
name|metrics
operator|.
name|horiBearingY
operator|<<
literal|6
expr_stmt|;
name|glyph
operator|->
name|metrics
operator|.
name|horiAdvance
operator|=
operator|(
name|FT_Pos
operator|)
name|metrics
operator|.
name|horiAdvance
operator|<<
literal|6
expr_stmt|;
name|glyph
operator|->
name|metrics
operator|.
name|vertBearingX
operator|=
operator|(
name|FT_Pos
operator|)
name|metrics
operator|.
name|vertBearingX
operator|<<
literal|6
expr_stmt|;
name|glyph
operator|->
name|metrics
operator|.
name|vertBearingY
operator|=
operator|(
name|FT_Pos
operator|)
name|metrics
operator|.
name|vertBearingY
operator|<<
literal|6
expr_stmt|;
name|glyph
operator|->
name|metrics
operator|.
name|vertAdvance
operator|=
operator|(
name|FT_Pos
operator|)
name|metrics
operator|.
name|vertAdvance
operator|<<
literal|6
expr_stmt|;
name|glyph
operator|->
name|format
operator|=
name|FT_GLYPH_FORMAT_BITMAP
expr_stmt|;
if|if
condition|(
name|load_flags
operator|&
name|FT_LOAD_VERTICAL_LAYOUT
condition|)
block|{
name|glyph
operator|->
name|bitmap_left
operator|=
name|metrics
operator|.
name|vertBearingX
expr_stmt|;
name|glyph
operator|->
name|bitmap_top
operator|=
name|metrics
operator|.
name|vertBearingY
expr_stmt|;
block|}
else|else
block|{
name|glyph
operator|->
name|bitmap_left
operator|=
name|metrics
operator|.
name|horiBearingX
expr_stmt|;
name|glyph
operator|->
name|bitmap_top
operator|=
name|metrics
operator|.
name|horiBearingY
expr_stmt|;
block|}
block|}
return|return
name|error
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* TT_CONFIG_OPTION_EMBEDDED_BITMAPS */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|tt_loader_init
name|tt_loader_init
parameter_list|(
name|TT_Loader
name|loader
parameter_list|,
name|TT_Size
name|size
parameter_list|,
name|TT_GlyphSlot
name|glyph
parameter_list|,
name|FT_Int32
name|load_flags
parameter_list|,
name|FT_Bool
name|glyf_table_only
parameter_list|)
block|{
name|FT_Error
name|error
decl_stmt|;
name|TT_Face
name|face
decl_stmt|;
name|FT_Stream
name|stream
decl_stmt|;
ifdef|#
directive|ifdef
name|TT_USE_BYTECODE_INTERPRETER
name|FT_Bool
name|pedantic
init|=
name|FT_BOOL
argument_list|(
name|load_flags
operator|&
name|FT_LOAD_PEDANTIC
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|face
operator|=
operator|(
name|TT_Face
operator|)
name|glyph
operator|->
name|face
expr_stmt|;
name|stream
operator|=
name|face
operator|->
name|root
operator|.
name|stream
expr_stmt|;
name|FT_MEM_ZERO
argument_list|(
name|loader
argument_list|,
sizeof|sizeof
argument_list|(
name|TT_LoaderRec
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TT_USE_BYTECODE_INTERPRETER
comment|/* load execution context */
if|if
condition|(
name|IS_HINTED
argument_list|(
name|load_flags
argument_list|)
operator|&&
operator|!
name|glyf_table_only
condition|)
block|{
name|TT_ExecContext
name|exec
decl_stmt|;
name|FT_Bool
name|grayscale
decl_stmt|;
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_SUBPIXEL_HINTING
name|TT_Driver
name|driver
init|=
operator|(
name|TT_Driver
operator|)
name|FT_FACE_DRIVER
argument_list|(
name|face
argument_list|)
decl_stmt|;
name|FT_Bool
name|subpixel
init|=
name|FALSE
decl_stmt|;
if|#
directive|if
literal|0
comment|/* not used yet */
block|FT_Bool  compatible_widths;       FT_Bool  symmetrical_smoothing;       FT_Bool  bgr;       FT_Bool  subpixel_positioned;
endif|#
directive|endif
endif|#
directive|endif
comment|/* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
name|FT_Bool
name|reexecute
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|size
operator|->
name|bytecode_ready
operator|<
literal|0
operator|||
name|size
operator|->
name|cvt_ready
operator|<
literal|0
condition|)
block|{
name|error
operator|=
name|tt_size_ready_bytecode
argument_list|(
name|size
argument_list|,
name|pedantic
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
block|}
elseif|else
if|if
condition|(
name|size
operator|->
name|bytecode_ready
condition|)
return|return
name|size
operator|->
name|bytecode_ready
return|;
elseif|else
if|if
condition|(
name|size
operator|->
name|cvt_ready
condition|)
return|return
name|size
operator|->
name|cvt_ready
return|;
comment|/* query new execution context */
name|exec
operator|=
name|size
operator|->
name|debug
condition|?
name|size
operator|->
name|context
else|:
operator|(
operator|(
name|TT_Driver
operator|)
name|FT_FACE_DRIVER
argument_list|(
name|face
argument_list|)
operator|)
operator|->
name|context
expr_stmt|;
if|if
condition|(
operator|!
name|exec
condition|)
return|return
name|FT_THROW
argument_list|(
name|Could_Not_Find_Context
argument_list|)
return|;
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_SUBPIXEL_HINTING
if|if
condition|(
name|driver
operator|->
name|interpreter_version
operator|==
name|TT_INTERPRETER_VERSION_38
condition|)
block|{
name|subpixel
operator|=
name|FT_BOOL
argument_list|(
operator|(
name|FT_LOAD_TARGET_MODE
argument_list|(
name|load_flags
argument_list|)
operator|!=
name|FT_RENDER_MODE_MONO
operator|)
operator|&&
name|SPH_OPTION_SET_SUBPIXEL
argument_list|)
expr_stmt|;
if|if
condition|(
name|subpixel
condition|)
name|grayscale
operator|=
name|FALSE
expr_stmt|;
elseif|else
if|if
condition|(
name|SPH_OPTION_SET_GRAYSCALE
condition|)
block|{
name|grayscale
operator|=
name|TRUE
expr_stmt|;
name|subpixel
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
name|grayscale
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|FT_IS_TRICKY
argument_list|(
name|glyph
operator|->
name|face
argument_list|)
condition|)
name|subpixel
operator|=
name|FALSE
expr_stmt|;
name|exec
operator|->
name|ignore_x_mode
operator|=
name|subpixel
operator|||
name|grayscale
expr_stmt|;
name|exec
operator|->
name|rasterizer_version
operator|=
name|SPH_OPTION_SET_RASTERIZER_VERSION
expr_stmt|;
if|if
condition|(
name|exec
operator|->
name|sph_tweak_flags
operator|&
name|SPH_TWEAK_RASTERIZER_35
condition|)
name|exec
operator|->
name|rasterizer_version
operator|=
name|TT_INTERPRETER_VERSION_35
expr_stmt|;
if|#
directive|if
literal|1
name|exec
operator|->
name|compatible_widths
operator|=
name|SPH_OPTION_SET_COMPATIBLE_WIDTHS
expr_stmt|;
name|exec
operator|->
name|symmetrical_smoothing
operator|=
name|FALSE
expr_stmt|;
name|exec
operator|->
name|bgr
operator|=
name|FALSE
expr_stmt|;
name|exec
operator|->
name|subpixel_positioned
operator|=
name|TRUE
expr_stmt|;
else|#
directive|else
comment|/* 0 */
name|exec
operator|->
name|compatible_widths
operator|=
name|FT_BOOL
argument_list|(
name|FT_LOAD_TARGET_MODE
argument_list|(
name|load_flags
argument_list|)
operator|!=
name|TT_LOAD_COMPATIBLE_WIDTHS
argument_list|)
expr_stmt|;
name|exec
operator|->
name|symmetrical_smoothing
operator|=
name|FT_BOOL
argument_list|(
name|FT_LOAD_TARGET_MODE
argument_list|(
name|load_flags
argument_list|)
operator|!=
name|TT_LOAD_SYMMETRICAL_SMOOTHING
argument_list|)
expr_stmt|;
name|exec
operator|->
name|bgr
operator|=
name|FT_BOOL
argument_list|(
name|FT_LOAD_TARGET_MODE
argument_list|(
name|load_flags
argument_list|)
operator|!=
name|TT_LOAD_BGR
argument_list|)
expr_stmt|;
name|exec
operator|->
name|subpixel_positioned
operator|=
name|FT_BOOL
argument_list|(
name|FT_LOAD_TARGET_MODE
argument_list|(
name|load_flags
argument_list|)
operator|!=
name|TT_LOAD_SUBPIXEL_POSITIONED
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 0 */
block|}
else|else
endif|#
directive|endif
comment|/* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
block|{
name|grayscale
operator|=
name|FT_BOOL
argument_list|(
name|FT_LOAD_TARGET_MODE
argument_list|(
name|load_flags
argument_list|)
operator|!=
name|FT_RENDER_MODE_MONO
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|TT_Load_Context
argument_list|(
name|exec
argument_list|,
name|face
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_SUBPIXEL_HINTING
if|if
condition|(
name|driver
operator|->
name|interpreter_version
operator|==
name|TT_INTERPRETER_VERSION_38
condition|)
block|{
comment|/* a change from mono to subpixel rendering (and vice versa) */
comment|/* requires a re-execution of the CVT program                */
if|if
condition|(
name|subpixel
operator|!=
name|exec
operator|->
name|subpixel
condition|)
block|{
name|FT_TRACE4
argument_list|(
operator|(
literal|"tt_loader_init: subpixel hinting change,"
literal|" re-executing `prep' table\n"
operator|)
argument_list|)
expr_stmt|;
name|exec
operator|->
name|subpixel
operator|=
name|subpixel
expr_stmt|;
name|reexecute
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* a change from mono to grayscale rendering (and vice versa) */
comment|/* requires a re-execution of the CVT program                 */
if|if
condition|(
name|grayscale
operator|!=
name|exec
operator|->
name|grayscale
condition|)
block|{
name|FT_TRACE4
argument_list|(
operator|(
literal|"tt_loader_init: grayscale hinting change,"
literal|" re-executing `prep' table\n"
operator|)
argument_list|)
expr_stmt|;
name|exec
operator|->
name|grayscale
operator|=
name|grayscale
expr_stmt|;
name|reexecute
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
comment|/* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
block|{
comment|/* a change from mono to grayscale rendering (and vice versa) */
comment|/* requires a re-execution of the CVT program                 */
if|if
condition|(
name|grayscale
operator|!=
name|exec
operator|->
name|grayscale
condition|)
block|{
name|FT_TRACE4
argument_list|(
operator|(
literal|"tt_loader_init: grayscale change,"
literal|" re-executing `prep' table\n"
operator|)
argument_list|)
expr_stmt|;
name|exec
operator|->
name|grayscale
operator|=
name|grayscale
expr_stmt|;
name|reexecute
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|reexecute
condition|)
block|{
name|FT_UInt
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
operator|->
name|cvt_size
condition|;
name|i
operator|++
control|)
name|size
operator|->
name|cvt
index|[
name|i
index|]
operator|=
name|FT_MulFix
argument_list|(
name|face
operator|->
name|cvt
index|[
name|i
index|]
argument_list|,
name|size
operator|->
name|ttmetrics
operator|.
name|scale
argument_list|)
expr_stmt|;
name|error
operator|=
name|tt_size_run_prep
argument_list|(
name|size
argument_list|,
name|pedantic
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
block|}
comment|/* see whether the cvt program has disabled hinting */
if|if
condition|(
name|exec
operator|->
name|GS
operator|.
name|instruct_control
operator|&
literal|1
condition|)
name|load_flags
operator||=
name|FT_LOAD_NO_HINTING
expr_stmt|;
comment|/* load default graphics state -- if needed */
if|if
condition|(
name|exec
operator|->
name|GS
operator|.
name|instruct_control
operator|&
literal|2
condition|)
name|exec
operator|->
name|GS
operator|=
name|tt_default_graphics_state
expr_stmt|;
name|exec
operator|->
name|pedantic_hinting
operator|=
name|FT_BOOL
argument_list|(
name|load_flags
operator|&
name|FT_LOAD_PEDANTIC
argument_list|)
expr_stmt|;
name|loader
operator|->
name|exec
operator|=
name|exec
expr_stmt|;
name|loader
operator|->
name|instructions
operator|=
name|exec
operator|->
name|glyphIns
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* TT_USE_BYTECODE_INTERPRETER */
comment|/* seek to the beginning of the glyph table -- for Type 42 fonts     */
comment|/* the table might be accessed from a Postscript stream or something */
comment|/* else...                                                           */
ifdef|#
directive|ifdef
name|FT_CONFIG_OPTION_INCREMENTAL
if|if
condition|(
name|face
operator|->
name|root
operator|.
name|internal
operator|->
name|incremental_interface
condition|)
name|loader
operator|->
name|glyf_offset
operator|=
literal|0
expr_stmt|;
else|else
endif|#
directive|endif
block|{
name|error
operator|=
name|face
operator|->
name|goto_table
argument_list|(
name|face
argument_list|,
name|TTAG_glyf
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|FT_ERR_EQ
argument_list|(
name|error
argument_list|,
name|Table_Missing
argument_list|)
condition|)
name|loader
operator|->
name|glyf_offset
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|error
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"tt_loader_init: could not access glyph table\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
else|else
name|loader
operator|->
name|glyf_offset
operator|=
name|FT_STREAM_POS
argument_list|()
expr_stmt|;
block|}
comment|/* get face's glyph loader */
if|if
condition|(
operator|!
name|glyf_table_only
condition|)
block|{
name|FT_GlyphLoader
name|gloader
init|=
name|glyph
operator|->
name|internal
operator|->
name|loader
decl_stmt|;
name|FT_GlyphLoader_Rewind
argument_list|(
name|gloader
argument_list|)
expr_stmt|;
name|loader
operator|->
name|gloader
operator|=
name|gloader
expr_stmt|;
block|}
name|loader
operator|->
name|load_flags
operator|=
name|load_flags
expr_stmt|;
name|loader
operator|->
name|face
operator|=
operator|(
name|FT_Face
operator|)
name|face
expr_stmt|;
name|loader
operator|->
name|size
operator|=
operator|(
name|FT_Size
operator|)
name|size
expr_stmt|;
name|loader
operator|->
name|glyph
operator|=
operator|(
name|FT_GlyphSlot
operator|)
name|glyph
expr_stmt|;
name|loader
operator|->
name|stream
operator|=
name|stream
expr_stmt|;
return|return
name|FT_Err_Ok
return|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    TT_Load_Glyph                                                      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    A function used to load a single glyph within a given glyph slot,  */
end_comment
begin_comment
comment|/*    for a given size.                                                  */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    glyph       :: A handle to a target slot object where the glyph    */
end_comment
begin_comment
comment|/*                   will be loaded.                                     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    size        :: A handle to the source face size at which the glyph */
end_comment
begin_comment
comment|/*                   must be scaled/loaded.                              */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    glyph_index :: The index of the glyph in the font file.            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    load_flags  :: A flag indicating what to load for this glyph.  The */
end_comment
begin_comment
comment|/*                   FT_LOAD_XXX constants can be used to control the    */
end_comment
begin_comment
comment|/*                   glyph loading process (e.g., whether the outline    */
end_comment
begin_comment
comment|/*                   should be scaled, whether to load bitmaps or not,   */
end_comment
begin_comment
comment|/*                   whether to hint the outline, etc).                  */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    FreeType error code.  0 means success.                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|TT_Load_Glyph
argument_list|(
argument|TT_Size       size
argument_list|,
argument|TT_GlyphSlot  glyph
argument_list|,
argument|FT_UInt       glyph_index
argument_list|,
argument|FT_Int32      load_flags
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
decl_stmt|;
name|TT_LoaderRec
name|loader
decl_stmt|;
name|FT_TRACE1
argument_list|(
operator|(
literal|"TT_Load_Glyph: glyph index %d\n"
operator|,
name|glyph_index
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_EMBEDDED_BITMAPS
comment|/* try to load embedded bitmap if any              */
comment|/*                                                 */
comment|/* XXX: The convention should be emphasized in     */
comment|/*      the documents because it can be confusing. */
if|if
condition|(
name|size
operator|->
name|strike_index
operator|!=
literal|0xFFFFFFFFUL
operator|&&
operator|(
name|load_flags
operator|&
name|FT_LOAD_NO_BITMAP
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|load_sbit_image
argument_list|(
name|size
argument_list|,
name|glyph
argument_list|,
name|glyph_index
argument_list|,
name|load_flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
if|if
condition|(
name|FT_IS_SCALABLE
argument_list|(
name|glyph
operator|->
name|face
argument_list|)
condition|)
block|{
comment|/* for the bbox we need the header only */
operator|(
name|void
operator|)
name|tt_loader_init
argument_list|(
operator|&
name|loader
argument_list|,
name|size
argument_list|,
name|glyph
argument_list|,
name|load_flags
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|load_truetype_glyph
argument_list|(
operator|&
name|loader
argument_list|,
name|glyph_index
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|glyph
operator|->
name|linearHoriAdvance
operator|=
name|loader
operator|.
name|linear
expr_stmt|;
name|glyph
operator|->
name|linearVertAdvance
operator|=
name|loader
operator|.
name|vadvance
expr_stmt|;
comment|/* sanity checks: if `xxxAdvance' in the sbit metric */
comment|/* structure isn't set, use `linearXXXAdvance'      */
if|if
condition|(
operator|!
name|glyph
operator|->
name|metrics
operator|.
name|horiAdvance
operator|&&
name|glyph
operator|->
name|linearHoriAdvance
condition|)
name|glyph
operator|->
name|metrics
operator|.
name|horiAdvance
operator|=
name|FT_MulFix
argument_list|(
name|glyph
operator|->
name|linearHoriAdvance
argument_list|,
name|size
operator|->
name|root
operator|.
name|metrics
operator|.
name|x_scale
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|glyph
operator|->
name|metrics
operator|.
name|vertAdvance
operator|&&
name|glyph
operator|->
name|linearVertAdvance
condition|)
name|glyph
operator|->
name|metrics
operator|.
name|vertAdvance
operator|=
name|FT_MulFix
argument_list|(
name|glyph
operator|->
name|linearVertAdvance
argument_list|,
name|size
operator|->
name|root
operator|.
name|metrics
operator|.
name|y_scale
argument_list|)
expr_stmt|;
block|}
return|return
name|FT_Err_Ok
return|;
block|}
block|}
endif|#
directive|endif
comment|/* TT_CONFIG_OPTION_EMBEDDED_BITMAPS */
comment|/* if FT_LOAD_NO_SCALE is not set, `ttmetrics' must be valid */
if|if
condition|(
operator|!
operator|(
name|load_flags
operator|&
name|FT_LOAD_NO_SCALE
operator|)
operator|&&
operator|!
name|size
operator|->
name|ttmetrics
operator|.
name|valid
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_Size_Handle
argument_list|)
return|;
if|if
condition|(
name|load_flags
operator|&
name|FT_LOAD_SBITS_ONLY
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_Argument
argument_list|)
return|;
name|error
operator|=
name|tt_loader_init
argument_list|(
operator|&
name|loader
argument_list|,
name|size
argument_list|,
name|glyph
argument_list|,
name|load_flags
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|glyph
operator|->
name|format
operator|=
name|FT_GLYPH_FORMAT_OUTLINE
expr_stmt|;
name|glyph
operator|->
name|num_subglyphs
operator|=
literal|0
expr_stmt|;
name|glyph
operator|->
name|outline
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
comment|/* main loading loop */
name|error
operator|=
name|load_truetype_glyph
argument_list|(
operator|&
name|loader
argument_list|,
name|glyph_index
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
if|if
condition|(
name|glyph
operator|->
name|format
operator|==
name|FT_GLYPH_FORMAT_COMPOSITE
condition|)
block|{
name|glyph
operator|->
name|num_subglyphs
operator|=
name|loader
operator|.
name|gloader
operator|->
name|base
operator|.
name|num_subglyphs
expr_stmt|;
name|glyph
operator|->
name|subglyphs
operator|=
name|loader
operator|.
name|gloader
operator|->
name|base
operator|.
name|subglyphs
expr_stmt|;
block|}
else|else
block|{
name|glyph
operator|->
name|outline
operator|=
name|loader
operator|.
name|gloader
operator|->
name|base
operator|.
name|outline
expr_stmt|;
name|glyph
operator|->
name|outline
operator|.
name|flags
operator|&=
operator|~
name|FT_OUTLINE_SINGLE_PASS
expr_stmt|;
comment|/* Translate array so that (0,0) is the glyph's origin.  Note  */
comment|/* that this behaviour is independent on the value of bit 1 of */
comment|/* the `flags' field in the `head' table -- at least major     */
comment|/* applications like Acroread indicate that.                   */
if|if
condition|(
name|loader
operator|.
name|pp1
operator|.
name|x
condition|)
name|FT_Outline_Translate
argument_list|(
operator|&
name|glyph
operator|->
name|outline
argument_list|,
operator|-
name|loader
operator|.
name|pp1
operator|.
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TT_USE_BYTECODE_INTERPRETER
if|if
condition|(
name|IS_HINTED
argument_list|(
name|load_flags
argument_list|)
condition|)
block|{
if|if
condition|(
name|loader
operator|.
name|exec
operator|->
name|GS
operator|.
name|scan_control
condition|)
block|{
comment|/* convert scan conversion mode to FT_OUTLINE_XXX flags */
switch|switch
condition|(
name|loader
operator|.
name|exec
operator|->
name|GS
operator|.
name|scan_type
condition|)
block|{
case|case
literal|0
case|:
comment|/* simple drop-outs including stubs */
name|glyph
operator|->
name|outline
operator|.
name|flags
operator||=
name|FT_OUTLINE_INCLUDE_STUBS
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* simple drop-outs excluding stubs */
comment|/* nothing; it's the default rendering mode */
break|break;
case|case
literal|4
case|:
comment|/* smart drop-outs including stubs */
name|glyph
operator|->
name|outline
operator|.
name|flags
operator||=
name|FT_OUTLINE_SMART_DROPOUTS
operator||
name|FT_OUTLINE_INCLUDE_STUBS
expr_stmt|;
break|break;
case|case
literal|5
case|:
comment|/* smart drop-outs excluding stubs  */
name|glyph
operator|->
name|outline
operator|.
name|flags
operator||=
name|FT_OUTLINE_SMART_DROPOUTS
expr_stmt|;
break|break;
default|default:
comment|/* no drop-out control */
name|glyph
operator|->
name|outline
operator|.
name|flags
operator||=
name|FT_OUTLINE_IGNORE_DROPOUTS
expr_stmt|;
break|break;
block|}
block|}
else|else
name|glyph
operator|->
name|outline
operator|.
name|flags
operator||=
name|FT_OUTLINE_IGNORE_DROPOUTS
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* TT_USE_BYTECODE_INTERPRETER */
name|error
operator|=
name|compute_glyph_metrics
argument_list|(
operator|&
name|loader
argument_list|,
name|glyph_index
argument_list|)
expr_stmt|;
block|}
comment|/* Set the `high precision' bit flag.                           */
comment|/* This is _critical_ to get correct output for monochrome      */
comment|/* TrueType glyphs at all sizes using the bytecode interpreter. */
comment|/*                                                              */
if|if
condition|(
operator|!
operator|(
name|load_flags
operator|&
name|FT_LOAD_NO_SCALE
operator|)
operator|&&
name|size
operator|->
name|root
operator|.
name|metrics
operator|.
name|y_ppem
operator|<
literal|24
condition|)
name|glyph
operator|->
name|outline
operator|.
name|flags
operator||=
name|FT_OUTLINE_HIGH_PRECISION
expr_stmt|;
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/* END */
end_comment
end_unit
