begin_unit
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  ttgload.c                                                              */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*    TrueType Glyph Loader (body).                                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,   */
end_comment
begin_comment
comment|/*            2010 by                                                      */
end_comment
begin_comment
comment|/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  This file is part of the FreeType project, and may only be used,       */
end_comment
begin_comment
comment|/*  modified, and distributed under the terms of the FreeType project      */
end_comment
begin_comment
comment|/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
end_comment
begin_comment
comment|/*  this file you indicate that you have read the license and              */
end_comment
begin_comment
comment|/*  understand and accept it fully.                                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<ft2build.h>
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_DEBUG_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_CALC_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_STREAM_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_SFNT_H
end_include
begin_include
include|#
directive|include
include|FT_TRUETYPE_TAGS_H
end_include
begin_include
include|#
directive|include
include|FT_OUTLINE_H
end_include
begin_include
include|#
directive|include
file|"ttgload.h"
end_include
begin_include
include|#
directive|include
file|"ttpload.h"
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_GX_VAR_SUPPORT
end_ifdef
begin_include
include|#
directive|include
file|"ttgxvar.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|"tterrors.h"
end_include
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
end_comment
begin_comment
comment|/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
end_comment
begin_comment
comment|/* messages during execution.                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_undef
DECL|macro|FT_COMPONENT
undef|#
directive|undef
name|FT_COMPONENT
end_undef
begin_define
DECL|macro|FT_COMPONENT
define|#
directive|define
name|FT_COMPONENT
value|trace_ttgload
end_define
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* Composite font flags.                                                 */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_define
DECL|macro|ARGS_ARE_WORDS
define|#
directive|define
name|ARGS_ARE_WORDS
value|0x0001
end_define
begin_define
DECL|macro|ARGS_ARE_XY_VALUES
define|#
directive|define
name|ARGS_ARE_XY_VALUES
value|0x0002
end_define
begin_define
DECL|macro|ROUND_XY_TO_GRID
define|#
directive|define
name|ROUND_XY_TO_GRID
value|0x0004
end_define
begin_define
DECL|macro|WE_HAVE_A_SCALE
define|#
directive|define
name|WE_HAVE_A_SCALE
value|0x0008
end_define
begin_comment
comment|/* reserved                        0x0010 */
end_comment
begin_define
DECL|macro|MORE_COMPONENTS
define|#
directive|define
name|MORE_COMPONENTS
value|0x0020
end_define
begin_define
DECL|macro|WE_HAVE_AN_XY_SCALE
define|#
directive|define
name|WE_HAVE_AN_XY_SCALE
value|0x0040
end_define
begin_define
DECL|macro|WE_HAVE_A_2X2
define|#
directive|define
name|WE_HAVE_A_2X2
value|0x0080
end_define
begin_define
DECL|macro|WE_HAVE_INSTR
define|#
directive|define
name|WE_HAVE_INSTR
value|0x0100
end_define
begin_define
DECL|macro|USE_MY_METRICS
define|#
directive|define
name|USE_MY_METRICS
value|0x0200
end_define
begin_define
DECL|macro|OVERLAP_COMPOUND
define|#
directive|define
name|OVERLAP_COMPOUND
value|0x0400
end_define
begin_define
DECL|macro|SCALED_COMPONENT_OFFSET
define|#
directive|define
name|SCALED_COMPONENT_OFFSET
value|0x0800
end_define
begin_define
DECL|macro|UNSCALED_COMPONENT_OFFSET
define|#
directive|define
name|UNSCALED_COMPONENT_OFFSET
value|0x1000
end_define
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* Returns the horizontal metrics in font units for a given glyph.  If   */
end_comment
begin_comment
comment|/* `check' is true, take care of monospaced fonts by returning the       */
end_comment
begin_comment
comment|/* advance width maximum.                                                */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|TT_Get_HMetrics
name|TT_Get_HMetrics
argument_list|(
argument|TT_Face     face
argument_list|,
argument|FT_UInt     idx
argument_list|,
argument|FT_Bool     check
argument_list|,
argument|FT_Short*   lsb
argument_list|,
argument|FT_UShort*  aw
argument_list|)
end_macro
begin_block
block|{
operator|(
operator|(
name|SFNT_Service
operator|)
name|face
operator|->
name|sfnt
operator|)
operator|->
name|get_metrics
argument_list|(
name|face
argument_list|,
literal|0
argument_list|,
name|idx
argument_list|,
name|lsb
argument_list|,
name|aw
argument_list|)
expr_stmt|;
if|if
condition|(
name|check
operator|&&
name|face
operator|->
name|postscript
operator|.
name|isFixedPitch
condition|)
operator|*
name|aw
operator|=
name|face
operator|->
name|horizontal
operator|.
name|advance_Width_Max
expr_stmt|;
name|FT_TRACE5
argument_list|(
operator|(
literal|"  advance width (font units): %d\n"
operator|,
operator|*
name|aw
operator|)
argument_list|)
expr_stmt|;
name|FT_TRACE5
argument_list|(
operator|(
literal|"  left side bearing (font units): %d\n"
operator|,
operator|*
name|lsb
operator|)
argument_list|)
expr_stmt|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* Returns the vertical metrics in font units for a given glyph.         */
end_comment
begin_comment
comment|/* Greg Hitchcock from Microsoft told us that if there were no `vmtx'    */
end_comment
begin_comment
comment|/* table, typoAscender/Descender from the `OS/2' table would be used     */
end_comment
begin_comment
comment|/* instead, and if there were no `OS/2' table, use ascender/descender    */
end_comment
begin_comment
comment|/* from the `hhea' table.  But that is not what Microsoft's rasterizer   */
end_comment
begin_comment
comment|/* apparently does: It uses the ppem value as the advance height, and    */
end_comment
begin_comment
comment|/* sets the top side bearing to be zero.                                 */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* The monospace `check' is probably not meaningful here, but we leave   */
end_comment
begin_comment
comment|/* it in for a consistent interface.                                     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|TT_Get_VMetrics
name|TT_Get_VMetrics
argument_list|(
argument|TT_Face     face
argument_list|,
argument|FT_UInt     idx
argument_list|,
argument|FT_Bool     check
argument_list|,
argument|FT_Short*   tsb
argument_list|,
argument|FT_UShort*  ah
argument_list|)
end_macro
begin_block
block|{
name|FT_UNUSED
argument_list|(
name|check
argument_list|)
expr_stmt|;
if|if
condition|(
name|face
operator|->
name|vertical_info
condition|)
operator|(
operator|(
name|SFNT_Service
operator|)
name|face
operator|->
name|sfnt
operator|)
operator|->
name|get_metrics
argument_list|(
name|face
argument_list|,
literal|1
argument_list|,
name|idx
argument_list|,
name|tsb
argument_list|,
name|ah
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
comment|/* Empirically determined, at variance with what MS said */
else|else
block|{
operator|*
name|tsb
operator|=
literal|0
expr_stmt|;
operator|*
name|ah
operator|=
name|face
operator|->
name|root
operator|.
name|units_per_EM
expr_stmt|;
block|}
else|#
directive|else
comment|/* This is what MS said to do.  It isn't what they do, however. */
elseif|else
if|if
condition|(
name|face
operator|->
name|os2
operator|.
name|version
operator|!=
literal|0xFFFFU
condition|)
block|{
operator|*
name|tsb
operator|=
name|face
operator|->
name|os2
operator|.
name|sTypoAscender
expr_stmt|;
operator|*
name|ah
operator|=
name|face
operator|->
name|os2
operator|.
name|sTypoAscender
operator|-
name|face
operator|->
name|os2
operator|.
name|sTypoDescender
expr_stmt|;
block|}
else|else
block|{
operator|*
name|tsb
operator|=
name|face
operator|->
name|horizontal
operator|.
name|Ascender
expr_stmt|;
operator|*
name|ah
operator|=
name|face
operator|->
name|horizontal
operator|.
name|Ascender
operator|-
name|face
operator|->
name|horizontal
operator|.
name|Descender
expr_stmt|;
block|}
endif|#
directive|endif
name|FT_TRACE5
argument_list|(
operator|(
literal|"  advance height (font units): %d\n"
operator|,
operator|*
name|ah
operator|)
argument_list|)
expr_stmt|;
name|FT_TRACE5
argument_list|(
operator|(
literal|"  top side bearing (font units): %d\n"
operator|,
operator|*
name|tsb
operator|)
argument_list|)
expr_stmt|;
block|}
end_block
begin_function
specifier|static
name|void
DECL|function|tt_get_metrics
name|tt_get_metrics
parameter_list|(
name|TT_Loader
name|loader
parameter_list|,
name|FT_UInt
name|glyph_index
parameter_list|)
block|{
name|TT_Face
name|face
init|=
operator|(
name|TT_Face
operator|)
name|loader
operator|->
name|face
decl_stmt|;
name|FT_Short
name|left_bearing
init|=
literal|0
decl_stmt|,
name|top_bearing
init|=
literal|0
decl_stmt|;
name|FT_UShort
name|advance_width
init|=
literal|0
decl_stmt|,
name|advance_height
init|=
literal|0
decl_stmt|;
name|TT_Get_HMetrics
argument_list|(
name|face
argument_list|,
name|glyph_index
argument_list|,
operator|(
name|FT_Bool
operator|)
operator|!
operator|(
name|loader
operator|->
name|load_flags
operator|&
name|FT_LOAD_IGNORE_GLOBAL_ADVANCE_WIDTH
operator|)
argument_list|,
operator|&
name|left_bearing
argument_list|,
operator|&
name|advance_width
argument_list|)
expr_stmt|;
name|TT_Get_VMetrics
argument_list|(
name|face
argument_list|,
name|glyph_index
argument_list|,
operator|(
name|FT_Bool
operator|)
operator|!
operator|(
name|loader
operator|->
name|load_flags
operator|&
name|FT_LOAD_IGNORE_GLOBAL_ADVANCE_WIDTH
operator|)
argument_list|,
operator|&
name|top_bearing
argument_list|,
operator|&
name|advance_height
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FT_CONFIG_OPTION_INCREMENTAL
comment|/* If this is an incrementally loaded font check whether there are */
comment|/* overriding metrics for this glyph.                              */
if|if
condition|(
name|face
operator|->
name|root
operator|.
name|internal
operator|->
name|incremental_interface
operator|&&
name|face
operator|->
name|root
operator|.
name|internal
operator|->
name|incremental_interface
operator|->
name|funcs
operator|->
name|get_glyph_metrics
condition|)
block|{
name|FT_Incremental_MetricsRec
name|metrics
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|metrics
operator|.
name|bearing_x
operator|=
name|left_bearing
expr_stmt|;
name|metrics
operator|.
name|bearing_y
operator|=
literal|0
expr_stmt|;
name|metrics
operator|.
name|advance
operator|=
name|advance_width
expr_stmt|;
name|metrics
operator|.
name|advance_v
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|face
operator|->
name|root
operator|.
name|internal
operator|->
name|incremental_interface
operator|->
name|funcs
operator|->
name|get_glyph_metrics
argument_list|(
name|face
operator|->
name|root
operator|.
name|internal
operator|->
name|incremental_interface
operator|->
name|object
argument_list|,
name|glyph_index
argument_list|,
name|FALSE
argument_list|,
operator|&
name|metrics
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|left_bearing
operator|=
operator|(
name|FT_Short
operator|)
name|metrics
operator|.
name|bearing_x
expr_stmt|;
name|advance_width
operator|=
operator|(
name|FT_UShort
operator|)
name|metrics
operator|.
name|advance
expr_stmt|;
if|#
directive|if
literal|0
comment|/* GWW: Do I do the same for vertical metrics? */
block|metrics.bearing_x = 0;       metrics.bearing_y = top_bearing;       metrics.advance   = advance_height;        error = face->root.internal->incremental_interface->funcs->get_glyph_metrics(                 face->root.internal->incremental_interface->object,                 glyph_index, TRUE,&metrics );       if ( error )         goto Exit;        top_bearing    = (FT_Short)metrics.bearing_y;       advance_height = (FT_UShort)metrics.advance;
endif|#
directive|endif
comment|/* 0 */
block|}
name|Exit
label|:
endif|#
directive|endif
comment|/* FT_CONFIG_OPTION_INCREMENTAL */
name|loader
operator|->
name|left_bearing
operator|=
name|left_bearing
expr_stmt|;
name|loader
operator|->
name|advance
operator|=
name|advance_width
expr_stmt|;
name|loader
operator|->
name|top_bearing
operator|=
name|top_bearing
expr_stmt|;
name|loader
operator|->
name|vadvance
operator|=
name|advance_height
expr_stmt|;
if|if
condition|(
operator|!
name|loader
operator|->
name|linear_def
condition|)
block|{
name|loader
operator|->
name|linear_def
operator|=
literal|1
expr_stmt|;
name|loader
operator|->
name|linear
operator|=
name|advance_width
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* Translates an array of coordinates.                                   */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|translate_array
name|translate_array
parameter_list|(
name|FT_UInt
name|n
parameter_list|,
name|FT_Vector
modifier|*
name|coords
parameter_list|,
name|FT_Pos
name|delta_x
parameter_list|,
name|FT_Pos
name|delta_y
parameter_list|)
block|{
name|FT_UInt
name|k
decl_stmt|;
if|if
condition|(
name|delta_x
condition|)
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|n
condition|;
name|k
operator|++
control|)
name|coords
index|[
name|k
index|]
operator|.
name|x
operator|+=
name|delta_x
expr_stmt|;
if|if
condition|(
name|delta_y
condition|)
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|n
condition|;
name|k
operator|++
control|)
name|coords
index|[
name|k
index|]
operator|.
name|y
operator|+=
name|delta_y
expr_stmt|;
block|}
end_function
begin_undef
DECL|macro|IS_HINTED
undef|#
directive|undef
name|IS_HINTED
end_undef
begin_define
DECL|macro|IS_HINTED
define|#
directive|define
name|IS_HINTED
parameter_list|(
name|flags
parameter_list|)
value|( ( flags& FT_LOAD_NO_HINTING ) == 0 )
end_define
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* The following functions are used by default with TrueType fonts.      */
end_comment
begin_comment
comment|/* However, they can be replaced by alternatives if we need to support   */
end_comment
begin_comment
comment|/* TrueType-compressed formats (like MicroType) in the future.           */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|TT_Access_Glyph_Frame
argument_list|(
argument|TT_Loader  loader
argument_list|,
argument|FT_UInt    glyph_index
argument_list|,
argument|FT_ULong   offset
argument_list|,
argument|FT_UInt    byte_count
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
decl_stmt|;
name|FT_Stream
name|stream
init|=
name|loader
operator|->
name|stream
decl_stmt|;
comment|/* for non-debug mode */
name|FT_UNUSED
argument_list|(
name|glyph_index
argument_list|)
expr_stmt|;
name|FT_TRACE5
argument_list|(
operator|(
literal|"Glyph %ld\n"
operator|,
name|glyph_index
operator|)
argument_list|)
expr_stmt|;
comment|/* the following line sets the `error' variable through macros! */
if|if
condition|(
name|FT_STREAM_SEEK
argument_list|(
name|offset
argument_list|)
operator|||
name|FT_FRAME_ENTER
argument_list|(
name|byte_count
argument_list|)
condition|)
return|return
name|error
return|;
name|loader
operator|->
name|cursor
operator|=
name|stream
operator|->
name|cursor
expr_stmt|;
name|loader
operator|->
name|limit
operator|=
name|stream
operator|->
name|limit
expr_stmt|;
return|return
name|TT_Err_Ok
return|;
block|}
end_block
begin_macro
name|FT_CALLBACK_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|TT_Forget_Glyph_Frame
name|TT_Forget_Glyph_Frame
argument_list|(
argument|TT_Loader  loader
argument_list|)
end_macro
begin_block
block|{
name|FT_Stream
name|stream
init|=
name|loader
operator|->
name|stream
decl_stmt|;
name|FT_FRAME_EXIT
argument_list|()
expr_stmt|;
block|}
end_block
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|TT_Load_Glyph_Header
argument_list|(
argument|TT_Loader  loader
argument_list|)
end_macro
begin_block
block|{
name|FT_Byte
modifier|*
name|p
init|=
name|loader
operator|->
name|cursor
decl_stmt|;
name|FT_Byte
modifier|*
name|limit
init|=
name|loader
operator|->
name|limit
decl_stmt|;
if|if
condition|(
name|p
operator|+
literal|10
operator|>
name|limit
condition|)
return|return
name|TT_Err_Invalid_Outline
return|;
name|loader
operator|->
name|n_contours
operator|=
name|FT_NEXT_SHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|loader
operator|->
name|bbox
operator|.
name|xMin
operator|=
name|FT_NEXT_SHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|loader
operator|->
name|bbox
operator|.
name|yMin
operator|=
name|FT_NEXT_SHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|loader
operator|->
name|bbox
operator|.
name|xMax
operator|=
name|FT_NEXT_SHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|loader
operator|->
name|bbox
operator|.
name|yMax
operator|=
name|FT_NEXT_SHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|FT_TRACE5
argument_list|(
operator|(
literal|"  # of contours: %d\n"
operator|,
name|loader
operator|->
name|n_contours
operator|)
argument_list|)
expr_stmt|;
name|FT_TRACE5
argument_list|(
operator|(
literal|"  xMin: %4d  xMax: %4d\n"
operator|,
name|loader
operator|->
name|bbox
operator|.
name|xMin
operator|,
name|loader
operator|->
name|bbox
operator|.
name|xMax
operator|)
argument_list|)
expr_stmt|;
name|FT_TRACE5
argument_list|(
operator|(
literal|"  yMin: %4d  yMax: %4d\n"
operator|,
name|loader
operator|->
name|bbox
operator|.
name|yMin
operator|,
name|loader
operator|->
name|bbox
operator|.
name|yMax
operator|)
argument_list|)
expr_stmt|;
name|loader
operator|->
name|cursor
operator|=
name|p
expr_stmt|;
return|return
name|TT_Err_Ok
return|;
block|}
end_block
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|TT_Load_Simple_Glyph
argument_list|(
argument|TT_Loader  load
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
decl_stmt|;
name|FT_Byte
modifier|*
name|p
init|=
name|load
operator|->
name|cursor
decl_stmt|;
name|FT_Byte
modifier|*
name|limit
init|=
name|load
operator|->
name|limit
decl_stmt|;
name|FT_GlyphLoader
name|gloader
init|=
name|load
operator|->
name|gloader
decl_stmt|;
name|FT_Int
name|n_contours
init|=
name|load
operator|->
name|n_contours
decl_stmt|;
name|FT_Outline
modifier|*
name|outline
decl_stmt|;
name|TT_Face
name|face
init|=
operator|(
name|TT_Face
operator|)
name|load
operator|->
name|face
decl_stmt|;
name|FT_UShort
name|n_ins
decl_stmt|;
name|FT_Int
name|n_points
decl_stmt|;
name|FT_Byte
modifier|*
name|flag
decl_stmt|,
modifier|*
name|flag_limit
decl_stmt|;
name|FT_Byte
name|c
decl_stmt|,
name|count
decl_stmt|;
name|FT_Vector
modifier|*
name|vec
decl_stmt|,
modifier|*
name|vec_limit
decl_stmt|;
name|FT_Pos
name|x
decl_stmt|;
name|FT_Short
modifier|*
name|cont
decl_stmt|,
modifier|*
name|cont_limit
decl_stmt|,
name|prev_cont
decl_stmt|;
name|FT_Int
name|xy_size
init|=
literal|0
decl_stmt|;
comment|/* check that we can add the contours to the glyph */
name|error
operator|=
name|FT_GLYPHLOADER_CHECK_POINTS
argument_list|(
name|gloader
argument_list|,
literal|0
argument_list|,
name|n_contours
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Fail
goto|;
comment|/* reading the contours' endpoints& number of points */
name|cont
operator|=
name|gloader
operator|->
name|current
operator|.
name|outline
operator|.
name|contours
expr_stmt|;
name|cont_limit
operator|=
name|cont
operator|+
name|n_contours
expr_stmt|;
comment|/* check space for contours array + instructions count */
if|if
condition|(
name|n_contours
operator|>=
literal|0xFFF
operator|||
name|p
operator|+
operator|(
name|n_contours
operator|+
literal|1
operator|)
operator|*
literal|2
operator|>
name|limit
condition|)
goto|goto
name|Invalid_Outline
goto|;
name|prev_cont
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_contours
operator|>
literal|0
condition|)
name|cont
index|[
literal|0
index|]
operator|=
name|prev_cont
expr_stmt|;
for|for
control|(
name|cont
operator|++
init|;
name|cont
operator|<
name|cont_limit
condition|;
name|cont
operator|++
control|)
block|{
name|cont
index|[
literal|0
index|]
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|cont
index|[
literal|0
index|]
operator|<=
name|prev_cont
condition|)
block|{
comment|/* unordered contours: this is invalid */
name|error
operator|=
name|FT_Err_Invalid_Table
expr_stmt|;
goto|goto
name|Fail
goto|;
block|}
name|prev_cont
operator|=
name|cont
index|[
literal|0
index|]
expr_stmt|;
block|}
name|n_points
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|n_contours
operator|>
literal|0
condition|)
block|{
name|n_points
operator|=
name|cont
index|[
operator|-
literal|1
index|]
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|n_points
operator|<
literal|0
condition|)
goto|goto
name|Invalid_Outline
goto|;
block|}
comment|/* note that we will add four phantom points later */
name|error
operator|=
name|FT_GLYPHLOADER_CHECK_POINTS
argument_list|(
name|gloader
argument_list|,
name|n_points
operator|+
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Fail
goto|;
comment|/* we'd better check the contours table right now */
name|outline
operator|=
operator|&
name|gloader
operator|->
name|current
operator|.
name|outline
expr_stmt|;
for|for
control|(
name|cont
operator|=
name|outline
operator|->
name|contours
operator|+
literal|1
init|;
name|cont
operator|<
name|cont_limit
condition|;
name|cont
operator|++
control|)
if|if
condition|(
name|cont
index|[
operator|-
literal|1
index|]
operator|>=
name|cont
index|[
literal|0
index|]
condition|)
goto|goto
name|Invalid_Outline
goto|;
comment|/* reading the bytecode instructions */
name|load
operator|->
name|glyph
operator|->
name|control_len
operator|=
literal|0
expr_stmt|;
name|load
operator|->
name|glyph
operator|->
name|control_data
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p
operator|+
literal|2
operator|>
name|limit
condition|)
goto|goto
name|Invalid_Outline
goto|;
name|n_ins
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|FT_TRACE5
argument_list|(
operator|(
literal|"  Instructions size: %u\n"
operator|,
name|n_ins
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_ins
operator|>
name|face
operator|->
name|max_profile
operator|.
name|maxSizeOfInstructions
condition|)
block|{
name|FT_TRACE0
argument_list|(
operator|(
literal|"TT_Load_Simple_Glyph: too many instructions (%d)\n"
operator|,
name|n_ins
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|TT_Err_Too_Many_Hints
expr_stmt|;
goto|goto
name|Fail
goto|;
block|}
if|if
condition|(
operator|(
name|limit
operator|-
name|p
operator|)
operator|<
name|n_ins
condition|)
block|{
name|FT_TRACE0
argument_list|(
operator|(
literal|"TT_Load_Simple_Glyph: instruction count mismatch\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|TT_Err_Too_Many_Hints
expr_stmt|;
goto|goto
name|Fail
goto|;
block|}
ifdef|#
directive|ifdef
name|TT_USE_BYTECODE_INTERPRETER
if|if
condition|(
name|IS_HINTED
argument_list|(
name|load
operator|->
name|load_flags
argument_list|)
condition|)
block|{
name|load
operator|->
name|glyph
operator|->
name|control_len
operator|=
name|n_ins
expr_stmt|;
name|load
operator|->
name|glyph
operator|->
name|control_data
operator|=
name|load
operator|->
name|exec
operator|->
name|glyphIns
expr_stmt|;
name|FT_MEM_COPY
argument_list|(
name|load
operator|->
name|exec
operator|->
name|glyphIns
argument_list|,
name|p
argument_list|,
operator|(
name|FT_Long
operator|)
name|n_ins
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* TT_USE_BYTECODE_INTERPRETER */
name|p
operator|+=
name|n_ins
expr_stmt|;
comment|/* reading the point tags */
name|flag
operator|=
operator|(
name|FT_Byte
operator|*
operator|)
name|outline
operator|->
name|tags
expr_stmt|;
name|flag_limit
operator|=
name|flag
operator|+
name|n_points
expr_stmt|;
name|FT_ASSERT
argument_list|(
name|flag
operator|!=
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
name|flag
operator|<
name|flag_limit
condition|)
block|{
if|if
condition|(
name|p
operator|+
literal|1
operator|>
name|limit
condition|)
goto|goto
name|Invalid_Outline
goto|;
operator|*
name|flag
operator|++
operator|=
name|c
operator|=
name|FT_NEXT_BYTE
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|&
literal|8
condition|)
block|{
if|if
condition|(
name|p
operator|+
literal|1
operator|>
name|limit
condition|)
goto|goto
name|Invalid_Outline
goto|;
name|count
operator|=
name|FT_NEXT_BYTE
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
operator|+
operator|(
name|FT_Int
operator|)
name|count
operator|>
name|flag_limit
condition|)
goto|goto
name|Invalid_Outline
goto|;
for|for
control|(
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
control|)
operator|*
name|flag
operator|++
operator|=
name|c
expr_stmt|;
block|}
block|}
comment|/* reading the X coordinates */
name|vec
operator|=
name|outline
operator|->
name|points
expr_stmt|;
name|vec_limit
operator|=
name|vec
operator|+
name|n_points
expr_stmt|;
name|flag
operator|=
operator|(
name|FT_Byte
operator|*
operator|)
name|outline
operator|->
name|tags
expr_stmt|;
name|x
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p
operator|+
name|xy_size
operator|>
name|limit
condition|)
goto|goto
name|Invalid_Outline
goto|;
for|for
control|(
init|;
name|vec
operator|<
name|vec_limit
condition|;
name|vec
operator|++
operator|,
name|flag
operator|++
control|)
block|{
name|FT_Pos
name|y
init|=
literal|0
decl_stmt|;
name|FT_Byte
name|f
init|=
operator|*
name|flag
decl_stmt|;
if|if
condition|(
name|f
operator|&
literal|2
condition|)
block|{
if|if
condition|(
name|p
operator|+
literal|1
operator|>
name|limit
condition|)
goto|goto
name|Invalid_Outline
goto|;
name|y
operator|=
operator|(
name|FT_Pos
operator|)
name|FT_NEXT_BYTE
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|f
operator|&
literal|16
operator|)
operator|==
literal|0
condition|)
name|y
operator|=
operator|-
name|y
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|f
operator|&
literal|16
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|p
operator|+
literal|2
operator|>
name|limit
condition|)
goto|goto
name|Invalid_Outline
goto|;
name|y
operator|=
operator|(
name|FT_Pos
operator|)
name|FT_NEXT_SHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|x
operator|+=
name|y
expr_stmt|;
name|vec
operator|->
name|x
operator|=
name|x
expr_stmt|;
comment|/* the cast is for stupid compilers */
operator|*
name|flag
operator|=
call|(
name|FT_Byte
call|)
argument_list|(
name|f
operator|&
operator|~
operator|(
literal|2
operator||
literal|16
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* reading the Y coordinates */
name|vec
operator|=
name|gloader
operator|->
name|current
operator|.
name|outline
operator|.
name|points
expr_stmt|;
name|vec_limit
operator|=
name|vec
operator|+
name|n_points
expr_stmt|;
name|flag
operator|=
operator|(
name|FT_Byte
operator|*
operator|)
name|outline
operator|->
name|tags
expr_stmt|;
name|x
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|vec
operator|<
name|vec_limit
condition|;
name|vec
operator|++
operator|,
name|flag
operator|++
control|)
block|{
name|FT_Pos
name|y
init|=
literal|0
decl_stmt|;
name|FT_Byte
name|f
init|=
operator|*
name|flag
decl_stmt|;
if|if
condition|(
name|f
operator|&
literal|4
condition|)
block|{
if|if
condition|(
name|p
operator|+
literal|1
operator|>
name|limit
condition|)
goto|goto
name|Invalid_Outline
goto|;
name|y
operator|=
operator|(
name|FT_Pos
operator|)
name|FT_NEXT_BYTE
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|f
operator|&
literal|32
operator|)
operator|==
literal|0
condition|)
name|y
operator|=
operator|-
name|y
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|f
operator|&
literal|32
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|p
operator|+
literal|2
operator|>
name|limit
condition|)
goto|goto
name|Invalid_Outline
goto|;
name|y
operator|=
operator|(
name|FT_Pos
operator|)
name|FT_NEXT_SHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|x
operator|+=
name|y
expr_stmt|;
name|vec
operator|->
name|y
operator|=
name|x
expr_stmt|;
comment|/* the cast is for stupid compilers */
operator|*
name|flag
operator|=
call|(
name|FT_Byte
call|)
argument_list|(
name|f
operator|&
name|FT_CURVE_TAG_ON
argument_list|)
expr_stmt|;
block|}
name|outline
operator|->
name|n_points
operator|=
operator|(
name|FT_UShort
operator|)
name|n_points
expr_stmt|;
name|outline
operator|->
name|n_contours
operator|=
operator|(
name|FT_Short
operator|)
name|n_contours
expr_stmt|;
name|load
operator|->
name|cursor
operator|=
name|p
expr_stmt|;
name|Fail
label|:
return|return
name|error
return|;
name|Invalid_Outline
label|:
name|error
operator|=
name|TT_Err_Invalid_Outline
expr_stmt|;
goto|goto
name|Fail
goto|;
block|}
end_block
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|TT_Load_Composite_Glyph
argument_list|(
argument|TT_Loader  loader
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
decl_stmt|;
name|FT_Byte
modifier|*
name|p
init|=
name|loader
operator|->
name|cursor
decl_stmt|;
name|FT_Byte
modifier|*
name|limit
init|=
name|loader
operator|->
name|limit
decl_stmt|;
name|FT_GlyphLoader
name|gloader
init|=
name|loader
operator|->
name|gloader
decl_stmt|;
name|FT_SubGlyph
name|subglyph
decl_stmt|;
name|FT_UInt
name|num_subglyphs
decl_stmt|;
name|num_subglyphs
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|FT_Fixed
name|xx
decl_stmt|,
name|xy
decl_stmt|,
name|yy
decl_stmt|,
name|yx
decl_stmt|;
name|FT_UInt
name|count
decl_stmt|;
comment|/* check that we can load a new subglyph */
name|error
operator|=
name|FT_GlyphLoader_CheckSubGlyphs
argument_list|(
name|gloader
argument_list|,
name|num_subglyphs
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Fail
goto|;
comment|/* check space */
if|if
condition|(
name|p
operator|+
literal|4
operator|>
name|limit
condition|)
goto|goto
name|Invalid_Composite
goto|;
name|subglyph
operator|=
name|gloader
operator|->
name|current
operator|.
name|subglyphs
operator|+
name|num_subglyphs
expr_stmt|;
name|subglyph
operator|->
name|arg1
operator|=
name|subglyph
operator|->
name|arg2
operator|=
literal|0
expr_stmt|;
name|subglyph
operator|->
name|flags
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|subglyph
operator|->
name|index
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* check space */
name|count
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|subglyph
operator|->
name|flags
operator|&
name|ARGS_ARE_WORDS
condition|)
name|count
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|subglyph
operator|->
name|flags
operator|&
name|WE_HAVE_A_SCALE
condition|)
name|count
operator|+=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|subglyph
operator|->
name|flags
operator|&
name|WE_HAVE_AN_XY_SCALE
condition|)
name|count
operator|+=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|subglyph
operator|->
name|flags
operator|&
name|WE_HAVE_A_2X2
condition|)
name|count
operator|+=
literal|8
expr_stmt|;
if|if
condition|(
name|p
operator|+
name|count
operator|>
name|limit
condition|)
goto|goto
name|Invalid_Composite
goto|;
comment|/* read arguments */
if|if
condition|(
name|subglyph
operator|->
name|flags
operator|&
name|ARGS_ARE_WORDS
condition|)
block|{
name|subglyph
operator|->
name|arg1
operator|=
name|FT_NEXT_SHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|subglyph
operator|->
name|arg2
operator|=
name|FT_NEXT_SHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|subglyph
operator|->
name|arg1
operator|=
name|FT_NEXT_CHAR
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|subglyph
operator|->
name|arg2
operator|=
name|FT_NEXT_CHAR
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
comment|/* read transform */
name|xx
operator|=
name|yy
operator|=
literal|0x10000L
expr_stmt|;
name|xy
operator|=
name|yx
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|subglyph
operator|->
name|flags
operator|&
name|WE_HAVE_A_SCALE
condition|)
block|{
name|xx
operator|=
operator|(
name|FT_Fixed
operator|)
name|FT_NEXT_SHORT
argument_list|(
name|p
argument_list|)
operator|<<
literal|2
expr_stmt|;
name|yy
operator|=
name|xx
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|subglyph
operator|->
name|flags
operator|&
name|WE_HAVE_AN_XY_SCALE
condition|)
block|{
name|xx
operator|=
operator|(
name|FT_Fixed
operator|)
name|FT_NEXT_SHORT
argument_list|(
name|p
argument_list|)
operator|<<
literal|2
expr_stmt|;
name|yy
operator|=
operator|(
name|FT_Fixed
operator|)
name|FT_NEXT_SHORT
argument_list|(
name|p
argument_list|)
operator|<<
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|subglyph
operator|->
name|flags
operator|&
name|WE_HAVE_A_2X2
condition|)
block|{
name|xx
operator|=
operator|(
name|FT_Fixed
operator|)
name|FT_NEXT_SHORT
argument_list|(
name|p
argument_list|)
operator|<<
literal|2
expr_stmt|;
name|yx
operator|=
operator|(
name|FT_Fixed
operator|)
name|FT_NEXT_SHORT
argument_list|(
name|p
argument_list|)
operator|<<
literal|2
expr_stmt|;
name|xy
operator|=
operator|(
name|FT_Fixed
operator|)
name|FT_NEXT_SHORT
argument_list|(
name|p
argument_list|)
operator|<<
literal|2
expr_stmt|;
name|yy
operator|=
operator|(
name|FT_Fixed
operator|)
name|FT_NEXT_SHORT
argument_list|(
name|p
argument_list|)
operator|<<
literal|2
expr_stmt|;
block|}
name|subglyph
operator|->
name|transform
operator|.
name|xx
operator|=
name|xx
expr_stmt|;
name|subglyph
operator|->
name|transform
operator|.
name|xy
operator|=
name|xy
expr_stmt|;
name|subglyph
operator|->
name|transform
operator|.
name|yx
operator|=
name|yx
expr_stmt|;
name|subglyph
operator|->
name|transform
operator|.
name|yy
operator|=
name|yy
expr_stmt|;
name|num_subglyphs
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|subglyph
operator|->
name|flags
operator|&
name|MORE_COMPONENTS
condition|)
do|;
name|gloader
operator|->
name|current
operator|.
name|num_subglyphs
operator|=
name|num_subglyphs
expr_stmt|;
ifdef|#
directive|ifdef
name|TT_USE_BYTECODE_INTERPRETER
block|{
name|FT_Stream
name|stream
init|=
name|loader
operator|->
name|stream
decl_stmt|;
comment|/* we must undo the FT_FRAME_ENTER in order to point */
comment|/* to the composite instructions, if we find some.   */
comment|/* We will process them later.                       */
comment|/*                                                   */
name|loader
operator|->
name|ins_pos
operator|=
call|(
name|FT_ULong
call|)
argument_list|(
name|FT_STREAM_POS
argument_list|()
operator|+
name|p
operator|-
name|limit
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|loader
operator|->
name|cursor
operator|=
name|p
expr_stmt|;
name|Fail
label|:
return|return
name|error
return|;
name|Invalid_Composite
label|:
name|error
operator|=
name|TT_Err_Invalid_Composite
expr_stmt|;
goto|goto
name|Fail
goto|;
block|}
end_block
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|TT_Init_Glyph_Loading
name|TT_Init_Glyph_Loading
argument_list|(
argument|TT_Face  face
argument_list|)
end_macro
begin_block
block|{
name|face
operator|->
name|access_glyph_frame
operator|=
name|TT_Access_Glyph_Frame
expr_stmt|;
name|face
operator|->
name|read_glyph_header
operator|=
name|TT_Load_Glyph_Header
expr_stmt|;
name|face
operator|->
name|read_simple_glyph
operator|=
name|TT_Load_Simple_Glyph
expr_stmt|;
name|face
operator|->
name|read_composite_glyph
operator|=
name|TT_Load_Composite_Glyph
expr_stmt|;
name|face
operator|->
name|forget_glyph_frame
operator|=
name|TT_Forget_Glyph_Frame
expr_stmt|;
block|}
end_block
begin_function
specifier|static
name|void
DECL|function|tt_prepare_zone
name|tt_prepare_zone
parameter_list|(
name|TT_GlyphZone
name|zone
parameter_list|,
name|FT_GlyphLoad
name|load
parameter_list|,
name|FT_UInt
name|start_point
parameter_list|,
name|FT_UInt
name|start_contour
parameter_list|)
block|{
name|zone
operator|->
name|n_points
operator|=
call|(
name|FT_UShort
call|)
argument_list|(
name|load
operator|->
name|outline
operator|.
name|n_points
operator|-
name|start_point
argument_list|)
expr_stmt|;
name|zone
operator|->
name|n_contours
operator|=
call|(
name|FT_Short
call|)
argument_list|(
name|load
operator|->
name|outline
operator|.
name|n_contours
operator|-
name|start_contour
argument_list|)
expr_stmt|;
name|zone
operator|->
name|org
operator|=
name|load
operator|->
name|extra_points
operator|+
name|start_point
expr_stmt|;
name|zone
operator|->
name|cur
operator|=
name|load
operator|->
name|outline
operator|.
name|points
operator|+
name|start_point
expr_stmt|;
name|zone
operator|->
name|orus
operator|=
name|load
operator|->
name|extra_points2
operator|+
name|start_point
expr_stmt|;
name|zone
operator|->
name|tags
operator|=
operator|(
name|FT_Byte
operator|*
operator|)
name|load
operator|->
name|outline
operator|.
name|tags
operator|+
name|start_point
expr_stmt|;
name|zone
operator|->
name|contours
operator|=
operator|(
name|FT_UShort
operator|*
operator|)
name|load
operator|->
name|outline
operator|.
name|contours
operator|+
name|start_contour
expr_stmt|;
name|zone
operator|->
name|first_point
operator|=
operator|(
name|FT_UShort
operator|)
name|start_point
expr_stmt|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    TT_Hint_Glyph                                                      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Hint the glyph using the zone prepared by the caller.  Note that   */
end_comment
begin_comment
comment|/*    the zone is supposed to include four phantom points.               */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|TT_Hint_Glyph
name|TT_Hint_Glyph
parameter_list|(
name|TT_Loader
name|loader
parameter_list|,
name|FT_Bool
name|is_composite
parameter_list|)
block|{
name|TT_GlyphZone
name|zone
init|=
operator|&
name|loader
operator|->
name|zone
decl_stmt|;
name|FT_Pos
name|origin
decl_stmt|;
ifdef|#
directive|ifdef
name|TT_USE_BYTECODE_INTERPRETER
name|FT_UInt
name|n_ins
decl_stmt|;
else|#
directive|else
name|FT_UNUSED
argument_list|(
name|is_composite
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TT_USE_BYTECODE_INTERPRETER
if|if
condition|(
name|loader
operator|->
name|glyph
operator|->
name|control_len
operator|>
literal|0xFFFFL
condition|)
block|{
name|FT_TRACE1
argument_list|(
operator|(
literal|"TT_Hint_Glyph: too long instructions "
operator|)
argument_list|)
expr_stmt|;
name|FT_TRACE1
argument_list|(
operator|(
literal|"(0x%lx byte) is truncated\n"
operator|,
name|loader
operator|->
name|glyph
operator|->
name|control_len
operator|)
argument_list|)
expr_stmt|;
block|}
name|n_ins
operator|=
call|(
name|FT_UInt
call|)
argument_list|(
name|loader
operator|->
name|glyph
operator|->
name|control_len
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|origin
operator|=
name|zone
operator|->
name|cur
index|[
name|zone
operator|->
name|n_points
operator|-
literal|4
index|]
operator|.
name|x
expr_stmt|;
name|origin
operator|=
name|FT_PIX_ROUND
argument_list|(
name|origin
argument_list|)
operator|-
name|origin
expr_stmt|;
if|if
condition|(
name|origin
condition|)
name|translate_array
argument_list|(
name|zone
operator|->
name|n_points
argument_list|,
name|zone
operator|->
name|cur
argument_list|,
name|origin
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TT_USE_BYTECODE_INTERPRETER
comment|/* save original point position in org */
if|if
condition|(
name|n_ins
operator|>
literal|0
condition|)
name|FT_ARRAY_COPY
argument_list|(
name|zone
operator|->
name|org
argument_list|,
name|zone
operator|->
name|cur
argument_list|,
name|zone
operator|->
name|n_points
argument_list|)
expr_stmt|;
comment|/* Reset graphics state. */
name|loader
operator|->
name|exec
operator|->
name|GS
operator|=
operator|(
operator|(
name|TT_Size
operator|)
name|loader
operator|->
name|size
operator|)
operator|->
name|GS
expr_stmt|;
comment|/* XXX: UNDOCUMENTED! Hinting instructions of a composite glyph */
comment|/*      completely refer to the (already) hinted subglyphs.     */
if|if
condition|(
name|is_composite
condition|)
block|{
name|loader
operator|->
name|exec
operator|->
name|metrics
operator|.
name|x_scale
operator|=
literal|1
operator|<<
literal|16
expr_stmt|;
name|loader
operator|->
name|exec
operator|->
name|metrics
operator|.
name|y_scale
operator|=
literal|1
operator|<<
literal|16
expr_stmt|;
name|FT_ARRAY_COPY
argument_list|(
name|zone
operator|->
name|orus
argument_list|,
name|zone
operator|->
name|cur
argument_list|,
name|zone
operator|->
name|n_points
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|loader
operator|->
name|exec
operator|->
name|metrics
operator|.
name|x_scale
operator|=
operator|(
operator|(
name|TT_Size
operator|)
name|loader
operator|->
name|size
operator|)
operator|->
name|metrics
operator|.
name|x_scale
expr_stmt|;
name|loader
operator|->
name|exec
operator|->
name|metrics
operator|.
name|y_scale
operator|=
operator|(
operator|(
name|TT_Size
operator|)
name|loader
operator|->
name|size
operator|)
operator|->
name|metrics
operator|.
name|y_scale
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* round pp2 and pp4 */
name|zone
operator|->
name|cur
index|[
name|zone
operator|->
name|n_points
operator|-
literal|3
index|]
operator|.
name|x
operator|=
name|FT_PIX_ROUND
argument_list|(
name|zone
operator|->
name|cur
index|[
name|zone
operator|->
name|n_points
operator|-
literal|3
index|]
operator|.
name|x
argument_list|)
expr_stmt|;
name|zone
operator|->
name|cur
index|[
name|zone
operator|->
name|n_points
operator|-
literal|1
index|]
operator|.
name|y
operator|=
name|FT_PIX_ROUND
argument_list|(
name|zone
operator|->
name|cur
index|[
name|zone
operator|->
name|n_points
operator|-
literal|1
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TT_USE_BYTECODE_INTERPRETER
if|if
condition|(
name|n_ins
operator|>
literal|0
condition|)
block|{
name|FT_Bool
name|debug
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|FT_GlyphLoader
name|gloader
init|=
name|loader
operator|->
name|gloader
decl_stmt|;
name|FT_Outline
name|current_outline
init|=
name|gloader
operator|->
name|current
operator|.
name|outline
decl_stmt|;
name|error
operator|=
name|TT_Set_CodeRange
argument_list|(
name|loader
operator|->
name|exec
argument_list|,
name|tt_coderange_glyph
argument_list|,
name|loader
operator|->
name|exec
operator|->
name|glyphIns
argument_list|,
name|n_ins
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|loader
operator|->
name|exec
operator|->
name|is_composite
operator|=
name|is_composite
expr_stmt|;
name|loader
operator|->
name|exec
operator|->
name|pts
operator|=
operator|*
name|zone
expr_stmt|;
name|debug
operator|=
name|FT_BOOL
argument_list|(
operator|!
operator|(
name|loader
operator|->
name|load_flags
operator|&
name|FT_LOAD_NO_SCALE
operator|)
operator|&&
operator|(
operator|(
name|TT_Size
operator|)
name|loader
operator|->
name|size
operator|)
operator|->
name|debug
argument_list|)
expr_stmt|;
name|error
operator|=
name|TT_Run_Context
argument_list|(
name|loader
operator|->
name|exec
argument_list|,
name|debug
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|loader
operator|->
name|exec
operator|->
name|pedantic_hinting
condition|)
return|return
name|error
return|;
comment|/* store drop-out mode in bits 5-7; set bit 2 also as a marker */
name|current_outline
operator|.
name|tags
index|[
literal|0
index|]
operator||=
operator|(
name|loader
operator|->
name|exec
operator|->
name|GS
operator|.
name|scan_type
operator|<<
literal|5
operator|)
operator||
name|FT_CURVE_TAG_HAS_SCANMODE
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* save glyph phantom points */
if|if
condition|(
operator|!
name|loader
operator|->
name|preserve_pps
condition|)
block|{
name|loader
operator|->
name|pp1
operator|=
name|zone
operator|->
name|cur
index|[
name|zone
operator|->
name|n_points
operator|-
literal|4
index|]
expr_stmt|;
name|loader
operator|->
name|pp2
operator|=
name|zone
operator|->
name|cur
index|[
name|zone
operator|->
name|n_points
operator|-
literal|3
index|]
expr_stmt|;
name|loader
operator|->
name|pp3
operator|=
name|zone
operator|->
name|cur
index|[
name|zone
operator|->
name|n_points
operator|-
literal|2
index|]
expr_stmt|;
name|loader
operator|->
name|pp4
operator|=
name|zone
operator|->
name|cur
index|[
name|zone
operator|->
name|n_points
operator|-
literal|1
index|]
expr_stmt|;
block|}
return|return
name|TT_Err_Ok
return|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    TT_Process_Simple_Glyph                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Once a simple glyph has been loaded, it needs to be processed.     */
end_comment
begin_comment
comment|/*    Usually, this means scaling and hinting through bytecode           */
end_comment
begin_comment
comment|/*    interpretation.                                                    */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|TT_Process_Simple_Glyph
name|TT_Process_Simple_Glyph
parameter_list|(
name|TT_Loader
name|loader
parameter_list|)
block|{
name|FT_GlyphLoader
name|gloader
init|=
name|loader
operator|->
name|gloader
decl_stmt|;
name|FT_Error
name|error
init|=
name|TT_Err_Ok
decl_stmt|;
name|FT_Outline
modifier|*
name|outline
decl_stmt|;
name|FT_Int
name|n_points
decl_stmt|;
name|outline
operator|=
operator|&
name|gloader
operator|->
name|current
operator|.
name|outline
expr_stmt|;
name|n_points
operator|=
name|outline
operator|->
name|n_points
expr_stmt|;
comment|/* set phantom points */
name|outline
operator|->
name|points
index|[
name|n_points
index|]
operator|=
name|loader
operator|->
name|pp1
expr_stmt|;
name|outline
operator|->
name|points
index|[
name|n_points
operator|+
literal|1
index|]
operator|=
name|loader
operator|->
name|pp2
expr_stmt|;
name|outline
operator|->
name|points
index|[
name|n_points
operator|+
literal|2
index|]
operator|=
name|loader
operator|->
name|pp3
expr_stmt|;
name|outline
operator|->
name|points
index|[
name|n_points
operator|+
literal|3
index|]
operator|=
name|loader
operator|->
name|pp4
expr_stmt|;
name|outline
operator|->
name|tags
index|[
name|n_points
index|]
operator|=
literal|0
expr_stmt|;
name|outline
operator|->
name|tags
index|[
name|n_points
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|outline
operator|->
name|tags
index|[
name|n_points
operator|+
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|outline
operator|->
name|tags
index|[
name|n_points
operator|+
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|n_points
operator|+=
literal|4
expr_stmt|;
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_GX_VAR_SUPPORT
if|if
condition|(
operator|(
operator|(
name|TT_Face
operator|)
name|loader
operator|->
name|face
operator|)
operator|->
name|doblend
condition|)
block|{
comment|/* Deltas apply to the unscaled data. */
name|FT_Vector
modifier|*
name|deltas
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|loader
operator|->
name|face
operator|->
name|memory
decl_stmt|;
name|FT_Int
name|i
decl_stmt|;
name|error
operator|=
name|TT_Vary_Get_Glyph_Deltas
argument_list|(
call|(
name|TT_Face
call|)
argument_list|(
name|loader
operator|->
name|face
argument_list|)
argument_list|,
name|loader
operator|->
name|glyph_index
argument_list|,
operator|&
name|deltas
argument_list|,
name|n_points
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_points
condition|;
operator|++
name|i
control|)
block|{
name|outline
operator|->
name|points
index|[
name|i
index|]
operator|.
name|x
operator|+=
name|deltas
index|[
name|i
index|]
operator|.
name|x
expr_stmt|;
name|outline
operator|->
name|points
index|[
name|i
index|]
operator|.
name|y
operator|+=
name|deltas
index|[
name|i
index|]
operator|.
name|y
expr_stmt|;
block|}
name|FT_FREE
argument_list|(
name|deltas
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* TT_CONFIG_OPTION_GX_VAR_SUPPORT */
if|if
condition|(
name|IS_HINTED
argument_list|(
name|loader
operator|->
name|load_flags
argument_list|)
condition|)
block|{
name|tt_prepare_zone
argument_list|(
operator|&
name|loader
operator|->
name|zone
argument_list|,
operator|&
name|gloader
operator|->
name|current
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FT_ARRAY_COPY
argument_list|(
name|loader
operator|->
name|zone
operator|.
name|orus
argument_list|,
name|loader
operator|->
name|zone
operator|.
name|cur
argument_list|,
name|loader
operator|->
name|zone
operator|.
name|n_points
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
comment|/* scale the glyph */
if|if
condition|(
operator|(
name|loader
operator|->
name|load_flags
operator|&
name|FT_LOAD_NO_SCALE
operator|)
operator|==
literal|0
condition|)
block|{
name|FT_Vector
modifier|*
name|vec
init|=
name|outline
operator|->
name|points
decl_stmt|;
name|FT_Vector
modifier|*
name|limit
init|=
name|outline
operator|->
name|points
operator|+
name|n_points
decl_stmt|;
name|FT_Fixed
name|x_scale
init|=
operator|(
operator|(
name|TT_Size
operator|)
name|loader
operator|->
name|size
operator|)
operator|->
name|metrics
operator|.
name|x_scale
decl_stmt|;
name|FT_Fixed
name|y_scale
init|=
operator|(
operator|(
name|TT_Size
operator|)
name|loader
operator|->
name|size
operator|)
operator|->
name|metrics
operator|.
name|y_scale
decl_stmt|;
for|for
control|(
init|;
name|vec
operator|<
name|limit
condition|;
name|vec
operator|++
control|)
block|{
name|vec
operator|->
name|x
operator|=
name|FT_MulFix
argument_list|(
name|vec
operator|->
name|x
argument_list|,
name|x_scale
argument_list|)
expr_stmt|;
name|vec
operator|->
name|y
operator|=
name|FT_MulFix
argument_list|(
name|vec
operator|->
name|y
argument_list|,
name|y_scale
argument_list|)
expr_stmt|;
block|}
name|loader
operator|->
name|pp1
operator|=
name|outline
operator|->
name|points
index|[
name|n_points
operator|-
literal|4
index|]
expr_stmt|;
name|loader
operator|->
name|pp2
operator|=
name|outline
operator|->
name|points
index|[
name|n_points
operator|-
literal|3
index|]
expr_stmt|;
name|loader
operator|->
name|pp3
operator|=
name|outline
operator|->
name|points
index|[
name|n_points
operator|-
literal|2
index|]
expr_stmt|;
name|loader
operator|->
name|pp4
operator|=
name|outline
operator|->
name|points
index|[
name|n_points
operator|-
literal|1
index|]
expr_stmt|;
block|}
if|if
condition|(
name|IS_HINTED
argument_list|(
name|loader
operator|->
name|load_flags
argument_list|)
condition|)
block|{
name|loader
operator|->
name|zone
operator|.
name|n_points
operator|+=
literal|4
expr_stmt|;
name|error
operator|=
name|TT_Hint_Glyph
argument_list|(
name|loader
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    TT_Process_Composite_Component                                     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Once a composite component has been loaded, it needs to be         */
end_comment
begin_comment
comment|/*    processed.  Usually, this means transforming and translating.      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|TT_Process_Composite_Component
name|TT_Process_Composite_Component
parameter_list|(
name|TT_Loader
name|loader
parameter_list|,
name|FT_SubGlyph
name|subglyph
parameter_list|,
name|FT_UInt
name|start_point
parameter_list|,
name|FT_UInt
name|num_base_points
parameter_list|)
block|{
name|FT_GlyphLoader
name|gloader
init|=
name|loader
operator|->
name|gloader
decl_stmt|;
name|FT_Vector
modifier|*
name|base_vec
init|=
name|gloader
operator|->
name|base
operator|.
name|outline
operator|.
name|points
decl_stmt|;
name|FT_UInt
name|num_points
init|=
name|gloader
operator|->
name|base
operator|.
name|outline
operator|.
name|n_points
decl_stmt|;
name|FT_Bool
name|have_scale
decl_stmt|;
name|FT_Pos
name|x
decl_stmt|,
name|y
decl_stmt|;
name|have_scale
operator|=
name|FT_BOOL
argument_list|(
name|subglyph
operator|->
name|flags
operator|&
operator|(
name|WE_HAVE_A_SCALE
operator||
name|WE_HAVE_AN_XY_SCALE
operator||
name|WE_HAVE_A_2X2
operator|)
argument_list|)
expr_stmt|;
comment|/* perform the transform required for this subglyph */
if|if
condition|(
name|have_scale
condition|)
block|{
name|FT_UInt
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|num_base_points
init|;
name|i
operator|<
name|num_points
condition|;
name|i
operator|++
control|)
name|FT_Vector_Transform
argument_list|(
name|base_vec
operator|+
name|i
argument_list|,
operator|&
name|subglyph
operator|->
name|transform
argument_list|)
expr_stmt|;
block|}
comment|/* get offset */
if|if
condition|(
operator|!
operator|(
name|subglyph
operator|->
name|flags
operator|&
name|ARGS_ARE_XY_VALUES
operator|)
condition|)
block|{
name|FT_UInt
name|k
init|=
name|subglyph
operator|->
name|arg1
decl_stmt|;
name|FT_UInt
name|l
init|=
name|subglyph
operator|->
name|arg2
decl_stmt|;
name|FT_Vector
modifier|*
name|p1
decl_stmt|;
name|FT_Vector
modifier|*
name|p2
decl_stmt|;
comment|/* match l-th point of the newly loaded component to the k-th point */
comment|/* of the previously loaded components.                             */
comment|/* change to the point numbers used by our outline */
name|k
operator|+=
name|start_point
expr_stmt|;
name|l
operator|+=
name|num_base_points
expr_stmt|;
if|if
condition|(
name|k
operator|>=
name|num_base_points
operator|||
name|l
operator|>=
name|num_points
condition|)
return|return
name|TT_Err_Invalid_Composite
return|;
name|p1
operator|=
name|gloader
operator|->
name|base
operator|.
name|outline
operator|.
name|points
operator|+
name|k
expr_stmt|;
name|p2
operator|=
name|gloader
operator|->
name|base
operator|.
name|outline
operator|.
name|points
operator|+
name|l
expr_stmt|;
name|x
operator|=
name|p1
operator|->
name|x
operator|-
name|p2
operator|->
name|x
expr_stmt|;
name|y
operator|=
name|p1
operator|->
name|y
operator|-
name|p2
operator|->
name|y
expr_stmt|;
block|}
else|else
block|{
name|x
operator|=
name|subglyph
operator|->
name|arg1
expr_stmt|;
name|y
operator|=
name|subglyph
operator|->
name|arg2
expr_stmt|;
if|if
condition|(
operator|!
name|x
operator|&&
operator|!
name|y
condition|)
return|return
name|TT_Err_Ok
return|;
comment|/* Use a default value dependent on                                     */
comment|/* TT_CONFIG_OPTION_COMPONENT_OFFSET_SCALED.  This is useful for old TT */
comment|/* fonts which don't set the xxx_COMPONENT_OFFSET bit.                  */
if|if
condition|(
name|have_scale
operator|&&
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_COMPONENT_OFFSET_SCALED
operator|!
operator|(
name|subglyph
operator|->
name|flags
operator|&
name|UNSCALED_COMPONENT_OFFSET
operator|)
condition|)
else|#
directive|else
operator|(
name|subglyph
operator|->
name|flags
operator|&
name|SCALED_COMPONENT_OFFSET
operator|)
block|)
endif|#
directive|endif
block|{
if|#
directive|if
literal|0
comment|/*************************************************************************/
comment|/*                                                                       */
comment|/* This algorithm is what Apple documents.  But it doesn't work.         */
comment|/*                                                                       */
block|int  a = subglyph->transform.xx> 0 ?  subglyph->transform.xx                                             : -subglyph->transform.xx;         int  b = subglyph->transform.yx> 0 ?  subglyph->transform.yx                                             : -subglyph->transform.yx;         int  c = subglyph->transform.xy> 0 ?  subglyph->transform.xy                                             : -subglyph->transform.xy;         int  d = subglyph->transform.yy> 0 ? subglyph->transform.yy                                             : -subglyph->transform.yy;         int  m = a> b ? a : b;         int  n = c> d ? c : d;           if ( a - b<= 33&& a - b>= -33 )           m *= 2;         if ( c - d<= 33&& c - d>= -33 )           n *= 2;         x = FT_MulFix( x, m );         y = FT_MulFix( y, n );
else|#
directive|else
comment|/* 0 */
comment|/*************************************************************************/
comment|/*                                                                       */
comment|/* This algorithm is a guess and works much better than the above.       */
comment|/*                                                                       */
name|FT_Fixed
name|mac_xscale
init|=
name|FT_SqrtFixed
argument_list|(
operator|(
name|FT_Int32
operator|)
name|FT_MulFix
argument_list|(
name|subglyph
operator|->
name|transform
operator|.
name|xx
argument_list|,
name|subglyph
operator|->
name|transform
operator|.
name|xx
argument_list|)
operator|+
operator|(
name|FT_Int32
operator|)
name|FT_MulFix
argument_list|(
name|subglyph
operator|->
name|transform
operator|.
name|xy
argument_list|,
name|subglyph
operator|->
name|transform
operator|.
name|xy
argument_list|)
argument_list|)
decl_stmt|;
name|FT_Fixed
name|mac_yscale
init|=
name|FT_SqrtFixed
argument_list|(
operator|(
name|FT_Int32
operator|)
name|FT_MulFix
argument_list|(
name|subglyph
operator|->
name|transform
operator|.
name|yy
argument_list|,
name|subglyph
operator|->
name|transform
operator|.
name|yy
argument_list|)
operator|+
operator|(
name|FT_Int32
operator|)
name|FT_MulFix
argument_list|(
name|subglyph
operator|->
name|transform
operator|.
name|yx
argument_list|,
name|subglyph
operator|->
name|transform
operator|.
name|yx
argument_list|)
argument_list|)
decl_stmt|;
name|x
operator|=
name|FT_MulFix
argument_list|(
name|x
argument_list|,
name|mac_xscale
argument_list|)
expr_stmt|;
name|y
operator|=
name|FT_MulFix
argument_list|(
name|y
argument_list|,
name|mac_yscale
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 0 */
block|}
if|if
condition|(
operator|!
operator|(
name|loader
operator|->
name|load_flags
operator|&
name|FT_LOAD_NO_SCALE
operator|)
condition|)
block|{
name|FT_Fixed
name|x_scale
init|=
operator|(
operator|(
name|TT_Size
operator|)
name|loader
operator|->
name|size
operator|)
operator|->
name|metrics
operator|.
name|x_scale
decl_stmt|;
name|FT_Fixed
name|y_scale
init|=
operator|(
operator|(
name|TT_Size
operator|)
name|loader
operator|->
name|size
operator|)
operator|->
name|metrics
operator|.
name|y_scale
decl_stmt|;
name|x
operator|=
name|FT_MulFix
argument_list|(
name|x
argument_list|,
name|x_scale
argument_list|)
expr_stmt|;
name|y
operator|=
name|FT_MulFix
argument_list|(
name|y
argument_list|,
name|y_scale
argument_list|)
expr_stmt|;
if|if
condition|(
name|subglyph
operator|->
name|flags
operator|&
name|ROUND_XY_TO_GRID
condition|)
block|{
name|x
operator|=
name|FT_PIX_ROUND
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|y
operator|=
name|FT_PIX_ROUND
argument_list|(
name|y
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_if
if|if
condition|(
name|x
operator|||
name|y
condition|)
name|translate_array
argument_list|(
name|num_points
operator|-
name|num_base_points
argument_list|,
name|base_vec
operator|+
name|num_base_points
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
end_if
begin_return
return|return
name|TT_Err_Ok
return|;
end_return
begin_comment
unit|}
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    TT_Process_Composite_Glyph                                         */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    This is slightly different from TT_Process_Simple_Glyph, in that   */
end_comment
begin_comment
comment|/*    its sole purpose is to hint the glyph.  Thus this function is      */
end_comment
begin_comment
comment|/*    only available when bytecode interpreter is enabled.               */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
unit|static
name|FT_Error
DECL|function|TT_Process_Composite_Glyph
name|TT_Process_Composite_Glyph
parameter_list|(
name|TT_Loader
name|loader
parameter_list|,
name|FT_UInt
name|start_point
parameter_list|,
name|FT_UInt
name|start_contour
parameter_list|)
block|{
name|FT_Error
name|error
decl_stmt|;
name|FT_Outline
modifier|*
name|outline
decl_stmt|;
name|FT_UInt
name|i
decl_stmt|;
name|outline
operator|=
operator|&
name|loader
operator|->
name|gloader
operator|->
name|base
operator|.
name|outline
expr_stmt|;
comment|/* make room for phantom points */
name|error
operator|=
name|FT_GLYPHLOADER_CHECK_POINTS
argument_list|(
name|loader
operator|->
name|gloader
argument_list|,
name|outline
operator|->
name|n_points
operator|+
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|outline
operator|->
name|points
index|[
name|outline
operator|->
name|n_points
index|]
operator|=
name|loader
operator|->
name|pp1
expr_stmt|;
name|outline
operator|->
name|points
index|[
name|outline
operator|->
name|n_points
operator|+
literal|1
index|]
operator|=
name|loader
operator|->
name|pp2
expr_stmt|;
name|outline
operator|->
name|points
index|[
name|outline
operator|->
name|n_points
operator|+
literal|2
index|]
operator|=
name|loader
operator|->
name|pp3
expr_stmt|;
name|outline
operator|->
name|points
index|[
name|outline
operator|->
name|n_points
operator|+
literal|3
index|]
operator|=
name|loader
operator|->
name|pp4
expr_stmt|;
name|outline
operator|->
name|tags
index|[
name|outline
operator|->
name|n_points
index|]
operator|=
literal|0
expr_stmt|;
name|outline
operator|->
name|tags
index|[
name|outline
operator|->
name|n_points
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|outline
operator|->
name|tags
index|[
name|outline
operator|->
name|n_points
operator|+
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|outline
operator|->
name|tags
index|[
name|outline
operator|->
name|n_points
operator|+
literal|3
index|]
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|TT_USE_BYTECODE_INTERPRETER
block|{
name|FT_Stream
name|stream
init|=
name|loader
operator|->
name|stream
decl_stmt|;
name|FT_UShort
name|n_ins
decl_stmt|;
comment|/* TT_Load_Composite_Glyph only gives us the offset of instructions */
comment|/* so we read them here                                             */
if|if
condition|(
name|FT_STREAM_SEEK
argument_list|(
name|loader
operator|->
name|ins_pos
argument_list|)
operator|||
name|FT_READ_USHORT
argument_list|(
name|n_ins
argument_list|)
condition|)
return|return
name|error
return|;
name|FT_TRACE5
argument_list|(
operator|(
literal|"  Instructions size = %d\n"
operator|,
name|n_ins
operator|)
argument_list|)
expr_stmt|;
comment|/* check it */
if|if
condition|(
name|n_ins
operator|>
operator|(
operator|(
name|TT_Face
operator|)
name|loader
operator|->
name|face
operator|)
operator|->
name|max_profile
operator|.
name|maxSizeOfInstructions
condition|)
block|{
name|FT_TRACE0
argument_list|(
operator|(
literal|"TT_Process_Composite_Glyph: too many instructions (%d)\n"
operator|,
name|n_ins
operator|)
argument_list|)
expr_stmt|;
return|return
name|TT_Err_Too_Many_Hints
return|;
block|}
elseif|else
if|if
condition|(
name|n_ins
operator|==
literal|0
condition|)
return|return
name|TT_Err_Ok
return|;
if|if
condition|(
name|FT_STREAM_READ
argument_list|(
name|loader
operator|->
name|exec
operator|->
name|glyphIns
argument_list|,
name|n_ins
argument_list|)
condition|)
return|return
name|error
return|;
name|loader
operator|->
name|glyph
operator|->
name|control_data
operator|=
name|loader
operator|->
name|exec
operator|->
name|glyphIns
expr_stmt|;
name|loader
operator|->
name|glyph
operator|->
name|control_len
operator|=
name|n_ins
expr_stmt|;
block|}
endif|#
directive|endif
name|tt_prepare_zone
argument_list|(
operator|&
name|loader
operator|->
name|zone
argument_list|,
operator|&
name|loader
operator|->
name|gloader
operator|->
name|base
argument_list|,
name|start_point
argument_list|,
name|start_contour
argument_list|)
expr_stmt|;
comment|/* Some points are likely touched during execution of  */
comment|/* instructions on components.  So let's untouch them. */
for|for
control|(
name|i
operator|=
name|start_point
init|;
name|i
operator|<
name|loader
operator|->
name|zone
operator|.
name|n_points
condition|;
name|i
operator|++
control|)
name|loader
operator|->
name|zone
operator|.
name|tags
index|[
name|i
index|]
operator|&=
operator|~
name|FT_CURVE_TAG_TOUCH_BOTH
expr_stmt|;
name|loader
operator|->
name|zone
operator|.
name|n_points
operator|+=
literal|4
expr_stmt|;
return|return
name|TT_Hint_Glyph
argument_list|(
name|loader
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/* Calculate the four phantom points.                     */
end_comment
begin_comment
comment|/* The first two stand for horizontal origin and advance. */
end_comment
begin_comment
comment|/* The last two stand for vertical origin and advance.    */
end_comment
begin_define
DECL|macro|TT_LOADER_SET_PP
define|#
directive|define
name|TT_LOADER_SET_PP
parameter_list|(
name|loader
parameter_list|)
define|\
value|do {                                                              \             (loader)->pp1.x = (loader)->bbox.xMin - (loader)->left_bearing; \             (loader)->pp1.y = 0;                                            \             (loader)->pp2.x = (loader)->pp1.x + (loader)->advance;          \             (loader)->pp2.y = 0;                                            \             (loader)->pp3.x = 0;                                            \             (loader)->pp3.y = (loader)->top_bearing + (loader)->bbox.yMax;  \             (loader)->pp4.x = 0;                                            \             (loader)->pp4.y = (loader)->pp3.y - (loader)->vadvance;         \           } while ( 0 )
end_define
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    load_truetype_glyph                                                */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Loads a given truetype glyph.  Handles composites and uses a       */
end_comment
begin_comment
comment|/*    TT_Loader object.                                                  */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|load_truetype_glyph
name|load_truetype_glyph
parameter_list|(
name|TT_Loader
name|loader
parameter_list|,
name|FT_UInt
name|glyph_index
parameter_list|,
name|FT_UInt
name|recurse_count
parameter_list|,
name|FT_Bool
name|header_only
parameter_list|)
block|{
name|FT_Error
name|error
init|=
name|TT_Err_Ok
decl_stmt|;
name|FT_Fixed
name|x_scale
decl_stmt|,
name|y_scale
decl_stmt|;
name|FT_ULong
name|offset
decl_stmt|;
name|TT_Face
name|face
init|=
operator|(
name|TT_Face
operator|)
name|loader
operator|->
name|face
decl_stmt|;
name|FT_GlyphLoader
name|gloader
init|=
name|loader
operator|->
name|gloader
decl_stmt|;
name|FT_Bool
name|opened_frame
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_GX_VAR_SUPPORT
name|FT_Vector
modifier|*
name|deltas
init|=
name|NULL
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|FT_CONFIG_OPTION_INCREMENTAL
name|FT_StreamRec
name|inc_stream
decl_stmt|;
name|FT_Data
name|glyph_data
decl_stmt|;
name|FT_Bool
name|glyph_data_loaded
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
comment|/* some fonts have an incorrect value of `maxComponentDepth', */
comment|/* thus we allow depth 1 to catch the majority of them        */
if|if
condition|(
name|recurse_count
operator|>
literal|1
operator|&&
name|recurse_count
operator|>
name|face
operator|->
name|max_profile
operator|.
name|maxComponentDepth
condition|)
block|{
name|error
operator|=
name|TT_Err_Invalid_Composite
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* check glyph index */
if|if
condition|(
name|glyph_index
operator|>=
operator|(
name|FT_UInt
operator|)
name|face
operator|->
name|root
operator|.
name|num_glyphs
condition|)
block|{
name|error
operator|=
name|TT_Err_Invalid_Glyph_Index
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|loader
operator|->
name|glyph_index
operator|=
name|glyph_index
expr_stmt|;
if|if
condition|(
operator|(
name|loader
operator|->
name|load_flags
operator|&
name|FT_LOAD_NO_SCALE
operator|)
operator|==
literal|0
condition|)
block|{
name|x_scale
operator|=
operator|(
operator|(
name|TT_Size
operator|)
name|loader
operator|->
name|size
operator|)
operator|->
name|metrics
operator|.
name|x_scale
expr_stmt|;
name|y_scale
operator|=
operator|(
operator|(
name|TT_Size
operator|)
name|loader
operator|->
name|size
operator|)
operator|->
name|metrics
operator|.
name|y_scale
expr_stmt|;
block|}
else|else
block|{
name|x_scale
operator|=
literal|0x10000L
expr_stmt|;
name|y_scale
operator|=
literal|0x10000L
expr_stmt|;
block|}
name|tt_get_metrics
argument_list|(
name|loader
argument_list|,
name|glyph_index
argument_list|)
expr_stmt|;
comment|/* Set `offset' to the start of the glyph relative to the start of */
comment|/* the `glyf' table, and `byte_len' to the length of the glyph in  */
comment|/* bytes.                                                          */
ifdef|#
directive|ifdef
name|FT_CONFIG_OPTION_INCREMENTAL
comment|/* If we are loading glyph data via the incremental interface, set */
comment|/* the loader stream to a memory stream reading the data returned  */
comment|/* by the interface.                                               */
if|if
condition|(
name|face
operator|->
name|root
operator|.
name|internal
operator|->
name|incremental_interface
condition|)
block|{
name|error
operator|=
name|face
operator|->
name|root
operator|.
name|internal
operator|->
name|incremental_interface
operator|->
name|funcs
operator|->
name|get_glyph_data
argument_list|(
name|face
operator|->
name|root
operator|.
name|internal
operator|->
name|incremental_interface
operator|->
name|object
argument_list|,
name|glyph_index
argument_list|,
operator|&
name|glyph_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|glyph_data_loaded
operator|=
literal|1
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
name|loader
operator|->
name|byte_len
operator|=
name|glyph_data
operator|.
name|length
expr_stmt|;
name|FT_MEM_ZERO
argument_list|(
operator|&
name|inc_stream
argument_list|,
sizeof|sizeof
argument_list|(
name|inc_stream
argument_list|)
argument_list|)
expr_stmt|;
name|FT_Stream_OpenMemory
argument_list|(
operator|&
name|inc_stream
argument_list|,
name|glyph_data
operator|.
name|pointer
argument_list|,
name|glyph_data
operator|.
name|length
argument_list|)
expr_stmt|;
name|loader
operator|->
name|stream
operator|=
operator|&
name|inc_stream
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* FT_CONFIG_OPTION_INCREMENTAL */
name|offset
operator|=
name|tt_face_get_location
argument_list|(
name|face
argument_list|,
name|glyph_index
argument_list|,
operator|(
name|FT_UInt
operator|*
operator|)
operator|&
name|loader
operator|->
name|byte_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|loader
operator|->
name|byte_len
operator|>
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|FT_CONFIG_OPTION_INCREMENTAL
comment|/* for the incremental interface, `glyf_offset' is always zero */
if|if
condition|(
operator|!
name|loader
operator|->
name|glyf_offset
operator|&&
operator|!
name|face
operator|->
name|root
operator|.
name|internal
operator|->
name|incremental_interface
condition|)
else|#
directive|else
if|if
condition|(
operator|!
name|loader
operator|->
name|glyf_offset
condition|)
endif|#
directive|endif
comment|/* FT_CONFIG_OPTION_INCREMENTAL */
block|{
name|FT_TRACE2
argument_list|(
operator|(
literal|"no `glyf' table but non-zero `loca' entry\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|TT_Err_Invalid_Table
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|error
operator|=
name|face
operator|->
name|access_glyph_frame
argument_list|(
name|loader
argument_list|,
name|glyph_index
argument_list|,
name|loader
operator|->
name|glyf_offset
operator|+
name|offset
argument_list|,
name|loader
operator|->
name|byte_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|opened_frame
operator|=
literal|1
expr_stmt|;
comment|/* read glyph header first */
name|error
operator|=
name|face
operator|->
name|read_glyph_header
argument_list|(
name|loader
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|header_only
condition|)
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|loader
operator|->
name|byte_len
operator|==
literal|0
operator|||
name|loader
operator|->
name|n_contours
operator|==
literal|0
condition|)
block|{
name|loader
operator|->
name|bbox
operator|.
name|xMin
operator|=
literal|0
expr_stmt|;
name|loader
operator|->
name|bbox
operator|.
name|xMax
operator|=
literal|0
expr_stmt|;
name|loader
operator|->
name|bbox
operator|.
name|yMin
operator|=
literal|0
expr_stmt|;
name|loader
operator|->
name|bbox
operator|.
name|yMax
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|header_only
condition|)
goto|goto
name|Exit
goto|;
name|TT_LOADER_SET_PP
argument_list|(
name|loader
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_GX_VAR_SUPPORT
if|if
condition|(
operator|(
call|(
name|TT_Face
call|)
argument_list|(
name|loader
operator|->
name|face
argument_list|)
operator|)
operator|->
name|doblend
condition|)
block|{
comment|/* this must be done before scaling */
name|FT_Memory
name|memory
init|=
name|loader
operator|->
name|face
operator|->
name|memory
decl_stmt|;
name|error
operator|=
name|TT_Vary_Get_Glyph_Deltas
argument_list|(
call|(
name|TT_Face
call|)
argument_list|(
name|loader
operator|->
name|face
argument_list|)
argument_list|,
name|glyph_index
argument_list|,
operator|&
name|deltas
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|loader
operator|->
name|pp1
operator|.
name|x
operator|+=
name|deltas
index|[
literal|0
index|]
operator|.
name|x
expr_stmt|;
name|loader
operator|->
name|pp1
operator|.
name|y
operator|+=
name|deltas
index|[
literal|0
index|]
operator|.
name|y
expr_stmt|;
name|loader
operator|->
name|pp2
operator|.
name|x
operator|+=
name|deltas
index|[
literal|1
index|]
operator|.
name|x
expr_stmt|;
name|loader
operator|->
name|pp2
operator|.
name|y
operator|+=
name|deltas
index|[
literal|1
index|]
operator|.
name|y
expr_stmt|;
name|loader
operator|->
name|pp3
operator|.
name|x
operator|+=
name|deltas
index|[
literal|2
index|]
operator|.
name|x
expr_stmt|;
name|loader
operator|->
name|pp3
operator|.
name|y
operator|+=
name|deltas
index|[
literal|2
index|]
operator|.
name|y
expr_stmt|;
name|loader
operator|->
name|pp4
operator|.
name|x
operator|+=
name|deltas
index|[
literal|3
index|]
operator|.
name|x
expr_stmt|;
name|loader
operator|->
name|pp4
operator|.
name|y
operator|+=
name|deltas
index|[
literal|3
index|]
operator|.
name|y
expr_stmt|;
name|FT_FREE
argument_list|(
name|deltas
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|loader
operator|->
name|load_flags
operator|&
name|FT_LOAD_NO_SCALE
operator|)
operator|==
literal|0
condition|)
block|{
name|loader
operator|->
name|pp1
operator|.
name|x
operator|=
name|FT_MulFix
argument_list|(
name|loader
operator|->
name|pp1
operator|.
name|x
argument_list|,
name|x_scale
argument_list|)
expr_stmt|;
name|loader
operator|->
name|pp2
operator|.
name|x
operator|=
name|FT_MulFix
argument_list|(
name|loader
operator|->
name|pp2
operator|.
name|x
argument_list|,
name|x_scale
argument_list|)
expr_stmt|;
name|loader
operator|->
name|pp3
operator|.
name|y
operator|=
name|FT_MulFix
argument_list|(
name|loader
operator|->
name|pp3
operator|.
name|y
argument_list|,
name|y_scale
argument_list|)
expr_stmt|;
name|loader
operator|->
name|pp4
operator|.
name|y
operator|=
name|FT_MulFix
argument_list|(
name|loader
operator|->
name|pp4
operator|.
name|y
argument_list|,
name|y_scale
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|TT_Err_Ok
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|TT_LOADER_SET_PP
argument_list|(
name|loader
argument_list|)
expr_stmt|;
comment|/***********************************************************************/
comment|/***********************************************************************/
comment|/***********************************************************************/
comment|/* if it is a simple glyph, load it */
if|if
condition|(
name|loader
operator|->
name|n_contours
operator|>
literal|0
condition|)
block|{
name|error
operator|=
name|face
operator|->
name|read_simple_glyph
argument_list|(
name|loader
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
comment|/* all data have been read */
name|face
operator|->
name|forget_glyph_frame
argument_list|(
name|loader
argument_list|)
expr_stmt|;
name|opened_frame
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|TT_Process_Simple_Glyph
argument_list|(
name|loader
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|FT_GlyphLoader_Add
argument_list|(
name|gloader
argument_list|)
expr_stmt|;
block|}
comment|/***********************************************************************/
comment|/***********************************************************************/
comment|/***********************************************************************/
comment|/* otherwise, load a composite! */
elseif|else
if|if
condition|(
name|loader
operator|->
name|n_contours
operator|==
operator|-
literal|1
condition|)
block|{
name|FT_UInt
name|start_point
decl_stmt|;
name|FT_UInt
name|start_contour
decl_stmt|;
name|FT_ULong
name|ins_pos
decl_stmt|;
comment|/* position of composite instructions, if any */
name|start_point
operator|=
name|gloader
operator|->
name|base
operator|.
name|outline
operator|.
name|n_points
expr_stmt|;
name|start_contour
operator|=
name|gloader
operator|->
name|base
operator|.
name|outline
operator|.
name|n_contours
expr_stmt|;
comment|/* for each subglyph, read composite header */
name|error
operator|=
name|face
operator|->
name|read_composite_glyph
argument_list|(
name|loader
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
comment|/* store the offset of instructions */
name|ins_pos
operator|=
name|loader
operator|->
name|ins_pos
expr_stmt|;
comment|/* all data we need are read */
name|face
operator|->
name|forget_glyph_frame
argument_list|(
name|loader
argument_list|)
expr_stmt|;
name|opened_frame
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_GX_VAR_SUPPORT
if|if
condition|(
name|face
operator|->
name|doblend
condition|)
block|{
name|FT_Int
name|i
decl_stmt|,
name|limit
decl_stmt|;
name|FT_SubGlyph
name|subglyph
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|face
operator|->
name|root
operator|.
name|memory
decl_stmt|;
comment|/* this provides additional offsets */
comment|/* for each component's translation */
if|if
condition|(
operator|(
name|error
operator|=
name|TT_Vary_Get_Glyph_Deltas
argument_list|(
name|face
argument_list|,
name|glyph_index
argument_list|,
operator|&
name|deltas
argument_list|,
name|gloader
operator|->
name|current
operator|.
name|num_subglyphs
operator|+
literal|4
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|Exit
goto|;
name|subglyph
operator|=
name|gloader
operator|->
name|current
operator|.
name|subglyphs
operator|+
name|gloader
operator|->
name|base
operator|.
name|num_subglyphs
expr_stmt|;
name|limit
operator|=
name|gloader
operator|->
name|current
operator|.
name|num_subglyphs
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|limit
condition|;
operator|++
name|i
operator|,
operator|++
name|subglyph
control|)
block|{
if|if
condition|(
name|subglyph
operator|->
name|flags
operator|&
name|ARGS_ARE_XY_VALUES
condition|)
block|{
comment|/* XXX: overflow check for subglyph->{arg1,arg2}.   */
comment|/* deltas[i].{x,y} must be within signed 16-bit,    */
comment|/* but the restriction of summed delta is not clear */
name|subglyph
operator|->
name|arg1
operator|+=
operator|(
name|FT_Int16
operator|)
name|deltas
index|[
name|i
index|]
operator|.
name|x
expr_stmt|;
name|subglyph
operator|->
name|arg2
operator|+=
operator|(
name|FT_Int16
operator|)
name|deltas
index|[
name|i
index|]
operator|.
name|y
expr_stmt|;
block|}
block|}
name|loader
operator|->
name|pp1
operator|.
name|x
operator|+=
name|deltas
index|[
name|i
operator|+
literal|0
index|]
operator|.
name|x
expr_stmt|;
name|loader
operator|->
name|pp1
operator|.
name|y
operator|+=
name|deltas
index|[
name|i
operator|+
literal|0
index|]
operator|.
name|y
expr_stmt|;
name|loader
operator|->
name|pp2
operator|.
name|x
operator|+=
name|deltas
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|x
expr_stmt|;
name|loader
operator|->
name|pp2
operator|.
name|y
operator|+=
name|deltas
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|y
expr_stmt|;
name|loader
operator|->
name|pp3
operator|.
name|x
operator|+=
name|deltas
index|[
name|i
operator|+
literal|2
index|]
operator|.
name|x
expr_stmt|;
name|loader
operator|->
name|pp3
operator|.
name|y
operator|+=
name|deltas
index|[
name|i
operator|+
literal|2
index|]
operator|.
name|y
expr_stmt|;
name|loader
operator|->
name|pp4
operator|.
name|x
operator|+=
name|deltas
index|[
name|i
operator|+
literal|3
index|]
operator|.
name|x
expr_stmt|;
name|loader
operator|->
name|pp4
operator|.
name|y
operator|+=
name|deltas
index|[
name|i
operator|+
literal|3
index|]
operator|.
name|y
expr_stmt|;
name|FT_FREE
argument_list|(
name|deltas
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* TT_CONFIG_OPTION_GX_VAR_SUPPORT */
if|if
condition|(
operator|(
name|loader
operator|->
name|load_flags
operator|&
name|FT_LOAD_NO_SCALE
operator|)
operator|==
literal|0
condition|)
block|{
name|loader
operator|->
name|pp1
operator|.
name|x
operator|=
name|FT_MulFix
argument_list|(
name|loader
operator|->
name|pp1
operator|.
name|x
argument_list|,
name|x_scale
argument_list|)
expr_stmt|;
name|loader
operator|->
name|pp2
operator|.
name|x
operator|=
name|FT_MulFix
argument_list|(
name|loader
operator|->
name|pp2
operator|.
name|x
argument_list|,
name|x_scale
argument_list|)
expr_stmt|;
name|loader
operator|->
name|pp3
operator|.
name|y
operator|=
name|FT_MulFix
argument_list|(
name|loader
operator|->
name|pp3
operator|.
name|y
argument_list|,
name|y_scale
argument_list|)
expr_stmt|;
name|loader
operator|->
name|pp4
operator|.
name|y
operator|=
name|FT_MulFix
argument_list|(
name|loader
operator|->
name|pp4
operator|.
name|y
argument_list|,
name|y_scale
argument_list|)
expr_stmt|;
block|}
comment|/* if the flag FT_LOAD_NO_RECURSE is set, we return the subglyph */
comment|/* `as is' in the glyph slot (the client application will be     */
comment|/* responsible for interpreting these data)...                   */
if|if
condition|(
name|loader
operator|->
name|load_flags
operator|&
name|FT_LOAD_NO_RECURSE
condition|)
block|{
name|FT_GlyphLoader_Add
argument_list|(
name|gloader
argument_list|)
expr_stmt|;
name|loader
operator|->
name|glyph
operator|->
name|format
operator|=
name|FT_GLYPH_FORMAT_COMPOSITE
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/*********************************************************************/
comment|/*********************************************************************/
comment|/*********************************************************************/
block|{
name|FT_UInt
name|n
decl_stmt|,
name|num_base_points
decl_stmt|;
name|FT_SubGlyph
name|subglyph
init|=
literal|0
decl_stmt|;
name|FT_UInt
name|num_points
init|=
name|start_point
decl_stmt|;
name|FT_UInt
name|num_subglyphs
init|=
name|gloader
operator|->
name|current
operator|.
name|num_subglyphs
decl_stmt|;
name|FT_UInt
name|num_base_subgs
init|=
name|gloader
operator|->
name|base
operator|.
name|num_subglyphs
decl_stmt|;
name|FT_Stream
name|old_stream
init|=
name|loader
operator|->
name|stream
decl_stmt|;
name|FT_GlyphLoader_Add
argument_list|(
name|gloader
argument_list|)
expr_stmt|;
comment|/* read each subglyph independently */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|num_subglyphs
condition|;
name|n
operator|++
control|)
block|{
name|FT_Vector
name|pp
index|[
literal|4
index|]
decl_stmt|;
comment|/* Each time we call load_truetype_glyph in this loop, the   */
comment|/* value of `gloader.base.subglyphs' can change due to table */
comment|/* reallocations.  We thus need to recompute the subglyph    */
comment|/* pointer on each iteration.                                */
name|subglyph
operator|=
name|gloader
operator|->
name|base
operator|.
name|subglyphs
operator|+
name|num_base_subgs
operator|+
name|n
expr_stmt|;
name|pp
index|[
literal|0
index|]
operator|=
name|loader
operator|->
name|pp1
expr_stmt|;
name|pp
index|[
literal|1
index|]
operator|=
name|loader
operator|->
name|pp2
expr_stmt|;
name|pp
index|[
literal|2
index|]
operator|=
name|loader
operator|->
name|pp3
expr_stmt|;
name|pp
index|[
literal|3
index|]
operator|=
name|loader
operator|->
name|pp4
expr_stmt|;
name|num_base_points
operator|=
name|gloader
operator|->
name|base
operator|.
name|outline
operator|.
name|n_points
expr_stmt|;
name|error
operator|=
name|load_truetype_glyph
argument_list|(
name|loader
argument_list|,
name|subglyph
operator|->
name|index
argument_list|,
name|recurse_count
operator|+
literal|1
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
comment|/* restore subglyph pointer */
name|subglyph
operator|=
name|gloader
operator|->
name|base
operator|.
name|subglyphs
operator|+
name|num_base_subgs
operator|+
name|n
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|subglyph
operator|->
name|flags
operator|&
name|USE_MY_METRICS
operator|)
condition|)
block|{
name|loader
operator|->
name|pp1
operator|=
name|pp
index|[
literal|0
index|]
expr_stmt|;
name|loader
operator|->
name|pp2
operator|=
name|pp
index|[
literal|1
index|]
expr_stmt|;
name|loader
operator|->
name|pp3
operator|=
name|pp
index|[
literal|2
index|]
expr_stmt|;
name|loader
operator|->
name|pp4
operator|=
name|pp
index|[
literal|3
index|]
expr_stmt|;
block|}
name|num_points
operator|=
name|gloader
operator|->
name|base
operator|.
name|outline
operator|.
name|n_points
expr_stmt|;
if|if
condition|(
name|num_points
operator|==
name|num_base_points
condition|)
continue|continue;
comment|/* gloader->base.outline consists of three parts:               */
comment|/* 0 -(1)-> start_point -(2)-> num_base_points -(3)-> n_points. */
comment|/*                                                              */
comment|/* (1): exists from the beginning                               */
comment|/* (2): components that have been loaded so far                 */
comment|/* (3): the newly loaded component                              */
name|TT_Process_Composite_Component
argument_list|(
name|loader
argument_list|,
name|subglyph
argument_list|,
name|start_point
argument_list|,
name|num_base_points
argument_list|)
expr_stmt|;
block|}
name|loader
operator|->
name|stream
operator|=
name|old_stream
expr_stmt|;
comment|/* process the glyph */
name|loader
operator|->
name|ins_pos
operator|=
name|ins_pos
expr_stmt|;
if|if
condition|(
name|IS_HINTED
argument_list|(
name|loader
operator|->
name|load_flags
argument_list|)
operator|&&
ifdef|#
directive|ifdef
name|TT_USE_BYTECODE_INTERPRETER
name|subglyph
operator|->
name|flags
operator|&
name|WE_HAVE_INSTR
operator|&&
endif|#
directive|endif
name|num_points
operator|>
name|start_point
condition|)
name|TT_Process_Composite_Glyph
argument_list|(
name|loader
argument_list|,
name|start_point
argument_list|,
name|start_contour
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* invalid composite count (negative but not -1) */
name|error
operator|=
name|TT_Err_Invalid_Outline
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/***********************************************************************/
comment|/***********************************************************************/
comment|/***********************************************************************/
name|Exit
label|:
if|if
condition|(
name|opened_frame
condition|)
name|face
operator|->
name|forget_glyph_frame
argument_list|(
name|loader
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FT_CONFIG_OPTION_INCREMENTAL
if|if
condition|(
name|glyph_data_loaded
condition|)
name|face
operator|->
name|root
operator|.
name|internal
operator|->
name|incremental_interface
operator|->
name|funcs
operator|->
name|free_glyph_data
argument_list|(
name|face
operator|->
name|root
operator|.
name|internal
operator|->
name|incremental_interface
operator|->
name|object
argument_list|,
operator|&
name|glyph_data
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|error
return|;
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|compute_glyph_metrics
name|compute_glyph_metrics
parameter_list|(
name|TT_Loader
name|loader
parameter_list|,
name|FT_UInt
name|glyph_index
parameter_list|)
block|{
name|FT_BBox
name|bbox
decl_stmt|;
name|TT_Face
name|face
init|=
operator|(
name|TT_Face
operator|)
name|loader
operator|->
name|face
decl_stmt|;
name|FT_Fixed
name|y_scale
decl_stmt|;
name|TT_GlyphSlot
name|glyph
init|=
name|loader
operator|->
name|glyph
decl_stmt|;
name|TT_Size
name|size
init|=
operator|(
name|TT_Size
operator|)
name|loader
operator|->
name|size
decl_stmt|;
name|y_scale
operator|=
literal|0x10000L
expr_stmt|;
if|if
condition|(
operator|(
name|loader
operator|->
name|load_flags
operator|&
name|FT_LOAD_NO_SCALE
operator|)
operator|==
literal|0
condition|)
name|y_scale
operator|=
name|size
operator|->
name|root
operator|.
name|metrics
operator|.
name|y_scale
expr_stmt|;
if|if
condition|(
name|glyph
operator|->
name|format
operator|!=
name|FT_GLYPH_FORMAT_COMPOSITE
condition|)
name|FT_Outline_Get_CBox
argument_list|(
operator|&
name|glyph
operator|->
name|outline
argument_list|,
operator|&
name|bbox
argument_list|)
expr_stmt|;
else|else
name|bbox
operator|=
name|loader
operator|->
name|bbox
expr_stmt|;
comment|/* get the device-independent horizontal advance; it is scaled later */
comment|/* by the base layer.                                                */
block|{
name|FT_Pos
name|advance
init|=
name|loader
operator|->
name|linear
decl_stmt|;
comment|/* the flag FT_LOAD_IGNORE_GLOBAL_ADVANCE_WIDTH was introduced to */
comment|/* correctly support DynaLab fonts, which have an incorrect       */
comment|/* `advance_Width_Max' field!  It is used, to my knowledge,       */
comment|/* exclusively in the X-TrueType font server.                     */
comment|/*                                                                */
if|if
condition|(
name|face
operator|->
name|postscript
operator|.
name|isFixedPitch
operator|&&
operator|(
name|loader
operator|->
name|load_flags
operator|&
name|FT_LOAD_IGNORE_GLOBAL_ADVANCE_WIDTH
operator|)
operator|==
literal|0
condition|)
name|advance
operator|=
name|face
operator|->
name|horizontal
operator|.
name|advance_Width_Max
expr_stmt|;
comment|/* we need to return the advance in font units in linearHoriAdvance, */
comment|/* it will be scaled later by the base layer.                        */
name|glyph
operator|->
name|linearHoriAdvance
operator|=
name|advance
expr_stmt|;
block|}
name|glyph
operator|->
name|metrics
operator|.
name|horiBearingX
operator|=
name|bbox
operator|.
name|xMin
expr_stmt|;
name|glyph
operator|->
name|metrics
operator|.
name|horiBearingY
operator|=
name|bbox
operator|.
name|yMax
expr_stmt|;
name|glyph
operator|->
name|metrics
operator|.
name|horiAdvance
operator|=
name|loader
operator|->
name|pp2
operator|.
name|x
operator|-
name|loader
operator|->
name|pp1
operator|.
name|x
expr_stmt|;
comment|/* adjust advance width to the value contained in the hdmx table */
if|if
condition|(
operator|!
name|face
operator|->
name|postscript
operator|.
name|isFixedPitch
operator|&&
name|IS_HINTED
argument_list|(
name|loader
operator|->
name|load_flags
argument_list|)
condition|)
block|{
name|FT_Byte
modifier|*
name|widthp
decl_stmt|;
name|widthp
operator|=
name|tt_face_get_device_metrics
argument_list|(
name|face
argument_list|,
name|size
operator|->
name|root
operator|.
name|metrics
operator|.
name|x_ppem
argument_list|,
name|glyph_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|widthp
condition|)
name|glyph
operator|->
name|metrics
operator|.
name|horiAdvance
operator|=
operator|*
name|widthp
operator|<<
literal|6
expr_stmt|;
block|}
comment|/* set glyph dimensions */
name|glyph
operator|->
name|metrics
operator|.
name|width
operator|=
name|bbox
operator|.
name|xMax
operator|-
name|bbox
operator|.
name|xMin
expr_stmt|;
name|glyph
operator|->
name|metrics
operator|.
name|height
operator|=
name|bbox
operator|.
name|yMax
operator|-
name|bbox
operator|.
name|yMin
expr_stmt|;
comment|/* Now take care of vertical metrics.  In the case where there is */
comment|/* no vertical information within the font (relatively common),   */
comment|/* create some metrics manually                                   */
block|{
name|FT_Pos
name|top
decl_stmt|;
comment|/* scaled vertical top side bearing  */
name|FT_Pos
name|advance
decl_stmt|;
comment|/* scaled vertical advance height    */
comment|/* Get the unscaled top bearing and advance height. */
if|if
condition|(
name|face
operator|->
name|vertical_info
operator|&&
name|face
operator|->
name|vertical
operator|.
name|number_Of_VMetrics
operator|>
literal|0
condition|)
block|{
name|top
operator|=
operator|(
name|FT_Short
operator|)
name|FT_DivFix
argument_list|(
name|loader
operator|->
name|pp3
operator|.
name|y
operator|-
name|bbox
operator|.
name|yMax
argument_list|,
name|y_scale
argument_list|)
expr_stmt|;
if|if
condition|(
name|loader
operator|->
name|pp3
operator|.
name|y
operator|<=
name|loader
operator|->
name|pp4
operator|.
name|y
condition|)
name|advance
operator|=
literal|0
expr_stmt|;
else|else
name|advance
operator|=
operator|(
name|FT_UShort
operator|)
name|FT_DivFix
argument_list|(
name|loader
operator|->
name|pp3
operator|.
name|y
operator|-
name|loader
operator|->
name|pp4
operator|.
name|y
argument_list|,
name|y_scale
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|FT_Pos
name|height
decl_stmt|;
comment|/* XXX Compute top side bearing and advance height in  */
comment|/*     Get_VMetrics instead of here.                   */
comment|/* NOTE: The OS/2 values are the only `portable' ones, */
comment|/*       which is why we use them, if there is an OS/2 */
comment|/*       table in the font.  Otherwise, we use the     */
comment|/*       values defined in the horizontal header.      */
name|height
operator|=
operator|(
name|FT_Short
operator|)
name|FT_DivFix
argument_list|(
name|bbox
operator|.
name|yMax
operator|-
name|bbox
operator|.
name|yMin
argument_list|,
name|y_scale
argument_list|)
expr_stmt|;
if|if
condition|(
name|face
operator|->
name|os2
operator|.
name|version
operator|!=
literal|0xFFFFU
condition|)
name|advance
operator|=
call|(
name|FT_Pos
call|)
argument_list|(
name|face
operator|->
name|os2
operator|.
name|sTypoAscender
operator|-
name|face
operator|->
name|os2
operator|.
name|sTypoDescender
argument_list|)
expr_stmt|;
else|else
name|advance
operator|=
call|(
name|FT_Pos
call|)
argument_list|(
name|face
operator|->
name|horizontal
operator|.
name|Ascender
operator|-
name|face
operator|->
name|horizontal
operator|.
name|Descender
argument_list|)
expr_stmt|;
name|top
operator|=
operator|(
name|advance
operator|-
name|height
operator|)
operator|/
literal|2
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|FT_CONFIG_OPTION_INCREMENTAL
block|{
name|FT_Incremental_InterfaceRec
modifier|*
name|incr
decl_stmt|;
name|FT_Incremental_MetricsRec
name|metrics
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|incr
operator|=
name|face
operator|->
name|root
operator|.
name|internal
operator|->
name|incremental_interface
expr_stmt|;
comment|/* If this is an incrementally loaded font see if there are */
comment|/* overriding metrics for this glyph.                       */
if|if
condition|(
name|incr
operator|&&
name|incr
operator|->
name|funcs
operator|->
name|get_glyph_metrics
condition|)
block|{
name|metrics
operator|.
name|bearing_x
operator|=
literal|0
expr_stmt|;
name|metrics
operator|.
name|bearing_y
operator|=
name|top
expr_stmt|;
name|metrics
operator|.
name|advance
operator|=
name|advance
expr_stmt|;
name|error
operator|=
name|incr
operator|->
name|funcs
operator|->
name|get_glyph_metrics
argument_list|(
name|incr
operator|->
name|object
argument_list|,
name|glyph_index
argument_list|,
name|TRUE
argument_list|,
operator|&
name|metrics
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|top
operator|=
name|metrics
operator|.
name|bearing_y
expr_stmt|;
name|advance
operator|=
name|metrics
operator|.
name|advance
expr_stmt|;
block|}
block|}
comment|/* GWW: Do vertical metrics get loaded incrementally too? */
endif|#
directive|endif
comment|/* FT_CONFIG_OPTION_INCREMENTAL */
name|glyph
operator|->
name|linearVertAdvance
operator|=
name|advance
expr_stmt|;
comment|/* scale the metrics */
if|if
condition|(
operator|!
operator|(
name|loader
operator|->
name|load_flags
operator|&
name|FT_LOAD_NO_SCALE
operator|)
condition|)
block|{
name|top
operator|=
name|FT_MulFix
argument_list|(
name|top
argument_list|,
name|y_scale
argument_list|)
expr_stmt|;
name|advance
operator|=
name|FT_MulFix
argument_list|(
name|advance
argument_list|,
name|y_scale
argument_list|)
expr_stmt|;
block|}
comment|/* XXX: for now, we have no better algorithm for the lsb, but it */
comment|/*      should work fine.                                        */
comment|/*                                                               */
name|glyph
operator|->
name|metrics
operator|.
name|vertBearingX
operator|=
name|glyph
operator|->
name|metrics
operator|.
name|horiBearingX
operator|-
name|glyph
operator|->
name|metrics
operator|.
name|horiAdvance
operator|/
literal|2
expr_stmt|;
name|glyph
operator|->
name|metrics
operator|.
name|vertBearingY
operator|=
name|top
expr_stmt|;
name|glyph
operator|->
name|metrics
operator|.
name|vertAdvance
operator|=
name|advance
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_EMBEDDED_BITMAPS
end_ifdef
begin_function
specifier|static
name|FT_Error
DECL|function|load_sbit_image
name|load_sbit_image
parameter_list|(
name|TT_Size
name|size
parameter_list|,
name|TT_GlyphSlot
name|glyph
parameter_list|,
name|FT_UInt
name|glyph_index
parameter_list|,
name|FT_Int32
name|load_flags
parameter_list|)
block|{
name|TT_Face
name|face
decl_stmt|;
name|SFNT_Service
name|sfnt
decl_stmt|;
name|FT_Stream
name|stream
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|TT_SBit_MetricsRec
name|metrics
decl_stmt|;
name|face
operator|=
operator|(
name|TT_Face
operator|)
name|glyph
operator|->
name|face
expr_stmt|;
name|sfnt
operator|=
operator|(
name|SFNT_Service
operator|)
name|face
operator|->
name|sfnt
expr_stmt|;
name|stream
operator|=
name|face
operator|->
name|root
operator|.
name|stream
expr_stmt|;
name|error
operator|=
name|sfnt
operator|->
name|load_sbit_image
argument_list|(
name|face
argument_list|,
name|size
operator|->
name|strike_index
argument_list|,
name|glyph_index
argument_list|,
operator|(
name|FT_Int
operator|)
name|load_flags
argument_list|,
name|stream
argument_list|,
operator|&
name|glyph
operator|->
name|bitmap
argument_list|,
operator|&
name|metrics
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|glyph
operator|->
name|outline
operator|.
name|n_points
operator|=
literal|0
expr_stmt|;
name|glyph
operator|->
name|outline
operator|.
name|n_contours
operator|=
literal|0
expr_stmt|;
name|glyph
operator|->
name|metrics
operator|.
name|width
operator|=
operator|(
name|FT_Pos
operator|)
name|metrics
operator|.
name|width
operator|<<
literal|6
expr_stmt|;
name|glyph
operator|->
name|metrics
operator|.
name|height
operator|=
operator|(
name|FT_Pos
operator|)
name|metrics
operator|.
name|height
operator|<<
literal|6
expr_stmt|;
name|glyph
operator|->
name|metrics
operator|.
name|horiBearingX
operator|=
operator|(
name|FT_Pos
operator|)
name|metrics
operator|.
name|horiBearingX
operator|<<
literal|6
expr_stmt|;
name|glyph
operator|->
name|metrics
operator|.
name|horiBearingY
operator|=
operator|(
name|FT_Pos
operator|)
name|metrics
operator|.
name|horiBearingY
operator|<<
literal|6
expr_stmt|;
name|glyph
operator|->
name|metrics
operator|.
name|horiAdvance
operator|=
operator|(
name|FT_Pos
operator|)
name|metrics
operator|.
name|horiAdvance
operator|<<
literal|6
expr_stmt|;
name|glyph
operator|->
name|metrics
operator|.
name|vertBearingX
operator|=
operator|(
name|FT_Pos
operator|)
name|metrics
operator|.
name|vertBearingX
operator|<<
literal|6
expr_stmt|;
name|glyph
operator|->
name|metrics
operator|.
name|vertBearingY
operator|=
operator|(
name|FT_Pos
operator|)
name|metrics
operator|.
name|vertBearingY
operator|<<
literal|6
expr_stmt|;
name|glyph
operator|->
name|metrics
operator|.
name|vertAdvance
operator|=
operator|(
name|FT_Pos
operator|)
name|metrics
operator|.
name|vertAdvance
operator|<<
literal|6
expr_stmt|;
name|glyph
operator|->
name|format
operator|=
name|FT_GLYPH_FORMAT_BITMAP
expr_stmt|;
if|if
condition|(
name|load_flags
operator|&
name|FT_LOAD_VERTICAL_LAYOUT
condition|)
block|{
name|glyph
operator|->
name|bitmap_left
operator|=
name|metrics
operator|.
name|vertBearingX
expr_stmt|;
name|glyph
operator|->
name|bitmap_top
operator|=
name|metrics
operator|.
name|vertBearingY
expr_stmt|;
block|}
else|else
block|{
name|glyph
operator|->
name|bitmap_left
operator|=
name|metrics
operator|.
name|horiBearingX
expr_stmt|;
name|glyph
operator|->
name|bitmap_top
operator|=
name|metrics
operator|.
name|horiBearingY
expr_stmt|;
block|}
block|}
return|return
name|error
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* TT_CONFIG_OPTION_EMBEDDED_BITMAPS */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|tt_loader_init
name|tt_loader_init
parameter_list|(
name|TT_Loader
name|loader
parameter_list|,
name|TT_Size
name|size
parameter_list|,
name|TT_GlyphSlot
name|glyph
parameter_list|,
name|FT_Int32
name|load_flags
parameter_list|,
name|FT_Bool
name|glyf_table_only
parameter_list|)
block|{
name|TT_Face
name|face
decl_stmt|;
name|FT_Stream
name|stream
decl_stmt|;
name|face
operator|=
operator|(
name|TT_Face
operator|)
name|glyph
operator|->
name|face
expr_stmt|;
name|stream
operator|=
name|face
operator|->
name|root
operator|.
name|stream
expr_stmt|;
name|FT_MEM_ZERO
argument_list|(
name|loader
argument_list|,
sizeof|sizeof
argument_list|(
name|TT_LoaderRec
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TT_USE_BYTECODE_INTERPRETER
comment|/* load execution context */
if|if
condition|(
name|IS_HINTED
argument_list|(
name|load_flags
argument_list|)
operator|&&
operator|!
name|glyf_table_only
condition|)
block|{
name|TT_ExecContext
name|exec
decl_stmt|;
name|FT_Bool
name|grayscale
decl_stmt|;
if|if
condition|(
operator|!
name|size
operator|->
name|cvt_ready
condition|)
block|{
name|FT_Error
name|error
init|=
name|tt_size_ready_bytecode
argument_list|(
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
block|}
comment|/* query new execution context */
name|exec
operator|=
name|size
operator|->
name|debug
condition|?
name|size
operator|->
name|context
else|:
operator|(
operator|(
name|TT_Driver
operator|)
name|FT_FACE_DRIVER
argument_list|(
name|face
argument_list|)
operator|)
operator|->
name|context
expr_stmt|;
if|if
condition|(
operator|!
name|exec
condition|)
return|return
name|TT_Err_Could_Not_Find_Context
return|;
name|grayscale
operator|=
name|FT_BOOL
argument_list|(
name|FT_LOAD_TARGET_MODE
argument_list|(
name|load_flags
argument_list|)
operator|!=
name|FT_RENDER_MODE_MONO
argument_list|)
expr_stmt|;
name|TT_Load_Context
argument_list|(
name|exec
argument_list|,
name|face
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* a change from mono to grayscale rendering (and vice versa) */
comment|/* requires a re-execution of the CVT program                 */
if|if
condition|(
name|grayscale
operator|!=
name|exec
operator|->
name|grayscale
condition|)
block|{
name|FT_UInt
name|i
decl_stmt|;
name|exec
operator|->
name|grayscale
operator|=
name|grayscale
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
operator|->
name|cvt_size
condition|;
name|i
operator|++
control|)
name|size
operator|->
name|cvt
index|[
name|i
index|]
operator|=
name|FT_MulFix
argument_list|(
name|face
operator|->
name|cvt
index|[
name|i
index|]
argument_list|,
name|size
operator|->
name|ttmetrics
operator|.
name|scale
argument_list|)
expr_stmt|;
name|tt_size_run_prep
argument_list|(
name|size
argument_list|)
expr_stmt|;
block|}
comment|/* see whether the cvt program has disabled hinting */
if|if
condition|(
name|exec
operator|->
name|GS
operator|.
name|instruct_control
operator|&
literal|1
condition|)
name|load_flags
operator||=
name|FT_LOAD_NO_HINTING
expr_stmt|;
comment|/* load default graphics state -- if needed */
if|if
condition|(
name|exec
operator|->
name|GS
operator|.
name|instruct_control
operator|&
literal|2
condition|)
name|exec
operator|->
name|GS
operator|=
name|tt_default_graphics_state
expr_stmt|;
name|exec
operator|->
name|pedantic_hinting
operator|=
name|FT_BOOL
argument_list|(
name|load_flags
operator|&
name|FT_LOAD_PEDANTIC
argument_list|)
expr_stmt|;
name|loader
operator|->
name|exec
operator|=
name|exec
expr_stmt|;
name|loader
operator|->
name|instructions
operator|=
name|exec
operator|->
name|glyphIns
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* TT_USE_BYTECODE_INTERPRETER */
comment|/* seek to the beginning of the glyph table -- for Type 42 fonts     */
comment|/* the table might be accessed from a Postscript stream or something */
comment|/* else...                                                           */
ifdef|#
directive|ifdef
name|FT_CONFIG_OPTION_INCREMENTAL
if|if
condition|(
name|face
operator|->
name|root
operator|.
name|internal
operator|->
name|incremental_interface
condition|)
name|loader
operator|->
name|glyf_offset
operator|=
literal|0
expr_stmt|;
else|else
endif|#
directive|endif
block|{
name|FT_Error
name|error
init|=
name|face
operator|->
name|goto_table
argument_list|(
name|face
argument_list|,
name|TTAG_glyf
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|==
name|TT_Err_Table_Missing
condition|)
name|loader
operator|->
name|glyf_offset
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|error
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"tt_loader_init: could not access glyph table\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
else|else
name|loader
operator|->
name|glyf_offset
operator|=
name|FT_STREAM_POS
argument_list|()
expr_stmt|;
block|}
comment|/* get face's glyph loader */
if|if
condition|(
operator|!
name|glyf_table_only
condition|)
block|{
name|FT_GlyphLoader
name|gloader
init|=
name|glyph
operator|->
name|internal
operator|->
name|loader
decl_stmt|;
name|FT_GlyphLoader_Rewind
argument_list|(
name|gloader
argument_list|)
expr_stmt|;
name|loader
operator|->
name|gloader
operator|=
name|gloader
expr_stmt|;
block|}
name|loader
operator|->
name|load_flags
operator|=
name|load_flags
expr_stmt|;
name|loader
operator|->
name|face
operator|=
operator|(
name|FT_Face
operator|)
name|face
expr_stmt|;
name|loader
operator|->
name|size
operator|=
operator|(
name|FT_Size
operator|)
name|size
expr_stmt|;
name|loader
operator|->
name|glyph
operator|=
operator|(
name|FT_GlyphSlot
operator|)
name|glyph
expr_stmt|;
name|loader
operator|->
name|stream
operator|=
name|stream
expr_stmt|;
return|return
name|TT_Err_Ok
return|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    TT_Load_Glyph                                                      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    A function used to load a single glyph within a given glyph slot,  */
end_comment
begin_comment
comment|/*    for a given size.                                                  */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    glyph       :: A handle to a target slot object where the glyph    */
end_comment
begin_comment
comment|/*                   will be loaded.                                     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    size        :: A handle to the source face size at which the glyph */
end_comment
begin_comment
comment|/*                   must be scaled/loaded.                              */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    glyph_index :: The index of the glyph in the font file.            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    load_flags  :: A flag indicating what to load for this glyph.  The */
end_comment
begin_comment
comment|/*                   FT_LOAD_XXX constants can be used to control the    */
end_comment
begin_comment
comment|/*                   glyph loading process (e.g., whether the outline    */
end_comment
begin_comment
comment|/*                   should be scaled, whether to load bitmaps or not,   */
end_comment
begin_comment
comment|/*                   whether to hint the outline, etc).                  */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    FreeType error code.  0 means success.                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|TT_Load_Glyph
argument_list|(
argument|TT_Size       size
argument_list|,
argument|TT_GlyphSlot  glyph
argument_list|,
argument|FT_UInt       glyph_index
argument_list|,
argument|FT_Int32      load_flags
argument_list|)
end_macro
begin_block
block|{
name|TT_Face
name|face
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|TT_LoaderRec
name|loader
decl_stmt|;
name|face
operator|=
operator|(
name|TT_Face
operator|)
name|glyph
operator|->
name|face
expr_stmt|;
name|error
operator|=
name|TT_Err_Ok
expr_stmt|;
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_EMBEDDED_BITMAPS
comment|/* try to load embedded bitmap if any              */
comment|/*                                                 */
comment|/* XXX: The convention should be emphasized in     */
comment|/*      the documents because it can be confusing. */
if|if
condition|(
name|size
operator|->
name|strike_index
operator|!=
literal|0xFFFFFFFFUL
operator|&&
operator|(
name|load_flags
operator|&
name|FT_LOAD_NO_BITMAP
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|load_sbit_image
argument_list|(
name|size
argument_list|,
name|glyph
argument_list|,
name|glyph_index
argument_list|,
name|load_flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|FT_Face
name|root
init|=
operator|&
name|face
operator|->
name|root
decl_stmt|;
if|if
condition|(
name|FT_IS_SCALABLE
argument_list|(
name|root
argument_list|)
condition|)
block|{
comment|/* for the bbox we need the header only */
operator|(
name|void
operator|)
name|tt_loader_init
argument_list|(
operator|&
name|loader
argument_list|,
name|size
argument_list|,
name|glyph
argument_list|,
name|load_flags
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|load_truetype_glyph
argument_list|(
operator|&
name|loader
argument_list|,
name|glyph_index
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|glyph
operator|->
name|linearHoriAdvance
operator|=
name|loader
operator|.
name|linear
expr_stmt|;
name|glyph
operator|->
name|linearVertAdvance
operator|=
name|loader
operator|.
name|top_bearing
operator|+
name|loader
operator|.
name|bbox
operator|.
name|yMax
operator|-
name|loader
operator|.
name|vadvance
expr_stmt|;
if|if
condition|(
name|face
operator|->
name|postscript
operator|.
name|isFixedPitch
operator|&&
operator|(
name|load_flags
operator|&
name|FT_LOAD_IGNORE_GLOBAL_ADVANCE_WIDTH
operator|)
operator|==
literal|0
condition|)
name|glyph
operator|->
name|linearHoriAdvance
operator|=
name|face
operator|->
name|horizontal
operator|.
name|advance_Width_Max
expr_stmt|;
block|}
return|return
name|TT_Err_Ok
return|;
block|}
block|}
endif|#
directive|endif
comment|/* TT_CONFIG_OPTION_EMBEDDED_BITMAPS */
comment|/* if FT_LOAD_NO_SCALE is not set, `ttmetrics' must be valid */
if|if
condition|(
operator|!
operator|(
name|load_flags
operator|&
name|FT_LOAD_NO_SCALE
operator|)
operator|&&
operator|!
name|size
operator|->
name|ttmetrics
operator|.
name|valid
condition|)
return|return
name|TT_Err_Invalid_Size_Handle
return|;
if|if
condition|(
name|load_flags
operator|&
name|FT_LOAD_SBITS_ONLY
condition|)
return|return
name|TT_Err_Invalid_Argument
return|;
name|error
operator|=
name|tt_loader_init
argument_list|(
operator|&
name|loader
argument_list|,
name|size
argument_list|,
name|glyph
argument_list|,
name|load_flags
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|glyph
operator|->
name|format
operator|=
name|FT_GLYPH_FORMAT_OUTLINE
expr_stmt|;
name|glyph
operator|->
name|num_subglyphs
operator|=
literal|0
expr_stmt|;
name|glyph
operator|->
name|outline
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
comment|/* main loading loop */
name|error
operator|=
name|load_truetype_glyph
argument_list|(
operator|&
name|loader
argument_list|,
name|glyph_index
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
if|if
condition|(
name|glyph
operator|->
name|format
operator|==
name|FT_GLYPH_FORMAT_COMPOSITE
condition|)
block|{
name|glyph
operator|->
name|num_subglyphs
operator|=
name|loader
operator|.
name|gloader
operator|->
name|base
operator|.
name|num_subglyphs
expr_stmt|;
name|glyph
operator|->
name|subglyphs
operator|=
name|loader
operator|.
name|gloader
operator|->
name|base
operator|.
name|subglyphs
expr_stmt|;
block|}
else|else
block|{
name|glyph
operator|->
name|outline
operator|=
name|loader
operator|.
name|gloader
operator|->
name|base
operator|.
name|outline
expr_stmt|;
name|glyph
operator|->
name|outline
operator|.
name|flags
operator|&=
operator|~
name|FT_OUTLINE_SINGLE_PASS
expr_stmt|;
comment|/* In case bit 1 of the `flags' field in the `head' table isn't */
comment|/* set, translate array so that (0,0) is the glyph's origin.    */
if|if
condition|(
operator|(
name|face
operator|->
name|header
operator|.
name|Flags
operator|&
literal|2
operator|)
operator|==
literal|0
operator|&&
name|loader
operator|.
name|pp1
operator|.
name|x
condition|)
name|FT_Outline_Translate
argument_list|(
operator|&
name|glyph
operator|->
name|outline
argument_list|,
operator|-
name|loader
operator|.
name|pp1
operator|.
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TT_USE_BYTECODE_INTERPRETER
if|if
condition|(
name|IS_HINTED
argument_list|(
name|load_flags
argument_list|)
condition|)
block|{
if|if
condition|(
name|loader
operator|.
name|exec
operator|->
name|GS
operator|.
name|scan_control
condition|)
block|{
comment|/* convert scan conversion mode to FT_OUTLINE_XXX flags */
switch|switch
condition|(
name|loader
operator|.
name|exec
operator|->
name|GS
operator|.
name|scan_type
condition|)
block|{
case|case
literal|0
case|:
comment|/* simple drop-outs including stubs */
name|glyph
operator|->
name|outline
operator|.
name|flags
operator||=
name|FT_OUTLINE_INCLUDE_STUBS
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* simple drop-outs excluding stubs */
comment|/* nothing; it's the default rendering mode */
break|break;
case|case
literal|4
case|:
comment|/* smart drop-outs including stubs */
name|glyph
operator|->
name|outline
operator|.
name|flags
operator||=
name|FT_OUTLINE_SMART_DROPOUTS
operator||
name|FT_OUTLINE_INCLUDE_STUBS
expr_stmt|;
break|break;
case|case
literal|5
case|:
comment|/* smart drop-outs excluding stubs  */
name|glyph
operator|->
name|outline
operator|.
name|flags
operator||=
name|FT_OUTLINE_SMART_DROPOUTS
expr_stmt|;
break|break;
default|default:
comment|/* no drop-out control */
name|glyph
operator|->
name|outline
operator|.
name|flags
operator||=
name|FT_OUTLINE_IGNORE_DROPOUTS
expr_stmt|;
break|break;
block|}
block|}
else|else
name|glyph
operator|->
name|outline
operator|.
name|flags
operator||=
name|FT_OUTLINE_IGNORE_DROPOUTS
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* TT_USE_BYTECODE_INTERPRETER */
name|compute_glyph_metrics
argument_list|(
operator|&
name|loader
argument_list|,
name|glyph_index
argument_list|)
expr_stmt|;
block|}
comment|/* Set the `high precision' bit flag.                           */
comment|/* This is _critical_ to get correct output for monochrome      */
comment|/* TrueType glyphs at all sizes using the bytecode interpreter. */
comment|/*                                                              */
if|if
condition|(
operator|!
operator|(
name|load_flags
operator|&
name|FT_LOAD_NO_SCALE
operator|)
operator|&&
name|size
operator|->
name|root
operator|.
name|metrics
operator|.
name|y_ppem
operator|<
literal|24
condition|)
name|glyph
operator|->
name|outline
operator|.
name|flags
operator||=
name|FT_OUTLINE_HIGH_PRECISION
expr_stmt|;
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/* END */
end_comment
end_unit
