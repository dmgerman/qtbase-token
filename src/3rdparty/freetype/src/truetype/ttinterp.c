begin_unit
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  ttinterp.c                                                             */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*    TrueType bytecode interpreter (body).                                */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  Copyright 1996-2014                                                    */
end_comment
begin_comment
comment|/*  by David Turner, Robert Wilhelm, and Werner Lemberg.                   */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  This file is part of the FreeType project, and may only be used,       */
end_comment
begin_comment
comment|/*  modified, and distributed under the terms of the FreeType project      */
end_comment
begin_comment
comment|/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
end_comment
begin_comment
comment|/*  this file you indicate that you have read the license and              */
end_comment
begin_comment
comment|/*  understand and accept it fully.                                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/* Greg Hitchcock from Microsoft has helped a lot in resolving unclear */
end_comment
begin_comment
comment|/* issues; many thanks!                                                */
end_comment
begin_include
include|#
directive|include
file|<ft2build.h>
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_DEBUG_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_CALC_H
end_include
begin_include
include|#
directive|include
include|FT_TRIGONOMETRY_H
end_include
begin_include
include|#
directive|include
include|FT_SYSTEM_H
end_include
begin_include
include|#
directive|include
include|FT_TRUETYPE_DRIVER_H
end_include
begin_include
include|#
directive|include
file|"ttinterp.h"
end_include
begin_include
include|#
directive|include
file|"tterrors.h"
end_include
begin_include
include|#
directive|include
file|"ttsubpix.h"
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|TT_USE_BYTECODE_INTERPRETER
end_ifdef
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
end_comment
begin_comment
comment|/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
end_comment
begin_comment
comment|/* messages during execution.                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_undef
DECL|macro|FT_COMPONENT
undef|#
directive|undef
name|FT_COMPONENT
end_undef
begin_define
DECL|macro|FT_COMPONENT
define|#
directive|define
name|FT_COMPONENT
value|trace_ttinterp
end_define
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* In order to detect infinite loops in the code, we set up a counter    */
end_comment
begin_comment
comment|/* within the run loop.  A single stroke of interpretation is now        */
end_comment
begin_comment
comment|/* limited to a maximum number of opcodes defined below.                 */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_define
DECL|macro|MAX_RUNNABLE_OPCODES
define|#
directive|define
name|MAX_RUNNABLE_OPCODES
value|1000000L
end_define
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* There are two kinds of implementations:                               */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* a. static implementation                                              */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    The current execution context is a static variable, which fields   */
end_comment
begin_comment
comment|/*    are accessed directly by the interpreter during execution.  The    */
end_comment
begin_comment
comment|/*    context is named `cur'.                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    This version is non-reentrant, of course.                          */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* b. indirect implementation                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    The current execution context is passed to _each_ function as its  */
end_comment
begin_comment
comment|/*    first argument, and each field is thus accessed indirectly.        */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    This version is fully re-entrant.                                  */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* The idea is that an indirect implementation may be slower to execute  */
end_comment
begin_comment
comment|/* on low-end processors that are used in some systems (like 386s or     */
end_comment
begin_comment
comment|/* even 486s).                                                           */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* As a consequence, the indirect implementation is now the default, as  */
end_comment
begin_comment
comment|/* its performance costs can be considered negligible in our context.    */
end_comment
begin_comment
comment|/* Note, however, that we kept the same source with macros because:      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* - The code is kept very close in design to the Pascal code used for   */
end_comment
begin_comment
comment|/*   development.                                                        */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* - It's much more readable that way!                                   */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* - It's still open to experimentation and tuning.                      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|TT_CONFIG_OPTION_STATIC_INTERPRETER
end_ifndef
begin_comment
comment|/* indirect implementation */
end_comment
begin_define
DECL|macro|CUR
define|#
directive|define
name|CUR
value|(*exc)
end_define
begin_comment
DECL|macro|CUR
comment|/* see ttobjs.h */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* This macro is used whenever `exec' is unused in a function, to avoid  */
end_comment
begin_comment
comment|/* stupid warnings from pedantic compilers.                              */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_define
DECL|macro|FT_UNUSED_EXEC
define|#
directive|define
name|FT_UNUSED_EXEC
value|FT_UNUSED( exc )
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* static implementation */
end_comment
begin_define
DECL|macro|CUR
define|#
directive|define
name|CUR
value|cur
end_define
begin_define
DECL|macro|FT_UNUSED_EXEC
define|#
directive|define
name|FT_UNUSED_EXEC
value|int  __dummy = __dummy
end_define
begin_decl_stmt
specifier|static
DECL|variable|cur
name|TT_ExecContextRec
name|cur
decl_stmt|;
end_decl_stmt
begin_comment
DECL|variable|cur
comment|/* static exec. context variable */
end_comment
begin_comment
comment|/* apparently, we have a _lot_ of direct indexing when accessing  */
end_comment
begin_comment
comment|/* the static `cur', which makes the code bigger (due to all the  */
end_comment
begin_comment
comment|/* four bytes addresses).                                         */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* TT_CONFIG_OPTION_STATIC_INTERPRETER */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* The instruction argument stack.                                       */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_define
DECL|macro|INS_ARG
define|#
directive|define
name|INS_ARG
value|EXEC_OP_ FT_Long*  args
end_define
begin_comment
DECL|macro|INS_ARG
comment|/* see ttobjs.h for EXEC_OP_ */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* This macro is used whenever `args' is unused in a function, to avoid  */
end_comment
begin_comment
comment|/* stupid warnings from pedantic compilers.                              */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_define
DECL|macro|FT_UNUSED_ARG
define|#
directive|define
name|FT_UNUSED_ARG
value|FT_UNUSED_EXEC; FT_UNUSED( args )
end_define
begin_define
DECL|macro|SUBPIXEL_HINTING
define|#
directive|define
name|SUBPIXEL_HINTING
define|\
value|( ((TT_Driver)FT_FACE_DRIVER( CUR.face ))->interpreter_version == \             TT_INTERPRETER_VERSION_38 )
end_define
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* The following macros hide the use of EXEC_ARG and EXEC_ARG_ to        */
end_comment
begin_comment
comment|/* increase readability of the code.                                     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_define
DECL|macro|SKIP_Code
define|#
directive|define
name|SKIP_Code
parameter_list|()
define|\
value|SkipCode( EXEC_ARG )
end_define
begin_define
DECL|macro|GET_ShortIns
define|#
directive|define
name|GET_ShortIns
parameter_list|()
define|\
value|GetShortIns( EXEC_ARG )
end_define
begin_define
DECL|macro|NORMalize
define|#
directive|define
name|NORMalize
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|v
parameter_list|)
define|\
value|Normalize( EXEC_ARG_ x, y, v )
end_define
begin_define
DECL|macro|SET_SuperRound
define|#
directive|define
name|SET_SuperRound
parameter_list|(
name|scale
parameter_list|,
name|flags
parameter_list|)
define|\
value|SetSuperRound( EXEC_ARG_ scale, flags )
end_define
begin_define
DECL|macro|ROUND_None
define|#
directive|define
name|ROUND_None
parameter_list|(
name|d
parameter_list|,
name|c
parameter_list|)
define|\
value|Round_None( EXEC_ARG_ d, c )
end_define
begin_define
DECL|macro|INS_Goto_CodeRange
define|#
directive|define
name|INS_Goto_CodeRange
parameter_list|(
name|range
parameter_list|,
name|ip
parameter_list|)
define|\
value|Ins_Goto_CodeRange( EXEC_ARG_ range, ip )
end_define
begin_define
DECL|macro|CUR_Func_move
define|#
directive|define
name|CUR_Func_move
parameter_list|(
name|z
parameter_list|,
name|p
parameter_list|,
name|d
parameter_list|)
define|\
value|CUR.func_move( EXEC_ARG_ z, p, d )
end_define
begin_define
DECL|macro|CUR_Func_move_orig
define|#
directive|define
name|CUR_Func_move_orig
parameter_list|(
name|z
parameter_list|,
name|p
parameter_list|,
name|d
parameter_list|)
define|\
value|CUR.func_move_orig( EXEC_ARG_ z, p, d )
end_define
begin_define
DECL|macro|CUR_Func_round
define|#
directive|define
name|CUR_Func_round
parameter_list|(
name|d
parameter_list|,
name|c
parameter_list|)
define|\
value|CUR.func_round( EXEC_ARG_ d, c )
end_define
begin_define
DECL|macro|CUR_Func_cur_ppem
define|#
directive|define
name|CUR_Func_cur_ppem
parameter_list|()
define|\
value|CUR.func_cur_ppem( EXEC_ARG )
end_define
begin_define
DECL|macro|CUR_Func_read_cvt
define|#
directive|define
name|CUR_Func_read_cvt
parameter_list|(
name|index
parameter_list|)
define|\
value|CUR.func_read_cvt( EXEC_ARG_ index )
end_define
begin_define
DECL|macro|CUR_Func_write_cvt
define|#
directive|define
name|CUR_Func_write_cvt
parameter_list|(
name|index
parameter_list|,
name|val
parameter_list|)
define|\
value|CUR.func_write_cvt( EXEC_ARG_ index, val )
end_define
begin_define
DECL|macro|CUR_Func_move_cvt
define|#
directive|define
name|CUR_Func_move_cvt
parameter_list|(
name|index
parameter_list|,
name|val
parameter_list|)
define|\
value|CUR.func_move_cvt( EXEC_ARG_ index, val )
end_define
begin_define
DECL|macro|CURRENT_Ratio
define|#
directive|define
name|CURRENT_Ratio
parameter_list|()
define|\
value|Current_Ratio( EXEC_ARG )
end_define
begin_define
DECL|macro|INS_SxVTL
define|#
directive|define
name|INS_SxVTL
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|)
define|\
value|Ins_SxVTL( EXEC_ARG_ a, b, c, d )
end_define
begin_define
DECL|macro|COMPUTE_Funcs
define|#
directive|define
name|COMPUTE_Funcs
parameter_list|()
define|\
value|Compute_Funcs( EXEC_ARG )
end_define
begin_define
DECL|macro|COMPUTE_Round
define|#
directive|define
name|COMPUTE_Round
parameter_list|(
name|a
parameter_list|)
define|\
value|Compute_Round( EXEC_ARG_ a )
end_define
begin_define
DECL|macro|COMPUTE_Point_Displacement
define|#
directive|define
name|COMPUTE_Point_Displacement
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|)
define|\
value|Compute_Point_Displacement( EXEC_ARG_ a, b, c, d )
end_define
begin_define
DECL|macro|MOVE_Zp2_Point
define|#
directive|define
name|MOVE_Zp2_Point
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|t
parameter_list|)
define|\
value|Move_Zp2_Point( EXEC_ARG_ a, b, c, t )
end_define
begin_define
DECL|macro|CUR_Func_project
define|#
directive|define
name|CUR_Func_project
parameter_list|(
name|v1
parameter_list|,
name|v2
parameter_list|)
define|\
value|CUR.func_project( EXEC_ARG_ (v1)->x - (v2)->x, (v1)->y - (v2)->y )
end_define
begin_define
DECL|macro|CUR_Func_dualproj
define|#
directive|define
name|CUR_Func_dualproj
parameter_list|(
name|v1
parameter_list|,
name|v2
parameter_list|)
define|\
value|CUR.func_dualproj( EXEC_ARG_ (v1)->x - (v2)->x, (v1)->y - (v2)->y )
end_define
begin_define
DECL|macro|CUR_fast_project
define|#
directive|define
name|CUR_fast_project
parameter_list|(
name|v
parameter_list|)
define|\
value|CUR.func_project( EXEC_ARG_ (v)->x, (v)->y )
end_define
begin_define
DECL|macro|CUR_fast_dualproj
define|#
directive|define
name|CUR_fast_dualproj
parameter_list|(
name|v
parameter_list|)
define|\
value|CUR.func_dualproj( EXEC_ARG_ (v)->x, (v)->y )
end_define
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* Instruction dispatch function, as used by the interpreter.            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_typedef
DECL|typedef|TInstruction_Function
typedef|typedef
name|void
function_decl|(
modifier|*
name|TInstruction_Function
function_decl|)
parameter_list|(
name|INS_ARG
parameter_list|)
function_decl|;
end_typedef
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* Two simple bounds-checking macros.                                    */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_define
DECL|macro|BOUNDS
define|#
directive|define
name|BOUNDS
parameter_list|(
name|x
parameter_list|,
name|n
parameter_list|)
value|( (FT_UInt)(x)>= (FT_UInt)(n)  )
end_define
begin_define
DECL|macro|BOUNDSL
define|#
directive|define
name|BOUNDSL
parameter_list|(
name|x
parameter_list|,
name|n
parameter_list|)
value|( (FT_ULong)(x)>= (FT_ULong)(n) )
end_define
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* This macro computes (a*2^14)/b and complements TT_MulFix14.           */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_define
DECL|macro|TT_DivFix14
define|#
directive|define
name|TT_DivFix14
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
define|\
value|FT_DivFix( a, (b)<< 2 )
end_define
begin_undef
DECL|macro|SUCCESS
undef|#
directive|undef
name|SUCCESS
end_undef
begin_define
DECL|macro|SUCCESS
define|#
directive|define
name|SUCCESS
value|0
end_define
begin_undef
DECL|macro|FAILURE
undef|#
directive|undef
name|FAILURE
end_undef
begin_define
DECL|macro|FAILURE
define|#
directive|define
name|FAILURE
value|1
end_define
begin_ifdef
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_UNPATENTED_HINTING
end_ifdef
begin_define
DECL|macro|GUESS_VECTOR
define|#
directive|define
name|GUESS_VECTOR
parameter_list|(
name|V
parameter_list|)
define|\
value|if ( CUR.face->unpatented_hinting )                             \   {                                                               \     CUR.GS.V.x = (FT_F2Dot14)( CUR.GS.both_x_axis ? 0x4000 : 0 ); \     CUR.GS.V.y = (FT_F2Dot14)( CUR.GS.both_x_axis ? 0 : 0x4000 ); \   }
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|GUESS_VECTOR
define|#
directive|define
name|GUESS_VECTOR
parameter_list|(
name|V
parameter_list|)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*                        CODERANGE FUNCTIONS                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    TT_Goto_CodeRange                                                  */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Switches to a new code range (updates the code related elements in */
end_comment
begin_comment
comment|/*    `exec', and `IP').                                                 */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    range :: The new execution code range.                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    IP    :: The new IP in the new code range.                         */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<InOut>                                                               */
end_comment
begin_comment
comment|/*    exec  :: The target execution context.                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|TT_Goto_CodeRange
name|TT_Goto_CodeRange
argument_list|(
argument|TT_ExecContext  exec
argument_list|,
argument|FT_Int          range
argument_list|,
argument|FT_Long         IP
argument_list|)
end_macro
begin_block
block|{
name|TT_CodeRange
modifier|*
name|coderange
decl_stmt|;
name|FT_ASSERT
argument_list|(
name|range
operator|>=
literal|1
operator|&&
name|range
operator|<=
literal|3
argument_list|)
expr_stmt|;
name|coderange
operator|=
operator|&
name|exec
operator|->
name|codeRangeTable
index|[
name|range
operator|-
literal|1
index|]
expr_stmt|;
name|FT_ASSERT
argument_list|(
name|coderange
operator|->
name|base
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* NOTE: Because the last instruction of a program may be a CALL */
comment|/*       which will return to the first byte *after* the code    */
comment|/*       range, we test for IP<= Size instead of IP< Size.     */
comment|/*                                                               */
name|FT_ASSERT
argument_list|(
operator|(
name|FT_ULong
operator|)
name|IP
operator|<=
name|coderange
operator|->
name|size
argument_list|)
expr_stmt|;
name|exec
operator|->
name|code
operator|=
name|coderange
operator|->
name|base
expr_stmt|;
name|exec
operator|->
name|codeSize
operator|=
name|coderange
operator|->
name|size
expr_stmt|;
name|exec
operator|->
name|IP
operator|=
name|IP
expr_stmt|;
name|exec
operator|->
name|curRange
operator|=
name|range
expr_stmt|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    TT_Set_CodeRange                                                   */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Sets a code range.                                                 */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    range  :: The code range index.                                    */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    base   :: The new code base.                                       */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    length :: The range size in bytes.                                 */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<InOut>                                                               */
end_comment
begin_comment
comment|/*    exec   :: The target execution context.                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|TT_Set_CodeRange
name|TT_Set_CodeRange
argument_list|(
argument|TT_ExecContext  exec
argument_list|,
argument|FT_Int          range
argument_list|,
argument|void*           base
argument_list|,
argument|FT_Long         length
argument_list|)
end_macro
begin_block
block|{
name|FT_ASSERT
argument_list|(
name|range
operator|>=
literal|1
operator|&&
name|range
operator|<=
literal|3
argument_list|)
expr_stmt|;
name|exec
operator|->
name|codeRangeTable
index|[
name|range
operator|-
literal|1
index|]
operator|.
name|base
operator|=
operator|(
name|FT_Byte
operator|*
operator|)
name|base
expr_stmt|;
name|exec
operator|->
name|codeRangeTable
index|[
name|range
operator|-
literal|1
index|]
operator|.
name|size
operator|=
name|length
expr_stmt|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    TT_Clear_CodeRange                                                 */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Clears a code range.                                               */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    range :: The code range index.                                     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<InOut>                                                               */
end_comment
begin_comment
comment|/*    exec  :: The target execution context.                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|TT_Clear_CodeRange
name|TT_Clear_CodeRange
argument_list|(
argument|TT_ExecContext  exec
argument_list|,
argument|FT_Int          range
argument_list|)
end_macro
begin_block
block|{
name|FT_ASSERT
argument_list|(
name|range
operator|>=
literal|1
operator|&&
name|range
operator|<=
literal|3
argument_list|)
expr_stmt|;
name|exec
operator|->
name|codeRangeTable
index|[
name|range
operator|-
literal|1
index|]
operator|.
name|base
operator|=
name|NULL
expr_stmt|;
name|exec
operator|->
name|codeRangeTable
index|[
name|range
operator|-
literal|1
index|]
operator|.
name|size
operator|=
literal|0
expr_stmt|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*                   EXECUTION CONTEXT ROUTINES                          */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    TT_Done_Context                                                    */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Destroys a given context.                                          */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    exec   :: A handle to the target execution context.                */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    memory :: A handle to the parent memory object.                    */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Note>                                                                */
end_comment
begin_comment
comment|/*    Only the glyph loader and debugger should call this function.      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|TT_Done_Context
name|TT_Done_Context
argument_list|(
argument|TT_ExecContext  exec
argument_list|)
end_macro
begin_block
block|{
name|FT_Memory
name|memory
init|=
name|exec
operator|->
name|memory
decl_stmt|;
comment|/* points zone */
name|exec
operator|->
name|maxPoints
operator|=
literal|0
expr_stmt|;
name|exec
operator|->
name|maxContours
operator|=
literal|0
expr_stmt|;
comment|/* free stack */
name|FT_FREE
argument_list|(
name|exec
operator|->
name|stack
argument_list|)
expr_stmt|;
name|exec
operator|->
name|stackSize
operator|=
literal|0
expr_stmt|;
comment|/* free call stack */
name|FT_FREE
argument_list|(
name|exec
operator|->
name|callStack
argument_list|)
expr_stmt|;
name|exec
operator|->
name|callSize
operator|=
literal|0
expr_stmt|;
name|exec
operator|->
name|callTop
operator|=
literal|0
expr_stmt|;
comment|/* free glyph code range */
name|FT_FREE
argument_list|(
name|exec
operator|->
name|glyphIns
argument_list|)
expr_stmt|;
name|exec
operator|->
name|glyphSize
operator|=
literal|0
expr_stmt|;
name|exec
operator|->
name|size
operator|=
name|NULL
expr_stmt|;
name|exec
operator|->
name|face
operator|=
name|NULL
expr_stmt|;
name|FT_FREE
argument_list|(
name|exec
argument_list|)
expr_stmt|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    Init_Context                                                       */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Initializes a context object.                                      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    memory :: A handle to the parent memory object.                    */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<InOut>                                                               */
end_comment
begin_comment
comment|/*    exec   :: A handle to the target execution context.                */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    FreeType error code.  0 means success.                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|Init_Context
name|Init_Context
parameter_list|(
name|TT_ExecContext
name|exec
parameter_list|,
name|FT_Memory
name|memory
parameter_list|)
block|{
name|FT_Error
name|error
decl_stmt|;
name|FT_TRACE1
argument_list|(
operator|(
literal|"Init_Context: new object at 0x%08p\n"
operator|,
name|exec
operator|)
argument_list|)
expr_stmt|;
name|exec
operator|->
name|memory
operator|=
name|memory
expr_stmt|;
name|exec
operator|->
name|callSize
operator|=
literal|32
expr_stmt|;
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|exec
operator|->
name|callStack
argument_list|,
name|exec
operator|->
name|callSize
argument_list|)
condition|)
goto|goto
name|Fail_Memory
goto|;
comment|/* all values in the context are set to 0 already, but this is */
comment|/* here as a remainder                                         */
name|exec
operator|->
name|maxPoints
operator|=
literal|0
expr_stmt|;
name|exec
operator|->
name|maxContours
operator|=
literal|0
expr_stmt|;
name|exec
operator|->
name|stackSize
operator|=
literal|0
expr_stmt|;
name|exec
operator|->
name|glyphSize
operator|=
literal|0
expr_stmt|;
name|exec
operator|->
name|stack
operator|=
name|NULL
expr_stmt|;
name|exec
operator|->
name|glyphIns
operator|=
name|NULL
expr_stmt|;
name|exec
operator|->
name|face
operator|=
name|NULL
expr_stmt|;
name|exec
operator|->
name|size
operator|=
name|NULL
expr_stmt|;
return|return
name|FT_Err_Ok
return|;
name|Fail_Memory
label|:
name|FT_ERROR
argument_list|(
operator|(
literal|"Init_Context: not enough memory for %p\n"
operator|,
name|exec
operator|)
argument_list|)
expr_stmt|;
name|TT_Done_Context
argument_list|(
name|exec
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    Update_Max                                                         */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Checks the size of a buffer and reallocates it if necessary.       */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    memory     :: A handle to the parent memory object.                */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    multiplier :: The size in bytes of each element in the buffer.     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    new_max    :: The new capacity (size) of the buffer.               */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<InOut>                                                               */
end_comment
begin_comment
comment|/*    size       :: The address of the buffer's current size expressed   */
end_comment
begin_comment
comment|/*                  in elements.                                         */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    buff       :: The address of the buffer base pointer.              */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    FreeType error code.  0 means success.                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|Update_Max
argument_list|(
argument|FT_Memory  memory
argument_list|,
argument|FT_ULong*  size
argument_list|,
argument|FT_Long    multiplier
argument_list|,
argument|void*      _pbuff
argument_list|,
argument|FT_ULong   new_max
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
decl_stmt|;
name|void
modifier|*
modifier|*
name|pbuff
init|=
operator|(
name|void
operator|*
operator|*
operator|)
name|_pbuff
decl_stmt|;
if|if
condition|(
operator|*
name|size
operator|<
name|new_max
condition|)
block|{
if|if
condition|(
name|FT_REALLOC
argument_list|(
operator|*
name|pbuff
argument_list|,
operator|*
name|size
operator|*
name|multiplier
argument_list|,
name|new_max
operator|*
name|multiplier
argument_list|)
condition|)
return|return
name|error
return|;
operator|*
name|size
operator|=
name|new_max
expr_stmt|;
block|}
return|return
name|FT_Err_Ok
return|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    TT_Load_Context                                                    */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Prepare an execution context for glyph hinting.                    */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    face :: A handle to the source face object.                        */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    size :: A handle to the source size object.                        */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<InOut>                                                               */
end_comment
begin_comment
comment|/*    exec :: A handle to the target execution context.                  */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    FreeType error code.  0 means success.                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Note>                                                                */
end_comment
begin_comment
comment|/*    Only the glyph loader and debugger should call this function.      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|TT_Load_Context
argument_list|(
argument|TT_ExecContext  exec
argument_list|,
argument|TT_Face         face
argument_list|,
argument|TT_Size         size
argument_list|)
end_macro
begin_block
block|{
name|FT_Int
name|i
decl_stmt|;
name|FT_ULong
name|tmp
decl_stmt|;
name|TT_MaxProfile
modifier|*
name|maxp
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|exec
operator|->
name|face
operator|=
name|face
expr_stmt|;
name|maxp
operator|=
operator|&
name|face
operator|->
name|max_profile
expr_stmt|;
name|exec
operator|->
name|size
operator|=
name|size
expr_stmt|;
if|if
condition|(
name|size
condition|)
block|{
name|exec
operator|->
name|numFDefs
operator|=
name|size
operator|->
name|num_function_defs
expr_stmt|;
name|exec
operator|->
name|maxFDefs
operator|=
name|size
operator|->
name|max_function_defs
expr_stmt|;
name|exec
operator|->
name|numIDefs
operator|=
name|size
operator|->
name|num_instruction_defs
expr_stmt|;
name|exec
operator|->
name|maxIDefs
operator|=
name|size
operator|->
name|max_instruction_defs
expr_stmt|;
name|exec
operator|->
name|FDefs
operator|=
name|size
operator|->
name|function_defs
expr_stmt|;
name|exec
operator|->
name|IDefs
operator|=
name|size
operator|->
name|instruction_defs
expr_stmt|;
name|exec
operator|->
name|tt_metrics
operator|=
name|size
operator|->
name|ttmetrics
expr_stmt|;
name|exec
operator|->
name|metrics
operator|=
name|size
operator|->
name|metrics
expr_stmt|;
name|exec
operator|->
name|maxFunc
operator|=
name|size
operator|->
name|max_func
expr_stmt|;
name|exec
operator|->
name|maxIns
operator|=
name|size
operator|->
name|max_ins
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TT_MAX_CODE_RANGES
condition|;
name|i
operator|++
control|)
name|exec
operator|->
name|codeRangeTable
index|[
name|i
index|]
operator|=
name|size
operator|->
name|codeRangeTable
index|[
name|i
index|]
expr_stmt|;
comment|/* set graphics state */
name|exec
operator|->
name|GS
operator|=
name|size
operator|->
name|GS
expr_stmt|;
name|exec
operator|->
name|cvtSize
operator|=
name|size
operator|->
name|cvt_size
expr_stmt|;
name|exec
operator|->
name|cvt
operator|=
name|size
operator|->
name|cvt
expr_stmt|;
name|exec
operator|->
name|storeSize
operator|=
name|size
operator|->
name|storage_size
expr_stmt|;
name|exec
operator|->
name|storage
operator|=
name|size
operator|->
name|storage
expr_stmt|;
name|exec
operator|->
name|twilight
operator|=
name|size
operator|->
name|twilight
expr_stmt|;
comment|/* In case of multi-threading it can happen that the old size object */
comment|/* no longer exists, thus we must clear all glyph zone references.   */
name|ft_memset
argument_list|(
operator|&
name|exec
operator|->
name|zp0
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|exec
operator|->
name|zp0
argument_list|)
argument_list|)
expr_stmt|;
name|exec
operator|->
name|zp1
operator|=
name|exec
operator|->
name|zp0
expr_stmt|;
name|exec
operator|->
name|zp2
operator|=
name|exec
operator|->
name|zp0
expr_stmt|;
block|}
comment|/* XXX: We reserve a little more elements on the stack to deal safely */
comment|/*      with broken fonts like arialbs, courbs, timesbs, etc.         */
name|tmp
operator|=
name|exec
operator|->
name|stackSize
expr_stmt|;
name|error
operator|=
name|Update_Max
argument_list|(
name|exec
operator|->
name|memory
argument_list|,
operator|&
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|FT_F26Dot6
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|exec
operator|->
name|stack
argument_list|,
name|maxp
operator|->
name|maxStackElements
operator|+
literal|32
argument_list|)
expr_stmt|;
name|exec
operator|->
name|stackSize
operator|=
operator|(
name|FT_UInt
operator|)
name|tmp
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|tmp
operator|=
name|exec
operator|->
name|glyphSize
expr_stmt|;
name|error
operator|=
name|Update_Max
argument_list|(
name|exec
operator|->
name|memory
argument_list|,
operator|&
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|FT_Byte
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|exec
operator|->
name|glyphIns
argument_list|,
name|maxp
operator|->
name|maxSizeOfInstructions
argument_list|)
expr_stmt|;
name|exec
operator|->
name|glyphSize
operator|=
operator|(
name|FT_UShort
operator|)
name|tmp
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|exec
operator|->
name|pts
operator|.
name|n_points
operator|=
literal|0
expr_stmt|;
name|exec
operator|->
name|pts
operator|.
name|n_contours
operator|=
literal|0
expr_stmt|;
name|exec
operator|->
name|zp1
operator|=
name|exec
operator|->
name|pts
expr_stmt|;
name|exec
operator|->
name|zp2
operator|=
name|exec
operator|->
name|pts
expr_stmt|;
name|exec
operator|->
name|zp0
operator|=
name|exec
operator|->
name|pts
expr_stmt|;
name|exec
operator|->
name|instruction_trap
operator|=
name|FALSE
expr_stmt|;
return|return
name|FT_Err_Ok
return|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    TT_Save_Context                                                    */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Saves the code ranges in a `size' object.                          */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    exec :: A handle to the source execution context.                  */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<InOut>                                                               */
end_comment
begin_comment
comment|/*    size :: A handle to the target size object.                        */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Note>                                                                */
end_comment
begin_comment
comment|/*    Only the glyph loader and debugger should call this function.      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|TT_Save_Context
name|TT_Save_Context
argument_list|(
argument|TT_ExecContext  exec
argument_list|,
argument|TT_Size         size
argument_list|)
end_macro
begin_block
block|{
name|FT_Int
name|i
decl_stmt|;
comment|/* XXX: Will probably disappear soon with all the code range */
comment|/*      management, which is now rather obsolete.            */
comment|/*                                                           */
name|size
operator|->
name|num_function_defs
operator|=
name|exec
operator|->
name|numFDefs
expr_stmt|;
name|size
operator|->
name|num_instruction_defs
operator|=
name|exec
operator|->
name|numIDefs
expr_stmt|;
name|size
operator|->
name|max_func
operator|=
name|exec
operator|->
name|maxFunc
expr_stmt|;
name|size
operator|->
name|max_ins
operator|=
name|exec
operator|->
name|maxIns
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TT_MAX_CODE_RANGES
condition|;
name|i
operator|++
control|)
name|size
operator|->
name|codeRangeTable
index|[
name|i
index|]
operator|=
name|exec
operator|->
name|codeRangeTable
index|[
name|i
index|]
expr_stmt|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    TT_Run_Context                                                     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Executes one or more instructions in the execution context.        */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    debug :: A Boolean flag.  If set, the function sets some internal  */
end_comment
begin_comment
comment|/*             variables and returns immediately, otherwise TT_RunIns()  */
end_comment
begin_comment
comment|/*             is called.                                                */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*             This is commented out currently.                          */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    exec  :: A handle to the target execution context.                 */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    TrueType error code.  0 means success.                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Note>                                                                */
end_comment
begin_comment
comment|/*    Only the glyph loader and debugger should call this function.      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|TT_Run_Context
argument_list|(
argument|TT_ExecContext  exec
argument_list|,
argument|FT_Bool         debug
argument_list|)
end_macro
begin_block
block|{
name|TT_Goto_CodeRange
argument_list|(
name|exec
argument_list|,
name|tt_coderange_glyph
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|exec
operator|->
name|zp0
operator|=
name|exec
operator|->
name|pts
expr_stmt|;
name|exec
operator|->
name|zp1
operator|=
name|exec
operator|->
name|pts
expr_stmt|;
name|exec
operator|->
name|zp2
operator|=
name|exec
operator|->
name|pts
expr_stmt|;
name|exec
operator|->
name|GS
operator|.
name|gep0
operator|=
literal|1
expr_stmt|;
name|exec
operator|->
name|GS
operator|.
name|gep1
operator|=
literal|1
expr_stmt|;
name|exec
operator|->
name|GS
operator|.
name|gep2
operator|=
literal|1
expr_stmt|;
name|exec
operator|->
name|GS
operator|.
name|projVector
operator|.
name|x
operator|=
literal|0x4000
expr_stmt|;
name|exec
operator|->
name|GS
operator|.
name|projVector
operator|.
name|y
operator|=
literal|0x0000
expr_stmt|;
name|exec
operator|->
name|GS
operator|.
name|freeVector
operator|=
name|exec
operator|->
name|GS
operator|.
name|projVector
expr_stmt|;
name|exec
operator|->
name|GS
operator|.
name|dualVector
operator|=
name|exec
operator|->
name|GS
operator|.
name|projVector
expr_stmt|;
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_UNPATENTED_HINTING
name|exec
operator|->
name|GS
operator|.
name|both_x_axis
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
name|exec
operator|->
name|GS
operator|.
name|round_state
operator|=
literal|1
expr_stmt|;
name|exec
operator|->
name|GS
operator|.
name|loop
operator|=
literal|1
expr_stmt|;
comment|/* some glyphs leave something on the stack. so we clean it */
comment|/* before a new execution.                                  */
name|exec
operator|->
name|top
operator|=
literal|0
expr_stmt|;
name|exec
operator|->
name|callTop
operator|=
literal|0
expr_stmt|;
if|#
directive|if
literal|1
name|FT_UNUSED
argument_list|(
name|debug
argument_list|)
expr_stmt|;
return|return
name|exec
operator|->
name|face
operator|->
name|interpreter
argument_list|(
name|exec
argument_list|)
return|;
else|#
directive|else
if|if
condition|(
operator|!
name|debug
condition|)
return|return
name|TT_RunIns
argument_list|(
name|exec
argument_list|)
return|;
else|else
return|return
name|FT_Err_Ok
return|;
endif|#
directive|endif
block|}
end_block
begin_comment
comment|/* The default value for `scan_control' is documented as FALSE in the */
end_comment
begin_comment
comment|/* TrueType specification.  This is confusing since it implies a      */
end_comment
begin_comment
comment|/* Boolean value.  However, this is not the case, thus both the       */
end_comment
begin_comment
comment|/* default values of our `scan_type' and `scan_control' fields (which */
end_comment
begin_comment
comment|/* the documentation's `scan_control' variable is split into) are     */
end_comment
begin_comment
comment|/* zero.                                                              */
end_comment
begin_decl_stmt
DECL|variable|tt_default_graphics_state
specifier|const
name|TT_GraphicsState
name|tt_default_graphics_state
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
block|{
literal|0x4000
block|,
literal|0
block|}
block|,
block|{
literal|0x4000
block|,
literal|0
block|}
block|,
block|{
literal|0x4000
block|,
literal|0
block|}
block|,
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_UNPATENTED_HINTING
name|TRUE
block|,
endif|#
directive|endif
literal|1
block|,
literal|64
block|,
literal|1
block|,
name|TRUE
block|,
literal|68
block|,
literal|0
block|,
literal|0
block|,
literal|9
block|,
literal|3
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* documentation is in ttinterp.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|TT_ExecContext
argument_list|)
end_macro
begin_macro
name|TT_New_Context
argument_list|(
argument|TT_Driver  driver
argument_list|)
end_macro
begin_block
block|{
name|FT_Memory
name|memory
decl_stmt|;
if|if
condition|(
operator|!
name|driver
condition|)
goto|goto
name|Fail
goto|;
name|memory
operator|=
name|driver
operator|->
name|root
operator|.
name|root
operator|.
name|memory
expr_stmt|;
if|if
condition|(
operator|!
name|driver
operator|->
name|context
condition|)
block|{
name|FT_Error
name|error
decl_stmt|;
name|TT_ExecContext
name|exec
decl_stmt|;
comment|/* allocate object */
if|if
condition|(
name|FT_NEW
argument_list|(
name|exec
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
comment|/* initialize it; in case of error this deallocates `exec' too */
name|error
operator|=
name|Init_Context
argument_list|(
name|exec
argument_list|,
name|memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Fail
goto|;
comment|/* store it into the driver */
name|driver
operator|->
name|context
operator|=
name|exec
expr_stmt|;
block|}
return|return
name|driver
operator|->
name|context
return|;
name|Fail
label|:
return|return
name|NULL
return|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* Before an opcode is executed, the interpreter verifies that there are */
end_comment
begin_comment
comment|/* enough arguments on the stack, with the help of the `Pop_Push_Count'  */
end_comment
begin_comment
comment|/* table.                                                                */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* For each opcode, the first column gives the number of arguments that  */
end_comment
begin_comment
comment|/* are popped from the stack; the second one gives the number of those   */
end_comment
begin_comment
comment|/* that are pushed in result.                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* Opcodes which have a varying number of parameters in the data stream  */
end_comment
begin_comment
comment|/* (NPUSHB, NPUSHW) are handled specially; they have a negative value in */
end_comment
begin_comment
comment|/* the `opcode_length' table, and the value in `Pop_Push_Count' is set   */
end_comment
begin_comment
comment|/* to zero.                                                              */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_undef
DECL|macro|PACK
undef|#
directive|undef
name|PACK
end_undef
begin_define
DECL|macro|PACK
define|#
directive|define
name|PACK
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|( ( x<< 4 ) | y )
end_define
begin_decl_stmt
specifier|static
DECL|variable|Pop_Push_Count
specifier|const
name|FT_Byte
name|Pop_Push_Count
index|[
literal|256
index|]
init|=
block|{
comment|/* opcodes are gathered in groups of 16 */
comment|/* please keep the spaces as they are   */
comment|/*  SVTCA  y  */
name|PACK
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  SVTCA  x  */
name|PACK
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  SPvTCA y  */
name|PACK
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  SPvTCA x  */
name|PACK
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  SFvTCA y  */
name|PACK
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  SFvTCA x  */
name|PACK
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  SPvTL //  */
name|PACK
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  SPvTL +   */
name|PACK
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  SFvTL //  */
name|PACK
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  SFvTL +   */
name|PACK
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  SPvFS     */
name|PACK
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  SFvFS     */
name|PACK
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  GPV       */
name|PACK
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|)
block|,
comment|/*  GFV       */
name|PACK
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|)
block|,
comment|/*  SFvTPv    */
name|PACK
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  ISECT     */
name|PACK
argument_list|(
literal|5
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  SRP0      */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  SRP1      */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  SRP2      */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  SZP0      */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  SZP1      */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  SZP2      */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  SZPS      */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  SLOOP     */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  RTG       */
name|PACK
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  RTHG      */
name|PACK
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  SMD       */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  ELSE      */
name|PACK
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  JMPR      */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  SCvTCi    */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  SSwCi     */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  SSW       */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  DUP       */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
block|,
comment|/*  POP       */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  CLEAR     */
name|PACK
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  SWAP      */
name|PACK
argument_list|(
literal|2
argument_list|,
literal|2
argument_list|)
block|,
comment|/*  DEPTH     */
name|PACK
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
block|,
comment|/*  CINDEX    */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
block|,
comment|/*  MINDEX    */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  AlignPTS  */
name|PACK
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  INS_$28   */
name|PACK
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  UTP       */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  LOOPCALL  */
name|PACK
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  CALL      */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  FDEF      */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  ENDF      */
name|PACK
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  MDAP[0]   */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  MDAP[1]   */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  IUP[0]    */
name|PACK
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  IUP[1]    */
name|PACK
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  SHP[0]    */
name|PACK
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  SHP[1]    */
name|PACK
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  SHC[0]    */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  SHC[1]    */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  SHZ[0]    */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  SHZ[1]    */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  SHPIX     */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  IP        */
name|PACK
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  MSIRP[0]  */
name|PACK
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  MSIRP[1]  */
name|PACK
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  AlignRP   */
name|PACK
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  RTDG      */
name|PACK
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  MIAP[0]   */
name|PACK
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  MIAP[1]   */
name|PACK
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  NPushB    */
name|PACK
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  NPushW    */
name|PACK
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  WS        */
name|PACK
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  RS        */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
block|,
comment|/*  WCvtP     */
name|PACK
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  RCvt      */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
block|,
comment|/*  GC[0]     */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
block|,
comment|/*  GC[1]     */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
block|,
comment|/*  SCFS      */
name|PACK
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  MD[0]     */
name|PACK
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|)
block|,
comment|/*  MD[1]     */
name|PACK
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|)
block|,
comment|/*  MPPEM     */
name|PACK
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
block|,
comment|/*  MPS       */
name|PACK
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
block|,
comment|/*  FlipON    */
name|PACK
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  FlipOFF   */
name|PACK
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  DEBUG     */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  LT        */
name|PACK
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|)
block|,
comment|/*  LTEQ      */
name|PACK
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|)
block|,
comment|/*  GT        */
name|PACK
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|)
block|,
comment|/*  GTEQ      */
name|PACK
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|)
block|,
comment|/*  EQ        */
name|PACK
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|)
block|,
comment|/*  NEQ       */
name|PACK
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|)
block|,
comment|/*  ODD       */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
block|,
comment|/*  EVEN      */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
block|,
comment|/*  IF        */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  EIF       */
name|PACK
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  AND       */
name|PACK
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|)
block|,
comment|/*  OR        */
name|PACK
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|)
block|,
comment|/*  NOT       */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
block|,
comment|/*  DeltaP1   */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  SDB       */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  SDS       */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  ADD       */
name|PACK
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|)
block|,
comment|/*  SUB       */
name|PACK
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|)
block|,
comment|/*  DIV       */
name|PACK
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|)
block|,
comment|/*  MUL       */
name|PACK
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|)
block|,
comment|/*  ABS       */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
block|,
comment|/*  NEG       */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
block|,
comment|/*  FLOOR     */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
block|,
comment|/*  CEILING   */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
block|,
comment|/*  ROUND[0]  */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
block|,
comment|/*  ROUND[1]  */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
block|,
comment|/*  ROUND[2]  */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
block|,
comment|/*  ROUND[3]  */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
block|,
comment|/*  NROUND[0] */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
block|,
comment|/*  NROUND[1] */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
block|,
comment|/*  NROUND[2] */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
block|,
comment|/*  NROUND[3] */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
block|,
comment|/*  WCvtF     */
name|PACK
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  DeltaP2   */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  DeltaP3   */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  DeltaCn[0] */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  DeltaCn[1] */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  DeltaCn[2] */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  SROUND    */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  S45Round  */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  JROT      */
name|PACK
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  JROF      */
name|PACK
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  ROFF      */
name|PACK
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  INS_$7B   */
name|PACK
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  RUTG      */
name|PACK
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  RDTG      */
name|PACK
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  SANGW     */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  AA        */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  FlipPT    */
name|PACK
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  FlipRgON  */
name|PACK
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  FlipRgOFF */
name|PACK
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  INS_$83   */
name|PACK
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  INS_$84   */
name|PACK
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  ScanCTRL  */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  SDPVTL[0] */
name|PACK
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  SDPVTL[1] */
name|PACK
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  GetINFO   */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
block|,
comment|/*  IDEF      */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  ROLL      */
name|PACK
argument_list|(
literal|3
argument_list|,
literal|3
argument_list|)
block|,
comment|/*  MAX       */
name|PACK
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|)
block|,
comment|/*  MIN       */
name|PACK
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|)
block|,
comment|/*  ScanTYPE  */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  InstCTRL  */
name|PACK
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  INS_$8F   */
name|PACK
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  INS_$90  */
name|PACK
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  INS_$91  */
name|PACK
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  INS_$92  */
name|PACK
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  INS_$93  */
name|PACK
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  INS_$94  */
name|PACK
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  INS_$95  */
name|PACK
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  INS_$96  */
name|PACK
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  INS_$97  */
name|PACK
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  INS_$98  */
name|PACK
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  INS_$99  */
name|PACK
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  INS_$9A  */
name|PACK
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  INS_$9B  */
name|PACK
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  INS_$9C  */
name|PACK
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  INS_$9D  */
name|PACK
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  INS_$9E  */
name|PACK
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  INS_$9F  */
name|PACK
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  INS_$A0  */
name|PACK
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  INS_$A1  */
name|PACK
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  INS_$A2  */
name|PACK
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  INS_$A3  */
name|PACK
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  INS_$A4  */
name|PACK
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  INS_$A5  */
name|PACK
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  INS_$A6  */
name|PACK
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  INS_$A7  */
name|PACK
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  INS_$A8  */
name|PACK
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  INS_$A9  */
name|PACK
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  INS_$AA  */
name|PACK
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  INS_$AB  */
name|PACK
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  INS_$AC  */
name|PACK
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  INS_$AD  */
name|PACK
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  INS_$AE  */
name|PACK
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  INS_$AF  */
name|PACK
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  PushB[0]  */
name|PACK
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
block|,
comment|/*  PushB[1]  */
name|PACK
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|)
block|,
comment|/*  PushB[2]  */
name|PACK
argument_list|(
literal|0
argument_list|,
literal|3
argument_list|)
block|,
comment|/*  PushB[3]  */
name|PACK
argument_list|(
literal|0
argument_list|,
literal|4
argument_list|)
block|,
comment|/*  PushB[4]  */
name|PACK
argument_list|(
literal|0
argument_list|,
literal|5
argument_list|)
block|,
comment|/*  PushB[5]  */
name|PACK
argument_list|(
literal|0
argument_list|,
literal|6
argument_list|)
block|,
comment|/*  PushB[6]  */
name|PACK
argument_list|(
literal|0
argument_list|,
literal|7
argument_list|)
block|,
comment|/*  PushB[7]  */
name|PACK
argument_list|(
literal|0
argument_list|,
literal|8
argument_list|)
block|,
comment|/*  PushW[0]  */
name|PACK
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
block|,
comment|/*  PushW[1]  */
name|PACK
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|)
block|,
comment|/*  PushW[2]  */
name|PACK
argument_list|(
literal|0
argument_list|,
literal|3
argument_list|)
block|,
comment|/*  PushW[3]  */
name|PACK
argument_list|(
literal|0
argument_list|,
literal|4
argument_list|)
block|,
comment|/*  PushW[4]  */
name|PACK
argument_list|(
literal|0
argument_list|,
literal|5
argument_list|)
block|,
comment|/*  PushW[5]  */
name|PACK
argument_list|(
literal|0
argument_list|,
literal|6
argument_list|)
block|,
comment|/*  PushW[6]  */
name|PACK
argument_list|(
literal|0
argument_list|,
literal|7
argument_list|)
block|,
comment|/*  PushW[7]  */
name|PACK
argument_list|(
literal|0
argument_list|,
literal|8
argument_list|)
block|,
comment|/*  MDRP[00]  */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  MDRP[01]  */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  MDRP[02]  */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  MDRP[03]  */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  MDRP[04]  */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  MDRP[05]  */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  MDRP[06]  */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  MDRP[07]  */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  MDRP[08]  */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  MDRP[09]  */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  MDRP[10]  */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  MDRP[11]  */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  MDRP[12]  */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  MDRP[13]  */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  MDRP[14]  */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  MDRP[15]  */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  MDRP[16]  */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  MDRP[17]  */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  MDRP[18]  */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  MDRP[19]  */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  MDRP[20]  */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  MDRP[21]  */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  MDRP[22]  */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  MDRP[23]  */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  MDRP[24]  */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  MDRP[25]  */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  MDRP[26]  */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  MDRP[27]  */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  MDRP[28]  */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  MDRP[29]  */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  MDRP[30]  */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  MDRP[31]  */
name|PACK
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  MIRP[00]  */
name|PACK
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  MIRP[01]  */
name|PACK
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  MIRP[02]  */
name|PACK
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  MIRP[03]  */
name|PACK
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  MIRP[04]  */
name|PACK
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  MIRP[05]  */
name|PACK
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  MIRP[06]  */
name|PACK
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  MIRP[07]  */
name|PACK
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  MIRP[08]  */
name|PACK
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  MIRP[09]  */
name|PACK
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  MIRP[10]  */
name|PACK
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  MIRP[11]  */
name|PACK
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  MIRP[12]  */
name|PACK
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  MIRP[13]  */
name|PACK
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  MIRP[14]  */
name|PACK
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  MIRP[15]  */
name|PACK
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  MIRP[16]  */
name|PACK
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  MIRP[17]  */
name|PACK
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  MIRP[18]  */
name|PACK
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  MIRP[19]  */
name|PACK
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  MIRP[20]  */
name|PACK
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  MIRP[21]  */
name|PACK
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  MIRP[22]  */
name|PACK
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  MIRP[23]  */
name|PACK
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  MIRP[24]  */
name|PACK
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  MIRP[25]  */
name|PACK
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  MIRP[26]  */
name|PACK
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  MIRP[27]  */
name|PACK
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  MIRP[28]  */
name|PACK
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  MIRP[29]  */
name|PACK
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  MIRP[30]  */
name|PACK
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
block|,
comment|/*  MIRP[31]  */
name|PACK
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
block|}
decl_stmt|;
end_decl_stmt
begin_ifdef
ifdef|#
directive|ifdef
name|FT_DEBUG_LEVEL_TRACE
end_ifdef
begin_decl_stmt
specifier|static
DECL|variable|opcode_name
specifier|const
name|char
modifier|*
specifier|const
name|opcode_name
index|[
literal|256
index|]
init|=
block|{
literal|"SVTCA y"
block|,
literal|"SVTCA x"
block|,
literal|"SPvTCA y"
block|,
literal|"SPvTCA x"
block|,
literal|"SFvTCA y"
block|,
literal|"SFvTCA x"
block|,
literal|"SPvTL ||"
block|,
literal|"SPvTL +"
block|,
literal|"SFvTL ||"
block|,
literal|"SFvTL +"
block|,
literal|"SPvFS"
block|,
literal|"SFvFS"
block|,
literal|"GPV"
block|,
literal|"GFV"
block|,
literal|"SFvTPv"
block|,
literal|"ISECT"
block|,
literal|"SRP0"
block|,
literal|"SRP1"
block|,
literal|"SRP2"
block|,
literal|"SZP0"
block|,
literal|"SZP1"
block|,
literal|"SZP2"
block|,
literal|"SZPS"
block|,
literal|"SLOOP"
block|,
literal|"RTG"
block|,
literal|"RTHG"
block|,
literal|"SMD"
block|,
literal|"ELSE"
block|,
literal|"JMPR"
block|,
literal|"SCvTCi"
block|,
literal|"SSwCi"
block|,
literal|"SSW"
block|,
literal|"DUP"
block|,
literal|"POP"
block|,
literal|"CLEAR"
block|,
literal|"SWAP"
block|,
literal|"DEPTH"
block|,
literal|"CINDEX"
block|,
literal|"MINDEX"
block|,
literal|"AlignPTS"
block|,
literal|"INS_$28"
block|,
literal|"UTP"
block|,
literal|"LOOPCALL"
block|,
literal|"CALL"
block|,
literal|"FDEF"
block|,
literal|"ENDF"
block|,
literal|"MDAP[0]"
block|,
literal|"MDAP[1]"
block|,
literal|"IUP[0]"
block|,
literal|"IUP[1]"
block|,
literal|"SHP[0]"
block|,
literal|"SHP[1]"
block|,
literal|"SHC[0]"
block|,
literal|"SHC[1]"
block|,
literal|"SHZ[0]"
block|,
literal|"SHZ[1]"
block|,
literal|"SHPIX"
block|,
literal|"IP"
block|,
literal|"MSIRP[0]"
block|,
literal|"MSIRP[1]"
block|,
literal|"AlignRP"
block|,
literal|"RTDG"
block|,
literal|"MIAP[0]"
block|,
literal|"MIAP[1]"
block|,
literal|"NPushB"
block|,
literal|"NPushW"
block|,
literal|"WS"
block|,
literal|"RS"
block|,
literal|"WCvtP"
block|,
literal|"RCvt"
block|,
literal|"GC[0]"
block|,
literal|"GC[1]"
block|,
literal|"SCFS"
block|,
literal|"MD[0]"
block|,
literal|"MD[1]"
block|,
literal|"MPPEM"
block|,
literal|"MPS"
block|,
literal|"FlipON"
block|,
literal|"FlipOFF"
block|,
literal|"DEBUG"
block|,
literal|"LT"
block|,
literal|"LTEQ"
block|,
literal|"GT"
block|,
literal|"GTEQ"
block|,
literal|"EQ"
block|,
literal|"NEQ"
block|,
literal|"ODD"
block|,
literal|"EVEN"
block|,
literal|"IF"
block|,
literal|"EIF"
block|,
literal|"AND"
block|,
literal|"OR"
block|,
literal|"NOT"
block|,
literal|"DeltaP1"
block|,
literal|"SDB"
block|,
literal|"SDS"
block|,
literal|"ADD"
block|,
literal|"SUB"
block|,
literal|"DIV"
block|,
literal|"MUL"
block|,
literal|"ABS"
block|,
literal|"NEG"
block|,
literal|"FLOOR"
block|,
literal|"CEILING"
block|,
literal|"ROUND[0]"
block|,
literal|"ROUND[1]"
block|,
literal|"ROUND[2]"
block|,
literal|"ROUND[3]"
block|,
literal|"NROUND[0]"
block|,
literal|"NROUND[1]"
block|,
literal|"NROUND[2]"
block|,
literal|"NROUND[3]"
block|,
literal|"WCvtF"
block|,
literal|"DeltaP2"
block|,
literal|"DeltaP3"
block|,
literal|"DeltaCn[0]"
block|,
literal|"DeltaCn[1]"
block|,
literal|"DeltaCn[2]"
block|,
literal|"SROUND"
block|,
literal|"S45Round"
block|,
literal|"JROT"
block|,
literal|"JROF"
block|,
literal|"ROFF"
block|,
literal|"INS_$7B"
block|,
literal|"RUTG"
block|,
literal|"RDTG"
block|,
literal|"SANGW"
block|,
literal|"AA"
block|,
literal|"FlipPT"
block|,
literal|"FlipRgON"
block|,
literal|"FlipRgOFF"
block|,
literal|"INS_$83"
block|,
literal|"INS_$84"
block|,
literal|"ScanCTRL"
block|,
literal|"SDVPTL[0]"
block|,
literal|"SDVPTL[1]"
block|,
literal|"GetINFO"
block|,
literal|"IDEF"
block|,
literal|"ROLL"
block|,
literal|"MAX"
block|,
literal|"MIN"
block|,
literal|"ScanTYPE"
block|,
literal|"InstCTRL"
block|,
literal|"INS_$8F"
block|,
literal|"INS_$90"
block|,
literal|"INS_$91"
block|,
literal|"INS_$92"
block|,
literal|"INS_$93"
block|,
literal|"INS_$94"
block|,
literal|"INS_$95"
block|,
literal|"INS_$96"
block|,
literal|"INS_$97"
block|,
literal|"INS_$98"
block|,
literal|"INS_$99"
block|,
literal|"INS_$9A"
block|,
literal|"INS_$9B"
block|,
literal|"INS_$9C"
block|,
literal|"INS_$9D"
block|,
literal|"INS_$9E"
block|,
literal|"INS_$9F"
block|,
literal|"INS_$A0"
block|,
literal|"INS_$A1"
block|,
literal|"INS_$A2"
block|,
literal|"INS_$A3"
block|,
literal|"INS_$A4"
block|,
literal|"INS_$A5"
block|,
literal|"INS_$A6"
block|,
literal|"INS_$A7"
block|,
literal|"INS_$A8"
block|,
literal|"INS_$A9"
block|,
literal|"INS_$AA"
block|,
literal|"INS_$AB"
block|,
literal|"INS_$AC"
block|,
literal|"INS_$AD"
block|,
literal|"INS_$AE"
block|,
literal|"INS_$AF"
block|,
literal|"PushB[0]"
block|,
literal|"PushB[1]"
block|,
literal|"PushB[2]"
block|,
literal|"PushB[3]"
block|,
literal|"PushB[4]"
block|,
literal|"PushB[5]"
block|,
literal|"PushB[6]"
block|,
literal|"PushB[7]"
block|,
literal|"PushW[0]"
block|,
literal|"PushW[1]"
block|,
literal|"PushW[2]"
block|,
literal|"PushW[3]"
block|,
literal|"PushW[4]"
block|,
literal|"PushW[5]"
block|,
literal|"PushW[6]"
block|,
literal|"PushW[7]"
block|,
literal|"MDRP[00]"
block|,
literal|"MDRP[01]"
block|,
literal|"MDRP[02]"
block|,
literal|"MDRP[03]"
block|,
literal|"MDRP[04]"
block|,
literal|"MDRP[05]"
block|,
literal|"MDRP[06]"
block|,
literal|"MDRP[07]"
block|,
literal|"MDRP[08]"
block|,
literal|"MDRP[09]"
block|,
literal|"MDRP[10]"
block|,
literal|"MDRP[11]"
block|,
literal|"MDRP[12]"
block|,
literal|"MDRP[13]"
block|,
literal|"MDRP[14]"
block|,
literal|"MDRP[15]"
block|,
literal|"MDRP[16]"
block|,
literal|"MDRP[17]"
block|,
literal|"MDRP[18]"
block|,
literal|"MDRP[19]"
block|,
literal|"MDRP[20]"
block|,
literal|"MDRP[21]"
block|,
literal|"MDRP[22]"
block|,
literal|"MDRP[23]"
block|,
literal|"MDRP[24]"
block|,
literal|"MDRP[25]"
block|,
literal|"MDRP[26]"
block|,
literal|"MDRP[27]"
block|,
literal|"MDRP[28]"
block|,
literal|"MDRP[29]"
block|,
literal|"MDRP[30]"
block|,
literal|"MDRP[31]"
block|,
literal|"MIRP[00]"
block|,
literal|"MIRP[01]"
block|,
literal|"MIRP[02]"
block|,
literal|"MIRP[03]"
block|,
literal|"MIRP[04]"
block|,
literal|"MIRP[05]"
block|,
literal|"MIRP[06]"
block|,
literal|"MIRP[07]"
block|,
literal|"MIRP[08]"
block|,
literal|"MIRP[09]"
block|,
literal|"MIRP[10]"
block|,
literal|"MIRP[11]"
block|,
literal|"MIRP[12]"
block|,
literal|"MIRP[13]"
block|,
literal|"MIRP[14]"
block|,
literal|"MIRP[15]"
block|,
literal|"MIRP[16]"
block|,
literal|"MIRP[17]"
block|,
literal|"MIRP[18]"
block|,
literal|"MIRP[19]"
block|,
literal|"MIRP[20]"
block|,
literal|"MIRP[21]"
block|,
literal|"MIRP[22]"
block|,
literal|"MIRP[23]"
block|,
literal|"MIRP[24]"
block|,
literal|"MIRP[25]"
block|,
literal|"MIRP[26]"
block|,
literal|"MIRP[27]"
block|,
literal|"MIRP[28]"
block|,
literal|"MIRP[29]"
block|,
literal|"MIRP[30]"
block|,
literal|"MIRP[31]"
block|}
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* FT_DEBUG_LEVEL_TRACE */
end_comment
begin_decl_stmt
specifier|static
DECL|variable|opcode_length
specifier|const
name|FT_Char
name|opcode_length
index|[
literal|256
index|]
init|=
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|2
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|3
block|,
literal|5
block|,
literal|7
block|,
literal|9
block|,
literal|11
block|,
literal|13
block|,
literal|15
block|,
literal|17
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt
begin_undef
DECL|macro|PACK
undef|#
directive|undef
name|PACK
end_undef
begin_ifndef
ifndef|#
directive|ifndef
name|FT_CONFIG_OPTION_NO_ASSEMBLER
end_ifndef
begin_if
if|#
directive|if
name|defined
argument_list|(
name|__arm__
argument_list|)
operator|&&
expr|\
operator|(
name|defined
argument_list|(
name|__thumb2__
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|__thumb__
argument_list|)
operator|)
end_if
begin_define
DECL|macro|TT_MulFix14
define|#
directive|define
name|TT_MulFix14
value|TT_MulFix14_arm
end_define
begin_function
specifier|static
name|FT_Int32
DECL|function|TT_MulFix14_arm
name|TT_MulFix14_arm
parameter_list|(
name|FT_Int32
name|a
parameter_list|,
name|FT_Int
name|b
parameter_list|)
block|{
name|FT_Int32
name|t
decl_stmt|,
name|t2
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__CC_ARM
argument_list|)
operator|||
name|defined
argument_list|(
name|__ARMCC__
argument_list|)
asm|__asm
block|{
name|smull
name|t2
decl_stmt|,
name|t
decl_stmt|,
name|b
decl_stmt|,
name|a
comment|/* (lo=t2,hi=t) = a*b */
name|mov
name|a
decl_stmt|,
name|t
decl_stmt|,
name|asr
decl|#31
comment|/* a   = (hi>> 31) */
name|add
name|a
decl_stmt|,
name|a
decl_stmt|,  #0x2000
comment|/* a  += 0x2000 */
name|adds
name|t2
decl_stmt|,
name|t2
decl_stmt|,
name|a
comment|/* t2 += a */
name|adc
name|t
decl_stmt|,
name|t
decl_stmt|,  #0
comment|/* t  += carry */
name|mov
name|a
decl_stmt|,
name|t2
decl_stmt|,
name|lsr
decl|#14
comment|/* a   = t2>> 14 */
name|orr
name|a
decl_stmt|,
name|a
decl_stmt|,
name|t
decl_stmt|,
name|lsl
decl|#18
comment|/* a  |= t<< 18 */
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|__GNUC__
argument_list|)
asm|__asm__
specifier|__volatile__
asm|(       "smull  %1, %2, %4, %3\n\t"
comment|/* (lo=%1,hi=%2) = a*b */
asm|"mov    %0, %2, asr #31\n\t"
comment|/* %0  = (hi>> 31) */
if|#
directive|if
name|defined
argument_list|(
name|__clang__
argument_list|)
operator|&&
name|defined
argument_list|(
name|__thumb2__
argument_list|)
asm|"add.w  %0, %0, #0x2000\n\t"
comment|/* %0 += 0x2000 */
else|#
directive|else
asm|"add    %0, %0, #0x2000\n\t"
comment|/* %0 += 0x2000 */
endif|#
directive|endif
asm|"adds   %1, %1, %0\n\t"
comment|/* %1 += %0 */
asm|"adc    %2, %2, #0\n\t"
comment|/* %2 += carry */
asm|"mov    %0, %1, lsr #14\n\t"
comment|/* %0  = %1>> 16 */
asm|"orr    %0, %0, %2, lsl #18\n\t"
comment|/* %0 |= %2<< 16 */
asm|: "=r"(a), "=&r"(t2), "=&r"(t)       : "r"(a), "r"(b)       : "cc" );
endif|#
directive|endif
return|return
name|a
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* __arm__&& ( __thumb2__ || !__thumb__ ) */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* !FT_CONFIG_OPTION_NO_ASSEMBLER */
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
expr|\
operator|(
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
name|defined
argument_list|(
name|__x86_64__
argument_list|)
operator|)
end_if
begin_define
DECL|macro|TT_MulFix14
define|#
directive|define
name|TT_MulFix14
value|TT_MulFix14_long_long
end_define
begin_comment
comment|/* Temporarily disable the warning that C90 doesn't support `long long'. */
end_comment
begin_if
if|#
directive|if
operator|(
name|__GNUC__
operator|*
literal|100
operator|+
name|__GNUC_MINOR__
operator|)
operator|>=
literal|406
end_if
begin_pragma
pragma|#
directive|pragma
name|GCC
name|diagnostic
name|push
end_pragma
begin_endif
endif|#
directive|endif
end_endif
begin_pragma
pragma|#
directive|pragma
name|GCC
name|diagnostic
name|ignored
literal|"-Wlong-long"
end_pragma
begin_comment
comment|/* This is declared `noinline' because inlining the function results */
end_comment
begin_comment
comment|/* in slower code.  The `pure' attribute indicates that the result   */
end_comment
begin_comment
comment|/* only depends on the parameters.                                   */
end_comment
begin_expr_stmt
specifier|static
name|__attribute__
argument_list|(
argument|( noinline )
argument_list|)
name|__attribute__
argument_list|(
argument|( pure )
argument_list|)
name|FT_Int32
DECL|function|TT_MulFix14_long_long
name|TT_MulFix14_long_long
argument_list|(
argument|FT_Int32  a
argument_list|,
argument|FT_Int    b
argument_list|)
block|{
name|long
name|long
name|ret
operator|=
operator|(
name|long
name|long
operator|)
name|a
operator|*
name|b
block|;
comment|/* The following line assumes that right shifting of signed values */
comment|/* will actually preserve the sign bit.  The exact behaviour is    */
comment|/* undefined, but this is true on x86 and x86_64.                  */
name|long
name|long
name|tmp
operator|=
name|ret
operator|>>
literal|63
block|;
name|ret
operator|+=
literal|0x2000
operator|+
name|tmp
block|;
return|return
call|(
name|FT_Int32
call|)
argument_list|(
name|ret
operator|>>
literal|14
argument_list|)
return|;
block|}
end_expr_stmt
begin_if
if|#
directive|if
operator|(
name|__GNUC__
operator|*
literal|100
operator|+
name|__GNUC_MINOR__
operator|)
operator|>=
literal|406
end_if
begin_pragma
pragma|#
directive|pragma
name|GCC
name|diagnostic
name|pop
end_pragma
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* __GNUC__&& ( __i386__ || __x86_64__ ) */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|TT_MulFix14
end_ifndef
begin_comment
comment|/* Compute (a*b)/2^14 with maximum accuracy and rounding.  */
end_comment
begin_comment
comment|/* This is optimized to be faster than calling FT_MulFix() */
end_comment
begin_comment
comment|/* for platforms where sizeof(int) == 2.                   */
end_comment
begin_function
specifier|static
name|FT_Int32
DECL|function|TT_MulFix14
name|TT_MulFix14
parameter_list|(
name|FT_Int32
name|a
parameter_list|,
name|FT_Int
name|b
parameter_list|)
block|{
name|FT_Int32
name|sign
decl_stmt|;
name|FT_UInt32
name|ah
decl_stmt|,
name|al
decl_stmt|,
name|mid
decl_stmt|,
name|lo
decl_stmt|,
name|hi
decl_stmt|;
name|sign
operator|=
name|a
operator|^
name|b
expr_stmt|;
if|if
condition|(
name|a
operator|<
literal|0
condition|)
name|a
operator|=
operator|-
name|a
expr_stmt|;
if|if
condition|(
name|b
operator|<
literal|0
condition|)
name|b
operator|=
operator|-
name|b
expr_stmt|;
name|ah
operator|=
call|(
name|FT_UInt32
call|)
argument_list|(
operator|(
name|a
operator|>>
literal|16
operator|)
operator|&
literal|0xFFFFU
argument_list|)
expr_stmt|;
name|al
operator|=
call|(
name|FT_UInt32
call|)
argument_list|(
name|a
operator|&
literal|0xFFFFU
argument_list|)
expr_stmt|;
name|lo
operator|=
name|al
operator|*
name|b
expr_stmt|;
name|mid
operator|=
name|ah
operator|*
name|b
expr_stmt|;
name|hi
operator|=
name|mid
operator|>>
literal|16
expr_stmt|;
name|mid
operator|=
operator|(
name|mid
operator|<<
literal|16
operator|)
operator|+
operator|(
literal|1
operator|<<
literal|13
operator|)
expr_stmt|;
comment|/* rounding */
name|lo
operator|+=
name|mid
expr_stmt|;
if|if
condition|(
name|lo
operator|<
name|mid
condition|)
name|hi
operator|+=
literal|1
expr_stmt|;
name|mid
operator|=
operator|(
name|lo
operator|>>
literal|14
operator|)
operator||
operator|(
name|hi
operator|<<
literal|18
operator|)
expr_stmt|;
return|return
name|sign
operator|>=
literal|0
condition|?
operator|(
name|FT_Int32
operator|)
name|mid
else|:
operator|-
operator|(
name|FT_Int32
operator|)
name|mid
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* !TT_MulFix14 */
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
expr|\
operator|(
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|__x86_64__
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|__arm__
argument_list|)
operator|)
end_if
begin_define
DECL|macro|TT_DotFix14
define|#
directive|define
name|TT_DotFix14
value|TT_DotFix14_long_long
end_define
begin_if
if|#
directive|if
operator|(
name|__GNUC__
operator|*
literal|100
operator|+
name|__GNUC_MINOR__
operator|)
operator|>=
literal|406
end_if
begin_pragma
pragma|#
directive|pragma
name|GCC
name|diagnostic
name|push
end_pragma
begin_endif
endif|#
directive|endif
end_endif
begin_pragma
pragma|#
directive|pragma
name|GCC
name|diagnostic
name|ignored
literal|"-Wlong-long"
end_pragma
begin_expr_stmt
specifier|static
name|__attribute__
argument_list|(
argument|( pure )
argument_list|)
name|FT_Int32
DECL|function|TT_DotFix14_long_long
name|TT_DotFix14_long_long
argument_list|(
argument|FT_Int32  ax
argument_list|,
argument|FT_Int32  ay
argument_list|,
argument|FT_Int    bx
argument_list|,
argument|FT_Int    by
argument_list|)
block|{
comment|/* Temporarily disable the warning that C90 doesn't support */
comment|/* `long long'.                                             */
name|long
name|long
name|temp1
operator|=
operator|(
name|long
name|long
operator|)
name|ax
operator|*
name|bx
block|;
name|long
name|long
name|temp2
operator|=
operator|(
name|long
name|long
operator|)
name|ay
operator|*
name|by
block|;
name|temp1
operator|+=
name|temp2
block|;
name|temp2
operator|=
name|temp1
operator|>>
literal|63
block|;
name|temp1
operator|+=
literal|0x2000
operator|+
name|temp2
block|;
return|return
call|(
name|FT_Int32
call|)
argument_list|(
name|temp1
operator|>>
literal|14
argument_list|)
return|;
block|}
end_expr_stmt
begin_if
if|#
directive|if
operator|(
name|__GNUC__
operator|*
literal|100
operator|+
name|__GNUC_MINOR__
operator|)
operator|>=
literal|406
end_if
begin_pragma
pragma|#
directive|pragma
name|GCC
name|diagnostic
name|pop
end_pragma
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* __GNUC__&& (__arm__ || __i386__ || __x86_64__) */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|TT_DotFix14
end_ifndef
begin_comment
comment|/* compute (ax*bx+ay*by)/2^14 with maximum accuracy and rounding */
end_comment
begin_function
specifier|static
name|FT_Int32
DECL|function|TT_DotFix14
name|TT_DotFix14
parameter_list|(
name|FT_Int32
name|ax
parameter_list|,
name|FT_Int32
name|ay
parameter_list|,
name|FT_Int
name|bx
parameter_list|,
name|FT_Int
name|by
parameter_list|)
block|{
name|FT_Int32
name|m
decl_stmt|,
name|s
decl_stmt|,
name|hi1
decl_stmt|,
name|hi2
decl_stmt|,
name|hi
decl_stmt|;
name|FT_UInt32
name|l
decl_stmt|,
name|lo1
decl_stmt|,
name|lo2
decl_stmt|,
name|lo
decl_stmt|;
comment|/* compute ax*bx as 64-bit value */
name|l
operator|=
call|(
name|FT_UInt32
call|)
argument_list|(
operator|(
name|ax
operator|&
literal|0xFFFFU
operator|)
operator|*
name|bx
argument_list|)
expr_stmt|;
name|m
operator|=
operator|(
name|ax
operator|>>
literal|16
operator|)
operator|*
name|bx
expr_stmt|;
name|lo1
operator|=
name|l
operator|+
operator|(
operator|(
name|FT_UInt32
operator|)
name|m
operator|<<
literal|16
operator|)
expr_stmt|;
name|hi1
operator|=
operator|(
name|m
operator|>>
literal|16
operator|)
operator|+
operator|(
operator|(
name|FT_Int32
operator|)
name|l
operator|>>
literal|31
operator|)
operator|+
operator|(
name|lo1
operator|<
name|l
operator|)
expr_stmt|;
comment|/* compute ay*by as 64-bit value */
name|l
operator|=
call|(
name|FT_UInt32
call|)
argument_list|(
operator|(
name|ay
operator|&
literal|0xFFFFU
operator|)
operator|*
name|by
argument_list|)
expr_stmt|;
name|m
operator|=
operator|(
name|ay
operator|>>
literal|16
operator|)
operator|*
name|by
expr_stmt|;
name|lo2
operator|=
name|l
operator|+
operator|(
operator|(
name|FT_UInt32
operator|)
name|m
operator|<<
literal|16
operator|)
expr_stmt|;
name|hi2
operator|=
operator|(
name|m
operator|>>
literal|16
operator|)
operator|+
operator|(
operator|(
name|FT_Int32
operator|)
name|l
operator|>>
literal|31
operator|)
operator|+
operator|(
name|lo2
operator|<
name|l
operator|)
expr_stmt|;
comment|/* add them */
name|lo
operator|=
name|lo1
operator|+
name|lo2
expr_stmt|;
name|hi
operator|=
name|hi1
operator|+
name|hi2
operator|+
operator|(
name|lo
operator|<
name|lo1
operator|)
expr_stmt|;
comment|/* divide the result by 2^14 with rounding */
name|s
operator|=
name|hi
operator|>>
literal|31
expr_stmt|;
name|l
operator|=
name|lo
operator|+
operator|(
name|FT_UInt32
operator|)
name|s
expr_stmt|;
name|hi
operator|+=
name|s
operator|+
operator|(
name|l
operator|<
name|lo
operator|)
expr_stmt|;
name|lo
operator|=
name|l
expr_stmt|;
name|l
operator|=
name|lo
operator|+
literal|0x2000U
expr_stmt|;
name|hi
operator|+=
operator|(
name|l
operator|<
name|lo
operator|)
expr_stmt|;
return|return
call|(
name|FT_Int32
call|)
argument_list|(
operator|(
operator|(
name|FT_UInt32
operator|)
name|hi
operator|<<
literal|18
operator|)
operator||
operator|(
name|l
operator|>>
literal|14
operator|)
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* TT_DotFix14 */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    Current_Ratio                                                      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Returns the current aspect ratio scaling factor depending on the   */
end_comment
begin_comment
comment|/*    projection vector's state and device resolutions.                  */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    The aspect ratio in 16.16 format, always<= 1.0 .                  */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|FT_Long
DECL|function|Current_Ratio
name|Current_Ratio
parameter_list|(
name|EXEC_OP
parameter_list|)
block|{
if|if
condition|(
operator|!
name|CUR
operator|.
name|tt_metrics
operator|.
name|ratio
condition|)
block|{
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_UNPATENTED_HINTING
if|if
condition|(
name|CUR
operator|.
name|face
operator|->
name|unpatented_hinting
condition|)
block|{
if|if
condition|(
name|CUR
operator|.
name|GS
operator|.
name|both_x_axis
condition|)
name|CUR
operator|.
name|tt_metrics
operator|.
name|ratio
operator|=
name|CUR
operator|.
name|tt_metrics
operator|.
name|x_ratio
expr_stmt|;
else|else
name|CUR
operator|.
name|tt_metrics
operator|.
name|ratio
operator|=
name|CUR
operator|.
name|tt_metrics
operator|.
name|y_ratio
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
if|if
condition|(
name|CUR
operator|.
name|GS
operator|.
name|projVector
operator|.
name|y
operator|==
literal|0
condition|)
name|CUR
operator|.
name|tt_metrics
operator|.
name|ratio
operator|=
name|CUR
operator|.
name|tt_metrics
operator|.
name|x_ratio
expr_stmt|;
elseif|else
if|if
condition|(
name|CUR
operator|.
name|GS
operator|.
name|projVector
operator|.
name|x
operator|==
literal|0
condition|)
name|CUR
operator|.
name|tt_metrics
operator|.
name|ratio
operator|=
name|CUR
operator|.
name|tt_metrics
operator|.
name|y_ratio
expr_stmt|;
else|else
block|{
name|FT_F26Dot6
name|x
decl_stmt|,
name|y
decl_stmt|;
name|x
operator|=
name|TT_MulFix14
argument_list|(
name|CUR
operator|.
name|tt_metrics
operator|.
name|x_ratio
argument_list|,
name|CUR
operator|.
name|GS
operator|.
name|projVector
operator|.
name|x
argument_list|)
expr_stmt|;
name|y
operator|=
name|TT_MulFix14
argument_list|(
name|CUR
operator|.
name|tt_metrics
operator|.
name|y_ratio
argument_list|,
name|CUR
operator|.
name|GS
operator|.
name|projVector
operator|.
name|y
argument_list|)
expr_stmt|;
name|CUR
operator|.
name|tt_metrics
operator|.
name|ratio
operator|=
name|FT_Hypot
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|CUR
operator|.
name|tt_metrics
operator|.
name|ratio
return|;
block|}
end_function
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_Long
argument_list|)
end_macro
begin_macro
name|Current_Ppem
argument_list|(
argument|EXEC_OP
argument_list|)
end_macro
begin_block
block|{
return|return
name|CUR
operator|.
name|tt_metrics
operator|.
name|ppem
return|;
block|}
end_block
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_Long
argument_list|)
end_macro
begin_macro
name|Current_Ppem_Stretched
argument_list|(
argument|EXEC_OP
argument_list|)
end_macro
begin_block
block|{
return|return
name|FT_MulFix
argument_list|(
name|CUR
operator|.
name|tt_metrics
operator|.
name|ppem
argument_list|,
name|CURRENT_Ratio
argument_list|()
argument_list|)
return|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* Functions related to the control value table (CVT).                   */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_F26Dot6
argument_list|)
end_macro
begin_macro
name|Read_CVT
argument_list|(
argument|EXEC_OP_ FT_ULong  idx
argument_list|)
end_macro
begin_block
block|{
return|return
name|CUR
operator|.
name|cvt
index|[
name|idx
index|]
return|;
block|}
end_block
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_F26Dot6
argument_list|)
end_macro
begin_macro
name|Read_CVT_Stretched
argument_list|(
argument|EXEC_OP_ FT_ULong  idx
argument_list|)
end_macro
begin_block
block|{
return|return
name|FT_MulFix
argument_list|(
name|CUR
operator|.
name|cvt
index|[
name|idx
index|]
argument_list|,
name|CURRENT_Ratio
argument_list|()
argument_list|)
return|;
block|}
end_block
begin_macro
name|FT_CALLBACK_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|Write_CVT
name|Write_CVT
argument_list|(
argument|EXEC_OP_ FT_ULong    idx
argument_list|,
argument|FT_F26Dot6  value
argument_list|)
end_macro
begin_block
block|{
name|CUR
operator|.
name|cvt
index|[
name|idx
index|]
operator|=
name|value
expr_stmt|;
block|}
end_block
begin_macro
name|FT_CALLBACK_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|Write_CVT_Stretched
name|Write_CVT_Stretched
argument_list|(
argument|EXEC_OP_ FT_ULong    idx
argument_list|,
argument|FT_F26Dot6  value
argument_list|)
end_macro
begin_block
block|{
name|CUR
operator|.
name|cvt
index|[
name|idx
index|]
operator|=
name|FT_DivFix
argument_list|(
name|value
argument_list|,
name|CURRENT_Ratio
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_block
begin_macro
name|FT_CALLBACK_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|Move_CVT
name|Move_CVT
argument_list|(
argument|EXEC_OP_ FT_ULong    idx
argument_list|,
argument|FT_F26Dot6  value
argument_list|)
end_macro
begin_block
block|{
name|CUR
operator|.
name|cvt
index|[
name|idx
index|]
operator|+=
name|value
expr_stmt|;
block|}
end_block
begin_macro
name|FT_CALLBACK_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|Move_CVT_Stretched
name|Move_CVT_Stretched
argument_list|(
argument|EXEC_OP_ FT_ULong    idx
argument_list|,
argument|FT_F26Dot6  value
argument_list|)
end_macro
begin_block
block|{
name|CUR
operator|.
name|cvt
index|[
name|idx
index|]
operator|+=
name|FT_DivFix
argument_list|(
name|value
argument_list|,
name|CURRENT_Ratio
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    GetShortIns                                                        */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Returns a short integer taken from the instruction stream at       */
end_comment
begin_comment
comment|/*    address IP.                                                        */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    Short read at code[IP].                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Note>                                                                */
end_comment
begin_comment
comment|/*    This one could become a macro.                                     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|FT_Short
DECL|function|GetShortIns
name|GetShortIns
parameter_list|(
name|EXEC_OP
parameter_list|)
block|{
comment|/* Reading a byte stream so there is no endianess (DaveP) */
name|CUR
operator|.
name|IP
operator|+=
literal|2
expr_stmt|;
return|return
call|(
name|FT_Short
call|)
argument_list|(
operator|(
name|CUR
operator|.
name|code
index|[
name|CUR
operator|.
name|IP
operator|-
literal|2
index|]
operator|<<
literal|8
operator|)
operator|+
name|CUR
operator|.
name|code
index|[
name|CUR
operator|.
name|IP
operator|-
literal|1
index|]
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    Ins_Goto_CodeRange                                                 */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Goes to a certain code range in the instruction stream.            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    aRange :: The index of the code range.                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    aIP    :: The new IP address in the code range.                    */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    SUCCESS or FAILURE.                                                */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|FT_Bool
DECL|function|Ins_Goto_CodeRange
name|Ins_Goto_CodeRange
parameter_list|(
name|EXEC_OP_
name|FT_Int
name|aRange
parameter_list|,
name|FT_ULong
name|aIP
parameter_list|)
block|{
name|TT_CodeRange
modifier|*
name|range
decl_stmt|;
if|if
condition|(
name|aRange
operator|<
literal|1
operator|||
name|aRange
operator|>
literal|3
condition|)
block|{
name|CUR
operator|.
name|error
operator|=
name|FT_THROW
argument_list|(
name|Bad_Argument
argument_list|)
expr_stmt|;
return|return
name|FAILURE
return|;
block|}
name|range
operator|=
operator|&
name|CUR
operator|.
name|codeRangeTable
index|[
name|aRange
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|range
operator|->
name|base
operator|==
name|NULL
condition|)
comment|/* invalid coderange */
block|{
name|CUR
operator|.
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_CodeRange
argument_list|)
expr_stmt|;
return|return
name|FAILURE
return|;
block|}
comment|/* NOTE: Because the last instruction of a program may be a CALL */
comment|/*       which will return to the first byte *after* the code    */
comment|/*       range, we test for aIP<= Size, instead of aIP< Size.  */
if|if
condition|(
name|aIP
operator|>
name|range
operator|->
name|size
condition|)
block|{
name|CUR
operator|.
name|error
operator|=
name|FT_THROW
argument_list|(
name|Code_Overflow
argument_list|)
expr_stmt|;
return|return
name|FAILURE
return|;
block|}
name|CUR
operator|.
name|code
operator|=
name|range
operator|->
name|base
expr_stmt|;
name|CUR
operator|.
name|codeSize
operator|=
name|range
operator|->
name|size
expr_stmt|;
name|CUR
operator|.
name|IP
operator|=
name|aIP
expr_stmt|;
name|CUR
operator|.
name|curRange
operator|=
name|aRange
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    Direct_Move                                                        */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Moves a point by a given distance along the freedom vector.  The   */
end_comment
begin_comment
comment|/*    point will be `touched'.                                           */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    point    :: The index of the point to move.                        */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    distance :: The distance to apply.                                 */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<InOut>                                                               */
end_comment
begin_comment
comment|/*    zone     :: The affected glyph zone.                               */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Direct_Move
name|Direct_Move
parameter_list|(
name|EXEC_OP_
name|TT_GlyphZone
name|zone
parameter_list|,
name|FT_UShort
name|point
parameter_list|,
name|FT_F26Dot6
name|distance
parameter_list|)
block|{
name|FT_F26Dot6
name|v
decl_stmt|;
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_UNPATENTED_HINTING
name|FT_ASSERT
argument_list|(
operator|!
name|CUR
operator|.
name|face
operator|->
name|unpatented_hinting
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|v
operator|=
name|CUR
operator|.
name|GS
operator|.
name|freeVector
operator|.
name|x
expr_stmt|;
if|if
condition|(
name|v
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_SUBPIXEL_HINTING
if|if
condition|(
operator|!
name|SUBPIXEL_HINTING
operator|||
operator|(
operator|!
name|CUR
operator|.
name|ignore_x_mode
operator|||
operator|(
name|CUR
operator|.
name|sph_tweak_flags
operator|&
name|SPH_TWEAK_ALLOW_X_DMOVE
operator|)
operator|)
condition|)
endif|#
directive|endif
comment|/* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
name|zone
operator|->
name|cur
index|[
name|point
index|]
operator|.
name|x
operator|+=
name|FT_MulDiv
argument_list|(
name|distance
argument_list|,
name|v
argument_list|,
name|CUR
operator|.
name|F_dot_P
argument_list|)
expr_stmt|;
name|zone
operator|->
name|tags
index|[
name|point
index|]
operator||=
name|FT_CURVE_TAG_TOUCH_X
expr_stmt|;
block|}
name|v
operator|=
name|CUR
operator|.
name|GS
operator|.
name|freeVector
operator|.
name|y
expr_stmt|;
if|if
condition|(
name|v
operator|!=
literal|0
condition|)
block|{
name|zone
operator|->
name|cur
index|[
name|point
index|]
operator|.
name|y
operator|+=
name|FT_MulDiv
argument_list|(
name|distance
argument_list|,
name|v
argument_list|,
name|CUR
operator|.
name|F_dot_P
argument_list|)
expr_stmt|;
name|zone
operator|->
name|tags
index|[
name|point
index|]
operator||=
name|FT_CURVE_TAG_TOUCH_Y
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    Direct_Move_Orig                                                   */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Moves the *original* position of a point by a given distance along */
end_comment
begin_comment
comment|/*    the freedom vector.  Obviously, the point will not be `touched'.   */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    point    :: The index of the point to move.                        */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    distance :: The distance to apply.                                 */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<InOut>                                                               */
end_comment
begin_comment
comment|/*    zone     :: The affected glyph zone.                               */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Direct_Move_Orig
name|Direct_Move_Orig
parameter_list|(
name|EXEC_OP_
name|TT_GlyphZone
name|zone
parameter_list|,
name|FT_UShort
name|point
parameter_list|,
name|FT_F26Dot6
name|distance
parameter_list|)
block|{
name|FT_F26Dot6
name|v
decl_stmt|;
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_UNPATENTED_HINTING
name|FT_ASSERT
argument_list|(
operator|!
name|CUR
operator|.
name|face
operator|->
name|unpatented_hinting
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|v
operator|=
name|CUR
operator|.
name|GS
operator|.
name|freeVector
operator|.
name|x
expr_stmt|;
if|if
condition|(
name|v
operator|!=
literal|0
condition|)
name|zone
operator|->
name|org
index|[
name|point
index|]
operator|.
name|x
operator|+=
name|FT_MulDiv
argument_list|(
name|distance
argument_list|,
name|v
argument_list|,
name|CUR
operator|.
name|F_dot_P
argument_list|)
expr_stmt|;
name|v
operator|=
name|CUR
operator|.
name|GS
operator|.
name|freeVector
operator|.
name|y
expr_stmt|;
if|if
condition|(
name|v
operator|!=
literal|0
condition|)
name|zone
operator|->
name|org
index|[
name|point
index|]
operator|.
name|y
operator|+=
name|FT_MulDiv
argument_list|(
name|distance
argument_list|,
name|v
argument_list|,
name|CUR
operator|.
name|F_dot_P
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* Special versions of Direct_Move()                                     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*   The following versions are used whenever both vectors are both      */
end_comment
begin_comment
comment|/*   along one of the coordinate unit vectors, i.e. in 90% of the cases. */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_function
specifier|static
name|void
DECL|function|Direct_Move_X
name|Direct_Move_X
parameter_list|(
name|EXEC_OP_
name|TT_GlyphZone
name|zone
parameter_list|,
name|FT_UShort
name|point
parameter_list|,
name|FT_F26Dot6
name|distance
parameter_list|)
block|{
name|FT_UNUSED_EXEC
expr_stmt|;
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_SUBPIXEL_HINTING
if|if
condition|(
operator|!
name|SUBPIXEL_HINTING
operator|||
operator|!
name|CUR
operator|.
name|ignore_x_mode
condition|)
endif|#
directive|endif
comment|/* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
name|zone
operator|->
name|cur
index|[
name|point
index|]
operator|.
name|x
operator|+=
name|distance
expr_stmt|;
name|zone
operator|->
name|tags
index|[
name|point
index|]
operator||=
name|FT_CURVE_TAG_TOUCH_X
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|Direct_Move_Y
name|Direct_Move_Y
parameter_list|(
name|EXEC_OP_
name|TT_GlyphZone
name|zone
parameter_list|,
name|FT_UShort
name|point
parameter_list|,
name|FT_F26Dot6
name|distance
parameter_list|)
block|{
name|FT_UNUSED_EXEC
expr_stmt|;
name|zone
operator|->
name|cur
index|[
name|point
index|]
operator|.
name|y
operator|+=
name|distance
expr_stmt|;
name|zone
operator|->
name|tags
index|[
name|point
index|]
operator||=
name|FT_CURVE_TAG_TOUCH_Y
expr_stmt|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* Special versions of Direct_Move_Orig()                                */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*   The following versions are used whenever both vectors are both      */
end_comment
begin_comment
comment|/*   along one of the coordinate unit vectors, i.e. in 90% of the cases. */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_function
specifier|static
name|void
DECL|function|Direct_Move_Orig_X
name|Direct_Move_Orig_X
parameter_list|(
name|EXEC_OP_
name|TT_GlyphZone
name|zone
parameter_list|,
name|FT_UShort
name|point
parameter_list|,
name|FT_F26Dot6
name|distance
parameter_list|)
block|{
name|FT_UNUSED_EXEC
expr_stmt|;
name|zone
operator|->
name|org
index|[
name|point
index|]
operator|.
name|x
operator|+=
name|distance
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|Direct_Move_Orig_Y
name|Direct_Move_Orig_Y
parameter_list|(
name|EXEC_OP_
name|TT_GlyphZone
name|zone
parameter_list|,
name|FT_UShort
name|point
parameter_list|,
name|FT_F26Dot6
name|distance
parameter_list|)
block|{
name|FT_UNUSED_EXEC
expr_stmt|;
name|zone
operator|->
name|org
index|[
name|point
index|]
operator|.
name|y
operator|+=
name|distance
expr_stmt|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    Round_None                                                         */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Does not round, but adds engine compensation.                      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    distance     :: The distance (not) to round.                       */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    compensation :: The engine compensation.                           */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    The compensated distance.                                          */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Note>                                                                */
end_comment
begin_comment
comment|/*    The TrueType specification says very few about the relationship    */
end_comment
begin_comment
comment|/*    between rounding and engine compensation.  However, it seems from  */
end_comment
begin_comment
comment|/*    the description of super round that we should add the compensation */
end_comment
begin_comment
comment|/*    before rounding.                                                   */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|FT_F26Dot6
DECL|function|Round_None
name|Round_None
parameter_list|(
name|EXEC_OP_
name|FT_F26Dot6
name|distance
parameter_list|,
name|FT_F26Dot6
name|compensation
parameter_list|)
block|{
name|FT_F26Dot6
name|val
decl_stmt|;
name|FT_UNUSED_EXEC
expr_stmt|;
if|if
condition|(
name|distance
operator|>=
literal|0
condition|)
block|{
name|val
operator|=
name|distance
operator|+
name|compensation
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|val
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|val
operator|=
name|distance
operator|-
name|compensation
expr_stmt|;
if|if
condition|(
name|val
operator|>
literal|0
condition|)
name|val
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    Round_To_Grid                                                      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Rounds value to grid after adding engine compensation.             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    distance     :: The distance to round.                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    compensation :: The engine compensation.                           */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    Rounded distance.                                                  */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|FT_F26Dot6
DECL|function|Round_To_Grid
name|Round_To_Grid
parameter_list|(
name|EXEC_OP_
name|FT_F26Dot6
name|distance
parameter_list|,
name|FT_F26Dot6
name|compensation
parameter_list|)
block|{
name|FT_F26Dot6
name|val
decl_stmt|;
name|FT_UNUSED_EXEC
expr_stmt|;
if|if
condition|(
name|distance
operator|>=
literal|0
condition|)
block|{
name|val
operator|=
name|FT_PIX_ROUND
argument_list|(
name|distance
operator|+
name|compensation
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|val
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|val
operator|=
operator|-
name|FT_PIX_ROUND
argument_list|(
name|compensation
operator|-
name|distance
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|>
literal|0
condition|)
name|val
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    Round_To_Half_Grid                                                 */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Rounds value to half grid after adding engine compensation.        */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    distance     :: The distance to round.                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    compensation :: The engine compensation.                           */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    Rounded distance.                                                  */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|FT_F26Dot6
DECL|function|Round_To_Half_Grid
name|Round_To_Half_Grid
parameter_list|(
name|EXEC_OP_
name|FT_F26Dot6
name|distance
parameter_list|,
name|FT_F26Dot6
name|compensation
parameter_list|)
block|{
name|FT_F26Dot6
name|val
decl_stmt|;
name|FT_UNUSED_EXEC
expr_stmt|;
if|if
condition|(
name|distance
operator|>=
literal|0
condition|)
block|{
name|val
operator|=
name|FT_PIX_FLOOR
argument_list|(
name|distance
operator|+
name|compensation
argument_list|)
operator|+
literal|32
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|val
operator|=
literal|32
expr_stmt|;
block|}
else|else
block|{
name|val
operator|=
operator|-
operator|(
name|FT_PIX_FLOOR
argument_list|(
name|compensation
operator|-
name|distance
argument_list|)
operator|+
literal|32
operator|)
expr_stmt|;
if|if
condition|(
name|val
operator|>
literal|0
condition|)
name|val
operator|=
operator|-
literal|32
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    Round_Down_To_Grid                                                 */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Rounds value down to grid after adding engine compensation.        */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    distance     :: The distance to round.                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    compensation :: The engine compensation.                           */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    Rounded distance.                                                  */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|FT_F26Dot6
DECL|function|Round_Down_To_Grid
name|Round_Down_To_Grid
parameter_list|(
name|EXEC_OP_
name|FT_F26Dot6
name|distance
parameter_list|,
name|FT_F26Dot6
name|compensation
parameter_list|)
block|{
name|FT_F26Dot6
name|val
decl_stmt|;
name|FT_UNUSED_EXEC
expr_stmt|;
if|if
condition|(
name|distance
operator|>=
literal|0
condition|)
block|{
name|val
operator|=
name|FT_PIX_FLOOR
argument_list|(
name|distance
operator|+
name|compensation
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|val
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|val
operator|=
operator|-
name|FT_PIX_FLOOR
argument_list|(
name|compensation
operator|-
name|distance
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|>
literal|0
condition|)
name|val
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    Round_Up_To_Grid                                                   */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Rounds value up to grid after adding engine compensation.          */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    distance     :: The distance to round.                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    compensation :: The engine compensation.                           */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    Rounded distance.                                                  */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|FT_F26Dot6
DECL|function|Round_Up_To_Grid
name|Round_Up_To_Grid
parameter_list|(
name|EXEC_OP_
name|FT_F26Dot6
name|distance
parameter_list|,
name|FT_F26Dot6
name|compensation
parameter_list|)
block|{
name|FT_F26Dot6
name|val
decl_stmt|;
name|FT_UNUSED_EXEC
expr_stmt|;
if|if
condition|(
name|distance
operator|>=
literal|0
condition|)
block|{
name|val
operator|=
name|FT_PIX_CEIL
argument_list|(
name|distance
operator|+
name|compensation
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|val
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|val
operator|=
operator|-
name|FT_PIX_CEIL
argument_list|(
name|compensation
operator|-
name|distance
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|>
literal|0
condition|)
name|val
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    Round_To_Double_Grid                                               */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Rounds value to double grid after adding engine compensation.      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    distance     :: The distance to round.                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    compensation :: The engine compensation.                           */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    Rounded distance.                                                  */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|FT_F26Dot6
DECL|function|Round_To_Double_Grid
name|Round_To_Double_Grid
parameter_list|(
name|EXEC_OP_
name|FT_F26Dot6
name|distance
parameter_list|,
name|FT_F26Dot6
name|compensation
parameter_list|)
block|{
name|FT_F26Dot6
name|val
decl_stmt|;
name|FT_UNUSED_EXEC
expr_stmt|;
if|if
condition|(
name|distance
operator|>=
literal|0
condition|)
block|{
name|val
operator|=
name|FT_PAD_ROUND
argument_list|(
name|distance
operator|+
name|compensation
argument_list|,
literal|32
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|val
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|val
operator|=
operator|-
name|FT_PAD_ROUND
argument_list|(
name|compensation
operator|-
name|distance
argument_list|,
literal|32
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|>
literal|0
condition|)
name|val
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    Round_Super                                                        */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Super-rounds value to grid after adding engine compensation.       */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    distance     :: The distance to round.                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    compensation :: The engine compensation.                           */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    Rounded distance.                                                  */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Note>                                                                */
end_comment
begin_comment
comment|/*    The TrueType specification says very few about the relationship    */
end_comment
begin_comment
comment|/*    between rounding and engine compensation.  However, it seems from  */
end_comment
begin_comment
comment|/*    the description of super round that we should add the compensation */
end_comment
begin_comment
comment|/*    before rounding.                                                   */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|FT_F26Dot6
DECL|function|Round_Super
name|Round_Super
parameter_list|(
name|EXEC_OP_
name|FT_F26Dot6
name|distance
parameter_list|,
name|FT_F26Dot6
name|compensation
parameter_list|)
block|{
name|FT_F26Dot6
name|val
decl_stmt|;
if|if
condition|(
name|distance
operator|>=
literal|0
condition|)
block|{
name|val
operator|=
operator|(
name|distance
operator|-
name|CUR
operator|.
name|phase
operator|+
name|CUR
operator|.
name|threshold
operator|+
name|compensation
operator|)
operator|&
operator|-
name|CUR
operator|.
name|period
expr_stmt|;
name|val
operator|+=
name|CUR
operator|.
name|phase
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|val
operator|=
name|CUR
operator|.
name|phase
expr_stmt|;
block|}
else|else
block|{
name|val
operator|=
operator|-
operator|(
operator|(
name|CUR
operator|.
name|threshold
operator|-
name|CUR
operator|.
name|phase
operator|-
name|distance
operator|+
name|compensation
operator|)
operator|&
operator|-
name|CUR
operator|.
name|period
operator|)
expr_stmt|;
name|val
operator|-=
name|CUR
operator|.
name|phase
expr_stmt|;
if|if
condition|(
name|val
operator|>
literal|0
condition|)
name|val
operator|=
operator|-
name|CUR
operator|.
name|phase
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    Round_Super_45                                                     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Super-rounds value to grid after adding engine compensation.       */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    distance     :: The distance to round.                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    compensation :: The engine compensation.                           */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    Rounded distance.                                                  */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Note>                                                                */
end_comment
begin_comment
comment|/*    There is a separate function for Round_Super_45() as we may need   */
end_comment
begin_comment
comment|/*    greater precision.                                                 */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|FT_F26Dot6
DECL|function|Round_Super_45
name|Round_Super_45
parameter_list|(
name|EXEC_OP_
name|FT_F26Dot6
name|distance
parameter_list|,
name|FT_F26Dot6
name|compensation
parameter_list|)
block|{
name|FT_F26Dot6
name|val
decl_stmt|;
if|if
condition|(
name|distance
operator|>=
literal|0
condition|)
block|{
name|val
operator|=
operator|(
operator|(
name|distance
operator|-
name|CUR
operator|.
name|phase
operator|+
name|CUR
operator|.
name|threshold
operator|+
name|compensation
operator|)
operator|/
name|CUR
operator|.
name|period
operator|)
operator|*
name|CUR
operator|.
name|period
expr_stmt|;
name|val
operator|+=
name|CUR
operator|.
name|phase
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|val
operator|=
name|CUR
operator|.
name|phase
expr_stmt|;
block|}
else|else
block|{
name|val
operator|=
operator|-
operator|(
operator|(
operator|(
name|CUR
operator|.
name|threshold
operator|-
name|CUR
operator|.
name|phase
operator|-
name|distance
operator|+
name|compensation
operator|)
operator|/
name|CUR
operator|.
name|period
operator|)
operator|*
name|CUR
operator|.
name|period
operator|)
expr_stmt|;
name|val
operator|-=
name|CUR
operator|.
name|phase
expr_stmt|;
if|if
condition|(
name|val
operator|>
literal|0
condition|)
name|val
operator|=
operator|-
name|CUR
operator|.
name|phase
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    Compute_Round                                                      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Sets the rounding mode.                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    round_mode :: The rounding mode to be used.                        */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Compute_Round
name|Compute_Round
parameter_list|(
name|EXEC_OP_
name|FT_Byte
name|round_mode
parameter_list|)
block|{
switch|switch
condition|(
name|round_mode
condition|)
block|{
case|case
name|TT_Round_Off
case|:
name|CUR
operator|.
name|func_round
operator|=
operator|(
name|TT_Round_Func
operator|)
name|Round_None
expr_stmt|;
break|break;
case|case
name|TT_Round_To_Grid
case|:
name|CUR
operator|.
name|func_round
operator|=
operator|(
name|TT_Round_Func
operator|)
name|Round_To_Grid
expr_stmt|;
break|break;
case|case
name|TT_Round_Up_To_Grid
case|:
name|CUR
operator|.
name|func_round
operator|=
operator|(
name|TT_Round_Func
operator|)
name|Round_Up_To_Grid
expr_stmt|;
break|break;
case|case
name|TT_Round_Down_To_Grid
case|:
name|CUR
operator|.
name|func_round
operator|=
operator|(
name|TT_Round_Func
operator|)
name|Round_Down_To_Grid
expr_stmt|;
break|break;
case|case
name|TT_Round_To_Half_Grid
case|:
name|CUR
operator|.
name|func_round
operator|=
operator|(
name|TT_Round_Func
operator|)
name|Round_To_Half_Grid
expr_stmt|;
break|break;
case|case
name|TT_Round_To_Double_Grid
case|:
name|CUR
operator|.
name|func_round
operator|=
operator|(
name|TT_Round_Func
operator|)
name|Round_To_Double_Grid
expr_stmt|;
break|break;
case|case
name|TT_Round_Super
case|:
name|CUR
operator|.
name|func_round
operator|=
operator|(
name|TT_Round_Func
operator|)
name|Round_Super
expr_stmt|;
break|break;
case|case
name|TT_Round_Super_45
case|:
name|CUR
operator|.
name|func_round
operator|=
operator|(
name|TT_Round_Func
operator|)
name|Round_Super_45
expr_stmt|;
break|break;
block|}
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    SetSuperRound                                                      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Sets Super Round parameters.                                       */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    GridPeriod :: The grid period.                                     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    selector   :: The SROUND opcode.                                   */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|SetSuperRound
name|SetSuperRound
parameter_list|(
name|EXEC_OP_
name|FT_F26Dot6
name|GridPeriod
parameter_list|,
name|FT_Long
name|selector
parameter_list|)
block|{
switch|switch
condition|(
call|(
name|FT_Int
call|)
argument_list|(
name|selector
operator|&
literal|0xC0
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|CUR
operator|.
name|period
operator|=
name|GridPeriod
operator|/
literal|2
expr_stmt|;
break|break;
case|case
literal|0x40
case|:
name|CUR
operator|.
name|period
operator|=
name|GridPeriod
expr_stmt|;
break|break;
case|case
literal|0x80
case|:
name|CUR
operator|.
name|period
operator|=
name|GridPeriod
operator|*
literal|2
expr_stmt|;
break|break;
comment|/* This opcode is reserved, but... */
case|case
literal|0xC0
case|:
name|CUR
operator|.
name|period
operator|=
name|GridPeriod
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
call|(
name|FT_Int
call|)
argument_list|(
name|selector
operator|&
literal|0x30
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|CUR
operator|.
name|phase
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|0x10
case|:
name|CUR
operator|.
name|phase
operator|=
name|CUR
operator|.
name|period
operator|/
literal|4
expr_stmt|;
break|break;
case|case
literal|0x20
case|:
name|CUR
operator|.
name|phase
operator|=
name|CUR
operator|.
name|period
operator|/
literal|2
expr_stmt|;
break|break;
case|case
literal|0x30
case|:
name|CUR
operator|.
name|phase
operator|=
name|CUR
operator|.
name|period
operator|*
literal|3
operator|/
literal|4
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|selector
operator|&
literal|0x0F
operator|)
operator|==
literal|0
condition|)
name|CUR
operator|.
name|threshold
operator|=
name|CUR
operator|.
name|period
operator|-
literal|1
expr_stmt|;
else|else
name|CUR
operator|.
name|threshold
operator|=
operator|(
call|(
name|FT_Int
call|)
argument_list|(
name|selector
operator|&
literal|0x0F
argument_list|)
operator|-
literal|4
operator|)
operator|*
name|CUR
operator|.
name|period
operator|/
literal|8
expr_stmt|;
name|CUR
operator|.
name|period
operator|/=
literal|256
expr_stmt|;
name|CUR
operator|.
name|phase
operator|/=
literal|256
expr_stmt|;
name|CUR
operator|.
name|threshold
operator|/=
literal|256
expr_stmt|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    Project                                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Computes the projection of vector given by (v2-v1) along the       */
end_comment
begin_comment
comment|/*    current projection vector.                                         */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    v1 :: First input vector.                                          */
end_comment
begin_comment
comment|/*    v2 :: Second input vector.                                         */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    The distance in F26dot6 format.                                    */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|FT_F26Dot6
DECL|function|Project
name|Project
parameter_list|(
name|EXEC_OP_
name|FT_Pos
name|dx
parameter_list|,
name|FT_Pos
name|dy
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_UNPATENTED_HINTING
name|FT_ASSERT
argument_list|(
operator|!
name|CUR
operator|.
name|face
operator|->
name|unpatented_hinting
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|TT_DotFix14
argument_list|(
operator|(
name|FT_UInt32
operator|)
name|dx
argument_list|,
operator|(
name|FT_UInt32
operator|)
name|dy
argument_list|,
name|CUR
operator|.
name|GS
operator|.
name|projVector
operator|.
name|x
argument_list|,
name|CUR
operator|.
name|GS
operator|.
name|projVector
operator|.
name|y
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    Dual_Project                                                       */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Computes the projection of the vector given by (v2-v1) along the   */
end_comment
begin_comment
comment|/*    current dual vector.                                               */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    v1 :: First input vector.                                          */
end_comment
begin_comment
comment|/*    v2 :: Second input vector.                                         */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    The distance in F26dot6 format.                                    */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|FT_F26Dot6
DECL|function|Dual_Project
name|Dual_Project
parameter_list|(
name|EXEC_OP_
name|FT_Pos
name|dx
parameter_list|,
name|FT_Pos
name|dy
parameter_list|)
block|{
return|return
name|TT_DotFix14
argument_list|(
operator|(
name|FT_UInt32
operator|)
name|dx
argument_list|,
operator|(
name|FT_UInt32
operator|)
name|dy
argument_list|,
name|CUR
operator|.
name|GS
operator|.
name|dualVector
operator|.
name|x
argument_list|,
name|CUR
operator|.
name|GS
operator|.
name|dualVector
operator|.
name|y
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    Project_x                                                          */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Computes the projection of the vector given by (v2-v1) along the   */
end_comment
begin_comment
comment|/*    horizontal axis.                                                   */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    v1 :: First input vector.                                          */
end_comment
begin_comment
comment|/*    v2 :: Second input vector.                                         */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    The distance in F26dot6 format.                                    */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|FT_F26Dot6
DECL|function|Project_x
name|Project_x
parameter_list|(
name|EXEC_OP_
name|FT_Pos
name|dx
parameter_list|,
name|FT_Pos
name|dy
parameter_list|)
block|{
name|FT_UNUSED_EXEC
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|dy
argument_list|)
expr_stmt|;
return|return
name|dx
return|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    Project_y                                                          */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Computes the projection of the vector given by (v2-v1) along the   */
end_comment
begin_comment
comment|/*    vertical axis.                                                     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    v1 :: First input vector.                                          */
end_comment
begin_comment
comment|/*    v2 :: Second input vector.                                         */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    The distance in F26dot6 format.                                    */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|FT_F26Dot6
DECL|function|Project_y
name|Project_y
parameter_list|(
name|EXEC_OP_
name|FT_Pos
name|dx
parameter_list|,
name|FT_Pos
name|dy
parameter_list|)
block|{
name|FT_UNUSED_EXEC
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|dx
argument_list|)
expr_stmt|;
return|return
name|dy
return|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    Compute_Funcs                                                      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Computes the projection and movement function pointers according   */
end_comment
begin_comment
comment|/*    to the current graphics state.                                     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Compute_Funcs
name|Compute_Funcs
parameter_list|(
name|EXEC_OP
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_UNPATENTED_HINTING
if|if
condition|(
name|CUR
operator|.
name|face
operator|->
name|unpatented_hinting
condition|)
block|{
comment|/* If both vectors point rightwards along the x axis, set             */
comment|/* `both-x-axis' true, otherwise set it false.  The x values only     */
comment|/* need be tested because the vector has been normalised to a unit    */
comment|/* vector of length 0x4000 = unity.                                   */
name|CUR
operator|.
name|GS
operator|.
name|both_x_axis
operator|=
call|(
name|FT_Bool
call|)
argument_list|(
name|CUR
operator|.
name|GS
operator|.
name|projVector
operator|.
name|x
operator|==
literal|0x4000
operator|&&
name|CUR
operator|.
name|GS
operator|.
name|freeVector
operator|.
name|x
operator|==
literal|0x4000
argument_list|)
expr_stmt|;
comment|/* Throw away projection and freedom vector information */
comment|/* because the patents don't allow them to be stored.   */
comment|/* The relevant US Patents are 5155805 and 5325479.     */
name|CUR
operator|.
name|GS
operator|.
name|projVector
operator|.
name|x
operator|=
literal|0
expr_stmt|;
name|CUR
operator|.
name|GS
operator|.
name|projVector
operator|.
name|y
operator|=
literal|0
expr_stmt|;
name|CUR
operator|.
name|GS
operator|.
name|freeVector
operator|.
name|x
operator|=
literal|0
expr_stmt|;
name|CUR
operator|.
name|GS
operator|.
name|freeVector
operator|.
name|y
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|CUR
operator|.
name|GS
operator|.
name|both_x_axis
condition|)
block|{
name|CUR
operator|.
name|func_project
operator|=
name|Project_x
expr_stmt|;
name|CUR
operator|.
name|func_move
operator|=
name|Direct_Move_X
expr_stmt|;
name|CUR
operator|.
name|func_move_orig
operator|=
name|Direct_Move_Orig_X
expr_stmt|;
block|}
else|else
block|{
name|CUR
operator|.
name|func_project
operator|=
name|Project_y
expr_stmt|;
name|CUR
operator|.
name|func_move
operator|=
name|Direct_Move_Y
expr_stmt|;
name|CUR
operator|.
name|func_move_orig
operator|=
name|Direct_Move_Orig_Y
expr_stmt|;
block|}
if|if
condition|(
name|CUR
operator|.
name|GS
operator|.
name|dualVector
operator|.
name|x
operator|==
literal|0x4000
condition|)
name|CUR
operator|.
name|func_dualproj
operator|=
name|Project_x
expr_stmt|;
elseif|else
if|if
condition|(
name|CUR
operator|.
name|GS
operator|.
name|dualVector
operator|.
name|y
operator|==
literal|0x4000
condition|)
name|CUR
operator|.
name|func_dualproj
operator|=
name|Project_y
expr_stmt|;
else|else
name|CUR
operator|.
name|func_dualproj
operator|=
name|Dual_Project
expr_stmt|;
comment|/* Force recalculation of cached aspect ratio */
name|CUR
operator|.
name|tt_metrics
operator|.
name|ratio
operator|=
literal|0
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* TT_CONFIG_OPTION_UNPATENTED_HINTING */
if|if
condition|(
name|CUR
operator|.
name|GS
operator|.
name|freeVector
operator|.
name|x
operator|==
literal|0x4000
condition|)
name|CUR
operator|.
name|F_dot_P
operator|=
name|CUR
operator|.
name|GS
operator|.
name|projVector
operator|.
name|x
expr_stmt|;
elseif|else
if|if
condition|(
name|CUR
operator|.
name|GS
operator|.
name|freeVector
operator|.
name|y
operator|==
literal|0x4000
condition|)
name|CUR
operator|.
name|F_dot_P
operator|=
name|CUR
operator|.
name|GS
operator|.
name|projVector
operator|.
name|y
expr_stmt|;
else|else
name|CUR
operator|.
name|F_dot_P
operator|=
operator|(
operator|(
name|FT_Long
operator|)
name|CUR
operator|.
name|GS
operator|.
name|projVector
operator|.
name|x
operator|*
name|CUR
operator|.
name|GS
operator|.
name|freeVector
operator|.
name|x
operator|+
operator|(
name|FT_Long
operator|)
name|CUR
operator|.
name|GS
operator|.
name|projVector
operator|.
name|y
operator|*
name|CUR
operator|.
name|GS
operator|.
name|freeVector
operator|.
name|y
operator|)
operator|>>
literal|14
expr_stmt|;
if|if
condition|(
name|CUR
operator|.
name|GS
operator|.
name|projVector
operator|.
name|x
operator|==
literal|0x4000
condition|)
name|CUR
operator|.
name|func_project
operator|=
operator|(
name|TT_Project_Func
operator|)
name|Project_x
expr_stmt|;
elseif|else
if|if
condition|(
name|CUR
operator|.
name|GS
operator|.
name|projVector
operator|.
name|y
operator|==
literal|0x4000
condition|)
name|CUR
operator|.
name|func_project
operator|=
operator|(
name|TT_Project_Func
operator|)
name|Project_y
expr_stmt|;
else|else
name|CUR
operator|.
name|func_project
operator|=
operator|(
name|TT_Project_Func
operator|)
name|Project
expr_stmt|;
if|if
condition|(
name|CUR
operator|.
name|GS
operator|.
name|dualVector
operator|.
name|x
operator|==
literal|0x4000
condition|)
name|CUR
operator|.
name|func_dualproj
operator|=
operator|(
name|TT_Project_Func
operator|)
name|Project_x
expr_stmt|;
elseif|else
if|if
condition|(
name|CUR
operator|.
name|GS
operator|.
name|dualVector
operator|.
name|y
operator|==
literal|0x4000
condition|)
name|CUR
operator|.
name|func_dualproj
operator|=
operator|(
name|TT_Project_Func
operator|)
name|Project_y
expr_stmt|;
else|else
name|CUR
operator|.
name|func_dualproj
operator|=
operator|(
name|TT_Project_Func
operator|)
name|Dual_Project
expr_stmt|;
name|CUR
operator|.
name|func_move
operator|=
operator|(
name|TT_Move_Func
operator|)
name|Direct_Move
expr_stmt|;
name|CUR
operator|.
name|func_move_orig
operator|=
operator|(
name|TT_Move_Func
operator|)
name|Direct_Move_Orig
expr_stmt|;
if|if
condition|(
name|CUR
operator|.
name|F_dot_P
operator|==
literal|0x4000L
condition|)
block|{
if|if
condition|(
name|CUR
operator|.
name|GS
operator|.
name|freeVector
operator|.
name|x
operator|==
literal|0x4000
condition|)
block|{
name|CUR
operator|.
name|func_move
operator|=
operator|(
name|TT_Move_Func
operator|)
name|Direct_Move_X
expr_stmt|;
name|CUR
operator|.
name|func_move_orig
operator|=
operator|(
name|TT_Move_Func
operator|)
name|Direct_Move_Orig_X
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CUR
operator|.
name|GS
operator|.
name|freeVector
operator|.
name|y
operator|==
literal|0x4000
condition|)
block|{
name|CUR
operator|.
name|func_move
operator|=
operator|(
name|TT_Move_Func
operator|)
name|Direct_Move_Y
expr_stmt|;
name|CUR
operator|.
name|func_move_orig
operator|=
operator|(
name|TT_Move_Func
operator|)
name|Direct_Move_Orig_Y
expr_stmt|;
block|}
block|}
comment|/* at small sizes, F_dot_P can become too small, resulting   */
comment|/* in overflows and `spikes' in a number of glyphs like `w'. */
if|if
condition|(
name|FT_ABS
argument_list|(
name|CUR
operator|.
name|F_dot_P
argument_list|)
operator|<
literal|0x400L
condition|)
name|CUR
operator|.
name|F_dot_P
operator|=
literal|0x4000L
expr_stmt|;
comment|/* Disable cached aspect ratio */
name|CUR
operator|.
name|tt_metrics
operator|.
name|ratio
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    Normalize                                                          */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Norms a vector.                                                    */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    Vx :: The horizontal input vector coordinate.                      */
end_comment
begin_comment
comment|/*    Vy :: The vertical input vector coordinate.                        */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Output>                                                              */
end_comment
begin_comment
comment|/*    R  :: The normed unit vector.                                      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    Returns FAILURE if a vector parameter is zero.                     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Note>                                                                */
end_comment
begin_comment
comment|/*    In case Vx and Vy are both zero, Normalize() returns SUCCESS, and  */
end_comment
begin_comment
comment|/*    R is undefined.                                                    */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|FT_Bool
DECL|function|Normalize
name|Normalize
parameter_list|(
name|EXEC_OP_
name|FT_F26Dot6
name|Vx
parameter_list|,
name|FT_F26Dot6
name|Vy
parameter_list|,
name|FT_UnitVector
modifier|*
name|R
parameter_list|)
block|{
name|FT_F26Dot6
name|W
decl_stmt|;
name|FT_UNUSED_EXEC
expr_stmt|;
if|if
condition|(
name|FT_ABS
argument_list|(
name|Vx
argument_list|)
operator|<
literal|0x4000L
operator|&&
name|FT_ABS
argument_list|(
name|Vy
argument_list|)
operator|<
literal|0x4000L
condition|)
block|{
if|if
condition|(
name|Vx
operator|==
literal|0
operator|&&
name|Vy
operator|==
literal|0
condition|)
block|{
comment|/* XXX: UNDOCUMENTED! It seems that it is possible to try   */
comment|/*      to normalize the vector (0,0).  Return immediately. */
return|return
name|SUCCESS
return|;
block|}
name|Vx
operator|*=
literal|0x4000
expr_stmt|;
name|Vy
operator|*=
literal|0x4000
expr_stmt|;
block|}
name|W
operator|=
name|FT_Hypot
argument_list|(
name|Vx
argument_list|,
name|Vy
argument_list|)
expr_stmt|;
name|R
operator|->
name|x
operator|=
operator|(
name|FT_F2Dot14
operator|)
name|TT_DivFix14
argument_list|(
name|Vx
argument_list|,
name|W
argument_list|)
expr_stmt|;
name|R
operator|->
name|y
operator|=
operator|(
name|FT_F2Dot14
operator|)
name|TT_DivFix14
argument_list|(
name|Vy
argument_list|,
name|W
argument_list|)
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* Here we start with the implementation of the various opcodes.         */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_function
specifier|static
name|FT_Bool
DECL|function|Ins_SxVTL
name|Ins_SxVTL
parameter_list|(
name|EXEC_OP_
name|FT_UShort
name|aIdx1
parameter_list|,
name|FT_UShort
name|aIdx2
parameter_list|,
name|FT_Int
name|aOpc
parameter_list|,
name|FT_UnitVector
modifier|*
name|Vec
parameter_list|)
block|{
name|FT_Long
name|A
decl_stmt|,
name|B
decl_stmt|,
name|C
decl_stmt|;
name|FT_Vector
modifier|*
name|p1
decl_stmt|;
name|FT_Vector
modifier|*
name|p2
decl_stmt|;
if|if
condition|(
name|BOUNDS
argument_list|(
name|aIdx1
argument_list|,
name|CUR
operator|.
name|zp2
operator|.
name|n_points
argument_list|)
operator|||
name|BOUNDS
argument_list|(
name|aIdx2
argument_list|,
name|CUR
operator|.
name|zp1
operator|.
name|n_points
argument_list|)
condition|)
block|{
if|if
condition|(
name|CUR
operator|.
name|pedantic_hinting
condition|)
name|CUR
operator|.
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Reference
argument_list|)
expr_stmt|;
return|return
name|FAILURE
return|;
block|}
name|p1
operator|=
name|CUR
operator|.
name|zp1
operator|.
name|cur
operator|+
name|aIdx2
expr_stmt|;
name|p2
operator|=
name|CUR
operator|.
name|zp2
operator|.
name|cur
operator|+
name|aIdx1
expr_stmt|;
name|A
operator|=
name|p1
operator|->
name|x
operator|-
name|p2
operator|->
name|x
expr_stmt|;
name|B
operator|=
name|p1
operator|->
name|y
operator|-
name|p2
operator|->
name|y
expr_stmt|;
comment|/* If p1 == p2, SPVTL and SFVTL behave the same as */
comment|/* SPVTCA[X] and SFVTCA[X], respectively.          */
comment|/*                                                 */
comment|/* Confirmed by Greg Hitchcock.                    */
if|if
condition|(
name|A
operator|==
literal|0
operator|&&
name|B
operator|==
literal|0
condition|)
block|{
name|A
operator|=
literal|0x4000
expr_stmt|;
name|aOpc
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|aOpc
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
name|C
operator|=
name|B
expr_stmt|;
comment|/* counter clockwise rotation */
name|B
operator|=
name|A
expr_stmt|;
name|A
operator|=
operator|-
name|C
expr_stmt|;
block|}
name|NORMalize
argument_list|(
name|A
argument_list|,
name|B
argument_list|,
name|Vec
argument_list|)
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
end_function
begin_comment
comment|/* When not using the big switch statements, the interpreter uses a */
end_comment
begin_comment
comment|/* call table defined later below in this source.  Each opcode must */
end_comment
begin_comment
comment|/* thus have a corresponding function, even trivial ones.           */
end_comment
begin_comment
comment|/*                                                                  */
end_comment
begin_comment
comment|/* They are all defined there.                                      */
end_comment
begin_define
DECL|macro|DO_SVTCA
define|#
directive|define
name|DO_SVTCA
define|\
value|{                                         \     FT_Short  A, B;                         \                                             \                                             \     A = (FT_Short)( CUR.opcode& 1 )<< 14; \     B = A ^ (FT_Short)0x4000;               \                                             \     CUR.GS.freeVector.x = A;                \     CUR.GS.projVector.x = A;                \     CUR.GS.dualVector.x = A;                \                                             \     CUR.GS.freeVector.y = B;                \     CUR.GS.projVector.y = B;                \     CUR.GS.dualVector.y = B;                \                                             \     COMPUTE_Funcs();                        \   }
end_define
begin_define
DECL|macro|DO_SPVTCA
define|#
directive|define
name|DO_SPVTCA
define|\
value|{                                         \     FT_Short  A, B;                         \                                             \                                             \     A = (FT_Short)( CUR.opcode& 1 )<< 14; \     B = A ^ (FT_Short)0x4000;               \                                             \     CUR.GS.projVector.x = A;                \     CUR.GS.dualVector.x = A;                \                                             \     CUR.GS.projVector.y = B;                \     CUR.GS.dualVector.y = B;                \                                             \     GUESS_VECTOR( freeVector );             \                                             \     COMPUTE_Funcs();                        \   }
end_define
begin_define
DECL|macro|DO_SFVTCA
define|#
directive|define
name|DO_SFVTCA
define|\
value|{                                         \     FT_Short  A, B;                         \                                             \                                             \     A = (FT_Short)( CUR.opcode& 1 )<< 14; \     B = A ^ (FT_Short)0x4000;               \                                             \     CUR.GS.freeVector.x = A;                \     CUR.GS.freeVector.y = B;                \                                             \     GUESS_VECTOR( projVector );             \                                             \     COMPUTE_Funcs();                        \   }
end_define
begin_define
DECL|macro|DO_SPVTL
define|#
directive|define
name|DO_SPVTL
define|\
value|if ( INS_SxVTL( (FT_UShort)args[1],               \                     (FT_UShort)args[0],               \                     CUR.opcode,                       \&CUR.GS.projVector ) == SUCCESS ) \     {                                                 \       CUR.GS.dualVector = CUR.GS.projVector;          \       GUESS_VECTOR( freeVector );                     \       COMPUTE_Funcs();                                \     }
end_define
begin_define
DECL|macro|DO_SFVTL
define|#
directive|define
name|DO_SFVTL
define|\
value|if ( INS_SxVTL( (FT_UShort)args[1],               \                     (FT_UShort)args[0],               \                     CUR.opcode,                       \&CUR.GS.freeVector ) == SUCCESS ) \     {                                                 \       GUESS_VECTOR( projVector );                     \       COMPUTE_Funcs();                                \     }
end_define
begin_define
DECL|macro|DO_SFVTPV
define|#
directive|define
name|DO_SFVTPV
define|\
value|GUESS_VECTOR( projVector );            \     CUR.GS.freeVector = CUR.GS.projVector; \     COMPUTE_Funcs();
end_define
begin_define
DECL|macro|DO_SPVFS
define|#
directive|define
name|DO_SPVFS
define|\
value|{                                             \     FT_Short  S;                                \     FT_Long   X, Y;                             \                                                 \                                                 \
comment|/* Only use low 16bits, then sign extend */
value|\     S = (FT_Short)args[1];                      \     Y = (FT_Long)S;                             \     S = (FT_Short)args[0];                      \     X = (FT_Long)S;                             \                                                 \     NORMalize( X, Y,&CUR.GS.projVector );      \                                                 \     CUR.GS.dualVector = CUR.GS.projVector;      \     GUESS_VECTOR( freeVector );                 \     COMPUTE_Funcs();                            \   }
end_define
begin_define
DECL|macro|DO_SFVFS
define|#
directive|define
name|DO_SFVFS
define|\
value|{                                             \     FT_Short  S;                                \     FT_Long   X, Y;                             \                                                 \                                                 \
comment|/* Only use low 16bits, then sign extend */
value|\     S = (FT_Short)args[1];                      \     Y = (FT_Long)S;                             \     S = (FT_Short)args[0];                      \     X = S;                                      \                                                 \     NORMalize( X, Y,&CUR.GS.freeVector );      \     GUESS_VECTOR( projVector );                 \     COMPUTE_Funcs();                            \   }
end_define
begin_ifdef
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_UNPATENTED_HINTING
end_ifdef
begin_define
DECL|macro|DO_GPV
define|#
directive|define
name|DO_GPV
define|\
value|if ( CUR.face->unpatented_hinting )          \     {                                            \       args[0] = CUR.GS.both_x_axis ? 0x4000 : 0; \       args[1] = CUR.GS.both_x_axis ? 0 : 0x4000; \     }                                            \     else                                         \     {                                            \       args[0] = CUR.GS.projVector.x;             \       args[1] = CUR.GS.projVector.y;             \     }
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|DO_GPV
define|#
directive|define
name|DO_GPV
define|\
value|args[0] = CUR.GS.projVector.x;               \     args[1] = CUR.GS.projVector.y;
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_UNPATENTED_HINTING
end_ifdef
begin_define
DECL|macro|DO_GFV
define|#
directive|define
name|DO_GFV
define|\
value|if ( CUR.face->unpatented_hinting )          \     {                                            \       args[0] = CUR.GS.both_x_axis ? 0x4000 : 0; \       args[1] = CUR.GS.both_x_axis ? 0 : 0x4000; \     }                                            \     else                                         \     {                                            \       args[0] = CUR.GS.freeVector.x;             \       args[1] = CUR.GS.freeVector.y;             \     }
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|DO_GFV
define|#
directive|define
name|DO_GFV
define|\
value|args[0] = CUR.GS.freeVector.x;               \     args[1] = CUR.GS.freeVector.y;
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|DO_SRP0
define|#
directive|define
name|DO_SRP0
define|\
value|CUR.GS.rp0 = (FT_UShort)args[0];
end_define
begin_define
DECL|macro|DO_SRP1
define|#
directive|define
name|DO_SRP1
define|\
value|CUR.GS.rp1 = (FT_UShort)args[0];
end_define
begin_define
DECL|macro|DO_SRP2
define|#
directive|define
name|DO_SRP2
define|\
value|CUR.GS.rp2 = (FT_UShort)args[0];
end_define
begin_define
DECL|macro|DO_RTHG
define|#
directive|define
name|DO_RTHG
define|\
value|CUR.GS.round_state = TT_Round_To_Half_Grid;         \     CUR.func_round = (TT_Round_Func)Round_To_Half_Grid;
end_define
begin_define
DECL|macro|DO_RTG
define|#
directive|define
name|DO_RTG
define|\
value|CUR.GS.round_state = TT_Round_To_Grid;         \     CUR.func_round = (TT_Round_Func)Round_To_Grid;
end_define
begin_define
DECL|macro|DO_RTDG
define|#
directive|define
name|DO_RTDG
define|\
value|CUR.GS.round_state = TT_Round_To_Double_Grid;         \     CUR.func_round = (TT_Round_Func)Round_To_Double_Grid;
end_define
begin_define
DECL|macro|DO_RUTG
define|#
directive|define
name|DO_RUTG
define|\
value|CUR.GS.round_state = TT_Round_Up_To_Grid;         \     CUR.func_round = (TT_Round_Func)Round_Up_To_Grid;
end_define
begin_define
DECL|macro|DO_RDTG
define|#
directive|define
name|DO_RDTG
define|\
value|CUR.GS.round_state = TT_Round_Down_To_Grid;         \     CUR.func_round = (TT_Round_Func)Round_Down_To_Grid;
end_define
begin_define
DECL|macro|DO_ROFF
define|#
directive|define
name|DO_ROFF
define|\
value|CUR.GS.round_state = TT_Round_Off;          \     CUR.func_round = (TT_Round_Func)Round_None;
end_define
begin_define
DECL|macro|DO_SROUND
define|#
directive|define
name|DO_SROUND
define|\
value|SET_SuperRound( 0x4000, args[0] );           \     CUR.GS.round_state = TT_Round_Super;         \     CUR.func_round = (TT_Round_Func)Round_Super;
end_define
begin_define
DECL|macro|DO_S45ROUND
define|#
directive|define
name|DO_S45ROUND
define|\
value|SET_SuperRound( 0x2D41, args[0] );              \     CUR.GS.round_state = TT_Round_Super_45;         \     CUR.func_round = (TT_Round_Func)Round_Super_45;
end_define
begin_define
DECL|macro|DO_SLOOP
define|#
directive|define
name|DO_SLOOP
define|\
value|if ( args[0]< 0 )                      \       CUR.error = FT_THROW( Bad_Argument ); \     else                                    \       CUR.GS.loop = args[0];
end_define
begin_define
DECL|macro|DO_SMD
define|#
directive|define
name|DO_SMD
define|\
value|CUR.GS.minimum_distance = args[0];
end_define
begin_define
DECL|macro|DO_SCVTCI
define|#
directive|define
name|DO_SCVTCI
define|\
value|CUR.GS.control_value_cutin = (FT_F26Dot6)args[0];
end_define
begin_define
DECL|macro|DO_SSWCI
define|#
directive|define
name|DO_SSWCI
define|\
value|CUR.GS.single_width_cutin = (FT_F26Dot6)args[0];
end_define
begin_define
DECL|macro|DO_SSW
define|#
directive|define
name|DO_SSW
define|\
value|CUR.GS.single_width_value = FT_MulFix( args[0],                \                                            CUR.tt_metrics.scale );
end_define
begin_define
DECL|macro|DO_FLIPON
define|#
directive|define
name|DO_FLIPON
define|\
value|CUR.GS.auto_flip = TRUE;
end_define
begin_define
DECL|macro|DO_FLIPOFF
define|#
directive|define
name|DO_FLIPOFF
define|\
value|CUR.GS.auto_flip = FALSE;
end_define
begin_define
DECL|macro|DO_SDB
define|#
directive|define
name|DO_SDB
define|\
value|CUR.GS.delta_base = (FT_UShort)args[0];
end_define
begin_define
DECL|macro|DO_SDS
define|#
directive|define
name|DO_SDS
define|\
value|if ( (FT_ULong)args[0]> 6UL )             \       CUR.error = FT_THROW( Bad_Argument );    \     else                                       \       CUR.GS.delta_shift = (FT_UShort)args[0];
end_define
begin_define
DECL|macro|DO_MD
define|#
directive|define
name|DO_MD
end_define
begin_comment
DECL|macro|DO_MD
comment|/* nothing */
end_comment
begin_define
DECL|macro|DO_MPPEM
define|#
directive|define
name|DO_MPPEM
define|\
value|args[0] = CUR_Func_cur_ppem();
end_define
begin_comment
comment|/* Note: The pointSize should be irrelevant in a given font program; */
end_comment
begin_comment
comment|/*       we thus decide to return only the ppem.                     */
end_comment
begin_if
if|#
directive|if
literal|0
end_if
begin_define
define|#
directive|define
name|DO_MPS
define|\
value|args[0] = CUR.metrics.pointSize;
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|DO_MPS
define|#
directive|define
name|DO_MPS
define|\
value|args[0] = CUR_Func_cur_ppem();
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* 0 */
end_comment
begin_define
DECL|macro|DO_DUP
define|#
directive|define
name|DO_DUP
define|\
value|args[1] = args[0];
end_define
begin_define
DECL|macro|DO_CLEAR
define|#
directive|define
name|DO_CLEAR
define|\
value|CUR.new_top = 0;
end_define
begin_define
DECL|macro|DO_SWAP
define|#
directive|define
name|DO_SWAP
define|\
value|{                    \     FT_Long  L;        \                        \                        \     L       = args[0]; \     args[0] = args[1]; \     args[1] = L;       \   }
end_define
begin_define
DECL|macro|DO_DEPTH
define|#
directive|define
name|DO_DEPTH
define|\
value|args[0] = CUR.top;
end_define
begin_define
DECL|macro|DO_CINDEX
define|#
directive|define
name|DO_CINDEX
define|\
value|{                                                \     FT_Long  L;                                    \                                                    \                                                    \     L = args[0];                                   \                                                    \     if ( L<= 0 || L> CUR.args )                  \     {                                              \       if ( CUR.pedantic_hinting )                  \         CUR.error = FT_THROW( Invalid_Reference ); \       args[0] = 0;                                 \     }                                              \     else                                           \       args[0] = CUR.stack[CUR.args - L];           \   }
end_define
begin_define
DECL|macro|DO_JROT
define|#
directive|define
name|DO_JROT
define|\
value|if ( args[1] != 0 )                                            \     {                                                              \       if ( args[0] == 0&& CUR.args == 0 )                         \         CUR.error = FT_THROW( Bad_Argument );                      \       CUR.IP += args[0];                                           \       if ( CUR.IP< 0                                           || \            ( CUR.callTop> 0&&   \              CUR.IP> CUR.callStack[CUR.callTop - 1].Def->end ) )  \         CUR.error = FT_THROW( Bad_Argument );                      \       CUR.step_ins = FALSE;                                        \     }
end_define
begin_define
DECL|macro|DO_JMPR
define|#
directive|define
name|DO_JMPR
define|\
value|if ( args[0] == 0&& CUR.args == 0 )                         \       CUR.error = FT_THROW( Bad_Argument );                      \     CUR.IP += args[0];                                           \     if ( CUR.IP< 0                                           || \          ( CUR.callTop> 0&&   \            CUR.IP> CUR.callStack[CUR.callTop - 1].Def->end ) )  \       CUR.error = FT_THROW( Bad_Argument );                      \     CUR.step_ins = FALSE;
end_define
begin_define
DECL|macro|DO_JROF
define|#
directive|define
name|DO_JROF
define|\
value|if ( args[1] == 0 )                                            \     {                                                              \       if ( args[0] == 0&& CUR.args == 0 )                         \         CUR.error = FT_THROW( Bad_Argument );                      \       CUR.IP += args[0];                                           \       if ( CUR.IP< 0                                           || \            ( CUR.callTop> 0&&   \              CUR.IP> CUR.callStack[CUR.callTop - 1].Def->end ) )  \         CUR.error = FT_THROW( Bad_Argument );                      \       CUR.step_ins = FALSE;                                        \     }
end_define
begin_define
DECL|macro|DO_LT
define|#
directive|define
name|DO_LT
define|\
value|args[0] = ( args[0]< args[1] );
end_define
begin_define
DECL|macro|DO_LTEQ
define|#
directive|define
name|DO_LTEQ
define|\
value|args[0] = ( args[0]<= args[1] );
end_define
begin_define
DECL|macro|DO_GT
define|#
directive|define
name|DO_GT
define|\
value|args[0] = ( args[0]> args[1] );
end_define
begin_define
DECL|macro|DO_GTEQ
define|#
directive|define
name|DO_GTEQ
define|\
value|args[0] = ( args[0]>= args[1] );
end_define
begin_define
DECL|macro|DO_EQ
define|#
directive|define
name|DO_EQ
define|\
value|args[0] = ( args[0] == args[1] );
end_define
begin_define
DECL|macro|DO_NEQ
define|#
directive|define
name|DO_NEQ
define|\
value|args[0] = ( args[0] != args[1] );
end_define
begin_define
DECL|macro|DO_ODD
define|#
directive|define
name|DO_ODD
define|\
value|args[0] = ( ( CUR_Func_round( args[0], 0 )& 127 ) == 64 );
end_define
begin_define
DECL|macro|DO_EVEN
define|#
directive|define
name|DO_EVEN
define|\
value|args[0] = ( ( CUR_Func_round( args[0], 0 )& 127 ) == 0 );
end_define
begin_define
DECL|macro|DO_AND
define|#
directive|define
name|DO_AND
define|\
value|args[0] = ( args[0]&& args[1] );
end_define
begin_define
DECL|macro|DO_OR
define|#
directive|define
name|DO_OR
define|\
value|args[0] = ( args[0] || args[1] );
end_define
begin_define
DECL|macro|DO_NOT
define|#
directive|define
name|DO_NOT
define|\
value|args[0] = !args[0];
end_define
begin_define
DECL|macro|DO_ADD
define|#
directive|define
name|DO_ADD
define|\
value|args[0] += args[1];
end_define
begin_define
DECL|macro|DO_SUB
define|#
directive|define
name|DO_SUB
define|\
value|args[0] -= args[1];
end_define
begin_define
DECL|macro|DO_DIV
define|#
directive|define
name|DO_DIV
define|\
value|if ( args[1] == 0 )                                      \       CUR.error = FT_THROW( Divide_By_Zero );                \     else                                                     \       args[0] = FT_MulDiv_No_Round( args[0], 64L, args[1] );
end_define
begin_define
DECL|macro|DO_MUL
define|#
directive|define
name|DO_MUL
define|\
value|args[0] = FT_MulDiv( args[0], args[1], 64L );
end_define
begin_define
DECL|macro|DO_ABS
define|#
directive|define
name|DO_ABS
define|\
value|args[0] = FT_ABS( args[0] );
end_define
begin_define
DECL|macro|DO_NEG
define|#
directive|define
name|DO_NEG
define|\
value|args[0] = -args[0];
end_define
begin_define
DECL|macro|DO_FLOOR
define|#
directive|define
name|DO_FLOOR
define|\
value|args[0] = FT_PIX_FLOOR( args[0] );
end_define
begin_define
DECL|macro|DO_CEILING
define|#
directive|define
name|DO_CEILING
define|\
value|args[0] = FT_PIX_CEIL( args[0] );
end_define
begin_ifdef
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_SUBPIXEL_HINTING
end_ifdef
begin_define
DECL|macro|DO_RS
define|#
directive|define
name|DO_RS
define|\
value|{                                                      \      FT_ULong  I = (FT_ULong)args[0];                     \                                                           \                                                           \      if ( BOUNDSL( I, CUR.storeSize ) )                   \      {                                                    \        if ( CUR.pedantic_hinting )                        \          ARRAY_BOUND_ERROR;                               \        else                                               \          args[0] = 0;                                     \      }                                                    \      else                                                 \      {                                                    \
comment|/* subpixel hinting - avoid Typeman Dstroke and */
value|\
comment|/* IStroke and Vacuform rounds                  */
value|\                                                           \        if ( SUBPIXEL_HINTING&& \             CUR.ignore_x_mode&& \             ( ( I == 24&&     \                 ( CUR.face->sph_found_func_flags&        \                   ( SPH_FDEF_SPACING_1 |                  \                     SPH_FDEF_SPACING_2 )         ) ) ||   \               ( I == 22&&           \                 ( CUR.sph_in_func_flags&              \                   SPH_FDEF_TYPEMAN_STROKES ) )       ||   \               ( I == 8&&     \                 ( CUR.face->sph_found_func_flags&        \                   SPH_FDEF_VACUFORM_ROUND_1      )&&     \                   CUR.iup_called                   ) ) )  \          args[0] = 0;                                     \        else                                               \          args[0] = CUR.storage[I];                        \      }                                                    \    }
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* !TT_CONFIG_OPTION_SUBPIXEL_HINTING */
end_comment
begin_define
DECL|macro|DO_RS
define|#
directive|define
name|DO_RS
define|\
value|{                                    \      FT_ULong  I = (FT_ULong)args[0];   \                                         \                                         \      if ( BOUNDSL( I, CUR.storeSize ) ) \      {                                  \        if ( CUR.pedantic_hinting )      \        {                                \          ARRAY_BOUND_ERROR;             \        }                                \        else                             \          args[0] = 0;                   \      }                                  \      else                               \        args[0] = CUR.storage[I];        \    }
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* !TT_CONFIG_OPTION_SUBPIXEL_HINTING */
end_comment
begin_define
DECL|macro|DO_WS
define|#
directive|define
name|DO_WS
define|\
value|{                                    \      FT_ULong  I = (FT_ULong)args[0];   \                                         \                                         \      if ( BOUNDSL( I, CUR.storeSize ) ) \      {                                  \        if ( CUR.pedantic_hinting )      \        {                                \          ARRAY_BOUND_ERROR;             \        }                                \      }                                  \      else                               \        CUR.storage[I] = args[1];        \    }
end_define
begin_define
DECL|macro|DO_RCVT
define|#
directive|define
name|DO_RCVT
define|\
value|{                                     \      FT_ULong  I = (FT_ULong)args[0];    \                                          \                                          \      if ( BOUNDSL( I, CUR.cvtSize ) )    \      {                                   \        if ( CUR.pedantic_hinting )       \        {                                 \          ARRAY_BOUND_ERROR;              \        }                                 \        else                              \          args[0] = 0;                    \      }                                   \      else                                \        args[0] = CUR_Func_read_cvt( I ); \    }
end_define
begin_define
DECL|macro|DO_WCVTP
define|#
directive|define
name|DO_WCVTP
define|\
value|{                                     \      FT_ULong  I = (FT_ULong)args[0];    \                                          \                                          \      if ( BOUNDSL( I, CUR.cvtSize ) )    \      {                                   \        if ( CUR.pedantic_hinting )       \        {                                 \          ARRAY_BOUND_ERROR;              \        }                                 \      }                                   \      else                                \        CUR_Func_write_cvt( I, args[1] ); \    }
end_define
begin_define
DECL|macro|DO_WCVTF
define|#
directive|define
name|DO_WCVTF
define|\
value|{                                                            \      FT_ULong  I = (FT_ULong)args[0];                           \                                                                 \                                                                 \      if ( BOUNDSL( I, CUR.cvtSize ) )                           \      {                                                          \        if ( CUR.pedantic_hinting )                              \        {                                                        \          ARRAY_BOUND_ERROR;                                     \        }                                                        \      }                                                          \      else                                                       \        CUR.cvt[I] = FT_MulFix( args[1], CUR.tt_metrics.scale ); \    }
end_define
begin_define
DECL|macro|DO_DEBUG
define|#
directive|define
name|DO_DEBUG
define|\
value|CUR.error = FT_THROW( Debug_OpCode );
end_define
begin_define
DECL|macro|DO_ROUND
define|#
directive|define
name|DO_ROUND
define|\
value|args[0] = CUR_Func_round(                                      \                 args[0],                                           \                 CUR.tt_metrics.compensations[CUR.opcode - 0x68] );
end_define
begin_define
DECL|macro|DO_NROUND
define|#
directive|define
name|DO_NROUND
define|\
value|args[0] = ROUND_None( args[0],                                           \                           CUR.tt_metrics.compensations[CUR.opcode - 0x6C] );
end_define
begin_define
DECL|macro|DO_MAX
define|#
directive|define
name|DO_MAX
define|\
value|if ( args[1]> args[0] ) \       args[0] = args[1];
end_define
begin_define
DECL|macro|DO_MIN
define|#
directive|define
name|DO_MIN
define|\
value|if ( args[1]< args[0] ) \       args[0] = args[1];
end_define
begin_ifndef
ifndef|#
directive|ifndef
name|TT_CONFIG_OPTION_INTERPRETER_SWITCH
end_ifndef
begin_undef
DECL|macro|ARRAY_BOUND_ERROR
undef|#
directive|undef
name|ARRAY_BOUND_ERROR
end_undef
begin_define
DECL|macro|ARRAY_BOUND_ERROR
define|#
directive|define
name|ARRAY_BOUND_ERROR
define|\
value|{                                            \       CUR.error = FT_THROW( Invalid_Reference ); \       return;                                    \     }
end_define
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* SVTCA[a]:     Set (F and P) Vectors to Coordinate Axis                */
end_comment
begin_comment
comment|/* Opcode range: 0x00-0x01                                               */
end_comment
begin_comment
comment|/* Stack:        -->                                                     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_SVTCA
name|Ins_SVTCA
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|DO_SVTCA
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* SPVTCA[a]:    Set PVector to Coordinate Axis                          */
end_comment
begin_comment
comment|/* Opcode range: 0x02-0x03                                               */
end_comment
begin_comment
comment|/* Stack:        -->                                                     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_SPVTCA
name|Ins_SPVTCA
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|DO_SPVTCA
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* SFVTCA[a]:    Set FVector to Coordinate Axis                          */
end_comment
begin_comment
comment|/* Opcode range: 0x04-0x05                                               */
end_comment
begin_comment
comment|/* Stack:        -->                                                     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_SFVTCA
name|Ins_SFVTCA
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|DO_SFVTCA
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* SPVTL[a]:     Set PVector To Line                                     */
end_comment
begin_comment
comment|/* Opcode range: 0x06-0x07                                               */
end_comment
begin_comment
comment|/* Stack:        uint32 uint32 -->                                       */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_SPVTL
name|Ins_SPVTL
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|DO_SPVTL
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* SFVTL[a]:     Set FVector To Line                                     */
end_comment
begin_comment
comment|/* Opcode range: 0x08-0x09                                               */
end_comment
begin_comment
comment|/* Stack:        uint32 uint32 -->                                       */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_SFVTL
name|Ins_SFVTL
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|DO_SFVTL
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* SFVTPV[]:     Set FVector To PVector                                  */
end_comment
begin_comment
comment|/* Opcode range: 0x0E                                                    */
end_comment
begin_comment
comment|/* Stack:        -->                                                     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_SFVTPV
name|Ins_SFVTPV
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|DO_SFVTPV
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* SPVFS[]:      Set PVector From Stack                                  */
end_comment
begin_comment
comment|/* Opcode range: 0x0A                                                    */
end_comment
begin_comment
comment|/* Stack:        f2.14 f2.14 -->                                         */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_SPVFS
name|Ins_SPVFS
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|DO_SPVFS
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* SFVFS[]:      Set FVector From Stack                                  */
end_comment
begin_comment
comment|/* Opcode range: 0x0B                                                    */
end_comment
begin_comment
comment|/* Stack:        f2.14 f2.14 -->                                         */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_SFVFS
name|Ins_SFVFS
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|DO_SFVFS
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* GPV[]:        Get Projection Vector                                   */
end_comment
begin_comment
comment|/* Opcode range: 0x0C                                                    */
end_comment
begin_comment
comment|/* Stack:        ef2.14 --> ef2.14                                       */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_GPV
name|Ins_GPV
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|DO_GPV
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/* GFV[]:        Get Freedom Vector                                      */
end_comment
begin_comment
comment|/* Opcode range: 0x0D                                                    */
end_comment
begin_comment
comment|/* Stack:        ef2.14 --> ef2.14                                       */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_GFV
name|Ins_GFV
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|DO_GFV
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* SRP0[]:       Set Reference Point 0                                   */
end_comment
begin_comment
comment|/* Opcode range: 0x10                                                    */
end_comment
begin_comment
comment|/* Stack:        uint32 -->                                              */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_SRP0
name|Ins_SRP0
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|DO_SRP0
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* SRP1[]:       Set Reference Point 1                                   */
end_comment
begin_comment
comment|/* Opcode range: 0x11                                                    */
end_comment
begin_comment
comment|/* Stack:        uint32 -->                                              */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_SRP1
name|Ins_SRP1
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|DO_SRP1
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* SRP2[]:       Set Reference Point 2                                   */
end_comment
begin_comment
comment|/* Opcode range: 0x12                                                    */
end_comment
begin_comment
comment|/* Stack:        uint32 -->                                              */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_SRP2
name|Ins_SRP2
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|DO_SRP2
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* RTHG[]:       Round To Half Grid                                      */
end_comment
begin_comment
comment|/* Opcode range: 0x19                                                    */
end_comment
begin_comment
comment|/* Stack:        -->                                                     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_RTHG
name|Ins_RTHG
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|DO_RTHG
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* RTG[]:        Round To Grid                                           */
end_comment
begin_comment
comment|/* Opcode range: 0x18                                                    */
end_comment
begin_comment
comment|/* Stack:        -->                                                     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_RTG
name|Ins_RTG
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|DO_RTG
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/* RTDG[]:       Round To Double Grid                                    */
end_comment
begin_comment
comment|/* Opcode range: 0x3D                                                    */
end_comment
begin_comment
comment|/* Stack:        -->                                                     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_RTDG
name|Ins_RTDG
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|DO_RTDG
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/* RUTG[]:       Round Up To Grid                                        */
end_comment
begin_comment
comment|/* Opcode range: 0x7C                                                    */
end_comment
begin_comment
comment|/* Stack:        -->                                                     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_RUTG
name|Ins_RUTG
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|DO_RUTG
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* RDTG[]:       Round Down To Grid                                      */
end_comment
begin_comment
comment|/* Opcode range: 0x7D                                                    */
end_comment
begin_comment
comment|/* Stack:        -->                                                     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_RDTG
name|Ins_RDTG
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|DO_RDTG
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* ROFF[]:       Round OFF                                               */
end_comment
begin_comment
comment|/* Opcode range: 0x7A                                                    */
end_comment
begin_comment
comment|/* Stack:        -->                                                     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_ROFF
name|Ins_ROFF
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|DO_ROFF
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* SROUND[]:     Super ROUND                                             */
end_comment
begin_comment
comment|/* Opcode range: 0x76                                                    */
end_comment
begin_comment
comment|/* Stack:        Eint8 -->                                               */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_SROUND
name|Ins_SROUND
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|DO_SROUND
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* S45ROUND[]:   Super ROUND 45 degrees                                  */
end_comment
begin_comment
comment|/* Opcode range: 0x77                                                    */
end_comment
begin_comment
comment|/* Stack:        uint32 -->                                              */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_S45ROUND
name|Ins_S45ROUND
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|DO_S45ROUND
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* SLOOP[]:      Set LOOP variable                                       */
end_comment
begin_comment
comment|/* Opcode range: 0x17                                                    */
end_comment
begin_comment
comment|/* Stack:        int32? -->                                              */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_SLOOP
name|Ins_SLOOP
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|DO_SLOOP
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* SMD[]:        Set Minimum Distance                                    */
end_comment
begin_comment
comment|/* Opcode range: 0x1A                                                    */
end_comment
begin_comment
comment|/* Stack:        f26.6 -->                                               */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_SMD
name|Ins_SMD
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|DO_SMD
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* SCVTCI[]:     Set Control Value Table Cut In                          */
end_comment
begin_comment
comment|/* Opcode range: 0x1D                                                    */
end_comment
begin_comment
comment|/* Stack:        f26.6 -->                                               */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_SCVTCI
name|Ins_SCVTCI
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|DO_SCVTCI
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* SSWCI[]:      Set Single Width Cut In                                 */
end_comment
begin_comment
comment|/* Opcode range: 0x1E                                                    */
end_comment
begin_comment
comment|/* Stack:        f26.6 -->                                               */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_SSWCI
name|Ins_SSWCI
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|DO_SSWCI
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* SSW[]:        Set Single Width                                        */
end_comment
begin_comment
comment|/* Opcode range: 0x1F                                                    */
end_comment
begin_comment
comment|/* Stack:        int32? -->                                              */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_SSW
name|Ins_SSW
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|DO_SSW
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* FLIPON[]:     Set auto-FLIP to ON                                     */
end_comment
begin_comment
comment|/* Opcode range: 0x4D                                                    */
end_comment
begin_comment
comment|/* Stack:        -->                                                     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_FLIPON
name|Ins_FLIPON
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|DO_FLIPON
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* FLIPOFF[]:    Set auto-FLIP to OFF                                    */
end_comment
begin_comment
comment|/* Opcode range: 0x4E                                                    */
end_comment
begin_comment
comment|/* Stack: -->                                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_FLIPOFF
name|Ins_FLIPOFF
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|DO_FLIPOFF
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* SANGW[]:      Set ANGle Weight                                        */
end_comment
begin_comment
comment|/* Opcode range: 0x7E                                                    */
end_comment
begin_comment
comment|/* Stack:        uint32 -->                                              */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_SANGW
name|Ins_SANGW
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
comment|/* instruction not supported anymore */
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* SDB[]:        Set Delta Base                                          */
end_comment
begin_comment
comment|/* Opcode range: 0x5E                                                    */
end_comment
begin_comment
comment|/* Stack:        uint32 -->                                              */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_SDB
name|Ins_SDB
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|DO_SDB
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* SDS[]:        Set Delta Shift                                         */
end_comment
begin_comment
comment|/* Opcode range: 0x5F                                                    */
end_comment
begin_comment
comment|/* Stack:        uint32 -->                                              */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_SDS
name|Ins_SDS
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|DO_SDS
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* MPPEM[]:      Measure Pixel Per EM                                    */
end_comment
begin_comment
comment|/* Opcode range: 0x4B                                                    */
end_comment
begin_comment
comment|/* Stack:        --> Euint16                                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_MPPEM
name|Ins_MPPEM
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|DO_MPPEM
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* MPS[]:        Measure Point Size                                      */
end_comment
begin_comment
comment|/* Opcode range: 0x4C                                                    */
end_comment
begin_comment
comment|/* Stack:        --> Euint16                                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_MPS
name|Ins_MPS
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|DO_MPS
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* DUP[]:        DUPlicate the top stack's element                       */
end_comment
begin_comment
comment|/* Opcode range: 0x20                                                    */
end_comment
begin_comment
comment|/* Stack:        StkElt --> StkElt StkElt                                */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_DUP
name|Ins_DUP
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|DO_DUP
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* POP[]:        POP the stack's top element                             */
end_comment
begin_comment
comment|/* Opcode range: 0x21                                                    */
end_comment
begin_comment
comment|/* Stack:        StkElt -->                                              */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_POP
name|Ins_POP
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
comment|/* nothing to do */
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* CLEAR[]:      CLEAR the entire stack                                  */
end_comment
begin_comment
comment|/* Opcode range: 0x22                                                    */
end_comment
begin_comment
comment|/* Stack:        StkElt... -->                                           */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_CLEAR
name|Ins_CLEAR
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|DO_CLEAR
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* SWAP[]:       SWAP the stack's top two elements                       */
end_comment
begin_comment
comment|/* Opcode range: 0x23                                                    */
end_comment
begin_comment
comment|/* Stack:        2 * StkElt --> 2 * StkElt                               */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_SWAP
name|Ins_SWAP
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|DO_SWAP
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* DEPTH[]:      return the stack DEPTH                                  */
end_comment
begin_comment
comment|/* Opcode range: 0x24                                                    */
end_comment
begin_comment
comment|/* Stack:        --> uint32                                              */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_DEPTH
name|Ins_DEPTH
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|DO_DEPTH
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* CINDEX[]:     Copy INDEXed element                                    */
end_comment
begin_comment
comment|/* Opcode range: 0x25                                                    */
end_comment
begin_comment
comment|/* Stack:        int32 --> StkElt                                        */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_CINDEX
name|Ins_CINDEX
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|DO_CINDEX
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* EIF[]:        End IF                                                  */
end_comment
begin_comment
comment|/* Opcode range: 0x59                                                    */
end_comment
begin_comment
comment|/* Stack:        -->                                                     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_EIF
name|Ins_EIF
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
comment|/* nothing to do */
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* JROT[]:       Jump Relative On True                                   */
end_comment
begin_comment
comment|/* Opcode range: 0x78                                                    */
end_comment
begin_comment
comment|/* Stack:        StkElt int32 -->                                        */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_JROT
name|Ins_JROT
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|DO_JROT
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* JMPR[]:       JuMP Relative                                           */
end_comment
begin_comment
comment|/* Opcode range: 0x1C                                                    */
end_comment
begin_comment
comment|/* Stack:        int32 -->                                               */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_JMPR
name|Ins_JMPR
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|DO_JMPR
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* JROF[]:       Jump Relative On False                                  */
end_comment
begin_comment
comment|/* Opcode range: 0x79                                                    */
end_comment
begin_comment
comment|/* Stack:        StkElt int32 -->                                        */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_JROF
name|Ins_JROF
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|DO_JROF
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* LT[]:         Less Than                                               */
end_comment
begin_comment
comment|/* Opcode range: 0x50                                                    */
end_comment
begin_comment
comment|/* Stack:        int32? int32? --> bool                                  */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_LT
name|Ins_LT
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|DO_LT
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* LTEQ[]:       Less Than or EQual                                      */
end_comment
begin_comment
comment|/* Opcode range: 0x51                                                    */
end_comment
begin_comment
comment|/* Stack:        int32? int32? --> bool                                  */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_LTEQ
name|Ins_LTEQ
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|DO_LTEQ
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* GT[]:         Greater Than                                            */
end_comment
begin_comment
comment|/* Opcode range: 0x52                                                    */
end_comment
begin_comment
comment|/* Stack:        int32? int32? --> bool                                  */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_GT
name|Ins_GT
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|DO_GT
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* GTEQ[]:       Greater Than or EQual                                   */
end_comment
begin_comment
comment|/* Opcode range: 0x53                                                    */
end_comment
begin_comment
comment|/* Stack:        int32? int32? --> bool                                  */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_GTEQ
name|Ins_GTEQ
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|DO_GTEQ
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* EQ[]:         EQual                                                   */
end_comment
begin_comment
comment|/* Opcode range: 0x54                                                    */
end_comment
begin_comment
comment|/* Stack:        StkElt StkElt --> bool                                  */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_EQ
name|Ins_EQ
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|DO_EQ
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* NEQ[]:        Not EQual                                               */
end_comment
begin_comment
comment|/* Opcode range: 0x55                                                    */
end_comment
begin_comment
comment|/* Stack:        StkElt StkElt --> bool                                  */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_NEQ
name|Ins_NEQ
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|DO_NEQ
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* ODD[]:        Is ODD                                                  */
end_comment
begin_comment
comment|/* Opcode range: 0x56                                                    */
end_comment
begin_comment
comment|/* Stack:        f26.6 --> bool                                          */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_ODD
name|Ins_ODD
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|DO_ODD
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* EVEN[]:       Is EVEN                                                 */
end_comment
begin_comment
comment|/* Opcode range: 0x57                                                    */
end_comment
begin_comment
comment|/* Stack:        f26.6 --> bool                                          */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_EVEN
name|Ins_EVEN
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|DO_EVEN
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* AND[]:        logical AND                                             */
end_comment
begin_comment
comment|/* Opcode range: 0x5A                                                    */
end_comment
begin_comment
comment|/* Stack:        uint32 uint32 --> uint32                                */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_AND
name|Ins_AND
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|DO_AND
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* OR[]:         logical OR                                              */
end_comment
begin_comment
comment|/* Opcode range: 0x5B                                                    */
end_comment
begin_comment
comment|/* Stack:        uint32 uint32 --> uint32                                */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_OR
name|Ins_OR
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|DO_OR
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* NOT[]:        logical NOT                                             */
end_comment
begin_comment
comment|/* Opcode range: 0x5C                                                    */
end_comment
begin_comment
comment|/* Stack:        StkElt --> uint32                                       */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_NOT
name|Ins_NOT
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|DO_NOT
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* ADD[]:        ADD                                                     */
end_comment
begin_comment
comment|/* Opcode range: 0x60                                                    */
end_comment
begin_comment
comment|/* Stack:        f26.6 f26.6 --> f26.6                                   */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_ADD
name|Ins_ADD
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|DO_ADD
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* SUB[]:        SUBtract                                                */
end_comment
begin_comment
comment|/* Opcode range: 0x61                                                    */
end_comment
begin_comment
comment|/* Stack:        f26.6 f26.6 --> f26.6                                   */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_SUB
name|Ins_SUB
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|DO_SUB
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* DIV[]:        DIVide                                                  */
end_comment
begin_comment
comment|/* Opcode range: 0x62                                                    */
end_comment
begin_comment
comment|/* Stack:        f26.6 f26.6 --> f26.6                                   */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_DIV
name|Ins_DIV
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|DO_DIV
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* MUL[]:        MULtiply                                                */
end_comment
begin_comment
comment|/* Opcode range: 0x63                                                    */
end_comment
begin_comment
comment|/* Stack:        f26.6 f26.6 --> f26.6                                   */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_MUL
name|Ins_MUL
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|DO_MUL
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* ABS[]:        ABSolute value                                          */
end_comment
begin_comment
comment|/* Opcode range: 0x64                                                    */
end_comment
begin_comment
comment|/* Stack:        f26.6 --> f26.6                                         */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_ABS
name|Ins_ABS
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|DO_ABS
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* NEG[]:        NEGate                                                  */
end_comment
begin_comment
comment|/* Opcode range: 0x65                                                    */
end_comment
begin_comment
comment|/* Stack: f26.6 --> f26.6                                                */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_NEG
name|Ins_NEG
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|DO_NEG
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* FLOOR[]:      FLOOR                                                   */
end_comment
begin_comment
comment|/* Opcode range: 0x66                                                    */
end_comment
begin_comment
comment|/* Stack:        f26.6 --> f26.6                                         */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_FLOOR
name|Ins_FLOOR
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|DO_FLOOR
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* CEILING[]:    CEILING                                                 */
end_comment
begin_comment
comment|/* Opcode range: 0x67                                                    */
end_comment
begin_comment
comment|/* Stack:        f26.6 --> f26.6                                         */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_CEILING
name|Ins_CEILING
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|DO_CEILING
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* RS[]:         Read Store                                              */
end_comment
begin_comment
comment|/* Opcode range: 0x43                                                    */
end_comment
begin_comment
comment|/* Stack:        uint32 --> uint32                                       */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_RS
name|Ins_RS
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|DO_RS
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* WS[]:         Write Store                                             */
end_comment
begin_comment
comment|/* Opcode range: 0x42                                                    */
end_comment
begin_comment
comment|/* Stack:        uint32 uint32 -->                                       */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_WS
name|Ins_WS
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|DO_WS
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* WCVTP[]:      Write CVT in Pixel units                                */
end_comment
begin_comment
comment|/* Opcode range: 0x44                                                    */
end_comment
begin_comment
comment|/* Stack:        f26.6 uint32 -->                                        */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_WCVTP
name|Ins_WCVTP
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|DO_WCVTP
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* WCVTF[]:      Write CVT in Funits                                     */
end_comment
begin_comment
comment|/* Opcode range: 0x70                                                    */
end_comment
begin_comment
comment|/* Stack:        uint32 uint32 -->                                       */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_WCVTF
name|Ins_WCVTF
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|DO_WCVTF
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* RCVT[]:       Read CVT                                                */
end_comment
begin_comment
comment|/* Opcode range: 0x45                                                    */
end_comment
begin_comment
comment|/* Stack:        uint32 --> f26.6                                        */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_RCVT
name|Ins_RCVT
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|DO_RCVT
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* AA[]:         Adjust Angle                                            */
end_comment
begin_comment
comment|/* Opcode range: 0x7F                                                    */
end_comment
begin_comment
comment|/* Stack:        uint32 -->                                              */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_AA
name|Ins_AA
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
comment|/* intentionally no longer supported */
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* DEBUG[]:      DEBUG.  Unsupported.                                    */
end_comment
begin_comment
comment|/* Opcode range: 0x4F                                                    */
end_comment
begin_comment
comment|/* Stack:        uint32 -->                                              */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* Note: The original instruction pops a value from the stack.           */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_DEBUG
name|Ins_DEBUG
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|DO_DEBUG
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* ROUND[ab]:    ROUND value                                             */
end_comment
begin_comment
comment|/* Opcode range: 0x68-0x6B                                               */
end_comment
begin_comment
comment|/* Stack:        f26.6 --> f26.6                                         */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_ROUND
name|Ins_ROUND
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|DO_ROUND
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* NROUND[ab]:   No ROUNDing of value                                    */
end_comment
begin_comment
comment|/* Opcode range: 0x6C-0x6F                                               */
end_comment
begin_comment
comment|/* Stack:        f26.6 --> f26.6                                         */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_NROUND
name|Ins_NROUND
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|DO_NROUND
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* MAX[]:        MAXimum                                                 */
end_comment
begin_comment
comment|/* Opcode range: 0x68                                                    */
end_comment
begin_comment
comment|/* Stack:        int32? int32? --> int32                                 */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_MAX
name|Ins_MAX
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|DO_MAX
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* MIN[]:        MINimum                                                 */
end_comment
begin_comment
comment|/* Opcode range: 0x69                                                    */
end_comment
begin_comment
comment|/* Stack:        int32? int32? --> int32                                 */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_MIN
name|Ins_MIN
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|DO_MIN
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* !TT_CONFIG_OPTION_INTERPRETER_SWITCH */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* The following functions are called as is within the switch statement. */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* MINDEX[]:     Move INDEXed element                                    */
end_comment
begin_comment
comment|/* Opcode range: 0x26                                                    */
end_comment
begin_comment
comment|/* Stack:        int32? --> StkElt                                       */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_MINDEX
name|Ins_MINDEX
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|FT_Long
name|L
decl_stmt|,
name|K
decl_stmt|;
name|L
operator|=
name|args
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|L
operator|<=
literal|0
operator|||
name|L
operator|>
name|CUR
operator|.
name|args
condition|)
block|{
if|if
condition|(
name|CUR
operator|.
name|pedantic_hinting
condition|)
name|CUR
operator|.
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Reference
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|K
operator|=
name|CUR
operator|.
name|stack
index|[
name|CUR
operator|.
name|args
operator|-
name|L
index|]
expr_stmt|;
name|FT_ARRAY_MOVE
argument_list|(
operator|&
name|CUR
operator|.
name|stack
index|[
name|CUR
operator|.
name|args
operator|-
name|L
index|]
argument_list|,
operator|&
name|CUR
operator|.
name|stack
index|[
name|CUR
operator|.
name|args
operator|-
name|L
operator|+
literal|1
index|]
argument_list|,
operator|(
name|L
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|CUR
operator|.
name|stack
index|[
name|CUR
operator|.
name|args
operator|-
literal|1
index|]
operator|=
name|K
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* ROLL[]:       ROLL top three elements                                 */
end_comment
begin_comment
comment|/* Opcode range: 0x8A                                                    */
end_comment
begin_comment
comment|/* Stack:        3 * StkElt --> 3 * StkElt                               */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_ROLL
name|Ins_ROLL
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|FT_Long
name|A
decl_stmt|,
name|B
decl_stmt|,
name|C
decl_stmt|;
name|FT_UNUSED_EXEC
expr_stmt|;
name|A
operator|=
name|args
index|[
literal|2
index|]
expr_stmt|;
name|B
operator|=
name|args
index|[
literal|1
index|]
expr_stmt|;
name|C
operator|=
name|args
index|[
literal|0
index|]
expr_stmt|;
name|args
index|[
literal|2
index|]
operator|=
name|C
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|A
expr_stmt|;
name|args
index|[
literal|0
index|]
operator|=
name|B
expr_stmt|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* MANAGING THE FLOW OF CONTROL                                          */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*   Instructions appear in the specification's order.                   */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_function
specifier|static
name|FT_Bool
DECL|function|SkipCode
name|SkipCode
parameter_list|(
name|EXEC_OP
parameter_list|)
block|{
name|CUR
operator|.
name|IP
operator|+=
name|CUR
operator|.
name|length
expr_stmt|;
if|if
condition|(
name|CUR
operator|.
name|IP
operator|<
name|CUR
operator|.
name|codeSize
condition|)
block|{
name|CUR
operator|.
name|opcode
operator|=
name|CUR
operator|.
name|code
index|[
name|CUR
operator|.
name|IP
index|]
expr_stmt|;
name|CUR
operator|.
name|length
operator|=
name|opcode_length
index|[
name|CUR
operator|.
name|opcode
index|]
expr_stmt|;
if|if
condition|(
name|CUR
operator|.
name|length
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|CUR
operator|.
name|IP
operator|+
literal|1
operator|>=
name|CUR
operator|.
name|codeSize
condition|)
goto|goto
name|Fail_Overflow
goto|;
name|CUR
operator|.
name|length
operator|=
literal|2
operator|-
name|CUR
operator|.
name|length
operator|*
name|CUR
operator|.
name|code
index|[
name|CUR
operator|.
name|IP
operator|+
literal|1
index|]
expr_stmt|;
block|}
if|if
condition|(
name|CUR
operator|.
name|IP
operator|+
name|CUR
operator|.
name|length
operator|<=
name|CUR
operator|.
name|codeSize
condition|)
return|return
name|SUCCESS
return|;
block|}
name|Fail_Overflow
label|:
name|CUR
operator|.
name|error
operator|=
name|FT_THROW
argument_list|(
name|Code_Overflow
argument_list|)
expr_stmt|;
return|return
name|FAILURE
return|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* IF[]:         IF test                                                 */
end_comment
begin_comment
comment|/* Opcode range: 0x58                                                    */
end_comment
begin_comment
comment|/* Stack:        StkElt -->                                              */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_IF
name|Ins_IF
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|FT_Int
name|nIfs
decl_stmt|;
name|FT_Bool
name|Out
decl_stmt|;
if|if
condition|(
name|args
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
return|return;
name|nIfs
operator|=
literal|1
expr_stmt|;
name|Out
operator|=
literal|0
expr_stmt|;
do|do
block|{
if|if
condition|(
name|SKIP_Code
argument_list|()
operator|==
name|FAILURE
condition|)
return|return;
switch|switch
condition|(
name|CUR
operator|.
name|opcode
condition|)
block|{
case|case
literal|0x58
case|:
comment|/* IF */
name|nIfs
operator|++
expr_stmt|;
break|break;
case|case
literal|0x1B
case|:
comment|/* ELSE */
name|Out
operator|=
name|FT_BOOL
argument_list|(
name|nIfs
operator|==
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x59
case|:
comment|/* EIF */
name|nIfs
operator|--
expr_stmt|;
name|Out
operator|=
name|FT_BOOL
argument_list|(
name|nIfs
operator|==
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|Out
operator|==
literal|0
condition|)
do|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* ELSE[]:       ELSE                                                    */
end_comment
begin_comment
comment|/* Opcode range: 0x1B                                                    */
end_comment
begin_comment
comment|/* Stack:        -->                                                     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_ELSE
name|Ins_ELSE
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|FT_Int
name|nIfs
decl_stmt|;
name|FT_UNUSED_ARG
expr_stmt|;
name|nIfs
operator|=
literal|1
expr_stmt|;
do|do
block|{
if|if
condition|(
name|SKIP_Code
argument_list|()
operator|==
name|FAILURE
condition|)
return|return;
switch|switch
condition|(
name|CUR
operator|.
name|opcode
condition|)
block|{
case|case
literal|0x58
case|:
comment|/* IF */
name|nIfs
operator|++
expr_stmt|;
break|break;
case|case
literal|0x59
case|:
comment|/* EIF */
name|nIfs
operator|--
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|nIfs
operator|!=
literal|0
condition|)
do|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* DEFINING AND USING FUNCTIONS AND INSTRUCTIONS                         */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*   Instructions appear in the specification's order.                   */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* FDEF[]:       Function DEFinition                                     */
end_comment
begin_comment
comment|/* Opcode range: 0x2C                                                    */
end_comment
begin_comment
comment|/* Stack:        uint32 -->                                              */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_FDEF
name|Ins_FDEF
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|FT_ULong
name|n
decl_stmt|;
name|TT_DefRecord
modifier|*
name|rec
decl_stmt|;
name|TT_DefRecord
modifier|*
name|limit
decl_stmt|;
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_SUBPIXEL_HINTING
comment|/* arguments to opcodes are skipped by `SKIP_Code' */
name|FT_Byte
name|opcode_pattern
index|[
literal|9
index|]
index|[
literal|12
index|]
init|=
block|{
comment|/* #0 inline delta function 1 */
block|{
literal|0x4B
block|,
comment|/* PPEM    */
literal|0x53
block|,
comment|/* GTEQ    */
literal|0x23
block|,
comment|/* SWAP    */
literal|0x4B
block|,
comment|/* PPEM    */
literal|0x51
block|,
comment|/* LTEQ    */
literal|0x5A
block|,
comment|/* AND     */
literal|0x58
block|,
comment|/* IF      */
literal|0x38
block|,
comment|/*   SHPIX */
literal|0x1B
block|,
comment|/* ELSE    */
literal|0x21
block|,
comment|/*   POP   */
literal|0x21
block|,
comment|/*   POP   */
literal|0x59
comment|/* EIF     */
block|}
block|,
comment|/* #1 inline delta function 2 */
block|{
literal|0x4B
block|,
comment|/* PPEM    */
literal|0x54
block|,
comment|/* EQ      */
literal|0x58
block|,
comment|/* IF      */
literal|0x38
block|,
comment|/*   SHPIX */
literal|0x1B
block|,
comment|/* ELSE    */
literal|0x21
block|,
comment|/*   POP   */
literal|0x21
block|,
comment|/*   POP   */
literal|0x59
comment|/* EIF     */
block|}
block|,
comment|/* #2 diagonal stroke function */
block|{
literal|0x20
block|,
comment|/* DUP     */
literal|0x20
block|,
comment|/* DUP     */
literal|0xB0
block|,
comment|/* PUSHB_1 */
comment|/*   1     */
literal|0x60
block|,
comment|/* ADD     */
literal|0x46
block|,
comment|/* GC_cur  */
literal|0xB0
block|,
comment|/* PUSHB_1 */
comment|/*   64    */
literal|0x23
block|,
comment|/* SWAP    */
literal|0x42
comment|/* WS      */
block|}
block|,
comment|/* #3 VacuFormRound function */
block|{
literal|0x45
block|,
comment|/* RCVT    */
literal|0x23
block|,
comment|/* SWAP    */
literal|0x46
block|,
comment|/* GC_cur  */
literal|0x60
block|,
comment|/* ADD     */
literal|0x20
block|,
comment|/* DUP     */
literal|0xB0
comment|/* PUSHB_1 */
comment|/*   38    */
block|}
block|,
comment|/* #4 TTFautohint bytecode (old) */
block|{
literal|0x20
block|,
comment|/* DUP     */
literal|0x64
block|,
comment|/* ABS     */
literal|0xB0
block|,
comment|/* PUSHB_1 */
comment|/*   32    */
literal|0x60
block|,
comment|/* ADD     */
literal|0x66
block|,
comment|/* FLOOR   */
literal|0x23
block|,
comment|/* SWAP    */
literal|0xB0
comment|/* PUSHB_1 */
block|}
block|,
comment|/* #5 spacing function 1 */
block|{
literal|0x01
block|,
comment|/* SVTCA_x */
literal|0xB0
block|,
comment|/* PUSHB_1 */
comment|/*   24    */
literal|0x43
block|,
comment|/* RS      */
literal|0x58
comment|/* IF      */
block|}
block|,
comment|/* #6 spacing function 2 */
block|{
literal|0x01
block|,
comment|/* SVTCA_x */
literal|0x18
block|,
comment|/* RTG     */
literal|0xB0
block|,
comment|/* PUSHB_1 */
comment|/*   24    */
literal|0x43
block|,
comment|/* RS      */
literal|0x58
comment|/* IF      */
block|}
block|,
comment|/* #7 TypeMan Talk DiagEndCtrl function */
block|{
literal|0x01
block|,
comment|/* SVTCA_x */
literal|0x20
block|,
comment|/* DUP     */
literal|0xB0
block|,
comment|/* PUSHB_1 */
comment|/*   3     */
literal|0x25
block|,
comment|/* CINDEX  */
block|}
block|,
comment|/* #8 TypeMan Talk Align */
block|{
literal|0x06
block|,
comment|/* SPVTL   */
literal|0x7D
block|,
comment|/* RDTG    */
block|}
block|,                }
decl_stmt|;
name|FT_UShort
name|opcode_patterns
init|=
literal|9
decl_stmt|;
name|FT_UShort
name|opcode_pointer
index|[
literal|9
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|FT_UShort
name|opcode_size
index|[
literal|9
index|]
init|=
block|{
literal|12
block|,
literal|8
block|,
literal|8
block|,
literal|6
block|,
literal|7
block|,
literal|4
block|,
literal|5
block|,
literal|4
block|,
literal|2
block|}
decl_stmt|;
name|FT_UShort
name|i
decl_stmt|;
endif|#
directive|endif
comment|/* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
comment|/* some font programs are broken enough to redefine functions! */
comment|/* We will then parse the current table.                       */
name|rec
operator|=
name|CUR
operator|.
name|FDefs
expr_stmt|;
name|limit
operator|=
name|rec
operator|+
name|CUR
operator|.
name|numFDefs
expr_stmt|;
name|n
operator|=
name|args
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
init|;
name|rec
operator|<
name|limit
condition|;
name|rec
operator|++
control|)
block|{
if|if
condition|(
name|rec
operator|->
name|opc
operator|==
name|n
condition|)
break|break;
block|}
if|if
condition|(
name|rec
operator|==
name|limit
condition|)
block|{
comment|/* check that there is enough room for new functions */
if|if
condition|(
name|CUR
operator|.
name|numFDefs
operator|>=
name|CUR
operator|.
name|maxFDefs
condition|)
block|{
name|CUR
operator|.
name|error
operator|=
name|FT_THROW
argument_list|(
name|Too_Many_Function_Defs
argument_list|)
expr_stmt|;
return|return;
block|}
name|CUR
operator|.
name|numFDefs
operator|++
expr_stmt|;
block|}
comment|/* Although FDEF takes unsigned 32-bit integer,  */
comment|/* func # must be within unsigned 16-bit integer */
if|if
condition|(
name|n
operator|>
literal|0xFFFFU
condition|)
block|{
name|CUR
operator|.
name|error
operator|=
name|FT_THROW
argument_list|(
name|Too_Many_Function_Defs
argument_list|)
expr_stmt|;
return|return;
block|}
name|rec
operator|->
name|range
operator|=
name|CUR
operator|.
name|curRange
expr_stmt|;
name|rec
operator|->
name|opc
operator|=
operator|(
name|FT_UInt16
operator|)
name|n
expr_stmt|;
name|rec
operator|->
name|start
operator|=
name|CUR
operator|.
name|IP
operator|+
literal|1
expr_stmt|;
name|rec
operator|->
name|active
operator|=
name|TRUE
expr_stmt|;
name|rec
operator|->
name|inline_delta
operator|=
name|FALSE
expr_stmt|;
name|rec
operator|->
name|sph_fdef_flags
operator|=
literal|0x0000
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|CUR
operator|.
name|maxFunc
condition|)
name|CUR
operator|.
name|maxFunc
operator|=
operator|(
name|FT_UInt16
operator|)
name|n
expr_stmt|;
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_SUBPIXEL_HINTING
comment|/* We don't know for sure these are typeman functions, */
comment|/* however they are only active when RS 22 is called   */
if|if
condition|(
name|n
operator|>=
literal|64
operator|&&
name|n
operator|<=
literal|66
condition|)
name|rec
operator|->
name|sph_fdef_flags
operator||=
name|SPH_FDEF_TYPEMAN_STROKES
expr_stmt|;
endif|#
directive|endif
comment|/* Now skip the whole function definition. */
comment|/* We don't allow nested IDEFS& FDEFs.    */
while|while
condition|(
name|SKIP_Code
argument_list|()
operator|==
name|SUCCESS
condition|)
block|{
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_SUBPIXEL_HINTING
if|if
condition|(
name|SUBPIXEL_HINTING
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|opcode_patterns
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|opcode_pointer
index|[
name|i
index|]
operator|<
name|opcode_size
index|[
name|i
index|]
operator|&&
name|CUR
operator|.
name|opcode
operator|==
name|opcode_pattern
index|[
name|i
index|]
index|[
name|opcode_pointer
index|[
name|i
index|]
index|]
condition|)
block|{
name|opcode_pointer
index|[
name|i
index|]
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|opcode_pointer
index|[
name|i
index|]
operator|==
name|opcode_size
index|[
name|i
index|]
condition|)
block|{
name|FT_TRACE7
argument_list|(
operator|(
literal|"sph: Function %d, opcode ptrn: %d, %s %s\n"
operator|,
name|i
operator|,
name|n
operator|,
name|CUR
operator|.
name|face
operator|->
name|root
operator|.
name|family_name
operator|,
name|CUR
operator|.
name|face
operator|->
name|root
operator|.
name|style_name
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|0
case|:
name|rec
operator|->
name|sph_fdef_flags
operator||=
name|SPH_FDEF_INLINE_DELTA_1
expr_stmt|;
name|CUR
operator|.
name|face
operator|->
name|sph_found_func_flags
operator||=
name|SPH_FDEF_INLINE_DELTA_1
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|rec
operator|->
name|sph_fdef_flags
operator||=
name|SPH_FDEF_INLINE_DELTA_2
expr_stmt|;
name|CUR
operator|.
name|face
operator|->
name|sph_found_func_flags
operator||=
name|SPH_FDEF_INLINE_DELTA_2
expr_stmt|;
break|break;
case|case
literal|2
case|:
switch|switch
condition|(
name|n
condition|)
block|{
comment|/* needs to be implemented still */
case|case
literal|58
case|:
name|rec
operator|->
name|sph_fdef_flags
operator||=
name|SPH_FDEF_DIAGONAL_STROKE
expr_stmt|;
name|CUR
operator|.
name|face
operator|->
name|sph_found_func_flags
operator||=
name|SPH_FDEF_DIAGONAL_STROKE
expr_stmt|;
block|}
break|break;
case|case
literal|3
case|:
switch|switch
condition|(
name|n
condition|)
block|{
case|case
literal|0
case|:
name|rec
operator|->
name|sph_fdef_flags
operator||=
name|SPH_FDEF_VACUFORM_ROUND_1
expr_stmt|;
name|CUR
operator|.
name|face
operator|->
name|sph_found_func_flags
operator||=
name|SPH_FDEF_VACUFORM_ROUND_1
expr_stmt|;
block|}
break|break;
case|case
literal|4
case|:
comment|/* probably not necessary to detect anymore */
name|rec
operator|->
name|sph_fdef_flags
operator||=
name|SPH_FDEF_TTFAUTOHINT_1
expr_stmt|;
name|CUR
operator|.
name|face
operator|->
name|sph_found_func_flags
operator||=
name|SPH_FDEF_TTFAUTOHINT_1
expr_stmt|;
break|break;
case|case
literal|5
case|:
switch|switch
condition|(
name|n
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|1
case|:
case|case
literal|2
case|:
case|case
literal|4
case|:
case|case
literal|7
case|:
case|case
literal|8
case|:
name|rec
operator|->
name|sph_fdef_flags
operator||=
name|SPH_FDEF_SPACING_1
expr_stmt|;
name|CUR
operator|.
name|face
operator|->
name|sph_found_func_flags
operator||=
name|SPH_FDEF_SPACING_1
expr_stmt|;
block|}
break|break;
case|case
literal|6
case|:
switch|switch
condition|(
name|n
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|1
case|:
case|case
literal|2
case|:
case|case
literal|4
case|:
case|case
literal|7
case|:
case|case
literal|8
case|:
name|rec
operator|->
name|sph_fdef_flags
operator||=
name|SPH_FDEF_SPACING_2
expr_stmt|;
name|CUR
operator|.
name|face
operator|->
name|sph_found_func_flags
operator||=
name|SPH_FDEF_SPACING_2
expr_stmt|;
block|}
break|break;
case|case
literal|7
case|:
name|rec
operator|->
name|sph_fdef_flags
operator||=
name|SPH_FDEF_TYPEMAN_DIAGENDCTRL
expr_stmt|;
name|CUR
operator|.
name|face
operator|->
name|sph_found_func_flags
operator||=
name|SPH_FDEF_TYPEMAN_DIAGENDCTRL
expr_stmt|;
break|break;
case|case
literal|8
case|:
if|#
directive|if
literal|0
block|rec->sph_fdef_flags            |= SPH_FDEF_TYPEMAN_DIAGENDCTRL;                  CUR.face->sph_found_func_flags |= SPH_FDEF_TYPEMAN_DIAGENDCTRL;
endif|#
directive|endif
break|break;
block|}
name|opcode_pointer
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
name|opcode_pointer
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Set sph_compatibility_mode only when deltas are detected */
name|CUR
operator|.
name|face
operator|->
name|sph_compatibility_mode
operator|=
operator|(
operator|(
name|CUR
operator|.
name|face
operator|->
name|sph_found_func_flags
operator|&
name|SPH_FDEF_INLINE_DELTA_1
operator|)
operator||
operator|(
name|CUR
operator|.
name|face
operator|->
name|sph_found_func_flags
operator|&
name|SPH_FDEF_INLINE_DELTA_2
operator|)
operator|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
switch|switch
condition|(
name|CUR
operator|.
name|opcode
condition|)
block|{
case|case
literal|0x89
case|:
comment|/* IDEF */
case|case
literal|0x2C
case|:
comment|/* FDEF */
name|CUR
operator|.
name|error
operator|=
name|FT_THROW
argument_list|(
name|Nested_DEFS
argument_list|)
expr_stmt|;
return|return;
case|case
literal|0x2D
case|:
comment|/* ENDF */
name|rec
operator|->
name|end
operator|=
name|CUR
operator|.
name|IP
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* ENDF[]:       END Function definition                                 */
end_comment
begin_comment
comment|/* Opcode range: 0x2D                                                    */
end_comment
begin_comment
comment|/* Stack:        -->                                                     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_ENDF
name|Ins_ENDF
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|TT_CallRec
modifier|*
name|pRec
decl_stmt|;
name|FT_UNUSED_ARG
expr_stmt|;
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_SUBPIXEL_HINTING
name|CUR
operator|.
name|sph_in_func_flags
operator|=
literal|0x0000
expr_stmt|;
endif|#
directive|endif
comment|/* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
if|if
condition|(
name|CUR
operator|.
name|callTop
operator|<=
literal|0
condition|)
comment|/* We encountered an ENDF without a call */
block|{
name|CUR
operator|.
name|error
operator|=
name|FT_THROW
argument_list|(
name|ENDF_In_Exec_Stream
argument_list|)
expr_stmt|;
return|return;
block|}
name|CUR
operator|.
name|callTop
operator|--
expr_stmt|;
name|pRec
operator|=
operator|&
name|CUR
operator|.
name|callStack
index|[
name|CUR
operator|.
name|callTop
index|]
expr_stmt|;
name|pRec
operator|->
name|Cur_Count
operator|--
expr_stmt|;
name|CUR
operator|.
name|step_ins
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|pRec
operator|->
name|Cur_Count
operator|>
literal|0
condition|)
block|{
name|CUR
operator|.
name|callTop
operator|++
expr_stmt|;
name|CUR
operator|.
name|IP
operator|=
name|pRec
operator|->
name|Def
operator|->
name|start
expr_stmt|;
block|}
else|else
comment|/* Loop through the current function */
name|INS_Goto_CodeRange
argument_list|(
name|pRec
operator|->
name|Caller_Range
argument_list|,
name|pRec
operator|->
name|Caller_IP
argument_list|)
expr_stmt|;
comment|/* Exit the current call frame.                      */
comment|/* NOTE: If the last instruction of a program is a   */
comment|/*       CALL or LOOPCALL, the return address is     */
comment|/*       always out of the code range.  This is a    */
comment|/*       valid address, and it is why we do not test */
comment|/*       the result of Ins_Goto_CodeRange() here!    */
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* CALL[]:       CALL function                                           */
end_comment
begin_comment
comment|/* Opcode range: 0x2B                                                    */
end_comment
begin_comment
comment|/* Stack:        uint32? -->                                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_CALL
name|Ins_CALL
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|FT_ULong
name|F
decl_stmt|;
name|TT_CallRec
modifier|*
name|pCrec
decl_stmt|;
name|TT_DefRecord
modifier|*
name|def
decl_stmt|;
comment|/* first of all, check the index */
name|F
operator|=
name|args
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|BOUNDSL
argument_list|(
name|F
argument_list|,
name|CUR
operator|.
name|maxFunc
operator|+
literal|1
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
comment|/* Except for some old Apple fonts, all functions in a TrueType */
comment|/* font are defined in increasing order, starting from 0.  This */
comment|/* means that we normally have                                  */
comment|/*                                                              */
comment|/*    CUR.maxFunc+1 == CUR.numFDefs                             */
comment|/*    CUR.FDefs[n].opc == n for n in 0..CUR.maxFunc             */
comment|/*                                                              */
comment|/* If this isn't true, we need to look up the function table.   */
name|def
operator|=
name|CUR
operator|.
name|FDefs
operator|+
name|F
expr_stmt|;
if|if
condition|(
name|CUR
operator|.
name|maxFunc
operator|+
literal|1
operator|!=
name|CUR
operator|.
name|numFDefs
operator|||
name|def
operator|->
name|opc
operator|!=
name|F
condition|)
block|{
comment|/* look up the FDefs table */
name|TT_DefRecord
modifier|*
name|limit
decl_stmt|;
name|def
operator|=
name|CUR
operator|.
name|FDefs
expr_stmt|;
name|limit
operator|=
name|def
operator|+
name|CUR
operator|.
name|numFDefs
expr_stmt|;
while|while
condition|(
name|def
operator|<
name|limit
operator|&&
name|def
operator|->
name|opc
operator|!=
name|F
condition|)
name|def
operator|++
expr_stmt|;
if|if
condition|(
name|def
operator|==
name|limit
condition|)
goto|goto
name|Fail
goto|;
block|}
comment|/* check that the function is active */
if|if
condition|(
operator|!
name|def
operator|->
name|active
condition|)
goto|goto
name|Fail
goto|;
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_SUBPIXEL_HINTING
if|if
condition|(
name|SUBPIXEL_HINTING
operator|&&
name|CUR
operator|.
name|ignore_x_mode
operator|&&
operator|(
operator|(
name|CUR
operator|.
name|iup_called
operator|&&
operator|(
name|CUR
operator|.
name|sph_tweak_flags
operator|&
name|SPH_TWEAK_NO_CALL_AFTER_IUP
operator|)
operator|)
operator|||
operator|(
name|def
operator|->
name|sph_fdef_flags
operator|&
name|SPH_FDEF_VACUFORM_ROUND_1
operator|)
operator|)
condition|)
goto|goto
name|Fail
goto|;
else|else
name|CUR
operator|.
name|sph_in_func_flags
operator|=
name|def
operator|->
name|sph_fdef_flags
expr_stmt|;
endif|#
directive|endif
comment|/* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
comment|/* check the call stack */
if|if
condition|(
name|CUR
operator|.
name|callTop
operator|>=
name|CUR
operator|.
name|callSize
condition|)
block|{
name|CUR
operator|.
name|error
operator|=
name|FT_THROW
argument_list|(
name|Stack_Overflow
argument_list|)
expr_stmt|;
return|return;
block|}
name|pCrec
operator|=
name|CUR
operator|.
name|callStack
operator|+
name|CUR
operator|.
name|callTop
expr_stmt|;
name|pCrec
operator|->
name|Caller_Range
operator|=
name|CUR
operator|.
name|curRange
expr_stmt|;
name|pCrec
operator|->
name|Caller_IP
operator|=
name|CUR
operator|.
name|IP
operator|+
literal|1
expr_stmt|;
name|pCrec
operator|->
name|Cur_Count
operator|=
literal|1
expr_stmt|;
name|pCrec
operator|->
name|Def
operator|=
name|def
expr_stmt|;
name|CUR
operator|.
name|callTop
operator|++
expr_stmt|;
name|INS_Goto_CodeRange
argument_list|(
name|def
operator|->
name|range
argument_list|,
name|def
operator|->
name|start
argument_list|)
expr_stmt|;
name|CUR
operator|.
name|step_ins
operator|=
name|FALSE
expr_stmt|;
return|return;
name|Fail
label|:
name|CUR
operator|.
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Reference
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* LOOPCALL[]:   LOOP and CALL function                                  */
end_comment
begin_comment
comment|/* Opcode range: 0x2A                                                    */
end_comment
begin_comment
comment|/* Stack:        uint32? Eint16? -->                                     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_LOOPCALL
name|Ins_LOOPCALL
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|FT_ULong
name|F
decl_stmt|;
name|TT_CallRec
modifier|*
name|pCrec
decl_stmt|;
name|TT_DefRecord
modifier|*
name|def
decl_stmt|;
comment|/* first of all, check the index */
name|F
operator|=
name|args
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|BOUNDSL
argument_list|(
name|F
argument_list|,
name|CUR
operator|.
name|maxFunc
operator|+
literal|1
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
comment|/* Except for some old Apple fonts, all functions in a TrueType */
comment|/* font are defined in increasing order, starting from 0.  This */
comment|/* means that we normally have                                  */
comment|/*                                                              */
comment|/*    CUR.maxFunc+1 == CUR.numFDefs                             */
comment|/*    CUR.FDefs[n].opc == n for n in 0..CUR.maxFunc             */
comment|/*                                                              */
comment|/* If this isn't true, we need to look up the function table.   */
name|def
operator|=
name|CUR
operator|.
name|FDefs
operator|+
name|F
expr_stmt|;
if|if
condition|(
name|CUR
operator|.
name|maxFunc
operator|+
literal|1
operator|!=
name|CUR
operator|.
name|numFDefs
operator|||
name|def
operator|->
name|opc
operator|!=
name|F
condition|)
block|{
comment|/* look up the FDefs table */
name|TT_DefRecord
modifier|*
name|limit
decl_stmt|;
name|def
operator|=
name|CUR
operator|.
name|FDefs
expr_stmt|;
name|limit
operator|=
name|def
operator|+
name|CUR
operator|.
name|numFDefs
expr_stmt|;
while|while
condition|(
name|def
operator|<
name|limit
operator|&&
name|def
operator|->
name|opc
operator|!=
name|F
condition|)
name|def
operator|++
expr_stmt|;
if|if
condition|(
name|def
operator|==
name|limit
condition|)
goto|goto
name|Fail
goto|;
block|}
comment|/* check that the function is active */
if|if
condition|(
operator|!
name|def
operator|->
name|active
condition|)
goto|goto
name|Fail
goto|;
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_SUBPIXEL_HINTING
if|if
condition|(
name|SUBPIXEL_HINTING
operator|&&
name|CUR
operator|.
name|ignore_x_mode
operator|&&
operator|(
name|def
operator|->
name|sph_fdef_flags
operator|&
name|SPH_FDEF_VACUFORM_ROUND_1
operator|)
condition|)
goto|goto
name|Fail
goto|;
else|else
name|CUR
operator|.
name|sph_in_func_flags
operator|=
name|def
operator|->
name|sph_fdef_flags
expr_stmt|;
endif|#
directive|endif
comment|/* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
comment|/* check stack */
if|if
condition|(
name|CUR
operator|.
name|callTop
operator|>=
name|CUR
operator|.
name|callSize
condition|)
block|{
name|CUR
operator|.
name|error
operator|=
name|FT_THROW
argument_list|(
name|Stack_Overflow
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|args
index|[
literal|0
index|]
operator|>
literal|0
condition|)
block|{
name|pCrec
operator|=
name|CUR
operator|.
name|callStack
operator|+
name|CUR
operator|.
name|callTop
expr_stmt|;
name|pCrec
operator|->
name|Caller_Range
operator|=
name|CUR
operator|.
name|curRange
expr_stmt|;
name|pCrec
operator|->
name|Caller_IP
operator|=
name|CUR
operator|.
name|IP
operator|+
literal|1
expr_stmt|;
name|pCrec
operator|->
name|Cur_Count
operator|=
operator|(
name|FT_Int
operator|)
name|args
index|[
literal|0
index|]
expr_stmt|;
name|pCrec
operator|->
name|Def
operator|=
name|def
expr_stmt|;
name|CUR
operator|.
name|callTop
operator|++
expr_stmt|;
name|INS_Goto_CodeRange
argument_list|(
name|def
operator|->
name|range
argument_list|,
name|def
operator|->
name|start
argument_list|)
expr_stmt|;
name|CUR
operator|.
name|step_ins
operator|=
name|FALSE
expr_stmt|;
block|}
return|return;
name|Fail
label|:
name|CUR
operator|.
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Reference
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* IDEF[]:       Instruction DEFinition                                  */
end_comment
begin_comment
comment|/* Opcode range: 0x89                                                    */
end_comment
begin_comment
comment|/* Stack:        Eint8 -->                                               */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_IDEF
name|Ins_IDEF
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|TT_DefRecord
modifier|*
name|def
decl_stmt|;
name|TT_DefRecord
modifier|*
name|limit
decl_stmt|;
comment|/*  First of all, look for the same function in our table */
name|def
operator|=
name|CUR
operator|.
name|IDefs
expr_stmt|;
name|limit
operator|=
name|def
operator|+
name|CUR
operator|.
name|numIDefs
expr_stmt|;
for|for
control|(
init|;
name|def
operator|<
name|limit
condition|;
name|def
operator|++
control|)
if|if
condition|(
name|def
operator|->
name|opc
operator|==
operator|(
name|FT_ULong
operator|)
name|args
index|[
literal|0
index|]
condition|)
break|break;
if|if
condition|(
name|def
operator|==
name|limit
condition|)
block|{
comment|/* check that there is enough room for a new instruction */
if|if
condition|(
name|CUR
operator|.
name|numIDefs
operator|>=
name|CUR
operator|.
name|maxIDefs
condition|)
block|{
name|CUR
operator|.
name|error
operator|=
name|FT_THROW
argument_list|(
name|Too_Many_Instruction_Defs
argument_list|)
expr_stmt|;
return|return;
block|}
name|CUR
operator|.
name|numIDefs
operator|++
expr_stmt|;
block|}
comment|/* opcode must be unsigned 8-bit integer */
if|if
condition|(
literal|0
operator|>
name|args
index|[
literal|0
index|]
operator|||
name|args
index|[
literal|0
index|]
operator|>
literal|0x00FF
condition|)
block|{
name|CUR
operator|.
name|error
operator|=
name|FT_THROW
argument_list|(
name|Too_Many_Instruction_Defs
argument_list|)
expr_stmt|;
return|return;
block|}
name|def
operator|->
name|opc
operator|=
operator|(
name|FT_Byte
operator|)
name|args
index|[
literal|0
index|]
expr_stmt|;
name|def
operator|->
name|start
operator|=
name|CUR
operator|.
name|IP
operator|+
literal|1
expr_stmt|;
name|def
operator|->
name|range
operator|=
name|CUR
operator|.
name|curRange
expr_stmt|;
name|def
operator|->
name|active
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|(
name|FT_ULong
operator|)
name|args
index|[
literal|0
index|]
operator|>
name|CUR
operator|.
name|maxIns
condition|)
name|CUR
operator|.
name|maxIns
operator|=
operator|(
name|FT_Byte
operator|)
name|args
index|[
literal|0
index|]
expr_stmt|;
comment|/* Now skip the whole function definition. */
comment|/* We don't allow nested IDEFs& FDEFs.    */
while|while
condition|(
name|SKIP_Code
argument_list|()
operator|==
name|SUCCESS
condition|)
block|{
switch|switch
condition|(
name|CUR
operator|.
name|opcode
condition|)
block|{
case|case
literal|0x89
case|:
comment|/* IDEF */
case|case
literal|0x2C
case|:
comment|/* FDEF */
name|CUR
operator|.
name|error
operator|=
name|FT_THROW
argument_list|(
name|Nested_DEFS
argument_list|)
expr_stmt|;
return|return;
case|case
literal|0x2D
case|:
comment|/* ENDF */
return|return;
block|}
block|}
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* PUSHING DATA ONTO THE INTERPRETER STACK                               */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*   Instructions appear in the specification's order.                   */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* NPUSHB[]:     PUSH N Bytes                                            */
end_comment
begin_comment
comment|/* Opcode range: 0x40                                                    */
end_comment
begin_comment
comment|/* Stack:        --> uint32...                                           */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_NPUSHB
name|Ins_NPUSHB
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|FT_UShort
name|L
decl_stmt|,
name|K
decl_stmt|;
name|L
operator|=
operator|(
name|FT_UShort
operator|)
name|CUR
operator|.
name|code
index|[
name|CUR
operator|.
name|IP
operator|+
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|BOUNDS
argument_list|(
name|L
argument_list|,
name|CUR
operator|.
name|stackSize
operator|+
literal|1
operator|-
name|CUR
operator|.
name|top
argument_list|)
condition|)
block|{
name|CUR
operator|.
name|error
operator|=
name|FT_THROW
argument_list|(
name|Stack_Overflow
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|K
operator|=
literal|1
init|;
name|K
operator|<=
name|L
condition|;
name|K
operator|++
control|)
name|args
index|[
name|K
operator|-
literal|1
index|]
operator|=
name|CUR
operator|.
name|code
index|[
name|CUR
operator|.
name|IP
operator|+
name|K
operator|+
literal|1
index|]
expr_stmt|;
name|CUR
operator|.
name|new_top
operator|+=
name|L
expr_stmt|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* NPUSHW[]:     PUSH N Words                                            */
end_comment
begin_comment
comment|/* Opcode range: 0x41                                                    */
end_comment
begin_comment
comment|/* Stack:        --> int32...                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_NPUSHW
name|Ins_NPUSHW
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|FT_UShort
name|L
decl_stmt|,
name|K
decl_stmt|;
name|L
operator|=
operator|(
name|FT_UShort
operator|)
name|CUR
operator|.
name|code
index|[
name|CUR
operator|.
name|IP
operator|+
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|BOUNDS
argument_list|(
name|L
argument_list|,
name|CUR
operator|.
name|stackSize
operator|+
literal|1
operator|-
name|CUR
operator|.
name|top
argument_list|)
condition|)
block|{
name|CUR
operator|.
name|error
operator|=
name|FT_THROW
argument_list|(
name|Stack_Overflow
argument_list|)
expr_stmt|;
return|return;
block|}
name|CUR
operator|.
name|IP
operator|+=
literal|2
expr_stmt|;
for|for
control|(
name|K
operator|=
literal|0
init|;
name|K
operator|<
name|L
condition|;
name|K
operator|++
control|)
name|args
index|[
name|K
index|]
operator|=
name|GET_ShortIns
argument_list|()
expr_stmt|;
name|CUR
operator|.
name|step_ins
operator|=
name|FALSE
expr_stmt|;
name|CUR
operator|.
name|new_top
operator|+=
name|L
expr_stmt|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* PUSHB[abc]:   PUSH Bytes                                              */
end_comment
begin_comment
comment|/* Opcode range: 0xB0-0xB7                                               */
end_comment
begin_comment
comment|/* Stack:        --> uint32...                                           */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_PUSHB
name|Ins_PUSHB
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|FT_UShort
name|L
decl_stmt|,
name|K
decl_stmt|;
name|L
operator|=
call|(
name|FT_UShort
call|)
argument_list|(
name|CUR
operator|.
name|opcode
operator|-
literal|0xB0
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|BOUNDS
argument_list|(
name|L
argument_list|,
name|CUR
operator|.
name|stackSize
operator|+
literal|1
operator|-
name|CUR
operator|.
name|top
argument_list|)
condition|)
block|{
name|CUR
operator|.
name|error
operator|=
name|FT_THROW
argument_list|(
name|Stack_Overflow
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|K
operator|=
literal|1
init|;
name|K
operator|<=
name|L
condition|;
name|K
operator|++
control|)
name|args
index|[
name|K
operator|-
literal|1
index|]
operator|=
name|CUR
operator|.
name|code
index|[
name|CUR
operator|.
name|IP
operator|+
name|K
index|]
expr_stmt|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* PUSHW[abc]:   PUSH Words                                              */
end_comment
begin_comment
comment|/* Opcode range: 0xB8-0xBF                                               */
end_comment
begin_comment
comment|/* Stack:        --> int32...                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_PUSHW
name|Ins_PUSHW
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|FT_UShort
name|L
decl_stmt|,
name|K
decl_stmt|;
name|L
operator|=
call|(
name|FT_UShort
call|)
argument_list|(
name|CUR
operator|.
name|opcode
operator|-
literal|0xB8
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|BOUNDS
argument_list|(
name|L
argument_list|,
name|CUR
operator|.
name|stackSize
operator|+
literal|1
operator|-
name|CUR
operator|.
name|top
argument_list|)
condition|)
block|{
name|CUR
operator|.
name|error
operator|=
name|FT_THROW
argument_list|(
name|Stack_Overflow
argument_list|)
expr_stmt|;
return|return;
block|}
name|CUR
operator|.
name|IP
operator|++
expr_stmt|;
for|for
control|(
name|K
operator|=
literal|0
init|;
name|K
operator|<
name|L
condition|;
name|K
operator|++
control|)
name|args
index|[
name|K
index|]
operator|=
name|GET_ShortIns
argument_list|()
expr_stmt|;
name|CUR
operator|.
name|step_ins
operator|=
name|FALSE
expr_stmt|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* MANAGING THE GRAPHICS STATE                                           */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*  Instructions appear in the specs' order.                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* GC[a]:        Get Coordinate projected onto                           */
end_comment
begin_comment
comment|/* Opcode range: 0x46-0x47                                               */
end_comment
begin_comment
comment|/* Stack:        uint32 --> f26.6                                        */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* XXX: UNDOCUMENTED: Measures from the original glyph must be taken     */
end_comment
begin_comment
comment|/*      along the dual projection vector!                                */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_GC
name|Ins_GC
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|FT_ULong
name|L
decl_stmt|;
name|FT_F26Dot6
name|R
decl_stmt|;
name|L
operator|=
operator|(
name|FT_ULong
operator|)
name|args
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|BOUNDSL
argument_list|(
name|L
argument_list|,
name|CUR
operator|.
name|zp2
operator|.
name|n_points
argument_list|)
condition|)
block|{
if|if
condition|(
name|CUR
operator|.
name|pedantic_hinting
condition|)
name|CUR
operator|.
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Reference
argument_list|)
expr_stmt|;
name|R
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|CUR
operator|.
name|opcode
operator|&
literal|1
condition|)
name|R
operator|=
name|CUR_fast_dualproj
argument_list|(
operator|&
name|CUR
operator|.
name|zp2
operator|.
name|org
index|[
name|L
index|]
argument_list|)
expr_stmt|;
else|else
name|R
operator|=
name|CUR_fast_project
argument_list|(
operator|&
name|CUR
operator|.
name|zp2
operator|.
name|cur
index|[
name|L
index|]
argument_list|)
expr_stmt|;
block|}
name|args
index|[
literal|0
index|]
operator|=
name|R
expr_stmt|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* SCFS[]:       Set Coordinate From Stack                               */
end_comment
begin_comment
comment|/* Opcode range: 0x48                                                    */
end_comment
begin_comment
comment|/* Stack:        f26.6 uint32 -->                                        */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* Formula:                                                              */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*   OA := OA + ( value - OA.p )/( f.p ) * f                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_SCFS
name|Ins_SCFS
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|FT_Long
name|K
decl_stmt|;
name|FT_UShort
name|L
decl_stmt|;
name|L
operator|=
operator|(
name|FT_UShort
operator|)
name|args
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|BOUNDS
argument_list|(
name|L
argument_list|,
name|CUR
operator|.
name|zp2
operator|.
name|n_points
argument_list|)
condition|)
block|{
if|if
condition|(
name|CUR
operator|.
name|pedantic_hinting
condition|)
name|CUR
operator|.
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Reference
argument_list|)
expr_stmt|;
return|return;
block|}
name|K
operator|=
name|CUR_fast_project
argument_list|(
operator|&
name|CUR
operator|.
name|zp2
operator|.
name|cur
index|[
name|L
index|]
argument_list|)
expr_stmt|;
name|CUR_Func_move
argument_list|(
operator|&
name|CUR
operator|.
name|zp2
argument_list|,
name|L
argument_list|,
name|args
index|[
literal|1
index|]
operator|-
name|K
argument_list|)
expr_stmt|;
comment|/* UNDOCUMENTED!  The MS rasterizer does that with */
comment|/* twilight points (confirmed by Greg Hitchcock)   */
if|if
condition|(
name|CUR
operator|.
name|GS
operator|.
name|gep2
operator|==
literal|0
condition|)
name|CUR
operator|.
name|zp2
operator|.
name|org
index|[
name|L
index|]
operator|=
name|CUR
operator|.
name|zp2
operator|.
name|cur
index|[
name|L
index|]
expr_stmt|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* MD[a]:        Measure Distance                                        */
end_comment
begin_comment
comment|/* Opcode range: 0x49-0x4A                                               */
end_comment
begin_comment
comment|/* Stack:        uint32 uint32 --> f26.6                                 */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* XXX: UNDOCUMENTED: Measure taken in the original glyph must be along  */
end_comment
begin_comment
comment|/*                    the dual projection vector.                        */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* XXX: UNDOCUMENTED: Flag attributes are inverted!                      */
end_comment
begin_comment
comment|/*                      0 => measure distance in original outline        */
end_comment
begin_comment
comment|/*                      1 => measure distance in grid-fitted outline     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* XXX: UNDOCUMENTED: `zp0 - zp1', and not `zp2 - zp1!                   */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_MD
name|Ins_MD
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|FT_UShort
name|K
decl_stmt|,
name|L
decl_stmt|;
name|FT_F26Dot6
name|D
decl_stmt|;
name|K
operator|=
operator|(
name|FT_UShort
operator|)
name|args
index|[
literal|1
index|]
expr_stmt|;
name|L
operator|=
operator|(
name|FT_UShort
operator|)
name|args
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|BOUNDS
argument_list|(
name|L
argument_list|,
name|CUR
operator|.
name|zp0
operator|.
name|n_points
argument_list|)
operator|||
name|BOUNDS
argument_list|(
name|K
argument_list|,
name|CUR
operator|.
name|zp1
operator|.
name|n_points
argument_list|)
condition|)
block|{
if|if
condition|(
name|CUR
operator|.
name|pedantic_hinting
condition|)
name|CUR
operator|.
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Reference
argument_list|)
expr_stmt|;
name|D
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|CUR
operator|.
name|opcode
operator|&
literal|1
condition|)
name|D
operator|=
name|CUR_Func_project
argument_list|(
name|CUR
operator|.
name|zp0
operator|.
name|cur
operator|+
name|L
argument_list|,
name|CUR
operator|.
name|zp1
operator|.
name|cur
operator|+
name|K
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* XXX: UNDOCUMENTED: twilight zone special case */
if|if
condition|(
name|CUR
operator|.
name|GS
operator|.
name|gep0
operator|==
literal|0
operator|||
name|CUR
operator|.
name|GS
operator|.
name|gep1
operator|==
literal|0
condition|)
block|{
name|FT_Vector
modifier|*
name|vec1
init|=
name|CUR
operator|.
name|zp0
operator|.
name|org
operator|+
name|L
decl_stmt|;
name|FT_Vector
modifier|*
name|vec2
init|=
name|CUR
operator|.
name|zp1
operator|.
name|org
operator|+
name|K
decl_stmt|;
name|D
operator|=
name|CUR_Func_dualproj
argument_list|(
name|vec1
argument_list|,
name|vec2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|FT_Vector
modifier|*
name|vec1
init|=
name|CUR
operator|.
name|zp0
operator|.
name|orus
operator|+
name|L
decl_stmt|;
name|FT_Vector
modifier|*
name|vec2
init|=
name|CUR
operator|.
name|zp1
operator|.
name|orus
operator|+
name|K
decl_stmt|;
if|if
condition|(
name|CUR
operator|.
name|metrics
operator|.
name|x_scale
operator|==
name|CUR
operator|.
name|metrics
operator|.
name|y_scale
condition|)
block|{
comment|/* this should be faster */
name|D
operator|=
name|CUR_Func_dualproj
argument_list|(
name|vec1
argument_list|,
name|vec2
argument_list|)
expr_stmt|;
name|D
operator|=
name|FT_MulFix
argument_list|(
name|D
argument_list|,
name|CUR
operator|.
name|metrics
operator|.
name|x_scale
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|FT_Vector
name|vec
decl_stmt|;
name|vec
operator|.
name|x
operator|=
name|FT_MulFix
argument_list|(
name|vec1
operator|->
name|x
operator|-
name|vec2
operator|->
name|x
argument_list|,
name|CUR
operator|.
name|metrics
operator|.
name|x_scale
argument_list|)
expr_stmt|;
name|vec
operator|.
name|y
operator|=
name|FT_MulFix
argument_list|(
name|vec1
operator|->
name|y
operator|-
name|vec2
operator|->
name|y
argument_list|,
name|CUR
operator|.
name|metrics
operator|.
name|y_scale
argument_list|)
expr_stmt|;
name|D
operator|=
name|CUR_fast_dualproj
argument_list|(
operator|&
name|vec
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_SUBPIXEL_HINTING
comment|/* Disable Type 2 Vacuform Rounds - e.g. Arial Narrow */
if|if
condition|(
name|SUBPIXEL_HINTING
operator|&&
name|CUR
operator|.
name|ignore_x_mode
operator|&&
name|FT_ABS
argument_list|(
name|D
argument_list|)
operator|==
literal|64
condition|)
name|D
operator|+=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
name|args
index|[
literal|0
index|]
operator|=
name|D
expr_stmt|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* SDPVTL[a]:    Set Dual PVector to Line                                */
end_comment
begin_comment
comment|/* Opcode range: 0x86-0x87                                               */
end_comment
begin_comment
comment|/* Stack:        uint32 uint32 -->                                       */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_SDPVTL
name|Ins_SDPVTL
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|FT_Long
name|A
decl_stmt|,
name|B
decl_stmt|,
name|C
decl_stmt|;
name|FT_UShort
name|p1
decl_stmt|,
name|p2
decl_stmt|;
comment|/* was FT_Int in pas type ERROR */
name|FT_Int
name|aOpc
init|=
name|CUR
operator|.
name|opcode
decl_stmt|;
name|p1
operator|=
operator|(
name|FT_UShort
operator|)
name|args
index|[
literal|1
index|]
expr_stmt|;
name|p2
operator|=
operator|(
name|FT_UShort
operator|)
name|args
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|BOUNDS
argument_list|(
name|p2
argument_list|,
name|CUR
operator|.
name|zp1
operator|.
name|n_points
argument_list|)
operator|||
name|BOUNDS
argument_list|(
name|p1
argument_list|,
name|CUR
operator|.
name|zp2
operator|.
name|n_points
argument_list|)
condition|)
block|{
if|if
condition|(
name|CUR
operator|.
name|pedantic_hinting
condition|)
name|CUR
operator|.
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Reference
argument_list|)
expr_stmt|;
return|return;
block|}
block|{
name|FT_Vector
modifier|*
name|v1
init|=
name|CUR
operator|.
name|zp1
operator|.
name|org
operator|+
name|p2
decl_stmt|;
name|FT_Vector
modifier|*
name|v2
init|=
name|CUR
operator|.
name|zp2
operator|.
name|org
operator|+
name|p1
decl_stmt|;
name|A
operator|=
name|v1
operator|->
name|x
operator|-
name|v2
operator|->
name|x
expr_stmt|;
name|B
operator|=
name|v1
operator|->
name|y
operator|-
name|v2
operator|->
name|y
expr_stmt|;
comment|/* If v1 == v2, SDPVTL behaves the same as */
comment|/* SVTCA[X], respectively.                 */
comment|/*                                         */
comment|/* Confirmed by Greg Hitchcock.            */
if|if
condition|(
name|A
operator|==
literal|0
operator|&&
name|B
operator|==
literal|0
condition|)
block|{
name|A
operator|=
literal|0x4000
expr_stmt|;
name|aOpc
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|aOpc
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
name|C
operator|=
name|B
expr_stmt|;
comment|/* counter clockwise rotation */
name|B
operator|=
name|A
expr_stmt|;
name|A
operator|=
operator|-
name|C
expr_stmt|;
block|}
name|NORMalize
argument_list|(
name|A
argument_list|,
name|B
argument_list|,
operator|&
name|CUR
operator|.
name|GS
operator|.
name|dualVector
argument_list|)
expr_stmt|;
block|{
name|FT_Vector
modifier|*
name|v1
init|=
name|CUR
operator|.
name|zp1
operator|.
name|cur
operator|+
name|p2
decl_stmt|;
name|FT_Vector
modifier|*
name|v2
init|=
name|CUR
operator|.
name|zp2
operator|.
name|cur
operator|+
name|p1
decl_stmt|;
name|A
operator|=
name|v1
operator|->
name|x
operator|-
name|v2
operator|->
name|x
expr_stmt|;
name|B
operator|=
name|v1
operator|->
name|y
operator|-
name|v2
operator|->
name|y
expr_stmt|;
if|if
condition|(
name|A
operator|==
literal|0
operator|&&
name|B
operator|==
literal|0
condition|)
block|{
name|A
operator|=
literal|0x4000
expr_stmt|;
name|aOpc
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|aOpc
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
name|C
operator|=
name|B
expr_stmt|;
comment|/* counter clockwise rotation */
name|B
operator|=
name|A
expr_stmt|;
name|A
operator|=
operator|-
name|C
expr_stmt|;
block|}
name|NORMalize
argument_list|(
name|A
argument_list|,
name|B
argument_list|,
operator|&
name|CUR
operator|.
name|GS
operator|.
name|projVector
argument_list|)
expr_stmt|;
name|GUESS_VECTOR
argument_list|(
name|freeVector
argument_list|)
expr_stmt|;
name|COMPUTE_Funcs
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* SZP0[]:       Set Zone Pointer 0                                      */
end_comment
begin_comment
comment|/* Opcode range: 0x13                                                    */
end_comment
begin_comment
comment|/* Stack:        uint32 -->                                              */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_SZP0
name|Ins_SZP0
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
switch|switch
condition|(
operator|(
name|FT_Int
operator|)
name|args
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|0
case|:
name|CUR
operator|.
name|zp0
operator|=
name|CUR
operator|.
name|twilight
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|CUR
operator|.
name|zp0
operator|=
name|CUR
operator|.
name|pts
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|CUR
operator|.
name|pedantic_hinting
condition|)
name|CUR
operator|.
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Reference
argument_list|)
expr_stmt|;
return|return;
block|}
name|CUR
operator|.
name|GS
operator|.
name|gep0
operator|=
operator|(
name|FT_UShort
operator|)
name|args
index|[
literal|0
index|]
expr_stmt|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* SZP1[]:       Set Zone Pointer 1                                      */
end_comment
begin_comment
comment|/* Opcode range: 0x14                                                    */
end_comment
begin_comment
comment|/* Stack:        uint32 -->                                              */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_SZP1
name|Ins_SZP1
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
switch|switch
condition|(
operator|(
name|FT_Int
operator|)
name|args
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|0
case|:
name|CUR
operator|.
name|zp1
operator|=
name|CUR
operator|.
name|twilight
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|CUR
operator|.
name|zp1
operator|=
name|CUR
operator|.
name|pts
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|CUR
operator|.
name|pedantic_hinting
condition|)
name|CUR
operator|.
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Reference
argument_list|)
expr_stmt|;
return|return;
block|}
name|CUR
operator|.
name|GS
operator|.
name|gep1
operator|=
operator|(
name|FT_UShort
operator|)
name|args
index|[
literal|0
index|]
expr_stmt|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* SZP2[]:       Set Zone Pointer 2                                      */
end_comment
begin_comment
comment|/* Opcode range: 0x15                                                    */
end_comment
begin_comment
comment|/* Stack:        uint32 -->                                              */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_SZP2
name|Ins_SZP2
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
switch|switch
condition|(
operator|(
name|FT_Int
operator|)
name|args
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|0
case|:
name|CUR
operator|.
name|zp2
operator|=
name|CUR
operator|.
name|twilight
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|CUR
operator|.
name|zp2
operator|=
name|CUR
operator|.
name|pts
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|CUR
operator|.
name|pedantic_hinting
condition|)
name|CUR
operator|.
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Reference
argument_list|)
expr_stmt|;
return|return;
block|}
name|CUR
operator|.
name|GS
operator|.
name|gep2
operator|=
operator|(
name|FT_UShort
operator|)
name|args
index|[
literal|0
index|]
expr_stmt|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* SZPS[]:       Set Zone PointerS                                       */
end_comment
begin_comment
comment|/* Opcode range: 0x16                                                    */
end_comment
begin_comment
comment|/* Stack:        uint32 -->                                              */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_SZPS
name|Ins_SZPS
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
switch|switch
condition|(
operator|(
name|FT_Int
operator|)
name|args
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|0
case|:
name|CUR
operator|.
name|zp0
operator|=
name|CUR
operator|.
name|twilight
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|CUR
operator|.
name|zp0
operator|=
name|CUR
operator|.
name|pts
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|CUR
operator|.
name|pedantic_hinting
condition|)
name|CUR
operator|.
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Reference
argument_list|)
expr_stmt|;
return|return;
block|}
name|CUR
operator|.
name|zp1
operator|=
name|CUR
operator|.
name|zp0
expr_stmt|;
name|CUR
operator|.
name|zp2
operator|=
name|CUR
operator|.
name|zp0
expr_stmt|;
name|CUR
operator|.
name|GS
operator|.
name|gep0
operator|=
operator|(
name|FT_UShort
operator|)
name|args
index|[
literal|0
index|]
expr_stmt|;
name|CUR
operator|.
name|GS
operator|.
name|gep1
operator|=
operator|(
name|FT_UShort
operator|)
name|args
index|[
literal|0
index|]
expr_stmt|;
name|CUR
operator|.
name|GS
operator|.
name|gep2
operator|=
operator|(
name|FT_UShort
operator|)
name|args
index|[
literal|0
index|]
expr_stmt|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* INSTCTRL[]:   INSTruction ConTRoL                                     */
end_comment
begin_comment
comment|/* Opcode range: 0x8E                                                    */
end_comment
begin_comment
comment|/* Stack:        int32 int32 -->                                         */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_INSTCTRL
name|Ins_INSTCTRL
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|FT_Long
name|K
decl_stmt|,
name|L
decl_stmt|;
name|K
operator|=
name|args
index|[
literal|1
index|]
expr_stmt|;
name|L
operator|=
name|args
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|K
operator|<
literal|1
operator|||
name|K
operator|>
literal|2
condition|)
block|{
if|if
condition|(
name|CUR
operator|.
name|pedantic_hinting
condition|)
name|CUR
operator|.
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Reference
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|L
operator|!=
literal|0
condition|)
name|L
operator|=
name|K
expr_stmt|;
name|CUR
operator|.
name|GS
operator|.
name|instruct_control
operator|=
name|FT_BOOL
argument_list|(
operator|(
operator|(
name|FT_Byte
operator|)
name|CUR
operator|.
name|GS
operator|.
name|instruct_control
operator|&
operator|~
operator|(
name|FT_Byte
operator|)
name|K
operator|)
operator||
operator|(
name|FT_Byte
operator|)
name|L
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* SCANCTRL[]:   SCAN ConTRoL                                            */
end_comment
begin_comment
comment|/* Opcode range: 0x85                                                    */
end_comment
begin_comment
comment|/* Stack:        uint32? -->                                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_SCANCTRL
name|Ins_SCANCTRL
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|FT_Int
name|A
decl_stmt|;
comment|/* Get Threshold */
name|A
operator|=
call|(
name|FT_Int
call|)
argument_list|(
name|args
index|[
literal|0
index|]
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
if|if
condition|(
name|A
operator|==
literal|0xFF
condition|)
block|{
name|CUR
operator|.
name|GS
operator|.
name|scan_control
operator|=
name|TRUE
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|A
operator|==
literal|0
condition|)
block|{
name|CUR
operator|.
name|GS
operator|.
name|scan_control
operator|=
name|FALSE
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|args
index|[
literal|0
index|]
operator|&
literal|0x100
operator|)
operator|!=
literal|0
operator|&&
name|CUR
operator|.
name|tt_metrics
operator|.
name|ppem
operator|<=
name|A
condition|)
name|CUR
operator|.
name|GS
operator|.
name|scan_control
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|(
name|args
index|[
literal|0
index|]
operator|&
literal|0x200
operator|)
operator|!=
literal|0
operator|&&
name|CUR
operator|.
name|tt_metrics
operator|.
name|rotated
condition|)
name|CUR
operator|.
name|GS
operator|.
name|scan_control
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|(
name|args
index|[
literal|0
index|]
operator|&
literal|0x400
operator|)
operator|!=
literal|0
operator|&&
name|CUR
operator|.
name|tt_metrics
operator|.
name|stretched
condition|)
name|CUR
operator|.
name|GS
operator|.
name|scan_control
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|(
name|args
index|[
literal|0
index|]
operator|&
literal|0x800
operator|)
operator|!=
literal|0
operator|&&
name|CUR
operator|.
name|tt_metrics
operator|.
name|ppem
operator|>
name|A
condition|)
name|CUR
operator|.
name|GS
operator|.
name|scan_control
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|(
name|args
index|[
literal|0
index|]
operator|&
literal|0x1000
operator|)
operator|!=
literal|0
operator|&&
name|CUR
operator|.
name|tt_metrics
operator|.
name|rotated
condition|)
name|CUR
operator|.
name|GS
operator|.
name|scan_control
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|(
name|args
index|[
literal|0
index|]
operator|&
literal|0x2000
operator|)
operator|!=
literal|0
operator|&&
name|CUR
operator|.
name|tt_metrics
operator|.
name|stretched
condition|)
name|CUR
operator|.
name|GS
operator|.
name|scan_control
operator|=
name|FALSE
expr_stmt|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* SCANTYPE[]:   SCAN TYPE                                               */
end_comment
begin_comment
comment|/* Opcode range: 0x8D                                                    */
end_comment
begin_comment
comment|/* Stack:        uint32? -->                                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_SCANTYPE
name|Ins_SCANTYPE
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
if|if
condition|(
name|args
index|[
literal|0
index|]
operator|>=
literal|0
condition|)
name|CUR
operator|.
name|GS
operator|.
name|scan_type
operator|=
operator|(
name|FT_Int
operator|)
name|args
index|[
literal|0
index|]
expr_stmt|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* MANAGING OUTLINES                                                     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*   Instructions appear in the specification's order.                   */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* FLIPPT[]:     FLIP PoinT                                              */
end_comment
begin_comment
comment|/* Opcode range: 0x80                                                    */
end_comment
begin_comment
comment|/* Stack:        uint32... -->                                           */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_FLIPPT
name|Ins_FLIPPT
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|FT_UShort
name|point
decl_stmt|;
name|FT_UNUSED_ARG
expr_stmt|;
if|if
condition|(
name|CUR
operator|.
name|top
operator|<
name|CUR
operator|.
name|GS
operator|.
name|loop
condition|)
block|{
if|if
condition|(
name|CUR
operator|.
name|pedantic_hinting
condition|)
name|CUR
operator|.
name|error
operator|=
name|FT_THROW
argument_list|(
name|Too_Few_Arguments
argument_list|)
expr_stmt|;
goto|goto
name|Fail
goto|;
block|}
while|while
condition|(
name|CUR
operator|.
name|GS
operator|.
name|loop
operator|>
literal|0
condition|)
block|{
name|CUR
operator|.
name|args
operator|--
expr_stmt|;
name|point
operator|=
operator|(
name|FT_UShort
operator|)
name|CUR
operator|.
name|stack
index|[
name|CUR
operator|.
name|args
index|]
expr_stmt|;
if|if
condition|(
name|BOUNDS
argument_list|(
name|point
argument_list|,
name|CUR
operator|.
name|pts
operator|.
name|n_points
argument_list|)
condition|)
block|{
if|if
condition|(
name|CUR
operator|.
name|pedantic_hinting
condition|)
block|{
name|CUR
operator|.
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Reference
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
name|CUR
operator|.
name|pts
operator|.
name|tags
index|[
name|point
index|]
operator|^=
name|FT_CURVE_TAG_ON
expr_stmt|;
name|CUR
operator|.
name|GS
operator|.
name|loop
operator|--
expr_stmt|;
block|}
name|Fail
label|:
name|CUR
operator|.
name|GS
operator|.
name|loop
operator|=
literal|1
expr_stmt|;
name|CUR
operator|.
name|new_top
operator|=
name|CUR
operator|.
name|args
expr_stmt|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* FLIPRGON[]:   FLIP RanGe ON                                           */
end_comment
begin_comment
comment|/* Opcode range: 0x81                                                    */
end_comment
begin_comment
comment|/* Stack:        uint32 uint32 -->                                       */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_FLIPRGON
name|Ins_FLIPRGON
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|FT_UShort
name|I
decl_stmt|,
name|K
decl_stmt|,
name|L
decl_stmt|;
name|K
operator|=
operator|(
name|FT_UShort
operator|)
name|args
index|[
literal|1
index|]
expr_stmt|;
name|L
operator|=
operator|(
name|FT_UShort
operator|)
name|args
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|BOUNDS
argument_list|(
name|K
argument_list|,
name|CUR
operator|.
name|pts
operator|.
name|n_points
argument_list|)
operator|||
name|BOUNDS
argument_list|(
name|L
argument_list|,
name|CUR
operator|.
name|pts
operator|.
name|n_points
argument_list|)
condition|)
block|{
if|if
condition|(
name|CUR
operator|.
name|pedantic_hinting
condition|)
name|CUR
operator|.
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Reference
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|I
operator|=
name|L
init|;
name|I
operator|<=
name|K
condition|;
name|I
operator|++
control|)
name|CUR
operator|.
name|pts
operator|.
name|tags
index|[
name|I
index|]
operator||=
name|FT_CURVE_TAG_ON
expr_stmt|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* FLIPRGOFF:    FLIP RanGe OFF                                          */
end_comment
begin_comment
comment|/* Opcode range: 0x82                                                    */
end_comment
begin_comment
comment|/* Stack:        uint32 uint32 -->                                       */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_FLIPRGOFF
name|Ins_FLIPRGOFF
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|FT_UShort
name|I
decl_stmt|,
name|K
decl_stmt|,
name|L
decl_stmt|;
name|K
operator|=
operator|(
name|FT_UShort
operator|)
name|args
index|[
literal|1
index|]
expr_stmt|;
name|L
operator|=
operator|(
name|FT_UShort
operator|)
name|args
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|BOUNDS
argument_list|(
name|K
argument_list|,
name|CUR
operator|.
name|pts
operator|.
name|n_points
argument_list|)
operator|||
name|BOUNDS
argument_list|(
name|L
argument_list|,
name|CUR
operator|.
name|pts
operator|.
name|n_points
argument_list|)
condition|)
block|{
if|if
condition|(
name|CUR
operator|.
name|pedantic_hinting
condition|)
name|CUR
operator|.
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Reference
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|I
operator|=
name|L
init|;
name|I
operator|<=
name|K
condition|;
name|I
operator|++
control|)
name|CUR
operator|.
name|pts
operator|.
name|tags
index|[
name|I
index|]
operator|&=
operator|~
name|FT_CURVE_TAG_ON
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|FT_Bool
DECL|function|Compute_Point_Displacement
name|Compute_Point_Displacement
parameter_list|(
name|EXEC_OP_
name|FT_F26Dot6
modifier|*
name|x
parameter_list|,
name|FT_F26Dot6
modifier|*
name|y
parameter_list|,
name|TT_GlyphZone
name|zone
parameter_list|,
name|FT_UShort
modifier|*
name|refp
parameter_list|)
block|{
name|TT_GlyphZoneRec
name|zp
decl_stmt|;
name|FT_UShort
name|p
decl_stmt|;
name|FT_F26Dot6
name|d
decl_stmt|;
if|if
condition|(
name|CUR
operator|.
name|opcode
operator|&
literal|1
condition|)
block|{
name|zp
operator|=
name|CUR
operator|.
name|zp0
expr_stmt|;
name|p
operator|=
name|CUR
operator|.
name|GS
operator|.
name|rp1
expr_stmt|;
block|}
else|else
block|{
name|zp
operator|=
name|CUR
operator|.
name|zp1
expr_stmt|;
name|p
operator|=
name|CUR
operator|.
name|GS
operator|.
name|rp2
expr_stmt|;
block|}
if|if
condition|(
name|BOUNDS
argument_list|(
name|p
argument_list|,
name|zp
operator|.
name|n_points
argument_list|)
condition|)
block|{
if|if
condition|(
name|CUR
operator|.
name|pedantic_hinting
condition|)
name|CUR
operator|.
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Reference
argument_list|)
expr_stmt|;
operator|*
name|refp
operator|=
literal|0
expr_stmt|;
return|return
name|FAILURE
return|;
block|}
operator|*
name|zone
operator|=
name|zp
expr_stmt|;
operator|*
name|refp
operator|=
name|p
expr_stmt|;
name|d
operator|=
name|CUR_Func_project
argument_list|(
name|zp
operator|.
name|cur
operator|+
name|p
argument_list|,
name|zp
operator|.
name|org
operator|+
name|p
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_UNPATENTED_HINTING
if|if
condition|(
name|CUR
operator|.
name|face
operator|->
name|unpatented_hinting
condition|)
block|{
if|if
condition|(
name|CUR
operator|.
name|GS
operator|.
name|both_x_axis
condition|)
block|{
operator|*
name|x
operator|=
name|d
expr_stmt|;
operator|*
name|y
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
operator|*
name|x
operator|=
literal|0
expr_stmt|;
operator|*
name|y
operator|=
name|d
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
block|{
operator|*
name|x
operator|=
name|FT_MulDiv
argument_list|(
name|d
argument_list|,
operator|(
name|FT_Long
operator|)
name|CUR
operator|.
name|GS
operator|.
name|freeVector
operator|.
name|x
argument_list|,
name|CUR
operator|.
name|F_dot_P
argument_list|)
expr_stmt|;
operator|*
name|y
operator|=
name|FT_MulDiv
argument_list|(
name|d
argument_list|,
operator|(
name|FT_Long
operator|)
name|CUR
operator|.
name|GS
operator|.
name|freeVector
operator|.
name|y
argument_list|,
name|CUR
operator|.
name|F_dot_P
argument_list|)
expr_stmt|;
block|}
return|return
name|SUCCESS
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|Move_Zp2_Point
name|Move_Zp2_Point
parameter_list|(
name|EXEC_OP_
name|FT_UShort
name|point
parameter_list|,
name|FT_F26Dot6
name|dx
parameter_list|,
name|FT_F26Dot6
name|dy
parameter_list|,
name|FT_Bool
name|touch
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_UNPATENTED_HINTING
if|if
condition|(
name|CUR
operator|.
name|face
operator|->
name|unpatented_hinting
condition|)
block|{
if|if
condition|(
name|CUR
operator|.
name|GS
operator|.
name|both_x_axis
condition|)
block|{
name|CUR
operator|.
name|zp2
operator|.
name|cur
index|[
name|point
index|]
operator|.
name|x
operator|+=
name|dx
expr_stmt|;
if|if
condition|(
name|touch
condition|)
name|CUR
operator|.
name|zp2
operator|.
name|tags
index|[
name|point
index|]
operator||=
name|FT_CURVE_TAG_TOUCH_X
expr_stmt|;
block|}
else|else
block|{
name|CUR
operator|.
name|zp2
operator|.
name|cur
index|[
name|point
index|]
operator|.
name|y
operator|+=
name|dy
expr_stmt|;
if|if
condition|(
name|touch
condition|)
name|CUR
operator|.
name|zp2
operator|.
name|tags
index|[
name|point
index|]
operator||=
name|FT_CURVE_TAG_TOUCH_Y
expr_stmt|;
block|}
return|return;
block|}
endif|#
directive|endif
if|if
condition|(
name|CUR
operator|.
name|GS
operator|.
name|freeVector
operator|.
name|x
operator|!=
literal|0
condition|)
block|{
name|CUR
operator|.
name|zp2
operator|.
name|cur
index|[
name|point
index|]
operator|.
name|x
operator|+=
name|dx
expr_stmt|;
if|if
condition|(
name|touch
condition|)
name|CUR
operator|.
name|zp2
operator|.
name|tags
index|[
name|point
index|]
operator||=
name|FT_CURVE_TAG_TOUCH_X
expr_stmt|;
block|}
if|if
condition|(
name|CUR
operator|.
name|GS
operator|.
name|freeVector
operator|.
name|y
operator|!=
literal|0
condition|)
block|{
name|CUR
operator|.
name|zp2
operator|.
name|cur
index|[
name|point
index|]
operator|.
name|y
operator|+=
name|dy
expr_stmt|;
if|if
condition|(
name|touch
condition|)
name|CUR
operator|.
name|zp2
operator|.
name|tags
index|[
name|point
index|]
operator||=
name|FT_CURVE_TAG_TOUCH_Y
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* SHP[a]:       SHift Point by the last point                           */
end_comment
begin_comment
comment|/* Opcode range: 0x32-0x33                                               */
end_comment
begin_comment
comment|/* Stack:        uint32... -->                                           */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_SHP
name|Ins_SHP
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|TT_GlyphZoneRec
name|zp
decl_stmt|;
name|FT_UShort
name|refp
decl_stmt|;
name|FT_F26Dot6
name|dx
decl_stmt|,
name|dy
decl_stmt|;
name|FT_UShort
name|point
decl_stmt|;
name|FT_UNUSED_ARG
expr_stmt|;
if|if
condition|(
name|CUR
operator|.
name|top
operator|<
name|CUR
operator|.
name|GS
operator|.
name|loop
condition|)
block|{
if|if
condition|(
name|CUR
operator|.
name|pedantic_hinting
condition|)
name|CUR
operator|.
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Reference
argument_list|)
expr_stmt|;
goto|goto
name|Fail
goto|;
block|}
if|if
condition|(
name|COMPUTE_Point_Displacement
argument_list|(
operator|&
name|dx
argument_list|,
operator|&
name|dy
argument_list|,
operator|&
name|zp
argument_list|,
operator|&
name|refp
argument_list|)
condition|)
return|return;
while|while
condition|(
name|CUR
operator|.
name|GS
operator|.
name|loop
operator|>
literal|0
condition|)
block|{
name|CUR
operator|.
name|args
operator|--
expr_stmt|;
name|point
operator|=
operator|(
name|FT_UShort
operator|)
name|CUR
operator|.
name|stack
index|[
name|CUR
operator|.
name|args
index|]
expr_stmt|;
if|if
condition|(
name|BOUNDS
argument_list|(
name|point
argument_list|,
name|CUR
operator|.
name|zp2
operator|.
name|n_points
argument_list|)
condition|)
block|{
if|if
condition|(
name|CUR
operator|.
name|pedantic_hinting
condition|)
block|{
name|CUR
operator|.
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Reference
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
elseif|else
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_SUBPIXEL_HINTING
comment|/* doesn't follow Cleartype spec but produces better result */
if|if
condition|(
name|SUBPIXEL_HINTING
operator|&&
name|CUR
operator|.
name|ignore_x_mode
condition|)
name|MOVE_Zp2_Point
argument_list|(
name|point
argument_list|,
literal|0
argument_list|,
name|dy
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
name|MOVE_Zp2_Point
argument_list|(
name|point
argument_list|,
name|dx
argument_list|,
name|dy
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|CUR
operator|.
name|GS
operator|.
name|loop
operator|--
expr_stmt|;
block|}
name|Fail
label|:
name|CUR
operator|.
name|GS
operator|.
name|loop
operator|=
literal|1
expr_stmt|;
name|CUR
operator|.
name|new_top
operator|=
name|CUR
operator|.
name|args
expr_stmt|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* SHC[a]:       SHift Contour                                           */
end_comment
begin_comment
comment|/* Opcode range: 0x34-35                                                 */
end_comment
begin_comment
comment|/* Stack:        uint32 -->                                              */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* UNDOCUMENTED: According to Greg Hitchcock, there is one (virtual)     */
end_comment
begin_comment
comment|/*               contour in the twilight zone, namely contour number     */
end_comment
begin_comment
comment|/*               zero which includes all points of it.                   */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_SHC
name|Ins_SHC
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|TT_GlyphZoneRec
name|zp
decl_stmt|;
name|FT_UShort
name|refp
decl_stmt|;
name|FT_F26Dot6
name|dx
decl_stmt|,
name|dy
decl_stmt|;
name|FT_Short
name|contour
decl_stmt|,
name|bounds
decl_stmt|;
name|FT_UShort
name|start
decl_stmt|,
name|limit
decl_stmt|,
name|i
decl_stmt|;
name|contour
operator|=
operator|(
name|FT_UShort
operator|)
name|args
index|[
literal|0
index|]
expr_stmt|;
name|bounds
operator|=
operator|(
name|CUR
operator|.
name|GS
operator|.
name|gep2
operator|==
literal|0
operator|)
condition|?
literal|1
else|:
name|CUR
operator|.
name|zp2
operator|.
name|n_contours
expr_stmt|;
if|if
condition|(
name|BOUNDS
argument_list|(
name|contour
argument_list|,
name|bounds
argument_list|)
condition|)
block|{
if|if
condition|(
name|CUR
operator|.
name|pedantic_hinting
condition|)
name|CUR
operator|.
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Reference
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|COMPUTE_Point_Displacement
argument_list|(
operator|&
name|dx
argument_list|,
operator|&
name|dy
argument_list|,
operator|&
name|zp
argument_list|,
operator|&
name|refp
argument_list|)
condition|)
return|return;
if|if
condition|(
name|contour
operator|==
literal|0
condition|)
name|start
operator|=
literal|0
expr_stmt|;
else|else
name|start
operator|=
call|(
name|FT_UShort
call|)
argument_list|(
name|CUR
operator|.
name|zp2
operator|.
name|contours
index|[
name|contour
operator|-
literal|1
index|]
operator|+
literal|1
operator|-
name|CUR
operator|.
name|zp2
operator|.
name|first_point
argument_list|)
expr_stmt|;
comment|/* we use the number of points if in the twilight zone */
if|if
condition|(
name|CUR
operator|.
name|GS
operator|.
name|gep2
operator|==
literal|0
condition|)
name|limit
operator|=
name|CUR
operator|.
name|zp2
operator|.
name|n_points
expr_stmt|;
else|else
name|limit
operator|=
call|(
name|FT_UShort
call|)
argument_list|(
name|CUR
operator|.
name|zp2
operator|.
name|contours
index|[
name|contour
index|]
operator|-
name|CUR
operator|.
name|zp2
operator|.
name|first_point
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<
name|limit
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|zp
operator|.
name|cur
operator|!=
name|CUR
operator|.
name|zp2
operator|.
name|cur
operator|||
name|refp
operator|!=
name|i
condition|)
name|MOVE_Zp2_Point
argument_list|(
name|i
argument_list|,
name|dx
argument_list|,
name|dy
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* SHZ[a]:       SHift Zone                                              */
end_comment
begin_comment
comment|/* Opcode range: 0x36-37                                                 */
end_comment
begin_comment
comment|/* Stack:        uint32 -->                                              */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_SHZ
name|Ins_SHZ
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|TT_GlyphZoneRec
name|zp
decl_stmt|;
name|FT_UShort
name|refp
decl_stmt|;
name|FT_F26Dot6
name|dx
decl_stmt|,
name|dy
decl_stmt|;
name|FT_UShort
name|limit
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|BOUNDS
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
literal|2
argument_list|)
condition|)
block|{
if|if
condition|(
name|CUR
operator|.
name|pedantic_hinting
condition|)
name|CUR
operator|.
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Reference
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|COMPUTE_Point_Displacement
argument_list|(
operator|&
name|dx
argument_list|,
operator|&
name|dy
argument_list|,
operator|&
name|zp
argument_list|,
operator|&
name|refp
argument_list|)
condition|)
return|return;
comment|/* XXX: UNDOCUMENTED! SHZ doesn't move the phantom points.     */
comment|/*      Twilight zone has no real contours, so use `n_points'. */
comment|/*      Normal zone's `n_points' includes phantoms, so must    */
comment|/*      use end of last contour.                               */
if|if
condition|(
name|CUR
operator|.
name|GS
operator|.
name|gep2
operator|==
literal|0
condition|)
name|limit
operator|=
operator|(
name|FT_UShort
operator|)
name|CUR
operator|.
name|zp2
operator|.
name|n_points
expr_stmt|;
elseif|else
if|if
condition|(
name|CUR
operator|.
name|GS
operator|.
name|gep2
operator|==
literal|1
operator|&&
name|CUR
operator|.
name|zp2
operator|.
name|n_contours
operator|>
literal|0
condition|)
name|limit
operator|=
call|(
name|FT_UShort
call|)
argument_list|(
name|CUR
operator|.
name|zp2
operator|.
name|contours
index|[
name|CUR
operator|.
name|zp2
operator|.
name|n_contours
operator|-
literal|1
index|]
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|limit
operator|=
literal|0
expr_stmt|;
comment|/* XXX: UNDOCUMENTED! SHZ doesn't touch the points */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|limit
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|zp
operator|.
name|cur
operator|!=
name|CUR
operator|.
name|zp2
operator|.
name|cur
operator|||
name|refp
operator|!=
name|i
condition|)
name|MOVE_Zp2_Point
argument_list|(
name|i
argument_list|,
name|dx
argument_list|,
name|dy
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* SHPIX[]:      SHift points by a PIXel amount                          */
end_comment
begin_comment
comment|/* Opcode range: 0x38                                                    */
end_comment
begin_comment
comment|/* Stack:        f26.6 uint32... -->                                     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_SHPIX
name|Ins_SHPIX
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|FT_F26Dot6
name|dx
decl_stmt|,
name|dy
decl_stmt|;
name|FT_UShort
name|point
decl_stmt|;
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_SUBPIXEL_HINTING
name|FT_Int
name|B1
decl_stmt|,
name|B2
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|CUR
operator|.
name|top
operator|<
name|CUR
operator|.
name|GS
operator|.
name|loop
operator|+
literal|1
condition|)
block|{
if|if
condition|(
name|CUR
operator|.
name|pedantic_hinting
condition|)
name|CUR
operator|.
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Reference
argument_list|)
expr_stmt|;
goto|goto
name|Fail
goto|;
block|}
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_UNPATENTED_HINTING
if|if
condition|(
name|CUR
operator|.
name|face
operator|->
name|unpatented_hinting
condition|)
block|{
if|if
condition|(
name|CUR
operator|.
name|GS
operator|.
name|both_x_axis
condition|)
block|{
name|dx
operator|=
operator|(
name|FT_UInt32
operator|)
name|args
index|[
literal|0
index|]
expr_stmt|;
name|dy
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|dx
operator|=
literal|0
expr_stmt|;
name|dy
operator|=
operator|(
name|FT_UInt32
operator|)
name|args
index|[
literal|0
index|]
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
block|{
name|dx
operator|=
name|TT_MulFix14
argument_list|(
operator|(
name|FT_UInt32
operator|)
name|args
index|[
literal|0
index|]
argument_list|,
name|CUR
operator|.
name|GS
operator|.
name|freeVector
operator|.
name|x
argument_list|)
expr_stmt|;
name|dy
operator|=
name|TT_MulFix14
argument_list|(
operator|(
name|FT_UInt32
operator|)
name|args
index|[
literal|0
index|]
argument_list|,
name|CUR
operator|.
name|GS
operator|.
name|freeVector
operator|.
name|y
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|CUR
operator|.
name|GS
operator|.
name|loop
operator|>
literal|0
condition|)
block|{
name|CUR
operator|.
name|args
operator|--
expr_stmt|;
name|point
operator|=
operator|(
name|FT_UShort
operator|)
name|CUR
operator|.
name|stack
index|[
name|CUR
operator|.
name|args
index|]
expr_stmt|;
if|if
condition|(
name|BOUNDS
argument_list|(
name|point
argument_list|,
name|CUR
operator|.
name|zp2
operator|.
name|n_points
argument_list|)
condition|)
block|{
if|if
condition|(
name|CUR
operator|.
name|pedantic_hinting
condition|)
block|{
name|CUR
operator|.
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Reference
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_SUBPIXEL_HINTING
block|{
comment|/*  If not using ignore_x_mode rendering, allow ZP2 move.          */
comment|/*  If inline deltas aren't allowed, skip ZP2 move.                */
comment|/*  If using ignore_x_mode rendering, allow ZP2 point move if:     */
comment|/*   - freedom vector is y and sph_compatibility_mode is off       */
comment|/*   - the glyph is composite and the move is in the Y direction   */
comment|/*   - the glyph is specifically set to allow SHPIX moves          */
comment|/*   - the move is on a previously Y-touched point                 */
if|if
condition|(
name|SUBPIXEL_HINTING
operator|&&
name|CUR
operator|.
name|ignore_x_mode
condition|)
block|{
comment|/* save point for later comparison */
if|if
condition|(
name|CUR
operator|.
name|GS
operator|.
name|freeVector
operator|.
name|y
operator|!=
literal|0
condition|)
name|B1
operator|=
name|CUR
operator|.
name|zp2
operator|.
name|cur
index|[
name|point
index|]
operator|.
name|y
expr_stmt|;
else|else
name|B1
operator|=
name|CUR
operator|.
name|zp2
operator|.
name|cur
index|[
name|point
index|]
operator|.
name|x
expr_stmt|;
if|if
condition|(
operator|!
name|CUR
operator|.
name|face
operator|->
name|sph_compatibility_mode
operator|&&
name|CUR
operator|.
name|GS
operator|.
name|freeVector
operator|.
name|y
operator|!=
literal|0
condition|)
block|{
name|MOVE_Zp2_Point
argument_list|(
name|point
argument_list|,
name|dx
argument_list|,
name|dy
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* save new point */
if|if
condition|(
name|CUR
operator|.
name|GS
operator|.
name|freeVector
operator|.
name|y
operator|!=
literal|0
condition|)
block|{
name|B2
operator|=
name|CUR
operator|.
name|zp2
operator|.
name|cur
index|[
name|point
index|]
operator|.
name|y
expr_stmt|;
comment|/* reverse any disallowed moves */
if|if
condition|(
operator|(
name|CUR
operator|.
name|sph_tweak_flags
operator|&
name|SPH_TWEAK_SKIP_NONPIXEL_Y_MOVES
operator|)
operator|&&
operator|(
name|B1
operator|&
literal|63
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|B2
operator|&
literal|63
operator|)
operator|!=
literal|0
operator|&&
name|B1
operator|!=
name|B2
condition|)
name|MOVE_Zp2_Point
argument_list|(
name|point
argument_list|,
operator|-
name|dx
argument_list|,
operator|-
name|dy
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|CUR
operator|.
name|face
operator|->
name|sph_compatibility_mode
condition|)
block|{
if|if
condition|(
name|CUR
operator|.
name|sph_tweak_flags
operator|&
name|SPH_TWEAK_ROUND_NONPIXEL_Y_MOVES
condition|)
block|{
name|dx
operator|=
name|FT_PIX_ROUND
argument_list|(
name|B1
operator|+
name|dx
argument_list|)
operator|-
name|B1
expr_stmt|;
name|dy
operator|=
name|FT_PIX_ROUND
argument_list|(
name|B1
operator|+
name|dy
argument_list|)
operator|-
name|B1
expr_stmt|;
block|}
comment|/* skip post-iup deltas */
if|if
condition|(
name|CUR
operator|.
name|iup_called
operator|&&
operator|(
operator|(
name|CUR
operator|.
name|sph_in_func_flags
operator|&
name|SPH_FDEF_INLINE_DELTA_1
operator|)
operator|||
operator|(
name|CUR
operator|.
name|sph_in_func_flags
operator|&
name|SPH_FDEF_INLINE_DELTA_2
operator|)
operator|)
condition|)
goto|goto
name|Skip
goto|;
if|if
condition|(
operator|!
operator|(
name|CUR
operator|.
name|sph_tweak_flags
operator|&
name|SPH_TWEAK_ALWAYS_SKIP_DELTAP
operator|)
operator|&&
operator|(
operator|(
name|CUR
operator|.
name|is_composite
operator|&&
name|CUR
operator|.
name|GS
operator|.
name|freeVector
operator|.
name|y
operator|!=
literal|0
operator|)
operator|||
operator|(
name|CUR
operator|.
name|zp2
operator|.
name|tags
index|[
name|point
index|]
operator|&
name|FT_CURVE_TAG_TOUCH_Y
operator|)
operator|||
operator|(
name|CUR
operator|.
name|sph_tweak_flags
operator|&
name|SPH_TWEAK_DO_SHPIX
operator|)
operator|)
condition|)
name|MOVE_Zp2_Point
argument_list|(
name|point
argument_list|,
literal|0
argument_list|,
name|dy
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* save new point */
if|if
condition|(
name|CUR
operator|.
name|GS
operator|.
name|freeVector
operator|.
name|y
operator|!=
literal|0
condition|)
block|{
name|B2
operator|=
name|CUR
operator|.
name|zp2
operator|.
name|cur
index|[
name|point
index|]
operator|.
name|y
expr_stmt|;
comment|/* reverse any disallowed moves */
if|if
condition|(
operator|(
name|B1
operator|&
literal|63
operator|)
operator|==
literal|0
operator|&&
operator|(
name|B2
operator|&
literal|63
operator|)
operator|!=
literal|0
operator|&&
name|B1
operator|!=
name|B2
condition|)
name|MOVE_Zp2_Point
argument_list|(
name|point
argument_list|,
literal|0
argument_list|,
operator|-
name|dy
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|CUR
operator|.
name|sph_in_func_flags
operator|&
name|SPH_FDEF_TYPEMAN_DIAGENDCTRL
condition|)
name|MOVE_Zp2_Point
argument_list|(
name|point
argument_list|,
name|dx
argument_list|,
name|dy
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
else|else
name|MOVE_Zp2_Point
argument_list|(
name|point
argument_list|,
name|dx
argument_list|,
name|dy
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
name|Skip
label|:
else|#
directive|else
comment|/* !TT_CONFIG_OPTION_SUBPIXEL_HINTING */
name|MOVE_Zp2_Point
argument_list|(
name|point
argument_list|,
name|dx
argument_list|,
name|dy
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !TT_CONFIG_OPTION_SUBPIXEL_HINTING */
name|CUR
operator|.
name|GS
operator|.
name|loop
operator|--
expr_stmt|;
block|}
name|Fail
label|:
name|CUR
operator|.
name|GS
operator|.
name|loop
operator|=
literal|1
expr_stmt|;
name|CUR
operator|.
name|new_top
operator|=
name|CUR
operator|.
name|args
expr_stmt|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* MSIRP[a]:     Move Stack Indirect Relative Position                   */
end_comment
begin_comment
comment|/* Opcode range: 0x3A-0x3B                                               */
end_comment
begin_comment
comment|/* Stack:        f26.6 uint32 -->                                        */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_MSIRP
name|Ins_MSIRP
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|FT_UShort
name|point
decl_stmt|;
name|FT_F26Dot6
name|distance
decl_stmt|;
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_SUBPIXEL_HINTING
name|FT_F26Dot6
name|control_value_cutin
init|=
literal|0
decl_stmt|;
comment|/* pacify compiler */
if|if
condition|(
name|SUBPIXEL_HINTING
condition|)
block|{
name|control_value_cutin
operator|=
name|CUR
operator|.
name|GS
operator|.
name|control_value_cutin
expr_stmt|;
if|if
condition|(
name|CUR
operator|.
name|ignore_x_mode
operator|&&
name|CUR
operator|.
name|GS
operator|.
name|freeVector
operator|.
name|x
operator|!=
literal|0
operator|&&
operator|!
operator|(
name|CUR
operator|.
name|sph_tweak_flags
operator|&
name|SPH_TWEAK_NORMAL_ROUND
operator|)
condition|)
name|control_value_cutin
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
name|point
operator|=
operator|(
name|FT_UShort
operator|)
name|args
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|BOUNDS
argument_list|(
name|point
argument_list|,
name|CUR
operator|.
name|zp1
operator|.
name|n_points
argument_list|)
operator|||
name|BOUNDS
argument_list|(
name|CUR
operator|.
name|GS
operator|.
name|rp0
argument_list|,
name|CUR
operator|.
name|zp0
operator|.
name|n_points
argument_list|)
condition|)
block|{
if|if
condition|(
name|CUR
operator|.
name|pedantic_hinting
condition|)
name|CUR
operator|.
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Reference
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* UNDOCUMENTED!  The MS rasterizer does that with */
comment|/* twilight points (confirmed by Greg Hitchcock)   */
if|if
condition|(
name|CUR
operator|.
name|GS
operator|.
name|gep1
operator|==
literal|0
condition|)
block|{
name|CUR
operator|.
name|zp1
operator|.
name|org
index|[
name|point
index|]
operator|=
name|CUR
operator|.
name|zp0
operator|.
name|org
index|[
name|CUR
operator|.
name|GS
operator|.
name|rp0
index|]
expr_stmt|;
name|CUR_Func_move_orig
argument_list|(
operator|&
name|CUR
operator|.
name|zp1
argument_list|,
name|point
argument_list|,
name|args
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|CUR
operator|.
name|zp1
operator|.
name|cur
index|[
name|point
index|]
operator|=
name|CUR
operator|.
name|zp1
operator|.
name|org
index|[
name|point
index|]
expr_stmt|;
block|}
name|distance
operator|=
name|CUR_Func_project
argument_list|(
name|CUR
operator|.
name|zp1
operator|.
name|cur
operator|+
name|point
argument_list|,
name|CUR
operator|.
name|zp0
operator|.
name|cur
operator|+
name|CUR
operator|.
name|GS
operator|.
name|rp0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_SUBPIXEL_HINTING
comment|/* subpixel hinting - make MSIRP respect CVT cut-in; */
if|if
condition|(
name|SUBPIXEL_HINTING
operator|&&
name|CUR
operator|.
name|ignore_x_mode
operator|&&
name|CUR
operator|.
name|GS
operator|.
name|freeVector
operator|.
name|x
operator|!=
literal|0
operator|&&
name|FT_ABS
argument_list|(
name|distance
operator|-
name|args
index|[
literal|1
index|]
argument_list|)
operator|>=
name|control_value_cutin
condition|)
name|distance
operator|=
name|args
index|[
literal|1
index|]
expr_stmt|;
endif|#
directive|endif
comment|/* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
name|CUR_Func_move
argument_list|(
operator|&
name|CUR
operator|.
name|zp1
argument_list|,
name|point
argument_list|,
name|args
index|[
literal|1
index|]
operator|-
name|distance
argument_list|)
expr_stmt|;
name|CUR
operator|.
name|GS
operator|.
name|rp1
operator|=
name|CUR
operator|.
name|GS
operator|.
name|rp0
expr_stmt|;
name|CUR
operator|.
name|GS
operator|.
name|rp2
operator|=
name|point
expr_stmt|;
if|if
condition|(
operator|(
name|CUR
operator|.
name|opcode
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|CUR
operator|.
name|GS
operator|.
name|rp0
operator|=
name|point
expr_stmt|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* MDAP[a]:      Move Direct Absolute Point                              */
end_comment
begin_comment
comment|/* Opcode range: 0x2E-0x2F                                               */
end_comment
begin_comment
comment|/* Stack:        uint32 -->                                              */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_MDAP
name|Ins_MDAP
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|FT_UShort
name|point
decl_stmt|;
name|FT_F26Dot6
name|cur_dist
decl_stmt|;
name|FT_F26Dot6
name|distance
decl_stmt|;
name|point
operator|=
operator|(
name|FT_UShort
operator|)
name|args
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|BOUNDS
argument_list|(
name|point
argument_list|,
name|CUR
operator|.
name|zp0
operator|.
name|n_points
argument_list|)
condition|)
block|{
if|if
condition|(
name|CUR
operator|.
name|pedantic_hinting
condition|)
name|CUR
operator|.
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Reference
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|CUR
operator|.
name|opcode
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
name|cur_dist
operator|=
name|CUR_fast_project
argument_list|(
operator|&
name|CUR
operator|.
name|zp0
operator|.
name|cur
index|[
name|point
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_SUBPIXEL_HINTING
if|if
condition|(
name|SUBPIXEL_HINTING
operator|&&
name|CUR
operator|.
name|ignore_x_mode
operator|&&
name|CUR
operator|.
name|GS
operator|.
name|freeVector
operator|.
name|x
operator|!=
literal|0
condition|)
name|distance
operator|=
name|ROUND_None
argument_list|(
name|cur_dist
argument_list|,
name|CUR
operator|.
name|tt_metrics
operator|.
name|compensations
index|[
literal|0
index|]
argument_list|)
operator|-
name|cur_dist
expr_stmt|;
else|else
endif|#
directive|endif
name|distance
operator|=
name|CUR_Func_round
argument_list|(
name|cur_dist
argument_list|,
name|CUR
operator|.
name|tt_metrics
operator|.
name|compensations
index|[
literal|0
index|]
argument_list|)
operator|-
name|cur_dist
expr_stmt|;
block|}
else|else
name|distance
operator|=
literal|0
expr_stmt|;
name|CUR_Func_move
argument_list|(
operator|&
name|CUR
operator|.
name|zp0
argument_list|,
name|point
argument_list|,
name|distance
argument_list|)
expr_stmt|;
name|CUR
operator|.
name|GS
operator|.
name|rp0
operator|=
name|point
expr_stmt|;
name|CUR
operator|.
name|GS
operator|.
name|rp1
operator|=
name|point
expr_stmt|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* MIAP[a]:      Move Indirect Absolute Point                            */
end_comment
begin_comment
comment|/* Opcode range: 0x3E-0x3F                                               */
end_comment
begin_comment
comment|/* Stack:        uint32 uint32 -->                                       */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_MIAP
name|Ins_MIAP
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|FT_ULong
name|cvtEntry
decl_stmt|;
name|FT_UShort
name|point
decl_stmt|;
name|FT_F26Dot6
name|distance
decl_stmt|;
name|FT_F26Dot6
name|org_dist
decl_stmt|;
name|FT_F26Dot6
name|control_value_cutin
decl_stmt|;
name|control_value_cutin
operator|=
name|CUR
operator|.
name|GS
operator|.
name|control_value_cutin
expr_stmt|;
name|cvtEntry
operator|=
operator|(
name|FT_ULong
operator|)
name|args
index|[
literal|1
index|]
expr_stmt|;
name|point
operator|=
operator|(
name|FT_UShort
operator|)
name|args
index|[
literal|0
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_SUBPIXEL_HINTING
if|if
condition|(
name|SUBPIXEL_HINTING
operator|&&
name|CUR
operator|.
name|ignore_x_mode
operator|&&
name|CUR
operator|.
name|GS
operator|.
name|freeVector
operator|.
name|x
operator|!=
literal|0
operator|&&
name|CUR
operator|.
name|GS
operator|.
name|freeVector
operator|.
name|y
operator|==
literal|0
operator|&&
operator|!
operator|(
name|CUR
operator|.
name|sph_tweak_flags
operator|&
name|SPH_TWEAK_NORMAL_ROUND
operator|)
condition|)
name|control_value_cutin
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
if|if
condition|(
name|BOUNDS
argument_list|(
name|point
argument_list|,
name|CUR
operator|.
name|zp0
operator|.
name|n_points
argument_list|)
operator|||
name|BOUNDSL
argument_list|(
name|cvtEntry
argument_list|,
name|CUR
operator|.
name|cvtSize
argument_list|)
condition|)
block|{
if|if
condition|(
name|CUR
operator|.
name|pedantic_hinting
condition|)
name|CUR
operator|.
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Reference
argument_list|)
expr_stmt|;
goto|goto
name|Fail
goto|;
block|}
comment|/* UNDOCUMENTED!                                                      */
comment|/*                                                                    */
comment|/* The behaviour of an MIAP instruction is quite different when used  */
comment|/* in the twilight zone.                                              */
comment|/*                                                                    */
comment|/* First, no control value cut-in test is performed as it would fail  */
comment|/* anyway.  Second, the original point, i.e. (org_x,org_y) of         */
comment|/* zp0.point, is set to the absolute, unrounded distance found in the */
comment|/* CVT.                                                               */
comment|/*                                                                    */
comment|/* This is used in the CVT programs of the Microsoft fonts Arial,     */
comment|/* Times, etc., in order to re-adjust some key font heights.  It      */
comment|/* allows the use of the IP instruction in the twilight zone, which   */
comment|/* otherwise would be invalid according to the specification.         */
comment|/*                                                                    */
comment|/* We implement it with a special sequence for the twilight zone.     */
comment|/* This is a bad hack, but it seems to work.                          */
comment|/*                                                                    */
comment|/* Confirmed by Greg Hitchcock.                                       */
name|distance
operator|=
name|CUR_Func_read_cvt
argument_list|(
name|cvtEntry
argument_list|)
expr_stmt|;
if|if
condition|(
name|CUR
operator|.
name|GS
operator|.
name|gep0
operator|==
literal|0
condition|)
comment|/* If in twilight zone */
block|{
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_SUBPIXEL_HINTING
comment|/* Only adjust if not in sph_compatibility_mode or ignore_x_mode. */
comment|/* Determined via experimentation and may be incorrect...         */
if|if
condition|(
operator|!
name|SUBPIXEL_HINTING
operator|||
operator|(
operator|!
name|CUR
operator|.
name|ignore_x_mode
operator|||
operator|!
name|CUR
operator|.
name|face
operator|->
name|sph_compatibility_mode
operator|)
condition|)
endif|#
directive|endif
comment|/* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
name|CUR
operator|.
name|zp0
operator|.
name|org
index|[
name|point
index|]
operator|.
name|x
operator|=
name|TT_MulFix14
argument_list|(
operator|(
name|FT_UInt32
operator|)
name|distance
argument_list|,
name|CUR
operator|.
name|GS
operator|.
name|freeVector
operator|.
name|x
argument_list|)
expr_stmt|;
name|CUR
operator|.
name|zp0
operator|.
name|org
index|[
name|point
index|]
operator|.
name|y
operator|=
name|TT_MulFix14
argument_list|(
operator|(
name|FT_UInt32
operator|)
name|distance
argument_list|,
name|CUR
operator|.
name|GS
operator|.
name|freeVector
operator|.
name|y
argument_list|)
operator|,
name|CUR
operator|.
name|zp0
operator|.
name|cur
index|[
name|point
index|]
operator|=
name|CUR
operator|.
name|zp0
operator|.
name|org
index|[
name|point
index|]
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_SUBPIXEL_HINTING
if|if
condition|(
name|SUBPIXEL_HINTING
operator|&&
name|CUR
operator|.
name|ignore_x_mode
operator|&&
operator|(
name|CUR
operator|.
name|sph_tweak_flags
operator|&
name|SPH_TWEAK_MIAP_HACK
operator|)
operator|&&
name|distance
operator|>
literal|0
operator|&&
name|CUR
operator|.
name|GS
operator|.
name|freeVector
operator|.
name|y
operator|!=
literal|0
condition|)
name|distance
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
name|org_dist
operator|=
name|CUR_fast_project
argument_list|(
operator|&
name|CUR
operator|.
name|zp0
operator|.
name|cur
index|[
name|point
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|CUR
operator|.
name|opcode
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
comment|/* rounding and control cut-in flag */
block|{
if|if
condition|(
name|FT_ABS
argument_list|(
name|distance
operator|-
name|org_dist
argument_list|)
operator|>
name|control_value_cutin
condition|)
name|distance
operator|=
name|org_dist
expr_stmt|;
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_SUBPIXEL_HINTING
if|if
condition|(
name|SUBPIXEL_HINTING
operator|&&
name|CUR
operator|.
name|ignore_x_mode
operator|&&
name|CUR
operator|.
name|GS
operator|.
name|freeVector
operator|.
name|x
operator|!=
literal|0
condition|)
name|distance
operator|=
name|ROUND_None
argument_list|(
name|distance
argument_list|,
name|CUR
operator|.
name|tt_metrics
operator|.
name|compensations
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|distance
operator|=
name|CUR_Func_round
argument_list|(
name|distance
argument_list|,
name|CUR
operator|.
name|tt_metrics
operator|.
name|compensations
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
name|CUR_Func_move
argument_list|(
operator|&
name|CUR
operator|.
name|zp0
argument_list|,
name|point
argument_list|,
name|distance
operator|-
name|org_dist
argument_list|)
expr_stmt|;
name|Fail
label|:
name|CUR
operator|.
name|GS
operator|.
name|rp0
operator|=
name|point
expr_stmt|;
name|CUR
operator|.
name|GS
operator|.
name|rp1
operator|=
name|point
expr_stmt|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* MDRP[abcde]:  Move Direct Relative Point                              */
end_comment
begin_comment
comment|/* Opcode range: 0xC0-0xDF                                               */
end_comment
begin_comment
comment|/* Stack:        uint32 -->                                              */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_MDRP
name|Ins_MDRP
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|FT_UShort
name|point
decl_stmt|;
name|FT_F26Dot6
name|org_dist
decl_stmt|,
name|distance
decl_stmt|,
name|minimum_distance
decl_stmt|;
name|minimum_distance
operator|=
name|CUR
operator|.
name|GS
operator|.
name|minimum_distance
expr_stmt|;
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_SUBPIXEL_HINTING
if|if
condition|(
name|SUBPIXEL_HINTING
operator|&&
name|CUR
operator|.
name|ignore_x_mode
operator|&&
name|CUR
operator|.
name|GS
operator|.
name|freeVector
operator|.
name|x
operator|!=
literal|0
operator|&&
operator|!
operator|(
name|CUR
operator|.
name|sph_tweak_flags
operator|&
name|SPH_TWEAK_NORMAL_ROUND
operator|)
condition|)
name|minimum_distance
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
name|point
operator|=
operator|(
name|FT_UShort
operator|)
name|args
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|BOUNDS
argument_list|(
name|point
argument_list|,
name|CUR
operator|.
name|zp1
operator|.
name|n_points
argument_list|)
operator|||
name|BOUNDS
argument_list|(
name|CUR
operator|.
name|GS
operator|.
name|rp0
argument_list|,
name|CUR
operator|.
name|zp0
operator|.
name|n_points
argument_list|)
condition|)
block|{
if|if
condition|(
name|CUR
operator|.
name|pedantic_hinting
condition|)
name|CUR
operator|.
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Reference
argument_list|)
expr_stmt|;
goto|goto
name|Fail
goto|;
block|}
comment|/* XXX: Is there some undocumented feature while in the */
comment|/*      twilight zone?                                  */
comment|/* XXX: UNDOCUMENTED: twilight zone special case */
if|if
condition|(
name|CUR
operator|.
name|GS
operator|.
name|gep0
operator|==
literal|0
operator|||
name|CUR
operator|.
name|GS
operator|.
name|gep1
operator|==
literal|0
condition|)
block|{
name|FT_Vector
modifier|*
name|vec1
init|=
operator|&
name|CUR
operator|.
name|zp1
operator|.
name|org
index|[
name|point
index|]
decl_stmt|;
name|FT_Vector
modifier|*
name|vec2
init|=
operator|&
name|CUR
operator|.
name|zp0
operator|.
name|org
index|[
name|CUR
operator|.
name|GS
operator|.
name|rp0
index|]
decl_stmt|;
name|org_dist
operator|=
name|CUR_Func_dualproj
argument_list|(
name|vec1
argument_list|,
name|vec2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|FT_Vector
modifier|*
name|vec1
init|=
operator|&
name|CUR
operator|.
name|zp1
operator|.
name|orus
index|[
name|point
index|]
decl_stmt|;
name|FT_Vector
modifier|*
name|vec2
init|=
operator|&
name|CUR
operator|.
name|zp0
operator|.
name|orus
index|[
name|CUR
operator|.
name|GS
operator|.
name|rp0
index|]
decl_stmt|;
if|if
condition|(
name|CUR
operator|.
name|metrics
operator|.
name|x_scale
operator|==
name|CUR
operator|.
name|metrics
operator|.
name|y_scale
condition|)
block|{
comment|/* this should be faster */
name|org_dist
operator|=
name|CUR_Func_dualproj
argument_list|(
name|vec1
argument_list|,
name|vec2
argument_list|)
expr_stmt|;
name|org_dist
operator|=
name|FT_MulFix
argument_list|(
name|org_dist
argument_list|,
name|CUR
operator|.
name|metrics
operator|.
name|x_scale
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|FT_Vector
name|vec
decl_stmt|;
name|vec
operator|.
name|x
operator|=
name|FT_MulFix
argument_list|(
name|vec1
operator|->
name|x
operator|-
name|vec2
operator|->
name|x
argument_list|,
name|CUR
operator|.
name|metrics
operator|.
name|x_scale
argument_list|)
expr_stmt|;
name|vec
operator|.
name|y
operator|=
name|FT_MulFix
argument_list|(
name|vec1
operator|->
name|y
operator|-
name|vec2
operator|->
name|y
argument_list|,
name|CUR
operator|.
name|metrics
operator|.
name|y_scale
argument_list|)
expr_stmt|;
name|org_dist
operator|=
name|CUR_fast_dualproj
argument_list|(
operator|&
name|vec
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* single width cut-in test */
if|if
condition|(
name|FT_ABS
argument_list|(
name|org_dist
operator|-
name|CUR
operator|.
name|GS
operator|.
name|single_width_value
argument_list|)
operator|<
name|CUR
operator|.
name|GS
operator|.
name|single_width_cutin
condition|)
block|{
if|if
condition|(
name|org_dist
operator|>=
literal|0
condition|)
name|org_dist
operator|=
name|CUR
operator|.
name|GS
operator|.
name|single_width_value
expr_stmt|;
else|else
name|org_dist
operator|=
operator|-
name|CUR
operator|.
name|GS
operator|.
name|single_width_value
expr_stmt|;
block|}
comment|/* round flag */
if|if
condition|(
operator|(
name|CUR
operator|.
name|opcode
operator|&
literal|4
operator|)
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_SUBPIXEL_HINTING
if|if
condition|(
name|SUBPIXEL_HINTING
operator|&&
name|CUR
operator|.
name|ignore_x_mode
operator|&&
name|CUR
operator|.
name|GS
operator|.
name|freeVector
operator|.
name|x
operator|!=
literal|0
condition|)
name|distance
operator|=
name|ROUND_None
argument_list|(
name|org_dist
argument_list|,
name|CUR
operator|.
name|tt_metrics
operator|.
name|compensations
index|[
name|CUR
operator|.
name|opcode
operator|&
literal|3
index|]
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|distance
operator|=
name|CUR_Func_round
argument_list|(
name|org_dist
argument_list|,
name|CUR
operator|.
name|tt_metrics
operator|.
name|compensations
index|[
name|CUR
operator|.
name|opcode
operator|&
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
else|else
name|distance
operator|=
name|ROUND_None
argument_list|(
name|org_dist
argument_list|,
name|CUR
operator|.
name|tt_metrics
operator|.
name|compensations
index|[
name|CUR
operator|.
name|opcode
operator|&
literal|3
index|]
argument_list|)
expr_stmt|;
comment|/* minimum distance flag */
if|if
condition|(
operator|(
name|CUR
operator|.
name|opcode
operator|&
literal|8
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|org_dist
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|distance
operator|<
name|minimum_distance
condition|)
name|distance
operator|=
name|minimum_distance
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|distance
operator|>
operator|-
name|minimum_distance
condition|)
name|distance
operator|=
operator|-
name|minimum_distance
expr_stmt|;
block|}
block|}
comment|/* now move the point */
name|org_dist
operator|=
name|CUR_Func_project
argument_list|(
name|CUR
operator|.
name|zp1
operator|.
name|cur
operator|+
name|point
argument_list|,
name|CUR
operator|.
name|zp0
operator|.
name|cur
operator|+
name|CUR
operator|.
name|GS
operator|.
name|rp0
argument_list|)
expr_stmt|;
name|CUR_Func_move
argument_list|(
operator|&
name|CUR
operator|.
name|zp1
argument_list|,
name|point
argument_list|,
name|distance
operator|-
name|org_dist
argument_list|)
expr_stmt|;
name|Fail
label|:
name|CUR
operator|.
name|GS
operator|.
name|rp1
operator|=
name|CUR
operator|.
name|GS
operator|.
name|rp0
expr_stmt|;
name|CUR
operator|.
name|GS
operator|.
name|rp2
operator|=
name|point
expr_stmt|;
if|if
condition|(
operator|(
name|CUR
operator|.
name|opcode
operator|&
literal|16
operator|)
operator|!=
literal|0
condition|)
name|CUR
operator|.
name|GS
operator|.
name|rp0
operator|=
name|point
expr_stmt|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* MIRP[abcde]:  Move Indirect Relative Point                            */
end_comment
begin_comment
comment|/* Opcode range: 0xE0-0xFF                                               */
end_comment
begin_comment
comment|/* Stack:        int32? uint32 -->                                       */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_MIRP
name|Ins_MIRP
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|FT_UShort
name|point
decl_stmt|;
name|FT_ULong
name|cvtEntry
decl_stmt|;
name|FT_F26Dot6
name|cvt_dist
decl_stmt|,
name|distance
decl_stmt|,
name|cur_dist
decl_stmt|,
name|org_dist
decl_stmt|,
name|control_value_cutin
decl_stmt|,
name|minimum_distance
decl_stmt|;
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_SUBPIXEL_HINTING
name|FT_Int
name|B1
init|=
literal|0
decl_stmt|;
comment|/* pacify compiler */
name|FT_Int
name|B2
init|=
literal|0
decl_stmt|;
name|FT_Bool
name|reverse_move
init|=
name|FALSE
decl_stmt|;
endif|#
directive|endif
comment|/* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
name|minimum_distance
operator|=
name|CUR
operator|.
name|GS
operator|.
name|minimum_distance
expr_stmt|;
name|control_value_cutin
operator|=
name|CUR
operator|.
name|GS
operator|.
name|control_value_cutin
expr_stmt|;
name|point
operator|=
operator|(
name|FT_UShort
operator|)
name|args
index|[
literal|0
index|]
expr_stmt|;
name|cvtEntry
operator|=
call|(
name|FT_ULong
call|)
argument_list|(
name|args
index|[
literal|1
index|]
operator|+
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_SUBPIXEL_HINTING
if|if
condition|(
name|SUBPIXEL_HINTING
operator|&&
name|CUR
operator|.
name|ignore_x_mode
operator|&&
name|CUR
operator|.
name|GS
operator|.
name|freeVector
operator|.
name|x
operator|!=
literal|0
operator|&&
operator|!
operator|(
name|CUR
operator|.
name|sph_tweak_flags
operator|&
name|SPH_TWEAK_NORMAL_ROUND
operator|)
condition|)
name|control_value_cutin
operator|=
name|minimum_distance
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
comment|/* XXX: UNDOCUMENTED! cvt[-1] = 0 always */
if|if
condition|(
name|BOUNDS
argument_list|(
name|point
argument_list|,
name|CUR
operator|.
name|zp1
operator|.
name|n_points
argument_list|)
operator|||
name|BOUNDSL
argument_list|(
name|cvtEntry
argument_list|,
name|CUR
operator|.
name|cvtSize
operator|+
literal|1
argument_list|)
operator|||
name|BOUNDS
argument_list|(
name|CUR
operator|.
name|GS
operator|.
name|rp0
argument_list|,
name|CUR
operator|.
name|zp0
operator|.
name|n_points
argument_list|)
condition|)
block|{
if|if
condition|(
name|CUR
operator|.
name|pedantic_hinting
condition|)
name|CUR
operator|.
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Reference
argument_list|)
expr_stmt|;
goto|goto
name|Fail
goto|;
block|}
if|if
condition|(
operator|!
name|cvtEntry
condition|)
name|cvt_dist
operator|=
literal|0
expr_stmt|;
else|else
name|cvt_dist
operator|=
name|CUR_Func_read_cvt
argument_list|(
name|cvtEntry
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* single width test */
if|if
condition|(
name|FT_ABS
argument_list|(
name|cvt_dist
operator|-
name|CUR
operator|.
name|GS
operator|.
name|single_width_value
argument_list|)
operator|<
name|CUR
operator|.
name|GS
operator|.
name|single_width_cutin
condition|)
block|{
if|if
condition|(
name|cvt_dist
operator|>=
literal|0
condition|)
name|cvt_dist
operator|=
name|CUR
operator|.
name|GS
operator|.
name|single_width_value
expr_stmt|;
else|else
name|cvt_dist
operator|=
operator|-
name|CUR
operator|.
name|GS
operator|.
name|single_width_value
expr_stmt|;
block|}
comment|/* UNDOCUMENTED!  The MS rasterizer does that with */
comment|/* twilight points (confirmed by Greg Hitchcock)   */
if|if
condition|(
name|CUR
operator|.
name|GS
operator|.
name|gep1
operator|==
literal|0
condition|)
block|{
name|CUR
operator|.
name|zp1
operator|.
name|org
index|[
name|point
index|]
operator|.
name|x
operator|=
name|CUR
operator|.
name|zp0
operator|.
name|org
index|[
name|CUR
operator|.
name|GS
operator|.
name|rp0
index|]
operator|.
name|x
operator|+
name|TT_MulFix14
argument_list|(
operator|(
name|FT_UInt32
operator|)
name|cvt_dist
argument_list|,
name|CUR
operator|.
name|GS
operator|.
name|freeVector
operator|.
name|x
argument_list|)
expr_stmt|;
name|CUR
operator|.
name|zp1
operator|.
name|org
index|[
name|point
index|]
operator|.
name|y
operator|=
name|CUR
operator|.
name|zp0
operator|.
name|org
index|[
name|CUR
operator|.
name|GS
operator|.
name|rp0
index|]
operator|.
name|y
operator|+
name|TT_MulFix14
argument_list|(
operator|(
name|FT_UInt32
operator|)
name|cvt_dist
argument_list|,
name|CUR
operator|.
name|GS
operator|.
name|freeVector
operator|.
name|y
argument_list|)
expr_stmt|;
name|CUR
operator|.
name|zp1
operator|.
name|cur
index|[
name|point
index|]
operator|=
name|CUR
operator|.
name|zp1
operator|.
name|org
index|[
name|point
index|]
expr_stmt|;
block|}
name|org_dist
operator|=
name|CUR_Func_dualproj
argument_list|(
operator|&
name|CUR
operator|.
name|zp1
operator|.
name|org
index|[
name|point
index|]
argument_list|,
operator|&
name|CUR
operator|.
name|zp0
operator|.
name|org
index|[
name|CUR
operator|.
name|GS
operator|.
name|rp0
index|]
argument_list|)
expr_stmt|;
name|cur_dist
operator|=
name|CUR_Func_project
argument_list|(
operator|&
name|CUR
operator|.
name|zp1
operator|.
name|cur
index|[
name|point
index|]
argument_list|,
operator|&
name|CUR
operator|.
name|zp0
operator|.
name|cur
index|[
name|CUR
operator|.
name|GS
operator|.
name|rp0
index|]
argument_list|)
expr_stmt|;
comment|/* auto-flip test */
if|if
condition|(
name|CUR
operator|.
name|GS
operator|.
name|auto_flip
condition|)
block|{
if|if
condition|(
operator|(
name|org_dist
operator|^
name|cvt_dist
operator|)
operator|<
literal|0
condition|)
name|cvt_dist
operator|=
operator|-
name|cvt_dist
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_SUBPIXEL_HINTING
if|if
condition|(
name|SUBPIXEL_HINTING
operator|&&
name|CUR
operator|.
name|ignore_x_mode
operator|&&
name|CUR
operator|.
name|GS
operator|.
name|freeVector
operator|.
name|y
operator|!=
literal|0
operator|&&
operator|(
name|CUR
operator|.
name|sph_tweak_flags
operator|&
name|SPH_TWEAK_TIMES_NEW_ROMAN_HACK
operator|)
condition|)
block|{
if|if
condition|(
name|cur_dist
operator|<
operator|-
literal|64
condition|)
name|cvt_dist
operator|-=
literal|16
expr_stmt|;
elseif|else
if|if
condition|(
name|cur_dist
operator|>
literal|64
operator|&&
name|cur_dist
operator|<
literal|84
condition|)
name|cvt_dist
operator|+=
literal|32
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
comment|/* control value cut-in and round */
if|if
condition|(
operator|(
name|CUR
operator|.
name|opcode
operator|&
literal|4
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* XXX: UNDOCUMENTED!  Only perform cut-in test when both points */
comment|/*      refer to the same zone.                                  */
if|if
condition|(
name|CUR
operator|.
name|GS
operator|.
name|gep0
operator|==
name|CUR
operator|.
name|GS
operator|.
name|gep1
condition|)
block|{
comment|/* XXX: According to Greg Hitchcock, the following wording is */
comment|/*      the right one:                                        */
comment|/*                                                            */
comment|/*        When the absolute difference between the value in   */
comment|/*        the table [CVT] and the measurement directly from   */
comment|/*        the outline is _greater_ than the cut_in value, the */
comment|/*        outline measurement is used.                        */
comment|/*                                                            */
comment|/*      This is from `instgly.doc'.  The description in       */
comment|/*      `ttinst2.doc', version 1.66, is thus incorrect since  */
comment|/*      it implies `>=' instead of `>'.                       */
if|if
condition|(
name|FT_ABS
argument_list|(
name|cvt_dist
operator|-
name|org_dist
argument_list|)
operator|>
name|control_value_cutin
condition|)
name|cvt_dist
operator|=
name|org_dist
expr_stmt|;
block|}
name|distance
operator|=
name|CUR_Func_round
argument_list|(
name|cvt_dist
argument_list|,
name|CUR
operator|.
name|tt_metrics
operator|.
name|compensations
index|[
name|CUR
operator|.
name|opcode
operator|&
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_SUBPIXEL_HINTING
comment|/* do cvt cut-in always in MIRP for sph */
if|if
condition|(
name|SUBPIXEL_HINTING
operator|&&
name|CUR
operator|.
name|ignore_x_mode
operator|&&
name|CUR
operator|.
name|GS
operator|.
name|gep0
operator|==
name|CUR
operator|.
name|GS
operator|.
name|gep1
condition|)
block|{
if|if
condition|(
name|FT_ABS
argument_list|(
name|cvt_dist
operator|-
name|org_dist
argument_list|)
operator|>
name|control_value_cutin
condition|)
name|cvt_dist
operator|=
name|org_dist
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
name|distance
operator|=
name|ROUND_None
argument_list|(
name|cvt_dist
argument_list|,
name|CUR
operator|.
name|tt_metrics
operator|.
name|compensations
index|[
name|CUR
operator|.
name|opcode
operator|&
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* minimum distance test */
if|if
condition|(
operator|(
name|CUR
operator|.
name|opcode
operator|&
literal|8
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|org_dist
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|distance
operator|<
name|minimum_distance
condition|)
name|distance
operator|=
name|minimum_distance
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|distance
operator|>
operator|-
name|minimum_distance
condition|)
name|distance
operator|=
operator|-
name|minimum_distance
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_SUBPIXEL_HINTING
if|if
condition|(
name|SUBPIXEL_HINTING
condition|)
block|{
name|B1
operator|=
name|CUR
operator|.
name|zp1
operator|.
name|cur
index|[
name|point
index|]
operator|.
name|y
expr_stmt|;
comment|/* Round moves if necessary */
if|if
condition|(
name|CUR
operator|.
name|ignore_x_mode
operator|&&
name|CUR
operator|.
name|GS
operator|.
name|freeVector
operator|.
name|y
operator|!=
literal|0
operator|&&
operator|(
name|CUR
operator|.
name|sph_tweak_flags
operator|&
name|SPH_TWEAK_ROUND_NONPIXEL_Y_MOVES
operator|)
condition|)
name|distance
operator|=
name|FT_PIX_ROUND
argument_list|(
name|B1
operator|+
name|distance
operator|-
name|cur_dist
argument_list|)
operator|-
name|B1
operator|+
name|cur_dist
expr_stmt|;
if|if
condition|(
name|CUR
operator|.
name|ignore_x_mode
operator|&&
name|CUR
operator|.
name|GS
operator|.
name|freeVector
operator|.
name|y
operator|!=
literal|0
operator|&&
operator|(
name|CUR
operator|.
name|opcode
operator|&
literal|16
operator|)
operator|==
literal|0
operator|&&
operator|(
name|CUR
operator|.
name|opcode
operator|&
literal|8
operator|)
operator|==
literal|0
operator|&&
operator|(
name|CUR
operator|.
name|sph_tweak_flags
operator|&
name|SPH_TWEAK_COURIER_NEW_2_HACK
operator|)
condition|)
name|distance
operator|+=
literal|64
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
name|CUR_Func_move
argument_list|(
operator|&
name|CUR
operator|.
name|zp1
argument_list|,
name|point
argument_list|,
name|distance
operator|-
name|cur_dist
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_SUBPIXEL_HINTING
if|if
condition|(
name|SUBPIXEL_HINTING
condition|)
block|{
name|B2
operator|=
name|CUR
operator|.
name|zp1
operator|.
name|cur
index|[
name|point
index|]
operator|.
name|y
expr_stmt|;
comment|/* Reverse move if necessary */
if|if
condition|(
name|CUR
operator|.
name|ignore_x_mode
condition|)
block|{
if|if
condition|(
name|CUR
operator|.
name|face
operator|->
name|sph_compatibility_mode
operator|&&
name|CUR
operator|.
name|GS
operator|.
name|freeVector
operator|.
name|y
operator|!=
literal|0
operator|&&
operator|(
name|B1
operator|&
literal|63
operator|)
operator|==
literal|0
operator|&&
operator|(
name|B2
operator|&
literal|63
operator|)
operator|!=
literal|0
condition|)
name|reverse_move
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|(
name|CUR
operator|.
name|sph_tweak_flags
operator|&
name|SPH_TWEAK_SKIP_NONPIXEL_Y_MOVES
operator|)
operator|&&
name|CUR
operator|.
name|GS
operator|.
name|freeVector
operator|.
name|y
operator|!=
literal|0
operator|&&
operator|(
name|B2
operator|&
literal|63
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|B1
operator|&
literal|63
operator|)
operator|!=
literal|0
condition|)
name|reverse_move
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|reverse_move
condition|)
name|CUR_Func_move
argument_list|(
operator|&
name|CUR
operator|.
name|zp1
argument_list|,
name|point
argument_list|,
operator|-
operator|(
name|distance
operator|-
name|cur_dist
operator|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
name|Fail
label|:
name|CUR
operator|.
name|GS
operator|.
name|rp1
operator|=
name|CUR
operator|.
name|GS
operator|.
name|rp0
expr_stmt|;
if|if
condition|(
operator|(
name|CUR
operator|.
name|opcode
operator|&
literal|16
operator|)
operator|!=
literal|0
condition|)
name|CUR
operator|.
name|GS
operator|.
name|rp0
operator|=
name|point
expr_stmt|;
name|CUR
operator|.
name|GS
operator|.
name|rp2
operator|=
name|point
expr_stmt|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* ALIGNRP[]:    ALIGN Relative Point                                    */
end_comment
begin_comment
comment|/* Opcode range: 0x3C                                                    */
end_comment
begin_comment
comment|/* Stack:        uint32 uint32... -->                                    */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_ALIGNRP
name|Ins_ALIGNRP
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|FT_UShort
name|point
decl_stmt|;
name|FT_F26Dot6
name|distance
decl_stmt|;
name|FT_UNUSED_ARG
expr_stmt|;
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_SUBPIXEL_HINTING
if|if
condition|(
name|SUBPIXEL_HINTING
operator|&&
name|CUR
operator|.
name|ignore_x_mode
operator|&&
name|CUR
operator|.
name|iup_called
operator|&&
operator|(
name|CUR
operator|.
name|sph_tweak_flags
operator|&
name|SPH_TWEAK_NO_ALIGNRP_AFTER_IUP
operator|)
condition|)
block|{
name|CUR
operator|.
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Reference
argument_list|)
expr_stmt|;
goto|goto
name|Fail
goto|;
block|}
endif|#
directive|endif
comment|/* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
if|if
condition|(
name|CUR
operator|.
name|top
operator|<
name|CUR
operator|.
name|GS
operator|.
name|loop
operator|||
name|BOUNDS
argument_list|(
name|CUR
operator|.
name|GS
operator|.
name|rp0
argument_list|,
name|CUR
operator|.
name|zp0
operator|.
name|n_points
argument_list|)
condition|)
block|{
if|if
condition|(
name|CUR
operator|.
name|pedantic_hinting
condition|)
name|CUR
operator|.
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Reference
argument_list|)
expr_stmt|;
goto|goto
name|Fail
goto|;
block|}
while|while
condition|(
name|CUR
operator|.
name|GS
operator|.
name|loop
operator|>
literal|0
condition|)
block|{
name|CUR
operator|.
name|args
operator|--
expr_stmt|;
name|point
operator|=
operator|(
name|FT_UShort
operator|)
name|CUR
operator|.
name|stack
index|[
name|CUR
operator|.
name|args
index|]
expr_stmt|;
if|if
condition|(
name|BOUNDS
argument_list|(
name|point
argument_list|,
name|CUR
operator|.
name|zp1
operator|.
name|n_points
argument_list|)
condition|)
block|{
if|if
condition|(
name|CUR
operator|.
name|pedantic_hinting
condition|)
block|{
name|CUR
operator|.
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Reference
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|distance
operator|=
name|CUR_Func_project
argument_list|(
name|CUR
operator|.
name|zp1
operator|.
name|cur
operator|+
name|point
argument_list|,
name|CUR
operator|.
name|zp0
operator|.
name|cur
operator|+
name|CUR
operator|.
name|GS
operator|.
name|rp0
argument_list|)
expr_stmt|;
name|CUR_Func_move
argument_list|(
operator|&
name|CUR
operator|.
name|zp1
argument_list|,
name|point
argument_list|,
operator|-
name|distance
argument_list|)
expr_stmt|;
block|}
name|CUR
operator|.
name|GS
operator|.
name|loop
operator|--
expr_stmt|;
block|}
name|Fail
label|:
name|CUR
operator|.
name|GS
operator|.
name|loop
operator|=
literal|1
expr_stmt|;
name|CUR
operator|.
name|new_top
operator|=
name|CUR
operator|.
name|args
expr_stmt|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* ISECT[]:      moves point to InterSECTion                             */
end_comment
begin_comment
comment|/* Opcode range: 0x0F                                                    */
end_comment
begin_comment
comment|/* Stack:        5 * uint32 -->                                          */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_ISECT
name|Ins_ISECT
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|FT_UShort
name|point
decl_stmt|,
name|a0
decl_stmt|,
name|a1
decl_stmt|,
name|b0
decl_stmt|,
name|b1
decl_stmt|;
name|FT_F26Dot6
name|discriminant
decl_stmt|,
name|dotproduct
decl_stmt|;
name|FT_F26Dot6
name|dx
decl_stmt|,
name|dy
decl_stmt|,
name|dax
decl_stmt|,
name|day
decl_stmt|,
name|dbx
decl_stmt|,
name|dby
decl_stmt|;
name|FT_F26Dot6
name|val
decl_stmt|;
name|FT_Vector
name|R
decl_stmt|;
name|point
operator|=
operator|(
name|FT_UShort
operator|)
name|args
index|[
literal|0
index|]
expr_stmt|;
name|a0
operator|=
operator|(
name|FT_UShort
operator|)
name|args
index|[
literal|1
index|]
expr_stmt|;
name|a1
operator|=
operator|(
name|FT_UShort
operator|)
name|args
index|[
literal|2
index|]
expr_stmt|;
name|b0
operator|=
operator|(
name|FT_UShort
operator|)
name|args
index|[
literal|3
index|]
expr_stmt|;
name|b1
operator|=
operator|(
name|FT_UShort
operator|)
name|args
index|[
literal|4
index|]
expr_stmt|;
if|if
condition|(
name|BOUNDS
argument_list|(
name|b0
argument_list|,
name|CUR
operator|.
name|zp0
operator|.
name|n_points
argument_list|)
operator|||
name|BOUNDS
argument_list|(
name|b1
argument_list|,
name|CUR
operator|.
name|zp0
operator|.
name|n_points
argument_list|)
operator|||
name|BOUNDS
argument_list|(
name|a0
argument_list|,
name|CUR
operator|.
name|zp1
operator|.
name|n_points
argument_list|)
operator|||
name|BOUNDS
argument_list|(
name|a1
argument_list|,
name|CUR
operator|.
name|zp1
operator|.
name|n_points
argument_list|)
operator|||
name|BOUNDS
argument_list|(
name|point
argument_list|,
name|CUR
operator|.
name|zp2
operator|.
name|n_points
argument_list|)
condition|)
block|{
if|if
condition|(
name|CUR
operator|.
name|pedantic_hinting
condition|)
name|CUR
operator|.
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Reference
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Cramer's rule */
name|dbx
operator|=
name|CUR
operator|.
name|zp0
operator|.
name|cur
index|[
name|b1
index|]
operator|.
name|x
operator|-
name|CUR
operator|.
name|zp0
operator|.
name|cur
index|[
name|b0
index|]
operator|.
name|x
expr_stmt|;
name|dby
operator|=
name|CUR
operator|.
name|zp0
operator|.
name|cur
index|[
name|b1
index|]
operator|.
name|y
operator|-
name|CUR
operator|.
name|zp0
operator|.
name|cur
index|[
name|b0
index|]
operator|.
name|y
expr_stmt|;
name|dax
operator|=
name|CUR
operator|.
name|zp1
operator|.
name|cur
index|[
name|a1
index|]
operator|.
name|x
operator|-
name|CUR
operator|.
name|zp1
operator|.
name|cur
index|[
name|a0
index|]
operator|.
name|x
expr_stmt|;
name|day
operator|=
name|CUR
operator|.
name|zp1
operator|.
name|cur
index|[
name|a1
index|]
operator|.
name|y
operator|-
name|CUR
operator|.
name|zp1
operator|.
name|cur
index|[
name|a0
index|]
operator|.
name|y
expr_stmt|;
name|dx
operator|=
name|CUR
operator|.
name|zp0
operator|.
name|cur
index|[
name|b0
index|]
operator|.
name|x
operator|-
name|CUR
operator|.
name|zp1
operator|.
name|cur
index|[
name|a0
index|]
operator|.
name|x
expr_stmt|;
name|dy
operator|=
name|CUR
operator|.
name|zp0
operator|.
name|cur
index|[
name|b0
index|]
operator|.
name|y
operator|-
name|CUR
operator|.
name|zp1
operator|.
name|cur
index|[
name|a0
index|]
operator|.
name|y
expr_stmt|;
name|CUR
operator|.
name|zp2
operator|.
name|tags
index|[
name|point
index|]
operator||=
name|FT_CURVE_TAG_TOUCH_BOTH
expr_stmt|;
name|discriminant
operator|=
name|FT_MulDiv
argument_list|(
name|dax
argument_list|,
operator|-
name|dby
argument_list|,
literal|0x40
argument_list|)
operator|+
name|FT_MulDiv
argument_list|(
name|day
argument_list|,
name|dbx
argument_list|,
literal|0x40
argument_list|)
expr_stmt|;
name|dotproduct
operator|=
name|FT_MulDiv
argument_list|(
name|dax
argument_list|,
name|dbx
argument_list|,
literal|0x40
argument_list|)
operator|+
name|FT_MulDiv
argument_list|(
name|day
argument_list|,
name|dby
argument_list|,
literal|0x40
argument_list|)
expr_stmt|;
comment|/* The discriminant above is actually a cross product of vectors     */
comment|/* da and db. Together with the dot product, they can be used as     */
comment|/* surrogates for sine and cosine of the angle between the vectors.  */
comment|/* Indeed,                                                           */
comment|/*       dotproduct   = |da||db|cos(angle)                           */
comment|/*       discriminant = |da||db|sin(angle)     .                     */
comment|/* We use these equations to reject grazing intersections by         */
comment|/* thresholding abs(tan(angle)) at 1/19, corresponding to 3 degrees. */
if|if
condition|(
literal|19
operator|*
name|FT_ABS
argument_list|(
name|discriminant
argument_list|)
operator|>
name|FT_ABS
argument_list|(
name|dotproduct
argument_list|)
condition|)
block|{
name|val
operator|=
name|FT_MulDiv
argument_list|(
name|dx
argument_list|,
operator|-
name|dby
argument_list|,
literal|0x40
argument_list|)
operator|+
name|FT_MulDiv
argument_list|(
name|dy
argument_list|,
name|dbx
argument_list|,
literal|0x40
argument_list|)
expr_stmt|;
name|R
operator|.
name|x
operator|=
name|FT_MulDiv
argument_list|(
name|val
argument_list|,
name|dax
argument_list|,
name|discriminant
argument_list|)
expr_stmt|;
name|R
operator|.
name|y
operator|=
name|FT_MulDiv
argument_list|(
name|val
argument_list|,
name|day
argument_list|,
name|discriminant
argument_list|)
expr_stmt|;
name|CUR
operator|.
name|zp2
operator|.
name|cur
index|[
name|point
index|]
operator|.
name|x
operator|=
name|CUR
operator|.
name|zp1
operator|.
name|cur
index|[
name|a0
index|]
operator|.
name|x
operator|+
name|R
operator|.
name|x
expr_stmt|;
name|CUR
operator|.
name|zp2
operator|.
name|cur
index|[
name|point
index|]
operator|.
name|y
operator|=
name|CUR
operator|.
name|zp1
operator|.
name|cur
index|[
name|a0
index|]
operator|.
name|y
operator|+
name|R
operator|.
name|y
expr_stmt|;
block|}
else|else
block|{
comment|/* else, take the middle of the middles of A and B */
name|CUR
operator|.
name|zp2
operator|.
name|cur
index|[
name|point
index|]
operator|.
name|x
operator|=
operator|(
name|CUR
operator|.
name|zp1
operator|.
name|cur
index|[
name|a0
index|]
operator|.
name|x
operator|+
name|CUR
operator|.
name|zp1
operator|.
name|cur
index|[
name|a1
index|]
operator|.
name|x
operator|+
name|CUR
operator|.
name|zp0
operator|.
name|cur
index|[
name|b0
index|]
operator|.
name|x
operator|+
name|CUR
operator|.
name|zp0
operator|.
name|cur
index|[
name|b1
index|]
operator|.
name|x
operator|)
operator|/
literal|4
expr_stmt|;
name|CUR
operator|.
name|zp2
operator|.
name|cur
index|[
name|point
index|]
operator|.
name|y
operator|=
operator|(
name|CUR
operator|.
name|zp1
operator|.
name|cur
index|[
name|a0
index|]
operator|.
name|y
operator|+
name|CUR
operator|.
name|zp1
operator|.
name|cur
index|[
name|a1
index|]
operator|.
name|y
operator|+
name|CUR
operator|.
name|zp0
operator|.
name|cur
index|[
name|b0
index|]
operator|.
name|y
operator|+
name|CUR
operator|.
name|zp0
operator|.
name|cur
index|[
name|b1
index|]
operator|.
name|y
operator|)
operator|/
literal|4
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* ALIGNPTS[]:   ALIGN PoinTS                                            */
end_comment
begin_comment
comment|/* Opcode range: 0x27                                                    */
end_comment
begin_comment
comment|/* Stack:        uint32 uint32 -->                                       */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_ALIGNPTS
name|Ins_ALIGNPTS
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|FT_UShort
name|p1
decl_stmt|,
name|p2
decl_stmt|;
name|FT_F26Dot6
name|distance
decl_stmt|;
name|p1
operator|=
operator|(
name|FT_UShort
operator|)
name|args
index|[
literal|0
index|]
expr_stmt|;
name|p2
operator|=
operator|(
name|FT_UShort
operator|)
name|args
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|BOUNDS
argument_list|(
name|p1
argument_list|,
name|CUR
operator|.
name|zp1
operator|.
name|n_points
argument_list|)
operator|||
name|BOUNDS
argument_list|(
name|p2
argument_list|,
name|CUR
operator|.
name|zp0
operator|.
name|n_points
argument_list|)
condition|)
block|{
if|if
condition|(
name|CUR
operator|.
name|pedantic_hinting
condition|)
name|CUR
operator|.
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Reference
argument_list|)
expr_stmt|;
return|return;
block|}
name|distance
operator|=
name|CUR_Func_project
argument_list|(
name|CUR
operator|.
name|zp0
operator|.
name|cur
operator|+
name|p2
argument_list|,
name|CUR
operator|.
name|zp1
operator|.
name|cur
operator|+
name|p1
argument_list|)
operator|/
literal|2
expr_stmt|;
name|CUR_Func_move
argument_list|(
operator|&
name|CUR
operator|.
name|zp1
argument_list|,
name|p1
argument_list|,
name|distance
argument_list|)
expr_stmt|;
name|CUR_Func_move
argument_list|(
operator|&
name|CUR
operator|.
name|zp0
argument_list|,
name|p2
argument_list|,
operator|-
name|distance
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* IP[]:         Interpolate Point                                       */
end_comment
begin_comment
comment|/* Opcode range: 0x39                                                    */
end_comment
begin_comment
comment|/* Stack:        uint32... -->                                           */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* SOMETIMES, DUMBER CODE IS BETTER CODE */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_IP
name|Ins_IP
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|FT_F26Dot6
name|old_range
decl_stmt|,
name|cur_range
decl_stmt|;
name|FT_Vector
modifier|*
name|orus_base
decl_stmt|;
name|FT_Vector
modifier|*
name|cur_base
decl_stmt|;
name|FT_Int
name|twilight
decl_stmt|;
name|FT_UNUSED_ARG
expr_stmt|;
if|if
condition|(
name|CUR
operator|.
name|top
operator|<
name|CUR
operator|.
name|GS
operator|.
name|loop
condition|)
block|{
if|if
condition|(
name|CUR
operator|.
name|pedantic_hinting
condition|)
name|CUR
operator|.
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Reference
argument_list|)
expr_stmt|;
goto|goto
name|Fail
goto|;
block|}
comment|/*      * We need to deal in a special way with the twilight zone.      * Otherwise, by definition, the value of CUR.twilight.orus[n] is (0,0),      * for every n.      */
name|twilight
operator|=
name|CUR
operator|.
name|GS
operator|.
name|gep0
operator|==
literal|0
operator|||
name|CUR
operator|.
name|GS
operator|.
name|gep1
operator|==
literal|0
operator|||
name|CUR
operator|.
name|GS
operator|.
name|gep2
operator|==
literal|0
expr_stmt|;
if|if
condition|(
name|BOUNDS
argument_list|(
name|CUR
operator|.
name|GS
operator|.
name|rp1
argument_list|,
name|CUR
operator|.
name|zp0
operator|.
name|n_points
argument_list|)
condition|)
block|{
if|if
condition|(
name|CUR
operator|.
name|pedantic_hinting
condition|)
name|CUR
operator|.
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Reference
argument_list|)
expr_stmt|;
goto|goto
name|Fail
goto|;
block|}
if|if
condition|(
name|twilight
condition|)
name|orus_base
operator|=
operator|&
name|CUR
operator|.
name|zp0
operator|.
name|org
index|[
name|CUR
operator|.
name|GS
operator|.
name|rp1
index|]
expr_stmt|;
else|else
name|orus_base
operator|=
operator|&
name|CUR
operator|.
name|zp0
operator|.
name|orus
index|[
name|CUR
operator|.
name|GS
operator|.
name|rp1
index|]
expr_stmt|;
name|cur_base
operator|=
operator|&
name|CUR
operator|.
name|zp0
operator|.
name|cur
index|[
name|CUR
operator|.
name|GS
operator|.
name|rp1
index|]
expr_stmt|;
comment|/* XXX: There are some glyphs in some braindead but popular */
comment|/*      fonts out there (e.g. [aeu]grave in monotype.ttf)   */
comment|/*      calling IP[] with bad values of rp[12].             */
comment|/*      Do something sane when this odd thing happens.      */
if|if
condition|(
name|BOUNDS
argument_list|(
name|CUR
operator|.
name|GS
operator|.
name|rp1
argument_list|,
name|CUR
operator|.
name|zp0
operator|.
name|n_points
argument_list|)
operator|||
name|BOUNDS
argument_list|(
name|CUR
operator|.
name|GS
operator|.
name|rp2
argument_list|,
name|CUR
operator|.
name|zp1
operator|.
name|n_points
argument_list|)
condition|)
block|{
name|old_range
operator|=
literal|0
expr_stmt|;
name|cur_range
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|twilight
condition|)
name|old_range
operator|=
name|CUR_Func_dualproj
argument_list|(
operator|&
name|CUR
operator|.
name|zp1
operator|.
name|org
index|[
name|CUR
operator|.
name|GS
operator|.
name|rp2
index|]
argument_list|,
name|orus_base
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CUR
operator|.
name|metrics
operator|.
name|x_scale
operator|==
name|CUR
operator|.
name|metrics
operator|.
name|y_scale
condition|)
name|old_range
operator|=
name|CUR_Func_dualproj
argument_list|(
operator|&
name|CUR
operator|.
name|zp1
operator|.
name|orus
index|[
name|CUR
operator|.
name|GS
operator|.
name|rp2
index|]
argument_list|,
name|orus_base
argument_list|)
expr_stmt|;
else|else
block|{
name|FT_Vector
name|vec
decl_stmt|;
name|vec
operator|.
name|x
operator|=
name|FT_MulFix
argument_list|(
name|CUR
operator|.
name|zp1
operator|.
name|orus
index|[
name|CUR
operator|.
name|GS
operator|.
name|rp2
index|]
operator|.
name|x
operator|-
name|orus_base
operator|->
name|x
argument_list|,
name|CUR
operator|.
name|metrics
operator|.
name|x_scale
argument_list|)
expr_stmt|;
name|vec
operator|.
name|y
operator|=
name|FT_MulFix
argument_list|(
name|CUR
operator|.
name|zp1
operator|.
name|orus
index|[
name|CUR
operator|.
name|GS
operator|.
name|rp2
index|]
operator|.
name|y
operator|-
name|orus_base
operator|->
name|y
argument_list|,
name|CUR
operator|.
name|metrics
operator|.
name|y_scale
argument_list|)
expr_stmt|;
name|old_range
operator|=
name|CUR_fast_dualproj
argument_list|(
operator|&
name|vec
argument_list|)
expr_stmt|;
block|}
name|cur_range
operator|=
name|CUR_Func_project
argument_list|(
operator|&
name|CUR
operator|.
name|zp1
operator|.
name|cur
index|[
name|CUR
operator|.
name|GS
operator|.
name|rp2
index|]
argument_list|,
name|cur_base
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|CUR
operator|.
name|GS
operator|.
name|loop
operator|>
literal|0
condition|;
operator|--
name|CUR
operator|.
name|GS
operator|.
name|loop
control|)
block|{
name|FT_UInt
name|point
init|=
operator|(
name|FT_UInt
operator|)
name|CUR
operator|.
name|stack
index|[
operator|--
name|CUR
operator|.
name|args
index|]
decl_stmt|;
name|FT_F26Dot6
name|org_dist
decl_stmt|,
name|cur_dist
decl_stmt|,
name|new_dist
decl_stmt|;
comment|/* check point bounds */
if|if
condition|(
name|BOUNDS
argument_list|(
name|point
argument_list|,
name|CUR
operator|.
name|zp2
operator|.
name|n_points
argument_list|)
condition|)
block|{
if|if
condition|(
name|CUR
operator|.
name|pedantic_hinting
condition|)
block|{
name|CUR
operator|.
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Reference
argument_list|)
expr_stmt|;
return|return;
block|}
continue|continue;
block|}
if|if
condition|(
name|twilight
condition|)
name|org_dist
operator|=
name|CUR_Func_dualproj
argument_list|(
operator|&
name|CUR
operator|.
name|zp2
operator|.
name|org
index|[
name|point
index|]
argument_list|,
name|orus_base
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CUR
operator|.
name|metrics
operator|.
name|x_scale
operator|==
name|CUR
operator|.
name|metrics
operator|.
name|y_scale
condition|)
name|org_dist
operator|=
name|CUR_Func_dualproj
argument_list|(
operator|&
name|CUR
operator|.
name|zp2
operator|.
name|orus
index|[
name|point
index|]
argument_list|,
name|orus_base
argument_list|)
expr_stmt|;
else|else
block|{
name|FT_Vector
name|vec
decl_stmt|;
name|vec
operator|.
name|x
operator|=
name|FT_MulFix
argument_list|(
name|CUR
operator|.
name|zp2
operator|.
name|orus
index|[
name|point
index|]
operator|.
name|x
operator|-
name|orus_base
operator|->
name|x
argument_list|,
name|CUR
operator|.
name|metrics
operator|.
name|x_scale
argument_list|)
expr_stmt|;
name|vec
operator|.
name|y
operator|=
name|FT_MulFix
argument_list|(
name|CUR
operator|.
name|zp2
operator|.
name|orus
index|[
name|point
index|]
operator|.
name|y
operator|-
name|orus_base
operator|->
name|y
argument_list|,
name|CUR
operator|.
name|metrics
operator|.
name|y_scale
argument_list|)
expr_stmt|;
name|org_dist
operator|=
name|CUR_fast_dualproj
argument_list|(
operator|&
name|vec
argument_list|)
expr_stmt|;
block|}
name|cur_dist
operator|=
name|CUR_Func_project
argument_list|(
operator|&
name|CUR
operator|.
name|zp2
operator|.
name|cur
index|[
name|point
index|]
argument_list|,
name|cur_base
argument_list|)
expr_stmt|;
if|if
condition|(
name|org_dist
condition|)
block|{
if|if
condition|(
name|old_range
condition|)
name|new_dist
operator|=
name|FT_MulDiv
argument_list|(
name|org_dist
argument_list|,
name|cur_range
argument_list|,
name|old_range
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* This is the same as what MS does for the invalid case:  */
comment|/*                                                         */
comment|/*   delta = (Original_Pt - Original_RP1) -                */
comment|/*           (Current_Pt - Current_RP1)         ;          */
comment|/*                                                         */
comment|/* In FreeType speak:                                      */
comment|/*                                                         */
comment|/*   delta = org_dist - cur_dist          .                */
comment|/*                                                         */
comment|/* We move `point' by `new_dist - cur_dist' after leaving  */
comment|/* this block, thus we have                                */
comment|/*                                                         */
comment|/*   new_dist - cur_dist = delta                   ,       */
comment|/*   new_dist - cur_dist = org_dist - cur_dist     ,       */
comment|/*              new_dist = org_dist                .       */
name|new_dist
operator|=
name|org_dist
expr_stmt|;
block|}
block|}
else|else
name|new_dist
operator|=
literal|0
expr_stmt|;
name|CUR_Func_move
argument_list|(
operator|&
name|CUR
operator|.
name|zp2
argument_list|,
operator|(
name|FT_UShort
operator|)
name|point
argument_list|,
name|new_dist
operator|-
name|cur_dist
argument_list|)
expr_stmt|;
block|}
name|Fail
label|:
name|CUR
operator|.
name|GS
operator|.
name|loop
operator|=
literal|1
expr_stmt|;
name|CUR
operator|.
name|new_top
operator|=
name|CUR
operator|.
name|args
expr_stmt|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* UTP[a]:       UnTouch Point                                           */
end_comment
begin_comment
comment|/* Opcode range: 0x29                                                    */
end_comment
begin_comment
comment|/* Stack:        uint32 -->                                              */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_UTP
name|Ins_UTP
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|FT_UShort
name|point
decl_stmt|;
name|FT_Byte
name|mask
decl_stmt|;
name|point
operator|=
operator|(
name|FT_UShort
operator|)
name|args
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|BOUNDS
argument_list|(
name|point
argument_list|,
name|CUR
operator|.
name|zp0
operator|.
name|n_points
argument_list|)
condition|)
block|{
if|if
condition|(
name|CUR
operator|.
name|pedantic_hinting
condition|)
name|CUR
operator|.
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Reference
argument_list|)
expr_stmt|;
return|return;
block|}
name|mask
operator|=
literal|0xFF
expr_stmt|;
if|if
condition|(
name|CUR
operator|.
name|GS
operator|.
name|freeVector
operator|.
name|x
operator|!=
literal|0
condition|)
name|mask
operator|&=
operator|~
name|FT_CURVE_TAG_TOUCH_X
expr_stmt|;
if|if
condition|(
name|CUR
operator|.
name|GS
operator|.
name|freeVector
operator|.
name|y
operator|!=
literal|0
condition|)
name|mask
operator|&=
operator|~
name|FT_CURVE_TAG_TOUCH_Y
expr_stmt|;
name|CUR
operator|.
name|zp0
operator|.
name|tags
index|[
name|point
index|]
operator|&=
name|mask
expr_stmt|;
block|}
end_function
begin_comment
comment|/* Local variables for Ins_IUP: */
end_comment
begin_typedef
DECL|struct|IUP_WorkerRec_
typedef|typedef
struct|struct
name|IUP_WorkerRec_
block|{
DECL|member|orgs
name|FT_Vector
modifier|*
name|orgs
decl_stmt|;
comment|/* original and current coordinate */
DECL|member|curs
name|FT_Vector
modifier|*
name|curs
decl_stmt|;
comment|/* arrays                          */
DECL|member|orus
name|FT_Vector
modifier|*
name|orus
decl_stmt|;
DECL|member|max_points
name|FT_UInt
name|max_points
decl_stmt|;
block|}
DECL|typedef|IUP_WorkerRec
DECL|typedef|IUP_Worker
name|IUP_WorkerRec
operator|,
typedef|*
name|IUP_Worker
typedef|;
end_typedef
begin_function
specifier|static
name|void
DECL|function|_iup_worker_shift
name|_iup_worker_shift
parameter_list|(
name|IUP_Worker
name|worker
parameter_list|,
name|FT_UInt
name|p1
parameter_list|,
name|FT_UInt
name|p2
parameter_list|,
name|FT_UInt
name|p
parameter_list|)
block|{
name|FT_UInt
name|i
decl_stmt|;
name|FT_F26Dot6
name|dx
decl_stmt|;
name|dx
operator|=
name|worker
operator|->
name|curs
index|[
name|p
index|]
operator|.
name|x
operator|-
name|worker
operator|->
name|orgs
index|[
name|p
index|]
operator|.
name|x
expr_stmt|;
if|if
condition|(
name|dx
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
name|p1
init|;
name|i
operator|<
name|p
condition|;
name|i
operator|++
control|)
name|worker
operator|->
name|curs
index|[
name|i
index|]
operator|.
name|x
operator|+=
name|dx
expr_stmt|;
for|for
control|(
name|i
operator|=
name|p
operator|+
literal|1
init|;
name|i
operator|<=
name|p2
condition|;
name|i
operator|++
control|)
name|worker
operator|->
name|curs
index|[
name|i
index|]
operator|.
name|x
operator|+=
name|dx
expr_stmt|;
block|}
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|_iup_worker_interpolate
name|_iup_worker_interpolate
parameter_list|(
name|IUP_Worker
name|worker
parameter_list|,
name|FT_UInt
name|p1
parameter_list|,
name|FT_UInt
name|p2
parameter_list|,
name|FT_UInt
name|ref1
parameter_list|,
name|FT_UInt
name|ref2
parameter_list|)
block|{
name|FT_UInt
name|i
decl_stmt|;
name|FT_F26Dot6
name|orus1
decl_stmt|,
name|orus2
decl_stmt|,
name|org1
decl_stmt|,
name|org2
decl_stmt|,
name|delta1
decl_stmt|,
name|delta2
decl_stmt|;
if|if
condition|(
name|p1
operator|>
name|p2
condition|)
return|return;
if|if
condition|(
name|BOUNDS
argument_list|(
name|ref1
argument_list|,
name|worker
operator|->
name|max_points
argument_list|)
operator|||
name|BOUNDS
argument_list|(
name|ref2
argument_list|,
name|worker
operator|->
name|max_points
argument_list|)
condition|)
return|return;
name|orus1
operator|=
name|worker
operator|->
name|orus
index|[
name|ref1
index|]
operator|.
name|x
expr_stmt|;
name|orus2
operator|=
name|worker
operator|->
name|orus
index|[
name|ref2
index|]
operator|.
name|x
expr_stmt|;
if|if
condition|(
name|orus1
operator|>
name|orus2
condition|)
block|{
name|FT_F26Dot6
name|tmp_o
decl_stmt|;
name|FT_UInt
name|tmp_r
decl_stmt|;
name|tmp_o
operator|=
name|orus1
expr_stmt|;
name|orus1
operator|=
name|orus2
expr_stmt|;
name|orus2
operator|=
name|tmp_o
expr_stmt|;
name|tmp_r
operator|=
name|ref1
expr_stmt|;
name|ref1
operator|=
name|ref2
expr_stmt|;
name|ref2
operator|=
name|tmp_r
expr_stmt|;
block|}
name|org1
operator|=
name|worker
operator|->
name|orgs
index|[
name|ref1
index|]
operator|.
name|x
expr_stmt|;
name|org2
operator|=
name|worker
operator|->
name|orgs
index|[
name|ref2
index|]
operator|.
name|x
expr_stmt|;
name|delta1
operator|=
name|worker
operator|->
name|curs
index|[
name|ref1
index|]
operator|.
name|x
operator|-
name|org1
expr_stmt|;
name|delta2
operator|=
name|worker
operator|->
name|curs
index|[
name|ref2
index|]
operator|.
name|x
operator|-
name|org2
expr_stmt|;
if|if
condition|(
name|orus1
operator|==
name|orus2
condition|)
block|{
comment|/* simple shift of untouched points */
for|for
control|(
name|i
operator|=
name|p1
init|;
name|i
operator|<=
name|p2
condition|;
name|i
operator|++
control|)
block|{
name|FT_F26Dot6
name|x
init|=
name|worker
operator|->
name|orgs
index|[
name|i
index|]
operator|.
name|x
decl_stmt|;
if|if
condition|(
name|x
operator|<=
name|org1
condition|)
name|x
operator|+=
name|delta1
expr_stmt|;
else|else
name|x
operator|+=
name|delta2
expr_stmt|;
name|worker
operator|->
name|curs
index|[
name|i
index|]
operator|.
name|x
operator|=
name|x
expr_stmt|;
block|}
block|}
else|else
block|{
name|FT_Fixed
name|scale
init|=
literal|0
decl_stmt|;
name|FT_Bool
name|scale_valid
init|=
literal|0
decl_stmt|;
comment|/* interpolation */
for|for
control|(
name|i
operator|=
name|p1
init|;
name|i
operator|<=
name|p2
condition|;
name|i
operator|++
control|)
block|{
name|FT_F26Dot6
name|x
init|=
name|worker
operator|->
name|orgs
index|[
name|i
index|]
operator|.
name|x
decl_stmt|;
if|if
condition|(
name|x
operator|<=
name|org1
condition|)
name|x
operator|+=
name|delta1
expr_stmt|;
elseif|else
if|if
condition|(
name|x
operator|>=
name|org2
condition|)
name|x
operator|+=
name|delta2
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|scale_valid
condition|)
block|{
name|scale_valid
operator|=
literal|1
expr_stmt|;
name|scale
operator|=
name|FT_DivFix
argument_list|(
name|org2
operator|+
name|delta2
operator|-
operator|(
name|org1
operator|+
name|delta1
operator|)
argument_list|,
name|orus2
operator|-
name|orus1
argument_list|)
expr_stmt|;
block|}
name|x
operator|=
operator|(
name|org1
operator|+
name|delta1
operator|)
operator|+
name|FT_MulFix
argument_list|(
name|worker
operator|->
name|orus
index|[
name|i
index|]
operator|.
name|x
operator|-
name|orus1
argument_list|,
name|scale
argument_list|)
expr_stmt|;
block|}
name|worker
operator|->
name|curs
index|[
name|i
index|]
operator|.
name|x
operator|=
name|x
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* IUP[a]:       Interpolate Untouched Points                            */
end_comment
begin_comment
comment|/* Opcode range: 0x30-0x31                                               */
end_comment
begin_comment
comment|/* Stack:        -->                                                     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_IUP
name|Ins_IUP
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|IUP_WorkerRec
name|V
decl_stmt|;
name|FT_Byte
name|mask
decl_stmt|;
name|FT_UInt
name|first_point
decl_stmt|;
comment|/* first point of contour        */
name|FT_UInt
name|end_point
decl_stmt|;
comment|/* end point (last+1) of contour */
name|FT_UInt
name|first_touched
decl_stmt|;
comment|/* first touched point in contour   */
name|FT_UInt
name|cur_touched
decl_stmt|;
comment|/* current touched point in contour */
name|FT_UInt
name|point
decl_stmt|;
comment|/* current point   */
name|FT_Short
name|contour
decl_stmt|;
comment|/* current contour */
name|FT_UNUSED_ARG
expr_stmt|;
comment|/* ignore empty outlines */
if|if
condition|(
name|CUR
operator|.
name|pts
operator|.
name|n_contours
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|CUR
operator|.
name|opcode
operator|&
literal|1
condition|)
block|{
name|mask
operator|=
name|FT_CURVE_TAG_TOUCH_X
expr_stmt|;
name|V
operator|.
name|orgs
operator|=
name|CUR
operator|.
name|pts
operator|.
name|org
expr_stmt|;
name|V
operator|.
name|curs
operator|=
name|CUR
operator|.
name|pts
operator|.
name|cur
expr_stmt|;
name|V
operator|.
name|orus
operator|=
name|CUR
operator|.
name|pts
operator|.
name|orus
expr_stmt|;
block|}
else|else
block|{
name|mask
operator|=
name|FT_CURVE_TAG_TOUCH_Y
expr_stmt|;
name|V
operator|.
name|orgs
operator|=
operator|(
name|FT_Vector
operator|*
operator|)
operator|(
operator|(
name|FT_Pos
operator|*
operator|)
name|CUR
operator|.
name|pts
operator|.
name|org
operator|+
literal|1
operator|)
expr_stmt|;
name|V
operator|.
name|curs
operator|=
operator|(
name|FT_Vector
operator|*
operator|)
operator|(
operator|(
name|FT_Pos
operator|*
operator|)
name|CUR
operator|.
name|pts
operator|.
name|cur
operator|+
literal|1
operator|)
expr_stmt|;
name|V
operator|.
name|orus
operator|=
operator|(
name|FT_Vector
operator|*
operator|)
operator|(
operator|(
name|FT_Pos
operator|*
operator|)
name|CUR
operator|.
name|pts
operator|.
name|orus
operator|+
literal|1
operator|)
expr_stmt|;
block|}
name|V
operator|.
name|max_points
operator|=
name|CUR
operator|.
name|pts
operator|.
name|n_points
expr_stmt|;
name|contour
operator|=
literal|0
expr_stmt|;
name|point
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_SUBPIXEL_HINTING
if|if
condition|(
name|SUBPIXEL_HINTING
operator|&&
name|CUR
operator|.
name|ignore_x_mode
condition|)
block|{
name|CUR
operator|.
name|iup_called
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|CUR
operator|.
name|sph_tweak_flags
operator|&
name|SPH_TWEAK_SKIP_IUP
condition|)
return|return;
block|}
endif|#
directive|endif
comment|/* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
do|do
block|{
name|end_point
operator|=
name|CUR
operator|.
name|pts
operator|.
name|contours
index|[
name|contour
index|]
operator|-
name|CUR
operator|.
name|pts
operator|.
name|first_point
expr_stmt|;
name|first_point
operator|=
name|point
expr_stmt|;
if|if
condition|(
name|BOUNDS
argument_list|(
name|end_point
argument_list|,
name|CUR
operator|.
name|pts
operator|.
name|n_points
argument_list|)
condition|)
name|end_point
operator|=
name|CUR
operator|.
name|pts
operator|.
name|n_points
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|point
operator|<=
name|end_point
operator|&&
operator|(
name|CUR
operator|.
name|pts
operator|.
name|tags
index|[
name|point
index|]
operator|&
name|mask
operator|)
operator|==
literal|0
condition|)
name|point
operator|++
expr_stmt|;
if|if
condition|(
name|point
operator|<=
name|end_point
condition|)
block|{
name|first_touched
operator|=
name|point
expr_stmt|;
name|cur_touched
operator|=
name|point
expr_stmt|;
name|point
operator|++
expr_stmt|;
while|while
condition|(
name|point
operator|<=
name|end_point
condition|)
block|{
if|if
condition|(
operator|(
name|CUR
operator|.
name|pts
operator|.
name|tags
index|[
name|point
index|]
operator|&
name|mask
operator|)
operator|!=
literal|0
condition|)
block|{
name|_iup_worker_interpolate
argument_list|(
operator|&
name|V
argument_list|,
name|cur_touched
operator|+
literal|1
argument_list|,
name|point
operator|-
literal|1
argument_list|,
name|cur_touched
argument_list|,
name|point
argument_list|)
expr_stmt|;
name|cur_touched
operator|=
name|point
expr_stmt|;
block|}
name|point
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|cur_touched
operator|==
name|first_touched
condition|)
name|_iup_worker_shift
argument_list|(
operator|&
name|V
argument_list|,
name|first_point
argument_list|,
name|end_point
argument_list|,
name|cur_touched
argument_list|)
expr_stmt|;
else|else
block|{
name|_iup_worker_interpolate
argument_list|(
operator|&
name|V
argument_list|,
call|(
name|FT_UShort
call|)
argument_list|(
name|cur_touched
operator|+
literal|1
argument_list|)
argument_list|,
name|end_point
argument_list|,
name|cur_touched
argument_list|,
name|first_touched
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_touched
operator|>
literal|0
condition|)
name|_iup_worker_interpolate
argument_list|(
operator|&
name|V
argument_list|,
name|first_point
argument_list|,
name|first_touched
operator|-
literal|1
argument_list|,
name|cur_touched
argument_list|,
name|first_touched
argument_list|)
expr_stmt|;
block|}
block|}
name|contour
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|contour
operator|<
name|CUR
operator|.
name|pts
operator|.
name|n_contours
condition|)
do|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* DELTAPn[]:    DELTA exceptions P1, P2, P3                             */
end_comment
begin_comment
comment|/* Opcode range: 0x5D,0x71,0x72                                          */
end_comment
begin_comment
comment|/* Stack:        uint32 (2 * uint32)... -->                              */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_DELTAP
name|Ins_DELTAP
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|FT_ULong
name|nump
decl_stmt|,
name|k
decl_stmt|;
name|FT_UShort
name|A
decl_stmt|;
name|FT_ULong
name|C
decl_stmt|,
name|P
decl_stmt|;
name|FT_Long
name|B
decl_stmt|;
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_SUBPIXEL_HINTING
name|FT_UShort
name|B1
decl_stmt|,
name|B2
decl_stmt|;
if|if
condition|(
name|SUBPIXEL_HINTING
operator|&&
name|CUR
operator|.
name|ignore_x_mode
operator|&&
name|CUR
operator|.
name|iup_called
operator|&&
operator|(
name|CUR
operator|.
name|sph_tweak_flags
operator|&
name|SPH_TWEAK_NO_DELTAP_AFTER_IUP
operator|)
condition|)
goto|goto
name|Fail
goto|;
endif|#
directive|endif
comment|/* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_UNPATENTED_HINTING
comment|/* Delta hinting is covered by US Patent 5159668. */
if|if
condition|(
name|CUR
operator|.
name|face
operator|->
name|unpatented_hinting
condition|)
block|{
name|FT_Long
name|n
init|=
name|args
index|[
literal|0
index|]
operator|*
literal|2
decl_stmt|;
if|if
condition|(
name|CUR
operator|.
name|args
operator|<
name|n
condition|)
block|{
if|if
condition|(
name|CUR
operator|.
name|pedantic_hinting
condition|)
name|CUR
operator|.
name|error
operator|=
name|FT_THROW
argument_list|(
name|Too_Few_Arguments
argument_list|)
expr_stmt|;
name|n
operator|=
name|CUR
operator|.
name|args
expr_stmt|;
block|}
name|CUR
operator|.
name|args
operator|-=
name|n
expr_stmt|;
name|CUR
operator|.
name|new_top
operator|=
name|CUR
operator|.
name|args
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|P
operator|=
operator|(
name|FT_ULong
operator|)
name|CUR_Func_cur_ppem
argument_list|()
expr_stmt|;
name|nump
operator|=
operator|(
name|FT_ULong
operator|)
name|args
index|[
literal|0
index|]
expr_stmt|;
comment|/* some points theoretically may occur more                                    than once, thus UShort isn't enough */
for|for
control|(
name|k
operator|=
literal|1
init|;
name|k
operator|<=
name|nump
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|CUR
operator|.
name|args
operator|<
literal|2
condition|)
block|{
if|if
condition|(
name|CUR
operator|.
name|pedantic_hinting
condition|)
name|CUR
operator|.
name|error
operator|=
name|FT_THROW
argument_list|(
name|Too_Few_Arguments
argument_list|)
expr_stmt|;
name|CUR
operator|.
name|args
operator|=
literal|0
expr_stmt|;
goto|goto
name|Fail
goto|;
block|}
name|CUR
operator|.
name|args
operator|-=
literal|2
expr_stmt|;
name|A
operator|=
operator|(
name|FT_UShort
operator|)
name|CUR
operator|.
name|stack
index|[
name|CUR
operator|.
name|args
operator|+
literal|1
index|]
expr_stmt|;
name|B
operator|=
name|CUR
operator|.
name|stack
index|[
name|CUR
operator|.
name|args
index|]
expr_stmt|;
comment|/* XXX: Because some popular fonts contain some invalid DeltaP */
comment|/*      instructions, we simply ignore them when the stacked   */
comment|/*      point reference is off limit, rather than returning an */
comment|/*      error.  As a delta instruction doesn't change a glyph  */
comment|/*      in great ways, this shouldn't be a problem.            */
if|if
condition|(
operator|!
name|BOUNDS
argument_list|(
name|A
argument_list|,
name|CUR
operator|.
name|zp0
operator|.
name|n_points
argument_list|)
condition|)
block|{
name|C
operator|=
operator|(
operator|(
name|FT_ULong
operator|)
name|B
operator|&
literal|0xF0
operator|)
operator|>>
literal|4
expr_stmt|;
switch|switch
condition|(
name|CUR
operator|.
name|opcode
condition|)
block|{
case|case
literal|0x5D
case|:
break|break;
case|case
literal|0x71
case|:
name|C
operator|+=
literal|16
expr_stmt|;
break|break;
case|case
literal|0x72
case|:
name|C
operator|+=
literal|32
expr_stmt|;
break|break;
block|}
name|C
operator|+=
name|CUR
operator|.
name|GS
operator|.
name|delta_base
expr_stmt|;
if|if
condition|(
name|P
operator|==
name|C
condition|)
block|{
name|B
operator|=
operator|(
operator|(
name|FT_ULong
operator|)
name|B
operator|&
literal|0xF
operator|)
operator|-
literal|8
expr_stmt|;
if|if
condition|(
name|B
operator|>=
literal|0
condition|)
name|B
operator|++
expr_stmt|;
name|B
operator|*=
literal|1L
operator|<<
operator|(
literal|6
operator|-
name|CUR
operator|.
name|GS
operator|.
name|delta_shift
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_SUBPIXEL_HINTING
if|if
condition|(
name|SUBPIXEL_HINTING
condition|)
block|{
comment|/*              *  Allow delta move if              *              *  - not using ignore_x_mode rendering,              *  - glyph is specifically set to allow it, or              *  - glyph is composite and freedom vector is not in subpixel              *    direction.              */
if|if
condition|(
operator|!
name|CUR
operator|.
name|ignore_x_mode
operator|||
operator|(
name|CUR
operator|.
name|sph_tweak_flags
operator|&
name|SPH_TWEAK_ALWAYS_DO_DELTAP
operator|)
operator|||
operator|(
name|CUR
operator|.
name|is_composite
operator|&&
name|CUR
operator|.
name|GS
operator|.
name|freeVector
operator|.
name|y
operator|!=
literal|0
operator|)
condition|)
name|CUR_Func_move
argument_list|(
operator|&
name|CUR
operator|.
name|zp0
argument_list|,
name|A
argument_list|,
name|B
argument_list|)
expr_stmt|;
comment|/* Otherwise, apply subpixel hinting and compatibility mode */
comment|/* rules, always skipping deltas in subpixel direction.     */
elseif|else
if|if
condition|(
name|CUR
operator|.
name|ignore_x_mode
operator|&&
name|CUR
operator|.
name|GS
operator|.
name|freeVector
operator|.
name|y
operator|!=
literal|0
condition|)
block|{
comment|/* save the y value of the point now; compare after move */
name|B1
operator|=
operator|(
name|FT_UShort
operator|)
name|CUR
operator|.
name|zp0
operator|.
name|cur
index|[
name|A
index|]
operator|.
name|y
expr_stmt|;
comment|/* Standard subpixel hinting: Allow y move for y-touched */
comment|/* points.  This messes up DejaVu ...                    */
if|if
condition|(
operator|!
name|CUR
operator|.
name|face
operator|->
name|sph_compatibility_mode
operator|&&
operator|(
name|CUR
operator|.
name|zp0
operator|.
name|tags
index|[
name|A
index|]
operator|&
name|FT_CURVE_TAG_TOUCH_Y
operator|)
condition|)
name|CUR_Func_move
argument_list|(
operator|&
name|CUR
operator|.
name|zp0
argument_list|,
name|A
argument_list|,
name|B
argument_list|)
expr_stmt|;
comment|/* compatibility mode */
elseif|else
if|if
condition|(
name|CUR
operator|.
name|face
operator|->
name|sph_compatibility_mode
operator|&&
operator|!
operator|(
name|CUR
operator|.
name|sph_tweak_flags
operator|&
name|SPH_TWEAK_ALWAYS_SKIP_DELTAP
operator|)
condition|)
block|{
if|if
condition|(
name|CUR
operator|.
name|sph_tweak_flags
operator|&
name|SPH_TWEAK_ROUND_NONPIXEL_Y_MOVES
condition|)
name|B
operator|=
name|FT_PIX_ROUND
argument_list|(
name|B1
operator|+
name|B
argument_list|)
operator|-
name|B1
expr_stmt|;
comment|/* Allow delta move if using sph_compatibility_mode,   */
comment|/* IUP has not been called, and point is touched on Y. */
if|if
condition|(
operator|!
name|CUR
operator|.
name|iup_called
operator|&&
operator|(
name|CUR
operator|.
name|zp0
operator|.
name|tags
index|[
name|A
index|]
operator|&
name|FT_CURVE_TAG_TOUCH_Y
operator|)
condition|)
name|CUR_Func_move
argument_list|(
operator|&
name|CUR
operator|.
name|zp0
argument_list|,
name|A
argument_list|,
name|B
argument_list|)
expr_stmt|;
block|}
name|B2
operator|=
operator|(
name|FT_UShort
operator|)
name|CUR
operator|.
name|zp0
operator|.
name|cur
index|[
name|A
index|]
operator|.
name|y
expr_stmt|;
comment|/* Reverse this move if it results in a disallowed move */
if|if
condition|(
name|CUR
operator|.
name|GS
operator|.
name|freeVector
operator|.
name|y
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|CUR
operator|.
name|face
operator|->
name|sph_compatibility_mode
operator|&&
operator|(
name|B1
operator|&
literal|63
operator|)
operator|==
literal|0
operator|&&
operator|(
name|B2
operator|&
literal|63
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
name|CUR
operator|.
name|sph_tweak_flags
operator|&
name|SPH_TWEAK_SKIP_NONPIXEL_Y_MOVES_DELTAP
operator|)
operator|&&
operator|(
name|B1
operator|&
literal|63
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|B2
operator|&
literal|63
operator|)
operator|!=
literal|0
operator|)
operator|)
condition|)
name|CUR_Func_move
argument_list|(
operator|&
name|CUR
operator|.
name|zp0
argument_list|,
name|A
argument_list|,
operator|-
name|B
argument_list|)
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
comment|/* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
name|CUR_Func_move
argument_list|(
operator|&
name|CUR
operator|.
name|zp0
argument_list|,
name|A
argument_list|,
name|B
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|CUR
operator|.
name|pedantic_hinting
condition|)
name|CUR
operator|.
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Reference
argument_list|)
expr_stmt|;
block|}
name|Fail
label|:
name|CUR
operator|.
name|new_top
operator|=
name|CUR
operator|.
name|args
expr_stmt|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* DELTACn[]:    DELTA exceptions C1, C2, C3                             */
end_comment
begin_comment
comment|/* Opcode range: 0x73,0x74,0x75                                          */
end_comment
begin_comment
comment|/* Stack:        uint32 (2 * uint32)... -->                              */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_DELTAC
name|Ins_DELTAC
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|FT_ULong
name|nump
decl_stmt|,
name|k
decl_stmt|;
name|FT_ULong
name|A
decl_stmt|,
name|C
decl_stmt|,
name|P
decl_stmt|;
name|FT_Long
name|B
decl_stmt|;
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_UNPATENTED_HINTING
comment|/* Delta hinting is covered by US Patent 5159668. */
if|if
condition|(
name|CUR
operator|.
name|face
operator|->
name|unpatented_hinting
condition|)
block|{
name|FT_Long
name|n
init|=
name|args
index|[
literal|0
index|]
operator|*
literal|2
decl_stmt|;
if|if
condition|(
name|CUR
operator|.
name|args
operator|<
name|n
condition|)
block|{
if|if
condition|(
name|CUR
operator|.
name|pedantic_hinting
condition|)
name|CUR
operator|.
name|error
operator|=
name|FT_THROW
argument_list|(
name|Too_Few_Arguments
argument_list|)
expr_stmt|;
name|n
operator|=
name|CUR
operator|.
name|args
expr_stmt|;
block|}
name|CUR
operator|.
name|args
operator|-=
name|n
expr_stmt|;
name|CUR
operator|.
name|new_top
operator|=
name|CUR
operator|.
name|args
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|P
operator|=
operator|(
name|FT_ULong
operator|)
name|CUR_Func_cur_ppem
argument_list|()
expr_stmt|;
name|nump
operator|=
operator|(
name|FT_ULong
operator|)
name|args
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|1
init|;
name|k
operator|<=
name|nump
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|CUR
operator|.
name|args
operator|<
literal|2
condition|)
block|{
if|if
condition|(
name|CUR
operator|.
name|pedantic_hinting
condition|)
name|CUR
operator|.
name|error
operator|=
name|FT_THROW
argument_list|(
name|Too_Few_Arguments
argument_list|)
expr_stmt|;
name|CUR
operator|.
name|args
operator|=
literal|0
expr_stmt|;
goto|goto
name|Fail
goto|;
block|}
name|CUR
operator|.
name|args
operator|-=
literal|2
expr_stmt|;
name|A
operator|=
operator|(
name|FT_ULong
operator|)
name|CUR
operator|.
name|stack
index|[
name|CUR
operator|.
name|args
operator|+
literal|1
index|]
expr_stmt|;
name|B
operator|=
name|CUR
operator|.
name|stack
index|[
name|CUR
operator|.
name|args
index|]
expr_stmt|;
if|if
condition|(
name|BOUNDSL
argument_list|(
name|A
argument_list|,
name|CUR
operator|.
name|cvtSize
argument_list|)
condition|)
block|{
if|if
condition|(
name|CUR
operator|.
name|pedantic_hinting
condition|)
block|{
name|CUR
operator|.
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Reference
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|C
operator|=
operator|(
operator|(
name|FT_ULong
operator|)
name|B
operator|&
literal|0xF0
operator|)
operator|>>
literal|4
expr_stmt|;
switch|switch
condition|(
name|CUR
operator|.
name|opcode
condition|)
block|{
case|case
literal|0x73
case|:
break|break;
case|case
literal|0x74
case|:
name|C
operator|+=
literal|16
expr_stmt|;
break|break;
case|case
literal|0x75
case|:
name|C
operator|+=
literal|32
expr_stmt|;
break|break;
block|}
name|C
operator|+=
name|CUR
operator|.
name|GS
operator|.
name|delta_base
expr_stmt|;
if|if
condition|(
name|P
operator|==
name|C
condition|)
block|{
name|B
operator|=
operator|(
operator|(
name|FT_ULong
operator|)
name|B
operator|&
literal|0xF
operator|)
operator|-
literal|8
expr_stmt|;
if|if
condition|(
name|B
operator|>=
literal|0
condition|)
name|B
operator|++
expr_stmt|;
name|B
operator|*=
literal|1L
operator|<<
operator|(
literal|6
operator|-
name|CUR
operator|.
name|GS
operator|.
name|delta_shift
operator|)
expr_stmt|;
name|CUR_Func_move_cvt
argument_list|(
name|A
argument_list|,
name|B
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|Fail
label|:
name|CUR
operator|.
name|new_top
operator|=
name|CUR
operator|.
name|args
expr_stmt|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* MISC. INSTRUCTIONS                                                    */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* GETINFO[]:    GET INFOrmation                                         */
end_comment
begin_comment
comment|/* Opcode range: 0x88                                                    */
end_comment
begin_comment
comment|/* Stack:        uint32 --> uint32                                       */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Ins_GETINFO
name|Ins_GETINFO
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|FT_Long
name|K
decl_stmt|;
name|K
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_SUBPIXEL_HINTING
comment|/********************************/
comment|/* RASTERIZER VERSION           */
comment|/* Selector Bit:  0             */
comment|/* Return Bit(s): 0-7           */
comment|/*                              */
if|if
condition|(
name|SUBPIXEL_HINTING
operator|&&
operator|(
name|args
index|[
literal|0
index|]
operator|&
literal|1
operator|)
operator|!=
literal|0
operator|&&
name|CUR
operator|.
name|ignore_x_mode
condition|)
block|{
name|K
operator|=
name|CUR
operator|.
name|rasterizer_version
expr_stmt|;
name|FT_TRACE7
argument_list|(
operator|(
literal|"Setting rasterizer version %d\n"
operator|,
name|CUR
operator|.
name|rasterizer_version
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
comment|/* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
if|if
condition|(
operator|(
name|args
index|[
literal|0
index|]
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|K
operator|=
name|TT_INTERPRETER_VERSION_35
expr_stmt|;
comment|/********************************/
comment|/* GLYPH ROTATED                */
comment|/* Selector Bit:  1             */
comment|/* Return Bit(s): 8             */
comment|/*                              */
if|if
condition|(
operator|(
name|args
index|[
literal|0
index|]
operator|&
literal|2
operator|)
operator|!=
literal|0
operator|&&
name|CUR
operator|.
name|tt_metrics
operator|.
name|rotated
condition|)
name|K
operator||=
literal|0x80
expr_stmt|;
comment|/********************************/
comment|/* GLYPH STRETCHED              */
comment|/* Selector Bit:  2             */
comment|/* Return Bit(s): 9             */
comment|/*                              */
if|if
condition|(
operator|(
name|args
index|[
literal|0
index|]
operator|&
literal|4
operator|)
operator|!=
literal|0
operator|&&
name|CUR
operator|.
name|tt_metrics
operator|.
name|stretched
condition|)
name|K
operator||=
literal|1
operator|<<
literal|8
expr_stmt|;
comment|/********************************/
comment|/* HINTING FOR GRAYSCALE        */
comment|/* Selector Bit:  5             */
comment|/* Return Bit(s): 12            */
comment|/*                              */
if|if
condition|(
operator|(
name|args
index|[
literal|0
index|]
operator|&
literal|32
operator|)
operator|!=
literal|0
operator|&&
name|CUR
operator|.
name|grayscale
condition|)
name|K
operator||=
literal|1
operator|<<
literal|12
expr_stmt|;
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_SUBPIXEL_HINTING
if|if
condition|(
name|SUBPIXEL_HINTING
operator|&&
name|CUR
operator|.
name|ignore_x_mode
operator|&&
name|CUR
operator|.
name|rasterizer_version
operator|>=
name|TT_INTERPRETER_VERSION_35
condition|)
block|{
if|if
condition|(
name|CUR
operator|.
name|rasterizer_version
operator|>=
literal|37
condition|)
block|{
comment|/********************************/
comment|/* HINTING FOR SUBPIXEL         */
comment|/* Selector Bit:  6             */
comment|/* Return Bit(s): 13            */
comment|/*                              */
if|if
condition|(
operator|(
name|args
index|[
literal|0
index|]
operator|&
literal|64
operator|)
operator|!=
literal|0
operator|&&
name|CUR
operator|.
name|subpixel
condition|)
name|K
operator||=
literal|1
operator|<<
literal|13
expr_stmt|;
comment|/********************************/
comment|/* COMPATIBLE WIDTHS ENABLED    */
comment|/* Selector Bit:  7             */
comment|/* Return Bit(s): 14            */
comment|/*                              */
comment|/* Functionality still needs to be added */
if|if
condition|(
operator|(
name|args
index|[
literal|0
index|]
operator|&
literal|128
operator|)
operator|!=
literal|0
operator|&&
name|CUR
operator|.
name|compatible_widths
condition|)
name|K
operator||=
literal|1
operator|<<
literal|14
expr_stmt|;
comment|/********************************/
comment|/* SYMMETRICAL SMOOTHING        */
comment|/* Selector Bit:  8             */
comment|/* Return Bit(s): 15            */
comment|/*                              */
comment|/* Functionality still needs to be added */
if|if
condition|(
operator|(
name|args
index|[
literal|0
index|]
operator|&
literal|256
operator|)
operator|!=
literal|0
operator|&&
name|CUR
operator|.
name|symmetrical_smoothing
condition|)
name|K
operator||=
literal|1
operator|<<
literal|15
expr_stmt|;
comment|/********************************/
comment|/* HINTING FOR BGR?             */
comment|/* Selector Bit:  9             */
comment|/* Return Bit(s): 16            */
comment|/*                              */
comment|/* Functionality still needs to be added */
if|if
condition|(
operator|(
name|args
index|[
literal|0
index|]
operator|&
literal|512
operator|)
operator|!=
literal|0
operator|&&
name|CUR
operator|.
name|bgr
condition|)
name|K
operator||=
literal|1
operator|<<
literal|16
expr_stmt|;
if|if
condition|(
name|CUR
operator|.
name|rasterizer_version
operator|>=
literal|38
condition|)
block|{
comment|/********************************/
comment|/* SUBPIXEL POSITIONED?         */
comment|/* Selector Bit:  10            */
comment|/* Return Bit(s): 17            */
comment|/*                              */
comment|/* Functionality still needs to be added */
if|if
condition|(
operator|(
name|args
index|[
literal|0
index|]
operator|&
literal|1024
operator|)
operator|!=
literal|0
operator|&&
name|CUR
operator|.
name|subpixel_positioned
condition|)
name|K
operator||=
literal|1
operator|<<
literal|17
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
name|args
index|[
literal|0
index|]
operator|=
name|K
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|Ins_UNKNOWN
name|Ins_UNKNOWN
parameter_list|(
name|INS_ARG
parameter_list|)
block|{
name|TT_DefRecord
modifier|*
name|def
init|=
name|CUR
operator|.
name|IDefs
decl_stmt|;
name|TT_DefRecord
modifier|*
name|limit
init|=
name|def
operator|+
name|CUR
operator|.
name|numIDefs
decl_stmt|;
name|FT_UNUSED_ARG
expr_stmt|;
for|for
control|(
init|;
name|def
operator|<
name|limit
condition|;
name|def
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|FT_Byte
operator|)
name|def
operator|->
name|opc
operator|==
name|CUR
operator|.
name|opcode
operator|&&
name|def
operator|->
name|active
condition|)
block|{
name|TT_CallRec
modifier|*
name|call
decl_stmt|;
if|if
condition|(
name|CUR
operator|.
name|callTop
operator|>=
name|CUR
operator|.
name|callSize
condition|)
block|{
name|CUR
operator|.
name|error
operator|=
name|FT_THROW
argument_list|(
name|Stack_Overflow
argument_list|)
expr_stmt|;
return|return;
block|}
name|call
operator|=
name|CUR
operator|.
name|callStack
operator|+
name|CUR
operator|.
name|callTop
operator|++
expr_stmt|;
name|call
operator|->
name|Caller_Range
operator|=
name|CUR
operator|.
name|curRange
expr_stmt|;
name|call
operator|->
name|Caller_IP
operator|=
name|CUR
operator|.
name|IP
operator|+
literal|1
expr_stmt|;
name|call
operator|->
name|Cur_Count
operator|=
literal|1
expr_stmt|;
name|call
operator|->
name|Def
operator|=
name|def
expr_stmt|;
name|INS_Goto_CodeRange
argument_list|(
name|def
operator|->
name|range
argument_list|,
name|def
operator|->
name|start
argument_list|)
expr_stmt|;
name|CUR
operator|.
name|step_ins
operator|=
name|FALSE
expr_stmt|;
return|return;
block|}
block|}
name|CUR
operator|.
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Opcode
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|TT_CONFIG_OPTION_INTERPRETER_SWITCH
end_ifndef
begin_decl_stmt
specifier|static
DECL|variable|Instruct_Dispatch
name|TInstruction_Function
name|Instruct_Dispatch
index|[
literal|256
index|]
init|=
block|{
comment|/* Opcodes are gathered in groups of 16. */
comment|/* Please keep the spaces as they are.   */
comment|/*  SVTCA  y  */
name|Ins_SVTCA
block|,
comment|/*  SVTCA  x  */
name|Ins_SVTCA
block|,
comment|/*  SPvTCA y  */
name|Ins_SPVTCA
block|,
comment|/*  SPvTCA x  */
name|Ins_SPVTCA
block|,
comment|/*  SFvTCA y  */
name|Ins_SFVTCA
block|,
comment|/*  SFvTCA x  */
name|Ins_SFVTCA
block|,
comment|/*  SPvTL //  */
name|Ins_SPVTL
block|,
comment|/*  SPvTL +   */
name|Ins_SPVTL
block|,
comment|/*  SFvTL //  */
name|Ins_SFVTL
block|,
comment|/*  SFvTL +   */
name|Ins_SFVTL
block|,
comment|/*  SPvFS     */
name|Ins_SPVFS
block|,
comment|/*  SFvFS     */
name|Ins_SFVFS
block|,
comment|/*  GPV       */
name|Ins_GPV
block|,
comment|/*  GFV       */
name|Ins_GFV
block|,
comment|/*  SFvTPv    */
name|Ins_SFVTPV
block|,
comment|/*  ISECT     */
name|Ins_ISECT
block|,
comment|/*  SRP0      */
name|Ins_SRP0
block|,
comment|/*  SRP1      */
name|Ins_SRP1
block|,
comment|/*  SRP2      */
name|Ins_SRP2
block|,
comment|/*  SZP0      */
name|Ins_SZP0
block|,
comment|/*  SZP1      */
name|Ins_SZP1
block|,
comment|/*  SZP2      */
name|Ins_SZP2
block|,
comment|/*  SZPS      */
name|Ins_SZPS
block|,
comment|/*  SLOOP     */
name|Ins_SLOOP
block|,
comment|/*  RTG       */
name|Ins_RTG
block|,
comment|/*  RTHG      */
name|Ins_RTHG
block|,
comment|/*  SMD       */
name|Ins_SMD
block|,
comment|/*  ELSE      */
name|Ins_ELSE
block|,
comment|/*  JMPR      */
name|Ins_JMPR
block|,
comment|/*  SCvTCi    */
name|Ins_SCVTCI
block|,
comment|/*  SSwCi     */
name|Ins_SSWCI
block|,
comment|/*  SSW       */
name|Ins_SSW
block|,
comment|/*  DUP       */
name|Ins_DUP
block|,
comment|/*  POP       */
name|Ins_POP
block|,
comment|/*  CLEAR     */
name|Ins_CLEAR
block|,
comment|/*  SWAP      */
name|Ins_SWAP
block|,
comment|/*  DEPTH     */
name|Ins_DEPTH
block|,
comment|/*  CINDEX    */
name|Ins_CINDEX
block|,
comment|/*  MINDEX    */
name|Ins_MINDEX
block|,
comment|/*  AlignPTS  */
name|Ins_ALIGNPTS
block|,
comment|/*  INS_0x28  */
name|Ins_UNKNOWN
block|,
comment|/*  UTP       */
name|Ins_UTP
block|,
comment|/*  LOOPCALL  */
name|Ins_LOOPCALL
block|,
comment|/*  CALL      */
name|Ins_CALL
block|,
comment|/*  FDEF      */
name|Ins_FDEF
block|,
comment|/*  ENDF      */
name|Ins_ENDF
block|,
comment|/*  MDAP[0]   */
name|Ins_MDAP
block|,
comment|/*  MDAP[1]   */
name|Ins_MDAP
block|,
comment|/*  IUP[0]    */
name|Ins_IUP
block|,
comment|/*  IUP[1]    */
name|Ins_IUP
block|,
comment|/*  SHP[0]    */
name|Ins_SHP
block|,
comment|/*  SHP[1]    */
name|Ins_SHP
block|,
comment|/*  SHC[0]    */
name|Ins_SHC
block|,
comment|/*  SHC[1]    */
name|Ins_SHC
block|,
comment|/*  SHZ[0]    */
name|Ins_SHZ
block|,
comment|/*  SHZ[1]    */
name|Ins_SHZ
block|,
comment|/*  SHPIX     */
name|Ins_SHPIX
block|,
comment|/*  IP        */
name|Ins_IP
block|,
comment|/*  MSIRP[0]  */
name|Ins_MSIRP
block|,
comment|/*  MSIRP[1]  */
name|Ins_MSIRP
block|,
comment|/*  AlignRP   */
name|Ins_ALIGNRP
block|,
comment|/*  RTDG      */
name|Ins_RTDG
block|,
comment|/*  MIAP[0]   */
name|Ins_MIAP
block|,
comment|/*  MIAP[1]   */
name|Ins_MIAP
block|,
comment|/*  NPushB    */
name|Ins_NPUSHB
block|,
comment|/*  NPushW    */
name|Ins_NPUSHW
block|,
comment|/*  WS        */
name|Ins_WS
block|,
comment|/*  RS        */
name|Ins_RS
block|,
comment|/*  WCvtP     */
name|Ins_WCVTP
block|,
comment|/*  RCvt      */
name|Ins_RCVT
block|,
comment|/*  GC[0]     */
name|Ins_GC
block|,
comment|/*  GC[1]     */
name|Ins_GC
block|,
comment|/*  SCFS      */
name|Ins_SCFS
block|,
comment|/*  MD[0]     */
name|Ins_MD
block|,
comment|/*  MD[1]     */
name|Ins_MD
block|,
comment|/*  MPPEM     */
name|Ins_MPPEM
block|,
comment|/*  MPS       */
name|Ins_MPS
block|,
comment|/*  FlipON    */
name|Ins_FLIPON
block|,
comment|/*  FlipOFF   */
name|Ins_FLIPOFF
block|,
comment|/*  DEBUG     */
name|Ins_DEBUG
block|,
comment|/*  LT        */
name|Ins_LT
block|,
comment|/*  LTEQ      */
name|Ins_LTEQ
block|,
comment|/*  GT        */
name|Ins_GT
block|,
comment|/*  GTEQ      */
name|Ins_GTEQ
block|,
comment|/*  EQ        */
name|Ins_EQ
block|,
comment|/*  NEQ       */
name|Ins_NEQ
block|,
comment|/*  ODD       */
name|Ins_ODD
block|,
comment|/*  EVEN      */
name|Ins_EVEN
block|,
comment|/*  IF        */
name|Ins_IF
block|,
comment|/*  EIF       */
name|Ins_EIF
block|,
comment|/*  AND       */
name|Ins_AND
block|,
comment|/*  OR        */
name|Ins_OR
block|,
comment|/*  NOT       */
name|Ins_NOT
block|,
comment|/*  DeltaP1   */
name|Ins_DELTAP
block|,
comment|/*  SDB       */
name|Ins_SDB
block|,
comment|/*  SDS       */
name|Ins_SDS
block|,
comment|/*  ADD       */
name|Ins_ADD
block|,
comment|/*  SUB       */
name|Ins_SUB
block|,
comment|/*  DIV       */
name|Ins_DIV
block|,
comment|/*  MUL       */
name|Ins_MUL
block|,
comment|/*  ABS       */
name|Ins_ABS
block|,
comment|/*  NEG       */
name|Ins_NEG
block|,
comment|/*  FLOOR     */
name|Ins_FLOOR
block|,
comment|/*  CEILING   */
name|Ins_CEILING
block|,
comment|/*  ROUND[0]  */
name|Ins_ROUND
block|,
comment|/*  ROUND[1]  */
name|Ins_ROUND
block|,
comment|/*  ROUND[2]  */
name|Ins_ROUND
block|,
comment|/*  ROUND[3]  */
name|Ins_ROUND
block|,
comment|/*  NROUND[0] */
name|Ins_NROUND
block|,
comment|/*  NROUND[1] */
name|Ins_NROUND
block|,
comment|/*  NROUND[2] */
name|Ins_NROUND
block|,
comment|/*  NROUND[3] */
name|Ins_NROUND
block|,
comment|/*  WCvtF     */
name|Ins_WCVTF
block|,
comment|/*  DeltaP2   */
name|Ins_DELTAP
block|,
comment|/*  DeltaP3   */
name|Ins_DELTAP
block|,
comment|/*  DeltaCn[0] */
name|Ins_DELTAC
block|,
comment|/*  DeltaCn[1] */
name|Ins_DELTAC
block|,
comment|/*  DeltaCn[2] */
name|Ins_DELTAC
block|,
comment|/*  SROUND    */
name|Ins_SROUND
block|,
comment|/*  S45Round  */
name|Ins_S45ROUND
block|,
comment|/*  JROT      */
name|Ins_JROT
block|,
comment|/*  JROF      */
name|Ins_JROF
block|,
comment|/*  ROFF      */
name|Ins_ROFF
block|,
comment|/*  INS_0x7B  */
name|Ins_UNKNOWN
block|,
comment|/*  RUTG      */
name|Ins_RUTG
block|,
comment|/*  RDTG      */
name|Ins_RDTG
block|,
comment|/*  SANGW     */
name|Ins_SANGW
block|,
comment|/*  AA        */
name|Ins_AA
block|,
comment|/*  FlipPT    */
name|Ins_FLIPPT
block|,
comment|/*  FlipRgON  */
name|Ins_FLIPRGON
block|,
comment|/*  FlipRgOFF */
name|Ins_FLIPRGOFF
block|,
comment|/*  INS_0x83  */
name|Ins_UNKNOWN
block|,
comment|/*  INS_0x84  */
name|Ins_UNKNOWN
block|,
comment|/*  ScanCTRL  */
name|Ins_SCANCTRL
block|,
comment|/*  SDPVTL[0] */
name|Ins_SDPVTL
block|,
comment|/*  SDPVTL[1] */
name|Ins_SDPVTL
block|,
comment|/*  GetINFO   */
name|Ins_GETINFO
block|,
comment|/*  IDEF      */
name|Ins_IDEF
block|,
comment|/*  ROLL      */
name|Ins_ROLL
block|,
comment|/*  MAX       */
name|Ins_MAX
block|,
comment|/*  MIN       */
name|Ins_MIN
block|,
comment|/*  ScanTYPE  */
name|Ins_SCANTYPE
block|,
comment|/*  InstCTRL  */
name|Ins_INSTCTRL
block|,
comment|/*  INS_0x8F  */
name|Ins_UNKNOWN
block|,
comment|/*  INS_0x90  */
name|Ins_UNKNOWN
block|,
comment|/*  INS_0x91  */
name|Ins_UNKNOWN
block|,
comment|/*  INS_0x92  */
name|Ins_UNKNOWN
block|,
comment|/*  INS_0x93  */
name|Ins_UNKNOWN
block|,
comment|/*  INS_0x94  */
name|Ins_UNKNOWN
block|,
comment|/*  INS_0x95  */
name|Ins_UNKNOWN
block|,
comment|/*  INS_0x96  */
name|Ins_UNKNOWN
block|,
comment|/*  INS_0x97  */
name|Ins_UNKNOWN
block|,
comment|/*  INS_0x98  */
name|Ins_UNKNOWN
block|,
comment|/*  INS_0x99  */
name|Ins_UNKNOWN
block|,
comment|/*  INS_0x9A  */
name|Ins_UNKNOWN
block|,
comment|/*  INS_0x9B  */
name|Ins_UNKNOWN
block|,
comment|/*  INS_0x9C  */
name|Ins_UNKNOWN
block|,
comment|/*  INS_0x9D  */
name|Ins_UNKNOWN
block|,
comment|/*  INS_0x9E  */
name|Ins_UNKNOWN
block|,
comment|/*  INS_0x9F  */
name|Ins_UNKNOWN
block|,
comment|/*  INS_0xA0  */
name|Ins_UNKNOWN
block|,
comment|/*  INS_0xA1  */
name|Ins_UNKNOWN
block|,
comment|/*  INS_0xA2  */
name|Ins_UNKNOWN
block|,
comment|/*  INS_0xA3  */
name|Ins_UNKNOWN
block|,
comment|/*  INS_0xA4  */
name|Ins_UNKNOWN
block|,
comment|/*  INS_0xA5  */
name|Ins_UNKNOWN
block|,
comment|/*  INS_0xA6  */
name|Ins_UNKNOWN
block|,
comment|/*  INS_0xA7  */
name|Ins_UNKNOWN
block|,
comment|/*  INS_0xA8  */
name|Ins_UNKNOWN
block|,
comment|/*  INS_0xA9  */
name|Ins_UNKNOWN
block|,
comment|/*  INS_0xAA  */
name|Ins_UNKNOWN
block|,
comment|/*  INS_0xAB  */
name|Ins_UNKNOWN
block|,
comment|/*  INS_0xAC  */
name|Ins_UNKNOWN
block|,
comment|/*  INS_0xAD  */
name|Ins_UNKNOWN
block|,
comment|/*  INS_0xAE  */
name|Ins_UNKNOWN
block|,
comment|/*  INS_0xAF  */
name|Ins_UNKNOWN
block|,
comment|/*  PushB[0]  */
name|Ins_PUSHB
block|,
comment|/*  PushB[1]  */
name|Ins_PUSHB
block|,
comment|/*  PushB[2]  */
name|Ins_PUSHB
block|,
comment|/*  PushB[3]  */
name|Ins_PUSHB
block|,
comment|/*  PushB[4]  */
name|Ins_PUSHB
block|,
comment|/*  PushB[5]  */
name|Ins_PUSHB
block|,
comment|/*  PushB[6]  */
name|Ins_PUSHB
block|,
comment|/*  PushB[7]  */
name|Ins_PUSHB
block|,
comment|/*  PushW[0]  */
name|Ins_PUSHW
block|,
comment|/*  PushW[1]  */
name|Ins_PUSHW
block|,
comment|/*  PushW[2]  */
name|Ins_PUSHW
block|,
comment|/*  PushW[3]  */
name|Ins_PUSHW
block|,
comment|/*  PushW[4]  */
name|Ins_PUSHW
block|,
comment|/*  PushW[5]  */
name|Ins_PUSHW
block|,
comment|/*  PushW[6]  */
name|Ins_PUSHW
block|,
comment|/*  PushW[7]  */
name|Ins_PUSHW
block|,
comment|/*  MDRP[00]  */
name|Ins_MDRP
block|,
comment|/*  MDRP[01]  */
name|Ins_MDRP
block|,
comment|/*  MDRP[02]  */
name|Ins_MDRP
block|,
comment|/*  MDRP[03]  */
name|Ins_MDRP
block|,
comment|/*  MDRP[04]  */
name|Ins_MDRP
block|,
comment|/*  MDRP[05]  */
name|Ins_MDRP
block|,
comment|/*  MDRP[06]  */
name|Ins_MDRP
block|,
comment|/*  MDRP[07]  */
name|Ins_MDRP
block|,
comment|/*  MDRP[08]  */
name|Ins_MDRP
block|,
comment|/*  MDRP[09]  */
name|Ins_MDRP
block|,
comment|/*  MDRP[10]  */
name|Ins_MDRP
block|,
comment|/*  MDRP[11]  */
name|Ins_MDRP
block|,
comment|/*  MDRP[12]  */
name|Ins_MDRP
block|,
comment|/*  MDRP[13]  */
name|Ins_MDRP
block|,
comment|/*  MDRP[14]  */
name|Ins_MDRP
block|,
comment|/*  MDRP[15]  */
name|Ins_MDRP
block|,
comment|/*  MDRP[16]  */
name|Ins_MDRP
block|,
comment|/*  MDRP[17]  */
name|Ins_MDRP
block|,
comment|/*  MDRP[18]  */
name|Ins_MDRP
block|,
comment|/*  MDRP[19]  */
name|Ins_MDRP
block|,
comment|/*  MDRP[20]  */
name|Ins_MDRP
block|,
comment|/*  MDRP[21]  */
name|Ins_MDRP
block|,
comment|/*  MDRP[22]  */
name|Ins_MDRP
block|,
comment|/*  MDRP[23]  */
name|Ins_MDRP
block|,
comment|/*  MDRP[24]  */
name|Ins_MDRP
block|,
comment|/*  MDRP[25]  */
name|Ins_MDRP
block|,
comment|/*  MDRP[26]  */
name|Ins_MDRP
block|,
comment|/*  MDRP[27]  */
name|Ins_MDRP
block|,
comment|/*  MDRP[28]  */
name|Ins_MDRP
block|,
comment|/*  MDRP[29]  */
name|Ins_MDRP
block|,
comment|/*  MDRP[30]  */
name|Ins_MDRP
block|,
comment|/*  MDRP[31]  */
name|Ins_MDRP
block|,
comment|/*  MIRP[00]  */
name|Ins_MIRP
block|,
comment|/*  MIRP[01]  */
name|Ins_MIRP
block|,
comment|/*  MIRP[02]  */
name|Ins_MIRP
block|,
comment|/*  MIRP[03]  */
name|Ins_MIRP
block|,
comment|/*  MIRP[04]  */
name|Ins_MIRP
block|,
comment|/*  MIRP[05]  */
name|Ins_MIRP
block|,
comment|/*  MIRP[06]  */
name|Ins_MIRP
block|,
comment|/*  MIRP[07]  */
name|Ins_MIRP
block|,
comment|/*  MIRP[08]  */
name|Ins_MIRP
block|,
comment|/*  MIRP[09]  */
name|Ins_MIRP
block|,
comment|/*  MIRP[10]  */
name|Ins_MIRP
block|,
comment|/*  MIRP[11]  */
name|Ins_MIRP
block|,
comment|/*  MIRP[12]  */
name|Ins_MIRP
block|,
comment|/*  MIRP[13]  */
name|Ins_MIRP
block|,
comment|/*  MIRP[14]  */
name|Ins_MIRP
block|,
comment|/*  MIRP[15]  */
name|Ins_MIRP
block|,
comment|/*  MIRP[16]  */
name|Ins_MIRP
block|,
comment|/*  MIRP[17]  */
name|Ins_MIRP
block|,
comment|/*  MIRP[18]  */
name|Ins_MIRP
block|,
comment|/*  MIRP[19]  */
name|Ins_MIRP
block|,
comment|/*  MIRP[20]  */
name|Ins_MIRP
block|,
comment|/*  MIRP[21]  */
name|Ins_MIRP
block|,
comment|/*  MIRP[22]  */
name|Ins_MIRP
block|,
comment|/*  MIRP[23]  */
name|Ins_MIRP
block|,
comment|/*  MIRP[24]  */
name|Ins_MIRP
block|,
comment|/*  MIRP[25]  */
name|Ins_MIRP
block|,
comment|/*  MIRP[26]  */
name|Ins_MIRP
block|,
comment|/*  MIRP[27]  */
name|Ins_MIRP
block|,
comment|/*  MIRP[28]  */
name|Ins_MIRP
block|,
comment|/*  MIRP[29]  */
name|Ins_MIRP
block|,
comment|/*  MIRP[30]  */
name|Ins_MIRP
block|,
comment|/*  MIRP[31]  */
name|Ins_MIRP
block|}
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* !TT_CONFIG_OPTION_INTERPRETER_SWITCH */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* RUN                                                                   */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*  This function executes a run of opcodes.  It will exit in the        */
end_comment
begin_comment
comment|/*  following cases:                                                     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*  - Errors (in which case it returns FALSE).                           */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*  - Reaching the end of the main code range (returns TRUE).            */
end_comment
begin_comment
comment|/*    Reaching the end of a code range within a function call is an      */
end_comment
begin_comment
comment|/*    error.                                                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*  - After executing one single opcode, if the flag `Instruction_Trap'  */
end_comment
begin_comment
comment|/*    is set to TRUE (returns TRUE).                                     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*  On exit with TRUE, test IP< CodeSize to know whether it comes from  */
end_comment
begin_comment
comment|/*  an instruction trap or a normal termination.                         */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*  Note: The documented DEBUG opcode pops a value from the stack.  This */
end_comment
begin_comment
comment|/*        behaviour is unsupported; here a DEBUG opcode is always an     */
end_comment
begin_comment
comment|/*        error.                                                         */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* THIS IS THE INTERPRETER'S MAIN LOOP.                                  */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*  Instructions appear in the specification's order.                    */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/* documentation is in ttinterp.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|TT_RunIns
argument_list|(
argument|TT_ExecContext  exc
argument_list|)
end_macro
begin_block
block|{
name|FT_Long
name|ins_counter
init|=
literal|0
decl_stmt|;
comment|/* executed instructions counter */
name|FT_UShort
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_SUBPIXEL_HINTING
name|FT_Byte
name|opcode_pattern
index|[
literal|1
index|]
index|[
literal|2
index|]
init|=
block|{
comment|/* #8 TypeMan Talk Align */
block|{
literal|0x06
block|,
comment|/* SPVTL   */
literal|0x7D
block|,
comment|/* RDTG    */
block|}
block|,                 }
decl_stmt|;
name|FT_UShort
name|opcode_patterns
init|=
literal|1
decl_stmt|;
name|FT_UShort
name|opcode_pointer
index|[
literal|1
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
name|FT_UShort
name|opcode_size
index|[
literal|1
index|]
init|=
block|{
literal|1
block|}
decl_stmt|;
endif|#
directive|endif
comment|/* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_STATIC_RASTER
if|if
condition|(
operator|!
name|exc
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_Argument
argument_list|)
return|;
name|cur
operator|=
operator|*
name|exc
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_SUBPIXEL_HINTING
name|CUR
operator|.
name|iup_called
operator|=
name|FALSE
expr_stmt|;
endif|#
directive|endif
comment|/* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
comment|/* set PPEM and CVT functions */
name|CUR
operator|.
name|tt_metrics
operator|.
name|ratio
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|CUR
operator|.
name|metrics
operator|.
name|x_ppem
operator|!=
name|CUR
operator|.
name|metrics
operator|.
name|y_ppem
condition|)
block|{
comment|/* non-square pixels, use the stretched routines */
name|CUR
operator|.
name|func_cur_ppem
operator|=
name|Current_Ppem_Stretched
expr_stmt|;
name|CUR
operator|.
name|func_read_cvt
operator|=
name|Read_CVT_Stretched
expr_stmt|;
name|CUR
operator|.
name|func_write_cvt
operator|=
name|Write_CVT_Stretched
expr_stmt|;
name|CUR
operator|.
name|func_move_cvt
operator|=
name|Move_CVT_Stretched
expr_stmt|;
block|}
else|else
block|{
comment|/* square pixels, use normal routines */
name|CUR
operator|.
name|func_cur_ppem
operator|=
name|Current_Ppem
expr_stmt|;
name|CUR
operator|.
name|func_read_cvt
operator|=
name|Read_CVT
expr_stmt|;
name|CUR
operator|.
name|func_write_cvt
operator|=
name|Write_CVT
expr_stmt|;
name|CUR
operator|.
name|func_move_cvt
operator|=
name|Move_CVT
expr_stmt|;
block|}
name|COMPUTE_Funcs
argument_list|()
expr_stmt|;
name|COMPUTE_Round
argument_list|(
operator|(
name|FT_Byte
operator|)
name|exc
operator|->
name|GS
operator|.
name|round_state
argument_list|)
expr_stmt|;
do|do
block|{
name|CUR
operator|.
name|opcode
operator|=
name|CUR
operator|.
name|code
index|[
name|CUR
operator|.
name|IP
index|]
expr_stmt|;
name|FT_TRACE7
argument_list|(
operator|(
literal|"  "
operator|)
argument_list|)
expr_stmt|;
name|FT_TRACE7
argument_list|(
operator|(
name|opcode_name
index|[
name|CUR
operator|.
name|opcode
index|]
operator|)
argument_list|)
expr_stmt|;
name|FT_TRACE7
argument_list|(
operator|(
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|CUR
operator|.
name|length
operator|=
name|opcode_length
index|[
name|CUR
operator|.
name|opcode
index|]
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|CUR
operator|.
name|IP
operator|+
literal|1
operator|>=
name|CUR
operator|.
name|codeSize
condition|)
goto|goto
name|LErrorCodeOverflow_
goto|;
name|CUR
operator|.
name|length
operator|=
literal|2
operator|-
name|CUR
operator|.
name|length
operator|*
name|CUR
operator|.
name|code
index|[
name|CUR
operator|.
name|IP
operator|+
literal|1
index|]
expr_stmt|;
block|}
if|if
condition|(
name|CUR
operator|.
name|IP
operator|+
name|CUR
operator|.
name|length
operator|>
name|CUR
operator|.
name|codeSize
condition|)
goto|goto
name|LErrorCodeOverflow_
goto|;
comment|/* First, let's check for empty stack and overflow */
name|CUR
operator|.
name|args
operator|=
name|CUR
operator|.
name|top
operator|-
operator|(
name|Pop_Push_Count
index|[
name|CUR
operator|.
name|opcode
index|]
operator|>>
literal|4
operator|)
expr_stmt|;
comment|/* `args' is the top of the stack once arguments have been popped. */
comment|/* One can also interpret it as the index of the last argument.    */
if|if
condition|(
name|CUR
operator|.
name|args
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|CUR
operator|.
name|pedantic_hinting
condition|)
block|{
name|CUR
operator|.
name|error
operator|=
name|FT_THROW
argument_list|(
name|Too_Few_Arguments
argument_list|)
expr_stmt|;
goto|goto
name|LErrorLabel_
goto|;
block|}
comment|/* push zeroes onto the stack */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|Pop_Push_Count
index|[
name|CUR
operator|.
name|opcode
index|]
operator|>>
literal|4
condition|;
name|i
operator|++
control|)
name|CUR
operator|.
name|stack
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|CUR
operator|.
name|args
operator|=
literal|0
expr_stmt|;
block|}
name|CUR
operator|.
name|new_top
operator|=
name|CUR
operator|.
name|args
operator|+
operator|(
name|Pop_Push_Count
index|[
name|CUR
operator|.
name|opcode
index|]
operator|&
literal|15
operator|)
expr_stmt|;
comment|/* `new_top' is the new top of the stack, after the instruction's */
comment|/* execution.  `top' will be set to `new_top' after the `switch'  */
comment|/* statement.                                                     */
if|if
condition|(
name|CUR
operator|.
name|new_top
operator|>
name|CUR
operator|.
name|stackSize
condition|)
block|{
name|CUR
operator|.
name|error
operator|=
name|FT_THROW
argument_list|(
name|Stack_Overflow
argument_list|)
expr_stmt|;
goto|goto
name|LErrorLabel_
goto|;
block|}
name|CUR
operator|.
name|step_ins
operator|=
name|TRUE
expr_stmt|;
name|CUR
operator|.
name|error
operator|=
name|FT_Err_Ok
expr_stmt|;
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_SUBPIXEL_HINTING
if|if
condition|(
name|SUBPIXEL_HINTING
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|opcode_patterns
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|opcode_pointer
index|[
name|i
index|]
operator|<
name|opcode_size
index|[
name|i
index|]
operator|&&
name|CUR
operator|.
name|opcode
operator|==
name|opcode_pattern
index|[
name|i
index|]
index|[
name|opcode_pointer
index|[
name|i
index|]
index|]
condition|)
block|{
name|opcode_pointer
index|[
name|i
index|]
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|opcode_pointer
index|[
name|i
index|]
operator|==
name|opcode_size
index|[
name|i
index|]
condition|)
block|{
name|FT_TRACE7
argument_list|(
operator|(
literal|"sph: opcode ptrn: %d, %s %s\n"
operator|,
name|i
operator|,
name|CUR
operator|.
name|face
operator|->
name|root
operator|.
name|family_name
operator|,
name|CUR
operator|.
name|face
operator|->
name|root
operator|.
name|style_name
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|0
case|:
break|break;
block|}
name|opcode_pointer
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
name|opcode_pointer
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* TT_CONFIG_OPTION_SUBPIXEL_HINTING */
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_INTERPRETER_SWITCH
block|{
name|FT_Long
modifier|*
name|args
init|=
name|CUR
operator|.
name|stack
operator|+
name|CUR
operator|.
name|args
decl_stmt|;
name|FT_Byte
name|opcode
init|=
name|CUR
operator|.
name|opcode
decl_stmt|;
DECL|macro|ARRAY_BOUND_ERROR
undef|#
directive|undef
name|ARRAY_BOUND_ERROR
DECL|macro|ARRAY_BOUND_ERROR
define|#
directive|define
name|ARRAY_BOUND_ERROR
value|goto Set_Invalid_Ref
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
literal|0x00
case|:
comment|/* SVTCA y  */
case|case
literal|0x01
case|:
comment|/* SVTCA x  */
case|case
literal|0x02
case|:
comment|/* SPvTCA y */
case|case
literal|0x03
case|:
comment|/* SPvTCA x */
case|case
literal|0x04
case|:
comment|/* SFvTCA y */
case|case
literal|0x05
case|:
comment|/* SFvTCA x */
block|{
name|FT_Short
name|AA
decl_stmt|,
name|BB
decl_stmt|;
name|AA
operator|=
call|(
name|FT_Short
call|)
argument_list|(
operator|(
name|opcode
operator|&
literal|1
operator|)
operator|<<
literal|14
argument_list|)
expr_stmt|;
name|BB
operator|=
call|(
name|FT_Short
call|)
argument_list|(
name|AA
operator|^
literal|0x4000
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|<
literal|4
condition|)
block|{
name|CUR
operator|.
name|GS
operator|.
name|projVector
operator|.
name|x
operator|=
name|AA
expr_stmt|;
name|CUR
operator|.
name|GS
operator|.
name|projVector
operator|.
name|y
operator|=
name|BB
expr_stmt|;
name|CUR
operator|.
name|GS
operator|.
name|dualVector
operator|.
name|x
operator|=
name|AA
expr_stmt|;
name|CUR
operator|.
name|GS
operator|.
name|dualVector
operator|.
name|y
operator|=
name|BB
expr_stmt|;
block|}
else|else
block|{
name|GUESS_VECTOR
argument_list|(
name|projVector
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|opcode
operator|&
literal|2
operator|)
operator|==
literal|0
condition|)
block|{
name|CUR
operator|.
name|GS
operator|.
name|freeVector
operator|.
name|x
operator|=
name|AA
expr_stmt|;
name|CUR
operator|.
name|GS
operator|.
name|freeVector
operator|.
name|y
operator|=
name|BB
expr_stmt|;
block|}
else|else
block|{
name|GUESS_VECTOR
argument_list|(
name|freeVector
argument_list|)
expr_stmt|;
block|}
name|COMPUTE_Funcs
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
literal|0x06
case|:
comment|/* SPvTL // */
case|case
literal|0x07
case|:
comment|/* SPvTL +  */
name|DO_SPVTL
break|break;
case|case
literal|0x08
case|:
comment|/* SFvTL // */
case|case
literal|0x09
case|:
comment|/* SFvTL +  */
name|DO_SFVTL
break|break;
case|case
literal|0x0A
case|:
comment|/* SPvFS */
name|DO_SPVFS
break|break;
case|case
literal|0x0B
case|:
comment|/* SFvFS */
name|DO_SFVFS
break|break;
case|case
literal|0x0C
case|:
comment|/* GPV */
name|DO_GPV
break|break;
case|case
literal|0x0D
case|:
comment|/* GFV */
name|DO_GFV
break|break;
case|case
literal|0x0E
case|:
comment|/* SFvTPv */
name|DO_SFVTPV
break|break;
case|case
literal|0x0F
case|:
comment|/* ISECT  */
name|Ins_ISECT
argument_list|(
argument|EXEC_ARG_ args
argument_list|)
empty_stmt|;
break|break;
case|case
literal|0x10
case|:
comment|/* SRP0 */
name|DO_SRP0
break|break;
case|case
literal|0x11
case|:
comment|/* SRP1 */
name|DO_SRP1
break|break;
case|case
literal|0x12
case|:
comment|/* SRP2 */
name|DO_SRP2
break|break;
case|case
literal|0x13
case|:
comment|/* SZP0 */
name|Ins_SZP0
argument_list|(
argument|EXEC_ARG_ args
argument_list|)
empty_stmt|;
break|break;
case|case
literal|0x14
case|:
comment|/* SZP1 */
name|Ins_SZP1
argument_list|(
argument|EXEC_ARG_ args
argument_list|)
empty_stmt|;
break|break;
case|case
literal|0x15
case|:
comment|/* SZP2 */
name|Ins_SZP2
argument_list|(
argument|EXEC_ARG_ args
argument_list|)
empty_stmt|;
break|break;
case|case
literal|0x16
case|:
comment|/* SZPS */
name|Ins_SZPS
argument_list|(
argument|EXEC_ARG_ args
argument_list|)
empty_stmt|;
break|break;
case|case
literal|0x17
case|:
comment|/* SLOOP */
name|DO_SLOOP
break|break;
case|case
literal|0x18
case|:
comment|/* RTG */
name|DO_RTG
break|break;
case|case
literal|0x19
case|:
comment|/* RTHG */
name|DO_RTHG
break|break;
case|case
literal|0x1A
case|:
comment|/* SMD */
name|DO_SMD
break|break;
case|case
literal|0x1B
case|:
comment|/* ELSE */
name|Ins_ELSE
argument_list|(
argument|EXEC_ARG_ args
argument_list|)
empty_stmt|;
break|break;
case|case
literal|0x1C
case|:
comment|/* JMPR */
name|DO_JMPR
break|break;
case|case
literal|0x1D
case|:
comment|/* SCVTCI */
name|DO_SCVTCI
break|break;
case|case
literal|0x1E
case|:
comment|/* SSWCI */
name|DO_SSWCI
break|break;
case|case
literal|0x1F
case|:
comment|/* SSW */
name|DO_SSW
break|break;
case|case
literal|0x20
case|:
comment|/* DUP */
name|DO_DUP
break|break;
case|case
literal|0x21
case|:
comment|/* POP */
comment|/* nothing :-) */
break|break;
case|case
literal|0x22
case|:
comment|/* CLEAR */
name|DO_CLEAR
break|break;
case|case
literal|0x23
case|:
comment|/* SWAP */
name|DO_SWAP
break|break;
case|case
literal|0x24
case|:
comment|/* DEPTH */
name|DO_DEPTH
break|break;
case|case
literal|0x25
case|:
comment|/* CINDEX */
name|DO_CINDEX
break|break;
case|case
literal|0x26
case|:
comment|/* MINDEX */
name|Ins_MINDEX
argument_list|(
argument|EXEC_ARG_ args
argument_list|)
empty_stmt|;
break|break;
case|case
literal|0x27
case|:
comment|/* ALIGNPTS */
name|Ins_ALIGNPTS
argument_list|(
argument|EXEC_ARG_ args
argument_list|)
empty_stmt|;
break|break;
case|case
literal|0x28
case|:
comment|/* ???? */
name|Ins_UNKNOWN
argument_list|(
argument|EXEC_ARG_ args
argument_list|)
empty_stmt|;
break|break;
case|case
literal|0x29
case|:
comment|/* UTP */
name|Ins_UTP
argument_list|(
argument|EXEC_ARG_ args
argument_list|)
empty_stmt|;
break|break;
case|case
literal|0x2A
case|:
comment|/* LOOPCALL */
name|Ins_LOOPCALL
argument_list|(
argument|EXEC_ARG_ args
argument_list|)
empty_stmt|;
break|break;
case|case
literal|0x2B
case|:
comment|/* CALL */
name|Ins_CALL
argument_list|(
argument|EXEC_ARG_ args
argument_list|)
empty_stmt|;
break|break;
case|case
literal|0x2C
case|:
comment|/* FDEF */
name|Ins_FDEF
argument_list|(
argument|EXEC_ARG_ args
argument_list|)
empty_stmt|;
break|break;
case|case
literal|0x2D
case|:
comment|/* ENDF */
name|Ins_ENDF
argument_list|(
argument|EXEC_ARG_ args
argument_list|)
empty_stmt|;
break|break;
case|case
literal|0x2E
case|:
comment|/* MDAP */
case|case
literal|0x2F
case|:
comment|/* MDAP */
name|Ins_MDAP
argument_list|(
argument|EXEC_ARG_ args
argument_list|)
empty_stmt|;
break|break;
case|case
literal|0x30
case|:
comment|/* IUP */
case|case
literal|0x31
case|:
comment|/* IUP */
name|Ins_IUP
argument_list|(
argument|EXEC_ARG_ args
argument_list|)
empty_stmt|;
break|break;
case|case
literal|0x32
case|:
comment|/* SHP */
case|case
literal|0x33
case|:
comment|/* SHP */
name|Ins_SHP
argument_list|(
argument|EXEC_ARG_ args
argument_list|)
empty_stmt|;
break|break;
case|case
literal|0x34
case|:
comment|/* SHC */
case|case
literal|0x35
case|:
comment|/* SHC */
name|Ins_SHC
argument_list|(
argument|EXEC_ARG_ args
argument_list|)
empty_stmt|;
break|break;
case|case
literal|0x36
case|:
comment|/* SHZ */
case|case
literal|0x37
case|:
comment|/* SHZ */
name|Ins_SHZ
argument_list|(
argument|EXEC_ARG_ args
argument_list|)
empty_stmt|;
break|break;
case|case
literal|0x38
case|:
comment|/* SHPIX */
name|Ins_SHPIX
argument_list|(
argument|EXEC_ARG_ args
argument_list|)
empty_stmt|;
break|break;
case|case
literal|0x39
case|:
comment|/* IP    */
name|Ins_IP
argument_list|(
argument|EXEC_ARG_ args
argument_list|)
empty_stmt|;
break|break;
case|case
literal|0x3A
case|:
comment|/* MSIRP */
case|case
literal|0x3B
case|:
comment|/* MSIRP */
name|Ins_MSIRP
argument_list|(
argument|EXEC_ARG_ args
argument_list|)
empty_stmt|;
break|break;
case|case
literal|0x3C
case|:
comment|/* AlignRP */
name|Ins_ALIGNRP
argument_list|(
argument|EXEC_ARG_ args
argument_list|)
empty_stmt|;
break|break;
case|case
literal|0x3D
case|:
comment|/* RTDG */
name|DO_RTDG
break|break;
case|case
literal|0x3E
case|:
comment|/* MIAP */
case|case
literal|0x3F
case|:
comment|/* MIAP */
name|Ins_MIAP
argument_list|(
argument|EXEC_ARG_ args
argument_list|)
empty_stmt|;
break|break;
case|case
literal|0x40
case|:
comment|/* NPUSHB */
name|Ins_NPUSHB
argument_list|(
argument|EXEC_ARG_ args
argument_list|)
empty_stmt|;
break|break;
case|case
literal|0x41
case|:
comment|/* NPUSHW */
name|Ins_NPUSHW
argument_list|(
argument|EXEC_ARG_ args
argument_list|)
empty_stmt|;
break|break;
case|case
literal|0x42
case|:
comment|/* WS */
name|DO_WS
break|break;
name|Set_Invalid_Ref
label|:
name|CUR
operator|.
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Reference
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x43
case|:
comment|/* RS */
name|DO_RS
break|break;
case|case
literal|0x44
case|:
comment|/* WCVTP */
name|DO_WCVTP
break|break;
case|case
literal|0x45
case|:
comment|/* RCVT */
name|DO_RCVT
break|break;
case|case
literal|0x46
case|:
comment|/* GC */
case|case
literal|0x47
case|:
comment|/* GC */
name|Ins_GC
argument_list|(
argument|EXEC_ARG_ args
argument_list|)
empty_stmt|;
break|break;
case|case
literal|0x48
case|:
comment|/* SCFS */
name|Ins_SCFS
argument_list|(
argument|EXEC_ARG_ args
argument_list|)
empty_stmt|;
break|break;
case|case
literal|0x49
case|:
comment|/* MD */
case|case
literal|0x4A
case|:
comment|/* MD */
name|Ins_MD
argument_list|(
argument|EXEC_ARG_ args
argument_list|)
empty_stmt|;
break|break;
case|case
literal|0x4B
case|:
comment|/* MPPEM */
name|DO_MPPEM
break|break;
case|case
literal|0x4C
case|:
comment|/* MPS */
name|DO_MPS
break|break;
case|case
literal|0x4D
case|:
comment|/* FLIPON */
name|DO_FLIPON
break|break;
case|case
literal|0x4E
case|:
comment|/* FLIPOFF */
name|DO_FLIPOFF
break|break;
case|case
literal|0x4F
case|:
comment|/* DEBUG */
name|DO_DEBUG
break|break;
case|case
literal|0x50
case|:
comment|/* LT */
name|DO_LT
break|break;
case|case
literal|0x51
case|:
comment|/* LTEQ */
name|DO_LTEQ
break|break;
case|case
literal|0x52
case|:
comment|/* GT */
name|DO_GT
break|break;
case|case
literal|0x53
case|:
comment|/* GTEQ */
name|DO_GTEQ
break|break;
case|case
literal|0x54
case|:
comment|/* EQ */
name|DO_EQ
break|break;
case|case
literal|0x55
case|:
comment|/* NEQ */
name|DO_NEQ
break|break;
case|case
literal|0x56
case|:
comment|/* ODD */
name|DO_ODD
break|break;
case|case
literal|0x57
case|:
comment|/* EVEN */
name|DO_EVEN
break|break;
case|case
literal|0x58
case|:
comment|/* IF */
name|Ins_IF
argument_list|(
argument|EXEC_ARG_ args
argument_list|)
empty_stmt|;
break|break;
case|case
literal|0x59
case|:
comment|/* EIF */
comment|/* do nothing */
break|break;
case|case
literal|0x5A
case|:
comment|/* AND */
name|DO_AND
break|break;
case|case
literal|0x5B
case|:
comment|/* OR */
name|DO_OR
break|break;
case|case
literal|0x5C
case|:
comment|/* NOT */
name|DO_NOT
break|break;
case|case
literal|0x5D
case|:
comment|/* DELTAP1 */
name|Ins_DELTAP
argument_list|(
argument|EXEC_ARG_ args
argument_list|)
empty_stmt|;
break|break;
case|case
literal|0x5E
case|:
comment|/* SDB */
name|DO_SDB
break|break;
case|case
literal|0x5F
case|:
comment|/* SDS */
name|DO_SDS
break|break;
case|case
literal|0x60
case|:
comment|/* ADD */
name|DO_ADD
break|break;
case|case
literal|0x61
case|:
comment|/* SUB */
name|DO_SUB
break|break;
case|case
literal|0x62
case|:
comment|/* DIV */
name|DO_DIV
break|break;
case|case
literal|0x63
case|:
comment|/* MUL */
name|DO_MUL
break|break;
case|case
literal|0x64
case|:
comment|/* ABS */
name|DO_ABS
break|break;
case|case
literal|0x65
case|:
comment|/* NEG */
name|DO_NEG
break|break;
case|case
literal|0x66
case|:
comment|/* FLOOR */
name|DO_FLOOR
break|break;
case|case
literal|0x67
case|:
comment|/* CEILING */
name|DO_CEILING
break|break;
case|case
literal|0x68
case|:
comment|/* ROUND */
case|case
literal|0x69
case|:
comment|/* ROUND */
case|case
literal|0x6A
case|:
comment|/* ROUND */
case|case
literal|0x6B
case|:
comment|/* ROUND */
name|DO_ROUND
break|break;
case|case
literal|0x6C
case|:
comment|/* NROUND */
case|case
literal|0x6D
case|:
comment|/* NROUND */
case|case
literal|0x6E
case|:
comment|/* NRRUND */
case|case
literal|0x6F
case|:
comment|/* NROUND */
name|DO_NROUND
break|break;
case|case
literal|0x70
case|:
comment|/* WCVTF */
name|DO_WCVTF
break|break;
case|case
literal|0x71
case|:
comment|/* DELTAP2 */
case|case
literal|0x72
case|:
comment|/* DELTAP3 */
name|Ins_DELTAP
argument_list|(
argument|EXEC_ARG_ args
argument_list|)
empty_stmt|;
break|break;
case|case
literal|0x73
case|:
comment|/* DELTAC0 */
case|case
literal|0x74
case|:
comment|/* DELTAC1 */
case|case
literal|0x75
case|:
comment|/* DELTAC2 */
name|Ins_DELTAC
argument_list|(
argument|EXEC_ARG_ args
argument_list|)
empty_stmt|;
break|break;
case|case
literal|0x76
case|:
comment|/* SROUND */
name|DO_SROUND
break|break;
case|case
literal|0x77
case|:
comment|/* S45Round */
name|DO_S45ROUND
break|break;
case|case
literal|0x78
case|:
comment|/* JROT */
name|DO_JROT
break|break;
case|case
literal|0x79
case|:
comment|/* JROF */
name|DO_JROF
break|break;
case|case
literal|0x7A
case|:
comment|/* ROFF */
name|DO_ROFF
break|break;
case|case
literal|0x7B
case|:
comment|/* ???? */
name|Ins_UNKNOWN
argument_list|(
argument|EXEC_ARG_ args
argument_list|)
empty_stmt|;
break|break;
case|case
literal|0x7C
case|:
comment|/* RUTG */
name|DO_RUTG
break|break;
case|case
literal|0x7D
case|:
comment|/* RDTG */
name|DO_RDTG
break|break;
case|case
literal|0x7E
case|:
comment|/* SANGW */
case|case
literal|0x7F
case|:
comment|/* AA    */
comment|/* nothing - obsolete */
break|break;
case|case
literal|0x80
case|:
comment|/* FLIPPT */
name|Ins_FLIPPT
argument_list|(
argument|EXEC_ARG_ args
argument_list|)
empty_stmt|;
break|break;
case|case
literal|0x81
case|:
comment|/* FLIPRGON */
name|Ins_FLIPRGON
argument_list|(
argument|EXEC_ARG_ args
argument_list|)
empty_stmt|;
break|break;
case|case
literal|0x82
case|:
comment|/* FLIPRGOFF */
name|Ins_FLIPRGOFF
argument_list|(
argument|EXEC_ARG_ args
argument_list|)
empty_stmt|;
break|break;
case|case
literal|0x83
case|:
comment|/* UNKNOWN */
case|case
literal|0x84
case|:
comment|/* UNKNOWN */
name|Ins_UNKNOWN
argument_list|(
argument|EXEC_ARG_ args
argument_list|)
empty_stmt|;
break|break;
case|case
literal|0x85
case|:
comment|/* SCANCTRL */
name|Ins_SCANCTRL
argument_list|(
argument|EXEC_ARG_ args
argument_list|)
empty_stmt|;
break|break;
case|case
literal|0x86
case|:
comment|/* SDPVTL */
case|case
literal|0x87
case|:
comment|/* SDPVTL */
name|Ins_SDPVTL
argument_list|(
argument|EXEC_ARG_ args
argument_list|)
empty_stmt|;
break|break;
case|case
literal|0x88
case|:
comment|/* GETINFO */
name|Ins_GETINFO
argument_list|(
argument|EXEC_ARG_ args
argument_list|)
empty_stmt|;
break|break;
case|case
literal|0x89
case|:
comment|/* IDEF */
name|Ins_IDEF
argument_list|(
argument|EXEC_ARG_ args
argument_list|)
empty_stmt|;
break|break;
case|case
literal|0x8A
case|:
comment|/* ROLL */
name|Ins_ROLL
argument_list|(
argument|EXEC_ARG_ args
argument_list|)
empty_stmt|;
break|break;
case|case
literal|0x8B
case|:
comment|/* MAX */
name|DO_MAX
break|break;
case|case
literal|0x8C
case|:
comment|/* MIN */
name|DO_MIN
break|break;
case|case
literal|0x8D
case|:
comment|/* SCANTYPE */
name|Ins_SCANTYPE
argument_list|(
argument|EXEC_ARG_ args
argument_list|)
empty_stmt|;
break|break;
case|case
literal|0x8E
case|:
comment|/* INSTCTRL */
name|Ins_INSTCTRL
argument_list|(
argument|EXEC_ARG_ args
argument_list|)
empty_stmt|;
break|break;
case|case
literal|0x8F
case|:
name|Ins_UNKNOWN
argument_list|(
argument|EXEC_ARG_ args
argument_list|)
empty_stmt|;
break|break;
default|default:
if|if
condition|(
name|opcode
operator|>=
literal|0xE0
condition|)
name|Ins_MIRP
argument_list|(
argument|EXEC_ARG_ args
argument_list|)
empty_stmt|;
elseif|else
if|if
condition|(
name|opcode
operator|>=
literal|0xC0
condition|)
name|Ins_MDRP
argument_list|(
argument|EXEC_ARG_ args
argument_list|)
empty_stmt|;
elseif|else
if|if
condition|(
name|opcode
operator|>=
literal|0xB8
condition|)
name|Ins_PUSHW
argument_list|(
argument|EXEC_ARG_ args
argument_list|)
empty_stmt|;
elseif|else
if|if
condition|(
name|opcode
operator|>=
literal|0xB0
condition|)
name|Ins_PUSHB
argument_list|(
argument|EXEC_ARG_ args
argument_list|)
empty_stmt|;
else|else
name|Ins_UNKNOWN
argument_list|(
argument|EXEC_ARG_ args
argument_list|)
empty_stmt|;
block|}
block|}
else|#
directive|else
name|Instruct_Dispatch
index|[
name|CUR
operator|.
name|opcode
index|]
operator|(
name|EXEC_ARG_
operator|&
name|CUR
operator|.
name|stack
index|[
name|CUR
operator|.
name|args
index|]
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* TT_CONFIG_OPTION_INTERPRETER_SWITCH */
if|if
condition|(
name|CUR
operator|.
name|error
condition|)
block|{
switch|switch
condition|(
name|CUR
operator|.
name|error
condition|)
block|{
comment|/* looking for redefined instructions */
case|case
name|FT_ERR
argument_list|(
name|Invalid_Opcode
argument_list|)
case|:
block|{
name|TT_DefRecord
modifier|*
name|def
init|=
name|CUR
operator|.
name|IDefs
decl_stmt|;
name|TT_DefRecord
modifier|*
name|limit
init|=
name|def
operator|+
name|CUR
operator|.
name|numIDefs
decl_stmt|;
for|for
control|(
init|;
name|def
operator|<
name|limit
condition|;
name|def
operator|++
control|)
block|{
if|if
condition|(
name|def
operator|->
name|active
operator|&&
name|CUR
operator|.
name|opcode
operator|==
operator|(
name|FT_Byte
operator|)
name|def
operator|->
name|opc
condition|)
block|{
name|TT_CallRec
modifier|*
name|callrec
decl_stmt|;
if|if
condition|(
name|CUR
operator|.
name|callTop
operator|>=
name|CUR
operator|.
name|callSize
condition|)
block|{
name|CUR
operator|.
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Reference
argument_list|)
expr_stmt|;
goto|goto
name|LErrorLabel_
goto|;
block|}
name|callrec
operator|=
operator|&
name|CUR
operator|.
name|callStack
index|[
name|CUR
operator|.
name|callTop
index|]
expr_stmt|;
name|callrec
operator|->
name|Caller_Range
operator|=
name|CUR
operator|.
name|curRange
expr_stmt|;
name|callrec
operator|->
name|Caller_IP
operator|=
name|CUR
operator|.
name|IP
operator|+
literal|1
expr_stmt|;
name|callrec
operator|->
name|Cur_Count
operator|=
literal|1
expr_stmt|;
name|callrec
operator|->
name|Def
operator|=
name|def
expr_stmt|;
if|if
condition|(
name|INS_Goto_CodeRange
argument_list|(
name|def
operator|->
name|range
argument_list|,
name|def
operator|->
name|start
argument_list|)
operator|==
name|FAILURE
condition|)
goto|goto
name|LErrorLabel_
goto|;
goto|goto
name|LSuiteLabel_
goto|;
block|}
block|}
block|}
name|CUR
operator|.
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Opcode
argument_list|)
expr_stmt|;
goto|goto
name|LErrorLabel_
goto|;
if|#
directive|if
literal|0
block|break;
comment|/* Unreachable code warning suppression.             */
comment|/* Leave to remind in case a later change the editor */
comment|/* to consider break;                                */
endif|#
directive|endif
default|default:
goto|goto
name|LErrorLabel_
goto|;
if|#
directive|if
literal|0
block|break;
endif|#
directive|endif
block|}
block|}
name|CUR
operator|.
name|top
operator|=
name|CUR
operator|.
name|new_top
expr_stmt|;
if|if
condition|(
name|CUR
operator|.
name|step_ins
condition|)
name|CUR
operator|.
name|IP
operator|+=
name|CUR
operator|.
name|length
expr_stmt|;
comment|/* increment instruction counter and check if we didn't */
comment|/* run this program for too long (e.g. infinite loops). */
if|if
condition|(
operator|++
name|ins_counter
operator|>
name|MAX_RUNNABLE_OPCODES
condition|)
return|return
name|FT_THROW
argument_list|(
name|Execution_Too_Long
argument_list|)
return|;
name|LSuiteLabel_
label|:
if|if
condition|(
name|CUR
operator|.
name|IP
operator|>=
name|CUR
operator|.
name|codeSize
condition|)
block|{
if|if
condition|(
name|CUR
operator|.
name|callTop
operator|>
literal|0
condition|)
block|{
name|CUR
operator|.
name|error
operator|=
name|FT_THROW
argument_list|(
name|Code_Overflow
argument_list|)
expr_stmt|;
goto|goto
name|LErrorLabel_
goto|;
block|}
else|else
goto|goto
name|LNo_Error_
goto|;
block|}
block|}
do|while
condition|(
operator|!
name|CUR
operator|.
name|instruction_trap
condition|)
do|;
name|LNo_Error_
label|:
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_STATIC_RASTER
operator|*
name|exc
operator|=
name|cur
expr_stmt|;
endif|#
directive|endif
return|return
name|FT_Err_Ok
return|;
name|LErrorCodeOverflow_
label|:
name|CUR
operator|.
name|error
operator|=
name|FT_THROW
argument_list|(
name|Code_Overflow
argument_list|)
expr_stmt|;
name|LErrorLabel_
label|:
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_STATIC_RASTER
operator|*
name|exc
operator|=
name|cur
expr_stmt|;
endif|#
directive|endif
comment|/* If any errors have occurred, function tables may be broken. */
comment|/* Force a re-execution of `prep' and `fpgm' tables if no      */
comment|/* bytecode debugger is run.                                   */
if|if
condition|(
name|CUR
operator|.
name|error
operator|&&
operator|!
name|CUR
operator|.
name|instruction_trap
operator|&&
name|CUR
operator|.
name|curRange
operator|==
name|tt_coderange_glyph
condition|)
block|{
name|FT_TRACE1
argument_list|(
operator|(
literal|"  The interpreter returned error 0x%x\n"
operator|,
name|CUR
operator|.
name|error
operator|)
argument_list|)
expr_stmt|;
name|exc
operator|->
name|size
operator|->
name|bytecode_ready
operator|=
operator|-
literal|1
expr_stmt|;
name|exc
operator|->
name|size
operator|->
name|cvt_ready
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
name|CUR
operator|.
name|error
return|;
block|}
end_block
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* TT_USE_BYTECODE_INTERPRETER */
end_comment
begin_comment
comment|/* END */
end_comment
end_unit
