begin_unit
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  psmodule.c                                                             */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*    PSNames module implementation (body).                                */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  Copyright 1996-2001, 2002, 2003, 2005, 2006, 2007, 2008 by             */
end_comment
begin_comment
comment|/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  This file is part of the FreeType project, and may only be used,       */
end_comment
begin_comment
comment|/*  modified, and distributed under the terms of the FreeType project      */
end_comment
begin_comment
comment|/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
end_comment
begin_comment
comment|/*  this file you indicate that you have read the license and              */
end_comment
begin_comment
comment|/*  understand and accept it fully.                                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<ft2build.h>
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_OBJECTS_H
end_include
begin_include
include|#
directive|include
include|FT_SERVICE_POSTSCRIPT_CMAPS_H
end_include
begin_include
include|#
directive|include
file|"psmodule.h"
end_include
begin_include
include|#
directive|include
file|"pstables.h"
end_include
begin_include
include|#
directive|include
file|"psnamerr.h"
end_include
begin_include
include|#
directive|include
file|"pspic.h"
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|FT_CONFIG_OPTION_POSTSCRIPT_NAMES
end_ifdef
begin_ifdef
ifdef|#
directive|ifdef
name|FT_CONFIG_OPTION_ADOBE_GLYPH_LIST
end_ifdef
begin_define
DECL|macro|VARIANT_BIT
define|#
directive|define
name|VARIANT_BIT
value|0x80000000UL
end_define
begin_define
DECL|macro|BASE_GLYPH
define|#
directive|define
name|BASE_GLYPH
parameter_list|(
name|code
parameter_list|)
value|( (FT_UInt32)( (code)& ~VARIANT_BIT ) )
end_define
begin_comment
comment|/* Return the Unicode value corresponding to a given glyph.  Note that */
end_comment
begin_comment
comment|/* we do deal with glyph variants by detecting a non-initial dot in    */
end_comment
begin_comment
comment|/* the name, as in `A.swash' or `e.final'; in this case, the           */
end_comment
begin_comment
comment|/* VARIANT_BIT is set in the return value.                             */
end_comment
begin_comment
comment|/*                                                                     */
end_comment
begin_function
specifier|static
name|FT_UInt32
DECL|function|ps_unicode_value
name|ps_unicode_value
parameter_list|(
specifier|const
name|char
modifier|*
name|glyph_name
parameter_list|)
block|{
comment|/* If the name begins with `uni', then the glyph name may be a */
comment|/* hard-coded unicode character code.                          */
if|if
condition|(
name|glyph_name
index|[
literal|0
index|]
operator|==
literal|'u'
operator|&&
name|glyph_name
index|[
literal|1
index|]
operator|==
literal|'n'
operator|&&
name|glyph_name
index|[
literal|2
index|]
operator|==
literal|'i'
condition|)
block|{
comment|/* determine whether the next four characters following are */
comment|/* hexadecimal.                                             */
comment|/* XXX: Add code to deal with ligatures, i.e. glyph names like */
comment|/*      `uniXXXXYYYYZZZZ'...                                   */
name|FT_Int
name|count
decl_stmt|;
name|FT_UInt32
name|value
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
init|=
name|glyph_name
operator|+
literal|3
decl_stmt|;
for|for
control|(
name|count
operator|=
literal|4
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
operator|,
name|p
operator|++
control|)
block|{
name|char
name|c
init|=
operator|*
name|p
decl_stmt|;
name|unsigned
name|int
name|d
decl_stmt|;
name|d
operator|=
operator|(
name|unsigned
name|char
operator|)
name|c
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|d
operator|>=
literal|10
condition|)
block|{
name|d
operator|=
operator|(
name|unsigned
name|char
operator|)
name|c
operator|-
literal|'A'
expr_stmt|;
if|if
condition|(
name|d
operator|>=
literal|6
condition|)
name|d
operator|=
literal|16
expr_stmt|;
else|else
name|d
operator|+=
literal|10
expr_stmt|;
block|}
comment|/* Exit if a non-uppercase hexadecimal character was found   */
comment|/* -- this also catches character codes below `0' since such */
comment|/* negative numbers cast to `unsigned int' are far too big.  */
if|if
condition|(
name|d
operator|>=
literal|16
condition|)
break|break;
name|value
operator|=
operator|(
name|value
operator|<<
literal|4
operator|)
operator|+
name|d
expr_stmt|;
block|}
comment|/* there must be exactly four hex digits */
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
return|return
name|value
return|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'.'
condition|)
return|return
call|(
name|FT_UInt32
call|)
argument_list|(
name|value
operator||
name|VARIANT_BIT
argument_list|)
return|;
block|}
block|}
comment|/* If the name begins with `u', followed by four to six uppercase */
comment|/* hexadecimal digits, it is a hard-coded unicode character code. */
if|if
condition|(
name|glyph_name
index|[
literal|0
index|]
operator|==
literal|'u'
condition|)
block|{
name|FT_Int
name|count
decl_stmt|;
name|FT_UInt32
name|value
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
init|=
name|glyph_name
operator|+
literal|1
decl_stmt|;
for|for
control|(
name|count
operator|=
literal|6
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
operator|,
name|p
operator|++
control|)
block|{
name|char
name|c
init|=
operator|*
name|p
decl_stmt|;
name|unsigned
name|int
name|d
decl_stmt|;
name|d
operator|=
operator|(
name|unsigned
name|char
operator|)
name|c
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|d
operator|>=
literal|10
condition|)
block|{
name|d
operator|=
operator|(
name|unsigned
name|char
operator|)
name|c
operator|-
literal|'A'
expr_stmt|;
if|if
condition|(
name|d
operator|>=
literal|6
condition|)
name|d
operator|=
literal|16
expr_stmt|;
else|else
name|d
operator|+=
literal|10
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|>=
literal|16
condition|)
break|break;
name|value
operator|=
operator|(
name|value
operator|<<
literal|4
operator|)
operator|+
name|d
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|<=
literal|2
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
return|return
name|value
return|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'.'
condition|)
return|return
call|(
name|FT_UInt32
call|)
argument_list|(
name|value
operator||
name|VARIANT_BIT
argument_list|)
return|;
block|}
block|}
comment|/* Look for a non-initial dot in the glyph name in order to */
comment|/* find variants like `A.swash', `e.final', etc.            */
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|glyph_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|dot
init|=
name|NULL
decl_stmt|;
for|for
control|(
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'.'
operator|&&
name|p
operator|>
name|glyph_name
condition|)
block|{
name|dot
operator|=
name|p
expr_stmt|;
break|break;
block|}
block|}
comment|/* now look up the glyph in the Adobe Glyph List */
if|if
condition|(
operator|!
name|dot
condition|)
return|return
operator|(
name|FT_UInt32
operator|)
name|ft_get_adobe_glyph_index
argument_list|(
name|glyph_name
argument_list|,
name|p
argument_list|)
return|;
else|else
return|return
call|(
name|FT_UInt32
call|)
argument_list|(
name|ft_get_adobe_glyph_index
argument_list|(
name|glyph_name
argument_list|,
name|dot
argument_list|)
operator||
name|VARIANT_BIT
argument_list|)
return|;
block|}
block|}
end_function
begin_comment
comment|/* ft_qsort callback to sort the unicode map */
end_comment
begin_macro
name|FT_CALLBACK_DEF
argument_list|(
argument|int
argument_list|)
end_macro
begin_macro
DECL|function|compare_uni_maps
name|compare_uni_maps
argument_list|(
argument|const void*  a
argument_list|,
argument|const void*  b
argument_list|)
end_macro
begin_block
block|{
name|PS_UniMap
modifier|*
name|map1
init|=
operator|(
name|PS_UniMap
operator|*
operator|)
name|a
decl_stmt|;
name|PS_UniMap
modifier|*
name|map2
init|=
operator|(
name|PS_UniMap
operator|*
operator|)
name|b
decl_stmt|;
name|FT_UInt32
name|unicode1
init|=
name|BASE_GLYPH
argument_list|(
name|map1
operator|->
name|unicode
argument_list|)
decl_stmt|;
name|FT_UInt32
name|unicode2
init|=
name|BASE_GLYPH
argument_list|(
name|map2
operator|->
name|unicode
argument_list|)
decl_stmt|;
comment|/* sort base glyphs before glyph variants */
if|if
condition|(
name|unicode1
operator|==
name|unicode2
condition|)
block|{
if|if
condition|(
name|map1
operator|->
name|unicode
operator|>
name|map2
operator|->
name|unicode
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|map1
operator|->
name|unicode
operator|<
name|map2
operator|->
name|unicode
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
else|else
block|{
if|if
condition|(
name|unicode1
operator|>
name|unicode2
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|unicode1
operator|<
name|unicode2
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
block|}
end_block
begin_comment
comment|/* support for extra glyphs not handled (well) in AGL; */
end_comment
begin_comment
comment|/* we add extra mappings for them if necessary         */
end_comment
begin_define
DECL|macro|EXTRA_GLYPH_LIST_SIZE
define|#
directive|define
name|EXTRA_GLYPH_LIST_SIZE
value|10
end_define
begin_decl_stmt
DECL|variable|ft_extra_glyph_unicodes
specifier|static
specifier|const
name|FT_UInt32
name|ft_extra_glyph_unicodes
index|[
name|EXTRA_GLYPH_LIST_SIZE
index|]
init|=
block|{
comment|/* WGL 4 */
literal|0x0394
block|,
literal|0x03A9
block|,
literal|0x2215
block|,
literal|0x00AD
block|,
literal|0x02C9
block|,
literal|0x03BC
block|,
literal|0x2219
block|,
literal|0x00A0
block|,
comment|/* Romanian */
literal|0x021A
block|,
literal|0x021B
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|ft_extra_glyph_names
specifier|static
specifier|const
name|char
name|ft_extra_glyph_names
index|[]
init|=
block|{
literal|'D'
block|,
literal|'e'
block|,
literal|'l'
block|,
literal|'t'
block|,
literal|'a'
block|,
literal|0
block|,
literal|'O'
block|,
literal|'m'
block|,
literal|'e'
block|,
literal|'g'
block|,
literal|'a'
block|,
literal|0
block|,
literal|'f'
block|,
literal|'r'
block|,
literal|'a'
block|,
literal|'c'
block|,
literal|'t'
block|,
literal|'i'
block|,
literal|'o'
block|,
literal|'n'
block|,
literal|0
block|,
literal|'h'
block|,
literal|'y'
block|,
literal|'p'
block|,
literal|'h'
block|,
literal|'e'
block|,
literal|'n'
block|,
literal|0
block|,
literal|'m'
block|,
literal|'a'
block|,
literal|'c'
block|,
literal|'r'
block|,
literal|'o'
block|,
literal|'n'
block|,
literal|0
block|,
literal|'m'
block|,
literal|'u'
block|,
literal|0
block|,
literal|'p'
block|,
literal|'e'
block|,
literal|'r'
block|,
literal|'i'
block|,
literal|'o'
block|,
literal|'d'
block|,
literal|'c'
block|,
literal|'e'
block|,
literal|'n'
block|,
literal|'t'
block|,
literal|'e'
block|,
literal|'r'
block|,
literal|'e'
block|,
literal|'d'
block|,
literal|0
block|,
literal|'s'
block|,
literal|'p'
block|,
literal|'a'
block|,
literal|'c'
block|,
literal|'e'
block|,
literal|0
block|,
literal|'T'
block|,
literal|'c'
block|,
literal|'o'
block|,
literal|'m'
block|,
literal|'m'
block|,
literal|'a'
block|,
literal|'a'
block|,
literal|'c'
block|,
literal|'c'
block|,
literal|'e'
block|,
literal|'n'
block|,
literal|'t'
block|,
literal|0
block|,
literal|'t'
block|,
literal|'c'
block|,
literal|'o'
block|,
literal|'m'
block|,
literal|'m'
block|,
literal|'a'
block|,
literal|'a'
block|,
literal|'c'
block|,
literal|'c'
block|,
literal|'e'
block|,
literal|'n'
block|,
literal|'t'
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
specifier|static
specifier|const
name|FT_Int
DECL|variable|ft_extra_glyph_name_offsets
name|ft_extra_glyph_name_offsets
index|[
name|EXTRA_GLYPH_LIST_SIZE
index|]
init|=
block|{
literal|0
block|,
literal|6
block|,
literal|12
block|,
literal|21
block|,
literal|28
block|,
literal|35
block|,
literal|38
block|,
literal|53
block|,
literal|59
block|,
literal|72
block|}
decl_stmt|;
end_decl_stmt
begin_function
specifier|static
name|void
DECL|function|ps_check_extra_glyph_name
name|ps_check_extra_glyph_name
parameter_list|(
specifier|const
name|char
modifier|*
name|gname
parameter_list|,
name|FT_UInt
name|glyph
parameter_list|,
name|FT_UInt
modifier|*
name|extra_glyphs
parameter_list|,
name|FT_UInt
modifier|*
name|states
parameter_list|)
block|{
name|FT_UInt
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|EXTRA_GLYPH_LIST_SIZE
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|ft_strcmp
argument_list|(
name|ft_extra_glyph_names
operator|+
name|ft_extra_glyph_name_offsets
index|[
name|n
index|]
argument_list|,
name|gname
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|states
index|[
name|n
index|]
operator|==
literal|0
condition|)
block|{
comment|/* mark this extra glyph as a candidate for the cmap */
name|states
index|[
name|n
index|]
operator|=
literal|1
expr_stmt|;
name|extra_glyphs
index|[
name|n
index|]
operator|=
name|glyph
expr_stmt|;
block|}
return|return;
block|}
block|}
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|ps_check_extra_glyph_unicode
name|ps_check_extra_glyph_unicode
parameter_list|(
name|FT_UInt32
name|uni_char
parameter_list|,
name|FT_UInt
modifier|*
name|states
parameter_list|)
block|{
name|FT_UInt
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|EXTRA_GLYPH_LIST_SIZE
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|uni_char
operator|==
name|ft_extra_glyph_unicodes
index|[
name|n
index|]
condition|)
block|{
comment|/* disable this extra glyph from being added to the cmap */
name|states
index|[
name|n
index|]
operator|=
literal|2
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function
begin_comment
comment|/* Build a table that maps Unicode values to glyph indices. */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|ps_unicodes_init
name|ps_unicodes_init
parameter_list|(
name|FT_Memory
name|memory
parameter_list|,
name|PS_Unicodes
name|table
parameter_list|,
name|FT_UInt
name|num_glyphs
parameter_list|,
name|PS_GetGlyphNameFunc
name|get_glyph_name
parameter_list|,
name|PS_FreeGlyphNameFunc
name|free_glyph_name
parameter_list|,
name|FT_Pointer
name|glyph_data
parameter_list|)
block|{
name|FT_Error
name|error
decl_stmt|;
name|FT_UInt
name|extra_glyph_list_states
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|FT_UInt
name|extra_glyphs
index|[
name|EXTRA_GLYPH_LIST_SIZE
index|]
decl_stmt|;
comment|/* we first allocate the table */
name|table
operator|->
name|num_maps
operator|=
literal|0
expr_stmt|;
name|table
operator|->
name|maps
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|FT_NEW_ARRAY
argument_list|(
name|table
operator|->
name|maps
argument_list|,
name|num_glyphs
operator|+
name|EXTRA_GLYPH_LIST_SIZE
argument_list|)
condition|)
block|{
name|FT_UInt
name|n
decl_stmt|;
name|FT_UInt
name|count
decl_stmt|;
name|PS_UniMap
modifier|*
name|map
decl_stmt|;
name|FT_UInt32
name|uni_char
decl_stmt|;
name|map
operator|=
name|table
operator|->
name|maps
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|num_glyphs
condition|;
name|n
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|gname
init|=
name|get_glyph_name
argument_list|(
name|glyph_data
argument_list|,
name|n
argument_list|)
decl_stmt|;
if|if
condition|(
name|gname
condition|)
block|{
name|ps_check_extra_glyph_name
argument_list|(
name|gname
argument_list|,
name|n
argument_list|,
name|extra_glyphs
argument_list|,
name|extra_glyph_list_states
argument_list|)
expr_stmt|;
name|uni_char
operator|=
name|ps_unicode_value
argument_list|(
name|gname
argument_list|)
expr_stmt|;
if|if
condition|(
name|BASE_GLYPH
argument_list|(
name|uni_char
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ps_check_extra_glyph_unicode
argument_list|(
name|uni_char
argument_list|,
name|extra_glyph_list_states
argument_list|)
expr_stmt|;
name|map
operator|->
name|unicode
operator|=
name|uni_char
expr_stmt|;
name|map
operator|->
name|glyph_index
operator|=
name|n
expr_stmt|;
name|map
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|free_glyph_name
condition|)
name|free_glyph_name
argument_list|(
name|glyph_data
argument_list|,
name|gname
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|EXTRA_GLYPH_LIST_SIZE
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|extra_glyph_list_states
index|[
name|n
index|]
operator|==
literal|1
condition|)
block|{
comment|/* This glyph name has an additional representation. */
comment|/* Add it to the cmap.                               */
name|map
operator|->
name|unicode
operator|=
name|ft_extra_glyph_unicodes
index|[
name|n
index|]
expr_stmt|;
name|map
operator|->
name|glyph_index
operator|=
name|extra_glyphs
index|[
name|n
index|]
expr_stmt|;
name|map
operator|++
expr_stmt|;
block|}
block|}
comment|/* now compress the table a bit */
name|count
operator|=
call|(
name|FT_UInt
call|)
argument_list|(
name|map
operator|-
name|table
operator|->
name|maps
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
name|FT_FREE
argument_list|(
name|table
operator|->
name|maps
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|PSnames_Err_Invalid_Argument
expr_stmt|;
comment|/* No unicode chars here! */
block|}
else|else
block|{
comment|/* Reallocate if the number of used entries is much smaller. */
if|if
condition|(
name|count
operator|<
name|num_glyphs
operator|/
literal|2
condition|)
block|{
operator|(
name|void
operator|)
name|FT_RENEW_ARRAY
argument_list|(
name|table
operator|->
name|maps
argument_list|,
name|num_glyphs
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|error
operator|=
name|PSnames_Err_Ok
expr_stmt|;
block|}
comment|/* Sort the table in increasing order of unicode values, */
comment|/* taking care of glyph variants.                        */
name|ft_qsort
argument_list|(
name|table
operator|->
name|maps
argument_list|,
name|count
argument_list|,
sizeof|sizeof
argument_list|(
name|PS_UniMap
argument_list|)
argument_list|,
name|compare_uni_maps
argument_list|)
expr_stmt|;
block|}
name|table
operator|->
name|num_maps
operator|=
name|count
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function
begin_function
specifier|static
name|FT_UInt
DECL|function|ps_unicodes_char_index
name|ps_unicodes_char_index
parameter_list|(
name|PS_Unicodes
name|table
parameter_list|,
name|FT_UInt32
name|unicode
parameter_list|)
block|{
name|PS_UniMap
modifier|*
name|min
decl_stmt|,
modifier|*
name|max
decl_stmt|,
modifier|*
name|mid
decl_stmt|,
modifier|*
name|result
init|=
name|NULL
decl_stmt|;
comment|/* Perform a binary search on the table. */
name|min
operator|=
name|table
operator|->
name|maps
expr_stmt|;
name|max
operator|=
name|min
operator|+
name|table
operator|->
name|num_maps
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|min
operator|<=
name|max
condition|)
block|{
name|FT_UInt32
name|base_glyph
decl_stmt|;
name|mid
operator|=
name|min
operator|+
operator|(
operator|(
name|max
operator|-
name|min
operator|)
operator|>>
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|mid
operator|->
name|unicode
operator|==
name|unicode
condition|)
block|{
name|result
operator|=
name|mid
expr_stmt|;
break|break;
block|}
name|base_glyph
operator|=
name|BASE_GLYPH
argument_list|(
name|mid
operator|->
name|unicode
argument_list|)
expr_stmt|;
if|if
condition|(
name|base_glyph
operator|==
name|unicode
condition|)
name|result
operator|=
name|mid
expr_stmt|;
comment|/* remember match but continue search for base glyph */
if|if
condition|(
name|min
operator|==
name|max
condition|)
break|break;
if|if
condition|(
name|base_glyph
operator|<
name|unicode
condition|)
name|min
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
else|else
name|max
operator|=
name|mid
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|result
condition|)
return|return
name|result
operator|->
name|glyph_index
return|;
else|else
return|return
literal|0
return|;
block|}
end_function
begin_function
specifier|static
name|FT_UInt32
DECL|function|ps_unicodes_char_next
name|ps_unicodes_char_next
parameter_list|(
name|PS_Unicodes
name|table
parameter_list|,
name|FT_UInt32
modifier|*
name|unicode
parameter_list|)
block|{
name|FT_UInt
name|result
init|=
literal|0
decl_stmt|;
name|FT_UInt32
name|char_code
init|=
operator|*
name|unicode
operator|+
literal|1
decl_stmt|;
block|{
name|FT_UInt
name|min
init|=
literal|0
decl_stmt|;
name|FT_UInt
name|max
init|=
name|table
operator|->
name|num_maps
decl_stmt|;
name|FT_UInt
name|mid
decl_stmt|;
name|PS_UniMap
modifier|*
name|map
decl_stmt|;
name|FT_UInt32
name|base_glyph
decl_stmt|;
while|while
condition|(
name|min
operator|<
name|max
condition|)
block|{
name|mid
operator|=
name|min
operator|+
operator|(
operator|(
name|max
operator|-
name|min
operator|)
operator|>>
literal|1
operator|)
expr_stmt|;
name|map
operator|=
name|table
operator|->
name|maps
operator|+
name|mid
expr_stmt|;
if|if
condition|(
name|map
operator|->
name|unicode
operator|==
name|char_code
condition|)
block|{
name|result
operator|=
name|map
operator|->
name|glyph_index
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|base_glyph
operator|=
name|BASE_GLYPH
argument_list|(
name|map
operator|->
name|unicode
argument_list|)
expr_stmt|;
if|if
condition|(
name|base_glyph
operator|==
name|char_code
condition|)
name|result
operator|=
name|map
operator|->
name|glyph_index
expr_stmt|;
if|if
condition|(
name|base_glyph
operator|<
name|char_code
condition|)
name|min
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
else|else
name|max
operator|=
name|mid
expr_stmt|;
block|}
if|if
condition|(
name|result
condition|)
goto|goto
name|Exit
goto|;
comment|/* we have a variant glyph */
comment|/* we didn't find it; check whether we have a map just above it */
name|char_code
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|min
operator|<
name|table
operator|->
name|num_maps
condition|)
block|{
name|map
operator|=
name|table
operator|->
name|maps
operator|+
name|min
expr_stmt|;
name|result
operator|=
name|map
operator|->
name|glyph_index
expr_stmt|;
name|char_code
operator|=
name|BASE_GLYPH
argument_list|(
name|map
operator|->
name|unicode
argument_list|)
expr_stmt|;
block|}
block|}
name|Exit
label|:
operator|*
name|unicode
operator|=
name|char_code
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* FT_CONFIG_OPTION_ADOBE_GLYPH_LIST */
end_comment
begin_function
specifier|static
specifier|const
name|char
modifier|*
DECL|function|ps_get_macintosh_name
name|ps_get_macintosh_name
parameter_list|(
name|FT_UInt
name|name_index
parameter_list|)
block|{
if|if
condition|(
name|name_index
operator|>=
name|FT_NUM_MAC_NAMES
condition|)
name|name_index
operator|=
literal|0
expr_stmt|;
return|return
name|ft_standard_glyph_names
operator|+
name|ft_mac_names
index|[
name|name_index
index|]
return|;
block|}
end_function
begin_function
specifier|static
specifier|const
name|char
modifier|*
DECL|function|ps_get_standard_strings
name|ps_get_standard_strings
parameter_list|(
name|FT_UInt
name|sid
parameter_list|)
block|{
if|if
condition|(
name|sid
operator|>=
name|FT_NUM_SID_NAMES
condition|)
return|return
literal|0
return|;
return|return
name|ft_standard_glyph_names
operator|+
name|ft_sid_names
index|[
name|sid
index|]
return|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|FT_CONFIG_OPTION_ADOBE_GLYPH_LIST
end_ifdef
begin_macro
name|FT_DEFINE_SERVICE_PSCMAPSREC
argument_list|(
argument|pscmaps_interface
argument_list|,
argument|(PS_Unicode_ValueFunc)     ps_unicode_value
argument_list|,
DECL|variable|ps_unicodes_init
argument|(PS_Unicodes_InitFunc)     ps_unicodes_init
argument_list|,
DECL|variable|ps_unicodes_char_index
argument|(PS_Unicodes_CharIndexFunc)ps_unicodes_char_index
argument_list|,
DECL|variable|ps_unicodes_char_next
argument|(PS_Unicodes_CharNextFunc) ps_unicodes_char_next
argument_list|,
DECL|variable|ps_get_macintosh_name
argument|(PS_Macintosh_NameFunc)    ps_get_macintosh_name
argument_list|,
DECL|variable|ps_get_standard_strings
argument|(PS_Adobe_Std_StringsFunc) ps_get_standard_strings
argument_list|,
DECL|variable|t1_standard_encoding
argument|t1_standard_encoding
argument_list|,
argument|t1_expert_encoding
argument_list|)
end_macro
begin_else
else|#
directive|else
end_else
begin_macro
name|FT_DEFINE_SERVICE_PSCMAPSREC
argument_list|(
argument|pscmaps_interface
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
argument|(PS_Macintosh_NameFunc)    ps_get_macintosh_name
argument_list|,
argument|(PS_Adobe_Std_StringsFunc) ps_get_standard_strings
argument_list|,
argument|t1_standard_encoding
argument_list|,
argument|t1_expert_encoding
argument_list|)
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* FT_CONFIG_OPTION_ADOBE_GLYPH_LIST */
end_comment
begin_macro
name|FT_DEFINE_SERVICEDESCREC1
argument_list|(
argument|pscmaps_services
argument_list|,
argument|FT_SERVICE_ID_POSTSCRIPT_CMAPS
argument_list|,
argument|&FT_PSCMAPS_INTERFACE_GET
argument_list|)
end_macro
begin_function
specifier|static
name|FT_Pointer
DECL|function|psnames_get_service
name|psnames_get_service
parameter_list|(
name|FT_Module
name|module
parameter_list|,
specifier|const
name|char
modifier|*
name|service_id
parameter_list|)
block|{
name|FT_UNUSED
argument_list|(
name|module
argument_list|)
expr_stmt|;
return|return
name|ft_service_list_lookup
argument_list|(
name|FT_PSCMAPS_SERVICES_GET
argument_list|,
name|service_id
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* FT_CONFIG_OPTION_POSTSCRIPT_NAMES */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|FT_CONFIG_OPTION_POSTSCRIPT_NAMES
end_ifndef
begin_define
DECL|macro|PUT_PS_NAMES_SERVICE
define|#
directive|define
name|PUT_PS_NAMES_SERVICE
parameter_list|(
name|a
parameter_list|)
value|0
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|PUT_PS_NAMES_SERVICE
define|#
directive|define
name|PUT_PS_NAMES_SERVICE
parameter_list|(
name|a
parameter_list|)
value|a
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_macro
name|FT_DEFINE_MODULE
argument_list|(
argument|psnames_module_class
argument_list|,
literal|0
argument_list|,
comment|/* this is not a font driver, nor a renderer */
argument|sizeof ( FT_ModuleRec )
argument_list|,
literal|"psnames"
argument_list|,
comment|/* driver name                         */
literal|0x10000L
argument_list|,
comment|/* driver version                      */
literal|0x20000L
argument_list|,
comment|/* driver requires FreeType 2 or above */
argument|PUT_PS_NAMES_SERVICE((void*)&FT_PSCMAPS_INTERFACE_GET)
argument_list|,
comment|/* module specific interface */
argument|(FT_Module_Constructor)
literal|0
argument_list|,
argument|(FT_Module_Destructor)
literal|0
argument_list|,
argument|(FT_Module_Requester)  PUT_PS_NAMES_SERVICE(psnames_get_service)
argument_list|)
end_macro
begin_comment
comment|/* END */
end_comment
end_unit
