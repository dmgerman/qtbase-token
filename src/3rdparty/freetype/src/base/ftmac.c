begin_unit
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  ftmac.c                                                                */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*    Mac FOND support.  Written by just@letterror.com.                    */
end_comment
begin_comment
comment|/*  Heavily modified by mpsuzuki, George Williams, and Sean McBride.       */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  This file is for Mac OS X only; see builds/mac/ftoldmac.c for          */
end_comment
begin_comment
comment|/*  classic platforms built by MPW.                                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  Copyright 1996-2009, 2013, 2014 by                                     */
end_comment
begin_comment
comment|/*  Just van Rossum, David Turner, Robert Wilhelm, and Werner Lemberg.     */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  This file is part of the FreeType project, and may only be used,       */
end_comment
begin_comment
comment|/*  modified, and distributed under the terms of the FreeType project      */
end_comment
begin_comment
comment|/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
end_comment
begin_comment
comment|/*  this file you indicate that you have read the license and              */
end_comment
begin_comment
comment|/*  understand and accept it fully.                                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*     Notes      Mac suitcase files can (and often do!) contain multiple fonts.  To     support this I use the face_index argument of FT_(Open|New)_Face()     functions, and pretend the suitcase file is a collection.      Warning: fbit and NFNT bitmap resources are not supported yet.  In old     sfnt fonts, bitmap glyph data for each size is stored in each `NFNT'     resources instead of the `bdat' table in the sfnt resource.  Therefore,     face->num_fixed_sizes is set to 0, because bitmap data in `NFNT'     resource is unavailable at present.      The Mac FOND support works roughly like this:      - Check whether the offered stream points to a Mac suitcase file.  This       is done by checking the file type: it has to be 'FFIL' or 'tfil'.  The       stream that gets passed to our init_face() routine is a stdio stream,       which isn't usable for us, since the FOND resources live in the       resource fork.  So we just grab the stream->pathname field.      - Read the FOND resource into memory, then check whether there is a       TrueType font and/or(!) a Type 1 font available.      - If there is a Type 1 font available (as a separate `LWFN' file), read       its data into memory, massage it slightly so it becomes PFB data, wrap       it into a memory stream, load the Type 1 driver and delegate the rest       of the work to it by calling FT_Open_Face().  (XXX TODO: after this       has been done, the kerning data from the FOND resource should be       appended to the face: On the Mac there are usually no AFM files       available.  However, this is tricky since we need to map Mac char       codes to ps glyph names to glyph ID's...)      - If there is a TrueType font (an `sfnt' resource), read it into memory,       wrap it into a memory stream, load the TrueType driver and delegate       the rest of the work to it, by calling FT_Open_Face().      - Some suitcase fonts (notably Onyx) might point the `LWFN' file to       itself, even though it doesn't contains `POST' resources.  To handle       this special case without opening the file an extra time, we just       ignore errors from the `LWFN' and fallback to the `sfnt' if both are       available.   */
end_comment
begin_include
include|#
directive|include
file|<ft2build.h>
end_include
begin_include
include|#
directive|include
include|FT_FREETYPE_H
end_include
begin_include
include|#
directive|include
include|FT_TRUETYPE_TAGS_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_STREAM_H
end_include
begin_include
include|#
directive|include
file|"ftbase.h"
end_include
begin_comment
comment|/* This is for Mac OS X.  Without redefinition, OS_INLINE */
end_comment
begin_comment
comment|/* expands to `static inline' which doesn't survive the   */
end_comment
begin_comment
comment|/* -ansi compilation flag of GCC.                         */
end_comment
begin_if
if|#
directive|if
operator|!
name|HAVE_ANSI_OS_INLINE
end_if
begin_undef
DECL|macro|OS_INLINE
undef|#
directive|undef
name|OS_INLINE
end_undef
begin_define
DECL|macro|OS_INLINE
define|#
directive|define
name|OS_INLINE
value|static __inline__
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* `configure' checks the availability of `ResourceIndex' strictly */
end_comment
begin_comment
comment|/* and sets HAVE_TYPE_RESOURCE_INDEX 1 or 0 always.  If it is      */
end_comment
begin_comment
comment|/* not set (e.g., a build without `configure'), the availability   */
end_comment
begin_comment
comment|/* is guessed from the SDK version.                                */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_TYPE_RESOURCE_INDEX
end_ifndef
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MAC_OS_X_VERSION_10_5
argument_list|)
operator|||
expr|\
operator|(
name|MAC_OS_X_VERSION_MAX_ALLOWED
operator|<
name|MAC_OS_X_VERSION_10_5
operator|)
end_if
begin_define
DECL|macro|HAVE_TYPE_RESOURCE_INDEX
define|#
directive|define
name|HAVE_TYPE_RESOURCE_INDEX
value|0
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|HAVE_TYPE_RESOURCE_INDEX
define|#
directive|define
name|HAVE_TYPE_RESOURCE_INDEX
value|1
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* !HAVE_TYPE_RESOURCE_INDEX */
end_comment
begin_if
if|#
directive|if
operator|(
name|HAVE_TYPE_RESOURCE_INDEX
operator|==
literal|0
operator|)
end_if
begin_typedef
DECL|typedef|ResourceIndex
typedef|typedef
name|short
name|ResourceIndex
typedef|;
end_typedef
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|<CoreServices/CoreServices.h>
end_include
begin_include
include|#
directive|include
file|<ApplicationServices/ApplicationServices.h>
end_include
begin_include
include|#
directive|include
file|<sys/syslimits.h>
end_include
begin_comment
comment|/* PATH_MAX */
end_comment
begin_comment
comment|/* Don't want warnings about our own use of deprecated functions. */
end_comment
begin_define
DECL|macro|FT_DEPRECATED_ATTRIBUTE
define|#
directive|define
name|FT_DEPRECATED_ATTRIBUTE
end_define
begin_include
include|#
directive|include
include|FT_MAC_H
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|kATSOptionFlagsUnRestrictedScope
end_ifndef
begin_comment
comment|/* since Mac OS X 10.1 */
end_comment
begin_define
DECL|macro|kATSOptionFlagsUnRestrictedScope
define|#
directive|define
name|kATSOptionFlagsUnRestrictedScope
value|kATSOptionFlagsDefault
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* Set PREFER_LWFN to 1 if LWFN (Type 1) is preferred over      TrueType in case *both* are available (this is not common,      but it *is* possible). */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|PREFER_LWFN
end_ifndef
begin_define
DECL|macro|PREFER_LWFN
define|#
directive|define
name|PREFER_LWFN
value|1
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|FT_MACINTOSH
end_ifdef
begin_comment
comment|/* This function is deprecated because FSSpec is deprecated in Mac OS X  */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_GetFile_From_Mac_Name
argument_list|(
argument|const char*  fontName
argument_list|,
argument|FSSpec*      pathSpec
argument_list|,
argument|FT_Long*     face_index
argument_list|)
end_macro
begin_block
block|{
name|FT_UNUSED
argument_list|(
name|fontName
argument_list|)
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|pathSpec
argument_list|)
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|face_index
argument_list|)
expr_stmt|;
return|return
name|FT_THROW
argument_list|(
name|Unimplemented_Feature
argument_list|)
return|;
block|}
end_block
begin_comment
comment|/* Private function.                                         */
end_comment
begin_comment
comment|/* The FSSpec type has been discouraged for a long time,     */
end_comment
begin_comment
comment|/* unfortunately an FSRef replacement API for                */
end_comment
begin_comment
comment|/* ATSFontGetFileSpecification() is only available in        */
end_comment
begin_comment
comment|/* Mac OS X 10.5 and later.                                  */
end_comment
begin_function
specifier|static
name|OSStatus
DECL|function|FT_ATSFontGetFileReference
name|FT_ATSFontGetFileReference
parameter_list|(
name|ATSFontRef
name|ats_font_id
parameter_list|,
name|FSRef
modifier|*
name|ats_font_ref
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|MAC_OS_X_VERSION_10_5
argument_list|)
operator|&&
expr|\
operator|(
name|MAC_OS_X_VERSION_MIN_REQUIRED
operator|>=
name|MAC_OS_X_VERSION_10_5
operator|)
name|OSStatus
name|err
decl_stmt|;
name|err
operator|=
name|ATSFontGetFileReference
argument_list|(
name|ats_font_id
argument_list|,
name|ats_font_ref
argument_list|)
expr_stmt|;
return|return
name|err
return|;
elif|#
directive|elif
name|__LP64__
comment|/* No 64bit Carbon API on legacy platforms */
name|FT_UNUSED
argument_list|(
name|ats_font_id
argument_list|)
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|ats_font_ref
argument_list|)
expr_stmt|;
return|return
name|fnfErr
return|;
else|#
directive|else
comment|/* 32bit Carbon API on legacy platforms */
name|OSStatus
name|err
decl_stmt|;
name|FSSpec
name|spec
decl_stmt|;
name|err
operator|=
name|ATSFontGetFileSpecification
argument_list|(
name|ats_font_id
argument_list|,
operator|&
name|spec
argument_list|)
expr_stmt|;
if|if
condition|(
name|noErr
operator|==
name|err
condition|)
name|err
operator|=
name|FSpMakeFSRef
argument_list|(
operator|&
name|spec
argument_list|,
name|ats_font_ref
argument_list|)
expr_stmt|;
return|return
name|err
return|;
endif|#
directive|endif
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|FT_GetFileRef_From_Mac_ATS_Name
name|FT_GetFileRef_From_Mac_ATS_Name
parameter_list|(
specifier|const
name|char
modifier|*
name|fontName
parameter_list|,
name|FSRef
modifier|*
name|ats_font_ref
parameter_list|,
name|FT_Long
modifier|*
name|face_index
parameter_list|)
block|{
name|CFStringRef
name|cf_fontName
decl_stmt|;
name|ATSFontRef
name|ats_font_id
decl_stmt|;
operator|*
name|face_index
operator|=
literal|0
expr_stmt|;
name|cf_fontName
operator|=
name|CFStringCreateWithCString
argument_list|(
name|NULL
argument_list|,
name|fontName
argument_list|,
name|kCFStringEncodingMacRoman
argument_list|)
expr_stmt|;
name|ats_font_id
operator|=
name|ATSFontFindFromName
argument_list|(
name|cf_fontName
argument_list|,
name|kATSOptionFlagsUnRestrictedScope
argument_list|)
expr_stmt|;
name|CFRelease
argument_list|(
name|cf_fontName
argument_list|)
expr_stmt|;
if|if
condition|(
name|ats_font_id
operator|==
literal|0
operator|||
name|ats_font_id
operator|==
literal|0xFFFFFFFFUL
condition|)
return|return
name|FT_THROW
argument_list|(
name|Unknown_File_Format
argument_list|)
return|;
if|if
condition|(
name|noErr
operator|!=
name|FT_ATSFontGetFileReference
argument_list|(
name|ats_font_id
argument_list|,
name|ats_font_ref
argument_list|)
condition|)
return|return
name|FT_THROW
argument_list|(
name|Unknown_File_Format
argument_list|)
return|;
comment|/* face_index calculation by searching preceding fontIDs */
comment|/* with same FSRef                                       */
block|{
name|ATSFontRef
name|id2
init|=
name|ats_font_id
operator|-
literal|1
decl_stmt|;
name|FSRef
name|ref2
decl_stmt|;
while|while
condition|(
name|id2
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|noErr
operator|!=
name|FT_ATSFontGetFileReference
argument_list|(
name|id2
argument_list|,
operator|&
name|ref2
argument_list|)
condition|)
break|break;
if|if
condition|(
name|noErr
operator|!=
name|FSCompareFSRefs
argument_list|(
name|ats_font_ref
argument_list|,
operator|&
name|ref2
argument_list|)
condition|)
break|break;
name|id2
operator|--
expr_stmt|;
block|}
operator|*
name|face_index
operator|=
name|ats_font_id
operator|-
operator|(
name|id2
operator|+
literal|1
operator|)
expr_stmt|;
block|}
return|return
name|FT_Err_Ok
return|;
block|}
end_function
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_GetFilePath_From_Mac_ATS_Name
argument_list|(
argument|const char*  fontName
argument_list|,
argument|UInt8*       path
argument_list|,
argument|UInt32       maxPathSize
argument_list|,
argument|FT_Long*     face_index
argument_list|)
end_macro
begin_block
block|{
name|FSRef
name|ref
decl_stmt|;
name|FT_Error
name|err
decl_stmt|;
if|if
condition|(
operator|!
name|fontName
operator|||
operator|!
name|face_index
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_Argument
argument_list|)
return|;
name|err
operator|=
name|FT_GetFileRef_From_Mac_ATS_Name
argument_list|(
name|fontName
argument_list|,
operator|&
name|ref
argument_list|,
name|face_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
if|if
condition|(
name|noErr
operator|!=
name|FSRefMakePath
argument_list|(
operator|&
name|ref
argument_list|,
name|path
argument_list|,
name|maxPathSize
argument_list|)
condition|)
return|return
name|FT_THROW
argument_list|(
name|Unknown_File_Format
argument_list|)
return|;
return|return
name|FT_Err_Ok
return|;
block|}
end_block
begin_comment
comment|/* This function is deprecated because FSSpec is deprecated in Mac OS X  */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_GetFile_From_Mac_ATS_Name
argument_list|(
argument|const char*  fontName
argument_list|,
argument|FSSpec*      pathSpec
argument_list|,
argument|FT_Long*     face_index
argument_list|)
end_macro
begin_block
block|{
if|#
directive|if
operator|(
name|__LP64__
operator|)
operator|||
operator|(
name|defined
argument_list|(
name|MAC_OS_X_VERSION_10_5
argument_list|)
operator|&&
expr|\
operator|(
name|MAC_OS_X_VERSION_MIN_REQUIRED
operator|>=
name|MAC_OS_X_VERSION_10_5
operator|)
operator|)
name|FT_UNUSED
argument_list|(
name|fontName
argument_list|)
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|pathSpec
argument_list|)
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|face_index
argument_list|)
expr_stmt|;
return|return
name|FT_THROW
argument_list|(
name|Unimplemented_Feature
argument_list|)
return|;
else|#
directive|else
name|FSRef
name|ref
decl_stmt|;
name|FT_Error
name|err
decl_stmt|;
if|if
condition|(
operator|!
name|fontName
operator|||
operator|!
name|face_index
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_Argument
argument_list|)
return|;
name|err
operator|=
name|FT_GetFileRef_From_Mac_ATS_Name
argument_list|(
name|fontName
argument_list|,
operator|&
name|ref
argument_list|,
name|face_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
if|if
condition|(
name|noErr
operator|!=
name|FSGetCatalogInfo
argument_list|(
operator|&
name|ref
argument_list|,
name|kFSCatInfoNone
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pathSpec
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
name|FT_THROW
argument_list|(
name|Unknown_File_Format
argument_list|)
return|;
return|return
name|FT_Err_Ok
return|;
endif|#
directive|endif
block|}
end_block
begin_function
specifier|static
name|OSErr
DECL|function|FT_FSPathMakeRes
name|FT_FSPathMakeRes
parameter_list|(
specifier|const
name|UInt8
modifier|*
name|pathname
parameter_list|,
name|ResFileRefNum
modifier|*
name|res
parameter_list|)
block|{
name|OSErr
name|err
decl_stmt|;
name|FSRef
name|ref
decl_stmt|;
if|if
condition|(
name|noErr
operator|!=
name|FSPathMakeRef
argument_list|(
name|pathname
argument_list|,
operator|&
name|ref
argument_list|,
name|FALSE
argument_list|)
condition|)
return|return
name|FT_THROW
argument_list|(
name|Cannot_Open_Resource
argument_list|)
return|;
comment|/* at present, no support for dfont format */
name|err
operator|=
name|FSOpenResourceFile
argument_list|(
operator|&
name|ref
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|fsRdPerm
argument_list|,
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|noErr
operator|==
name|err
condition|)
return|return
name|err
return|;
comment|/* fallback to original resource-fork font */
operator|*
name|res
operator|=
name|FSOpenResFile
argument_list|(
operator|&
name|ref
argument_list|,
name|fsRdPerm
argument_list|)
expr_stmt|;
name|err
operator|=
name|ResError
argument_list|()
expr_stmt|;
return|return
name|err
return|;
block|}
end_function
begin_comment
comment|/* Return the file type for given pathname */
end_comment
begin_function
specifier|static
name|OSType
DECL|function|get_file_type_from_path
name|get_file_type_from_path
parameter_list|(
specifier|const
name|UInt8
modifier|*
name|pathname
parameter_list|)
block|{
name|FSRef
name|ref
decl_stmt|;
name|FSCatalogInfo
name|info
decl_stmt|;
if|if
condition|(
name|noErr
operator|!=
name|FSPathMakeRef
argument_list|(
name|pathname
argument_list|,
operator|&
name|ref
argument_list|,
name|FALSE
argument_list|)
condition|)
return|return
operator|(
name|OSType
operator|)
literal|0
return|;
if|if
condition|(
name|noErr
operator|!=
name|FSGetCatalogInfo
argument_list|(
operator|&
name|ref
argument_list|,
name|kFSCatInfoFinderInfo
argument_list|,
operator|&
name|info
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|(
name|OSType
operator|)
literal|0
return|;
return|return
operator|(
operator|(
name|FInfo
operator|*
operator|)
operator|(
name|info
operator|.
name|finderInfo
operator|)
operator|)
operator|->
name|fdType
return|;
block|}
end_function
begin_comment
comment|/* Given a PostScript font name, create the Macintosh LWFN file name. */
end_comment
begin_function
specifier|static
name|void
DECL|function|create_lwfn_name
name|create_lwfn_name
parameter_list|(
name|char
modifier|*
name|ps_name
parameter_list|,
name|Str255
name|lwfn_file_name
parameter_list|)
block|{
name|int
name|max
init|=
literal|5
decl_stmt|,
name|count
init|=
literal|0
decl_stmt|;
name|FT_Byte
modifier|*
name|p
init|=
name|lwfn_file_name
decl_stmt|;
name|FT_Byte
modifier|*
name|q
init|=
operator|(
name|FT_Byte
operator|*
operator|)
name|ps_name
decl_stmt|;
name|lwfn_file_name
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|q
condition|)
block|{
if|if
condition|(
name|ft_isupper
argument_list|(
operator|*
name|q
argument_list|)
condition|)
block|{
if|if
condition|(
name|count
condition|)
name|max
operator|=
literal|3
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|<
name|max
operator|&&
operator|(
name|ft_isalnum
argument_list|(
operator|*
name|q
argument_list|)
operator|||
operator|*
name|q
operator|==
literal|'_'
operator|)
condition|)
block|{
operator|*
operator|++
name|p
operator|=
operator|*
name|q
expr_stmt|;
name|lwfn_file_name
index|[
literal|0
index|]
operator|++
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
name|q
operator|++
expr_stmt|;
block|}
block|}
end_function
begin_function
specifier|static
name|short
DECL|function|count_faces_sfnt
name|count_faces_sfnt
parameter_list|(
name|char
modifier|*
name|fond_data
parameter_list|)
block|{
comment|/* The count is 1 greater than the value in the FOND.  */
comment|/* Isn't that cute? :-)                                */
return|return
name|EndianS16_BtoN
argument_list|(
operator|*
operator|(
operator|(
name|short
operator|*
operator|)
operator|(
name|fond_data
operator|+
sizeof|sizeof
argument_list|(
name|FamRec
argument_list|)
operator|)
operator|)
argument_list|)
operator|+
literal|1
return|;
block|}
end_function
begin_function
specifier|static
name|short
DECL|function|count_faces_scalable
name|count_faces_scalable
parameter_list|(
name|char
modifier|*
name|fond_data
parameter_list|)
block|{
name|AsscEntry
modifier|*
name|assoc
decl_stmt|;
name|short
name|i
decl_stmt|,
name|face
decl_stmt|,
name|face_all
decl_stmt|;
name|face_all
operator|=
name|EndianS16_BtoN
argument_list|(
operator|*
operator|(
operator|(
name|short
operator|*
operator|)
operator|(
name|fond_data
operator|+
sizeof|sizeof
argument_list|(
name|FamRec
argument_list|)
operator|)
operator|)
argument_list|)
operator|+
literal|1
expr_stmt|;
name|assoc
operator|=
operator|(
name|AsscEntry
operator|*
operator|)
operator|(
name|fond_data
operator|+
sizeof|sizeof
argument_list|(
name|FamRec
argument_list|)
operator|+
literal|2
operator|)
expr_stmt|;
name|face
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|face_all
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
literal|0
operator|==
name|EndianS16_BtoN
argument_list|(
name|assoc
index|[
name|i
index|]
operator|.
name|fontSize
argument_list|)
condition|)
name|face
operator|++
expr_stmt|;
block|}
return|return
name|face
return|;
block|}
end_function
begin_comment
comment|/* Look inside the FOND data, answer whether there should be an SFNT      resource, and answer the name of a possible LWFN Type 1 file.       Thanks to Paul Miller (paulm@profoundeffects.com) for the fix      to load a face OTHER than the first one in the FOND!   */
end_comment
begin_function
specifier|static
name|void
DECL|function|parse_fond
name|parse_fond
parameter_list|(
name|char
modifier|*
name|fond_data
parameter_list|,
name|short
modifier|*
name|have_sfnt
parameter_list|,
name|ResID
modifier|*
name|sfnt_id
parameter_list|,
name|Str255
name|lwfn_file_name
parameter_list|,
name|short
name|face_index
parameter_list|)
block|{
name|AsscEntry
modifier|*
name|assoc
decl_stmt|;
name|AsscEntry
modifier|*
name|base_assoc
decl_stmt|;
name|FamRec
modifier|*
name|fond
decl_stmt|;
operator|*
name|sfnt_id
operator|=
literal|0
expr_stmt|;
operator|*
name|have_sfnt
operator|=
literal|0
expr_stmt|;
name|lwfn_file_name
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|fond
operator|=
operator|(
name|FamRec
operator|*
operator|)
name|fond_data
expr_stmt|;
name|assoc
operator|=
operator|(
name|AsscEntry
operator|*
operator|)
operator|(
name|fond_data
operator|+
sizeof|sizeof
argument_list|(
name|FamRec
argument_list|)
operator|+
literal|2
operator|)
expr_stmt|;
name|base_assoc
operator|=
name|assoc
expr_stmt|;
comment|/* the maximum faces in a FOND is 48, size of StyleTable.indexes[] */
if|if
condition|(
literal|47
operator|<
name|face_index
condition|)
return|return;
comment|/* Let's do a little range checking before we get too excited here */
if|if
condition|(
name|face_index
operator|<
name|count_faces_sfnt
argument_list|(
name|fond_data
argument_list|)
condition|)
block|{
name|assoc
operator|+=
name|face_index
expr_stmt|;
comment|/* add on the face_index! */
comment|/* if the face at this index is not scalable,          fall back to the first one (old behavior) */
if|if
condition|(
name|EndianS16_BtoN
argument_list|(
name|assoc
operator|->
name|fontSize
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|have_sfnt
operator|=
literal|1
expr_stmt|;
operator|*
name|sfnt_id
operator|=
name|EndianS16_BtoN
argument_list|(
name|assoc
operator|->
name|fontID
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|base_assoc
operator|->
name|fontSize
operator|==
literal|0
condition|)
block|{
operator|*
name|have_sfnt
operator|=
literal|1
expr_stmt|;
operator|*
name|sfnt_id
operator|=
name|EndianS16_BtoN
argument_list|(
name|base_assoc
operator|->
name|fontID
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|EndianS32_BtoN
argument_list|(
name|fond
operator|->
name|ffStylOff
argument_list|)
condition|)
block|{
name|unsigned
name|char
modifier|*
name|p
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|fond_data
decl_stmt|;
name|StyleTable
modifier|*
name|style
decl_stmt|;
name|unsigned
name|short
name|string_count
decl_stmt|;
name|char
name|ps_name
index|[
literal|256
index|]
decl_stmt|;
name|unsigned
name|char
modifier|*
name|names
index|[
literal|64
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|p
operator|+=
name|EndianS32_BtoN
argument_list|(
name|fond
operator|->
name|ffStylOff
argument_list|)
expr_stmt|;
name|style
operator|=
operator|(
name|StyleTable
operator|*
operator|)
name|p
expr_stmt|;
name|p
operator|+=
sizeof|sizeof
argument_list|(
name|StyleTable
argument_list|)
expr_stmt|;
name|string_count
operator|=
name|EndianS16_BtoN
argument_list|(
operator|*
operator|(
name|short
operator|*
operator|)
operator|(
name|p
operator|)
argument_list|)
expr_stmt|;
name|string_count
operator|=
name|FT_MIN
argument_list|(
literal|64
argument_list|,
name|string_count
argument_list|)
expr_stmt|;
name|p
operator|+=
sizeof|sizeof
argument_list|(
name|short
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|string_count
condition|;
name|i
operator|++
control|)
block|{
name|names
index|[
name|i
index|]
operator|=
name|p
expr_stmt|;
name|p
operator|+=
name|names
index|[
name|i
index|]
index|[
literal|0
index|]
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
block|{
name|size_t
name|ps_name_len
init|=
operator|(
name|size_t
operator|)
name|names
index|[
literal|0
index|]
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
name|ps_name_len
operator|!=
literal|0
condition|)
block|{
name|ft_memcpy
argument_list|(
name|ps_name
argument_list|,
name|names
index|[
literal|0
index|]
operator|+
literal|1
argument_list|,
name|ps_name_len
argument_list|)
expr_stmt|;
name|ps_name
index|[
name|ps_name_len
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|style
operator|->
name|indexes
index|[
name|face_index
index|]
operator|>
literal|1
operator|&&
name|style
operator|->
name|indexes
index|[
name|face_index
index|]
operator|<=
name|string_count
condition|)
block|{
name|unsigned
name|char
modifier|*
name|suffixes
init|=
name|names
index|[
name|style
operator|->
name|indexes
index|[
name|face_index
index|]
operator|-
literal|1
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|suffixes
index|[
literal|0
index|]
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|char
modifier|*
name|s
decl_stmt|;
name|size_t
name|j
init|=
name|suffixes
index|[
name|i
index|]
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|j
operator|<
name|string_count
operator|&&
operator|(
name|s
operator|=
name|names
index|[
name|j
index|]
operator|)
operator|!=
name|NULL
condition|)
block|{
name|size_t
name|s_len
init|=
operator|(
name|size_t
operator|)
name|s
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
name|s_len
operator|!=
literal|0
operator|&&
name|ps_name_len
operator|+
name|s_len
operator|<
sizeof|sizeof
argument_list|(
name|ps_name
argument_list|)
condition|)
block|{
name|ft_memcpy
argument_list|(
name|ps_name
operator|+
name|ps_name_len
argument_list|,
name|s
operator|+
literal|1
argument_list|,
name|s_len
argument_list|)
expr_stmt|;
name|ps_name_len
operator|+=
name|s_len
expr_stmt|;
name|ps_name
index|[
name|ps_name_len
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
name|create_lwfn_name
argument_list|(
name|ps_name
argument_list|,
name|lwfn_file_name
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|lookup_lwfn_by_fond
name|lookup_lwfn_by_fond
parameter_list|(
specifier|const
name|UInt8
modifier|*
name|path_fond
parameter_list|,
name|ConstStr255Param
name|base_lwfn
parameter_list|,
name|UInt8
modifier|*
name|path_lwfn
parameter_list|,
name|size_t
name|path_size
parameter_list|)
block|{
name|FSRef
name|ref
decl_stmt|,
name|par_ref
decl_stmt|;
name|size_t
name|dirname_len
decl_stmt|;
comment|/* Pathname for FSRef can be in various formats: HFS, HFS+, and POSIX. */
comment|/* We should not extract parent directory by string manipulation.      */
if|if
condition|(
name|noErr
operator|!=
name|FSPathMakeRef
argument_list|(
name|path_fond
argument_list|,
operator|&
name|ref
argument_list|,
name|FALSE
argument_list|)
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_Argument
argument_list|)
return|;
if|if
condition|(
name|noErr
operator|!=
name|FSGetCatalogInfo
argument_list|(
operator|&
name|ref
argument_list|,
name|kFSCatInfoNone
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|par_ref
argument_list|)
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_Argument
argument_list|)
return|;
if|if
condition|(
name|noErr
operator|!=
name|FSRefMakePath
argument_list|(
operator|&
name|par_ref
argument_list|,
name|path_lwfn
argument_list|,
name|path_size
argument_list|)
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_Argument
argument_list|)
return|;
if|if
condition|(
name|ft_strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|path_lwfn
argument_list|)
operator|+
literal|1
operator|+
name|base_lwfn
index|[
literal|0
index|]
operator|>
name|path_size
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_Argument
argument_list|)
return|;
comment|/* now we have absolute dirname in path_lwfn */
name|ft_strcat
argument_list|(
operator|(
name|char
operator|*
operator|)
name|path_lwfn
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|dirname_len
operator|=
name|ft_strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|path_lwfn
argument_list|)
expr_stmt|;
name|ft_strcat
argument_list|(
operator|(
name|char
operator|*
operator|)
name|path_lwfn
argument_list|,
operator|(
name|char
operator|*
operator|)
name|base_lwfn
operator|+
literal|1
argument_list|)
expr_stmt|;
name|path_lwfn
index|[
name|dirname_len
operator|+
name|base_lwfn
index|[
literal|0
index|]
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|noErr
operator|!=
name|FSPathMakeRef
argument_list|(
name|path_lwfn
argument_list|,
operator|&
name|ref
argument_list|,
name|FALSE
argument_list|)
condition|)
return|return
name|FT_THROW
argument_list|(
name|Cannot_Open_Resource
argument_list|)
return|;
if|if
condition|(
name|noErr
operator|!=
name|FSGetCatalogInfo
argument_list|(
operator|&
name|ref
argument_list|,
name|kFSCatInfoNone
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
name|FT_THROW
argument_list|(
name|Cannot_Open_Resource
argument_list|)
return|;
return|return
name|FT_Err_Ok
return|;
block|}
end_function
begin_function
specifier|static
name|short
DECL|function|count_faces
name|count_faces
parameter_list|(
name|Handle
name|fond
parameter_list|,
specifier|const
name|UInt8
modifier|*
name|pathname
parameter_list|)
block|{
name|ResID
name|sfnt_id
decl_stmt|;
name|short
name|have_sfnt
decl_stmt|,
name|have_lwfn
decl_stmt|;
name|Str255
name|lwfn_file_name
decl_stmt|;
name|UInt8
name|buff
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|FT_Error
name|err
decl_stmt|;
name|short
name|num_faces
decl_stmt|;
name|have_sfnt
operator|=
name|have_lwfn
operator|=
literal|0
expr_stmt|;
name|parse_fond
argument_list|(
operator|*
name|fond
argument_list|,
operator|&
name|have_sfnt
argument_list|,
operator|&
name|sfnt_id
argument_list|,
name|lwfn_file_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|lwfn_file_name
index|[
literal|0
index|]
condition|)
block|{
name|err
operator|=
name|lookup_lwfn_by_fond
argument_list|(
name|pathname
argument_list|,
name|lwfn_file_name
argument_list|,
name|buff
argument_list|,
sizeof|sizeof
argument_list|(
name|buff
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
name|have_lwfn
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|have_lwfn
operator|&&
operator|(
operator|!
name|have_sfnt
operator|||
name|PREFER_LWFN
operator|)
condition|)
name|num_faces
operator|=
literal|1
expr_stmt|;
else|else
name|num_faces
operator|=
name|count_faces_scalable
argument_list|(
operator|*
name|fond
argument_list|)
expr_stmt|;
return|return
name|num_faces
return|;
block|}
end_function
begin_comment
comment|/* Read Type 1 data from the POST resources inside the LWFN file,      return a PFB buffer.  This is somewhat convoluted because the FT2      PFB parser wants the ASCII header as one chunk, and the LWFN      chunks are often not organized that way, so we glue chunks      of the same type together. */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|read_lwfn
name|read_lwfn
parameter_list|(
name|FT_Memory
name|memory
parameter_list|,
name|ResFileRefNum
name|res
parameter_list|,
name|FT_Byte
modifier|*
modifier|*
name|pfb_data
parameter_list|,
name|FT_ULong
modifier|*
name|size
parameter_list|)
block|{
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
name|ResID
name|res_id
decl_stmt|;
name|unsigned
name|char
modifier|*
name|buffer
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|size_p
init|=
name|NULL
decl_stmt|;
name|FT_ULong
name|total_size
init|=
literal|0
decl_stmt|;
name|FT_ULong
name|old_total_size
init|=
literal|0
decl_stmt|;
name|FT_ULong
name|post_size
decl_stmt|,
name|pfb_chunk_size
decl_stmt|;
name|Handle
name|post_data
decl_stmt|;
name|char
name|code
decl_stmt|,
name|last_code
decl_stmt|;
name|UseResFile
argument_list|(
name|res
argument_list|)
expr_stmt|;
comment|/* First pass: load all POST resources, and determine the size of */
comment|/* the output buffer.                                             */
name|res_id
operator|=
literal|501
expr_stmt|;
name|last_code
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|post_data
operator|=
name|Get1Resource
argument_list|(
name|TTAG_POST
argument_list|,
name|res_id
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|post_data
operator|==
name|NULL
condition|)
break|break;
comment|/* we are done */
name|code
operator|=
operator|(
operator|*
name|post_data
operator|)
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|code
operator|!=
name|last_code
condition|)
block|{
if|if
condition|(
name|code
operator|==
literal|5
condition|)
name|total_size
operator|+=
literal|2
expr_stmt|;
comment|/* just the end code */
else|else
name|total_size
operator|+=
literal|6
expr_stmt|;
comment|/* code + 4 bytes chunk length */
block|}
name|total_size
operator|+=
name|GetHandleSize
argument_list|(
name|post_data
argument_list|)
operator|-
literal|2
expr_stmt|;
name|last_code
operator|=
name|code
expr_stmt|;
comment|/* detect integer overflows */
if|if
condition|(
name|total_size
operator|<
name|old_total_size
condition|)
block|{
name|error
operator|=
name|FT_THROW
argument_list|(
name|Array_Too_Large
argument_list|)
expr_stmt|;
goto|goto
name|Error
goto|;
block|}
name|old_total_size
operator|=
name|total_size
expr_stmt|;
block|}
if|if
condition|(
name|FT_ALLOC
argument_list|(
name|buffer
argument_list|,
operator|(
name|FT_Long
operator|)
name|total_size
argument_list|)
condition|)
goto|goto
name|Error
goto|;
comment|/* Second pass: append all POST data to the buffer, add PFB fields. */
comment|/* Glue all consecutive chunks of the same type together.           */
name|p
operator|=
name|buffer
expr_stmt|;
name|res_id
operator|=
literal|501
expr_stmt|;
name|last_code
operator|=
operator|-
literal|1
expr_stmt|;
name|pfb_chunk_size
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|post_data
operator|=
name|Get1Resource
argument_list|(
name|TTAG_POST
argument_list|,
name|res_id
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|post_data
operator|==
name|NULL
condition|)
break|break;
comment|/* we are done */
name|post_size
operator|=
operator|(
name|FT_ULong
operator|)
name|GetHandleSize
argument_list|(
name|post_data
argument_list|)
operator|-
literal|2
expr_stmt|;
name|code
operator|=
operator|(
operator|*
name|post_data
operator|)
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|code
operator|!=
name|last_code
condition|)
block|{
if|if
condition|(
name|last_code
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* we are done adding a chunk, fill in the size field */
if|if
condition|(
name|size_p
operator|!=
name|NULL
condition|)
block|{
operator|*
name|size_p
operator|++
operator|=
call|(
name|FT_Byte
call|)
argument_list|(
name|pfb_chunk_size
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
operator|*
name|size_p
operator|++
operator|=
call|(
name|FT_Byte
call|)
argument_list|(
operator|(
name|pfb_chunk_size
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
operator|*
name|size_p
operator|++
operator|=
call|(
name|FT_Byte
call|)
argument_list|(
operator|(
name|pfb_chunk_size
operator|>>
literal|16
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
operator|*
name|size_p
operator|++
operator|=
call|(
name|FT_Byte
call|)
argument_list|(
operator|(
name|pfb_chunk_size
operator|>>
literal|24
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
block|}
name|pfb_chunk_size
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|p
operator|++
operator|=
literal|0x80
expr_stmt|;
if|if
condition|(
name|code
operator|==
literal|5
condition|)
operator|*
name|p
operator|++
operator|=
literal|0x03
expr_stmt|;
comment|/* the end */
elseif|else
if|if
condition|(
name|code
operator|==
literal|2
condition|)
operator|*
name|p
operator|++
operator|=
literal|0x02
expr_stmt|;
comment|/* binary segment */
else|else
operator|*
name|p
operator|++
operator|=
literal|0x01
expr_stmt|;
comment|/* ASCII segment */
if|if
condition|(
name|code
operator|!=
literal|5
condition|)
block|{
name|size_p
operator|=
name|p
expr_stmt|;
comment|/* save for later */
name|p
operator|+=
literal|4
expr_stmt|;
comment|/* make space for size field */
block|}
block|}
name|ft_memcpy
argument_list|(
name|p
argument_list|,
operator|*
name|post_data
operator|+
literal|2
argument_list|,
name|post_size
argument_list|)
expr_stmt|;
name|pfb_chunk_size
operator|+=
name|post_size
expr_stmt|;
name|p
operator|+=
name|post_size
expr_stmt|;
name|last_code
operator|=
name|code
expr_stmt|;
block|}
operator|*
name|pfb_data
operator|=
name|buffer
expr_stmt|;
operator|*
name|size
operator|=
name|total_size
expr_stmt|;
name|Error
label|:
name|CloseResFile
argument_list|(
name|res
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_comment
comment|/* Create a new FT_Face from a file path to an LWFN file. */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|FT_New_Face_From_LWFN
name|FT_New_Face_From_LWFN
parameter_list|(
name|FT_Library
name|library
parameter_list|,
specifier|const
name|UInt8
modifier|*
name|pathname
parameter_list|,
name|FT_Long
name|face_index
parameter_list|,
name|FT_Face
modifier|*
name|aface
parameter_list|)
block|{
name|FT_Byte
modifier|*
name|pfb_data
decl_stmt|;
name|FT_ULong
name|pfb_size
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|ResFileRefNum
name|res
decl_stmt|;
if|if
condition|(
name|noErr
operator|!=
name|FT_FSPathMakeRes
argument_list|(
name|pathname
argument_list|,
operator|&
name|res
argument_list|)
condition|)
return|return
name|FT_THROW
argument_list|(
name|Cannot_Open_Resource
argument_list|)
return|;
name|pfb_data
operator|=
name|NULL
expr_stmt|;
name|pfb_size
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|read_lwfn
argument_list|(
name|library
operator|->
name|memory
argument_list|,
name|res
argument_list|,
operator|&
name|pfb_data
argument_list|,
operator|&
name|pfb_size
argument_list|)
expr_stmt|;
name|CloseResFile
argument_list|(
name|res
argument_list|)
expr_stmt|;
comment|/* PFB is already loaded, useless anymore */
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
return|return
name|open_face_from_buffer
argument_list|(
name|library
argument_list|,
name|pfb_data
argument_list|,
name|pfb_size
argument_list|,
name|face_index
argument_list|,
literal|"type1"
argument_list|,
name|aface
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/* Create a new FT_Face from an SFNT resource, specified by res ID. */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|FT_New_Face_From_SFNT
name|FT_New_Face_From_SFNT
parameter_list|(
name|FT_Library
name|library
parameter_list|,
name|ResID
name|sfnt_id
parameter_list|,
name|FT_Long
name|face_index
parameter_list|,
name|FT_Face
modifier|*
name|aface
parameter_list|)
block|{
name|Handle
name|sfnt
init|=
name|NULL
decl_stmt|;
name|FT_Byte
modifier|*
name|sfnt_data
decl_stmt|;
name|size_t
name|sfnt_size
decl_stmt|;
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|library
operator|->
name|memory
decl_stmt|;
name|int
name|is_cff
decl_stmt|,
name|is_sfnt_ps
decl_stmt|;
name|sfnt
operator|=
name|GetResource
argument_list|(
name|TTAG_sfnt
argument_list|,
name|sfnt_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|sfnt
operator|==
name|NULL
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_Handle
argument_list|)
return|;
name|sfnt_size
operator|=
operator|(
name|FT_ULong
operator|)
name|GetHandleSize
argument_list|(
name|sfnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|FT_ALLOC
argument_list|(
name|sfnt_data
argument_list|,
operator|(
name|FT_Long
operator|)
name|sfnt_size
argument_list|)
condition|)
block|{
name|ReleaseResource
argument_list|(
name|sfnt
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|ft_memcpy
argument_list|(
name|sfnt_data
argument_list|,
operator|*
name|sfnt
argument_list|,
name|sfnt_size
argument_list|)
expr_stmt|;
name|ReleaseResource
argument_list|(
name|sfnt
argument_list|)
expr_stmt|;
name|is_cff
operator|=
name|sfnt_size
operator|>
literal|4
operator|&&
operator|!
name|ft_memcmp
argument_list|(
name|sfnt_data
argument_list|,
literal|"OTTO"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|is_sfnt_ps
operator|=
name|sfnt_size
operator|>
literal|4
operator|&&
operator|!
name|ft_memcmp
argument_list|(
name|sfnt_data
argument_list|,
literal|"typ1"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_sfnt_ps
condition|)
block|{
name|FT_Stream
name|stream
decl_stmt|;
if|if
condition|(
name|FT_NEW
argument_list|(
name|stream
argument_list|)
condition|)
goto|goto
name|Try_OpenType
goto|;
name|FT_Stream_OpenMemory
argument_list|(
name|stream
argument_list|,
name|sfnt_data
argument_list|,
name|sfnt_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|open_face_PS_from_sfnt_stream
argument_list|(
name|library
argument_list|,
name|stream
argument_list|,
name|face_index
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|aface
argument_list|)
condition|)
block|{
name|FT_Stream_Close
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|sfnt_data
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|FT_FREE
argument_list|(
name|stream
argument_list|)
expr_stmt|;
block|}
name|Try_OpenType
label|:
name|error
operator|=
name|open_face_from_buffer
argument_list|(
name|library
argument_list|,
name|sfnt_data
argument_list|,
name|sfnt_size
argument_list|,
name|face_index
argument_list|,
name|is_cff
condition|?
literal|"cff"
else|:
literal|"truetype"
argument_list|,
name|aface
argument_list|)
expr_stmt|;
name|Exit
label|:
return|return
name|error
return|;
block|}
end_function
begin_comment
comment|/* Create a new FT_Face from a file path to a suitcase file. */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|FT_New_Face_From_Suitcase
name|FT_New_Face_From_Suitcase
parameter_list|(
name|FT_Library
name|library
parameter_list|,
specifier|const
name|UInt8
modifier|*
name|pathname
parameter_list|,
name|FT_Long
name|face_index
parameter_list|,
name|FT_Face
modifier|*
name|aface
parameter_list|)
block|{
name|FT_Error
name|error
init|=
name|FT_ERR
argument_list|(
name|Cannot_Open_Resource
argument_list|)
decl_stmt|;
name|ResFileRefNum
name|res_ref
decl_stmt|;
name|ResourceIndex
name|res_index
decl_stmt|;
name|Handle
name|fond
decl_stmt|;
name|short
name|num_faces_in_res
decl_stmt|;
if|if
condition|(
name|noErr
operator|!=
name|FT_FSPathMakeRes
argument_list|(
name|pathname
argument_list|,
operator|&
name|res_ref
argument_list|)
condition|)
return|return
name|FT_THROW
argument_list|(
name|Cannot_Open_Resource
argument_list|)
return|;
name|UseResFile
argument_list|(
name|res_ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|ResError
argument_list|()
condition|)
return|return
name|FT_THROW
argument_list|(
name|Cannot_Open_Resource
argument_list|)
return|;
name|num_faces_in_res
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|res_index
operator|=
literal|1
init|;
condition|;
operator|++
name|res_index
control|)
block|{
name|short
name|num_faces_in_fond
decl_stmt|;
name|fond
operator|=
name|Get1IndResource
argument_list|(
name|TTAG_FOND
argument_list|,
name|res_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|ResError
argument_list|()
condition|)
break|break;
name|num_faces_in_fond
operator|=
name|count_faces
argument_list|(
name|fond
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
name|num_faces_in_res
operator|+=
name|num_faces_in_fond
expr_stmt|;
if|if
condition|(
literal|0
operator|<=
name|face_index
operator|&&
name|face_index
operator|<
name|num_faces_in_fond
operator|&&
name|error
condition|)
name|error
operator|=
name|FT_New_Face_From_FOND
argument_list|(
name|library
argument_list|,
name|fond
argument_list|,
name|face_index
argument_list|,
name|aface
argument_list|)
expr_stmt|;
name|face_index
operator|-=
name|num_faces_in_fond
expr_stmt|;
block|}
name|CloseResFile
argument_list|(
name|res_ref
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
name|aface
operator|&&
operator|*
name|aface
condition|)
operator|(
operator|*
name|aface
operator|)
operator|->
name|num_faces
operator|=
name|num_faces_in_res
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_comment
comment|/* documentation is in ftmac.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_New_Face_From_FOND
argument_list|(
argument|FT_Library  library
argument_list|,
argument|Handle      fond
argument_list|,
argument|FT_Long     face_index
argument_list|,
argument|FT_Face*    aface
argument_list|)
end_macro
begin_block
block|{
name|short
name|have_sfnt
decl_stmt|,
name|have_lwfn
init|=
literal|0
decl_stmt|;
name|ResID
name|sfnt_id
decl_stmt|,
name|fond_id
decl_stmt|;
name|OSType
name|fond_type
decl_stmt|;
name|Str255
name|fond_name
decl_stmt|;
name|Str255
name|lwfn_file_name
decl_stmt|;
name|UInt8
name|path_lwfn
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|OSErr
name|err
decl_stmt|;
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
comment|/* check of `library' and `aface' delayed to `FT_New_Face_From_XXX' */
name|GetResInfo
argument_list|(
name|fond
argument_list|,
operator|&
name|fond_id
argument_list|,
operator|&
name|fond_type
argument_list|,
name|fond_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ResError
argument_list|()
operator|!=
name|noErr
operator|||
name|fond_type
operator|!=
name|TTAG_FOND
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_File_Format
argument_list|)
return|;
name|parse_fond
argument_list|(
operator|*
name|fond
argument_list|,
operator|&
name|have_sfnt
argument_list|,
operator|&
name|sfnt_id
argument_list|,
name|lwfn_file_name
argument_list|,
name|face_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|lwfn_file_name
index|[
literal|0
index|]
condition|)
block|{
name|ResFileRefNum
name|res
decl_stmt|;
name|res
operator|=
name|HomeResFile
argument_list|(
name|fond
argument_list|)
expr_stmt|;
if|if
condition|(
name|noErr
operator|!=
name|ResError
argument_list|()
condition|)
goto|goto
name|found_no_lwfn_file
goto|;
block|{
name|UInt8
name|path_fond
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|FSRef
name|ref
decl_stmt|;
name|err
operator|=
name|FSGetForkCBInfo
argument_list|(
name|res
argument_list|,
name|kFSInvalidVolumeRefNum
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|ref
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|noErr
operator|!=
name|err
condition|)
goto|goto
name|found_no_lwfn_file
goto|;
name|err
operator|=
name|FSRefMakePath
argument_list|(
operator|&
name|ref
argument_list|,
name|path_fond
argument_list|,
sizeof|sizeof
argument_list|(
name|path_fond
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|noErr
operator|!=
name|err
condition|)
goto|goto
name|found_no_lwfn_file
goto|;
name|error
operator|=
name|lookup_lwfn_by_fond
argument_list|(
name|path_fond
argument_list|,
name|lwfn_file_name
argument_list|,
name|path_lwfn
argument_list|,
sizeof|sizeof
argument_list|(
name|path_lwfn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|have_lwfn
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|have_lwfn
operator|&&
operator|(
operator|!
name|have_sfnt
operator|||
name|PREFER_LWFN
operator|)
condition|)
name|error
operator|=
name|FT_New_Face_From_LWFN
argument_list|(
name|library
argument_list|,
name|path_lwfn
argument_list|,
name|face_index
argument_list|,
name|aface
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|FT_THROW
argument_list|(
name|Unknown_File_Format
argument_list|)
expr_stmt|;
name|found_no_lwfn_file
label|:
if|if
condition|(
name|have_sfnt
operator|&&
name|error
condition|)
name|error
operator|=
name|FT_New_Face_From_SFNT
argument_list|(
name|library
argument_list|,
name|sfnt_id
argument_list|,
name|face_index
argument_list|,
name|aface
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/* Common function to load a new FT_Face from a resource file. */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|FT_New_Face_From_Resource
name|FT_New_Face_From_Resource
parameter_list|(
name|FT_Library
name|library
parameter_list|,
specifier|const
name|UInt8
modifier|*
name|pathname
parameter_list|,
name|FT_Long
name|face_index
parameter_list|,
name|FT_Face
modifier|*
name|aface
parameter_list|)
block|{
name|OSType
name|file_type
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
comment|/* LWFN is a (very) specific file format, check for it explicitly */
name|file_type
operator|=
name|get_file_type_from_path
argument_list|(
name|pathname
argument_list|)
expr_stmt|;
if|if
condition|(
name|file_type
operator|==
name|TTAG_LWFN
condition|)
return|return
name|FT_New_Face_From_LWFN
argument_list|(
name|library
argument_list|,
name|pathname
argument_list|,
name|face_index
argument_list|,
name|aface
argument_list|)
return|;
comment|/* Otherwise the file type doesn't matter (there are more than  */
comment|/* `FFIL' and `tfil').  Just try opening it as a font suitcase; */
comment|/* if it works, fine.                                           */
name|error
operator|=
name|FT_New_Face_From_Suitcase
argument_list|(
name|library
argument_list|,
name|pathname
argument_list|,
name|face_index
argument_list|,
name|aface
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
return|return
name|error
return|;
comment|/* let it fall through to normal loader (.ttf, .otf, etc.); */
comment|/* we signal this by returning no error and no FT_Face      */
operator|*
name|aface
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    FT_New_Face                                                        */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    This is the Mac-specific implementation of FT_New_Face.  In        */
end_comment
begin_comment
comment|/*    addition to the standard FT_New_Face() functionality, it also      */
end_comment
begin_comment
comment|/*    accepts pathnames to Mac suitcase files.  For further              */
end_comment
begin_comment
comment|/*    documentation see the original FT_New_Face() in freetype.h.        */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_New_Face
argument_list|(
argument|FT_Library   library
argument_list|,
argument|const char*  pathname
argument_list|,
argument|FT_Long      face_index
argument_list|,
argument|FT_Face*     aface
argument_list|)
end_macro
begin_block
block|{
name|FT_Open_Args
name|args
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
comment|/* test for valid `library' and `aface' delayed to FT_Open_Face() */
if|if
condition|(
operator|!
name|pathname
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_Argument
argument_list|)
return|;
operator|*
name|aface
operator|=
name|NULL
expr_stmt|;
comment|/* try resourcefork based font: LWFN, FFIL */
name|error
operator|=
name|FT_New_Face_From_Resource
argument_list|(
name|library
argument_list|,
operator|(
name|UInt8
operator|*
operator|)
name|pathname
argument_list|,
name|face_index
argument_list|,
name|aface
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
operator|*
name|aface
operator|!=
name|NULL
condition|)
return|return
name|error
return|;
comment|/* let it fall through to normal loader (.ttf, .otf, etc.) */
name|args
operator|.
name|flags
operator|=
name|FT_OPEN_PATHNAME
expr_stmt|;
name|args
operator|.
name|pathname
operator|=
operator|(
name|char
operator|*
operator|)
name|pathname
expr_stmt|;
return|return
name|FT_Open_Face
argument_list|(
name|library
argument_list|,
operator|&
name|args
argument_list|,
name|face_index
argument_list|,
name|aface
argument_list|)
return|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    FT_New_Face_From_FSRef                                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    FT_New_Face_From_FSRef is identical to FT_New_Face except it       */
end_comment
begin_comment
comment|/*    accepts an FSRef instead of a path.                                */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* This function is deprecated because Carbon data types (FSRef)         */
end_comment
begin_comment
comment|/* are not cross-platform, and thus not suitable for the freetype API.   */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_New_Face_From_FSRef
argument_list|(
argument|FT_Library    library
argument_list|,
argument|const FSRef*  ref
argument_list|,
argument|FT_Long       face_index
argument_list|,
argument|FT_Face*      aface
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
decl_stmt|;
name|FT_Open_Args
name|args
decl_stmt|;
name|OSErr
name|err
decl_stmt|;
name|UInt8
name|pathname
index|[
name|PATH_MAX
index|]
decl_stmt|;
comment|/* check of `library' and `aface' delayed to */
comment|/* `FT_New_Face_From_Resource'               */
if|if
condition|(
operator|!
name|ref
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_Argument
argument_list|)
return|;
name|err
operator|=
name|FSRefMakePath
argument_list|(
name|ref
argument_list|,
name|pathname
argument_list|,
sizeof|sizeof
argument_list|(
name|pathname
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|error
operator|=
name|FT_THROW
argument_list|(
name|Cannot_Open_Resource
argument_list|)
expr_stmt|;
name|error
operator|=
name|FT_New_Face_From_Resource
argument_list|(
name|library
argument_list|,
name|pathname
argument_list|,
name|face_index
argument_list|,
name|aface
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
operator|*
name|aface
operator|!=
name|NULL
condition|)
return|return
name|error
return|;
comment|/* fallback to datafork font */
name|args
operator|.
name|flags
operator|=
name|FT_OPEN_PATHNAME
expr_stmt|;
name|args
operator|.
name|pathname
operator|=
operator|(
name|char
operator|*
operator|)
name|pathname
expr_stmt|;
return|return
name|FT_Open_Face
argument_list|(
name|library
argument_list|,
operator|&
name|args
argument_list|,
name|face_index
argument_list|,
name|aface
argument_list|)
return|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    FT_New_Face_From_FSSpec                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    FT_New_Face_From_FSSpec is identical to FT_New_Face except it      */
end_comment
begin_comment
comment|/*    accepts an FSSpec instead of a path.                               */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* This function is deprecated because FSSpec is deprecated in Mac OS X  */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_New_Face_From_FSSpec
argument_list|(
argument|FT_Library     library
argument_list|,
argument|const FSSpec*  spec
argument_list|,
argument|FT_Long        face_index
argument_list|,
argument|FT_Face*       aface
argument_list|)
end_macro
begin_block
block|{
if|#
directive|if
operator|(
name|__LP64__
operator|)
operator|||
operator|(
name|defined
argument_list|(
name|MAC_OS_X_VERSION_10_5
argument_list|)
operator|&&
expr|\
operator|(
name|MAC_OS_X_VERSION_MIN_REQUIRED
operator|>=
name|MAC_OS_X_VERSION_10_5
operator|)
operator|)
name|FT_UNUSED
argument_list|(
name|library
argument_list|)
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|spec
argument_list|)
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|face_index
argument_list|)
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|aface
argument_list|)
expr_stmt|;
return|return
name|FT_THROW
argument_list|(
name|Unimplemented_Feature
argument_list|)
return|;
else|#
directive|else
name|FSRef
name|ref
decl_stmt|;
comment|/* check of `library' and `aface' delayed to `FT_New_Face_From_FSRef' */
if|if
condition|(
operator|!
name|spec
operator|||
name|FSpMakeFSRef
argument_list|(
name|spec
argument_list|,
operator|&
name|ref
argument_list|)
operator|!=
name|noErr
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_Argument
argument_list|)
return|;
else|else
return|return
name|FT_New_Face_From_FSRef
argument_list|(
name|library
argument_list|,
operator|&
name|ref
argument_list|,
name|face_index
argument_list|,
name|aface
argument_list|)
return|;
endif|#
directive|endif
block|}
end_block
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* FT_MACINTOSH */
end_comment
begin_comment
comment|/* END */
end_comment
end_unit
