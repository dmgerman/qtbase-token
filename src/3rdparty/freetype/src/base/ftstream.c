begin_unit
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  ftstream.c                                                             */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*    I/O stream support (body).                                           */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  Copyright 2000-2001, 2002, 2004, 2005, 2006, 2008, 2009 by             */
end_comment
begin_comment
comment|/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  This file is part of the FreeType project, and may only be used,       */
end_comment
begin_comment
comment|/*  modified, and distributed under the terms of the FreeType project      */
end_comment
begin_comment
comment|/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
end_comment
begin_comment
comment|/*  this file you indicate that you have read the license and              */
end_comment
begin_comment
comment|/*  understand and accept it fully.                                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<ft2build.h>
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_STREAM_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_DEBUG_H
end_include
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
end_comment
begin_comment
comment|/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
end_comment
begin_comment
comment|/* messages during execution.                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_undef
DECL|macro|FT_COMPONENT
undef|#
directive|undef
name|FT_COMPONENT
end_undef
begin_define
DECL|macro|FT_COMPONENT
define|#
directive|define
name|FT_COMPONENT
value|trace_stream
end_define
begin_macro
name|FT_BASE_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|FT_Stream_OpenMemory
name|FT_Stream_OpenMemory
argument_list|(
argument|FT_Stream       stream
argument_list|,
argument|const FT_Byte*  base
argument_list|,
argument|FT_ULong        size
argument_list|)
end_macro
begin_block
block|{
name|stream
operator|->
name|base
operator|=
operator|(
name|FT_Byte
operator|*
operator|)
name|base
expr_stmt|;
name|stream
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|stream
operator|->
name|pos
operator|=
literal|0
expr_stmt|;
name|stream
operator|->
name|cursor
operator|=
literal|0
expr_stmt|;
name|stream
operator|->
name|read
operator|=
literal|0
expr_stmt|;
name|stream
operator|->
name|close
operator|=
literal|0
expr_stmt|;
block|}
end_block
begin_macro
name|FT_BASE_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|FT_Stream_Close
name|FT_Stream_Close
argument_list|(
argument|FT_Stream  stream
argument_list|)
end_macro
begin_block
block|{
if|if
condition|(
name|stream
operator|&&
name|stream
operator|->
name|close
condition|)
name|stream
operator|->
name|close
argument_list|(
name|stream
argument_list|)
expr_stmt|;
block|}
end_block
begin_macro
DECL|function|FT_BASE_DEF
name|FT_BASE_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_Stream_Seek
argument_list|(
argument|FT_Stream  stream
argument_list|,
argument|FT_ULong   pos
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
if|if
condition|(
name|stream
operator|->
name|read
condition|)
block|{
if|if
condition|(
name|stream
operator|->
name|read
argument_list|(
name|stream
argument_list|,
name|pos
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"FT_Stream_Seek:"
literal|" invalid i/o; pos = 0x%lx, size = 0x%lx\n"
operator|,
name|pos
operator|,
name|stream
operator|->
name|size
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|FT_Err_Invalid_Stream_Operation
expr_stmt|;
block|}
block|}
comment|/* note that seeking to the first position after the file is valid */
elseif|else
if|if
condition|(
name|pos
operator|>
name|stream
operator|->
name|size
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"FT_Stream_Seek:"
literal|" invalid i/o; pos = 0x%lx, size = 0x%lx\n"
operator|,
name|pos
operator|,
name|stream
operator|->
name|size
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|FT_Err_Invalid_Stream_Operation
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|error
condition|)
name|stream
operator|->
name|pos
operator|=
name|pos
expr_stmt|;
return|return
name|error
return|;
block|}
end_block
begin_macro
DECL|function|FT_BASE_DEF
name|FT_BASE_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_Stream_Skip
argument_list|(
argument|FT_Stream  stream
argument_list|,
argument|FT_Long    distance
argument_list|)
end_macro
begin_block
block|{
if|if
condition|(
name|distance
operator|<
literal|0
condition|)
return|return
name|FT_Err_Invalid_Stream_Operation
return|;
return|return
name|FT_Stream_Seek
argument_list|(
name|stream
argument_list|,
call|(
name|FT_ULong
call|)
argument_list|(
name|stream
operator|->
name|pos
operator|+
name|distance
argument_list|)
argument_list|)
return|;
block|}
end_block
begin_macro
DECL|function|FT_BASE_DEF
name|FT_BASE_DEF
argument_list|(
argument|FT_Long
argument_list|)
end_macro
begin_macro
name|FT_Stream_Pos
argument_list|(
argument|FT_Stream  stream
argument_list|)
end_macro
begin_block
block|{
return|return
name|stream
operator|->
name|pos
return|;
block|}
end_block
begin_macro
DECL|function|FT_BASE_DEF
name|FT_BASE_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_Stream_Read
argument_list|(
argument|FT_Stream  stream
argument_list|,
argument|FT_Byte*   buffer
argument_list|,
argument|FT_ULong   count
argument_list|)
end_macro
begin_block
block|{
return|return
name|FT_Stream_ReadAt
argument_list|(
name|stream
argument_list|,
name|stream
operator|->
name|pos
argument_list|,
name|buffer
argument_list|,
name|count
argument_list|)
return|;
block|}
end_block
begin_macro
DECL|function|FT_BASE_DEF
name|FT_BASE_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_Stream_ReadAt
argument_list|(
argument|FT_Stream  stream
argument_list|,
argument|FT_ULong   pos
argument_list|,
argument|FT_Byte*   buffer
argument_list|,
argument|FT_ULong   count
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
name|FT_ULong
name|read_bytes
decl_stmt|;
if|if
condition|(
name|pos
operator|>=
name|stream
operator|->
name|size
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"FT_Stream_ReadAt:"
literal|" invalid i/o; pos = 0x%lx, size = 0x%lx\n"
operator|,
name|pos
operator|,
name|stream
operator|->
name|size
operator|)
argument_list|)
expr_stmt|;
return|return
name|FT_Err_Invalid_Stream_Operation
return|;
block|}
if|if
condition|(
name|stream
operator|->
name|read
condition|)
name|read_bytes
operator|=
name|stream
operator|->
name|read
argument_list|(
name|stream
argument_list|,
name|pos
argument_list|,
name|buffer
argument_list|,
name|count
argument_list|)
expr_stmt|;
else|else
block|{
name|read_bytes
operator|=
name|stream
operator|->
name|size
operator|-
name|pos
expr_stmt|;
if|if
condition|(
name|read_bytes
operator|>
name|count
condition|)
name|read_bytes
operator|=
name|count
expr_stmt|;
name|FT_MEM_COPY
argument_list|(
name|buffer
argument_list|,
name|stream
operator|->
name|base
operator|+
name|pos
argument_list|,
name|read_bytes
argument_list|)
expr_stmt|;
block|}
name|stream
operator|->
name|pos
operator|=
name|pos
operator|+
name|read_bytes
expr_stmt|;
if|if
condition|(
name|read_bytes
operator|<
name|count
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"FT_Stream_ReadAt:"
literal|" invalid read; expected %lu bytes, got %lu\n"
operator|,
name|count
operator|,
name|read_bytes
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|FT_Err_Invalid_Stream_Operation
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_block
begin_macro
DECL|function|FT_BASE_DEF
name|FT_BASE_DEF
argument_list|(
argument|FT_ULong
argument_list|)
end_macro
begin_macro
name|FT_Stream_TryRead
argument_list|(
argument|FT_Stream  stream
argument_list|,
argument|FT_Byte*   buffer
argument_list|,
argument|FT_ULong   count
argument_list|)
end_macro
begin_block
block|{
name|FT_ULong
name|read_bytes
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|stream
operator|->
name|pos
operator|>=
name|stream
operator|->
name|size
condition|)
goto|goto
name|Exit
goto|;
if|if
condition|(
name|stream
operator|->
name|read
condition|)
name|read_bytes
operator|=
name|stream
operator|->
name|read
argument_list|(
name|stream
argument_list|,
name|stream
operator|->
name|pos
argument_list|,
name|buffer
argument_list|,
name|count
argument_list|)
expr_stmt|;
else|else
block|{
name|read_bytes
operator|=
name|stream
operator|->
name|size
operator|-
name|stream
operator|->
name|pos
expr_stmt|;
if|if
condition|(
name|read_bytes
operator|>
name|count
condition|)
name|read_bytes
operator|=
name|count
expr_stmt|;
name|FT_MEM_COPY
argument_list|(
name|buffer
argument_list|,
name|stream
operator|->
name|base
operator|+
name|stream
operator|->
name|pos
argument_list|,
name|read_bytes
argument_list|)
expr_stmt|;
block|}
name|stream
operator|->
name|pos
operator|+=
name|read_bytes
expr_stmt|;
name|Exit
label|:
return|return
name|read_bytes
return|;
block|}
end_block
begin_macro
DECL|function|FT_BASE_DEF
name|FT_BASE_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_Stream_ExtractFrame
argument_list|(
argument|FT_Stream  stream
argument_list|,
argument|FT_ULong   count
argument_list|,
argument|FT_Byte**  pbytes
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
decl_stmt|;
name|error
operator|=
name|FT_Stream_EnterFrame
argument_list|(
name|stream
argument_list|,
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
operator|*
name|pbytes
operator|=
operator|(
name|FT_Byte
operator|*
operator|)
name|stream
operator|->
name|cursor
expr_stmt|;
comment|/* equivalent to FT_Stream_ExitFrame(), with no memory block release */
name|stream
operator|->
name|cursor
operator|=
literal|0
expr_stmt|;
name|stream
operator|->
name|limit
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_block
begin_macro
name|FT_BASE_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|FT_Stream_ReleaseFrame
name|FT_Stream_ReleaseFrame
argument_list|(
argument|FT_Stream  stream
argument_list|,
argument|FT_Byte**  pbytes
argument_list|)
end_macro
begin_block
block|{
if|if
condition|(
name|stream
operator|&&
name|stream
operator|->
name|read
condition|)
block|{
name|FT_Memory
name|memory
init|=
name|stream
operator|->
name|memory
decl_stmt|;
ifdef|#
directive|ifdef
name|FT_DEBUG_MEMORY
name|ft_mem_free
argument_list|(
name|memory
argument_list|,
operator|*
name|pbytes
argument_list|)
expr_stmt|;
operator|*
name|pbytes
operator|=
name|NULL
expr_stmt|;
else|#
directive|else
name|FT_FREE
argument_list|(
operator|*
name|pbytes
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
operator|*
name|pbytes
operator|=
literal|0
expr_stmt|;
block|}
end_block
begin_macro
DECL|function|FT_BASE_DEF
name|FT_BASE_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_Stream_EnterFrame
argument_list|(
argument|FT_Stream  stream
argument_list|,
argument|FT_ULong   count
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
name|FT_ULong
name|read_bytes
decl_stmt|;
comment|/* check for nested frame access */
name|FT_ASSERT
argument_list|(
name|stream
operator|&&
name|stream
operator|->
name|cursor
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|stream
operator|->
name|read
condition|)
block|{
comment|/* allocate the frame in memory */
name|FT_Memory
name|memory
init|=
name|stream
operator|->
name|memory
decl_stmt|;
ifdef|#
directive|ifdef
name|FT_DEBUG_MEMORY
comment|/* assume _ft_debug_file and _ft_debug_lineno are already set */
name|stream
operator|->
name|base
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ft_mem_qalloc
argument_list|(
name|memory
argument_list|,
name|count
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
else|#
directive|else
if|if
condition|(
name|FT_QALLOC
argument_list|(
name|stream
operator|->
name|base
argument_list|,
name|count
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
endif|#
directive|endif
comment|/* read it */
name|read_bytes
operator|=
name|stream
operator|->
name|read
argument_list|(
name|stream
argument_list|,
name|stream
operator|->
name|pos
argument_list|,
name|stream
operator|->
name|base
argument_list|,
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_bytes
operator|<
name|count
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"FT_Stream_EnterFrame:"
literal|" invalid read; expected %lu bytes, got %lu\n"
operator|,
name|count
operator|,
name|read_bytes
operator|)
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|stream
operator|->
name|base
argument_list|)
expr_stmt|;
name|error
operator|=
name|FT_Err_Invalid_Stream_Operation
expr_stmt|;
block|}
name|stream
operator|->
name|cursor
operator|=
name|stream
operator|->
name|base
expr_stmt|;
name|stream
operator|->
name|limit
operator|=
name|stream
operator|->
name|cursor
operator|+
name|count
expr_stmt|;
name|stream
operator|->
name|pos
operator|+=
name|read_bytes
expr_stmt|;
block|}
else|else
block|{
comment|/* check current and new position */
if|if
condition|(
name|stream
operator|->
name|pos
operator|>=
name|stream
operator|->
name|size
operator|||
name|stream
operator|->
name|pos
operator|+
name|count
operator|>
name|stream
operator|->
name|size
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"FT_Stream_EnterFrame:"
literal|" invalid i/o; pos = 0x%lx, count = %lu, size = 0x%lx\n"
operator|,
name|stream
operator|->
name|pos
operator|,
name|count
operator|,
name|stream
operator|->
name|size
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|FT_Err_Invalid_Stream_Operation
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* set cursor */
name|stream
operator|->
name|cursor
operator|=
name|stream
operator|->
name|base
operator|+
name|stream
operator|->
name|pos
expr_stmt|;
name|stream
operator|->
name|limit
operator|=
name|stream
operator|->
name|cursor
operator|+
name|count
expr_stmt|;
name|stream
operator|->
name|pos
operator|+=
name|count
expr_stmt|;
block|}
name|Exit
label|:
return|return
name|error
return|;
block|}
end_block
begin_macro
name|FT_BASE_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|FT_Stream_ExitFrame
name|FT_Stream_ExitFrame
argument_list|(
argument|FT_Stream  stream
argument_list|)
end_macro
begin_block
block|{
comment|/* IMPORTANT: The assertion stream->cursor != 0 was removed, given    */
comment|/*            that it is possible to access a frame of length 0 in    */
comment|/*            some weird fonts (usually, when accessing an array of   */
comment|/*            0 records, like in some strange kern tables).           */
comment|/*                                                                    */
comment|/*  In this case, the loader code handles the 0-length table          */
comment|/*  gracefully; however, stream.cursor is really set to 0 by the      */
comment|/*  FT_Stream_EnterFrame() call, and this is not an error.            */
comment|/*                                                                    */
name|FT_ASSERT
argument_list|(
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|stream
operator|->
name|read
condition|)
block|{
name|FT_Memory
name|memory
init|=
name|stream
operator|->
name|memory
decl_stmt|;
ifdef|#
directive|ifdef
name|FT_DEBUG_MEMORY
name|ft_mem_free
argument_list|(
name|memory
argument_list|,
name|stream
operator|->
name|base
argument_list|)
expr_stmt|;
name|stream
operator|->
name|base
operator|=
name|NULL
expr_stmt|;
else|#
directive|else
name|FT_FREE
argument_list|(
name|stream
operator|->
name|base
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|stream
operator|->
name|cursor
operator|=
literal|0
expr_stmt|;
name|stream
operator|->
name|limit
operator|=
literal|0
expr_stmt|;
block|}
end_block
begin_macro
DECL|function|FT_BASE_DEF
name|FT_BASE_DEF
argument_list|(
argument|FT_Char
argument_list|)
end_macro
begin_macro
name|FT_Stream_GetChar
argument_list|(
argument|FT_Stream  stream
argument_list|)
end_macro
begin_block
block|{
name|FT_Char
name|result
decl_stmt|;
name|FT_ASSERT
argument_list|(
name|stream
operator|&&
name|stream
operator|->
name|cursor
argument_list|)
expr_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|stream
operator|->
name|cursor
operator|<
name|stream
operator|->
name|limit
condition|)
name|result
operator|=
operator|*
name|stream
operator|->
name|cursor
operator|++
expr_stmt|;
return|return
name|result
return|;
block|}
end_block
begin_macro
DECL|function|FT_BASE_DEF
name|FT_BASE_DEF
argument_list|(
argument|FT_Short
argument_list|)
end_macro
begin_macro
name|FT_Stream_GetShort
argument_list|(
argument|FT_Stream  stream
argument_list|)
end_macro
begin_block
block|{
name|FT_Byte
modifier|*
name|p
decl_stmt|;
name|FT_Short
name|result
decl_stmt|;
name|FT_ASSERT
argument_list|(
name|stream
operator|&&
name|stream
operator|->
name|cursor
argument_list|)
expr_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|stream
operator|->
name|cursor
expr_stmt|;
if|if
condition|(
name|p
operator|+
literal|1
operator|<
name|stream
operator|->
name|limit
condition|)
name|result
operator|=
name|FT_NEXT_SHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|stream
operator|->
name|cursor
operator|=
name|p
expr_stmt|;
return|return
name|result
return|;
block|}
end_block
begin_macro
DECL|function|FT_BASE_DEF
name|FT_BASE_DEF
argument_list|(
argument|FT_Short
argument_list|)
end_macro
begin_macro
name|FT_Stream_GetShortLE
argument_list|(
argument|FT_Stream  stream
argument_list|)
end_macro
begin_block
block|{
name|FT_Byte
modifier|*
name|p
decl_stmt|;
name|FT_Short
name|result
decl_stmt|;
name|FT_ASSERT
argument_list|(
name|stream
operator|&&
name|stream
operator|->
name|cursor
argument_list|)
expr_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|stream
operator|->
name|cursor
expr_stmt|;
if|if
condition|(
name|p
operator|+
literal|1
operator|<
name|stream
operator|->
name|limit
condition|)
name|result
operator|=
name|FT_NEXT_SHORT_LE
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|stream
operator|->
name|cursor
operator|=
name|p
expr_stmt|;
return|return
name|result
return|;
block|}
end_block
begin_macro
DECL|function|FT_BASE_DEF
name|FT_BASE_DEF
argument_list|(
argument|FT_Long
argument_list|)
end_macro
begin_macro
name|FT_Stream_GetOffset
argument_list|(
argument|FT_Stream  stream
argument_list|)
end_macro
begin_block
block|{
name|FT_Byte
modifier|*
name|p
decl_stmt|;
name|FT_Long
name|result
decl_stmt|;
name|FT_ASSERT
argument_list|(
name|stream
operator|&&
name|stream
operator|->
name|cursor
argument_list|)
expr_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|stream
operator|->
name|cursor
expr_stmt|;
if|if
condition|(
name|p
operator|+
literal|2
operator|<
name|stream
operator|->
name|limit
condition|)
name|result
operator|=
name|FT_NEXT_OFF3
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|stream
operator|->
name|cursor
operator|=
name|p
expr_stmt|;
return|return
name|result
return|;
block|}
end_block
begin_macro
DECL|function|FT_BASE_DEF
name|FT_BASE_DEF
argument_list|(
argument|FT_Long
argument_list|)
end_macro
begin_macro
name|FT_Stream_GetLong
argument_list|(
argument|FT_Stream  stream
argument_list|)
end_macro
begin_block
block|{
name|FT_Byte
modifier|*
name|p
decl_stmt|;
name|FT_Long
name|result
decl_stmt|;
name|FT_ASSERT
argument_list|(
name|stream
operator|&&
name|stream
operator|->
name|cursor
argument_list|)
expr_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|stream
operator|->
name|cursor
expr_stmt|;
if|if
condition|(
name|p
operator|+
literal|3
operator|<
name|stream
operator|->
name|limit
condition|)
name|result
operator|=
name|FT_NEXT_LONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|stream
operator|->
name|cursor
operator|=
name|p
expr_stmt|;
return|return
name|result
return|;
block|}
end_block
begin_macro
DECL|function|FT_BASE_DEF
name|FT_BASE_DEF
argument_list|(
argument|FT_Long
argument_list|)
end_macro
begin_macro
name|FT_Stream_GetLongLE
argument_list|(
argument|FT_Stream  stream
argument_list|)
end_macro
begin_block
block|{
name|FT_Byte
modifier|*
name|p
decl_stmt|;
name|FT_Long
name|result
decl_stmt|;
name|FT_ASSERT
argument_list|(
name|stream
operator|&&
name|stream
operator|->
name|cursor
argument_list|)
expr_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|stream
operator|->
name|cursor
expr_stmt|;
if|if
condition|(
name|p
operator|+
literal|3
operator|<
name|stream
operator|->
name|limit
condition|)
name|result
operator|=
name|FT_NEXT_LONG_LE
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|stream
operator|->
name|cursor
operator|=
name|p
expr_stmt|;
return|return
name|result
return|;
block|}
end_block
begin_macro
DECL|function|FT_BASE_DEF
name|FT_BASE_DEF
argument_list|(
argument|FT_Char
argument_list|)
end_macro
begin_macro
name|FT_Stream_ReadChar
argument_list|(
argument|FT_Stream  stream
argument_list|,
argument|FT_Error*  error
argument_list|)
end_macro
begin_block
block|{
name|FT_Byte
name|result
init|=
literal|0
decl_stmt|;
name|FT_ASSERT
argument_list|(
name|stream
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|FT_Err_Ok
expr_stmt|;
if|if
condition|(
name|stream
operator|->
name|read
condition|)
block|{
if|if
condition|(
name|stream
operator|->
name|read
argument_list|(
name|stream
argument_list|,
name|stream
operator|->
name|pos
argument_list|,
operator|&
name|result
argument_list|,
literal|1L
argument_list|)
operator|!=
literal|1L
condition|)
goto|goto
name|Fail
goto|;
block|}
else|else
block|{
if|if
condition|(
name|stream
operator|->
name|pos
operator|<
name|stream
operator|->
name|size
condition|)
name|result
operator|=
name|stream
operator|->
name|base
index|[
name|stream
operator|->
name|pos
index|]
expr_stmt|;
else|else
goto|goto
name|Fail
goto|;
block|}
name|stream
operator|->
name|pos
operator|++
expr_stmt|;
return|return
name|result
return|;
name|Fail
label|:
operator|*
name|error
operator|=
name|FT_Err_Invalid_Stream_Operation
expr_stmt|;
name|FT_ERROR
argument_list|(
operator|(
literal|"FT_Stream_ReadChar:"
literal|" invalid i/o; pos = 0x%lx, size = 0x%lx\n"
operator|,
name|stream
operator|->
name|pos
operator|,
name|stream
operator|->
name|size
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block
begin_macro
DECL|function|FT_BASE_DEF
name|FT_BASE_DEF
argument_list|(
argument|FT_Short
argument_list|)
end_macro
begin_macro
name|FT_Stream_ReadShort
argument_list|(
argument|FT_Stream  stream
argument_list|,
argument|FT_Error*  error
argument_list|)
end_macro
begin_block
block|{
name|FT_Byte
name|reads
index|[
literal|2
index|]
decl_stmt|;
name|FT_Byte
modifier|*
name|p
init|=
literal|0
decl_stmt|;
name|FT_Short
name|result
init|=
literal|0
decl_stmt|;
name|FT_ASSERT
argument_list|(
name|stream
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|FT_Err_Ok
expr_stmt|;
if|if
condition|(
name|stream
operator|->
name|pos
operator|+
literal|1
operator|<
name|stream
operator|->
name|size
condition|)
block|{
if|if
condition|(
name|stream
operator|->
name|read
condition|)
block|{
if|if
condition|(
name|stream
operator|->
name|read
argument_list|(
name|stream
argument_list|,
name|stream
operator|->
name|pos
argument_list|,
name|reads
argument_list|,
literal|2L
argument_list|)
operator|!=
literal|2L
condition|)
goto|goto
name|Fail
goto|;
name|p
operator|=
name|reads
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|stream
operator|->
name|base
operator|+
name|stream
operator|->
name|pos
expr_stmt|;
block|}
if|if
condition|(
name|p
condition|)
name|result
operator|=
name|FT_NEXT_SHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
goto|goto
name|Fail
goto|;
name|stream
operator|->
name|pos
operator|+=
literal|2
expr_stmt|;
return|return
name|result
return|;
name|Fail
label|:
operator|*
name|error
operator|=
name|FT_Err_Invalid_Stream_Operation
expr_stmt|;
name|FT_ERROR
argument_list|(
operator|(
literal|"FT_Stream_ReadShort:"
literal|" invalid i/o; pos = 0x%lx, size = 0x%lx\n"
operator|,
name|stream
operator|->
name|pos
operator|,
name|stream
operator|->
name|size
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block
begin_macro
DECL|function|FT_BASE_DEF
name|FT_BASE_DEF
argument_list|(
argument|FT_Short
argument_list|)
end_macro
begin_macro
name|FT_Stream_ReadShortLE
argument_list|(
argument|FT_Stream  stream
argument_list|,
argument|FT_Error*  error
argument_list|)
end_macro
begin_block
block|{
name|FT_Byte
name|reads
index|[
literal|2
index|]
decl_stmt|;
name|FT_Byte
modifier|*
name|p
init|=
literal|0
decl_stmt|;
name|FT_Short
name|result
init|=
literal|0
decl_stmt|;
name|FT_ASSERT
argument_list|(
name|stream
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|FT_Err_Ok
expr_stmt|;
if|if
condition|(
name|stream
operator|->
name|pos
operator|+
literal|1
operator|<
name|stream
operator|->
name|size
condition|)
block|{
if|if
condition|(
name|stream
operator|->
name|read
condition|)
block|{
if|if
condition|(
name|stream
operator|->
name|read
argument_list|(
name|stream
argument_list|,
name|stream
operator|->
name|pos
argument_list|,
name|reads
argument_list|,
literal|2L
argument_list|)
operator|!=
literal|2L
condition|)
goto|goto
name|Fail
goto|;
name|p
operator|=
name|reads
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|stream
operator|->
name|base
operator|+
name|stream
operator|->
name|pos
expr_stmt|;
block|}
if|if
condition|(
name|p
condition|)
name|result
operator|=
name|FT_NEXT_SHORT_LE
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
goto|goto
name|Fail
goto|;
name|stream
operator|->
name|pos
operator|+=
literal|2
expr_stmt|;
return|return
name|result
return|;
name|Fail
label|:
operator|*
name|error
operator|=
name|FT_Err_Invalid_Stream_Operation
expr_stmt|;
name|FT_ERROR
argument_list|(
operator|(
literal|"FT_Stream_ReadShortLE:"
literal|" invalid i/o; pos = 0x%lx, size = 0x%lx\n"
operator|,
name|stream
operator|->
name|pos
operator|,
name|stream
operator|->
name|size
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block
begin_macro
DECL|function|FT_BASE_DEF
name|FT_BASE_DEF
argument_list|(
argument|FT_Long
argument_list|)
end_macro
begin_macro
name|FT_Stream_ReadOffset
argument_list|(
argument|FT_Stream  stream
argument_list|,
argument|FT_Error*  error
argument_list|)
end_macro
begin_block
block|{
name|FT_Byte
name|reads
index|[
literal|3
index|]
decl_stmt|;
name|FT_Byte
modifier|*
name|p
init|=
literal|0
decl_stmt|;
name|FT_Long
name|result
init|=
literal|0
decl_stmt|;
name|FT_ASSERT
argument_list|(
name|stream
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|FT_Err_Ok
expr_stmt|;
if|if
condition|(
name|stream
operator|->
name|pos
operator|+
literal|2
operator|<
name|stream
operator|->
name|size
condition|)
block|{
if|if
condition|(
name|stream
operator|->
name|read
condition|)
block|{
if|if
condition|(
name|stream
operator|->
name|read
argument_list|(
name|stream
argument_list|,
name|stream
operator|->
name|pos
argument_list|,
name|reads
argument_list|,
literal|3L
argument_list|)
operator|!=
literal|3L
condition|)
goto|goto
name|Fail
goto|;
name|p
operator|=
name|reads
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|stream
operator|->
name|base
operator|+
name|stream
operator|->
name|pos
expr_stmt|;
block|}
if|if
condition|(
name|p
condition|)
name|result
operator|=
name|FT_NEXT_OFF3
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
goto|goto
name|Fail
goto|;
name|stream
operator|->
name|pos
operator|+=
literal|3
expr_stmt|;
return|return
name|result
return|;
name|Fail
label|:
operator|*
name|error
operator|=
name|FT_Err_Invalid_Stream_Operation
expr_stmt|;
name|FT_ERROR
argument_list|(
operator|(
literal|"FT_Stream_ReadOffset:"
literal|" invalid i/o; pos = 0x%lx, size = 0x%lx\n"
operator|,
name|stream
operator|->
name|pos
operator|,
name|stream
operator|->
name|size
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block
begin_macro
DECL|function|FT_BASE_DEF
name|FT_BASE_DEF
argument_list|(
argument|FT_Long
argument_list|)
end_macro
begin_macro
name|FT_Stream_ReadLong
argument_list|(
argument|FT_Stream  stream
argument_list|,
argument|FT_Error*  error
argument_list|)
end_macro
begin_block
block|{
name|FT_Byte
name|reads
index|[
literal|4
index|]
decl_stmt|;
name|FT_Byte
modifier|*
name|p
init|=
literal|0
decl_stmt|;
name|FT_Long
name|result
init|=
literal|0
decl_stmt|;
name|FT_ASSERT
argument_list|(
name|stream
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|FT_Err_Ok
expr_stmt|;
if|if
condition|(
name|stream
operator|->
name|pos
operator|+
literal|3
operator|<
name|stream
operator|->
name|size
condition|)
block|{
if|if
condition|(
name|stream
operator|->
name|read
condition|)
block|{
if|if
condition|(
name|stream
operator|->
name|read
argument_list|(
name|stream
argument_list|,
name|stream
operator|->
name|pos
argument_list|,
name|reads
argument_list|,
literal|4L
argument_list|)
operator|!=
literal|4L
condition|)
goto|goto
name|Fail
goto|;
name|p
operator|=
name|reads
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|stream
operator|->
name|base
operator|+
name|stream
operator|->
name|pos
expr_stmt|;
block|}
if|if
condition|(
name|p
condition|)
name|result
operator|=
name|FT_NEXT_LONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
goto|goto
name|Fail
goto|;
name|stream
operator|->
name|pos
operator|+=
literal|4
expr_stmt|;
return|return
name|result
return|;
name|Fail
label|:
operator|*
name|error
operator|=
name|FT_Err_Invalid_Stream_Operation
expr_stmt|;
name|FT_ERROR
argument_list|(
operator|(
literal|"FT_Stream_ReadLong:"
literal|" invalid i/o; pos = 0x%lx, size = 0x%lx\n"
operator|,
name|stream
operator|->
name|pos
operator|,
name|stream
operator|->
name|size
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block
begin_macro
DECL|function|FT_BASE_DEF
name|FT_BASE_DEF
argument_list|(
argument|FT_Long
argument_list|)
end_macro
begin_macro
name|FT_Stream_ReadLongLE
argument_list|(
argument|FT_Stream  stream
argument_list|,
argument|FT_Error*  error
argument_list|)
end_macro
begin_block
block|{
name|FT_Byte
name|reads
index|[
literal|4
index|]
decl_stmt|;
name|FT_Byte
modifier|*
name|p
init|=
literal|0
decl_stmt|;
name|FT_Long
name|result
init|=
literal|0
decl_stmt|;
name|FT_ASSERT
argument_list|(
name|stream
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|FT_Err_Ok
expr_stmt|;
if|if
condition|(
name|stream
operator|->
name|pos
operator|+
literal|3
operator|<
name|stream
operator|->
name|size
condition|)
block|{
if|if
condition|(
name|stream
operator|->
name|read
condition|)
block|{
if|if
condition|(
name|stream
operator|->
name|read
argument_list|(
name|stream
argument_list|,
name|stream
operator|->
name|pos
argument_list|,
name|reads
argument_list|,
literal|4L
argument_list|)
operator|!=
literal|4L
condition|)
goto|goto
name|Fail
goto|;
name|p
operator|=
name|reads
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|stream
operator|->
name|base
operator|+
name|stream
operator|->
name|pos
expr_stmt|;
block|}
if|if
condition|(
name|p
condition|)
name|result
operator|=
name|FT_NEXT_LONG_LE
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
goto|goto
name|Fail
goto|;
name|stream
operator|->
name|pos
operator|+=
literal|4
expr_stmt|;
return|return
name|result
return|;
name|Fail
label|:
operator|*
name|error
operator|=
name|FT_Err_Invalid_Stream_Operation
expr_stmt|;
name|FT_ERROR
argument_list|(
operator|(
literal|"FT_Stream_ReadLongLE:"
literal|" invalid i/o; pos = 0x%lx, size = 0x%lx\n"
operator|,
name|stream
operator|->
name|pos
operator|,
name|stream
operator|->
name|size
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block
begin_macro
DECL|function|FT_BASE_DEF
name|FT_BASE_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_Stream_ReadFields
argument_list|(
argument|FT_Stream              stream
argument_list|,
argument|const FT_Frame_Field*  fields
argument_list|,
argument|void*                  structure
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
decl_stmt|;
name|FT_Bool
name|frame_accessed
init|=
literal|0
decl_stmt|;
name|FT_Byte
modifier|*
name|cursor
decl_stmt|;
if|if
condition|(
operator|!
name|fields
operator|||
operator|!
name|stream
condition|)
return|return
name|FT_Err_Invalid_Argument
return|;
name|cursor
operator|=
name|stream
operator|->
name|cursor
expr_stmt|;
name|error
operator|=
name|FT_Err_Ok
expr_stmt|;
do|do
block|{
name|FT_ULong
name|value
decl_stmt|;
name|FT_Int
name|sign_shift
decl_stmt|;
name|FT_Byte
modifier|*
name|p
decl_stmt|;
switch|switch
condition|(
name|fields
operator|->
name|value
condition|)
block|{
case|case
name|ft_frame_start
case|:
comment|/* access a new frame */
name|error
operator|=
name|FT_Stream_EnterFrame
argument_list|(
name|stream
argument_list|,
name|fields
operator|->
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|frame_accessed
operator|=
literal|1
expr_stmt|;
name|cursor
operator|=
name|stream
operator|->
name|cursor
expr_stmt|;
name|fields
operator|++
expr_stmt|;
continue|continue;
comment|/* loop! */
case|case
name|ft_frame_bytes
case|:
comment|/* read a byte sequence */
case|case
name|ft_frame_skip
case|:
comment|/* skip some bytes      */
block|{
name|FT_UInt
name|len
init|=
name|fields
operator|->
name|size
decl_stmt|;
if|if
condition|(
name|cursor
operator|+
name|len
operator|>
name|stream
operator|->
name|limit
condition|)
block|{
name|error
operator|=
name|FT_Err_Invalid_Stream_Operation
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|fields
operator|->
name|value
operator|==
name|ft_frame_bytes
condition|)
block|{
name|p
operator|=
operator|(
name|FT_Byte
operator|*
operator|)
name|structure
operator|+
name|fields
operator|->
name|offset
expr_stmt|;
name|FT_MEM_COPY
argument_list|(
name|p
argument_list|,
name|cursor
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
name|cursor
operator|+=
name|len
expr_stmt|;
name|fields
operator|++
expr_stmt|;
continue|continue;
block|}
case|case
name|ft_frame_byte
case|:
case|case
name|ft_frame_schar
case|:
comment|/* read a single byte */
name|value
operator|=
name|FT_NEXT_BYTE
argument_list|(
name|cursor
argument_list|)
expr_stmt|;
name|sign_shift
operator|=
literal|24
expr_stmt|;
break|break;
case|case
name|ft_frame_short_be
case|:
case|case
name|ft_frame_ushort_be
case|:
comment|/* read a 2-byte big-endian short */
name|value
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|cursor
argument_list|)
expr_stmt|;
name|sign_shift
operator|=
literal|16
expr_stmt|;
break|break;
case|case
name|ft_frame_short_le
case|:
case|case
name|ft_frame_ushort_le
case|:
comment|/* read a 2-byte little-endian short */
name|value
operator|=
name|FT_NEXT_USHORT_LE
argument_list|(
name|cursor
argument_list|)
expr_stmt|;
name|sign_shift
operator|=
literal|16
expr_stmt|;
break|break;
case|case
name|ft_frame_long_be
case|:
case|case
name|ft_frame_ulong_be
case|:
comment|/* read a 4-byte big-endian long */
name|value
operator|=
name|FT_NEXT_ULONG
argument_list|(
name|cursor
argument_list|)
expr_stmt|;
name|sign_shift
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ft_frame_long_le
case|:
case|case
name|ft_frame_ulong_le
case|:
comment|/* read a 4-byte little-endian long */
name|value
operator|=
name|FT_NEXT_ULONG_LE
argument_list|(
name|cursor
argument_list|)
expr_stmt|;
name|sign_shift
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ft_frame_off3_be
case|:
case|case
name|ft_frame_uoff3_be
case|:
comment|/* read a 3-byte big-endian long */
name|value
operator|=
name|FT_NEXT_UOFF3
argument_list|(
name|cursor
argument_list|)
expr_stmt|;
name|sign_shift
operator|=
literal|8
expr_stmt|;
break|break;
case|case
name|ft_frame_off3_le
case|:
case|case
name|ft_frame_uoff3_le
case|:
comment|/* read a 3-byte little-endian long */
name|value
operator|=
name|FT_NEXT_UOFF3_LE
argument_list|(
name|cursor
argument_list|)
expr_stmt|;
name|sign_shift
operator|=
literal|8
expr_stmt|;
break|break;
default|default:
comment|/* otherwise, exit the loop */
name|stream
operator|->
name|cursor
operator|=
name|cursor
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* now, compute the signed value is necessary */
if|if
condition|(
name|fields
operator|->
name|value
operator|&
name|FT_FRAME_OP_SIGNED
condition|)
name|value
operator|=
call|(
name|FT_ULong
call|)
argument_list|(
call|(
name|FT_Int32
call|)
argument_list|(
name|value
operator|<<
name|sign_shift
argument_list|)
operator|>>
name|sign_shift
argument_list|)
expr_stmt|;
comment|/* finally, store the value in the object */
name|p
operator|=
operator|(
name|FT_Byte
operator|*
operator|)
name|structure
operator|+
name|fields
operator|->
name|offset
expr_stmt|;
switch|switch
condition|(
name|fields
operator|->
name|size
condition|)
block|{
case|case
operator|(
literal|8
operator|/
name|FT_CHAR_BIT
operator|)
case|:
operator|*
operator|(
name|FT_Byte
operator|*
operator|)
name|p
operator|=
operator|(
name|FT_Byte
operator|)
name|value
expr_stmt|;
break|break;
case|case
operator|(
literal|16
operator|/
name|FT_CHAR_BIT
operator|)
case|:
operator|*
operator|(
name|FT_UShort
operator|*
operator|)
name|p
operator|=
operator|(
name|FT_UShort
operator|)
name|value
expr_stmt|;
break|break;
case|case
operator|(
literal|32
operator|/
name|FT_CHAR_BIT
operator|)
case|:
operator|*
operator|(
name|FT_UInt32
operator|*
operator|)
name|p
operator|=
operator|(
name|FT_UInt32
operator|)
name|value
expr_stmt|;
break|break;
default|default:
comment|/* for 64-bit systems */
operator|*
operator|(
name|FT_ULong
operator|*
operator|)
name|p
operator|=
operator|(
name|FT_ULong
operator|)
name|value
expr_stmt|;
block|}
comment|/* go to next field */
name|fields
operator|++
expr_stmt|;
block|}
do|while
condition|(
literal|1
condition|)
do|;
name|Exit
label|:
comment|/* close the frame if it was opened by this read */
if|if
condition|(
name|frame_accessed
condition|)
name|FT_Stream_ExitFrame
argument_list|(
name|stream
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/* END */
end_comment
end_unit
