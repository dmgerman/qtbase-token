begin_unit
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  ftoutln.c                                                              */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*    FreeType outline management (body).                                  */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  Copyright 1996-2008, 2010, 2012-2014 by                                */
end_comment
begin_comment
comment|/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  This file is part of the FreeType project, and may only be used,       */
end_comment
begin_comment
comment|/*  modified, and distributed under the terms of the FreeType project      */
end_comment
begin_comment
comment|/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
end_comment
begin_comment
comment|/*  this file you indicate that you have read the license and              */
end_comment
begin_comment
comment|/*  understand and accept it fully.                                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* All functions are declared in freetype.h.                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<ft2build.h>
end_include
begin_include
include|#
directive|include
include|FT_OUTLINE_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_OBJECTS_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_CALC_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_DEBUG_H
end_include
begin_include
include|#
directive|include
include|FT_TRIGONOMETRY_H
end_include
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
end_comment
begin_comment
comment|/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
end_comment
begin_comment
comment|/* messages during execution.                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_undef
DECL|macro|FT_COMPONENT
undef|#
directive|undef
name|FT_COMPONENT
end_undef
begin_define
DECL|macro|FT_COMPONENT
define|#
directive|define
name|FT_COMPONENT
value|trace_outline
end_define
begin_decl_stmt
specifier|static
DECL|variable|null_outline
specifier|const
name|FT_Outline
name|null_outline
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* documentation is in ftoutln.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_Outline_Decompose
argument_list|(
argument|FT_Outline*              outline
argument_list|,
argument|const FT_Outline_Funcs*  func_interface
argument_list|,
argument|void*                    user
argument_list|)
end_macro
begin_block
block|{
DECL|macro|SCALED
undef|#
directive|undef
name|SCALED
DECL|macro|SCALED
define|#
directive|define
name|SCALED
parameter_list|(
name|x
parameter_list|)
value|( ( (x)<< shift ) - delta )
name|FT_Vector
name|v_last
decl_stmt|;
name|FT_Vector
name|v_control
decl_stmt|;
name|FT_Vector
name|v_start
decl_stmt|;
name|FT_Vector
modifier|*
name|point
decl_stmt|;
name|FT_Vector
modifier|*
name|limit
decl_stmt|;
name|char
modifier|*
name|tags
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|FT_Int
name|n
decl_stmt|;
comment|/* index of contour in outline     */
name|FT_UInt
name|first
decl_stmt|;
comment|/* index of first point in contour */
name|FT_Int
name|tag
decl_stmt|;
comment|/* current point's state           */
name|FT_Int
name|shift
decl_stmt|;
name|FT_Pos
name|delta
decl_stmt|;
if|if
condition|(
operator|!
name|outline
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_Outline
argument_list|)
return|;
if|if
condition|(
operator|!
name|func_interface
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_Argument
argument_list|)
return|;
name|shift
operator|=
name|func_interface
operator|->
name|shift
expr_stmt|;
name|delta
operator|=
name|func_interface
operator|->
name|delta
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|outline
operator|->
name|n_contours
condition|;
name|n
operator|++
control|)
block|{
name|FT_Int
name|last
decl_stmt|;
comment|/* index of last point in contour */
name|FT_TRACE5
argument_list|(
operator|(
literal|"FT_Outline_Decompose: Outline %d\n"
operator|,
name|n
operator|)
argument_list|)
expr_stmt|;
name|last
operator|=
name|outline
operator|->
name|contours
index|[
name|n
index|]
expr_stmt|;
if|if
condition|(
name|last
operator|<
literal|0
condition|)
goto|goto
name|Invalid_Outline
goto|;
name|limit
operator|=
name|outline
operator|->
name|points
operator|+
name|last
expr_stmt|;
name|v_start
operator|=
name|outline
operator|->
name|points
index|[
name|first
index|]
expr_stmt|;
name|v_start
operator|.
name|x
operator|=
name|SCALED
argument_list|(
name|v_start
operator|.
name|x
argument_list|)
expr_stmt|;
name|v_start
operator|.
name|y
operator|=
name|SCALED
argument_list|(
name|v_start
operator|.
name|y
argument_list|)
expr_stmt|;
name|v_last
operator|=
name|outline
operator|->
name|points
index|[
name|last
index|]
expr_stmt|;
name|v_last
operator|.
name|x
operator|=
name|SCALED
argument_list|(
name|v_last
operator|.
name|x
argument_list|)
expr_stmt|;
name|v_last
operator|.
name|y
operator|=
name|SCALED
argument_list|(
name|v_last
operator|.
name|y
argument_list|)
expr_stmt|;
name|v_control
operator|=
name|v_start
expr_stmt|;
name|point
operator|=
name|outline
operator|->
name|points
operator|+
name|first
expr_stmt|;
name|tags
operator|=
name|outline
operator|->
name|tags
operator|+
name|first
expr_stmt|;
name|tag
operator|=
name|FT_CURVE_TAG
argument_list|(
name|tags
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* A contour cannot start with a cubic control point! */
if|if
condition|(
name|tag
operator|==
name|FT_CURVE_TAG_CUBIC
condition|)
goto|goto
name|Invalid_Outline
goto|;
comment|/* check first point to determine origin */
if|if
condition|(
name|tag
operator|==
name|FT_CURVE_TAG_CONIC
condition|)
block|{
comment|/* first point is conic control.  Yes, this happens. */
if|if
condition|(
name|FT_CURVE_TAG
argument_list|(
name|outline
operator|->
name|tags
index|[
name|last
index|]
argument_list|)
operator|==
name|FT_CURVE_TAG_ON
condition|)
block|{
comment|/* start at last point if it is on the curve */
name|v_start
operator|=
name|v_last
expr_stmt|;
name|limit
operator|--
expr_stmt|;
block|}
else|else
block|{
comment|/* if both first and last points are conic,         */
comment|/* start at their middle and record its position    */
comment|/* for closure                                      */
name|v_start
operator|.
name|x
operator|=
operator|(
name|v_start
operator|.
name|x
operator|+
name|v_last
operator|.
name|x
operator|)
operator|/
literal|2
expr_stmt|;
name|v_start
operator|.
name|y
operator|=
operator|(
name|v_start
operator|.
name|y
operator|+
name|v_last
operator|.
name|y
operator|)
operator|/
literal|2
expr_stmt|;
comment|/* v_last = v_start; */
block|}
name|point
operator|--
expr_stmt|;
name|tags
operator|--
expr_stmt|;
block|}
name|FT_TRACE5
argument_list|(
operator|(
literal|"  move to (%.2f, %.2f)\n"
operator|,
name|v_start
operator|.
name|x
operator|/
literal|64.0
operator|,
name|v_start
operator|.
name|y
operator|/
literal|64.0
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|func_interface
operator|->
name|move_to
argument_list|(
operator|&
name|v_start
argument_list|,
name|user
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
while|while
condition|(
name|point
operator|<
name|limit
condition|)
block|{
name|point
operator|++
expr_stmt|;
name|tags
operator|++
expr_stmt|;
name|tag
operator|=
name|FT_CURVE_TAG
argument_list|(
name|tags
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tag
condition|)
block|{
case|case
name|FT_CURVE_TAG_ON
case|:
comment|/* emit a single line_to */
block|{
name|FT_Vector
name|vec
decl_stmt|;
name|vec
operator|.
name|x
operator|=
name|SCALED
argument_list|(
name|point
operator|->
name|x
argument_list|)
expr_stmt|;
name|vec
operator|.
name|y
operator|=
name|SCALED
argument_list|(
name|point
operator|->
name|y
argument_list|)
expr_stmt|;
name|FT_TRACE5
argument_list|(
operator|(
literal|"  line to (%.2f, %.2f)\n"
operator|,
name|vec
operator|.
name|x
operator|/
literal|64.0
operator|,
name|vec
operator|.
name|y
operator|/
literal|64.0
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|func_interface
operator|->
name|line_to
argument_list|(
operator|&
name|vec
argument_list|,
name|user
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
continue|continue;
block|}
case|case
name|FT_CURVE_TAG_CONIC
case|:
comment|/* consume conic arcs */
name|v_control
operator|.
name|x
operator|=
name|SCALED
argument_list|(
name|point
operator|->
name|x
argument_list|)
expr_stmt|;
name|v_control
operator|.
name|y
operator|=
name|SCALED
argument_list|(
name|point
operator|->
name|y
argument_list|)
expr_stmt|;
name|Do_Conic
label|:
if|if
condition|(
name|point
operator|<
name|limit
condition|)
block|{
name|FT_Vector
name|vec
decl_stmt|;
name|FT_Vector
name|v_middle
decl_stmt|;
name|point
operator|++
expr_stmt|;
name|tags
operator|++
expr_stmt|;
name|tag
operator|=
name|FT_CURVE_TAG
argument_list|(
name|tags
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|vec
operator|.
name|x
operator|=
name|SCALED
argument_list|(
name|point
operator|->
name|x
argument_list|)
expr_stmt|;
name|vec
operator|.
name|y
operator|=
name|SCALED
argument_list|(
name|point
operator|->
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag
operator|==
name|FT_CURVE_TAG_ON
condition|)
block|{
name|FT_TRACE5
argument_list|(
operator|(
literal|"  conic to (%.2f, %.2f)"
literal|" with control (%.2f, %.2f)\n"
operator|,
name|vec
operator|.
name|x
operator|/
literal|64.0
operator|,
name|vec
operator|.
name|y
operator|/
literal|64.0
operator|,
name|v_control
operator|.
name|x
operator|/
literal|64.0
operator|,
name|v_control
operator|.
name|y
operator|/
literal|64.0
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|func_interface
operator|->
name|conic_to
argument_list|(
operator|&
name|v_control
argument_list|,
operator|&
name|vec
argument_list|,
name|user
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
continue|continue;
block|}
if|if
condition|(
name|tag
operator|!=
name|FT_CURVE_TAG_CONIC
condition|)
goto|goto
name|Invalid_Outline
goto|;
name|v_middle
operator|.
name|x
operator|=
operator|(
name|v_control
operator|.
name|x
operator|+
name|vec
operator|.
name|x
operator|)
operator|/
literal|2
expr_stmt|;
name|v_middle
operator|.
name|y
operator|=
operator|(
name|v_control
operator|.
name|y
operator|+
name|vec
operator|.
name|y
operator|)
operator|/
literal|2
expr_stmt|;
name|FT_TRACE5
argument_list|(
operator|(
literal|"  conic to (%.2f, %.2f)"
literal|" with control (%.2f, %.2f)\n"
operator|,
name|v_middle
operator|.
name|x
operator|/
literal|64.0
operator|,
name|v_middle
operator|.
name|y
operator|/
literal|64.0
operator|,
name|v_control
operator|.
name|x
operator|/
literal|64.0
operator|,
name|v_control
operator|.
name|y
operator|/
literal|64.0
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|func_interface
operator|->
name|conic_to
argument_list|(
operator|&
name|v_control
argument_list|,
operator|&
name|v_middle
argument_list|,
name|user
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|v_control
operator|=
name|vec
expr_stmt|;
goto|goto
name|Do_Conic
goto|;
block|}
name|FT_TRACE5
argument_list|(
operator|(
literal|"  conic to (%.2f, %.2f)"
literal|" with control (%.2f, %.2f)\n"
operator|,
name|v_start
operator|.
name|x
operator|/
literal|64.0
operator|,
name|v_start
operator|.
name|y
operator|/
literal|64.0
operator|,
name|v_control
operator|.
name|x
operator|/
literal|64.0
operator|,
name|v_control
operator|.
name|y
operator|/
literal|64.0
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|func_interface
operator|->
name|conic_to
argument_list|(
operator|&
name|v_control
argument_list|,
operator|&
name|v_start
argument_list|,
name|user
argument_list|)
expr_stmt|;
goto|goto
name|Close
goto|;
default|default:
comment|/* FT_CURVE_TAG_CUBIC */
block|{
name|FT_Vector
name|vec1
decl_stmt|,
name|vec2
decl_stmt|;
if|if
condition|(
name|point
operator|+
literal|1
operator|>
name|limit
operator|||
name|FT_CURVE_TAG
argument_list|(
name|tags
index|[
literal|1
index|]
argument_list|)
operator|!=
name|FT_CURVE_TAG_CUBIC
condition|)
goto|goto
name|Invalid_Outline
goto|;
name|point
operator|+=
literal|2
expr_stmt|;
name|tags
operator|+=
literal|2
expr_stmt|;
name|vec1
operator|.
name|x
operator|=
name|SCALED
argument_list|(
name|point
index|[
operator|-
literal|2
index|]
operator|.
name|x
argument_list|)
expr_stmt|;
name|vec1
operator|.
name|y
operator|=
name|SCALED
argument_list|(
name|point
index|[
operator|-
literal|2
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
name|vec2
operator|.
name|x
operator|=
name|SCALED
argument_list|(
name|point
index|[
operator|-
literal|1
index|]
operator|.
name|x
argument_list|)
expr_stmt|;
name|vec2
operator|.
name|y
operator|=
name|SCALED
argument_list|(
name|point
index|[
operator|-
literal|1
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|point
operator|<=
name|limit
condition|)
block|{
name|FT_Vector
name|vec
decl_stmt|;
name|vec
operator|.
name|x
operator|=
name|SCALED
argument_list|(
name|point
operator|->
name|x
argument_list|)
expr_stmt|;
name|vec
operator|.
name|y
operator|=
name|SCALED
argument_list|(
name|point
operator|->
name|y
argument_list|)
expr_stmt|;
name|FT_TRACE5
argument_list|(
operator|(
literal|"  cubic to (%.2f, %.2f)"
literal|" with controls (%.2f, %.2f) and (%.2f, %.2f)\n"
operator|,
name|vec
operator|.
name|x
operator|/
literal|64.0
operator|,
name|vec
operator|.
name|y
operator|/
literal|64.0
operator|,
name|vec1
operator|.
name|x
operator|/
literal|64.0
operator|,
name|vec1
operator|.
name|y
operator|/
literal|64.0
operator|,
name|vec2
operator|.
name|x
operator|/
literal|64.0
operator|,
name|vec2
operator|.
name|y
operator|/
literal|64.0
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|func_interface
operator|->
name|cubic_to
argument_list|(
operator|&
name|vec1
argument_list|,
operator|&
name|vec2
argument_list|,
operator|&
name|vec
argument_list|,
name|user
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
continue|continue;
block|}
name|FT_TRACE5
argument_list|(
operator|(
literal|"  cubic to (%.2f, %.2f)"
literal|" with controls (%.2f, %.2f) and (%.2f, %.2f)\n"
operator|,
name|v_start
operator|.
name|x
operator|/
literal|64.0
operator|,
name|v_start
operator|.
name|y
operator|/
literal|64.0
operator|,
name|vec1
operator|.
name|x
operator|/
literal|64.0
operator|,
name|vec1
operator|.
name|y
operator|/
literal|64.0
operator|,
name|vec2
operator|.
name|x
operator|/
literal|64.0
operator|,
name|vec2
operator|.
name|y
operator|/
literal|64.0
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|func_interface
operator|->
name|cubic_to
argument_list|(
operator|&
name|vec1
argument_list|,
operator|&
name|vec2
argument_list|,
operator|&
name|v_start
argument_list|,
name|user
argument_list|)
expr_stmt|;
goto|goto
name|Close
goto|;
block|}
block|}
block|}
comment|/* close the contour with a line segment */
name|FT_TRACE5
argument_list|(
operator|(
literal|"  line to (%.2f, %.2f)\n"
operator|,
name|v_start
operator|.
name|x
operator|/
literal|64.0
operator|,
name|v_start
operator|.
name|y
operator|/
literal|64.0
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|func_interface
operator|->
name|line_to
argument_list|(
operator|&
name|v_start
argument_list|,
name|user
argument_list|)
expr_stmt|;
name|Close
label|:
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|first
operator|=
name|last
operator|+
literal|1
expr_stmt|;
block|}
name|FT_TRACE5
argument_list|(
operator|(
literal|"FT_Outline_Decompose: Done\n"
operator|,
name|n
operator|)
argument_list|)
expr_stmt|;
return|return
name|FT_Err_Ok
return|;
name|Exit
label|:
name|FT_TRACE5
argument_list|(
operator|(
literal|"FT_Outline_Decompose: Error %d\n"
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
return|return
name|error
return|;
name|Invalid_Outline
label|:
return|return
name|FT_THROW
argument_list|(
name|Invalid_Outline
argument_list|)
return|;
block|}
end_block
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_Outline_New_Internal
argument_list|(
argument|FT_Memory    memory
argument_list|,
argument|FT_UInt      numPoints
argument_list|,
argument|FT_Int       numContours
argument_list|,
argument|FT_Outline  *anoutline
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
decl_stmt|;
if|if
condition|(
operator|!
name|anoutline
operator|||
operator|!
name|memory
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_Argument
argument_list|)
return|;
operator|*
name|anoutline
operator|=
name|null_outline
expr_stmt|;
if|if
condition|(
name|numContours
operator|<
literal|0
operator|||
operator|(
name|FT_UInt
operator|)
name|numContours
operator|>
name|numPoints
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_Argument
argument_list|)
return|;
if|if
condition|(
name|numPoints
operator|>
name|FT_OUTLINE_POINTS_MAX
condition|)
return|return
name|FT_THROW
argument_list|(
name|Array_Too_Large
argument_list|)
return|;
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|anoutline
operator|->
name|points
argument_list|,
name|numPoints
argument_list|)
operator|||
name|FT_NEW_ARRAY
argument_list|(
name|anoutline
operator|->
name|tags
argument_list|,
name|numPoints
argument_list|)
operator|||
name|FT_NEW_ARRAY
argument_list|(
name|anoutline
operator|->
name|contours
argument_list|,
name|numContours
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
name|anoutline
operator|->
name|n_points
operator|=
operator|(
name|FT_UShort
operator|)
name|numPoints
expr_stmt|;
name|anoutline
operator|->
name|n_contours
operator|=
operator|(
name|FT_Short
operator|)
name|numContours
expr_stmt|;
name|anoutline
operator|->
name|flags
operator||=
name|FT_OUTLINE_OWNER
expr_stmt|;
return|return
name|FT_Err_Ok
return|;
name|Fail
label|:
name|anoutline
operator|->
name|flags
operator||=
name|FT_OUTLINE_OWNER
expr_stmt|;
name|FT_Outline_Done_Internal
argument_list|(
name|memory
argument_list|,
name|anoutline
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/* documentation is in ftoutln.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_Outline_New
argument_list|(
argument|FT_Library   library
argument_list|,
argument|FT_UInt      numPoints
argument_list|,
argument|FT_Int       numContours
argument_list|,
argument|FT_Outline  *anoutline
argument_list|)
end_macro
begin_block
block|{
if|if
condition|(
operator|!
name|library
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_Library_Handle
argument_list|)
return|;
return|return
name|FT_Outline_New_Internal
argument_list|(
name|library
operator|->
name|memory
argument_list|,
name|numPoints
argument_list|,
name|numContours
argument_list|,
name|anoutline
argument_list|)
return|;
block|}
end_block
begin_comment
comment|/* documentation is in ftoutln.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_Outline_Check
argument_list|(
argument|FT_Outline*  outline
argument_list|)
end_macro
begin_block
block|{
if|if
condition|(
name|outline
condition|)
block|{
name|FT_Int
name|n_points
init|=
name|outline
operator|->
name|n_points
decl_stmt|;
name|FT_Int
name|n_contours
init|=
name|outline
operator|->
name|n_contours
decl_stmt|;
name|FT_Int
name|end0
decl_stmt|,
name|end
decl_stmt|;
name|FT_Int
name|n
decl_stmt|;
comment|/* empty glyph? */
if|if
condition|(
name|n_points
operator|==
literal|0
operator|&&
name|n_contours
operator|==
literal|0
condition|)
return|return
name|FT_Err_Ok
return|;
comment|/* check point and contour counts */
if|if
condition|(
name|n_points
operator|<=
literal|0
operator|||
name|n_contours
operator|<=
literal|0
condition|)
goto|goto
name|Bad
goto|;
name|end0
operator|=
name|end
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|n_contours
condition|;
name|n
operator|++
control|)
block|{
name|end
operator|=
name|outline
operator|->
name|contours
index|[
name|n
index|]
expr_stmt|;
comment|/* note that we don't accept empty contours */
if|if
condition|(
name|end
operator|<=
name|end0
operator|||
name|end
operator|>=
name|n_points
condition|)
goto|goto
name|Bad
goto|;
name|end0
operator|=
name|end
expr_stmt|;
block|}
if|if
condition|(
name|end
operator|!=
name|n_points
operator|-
literal|1
condition|)
goto|goto
name|Bad
goto|;
comment|/* XXX: check the tags array */
return|return
name|FT_Err_Ok
return|;
block|}
name|Bad
label|:
return|return
name|FT_THROW
argument_list|(
name|Invalid_Argument
argument_list|)
return|;
block|}
end_block
begin_comment
comment|/* documentation is in ftoutln.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_Outline_Copy
argument_list|(
argument|const FT_Outline*  source
argument_list|,
argument|FT_Outline        *target
argument_list|)
end_macro
begin_block
block|{
name|FT_Int
name|is_owner
decl_stmt|;
if|if
condition|(
operator|!
name|source
operator|||
operator|!
name|target
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_Outline
argument_list|)
return|;
if|if
condition|(
name|source
operator|->
name|n_points
operator|!=
name|target
operator|->
name|n_points
operator|||
name|source
operator|->
name|n_contours
operator|!=
name|target
operator|->
name|n_contours
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_Argument
argument_list|)
return|;
if|if
condition|(
name|source
operator|==
name|target
condition|)
return|return
name|FT_Err_Ok
return|;
name|FT_ARRAY_COPY
argument_list|(
name|target
operator|->
name|points
argument_list|,
name|source
operator|->
name|points
argument_list|,
name|source
operator|->
name|n_points
argument_list|)
expr_stmt|;
name|FT_ARRAY_COPY
argument_list|(
name|target
operator|->
name|tags
argument_list|,
name|source
operator|->
name|tags
argument_list|,
name|source
operator|->
name|n_points
argument_list|)
expr_stmt|;
name|FT_ARRAY_COPY
argument_list|(
name|target
operator|->
name|contours
argument_list|,
name|source
operator|->
name|contours
argument_list|,
name|source
operator|->
name|n_contours
argument_list|)
expr_stmt|;
comment|/* copy all flags, except the `FT_OUTLINE_OWNER' one */
name|is_owner
operator|=
name|target
operator|->
name|flags
operator|&
name|FT_OUTLINE_OWNER
expr_stmt|;
name|target
operator|->
name|flags
operator|=
name|source
operator|->
name|flags
expr_stmt|;
name|target
operator|->
name|flags
operator|&=
operator|~
name|FT_OUTLINE_OWNER
expr_stmt|;
name|target
operator|->
name|flags
operator||=
name|is_owner
expr_stmt|;
return|return
name|FT_Err_Ok
return|;
block|}
end_block
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_Outline_Done_Internal
argument_list|(
argument|FT_Memory    memory
argument_list|,
argument|FT_Outline*  outline
argument_list|)
end_macro
begin_block
block|{
if|if
condition|(
operator|!
name|outline
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_Outline
argument_list|)
return|;
if|if
condition|(
operator|!
name|memory
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_Argument
argument_list|)
return|;
if|if
condition|(
name|outline
operator|->
name|flags
operator|&
name|FT_OUTLINE_OWNER
condition|)
block|{
name|FT_FREE
argument_list|(
name|outline
operator|->
name|points
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|outline
operator|->
name|tags
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|outline
operator|->
name|contours
argument_list|)
expr_stmt|;
block|}
operator|*
name|outline
operator|=
name|null_outline
expr_stmt|;
return|return
name|FT_Err_Ok
return|;
block|}
end_block
begin_comment
comment|/* documentation is in ftoutln.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_Outline_Done
argument_list|(
argument|FT_Library   library
argument_list|,
argument|FT_Outline*  outline
argument_list|)
end_macro
begin_block
block|{
comment|/* check for valid `outline' in FT_Outline_Done_Internal() */
if|if
condition|(
operator|!
name|library
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_Library_Handle
argument_list|)
return|;
return|return
name|FT_Outline_Done_Internal
argument_list|(
name|library
operator|->
name|memory
argument_list|,
name|outline
argument_list|)
return|;
block|}
end_block
begin_comment
comment|/* documentation is in ftoutln.h */
end_comment
begin_macro
name|FT_EXPORT_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|FT_Outline_Get_CBox
name|FT_Outline_Get_CBox
argument_list|(
argument|const FT_Outline*  outline
argument_list|,
argument|FT_BBox           *acbox
argument_list|)
end_macro
begin_block
block|{
name|FT_Pos
name|xMin
decl_stmt|,
name|yMin
decl_stmt|,
name|xMax
decl_stmt|,
name|yMax
decl_stmt|;
if|if
condition|(
name|outline
operator|&&
name|acbox
condition|)
block|{
if|if
condition|(
name|outline
operator|->
name|n_points
operator|==
literal|0
condition|)
block|{
name|xMin
operator|=
literal|0
expr_stmt|;
name|yMin
operator|=
literal|0
expr_stmt|;
name|xMax
operator|=
literal|0
expr_stmt|;
name|yMax
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|FT_Vector
modifier|*
name|vec
init|=
name|outline
operator|->
name|points
decl_stmt|;
name|FT_Vector
modifier|*
name|limit
init|=
name|vec
operator|+
name|outline
operator|->
name|n_points
decl_stmt|;
name|xMin
operator|=
name|xMax
operator|=
name|vec
operator|->
name|x
expr_stmt|;
name|yMin
operator|=
name|yMax
operator|=
name|vec
operator|->
name|y
expr_stmt|;
name|vec
operator|++
expr_stmt|;
for|for
control|(
init|;
name|vec
operator|<
name|limit
condition|;
name|vec
operator|++
control|)
block|{
name|FT_Pos
name|x
decl_stmt|,
name|y
decl_stmt|;
name|x
operator|=
name|vec
operator|->
name|x
expr_stmt|;
if|if
condition|(
name|x
operator|<
name|xMin
condition|)
name|xMin
operator|=
name|x
expr_stmt|;
if|if
condition|(
name|x
operator|>
name|xMax
condition|)
name|xMax
operator|=
name|x
expr_stmt|;
name|y
operator|=
name|vec
operator|->
name|y
expr_stmt|;
if|if
condition|(
name|y
operator|<
name|yMin
condition|)
name|yMin
operator|=
name|y
expr_stmt|;
if|if
condition|(
name|y
operator|>
name|yMax
condition|)
name|yMax
operator|=
name|y
expr_stmt|;
block|}
block|}
name|acbox
operator|->
name|xMin
operator|=
name|xMin
expr_stmt|;
name|acbox
operator|->
name|xMax
operator|=
name|xMax
expr_stmt|;
name|acbox
operator|->
name|yMin
operator|=
name|yMin
expr_stmt|;
name|acbox
operator|->
name|yMax
operator|=
name|yMax
expr_stmt|;
block|}
block|}
end_block
begin_comment
comment|/* documentation is in ftoutln.h */
end_comment
begin_macro
name|FT_EXPORT_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|FT_Outline_Translate
name|FT_Outline_Translate
argument_list|(
argument|const FT_Outline*  outline
argument_list|,
argument|FT_Pos             xOffset
argument_list|,
argument|FT_Pos             yOffset
argument_list|)
end_macro
begin_block
block|{
name|FT_UShort
name|n
decl_stmt|;
name|FT_Vector
modifier|*
name|vec
decl_stmt|;
if|if
condition|(
operator|!
name|outline
condition|)
return|return;
name|vec
operator|=
name|outline
operator|->
name|points
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|outline
operator|->
name|n_points
condition|;
name|n
operator|++
control|)
block|{
name|vec
operator|->
name|x
operator|+=
name|xOffset
expr_stmt|;
name|vec
operator|->
name|y
operator|+=
name|yOffset
expr_stmt|;
name|vec
operator|++
expr_stmt|;
block|}
block|}
end_block
begin_comment
comment|/* documentation is in ftoutln.h */
end_comment
begin_macro
name|FT_EXPORT_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|FT_Outline_Reverse
name|FT_Outline_Reverse
argument_list|(
argument|FT_Outline*  outline
argument_list|)
end_macro
begin_block
block|{
name|FT_UShort
name|n
decl_stmt|;
name|FT_Int
name|first
decl_stmt|,
name|last
decl_stmt|;
if|if
condition|(
operator|!
name|outline
condition|)
return|return;
name|first
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|outline
operator|->
name|n_contours
condition|;
name|n
operator|++
control|)
block|{
name|last
operator|=
name|outline
operator|->
name|contours
index|[
name|n
index|]
expr_stmt|;
comment|/* reverse point table */
block|{
name|FT_Vector
modifier|*
name|p
init|=
name|outline
operator|->
name|points
operator|+
name|first
decl_stmt|;
name|FT_Vector
modifier|*
name|q
init|=
name|outline
operator|->
name|points
operator|+
name|last
decl_stmt|;
name|FT_Vector
name|swap
decl_stmt|;
while|while
condition|(
name|p
operator|<
name|q
condition|)
block|{
name|swap
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|=
operator|*
name|q
expr_stmt|;
operator|*
name|q
operator|=
name|swap
expr_stmt|;
name|p
operator|++
expr_stmt|;
name|q
operator|--
expr_stmt|;
block|}
block|}
comment|/* reverse tags table */
block|{
name|char
modifier|*
name|p
init|=
name|outline
operator|->
name|tags
operator|+
name|first
decl_stmt|;
name|char
modifier|*
name|q
init|=
name|outline
operator|->
name|tags
operator|+
name|last
decl_stmt|;
while|while
condition|(
name|p
operator|<
name|q
condition|)
block|{
name|char
name|swap
decl_stmt|;
name|swap
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|=
operator|*
name|q
expr_stmt|;
operator|*
name|q
operator|=
name|swap
expr_stmt|;
name|p
operator|++
expr_stmt|;
name|q
operator|--
expr_stmt|;
block|}
block|}
name|first
operator|=
name|last
operator|+
literal|1
expr_stmt|;
block|}
name|outline
operator|->
name|flags
operator|^=
name|FT_OUTLINE_REVERSE_FILL
expr_stmt|;
block|}
end_block
begin_comment
comment|/* documentation is in ftoutln.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_Outline_Render
argument_list|(
argument|FT_Library         library
argument_list|,
argument|FT_Outline*        outline
argument_list|,
argument|FT_Raster_Params*  params
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
decl_stmt|;
name|FT_Bool
name|update
init|=
name|FALSE
decl_stmt|;
name|FT_Renderer
name|renderer
decl_stmt|;
name|FT_ListNode
name|node
decl_stmt|;
if|if
condition|(
operator|!
name|library
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_Library_Handle
argument_list|)
return|;
if|if
condition|(
operator|!
name|outline
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_Outline
argument_list|)
return|;
if|if
condition|(
operator|!
name|params
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_Argument
argument_list|)
return|;
name|renderer
operator|=
name|library
operator|->
name|cur_renderer
expr_stmt|;
name|node
operator|=
name|library
operator|->
name|renderers
operator|.
name|head
expr_stmt|;
name|params
operator|->
name|source
operator|=
operator|(
name|void
operator|*
operator|)
name|outline
expr_stmt|;
name|error
operator|=
name|FT_ERR
argument_list|(
name|Cannot_Render_Glyph
argument_list|)
expr_stmt|;
while|while
condition|(
name|renderer
condition|)
block|{
name|error
operator|=
name|renderer
operator|->
name|raster_render
argument_list|(
name|renderer
operator|->
name|raster
argument_list|,
name|params
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|||
name|FT_ERR_NEQ
argument_list|(
name|error
argument_list|,
name|Cannot_Render_Glyph
argument_list|)
condition|)
break|break;
comment|/* FT_Err_Cannot_Render_Glyph is returned if the render mode   */
comment|/* is unsupported by the current renderer for this glyph image */
comment|/* format                                                      */
comment|/* now, look for another renderer that supports the same */
comment|/* format                                                */
name|renderer
operator|=
name|FT_Lookup_Renderer
argument_list|(
name|library
argument_list|,
name|FT_GLYPH_FORMAT_OUTLINE
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
name|update
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* if we changed the current renderer for the glyph image format */
comment|/* we need to select it as the next current one                  */
if|if
condition|(
operator|!
name|error
operator|&&
name|update
operator|&&
name|renderer
condition|)
name|error
operator|=
name|FT_Set_Renderer
argument_list|(
name|library
argument_list|,
name|renderer
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/* documentation is in ftoutln.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_Outline_Get_Bitmap
argument_list|(
argument|FT_Library        library
argument_list|,
argument|FT_Outline*       outline
argument_list|,
argument|const FT_Bitmap  *abitmap
argument_list|)
end_macro
begin_block
block|{
name|FT_Raster_Params
name|params
decl_stmt|;
if|if
condition|(
operator|!
name|abitmap
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_Argument
argument_list|)
return|;
comment|/* other checks are delayed to `FT_Outline_Render' */
name|params
operator|.
name|target
operator|=
name|abitmap
expr_stmt|;
name|params
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|abitmap
operator|->
name|pixel_mode
operator|==
name|FT_PIXEL_MODE_GRAY
operator|||
name|abitmap
operator|->
name|pixel_mode
operator|==
name|FT_PIXEL_MODE_LCD
operator|||
name|abitmap
operator|->
name|pixel_mode
operator|==
name|FT_PIXEL_MODE_LCD_V
condition|)
name|params
operator|.
name|flags
operator||=
name|FT_RASTER_FLAG_AA
expr_stmt|;
return|return
name|FT_Outline_Render
argument_list|(
name|library
argument_list|,
name|outline
argument_list|,
operator|&
name|params
argument_list|)
return|;
block|}
end_block
begin_comment
comment|/* documentation is in freetype.h */
end_comment
begin_macro
name|FT_EXPORT_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|FT_Vector_Transform
name|FT_Vector_Transform
argument_list|(
argument|FT_Vector*        vector
argument_list|,
argument|const FT_Matrix*  matrix
argument_list|)
end_macro
begin_block
block|{
name|FT_Pos
name|xz
decl_stmt|,
name|yz
decl_stmt|;
if|if
condition|(
operator|!
name|vector
operator|||
operator|!
name|matrix
condition|)
return|return;
name|xz
operator|=
name|FT_MulFix
argument_list|(
name|vector
operator|->
name|x
argument_list|,
name|matrix
operator|->
name|xx
argument_list|)
operator|+
name|FT_MulFix
argument_list|(
name|vector
operator|->
name|y
argument_list|,
name|matrix
operator|->
name|xy
argument_list|)
expr_stmt|;
name|yz
operator|=
name|FT_MulFix
argument_list|(
name|vector
operator|->
name|x
argument_list|,
name|matrix
operator|->
name|yx
argument_list|)
operator|+
name|FT_MulFix
argument_list|(
name|vector
operator|->
name|y
argument_list|,
name|matrix
operator|->
name|yy
argument_list|)
expr_stmt|;
name|vector
operator|->
name|x
operator|=
name|xz
expr_stmt|;
name|vector
operator|->
name|y
operator|=
name|yz
expr_stmt|;
block|}
end_block
begin_comment
comment|/* documentation is in ftoutln.h */
end_comment
begin_macro
name|FT_EXPORT_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|FT_Outline_Transform
name|FT_Outline_Transform
argument_list|(
argument|const FT_Outline*  outline
argument_list|,
argument|const FT_Matrix*   matrix
argument_list|)
end_macro
begin_block
block|{
name|FT_Vector
modifier|*
name|vec
decl_stmt|;
name|FT_Vector
modifier|*
name|limit
decl_stmt|;
if|if
condition|(
operator|!
name|outline
operator|||
operator|!
name|matrix
condition|)
return|return;
name|vec
operator|=
name|outline
operator|->
name|points
expr_stmt|;
name|limit
operator|=
name|vec
operator|+
name|outline
operator|->
name|n_points
expr_stmt|;
for|for
control|(
init|;
name|vec
operator|<
name|limit
condition|;
name|vec
operator|++
control|)
name|FT_Vector_Transform
argument_list|(
name|vec
argument_list|,
name|matrix
argument_list|)
expr_stmt|;
block|}
end_block
begin_if
if|#
directive|if
literal|0
end_if
begin_define
define|#
directive|define
name|FT_OUTLINE_GET_CONTOUR
parameter_list|(
name|outline
parameter_list|,
name|c
parameter_list|,
name|first
parameter_list|,
name|last
parameter_list|)
define|\
value|do                                                       \   {                                                        \     (first) = ( c> 0 ) ? (outline)->points +              \                             (outline)->contours[c - 1] + 1 \                         : (outline)->points;               \     (last) = (outline)->points + (outline)->contours[c];   \   } while ( 0 )
end_define
begin_comment
comment|/* Is a point in some contour?                     */
end_comment
begin_comment
comment|/*                                                 */
end_comment
begin_comment
comment|/* We treat every point of the contour as if it    */
end_comment
begin_comment
comment|/* it were ON.  That is, we allow false positives, */
end_comment
begin_comment
comment|/* but disallow false negatives.  (XXX really?)    */
end_comment
begin_comment
unit|static FT_Bool   ft_contour_has( FT_Outline*  outline,                   FT_Short     c,                   FT_Vector*   point )   {     FT_Vector*  first;     FT_Vector*  last;     FT_Vector*  a;     FT_Vector*  b;     FT_UInt     n = 0;       FT_OUTLINE_GET_CONTOUR( outline, c, first, last );      for ( a = first; a<= last; a++ )     {       FT_Pos  x;       FT_Int  intersect;         b = ( a == last ) ? first : a + 1;        intersect = ( a->y - point->y ) ^ ( b->y - point->y );
comment|/* a and b are on the same side */
end_comment
begin_comment
unit|if ( intersect>= 0 )       {         if ( intersect == 0&& a->y == point->y )         {           if ( ( a->x<= point->x&& b->x>= point->x ) ||                ( a->x>= point->x&& b->x<= point->x ) )             return 1;         }          continue;       }        x = a->x + ( b->x - a->x ) * (point->y - a->y ) / ( b->y - a->y );        if ( x< point->x )         n++;       else if ( x == point->x )         return 1;     }      return n& 1;   }     static FT_Bool   ft_contour_enclosed( FT_Outline*  outline,                        FT_UShort    c )   {     FT_Vector*  first;     FT_Vector*  last;     FT_Short    i;       FT_OUTLINE_GET_CONTOUR( outline, c, first, last );      for ( i = 0; i< outline->n_contours; i++ )     {       if ( i != c&& ft_contour_has( outline, i, first ) )       {         FT_Vector*  pt;           for ( pt = first + 1; pt<= last; pt++ )           if ( !ft_contour_has( outline, i, pt ) )             return 0;          return 1;       }     }      return 0;   }
comment|/* This version differs from the public one in that each */
end_comment
begin_comment
comment|/* part (contour not enclosed in another contour) of the */
end_comment
begin_comment
comment|/* outline is checked for orientation.  This is          */
end_comment
begin_comment
comment|/* necessary for some buggy CJK fonts.                   */
end_comment
begin_comment
unit|static FT_Orientation   ft_outline_get_orientation( FT_Outline*  outline )   {     FT_Short        i;     FT_Vector*      first;     FT_Vector*      last;     FT_Orientation  orient = FT_ORIENTATION_NONE;       first = outline->points;     for ( i = 0; i< outline->n_contours; i++, first = last + 1 )     {       FT_Vector*  point;       FT_Vector*  xmin_point;       FT_Pos      xmin;         last = outline->points + outline->contours[i];
comment|/* skip degenerate contours */
end_comment
begin_comment
unit|if ( last< first + 2 )         continue;        if ( ft_contour_enclosed( outline, i ) )         continue;        xmin       = first->x;       xmin_point = first;        for ( point = first + 1; point<= last; point++ )       {         if ( point->x< xmin )         {           xmin       = point->x;           xmin_point = point;         }       }
comment|/* check the orientation of the contour */
end_comment
begin_endif
unit|{         FT_Vector*      prev;         FT_Vector*      next;         FT_Orientation  o;           prev = ( xmin_point == first ) ? last : xmin_point - 1;         next = ( xmin_point == last ) ? first : xmin_point + 1;          if ( FT_Atan2( prev->x - xmin_point->x, prev->y - xmin_point->y )>              FT_Atan2( next->x - xmin_point->x, next->y - xmin_point->y ) )           o = FT_ORIENTATION_POSTSCRIPT;         else           o = FT_ORIENTATION_TRUETYPE;          if ( orient == FT_ORIENTATION_NONE )           orient = o;         else if ( orient != o )           return FT_ORIENTATION_NONE;       }     }      return orient;   }
endif|#
directive|endif
end_endif
begin_comment
comment|/* 0 */
end_comment
begin_comment
comment|/* documentation is in ftoutln.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_Outline_Embolden
argument_list|(
argument|FT_Outline*  outline
argument_list|,
argument|FT_Pos       strength
argument_list|)
end_macro
begin_block
block|{
return|return
name|FT_Outline_EmboldenXY
argument_list|(
name|outline
argument_list|,
name|strength
argument_list|,
name|strength
argument_list|)
return|;
block|}
end_block
begin_comment
comment|/* documentation is in ftoutln.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_Outline_EmboldenXY
argument_list|(
argument|FT_Outline*  outline
argument_list|,
argument|FT_Pos       xstrength
argument_list|,
argument|FT_Pos       ystrength
argument_list|)
end_macro
begin_block
block|{
name|FT_Vector
modifier|*
name|points
decl_stmt|;
name|FT_Vector
name|v_prev
decl_stmt|,
name|v_first
decl_stmt|,
name|v_next
decl_stmt|,
name|v_cur
decl_stmt|;
name|FT_Int
name|c
decl_stmt|,
name|n
decl_stmt|,
name|first
decl_stmt|;
name|FT_Int
name|orientation
decl_stmt|;
if|if
condition|(
operator|!
name|outline
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_Outline
argument_list|)
return|;
name|xstrength
operator|/=
literal|2
expr_stmt|;
name|ystrength
operator|/=
literal|2
expr_stmt|;
if|if
condition|(
name|xstrength
operator|==
literal|0
operator|&&
name|ystrength
operator|==
literal|0
condition|)
return|return
name|FT_Err_Ok
return|;
name|orientation
operator|=
name|FT_Outline_Get_Orientation
argument_list|(
name|outline
argument_list|)
expr_stmt|;
if|if
condition|(
name|orientation
operator|==
name|FT_ORIENTATION_NONE
condition|)
block|{
if|if
condition|(
name|outline
operator|->
name|n_contours
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_Argument
argument_list|)
return|;
else|else
return|return
name|FT_Err_Ok
return|;
block|}
name|points
operator|=
name|outline
operator|->
name|points
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|outline
operator|->
name|n_contours
condition|;
name|c
operator|++
control|)
block|{
name|FT_Vector
name|in
decl_stmt|,
name|out
decl_stmt|,
name|shift
decl_stmt|;
name|FT_Fixed
name|l_in
decl_stmt|,
name|l_out
decl_stmt|,
name|l
decl_stmt|,
name|q
decl_stmt|,
name|d
decl_stmt|;
name|int
name|last
init|=
name|outline
operator|->
name|contours
index|[
name|c
index|]
decl_stmt|;
name|v_first
operator|=
name|points
index|[
name|first
index|]
expr_stmt|;
name|v_prev
operator|=
name|points
index|[
name|last
index|]
expr_stmt|;
name|v_cur
operator|=
name|v_first
expr_stmt|;
comment|/* compute incoming normalized vector */
name|in
operator|.
name|x
operator|=
name|v_cur
operator|.
name|x
operator|-
name|v_prev
operator|.
name|x
expr_stmt|;
name|in
operator|.
name|y
operator|=
name|v_cur
operator|.
name|y
operator|-
name|v_prev
operator|.
name|y
expr_stmt|;
name|l_in
operator|=
name|FT_Vector_Length
argument_list|(
operator|&
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_in
condition|)
block|{
name|in
operator|.
name|x
operator|=
name|FT_DivFix
argument_list|(
name|in
operator|.
name|x
argument_list|,
name|l_in
argument_list|)
expr_stmt|;
name|in
operator|.
name|y
operator|=
name|FT_DivFix
argument_list|(
name|in
operator|.
name|y
argument_list|,
name|l_in
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|n
operator|=
name|first
init|;
name|n
operator|<=
name|last
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|n
operator|<
name|last
condition|)
name|v_next
operator|=
name|points
index|[
name|n
operator|+
literal|1
index|]
expr_stmt|;
else|else
name|v_next
operator|=
name|v_first
expr_stmt|;
comment|/* compute outgoing normalized vector */
name|out
operator|.
name|x
operator|=
name|v_next
operator|.
name|x
operator|-
name|v_cur
operator|.
name|x
expr_stmt|;
name|out
operator|.
name|y
operator|=
name|v_next
operator|.
name|y
operator|-
name|v_cur
operator|.
name|y
expr_stmt|;
name|l_out
operator|=
name|FT_Vector_Length
argument_list|(
operator|&
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_out
condition|)
block|{
name|out
operator|.
name|x
operator|=
name|FT_DivFix
argument_list|(
name|out
operator|.
name|x
argument_list|,
name|l_out
argument_list|)
expr_stmt|;
name|out
operator|.
name|y
operator|=
name|FT_DivFix
argument_list|(
name|out
operator|.
name|y
argument_list|,
name|l_out
argument_list|)
expr_stmt|;
block|}
name|d
operator|=
name|FT_MulFix
argument_list|(
name|in
operator|.
name|x
argument_list|,
name|out
operator|.
name|x
argument_list|)
operator|+
name|FT_MulFix
argument_list|(
name|in
operator|.
name|y
argument_list|,
name|out
operator|.
name|y
argument_list|)
expr_stmt|;
comment|/* shift only if turn is less than ~160 degrees */
if|if
condition|(
name|d
operator|>
operator|-
literal|0xF000L
condition|)
block|{
name|d
operator|=
name|d
operator|+
literal|0x10000L
expr_stmt|;
comment|/* shift components are aligned along lateral bisector */
comment|/* and directed according to the outline orientation.  */
name|shift
operator|.
name|x
operator|=
name|in
operator|.
name|y
operator|+
name|out
operator|.
name|y
expr_stmt|;
name|shift
operator|.
name|y
operator|=
name|in
operator|.
name|x
operator|+
name|out
operator|.
name|x
expr_stmt|;
if|if
condition|(
name|orientation
operator|==
name|FT_ORIENTATION_TRUETYPE
condition|)
name|shift
operator|.
name|x
operator|=
operator|-
name|shift
operator|.
name|x
expr_stmt|;
else|else
name|shift
operator|.
name|y
operator|=
operator|-
name|shift
operator|.
name|y
expr_stmt|;
comment|/* restrict shift magnitude to better handle collapsing segments */
name|q
operator|=
name|FT_MulFix
argument_list|(
name|out
operator|.
name|x
argument_list|,
name|in
operator|.
name|y
argument_list|)
operator|-
name|FT_MulFix
argument_list|(
name|out
operator|.
name|y
argument_list|,
name|in
operator|.
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|orientation
operator|==
name|FT_ORIENTATION_TRUETYPE
condition|)
name|q
operator|=
operator|-
name|q
expr_stmt|;
name|l
operator|=
name|FT_MIN
argument_list|(
name|l_in
argument_list|,
name|l_out
argument_list|)
expr_stmt|;
comment|/* non-strict inequalities avoid divide-by-zero when q == l == 0 */
if|if
condition|(
name|FT_MulFix
argument_list|(
name|xstrength
argument_list|,
name|q
argument_list|)
operator|<=
name|FT_MulFix
argument_list|(
name|d
argument_list|,
name|l
argument_list|)
condition|)
name|shift
operator|.
name|x
operator|=
name|FT_MulDiv
argument_list|(
name|shift
operator|.
name|x
argument_list|,
name|xstrength
argument_list|,
name|d
argument_list|)
expr_stmt|;
else|else
name|shift
operator|.
name|x
operator|=
name|FT_MulDiv
argument_list|(
name|shift
operator|.
name|x
argument_list|,
name|l
argument_list|,
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|FT_MulFix
argument_list|(
name|ystrength
argument_list|,
name|q
argument_list|)
operator|<=
name|FT_MulFix
argument_list|(
name|d
argument_list|,
name|l
argument_list|)
condition|)
name|shift
operator|.
name|y
operator|=
name|FT_MulDiv
argument_list|(
name|shift
operator|.
name|y
argument_list|,
name|ystrength
argument_list|,
name|d
argument_list|)
expr_stmt|;
else|else
name|shift
operator|.
name|y
operator|=
name|FT_MulDiv
argument_list|(
name|shift
operator|.
name|y
argument_list|,
name|l
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
else|else
name|shift
operator|.
name|x
operator|=
name|shift
operator|.
name|y
operator|=
literal|0
expr_stmt|;
name|outline
operator|->
name|points
index|[
name|n
index|]
operator|.
name|x
operator|=
name|v_cur
operator|.
name|x
operator|+
name|xstrength
operator|+
name|shift
operator|.
name|x
expr_stmt|;
name|outline
operator|->
name|points
index|[
name|n
index|]
operator|.
name|y
operator|=
name|v_cur
operator|.
name|y
operator|+
name|ystrength
operator|+
name|shift
operator|.
name|y
expr_stmt|;
name|in
operator|=
name|out
expr_stmt|;
name|l_in
operator|=
name|l_out
expr_stmt|;
name|v_cur
operator|=
name|v_next
expr_stmt|;
block|}
name|first
operator|=
name|last
operator|+
literal|1
expr_stmt|;
block|}
return|return
name|FT_Err_Ok
return|;
block|}
end_block
begin_comment
comment|/* documentation is in ftoutln.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Orientation
argument_list|)
end_macro
begin_macro
name|FT_Outline_Get_Orientation
argument_list|(
argument|FT_Outline*  outline
argument_list|)
end_macro
begin_block
block|{
name|FT_BBox
name|cbox
decl_stmt|;
name|FT_Int
name|xshift
decl_stmt|,
name|yshift
decl_stmt|;
name|FT_Vector
modifier|*
name|points
decl_stmt|;
name|FT_Vector
name|v_prev
decl_stmt|,
name|v_cur
decl_stmt|;
name|FT_Int
name|c
decl_stmt|,
name|n
decl_stmt|,
name|first
decl_stmt|;
name|FT_Pos
name|area
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|outline
operator|||
name|outline
operator|->
name|n_points
operator|<=
literal|0
condition|)
return|return
name|FT_ORIENTATION_TRUETYPE
return|;
comment|/* We use the nonzero winding rule to find the orientation.       */
comment|/* Since glyph outlines behave much more `regular' than arbitrary */
comment|/* cubic or quadratic curves, this test deals with the polygon    */
comment|/* only which is spanned up by the control points.                */
name|FT_Outline_Get_CBox
argument_list|(
name|outline
argument_list|,
operator|&
name|cbox
argument_list|)
expr_stmt|;
comment|/* Handle collapsed outlines to avoid undefined FT_MSB. */
if|if
condition|(
name|cbox
operator|.
name|xMin
operator|==
name|cbox
operator|.
name|xMax
operator|||
name|cbox
operator|.
name|yMin
operator|==
name|cbox
operator|.
name|yMax
condition|)
return|return
name|FT_ORIENTATION_NONE
return|;
name|xshift
operator|=
name|FT_MSB
argument_list|(
name|FT_ABS
argument_list|(
name|cbox
operator|.
name|xMax
argument_list|)
operator||
name|FT_ABS
argument_list|(
name|cbox
operator|.
name|xMin
argument_list|)
argument_list|)
operator|-
literal|14
expr_stmt|;
name|xshift
operator|=
name|FT_MAX
argument_list|(
name|xshift
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|yshift
operator|=
name|FT_MSB
argument_list|(
name|cbox
operator|.
name|yMax
operator|-
name|cbox
operator|.
name|yMin
argument_list|)
operator|-
literal|14
expr_stmt|;
name|yshift
operator|=
name|FT_MAX
argument_list|(
name|yshift
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|points
operator|=
name|outline
operator|->
name|points
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|outline
operator|->
name|n_contours
condition|;
name|c
operator|++
control|)
block|{
name|FT_Int
name|last
init|=
name|outline
operator|->
name|contours
index|[
name|c
index|]
decl_stmt|;
name|v_prev
operator|=
name|points
index|[
name|last
index|]
expr_stmt|;
for|for
control|(
name|n
operator|=
name|first
init|;
name|n
operator|<=
name|last
condition|;
name|n
operator|++
control|)
block|{
name|v_cur
operator|=
name|points
index|[
name|n
index|]
expr_stmt|;
name|area
operator|+=
operator|(
operator|(
name|v_cur
operator|.
name|y
operator|-
name|v_prev
operator|.
name|y
operator|)
operator|>>
name|yshift
operator|)
operator|*
operator|(
operator|(
name|v_cur
operator|.
name|x
operator|+
name|v_prev
operator|.
name|x
operator|)
operator|>>
name|xshift
operator|)
expr_stmt|;
name|v_prev
operator|=
name|v_cur
expr_stmt|;
block|}
name|first
operator|=
name|last
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|area
operator|>
literal|0
condition|)
return|return
name|FT_ORIENTATION_POSTSCRIPT
return|;
elseif|else
if|if
condition|(
name|area
operator|<
literal|0
condition|)
return|return
name|FT_ORIENTATION_TRUETYPE
return|;
else|else
return|return
name|FT_ORIENTATION_NONE
return|;
block|}
end_block
begin_comment
comment|/* END */
end_comment
end_unit
