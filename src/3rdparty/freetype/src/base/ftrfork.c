begin_unit
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  ftrfork.c                                                              */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*    Embedded resource forks accessor (body).                             */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  Copyright 2004, 2005, 2006, 2007, 2008, 2009 by                        */
end_comment
begin_comment
comment|/*  Masatake YAMATO and Redhat K.K.                                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  FT_Raccess_Get_HeaderInfo() and raccess_guess_darwin_hfsplus() are     */
end_comment
begin_comment
comment|/*  derived from ftobjs.c.                                                 */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  This file is part of the FreeType project, and may only be used,       */
end_comment
begin_comment
comment|/*  modified, and distributed under the terms of the FreeType project      */
end_comment
begin_comment
comment|/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
end_comment
begin_comment
comment|/*  this file you indicate that you have read the license and              */
end_comment
begin_comment
comment|/*  understand and accept it fully.                                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/* Development of the code in this file is support of                      */
end_comment
begin_comment
comment|/* Information-technology Promotion Agency, Japan.                         */
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<ft2build.h>
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_DEBUG_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_STREAM_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_RFORK_H
end_include
begin_undef
DECL|macro|FT_COMPONENT
undef|#
directive|undef
name|FT_COMPONENT
end_undef
begin_define
DECL|macro|FT_COMPONENT
define|#
directive|define
name|FT_COMPONENT
value|trace_raccess
end_define
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/****                                                                 ****/
end_comment
begin_comment
comment|/****                                                                 ****/
end_comment
begin_comment
comment|/****               Resource fork directory access                    ****/
end_comment
begin_comment
comment|/****                                                                 ****/
end_comment
begin_comment
comment|/****                                                                 ****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_macro
DECL|function|FT_BASE_DEF
name|FT_BASE_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_Raccess_Get_HeaderInfo
argument_list|(
argument|FT_Library  library
argument_list|,
argument|FT_Stream   stream
argument_list|,
argument|FT_Long     rfork_offset
argument_list|,
argument|FT_Long    *map_offset
argument_list|,
argument|FT_Long    *rdata_pos
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
decl_stmt|;
name|unsigned
name|char
name|head
index|[
literal|16
index|]
decl_stmt|,
name|head2
index|[
literal|16
index|]
decl_stmt|;
name|FT_Long
name|map_pos
decl_stmt|,
name|rdata_len
decl_stmt|;
name|int
name|allzeros
decl_stmt|,
name|allmatch
decl_stmt|,
name|i
decl_stmt|;
name|FT_Long
name|type_list
decl_stmt|;
name|FT_UNUSED
argument_list|(
name|library
argument_list|)
expr_stmt|;
name|error
operator|=
name|FT_Stream_Seek
argument_list|(
name|stream
argument_list|,
name|rfork_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|error
operator|=
name|FT_Stream_Read
argument_list|(
name|stream
argument_list|,
operator|(
name|FT_Byte
operator|*
operator|)
name|head
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
operator|*
name|rdata_pos
operator|=
name|rfork_offset
operator|+
operator|(
operator|(
name|head
index|[
literal|0
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|head
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|head
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator||
name|head
index|[
literal|3
index|]
operator|)
expr_stmt|;
name|map_pos
operator|=
name|rfork_offset
operator|+
operator|(
operator|(
name|head
index|[
literal|4
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|head
index|[
literal|5
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|head
index|[
literal|6
index|]
operator|<<
literal|8
operator|)
operator||
name|head
index|[
literal|7
index|]
operator|)
expr_stmt|;
name|rdata_len
operator|=
operator|(
name|head
index|[
literal|8
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|head
index|[
literal|9
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|head
index|[
literal|10
index|]
operator|<<
literal|8
operator|)
operator||
name|head
index|[
literal|11
index|]
expr_stmt|;
comment|/* map_len = head[12] .. head[15] */
if|if
condition|(
operator|*
name|rdata_pos
operator|+
name|rdata_len
operator|!=
name|map_pos
operator|||
name|map_pos
operator|==
name|rfork_offset
condition|)
return|return
name|FT_Err_Unknown_File_Format
return|;
name|error
operator|=
name|FT_Stream_Seek
argument_list|(
name|stream
argument_list|,
name|map_pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|head2
index|[
literal|15
index|]
operator|=
call|(
name|FT_Byte
call|)
argument_list|(
name|head
index|[
literal|15
index|]
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* make it be different */
name|error
operator|=
name|FT_Stream_Read
argument_list|(
name|stream
argument_list|,
operator|(
name|FT_Byte
operator|*
operator|)
name|head2
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|allzeros
operator|=
literal|1
expr_stmt|;
name|allmatch
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|head2
index|[
name|i
index|]
operator|!=
literal|0
condition|)
name|allzeros
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|head2
index|[
name|i
index|]
operator|!=
name|head
index|[
name|i
index|]
condition|)
name|allmatch
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|allzeros
operator|&&
operator|!
name|allmatch
condition|)
return|return
name|FT_Err_Unknown_File_Format
return|;
comment|/* If we have reached this point then it is probably a mac resource */
comment|/* file.  Now, does it contain any interesting resources?           */
comment|/* Skip handle to next resource map, the file resource number, and  */
comment|/* attributes.                                                      */
operator|(
name|void
operator|)
name|FT_STREAM_SKIP
argument_list|(
literal|4
comment|/* skip handle to next resource map */
operator|+
literal|2
comment|/* skip file resource number */
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|/* skip attributes */
if|if
condition|(
name|FT_READ_USHORT
argument_list|(
name|type_list
argument_list|)
condition|)
return|return
name|error
return|;
if|if
condition|(
name|type_list
operator|==
operator|-
literal|1
condition|)
return|return
name|FT_Err_Unknown_File_Format
return|;
name|error
operator|=
name|FT_Stream_Seek
argument_list|(
name|stream
argument_list|,
name|map_pos
operator|+
name|type_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
operator|*
name|map_offset
operator|=
name|map_pos
operator|+
name|type_list
expr_stmt|;
return|return
name|FT_Err_Ok
return|;
block|}
end_block
begin_function
specifier|static
name|int
DECL|function|ft_raccess_sort_ref_by_id
name|ft_raccess_sort_ref_by_id
parameter_list|(
name|FT_RFork_Ref
modifier|*
name|a
parameter_list|,
name|FT_RFork_Ref
modifier|*
name|b
parameter_list|)
block|{
if|if
condition|(
name|a
operator|->
name|res_id
operator|<
name|b
operator|->
name|res_id
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
name|a
operator|->
name|res_id
operator|>
name|b
operator|->
name|res_id
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function
begin_macro
DECL|function|FT_BASE_DEF
name|FT_BASE_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_Raccess_Get_DataOffsets
argument_list|(
argument|FT_Library  library
argument_list|,
argument|FT_Stream   stream
argument_list|,
argument|FT_Long     map_offset
argument_list|,
argument|FT_Long     rdata_pos
argument_list|,
argument|FT_Long     tag
argument_list|,
argument|FT_Long   **offsets
argument_list|,
argument|FT_Long    *count
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|cnt
decl_stmt|,
name|subcnt
decl_stmt|;
name|FT_Long
name|tag_internal
decl_stmt|,
name|rpos
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|library
operator|->
name|memory
decl_stmt|;
name|FT_Long
name|temp
decl_stmt|;
name|FT_Long
modifier|*
name|offsets_internal
decl_stmt|;
name|FT_RFork_Ref
modifier|*
name|ref
decl_stmt|;
name|error
operator|=
name|FT_Stream_Seek
argument_list|(
name|stream
argument_list|,
name|map_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
name|FT_READ_USHORT
argument_list|(
name|cnt
argument_list|)
condition|)
return|return
name|error
return|;
name|cnt
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|FT_READ_LONG
argument_list|(
name|tag_internal
argument_list|)
operator|||
name|FT_READ_USHORT
argument_list|(
name|subcnt
argument_list|)
operator|||
name|FT_READ_USHORT
argument_list|(
name|rpos
argument_list|)
condition|)
return|return
name|error
return|;
name|FT_TRACE2
argument_list|(
operator|(
literal|"Resource tags: %c%c%c%c\n"
operator|,
call|(
name|char
call|)
argument_list|(
literal|0xff
operator|&
operator|(
name|tag_internal
operator|>>
literal|24
operator|)
argument_list|)
operator|,
call|(
name|char
call|)
argument_list|(
literal|0xff
operator|&
operator|(
name|tag_internal
operator|>>
literal|16
operator|)
argument_list|)
operator|,
call|(
name|char
call|)
argument_list|(
literal|0xff
operator|&
operator|(
name|tag_internal
operator|>>
literal|8
operator|)
argument_list|)
operator|,
call|(
name|char
call|)
argument_list|(
literal|0xff
operator|&
operator|(
name|tag_internal
operator|>>
literal|0
operator|)
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag_internal
operator|==
name|tag
condition|)
block|{
operator|*
name|count
operator|=
name|subcnt
operator|+
literal|1
expr_stmt|;
name|rpos
operator|+=
name|map_offset
expr_stmt|;
name|error
operator|=
name|FT_Stream_Seek
argument_list|(
name|stream
argument_list|,
name|rpos
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|ref
argument_list|,
operator|*
name|count
argument_list|)
condition|)
return|return
name|error
return|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
operator|*
name|count
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|FT_READ_USHORT
argument_list|(
name|ref
index|[
name|j
index|]
operator|.
name|res_id
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
if|if
condition|(
name|FT_STREAM_SKIP
argument_list|(
literal|2
argument_list|)
condition|)
comment|/* resource name */
goto|goto
name|Exit
goto|;
if|if
condition|(
name|FT_READ_LONG
argument_list|(
name|temp
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
if|if
condition|(
name|FT_STREAM_SKIP
argument_list|(
literal|4
argument_list|)
condition|)
comment|/* mbz */
goto|goto
name|Exit
goto|;
name|ref
index|[
name|j
index|]
operator|.
name|offset
operator|=
name|temp
operator|&
literal|0xFFFFFFL
expr_stmt|;
block|}
name|ft_qsort
argument_list|(
name|ref
argument_list|,
operator|*
name|count
argument_list|,
sizeof|sizeof
argument_list|(
name|FT_RFork_Ref
argument_list|)
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
specifier|const
name|void
operator|*
argument_list|,
specifier|const
name|void
operator|*
argument_list|)
operator|)
name|ft_raccess_sort_ref_by_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|offsets_internal
argument_list|,
operator|*
name|count
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
comment|/* XXX: duplicated reference ID,          *      gap between reference IDs are acceptable?          *      further investigation on Apple implementation is needed.          */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
operator|*
name|count
condition|;
operator|++
name|j
control|)
name|offsets_internal
index|[
name|j
index|]
operator|=
name|rdata_pos
operator|+
name|ref
index|[
name|j
index|]
operator|.
name|offset
expr_stmt|;
operator|*
name|offsets
operator|=
name|offsets_internal
expr_stmt|;
name|error
operator|=
name|FT_Err_Ok
expr_stmt|;
name|Exit
label|:
name|FT_FREE
argument_list|(
name|ref
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
block|}
return|return
name|FT_Err_Cannot_Open_Resource
return|;
block|}
end_block
begin_ifdef
ifdef|#
directive|ifdef
name|FT_CONFIG_OPTION_GUESSING_EMBEDDED_RFORK
end_ifdef
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/****                                                                 ****/
end_comment
begin_comment
comment|/****                                                                 ****/
end_comment
begin_comment
comment|/****                     Guessing functions                          ****/
end_comment
begin_comment
comment|/****                                                                 ****/
end_comment
begin_comment
comment|/****            When you add a new guessing function,                ****/
end_comment
begin_comment
comment|/****           update FT_RACCESS_N_RULES in ftrfork.h.               ****/
end_comment
begin_comment
comment|/****                                                                 ****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_typedef
typedef|typedef
name|FT_Error
function_decl|(
DECL|typedef|raccess_guess_func
modifier|*
name|raccess_guess_func
function_decl|)
parameter_list|(
name|FT_Library
name|library
parameter_list|,
name|FT_Stream
name|stream
parameter_list|,
name|char
modifier|*
name|base_file_name
parameter_list|,
name|char
modifier|*
modifier|*
name|result_file_name
parameter_list|,
name|FT_Long
modifier|*
name|result_offset
parameter_list|)
function_decl|;
end_typedef
begin_function_decl
specifier|static
name|FT_Error
name|raccess_guess_apple_double
parameter_list|(
name|FT_Library
name|library
parameter_list|,
name|FT_Stream
name|stream
parameter_list|,
name|char
modifier|*
name|base_file_name
parameter_list|,
name|char
modifier|*
modifier|*
name|result_file_name
parameter_list|,
name|FT_Long
modifier|*
name|result_offset
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|FT_Error
name|raccess_guess_apple_single
parameter_list|(
name|FT_Library
name|library
parameter_list|,
name|FT_Stream
name|stream
parameter_list|,
name|char
modifier|*
name|base_file_name
parameter_list|,
name|char
modifier|*
modifier|*
name|result_file_name
parameter_list|,
name|FT_Long
modifier|*
name|result_offset
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|FT_Error
name|raccess_guess_darwin_ufs_export
parameter_list|(
name|FT_Library
name|library
parameter_list|,
name|FT_Stream
name|stream
parameter_list|,
name|char
modifier|*
name|base_file_name
parameter_list|,
name|char
modifier|*
modifier|*
name|result_file_name
parameter_list|,
name|FT_Long
modifier|*
name|result_offset
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|FT_Error
name|raccess_guess_darwin_newvfs
parameter_list|(
name|FT_Library
name|library
parameter_list|,
name|FT_Stream
name|stream
parameter_list|,
name|char
modifier|*
name|base_file_name
parameter_list|,
name|char
modifier|*
modifier|*
name|result_file_name
parameter_list|,
name|FT_Long
modifier|*
name|result_offset
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|FT_Error
name|raccess_guess_darwin_hfsplus
parameter_list|(
name|FT_Library
name|library
parameter_list|,
name|FT_Stream
name|stream
parameter_list|,
name|char
modifier|*
name|base_file_name
parameter_list|,
name|char
modifier|*
modifier|*
name|result_file_name
parameter_list|,
name|FT_Long
modifier|*
name|result_offset
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|FT_Error
name|raccess_guess_vfat
parameter_list|(
name|FT_Library
name|library
parameter_list|,
name|FT_Stream
name|stream
parameter_list|,
name|char
modifier|*
name|base_file_name
parameter_list|,
name|char
modifier|*
modifier|*
name|result_file_name
parameter_list|,
name|FT_Long
modifier|*
name|result_offset
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|FT_Error
name|raccess_guess_linux_cap
parameter_list|(
name|FT_Library
name|library
parameter_list|,
name|FT_Stream
name|stream
parameter_list|,
name|char
modifier|*
name|base_file_name
parameter_list|,
name|char
modifier|*
modifier|*
name|result_file_name
parameter_list|,
name|FT_Long
modifier|*
name|result_offset
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|FT_Error
name|raccess_guess_linux_double
parameter_list|(
name|FT_Library
name|library
parameter_list|,
name|FT_Stream
name|stream
parameter_list|,
name|char
modifier|*
name|base_file_name
parameter_list|,
name|char
modifier|*
modifier|*
name|result_file_name
parameter_list|,
name|FT_Long
modifier|*
name|result_offset
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|FT_Error
name|raccess_guess_linux_netatalk
parameter_list|(
name|FT_Library
name|library
parameter_list|,
name|FT_Stream
name|stream
parameter_list|,
name|char
modifier|*
name|base_file_name
parameter_list|,
name|char
modifier|*
modifier|*
name|result_file_name
parameter_list|,
name|FT_Long
modifier|*
name|result_offset
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/****                                                                 ****/
end_comment
begin_comment
comment|/****                       Helper functions                          ****/
end_comment
begin_comment
comment|/****                                                                 ****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_function_decl
specifier|static
name|FT_Error
name|raccess_guess_apple_generic
parameter_list|(
name|FT_Library
name|library
parameter_list|,
name|FT_Stream
name|stream
parameter_list|,
name|char
modifier|*
name|base_file_name
parameter_list|,
name|FT_Int32
name|magic
parameter_list|,
name|FT_Long
modifier|*
name|result_offset
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|FT_Error
name|raccess_guess_linux_double_from_file_name
parameter_list|(
name|FT_Library
name|library
parameter_list|,
name|char
modifier|*
name|file_name
parameter_list|,
name|FT_Long
modifier|*
name|result_offset
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|char
modifier|*
name|raccess_make_file_name
parameter_list|(
name|FT_Memory
name|memory
parameter_list|,
specifier|const
name|char
modifier|*
name|original_name
parameter_list|,
specifier|const
name|char
modifier|*
name|insertion
parameter_list|)
function_decl|;
end_function_decl
begin_macro
name|FT_BASE_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|FT_Raccess_Guess
name|FT_Raccess_Guess
argument_list|(
argument|FT_Library  library
argument_list|,
argument|FT_Stream   stream
argument_list|,
argument|char*       base_name
argument_list|,
argument|char      **new_names
argument_list|,
argument|FT_Long    *offsets
argument_list|,
argument|FT_Error   *errors
argument_list|)
end_macro
begin_block
block|{
name|FT_Long
name|i
decl_stmt|;
name|raccess_guess_func
name|funcs
index|[
name|FT_RACCESS_N_RULES
index|]
init|=
block|{
name|raccess_guess_apple_double
block|,
name|raccess_guess_apple_single
block|,
name|raccess_guess_darwin_ufs_export
block|,
name|raccess_guess_darwin_newvfs
block|,
name|raccess_guess_darwin_hfsplus
block|,
name|raccess_guess_vfat
block|,
name|raccess_guess_linux_cap
block|,
name|raccess_guess_linux_double
block|,
name|raccess_guess_linux_netatalk
block|,     }
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FT_RACCESS_N_RULES
condition|;
name|i
operator|++
control|)
block|{
name|new_names
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|stream
condition|)
name|errors
index|[
name|i
index|]
operator|=
name|FT_Stream_Seek
argument_list|(
name|stream
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|errors
index|[
name|i
index|]
operator|=
name|FT_Err_Ok
expr_stmt|;
if|if
condition|(
name|errors
index|[
name|i
index|]
condition|)
continue|continue ;
name|errors
index|[
name|i
index|]
operator|=
operator|(
name|funcs
index|[
name|i
index|]
operator|)
operator|(
name|library
operator|,
name|stream
operator|,
name|base_name
operator|,
operator|&
operator|(
name|new_names
index|[
name|i
index|]
operator|)
operator|,
operator|&
operator|(
name|offsets
index|[
name|i
index|]
operator|)
operator|)
expr_stmt|;
block|}
return|return;
block|}
end_block
begin_function
specifier|static
name|FT_Error
DECL|function|raccess_guess_apple_double
name|raccess_guess_apple_double
parameter_list|(
name|FT_Library
name|library
parameter_list|,
name|FT_Stream
name|stream
parameter_list|,
name|char
modifier|*
name|base_file_name
parameter_list|,
name|char
modifier|*
modifier|*
name|result_file_name
parameter_list|,
name|FT_Long
modifier|*
name|result_offset
parameter_list|)
block|{
name|FT_Int32
name|magic
init|=
operator|(
literal|0x00
operator|<<
literal|24
operator|)
operator||
operator|(
literal|0x05
operator|<<
literal|16
operator|)
operator||
operator|(
literal|0x16
operator|<<
literal|8
operator|)
operator||
literal|0x07
decl_stmt|;
operator|*
name|result_file_name
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|stream
condition|)
return|return
name|FT_Err_Cannot_Open_Stream
return|;
return|return
name|raccess_guess_apple_generic
argument_list|(
name|library
argument_list|,
name|stream
argument_list|,
name|base_file_name
argument_list|,
name|magic
argument_list|,
name|result_offset
argument_list|)
return|;
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|raccess_guess_apple_single
name|raccess_guess_apple_single
parameter_list|(
name|FT_Library
name|library
parameter_list|,
name|FT_Stream
name|stream
parameter_list|,
name|char
modifier|*
name|base_file_name
parameter_list|,
name|char
modifier|*
modifier|*
name|result_file_name
parameter_list|,
name|FT_Long
modifier|*
name|result_offset
parameter_list|)
block|{
name|FT_Int32
name|magic
init|=
operator|(
literal|0x00
operator|<<
literal|24
operator|)
operator||
operator|(
literal|0x05
operator|<<
literal|16
operator|)
operator||
operator|(
literal|0x16
operator|<<
literal|8
operator|)
operator||
literal|0x00
decl_stmt|;
operator|*
name|result_file_name
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|stream
condition|)
return|return
name|FT_Err_Cannot_Open_Stream
return|;
return|return
name|raccess_guess_apple_generic
argument_list|(
name|library
argument_list|,
name|stream
argument_list|,
name|base_file_name
argument_list|,
name|magic
argument_list|,
name|result_offset
argument_list|)
return|;
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|raccess_guess_darwin_ufs_export
name|raccess_guess_darwin_ufs_export
parameter_list|(
name|FT_Library
name|library
parameter_list|,
name|FT_Stream
name|stream
parameter_list|,
name|char
modifier|*
name|base_file_name
parameter_list|,
name|char
modifier|*
modifier|*
name|result_file_name
parameter_list|,
name|FT_Long
modifier|*
name|result_offset
parameter_list|)
block|{
name|char
modifier|*
name|newpath
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|FT_Memory
name|memory
decl_stmt|;
name|FT_UNUSED
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|memory
operator|=
name|library
operator|->
name|memory
expr_stmt|;
name|newpath
operator|=
name|raccess_make_file_name
argument_list|(
name|memory
argument_list|,
name|base_file_name
argument_list|,
literal|"._"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|newpath
condition|)
return|return
name|FT_Err_Out_Of_Memory
return|;
name|error
operator|=
name|raccess_guess_linux_double_from_file_name
argument_list|(
name|library
argument_list|,
name|newpath
argument_list|,
name|result_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
operator|*
name|result_file_name
operator|=
name|newpath
expr_stmt|;
else|else
name|FT_FREE
argument_list|(
name|newpath
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|raccess_guess_darwin_hfsplus
name|raccess_guess_darwin_hfsplus
parameter_list|(
name|FT_Library
name|library
parameter_list|,
name|FT_Stream
name|stream
parameter_list|,
name|char
modifier|*
name|base_file_name
parameter_list|,
name|char
modifier|*
modifier|*
name|result_file_name
parameter_list|,
name|FT_Long
modifier|*
name|result_offset
parameter_list|)
block|{
comment|/*       Only meaningful on systems with hfs+ drivers (or Macs).      */
name|FT_Error
name|error
decl_stmt|;
name|char
modifier|*
name|newpath
decl_stmt|;
name|FT_Memory
name|memory
decl_stmt|;
name|FT_Long
name|base_file_len
init|=
name|ft_strlen
argument_list|(
name|base_file_name
argument_list|)
decl_stmt|;
name|FT_UNUSED
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|memory
operator|=
name|library
operator|->
name|memory
expr_stmt|;
if|if
condition|(
name|base_file_len
operator|+
literal|6
operator|>
name|FT_INT_MAX
condition|)
return|return
name|FT_Err_Array_Too_Large
return|;
if|if
condition|(
name|FT_ALLOC
argument_list|(
name|newpath
argument_list|,
name|base_file_len
operator|+
literal|6
argument_list|)
condition|)
return|return
name|error
return|;
name|FT_MEM_COPY
argument_list|(
name|newpath
argument_list|,
name|base_file_name
argument_list|,
name|base_file_len
argument_list|)
expr_stmt|;
name|FT_MEM_COPY
argument_list|(
name|newpath
operator|+
name|base_file_len
argument_list|,
literal|"/rsrc"
argument_list|,
literal|6
argument_list|)
expr_stmt|;
operator|*
name|result_file_name
operator|=
name|newpath
expr_stmt|;
operator|*
name|result_offset
operator|=
literal|0
expr_stmt|;
return|return
name|FT_Err_Ok
return|;
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|raccess_guess_darwin_newvfs
name|raccess_guess_darwin_newvfs
parameter_list|(
name|FT_Library
name|library
parameter_list|,
name|FT_Stream
name|stream
parameter_list|,
name|char
modifier|*
name|base_file_name
parameter_list|,
name|char
modifier|*
modifier|*
name|result_file_name
parameter_list|,
name|FT_Long
modifier|*
name|result_offset
parameter_list|)
block|{
comment|/*       Only meaningful on systems with Mac OS X (> 10.1).      */
name|FT_Error
name|error
decl_stmt|;
name|char
modifier|*
name|newpath
decl_stmt|;
name|FT_Memory
name|memory
decl_stmt|;
name|FT_Long
name|base_file_len
init|=
name|ft_strlen
argument_list|(
name|base_file_name
argument_list|)
decl_stmt|;
name|FT_UNUSED
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|memory
operator|=
name|library
operator|->
name|memory
expr_stmt|;
if|if
condition|(
name|base_file_len
operator|+
literal|18
operator|>
name|FT_INT_MAX
condition|)
return|return
name|FT_Err_Array_Too_Large
return|;
if|if
condition|(
name|FT_ALLOC
argument_list|(
name|newpath
argument_list|,
name|base_file_len
operator|+
literal|18
argument_list|)
condition|)
return|return
name|error
return|;
name|FT_MEM_COPY
argument_list|(
name|newpath
argument_list|,
name|base_file_name
argument_list|,
name|base_file_len
argument_list|)
expr_stmt|;
name|FT_MEM_COPY
argument_list|(
name|newpath
operator|+
name|base_file_len
argument_list|,
literal|"/..namedfork/rsrc"
argument_list|,
literal|18
argument_list|)
expr_stmt|;
operator|*
name|result_file_name
operator|=
name|newpath
expr_stmt|;
operator|*
name|result_offset
operator|=
literal|0
expr_stmt|;
return|return
name|FT_Err_Ok
return|;
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|raccess_guess_vfat
name|raccess_guess_vfat
parameter_list|(
name|FT_Library
name|library
parameter_list|,
name|FT_Stream
name|stream
parameter_list|,
name|char
modifier|*
name|base_file_name
parameter_list|,
name|char
modifier|*
modifier|*
name|result_file_name
parameter_list|,
name|FT_Long
modifier|*
name|result_offset
parameter_list|)
block|{
name|char
modifier|*
name|newpath
decl_stmt|;
name|FT_Memory
name|memory
decl_stmt|;
name|FT_UNUSED
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|memory
operator|=
name|library
operator|->
name|memory
expr_stmt|;
name|newpath
operator|=
name|raccess_make_file_name
argument_list|(
name|memory
argument_list|,
name|base_file_name
argument_list|,
literal|"resource.frk/"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|newpath
condition|)
return|return
name|FT_Err_Out_Of_Memory
return|;
operator|*
name|result_file_name
operator|=
name|newpath
expr_stmt|;
operator|*
name|result_offset
operator|=
literal|0
expr_stmt|;
return|return
name|FT_Err_Ok
return|;
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|raccess_guess_linux_cap
name|raccess_guess_linux_cap
parameter_list|(
name|FT_Library
name|library
parameter_list|,
name|FT_Stream
name|stream
parameter_list|,
name|char
modifier|*
name|base_file_name
parameter_list|,
name|char
modifier|*
modifier|*
name|result_file_name
parameter_list|,
name|FT_Long
modifier|*
name|result_offset
parameter_list|)
block|{
name|char
modifier|*
name|newpath
decl_stmt|;
name|FT_Memory
name|memory
decl_stmt|;
name|FT_UNUSED
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|memory
operator|=
name|library
operator|->
name|memory
expr_stmt|;
name|newpath
operator|=
name|raccess_make_file_name
argument_list|(
name|memory
argument_list|,
name|base_file_name
argument_list|,
literal|".resource/"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|newpath
condition|)
return|return
name|FT_Err_Out_Of_Memory
return|;
operator|*
name|result_file_name
operator|=
name|newpath
expr_stmt|;
operator|*
name|result_offset
operator|=
literal|0
expr_stmt|;
return|return
name|FT_Err_Ok
return|;
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|raccess_guess_linux_double
name|raccess_guess_linux_double
parameter_list|(
name|FT_Library
name|library
parameter_list|,
name|FT_Stream
name|stream
parameter_list|,
name|char
modifier|*
name|base_file_name
parameter_list|,
name|char
modifier|*
modifier|*
name|result_file_name
parameter_list|,
name|FT_Long
modifier|*
name|result_offset
parameter_list|)
block|{
name|char
modifier|*
name|newpath
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|FT_Memory
name|memory
decl_stmt|;
name|FT_UNUSED
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|memory
operator|=
name|library
operator|->
name|memory
expr_stmt|;
name|newpath
operator|=
name|raccess_make_file_name
argument_list|(
name|memory
argument_list|,
name|base_file_name
argument_list|,
literal|"%"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|newpath
condition|)
return|return
name|FT_Err_Out_Of_Memory
return|;
name|error
operator|=
name|raccess_guess_linux_double_from_file_name
argument_list|(
name|library
argument_list|,
name|newpath
argument_list|,
name|result_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
operator|*
name|result_file_name
operator|=
name|newpath
expr_stmt|;
else|else
name|FT_FREE
argument_list|(
name|newpath
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|raccess_guess_linux_netatalk
name|raccess_guess_linux_netatalk
parameter_list|(
name|FT_Library
name|library
parameter_list|,
name|FT_Stream
name|stream
parameter_list|,
name|char
modifier|*
name|base_file_name
parameter_list|,
name|char
modifier|*
modifier|*
name|result_file_name
parameter_list|,
name|FT_Long
modifier|*
name|result_offset
parameter_list|)
block|{
name|char
modifier|*
name|newpath
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|FT_Memory
name|memory
decl_stmt|;
name|FT_UNUSED
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|memory
operator|=
name|library
operator|->
name|memory
expr_stmt|;
name|newpath
operator|=
name|raccess_make_file_name
argument_list|(
name|memory
argument_list|,
name|base_file_name
argument_list|,
literal|".AppleDouble/"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|newpath
condition|)
return|return
name|FT_Err_Out_Of_Memory
return|;
name|error
operator|=
name|raccess_guess_linux_double_from_file_name
argument_list|(
name|library
argument_list|,
name|newpath
argument_list|,
name|result_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
operator|*
name|result_file_name
operator|=
name|newpath
expr_stmt|;
else|else
name|FT_FREE
argument_list|(
name|newpath
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|raccess_guess_apple_generic
name|raccess_guess_apple_generic
parameter_list|(
name|FT_Library
name|library
parameter_list|,
name|FT_Stream
name|stream
parameter_list|,
name|char
modifier|*
name|base_file_name
parameter_list|,
name|FT_Int32
name|magic
parameter_list|,
name|FT_Long
modifier|*
name|result_offset
parameter_list|)
block|{
name|FT_Int32
name|magic_from_stream
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|FT_Int32
name|version_number
init|=
literal|0
decl_stmt|;
name|FT_UShort
name|n_of_entries
decl_stmt|;
name|int
name|i
decl_stmt|;
name|FT_UInt32
name|entry_id
decl_stmt|,
name|entry_offset
decl_stmt|,
name|entry_length
init|=
literal|0
decl_stmt|;
specifier|const
name|FT_UInt32
name|resource_fork_entry_id
init|=
literal|0x2
decl_stmt|;
name|FT_UNUSED
argument_list|(
name|library
argument_list|)
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|base_file_name
argument_list|)
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|version_number
argument_list|)
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|entry_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|FT_READ_LONG
argument_list|(
name|magic_from_stream
argument_list|)
condition|)
return|return
name|error
return|;
if|if
condition|(
name|magic_from_stream
operator|!=
name|magic
condition|)
return|return
name|FT_Err_Unknown_File_Format
return|;
if|if
condition|(
name|FT_READ_LONG
argument_list|(
name|version_number
argument_list|)
condition|)
return|return
name|error
return|;
comment|/* filler */
name|error
operator|=
name|FT_Stream_Skip
argument_list|(
name|stream
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
name|FT_READ_USHORT
argument_list|(
name|n_of_entries
argument_list|)
condition|)
return|return
name|error
return|;
if|if
condition|(
name|n_of_entries
operator|==
literal|0
condition|)
return|return
name|FT_Err_Unknown_File_Format
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_of_entries
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|FT_READ_LONG
argument_list|(
name|entry_id
argument_list|)
condition|)
return|return
name|error
return|;
if|if
condition|(
name|entry_id
operator|==
name|resource_fork_entry_id
condition|)
block|{
if|if
condition|(
name|FT_READ_LONG
argument_list|(
name|entry_offset
argument_list|)
operator|||
name|FT_READ_LONG
argument_list|(
name|entry_length
argument_list|)
condition|)
continue|continue;
operator|*
name|result_offset
operator|=
name|entry_offset
expr_stmt|;
return|return
name|FT_Err_Ok
return|;
block|}
else|else
block|{
name|error
operator|=
name|FT_Stream_Skip
argument_list|(
name|stream
argument_list|,
literal|4
operator|+
literal|4
argument_list|)
expr_stmt|;
comment|/* offset + length */
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
block|}
block|}
return|return
name|FT_Err_Unknown_File_Format
return|;
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|raccess_guess_linux_double_from_file_name
name|raccess_guess_linux_double_from_file_name
parameter_list|(
name|FT_Library
name|library
parameter_list|,
name|char
modifier|*
name|file_name
parameter_list|,
name|FT_Long
modifier|*
name|result_offset
parameter_list|)
block|{
name|FT_Open_Args
name|args2
decl_stmt|;
name|FT_Stream
name|stream2
decl_stmt|;
name|char
modifier|*
name|nouse
init|=
name|NULL
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|args2
operator|.
name|flags
operator|=
name|FT_OPEN_PATHNAME
expr_stmt|;
name|args2
operator|.
name|pathname
operator|=
name|file_name
expr_stmt|;
name|error
operator|=
name|FT_Stream_New
argument_list|(
name|library
argument_list|,
operator|&
name|args2
argument_list|,
operator|&
name|stream2
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|error
operator|=
name|raccess_guess_apple_double
argument_list|(
name|library
argument_list|,
name|stream2
argument_list|,
name|file_name
argument_list|,
operator|&
name|nouse
argument_list|,
name|result_offset
argument_list|)
expr_stmt|;
name|FT_Stream_Free
argument_list|(
name|stream2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_function
specifier|static
name|char
modifier|*
DECL|function|raccess_make_file_name
name|raccess_make_file_name
parameter_list|(
name|FT_Memory
name|memory
parameter_list|,
specifier|const
name|char
modifier|*
name|original_name
parameter_list|,
specifier|const
name|char
modifier|*
name|insertion
parameter_list|)
block|{
name|char
modifier|*
name|new_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|tmp
decl_stmt|;
specifier|const
name|char
modifier|*
name|slash
decl_stmt|;
name|size_t
name|new_length
decl_stmt|;
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
name|FT_UNUSED
argument_list|(
name|error
argument_list|)
expr_stmt|;
name|new_length
operator|=
name|ft_strlen
argument_list|(
name|original_name
argument_list|)
operator|+
name|ft_strlen
argument_list|(
name|insertion
argument_list|)
expr_stmt|;
if|if
condition|(
name|FT_ALLOC
argument_list|(
name|new_name
argument_list|,
name|new_length
operator|+
literal|1
argument_list|)
condition|)
return|return
name|NULL
return|;
name|tmp
operator|=
name|ft_strrchr
argument_list|(
name|original_name
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
condition|)
block|{
name|ft_strncpy
argument_list|(
name|new_name
argument_list|,
name|original_name
argument_list|,
name|tmp
operator|-
name|original_name
operator|+
literal|1
argument_list|)
expr_stmt|;
name|new_name
index|[
name|tmp
operator|-
name|original_name
operator|+
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|slash
operator|=
name|tmp
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|slash
operator|=
name|original_name
expr_stmt|;
name|new_name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|ft_strcat
argument_list|(
name|new_name
argument_list|,
name|insertion
argument_list|)
expr_stmt|;
name|ft_strcat
argument_list|(
name|new_name
argument_list|,
name|slash
argument_list|)
expr_stmt|;
return|return
name|new_name
return|;
block|}
end_function
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* !FT_CONFIG_OPTION_GUESSING_EMBEDDED_RFORK */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                  Dummy function; just sets errors                     */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_macro
name|FT_BASE_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|FT_Raccess_Guess
name|FT_Raccess_Guess
argument_list|(
argument|FT_Library  library
argument_list|,
argument|FT_Stream   stream
argument_list|,
argument|char       *base_name
argument_list|,
argument|char      **new_names
argument_list|,
argument|FT_Long    *offsets
argument_list|,
argument|FT_Error   *errors
argument_list|)
end_macro
begin_block
block|{
name|int
name|i
decl_stmt|;
name|FT_UNUSED
argument_list|(
name|library
argument_list|)
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|base_name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FT_RACCESS_N_RULES
condition|;
name|i
operator|++
control|)
block|{
name|new_names
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|offsets
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|errors
index|[
name|i
index|]
operator|=
name|FT_Err_Unimplemented_Feature
expr_stmt|;
block|}
block|}
end_block
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* !FT_CONFIG_OPTION_GUESSING_EMBEDDED_RFORK */
end_comment
begin_comment
comment|/* END */
end_comment
end_unit
