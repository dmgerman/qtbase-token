begin_unit
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  ftcalc.c                                                               */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*    Arithmetic computations (body).                                      */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2008 by             */
end_comment
begin_comment
comment|/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  This file is part of the FreeType project, and may only be used,       */
end_comment
begin_comment
comment|/*  modified, and distributed under the terms of the FreeType project      */
end_comment
begin_comment
comment|/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
end_comment
begin_comment
comment|/*  this file you indicate that you have read the license and              */
end_comment
begin_comment
comment|/*  understand and accept it fully.                                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* Support for 1-complement arithmetic has been totally dropped in this  */
end_comment
begin_comment
comment|/* release.  You can still write your own code if you need it.           */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* Implementing basic computation routines.                              */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* FT_MulDiv(), FT_MulFix(), FT_DivFix(), FT_RoundFix(), FT_CeilFix(),   */
end_comment
begin_comment
comment|/* and FT_FloorFix() are declared in freetype.h.                         */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<ft2build.h>
end_include
begin_include
include|#
directive|include
include|FT_GLYPH_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_CALC_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_DEBUG_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_OBJECTS_H
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|FT_MULFIX_INLINED
end_ifdef
begin_undef
DECL|macro|FT_MulFix
undef|#
directive|undef
name|FT_MulFix
end_undef
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* we need to define a 64-bits data type here */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|FT_LONG64
end_ifdef
begin_typedef
DECL|typedef|FT_Int64
typedef|typedef
name|FT_INT64
name|FT_Int64
typedef|;
end_typedef
begin_else
else|#
directive|else
end_else
begin_typedef
DECL|struct|FT_Int64_
typedef|typedef
struct|struct
name|FT_Int64_
block|{
DECL|member|lo
name|FT_UInt32
name|lo
decl_stmt|;
DECL|member|hi
name|FT_UInt32
name|hi
decl_stmt|;
block|}
DECL|typedef|FT_Int64
name|FT_Int64
typedef|;
end_typedef
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* FT_LONG64 */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
end_comment
begin_comment
comment|/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
end_comment
begin_comment
comment|/* messages during execution.                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_undef
DECL|macro|FT_COMPONENT
undef|#
directive|undef
name|FT_COMPONENT
end_undef
begin_define
DECL|macro|FT_COMPONENT
define|#
directive|define
name|FT_COMPONENT
value|trace_calc
end_define
begin_comment
comment|/* The following three functions are available regardless of whether */
end_comment
begin_comment
comment|/* FT_LONG64 is defined.                                             */
end_comment
begin_comment
comment|/* documentation is in freetype.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Fixed
argument_list|)
end_macro
begin_macro
name|FT_RoundFix
argument_list|(
argument|FT_Fixed  a
argument_list|)
end_macro
begin_block
block|{
return|return
operator|(
name|a
operator|>=
literal|0
operator|)
condition|?
operator|(
name|a
operator|+
literal|0x8000L
operator|)
operator|&
operator|~
literal|0xFFFFL
else|:
operator|-
operator|(
operator|(
operator|-
name|a
operator|+
literal|0x8000L
operator|)
operator|&
operator|~
literal|0xFFFFL
operator|)
return|;
block|}
end_block
begin_comment
comment|/* documentation is in freetype.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Fixed
argument_list|)
end_macro
begin_macro
name|FT_CeilFix
argument_list|(
argument|FT_Fixed  a
argument_list|)
end_macro
begin_block
block|{
return|return
operator|(
name|a
operator|>=
literal|0
operator|)
condition|?
operator|(
name|a
operator|+
literal|0xFFFFL
operator|)
operator|&
operator|~
literal|0xFFFFL
else|:
operator|-
operator|(
operator|(
operator|-
name|a
operator|+
literal|0xFFFFL
operator|)
operator|&
operator|~
literal|0xFFFFL
operator|)
return|;
block|}
end_block
begin_comment
comment|/* documentation is in freetype.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Fixed
argument_list|)
end_macro
begin_macro
name|FT_FloorFix
argument_list|(
argument|FT_Fixed  a
argument_list|)
end_macro
begin_block
block|{
return|return
operator|(
name|a
operator|>=
literal|0
operator|)
condition|?
name|a
operator|&
operator|~
literal|0xFFFFL
else|:
operator|-
operator|(
operator|(
operator|-
name|a
operator|)
operator|&
operator|~
literal|0xFFFFL
operator|)
return|;
block|}
end_block
begin_ifdef
ifdef|#
directive|ifdef
name|FT_CONFIG_OPTION_OLD_INTERNALS
end_ifdef
begin_comment
comment|/* documentation is in ftcalc.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Int32
argument_list|)
end_macro
begin_macro
name|FT_Sqrt32
argument_list|(
argument|FT_Int32  x
argument_list|)
end_macro
begin_block
block|{
name|FT_UInt32
name|val
decl_stmt|,
name|root
decl_stmt|,
name|newroot
decl_stmt|,
name|mask
decl_stmt|;
name|root
operator|=
literal|0
expr_stmt|;
name|mask
operator|=
operator|(
name|FT_UInt32
operator|)
literal|0x40000000UL
expr_stmt|;
name|val
operator|=
operator|(
name|FT_UInt32
operator|)
name|x
expr_stmt|;
do|do
block|{
name|newroot
operator|=
name|root
operator|+
name|mask
expr_stmt|;
if|if
condition|(
name|newroot
operator|<=
name|val
condition|)
block|{
name|val
operator|-=
name|newroot
expr_stmt|;
name|root
operator|=
name|newroot
operator|+
name|mask
expr_stmt|;
block|}
name|root
operator|>>=
literal|1
expr_stmt|;
name|mask
operator|>>=
literal|2
expr_stmt|;
block|}
do|while
condition|(
name|mask
operator|!=
literal|0
condition|)
do|;
return|return
name|root
return|;
block|}
end_block
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* FT_CONFIG_OPTION_OLD_INTERNALS */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|FT_LONG64
end_ifdef
begin_comment
comment|/* documentation is in freetype.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Long
argument_list|)
end_macro
begin_macro
name|FT_MulDiv
argument_list|(
argument|FT_Long  a
argument_list|,
argument|FT_Long  b
argument_list|,
argument|FT_Long  c
argument_list|)
end_macro
begin_block
block|{
name|FT_Int
name|s
decl_stmt|;
name|FT_Long
name|d
decl_stmt|;
name|s
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|a
operator|<
literal|0
condition|)
block|{
name|a
operator|=
operator|-
name|a
expr_stmt|;
name|s
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|b
operator|<
literal|0
condition|)
block|{
name|b
operator|=
operator|-
name|b
expr_stmt|;
name|s
operator|=
operator|-
name|s
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|<
literal|0
condition|)
block|{
name|c
operator|=
operator|-
name|c
expr_stmt|;
name|s
operator|=
operator|-
name|s
expr_stmt|;
block|}
name|d
operator|=
call|(
name|FT_Long
call|)
argument_list|(
name|c
operator|>
literal|0
condition|?
operator|(
operator|(
name|FT_Int64
operator|)
name|a
operator|*
name|b
operator|+
operator|(
name|c
operator|>>
literal|1
operator|)
operator|)
operator|/
name|c
else|:
literal|0x7FFFFFFFL
argument_list|)
expr_stmt|;
return|return
operator|(
name|s
operator|>
literal|0
operator|)
condition|?
name|d
else|:
operator|-
name|d
return|;
block|}
end_block
begin_ifdef
ifdef|#
directive|ifdef
name|TT_USE_BYTECODE_INTERPRETER
end_ifdef
begin_comment
comment|/* documentation is in ftcalc.h */
end_comment
begin_macro
DECL|function|FT_BASE_DEF
name|FT_BASE_DEF
argument_list|(
argument|FT_Long
argument_list|)
end_macro
begin_macro
name|FT_MulDiv_No_Round
argument_list|(
argument|FT_Long  a
argument_list|,
argument|FT_Long  b
argument_list|,
argument|FT_Long  c
argument_list|)
end_macro
begin_block
block|{
name|FT_Int
name|s
decl_stmt|;
name|FT_Long
name|d
decl_stmt|;
name|s
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|a
operator|<
literal|0
condition|)
block|{
name|a
operator|=
operator|-
name|a
expr_stmt|;
name|s
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|b
operator|<
literal|0
condition|)
block|{
name|b
operator|=
operator|-
name|b
expr_stmt|;
name|s
operator|=
operator|-
name|s
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|<
literal|0
condition|)
block|{
name|c
operator|=
operator|-
name|c
expr_stmt|;
name|s
operator|=
operator|-
name|s
expr_stmt|;
block|}
name|d
operator|=
call|(
name|FT_Long
call|)
argument_list|(
name|c
operator|>
literal|0
condition|?
operator|(
name|FT_Int64
operator|)
name|a
operator|*
name|b
operator|/
name|c
else|:
literal|0x7FFFFFFFL
argument_list|)
expr_stmt|;
return|return
operator|(
name|s
operator|>
literal|0
operator|)
condition|?
name|d
else|:
operator|-
name|d
return|;
block|}
end_block
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* TT_USE_BYTECODE_INTERPRETER */
end_comment
begin_comment
comment|/* documentation is in freetype.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Long
argument_list|)
end_macro
begin_macro
name|FT_MulFix
argument_list|(
argument|FT_Long  a
argument_list|,
argument|FT_Long  b
argument_list|)
end_macro
begin_block
block|{
ifdef|#
directive|ifdef
name|FT_MULFIX_ASSEMBLER
return|return
name|FT_MULFIX_ASSEMBLER
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
else|#
directive|else
name|FT_Int
name|s
init|=
literal|1
decl_stmt|;
name|FT_Long
name|c
decl_stmt|;
if|if
condition|(
name|a
operator|<
literal|0
condition|)
block|{
name|a
operator|=
operator|-
name|a
expr_stmt|;
name|s
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|b
operator|<
literal|0
condition|)
block|{
name|b
operator|=
operator|-
name|b
expr_stmt|;
name|s
operator|=
operator|-
name|s
expr_stmt|;
block|}
name|c
operator|=
call|(
name|FT_Long
call|)
argument_list|(
operator|(
operator|(
name|FT_Int64
operator|)
name|a
operator|*
name|b
operator|+
literal|0x8000L
operator|)
operator|>>
literal|16
argument_list|)
expr_stmt|;
return|return
operator|(
name|s
operator|>
literal|0
operator|)
condition|?
name|c
else|:
operator|-
name|c
return|;
endif|#
directive|endif
comment|/* FT_MULFIX_ASSEMBLER */
block|}
end_block
begin_comment
comment|/* documentation is in freetype.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Long
argument_list|)
end_macro
begin_macro
name|FT_DivFix
argument_list|(
argument|FT_Long  a
argument_list|,
argument|FT_Long  b
argument_list|)
end_macro
begin_block
block|{
name|FT_Int32
name|s
decl_stmt|;
name|FT_UInt32
name|q
decl_stmt|;
name|s
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|a
operator|<
literal|0
condition|)
block|{
name|a
operator|=
operator|-
name|a
expr_stmt|;
name|s
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|b
operator|<
literal|0
condition|)
block|{
name|b
operator|=
operator|-
name|b
expr_stmt|;
name|s
operator|=
operator|-
name|s
expr_stmt|;
block|}
if|if
condition|(
name|b
operator|==
literal|0
condition|)
comment|/* check for division by 0 */
name|q
operator|=
literal|0x7FFFFFFFL
expr_stmt|;
else|else
comment|/* compute result directly */
name|q
operator|=
call|(
name|FT_UInt32
call|)
argument_list|(
operator|(
operator|(
operator|(
name|FT_Int64
operator|)
name|a
operator|<<
literal|16
operator|)
operator|+
operator|(
name|b
operator|>>
literal|1
operator|)
operator|)
operator|/
name|b
argument_list|)
expr_stmt|;
return|return
operator|(
name|s
operator|<
literal|0
condition|?
operator|-
operator|(
name|FT_Long
operator|)
name|q
else|:
operator|(
name|FT_Long
operator|)
name|q
operator|)
return|;
block|}
end_block
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* !FT_LONG64 */
end_comment
begin_function
specifier|static
name|void
DECL|function|ft_multo64
name|ft_multo64
parameter_list|(
name|FT_UInt32
name|x
parameter_list|,
name|FT_UInt32
name|y
parameter_list|,
name|FT_Int64
modifier|*
name|z
parameter_list|)
block|{
name|FT_UInt32
name|lo1
decl_stmt|,
name|hi1
decl_stmt|,
name|lo2
decl_stmt|,
name|hi2
decl_stmt|,
name|lo
decl_stmt|,
name|hi
decl_stmt|,
name|i1
decl_stmt|,
name|i2
decl_stmt|;
name|lo1
operator|=
name|x
operator|&
literal|0x0000FFFFU
expr_stmt|;
name|hi1
operator|=
name|x
operator|>>
literal|16
expr_stmt|;
name|lo2
operator|=
name|y
operator|&
literal|0x0000FFFFU
expr_stmt|;
name|hi2
operator|=
name|y
operator|>>
literal|16
expr_stmt|;
name|lo
operator|=
name|lo1
operator|*
name|lo2
expr_stmt|;
name|i1
operator|=
name|lo1
operator|*
name|hi2
expr_stmt|;
name|i2
operator|=
name|lo2
operator|*
name|hi1
expr_stmt|;
name|hi
operator|=
name|hi1
operator|*
name|hi2
expr_stmt|;
comment|/* Check carry overflow of i1 + i2 */
name|i1
operator|+=
name|i2
expr_stmt|;
name|hi
operator|+=
call|(
name|FT_UInt32
call|)
argument_list|(
name|i1
operator|<
name|i2
argument_list|)
operator|<<
literal|16
expr_stmt|;
name|hi
operator|+=
name|i1
operator|>>
literal|16
expr_stmt|;
name|i1
operator|=
name|i1
operator|<<
literal|16
expr_stmt|;
comment|/* Check carry overflow of i1 + lo */
name|lo
operator|+=
name|i1
expr_stmt|;
name|hi
operator|+=
operator|(
name|lo
operator|<
name|i1
operator|)
expr_stmt|;
name|z
operator|->
name|lo
operator|=
name|lo
expr_stmt|;
name|z
operator|->
name|hi
operator|=
name|hi
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|FT_UInt32
DECL|function|ft_div64by32
name|ft_div64by32
parameter_list|(
name|FT_UInt32
name|hi
parameter_list|,
name|FT_UInt32
name|lo
parameter_list|,
name|FT_UInt32
name|y
parameter_list|)
block|{
name|FT_UInt32
name|r
decl_stmt|,
name|q
decl_stmt|;
name|FT_Int
name|i
decl_stmt|;
name|q
operator|=
literal|0
expr_stmt|;
name|r
operator|=
name|hi
expr_stmt|;
if|if
condition|(
name|r
operator|>=
name|y
condition|)
return|return
operator|(
name|FT_UInt32
operator|)
literal|0x7FFFFFFFL
return|;
name|i
operator|=
literal|32
expr_stmt|;
do|do
block|{
name|r
operator|<<=
literal|1
expr_stmt|;
name|q
operator|<<=
literal|1
expr_stmt|;
name|r
operator||=
name|lo
operator|>>
literal|31
expr_stmt|;
if|if
condition|(
name|r
operator|>=
operator|(
name|FT_UInt32
operator|)
name|y
condition|)
block|{
name|r
operator|-=
name|y
expr_stmt|;
name|q
operator||=
literal|1
expr_stmt|;
block|}
name|lo
operator|<<=
literal|1
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|i
condition|)
do|;
return|return
name|q
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|FT_Add64
name|FT_Add64
parameter_list|(
name|FT_Int64
modifier|*
name|x
parameter_list|,
name|FT_Int64
modifier|*
name|y
parameter_list|,
name|FT_Int64
modifier|*
name|z
parameter_list|)
block|{
specifier|register
name|FT_UInt32
name|lo
decl_stmt|,
name|hi
decl_stmt|;
name|lo
operator|=
name|x
operator|->
name|lo
operator|+
name|y
operator|->
name|lo
expr_stmt|;
name|hi
operator|=
name|x
operator|->
name|hi
operator|+
name|y
operator|->
name|hi
operator|+
operator|(
name|lo
operator|<
name|x
operator|->
name|lo
operator|)
expr_stmt|;
name|z
operator|->
name|lo
operator|=
name|lo
expr_stmt|;
name|z
operator|->
name|hi
operator|=
name|hi
expr_stmt|;
block|}
end_function
begin_comment
comment|/* documentation is in freetype.h */
end_comment
begin_comment
comment|/* The FT_MulDiv function has been optimized thanks to ideas from      */
end_comment
begin_comment
comment|/* Graham Asher.  The trick is to optimize computation when everything */
end_comment
begin_comment
comment|/* fits within 32-bits (a rather common case).                         */
end_comment
begin_comment
comment|/*                                                                     */
end_comment
begin_comment
comment|/*  we compute 'a*b+c/2', then divide it by 'c'. (positive values)     */
end_comment
begin_comment
comment|/*                                                                     */
end_comment
begin_comment
comment|/*  46340 is FLOOR(SQRT(2^31-1)).                                      */
end_comment
begin_comment
comment|/*                                                                     */
end_comment
begin_comment
comment|/*  if ( a<= 46340&& b<= 46340 ) then ( a*b<= 0x7FFEA810 )         */
end_comment
begin_comment
comment|/*                                                                     */
end_comment
begin_comment
comment|/*  0x7FFFFFFF - 0x7FFEA810 = 0x157F0                                  */
end_comment
begin_comment
comment|/*                                                                     */
end_comment
begin_comment
comment|/*  if ( c< 0x157F0*2 ) then ( a*b+c/2<= 0x7FFFFFFF )                */
end_comment
begin_comment
comment|/*                                                                     */
end_comment
begin_comment
comment|/*  and 2*0x157F0 = 176096                                             */
end_comment
begin_comment
comment|/*                                                                     */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Long
argument_list|)
end_macro
begin_macro
name|FT_MulDiv
argument_list|(
argument|FT_Long  a
argument_list|,
argument|FT_Long  b
argument_list|,
argument|FT_Long  c
argument_list|)
end_macro
begin_block
block|{
name|long
name|s
decl_stmt|;
comment|/* XXX: this function does not allow 64-bit arguments */
if|if
condition|(
name|a
operator|==
literal|0
operator|||
name|b
operator|==
name|c
condition|)
return|return
name|a
return|;
name|s
operator|=
name|a
expr_stmt|;
name|a
operator|=
name|FT_ABS
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|s
operator|^=
name|b
expr_stmt|;
name|b
operator|=
name|FT_ABS
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|s
operator|^=
name|c
expr_stmt|;
name|c
operator|=
name|FT_ABS
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|<=
literal|46340L
operator|&&
name|b
operator|<=
literal|46340L
operator|&&
name|c
operator|<=
literal|176095L
operator|&&
name|c
operator|>
literal|0
condition|)
name|a
operator|=
operator|(
name|a
operator|*
name|b
operator|+
operator|(
name|c
operator|>>
literal|1
operator|)
operator|)
operator|/
name|c
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|>
literal|0
condition|)
block|{
name|FT_Int64
name|temp
decl_stmt|,
name|temp2
decl_stmt|;
name|ft_multo64
argument_list|(
operator|(
name|FT_Int32
operator|)
name|a
argument_list|,
operator|(
name|FT_Int32
operator|)
name|b
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
name|temp2
operator|.
name|hi
operator|=
literal|0
expr_stmt|;
name|temp2
operator|.
name|lo
operator|=
call|(
name|FT_UInt32
call|)
argument_list|(
name|c
operator|>>
literal|1
argument_list|)
expr_stmt|;
name|FT_Add64
argument_list|(
operator|&
name|temp
argument_list|,
operator|&
name|temp2
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
name|a
operator|=
name|ft_div64by32
argument_list|(
name|temp
operator|.
name|hi
argument_list|,
name|temp
operator|.
name|lo
argument_list|,
operator|(
name|FT_Int32
operator|)
name|c
argument_list|)
expr_stmt|;
block|}
else|else
name|a
operator|=
literal|0x7FFFFFFFL
expr_stmt|;
return|return
operator|(
name|s
operator|<
literal|0
condition|?
operator|-
name|a
else|:
name|a
operator|)
return|;
block|}
end_block
begin_ifdef
ifdef|#
directive|ifdef
name|TT_USE_BYTECODE_INTERPRETER
end_ifdef
begin_macro
DECL|function|FT_BASE_DEF
name|FT_BASE_DEF
argument_list|(
argument|FT_Long
argument_list|)
end_macro
begin_macro
name|FT_MulDiv_No_Round
argument_list|(
argument|FT_Long  a
argument_list|,
argument|FT_Long  b
argument_list|,
argument|FT_Long  c
argument_list|)
end_macro
begin_block
block|{
name|long
name|s
decl_stmt|;
if|if
condition|(
name|a
operator|==
literal|0
operator|||
name|b
operator|==
name|c
condition|)
return|return
name|a
return|;
name|s
operator|=
name|a
expr_stmt|;
name|a
operator|=
name|FT_ABS
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|s
operator|^=
name|b
expr_stmt|;
name|b
operator|=
name|FT_ABS
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|s
operator|^=
name|c
expr_stmt|;
name|c
operator|=
name|FT_ABS
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|<=
literal|46340L
operator|&&
name|b
operator|<=
literal|46340L
operator|&&
name|c
operator|>
literal|0
condition|)
name|a
operator|=
name|a
operator|*
name|b
operator|/
name|c
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|>
literal|0
condition|)
block|{
name|FT_Int64
name|temp
decl_stmt|;
name|ft_multo64
argument_list|(
operator|(
name|FT_Int32
operator|)
name|a
argument_list|,
operator|(
name|FT_Int32
operator|)
name|b
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
name|a
operator|=
name|ft_div64by32
argument_list|(
name|temp
operator|.
name|hi
argument_list|,
name|temp
operator|.
name|lo
argument_list|,
operator|(
name|FT_Int32
operator|)
name|c
argument_list|)
expr_stmt|;
block|}
else|else
name|a
operator|=
literal|0x7FFFFFFFL
expr_stmt|;
return|return
operator|(
name|s
operator|<
literal|0
condition|?
operator|-
name|a
else|:
name|a
operator|)
return|;
block|}
end_block
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* TT_USE_BYTECODE_INTERPRETER */
end_comment
begin_comment
comment|/* documentation is in freetype.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Long
argument_list|)
end_macro
begin_macro
name|FT_MulFix
argument_list|(
argument|FT_Long  a
argument_list|,
argument|FT_Long  b
argument_list|)
end_macro
begin_block
block|{
ifdef|#
directive|ifdef
name|FT_MULFIX_ASSEMBLER
return|return
name|FT_MULFIX_ASSEMBLER
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
elif|#
directive|elif
literal|0
comment|/*      *  This code is nonportable.  See comment below.      *      *  However, on a platform where right-shift of a signed quantity fills      *  the leftmost bits by copying the sign bit, it might be faster.      */
name|FT_Long
name|sa
decl_stmt|,
name|sb
decl_stmt|;
name|FT_ULong
name|ua
decl_stmt|,
name|ub
decl_stmt|;
if|if
condition|(
name|a
operator|==
literal|0
operator|||
name|b
operator|==
literal|0x10000L
condition|)
return|return
name|a
return|;
comment|/*      *  This is a clever way of converting a signed number `a' into its      *  absolute value (stored back into `a') and its sign.  The sign is      *  stored in `sa'; 0 means `a' was positive or zero, and -1 means `a'      *  was negative.  (Similarly for `b' and `sb').      *      *  Unfortunately, it doesn't work (at least not portably).      *      *  It makes the assumption that right-shift on a negative signed value      *  fills the leftmost bits by copying the sign bit.  This is wrong.       *  According to K&R 2nd ed, section `A7.8 Shift Operators' on page 206,      *  the result of right-shift of a negative signed value is      *  implementation-defined.  At least one implementation fills the      *  leftmost bits with 0s (i.e., it is exactly the same as an unsigned      *  right shift).  This means that when `a' is negative, `sa' ends up      *  with the value 1 rather than -1.  After that, everything else goes      *  wrong.      */
name|sa
operator|=
operator|(
name|a
operator|>>
operator|(
sizeof|sizeof
argument_list|(
name|a
argument_list|)
operator|*
literal|8
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|a
operator|=
operator|(
name|a
operator|^
name|sa
operator|)
operator|-
name|sa
expr_stmt|;
name|sb
operator|=
operator|(
name|b
operator|>>
operator|(
sizeof|sizeof
argument_list|(
name|b
argument_list|)
operator|*
literal|8
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|b
operator|=
operator|(
name|b
operator|^
name|sb
operator|)
operator|-
name|sb
expr_stmt|;
name|ua
operator|=
operator|(
name|FT_ULong
operator|)
name|a
expr_stmt|;
name|ub
operator|=
operator|(
name|FT_ULong
operator|)
name|b
expr_stmt|;
if|if
condition|(
name|ua
operator|<=
literal|2048
operator|&&
name|ub
operator|<=
literal|1048576L
condition|)
name|ua
operator|=
operator|(
name|ua
operator|*
name|ub
operator|+
literal|0x8000U
operator|)
operator|>>
literal|16
expr_stmt|;
else|else
block|{
name|FT_ULong
name|al
init|=
name|ua
operator|&
literal|0xFFFFU
decl_stmt|;
name|ua
operator|=
operator|(
name|ua
operator|>>
literal|16
operator|)
operator|*
name|ub
operator|+
name|al
operator|*
operator|(
name|ub
operator|>>
literal|16
operator|)
operator|+
operator|(
operator|(
name|al
operator|*
operator|(
name|ub
operator|&
literal|0xFFFFU
operator|)
operator|+
literal|0x8000U
operator|)
operator|>>
literal|16
operator|)
expr_stmt|;
block|}
name|sa
operator|^=
name|sb
operator|,
name|ua
operator|=
call|(
name|FT_ULong
call|)
argument_list|(
operator|(
name|ua
operator|^
name|sa
operator|)
operator|-
name|sa
argument_list|)
expr_stmt|;
return|return
operator|(
name|FT_Long
operator|)
name|ua
return|;
else|#
directive|else
comment|/* 0 */
name|FT_Long
name|s
decl_stmt|;
name|FT_ULong
name|ua
decl_stmt|,
name|ub
decl_stmt|;
if|if
condition|(
name|a
operator|==
literal|0
operator|||
name|b
operator|==
literal|0x10000L
condition|)
return|return
name|a
return|;
name|s
operator|=
name|a
expr_stmt|;
name|a
operator|=
name|FT_ABS
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|s
operator|^=
name|b
expr_stmt|;
name|b
operator|=
name|FT_ABS
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|ua
operator|=
operator|(
name|FT_ULong
operator|)
name|a
expr_stmt|;
name|ub
operator|=
operator|(
name|FT_ULong
operator|)
name|b
expr_stmt|;
if|if
condition|(
name|ua
operator|<=
literal|2048
operator|&&
name|ub
operator|<=
literal|1048576L
condition|)
name|ua
operator|=
operator|(
name|ua
operator|*
name|ub
operator|+
literal|0x8000UL
operator|)
operator|>>
literal|16
expr_stmt|;
else|else
block|{
name|FT_ULong
name|al
init|=
name|ua
operator|&
literal|0xFFFFUL
decl_stmt|;
name|ua
operator|=
operator|(
name|ua
operator|>>
literal|16
operator|)
operator|*
name|ub
operator|+
name|al
operator|*
operator|(
name|ub
operator|>>
literal|16
operator|)
operator|+
operator|(
operator|(
name|al
operator|*
operator|(
name|ub
operator|&
literal|0xFFFFUL
operator|)
operator|+
literal|0x8000UL
operator|)
operator|>>
literal|16
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|s
operator|<
literal|0
condition|?
operator|-
operator|(
name|FT_Long
operator|)
name|ua
else|:
operator|(
name|FT_Long
operator|)
name|ua
operator|)
return|;
endif|#
directive|endif
comment|/* 0 */
block|}
end_block
begin_comment
comment|/* documentation is in freetype.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Long
argument_list|)
end_macro
begin_macro
name|FT_DivFix
argument_list|(
argument|FT_Long  a
argument_list|,
argument|FT_Long  b
argument_list|)
end_macro
begin_block
block|{
name|FT_Int32
name|s
decl_stmt|;
name|FT_UInt32
name|q
decl_stmt|;
comment|/* XXX: this function does not allow 64-bit arguments */
name|s
operator|=
operator|(
name|FT_Int32
operator|)
name|a
expr_stmt|;
name|a
operator|=
name|FT_ABS
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|s
operator|^=
operator|(
name|FT_Int32
operator|)
name|b
expr_stmt|;
name|b
operator|=
name|FT_ABS
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|==
literal|0
condition|)
block|{
comment|/* check for division by 0 */
name|q
operator|=
operator|(
name|FT_UInt32
operator|)
literal|0x7FFFFFFFL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|a
operator|>>
literal|16
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* compute result directly */
name|q
operator|=
call|(
name|FT_UInt32
call|)
argument_list|(
operator|(
name|a
operator|<<
literal|16
operator|)
operator|+
operator|(
name|b
operator|>>
literal|1
operator|)
argument_list|)
operator|/
operator|(
name|FT_UInt32
operator|)
name|b
expr_stmt|;
block|}
else|else
block|{
comment|/* we need more bits; we have to do it by hand */
name|FT_Int64
name|temp
decl_stmt|,
name|temp2
decl_stmt|;
name|temp
operator|.
name|hi
operator|=
call|(
name|FT_Int32
call|)
argument_list|(
name|a
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|temp
operator|.
name|lo
operator|=
call|(
name|FT_UInt32
call|)
argument_list|(
name|a
operator|<<
literal|16
argument_list|)
expr_stmt|;
name|temp2
operator|.
name|hi
operator|=
literal|0
expr_stmt|;
name|temp2
operator|.
name|lo
operator|=
call|(
name|FT_UInt32
call|)
argument_list|(
name|b
operator|>>
literal|1
argument_list|)
expr_stmt|;
name|FT_Add64
argument_list|(
operator|&
name|temp
argument_list|,
operator|&
name|temp2
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
name|q
operator|=
name|ft_div64by32
argument_list|(
name|temp
operator|.
name|hi
argument_list|,
name|temp
operator|.
name|lo
argument_list|,
operator|(
name|FT_Int32
operator|)
name|b
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|s
operator|<
literal|0
condition|?
operator|-
operator|(
name|FT_Int32
operator|)
name|q
else|:
operator|(
name|FT_Int32
operator|)
name|q
operator|)
return|;
block|}
end_block
begin_if
if|#
directive|if
literal|0
end_if
begin_comment
comment|/* documentation is in ftcalc.h */
end_comment
begin_comment
unit|FT_EXPORT_DEF( void )   FT_MulTo64( FT_Int32   x,               FT_Int32   y,               FT_Int64  *z )   {     FT_Int32  s;       s  = x; x = FT_ABS( x );     s ^= y; y = FT_ABS( y );      ft_multo64( x, y, z );      if ( s< 0 )     {       z->lo = (FT_UInt32)-(FT_Int32)z->lo;       z->hi = ~z->hi + !( z->lo );     }   }
comment|/* apparently, the second version of this code is not compiled correctly */
end_comment
begin_comment
comment|/* on Mac machines with the MPW C compiler..  tsk, tsk, tsk...           */
end_comment
begin_if
if|#
directive|if
literal|1
end_if
begin_comment
unit|FT_EXPORT_DEF( FT_Int32 )   FT_Div64by32( FT_Int64*  x,                 FT_Int32   y )   {     FT_Int32   s;     FT_UInt32  q, r, i, lo;       s  = x->hi;     if ( s< 0 )     {       x->lo = (FT_UInt32)-(FT_Int32)x->lo;       x->hi = ~x->hi + !x->lo;     }     s ^= y;  y = FT_ABS( y );
comment|/* Shortcut */
end_comment
begin_comment
unit|if ( x->hi == 0 )     {       if ( y> 0 )         q = x->lo / y;       else         q = 0x7FFFFFFFL;        return ( s< 0 ? -(FT_Int32)q : (FT_Int32)q );     }      r  = x->hi;     lo = x->lo;      if ( r>= (FT_UInt32)y )
comment|/* we know y is to be treated as unsigned here */
end_comment
begin_comment
unit|return ( s< 0 ? 0x80000001UL : 0x7FFFFFFFUL );
comment|/* Return Max/Min Int32 if division overflow. */
end_comment
begin_comment
comment|/* This includes division by zero!            */
end_comment
begin_else
unit|q = 0;     for ( i = 0; i< 32; i++ )     {       r<<= 1;       q<<= 1;       r  |= lo>> 31;        if ( r>= (FT_UInt32)y )       {         r -= y;         q |= 1;       }       lo<<= 1;     }      return ( s< 0 ? -(FT_Int32)q : (FT_Int32)q );   }
else|#
directive|else
end_else
begin_comment
comment|/* 0 */
end_comment
begin_comment
unit|FT_EXPORT_DEF( FT_Int32 )   FT_Div64by32( FT_Int64*  x,                 FT_Int32   y )   {     FT_Int32   s;     FT_UInt32  q;       s  = x->hi;     if ( s< 0 )     {       x->lo = (FT_UInt32)-(FT_Int32)x->lo;       x->hi = ~x->hi + !x->lo;     }     s ^= y;  y = FT_ABS( y );
comment|/* Shortcut */
end_comment
begin_endif
unit|if ( x->hi == 0 )     {       if ( y> 0 )         q = ( x->lo + ( y>> 1 ) ) / y;       else         q = 0x7FFFFFFFL;        return ( s< 0 ? -(FT_Int32)q : (FT_Int32)q );     }      q = ft_div64by32( x->hi, x->lo, y );      return ( s< 0 ? -(FT_Int32)q : (FT_Int32)q );   }
endif|#
directive|endif
end_endif
begin_comment
comment|/* 0 */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* 0 */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* FT_LONG64 */
end_comment
begin_comment
comment|/* documentation is in ftglyph.h */
end_comment
begin_macro
name|FT_EXPORT_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|FT_Matrix_Multiply
name|FT_Matrix_Multiply
argument_list|(
argument|const FT_Matrix*  a
argument_list|,
argument|FT_Matrix        *b
argument_list|)
end_macro
begin_block
block|{
name|FT_Fixed
name|xx
decl_stmt|,
name|xy
decl_stmt|,
name|yx
decl_stmt|,
name|yy
decl_stmt|;
if|if
condition|(
operator|!
name|a
operator|||
operator|!
name|b
condition|)
return|return;
name|xx
operator|=
name|FT_MulFix
argument_list|(
name|a
operator|->
name|xx
argument_list|,
name|b
operator|->
name|xx
argument_list|)
operator|+
name|FT_MulFix
argument_list|(
name|a
operator|->
name|xy
argument_list|,
name|b
operator|->
name|yx
argument_list|)
expr_stmt|;
name|xy
operator|=
name|FT_MulFix
argument_list|(
name|a
operator|->
name|xx
argument_list|,
name|b
operator|->
name|xy
argument_list|)
operator|+
name|FT_MulFix
argument_list|(
name|a
operator|->
name|xy
argument_list|,
name|b
operator|->
name|yy
argument_list|)
expr_stmt|;
name|yx
operator|=
name|FT_MulFix
argument_list|(
name|a
operator|->
name|yx
argument_list|,
name|b
operator|->
name|xx
argument_list|)
operator|+
name|FT_MulFix
argument_list|(
name|a
operator|->
name|yy
argument_list|,
name|b
operator|->
name|yx
argument_list|)
expr_stmt|;
name|yy
operator|=
name|FT_MulFix
argument_list|(
name|a
operator|->
name|yx
argument_list|,
name|b
operator|->
name|xy
argument_list|)
operator|+
name|FT_MulFix
argument_list|(
name|a
operator|->
name|yy
argument_list|,
name|b
operator|->
name|yy
argument_list|)
expr_stmt|;
name|b
operator|->
name|xx
operator|=
name|xx
expr_stmt|;
name|b
operator|->
name|xy
operator|=
name|xy
expr_stmt|;
name|b
operator|->
name|yx
operator|=
name|yx
expr_stmt|;
name|b
operator|->
name|yy
operator|=
name|yy
expr_stmt|;
block|}
end_block
begin_comment
comment|/* documentation is in ftglyph.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_Matrix_Invert
argument_list|(
argument|FT_Matrix*  matrix
argument_list|)
end_macro
begin_block
block|{
name|FT_Pos
name|delta
decl_stmt|,
name|xx
decl_stmt|,
name|yy
decl_stmt|;
if|if
condition|(
operator|!
name|matrix
condition|)
return|return
name|FT_Err_Invalid_Argument
return|;
comment|/* compute discriminant */
name|delta
operator|=
name|FT_MulFix
argument_list|(
name|matrix
operator|->
name|xx
argument_list|,
name|matrix
operator|->
name|yy
argument_list|)
operator|-
name|FT_MulFix
argument_list|(
name|matrix
operator|->
name|xy
argument_list|,
name|matrix
operator|->
name|yx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|delta
condition|)
return|return
name|FT_Err_Invalid_Argument
return|;
comment|/* matrix can't be inverted */
name|matrix
operator|->
name|xy
operator|=
operator|-
name|FT_DivFix
argument_list|(
name|matrix
operator|->
name|xy
argument_list|,
name|delta
argument_list|)
expr_stmt|;
name|matrix
operator|->
name|yx
operator|=
operator|-
name|FT_DivFix
argument_list|(
name|matrix
operator|->
name|yx
argument_list|,
name|delta
argument_list|)
expr_stmt|;
name|xx
operator|=
name|matrix
operator|->
name|xx
expr_stmt|;
name|yy
operator|=
name|matrix
operator|->
name|yy
expr_stmt|;
name|matrix
operator|->
name|xx
operator|=
name|FT_DivFix
argument_list|(
name|yy
argument_list|,
name|delta
argument_list|)
expr_stmt|;
name|matrix
operator|->
name|yy
operator|=
name|FT_DivFix
argument_list|(
name|xx
argument_list|,
name|delta
argument_list|)
expr_stmt|;
return|return
name|FT_Err_Ok
return|;
block|}
end_block
begin_comment
comment|/* documentation is in ftcalc.h */
end_comment
begin_macro
name|FT_BASE_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|FT_Matrix_Multiply_Scaled
name|FT_Matrix_Multiply_Scaled
argument_list|(
argument|const FT_Matrix*  a
argument_list|,
argument|FT_Matrix        *b
argument_list|,
argument|FT_Long           scaling
argument_list|)
end_macro
begin_block
block|{
name|FT_Fixed
name|xx
decl_stmt|,
name|xy
decl_stmt|,
name|yx
decl_stmt|,
name|yy
decl_stmt|;
name|FT_Long
name|val
init|=
literal|0x10000L
operator|*
name|scaling
decl_stmt|;
if|if
condition|(
operator|!
name|a
operator|||
operator|!
name|b
condition|)
return|return;
name|xx
operator|=
name|FT_MulDiv
argument_list|(
name|a
operator|->
name|xx
argument_list|,
name|b
operator|->
name|xx
argument_list|,
name|val
argument_list|)
operator|+
name|FT_MulDiv
argument_list|(
name|a
operator|->
name|xy
argument_list|,
name|b
operator|->
name|yx
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|xy
operator|=
name|FT_MulDiv
argument_list|(
name|a
operator|->
name|xx
argument_list|,
name|b
operator|->
name|xy
argument_list|,
name|val
argument_list|)
operator|+
name|FT_MulDiv
argument_list|(
name|a
operator|->
name|xy
argument_list|,
name|b
operator|->
name|yy
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|yx
operator|=
name|FT_MulDiv
argument_list|(
name|a
operator|->
name|yx
argument_list|,
name|b
operator|->
name|xx
argument_list|,
name|val
argument_list|)
operator|+
name|FT_MulDiv
argument_list|(
name|a
operator|->
name|yy
argument_list|,
name|b
operator|->
name|yx
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|yy
operator|=
name|FT_MulDiv
argument_list|(
name|a
operator|->
name|yx
argument_list|,
name|b
operator|->
name|xy
argument_list|,
name|val
argument_list|)
operator|+
name|FT_MulDiv
argument_list|(
name|a
operator|->
name|yy
argument_list|,
name|b
operator|->
name|yy
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|b
operator|->
name|xx
operator|=
name|xx
expr_stmt|;
name|b
operator|->
name|xy
operator|=
name|xy
expr_stmt|;
name|b
operator|->
name|yx
operator|=
name|yx
expr_stmt|;
name|b
operator|->
name|yy
operator|=
name|yy
expr_stmt|;
block|}
end_block
begin_comment
comment|/* documentation is in ftcalc.h */
end_comment
begin_macro
name|FT_BASE_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|FT_Vector_Transform_Scaled
name|FT_Vector_Transform_Scaled
argument_list|(
argument|FT_Vector*        vector
argument_list|,
argument|const FT_Matrix*  matrix
argument_list|,
argument|FT_Long           scaling
argument_list|)
end_macro
begin_block
block|{
name|FT_Pos
name|xz
decl_stmt|,
name|yz
decl_stmt|;
name|FT_Long
name|val
init|=
literal|0x10000L
operator|*
name|scaling
decl_stmt|;
if|if
condition|(
operator|!
name|vector
operator|||
operator|!
name|matrix
condition|)
return|return;
name|xz
operator|=
name|FT_MulDiv
argument_list|(
name|vector
operator|->
name|x
argument_list|,
name|matrix
operator|->
name|xx
argument_list|,
name|val
argument_list|)
operator|+
name|FT_MulDiv
argument_list|(
name|vector
operator|->
name|y
argument_list|,
name|matrix
operator|->
name|xy
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|yz
operator|=
name|FT_MulDiv
argument_list|(
name|vector
operator|->
name|x
argument_list|,
name|matrix
operator|->
name|yx
argument_list|,
name|val
argument_list|)
operator|+
name|FT_MulDiv
argument_list|(
name|vector
operator|->
name|y
argument_list|,
name|matrix
operator|->
name|yy
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|vector
operator|->
name|x
operator|=
name|xz
expr_stmt|;
name|vector
operator|->
name|y
operator|=
name|yz
expr_stmt|;
block|}
end_block
begin_comment
comment|/* documentation is in ftcalc.h */
end_comment
begin_macro
DECL|function|FT_BASE_DEF
name|FT_BASE_DEF
argument_list|(
argument|FT_Int32
argument_list|)
end_macro
begin_macro
name|FT_SqrtFixed
argument_list|(
argument|FT_Int32  x
argument_list|)
end_macro
begin_block
block|{
name|FT_UInt32
name|root
decl_stmt|,
name|rem_hi
decl_stmt|,
name|rem_lo
decl_stmt|,
name|test_div
decl_stmt|;
name|FT_Int
name|count
decl_stmt|;
name|root
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|x
operator|>
literal|0
condition|)
block|{
name|rem_hi
operator|=
literal|0
expr_stmt|;
name|rem_lo
operator|=
name|x
expr_stmt|;
name|count
operator|=
literal|24
expr_stmt|;
do|do
block|{
name|rem_hi
operator|=
operator|(
name|rem_hi
operator|<<
literal|2
operator|)
operator||
operator|(
name|rem_lo
operator|>>
literal|30
operator|)
expr_stmt|;
name|rem_lo
operator|<<=
literal|2
expr_stmt|;
name|root
operator|<<=
literal|1
expr_stmt|;
name|test_div
operator|=
operator|(
name|root
operator|<<
literal|1
operator|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|rem_hi
operator|>=
name|test_div
condition|)
block|{
name|rem_hi
operator|-=
name|test_div
expr_stmt|;
name|root
operator|+=
literal|1
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|--
name|count
condition|)
do|;
block|}
return|return
operator|(
name|FT_Int32
operator|)
name|root
return|;
block|}
end_block
begin_comment
comment|/* documentation is in ftcalc.h */
end_comment
begin_macro
DECL|function|FT_BASE_DEF
name|FT_BASE_DEF
argument_list|(
argument|FT_Int
argument_list|)
end_macro
begin_macro
name|ft_corner_orientation
argument_list|(
argument|FT_Pos  in_x
argument_list|,
argument|FT_Pos  in_y
argument_list|,
argument|FT_Pos  out_x
argument_list|,
argument|FT_Pos  out_y
argument_list|)
end_macro
begin_block
block|{
name|FT_Long
name|result
decl_stmt|;
comment|/* avoid overflow on 16-bit system */
comment|/* deal with the trivial cases quickly */
if|if
condition|(
name|in_y
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|in_x
operator|>=
literal|0
condition|)
name|result
operator|=
name|out_y
expr_stmt|;
else|else
name|result
operator|=
operator|-
name|out_y
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|in_x
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|in_y
operator|>=
literal|0
condition|)
name|result
operator|=
operator|-
name|out_x
expr_stmt|;
else|else
name|result
operator|=
name|out_x
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|out_y
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|out_x
operator|>=
literal|0
condition|)
name|result
operator|=
name|in_y
expr_stmt|;
else|else
name|result
operator|=
operator|-
name|in_y
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|out_x
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|out_y
operator|>=
literal|0
condition|)
name|result
operator|=
operator|-
name|in_x
expr_stmt|;
else|else
name|result
operator|=
name|in_x
expr_stmt|;
block|}
else|else
comment|/* general case */
block|{
ifdef|#
directive|ifdef
name|FT_LONG64
name|FT_Int64
name|delta
init|=
operator|(
name|FT_Int64
operator|)
name|in_x
operator|*
name|out_y
operator|-
operator|(
name|FT_Int64
operator|)
name|in_y
operator|*
name|out_x
decl_stmt|;
if|if
condition|(
name|delta
operator|==
literal|0
condition|)
name|result
operator|=
literal|0
expr_stmt|;
else|else
name|result
operator|=
literal|1
operator|-
literal|2
operator|*
operator|(
name|delta
operator|<
literal|0
operator|)
expr_stmt|;
else|#
directive|else
name|FT_Int64
name|z1
decl_stmt|,
name|z2
decl_stmt|;
comment|/* XXX: this function does not allow 64-bit arguments */
name|ft_multo64
argument_list|(
operator|(
name|FT_Int32
operator|)
name|in_x
argument_list|,
operator|(
name|FT_Int32
operator|)
name|out_y
argument_list|,
operator|&
name|z1
argument_list|)
expr_stmt|;
name|ft_multo64
argument_list|(
operator|(
name|FT_Int32
operator|)
name|in_y
argument_list|,
operator|(
name|FT_Int32
operator|)
name|out_x
argument_list|,
operator|&
name|z2
argument_list|)
expr_stmt|;
if|if
condition|(
name|z1
operator|.
name|hi
operator|>
name|z2
operator|.
name|hi
condition|)
name|result
operator|=
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|z1
operator|.
name|hi
operator|<
name|z2
operator|.
name|hi
condition|)
name|result
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|z1
operator|.
name|lo
operator|>
name|z2
operator|.
name|lo
condition|)
name|result
operator|=
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|z1
operator|.
name|lo
operator|<
name|z2
operator|.
name|lo
condition|)
name|result
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|result
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* XXX: only the sign of return value, +1/0/-1 must be used */
return|return
operator|(
name|FT_Int
operator|)
name|result
return|;
block|}
end_block
begin_comment
comment|/* documentation is in ftcalc.h */
end_comment
begin_macro
DECL|function|FT_BASE_DEF
name|FT_BASE_DEF
argument_list|(
argument|FT_Int
argument_list|)
end_macro
begin_macro
name|ft_corner_is_flat
argument_list|(
argument|FT_Pos  in_x
argument_list|,
argument|FT_Pos  in_y
argument_list|,
argument|FT_Pos  out_x
argument_list|,
argument|FT_Pos  out_y
argument_list|)
end_macro
begin_block
block|{
name|FT_Pos
name|ax
init|=
name|in_x
decl_stmt|;
name|FT_Pos
name|ay
init|=
name|in_y
decl_stmt|;
name|FT_Pos
name|d_in
decl_stmt|,
name|d_out
decl_stmt|,
name|d_corner
decl_stmt|;
if|if
condition|(
name|ax
operator|<
literal|0
condition|)
name|ax
operator|=
operator|-
name|ax
expr_stmt|;
if|if
condition|(
name|ay
operator|<
literal|0
condition|)
name|ay
operator|=
operator|-
name|ay
expr_stmt|;
name|d_in
operator|=
name|ax
operator|+
name|ay
expr_stmt|;
name|ax
operator|=
name|out_x
expr_stmt|;
if|if
condition|(
name|ax
operator|<
literal|0
condition|)
name|ax
operator|=
operator|-
name|ax
expr_stmt|;
name|ay
operator|=
name|out_y
expr_stmt|;
if|if
condition|(
name|ay
operator|<
literal|0
condition|)
name|ay
operator|=
operator|-
name|ay
expr_stmt|;
name|d_out
operator|=
name|ax
operator|+
name|ay
expr_stmt|;
name|ax
operator|=
name|out_x
operator|+
name|in_x
expr_stmt|;
if|if
condition|(
name|ax
operator|<
literal|0
condition|)
name|ax
operator|=
operator|-
name|ax
expr_stmt|;
name|ay
operator|=
name|out_y
operator|+
name|in_y
expr_stmt|;
if|if
condition|(
name|ay
operator|<
literal|0
condition|)
name|ay
operator|=
operator|-
name|ay
expr_stmt|;
name|d_corner
operator|=
name|ax
operator|+
name|ay
expr_stmt|;
return|return
operator|(
name|d_in
operator|+
name|d_out
operator|-
name|d_corner
operator|)
operator|<
operator|(
name|d_corner
operator|>>
literal|4
operator|)
return|;
block|}
end_block
begin_comment
comment|/* END */
end_comment
end_unit
