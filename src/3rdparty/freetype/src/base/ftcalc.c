begin_unit
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  ftcalc.c                                                               */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*    Arithmetic computations (body).                                      */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  Copyright 1996-2006, 2008, 2012-2014 by                                */
end_comment
begin_comment
comment|/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  This file is part of the FreeType project, and may only be used,       */
end_comment
begin_comment
comment|/*  modified, and distributed under the terms of the FreeType project      */
end_comment
begin_comment
comment|/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
end_comment
begin_comment
comment|/*  this file you indicate that you have read the license and              */
end_comment
begin_comment
comment|/*  understand and accept it fully.                                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* Support for 1-complement arithmetic has been totally dropped in this  */
end_comment
begin_comment
comment|/* release.  You can still write your own code if you need it.           */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* Implementing basic computation routines.                              */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* FT_MulDiv(), FT_MulFix(), FT_DivFix(), FT_RoundFix(), FT_CeilFix(),   */
end_comment
begin_comment
comment|/* and FT_FloorFix() are declared in freetype.h.                         */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<ft2build.h>
end_include
begin_include
include|#
directive|include
include|FT_GLYPH_H
end_include
begin_include
include|#
directive|include
include|FT_TRIGONOMETRY_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_CALC_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_DEBUG_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_OBJECTS_H
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|FT_MULFIX_ASSEMBLER
end_ifdef
begin_undef
DECL|macro|FT_MulFix
undef|#
directive|undef
name|FT_MulFix
end_undef
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* we need to emulate a 64-bit data type if a real one isn't available */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|FT_LONG64
end_ifndef
begin_typedef
DECL|struct|FT_Int64_
typedef|typedef
struct|struct
name|FT_Int64_
block|{
DECL|member|lo
name|FT_UInt32
name|lo
decl_stmt|;
DECL|member|hi
name|FT_UInt32
name|hi
decl_stmt|;
block|}
DECL|typedef|FT_Int64
name|FT_Int64
typedef|;
end_typedef
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* !FT_LONG64 */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
end_comment
begin_comment
comment|/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
end_comment
begin_comment
comment|/* messages during execution.                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_undef
DECL|macro|FT_COMPONENT
undef|#
directive|undef
name|FT_COMPONENT
end_undef
begin_define
DECL|macro|FT_COMPONENT
define|#
directive|define
name|FT_COMPONENT
value|trace_calc
end_define
begin_comment
comment|/* transfer sign leaving a positive number */
end_comment
begin_define
DECL|macro|FT_MOVE_SIGN
define|#
directive|define
name|FT_MOVE_SIGN
parameter_list|(
name|x
parameter_list|,
name|s
parameter_list|)
define|\
value|FT_BEGIN_STMNT             \     if ( x< 0 )             \     {                        \       x = -x;                \       s = -s;                \     }                        \   FT_END_STMNT
end_define
begin_comment
comment|/* The following three functions are available regardless of whether */
end_comment
begin_comment
comment|/* FT_LONG64 is defined.                                             */
end_comment
begin_comment
comment|/* documentation is in freetype.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Fixed
argument_list|)
end_macro
begin_macro
name|FT_RoundFix
argument_list|(
argument|FT_Fixed  a
argument_list|)
end_macro
begin_block
block|{
return|return
name|a
operator|>=
literal|0
condition|?
operator|(
name|a
operator|+
literal|0x8000L
operator|)
operator|&
operator|~
literal|0xFFFFL
else|:
operator|-
operator|(
operator|(
operator|-
name|a
operator|+
literal|0x8000L
operator|)
operator|&
operator|~
literal|0xFFFFL
operator|)
return|;
block|}
end_block
begin_comment
comment|/* documentation is in freetype.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Fixed
argument_list|)
end_macro
begin_macro
name|FT_CeilFix
argument_list|(
argument|FT_Fixed  a
argument_list|)
end_macro
begin_block
block|{
return|return
name|a
operator|>=
literal|0
condition|?
operator|(
name|a
operator|+
literal|0xFFFFL
operator|)
operator|&
operator|~
literal|0xFFFFL
else|:
operator|-
operator|(
operator|(
operator|-
name|a
operator|+
literal|0xFFFFL
operator|)
operator|&
operator|~
literal|0xFFFFL
operator|)
return|;
block|}
end_block
begin_comment
comment|/* documentation is in freetype.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Fixed
argument_list|)
end_macro
begin_macro
name|FT_FloorFix
argument_list|(
argument|FT_Fixed  a
argument_list|)
end_macro
begin_block
block|{
return|return
name|a
operator|>=
literal|0
condition|?
name|a
operator|&
operator|~
literal|0xFFFFL
else|:
operator|-
operator|(
operator|(
operator|-
name|a
operator|)
operator|&
operator|~
literal|0xFFFFL
operator|)
return|;
block|}
end_block
begin_ifndef
ifndef|#
directive|ifndef
name|FT_MSB
end_ifndef
begin_macro
DECL|function|FT_BASE_DEF
name|FT_BASE_DEF
argument_list|(
argument|FT_Int
argument_list|)
end_macro
begin_macro
name|FT_MSB
argument_list|(
argument|FT_UInt32 z
argument_list|)
end_macro
begin_block
block|{
name|FT_Int
name|shift
init|=
literal|0
decl_stmt|;
comment|/* determine msb bit index in `shift' */
if|if
condition|(
name|z
operator|&
literal|0xFFFF0000UL
condition|)
block|{
name|z
operator|>>=
literal|16
expr_stmt|;
name|shift
operator|+=
literal|16
expr_stmt|;
block|}
if|if
condition|(
name|z
operator|&
literal|0x0000FF00UL
condition|)
block|{
name|z
operator|>>=
literal|8
expr_stmt|;
name|shift
operator|+=
literal|8
expr_stmt|;
block|}
if|if
condition|(
name|z
operator|&
literal|0x000000F0UL
condition|)
block|{
name|z
operator|>>=
literal|4
expr_stmt|;
name|shift
operator|+=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|z
operator|&
literal|0x0000000CUL
condition|)
block|{
name|z
operator|>>=
literal|2
expr_stmt|;
name|shift
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|z
operator|&
literal|0x00000002UL
condition|)
block|{
comment|/* z>>= 1; */
name|shift
operator|+=
literal|1
expr_stmt|;
block|}
return|return
name|shift
return|;
block|}
end_block
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* !FT_MSB */
end_comment
begin_comment
comment|/* documentation is in ftcalc.h */
end_comment
begin_macro
DECL|function|FT_BASE_DEF
name|FT_BASE_DEF
argument_list|(
argument|FT_Fixed
argument_list|)
end_macro
begin_macro
name|FT_Hypot
argument_list|(
argument|FT_Fixed  x
argument_list|,
argument|FT_Fixed  y
argument_list|)
end_macro
begin_block
block|{
name|FT_Vector
name|v
decl_stmt|;
name|v
operator|.
name|x
operator|=
name|x
expr_stmt|;
name|v
operator|.
name|y
operator|=
name|y
expr_stmt|;
return|return
name|FT_Vector_Length
argument_list|(
operator|&
name|v
argument_list|)
return|;
block|}
end_block
begin_ifdef
ifdef|#
directive|ifdef
name|FT_LONG64
end_ifdef
begin_comment
comment|/* documentation is in freetype.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Long
argument_list|)
end_macro
begin_macro
name|FT_MulDiv
argument_list|(
argument|FT_Long  a
argument_list|,
argument|FT_Long  b
argument_list|,
argument|FT_Long  c
argument_list|)
end_macro
begin_block
block|{
name|FT_Int
name|s
init|=
literal|1
decl_stmt|;
name|FT_Long
name|d
decl_stmt|;
name|FT_MOVE_SIGN
argument_list|(
name|a
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|FT_MOVE_SIGN
argument_list|(
name|b
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|FT_MOVE_SIGN
argument_list|(
name|c
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|d
operator|=
call|(
name|FT_Long
call|)
argument_list|(
name|c
operator|>
literal|0
condition|?
operator|(
operator|(
name|FT_Int64
operator|)
name|a
operator|*
name|b
operator|+
operator|(
name|c
operator|>>
literal|1
operator|)
operator|)
operator|/
name|c
else|:
literal|0x7FFFFFFFL
argument_list|)
expr_stmt|;
return|return
name|s
operator|<
literal|0
condition|?
operator|-
name|d
else|:
name|d
return|;
block|}
end_block
begin_comment
comment|/* documentation is in ftcalc.h */
end_comment
begin_macro
DECL|function|FT_BASE_DEF
name|FT_BASE_DEF
argument_list|(
argument|FT_Long
argument_list|)
end_macro
begin_macro
name|FT_MulDiv_No_Round
argument_list|(
argument|FT_Long  a
argument_list|,
argument|FT_Long  b
argument_list|,
argument|FT_Long  c
argument_list|)
end_macro
begin_block
block|{
name|FT_Int
name|s
init|=
literal|1
decl_stmt|;
name|FT_Long
name|d
decl_stmt|;
name|FT_MOVE_SIGN
argument_list|(
name|a
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|FT_MOVE_SIGN
argument_list|(
name|b
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|FT_MOVE_SIGN
argument_list|(
name|c
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|d
operator|=
call|(
name|FT_Long
call|)
argument_list|(
name|c
operator|>
literal|0
condition|?
operator|(
name|FT_Int64
operator|)
name|a
operator|*
name|b
operator|/
name|c
else|:
literal|0x7FFFFFFFL
argument_list|)
expr_stmt|;
return|return
name|s
operator|<
literal|0
condition|?
operator|-
name|d
else|:
name|d
return|;
block|}
end_block
begin_comment
comment|/* documentation is in freetype.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Long
argument_list|)
end_macro
begin_macro
name|FT_MulFix
argument_list|(
argument|FT_Long  a
argument_list|,
argument|FT_Long  b
argument_list|)
end_macro
begin_block
block|{
ifdef|#
directive|ifdef
name|FT_MULFIX_ASSEMBLER
return|return
name|FT_MULFIX_ASSEMBLER
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
else|#
directive|else
name|FT_Int
name|s
init|=
literal|1
decl_stmt|;
name|FT_Long
name|c
decl_stmt|;
name|FT_MOVE_SIGN
argument_list|(
name|a
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|FT_MOVE_SIGN
argument_list|(
name|b
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|c
operator|=
call|(
name|FT_Long
call|)
argument_list|(
operator|(
operator|(
name|FT_Int64
operator|)
name|a
operator|*
name|b
operator|+
literal|0x8000L
operator|)
operator|>>
literal|16
argument_list|)
expr_stmt|;
return|return
name|s
operator|<
literal|0
condition|?
operator|-
name|c
else|:
name|c
return|;
endif|#
directive|endif
comment|/* FT_MULFIX_ASSEMBLER */
block|}
end_block
begin_comment
comment|/* documentation is in freetype.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Long
argument_list|)
end_macro
begin_macro
name|FT_DivFix
argument_list|(
argument|FT_Long  a
argument_list|,
argument|FT_Long  b
argument_list|)
end_macro
begin_block
block|{
name|FT_Int
name|s
init|=
literal|1
decl_stmt|;
name|FT_Long
name|q
decl_stmt|;
name|FT_MOVE_SIGN
argument_list|(
name|a
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|FT_MOVE_SIGN
argument_list|(
name|b
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|q
operator|=
call|(
name|FT_Long
call|)
argument_list|(
name|b
operator|>
literal|0
condition|?
operator|(
operator|(
operator|(
name|FT_UInt64
operator|)
name|a
operator|<<
literal|16
operator|)
operator|+
operator|(
name|b
operator|>>
literal|1
operator|)
operator|)
operator|/
name|b
else|:
literal|0x7FFFFFFFL
argument_list|)
expr_stmt|;
return|return
name|s
operator|<
literal|0
condition|?
operator|-
name|q
else|:
name|q
return|;
block|}
end_block
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* !FT_LONG64 */
end_comment
begin_function
specifier|static
name|void
DECL|function|ft_multo64
name|ft_multo64
parameter_list|(
name|FT_UInt32
name|x
parameter_list|,
name|FT_UInt32
name|y
parameter_list|,
name|FT_Int64
modifier|*
name|z
parameter_list|)
block|{
name|FT_UInt32
name|lo1
decl_stmt|,
name|hi1
decl_stmt|,
name|lo2
decl_stmt|,
name|hi2
decl_stmt|,
name|lo
decl_stmt|,
name|hi
decl_stmt|,
name|i1
decl_stmt|,
name|i2
decl_stmt|;
name|lo1
operator|=
name|x
operator|&
literal|0x0000FFFFU
expr_stmt|;
name|hi1
operator|=
name|x
operator|>>
literal|16
expr_stmt|;
name|lo2
operator|=
name|y
operator|&
literal|0x0000FFFFU
expr_stmt|;
name|hi2
operator|=
name|y
operator|>>
literal|16
expr_stmt|;
name|lo
operator|=
name|lo1
operator|*
name|lo2
expr_stmt|;
name|i1
operator|=
name|lo1
operator|*
name|hi2
expr_stmt|;
name|i2
operator|=
name|lo2
operator|*
name|hi1
expr_stmt|;
name|hi
operator|=
name|hi1
operator|*
name|hi2
expr_stmt|;
comment|/* Check carry overflow of i1 + i2 */
name|i1
operator|+=
name|i2
expr_stmt|;
name|hi
operator|+=
call|(
name|FT_UInt32
call|)
argument_list|(
name|i1
operator|<
name|i2
argument_list|)
operator|<<
literal|16
expr_stmt|;
name|hi
operator|+=
name|i1
operator|>>
literal|16
expr_stmt|;
name|i1
operator|=
name|i1
operator|<<
literal|16
expr_stmt|;
comment|/* Check carry overflow of i1 + lo */
name|lo
operator|+=
name|i1
expr_stmt|;
name|hi
operator|+=
operator|(
name|lo
operator|<
name|i1
operator|)
expr_stmt|;
name|z
operator|->
name|lo
operator|=
name|lo
expr_stmt|;
name|z
operator|->
name|hi
operator|=
name|hi
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|FT_UInt32
DECL|function|ft_div64by32
name|ft_div64by32
parameter_list|(
name|FT_UInt32
name|hi
parameter_list|,
name|FT_UInt32
name|lo
parameter_list|,
name|FT_UInt32
name|y
parameter_list|)
block|{
name|FT_UInt32
name|r
decl_stmt|,
name|q
decl_stmt|;
name|FT_Int
name|i
decl_stmt|;
if|if
condition|(
name|hi
operator|>=
name|y
condition|)
return|return
operator|(
name|FT_UInt32
operator|)
literal|0x7FFFFFFFL
return|;
comment|/* We shift as many bits as we can into the high register, perform     */
comment|/* 32-bit division with modulo there, then work through the remaining  */
comment|/* bits with long division. This optimization is especially noticeable */
comment|/* for smaller dividends that barely use the high register.            */
name|i
operator|=
literal|31
operator|-
name|FT_MSB
argument_list|(
name|hi
argument_list|)
expr_stmt|;
name|r
operator|=
operator|(
name|hi
operator|<<
name|i
operator|)
operator||
operator|(
name|lo
operator|>>
operator|(
literal|32
operator|-
name|i
operator|)
operator|)
expr_stmt|;
name|lo
operator|<<=
name|i
expr_stmt|;
comment|/* left 64-bit shift */
name|q
operator|=
name|r
operator|/
name|y
expr_stmt|;
name|r
operator|-=
name|q
operator|*
name|y
expr_stmt|;
comment|/* remainder */
name|i
operator|=
literal|32
operator|-
name|i
expr_stmt|;
comment|/* bits remaining in low register */
do|do
block|{
name|q
operator|<<=
literal|1
expr_stmt|;
name|r
operator|=
operator|(
name|r
operator|<<
literal|1
operator|)
operator||
operator|(
name|lo
operator|>>
literal|31
operator|)
expr_stmt|;
name|lo
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|r
operator|>=
name|y
condition|)
block|{
name|r
operator|-=
name|y
expr_stmt|;
name|q
operator||=
literal|1
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|--
name|i
condition|)
do|;
return|return
name|q
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|FT_Add64
name|FT_Add64
parameter_list|(
name|FT_Int64
modifier|*
name|x
parameter_list|,
name|FT_Int64
modifier|*
name|y
parameter_list|,
name|FT_Int64
modifier|*
name|z
parameter_list|)
block|{
name|FT_UInt32
name|lo
decl_stmt|,
name|hi
decl_stmt|;
name|lo
operator|=
name|x
operator|->
name|lo
operator|+
name|y
operator|->
name|lo
expr_stmt|;
name|hi
operator|=
name|x
operator|->
name|hi
operator|+
name|y
operator|->
name|hi
operator|+
operator|(
name|lo
operator|<
name|x
operator|->
name|lo
operator|)
expr_stmt|;
name|z
operator|->
name|lo
operator|=
name|lo
expr_stmt|;
name|z
operator|->
name|hi
operator|=
name|hi
expr_stmt|;
block|}
end_function
begin_comment
comment|/*  The FT_MulDiv function has been optimized thanks to ideas from     */
end_comment
begin_comment
comment|/*  Graham Asher and Alexei Podtelezhnikov.  The trick is to optimize  */
end_comment
begin_comment
comment|/*  a rather common case when everything fits within 32-bits.          */
end_comment
begin_comment
comment|/*                                                                     */
end_comment
begin_comment
comment|/*  We compute 'a*b+c/2', then divide it by 'c' (all positive values). */
end_comment
begin_comment
comment|/*                                                                     */
end_comment
begin_comment
comment|/*  The product of two positive numbers never exceeds the square of    */
end_comment
begin_comment
comment|/*  its mean values.  Therefore, we always avoid the overflow by       */
end_comment
begin_comment
comment|/*  imposing                                                           */
end_comment
begin_comment
comment|/*                                                                     */
end_comment
begin_comment
comment|/*    (a + b) / 2<= sqrt(X - c/2)    ,                                */
end_comment
begin_comment
comment|/*                                                                     */
end_comment
begin_comment
comment|/*  where X = 2^32 - 1, the maximum unsigned 32-bit value, and using   */
end_comment
begin_comment
comment|/*  unsigned arithmetic.  Now we replace `sqrt' with a linear function */
end_comment
begin_comment
comment|/*  that is smaller or equal for all values of c in the interval       */
end_comment
begin_comment
comment|/*  [0;X/2]; it should be equal to sqrt(X) and sqrt(3X/4) at the       */
end_comment
begin_comment
comment|/*  endpoints.  Substituting the linear solution and explicit numbers  */
end_comment
begin_comment
comment|/*  we get                                                             */
end_comment
begin_comment
comment|/*                                                                     */
end_comment
begin_comment
comment|/*    a + b<= 131071.99 - c / 122291.84    .                          */
end_comment
begin_comment
comment|/*                                                                     */
end_comment
begin_comment
comment|/*  In practice, we should use a faster and even stronger inequality   */
end_comment
begin_comment
comment|/*                                                                     */
end_comment
begin_comment
comment|/*    a + b<= 131071 - (c>> 16)                                      */
end_comment
begin_comment
comment|/*                                                                     */
end_comment
begin_comment
comment|/*  or, alternatively,                                                 */
end_comment
begin_comment
comment|/*                                                                     */
end_comment
begin_comment
comment|/*    a + b<= 129894 - (c>> 17)    .                                 */
end_comment
begin_comment
comment|/*                                                                     */
end_comment
begin_comment
comment|/*  FT_MulFix, on the other hand, is optimized for a small value of    */
end_comment
begin_comment
comment|/*  the first argument, when the second argument can be much larger.   */
end_comment
begin_comment
comment|/*  This can be achieved by scaling the second argument and the limit  */
end_comment
begin_comment
comment|/*  in the above inequalities.  For example,                           */
end_comment
begin_comment
comment|/*                                                                     */
end_comment
begin_comment
comment|/*    a + (b>> 8)<= (131071>> 4)                                    */
end_comment
begin_comment
comment|/*                                                                     */
end_comment
begin_comment
comment|/*  covers the practical range of use. The actual test below is a bit  */
end_comment
begin_comment
comment|/*  tighter to avoid the border case overflows.                        */
end_comment
begin_comment
comment|/*                                                                     */
end_comment
begin_comment
comment|/*  In the case of FT_DivFix, the exact overflow check                 */
end_comment
begin_comment
comment|/*                                                                     */
end_comment
begin_comment
comment|/*    a<< 16<= X - c/2                                               */
end_comment
begin_comment
comment|/*                                                                     */
end_comment
begin_comment
comment|/*  is scaled down by 2^16 and we use                                  */
end_comment
begin_comment
comment|/*                                                                     */
end_comment
begin_comment
comment|/*    a<= 65535 - (c>> 17)    .                                      */
end_comment
begin_comment
comment|/* documentation is in freetype.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Long
argument_list|)
end_macro
begin_macro
name|FT_MulDiv
argument_list|(
argument|FT_Long  a
argument_list|,
argument|FT_Long  b
argument_list|,
argument|FT_Long  c
argument_list|)
end_macro
begin_block
block|{
name|FT_Int
name|s
init|=
literal|1
decl_stmt|;
comment|/* XXX: this function does not allow 64-bit arguments */
if|if
condition|(
name|a
operator|==
literal|0
operator|||
name|b
operator|==
name|c
condition|)
return|return
name|a
return|;
name|FT_MOVE_SIGN
argument_list|(
name|a
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|FT_MOVE_SIGN
argument_list|(
name|b
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|FT_MOVE_SIGN
argument_list|(
name|c
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
name|a
operator|=
literal|0x7FFFFFFFL
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|FT_ULong
operator|)
name|a
operator|+
name|b
operator|<=
literal|129894UL
operator|-
operator|(
name|c
operator|>>
literal|17
operator|)
condition|)
name|a
operator|=
operator|(
operator|(
name|FT_ULong
operator|)
name|a
operator|*
name|b
operator|+
operator|(
name|c
operator|>>
literal|1
operator|)
operator|)
operator|/
name|c
expr_stmt|;
else|else
block|{
name|FT_Int64
name|temp
decl_stmt|,
name|temp2
decl_stmt|;
name|ft_multo64
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
name|temp2
operator|.
name|hi
operator|=
literal|0
expr_stmt|;
name|temp2
operator|.
name|lo
operator|=
name|c
operator|>>
literal|1
expr_stmt|;
name|FT_Add64
argument_list|(
operator|&
name|temp
argument_list|,
operator|&
name|temp2
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
comment|/* last attempt to ditch long division */
name|a
operator|=
name|temp
operator|.
name|hi
operator|==
literal|0
condition|?
name|temp
operator|.
name|lo
operator|/
name|c
else|:
name|ft_div64by32
argument_list|(
name|temp
operator|.
name|hi
argument_list|,
name|temp
operator|.
name|lo
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
return|return
name|s
operator|<
literal|0
condition|?
operator|-
name|a
else|:
name|a
return|;
block|}
end_block
begin_macro
DECL|function|FT_BASE_DEF
name|FT_BASE_DEF
argument_list|(
argument|FT_Long
argument_list|)
end_macro
begin_macro
name|FT_MulDiv_No_Round
argument_list|(
argument|FT_Long  a
argument_list|,
argument|FT_Long  b
argument_list|,
argument|FT_Long  c
argument_list|)
end_macro
begin_block
block|{
name|FT_Int
name|s
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|a
operator|==
literal|0
operator|||
name|b
operator|==
name|c
condition|)
return|return
name|a
return|;
name|FT_MOVE_SIGN
argument_list|(
name|a
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|FT_MOVE_SIGN
argument_list|(
name|b
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|FT_MOVE_SIGN
argument_list|(
name|c
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
name|a
operator|=
literal|0x7FFFFFFFL
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|FT_ULong
operator|)
name|a
operator|+
name|b
operator|<=
literal|131071UL
condition|)
name|a
operator|=
operator|(
name|FT_ULong
operator|)
name|a
operator|*
name|b
operator|/
name|c
expr_stmt|;
else|else
block|{
name|FT_Int64
name|temp
decl_stmt|;
name|ft_multo64
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
comment|/* last attempt to ditch long division */
name|a
operator|=
name|temp
operator|.
name|hi
operator|==
literal|0
condition|?
name|temp
operator|.
name|lo
operator|/
name|c
else|:
name|ft_div64by32
argument_list|(
name|temp
operator|.
name|hi
argument_list|,
name|temp
operator|.
name|lo
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
return|return
name|s
operator|<
literal|0
condition|?
operator|-
name|a
else|:
name|a
return|;
block|}
end_block
begin_comment
comment|/* documentation is in freetype.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Long
argument_list|)
end_macro
begin_macro
name|FT_MulFix
argument_list|(
argument|FT_Long  a
argument_list|,
argument|FT_Long  b
argument_list|)
end_macro
begin_block
block|{
ifdef|#
directive|ifdef
name|FT_MULFIX_ASSEMBLER
return|return
name|FT_MULFIX_ASSEMBLER
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
elif|#
directive|elif
literal|0
comment|/*      *  This code is nonportable.  See comment below.      *      *  However, on a platform where right-shift of a signed quantity fills      *  the leftmost bits by copying the sign bit, it might be faster.      */
name|FT_Long
name|sa
decl_stmt|,
name|sb
decl_stmt|;
name|FT_ULong
name|ua
decl_stmt|,
name|ub
decl_stmt|;
if|if
condition|(
name|a
operator|==
literal|0
operator|||
name|b
operator|==
literal|0x10000L
condition|)
return|return
name|a
return|;
comment|/*      *  This is a clever way of converting a signed number `a' into its      *  absolute value (stored back into `a') and its sign.  The sign is      *  stored in `sa'; 0 means `a' was positive or zero, and -1 means `a'      *  was negative.  (Similarly for `b' and `sb').      *      *  Unfortunately, it doesn't work (at least not portably).      *      *  It makes the assumption that right-shift on a negative signed value      *  fills the leftmost bits by copying the sign bit.  This is wrong.      *  According to K&R 2nd ed, section `A7.8 Shift Operators' on page 206,      *  the result of right-shift of a negative signed value is      *  implementation-defined.  At least one implementation fills the      *  leftmost bits with 0s (i.e., it is exactly the same as an unsigned      *  right shift).  This means that when `a' is negative, `sa' ends up      *  with the value 1 rather than -1.  After that, everything else goes      *  wrong.      */
name|sa
operator|=
operator|(
name|a
operator|>>
operator|(
sizeof|sizeof
argument_list|(
name|a
argument_list|)
operator|*
literal|8
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|a
operator|=
operator|(
name|a
operator|^
name|sa
operator|)
operator|-
name|sa
expr_stmt|;
name|sb
operator|=
operator|(
name|b
operator|>>
operator|(
sizeof|sizeof
argument_list|(
name|b
argument_list|)
operator|*
literal|8
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|b
operator|=
operator|(
name|b
operator|^
name|sb
operator|)
operator|-
name|sb
expr_stmt|;
name|ua
operator|=
operator|(
name|FT_ULong
operator|)
name|a
expr_stmt|;
name|ub
operator|=
operator|(
name|FT_ULong
operator|)
name|b
expr_stmt|;
if|if
condition|(
name|ua
operator|+
operator|(
name|ub
operator|>>
literal|8
operator|)
operator|<=
literal|8190UL
condition|)
name|ua
operator|=
operator|(
name|ua
operator|*
name|ub
operator|+
literal|0x8000U
operator|)
operator|>>
literal|16
expr_stmt|;
else|else
block|{
name|FT_ULong
name|al
init|=
name|ua
operator|&
literal|0xFFFFU
decl_stmt|;
name|ua
operator|=
operator|(
name|ua
operator|>>
literal|16
operator|)
operator|*
name|ub
operator|+
name|al
operator|*
operator|(
name|ub
operator|>>
literal|16
operator|)
operator|+
operator|(
operator|(
name|al
operator|*
operator|(
name|ub
operator|&
literal|0xFFFFU
operator|)
operator|+
literal|0x8000U
operator|)
operator|>>
literal|16
operator|)
expr_stmt|;
block|}
name|sa
operator|^=
name|sb
operator|,
name|ua
operator|=
call|(
name|FT_ULong
call|)
argument_list|(
operator|(
name|ua
operator|^
name|sa
operator|)
operator|-
name|sa
argument_list|)
expr_stmt|;
return|return
operator|(
name|FT_Long
operator|)
name|ua
return|;
else|#
directive|else
comment|/* 0 */
name|FT_Int
name|s
init|=
literal|1
decl_stmt|;
name|FT_ULong
name|ua
decl_stmt|,
name|ub
decl_stmt|;
if|if
condition|(
name|a
operator|==
literal|0
operator|||
name|b
operator|==
literal|0x10000L
condition|)
return|return
name|a
return|;
name|FT_MOVE_SIGN
argument_list|(
name|a
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|FT_MOVE_SIGN
argument_list|(
name|b
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|ua
operator|=
operator|(
name|FT_ULong
operator|)
name|a
expr_stmt|;
name|ub
operator|=
operator|(
name|FT_ULong
operator|)
name|b
expr_stmt|;
if|if
condition|(
name|ua
operator|+
operator|(
name|ub
operator|>>
literal|8
operator|)
operator|<=
literal|8190UL
condition|)
name|ua
operator|=
operator|(
name|ua
operator|*
name|ub
operator|+
literal|0x8000UL
operator|)
operator|>>
literal|16
expr_stmt|;
else|else
block|{
name|FT_ULong
name|al
init|=
name|ua
operator|&
literal|0xFFFFUL
decl_stmt|;
name|ua
operator|=
operator|(
name|ua
operator|>>
literal|16
operator|)
operator|*
name|ub
operator|+
name|al
operator|*
operator|(
name|ub
operator|>>
literal|16
operator|)
operator|+
operator|(
operator|(
name|al
operator|*
operator|(
name|ub
operator|&
literal|0xFFFFUL
operator|)
operator|+
literal|0x8000UL
operator|)
operator|>>
literal|16
operator|)
expr_stmt|;
block|}
return|return
name|s
operator|<
literal|0
condition|?
operator|-
operator|(
name|FT_Long
operator|)
name|ua
else|:
operator|(
name|FT_Long
operator|)
name|ua
return|;
endif|#
directive|endif
comment|/* 0 */
block|}
end_block
begin_comment
comment|/* documentation is in freetype.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Long
argument_list|)
end_macro
begin_macro
name|FT_DivFix
argument_list|(
argument|FT_Long  a
argument_list|,
argument|FT_Long  b
argument_list|)
end_macro
begin_block
block|{
name|FT_Int
name|s
init|=
literal|1
decl_stmt|;
name|FT_Long
name|q
decl_stmt|;
comment|/* XXX: this function does not allow 64-bit arguments */
name|FT_MOVE_SIGN
argument_list|(
name|a
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|FT_MOVE_SIGN
argument_list|(
name|b
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|==
literal|0
condition|)
block|{
comment|/* check for division by 0 */
name|q
operator|=
literal|0x7FFFFFFFL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|a
operator|<=
literal|65535L
operator|-
operator|(
name|b
operator|>>
literal|17
operator|)
condition|)
block|{
comment|/* compute result directly */
name|q
operator|=
call|(
name|FT_Long
call|)
argument_list|(
operator|(
operator|(
operator|(
name|FT_ULong
operator|)
name|a
operator|<<
literal|16
operator|)
operator|+
operator|(
name|b
operator|>>
literal|1
operator|)
operator|)
operator|/
name|b
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* we need more bits; we have to do it by hand */
name|FT_Int64
name|temp
decl_stmt|,
name|temp2
decl_stmt|;
name|temp
operator|.
name|hi
operator|=
name|a
operator|>>
literal|16
expr_stmt|;
name|temp
operator|.
name|lo
operator|=
name|a
operator|<<
literal|16
expr_stmt|;
name|temp2
operator|.
name|hi
operator|=
literal|0
expr_stmt|;
name|temp2
operator|.
name|lo
operator|=
name|b
operator|>>
literal|1
expr_stmt|;
name|FT_Add64
argument_list|(
operator|&
name|temp
argument_list|,
operator|&
name|temp2
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
name|q
operator|=
operator|(
name|FT_Long
operator|)
name|ft_div64by32
argument_list|(
name|temp
operator|.
name|hi
argument_list|,
name|temp
operator|.
name|lo
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
return|return
name|s
operator|<
literal|0
condition|?
operator|-
name|q
else|:
name|q
return|;
block|}
end_block
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* FT_LONG64 */
end_comment
begin_comment
comment|/* documentation is in ftglyph.h */
end_comment
begin_macro
name|FT_EXPORT_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|FT_Matrix_Multiply
name|FT_Matrix_Multiply
argument_list|(
argument|const FT_Matrix*  a
argument_list|,
argument|FT_Matrix        *b
argument_list|)
end_macro
begin_block
block|{
name|FT_Fixed
name|xx
decl_stmt|,
name|xy
decl_stmt|,
name|yx
decl_stmt|,
name|yy
decl_stmt|;
if|if
condition|(
operator|!
name|a
operator|||
operator|!
name|b
condition|)
return|return;
name|xx
operator|=
name|FT_MulFix
argument_list|(
name|a
operator|->
name|xx
argument_list|,
name|b
operator|->
name|xx
argument_list|)
operator|+
name|FT_MulFix
argument_list|(
name|a
operator|->
name|xy
argument_list|,
name|b
operator|->
name|yx
argument_list|)
expr_stmt|;
name|xy
operator|=
name|FT_MulFix
argument_list|(
name|a
operator|->
name|xx
argument_list|,
name|b
operator|->
name|xy
argument_list|)
operator|+
name|FT_MulFix
argument_list|(
name|a
operator|->
name|xy
argument_list|,
name|b
operator|->
name|yy
argument_list|)
expr_stmt|;
name|yx
operator|=
name|FT_MulFix
argument_list|(
name|a
operator|->
name|yx
argument_list|,
name|b
operator|->
name|xx
argument_list|)
operator|+
name|FT_MulFix
argument_list|(
name|a
operator|->
name|yy
argument_list|,
name|b
operator|->
name|yx
argument_list|)
expr_stmt|;
name|yy
operator|=
name|FT_MulFix
argument_list|(
name|a
operator|->
name|yx
argument_list|,
name|b
operator|->
name|xy
argument_list|)
operator|+
name|FT_MulFix
argument_list|(
name|a
operator|->
name|yy
argument_list|,
name|b
operator|->
name|yy
argument_list|)
expr_stmt|;
name|b
operator|->
name|xx
operator|=
name|xx
expr_stmt|;
name|b
operator|->
name|xy
operator|=
name|xy
expr_stmt|;
name|b
operator|->
name|yx
operator|=
name|yx
expr_stmt|;
name|b
operator|->
name|yy
operator|=
name|yy
expr_stmt|;
block|}
end_block
begin_comment
comment|/* documentation is in ftglyph.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_Matrix_Invert
argument_list|(
argument|FT_Matrix*  matrix
argument_list|)
end_macro
begin_block
block|{
name|FT_Pos
name|delta
decl_stmt|,
name|xx
decl_stmt|,
name|yy
decl_stmt|;
if|if
condition|(
operator|!
name|matrix
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_Argument
argument_list|)
return|;
comment|/* compute discriminant */
name|delta
operator|=
name|FT_MulFix
argument_list|(
name|matrix
operator|->
name|xx
argument_list|,
name|matrix
operator|->
name|yy
argument_list|)
operator|-
name|FT_MulFix
argument_list|(
name|matrix
operator|->
name|xy
argument_list|,
name|matrix
operator|->
name|yx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|delta
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_Argument
argument_list|)
return|;
comment|/* matrix can't be inverted */
name|matrix
operator|->
name|xy
operator|=
operator|-
name|FT_DivFix
argument_list|(
name|matrix
operator|->
name|xy
argument_list|,
name|delta
argument_list|)
expr_stmt|;
name|matrix
operator|->
name|yx
operator|=
operator|-
name|FT_DivFix
argument_list|(
name|matrix
operator|->
name|yx
argument_list|,
name|delta
argument_list|)
expr_stmt|;
name|xx
operator|=
name|matrix
operator|->
name|xx
expr_stmt|;
name|yy
operator|=
name|matrix
operator|->
name|yy
expr_stmt|;
name|matrix
operator|->
name|xx
operator|=
name|FT_DivFix
argument_list|(
name|yy
argument_list|,
name|delta
argument_list|)
expr_stmt|;
name|matrix
operator|->
name|yy
operator|=
name|FT_DivFix
argument_list|(
name|xx
argument_list|,
name|delta
argument_list|)
expr_stmt|;
return|return
name|FT_Err_Ok
return|;
block|}
end_block
begin_comment
comment|/* documentation is in ftcalc.h */
end_comment
begin_macro
name|FT_BASE_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|FT_Matrix_Multiply_Scaled
name|FT_Matrix_Multiply_Scaled
argument_list|(
argument|const FT_Matrix*  a
argument_list|,
argument|FT_Matrix        *b
argument_list|,
argument|FT_Long           scaling
argument_list|)
end_macro
begin_block
block|{
name|FT_Fixed
name|xx
decl_stmt|,
name|xy
decl_stmt|,
name|yx
decl_stmt|,
name|yy
decl_stmt|;
name|FT_Long
name|val
init|=
literal|0x10000L
operator|*
name|scaling
decl_stmt|;
if|if
condition|(
operator|!
name|a
operator|||
operator|!
name|b
condition|)
return|return;
name|xx
operator|=
name|FT_MulDiv
argument_list|(
name|a
operator|->
name|xx
argument_list|,
name|b
operator|->
name|xx
argument_list|,
name|val
argument_list|)
operator|+
name|FT_MulDiv
argument_list|(
name|a
operator|->
name|xy
argument_list|,
name|b
operator|->
name|yx
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|xy
operator|=
name|FT_MulDiv
argument_list|(
name|a
operator|->
name|xx
argument_list|,
name|b
operator|->
name|xy
argument_list|,
name|val
argument_list|)
operator|+
name|FT_MulDiv
argument_list|(
name|a
operator|->
name|xy
argument_list|,
name|b
operator|->
name|yy
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|yx
operator|=
name|FT_MulDiv
argument_list|(
name|a
operator|->
name|yx
argument_list|,
name|b
operator|->
name|xx
argument_list|,
name|val
argument_list|)
operator|+
name|FT_MulDiv
argument_list|(
name|a
operator|->
name|yy
argument_list|,
name|b
operator|->
name|yx
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|yy
operator|=
name|FT_MulDiv
argument_list|(
name|a
operator|->
name|yx
argument_list|,
name|b
operator|->
name|xy
argument_list|,
name|val
argument_list|)
operator|+
name|FT_MulDiv
argument_list|(
name|a
operator|->
name|yy
argument_list|,
name|b
operator|->
name|yy
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|b
operator|->
name|xx
operator|=
name|xx
expr_stmt|;
name|b
operator|->
name|xy
operator|=
name|xy
expr_stmt|;
name|b
operator|->
name|yx
operator|=
name|yx
expr_stmt|;
name|b
operator|->
name|yy
operator|=
name|yy
expr_stmt|;
block|}
end_block
begin_comment
comment|/* documentation is in ftcalc.h */
end_comment
begin_macro
name|FT_BASE_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|FT_Vector_Transform_Scaled
name|FT_Vector_Transform_Scaled
argument_list|(
argument|FT_Vector*        vector
argument_list|,
argument|const FT_Matrix*  matrix
argument_list|,
argument|FT_Long           scaling
argument_list|)
end_macro
begin_block
block|{
name|FT_Pos
name|xz
decl_stmt|,
name|yz
decl_stmt|;
name|FT_Long
name|val
init|=
literal|0x10000L
operator|*
name|scaling
decl_stmt|;
if|if
condition|(
operator|!
name|vector
operator|||
operator|!
name|matrix
condition|)
return|return;
name|xz
operator|=
name|FT_MulDiv
argument_list|(
name|vector
operator|->
name|x
argument_list|,
name|matrix
operator|->
name|xx
argument_list|,
name|val
argument_list|)
operator|+
name|FT_MulDiv
argument_list|(
name|vector
operator|->
name|y
argument_list|,
name|matrix
operator|->
name|xy
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|yz
operator|=
name|FT_MulDiv
argument_list|(
name|vector
operator|->
name|x
argument_list|,
name|matrix
operator|->
name|yx
argument_list|,
name|val
argument_list|)
operator|+
name|FT_MulDiv
argument_list|(
name|vector
operator|->
name|y
argument_list|,
name|matrix
operator|->
name|yy
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|vector
operator|->
name|x
operator|=
name|xz
expr_stmt|;
name|vector
operator|->
name|y
operator|=
name|yz
expr_stmt|;
block|}
end_block
begin_if
if|#
directive|if
literal|0
end_if
begin_comment
comment|/* documentation is in ftcalc.h */
end_comment
begin_endif
unit|FT_BASE_DEF( FT_Int32 )   FT_SqrtFixed( FT_Int32  x )   {     FT_UInt32  root, rem_hi, rem_lo, test_div;     FT_Int     count;       root = 0;      if ( x> 0 )     {       rem_hi = 0;       rem_lo = x;       count  = 24;       do       {         rem_hi   = ( rem_hi<< 2 ) | ( rem_lo>> 30 );         rem_lo<<= 2;         root<<= 1;         test_div = ( root<< 1 ) + 1;          if ( rem_hi>= test_div )         {           rem_hi -= test_div;           root   += 1;         }       } while ( --count );     }      return (FT_Int32)root;   }
endif|#
directive|endif
end_endif
begin_comment
comment|/* 0 */
end_comment
begin_comment
comment|/* documentation is in ftcalc.h */
end_comment
begin_macro
DECL|function|FT_BASE_DEF
name|FT_BASE_DEF
argument_list|(
argument|FT_Int
argument_list|)
end_macro
begin_macro
name|ft_corner_orientation
argument_list|(
argument|FT_Pos  in_x
argument_list|,
argument|FT_Pos  in_y
argument_list|,
argument|FT_Pos  out_x
argument_list|,
argument|FT_Pos  out_y
argument_list|)
end_macro
begin_block
block|{
name|FT_Long
name|result
decl_stmt|;
comment|/* avoid overflow on 16-bit system */
comment|/* deal with the trivial cases quickly */
if|if
condition|(
name|in_y
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|in_x
operator|>=
literal|0
condition|)
name|result
operator|=
name|out_y
expr_stmt|;
else|else
name|result
operator|=
operator|-
name|out_y
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|in_x
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|in_y
operator|>=
literal|0
condition|)
name|result
operator|=
operator|-
name|out_x
expr_stmt|;
else|else
name|result
operator|=
name|out_x
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|out_y
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|out_x
operator|>=
literal|0
condition|)
name|result
operator|=
name|in_y
expr_stmt|;
else|else
name|result
operator|=
operator|-
name|in_y
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|out_x
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|out_y
operator|>=
literal|0
condition|)
name|result
operator|=
operator|-
name|in_x
expr_stmt|;
else|else
name|result
operator|=
name|in_x
expr_stmt|;
block|}
else|else
comment|/* general case */
block|{
ifdef|#
directive|ifdef
name|FT_LONG64
name|FT_Int64
name|delta
init|=
operator|(
name|FT_Int64
operator|)
name|in_x
operator|*
name|out_y
operator|-
operator|(
name|FT_Int64
operator|)
name|in_y
operator|*
name|out_x
decl_stmt|;
if|if
condition|(
name|delta
operator|==
literal|0
condition|)
name|result
operator|=
literal|0
expr_stmt|;
else|else
name|result
operator|=
literal|1
operator|-
literal|2
operator|*
operator|(
name|delta
operator|<
literal|0
operator|)
expr_stmt|;
else|#
directive|else
name|FT_Int64
name|z1
decl_stmt|,
name|z2
decl_stmt|;
comment|/* XXX: this function does not allow 64-bit arguments */
name|ft_multo64
argument_list|(
operator|(
name|FT_Int32
operator|)
name|in_x
argument_list|,
operator|(
name|FT_Int32
operator|)
name|out_y
argument_list|,
operator|&
name|z1
argument_list|)
expr_stmt|;
name|ft_multo64
argument_list|(
operator|(
name|FT_Int32
operator|)
name|in_y
argument_list|,
operator|(
name|FT_Int32
operator|)
name|out_x
argument_list|,
operator|&
name|z2
argument_list|)
expr_stmt|;
if|if
condition|(
name|z1
operator|.
name|hi
operator|>
name|z2
operator|.
name|hi
condition|)
name|result
operator|=
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|z1
operator|.
name|hi
operator|<
name|z2
operator|.
name|hi
condition|)
name|result
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|z1
operator|.
name|lo
operator|>
name|z2
operator|.
name|lo
condition|)
name|result
operator|=
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|z1
operator|.
name|lo
operator|<
name|z2
operator|.
name|lo
condition|)
name|result
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|result
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* XXX: only the sign of return value, +1/0/-1 must be used */
return|return
operator|(
name|FT_Int
operator|)
name|result
return|;
block|}
end_block
begin_comment
comment|/* documentation is in ftcalc.h */
end_comment
begin_macro
DECL|function|FT_BASE_DEF
name|FT_BASE_DEF
argument_list|(
argument|FT_Int
argument_list|)
end_macro
begin_macro
name|ft_corner_is_flat
argument_list|(
argument|FT_Pos  in_x
argument_list|,
argument|FT_Pos  in_y
argument_list|,
argument|FT_Pos  out_x
argument_list|,
argument|FT_Pos  out_y
argument_list|)
end_macro
begin_block
block|{
name|FT_Pos
name|ax
init|=
name|in_x
operator|+
name|out_x
decl_stmt|;
name|FT_Pos
name|ay
init|=
name|in_y
operator|+
name|out_y
decl_stmt|;
name|FT_Pos
name|d_in
decl_stmt|,
name|d_out
decl_stmt|,
name|d_hypot
decl_stmt|;
comment|/* The idea of this function is to compare the length of the */
comment|/* hypotenuse with the `in' and `out' length.  The `corner'  */
comment|/* represented by `in' and `out' is flat if the hypotenuse's */
comment|/* length isn't too large.                                   */
comment|/*                                                           */
comment|/* This approach has the advantage that the angle between    */
comment|/* `in' and `out' is not checked.  In case one of the two    */
comment|/* vectors is `dominant', this is, much larger than the      */
comment|/* other vector, we thus always have a flat corner.          */
comment|/*                                                           */
comment|/*                hypotenuse                                 */
comment|/*       x---------------------------x                       */
comment|/*        \                      /                           */
comment|/*         \                /                                */
comment|/*      in  \          /  out                                */
comment|/*           \    /                                          */
comment|/*            o                                              */
comment|/*              Point                                        */
name|d_in
operator|=
name|FT_HYPOT
argument_list|(
name|in_x
argument_list|,
name|in_y
argument_list|)
expr_stmt|;
name|d_out
operator|=
name|FT_HYPOT
argument_list|(
name|out_x
argument_list|,
name|out_y
argument_list|)
expr_stmt|;
name|d_hypot
operator|=
name|FT_HYPOT
argument_list|(
name|ax
argument_list|,
name|ay
argument_list|)
expr_stmt|;
comment|/* now do a simple length comparison: */
comment|/*                                    */
comment|/*   d_in + d_out< 17/16 d_hypot     */
return|return
operator|(
name|d_in
operator|+
name|d_out
operator|-
name|d_hypot
operator|)
operator|<
operator|(
name|d_hypot
operator|>>
literal|4
operator|)
return|;
block|}
end_block
begin_comment
comment|/* END */
end_comment
end_unit
