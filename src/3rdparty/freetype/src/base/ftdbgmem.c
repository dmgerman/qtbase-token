begin_unit
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  ftdbgmem.c                                                             */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*    Memory debugger (body).                                              */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  Copyright 2001, 2002, 2003, 2004, 2005, 2006, 2009 by                  */
end_comment
begin_comment
comment|/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  This file is part of the FreeType project, and may only be used,       */
end_comment
begin_comment
comment|/*  modified, and distributed under the terms of the FreeType project      */
end_comment
begin_comment
comment|/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
end_comment
begin_comment
comment|/*  this file you indicate that you have read the license and              */
end_comment
begin_comment
comment|/*  understand and accept it fully.                                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<ft2build.h>
end_include
begin_include
include|#
directive|include
include|FT_CONFIG_CONFIG_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_DEBUG_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_MEMORY_H
end_include
begin_include
include|#
directive|include
include|FT_SYSTEM_H
end_include
begin_include
include|#
directive|include
include|FT_ERRORS_H
end_include
begin_include
include|#
directive|include
include|FT_TYPES_H
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|FT_DEBUG_MEMORY
end_ifdef
begin_define
DECL|macro|KEEPALIVE
define|#
directive|define
name|KEEPALIVE
end_define
begin_comment
DECL|macro|KEEPALIVE
comment|/* `Keep alive' means that freed blocks aren't released                     * to the heap.  This is useful to detect double-frees                     * or weird heap corruption, but it uses large amounts of                     * memory, however.                     */
end_comment
begin_include
include|#
directive|include
include|FT_CONFIG_STANDARD_LIBRARY_H
end_include
begin_macro
name|FT_BASE_DEF
argument_list|(
argument|const char*
argument_list|)
end_macro
begin_expr_stmt
name|_ft_debug_file
operator|=
literal|0
expr_stmt|;
end_expr_stmt
begin_macro
name|FT_BASE_DEF
argument_list|(
argument|long
argument_list|)
end_macro
begin_expr_stmt
name|_ft_debug_lineno
operator|=
literal|0
expr_stmt|;
end_expr_stmt
begin_function_decl
specifier|extern
name|void
name|FT_DumpMemory
parameter_list|(
name|FT_Memory
name|memory
parameter_list|)
function_decl|;
end_function_decl
begin_typedef
DECL|typedef|FT_MemSource
typedef|typedef
name|struct
name|FT_MemSourceRec_
modifier|*
name|FT_MemSource
typedef|;
end_typedef
begin_typedef
DECL|typedef|FT_MemNode
typedef|typedef
name|struct
name|FT_MemNodeRec_
modifier|*
name|FT_MemNode
typedef|;
end_typedef
begin_typedef
DECL|typedef|FT_MemTable
typedef|typedef
name|struct
name|FT_MemTableRec_
modifier|*
name|FT_MemTable
typedef|;
end_typedef
begin_define
DECL|macro|FT_MEM_VAL
define|#
directive|define
name|FT_MEM_VAL
parameter_list|(
name|addr
parameter_list|)
value|((FT_ULong)(FT_Pointer)( addr ))
end_define
begin_comment
comment|/*    *  This structure holds statistics for a single allocation/release    *  site.  This is useful to know where memory operations happen the    *  most.    */
end_comment
begin_typedef
DECL|struct|FT_MemSourceRec_
typedef|typedef
struct|struct
name|FT_MemSourceRec_
block|{
DECL|member|file_name
specifier|const
name|char
modifier|*
name|file_name
decl_stmt|;
DECL|member|line_no
name|long
name|line_no
decl_stmt|;
DECL|member|cur_blocks
name|FT_Long
name|cur_blocks
decl_stmt|;
comment|/* current number of allocated blocks */
DECL|member|max_blocks
name|FT_Long
name|max_blocks
decl_stmt|;
comment|/* max. number of allocated blocks    */
DECL|member|all_blocks
name|FT_Long
name|all_blocks
decl_stmt|;
comment|/* total number of blocks allocated   */
DECL|member|cur_size
name|FT_Long
name|cur_size
decl_stmt|;
comment|/* current cumulative allocated size */
DECL|member|max_size
name|FT_Long
name|max_size
decl_stmt|;
comment|/* maximum cumulative allocated size */
DECL|member|all_size
name|FT_Long
name|all_size
decl_stmt|;
comment|/* total cumulative allocated size   */
DECL|member|cur_max
name|FT_Long
name|cur_max
decl_stmt|;
comment|/* current maximum allocated size */
DECL|member|hash
name|FT_UInt32
name|hash
decl_stmt|;
DECL|member|link
name|FT_MemSource
name|link
decl_stmt|;
block|}
DECL|typedef|FT_MemSourceRec
name|FT_MemSourceRec
typedef|;
end_typedef
begin_comment
comment|/*    *  We don't need a resizable array for the memory sources, because    *  their number is pretty limited within FreeType.    */
end_comment
begin_define
DECL|macro|FT_MEM_SOURCE_BUCKETS
define|#
directive|define
name|FT_MEM_SOURCE_BUCKETS
value|128
end_define
begin_comment
comment|/*    *  This structure holds information related to a single allocated    *  memory block.  If KEEPALIVE is defined, blocks that are freed by    *  FreeType are never released to the system.  Instead, their `size'    *  field is set to -size.  This is mainly useful to detect double frees,    *  at the price of large memory footprint during execution.    */
end_comment
begin_typedef
DECL|struct|FT_MemNodeRec_
typedef|typedef
struct|struct
name|FT_MemNodeRec_
block|{
DECL|member|address
name|FT_Byte
modifier|*
name|address
decl_stmt|;
DECL|member|size
name|FT_Long
name|size
decl_stmt|;
comment|/*< 0 if the block was freed */
DECL|member|source
name|FT_MemSource
name|source
decl_stmt|;
ifdef|#
directive|ifdef
name|KEEPALIVE
DECL|member|free_file_name
specifier|const
name|char
modifier|*
name|free_file_name
decl_stmt|;
DECL|member|free_line_no
name|FT_Long
name|free_line_no
decl_stmt|;
endif|#
directive|endif
DECL|member|link
name|FT_MemNode
name|link
decl_stmt|;
block|}
DECL|typedef|FT_MemNodeRec
name|FT_MemNodeRec
typedef|;
end_typedef
begin_comment
comment|/*    *  The global structure, containing compound statistics and all hash    *  tables.    */
end_comment
begin_typedef
DECL|struct|FT_MemTableRec_
typedef|typedef
struct|struct
name|FT_MemTableRec_
block|{
DECL|member|size
name|FT_ULong
name|size
decl_stmt|;
DECL|member|nodes
name|FT_ULong
name|nodes
decl_stmt|;
DECL|member|buckets
name|FT_MemNode
modifier|*
name|buckets
decl_stmt|;
DECL|member|alloc_total
name|FT_ULong
name|alloc_total
decl_stmt|;
DECL|member|alloc_current
name|FT_ULong
name|alloc_current
decl_stmt|;
DECL|member|alloc_max
name|FT_ULong
name|alloc_max
decl_stmt|;
DECL|member|alloc_count
name|FT_ULong
name|alloc_count
decl_stmt|;
DECL|member|bound_total
name|FT_Bool
name|bound_total
decl_stmt|;
DECL|member|alloc_total_max
name|FT_ULong
name|alloc_total_max
decl_stmt|;
DECL|member|bound_count
name|FT_Bool
name|bound_count
decl_stmt|;
DECL|member|alloc_count_max
name|FT_ULong
name|alloc_count_max
decl_stmt|;
DECL|member|sources
name|FT_MemSource
name|sources
index|[
name|FT_MEM_SOURCE_BUCKETS
index|]
decl_stmt|;
DECL|member|keep_alive
name|FT_Bool
name|keep_alive
decl_stmt|;
DECL|member|memory
name|FT_Memory
name|memory
decl_stmt|;
DECL|member|memory_user
name|FT_Pointer
name|memory_user
decl_stmt|;
DECL|member|alloc
name|FT_Alloc_Func
name|alloc
decl_stmt|;
DECL|member|free
name|FT_Free_Func
name|free
decl_stmt|;
DECL|member|realloc
name|FT_Realloc_Func
name|realloc
decl_stmt|;
block|}
DECL|typedef|FT_MemTableRec
name|FT_MemTableRec
typedef|;
end_typedef
begin_define
DECL|macro|FT_MEM_SIZE_MIN
define|#
directive|define
name|FT_MEM_SIZE_MIN
value|7
end_define
begin_define
DECL|macro|FT_MEM_SIZE_MAX
define|#
directive|define
name|FT_MEM_SIZE_MAX
value|13845163
end_define
begin_define
DECL|macro|FT_FILENAME
define|#
directive|define
name|FT_FILENAME
parameter_list|(
name|x
parameter_list|)
value|((x) ? (x) : "unknown file")
end_define
begin_comment
comment|/*    *  Prime numbers are ugly to handle.  It would be better to implement    *  L-Hashing, which is 10% faster and doesn't require divisions.    */
end_comment
begin_decl_stmt
DECL|variable|ft_mem_primes
specifier|static
specifier|const
name|FT_UInt
name|ft_mem_primes
index|[]
init|=
block|{
literal|7
block|,
literal|11
block|,
literal|19
block|,
literal|37
block|,
literal|73
block|,
literal|109
block|,
literal|163
block|,
literal|251
block|,
literal|367
block|,
literal|557
block|,
literal|823
block|,
literal|1237
block|,
literal|1861
block|,
literal|2777
block|,
literal|4177
block|,
literal|6247
block|,
literal|9371
block|,
literal|14057
block|,
literal|21089
block|,
literal|31627
block|,
literal|47431
block|,
literal|71143
block|,
literal|106721
block|,
literal|160073
block|,
literal|240101
block|,
literal|360163
block|,
literal|540217
block|,
literal|810343
block|,
literal|1215497
block|,
literal|1823231
block|,
literal|2734867
block|,
literal|4102283
block|,
literal|6153409
block|,
literal|9230113
block|,
literal|13845163
block|,   }
decl_stmt|;
end_decl_stmt
begin_function
specifier|static
name|FT_ULong
DECL|function|ft_mem_closest_prime
name|ft_mem_closest_prime
parameter_list|(
name|FT_ULong
name|num
parameter_list|)
block|{
name|FT_UInt
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|ft_mem_primes
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|ft_mem_primes
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ft_mem_primes
index|[
name|i
index|]
operator|>
name|num
condition|)
return|return
name|ft_mem_primes
index|[
name|i
index|]
return|;
return|return
name|FT_MEM_SIZE_MAX
return|;
block|}
end_function
begin_function
specifier|extern
name|void
DECL|function|ft_mem_debug_panic
name|ft_mem_debug_panic
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|printf
argument_list|(
literal|"FreeType.Debug: "
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vprintf
argument_list|(
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|FT_Pointer
DECL|function|ft_mem_table_alloc
name|ft_mem_table_alloc
parameter_list|(
name|FT_MemTable
name|table
parameter_list|,
name|FT_Long
name|size
parameter_list|)
block|{
name|FT_Memory
name|memory
init|=
name|table
operator|->
name|memory
decl_stmt|;
name|FT_Pointer
name|block
decl_stmt|;
name|memory
operator|->
name|user
operator|=
name|table
operator|->
name|memory_user
expr_stmt|;
name|block
operator|=
name|table
operator|->
name|alloc
argument_list|(
name|memory
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|memory
operator|->
name|user
operator|=
name|table
expr_stmt|;
return|return
name|block
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|ft_mem_table_free
name|ft_mem_table_free
parameter_list|(
name|FT_MemTable
name|table
parameter_list|,
name|FT_Pointer
name|block
parameter_list|)
block|{
name|FT_Memory
name|memory
init|=
name|table
operator|->
name|memory
decl_stmt|;
name|memory
operator|->
name|user
operator|=
name|table
operator|->
name|memory_user
expr_stmt|;
name|table
operator|->
name|free
argument_list|(
name|memory
argument_list|,
name|block
argument_list|)
expr_stmt|;
name|memory
operator|->
name|user
operator|=
name|table
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|ft_mem_table_resize
name|ft_mem_table_resize
parameter_list|(
name|FT_MemTable
name|table
parameter_list|)
block|{
name|FT_ULong
name|new_size
decl_stmt|;
name|new_size
operator|=
name|ft_mem_closest_prime
argument_list|(
name|table
operator|->
name|nodes
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_size
operator|!=
name|table
operator|->
name|size
condition|)
block|{
name|FT_MemNode
modifier|*
name|new_buckets
decl_stmt|;
name|FT_ULong
name|i
decl_stmt|;
name|new_buckets
operator|=
operator|(
name|FT_MemNode
operator|*
operator|)
name|ft_mem_table_alloc
argument_list|(
name|table
argument_list|,
name|new_size
operator|*
sizeof|sizeof
argument_list|(
name|FT_MemNode
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_buckets
operator|==
name|NULL
condition|)
return|return;
name|FT_ARRAY_ZERO
argument_list|(
name|new_buckets
argument_list|,
name|new_size
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|table
operator|->
name|size
condition|;
name|i
operator|++
control|)
block|{
name|FT_MemNode
name|node
decl_stmt|,
name|next
decl_stmt|,
modifier|*
name|pnode
decl_stmt|;
name|FT_ULong
name|hash
decl_stmt|;
name|node
operator|=
name|table
operator|->
name|buckets
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
name|node
condition|)
block|{
name|next
operator|=
name|node
operator|->
name|link
expr_stmt|;
name|hash
operator|=
name|FT_MEM_VAL
argument_list|(
name|node
operator|->
name|address
argument_list|)
operator|%
name|new_size
expr_stmt|;
name|pnode
operator|=
name|new_buckets
operator|+
name|hash
expr_stmt|;
name|node
operator|->
name|link
operator|=
name|pnode
index|[
literal|0
index|]
expr_stmt|;
name|pnode
index|[
literal|0
index|]
operator|=
name|node
expr_stmt|;
name|node
operator|=
name|next
expr_stmt|;
block|}
block|}
if|if
condition|(
name|table
operator|->
name|buckets
condition|)
name|ft_mem_table_free
argument_list|(
name|table
argument_list|,
name|table
operator|->
name|buckets
argument_list|)
expr_stmt|;
name|table
operator|->
name|buckets
operator|=
name|new_buckets
expr_stmt|;
name|table
operator|->
name|size
operator|=
name|new_size
expr_stmt|;
block|}
block|}
end_function
begin_function
specifier|static
name|FT_MemTable
DECL|function|ft_mem_table_new
name|ft_mem_table_new
parameter_list|(
name|FT_Memory
name|memory
parameter_list|)
block|{
name|FT_MemTable
name|table
decl_stmt|;
name|table
operator|=
operator|(
name|FT_MemTable
operator|)
name|memory
operator|->
name|alloc
argument_list|(
name|memory
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|table
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|table
operator|==
name|NULL
condition|)
goto|goto
name|Exit
goto|;
name|FT_ZERO
argument_list|(
name|table
argument_list|)
expr_stmt|;
name|table
operator|->
name|size
operator|=
name|FT_MEM_SIZE_MIN
expr_stmt|;
name|table
operator|->
name|nodes
operator|=
literal|0
expr_stmt|;
name|table
operator|->
name|memory
operator|=
name|memory
expr_stmt|;
name|table
operator|->
name|memory_user
operator|=
name|memory
operator|->
name|user
expr_stmt|;
name|table
operator|->
name|alloc
operator|=
name|memory
operator|->
name|alloc
expr_stmt|;
name|table
operator|->
name|realloc
operator|=
name|memory
operator|->
name|realloc
expr_stmt|;
name|table
operator|->
name|free
operator|=
name|memory
operator|->
name|free
expr_stmt|;
name|table
operator|->
name|buckets
operator|=
operator|(
name|FT_MemNode
operator|*
operator|)
name|memory
operator|->
name|alloc
argument_list|(
name|memory
argument_list|,
name|table
operator|->
name|size
operator|*
sizeof|sizeof
argument_list|(
name|FT_MemNode
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|table
operator|->
name|buckets
condition|)
name|FT_ARRAY_ZERO
argument_list|(
name|table
operator|->
name|buckets
argument_list|,
name|table
operator|->
name|size
argument_list|)
expr_stmt|;
else|else
block|{
name|memory
operator|->
name|free
argument_list|(
name|memory
argument_list|,
name|table
argument_list|)
expr_stmt|;
name|table
operator|=
name|NULL
expr_stmt|;
block|}
name|Exit
label|:
return|return
name|table
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|ft_mem_table_destroy
name|ft_mem_table_destroy
parameter_list|(
name|FT_MemTable
name|table
parameter_list|)
block|{
name|FT_ULong
name|i
decl_stmt|;
name|FT_DumpMemory
argument_list|(
name|table
operator|->
name|memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|table
condition|)
block|{
name|FT_Long
name|leak_count
init|=
literal|0
decl_stmt|;
name|FT_ULong
name|leaks
init|=
literal|0
decl_stmt|;
comment|/* remove all blocks from the table, revealing leaked ones */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|table
operator|->
name|size
condition|;
name|i
operator|++
control|)
block|{
name|FT_MemNode
modifier|*
name|pnode
init|=
name|table
operator|->
name|buckets
operator|+
name|i
decl_stmt|,
name|next
decl_stmt|,
name|node
init|=
operator|*
name|pnode
decl_stmt|;
while|while
condition|(
name|node
condition|)
block|{
name|next
operator|=
name|node
operator|->
name|link
expr_stmt|;
name|node
operator|->
name|link
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|size
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"leaked memory block at address %p, size %8ld in (%s:%ld)\n"
argument_list|,
name|node
operator|->
name|address
argument_list|,
name|node
operator|->
name|size
argument_list|,
name|FT_FILENAME
argument_list|(
name|node
operator|->
name|source
operator|->
name|file_name
argument_list|)
argument_list|,
name|node
operator|->
name|source
operator|->
name|line_no
argument_list|)
expr_stmt|;
name|leak_count
operator|++
expr_stmt|;
name|leaks
operator|+=
name|node
operator|->
name|size
expr_stmt|;
name|ft_mem_table_free
argument_list|(
name|table
argument_list|,
name|node
operator|->
name|address
argument_list|)
expr_stmt|;
block|}
name|node
operator|->
name|address
operator|=
name|NULL
expr_stmt|;
name|node
operator|->
name|size
operator|=
literal|0
expr_stmt|;
name|ft_mem_table_free
argument_list|(
name|table
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|node
operator|=
name|next
expr_stmt|;
block|}
name|table
operator|->
name|buckets
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|ft_mem_table_free
argument_list|(
name|table
argument_list|,
name|table
operator|->
name|buckets
argument_list|)
expr_stmt|;
name|table
operator|->
name|buckets
operator|=
name|NULL
expr_stmt|;
name|table
operator|->
name|size
operator|=
literal|0
expr_stmt|;
name|table
operator|->
name|nodes
operator|=
literal|0
expr_stmt|;
comment|/* remove all sources */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FT_MEM_SOURCE_BUCKETS
condition|;
name|i
operator|++
control|)
block|{
name|FT_MemSource
name|source
decl_stmt|,
name|next
decl_stmt|;
for|for
control|(
name|source
operator|=
name|table
operator|->
name|sources
index|[
name|i
index|]
init|;
name|source
operator|!=
name|NULL
condition|;
name|source
operator|=
name|next
control|)
block|{
name|next
operator|=
name|source
operator|->
name|link
expr_stmt|;
name|ft_mem_table_free
argument_list|(
name|table
argument_list|,
name|source
argument_list|)
expr_stmt|;
block|}
name|table
operator|->
name|sources
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"FreeType: total memory allocations = %ld\n"
argument_list|,
name|table
operator|->
name|alloc_total
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"FreeType: maximum memory footprint = %ld\n"
argument_list|,
name|table
operator|->
name|alloc_max
argument_list|)
expr_stmt|;
name|ft_mem_table_free
argument_list|(
name|table
argument_list|,
name|table
argument_list|)
expr_stmt|;
if|if
condition|(
name|leak_count
operator|>
literal|0
condition|)
name|ft_mem_debug_panic
argument_list|(
literal|"FreeType: %ld bytes of memory leaked in %ld blocks\n"
argument_list|,
name|leaks
argument_list|,
name|leak_count
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"FreeType: no memory leaks detected\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
specifier|static
name|FT_MemNode
modifier|*
DECL|function|ft_mem_table_get_nodep
name|ft_mem_table_get_nodep
parameter_list|(
name|FT_MemTable
name|table
parameter_list|,
name|FT_Byte
modifier|*
name|address
parameter_list|)
block|{
name|FT_ULong
name|hash
decl_stmt|;
name|FT_MemNode
modifier|*
name|pnode
decl_stmt|,
name|node
decl_stmt|;
name|hash
operator|=
name|FT_MEM_VAL
argument_list|(
name|address
argument_list|)
expr_stmt|;
name|pnode
operator|=
name|table
operator|->
name|buckets
operator|+
operator|(
name|hash
operator|%
name|table
operator|->
name|size
operator|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|node
operator|=
name|pnode
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|node
condition|)
break|break;
if|if
condition|(
name|node
operator|->
name|address
operator|==
name|address
condition|)
break|break;
name|pnode
operator|=
operator|&
name|node
operator|->
name|link
expr_stmt|;
block|}
return|return
name|pnode
return|;
block|}
end_function
begin_function
specifier|static
name|FT_MemSource
DECL|function|ft_mem_table_get_source
name|ft_mem_table_get_source
parameter_list|(
name|FT_MemTable
name|table
parameter_list|)
block|{
name|FT_UInt32
name|hash
decl_stmt|;
name|FT_MemSource
name|node
decl_stmt|,
modifier|*
name|pnode
decl_stmt|;
comment|/* cast to FT_PtrDist first since void* can be larger */
comment|/* than FT_UInt32 and GCC 4.1.1 emits a warning       */
name|hash
operator|=
operator|(
name|FT_UInt32
operator|)
operator|(
name|FT_PtrDist
operator|)
operator|(
name|void
operator|*
operator|)
name|_ft_debug_file
operator|+
call|(
name|FT_UInt32
call|)
argument_list|(
literal|5
operator|*
name|_ft_debug_lineno
argument_list|)
expr_stmt|;
name|pnode
operator|=
operator|&
name|table
operator|->
name|sources
index|[
name|hash
operator|%
name|FT_MEM_SOURCE_BUCKETS
index|]
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|node
operator|=
operator|*
name|pnode
expr_stmt|;
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|node
operator|->
name|file_name
operator|==
name|_ft_debug_file
operator|&&
name|node
operator|->
name|line_no
operator|==
name|_ft_debug_lineno
condition|)
goto|goto
name|Exit
goto|;
name|pnode
operator|=
operator|&
name|node
operator|->
name|link
expr_stmt|;
block|}
name|node
operator|=
operator|(
name|FT_MemSource
operator|)
name|ft_mem_table_alloc
argument_list|(
name|table
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|node
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
name|ft_mem_debug_panic
argument_list|(
literal|"not enough memory to perform memory debugging\n"
argument_list|)
expr_stmt|;
name|node
operator|->
name|file_name
operator|=
name|_ft_debug_file
expr_stmt|;
name|node
operator|->
name|line_no
operator|=
name|_ft_debug_lineno
expr_stmt|;
name|node
operator|->
name|cur_blocks
operator|=
literal|0
expr_stmt|;
name|node
operator|->
name|max_blocks
operator|=
literal|0
expr_stmt|;
name|node
operator|->
name|all_blocks
operator|=
literal|0
expr_stmt|;
name|node
operator|->
name|cur_size
operator|=
literal|0
expr_stmt|;
name|node
operator|->
name|max_size
operator|=
literal|0
expr_stmt|;
name|node
operator|->
name|all_size
operator|=
literal|0
expr_stmt|;
name|node
operator|->
name|cur_max
operator|=
literal|0
expr_stmt|;
name|node
operator|->
name|link
operator|=
name|NULL
expr_stmt|;
name|node
operator|->
name|hash
operator|=
name|hash
expr_stmt|;
operator|*
name|pnode
operator|=
name|node
expr_stmt|;
name|Exit
label|:
return|return
name|node
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|ft_mem_table_set
name|ft_mem_table_set
parameter_list|(
name|FT_MemTable
name|table
parameter_list|,
name|FT_Byte
modifier|*
name|address
parameter_list|,
name|FT_ULong
name|size
parameter_list|,
name|FT_Long
name|delta
parameter_list|)
block|{
name|FT_MemNode
modifier|*
name|pnode
decl_stmt|,
name|node
decl_stmt|;
if|if
condition|(
name|table
condition|)
block|{
name|FT_MemSource
name|source
decl_stmt|;
name|pnode
operator|=
name|ft_mem_table_get_nodep
argument_list|(
name|table
argument_list|,
name|address
argument_list|)
expr_stmt|;
name|node
operator|=
operator|*
name|pnode
expr_stmt|;
if|if
condition|(
name|node
condition|)
block|{
if|if
condition|(
name|node
operator|->
name|size
operator|<
literal|0
condition|)
block|{
comment|/* This block was already freed.  Our memory is now completely */
comment|/* corrupted!                                                  */
comment|/* This can only happen in keep-alive mode.                    */
name|ft_mem_debug_panic
argument_list|(
literal|"memory heap corrupted (allocating freed block)"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This block was already allocated.  This means that our memory */
comment|/* is also corrupted!                                            */
name|ft_mem_debug_panic
argument_list|(
literal|"memory heap corrupted (re-allocating allocated block at"
literal|" %p, of size %ld)\n"
literal|"org=%s:%d new=%s:%d\n"
argument_list|,
name|node
operator|->
name|address
argument_list|,
name|node
operator|->
name|size
argument_list|,
name|FT_FILENAME
argument_list|(
name|node
operator|->
name|source
operator|->
name|file_name
argument_list|)
argument_list|,
name|node
operator|->
name|source
operator|->
name|line_no
argument_list|,
name|FT_FILENAME
argument_list|(
name|_ft_debug_file
argument_list|)
argument_list|,
name|_ft_debug_lineno
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* we need to create a new node in this table */
name|node
operator|=
operator|(
name|FT_MemNode
operator|)
name|ft_mem_table_alloc
argument_list|(
name|table
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|node
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
name|ft_mem_debug_panic
argument_list|(
literal|"not enough memory to run memory tests"
argument_list|)
expr_stmt|;
name|node
operator|->
name|address
operator|=
name|address
expr_stmt|;
name|node
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|node
operator|->
name|source
operator|=
name|source
operator|=
name|ft_mem_table_get_source
argument_list|(
name|table
argument_list|)
expr_stmt|;
if|if
condition|(
name|delta
operator|==
literal|0
condition|)
block|{
comment|/* this is an allocation */
name|source
operator|->
name|all_blocks
operator|++
expr_stmt|;
name|source
operator|->
name|cur_blocks
operator|++
expr_stmt|;
if|if
condition|(
name|source
operator|->
name|cur_blocks
operator|>
name|source
operator|->
name|max_blocks
condition|)
name|source
operator|->
name|max_blocks
operator|=
name|source
operator|->
name|cur_blocks
expr_stmt|;
block|}
if|if
condition|(
name|size
operator|>
operator|(
name|FT_ULong
operator|)
name|source
operator|->
name|cur_max
condition|)
name|source
operator|->
name|cur_max
operator|=
name|size
expr_stmt|;
if|if
condition|(
name|delta
operator|!=
literal|0
condition|)
block|{
comment|/* we are growing or shrinking a reallocated block */
name|source
operator|->
name|cur_size
operator|+=
name|delta
expr_stmt|;
name|table
operator|->
name|alloc_current
operator|+=
name|delta
expr_stmt|;
block|}
else|else
block|{
comment|/* we are allocating a new block */
name|source
operator|->
name|cur_size
operator|+=
name|size
expr_stmt|;
name|table
operator|->
name|alloc_current
operator|+=
name|size
expr_stmt|;
block|}
name|source
operator|->
name|all_size
operator|+=
name|size
expr_stmt|;
if|if
condition|(
name|source
operator|->
name|cur_size
operator|>
name|source
operator|->
name|max_size
condition|)
name|source
operator|->
name|max_size
operator|=
name|source
operator|->
name|cur_size
expr_stmt|;
name|node
operator|->
name|free_file_name
operator|=
name|NULL
expr_stmt|;
name|node
operator|->
name|free_line_no
operator|=
literal|0
expr_stmt|;
name|node
operator|->
name|link
operator|=
name|pnode
index|[
literal|0
index|]
expr_stmt|;
name|pnode
index|[
literal|0
index|]
operator|=
name|node
expr_stmt|;
name|table
operator|->
name|nodes
operator|++
expr_stmt|;
name|table
operator|->
name|alloc_total
operator|+=
name|size
expr_stmt|;
if|if
condition|(
name|table
operator|->
name|alloc_current
operator|>
name|table
operator|->
name|alloc_max
condition|)
name|table
operator|->
name|alloc_max
operator|=
name|table
operator|->
name|alloc_current
expr_stmt|;
if|if
condition|(
name|table
operator|->
name|nodes
operator|*
literal|3
operator|<
name|table
operator|->
name|size
operator|||
name|table
operator|->
name|size
operator|*
literal|3
operator|<
name|table
operator|->
name|nodes
condition|)
name|ft_mem_table_resize
argument_list|(
name|table
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|ft_mem_table_remove
name|ft_mem_table_remove
parameter_list|(
name|FT_MemTable
name|table
parameter_list|,
name|FT_Byte
modifier|*
name|address
parameter_list|,
name|FT_Long
name|delta
parameter_list|)
block|{
if|if
condition|(
name|table
condition|)
block|{
name|FT_MemNode
modifier|*
name|pnode
decl_stmt|,
name|node
decl_stmt|;
name|pnode
operator|=
name|ft_mem_table_get_nodep
argument_list|(
name|table
argument_list|,
name|address
argument_list|)
expr_stmt|;
name|node
operator|=
operator|*
name|pnode
expr_stmt|;
if|if
condition|(
name|node
condition|)
block|{
name|FT_MemSource
name|source
decl_stmt|;
if|if
condition|(
name|node
operator|->
name|size
operator|<
literal|0
condition|)
name|ft_mem_debug_panic
argument_list|(
literal|"freeing memory block at %p more than once at (%s:%ld)\n"
literal|"block allocated at (%s:%ld) and released at (%s:%ld)"
argument_list|,
name|address
argument_list|,
name|FT_FILENAME
argument_list|(
name|_ft_debug_file
argument_list|)
argument_list|,
name|_ft_debug_lineno
argument_list|,
name|FT_FILENAME
argument_list|(
name|node
operator|->
name|source
operator|->
name|file_name
argument_list|)
argument_list|,
name|node
operator|->
name|source
operator|->
name|line_no
argument_list|,
name|FT_FILENAME
argument_list|(
name|node
operator|->
name|free_file_name
argument_list|)
argument_list|,
name|node
operator|->
name|free_line_no
argument_list|)
expr_stmt|;
comment|/* scramble the node's content for additional safety */
name|FT_MEM_SET
argument_list|(
name|address
argument_list|,
literal|0xF3
argument_list|,
name|node
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|delta
operator|==
literal|0
condition|)
block|{
name|source
operator|=
name|node
operator|->
name|source
expr_stmt|;
name|source
operator|->
name|cur_blocks
operator|--
expr_stmt|;
name|source
operator|->
name|cur_size
operator|-=
name|node
operator|->
name|size
expr_stmt|;
name|table
operator|->
name|alloc_current
operator|-=
name|node
operator|->
name|size
expr_stmt|;
block|}
if|if
condition|(
name|table
operator|->
name|keep_alive
condition|)
block|{
comment|/* we simply invert the node's size to indicate that the node */
comment|/* was freed.                                                 */
name|node
operator|->
name|size
operator|=
operator|-
name|node
operator|->
name|size
expr_stmt|;
name|node
operator|->
name|free_file_name
operator|=
name|_ft_debug_file
expr_stmt|;
name|node
operator|->
name|free_line_no
operator|=
name|_ft_debug_lineno
expr_stmt|;
block|}
else|else
block|{
name|table
operator|->
name|nodes
operator|--
expr_stmt|;
operator|*
name|pnode
operator|=
name|node
operator|->
name|link
expr_stmt|;
name|node
operator|->
name|size
operator|=
literal|0
expr_stmt|;
name|node
operator|->
name|source
operator|=
name|NULL
expr_stmt|;
name|ft_mem_table_free
argument_list|(
name|table
argument_list|,
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|table
operator|->
name|nodes
operator|*
literal|3
operator|<
name|table
operator|->
name|size
operator|||
name|table
operator|->
name|size
operator|*
literal|3
operator|<
name|table
operator|->
name|nodes
condition|)
name|ft_mem_table_resize
argument_list|(
name|table
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|ft_mem_debug_panic
argument_list|(
literal|"trying to free unknown block at %p in (%s:%ld)\n"
argument_list|,
name|address
argument_list|,
name|FT_FILENAME
argument_list|(
name|_ft_debug_file
argument_list|)
argument_list|,
name|_ft_debug_lineno
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
specifier|extern
name|FT_Pointer
DECL|function|ft_mem_debug_alloc
name|ft_mem_debug_alloc
parameter_list|(
name|FT_Memory
name|memory
parameter_list|,
name|FT_Long
name|size
parameter_list|)
block|{
name|FT_MemTable
name|table
init|=
operator|(
name|FT_MemTable
operator|)
name|memory
operator|->
name|user
decl_stmt|;
name|FT_Byte
modifier|*
name|block
decl_stmt|;
if|if
condition|(
name|size
operator|<=
literal|0
condition|)
name|ft_mem_debug_panic
argument_list|(
literal|"negative block size allocation (%ld)"
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* return NULL if the maximum number of allocations was reached */
if|if
condition|(
name|table
operator|->
name|bound_count
operator|&&
name|table
operator|->
name|alloc_count
operator|>=
name|table
operator|->
name|alloc_count_max
condition|)
return|return
name|NULL
return|;
comment|/* return NULL if this allocation would overflow the maximum heap size */
if|if
condition|(
name|table
operator|->
name|bound_total
operator|&&
name|table
operator|->
name|alloc_total_max
operator|-
name|table
operator|->
name|alloc_current
operator|>
operator|(
name|FT_ULong
operator|)
name|size
condition|)
return|return
name|NULL
return|;
name|block
operator|=
operator|(
name|FT_Byte
operator|*
operator|)
name|ft_mem_table_alloc
argument_list|(
name|table
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|block
condition|)
block|{
name|ft_mem_table_set
argument_list|(
name|table
argument_list|,
name|block
argument_list|,
operator|(
name|FT_ULong
operator|)
name|size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|table
operator|->
name|alloc_count
operator|++
expr_stmt|;
block|}
name|_ft_debug_file
operator|=
literal|"<unknown>"
expr_stmt|;
name|_ft_debug_lineno
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|FT_Pointer
operator|)
name|block
return|;
block|}
end_function
begin_function
specifier|extern
name|void
DECL|function|ft_mem_debug_free
name|ft_mem_debug_free
parameter_list|(
name|FT_Memory
name|memory
parameter_list|,
name|FT_Pointer
name|block
parameter_list|)
block|{
name|FT_MemTable
name|table
init|=
operator|(
name|FT_MemTable
operator|)
name|memory
operator|->
name|user
decl_stmt|;
if|if
condition|(
name|block
operator|==
name|NULL
condition|)
name|ft_mem_debug_panic
argument_list|(
literal|"trying to free NULL in (%s:%ld)"
argument_list|,
name|FT_FILENAME
argument_list|(
name|_ft_debug_file
argument_list|)
argument_list|,
name|_ft_debug_lineno
argument_list|)
expr_stmt|;
name|ft_mem_table_remove
argument_list|(
name|table
argument_list|,
operator|(
name|FT_Byte
operator|*
operator|)
name|block
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|table
operator|->
name|keep_alive
condition|)
name|ft_mem_table_free
argument_list|(
name|table
argument_list|,
name|block
argument_list|)
expr_stmt|;
name|table
operator|->
name|alloc_count
operator|--
expr_stmt|;
name|_ft_debug_file
operator|=
literal|"<unknown>"
expr_stmt|;
name|_ft_debug_lineno
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_function
specifier|extern
name|FT_Pointer
DECL|function|ft_mem_debug_realloc
name|ft_mem_debug_realloc
parameter_list|(
name|FT_Memory
name|memory
parameter_list|,
name|FT_Long
name|cur_size
parameter_list|,
name|FT_Long
name|new_size
parameter_list|,
name|FT_Pointer
name|block
parameter_list|)
block|{
name|FT_MemTable
name|table
init|=
operator|(
name|FT_MemTable
operator|)
name|memory
operator|->
name|user
decl_stmt|;
name|FT_MemNode
name|node
decl_stmt|,
modifier|*
name|pnode
decl_stmt|;
name|FT_Pointer
name|new_block
decl_stmt|;
name|FT_Long
name|delta
decl_stmt|;
specifier|const
name|char
modifier|*
name|file_name
init|=
name|FT_FILENAME
argument_list|(
name|_ft_debug_file
argument_list|)
decl_stmt|;
name|FT_Long
name|line_no
init|=
name|_ft_debug_lineno
decl_stmt|;
comment|/* unlikely, but possible */
if|if
condition|(
name|new_size
operator|==
name|cur_size
condition|)
return|return
name|block
return|;
comment|/* the following is valid according to ANSI C */
if|#
directive|if
literal|0
block|if ( block == NULL || cur_size == 0 )       ft_mem_debug_panic( "trying to reallocate NULL in (%s:%ld)",                           file_name, line_no );
endif|#
directive|endif
comment|/* while the following is allowed in ANSI C also, we abort since */
comment|/* such case should be handled by FreeType.                      */
if|if
condition|(
name|new_size
operator|<=
literal|0
condition|)
name|ft_mem_debug_panic
argument_list|(
literal|"trying to reallocate %p to size 0 (current is %ld) in (%s:%ld)"
argument_list|,
name|block
argument_list|,
name|cur_size
argument_list|,
name|file_name
argument_list|,
name|line_no
argument_list|)
expr_stmt|;
comment|/* check `cur_size' value */
name|pnode
operator|=
name|ft_mem_table_get_nodep
argument_list|(
name|table
argument_list|,
operator|(
name|FT_Byte
operator|*
operator|)
name|block
argument_list|)
expr_stmt|;
name|node
operator|=
operator|*
name|pnode
expr_stmt|;
if|if
condition|(
operator|!
name|node
condition|)
name|ft_mem_debug_panic
argument_list|(
literal|"trying to reallocate unknown block at %p in (%s:%ld)"
argument_list|,
name|block
argument_list|,
name|file_name
argument_list|,
name|line_no
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|size
operator|<=
literal|0
condition|)
name|ft_mem_debug_panic
argument_list|(
literal|"trying to reallocate freed block at %p in (%s:%ld)"
argument_list|,
name|block
argument_list|,
name|file_name
argument_list|,
name|line_no
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|size
operator|!=
name|cur_size
condition|)
name|ft_mem_debug_panic
argument_list|(
literal|"invalid ft_realloc request for %p. cur_size is "
literal|"%ld instead of %ld in (%s:%ld)"
argument_list|,
name|block
argument_list|,
name|cur_size
argument_list|,
name|node
operator|->
name|size
argument_list|,
name|file_name
argument_list|,
name|line_no
argument_list|)
expr_stmt|;
comment|/* return NULL if the maximum number of allocations was reached */
if|if
condition|(
name|table
operator|->
name|bound_count
operator|&&
name|table
operator|->
name|alloc_count
operator|>=
name|table
operator|->
name|alloc_count_max
condition|)
return|return
name|NULL
return|;
name|delta
operator|=
call|(
name|FT_Long
call|)
argument_list|(
name|new_size
operator|-
name|cur_size
argument_list|)
expr_stmt|;
comment|/* return NULL if this allocation would overflow the maximum heap size */
if|if
condition|(
name|delta
operator|>
literal|0
operator|&&
name|table
operator|->
name|bound_total
operator|&&
name|table
operator|->
name|alloc_current
operator|+
operator|(
name|FT_ULong
operator|)
name|delta
operator|>
name|table
operator|->
name|alloc_total_max
condition|)
return|return
name|NULL
return|;
name|new_block
operator|=
operator|(
name|FT_Byte
operator|*
operator|)
name|ft_mem_table_alloc
argument_list|(
name|table
argument_list|,
name|new_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_block
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|ft_mem_table_set
argument_list|(
name|table
argument_list|,
operator|(
name|FT_Byte
operator|*
operator|)
name|new_block
argument_list|,
name|new_size
argument_list|,
name|delta
argument_list|)
expr_stmt|;
name|ft_memcpy
argument_list|(
name|new_block
argument_list|,
name|block
argument_list|,
name|cur_size
operator|<
name|new_size
condition|?
name|cur_size
else|:
name|new_size
argument_list|)
expr_stmt|;
name|ft_mem_table_remove
argument_list|(
name|table
argument_list|,
operator|(
name|FT_Byte
operator|*
operator|)
name|block
argument_list|,
name|delta
argument_list|)
expr_stmt|;
name|_ft_debug_file
operator|=
literal|"<unknown>"
expr_stmt|;
name|_ft_debug_lineno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|table
operator|->
name|keep_alive
condition|)
name|ft_mem_table_free
argument_list|(
name|table
argument_list|,
name|block
argument_list|)
expr_stmt|;
return|return
name|new_block
return|;
block|}
end_function
begin_function
specifier|extern
name|FT_Int
DECL|function|ft_mem_debug_init
name|ft_mem_debug_init
parameter_list|(
name|FT_Memory
name|memory
parameter_list|)
block|{
name|FT_MemTable
name|table
decl_stmt|;
name|FT_Int
name|result
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|getenv
argument_list|(
literal|"FT2_DEBUG_MEMORY"
argument_list|)
condition|)
block|{
name|table
operator|=
name|ft_mem_table_new
argument_list|(
name|memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|table
condition|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|memory
operator|->
name|user
operator|=
name|table
expr_stmt|;
name|memory
operator|->
name|alloc
operator|=
name|ft_mem_debug_alloc
expr_stmt|;
name|memory
operator|->
name|realloc
operator|=
name|ft_mem_debug_realloc
expr_stmt|;
name|memory
operator|->
name|free
operator|=
name|ft_mem_debug_free
expr_stmt|;
name|p
operator|=
name|getenv
argument_list|(
literal|"FT2_ALLOC_TOTAL_MAX"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|FT_Long
name|total_max
init|=
name|ft_atol
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|total_max
operator|>
literal|0
condition|)
block|{
name|table
operator|->
name|bound_total
operator|=
literal|1
expr_stmt|;
name|table
operator|->
name|alloc_total_max
operator|=
operator|(
name|FT_ULong
operator|)
name|total_max
expr_stmt|;
block|}
block|}
name|p
operator|=
name|getenv
argument_list|(
literal|"FT2_ALLOC_COUNT_MAX"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|FT_Long
name|total_count
init|=
name|ft_atol
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|total_count
operator|>
literal|0
condition|)
block|{
name|table
operator|->
name|bound_count
operator|=
literal|1
expr_stmt|;
name|table
operator|->
name|alloc_count_max
operator|=
operator|(
name|FT_ULong
operator|)
name|total_count
expr_stmt|;
block|}
block|}
name|p
operator|=
name|getenv
argument_list|(
literal|"FT2_KEEP_ALIVE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|FT_Long
name|keep_alive
init|=
name|ft_atol
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|keep_alive
operator|>
literal|0
condition|)
name|table
operator|->
name|keep_alive
operator|=
literal|1
expr_stmt|;
block|}
name|result
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function
begin_function
specifier|extern
name|void
DECL|function|ft_mem_debug_done
name|ft_mem_debug_done
parameter_list|(
name|FT_Memory
name|memory
parameter_list|)
block|{
name|FT_MemTable
name|table
init|=
operator|(
name|FT_MemTable
operator|)
name|memory
operator|->
name|user
decl_stmt|;
if|if
condition|(
name|table
condition|)
block|{
name|memory
operator|->
name|free
operator|=
name|table
operator|->
name|free
expr_stmt|;
name|memory
operator|->
name|realloc
operator|=
name|table
operator|->
name|realloc
expr_stmt|;
name|memory
operator|->
name|alloc
operator|=
name|table
operator|->
name|alloc
expr_stmt|;
name|ft_mem_table_destroy
argument_list|(
name|table
argument_list|)
expr_stmt|;
name|memory
operator|->
name|user
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|ft_mem_source_compare
name|ft_mem_source_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|p1
parameter_list|,
specifier|const
name|void
modifier|*
name|p2
parameter_list|)
block|{
name|FT_MemSource
name|s1
init|=
operator|*
operator|(
name|FT_MemSource
operator|*
operator|)
name|p1
decl_stmt|;
name|FT_MemSource
name|s2
init|=
operator|*
operator|(
name|FT_MemSource
operator|*
operator|)
name|p2
decl_stmt|;
if|if
condition|(
name|s2
operator|->
name|max_size
operator|>
name|s1
operator|->
name|max_size
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|s2
operator|->
name|max_size
operator|<
name|s1
operator|->
name|max_size
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function
begin_function
specifier|extern
name|void
DECL|function|FT_DumpMemory
name|FT_DumpMemory
parameter_list|(
name|FT_Memory
name|memory
parameter_list|)
block|{
name|FT_MemTable
name|table
init|=
operator|(
name|FT_MemTable
operator|)
name|memory
operator|->
name|user
decl_stmt|;
if|if
condition|(
name|table
condition|)
block|{
name|FT_MemSource
modifier|*
name|bucket
init|=
name|table
operator|->
name|sources
decl_stmt|;
name|FT_MemSource
modifier|*
name|limit
init|=
name|bucket
operator|+
name|FT_MEM_SOURCE_BUCKETS
decl_stmt|;
name|FT_MemSource
modifier|*
name|sources
decl_stmt|;
name|FT_UInt
name|nn
decl_stmt|,
name|count
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|bucket
operator|<
name|limit
condition|;
name|bucket
operator|++
control|)
block|{
name|FT_MemSource
name|source
init|=
operator|*
name|bucket
decl_stmt|;
for|for
control|(
init|;
name|source
condition|;
name|source
operator|=
name|source
operator|->
name|link
control|)
name|count
operator|++
expr_stmt|;
block|}
name|sources
operator|=
operator|(
name|FT_MemSource
operator|*
operator|)
name|ft_mem_table_alloc
argument_list|(
name|table
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sources
argument_list|)
operator|*
name|count
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|bucket
operator|=
name|table
operator|->
name|sources
init|;
name|bucket
operator|<
name|limit
condition|;
name|bucket
operator|++
control|)
block|{
name|FT_MemSource
name|source
init|=
operator|*
name|bucket
decl_stmt|;
for|for
control|(
init|;
name|source
condition|;
name|source
operator|=
name|source
operator|->
name|link
control|)
name|sources
index|[
name|count
operator|++
index|]
operator|=
name|source
expr_stmt|;
block|}
name|ft_qsort
argument_list|(
name|sources
argument_list|,
name|count
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sources
argument_list|)
argument_list|,
name|ft_mem_source_compare
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"FreeType Memory Dump: "
literal|"current=%ld max=%ld total=%ld count=%ld\n"
argument_list|,
name|table
operator|->
name|alloc_current
argument_list|,
name|table
operator|->
name|alloc_max
argument_list|,
name|table
operator|->
name|alloc_total
argument_list|,
name|table
operator|->
name|alloc_count
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" block  block    sizes    sizes    sizes   source\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" count   high      sum  highsum      max   location\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"-------------------------------------------------\n"
argument_list|)
expr_stmt|;
name|fmt
operator|=
literal|"%6ld %6ld %8ld %8ld %8ld %s:%d\n"
expr_stmt|;
for|for
control|(
name|nn
operator|=
literal|0
init|;
name|nn
operator|<
name|count
condition|;
name|nn
operator|++
control|)
block|{
name|FT_MemSource
name|source
init|=
name|sources
index|[
name|nn
index|]
decl_stmt|;
name|printf
argument_list|(
name|fmt
argument_list|,
name|source
operator|->
name|cur_blocks
argument_list|,
name|source
operator|->
name|max_blocks
argument_list|,
name|source
operator|->
name|cur_size
argument_list|,
name|source
operator|->
name|max_size
argument_list|,
name|source
operator|->
name|cur_max
argument_list|,
name|FT_FILENAME
argument_list|(
name|source
operator|->
name|file_name
argument_list|)
argument_list|,
name|source
operator|->
name|line_no
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"------------------------------------------------\n"
argument_list|)
expr_stmt|;
name|ft_mem_table_free
argument_list|(
name|table
argument_list|,
name|sources
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* !FT_DEBUG_MEMORY */
end_comment
begin_comment
comment|/* ANSI C doesn't like empty source files */
end_comment
begin_typedef
DECL|typedef|_debug_mem_dummy
typedef|typedef
name|int
name|_debug_mem_dummy
typedef|;
end_typedef
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* !FT_DEBUG_MEMORY */
end_comment
begin_comment
comment|/* END */
end_comment
end_unit
