begin_unit
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  ftutil.c                                                               */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*    FreeType utility file for memory and list management (body).         */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  Copyright 2002, 2004-2007, 2013 by                                     */
end_comment
begin_comment
comment|/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  This file is part of the FreeType project, and may only be used,       */
end_comment
begin_comment
comment|/*  modified, and distributed under the terms of the FreeType project      */
end_comment
begin_comment
comment|/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
end_comment
begin_comment
comment|/*  this file you indicate that you have read the license and              */
end_comment
begin_comment
comment|/*  understand and accept it fully.                                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<ft2build.h>
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_DEBUG_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_MEMORY_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_OBJECTS_H
end_include
begin_include
include|#
directive|include
include|FT_LIST_H
end_include
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
end_comment
begin_comment
comment|/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
end_comment
begin_comment
comment|/* messages during execution.                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_undef
DECL|macro|FT_COMPONENT
undef|#
directive|undef
name|FT_COMPONENT
end_undef
begin_define
DECL|macro|FT_COMPONENT
define|#
directive|define
name|FT_COMPONENT
value|trace_memory
end_define
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****               M E M O R Y   M A N A G E M E N T               *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_macro
DECL|function|FT_BASE_DEF
name|FT_BASE_DEF
argument_list|(
argument|FT_Pointer
argument_list|)
end_macro
begin_macro
name|ft_mem_alloc
argument_list|(
argument|FT_Memory  memory
argument_list|,
argument|FT_Long    size
argument_list|,
argument|FT_Error  *p_error
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
decl_stmt|;
name|FT_Pointer
name|block
init|=
name|ft_mem_qalloc
argument_list|(
name|memory
argument_list|,
name|size
argument_list|,
operator|&
name|error
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
name|size
operator|>
literal|0
condition|)
name|FT_MEM_ZERO
argument_list|(
name|block
argument_list|,
name|size
argument_list|)
expr_stmt|;
operator|*
name|p_error
operator|=
name|error
expr_stmt|;
return|return
name|block
return|;
block|}
end_block
begin_macro
DECL|function|FT_BASE_DEF
name|FT_BASE_DEF
argument_list|(
argument|FT_Pointer
argument_list|)
end_macro
begin_macro
name|ft_mem_qalloc
argument_list|(
argument|FT_Memory  memory
argument_list|,
argument|FT_Long    size
argument_list|,
argument|FT_Error  *p_error
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
name|FT_Pointer
name|block
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|size
operator|>
literal|0
condition|)
block|{
name|block
operator|=
name|memory
operator|->
name|alloc
argument_list|(
name|memory
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|block
operator|==
name|NULL
condition|)
name|error
operator|=
name|FT_THROW
argument_list|(
name|Out_Of_Memory
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size
operator|<
literal|0
condition|)
block|{
comment|/* may help catch/prevent security issues */
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Argument
argument_list|)
expr_stmt|;
block|}
operator|*
name|p_error
operator|=
name|error
expr_stmt|;
return|return
name|block
return|;
block|}
end_block
begin_macro
DECL|function|FT_BASE_DEF
name|FT_BASE_DEF
argument_list|(
argument|FT_Pointer
argument_list|)
end_macro
begin_macro
name|ft_mem_realloc
argument_list|(
argument|FT_Memory  memory
argument_list|,
argument|FT_Long    item_size
argument_list|,
argument|FT_Long    cur_count
argument_list|,
argument|FT_Long    new_count
argument_list|,
argument|void*      block
argument_list|,
argument|FT_Error  *p_error
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
name|block
operator|=
name|ft_mem_qrealloc
argument_list|(
name|memory
argument_list|,
name|item_size
argument_list|,
name|cur_count
argument_list|,
name|new_count
argument_list|,
name|block
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
name|new_count
operator|>
name|cur_count
condition|)
name|FT_MEM_ZERO
argument_list|(
operator|(
name|char
operator|*
operator|)
name|block
operator|+
name|cur_count
operator|*
name|item_size
argument_list|,
operator|(
name|new_count
operator|-
name|cur_count
operator|)
operator|*
name|item_size
argument_list|)
expr_stmt|;
operator|*
name|p_error
operator|=
name|error
expr_stmt|;
return|return
name|block
return|;
block|}
end_block
begin_macro
DECL|function|FT_BASE_DEF
name|FT_BASE_DEF
argument_list|(
argument|FT_Pointer
argument_list|)
end_macro
begin_macro
name|ft_mem_qrealloc
argument_list|(
argument|FT_Memory  memory
argument_list|,
argument|FT_Long    item_size
argument_list|,
argument|FT_Long    cur_count
argument_list|,
argument|FT_Long    new_count
argument_list|,
argument|void*      block
argument_list|,
argument|FT_Error  *p_error
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
comment|/* Note that we now accept `item_size == 0' as a valid parameter, in      * order to cover very weird cases where an ALLOC_MULT macro would be      * called.      */
if|if
condition|(
name|cur_count
operator|<
literal|0
operator|||
name|new_count
operator|<
literal|0
operator|||
name|item_size
operator|<
literal|0
condition|)
block|{
comment|/* may help catch/prevent nasty security issues */
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Argument
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|new_count
operator|==
literal|0
operator|||
name|item_size
operator|==
literal|0
condition|)
block|{
name|ft_mem_free
argument_list|(
name|memory
argument_list|,
name|block
argument_list|)
expr_stmt|;
name|block
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|new_count
operator|>
name|FT_INT_MAX
operator|/
name|item_size
condition|)
block|{
name|error
operator|=
name|FT_THROW
argument_list|(
name|Array_Too_Large
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cur_count
operator|==
literal|0
condition|)
block|{
name|FT_ASSERT
argument_list|(
name|block
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|block
operator|=
name|ft_mem_alloc
argument_list|(
name|memory
argument_list|,
name|new_count
operator|*
name|item_size
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|FT_Pointer
name|block2
decl_stmt|;
name|FT_Long
name|cur_size
init|=
name|cur_count
operator|*
name|item_size
decl_stmt|;
name|FT_Long
name|new_size
init|=
name|new_count
operator|*
name|item_size
decl_stmt|;
name|block2
operator|=
name|memory
operator|->
name|realloc
argument_list|(
name|memory
argument_list|,
name|cur_size
argument_list|,
name|new_size
argument_list|,
name|block
argument_list|)
expr_stmt|;
if|if
condition|(
name|block2
operator|==
name|NULL
condition|)
name|error
operator|=
name|FT_THROW
argument_list|(
name|Out_Of_Memory
argument_list|)
expr_stmt|;
else|else
name|block
operator|=
name|block2
expr_stmt|;
block|}
operator|*
name|p_error
operator|=
name|error
expr_stmt|;
return|return
name|block
return|;
block|}
end_block
begin_macro
name|FT_BASE_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|ft_mem_free
name|ft_mem_free
argument_list|(
argument|FT_Memory   memory
argument_list|,
argument|const void *P
argument_list|)
end_macro
begin_block
block|{
if|if
condition|(
name|P
condition|)
name|memory
operator|->
name|free
argument_list|(
name|memory
argument_list|,
operator|(
name|void
operator|*
operator|)
name|P
argument_list|)
expr_stmt|;
block|}
end_block
begin_macro
DECL|function|FT_BASE_DEF
name|FT_BASE_DEF
argument_list|(
argument|FT_Pointer
argument_list|)
end_macro
begin_macro
name|ft_mem_dup
argument_list|(
argument|FT_Memory    memory
argument_list|,
argument|const void*  address
argument_list|,
argument|FT_ULong     size
argument_list|,
argument|FT_Error    *p_error
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
decl_stmt|;
name|FT_Pointer
name|p
init|=
name|ft_mem_qalloc
argument_list|(
name|memory
argument_list|,
name|size
argument_list|,
operator|&
name|error
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
name|address
condition|)
name|ft_memcpy
argument_list|(
name|p
argument_list|,
name|address
argument_list|,
name|size
argument_list|)
expr_stmt|;
operator|*
name|p_error
operator|=
name|error
expr_stmt|;
return|return
name|p
return|;
block|}
end_block
begin_macro
DECL|function|FT_BASE_DEF
name|FT_BASE_DEF
argument_list|(
argument|FT_Pointer
argument_list|)
end_macro
begin_macro
name|ft_mem_strdup
argument_list|(
argument|FT_Memory    memory
argument_list|,
argument|const char*  str
argument_list|,
argument|FT_Error    *p_error
argument_list|)
end_macro
begin_block
block|{
name|FT_ULong
name|len
init|=
name|str
condition|?
operator|(
name|FT_ULong
operator|)
name|ft_strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
else|:
literal|0
decl_stmt|;
return|return
name|ft_mem_dup
argument_list|(
name|memory
argument_list|,
name|str
argument_list|,
name|len
argument_list|,
name|p_error
argument_list|)
return|;
block|}
end_block
begin_macro
DECL|function|FT_BASE_DEF
name|FT_BASE_DEF
argument_list|(
argument|FT_Int
argument_list|)
end_macro
begin_macro
name|ft_mem_strcpyn
argument_list|(
argument|char*        dst
argument_list|,
argument|const char*  src
argument_list|,
argument|FT_ULong     size
argument_list|)
end_macro
begin_block
block|{
while|while
condition|(
name|size
operator|>
literal|1
operator|&&
operator|*
name|src
operator|!=
literal|0
condition|)
block|{
operator|*
name|dst
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
name|size
operator|--
expr_stmt|;
block|}
operator|*
name|dst
operator|=
literal|0
expr_stmt|;
comment|/* always zero-terminate */
return|return
operator|*
name|src
operator|!=
literal|0
return|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****            D O U B L Y   L I N K E D   L I S T S              *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_undef
DECL|macro|FT_COMPONENT
undef|#
directive|undef
name|FT_COMPONENT
end_undef
begin_define
DECL|macro|FT_COMPONENT
define|#
directive|define
name|FT_COMPONENT
value|trace_list
end_define
begin_comment
comment|/* documentation is in ftlist.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_ListNode
argument_list|)
end_macro
begin_macro
name|FT_List_Find
argument_list|(
argument|FT_List  list
argument_list|,
argument|void*    data
argument_list|)
end_macro
begin_block
block|{
name|FT_ListNode
name|cur
decl_stmt|;
if|if
condition|(
operator|!
name|list
condition|)
return|return
name|NULL
return|;
name|cur
operator|=
name|list
operator|->
name|head
expr_stmt|;
while|while
condition|(
name|cur
condition|)
block|{
if|if
condition|(
name|cur
operator|->
name|data
operator|==
name|data
condition|)
return|return
name|cur
return|;
name|cur
operator|=
name|cur
operator|->
name|next
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_block
begin_comment
comment|/* documentation is in ftlist.h */
end_comment
begin_macro
name|FT_EXPORT_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|FT_List_Add
name|FT_List_Add
argument_list|(
argument|FT_List      list
argument_list|,
argument|FT_ListNode  node
argument_list|)
end_macro
begin_block
block|{
name|FT_ListNode
name|before
decl_stmt|;
if|if
condition|(
operator|!
name|list
operator|||
operator|!
name|node
condition|)
return|return;
name|before
operator|=
name|list
operator|->
name|tail
expr_stmt|;
name|node
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|node
operator|->
name|prev
operator|=
name|before
expr_stmt|;
if|if
condition|(
name|before
condition|)
name|before
operator|->
name|next
operator|=
name|node
expr_stmt|;
else|else
name|list
operator|->
name|head
operator|=
name|node
expr_stmt|;
name|list
operator|->
name|tail
operator|=
name|node
expr_stmt|;
block|}
end_block
begin_comment
comment|/* documentation is in ftlist.h */
end_comment
begin_macro
name|FT_EXPORT_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|FT_List_Insert
name|FT_List_Insert
argument_list|(
argument|FT_List      list
argument_list|,
argument|FT_ListNode  node
argument_list|)
end_macro
begin_block
block|{
name|FT_ListNode
name|after
decl_stmt|;
if|if
condition|(
operator|!
name|list
operator|||
operator|!
name|node
condition|)
return|return;
name|after
operator|=
name|list
operator|->
name|head
expr_stmt|;
name|node
operator|->
name|next
operator|=
name|after
expr_stmt|;
name|node
operator|->
name|prev
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|after
condition|)
name|list
operator|->
name|tail
operator|=
name|node
expr_stmt|;
else|else
name|after
operator|->
name|prev
operator|=
name|node
expr_stmt|;
name|list
operator|->
name|head
operator|=
name|node
expr_stmt|;
block|}
end_block
begin_comment
comment|/* documentation is in ftlist.h */
end_comment
begin_macro
name|FT_EXPORT_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|FT_List_Remove
name|FT_List_Remove
argument_list|(
argument|FT_List      list
argument_list|,
argument|FT_ListNode  node
argument_list|)
end_macro
begin_block
block|{
name|FT_ListNode
name|before
decl_stmt|,
name|after
decl_stmt|;
if|if
condition|(
operator|!
name|list
operator|||
operator|!
name|node
condition|)
return|return;
name|before
operator|=
name|node
operator|->
name|prev
expr_stmt|;
name|after
operator|=
name|node
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|before
condition|)
name|before
operator|->
name|next
operator|=
name|after
expr_stmt|;
else|else
name|list
operator|->
name|head
operator|=
name|after
expr_stmt|;
if|if
condition|(
name|after
condition|)
name|after
operator|->
name|prev
operator|=
name|before
expr_stmt|;
else|else
name|list
operator|->
name|tail
operator|=
name|before
expr_stmt|;
block|}
end_block
begin_comment
comment|/* documentation is in ftlist.h */
end_comment
begin_macro
name|FT_EXPORT_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|FT_List_Up
name|FT_List_Up
argument_list|(
argument|FT_List      list
argument_list|,
argument|FT_ListNode  node
argument_list|)
end_macro
begin_block
block|{
name|FT_ListNode
name|before
decl_stmt|,
name|after
decl_stmt|;
if|if
condition|(
operator|!
name|list
operator|||
operator|!
name|node
condition|)
return|return;
name|before
operator|=
name|node
operator|->
name|prev
expr_stmt|;
name|after
operator|=
name|node
operator|->
name|next
expr_stmt|;
comment|/* check whether we are already on top of the list */
if|if
condition|(
operator|!
name|before
condition|)
return|return;
name|before
operator|->
name|next
operator|=
name|after
expr_stmt|;
if|if
condition|(
name|after
condition|)
name|after
operator|->
name|prev
operator|=
name|before
expr_stmt|;
else|else
name|list
operator|->
name|tail
operator|=
name|before
expr_stmt|;
name|node
operator|->
name|prev
operator|=
literal|0
expr_stmt|;
name|node
operator|->
name|next
operator|=
name|list
operator|->
name|head
expr_stmt|;
name|list
operator|->
name|head
operator|->
name|prev
operator|=
name|node
expr_stmt|;
name|list
operator|->
name|head
operator|=
name|node
expr_stmt|;
block|}
end_block
begin_comment
comment|/* documentation is in ftlist.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_List_Iterate
argument_list|(
argument|FT_List           list
argument_list|,
argument|FT_List_Iterator  iterator
argument_list|,
argument|void*             user
argument_list|)
end_macro
begin_block
block|{
name|FT_ListNode
name|cur
decl_stmt|;
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
if|if
condition|(
operator|!
name|list
operator|||
operator|!
name|iterator
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_Argument
argument_list|)
return|;
name|cur
operator|=
name|list
operator|->
name|head
expr_stmt|;
while|while
condition|(
name|cur
condition|)
block|{
name|FT_ListNode
name|next
init|=
name|cur
operator|->
name|next
decl_stmt|;
name|error
operator|=
name|iterator
argument_list|(
name|cur
argument_list|,
name|user
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|cur
operator|=
name|next
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/* documentation is in ftlist.h */
end_comment
begin_macro
name|FT_EXPORT_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|FT_List_Finalize
name|FT_List_Finalize
argument_list|(
argument|FT_List             list
argument_list|,
argument|FT_List_Destructor  destroy
argument_list|,
argument|FT_Memory           memory
argument_list|,
argument|void*               user
argument_list|)
end_macro
begin_block
block|{
name|FT_ListNode
name|cur
decl_stmt|;
if|if
condition|(
operator|!
name|list
operator|||
operator|!
name|memory
condition|)
return|return;
name|cur
operator|=
name|list
operator|->
name|head
expr_stmt|;
while|while
condition|(
name|cur
condition|)
block|{
name|FT_ListNode
name|next
init|=
name|cur
operator|->
name|next
decl_stmt|;
name|void
modifier|*
name|data
init|=
name|cur
operator|->
name|data
decl_stmt|;
if|if
condition|(
name|destroy
condition|)
name|destroy
argument_list|(
name|memory
argument_list|,
name|data
argument_list|,
name|user
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|cur
argument_list|)
expr_stmt|;
name|cur
operator|=
name|next
expr_stmt|;
block|}
name|list
operator|->
name|head
operator|=
literal|0
expr_stmt|;
name|list
operator|->
name|tail
operator|=
literal|0
expr_stmt|;
block|}
end_block
begin_comment
comment|/* END */
end_comment
end_unit
