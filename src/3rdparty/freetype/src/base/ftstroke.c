begin_unit
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  ftstroke.c                                                             */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*    FreeType path stroker (body).                                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  Copyright 2002, 2003, 2004, 2005, 2006, 2008, 2009 by                  */
end_comment
begin_comment
comment|/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  This file is part of the FreeType project, and may only be used,       */
end_comment
begin_comment
comment|/*  modified, and distributed under the terms of the FreeType project      */
end_comment
begin_comment
comment|/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
end_comment
begin_comment
comment|/*  this file you indicate that you have read the license and              */
end_comment
begin_comment
comment|/*  understand and accept it fully.                                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<ft2build.h>
end_include
begin_include
include|#
directive|include
include|FT_STROKER_H
end_include
begin_include
include|#
directive|include
include|FT_TRIGONOMETRY_H
end_include
begin_include
include|#
directive|include
include|FT_OUTLINE_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_MEMORY_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_DEBUG_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_OBJECTS_H
end_include
begin_comment
comment|/* documentation is in ftstroke.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_StrokerBorder
argument_list|)
end_macro
begin_macro
name|FT_Outline_GetInsideBorder
argument_list|(
argument|FT_Outline*  outline
argument_list|)
end_macro
begin_block
block|{
name|FT_Orientation
name|o
init|=
name|FT_Outline_Get_Orientation
argument_list|(
name|outline
argument_list|)
decl_stmt|;
return|return
name|o
operator|==
name|FT_ORIENTATION_TRUETYPE
condition|?
name|FT_STROKER_BORDER_RIGHT
else|:
name|FT_STROKER_BORDER_LEFT
return|;
block|}
end_block
begin_comment
comment|/* documentation is in ftstroke.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_StrokerBorder
argument_list|)
end_macro
begin_macro
name|FT_Outline_GetOutsideBorder
argument_list|(
argument|FT_Outline*  outline
argument_list|)
end_macro
begin_block
block|{
name|FT_Orientation
name|o
init|=
name|FT_Outline_Get_Orientation
argument_list|(
name|outline
argument_list|)
decl_stmt|;
return|return
name|o
operator|==
name|FT_ORIENTATION_TRUETYPE
condition|?
name|FT_STROKER_BORDER_LEFT
else|:
name|FT_STROKER_BORDER_RIGHT
return|;
block|}
end_block
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*****                                                                 *****/
end_comment
begin_comment
comment|/*****                       BEZIER COMPUTATIONS                       *****/
end_comment
begin_comment
comment|/*****                                                                 *****/
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_define
DECL|macro|FT_SMALL_CONIC_THRESHOLD
define|#
directive|define
name|FT_SMALL_CONIC_THRESHOLD
value|( FT_ANGLE_PI / 6 )
end_define
begin_define
DECL|macro|FT_SMALL_CUBIC_THRESHOLD
define|#
directive|define
name|FT_SMALL_CUBIC_THRESHOLD
value|( FT_ANGLE_PI / 6 )
end_define
begin_define
DECL|macro|FT_EPSILON
define|#
directive|define
name|FT_EPSILON
value|2
end_define
begin_define
DECL|macro|FT_IS_SMALL
define|#
directive|define
name|FT_IS_SMALL
parameter_list|(
name|x
parameter_list|)
value|( (x)> -FT_EPSILON&& (x)< FT_EPSILON )
end_define
begin_function
specifier|static
name|FT_Pos
DECL|function|ft_pos_abs
name|ft_pos_abs
parameter_list|(
name|FT_Pos
name|x
parameter_list|)
block|{
return|return
name|x
operator|>=
literal|0
condition|?
name|x
else|:
operator|-
name|x
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|ft_conic_split
name|ft_conic_split
parameter_list|(
name|FT_Vector
modifier|*
name|base
parameter_list|)
block|{
name|FT_Pos
name|a
decl_stmt|,
name|b
decl_stmt|;
name|base
index|[
literal|4
index|]
operator|.
name|x
operator|=
name|base
index|[
literal|2
index|]
operator|.
name|x
expr_stmt|;
name|b
operator|=
name|base
index|[
literal|1
index|]
operator|.
name|x
expr_stmt|;
name|a
operator|=
name|base
index|[
literal|3
index|]
operator|.
name|x
operator|=
operator|(
name|base
index|[
literal|2
index|]
operator|.
name|x
operator|+
name|b
operator|)
operator|/
literal|2
expr_stmt|;
name|b
operator|=
name|base
index|[
literal|1
index|]
operator|.
name|x
operator|=
operator|(
name|base
index|[
literal|0
index|]
operator|.
name|x
operator|+
name|b
operator|)
operator|/
literal|2
expr_stmt|;
name|base
index|[
literal|2
index|]
operator|.
name|x
operator|=
operator|(
name|a
operator|+
name|b
operator|)
operator|/
literal|2
expr_stmt|;
name|base
index|[
literal|4
index|]
operator|.
name|y
operator|=
name|base
index|[
literal|2
index|]
operator|.
name|y
expr_stmt|;
name|b
operator|=
name|base
index|[
literal|1
index|]
operator|.
name|y
expr_stmt|;
name|a
operator|=
name|base
index|[
literal|3
index|]
operator|.
name|y
operator|=
operator|(
name|base
index|[
literal|2
index|]
operator|.
name|y
operator|+
name|b
operator|)
operator|/
literal|2
expr_stmt|;
name|b
operator|=
name|base
index|[
literal|1
index|]
operator|.
name|y
operator|=
operator|(
name|base
index|[
literal|0
index|]
operator|.
name|y
operator|+
name|b
operator|)
operator|/
literal|2
expr_stmt|;
name|base
index|[
literal|2
index|]
operator|.
name|y
operator|=
operator|(
name|a
operator|+
name|b
operator|)
operator|/
literal|2
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|FT_Bool
DECL|function|ft_conic_is_small_enough
name|ft_conic_is_small_enough
parameter_list|(
name|FT_Vector
modifier|*
name|base
parameter_list|,
name|FT_Angle
modifier|*
name|angle_in
parameter_list|,
name|FT_Angle
modifier|*
name|angle_out
parameter_list|)
block|{
name|FT_Vector
name|d1
decl_stmt|,
name|d2
decl_stmt|;
name|FT_Angle
name|theta
decl_stmt|;
name|FT_Int
name|close1
decl_stmt|,
name|close2
decl_stmt|;
name|d1
operator|.
name|x
operator|=
name|base
index|[
literal|1
index|]
operator|.
name|x
operator|-
name|base
index|[
literal|2
index|]
operator|.
name|x
expr_stmt|;
name|d1
operator|.
name|y
operator|=
name|base
index|[
literal|1
index|]
operator|.
name|y
operator|-
name|base
index|[
literal|2
index|]
operator|.
name|y
expr_stmt|;
name|d2
operator|.
name|x
operator|=
name|base
index|[
literal|0
index|]
operator|.
name|x
operator|-
name|base
index|[
literal|1
index|]
operator|.
name|x
expr_stmt|;
name|d2
operator|.
name|y
operator|=
name|base
index|[
literal|0
index|]
operator|.
name|y
operator|-
name|base
index|[
literal|1
index|]
operator|.
name|y
expr_stmt|;
name|close1
operator|=
name|FT_IS_SMALL
argument_list|(
name|d1
operator|.
name|x
argument_list|)
operator|&&
name|FT_IS_SMALL
argument_list|(
name|d1
operator|.
name|y
argument_list|)
expr_stmt|;
name|close2
operator|=
name|FT_IS_SMALL
argument_list|(
name|d2
operator|.
name|x
argument_list|)
operator|&&
name|FT_IS_SMALL
argument_list|(
name|d2
operator|.
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|close1
condition|)
block|{
if|if
condition|(
name|close2
condition|)
operator|*
name|angle_in
operator|=
operator|*
name|angle_out
operator|=
literal|0
expr_stmt|;
else|else
operator|*
name|angle_in
operator|=
operator|*
name|angle_out
operator|=
name|FT_Atan2
argument_list|(
name|d2
operator|.
name|x
argument_list|,
name|d2
operator|.
name|y
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|close2
condition|)
block|{
operator|*
name|angle_in
operator|=
operator|*
name|angle_out
operator|=
name|FT_Atan2
argument_list|(
name|d1
operator|.
name|x
argument_list|,
name|d1
operator|.
name|y
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|angle_in
operator|=
name|FT_Atan2
argument_list|(
name|d1
operator|.
name|x
argument_list|,
name|d1
operator|.
name|y
argument_list|)
expr_stmt|;
operator|*
name|angle_out
operator|=
name|FT_Atan2
argument_list|(
name|d2
operator|.
name|x
argument_list|,
name|d2
operator|.
name|y
argument_list|)
expr_stmt|;
block|}
name|theta
operator|=
name|ft_pos_abs
argument_list|(
name|FT_Angle_Diff
argument_list|(
operator|*
name|angle_in
argument_list|,
operator|*
name|angle_out
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FT_BOOL
argument_list|(
name|theta
operator|<
name|FT_SMALL_CONIC_THRESHOLD
argument_list|)
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|ft_cubic_split
name|ft_cubic_split
parameter_list|(
name|FT_Vector
modifier|*
name|base
parameter_list|)
block|{
name|FT_Pos
name|a
decl_stmt|,
name|b
decl_stmt|,
name|c
decl_stmt|,
name|d
decl_stmt|;
name|base
index|[
literal|6
index|]
operator|.
name|x
operator|=
name|base
index|[
literal|3
index|]
operator|.
name|x
expr_stmt|;
name|c
operator|=
name|base
index|[
literal|1
index|]
operator|.
name|x
expr_stmt|;
name|d
operator|=
name|base
index|[
literal|2
index|]
operator|.
name|x
expr_stmt|;
name|base
index|[
literal|1
index|]
operator|.
name|x
operator|=
name|a
operator|=
operator|(
name|base
index|[
literal|0
index|]
operator|.
name|x
operator|+
name|c
operator|)
operator|/
literal|2
expr_stmt|;
name|base
index|[
literal|5
index|]
operator|.
name|x
operator|=
name|b
operator|=
operator|(
name|base
index|[
literal|3
index|]
operator|.
name|x
operator|+
name|d
operator|)
operator|/
literal|2
expr_stmt|;
name|c
operator|=
operator|(
name|c
operator|+
name|d
operator|)
operator|/
literal|2
expr_stmt|;
name|base
index|[
literal|2
index|]
operator|.
name|x
operator|=
name|a
operator|=
operator|(
name|a
operator|+
name|c
operator|)
operator|/
literal|2
expr_stmt|;
name|base
index|[
literal|4
index|]
operator|.
name|x
operator|=
name|b
operator|=
operator|(
name|b
operator|+
name|c
operator|)
operator|/
literal|2
expr_stmt|;
name|base
index|[
literal|3
index|]
operator|.
name|x
operator|=
operator|(
name|a
operator|+
name|b
operator|)
operator|/
literal|2
expr_stmt|;
name|base
index|[
literal|6
index|]
operator|.
name|y
operator|=
name|base
index|[
literal|3
index|]
operator|.
name|y
expr_stmt|;
name|c
operator|=
name|base
index|[
literal|1
index|]
operator|.
name|y
expr_stmt|;
name|d
operator|=
name|base
index|[
literal|2
index|]
operator|.
name|y
expr_stmt|;
name|base
index|[
literal|1
index|]
operator|.
name|y
operator|=
name|a
operator|=
operator|(
name|base
index|[
literal|0
index|]
operator|.
name|y
operator|+
name|c
operator|)
operator|/
literal|2
expr_stmt|;
name|base
index|[
literal|5
index|]
operator|.
name|y
operator|=
name|b
operator|=
operator|(
name|base
index|[
literal|3
index|]
operator|.
name|y
operator|+
name|d
operator|)
operator|/
literal|2
expr_stmt|;
name|c
operator|=
operator|(
name|c
operator|+
name|d
operator|)
operator|/
literal|2
expr_stmt|;
name|base
index|[
literal|2
index|]
operator|.
name|y
operator|=
name|a
operator|=
operator|(
name|a
operator|+
name|c
operator|)
operator|/
literal|2
expr_stmt|;
name|base
index|[
literal|4
index|]
operator|.
name|y
operator|=
name|b
operator|=
operator|(
name|b
operator|+
name|c
operator|)
operator|/
literal|2
expr_stmt|;
name|base
index|[
literal|3
index|]
operator|.
name|y
operator|=
operator|(
name|a
operator|+
name|b
operator|)
operator|/
literal|2
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|FT_Bool
DECL|function|ft_cubic_is_small_enough
name|ft_cubic_is_small_enough
parameter_list|(
name|FT_Vector
modifier|*
name|base
parameter_list|,
name|FT_Angle
modifier|*
name|angle_in
parameter_list|,
name|FT_Angle
modifier|*
name|angle_mid
parameter_list|,
name|FT_Angle
modifier|*
name|angle_out
parameter_list|)
block|{
name|FT_Vector
name|d1
decl_stmt|,
name|d2
decl_stmt|,
name|d3
decl_stmt|;
name|FT_Angle
name|theta1
decl_stmt|,
name|theta2
decl_stmt|;
name|FT_Int
name|close1
decl_stmt|,
name|close2
decl_stmt|,
name|close3
decl_stmt|;
name|d1
operator|.
name|x
operator|=
name|base
index|[
literal|2
index|]
operator|.
name|x
operator|-
name|base
index|[
literal|3
index|]
operator|.
name|x
expr_stmt|;
name|d1
operator|.
name|y
operator|=
name|base
index|[
literal|2
index|]
operator|.
name|y
operator|-
name|base
index|[
literal|3
index|]
operator|.
name|y
expr_stmt|;
name|d2
operator|.
name|x
operator|=
name|base
index|[
literal|1
index|]
operator|.
name|x
operator|-
name|base
index|[
literal|2
index|]
operator|.
name|x
expr_stmt|;
name|d2
operator|.
name|y
operator|=
name|base
index|[
literal|1
index|]
operator|.
name|y
operator|-
name|base
index|[
literal|2
index|]
operator|.
name|y
expr_stmt|;
name|d3
operator|.
name|x
operator|=
name|base
index|[
literal|0
index|]
operator|.
name|x
operator|-
name|base
index|[
literal|1
index|]
operator|.
name|x
expr_stmt|;
name|d3
operator|.
name|y
operator|=
name|base
index|[
literal|0
index|]
operator|.
name|y
operator|-
name|base
index|[
literal|1
index|]
operator|.
name|y
expr_stmt|;
name|close1
operator|=
name|FT_IS_SMALL
argument_list|(
name|d1
operator|.
name|x
argument_list|)
operator|&&
name|FT_IS_SMALL
argument_list|(
name|d1
operator|.
name|y
argument_list|)
expr_stmt|;
name|close2
operator|=
name|FT_IS_SMALL
argument_list|(
name|d2
operator|.
name|x
argument_list|)
operator|&&
name|FT_IS_SMALL
argument_list|(
name|d2
operator|.
name|y
argument_list|)
expr_stmt|;
name|close3
operator|=
name|FT_IS_SMALL
argument_list|(
name|d3
operator|.
name|x
argument_list|)
operator|&&
name|FT_IS_SMALL
argument_list|(
name|d3
operator|.
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|close1
operator|||
name|close3
condition|)
block|{
if|if
condition|(
name|close2
condition|)
block|{
comment|/* basically a point */
operator|*
name|angle_in
operator|=
operator|*
name|angle_out
operator|=
operator|*
name|angle_mid
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|close1
condition|)
block|{
operator|*
name|angle_in
operator|=
operator|*
name|angle_mid
operator|=
name|FT_Atan2
argument_list|(
name|d2
operator|.
name|x
argument_list|,
name|d2
operator|.
name|y
argument_list|)
expr_stmt|;
operator|*
name|angle_out
operator|=
name|FT_Atan2
argument_list|(
name|d3
operator|.
name|x
argument_list|,
name|d3
operator|.
name|y
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* close2 */
block|{
operator|*
name|angle_in
operator|=
name|FT_Atan2
argument_list|(
name|d1
operator|.
name|x
argument_list|,
name|d1
operator|.
name|y
argument_list|)
expr_stmt|;
operator|*
name|angle_mid
operator|=
operator|*
name|angle_out
operator|=
name|FT_Atan2
argument_list|(
name|d2
operator|.
name|x
argument_list|,
name|d2
operator|.
name|y
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|close2
condition|)
block|{
operator|*
name|angle_in
operator|=
operator|*
name|angle_mid
operator|=
name|FT_Atan2
argument_list|(
name|d1
operator|.
name|x
argument_list|,
name|d1
operator|.
name|y
argument_list|)
expr_stmt|;
operator|*
name|angle_out
operator|=
name|FT_Atan2
argument_list|(
name|d3
operator|.
name|x
argument_list|,
name|d3
operator|.
name|y
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|angle_in
operator|=
name|FT_Atan2
argument_list|(
name|d1
operator|.
name|x
argument_list|,
name|d1
operator|.
name|y
argument_list|)
expr_stmt|;
operator|*
name|angle_mid
operator|=
name|FT_Atan2
argument_list|(
name|d2
operator|.
name|x
argument_list|,
name|d2
operator|.
name|y
argument_list|)
expr_stmt|;
operator|*
name|angle_out
operator|=
name|FT_Atan2
argument_list|(
name|d3
operator|.
name|x
argument_list|,
name|d3
operator|.
name|y
argument_list|)
expr_stmt|;
block|}
name|theta1
operator|=
name|ft_pos_abs
argument_list|(
name|FT_Angle_Diff
argument_list|(
operator|*
name|angle_in
argument_list|,
operator|*
name|angle_mid
argument_list|)
argument_list|)
expr_stmt|;
name|theta2
operator|=
name|ft_pos_abs
argument_list|(
name|FT_Angle_Diff
argument_list|(
operator|*
name|angle_mid
argument_list|,
operator|*
name|angle_out
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FT_BOOL
argument_list|(
name|theta1
operator|<
name|FT_SMALL_CUBIC_THRESHOLD
operator|&&
name|theta2
operator|<
name|FT_SMALL_CUBIC_THRESHOLD
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*****                                                                 *****/
end_comment
begin_comment
comment|/*****                       STROKE BORDERS                            *****/
end_comment
begin_comment
comment|/*****                                                                 *****/
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_typedef
DECL|enum|FT_StrokeTags_
typedef|typedef
enum|enum
name|FT_StrokeTags_
block|{
DECL|enumerator|FT_STROKE_TAG_ON
name|FT_STROKE_TAG_ON
init|=
literal|1
block|,
comment|/* on-curve point  */
DECL|enumerator|FT_STROKE_TAG_CUBIC
name|FT_STROKE_TAG_CUBIC
init|=
literal|2
block|,
comment|/* cubic off-point */
DECL|enumerator|FT_STROKE_TAG_BEGIN
name|FT_STROKE_TAG_BEGIN
init|=
literal|4
block|,
comment|/* sub-path start  */
DECL|enumerator|FT_STROKE_TAG_END
name|FT_STROKE_TAG_END
init|=
literal|8
comment|/* sub-path end    */
block|}
DECL|typedef|FT_StrokeTags
name|FT_StrokeTags
typedef|;
end_typedef
begin_define
DECL|macro|FT_STROKE_TAG_BEGIN_END
define|#
directive|define
name|FT_STROKE_TAG_BEGIN_END
value|(FT_STROKE_TAG_BEGIN|FT_STROKE_TAG_END)
end_define
begin_typedef
DECL|struct|FT_StrokeBorderRec_
typedef|typedef
struct|struct
name|FT_StrokeBorderRec_
block|{
DECL|member|num_points
name|FT_UInt
name|num_points
decl_stmt|;
DECL|member|max_points
name|FT_UInt
name|max_points
decl_stmt|;
DECL|member|points
name|FT_Vector
modifier|*
name|points
decl_stmt|;
DECL|member|tags
name|FT_Byte
modifier|*
name|tags
decl_stmt|;
DECL|member|movable
name|FT_Bool
name|movable
decl_stmt|;
DECL|member|start
name|FT_Int
name|start
decl_stmt|;
comment|/* index of current sub-path start point */
DECL|member|memory
name|FT_Memory
name|memory
decl_stmt|;
DECL|member|valid
name|FT_Bool
name|valid
decl_stmt|;
block|}
DECL|typedef|FT_StrokeBorderRec
DECL|typedef|FT_StrokeBorder
name|FT_StrokeBorderRec
operator|,
typedef|*
name|FT_StrokeBorder
typedef|;
end_typedef
begin_function
specifier|static
name|FT_Error
DECL|function|ft_stroke_border_grow
name|ft_stroke_border_grow
parameter_list|(
name|FT_StrokeBorder
name|border
parameter_list|,
name|FT_UInt
name|new_points
parameter_list|)
block|{
name|FT_UInt
name|old_max
init|=
name|border
operator|->
name|max_points
decl_stmt|;
name|FT_UInt
name|new_max
init|=
name|border
operator|->
name|num_points
operator|+
name|new_points
decl_stmt|;
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
if|if
condition|(
name|new_max
operator|>
name|old_max
condition|)
block|{
name|FT_UInt
name|cur_max
init|=
name|old_max
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|border
operator|->
name|memory
decl_stmt|;
while|while
condition|(
name|cur_max
operator|<
name|new_max
condition|)
name|cur_max
operator|+=
operator|(
name|cur_max
operator|>>
literal|1
operator|)
operator|+
literal|16
expr_stmt|;
if|if
condition|(
name|FT_RENEW_ARRAY
argument_list|(
name|border
operator|->
name|points
argument_list|,
name|old_max
argument_list|,
name|cur_max
argument_list|)
operator|||
name|FT_RENEW_ARRAY
argument_list|(
name|border
operator|->
name|tags
argument_list|,
name|old_max
argument_list|,
name|cur_max
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|border
operator|->
name|max_points
operator|=
name|cur_max
expr_stmt|;
block|}
name|Exit
label|:
return|return
name|error
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|ft_stroke_border_close
name|ft_stroke_border_close
parameter_list|(
name|FT_StrokeBorder
name|border
parameter_list|,
name|FT_Bool
name|reverse
parameter_list|)
block|{
name|FT_UInt
name|start
init|=
name|border
operator|->
name|start
decl_stmt|;
name|FT_UInt
name|count
init|=
name|border
operator|->
name|num_points
decl_stmt|;
name|FT_ASSERT
argument_list|(
name|border
operator|->
name|start
operator|>=
literal|0
argument_list|)
expr_stmt|;
comment|/* don't record empty paths! */
if|if
condition|(
name|count
operator|<=
name|start
operator|+
literal|1U
condition|)
name|border
operator|->
name|num_points
operator|=
name|start
expr_stmt|;
else|else
block|{
comment|/* copy the last point to the start of this sub-path, since */
comment|/* it contains the `adjusted' starting coordinates          */
name|border
operator|->
name|num_points
operator|=
operator|--
name|count
expr_stmt|;
name|border
operator|->
name|points
index|[
name|start
index|]
operator|=
name|border
operator|->
name|points
index|[
name|count
index|]
expr_stmt|;
if|if
condition|(
name|reverse
condition|)
block|{
comment|/* reverse the points */
block|{
name|FT_Vector
modifier|*
name|vec1
init|=
name|border
operator|->
name|points
operator|+
name|start
operator|+
literal|1
decl_stmt|;
name|FT_Vector
modifier|*
name|vec2
init|=
name|border
operator|->
name|points
operator|+
name|count
operator|-
literal|1
decl_stmt|;
for|for
control|(
init|;
name|vec1
operator|<
name|vec2
condition|;
name|vec1
operator|++
operator|,
name|vec2
operator|--
control|)
block|{
name|FT_Vector
name|tmp
decl_stmt|;
name|tmp
operator|=
operator|*
name|vec1
expr_stmt|;
operator|*
name|vec1
operator|=
operator|*
name|vec2
expr_stmt|;
operator|*
name|vec2
operator|=
name|tmp
expr_stmt|;
block|}
block|}
comment|/* then the tags */
block|{
name|FT_Byte
modifier|*
name|tag1
init|=
name|border
operator|->
name|tags
operator|+
name|start
operator|+
literal|1
decl_stmt|;
name|FT_Byte
modifier|*
name|tag2
init|=
name|border
operator|->
name|tags
operator|+
name|count
operator|-
literal|1
decl_stmt|;
for|for
control|(
init|;
name|tag1
operator|<
name|tag2
condition|;
name|tag1
operator|++
operator|,
name|tag2
operator|--
control|)
block|{
name|FT_Byte
name|tmp
decl_stmt|;
name|tmp
operator|=
operator|*
name|tag1
expr_stmt|;
operator|*
name|tag1
operator|=
operator|*
name|tag2
expr_stmt|;
operator|*
name|tag2
operator|=
name|tmp
expr_stmt|;
block|}
block|}
block|}
name|border
operator|->
name|tags
index|[
name|start
index|]
operator||=
name|FT_STROKE_TAG_BEGIN
expr_stmt|;
name|border
operator|->
name|tags
index|[
name|count
operator|-
literal|1
index|]
operator||=
name|FT_STROKE_TAG_END
expr_stmt|;
block|}
name|border
operator|->
name|start
operator|=
operator|-
literal|1
expr_stmt|;
name|border
operator|->
name|movable
operator|=
name|FALSE
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|ft_stroke_border_lineto
name|ft_stroke_border_lineto
parameter_list|(
name|FT_StrokeBorder
name|border
parameter_list|,
name|FT_Vector
modifier|*
name|to
parameter_list|,
name|FT_Bool
name|movable
parameter_list|)
block|{
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
name|FT_ASSERT
argument_list|(
name|border
operator|->
name|start
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|border
operator|->
name|movable
condition|)
block|{
comment|/* move last point */
name|border
operator|->
name|points
index|[
name|border
operator|->
name|num_points
operator|-
literal|1
index|]
operator|=
operator|*
name|to
expr_stmt|;
block|}
else|else
block|{
comment|/* add one point */
name|error
operator|=
name|ft_stroke_border_grow
argument_list|(
name|border
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|FT_Vector
modifier|*
name|vec
init|=
name|border
operator|->
name|points
operator|+
name|border
operator|->
name|num_points
decl_stmt|;
name|FT_Byte
modifier|*
name|tag
init|=
name|border
operator|->
name|tags
operator|+
name|border
operator|->
name|num_points
decl_stmt|;
name|vec
index|[
literal|0
index|]
operator|=
operator|*
name|to
expr_stmt|;
name|tag
index|[
literal|0
index|]
operator|=
name|FT_STROKE_TAG_ON
expr_stmt|;
name|border
operator|->
name|num_points
operator|+=
literal|1
expr_stmt|;
block|}
block|}
name|border
operator|->
name|movable
operator|=
name|movable
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|ft_stroke_border_conicto
name|ft_stroke_border_conicto
parameter_list|(
name|FT_StrokeBorder
name|border
parameter_list|,
name|FT_Vector
modifier|*
name|control
parameter_list|,
name|FT_Vector
modifier|*
name|to
parameter_list|)
block|{
name|FT_Error
name|error
decl_stmt|;
name|FT_ASSERT
argument_list|(
name|border
operator|->
name|start
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|ft_stroke_border_grow
argument_list|(
name|border
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|FT_Vector
modifier|*
name|vec
init|=
name|border
operator|->
name|points
operator|+
name|border
operator|->
name|num_points
decl_stmt|;
name|FT_Byte
modifier|*
name|tag
init|=
name|border
operator|->
name|tags
operator|+
name|border
operator|->
name|num_points
decl_stmt|;
name|vec
index|[
literal|0
index|]
operator|=
operator|*
name|control
expr_stmt|;
name|vec
index|[
literal|1
index|]
operator|=
operator|*
name|to
expr_stmt|;
name|tag
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|tag
index|[
literal|1
index|]
operator|=
name|FT_STROKE_TAG_ON
expr_stmt|;
name|border
operator|->
name|num_points
operator|+=
literal|2
expr_stmt|;
block|}
name|border
operator|->
name|movable
operator|=
name|FALSE
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|ft_stroke_border_cubicto
name|ft_stroke_border_cubicto
parameter_list|(
name|FT_StrokeBorder
name|border
parameter_list|,
name|FT_Vector
modifier|*
name|control1
parameter_list|,
name|FT_Vector
modifier|*
name|control2
parameter_list|,
name|FT_Vector
modifier|*
name|to
parameter_list|)
block|{
name|FT_Error
name|error
decl_stmt|;
name|FT_ASSERT
argument_list|(
name|border
operator|->
name|start
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|ft_stroke_border_grow
argument_list|(
name|border
argument_list|,
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|FT_Vector
modifier|*
name|vec
init|=
name|border
operator|->
name|points
operator|+
name|border
operator|->
name|num_points
decl_stmt|;
name|FT_Byte
modifier|*
name|tag
init|=
name|border
operator|->
name|tags
operator|+
name|border
operator|->
name|num_points
decl_stmt|;
name|vec
index|[
literal|0
index|]
operator|=
operator|*
name|control1
expr_stmt|;
name|vec
index|[
literal|1
index|]
operator|=
operator|*
name|control2
expr_stmt|;
name|vec
index|[
literal|2
index|]
operator|=
operator|*
name|to
expr_stmt|;
name|tag
index|[
literal|0
index|]
operator|=
name|FT_STROKE_TAG_CUBIC
expr_stmt|;
name|tag
index|[
literal|1
index|]
operator|=
name|FT_STROKE_TAG_CUBIC
expr_stmt|;
name|tag
index|[
literal|2
index|]
operator|=
name|FT_STROKE_TAG_ON
expr_stmt|;
name|border
operator|->
name|num_points
operator|+=
literal|3
expr_stmt|;
block|}
name|border
operator|->
name|movable
operator|=
name|FALSE
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_define
DECL|macro|FT_ARC_CUBIC_ANGLE
define|#
directive|define
name|FT_ARC_CUBIC_ANGLE
value|( FT_ANGLE_PI / 2 )
end_define
begin_function
specifier|static
name|FT_Error
DECL|function|ft_stroke_border_arcto
name|ft_stroke_border_arcto
parameter_list|(
name|FT_StrokeBorder
name|border
parameter_list|,
name|FT_Vector
modifier|*
name|center
parameter_list|,
name|FT_Fixed
name|radius
parameter_list|,
name|FT_Angle
name|angle_start
parameter_list|,
name|FT_Angle
name|angle_diff
parameter_list|)
block|{
name|FT_Angle
name|total
decl_stmt|,
name|angle
decl_stmt|,
name|step
decl_stmt|,
name|rotate
decl_stmt|,
name|next
decl_stmt|,
name|theta
decl_stmt|;
name|FT_Vector
name|a
decl_stmt|,
name|b
decl_stmt|,
name|a2
decl_stmt|,
name|b2
decl_stmt|;
name|FT_Fixed
name|length
decl_stmt|;
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
comment|/* compute start point */
name|FT_Vector_From_Polar
argument_list|(
operator|&
name|a
argument_list|,
name|radius
argument_list|,
name|angle_start
argument_list|)
expr_stmt|;
name|a
operator|.
name|x
operator|+=
name|center
operator|->
name|x
expr_stmt|;
name|a
operator|.
name|y
operator|+=
name|center
operator|->
name|y
expr_stmt|;
name|total
operator|=
name|angle_diff
expr_stmt|;
name|angle
operator|=
name|angle_start
expr_stmt|;
name|rotate
operator|=
operator|(
name|angle_diff
operator|>=
literal|0
operator|)
condition|?
name|FT_ANGLE_PI2
else|:
operator|-
name|FT_ANGLE_PI2
expr_stmt|;
while|while
condition|(
name|total
operator|!=
literal|0
condition|)
block|{
name|step
operator|=
name|total
expr_stmt|;
if|if
condition|(
name|step
operator|>
name|FT_ARC_CUBIC_ANGLE
condition|)
name|step
operator|=
name|FT_ARC_CUBIC_ANGLE
expr_stmt|;
elseif|else
if|if
condition|(
name|step
operator|<
operator|-
name|FT_ARC_CUBIC_ANGLE
condition|)
name|step
operator|=
operator|-
name|FT_ARC_CUBIC_ANGLE
expr_stmt|;
name|next
operator|=
name|angle
operator|+
name|step
expr_stmt|;
name|theta
operator|=
name|step
expr_stmt|;
if|if
condition|(
name|theta
operator|<
literal|0
condition|)
name|theta
operator|=
operator|-
name|theta
expr_stmt|;
name|theta
operator|>>=
literal|1
expr_stmt|;
comment|/* compute end point */
name|FT_Vector_From_Polar
argument_list|(
operator|&
name|b
argument_list|,
name|radius
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|b
operator|.
name|x
operator|+=
name|center
operator|->
name|x
expr_stmt|;
name|b
operator|.
name|y
operator|+=
name|center
operator|->
name|y
expr_stmt|;
comment|/* compute first and second control points */
name|length
operator|=
name|FT_MulDiv
argument_list|(
name|radius
argument_list|,
name|FT_Sin
argument_list|(
name|theta
argument_list|)
operator|*
literal|4
argument_list|,
operator|(
literal|0x10000L
operator|+
name|FT_Cos
argument_list|(
name|theta
argument_list|)
operator|)
operator|*
literal|3
argument_list|)
expr_stmt|;
name|FT_Vector_From_Polar
argument_list|(
operator|&
name|a2
argument_list|,
name|length
argument_list|,
name|angle
operator|+
name|rotate
argument_list|)
expr_stmt|;
name|a2
operator|.
name|x
operator|+=
name|a
operator|.
name|x
expr_stmt|;
name|a2
operator|.
name|y
operator|+=
name|a
operator|.
name|y
expr_stmt|;
name|FT_Vector_From_Polar
argument_list|(
operator|&
name|b2
argument_list|,
name|length
argument_list|,
name|next
operator|-
name|rotate
argument_list|)
expr_stmt|;
name|b2
operator|.
name|x
operator|+=
name|b
operator|.
name|x
expr_stmt|;
name|b2
operator|.
name|y
operator|+=
name|b
operator|.
name|y
expr_stmt|;
comment|/* add cubic arc */
name|error
operator|=
name|ft_stroke_border_cubicto
argument_list|(
name|border
argument_list|,
operator|&
name|a2
argument_list|,
operator|&
name|b2
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
comment|/* process the rest of the arc ?? */
name|a
operator|=
name|b
expr_stmt|;
name|total
operator|-=
name|step
expr_stmt|;
name|angle
operator|=
name|next
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|ft_stroke_border_moveto
name|ft_stroke_border_moveto
parameter_list|(
name|FT_StrokeBorder
name|border
parameter_list|,
name|FT_Vector
modifier|*
name|to
parameter_list|)
block|{
comment|/* close current open path if any ? */
if|if
condition|(
name|border
operator|->
name|start
operator|>=
literal|0
condition|)
name|ft_stroke_border_close
argument_list|(
name|border
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|border
operator|->
name|start
operator|=
name|border
operator|->
name|num_points
expr_stmt|;
name|border
operator|->
name|movable
operator|=
name|FALSE
expr_stmt|;
return|return
name|ft_stroke_border_lineto
argument_list|(
name|border
argument_list|,
name|to
argument_list|,
name|FALSE
argument_list|)
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|ft_stroke_border_init
name|ft_stroke_border_init
parameter_list|(
name|FT_StrokeBorder
name|border
parameter_list|,
name|FT_Memory
name|memory
parameter_list|)
block|{
name|border
operator|->
name|memory
operator|=
name|memory
expr_stmt|;
name|border
operator|->
name|points
operator|=
name|NULL
expr_stmt|;
name|border
operator|->
name|tags
operator|=
name|NULL
expr_stmt|;
name|border
operator|->
name|num_points
operator|=
literal|0
expr_stmt|;
name|border
operator|->
name|max_points
operator|=
literal|0
expr_stmt|;
name|border
operator|->
name|start
operator|=
operator|-
literal|1
expr_stmt|;
name|border
operator|->
name|valid
operator|=
name|FALSE
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|ft_stroke_border_reset
name|ft_stroke_border_reset
parameter_list|(
name|FT_StrokeBorder
name|border
parameter_list|)
block|{
name|border
operator|->
name|num_points
operator|=
literal|0
expr_stmt|;
name|border
operator|->
name|start
operator|=
operator|-
literal|1
expr_stmt|;
name|border
operator|->
name|valid
operator|=
name|FALSE
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|ft_stroke_border_done
name|ft_stroke_border_done
parameter_list|(
name|FT_StrokeBorder
name|border
parameter_list|)
block|{
name|FT_Memory
name|memory
init|=
name|border
operator|->
name|memory
decl_stmt|;
name|FT_FREE
argument_list|(
name|border
operator|->
name|points
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|border
operator|->
name|tags
argument_list|)
expr_stmt|;
name|border
operator|->
name|num_points
operator|=
literal|0
expr_stmt|;
name|border
operator|->
name|max_points
operator|=
literal|0
expr_stmt|;
name|border
operator|->
name|start
operator|=
operator|-
literal|1
expr_stmt|;
name|border
operator|->
name|valid
operator|=
name|FALSE
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|ft_stroke_border_get_counts
name|ft_stroke_border_get_counts
parameter_list|(
name|FT_StrokeBorder
name|border
parameter_list|,
name|FT_UInt
modifier|*
name|anum_points
parameter_list|,
name|FT_UInt
modifier|*
name|anum_contours
parameter_list|)
block|{
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
name|FT_UInt
name|num_points
init|=
literal|0
decl_stmt|;
name|FT_UInt
name|num_contours
init|=
literal|0
decl_stmt|;
name|FT_UInt
name|count
init|=
name|border
operator|->
name|num_points
decl_stmt|;
name|FT_Vector
modifier|*
name|point
init|=
name|border
operator|->
name|points
decl_stmt|;
name|FT_Byte
modifier|*
name|tags
init|=
name|border
operator|->
name|tags
decl_stmt|;
name|FT_Int
name|in_contour
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
operator|,
name|num_points
operator|++
operator|,
name|point
operator|++
operator|,
name|tags
operator|++
control|)
block|{
if|if
condition|(
name|tags
index|[
literal|0
index|]
operator|&
name|FT_STROKE_TAG_BEGIN
condition|)
block|{
if|if
condition|(
name|in_contour
operator|!=
literal|0
condition|)
goto|goto
name|Fail
goto|;
name|in_contour
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|in_contour
operator|==
literal|0
condition|)
goto|goto
name|Fail
goto|;
if|if
condition|(
name|tags
index|[
literal|0
index|]
operator|&
name|FT_STROKE_TAG_END
condition|)
block|{
name|in_contour
operator|=
literal|0
expr_stmt|;
name|num_contours
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|in_contour
operator|!=
literal|0
condition|)
goto|goto
name|Fail
goto|;
name|border
operator|->
name|valid
operator|=
name|TRUE
expr_stmt|;
name|Exit
label|:
operator|*
name|anum_points
operator|=
name|num_points
expr_stmt|;
operator|*
name|anum_contours
operator|=
name|num_contours
expr_stmt|;
return|return
name|error
return|;
name|Fail
label|:
name|num_points
operator|=
literal|0
expr_stmt|;
name|num_contours
operator|=
literal|0
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|ft_stroke_border_export
name|ft_stroke_border_export
parameter_list|(
name|FT_StrokeBorder
name|border
parameter_list|,
name|FT_Outline
modifier|*
name|outline
parameter_list|)
block|{
comment|/* copy point locations */
name|FT_ARRAY_COPY
argument_list|(
name|outline
operator|->
name|points
operator|+
name|outline
operator|->
name|n_points
argument_list|,
name|border
operator|->
name|points
argument_list|,
name|border
operator|->
name|num_points
argument_list|)
expr_stmt|;
comment|/* copy tags */
block|{
name|FT_UInt
name|count
init|=
name|border
operator|->
name|num_points
decl_stmt|;
name|FT_Byte
modifier|*
name|read
init|=
name|border
operator|->
name|tags
decl_stmt|;
name|FT_Byte
modifier|*
name|write
init|=
operator|(
name|FT_Byte
operator|*
operator|)
name|outline
operator|->
name|tags
operator|+
name|outline
operator|->
name|n_points
decl_stmt|;
for|for
control|(
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
operator|,
name|read
operator|++
operator|,
name|write
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|read
operator|&
name|FT_STROKE_TAG_ON
condition|)
operator|*
name|write
operator|=
name|FT_CURVE_TAG_ON
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|read
operator|&
name|FT_STROKE_TAG_CUBIC
condition|)
operator|*
name|write
operator|=
name|FT_CURVE_TAG_CUBIC
expr_stmt|;
else|else
operator|*
name|write
operator|=
name|FT_CURVE_TAG_CONIC
expr_stmt|;
block|}
block|}
comment|/* copy contours */
block|{
name|FT_UInt
name|count
init|=
name|border
operator|->
name|num_points
decl_stmt|;
name|FT_Byte
modifier|*
name|tags
init|=
name|border
operator|->
name|tags
decl_stmt|;
name|FT_Short
modifier|*
name|write
init|=
name|outline
operator|->
name|contours
operator|+
name|outline
operator|->
name|n_contours
decl_stmt|;
name|FT_Short
name|idx
init|=
operator|(
name|FT_Short
operator|)
name|outline
operator|->
name|n_points
decl_stmt|;
for|for
control|(
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
operator|,
name|tags
operator|++
operator|,
name|idx
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|tags
operator|&
name|FT_STROKE_TAG_END
condition|)
block|{
operator|*
name|write
operator|++
operator|=
name|idx
expr_stmt|;
name|outline
operator|->
name|n_contours
operator|++
expr_stmt|;
block|}
block|}
block|}
name|outline
operator|->
name|n_points
operator|=
call|(
name|short
call|)
argument_list|(
name|outline
operator|->
name|n_points
operator|+
name|border
operator|->
name|num_points
argument_list|)
expr_stmt|;
name|FT_ASSERT
argument_list|(
name|FT_Outline_Check
argument_list|(
name|outline
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*****                                                                 *****/
end_comment
begin_comment
comment|/*****                           STROKER                               *****/
end_comment
begin_comment
comment|/*****                                                                 *****/
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_define
DECL|macro|FT_SIDE_TO_ROTATE
define|#
directive|define
name|FT_SIDE_TO_ROTATE
parameter_list|(
name|s
parameter_list|)
value|( FT_ANGLE_PI2 - (s) * FT_ANGLE_PI )
end_define
begin_typedef
DECL|struct|FT_StrokerRec_
typedef|typedef
struct|struct
name|FT_StrokerRec_
block|{
DECL|member|angle_in
name|FT_Angle
name|angle_in
decl_stmt|;
DECL|member|angle_out
name|FT_Angle
name|angle_out
decl_stmt|;
DECL|member|center
name|FT_Vector
name|center
decl_stmt|;
DECL|member|first_point
name|FT_Bool
name|first_point
decl_stmt|;
DECL|member|subpath_open
name|FT_Bool
name|subpath_open
decl_stmt|;
DECL|member|subpath_angle
name|FT_Angle
name|subpath_angle
decl_stmt|;
DECL|member|subpath_start
name|FT_Vector
name|subpath_start
decl_stmt|;
DECL|member|line_cap
name|FT_Stroker_LineCap
name|line_cap
decl_stmt|;
DECL|member|line_join
name|FT_Stroker_LineJoin
name|line_join
decl_stmt|;
DECL|member|miter_limit
name|FT_Fixed
name|miter_limit
decl_stmt|;
DECL|member|radius
name|FT_Fixed
name|radius
decl_stmt|;
DECL|member|valid
name|FT_Bool
name|valid
decl_stmt|;
DECL|member|borders
name|FT_StrokeBorderRec
name|borders
index|[
literal|2
index|]
decl_stmt|;
DECL|member|memory
name|FT_Memory
name|memory
decl_stmt|;
block|}
DECL|typedef|FT_StrokerRec
name|FT_StrokerRec
typedef|;
end_typedef
begin_comment
comment|/* documentation is in ftstroke.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_Stroker_New
argument_list|(
argument|FT_Library   library
argument_list|,
argument|FT_Stroker  *astroker
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
decl_stmt|;
name|FT_Memory
name|memory
decl_stmt|;
name|FT_Stroker
name|stroker
decl_stmt|;
if|if
condition|(
operator|!
name|library
condition|)
return|return
name|FT_Err_Invalid_Argument
return|;
name|memory
operator|=
name|library
operator|->
name|memory
expr_stmt|;
if|if
condition|(
operator|!
name|FT_NEW
argument_list|(
name|stroker
argument_list|)
condition|)
block|{
name|stroker
operator|->
name|memory
operator|=
name|memory
expr_stmt|;
name|ft_stroke_border_init
argument_list|(
operator|&
name|stroker
operator|->
name|borders
index|[
literal|0
index|]
argument_list|,
name|memory
argument_list|)
expr_stmt|;
name|ft_stroke_border_init
argument_list|(
operator|&
name|stroker
operator|->
name|borders
index|[
literal|1
index|]
argument_list|,
name|memory
argument_list|)
expr_stmt|;
block|}
operator|*
name|astroker
operator|=
name|stroker
expr_stmt|;
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/* documentation is in ftstroke.h */
end_comment
begin_macro
name|FT_EXPORT_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|FT_Stroker_Set
name|FT_Stroker_Set
argument_list|(
argument|FT_Stroker           stroker
argument_list|,
argument|FT_Fixed             radius
argument_list|,
argument|FT_Stroker_LineCap   line_cap
argument_list|,
argument|FT_Stroker_LineJoin  line_join
argument_list|,
argument|FT_Fixed             miter_limit
argument_list|)
end_macro
begin_block
block|{
name|stroker
operator|->
name|radius
operator|=
name|radius
expr_stmt|;
name|stroker
operator|->
name|line_cap
operator|=
name|line_cap
expr_stmt|;
name|stroker
operator|->
name|line_join
operator|=
name|line_join
expr_stmt|;
name|stroker
operator|->
name|miter_limit
operator|=
name|miter_limit
expr_stmt|;
name|FT_Stroker_Rewind
argument_list|(
name|stroker
argument_list|)
expr_stmt|;
block|}
end_block
begin_comment
comment|/* documentation is in ftstroke.h */
end_comment
begin_macro
name|FT_EXPORT_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|FT_Stroker_Rewind
name|FT_Stroker_Rewind
argument_list|(
argument|FT_Stroker  stroker
argument_list|)
end_macro
begin_block
block|{
if|if
condition|(
name|stroker
condition|)
block|{
name|ft_stroke_border_reset
argument_list|(
operator|&
name|stroker
operator|->
name|borders
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ft_stroke_border_reset
argument_list|(
operator|&
name|stroker
operator|->
name|borders
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_block
begin_comment
comment|/* documentation is in ftstroke.h */
end_comment
begin_macro
name|FT_EXPORT_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|FT_Stroker_Done
name|FT_Stroker_Done
argument_list|(
argument|FT_Stroker  stroker
argument_list|)
end_macro
begin_block
block|{
if|if
condition|(
name|stroker
condition|)
block|{
name|FT_Memory
name|memory
init|=
name|stroker
operator|->
name|memory
decl_stmt|;
name|ft_stroke_border_done
argument_list|(
operator|&
name|stroker
operator|->
name|borders
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ft_stroke_border_done
argument_list|(
operator|&
name|stroker
operator|->
name|borders
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|stroker
operator|->
name|memory
operator|=
name|NULL
expr_stmt|;
name|FT_FREE
argument_list|(
name|stroker
argument_list|)
expr_stmt|;
block|}
block|}
end_block
begin_comment
comment|/* creates a circular arc at a corner or cap */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|ft_stroker_arcto
name|ft_stroker_arcto
parameter_list|(
name|FT_Stroker
name|stroker
parameter_list|,
name|FT_Int
name|side
parameter_list|)
block|{
name|FT_Angle
name|total
decl_stmt|,
name|rotate
decl_stmt|;
name|FT_Fixed
name|radius
init|=
name|stroker
operator|->
name|radius
decl_stmt|;
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
name|FT_StrokeBorder
name|border
init|=
name|stroker
operator|->
name|borders
operator|+
name|side
decl_stmt|;
name|rotate
operator|=
name|FT_SIDE_TO_ROTATE
argument_list|(
name|side
argument_list|)
expr_stmt|;
name|total
operator|=
name|FT_Angle_Diff
argument_list|(
name|stroker
operator|->
name|angle_in
argument_list|,
name|stroker
operator|->
name|angle_out
argument_list|)
expr_stmt|;
if|if
condition|(
name|total
operator|==
name|FT_ANGLE_PI
condition|)
name|total
operator|=
operator|-
name|rotate
operator|*
literal|2
expr_stmt|;
name|error
operator|=
name|ft_stroke_border_arcto
argument_list|(
name|border
argument_list|,
operator|&
name|stroker
operator|->
name|center
argument_list|,
name|radius
argument_list|,
name|stroker
operator|->
name|angle_in
operator|+
name|rotate
argument_list|,
name|total
argument_list|)
expr_stmt|;
name|border
operator|->
name|movable
operator|=
name|FALSE
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_comment
comment|/* adds a cap at the end of an opened path */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|ft_stroker_cap
name|ft_stroker_cap
parameter_list|(
name|FT_Stroker
name|stroker
parameter_list|,
name|FT_Angle
name|angle
parameter_list|,
name|FT_Int
name|side
parameter_list|)
block|{
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
if|if
condition|(
name|stroker
operator|->
name|line_cap
operator|==
name|FT_STROKER_LINECAP_ROUND
condition|)
block|{
comment|/* add a round cap */
name|stroker
operator|->
name|angle_in
operator|=
name|angle
expr_stmt|;
name|stroker
operator|->
name|angle_out
operator|=
name|angle
operator|+
name|FT_ANGLE_PI
expr_stmt|;
name|error
operator|=
name|ft_stroker_arcto
argument_list|(
name|stroker
argument_list|,
name|side
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|stroker
operator|->
name|line_cap
operator|==
name|FT_STROKER_LINECAP_SQUARE
condition|)
block|{
comment|/* add a square cap */
name|FT_Vector
name|delta
decl_stmt|,
name|delta2
decl_stmt|;
name|FT_Angle
name|rotate
init|=
name|FT_SIDE_TO_ROTATE
argument_list|(
name|side
argument_list|)
decl_stmt|;
name|FT_Fixed
name|radius
init|=
name|stroker
operator|->
name|radius
decl_stmt|;
name|FT_StrokeBorder
name|border
init|=
name|stroker
operator|->
name|borders
operator|+
name|side
decl_stmt|;
name|FT_Vector_From_Polar
argument_list|(
operator|&
name|delta2
argument_list|,
name|radius
argument_list|,
name|angle
operator|+
name|rotate
argument_list|)
expr_stmt|;
name|FT_Vector_From_Polar
argument_list|(
operator|&
name|delta
argument_list|,
name|radius
argument_list|,
name|angle
argument_list|)
expr_stmt|;
name|delta
operator|.
name|x
operator|+=
name|stroker
operator|->
name|center
operator|.
name|x
operator|+
name|delta2
operator|.
name|x
expr_stmt|;
name|delta
operator|.
name|y
operator|+=
name|stroker
operator|->
name|center
operator|.
name|y
operator|+
name|delta2
operator|.
name|y
expr_stmt|;
name|error
operator|=
name|ft_stroke_border_lineto
argument_list|(
name|border
argument_list|,
operator|&
name|delta
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|FT_Vector_From_Polar
argument_list|(
operator|&
name|delta2
argument_list|,
name|radius
argument_list|,
name|angle
operator|-
name|rotate
argument_list|)
expr_stmt|;
name|FT_Vector_From_Polar
argument_list|(
operator|&
name|delta
argument_list|,
name|radius
argument_list|,
name|angle
argument_list|)
expr_stmt|;
name|delta
operator|.
name|x
operator|+=
name|delta2
operator|.
name|x
operator|+
name|stroker
operator|->
name|center
operator|.
name|x
expr_stmt|;
name|delta
operator|.
name|y
operator|+=
name|delta2
operator|.
name|y
operator|+
name|stroker
operator|->
name|center
operator|.
name|y
expr_stmt|;
name|error
operator|=
name|ft_stroke_border_lineto
argument_list|(
name|border
argument_list|,
operator|&
name|delta
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|Exit
label|:
return|return
name|error
return|;
block|}
end_function
begin_comment
comment|/* process an inside corner, i.e. compute intersection */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|ft_stroker_inside
name|ft_stroker_inside
parameter_list|(
name|FT_Stroker
name|stroker
parameter_list|,
name|FT_Int
name|side
parameter_list|)
block|{
name|FT_StrokeBorder
name|border
init|=
name|stroker
operator|->
name|borders
operator|+
name|side
decl_stmt|;
name|FT_Angle
name|phi
decl_stmt|,
name|theta
decl_stmt|,
name|rotate
decl_stmt|;
name|FT_Fixed
name|length
decl_stmt|,
name|thcos
decl_stmt|,
name|sigma
decl_stmt|;
name|FT_Vector
name|delta
decl_stmt|;
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
name|rotate
operator|=
name|FT_SIDE_TO_ROTATE
argument_list|(
name|side
argument_list|)
expr_stmt|;
comment|/* compute median angle */
name|theta
operator|=
name|FT_Angle_Diff
argument_list|(
name|stroker
operator|->
name|angle_in
argument_list|,
name|stroker
operator|->
name|angle_out
argument_list|)
expr_stmt|;
if|if
condition|(
name|theta
operator|==
name|FT_ANGLE_PI
condition|)
name|theta
operator|=
name|rotate
expr_stmt|;
else|else
name|theta
operator|=
name|theta
operator|/
literal|2
expr_stmt|;
name|phi
operator|=
name|stroker
operator|->
name|angle_in
operator|+
name|theta
expr_stmt|;
name|thcos
operator|=
name|FT_Cos
argument_list|(
name|theta
argument_list|)
expr_stmt|;
name|sigma
operator|=
name|FT_MulFix
argument_list|(
name|stroker
operator|->
name|miter_limit
argument_list|,
name|thcos
argument_list|)
expr_stmt|;
comment|/* TODO: find better criterion to switch off the optimization */
if|if
condition|(
name|sigma
operator|<
literal|0x10000L
condition|)
block|{
name|FT_Vector_From_Polar
argument_list|(
operator|&
name|delta
argument_list|,
name|stroker
operator|->
name|radius
argument_list|,
name|stroker
operator|->
name|angle_out
operator|+
name|rotate
argument_list|)
expr_stmt|;
name|delta
operator|.
name|x
operator|+=
name|stroker
operator|->
name|center
operator|.
name|x
expr_stmt|;
name|delta
operator|.
name|y
operator|+=
name|stroker
operator|->
name|center
operator|.
name|y
expr_stmt|;
name|border
operator|->
name|movable
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|length
operator|=
name|FT_DivFix
argument_list|(
name|stroker
operator|->
name|radius
argument_list|,
name|thcos
argument_list|)
expr_stmt|;
name|FT_Vector_From_Polar
argument_list|(
operator|&
name|delta
argument_list|,
name|length
argument_list|,
name|phi
operator|+
name|rotate
argument_list|)
expr_stmt|;
name|delta
operator|.
name|x
operator|+=
name|stroker
operator|->
name|center
operator|.
name|x
expr_stmt|;
name|delta
operator|.
name|y
operator|+=
name|stroker
operator|->
name|center
operator|.
name|y
expr_stmt|;
block|}
name|error
operator|=
name|ft_stroke_border_lineto
argument_list|(
name|border
argument_list|,
operator|&
name|delta
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_comment
comment|/* process an outside corner, i.e. compute bevel/miter/round */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|ft_stroker_outside
name|ft_stroker_outside
parameter_list|(
name|FT_Stroker
name|stroker
parameter_list|,
name|FT_Int
name|side
parameter_list|)
block|{
name|FT_StrokeBorder
name|border
init|=
name|stroker
operator|->
name|borders
operator|+
name|side
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|FT_Angle
name|rotate
decl_stmt|;
if|if
condition|(
name|stroker
operator|->
name|line_join
operator|==
name|FT_STROKER_LINEJOIN_ROUND
condition|)
name|error
operator|=
name|ft_stroker_arcto
argument_list|(
name|stroker
argument_list|,
name|side
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* this is a mitered or beveled corner */
name|FT_Fixed
name|sigma
decl_stmt|,
name|radius
init|=
name|stroker
operator|->
name|radius
decl_stmt|;
name|FT_Angle
name|theta
decl_stmt|,
name|phi
decl_stmt|;
name|FT_Fixed
name|thcos
decl_stmt|;
name|FT_Bool
name|miter
decl_stmt|;
name|rotate
operator|=
name|FT_SIDE_TO_ROTATE
argument_list|(
name|side
argument_list|)
expr_stmt|;
name|miter
operator|=
name|FT_BOOL
argument_list|(
name|stroker
operator|->
name|line_join
operator|==
name|FT_STROKER_LINEJOIN_MITER
argument_list|)
expr_stmt|;
name|theta
operator|=
name|FT_Angle_Diff
argument_list|(
name|stroker
operator|->
name|angle_in
argument_list|,
name|stroker
operator|->
name|angle_out
argument_list|)
expr_stmt|;
if|if
condition|(
name|theta
operator|==
name|FT_ANGLE_PI
condition|)
block|{
name|theta
operator|=
name|rotate
expr_stmt|;
name|phi
operator|=
name|stroker
operator|->
name|angle_in
expr_stmt|;
block|}
else|else
block|{
name|theta
operator|=
name|theta
operator|/
literal|2
expr_stmt|;
name|phi
operator|=
name|stroker
operator|->
name|angle_in
operator|+
name|theta
operator|+
name|rotate
expr_stmt|;
block|}
name|thcos
operator|=
name|FT_Cos
argument_list|(
name|theta
argument_list|)
expr_stmt|;
name|sigma
operator|=
name|FT_MulFix
argument_list|(
name|stroker
operator|->
name|miter_limit
argument_list|,
name|thcos
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigma
operator|>=
literal|0x10000L
condition|)
name|miter
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|miter
condition|)
comment|/* this is a miter (broken angle) */
block|{
name|FT_Vector
name|middle
decl_stmt|,
name|delta
decl_stmt|;
name|FT_Fixed
name|length
decl_stmt|;
comment|/* compute middle point */
name|FT_Vector_From_Polar
argument_list|(
operator|&
name|middle
argument_list|,
name|FT_MulFix
argument_list|(
name|radius
argument_list|,
name|stroker
operator|->
name|miter_limit
argument_list|)
argument_list|,
name|phi
argument_list|)
expr_stmt|;
name|middle
operator|.
name|x
operator|+=
name|stroker
operator|->
name|center
operator|.
name|x
expr_stmt|;
name|middle
operator|.
name|y
operator|+=
name|stroker
operator|->
name|center
operator|.
name|y
expr_stmt|;
comment|/* compute first angle point */
name|length
operator|=
name|FT_MulFix
argument_list|(
name|radius
argument_list|,
name|FT_DivFix
argument_list|(
literal|0x10000L
operator|-
name|sigma
argument_list|,
name|ft_pos_abs
argument_list|(
name|FT_Sin
argument_list|(
name|theta
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|FT_Vector_From_Polar
argument_list|(
operator|&
name|delta
argument_list|,
name|length
argument_list|,
name|phi
operator|+
name|rotate
argument_list|)
expr_stmt|;
name|delta
operator|.
name|x
operator|+=
name|middle
operator|.
name|x
expr_stmt|;
name|delta
operator|.
name|y
operator|+=
name|middle
operator|.
name|y
expr_stmt|;
name|error
operator|=
name|ft_stroke_border_lineto
argument_list|(
name|border
argument_list|,
operator|&
name|delta
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
comment|/* compute second angle point */
name|FT_Vector_From_Polar
argument_list|(
operator|&
name|delta
argument_list|,
name|length
argument_list|,
name|phi
operator|-
name|rotate
argument_list|)
expr_stmt|;
name|delta
operator|.
name|x
operator|+=
name|middle
operator|.
name|x
expr_stmt|;
name|delta
operator|.
name|y
operator|+=
name|middle
operator|.
name|y
expr_stmt|;
name|error
operator|=
name|ft_stroke_border_lineto
argument_list|(
name|border
argument_list|,
operator|&
name|delta
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
comment|/* finally, add a movable end point */
name|FT_Vector_From_Polar
argument_list|(
operator|&
name|delta
argument_list|,
name|radius
argument_list|,
name|stroker
operator|->
name|angle_out
operator|+
name|rotate
argument_list|)
expr_stmt|;
name|delta
operator|.
name|x
operator|+=
name|stroker
operator|->
name|center
operator|.
name|x
expr_stmt|;
name|delta
operator|.
name|y
operator|+=
name|stroker
operator|->
name|center
operator|.
name|y
expr_stmt|;
name|error
operator|=
name|ft_stroke_border_lineto
argument_list|(
name|border
argument_list|,
operator|&
name|delta
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* this is a bevel (intersection) */
block|{
name|FT_Fixed
name|length
decl_stmt|;
name|FT_Vector
name|delta
decl_stmt|;
name|length
operator|=
name|FT_DivFix
argument_list|(
name|stroker
operator|->
name|radius
argument_list|,
name|thcos
argument_list|)
expr_stmt|;
name|FT_Vector_From_Polar
argument_list|(
operator|&
name|delta
argument_list|,
name|length
argument_list|,
name|phi
argument_list|)
expr_stmt|;
name|delta
operator|.
name|x
operator|+=
name|stroker
operator|->
name|center
operator|.
name|x
expr_stmt|;
name|delta
operator|.
name|y
operator|+=
name|stroker
operator|->
name|center
operator|.
name|y
expr_stmt|;
name|error
operator|=
name|ft_stroke_border_lineto
argument_list|(
name|border
argument_list|,
operator|&
name|delta
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
comment|/* now add end point */
name|FT_Vector_From_Polar
argument_list|(
operator|&
name|delta
argument_list|,
name|stroker
operator|->
name|radius
argument_list|,
name|stroker
operator|->
name|angle_out
operator|+
name|rotate
argument_list|)
expr_stmt|;
name|delta
operator|.
name|x
operator|+=
name|stroker
operator|->
name|center
operator|.
name|x
expr_stmt|;
name|delta
operator|.
name|y
operator|+=
name|stroker
operator|->
name|center
operator|.
name|y
expr_stmt|;
name|error
operator|=
name|ft_stroke_border_lineto
argument_list|(
name|border
argument_list|,
operator|&
name|delta
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
name|Exit
label|:
return|return
name|error
return|;
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|ft_stroker_process_corner
name|ft_stroker_process_corner
parameter_list|(
name|FT_Stroker
name|stroker
parameter_list|)
block|{
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
name|FT_Angle
name|turn
decl_stmt|;
name|FT_Int
name|inside_side
decl_stmt|;
name|turn
operator|=
name|FT_Angle_Diff
argument_list|(
name|stroker
operator|->
name|angle_in
argument_list|,
name|stroker
operator|->
name|angle_out
argument_list|)
expr_stmt|;
comment|/* no specific corner processing is required if the turn is 0 */
if|if
condition|(
name|turn
operator|==
literal|0
condition|)
goto|goto
name|Exit
goto|;
comment|/* when we turn to the right, the inside side is 0 */
name|inside_side
operator|=
literal|0
expr_stmt|;
comment|/* otherwise, the inside side is 1 */
if|if
condition|(
name|turn
operator|<
literal|0
condition|)
name|inside_side
operator|=
literal|1
expr_stmt|;
comment|/* process the inside side */
name|error
operator|=
name|ft_stroker_inside
argument_list|(
name|stroker
argument_list|,
name|inside_side
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
comment|/* process the outside side */
name|error
operator|=
name|ft_stroker_outside
argument_list|(
name|stroker
argument_list|,
literal|1
operator|-
name|inside_side
argument_list|)
expr_stmt|;
name|Exit
label|:
return|return
name|error
return|;
block|}
end_function
begin_comment
comment|/* add two points to the left and right borders corresponding to the */
end_comment
begin_comment
comment|/* start of the subpath                                              */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|ft_stroker_subpath_start
name|ft_stroker_subpath_start
parameter_list|(
name|FT_Stroker
name|stroker
parameter_list|,
name|FT_Angle
name|start_angle
parameter_list|)
block|{
name|FT_Vector
name|delta
decl_stmt|;
name|FT_Vector
name|point
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|FT_StrokeBorder
name|border
decl_stmt|;
name|FT_Vector_From_Polar
argument_list|(
operator|&
name|delta
argument_list|,
name|stroker
operator|->
name|radius
argument_list|,
name|start_angle
operator|+
name|FT_ANGLE_PI2
argument_list|)
expr_stmt|;
name|point
operator|.
name|x
operator|=
name|stroker
operator|->
name|center
operator|.
name|x
operator|+
name|delta
operator|.
name|x
expr_stmt|;
name|point
operator|.
name|y
operator|=
name|stroker
operator|->
name|center
operator|.
name|y
operator|+
name|delta
operator|.
name|y
expr_stmt|;
name|border
operator|=
name|stroker
operator|->
name|borders
expr_stmt|;
name|error
operator|=
name|ft_stroke_border_moveto
argument_list|(
name|border
argument_list|,
operator|&
name|point
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|point
operator|.
name|x
operator|=
name|stroker
operator|->
name|center
operator|.
name|x
operator|-
name|delta
operator|.
name|x
expr_stmt|;
name|point
operator|.
name|y
operator|=
name|stroker
operator|->
name|center
operator|.
name|y
operator|-
name|delta
operator|.
name|y
expr_stmt|;
name|border
operator|++
expr_stmt|;
name|error
operator|=
name|ft_stroke_border_moveto
argument_list|(
name|border
argument_list|,
operator|&
name|point
argument_list|)
expr_stmt|;
comment|/* save angle for last cap */
name|stroker
operator|->
name|subpath_angle
operator|=
name|start_angle
expr_stmt|;
name|stroker
operator|->
name|first_point
operator|=
name|FALSE
expr_stmt|;
name|Exit
label|:
return|return
name|error
return|;
block|}
end_function
begin_comment
comment|/* documentation is in ftstroke.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_Stroker_LineTo
argument_list|(
argument|FT_Stroker  stroker
argument_list|,
argument|FT_Vector*  to
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
name|FT_StrokeBorder
name|border
decl_stmt|;
name|FT_Vector
name|delta
decl_stmt|;
name|FT_Angle
name|angle
decl_stmt|;
name|FT_Int
name|side
decl_stmt|;
name|delta
operator|.
name|x
operator|=
name|to
operator|->
name|x
operator|-
name|stroker
operator|->
name|center
operator|.
name|x
expr_stmt|;
name|delta
operator|.
name|y
operator|=
name|to
operator|->
name|y
operator|-
name|stroker
operator|->
name|center
operator|.
name|y
expr_stmt|;
name|angle
operator|=
name|FT_Atan2
argument_list|(
name|delta
operator|.
name|x
argument_list|,
name|delta
operator|.
name|y
argument_list|)
expr_stmt|;
name|FT_Vector_From_Polar
argument_list|(
operator|&
name|delta
argument_list|,
name|stroker
operator|->
name|radius
argument_list|,
name|angle
operator|+
name|FT_ANGLE_PI2
argument_list|)
expr_stmt|;
comment|/* process corner if necessary */
if|if
condition|(
name|stroker
operator|->
name|first_point
condition|)
block|{
comment|/* This is the first segment of a subpath.  We need to     */
comment|/* add a point to each border at their respective starting */
comment|/* point locations.                                        */
name|error
operator|=
name|ft_stroker_subpath_start
argument_list|(
name|stroker
argument_list|,
name|angle
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
block|}
else|else
block|{
comment|/* process the current corner */
name|stroker
operator|->
name|angle_out
operator|=
name|angle
expr_stmt|;
name|error
operator|=
name|ft_stroker_process_corner
argument_list|(
name|stroker
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
block|}
comment|/* now add a line segment to both the `inside' and `outside' paths */
for|for
control|(
name|border
operator|=
name|stroker
operator|->
name|borders
operator|,
name|side
operator|=
literal|1
init|;
name|side
operator|>=
literal|0
condition|;
name|side
operator|--
operator|,
name|border
operator|++
control|)
block|{
name|FT_Vector
name|point
decl_stmt|;
name|point
operator|.
name|x
operator|=
name|to
operator|->
name|x
operator|+
name|delta
operator|.
name|x
expr_stmt|;
name|point
operator|.
name|y
operator|=
name|to
operator|->
name|y
operator|+
name|delta
operator|.
name|y
expr_stmt|;
name|error
operator|=
name|ft_stroke_border_lineto
argument_list|(
name|border
argument_list|,
operator|&
name|point
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|delta
operator|.
name|x
operator|=
operator|-
name|delta
operator|.
name|x
expr_stmt|;
name|delta
operator|.
name|y
operator|=
operator|-
name|delta
operator|.
name|y
expr_stmt|;
block|}
name|stroker
operator|->
name|angle_in
operator|=
name|angle
expr_stmt|;
name|stroker
operator|->
name|center
operator|=
operator|*
name|to
expr_stmt|;
name|Exit
label|:
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/* documentation is in ftstroke.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_Stroker_ConicTo
argument_list|(
argument|FT_Stroker  stroker
argument_list|,
argument|FT_Vector*  control
argument_list|,
argument|FT_Vector*  to
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
name|FT_Vector
name|bez_stack
index|[
literal|34
index|]
decl_stmt|;
name|FT_Vector
modifier|*
name|arc
decl_stmt|;
name|FT_Vector
modifier|*
name|limit
init|=
name|bez_stack
operator|+
literal|30
decl_stmt|;
name|FT_Angle
name|start_angle
decl_stmt|;
name|FT_Bool
name|first_arc
init|=
name|TRUE
decl_stmt|;
name|arc
operator|=
name|bez_stack
expr_stmt|;
name|arc
index|[
literal|0
index|]
operator|=
operator|*
name|to
expr_stmt|;
name|arc
index|[
literal|1
index|]
operator|=
operator|*
name|control
expr_stmt|;
name|arc
index|[
literal|2
index|]
operator|=
name|stroker
operator|->
name|center
expr_stmt|;
while|while
condition|(
name|arc
operator|>=
name|bez_stack
condition|)
block|{
name|FT_Angle
name|angle_in
decl_stmt|,
name|angle_out
decl_stmt|;
name|angle_in
operator|=
name|angle_out
operator|=
literal|0
expr_stmt|;
comment|/* remove compiler warnings */
if|if
condition|(
name|arc
operator|<
name|limit
operator|&&
operator|!
name|ft_conic_is_small_enough
argument_list|(
name|arc
argument_list|,
operator|&
name|angle_in
argument_list|,
operator|&
name|angle_out
argument_list|)
condition|)
block|{
name|ft_conic_split
argument_list|(
name|arc
argument_list|)
expr_stmt|;
name|arc
operator|+=
literal|2
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|first_arc
condition|)
block|{
name|first_arc
operator|=
name|FALSE
expr_stmt|;
name|start_angle
operator|=
name|angle_in
expr_stmt|;
comment|/* process corner if necessary */
if|if
condition|(
name|stroker
operator|->
name|first_point
condition|)
name|error
operator|=
name|ft_stroker_subpath_start
argument_list|(
name|stroker
argument_list|,
name|start_angle
argument_list|)
expr_stmt|;
else|else
block|{
name|stroker
operator|->
name|angle_out
operator|=
name|start_angle
expr_stmt|;
name|error
operator|=
name|ft_stroker_process_corner
argument_list|(
name|stroker
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* the arc's angle is small enough; we can add it directly to each */
comment|/* border                                                          */
block|{
name|FT_Vector
name|ctrl
decl_stmt|,
name|end
decl_stmt|;
name|FT_Angle
name|theta
decl_stmt|,
name|phi
decl_stmt|,
name|rotate
decl_stmt|;
name|FT_Fixed
name|length
decl_stmt|;
name|FT_Int
name|side
decl_stmt|;
name|theta
operator|=
name|FT_Angle_Diff
argument_list|(
name|angle_in
argument_list|,
name|angle_out
argument_list|)
operator|/
literal|2
expr_stmt|;
name|phi
operator|=
name|angle_in
operator|+
name|theta
expr_stmt|;
name|length
operator|=
name|FT_DivFix
argument_list|(
name|stroker
operator|->
name|radius
argument_list|,
name|FT_Cos
argument_list|(
name|theta
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|side
operator|=
literal|0
init|;
name|side
operator|<=
literal|1
condition|;
name|side
operator|++
control|)
block|{
name|rotate
operator|=
name|FT_SIDE_TO_ROTATE
argument_list|(
name|side
argument_list|)
expr_stmt|;
comment|/* compute control point */
name|FT_Vector_From_Polar
argument_list|(
operator|&
name|ctrl
argument_list|,
name|length
argument_list|,
name|phi
operator|+
name|rotate
argument_list|)
expr_stmt|;
name|ctrl
operator|.
name|x
operator|+=
name|arc
index|[
literal|1
index|]
operator|.
name|x
expr_stmt|;
name|ctrl
operator|.
name|y
operator|+=
name|arc
index|[
literal|1
index|]
operator|.
name|y
expr_stmt|;
comment|/* compute end point */
name|FT_Vector_From_Polar
argument_list|(
operator|&
name|end
argument_list|,
name|stroker
operator|->
name|radius
argument_list|,
name|angle_out
operator|+
name|rotate
argument_list|)
expr_stmt|;
name|end
operator|.
name|x
operator|+=
name|arc
index|[
literal|0
index|]
operator|.
name|x
expr_stmt|;
name|end
operator|.
name|y
operator|+=
name|arc
index|[
literal|0
index|]
operator|.
name|y
expr_stmt|;
name|error
operator|=
name|ft_stroke_border_conicto
argument_list|(
name|stroker
operator|->
name|borders
operator|+
name|side
argument_list|,
operator|&
name|ctrl
argument_list|,
operator|&
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
block|}
block|}
name|arc
operator|-=
literal|2
expr_stmt|;
if|if
condition|(
name|arc
operator|<
name|bez_stack
condition|)
name|stroker
operator|->
name|angle_in
operator|=
name|angle_out
expr_stmt|;
block|}
name|stroker
operator|->
name|center
operator|=
operator|*
name|to
expr_stmt|;
name|Exit
label|:
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/* documentation is in ftstroke.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_Stroker_CubicTo
argument_list|(
argument|FT_Stroker  stroker
argument_list|,
argument|FT_Vector*  control1
argument_list|,
argument|FT_Vector*  control2
argument_list|,
argument|FT_Vector*  to
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
name|FT_Vector
name|bez_stack
index|[
literal|37
index|]
decl_stmt|;
name|FT_Vector
modifier|*
name|arc
decl_stmt|;
name|FT_Vector
modifier|*
name|limit
init|=
name|bez_stack
operator|+
literal|32
decl_stmt|;
name|FT_Angle
name|start_angle
decl_stmt|;
name|FT_Bool
name|first_arc
init|=
name|TRUE
decl_stmt|;
name|arc
operator|=
name|bez_stack
expr_stmt|;
name|arc
index|[
literal|0
index|]
operator|=
operator|*
name|to
expr_stmt|;
name|arc
index|[
literal|1
index|]
operator|=
operator|*
name|control2
expr_stmt|;
name|arc
index|[
literal|2
index|]
operator|=
operator|*
name|control1
expr_stmt|;
name|arc
index|[
literal|3
index|]
operator|=
name|stroker
operator|->
name|center
expr_stmt|;
while|while
condition|(
name|arc
operator|>=
name|bez_stack
condition|)
block|{
name|FT_Angle
name|angle_in
decl_stmt|,
name|angle_mid
decl_stmt|,
name|angle_out
decl_stmt|;
comment|/* remove compiler warnings */
name|angle_in
operator|=
name|angle_out
operator|=
name|angle_mid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|arc
operator|<
name|limit
operator|&&
operator|!
name|ft_cubic_is_small_enough
argument_list|(
name|arc
argument_list|,
operator|&
name|angle_in
argument_list|,
operator|&
name|angle_mid
argument_list|,
operator|&
name|angle_out
argument_list|)
condition|)
block|{
name|ft_cubic_split
argument_list|(
name|arc
argument_list|)
expr_stmt|;
name|arc
operator|+=
literal|3
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|first_arc
condition|)
block|{
name|first_arc
operator|=
name|FALSE
expr_stmt|;
comment|/* process corner if necessary */
name|start_angle
operator|=
name|angle_in
expr_stmt|;
if|if
condition|(
name|stroker
operator|->
name|first_point
condition|)
name|error
operator|=
name|ft_stroker_subpath_start
argument_list|(
name|stroker
argument_list|,
name|start_angle
argument_list|)
expr_stmt|;
else|else
block|{
name|stroker
operator|->
name|angle_out
operator|=
name|start_angle
expr_stmt|;
name|error
operator|=
name|ft_stroker_process_corner
argument_list|(
name|stroker
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
block|}
comment|/* the arc's angle is small enough; we can add it directly to each */
comment|/* border                                                          */
block|{
name|FT_Vector
name|ctrl1
decl_stmt|,
name|ctrl2
decl_stmt|,
name|end
decl_stmt|;
name|FT_Angle
name|theta1
decl_stmt|,
name|phi1
decl_stmt|,
name|theta2
decl_stmt|,
name|phi2
decl_stmt|,
name|rotate
decl_stmt|;
name|FT_Fixed
name|length1
decl_stmt|,
name|length2
decl_stmt|;
name|FT_Int
name|side
decl_stmt|;
name|theta1
operator|=
name|ft_pos_abs
argument_list|(
name|angle_mid
operator|-
name|angle_in
argument_list|)
operator|/
literal|2
expr_stmt|;
name|theta2
operator|=
name|ft_pos_abs
argument_list|(
name|angle_out
operator|-
name|angle_mid
argument_list|)
operator|/
literal|2
expr_stmt|;
name|phi1
operator|=
operator|(
name|angle_mid
operator|+
name|angle_in
operator|)
operator|/
literal|2
expr_stmt|;
name|phi2
operator|=
operator|(
name|angle_mid
operator|+
name|angle_out
operator|)
operator|/
literal|2
expr_stmt|;
name|length1
operator|=
name|FT_DivFix
argument_list|(
name|stroker
operator|->
name|radius
argument_list|,
name|FT_Cos
argument_list|(
name|theta1
argument_list|)
argument_list|)
expr_stmt|;
name|length2
operator|=
name|FT_DivFix
argument_list|(
name|stroker
operator|->
name|radius
argument_list|,
name|FT_Cos
argument_list|(
name|theta2
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|side
operator|=
literal|0
init|;
name|side
operator|<=
literal|1
condition|;
name|side
operator|++
control|)
block|{
name|rotate
operator|=
name|FT_SIDE_TO_ROTATE
argument_list|(
name|side
argument_list|)
expr_stmt|;
comment|/* compute control points */
name|FT_Vector_From_Polar
argument_list|(
operator|&
name|ctrl1
argument_list|,
name|length1
argument_list|,
name|phi1
operator|+
name|rotate
argument_list|)
expr_stmt|;
name|ctrl1
operator|.
name|x
operator|+=
name|arc
index|[
literal|2
index|]
operator|.
name|x
expr_stmt|;
name|ctrl1
operator|.
name|y
operator|+=
name|arc
index|[
literal|2
index|]
operator|.
name|y
expr_stmt|;
name|FT_Vector_From_Polar
argument_list|(
operator|&
name|ctrl2
argument_list|,
name|length2
argument_list|,
name|phi2
operator|+
name|rotate
argument_list|)
expr_stmt|;
name|ctrl2
operator|.
name|x
operator|+=
name|arc
index|[
literal|1
index|]
operator|.
name|x
expr_stmt|;
name|ctrl2
operator|.
name|y
operator|+=
name|arc
index|[
literal|1
index|]
operator|.
name|y
expr_stmt|;
comment|/* compute end point */
name|FT_Vector_From_Polar
argument_list|(
operator|&
name|end
argument_list|,
name|stroker
operator|->
name|radius
argument_list|,
name|angle_out
operator|+
name|rotate
argument_list|)
expr_stmt|;
name|end
operator|.
name|x
operator|+=
name|arc
index|[
literal|0
index|]
operator|.
name|x
expr_stmt|;
name|end
operator|.
name|y
operator|+=
name|arc
index|[
literal|0
index|]
operator|.
name|y
expr_stmt|;
name|error
operator|=
name|ft_stroke_border_cubicto
argument_list|(
name|stroker
operator|->
name|borders
operator|+
name|side
argument_list|,
operator|&
name|ctrl1
argument_list|,
operator|&
name|ctrl2
argument_list|,
operator|&
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
block|}
block|}
name|arc
operator|-=
literal|3
expr_stmt|;
if|if
condition|(
name|arc
operator|<
name|bez_stack
condition|)
name|stroker
operator|->
name|angle_in
operator|=
name|angle_out
expr_stmt|;
block|}
name|stroker
operator|->
name|center
operator|=
operator|*
name|to
expr_stmt|;
name|Exit
label|:
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/* documentation is in ftstroke.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_Stroker_BeginSubPath
argument_list|(
argument|FT_Stroker  stroker
argument_list|,
argument|FT_Vector*  to
argument_list|,
argument|FT_Bool     open
argument_list|)
end_macro
begin_block
block|{
comment|/* We cannot process the first point, because there is not enough      */
comment|/* information regarding its corner/cap.  The latter will be processed */
comment|/* in the `FT_Stroker_EndSubPath' routine.                             */
comment|/*                                                                     */
name|stroker
operator|->
name|first_point
operator|=
name|TRUE
expr_stmt|;
name|stroker
operator|->
name|center
operator|=
operator|*
name|to
expr_stmt|;
name|stroker
operator|->
name|subpath_open
operator|=
name|open
expr_stmt|;
comment|/* record the subpath start point for each border */
name|stroker
operator|->
name|subpath_start
operator|=
operator|*
name|to
expr_stmt|;
return|return
name|FT_Err_Ok
return|;
block|}
end_block
begin_function
specifier|static
name|FT_Error
DECL|function|ft_stroker_add_reverse_left
name|ft_stroker_add_reverse_left
parameter_list|(
name|FT_Stroker
name|stroker
parameter_list|,
name|FT_Bool
name|open
parameter_list|)
block|{
name|FT_StrokeBorder
name|right
init|=
name|stroker
operator|->
name|borders
operator|+
literal|0
decl_stmt|;
name|FT_StrokeBorder
name|left
init|=
name|stroker
operator|->
name|borders
operator|+
literal|1
decl_stmt|;
name|FT_Int
name|new_points
decl_stmt|;
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
name|FT_ASSERT
argument_list|(
name|left
operator|->
name|start
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|new_points
operator|=
name|left
operator|->
name|num_points
operator|-
name|left
operator|->
name|start
expr_stmt|;
if|if
condition|(
name|new_points
operator|>
literal|0
condition|)
block|{
name|error
operator|=
name|ft_stroke_border_grow
argument_list|(
name|right
argument_list|,
operator|(
name|FT_UInt
operator|)
name|new_points
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
block|{
name|FT_Vector
modifier|*
name|dst_point
init|=
name|right
operator|->
name|points
operator|+
name|right
operator|->
name|num_points
decl_stmt|;
name|FT_Byte
modifier|*
name|dst_tag
init|=
name|right
operator|->
name|tags
operator|+
name|right
operator|->
name|num_points
decl_stmt|;
name|FT_Vector
modifier|*
name|src_point
init|=
name|left
operator|->
name|points
operator|+
name|left
operator|->
name|num_points
operator|-
literal|1
decl_stmt|;
name|FT_Byte
modifier|*
name|src_tag
init|=
name|left
operator|->
name|tags
operator|+
name|left
operator|->
name|num_points
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|src_point
operator|>=
name|left
operator|->
name|points
operator|+
name|left
operator|->
name|start
condition|)
block|{
operator|*
name|dst_point
operator|=
operator|*
name|src_point
expr_stmt|;
operator|*
name|dst_tag
operator|=
operator|*
name|src_tag
expr_stmt|;
if|if
condition|(
name|open
condition|)
name|dst_tag
index|[
literal|0
index|]
operator|&=
operator|~
name|FT_STROKE_TAG_BEGIN_END
expr_stmt|;
else|else
block|{
name|FT_Byte
name|ttag
init|=
call|(
name|FT_Byte
call|)
argument_list|(
name|dst_tag
index|[
literal|0
index|]
operator|&
name|FT_STROKE_TAG_BEGIN_END
argument_list|)
decl_stmt|;
comment|/* switch begin/end tags if necessary */
if|if
condition|(
name|ttag
operator|==
name|FT_STROKE_TAG_BEGIN
operator|||
name|ttag
operator|==
name|FT_STROKE_TAG_END
condition|)
name|dst_tag
index|[
literal|0
index|]
operator|^=
name|FT_STROKE_TAG_BEGIN_END
expr_stmt|;
block|}
name|src_point
operator|--
expr_stmt|;
name|src_tag
operator|--
expr_stmt|;
name|dst_point
operator|++
expr_stmt|;
name|dst_tag
operator|++
expr_stmt|;
block|}
block|}
name|left
operator|->
name|num_points
operator|=
name|left
operator|->
name|start
expr_stmt|;
name|right
operator|->
name|num_points
operator|+=
name|new_points
expr_stmt|;
name|right
operator|->
name|movable
operator|=
name|FALSE
expr_stmt|;
name|left
operator|->
name|movable
operator|=
name|FALSE
expr_stmt|;
block|}
name|Exit
label|:
return|return
name|error
return|;
block|}
end_function
begin_comment
comment|/* documentation is in ftstroke.h */
end_comment
begin_comment
comment|/* there's a lot of magic in this function! */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_Stroker_EndSubPath
argument_list|(
argument|FT_Stroker  stroker
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
if|if
condition|(
name|stroker
operator|->
name|subpath_open
condition|)
block|{
name|FT_StrokeBorder
name|right
init|=
name|stroker
operator|->
name|borders
decl_stmt|;
comment|/* All right, this is an opened path, we need to add a cap between */
comment|/* right& left, add the reverse of left, then add a final cap     */
comment|/* between left& right.                                           */
name|error
operator|=
name|ft_stroker_cap
argument_list|(
name|stroker
argument_list|,
name|stroker
operator|->
name|angle_in
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
comment|/* add reversed points from `left' to `right' */
name|error
operator|=
name|ft_stroker_add_reverse_left
argument_list|(
name|stroker
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
comment|/* now add the final cap */
name|stroker
operator|->
name|center
operator|=
name|stroker
operator|->
name|subpath_start
expr_stmt|;
name|error
operator|=
name|ft_stroker_cap
argument_list|(
name|stroker
argument_list|,
name|stroker
operator|->
name|subpath_angle
operator|+
name|FT_ANGLE_PI
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
comment|/* Now end the right subpath accordingly.  The left one is */
comment|/* rewind and doesn't need further processing.             */
name|ft_stroke_border_close
argument_list|(
name|right
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|FT_Angle
name|turn
decl_stmt|;
name|FT_Int
name|inside_side
decl_stmt|;
comment|/* close the path if needed */
if|if
condition|(
name|stroker
operator|->
name|center
operator|.
name|x
operator|!=
name|stroker
operator|->
name|subpath_start
operator|.
name|x
operator|||
name|stroker
operator|->
name|center
operator|.
name|y
operator|!=
name|stroker
operator|->
name|subpath_start
operator|.
name|y
condition|)
block|{
name|error
operator|=
name|FT_Stroker_LineTo
argument_list|(
name|stroker
argument_list|,
operator|&
name|stroker
operator|->
name|subpath_start
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
block|}
comment|/* process the corner */
name|stroker
operator|->
name|angle_out
operator|=
name|stroker
operator|->
name|subpath_angle
expr_stmt|;
name|turn
operator|=
name|FT_Angle_Diff
argument_list|(
name|stroker
operator|->
name|angle_in
argument_list|,
name|stroker
operator|->
name|angle_out
argument_list|)
expr_stmt|;
comment|/* no specific corner processing is required if the turn is 0 */
if|if
condition|(
name|turn
operator|!=
literal|0
condition|)
block|{
comment|/* when we turn to the right, the inside side is 0 */
name|inside_side
operator|=
literal|0
expr_stmt|;
comment|/* otherwise, the inside side is 1 */
if|if
condition|(
name|turn
operator|<
literal|0
condition|)
name|inside_side
operator|=
literal|1
expr_stmt|;
name|error
operator|=
name|ft_stroker_inside
argument_list|(
name|stroker
argument_list|,
name|inside_side
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
comment|/* process the outside side */
name|error
operator|=
name|ft_stroker_outside
argument_list|(
name|stroker
argument_list|,
literal|1
operator|-
name|inside_side
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
block|}
comment|/* then end our two subpaths */
name|ft_stroke_border_close
argument_list|(
name|stroker
operator|->
name|borders
operator|+
literal|0
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|ft_stroke_border_close
argument_list|(
name|stroker
operator|->
name|borders
operator|+
literal|1
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|Exit
label|:
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/* documentation is in ftstroke.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_Stroker_GetBorderCounts
argument_list|(
argument|FT_Stroker        stroker
argument_list|,
argument|FT_StrokerBorder  border
argument_list|,
argument|FT_UInt          *anum_points
argument_list|,
argument|FT_UInt          *anum_contours
argument_list|)
end_macro
begin_block
block|{
name|FT_UInt
name|num_points
init|=
literal|0
decl_stmt|,
name|num_contours
init|=
literal|0
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
if|if
condition|(
operator|!
name|stroker
operator|||
name|border
operator|>
literal|1
condition|)
block|{
name|error
operator|=
name|FT_Err_Invalid_Argument
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|error
operator|=
name|ft_stroke_border_get_counts
argument_list|(
name|stroker
operator|->
name|borders
operator|+
name|border
argument_list|,
operator|&
name|num_points
argument_list|,
operator|&
name|num_contours
argument_list|)
expr_stmt|;
name|Exit
label|:
if|if
condition|(
name|anum_points
condition|)
operator|*
name|anum_points
operator|=
name|num_points
expr_stmt|;
if|if
condition|(
name|anum_contours
condition|)
operator|*
name|anum_contours
operator|=
name|num_contours
expr_stmt|;
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/* documentation is in ftstroke.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_Stroker_GetCounts
argument_list|(
argument|FT_Stroker  stroker
argument_list|,
argument|FT_UInt    *anum_points
argument_list|,
argument|FT_UInt    *anum_contours
argument_list|)
end_macro
begin_block
block|{
name|FT_UInt
name|count1
decl_stmt|,
name|count2
decl_stmt|,
name|num_points
init|=
literal|0
decl_stmt|;
name|FT_UInt
name|count3
decl_stmt|,
name|count4
decl_stmt|,
name|num_contours
init|=
literal|0
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|error
operator|=
name|ft_stroke_border_get_counts
argument_list|(
name|stroker
operator|->
name|borders
operator|+
literal|0
argument_list|,
operator|&
name|count1
argument_list|,
operator|&
name|count2
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|error
operator|=
name|ft_stroke_border_get_counts
argument_list|(
name|stroker
operator|->
name|borders
operator|+
literal|1
argument_list|,
operator|&
name|count3
argument_list|,
operator|&
name|count4
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|num_points
operator|=
name|count1
operator|+
name|count3
expr_stmt|;
name|num_contours
operator|=
name|count2
operator|+
name|count4
expr_stmt|;
name|Exit
label|:
operator|*
name|anum_points
operator|=
name|num_points
expr_stmt|;
operator|*
name|anum_contours
operator|=
name|num_contours
expr_stmt|;
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/* documentation is in ftstroke.h */
end_comment
begin_macro
name|FT_EXPORT_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|FT_Stroker_ExportBorder
name|FT_Stroker_ExportBorder
argument_list|(
argument|FT_Stroker        stroker
argument_list|,
argument|FT_StrokerBorder  border
argument_list|,
argument|FT_Outline*       outline
argument_list|)
end_macro
begin_block
block|{
if|if
condition|(
name|border
operator|==
name|FT_STROKER_BORDER_LEFT
operator|||
name|border
operator|==
name|FT_STROKER_BORDER_RIGHT
condition|)
block|{
name|FT_StrokeBorder
name|sborder
init|=
operator|&
name|stroker
operator|->
name|borders
index|[
name|border
index|]
decl_stmt|;
if|if
condition|(
name|sborder
operator|->
name|valid
condition|)
name|ft_stroke_border_export
argument_list|(
name|sborder
argument_list|,
name|outline
argument_list|)
expr_stmt|;
block|}
block|}
end_block
begin_comment
comment|/* documentation is in ftstroke.h */
end_comment
begin_macro
name|FT_EXPORT_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|FT_Stroker_Export
name|FT_Stroker_Export
argument_list|(
argument|FT_Stroker   stroker
argument_list|,
argument|FT_Outline*  outline
argument_list|)
end_macro
begin_block
block|{
name|FT_Stroker_ExportBorder
argument_list|(
name|stroker
argument_list|,
name|FT_STROKER_BORDER_LEFT
argument_list|,
name|outline
argument_list|)
expr_stmt|;
name|FT_Stroker_ExportBorder
argument_list|(
name|stroker
argument_list|,
name|FT_STROKER_BORDER_RIGHT
argument_list|,
name|outline
argument_list|)
expr_stmt|;
block|}
end_block
begin_comment
comment|/* documentation is in ftstroke.h */
end_comment
begin_comment
comment|/*    *  The following is very similar to FT_Outline_Decompose, except    *  that we do support opened paths, and do not scale the outline.    */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_Stroker_ParseOutline
argument_list|(
argument|FT_Stroker   stroker
argument_list|,
argument|FT_Outline*  outline
argument_list|,
argument|FT_Bool      opened
argument_list|)
end_macro
begin_block
block|{
name|FT_Vector
name|v_last
decl_stmt|;
name|FT_Vector
name|v_control
decl_stmt|;
name|FT_Vector
name|v_start
decl_stmt|;
name|FT_Vector
modifier|*
name|point
decl_stmt|;
name|FT_Vector
modifier|*
name|limit
decl_stmt|;
name|char
modifier|*
name|tags
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|FT_Int
name|n
decl_stmt|;
comment|/* index of contour in outline     */
name|FT_UInt
name|first
decl_stmt|;
comment|/* index of first point in contour */
name|FT_Int
name|tag
decl_stmt|;
comment|/* current point's state           */
if|if
condition|(
operator|!
name|outline
operator|||
operator|!
name|stroker
condition|)
return|return
name|FT_Err_Invalid_Argument
return|;
name|FT_Stroker_Rewind
argument_list|(
name|stroker
argument_list|)
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|outline
operator|->
name|n_contours
condition|;
name|n
operator|++
control|)
block|{
name|FT_UInt
name|last
decl_stmt|;
comment|/* index of last point in contour */
name|last
operator|=
name|outline
operator|->
name|contours
index|[
name|n
index|]
expr_stmt|;
name|limit
operator|=
name|outline
operator|->
name|points
operator|+
name|last
expr_stmt|;
comment|/* skip empty points; we don't stroke these */
if|if
condition|(
name|last
operator|<=
name|first
condition|)
block|{
name|first
operator|=
name|last
operator|+
literal|1
expr_stmt|;
continue|continue;
block|}
name|v_start
operator|=
name|outline
operator|->
name|points
index|[
name|first
index|]
expr_stmt|;
name|v_last
operator|=
name|outline
operator|->
name|points
index|[
name|last
index|]
expr_stmt|;
name|v_control
operator|=
name|v_start
expr_stmt|;
name|point
operator|=
name|outline
operator|->
name|points
operator|+
name|first
expr_stmt|;
name|tags
operator|=
name|outline
operator|->
name|tags
operator|+
name|first
expr_stmt|;
name|tag
operator|=
name|FT_CURVE_TAG
argument_list|(
name|tags
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* A contour cannot start with a cubic control point! */
if|if
condition|(
name|tag
operator|==
name|FT_CURVE_TAG_CUBIC
condition|)
goto|goto
name|Invalid_Outline
goto|;
comment|/* check first point to determine origin */
if|if
condition|(
name|tag
operator|==
name|FT_CURVE_TAG_CONIC
condition|)
block|{
comment|/* First point is conic control.  Yes, this happens. */
if|if
condition|(
name|FT_CURVE_TAG
argument_list|(
name|outline
operator|->
name|tags
index|[
name|last
index|]
argument_list|)
operator|==
name|FT_CURVE_TAG_ON
condition|)
block|{
comment|/* start at last point if it is on the curve */
name|v_start
operator|=
name|v_last
expr_stmt|;
name|limit
operator|--
expr_stmt|;
block|}
else|else
block|{
comment|/* if both first and last points are conic,         */
comment|/* start at their middle and record its position    */
comment|/* for closure                                      */
name|v_start
operator|.
name|x
operator|=
operator|(
name|v_start
operator|.
name|x
operator|+
name|v_last
operator|.
name|x
operator|)
operator|/
literal|2
expr_stmt|;
name|v_start
operator|.
name|y
operator|=
operator|(
name|v_start
operator|.
name|y
operator|+
name|v_last
operator|.
name|y
operator|)
operator|/
literal|2
expr_stmt|;
name|v_last
operator|=
name|v_start
expr_stmt|;
block|}
name|point
operator|--
expr_stmt|;
name|tags
operator|--
expr_stmt|;
block|}
name|error
operator|=
name|FT_Stroker_BeginSubPath
argument_list|(
name|stroker
argument_list|,
operator|&
name|v_start
argument_list|,
name|opened
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
while|while
condition|(
name|point
operator|<
name|limit
condition|)
block|{
name|point
operator|++
expr_stmt|;
name|tags
operator|++
expr_stmt|;
name|tag
operator|=
name|FT_CURVE_TAG
argument_list|(
name|tags
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tag
condition|)
block|{
case|case
name|FT_CURVE_TAG_ON
case|:
comment|/* emit a single line_to */
block|{
name|FT_Vector
name|vec
decl_stmt|;
name|vec
operator|.
name|x
operator|=
name|point
operator|->
name|x
expr_stmt|;
name|vec
operator|.
name|y
operator|=
name|point
operator|->
name|y
expr_stmt|;
name|error
operator|=
name|FT_Stroker_LineTo
argument_list|(
name|stroker
argument_list|,
operator|&
name|vec
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
continue|continue;
block|}
case|case
name|FT_CURVE_TAG_CONIC
case|:
comment|/* consume conic arcs */
name|v_control
operator|.
name|x
operator|=
name|point
operator|->
name|x
expr_stmt|;
name|v_control
operator|.
name|y
operator|=
name|point
operator|->
name|y
expr_stmt|;
name|Do_Conic
label|:
if|if
condition|(
name|point
operator|<
name|limit
condition|)
block|{
name|FT_Vector
name|vec
decl_stmt|;
name|FT_Vector
name|v_middle
decl_stmt|;
name|point
operator|++
expr_stmt|;
name|tags
operator|++
expr_stmt|;
name|tag
operator|=
name|FT_CURVE_TAG
argument_list|(
name|tags
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|vec
operator|=
name|point
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|tag
operator|==
name|FT_CURVE_TAG_ON
condition|)
block|{
name|error
operator|=
name|FT_Stroker_ConicTo
argument_list|(
name|stroker
argument_list|,
operator|&
name|v_control
argument_list|,
operator|&
name|vec
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
continue|continue;
block|}
if|if
condition|(
name|tag
operator|!=
name|FT_CURVE_TAG_CONIC
condition|)
goto|goto
name|Invalid_Outline
goto|;
name|v_middle
operator|.
name|x
operator|=
operator|(
name|v_control
operator|.
name|x
operator|+
name|vec
operator|.
name|x
operator|)
operator|/
literal|2
expr_stmt|;
name|v_middle
operator|.
name|y
operator|=
operator|(
name|v_control
operator|.
name|y
operator|+
name|vec
operator|.
name|y
operator|)
operator|/
literal|2
expr_stmt|;
name|error
operator|=
name|FT_Stroker_ConicTo
argument_list|(
name|stroker
argument_list|,
operator|&
name|v_control
argument_list|,
operator|&
name|v_middle
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|v_control
operator|=
name|vec
expr_stmt|;
goto|goto
name|Do_Conic
goto|;
block|}
name|error
operator|=
name|FT_Stroker_ConicTo
argument_list|(
name|stroker
argument_list|,
operator|&
name|v_control
argument_list|,
operator|&
name|v_start
argument_list|)
expr_stmt|;
goto|goto
name|Close
goto|;
default|default:
comment|/* FT_CURVE_TAG_CUBIC */
block|{
name|FT_Vector
name|vec1
decl_stmt|,
name|vec2
decl_stmt|;
if|if
condition|(
name|point
operator|+
literal|1
operator|>
name|limit
operator|||
name|FT_CURVE_TAG
argument_list|(
name|tags
index|[
literal|1
index|]
argument_list|)
operator|!=
name|FT_CURVE_TAG_CUBIC
condition|)
goto|goto
name|Invalid_Outline
goto|;
name|point
operator|+=
literal|2
expr_stmt|;
name|tags
operator|+=
literal|2
expr_stmt|;
name|vec1
operator|=
name|point
index|[
operator|-
literal|2
index|]
expr_stmt|;
name|vec2
operator|=
name|point
index|[
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|point
operator|<=
name|limit
condition|)
block|{
name|FT_Vector
name|vec
decl_stmt|;
name|vec
operator|=
name|point
index|[
literal|0
index|]
expr_stmt|;
name|error
operator|=
name|FT_Stroker_CubicTo
argument_list|(
name|stroker
argument_list|,
operator|&
name|vec1
argument_list|,
operator|&
name|vec2
argument_list|,
operator|&
name|vec
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
continue|continue;
block|}
name|error
operator|=
name|FT_Stroker_CubicTo
argument_list|(
name|stroker
argument_list|,
operator|&
name|vec1
argument_list|,
operator|&
name|vec2
argument_list|,
operator|&
name|v_start
argument_list|)
expr_stmt|;
goto|goto
name|Close
goto|;
block|}
block|}
block|}
name|Close
label|:
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|error
operator|=
name|FT_Stroker_EndSubPath
argument_list|(
name|stroker
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|first
operator|=
name|last
operator|+
literal|1
expr_stmt|;
block|}
return|return
name|FT_Err_Ok
return|;
name|Exit
label|:
return|return
name|error
return|;
name|Invalid_Outline
label|:
return|return
name|FT_Err_Invalid_Outline
return|;
block|}
end_block
begin_decl_stmt
specifier|extern
specifier|const
name|FT_Glyph_Class
name|ft_outline_glyph_class
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* documentation is in ftstroke.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_Glyph_Stroke
argument_list|(
argument|FT_Glyph    *pglyph
argument_list|,
argument|FT_Stroker   stroker
argument_list|,
argument|FT_Bool      destroy
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
init|=
name|FT_Err_Invalid_Argument
decl_stmt|;
name|FT_Glyph
name|glyph
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|pglyph
operator|==
name|NULL
condition|)
goto|goto
name|Exit
goto|;
name|glyph
operator|=
operator|*
name|pglyph
expr_stmt|;
if|if
condition|(
name|glyph
operator|==
name|NULL
operator|||
name|glyph
operator|->
name|clazz
operator|!=
operator|&
name|ft_outline_glyph_class
condition|)
goto|goto
name|Exit
goto|;
block|{
name|FT_Glyph
name|copy
decl_stmt|;
name|error
operator|=
name|FT_Glyph_Copy
argument_list|(
name|glyph
argument_list|,
operator|&
name|copy
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|glyph
operator|=
name|copy
expr_stmt|;
block|}
block|{
name|FT_OutlineGlyph
name|oglyph
init|=
operator|(
name|FT_OutlineGlyph
operator|)
name|glyph
decl_stmt|;
name|FT_Outline
modifier|*
name|outline
init|=
operator|&
name|oglyph
operator|->
name|outline
decl_stmt|;
name|FT_UInt
name|num_points
decl_stmt|,
name|num_contours
decl_stmt|;
name|error
operator|=
name|FT_Stroker_ParseOutline
argument_list|(
name|stroker
argument_list|,
name|outline
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Fail
goto|;
operator|(
name|void
operator|)
name|FT_Stroker_GetCounts
argument_list|(
name|stroker
argument_list|,
operator|&
name|num_points
argument_list|,
operator|&
name|num_contours
argument_list|)
expr_stmt|;
name|FT_Outline_Done
argument_list|(
name|glyph
operator|->
name|library
argument_list|,
name|outline
argument_list|)
expr_stmt|;
name|error
operator|=
name|FT_Outline_New
argument_list|(
name|glyph
operator|->
name|library
argument_list|,
name|num_points
argument_list|,
name|num_contours
argument_list|,
name|outline
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Fail
goto|;
name|outline
operator|->
name|n_points
operator|=
literal|0
expr_stmt|;
name|outline
operator|->
name|n_contours
operator|=
literal|0
expr_stmt|;
name|FT_Stroker_Export
argument_list|(
name|stroker
argument_list|,
name|outline
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|destroy
condition|)
name|FT_Done_Glyph
argument_list|(
operator|*
name|pglyph
argument_list|)
expr_stmt|;
operator|*
name|pglyph
operator|=
name|glyph
expr_stmt|;
goto|goto
name|Exit
goto|;
name|Fail
label|:
name|FT_Done_Glyph
argument_list|(
name|glyph
argument_list|)
expr_stmt|;
name|glyph
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|destroy
condition|)
operator|*
name|pglyph
operator|=
name|NULL
expr_stmt|;
name|Exit
label|:
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/* documentation is in ftstroke.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_Glyph_StrokeBorder
argument_list|(
argument|FT_Glyph    *pglyph
argument_list|,
argument|FT_Stroker   stroker
argument_list|,
argument|FT_Bool      inside
argument_list|,
argument|FT_Bool      destroy
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
init|=
name|FT_Err_Invalid_Argument
decl_stmt|;
name|FT_Glyph
name|glyph
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|pglyph
operator|==
name|NULL
condition|)
goto|goto
name|Exit
goto|;
name|glyph
operator|=
operator|*
name|pglyph
expr_stmt|;
if|if
condition|(
name|glyph
operator|==
name|NULL
operator|||
name|glyph
operator|->
name|clazz
operator|!=
operator|&
name|ft_outline_glyph_class
condition|)
goto|goto
name|Exit
goto|;
block|{
name|FT_Glyph
name|copy
decl_stmt|;
name|error
operator|=
name|FT_Glyph_Copy
argument_list|(
name|glyph
argument_list|,
operator|&
name|copy
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|glyph
operator|=
name|copy
expr_stmt|;
block|}
block|{
name|FT_OutlineGlyph
name|oglyph
init|=
operator|(
name|FT_OutlineGlyph
operator|)
name|glyph
decl_stmt|;
name|FT_StrokerBorder
name|border
decl_stmt|;
name|FT_Outline
modifier|*
name|outline
init|=
operator|&
name|oglyph
operator|->
name|outline
decl_stmt|;
name|FT_UInt
name|num_points
decl_stmt|,
name|num_contours
decl_stmt|;
name|border
operator|=
name|FT_Outline_GetOutsideBorder
argument_list|(
name|outline
argument_list|)
expr_stmt|;
if|if
condition|(
name|inside
condition|)
block|{
if|if
condition|(
name|border
operator|==
name|FT_STROKER_BORDER_LEFT
condition|)
name|border
operator|=
name|FT_STROKER_BORDER_RIGHT
expr_stmt|;
else|else
name|border
operator|=
name|FT_STROKER_BORDER_LEFT
expr_stmt|;
block|}
name|error
operator|=
name|FT_Stroker_ParseOutline
argument_list|(
name|stroker
argument_list|,
name|outline
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Fail
goto|;
operator|(
name|void
operator|)
name|FT_Stroker_GetBorderCounts
argument_list|(
name|stroker
argument_list|,
name|border
argument_list|,
operator|&
name|num_points
argument_list|,
operator|&
name|num_contours
argument_list|)
expr_stmt|;
name|FT_Outline_Done
argument_list|(
name|glyph
operator|->
name|library
argument_list|,
name|outline
argument_list|)
expr_stmt|;
name|error
operator|=
name|FT_Outline_New
argument_list|(
name|glyph
operator|->
name|library
argument_list|,
name|num_points
argument_list|,
name|num_contours
argument_list|,
name|outline
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Fail
goto|;
name|outline
operator|->
name|n_points
operator|=
literal|0
expr_stmt|;
name|outline
operator|->
name|n_contours
operator|=
literal|0
expr_stmt|;
name|FT_Stroker_ExportBorder
argument_list|(
name|stroker
argument_list|,
name|border
argument_list|,
name|outline
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|destroy
condition|)
name|FT_Done_Glyph
argument_list|(
operator|*
name|pglyph
argument_list|)
expr_stmt|;
operator|*
name|pglyph
operator|=
name|glyph
expr_stmt|;
goto|goto
name|Exit
goto|;
name|Fail
label|:
name|FT_Done_Glyph
argument_list|(
name|glyph
argument_list|)
expr_stmt|;
name|glyph
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|destroy
condition|)
operator|*
name|pglyph
operator|=
name|NULL
expr_stmt|;
name|Exit
label|:
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/* END */
end_comment
end_unit
