begin_unit
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  ftobjs.c                                                               */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*    The FreeType private base classes (body).                            */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,   */
end_comment
begin_comment
comment|/*            2010 by                                                      */
end_comment
begin_comment
comment|/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  This file is part of the FreeType project, and may only be used,       */
end_comment
begin_comment
comment|/*  modified, and distributed under the terms of the FreeType project      */
end_comment
begin_comment
comment|/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
end_comment
begin_comment
comment|/*  this file you indicate that you have read the license and              */
end_comment
begin_comment
comment|/*  understand and accept it fully.                                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<ft2build.h>
end_include
begin_include
include|#
directive|include
include|FT_LIST_H
end_include
begin_include
include|#
directive|include
include|FT_OUTLINE_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_VALIDATE_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_OBJECTS_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_DEBUG_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_RFORK_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_STREAM_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_SFNT_H
end_include
begin_comment
comment|/* for SFNT_Load_Table_Func */
end_comment
begin_include
include|#
directive|include
include|FT_TRUETYPE_TABLES_H
end_include
begin_include
include|#
directive|include
include|FT_TRUETYPE_TAGS_H
end_include
begin_include
include|#
directive|include
include|FT_TRUETYPE_IDS_H
end_include
begin_include
include|#
directive|include
include|FT_OUTLINE_H
end_include
begin_include
include|#
directive|include
include|FT_SERVICE_SFNT_H
end_include
begin_include
include|#
directive|include
include|FT_SERVICE_POSTSCRIPT_NAME_H
end_include
begin_include
include|#
directive|include
include|FT_SERVICE_GLYPH_DICT_H
end_include
begin_include
include|#
directive|include
include|FT_SERVICE_TT_CMAP_H
end_include
begin_include
include|#
directive|include
include|FT_SERVICE_KERNING_H
end_include
begin_include
include|#
directive|include
include|FT_SERVICE_TRUETYPE_ENGINE_H
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|FT_CONFIG_OPTION_MAC_FONTS
end_ifdef
begin_include
include|#
directive|include
file|"ftbase.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|GRID_FIT_METRICS
define|#
directive|define
name|GRID_FIT_METRICS
end_define
begin_macro
DECL|function|FT_BASE_DEF
name|FT_BASE_DEF
argument_list|(
argument|FT_Pointer
argument_list|)
end_macro
begin_macro
name|ft_service_list_lookup
argument_list|(
argument|FT_ServiceDesc  service_descriptors
argument_list|,
argument|const char*     service_id
argument_list|)
end_macro
begin_block
block|{
name|FT_Pointer
name|result
init|=
name|NULL
decl_stmt|;
name|FT_ServiceDesc
name|desc
init|=
name|service_descriptors
decl_stmt|;
if|if
condition|(
name|desc
operator|&&
name|service_id
condition|)
block|{
for|for
control|(
init|;
name|desc
operator|->
name|serv_id
operator|!=
name|NULL
condition|;
name|desc
operator|++
control|)
block|{
if|if
condition|(
name|ft_strcmp
argument_list|(
name|desc
operator|->
name|serv_id
argument_list|,
name|service_id
argument_list|)
operator|==
literal|0
condition|)
block|{
name|result
operator|=
operator|(
name|FT_Pointer
operator|)
name|desc
operator|->
name|serv_data
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return
name|result
return|;
block|}
end_block
begin_macro
name|FT_BASE_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|ft_validator_init
name|ft_validator_init
argument_list|(
argument|FT_Validator        valid
argument_list|,
argument|const FT_Byte*      base
argument_list|,
argument|const FT_Byte*      limit
argument_list|,
argument|FT_ValidationLevel  level
argument_list|)
end_macro
begin_block
block|{
name|valid
operator|->
name|base
operator|=
name|base
expr_stmt|;
name|valid
operator|->
name|limit
operator|=
name|limit
expr_stmt|;
name|valid
operator|->
name|level
operator|=
name|level
expr_stmt|;
name|valid
operator|->
name|error
operator|=
name|FT_Err_Ok
expr_stmt|;
block|}
end_block
begin_macro
DECL|function|FT_BASE_DEF
name|FT_BASE_DEF
argument_list|(
argument|FT_Int
argument_list|)
end_macro
begin_macro
name|ft_validator_run
argument_list|(
argument|FT_Validator  valid
argument_list|)
end_macro
begin_block
block|{
comment|/* This function doesn't work!  None should call it. */
name|FT_UNUSED
argument_list|(
name|valid
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_block
begin_macro
name|FT_BASE_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|ft_validator_error
name|ft_validator_error
argument_list|(
argument|FT_Validator  valid
argument_list|,
argument|FT_Error      error
argument_list|)
end_macro
begin_block
block|{
comment|/* since the cast below also disables the compiler's */
comment|/* type check, we introduce a dummy variable, which  */
comment|/* will be optimized away                            */
specifier|volatile
name|ft_jmp_buf
modifier|*
name|jump_buffer
init|=
operator|&
name|valid
operator|->
name|jump_buffer
decl_stmt|;
name|valid
operator|->
name|error
operator|=
name|error
expr_stmt|;
comment|/* throw away volatileness; use `jump_buffer' or the  */
comment|/* compiler may warn about an unused local variable   */
name|ft_longjmp
argument_list|(
operator|*
operator|(
name|ft_jmp_buf
operator|*
operator|)
name|jump_buffer
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/****                                                                 ****/
end_comment
begin_comment
comment|/****                                                                 ****/
end_comment
begin_comment
comment|/****                           S T R E A M                           ****/
end_comment
begin_comment
comment|/****                                                                 ****/
end_comment
begin_comment
comment|/****                                                                 ****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/* create a new input stream from an FT_Open_Args structure */
end_comment
begin_comment
comment|/*                                                          */
end_comment
begin_macro
DECL|function|FT_BASE_DEF
name|FT_BASE_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_Stream_New
argument_list|(
argument|FT_Library           library
argument_list|,
argument|const FT_Open_Args*  args
argument_list|,
argument|FT_Stream           *astream
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
decl_stmt|;
name|FT_Memory
name|memory
decl_stmt|;
name|FT_Stream
name|stream
decl_stmt|;
operator|*
name|astream
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|library
condition|)
return|return
name|FT_Err_Invalid_Library_Handle
return|;
if|if
condition|(
operator|!
name|args
condition|)
return|return
name|FT_Err_Invalid_Argument
return|;
name|memory
operator|=
name|library
operator|->
name|memory
expr_stmt|;
if|if
condition|(
name|FT_NEW
argument_list|(
name|stream
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|stream
operator|->
name|memory
operator|=
name|memory
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|flags
operator|&
name|FT_OPEN_MEMORY
condition|)
block|{
comment|/* create a memory-based stream */
name|FT_Stream_OpenMemory
argument_list|(
name|stream
argument_list|,
operator|(
specifier|const
name|FT_Byte
operator|*
operator|)
name|args
operator|->
name|memory_base
argument_list|,
name|args
operator|->
name|memory_size
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|args
operator|->
name|flags
operator|&
name|FT_OPEN_PATHNAME
condition|)
block|{
comment|/* create a normal system stream */
name|error
operator|=
name|FT_Stream_Open
argument_list|(
name|stream
argument_list|,
name|args
operator|->
name|pathname
argument_list|)
expr_stmt|;
name|stream
operator|->
name|pathname
operator|.
name|pointer
operator|=
name|args
operator|->
name|pathname
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|args
operator|->
name|flags
operator|&
name|FT_OPEN_STREAM
operator|)
operator|&&
name|args
operator|->
name|stream
condition|)
block|{
comment|/* use an existing, user-provided stream */
comment|/* in this case, we do not need to allocate a new stream object */
comment|/* since the caller is responsible for closing it himself       */
name|FT_FREE
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|stream
operator|=
name|args
operator|->
name|stream
expr_stmt|;
block|}
else|else
name|error
operator|=
name|FT_Err_Invalid_Argument
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|FT_FREE
argument_list|(
name|stream
argument_list|)
expr_stmt|;
else|else
name|stream
operator|->
name|memory
operator|=
name|memory
expr_stmt|;
comment|/* just to be certain */
operator|*
name|astream
operator|=
name|stream
expr_stmt|;
name|Exit
label|:
return|return
name|error
return|;
block|}
end_block
begin_macro
name|FT_BASE_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|FT_Stream_Free
name|FT_Stream_Free
argument_list|(
argument|FT_Stream  stream
argument_list|,
argument|FT_Int     external
argument_list|)
end_macro
begin_block
block|{
if|if
condition|(
name|stream
condition|)
block|{
name|FT_Memory
name|memory
init|=
name|stream
operator|->
name|memory
decl_stmt|;
name|FT_Stream_Close
argument_list|(
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|external
condition|)
name|FT_FREE
argument_list|(
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
end_comment
begin_comment
comment|/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
end_comment
begin_comment
comment|/* messages during execution.                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_undef
DECL|macro|FT_COMPONENT
undef|#
directive|undef
name|FT_COMPONENT
end_undef
begin_define
DECL|macro|FT_COMPONENT
define|#
directive|define
name|FT_COMPONENT
value|trace_objs
end_define
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/****                                                                 ****/
end_comment
begin_comment
comment|/****                                                                 ****/
end_comment
begin_comment
comment|/****               FACE, SIZE& GLYPH SLOT OBJECTS                   ****/
end_comment
begin_comment
comment|/****                                                                 ****/
end_comment
begin_comment
comment|/****                                                                 ****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|ft_glyphslot_init
name|ft_glyphslot_init
parameter_list|(
name|FT_GlyphSlot
name|slot
parameter_list|)
block|{
name|FT_Driver
name|driver
init|=
name|slot
operator|->
name|face
operator|->
name|driver
decl_stmt|;
name|FT_Driver_Class
name|clazz
init|=
name|driver
operator|->
name|clazz
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|driver
operator|->
name|root
operator|.
name|memory
decl_stmt|;
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
name|FT_Slot_Internal
name|internal
decl_stmt|;
name|slot
operator|->
name|library
operator|=
name|driver
operator|->
name|root
operator|.
name|library
expr_stmt|;
if|if
condition|(
name|FT_NEW
argument_list|(
name|internal
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|slot
operator|->
name|internal
operator|=
name|internal
expr_stmt|;
if|if
condition|(
name|FT_DRIVER_USES_OUTLINES
argument_list|(
name|driver
argument_list|)
condition|)
name|error
operator|=
name|FT_GlyphLoader_New
argument_list|(
name|memory
argument_list|,
operator|&
name|internal
operator|->
name|loader
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
name|clazz
operator|->
name|init_slot
condition|)
name|error
operator|=
name|clazz
operator|->
name|init_slot
argument_list|(
name|slot
argument_list|)
expr_stmt|;
name|Exit
label|:
return|return
name|error
return|;
block|}
end_function
begin_macro
name|FT_BASE_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|ft_glyphslot_free_bitmap
name|ft_glyphslot_free_bitmap
argument_list|(
argument|FT_GlyphSlot  slot
argument_list|)
end_macro
begin_block
block|{
if|if
condition|(
name|slot
operator|->
name|internal
operator|&&
operator|(
name|slot
operator|->
name|internal
operator|->
name|flags
operator|&
name|FT_GLYPH_OWN_BITMAP
operator|)
condition|)
block|{
name|FT_Memory
name|memory
init|=
name|FT_FACE_MEMORY
argument_list|(
name|slot
operator|->
name|face
argument_list|)
decl_stmt|;
name|FT_FREE
argument_list|(
name|slot
operator|->
name|bitmap
operator|.
name|buffer
argument_list|)
expr_stmt|;
name|slot
operator|->
name|internal
operator|->
name|flags
operator|&=
operator|~
name|FT_GLYPH_OWN_BITMAP
expr_stmt|;
block|}
else|else
block|{
comment|/* assume that the bitmap buffer was stolen or not */
comment|/* allocated from the heap                         */
name|slot
operator|->
name|bitmap
operator|.
name|buffer
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_block
begin_macro
name|FT_BASE_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|ft_glyphslot_set_bitmap
name|ft_glyphslot_set_bitmap
argument_list|(
argument|FT_GlyphSlot  slot
argument_list|,
argument|FT_Byte*      buffer
argument_list|)
end_macro
begin_block
block|{
name|ft_glyphslot_free_bitmap
argument_list|(
name|slot
argument_list|)
expr_stmt|;
name|slot
operator|->
name|bitmap
operator|.
name|buffer
operator|=
name|buffer
expr_stmt|;
name|FT_ASSERT
argument_list|(
operator|(
name|slot
operator|->
name|internal
operator|->
name|flags
operator|&
name|FT_GLYPH_OWN_BITMAP
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
end_block
begin_macro
DECL|function|FT_BASE_DEF
name|FT_BASE_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|ft_glyphslot_alloc_bitmap
argument_list|(
argument|FT_GlyphSlot  slot
argument_list|,
argument|FT_ULong      size
argument_list|)
end_macro
begin_block
block|{
name|FT_Memory
name|memory
init|=
name|FT_FACE_MEMORY
argument_list|(
name|slot
operator|->
name|face
argument_list|)
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
if|if
condition|(
name|slot
operator|->
name|internal
operator|->
name|flags
operator|&
name|FT_GLYPH_OWN_BITMAP
condition|)
name|FT_FREE
argument_list|(
name|slot
operator|->
name|bitmap
operator|.
name|buffer
argument_list|)
expr_stmt|;
else|else
name|slot
operator|->
name|internal
operator|->
name|flags
operator||=
name|FT_GLYPH_OWN_BITMAP
expr_stmt|;
operator|(
name|void
operator|)
name|FT_ALLOC
argument_list|(
name|slot
operator|->
name|bitmap
operator|.
name|buffer
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_block
begin_function
specifier|static
name|void
DECL|function|ft_glyphslot_clear
name|ft_glyphslot_clear
parameter_list|(
name|FT_GlyphSlot
name|slot
parameter_list|)
block|{
comment|/* free bitmap if needed */
name|ft_glyphslot_free_bitmap
argument_list|(
name|slot
argument_list|)
expr_stmt|;
comment|/* clear all public fields in the glyph slot */
name|FT_ZERO
argument_list|(
operator|&
name|slot
operator|->
name|metrics
argument_list|)
expr_stmt|;
name|FT_ZERO
argument_list|(
operator|&
name|slot
operator|->
name|outline
argument_list|)
expr_stmt|;
name|slot
operator|->
name|bitmap
operator|.
name|width
operator|=
literal|0
expr_stmt|;
name|slot
operator|->
name|bitmap
operator|.
name|rows
operator|=
literal|0
expr_stmt|;
name|slot
operator|->
name|bitmap
operator|.
name|pitch
operator|=
literal|0
expr_stmt|;
name|slot
operator|->
name|bitmap
operator|.
name|pixel_mode
operator|=
literal|0
expr_stmt|;
comment|/* `slot->bitmap.buffer' has been handled by ft_glyphslot_free_bitmap */
name|slot
operator|->
name|bitmap_left
operator|=
literal|0
expr_stmt|;
name|slot
operator|->
name|bitmap_top
operator|=
literal|0
expr_stmt|;
name|slot
operator|->
name|num_subglyphs
operator|=
literal|0
expr_stmt|;
name|slot
operator|->
name|subglyphs
operator|=
literal|0
expr_stmt|;
name|slot
operator|->
name|control_data
operator|=
literal|0
expr_stmt|;
name|slot
operator|->
name|control_len
operator|=
literal|0
expr_stmt|;
name|slot
operator|->
name|other
operator|=
literal|0
expr_stmt|;
name|slot
operator|->
name|format
operator|=
name|FT_GLYPH_FORMAT_NONE
expr_stmt|;
name|slot
operator|->
name|linearHoriAdvance
operator|=
literal|0
expr_stmt|;
name|slot
operator|->
name|linearVertAdvance
operator|=
literal|0
expr_stmt|;
name|slot
operator|->
name|lsb_delta
operator|=
literal|0
expr_stmt|;
name|slot
operator|->
name|rsb_delta
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|ft_glyphslot_done
name|ft_glyphslot_done
parameter_list|(
name|FT_GlyphSlot
name|slot
parameter_list|)
block|{
name|FT_Driver
name|driver
init|=
name|slot
operator|->
name|face
operator|->
name|driver
decl_stmt|;
name|FT_Driver_Class
name|clazz
init|=
name|driver
operator|->
name|clazz
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|driver
operator|->
name|root
operator|.
name|memory
decl_stmt|;
if|if
condition|(
name|clazz
operator|->
name|done_slot
condition|)
name|clazz
operator|->
name|done_slot
argument_list|(
name|slot
argument_list|)
expr_stmt|;
comment|/* free bitmap buffer if needed */
name|ft_glyphslot_free_bitmap
argument_list|(
name|slot
argument_list|)
expr_stmt|;
comment|/* slot->internal might be NULL in out-of-memory situations */
if|if
condition|(
name|slot
operator|->
name|internal
condition|)
block|{
comment|/* free glyph loader */
if|if
condition|(
name|FT_DRIVER_USES_OUTLINES
argument_list|(
name|driver
argument_list|)
condition|)
block|{
name|FT_GlyphLoader_Done
argument_list|(
name|slot
operator|->
name|internal
operator|->
name|loader
argument_list|)
expr_stmt|;
name|slot
operator|->
name|internal
operator|->
name|loader
operator|=
literal|0
expr_stmt|;
block|}
name|FT_FREE
argument_list|(
name|slot
operator|->
name|internal
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/* documentation is in ftobjs.h */
end_comment
begin_macro
DECL|function|FT_BASE_DEF
name|FT_BASE_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_New_GlyphSlot
argument_list|(
argument|FT_Face        face
argument_list|,
argument|FT_GlyphSlot  *aslot
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
decl_stmt|;
name|FT_Driver
name|driver
decl_stmt|;
name|FT_Driver_Class
name|clazz
decl_stmt|;
name|FT_Memory
name|memory
decl_stmt|;
name|FT_GlyphSlot
name|slot
decl_stmt|;
if|if
condition|(
operator|!
name|face
operator|||
operator|!
name|face
operator|->
name|driver
condition|)
return|return
name|FT_Err_Invalid_Argument
return|;
name|driver
operator|=
name|face
operator|->
name|driver
expr_stmt|;
name|clazz
operator|=
name|driver
operator|->
name|clazz
expr_stmt|;
name|memory
operator|=
name|driver
operator|->
name|root
operator|.
name|memory
expr_stmt|;
name|FT_TRACE4
argument_list|(
operator|(
literal|"FT_New_GlyphSlot: Creating new slot object\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|FT_ALLOC
argument_list|(
name|slot
argument_list|,
name|clazz
operator|->
name|slot_object_size
argument_list|)
condition|)
block|{
name|slot
operator|->
name|face
operator|=
name|face
expr_stmt|;
name|error
operator|=
name|ft_glyphslot_init
argument_list|(
name|slot
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|ft_glyphslot_done
argument_list|(
name|slot
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|slot
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|slot
operator|->
name|next
operator|=
name|face
operator|->
name|glyph
expr_stmt|;
name|face
operator|->
name|glyph
operator|=
name|slot
expr_stmt|;
if|if
condition|(
name|aslot
condition|)
operator|*
name|aslot
operator|=
name|slot
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|aslot
condition|)
operator|*
name|aslot
operator|=
literal|0
expr_stmt|;
name|Exit
label|:
name|FT_TRACE4
argument_list|(
operator|(
literal|"FT_New_GlyphSlot: Return %d\n"
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/* documentation is in ftobjs.h */
end_comment
begin_macro
name|FT_BASE_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|FT_Done_GlyphSlot
name|FT_Done_GlyphSlot
argument_list|(
argument|FT_GlyphSlot  slot
argument_list|)
end_macro
begin_block
block|{
if|if
condition|(
name|slot
condition|)
block|{
name|FT_Driver
name|driver
init|=
name|slot
operator|->
name|face
operator|->
name|driver
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|driver
operator|->
name|root
operator|.
name|memory
decl_stmt|;
name|FT_GlyphSlot
name|prev
decl_stmt|;
name|FT_GlyphSlot
name|cur
decl_stmt|;
comment|/* Remove slot from its parent face's list */
name|prev
operator|=
name|NULL
expr_stmt|;
name|cur
operator|=
name|slot
operator|->
name|face
operator|->
name|glyph
expr_stmt|;
while|while
condition|(
name|cur
condition|)
block|{
if|if
condition|(
name|cur
operator|==
name|slot
condition|)
block|{
if|if
condition|(
operator|!
name|prev
condition|)
name|slot
operator|->
name|face
operator|->
name|glyph
operator|=
name|cur
operator|->
name|next
expr_stmt|;
else|else
name|prev
operator|->
name|next
operator|=
name|cur
operator|->
name|next
expr_stmt|;
name|ft_glyphslot_done
argument_list|(
name|slot
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|slot
argument_list|)
expr_stmt|;
break|break;
block|}
name|prev
operator|=
name|cur
expr_stmt|;
name|cur
operator|=
name|cur
operator|->
name|next
expr_stmt|;
block|}
block|}
block|}
end_block
begin_comment
comment|/* documentation is in freetype.h */
end_comment
begin_macro
name|FT_EXPORT_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|FT_Set_Transform
name|FT_Set_Transform
argument_list|(
argument|FT_Face     face
argument_list|,
argument|FT_Matrix*  matrix
argument_list|,
argument|FT_Vector*  delta
argument_list|)
end_macro
begin_block
block|{
name|FT_Face_Internal
name|internal
decl_stmt|;
if|if
condition|(
operator|!
name|face
condition|)
return|return;
name|internal
operator|=
name|face
operator|->
name|internal
expr_stmt|;
name|internal
operator|->
name|transform_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|matrix
condition|)
block|{
name|internal
operator|->
name|transform_matrix
operator|.
name|xx
operator|=
literal|0x10000L
expr_stmt|;
name|internal
operator|->
name|transform_matrix
operator|.
name|xy
operator|=
literal|0
expr_stmt|;
name|internal
operator|->
name|transform_matrix
operator|.
name|yx
operator|=
literal|0
expr_stmt|;
name|internal
operator|->
name|transform_matrix
operator|.
name|yy
operator|=
literal|0x10000L
expr_stmt|;
name|matrix
operator|=
operator|&
name|internal
operator|->
name|transform_matrix
expr_stmt|;
block|}
else|else
name|internal
operator|->
name|transform_matrix
operator|=
operator|*
name|matrix
expr_stmt|;
comment|/* set transform_flags bit flag 0 if `matrix' isn't the identity */
if|if
condition|(
operator|(
name|matrix
operator|->
name|xy
operator||
name|matrix
operator|->
name|yx
operator|)
operator|||
name|matrix
operator|->
name|xx
operator|!=
literal|0x10000L
operator|||
name|matrix
operator|->
name|yy
operator|!=
literal|0x10000L
condition|)
name|internal
operator|->
name|transform_flags
operator||=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|delta
condition|)
block|{
name|internal
operator|->
name|transform_delta
operator|.
name|x
operator|=
literal|0
expr_stmt|;
name|internal
operator|->
name|transform_delta
operator|.
name|y
operator|=
literal|0
expr_stmt|;
name|delta
operator|=
operator|&
name|internal
operator|->
name|transform_delta
expr_stmt|;
block|}
else|else
name|internal
operator|->
name|transform_delta
operator|=
operator|*
name|delta
expr_stmt|;
comment|/* set transform_flags bit flag 1 if `delta' isn't the null vector */
if|if
condition|(
name|delta
operator|->
name|x
operator||
name|delta
operator|->
name|y
condition|)
name|internal
operator|->
name|transform_flags
operator||=
literal|2
expr_stmt|;
block|}
end_block
begin_function_decl
specifier|static
name|FT_Renderer
name|ft_lookup_glyph_renderer
parameter_list|(
name|FT_GlyphSlot
name|slot
parameter_list|)
function_decl|;
end_function_decl
begin_ifdef
ifdef|#
directive|ifdef
name|GRID_FIT_METRICS
end_ifdef
begin_function
specifier|static
name|void
DECL|function|ft_glyphslot_grid_fit_metrics
name|ft_glyphslot_grid_fit_metrics
parameter_list|(
name|FT_GlyphSlot
name|slot
parameter_list|,
name|FT_Bool
name|vertical
parameter_list|)
block|{
name|FT_Glyph_Metrics
modifier|*
name|metrics
init|=
operator|&
name|slot
operator|->
name|metrics
decl_stmt|;
name|FT_Pos
name|right
decl_stmt|,
name|bottom
decl_stmt|;
if|if
condition|(
name|vertical
condition|)
block|{
name|metrics
operator|->
name|horiBearingX
operator|=
name|FT_PIX_FLOOR
argument_list|(
name|metrics
operator|->
name|horiBearingX
argument_list|)
expr_stmt|;
name|metrics
operator|->
name|horiBearingY
operator|=
name|FT_PIX_CEIL
argument_list|(
name|metrics
operator|->
name|horiBearingY
argument_list|)
expr_stmt|;
name|right
operator|=
name|FT_PIX_CEIL
argument_list|(
name|metrics
operator|->
name|vertBearingX
operator|+
name|metrics
operator|->
name|width
argument_list|)
expr_stmt|;
name|bottom
operator|=
name|FT_PIX_CEIL
argument_list|(
name|metrics
operator|->
name|vertBearingY
operator|+
name|metrics
operator|->
name|height
argument_list|)
expr_stmt|;
name|metrics
operator|->
name|vertBearingX
operator|=
name|FT_PIX_FLOOR
argument_list|(
name|metrics
operator|->
name|vertBearingX
argument_list|)
expr_stmt|;
name|metrics
operator|->
name|vertBearingY
operator|=
name|FT_PIX_FLOOR
argument_list|(
name|metrics
operator|->
name|vertBearingY
argument_list|)
expr_stmt|;
name|metrics
operator|->
name|width
operator|=
name|right
operator|-
name|metrics
operator|->
name|vertBearingX
expr_stmt|;
name|metrics
operator|->
name|height
operator|=
name|bottom
operator|-
name|metrics
operator|->
name|vertBearingY
expr_stmt|;
block|}
else|else
block|{
name|metrics
operator|->
name|vertBearingX
operator|=
name|FT_PIX_FLOOR
argument_list|(
name|metrics
operator|->
name|vertBearingX
argument_list|)
expr_stmt|;
name|metrics
operator|->
name|vertBearingY
operator|=
name|FT_PIX_FLOOR
argument_list|(
name|metrics
operator|->
name|vertBearingY
argument_list|)
expr_stmt|;
name|right
operator|=
name|FT_PIX_CEIL
argument_list|(
name|metrics
operator|->
name|horiBearingX
operator|+
name|metrics
operator|->
name|width
argument_list|)
expr_stmt|;
name|bottom
operator|=
name|FT_PIX_FLOOR
argument_list|(
name|metrics
operator|->
name|horiBearingY
operator|-
name|metrics
operator|->
name|height
argument_list|)
expr_stmt|;
name|metrics
operator|->
name|horiBearingX
operator|=
name|FT_PIX_FLOOR
argument_list|(
name|metrics
operator|->
name|horiBearingX
argument_list|)
expr_stmt|;
name|metrics
operator|->
name|horiBearingY
operator|=
name|FT_PIX_CEIL
argument_list|(
name|metrics
operator|->
name|horiBearingY
argument_list|)
expr_stmt|;
name|metrics
operator|->
name|width
operator|=
name|right
operator|-
name|metrics
operator|->
name|horiBearingX
expr_stmt|;
name|metrics
operator|->
name|height
operator|=
name|metrics
operator|->
name|horiBearingY
operator|-
name|bottom
expr_stmt|;
block|}
name|metrics
operator|->
name|horiAdvance
operator|=
name|FT_PIX_ROUND
argument_list|(
name|metrics
operator|->
name|horiAdvance
argument_list|)
expr_stmt|;
name|metrics
operator|->
name|vertAdvance
operator|=
name|FT_PIX_ROUND
argument_list|(
name|metrics
operator|->
name|vertAdvance
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* GRID_FIT_METRICS */
end_comment
begin_comment
comment|/* documentation is in freetype.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_Load_Glyph
argument_list|(
argument|FT_Face   face
argument_list|,
argument|FT_UInt   glyph_index
argument_list|,
argument|FT_Int32  load_flags
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
decl_stmt|;
name|FT_Driver
name|driver
decl_stmt|;
name|FT_GlyphSlot
name|slot
decl_stmt|;
name|FT_Library
name|library
decl_stmt|;
name|FT_Bool
name|autohint
init|=
name|FALSE
decl_stmt|;
name|FT_Module
name|hinter
decl_stmt|;
if|if
condition|(
operator|!
name|face
operator|||
operator|!
name|face
operator|->
name|size
operator|||
operator|!
name|face
operator|->
name|glyph
condition|)
return|return
name|FT_Err_Invalid_Face_Handle
return|;
comment|/* The validity test for `glyph_index' is performed by the */
comment|/* font drivers.                                           */
name|slot
operator|=
name|face
operator|->
name|glyph
expr_stmt|;
name|ft_glyphslot_clear
argument_list|(
name|slot
argument_list|)
expr_stmt|;
name|driver
operator|=
name|face
operator|->
name|driver
expr_stmt|;
name|library
operator|=
name|driver
operator|->
name|root
operator|.
name|library
expr_stmt|;
name|hinter
operator|=
name|library
operator|->
name|auto_hinter
expr_stmt|;
comment|/* resolve load flags dependencies */
if|if
condition|(
name|load_flags
operator|&
name|FT_LOAD_NO_RECURSE
condition|)
name|load_flags
operator||=
name|FT_LOAD_NO_SCALE
operator||
name|FT_LOAD_IGNORE_TRANSFORM
expr_stmt|;
if|if
condition|(
name|load_flags
operator|&
name|FT_LOAD_NO_SCALE
condition|)
block|{
name|load_flags
operator||=
name|FT_LOAD_NO_HINTING
operator||
name|FT_LOAD_NO_BITMAP
expr_stmt|;
name|load_flags
operator|&=
operator|~
name|FT_LOAD_RENDER
expr_stmt|;
block|}
comment|/*      * Determine whether we need to auto-hint or not.      * The general rules are:      *      * - Do only auto-hinting if we have a hinter module, a scalable font      *   format dealing with outlines, and no transforms except simple      *   slants and/or rotations by integer multiples of 90 degrees.      *      * - Then, auto-hint if FT_LOAD_FORCE_AUTOHINT is set or if we don't      *   have a native font hinter.      *      * - Otherwise, auto-hint for LIGHT hinting mode.      *      * - Exception: The font is `tricky' and requires the native hinter to      *   load properly.      */
if|if
condition|(
name|hinter
operator|&&
operator|!
operator|(
name|load_flags
operator|&
name|FT_LOAD_NO_HINTING
operator|)
operator|&&
operator|!
operator|(
name|load_flags
operator|&
name|FT_LOAD_NO_AUTOHINT
operator|)
operator|&&
name|FT_DRIVER_IS_SCALABLE
argument_list|(
name|driver
argument_list|)
operator|&&
name|FT_DRIVER_USES_OUTLINES
argument_list|(
name|driver
argument_list|)
operator|&&
operator|!
name|FT_IS_TRICKY
argument_list|(
name|face
argument_list|)
operator|&&
operator|(
operator|(
name|face
operator|->
name|internal
operator|->
name|transform_matrix
operator|.
name|yx
operator|==
literal|0
operator|&&
name|face
operator|->
name|internal
operator|->
name|transform_matrix
operator|.
name|xx
operator|!=
literal|0
operator|)
operator|||
operator|(
name|face
operator|->
name|internal
operator|->
name|transform_matrix
operator|.
name|xx
operator|==
literal|0
operator|&&
name|face
operator|->
name|internal
operator|->
name|transform_matrix
operator|.
name|yx
operator|!=
literal|0
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|load_flags
operator|&
name|FT_LOAD_FORCE_AUTOHINT
operator|)
operator|||
operator|!
name|FT_DRIVER_HAS_HINTER
argument_list|(
name|driver
argument_list|)
condition|)
name|autohint
operator|=
name|TRUE
expr_stmt|;
else|else
block|{
name|FT_Render_Mode
name|mode
init|=
name|FT_LOAD_TARGET_MODE
argument_list|(
name|load_flags
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|FT_RENDER_MODE_LIGHT
operator|||
name|face
operator|->
name|internal
operator|->
name|ignore_unpatented_hinter
condition|)
name|autohint
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|autohint
condition|)
block|{
name|FT_AutoHinter_Service
name|hinting
decl_stmt|;
comment|/* try to load embedded bitmaps first if available            */
comment|/*                                                            */
comment|/* XXX: This is really a temporary hack that should disappear */
comment|/*      promptly with FreeType 2.1!                           */
comment|/*                                                            */
if|if
condition|(
name|FT_HAS_FIXED_SIZES
argument_list|(
name|face
argument_list|)
operator|&&
operator|(
name|load_flags
operator|&
name|FT_LOAD_NO_BITMAP
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|driver
operator|->
name|clazz
operator|->
name|load_glyph
argument_list|(
name|slot
argument_list|,
name|face
operator|->
name|size
argument_list|,
name|glyph_index
argument_list|,
name|load_flags
operator||
name|FT_LOAD_SBITS_ONLY
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
name|slot
operator|->
name|format
operator|==
name|FT_GLYPH_FORMAT_BITMAP
condition|)
goto|goto
name|Load_Ok
goto|;
block|}
block|{
name|FT_Face_Internal
name|internal
init|=
name|face
operator|->
name|internal
decl_stmt|;
name|FT_Int
name|transform_flags
init|=
name|internal
operator|->
name|transform_flags
decl_stmt|;
comment|/* since the auto-hinter calls FT_Load_Glyph by itself, */
comment|/* make sure that glyphs aren't transformed             */
name|internal
operator|->
name|transform_flags
operator|=
literal|0
expr_stmt|;
comment|/* load auto-hinted outline */
name|hinting
operator|=
operator|(
name|FT_AutoHinter_Service
operator|)
name|hinter
operator|->
name|clazz
operator|->
name|module_interface
expr_stmt|;
name|error
operator|=
name|hinting
operator|->
name|load_glyph
argument_list|(
operator|(
name|FT_AutoHinter
operator|)
name|hinter
argument_list|,
name|slot
argument_list|,
name|face
operator|->
name|size
argument_list|,
name|glyph_index
argument_list|,
name|load_flags
argument_list|)
expr_stmt|;
name|internal
operator|->
name|transform_flags
operator|=
name|transform_flags
expr_stmt|;
block|}
block|}
else|else
block|{
name|error
operator|=
name|driver
operator|->
name|clazz
operator|->
name|load_glyph
argument_list|(
name|slot
argument_list|,
name|face
operator|->
name|size
argument_list|,
name|glyph_index
argument_list|,
name|load_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
if|if
condition|(
name|slot
operator|->
name|format
operator|==
name|FT_GLYPH_FORMAT_OUTLINE
condition|)
block|{
comment|/* check that the loaded outline is correct */
name|error
operator|=
name|FT_Outline_Check
argument_list|(
operator|&
name|slot
operator|->
name|outline
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
ifdef|#
directive|ifdef
name|GRID_FIT_METRICS
if|if
condition|(
operator|!
operator|(
name|load_flags
operator|&
name|FT_LOAD_NO_HINTING
operator|)
condition|)
name|ft_glyphslot_grid_fit_metrics
argument_list|(
name|slot
argument_list|,
name|FT_BOOL
argument_list|(
name|load_flags
operator|&
name|FT_LOAD_VERTICAL_LAYOUT
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
name|Load_Ok
label|:
comment|/* compute the advance */
if|if
condition|(
name|load_flags
operator|&
name|FT_LOAD_VERTICAL_LAYOUT
condition|)
block|{
name|slot
operator|->
name|advance
operator|.
name|x
operator|=
literal|0
expr_stmt|;
name|slot
operator|->
name|advance
operator|.
name|y
operator|=
name|slot
operator|->
name|metrics
operator|.
name|vertAdvance
expr_stmt|;
block|}
else|else
block|{
name|slot
operator|->
name|advance
operator|.
name|x
operator|=
name|slot
operator|->
name|metrics
operator|.
name|horiAdvance
expr_stmt|;
name|slot
operator|->
name|advance
operator|.
name|y
operator|=
literal|0
expr_stmt|;
block|}
comment|/* compute the linear advance in 16.16 pixels */
if|if
condition|(
operator|(
name|load_flags
operator|&
name|FT_LOAD_LINEAR_DESIGN
operator|)
operator|==
literal|0
operator|&&
operator|(
name|FT_IS_SCALABLE
argument_list|(
name|face
argument_list|)
operator|)
condition|)
block|{
name|FT_Size_Metrics
modifier|*
name|metrics
init|=
operator|&
name|face
operator|->
name|size
operator|->
name|metrics
decl_stmt|;
comment|/* it's tricky! */
name|slot
operator|->
name|linearHoriAdvance
operator|=
name|FT_MulDiv
argument_list|(
name|slot
operator|->
name|linearHoriAdvance
argument_list|,
name|metrics
operator|->
name|x_scale
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|slot
operator|->
name|linearVertAdvance
operator|=
name|FT_MulDiv
argument_list|(
name|slot
operator|->
name|linearVertAdvance
argument_list|,
name|metrics
operator|->
name|y_scale
argument_list|,
literal|64
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|load_flags
operator|&
name|FT_LOAD_IGNORE_TRANSFORM
operator|)
operator|==
literal|0
condition|)
block|{
name|FT_Face_Internal
name|internal
init|=
name|face
operator|->
name|internal
decl_stmt|;
comment|/* now, transform the glyph image if needed */
if|if
condition|(
name|internal
operator|->
name|transform_flags
condition|)
block|{
comment|/* get renderer */
name|FT_Renderer
name|renderer
init|=
name|ft_lookup_glyph_renderer
argument_list|(
name|slot
argument_list|)
decl_stmt|;
if|if
condition|(
name|renderer
condition|)
name|error
operator|=
name|renderer
operator|->
name|clazz
operator|->
name|transform_glyph
argument_list|(
name|renderer
argument_list|,
name|slot
argument_list|,
operator|&
name|internal
operator|->
name|transform_matrix
argument_list|,
operator|&
name|internal
operator|->
name|transform_delta
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|slot
operator|->
name|format
operator|==
name|FT_GLYPH_FORMAT_OUTLINE
condition|)
block|{
comment|/* apply `standard' transformation if no renderer is available */
if|if
condition|(
operator|&
name|internal
operator|->
name|transform_matrix
condition|)
name|FT_Outline_Transform
argument_list|(
operator|&
name|slot
operator|->
name|outline
argument_list|,
operator|&
name|internal
operator|->
name|transform_matrix
argument_list|)
expr_stmt|;
if|if
condition|(
operator|&
name|internal
operator|->
name|transform_delta
condition|)
name|FT_Outline_Translate
argument_list|(
operator|&
name|slot
operator|->
name|outline
argument_list|,
name|internal
operator|->
name|transform_delta
operator|.
name|x
argument_list|,
name|internal
operator|->
name|transform_delta
operator|.
name|y
argument_list|)
expr_stmt|;
block|}
comment|/* transform advance */
name|FT_Vector_Transform
argument_list|(
operator|&
name|slot
operator|->
name|advance
argument_list|,
operator|&
name|internal
operator|->
name|transform_matrix
argument_list|)
expr_stmt|;
block|}
block|}
name|FT_TRACE5
argument_list|(
operator|(
literal|"  x advance: %d\n"
operator|,
name|slot
operator|->
name|advance
operator|.
name|x
operator|)
argument_list|)
expr_stmt|;
name|FT_TRACE5
argument_list|(
operator|(
literal|"  y advance: %d\n"
operator|,
name|slot
operator|->
name|advance
operator|.
name|y
operator|)
argument_list|)
expr_stmt|;
name|FT_TRACE5
argument_list|(
operator|(
literal|"  linear x advance: %d\n"
operator|,
name|slot
operator|->
name|linearHoriAdvance
operator|)
argument_list|)
expr_stmt|;
name|FT_TRACE5
argument_list|(
operator|(
literal|"  linear y advance: %d\n"
operator|,
name|slot
operator|->
name|linearVertAdvance
operator|)
argument_list|)
expr_stmt|;
comment|/* do we need to render the image now? */
if|if
condition|(
operator|!
name|error
operator|&&
name|slot
operator|->
name|format
operator|!=
name|FT_GLYPH_FORMAT_BITMAP
operator|&&
name|slot
operator|->
name|format
operator|!=
name|FT_GLYPH_FORMAT_COMPOSITE
operator|&&
name|load_flags
operator|&
name|FT_LOAD_RENDER
condition|)
block|{
name|FT_Render_Mode
name|mode
init|=
name|FT_LOAD_TARGET_MODE
argument_list|(
name|load_flags
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|FT_RENDER_MODE_NORMAL
operator|&&
operator|(
name|load_flags
operator|&
name|FT_LOAD_MONOCHROME
operator|)
condition|)
name|mode
operator|=
name|FT_RENDER_MODE_MONO
expr_stmt|;
name|error
operator|=
name|FT_Render_Glyph
argument_list|(
name|slot
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
name|Exit
label|:
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/* documentation is in freetype.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_Load_Char
argument_list|(
argument|FT_Face   face
argument_list|,
argument|FT_ULong  char_code
argument_list|,
argument|FT_Int32  load_flags
argument_list|)
end_macro
begin_block
block|{
name|FT_UInt
name|glyph_index
decl_stmt|;
if|if
condition|(
operator|!
name|face
condition|)
return|return
name|FT_Err_Invalid_Face_Handle
return|;
name|glyph_index
operator|=
operator|(
name|FT_UInt
operator|)
name|char_code
expr_stmt|;
if|if
condition|(
name|face
operator|->
name|charmap
condition|)
name|glyph_index
operator|=
name|FT_Get_Char_Index
argument_list|(
name|face
argument_list|,
name|char_code
argument_list|)
expr_stmt|;
return|return
name|FT_Load_Glyph
argument_list|(
name|face
argument_list|,
name|glyph_index
argument_list|,
name|load_flags
argument_list|)
return|;
block|}
end_block
begin_comment
comment|/* destructor for sizes list */
end_comment
begin_function
specifier|static
name|void
DECL|function|destroy_size
name|destroy_size
parameter_list|(
name|FT_Memory
name|memory
parameter_list|,
name|FT_Size
name|size
parameter_list|,
name|FT_Driver
name|driver
parameter_list|)
block|{
comment|/* finalize client-specific data */
if|if
condition|(
name|size
operator|->
name|generic
operator|.
name|finalizer
condition|)
name|size
operator|->
name|generic
operator|.
name|finalizer
argument_list|(
name|size
argument_list|)
expr_stmt|;
comment|/* finalize format-specific stuff */
if|if
condition|(
name|driver
operator|->
name|clazz
operator|->
name|done_size
condition|)
name|driver
operator|->
name|clazz
operator|->
name|done_size
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|size
operator|->
name|internal
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|size
argument_list|)
expr_stmt|;
block|}
end_function
begin_function_decl
specifier|static
name|void
name|ft_cmap_done_internal
parameter_list|(
name|FT_CMap
name|cmap
parameter_list|)
function_decl|;
end_function_decl
begin_function
specifier|static
name|void
DECL|function|destroy_charmaps
name|destroy_charmaps
parameter_list|(
name|FT_Face
name|face
parameter_list|,
name|FT_Memory
name|memory
parameter_list|)
block|{
name|FT_Int
name|n
decl_stmt|;
if|if
condition|(
operator|!
name|face
condition|)
return|return;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|face
operator|->
name|num_charmaps
condition|;
name|n
operator|++
control|)
block|{
name|FT_CMap
name|cmap
init|=
name|FT_CMAP
argument_list|(
name|face
operator|->
name|charmaps
index|[
name|n
index|]
argument_list|)
decl_stmt|;
name|ft_cmap_done_internal
argument_list|(
name|cmap
argument_list|)
expr_stmt|;
name|face
operator|->
name|charmaps
index|[
name|n
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|FT_FREE
argument_list|(
name|face
operator|->
name|charmaps
argument_list|)
expr_stmt|;
name|face
operator|->
name|num_charmaps
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_comment
comment|/* destructor for faces list */
end_comment
begin_function
specifier|static
name|void
DECL|function|destroy_face
name|destroy_face
parameter_list|(
name|FT_Memory
name|memory
parameter_list|,
name|FT_Face
name|face
parameter_list|,
name|FT_Driver
name|driver
parameter_list|)
block|{
name|FT_Driver_Class
name|clazz
init|=
name|driver
operator|->
name|clazz
decl_stmt|;
comment|/* discard auto-hinting data */
if|if
condition|(
name|face
operator|->
name|autohint
operator|.
name|finalizer
condition|)
name|face
operator|->
name|autohint
operator|.
name|finalizer
argument_list|(
name|face
operator|->
name|autohint
operator|.
name|data
argument_list|)
expr_stmt|;
comment|/* Discard glyph slots for this face.                           */
comment|/* Beware!  FT_Done_GlyphSlot() changes the field `face->glyph' */
while|while
condition|(
name|face
operator|->
name|glyph
condition|)
name|FT_Done_GlyphSlot
argument_list|(
name|face
operator|->
name|glyph
argument_list|)
expr_stmt|;
comment|/* discard all sizes for this face */
name|FT_List_Finalize
argument_list|(
operator|&
name|face
operator|->
name|sizes_list
argument_list|,
operator|(
name|FT_List_Destructor
operator|)
name|destroy_size
argument_list|,
name|memory
argument_list|,
name|driver
argument_list|)
expr_stmt|;
name|face
operator|->
name|size
operator|=
literal|0
expr_stmt|;
comment|/* now discard client data */
if|if
condition|(
name|face
operator|->
name|generic
operator|.
name|finalizer
condition|)
name|face
operator|->
name|generic
operator|.
name|finalizer
argument_list|(
name|face
argument_list|)
expr_stmt|;
comment|/* discard charmaps */
name|destroy_charmaps
argument_list|(
name|face
argument_list|,
name|memory
argument_list|)
expr_stmt|;
comment|/* finalize format-specific stuff */
if|if
condition|(
name|clazz
operator|->
name|done_face
condition|)
name|clazz
operator|->
name|done_face
argument_list|(
name|face
argument_list|)
expr_stmt|;
comment|/* close the stream for this face if needed */
name|FT_Stream_Free
argument_list|(
name|face
operator|->
name|stream
argument_list|,
operator|(
name|face
operator|->
name|face_flags
operator|&
name|FT_FACE_FLAG_EXTERNAL_STREAM
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|face
operator|->
name|stream
operator|=
literal|0
expr_stmt|;
comment|/* get rid of it */
if|if
condition|(
name|face
operator|->
name|internal
condition|)
block|{
name|FT_FREE
argument_list|(
name|face
operator|->
name|internal
argument_list|)
expr_stmt|;
block|}
name|FT_FREE
argument_list|(
name|face
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|Destroy_Driver
name|Destroy_Driver
parameter_list|(
name|FT_Driver
name|driver
parameter_list|)
block|{
name|FT_List_Finalize
argument_list|(
operator|&
name|driver
operator|->
name|faces_list
argument_list|,
operator|(
name|FT_List_Destructor
operator|)
name|destroy_face
argument_list|,
name|driver
operator|->
name|root
operator|.
name|memory
argument_list|,
name|driver
argument_list|)
expr_stmt|;
comment|/* check whether we need to drop the driver's glyph loader */
if|if
condition|(
name|FT_DRIVER_USES_OUTLINES
argument_list|(
name|driver
argument_list|)
condition|)
name|FT_GlyphLoader_Done
argument_list|(
name|driver
operator|->
name|glyph_loader
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    find_unicode_charmap                                               */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    This function finds a Unicode charmap, if there is one.            */
end_comment
begin_comment
comment|/*    And if there is more than one, it tries to favour the more         */
end_comment
begin_comment
comment|/*    extensive one, i.e., one that supports UCS-4 against those which   */
end_comment
begin_comment
comment|/*    are limited to the BMP (said UCS-2 encoding.)                      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    This function is called from open_face() (just below), and also    */
end_comment
begin_comment
comment|/*    from FT_Select_Charmap( ..., FT_ENCODING_UNICODE ).                */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|find_unicode_charmap
name|find_unicode_charmap
parameter_list|(
name|FT_Face
name|face
parameter_list|)
block|{
name|FT_CharMap
modifier|*
name|first
decl_stmt|;
name|FT_CharMap
modifier|*
name|cur
decl_stmt|;
comment|/* caller should have already checked that `face' is valid */
name|FT_ASSERT
argument_list|(
name|face
argument_list|)
expr_stmt|;
name|first
operator|=
name|face
operator|->
name|charmaps
expr_stmt|;
if|if
condition|(
operator|!
name|first
condition|)
return|return
name|FT_Err_Invalid_CharMap_Handle
return|;
comment|/*      *  The original TrueType specification(s) only specified charmap      *  formats that are capable of mapping 8 or 16 bit character codes to      *  glyph indices.      *      *  However, recent updates to the Apple and OpenType specifications      *  introduced new formats that are capable of mapping 32-bit character      *  codes as well.  And these are already used on some fonts, mainly to      *  map non-BMP Asian ideographs as defined in Unicode.      *      *  For compatibility purposes, these fonts generally come with      *  *several* Unicode charmaps:      *      *   - One of them in the "old" 16-bit format, that cannot access      *     all glyphs in the font.      *      *   - Another one in the "new" 32-bit format, that can access all      *     the glyphs.      *      *  This function has been written to always favor a 32-bit charmap      *  when found.  Otherwise, a 16-bit one is returned when found.      */
comment|/* Since the `interesting' table, with IDs (3,10), is normally the */
comment|/* last one, we loop backwards.  This loses with type1 fonts with  */
comment|/* non-BMP characters (<.0001%), this wins with .ttf with non-BMP  */
comment|/* chars (.01% ?), and this is the same about 99.99% of the time!  */
name|cur
operator|=
name|first
operator|+
name|face
operator|->
name|num_charmaps
expr_stmt|;
comment|/* points after the last one */
for|for
control|(
init|;
operator|--
name|cur
operator|>=
name|first
condition|;
control|)
block|{
if|if
condition|(
name|cur
index|[
literal|0
index|]
operator|->
name|encoding
operator|==
name|FT_ENCODING_UNICODE
condition|)
block|{
comment|/* XXX If some new encodings to represent UCS-4 are added, */
comment|/*     they should be added here.                          */
if|if
condition|(
operator|(
name|cur
index|[
literal|0
index|]
operator|->
name|platform_id
operator|==
name|TT_PLATFORM_MICROSOFT
operator|&&
name|cur
index|[
literal|0
index|]
operator|->
name|encoding_id
operator|==
name|TT_MS_ID_UCS_4
operator|)
operator|||
operator|(
name|cur
index|[
literal|0
index|]
operator|->
name|platform_id
operator|==
name|TT_PLATFORM_APPLE_UNICODE
operator|&&
name|cur
index|[
literal|0
index|]
operator|->
name|encoding_id
operator|==
name|TT_APPLE_ID_UNICODE_32
operator|)
condition|)
block|{
name|face
operator|->
name|charmap
operator|=
name|cur
index|[
literal|0
index|]
expr_stmt|;
return|return
name|FT_Err_Ok
return|;
block|}
block|}
block|}
comment|/* We do not have any UCS-4 charmap.                */
comment|/* Do the loop again and search for UCS-2 charmaps. */
name|cur
operator|=
name|first
operator|+
name|face
operator|->
name|num_charmaps
expr_stmt|;
for|for
control|(
init|;
operator|--
name|cur
operator|>=
name|first
condition|;
control|)
block|{
if|if
condition|(
name|cur
index|[
literal|0
index|]
operator|->
name|encoding
operator|==
name|FT_ENCODING_UNICODE
condition|)
block|{
name|face
operator|->
name|charmap
operator|=
name|cur
index|[
literal|0
index|]
expr_stmt|;
return|return
name|FT_Err_Ok
return|;
block|}
block|}
return|return
name|FT_Err_Invalid_CharMap_Handle
return|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    find_variant_selector_charmap                                      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    This function finds the variant selector charmap, if there is one. */
end_comment
begin_comment
comment|/*    There can only be one (platform=0, specific=5, format=14).         */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|FT_CharMap
DECL|function|find_variant_selector_charmap
name|find_variant_selector_charmap
parameter_list|(
name|FT_Face
name|face
parameter_list|)
block|{
name|FT_CharMap
modifier|*
name|first
decl_stmt|;
name|FT_CharMap
modifier|*
name|end
decl_stmt|;
name|FT_CharMap
modifier|*
name|cur
decl_stmt|;
comment|/* caller should have already checked that `face' is valid */
name|FT_ASSERT
argument_list|(
name|face
argument_list|)
expr_stmt|;
name|first
operator|=
name|face
operator|->
name|charmaps
expr_stmt|;
if|if
condition|(
operator|!
name|first
condition|)
return|return
name|NULL
return|;
name|end
operator|=
name|first
operator|+
name|face
operator|->
name|num_charmaps
expr_stmt|;
comment|/* points after the last one */
for|for
control|(
name|cur
operator|=
name|first
init|;
name|cur
operator|<
name|end
condition|;
operator|++
name|cur
control|)
block|{
if|if
condition|(
name|cur
index|[
literal|0
index|]
operator|->
name|platform_id
operator|==
name|TT_PLATFORM_APPLE_UNICODE
operator|&&
name|cur
index|[
literal|0
index|]
operator|->
name|encoding_id
operator|==
name|TT_APPLE_ID_VARIANT_SELECTOR
operator|&&
name|FT_Get_CMap_Format
argument_list|(
name|cur
index|[
literal|0
index|]
argument_list|)
operator|==
literal|14
condition|)
return|return
name|cur
index|[
literal|0
index|]
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    open_face                                                          */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    This function does some work for FT_Open_Face().                   */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|open_face
name|open_face
parameter_list|(
name|FT_Driver
name|driver
parameter_list|,
name|FT_Stream
name|stream
parameter_list|,
name|FT_Long
name|face_index
parameter_list|,
name|FT_Int
name|num_params
parameter_list|,
name|FT_Parameter
modifier|*
name|params
parameter_list|,
name|FT_Face
modifier|*
name|aface
parameter_list|)
block|{
name|FT_Memory
name|memory
decl_stmt|;
name|FT_Driver_Class
name|clazz
decl_stmt|;
name|FT_Face
name|face
init|=
literal|0
decl_stmt|;
name|FT_Error
name|error
decl_stmt|,
name|error2
decl_stmt|;
name|FT_Face_Internal
name|internal
init|=
name|NULL
decl_stmt|;
name|clazz
operator|=
name|driver
operator|->
name|clazz
expr_stmt|;
name|memory
operator|=
name|driver
operator|->
name|root
operator|.
name|memory
expr_stmt|;
comment|/* allocate the face object and perform basic initialization */
if|if
condition|(
name|FT_ALLOC
argument_list|(
name|face
argument_list|,
name|clazz
operator|->
name|face_object_size
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
if|if
condition|(
name|FT_NEW
argument_list|(
name|internal
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
name|face
operator|->
name|internal
operator|=
name|internal
expr_stmt|;
name|face
operator|->
name|driver
operator|=
name|driver
expr_stmt|;
name|face
operator|->
name|memory
operator|=
name|memory
expr_stmt|;
name|face
operator|->
name|stream
operator|=
name|stream
expr_stmt|;
ifdef|#
directive|ifdef
name|FT_CONFIG_OPTION_INCREMENTAL
block|{
name|int
name|i
decl_stmt|;
name|face
operator|->
name|internal
operator|->
name|incremental_interface
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_params
operator|&&
operator|!
name|face
operator|->
name|internal
operator|->
name|incremental_interface
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|params
index|[
name|i
index|]
operator|.
name|tag
operator|==
name|FT_PARAM_TAG_INCREMENTAL
condition|)
name|face
operator|->
name|internal
operator|->
name|incremental_interface
operator|=
operator|(
name|FT_Incremental_Interface
operator|)
name|params
index|[
name|i
index|]
operator|.
name|data
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|clazz
operator|->
name|init_face
condition|)
name|error
operator|=
name|clazz
operator|->
name|init_face
argument_list|(
name|stream
argument_list|,
name|face
argument_list|,
operator|(
name|FT_Int
operator|)
name|face_index
argument_list|,
name|num_params
argument_list|,
name|params
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Fail
goto|;
comment|/* select Unicode charmap by default */
name|error2
operator|=
name|find_unicode_charmap
argument_list|(
name|face
argument_list|)
expr_stmt|;
comment|/* if no Unicode charmap can be found, FT_Err_Invalid_CharMap_Handle */
comment|/* is returned.                                                      */
comment|/* no error should happen, but we want to play safe */
if|if
condition|(
name|error2
operator|&&
name|error2
operator|!=
name|FT_Err_Invalid_CharMap_Handle
condition|)
block|{
name|error
operator|=
name|error2
expr_stmt|;
goto|goto
name|Fail
goto|;
block|}
operator|*
name|aface
operator|=
name|face
expr_stmt|;
name|Fail
label|:
if|if
condition|(
name|error
condition|)
block|{
name|destroy_charmaps
argument_list|(
name|face
argument_list|,
name|memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|clazz
operator|->
name|done_face
operator|&&
name|face
condition|)
name|clazz
operator|->
name|done_face
argument_list|(
name|face
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|internal
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|face
argument_list|)
expr_stmt|;
operator|*
name|aface
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function
begin_comment
comment|/* there's a Mac-specific extended implementation of FT_New_Face() */
end_comment
begin_comment
comment|/* in src/base/ftmac.c                                             */
end_comment
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|FT_MACINTOSH
argument_list|)
operator|||
name|defined
argument_list|(
name|DARWIN_NO_CARBON
argument_list|)
end_if
begin_comment
comment|/* documentation is in freetype.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_New_Face
argument_list|(
argument|FT_Library   library
argument_list|,
argument|const char*  pathname
argument_list|,
argument|FT_Long      face_index
argument_list|,
argument|FT_Face     *aface
argument_list|)
end_macro
begin_block
block|{
name|FT_Open_Args
name|args
decl_stmt|;
comment|/* test for valid `library' and `aface' delayed to FT_Open_Face() */
if|if
condition|(
operator|!
name|pathname
condition|)
return|return
name|FT_Err_Invalid_Argument
return|;
name|args
operator|.
name|flags
operator|=
name|FT_OPEN_PATHNAME
expr_stmt|;
name|args
operator|.
name|pathname
operator|=
operator|(
name|char
operator|*
operator|)
name|pathname
expr_stmt|;
name|args
operator|.
name|stream
operator|=
name|NULL
expr_stmt|;
return|return
name|FT_Open_Face
argument_list|(
name|library
argument_list|,
operator|&
name|args
argument_list|,
name|face_index
argument_list|,
name|aface
argument_list|)
return|;
block|}
end_block
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* defined( FT_MACINTOSH )&& !defined( DARWIN_NO_CARBON ) */
end_comment
begin_comment
comment|/* documentation is in freetype.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_New_Memory_Face
argument_list|(
argument|FT_Library      library
argument_list|,
argument|const FT_Byte*  file_base
argument_list|,
argument|FT_Long         file_size
argument_list|,
argument|FT_Long         face_index
argument_list|,
argument|FT_Face        *aface
argument_list|)
end_macro
begin_block
block|{
name|FT_Open_Args
name|args
decl_stmt|;
comment|/* test for valid `library' and `face' delayed to FT_Open_Face() */
if|if
condition|(
operator|!
name|file_base
condition|)
return|return
name|FT_Err_Invalid_Argument
return|;
name|args
operator|.
name|flags
operator|=
name|FT_OPEN_MEMORY
expr_stmt|;
name|args
operator|.
name|memory_base
operator|=
name|file_base
expr_stmt|;
name|args
operator|.
name|memory_size
operator|=
name|file_size
expr_stmt|;
name|args
operator|.
name|stream
operator|=
name|NULL
expr_stmt|;
return|return
name|FT_Open_Face
argument_list|(
name|library
argument_list|,
operator|&
name|args
argument_list|,
name|face_index
argument_list|,
name|aface
argument_list|)
return|;
block|}
end_block
begin_ifdef
ifdef|#
directive|ifdef
name|FT_CONFIG_OPTION_MAC_FONTS
end_ifdef
begin_comment
comment|/* The behavior here is very similar to that in base/ftmac.c, but it     */
end_comment
begin_comment
comment|/* is designed to work on non-mac systems, so no mac specific calls.     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* We look at the file and determine if it is a mac dfont file or a mac  */
end_comment
begin_comment
comment|/* resource file, or a macbinary file containing a mac resource file.    */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* Unlike ftmac I'm not going to look at a `FOND'.  I don't really see   */
end_comment
begin_comment
comment|/* the point, especially since there may be multiple `FOND' resources.   */
end_comment
begin_comment
comment|/* Instead I'll just look for `sfnt' and `POST' resources, ordered as    */
end_comment
begin_comment
comment|/* they occur in the file.                                               */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* Note that multiple `POST' resources do not mean multiple postscript   */
end_comment
begin_comment
comment|/* fonts; they all get jammed together to make what is essentially a     */
end_comment
begin_comment
comment|/* pfb file.                                                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* We aren't interested in `NFNT' or `FONT' bitmap resources.            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* As soon as we get an `sfnt' load it into memory and pass it off to    */
end_comment
begin_comment
comment|/* FT_Open_Face.                                                         */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* If we have a (set of) `POST' resources, massage them into a (memory)  */
end_comment
begin_comment
comment|/* pfb file and pass that to FT_Open_Face.  (As with ftmac.c I'm not     */
end_comment
begin_comment
comment|/* going to try to save the kerning info.  After all that lives in the   */
end_comment
begin_comment
comment|/* `FOND' which isn't in the file containing the `POST' resources so     */
end_comment
begin_comment
comment|/* we don't really have access to it.                                    */
end_comment
begin_comment
comment|/* Finalizer for a memory stream; gets called by FT_Done_Face(). */
end_comment
begin_comment
comment|/* It frees the memory it uses.                                  */
end_comment
begin_comment
comment|/* From ftmac.c.                                                 */
end_comment
begin_function
specifier|static
name|void
DECL|function|memory_stream_close
name|memory_stream_close
parameter_list|(
name|FT_Stream
name|stream
parameter_list|)
block|{
name|FT_Memory
name|memory
init|=
name|stream
operator|->
name|memory
decl_stmt|;
name|FT_FREE
argument_list|(
name|stream
operator|->
name|base
argument_list|)
expr_stmt|;
name|stream
operator|->
name|size
operator|=
literal|0
expr_stmt|;
name|stream
operator|->
name|base
operator|=
literal|0
expr_stmt|;
name|stream
operator|->
name|close
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_comment
comment|/* Create a new memory stream from a buffer and a size. */
end_comment
begin_comment
comment|/* From ftmac.c.                                        */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|new_memory_stream
name|new_memory_stream
parameter_list|(
name|FT_Library
name|library
parameter_list|,
name|FT_Byte
modifier|*
name|base
parameter_list|,
name|FT_ULong
name|size
parameter_list|,
name|FT_Stream_CloseFunc
name|close
parameter_list|,
name|FT_Stream
modifier|*
name|astream
parameter_list|)
block|{
name|FT_Error
name|error
decl_stmt|;
name|FT_Memory
name|memory
decl_stmt|;
name|FT_Stream
name|stream
decl_stmt|;
if|if
condition|(
operator|!
name|library
condition|)
return|return
name|FT_Err_Invalid_Library_Handle
return|;
if|if
condition|(
operator|!
name|base
condition|)
return|return
name|FT_Err_Invalid_Argument
return|;
operator|*
name|astream
operator|=
literal|0
expr_stmt|;
name|memory
operator|=
name|library
operator|->
name|memory
expr_stmt|;
if|if
condition|(
name|FT_NEW
argument_list|(
name|stream
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|FT_Stream_OpenMemory
argument_list|(
name|stream
argument_list|,
name|base
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|stream
operator|->
name|close
operator|=
name|close
expr_stmt|;
operator|*
name|astream
operator|=
name|stream
expr_stmt|;
name|Exit
label|:
return|return
name|error
return|;
block|}
end_function
begin_comment
comment|/* Create a new FT_Face given a buffer and a driver name. */
end_comment
begin_comment
comment|/* from ftmac.c */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|open_face_from_buffer
argument_list|(
argument|FT_Library   library
argument_list|,
argument|FT_Byte*     base
argument_list|,
argument|FT_ULong     size
argument_list|,
argument|FT_Long      face_index
argument_list|,
argument|const char*  driver_name
argument_list|,
argument|FT_Face     *aface
argument_list|)
end_macro
begin_block
block|{
name|FT_Open_Args
name|args
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|FT_Stream
name|stream
init|=
name|NULL
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|library
operator|->
name|memory
decl_stmt|;
name|error
operator|=
name|new_memory_stream
argument_list|(
name|library
argument_list|,
name|base
argument_list|,
name|size
argument_list|,
name|memory_stream_close
argument_list|,
operator|&
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|FT_FREE
argument_list|(
name|base
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|args
operator|.
name|flags
operator|=
name|FT_OPEN_STREAM
expr_stmt|;
name|args
operator|.
name|stream
operator|=
name|stream
expr_stmt|;
if|if
condition|(
name|driver_name
condition|)
block|{
name|args
operator|.
name|flags
operator|=
name|args
operator|.
name|flags
operator||
name|FT_OPEN_DRIVER
expr_stmt|;
name|args
operator|.
name|driver
operator|=
name|FT_Get_Module
argument_list|(
name|library
argument_list|,
name|driver_name
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|FT_MACINTOSH
comment|/* At this point, face_index has served its purpose;      */
comment|/* whoever calls this function has already used it to     */
comment|/* locate the correct font data.  We should not propagate */
comment|/* this index to FT_Open_Face() (unless it is negative).  */
if|if
condition|(
name|face_index
operator|>
literal|0
condition|)
name|face_index
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|error
operator|=
name|FT_Open_Face
argument_list|(
name|library
argument_list|,
operator|&
name|args
argument_list|,
name|face_index
argument_list|,
name|aface
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|FT_Err_Ok
condition|)
operator|(
operator|*
name|aface
operator|)
operator|->
name|face_flags
operator|&=
operator|~
name|FT_FACE_FLAG_EXTERNAL_STREAM
expr_stmt|;
else|else
ifdef|#
directive|ifdef
name|FT_MACINTOSH
name|FT_Stream_Free
argument_list|(
name|stream
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
block|{
name|FT_Stream_Close
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|stream
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/* Look up `TYP1' or `CID ' table from sfnt table directory.       */
end_comment
begin_comment
comment|/* `offset' and `length' must exclude the binary header in tables. */
end_comment
begin_comment
comment|/* Type 1 and CID-keyed font drivers should recognize sfnt-wrapped */
end_comment
begin_comment
comment|/* format too.  Here, since we can't expect that the TrueType font */
end_comment
begin_comment
comment|/* driver is loaded unconditially, we must parse the font by       */
end_comment
begin_comment
comment|/* ourselves.  We are only interested in the name of the table and */
end_comment
begin_comment
comment|/* the offset.                                                     */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|ft_lookup_PS_in_sfnt_stream
name|ft_lookup_PS_in_sfnt_stream
parameter_list|(
name|FT_Stream
name|stream
parameter_list|,
name|FT_Long
name|face_index
parameter_list|,
name|FT_ULong
modifier|*
name|offset
parameter_list|,
name|FT_ULong
modifier|*
name|length
parameter_list|,
name|FT_Bool
modifier|*
name|is_sfnt_cid
parameter_list|)
block|{
name|FT_Error
name|error
decl_stmt|;
name|FT_UShort
name|numTables
decl_stmt|;
name|FT_Long
name|pstable_index
decl_stmt|;
name|FT_ULong
name|tag
decl_stmt|;
name|int
name|i
decl_stmt|;
operator|*
name|offset
operator|=
literal|0
expr_stmt|;
operator|*
name|length
operator|=
literal|0
expr_stmt|;
operator|*
name|is_sfnt_cid
operator|=
name|FALSE
expr_stmt|;
comment|/* TODO: support for sfnt-wrapped PS/CID in TTC format */
comment|/* version check for 'typ1' (should be ignored?) */
if|if
condition|(
name|FT_READ_ULONG
argument_list|(
name|tag
argument_list|)
condition|)
return|return
name|error
return|;
if|if
condition|(
name|tag
operator|!=
name|TTAG_typ1
condition|)
return|return
name|FT_Err_Unknown_File_Format
return|;
if|if
condition|(
name|FT_READ_USHORT
argument_list|(
name|numTables
argument_list|)
condition|)
return|return
name|error
return|;
if|if
condition|(
name|FT_STREAM_SKIP
argument_list|(
literal|2
operator|*
literal|3
argument_list|)
condition|)
comment|/* skip binary search header */
return|return
name|error
return|;
name|pstable_index
operator|=
operator|-
literal|1
expr_stmt|;
operator|*
name|is_sfnt_cid
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numTables
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|FT_READ_ULONG
argument_list|(
name|tag
argument_list|)
operator|||
name|FT_STREAM_SKIP
argument_list|(
literal|4
argument_list|)
operator|||
name|FT_READ_ULONG
argument_list|(
operator|*
name|offset
argument_list|)
operator|||
name|FT_READ_ULONG
argument_list|(
operator|*
name|length
argument_list|)
condition|)
return|return
name|error
return|;
if|if
condition|(
name|tag
operator|==
name|TTAG_CID
condition|)
block|{
name|pstable_index
operator|++
expr_stmt|;
operator|*
name|offset
operator|+=
literal|22
expr_stmt|;
operator|*
name|length
operator|-=
literal|22
expr_stmt|;
operator|*
name|is_sfnt_cid
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|face_index
operator|<
literal|0
condition|)
return|return
name|FT_Err_Ok
return|;
block|}
elseif|else
if|if
condition|(
name|tag
operator|==
name|TTAG_TYP1
condition|)
block|{
name|pstable_index
operator|++
expr_stmt|;
operator|*
name|offset
operator|+=
literal|24
expr_stmt|;
operator|*
name|length
operator|-=
literal|24
expr_stmt|;
operator|*
name|is_sfnt_cid
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|face_index
operator|<
literal|0
condition|)
return|return
name|FT_Err_Ok
return|;
block|}
if|if
condition|(
name|face_index
operator|>=
literal|0
operator|&&
name|pstable_index
operator|==
name|face_index
condition|)
return|return
name|FT_Err_Ok
return|;
block|}
return|return
name|FT_Err_Table_Missing
return|;
block|}
end_function
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|open_face_PS_from_sfnt_stream
argument_list|(
argument|FT_Library     library
argument_list|,
argument|FT_Stream      stream
argument_list|,
argument|FT_Long        face_index
argument_list|,
argument|FT_Int         num_params
argument_list|,
argument|FT_Parameter  *params
argument_list|,
argument|FT_Face       *aface
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|library
operator|->
name|memory
decl_stmt|;
name|FT_ULong
name|offset
decl_stmt|,
name|length
decl_stmt|;
name|FT_Long
name|pos
decl_stmt|;
name|FT_Bool
name|is_sfnt_cid
decl_stmt|;
name|FT_Byte
modifier|*
name|sfnt_ps
decl_stmt|;
name|FT_UNUSED
argument_list|(
name|num_params
argument_list|)
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|params
argument_list|)
expr_stmt|;
name|pos
operator|=
name|FT_Stream_Pos
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|error
operator|=
name|ft_lookup_PS_in_sfnt_stream
argument_list|(
name|stream
argument_list|,
name|face_index
argument_list|,
operator|&
name|offset
argument_list|,
operator|&
name|length
argument_list|,
operator|&
name|is_sfnt_cid
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
if|if
condition|(
name|FT_Stream_Seek
argument_list|(
name|stream
argument_list|,
name|pos
operator|+
name|offset
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
if|if
condition|(
name|FT_ALLOC
argument_list|(
name|sfnt_ps
argument_list|,
operator|(
name|FT_Long
operator|)
name|length
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|error
operator|=
name|FT_Stream_Read
argument_list|(
name|stream
argument_list|,
operator|(
name|FT_Byte
operator|*
operator|)
name|sfnt_ps
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|error
operator|=
name|open_face_from_buffer
argument_list|(
name|library
argument_list|,
name|sfnt_ps
argument_list|,
name|length
argument_list|,
name|face_index
operator|<
literal|0
condition|?
name|face_index
else|:
literal|0
argument_list|,
name|is_sfnt_cid
condition|?
literal|"cid"
else|:
literal|"type1"
argument_list|,
name|aface
argument_list|)
expr_stmt|;
name|Exit
label|:
block|{
name|FT_Error
name|error1
decl_stmt|;
if|if
condition|(
name|error
operator|==
name|FT_Err_Unknown_File_Format
condition|)
block|{
name|error1
operator|=
name|FT_Stream_Seek
argument_list|(
name|stream
argument_list|,
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|error1
condition|)
return|return
name|error1
return|;
block|}
return|return
name|error
return|;
block|}
block|}
end_block
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|FT_MACINTOSH
argument_list|)
operator|||
name|defined
argument_list|(
name|DARWIN_NO_CARBON
argument_list|)
end_if
begin_comment
comment|/* The resource header says we've got resource_cnt `POST' (type1) */
end_comment
begin_comment
comment|/* resources in this file.  They all need to be coalesced into    */
end_comment
begin_comment
comment|/* one lump which gets passed on to the type1 driver.             */
end_comment
begin_comment
comment|/* Here can be only one PostScript font in a file so face_index   */
end_comment
begin_comment
comment|/* must be 0 (or -1).                                             */
end_comment
begin_comment
comment|/*                                                                */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|Mac_Read_POST_Resource
name|Mac_Read_POST_Resource
parameter_list|(
name|FT_Library
name|library
parameter_list|,
name|FT_Stream
name|stream
parameter_list|,
name|FT_Long
modifier|*
name|offsets
parameter_list|,
name|FT_Long
name|resource_cnt
parameter_list|,
name|FT_Long
name|face_index
parameter_list|,
name|FT_Face
modifier|*
name|aface
parameter_list|)
block|{
name|FT_Error
name|error
init|=
name|FT_Err_Cannot_Open_Resource
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|library
operator|->
name|memory
decl_stmt|;
name|FT_Byte
modifier|*
name|pfb_data
decl_stmt|;
name|int
name|i
decl_stmt|,
name|type
decl_stmt|,
name|flags
decl_stmt|;
name|FT_Long
name|len
decl_stmt|;
name|FT_Long
name|pfb_len
decl_stmt|,
name|pfb_pos
decl_stmt|,
name|pfb_lenpos
decl_stmt|;
name|FT_Long
name|rlen
decl_stmt|,
name|temp
decl_stmt|;
if|if
condition|(
name|face_index
operator|==
operator|-
literal|1
condition|)
name|face_index
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|face_index
operator|!=
literal|0
condition|)
return|return
name|error
return|;
comment|/* Find the length of all the POST resources, concatenated.  Assume */
comment|/* worst case (each resource in its own section).                   */
name|pfb_len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|resource_cnt
condition|;
operator|++
name|i
control|)
block|{
name|error
operator|=
name|FT_Stream_Seek
argument_list|(
name|stream
argument_list|,
name|offsets
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
if|if
condition|(
name|FT_READ_LONG
argument_list|(
name|temp
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|pfb_len
operator|+=
name|temp
operator|+
literal|6
expr_stmt|;
block|}
if|if
condition|(
name|FT_ALLOC
argument_list|(
name|pfb_data
argument_list|,
operator|(
name|FT_Long
operator|)
name|pfb_len
operator|+
literal|2
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|pfb_data
index|[
literal|0
index|]
operator|=
literal|0x80
expr_stmt|;
name|pfb_data
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
comment|/* Ascii section */
name|pfb_data
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
comment|/* 4-byte length, fill in later */
name|pfb_data
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|pfb_data
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
name|pfb_data
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
name|pfb_pos
operator|=
literal|6
expr_stmt|;
name|pfb_lenpos
operator|=
literal|2
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
name|type
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|resource_cnt
condition|;
operator|++
name|i
control|)
block|{
name|error
operator|=
name|FT_Stream_Seek
argument_list|(
name|stream
argument_list|,
name|offsets
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit2
goto|;
if|if
condition|(
name|FT_READ_LONG
argument_list|(
name|rlen
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
if|if
condition|(
name|FT_READ_USHORT
argument_list|(
name|flags
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|rlen
operator|-=
literal|2
expr_stmt|;
comment|/* the flags are part of the resource */
if|if
condition|(
operator|(
name|flags
operator|>>
literal|8
operator|)
operator|==
name|type
condition|)
name|len
operator|+=
name|rlen
expr_stmt|;
else|else
block|{
name|pfb_data
index|[
name|pfb_lenpos
index|]
operator|=
call|(
name|FT_Byte
call|)
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|pfb_data
index|[
name|pfb_lenpos
operator|+
literal|1
index|]
operator|=
call|(
name|FT_Byte
call|)
argument_list|(
name|len
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|pfb_data
index|[
name|pfb_lenpos
operator|+
literal|2
index|]
operator|=
call|(
name|FT_Byte
call|)
argument_list|(
name|len
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|pfb_data
index|[
name|pfb_lenpos
operator|+
literal|3
index|]
operator|=
call|(
name|FT_Byte
call|)
argument_list|(
name|len
operator|>>
literal|24
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|>>
literal|8
operator|)
operator|==
literal|5
condition|)
comment|/* End of font mark */
break|break;
name|pfb_data
index|[
name|pfb_pos
operator|++
index|]
operator|=
literal|0x80
expr_stmt|;
name|type
operator|=
name|flags
operator|>>
literal|8
expr_stmt|;
name|len
operator|=
name|rlen
expr_stmt|;
name|pfb_data
index|[
name|pfb_pos
operator|++
index|]
operator|=
operator|(
name|FT_Byte
operator|)
name|type
expr_stmt|;
name|pfb_lenpos
operator|=
name|pfb_pos
expr_stmt|;
name|pfb_data
index|[
name|pfb_pos
operator|++
index|]
operator|=
literal|0
expr_stmt|;
comment|/* 4-byte length, fill in later */
name|pfb_data
index|[
name|pfb_pos
operator|++
index|]
operator|=
literal|0
expr_stmt|;
name|pfb_data
index|[
name|pfb_pos
operator|++
index|]
operator|=
literal|0
expr_stmt|;
name|pfb_data
index|[
name|pfb_pos
operator|++
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|error
operator|=
name|FT_Stream_Read
argument_list|(
name|stream
argument_list|,
operator|(
name|FT_Byte
operator|*
operator|)
name|pfb_data
operator|+
name|pfb_pos
argument_list|,
name|rlen
argument_list|)
expr_stmt|;
name|pfb_pos
operator|+=
name|rlen
expr_stmt|;
block|}
name|pfb_data
index|[
name|pfb_pos
operator|++
index|]
operator|=
literal|0x80
expr_stmt|;
name|pfb_data
index|[
name|pfb_pos
operator|++
index|]
operator|=
literal|3
expr_stmt|;
name|pfb_data
index|[
name|pfb_lenpos
index|]
operator|=
call|(
name|FT_Byte
call|)
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|pfb_data
index|[
name|pfb_lenpos
operator|+
literal|1
index|]
operator|=
call|(
name|FT_Byte
call|)
argument_list|(
name|len
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|pfb_data
index|[
name|pfb_lenpos
operator|+
literal|2
index|]
operator|=
call|(
name|FT_Byte
call|)
argument_list|(
name|len
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|pfb_data
index|[
name|pfb_lenpos
operator|+
literal|3
index|]
operator|=
call|(
name|FT_Byte
call|)
argument_list|(
name|len
operator|>>
literal|24
argument_list|)
expr_stmt|;
return|return
name|open_face_from_buffer
argument_list|(
name|library
argument_list|,
name|pfb_data
argument_list|,
name|pfb_pos
argument_list|,
name|face_index
argument_list|,
literal|"type1"
argument_list|,
name|aface
argument_list|)
return|;
name|Exit2
label|:
name|FT_FREE
argument_list|(
name|pfb_data
argument_list|)
expr_stmt|;
name|Exit
label|:
return|return
name|error
return|;
block|}
end_function
begin_comment
comment|/* The resource header says we've got resource_cnt `sfnt'      */
end_comment
begin_comment
comment|/* (TrueType/OpenType) resources in this file.  Look through   */
end_comment
begin_comment
comment|/* them for the one indicated by face_index, load it into mem, */
end_comment
begin_comment
comment|/* pass it on the the truetype driver and return it.           */
end_comment
begin_comment
comment|/*                                                             */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|Mac_Read_sfnt_Resource
name|Mac_Read_sfnt_Resource
parameter_list|(
name|FT_Library
name|library
parameter_list|,
name|FT_Stream
name|stream
parameter_list|,
name|FT_Long
modifier|*
name|offsets
parameter_list|,
name|FT_Long
name|resource_cnt
parameter_list|,
name|FT_Long
name|face_index
parameter_list|,
name|FT_Face
modifier|*
name|aface
parameter_list|)
block|{
name|FT_Memory
name|memory
init|=
name|library
operator|->
name|memory
decl_stmt|;
name|FT_Byte
modifier|*
name|sfnt_data
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|FT_Long
name|flag_offset
decl_stmt|;
name|FT_Long
name|rlen
decl_stmt|;
name|int
name|is_cff
decl_stmt|;
name|FT_Long
name|face_index_in_resource
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|face_index
operator|==
operator|-
literal|1
condition|)
name|face_index
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|face_index
operator|>=
name|resource_cnt
condition|)
return|return
name|FT_Err_Cannot_Open_Resource
return|;
name|flag_offset
operator|=
name|offsets
index|[
name|face_index
index|]
expr_stmt|;
name|error
operator|=
name|FT_Stream_Seek
argument_list|(
name|stream
argument_list|,
name|flag_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
if|if
condition|(
name|FT_READ_LONG
argument_list|(
name|rlen
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
if|if
condition|(
name|rlen
operator|==
operator|-
literal|1
condition|)
return|return
name|FT_Err_Cannot_Open_Resource
return|;
name|error
operator|=
name|open_face_PS_from_sfnt_stream
argument_list|(
name|library
argument_list|,
name|stream
argument_list|,
name|face_index
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|aface
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
goto|goto
name|Exit
goto|;
comment|/* rewind sfnt stream before open_face_PS_from_sfnt_stream() */
if|if
condition|(
name|FT_Stream_Seek
argument_list|(
name|stream
argument_list|,
name|flag_offset
operator|+
literal|4
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
if|if
condition|(
name|FT_ALLOC
argument_list|(
name|sfnt_data
argument_list|,
operator|(
name|FT_Long
operator|)
name|rlen
argument_list|)
condition|)
return|return
name|error
return|;
name|error
operator|=
name|FT_Stream_Read
argument_list|(
name|stream
argument_list|,
operator|(
name|FT_Byte
operator|*
operator|)
name|sfnt_data
argument_list|,
name|rlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|is_cff
operator|=
name|rlen
operator|>
literal|4
operator|&&
operator|!
name|ft_memcmp
argument_list|(
name|sfnt_data
argument_list|,
literal|"OTTO"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|error
operator|=
name|open_face_from_buffer
argument_list|(
name|library
argument_list|,
name|sfnt_data
argument_list|,
name|rlen
argument_list|,
name|face_index_in_resource
argument_list|,
name|is_cff
condition|?
literal|"cff"
else|:
literal|"truetype"
argument_list|,
name|aface
argument_list|)
expr_stmt|;
name|Exit
label|:
return|return
name|error
return|;
block|}
end_function
begin_comment
comment|/* Check for a valid resource fork header, or a valid dfont    */
end_comment
begin_comment
comment|/* header.  In a resource fork the first 16 bytes are repeated */
end_comment
begin_comment
comment|/* at the location specified by bytes 4-7.  In a dfont bytes   */
end_comment
begin_comment
comment|/* 4-7 point to 16 bytes of zeroes instead.                    */
end_comment
begin_comment
comment|/*                                                             */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|IsMacResource
name|IsMacResource
parameter_list|(
name|FT_Library
name|library
parameter_list|,
name|FT_Stream
name|stream
parameter_list|,
name|FT_Long
name|resource_offset
parameter_list|,
name|FT_Long
name|face_index
parameter_list|,
name|FT_Face
modifier|*
name|aface
parameter_list|)
block|{
name|FT_Memory
name|memory
init|=
name|library
operator|->
name|memory
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|FT_Long
name|map_offset
decl_stmt|,
name|rdara_pos
decl_stmt|;
name|FT_Long
modifier|*
name|data_offsets
decl_stmt|;
name|FT_Long
name|count
decl_stmt|;
name|error
operator|=
name|FT_Raccess_Get_HeaderInfo
argument_list|(
name|library
argument_list|,
name|stream
argument_list|,
name|resource_offset
argument_list|,
operator|&
name|map_offset
argument_list|,
operator|&
name|rdara_pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|error
operator|=
name|FT_Raccess_Get_DataOffsets
argument_list|(
name|library
argument_list|,
name|stream
argument_list|,
name|map_offset
argument_list|,
name|rdara_pos
argument_list|,
name|TTAG_POST
argument_list|,
operator|&
name|data_offsets
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|error
operator|=
name|Mac_Read_POST_Resource
argument_list|(
name|library
argument_list|,
name|stream
argument_list|,
name|data_offsets
argument_list|,
name|count
argument_list|,
name|face_index
argument_list|,
name|aface
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|data_offsets
argument_list|)
expr_stmt|;
comment|/* POST exists in an LWFN providing a single face */
if|if
condition|(
operator|!
name|error
condition|)
operator|(
operator|*
name|aface
operator|)
operator|->
name|num_faces
operator|=
literal|1
expr_stmt|;
return|return
name|error
return|;
block|}
name|error
operator|=
name|FT_Raccess_Get_DataOffsets
argument_list|(
name|library
argument_list|,
name|stream
argument_list|,
name|map_offset
argument_list|,
name|rdara_pos
argument_list|,
name|TTAG_sfnt
argument_list|,
operator|&
name|data_offsets
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|FT_Long
name|face_index_internal
init|=
name|face_index
operator|%
name|count
decl_stmt|;
name|error
operator|=
name|Mac_Read_sfnt_Resource
argument_list|(
name|library
argument_list|,
name|stream
argument_list|,
name|data_offsets
argument_list|,
name|count
argument_list|,
name|face_index_internal
argument_list|,
name|aface
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|data_offsets
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
operator|(
operator|*
name|aface
operator|)
operator|->
name|num_faces
operator|=
name|count
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function
begin_comment
comment|/* Check for a valid macbinary header, and if we find one   */
end_comment
begin_comment
comment|/* check that the (flattened) resource fork in it is valid. */
end_comment
begin_comment
comment|/*                                                          */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|IsMacBinary
name|IsMacBinary
parameter_list|(
name|FT_Library
name|library
parameter_list|,
name|FT_Stream
name|stream
parameter_list|,
name|FT_Long
name|face_index
parameter_list|,
name|FT_Face
modifier|*
name|aface
parameter_list|)
block|{
name|unsigned
name|char
name|header
index|[
literal|128
index|]
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|FT_Long
name|dlen
decl_stmt|,
name|offset
decl_stmt|;
if|if
condition|(
name|NULL
operator|==
name|stream
condition|)
return|return
name|FT_Err_Invalid_Stream_Operation
return|;
name|error
operator|=
name|FT_Stream_Seek
argument_list|(
name|stream
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|error
operator|=
name|FT_Stream_Read
argument_list|(
name|stream
argument_list|,
operator|(
name|FT_Byte
operator|*
operator|)
name|header
argument_list|,
literal|128
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
if|if
condition|(
name|header
index|[
literal|0
index|]
operator|!=
literal|0
operator|||
name|header
index|[
literal|74
index|]
operator|!=
literal|0
operator|||
name|header
index|[
literal|82
index|]
operator|!=
literal|0
operator|||
name|header
index|[
literal|1
index|]
operator|==
literal|0
operator|||
name|header
index|[
literal|1
index|]
operator|>
literal|33
operator|||
name|header
index|[
literal|63
index|]
operator|!=
literal|0
operator|||
name|header
index|[
literal|2
operator|+
name|header
index|[
literal|1
index|]
index|]
operator|!=
literal|0
condition|)
return|return
name|FT_Err_Unknown_File_Format
return|;
name|dlen
operator|=
operator|(
name|header
index|[
literal|0x53
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|header
index|[
literal|0x54
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|header
index|[
literal|0x55
index|]
operator|<<
literal|8
operator|)
operator||
name|header
index|[
literal|0x56
index|]
expr_stmt|;
if|#
directive|if
literal|0
block|rlen = ( header[0x57]<< 24 ) |            ( header[0x58]<< 16 ) |            ( header[0x59]<<  8 ) |              header[0x5a];
endif|#
directive|endif
comment|/* 0 */
name|offset
operator|=
literal|128
operator|+
operator|(
operator|(
name|dlen
operator|+
literal|127
operator|)
operator|&
operator|~
literal|127
operator|)
expr_stmt|;
return|return
name|IsMacResource
argument_list|(
name|library
argument_list|,
name|stream
argument_list|,
name|offset
argument_list|,
name|face_index
argument_list|,
name|aface
argument_list|)
return|;
name|Exit
label|:
return|return
name|error
return|;
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|load_face_in_embedded_rfork
name|load_face_in_embedded_rfork
parameter_list|(
name|FT_Library
name|library
parameter_list|,
name|FT_Stream
name|stream
parameter_list|,
name|FT_Long
name|face_index
parameter_list|,
name|FT_Face
modifier|*
name|aface
parameter_list|,
specifier|const
name|FT_Open_Args
modifier|*
name|args
parameter_list|)
block|{
DECL|macro|FT_COMPONENT
undef|#
directive|undef
name|FT_COMPONENT
DECL|macro|FT_COMPONENT
define|#
directive|define
name|FT_COMPONENT
value|trace_raccess
name|FT_Memory
name|memory
init|=
name|library
operator|->
name|memory
decl_stmt|;
name|FT_Error
name|error
init|=
name|FT_Err_Unknown_File_Format
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|file_names
index|[
name|FT_RACCESS_N_RULES
index|]
decl_stmt|;
name|FT_Long
name|offsets
index|[
name|FT_RACCESS_N_RULES
index|]
decl_stmt|;
name|FT_Error
name|errors
index|[
name|FT_RACCESS_N_RULES
index|]
decl_stmt|;
name|FT_Open_Args
name|args2
decl_stmt|;
name|FT_Stream
name|stream2
init|=
literal|0
decl_stmt|;
name|FT_Raccess_Guess
argument_list|(
name|library
argument_list|,
name|stream
argument_list|,
name|args
operator|->
name|pathname
argument_list|,
name|file_names
argument_list|,
name|offsets
argument_list|,
name|errors
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FT_RACCESS_N_RULES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|errors
index|[
name|i
index|]
condition|)
block|{
name|FT_TRACE3
argument_list|(
operator|(
literal|"Error[%d] has occurred in rule %d\n"
operator|,
name|errors
index|[
name|i
index|]
operator|,
name|i
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|args2
operator|.
name|flags
operator|=
name|FT_OPEN_PATHNAME
expr_stmt|;
name|args2
operator|.
name|pathname
operator|=
name|file_names
index|[
name|i
index|]
condition|?
name|file_names
index|[
name|i
index|]
else|:
name|args
operator|->
name|pathname
expr_stmt|;
name|FT_TRACE3
argument_list|(
operator|(
literal|"Try rule %d: %s (offset=%d) ..."
operator|,
name|i
operator|,
name|args2
operator|.
name|pathname
operator|,
name|offsets
index|[
name|i
index|]
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|FT_Stream_New
argument_list|(
name|library
argument_list|,
operator|&
name|args2
argument_list|,
operator|&
name|stream2
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|FT_TRACE3
argument_list|(
operator|(
literal|"failed\n"
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|error
operator|=
name|IsMacResource
argument_list|(
name|library
argument_list|,
name|stream2
argument_list|,
name|offsets
index|[
name|i
index|]
argument_list|,
name|face_index
argument_list|,
name|aface
argument_list|)
expr_stmt|;
name|FT_Stream_Free
argument_list|(
name|stream2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FT_TRACE3
argument_list|(
operator|(
literal|"%s\n"
operator|,
name|error
condition|?
literal|"failed"
else|:
literal|"successful"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FT_RACCESS_N_RULES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|file_names
index|[
name|i
index|]
condition|)
name|FT_FREE
argument_list|(
name|file_names
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Caller (load_mac_face) requires FT_Err_Unknown_File_Format. */
if|if
condition|(
name|error
condition|)
name|error
operator|=
name|FT_Err_Unknown_File_Format
expr_stmt|;
return|return
name|error
return|;
DECL|macro|FT_COMPONENT
undef|#
directive|undef
name|FT_COMPONENT
DECL|macro|FT_COMPONENT
define|#
directive|define
name|FT_COMPONENT
value|trace_objs
block|}
end_function
begin_comment
comment|/* Check for some macintosh formats without Carbon framework.    */
end_comment
begin_comment
comment|/* Is this a macbinary file?  If so look at the resource fork.   */
end_comment
begin_comment
comment|/* Is this a mac dfont file?                                     */
end_comment
begin_comment
comment|/* Is this an old style resource fork? (in data)                 */
end_comment
begin_comment
comment|/* Else call load_face_in_embedded_rfork to try extra rules      */
end_comment
begin_comment
comment|/* (defined in `ftrfork.c').                                     */
end_comment
begin_comment
comment|/*                                                               */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|load_mac_face
name|load_mac_face
parameter_list|(
name|FT_Library
name|library
parameter_list|,
name|FT_Stream
name|stream
parameter_list|,
name|FT_Long
name|face_index
parameter_list|,
name|FT_Face
modifier|*
name|aface
parameter_list|,
specifier|const
name|FT_Open_Args
modifier|*
name|args
parameter_list|)
block|{
name|FT_Error
name|error
decl_stmt|;
name|FT_UNUSED
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|error
operator|=
name|IsMacBinary
argument_list|(
name|library
argument_list|,
name|stream
argument_list|,
name|face_index
argument_list|,
name|aface
argument_list|)
expr_stmt|;
if|if
condition|(
name|FT_ERROR_BASE
argument_list|(
name|error
argument_list|)
operator|==
name|FT_Err_Unknown_File_Format
condition|)
block|{
DECL|macro|FT_COMPONENT
undef|#
directive|undef
name|FT_COMPONENT
DECL|macro|FT_COMPONENT
define|#
directive|define
name|FT_COMPONENT
value|trace_raccess
name|FT_TRACE3
argument_list|(
operator|(
literal|"Try as dfont: %s ..."
operator|,
name|args
operator|->
name|pathname
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|IsMacResource
argument_list|(
name|library
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
name|face_index
argument_list|,
name|aface
argument_list|)
expr_stmt|;
name|FT_TRACE3
argument_list|(
operator|(
literal|"%s\n"
operator|,
name|error
condition|?
literal|"failed"
else|:
literal|"successful"
operator|)
argument_list|)
expr_stmt|;
DECL|macro|FT_COMPONENT
undef|#
directive|undef
name|FT_COMPONENT
DECL|macro|FT_COMPONENT
define|#
directive|define
name|FT_COMPONENT
value|trace_objs
block|}
if|if
condition|(
operator|(
name|FT_ERROR_BASE
argument_list|(
name|error
argument_list|)
operator|==
name|FT_Err_Unknown_File_Format
operator|||
name|FT_ERROR_BASE
argument_list|(
name|error
argument_list|)
operator|==
name|FT_Err_Invalid_Stream_Operation
operator|)
operator|&&
operator|(
name|args
operator|->
name|flags
operator|&
name|FT_OPEN_PATHNAME
operator|)
condition|)
name|error
operator|=
name|load_face_in_embedded_rfork
argument_list|(
name|library
argument_list|,
name|stream
argument_list|,
name|face_index
argument_list|,
name|aface
argument_list|,
name|args
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* !FT_MACINTOSH&& FT_CONFIG_OPTION_MAC_FONTS */
end_comment
begin_comment
comment|/* documentation is in freetype.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_Open_Face
argument_list|(
argument|FT_Library           library
argument_list|,
argument|const FT_Open_Args*  args
argument_list|,
argument|FT_Long              face_index
argument_list|,
argument|FT_Face             *aface
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
decl_stmt|;
name|FT_Driver
name|driver
decl_stmt|;
name|FT_Memory
name|memory
decl_stmt|;
name|FT_Stream
name|stream
init|=
literal|0
decl_stmt|;
name|FT_Face
name|face
init|=
literal|0
decl_stmt|;
name|FT_ListNode
name|node
init|=
literal|0
decl_stmt|;
name|FT_Bool
name|external_stream
decl_stmt|;
name|FT_Module
modifier|*
name|cur
decl_stmt|;
name|FT_Module
modifier|*
name|limit
decl_stmt|;
comment|/* test for valid `library' delayed to */
comment|/* FT_Stream_New()                     */
if|if
condition|(
operator|(
operator|!
name|aface
operator|&&
name|face_index
operator|>=
literal|0
operator|)
operator|||
operator|!
name|args
condition|)
return|return
name|FT_Err_Invalid_Argument
return|;
name|external_stream
operator|=
name|FT_BOOL
argument_list|(
operator|(
name|args
operator|->
name|flags
operator|&
name|FT_OPEN_STREAM
operator|)
operator|&&
name|args
operator|->
name|stream
argument_list|)
expr_stmt|;
comment|/* create input stream */
name|error
operator|=
name|FT_Stream_New
argument_list|(
name|library
argument_list|,
name|args
argument_list|,
operator|&
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Fail3
goto|;
name|memory
operator|=
name|library
operator|->
name|memory
expr_stmt|;
comment|/* If the font driver is specified in the `args' structure, use */
comment|/* it.  Otherwise, we scan the list of registered drivers.      */
if|if
condition|(
operator|(
name|args
operator|->
name|flags
operator|&
name|FT_OPEN_DRIVER
operator|)
operator|&&
name|args
operator|->
name|driver
condition|)
block|{
name|driver
operator|=
name|FT_DRIVER
argument_list|(
name|args
operator|->
name|driver
argument_list|)
expr_stmt|;
comment|/* not all modules are drivers, so check... */
if|if
condition|(
name|FT_MODULE_IS_DRIVER
argument_list|(
name|driver
argument_list|)
condition|)
block|{
name|FT_Int
name|num_params
init|=
literal|0
decl_stmt|;
name|FT_Parameter
modifier|*
name|params
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|args
operator|->
name|flags
operator|&
name|FT_OPEN_PARAMS
condition|)
block|{
name|num_params
operator|=
name|args
operator|->
name|num_params
expr_stmt|;
name|params
operator|=
name|args
operator|->
name|params
expr_stmt|;
block|}
name|error
operator|=
name|open_face
argument_list|(
name|driver
argument_list|,
name|stream
argument_list|,
name|face_index
argument_list|,
name|num_params
argument_list|,
name|params
argument_list|,
operator|&
name|face
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
goto|goto
name|Success
goto|;
block|}
else|else
name|error
operator|=
name|FT_Err_Invalid_Handle
expr_stmt|;
name|FT_Stream_Free
argument_list|(
name|stream
argument_list|,
name|external_stream
argument_list|)
expr_stmt|;
goto|goto
name|Fail
goto|;
block|}
else|else
block|{
comment|/* check each font driver for an appropriate format */
name|cur
operator|=
name|library
operator|->
name|modules
expr_stmt|;
name|limit
operator|=
name|cur
operator|+
name|library
operator|->
name|num_modules
expr_stmt|;
for|for
control|(
init|;
name|cur
operator|<
name|limit
condition|;
name|cur
operator|++
control|)
block|{
comment|/* not all modules are font drivers, so check... */
if|if
condition|(
name|FT_MODULE_IS_DRIVER
argument_list|(
name|cur
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|FT_Int
name|num_params
init|=
literal|0
decl_stmt|;
name|FT_Parameter
modifier|*
name|params
init|=
literal|0
decl_stmt|;
name|driver
operator|=
name|FT_DRIVER
argument_list|(
name|cur
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|flags
operator|&
name|FT_OPEN_PARAMS
condition|)
block|{
name|num_params
operator|=
name|args
operator|->
name|num_params
expr_stmt|;
name|params
operator|=
name|args
operator|->
name|params
expr_stmt|;
block|}
name|error
operator|=
name|open_face
argument_list|(
name|driver
argument_list|,
name|stream
argument_list|,
name|face_index
argument_list|,
name|num_params
argument_list|,
name|params
argument_list|,
operator|&
name|face
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
goto|goto
name|Success
goto|;
ifdef|#
directive|ifdef
name|FT_CONFIG_OPTION_MAC_FONTS
if|if
condition|(
name|ft_strcmp
argument_list|(
name|cur
index|[
literal|0
index|]
operator|->
name|clazz
operator|->
name|module_name
argument_list|,
literal|"truetype"
argument_list|)
operator|==
literal|0
operator|&&
name|FT_ERROR_BASE
argument_list|(
name|error
argument_list|)
operator|==
name|FT_Err_Table_Missing
condition|)
block|{
comment|/* TrueType but essential tables are missing */
if|if
condition|(
name|FT_Stream_Seek
argument_list|(
name|stream
argument_list|,
literal|0
argument_list|)
condition|)
break|break;
name|error
operator|=
name|open_face_PS_from_sfnt_stream
argument_list|(
name|library
argument_list|,
name|stream
argument_list|,
name|face_index
argument_list|,
name|num_params
argument_list|,
name|params
argument_list|,
name|aface
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|FT_Stream_Free
argument_list|(
name|stream
argument_list|,
name|external_stream
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|FT_ERROR_BASE
argument_list|(
name|error
argument_list|)
operator|!=
name|FT_Err_Unknown_File_Format
condition|)
goto|goto
name|Fail3
goto|;
block|}
block|}
name|Fail3
label|:
comment|/* If we are on the mac, and we get an FT_Err_Invalid_Stream_Operation */
comment|/* it may be because we have an empty data fork, so we need to check   */
comment|/* the resource fork.                                                  */
if|if
condition|(
name|FT_ERROR_BASE
argument_list|(
name|error
argument_list|)
operator|!=
name|FT_Err_Cannot_Open_Stream
operator|&&
name|FT_ERROR_BASE
argument_list|(
name|error
argument_list|)
operator|!=
name|FT_Err_Unknown_File_Format
operator|&&
name|FT_ERROR_BASE
argument_list|(
name|error
argument_list|)
operator|!=
name|FT_Err_Invalid_Stream_Operation
condition|)
goto|goto
name|Fail2
goto|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|FT_MACINTOSH
argument_list|)
operator|&&
name|defined
argument_list|(
name|FT_CONFIG_OPTION_MAC_FONTS
argument_list|)
name|error
operator|=
name|load_mac_face
argument_list|(
name|library
argument_list|,
name|stream
argument_list|,
name|face_index
argument_list|,
name|aface
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
comment|/* We don't want to go to Success here.  We've already done that. */
comment|/* On the other hand, if we succeeded we still need to close this */
comment|/* stream (we opened a different stream which extracted the       */
comment|/* interesting information out of this stream here.  That stream  */
comment|/* will still be open and the face will point to it).             */
name|FT_Stream_Free
argument_list|(
name|stream
argument_list|,
name|external_stream
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
if|if
condition|(
name|FT_ERROR_BASE
argument_list|(
name|error
argument_list|)
operator|!=
name|FT_Err_Unknown_File_Format
condition|)
goto|goto
name|Fail2
goto|;
endif|#
directive|endif
comment|/* !FT_MACINTOSH&& FT_CONFIG_OPTION_MAC_FONTS */
comment|/* no driver is able to handle this format */
name|error
operator|=
name|FT_Err_Unknown_File_Format
expr_stmt|;
name|Fail2
label|:
name|FT_Stream_Free
argument_list|(
name|stream
argument_list|,
name|external_stream
argument_list|)
expr_stmt|;
goto|goto
name|Fail
goto|;
block|}
name|Success
label|:
name|FT_TRACE4
argument_list|(
operator|(
literal|"FT_Open_Face: New face object, adding to list\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* set the FT_FACE_FLAG_EXTERNAL_STREAM bit for FT_Done_Face */
if|if
condition|(
name|external_stream
condition|)
name|face
operator|->
name|face_flags
operator||=
name|FT_FACE_FLAG_EXTERNAL_STREAM
expr_stmt|;
comment|/* add the face object to its driver's list */
if|if
condition|(
name|FT_NEW
argument_list|(
name|node
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
name|node
operator|->
name|data
operator|=
name|face
expr_stmt|;
comment|/* don't assume driver is the same as face->driver, so use */
comment|/* face->driver instead.                                   */
name|FT_List_Add
argument_list|(
operator|&
name|face
operator|->
name|driver
operator|->
name|faces_list
argument_list|,
name|node
argument_list|)
expr_stmt|;
comment|/* now allocate a glyph slot object for the face */
name|FT_TRACE4
argument_list|(
operator|(
literal|"FT_Open_Face: Creating glyph slot\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|face_index
operator|>=
literal|0
condition|)
block|{
name|error
operator|=
name|FT_New_GlyphSlot
argument_list|(
name|face
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Fail
goto|;
comment|/* finally, allocate a size object for the face */
block|{
name|FT_Size
name|size
decl_stmt|;
name|FT_TRACE4
argument_list|(
operator|(
literal|"FT_Open_Face: Creating size object\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|FT_New_Size
argument_list|(
name|face
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Fail
goto|;
name|face
operator|->
name|size
operator|=
name|size
expr_stmt|;
block|}
block|}
comment|/* some checks */
if|if
condition|(
name|FT_IS_SCALABLE
argument_list|(
name|face
argument_list|)
condition|)
block|{
if|if
condition|(
name|face
operator|->
name|height
operator|<
literal|0
condition|)
name|face
operator|->
name|height
operator|=
operator|(
name|FT_Short
operator|)
operator|-
name|face
operator|->
name|height
expr_stmt|;
if|if
condition|(
operator|!
name|FT_HAS_VERTICAL
argument_list|(
name|face
argument_list|)
condition|)
name|face
operator|->
name|max_advance_height
operator|=
operator|(
name|FT_Short
operator|)
name|face
operator|->
name|height
expr_stmt|;
block|}
if|if
condition|(
name|FT_HAS_FIXED_SIZES
argument_list|(
name|face
argument_list|)
condition|)
block|{
name|FT_Int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|face
operator|->
name|num_fixed_sizes
condition|;
name|i
operator|++
control|)
block|{
name|FT_Bitmap_Size
modifier|*
name|bsize
init|=
name|face
operator|->
name|available_sizes
operator|+
name|i
decl_stmt|;
if|if
condition|(
name|bsize
operator|->
name|height
operator|<
literal|0
condition|)
name|bsize
operator|->
name|height
operator|=
operator|(
name|FT_Short
operator|)
operator|-
name|bsize
operator|->
name|height
expr_stmt|;
if|if
condition|(
name|bsize
operator|->
name|x_ppem
operator|<
literal|0
condition|)
name|bsize
operator|->
name|x_ppem
operator|=
operator|(
name|FT_Short
operator|)
operator|-
name|bsize
operator|->
name|x_ppem
expr_stmt|;
if|if
condition|(
name|bsize
operator|->
name|y_ppem
operator|<
literal|0
condition|)
name|bsize
operator|->
name|y_ppem
operator|=
operator|-
name|bsize
operator|->
name|y_ppem
expr_stmt|;
block|}
block|}
comment|/* initialize internal face data */
block|{
name|FT_Face_Internal
name|internal
init|=
name|face
operator|->
name|internal
decl_stmt|;
name|internal
operator|->
name|transform_matrix
operator|.
name|xx
operator|=
literal|0x10000L
expr_stmt|;
name|internal
operator|->
name|transform_matrix
operator|.
name|xy
operator|=
literal|0
expr_stmt|;
name|internal
operator|->
name|transform_matrix
operator|.
name|yx
operator|=
literal|0
expr_stmt|;
name|internal
operator|->
name|transform_matrix
operator|.
name|yy
operator|=
literal|0x10000L
expr_stmt|;
name|internal
operator|->
name|transform_delta
operator|.
name|x
operator|=
literal|0
expr_stmt|;
name|internal
operator|->
name|transform_delta
operator|.
name|y
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|aface
condition|)
operator|*
name|aface
operator|=
name|face
expr_stmt|;
else|else
name|FT_Done_Face
argument_list|(
name|face
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
name|Fail
label|:
name|FT_Done_Face
argument_list|(
name|face
argument_list|)
expr_stmt|;
name|Exit
label|:
name|FT_TRACE4
argument_list|(
operator|(
literal|"FT_Open_Face: Return %d\n"
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/* documentation is in freetype.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_Attach_File
argument_list|(
argument|FT_Face      face
argument_list|,
argument|const char*  filepathname
argument_list|)
end_macro
begin_block
block|{
name|FT_Open_Args
name|open
decl_stmt|;
comment|/* test for valid `face' delayed to FT_Attach_Stream() */
if|if
condition|(
operator|!
name|filepathname
condition|)
return|return
name|FT_Err_Invalid_Argument
return|;
name|open
operator|.
name|stream
operator|=
name|NULL
expr_stmt|;
name|open
operator|.
name|flags
operator|=
name|FT_OPEN_PATHNAME
expr_stmt|;
name|open
operator|.
name|pathname
operator|=
operator|(
name|char
operator|*
operator|)
name|filepathname
expr_stmt|;
return|return
name|FT_Attach_Stream
argument_list|(
name|face
argument_list|,
operator|&
name|open
argument_list|)
return|;
block|}
end_block
begin_comment
comment|/* documentation is in freetype.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_Attach_Stream
argument_list|(
argument|FT_Face        face
argument_list|,
argument|FT_Open_Args*  parameters
argument_list|)
end_macro
begin_block
block|{
name|FT_Stream
name|stream
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|FT_Driver
name|driver
decl_stmt|;
name|FT_Driver_Class
name|clazz
decl_stmt|;
comment|/* test for valid `parameters' delayed to FT_Stream_New() */
if|if
condition|(
operator|!
name|face
condition|)
return|return
name|FT_Err_Invalid_Face_Handle
return|;
name|driver
operator|=
name|face
operator|->
name|driver
expr_stmt|;
if|if
condition|(
operator|!
name|driver
condition|)
return|return
name|FT_Err_Invalid_Driver_Handle
return|;
name|error
operator|=
name|FT_Stream_New
argument_list|(
name|driver
operator|->
name|root
operator|.
name|library
argument_list|,
name|parameters
argument_list|,
operator|&
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
comment|/* we implement FT_Attach_Stream in each driver through the */
comment|/* `attach_file' interface                                  */
name|error
operator|=
name|FT_Err_Unimplemented_Feature
expr_stmt|;
name|clazz
operator|=
name|driver
operator|->
name|clazz
expr_stmt|;
if|if
condition|(
name|clazz
operator|->
name|attach_file
condition|)
name|error
operator|=
name|clazz
operator|->
name|attach_file
argument_list|(
name|face
argument_list|,
name|stream
argument_list|)
expr_stmt|;
comment|/* close the attached stream */
name|FT_Stream_Free
argument_list|(
name|stream
argument_list|,
call|(
name|FT_Bool
call|)
argument_list|(
name|parameters
operator|->
name|stream
operator|&&
operator|(
name|parameters
operator|->
name|flags
operator|&
name|FT_OPEN_STREAM
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|Exit
label|:
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/* documentation is in freetype.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_Done_Face
argument_list|(
argument|FT_Face  face
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
decl_stmt|;
name|FT_Driver
name|driver
decl_stmt|;
name|FT_Memory
name|memory
decl_stmt|;
name|FT_ListNode
name|node
decl_stmt|;
name|error
operator|=
name|FT_Err_Invalid_Face_Handle
expr_stmt|;
if|if
condition|(
name|face
operator|&&
name|face
operator|->
name|driver
condition|)
block|{
name|driver
operator|=
name|face
operator|->
name|driver
expr_stmt|;
name|memory
operator|=
name|driver
operator|->
name|root
operator|.
name|memory
expr_stmt|;
comment|/* find face in driver's list */
name|node
operator|=
name|FT_List_Find
argument_list|(
operator|&
name|driver
operator|->
name|faces_list
argument_list|,
name|face
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
condition|)
block|{
comment|/* remove face object from the driver's list */
name|FT_List_Remove
argument_list|(
operator|&
name|driver
operator|->
name|faces_list
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|/* now destroy the object proper */
name|destroy_face
argument_list|(
name|memory
argument_list|,
name|face
argument_list|,
name|driver
argument_list|)
expr_stmt|;
name|error
operator|=
name|FT_Err_Ok
expr_stmt|;
block|}
block|}
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/* documentation is in ftobjs.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_New_Size
argument_list|(
argument|FT_Face   face
argument_list|,
argument|FT_Size  *asize
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
decl_stmt|;
name|FT_Memory
name|memory
decl_stmt|;
name|FT_Driver
name|driver
decl_stmt|;
name|FT_Driver_Class
name|clazz
decl_stmt|;
name|FT_Size
name|size
init|=
literal|0
decl_stmt|;
name|FT_ListNode
name|node
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|face
condition|)
return|return
name|FT_Err_Invalid_Face_Handle
return|;
if|if
condition|(
operator|!
name|asize
condition|)
return|return
name|FT_Err_Invalid_Size_Handle
return|;
if|if
condition|(
operator|!
name|face
operator|->
name|driver
condition|)
return|return
name|FT_Err_Invalid_Driver_Handle
return|;
operator|*
name|asize
operator|=
literal|0
expr_stmt|;
name|driver
operator|=
name|face
operator|->
name|driver
expr_stmt|;
name|clazz
operator|=
name|driver
operator|->
name|clazz
expr_stmt|;
name|memory
operator|=
name|face
operator|->
name|memory
expr_stmt|;
comment|/* Allocate new size object and perform basic initialisation */
if|if
condition|(
name|FT_ALLOC
argument_list|(
name|size
argument_list|,
name|clazz
operator|->
name|size_object_size
argument_list|)
operator|||
name|FT_NEW
argument_list|(
name|node
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|size
operator|->
name|face
operator|=
name|face
expr_stmt|;
comment|/* for now, do not use any internal fields in size objects */
name|size
operator|->
name|internal
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|clazz
operator|->
name|init_size
condition|)
name|error
operator|=
name|clazz
operator|->
name|init_size
argument_list|(
name|size
argument_list|)
expr_stmt|;
comment|/* in case of success, add to the face's list */
if|if
condition|(
operator|!
name|error
condition|)
block|{
operator|*
name|asize
operator|=
name|size
expr_stmt|;
name|node
operator|->
name|data
operator|=
name|size
expr_stmt|;
name|FT_List_Add
argument_list|(
operator|&
name|face
operator|->
name|sizes_list
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
name|Exit
label|:
if|if
condition|(
name|error
condition|)
block|{
name|FT_FREE
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|size
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/* documentation is in ftobjs.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_Done_Size
argument_list|(
argument|FT_Size  size
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
decl_stmt|;
name|FT_Driver
name|driver
decl_stmt|;
name|FT_Memory
name|memory
decl_stmt|;
name|FT_Face
name|face
decl_stmt|;
name|FT_ListNode
name|node
decl_stmt|;
if|if
condition|(
operator|!
name|size
condition|)
return|return
name|FT_Err_Invalid_Size_Handle
return|;
name|face
operator|=
name|size
operator|->
name|face
expr_stmt|;
if|if
condition|(
operator|!
name|face
condition|)
return|return
name|FT_Err_Invalid_Face_Handle
return|;
name|driver
operator|=
name|face
operator|->
name|driver
expr_stmt|;
if|if
condition|(
operator|!
name|driver
condition|)
return|return
name|FT_Err_Invalid_Driver_Handle
return|;
name|memory
operator|=
name|driver
operator|->
name|root
operator|.
name|memory
expr_stmt|;
name|error
operator|=
name|FT_Err_Ok
expr_stmt|;
name|node
operator|=
name|FT_List_Find
argument_list|(
operator|&
name|face
operator|->
name|sizes_list
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
condition|)
block|{
name|FT_List_Remove
argument_list|(
operator|&
name|face
operator|->
name|sizes_list
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|face
operator|->
name|size
operator|==
name|size
condition|)
block|{
name|face
operator|->
name|size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|face
operator|->
name|sizes_list
operator|.
name|head
condition|)
name|face
operator|->
name|size
operator|=
call|(
name|FT_Size
call|)
argument_list|(
name|face
operator|->
name|sizes_list
operator|.
name|head
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
name|destroy_size
argument_list|(
name|memory
argument_list|,
name|size
argument_list|,
name|driver
argument_list|)
expr_stmt|;
block|}
else|else
name|error
operator|=
name|FT_Err_Invalid_Size_Handle
expr_stmt|;
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/* documentation is in ftobjs.h */
end_comment
begin_macro
DECL|function|FT_BASE_DEF
name|FT_BASE_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_Match_Size
argument_list|(
argument|FT_Face          face
argument_list|,
argument|FT_Size_Request  req
argument_list|,
argument|FT_Bool          ignore_width
argument_list|,
argument|FT_ULong*        size_index
argument_list|)
end_macro
begin_block
block|{
name|FT_Int
name|i
decl_stmt|;
name|FT_Long
name|w
decl_stmt|,
name|h
decl_stmt|;
if|if
condition|(
operator|!
name|FT_HAS_FIXED_SIZES
argument_list|(
name|face
argument_list|)
condition|)
return|return
name|FT_Err_Invalid_Face_Handle
return|;
comment|/* FT_Bitmap_Size doesn't provide enough info... */
if|if
condition|(
name|req
operator|->
name|type
operator|!=
name|FT_SIZE_REQUEST_TYPE_NOMINAL
condition|)
return|return
name|FT_Err_Unimplemented_Feature
return|;
name|w
operator|=
name|FT_REQUEST_WIDTH
argument_list|(
name|req
argument_list|)
expr_stmt|;
name|h
operator|=
name|FT_REQUEST_HEIGHT
argument_list|(
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|->
name|width
operator|&&
operator|!
name|req
operator|->
name|height
condition|)
name|h
operator|=
name|w
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|req
operator|->
name|width
operator|&&
name|req
operator|->
name|height
condition|)
name|w
operator|=
name|h
expr_stmt|;
name|w
operator|=
name|FT_PIX_ROUND
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|h
operator|=
name|FT_PIX_ROUND
argument_list|(
name|h
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|face
operator|->
name|num_fixed_sizes
condition|;
name|i
operator|++
control|)
block|{
name|FT_Bitmap_Size
modifier|*
name|bsize
init|=
name|face
operator|->
name|available_sizes
operator|+
name|i
decl_stmt|;
if|if
condition|(
name|h
operator|!=
name|FT_PIX_ROUND
argument_list|(
name|bsize
operator|->
name|y_ppem
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|w
operator|==
name|FT_PIX_ROUND
argument_list|(
name|bsize
operator|->
name|x_ppem
argument_list|)
operator|||
name|ignore_width
condition|)
block|{
if|if
condition|(
name|size_index
condition|)
operator|*
name|size_index
operator|=
operator|(
name|FT_ULong
operator|)
name|i
expr_stmt|;
return|return
name|FT_Err_Ok
return|;
block|}
block|}
return|return
name|FT_Err_Invalid_Pixel_Size
return|;
block|}
end_block
begin_comment
comment|/* documentation is in ftobjs.h */
end_comment
begin_macro
name|FT_BASE_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|ft_synthesize_vertical_metrics
name|ft_synthesize_vertical_metrics
argument_list|(
argument|FT_Glyph_Metrics*  metrics
argument_list|,
argument|FT_Pos             advance
argument_list|)
end_macro
begin_block
block|{
name|FT_Pos
name|height
init|=
name|metrics
operator|->
name|height
decl_stmt|;
comment|/* compensate for glyph with bbox above/below the baseline */
if|if
condition|(
name|metrics
operator|->
name|horiBearingY
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|height
operator|<
name|metrics
operator|->
name|horiBearingY
condition|)
name|height
operator|=
name|metrics
operator|->
name|horiBearingY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|metrics
operator|->
name|horiBearingY
operator|>
literal|0
condition|)
name|height
operator|-=
name|metrics
operator|->
name|horiBearingY
expr_stmt|;
comment|/* the factor 1.2 is a heuristical value */
if|if
condition|(
operator|!
name|advance
condition|)
name|advance
operator|=
name|height
operator|*
literal|12
operator|/
literal|10
expr_stmt|;
name|metrics
operator|->
name|vertBearingX
operator|=
name|metrics
operator|->
name|horiBearingX
operator|-
name|metrics
operator|->
name|horiAdvance
operator|/
literal|2
expr_stmt|;
name|metrics
operator|->
name|vertBearingY
operator|=
operator|(
name|advance
operator|-
name|height
operator|)
operator|/
literal|2
expr_stmt|;
name|metrics
operator|->
name|vertAdvance
operator|=
name|advance
expr_stmt|;
block|}
end_block
begin_function
specifier|static
name|void
DECL|function|ft_recompute_scaled_metrics
name|ft_recompute_scaled_metrics
parameter_list|(
name|FT_Face
name|face
parameter_list|,
name|FT_Size_Metrics
modifier|*
name|metrics
parameter_list|)
block|{
comment|/* Compute root ascender, descender, test height, and max_advance */
ifdef|#
directive|ifdef
name|GRID_FIT_METRICS
name|metrics
operator|->
name|ascender
operator|=
name|FT_PIX_CEIL
argument_list|(
name|FT_MulFix
argument_list|(
name|face
operator|->
name|ascender
argument_list|,
name|metrics
operator|->
name|y_scale
argument_list|)
argument_list|)
expr_stmt|;
name|metrics
operator|->
name|descender
operator|=
name|FT_PIX_FLOOR
argument_list|(
name|FT_MulFix
argument_list|(
name|face
operator|->
name|descender
argument_list|,
name|metrics
operator|->
name|y_scale
argument_list|)
argument_list|)
expr_stmt|;
name|metrics
operator|->
name|height
operator|=
name|FT_PIX_ROUND
argument_list|(
name|FT_MulFix
argument_list|(
name|face
operator|->
name|height
argument_list|,
name|metrics
operator|->
name|y_scale
argument_list|)
argument_list|)
expr_stmt|;
name|metrics
operator|->
name|max_advance
operator|=
name|FT_PIX_ROUND
argument_list|(
name|FT_MulFix
argument_list|(
name|face
operator|->
name|max_advance_width
argument_list|,
name|metrics
operator|->
name|x_scale
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !GRID_FIT_METRICS */
name|metrics
operator|->
name|ascender
operator|=
name|FT_MulFix
argument_list|(
name|face
operator|->
name|ascender
argument_list|,
name|metrics
operator|->
name|y_scale
argument_list|)
expr_stmt|;
name|metrics
operator|->
name|descender
operator|=
name|FT_MulFix
argument_list|(
name|face
operator|->
name|descender
argument_list|,
name|metrics
operator|->
name|y_scale
argument_list|)
expr_stmt|;
name|metrics
operator|->
name|height
operator|=
name|FT_MulFix
argument_list|(
name|face
operator|->
name|height
argument_list|,
name|metrics
operator|->
name|y_scale
argument_list|)
expr_stmt|;
name|metrics
operator|->
name|max_advance
operator|=
name|FT_MulFix
argument_list|(
name|face
operator|->
name|max_advance_width
argument_list|,
name|metrics
operator|->
name|x_scale
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !GRID_FIT_METRICS */
block|}
end_function
begin_macro
name|FT_BASE_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|FT_Select_Metrics
name|FT_Select_Metrics
argument_list|(
argument|FT_Face   face
argument_list|,
argument|FT_ULong  strike_index
argument_list|)
end_macro
begin_block
block|{
name|FT_Size_Metrics
modifier|*
name|metrics
decl_stmt|;
name|FT_Bitmap_Size
modifier|*
name|bsize
decl_stmt|;
name|metrics
operator|=
operator|&
name|face
operator|->
name|size
operator|->
name|metrics
expr_stmt|;
name|bsize
operator|=
name|face
operator|->
name|available_sizes
operator|+
name|strike_index
expr_stmt|;
name|metrics
operator|->
name|x_ppem
operator|=
call|(
name|FT_UShort
call|)
argument_list|(
operator|(
name|bsize
operator|->
name|x_ppem
operator|+
literal|32
operator|)
operator|>>
literal|6
argument_list|)
expr_stmt|;
name|metrics
operator|->
name|y_ppem
operator|=
call|(
name|FT_UShort
call|)
argument_list|(
operator|(
name|bsize
operator|->
name|y_ppem
operator|+
literal|32
operator|)
operator|>>
literal|6
argument_list|)
expr_stmt|;
if|if
condition|(
name|FT_IS_SCALABLE
argument_list|(
name|face
argument_list|)
condition|)
block|{
name|metrics
operator|->
name|x_scale
operator|=
name|FT_DivFix
argument_list|(
name|bsize
operator|->
name|x_ppem
argument_list|,
name|face
operator|->
name|units_per_EM
argument_list|)
expr_stmt|;
name|metrics
operator|->
name|y_scale
operator|=
name|FT_DivFix
argument_list|(
name|bsize
operator|->
name|y_ppem
argument_list|,
name|face
operator|->
name|units_per_EM
argument_list|)
expr_stmt|;
name|ft_recompute_scaled_metrics
argument_list|(
name|face
argument_list|,
name|metrics
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|metrics
operator|->
name|x_scale
operator|=
literal|1L
operator|<<
literal|16
expr_stmt|;
name|metrics
operator|->
name|y_scale
operator|=
literal|1L
operator|<<
literal|16
expr_stmt|;
name|metrics
operator|->
name|ascender
operator|=
name|bsize
operator|->
name|y_ppem
expr_stmt|;
name|metrics
operator|->
name|descender
operator|=
literal|0
expr_stmt|;
name|metrics
operator|->
name|height
operator|=
name|bsize
operator|->
name|height
operator|<<
literal|6
expr_stmt|;
name|metrics
operator|->
name|max_advance
operator|=
name|bsize
operator|->
name|x_ppem
expr_stmt|;
block|}
block|}
end_block
begin_macro
name|FT_BASE_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|FT_Request_Metrics
name|FT_Request_Metrics
argument_list|(
argument|FT_Face          face
argument_list|,
argument|FT_Size_Request  req
argument_list|)
end_macro
begin_block
block|{
name|FT_Size_Metrics
modifier|*
name|metrics
decl_stmt|;
name|metrics
operator|=
operator|&
name|face
operator|->
name|size
operator|->
name|metrics
expr_stmt|;
if|if
condition|(
name|FT_IS_SCALABLE
argument_list|(
name|face
argument_list|)
condition|)
block|{
name|FT_Long
name|w
init|=
literal|0
decl_stmt|,
name|h
init|=
literal|0
decl_stmt|,
name|scaled_w
init|=
literal|0
decl_stmt|,
name|scaled_h
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|req
operator|->
name|type
condition|)
block|{
case|case
name|FT_SIZE_REQUEST_TYPE_NOMINAL
case|:
name|w
operator|=
name|h
operator|=
name|face
operator|->
name|units_per_EM
expr_stmt|;
break|break;
case|case
name|FT_SIZE_REQUEST_TYPE_REAL_DIM
case|:
name|w
operator|=
name|h
operator|=
name|face
operator|->
name|ascender
operator|-
name|face
operator|->
name|descender
expr_stmt|;
break|break;
case|case
name|FT_SIZE_REQUEST_TYPE_BBOX
case|:
name|w
operator|=
name|face
operator|->
name|bbox
operator|.
name|xMax
operator|-
name|face
operator|->
name|bbox
operator|.
name|xMin
expr_stmt|;
name|h
operator|=
name|face
operator|->
name|bbox
operator|.
name|yMax
operator|-
name|face
operator|->
name|bbox
operator|.
name|yMin
expr_stmt|;
break|break;
case|case
name|FT_SIZE_REQUEST_TYPE_CELL
case|:
name|w
operator|=
name|face
operator|->
name|max_advance_width
expr_stmt|;
name|h
operator|=
name|face
operator|->
name|ascender
operator|-
name|face
operator|->
name|descender
expr_stmt|;
break|break;
case|case
name|FT_SIZE_REQUEST_TYPE_SCALES
case|:
name|metrics
operator|->
name|x_scale
operator|=
operator|(
name|FT_Fixed
operator|)
name|req
operator|->
name|width
expr_stmt|;
name|metrics
operator|->
name|y_scale
operator|=
operator|(
name|FT_Fixed
operator|)
name|req
operator|->
name|height
expr_stmt|;
if|if
condition|(
operator|!
name|metrics
operator|->
name|x_scale
condition|)
name|metrics
operator|->
name|x_scale
operator|=
name|metrics
operator|->
name|y_scale
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|metrics
operator|->
name|y_scale
condition|)
name|metrics
operator|->
name|y_scale
operator|=
name|metrics
operator|->
name|x_scale
expr_stmt|;
goto|goto
name|Calculate_Ppem
goto|;
case|case
name|FT_SIZE_REQUEST_TYPE_MAX
case|:
break|break;
block|}
comment|/* to be on the safe side */
if|if
condition|(
name|w
operator|<
literal|0
condition|)
name|w
operator|=
operator|-
name|w
expr_stmt|;
if|if
condition|(
name|h
operator|<
literal|0
condition|)
name|h
operator|=
operator|-
name|h
expr_stmt|;
name|scaled_w
operator|=
name|FT_REQUEST_WIDTH
argument_list|(
name|req
argument_list|)
expr_stmt|;
name|scaled_h
operator|=
name|FT_REQUEST_HEIGHT
argument_list|(
name|req
argument_list|)
expr_stmt|;
comment|/* determine scales */
if|if
condition|(
name|req
operator|->
name|width
condition|)
block|{
name|metrics
operator|->
name|x_scale
operator|=
name|FT_DivFix
argument_list|(
name|scaled_w
argument_list|,
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|->
name|height
condition|)
block|{
name|metrics
operator|->
name|y_scale
operator|=
name|FT_DivFix
argument_list|(
name|scaled_h
argument_list|,
name|h
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|->
name|type
operator|==
name|FT_SIZE_REQUEST_TYPE_CELL
condition|)
block|{
if|if
condition|(
name|metrics
operator|->
name|y_scale
operator|>
name|metrics
operator|->
name|x_scale
condition|)
name|metrics
operator|->
name|y_scale
operator|=
name|metrics
operator|->
name|x_scale
expr_stmt|;
else|else
name|metrics
operator|->
name|x_scale
operator|=
name|metrics
operator|->
name|y_scale
expr_stmt|;
block|}
block|}
else|else
block|{
name|metrics
operator|->
name|y_scale
operator|=
name|metrics
operator|->
name|x_scale
expr_stmt|;
name|scaled_h
operator|=
name|FT_MulDiv
argument_list|(
name|scaled_w
argument_list|,
name|h
argument_list|,
name|w
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|metrics
operator|->
name|x_scale
operator|=
name|metrics
operator|->
name|y_scale
operator|=
name|FT_DivFix
argument_list|(
name|scaled_h
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|scaled_w
operator|=
name|FT_MulDiv
argument_list|(
name|scaled_h
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
block|}
name|Calculate_Ppem
label|:
comment|/* calculate the ppems */
if|if
condition|(
name|req
operator|->
name|type
operator|!=
name|FT_SIZE_REQUEST_TYPE_NOMINAL
condition|)
block|{
name|scaled_w
operator|=
name|FT_MulFix
argument_list|(
name|face
operator|->
name|units_per_EM
argument_list|,
name|metrics
operator|->
name|x_scale
argument_list|)
expr_stmt|;
name|scaled_h
operator|=
name|FT_MulFix
argument_list|(
name|face
operator|->
name|units_per_EM
argument_list|,
name|metrics
operator|->
name|y_scale
argument_list|)
expr_stmt|;
block|}
name|metrics
operator|->
name|x_ppem
operator|=
call|(
name|FT_UShort
call|)
argument_list|(
operator|(
name|scaled_w
operator|+
literal|32
operator|)
operator|>>
literal|6
argument_list|)
expr_stmt|;
name|metrics
operator|->
name|y_ppem
operator|=
call|(
name|FT_UShort
call|)
argument_list|(
operator|(
name|scaled_h
operator|+
literal|32
operator|)
operator|>>
literal|6
argument_list|)
expr_stmt|;
name|ft_recompute_scaled_metrics
argument_list|(
name|face
argument_list|,
name|metrics
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|FT_ZERO
argument_list|(
name|metrics
argument_list|)
expr_stmt|;
name|metrics
operator|->
name|x_scale
operator|=
literal|1L
operator|<<
literal|16
expr_stmt|;
name|metrics
operator|->
name|y_scale
operator|=
literal|1L
operator|<<
literal|16
expr_stmt|;
block|}
block|}
end_block
begin_comment
comment|/* documentation is in freetype.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_Select_Size
argument_list|(
argument|FT_Face  face
argument_list|,
argument|FT_Int   strike_index
argument_list|)
end_macro
begin_block
block|{
name|FT_Driver_Class
name|clazz
decl_stmt|;
if|if
condition|(
operator|!
name|face
operator|||
operator|!
name|FT_HAS_FIXED_SIZES
argument_list|(
name|face
argument_list|)
condition|)
return|return
name|FT_Err_Invalid_Face_Handle
return|;
if|if
condition|(
name|strike_index
operator|<
literal|0
operator|||
name|strike_index
operator|>=
name|face
operator|->
name|num_fixed_sizes
condition|)
return|return
name|FT_Err_Invalid_Argument
return|;
name|clazz
operator|=
name|face
operator|->
name|driver
operator|->
name|clazz
expr_stmt|;
if|if
condition|(
name|clazz
operator|->
name|select_size
condition|)
return|return
name|clazz
operator|->
name|select_size
argument_list|(
name|face
operator|->
name|size
argument_list|,
operator|(
name|FT_ULong
operator|)
name|strike_index
argument_list|)
return|;
name|FT_Select_Metrics
argument_list|(
name|face
argument_list|,
operator|(
name|FT_ULong
operator|)
name|strike_index
argument_list|)
expr_stmt|;
return|return
name|FT_Err_Ok
return|;
block|}
end_block
begin_comment
comment|/* documentation is in freetype.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_Request_Size
argument_list|(
argument|FT_Face          face
argument_list|,
argument|FT_Size_Request  req
argument_list|)
end_macro
begin_block
block|{
name|FT_Driver_Class
name|clazz
decl_stmt|;
name|FT_ULong
name|strike_index
decl_stmt|;
if|if
condition|(
operator|!
name|face
condition|)
return|return
name|FT_Err_Invalid_Face_Handle
return|;
if|if
condition|(
operator|!
name|req
operator|||
name|req
operator|->
name|width
operator|<
literal|0
operator|||
name|req
operator|->
name|height
operator|<
literal|0
operator|||
name|req
operator|->
name|type
operator|>=
name|FT_SIZE_REQUEST_TYPE_MAX
condition|)
return|return
name|FT_Err_Invalid_Argument
return|;
name|clazz
operator|=
name|face
operator|->
name|driver
operator|->
name|clazz
expr_stmt|;
if|if
condition|(
name|clazz
operator|->
name|request_size
condition|)
return|return
name|clazz
operator|->
name|request_size
argument_list|(
name|face
operator|->
name|size
argument_list|,
name|req
argument_list|)
return|;
comment|/*      * The reason that a driver doesn't have `request_size' defined is      * either that the scaling here suffices or that the supported formats      * are bitmap-only and size matching is not implemented.      *      * In the latter case, a simple size matching is done.      */
if|if
condition|(
operator|!
name|FT_IS_SCALABLE
argument_list|(
name|face
argument_list|)
operator|&&
name|FT_HAS_FIXED_SIZES
argument_list|(
name|face
argument_list|)
condition|)
block|{
name|FT_Error
name|error
decl_stmt|;
name|error
operator|=
name|FT_Match_Size
argument_list|(
name|face
argument_list|,
name|req
argument_list|,
literal|0
argument_list|,
operator|&
name|strike_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|FT_TRACE3
argument_list|(
operator|(
literal|"FT_Request_Size: bitmap strike %lu matched\n"
operator|,
name|strike_index
operator|)
argument_list|)
expr_stmt|;
return|return
name|FT_Select_Size
argument_list|(
name|face
argument_list|,
operator|(
name|FT_Int
operator|)
name|strike_index
argument_list|)
return|;
block|}
name|FT_Request_Metrics
argument_list|(
name|face
argument_list|,
name|req
argument_list|)
expr_stmt|;
return|return
name|FT_Err_Ok
return|;
block|}
end_block
begin_comment
comment|/* documentation is in freetype.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_Set_Char_Size
argument_list|(
argument|FT_Face     face
argument_list|,
argument|FT_F26Dot6  char_width
argument_list|,
argument|FT_F26Dot6  char_height
argument_list|,
argument|FT_UInt     horz_resolution
argument_list|,
argument|FT_UInt     vert_resolution
argument_list|)
end_macro
begin_block
block|{
name|FT_Size_RequestRec
name|req
decl_stmt|;
if|if
condition|(
operator|!
name|char_width
condition|)
name|char_width
operator|=
name|char_height
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|char_height
condition|)
name|char_height
operator|=
name|char_width
expr_stmt|;
if|if
condition|(
operator|!
name|horz_resolution
condition|)
name|horz_resolution
operator|=
name|vert_resolution
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|vert_resolution
condition|)
name|vert_resolution
operator|=
name|horz_resolution
expr_stmt|;
if|if
condition|(
name|char_width
operator|<
literal|1
operator|*
literal|64
condition|)
name|char_width
operator|=
literal|1
operator|*
literal|64
expr_stmt|;
if|if
condition|(
name|char_height
operator|<
literal|1
operator|*
literal|64
condition|)
name|char_height
operator|=
literal|1
operator|*
literal|64
expr_stmt|;
if|if
condition|(
operator|!
name|horz_resolution
condition|)
name|horz_resolution
operator|=
name|vert_resolution
operator|=
literal|72
expr_stmt|;
name|req
operator|.
name|type
operator|=
name|FT_SIZE_REQUEST_TYPE_NOMINAL
expr_stmt|;
name|req
operator|.
name|width
operator|=
name|char_width
expr_stmt|;
name|req
operator|.
name|height
operator|=
name|char_height
expr_stmt|;
name|req
operator|.
name|horiResolution
operator|=
name|horz_resolution
expr_stmt|;
name|req
operator|.
name|vertResolution
operator|=
name|vert_resolution
expr_stmt|;
return|return
name|FT_Request_Size
argument_list|(
name|face
argument_list|,
operator|&
name|req
argument_list|)
return|;
block|}
end_block
begin_comment
comment|/* documentation is in freetype.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_Set_Pixel_Sizes
argument_list|(
argument|FT_Face  face
argument_list|,
argument|FT_UInt  pixel_width
argument_list|,
argument|FT_UInt  pixel_height
argument_list|)
end_macro
begin_block
block|{
name|FT_Size_RequestRec
name|req
decl_stmt|;
if|if
condition|(
name|pixel_width
operator|==
literal|0
condition|)
name|pixel_width
operator|=
name|pixel_height
expr_stmt|;
elseif|else
if|if
condition|(
name|pixel_height
operator|==
literal|0
condition|)
name|pixel_height
operator|=
name|pixel_width
expr_stmt|;
if|if
condition|(
name|pixel_width
operator|<
literal|1
condition|)
name|pixel_width
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|pixel_height
operator|<
literal|1
condition|)
name|pixel_height
operator|=
literal|1
expr_stmt|;
comment|/* use `>=' to avoid potential compiler warning on 16bit platforms */
if|if
condition|(
name|pixel_width
operator|>=
literal|0xFFFFU
condition|)
name|pixel_width
operator|=
literal|0xFFFFU
expr_stmt|;
if|if
condition|(
name|pixel_height
operator|>=
literal|0xFFFFU
condition|)
name|pixel_height
operator|=
literal|0xFFFFU
expr_stmt|;
name|req
operator|.
name|type
operator|=
name|FT_SIZE_REQUEST_TYPE_NOMINAL
expr_stmt|;
name|req
operator|.
name|width
operator|=
name|pixel_width
operator|<<
literal|6
expr_stmt|;
name|req
operator|.
name|height
operator|=
name|pixel_height
operator|<<
literal|6
expr_stmt|;
name|req
operator|.
name|horiResolution
operator|=
literal|0
expr_stmt|;
name|req
operator|.
name|vertResolution
operator|=
literal|0
expr_stmt|;
return|return
name|FT_Request_Size
argument_list|(
name|face
argument_list|,
operator|&
name|req
argument_list|)
return|;
block|}
end_block
begin_comment
comment|/* documentation is in freetype.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_Get_Kerning
argument_list|(
argument|FT_Face     face
argument_list|,
argument|FT_UInt     left_glyph
argument_list|,
argument|FT_UInt     right_glyph
argument_list|,
argument|FT_UInt     kern_mode
argument_list|,
argument|FT_Vector  *akerning
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
name|FT_Driver
name|driver
decl_stmt|;
if|if
condition|(
operator|!
name|face
condition|)
return|return
name|FT_Err_Invalid_Face_Handle
return|;
if|if
condition|(
operator|!
name|akerning
condition|)
return|return
name|FT_Err_Invalid_Argument
return|;
name|driver
operator|=
name|face
operator|->
name|driver
expr_stmt|;
name|akerning
operator|->
name|x
operator|=
literal|0
expr_stmt|;
name|akerning
operator|->
name|y
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|driver
operator|->
name|clazz
operator|->
name|get_kerning
condition|)
block|{
name|error
operator|=
name|driver
operator|->
name|clazz
operator|->
name|get_kerning
argument_list|(
name|face
argument_list|,
name|left_glyph
argument_list|,
name|right_glyph
argument_list|,
name|akerning
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
if|if
condition|(
name|kern_mode
operator|!=
name|FT_KERNING_UNSCALED
condition|)
block|{
name|akerning
operator|->
name|x
operator|=
name|FT_MulFix
argument_list|(
name|akerning
operator|->
name|x
argument_list|,
name|face
operator|->
name|size
operator|->
name|metrics
operator|.
name|x_scale
argument_list|)
expr_stmt|;
name|akerning
operator|->
name|y
operator|=
name|FT_MulFix
argument_list|(
name|akerning
operator|->
name|y
argument_list|,
name|face
operator|->
name|size
operator|->
name|metrics
operator|.
name|y_scale
argument_list|)
expr_stmt|;
if|if
condition|(
name|kern_mode
operator|!=
name|FT_KERNING_UNFITTED
condition|)
block|{
comment|/* we scale down kerning values for small ppem values */
comment|/* to avoid that rounding makes them too big.         */
comment|/* `25' has been determined heuristically.            */
if|if
condition|(
name|face
operator|->
name|size
operator|->
name|metrics
operator|.
name|x_ppem
operator|<
literal|25
condition|)
name|akerning
operator|->
name|x
operator|=
name|FT_MulDiv
argument_list|(
name|akerning
operator|->
name|x
argument_list|,
name|face
operator|->
name|size
operator|->
name|metrics
operator|.
name|x_ppem
argument_list|,
literal|25
argument_list|)
expr_stmt|;
if|if
condition|(
name|face
operator|->
name|size
operator|->
name|metrics
operator|.
name|y_ppem
operator|<
literal|25
condition|)
name|akerning
operator|->
name|y
operator|=
name|FT_MulDiv
argument_list|(
name|akerning
operator|->
name|y
argument_list|,
name|face
operator|->
name|size
operator|->
name|metrics
operator|.
name|y_ppem
argument_list|,
literal|25
argument_list|)
expr_stmt|;
name|akerning
operator|->
name|x
operator|=
name|FT_PIX_ROUND
argument_list|(
name|akerning
operator|->
name|x
argument_list|)
expr_stmt|;
name|akerning
operator|->
name|y
operator|=
name|FT_PIX_ROUND
argument_list|(
name|akerning
operator|->
name|y
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/* documentation is in freetype.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_Get_Track_Kerning
argument_list|(
argument|FT_Face    face
argument_list|,
argument|FT_Fixed   point_size
argument_list|,
argument|FT_Int     degree
argument_list|,
argument|FT_Fixed*  akerning
argument_list|)
end_macro
begin_block
block|{
name|FT_Service_Kerning
name|service
decl_stmt|;
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
if|if
condition|(
operator|!
name|face
condition|)
return|return
name|FT_Err_Invalid_Face_Handle
return|;
if|if
condition|(
operator|!
name|akerning
condition|)
return|return
name|FT_Err_Invalid_Argument
return|;
name|FT_FACE_FIND_SERVICE
argument_list|(
name|face
argument_list|,
name|service
argument_list|,
name|KERNING
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|service
condition|)
return|return
name|FT_Err_Unimplemented_Feature
return|;
name|error
operator|=
name|service
operator|->
name|get_track
argument_list|(
name|face
argument_list|,
name|point_size
argument_list|,
name|degree
argument_list|,
name|akerning
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/* documentation is in freetype.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_Select_Charmap
argument_list|(
argument|FT_Face      face
argument_list|,
argument|FT_Encoding  encoding
argument_list|)
end_macro
begin_block
block|{
name|FT_CharMap
modifier|*
name|cur
decl_stmt|;
name|FT_CharMap
modifier|*
name|limit
decl_stmt|;
if|if
condition|(
operator|!
name|face
condition|)
return|return
name|FT_Err_Invalid_Face_Handle
return|;
if|if
condition|(
name|encoding
operator|==
name|FT_ENCODING_NONE
condition|)
return|return
name|FT_Err_Invalid_Argument
return|;
comment|/* FT_ENCODING_UNICODE is special.  We try to find the `best' Unicode */
comment|/* charmap available, i.e., one with UCS-4 characters, if possible.   */
comment|/*                                                                    */
comment|/* This is done by find_unicode_charmap() above, to share code.       */
if|if
condition|(
name|encoding
operator|==
name|FT_ENCODING_UNICODE
condition|)
return|return
name|find_unicode_charmap
argument_list|(
name|face
argument_list|)
return|;
name|cur
operator|=
name|face
operator|->
name|charmaps
expr_stmt|;
if|if
condition|(
operator|!
name|cur
condition|)
return|return
name|FT_Err_Invalid_CharMap_Handle
return|;
name|limit
operator|=
name|cur
operator|+
name|face
operator|->
name|num_charmaps
expr_stmt|;
for|for
control|(
init|;
name|cur
operator|<
name|limit
condition|;
name|cur
operator|++
control|)
block|{
if|if
condition|(
name|cur
index|[
literal|0
index|]
operator|->
name|encoding
operator|==
name|encoding
condition|)
block|{
name|face
operator|->
name|charmap
operator|=
name|cur
index|[
literal|0
index|]
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
return|return
name|FT_Err_Invalid_Argument
return|;
block|}
end_block
begin_comment
comment|/* documentation is in freetype.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_Set_Charmap
argument_list|(
argument|FT_Face     face
argument_list|,
argument|FT_CharMap  charmap
argument_list|)
end_macro
begin_block
block|{
name|FT_CharMap
modifier|*
name|cur
decl_stmt|;
name|FT_CharMap
modifier|*
name|limit
decl_stmt|;
if|if
condition|(
operator|!
name|face
condition|)
return|return
name|FT_Err_Invalid_Face_Handle
return|;
name|cur
operator|=
name|face
operator|->
name|charmaps
expr_stmt|;
if|if
condition|(
operator|!
name|cur
condition|)
return|return
name|FT_Err_Invalid_CharMap_Handle
return|;
if|if
condition|(
name|FT_Get_CMap_Format
argument_list|(
name|charmap
argument_list|)
operator|==
literal|14
condition|)
return|return
name|FT_Err_Invalid_Argument
return|;
name|limit
operator|=
name|cur
operator|+
name|face
operator|->
name|num_charmaps
expr_stmt|;
for|for
control|(
init|;
name|cur
operator|<
name|limit
condition|;
name|cur
operator|++
control|)
block|{
if|if
condition|(
name|cur
index|[
literal|0
index|]
operator|==
name|charmap
condition|)
block|{
name|face
operator|->
name|charmap
operator|=
name|cur
index|[
literal|0
index|]
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
return|return
name|FT_Err_Invalid_Argument
return|;
block|}
end_block
begin_comment
comment|/* documentation is in freetype.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Int
argument_list|)
end_macro
begin_macro
name|FT_Get_Charmap_Index
argument_list|(
argument|FT_CharMap  charmap
argument_list|)
end_macro
begin_block
block|{
name|FT_Int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|charmap
operator|->
name|face
operator|->
name|num_charmaps
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|charmap
operator|->
name|face
operator|->
name|charmaps
index|[
name|i
index|]
operator|==
name|charmap
condition|)
break|break;
name|FT_ASSERT
argument_list|(
name|i
operator|<
name|charmap
operator|->
name|face
operator|->
name|num_charmaps
argument_list|)
expr_stmt|;
return|return
name|i
return|;
block|}
end_block
begin_function
specifier|static
name|void
DECL|function|ft_cmap_done_internal
name|ft_cmap_done_internal
parameter_list|(
name|FT_CMap
name|cmap
parameter_list|)
block|{
name|FT_CMap_Class
name|clazz
init|=
name|cmap
operator|->
name|clazz
decl_stmt|;
name|FT_Face
name|face
init|=
name|cmap
operator|->
name|charmap
operator|.
name|face
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|FT_FACE_MEMORY
argument_list|(
name|face
argument_list|)
decl_stmt|;
if|if
condition|(
name|clazz
operator|->
name|done
condition|)
name|clazz
operator|->
name|done
argument_list|(
name|cmap
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|cmap
argument_list|)
expr_stmt|;
block|}
end_function
begin_macro
name|FT_BASE_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|FT_CMap_Done
name|FT_CMap_Done
argument_list|(
argument|FT_CMap  cmap
argument_list|)
end_macro
begin_block
block|{
if|if
condition|(
name|cmap
condition|)
block|{
name|FT_Face
name|face
init|=
name|cmap
operator|->
name|charmap
operator|.
name|face
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|FT_FACE_MEMORY
argument_list|(
name|face
argument_list|)
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|FT_Int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|face
operator|->
name|num_charmaps
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|FT_CMap
operator|)
name|face
operator|->
name|charmaps
index|[
name|i
index|]
operator|==
name|cmap
condition|)
block|{
name|FT_CharMap
name|last_charmap
init|=
name|face
operator|->
name|charmaps
index|[
name|face
operator|->
name|num_charmaps
operator|-
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|FT_RENEW_ARRAY
argument_list|(
name|face
operator|->
name|charmaps
argument_list|,
name|face
operator|->
name|num_charmaps
argument_list|,
name|face
operator|->
name|num_charmaps
operator|-
literal|1
argument_list|)
condition|)
return|return;
comment|/* remove it from our list of charmaps */
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|face
operator|->
name|num_charmaps
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|==
name|face
operator|->
name|num_charmaps
operator|-
literal|1
condition|)
name|face
operator|->
name|charmaps
index|[
name|j
operator|-
literal|1
index|]
operator|=
name|last_charmap
expr_stmt|;
else|else
name|face
operator|->
name|charmaps
index|[
name|j
operator|-
literal|1
index|]
operator|=
name|face
operator|->
name|charmaps
index|[
name|j
index|]
expr_stmt|;
block|}
name|face
operator|->
name|num_charmaps
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|FT_CMap
operator|)
name|face
operator|->
name|charmap
operator|==
name|cmap
condition|)
name|face
operator|->
name|charmap
operator|=
name|NULL
expr_stmt|;
name|ft_cmap_done_internal
argument_list|(
name|cmap
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
end_block
begin_macro
DECL|function|FT_BASE_DEF
name|FT_BASE_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_CMap_New
argument_list|(
argument|FT_CMap_Class  clazz
argument_list|,
argument|FT_Pointer     init_data
argument_list|,
argument|FT_CharMap     charmap
argument_list|,
argument|FT_CMap       *acmap
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
name|FT_Face
name|face
decl_stmt|;
name|FT_Memory
name|memory
decl_stmt|;
name|FT_CMap
name|cmap
decl_stmt|;
if|if
condition|(
name|clazz
operator|==
name|NULL
operator|||
name|charmap
operator|==
name|NULL
operator|||
name|charmap
operator|->
name|face
operator|==
name|NULL
condition|)
return|return
name|FT_Err_Invalid_Argument
return|;
name|face
operator|=
name|charmap
operator|->
name|face
expr_stmt|;
name|memory
operator|=
name|FT_FACE_MEMORY
argument_list|(
name|face
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|FT_ALLOC
argument_list|(
name|cmap
argument_list|,
name|clazz
operator|->
name|size
argument_list|)
condition|)
block|{
name|cmap
operator|->
name|charmap
operator|=
operator|*
name|charmap
expr_stmt|;
name|cmap
operator|->
name|clazz
operator|=
name|clazz
expr_stmt|;
if|if
condition|(
name|clazz
operator|->
name|init
condition|)
block|{
name|error
operator|=
name|clazz
operator|->
name|init
argument_list|(
name|cmap
argument_list|,
name|init_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Fail
goto|;
block|}
comment|/* add it to our list of charmaps */
if|if
condition|(
name|FT_RENEW_ARRAY
argument_list|(
name|face
operator|->
name|charmaps
argument_list|,
name|face
operator|->
name|num_charmaps
argument_list|,
name|face
operator|->
name|num_charmaps
operator|+
literal|1
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
name|face
operator|->
name|charmaps
index|[
name|face
operator|->
name|num_charmaps
operator|++
index|]
operator|=
operator|(
name|FT_CharMap
operator|)
name|cmap
expr_stmt|;
block|}
name|Exit
label|:
if|if
condition|(
name|acmap
condition|)
operator|*
name|acmap
operator|=
name|cmap
expr_stmt|;
return|return
name|error
return|;
name|Fail
label|:
name|ft_cmap_done_internal
argument_list|(
name|cmap
argument_list|)
expr_stmt|;
name|cmap
operator|=
name|NULL
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
end_block
begin_comment
comment|/* documentation is in freetype.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_UInt
argument_list|)
end_macro
begin_macro
name|FT_Get_Char_Index
argument_list|(
argument|FT_Face   face
argument_list|,
argument|FT_ULong  charcode
argument_list|)
end_macro
begin_block
block|{
name|FT_UInt
name|result
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|face
operator|&&
name|face
operator|->
name|charmap
condition|)
block|{
name|FT_CMap
name|cmap
init|=
name|FT_CMAP
argument_list|(
name|face
operator|->
name|charmap
argument_list|)
decl_stmt|;
if|if
condition|(
name|charcode
operator|>
literal|0xFFFFFFFFUL
condition|)
block|{
name|FT_TRACE1
argument_list|(
operator|(
literal|"FT_Get_Char_Index: too large charcode"
operator|)
argument_list|)
expr_stmt|;
name|FT_TRACE1
argument_list|(
operator|(
literal|" 0x%x is truncated\n"
operator|,
name|charcode
operator|)
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|cmap
operator|->
name|clazz
operator|->
name|char_index
argument_list|(
name|cmap
argument_list|,
operator|(
name|FT_UInt32
operator|)
name|charcode
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_block
begin_comment
comment|/* documentation is in freetype.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_ULong
argument_list|)
end_macro
begin_macro
name|FT_Get_First_Char
argument_list|(
argument|FT_Face   face
argument_list|,
argument|FT_UInt  *agindex
argument_list|)
end_macro
begin_block
block|{
name|FT_ULong
name|result
init|=
literal|0
decl_stmt|;
name|FT_UInt
name|gindex
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|face
operator|&&
name|face
operator|->
name|charmap
condition|)
block|{
name|gindex
operator|=
name|FT_Get_Char_Index
argument_list|(
name|face
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|gindex
operator|==
literal|0
condition|)
name|result
operator|=
name|FT_Get_Next_Char
argument_list|(
name|face
argument_list|,
literal|0
argument_list|,
operator|&
name|gindex
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|agindex
condition|)
operator|*
name|agindex
operator|=
name|gindex
expr_stmt|;
return|return
name|result
return|;
block|}
end_block
begin_comment
comment|/* documentation is in freetype.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_ULong
argument_list|)
end_macro
begin_macro
name|FT_Get_Next_Char
argument_list|(
argument|FT_Face   face
argument_list|,
argument|FT_ULong  charcode
argument_list|,
argument|FT_UInt  *agindex
argument_list|)
end_macro
begin_block
block|{
name|FT_ULong
name|result
init|=
literal|0
decl_stmt|;
name|FT_UInt
name|gindex
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|face
operator|&&
name|face
operator|->
name|charmap
condition|)
block|{
name|FT_UInt32
name|code
init|=
operator|(
name|FT_UInt32
operator|)
name|charcode
decl_stmt|;
name|FT_CMap
name|cmap
init|=
name|FT_CMAP
argument_list|(
name|face
operator|->
name|charmap
argument_list|)
decl_stmt|;
name|gindex
operator|=
name|cmap
operator|->
name|clazz
operator|->
name|char_next
argument_list|(
name|cmap
argument_list|,
operator|&
name|code
argument_list|)
expr_stmt|;
name|result
operator|=
operator|(
name|gindex
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
name|code
expr_stmt|;
block|}
if|if
condition|(
name|agindex
condition|)
operator|*
name|agindex
operator|=
name|gindex
expr_stmt|;
return|return
name|result
return|;
block|}
end_block
begin_comment
comment|/* documentation is in freetype.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_UInt
argument_list|)
end_macro
begin_macro
name|FT_Face_GetCharVariantIndex
argument_list|(
argument|FT_Face   face
argument_list|,
argument|FT_ULong  charcode
argument_list|,
argument|FT_ULong  variantSelector
argument_list|)
end_macro
begin_block
block|{
name|FT_UInt
name|result
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|face
operator|&&
name|face
operator|->
name|charmap
operator|&&
name|face
operator|->
name|charmap
operator|->
name|encoding
operator|==
name|FT_ENCODING_UNICODE
condition|)
block|{
name|FT_CharMap
name|charmap
init|=
name|find_variant_selector_charmap
argument_list|(
name|face
argument_list|)
decl_stmt|;
name|FT_CMap
name|ucmap
init|=
name|FT_CMAP
argument_list|(
name|face
operator|->
name|charmap
argument_list|)
decl_stmt|;
if|if
condition|(
name|charmap
operator|!=
name|NULL
condition|)
block|{
name|FT_CMap
name|vcmap
init|=
name|FT_CMAP
argument_list|(
name|charmap
argument_list|)
decl_stmt|;
if|if
condition|(
name|charcode
operator|>
literal|0xFFFFFFFFUL
condition|)
block|{
name|FT_TRACE1
argument_list|(
operator|(
literal|"FT_Get_Char_Index: too large charcode"
operator|)
argument_list|)
expr_stmt|;
name|FT_TRACE1
argument_list|(
operator|(
literal|" 0x%x is truncated\n"
operator|,
name|charcode
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|variantSelector
operator|>
literal|0xFFFFFFFFUL
condition|)
block|{
name|FT_TRACE1
argument_list|(
operator|(
literal|"FT_Get_Char_Index: too large variantSelector"
operator|)
argument_list|)
expr_stmt|;
name|FT_TRACE1
argument_list|(
operator|(
literal|" 0x%x is truncated\n"
operator|,
name|variantSelector
operator|)
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|vcmap
operator|->
name|clazz
operator|->
name|char_var_index
argument_list|(
name|vcmap
argument_list|,
name|ucmap
argument_list|,
operator|(
name|FT_UInt32
operator|)
name|charcode
argument_list|,
operator|(
name|FT_UInt32
operator|)
name|variantSelector
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_block
begin_comment
comment|/* documentation is in freetype.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Int
argument_list|)
end_macro
begin_macro
name|FT_Face_GetCharVariantIsDefault
argument_list|(
argument|FT_Face   face
argument_list|,
argument|FT_ULong  charcode
argument_list|,
argument|FT_ULong  variantSelector
argument_list|)
end_macro
begin_block
block|{
name|FT_Int
name|result
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|face
condition|)
block|{
name|FT_CharMap
name|charmap
init|=
name|find_variant_selector_charmap
argument_list|(
name|face
argument_list|)
decl_stmt|;
if|if
condition|(
name|charmap
operator|!=
name|NULL
condition|)
block|{
name|FT_CMap
name|vcmap
init|=
name|FT_CMAP
argument_list|(
name|charmap
argument_list|)
decl_stmt|;
if|if
condition|(
name|charcode
operator|>
literal|0xFFFFFFFFUL
condition|)
block|{
name|FT_TRACE1
argument_list|(
operator|(
literal|"FT_Get_Char_Index: too large charcode"
operator|)
argument_list|)
expr_stmt|;
name|FT_TRACE1
argument_list|(
operator|(
literal|" 0x%x is truncated\n"
operator|,
name|charcode
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|variantSelector
operator|>
literal|0xFFFFFFFFUL
condition|)
block|{
name|FT_TRACE1
argument_list|(
operator|(
literal|"FT_Get_Char_Index: too large variantSelector"
operator|)
argument_list|)
expr_stmt|;
name|FT_TRACE1
argument_list|(
operator|(
literal|" 0x%x is truncated\n"
operator|,
name|variantSelector
operator|)
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|vcmap
operator|->
name|clazz
operator|->
name|char_var_default
argument_list|(
name|vcmap
argument_list|,
operator|(
name|FT_UInt32
operator|)
name|charcode
argument_list|,
operator|(
name|FT_UInt32
operator|)
name|variantSelector
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_block
begin_comment
comment|/* documentation is in freetype.h */
end_comment
begin_macro
name|FT_EXPORT_DEF
argument_list|(
argument|FT_UInt32*
argument_list|)
end_macro
begin_macro
DECL|function|FT_Face_GetVariantSelectors
name|FT_Face_GetVariantSelectors
argument_list|(
argument|FT_Face  face
argument_list|)
end_macro
begin_block
block|{
name|FT_UInt32
modifier|*
name|result
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|face
condition|)
block|{
name|FT_CharMap
name|charmap
init|=
name|find_variant_selector_charmap
argument_list|(
name|face
argument_list|)
decl_stmt|;
if|if
condition|(
name|charmap
operator|!=
name|NULL
condition|)
block|{
name|FT_CMap
name|vcmap
init|=
name|FT_CMAP
argument_list|(
name|charmap
argument_list|)
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|FT_FACE_MEMORY
argument_list|(
name|face
argument_list|)
decl_stmt|;
name|result
operator|=
name|vcmap
operator|->
name|clazz
operator|->
name|variant_list
argument_list|(
name|vcmap
argument_list|,
name|memory
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_block
begin_comment
comment|/* documentation is in freetype.h */
end_comment
begin_macro
name|FT_EXPORT_DEF
argument_list|(
argument|FT_UInt32*
argument_list|)
end_macro
begin_macro
DECL|function|FT_Face_GetVariantsOfChar
name|FT_Face_GetVariantsOfChar
argument_list|(
argument|FT_Face   face
argument_list|,
argument|FT_ULong  charcode
argument_list|)
end_macro
begin_block
block|{
name|FT_UInt32
modifier|*
name|result
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|face
condition|)
block|{
name|FT_CharMap
name|charmap
init|=
name|find_variant_selector_charmap
argument_list|(
name|face
argument_list|)
decl_stmt|;
if|if
condition|(
name|charmap
operator|!=
name|NULL
condition|)
block|{
name|FT_CMap
name|vcmap
init|=
name|FT_CMAP
argument_list|(
name|charmap
argument_list|)
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|FT_FACE_MEMORY
argument_list|(
name|face
argument_list|)
decl_stmt|;
if|if
condition|(
name|charcode
operator|>
literal|0xFFFFFFFFUL
condition|)
block|{
name|FT_TRACE1
argument_list|(
operator|(
literal|"FT_Get_Char_Index: too large charcode"
operator|)
argument_list|)
expr_stmt|;
name|FT_TRACE1
argument_list|(
operator|(
literal|" 0x%x is truncated\n"
operator|,
name|charcode
operator|)
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|vcmap
operator|->
name|clazz
operator|->
name|charvariant_list
argument_list|(
name|vcmap
argument_list|,
name|memory
argument_list|,
operator|(
name|FT_UInt32
operator|)
name|charcode
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_block
begin_comment
comment|/* documentation is in freetype.h */
end_comment
begin_macro
name|FT_EXPORT_DEF
argument_list|(
argument|FT_UInt32*
argument_list|)
end_macro
begin_macro
DECL|function|FT_Face_GetCharsOfVariant
name|FT_Face_GetCharsOfVariant
argument_list|(
argument|FT_Face   face
argument_list|,
argument|FT_ULong  variantSelector
argument_list|)
end_macro
begin_block
block|{
name|FT_UInt32
modifier|*
name|result
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|face
condition|)
block|{
name|FT_CharMap
name|charmap
init|=
name|find_variant_selector_charmap
argument_list|(
name|face
argument_list|)
decl_stmt|;
if|if
condition|(
name|charmap
operator|!=
name|NULL
condition|)
block|{
name|FT_CMap
name|vcmap
init|=
name|FT_CMAP
argument_list|(
name|charmap
argument_list|)
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|FT_FACE_MEMORY
argument_list|(
name|face
argument_list|)
decl_stmt|;
if|if
condition|(
name|variantSelector
operator|>
literal|0xFFFFFFFFUL
condition|)
block|{
name|FT_TRACE1
argument_list|(
operator|(
literal|"FT_Get_Char_Index: too large variantSelector"
operator|)
argument_list|)
expr_stmt|;
name|FT_TRACE1
argument_list|(
operator|(
literal|" 0x%x is truncated\n"
operator|,
name|variantSelector
operator|)
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|vcmap
operator|->
name|clazz
operator|->
name|variantchar_list
argument_list|(
name|vcmap
argument_list|,
name|memory
argument_list|,
operator|(
name|FT_UInt32
operator|)
name|variantSelector
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_block
begin_comment
comment|/* documentation is in freetype.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_UInt
argument_list|)
end_macro
begin_macro
name|FT_Get_Name_Index
argument_list|(
argument|FT_Face     face
argument_list|,
argument|FT_String*  glyph_name
argument_list|)
end_macro
begin_block
block|{
name|FT_UInt
name|result
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|face
operator|&&
name|FT_HAS_GLYPH_NAMES
argument_list|(
name|face
argument_list|)
condition|)
block|{
name|FT_Service_GlyphDict
name|service
decl_stmt|;
name|FT_FACE_LOOKUP_SERVICE
argument_list|(
name|face
argument_list|,
name|service
argument_list|,
name|GLYPH_DICT
argument_list|)
expr_stmt|;
if|if
condition|(
name|service
operator|&&
name|service
operator|->
name|name_index
condition|)
name|result
operator|=
name|service
operator|->
name|name_index
argument_list|(
name|face
argument_list|,
name|glyph_name
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_block
begin_comment
comment|/* documentation is in freetype.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_Get_Glyph_Name
argument_list|(
argument|FT_Face     face
argument_list|,
argument|FT_UInt     glyph_index
argument_list|,
argument|FT_Pointer  buffer
argument_list|,
argument|FT_UInt     buffer_max
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
init|=
name|FT_Err_Invalid_Argument
decl_stmt|;
comment|/* clean up buffer */
if|if
condition|(
name|buffer
operator|&&
name|buffer_max
operator|>
literal|0
condition|)
operator|(
operator|(
name|FT_Byte
operator|*
operator|)
name|buffer
operator|)
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|face
operator|&&
operator|(
name|FT_Long
operator|)
name|glyph_index
operator|<=
name|face
operator|->
name|num_glyphs
operator|&&
name|FT_HAS_GLYPH_NAMES
argument_list|(
name|face
argument_list|)
condition|)
block|{
name|FT_Service_GlyphDict
name|service
decl_stmt|;
name|FT_FACE_LOOKUP_SERVICE
argument_list|(
name|face
argument_list|,
name|service
argument_list|,
name|GLYPH_DICT
argument_list|)
expr_stmt|;
if|if
condition|(
name|service
operator|&&
name|service
operator|->
name|get_name
condition|)
name|error
operator|=
name|service
operator|->
name|get_name
argument_list|(
name|face
argument_list|,
name|glyph_index
argument_list|,
name|buffer
argument_list|,
name|buffer_max
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/* documentation is in freetype.h */
end_comment
begin_macro
name|FT_EXPORT_DEF
argument_list|(
argument|const char*
argument_list|)
end_macro
begin_macro
DECL|function|FT_Get_Postscript_Name
name|FT_Get_Postscript_Name
argument_list|(
argument|FT_Face  face
argument_list|)
end_macro
begin_block
block|{
specifier|const
name|char
modifier|*
name|result
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|face
condition|)
goto|goto
name|Exit
goto|;
if|if
condition|(
operator|!
name|result
condition|)
block|{
name|FT_Service_PsFontName
name|service
decl_stmt|;
name|FT_FACE_LOOKUP_SERVICE
argument_list|(
name|face
argument_list|,
name|service
argument_list|,
name|POSTSCRIPT_FONT_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|service
operator|&&
name|service
operator|->
name|get_ps_font_name
condition|)
name|result
operator|=
name|service
operator|->
name|get_ps_font_name
argument_list|(
name|face
argument_list|)
expr_stmt|;
block|}
name|Exit
label|:
return|return
name|result
return|;
block|}
end_block
begin_comment
comment|/* documentation is in tttables.h */
end_comment
begin_macro
name|FT_EXPORT_DEF
argument_list|(
argument|void*
argument_list|)
end_macro
begin_macro
DECL|function|FT_Get_Sfnt_Table
name|FT_Get_Sfnt_Table
argument_list|(
argument|FT_Face      face
argument_list|,
argument|FT_Sfnt_Tag  tag
argument_list|)
end_macro
begin_block
block|{
name|void
modifier|*
name|table
init|=
literal|0
decl_stmt|;
name|FT_Service_SFNT_Table
name|service
decl_stmt|;
if|if
condition|(
name|face
operator|&&
name|FT_IS_SFNT
argument_list|(
name|face
argument_list|)
condition|)
block|{
name|FT_FACE_FIND_SERVICE
argument_list|(
name|face
argument_list|,
name|service
argument_list|,
name|SFNT_TABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|service
operator|!=
name|NULL
condition|)
name|table
operator|=
name|service
operator|->
name|get_table
argument_list|(
name|face
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
return|return
name|table
return|;
block|}
end_block
begin_comment
comment|/* documentation is in tttables.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_Load_Sfnt_Table
argument_list|(
argument|FT_Face    face
argument_list|,
argument|FT_ULong   tag
argument_list|,
argument|FT_Long    offset
argument_list|,
argument|FT_Byte*   buffer
argument_list|,
argument|FT_ULong*  length
argument_list|)
end_macro
begin_block
block|{
name|FT_Service_SFNT_Table
name|service
decl_stmt|;
if|if
condition|(
operator|!
name|face
operator|||
operator|!
name|FT_IS_SFNT
argument_list|(
name|face
argument_list|)
condition|)
return|return
name|FT_Err_Invalid_Face_Handle
return|;
name|FT_FACE_FIND_SERVICE
argument_list|(
name|face
argument_list|,
name|service
argument_list|,
name|SFNT_TABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|service
operator|==
name|NULL
condition|)
return|return
name|FT_Err_Unimplemented_Feature
return|;
return|return
name|service
operator|->
name|load_table
argument_list|(
name|face
argument_list|,
name|tag
argument_list|,
name|offset
argument_list|,
name|buffer
argument_list|,
name|length
argument_list|)
return|;
block|}
end_block
begin_comment
comment|/* documentation is in tttables.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_Sfnt_Table_Info
argument_list|(
argument|FT_Face    face
argument_list|,
argument|FT_UInt    table_index
argument_list|,
argument|FT_ULong  *tag
argument_list|,
argument|FT_ULong  *length
argument_list|)
end_macro
begin_block
block|{
name|FT_Service_SFNT_Table
name|service
decl_stmt|;
name|FT_ULong
name|offset
decl_stmt|;
if|if
condition|(
operator|!
name|face
operator|||
operator|!
name|FT_IS_SFNT
argument_list|(
name|face
argument_list|)
condition|)
return|return
name|FT_Err_Invalid_Face_Handle
return|;
name|FT_FACE_FIND_SERVICE
argument_list|(
name|face
argument_list|,
name|service
argument_list|,
name|SFNT_TABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|service
operator|==
name|NULL
condition|)
return|return
name|FT_Err_Unimplemented_Feature
return|;
return|return
name|service
operator|->
name|table_info
argument_list|(
name|face
argument_list|,
name|table_index
argument_list|,
name|tag
argument_list|,
operator|&
name|offset
argument_list|,
name|length
argument_list|)
return|;
block|}
end_block
begin_comment
comment|/* documentation is in tttables.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_ULong
argument_list|)
end_macro
begin_macro
name|FT_Get_CMap_Language_ID
argument_list|(
argument|FT_CharMap  charmap
argument_list|)
end_macro
begin_block
block|{
name|FT_Service_TTCMaps
name|service
decl_stmt|;
name|FT_Face
name|face
decl_stmt|;
name|TT_CMapInfo
name|cmap_info
decl_stmt|;
if|if
condition|(
operator|!
name|charmap
operator|||
operator|!
name|charmap
operator|->
name|face
condition|)
return|return
literal|0
return|;
name|face
operator|=
name|charmap
operator|->
name|face
expr_stmt|;
name|FT_FACE_FIND_SERVICE
argument_list|(
name|face
argument_list|,
name|service
argument_list|,
name|TT_CMAP
argument_list|)
expr_stmt|;
if|if
condition|(
name|service
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|service
operator|->
name|get_cmap_info
argument_list|(
name|charmap
argument_list|,
operator|&
name|cmap_info
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|cmap_info
operator|.
name|language
return|;
block|}
end_block
begin_comment
comment|/* documentation is in tttables.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Long
argument_list|)
end_macro
begin_macro
name|FT_Get_CMap_Format
argument_list|(
argument|FT_CharMap  charmap
argument_list|)
end_macro
begin_block
block|{
name|FT_Service_TTCMaps
name|service
decl_stmt|;
name|FT_Face
name|face
decl_stmt|;
name|TT_CMapInfo
name|cmap_info
decl_stmt|;
if|if
condition|(
operator|!
name|charmap
operator|||
operator|!
name|charmap
operator|->
name|face
condition|)
return|return
operator|-
literal|1
return|;
name|face
operator|=
name|charmap
operator|->
name|face
expr_stmt|;
name|FT_FACE_FIND_SERVICE
argument_list|(
name|face
argument_list|,
name|service
argument_list|,
name|TT_CMAP
argument_list|)
expr_stmt|;
if|if
condition|(
name|service
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|service
operator|->
name|get_cmap_info
argument_list|(
name|charmap
argument_list|,
operator|&
name|cmap_info
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|cmap_info
operator|.
name|format
return|;
block|}
end_block
begin_comment
comment|/* documentation is in ftsizes.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_Activate_Size
argument_list|(
argument|FT_Size  size
argument_list|)
end_macro
begin_block
block|{
name|FT_Face
name|face
decl_stmt|;
if|if
condition|(
name|size
operator|==
name|NULL
condition|)
return|return
name|FT_Err_Invalid_Argument
return|;
name|face
operator|=
name|size
operator|->
name|face
expr_stmt|;
if|if
condition|(
name|face
operator|==
name|NULL
operator|||
name|face
operator|->
name|driver
operator|==
name|NULL
condition|)
return|return
name|FT_Err_Invalid_Argument
return|;
comment|/* we don't need anything more complex than that; all size objects */
comment|/* are already listed by the face                                  */
name|face
operator|->
name|size
operator|=
name|size
expr_stmt|;
return|return
name|FT_Err_Ok
return|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/****                                                                 ****/
end_comment
begin_comment
comment|/****                                                                 ****/
end_comment
begin_comment
comment|/****                        R E N D E R E R S                        ****/
end_comment
begin_comment
comment|/****                                                                 ****/
end_comment
begin_comment
comment|/****                                                                 ****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/* lookup a renderer by glyph format in the library's list */
end_comment
begin_macro
DECL|function|FT_BASE_DEF
name|FT_BASE_DEF
argument_list|(
argument|FT_Renderer
argument_list|)
end_macro
begin_macro
name|FT_Lookup_Renderer
argument_list|(
argument|FT_Library       library
argument_list|,
argument|FT_Glyph_Format  format
argument_list|,
argument|FT_ListNode*     node
argument_list|)
end_macro
begin_block
block|{
name|FT_ListNode
name|cur
decl_stmt|;
name|FT_Renderer
name|result
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|library
condition|)
goto|goto
name|Exit
goto|;
name|cur
operator|=
name|library
operator|->
name|renderers
operator|.
name|head
expr_stmt|;
if|if
condition|(
name|node
condition|)
block|{
if|if
condition|(
operator|*
name|node
condition|)
name|cur
operator|=
operator|(
operator|*
name|node
operator|)
operator|->
name|next
expr_stmt|;
operator|*
name|node
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
name|cur
condition|)
block|{
name|FT_Renderer
name|renderer
init|=
name|FT_RENDERER
argument_list|(
name|cur
operator|->
name|data
argument_list|)
decl_stmt|;
if|if
condition|(
name|renderer
operator|->
name|glyph_format
operator|==
name|format
condition|)
block|{
if|if
condition|(
name|node
condition|)
operator|*
name|node
operator|=
name|cur
expr_stmt|;
name|result
operator|=
name|renderer
expr_stmt|;
break|break;
block|}
name|cur
operator|=
name|cur
operator|->
name|next
expr_stmt|;
block|}
name|Exit
label|:
return|return
name|result
return|;
block|}
end_block
begin_function
specifier|static
name|FT_Renderer
DECL|function|ft_lookup_glyph_renderer
name|ft_lookup_glyph_renderer
parameter_list|(
name|FT_GlyphSlot
name|slot
parameter_list|)
block|{
name|FT_Face
name|face
init|=
name|slot
operator|->
name|face
decl_stmt|;
name|FT_Library
name|library
init|=
name|FT_FACE_LIBRARY
argument_list|(
name|face
argument_list|)
decl_stmt|;
name|FT_Renderer
name|result
init|=
name|library
operator|->
name|cur_renderer
decl_stmt|;
if|if
condition|(
operator|!
name|result
operator|||
name|result
operator|->
name|glyph_format
operator|!=
name|slot
operator|->
name|format
condition|)
name|result
operator|=
name|FT_Lookup_Renderer
argument_list|(
name|library
argument_list|,
name|slot
operator|->
name|format
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|ft_set_current_renderer
name|ft_set_current_renderer
parameter_list|(
name|FT_Library
name|library
parameter_list|)
block|{
name|FT_Renderer
name|renderer
decl_stmt|;
name|renderer
operator|=
name|FT_Lookup_Renderer
argument_list|(
name|library
argument_list|,
name|FT_GLYPH_FORMAT_OUTLINE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|library
operator|->
name|cur_renderer
operator|=
name|renderer
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|ft_add_renderer
name|ft_add_renderer
parameter_list|(
name|FT_Module
name|module
parameter_list|)
block|{
name|FT_Library
name|library
init|=
name|module
operator|->
name|library
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|library
operator|->
name|memory
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|FT_ListNode
name|node
decl_stmt|;
if|if
condition|(
name|FT_NEW
argument_list|(
name|node
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
block|{
name|FT_Renderer
name|render
init|=
name|FT_RENDERER
argument_list|(
name|module
argument_list|)
decl_stmt|;
name|FT_Renderer_Class
modifier|*
name|clazz
init|=
operator|(
name|FT_Renderer_Class
operator|*
operator|)
name|module
operator|->
name|clazz
decl_stmt|;
name|render
operator|->
name|clazz
operator|=
name|clazz
expr_stmt|;
name|render
operator|->
name|glyph_format
operator|=
name|clazz
operator|->
name|glyph_format
expr_stmt|;
comment|/* allocate raster object if needed */
if|if
condition|(
name|clazz
operator|->
name|glyph_format
operator|==
name|FT_GLYPH_FORMAT_OUTLINE
operator|&&
name|clazz
operator|->
name|raster_class
operator|->
name|raster_new
condition|)
block|{
name|error
operator|=
name|clazz
operator|->
name|raster_class
operator|->
name|raster_new
argument_list|(
name|memory
argument_list|,
operator|&
name|render
operator|->
name|raster
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Fail
goto|;
name|render
operator|->
name|raster_render
operator|=
name|clazz
operator|->
name|raster_class
operator|->
name|raster_render
expr_stmt|;
name|render
operator|->
name|render
operator|=
name|clazz
operator|->
name|render_glyph
expr_stmt|;
block|}
comment|/* add to list */
name|node
operator|->
name|data
operator|=
name|module
expr_stmt|;
name|FT_List_Add
argument_list|(
operator|&
name|library
operator|->
name|renderers
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|ft_set_current_renderer
argument_list|(
name|library
argument_list|)
expr_stmt|;
block|}
name|Fail
label|:
if|if
condition|(
name|error
condition|)
name|FT_FREE
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|Exit
label|:
return|return
name|error
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|ft_remove_renderer
name|ft_remove_renderer
parameter_list|(
name|FT_Module
name|module
parameter_list|)
block|{
name|FT_Library
name|library
init|=
name|module
operator|->
name|library
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|library
operator|->
name|memory
decl_stmt|;
name|FT_ListNode
name|node
decl_stmt|;
name|node
operator|=
name|FT_List_Find
argument_list|(
operator|&
name|library
operator|->
name|renderers
argument_list|,
name|module
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
condition|)
block|{
name|FT_Renderer
name|render
init|=
name|FT_RENDERER
argument_list|(
name|module
argument_list|)
decl_stmt|;
comment|/* release raster object, if any */
if|if
condition|(
name|render
operator|->
name|raster
condition|)
name|render
operator|->
name|clazz
operator|->
name|raster_class
operator|->
name|raster_done
argument_list|(
name|render
operator|->
name|raster
argument_list|)
expr_stmt|;
comment|/* remove from list */
name|FT_List_Remove
argument_list|(
operator|&
name|library
operator|->
name|renderers
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|ft_set_current_renderer
argument_list|(
name|library
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/* documentation is in ftrender.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Renderer
argument_list|)
end_macro
begin_macro
name|FT_Get_Renderer
argument_list|(
argument|FT_Library       library
argument_list|,
argument|FT_Glyph_Format  format
argument_list|)
end_macro
begin_block
block|{
comment|/* test for valid `library' delayed to FT_Lookup_Renderer() */
return|return
name|FT_Lookup_Renderer
argument_list|(
name|library
argument_list|,
name|format
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_block
begin_comment
comment|/* documentation is in ftrender.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_Set_Renderer
argument_list|(
argument|FT_Library     library
argument_list|,
argument|FT_Renderer    renderer
argument_list|,
argument|FT_UInt        num_params
argument_list|,
argument|FT_Parameter*  parameters
argument_list|)
end_macro
begin_block
block|{
name|FT_ListNode
name|node
decl_stmt|;
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
if|if
condition|(
operator|!
name|library
condition|)
return|return
name|FT_Err_Invalid_Library_Handle
return|;
if|if
condition|(
operator|!
name|renderer
condition|)
return|return
name|FT_Err_Invalid_Argument
return|;
name|node
operator|=
name|FT_List_Find
argument_list|(
operator|&
name|library
operator|->
name|renderers
argument_list|,
name|renderer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|node
condition|)
block|{
name|error
operator|=
name|FT_Err_Invalid_Argument
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|FT_List_Up
argument_list|(
operator|&
name|library
operator|->
name|renderers
argument_list|,
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|renderer
operator|->
name|glyph_format
operator|==
name|FT_GLYPH_FORMAT_OUTLINE
condition|)
name|library
operator|->
name|cur_renderer
operator|=
name|renderer
expr_stmt|;
if|if
condition|(
name|num_params
operator|>
literal|0
condition|)
block|{
name|FT_Renderer_SetModeFunc
name|set_mode
init|=
name|renderer
operator|->
name|clazz
operator|->
name|set_mode
decl_stmt|;
for|for
control|(
init|;
name|num_params
operator|>
literal|0
condition|;
name|num_params
operator|--
control|)
block|{
name|error
operator|=
name|set_mode
argument_list|(
name|renderer
argument_list|,
name|parameters
operator|->
name|tag
argument_list|,
name|parameters
operator|->
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
block|}
name|Exit
label|:
return|return
name|error
return|;
block|}
end_block
begin_macro
DECL|function|FT_BASE_DEF
name|FT_BASE_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_Render_Glyph_Internal
argument_list|(
argument|FT_Library      library
argument_list|,
argument|FT_GlyphSlot    slot
argument_list|,
argument|FT_Render_Mode  render_mode
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
name|FT_Renderer
name|renderer
decl_stmt|;
comment|/* if it is already a bitmap, no need to do anything */
switch|switch
condition|(
name|slot
operator|->
name|format
condition|)
block|{
case|case
name|FT_GLYPH_FORMAT_BITMAP
case|:
comment|/* already a bitmap, don't do anything */
break|break;
default|default:
block|{
name|FT_ListNode
name|node
init|=
literal|0
decl_stmt|;
name|FT_Bool
name|update
init|=
literal|0
decl_stmt|;
comment|/* small shortcut for the very common case */
if|if
condition|(
name|slot
operator|->
name|format
operator|==
name|FT_GLYPH_FORMAT_OUTLINE
condition|)
block|{
name|renderer
operator|=
name|library
operator|->
name|cur_renderer
expr_stmt|;
name|node
operator|=
name|library
operator|->
name|renderers
operator|.
name|head
expr_stmt|;
block|}
else|else
name|renderer
operator|=
name|FT_Lookup_Renderer
argument_list|(
name|library
argument_list|,
name|slot
operator|->
name|format
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
name|error
operator|=
name|FT_Err_Unimplemented_Feature
expr_stmt|;
while|while
condition|(
name|renderer
condition|)
block|{
name|error
operator|=
name|renderer
operator|->
name|render
argument_list|(
name|renderer
argument_list|,
name|slot
argument_list|,
name|render_mode
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|||
name|FT_ERROR_BASE
argument_list|(
name|error
argument_list|)
operator|!=
name|FT_Err_Cannot_Render_Glyph
condition|)
break|break;
comment|/* FT_Err_Cannot_Render_Glyph is returned if the render mode   */
comment|/* is unsupported by the current renderer for this glyph image */
comment|/* format.                                                     */
comment|/* now, look for another renderer that supports the same */
comment|/* format.                                               */
name|renderer
operator|=
name|FT_Lookup_Renderer
argument_list|(
name|library
argument_list|,
name|slot
operator|->
name|format
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
name|update
operator|=
literal|1
expr_stmt|;
block|}
comment|/* if we changed the current renderer for the glyph image format */
comment|/* we need to select it as the next current one                  */
if|if
condition|(
operator|!
name|error
operator|&&
name|update
operator|&&
name|renderer
condition|)
name|FT_Set_Renderer
argument_list|(
name|library
argument_list|,
name|renderer
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/* documentation is in freetype.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_Render_Glyph
argument_list|(
argument|FT_GlyphSlot    slot
argument_list|,
argument|FT_Render_Mode  render_mode
argument_list|)
end_macro
begin_block
block|{
name|FT_Library
name|library
decl_stmt|;
if|if
condition|(
operator|!
name|slot
condition|)
return|return
name|FT_Err_Invalid_Argument
return|;
name|library
operator|=
name|FT_FACE_LIBRARY
argument_list|(
name|slot
operator|->
name|face
argument_list|)
expr_stmt|;
return|return
name|FT_Render_Glyph_Internal
argument_list|(
name|library
argument_list|,
name|slot
argument_list|,
name|render_mode
argument_list|)
return|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/****                                                                 ****/
end_comment
begin_comment
comment|/****                                                                 ****/
end_comment
begin_comment
comment|/****                         M O D U L E S                           ****/
end_comment
begin_comment
comment|/****                                                                 ****/
end_comment
begin_comment
comment|/****                                                                 ****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    Destroy_Module                                                     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Destroys a given module object.  For drivers, this also destroys   */
end_comment
begin_comment
comment|/*    all child faces.                                                   */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<InOut>                                                               */
end_comment
begin_comment
comment|/*     module :: A handle to the target driver object.                   */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Note>                                                                */
end_comment
begin_comment
comment|/*     The driver _must_ be LOCKED!                                      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|Destroy_Module
name|Destroy_Module
parameter_list|(
name|FT_Module
name|module
parameter_list|)
block|{
name|FT_Memory
name|memory
init|=
name|module
operator|->
name|memory
decl_stmt|;
name|FT_Module_Class
modifier|*
name|clazz
init|=
name|module
operator|->
name|clazz
decl_stmt|;
name|FT_Library
name|library
init|=
name|module
operator|->
name|library
decl_stmt|;
comment|/* finalize client-data - before anything else */
if|if
condition|(
name|module
operator|->
name|generic
operator|.
name|finalizer
condition|)
name|module
operator|->
name|generic
operator|.
name|finalizer
argument_list|(
name|module
argument_list|)
expr_stmt|;
if|if
condition|(
name|library
operator|&&
name|library
operator|->
name|auto_hinter
operator|==
name|module
condition|)
name|library
operator|->
name|auto_hinter
operator|=
literal|0
expr_stmt|;
comment|/* if the module is a renderer */
if|if
condition|(
name|FT_MODULE_IS_RENDERER
argument_list|(
name|module
argument_list|)
condition|)
name|ft_remove_renderer
argument_list|(
name|module
argument_list|)
expr_stmt|;
comment|/* if the module is a font driver, add some steps */
if|if
condition|(
name|FT_MODULE_IS_DRIVER
argument_list|(
name|module
argument_list|)
condition|)
name|Destroy_Driver
argument_list|(
name|FT_DRIVER
argument_list|(
name|module
argument_list|)
argument_list|)
expr_stmt|;
comment|/* finalize the module object */
if|if
condition|(
name|clazz
operator|->
name|module_done
condition|)
name|clazz
operator|->
name|module_done
argument_list|(
name|module
argument_list|)
expr_stmt|;
comment|/* discard it */
name|FT_FREE
argument_list|(
name|module
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* documentation is in ftmodapi.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_Add_Module
argument_list|(
argument|FT_Library              library
argument_list|,
argument|const FT_Module_Class*  clazz
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
decl_stmt|;
name|FT_Memory
name|memory
decl_stmt|;
name|FT_Module
name|module
decl_stmt|;
name|FT_UInt
name|nn
decl_stmt|;
DECL|macro|FREETYPE_VER_FIXED
define|#
directive|define
name|FREETYPE_VER_FIXED
value|( ( (FT_Long)FREETYPE_MAJOR<< 16 ) | \                                 FREETYPE_MINOR                  )
if|if
condition|(
operator|!
name|library
condition|)
return|return
name|FT_Err_Invalid_Library_Handle
return|;
if|if
condition|(
operator|!
name|clazz
condition|)
return|return
name|FT_Err_Invalid_Argument
return|;
comment|/* check freetype version */
if|if
condition|(
name|clazz
operator|->
name|module_requires
operator|>
name|FREETYPE_VER_FIXED
condition|)
return|return
name|FT_Err_Invalid_Version
return|;
comment|/* look for a module with the same name in the library's table */
for|for
control|(
name|nn
operator|=
literal|0
init|;
name|nn
operator|<
name|library
operator|->
name|num_modules
condition|;
name|nn
operator|++
control|)
block|{
name|module
operator|=
name|library
operator|->
name|modules
index|[
name|nn
index|]
expr_stmt|;
if|if
condition|(
name|ft_strcmp
argument_list|(
name|module
operator|->
name|clazz
operator|->
name|module_name
argument_list|,
name|clazz
operator|->
name|module_name
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* this installed module has the same name, compare their versions */
if|if
condition|(
name|clazz
operator|->
name|module_version
operator|<=
name|module
operator|->
name|clazz
operator|->
name|module_version
condition|)
return|return
name|FT_Err_Lower_Module_Version
return|;
comment|/* remove the module from our list, then exit the loop to replace */
comment|/* it by our new version..                                        */
name|FT_Remove_Module
argument_list|(
name|library
argument_list|,
name|module
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|memory
operator|=
name|library
operator|->
name|memory
expr_stmt|;
name|error
operator|=
name|FT_Err_Ok
expr_stmt|;
if|if
condition|(
name|library
operator|->
name|num_modules
operator|>=
name|FT_MAX_MODULES
condition|)
block|{
name|error
operator|=
name|FT_Err_Too_Many_Drivers
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* allocate module object */
if|if
condition|(
name|FT_ALLOC
argument_list|(
name|module
argument_list|,
name|clazz
operator|->
name|module_size
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
comment|/* base initialization */
name|module
operator|->
name|library
operator|=
name|library
expr_stmt|;
name|module
operator|->
name|memory
operator|=
name|memory
expr_stmt|;
name|module
operator|->
name|clazz
operator|=
operator|(
name|FT_Module_Class
operator|*
operator|)
name|clazz
expr_stmt|;
comment|/* check whether the module is a renderer - this must be performed */
comment|/* before the normal module initialization                         */
if|if
condition|(
name|FT_MODULE_IS_RENDERER
argument_list|(
name|module
argument_list|)
condition|)
block|{
comment|/* add to the renderers list */
name|error
operator|=
name|ft_add_renderer
argument_list|(
name|module
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Fail
goto|;
block|}
comment|/* is the module a auto-hinter? */
if|if
condition|(
name|FT_MODULE_IS_HINTER
argument_list|(
name|module
argument_list|)
condition|)
name|library
operator|->
name|auto_hinter
operator|=
name|module
expr_stmt|;
comment|/* if the module is a font driver */
if|if
condition|(
name|FT_MODULE_IS_DRIVER
argument_list|(
name|module
argument_list|)
condition|)
block|{
comment|/* allocate glyph loader if needed */
name|FT_Driver
name|driver
init|=
name|FT_DRIVER
argument_list|(
name|module
argument_list|)
decl_stmt|;
name|driver
operator|->
name|clazz
operator|=
operator|(
name|FT_Driver_Class
operator|)
name|module
operator|->
name|clazz
expr_stmt|;
if|if
condition|(
name|FT_DRIVER_USES_OUTLINES
argument_list|(
name|driver
argument_list|)
condition|)
block|{
name|error
operator|=
name|FT_GlyphLoader_New
argument_list|(
name|memory
argument_list|,
operator|&
name|driver
operator|->
name|glyph_loader
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Fail
goto|;
block|}
block|}
if|if
condition|(
name|clazz
operator|->
name|module_init
condition|)
block|{
name|error
operator|=
name|clazz
operator|->
name|module_init
argument_list|(
name|module
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Fail
goto|;
block|}
comment|/* add module to the library's table */
name|library
operator|->
name|modules
index|[
name|library
operator|->
name|num_modules
operator|++
index|]
operator|=
name|module
expr_stmt|;
name|Exit
label|:
return|return
name|error
return|;
name|Fail
label|:
if|if
condition|(
name|FT_MODULE_IS_DRIVER
argument_list|(
name|module
argument_list|)
condition|)
block|{
name|FT_Driver
name|driver
init|=
name|FT_DRIVER
argument_list|(
name|module
argument_list|)
decl_stmt|;
if|if
condition|(
name|FT_DRIVER_USES_OUTLINES
argument_list|(
name|driver
argument_list|)
condition|)
name|FT_GlyphLoader_Done
argument_list|(
name|driver
operator|->
name|glyph_loader
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|FT_MODULE_IS_RENDERER
argument_list|(
name|module
argument_list|)
condition|)
block|{
name|FT_Renderer
name|renderer
init|=
name|FT_RENDERER
argument_list|(
name|module
argument_list|)
decl_stmt|;
if|if
condition|(
name|renderer
operator|->
name|raster
condition|)
name|renderer
operator|->
name|clazz
operator|->
name|raster_class
operator|->
name|raster_done
argument_list|(
name|renderer
operator|->
name|raster
argument_list|)
expr_stmt|;
block|}
name|FT_FREE
argument_list|(
name|module
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
end_block
begin_comment
comment|/* documentation is in ftmodapi.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Module
argument_list|)
end_macro
begin_macro
name|FT_Get_Module
argument_list|(
argument|FT_Library   library
argument_list|,
argument|const char*  module_name
argument_list|)
end_macro
begin_block
block|{
name|FT_Module
name|result
init|=
literal|0
decl_stmt|;
name|FT_Module
modifier|*
name|cur
decl_stmt|;
name|FT_Module
modifier|*
name|limit
decl_stmt|;
if|if
condition|(
operator|!
name|library
operator|||
operator|!
name|module_name
condition|)
return|return
name|result
return|;
name|cur
operator|=
name|library
operator|->
name|modules
expr_stmt|;
name|limit
operator|=
name|cur
operator|+
name|library
operator|->
name|num_modules
expr_stmt|;
for|for
control|(
init|;
name|cur
operator|<
name|limit
condition|;
name|cur
operator|++
control|)
if|if
condition|(
name|ft_strcmp
argument_list|(
name|cur
index|[
literal|0
index|]
operator|->
name|clazz
operator|->
name|module_name
argument_list|,
name|module_name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|result
operator|=
name|cur
index|[
literal|0
index|]
expr_stmt|;
break|break;
block|}
return|return
name|result
return|;
block|}
end_block
begin_comment
comment|/* documentation is in ftobjs.h */
end_comment
begin_macro
name|FT_BASE_DEF
argument_list|(
argument|const void*
argument_list|)
end_macro
begin_macro
DECL|function|FT_Get_Module_Interface
name|FT_Get_Module_Interface
argument_list|(
argument|FT_Library   library
argument_list|,
argument|const char*  mod_name
argument_list|)
end_macro
begin_block
block|{
name|FT_Module
name|module
decl_stmt|;
comment|/* test for valid `library' delayed to FT_Get_Module() */
name|module
operator|=
name|FT_Get_Module
argument_list|(
name|library
argument_list|,
name|mod_name
argument_list|)
expr_stmt|;
return|return
name|module
condition|?
name|module
operator|->
name|clazz
operator|->
name|module_interface
else|:
literal|0
return|;
block|}
end_block
begin_macro
DECL|function|FT_BASE_DEF
name|FT_BASE_DEF
argument_list|(
argument|FT_Pointer
argument_list|)
end_macro
begin_macro
name|ft_module_get_service
argument_list|(
argument|FT_Module    module
argument_list|,
argument|const char*  service_id
argument_list|)
end_macro
begin_block
block|{
name|FT_Pointer
name|result
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|module
condition|)
block|{
name|FT_ASSERT
argument_list|(
name|module
operator|->
name|clazz
operator|&&
name|module
operator|->
name|clazz
operator|->
name|get_interface
argument_list|)
expr_stmt|;
comment|/* first, look for the service in the module       */
if|if
condition|(
name|module
operator|->
name|clazz
operator|->
name|get_interface
condition|)
name|result
operator|=
name|module
operator|->
name|clazz
operator|->
name|get_interface
argument_list|(
name|module
argument_list|,
name|service_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL
condition|)
block|{
comment|/* we didn't find it, look in all other modules then         */
name|FT_Library
name|library
init|=
name|module
operator|->
name|library
decl_stmt|;
name|FT_Module
modifier|*
name|cur
init|=
name|library
operator|->
name|modules
decl_stmt|;
name|FT_Module
modifier|*
name|limit
init|=
name|cur
operator|+
name|library
operator|->
name|num_modules
decl_stmt|;
for|for
control|(
init|;
name|cur
operator|<
name|limit
condition|;
name|cur
operator|++
control|)
block|{
if|if
condition|(
name|cur
index|[
literal|0
index|]
operator|!=
name|module
condition|)
block|{
name|FT_ASSERT
argument_list|(
name|cur
index|[
literal|0
index|]
operator|->
name|clazz
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur
index|[
literal|0
index|]
operator|->
name|clazz
operator|->
name|get_interface
condition|)
block|{
name|result
operator|=
name|cur
index|[
literal|0
index|]
operator|->
name|clazz
operator|->
name|get_interface
argument_list|(
name|cur
index|[
literal|0
index|]
argument_list|,
name|service_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|NULL
condition|)
break|break;
block|}
block|}
block|}
block|}
block|}
return|return
name|result
return|;
block|}
end_block
begin_comment
comment|/* documentation is in ftmodapi.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_Remove_Module
argument_list|(
argument|FT_Library  library
argument_list|,
argument|FT_Module   module
argument_list|)
end_macro
begin_block
block|{
comment|/* try to find the module from the table, then remove it from there */
if|if
condition|(
operator|!
name|library
condition|)
return|return
name|FT_Err_Invalid_Library_Handle
return|;
if|if
condition|(
name|module
condition|)
block|{
name|FT_Module
modifier|*
name|cur
init|=
name|library
operator|->
name|modules
decl_stmt|;
name|FT_Module
modifier|*
name|limit
init|=
name|cur
operator|+
name|library
operator|->
name|num_modules
decl_stmt|;
for|for
control|(
init|;
name|cur
operator|<
name|limit
condition|;
name|cur
operator|++
control|)
block|{
if|if
condition|(
name|cur
index|[
literal|0
index|]
operator|==
name|module
condition|)
block|{
comment|/* remove it from the table */
name|library
operator|->
name|num_modules
operator|--
expr_stmt|;
name|limit
operator|--
expr_stmt|;
while|while
condition|(
name|cur
operator|<
name|limit
condition|)
block|{
name|cur
index|[
literal|0
index|]
operator|=
name|cur
index|[
literal|1
index|]
expr_stmt|;
name|cur
operator|++
expr_stmt|;
block|}
name|limit
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* destroy the module */
name|Destroy_Module
argument_list|(
name|module
argument_list|)
expr_stmt|;
return|return
name|FT_Err_Ok
return|;
block|}
block|}
block|}
return|return
name|FT_Err_Invalid_Driver_Handle
return|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/****                                                                 ****/
end_comment
begin_comment
comment|/****                                                                 ****/
end_comment
begin_comment
comment|/****                         L I B R A R Y                           ****/
end_comment
begin_comment
comment|/****                                                                 ****/
end_comment
begin_comment
comment|/****                                                                 ****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/* documentation is in ftmodapi.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_New_Library
argument_list|(
argument|FT_Memory    memory
argument_list|,
argument|FT_Library  *alibrary
argument_list|)
end_macro
begin_block
block|{
name|FT_Library
name|library
init|=
literal|0
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
if|if
condition|(
operator|!
name|memory
condition|)
return|return
name|FT_Err_Invalid_Argument
return|;
ifdef|#
directive|ifdef
name|FT_DEBUG_LEVEL_ERROR
comment|/* init debugging support */
name|ft_debug_init
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* first of all, allocate the library object */
if|if
condition|(
name|FT_NEW
argument_list|(
name|library
argument_list|)
condition|)
return|return
name|error
return|;
name|library
operator|->
name|memory
operator|=
name|memory
expr_stmt|;
ifdef|#
directive|ifdef
name|FT_CONFIG_OPTION_PIC
comment|/* initialize position independent code containers */
name|error
operator|=
name|ft_pic_container_init
argument_list|(
name|library
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Fail
goto|;
endif|#
directive|endif
comment|/* allocate the render pool */
name|library
operator|->
name|raster_pool_size
operator|=
name|FT_RENDER_POOL_SIZE
expr_stmt|;
if|#
directive|if
name|FT_RENDER_POOL_SIZE
operator|>
literal|0
if|if
condition|(
name|FT_ALLOC
argument_list|(
name|library
operator|->
name|raster_pool
argument_list|,
name|FT_RENDER_POOL_SIZE
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
endif|#
directive|endif
name|library
operator|->
name|version_major
operator|=
name|FREETYPE_MAJOR
expr_stmt|;
name|library
operator|->
name|version_minor
operator|=
name|FREETYPE_MINOR
expr_stmt|;
name|library
operator|->
name|version_patch
operator|=
name|FREETYPE_PATCH
expr_stmt|;
comment|/* That's ok now */
operator|*
name|alibrary
operator|=
name|library
expr_stmt|;
return|return
name|FT_Err_Ok
return|;
name|Fail
label|:
ifdef|#
directive|ifdef
name|FT_CONFIG_OPTION_PIC
name|ft_pic_container_destroy
argument_list|(
name|library
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|FT_FREE
argument_list|(
name|library
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/* documentation is in freetype.h */
end_comment
begin_macro
name|FT_EXPORT_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|FT_Library_Version
name|FT_Library_Version
argument_list|(
argument|FT_Library   library
argument_list|,
argument|FT_Int      *amajor
argument_list|,
argument|FT_Int      *aminor
argument_list|,
argument|FT_Int      *apatch
argument_list|)
end_macro
begin_block
block|{
name|FT_Int
name|major
init|=
literal|0
decl_stmt|;
name|FT_Int
name|minor
init|=
literal|0
decl_stmt|;
name|FT_Int
name|patch
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|library
condition|)
block|{
name|major
operator|=
name|library
operator|->
name|version_major
expr_stmt|;
name|minor
operator|=
name|library
operator|->
name|version_minor
expr_stmt|;
name|patch
operator|=
name|library
operator|->
name|version_patch
expr_stmt|;
block|}
if|if
condition|(
name|amajor
condition|)
operator|*
name|amajor
operator|=
name|major
expr_stmt|;
if|if
condition|(
name|aminor
condition|)
operator|*
name|aminor
operator|=
name|minor
expr_stmt|;
if|if
condition|(
name|apatch
condition|)
operator|*
name|apatch
operator|=
name|patch
expr_stmt|;
block|}
end_block
begin_comment
comment|/* documentation is in ftmodapi.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_Done_Library
argument_list|(
argument|FT_Library  library
argument_list|)
end_macro
begin_block
block|{
name|FT_Memory
name|memory
decl_stmt|;
if|if
condition|(
operator|!
name|library
condition|)
return|return
name|FT_Err_Invalid_Library_Handle
return|;
name|memory
operator|=
name|library
operator|->
name|memory
expr_stmt|;
comment|/* Discard client-data */
if|if
condition|(
name|library
operator|->
name|generic
operator|.
name|finalizer
condition|)
name|library
operator|->
name|generic
operator|.
name|finalizer
argument_list|(
name|library
argument_list|)
expr_stmt|;
comment|/* Close all faces in the library.  If we don't do      * this, we can have some subtle memory leaks.      * Example:      *      *  - the cff font driver uses the pshinter module in cff_size_done      *  - if the pshinter module is destroyed before the cff font driver,      *    opened FT_Face objects managed by the driver are not properly      *    destroyed, resulting in a memory leak      */
block|{
name|FT_UInt
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|library
operator|->
name|num_modules
condition|;
name|n
operator|++
control|)
block|{
name|FT_Module
name|module
init|=
name|library
operator|->
name|modules
index|[
name|n
index|]
decl_stmt|;
name|FT_List
name|faces
decl_stmt|;
if|if
condition|(
operator|(
name|module
operator|->
name|clazz
operator|->
name|module_flags
operator|&
name|FT_MODULE_FONT_DRIVER
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|faces
operator|=
operator|&
name|FT_DRIVER
argument_list|(
name|module
argument_list|)
operator|->
name|faces_list
expr_stmt|;
while|while
condition|(
name|faces
operator|->
name|head
condition|)
block|{
name|FT_Done_Face
argument_list|(
name|FT_FACE
argument_list|(
name|faces
operator|->
name|head
operator|->
name|data
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|faces
operator|->
name|head
condition|)
name|FT_TRACE0
argument_list|(
operator|(
literal|"FT_Done_Library: failed to free some faces\n"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Close all other modules in the library */
if|#
directive|if
literal|1
comment|/* XXX Modules are removed in the reversed order so that  */
comment|/* type42 module is removed before truetype module.  This */
comment|/* avoids double free in some occasions.  It is a hack.   */
while|while
condition|(
name|library
operator|->
name|num_modules
operator|>
literal|0
condition|)
name|FT_Remove_Module
argument_list|(
name|library
argument_list|,
name|library
operator|->
name|modules
index|[
name|library
operator|->
name|num_modules
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
else|#
directive|else
block|{
name|FT_UInt
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|library
operator|->
name|num_modules
condition|;
name|n
operator|++
control|)
block|{
name|FT_Module
name|module
init|=
name|library
operator|->
name|modules
index|[
name|n
index|]
decl_stmt|;
if|if
condition|(
name|module
condition|)
block|{
name|Destroy_Module
argument_list|(
name|module
argument_list|)
expr_stmt|;
name|library
operator|->
name|modules
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* Destroy raster objects */
name|FT_FREE
argument_list|(
name|library
operator|->
name|raster_pool
argument_list|)
expr_stmt|;
name|library
operator|->
name|raster_pool_size
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|FT_CONFIG_OPTION_PIC
comment|/* Destroy pic container contents */
name|ft_pic_container_destroy
argument_list|(
name|library
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|FT_FREE
argument_list|(
name|library
argument_list|)
expr_stmt|;
return|return
name|FT_Err_Ok
return|;
block|}
end_block
begin_comment
comment|/* documentation is in ftmodapi.h */
end_comment
begin_macro
name|FT_EXPORT_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|FT_Set_Debug_Hook
name|FT_Set_Debug_Hook
argument_list|(
argument|FT_Library         library
argument_list|,
argument|FT_UInt            hook_index
argument_list|,
argument|FT_DebugHook_Func  debug_hook
argument_list|)
end_macro
begin_block
block|{
if|if
condition|(
name|library
operator|&&
name|debug_hook
operator|&&
name|hook_index
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|library
operator|->
name|debug_hooks
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|)
condition|)
name|library
operator|->
name|debug_hooks
index|[
name|hook_index
index|]
operator|=
name|debug_hook
expr_stmt|;
block|}
end_block
begin_comment
comment|/* documentation is in ftmodapi.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_TrueTypeEngineType
argument_list|)
end_macro
begin_macro
name|FT_Get_TrueType_Engine_Type
argument_list|(
argument|FT_Library  library
argument_list|)
end_macro
begin_block
block|{
name|FT_TrueTypeEngineType
name|result
init|=
name|FT_TRUETYPE_ENGINE_TYPE_NONE
decl_stmt|;
if|if
condition|(
name|library
condition|)
block|{
name|FT_Module
name|module
init|=
name|FT_Get_Module
argument_list|(
name|library
argument_list|,
literal|"truetype"
argument_list|)
decl_stmt|;
if|if
condition|(
name|module
condition|)
block|{
name|FT_Service_TrueTypeEngine
name|service
decl_stmt|;
name|service
operator|=
operator|(
name|FT_Service_TrueTypeEngine
operator|)
name|ft_module_get_service
argument_list|(
name|module
argument_list|,
name|FT_SERVICE_ID_TRUETYPE_ENGINE
argument_list|)
expr_stmt|;
if|if
condition|(
name|service
condition|)
name|result
operator|=
name|service
operator|->
name|engine_type
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_block
begin_ifdef
ifdef|#
directive|ifdef
name|FT_CONFIG_OPTION_OLD_INTERNALS
end_ifdef
begin_macro
DECL|function|FT_BASE_DEF
name|FT_BASE_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|ft_stub_set_char_sizes
argument_list|(
argument|FT_Size     size
argument_list|,
argument|FT_F26Dot6  width
argument_list|,
argument|FT_F26Dot6  height
argument_list|,
argument|FT_UInt     horz_res
argument_list|,
argument|FT_UInt     vert_res
argument_list|)
end_macro
begin_block
block|{
name|FT_Size_RequestRec
name|req
decl_stmt|;
name|FT_Driver
name|driver
init|=
name|size
operator|->
name|face
operator|->
name|driver
decl_stmt|;
if|if
condition|(
name|driver
operator|->
name|clazz
operator|->
name|request_size
condition|)
block|{
name|req
operator|.
name|type
operator|=
name|FT_SIZE_REQUEST_TYPE_NOMINAL
expr_stmt|;
name|req
operator|.
name|width
operator|=
name|width
expr_stmt|;
name|req
operator|.
name|height
operator|=
name|height
expr_stmt|;
if|if
condition|(
name|horz_res
operator|==
literal|0
condition|)
name|horz_res
operator|=
name|vert_res
expr_stmt|;
if|if
condition|(
name|vert_res
operator|==
literal|0
condition|)
name|vert_res
operator|=
name|horz_res
expr_stmt|;
if|if
condition|(
name|horz_res
operator|==
literal|0
condition|)
name|horz_res
operator|=
name|vert_res
operator|=
literal|72
expr_stmt|;
name|req
operator|.
name|horiResolution
operator|=
name|horz_res
expr_stmt|;
name|req
operator|.
name|vertResolution
operator|=
name|vert_res
expr_stmt|;
return|return
name|driver
operator|->
name|clazz
operator|->
name|request_size
argument_list|(
name|size
argument_list|,
operator|&
name|req
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_block
begin_macro
DECL|function|FT_BASE_DEF
name|FT_BASE_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|ft_stub_set_pixel_sizes
argument_list|(
argument|FT_Size  size
argument_list|,
argument|FT_UInt  width
argument_list|,
argument|FT_UInt  height
argument_list|)
end_macro
begin_block
block|{
name|FT_Size_RequestRec
name|req
decl_stmt|;
name|FT_Driver
name|driver
init|=
name|size
operator|->
name|face
operator|->
name|driver
decl_stmt|;
if|if
condition|(
name|driver
operator|->
name|clazz
operator|->
name|request_size
condition|)
block|{
name|req
operator|.
name|type
operator|=
name|FT_SIZE_REQUEST_TYPE_NOMINAL
expr_stmt|;
name|req
operator|.
name|width
operator|=
name|width
operator|<<
literal|6
expr_stmt|;
name|req
operator|.
name|height
operator|=
name|height
operator|<<
literal|6
expr_stmt|;
name|req
operator|.
name|horiResolution
operator|=
literal|0
expr_stmt|;
name|req
operator|.
name|vertResolution
operator|=
literal|0
expr_stmt|;
return|return
name|driver
operator|->
name|clazz
operator|->
name|request_size
argument_list|(
name|size
argument_list|,
operator|&
name|req
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_block
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* FT_CONFIG_OPTION_OLD_INTERNALS */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_Get_SubGlyph_Info
argument_list|(
argument|FT_GlyphSlot  glyph
argument_list|,
argument|FT_UInt       sub_index
argument_list|,
argument|FT_Int       *p_index
argument_list|,
argument|FT_UInt      *p_flags
argument_list|,
argument|FT_Int       *p_arg1
argument_list|,
argument|FT_Int       *p_arg2
argument_list|,
argument|FT_Matrix    *p_transform
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
init|=
name|FT_Err_Invalid_Argument
decl_stmt|;
if|if
condition|(
name|glyph
operator|!=
name|NULL
operator|&&
name|glyph
operator|->
name|format
operator|==
name|FT_GLYPH_FORMAT_COMPOSITE
operator|&&
name|sub_index
operator|<
name|glyph
operator|->
name|num_subglyphs
condition|)
block|{
name|FT_SubGlyph
name|subg
init|=
name|glyph
operator|->
name|subglyphs
operator|+
name|sub_index
decl_stmt|;
operator|*
name|p_index
operator|=
name|subg
operator|->
name|index
expr_stmt|;
operator|*
name|p_flags
operator|=
name|subg
operator|->
name|flags
expr_stmt|;
operator|*
name|p_arg1
operator|=
name|subg
operator|->
name|arg1
expr_stmt|;
operator|*
name|p_arg2
operator|=
name|subg
operator|->
name|arg2
expr_stmt|;
operator|*
name|p_transform
operator|=
name|subg
operator|->
name|transform
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/* END */
end_comment
end_unit
