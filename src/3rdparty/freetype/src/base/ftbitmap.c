begin_unit
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  ftbitmap.c                                                             */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*    FreeType utility functions for bitmaps (body).                       */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  Copyright 2004-2009, 2011, 2013, 2014 by                               */
end_comment
begin_comment
comment|/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  This file is part of the FreeType project, and may only be used,       */
end_comment
begin_comment
comment|/*  modified, and distributed under the terms of the FreeType project      */
end_comment
begin_comment
comment|/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
end_comment
begin_comment
comment|/*  this file you indicate that you have read the license and              */
end_comment
begin_comment
comment|/*  understand and accept it fully.                                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<ft2build.h>
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_DEBUG_H
end_include
begin_include
include|#
directive|include
include|FT_BITMAP_H
end_include
begin_include
include|#
directive|include
include|FT_IMAGE_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_OBJECTS_H
end_include
begin_decl_stmt
specifier|static
DECL|variable|null_bitmap
specifier|const
name|FT_Bitmap
name|null_bitmap
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* documentation is in ftbitmap.h */
end_comment
begin_macro
name|FT_EXPORT_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|FT_Bitmap_New
name|FT_Bitmap_New
argument_list|(
argument|FT_Bitmap  *abitmap
argument_list|)
end_macro
begin_block
block|{
if|if
condition|(
name|abitmap
condition|)
operator|*
name|abitmap
operator|=
name|null_bitmap
expr_stmt|;
block|}
end_block
begin_comment
comment|/* documentation is in ftbitmap.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_Bitmap_Copy
argument_list|(
argument|FT_Library        library
argument_list|,
argument|const FT_Bitmap  *source
argument_list|,
argument|FT_Bitmap        *target
argument_list|)
end_macro
begin_block
block|{
name|FT_Memory
name|memory
decl_stmt|;
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
name|FT_Int
name|pitch
decl_stmt|;
name|FT_ULong
name|size
decl_stmt|;
name|FT_Int
name|source_pitch_sign
decl_stmt|,
name|target_pitch_sign
decl_stmt|;
if|if
condition|(
operator|!
name|library
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_Library_Handle
argument_list|)
return|;
if|if
condition|(
operator|!
name|source
operator|||
operator|!
name|target
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_Argument
argument_list|)
return|;
if|if
condition|(
name|source
operator|==
name|target
condition|)
return|return
name|FT_Err_Ok
return|;
name|source_pitch_sign
operator|=
name|source
operator|->
name|pitch
operator|<
literal|0
condition|?
operator|-
literal|1
else|:
literal|1
expr_stmt|;
name|target_pitch_sign
operator|=
name|target
operator|->
name|pitch
operator|<
literal|0
condition|?
operator|-
literal|1
else|:
literal|1
expr_stmt|;
if|if
condition|(
name|source
operator|->
name|buffer
operator|==
name|NULL
condition|)
block|{
operator|*
name|target
operator|=
operator|*
name|source
expr_stmt|;
if|if
condition|(
name|source_pitch_sign
operator|!=
name|target_pitch_sign
condition|)
name|target
operator|->
name|pitch
operator|=
operator|-
name|target
operator|->
name|pitch
expr_stmt|;
return|return
name|FT_Err_Ok
return|;
block|}
name|memory
operator|=
name|library
operator|->
name|memory
expr_stmt|;
name|pitch
operator|=
name|source
operator|->
name|pitch
expr_stmt|;
if|if
condition|(
name|pitch
operator|<
literal|0
condition|)
name|pitch
operator|=
operator|-
name|pitch
expr_stmt|;
name|size
operator|=
operator|(
name|FT_ULong
operator|)
name|pitch
operator|*
name|source
operator|->
name|rows
expr_stmt|;
if|if
condition|(
name|target
operator|->
name|buffer
condition|)
block|{
name|FT_Int
name|target_pitch
init|=
name|target
operator|->
name|pitch
decl_stmt|;
name|FT_ULong
name|target_size
decl_stmt|;
if|if
condition|(
name|target_pitch
operator|<
literal|0
condition|)
name|target_pitch
operator|=
operator|-
name|target_pitch
expr_stmt|;
name|target_size
operator|=
operator|(
name|FT_ULong
operator|)
name|target_pitch
operator|*
name|target
operator|->
name|rows
expr_stmt|;
if|if
condition|(
name|target_size
operator|!=
name|size
condition|)
operator|(
name|void
operator|)
name|FT_QREALLOC
argument_list|(
name|target
operator|->
name|buffer
argument_list|,
name|target_size
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|FT_QALLOC
argument_list|(
name|target
operator|->
name|buffer
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|target
operator|->
name|buffer
expr_stmt|;
operator|*
name|target
operator|=
operator|*
name|source
expr_stmt|;
name|target
operator|->
name|buffer
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|source_pitch_sign
operator|==
name|target_pitch_sign
condition|)
name|FT_MEM_COPY
argument_list|(
name|target
operator|->
name|buffer
argument_list|,
name|source
operator|->
name|buffer
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* take care of bitmap flow */
name|FT_UInt
name|i
decl_stmt|;
name|FT_Byte
modifier|*
name|s
init|=
name|source
operator|->
name|buffer
decl_stmt|;
name|FT_Byte
modifier|*
name|t
init|=
name|target
operator|->
name|buffer
decl_stmt|;
name|t
operator|+=
name|pitch
operator|*
operator|(
name|target
operator|->
name|rows
operator|-
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|target
operator|->
name|rows
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|FT_ARRAY_COPY
argument_list|(
name|t
argument_list|,
name|s
argument_list|,
name|pitch
argument_list|)
expr_stmt|;
name|s
operator|+=
name|pitch
expr_stmt|;
name|t
operator|-=
name|pitch
expr_stmt|;
block|}
block|}
block|}
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/* Enlarge `bitmap' horizontally and vertically by `xpixels' */
end_comment
begin_comment
comment|/* and `ypixels', respectively.                              */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|ft_bitmap_assure_buffer
name|ft_bitmap_assure_buffer
parameter_list|(
name|FT_Memory
name|memory
parameter_list|,
name|FT_Bitmap
modifier|*
name|bitmap
parameter_list|,
name|FT_UInt
name|xpixels
parameter_list|,
name|FT_UInt
name|ypixels
parameter_list|)
block|{
name|FT_Error
name|error
decl_stmt|;
name|int
name|pitch
decl_stmt|;
name|int
name|new_pitch
decl_stmt|;
name|FT_UInt
name|bpp
decl_stmt|;
name|FT_UInt
name|i
decl_stmt|,
name|width
decl_stmt|,
name|height
decl_stmt|;
name|unsigned
name|char
modifier|*
name|buffer
init|=
name|NULL
decl_stmt|;
name|width
operator|=
name|bitmap
operator|->
name|width
expr_stmt|;
name|height
operator|=
name|bitmap
operator|->
name|rows
expr_stmt|;
name|pitch
operator|=
name|bitmap
operator|->
name|pitch
expr_stmt|;
if|if
condition|(
name|pitch
operator|<
literal|0
condition|)
name|pitch
operator|=
operator|-
name|pitch
expr_stmt|;
switch|switch
condition|(
name|bitmap
operator|->
name|pixel_mode
condition|)
block|{
case|case
name|FT_PIXEL_MODE_MONO
case|:
name|bpp
operator|=
literal|1
expr_stmt|;
name|new_pitch
operator|=
operator|(
name|width
operator|+
name|xpixels
operator|+
literal|7
operator|)
operator|>>
literal|3
expr_stmt|;
break|break;
case|case
name|FT_PIXEL_MODE_GRAY2
case|:
name|bpp
operator|=
literal|2
expr_stmt|;
name|new_pitch
operator|=
operator|(
name|width
operator|+
name|xpixels
operator|+
literal|3
operator|)
operator|>>
literal|2
expr_stmt|;
break|break;
case|case
name|FT_PIXEL_MODE_GRAY4
case|:
name|bpp
operator|=
literal|4
expr_stmt|;
name|new_pitch
operator|=
operator|(
name|width
operator|+
name|xpixels
operator|+
literal|1
operator|)
operator|>>
literal|1
expr_stmt|;
break|break;
case|case
name|FT_PIXEL_MODE_GRAY
case|:
case|case
name|FT_PIXEL_MODE_LCD
case|:
case|case
name|FT_PIXEL_MODE_LCD_V
case|:
name|bpp
operator|=
literal|8
expr_stmt|;
name|new_pitch
operator|=
operator|(
name|width
operator|+
name|xpixels
operator|)
expr_stmt|;
break|break;
default|default:
return|return
name|FT_THROW
argument_list|(
name|Invalid_Glyph_Format
argument_list|)
return|;
block|}
comment|/* if no need to allocate memory */
if|if
condition|(
name|ypixels
operator|==
literal|0
operator|&&
name|new_pitch
operator|<=
name|pitch
condition|)
block|{
comment|/* zero the padding */
name|FT_UInt
name|bit_width
init|=
name|pitch
operator|*
literal|8
decl_stmt|;
name|FT_UInt
name|bit_last
init|=
operator|(
name|width
operator|+
name|xpixels
operator|)
operator|*
name|bpp
decl_stmt|;
if|if
condition|(
name|bit_last
operator|<
name|bit_width
condition|)
block|{
name|FT_Byte
modifier|*
name|line
init|=
name|bitmap
operator|->
name|buffer
operator|+
operator|(
name|bit_last
operator|>>
literal|3
operator|)
decl_stmt|;
name|FT_Byte
modifier|*
name|end
init|=
name|bitmap
operator|->
name|buffer
operator|+
name|pitch
decl_stmt|;
name|FT_UInt
name|shift
init|=
name|bit_last
operator|&
literal|7
decl_stmt|;
name|FT_UInt
name|mask
init|=
literal|0xFF00U
operator|>>
name|shift
decl_stmt|;
name|FT_UInt
name|count
init|=
name|height
decl_stmt|;
for|for
control|(
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
operator|,
name|line
operator|+=
name|pitch
operator|,
name|end
operator|+=
name|pitch
control|)
block|{
name|FT_Byte
modifier|*
name|write
init|=
name|line
decl_stmt|;
if|if
condition|(
name|shift
operator|>
literal|0
condition|)
block|{
name|write
index|[
literal|0
index|]
operator|=
call|(
name|FT_Byte
call|)
argument_list|(
name|write
index|[
literal|0
index|]
operator|&
name|mask
argument_list|)
expr_stmt|;
name|write
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|write
operator|<
name|end
condition|)
name|FT_MEM_ZERO
argument_list|(
name|write
argument_list|,
name|end
operator|-
name|write
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|FT_Err_Ok
return|;
block|}
comment|/* otherwise allocate new buffer */
if|if
condition|(
name|FT_QALLOC_MULT
argument_list|(
name|buffer
argument_list|,
name|new_pitch
argument_list|,
name|bitmap
operator|->
name|rows
operator|+
name|ypixels
argument_list|)
condition|)
return|return
name|error
return|;
comment|/* new rows get added at the top of the bitmap, */
comment|/* thus take care of the flow direction         */
if|if
condition|(
name|bitmap
operator|->
name|pitch
operator|>
literal|0
condition|)
block|{
name|FT_UInt
name|len
init|=
operator|(
name|width
operator|*
name|bpp
operator|+
literal|7
operator|)
operator|>>
literal|3
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bitmap
operator|->
name|rows
condition|;
name|i
operator|++
control|)
name|FT_MEM_COPY
argument_list|(
name|buffer
operator|+
name|new_pitch
operator|*
operator|(
name|ypixels
operator|+
name|i
operator|)
argument_list|,
name|bitmap
operator|->
name|buffer
operator|+
name|pitch
operator|*
name|i
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|FT_UInt
name|len
init|=
operator|(
name|width
operator|*
name|bpp
operator|+
literal|7
operator|)
operator|>>
literal|3
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bitmap
operator|->
name|rows
condition|;
name|i
operator|++
control|)
name|FT_MEM_COPY
argument_list|(
name|buffer
operator|+
name|new_pitch
operator|*
name|i
argument_list|,
name|bitmap
operator|->
name|buffer
operator|+
name|pitch
operator|*
name|i
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
name|FT_FREE
argument_list|(
name|bitmap
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|bitmap
operator|->
name|buffer
operator|=
name|buffer
expr_stmt|;
if|if
condition|(
name|bitmap
operator|->
name|pitch
operator|<
literal|0
condition|)
name|new_pitch
operator|=
operator|-
name|new_pitch
expr_stmt|;
comment|/* set pitch only, width and height are left untouched */
name|bitmap
operator|->
name|pitch
operator|=
name|new_pitch
expr_stmt|;
return|return
name|FT_Err_Ok
return|;
block|}
end_function
begin_comment
comment|/* documentation is in ftbitmap.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_Bitmap_Embolden
argument_list|(
argument|FT_Library  library
argument_list|,
argument|FT_Bitmap*  bitmap
argument_list|,
argument|FT_Pos      xStrength
argument_list|,
argument|FT_Pos      yStrength
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|FT_Int
name|i
decl_stmt|,
name|x
decl_stmt|,
name|pitch
decl_stmt|;
name|FT_UInt
name|y
decl_stmt|;
name|FT_Int
name|xstr
decl_stmt|,
name|ystr
decl_stmt|;
if|if
condition|(
operator|!
name|library
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_Library_Handle
argument_list|)
return|;
if|if
condition|(
operator|!
name|bitmap
operator|||
operator|!
name|bitmap
operator|->
name|buffer
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_Argument
argument_list|)
return|;
if|if
condition|(
operator|(
operator|(
name|FT_PIX_ROUND
argument_list|(
name|xStrength
argument_list|)
operator|>>
literal|6
operator|)
operator|>
name|FT_INT_MAX
operator|)
operator|||
operator|(
operator|(
name|FT_PIX_ROUND
argument_list|(
name|yStrength
argument_list|)
operator|>>
literal|6
operator|)
operator|>
name|FT_INT_MAX
operator|)
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_Argument
argument_list|)
return|;
name|xstr
operator|=
operator|(
name|FT_Int
operator|)
name|FT_PIX_ROUND
argument_list|(
name|xStrength
argument_list|)
operator|>>
literal|6
expr_stmt|;
name|ystr
operator|=
operator|(
name|FT_Int
operator|)
name|FT_PIX_ROUND
argument_list|(
name|yStrength
argument_list|)
operator|>>
literal|6
expr_stmt|;
if|if
condition|(
name|xstr
operator|==
literal|0
operator|&&
name|ystr
operator|==
literal|0
condition|)
return|return
name|FT_Err_Ok
return|;
elseif|else
if|if
condition|(
name|xstr
operator|<
literal|0
operator|||
name|ystr
operator|<
literal|0
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_Argument
argument_list|)
return|;
switch|switch
condition|(
name|bitmap
operator|->
name|pixel_mode
condition|)
block|{
case|case
name|FT_PIXEL_MODE_GRAY2
case|:
case|case
name|FT_PIXEL_MODE_GRAY4
case|:
block|{
name|FT_Bitmap
name|tmp
decl_stmt|;
comment|/* convert to 8bpp */
name|FT_Bitmap_New
argument_list|(
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|error
operator|=
name|FT_Bitmap_Convert
argument_list|(
name|library
argument_list|,
name|bitmap
argument_list|,
operator|&
name|tmp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|FT_Bitmap_Done
argument_list|(
name|library
argument_list|,
name|bitmap
argument_list|)
expr_stmt|;
operator|*
name|bitmap
operator|=
name|tmp
expr_stmt|;
block|}
break|break;
case|case
name|FT_PIXEL_MODE_MONO
case|:
if|if
condition|(
name|xstr
operator|>
literal|8
condition|)
name|xstr
operator|=
literal|8
expr_stmt|;
break|break;
case|case
name|FT_PIXEL_MODE_LCD
case|:
name|xstr
operator|*=
literal|3
expr_stmt|;
break|break;
case|case
name|FT_PIXEL_MODE_LCD_V
case|:
name|ystr
operator|*=
literal|3
expr_stmt|;
break|break;
case|case
name|FT_PIXEL_MODE_BGRA
case|:
comment|/* We don't embolden color glyphs. */
return|return
name|FT_Err_Ok
return|;
block|}
name|error
operator|=
name|ft_bitmap_assure_buffer
argument_list|(
name|library
operator|->
name|memory
argument_list|,
name|bitmap
argument_list|,
name|xstr
argument_list|,
name|ystr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
comment|/* take care of bitmap flow */
name|pitch
operator|=
name|bitmap
operator|->
name|pitch
expr_stmt|;
if|if
condition|(
name|pitch
operator|>
literal|0
condition|)
name|p
operator|=
name|bitmap
operator|->
name|buffer
operator|+
name|pitch
operator|*
name|ystr
expr_stmt|;
else|else
block|{
name|pitch
operator|=
operator|-
name|pitch
expr_stmt|;
name|p
operator|=
name|bitmap
operator|->
name|buffer
operator|+
name|pitch
operator|*
operator|(
name|bitmap
operator|->
name|rows
operator|-
literal|1
operator|)
expr_stmt|;
block|}
comment|/* for each row */
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|bitmap
operator|->
name|rows
condition|;
name|y
operator|++
control|)
block|{
comment|/*        * Horizontally:        *        * From the last pixel on, make each pixel or'ed with the        * `xstr' pixels before it.        */
for|for
control|(
name|x
operator|=
name|pitch
operator|-
literal|1
init|;
name|x
operator|>=
literal|0
condition|;
name|x
operator|--
control|)
block|{
name|unsigned
name|char
name|tmp
decl_stmt|;
name|tmp
operator|=
name|p
index|[
name|x
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|xstr
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bitmap
operator|->
name|pixel_mode
operator|==
name|FT_PIXEL_MODE_MONO
condition|)
block|{
name|p
index|[
name|x
index|]
operator||=
name|tmp
operator|>>
name|i
expr_stmt|;
comment|/* the maximum value of 8 for `xstr' comes from here */
if|if
condition|(
name|x
operator|>
literal|0
condition|)
name|p
index|[
name|x
index|]
operator||=
name|p
index|[
name|x
operator|-
literal|1
index|]
operator|<<
operator|(
literal|8
operator|-
name|i
operator|)
expr_stmt|;
if|#
directive|if
literal|0
block|if ( p[x] == 0xFF )               break;
endif|#
directive|endif
block|}
else|else
block|{
if|if
condition|(
name|x
operator|-
name|i
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|p
index|[
name|x
index|]
operator|+
name|p
index|[
name|x
operator|-
name|i
index|]
operator|>
name|bitmap
operator|->
name|num_grays
operator|-
literal|1
condition|)
block|{
name|p
index|[
name|x
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|bitmap
operator|->
name|num_grays
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|p
index|[
name|x
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|p
index|[
name|x
index|]
operator|+
name|p
index|[
name|x
operator|-
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
index|[
name|x
index|]
operator|==
name|bitmap
operator|->
name|num_grays
operator|-
literal|1
condition|)
break|break;
block|}
block|}
else|else
break|break;
block|}
block|}
block|}
comment|/*        * Vertically:        *        * Make the above `ystr' rows or'ed with it.        */
for|for
control|(
name|x
operator|=
literal|1
init|;
name|x
operator|<=
name|ystr
condition|;
name|x
operator|++
control|)
block|{
name|unsigned
name|char
modifier|*
name|q
decl_stmt|;
name|q
operator|=
name|p
operator|-
name|bitmap
operator|->
name|pitch
operator|*
name|x
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pitch
condition|;
name|i
operator|++
control|)
name|q
index|[
name|i
index|]
operator||=
name|p
index|[
name|i
index|]
expr_stmt|;
block|}
name|p
operator|+=
name|bitmap
operator|->
name|pitch
expr_stmt|;
block|}
name|bitmap
operator|->
name|width
operator|+=
name|xstr
expr_stmt|;
name|bitmap
operator|->
name|rows
operator|+=
name|ystr
expr_stmt|;
return|return
name|FT_Err_Ok
return|;
block|}
end_block
begin_function
specifier|static
name|FT_Byte
DECL|function|ft_gray_for_premultiplied_srgb_bgra
name|ft_gray_for_premultiplied_srgb_bgra
parameter_list|(
specifier|const
name|FT_Byte
modifier|*
name|bgra
parameter_list|)
block|{
name|FT_UInt
name|a
init|=
name|bgra
index|[
literal|3
index|]
decl_stmt|;
name|FT_UInt
name|l
decl_stmt|;
comment|/* Short-circuit transparent color to avoid division by zero. */
if|if
condition|(
operator|!
name|a
condition|)
return|return
literal|0
return|;
comment|/*      * Luminosity for sRGB is defined using ~0.2126,0.7152,0.0722      * coefficients for RGB channels *on the linear colors*.      * A gamma of 2.2 is fair to assume.  And then, we need to      * undo the premultiplication too.      *      *   http://accessibility.kde.org/hsl-adjusted.php      *      * We do the computation with integers only, applying a gamma of 2.0.      * We guarantee 32-bit arithmetic to avoid overflow but the resulting      * luminosity fits into 16 bits.      *      */
name|l
operator|=
operator|(
literal|4732UL
comment|/* 0.0722 * 65536 */
operator|*
name|bgra
index|[
literal|0
index|]
operator|*
name|bgra
index|[
literal|0
index|]
operator|+
literal|46871UL
comment|/* 0.7152 * 65536 */
operator|*
name|bgra
index|[
literal|1
index|]
operator|*
name|bgra
index|[
literal|1
index|]
operator|+
literal|13933UL
comment|/* 0.2126 * 65536 */
operator|*
name|bgra
index|[
literal|2
index|]
operator|*
name|bgra
index|[
literal|2
index|]
operator|)
operator|>>
literal|16
expr_stmt|;
comment|/*      * Final transparency can be determined as follows.      *      * - If alpha is zero, we want 0.      * - If alpha is zero and luminosity is zero, we want 255.      * - If alpha is zero and luminosity is one, we want 0.      *      * So the formula is a * (1 - l) = a - l * a.      *      * We still need to undo premultiplication by dividing l by a*a.      *      */
return|return
call|(
name|FT_Byte
call|)
argument_list|(
name|a
operator|-
name|l
operator|/
name|a
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/* documentation is in ftbitmap.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_Bitmap_Convert
argument_list|(
argument|FT_Library        library
argument_list|,
argument|const FT_Bitmap  *source
argument_list|,
argument|FT_Bitmap        *target
argument_list|,
argument|FT_Int            alignment
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
name|FT_Memory
name|memory
decl_stmt|;
name|FT_Byte
modifier|*
name|s
decl_stmt|;
name|FT_Byte
modifier|*
name|t
decl_stmt|;
if|if
condition|(
operator|!
name|library
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_Library_Handle
argument_list|)
return|;
if|if
condition|(
operator|!
name|source
operator|||
operator|!
name|target
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_Argument
argument_list|)
return|;
name|memory
operator|=
name|library
operator|->
name|memory
expr_stmt|;
switch|switch
condition|(
name|source
operator|->
name|pixel_mode
condition|)
block|{
case|case
name|FT_PIXEL_MODE_MONO
case|:
case|case
name|FT_PIXEL_MODE_GRAY
case|:
case|case
name|FT_PIXEL_MODE_GRAY2
case|:
case|case
name|FT_PIXEL_MODE_GRAY4
case|:
case|case
name|FT_PIXEL_MODE_LCD
case|:
case|case
name|FT_PIXEL_MODE_LCD_V
case|:
case|case
name|FT_PIXEL_MODE_BGRA
case|:
block|{
name|FT_Int
name|pad
decl_stmt|,
name|old_target_pitch
decl_stmt|,
name|target_pitch
decl_stmt|;
name|FT_ULong
name|old_size
decl_stmt|;
name|old_target_pitch
operator|=
name|target
operator|->
name|pitch
expr_stmt|;
if|if
condition|(
name|old_target_pitch
operator|<
literal|0
condition|)
name|old_target_pitch
operator|=
operator|-
name|old_target_pitch
expr_stmt|;
name|old_size
operator|=
name|target
operator|->
name|rows
operator|*
name|old_target_pitch
expr_stmt|;
name|target
operator|->
name|pixel_mode
operator|=
name|FT_PIXEL_MODE_GRAY
expr_stmt|;
name|target
operator|->
name|rows
operator|=
name|source
operator|->
name|rows
expr_stmt|;
name|target
operator|->
name|width
operator|=
name|source
operator|->
name|width
expr_stmt|;
name|pad
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|alignment
operator|>
literal|0
condition|)
block|{
name|pad
operator|=
name|source
operator|->
name|width
operator|%
name|alignment
expr_stmt|;
if|if
condition|(
name|pad
operator|!=
literal|0
condition|)
name|pad
operator|=
name|alignment
operator|-
name|pad
expr_stmt|;
block|}
name|target_pitch
operator|=
name|source
operator|->
name|width
operator|+
name|pad
expr_stmt|;
if|if
condition|(
name|target_pitch
operator|>
literal|0
operator|&&
operator|(
name|FT_ULong
operator|)
name|target
operator|->
name|rows
operator|>
name|FT_ULONG_MAX
operator|/
name|target_pitch
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_Argument
argument_list|)
return|;
if|if
condition|(
name|target
operator|->
name|rows
operator|*
name|target_pitch
operator|>
name|old_size
operator|&&
name|FT_QREALLOC
argument_list|(
name|target
operator|->
name|buffer
argument_list|,
name|old_size
argument_list|,
name|target
operator|->
name|rows
operator|*
name|target_pitch
argument_list|)
condition|)
return|return
name|error
return|;
name|target
operator|->
name|pitch
operator|=
name|target
operator|->
name|pitch
operator|<
literal|0
condition|?
operator|-
name|target_pitch
else|:
name|target_pitch
expr_stmt|;
block|}
break|break;
default|default:
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Argument
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|source
operator|->
name|buffer
expr_stmt|;
name|t
operator|=
name|target
operator|->
name|buffer
expr_stmt|;
comment|/* take care of bitmap flow */
if|if
condition|(
name|source
operator|->
name|pitch
operator|<
literal|0
condition|)
name|s
operator|-=
name|source
operator|->
name|pitch
operator|*
operator|(
name|source
operator|->
name|rows
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|target
operator|->
name|pitch
operator|<
literal|0
condition|)
name|t
operator|-=
name|target
operator|->
name|pitch
operator|*
operator|(
name|target
operator|->
name|rows
operator|-
literal|1
operator|)
expr_stmt|;
switch|switch
condition|(
name|source
operator|->
name|pixel_mode
condition|)
block|{
case|case
name|FT_PIXEL_MODE_MONO
case|:
block|{
name|FT_UInt
name|i
decl_stmt|;
name|target
operator|->
name|num_grays
operator|=
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
name|source
operator|->
name|rows
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|FT_Byte
modifier|*
name|ss
init|=
name|s
decl_stmt|;
name|FT_Byte
modifier|*
name|tt
init|=
name|t
decl_stmt|;
name|FT_UInt
name|j
decl_stmt|;
comment|/* get the full bytes */
for|for
control|(
name|j
operator|=
name|source
operator|->
name|width
operator|>>
literal|3
init|;
name|j
operator|>
literal|0
condition|;
name|j
operator|--
control|)
block|{
name|FT_Int
name|val
init|=
name|ss
index|[
literal|0
index|]
decl_stmt|;
comment|/* avoid a byte->int cast on each line */
name|tt
index|[
literal|0
index|]
operator|=
call|(
name|FT_Byte
call|)
argument_list|(
operator|(
name|val
operator|&
literal|0x80
operator|)
operator|>>
literal|7
argument_list|)
expr_stmt|;
name|tt
index|[
literal|1
index|]
operator|=
call|(
name|FT_Byte
call|)
argument_list|(
operator|(
name|val
operator|&
literal|0x40
operator|)
operator|>>
literal|6
argument_list|)
expr_stmt|;
name|tt
index|[
literal|2
index|]
operator|=
call|(
name|FT_Byte
call|)
argument_list|(
operator|(
name|val
operator|&
literal|0x20
operator|)
operator|>>
literal|5
argument_list|)
expr_stmt|;
name|tt
index|[
literal|3
index|]
operator|=
call|(
name|FT_Byte
call|)
argument_list|(
operator|(
name|val
operator|&
literal|0x10
operator|)
operator|>>
literal|4
argument_list|)
expr_stmt|;
name|tt
index|[
literal|4
index|]
operator|=
call|(
name|FT_Byte
call|)
argument_list|(
operator|(
name|val
operator|&
literal|0x08
operator|)
operator|>>
literal|3
argument_list|)
expr_stmt|;
name|tt
index|[
literal|5
index|]
operator|=
call|(
name|FT_Byte
call|)
argument_list|(
operator|(
name|val
operator|&
literal|0x04
operator|)
operator|>>
literal|2
argument_list|)
expr_stmt|;
name|tt
index|[
literal|6
index|]
operator|=
call|(
name|FT_Byte
call|)
argument_list|(
operator|(
name|val
operator|&
literal|0x02
operator|)
operator|>>
literal|1
argument_list|)
expr_stmt|;
name|tt
index|[
literal|7
index|]
operator|=
call|(
name|FT_Byte
call|)
argument_list|(
name|val
operator|&
literal|0x01
argument_list|)
expr_stmt|;
name|tt
operator|+=
literal|8
expr_stmt|;
name|ss
operator|+=
literal|1
expr_stmt|;
block|}
comment|/* get remaining pixels (if any) */
name|j
operator|=
name|source
operator|->
name|width
operator|&
literal|7
expr_stmt|;
if|if
condition|(
name|j
operator|>
literal|0
condition|)
block|{
name|FT_Int
name|val
init|=
operator|*
name|ss
decl_stmt|;
for|for
control|(
init|;
name|j
operator|>
literal|0
condition|;
name|j
operator|--
control|)
block|{
name|tt
index|[
literal|0
index|]
operator|=
call|(
name|FT_Byte
call|)
argument_list|(
operator|(
name|val
operator|&
literal|0x80
operator|)
operator|>>
literal|7
argument_list|)
expr_stmt|;
name|val
operator|<<=
literal|1
expr_stmt|;
name|tt
operator|+=
literal|1
expr_stmt|;
block|}
block|}
name|s
operator|+=
name|source
operator|->
name|pitch
expr_stmt|;
name|t
operator|+=
name|target
operator|->
name|pitch
expr_stmt|;
block|}
block|}
break|break;
case|case
name|FT_PIXEL_MODE_GRAY
case|:
case|case
name|FT_PIXEL_MODE_LCD
case|:
case|case
name|FT_PIXEL_MODE_LCD_V
case|:
block|{
name|FT_Int
name|width
init|=
name|source
operator|->
name|width
decl_stmt|;
name|FT_UInt
name|i
decl_stmt|;
name|target
operator|->
name|num_grays
operator|=
literal|256
expr_stmt|;
for|for
control|(
name|i
operator|=
name|source
operator|->
name|rows
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|FT_ARRAY_COPY
argument_list|(
name|t
argument_list|,
name|s
argument_list|,
name|width
argument_list|)
expr_stmt|;
name|s
operator|+=
name|source
operator|->
name|pitch
expr_stmt|;
name|t
operator|+=
name|target
operator|->
name|pitch
expr_stmt|;
block|}
block|}
break|break;
case|case
name|FT_PIXEL_MODE_GRAY2
case|:
block|{
name|FT_UInt
name|i
decl_stmt|;
name|target
operator|->
name|num_grays
operator|=
literal|4
expr_stmt|;
for|for
control|(
name|i
operator|=
name|source
operator|->
name|rows
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|FT_Byte
modifier|*
name|ss
init|=
name|s
decl_stmt|;
name|FT_Byte
modifier|*
name|tt
init|=
name|t
decl_stmt|;
name|FT_UInt
name|j
decl_stmt|;
comment|/* get the full bytes */
for|for
control|(
name|j
operator|=
name|source
operator|->
name|width
operator|>>
literal|2
init|;
name|j
operator|>
literal|0
condition|;
name|j
operator|--
control|)
block|{
name|FT_Int
name|val
init|=
name|ss
index|[
literal|0
index|]
decl_stmt|;
name|tt
index|[
literal|0
index|]
operator|=
call|(
name|FT_Byte
call|)
argument_list|(
operator|(
name|val
operator|&
literal|0xC0
operator|)
operator|>>
literal|6
argument_list|)
expr_stmt|;
name|tt
index|[
literal|1
index|]
operator|=
call|(
name|FT_Byte
call|)
argument_list|(
operator|(
name|val
operator|&
literal|0x30
operator|)
operator|>>
literal|4
argument_list|)
expr_stmt|;
name|tt
index|[
literal|2
index|]
operator|=
call|(
name|FT_Byte
call|)
argument_list|(
operator|(
name|val
operator|&
literal|0x0C
operator|)
operator|>>
literal|2
argument_list|)
expr_stmt|;
name|tt
index|[
literal|3
index|]
operator|=
call|(
name|FT_Byte
call|)
argument_list|(
operator|(
name|val
operator|&
literal|0x03
operator|)
argument_list|)
expr_stmt|;
name|ss
operator|+=
literal|1
expr_stmt|;
name|tt
operator|+=
literal|4
expr_stmt|;
block|}
name|j
operator|=
name|source
operator|->
name|width
operator|&
literal|3
expr_stmt|;
if|if
condition|(
name|j
operator|>
literal|0
condition|)
block|{
name|FT_Int
name|val
init|=
name|ss
index|[
literal|0
index|]
decl_stmt|;
for|for
control|(
init|;
name|j
operator|>
literal|0
condition|;
name|j
operator|--
control|)
block|{
name|tt
index|[
literal|0
index|]
operator|=
call|(
name|FT_Byte
call|)
argument_list|(
operator|(
name|val
operator|&
literal|0xC0
operator|)
operator|>>
literal|6
argument_list|)
expr_stmt|;
name|val
operator|<<=
literal|2
expr_stmt|;
name|tt
operator|+=
literal|1
expr_stmt|;
block|}
block|}
name|s
operator|+=
name|source
operator|->
name|pitch
expr_stmt|;
name|t
operator|+=
name|target
operator|->
name|pitch
expr_stmt|;
block|}
block|}
break|break;
case|case
name|FT_PIXEL_MODE_GRAY4
case|:
block|{
name|FT_UInt
name|i
decl_stmt|;
name|target
operator|->
name|num_grays
operator|=
literal|16
expr_stmt|;
for|for
control|(
name|i
operator|=
name|source
operator|->
name|rows
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|FT_Byte
modifier|*
name|ss
init|=
name|s
decl_stmt|;
name|FT_Byte
modifier|*
name|tt
init|=
name|t
decl_stmt|;
name|FT_UInt
name|j
decl_stmt|;
comment|/* get the full bytes */
for|for
control|(
name|j
operator|=
name|source
operator|->
name|width
operator|>>
literal|1
init|;
name|j
operator|>
literal|0
condition|;
name|j
operator|--
control|)
block|{
name|FT_Int
name|val
init|=
name|ss
index|[
literal|0
index|]
decl_stmt|;
name|tt
index|[
literal|0
index|]
operator|=
call|(
name|FT_Byte
call|)
argument_list|(
operator|(
name|val
operator|&
literal|0xF0
operator|)
operator|>>
literal|4
argument_list|)
expr_stmt|;
name|tt
index|[
literal|1
index|]
operator|=
call|(
name|FT_Byte
call|)
argument_list|(
operator|(
name|val
operator|&
literal|0x0F
operator|)
argument_list|)
expr_stmt|;
name|ss
operator|+=
literal|1
expr_stmt|;
name|tt
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|source
operator|->
name|width
operator|&
literal|1
condition|)
name|tt
index|[
literal|0
index|]
operator|=
call|(
name|FT_Byte
call|)
argument_list|(
operator|(
name|ss
index|[
literal|0
index|]
operator|&
literal|0xF0
operator|)
operator|>>
literal|4
argument_list|)
expr_stmt|;
name|s
operator|+=
name|source
operator|->
name|pitch
expr_stmt|;
name|t
operator|+=
name|target
operator|->
name|pitch
expr_stmt|;
block|}
block|}
break|break;
case|case
name|FT_PIXEL_MODE_BGRA
case|:
block|{
name|FT_UInt
name|i
decl_stmt|;
name|target
operator|->
name|num_grays
operator|=
literal|256
expr_stmt|;
for|for
control|(
name|i
operator|=
name|source
operator|->
name|rows
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|FT_Byte
modifier|*
name|ss
init|=
name|s
decl_stmt|;
name|FT_Byte
modifier|*
name|tt
init|=
name|t
decl_stmt|;
name|FT_UInt
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|source
operator|->
name|width
init|;
name|j
operator|>
literal|0
condition|;
name|j
operator|--
control|)
block|{
name|tt
index|[
literal|0
index|]
operator|=
name|ft_gray_for_premultiplied_srgb_bgra
argument_list|(
name|ss
argument_list|)
expr_stmt|;
name|ss
operator|+=
literal|4
expr_stmt|;
name|tt
operator|+=
literal|1
expr_stmt|;
block|}
name|s
operator|+=
name|source
operator|->
name|pitch
expr_stmt|;
name|t
operator|+=
name|target
operator|->
name|pitch
expr_stmt|;
block|}
block|}
break|break;
default|default:
empty_stmt|;
block|}
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/* documentation is in ftbitmap.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_GlyphSlot_Own_Bitmap
argument_list|(
argument|FT_GlyphSlot  slot
argument_list|)
end_macro
begin_block
block|{
if|if
condition|(
name|slot
operator|&&
name|slot
operator|->
name|format
operator|==
name|FT_GLYPH_FORMAT_BITMAP
operator|&&
operator|!
operator|(
name|slot
operator|->
name|internal
operator|->
name|flags
operator|&
name|FT_GLYPH_OWN_BITMAP
operator|)
condition|)
block|{
name|FT_Bitmap
name|bitmap
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|FT_Bitmap_New
argument_list|(
operator|&
name|bitmap
argument_list|)
expr_stmt|;
name|error
operator|=
name|FT_Bitmap_Copy
argument_list|(
name|slot
operator|->
name|library
argument_list|,
operator|&
name|slot
operator|->
name|bitmap
argument_list|,
operator|&
name|bitmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|slot
operator|->
name|bitmap
operator|=
name|bitmap
expr_stmt|;
name|slot
operator|->
name|internal
operator|->
name|flags
operator||=
name|FT_GLYPH_OWN_BITMAP
expr_stmt|;
block|}
return|return
name|FT_Err_Ok
return|;
block|}
end_block
begin_comment
comment|/* documentation is in ftbitmap.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_Bitmap_Done
argument_list|(
argument|FT_Library  library
argument_list|,
argument|FT_Bitmap  *bitmap
argument_list|)
end_macro
begin_block
block|{
name|FT_Memory
name|memory
decl_stmt|;
if|if
condition|(
operator|!
name|library
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_Library_Handle
argument_list|)
return|;
if|if
condition|(
operator|!
name|bitmap
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_Argument
argument_list|)
return|;
name|memory
operator|=
name|library
operator|->
name|memory
expr_stmt|;
name|FT_FREE
argument_list|(
name|bitmap
operator|->
name|buffer
argument_list|)
expr_stmt|;
operator|*
name|bitmap
operator|=
name|null_bitmap
expr_stmt|;
return|return
name|FT_Err_Ok
return|;
block|}
end_block
begin_comment
comment|/* END */
end_comment
end_unit
