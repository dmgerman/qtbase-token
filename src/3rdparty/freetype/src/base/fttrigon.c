begin_unit
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  fttrigon.c                                                             */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*    FreeType trigonometric functions (body).                             */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  Copyright 2001-2005, 2012-2014 by                                      */
end_comment
begin_comment
comment|/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  This file is part of the FreeType project, and may only be used,       */
end_comment
begin_comment
comment|/*  modified, and distributed under the terms of the FreeType project      */
end_comment
begin_comment
comment|/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
end_comment
begin_comment
comment|/*  this file you indicate that you have read the license and              */
end_comment
begin_comment
comment|/*  understand and accept it fully.                                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* This is a fixed-point CORDIC implementation of trigonometric          */
end_comment
begin_comment
comment|/* functions as well as transformations between Cartesian and polar      */
end_comment
begin_comment
comment|/* coordinates.  The angles are represented as 16.16 fixed-point values  */
end_comment
begin_comment
comment|/* in degrees, i.e., the angular resolution is 2^-16 degrees.  Note that */
end_comment
begin_comment
comment|/* only vectors longer than 2^16*180/pi (or at least 22 bits) on a       */
end_comment
begin_comment
comment|/* discrete Cartesian grid can have the same or better angular           */
end_comment
begin_comment
comment|/* resolution.  Therefore, to maintain this precision, some functions    */
end_comment
begin_comment
comment|/* require an interim upscaling of the vectors, whereas others operate   */
end_comment
begin_comment
comment|/* with 24-bit long vectors directly.                                    */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<ft2build.h>
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_OBJECTS_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_CALC_H
end_include
begin_include
include|#
directive|include
include|FT_TRIGONOMETRY_H
end_include
begin_comment
comment|/* the Cordic shrink factor 0.858785336480436 * 2^32 */
end_comment
begin_define
DECL|macro|FT_TRIG_SCALE
define|#
directive|define
name|FT_TRIG_SCALE
value|0xDBD95B16UL
end_define
begin_comment
comment|/* the highest bit in overflow-safe vector components, */
end_comment
begin_comment
comment|/* MSB of 0.858785336480436 * sqrt(0.5) * 2^30         */
end_comment
begin_define
DECL|macro|FT_TRIG_SAFE_MSB
define|#
directive|define
name|FT_TRIG_SAFE_MSB
value|29
end_define
begin_comment
comment|/* this table was generated for FT_PI = 180L<< 16, i.e. degrees */
end_comment
begin_define
DECL|macro|FT_TRIG_MAX_ITERS
define|#
directive|define
name|FT_TRIG_MAX_ITERS
value|23
end_define
begin_decl_stmt
specifier|static
specifier|const
name|FT_Angle
DECL|variable|ft_trig_arctan_table
name|ft_trig_arctan_table
index|[]
init|=
block|{
literal|1740967L
block|,
literal|919879L
block|,
literal|466945L
block|,
literal|234379L
block|,
literal|117304L
block|,
literal|58666L
block|,
literal|29335L
block|,
literal|14668L
block|,
literal|7334L
block|,
literal|3667L
block|,
literal|1833L
block|,
literal|917L
block|,
literal|458L
block|,
literal|229L
block|,
literal|115L
block|,
literal|57L
block|,
literal|29L
block|,
literal|14L
block|,
literal|7L
block|,
literal|4L
block|,
literal|2L
block|,
literal|1L
block|}
decl_stmt|;
end_decl_stmt
begin_ifdef
ifdef|#
directive|ifdef
name|FT_LONG64
end_ifdef
begin_comment
comment|/* multiply a given value by the CORDIC shrink factor */
end_comment
begin_function
specifier|static
name|FT_Fixed
DECL|function|ft_trig_downscale
name|ft_trig_downscale
parameter_list|(
name|FT_Fixed
name|val
parameter_list|)
block|{
name|FT_Int
name|s
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
block|{
name|val
operator|=
operator|-
name|val
expr_stmt|;
name|s
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* 0x40000000 comes from regression analysis between true */
comment|/* and CORDIC hypotenuse, so it minimizes the error       */
name|val
operator|=
call|(
name|FT_Fixed
call|)
argument_list|(
operator|(
operator|(
name|FT_Int64
operator|)
name|val
operator|*
name|FT_TRIG_SCALE
operator|+
literal|0x40000000UL
operator|)
operator|>>
literal|32
argument_list|)
expr_stmt|;
return|return
name|s
operator|<
literal|0
condition|?
operator|-
name|val
else|:
name|val
return|;
block|}
end_function
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* !FT_LONG64 */
end_comment
begin_comment
comment|/* multiply a given value by the CORDIC shrink factor */
end_comment
begin_function
specifier|static
name|FT_Fixed
DECL|function|ft_trig_downscale
name|ft_trig_downscale
parameter_list|(
name|FT_Fixed
name|val
parameter_list|)
block|{
name|FT_Int
name|s
init|=
literal|1
decl_stmt|;
name|FT_UInt32
name|lo1
decl_stmt|,
name|hi1
decl_stmt|,
name|lo2
decl_stmt|,
name|hi2
decl_stmt|,
name|lo
decl_stmt|,
name|hi
decl_stmt|,
name|i1
decl_stmt|,
name|i2
decl_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
block|{
name|val
operator|=
operator|-
name|val
expr_stmt|;
name|s
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|lo1
operator|=
name|val
operator|&
literal|0x0000FFFFU
expr_stmt|;
name|hi1
operator|=
name|val
operator|>>
literal|16
expr_stmt|;
name|lo2
operator|=
name|FT_TRIG_SCALE
operator|&
literal|0x0000FFFFU
expr_stmt|;
name|hi2
operator|=
name|FT_TRIG_SCALE
operator|>>
literal|16
expr_stmt|;
name|lo
operator|=
name|lo1
operator|*
name|lo2
expr_stmt|;
name|i1
operator|=
name|lo1
operator|*
name|hi2
expr_stmt|;
name|i2
operator|=
name|lo2
operator|*
name|hi1
expr_stmt|;
name|hi
operator|=
name|hi1
operator|*
name|hi2
expr_stmt|;
comment|/* Check carry overflow of i1 + i2 */
name|i1
operator|+=
name|i2
expr_stmt|;
name|hi
operator|+=
call|(
name|FT_UInt32
call|)
argument_list|(
name|i1
operator|<
name|i2
argument_list|)
operator|<<
literal|16
expr_stmt|;
name|hi
operator|+=
name|i1
operator|>>
literal|16
expr_stmt|;
name|i1
operator|=
name|i1
operator|<<
literal|16
expr_stmt|;
comment|/* Check carry overflow of i1 + lo */
name|lo
operator|+=
name|i1
expr_stmt|;
name|hi
operator|+=
operator|(
name|lo
operator|<
name|i1
operator|)
expr_stmt|;
comment|/* 0x40000000 comes from regression analysis between true */
comment|/* and CORDIC hypotenuse, so it minimizes the error       */
comment|/* Check carry overflow of lo + 0x40000000 */
name|lo
operator|+=
literal|0x40000000UL
expr_stmt|;
name|hi
operator|+=
operator|(
name|lo
operator|<
literal|0x40000000UL
operator|)
expr_stmt|;
name|val
operator|=
operator|(
name|FT_Fixed
operator|)
name|hi
expr_stmt|;
return|return
name|s
operator|<
literal|0
condition|?
operator|-
name|val
else|:
name|val
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* !FT_LONG64 */
end_comment
begin_comment
comment|/* undefined and never called for zero vector */
end_comment
begin_function
specifier|static
name|FT_Int
DECL|function|ft_trig_prenorm
name|ft_trig_prenorm
parameter_list|(
name|FT_Vector
modifier|*
name|vec
parameter_list|)
block|{
name|FT_Pos
name|x
decl_stmt|,
name|y
decl_stmt|;
name|FT_Int
name|shift
decl_stmt|;
name|x
operator|=
name|vec
operator|->
name|x
expr_stmt|;
name|y
operator|=
name|vec
operator|->
name|y
expr_stmt|;
name|shift
operator|=
name|FT_MSB
argument_list|(
name|FT_ABS
argument_list|(
name|x
argument_list|)
operator||
name|FT_ABS
argument_list|(
name|y
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|shift
operator|<=
name|FT_TRIG_SAFE_MSB
condition|)
block|{
name|shift
operator|=
name|FT_TRIG_SAFE_MSB
operator|-
name|shift
expr_stmt|;
name|vec
operator|->
name|x
operator|=
call|(
name|FT_Pos
call|)
argument_list|(
operator|(
name|FT_ULong
operator|)
name|x
operator|<<
name|shift
argument_list|)
expr_stmt|;
name|vec
operator|->
name|y
operator|=
call|(
name|FT_Pos
call|)
argument_list|(
operator|(
name|FT_ULong
operator|)
name|y
operator|<<
name|shift
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|shift
operator|-=
name|FT_TRIG_SAFE_MSB
expr_stmt|;
name|vec
operator|->
name|x
operator|=
name|x
operator|>>
name|shift
expr_stmt|;
name|vec
operator|->
name|y
operator|=
name|y
operator|>>
name|shift
expr_stmt|;
name|shift
operator|=
operator|-
name|shift
expr_stmt|;
block|}
return|return
name|shift
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|ft_trig_pseudo_rotate
name|ft_trig_pseudo_rotate
parameter_list|(
name|FT_Vector
modifier|*
name|vec
parameter_list|,
name|FT_Angle
name|theta
parameter_list|)
block|{
name|FT_Int
name|i
decl_stmt|;
name|FT_Fixed
name|x
decl_stmt|,
name|y
decl_stmt|,
name|xtemp
decl_stmt|,
name|b
decl_stmt|;
specifier|const
name|FT_Angle
modifier|*
name|arctanptr
decl_stmt|;
name|x
operator|=
name|vec
operator|->
name|x
expr_stmt|;
name|y
operator|=
name|vec
operator|->
name|y
expr_stmt|;
comment|/* Rotate inside [-PI/4,PI/4] sector */
while|while
condition|(
name|theta
operator|<
operator|-
name|FT_ANGLE_PI4
condition|)
block|{
name|xtemp
operator|=
name|y
expr_stmt|;
name|y
operator|=
operator|-
name|x
expr_stmt|;
name|x
operator|=
name|xtemp
expr_stmt|;
name|theta
operator|+=
name|FT_ANGLE_PI2
expr_stmt|;
block|}
while|while
condition|(
name|theta
operator|>
name|FT_ANGLE_PI4
condition|)
block|{
name|xtemp
operator|=
operator|-
name|y
expr_stmt|;
name|y
operator|=
name|x
expr_stmt|;
name|x
operator|=
name|xtemp
expr_stmt|;
name|theta
operator|-=
name|FT_ANGLE_PI2
expr_stmt|;
block|}
name|arctanptr
operator|=
name|ft_trig_arctan_table
expr_stmt|;
comment|/* Pseudorotations, with right shifts */
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|b
operator|=
literal|1
init|;
name|i
operator|<
name|FT_TRIG_MAX_ITERS
condition|;
name|b
operator|<<=
literal|1
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|theta
operator|<
literal|0
condition|)
block|{
name|xtemp
operator|=
name|x
operator|+
operator|(
operator|(
name|y
operator|+
name|b
operator|)
operator|>>
name|i
operator|)
expr_stmt|;
name|y
operator|=
name|y
operator|-
operator|(
operator|(
name|x
operator|+
name|b
operator|)
operator|>>
name|i
operator|)
expr_stmt|;
name|x
operator|=
name|xtemp
expr_stmt|;
name|theta
operator|+=
operator|*
name|arctanptr
operator|++
expr_stmt|;
block|}
else|else
block|{
name|xtemp
operator|=
name|x
operator|-
operator|(
operator|(
name|y
operator|+
name|b
operator|)
operator|>>
name|i
operator|)
expr_stmt|;
name|y
operator|=
name|y
operator|+
operator|(
operator|(
name|x
operator|+
name|b
operator|)
operator|>>
name|i
operator|)
expr_stmt|;
name|x
operator|=
name|xtemp
expr_stmt|;
name|theta
operator|-=
operator|*
name|arctanptr
operator|++
expr_stmt|;
block|}
block|}
name|vec
operator|->
name|x
operator|=
name|x
expr_stmt|;
name|vec
operator|->
name|y
operator|=
name|y
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|ft_trig_pseudo_polarize
name|ft_trig_pseudo_polarize
parameter_list|(
name|FT_Vector
modifier|*
name|vec
parameter_list|)
block|{
name|FT_Angle
name|theta
decl_stmt|;
name|FT_Int
name|i
decl_stmt|;
name|FT_Fixed
name|x
decl_stmt|,
name|y
decl_stmt|,
name|xtemp
decl_stmt|,
name|b
decl_stmt|;
specifier|const
name|FT_Angle
modifier|*
name|arctanptr
decl_stmt|;
name|x
operator|=
name|vec
operator|->
name|x
expr_stmt|;
name|y
operator|=
name|vec
operator|->
name|y
expr_stmt|;
comment|/* Get the vector into [-PI/4,PI/4] sector */
if|if
condition|(
name|y
operator|>
name|x
condition|)
block|{
if|if
condition|(
name|y
operator|>
operator|-
name|x
condition|)
block|{
name|theta
operator|=
name|FT_ANGLE_PI2
expr_stmt|;
name|xtemp
operator|=
name|y
expr_stmt|;
name|y
operator|=
operator|-
name|x
expr_stmt|;
name|x
operator|=
name|xtemp
expr_stmt|;
block|}
else|else
block|{
name|theta
operator|=
name|y
operator|>
literal|0
condition|?
name|FT_ANGLE_PI
else|:
operator|-
name|FT_ANGLE_PI
expr_stmt|;
name|x
operator|=
operator|-
name|x
expr_stmt|;
name|y
operator|=
operator|-
name|y
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|y
operator|<
operator|-
name|x
condition|)
block|{
name|theta
operator|=
operator|-
name|FT_ANGLE_PI2
expr_stmt|;
name|xtemp
operator|=
operator|-
name|y
expr_stmt|;
name|y
operator|=
name|x
expr_stmt|;
name|x
operator|=
name|xtemp
expr_stmt|;
block|}
else|else
block|{
name|theta
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|arctanptr
operator|=
name|ft_trig_arctan_table
expr_stmt|;
comment|/* Pseudorotations, with right shifts */
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|b
operator|=
literal|1
init|;
name|i
operator|<
name|FT_TRIG_MAX_ITERS
condition|;
name|b
operator|<<=
literal|1
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|y
operator|>
literal|0
condition|)
block|{
name|xtemp
operator|=
name|x
operator|+
operator|(
operator|(
name|y
operator|+
name|b
operator|)
operator|>>
name|i
operator|)
expr_stmt|;
name|y
operator|=
name|y
operator|-
operator|(
operator|(
name|x
operator|+
name|b
operator|)
operator|>>
name|i
operator|)
expr_stmt|;
name|x
operator|=
name|xtemp
expr_stmt|;
name|theta
operator|+=
operator|*
name|arctanptr
operator|++
expr_stmt|;
block|}
else|else
block|{
name|xtemp
operator|=
name|x
operator|-
operator|(
operator|(
name|y
operator|+
name|b
operator|)
operator|>>
name|i
operator|)
expr_stmt|;
name|y
operator|=
name|y
operator|+
operator|(
operator|(
name|x
operator|+
name|b
operator|)
operator|>>
name|i
operator|)
expr_stmt|;
name|x
operator|=
name|xtemp
expr_stmt|;
name|theta
operator|-=
operator|*
name|arctanptr
operator|++
expr_stmt|;
block|}
block|}
comment|/* round theta to acknowledge its error that mostly comes */
comment|/* from accumulated rounding errors in the arctan table   */
if|if
condition|(
name|theta
operator|>=
literal|0
condition|)
name|theta
operator|=
name|FT_PAD_ROUND
argument_list|(
name|theta
argument_list|,
literal|16
argument_list|)
expr_stmt|;
else|else
name|theta
operator|=
operator|-
name|FT_PAD_ROUND
argument_list|(
operator|-
name|theta
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|vec
operator|->
name|x
operator|=
name|x
expr_stmt|;
name|vec
operator|->
name|y
operator|=
name|theta
expr_stmt|;
block|}
end_function
begin_comment
comment|/* documentation is in fttrigon.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Fixed
argument_list|)
end_macro
begin_macro
name|FT_Cos
argument_list|(
argument|FT_Angle  angle
argument_list|)
end_macro
begin_block
block|{
name|FT_Vector
name|v
decl_stmt|;
name|v
operator|.
name|x
operator|=
name|FT_TRIG_SCALE
operator|>>
literal|8
expr_stmt|;
name|v
operator|.
name|y
operator|=
literal|0
expr_stmt|;
name|ft_trig_pseudo_rotate
argument_list|(
operator|&
name|v
argument_list|,
name|angle
argument_list|)
expr_stmt|;
return|return
operator|(
name|v
operator|.
name|x
operator|+
literal|0x80L
operator|)
operator|>>
literal|8
return|;
block|}
end_block
begin_comment
comment|/* documentation is in fttrigon.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Fixed
argument_list|)
end_macro
begin_macro
name|FT_Sin
argument_list|(
argument|FT_Angle  angle
argument_list|)
end_macro
begin_block
block|{
return|return
name|FT_Cos
argument_list|(
name|FT_ANGLE_PI2
operator|-
name|angle
argument_list|)
return|;
block|}
end_block
begin_comment
comment|/* documentation is in fttrigon.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Fixed
argument_list|)
end_macro
begin_macro
name|FT_Tan
argument_list|(
argument|FT_Angle  angle
argument_list|)
end_macro
begin_block
block|{
name|FT_Vector
name|v
decl_stmt|;
name|v
operator|.
name|x
operator|=
name|FT_TRIG_SCALE
operator|>>
literal|8
expr_stmt|;
name|v
operator|.
name|y
operator|=
literal|0
expr_stmt|;
name|ft_trig_pseudo_rotate
argument_list|(
operator|&
name|v
argument_list|,
name|angle
argument_list|)
expr_stmt|;
return|return
name|FT_DivFix
argument_list|(
name|v
operator|.
name|y
argument_list|,
name|v
operator|.
name|x
argument_list|)
return|;
block|}
end_block
begin_comment
comment|/* documentation is in fttrigon.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Angle
argument_list|)
end_macro
begin_macro
name|FT_Atan2
argument_list|(
argument|FT_Fixed  dx
argument_list|,
argument|FT_Fixed  dy
argument_list|)
end_macro
begin_block
block|{
name|FT_Vector
name|v
decl_stmt|;
if|if
condition|(
name|dx
operator|==
literal|0
operator|&&
name|dy
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|v
operator|.
name|x
operator|=
name|dx
expr_stmt|;
name|v
operator|.
name|y
operator|=
name|dy
expr_stmt|;
name|ft_trig_prenorm
argument_list|(
operator|&
name|v
argument_list|)
expr_stmt|;
name|ft_trig_pseudo_polarize
argument_list|(
operator|&
name|v
argument_list|)
expr_stmt|;
return|return
name|v
operator|.
name|y
return|;
block|}
end_block
begin_comment
comment|/* documentation is in fttrigon.h */
end_comment
begin_macro
name|FT_EXPORT_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|FT_Vector_Unit
name|FT_Vector_Unit
argument_list|(
argument|FT_Vector*  vec
argument_list|,
argument|FT_Angle    angle
argument_list|)
end_macro
begin_block
block|{
if|if
condition|(
operator|!
name|vec
condition|)
return|return;
name|vec
operator|->
name|x
operator|=
name|FT_TRIG_SCALE
operator|>>
literal|8
expr_stmt|;
name|vec
operator|->
name|y
operator|=
literal|0
expr_stmt|;
name|ft_trig_pseudo_rotate
argument_list|(
name|vec
argument_list|,
name|angle
argument_list|)
expr_stmt|;
name|vec
operator|->
name|x
operator|=
operator|(
name|vec
operator|->
name|x
operator|+
literal|0x80L
operator|)
operator|>>
literal|8
expr_stmt|;
name|vec
operator|->
name|y
operator|=
operator|(
name|vec
operator|->
name|y
operator|+
literal|0x80L
operator|)
operator|>>
literal|8
expr_stmt|;
block|}
end_block
begin_comment
comment|/* these macros return 0 for positive numbers,      and -1 for negative ones */
end_comment
begin_define
DECL|macro|FT_SIGN_LONG
define|#
directive|define
name|FT_SIGN_LONG
parameter_list|(
name|x
parameter_list|)
value|( (x)>> ( FT_SIZEOF_LONG * 8 - 1 ) )
end_define
begin_define
DECL|macro|FT_SIGN_INT
define|#
directive|define
name|FT_SIGN_INT
parameter_list|(
name|x
parameter_list|)
value|( (x)>> ( FT_SIZEOF_INT * 8 - 1 ) )
end_define
begin_define
DECL|macro|FT_SIGN_INT32
define|#
directive|define
name|FT_SIGN_INT32
parameter_list|(
name|x
parameter_list|)
value|( (x)>> 31 )
end_define
begin_define
DECL|macro|FT_SIGN_INT16
define|#
directive|define
name|FT_SIGN_INT16
parameter_list|(
name|x
parameter_list|)
value|( (x)>> 15 )
end_define
begin_comment
comment|/* documentation is in fttrigon.h */
end_comment
begin_macro
name|FT_EXPORT_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|FT_Vector_Rotate
name|FT_Vector_Rotate
argument_list|(
argument|FT_Vector*  vec
argument_list|,
argument|FT_Angle    angle
argument_list|)
end_macro
begin_block
block|{
name|FT_Int
name|shift
decl_stmt|;
name|FT_Vector
name|v
decl_stmt|;
if|if
condition|(
operator|!
name|vec
condition|)
return|return;
name|v
operator|.
name|x
operator|=
name|vec
operator|->
name|x
expr_stmt|;
name|v
operator|.
name|y
operator|=
name|vec
operator|->
name|y
expr_stmt|;
if|if
condition|(
name|angle
operator|&&
operator|(
name|v
operator|.
name|x
operator|!=
literal|0
operator|||
name|v
operator|.
name|y
operator|!=
literal|0
operator|)
condition|)
block|{
name|shift
operator|=
name|ft_trig_prenorm
argument_list|(
operator|&
name|v
argument_list|)
expr_stmt|;
name|ft_trig_pseudo_rotate
argument_list|(
operator|&
name|v
argument_list|,
name|angle
argument_list|)
expr_stmt|;
name|v
operator|.
name|x
operator|=
name|ft_trig_downscale
argument_list|(
name|v
operator|.
name|x
argument_list|)
expr_stmt|;
name|v
operator|.
name|y
operator|=
name|ft_trig_downscale
argument_list|(
name|v
operator|.
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|shift
operator|>
literal|0
condition|)
block|{
name|FT_Int32
name|half
init|=
operator|(
name|FT_Int32
operator|)
literal|1L
operator|<<
operator|(
name|shift
operator|-
literal|1
operator|)
decl_stmt|;
name|vec
operator|->
name|x
operator|=
operator|(
name|v
operator|.
name|x
operator|+
name|half
operator|+
name|FT_SIGN_LONG
argument_list|(
name|v
operator|.
name|x
argument_list|)
operator|)
operator|>>
name|shift
expr_stmt|;
name|vec
operator|->
name|y
operator|=
operator|(
name|v
operator|.
name|y
operator|+
name|half
operator|+
name|FT_SIGN_LONG
argument_list|(
name|v
operator|.
name|y
argument_list|)
operator|)
operator|>>
name|shift
expr_stmt|;
block|}
else|else
block|{
name|shift
operator|=
operator|-
name|shift
expr_stmt|;
name|vec
operator|->
name|x
operator|=
call|(
name|FT_Pos
call|)
argument_list|(
operator|(
name|FT_ULong
operator|)
name|v
operator|.
name|x
operator|<<
name|shift
argument_list|)
expr_stmt|;
name|vec
operator|->
name|y
operator|=
call|(
name|FT_Pos
call|)
argument_list|(
operator|(
name|FT_ULong
operator|)
name|v
operator|.
name|y
operator|<<
name|shift
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block
begin_comment
comment|/* documentation is in fttrigon.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Fixed
argument_list|)
end_macro
begin_macro
name|FT_Vector_Length
argument_list|(
argument|FT_Vector*  vec
argument_list|)
end_macro
begin_block
block|{
name|FT_Int
name|shift
decl_stmt|;
name|FT_Vector
name|v
decl_stmt|;
if|if
condition|(
operator|!
name|vec
condition|)
return|return
literal|0
return|;
name|v
operator|=
operator|*
name|vec
expr_stmt|;
comment|/* handle trivial cases */
if|if
condition|(
name|v
operator|.
name|x
operator|==
literal|0
condition|)
block|{
return|return
name|FT_ABS
argument_list|(
name|v
operator|.
name|y
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|v
operator|.
name|y
operator|==
literal|0
condition|)
block|{
return|return
name|FT_ABS
argument_list|(
name|v
operator|.
name|x
argument_list|)
return|;
block|}
comment|/* general case */
name|shift
operator|=
name|ft_trig_prenorm
argument_list|(
operator|&
name|v
argument_list|)
expr_stmt|;
name|ft_trig_pseudo_polarize
argument_list|(
operator|&
name|v
argument_list|)
expr_stmt|;
name|v
operator|.
name|x
operator|=
name|ft_trig_downscale
argument_list|(
name|v
operator|.
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|shift
operator|>
literal|0
condition|)
return|return
operator|(
name|v
operator|.
name|x
operator|+
operator|(
literal|1
operator|<<
operator|(
name|shift
operator|-
literal|1
operator|)
operator|)
operator|)
operator|>>
name|shift
return|;
return|return
call|(
name|FT_Fixed
call|)
argument_list|(
operator|(
name|FT_UInt32
operator|)
name|v
operator|.
name|x
operator|<<
operator|-
name|shift
argument_list|)
return|;
block|}
end_block
begin_comment
comment|/* documentation is in fttrigon.h */
end_comment
begin_macro
name|FT_EXPORT_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|FT_Vector_Polarize
name|FT_Vector_Polarize
argument_list|(
argument|FT_Vector*  vec
argument_list|,
argument|FT_Fixed   *length
argument_list|,
argument|FT_Angle   *angle
argument_list|)
end_macro
begin_block
block|{
name|FT_Int
name|shift
decl_stmt|;
name|FT_Vector
name|v
decl_stmt|;
if|if
condition|(
operator|!
name|vec
operator|||
operator|!
name|length
operator|||
operator|!
name|angle
condition|)
return|return;
name|v
operator|=
operator|*
name|vec
expr_stmt|;
if|if
condition|(
name|v
operator|.
name|x
operator|==
literal|0
operator|&&
name|v
operator|.
name|y
operator|==
literal|0
condition|)
return|return;
name|shift
operator|=
name|ft_trig_prenorm
argument_list|(
operator|&
name|v
argument_list|)
expr_stmt|;
name|ft_trig_pseudo_polarize
argument_list|(
operator|&
name|v
argument_list|)
expr_stmt|;
name|v
operator|.
name|x
operator|=
name|ft_trig_downscale
argument_list|(
name|v
operator|.
name|x
argument_list|)
expr_stmt|;
operator|*
name|length
operator|=
name|shift
operator|>=
literal|0
condition|?
operator|(
name|v
operator|.
name|x
operator|>>
name|shift
operator|)
else|:
call|(
name|FT_Fixed
call|)
argument_list|(
operator|(
name|FT_UInt32
operator|)
name|v
operator|.
name|x
operator|<<
operator|-
name|shift
argument_list|)
expr_stmt|;
operator|*
name|angle
operator|=
name|v
operator|.
name|y
expr_stmt|;
block|}
end_block
begin_comment
comment|/* documentation is in fttrigon.h */
end_comment
begin_macro
name|FT_EXPORT_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|FT_Vector_From_Polar
name|FT_Vector_From_Polar
argument_list|(
argument|FT_Vector*  vec
argument_list|,
argument|FT_Fixed    length
argument_list|,
argument|FT_Angle    angle
argument_list|)
end_macro
begin_block
block|{
if|if
condition|(
operator|!
name|vec
condition|)
return|return;
name|vec
operator|->
name|x
operator|=
name|length
expr_stmt|;
name|vec
operator|->
name|y
operator|=
literal|0
expr_stmt|;
name|FT_Vector_Rotate
argument_list|(
name|vec
argument_list|,
name|angle
argument_list|)
expr_stmt|;
block|}
end_block
begin_comment
comment|/* documentation is in fttrigon.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Angle
argument_list|)
end_macro
begin_macro
name|FT_Angle_Diff
argument_list|(
argument|FT_Angle  angle1
argument_list|,
argument|FT_Angle  angle2
argument_list|)
end_macro
begin_block
block|{
name|FT_Angle
name|delta
init|=
name|angle2
operator|-
name|angle1
decl_stmt|;
name|delta
operator|%=
name|FT_ANGLE_2PI
expr_stmt|;
if|if
condition|(
name|delta
operator|<
literal|0
condition|)
name|delta
operator|+=
name|FT_ANGLE_2PI
expr_stmt|;
if|if
condition|(
name|delta
operator|>
name|FT_ANGLE_PI
condition|)
name|delta
operator|-=
name|FT_ANGLE_2PI
expr_stmt|;
return|return
name|delta
return|;
block|}
end_block
begin_comment
comment|/* END */
end_comment
end_unit
