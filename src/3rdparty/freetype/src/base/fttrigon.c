begin_unit
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  fttrigon.c                                                             */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*    FreeType trigonometric functions (body).                             */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  Copyright 2001, 2002, 2003, 2004, 2005 by                              */
end_comment
begin_comment
comment|/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  This file is part of the FreeType project, and may only be used,       */
end_comment
begin_comment
comment|/*  modified, and distributed under the terms of the FreeType project      */
end_comment
begin_comment
comment|/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
end_comment
begin_comment
comment|/*  this file you indicate that you have read the license and              */
end_comment
begin_comment
comment|/*  understand and accept it fully.                                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<ft2build.h>
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_OBJECTS_H
end_include
begin_include
include|#
directive|include
include|FT_TRIGONOMETRY_H
end_include
begin_comment
comment|/* the following is 0.2715717684432231 * 2^30 */
end_comment
begin_define
DECL|macro|FT_TRIG_COSCALE
define|#
directive|define
name|FT_TRIG_COSCALE
value|0x11616E8EUL
end_define
begin_comment
comment|/* this table was generated for FT_PI = 180L<< 16, i.e. degrees */
end_comment
begin_define
DECL|macro|FT_TRIG_MAX_ITERS
define|#
directive|define
name|FT_TRIG_MAX_ITERS
value|23
end_define
begin_decl_stmt
specifier|static
specifier|const
name|FT_Fixed
DECL|variable|ft_trig_arctan_table
name|ft_trig_arctan_table
index|[
literal|24
index|]
init|=
block|{
literal|4157273L
block|,
literal|2949120L
block|,
literal|1740967L
block|,
literal|919879L
block|,
literal|466945L
block|,
literal|234379L
block|,
literal|117304L
block|,
literal|58666L
block|,
literal|29335L
block|,
literal|14668L
block|,
literal|7334L
block|,
literal|3667L
block|,
literal|1833L
block|,
literal|917L
block|,
literal|458L
block|,
literal|229L
block|,
literal|115L
block|,
literal|57L
block|,
literal|29L
block|,
literal|14L
block|,
literal|7L
block|,
literal|4L
block|,
literal|2L
block|,
literal|1L
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* the Cordic shrink factor, multiplied by 2^32 */
end_comment
begin_define
DECL|macro|FT_TRIG_SCALE
define|#
directive|define
name|FT_TRIG_SCALE
value|1166391785UL
end_define
begin_comment
DECL|macro|FT_TRIG_SCALE
comment|/* 0x4585BA38UL */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|FT_CONFIG_HAS_INT64
end_ifdef
begin_comment
comment|/* multiply a given value by the CORDIC shrink factor */
end_comment
begin_function
specifier|static
name|FT_Fixed
DECL|function|ft_trig_downscale
name|ft_trig_downscale
parameter_list|(
name|FT_Fixed
name|val
parameter_list|)
block|{
name|FT_Fixed
name|s
decl_stmt|;
name|FT_Int64
name|v
decl_stmt|;
name|s
operator|=
name|val
expr_stmt|;
name|val
operator|=
operator|(
name|val
operator|>=
literal|0
operator|)
condition|?
name|val
else|:
operator|-
name|val
expr_stmt|;
name|v
operator|=
operator|(
name|val
operator|*
operator|(
name|FT_Int64
operator|)
name|FT_TRIG_SCALE
operator|)
operator|+
literal|0x100000000UL
expr_stmt|;
name|val
operator|=
call|(
name|FT_Fixed
call|)
argument_list|(
name|v
operator|>>
literal|32
argument_list|)
expr_stmt|;
return|return
operator|(
name|s
operator|>=
literal|0
operator|)
condition|?
name|val
else|:
operator|-
name|val
return|;
block|}
end_function
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* !FT_CONFIG_HAS_INT64 */
end_comment
begin_comment
comment|/* multiply a given value by the CORDIC shrink factor */
end_comment
begin_function
specifier|static
name|FT_Fixed
DECL|function|ft_trig_downscale
name|ft_trig_downscale
parameter_list|(
name|FT_Fixed
name|val
parameter_list|)
block|{
name|FT_Fixed
name|s
decl_stmt|;
name|FT_UInt32
name|v1
decl_stmt|,
name|v2
decl_stmt|,
name|k1
decl_stmt|,
name|k2
decl_stmt|,
name|hi
decl_stmt|,
name|lo1
decl_stmt|,
name|lo2
decl_stmt|,
name|lo3
decl_stmt|;
name|s
operator|=
name|val
expr_stmt|;
name|val
operator|=
operator|(
name|val
operator|>=
literal|0
operator|)
condition|?
name|val
else|:
operator|-
name|val
expr_stmt|;
name|v1
operator|=
operator|(
name|FT_UInt32
operator|)
name|val
operator|>>
literal|16
expr_stmt|;
name|v2
operator|=
call|(
name|FT_UInt32
call|)
argument_list|(
name|val
operator|&
literal|0xFFFFL
argument_list|)
expr_stmt|;
name|k1
operator|=
operator|(
name|FT_UInt32
operator|)
name|FT_TRIG_SCALE
operator|>>
literal|16
expr_stmt|;
comment|/* constant */
name|k2
operator|=
call|(
name|FT_UInt32
call|)
argument_list|(
name|FT_TRIG_SCALE
operator|&
literal|0xFFFFL
argument_list|)
expr_stmt|;
comment|/* constant */
name|hi
operator|=
name|k1
operator|*
name|v1
expr_stmt|;
name|lo1
operator|=
name|k1
operator|*
name|v2
operator|+
name|k2
operator|*
name|v1
expr_stmt|;
comment|/* can't overflow */
name|lo2
operator|=
operator|(
name|k2
operator|*
name|v2
operator|)
operator|>>
literal|16
expr_stmt|;
name|lo3
operator|=
operator|(
name|lo1
operator|>=
name|lo2
operator|)
condition|?
name|lo1
else|:
name|lo2
expr_stmt|;
name|lo1
operator|+=
name|lo2
expr_stmt|;
name|hi
operator|+=
name|lo1
operator|>>
literal|16
expr_stmt|;
if|if
condition|(
name|lo1
operator|<
name|lo3
condition|)
name|hi
operator|+=
operator|(
name|FT_UInt32
operator|)
literal|0x10000UL
expr_stmt|;
name|val
operator|=
operator|(
name|FT_Fixed
operator|)
name|hi
expr_stmt|;
return|return
operator|(
name|s
operator|>=
literal|0
operator|)
condition|?
name|val
else|:
operator|-
name|val
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* !FT_CONFIG_HAS_INT64 */
end_comment
begin_function
specifier|static
name|FT_Int
DECL|function|ft_trig_prenorm
name|ft_trig_prenorm
parameter_list|(
name|FT_Vector
modifier|*
name|vec
parameter_list|)
block|{
name|FT_Fixed
name|x
decl_stmt|,
name|y
decl_stmt|,
name|z
decl_stmt|;
name|FT_Int
name|shift
decl_stmt|;
name|x
operator|=
name|vec
operator|->
name|x
expr_stmt|;
name|y
operator|=
name|vec
operator|->
name|y
expr_stmt|;
name|z
operator|=
operator|(
operator|(
name|x
operator|>=
literal|0
operator|)
condition|?
name|x
else|:
operator|-
name|x
operator|)
operator||
operator|(
operator|(
name|y
operator|>=
literal|0
operator|)
condition|?
name|y
else|:
operator|-
name|y
operator|)
expr_stmt|;
name|shift
operator|=
literal|0
expr_stmt|;
if|#
directive|if
literal|1
comment|/* determine msb bit index in `shift' */
if|if
condition|(
name|z
operator|>=
operator|(
literal|1L
operator|<<
literal|16
operator|)
condition|)
block|{
name|z
operator|>>=
literal|16
expr_stmt|;
name|shift
operator|+=
literal|16
expr_stmt|;
block|}
if|if
condition|(
name|z
operator|>=
operator|(
literal|1L
operator|<<
literal|8
operator|)
condition|)
block|{
name|z
operator|>>=
literal|8
expr_stmt|;
name|shift
operator|+=
literal|8
expr_stmt|;
block|}
if|if
condition|(
name|z
operator|>=
operator|(
literal|1L
operator|<<
literal|4
operator|)
condition|)
block|{
name|z
operator|>>=
literal|4
expr_stmt|;
name|shift
operator|+=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|z
operator|>=
operator|(
literal|1L
operator|<<
literal|2
operator|)
condition|)
block|{
name|z
operator|>>=
literal|2
expr_stmt|;
name|shift
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|z
operator|>=
operator|(
literal|1L
operator|<<
literal|1
operator|)
condition|)
block|{
name|z
operator|>>=
literal|1
expr_stmt|;
name|shift
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|shift
operator|<=
literal|27
condition|)
block|{
name|shift
operator|=
literal|27
operator|-
name|shift
expr_stmt|;
name|vec
operator|->
name|x
operator|=
name|x
operator|<<
name|shift
expr_stmt|;
name|vec
operator|->
name|y
operator|=
name|y
operator|<<
name|shift
expr_stmt|;
block|}
else|else
block|{
name|shift
operator|-=
literal|27
expr_stmt|;
name|vec
operator|->
name|x
operator|=
name|x
operator|>>
name|shift
expr_stmt|;
name|vec
operator|->
name|y
operator|=
name|y
operator|>>
name|shift
expr_stmt|;
name|shift
operator|=
operator|-
name|shift
expr_stmt|;
block|}
else|#
directive|else
comment|/* 0 */
if|if
condition|(
name|z
operator|<
operator|(
literal|1L
operator|<<
literal|27
operator|)
condition|)
block|{
do|do
block|{
name|shift
operator|++
expr_stmt|;
name|z
operator|<<=
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|z
operator|<
operator|(
literal|1L
operator|<<
literal|27
operator|)
condition|)
do|;
name|vec
operator|->
name|x
operator|=
name|x
operator|<<
name|shift
expr_stmt|;
name|vec
operator|->
name|y
operator|=
name|y
operator|<<
name|shift
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|z
operator|>
operator|(
literal|1L
operator|<<
literal|28
operator|)
condition|)
block|{
do|do
block|{
name|shift
operator|++
expr_stmt|;
name|z
operator|>>=
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|z
operator|>
operator|(
literal|1L
operator|<<
literal|28
operator|)
condition|)
do|;
name|vec
operator|->
name|x
operator|=
name|x
operator|>>
name|shift
expr_stmt|;
name|vec
operator|->
name|y
operator|=
name|y
operator|>>
name|shift
expr_stmt|;
name|shift
operator|=
operator|-
name|shift
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 0 */
return|return
name|shift
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|ft_trig_pseudo_rotate
name|ft_trig_pseudo_rotate
parameter_list|(
name|FT_Vector
modifier|*
name|vec
parameter_list|,
name|FT_Angle
name|theta
parameter_list|)
block|{
name|FT_Int
name|i
decl_stmt|;
name|FT_Fixed
name|x
decl_stmt|,
name|y
decl_stmt|,
name|xtemp
decl_stmt|;
specifier|const
name|FT_Fixed
modifier|*
name|arctanptr
decl_stmt|;
name|x
operator|=
name|vec
operator|->
name|x
expr_stmt|;
name|y
operator|=
name|vec
operator|->
name|y
expr_stmt|;
comment|/* Get angle between -90 and 90 degrees */
while|while
condition|(
name|theta
operator|<=
operator|-
name|FT_ANGLE_PI2
condition|)
block|{
name|x
operator|=
operator|-
name|x
expr_stmt|;
name|y
operator|=
operator|-
name|y
expr_stmt|;
name|theta
operator|+=
name|FT_ANGLE_PI
expr_stmt|;
block|}
while|while
condition|(
name|theta
operator|>
name|FT_ANGLE_PI2
condition|)
block|{
name|x
operator|=
operator|-
name|x
expr_stmt|;
name|y
operator|=
operator|-
name|y
expr_stmt|;
name|theta
operator|-=
name|FT_ANGLE_PI
expr_stmt|;
block|}
comment|/* Initial pseudorotation, with left shift */
name|arctanptr
operator|=
name|ft_trig_arctan_table
expr_stmt|;
if|if
condition|(
name|theta
operator|<
literal|0
condition|)
block|{
name|xtemp
operator|=
name|x
operator|+
operator|(
name|y
operator|<<
literal|1
operator|)
expr_stmt|;
name|y
operator|=
name|y
operator|-
operator|(
name|x
operator|<<
literal|1
operator|)
expr_stmt|;
name|x
operator|=
name|xtemp
expr_stmt|;
name|theta
operator|+=
operator|*
name|arctanptr
operator|++
expr_stmt|;
block|}
else|else
block|{
name|xtemp
operator|=
name|x
operator|-
operator|(
name|y
operator|<<
literal|1
operator|)
expr_stmt|;
name|y
operator|=
name|y
operator|+
operator|(
name|x
operator|<<
literal|1
operator|)
expr_stmt|;
name|x
operator|=
name|xtemp
expr_stmt|;
name|theta
operator|-=
operator|*
name|arctanptr
operator|++
expr_stmt|;
block|}
comment|/* Subsequent pseudorotations, with right shifts */
name|i
operator|=
literal|0
expr_stmt|;
do|do
block|{
if|if
condition|(
name|theta
operator|<
literal|0
condition|)
block|{
name|xtemp
operator|=
name|x
operator|+
operator|(
name|y
operator|>>
name|i
operator|)
expr_stmt|;
name|y
operator|=
name|y
operator|-
operator|(
name|x
operator|>>
name|i
operator|)
expr_stmt|;
name|x
operator|=
name|xtemp
expr_stmt|;
name|theta
operator|+=
operator|*
name|arctanptr
operator|++
expr_stmt|;
block|}
else|else
block|{
name|xtemp
operator|=
name|x
operator|-
operator|(
name|y
operator|>>
name|i
operator|)
expr_stmt|;
name|y
operator|=
name|y
operator|+
operator|(
name|x
operator|>>
name|i
operator|)
expr_stmt|;
name|x
operator|=
name|xtemp
expr_stmt|;
name|theta
operator|-=
operator|*
name|arctanptr
operator|++
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|++
name|i
operator|<
name|FT_TRIG_MAX_ITERS
condition|)
do|;
name|vec
operator|->
name|x
operator|=
name|x
expr_stmt|;
name|vec
operator|->
name|y
operator|=
name|y
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|ft_trig_pseudo_polarize
name|ft_trig_pseudo_polarize
parameter_list|(
name|FT_Vector
modifier|*
name|vec
parameter_list|)
block|{
name|FT_Fixed
name|theta
decl_stmt|;
name|FT_Fixed
name|yi
decl_stmt|,
name|i
decl_stmt|;
name|FT_Fixed
name|x
decl_stmt|,
name|y
decl_stmt|;
specifier|const
name|FT_Fixed
modifier|*
name|arctanptr
decl_stmt|;
name|x
operator|=
name|vec
operator|->
name|x
expr_stmt|;
name|y
operator|=
name|vec
operator|->
name|y
expr_stmt|;
comment|/* Get the vector into the right half plane */
name|theta
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|x
operator|<
literal|0
condition|)
block|{
name|x
operator|=
operator|-
name|x
expr_stmt|;
name|y
operator|=
operator|-
name|y
expr_stmt|;
name|theta
operator|=
literal|2
operator|*
name|FT_ANGLE_PI2
expr_stmt|;
block|}
if|if
condition|(
name|y
operator|>
literal|0
condition|)
name|theta
operator|=
operator|-
name|theta
expr_stmt|;
name|arctanptr
operator|=
name|ft_trig_arctan_table
expr_stmt|;
if|if
condition|(
name|y
operator|<
literal|0
condition|)
block|{
comment|/* Rotate positive */
name|yi
operator|=
name|y
operator|+
operator|(
name|x
operator|<<
literal|1
operator|)
expr_stmt|;
name|x
operator|=
name|x
operator|-
operator|(
name|y
operator|<<
literal|1
operator|)
expr_stmt|;
name|y
operator|=
name|yi
expr_stmt|;
name|theta
operator|-=
operator|*
name|arctanptr
operator|++
expr_stmt|;
comment|/* Subtract angle */
block|}
else|else
block|{
comment|/* Rotate negative */
name|yi
operator|=
name|y
operator|-
operator|(
name|x
operator|<<
literal|1
operator|)
expr_stmt|;
name|x
operator|=
name|x
operator|+
operator|(
name|y
operator|<<
literal|1
operator|)
expr_stmt|;
name|y
operator|=
name|yi
expr_stmt|;
name|theta
operator|+=
operator|*
name|arctanptr
operator|++
expr_stmt|;
comment|/* Add angle */
block|}
name|i
operator|=
literal|0
expr_stmt|;
do|do
block|{
if|if
condition|(
name|y
operator|<
literal|0
condition|)
block|{
comment|/* Rotate positive */
name|yi
operator|=
name|y
operator|+
operator|(
name|x
operator|>>
name|i
operator|)
expr_stmt|;
name|x
operator|=
name|x
operator|-
operator|(
name|y
operator|>>
name|i
operator|)
expr_stmt|;
name|y
operator|=
name|yi
expr_stmt|;
name|theta
operator|-=
operator|*
name|arctanptr
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* Rotate negative */
name|yi
operator|=
name|y
operator|-
operator|(
name|x
operator|>>
name|i
operator|)
expr_stmt|;
name|x
operator|=
name|x
operator|+
operator|(
name|y
operator|>>
name|i
operator|)
expr_stmt|;
name|y
operator|=
name|yi
expr_stmt|;
name|theta
operator|+=
operator|*
name|arctanptr
operator|++
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|++
name|i
operator|<
name|FT_TRIG_MAX_ITERS
condition|)
do|;
comment|/* round theta */
if|if
condition|(
name|theta
operator|>=
literal|0
condition|)
name|theta
operator|=
name|FT_PAD_ROUND
argument_list|(
name|theta
argument_list|,
literal|32
argument_list|)
expr_stmt|;
else|else
name|theta
operator|=
operator|-
name|FT_PAD_ROUND
argument_list|(
operator|-
name|theta
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|vec
operator|->
name|x
operator|=
name|x
expr_stmt|;
name|vec
operator|->
name|y
operator|=
name|theta
expr_stmt|;
block|}
end_function
begin_comment
comment|/* documentation is in fttrigon.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Fixed
argument_list|)
end_macro
begin_macro
name|FT_Cos
argument_list|(
argument|FT_Angle  angle
argument_list|)
end_macro
begin_block
block|{
name|FT_Vector
name|v
decl_stmt|;
name|v
operator|.
name|x
operator|=
name|FT_TRIG_COSCALE
operator|>>
literal|2
expr_stmt|;
name|v
operator|.
name|y
operator|=
literal|0
expr_stmt|;
name|ft_trig_pseudo_rotate
argument_list|(
operator|&
name|v
argument_list|,
name|angle
argument_list|)
expr_stmt|;
return|return
name|v
operator|.
name|x
operator|/
operator|(
literal|1
operator|<<
literal|12
operator|)
return|;
block|}
end_block
begin_comment
comment|/* documentation is in fttrigon.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Fixed
argument_list|)
end_macro
begin_macro
name|FT_Sin
argument_list|(
argument|FT_Angle  angle
argument_list|)
end_macro
begin_block
block|{
return|return
name|FT_Cos
argument_list|(
name|FT_ANGLE_PI2
operator|-
name|angle
argument_list|)
return|;
block|}
end_block
begin_comment
comment|/* documentation is in fttrigon.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Fixed
argument_list|)
end_macro
begin_macro
name|FT_Tan
argument_list|(
argument|FT_Angle  angle
argument_list|)
end_macro
begin_block
block|{
name|FT_Vector
name|v
decl_stmt|;
name|v
operator|.
name|x
operator|=
name|FT_TRIG_COSCALE
operator|>>
literal|2
expr_stmt|;
name|v
operator|.
name|y
operator|=
literal|0
expr_stmt|;
name|ft_trig_pseudo_rotate
argument_list|(
operator|&
name|v
argument_list|,
name|angle
argument_list|)
expr_stmt|;
return|return
name|FT_DivFix
argument_list|(
name|v
operator|.
name|y
argument_list|,
name|v
operator|.
name|x
argument_list|)
return|;
block|}
end_block
begin_comment
comment|/* documentation is in fttrigon.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Angle
argument_list|)
end_macro
begin_macro
name|FT_Atan2
argument_list|(
argument|FT_Fixed  dx
argument_list|,
argument|FT_Fixed  dy
argument_list|)
end_macro
begin_block
block|{
name|FT_Vector
name|v
decl_stmt|;
if|if
condition|(
name|dx
operator|==
literal|0
operator|&&
name|dy
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|v
operator|.
name|x
operator|=
name|dx
expr_stmt|;
name|v
operator|.
name|y
operator|=
name|dy
expr_stmt|;
name|ft_trig_prenorm
argument_list|(
operator|&
name|v
argument_list|)
expr_stmt|;
name|ft_trig_pseudo_polarize
argument_list|(
operator|&
name|v
argument_list|)
expr_stmt|;
return|return
name|v
operator|.
name|y
return|;
block|}
end_block
begin_comment
comment|/* documentation is in fttrigon.h */
end_comment
begin_macro
name|FT_EXPORT_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|FT_Vector_Unit
name|FT_Vector_Unit
argument_list|(
argument|FT_Vector*  vec
argument_list|,
argument|FT_Angle    angle
argument_list|)
end_macro
begin_block
block|{
name|vec
operator|->
name|x
operator|=
name|FT_TRIG_COSCALE
operator|>>
literal|2
expr_stmt|;
name|vec
operator|->
name|y
operator|=
literal|0
expr_stmt|;
name|ft_trig_pseudo_rotate
argument_list|(
name|vec
argument_list|,
name|angle
argument_list|)
expr_stmt|;
name|vec
operator|->
name|x
operator|>>=
literal|12
expr_stmt|;
name|vec
operator|->
name|y
operator|>>=
literal|12
expr_stmt|;
block|}
end_block
begin_comment
comment|/* these macros return 0 for positive numbers,      and -1 for negative ones */
end_comment
begin_define
DECL|macro|FT_SIGN_LONG
define|#
directive|define
name|FT_SIGN_LONG
parameter_list|(
name|x
parameter_list|)
value|( (x)>> ( FT_SIZEOF_LONG * 8 - 1 ) )
end_define
begin_define
DECL|macro|FT_SIGN_INT
define|#
directive|define
name|FT_SIGN_INT
parameter_list|(
name|x
parameter_list|)
value|( (x)>> ( FT_SIZEOF_INT * 8 - 1 ) )
end_define
begin_define
DECL|macro|FT_SIGN_INT32
define|#
directive|define
name|FT_SIGN_INT32
parameter_list|(
name|x
parameter_list|)
value|( (x)>> 31 )
end_define
begin_define
DECL|macro|FT_SIGN_INT16
define|#
directive|define
name|FT_SIGN_INT16
parameter_list|(
name|x
parameter_list|)
value|( (x)>> 15 )
end_define
begin_comment
comment|/* documentation is in fttrigon.h */
end_comment
begin_macro
name|FT_EXPORT_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|FT_Vector_Rotate
name|FT_Vector_Rotate
argument_list|(
argument|FT_Vector*  vec
argument_list|,
argument|FT_Angle    angle
argument_list|)
end_macro
begin_block
block|{
name|FT_Int
name|shift
decl_stmt|;
name|FT_Vector
name|v
decl_stmt|;
name|v
operator|.
name|x
operator|=
name|vec
operator|->
name|x
expr_stmt|;
name|v
operator|.
name|y
operator|=
name|vec
operator|->
name|y
expr_stmt|;
if|if
condition|(
name|angle
operator|&&
operator|(
name|v
operator|.
name|x
operator|!=
literal|0
operator|||
name|v
operator|.
name|y
operator|!=
literal|0
operator|)
condition|)
block|{
name|shift
operator|=
name|ft_trig_prenorm
argument_list|(
operator|&
name|v
argument_list|)
expr_stmt|;
name|ft_trig_pseudo_rotate
argument_list|(
operator|&
name|v
argument_list|,
name|angle
argument_list|)
expr_stmt|;
name|v
operator|.
name|x
operator|=
name|ft_trig_downscale
argument_list|(
name|v
operator|.
name|x
argument_list|)
expr_stmt|;
name|v
operator|.
name|y
operator|=
name|ft_trig_downscale
argument_list|(
name|v
operator|.
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|shift
operator|>
literal|0
condition|)
block|{
name|FT_Int32
name|half
init|=
operator|(
name|FT_Int32
operator|)
literal|1L
operator|<<
operator|(
name|shift
operator|-
literal|1
operator|)
decl_stmt|;
name|vec
operator|->
name|x
operator|=
operator|(
name|v
operator|.
name|x
operator|+
name|half
operator|+
name|FT_SIGN_LONG
argument_list|(
name|v
operator|.
name|x
argument_list|)
operator|)
operator|>>
name|shift
expr_stmt|;
name|vec
operator|->
name|y
operator|=
operator|(
name|v
operator|.
name|y
operator|+
name|half
operator|+
name|FT_SIGN_LONG
argument_list|(
name|v
operator|.
name|y
argument_list|)
operator|)
operator|>>
name|shift
expr_stmt|;
block|}
else|else
block|{
name|shift
operator|=
operator|-
name|shift
expr_stmt|;
name|vec
operator|->
name|x
operator|=
name|v
operator|.
name|x
operator|<<
name|shift
expr_stmt|;
name|vec
operator|->
name|y
operator|=
name|v
operator|.
name|y
operator|<<
name|shift
expr_stmt|;
block|}
block|}
block|}
end_block
begin_comment
comment|/* documentation is in fttrigon.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Fixed
argument_list|)
end_macro
begin_macro
name|FT_Vector_Length
argument_list|(
argument|FT_Vector*  vec
argument_list|)
end_macro
begin_block
block|{
name|FT_Int
name|shift
decl_stmt|;
name|FT_Vector
name|v
decl_stmt|;
name|v
operator|=
operator|*
name|vec
expr_stmt|;
comment|/* handle trivial cases */
if|if
condition|(
name|v
operator|.
name|x
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|v
operator|.
name|y
operator|>=
literal|0
operator|)
condition|?
name|v
operator|.
name|y
else|:
operator|-
name|v
operator|.
name|y
return|;
block|}
elseif|else
if|if
condition|(
name|v
operator|.
name|y
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|v
operator|.
name|x
operator|>=
literal|0
operator|)
condition|?
name|v
operator|.
name|x
else|:
operator|-
name|v
operator|.
name|x
return|;
block|}
comment|/* general case */
name|shift
operator|=
name|ft_trig_prenorm
argument_list|(
operator|&
name|v
argument_list|)
expr_stmt|;
name|ft_trig_pseudo_polarize
argument_list|(
operator|&
name|v
argument_list|)
expr_stmt|;
name|v
operator|.
name|x
operator|=
name|ft_trig_downscale
argument_list|(
name|v
operator|.
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|shift
operator|>
literal|0
condition|)
return|return
operator|(
name|v
operator|.
name|x
operator|+
operator|(
literal|1
operator|<<
operator|(
name|shift
operator|-
literal|1
operator|)
operator|)
operator|)
operator|>>
name|shift
return|;
return|return
name|v
operator|.
name|x
operator|<<
operator|-
name|shift
return|;
block|}
end_block
begin_comment
comment|/* documentation is in fttrigon.h */
end_comment
begin_macro
name|FT_EXPORT_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|FT_Vector_Polarize
name|FT_Vector_Polarize
argument_list|(
argument|FT_Vector*  vec
argument_list|,
argument|FT_Fixed   *length
argument_list|,
argument|FT_Angle   *angle
argument_list|)
end_macro
begin_block
block|{
name|FT_Int
name|shift
decl_stmt|;
name|FT_Vector
name|v
decl_stmt|;
name|v
operator|=
operator|*
name|vec
expr_stmt|;
if|if
condition|(
name|v
operator|.
name|x
operator|==
literal|0
operator|&&
name|v
operator|.
name|y
operator|==
literal|0
condition|)
return|return;
name|shift
operator|=
name|ft_trig_prenorm
argument_list|(
operator|&
name|v
argument_list|)
expr_stmt|;
name|ft_trig_pseudo_polarize
argument_list|(
operator|&
name|v
argument_list|)
expr_stmt|;
name|v
operator|.
name|x
operator|=
name|ft_trig_downscale
argument_list|(
name|v
operator|.
name|x
argument_list|)
expr_stmt|;
operator|*
name|length
operator|=
operator|(
name|shift
operator|>=
literal|0
operator|)
condition|?
operator|(
name|v
operator|.
name|x
operator|>>
name|shift
operator|)
else|:
operator|(
name|v
operator|.
name|x
operator|<<
operator|-
name|shift
operator|)
expr_stmt|;
operator|*
name|angle
operator|=
name|v
operator|.
name|y
expr_stmt|;
block|}
end_block
begin_comment
comment|/* documentation is in fttrigon.h */
end_comment
begin_macro
name|FT_EXPORT_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|FT_Vector_From_Polar
name|FT_Vector_From_Polar
argument_list|(
argument|FT_Vector*  vec
argument_list|,
argument|FT_Fixed    length
argument_list|,
argument|FT_Angle    angle
argument_list|)
end_macro
begin_block
block|{
name|vec
operator|->
name|x
operator|=
name|length
expr_stmt|;
name|vec
operator|->
name|y
operator|=
literal|0
expr_stmt|;
name|FT_Vector_Rotate
argument_list|(
name|vec
argument_list|,
name|angle
argument_list|)
expr_stmt|;
block|}
end_block
begin_comment
comment|/* documentation is in fttrigon.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Angle
argument_list|)
end_macro
begin_macro
name|FT_Angle_Diff
argument_list|(
argument|FT_Angle  angle1
argument_list|,
argument|FT_Angle  angle2
argument_list|)
end_macro
begin_block
block|{
name|FT_Angle
name|delta
init|=
name|angle2
operator|-
name|angle1
decl_stmt|;
name|delta
operator|%=
name|FT_ANGLE_2PI
expr_stmt|;
if|if
condition|(
name|delta
operator|<
literal|0
condition|)
name|delta
operator|+=
name|FT_ANGLE_2PI
expr_stmt|;
if|if
condition|(
name|delta
operator|>
name|FT_ANGLE_PI
condition|)
name|delta
operator|-=
name|FT_ANGLE_2PI
expr_stmt|;
return|return
name|delta
return|;
block|}
end_block
begin_comment
comment|/* END */
end_comment
end_unit
