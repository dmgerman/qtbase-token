begin_unit
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  ftglyph.c                                                              */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*    FreeType convenience functions to handle glyphs (body).              */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2007, 2008 by             */
end_comment
begin_comment
comment|/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  This file is part of the FreeType project, and may only be used,       */
end_comment
begin_comment
comment|/*  modified, and distributed under the terms of the FreeType project      */
end_comment
begin_comment
comment|/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
end_comment
begin_comment
comment|/*  this file you indicate that you have read the license and              */
end_comment
begin_comment
comment|/*  understand and accept it fully.                                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*  This file contains the definition of several convenience functions   */
end_comment
begin_comment
comment|/*  that can be used by client applications to easily retrieve glyph     */
end_comment
begin_comment
comment|/*  bitmaps and outlines from a given face.                              */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*  These functions should be optional if you are writing a font server  */
end_comment
begin_comment
comment|/*  or text layout engine on top of FreeType.  However, they are pretty  */
end_comment
begin_comment
comment|/*  handy for many other simple uses of the library.                     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<ft2build.h>
end_include
begin_include
include|#
directive|include
include|FT_GLYPH_H
end_include
begin_include
include|#
directive|include
include|FT_OUTLINE_H
end_include
begin_include
include|#
directive|include
include|FT_BITMAP_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_OBJECTS_H
end_include
begin_include
include|#
directive|include
file|"basepic.h"
end_include
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
end_comment
begin_comment
comment|/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
end_comment
begin_comment
comment|/* messages during execution.                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_undef
DECL|macro|FT_COMPONENT
undef|#
directive|undef
name|FT_COMPONENT
end_undef
begin_define
DECL|macro|FT_COMPONENT
define|#
directive|define
name|FT_COMPONENT
value|trace_glyph
end_define
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/****                                                                 ****/
end_comment
begin_comment
comment|/****   FT_BitmapGlyph support                                        ****/
end_comment
begin_comment
comment|/****                                                                 ****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|ft_bitmap_glyph_init
argument_list|(
argument|FT_Glyph      bitmap_glyph
argument_list|,
argument|FT_GlyphSlot  slot
argument_list|)
end_macro
begin_block
block|{
name|FT_BitmapGlyph
name|glyph
init|=
operator|(
name|FT_BitmapGlyph
operator|)
name|bitmap_glyph
decl_stmt|;
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
name|FT_Library
name|library
init|=
name|FT_GLYPH
argument_list|(
name|glyph
argument_list|)
operator|->
name|library
decl_stmt|;
if|if
condition|(
name|slot
operator|->
name|format
operator|!=
name|FT_GLYPH_FORMAT_BITMAP
condition|)
block|{
name|error
operator|=
name|FT_Err_Invalid_Glyph_Format
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|glyph
operator|->
name|left
operator|=
name|slot
operator|->
name|bitmap_left
expr_stmt|;
name|glyph
operator|->
name|top
operator|=
name|slot
operator|->
name|bitmap_top
expr_stmt|;
comment|/* do lazy copying whenever possible */
if|if
condition|(
name|slot
operator|->
name|internal
operator|->
name|flags
operator|&
name|FT_GLYPH_OWN_BITMAP
condition|)
block|{
name|glyph
operator|->
name|bitmap
operator|=
name|slot
operator|->
name|bitmap
expr_stmt|;
name|slot
operator|->
name|internal
operator|->
name|flags
operator|&=
operator|~
name|FT_GLYPH_OWN_BITMAP
expr_stmt|;
block|}
else|else
block|{
name|FT_Bitmap_New
argument_list|(
operator|&
name|glyph
operator|->
name|bitmap
argument_list|)
expr_stmt|;
name|error
operator|=
name|FT_Bitmap_Copy
argument_list|(
name|library
argument_list|,
operator|&
name|slot
operator|->
name|bitmap
argument_list|,
operator|&
name|glyph
operator|->
name|bitmap
argument_list|)
expr_stmt|;
block|}
name|Exit
label|:
return|return
name|error
return|;
block|}
end_block
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|ft_bitmap_glyph_copy
argument_list|(
argument|FT_Glyph  bitmap_source
argument_list|,
argument|FT_Glyph  bitmap_target
argument_list|)
end_macro
begin_block
block|{
name|FT_Library
name|library
init|=
name|bitmap_source
operator|->
name|library
decl_stmt|;
name|FT_BitmapGlyph
name|source
init|=
operator|(
name|FT_BitmapGlyph
operator|)
name|bitmap_source
decl_stmt|;
name|FT_BitmapGlyph
name|target
init|=
operator|(
name|FT_BitmapGlyph
operator|)
name|bitmap_target
decl_stmt|;
name|target
operator|->
name|left
operator|=
name|source
operator|->
name|left
expr_stmt|;
name|target
operator|->
name|top
operator|=
name|source
operator|->
name|top
expr_stmt|;
return|return
name|FT_Bitmap_Copy
argument_list|(
name|library
argument_list|,
operator|&
name|source
operator|->
name|bitmap
argument_list|,
operator|&
name|target
operator|->
name|bitmap
argument_list|)
return|;
block|}
end_block
begin_macro
name|FT_CALLBACK_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|ft_bitmap_glyph_done
name|ft_bitmap_glyph_done
argument_list|(
argument|FT_Glyph  bitmap_glyph
argument_list|)
end_macro
begin_block
block|{
name|FT_BitmapGlyph
name|glyph
init|=
operator|(
name|FT_BitmapGlyph
operator|)
name|bitmap_glyph
decl_stmt|;
name|FT_Library
name|library
init|=
name|FT_GLYPH
argument_list|(
name|glyph
argument_list|)
operator|->
name|library
decl_stmt|;
name|FT_Bitmap_Done
argument_list|(
name|library
argument_list|,
operator|&
name|glyph
operator|->
name|bitmap
argument_list|)
expr_stmt|;
block|}
end_block
begin_macro
name|FT_CALLBACK_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|ft_bitmap_glyph_bbox
name|ft_bitmap_glyph_bbox
argument_list|(
argument|FT_Glyph  bitmap_glyph
argument_list|,
argument|FT_BBox*  cbox
argument_list|)
end_macro
begin_block
block|{
name|FT_BitmapGlyph
name|glyph
init|=
operator|(
name|FT_BitmapGlyph
operator|)
name|bitmap_glyph
decl_stmt|;
name|cbox
operator|->
name|xMin
operator|=
name|glyph
operator|->
name|left
operator|<<
literal|6
expr_stmt|;
name|cbox
operator|->
name|xMax
operator|=
name|cbox
operator|->
name|xMin
operator|+
operator|(
name|glyph
operator|->
name|bitmap
operator|.
name|width
operator|<<
literal|6
operator|)
expr_stmt|;
name|cbox
operator|->
name|yMax
operator|=
name|glyph
operator|->
name|top
operator|<<
literal|6
expr_stmt|;
name|cbox
operator|->
name|yMin
operator|=
name|cbox
operator|->
name|yMax
operator|-
operator|(
name|glyph
operator|->
name|bitmap
operator|.
name|rows
operator|<<
literal|6
operator|)
expr_stmt|;
block|}
end_block
begin_macro
name|FT_DEFINE_GLYPH
argument_list|(
argument|ft_bitmap_glyph_class
argument_list|,
argument|sizeof ( FT_BitmapGlyphRec )
argument_list|,
argument|FT_GLYPH_FORMAT_BITMAP
argument_list|,
argument|ft_bitmap_glyph_init
argument_list|,
argument|ft_bitmap_glyph_done
argument_list|,
argument|ft_bitmap_glyph_copy
argument_list|,
literal|0
argument_list|,
comment|/* FT_Glyph_TransformFunc */
argument|ft_bitmap_glyph_bbox
argument_list|,
literal|0
comment|/* FT_Glyph_PrepareFunc   */
argument_list|)
end_macro
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/****                                                                 ****/
end_comment
begin_comment
comment|/****   FT_OutlineGlyph support                                       ****/
end_comment
begin_comment
comment|/****                                                                 ****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|ft_outline_glyph_init
argument_list|(
argument|FT_Glyph      outline_glyph
argument_list|,
argument|FT_GlyphSlot  slot
argument_list|)
end_macro
begin_block
block|{
name|FT_OutlineGlyph
name|glyph
init|=
operator|(
name|FT_OutlineGlyph
operator|)
name|outline_glyph
decl_stmt|;
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
name|FT_Library
name|library
init|=
name|FT_GLYPH
argument_list|(
name|glyph
argument_list|)
operator|->
name|library
decl_stmt|;
name|FT_Outline
modifier|*
name|source
init|=
operator|&
name|slot
operator|->
name|outline
decl_stmt|;
name|FT_Outline
modifier|*
name|target
init|=
operator|&
name|glyph
operator|->
name|outline
decl_stmt|;
comment|/* check format in glyph slot */
if|if
condition|(
name|slot
operator|->
name|format
operator|!=
name|FT_GLYPH_FORMAT_OUTLINE
condition|)
block|{
name|error
operator|=
name|FT_Err_Invalid_Glyph_Format
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* allocate new outline */
name|error
operator|=
name|FT_Outline_New
argument_list|(
name|library
argument_list|,
name|source
operator|->
name|n_points
argument_list|,
name|source
operator|->
name|n_contours
argument_list|,
operator|&
name|glyph
operator|->
name|outline
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|FT_Outline_Copy
argument_list|(
name|source
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|Exit
label|:
return|return
name|error
return|;
block|}
end_block
begin_macro
name|FT_CALLBACK_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|ft_outline_glyph_done
name|ft_outline_glyph_done
argument_list|(
argument|FT_Glyph  outline_glyph
argument_list|)
end_macro
begin_block
block|{
name|FT_OutlineGlyph
name|glyph
init|=
operator|(
name|FT_OutlineGlyph
operator|)
name|outline_glyph
decl_stmt|;
name|FT_Outline_Done
argument_list|(
name|FT_GLYPH
argument_list|(
name|glyph
argument_list|)
operator|->
name|library
argument_list|,
operator|&
name|glyph
operator|->
name|outline
argument_list|)
expr_stmt|;
block|}
end_block
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|ft_outline_glyph_copy
argument_list|(
argument|FT_Glyph  outline_source
argument_list|,
argument|FT_Glyph  outline_target
argument_list|)
end_macro
begin_block
block|{
name|FT_OutlineGlyph
name|source
init|=
operator|(
name|FT_OutlineGlyph
operator|)
name|outline_source
decl_stmt|;
name|FT_OutlineGlyph
name|target
init|=
operator|(
name|FT_OutlineGlyph
operator|)
name|outline_target
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|FT_Library
name|library
init|=
name|FT_GLYPH
argument_list|(
name|source
argument_list|)
operator|->
name|library
decl_stmt|;
name|error
operator|=
name|FT_Outline_New
argument_list|(
name|library
argument_list|,
name|source
operator|->
name|outline
operator|.
name|n_points
argument_list|,
name|source
operator|->
name|outline
operator|.
name|n_contours
argument_list|,
operator|&
name|target
operator|->
name|outline
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|FT_Outline_Copy
argument_list|(
operator|&
name|source
operator|->
name|outline
argument_list|,
operator|&
name|target
operator|->
name|outline
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_block
begin_macro
name|FT_CALLBACK_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|ft_outline_glyph_transform
name|ft_outline_glyph_transform
argument_list|(
argument|FT_Glyph          outline_glyph
argument_list|,
argument|const FT_Matrix*  matrix
argument_list|,
argument|const FT_Vector*  delta
argument_list|)
end_macro
begin_block
block|{
name|FT_OutlineGlyph
name|glyph
init|=
operator|(
name|FT_OutlineGlyph
operator|)
name|outline_glyph
decl_stmt|;
if|if
condition|(
name|matrix
condition|)
name|FT_Outline_Transform
argument_list|(
operator|&
name|glyph
operator|->
name|outline
argument_list|,
name|matrix
argument_list|)
expr_stmt|;
if|if
condition|(
name|delta
condition|)
name|FT_Outline_Translate
argument_list|(
operator|&
name|glyph
operator|->
name|outline
argument_list|,
name|delta
operator|->
name|x
argument_list|,
name|delta
operator|->
name|y
argument_list|)
expr_stmt|;
block|}
end_block
begin_macro
name|FT_CALLBACK_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|ft_outline_glyph_bbox
name|ft_outline_glyph_bbox
argument_list|(
argument|FT_Glyph  outline_glyph
argument_list|,
argument|FT_BBox*  bbox
argument_list|)
end_macro
begin_block
block|{
name|FT_OutlineGlyph
name|glyph
init|=
operator|(
name|FT_OutlineGlyph
operator|)
name|outline_glyph
decl_stmt|;
name|FT_Outline_Get_CBox
argument_list|(
operator|&
name|glyph
operator|->
name|outline
argument_list|,
name|bbox
argument_list|)
expr_stmt|;
block|}
end_block
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|ft_outline_glyph_prepare
argument_list|(
argument|FT_Glyph      outline_glyph
argument_list|,
argument|FT_GlyphSlot  slot
argument_list|)
end_macro
begin_block
block|{
name|FT_OutlineGlyph
name|glyph
init|=
operator|(
name|FT_OutlineGlyph
operator|)
name|outline_glyph
decl_stmt|;
name|slot
operator|->
name|format
operator|=
name|FT_GLYPH_FORMAT_OUTLINE
expr_stmt|;
name|slot
operator|->
name|outline
operator|=
name|glyph
operator|->
name|outline
expr_stmt|;
name|slot
operator|->
name|outline
operator|.
name|flags
operator|&=
operator|~
name|FT_OUTLINE_OWNER
expr_stmt|;
return|return
name|FT_Err_Ok
return|;
block|}
end_block
begin_macro
name|FT_DEFINE_GLYPH
argument_list|(
argument|ft_outline_glyph_class
argument_list|,
argument|sizeof ( FT_OutlineGlyphRec )
argument_list|,
argument|FT_GLYPH_FORMAT_OUTLINE
argument_list|,
argument|ft_outline_glyph_init
argument_list|,
argument|ft_outline_glyph_done
argument_list|,
argument|ft_outline_glyph_copy
argument_list|,
argument|ft_outline_glyph_transform
argument_list|,
argument|ft_outline_glyph_bbox
argument_list|,
argument|ft_outline_glyph_prepare
argument_list|)
end_macro
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/****                                                                 ****/
end_comment
begin_comment
comment|/****   FT_Glyph class and API                                        ****/
end_comment
begin_comment
comment|/****                                                                 ****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|ft_new_glyph
name|ft_new_glyph
parameter_list|(
name|FT_Library
name|library
parameter_list|,
specifier|const
name|FT_Glyph_Class
modifier|*
name|clazz
parameter_list|,
name|FT_Glyph
modifier|*
name|aglyph
parameter_list|)
block|{
name|FT_Memory
name|memory
init|=
name|library
operator|->
name|memory
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|FT_Glyph
name|glyph
decl_stmt|;
operator|*
name|aglyph
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|FT_ALLOC
argument_list|(
name|glyph
argument_list|,
name|clazz
operator|->
name|glyph_size
argument_list|)
condition|)
block|{
name|glyph
operator|->
name|library
operator|=
name|library
expr_stmt|;
name|glyph
operator|->
name|clazz
operator|=
name|clazz
expr_stmt|;
name|glyph
operator|->
name|format
operator|=
name|clazz
operator|->
name|glyph_format
expr_stmt|;
operator|*
name|aglyph
operator|=
name|glyph
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function
begin_comment
comment|/* documentation is in ftglyph.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_Glyph_Copy
argument_list|(
argument|FT_Glyph   source
argument_list|,
argument|FT_Glyph  *target
argument_list|)
end_macro
begin_block
block|{
name|FT_Glyph
name|copy
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
specifier|const
name|FT_Glyph_Class
modifier|*
name|clazz
decl_stmt|;
comment|/* check arguments */
if|if
condition|(
operator|!
name|target
condition|)
block|{
name|error
operator|=
name|FT_Err_Invalid_Argument
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
operator|*
name|target
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|source
operator|||
operator|!
name|source
operator|->
name|clazz
condition|)
block|{
name|error
operator|=
name|FT_Err_Invalid_Argument
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|clazz
operator|=
name|source
operator|->
name|clazz
expr_stmt|;
name|error
operator|=
name|ft_new_glyph
argument_list|(
name|source
operator|->
name|library
argument_list|,
name|clazz
argument_list|,
operator|&
name|copy
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|copy
operator|->
name|advance
operator|=
name|source
operator|->
name|advance
expr_stmt|;
name|copy
operator|->
name|format
operator|=
name|source
operator|->
name|format
expr_stmt|;
if|if
condition|(
name|clazz
operator|->
name|glyph_copy
condition|)
name|error
operator|=
name|clazz
operator|->
name|glyph_copy
argument_list|(
name|source
argument_list|,
name|copy
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|FT_Done_Glyph
argument_list|(
name|copy
argument_list|)
expr_stmt|;
else|else
operator|*
name|target
operator|=
name|copy
expr_stmt|;
name|Exit
label|:
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/* documentation is in ftglyph.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_Get_Glyph
argument_list|(
argument|FT_GlyphSlot  slot
argument_list|,
argument|FT_Glyph     *aglyph
argument_list|)
end_macro
begin_block
block|{
name|FT_Library
name|library
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|FT_Glyph
name|glyph
decl_stmt|;
specifier|const
name|FT_Glyph_Class
modifier|*
name|clazz
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|slot
condition|)
return|return
name|FT_Err_Invalid_Slot_Handle
return|;
name|library
operator|=
name|slot
operator|->
name|library
expr_stmt|;
if|if
condition|(
operator|!
name|aglyph
condition|)
return|return
name|FT_Err_Invalid_Argument
return|;
comment|/* if it is a bitmap, that's easy :-) */
if|if
condition|(
name|slot
operator|->
name|format
operator|==
name|FT_GLYPH_FORMAT_BITMAP
condition|)
name|clazz
operator|=
name|FT_BITMAP_GLYPH_CLASS_GET
expr_stmt|;
comment|/* if it is an outline */
elseif|else
if|if
condition|(
name|slot
operator|->
name|format
operator|==
name|FT_GLYPH_FORMAT_OUTLINE
condition|)
name|clazz
operator|=
name|FT_OUTLINE_GLYPH_CLASS_GET
expr_stmt|;
else|else
block|{
comment|/* try to find a renderer that supports the glyph image format */
name|FT_Renderer
name|render
init|=
name|FT_Lookup_Renderer
argument_list|(
name|library
argument_list|,
name|slot
operator|->
name|format
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|render
condition|)
name|clazz
operator|=
operator|&
name|render
operator|->
name|glyph_class
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|clazz
condition|)
block|{
name|error
operator|=
name|FT_Err_Invalid_Glyph_Format
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* create FT_Glyph object */
name|error
operator|=
name|ft_new_glyph
argument_list|(
name|library
argument_list|,
name|clazz
argument_list|,
operator|&
name|glyph
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
comment|/* copy advance while converting it to 16.16 format */
name|glyph
operator|->
name|advance
operator|.
name|x
operator|=
name|slot
operator|->
name|advance
operator|.
name|x
operator|<<
literal|10
expr_stmt|;
name|glyph
operator|->
name|advance
operator|.
name|y
operator|=
name|slot
operator|->
name|advance
operator|.
name|y
operator|<<
literal|10
expr_stmt|;
comment|/* now import the image from the glyph slot */
name|error
operator|=
name|clazz
operator|->
name|glyph_init
argument_list|(
name|glyph
argument_list|,
name|slot
argument_list|)
expr_stmt|;
comment|/* if an error occurred, destroy the glyph */
if|if
condition|(
name|error
condition|)
name|FT_Done_Glyph
argument_list|(
name|glyph
argument_list|)
expr_stmt|;
else|else
operator|*
name|aglyph
operator|=
name|glyph
expr_stmt|;
name|Exit
label|:
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/* documentation is in ftglyph.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_Glyph_Transform
argument_list|(
argument|FT_Glyph    glyph
argument_list|,
argument|FT_Matrix*  matrix
argument_list|,
argument|FT_Vector*  delta
argument_list|)
end_macro
begin_block
block|{
specifier|const
name|FT_Glyph_Class
modifier|*
name|clazz
decl_stmt|;
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
if|if
condition|(
operator|!
name|glyph
operator|||
operator|!
name|glyph
operator|->
name|clazz
condition|)
name|error
operator|=
name|FT_Err_Invalid_Argument
expr_stmt|;
else|else
block|{
name|clazz
operator|=
name|glyph
operator|->
name|clazz
expr_stmt|;
if|if
condition|(
name|clazz
operator|->
name|glyph_transform
condition|)
block|{
comment|/* transform glyph image */
name|clazz
operator|->
name|glyph_transform
argument_list|(
name|glyph
argument_list|,
name|matrix
argument_list|,
name|delta
argument_list|)
expr_stmt|;
comment|/* transform advance vector */
if|if
condition|(
name|matrix
condition|)
name|FT_Vector_Transform
argument_list|(
operator|&
name|glyph
operator|->
name|advance
argument_list|,
name|matrix
argument_list|)
expr_stmt|;
block|}
else|else
name|error
operator|=
name|FT_Err_Invalid_Glyph_Format
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/* documentation is in ftglyph.h */
end_comment
begin_macro
name|FT_EXPORT_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|FT_Glyph_Get_CBox
name|FT_Glyph_Get_CBox
argument_list|(
argument|FT_Glyph  glyph
argument_list|,
argument|FT_UInt   bbox_mode
argument_list|,
argument|FT_BBox  *acbox
argument_list|)
end_macro
begin_block
block|{
specifier|const
name|FT_Glyph_Class
modifier|*
name|clazz
decl_stmt|;
if|if
condition|(
operator|!
name|acbox
condition|)
return|return;
name|acbox
operator|->
name|xMin
operator|=
name|acbox
operator|->
name|yMin
operator|=
name|acbox
operator|->
name|xMax
operator|=
name|acbox
operator|->
name|yMax
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|glyph
operator|||
operator|!
name|glyph
operator|->
name|clazz
condition|)
return|return;
else|else
block|{
name|clazz
operator|=
name|glyph
operator|->
name|clazz
expr_stmt|;
if|if
condition|(
operator|!
name|clazz
operator|->
name|glyph_bbox
condition|)
return|return;
else|else
block|{
comment|/* retrieve bbox in 26.6 coordinates */
name|clazz
operator|->
name|glyph_bbox
argument_list|(
name|glyph
argument_list|,
name|acbox
argument_list|)
expr_stmt|;
comment|/* perform grid fitting if needed */
if|if
condition|(
name|bbox_mode
operator|==
name|FT_GLYPH_BBOX_GRIDFIT
operator|||
name|bbox_mode
operator|==
name|FT_GLYPH_BBOX_PIXELS
condition|)
block|{
name|acbox
operator|->
name|xMin
operator|=
name|FT_PIX_FLOOR
argument_list|(
name|acbox
operator|->
name|xMin
argument_list|)
expr_stmt|;
name|acbox
operator|->
name|yMin
operator|=
name|FT_PIX_FLOOR
argument_list|(
name|acbox
operator|->
name|yMin
argument_list|)
expr_stmt|;
name|acbox
operator|->
name|xMax
operator|=
name|FT_PIX_CEIL
argument_list|(
name|acbox
operator|->
name|xMax
argument_list|)
expr_stmt|;
name|acbox
operator|->
name|yMax
operator|=
name|FT_PIX_CEIL
argument_list|(
name|acbox
operator|->
name|yMax
argument_list|)
expr_stmt|;
block|}
comment|/* convert to integer pixels if needed */
if|if
condition|(
name|bbox_mode
operator|==
name|FT_GLYPH_BBOX_TRUNCATE
operator|||
name|bbox_mode
operator|==
name|FT_GLYPH_BBOX_PIXELS
condition|)
block|{
name|acbox
operator|->
name|xMin
operator|>>=
literal|6
expr_stmt|;
name|acbox
operator|->
name|yMin
operator|>>=
literal|6
expr_stmt|;
name|acbox
operator|->
name|xMax
operator|>>=
literal|6
expr_stmt|;
name|acbox
operator|->
name|yMax
operator|>>=
literal|6
expr_stmt|;
block|}
block|}
block|}
return|return;
block|}
end_block
begin_comment
comment|/* documentation is in ftglyph.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_Glyph_To_Bitmap
argument_list|(
argument|FT_Glyph*       the_glyph
argument_list|,
argument|FT_Render_Mode  render_mode
argument_list|,
argument|FT_Vector*      origin
argument_list|,
argument|FT_Bool         destroy
argument_list|)
end_macro
begin_block
block|{
name|FT_GlyphSlotRec
name|dummy
decl_stmt|;
name|FT_GlyphSlot_InternalRec
name|dummy_internal
decl_stmt|;
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
name|FT_Glyph
name|glyph
decl_stmt|;
name|FT_BitmapGlyph
name|bitmap
init|=
name|NULL
decl_stmt|;
specifier|const
name|FT_Glyph_Class
modifier|*
name|clazz
decl_stmt|;
ifdef|#
directive|ifdef
name|FT_CONFIG_OPTION_PIC
name|FT_Library
name|library
init|=
name|FT_GLYPH
argument_list|(
name|glyph
argument_list|)
operator|->
name|library
decl_stmt|;
endif|#
directive|endif
comment|/* check argument */
if|if
condition|(
operator|!
name|the_glyph
condition|)
goto|goto
name|Bad
goto|;
comment|/* we render the glyph into a glyph bitmap using a `dummy' glyph slot */
comment|/* then calling FT_Render_Glyph_Internal()                            */
name|glyph
operator|=
operator|*
name|the_glyph
expr_stmt|;
if|if
condition|(
operator|!
name|glyph
condition|)
goto|goto
name|Bad
goto|;
name|clazz
operator|=
name|glyph
operator|->
name|clazz
expr_stmt|;
comment|/* when called with a bitmap glyph, do nothing and return successfully */
if|if
condition|(
name|clazz
operator|==
name|FT_BITMAP_GLYPH_CLASS_GET
condition|)
goto|goto
name|Exit
goto|;
if|if
condition|(
operator|!
name|clazz
operator|||
operator|!
name|clazz
operator|->
name|glyph_prepare
condition|)
goto|goto
name|Bad
goto|;
name|FT_MEM_ZERO
argument_list|(
operator|&
name|dummy
argument_list|,
sizeof|sizeof
argument_list|(
name|dummy
argument_list|)
argument_list|)
expr_stmt|;
name|FT_MEM_ZERO
argument_list|(
operator|&
name|dummy_internal
argument_list|,
sizeof|sizeof
argument_list|(
name|dummy_internal
argument_list|)
argument_list|)
expr_stmt|;
name|dummy
operator|.
name|internal
operator|=
operator|&
name|dummy_internal
expr_stmt|;
name|dummy
operator|.
name|library
operator|=
name|glyph
operator|->
name|library
expr_stmt|;
name|dummy
operator|.
name|format
operator|=
name|clazz
operator|->
name|glyph_format
expr_stmt|;
comment|/* create result bitmap glyph */
name|error
operator|=
name|ft_new_glyph
argument_list|(
name|glyph
operator|->
name|library
argument_list|,
name|FT_BITMAP_GLYPH_CLASS_GET
argument_list|,
operator|(
name|FT_Glyph
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
operator|&
name|bitmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
if|#
directive|if
literal|1
comment|/* if `origin' is set, translate the glyph image */
if|if
condition|(
name|origin
condition|)
name|FT_Glyph_Transform
argument_list|(
name|glyph
argument_list|,
literal|0
argument_list|,
name|origin
argument_list|)
expr_stmt|;
else|#
directive|else
name|FT_UNUSED
argument_list|(
name|origin
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* prepare dummy slot for rendering */
name|error
operator|=
name|clazz
operator|->
name|glyph_prepare
argument_list|(
name|glyph
argument_list|,
operator|&
name|dummy
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|FT_Render_Glyph_Internal
argument_list|(
name|glyph
operator|->
name|library
argument_list|,
operator|&
name|dummy
argument_list|,
name|render_mode
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
if|if
condition|(
operator|!
name|destroy
operator|&&
name|origin
condition|)
block|{
name|FT_Vector
name|v
decl_stmt|;
name|v
operator|.
name|x
operator|=
operator|-
name|origin
operator|->
name|x
expr_stmt|;
name|v
operator|.
name|y
operator|=
operator|-
name|origin
operator|->
name|y
expr_stmt|;
name|FT_Glyph_Transform
argument_list|(
name|glyph
argument_list|,
literal|0
argument_list|,
operator|&
name|v
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
comment|/* in case of success, copy the bitmap to the glyph bitmap */
name|error
operator|=
name|ft_bitmap_glyph_init
argument_list|(
operator|(
name|FT_Glyph
operator|)
name|bitmap
argument_list|,
operator|&
name|dummy
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
comment|/* copy advance */
name|bitmap
operator|->
name|root
operator|.
name|advance
operator|=
name|glyph
operator|->
name|advance
expr_stmt|;
if|if
condition|(
name|destroy
condition|)
name|FT_Done_Glyph
argument_list|(
name|glyph
argument_list|)
expr_stmt|;
operator|*
name|the_glyph
operator|=
name|FT_GLYPH
argument_list|(
name|bitmap
argument_list|)
expr_stmt|;
name|Exit
label|:
if|if
condition|(
name|error
operator|&&
name|bitmap
condition|)
name|FT_Done_Glyph
argument_list|(
name|FT_GLYPH
argument_list|(
name|bitmap
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error
return|;
name|Bad
label|:
name|error
operator|=
name|FT_Err_Invalid_Argument
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
end_block
begin_comment
comment|/* documentation is in ftglyph.h */
end_comment
begin_macro
name|FT_EXPORT_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|FT_Done_Glyph
name|FT_Done_Glyph
argument_list|(
argument|FT_Glyph  glyph
argument_list|)
end_macro
begin_block
block|{
if|if
condition|(
name|glyph
condition|)
block|{
name|FT_Memory
name|memory
init|=
name|glyph
operator|->
name|library
operator|->
name|memory
decl_stmt|;
specifier|const
name|FT_Glyph_Class
modifier|*
name|clazz
init|=
name|glyph
operator|->
name|clazz
decl_stmt|;
if|if
condition|(
name|clazz
operator|->
name|glyph_done
condition|)
name|clazz
operator|->
name|glyph_done
argument_list|(
name|glyph
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|glyph
argument_list|)
expr_stmt|;
block|}
block|}
end_block
begin_comment
comment|/* END */
end_comment
end_unit
