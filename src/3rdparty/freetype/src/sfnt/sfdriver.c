begin_unit
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  sfdriver.c                                                             */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*    High-level SFNT driver interface (body).                             */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2009 by       */
end_comment
begin_comment
comment|/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  This file is part of the FreeType project, and may only be used,       */
end_comment
begin_comment
comment|/*  modified, and distributed under the terms of the FreeType project      */
end_comment
begin_comment
comment|/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
end_comment
begin_comment
comment|/*  this file you indicate that you have read the license and              */
end_comment
begin_comment
comment|/*  understand and accept it fully.                                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<ft2build.h>
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_SFNT_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_OBJECTS_H
end_include
begin_include
include|#
directive|include
file|"sfdriver.h"
end_include
begin_include
include|#
directive|include
file|"ttload.h"
end_include
begin_include
include|#
directive|include
file|"sfobjs.h"
end_include
begin_include
include|#
directive|include
file|"sferrors.h"
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_EMBEDDED_BITMAPS
end_ifdef
begin_include
include|#
directive|include
file|"ttsbit.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_POSTSCRIPT_NAMES
end_ifdef
begin_include
include|#
directive|include
file|"ttpost.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_BDF
end_ifdef
begin_include
include|#
directive|include
file|"ttbdf.h"
end_include
begin_include
include|#
directive|include
include|FT_SERVICE_BDF_H
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|"ttcmap.h"
end_include
begin_include
include|#
directive|include
file|"ttkern.h"
end_include
begin_include
include|#
directive|include
file|"ttmtx.h"
end_include
begin_include
include|#
directive|include
include|FT_SERVICE_GLYPH_DICT_H
end_include
begin_include
include|#
directive|include
include|FT_SERVICE_POSTSCRIPT_NAME_H
end_include
begin_include
include|#
directive|include
include|FT_SERVICE_SFNT_H
end_include
begin_include
include|#
directive|include
include|FT_SERVICE_TT_CMAP_H
end_include
begin_comment
comment|/*   *  SFNT TABLE SERVICE   *   */
end_comment
begin_function
specifier|static
name|void
modifier|*
DECL|function|get_sfnt_table
name|get_sfnt_table
parameter_list|(
name|TT_Face
name|face
parameter_list|,
name|FT_Sfnt_Tag
name|tag
parameter_list|)
block|{
name|void
modifier|*
name|table
decl_stmt|;
switch|switch
condition|(
name|tag
condition|)
block|{
case|case
name|ft_sfnt_head
case|:
name|table
operator|=
operator|&
name|face
operator|->
name|header
expr_stmt|;
break|break;
case|case
name|ft_sfnt_hhea
case|:
name|table
operator|=
operator|&
name|face
operator|->
name|horizontal
expr_stmt|;
break|break;
case|case
name|ft_sfnt_vhea
case|:
name|table
operator|=
name|face
operator|->
name|vertical_info
condition|?
operator|&
name|face
operator|->
name|vertical
else|:
literal|0
expr_stmt|;
break|break;
case|case
name|ft_sfnt_os2
case|:
name|table
operator|=
name|face
operator|->
name|os2
operator|.
name|version
operator|==
literal|0xFFFFU
condition|?
literal|0
else|:
operator|&
name|face
operator|->
name|os2
expr_stmt|;
break|break;
case|case
name|ft_sfnt_post
case|:
name|table
operator|=
operator|&
name|face
operator|->
name|postscript
expr_stmt|;
break|break;
case|case
name|ft_sfnt_maxp
case|:
name|table
operator|=
operator|&
name|face
operator|->
name|max_profile
expr_stmt|;
break|break;
case|case
name|ft_sfnt_pclt
case|:
name|table
operator|=
name|face
operator|->
name|pclt
operator|.
name|Version
condition|?
operator|&
name|face
operator|->
name|pclt
else|:
literal|0
expr_stmt|;
break|break;
default|default:
name|table
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|table
return|;
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|sfnt_table_info
name|sfnt_table_info
parameter_list|(
name|TT_Face
name|face
parameter_list|,
name|FT_UInt
name|idx
parameter_list|,
name|FT_ULong
modifier|*
name|tag
parameter_list|,
name|FT_ULong
modifier|*
name|length
parameter_list|)
block|{
if|if
condition|(
operator|!
name|tag
operator|||
operator|!
name|length
condition|)
return|return
name|SFNT_Err_Invalid_Argument
return|;
if|if
condition|(
name|idx
operator|>=
name|face
operator|->
name|num_tables
condition|)
return|return
name|SFNT_Err_Table_Missing
return|;
operator|*
name|tag
operator|=
name|face
operator|->
name|dir_tables
index|[
name|idx
index|]
operator|.
name|Tag
expr_stmt|;
operator|*
name|length
operator|=
name|face
operator|->
name|dir_tables
index|[
name|idx
index|]
operator|.
name|Length
expr_stmt|;
return|return
name|SFNT_Err_Ok
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|sfnt_service_sfnt_table
specifier|static
specifier|const
name|FT_Service_SFNT_TableRec
name|sfnt_service_sfnt_table
init|=
block|{
operator|(
name|FT_SFNT_TableLoadFunc
operator|)
name|tt_face_load_any
block|,
operator|(
name|FT_SFNT_TableGetFunc
operator|)
name|get_sfnt_table
block|,
operator|(
name|FT_SFNT_TableInfoFunc
operator|)
name|sfnt_table_info
block|}
decl_stmt|;
end_decl_stmt
begin_ifdef
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_POSTSCRIPT_NAMES
end_ifdef
begin_comment
comment|/*   *  GLYPH DICT SERVICE   *   */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|sfnt_get_glyph_name
name|sfnt_get_glyph_name
parameter_list|(
name|TT_Face
name|face
parameter_list|,
name|FT_UInt
name|glyph_index
parameter_list|,
name|FT_Pointer
name|buffer
parameter_list|,
name|FT_UInt
name|buffer_max
parameter_list|)
block|{
name|FT_String
modifier|*
name|gname
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|error
operator|=
name|tt_face_get_ps_name
argument_list|(
name|face
argument_list|,
name|glyph_index
argument_list|,
operator|&
name|gname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|FT_STRCPYN
argument_list|(
name|buffer
argument_list|,
name|gname
argument_list|,
name|buffer_max
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_function
specifier|static
name|FT_UInt
DECL|function|sfnt_get_name_index
name|sfnt_get_name_index
parameter_list|(
name|TT_Face
name|face
parameter_list|,
name|FT_String
modifier|*
name|glyph_name
parameter_list|)
block|{
name|FT_Face
name|root
init|=
operator|&
name|face
operator|->
name|root
decl_stmt|;
name|FT_Long
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|root
operator|->
name|num_glyphs
condition|;
name|i
operator|++
control|)
block|{
name|FT_String
modifier|*
name|gname
decl_stmt|;
name|FT_Error
name|error
init|=
name|tt_face_get_ps_name
argument_list|(
name|face
argument_list|,
name|i
argument_list|,
operator|&
name|gname
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
condition|)
continue|continue;
if|if
condition|(
operator|!
name|ft_strcmp
argument_list|(
name|glyph_name
argument_list|,
name|gname
argument_list|)
condition|)
return|return
operator|(
name|FT_UInt
operator|)
name|i
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|sfnt_service_glyph_dict
specifier|static
specifier|const
name|FT_Service_GlyphDictRec
name|sfnt_service_glyph_dict
init|=
block|{
operator|(
name|FT_GlyphDict_GetNameFunc
operator|)
name|sfnt_get_glyph_name
block|,
operator|(
name|FT_GlyphDict_NameIndexFunc
operator|)
name|sfnt_get_name_index
block|}
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* TT_CONFIG_OPTION_POSTSCRIPT_NAMES */
end_comment
begin_comment
comment|/*   *  POSTSCRIPT NAME SERVICE   *   */
end_comment
begin_function
specifier|static
specifier|const
name|char
modifier|*
DECL|function|sfnt_get_ps_name
name|sfnt_get_ps_name
parameter_list|(
name|TT_Face
name|face
parameter_list|)
block|{
name|FT_Int
name|n
decl_stmt|,
name|found_win
decl_stmt|,
name|found_apple
decl_stmt|;
specifier|const
name|char
modifier|*
name|result
init|=
name|NULL
decl_stmt|;
comment|/* shouldn't happen, but just in case to avoid memory leaks */
if|if
condition|(
name|face
operator|->
name|postscript_name
condition|)
return|return
name|face
operator|->
name|postscript_name
return|;
comment|/* scan the name table to see whether we have a Postscript name here, */
comment|/* either in Macintosh or Windows platform encodings                  */
name|found_win
operator|=
operator|-
literal|1
expr_stmt|;
name|found_apple
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|face
operator|->
name|num_names
condition|;
name|n
operator|++
control|)
block|{
name|TT_NameEntryRec
modifier|*
name|name
init|=
name|face
operator|->
name|name_table
operator|.
name|names
operator|+
name|n
decl_stmt|;
if|if
condition|(
name|name
operator|->
name|nameID
operator|==
literal|6
operator|&&
name|name
operator|->
name|stringLength
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|name
operator|->
name|platformID
operator|==
literal|3
operator|&&
name|name
operator|->
name|encodingID
operator|==
literal|1
operator|&&
name|name
operator|->
name|languageID
operator|==
literal|0x409
condition|)
name|found_win
operator|=
name|n
expr_stmt|;
if|if
condition|(
name|name
operator|->
name|platformID
operator|==
literal|1
operator|&&
name|name
operator|->
name|encodingID
operator|==
literal|0
operator|&&
name|name
operator|->
name|languageID
operator|==
literal|0
condition|)
name|found_apple
operator|=
name|n
expr_stmt|;
block|}
block|}
if|if
condition|(
name|found_win
operator|!=
operator|-
literal|1
condition|)
block|{
name|FT_Memory
name|memory
init|=
name|face
operator|->
name|root
operator|.
name|memory
decl_stmt|;
name|TT_NameEntryRec
modifier|*
name|name
init|=
name|face
operator|->
name|name_table
operator|.
name|names
operator|+
name|found_win
decl_stmt|;
name|FT_UInt
name|len
init|=
name|name
operator|->
name|stringLength
operator|/
literal|2
decl_stmt|;
name|FT_Error
name|error
init|=
name|SFNT_Err_Ok
decl_stmt|;
name|FT_UNUSED
argument_list|(
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|FT_ALLOC
argument_list|(
name|result
argument_list|,
name|name
operator|->
name|stringLength
operator|+
literal|1
argument_list|)
condition|)
block|{
name|FT_Stream
name|stream
init|=
name|face
operator|->
name|name_table
operator|.
name|stream
decl_stmt|;
name|FT_String
modifier|*
name|r
init|=
operator|(
name|FT_String
operator|*
operator|)
name|result
decl_stmt|;
name|FT_Byte
modifier|*
name|p
init|=
operator|(
name|FT_Byte
operator|*
operator|)
name|name
operator|->
name|string
decl_stmt|;
if|if
condition|(
name|FT_STREAM_SEEK
argument_list|(
name|name
operator|->
name|stringOffset
argument_list|)
operator|||
name|FT_FRAME_ENTER
argument_list|(
name|name
operator|->
name|stringLength
argument_list|)
condition|)
block|{
name|FT_FREE
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|name
operator|->
name|stringLength
operator|=
literal|0
expr_stmt|;
name|name
operator|->
name|stringOffset
operator|=
literal|0
expr_stmt|;
name|FT_FREE
argument_list|(
name|name
operator|->
name|string
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|p
operator|=
operator|(
name|FT_Byte
operator|*
operator|)
name|stream
operator|->
name|cursor
expr_stmt|;
for|for
control|(
init|;
name|len
operator|>
literal|0
condition|;
name|len
operator|--
operator|,
name|p
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|0
operator|&&
name|p
index|[
literal|1
index|]
operator|>=
literal|32
operator|&&
name|p
index|[
literal|1
index|]
operator|<
literal|128
condition|)
operator|*
name|r
operator|++
operator|=
name|p
index|[
literal|1
index|]
expr_stmt|;
block|}
operator|*
name|r
operator|=
literal|'\0'
expr_stmt|;
name|FT_FRAME_EXIT
argument_list|()
expr_stmt|;
block|}
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|found_apple
operator|!=
operator|-
literal|1
condition|)
block|{
name|FT_Memory
name|memory
init|=
name|face
operator|->
name|root
operator|.
name|memory
decl_stmt|;
name|TT_NameEntryRec
modifier|*
name|name
init|=
name|face
operator|->
name|name_table
operator|.
name|names
operator|+
name|found_apple
decl_stmt|;
name|FT_UInt
name|len
init|=
name|name
operator|->
name|stringLength
decl_stmt|;
name|FT_Error
name|error
init|=
name|SFNT_Err_Ok
decl_stmt|;
name|FT_UNUSED
argument_list|(
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|FT_ALLOC
argument_list|(
name|result
argument_list|,
name|len
operator|+
literal|1
argument_list|)
condition|)
block|{
name|FT_Stream
name|stream
init|=
name|face
operator|->
name|name_table
operator|.
name|stream
decl_stmt|;
if|if
condition|(
name|FT_STREAM_SEEK
argument_list|(
name|name
operator|->
name|stringOffset
argument_list|)
operator|||
name|FT_STREAM_READ
argument_list|(
name|result
argument_list|,
name|len
argument_list|)
condition|)
block|{
name|name
operator|->
name|stringOffset
operator|=
literal|0
expr_stmt|;
name|name
operator|->
name|stringLength
operator|=
literal|0
expr_stmt|;
name|FT_FREE
argument_list|(
name|name
operator|->
name|string
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|result
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
operator|(
operator|(
name|char
operator|*
operator|)
name|result
operator|)
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
name|Exit
label|:
name|face
operator|->
name|postscript_name
operator|=
name|result
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|sfnt_service_ps_name
specifier|static
specifier|const
name|FT_Service_PsFontNameRec
name|sfnt_service_ps_name
init|=
block|{
operator|(
name|FT_PsName_GetFunc
operator|)
name|sfnt_get_ps_name
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*    *  TT CMAP INFO    */
end_comment
begin_decl_stmt
DECL|variable|tt_service_get_cmap_info
specifier|static
specifier|const
name|FT_Service_TTCMapsRec
name|tt_service_get_cmap_info
init|=
block|{
operator|(
name|TT_CMap_Info_GetFunc
operator|)
name|tt_get_cmap_info
block|}
decl_stmt|;
end_decl_stmt
begin_ifdef
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_BDF
end_ifdef
begin_function
specifier|static
name|FT_Error
DECL|function|sfnt_get_charset_id
name|sfnt_get_charset_id
parameter_list|(
name|TT_Face
name|face
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|acharset_encoding
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|acharset_registry
parameter_list|)
block|{
name|BDF_PropertyRec
name|encoding
decl_stmt|,
name|registry
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
comment|/* XXX: I don't know whether this is correct, since      *      tt_face_find_bdf_prop only returns something correct if we have      *      previously selected a size that is listed in the BDF table.      *      Should we change the BDF table format to include single offsets      *      for `CHARSET_REGISTRY' and `CHARSET_ENCODING'?      */
name|error
operator|=
name|tt_face_find_bdf_prop
argument_list|(
name|face
argument_list|,
literal|"CHARSET_REGISTRY"
argument_list|,
operator|&
name|registry
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|error
operator|=
name|tt_face_find_bdf_prop
argument_list|(
name|face
argument_list|,
literal|"CHARSET_ENCODING"
argument_list|,
operator|&
name|encoding
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
if|if
condition|(
name|registry
operator|.
name|type
operator|==
name|BDF_PROPERTY_TYPE_ATOM
operator|&&
name|encoding
operator|.
name|type
operator|==
name|BDF_PROPERTY_TYPE_ATOM
condition|)
block|{
operator|*
name|acharset_encoding
operator|=
name|encoding
operator|.
name|u
operator|.
name|atom
expr_stmt|;
operator|*
name|acharset_registry
operator|=
name|registry
operator|.
name|u
operator|.
name|atom
expr_stmt|;
block|}
else|else
name|error
operator|=
name|FT_Err_Invalid_Argument
expr_stmt|;
block|}
block|}
return|return
name|error
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|sfnt_service_bdf
specifier|static
specifier|const
name|FT_Service_BDFRec
name|sfnt_service_bdf
init|=
block|{
operator|(
name|FT_BDF_GetCharsetIdFunc
operator|)
name|sfnt_get_charset_id
block|,
operator|(
name|FT_BDF_GetPropertyFunc
operator|)
name|tt_face_find_bdf_prop
block|,   }
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* TT_CONFIG_OPTION_BDF */
end_comment
begin_comment
comment|/*    *  SERVICE LIST    */
end_comment
begin_decl_stmt
DECL|variable|sfnt_services
specifier|static
specifier|const
name|FT_ServiceDescRec
name|sfnt_services
index|[]
init|=
block|{
block|{
name|FT_SERVICE_ID_SFNT_TABLE
block|,
operator|&
name|sfnt_service_sfnt_table
block|}
block|,
block|{
name|FT_SERVICE_ID_POSTSCRIPT_FONT_NAME
block|,
operator|&
name|sfnt_service_ps_name
block|}
block|,
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_POSTSCRIPT_NAMES
block|{
name|FT_SERVICE_ID_GLYPH_DICT
block|,
operator|&
name|sfnt_service_glyph_dict
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_BDF
block|{
name|FT_SERVICE_ID_BDF
block|,
operator|&
name|sfnt_service_bdf
block|}
block|,
endif|#
directive|endif
block|{
name|FT_SERVICE_ID_TT_CMAP
block|,
operator|&
name|tt_service_get_cmap_info
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_Module_Interface
argument_list|)
end_macro
begin_macro
name|sfnt_get_interface
argument_list|(
argument|FT_Module    module
argument_list|,
argument|const char*  module_interface
argument_list|)
end_macro
begin_block
block|{
name|FT_UNUSED
argument_list|(
name|module
argument_list|)
expr_stmt|;
return|return
name|ft_service_list_lookup
argument_list|(
name|sfnt_services
argument_list|,
name|module_interface
argument_list|)
return|;
block|}
end_block
begin_ifdef
ifdef|#
directive|ifdef
name|FT_CONFIG_OPTION_OLD_INTERNALS
end_ifdef
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|tt_face_load_sfnt_header_stub
argument_list|(
argument|TT_Face      face
argument_list|,
argument|FT_Stream    stream
argument_list|,
argument|FT_Long      face_index
argument_list|,
argument|SFNT_Header  header
argument_list|)
end_macro
begin_block
block|{
name|FT_UNUSED
argument_list|(
name|face
argument_list|)
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|face_index
argument_list|)
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|header
argument_list|)
expr_stmt|;
return|return
name|FT_Err_Unimplemented_Feature
return|;
block|}
end_block
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|tt_face_load_directory_stub
argument_list|(
argument|TT_Face      face
argument_list|,
argument|FT_Stream    stream
argument_list|,
argument|SFNT_Header  header
argument_list|)
end_macro
begin_block
block|{
name|FT_UNUSED
argument_list|(
name|face
argument_list|)
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|header
argument_list|)
expr_stmt|;
return|return
name|FT_Err_Unimplemented_Feature
return|;
block|}
end_block
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|tt_face_load_hdmx_stub
argument_list|(
argument|TT_Face    face
argument_list|,
argument|FT_Stream  stream
argument_list|)
end_macro
begin_block
block|{
name|FT_UNUSED
argument_list|(
name|face
argument_list|)
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|stream
argument_list|)
expr_stmt|;
return|return
name|FT_Err_Unimplemented_Feature
return|;
block|}
end_block
begin_macro
name|FT_CALLBACK_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|tt_face_free_hdmx_stub
name|tt_face_free_hdmx_stub
argument_list|(
argument|TT_Face  face
argument_list|)
end_macro
begin_block
block|{
name|FT_UNUSED
argument_list|(
name|face
argument_list|)
expr_stmt|;
block|}
end_block
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|tt_face_set_sbit_strike_stub
argument_list|(
argument|TT_Face    face
argument_list|,
argument|FT_UInt    x_ppem
argument_list|,
argument|FT_UInt    y_ppem
argument_list|,
argument|FT_ULong*  astrike_index
argument_list|)
end_macro
begin_block
block|{
comment|/*      * We simply forge a FT_Size_Request and call the real function      * that does all the work.      *      * This stub might be called by libXfont in the X.Org Xserver,      * compiled against version 2.1.8 or newer.      */
name|FT_Size_RequestRec
name|req
decl_stmt|;
name|req
operator|.
name|type
operator|=
name|FT_SIZE_REQUEST_TYPE_NOMINAL
expr_stmt|;
name|req
operator|.
name|width
operator|=
operator|(
name|FT_F26Dot6
operator|)
name|x_ppem
expr_stmt|;
name|req
operator|.
name|height
operator|=
operator|(
name|FT_F26Dot6
operator|)
name|y_ppem
expr_stmt|;
name|req
operator|.
name|horiResolution
operator|=
literal|0
expr_stmt|;
name|req
operator|.
name|vertResolution
operator|=
literal|0
expr_stmt|;
operator|*
name|astrike_index
operator|=
literal|0x7FFFFFFFUL
expr_stmt|;
return|return
name|tt_face_set_sbit_strike
argument_list|(
name|face
argument_list|,
operator|&
name|req
argument_list|,
name|astrike_index
argument_list|)
return|;
block|}
end_block
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|tt_face_load_sbit_stub
argument_list|(
argument|TT_Face    face
argument_list|,
argument|FT_Stream  stream
argument_list|)
end_macro
begin_block
block|{
name|FT_UNUSED
argument_list|(
name|face
argument_list|)
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|stream
argument_list|)
expr_stmt|;
comment|/*      *  This function was originally implemented to load the sbit table.      *  However, it has been replaced by `tt_face_load_eblc', and this stub      *  is only there for some rogue clients which would want to call it      *  directly (which doesn't make much sense).      */
return|return
name|FT_Err_Unimplemented_Feature
return|;
block|}
end_block
begin_macro
name|FT_CALLBACK_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|tt_face_free_sbit_stub
name|tt_face_free_sbit_stub
argument_list|(
argument|TT_Face  face
argument_list|)
end_macro
begin_block
block|{
comment|/* nothing to do in this stub */
name|FT_UNUSED
argument_list|(
name|face
argument_list|)
expr_stmt|;
block|}
end_block
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|tt_face_load_charmap_stub
argument_list|(
argument|TT_Face    face
argument_list|,
argument|void*      cmap
argument_list|,
argument|FT_Stream  input
argument_list|)
end_macro
begin_block
block|{
name|FT_UNUSED
argument_list|(
name|face
argument_list|)
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|cmap
argument_list|)
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|input
argument_list|)
expr_stmt|;
return|return
name|FT_Err_Unimplemented_Feature
return|;
block|}
end_block
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|tt_face_free_charmap_stub
argument_list|(
argument|TT_Face  face
argument_list|,
argument|void*    cmap
argument_list|)
end_macro
begin_block
block|{
name|FT_UNUSED
argument_list|(
name|face
argument_list|)
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|cmap
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* FT_CONFIG_OPTION_OLD_INTERNALS */
end_comment
begin_decl_stmt
specifier|static
DECL|variable|sfnt_interface
specifier|const
name|SFNT_Interface
name|sfnt_interface
init|=
block|{
name|tt_face_goto_table
block|,
name|sfnt_init_face
block|,
name|sfnt_load_face
block|,
name|sfnt_done_face
block|,
name|sfnt_get_interface
block|,
name|tt_face_load_any
block|,
ifdef|#
directive|ifdef
name|FT_CONFIG_OPTION_OLD_INTERNALS
name|tt_face_load_sfnt_header_stub
block|,
name|tt_face_load_directory_stub
block|,
endif|#
directive|endif
name|tt_face_load_head
block|,
name|tt_face_load_hhea
block|,
name|tt_face_load_cmap
block|,
name|tt_face_load_maxp
block|,
name|tt_face_load_os2
block|,
name|tt_face_load_post
block|,
name|tt_face_load_name
block|,
name|tt_face_free_name
block|,
ifdef|#
directive|ifdef
name|FT_CONFIG_OPTION_OLD_INTERNALS
name|tt_face_load_hdmx_stub
block|,
name|tt_face_free_hdmx_stub
block|,
endif|#
directive|endif
name|tt_face_load_kern
block|,
name|tt_face_load_gasp
block|,
name|tt_face_load_pclt
block|,
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_EMBEDDED_BITMAPS
comment|/* see `ttload.h' */
name|tt_face_load_bhed
block|,
else|#
directive|else
literal|0
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|FT_CONFIG_OPTION_OLD_INTERNALS
name|tt_face_set_sbit_strike_stub
block|,
name|tt_face_load_sbit_stub
block|,
name|tt_find_sbit_image
block|,
name|tt_load_sbit_metrics
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_EMBEDDED_BITMAPS
name|tt_face_load_sbit_image
block|,
else|#
directive|else
literal|0
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|FT_CONFIG_OPTION_OLD_INTERNALS
name|tt_face_free_sbit_stub
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_POSTSCRIPT_NAMES
comment|/* see `ttpost.h' */
name|tt_face_get_ps_name
block|,
name|tt_face_free_ps_names
block|,
else|#
directive|else
literal|0
block|,
literal|0
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|FT_CONFIG_OPTION_OLD_INTERNALS
name|tt_face_load_charmap_stub
block|,
name|tt_face_free_charmap_stub
block|,
endif|#
directive|endif
comment|/* since version 2.1.8 */
name|tt_face_get_kerning
block|,
comment|/* since version 2.2 */
name|tt_face_load_font_dir
block|,
name|tt_face_load_hmtx
block|,
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_EMBEDDED_BITMAPS
comment|/* see `ttsbit.h' and `sfnt.h' */
name|tt_face_load_eblc
block|,
name|tt_face_free_eblc
block|,
name|tt_face_set_sbit_strike
block|,
name|tt_face_load_strike_metrics
block|,
else|#
directive|else
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
endif|#
directive|endif
name|tt_face_get_metrics
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|FT_CALLBACK_TABLE_DEF
DECL|variable|sfnt_module_class
specifier|const
name|FT_Module_Class
name|sfnt_module_class
init|=
block|{
literal|0
block|,
comment|/* not a font driver or renderer */
sizeof|sizeof
argument_list|(
name|FT_ModuleRec
argument_list|)
block|,
literal|"sfnt"
block|,
comment|/* driver name                            */
literal|0x10000L
block|,
comment|/* driver version 1.0                     */
literal|0x20000L
block|,
comment|/* driver requires FreeType 2.0 or higher */
operator|(
specifier|const
name|void
operator|*
operator|)
operator|&
name|sfnt_interface
block|,
comment|/* module specific interface */
operator|(
name|FT_Module_Constructor
operator|)
literal|0
block|,
operator|(
name|FT_Module_Destructor
operator|)
literal|0
block|,
operator|(
name|FT_Module_Requester
operator|)
name|sfnt_get_interface
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* END */
end_comment
end_unit
