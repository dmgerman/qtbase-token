begin_unit
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  ttcmap.c                                                               */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*    TrueType character mapping table (cmap) support (body).              */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  Copyright 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 by            */
end_comment
begin_comment
comment|/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  This file is part of the FreeType project, and may only be used,       */
end_comment
begin_comment
comment|/*  modified, and distributed under the terms of the FreeType project      */
end_comment
begin_comment
comment|/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
end_comment
begin_comment
comment|/*  this file you indicate that you have read the license and              */
end_comment
begin_comment
comment|/*  understand and accept it fully.                                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<ft2build.h>
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_DEBUG_H
end_include
begin_include
include|#
directive|include
file|"sferrors.h"
end_include
begin_comment
comment|/* must come before FT_INTERNAL_VALIDATE_H */
end_comment
begin_include
include|#
directive|include
include|FT_INTERNAL_VALIDATE_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_STREAM_H
end_include
begin_include
include|#
directive|include
file|"ttload.h"
end_include
begin_include
include|#
directive|include
file|"ttcmap.h"
end_include
begin_include
include|#
directive|include
file|"sfntpic.h"
end_include
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
end_comment
begin_comment
comment|/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
end_comment
begin_comment
comment|/* messages during execution.                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_undef
DECL|macro|FT_COMPONENT
undef|#
directive|undef
name|FT_COMPONENT
end_undef
begin_define
DECL|macro|FT_COMPONENT
define|#
directive|define
name|FT_COMPONENT
value|trace_ttcmap
end_define
begin_define
DECL|macro|TT_PEEK_SHORT
define|#
directive|define
name|TT_PEEK_SHORT
value|FT_PEEK_SHORT
end_define
begin_define
DECL|macro|TT_PEEK_USHORT
define|#
directive|define
name|TT_PEEK_USHORT
value|FT_PEEK_USHORT
end_define
begin_define
DECL|macro|TT_PEEK_UINT24
define|#
directive|define
name|TT_PEEK_UINT24
value|FT_PEEK_UOFF3
end_define
begin_define
DECL|macro|TT_PEEK_LONG
define|#
directive|define
name|TT_PEEK_LONG
value|FT_PEEK_LONG
end_define
begin_define
DECL|macro|TT_PEEK_ULONG
define|#
directive|define
name|TT_PEEK_ULONG
value|FT_PEEK_ULONG
end_define
begin_define
DECL|macro|TT_NEXT_SHORT
define|#
directive|define
name|TT_NEXT_SHORT
value|FT_NEXT_SHORT
end_define
begin_define
DECL|macro|TT_NEXT_USHORT
define|#
directive|define
name|TT_NEXT_USHORT
value|FT_NEXT_USHORT
end_define
begin_define
DECL|macro|TT_NEXT_UINT24
define|#
directive|define
name|TT_NEXT_UINT24
value|FT_NEXT_UOFF3
end_define
begin_define
DECL|macro|TT_NEXT_LONG
define|#
directive|define
name|TT_NEXT_LONG
value|FT_NEXT_LONG
end_define
begin_define
DECL|macro|TT_NEXT_ULONG
define|#
directive|define
name|TT_NEXT_ULONG
value|FT_NEXT_ULONG
end_define
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|tt_cmap_init
argument_list|(
argument|TT_CMap   cmap
argument_list|,
argument|FT_Byte*  table
argument_list|)
end_macro
begin_block
block|{
name|cmap
operator|->
name|data
operator|=
name|table
expr_stmt|;
return|return
name|SFNT_Err_Ok
return|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****                           FORMAT 0                            *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* TABLE OVERVIEW                                                        */
end_comment
begin_comment
comment|/* --------------                                                        */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*   NAME        OFFSET         TYPE          DESCRIPTION                */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*   format      0              USHORT        must be 0                  */
end_comment
begin_comment
comment|/*   length      2              USHORT        table length in bytes      */
end_comment
begin_comment
comment|/*   language    4              USHORT        Mac language code          */
end_comment
begin_comment
comment|/*   glyph_ids   6              BYTE[256]     array of glyph indices     */
end_comment
begin_comment
comment|/*               262                                                     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|TT_CONFIG_CMAP_FORMAT_0
end_ifdef
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|tt_cmap0_validate
argument_list|(
argument|FT_Byte*      table
argument_list|,
argument|FT_Validator  valid
argument_list|)
end_macro
begin_block
block|{
name|FT_Byte
modifier|*
name|p
init|=
name|table
operator|+
literal|2
decl_stmt|;
name|FT_UInt
name|length
init|=
name|TT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|table
operator|+
name|length
operator|>
name|valid
operator|->
name|limit
operator|||
name|length
operator|<
literal|262
condition|)
name|FT_INVALID_TOO_SHORT
expr_stmt|;
comment|/* check glyph indices whenever necessary */
if|if
condition|(
name|valid
operator|->
name|level
operator|>=
name|FT_VALIDATE_TIGHT
condition|)
block|{
name|FT_UInt
name|n
decl_stmt|,
name|idx
decl_stmt|;
name|p
operator|=
name|table
operator|+
literal|6
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|256
condition|;
name|n
operator|++
control|)
block|{
name|idx
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|idx
operator|>=
name|TT_VALID_GLYPH_COUNT
argument_list|(
name|valid
argument_list|)
condition|)
name|FT_INVALID_GLYPH_ID
expr_stmt|;
block|}
block|}
return|return
name|SFNT_Err_Ok
return|;
block|}
end_block
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_UInt
argument_list|)
end_macro
begin_macro
name|tt_cmap0_char_index
argument_list|(
argument|TT_CMap    cmap
argument_list|,
argument|FT_UInt32  char_code
argument_list|)
end_macro
begin_block
block|{
name|FT_Byte
modifier|*
name|table
init|=
name|cmap
operator|->
name|data
decl_stmt|;
return|return
name|char_code
operator|<
literal|256
condition|?
name|table
index|[
literal|6
operator|+
name|char_code
index|]
else|:
literal|0
return|;
block|}
end_block
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_UInt32
argument_list|)
end_macro
begin_macro
name|tt_cmap0_char_next
argument_list|(
argument|TT_CMap     cmap
argument_list|,
argument|FT_UInt32  *pchar_code
argument_list|)
end_macro
begin_block
block|{
name|FT_Byte
modifier|*
name|table
init|=
name|cmap
operator|->
name|data
decl_stmt|;
name|FT_UInt32
name|charcode
init|=
operator|*
name|pchar_code
decl_stmt|;
name|FT_UInt32
name|result
init|=
literal|0
decl_stmt|;
name|FT_UInt
name|gindex
init|=
literal|0
decl_stmt|;
name|table
operator|+=
literal|6
expr_stmt|;
comment|/* go to glyph IDs */
while|while
condition|(
operator|++
name|charcode
operator|<
literal|256
condition|)
block|{
name|gindex
operator|=
name|table
index|[
name|charcode
index|]
expr_stmt|;
if|if
condition|(
name|gindex
operator|!=
literal|0
condition|)
block|{
name|result
operator|=
name|charcode
expr_stmt|;
break|break;
block|}
block|}
operator|*
name|pchar_code
operator|=
name|result
expr_stmt|;
return|return
name|gindex
return|;
block|}
end_block
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|tt_cmap0_get_info
argument_list|(
argument|TT_CMap       cmap
argument_list|,
argument|TT_CMapInfo  *cmap_info
argument_list|)
end_macro
begin_block
block|{
name|FT_Byte
modifier|*
name|p
init|=
name|cmap
operator|->
name|data
operator|+
literal|4
decl_stmt|;
name|cmap_info
operator|->
name|format
operator|=
literal|0
expr_stmt|;
name|cmap_info
operator|->
name|language
operator|=
operator|(
name|FT_ULong
operator|)
name|TT_PEEK_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|SFNT_Err_Ok
return|;
block|}
end_block
begin_macro
name|FT_DEFINE_TT_CMAP
argument_list|(
argument|tt_cmap0_class_rec
argument_list|,
argument|sizeof ( TT_CMapRec )
argument_list|,
argument|(FT_CMap_InitFunc)     tt_cmap_init
argument_list|,
argument|(FT_CMap_DoneFunc)     NULL
argument_list|,
argument|(FT_CMap_CharIndexFunc)tt_cmap0_char_index
argument_list|,
argument|(FT_CMap_CharNextFunc) tt_cmap0_char_next
argument_list|,
argument|NULL
argument_list|,
argument|NULL
argument_list|,
argument|NULL
argument_list|,
argument|NULL
argument_list|,
argument|NULL
argument_list|,
literal|0
argument_list|,
argument|(TT_CMap_ValidateFunc)   tt_cmap0_validate
argument_list|,
argument|(TT_CMap_Info_GetFunc)   tt_cmap0_get_info
argument_list|)
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* TT_CONFIG_CMAP_FORMAT_0 */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****                          FORMAT 2                             *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/***** This is used for certain CJK encodings that encode text in a  *****/
end_comment
begin_comment
comment|/***** mixed 8/16 bits encoding along the following lines:           *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/***** * Certain byte values correspond to an 8-bit character code   *****/
end_comment
begin_comment
comment|/*****   (typically in the range 0..127 for ASCII compatibility).    *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/***** * Certain byte values signal the first byte of a 2-byte       *****/
end_comment
begin_comment
comment|/*****   character code (but these values are also valid as the      *****/
end_comment
begin_comment
comment|/*****   second byte of a 2-byte character).                         *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/***** The following charmap lookup and iteration functions all      *****/
end_comment
begin_comment
comment|/***** assume that the value "charcode" correspond to following:     *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****   - For one byte characters, "charcode" is simply the         *****/
end_comment
begin_comment
comment|/*****     character code.                                           *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****   - For two byte characters, "charcode" is the 2-byte         *****/
end_comment
begin_comment
comment|/*****     character code in big endian format.  More exactly:       *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****       (charcode>> 8)    is the first byte value              *****/
end_comment
begin_comment
comment|/*****       (charcode& 0xFF)  is the second byte value             *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/***** Note that not all values of "charcode" are valid according    *****/
end_comment
begin_comment
comment|/***** to these rules, and the function moderately check the         *****/
end_comment
begin_comment
comment|/***** arguments.                                                    *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* TABLE OVERVIEW                                                        */
end_comment
begin_comment
comment|/* --------------                                                        */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*   NAME        OFFSET         TYPE            DESCRIPTION              */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*   format      0              USHORT          must be 2                */
end_comment
begin_comment
comment|/*   length      2              USHORT          table length in bytes    */
end_comment
begin_comment
comment|/*   language    4              USHORT          Mac language code        */
end_comment
begin_comment
comment|/*   keys        6              USHORT[256]     sub-header keys          */
end_comment
begin_comment
comment|/*   subs        518            SUBHEAD[NSUBS]  sub-headers array        */
end_comment
begin_comment
comment|/*   glyph_ids   518+NSUB*8     USHORT[]        glyph ID array           */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* The `keys' table is used to map charcode high-bytes to sub-headers.   */
end_comment
begin_comment
comment|/* The value of `NSUBS' is the number of sub-headers defined in the      */
end_comment
begin_comment
comment|/* table and is computed by finding the maximum of the `keys' table.     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* Note that for any n, `keys[n]' is a byte offset within the `subs'     */
end_comment
begin_comment
comment|/* table, i.e., it is the corresponding sub-header index multiplied      */
end_comment
begin_comment
comment|/* by 8.                                                                 */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* Each sub-header has the following format:                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*   NAME        OFFSET      TYPE            DESCRIPTION                 */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*   first       0           USHORT          first valid low-byte        */
end_comment
begin_comment
comment|/*   count       2           USHORT          number of valid low-bytes   */
end_comment
begin_comment
comment|/*   delta       4           SHORT           see below                   */
end_comment
begin_comment
comment|/*   offset      6           USHORT          see below                   */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* A sub-header defines, for each high-byte, the range of valid          */
end_comment
begin_comment
comment|/* low-bytes within the charmap.  Note that the range defined by `first' */
end_comment
begin_comment
comment|/* and `count' must be completely included in the interval [0..255]      */
end_comment
begin_comment
comment|/* according to the specification.                                       */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* If a character code is contained within a given sub-header, then      */
end_comment
begin_comment
comment|/* mapping it to a glyph index is done as follows:                       */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* * The value of `offset' is read.  This is a _byte_ distance from the  */
end_comment
begin_comment
comment|/*   location of the `offset' field itself into a slice of the           */
end_comment
begin_comment
comment|/*   `glyph_ids' table.  Let's call it `slice' (it is a USHORT[] too).   */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* * The value `slice[char.lo - first]' is read.  If it is 0, there is   */
end_comment
begin_comment
comment|/*   no glyph for the charcode.  Otherwise, the value of `delta' is      */
end_comment
begin_comment
comment|/*   added to it (modulo 65536) to form a new glyph index.               */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* It is up to the validation routine to check that all offsets fall     */
end_comment
begin_comment
comment|/* within the glyph IDs table (and not within the `subs' table itself or */
end_comment
begin_comment
comment|/* outside of the CMap).                                                 */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|TT_CONFIG_CMAP_FORMAT_2
end_ifdef
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|tt_cmap2_validate
argument_list|(
argument|FT_Byte*      table
argument_list|,
argument|FT_Validator  valid
argument_list|)
end_macro
begin_block
block|{
name|FT_Byte
modifier|*
name|p
init|=
name|table
operator|+
literal|2
decl_stmt|;
comment|/* skip format */
name|FT_UInt
name|length
init|=
name|TT_PEEK_USHORT
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|FT_UInt
name|n
decl_stmt|,
name|max_subs
decl_stmt|;
name|FT_Byte
modifier|*
name|keys
decl_stmt|;
comment|/* keys table */
name|FT_Byte
modifier|*
name|subs
decl_stmt|;
comment|/* sub-headers */
name|FT_Byte
modifier|*
name|glyph_ids
decl_stmt|;
comment|/* glyph ID array */
if|if
condition|(
name|table
operator|+
name|length
operator|>
name|valid
operator|->
name|limit
operator|||
name|length
operator|<
literal|6
operator|+
literal|512
condition|)
name|FT_INVALID_TOO_SHORT
expr_stmt|;
name|keys
operator|=
name|table
operator|+
literal|6
expr_stmt|;
comment|/* parse keys to compute sub-headers count */
name|p
operator|=
name|keys
expr_stmt|;
name|max_subs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|256
condition|;
name|n
operator|++
control|)
block|{
name|FT_UInt
name|idx
init|=
name|TT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
decl_stmt|;
comment|/* value must be multiple of 8 */
if|if
condition|(
name|valid
operator|->
name|level
operator|>=
name|FT_VALIDATE_PARANOID
operator|&&
operator|(
name|idx
operator|&
literal|7
operator|)
operator|!=
literal|0
condition|)
name|FT_INVALID_DATA
expr_stmt|;
name|idx
operator|>>=
literal|3
expr_stmt|;
if|if
condition|(
name|idx
operator|>
name|max_subs
condition|)
name|max_subs
operator|=
name|idx
expr_stmt|;
block|}
name|FT_ASSERT
argument_list|(
name|p
operator|==
name|table
operator|+
literal|518
argument_list|)
expr_stmt|;
name|subs
operator|=
name|p
expr_stmt|;
name|glyph_ids
operator|=
name|subs
operator|+
operator|(
name|max_subs
operator|+
literal|1
operator|)
operator|*
literal|8
expr_stmt|;
if|if
condition|(
name|glyph_ids
operator|>
name|valid
operator|->
name|limit
condition|)
name|FT_INVALID_TOO_SHORT
expr_stmt|;
comment|/* parse sub-headers */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<=
name|max_subs
condition|;
name|n
operator|++
control|)
block|{
name|FT_UInt
name|first_code
decl_stmt|,
name|code_count
decl_stmt|,
name|offset
decl_stmt|;
name|FT_Int
name|delta
decl_stmt|;
name|FT_Byte
modifier|*
name|ids
decl_stmt|;
name|first_code
operator|=
name|TT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|code_count
operator|=
name|TT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|delta
operator|=
name|TT_NEXT_SHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|offset
operator|=
name|TT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* many Dynalab fonts have empty sub-headers */
if|if
condition|(
name|code_count
operator|==
literal|0
condition|)
continue|continue;
comment|/* check range within 0..255 */
if|if
condition|(
name|valid
operator|->
name|level
operator|>=
name|FT_VALIDATE_PARANOID
condition|)
block|{
if|if
condition|(
name|first_code
operator|>=
literal|256
operator|||
name|first_code
operator|+
name|code_count
operator|>
literal|256
condition|)
name|FT_INVALID_DATA
expr_stmt|;
block|}
comment|/* check offset */
if|if
condition|(
name|offset
operator|!=
literal|0
condition|)
block|{
name|ids
operator|=
name|p
operator|-
literal|2
operator|+
name|offset
expr_stmt|;
if|if
condition|(
name|ids
operator|<
name|glyph_ids
operator|||
name|ids
operator|+
name|code_count
operator|*
literal|2
operator|>
name|table
operator|+
name|length
condition|)
name|FT_INVALID_OFFSET
expr_stmt|;
comment|/* check glyph IDs */
if|if
condition|(
name|valid
operator|->
name|level
operator|>=
name|FT_VALIDATE_TIGHT
condition|)
block|{
name|FT_Byte
modifier|*
name|limit
init|=
name|p
operator|+
name|code_count
operator|*
literal|2
decl_stmt|;
name|FT_UInt
name|idx
decl_stmt|;
for|for
control|(
init|;
name|p
operator|<
name|limit
condition|;
control|)
block|{
name|idx
operator|=
name|TT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|!=
literal|0
condition|)
block|{
name|idx
operator|=
operator|(
name|idx
operator|+
name|delta
operator|)
operator|&
literal|0xFFFFU
expr_stmt|;
if|if
condition|(
name|idx
operator|>=
name|TT_VALID_GLYPH_COUNT
argument_list|(
name|valid
argument_list|)
condition|)
name|FT_INVALID_GLYPH_ID
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
return|return
name|SFNT_Err_Ok
return|;
block|}
end_block
begin_comment
comment|/* return sub header corresponding to a given character code */
end_comment
begin_comment
comment|/* NULL on invalid charcode                                  */
end_comment
begin_function
specifier|static
name|FT_Byte
modifier|*
DECL|function|tt_cmap2_get_subheader
name|tt_cmap2_get_subheader
parameter_list|(
name|FT_Byte
modifier|*
name|table
parameter_list|,
name|FT_UInt32
name|char_code
parameter_list|)
block|{
name|FT_Byte
modifier|*
name|result
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|char_code
operator|<
literal|0x10000UL
condition|)
block|{
name|FT_UInt
name|char_lo
init|=
call|(
name|FT_UInt
call|)
argument_list|(
name|char_code
operator|&
literal|0xFF
argument_list|)
decl_stmt|;
name|FT_UInt
name|char_hi
init|=
call|(
name|FT_UInt
call|)
argument_list|(
name|char_code
operator|>>
literal|8
argument_list|)
decl_stmt|;
name|FT_Byte
modifier|*
name|p
init|=
name|table
operator|+
literal|6
decl_stmt|;
comment|/* keys table */
name|FT_Byte
modifier|*
name|subs
init|=
name|table
operator|+
literal|518
decl_stmt|;
comment|/* subheaders table */
name|FT_Byte
modifier|*
name|sub
decl_stmt|;
if|if
condition|(
name|char_hi
operator|==
literal|0
condition|)
block|{
comment|/* an 8-bit character code -- we use subHeader 0 in this case */
comment|/* to test whether the character code is in the charmap       */
comment|/*                                                            */
name|sub
operator|=
name|subs
expr_stmt|;
comment|/* jump to first sub-header */
comment|/* check that the sub-header for this byte is 0, which */
comment|/* indicates that it is really a valid one-byte value  */
comment|/* Otherwise, return 0                                 */
comment|/*                                                     */
name|p
operator|+=
name|char_lo
operator|*
literal|2
expr_stmt|;
if|if
condition|(
name|TT_PEEK_USHORT
argument_list|(
name|p
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|Exit
goto|;
block|}
else|else
block|{
comment|/* a 16-bit character code */
comment|/* jump to key entry  */
name|p
operator|+=
name|char_hi
operator|*
literal|2
expr_stmt|;
comment|/* jump to sub-header */
name|sub
operator|=
name|subs
operator|+
operator|(
name|FT_PAD_FLOOR
argument_list|(
name|TT_PEEK_USHORT
argument_list|(
name|p
argument_list|)
argument_list|,
literal|8
argument_list|)
operator|)
expr_stmt|;
comment|/* check that the high byte isn't a valid one-byte value */
if|if
condition|(
name|sub
operator|==
name|subs
condition|)
goto|goto
name|Exit
goto|;
block|}
name|result
operator|=
name|sub
expr_stmt|;
block|}
name|Exit
label|:
return|return
name|result
return|;
block|}
end_function
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_UInt
argument_list|)
end_macro
begin_macro
name|tt_cmap2_char_index
argument_list|(
argument|TT_CMap    cmap
argument_list|,
argument|FT_UInt32  char_code
argument_list|)
end_macro
begin_block
block|{
name|FT_Byte
modifier|*
name|table
init|=
name|cmap
operator|->
name|data
decl_stmt|;
name|FT_UInt
name|result
init|=
literal|0
decl_stmt|;
name|FT_Byte
modifier|*
name|subheader
decl_stmt|;
name|subheader
operator|=
name|tt_cmap2_get_subheader
argument_list|(
name|table
argument_list|,
name|char_code
argument_list|)
expr_stmt|;
if|if
condition|(
name|subheader
condition|)
block|{
name|FT_Byte
modifier|*
name|p
init|=
name|subheader
decl_stmt|;
name|FT_UInt
name|idx
init|=
call|(
name|FT_UInt
call|)
argument_list|(
name|char_code
operator|&
literal|0xFF
argument_list|)
decl_stmt|;
name|FT_UInt
name|start
decl_stmt|,
name|count
decl_stmt|;
name|FT_Int
name|delta
decl_stmt|;
name|FT_UInt
name|offset
decl_stmt|;
name|start
operator|=
name|TT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|count
operator|=
name|TT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|delta
operator|=
name|TT_NEXT_SHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|offset
operator|=
name|TT_PEEK_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|idx
operator|-=
name|start
expr_stmt|;
if|if
condition|(
name|idx
operator|<
name|count
operator|&&
name|offset
operator|!=
literal|0
condition|)
block|{
name|p
operator|+=
name|offset
operator|+
literal|2
operator|*
name|idx
expr_stmt|;
name|idx
operator|=
name|TT_PEEK_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|!=
literal|0
condition|)
name|result
operator|=
call|(
name|FT_UInt
call|)
argument_list|(
name|idx
operator|+
name|delta
argument_list|)
operator|&
literal|0xFFFFU
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_block
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_UInt32
argument_list|)
end_macro
begin_macro
name|tt_cmap2_char_next
argument_list|(
argument|TT_CMap     cmap
argument_list|,
argument|FT_UInt32  *pcharcode
argument_list|)
end_macro
begin_block
block|{
name|FT_Byte
modifier|*
name|table
init|=
name|cmap
operator|->
name|data
decl_stmt|;
name|FT_UInt
name|gindex
init|=
literal|0
decl_stmt|;
name|FT_UInt32
name|result
init|=
literal|0
decl_stmt|;
name|FT_UInt32
name|charcode
init|=
operator|*
name|pcharcode
operator|+
literal|1
decl_stmt|;
name|FT_Byte
modifier|*
name|subheader
decl_stmt|;
while|while
condition|(
name|charcode
operator|<
literal|0x10000UL
condition|)
block|{
name|subheader
operator|=
name|tt_cmap2_get_subheader
argument_list|(
name|table
argument_list|,
name|charcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|subheader
condition|)
block|{
name|FT_Byte
modifier|*
name|p
init|=
name|subheader
decl_stmt|;
name|FT_UInt
name|start
init|=
name|TT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|FT_UInt
name|count
init|=
name|TT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|FT_Int
name|delta
init|=
name|TT_NEXT_SHORT
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|FT_UInt
name|offset
init|=
name|TT_PEEK_USHORT
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|FT_UInt
name|char_lo
init|=
call|(
name|FT_UInt
call|)
argument_list|(
name|charcode
operator|&
literal|0xFF
argument_list|)
decl_stmt|;
name|FT_UInt
name|pos
decl_stmt|,
name|idx
decl_stmt|;
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
goto|goto
name|Next_SubHeader
goto|;
if|if
condition|(
name|char_lo
operator|<
name|start
condition|)
block|{
name|char_lo
operator|=
name|start
expr_stmt|;
name|pos
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|pos
operator|=
call|(
name|FT_UInt
call|)
argument_list|(
name|char_lo
operator|-
name|start
argument_list|)
expr_stmt|;
name|p
operator|+=
name|offset
operator|+
name|pos
operator|*
literal|2
expr_stmt|;
name|charcode
operator|=
name|FT_PAD_FLOOR
argument_list|(
name|charcode
argument_list|,
literal|256
argument_list|)
operator|+
name|char_lo
expr_stmt|;
for|for
control|(
init|;
name|pos
operator|<
name|count
condition|;
name|pos
operator|++
operator|,
name|charcode
operator|++
control|)
block|{
name|idx
operator|=
name|TT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|!=
literal|0
condition|)
block|{
name|gindex
operator|=
operator|(
name|idx
operator|+
name|delta
operator|)
operator|&
literal|0xFFFFU
expr_stmt|;
if|if
condition|(
name|gindex
operator|!=
literal|0
condition|)
block|{
name|result
operator|=
name|charcode
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
block|}
block|}
comment|/* jump to next sub-header, i.e. higher byte value */
name|Next_SubHeader
label|:
name|charcode
operator|=
name|FT_PAD_FLOOR
argument_list|(
name|charcode
argument_list|,
literal|256
argument_list|)
operator|+
literal|256
expr_stmt|;
block|}
name|Exit
label|:
operator|*
name|pcharcode
operator|=
name|result
expr_stmt|;
return|return
name|gindex
return|;
block|}
end_block
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|tt_cmap2_get_info
argument_list|(
argument|TT_CMap       cmap
argument_list|,
argument|TT_CMapInfo  *cmap_info
argument_list|)
end_macro
begin_block
block|{
name|FT_Byte
modifier|*
name|p
init|=
name|cmap
operator|->
name|data
operator|+
literal|4
decl_stmt|;
name|cmap_info
operator|->
name|format
operator|=
literal|2
expr_stmt|;
name|cmap_info
operator|->
name|language
operator|=
operator|(
name|FT_ULong
operator|)
name|TT_PEEK_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|SFNT_Err_Ok
return|;
block|}
end_block
begin_macro
name|FT_DEFINE_TT_CMAP
argument_list|(
argument|tt_cmap2_class_rec
argument_list|,
argument|sizeof ( TT_CMapRec )
argument_list|,
argument|(FT_CMap_InitFunc)     tt_cmap_init
argument_list|,
argument|(FT_CMap_DoneFunc)     NULL
argument_list|,
argument|(FT_CMap_CharIndexFunc)tt_cmap2_char_index
argument_list|,
argument|(FT_CMap_CharNextFunc) tt_cmap2_char_next
argument_list|,
argument|NULL
argument_list|,
argument|NULL
argument_list|,
argument|NULL
argument_list|,
argument|NULL
argument_list|,
argument|NULL
argument_list|,
literal|2
argument_list|,
argument|(TT_CMap_ValidateFunc)   tt_cmap2_validate
argument_list|,
argument|(TT_CMap_Info_GetFunc)   tt_cmap2_get_info
argument_list|)
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* TT_CONFIG_CMAP_FORMAT_2 */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****                           FORMAT 4                            *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* TABLE OVERVIEW                                                        */
end_comment
begin_comment
comment|/* --------------                                                        */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*   NAME          OFFSET         TYPE              DESCRIPTION          */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*   format        0              USHORT            must be 4            */
end_comment
begin_comment
comment|/*   length        2              USHORT            table length         */
end_comment
begin_comment
comment|/*                                                  in bytes             */
end_comment
begin_comment
comment|/*   language      4              USHORT            Mac language code    */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*   segCountX2    6              USHORT            2*NUM_SEGS           */
end_comment
begin_comment
comment|/*   searchRange   8              USHORT            2*(1<< LOG_SEGS)    */
end_comment
begin_comment
comment|/*   entrySelector 10             USHORT            LOG_SEGS             */
end_comment
begin_comment
comment|/*   rangeShift    12             USHORT            segCountX2 -         */
end_comment
begin_comment
comment|/*                                                    searchRange        */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*   endCount      14             USHORT[NUM_SEGS]  end charcode for     */
end_comment
begin_comment
comment|/*                                                  each segment; last   */
end_comment
begin_comment
comment|/*                                                  is 0xFFFF            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*   pad           14+NUM_SEGS*2  USHORT            padding              */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*   startCount    16+NUM_SEGS*2  USHORT[NUM_SEGS]  first charcode for   */
end_comment
begin_comment
comment|/*                                                  each segment         */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*   idDelta       16+NUM_SEGS*4  SHORT[NUM_SEGS]   delta for each       */
end_comment
begin_comment
comment|/*                                                  segment              */
end_comment
begin_comment
comment|/*   idOffset      16+NUM_SEGS*6  SHORT[NUM_SEGS]   range offset for     */
end_comment
begin_comment
comment|/*                                                  each segment; can be */
end_comment
begin_comment
comment|/*                                                  zero                 */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*   glyphIds      16+NUM_SEGS*8  USHORT[]          array of glyph ID    */
end_comment
begin_comment
comment|/*                                                  ranges               */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* Character codes are modelled by a series of ordered (increasing)      */
end_comment
begin_comment
comment|/* intervals called segments.  Each segment has start and end codes,     */
end_comment
begin_comment
comment|/* provided by the `startCount' and `endCount' arrays.  Segments must    */
end_comment
begin_comment
comment|/* not overlap, and the last segment should always contain the value     */
end_comment
begin_comment
comment|/* 0xFFFF for `endCount'.                                                */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* The fields `searchRange', `entrySelector' and `rangeShift' are better */
end_comment
begin_comment
comment|/* ignored (they are traces of over-engineering in the TrueType          */
end_comment
begin_comment
comment|/* specification).                                                       */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* Each segment also has a signed `delta', as well as an optional offset */
end_comment
begin_comment
comment|/* within the `glyphIds' table.                                          */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* If a segment's idOffset is 0, the glyph index corresponding to any    */
end_comment
begin_comment
comment|/* charcode within the segment is obtained by adding the value of        */
end_comment
begin_comment
comment|/* `idDelta' directly to the charcode, modulo 65536.                     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* Otherwise, a glyph index is taken from the glyph IDs sub-array for    */
end_comment
begin_comment
comment|/* the segment, and the value of `idDelta' is added to it.               */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* Finally, note that a lot of fonts contain an invalid last segment,    */
end_comment
begin_comment
comment|/* where `start' and `end' are correctly set to 0xFFFF but both `delta'  */
end_comment
begin_comment
comment|/* and `offset' are incorrect (e.g., `opens___.ttf' which comes with     */
end_comment
begin_comment
comment|/* OpenOffice.org).  We need special code to deal with them correctly.   */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|TT_CONFIG_CMAP_FORMAT_4
end_ifdef
begin_typedef
DECL|struct|TT_CMap4Rec_
typedef|typedef
struct|struct
name|TT_CMap4Rec_
block|{
DECL|member|cmap
name|TT_CMapRec
name|cmap
decl_stmt|;
DECL|member|cur_charcode
name|FT_UInt32
name|cur_charcode
decl_stmt|;
comment|/* current charcode */
DECL|member|cur_gindex
name|FT_UInt
name|cur_gindex
decl_stmt|;
comment|/* current glyph index */
DECL|member|num_ranges
name|FT_UInt
name|num_ranges
decl_stmt|;
DECL|member|cur_range
name|FT_UInt
name|cur_range
decl_stmt|;
DECL|member|cur_start
name|FT_UInt
name|cur_start
decl_stmt|;
DECL|member|cur_end
name|FT_UInt
name|cur_end
decl_stmt|;
DECL|member|cur_delta
name|FT_Int
name|cur_delta
decl_stmt|;
DECL|member|cur_values
name|FT_Byte
modifier|*
name|cur_values
decl_stmt|;
block|}
DECL|typedef|TT_CMap4Rec
DECL|typedef|TT_CMap4
name|TT_CMap4Rec
operator|,
typedef|*
name|TT_CMap4
typedef|;
end_typedef
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|tt_cmap4_init
argument_list|(
argument|TT_CMap4  cmap
argument_list|,
argument|FT_Byte*  table
argument_list|)
end_macro
begin_block
block|{
name|FT_Byte
modifier|*
name|p
decl_stmt|;
name|cmap
operator|->
name|cmap
operator|.
name|data
operator|=
name|table
expr_stmt|;
name|p
operator|=
name|table
operator|+
literal|6
expr_stmt|;
name|cmap
operator|->
name|num_ranges
operator|=
name|FT_PEEK_USHORT
argument_list|(
name|p
argument_list|)
operator|>>
literal|1
expr_stmt|;
name|cmap
operator|->
name|cur_charcode
operator|=
operator|(
name|FT_UInt32
operator|)
literal|0xFFFFFFFFUL
expr_stmt|;
name|cmap
operator|->
name|cur_gindex
operator|=
literal|0
expr_stmt|;
return|return
name|SFNT_Err_Ok
return|;
block|}
end_block
begin_function
specifier|static
name|FT_Int
DECL|function|tt_cmap4_set_range
name|tt_cmap4_set_range
parameter_list|(
name|TT_CMap4
name|cmap
parameter_list|,
name|FT_UInt
name|range_index
parameter_list|)
block|{
name|FT_Byte
modifier|*
name|table
init|=
name|cmap
operator|->
name|cmap
operator|.
name|data
decl_stmt|;
name|FT_Byte
modifier|*
name|p
decl_stmt|;
name|FT_UInt
name|num_ranges
init|=
name|cmap
operator|->
name|num_ranges
decl_stmt|;
while|while
condition|(
name|range_index
operator|<
name|num_ranges
condition|)
block|{
name|FT_UInt
name|offset
decl_stmt|;
name|p
operator|=
name|table
operator|+
literal|14
operator|+
name|range_index
operator|*
literal|2
expr_stmt|;
name|cmap
operator|->
name|cur_end
operator|=
name|FT_PEEK_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|2
operator|+
name|num_ranges
operator|*
literal|2
expr_stmt|;
name|cmap
operator|->
name|cur_start
operator|=
name|FT_PEEK_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
name|num_ranges
operator|*
literal|2
expr_stmt|;
name|cmap
operator|->
name|cur_delta
operator|=
name|FT_PEEK_SHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
name|num_ranges
operator|*
literal|2
expr_stmt|;
name|offset
operator|=
name|FT_PEEK_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* some fonts have an incorrect last segment; */
comment|/* we have to catch it                        */
if|if
condition|(
name|range_index
operator|>=
name|num_ranges
operator|-
literal|1
operator|&&
name|cmap
operator|->
name|cur_start
operator|==
literal|0xFFFFU
operator|&&
name|cmap
operator|->
name|cur_end
operator|==
literal|0xFFFFU
condition|)
block|{
name|TT_Face
name|face
init|=
operator|(
name|TT_Face
operator|)
name|cmap
operator|->
name|cmap
operator|.
name|cmap
operator|.
name|charmap
operator|.
name|face
decl_stmt|;
name|FT_Byte
modifier|*
name|limit
init|=
name|face
operator|->
name|cmap_table
operator|+
name|face
operator|->
name|cmap_size
decl_stmt|;
if|if
condition|(
name|offset
operator|&&
name|p
operator|+
name|offset
operator|+
literal|2
operator|>
name|limit
condition|)
block|{
name|cmap
operator|->
name|cur_delta
operator|=
literal|1
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|offset
operator|!=
literal|0xFFFFU
condition|)
block|{
name|cmap
operator|->
name|cur_values
operator|=
name|offset
condition|?
name|p
operator|+
name|offset
else|:
name|NULL
expr_stmt|;
name|cmap
operator|->
name|cur_range
operator|=
name|range_index
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* we skip empty segments */
name|range_index
operator|++
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|/* search the index of the charcode next to cmap->cur_charcode; */
end_comment
begin_comment
comment|/* caller should call tt_cmap4_set_range with proper range      */
end_comment
begin_comment
comment|/* before calling this function                                 */
end_comment
begin_comment
comment|/*                                                              */
end_comment
begin_function
specifier|static
name|void
DECL|function|tt_cmap4_next
name|tt_cmap4_next
parameter_list|(
name|TT_CMap4
name|cmap
parameter_list|)
block|{
name|FT_UInt
name|charcode
decl_stmt|;
if|if
condition|(
name|cmap
operator|->
name|cur_charcode
operator|>=
literal|0xFFFFUL
condition|)
goto|goto
name|Fail
goto|;
name|charcode
operator|=
operator|(
name|FT_UInt
operator|)
name|cmap
operator|->
name|cur_charcode
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|charcode
operator|<
name|cmap
operator|->
name|cur_start
condition|)
name|charcode
operator|=
name|cmap
operator|->
name|cur_start
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|FT_Byte
modifier|*
name|values
init|=
name|cmap
operator|->
name|cur_values
decl_stmt|;
name|FT_UInt
name|end
init|=
name|cmap
operator|->
name|cur_end
decl_stmt|;
name|FT_Int
name|delta
init|=
name|cmap
operator|->
name|cur_delta
decl_stmt|;
if|if
condition|(
name|charcode
operator|<=
name|end
condition|)
block|{
if|if
condition|(
name|values
condition|)
block|{
name|FT_Byte
modifier|*
name|p
init|=
name|values
operator|+
literal|2
operator|*
operator|(
name|charcode
operator|-
name|cmap
operator|->
name|cur_start
operator|)
decl_stmt|;
do|do
block|{
name|FT_UInt
name|gindex
init|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|gindex
operator|!=
literal|0
condition|)
block|{
name|gindex
operator|=
call|(
name|FT_UInt
call|)
argument_list|(
operator|(
name|gindex
operator|+
name|delta
operator|)
operator|&
literal|0xFFFFU
argument_list|)
expr_stmt|;
if|if
condition|(
name|gindex
operator|!=
literal|0
condition|)
block|{
name|cmap
operator|->
name|cur_charcode
operator|=
name|charcode
expr_stmt|;
name|cmap
operator|->
name|cur_gindex
operator|=
name|gindex
expr_stmt|;
return|return;
block|}
block|}
block|}
do|while
condition|(
operator|++
name|charcode
operator|<=
name|end
condition|)
do|;
block|}
else|else
block|{
do|do
block|{
name|FT_UInt
name|gindex
init|=
call|(
name|FT_UInt
call|)
argument_list|(
operator|(
name|charcode
operator|+
name|delta
operator|)
operator|&
literal|0xFFFFU
argument_list|)
decl_stmt|;
if|if
condition|(
name|gindex
operator|!=
literal|0
condition|)
block|{
name|cmap
operator|->
name|cur_charcode
operator|=
name|charcode
expr_stmt|;
name|cmap
operator|->
name|cur_gindex
operator|=
name|gindex
expr_stmt|;
return|return;
block|}
block|}
do|while
condition|(
operator|++
name|charcode
operator|<=
name|end
condition|)
do|;
block|}
block|}
comment|/* we need to find another range */
if|if
condition|(
name|tt_cmap4_set_range
argument_list|(
name|cmap
argument_list|,
name|cmap
operator|->
name|cur_range
operator|+
literal|1
argument_list|)
operator|<
literal|0
condition|)
break|break;
if|if
condition|(
name|charcode
operator|<
name|cmap
operator|->
name|cur_start
condition|)
name|charcode
operator|=
name|cmap
operator|->
name|cur_start
expr_stmt|;
block|}
name|Fail
label|:
name|cmap
operator|->
name|cur_charcode
operator|=
operator|(
name|FT_UInt32
operator|)
literal|0xFFFFFFFFUL
expr_stmt|;
name|cmap
operator|->
name|cur_gindex
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|tt_cmap4_validate
argument_list|(
argument|FT_Byte*      table
argument_list|,
argument|FT_Validator  valid
argument_list|)
end_macro
begin_block
block|{
name|FT_Byte
modifier|*
name|p
init|=
name|table
operator|+
literal|2
decl_stmt|;
comment|/* skip format */
name|FT_UInt
name|length
init|=
name|TT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|FT_Byte
modifier|*
name|ends
decl_stmt|,
modifier|*
name|starts
decl_stmt|,
modifier|*
name|offsets
decl_stmt|,
modifier|*
name|deltas
decl_stmt|,
modifier|*
name|glyph_ids
decl_stmt|;
name|FT_UInt
name|num_segs
decl_stmt|;
name|FT_Error
name|error
init|=
name|SFNT_Err_Ok
decl_stmt|;
if|if
condition|(
name|length
operator|<
literal|16
condition|)
name|FT_INVALID_TOO_SHORT
expr_stmt|;
comment|/* in certain fonts, the `length' field is invalid and goes */
comment|/* out of bound.  We try to correct this here...            */
if|if
condition|(
name|table
operator|+
name|length
operator|>
name|valid
operator|->
name|limit
condition|)
block|{
if|if
condition|(
name|valid
operator|->
name|level
operator|>=
name|FT_VALIDATE_TIGHT
condition|)
name|FT_INVALID_TOO_SHORT
expr_stmt|;
name|length
operator|=
call|(
name|FT_UInt
call|)
argument_list|(
name|valid
operator|->
name|limit
operator|-
name|table
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|table
operator|+
literal|6
expr_stmt|;
name|num_segs
operator|=
name|TT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* read segCountX2 */
if|if
condition|(
name|valid
operator|->
name|level
operator|>=
name|FT_VALIDATE_PARANOID
condition|)
block|{
comment|/* check that we have an even value here */
if|if
condition|(
name|num_segs
operator|&
literal|1
condition|)
name|FT_INVALID_DATA
expr_stmt|;
block|}
name|num_segs
operator|/=
literal|2
expr_stmt|;
if|if
condition|(
name|length
operator|<
literal|16
operator|+
name|num_segs
operator|*
literal|2
operator|*
literal|4
condition|)
name|FT_INVALID_TOO_SHORT
expr_stmt|;
comment|/* check the search parameters - even though we never use them */
comment|/*                                                             */
if|if
condition|(
name|valid
operator|->
name|level
operator|>=
name|FT_VALIDATE_PARANOID
condition|)
block|{
comment|/* check the values of `searchRange', `entrySelector', `rangeShift' */
name|FT_UInt
name|search_range
init|=
name|TT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|FT_UInt
name|entry_selector
init|=
name|TT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|FT_UInt
name|range_shift
init|=
name|TT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|search_range
operator||
name|range_shift
operator|)
operator|&
literal|1
condition|)
comment|/* must be even values */
name|FT_INVALID_DATA
expr_stmt|;
name|search_range
operator|/=
literal|2
expr_stmt|;
name|range_shift
operator|/=
literal|2
expr_stmt|;
comment|/* `search range' is the greatest power of 2 that is<= num_segs */
if|if
condition|(
name|search_range
operator|>
name|num_segs
operator|||
name|search_range
operator|*
literal|2
operator|<
name|num_segs
operator|||
name|search_range
operator|+
name|range_shift
operator|!=
name|num_segs
operator|||
name|search_range
operator|!=
operator|(
literal|1U
operator|<<
name|entry_selector
operator|)
condition|)
name|FT_INVALID_DATA
expr_stmt|;
block|}
name|ends
operator|=
name|table
operator|+
literal|14
expr_stmt|;
name|starts
operator|=
name|table
operator|+
literal|16
operator|+
name|num_segs
operator|*
literal|2
expr_stmt|;
name|deltas
operator|=
name|starts
operator|+
name|num_segs
operator|*
literal|2
expr_stmt|;
name|offsets
operator|=
name|deltas
operator|+
name|num_segs
operator|*
literal|2
expr_stmt|;
name|glyph_ids
operator|=
name|offsets
operator|+
name|num_segs
operator|*
literal|2
expr_stmt|;
comment|/* check last segment; its end count value must be 0xFFFF */
if|if
condition|(
name|valid
operator|->
name|level
operator|>=
name|FT_VALIDATE_PARANOID
condition|)
block|{
name|p
operator|=
name|ends
operator|+
operator|(
name|num_segs
operator|-
literal|1
operator|)
operator|*
literal|2
expr_stmt|;
if|if
condition|(
name|TT_PEEK_USHORT
argument_list|(
name|p
argument_list|)
operator|!=
literal|0xFFFFU
condition|)
name|FT_INVALID_DATA
expr_stmt|;
block|}
block|{
name|FT_UInt
name|start
decl_stmt|,
name|end
decl_stmt|,
name|offset
decl_stmt|,
name|n
decl_stmt|;
name|FT_UInt
name|last_start
init|=
literal|0
decl_stmt|,
name|last_end
init|=
literal|0
decl_stmt|;
name|FT_Int
name|delta
decl_stmt|;
name|FT_Byte
modifier|*
name|p_start
init|=
name|starts
decl_stmt|;
name|FT_Byte
modifier|*
name|p_end
init|=
name|ends
decl_stmt|;
name|FT_Byte
modifier|*
name|p_delta
init|=
name|deltas
decl_stmt|;
name|FT_Byte
modifier|*
name|p_offset
init|=
name|offsets
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|num_segs
condition|;
name|n
operator|++
control|)
block|{
name|p
operator|=
name|p_offset
expr_stmt|;
name|start
operator|=
name|TT_NEXT_USHORT
argument_list|(
name|p_start
argument_list|)
expr_stmt|;
name|end
operator|=
name|TT_NEXT_USHORT
argument_list|(
name|p_end
argument_list|)
expr_stmt|;
name|delta
operator|=
name|TT_NEXT_SHORT
argument_list|(
name|p_delta
argument_list|)
expr_stmt|;
name|offset
operator|=
name|TT_NEXT_USHORT
argument_list|(
name|p_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|start
operator|>
name|end
condition|)
name|FT_INVALID_DATA
expr_stmt|;
comment|/* this test should be performed at default validation level; */
comment|/* unfortunately, some popular Asian fonts have overlapping   */
comment|/* ranges in their charmaps                                   */
comment|/*                                                            */
if|if
condition|(
name|start
operator|<=
name|last_end
operator|&&
name|n
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|valid
operator|->
name|level
operator|>=
name|FT_VALIDATE_TIGHT
condition|)
name|FT_INVALID_DATA
expr_stmt|;
else|else
block|{
comment|/* allow overlapping segments, provided their start points */
comment|/* and end points, respectively, are in ascending order    */
comment|/*                                                         */
if|if
condition|(
name|last_start
operator|>
name|start
operator|||
name|last_end
operator|>
name|end
condition|)
name|error
operator||=
name|TT_CMAP_FLAG_UNSORTED
expr_stmt|;
else|else
name|error
operator||=
name|TT_CMAP_FLAG_OVERLAPPING
expr_stmt|;
block|}
block|}
if|if
condition|(
name|offset
operator|&&
name|offset
operator|!=
literal|0xFFFFU
condition|)
block|{
name|p
operator|+=
name|offset
expr_stmt|;
comment|/* start of glyph ID array */
comment|/* check that we point within the glyph IDs table only */
if|if
condition|(
name|valid
operator|->
name|level
operator|>=
name|FT_VALIDATE_TIGHT
condition|)
block|{
if|if
condition|(
name|p
operator|<
name|glyph_ids
operator|||
name|p
operator|+
operator|(
name|end
operator|-
name|start
operator|+
literal|1
operator|)
operator|*
literal|2
operator|>
name|table
operator|+
name|length
condition|)
name|FT_INVALID_DATA
expr_stmt|;
block|}
comment|/* Some fonts handle the last segment incorrectly.  In */
comment|/* theory, 0xFFFF might point to an ordinary glyph --  */
comment|/* a cmap 4 is versatile and could be used for any     */
comment|/* encoding, not only Unicode.  However, reality shows */
comment|/* that far too many fonts are sloppy and incorrectly  */
comment|/* set all fields but `start' and `end' for the last   */
comment|/* segment if it contains only a single character.     */
comment|/*                                                     */
comment|/* We thus omit the test here, delaying it to the      */
comment|/* routines which actually access the cmap.            */
elseif|else
if|if
condition|(
name|n
operator|!=
name|num_segs
operator|-
literal|1
operator|||
operator|!
operator|(
name|start
operator|==
literal|0xFFFFU
operator|&&
name|end
operator|==
literal|0xFFFFU
operator|)
condition|)
block|{
if|if
condition|(
name|p
operator|<
name|glyph_ids
operator|||
name|p
operator|+
operator|(
name|end
operator|-
name|start
operator|+
literal|1
operator|)
operator|*
literal|2
operator|>
name|valid
operator|->
name|limit
condition|)
name|FT_INVALID_DATA
expr_stmt|;
block|}
comment|/* check glyph indices within the segment range */
if|if
condition|(
name|valid
operator|->
name|level
operator|>=
name|FT_VALIDATE_TIGHT
condition|)
block|{
name|FT_UInt
name|i
decl_stmt|,
name|idx
decl_stmt|;
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<
name|end
condition|;
name|i
operator|++
control|)
block|{
name|idx
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|!=
literal|0
condition|)
block|{
name|idx
operator|=
call|(
name|FT_UInt
call|)
argument_list|(
name|idx
operator|+
name|delta
argument_list|)
operator|&
literal|0xFFFFU
expr_stmt|;
if|if
condition|(
name|idx
operator|>=
name|TT_VALID_GLYPH_COUNT
argument_list|(
name|valid
argument_list|)
condition|)
name|FT_INVALID_GLYPH_ID
expr_stmt|;
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|offset
operator|==
literal|0xFFFFU
condition|)
block|{
comment|/* some fonts (erroneously?) use a range offset of 0xFFFF */
comment|/* to mean missing glyph in cmap table                    */
comment|/*                                                        */
if|if
condition|(
name|valid
operator|->
name|level
operator|>=
name|FT_VALIDATE_PARANOID
operator|||
name|n
operator|!=
name|num_segs
operator|-
literal|1
operator|||
operator|!
operator|(
name|start
operator|==
literal|0xFFFFU
operator|&&
name|end
operator|==
literal|0xFFFFU
operator|)
condition|)
name|FT_INVALID_DATA
expr_stmt|;
block|}
name|last_start
operator|=
name|start
expr_stmt|;
name|last_end
operator|=
name|end
expr_stmt|;
block|}
block|}
return|return
name|error
return|;
block|}
end_block
begin_function
specifier|static
name|FT_UInt
DECL|function|tt_cmap4_char_map_linear
name|tt_cmap4_char_map_linear
parameter_list|(
name|TT_CMap
name|cmap
parameter_list|,
name|FT_UInt32
modifier|*
name|pcharcode
parameter_list|,
name|FT_Bool
name|next
parameter_list|)
block|{
name|FT_UInt
name|num_segs2
decl_stmt|,
name|start
decl_stmt|,
name|end
decl_stmt|,
name|offset
decl_stmt|;
name|FT_Int
name|delta
decl_stmt|;
name|FT_UInt
name|i
decl_stmt|,
name|num_segs
decl_stmt|;
name|FT_UInt32
name|charcode
init|=
operator|*
name|pcharcode
decl_stmt|;
name|FT_UInt
name|gindex
init|=
literal|0
decl_stmt|;
name|FT_Byte
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|cmap
operator|->
name|data
operator|+
literal|6
expr_stmt|;
name|num_segs2
operator|=
name|FT_PAD_FLOOR
argument_list|(
name|TT_PEEK_USHORT
argument_list|(
name|p
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|num_segs
operator|=
name|num_segs2
operator|>>
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|num_segs
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|next
condition|)
name|charcode
operator|++
expr_stmt|;
comment|/* linear search */
for|for
control|(
init|;
name|charcode
operator|<=
literal|0xFFFFU
condition|;
name|charcode
operator|++
control|)
block|{
name|FT_Byte
modifier|*
name|q
decl_stmt|;
name|p
operator|=
name|cmap
operator|->
name|data
operator|+
literal|14
expr_stmt|;
comment|/* ends table   */
name|q
operator|=
name|cmap
operator|->
name|data
operator|+
literal|16
operator|+
name|num_segs2
expr_stmt|;
comment|/* starts table */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_segs
condition|;
name|i
operator|++
control|)
block|{
name|end
operator|=
name|TT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|start
operator|=
name|TT_NEXT_USHORT
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|charcode
operator|>=
name|start
operator|&&
name|charcode
operator|<=
name|end
condition|)
block|{
name|p
operator|=
name|q
operator|-
literal|2
operator|+
name|num_segs2
expr_stmt|;
name|delta
operator|=
name|TT_PEEK_SHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
name|num_segs2
expr_stmt|;
name|offset
operator|=
name|TT_PEEK_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* some fonts have an incorrect last segment; */
comment|/* we have to catch it                        */
if|if
condition|(
name|i
operator|>=
name|num_segs
operator|-
literal|1
operator|&&
name|start
operator|==
literal|0xFFFFU
operator|&&
name|end
operator|==
literal|0xFFFFU
condition|)
block|{
name|TT_Face
name|face
init|=
operator|(
name|TT_Face
operator|)
name|cmap
operator|->
name|cmap
operator|.
name|charmap
operator|.
name|face
decl_stmt|;
name|FT_Byte
modifier|*
name|limit
init|=
name|face
operator|->
name|cmap_table
operator|+
name|face
operator|->
name|cmap_size
decl_stmt|;
if|if
condition|(
name|offset
operator|&&
name|p
operator|+
name|offset
operator|+
literal|2
operator|>
name|limit
condition|)
block|{
name|delta
operator|=
literal|1
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|offset
operator|==
literal|0xFFFFU
condition|)
continue|continue;
if|if
condition|(
name|offset
condition|)
block|{
name|p
operator|+=
name|offset
operator|+
operator|(
name|charcode
operator|-
name|start
operator|)
operator|*
literal|2
expr_stmt|;
name|gindex
operator|=
name|TT_PEEK_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|gindex
operator|!=
literal|0
condition|)
name|gindex
operator|=
call|(
name|FT_UInt
call|)
argument_list|(
name|gindex
operator|+
name|delta
argument_list|)
operator|&
literal|0xFFFFU
expr_stmt|;
block|}
else|else
name|gindex
operator|=
call|(
name|FT_UInt
call|)
argument_list|(
name|charcode
operator|+
name|delta
argument_list|)
operator|&
literal|0xFFFFU
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|next
operator|||
name|gindex
condition|)
break|break;
block|}
if|if
condition|(
name|next
operator|&&
name|gindex
condition|)
operator|*
name|pcharcode
operator|=
name|charcode
expr_stmt|;
return|return
name|gindex
return|;
block|}
end_function
begin_function
specifier|static
name|FT_UInt
DECL|function|tt_cmap4_char_map_binary
name|tt_cmap4_char_map_binary
parameter_list|(
name|TT_CMap
name|cmap
parameter_list|,
name|FT_UInt32
modifier|*
name|pcharcode
parameter_list|,
name|FT_Bool
name|next
parameter_list|)
block|{
name|FT_UInt
name|num_segs2
decl_stmt|,
name|start
decl_stmt|,
name|end
decl_stmt|,
name|offset
decl_stmt|;
name|FT_Int
name|delta
decl_stmt|;
name|FT_UInt
name|max
decl_stmt|,
name|min
decl_stmt|,
name|mid
decl_stmt|,
name|num_segs
decl_stmt|;
name|FT_UInt
name|charcode
init|=
operator|(
name|FT_UInt
operator|)
operator|*
name|pcharcode
decl_stmt|;
name|FT_UInt
name|gindex
init|=
literal|0
decl_stmt|;
name|FT_Byte
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|cmap
operator|->
name|data
operator|+
literal|6
expr_stmt|;
name|num_segs2
operator|=
name|FT_PAD_FLOOR
argument_list|(
name|TT_PEEK_USHORT
argument_list|(
name|p
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|num_segs2
condition|)
return|return
literal|0
return|;
name|num_segs
operator|=
name|num_segs2
operator|>>
literal|1
expr_stmt|;
comment|/* make compiler happy */
name|mid
operator|=
name|num_segs
expr_stmt|;
name|end
operator|=
literal|0xFFFFU
expr_stmt|;
if|if
condition|(
name|next
condition|)
name|charcode
operator|++
expr_stmt|;
name|min
operator|=
literal|0
expr_stmt|;
name|max
operator|=
name|num_segs
expr_stmt|;
comment|/* binary search */
while|while
condition|(
name|min
operator|<
name|max
condition|)
block|{
name|mid
operator|=
operator|(
name|min
operator|+
name|max
operator|)
operator|>>
literal|1
expr_stmt|;
name|p
operator|=
name|cmap
operator|->
name|data
operator|+
literal|14
operator|+
name|mid
operator|*
literal|2
expr_stmt|;
name|end
operator|=
name|TT_PEEK_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|2
operator|+
name|num_segs2
expr_stmt|;
name|start
operator|=
name|TT_PEEK_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|charcode
operator|<
name|start
condition|)
name|max
operator|=
name|mid
expr_stmt|;
elseif|else
if|if
condition|(
name|charcode
operator|>
name|end
condition|)
name|min
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
else|else
block|{
name|p
operator|+=
name|num_segs2
expr_stmt|;
name|delta
operator|=
name|TT_PEEK_SHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
name|num_segs2
expr_stmt|;
name|offset
operator|=
name|TT_PEEK_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* some fonts have an incorrect last segment; */
comment|/* we have to catch it                        */
if|if
condition|(
name|mid
operator|>=
name|num_segs
operator|-
literal|1
operator|&&
name|start
operator|==
literal|0xFFFFU
operator|&&
name|end
operator|==
literal|0xFFFFU
condition|)
block|{
name|TT_Face
name|face
init|=
operator|(
name|TT_Face
operator|)
name|cmap
operator|->
name|cmap
operator|.
name|charmap
operator|.
name|face
decl_stmt|;
name|FT_Byte
modifier|*
name|limit
init|=
name|face
operator|->
name|cmap_table
operator|+
name|face
operator|->
name|cmap_size
decl_stmt|;
if|if
condition|(
name|offset
operator|&&
name|p
operator|+
name|offset
operator|+
literal|2
operator|>
name|limit
condition|)
block|{
name|delta
operator|=
literal|1
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* search the first segment containing `charcode' */
if|if
condition|(
name|cmap
operator|->
name|flags
operator|&
name|TT_CMAP_FLAG_OVERLAPPING
condition|)
block|{
name|FT_UInt
name|i
decl_stmt|;
comment|/* call the current segment `max' */
name|max
operator|=
name|mid
expr_stmt|;
if|if
condition|(
name|offset
operator|==
literal|0xFFFFU
condition|)
name|mid
operator|=
name|max
operator|+
literal|1
expr_stmt|;
comment|/* search in segments before the current segment */
for|for
control|(
name|i
operator|=
name|max
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|FT_UInt
name|prev_end
decl_stmt|;
name|FT_Byte
modifier|*
name|old_p
decl_stmt|;
name|old_p
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|cmap
operator|->
name|data
operator|+
literal|14
operator|+
operator|(
name|i
operator|-
literal|1
operator|)
operator|*
literal|2
expr_stmt|;
name|prev_end
operator|=
name|TT_PEEK_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|charcode
operator|>
name|prev_end
condition|)
block|{
name|p
operator|=
name|old_p
expr_stmt|;
break|break;
block|}
name|end
operator|=
name|prev_end
expr_stmt|;
name|p
operator|+=
literal|2
operator|+
name|num_segs2
expr_stmt|;
name|start
operator|=
name|TT_PEEK_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
name|num_segs2
expr_stmt|;
name|delta
operator|=
name|TT_PEEK_SHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
name|num_segs2
expr_stmt|;
name|offset
operator|=
name|TT_PEEK_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|!=
literal|0xFFFFU
condition|)
name|mid
operator|=
name|i
operator|-
literal|1
expr_stmt|;
block|}
comment|/* no luck */
if|if
condition|(
name|mid
operator|==
name|max
operator|+
literal|1
condition|)
block|{
if|if
condition|(
name|i
operator|!=
name|max
condition|)
block|{
name|p
operator|=
name|cmap
operator|->
name|data
operator|+
literal|14
operator|+
name|max
operator|*
literal|2
expr_stmt|;
name|end
operator|=
name|TT_PEEK_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|2
operator|+
name|num_segs2
expr_stmt|;
name|start
operator|=
name|TT_PEEK_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
name|num_segs2
expr_stmt|;
name|delta
operator|=
name|TT_PEEK_SHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
name|num_segs2
expr_stmt|;
name|offset
operator|=
name|TT_PEEK_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|mid
operator|=
name|max
expr_stmt|;
comment|/* search in segments after the current segment */
for|for
control|(
name|i
operator|=
name|max
operator|+
literal|1
init|;
name|i
operator|<
name|num_segs
condition|;
name|i
operator|++
control|)
block|{
name|FT_UInt
name|next_end
decl_stmt|,
name|next_start
decl_stmt|;
name|p
operator|=
name|cmap
operator|->
name|data
operator|+
literal|14
operator|+
name|i
operator|*
literal|2
expr_stmt|;
name|next_end
operator|=
name|TT_PEEK_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|2
operator|+
name|num_segs2
expr_stmt|;
name|next_start
operator|=
name|TT_PEEK_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|charcode
operator|<
name|next_start
condition|)
break|break;
name|end
operator|=
name|next_end
expr_stmt|;
name|start
operator|=
name|next_start
expr_stmt|;
name|p
operator|+=
name|num_segs2
expr_stmt|;
name|delta
operator|=
name|TT_PEEK_SHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
name|num_segs2
expr_stmt|;
name|offset
operator|=
name|TT_PEEK_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|!=
literal|0xFFFFU
condition|)
name|mid
operator|=
name|i
expr_stmt|;
block|}
name|i
operator|--
expr_stmt|;
comment|/* still no luck */
if|if
condition|(
name|mid
operator|==
name|max
condition|)
block|{
name|mid
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
comment|/* end, start, delta, and offset are for the i'th segment */
if|if
condition|(
name|mid
operator|!=
name|i
condition|)
block|{
name|p
operator|=
name|cmap
operator|->
name|data
operator|+
literal|14
operator|+
name|mid
operator|*
literal|2
expr_stmt|;
name|end
operator|=
name|TT_PEEK_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|2
operator|+
name|num_segs2
expr_stmt|;
name|start
operator|=
name|TT_PEEK_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
name|num_segs2
expr_stmt|;
name|delta
operator|=
name|TT_PEEK_SHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
name|num_segs2
expr_stmt|;
name|offset
operator|=
name|TT_PEEK_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|offset
operator|==
literal|0xFFFFU
condition|)
break|break;
block|}
if|if
condition|(
name|offset
condition|)
block|{
name|p
operator|+=
name|offset
operator|+
operator|(
name|charcode
operator|-
name|start
operator|)
operator|*
literal|2
expr_stmt|;
name|gindex
operator|=
name|TT_PEEK_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|gindex
operator|!=
literal|0
condition|)
name|gindex
operator|=
call|(
name|FT_UInt
call|)
argument_list|(
name|gindex
operator|+
name|delta
argument_list|)
operator|&
literal|0xFFFFU
expr_stmt|;
block|}
else|else
name|gindex
operator|=
call|(
name|FT_UInt
call|)
argument_list|(
name|charcode
operator|+
name|delta
argument_list|)
operator|&
literal|0xFFFFU
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|next
condition|)
block|{
name|TT_CMap4
name|cmap4
init|=
operator|(
name|TT_CMap4
operator|)
name|cmap
decl_stmt|;
comment|/* if `charcode' is not in any segment, then `mid' is */
comment|/* the segment nearest to `charcode'                  */
comment|/*                                                    */
if|if
condition|(
name|charcode
operator|>
name|end
condition|)
block|{
name|mid
operator|++
expr_stmt|;
if|if
condition|(
name|mid
operator|==
name|num_segs
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|tt_cmap4_set_range
argument_list|(
name|cmap4
argument_list|,
name|mid
argument_list|)
condition|)
block|{
if|if
condition|(
name|gindex
condition|)
operator|*
name|pcharcode
operator|=
name|charcode
expr_stmt|;
block|}
else|else
block|{
name|cmap4
operator|->
name|cur_charcode
operator|=
name|charcode
expr_stmt|;
if|if
condition|(
name|gindex
condition|)
name|cmap4
operator|->
name|cur_gindex
operator|=
name|gindex
expr_stmt|;
else|else
block|{
name|cmap4
operator|->
name|cur_charcode
operator|=
name|charcode
expr_stmt|;
name|tt_cmap4_next
argument_list|(
name|cmap4
argument_list|)
expr_stmt|;
name|gindex
operator|=
name|cmap4
operator|->
name|cur_gindex
expr_stmt|;
block|}
if|if
condition|(
name|gindex
condition|)
operator|*
name|pcharcode
operator|=
name|cmap4
operator|->
name|cur_charcode
expr_stmt|;
block|}
block|}
return|return
name|gindex
return|;
block|}
end_function
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_UInt
argument_list|)
end_macro
begin_macro
name|tt_cmap4_char_index
argument_list|(
argument|TT_CMap    cmap
argument_list|,
argument|FT_UInt32  char_code
argument_list|)
end_macro
begin_block
block|{
if|if
condition|(
name|char_code
operator|>=
literal|0x10000UL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|cmap
operator|->
name|flags
operator|&
name|TT_CMAP_FLAG_UNSORTED
condition|)
return|return
name|tt_cmap4_char_map_linear
argument_list|(
name|cmap
argument_list|,
operator|&
name|char_code
argument_list|,
literal|0
argument_list|)
return|;
else|else
return|return
name|tt_cmap4_char_map_binary
argument_list|(
name|cmap
argument_list|,
operator|&
name|char_code
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_block
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_UInt32
argument_list|)
end_macro
begin_macro
name|tt_cmap4_char_next
argument_list|(
argument|TT_CMap     cmap
argument_list|,
argument|FT_UInt32  *pchar_code
argument_list|)
end_macro
begin_block
block|{
name|FT_UInt
name|gindex
decl_stmt|;
if|if
condition|(
operator|*
name|pchar_code
operator|>=
literal|0xFFFFU
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|cmap
operator|->
name|flags
operator|&
name|TT_CMAP_FLAG_UNSORTED
condition|)
name|gindex
operator|=
name|tt_cmap4_char_map_linear
argument_list|(
name|cmap
argument_list|,
name|pchar_code
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
name|TT_CMap4
name|cmap4
init|=
operator|(
name|TT_CMap4
operator|)
name|cmap
decl_stmt|;
comment|/* no need to search */
if|if
condition|(
operator|*
name|pchar_code
operator|==
name|cmap4
operator|->
name|cur_charcode
condition|)
block|{
name|tt_cmap4_next
argument_list|(
name|cmap4
argument_list|)
expr_stmt|;
name|gindex
operator|=
name|cmap4
operator|->
name|cur_gindex
expr_stmt|;
if|if
condition|(
name|gindex
condition|)
operator|*
name|pchar_code
operator|=
name|cmap4
operator|->
name|cur_charcode
expr_stmt|;
block|}
else|else
name|gindex
operator|=
name|tt_cmap4_char_map_binary
argument_list|(
name|cmap
argument_list|,
name|pchar_code
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|gindex
return|;
block|}
end_block
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|tt_cmap4_get_info
argument_list|(
argument|TT_CMap       cmap
argument_list|,
argument|TT_CMapInfo  *cmap_info
argument_list|)
end_macro
begin_block
block|{
name|FT_Byte
modifier|*
name|p
init|=
name|cmap
operator|->
name|data
operator|+
literal|4
decl_stmt|;
name|cmap_info
operator|->
name|format
operator|=
literal|4
expr_stmt|;
name|cmap_info
operator|->
name|language
operator|=
operator|(
name|FT_ULong
operator|)
name|TT_PEEK_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|SFNT_Err_Ok
return|;
block|}
end_block
begin_macro
name|FT_DEFINE_TT_CMAP
argument_list|(
argument|tt_cmap4_class_rec
argument_list|,
argument|sizeof ( TT_CMap4Rec )
argument_list|,
argument|(FT_CMap_InitFunc)     tt_cmap4_init
argument_list|,
argument|(FT_CMap_DoneFunc)     NULL
argument_list|,
argument|(FT_CMap_CharIndexFunc)tt_cmap4_char_index
argument_list|,
argument|(FT_CMap_CharNextFunc) tt_cmap4_char_next
argument_list|,
argument|NULL
argument_list|,
argument|NULL
argument_list|,
argument|NULL
argument_list|,
argument|NULL
argument_list|,
argument|NULL
argument_list|,
literal|4
argument_list|,
argument|(TT_CMap_ValidateFunc)   tt_cmap4_validate
argument_list|,
argument|(TT_CMap_Info_GetFunc)   tt_cmap4_get_info
argument_list|)
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* TT_CONFIG_CMAP_FORMAT_4 */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****                          FORMAT 6                             *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* TABLE OVERVIEW                                                        */
end_comment
begin_comment
comment|/* --------------                                                        */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*   NAME        OFFSET          TYPE             DESCRIPTION            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*   format       0              USHORT           must be 4              */
end_comment
begin_comment
comment|/*   length       2              USHORT           table length in bytes  */
end_comment
begin_comment
comment|/*   language     4              USHORT           Mac language code      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*   first        6              USHORT           first segment code     */
end_comment
begin_comment
comment|/*   count        8              USHORT           segment size in chars  */
end_comment
begin_comment
comment|/*   glyphIds     10             USHORT[count]    glyph IDs              */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* A very simplified segment mapping.                                    */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|TT_CONFIG_CMAP_FORMAT_6
end_ifdef
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|tt_cmap6_validate
argument_list|(
argument|FT_Byte*      table
argument_list|,
argument|FT_Validator  valid
argument_list|)
end_macro
begin_block
block|{
name|FT_Byte
modifier|*
name|p
decl_stmt|;
name|FT_UInt
name|length
decl_stmt|,
name|count
decl_stmt|;
if|if
condition|(
name|table
operator|+
literal|10
operator|>
name|valid
operator|->
name|limit
condition|)
name|FT_INVALID_TOO_SHORT
expr_stmt|;
name|p
operator|=
name|table
operator|+
literal|2
expr_stmt|;
name|length
operator|=
name|TT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|table
operator|+
literal|8
expr_stmt|;
comment|/* skip language and start index */
name|count
operator|=
name|TT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|table
operator|+
name|length
operator|>
name|valid
operator|->
name|limit
operator|||
name|length
operator|<
literal|10
operator|+
name|count
operator|*
literal|2
condition|)
name|FT_INVALID_TOO_SHORT
expr_stmt|;
comment|/* check glyph indices */
if|if
condition|(
name|valid
operator|->
name|level
operator|>=
name|FT_VALIDATE_TIGHT
condition|)
block|{
name|FT_UInt
name|gindex
decl_stmt|;
for|for
control|(
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
control|)
block|{
name|gindex
operator|=
name|TT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|gindex
operator|>=
name|TT_VALID_GLYPH_COUNT
argument_list|(
name|valid
argument_list|)
condition|)
name|FT_INVALID_GLYPH_ID
expr_stmt|;
block|}
block|}
return|return
name|SFNT_Err_Ok
return|;
block|}
end_block
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_UInt
argument_list|)
end_macro
begin_macro
name|tt_cmap6_char_index
argument_list|(
argument|TT_CMap    cmap
argument_list|,
argument|FT_UInt32  char_code
argument_list|)
end_macro
begin_block
block|{
name|FT_Byte
modifier|*
name|table
init|=
name|cmap
operator|->
name|data
decl_stmt|;
name|FT_UInt
name|result
init|=
literal|0
decl_stmt|;
name|FT_Byte
modifier|*
name|p
init|=
name|table
operator|+
literal|6
decl_stmt|;
name|FT_UInt
name|start
init|=
name|TT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|FT_UInt
name|count
init|=
name|TT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|FT_UInt
name|idx
init|=
call|(
name|FT_UInt
call|)
argument_list|(
name|char_code
operator|-
name|start
argument_list|)
decl_stmt|;
if|if
condition|(
name|idx
operator|<
name|count
condition|)
block|{
name|p
operator|+=
literal|2
operator|*
name|idx
expr_stmt|;
name|result
operator|=
name|TT_PEEK_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_block
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_UInt32
argument_list|)
end_macro
begin_macro
name|tt_cmap6_char_next
argument_list|(
argument|TT_CMap     cmap
argument_list|,
argument|FT_UInt32  *pchar_code
argument_list|)
end_macro
begin_block
block|{
name|FT_Byte
modifier|*
name|table
init|=
name|cmap
operator|->
name|data
decl_stmt|;
name|FT_UInt32
name|result
init|=
literal|0
decl_stmt|;
name|FT_UInt32
name|char_code
init|=
operator|*
name|pchar_code
operator|+
literal|1
decl_stmt|;
name|FT_UInt
name|gindex
init|=
literal|0
decl_stmt|;
name|FT_Byte
modifier|*
name|p
init|=
name|table
operator|+
literal|6
decl_stmt|;
name|FT_UInt
name|start
init|=
name|TT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|FT_UInt
name|count
init|=
name|TT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|FT_UInt
name|idx
decl_stmt|;
if|if
condition|(
name|char_code
operator|>=
literal|0x10000UL
condition|)
goto|goto
name|Exit
goto|;
if|if
condition|(
name|char_code
operator|<
name|start
condition|)
name|char_code
operator|=
name|start
expr_stmt|;
name|idx
operator|=
call|(
name|FT_UInt
call|)
argument_list|(
name|char_code
operator|-
name|start
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|2
operator|*
name|idx
expr_stmt|;
for|for
control|(
init|;
name|idx
operator|<
name|count
condition|;
name|idx
operator|++
control|)
block|{
name|gindex
operator|=
name|TT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|gindex
operator|!=
literal|0
condition|)
block|{
name|result
operator|=
name|char_code
expr_stmt|;
break|break;
block|}
name|char_code
operator|++
expr_stmt|;
block|}
name|Exit
label|:
operator|*
name|pchar_code
operator|=
name|result
expr_stmt|;
return|return
name|gindex
return|;
block|}
end_block
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|tt_cmap6_get_info
argument_list|(
argument|TT_CMap       cmap
argument_list|,
argument|TT_CMapInfo  *cmap_info
argument_list|)
end_macro
begin_block
block|{
name|FT_Byte
modifier|*
name|p
init|=
name|cmap
operator|->
name|data
operator|+
literal|4
decl_stmt|;
name|cmap_info
operator|->
name|format
operator|=
literal|6
expr_stmt|;
name|cmap_info
operator|->
name|language
operator|=
operator|(
name|FT_ULong
operator|)
name|TT_PEEK_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|SFNT_Err_Ok
return|;
block|}
end_block
begin_macro
name|FT_DEFINE_TT_CMAP
argument_list|(
argument|tt_cmap6_class_rec
argument_list|,
argument|sizeof ( TT_CMapRec )
argument_list|,
argument|(FT_CMap_InitFunc)     tt_cmap_init
argument_list|,
argument|(FT_CMap_DoneFunc)     NULL
argument_list|,
argument|(FT_CMap_CharIndexFunc)tt_cmap6_char_index
argument_list|,
argument|(FT_CMap_CharNextFunc) tt_cmap6_char_next
argument_list|,
argument|NULL
argument_list|,
argument|NULL
argument_list|,
argument|NULL
argument_list|,
argument|NULL
argument_list|,
argument|NULL
argument_list|,
literal|6
argument_list|,
argument|(TT_CMap_ValidateFunc)   tt_cmap6_validate
argument_list|,
argument|(TT_CMap_Info_GetFunc)   tt_cmap6_get_info
argument_list|)
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* TT_CONFIG_CMAP_FORMAT_6 */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****                          FORMAT 8                             *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/***** It is hard to completely understand what the OpenType spec    *****/
end_comment
begin_comment
comment|/***** says about this format, but here is my conclusion.            *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/***** The purpose of this format is to easily map UTF-16 text to    *****/
end_comment
begin_comment
comment|/***** glyph indices.  Basically, the `char_code' must be in one of  *****/
end_comment
begin_comment
comment|/***** the following formats:                                        *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****   - A 16-bit value that isn't part of the Unicode Surrogates  *****/
end_comment
begin_comment
comment|/*****     Area (i.e. U+D800-U+DFFF).                                *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****   - A 32-bit value, made of two surrogate values, i.e.. if    *****/
end_comment
begin_comment
comment|/*****     `char_code = (char_hi<< 16) | char_lo', then both        *****/
end_comment
begin_comment
comment|/*****     `char_hi' and `char_lo' must be in the Surrogates Area.   *****/
end_comment
begin_comment
comment|/*****      Area.                                                    *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/***** The `is32' table embedded in the charmap indicates whether a  *****/
end_comment
begin_comment
comment|/***** given 16-bit value is in the surrogates area or not.          *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/***** So, for any given `char_code', we can assert the following:   *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****   If `char_hi == 0' then we must have `is32[char_lo] == 0'.   *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****   If `char_hi != 0' then we must have both                    *****/
end_comment
begin_comment
comment|/*****   `is32[char_hi] != 0' and `is32[char_lo] != 0'.              *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* TABLE OVERVIEW                                                        */
end_comment
begin_comment
comment|/* --------------                                                        */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*   NAME        OFFSET         TYPE        DESCRIPTION                  */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*   format      0              USHORT      must be 8                    */
end_comment
begin_comment
comment|/*   reserved    2              USHORT      reserved                     */
end_comment
begin_comment
comment|/*   length      4              ULONG       length in bytes              */
end_comment
begin_comment
comment|/*   language    8              ULONG       Mac language code            */
end_comment
begin_comment
comment|/*   is32        12             BYTE[8192]  32-bitness bitmap            */
end_comment
begin_comment
comment|/*   count       8204           ULONG       number of groups             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* This header is followed by `count' groups of the following format:    */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*   start       0              ULONG       first charcode               */
end_comment
begin_comment
comment|/*   end         4              ULONG       last charcode                */
end_comment
begin_comment
comment|/*   startId     8              ULONG       start glyph ID for the group */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|TT_CONFIG_CMAP_FORMAT_8
end_ifdef
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|tt_cmap8_validate
argument_list|(
argument|FT_Byte*      table
argument_list|,
argument|FT_Validator  valid
argument_list|)
end_macro
begin_block
block|{
name|FT_Byte
modifier|*
name|p
init|=
name|table
operator|+
literal|4
decl_stmt|;
name|FT_Byte
modifier|*
name|is32
decl_stmt|;
name|FT_UInt32
name|length
decl_stmt|;
name|FT_UInt32
name|num_groups
decl_stmt|;
if|if
condition|(
name|table
operator|+
literal|16
operator|+
literal|8192
operator|>
name|valid
operator|->
name|limit
condition|)
name|FT_INVALID_TOO_SHORT
expr_stmt|;
name|length
operator|=
name|TT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|>
call|(
name|FT_UInt32
call|)
argument_list|(
name|valid
operator|->
name|limit
operator|-
name|table
argument_list|)
operator|||
name|length
operator|<
literal|8192
operator|+
literal|16
condition|)
name|FT_INVALID_TOO_SHORT
expr_stmt|;
name|is32
operator|=
name|table
operator|+
literal|12
expr_stmt|;
name|p
operator|=
name|is32
operator|+
literal|8192
expr_stmt|;
comment|/* skip `is32' array */
name|num_groups
operator|=
name|TT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|+
name|num_groups
operator|*
literal|12
operator|>
name|valid
operator|->
name|limit
condition|)
name|FT_INVALID_TOO_SHORT
expr_stmt|;
comment|/* check groups, they must be in increasing order */
block|{
name|FT_UInt32
name|n
decl_stmt|,
name|start
decl_stmt|,
name|end
decl_stmt|,
name|start_id
decl_stmt|,
name|count
decl_stmt|,
name|last
init|=
literal|0
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|num_groups
condition|;
name|n
operator|++
control|)
block|{
name|FT_UInt
name|hi
decl_stmt|,
name|lo
decl_stmt|;
name|start
operator|=
name|TT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|end
operator|=
name|TT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|start_id
operator|=
name|TT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|start
operator|>
name|end
condition|)
name|FT_INVALID_DATA
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
operator|&&
name|start
operator|<=
name|last
condition|)
name|FT_INVALID_DATA
expr_stmt|;
if|if
condition|(
name|valid
operator|->
name|level
operator|>=
name|FT_VALIDATE_TIGHT
condition|)
block|{
if|if
condition|(
name|start_id
operator|+
name|end
operator|-
name|start
operator|>=
name|TT_VALID_GLYPH_COUNT
argument_list|(
name|valid
argument_list|)
condition|)
name|FT_INVALID_GLYPH_ID
expr_stmt|;
name|count
operator|=
call|(
name|FT_UInt32
call|)
argument_list|(
name|end
operator|-
name|start
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|start
operator|&
operator|~
literal|0xFFFFU
condition|)
block|{
comment|/* start_hi != 0; check that is32[i] is 1 for each i in */
comment|/* the `hi' and `lo' of the range [start..end]          */
for|for
control|(
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
operator|,
name|start
operator|++
control|)
block|{
name|hi
operator|=
call|(
name|FT_UInt
call|)
argument_list|(
name|start
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|lo
operator|=
call|(
name|FT_UInt
call|)
argument_list|(
name|start
operator|&
literal|0xFFFFU
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|is32
index|[
name|hi
operator|>>
literal|3
index|]
operator|&
operator|(
literal|0x80
operator|>>
operator|(
name|hi
operator|&
literal|7
operator|)
operator|)
operator|)
operator|==
literal|0
condition|)
name|FT_INVALID_DATA
expr_stmt|;
if|if
condition|(
operator|(
name|is32
index|[
name|lo
operator|>>
literal|3
index|]
operator|&
operator|(
literal|0x80
operator|>>
operator|(
name|lo
operator|&
literal|7
operator|)
operator|)
operator|)
operator|==
literal|0
condition|)
name|FT_INVALID_DATA
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* start_hi == 0; check that is32[i] is 0 for each i in */
comment|/* the range [start..end]                               */
comment|/* end_hi cannot be != 0! */
if|if
condition|(
name|end
operator|&
operator|~
literal|0xFFFFU
condition|)
name|FT_INVALID_DATA
expr_stmt|;
for|for
control|(
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
operator|,
name|start
operator|++
control|)
block|{
name|lo
operator|=
call|(
name|FT_UInt
call|)
argument_list|(
name|start
operator|&
literal|0xFFFFU
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|is32
index|[
name|lo
operator|>>
literal|3
index|]
operator|&
operator|(
literal|0x80
operator|>>
operator|(
name|lo
operator|&
literal|7
operator|)
operator|)
operator|)
operator|!=
literal|0
condition|)
name|FT_INVALID_DATA
expr_stmt|;
block|}
block|}
block|}
name|last
operator|=
name|end
expr_stmt|;
block|}
block|}
return|return
name|SFNT_Err_Ok
return|;
block|}
end_block
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_UInt
argument_list|)
end_macro
begin_macro
name|tt_cmap8_char_index
argument_list|(
argument|TT_CMap    cmap
argument_list|,
argument|FT_UInt32  char_code
argument_list|)
end_macro
begin_block
block|{
name|FT_Byte
modifier|*
name|table
init|=
name|cmap
operator|->
name|data
decl_stmt|;
name|FT_UInt
name|result
init|=
literal|0
decl_stmt|;
name|FT_Byte
modifier|*
name|p
init|=
name|table
operator|+
literal|8204
decl_stmt|;
name|FT_UInt32
name|num_groups
init|=
name|TT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|FT_UInt32
name|start
decl_stmt|,
name|end
decl_stmt|,
name|start_id
decl_stmt|;
for|for
control|(
init|;
name|num_groups
operator|>
literal|0
condition|;
name|num_groups
operator|--
control|)
block|{
name|start
operator|=
name|TT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|end
operator|=
name|TT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|start_id
operator|=
name|TT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|char_code
operator|<
name|start
condition|)
break|break;
if|if
condition|(
name|char_code
operator|<=
name|end
condition|)
block|{
name|result
operator|=
call|(
name|FT_UInt
call|)
argument_list|(
name|start_id
operator|+
name|char_code
operator|-
name|start
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|result
return|;
block|}
end_block
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_UInt32
argument_list|)
end_macro
begin_macro
name|tt_cmap8_char_next
argument_list|(
argument|TT_CMap     cmap
argument_list|,
argument|FT_UInt32  *pchar_code
argument_list|)
end_macro
begin_block
block|{
name|FT_UInt32
name|result
init|=
literal|0
decl_stmt|;
name|FT_UInt32
name|char_code
init|=
operator|*
name|pchar_code
operator|+
literal|1
decl_stmt|;
name|FT_UInt
name|gindex
init|=
literal|0
decl_stmt|;
name|FT_Byte
modifier|*
name|table
init|=
name|cmap
operator|->
name|data
decl_stmt|;
name|FT_Byte
modifier|*
name|p
init|=
name|table
operator|+
literal|8204
decl_stmt|;
name|FT_UInt32
name|num_groups
init|=
name|TT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|FT_UInt32
name|start
decl_stmt|,
name|end
decl_stmt|,
name|start_id
decl_stmt|;
name|p
operator|=
name|table
operator|+
literal|8208
expr_stmt|;
for|for
control|(
init|;
name|num_groups
operator|>
literal|0
condition|;
name|num_groups
operator|--
control|)
block|{
name|start
operator|=
name|TT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|end
operator|=
name|TT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|start_id
operator|=
name|TT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|char_code
operator|<
name|start
condition|)
name|char_code
operator|=
name|start
expr_stmt|;
if|if
condition|(
name|char_code
operator|<=
name|end
condition|)
block|{
name|gindex
operator|=
call|(
name|FT_UInt
call|)
argument_list|(
name|char_code
operator|-
name|start
operator|+
name|start_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|gindex
operator|!=
literal|0
condition|)
block|{
name|result
operator|=
name|char_code
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
block|}
name|Exit
label|:
operator|*
name|pchar_code
operator|=
name|result
expr_stmt|;
return|return
name|gindex
return|;
block|}
end_block
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|tt_cmap8_get_info
argument_list|(
argument|TT_CMap       cmap
argument_list|,
argument|TT_CMapInfo  *cmap_info
argument_list|)
end_macro
begin_block
block|{
name|FT_Byte
modifier|*
name|p
init|=
name|cmap
operator|->
name|data
operator|+
literal|8
decl_stmt|;
name|cmap_info
operator|->
name|format
operator|=
literal|8
expr_stmt|;
name|cmap_info
operator|->
name|language
operator|=
operator|(
name|FT_ULong
operator|)
name|TT_PEEK_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|SFNT_Err_Ok
return|;
block|}
end_block
begin_macro
name|FT_DEFINE_TT_CMAP
argument_list|(
argument|tt_cmap8_class_rec
argument_list|,
argument|sizeof ( TT_CMapRec )
argument_list|,
argument|(FT_CMap_InitFunc)     tt_cmap_init
argument_list|,
argument|(FT_CMap_DoneFunc)     NULL
argument_list|,
argument|(FT_CMap_CharIndexFunc)tt_cmap8_char_index
argument_list|,
argument|(FT_CMap_CharNextFunc) tt_cmap8_char_next
argument_list|,
argument|NULL
argument_list|,
argument|NULL
argument_list|,
argument|NULL
argument_list|,
argument|NULL
argument_list|,
argument|NULL
argument_list|,
literal|8
argument_list|,
argument|(TT_CMap_ValidateFunc)   tt_cmap8_validate
argument_list|,
argument|(TT_CMap_Info_GetFunc)   tt_cmap8_get_info
argument_list|)
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* TT_CONFIG_CMAP_FORMAT_8 */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****                          FORMAT 10                            *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* TABLE OVERVIEW                                                        */
end_comment
begin_comment
comment|/* --------------                                                        */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*   NAME      OFFSET  TYPE               DESCRIPTION                    */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*   format     0      USHORT             must be 10                     */
end_comment
begin_comment
comment|/*   reserved   2      USHORT             reserved                       */
end_comment
begin_comment
comment|/*   length     4      ULONG              length in bytes                */
end_comment
begin_comment
comment|/*   language   8      ULONG              Mac language code              */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*   start     12      ULONG              first char in range            */
end_comment
begin_comment
comment|/*   count     16      ULONG              number of chars in range       */
end_comment
begin_comment
comment|/*   glyphIds  20      USHORT[count]      glyph indices covered          */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|TT_CONFIG_CMAP_FORMAT_10
end_ifdef
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|tt_cmap10_validate
argument_list|(
argument|FT_Byte*      table
argument_list|,
argument|FT_Validator  valid
argument_list|)
end_macro
begin_block
block|{
name|FT_Byte
modifier|*
name|p
init|=
name|table
operator|+
literal|4
decl_stmt|;
name|FT_ULong
name|length
decl_stmt|,
name|count
decl_stmt|;
if|if
condition|(
name|table
operator|+
literal|20
operator|>
name|valid
operator|->
name|limit
condition|)
name|FT_INVALID_TOO_SHORT
expr_stmt|;
name|length
operator|=
name|TT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|table
operator|+
literal|16
expr_stmt|;
name|count
operator|=
name|TT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|>
call|(
name|FT_ULong
call|)
argument_list|(
name|valid
operator|->
name|limit
operator|-
name|table
argument_list|)
operator|||
name|length
operator|<
literal|20
operator|+
name|count
operator|*
literal|2
condition|)
name|FT_INVALID_TOO_SHORT
expr_stmt|;
comment|/* check glyph indices */
if|if
condition|(
name|valid
operator|->
name|level
operator|>=
name|FT_VALIDATE_TIGHT
condition|)
block|{
name|FT_UInt
name|gindex
decl_stmt|;
for|for
control|(
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
control|)
block|{
name|gindex
operator|=
name|TT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|gindex
operator|>=
name|TT_VALID_GLYPH_COUNT
argument_list|(
name|valid
argument_list|)
condition|)
name|FT_INVALID_GLYPH_ID
expr_stmt|;
block|}
block|}
return|return
name|SFNT_Err_Ok
return|;
block|}
end_block
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_UInt
argument_list|)
end_macro
begin_macro
name|tt_cmap10_char_index
argument_list|(
argument|TT_CMap    cmap
argument_list|,
argument|FT_UInt32  char_code
argument_list|)
end_macro
begin_block
block|{
name|FT_Byte
modifier|*
name|table
init|=
name|cmap
operator|->
name|data
decl_stmt|;
name|FT_UInt
name|result
init|=
literal|0
decl_stmt|;
name|FT_Byte
modifier|*
name|p
init|=
name|table
operator|+
literal|12
decl_stmt|;
name|FT_UInt32
name|start
init|=
name|TT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|FT_UInt32
name|count
init|=
name|TT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|FT_UInt32
name|idx
init|=
call|(
name|FT_ULong
call|)
argument_list|(
name|char_code
operator|-
name|start
argument_list|)
decl_stmt|;
if|if
condition|(
name|idx
operator|<
name|count
condition|)
block|{
name|p
operator|+=
literal|2
operator|*
name|idx
expr_stmt|;
name|result
operator|=
name|TT_PEEK_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_block
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_UInt32
argument_list|)
end_macro
begin_macro
name|tt_cmap10_char_next
argument_list|(
argument|TT_CMap     cmap
argument_list|,
argument|FT_UInt32  *pchar_code
argument_list|)
end_macro
begin_block
block|{
name|FT_Byte
modifier|*
name|table
init|=
name|cmap
operator|->
name|data
decl_stmt|;
name|FT_UInt32
name|char_code
init|=
operator|*
name|pchar_code
operator|+
literal|1
decl_stmt|;
name|FT_UInt
name|gindex
init|=
literal|0
decl_stmt|;
name|FT_Byte
modifier|*
name|p
init|=
name|table
operator|+
literal|12
decl_stmt|;
name|FT_UInt32
name|start
init|=
name|TT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|FT_UInt32
name|count
init|=
name|TT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|FT_UInt32
name|idx
decl_stmt|;
if|if
condition|(
name|char_code
operator|<
name|start
condition|)
name|char_code
operator|=
name|start
expr_stmt|;
name|idx
operator|=
call|(
name|FT_UInt32
call|)
argument_list|(
name|char_code
operator|-
name|start
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|2
operator|*
name|idx
expr_stmt|;
for|for
control|(
init|;
name|idx
operator|<
name|count
condition|;
name|idx
operator|++
control|)
block|{
name|gindex
operator|=
name|TT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|gindex
operator|!=
literal|0
condition|)
break|break;
name|char_code
operator|++
expr_stmt|;
block|}
operator|*
name|pchar_code
operator|=
name|char_code
expr_stmt|;
return|return
name|gindex
return|;
block|}
end_block
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|tt_cmap10_get_info
argument_list|(
argument|TT_CMap       cmap
argument_list|,
argument|TT_CMapInfo  *cmap_info
argument_list|)
end_macro
begin_block
block|{
name|FT_Byte
modifier|*
name|p
init|=
name|cmap
operator|->
name|data
operator|+
literal|8
decl_stmt|;
name|cmap_info
operator|->
name|format
operator|=
literal|10
expr_stmt|;
name|cmap_info
operator|->
name|language
operator|=
operator|(
name|FT_ULong
operator|)
name|TT_PEEK_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|SFNT_Err_Ok
return|;
block|}
end_block
begin_macro
name|FT_DEFINE_TT_CMAP
argument_list|(
argument|tt_cmap10_class_rec
argument_list|,
argument|sizeof ( TT_CMapRec )
argument_list|,
argument|(FT_CMap_InitFunc)     tt_cmap_init
argument_list|,
argument|(FT_CMap_DoneFunc)     NULL
argument_list|,
argument|(FT_CMap_CharIndexFunc)tt_cmap10_char_index
argument_list|,
argument|(FT_CMap_CharNextFunc) tt_cmap10_char_next
argument_list|,
argument|NULL
argument_list|,
argument|NULL
argument_list|,
argument|NULL
argument_list|,
argument|NULL
argument_list|,
argument|NULL
argument_list|,
literal|10
argument_list|,
argument|(TT_CMap_ValidateFunc)   tt_cmap10_validate
argument_list|,
argument|(TT_CMap_Info_GetFunc)   tt_cmap10_get_info
argument_list|)
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* TT_CONFIG_CMAP_FORMAT_10 */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****                          FORMAT 12                            *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* TABLE OVERVIEW                                                        */
end_comment
begin_comment
comment|/* --------------                                                        */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*   NAME        OFFSET     TYPE       DESCRIPTION                       */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*   format      0          USHORT     must be 12                        */
end_comment
begin_comment
comment|/*   reserved    2          USHORT     reserved                          */
end_comment
begin_comment
comment|/*   length      4          ULONG      length in bytes                   */
end_comment
begin_comment
comment|/*   language    8          ULONG      Mac language code                 */
end_comment
begin_comment
comment|/*   count       12         ULONG      number of groups                  */
end_comment
begin_comment
comment|/*               16                                                      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* This header is followed by `count' groups of the following format:    */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*   start       0          ULONG      first charcode                    */
end_comment
begin_comment
comment|/*   end         4          ULONG      last charcode                     */
end_comment
begin_comment
comment|/*   startId     8          ULONG      start glyph ID for the group      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|TT_CONFIG_CMAP_FORMAT_12
end_ifdef
begin_typedef
DECL|struct|TT_CMap12Rec_
typedef|typedef
struct|struct
name|TT_CMap12Rec_
block|{
DECL|member|cmap
name|TT_CMapRec
name|cmap
decl_stmt|;
DECL|member|valid
name|FT_Bool
name|valid
decl_stmt|;
DECL|member|cur_charcode
name|FT_ULong
name|cur_charcode
decl_stmt|;
DECL|member|cur_gindex
name|FT_UInt
name|cur_gindex
decl_stmt|;
DECL|member|cur_group
name|FT_ULong
name|cur_group
decl_stmt|;
DECL|member|num_groups
name|FT_ULong
name|num_groups
decl_stmt|;
block|}
DECL|typedef|TT_CMap12Rec
DECL|typedef|TT_CMap12
name|TT_CMap12Rec
operator|,
typedef|*
name|TT_CMap12
typedef|;
end_typedef
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|tt_cmap12_init
argument_list|(
argument|TT_CMap12  cmap
argument_list|,
argument|FT_Byte*   table
argument_list|)
end_macro
begin_block
block|{
name|cmap
operator|->
name|cmap
operator|.
name|data
operator|=
name|table
expr_stmt|;
name|table
operator|+=
literal|12
expr_stmt|;
name|cmap
operator|->
name|num_groups
operator|=
name|FT_PEEK_ULONG
argument_list|(
name|table
argument_list|)
expr_stmt|;
name|cmap
operator|->
name|valid
operator|=
literal|0
expr_stmt|;
return|return
name|SFNT_Err_Ok
return|;
block|}
end_block
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|tt_cmap12_validate
argument_list|(
argument|FT_Byte*      table
argument_list|,
argument|FT_Validator  valid
argument_list|)
end_macro
begin_block
block|{
name|FT_Byte
modifier|*
name|p
decl_stmt|;
name|FT_ULong
name|length
decl_stmt|;
name|FT_ULong
name|num_groups
decl_stmt|;
if|if
condition|(
name|table
operator|+
literal|16
operator|>
name|valid
operator|->
name|limit
condition|)
name|FT_INVALID_TOO_SHORT
expr_stmt|;
name|p
operator|=
name|table
operator|+
literal|4
expr_stmt|;
name|length
operator|=
name|TT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|table
operator|+
literal|12
expr_stmt|;
name|num_groups
operator|=
name|TT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|>
call|(
name|FT_ULong
call|)
argument_list|(
name|valid
operator|->
name|limit
operator|-
name|table
argument_list|)
operator|||
name|length
operator|<
literal|16
operator|+
literal|12
operator|*
name|num_groups
condition|)
name|FT_INVALID_TOO_SHORT
expr_stmt|;
comment|/* check groups, they must be in increasing order */
block|{
name|FT_ULong
name|n
decl_stmt|,
name|start
decl_stmt|,
name|end
decl_stmt|,
name|start_id
decl_stmt|,
name|last
init|=
literal|0
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|num_groups
condition|;
name|n
operator|++
control|)
block|{
name|start
operator|=
name|TT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|end
operator|=
name|TT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|start_id
operator|=
name|TT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|start
operator|>
name|end
condition|)
name|FT_INVALID_DATA
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
operator|&&
name|start
operator|<=
name|last
condition|)
name|FT_INVALID_DATA
expr_stmt|;
if|if
condition|(
name|valid
operator|->
name|level
operator|>=
name|FT_VALIDATE_TIGHT
condition|)
block|{
if|if
condition|(
name|start_id
operator|+
name|end
operator|-
name|start
operator|>=
name|TT_VALID_GLYPH_COUNT
argument_list|(
name|valid
argument_list|)
condition|)
name|FT_INVALID_GLYPH_ID
expr_stmt|;
block|}
name|last
operator|=
name|end
expr_stmt|;
block|}
block|}
return|return
name|SFNT_Err_Ok
return|;
block|}
end_block
begin_comment
comment|/* search the index of the charcode next to cmap->cur_charcode */
end_comment
begin_comment
comment|/* cmap->cur_group should be set up properly by caller         */
end_comment
begin_comment
comment|/*                                                             */
end_comment
begin_function
specifier|static
name|void
DECL|function|tt_cmap12_next
name|tt_cmap12_next
parameter_list|(
name|TT_CMap12
name|cmap
parameter_list|)
block|{
name|FT_Byte
modifier|*
name|p
decl_stmt|;
name|FT_ULong
name|start
decl_stmt|,
name|end
decl_stmt|,
name|start_id
decl_stmt|,
name|char_code
decl_stmt|;
name|FT_ULong
name|n
decl_stmt|;
name|FT_UInt
name|gindex
decl_stmt|;
if|if
condition|(
name|cmap
operator|->
name|cur_charcode
operator|>=
literal|0xFFFFFFFFUL
condition|)
goto|goto
name|Fail
goto|;
name|char_code
operator|=
name|cmap
operator|->
name|cur_charcode
operator|+
literal|1
expr_stmt|;
name|n
operator|=
name|cmap
operator|->
name|cur_group
expr_stmt|;
for|for
control|(
name|n
operator|=
name|cmap
operator|->
name|cur_group
init|;
name|n
operator|<
name|cmap
operator|->
name|num_groups
condition|;
name|n
operator|++
control|)
block|{
name|p
operator|=
name|cmap
operator|->
name|cmap
operator|.
name|data
operator|+
literal|16
operator|+
literal|12
operator|*
name|n
expr_stmt|;
name|start
operator|=
name|TT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|end
operator|=
name|TT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|start_id
operator|=
name|TT_PEEK_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|char_code
operator|<
name|start
condition|)
name|char_code
operator|=
name|start
expr_stmt|;
for|for
control|(
init|;
name|char_code
operator|<=
name|end
condition|;
name|char_code
operator|++
control|)
block|{
name|gindex
operator|=
call|(
name|FT_UInt
call|)
argument_list|(
name|start_id
operator|+
name|char_code
operator|-
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|gindex
condition|)
block|{
name|cmap
operator|->
name|cur_charcode
operator|=
name|char_code
expr_stmt|;
empty_stmt|;
name|cmap
operator|->
name|cur_gindex
operator|=
name|gindex
expr_stmt|;
name|cmap
operator|->
name|cur_group
operator|=
name|n
expr_stmt|;
return|return;
block|}
block|}
block|}
name|Fail
label|:
name|cmap
operator|->
name|valid
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|FT_UInt
DECL|function|tt_cmap12_char_map_binary
name|tt_cmap12_char_map_binary
parameter_list|(
name|TT_CMap
name|cmap
parameter_list|,
name|FT_UInt32
modifier|*
name|pchar_code
parameter_list|,
name|FT_Bool
name|next
parameter_list|)
block|{
name|FT_UInt
name|gindex
init|=
literal|0
decl_stmt|;
name|FT_Byte
modifier|*
name|p
init|=
name|cmap
operator|->
name|data
operator|+
literal|12
decl_stmt|;
name|FT_UInt32
name|num_groups
init|=
name|TT_PEEK_ULONG
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|FT_UInt32
name|char_code
init|=
operator|*
name|pchar_code
decl_stmt|;
name|FT_UInt32
name|start
decl_stmt|,
name|end
decl_stmt|,
name|start_id
decl_stmt|;
name|FT_UInt32
name|max
decl_stmt|,
name|min
decl_stmt|,
name|mid
decl_stmt|;
if|if
condition|(
operator|!
name|num_groups
condition|)
return|return
literal|0
return|;
comment|/* make compiler happy */
name|mid
operator|=
name|num_groups
expr_stmt|;
name|end
operator|=
literal|0xFFFFFFFFUL
expr_stmt|;
if|if
condition|(
name|next
condition|)
name|char_code
operator|++
expr_stmt|;
name|min
operator|=
literal|0
expr_stmt|;
name|max
operator|=
name|num_groups
expr_stmt|;
comment|/* binary search */
while|while
condition|(
name|min
operator|<
name|max
condition|)
block|{
name|mid
operator|=
operator|(
name|min
operator|+
name|max
operator|)
operator|>>
literal|1
expr_stmt|;
name|p
operator|=
name|cmap
operator|->
name|data
operator|+
literal|16
operator|+
literal|12
operator|*
name|mid
expr_stmt|;
name|start
operator|=
name|TT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|end
operator|=
name|TT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|char_code
operator|<
name|start
condition|)
name|max
operator|=
name|mid
expr_stmt|;
elseif|else
if|if
condition|(
name|char_code
operator|>
name|end
condition|)
name|min
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
else|else
block|{
name|start_id
operator|=
name|TT_PEEK_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|gindex
operator|=
call|(
name|FT_UInt
call|)
argument_list|(
name|start_id
operator|+
name|char_code
operator|-
name|start
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|next
condition|)
block|{
name|TT_CMap12
name|cmap12
init|=
operator|(
name|TT_CMap12
operator|)
name|cmap
decl_stmt|;
comment|/* if `char_code' is not in any group, then `mid' is */
comment|/* the group nearest to `char_code'                  */
comment|/*                                                   */
if|if
condition|(
name|char_code
operator|>
name|end
condition|)
block|{
name|mid
operator|++
expr_stmt|;
if|if
condition|(
name|mid
operator|==
name|num_groups
condition|)
return|return
literal|0
return|;
block|}
name|cmap12
operator|->
name|valid
operator|=
literal|1
expr_stmt|;
name|cmap12
operator|->
name|cur_charcode
operator|=
name|char_code
expr_stmt|;
name|cmap12
operator|->
name|cur_group
operator|=
name|mid
expr_stmt|;
if|if
condition|(
operator|!
name|gindex
condition|)
block|{
name|tt_cmap12_next
argument_list|(
name|cmap12
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmap12
operator|->
name|valid
condition|)
name|gindex
operator|=
name|cmap12
operator|->
name|cur_gindex
expr_stmt|;
block|}
else|else
name|cmap12
operator|->
name|cur_gindex
operator|=
name|gindex
expr_stmt|;
if|if
condition|(
name|gindex
condition|)
operator|*
name|pchar_code
operator|=
name|cmap12
operator|->
name|cur_charcode
expr_stmt|;
block|}
return|return
name|gindex
return|;
block|}
end_function
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_UInt
argument_list|)
end_macro
begin_macro
name|tt_cmap12_char_index
argument_list|(
argument|TT_CMap    cmap
argument_list|,
argument|FT_UInt32  char_code
argument_list|)
end_macro
begin_block
block|{
return|return
name|tt_cmap12_char_map_binary
argument_list|(
name|cmap
argument_list|,
operator|&
name|char_code
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_block
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_UInt32
argument_list|)
end_macro
begin_macro
name|tt_cmap12_char_next
argument_list|(
argument|TT_CMap     cmap
argument_list|,
argument|FT_UInt32  *pchar_code
argument_list|)
end_macro
begin_block
block|{
name|TT_CMap12
name|cmap12
init|=
operator|(
name|TT_CMap12
operator|)
name|cmap
decl_stmt|;
name|FT_ULong
name|gindex
decl_stmt|;
if|if
condition|(
name|cmap12
operator|->
name|cur_charcode
operator|>=
literal|0xFFFFFFFFUL
condition|)
return|return
literal|0
return|;
comment|/* no need to search */
if|if
condition|(
name|cmap12
operator|->
name|valid
operator|&&
name|cmap12
operator|->
name|cur_charcode
operator|==
operator|*
name|pchar_code
condition|)
block|{
name|tt_cmap12_next
argument_list|(
name|cmap12
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmap12
operator|->
name|valid
condition|)
block|{
name|gindex
operator|=
name|cmap12
operator|->
name|cur_gindex
expr_stmt|;
comment|/* XXX: check cur_charcode overflow is expected */
if|if
condition|(
name|gindex
condition|)
operator|*
name|pchar_code
operator|=
operator|(
name|FT_UInt32
operator|)
name|cmap12
operator|->
name|cur_charcode
expr_stmt|;
block|}
else|else
name|gindex
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|gindex
operator|=
name|tt_cmap12_char_map_binary
argument_list|(
name|cmap
argument_list|,
name|pchar_code
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* XXX: check gindex overflow is expected */
return|return
operator|(
name|FT_UInt32
operator|)
name|gindex
return|;
block|}
end_block
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|tt_cmap12_get_info
argument_list|(
argument|TT_CMap       cmap
argument_list|,
argument|TT_CMapInfo  *cmap_info
argument_list|)
end_macro
begin_block
block|{
name|FT_Byte
modifier|*
name|p
init|=
name|cmap
operator|->
name|data
operator|+
literal|8
decl_stmt|;
name|cmap_info
operator|->
name|format
operator|=
literal|12
expr_stmt|;
name|cmap_info
operator|->
name|language
operator|=
operator|(
name|FT_ULong
operator|)
name|TT_PEEK_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|SFNT_Err_Ok
return|;
block|}
end_block
begin_macro
name|FT_DEFINE_TT_CMAP
argument_list|(
argument|tt_cmap12_class_rec
argument_list|,
argument|sizeof ( TT_CMap12Rec )
argument_list|,
argument|(FT_CMap_InitFunc)     tt_cmap12_init
argument_list|,
argument|(FT_CMap_DoneFunc)     NULL
argument_list|,
argument|(FT_CMap_CharIndexFunc)tt_cmap12_char_index
argument_list|,
argument|(FT_CMap_CharNextFunc) tt_cmap12_char_next
argument_list|,
argument|NULL
argument_list|,
argument|NULL
argument_list|,
argument|NULL
argument_list|,
argument|NULL
argument_list|,
argument|NULL
argument_list|,
literal|12
argument_list|,
argument|(TT_CMap_ValidateFunc)   tt_cmap12_validate
argument_list|,
argument|(TT_CMap_Info_GetFunc)   tt_cmap12_get_info
argument_list|)
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* TT_CONFIG_CMAP_FORMAT_12 */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****                          FORMAT 13                            *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* TABLE OVERVIEW                                                        */
end_comment
begin_comment
comment|/* --------------                                                        */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*   NAME        OFFSET     TYPE       DESCRIPTION                       */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*   format      0          USHORT     must be 13                        */
end_comment
begin_comment
comment|/*   reserved    2          USHORT     reserved                          */
end_comment
begin_comment
comment|/*   length      4          ULONG      length in bytes                   */
end_comment
begin_comment
comment|/*   language    8          ULONG      Mac language code                 */
end_comment
begin_comment
comment|/*   count       12         ULONG      number of groups                  */
end_comment
begin_comment
comment|/*               16                                                      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* This header is followed by `count' groups of the following format:    */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*   start       0          ULONG      first charcode                    */
end_comment
begin_comment
comment|/*   end         4          ULONG      last charcode                     */
end_comment
begin_comment
comment|/*   glyphId     8          ULONG      glyph ID for the whole group      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|TT_CONFIG_CMAP_FORMAT_13
end_ifdef
begin_typedef
DECL|struct|TT_CMap13Rec_
typedef|typedef
struct|struct
name|TT_CMap13Rec_
block|{
DECL|member|cmap
name|TT_CMapRec
name|cmap
decl_stmt|;
DECL|member|valid
name|FT_Bool
name|valid
decl_stmt|;
DECL|member|cur_charcode
name|FT_ULong
name|cur_charcode
decl_stmt|;
DECL|member|cur_gindex
name|FT_UInt
name|cur_gindex
decl_stmt|;
DECL|member|cur_group
name|FT_ULong
name|cur_group
decl_stmt|;
DECL|member|num_groups
name|FT_ULong
name|num_groups
decl_stmt|;
block|}
DECL|typedef|TT_CMap13Rec
DECL|typedef|TT_CMap13
name|TT_CMap13Rec
operator|,
typedef|*
name|TT_CMap13
typedef|;
end_typedef
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|tt_cmap13_init
argument_list|(
argument|TT_CMap13  cmap
argument_list|,
argument|FT_Byte*   table
argument_list|)
end_macro
begin_block
block|{
name|cmap
operator|->
name|cmap
operator|.
name|data
operator|=
name|table
expr_stmt|;
name|table
operator|+=
literal|12
expr_stmt|;
name|cmap
operator|->
name|num_groups
operator|=
name|FT_PEEK_ULONG
argument_list|(
name|table
argument_list|)
expr_stmt|;
name|cmap
operator|->
name|valid
operator|=
literal|0
expr_stmt|;
return|return
name|SFNT_Err_Ok
return|;
block|}
end_block
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|tt_cmap13_validate
argument_list|(
argument|FT_Byte*      table
argument_list|,
argument|FT_Validator  valid
argument_list|)
end_macro
begin_block
block|{
name|FT_Byte
modifier|*
name|p
decl_stmt|;
name|FT_ULong
name|length
decl_stmt|;
name|FT_ULong
name|num_groups
decl_stmt|;
if|if
condition|(
name|table
operator|+
literal|16
operator|>
name|valid
operator|->
name|limit
condition|)
name|FT_INVALID_TOO_SHORT
expr_stmt|;
name|p
operator|=
name|table
operator|+
literal|4
expr_stmt|;
name|length
operator|=
name|TT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|table
operator|+
literal|12
expr_stmt|;
name|num_groups
operator|=
name|TT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|>
call|(
name|FT_ULong
call|)
argument_list|(
name|valid
operator|->
name|limit
operator|-
name|table
argument_list|)
operator|||
name|length
operator|<
literal|16
operator|+
literal|12
operator|*
name|num_groups
condition|)
name|FT_INVALID_TOO_SHORT
expr_stmt|;
comment|/* check groups, they must be in increasing order */
block|{
name|FT_ULong
name|n
decl_stmt|,
name|start
decl_stmt|,
name|end
decl_stmt|,
name|glyph_id
decl_stmt|,
name|last
init|=
literal|0
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|num_groups
condition|;
name|n
operator|++
control|)
block|{
name|start
operator|=
name|TT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|end
operator|=
name|TT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|glyph_id
operator|=
name|TT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|start
operator|>
name|end
condition|)
name|FT_INVALID_DATA
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
operator|&&
name|start
operator|<=
name|last
condition|)
name|FT_INVALID_DATA
expr_stmt|;
if|if
condition|(
name|valid
operator|->
name|level
operator|>=
name|FT_VALIDATE_TIGHT
condition|)
block|{
if|if
condition|(
name|glyph_id
operator|>=
name|TT_VALID_GLYPH_COUNT
argument_list|(
name|valid
argument_list|)
condition|)
name|FT_INVALID_GLYPH_ID
expr_stmt|;
block|}
name|last
operator|=
name|end
expr_stmt|;
block|}
block|}
return|return
name|SFNT_Err_Ok
return|;
block|}
end_block
begin_comment
comment|/* search the index of the charcode next to cmap->cur_charcode */
end_comment
begin_comment
comment|/* cmap->cur_group should be set up properly by caller         */
end_comment
begin_comment
comment|/*                                                             */
end_comment
begin_function
specifier|static
name|void
DECL|function|tt_cmap13_next
name|tt_cmap13_next
parameter_list|(
name|TT_CMap13
name|cmap
parameter_list|)
block|{
name|FT_Byte
modifier|*
name|p
decl_stmt|;
name|FT_ULong
name|start
decl_stmt|,
name|end
decl_stmt|,
name|glyph_id
decl_stmt|,
name|char_code
decl_stmt|;
name|FT_ULong
name|n
decl_stmt|;
name|FT_UInt
name|gindex
decl_stmt|;
if|if
condition|(
name|cmap
operator|->
name|cur_charcode
operator|>=
literal|0xFFFFFFFFUL
condition|)
goto|goto
name|Fail
goto|;
name|char_code
operator|=
name|cmap
operator|->
name|cur_charcode
operator|+
literal|1
expr_stmt|;
name|n
operator|=
name|cmap
operator|->
name|cur_group
expr_stmt|;
for|for
control|(
name|n
operator|=
name|cmap
operator|->
name|cur_group
init|;
name|n
operator|<
name|cmap
operator|->
name|num_groups
condition|;
name|n
operator|++
control|)
block|{
name|p
operator|=
name|cmap
operator|->
name|cmap
operator|.
name|data
operator|+
literal|16
operator|+
literal|12
operator|*
name|n
expr_stmt|;
name|start
operator|=
name|TT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|end
operator|=
name|TT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|glyph_id
operator|=
name|TT_PEEK_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|char_code
operator|<
name|start
condition|)
name|char_code
operator|=
name|start
expr_stmt|;
if|if
condition|(
name|char_code
operator|<=
name|end
condition|)
block|{
name|gindex
operator|=
operator|(
name|FT_UInt
operator|)
name|glyph_id
expr_stmt|;
if|if
condition|(
name|gindex
condition|)
block|{
name|cmap
operator|->
name|cur_charcode
operator|=
name|char_code
expr_stmt|;
empty_stmt|;
name|cmap
operator|->
name|cur_gindex
operator|=
name|gindex
expr_stmt|;
name|cmap
operator|->
name|cur_group
operator|=
name|n
expr_stmt|;
return|return;
block|}
block|}
block|}
name|Fail
label|:
name|cmap
operator|->
name|valid
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|FT_UInt
DECL|function|tt_cmap13_char_map_binary
name|tt_cmap13_char_map_binary
parameter_list|(
name|TT_CMap
name|cmap
parameter_list|,
name|FT_UInt32
modifier|*
name|pchar_code
parameter_list|,
name|FT_Bool
name|next
parameter_list|)
block|{
name|FT_UInt
name|gindex
init|=
literal|0
decl_stmt|;
name|FT_Byte
modifier|*
name|p
init|=
name|cmap
operator|->
name|data
operator|+
literal|12
decl_stmt|;
name|FT_UInt32
name|num_groups
init|=
name|TT_PEEK_ULONG
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|FT_UInt32
name|char_code
init|=
operator|*
name|pchar_code
decl_stmt|;
name|FT_UInt32
name|start
decl_stmt|,
name|end
decl_stmt|;
name|FT_UInt32
name|max
decl_stmt|,
name|min
decl_stmt|,
name|mid
decl_stmt|;
if|if
condition|(
operator|!
name|num_groups
condition|)
return|return
literal|0
return|;
comment|/* make compiler happy */
name|mid
operator|=
name|num_groups
expr_stmt|;
name|end
operator|=
literal|0xFFFFFFFFUL
expr_stmt|;
if|if
condition|(
name|next
condition|)
name|char_code
operator|++
expr_stmt|;
name|min
operator|=
literal|0
expr_stmt|;
name|max
operator|=
name|num_groups
expr_stmt|;
comment|/* binary search */
while|while
condition|(
name|min
operator|<
name|max
condition|)
block|{
name|mid
operator|=
operator|(
name|min
operator|+
name|max
operator|)
operator|>>
literal|1
expr_stmt|;
name|p
operator|=
name|cmap
operator|->
name|data
operator|+
literal|16
operator|+
literal|12
operator|*
name|mid
expr_stmt|;
name|start
operator|=
name|TT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|end
operator|=
name|TT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|char_code
operator|<
name|start
condition|)
name|max
operator|=
name|mid
expr_stmt|;
elseif|else
if|if
condition|(
name|char_code
operator|>
name|end
condition|)
name|min
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
else|else
block|{
name|gindex
operator|=
operator|(
name|FT_UInt
operator|)
name|TT_PEEK_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|next
condition|)
block|{
name|TT_CMap13
name|cmap13
init|=
operator|(
name|TT_CMap13
operator|)
name|cmap
decl_stmt|;
comment|/* if `char_code' is not in any group, then `mid' is */
comment|/* the group nearest to `char_code'                  */
comment|/*                                                   */
if|if
condition|(
name|char_code
operator|>
name|end
condition|)
block|{
name|mid
operator|++
expr_stmt|;
if|if
condition|(
name|mid
operator|==
name|num_groups
condition|)
return|return
literal|0
return|;
block|}
name|cmap13
operator|->
name|valid
operator|=
literal|1
expr_stmt|;
name|cmap13
operator|->
name|cur_charcode
operator|=
name|char_code
expr_stmt|;
name|cmap13
operator|->
name|cur_group
operator|=
name|mid
expr_stmt|;
if|if
condition|(
operator|!
name|gindex
condition|)
block|{
name|tt_cmap13_next
argument_list|(
name|cmap13
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmap13
operator|->
name|valid
condition|)
name|gindex
operator|=
name|cmap13
operator|->
name|cur_gindex
expr_stmt|;
block|}
else|else
name|cmap13
operator|->
name|cur_gindex
operator|=
name|gindex
expr_stmt|;
if|if
condition|(
name|gindex
condition|)
operator|*
name|pchar_code
operator|=
name|cmap13
operator|->
name|cur_charcode
expr_stmt|;
block|}
return|return
name|gindex
return|;
block|}
end_function
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_UInt
argument_list|)
end_macro
begin_macro
name|tt_cmap13_char_index
argument_list|(
argument|TT_CMap    cmap
argument_list|,
argument|FT_UInt32  char_code
argument_list|)
end_macro
begin_block
block|{
return|return
name|tt_cmap13_char_map_binary
argument_list|(
name|cmap
argument_list|,
operator|&
name|char_code
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_block
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_UInt32
argument_list|)
end_macro
begin_macro
name|tt_cmap13_char_next
argument_list|(
argument|TT_CMap     cmap
argument_list|,
argument|FT_UInt32  *pchar_code
argument_list|)
end_macro
begin_block
block|{
name|TT_CMap13
name|cmap13
init|=
operator|(
name|TT_CMap13
operator|)
name|cmap
decl_stmt|;
name|FT_UInt
name|gindex
decl_stmt|;
if|if
condition|(
name|cmap13
operator|->
name|cur_charcode
operator|>=
literal|0xFFFFFFFFUL
condition|)
return|return
literal|0
return|;
comment|/* no need to search */
if|if
condition|(
name|cmap13
operator|->
name|valid
operator|&&
name|cmap13
operator|->
name|cur_charcode
operator|==
operator|*
name|pchar_code
condition|)
block|{
name|tt_cmap13_next
argument_list|(
name|cmap13
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmap13
operator|->
name|valid
condition|)
block|{
name|gindex
operator|=
name|cmap13
operator|->
name|cur_gindex
expr_stmt|;
if|if
condition|(
name|gindex
condition|)
operator|*
name|pchar_code
operator|=
name|cmap13
operator|->
name|cur_charcode
expr_stmt|;
block|}
else|else
name|gindex
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|gindex
operator|=
name|tt_cmap13_char_map_binary
argument_list|(
name|cmap
argument_list|,
name|pchar_code
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|gindex
return|;
block|}
end_block
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|tt_cmap13_get_info
argument_list|(
argument|TT_CMap       cmap
argument_list|,
argument|TT_CMapInfo  *cmap_info
argument_list|)
end_macro
begin_block
block|{
name|FT_Byte
modifier|*
name|p
init|=
name|cmap
operator|->
name|data
operator|+
literal|8
decl_stmt|;
name|cmap_info
operator|->
name|format
operator|=
literal|13
expr_stmt|;
name|cmap_info
operator|->
name|language
operator|=
operator|(
name|FT_ULong
operator|)
name|TT_PEEK_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|SFNT_Err_Ok
return|;
block|}
end_block
begin_macro
name|FT_DEFINE_TT_CMAP
argument_list|(
argument|tt_cmap13_class_rec
argument_list|,
argument|sizeof ( TT_CMap13Rec )
argument_list|,
argument|(FT_CMap_InitFunc)     tt_cmap13_init
argument_list|,
argument|(FT_CMap_DoneFunc)     NULL
argument_list|,
argument|(FT_CMap_CharIndexFunc)tt_cmap13_char_index
argument_list|,
argument|(FT_CMap_CharNextFunc) tt_cmap13_char_next
argument_list|,
argument|NULL
argument_list|,
argument|NULL
argument_list|,
argument|NULL
argument_list|,
argument|NULL
argument_list|,
argument|NULL
argument_list|,
literal|13
argument_list|,
argument|(TT_CMap_ValidateFunc)   tt_cmap13_validate
argument_list|,
argument|(TT_CMap_Info_GetFunc)   tt_cmap13_get_info
argument_list|)
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* TT_CONFIG_CMAP_FORMAT_13 */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****                           FORMAT 14                           *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* TABLE OVERVIEW                                                        */
end_comment
begin_comment
comment|/* --------------                                                        */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*   NAME         OFFSET  TYPE    DESCRIPTION                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*   format         0     USHORT  must be 14                             */
end_comment
begin_comment
comment|/*   length         2     ULONG   table length in bytes                  */
end_comment
begin_comment
comment|/*   numSelector    6     ULONG   number of variation sel. records       */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* Followed by numSelector records, each of which looks like             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*   varSelector    0     UINT24  Unicode codepoint of sel.              */
end_comment
begin_comment
comment|/*   defaultOff     3     ULONG   offset to a default UVS table          */
end_comment
begin_comment
comment|/*                                describing any variants to be found in */
end_comment
begin_comment
comment|/*                                the normal Unicode subtable.           */
end_comment
begin_comment
comment|/*   nonDefOff      7     ULONG   offset to a non-default UVS table      */
end_comment
begin_comment
comment|/*                                describing any variants not in the     */
end_comment
begin_comment
comment|/*                                standard cmap, with GIDs here          */
end_comment
begin_comment
comment|/* (either offset may be 0 NULL)                                         */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* Selectors are sorted by code point.                                   */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* A default Unicode Variation Selector (UVS) subtable is just a list of */
end_comment
begin_comment
comment|/* ranges of code points which are to be found in the standard cmap.  No */
end_comment
begin_comment
comment|/* glyph IDs (GIDs) here.                                                */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*   numRanges      0     ULONG   number of ranges following             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* A range looks like                                                    */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*   uniStart       0     UINT24  code point of the first character in   */
end_comment
begin_comment
comment|/*                                this range                             */
end_comment
begin_comment
comment|/*   additionalCnt  3     UBYTE   count of additional characters in this */
end_comment
begin_comment
comment|/*                                range (zero means a range of a single  */
end_comment
begin_comment
comment|/*                                character)                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* Ranges are sorted by `uniStart'.                                      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* A non-default Unicode Variation Selector (UVS) subtable is a list of  */
end_comment
begin_comment
comment|/* mappings from codepoint to GID.                                       */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*   numMappings    0     ULONG   number of mappings                     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* A range looks like                                                    */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*   uniStart       0     UINT24  code point of the first character in   */
end_comment
begin_comment
comment|/*                                this range                             */
end_comment
begin_comment
comment|/*   GID            3     USHORT  and its GID                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* Ranges are sorted by `uniStart'.                                      */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|TT_CONFIG_CMAP_FORMAT_14
end_ifdef
begin_typedef
DECL|struct|TT_CMap14Rec_
typedef|typedef
struct|struct
name|TT_CMap14Rec_
block|{
DECL|member|cmap
name|TT_CMapRec
name|cmap
decl_stmt|;
DECL|member|num_selectors
name|FT_ULong
name|num_selectors
decl_stmt|;
comment|/* This array is used to store the results of various      * cmap 14 query functions.  The data is overwritten      * on each call to these functions.      */
DECL|member|max_results
name|FT_UInt32
name|max_results
decl_stmt|;
DECL|member|results
name|FT_UInt32
modifier|*
name|results
decl_stmt|;
DECL|member|memory
name|FT_Memory
name|memory
decl_stmt|;
block|}
DECL|typedef|TT_CMap14Rec
DECL|typedef|TT_CMap14
name|TT_CMap14Rec
operator|,
typedef|*
name|TT_CMap14
typedef|;
end_typedef
begin_macro
name|FT_CALLBACK_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|tt_cmap14_done
name|tt_cmap14_done
argument_list|(
argument|TT_CMap14  cmap
argument_list|)
end_macro
begin_block
block|{
name|FT_Memory
name|memory
init|=
name|cmap
operator|->
name|memory
decl_stmt|;
name|cmap
operator|->
name|max_results
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|memory
operator|!=
name|NULL
operator|&&
name|cmap
operator|->
name|results
operator|!=
name|NULL
condition|)
name|FT_FREE
argument_list|(
name|cmap
operator|->
name|results
argument_list|)
expr_stmt|;
block|}
end_block
begin_function
specifier|static
name|FT_Error
DECL|function|tt_cmap14_ensure
name|tt_cmap14_ensure
parameter_list|(
name|TT_CMap14
name|cmap
parameter_list|,
name|FT_UInt32
name|num_results
parameter_list|,
name|FT_Memory
name|memory
parameter_list|)
block|{
name|FT_UInt32
name|old_max
init|=
name|cmap
operator|->
name|max_results
decl_stmt|;
name|FT_Error
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|num_results
operator|>
name|cmap
operator|->
name|max_results
condition|)
block|{
name|cmap
operator|->
name|memory
operator|=
name|memory
expr_stmt|;
if|if
condition|(
name|FT_QRENEW_ARRAY
argument_list|(
name|cmap
operator|->
name|results
argument_list|,
name|old_max
argument_list|,
name|num_results
argument_list|)
condition|)
return|return
name|error
return|;
name|cmap
operator|->
name|max_results
operator|=
name|num_results
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|tt_cmap14_init
argument_list|(
argument|TT_CMap14  cmap
argument_list|,
argument|FT_Byte*   table
argument_list|)
end_macro
begin_block
block|{
name|cmap
operator|->
name|cmap
operator|.
name|data
operator|=
name|table
expr_stmt|;
name|table
operator|+=
literal|6
expr_stmt|;
name|cmap
operator|->
name|num_selectors
operator|=
name|FT_PEEK_ULONG
argument_list|(
name|table
argument_list|)
expr_stmt|;
name|cmap
operator|->
name|max_results
operator|=
literal|0
expr_stmt|;
name|cmap
operator|->
name|results
operator|=
name|NULL
expr_stmt|;
return|return
name|SFNT_Err_Ok
return|;
block|}
end_block
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|tt_cmap14_validate
argument_list|(
argument|FT_Byte*      table
argument_list|,
argument|FT_Validator  valid
argument_list|)
end_macro
begin_block
block|{
name|FT_Byte
modifier|*
name|p
init|=
name|table
operator|+
literal|2
decl_stmt|;
name|FT_ULong
name|length
init|=
name|TT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|FT_ULong
name|num_selectors
init|=
name|TT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|length
operator|>
call|(
name|FT_ULong
call|)
argument_list|(
name|valid
operator|->
name|limit
operator|-
name|table
argument_list|)
operator|||
name|length
operator|<
literal|10
operator|+
literal|11
operator|*
name|num_selectors
condition|)
name|FT_INVALID_TOO_SHORT
expr_stmt|;
comment|/* check selectors, they must be in increasing order */
block|{
comment|/* we start lastVarSel at 1 because a variant selector value of 0        * isn't valid.        */
name|FT_ULong
name|n
decl_stmt|,
name|lastVarSel
init|=
literal|1
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|num_selectors
condition|;
name|n
operator|++
control|)
block|{
name|FT_ULong
name|varSel
init|=
name|TT_NEXT_UINT24
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|FT_ULong
name|defOff
init|=
name|TT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|FT_ULong
name|nondefOff
init|=
name|TT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|defOff
operator|>=
name|length
operator|||
name|nondefOff
operator|>=
name|length
condition|)
name|FT_INVALID_TOO_SHORT
expr_stmt|;
if|if
condition|(
name|varSel
operator|<
name|lastVarSel
condition|)
name|FT_INVALID_DATA
expr_stmt|;
name|lastVarSel
operator|=
name|varSel
operator|+
literal|1
expr_stmt|;
comment|/* check the default table (these glyphs should be reached     */
comment|/* through the normal Unicode cmap, no GIDs, just check order) */
if|if
condition|(
name|defOff
operator|!=
literal|0
condition|)
block|{
name|FT_Byte
modifier|*
name|defp
init|=
name|table
operator|+
name|defOff
decl_stmt|;
name|FT_ULong
name|numRanges
init|=
name|TT_NEXT_ULONG
argument_list|(
name|defp
argument_list|)
decl_stmt|;
name|FT_ULong
name|i
decl_stmt|;
name|FT_ULong
name|lastBase
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|defp
operator|+
name|numRanges
operator|*
literal|4
operator|>
name|valid
operator|->
name|limit
condition|)
name|FT_INVALID_TOO_SHORT
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numRanges
condition|;
operator|++
name|i
control|)
block|{
name|FT_ULong
name|base
init|=
name|TT_NEXT_UINT24
argument_list|(
name|defp
argument_list|)
decl_stmt|;
name|FT_ULong
name|cnt
init|=
name|FT_NEXT_BYTE
argument_list|(
name|defp
argument_list|)
decl_stmt|;
if|if
condition|(
name|base
operator|+
name|cnt
operator|>=
literal|0x110000UL
condition|)
comment|/* end of Unicode */
name|FT_INVALID_DATA
expr_stmt|;
if|if
condition|(
name|base
operator|<
name|lastBase
condition|)
name|FT_INVALID_DATA
expr_stmt|;
name|lastBase
operator|=
name|base
operator|+
name|cnt
operator|+
literal|1U
expr_stmt|;
block|}
block|}
comment|/* and the non-default table (these glyphs are specified here) */
if|if
condition|(
name|nondefOff
operator|!=
literal|0
condition|)
block|{
name|FT_Byte
modifier|*
name|ndp
init|=
name|table
operator|+
name|nondefOff
decl_stmt|;
name|FT_ULong
name|numMappings
init|=
name|TT_NEXT_ULONG
argument_list|(
name|ndp
argument_list|)
decl_stmt|;
name|FT_ULong
name|i
decl_stmt|,
name|lastUni
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|numMappings
operator|*
literal|4
operator|>
call|(
name|FT_ULong
call|)
argument_list|(
name|valid
operator|->
name|limit
operator|-
name|ndp
argument_list|)
condition|)
name|FT_INVALID_TOO_SHORT
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numMappings
condition|;
operator|++
name|i
control|)
block|{
name|FT_ULong
name|uni
init|=
name|TT_NEXT_UINT24
argument_list|(
name|ndp
argument_list|)
decl_stmt|;
name|FT_ULong
name|gid
init|=
name|TT_NEXT_USHORT
argument_list|(
name|ndp
argument_list|)
decl_stmt|;
if|if
condition|(
name|uni
operator|>=
literal|0x110000UL
condition|)
comment|/* end of Unicode */
name|FT_INVALID_DATA
expr_stmt|;
if|if
condition|(
name|uni
operator|<
name|lastUni
condition|)
name|FT_INVALID_DATA
expr_stmt|;
name|lastUni
operator|=
name|uni
operator|+
literal|1U
expr_stmt|;
if|if
condition|(
name|valid
operator|->
name|level
operator|>=
name|FT_VALIDATE_TIGHT
operator|&&
name|gid
operator|>=
name|TT_VALID_GLYPH_COUNT
argument_list|(
name|valid
argument_list|)
condition|)
name|FT_INVALID_GLYPH_ID
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|SFNT_Err_Ok
return|;
block|}
end_block
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_UInt
argument_list|)
end_macro
begin_macro
name|tt_cmap14_char_index
argument_list|(
argument|TT_CMap    cmap
argument_list|,
argument|FT_UInt32  char_code
argument_list|)
end_macro
begin_block
block|{
name|FT_UNUSED
argument_list|(
name|cmap
argument_list|)
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|char_code
argument_list|)
expr_stmt|;
comment|/* This can't happen */
return|return
literal|0
return|;
block|}
end_block
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_UInt32
argument_list|)
end_macro
begin_macro
name|tt_cmap14_char_next
argument_list|(
argument|TT_CMap     cmap
argument_list|,
argument|FT_UInt32  *pchar_code
argument_list|)
end_macro
begin_block
block|{
name|FT_UNUSED
argument_list|(
name|cmap
argument_list|)
expr_stmt|;
comment|/* This can't happen */
operator|*
name|pchar_code
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|tt_cmap14_get_info
argument_list|(
argument|TT_CMap       cmap
argument_list|,
argument|TT_CMapInfo  *cmap_info
argument_list|)
end_macro
begin_block
block|{
name|FT_UNUSED
argument_list|(
name|cmap
argument_list|)
expr_stmt|;
name|cmap_info
operator|->
name|format
operator|=
literal|14
expr_stmt|;
comment|/* subtable 14 does not define a language field */
name|cmap_info
operator|->
name|language
operator|=
literal|0xFFFFFFFFUL
expr_stmt|;
return|return
name|SFNT_Err_Ok
return|;
block|}
end_block
begin_function
specifier|static
name|FT_UInt
DECL|function|tt_cmap14_char_map_def_binary
name|tt_cmap14_char_map_def_binary
parameter_list|(
name|FT_Byte
modifier|*
name|base
parameter_list|,
name|FT_UInt32
name|char_code
parameter_list|)
block|{
name|FT_UInt32
name|numRanges
init|=
name|TT_PEEK_ULONG
argument_list|(
name|base
argument_list|)
decl_stmt|;
name|FT_UInt32
name|max
decl_stmt|,
name|min
decl_stmt|;
name|min
operator|=
literal|0
expr_stmt|;
name|max
operator|=
name|numRanges
expr_stmt|;
name|base
operator|+=
literal|4
expr_stmt|;
comment|/* binary search */
while|while
condition|(
name|min
operator|<
name|max
condition|)
block|{
name|FT_UInt32
name|mid
init|=
operator|(
name|min
operator|+
name|max
operator|)
operator|>>
literal|1
decl_stmt|;
name|FT_Byte
modifier|*
name|p
init|=
name|base
operator|+
literal|4
operator|*
name|mid
decl_stmt|;
name|FT_ULong
name|start
init|=
name|TT_NEXT_UINT24
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|FT_UInt
name|cnt
init|=
name|FT_NEXT_BYTE
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|char_code
operator|<
name|start
condition|)
name|max
operator|=
name|mid
expr_stmt|;
elseif|else
if|if
condition|(
name|char_code
operator|>
name|start
operator|+
name|cnt
condition|)
name|min
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
else|else
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function
begin_function
specifier|static
name|FT_UInt
DECL|function|tt_cmap14_char_map_nondef_binary
name|tt_cmap14_char_map_nondef_binary
parameter_list|(
name|FT_Byte
modifier|*
name|base
parameter_list|,
name|FT_UInt32
name|char_code
parameter_list|)
block|{
name|FT_UInt32
name|numMappings
init|=
name|TT_PEEK_ULONG
argument_list|(
name|base
argument_list|)
decl_stmt|;
name|FT_UInt32
name|max
decl_stmt|,
name|min
decl_stmt|;
name|min
operator|=
literal|0
expr_stmt|;
name|max
operator|=
name|numMappings
expr_stmt|;
name|base
operator|+=
literal|4
expr_stmt|;
comment|/* binary search */
while|while
condition|(
name|min
operator|<
name|max
condition|)
block|{
name|FT_UInt32
name|mid
init|=
operator|(
name|min
operator|+
name|max
operator|)
operator|>>
literal|1
decl_stmt|;
name|FT_Byte
modifier|*
name|p
init|=
name|base
operator|+
literal|5
operator|*
name|mid
decl_stmt|;
name|FT_UInt32
name|uni
init|=
operator|(
name|FT_UInt32
operator|)
name|TT_NEXT_UINT24
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|char_code
operator|<
name|uni
condition|)
name|max
operator|=
name|mid
expr_stmt|;
elseif|else
if|if
condition|(
name|char_code
operator|>
name|uni
condition|)
name|min
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
else|else
return|return
name|TT_PEEK_USHORT
argument_list|(
name|p
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
specifier|static
name|FT_Byte
modifier|*
DECL|function|tt_cmap14_find_variant
name|tt_cmap14_find_variant
parameter_list|(
name|FT_Byte
modifier|*
name|base
parameter_list|,
name|FT_UInt32
name|variantCode
parameter_list|)
block|{
name|FT_UInt32
name|numVar
init|=
name|TT_PEEK_ULONG
argument_list|(
name|base
argument_list|)
decl_stmt|;
name|FT_UInt32
name|max
decl_stmt|,
name|min
decl_stmt|;
name|min
operator|=
literal|0
expr_stmt|;
name|max
operator|=
name|numVar
expr_stmt|;
name|base
operator|+=
literal|4
expr_stmt|;
comment|/* binary search */
while|while
condition|(
name|min
operator|<
name|max
condition|)
block|{
name|FT_UInt32
name|mid
init|=
operator|(
name|min
operator|+
name|max
operator|)
operator|>>
literal|1
decl_stmt|;
name|FT_Byte
modifier|*
name|p
init|=
name|base
operator|+
literal|11
operator|*
name|mid
decl_stmt|;
name|FT_ULong
name|varSel
init|=
name|TT_NEXT_UINT24
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|variantCode
operator|<
name|varSel
condition|)
name|max
operator|=
name|mid
expr_stmt|;
elseif|else
if|if
condition|(
name|variantCode
operator|>
name|varSel
condition|)
name|min
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
else|else
return|return
name|p
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_UInt
argument_list|)
end_macro
begin_macro
name|tt_cmap14_char_var_index
argument_list|(
argument|TT_CMap    cmap
argument_list|,
argument|TT_CMap    ucmap
argument_list|,
argument|FT_UInt32  charcode
argument_list|,
argument|FT_UInt32  variantSelector
argument_list|)
end_macro
begin_block
block|{
name|FT_Byte
modifier|*
name|p
init|=
name|tt_cmap14_find_variant
argument_list|(
name|cmap
operator|->
name|data
operator|+
literal|6
argument_list|,
name|variantSelector
argument_list|)
decl_stmt|;
name|FT_ULong
name|defOff
decl_stmt|;
name|FT_ULong
name|nondefOff
decl_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
return|return
literal|0
return|;
name|defOff
operator|=
name|TT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|nondefOff
operator|=
name|TT_PEEK_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|defOff
operator|!=
literal|0
operator|&&
name|tt_cmap14_char_map_def_binary
argument_list|(
name|cmap
operator|->
name|data
operator|+
name|defOff
argument_list|,
name|charcode
argument_list|)
condition|)
block|{
comment|/* This is the default variant of this charcode.  GID not stored */
comment|/* here; stored in the normal Unicode charmap instead.           */
return|return
name|ucmap
operator|->
name|cmap
operator|.
name|clazz
operator|->
name|char_index
argument_list|(
operator|&
name|ucmap
operator|->
name|cmap
argument_list|,
name|charcode
argument_list|)
return|;
block|}
if|if
condition|(
name|nondefOff
operator|!=
literal|0
condition|)
return|return
name|tt_cmap14_char_map_nondef_binary
argument_list|(
name|cmap
operator|->
name|data
operator|+
name|nondefOff
argument_list|,
name|charcode
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_block
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_Int
argument_list|)
end_macro
begin_macro
name|tt_cmap14_char_var_isdefault
argument_list|(
argument|TT_CMap    cmap
argument_list|,
argument|FT_UInt32  charcode
argument_list|,
argument|FT_UInt32  variantSelector
argument_list|)
end_macro
begin_block
block|{
name|FT_Byte
modifier|*
name|p
init|=
name|tt_cmap14_find_variant
argument_list|(
name|cmap
operator|->
name|data
operator|+
literal|6
argument_list|,
name|variantSelector
argument_list|)
decl_stmt|;
name|FT_ULong
name|defOff
decl_stmt|;
name|FT_ULong
name|nondefOff
decl_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
return|return
operator|-
literal|1
return|;
name|defOff
operator|=
name|TT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|nondefOff
operator|=
name|TT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|defOff
operator|!=
literal|0
operator|&&
name|tt_cmap14_char_map_def_binary
argument_list|(
name|cmap
operator|->
name|data
operator|+
name|defOff
argument_list|,
name|charcode
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|nondefOff
operator|!=
literal|0
operator|&&
name|tt_cmap14_char_map_nondef_binary
argument_list|(
name|cmap
operator|->
name|data
operator|+
name|nondefOff
argument_list|,
name|charcode
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
return|return
operator|-
literal|1
return|;
block|}
end_block
begin_macro
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_UInt32*
argument_list|)
end_macro
begin_macro
DECL|function|tt_cmap14_variants
name|tt_cmap14_variants
argument_list|(
argument|TT_CMap    cmap
argument_list|,
argument|FT_Memory  memory
argument_list|)
end_macro
begin_block
block|{
name|TT_CMap14
name|cmap14
init|=
operator|(
name|TT_CMap14
operator|)
name|cmap
decl_stmt|;
name|FT_UInt32
name|count
init|=
name|cmap14
operator|->
name|num_selectors
decl_stmt|;
name|FT_Byte
modifier|*
name|p
init|=
name|cmap
operator|->
name|data
operator|+
literal|10
decl_stmt|;
name|FT_UInt32
modifier|*
name|result
decl_stmt|;
name|FT_UInt32
name|i
decl_stmt|;
if|if
condition|(
name|tt_cmap14_ensure
argument_list|(
name|cmap14
argument_list|,
operator|(
name|count
operator|+
literal|1
operator|)
argument_list|,
name|memory
argument_list|)
condition|)
return|return
name|NULL
return|;
name|result
operator|=
name|cmap14
operator|->
name|results
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
name|result
index|[
name|i
index|]
operator|=
operator|(
name|FT_UInt32
operator|)
name|TT_NEXT_UINT24
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|8
expr_stmt|;
block|}
name|result
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|result
return|;
block|}
end_block
begin_macro
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_UInt32 *
argument_list|)
end_macro
begin_macro
DECL|function|tt_cmap14_char_variants
name|tt_cmap14_char_variants
argument_list|(
argument|TT_CMap    cmap
argument_list|,
argument|FT_Memory  memory
argument_list|,
argument|FT_UInt32  charCode
argument_list|)
end_macro
begin_block
block|{
name|TT_CMap14
name|cmap14
init|=
operator|(
name|TT_CMap14
operator|)
name|cmap
decl_stmt|;
name|FT_UInt32
name|count
init|=
name|cmap14
operator|->
name|num_selectors
decl_stmt|;
name|FT_Byte
modifier|*
name|p
init|=
name|cmap
operator|->
name|data
operator|+
literal|10
decl_stmt|;
name|FT_UInt32
modifier|*
name|q
decl_stmt|;
if|if
condition|(
name|tt_cmap14_ensure
argument_list|(
name|cmap14
argument_list|,
operator|(
name|count
operator|+
literal|1
operator|)
argument_list|,
name|memory
argument_list|)
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|q
operator|=
name|cmap14
operator|->
name|results
init|;
name|count
operator|>
literal|0
condition|;
operator|--
name|count
control|)
block|{
name|FT_UInt32
name|varSel
init|=
name|TT_NEXT_UINT24
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|FT_ULong
name|defOff
init|=
name|TT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|FT_ULong
name|nondefOff
init|=
name|TT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|defOff
operator|!=
literal|0
operator|&&
name|tt_cmap14_char_map_def_binary
argument_list|(
name|cmap
operator|->
name|data
operator|+
name|defOff
argument_list|,
name|charCode
argument_list|)
operator|)
operator|||
operator|(
name|nondefOff
operator|!=
literal|0
operator|&&
name|tt_cmap14_char_map_nondef_binary
argument_list|(
name|cmap
operator|->
name|data
operator|+
name|nondefOff
argument_list|,
name|charCode
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|q
index|[
literal|0
index|]
operator|=
name|varSel
expr_stmt|;
name|q
operator|++
expr_stmt|;
block|}
block|}
name|q
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|cmap14
operator|->
name|results
return|;
block|}
end_block
begin_function
specifier|static
name|FT_UInt
DECL|function|tt_cmap14_def_char_count
name|tt_cmap14_def_char_count
parameter_list|(
name|FT_Byte
modifier|*
name|p
parameter_list|)
block|{
name|FT_UInt32
name|numRanges
init|=
operator|(
name|FT_UInt32
operator|)
name|TT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|FT_UInt
name|tot
init|=
literal|0
decl_stmt|;
name|p
operator|+=
literal|3
expr_stmt|;
comment|/* point to the first `cnt' field */
for|for
control|(
init|;
name|numRanges
operator|>
literal|0
condition|;
name|numRanges
operator|--
control|)
block|{
name|tot
operator|+=
literal|1
operator|+
name|p
index|[
literal|0
index|]
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
block|}
return|return
name|tot
return|;
block|}
end_function
begin_function
specifier|static
name|FT_UInt32
modifier|*
DECL|function|tt_cmap14_get_def_chars
name|tt_cmap14_get_def_chars
parameter_list|(
name|TT_CMap
name|cmap
parameter_list|,
name|FT_Byte
modifier|*
name|p
parameter_list|,
name|FT_Memory
name|memory
parameter_list|)
block|{
name|TT_CMap14
name|cmap14
init|=
operator|(
name|TT_CMap14
operator|)
name|cmap
decl_stmt|;
name|FT_UInt32
name|numRanges
decl_stmt|;
name|FT_UInt
name|cnt
decl_stmt|;
name|FT_UInt32
modifier|*
name|q
decl_stmt|;
name|cnt
operator|=
name|tt_cmap14_def_char_count
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|numRanges
operator|=
operator|(
name|FT_UInt32
operator|)
name|TT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|tt_cmap14_ensure
argument_list|(
name|cmap14
argument_list|,
operator|(
name|cnt
operator|+
literal|1
operator|)
argument_list|,
name|memory
argument_list|)
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|q
operator|=
name|cmap14
operator|->
name|results
init|;
name|numRanges
operator|>
literal|0
condition|;
operator|--
name|numRanges
control|)
block|{
name|FT_UInt32
name|uni
init|=
operator|(
name|FT_UInt32
operator|)
name|TT_NEXT_UINT24
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|cnt
operator|=
name|FT_NEXT_BYTE
argument_list|(
name|p
argument_list|)
operator|+
literal|1
expr_stmt|;
do|do
block|{
name|q
index|[
literal|0
index|]
operator|=
name|uni
expr_stmt|;
name|uni
operator|+=
literal|1
expr_stmt|;
name|q
operator|+=
literal|1
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|cnt
operator|!=
literal|0
condition|)
do|;
block|}
name|q
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|cmap14
operator|->
name|results
return|;
block|}
end_function
begin_function
specifier|static
name|FT_UInt32
modifier|*
DECL|function|tt_cmap14_get_nondef_chars
name|tt_cmap14_get_nondef_chars
parameter_list|(
name|TT_CMap
name|cmap
parameter_list|,
name|FT_Byte
modifier|*
name|p
parameter_list|,
name|FT_Memory
name|memory
parameter_list|)
block|{
name|TT_CMap14
name|cmap14
init|=
operator|(
name|TT_CMap14
operator|)
name|cmap
decl_stmt|;
name|FT_UInt32
name|numMappings
decl_stmt|;
name|FT_UInt
name|i
decl_stmt|;
name|FT_UInt32
modifier|*
name|ret
decl_stmt|;
name|numMappings
operator|=
operator|(
name|FT_UInt32
operator|)
name|TT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|tt_cmap14_ensure
argument_list|(
name|cmap14
argument_list|,
operator|(
name|numMappings
operator|+
literal|1
operator|)
argument_list|,
name|memory
argument_list|)
condition|)
return|return
name|NULL
return|;
name|ret
operator|=
name|cmap14
operator|->
name|results
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numMappings
condition|;
operator|++
name|i
control|)
block|{
name|ret
index|[
name|i
index|]
operator|=
operator|(
name|FT_UInt32
operator|)
name|TT_NEXT_UINT24
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
block|}
name|ret
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_macro
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_UInt32 *
argument_list|)
end_macro
begin_macro
DECL|function|tt_cmap14_variant_chars
name|tt_cmap14_variant_chars
argument_list|(
argument|TT_CMap    cmap
argument_list|,
argument|FT_Memory  memory
argument_list|,
argument|FT_UInt32  variantSelector
argument_list|)
end_macro
begin_block
block|{
name|FT_Byte
modifier|*
name|p
init|=
name|tt_cmap14_find_variant
argument_list|(
name|cmap
operator|->
name|data
operator|+
literal|6
argument_list|,
name|variantSelector
argument_list|)
decl_stmt|;
name|FT_UInt32
modifier|*
name|ret
decl_stmt|;
name|FT_Int
name|i
decl_stmt|;
name|FT_ULong
name|defOff
decl_stmt|;
name|FT_ULong
name|nondefOff
decl_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
return|return
name|NULL
return|;
name|defOff
operator|=
name|TT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|nondefOff
operator|=
name|TT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|defOff
operator|==
literal|0
operator|&&
name|nondefOff
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|defOff
operator|==
literal|0
condition|)
return|return
name|tt_cmap14_get_nondef_chars
argument_list|(
name|cmap
argument_list|,
name|cmap
operator|->
name|data
operator|+
name|nondefOff
argument_list|,
name|memory
argument_list|)
return|;
elseif|else
if|if
condition|(
name|nondefOff
operator|==
literal|0
condition|)
return|return
name|tt_cmap14_get_def_chars
argument_list|(
name|cmap
argument_list|,
name|cmap
operator|->
name|data
operator|+
name|defOff
argument_list|,
name|memory
argument_list|)
return|;
else|else
block|{
comment|/* Both a default and a non-default glyph set?  That's probably not */
comment|/* good font design, but the spec allows for it...                  */
name|TT_CMap14
name|cmap14
init|=
operator|(
name|TT_CMap14
operator|)
name|cmap
decl_stmt|;
name|FT_UInt32
name|numRanges
decl_stmt|;
name|FT_UInt32
name|numMappings
decl_stmt|;
name|FT_UInt32
name|duni
decl_stmt|;
name|FT_UInt32
name|dcnt
decl_stmt|;
name|FT_UInt32
name|nuni
decl_stmt|;
name|FT_Byte
modifier|*
name|dp
decl_stmt|;
name|FT_UInt
name|di
decl_stmt|,
name|ni
decl_stmt|,
name|k
decl_stmt|;
name|p
operator|=
name|cmap
operator|->
name|data
operator|+
name|nondefOff
expr_stmt|;
name|dp
operator|=
name|cmap
operator|->
name|data
operator|+
name|defOff
expr_stmt|;
name|numMappings
operator|=
operator|(
name|FT_UInt32
operator|)
name|TT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|dcnt
operator|=
name|tt_cmap14_def_char_count
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|numRanges
operator|=
operator|(
name|FT_UInt32
operator|)
name|TT_NEXT_ULONG
argument_list|(
name|dp
argument_list|)
expr_stmt|;
if|if
condition|(
name|numMappings
operator|==
literal|0
condition|)
return|return
name|tt_cmap14_get_def_chars
argument_list|(
name|cmap
argument_list|,
name|cmap
operator|->
name|data
operator|+
name|defOff
argument_list|,
name|memory
argument_list|)
return|;
if|if
condition|(
name|dcnt
operator|==
literal|0
condition|)
return|return
name|tt_cmap14_get_nondef_chars
argument_list|(
name|cmap
argument_list|,
name|cmap
operator|->
name|data
operator|+
name|nondefOff
argument_list|,
name|memory
argument_list|)
return|;
if|if
condition|(
name|tt_cmap14_ensure
argument_list|(
name|cmap14
argument_list|,
operator|(
name|dcnt
operator|+
name|numMappings
operator|+
literal|1
operator|)
argument_list|,
name|memory
argument_list|)
condition|)
return|return
name|NULL
return|;
name|ret
operator|=
name|cmap14
operator|->
name|results
expr_stmt|;
name|duni
operator|=
operator|(
name|FT_UInt32
operator|)
name|TT_NEXT_UINT24
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|dcnt
operator|=
name|FT_NEXT_BYTE
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|di
operator|=
literal|1
expr_stmt|;
name|nuni
operator|=
operator|(
name|FT_UInt32
operator|)
name|TT_NEXT_UINT24
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
name|ni
operator|=
literal|1
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|nuni
operator|>
name|duni
operator|+
name|dcnt
condition|)
block|{
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<=
name|dcnt
condition|;
operator|++
name|k
control|)
name|ret
index|[
name|i
operator|++
index|]
operator|=
name|duni
operator|+
name|k
expr_stmt|;
operator|++
name|di
expr_stmt|;
if|if
condition|(
name|di
operator|>
name|numRanges
condition|)
break|break;
name|duni
operator|=
operator|(
name|FT_UInt32
operator|)
name|TT_NEXT_UINT24
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|dcnt
operator|=
name|FT_NEXT_BYTE
argument_list|(
name|dp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|nuni
operator|<
name|duni
condition|)
name|ret
index|[
name|i
operator|++
index|]
operator|=
name|nuni
expr_stmt|;
comment|/* If it is within the default range then ignore it -- */
comment|/* that should not have happened                       */
operator|++
name|ni
expr_stmt|;
if|if
condition|(
name|ni
operator|>
name|numMappings
condition|)
break|break;
name|nuni
operator|=
operator|(
name|FT_UInt32
operator|)
name|TT_NEXT_UINT24
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ni
operator|<=
name|numMappings
condition|)
block|{
comment|/* If we get here then we have run out of all default ranges.   */
comment|/* We have read one non-default mapping which we haven't stored */
comment|/* and there may be others that need to be read.                */
name|ret
index|[
name|i
operator|++
index|]
operator|=
name|nuni
expr_stmt|;
while|while
condition|(
name|ni
operator|<
name|numMappings
condition|)
block|{
name|ret
index|[
name|i
operator|++
index|]
operator|=
operator|(
name|FT_UInt32
operator|)
name|TT_NEXT_UINT24
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
operator|++
name|ni
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|di
operator|<=
name|numRanges
condition|)
block|{
comment|/* If we get here then we have run out of all non-default     */
comment|/* mappings.  We have read one default range which we haven't */
comment|/* stored and there may be others that need to be read.       */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<=
name|dcnt
condition|;
operator|++
name|k
control|)
name|ret
index|[
name|i
operator|++
index|]
operator|=
name|duni
operator|+
name|k
expr_stmt|;
while|while
condition|(
name|di
operator|<
name|numRanges
condition|)
block|{
name|duni
operator|=
operator|(
name|FT_UInt32
operator|)
name|TT_NEXT_UINT24
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|dcnt
operator|=
name|FT_NEXT_BYTE
argument_list|(
name|dp
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<=
name|dcnt
condition|;
operator|++
name|k
control|)
name|ret
index|[
name|i
operator|++
index|]
operator|=
name|duni
operator|+
name|k
expr_stmt|;
operator|++
name|di
expr_stmt|;
block|}
block|}
name|ret
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|ret
return|;
block|}
block|}
end_block
begin_macro
name|FT_DEFINE_TT_CMAP
argument_list|(
argument|tt_cmap14_class_rec
argument_list|,
argument|sizeof ( TT_CMap14Rec )
argument_list|,
argument|(FT_CMap_InitFunc)     tt_cmap14_init
argument_list|,
argument|(FT_CMap_DoneFunc)     tt_cmap14_done
argument_list|,
argument|(FT_CMap_CharIndexFunc)tt_cmap14_char_index
argument_list|,
argument|(FT_CMap_CharNextFunc) tt_cmap14_char_next
argument_list|,
comment|/* Format 14 extension functions */
argument|(FT_CMap_CharVarIndexFunc)    tt_cmap14_char_var_index
argument_list|,
argument|(FT_CMap_CharVarIsDefaultFunc)tt_cmap14_char_var_isdefault
argument_list|,
argument|(FT_CMap_VariantListFunc)     tt_cmap14_variants
argument_list|,
argument|(FT_CMap_CharVariantListFunc) tt_cmap14_char_variants
argument_list|,
argument|(FT_CMap_VariantCharListFunc) tt_cmap14_variant_chars
argument_list|,
literal|14
argument_list|,
argument|(TT_CMap_ValidateFunc)tt_cmap14_validate
argument_list|,
argument|(TT_CMap_Info_GetFunc)tt_cmap14_get_info
argument_list|)
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* TT_CONFIG_CMAP_FORMAT_14 */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|FT_CONFIG_OPTION_PIC
end_ifndef
begin_decl_stmt
DECL|variable|tt_cmap_classes
specifier|static
specifier|const
name|TT_CMap_Class
name|tt_cmap_classes
index|[]
init|=
block|{
DECL|macro|TTCMAPCITEM
define|#
directive|define
name|TTCMAPCITEM
parameter_list|(
name|a
parameter_list|)
value|&a,
include|#
directive|include
file|"ttcmapc.h"
name|NULL
block|,   }
decl_stmt|;
end_decl_stmt
begin_else
else|#
directive|else
end_else
begin_comment
comment|/*FT_CONFIG_OPTION_PIC*/
end_comment
begin_function
name|void
name|FT_Destroy_Class_tt_cmap_classes
parameter_list|(
name|FT_Library
name|library
parameter_list|,
name|TT_CMap_Class
modifier|*
name|clazz
parameter_list|)
block|{
name|FT_Memory
name|memory
init|=
name|library
operator|->
name|memory
decl_stmt|;
if|if
condition|(
name|clazz
condition|)
name|FT_FREE
argument_list|(
name|clazz
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
name|FT_Error
name|FT_Create_Class_tt_cmap_classes
parameter_list|(
name|FT_Library
name|library
parameter_list|,
name|TT_CMap_Class
modifier|*
modifier|*
name|output_class
parameter_list|)
block|{
name|TT_CMap_Class
modifier|*
name|clazz
decl_stmt|;
name|TT_CMap_ClassRec
modifier|*
name|recs
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|library
operator|->
name|memory
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
define|#
directive|define
name|TTCMAPCITEM
parameter_list|(
name|a
parameter_list|)
value|i++;
include|#
directive|include
file|"ttcmapc.h"
comment|/* allocate enough space for both the pointers +terminator and the class instances */
if|if
condition|(
name|FT_ALLOC
argument_list|(
name|clazz
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|clazz
argument_list|)
operator|*
operator|(
name|i
operator|+
literal|1
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|TT_CMap_ClassRec
argument_list|)
operator|*
name|i
argument_list|)
condition|)
return|return
name|error
return|;
comment|/* the location of the class instances follows the array of pointers */
name|recs
operator|=
operator|(
name|TT_CMap_ClassRec
operator|*
operator|)
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|clazz
operator|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|clazz
argument_list|)
operator|*
operator|(
name|i
operator|+
literal|1
operator|)
operator|)
operator|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
undef|#
directive|undef
name|TTCMAPCITEM
define|#
directive|define
name|TTCMAPCITEM
parameter_list|(
name|a
parameter_list|)
define|\
value|FT_Init_Class_##a(&recs[i]); \     clazz[i] =&recs[i];         \     i++;
include|#
directive|include
file|"ttcmapc.h"
name|clazz
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
operator|*
name|output_class
operator|=
name|clazz
expr_stmt|;
return|return
name|FT_Err_Ok
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*FT_CONFIG_OPTION_PIC*/
end_comment
begin_comment
comment|/* parse the `cmap' table and build the corresponding TT_CMap objects */
end_comment
begin_comment
comment|/* in the current face                                                */
end_comment
begin_comment
comment|/*                                                                    */
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|tt_face_build_cmaps
argument_list|(
argument|TT_Face  face
argument_list|)
end_macro
begin_block
block|{
name|FT_Byte
modifier|*
name|table
init|=
name|face
operator|->
name|cmap_table
decl_stmt|;
name|FT_Byte
modifier|*
name|limit
init|=
name|table
operator|+
name|face
operator|->
name|cmap_size
decl_stmt|;
name|FT_UInt
specifier|volatile
name|num_cmaps
decl_stmt|;
name|FT_Byte
modifier|*
specifier|volatile
name|p
init|=
name|table
decl_stmt|;
name|FT_Library
name|library
init|=
name|FT_FACE_LIBRARY
argument_list|(
name|face
argument_list|)
decl_stmt|;
name|FT_UNUSED
argument_list|(
name|library
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|+
literal|4
operator|>
name|limit
condition|)
return|return
name|SFNT_Err_Invalid_Table
return|;
comment|/* only recognize format 0 */
if|if
condition|(
name|TT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|p
operator|-=
literal|2
expr_stmt|;
name|FT_ERROR
argument_list|(
operator|(
literal|"tt_face_build_cmaps:"
literal|" unsupported `cmap' table format = %d\n"
operator|,
name|TT_PEEK_USHORT
argument_list|(
name|p
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|SFNT_Err_Invalid_Table
return|;
block|}
name|num_cmaps
operator|=
name|TT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|num_cmaps
operator|>
literal|0
operator|&&
name|p
operator|+
literal|8
operator|<=
name|limit
condition|;
name|num_cmaps
operator|--
control|)
block|{
name|FT_CharMapRec
name|charmap
decl_stmt|;
name|FT_UInt32
name|offset
decl_stmt|;
name|charmap
operator|.
name|platform_id
operator|=
name|TT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|charmap
operator|.
name|encoding_id
operator|=
name|TT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|charmap
operator|.
name|face
operator|=
name|FT_FACE
argument_list|(
name|face
argument_list|)
expr_stmt|;
name|charmap
operator|.
name|encoding
operator|=
name|FT_ENCODING_NONE
expr_stmt|;
comment|/* will be filled later */
name|offset
operator|=
name|TT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|&&
name|offset
operator|<=
name|face
operator|->
name|cmap_size
operator|-
literal|2
condition|)
block|{
name|FT_Byte
modifier|*
specifier|volatile
name|cmap
init|=
name|table
operator|+
name|offset
decl_stmt|;
specifier|volatile
name|FT_UInt
name|format
init|=
name|TT_PEEK_USHORT
argument_list|(
name|cmap
argument_list|)
decl_stmt|;
specifier|const
name|TT_CMap_Class
modifier|*
specifier|volatile
name|pclazz
init|=
name|FT_TT_CMAP_CLASSES_GET
decl_stmt|;
name|TT_CMap_Class
specifier|volatile
name|clazz
decl_stmt|;
for|for
control|(
init|;
operator|*
name|pclazz
condition|;
name|pclazz
operator|++
control|)
block|{
name|clazz
operator|=
operator|*
name|pclazz
expr_stmt|;
if|if
condition|(
name|clazz
operator|->
name|format
operator|==
name|format
condition|)
block|{
specifier|volatile
name|TT_ValidatorRec
name|valid
decl_stmt|;
specifier|volatile
name|FT_Error
name|error
init|=
name|SFNT_Err_Ok
decl_stmt|;
name|ft_validator_init
argument_list|(
name|FT_VALIDATOR
argument_list|(
operator|&
name|valid
argument_list|)
argument_list|,
name|cmap
argument_list|,
name|limit
argument_list|,
name|FT_VALIDATE_DEFAULT
argument_list|)
expr_stmt|;
name|valid
operator|.
name|num_glyphs
operator|=
operator|(
name|FT_UInt
operator|)
name|face
operator|->
name|max_profile
operator|.
name|numGlyphs
expr_stmt|;
if|if
condition|(
name|ft_setjmp
argument_list|(
operator|*
operator|(
operator|(
name|ft_jmp_buf
operator|*
operator|)
operator|&
name|FT_VALIDATOR
argument_list|(
operator|&
name|valid
argument_list|)
operator|->
name|jump_buffer
operator|)
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* validate this cmap sub-table */
name|error
operator|=
name|clazz
operator|->
name|validate
argument_list|(
name|cmap
argument_list|,
name|FT_VALIDATOR
argument_list|(
operator|&
name|valid
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|valid
operator|.
name|validator
operator|.
name|error
operator|==
literal|0
condition|)
block|{
name|FT_CMap
name|ttcmap
decl_stmt|;
comment|/* It might make sense to store the single variation selector */
comment|/* cmap somewhere special.  But it would have to be in the    */
comment|/* public FT_FaceRec, and we can't change that.               */
if|if
condition|(
operator|!
name|FT_CMap_New
argument_list|(
operator|(
name|FT_CMap_Class
operator|)
name|clazz
argument_list|,
name|cmap
argument_list|,
operator|&
name|charmap
argument_list|,
operator|&
name|ttcmap
argument_list|)
condition|)
block|{
comment|/* it is simpler to directly set `flags' than adding */
comment|/* a parameter to FT_CMap_New                        */
operator|(
operator|(
name|TT_CMap
operator|)
name|ttcmap
operator|)
operator|->
name|flags
operator|=
operator|(
name|FT_Int
operator|)
name|error
expr_stmt|;
block|}
block|}
else|else
block|{
name|FT_TRACE0
argument_list|(
operator|(
literal|"tt_face_build_cmaps:"
literal|" broken cmap sub-table ignored\n"
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
if|if
condition|(
operator|*
name|pclazz
operator|==
name|NULL
condition|)
block|{
name|FT_TRACE0
argument_list|(
operator|(
literal|"tt_face_build_cmaps:"
literal|" unsupported cmap sub-table ignored\n"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|SFNT_Err_Ok
return|;
block|}
end_block
begin_macro
name|FT_LOCAL
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|tt_get_cmap_info
argument_list|(
argument|FT_CharMap    charmap
argument_list|,
argument|TT_CMapInfo  *cmap_info
argument_list|)
end_macro
begin_block
block|{
name|FT_CMap
name|cmap
init|=
operator|(
name|FT_CMap
operator|)
name|charmap
decl_stmt|;
name|TT_CMap_Class
name|clazz
init|=
operator|(
name|TT_CMap_Class
operator|)
name|cmap
operator|->
name|clazz
decl_stmt|;
return|return
name|clazz
operator|->
name|get_cmap_info
argument_list|(
name|charmap
argument_list|,
name|cmap_info
argument_list|)
return|;
block|}
end_block
begin_comment
comment|/* END */
end_comment
end_unit
