begin_unit
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  sfobjs.c                                                               */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*    SFNT object management (base).                                       */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 by       */
end_comment
begin_comment
comment|/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  This file is part of the FreeType project, and may only be used,       */
end_comment
begin_comment
comment|/*  modified, and distributed under the terms of the FreeType project      */
end_comment
begin_comment
comment|/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
end_comment
begin_comment
comment|/*  this file you indicate that you have read the license and              */
end_comment
begin_comment
comment|/*  understand and accept it fully.                                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<ft2build.h>
end_include
begin_include
include|#
directive|include
file|"sfobjs.h"
end_include
begin_include
include|#
directive|include
file|"ttload.h"
end_include
begin_include
include|#
directive|include
file|"ttcmap.h"
end_include
begin_include
include|#
directive|include
file|"ttkern.h"
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_SFNT_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_DEBUG_H
end_include
begin_include
include|#
directive|include
include|FT_TRUETYPE_IDS_H
end_include
begin_include
include|#
directive|include
include|FT_TRUETYPE_TAGS_H
end_include
begin_include
include|#
directive|include
include|FT_SERVICE_POSTSCRIPT_CMAPS_H
end_include
begin_include
include|#
directive|include
include|FT_SFNT_NAMES_H
end_include
begin_include
include|#
directive|include
file|"sferrors.h"
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_BDF
end_ifdef
begin_include
include|#
directive|include
file|"ttbdf.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
end_comment
begin_comment
comment|/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
end_comment
begin_comment
comment|/* messages during execution.                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_undef
DECL|macro|FT_COMPONENT
undef|#
directive|undef
name|FT_COMPONENT
end_undef
begin_define
DECL|macro|FT_COMPONENT
define|#
directive|define
name|FT_COMPONENT
value|trace_sfobjs
end_define
begin_comment
comment|/* convert a UTF-16 name entry to ASCII */
end_comment
begin_function
specifier|static
name|FT_String
modifier|*
DECL|function|tt_name_entry_ascii_from_utf16
name|tt_name_entry_ascii_from_utf16
parameter_list|(
name|TT_NameEntry
name|entry
parameter_list|,
name|FT_Memory
name|memory
parameter_list|)
block|{
name|FT_String
modifier|*
name|string
decl_stmt|;
name|FT_UInt
name|len
decl_stmt|,
name|code
decl_stmt|,
name|n
decl_stmt|;
name|FT_Byte
modifier|*
name|read
init|=
operator|(
name|FT_Byte
operator|*
operator|)
name|entry
operator|->
name|string
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|len
operator|=
operator|(
name|FT_UInt
operator|)
name|entry
operator|->
name|stringLength
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|string
argument_list|,
name|len
operator|+
literal|1
argument_list|)
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|len
condition|;
name|n
operator|++
control|)
block|{
name|code
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|read
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|32
operator|||
name|code
operator|>
literal|127
condition|)
name|code
operator|=
literal|'?'
expr_stmt|;
name|string
index|[
name|n
index|]
operator|=
operator|(
name|char
operator|)
name|code
expr_stmt|;
block|}
name|string
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|string
return|;
block|}
end_function
begin_comment
comment|/* convert an Apple Roman or symbol name entry to ASCII */
end_comment
begin_function
specifier|static
name|FT_String
modifier|*
DECL|function|tt_name_entry_ascii_from_other
name|tt_name_entry_ascii_from_other
parameter_list|(
name|TT_NameEntry
name|entry
parameter_list|,
name|FT_Memory
name|memory
parameter_list|)
block|{
name|FT_String
modifier|*
name|string
decl_stmt|;
name|FT_UInt
name|len
decl_stmt|,
name|code
decl_stmt|,
name|n
decl_stmt|;
name|FT_Byte
modifier|*
name|read
init|=
operator|(
name|FT_Byte
operator|*
operator|)
name|entry
operator|->
name|string
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|len
operator|=
operator|(
name|FT_UInt
operator|)
name|entry
operator|->
name|stringLength
expr_stmt|;
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|string
argument_list|,
name|len
operator|+
literal|1
argument_list|)
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|len
condition|;
name|n
operator|++
control|)
block|{
name|code
operator|=
operator|*
name|read
operator|++
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|32
operator|||
name|code
operator|>
literal|127
condition|)
name|code
operator|=
literal|'?'
expr_stmt|;
name|string
index|[
name|n
index|]
operator|=
operator|(
name|char
operator|)
name|code
expr_stmt|;
block|}
name|string
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|string
return|;
block|}
end_function
begin_typedef
DECL|typedef|TT_NameEntry_ConvertFunc
typedef|typedef
name|FT_String
modifier|*
function_decl|(
modifier|*
name|TT_NameEntry_ConvertFunc
function_decl|)
parameter_list|(
name|TT_NameEntry
name|entry
parameter_list|,
name|FT_Memory
name|memory
parameter_list|)
function_decl|;
end_typedef
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    tt_face_get_name                                                   */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Returns a given ENGLISH name record in ASCII.                      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    face   :: A handle to the source face object.                      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    nameid :: The name id of the name record to return.                */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<InOut>                                                               */
end_comment
begin_comment
comment|/*    name   :: The address of a string pointer.  NULL if no name is     */
end_comment
begin_comment
comment|/*              present.                                                 */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    FreeType error code.  0 means success.                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|tt_face_get_name
name|tt_face_get_name
parameter_list|(
name|TT_Face
name|face
parameter_list|,
name|FT_UShort
name|nameid
parameter_list|,
name|FT_String
modifier|*
modifier|*
name|name
parameter_list|)
block|{
name|FT_Memory
name|memory
init|=
name|face
operator|->
name|root
operator|.
name|memory
decl_stmt|;
name|FT_Error
name|error
init|=
name|SFNT_Err_Ok
decl_stmt|;
name|FT_String
modifier|*
name|result
init|=
name|NULL
decl_stmt|;
name|FT_UShort
name|n
decl_stmt|;
name|TT_NameEntryRec
modifier|*
name|rec
decl_stmt|;
name|FT_Int
name|found_apple
init|=
operator|-
literal|1
decl_stmt|;
name|FT_Int
name|found_apple_roman
init|=
operator|-
literal|1
decl_stmt|;
name|FT_Int
name|found_apple_english
init|=
operator|-
literal|1
decl_stmt|;
name|FT_Int
name|found_win
init|=
operator|-
literal|1
decl_stmt|;
name|FT_Int
name|found_unicode
init|=
operator|-
literal|1
decl_stmt|;
name|FT_Bool
name|is_english
init|=
literal|0
decl_stmt|;
name|TT_NameEntry_ConvertFunc
name|convert
decl_stmt|;
name|FT_ASSERT
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|rec
operator|=
name|face
operator|->
name|name_table
operator|.
name|names
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|face
operator|->
name|num_names
condition|;
name|n
operator|++
operator|,
name|rec
operator|++
control|)
block|{
comment|/* According to the OpenType 1.3 specification, only Microsoft or  */
comment|/* Apple platform IDs might be used in the `name' table.  The      */
comment|/* `Unicode' platform is reserved for the `cmap' table, and the    */
comment|/* `Iso' one is deprecated.                                        */
comment|/*                                                                 */
comment|/* However, the Apple TrueType specification doesn't say the same  */
comment|/* thing and goes to suggest that all Unicode `name' table entries */
comment|/* should be coded in UTF-16 (in big-endian format I suppose).     */
comment|/*                                                                 */
if|if
condition|(
name|rec
operator|->
name|nameID
operator|==
name|nameid
operator|&&
name|rec
operator|->
name|stringLength
operator|>
literal|0
condition|)
block|{
switch|switch
condition|(
name|rec
operator|->
name|platformID
condition|)
block|{
case|case
name|TT_PLATFORM_APPLE_UNICODE
case|:
case|case
name|TT_PLATFORM_ISO
case|:
comment|/* there is `languageID' to check there.  We should use this */
comment|/* field only as a last solution when nothing else is        */
comment|/* available.                                                */
comment|/*                                                           */
name|found_unicode
operator|=
name|n
expr_stmt|;
break|break;
case|case
name|TT_PLATFORM_MACINTOSH
case|:
comment|/* This is a bit special because some fonts will use either    */
comment|/* an English language id, or a Roman encoding id, to indicate */
comment|/* the English version of its font name.                       */
comment|/*                                                             */
if|if
condition|(
name|rec
operator|->
name|languageID
operator|==
name|TT_MAC_LANGID_ENGLISH
condition|)
name|found_apple_english
operator|=
name|n
expr_stmt|;
elseif|else
if|if
condition|(
name|rec
operator|->
name|encodingID
operator|==
name|TT_MAC_ID_ROMAN
condition|)
name|found_apple_roman
operator|=
name|n
expr_stmt|;
break|break;
case|case
name|TT_PLATFORM_MICROSOFT
case|:
comment|/* we only take a non-English name when there is nothing */
comment|/* else available in the font                            */
comment|/*                                                       */
if|if
condition|(
name|found_win
operator|==
operator|-
literal|1
operator|||
operator|(
name|rec
operator|->
name|languageID
operator|&
literal|0x3FF
operator|)
operator|==
literal|0x009
condition|)
block|{
switch|switch
condition|(
name|rec
operator|->
name|encodingID
condition|)
block|{
case|case
name|TT_MS_ID_SYMBOL_CS
case|:
case|case
name|TT_MS_ID_UNICODE_CS
case|:
case|case
name|TT_MS_ID_UCS_4
case|:
name|is_english
operator|=
name|FT_BOOL
argument_list|(
operator|(
name|rec
operator|->
name|languageID
operator|&
literal|0x3FF
operator|)
operator|==
literal|0x009
argument_list|)
expr_stmt|;
name|found_win
operator|=
name|n
expr_stmt|;
break|break;
default|default:
empty_stmt|;
block|}
block|}
break|break;
default|default:
empty_stmt|;
block|}
block|}
block|}
name|found_apple
operator|=
name|found_apple_roman
expr_stmt|;
if|if
condition|(
name|found_apple_english
operator|>=
literal|0
condition|)
name|found_apple
operator|=
name|found_apple_english
expr_stmt|;
comment|/* some fonts contain invalid Unicode or Macintosh formatted entries; */
comment|/* we will thus favor names encoded in Windows formats if available   */
comment|/* (provided it is an English name)                                   */
comment|/*                                                                    */
name|convert
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|found_win
operator|>=
literal|0
operator|&&
operator|!
operator|(
name|found_apple
operator|>=
literal|0
operator|&&
operator|!
name|is_english
operator|)
condition|)
block|{
name|rec
operator|=
name|face
operator|->
name|name_table
operator|.
name|names
operator|+
name|found_win
expr_stmt|;
switch|switch
condition|(
name|rec
operator|->
name|encodingID
condition|)
block|{
comment|/* all Unicode strings are encoded using UTF-16BE */
case|case
name|TT_MS_ID_UNICODE_CS
case|:
case|case
name|TT_MS_ID_SYMBOL_CS
case|:
name|convert
operator|=
name|tt_name_entry_ascii_from_utf16
expr_stmt|;
break|break;
case|case
name|TT_MS_ID_UCS_4
case|:
comment|/* Apparently, if this value is found in a name table entry, it is */
comment|/* documented as `full Unicode repertoire'.  Experience with the   */
comment|/* MsGothic font shipped with Windows Vista shows that this really */
comment|/* means UTF-16 encoded names (UCS-4 values are only used within   */
comment|/* charmaps).                                                      */
name|convert
operator|=
name|tt_name_entry_ascii_from_utf16
expr_stmt|;
break|break;
default|default:
empty_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|found_apple
operator|>=
literal|0
condition|)
block|{
name|rec
operator|=
name|face
operator|->
name|name_table
operator|.
name|names
operator|+
name|found_apple
expr_stmt|;
name|convert
operator|=
name|tt_name_entry_ascii_from_other
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|found_unicode
operator|>=
literal|0
condition|)
block|{
name|rec
operator|=
name|face
operator|->
name|name_table
operator|.
name|names
operator|+
name|found_unicode
expr_stmt|;
name|convert
operator|=
name|tt_name_entry_ascii_from_utf16
expr_stmt|;
block|}
if|if
condition|(
name|rec
operator|&&
name|convert
condition|)
block|{
if|if
condition|(
name|rec
operator|->
name|string
operator|==
name|NULL
condition|)
block|{
name|FT_Stream
name|stream
init|=
name|face
operator|->
name|name_table
operator|.
name|stream
decl_stmt|;
if|if
condition|(
name|FT_QNEW_ARRAY
argument_list|(
name|rec
operator|->
name|string
argument_list|,
name|rec
operator|->
name|stringLength
argument_list|)
operator|||
name|FT_STREAM_SEEK
argument_list|(
name|rec
operator|->
name|stringOffset
argument_list|)
operator|||
name|FT_STREAM_READ
argument_list|(
name|rec
operator|->
name|string
argument_list|,
name|rec
operator|->
name|stringLength
argument_list|)
condition|)
block|{
name|FT_FREE
argument_list|(
name|rec
operator|->
name|string
argument_list|)
expr_stmt|;
name|rec
operator|->
name|stringLength
operator|=
literal|0
expr_stmt|;
name|result
operator|=
name|NULL
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
name|result
operator|=
name|convert
argument_list|(
name|rec
argument_list|,
name|memory
argument_list|)
expr_stmt|;
block|}
name|Exit
label|:
operator|*
name|name
operator|=
name|result
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_function
specifier|static
name|FT_Encoding
DECL|function|sfnt_find_encoding
name|sfnt_find_encoding
parameter_list|(
name|int
name|platform_id
parameter_list|,
name|int
name|encoding_id
parameter_list|)
block|{
typedef|typedef
struct|struct
name|TEncoding_
block|{
name|int
name|platform_id
decl_stmt|;
name|int
name|encoding_id
decl_stmt|;
name|FT_Encoding
name|encoding
decl_stmt|;
block|}
name|TEncoding
typedef|;
specifier|static
specifier|const
name|TEncoding
name|tt_encodings
index|[]
init|=
block|{
block|{
name|TT_PLATFORM_ISO
block|,
operator|-
literal|1
block|,
name|FT_ENCODING_UNICODE
block|}
block|,
block|{
name|TT_PLATFORM_APPLE_UNICODE
block|,
operator|-
literal|1
block|,
name|FT_ENCODING_UNICODE
block|}
block|,
block|{
name|TT_PLATFORM_MACINTOSH
block|,
name|TT_MAC_ID_ROMAN
block|,
name|FT_ENCODING_APPLE_ROMAN
block|}
block|,
block|{
name|TT_PLATFORM_MICROSOFT
block|,
name|TT_MS_ID_SYMBOL_CS
block|,
name|FT_ENCODING_MS_SYMBOL
block|}
block|,
block|{
name|TT_PLATFORM_MICROSOFT
block|,
name|TT_MS_ID_UCS_4
block|,
name|FT_ENCODING_UNICODE
block|}
block|,
block|{
name|TT_PLATFORM_MICROSOFT
block|,
name|TT_MS_ID_UNICODE_CS
block|,
name|FT_ENCODING_UNICODE
block|}
block|,
block|{
name|TT_PLATFORM_MICROSOFT
block|,
name|TT_MS_ID_SJIS
block|,
name|FT_ENCODING_SJIS
block|}
block|,
block|{
name|TT_PLATFORM_MICROSOFT
block|,
name|TT_MS_ID_GB2312
block|,
name|FT_ENCODING_GB2312
block|}
block|,
block|{
name|TT_PLATFORM_MICROSOFT
block|,
name|TT_MS_ID_BIG_5
block|,
name|FT_ENCODING_BIG5
block|}
block|,
block|{
name|TT_PLATFORM_MICROSOFT
block|,
name|TT_MS_ID_WANSUNG
block|,
name|FT_ENCODING_WANSUNG
block|}
block|,
block|{
name|TT_PLATFORM_MICROSOFT
block|,
name|TT_MS_ID_JOHAB
block|,
name|FT_ENCODING_JOHAB
block|}
block|}
decl_stmt|;
specifier|const
name|TEncoding
modifier|*
name|cur
decl_stmt|,
modifier|*
name|limit
decl_stmt|;
name|cur
operator|=
name|tt_encodings
expr_stmt|;
name|limit
operator|=
name|cur
operator|+
sizeof|sizeof
argument_list|(
name|tt_encodings
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|tt_encodings
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|cur
operator|<
name|limit
condition|;
name|cur
operator|++
control|)
block|{
if|if
condition|(
name|cur
operator|->
name|platform_id
operator|==
name|platform_id
condition|)
block|{
if|if
condition|(
name|cur
operator|->
name|encoding_id
operator|==
name|encoding_id
operator|||
name|cur
operator|->
name|encoding_id
operator|==
operator|-
literal|1
condition|)
return|return
name|cur
operator|->
name|encoding
return|;
block|}
block|}
return|return
name|FT_ENCODING_NONE
return|;
block|}
end_function
begin_comment
comment|/* Fill in face->ttc_header.  If the font is not a TTC, it is */
end_comment
begin_comment
comment|/* synthesized into a TTC with one offset table.              */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|sfnt_open_font
name|sfnt_open_font
parameter_list|(
name|FT_Stream
name|stream
parameter_list|,
name|TT_Face
name|face
parameter_list|)
block|{
name|FT_Memory
name|memory
init|=
name|stream
operator|->
name|memory
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|FT_ULong
name|tag
decl_stmt|,
name|offset
decl_stmt|;
specifier|static
specifier|const
name|FT_Frame_Field
name|ttc_header_fields
index|[]
init|=
block|{
DECL|macro|FT_STRUCTURE
undef|#
directive|undef
name|FT_STRUCTURE
DECL|macro|FT_STRUCTURE
define|#
directive|define
name|FT_STRUCTURE
value|TTC_HeaderRec
name|FT_FRAME_START
argument_list|(
literal|8
argument_list|)
block|,
name|FT_FRAME_LONG
argument_list|(
name|version
argument_list|)
block|,
name|FT_FRAME_LONG
argument_list|(
name|count
argument_list|)
block|,
name|FT_FRAME_END
block|}
decl_stmt|;
name|face
operator|->
name|ttc_header
operator|.
name|tag
operator|=
literal|0
expr_stmt|;
name|face
operator|->
name|ttc_header
operator|.
name|version
operator|=
literal|0
expr_stmt|;
name|face
operator|->
name|ttc_header
operator|.
name|count
operator|=
literal|0
expr_stmt|;
name|offset
operator|=
name|FT_STREAM_POS
argument_list|()
expr_stmt|;
if|if
condition|(
name|FT_READ_ULONG
argument_list|(
name|tag
argument_list|)
condition|)
return|return
name|error
return|;
if|if
condition|(
name|tag
operator|!=
literal|0x00010000UL
operator|&&
name|tag
operator|!=
name|TTAG_ttcf
operator|&&
name|tag
operator|!=
name|TTAG_OTTO
operator|&&
name|tag
operator|!=
name|TTAG_true
operator|&&
name|tag
operator|!=
name|TTAG_typ1
operator|&&
name|tag
operator|!=
literal|0x00020000UL
condition|)
return|return
name|SFNT_Err_Unknown_File_Format
return|;
name|face
operator|->
name|ttc_header
operator|.
name|tag
operator|=
name|TTAG_ttcf
expr_stmt|;
if|if
condition|(
name|tag
operator|==
name|TTAG_ttcf
condition|)
block|{
name|FT_Int
name|n
decl_stmt|;
name|FT_TRACE3
argument_list|(
operator|(
literal|"sfnt_open_font: file is a collection\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|FT_STREAM_READ_FIELDS
argument_list|(
name|ttc_header_fields
argument_list|,
operator|&
name|face
operator|->
name|ttc_header
argument_list|)
condition|)
return|return
name|error
return|;
comment|/* now read the offsets of each font in the file */
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|face
operator|->
name|ttc_header
operator|.
name|offsets
argument_list|,
name|face
operator|->
name|ttc_header
operator|.
name|count
argument_list|)
condition|)
return|return
name|error
return|;
if|if
condition|(
name|FT_FRAME_ENTER
argument_list|(
name|face
operator|->
name|ttc_header
operator|.
name|count
operator|*
literal|4L
argument_list|)
condition|)
return|return
name|error
return|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|face
operator|->
name|ttc_header
operator|.
name|count
condition|;
name|n
operator|++
control|)
name|face
operator|->
name|ttc_header
operator|.
name|offsets
index|[
name|n
index|]
operator|=
name|FT_GET_ULONG
argument_list|()
expr_stmt|;
name|FT_FRAME_EXIT
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|FT_TRACE3
argument_list|(
operator|(
literal|"sfnt_open_font: synthesize TTC\n"
operator|)
argument_list|)
expr_stmt|;
name|face
operator|->
name|ttc_header
operator|.
name|version
operator|=
literal|1
operator|<<
literal|16
expr_stmt|;
name|face
operator|->
name|ttc_header
operator|.
name|count
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|FT_NEW
argument_list|(
name|face
operator|->
name|ttc_header
operator|.
name|offsets
argument_list|)
condition|)
return|return
name|error
return|;
name|face
operator|->
name|ttc_header
operator|.
name|offsets
index|[
literal|0
index|]
operator|=
name|offset
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|sfnt_init_face
argument_list|(
argument|FT_Stream      stream
argument_list|,
argument|TT_Face        face
argument_list|,
argument|FT_Int         face_index
argument_list|,
argument|FT_Int         num_params
argument_list|,
argument|FT_Parameter*  params
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
decl_stmt|;
name|FT_Library
name|library
init|=
name|face
operator|->
name|root
operator|.
name|driver
operator|->
name|root
operator|.
name|library
decl_stmt|;
name|SFNT_Service
name|sfnt
decl_stmt|;
comment|/* for now, parameters are unused */
name|FT_UNUSED
argument_list|(
name|num_params
argument_list|)
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|params
argument_list|)
expr_stmt|;
name|sfnt
operator|=
operator|(
name|SFNT_Service
operator|)
name|face
operator|->
name|sfnt
expr_stmt|;
if|if
condition|(
operator|!
name|sfnt
condition|)
block|{
name|sfnt
operator|=
operator|(
name|SFNT_Service
operator|)
name|FT_Get_Module_Interface
argument_list|(
name|library
argument_list|,
literal|"sfnt"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sfnt
condition|)
return|return
name|SFNT_Err_Invalid_File_Format
return|;
name|face
operator|->
name|sfnt
operator|=
name|sfnt
expr_stmt|;
name|face
operator|->
name|goto_table
operator|=
name|sfnt
operator|->
name|goto_table
expr_stmt|;
block|}
name|FT_FACE_FIND_GLOBAL_SERVICE
argument_list|(
name|face
argument_list|,
name|face
operator|->
name|psnames
argument_list|,
name|POSTSCRIPT_CMAPS
argument_list|)
expr_stmt|;
name|error
operator|=
name|sfnt_open_font
argument_list|(
name|stream
argument_list|,
name|face
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|FT_TRACE2
argument_list|(
operator|(
literal|"sfnt_init_face: %08p, %ld\n"
operator|,
name|face
operator|,
name|face_index
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|face_index
operator|<
literal|0
condition|)
name|face_index
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|face_index
operator|>=
name|face
operator|->
name|ttc_header
operator|.
name|count
condition|)
return|return
name|SFNT_Err_Invalid_Argument
return|;
if|if
condition|(
name|FT_STREAM_SEEK
argument_list|(
name|face
operator|->
name|ttc_header
operator|.
name|offsets
index|[
name|face_index
index|]
argument_list|)
condition|)
return|return
name|error
return|;
comment|/* check that we have a valid TrueType file */
name|error
operator|=
name|sfnt
operator|->
name|load_font_dir
argument_list|(
name|face
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|face
operator|->
name|root
operator|.
name|num_faces
operator|=
name|face
operator|->
name|ttc_header
operator|.
name|count
expr_stmt|;
name|face
operator|->
name|root
operator|.
name|face_index
operator|=
name|face_index
expr_stmt|;
return|return
name|error
return|;
block|}
end_block
begin_define
DECL|macro|LOAD_
define|#
directive|define
name|LOAD_
parameter_list|(
name|x
parameter_list|)
define|\
value|do {                                                        \     FT_TRACE2(( "`" #x "' " ));                               \     FT_TRACE3(( "-->\n" ));                                   \                                                               \     error = sfnt->load_##x( face, stream );                   \                                                               \     FT_TRACE2(( "%s\n", ( !error )                            \                         ? "loaded"                            \                         : ( error == SFNT_Err_Table_Missing ) \                           ? "missing"                         \                           : "failed to load" ));              \     FT_TRACE3(( "\n" ));                                      \   } while ( 0 )
end_define
begin_define
DECL|macro|LOADM_
define|#
directive|define
name|LOADM_
parameter_list|(
name|x
parameter_list|,
name|vertical
parameter_list|)
define|\
value|do {                                                        \     FT_TRACE2(( "`%s" #x "' ",                                \                 vertical ? "vertical " : "" ));               \     FT_TRACE3(( "-->\n" ));                                   \                                                               \     error = sfnt->load_##x( face, stream, vertical );         \                                                               \     FT_TRACE2(( "%s\n", ( !error )                            \                         ? "loaded"                            \                         : ( error == SFNT_Err_Table_Missing ) \                           ? "missing"                         \                           : "failed to load" ));              \     FT_TRACE3(( "\n" ));                                      \   } while ( 0 )
end_define
begin_define
DECL|macro|GET_NAME
define|#
directive|define
name|GET_NAME
parameter_list|(
name|id
parameter_list|,
name|field
parameter_list|)
define|\
value|do {                                                        \     error = tt_face_get_name( face, TT_NAME_ID_##id, field ); \     if ( error )                                              \       goto Exit;                                              \   } while ( 0 )
end_define
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|sfnt_load_face
argument_list|(
argument|FT_Stream      stream
argument_list|,
argument|TT_Face        face
argument_list|,
argument|FT_Int         face_index
argument_list|,
argument|FT_Int         num_params
argument_list|,
argument|FT_Parameter*  params
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
decl_stmt|;
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_POSTSCRIPT_NAMES
name|FT_Error
name|psnames_error
decl_stmt|;
endif|#
directive|endif
name|FT_Bool
name|has_outline
decl_stmt|;
name|FT_Bool
name|is_apple_sbit
decl_stmt|;
name|FT_Bool
name|ignore_preferred_family
init|=
name|FALSE
decl_stmt|;
name|FT_Bool
name|ignore_preferred_subfamily
init|=
name|FALSE
decl_stmt|;
name|SFNT_Service
name|sfnt
init|=
operator|(
name|SFNT_Service
operator|)
name|face
operator|->
name|sfnt
decl_stmt|;
name|FT_UNUSED
argument_list|(
name|face_index
argument_list|)
expr_stmt|;
comment|/* Check parameters */
block|{
name|FT_Int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_params
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|params
index|[
name|i
index|]
operator|.
name|tag
operator|==
name|FT_PARAM_TAG_IGNORE_PREFERRED_FAMILY
condition|)
name|ignore_preferred_family
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|params
index|[
name|i
index|]
operator|.
name|tag
operator|==
name|FT_PARAM_TAG_IGNORE_PREFERRED_SUBFAMILY
condition|)
name|ignore_preferred_subfamily
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
comment|/* Load tables */
comment|/* We now support two SFNT-based bitmapped font formats.  They */
comment|/* are recognized easily as they do not include a `glyf'       */
comment|/* table.                                                      */
comment|/*                                                             */
comment|/* The first format comes from Apple, and uses a table named   */
comment|/* `bhed' instead of `head' to store the font header (using    */
comment|/* the same format).  It also doesn't include horizontal and   */
comment|/* vertical metrics tables (i.e. `hhea' and `vhea' tables are  */
comment|/* missing).                                                   */
comment|/*                                                             */
comment|/* The other format comes from Microsoft, and is used with     */
comment|/* WinCE/PocketPC.  It looks like a standard TTF, except that  */
comment|/* it doesn't contain outlines.                                */
comment|/*                                                             */
name|FT_TRACE2
argument_list|(
operator|(
literal|"sfnt_load_face: %08p\n\n"
operator|,
name|face
operator|)
argument_list|)
expr_stmt|;
comment|/* do we have outlines in there? */
ifdef|#
directive|ifdef
name|FT_CONFIG_OPTION_INCREMENTAL
name|has_outline
operator|=
name|FT_BOOL
argument_list|(
name|face
operator|->
name|root
operator|.
name|internal
operator|->
name|incremental_interface
operator|!=
literal|0
operator|||
name|tt_face_lookup_table
argument_list|(
name|face
argument_list|,
name|TTAG_glyf
argument_list|)
operator|!=
literal|0
operator|||
name|tt_face_lookup_table
argument_list|(
name|face
argument_list|,
name|TTAG_CFF
argument_list|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|has_outline
operator|=
name|FT_BOOL
argument_list|(
name|tt_face_lookup_table
argument_list|(
name|face
argument_list|,
name|TTAG_glyf
argument_list|)
operator|!=
literal|0
operator|||
name|tt_face_lookup_table
argument_list|(
name|face
argument_list|,
name|TTAG_CFF
argument_list|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|is_apple_sbit
operator|=
literal|0
expr_stmt|;
comment|/* if this font doesn't contain outlines, we try to load */
comment|/* a `bhed' table                                        */
if|if
condition|(
operator|!
name|has_outline
operator|&&
name|sfnt
operator|->
name|load_bhed
condition|)
block|{
name|LOAD_
argument_list|(
name|bhed
argument_list|)
expr_stmt|;
name|is_apple_sbit
operator|=
name|FT_BOOL
argument_list|(
operator|!
name|error
argument_list|)
expr_stmt|;
block|}
comment|/* load the font header (`head' table) if this isn't an Apple */
comment|/* sbit font file                                             */
if|if
condition|(
operator|!
name|is_apple_sbit
condition|)
block|{
name|LOAD_
argument_list|(
name|head
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|face
operator|->
name|header
operator|.
name|Units_Per_EM
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|SFNT_Err_Invalid_Table
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* the following tables are often not present in embedded TrueType */
comment|/* fonts within PDF documents, so don't check for them.            */
name|LOAD_
argument_list|(
name|maxp
argument_list|)
expr_stmt|;
name|LOAD_
argument_list|(
name|cmap
argument_list|)
expr_stmt|;
comment|/* the following tables are optional in PCL fonts -- */
comment|/* don't check for errors                            */
name|LOAD_
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|LOAD_
argument_list|(
name|post
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_POSTSCRIPT_NAMES
name|psnames_error
operator|=
name|error
expr_stmt|;
endif|#
directive|endif
comment|/* do not load the metrics headers and tables if this is an Apple */
comment|/* sbit font file                                                 */
if|if
condition|(
operator|!
name|is_apple_sbit
condition|)
block|{
comment|/* load the `hhea' and `hmtx' tables */
name|LOADM_
argument_list|(
name|hhea
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|LOADM_
argument_list|(
name|hmtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|SFNT_Err_Table_Missing
condition|)
block|{
name|error
operator|=
name|SFNT_Err_Hmtx_Table_Missing
expr_stmt|;
ifdef|#
directive|ifdef
name|FT_CONFIG_OPTION_INCREMENTAL
comment|/* If this is an incrementally loaded font and there are */
comment|/* overriding metrics, tolerate a missing `hmtx' table.  */
if|if
condition|(
name|face
operator|->
name|root
operator|.
name|internal
operator|->
name|incremental_interface
operator|&&
name|face
operator|->
name|root
operator|.
name|internal
operator|->
name|incremental_interface
operator|->
name|funcs
operator|->
name|get_glyph_metrics
condition|)
block|{
name|face
operator|->
name|horizontal
operator|.
name|number_Of_HMetrics
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|SFNT_Err_Ok
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
elseif|else
if|if
condition|(
name|error
operator|==
name|SFNT_Err_Table_Missing
condition|)
block|{
comment|/* No `hhea' table necessary for SFNT Mac fonts. */
if|if
condition|(
name|face
operator|->
name|format_tag
operator|==
name|TTAG_true
condition|)
block|{
name|FT_TRACE2
argument_list|(
operator|(
literal|"This is an SFNT Mac font.\n"
operator|)
argument_list|)
expr_stmt|;
name|has_outline
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|SFNT_Err_Ok
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|SFNT_Err_Horiz_Header_Missing
expr_stmt|;
ifdef|#
directive|ifdef
name|FT_CONFIG_OPTION_INCREMENTAL
comment|/* If this is an incrementally loaded font and there are */
comment|/* overriding metrics, tolerate a missing `hhea' table.  */
if|if
condition|(
name|face
operator|->
name|root
operator|.
name|internal
operator|->
name|incremental_interface
operator|&&
name|face
operator|->
name|root
operator|.
name|internal
operator|->
name|incremental_interface
operator|->
name|funcs
operator|->
name|get_glyph_metrics
condition|)
block|{
name|face
operator|->
name|horizontal
operator|.
name|number_Of_HMetrics
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|SFNT_Err_Ok
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
comment|/* try to load the `vhea' and `vmtx' tables */
name|LOADM_
argument_list|(
name|hhea
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|LOADM_
argument_list|(
name|hmtx
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|face
operator|->
name|vertical_info
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|SFNT_Err_Table_Missing
condition|)
goto|goto
name|Exit
goto|;
name|LOAD_
argument_list|(
name|os2
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|error
operator|!=
name|SFNT_Err_Table_Missing
condition|)
goto|goto
name|Exit
goto|;
name|face
operator|->
name|os2
operator|.
name|version
operator|=
literal|0xFFFFU
expr_stmt|;
block|}
block|}
comment|/* the optional tables */
comment|/* embedded bitmap support */
if|if
condition|(
name|sfnt
operator|->
name|load_eblc
condition|)
block|{
name|LOAD_
argument_list|(
name|eblc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* a font which contains neither bitmaps nor outlines is */
comment|/* still valid (although rather useless in most cases);  */
comment|/* however, you can find such stripped fonts in PDFs     */
if|if
condition|(
name|error
operator|==
name|SFNT_Err_Table_Missing
condition|)
name|error
operator|=
name|SFNT_Err_Ok
expr_stmt|;
else|else
goto|goto
name|Exit
goto|;
block|}
block|}
name|LOAD_
argument_list|(
name|pclt
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|error
operator|!=
name|SFNT_Err_Table_Missing
condition|)
goto|goto
name|Exit
goto|;
name|face
operator|->
name|pclt
operator|.
name|Version
operator|=
literal|0
expr_stmt|;
block|}
comment|/* consider the kerning and gasp tables as optional */
name|LOAD_
argument_list|(
name|gasp
argument_list|)
expr_stmt|;
name|LOAD_
argument_list|(
name|kern
argument_list|)
expr_stmt|;
name|face
operator|->
name|root
operator|.
name|num_glyphs
operator|=
name|face
operator|->
name|max_profile
operator|.
name|numGlyphs
expr_stmt|;
comment|/* Bit 8 of the `fsSelection' field in the `OS/2' table denotes  */
comment|/* a WWS-only font face.  `WWS' stands for `weight', width', and */
comment|/* `slope', a term used by Microsoft's Windows Presentation      */
comment|/* Foundation (WPF).  This flag has been introduced in version   */
comment|/* 1.5 of the OpenType specification (May 2008).                 */
name|face
operator|->
name|root
operator|.
name|family_name
operator|=
name|NULL
expr_stmt|;
name|face
operator|->
name|root
operator|.
name|style_name
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|face
operator|->
name|os2
operator|.
name|version
operator|!=
literal|0xFFFFU
operator|&&
name|face
operator|->
name|os2
operator|.
name|fsSelection
operator|&
literal|256
condition|)
block|{
if|if
condition|(
operator|!
name|ignore_preferred_family
condition|)
name|GET_NAME
argument_list|(
name|PREFERRED_FAMILY
argument_list|,
operator|&
name|face
operator|->
name|root
operator|.
name|family_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|face
operator|->
name|root
operator|.
name|family_name
condition|)
name|GET_NAME
argument_list|(
name|FONT_FAMILY
argument_list|,
operator|&
name|face
operator|->
name|root
operator|.
name|family_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ignore_preferred_subfamily
condition|)
name|GET_NAME
argument_list|(
name|PREFERRED_SUBFAMILY
argument_list|,
operator|&
name|face
operator|->
name|root
operator|.
name|style_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|face
operator|->
name|root
operator|.
name|style_name
condition|)
name|GET_NAME
argument_list|(
name|FONT_SUBFAMILY
argument_list|,
operator|&
name|face
operator|->
name|root
operator|.
name|style_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|GET_NAME
argument_list|(
name|WWS_FAMILY
argument_list|,
operator|&
name|face
operator|->
name|root
operator|.
name|family_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|face
operator|->
name|root
operator|.
name|family_name
operator|&&
operator|!
name|ignore_preferred_family
condition|)
name|GET_NAME
argument_list|(
name|PREFERRED_FAMILY
argument_list|,
operator|&
name|face
operator|->
name|root
operator|.
name|family_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|face
operator|->
name|root
operator|.
name|family_name
condition|)
name|GET_NAME
argument_list|(
name|FONT_FAMILY
argument_list|,
operator|&
name|face
operator|->
name|root
operator|.
name|family_name
argument_list|)
expr_stmt|;
name|GET_NAME
argument_list|(
name|WWS_SUBFAMILY
argument_list|,
operator|&
name|face
operator|->
name|root
operator|.
name|style_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|face
operator|->
name|root
operator|.
name|style_name
operator|&&
operator|!
name|ignore_preferred_subfamily
condition|)
name|GET_NAME
argument_list|(
name|PREFERRED_SUBFAMILY
argument_list|,
operator|&
name|face
operator|->
name|root
operator|.
name|style_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|face
operator|->
name|root
operator|.
name|style_name
condition|)
name|GET_NAME
argument_list|(
name|FONT_SUBFAMILY
argument_list|,
operator|&
name|face
operator|->
name|root
operator|.
name|style_name
argument_list|)
expr_stmt|;
block|}
comment|/* now set up root fields */
block|{
name|FT_Face
name|root
init|=
operator|&
name|face
operator|->
name|root
decl_stmt|;
name|FT_Long
name|flags
init|=
name|root
operator|->
name|face_flags
decl_stmt|;
comment|/*********************************************************************/
comment|/*                                                                   */
comment|/* Compute face flags.                                               */
comment|/*                                                                   */
if|if
condition|(
name|has_outline
operator|==
name|TRUE
condition|)
name|flags
operator||=
name|FT_FACE_FLAG_SCALABLE
expr_stmt|;
comment|/* scalable outlines */
comment|/* The sfnt driver only supports bitmap fonts natively, thus we */
comment|/* don't set FT_FACE_FLAG_HINTER.                               */
name|flags
operator||=
name|FT_FACE_FLAG_SFNT
operator||
comment|/* SFNT file format  */
name|FT_FACE_FLAG_HORIZONTAL
expr_stmt|;
comment|/* horizontal data   */
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_POSTSCRIPT_NAMES
if|if
condition|(
name|psnames_error
operator|==
name|SFNT_Err_Ok
operator|&&
name|face
operator|->
name|postscript
operator|.
name|FormatType
operator|!=
literal|0x00030000L
condition|)
name|flags
operator||=
name|FT_FACE_FLAG_GLYPH_NAMES
expr_stmt|;
endif|#
directive|endif
comment|/* fixed width font? */
if|if
condition|(
name|face
operator|->
name|postscript
operator|.
name|isFixedPitch
condition|)
name|flags
operator||=
name|FT_FACE_FLAG_FIXED_WIDTH
expr_stmt|;
comment|/* vertical information? */
if|if
condition|(
name|face
operator|->
name|vertical_info
condition|)
name|flags
operator||=
name|FT_FACE_FLAG_VERTICAL
expr_stmt|;
comment|/* kerning available ? */
if|if
condition|(
name|TT_FACE_HAS_KERNING
argument_list|(
name|face
argument_list|)
condition|)
name|flags
operator||=
name|FT_FACE_FLAG_KERNING
expr_stmt|;
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_GX_VAR_SUPPORT
comment|/* Don't bother to load the tables unless somebody asks for them. */
comment|/* No need to do work which will (probably) not be used.          */
if|if
condition|(
name|tt_face_lookup_table
argument_list|(
name|face
argument_list|,
name|TTAG_glyf
argument_list|)
operator|!=
literal|0
operator|&&
name|tt_face_lookup_table
argument_list|(
name|face
argument_list|,
name|TTAG_fvar
argument_list|)
operator|!=
literal|0
operator|&&
name|tt_face_lookup_table
argument_list|(
name|face
argument_list|,
name|TTAG_gvar
argument_list|)
operator|!=
literal|0
condition|)
name|flags
operator||=
name|FT_FACE_FLAG_MULTIPLE_MASTERS
expr_stmt|;
endif|#
directive|endif
name|root
operator|->
name|face_flags
operator|=
name|flags
expr_stmt|;
comment|/*********************************************************************/
comment|/*                                                                   */
comment|/* Compute style flags.                                              */
comment|/*                                                                   */
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|has_outline
operator|==
name|TRUE
operator|&&
name|face
operator|->
name|os2
operator|.
name|version
operator|!=
literal|0xFFFFU
condition|)
block|{
comment|/* We have an OS/2 table; use the `fsSelection' field.  Bit 9 */
comment|/* indicates an oblique font face.  This flag has been        */
comment|/* introduced in version 1.5 of the OpenType specification.   */
if|if
condition|(
name|face
operator|->
name|os2
operator|.
name|fsSelection
operator|&
literal|512
condition|)
comment|/* bit 9 */
name|flags
operator||=
name|FT_STYLE_FLAG_ITALIC
expr_stmt|;
elseif|else
if|if
condition|(
name|face
operator|->
name|os2
operator|.
name|fsSelection
operator|&
literal|1
condition|)
comment|/* bit 0 */
name|flags
operator||=
name|FT_STYLE_FLAG_ITALIC
expr_stmt|;
if|if
condition|(
name|face
operator|->
name|os2
operator|.
name|fsSelection
operator|&
literal|32
condition|)
comment|/* bit 5 */
name|flags
operator||=
name|FT_STYLE_FLAG_BOLD
expr_stmt|;
block|}
else|else
block|{
comment|/* this is an old Mac font, use the header field */
if|if
condition|(
name|face
operator|->
name|header
operator|.
name|Mac_Style
operator|&
literal|1
condition|)
name|flags
operator||=
name|FT_STYLE_FLAG_BOLD
expr_stmt|;
if|if
condition|(
name|face
operator|->
name|header
operator|.
name|Mac_Style
operator|&
literal|2
condition|)
name|flags
operator||=
name|FT_STYLE_FLAG_ITALIC
expr_stmt|;
block|}
name|root
operator|->
name|style_flags
operator|=
name|flags
expr_stmt|;
comment|/*********************************************************************/
comment|/*                                                                   */
comment|/* Polish the charmaps.                                              */
comment|/*                                                                   */
comment|/*   Try to set the charmap encoding according to the platform&     */
comment|/*   encoding ID of each charmap.                                    */
comment|/*                                                                   */
name|tt_face_build_cmaps
argument_list|(
name|face
argument_list|)
expr_stmt|;
comment|/* ignore errors */
comment|/* set the encoding fields */
block|{
name|FT_Int
name|m
decl_stmt|;
for|for
control|(
name|m
operator|=
literal|0
init|;
name|m
operator|<
name|root
operator|->
name|num_charmaps
condition|;
name|m
operator|++
control|)
block|{
name|FT_CharMap
name|charmap
init|=
name|root
operator|->
name|charmaps
index|[
name|m
index|]
decl_stmt|;
name|charmap
operator|->
name|encoding
operator|=
name|sfnt_find_encoding
argument_list|(
name|charmap
operator|->
name|platform_id
argument_list|,
name|charmap
operator|->
name|encoding_id
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if ( root->charmap     == NULL&&                charmap->encoding == FT_ENCODING_UNICODE )           {
comment|/* set 'root->charmap' to the first Unicode encoding we find */
block|root->charmap = charmap;           }
endif|#
directive|endif
block|}
block|}
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_EMBEDDED_BITMAPS
comment|/*        *  Now allocate the root array of FT_Bitmap_Size records and        *  populate them.  Unfortunately, it isn't possible to indicate bit        *  depths in the FT_Bitmap_Size record.  This is a design error.        */
block|{
name|FT_UInt
name|i
decl_stmt|,
name|count
decl_stmt|;
ifndef|#
directive|ifndef
name|FT_CONFIG_OPTION_OLD_INTERNALS
name|count
operator|=
name|face
operator|->
name|sbit_num_strikes
expr_stmt|;
else|#
directive|else
name|count
operator|=
operator|(
name|FT_UInt
operator|)
name|face
operator|->
name|num_sbit_strikes
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|FT_Memory
name|memory
init|=
name|face
operator|->
name|root
operator|.
name|stream
operator|->
name|memory
decl_stmt|;
name|FT_UShort
name|em_size
init|=
name|face
operator|->
name|header
operator|.
name|Units_Per_EM
decl_stmt|;
name|FT_Short
name|avgwidth
init|=
name|face
operator|->
name|os2
operator|.
name|xAvgCharWidth
decl_stmt|;
name|FT_Size_Metrics
name|metrics
decl_stmt|;
if|if
condition|(
name|em_size
operator|==
literal|0
operator|||
name|face
operator|->
name|os2
operator|.
name|version
operator|==
literal|0xFFFFU
condition|)
block|{
name|avgwidth
operator|=
literal|0
expr_stmt|;
name|em_size
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|root
operator|->
name|available_sizes
argument_list|,
name|count
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|FT_Bitmap_Size
modifier|*
name|bsize
init|=
name|root
operator|->
name|available_sizes
operator|+
name|i
decl_stmt|;
name|error
operator|=
name|sfnt
operator|->
name|load_strike_metrics
argument_list|(
name|face
argument_list|,
name|i
argument_list|,
operator|&
name|metrics
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|bsize
operator|->
name|height
operator|=
call|(
name|FT_Short
call|)
argument_list|(
name|metrics
operator|.
name|height
operator|>>
literal|6
argument_list|)
expr_stmt|;
name|bsize
operator|->
name|width
operator|=
call|(
name|FT_Short
call|)
argument_list|(
operator|(
name|avgwidth
operator|*
name|metrics
operator|.
name|x_ppem
operator|+
name|em_size
operator|/
literal|2
operator|)
operator|/
name|em_size
argument_list|)
expr_stmt|;
name|bsize
operator|->
name|x_ppem
operator|=
name|metrics
operator|.
name|x_ppem
operator|<<
literal|6
expr_stmt|;
name|bsize
operator|->
name|y_ppem
operator|=
name|metrics
operator|.
name|y_ppem
operator|<<
literal|6
expr_stmt|;
comment|/* assume 72dpi */
name|bsize
operator|->
name|size
operator|=
name|metrics
operator|.
name|y_ppem
operator|<<
literal|6
expr_stmt|;
block|}
name|root
operator|->
name|face_flags
operator||=
name|FT_FACE_FLAG_FIXED_SIZES
expr_stmt|;
name|root
operator|->
name|num_fixed_sizes
operator|=
operator|(
name|FT_Int
operator|)
name|count
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* TT_CONFIG_OPTION_EMBEDDED_BITMAPS */
comment|/* a font with no bitmaps and no outlines is scalable; */
comment|/* it has only empty glyphs then                       */
if|if
condition|(
operator|!
name|FT_HAS_FIXED_SIZES
argument_list|(
name|root
argument_list|)
operator|&&
operator|!
name|FT_IS_SCALABLE
argument_list|(
name|root
argument_list|)
condition|)
name|root
operator|->
name|face_flags
operator||=
name|FT_FACE_FLAG_SCALABLE
expr_stmt|;
comment|/*********************************************************************/
comment|/*                                                                   */
comment|/*  Set up metrics.                                                  */
comment|/*                                                                   */
if|if
condition|(
name|FT_IS_SCALABLE
argument_list|(
name|root
argument_list|)
condition|)
block|{
comment|/* XXX What about if outline header is missing */
comment|/*     (e.g. sfnt wrapped bitmap)?             */
name|root
operator|->
name|bbox
operator|.
name|xMin
operator|=
name|face
operator|->
name|header
operator|.
name|xMin
expr_stmt|;
name|root
operator|->
name|bbox
operator|.
name|yMin
operator|=
name|face
operator|->
name|header
operator|.
name|yMin
expr_stmt|;
name|root
operator|->
name|bbox
operator|.
name|xMax
operator|=
name|face
operator|->
name|header
operator|.
name|xMax
expr_stmt|;
name|root
operator|->
name|bbox
operator|.
name|yMax
operator|=
name|face
operator|->
name|header
operator|.
name|yMax
expr_stmt|;
name|root
operator|->
name|units_per_EM
operator|=
name|face
operator|->
name|header
operator|.
name|Units_Per_EM
expr_stmt|;
comment|/* XXX: Computing the ascender/descender/height is very different */
comment|/*      from what the specification tells you.  Apparently, we    */
comment|/*      must be careful because                                   */
comment|/*                                                                */
comment|/*      - not all fonts have an OS/2 table; in this case, we take */
comment|/*        the values in the horizontal header.  However, these    */
comment|/*        values very often are not reliable.                     */
comment|/*                                                                */
comment|/*      - otherwise, the correct typographic values are in the    */
comment|/*        sTypoAscender, sTypoDescender& sTypoLineGap fields.    */
comment|/*                                                                */
comment|/*        However, certain fonts have these fields set to 0.      */
comment|/*        Rather, they have usWinAscent& usWinDescent correctly  */
comment|/*        set (but with different values).                        */
comment|/*                                                                */
comment|/*      As an example, Arial Narrow is implemented through four   */
comment|/*      files ARIALN.TTF, ARIALNI.TTF, ARIALNB.TTF& ARIALNBI.TTF */
comment|/*                                                                */
comment|/*      Strangely, all fonts have the same values in their        */
comment|/*      sTypoXXX fields, except ARIALNB which sets them to 0.     */
comment|/*                                                                */
comment|/*      On the other hand, they all have different                */
comment|/*      usWinAscent/Descent values -- as a conclusion, the OS/2   */
comment|/*      table cannot be used to compute the text height reliably! */
comment|/*                                                                */
comment|/* The ascender/descender/height are computed from the OS/2 table */
comment|/* when found.  Otherwise, they're taken from the horizontal      */
comment|/* header.                                                        */
comment|/*                                                                */
name|root
operator|->
name|ascender
operator|=
name|face
operator|->
name|horizontal
operator|.
name|Ascender
expr_stmt|;
name|root
operator|->
name|descender
operator|=
name|face
operator|->
name|horizontal
operator|.
name|Descender
expr_stmt|;
name|root
operator|->
name|height
operator|=
call|(
name|FT_Short
call|)
argument_list|(
name|root
operator|->
name|ascender
operator|-
name|root
operator|->
name|descender
operator|+
name|face
operator|->
name|horizontal
operator|.
name|Line_Gap
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* if the line_gap is 0, we add an extra 15% to the text height --  */
comment|/* this computation is based on various versions of Times New Roman */
block|if ( face->horizontal.Line_Gap == 0 )           root->height = (FT_Short)( ( root->height * 115 + 50 ) / 100 );
endif|#
directive|endif
comment|/* 0 */
if|#
directive|if
literal|0
comment|/* some fonts have the OS/2 "sTypoAscender", "sTypoDescender"& */
comment|/* "sTypoLineGap" fields set to 0, like ARIALNB.TTF             */
block|if ( face->os2.version != 0xFFFFU&& root->ascender )         {           FT_Int  height;             root->ascender  =  face->os2.sTypoAscender;           root->descender = -face->os2.sTypoDescender;            height = root->ascender + root->descender + face->os2.sTypoLineGap;           if ( height> root->height )             root->height = height;         }
endif|#
directive|endif
comment|/* 0 */
name|root
operator|->
name|max_advance_width
operator|=
name|face
operator|->
name|horizontal
operator|.
name|advance_Width_Max
expr_stmt|;
name|root
operator|->
name|max_advance_height
operator|=
call|(
name|FT_Short
call|)
argument_list|(
name|face
operator|->
name|vertical_info
condition|?
name|face
operator|->
name|vertical
operator|.
name|advance_Height_Max
else|:
name|root
operator|->
name|height
argument_list|)
expr_stmt|;
comment|/* See http://www.microsoft.com/OpenType/OTSpec/post.htm -- */
comment|/* Adjust underline position from top edge to centre of     */
comment|/* stroke to convert TrueType meaning to FreeType meaning.  */
name|root
operator|->
name|underline_position
operator|=
name|face
operator|->
name|postscript
operator|.
name|underlinePosition
operator|-
name|face
operator|->
name|postscript
operator|.
name|underlineThickness
operator|/
literal|2
expr_stmt|;
name|root
operator|->
name|underline_thickness
operator|=
name|face
operator|->
name|postscript
operator|.
name|underlineThickness
expr_stmt|;
block|}
block|}
name|Exit
label|:
name|FT_TRACE2
argument_list|(
operator|(
literal|"sfnt_load_face: done\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_block
begin_undef
DECL|macro|LOAD_
undef|#
directive|undef
name|LOAD_
end_undef
begin_undef
DECL|macro|LOADM_
undef|#
directive|undef
name|LOADM_
end_undef
begin_undef
DECL|macro|GET_NAME
undef|#
directive|undef
name|GET_NAME
end_undef
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|sfnt_done_face
name|sfnt_done_face
argument_list|(
argument|TT_Face  face
argument_list|)
end_macro
begin_block
block|{
name|FT_Memory
name|memory
decl_stmt|;
name|SFNT_Service
name|sfnt
decl_stmt|;
if|if
condition|(
operator|!
name|face
condition|)
return|return;
name|memory
operator|=
name|face
operator|->
name|root
operator|.
name|memory
expr_stmt|;
name|sfnt
operator|=
operator|(
name|SFNT_Service
operator|)
name|face
operator|->
name|sfnt
expr_stmt|;
if|if
condition|(
name|sfnt
condition|)
block|{
comment|/* destroy the postscript names table if it is loaded */
if|if
condition|(
name|sfnt
operator|->
name|free_psnames
condition|)
name|sfnt
operator|->
name|free_psnames
argument_list|(
name|face
argument_list|)
expr_stmt|;
comment|/* destroy the embedded bitmaps table if it is loaded */
if|if
condition|(
name|sfnt
operator|->
name|free_eblc
condition|)
name|sfnt
operator|->
name|free_eblc
argument_list|(
name|face
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_BDF
comment|/* freeing the embedded BDF properties */
name|tt_face_free_bdf_props
argument_list|(
name|face
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* freeing the kerning table */
name|tt_face_done_kern
argument_list|(
name|face
argument_list|)
expr_stmt|;
comment|/* freeing the collection table */
name|FT_FREE
argument_list|(
name|face
operator|->
name|ttc_header
operator|.
name|offsets
argument_list|)
expr_stmt|;
name|face
operator|->
name|ttc_header
operator|.
name|count
operator|=
literal|0
expr_stmt|;
comment|/* freeing table directory */
name|FT_FREE
argument_list|(
name|face
operator|->
name|dir_tables
argument_list|)
expr_stmt|;
name|face
operator|->
name|num_tables
operator|=
literal|0
expr_stmt|;
block|{
name|FT_Stream
name|stream
init|=
name|FT_FACE_STREAM
argument_list|(
name|face
argument_list|)
decl_stmt|;
comment|/* simply release the 'cmap' table frame */
name|FT_FRAME_RELEASE
argument_list|(
name|face
operator|->
name|cmap_table
argument_list|)
expr_stmt|;
name|face
operator|->
name|cmap_size
operator|=
literal|0
expr_stmt|;
block|}
comment|/* freeing the horizontal metrics */
ifndef|#
directive|ifndef
name|FT_CONFIG_OPTION_OLD_INTERNALS
block|{
name|FT_Stream
name|stream
init|=
name|FT_FACE_STREAM
argument_list|(
name|face
argument_list|)
decl_stmt|;
name|FT_FRAME_RELEASE
argument_list|(
name|face
operator|->
name|horz_metrics
argument_list|)
expr_stmt|;
name|FT_FRAME_RELEASE
argument_list|(
name|face
operator|->
name|vert_metrics
argument_list|)
expr_stmt|;
name|face
operator|->
name|horz_metrics_size
operator|=
literal|0
expr_stmt|;
name|face
operator|->
name|vert_metrics_size
operator|=
literal|0
expr_stmt|;
block|}
else|#
directive|else
name|FT_FREE
argument_list|(
name|face
operator|->
name|horizontal
operator|.
name|long_metrics
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|face
operator|->
name|horizontal
operator|.
name|short_metrics
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* freeing the vertical ones, if any */
if|if
condition|(
name|face
operator|->
name|vertical_info
condition|)
block|{
name|FT_FREE
argument_list|(
name|face
operator|->
name|vertical
operator|.
name|long_metrics
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|face
operator|->
name|vertical
operator|.
name|short_metrics
argument_list|)
expr_stmt|;
name|face
operator|->
name|vertical_info
operator|=
literal|0
expr_stmt|;
block|}
comment|/* freeing the gasp table */
name|FT_FREE
argument_list|(
name|face
operator|->
name|gasp
operator|.
name|gaspRanges
argument_list|)
expr_stmt|;
name|face
operator|->
name|gasp
operator|.
name|numRanges
operator|=
literal|0
expr_stmt|;
comment|/* freeing the name table */
if|if
condition|(
name|sfnt
condition|)
name|sfnt
operator|->
name|free_name
argument_list|(
name|face
argument_list|)
expr_stmt|;
comment|/* freeing family and style name */
name|FT_FREE
argument_list|(
name|face
operator|->
name|root
operator|.
name|family_name
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|face
operator|->
name|root
operator|.
name|style_name
argument_list|)
expr_stmt|;
comment|/* freeing sbit size table */
name|FT_FREE
argument_list|(
name|face
operator|->
name|root
operator|.
name|available_sizes
argument_list|)
expr_stmt|;
name|face
operator|->
name|root
operator|.
name|num_fixed_sizes
operator|=
literal|0
expr_stmt|;
name|FT_FREE
argument_list|(
name|face
operator|->
name|postscript_name
argument_list|)
expr_stmt|;
name|face
operator|->
name|sfnt
operator|=
literal|0
expr_stmt|;
block|}
end_block
begin_comment
comment|/* END */
end_comment
end_unit
