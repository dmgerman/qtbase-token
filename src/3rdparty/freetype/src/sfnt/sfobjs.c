begin_unit
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  sfobjs.c                                                               */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*    SFNT object management (base).                                       */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  Copyright 1996-2015 by                                                 */
end_comment
begin_comment
comment|/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  This file is part of the FreeType project, and may only be used,       */
end_comment
begin_comment
comment|/*  modified, and distributed under the terms of the FreeType project      */
end_comment
begin_comment
comment|/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
end_comment
begin_comment
comment|/*  this file you indicate that you have read the license and              */
end_comment
begin_comment
comment|/*  understand and accept it fully.                                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<ft2build.h>
end_include
begin_include
include|#
directive|include
file|"sfobjs.h"
end_include
begin_include
include|#
directive|include
file|"ttload.h"
end_include
begin_include
include|#
directive|include
file|"ttcmap.h"
end_include
begin_include
include|#
directive|include
file|"ttkern.h"
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_SFNT_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_DEBUG_H
end_include
begin_include
include|#
directive|include
include|FT_TRUETYPE_IDS_H
end_include
begin_include
include|#
directive|include
include|FT_TRUETYPE_TAGS_H
end_include
begin_include
include|#
directive|include
include|FT_SERVICE_POSTSCRIPT_CMAPS_H
end_include
begin_include
include|#
directive|include
include|FT_SFNT_NAMES_H
end_include
begin_include
include|#
directive|include
include|FT_GZIP_H
end_include
begin_include
include|#
directive|include
file|"sferrors.h"
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_BDF
end_ifdef
begin_include
include|#
directive|include
file|"ttbdf.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
end_comment
begin_comment
comment|/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
end_comment
begin_comment
comment|/* messages during execution.                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_undef
DECL|macro|FT_COMPONENT
undef|#
directive|undef
name|FT_COMPONENT
end_undef
begin_define
DECL|macro|FT_COMPONENT
define|#
directive|define
name|FT_COMPONENT
value|trace_sfobjs
end_define
begin_comment
comment|/* convert a UTF-16 name entry to ASCII */
end_comment
begin_function
specifier|static
name|FT_String
modifier|*
DECL|function|tt_name_entry_ascii_from_utf16
name|tt_name_entry_ascii_from_utf16
parameter_list|(
name|TT_NameEntry
name|entry
parameter_list|,
name|FT_Memory
name|memory
parameter_list|)
block|{
name|FT_String
modifier|*
name|string
init|=
name|NULL
decl_stmt|;
name|FT_UInt
name|len
decl_stmt|,
name|code
decl_stmt|,
name|n
decl_stmt|;
name|FT_Byte
modifier|*
name|read
init|=
operator|(
name|FT_Byte
operator|*
operator|)
name|entry
operator|->
name|string
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|len
operator|=
operator|(
name|FT_UInt
operator|)
name|entry
operator|->
name|stringLength
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|string
argument_list|,
name|len
operator|+
literal|1
argument_list|)
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|len
condition|;
name|n
operator|++
control|)
block|{
name|code
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|read
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|code
operator|<
literal|32
operator|||
name|code
operator|>
literal|127
condition|)
name|code
operator|=
literal|'?'
expr_stmt|;
name|string
index|[
name|n
index|]
operator|=
operator|(
name|char
operator|)
name|code
expr_stmt|;
block|}
name|string
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|string
return|;
block|}
end_function
begin_comment
comment|/* convert an Apple Roman or symbol name entry to ASCII */
end_comment
begin_function
specifier|static
name|FT_String
modifier|*
DECL|function|tt_name_entry_ascii_from_other
name|tt_name_entry_ascii_from_other
parameter_list|(
name|TT_NameEntry
name|entry
parameter_list|,
name|FT_Memory
name|memory
parameter_list|)
block|{
name|FT_String
modifier|*
name|string
init|=
name|NULL
decl_stmt|;
name|FT_UInt
name|len
decl_stmt|,
name|code
decl_stmt|,
name|n
decl_stmt|;
name|FT_Byte
modifier|*
name|read
init|=
operator|(
name|FT_Byte
operator|*
operator|)
name|entry
operator|->
name|string
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|len
operator|=
operator|(
name|FT_UInt
operator|)
name|entry
operator|->
name|stringLength
expr_stmt|;
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|string
argument_list|,
name|len
operator|+
literal|1
argument_list|)
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|len
condition|;
name|n
operator|++
control|)
block|{
name|code
operator|=
operator|*
name|read
operator|++
expr_stmt|;
if|if
condition|(
name|code
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|code
operator|<
literal|32
operator|||
name|code
operator|>
literal|127
condition|)
name|code
operator|=
literal|'?'
expr_stmt|;
name|string
index|[
name|n
index|]
operator|=
operator|(
name|char
operator|)
name|code
expr_stmt|;
block|}
name|string
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|string
return|;
block|}
end_function
begin_typedef
DECL|typedef|TT_NameEntry_ConvertFunc
typedef|typedef
name|FT_String
modifier|*
function_decl|(
modifier|*
name|TT_NameEntry_ConvertFunc
function_decl|)
parameter_list|(
name|TT_NameEntry
name|entry
parameter_list|,
name|FT_Memory
name|memory
parameter_list|)
function_decl|;
end_typedef
begin_comment
comment|/* documentation is in sfnt.h */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|tt_face_get_name
argument_list|(
argument|TT_Face      face
argument_list|,
argument|FT_UShort    nameid
argument_list|,
argument|FT_String**  name
argument_list|)
end_macro
begin_block
block|{
name|FT_Memory
name|memory
init|=
name|face
operator|->
name|root
operator|.
name|memory
decl_stmt|;
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
name|FT_String
modifier|*
name|result
init|=
name|NULL
decl_stmt|;
name|FT_UShort
name|n
decl_stmt|;
name|TT_NameEntryRec
modifier|*
name|rec
decl_stmt|;
name|FT_Int
name|found_apple
init|=
operator|-
literal|1
decl_stmt|;
name|FT_Int
name|found_apple_roman
init|=
operator|-
literal|1
decl_stmt|;
name|FT_Int
name|found_apple_english
init|=
operator|-
literal|1
decl_stmt|;
name|FT_Int
name|found_win
init|=
operator|-
literal|1
decl_stmt|;
name|FT_Int
name|found_unicode
init|=
operator|-
literal|1
decl_stmt|;
name|FT_Bool
name|is_english
init|=
literal|0
decl_stmt|;
name|TT_NameEntry_ConvertFunc
name|convert
decl_stmt|;
name|FT_ASSERT
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|rec
operator|=
name|face
operator|->
name|name_table
operator|.
name|names
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|face
operator|->
name|num_names
condition|;
name|n
operator|++
operator|,
name|rec
operator|++
control|)
block|{
comment|/* According to the OpenType 1.3 specification, only Microsoft or  */
comment|/* Apple platform IDs might be used in the `name' table.  The      */
comment|/* `Unicode' platform is reserved for the `cmap' table, and the    */
comment|/* `ISO' one is deprecated.                                        */
comment|/*                                                                 */
comment|/* However, the Apple TrueType specification doesn't say the same  */
comment|/* thing and goes to suggest that all Unicode `name' table entries */
comment|/* should be coded in UTF-16 (in big-endian format I suppose).     */
comment|/*                                                                 */
if|if
condition|(
name|rec
operator|->
name|nameID
operator|==
name|nameid
operator|&&
name|rec
operator|->
name|stringLength
operator|>
literal|0
condition|)
block|{
switch|switch
condition|(
name|rec
operator|->
name|platformID
condition|)
block|{
case|case
name|TT_PLATFORM_APPLE_UNICODE
case|:
case|case
name|TT_PLATFORM_ISO
case|:
comment|/* there is `languageID' to check there.  We should use this */
comment|/* field only as a last solution when nothing else is        */
comment|/* available.                                                */
comment|/*                                                           */
name|found_unicode
operator|=
name|n
expr_stmt|;
break|break;
case|case
name|TT_PLATFORM_MACINTOSH
case|:
comment|/* This is a bit special because some fonts will use either    */
comment|/* an English language id, or a Roman encoding id, to indicate */
comment|/* the English version of its font name.                       */
comment|/*                                                             */
if|if
condition|(
name|rec
operator|->
name|languageID
operator|==
name|TT_MAC_LANGID_ENGLISH
condition|)
name|found_apple_english
operator|=
name|n
expr_stmt|;
elseif|else
if|if
condition|(
name|rec
operator|->
name|encodingID
operator|==
name|TT_MAC_ID_ROMAN
condition|)
name|found_apple_roman
operator|=
name|n
expr_stmt|;
break|break;
case|case
name|TT_PLATFORM_MICROSOFT
case|:
comment|/* we only take a non-English name when there is nothing */
comment|/* else available in the font                            */
comment|/*                                                       */
if|if
condition|(
name|found_win
operator|==
operator|-
literal|1
operator|||
operator|(
name|rec
operator|->
name|languageID
operator|&
literal|0x3FF
operator|)
operator|==
literal|0x009
condition|)
block|{
switch|switch
condition|(
name|rec
operator|->
name|encodingID
condition|)
block|{
case|case
name|TT_MS_ID_SYMBOL_CS
case|:
case|case
name|TT_MS_ID_UNICODE_CS
case|:
case|case
name|TT_MS_ID_UCS_4
case|:
name|is_english
operator|=
name|FT_BOOL
argument_list|(
operator|(
name|rec
operator|->
name|languageID
operator|&
literal|0x3FF
operator|)
operator|==
literal|0x009
argument_list|)
expr_stmt|;
name|found_win
operator|=
name|n
expr_stmt|;
break|break;
default|default:
empty_stmt|;
block|}
block|}
break|break;
default|default:
empty_stmt|;
block|}
block|}
block|}
name|found_apple
operator|=
name|found_apple_roman
expr_stmt|;
if|if
condition|(
name|found_apple_english
operator|>=
literal|0
condition|)
name|found_apple
operator|=
name|found_apple_english
expr_stmt|;
comment|/* some fonts contain invalid Unicode or Macintosh formatted entries; */
comment|/* we will thus favor names encoded in Windows formats if available   */
comment|/* (provided it is an English name)                                   */
comment|/*                                                                    */
name|convert
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|found_win
operator|>=
literal|0
operator|&&
operator|!
operator|(
name|found_apple
operator|>=
literal|0
operator|&&
operator|!
name|is_english
operator|)
condition|)
block|{
name|rec
operator|=
name|face
operator|->
name|name_table
operator|.
name|names
operator|+
name|found_win
expr_stmt|;
switch|switch
condition|(
name|rec
operator|->
name|encodingID
condition|)
block|{
comment|/* all Unicode strings are encoded using UTF-16BE */
case|case
name|TT_MS_ID_UNICODE_CS
case|:
case|case
name|TT_MS_ID_SYMBOL_CS
case|:
name|convert
operator|=
name|tt_name_entry_ascii_from_utf16
expr_stmt|;
break|break;
case|case
name|TT_MS_ID_UCS_4
case|:
comment|/* Apparently, if this value is found in a name table entry, it is */
comment|/* documented as `full Unicode repertoire'.  Experience with the   */
comment|/* MsGothic font shipped with Windows Vista shows that this really */
comment|/* means UTF-16 encoded names (UCS-4 values are only used within   */
comment|/* charmaps).                                                      */
name|convert
operator|=
name|tt_name_entry_ascii_from_utf16
expr_stmt|;
break|break;
default|default:
empty_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|found_apple
operator|>=
literal|0
condition|)
block|{
name|rec
operator|=
name|face
operator|->
name|name_table
operator|.
name|names
operator|+
name|found_apple
expr_stmt|;
name|convert
operator|=
name|tt_name_entry_ascii_from_other
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|found_unicode
operator|>=
literal|0
condition|)
block|{
name|rec
operator|=
name|face
operator|->
name|name_table
operator|.
name|names
operator|+
name|found_unicode
expr_stmt|;
name|convert
operator|=
name|tt_name_entry_ascii_from_utf16
expr_stmt|;
block|}
if|if
condition|(
name|rec
operator|&&
name|convert
condition|)
block|{
if|if
condition|(
name|rec
operator|->
name|string
operator|==
name|NULL
condition|)
block|{
name|FT_Stream
name|stream
init|=
name|face
operator|->
name|name_table
operator|.
name|stream
decl_stmt|;
if|if
condition|(
name|FT_QNEW_ARRAY
argument_list|(
name|rec
operator|->
name|string
argument_list|,
name|rec
operator|->
name|stringLength
argument_list|)
operator|||
name|FT_STREAM_SEEK
argument_list|(
name|rec
operator|->
name|stringOffset
argument_list|)
operator|||
name|FT_STREAM_READ
argument_list|(
name|rec
operator|->
name|string
argument_list|,
name|rec
operator|->
name|stringLength
argument_list|)
condition|)
block|{
name|FT_FREE
argument_list|(
name|rec
operator|->
name|string
argument_list|)
expr_stmt|;
name|rec
operator|->
name|stringLength
operator|=
literal|0
expr_stmt|;
name|result
operator|=
name|NULL
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
name|result
operator|=
name|convert
argument_list|(
name|rec
argument_list|,
name|memory
argument_list|)
expr_stmt|;
block|}
name|Exit
label|:
operator|*
name|name
operator|=
name|result
expr_stmt|;
return|return
name|error
return|;
block|}
end_block
begin_function
specifier|static
name|FT_Encoding
DECL|function|sfnt_find_encoding
name|sfnt_find_encoding
parameter_list|(
name|int
name|platform_id
parameter_list|,
name|int
name|encoding_id
parameter_list|)
block|{
typedef|typedef
struct|struct
name|TEncoding_
block|{
name|int
name|platform_id
decl_stmt|;
name|int
name|encoding_id
decl_stmt|;
name|FT_Encoding
name|encoding
decl_stmt|;
block|}
name|TEncoding
typedef|;
specifier|static
specifier|const
name|TEncoding
name|tt_encodings
index|[]
init|=
block|{
block|{
name|TT_PLATFORM_ISO
block|,
operator|-
literal|1
block|,
name|FT_ENCODING_UNICODE
block|}
block|,
block|{
name|TT_PLATFORM_APPLE_UNICODE
block|,
operator|-
literal|1
block|,
name|FT_ENCODING_UNICODE
block|}
block|,
block|{
name|TT_PLATFORM_MACINTOSH
block|,
name|TT_MAC_ID_ROMAN
block|,
name|FT_ENCODING_APPLE_ROMAN
block|}
block|,
block|{
name|TT_PLATFORM_MICROSOFT
block|,
name|TT_MS_ID_SYMBOL_CS
block|,
name|FT_ENCODING_MS_SYMBOL
block|}
block|,
block|{
name|TT_PLATFORM_MICROSOFT
block|,
name|TT_MS_ID_UCS_4
block|,
name|FT_ENCODING_UNICODE
block|}
block|,
block|{
name|TT_PLATFORM_MICROSOFT
block|,
name|TT_MS_ID_UNICODE_CS
block|,
name|FT_ENCODING_UNICODE
block|}
block|,
block|{
name|TT_PLATFORM_MICROSOFT
block|,
name|TT_MS_ID_SJIS
block|,
name|FT_ENCODING_SJIS
block|}
block|,
block|{
name|TT_PLATFORM_MICROSOFT
block|,
name|TT_MS_ID_GB2312
block|,
name|FT_ENCODING_GB2312
block|}
block|,
block|{
name|TT_PLATFORM_MICROSOFT
block|,
name|TT_MS_ID_BIG_5
block|,
name|FT_ENCODING_BIG5
block|}
block|,
block|{
name|TT_PLATFORM_MICROSOFT
block|,
name|TT_MS_ID_WANSUNG
block|,
name|FT_ENCODING_WANSUNG
block|}
block|,
block|{
name|TT_PLATFORM_MICROSOFT
block|,
name|TT_MS_ID_JOHAB
block|,
name|FT_ENCODING_JOHAB
block|}
block|}
decl_stmt|;
specifier|const
name|TEncoding
modifier|*
name|cur
decl_stmt|,
modifier|*
name|limit
decl_stmt|;
name|cur
operator|=
name|tt_encodings
expr_stmt|;
name|limit
operator|=
name|cur
operator|+
sizeof|sizeof
argument_list|(
name|tt_encodings
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|tt_encodings
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|cur
operator|<
name|limit
condition|;
name|cur
operator|++
control|)
block|{
if|if
condition|(
name|cur
operator|->
name|platform_id
operator|==
name|platform_id
condition|)
block|{
if|if
condition|(
name|cur
operator|->
name|encoding_id
operator|==
name|encoding_id
operator|||
name|cur
operator|->
name|encoding_id
operator|==
operator|-
literal|1
condition|)
return|return
name|cur
operator|->
name|encoding
return|;
block|}
block|}
return|return
name|FT_ENCODING_NONE
return|;
block|}
end_function
begin_define
DECL|macro|WRITE_USHORT
define|#
directive|define
name|WRITE_USHORT
parameter_list|(
name|p
parameter_list|,
name|v
parameter_list|)
define|\
value|do                                \           {                                 \             *(p)++ = (FT_Byte)( (v)>> 8 ); \             *(p)++ = (FT_Byte)( (v)>> 0 ); \                                             \           } while ( 0 )
end_define
begin_define
DECL|macro|WRITE_ULONG
define|#
directive|define
name|WRITE_ULONG
parameter_list|(
name|p
parameter_list|,
name|v
parameter_list|)
define|\
value|do                                 \           {                                  \             *(p)++ = (FT_Byte)( (v)>> 24 ); \             *(p)++ = (FT_Byte)( (v)>> 16 ); \             *(p)++ = (FT_Byte)( (v)>>  8 ); \             *(p)++ = (FT_Byte)( (v)>>  0 ); \                                              \           } while ( 0 )
end_define
begin_function
specifier|static
name|void
DECL|function|sfnt_stream_close
name|sfnt_stream_close
parameter_list|(
name|FT_Stream
name|stream
parameter_list|)
block|{
name|FT_Memory
name|memory
init|=
name|stream
operator|->
name|memory
decl_stmt|;
name|FT_FREE
argument_list|(
name|stream
operator|->
name|base
argument_list|)
expr_stmt|;
name|stream
operator|->
name|size
operator|=
literal|0
expr_stmt|;
name|stream
operator|->
name|base
operator|=
name|NULL
expr_stmt|;
name|stream
operator|->
name|close
operator|=
name|NULL
expr_stmt|;
block|}
end_function
begin_macro
name|FT_CALLBACK_DEF
argument_list|(
argument|int
argument_list|)
end_macro
begin_macro
DECL|function|compare_offsets
name|compare_offsets
argument_list|(
argument|const void*  a
argument_list|,
argument|const void*  b
argument_list|)
end_macro
begin_block
block|{
name|WOFF_Table
name|table1
init|=
operator|*
operator|(
name|WOFF_Table
operator|*
operator|)
name|a
decl_stmt|;
name|WOFF_Table
name|table2
init|=
operator|*
operator|(
name|WOFF_Table
operator|*
operator|)
name|b
decl_stmt|;
name|FT_ULong
name|offset1
init|=
name|table1
operator|->
name|Offset
decl_stmt|;
name|FT_ULong
name|offset2
init|=
name|table2
operator|->
name|Offset
decl_stmt|;
if|if
condition|(
name|offset1
operator|>
name|offset2
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|offset1
operator|<
name|offset2
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_block
begin_comment
comment|/* Replace `face->root.stream' with a stream containing the extracted */
end_comment
begin_comment
comment|/* SFNT of a WOFF font.                                               */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|woff_open_font
name|woff_open_font
parameter_list|(
name|FT_Stream
name|stream
parameter_list|,
name|TT_Face
name|face
parameter_list|)
block|{
name|FT_Memory
name|memory
init|=
name|stream
operator|->
name|memory
decl_stmt|;
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
name|WOFF_HeaderRec
name|woff
decl_stmt|;
name|WOFF_Table
name|tables
init|=
name|NULL
decl_stmt|;
name|WOFF_Table
modifier|*
name|indices
init|=
name|NULL
decl_stmt|;
name|FT_ULong
name|woff_offset
decl_stmt|;
name|FT_Byte
modifier|*
name|sfnt
init|=
name|NULL
decl_stmt|;
name|FT_Stream
name|sfnt_stream
init|=
name|NULL
decl_stmt|;
name|FT_Byte
modifier|*
name|sfnt_header
decl_stmt|;
name|FT_ULong
name|sfnt_offset
decl_stmt|;
name|FT_Int
name|nn
decl_stmt|;
name|FT_ULong
name|old_tag
init|=
literal|0
decl_stmt|;
specifier|static
specifier|const
name|FT_Frame_Field
name|woff_header_fields
index|[]
init|=
block|{
DECL|macro|FT_STRUCTURE
undef|#
directive|undef
name|FT_STRUCTURE
DECL|macro|FT_STRUCTURE
define|#
directive|define
name|FT_STRUCTURE
value|WOFF_HeaderRec
name|FT_FRAME_START
argument_list|(
literal|44
argument_list|)
block|,
name|FT_FRAME_ULONG
argument_list|(
name|signature
argument_list|)
block|,
name|FT_FRAME_ULONG
argument_list|(
name|flavor
argument_list|)
block|,
name|FT_FRAME_ULONG
argument_list|(
name|length
argument_list|)
block|,
name|FT_FRAME_USHORT
argument_list|(
name|num_tables
argument_list|)
block|,
name|FT_FRAME_USHORT
argument_list|(
name|reserved
argument_list|)
block|,
name|FT_FRAME_ULONG
argument_list|(
name|totalSfntSize
argument_list|)
block|,
name|FT_FRAME_USHORT
argument_list|(
name|majorVersion
argument_list|)
block|,
name|FT_FRAME_USHORT
argument_list|(
name|minorVersion
argument_list|)
block|,
name|FT_FRAME_ULONG
argument_list|(
name|metaOffset
argument_list|)
block|,
name|FT_FRAME_ULONG
argument_list|(
name|metaLength
argument_list|)
block|,
name|FT_FRAME_ULONG
argument_list|(
name|metaOrigLength
argument_list|)
block|,
name|FT_FRAME_ULONG
argument_list|(
name|privOffset
argument_list|)
block|,
name|FT_FRAME_ULONG
argument_list|(
name|privLength
argument_list|)
block|,
name|FT_FRAME_END
block|}
decl_stmt|;
name|FT_ASSERT
argument_list|(
name|stream
operator|==
name|face
operator|->
name|root
operator|.
name|stream
argument_list|)
expr_stmt|;
name|FT_ASSERT
argument_list|(
name|FT_STREAM_POS
argument_list|()
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|FT_STREAM_READ_FIELDS
argument_list|(
name|woff_header_fields
argument_list|,
operator|&
name|woff
argument_list|)
condition|)
return|return
name|error
return|;
comment|/* Make sure we don't recurse back here or hit TTC code. */
if|if
condition|(
name|woff
operator|.
name|flavor
operator|==
name|TTAG_wOFF
operator|||
name|woff
operator|.
name|flavor
operator|==
name|TTAG_ttcf
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_Table
argument_list|)
return|;
comment|/* Miscellaneous checks. */
if|if
condition|(
name|woff
operator|.
name|length
operator|!=
name|stream
operator|->
name|size
operator|||
name|woff
operator|.
name|num_tables
operator|==
literal|0
operator|||
literal|44
operator|+
name|woff
operator|.
name|num_tables
operator|*
literal|20UL
operator|>=
name|woff
operator|.
name|length
operator|||
literal|12
operator|+
name|woff
operator|.
name|num_tables
operator|*
literal|16UL
operator|>=
name|woff
operator|.
name|totalSfntSize
operator|||
operator|(
name|woff
operator|.
name|totalSfntSize
operator|&
literal|3
operator|)
operator|!=
literal|0
operator|||
operator|(
name|woff
operator|.
name|metaOffset
operator|==
literal|0
operator|&&
operator|(
name|woff
operator|.
name|metaLength
operator|!=
literal|0
operator|||
name|woff
operator|.
name|metaOrigLength
operator|!=
literal|0
operator|)
operator|)
operator|||
operator|(
name|woff
operator|.
name|metaLength
operator|!=
literal|0
operator|&&
name|woff
operator|.
name|metaOrigLength
operator|==
literal|0
operator|)
operator|||
operator|(
name|woff
operator|.
name|privOffset
operator|==
literal|0
operator|&&
name|woff
operator|.
name|privLength
operator|!=
literal|0
operator|)
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_Table
argument_list|)
return|;
if|if
condition|(
name|FT_ALLOC
argument_list|(
name|sfnt
argument_list|,
name|woff
operator|.
name|totalSfntSize
argument_list|)
operator|||
name|FT_NEW
argument_list|(
name|sfnt_stream
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|sfnt_header
operator|=
name|sfnt
expr_stmt|;
comment|/* Write sfnt header. */
block|{
name|FT_UInt
name|searchRange
decl_stmt|,
name|entrySelector
decl_stmt|,
name|rangeShift
decl_stmt|,
name|x
decl_stmt|;
name|x
operator|=
name|woff
operator|.
name|num_tables
expr_stmt|;
name|entrySelector
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|x
condition|)
block|{
name|x
operator|>>=
literal|1
expr_stmt|;
name|entrySelector
operator|+=
literal|1
expr_stmt|;
block|}
name|entrySelector
operator|--
expr_stmt|;
name|searchRange
operator|=
operator|(
literal|1
operator|<<
name|entrySelector
operator|)
operator|*
literal|16
expr_stmt|;
name|rangeShift
operator|=
name|woff
operator|.
name|num_tables
operator|*
literal|16
operator|-
name|searchRange
expr_stmt|;
name|WRITE_ULONG
argument_list|(
name|sfnt_header
argument_list|,
name|woff
operator|.
name|flavor
argument_list|)
expr_stmt|;
name|WRITE_USHORT
argument_list|(
name|sfnt_header
argument_list|,
name|woff
operator|.
name|num_tables
argument_list|)
expr_stmt|;
name|WRITE_USHORT
argument_list|(
name|sfnt_header
argument_list|,
name|searchRange
argument_list|)
expr_stmt|;
name|WRITE_USHORT
argument_list|(
name|sfnt_header
argument_list|,
name|entrySelector
argument_list|)
expr_stmt|;
name|WRITE_USHORT
argument_list|(
name|sfnt_header
argument_list|,
name|rangeShift
argument_list|)
expr_stmt|;
block|}
comment|/* While the entries in the sfnt header must be sorted by the */
comment|/* tag value, the tables themselves are not.  We thus have to */
comment|/* sort them by offset and check that they don't overlap.     */
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|tables
argument_list|,
name|woff
operator|.
name|num_tables
argument_list|)
operator|||
name|FT_NEW_ARRAY
argument_list|(
name|indices
argument_list|,
name|woff
operator|.
name|num_tables
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|FT_TRACE2
argument_list|(
operator|(
literal|"\n"
literal|"  tag    offset    compLen  origLen  checksum\n"
literal|"  -------------------------------------------\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|FT_FRAME_ENTER
argument_list|(
literal|20L
operator|*
name|woff
operator|.
name|num_tables
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
for|for
control|(
name|nn
operator|=
literal|0
init|;
name|nn
operator|<
name|woff
operator|.
name|num_tables
condition|;
name|nn
operator|++
control|)
block|{
name|WOFF_Table
name|table
init|=
name|tables
operator|+
name|nn
decl_stmt|;
name|table
operator|->
name|Tag
operator|=
name|FT_GET_TAG4
argument_list|()
expr_stmt|;
name|table
operator|->
name|Offset
operator|=
name|FT_GET_ULONG
argument_list|()
expr_stmt|;
name|table
operator|->
name|CompLength
operator|=
name|FT_GET_ULONG
argument_list|()
expr_stmt|;
name|table
operator|->
name|OrigLength
operator|=
name|FT_GET_ULONG
argument_list|()
expr_stmt|;
name|table
operator|->
name|CheckSum
operator|=
name|FT_GET_ULONG
argument_list|()
expr_stmt|;
name|FT_TRACE2
argument_list|(
operator|(
literal|"  %c%c%c%c  %08lx  %08lx  %08lx  %08lx\n"
operator|,
call|(
name|FT_Char
call|)
argument_list|(
name|table
operator|->
name|Tag
operator|>>
literal|24
argument_list|)
operator|,
call|(
name|FT_Char
call|)
argument_list|(
name|table
operator|->
name|Tag
operator|>>
literal|16
argument_list|)
operator|,
call|(
name|FT_Char
call|)
argument_list|(
name|table
operator|->
name|Tag
operator|>>
literal|8
argument_list|)
operator|,
call|(
name|FT_Char
call|)
argument_list|(
name|table
operator|->
name|Tag
argument_list|)
operator|,
name|table
operator|->
name|Offset
operator|,
name|table
operator|->
name|CompLength
operator|,
name|table
operator|->
name|OrigLength
operator|,
name|table
operator|->
name|CheckSum
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|table
operator|->
name|Tag
operator|<=
name|old_tag
condition|)
block|{
name|FT_FRAME_EXIT
argument_list|()
expr_stmt|;
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Table
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|old_tag
operator|=
name|table
operator|->
name|Tag
expr_stmt|;
name|indices
index|[
name|nn
index|]
operator|=
name|table
expr_stmt|;
block|}
name|FT_FRAME_EXIT
argument_list|()
expr_stmt|;
comment|/* Sort by offset. */
name|ft_qsort
argument_list|(
name|indices
argument_list|,
name|woff
operator|.
name|num_tables
argument_list|,
sizeof|sizeof
argument_list|(
name|WOFF_Table
argument_list|)
argument_list|,
name|compare_offsets
argument_list|)
expr_stmt|;
comment|/* Check offsets and lengths. */
name|woff_offset
operator|=
literal|44
operator|+
name|woff
operator|.
name|num_tables
operator|*
literal|20L
expr_stmt|;
name|sfnt_offset
operator|=
literal|12
operator|+
name|woff
operator|.
name|num_tables
operator|*
literal|16L
expr_stmt|;
for|for
control|(
name|nn
operator|=
literal|0
init|;
name|nn
operator|<
name|woff
operator|.
name|num_tables
condition|;
name|nn
operator|++
control|)
block|{
name|WOFF_Table
name|table
init|=
name|indices
index|[
name|nn
index|]
decl_stmt|;
if|if
condition|(
name|table
operator|->
name|Offset
operator|!=
name|woff_offset
operator|||
name|table
operator|->
name|CompLength
operator|>
name|woff
operator|.
name|length
operator|||
name|table
operator|->
name|Offset
operator|>
name|woff
operator|.
name|length
operator|-
name|table
operator|->
name|CompLength
operator|||
name|table
operator|->
name|OrigLength
operator|>
name|woff
operator|.
name|totalSfntSize
operator|||
name|sfnt_offset
operator|>
name|woff
operator|.
name|totalSfntSize
operator|-
name|table
operator|->
name|OrigLength
operator|||
name|table
operator|->
name|CompLength
operator|>
name|table
operator|->
name|OrigLength
condition|)
block|{
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Table
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|table
operator|->
name|OrigOffset
operator|=
name|sfnt_offset
expr_stmt|;
comment|/* The offsets must be multiples of 4. */
name|woff_offset
operator|+=
operator|(
name|table
operator|->
name|CompLength
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3U
expr_stmt|;
name|sfnt_offset
operator|+=
operator|(
name|table
operator|->
name|OrigLength
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3U
expr_stmt|;
block|}
comment|/*      * Final checks!      *      * We don't decode and check the metadata block.      * We don't check table checksums either.      * But other than those, I think we implement all      * `MUST' checks from the spec.      */
if|if
condition|(
name|woff
operator|.
name|metaOffset
condition|)
block|{
if|if
condition|(
name|woff
operator|.
name|metaOffset
operator|!=
name|woff_offset
operator|||
name|woff
operator|.
name|metaOffset
operator|+
name|woff
operator|.
name|metaLength
operator|>
name|woff
operator|.
name|length
condition|)
block|{
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Table
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* We have padding only ... */
name|woff_offset
operator|+=
name|woff
operator|.
name|metaLength
expr_stmt|;
block|}
if|if
condition|(
name|woff
operator|.
name|privOffset
condition|)
block|{
comment|/* ... if it isn't the last block. */
name|woff_offset
operator|=
operator|(
name|woff_offset
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3U
expr_stmt|;
if|if
condition|(
name|woff
operator|.
name|privOffset
operator|!=
name|woff_offset
operator|||
name|woff
operator|.
name|privOffset
operator|+
name|woff
operator|.
name|privLength
operator|>
name|woff
operator|.
name|length
condition|)
block|{
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Table
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* No padding for the last block. */
name|woff_offset
operator|+=
name|woff
operator|.
name|privLength
expr_stmt|;
block|}
if|if
condition|(
name|sfnt_offset
operator|!=
name|woff
operator|.
name|totalSfntSize
operator|||
name|woff_offset
operator|!=
name|woff
operator|.
name|length
condition|)
block|{
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Table
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* Write the tables. */
for|for
control|(
name|nn
operator|=
literal|0
init|;
name|nn
operator|<
name|woff
operator|.
name|num_tables
condition|;
name|nn
operator|++
control|)
block|{
name|WOFF_Table
name|table
init|=
name|tables
operator|+
name|nn
decl_stmt|;
comment|/* Write SFNT table entry. */
name|WRITE_ULONG
argument_list|(
name|sfnt_header
argument_list|,
name|table
operator|->
name|Tag
argument_list|)
expr_stmt|;
name|WRITE_ULONG
argument_list|(
name|sfnt_header
argument_list|,
name|table
operator|->
name|CheckSum
argument_list|)
expr_stmt|;
name|WRITE_ULONG
argument_list|(
name|sfnt_header
argument_list|,
name|table
operator|->
name|OrigOffset
argument_list|)
expr_stmt|;
name|WRITE_ULONG
argument_list|(
name|sfnt_header
argument_list|,
name|table
operator|->
name|OrigLength
argument_list|)
expr_stmt|;
comment|/* Write table data. */
if|if
condition|(
name|FT_STREAM_SEEK
argument_list|(
name|table
operator|->
name|Offset
argument_list|)
operator|||
name|FT_FRAME_ENTER
argument_list|(
name|table
operator|->
name|CompLength
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
if|if
condition|(
name|table
operator|->
name|CompLength
operator|==
name|table
operator|->
name|OrigLength
condition|)
block|{
comment|/* Uncompressed data; just copy. */
name|ft_memcpy
argument_list|(
name|sfnt
operator|+
name|table
operator|->
name|OrigOffset
argument_list|,
name|stream
operator|->
name|cursor
argument_list|,
name|table
operator|->
name|OrigLength
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|FT_CONFIG_OPTION_USE_ZLIB
comment|/* Uncompress with zlib. */
name|FT_ULong
name|output_len
init|=
name|table
operator|->
name|OrigLength
decl_stmt|;
name|error
operator|=
name|FT_Gzip_Uncompress
argument_list|(
name|memory
argument_list|,
name|sfnt
operator|+
name|table
operator|->
name|OrigOffset
argument_list|,
operator|&
name|output_len
argument_list|,
name|stream
operator|->
name|cursor
argument_list|,
name|table
operator|->
name|CompLength
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
if|if
condition|(
name|output_len
operator|!=
name|table
operator|->
name|OrigLength
condition|)
block|{
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Table
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
else|#
directive|else
comment|/* !FT_CONFIG_OPTION_USE_ZLIB */
name|error
operator|=
name|FT_THROW
argument_list|(
name|Unimplemented_Feature
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
endif|#
directive|endif
comment|/* !FT_CONFIG_OPTION_USE_ZLIB */
block|}
name|FT_FRAME_EXIT
argument_list|()
expr_stmt|;
comment|/* We don't check whether the padding bytes in the WOFF file are     */
comment|/* actually '\0'.  For the output, however, we do set them properly. */
name|sfnt_offset
operator|=
name|table
operator|->
name|OrigOffset
operator|+
name|table
operator|->
name|OrigLength
expr_stmt|;
while|while
condition|(
name|sfnt_offset
operator|&
literal|3
condition|)
block|{
name|sfnt
index|[
name|sfnt_offset
index|]
operator|=
literal|'\0'
expr_stmt|;
name|sfnt_offset
operator|++
expr_stmt|;
block|}
block|}
comment|/* Ok!  Finally ready.  Swap out stream and return. */
name|FT_Stream_OpenMemory
argument_list|(
name|sfnt_stream
argument_list|,
name|sfnt
argument_list|,
name|woff
operator|.
name|totalSfntSize
argument_list|)
expr_stmt|;
name|sfnt_stream
operator|->
name|memory
operator|=
name|stream
operator|->
name|memory
expr_stmt|;
name|sfnt_stream
operator|->
name|close
operator|=
name|sfnt_stream_close
expr_stmt|;
name|FT_Stream_Free
argument_list|(
name|face
operator|->
name|root
operator|.
name|stream
argument_list|,
operator|(
name|face
operator|->
name|root
operator|.
name|face_flags
operator|&
name|FT_FACE_FLAG_EXTERNAL_STREAM
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|face
operator|->
name|root
operator|.
name|stream
operator|=
name|sfnt_stream
expr_stmt|;
name|face
operator|->
name|root
operator|.
name|face_flags
operator|&=
operator|~
name|FT_FACE_FLAG_EXTERNAL_STREAM
expr_stmt|;
name|Exit
label|:
name|FT_FREE
argument_list|(
name|tables
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|indices
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|FT_FREE
argument_list|(
name|sfnt
argument_list|)
expr_stmt|;
name|FT_Stream_Close
argument_list|(
name|sfnt_stream
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|sfnt_stream
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function
begin_undef
DECL|macro|WRITE_USHORT
undef|#
directive|undef
name|WRITE_USHORT
end_undef
begin_undef
DECL|macro|WRITE_ULONG
undef|#
directive|undef
name|WRITE_ULONG
end_undef
begin_comment
comment|/* Fill in face->ttc_header.  If the font is not a TTC, it is */
end_comment
begin_comment
comment|/* synthesized into a TTC with one offset table.              */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|sfnt_open_font
name|sfnt_open_font
parameter_list|(
name|FT_Stream
name|stream
parameter_list|,
name|TT_Face
name|face
parameter_list|)
block|{
name|FT_Memory
name|memory
init|=
name|stream
operator|->
name|memory
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|FT_ULong
name|tag
decl_stmt|,
name|offset
decl_stmt|;
specifier|static
specifier|const
name|FT_Frame_Field
name|ttc_header_fields
index|[]
init|=
block|{
DECL|macro|FT_STRUCTURE
undef|#
directive|undef
name|FT_STRUCTURE
DECL|macro|FT_STRUCTURE
define|#
directive|define
name|FT_STRUCTURE
value|TTC_HeaderRec
name|FT_FRAME_START
argument_list|(
literal|8
argument_list|)
block|,
name|FT_FRAME_LONG
argument_list|(
name|version
argument_list|)
block|,
name|FT_FRAME_LONG
argument_list|(
name|count
argument_list|)
block|,
comment|/* this is ULong in the specs */
name|FT_FRAME_END
block|}
decl_stmt|;
name|face
operator|->
name|ttc_header
operator|.
name|tag
operator|=
literal|0
expr_stmt|;
name|face
operator|->
name|ttc_header
operator|.
name|version
operator|=
literal|0
expr_stmt|;
name|face
operator|->
name|ttc_header
operator|.
name|count
operator|=
literal|0
expr_stmt|;
name|retry
label|:
name|offset
operator|=
name|FT_STREAM_POS
argument_list|()
expr_stmt|;
if|if
condition|(
name|FT_READ_ULONG
argument_list|(
name|tag
argument_list|)
condition|)
return|return
name|error
return|;
if|if
condition|(
name|tag
operator|==
name|TTAG_wOFF
condition|)
block|{
name|FT_TRACE2
argument_list|(
operator|(
literal|"sfnt_open_font: file is a WOFF; synthesizing SFNT\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|FT_STREAM_SEEK
argument_list|(
name|offset
argument_list|)
condition|)
return|return
name|error
return|;
name|error
operator|=
name|woff_open_font
argument_list|(
name|stream
argument_list|,
name|face
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
comment|/* Swap out stream and retry! */
name|stream
operator|=
name|face
operator|->
name|root
operator|.
name|stream
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
if|if
condition|(
name|tag
operator|!=
literal|0x00010000UL
operator|&&
name|tag
operator|!=
name|TTAG_ttcf
operator|&&
name|tag
operator|!=
name|TTAG_OTTO
operator|&&
name|tag
operator|!=
name|TTAG_true
operator|&&
name|tag
operator|!=
name|TTAG_typ1
operator|&&
name|tag
operator|!=
literal|0x00020000UL
condition|)
block|{
name|FT_TRACE2
argument_list|(
operator|(
literal|"  not a font using the SFNT container format\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|FT_THROW
argument_list|(
name|Unknown_File_Format
argument_list|)
return|;
block|}
name|face
operator|->
name|ttc_header
operator|.
name|tag
operator|=
name|TTAG_ttcf
expr_stmt|;
if|if
condition|(
name|tag
operator|==
name|TTAG_ttcf
condition|)
block|{
name|FT_Int
name|n
decl_stmt|;
name|FT_TRACE3
argument_list|(
operator|(
literal|"sfnt_open_font: file is a collection\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|FT_STREAM_READ_FIELDS
argument_list|(
name|ttc_header_fields
argument_list|,
operator|&
name|face
operator|->
name|ttc_header
argument_list|)
condition|)
return|return
name|error
return|;
if|if
condition|(
name|face
operator|->
name|ttc_header
operator|.
name|count
operator|==
literal|0
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_Table
argument_list|)
return|;
comment|/* a rough size estimate: let's conservatively assume that there   */
comment|/* is just a single table info in each subfont header (12 + 16*1 = */
comment|/* 28 bytes), thus we have (at least) `12 + 4*count' bytes for the */
comment|/* size of the TTC header plus `28*count' bytes for all subfont    */
comment|/* headers                                                         */
if|if
condition|(
operator|(
name|FT_ULong
operator|)
name|face
operator|->
name|ttc_header
operator|.
name|count
operator|>
name|stream
operator|->
name|size
operator|/
operator|(
literal|28
operator|+
literal|4
operator|)
condition|)
return|return
name|FT_THROW
argument_list|(
name|Array_Too_Large
argument_list|)
return|;
comment|/* now read the offsets of each font in the file */
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|face
operator|->
name|ttc_header
operator|.
name|offsets
argument_list|,
name|face
operator|->
name|ttc_header
operator|.
name|count
argument_list|)
condition|)
return|return
name|error
return|;
if|if
condition|(
name|FT_FRAME_ENTER
argument_list|(
name|face
operator|->
name|ttc_header
operator|.
name|count
operator|*
literal|4L
argument_list|)
condition|)
return|return
name|error
return|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|face
operator|->
name|ttc_header
operator|.
name|count
condition|;
name|n
operator|++
control|)
name|face
operator|->
name|ttc_header
operator|.
name|offsets
index|[
name|n
index|]
operator|=
name|FT_GET_ULONG
argument_list|()
expr_stmt|;
name|FT_FRAME_EXIT
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|FT_TRACE3
argument_list|(
operator|(
literal|"sfnt_open_font: synthesize TTC\n"
operator|)
argument_list|)
expr_stmt|;
name|face
operator|->
name|ttc_header
operator|.
name|version
operator|=
literal|1
operator|<<
literal|16
expr_stmt|;
name|face
operator|->
name|ttc_header
operator|.
name|count
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|FT_NEW
argument_list|(
name|face
operator|->
name|ttc_header
operator|.
name|offsets
argument_list|)
condition|)
return|return
name|error
return|;
name|face
operator|->
name|ttc_header
operator|.
name|offsets
index|[
literal|0
index|]
operator|=
name|offset
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|sfnt_init_face
argument_list|(
argument|FT_Stream      stream
argument_list|,
argument|TT_Face        face
argument_list|,
argument|FT_Int         face_instance_index
argument_list|,
argument|FT_Int         num_params
argument_list|,
argument|FT_Parameter*  params
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
decl_stmt|;
name|FT_Library
name|library
init|=
name|face
operator|->
name|root
operator|.
name|driver
operator|->
name|root
operator|.
name|library
decl_stmt|;
name|SFNT_Service
name|sfnt
decl_stmt|;
name|FT_Int
name|face_index
decl_stmt|;
comment|/* for now, parameters are unused */
name|FT_UNUSED
argument_list|(
name|num_params
argument_list|)
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|params
argument_list|)
expr_stmt|;
name|sfnt
operator|=
operator|(
name|SFNT_Service
operator|)
name|face
operator|->
name|sfnt
expr_stmt|;
if|if
condition|(
operator|!
name|sfnt
condition|)
block|{
name|sfnt
operator|=
operator|(
name|SFNT_Service
operator|)
name|FT_Get_Module_Interface
argument_list|(
name|library
argument_list|,
literal|"sfnt"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sfnt
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"sfnt_init_face: cannot access `sfnt' module\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|FT_THROW
argument_list|(
name|Missing_Module
argument_list|)
return|;
block|}
name|face
operator|->
name|sfnt
operator|=
name|sfnt
expr_stmt|;
name|face
operator|->
name|goto_table
operator|=
name|sfnt
operator|->
name|goto_table
expr_stmt|;
block|}
name|FT_FACE_FIND_GLOBAL_SERVICE
argument_list|(
name|face
argument_list|,
name|face
operator|->
name|psnames
argument_list|,
name|POSTSCRIPT_CMAPS
argument_list|)
expr_stmt|;
name|FT_TRACE2
argument_list|(
operator|(
literal|"SFNT driver\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|sfnt_open_font
argument_list|(
name|stream
argument_list|,
name|face
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
comment|/* Stream may have changed in sfnt_open_font. */
name|stream
operator|=
name|face
operator|->
name|root
operator|.
name|stream
expr_stmt|;
name|FT_TRACE2
argument_list|(
operator|(
literal|"sfnt_init_face: %08p, %ld\n"
operator|,
name|face
operator|,
name|face_instance_index
operator|)
argument_list|)
expr_stmt|;
name|face_index
operator|=
name|FT_ABS
argument_list|(
name|face_instance_index
argument_list|)
operator|&
literal|0xFFFF
expr_stmt|;
if|if
condition|(
name|face_index
operator|>=
name|face
operator|->
name|ttc_header
operator|.
name|count
condition|)
block|{
if|if
condition|(
name|face_instance_index
operator|>=
literal|0
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_Argument
argument_list|)
return|;
else|else
name|face_index
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|FT_STREAM_SEEK
argument_list|(
name|face
operator|->
name|ttc_header
operator|.
name|offsets
index|[
name|face_index
index|]
argument_list|)
condition|)
return|return
name|error
return|;
comment|/* check whether we have a valid TrueType file */
name|error
operator|=
name|sfnt
operator|->
name|load_font_dir
argument_list|(
name|face
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_GX_VAR_SUPPORT
block|{
name|FT_ULong
name|fvar_len
decl_stmt|;
name|FT_UShort
name|num_instances
decl_stmt|;
name|FT_Int
name|instance_index
decl_stmt|;
name|instance_index
operator|=
name|FT_ABS
argument_list|(
name|face_instance_index
argument_list|)
operator|>>
literal|16
expr_stmt|;
comment|/* test whether current face is a GX font with named instances */
if|if
condition|(
name|face
operator|->
name|goto_table
argument_list|(
name|face
argument_list|,
name|TTAG_fvar
argument_list|,
name|stream
argument_list|,
operator|&
name|fvar_len
argument_list|)
operator|||
name|fvar_len
operator|<
literal|20
operator|||
name|FT_STREAM_SKIP
argument_list|(
literal|12
argument_list|)
operator|||
name|FT_READ_USHORT
argument_list|(
name|num_instances
argument_list|)
condition|)
name|num_instances
operator|=
literal|0
expr_stmt|;
comment|/* we support at most 2^15 - 1 instances */
if|if
condition|(
name|num_instances
operator|>=
operator|(
literal|1U
operator|<<
literal|15
operator|)
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|face_instance_index
operator|>=
literal|0
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_Argument
argument_list|)
return|;
else|else
name|num_instances
operator|=
literal|0
expr_stmt|;
block|}
comment|/* instance indices in `face_instance_index' start with index 1, */
comment|/* thus `>' and not `>='                                         */
if|if
condition|(
name|instance_index
operator|>
name|num_instances
condition|)
block|{
if|if
condition|(
name|face_instance_index
operator|>=
literal|0
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_Argument
argument_list|)
return|;
else|else
name|num_instances
operator|=
literal|0
expr_stmt|;
block|}
name|face
operator|->
name|root
operator|.
name|style_flags
operator|=
operator|(
name|FT_Long
operator|)
name|num_instances
operator|<<
literal|16
expr_stmt|;
block|}
endif|#
directive|endif
name|face
operator|->
name|root
operator|.
name|num_faces
operator|=
name|face
operator|->
name|ttc_header
operator|.
name|count
expr_stmt|;
name|face
operator|->
name|root
operator|.
name|face_index
operator|=
name|face_index
expr_stmt|;
return|return
name|error
return|;
block|}
end_block
begin_define
DECL|macro|LOAD_
define|#
directive|define
name|LOAD_
parameter_list|(
name|x
parameter_list|)
define|\
value|do                                                        \   {                                                         \     FT_TRACE2(( "`" #x "' " ));                             \     FT_TRACE3(( "-->\n" ));                                 \                                                             \     error = sfnt->load_ ## x( face, stream );               \                                                             \     FT_TRACE2(( "%s\n", ( !error )                          \                         ? "loaded"                          \                         : FT_ERR_EQ( error, Table_Missing ) \                           ? "missing"                       \                           : "failed to load" ));            \     FT_TRACE3(( "\n" ));                                    \   } while ( 0 )
end_define
begin_define
DECL|macro|LOADM_
define|#
directive|define
name|LOADM_
parameter_list|(
name|x
parameter_list|,
name|vertical
parameter_list|)
define|\
value|do                                                        \   {                                                         \     FT_TRACE2(( "`%s" #x "' ",                              \                 vertical ? "vertical " : "" ));             \     FT_TRACE3(( "-->\n" ));                                 \                                                             \     error = sfnt->load_ ## x( face, stream, vertical );     \                                                             \     FT_TRACE2(( "%s\n", ( !error )                          \                         ? "loaded"                          \                         : FT_ERR_EQ( error, Table_Missing ) \                           ? "missing"                       \                           : "failed to load" ));            \     FT_TRACE3(( "\n" ));                                    \   } while ( 0 )
end_define
begin_define
DECL|macro|GET_NAME
define|#
directive|define
name|GET_NAME
parameter_list|(
name|id
parameter_list|,
name|field
parameter_list|)
define|\
value|do                                                            \   {                                                             \     error = tt_face_get_name( face, TT_NAME_ID_ ## id, field ); \     if ( error )                                                \       goto Exit;                                                \   } while ( 0 )
end_define
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|sfnt_load_face
argument_list|(
argument|FT_Stream      stream
argument_list|,
argument|TT_Face        face
argument_list|,
argument|FT_Int         face_instance_index
argument_list|,
argument|FT_Int         num_params
argument_list|,
argument|FT_Parameter*  params
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
decl_stmt|;
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_POSTSCRIPT_NAMES
name|FT_Error
name|psnames_error
decl_stmt|;
endif|#
directive|endif
name|FT_Bool
name|has_outline
decl_stmt|;
name|FT_Bool
name|is_apple_sbit
decl_stmt|;
name|FT_Bool
name|is_apple_sbix
decl_stmt|;
name|FT_Bool
name|ignore_preferred_family
init|=
name|FALSE
decl_stmt|;
name|FT_Bool
name|ignore_preferred_subfamily
init|=
name|FALSE
decl_stmt|;
name|SFNT_Service
name|sfnt
init|=
operator|(
name|SFNT_Service
operator|)
name|face
operator|->
name|sfnt
decl_stmt|;
name|FT_UNUSED
argument_list|(
name|face_instance_index
argument_list|)
expr_stmt|;
comment|/* Check parameters */
block|{
name|FT_Int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_params
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|params
index|[
name|i
index|]
operator|.
name|tag
operator|==
name|FT_PARAM_TAG_IGNORE_PREFERRED_FAMILY
condition|)
name|ignore_preferred_family
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|params
index|[
name|i
index|]
operator|.
name|tag
operator|==
name|FT_PARAM_TAG_IGNORE_PREFERRED_SUBFAMILY
condition|)
name|ignore_preferred_subfamily
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
comment|/* Load tables */
comment|/* We now support two SFNT-based bitmapped font formats.  They */
comment|/* are recognized easily as they do not include a `glyf'       */
comment|/* table.                                                      */
comment|/*                                                             */
comment|/* The first format comes from Apple, and uses a table named   */
comment|/* `bhed' instead of `head' to store the font header (using    */
comment|/* the same format).  It also doesn't include horizontal and   */
comment|/* vertical metrics tables (i.e. `hhea' and `vhea' tables are  */
comment|/* missing).                                                   */
comment|/*                                                             */
comment|/* The other format comes from Microsoft, and is used with     */
comment|/* WinCE/PocketPC.  It looks like a standard TTF, except that  */
comment|/* it doesn't contain outlines.                                */
comment|/*                                                             */
name|FT_TRACE2
argument_list|(
operator|(
literal|"sfnt_load_face: %08p\n\n"
operator|,
name|face
operator|)
argument_list|)
expr_stmt|;
comment|/* do we have outlines in there? */
ifdef|#
directive|ifdef
name|FT_CONFIG_OPTION_INCREMENTAL
name|has_outline
operator|=
name|FT_BOOL
argument_list|(
name|face
operator|->
name|root
operator|.
name|internal
operator|->
name|incremental_interface
operator|!=
literal|0
operator|||
name|tt_face_lookup_table
argument_list|(
name|face
argument_list|,
name|TTAG_glyf
argument_list|)
operator|!=
literal|0
operator|||
name|tt_face_lookup_table
argument_list|(
name|face
argument_list|,
name|TTAG_CFF
argument_list|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|has_outline
operator|=
name|FT_BOOL
argument_list|(
name|tt_face_lookup_table
argument_list|(
name|face
argument_list|,
name|TTAG_glyf
argument_list|)
operator|!=
literal|0
operator|||
name|tt_face_lookup_table
argument_list|(
name|face
argument_list|,
name|TTAG_CFF
argument_list|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|is_apple_sbit
operator|=
literal|0
expr_stmt|;
name|is_apple_sbix
operator|=
operator|!
name|face
operator|->
name|goto_table
argument_list|(
name|face
argument_list|,
name|TTAG_sbix
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Apple 'sbix' color bitmaps are rendered scaled and then the 'glyf'      * outline rendered on top.  We don't support that yet, so just ignore      * the 'glyf' outline and advertise it as a bitmap-only font. */
if|if
condition|(
name|is_apple_sbix
condition|)
name|has_outline
operator|=
name|FALSE
expr_stmt|;
comment|/* if this font doesn't contain outlines, we try to load */
comment|/* a `bhed' table                                        */
if|if
condition|(
operator|!
name|has_outline
operator|&&
name|sfnt
operator|->
name|load_bhed
condition|)
block|{
name|LOAD_
argument_list|(
name|bhed
argument_list|)
expr_stmt|;
name|is_apple_sbit
operator|=
name|FT_BOOL
argument_list|(
operator|!
name|error
argument_list|)
expr_stmt|;
block|}
comment|/* load the font header (`head' table) if this isn't an Apple */
comment|/* sbit font file                                             */
if|if
condition|(
operator|!
name|is_apple_sbit
operator|||
name|is_apple_sbix
condition|)
block|{
name|LOAD_
argument_list|(
name|head
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|face
operator|->
name|header
operator|.
name|Units_Per_EM
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Table
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* the following tables are often not present in embedded TrueType */
comment|/* fonts within PDF documents, so don't check for them.            */
name|LOAD_
argument_list|(
name|maxp
argument_list|)
expr_stmt|;
name|LOAD_
argument_list|(
name|cmap
argument_list|)
expr_stmt|;
comment|/* the following tables are optional in PCL fonts -- */
comment|/* don't check for errors                            */
name|LOAD_
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|LOAD_
argument_list|(
name|post
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_POSTSCRIPT_NAMES
name|psnames_error
operator|=
name|error
expr_stmt|;
endif|#
directive|endif
comment|/* do not load the metrics headers and tables if this is an Apple */
comment|/* sbit font file                                                 */
if|if
condition|(
operator|!
name|is_apple_sbit
condition|)
block|{
comment|/* load the `hhea' and `hmtx' tables */
name|LOADM_
argument_list|(
name|hhea
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|LOADM_
argument_list|(
name|hmtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|FT_ERR_EQ
argument_list|(
name|error
argument_list|,
name|Table_Missing
argument_list|)
condition|)
block|{
name|error
operator|=
name|FT_THROW
argument_list|(
name|Hmtx_Table_Missing
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FT_CONFIG_OPTION_INCREMENTAL
comment|/* If this is an incrementally loaded font and there are */
comment|/* overriding metrics, tolerate a missing `hmtx' table.  */
if|if
condition|(
name|face
operator|->
name|root
operator|.
name|internal
operator|->
name|incremental_interface
operator|&&
name|face
operator|->
name|root
operator|.
name|internal
operator|->
name|incremental_interface
operator|->
name|funcs
operator|->
name|get_glyph_metrics
condition|)
block|{
name|face
operator|->
name|horizontal
operator|.
name|number_Of_HMetrics
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|FT_Err_Ok
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
elseif|else
if|if
condition|(
name|FT_ERR_EQ
argument_list|(
name|error
argument_list|,
name|Table_Missing
argument_list|)
condition|)
block|{
comment|/* No `hhea' table necessary for SFNT Mac fonts. */
if|if
condition|(
name|face
operator|->
name|format_tag
operator|==
name|TTAG_true
condition|)
block|{
name|FT_TRACE2
argument_list|(
operator|(
literal|"This is an SFNT Mac font.\n"
operator|)
argument_list|)
expr_stmt|;
name|has_outline
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|FT_Err_Ok
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|FT_THROW
argument_list|(
name|Horiz_Header_Missing
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FT_CONFIG_OPTION_INCREMENTAL
comment|/* If this is an incrementally loaded font and there are */
comment|/* overriding metrics, tolerate a missing `hhea' table.  */
if|if
condition|(
name|face
operator|->
name|root
operator|.
name|internal
operator|->
name|incremental_interface
operator|&&
name|face
operator|->
name|root
operator|.
name|internal
operator|->
name|incremental_interface
operator|->
name|funcs
operator|->
name|get_glyph_metrics
condition|)
block|{
name|face
operator|->
name|horizontal
operator|.
name|number_Of_HMetrics
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|FT_Err_Ok
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
comment|/* try to load the `vhea' and `vmtx' tables */
name|LOADM_
argument_list|(
name|hhea
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|LOADM_
argument_list|(
name|hmtx
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|face
operator|->
name|vertical_info
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|&&
name|FT_ERR_NEQ
argument_list|(
name|error
argument_list|,
name|Table_Missing
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|LOAD_
argument_list|(
name|os2
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* we treat the table as missing if there are any errors */
name|face
operator|->
name|os2
operator|.
name|version
operator|=
literal|0xFFFFU
expr_stmt|;
block|}
block|}
comment|/* the optional tables */
comment|/* embedded bitmap support */
if|if
condition|(
name|sfnt
operator|->
name|load_eblc
condition|)
block|{
name|LOAD_
argument_list|(
name|eblc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* a font which contains neither bitmaps nor outlines is */
comment|/* still valid (although rather useless in most cases);  */
comment|/* however, you can find such stripped fonts in PDFs     */
if|if
condition|(
name|FT_ERR_EQ
argument_list|(
name|error
argument_list|,
name|Table_Missing
argument_list|)
condition|)
name|error
operator|=
name|FT_Err_Ok
expr_stmt|;
else|else
goto|goto
name|Exit
goto|;
block|}
block|}
name|LOAD_
argument_list|(
name|pclt
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|FT_ERR_NEQ
argument_list|(
name|error
argument_list|,
name|Table_Missing
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|face
operator|->
name|pclt
operator|.
name|Version
operator|=
literal|0
expr_stmt|;
block|}
comment|/* consider the kerning and gasp tables as optional */
name|LOAD_
argument_list|(
name|gasp
argument_list|)
expr_stmt|;
name|LOAD_
argument_list|(
name|kern
argument_list|)
expr_stmt|;
name|face
operator|->
name|root
operator|.
name|num_glyphs
operator|=
name|face
operator|->
name|max_profile
operator|.
name|numGlyphs
expr_stmt|;
comment|/* Bit 8 of the `fsSelection' field in the `OS/2' table denotes  */
comment|/* a WWS-only font face.  `WWS' stands for `weight', width', and */
comment|/* `slope', a term used by Microsoft's Windows Presentation      */
comment|/* Foundation (WPF).  This flag has been introduced in version   */
comment|/* 1.5 of the OpenType specification (May 2008).                 */
name|face
operator|->
name|root
operator|.
name|family_name
operator|=
name|NULL
expr_stmt|;
name|face
operator|->
name|root
operator|.
name|style_name
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|face
operator|->
name|os2
operator|.
name|version
operator|!=
literal|0xFFFFU
operator|&&
name|face
operator|->
name|os2
operator|.
name|fsSelection
operator|&
literal|256
condition|)
block|{
if|if
condition|(
operator|!
name|ignore_preferred_family
condition|)
name|GET_NAME
argument_list|(
name|PREFERRED_FAMILY
argument_list|,
operator|&
name|face
operator|->
name|root
operator|.
name|family_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|face
operator|->
name|root
operator|.
name|family_name
condition|)
name|GET_NAME
argument_list|(
name|FONT_FAMILY
argument_list|,
operator|&
name|face
operator|->
name|root
operator|.
name|family_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ignore_preferred_subfamily
condition|)
name|GET_NAME
argument_list|(
name|PREFERRED_SUBFAMILY
argument_list|,
operator|&
name|face
operator|->
name|root
operator|.
name|style_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|face
operator|->
name|root
operator|.
name|style_name
condition|)
name|GET_NAME
argument_list|(
name|FONT_SUBFAMILY
argument_list|,
operator|&
name|face
operator|->
name|root
operator|.
name|style_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|GET_NAME
argument_list|(
name|WWS_FAMILY
argument_list|,
operator|&
name|face
operator|->
name|root
operator|.
name|family_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|face
operator|->
name|root
operator|.
name|family_name
operator|&&
operator|!
name|ignore_preferred_family
condition|)
name|GET_NAME
argument_list|(
name|PREFERRED_FAMILY
argument_list|,
operator|&
name|face
operator|->
name|root
operator|.
name|family_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|face
operator|->
name|root
operator|.
name|family_name
condition|)
name|GET_NAME
argument_list|(
name|FONT_FAMILY
argument_list|,
operator|&
name|face
operator|->
name|root
operator|.
name|family_name
argument_list|)
expr_stmt|;
name|GET_NAME
argument_list|(
name|WWS_SUBFAMILY
argument_list|,
operator|&
name|face
operator|->
name|root
operator|.
name|style_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|face
operator|->
name|root
operator|.
name|style_name
operator|&&
operator|!
name|ignore_preferred_subfamily
condition|)
name|GET_NAME
argument_list|(
name|PREFERRED_SUBFAMILY
argument_list|,
operator|&
name|face
operator|->
name|root
operator|.
name|style_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|face
operator|->
name|root
operator|.
name|style_name
condition|)
name|GET_NAME
argument_list|(
name|FONT_SUBFAMILY
argument_list|,
operator|&
name|face
operator|->
name|root
operator|.
name|style_name
argument_list|)
expr_stmt|;
block|}
comment|/* now set up root fields */
block|{
name|FT_Face
name|root
init|=
operator|&
name|face
operator|->
name|root
decl_stmt|;
name|FT_Long
name|flags
init|=
name|root
operator|->
name|face_flags
decl_stmt|;
comment|/*********************************************************************/
comment|/*                                                                   */
comment|/* Compute face flags.                                               */
comment|/*                                                                   */
if|if
condition|(
name|face
operator|->
name|sbit_table_type
operator|==
name|TT_SBIT_TABLE_TYPE_CBLC
operator|||
name|face
operator|->
name|sbit_table_type
operator|==
name|TT_SBIT_TABLE_TYPE_SBIX
condition|)
name|flags
operator||=
name|FT_FACE_FLAG_COLOR
expr_stmt|;
comment|/* color glyphs */
if|if
condition|(
name|has_outline
operator|==
name|TRUE
condition|)
name|flags
operator||=
name|FT_FACE_FLAG_SCALABLE
expr_stmt|;
comment|/* scalable outlines */
comment|/* The sfnt driver only supports bitmap fonts natively, thus we */
comment|/* don't set FT_FACE_FLAG_HINTER.                               */
name|flags
operator||=
name|FT_FACE_FLAG_SFNT
operator||
comment|/* SFNT file format  */
name|FT_FACE_FLAG_HORIZONTAL
expr_stmt|;
comment|/* horizontal data   */
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_POSTSCRIPT_NAMES
if|if
condition|(
operator|!
name|psnames_error
operator|&&
name|face
operator|->
name|postscript
operator|.
name|FormatType
operator|!=
literal|0x00030000L
condition|)
name|flags
operator||=
name|FT_FACE_FLAG_GLYPH_NAMES
expr_stmt|;
endif|#
directive|endif
comment|/* fixed width font? */
if|if
condition|(
name|face
operator|->
name|postscript
operator|.
name|isFixedPitch
condition|)
name|flags
operator||=
name|FT_FACE_FLAG_FIXED_WIDTH
expr_stmt|;
comment|/* vertical information? */
if|if
condition|(
name|face
operator|->
name|vertical_info
condition|)
name|flags
operator||=
name|FT_FACE_FLAG_VERTICAL
expr_stmt|;
comment|/* kerning available ? */
if|if
condition|(
name|TT_FACE_HAS_KERNING
argument_list|(
name|face
argument_list|)
condition|)
name|flags
operator||=
name|FT_FACE_FLAG_KERNING
expr_stmt|;
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_GX_VAR_SUPPORT
comment|/* Don't bother to load the tables unless somebody asks for them. */
comment|/* No need to do work which will (probably) not be used.          */
if|if
condition|(
name|tt_face_lookup_table
argument_list|(
name|face
argument_list|,
name|TTAG_glyf
argument_list|)
operator|!=
literal|0
operator|&&
name|tt_face_lookup_table
argument_list|(
name|face
argument_list|,
name|TTAG_fvar
argument_list|)
operator|!=
literal|0
operator|&&
name|tt_face_lookup_table
argument_list|(
name|face
argument_list|,
name|TTAG_gvar
argument_list|)
operator|!=
literal|0
condition|)
name|flags
operator||=
name|FT_FACE_FLAG_MULTIPLE_MASTERS
expr_stmt|;
endif|#
directive|endif
name|root
operator|->
name|face_flags
operator|=
name|flags
expr_stmt|;
comment|/*********************************************************************/
comment|/*                                                                   */
comment|/* Compute style flags.                                              */
comment|/*                                                                   */
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|has_outline
operator|==
name|TRUE
operator|&&
name|face
operator|->
name|os2
operator|.
name|version
operator|!=
literal|0xFFFFU
condition|)
block|{
comment|/* We have an OS/2 table; use the `fsSelection' field.  Bit 9 */
comment|/* indicates an oblique font face.  This flag has been        */
comment|/* introduced in version 1.5 of the OpenType specification.   */
if|if
condition|(
name|face
operator|->
name|os2
operator|.
name|fsSelection
operator|&
literal|512
condition|)
comment|/* bit 9 */
name|flags
operator||=
name|FT_STYLE_FLAG_ITALIC
expr_stmt|;
elseif|else
if|if
condition|(
name|face
operator|->
name|os2
operator|.
name|fsSelection
operator|&
literal|1
condition|)
comment|/* bit 0 */
name|flags
operator||=
name|FT_STYLE_FLAG_ITALIC
expr_stmt|;
if|if
condition|(
name|face
operator|->
name|os2
operator|.
name|fsSelection
operator|&
literal|32
condition|)
comment|/* bit 5 */
name|flags
operator||=
name|FT_STYLE_FLAG_BOLD
expr_stmt|;
block|}
else|else
block|{
comment|/* this is an old Mac font, use the header field */
if|if
condition|(
name|face
operator|->
name|header
operator|.
name|Mac_Style
operator|&
literal|1
condition|)
name|flags
operator||=
name|FT_STYLE_FLAG_BOLD
expr_stmt|;
if|if
condition|(
name|face
operator|->
name|header
operator|.
name|Mac_Style
operator|&
literal|2
condition|)
name|flags
operator||=
name|FT_STYLE_FLAG_ITALIC
expr_stmt|;
block|}
name|root
operator|->
name|style_flags
operator||=
name|flags
expr_stmt|;
comment|/*********************************************************************/
comment|/*                                                                   */
comment|/* Polish the charmaps.                                              */
comment|/*                                                                   */
comment|/*   Try to set the charmap encoding according to the platform&     */
comment|/*   encoding ID of each charmap.                                    */
comment|/*                                                                   */
name|tt_face_build_cmaps
argument_list|(
name|face
argument_list|)
expr_stmt|;
comment|/* ignore errors */
comment|/* set the encoding fields */
block|{
name|FT_Int
name|m
decl_stmt|;
for|for
control|(
name|m
operator|=
literal|0
init|;
name|m
operator|<
name|root
operator|->
name|num_charmaps
condition|;
name|m
operator|++
control|)
block|{
name|FT_CharMap
name|charmap
init|=
name|root
operator|->
name|charmaps
index|[
name|m
index|]
decl_stmt|;
name|charmap
operator|->
name|encoding
operator|=
name|sfnt_find_encoding
argument_list|(
name|charmap
operator|->
name|platform_id
argument_list|,
name|charmap
operator|->
name|encoding_id
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if ( root->charmap     == NULL&&                charmap->encoding == FT_ENCODING_UNICODE )           {
comment|/* set 'root->charmap' to the first Unicode encoding we find */
block|root->charmap = charmap;           }
endif|#
directive|endif
block|}
block|}
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_EMBEDDED_BITMAPS
comment|/*        *  Now allocate the root array of FT_Bitmap_Size records and        *  populate them.  Unfortunately, it isn't possible to indicate bit        *  depths in the FT_Bitmap_Size record.  This is a design error.        */
block|{
name|FT_UInt
name|i
decl_stmt|,
name|count
decl_stmt|;
name|count
operator|=
name|face
operator|->
name|sbit_num_strikes
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|FT_Memory
name|memory
init|=
name|face
operator|->
name|root
operator|.
name|stream
operator|->
name|memory
decl_stmt|;
name|FT_UShort
name|em_size
init|=
name|face
operator|->
name|header
operator|.
name|Units_Per_EM
decl_stmt|;
name|FT_Short
name|avgwidth
init|=
name|face
operator|->
name|os2
operator|.
name|xAvgCharWidth
decl_stmt|;
name|FT_Size_Metrics
name|metrics
decl_stmt|;
if|if
condition|(
name|em_size
operator|==
literal|0
operator|||
name|face
operator|->
name|os2
operator|.
name|version
operator|==
literal|0xFFFFU
condition|)
block|{
name|avgwidth
operator|=
literal|1
expr_stmt|;
name|em_size
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|root
operator|->
name|available_sizes
argument_list|,
name|count
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|FT_Bitmap_Size
modifier|*
name|bsize
init|=
name|root
operator|->
name|available_sizes
operator|+
name|i
decl_stmt|;
name|error
operator|=
name|sfnt
operator|->
name|load_strike_metrics
argument_list|(
name|face
argument_list|,
name|i
argument_list|,
operator|&
name|metrics
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|bsize
operator|->
name|height
operator|=
call|(
name|FT_Short
call|)
argument_list|(
name|metrics
operator|.
name|height
operator|>>
literal|6
argument_list|)
expr_stmt|;
name|bsize
operator|->
name|width
operator|=
call|(
name|FT_Short
call|)
argument_list|(
operator|(
name|avgwidth
operator|*
name|metrics
operator|.
name|x_ppem
operator|+
name|em_size
operator|/
literal|2
operator|)
operator|/
name|em_size
argument_list|)
expr_stmt|;
name|bsize
operator|->
name|x_ppem
operator|=
name|metrics
operator|.
name|x_ppem
operator|<<
literal|6
expr_stmt|;
name|bsize
operator|->
name|y_ppem
operator|=
name|metrics
operator|.
name|y_ppem
operator|<<
literal|6
expr_stmt|;
comment|/* assume 72dpi */
name|bsize
operator|->
name|size
operator|=
name|metrics
operator|.
name|y_ppem
operator|<<
literal|6
expr_stmt|;
block|}
name|root
operator|->
name|face_flags
operator||=
name|FT_FACE_FLAG_FIXED_SIZES
expr_stmt|;
name|root
operator|->
name|num_fixed_sizes
operator|=
operator|(
name|FT_Int
operator|)
name|count
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* TT_CONFIG_OPTION_EMBEDDED_BITMAPS */
comment|/* a font with no bitmaps and no outlines is scalable; */
comment|/* it has only empty glyphs then                       */
if|if
condition|(
operator|!
name|FT_HAS_FIXED_SIZES
argument_list|(
name|root
argument_list|)
operator|&&
operator|!
name|FT_IS_SCALABLE
argument_list|(
name|root
argument_list|)
condition|)
name|root
operator|->
name|face_flags
operator||=
name|FT_FACE_FLAG_SCALABLE
expr_stmt|;
comment|/*********************************************************************/
comment|/*                                                                   */
comment|/*  Set up metrics.                                                  */
comment|/*                                                                   */
if|if
condition|(
name|FT_IS_SCALABLE
argument_list|(
name|root
argument_list|)
condition|)
block|{
comment|/* XXX What about if outline header is missing */
comment|/*     (e.g. sfnt wrapped bitmap)?             */
name|root
operator|->
name|bbox
operator|.
name|xMin
operator|=
name|face
operator|->
name|header
operator|.
name|xMin
expr_stmt|;
name|root
operator|->
name|bbox
operator|.
name|yMin
operator|=
name|face
operator|->
name|header
operator|.
name|yMin
expr_stmt|;
name|root
operator|->
name|bbox
operator|.
name|xMax
operator|=
name|face
operator|->
name|header
operator|.
name|xMax
expr_stmt|;
name|root
operator|->
name|bbox
operator|.
name|yMax
operator|=
name|face
operator|->
name|header
operator|.
name|yMax
expr_stmt|;
name|root
operator|->
name|units_per_EM
operator|=
name|face
operator|->
name|header
operator|.
name|Units_Per_EM
expr_stmt|;
comment|/* XXX: Computing the ascender/descender/height is very different */
comment|/*      from what the specification tells you.  Apparently, we    */
comment|/*      must be careful because                                   */
comment|/*                                                                */
comment|/*      - not all fonts have an OS/2 table; in this case, we take */
comment|/*        the values in the horizontal header.  However, these    */
comment|/*        values very often are not reliable.                     */
comment|/*                                                                */
comment|/*      - otherwise, the correct typographic values are in the    */
comment|/*        sTypoAscender, sTypoDescender& sTypoLineGap fields.    */
comment|/*                                                                */
comment|/*        However, certain fonts have these fields set to 0.      */
comment|/*        Rather, they have usWinAscent& usWinDescent correctly  */
comment|/*        set (but with different values).                        */
comment|/*                                                                */
comment|/*      As an example, Arial Narrow is implemented through four   */
comment|/*      files ARIALN.TTF, ARIALNI.TTF, ARIALNB.TTF& ARIALNBI.TTF */
comment|/*                                                                */
comment|/*      Strangely, all fonts have the same values in their        */
comment|/*      sTypoXXX fields, except ARIALNB which sets them to 0.     */
comment|/*                                                                */
comment|/*      On the other hand, they all have different                */
comment|/*      usWinAscent/Descent values -- as a conclusion, the OS/2   */
comment|/*      table cannot be used to compute the text height reliably! */
comment|/*                                                                */
comment|/* The ascender and descender are taken from the `hhea' table. */
comment|/* If zero, they are taken from the `OS/2' table.              */
name|root
operator|->
name|ascender
operator|=
name|face
operator|->
name|horizontal
operator|.
name|Ascender
expr_stmt|;
name|root
operator|->
name|descender
operator|=
name|face
operator|->
name|horizontal
operator|.
name|Descender
expr_stmt|;
name|root
operator|->
name|height
operator|=
name|root
operator|->
name|ascender
operator|-
name|root
operator|->
name|descender
operator|+
name|face
operator|->
name|horizontal
operator|.
name|Line_Gap
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|root
operator|->
name|ascender
operator|||
name|root
operator|->
name|descender
operator|)
condition|)
block|{
if|if
condition|(
name|face
operator|->
name|os2
operator|.
name|version
operator|!=
literal|0xFFFFU
condition|)
block|{
if|if
condition|(
name|face
operator|->
name|os2
operator|.
name|sTypoAscender
operator|||
name|face
operator|->
name|os2
operator|.
name|sTypoDescender
condition|)
block|{
name|root
operator|->
name|ascender
operator|=
name|face
operator|->
name|os2
operator|.
name|sTypoAscender
expr_stmt|;
name|root
operator|->
name|descender
operator|=
name|face
operator|->
name|os2
operator|.
name|sTypoDescender
expr_stmt|;
name|root
operator|->
name|height
operator|=
name|root
operator|->
name|ascender
operator|-
name|root
operator|->
name|descender
operator|+
name|face
operator|->
name|os2
operator|.
name|sTypoLineGap
expr_stmt|;
block|}
else|else
block|{
name|root
operator|->
name|ascender
operator|=
operator|(
name|FT_Short
operator|)
name|face
operator|->
name|os2
operator|.
name|usWinAscent
expr_stmt|;
name|root
operator|->
name|descender
operator|=
operator|-
operator|(
name|FT_Short
operator|)
name|face
operator|->
name|os2
operator|.
name|usWinDescent
expr_stmt|;
name|root
operator|->
name|height
operator|=
name|root
operator|->
name|ascender
operator|-
name|root
operator|->
name|descender
expr_stmt|;
block|}
block|}
block|}
name|root
operator|->
name|max_advance_width
operator|=
operator|(
name|FT_Short
operator|)
name|face
operator|->
name|horizontal
operator|.
name|advance_Width_Max
expr_stmt|;
name|root
operator|->
name|max_advance_height
operator|=
call|(
name|FT_Short
call|)
argument_list|(
name|face
operator|->
name|vertical_info
condition|?
name|face
operator|->
name|vertical
operator|.
name|advance_Height_Max
else|:
name|root
operator|->
name|height
argument_list|)
expr_stmt|;
comment|/* See http://www.microsoft.com/OpenType/OTSpec/post.htm -- */
comment|/* Adjust underline position from top edge to centre of     */
comment|/* stroke to convert TrueType meaning to FreeType meaning.  */
name|root
operator|->
name|underline_position
operator|=
name|face
operator|->
name|postscript
operator|.
name|underlinePosition
operator|-
name|face
operator|->
name|postscript
operator|.
name|underlineThickness
operator|/
literal|2
expr_stmt|;
name|root
operator|->
name|underline_thickness
operator|=
name|face
operator|->
name|postscript
operator|.
name|underlineThickness
expr_stmt|;
block|}
block|}
name|Exit
label|:
name|FT_TRACE2
argument_list|(
operator|(
literal|"sfnt_load_face: done\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_block
begin_undef
DECL|macro|LOAD_
undef|#
directive|undef
name|LOAD_
end_undef
begin_undef
DECL|macro|LOADM_
undef|#
directive|undef
name|LOADM_
end_undef
begin_undef
DECL|macro|GET_NAME
undef|#
directive|undef
name|GET_NAME
end_undef
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|sfnt_done_face
name|sfnt_done_face
argument_list|(
argument|TT_Face  face
argument_list|)
end_macro
begin_block
block|{
name|FT_Memory
name|memory
decl_stmt|;
name|SFNT_Service
name|sfnt
decl_stmt|;
if|if
condition|(
operator|!
name|face
condition|)
return|return;
name|memory
operator|=
name|face
operator|->
name|root
operator|.
name|memory
expr_stmt|;
name|sfnt
operator|=
operator|(
name|SFNT_Service
operator|)
name|face
operator|->
name|sfnt
expr_stmt|;
if|if
condition|(
name|sfnt
condition|)
block|{
comment|/* destroy the postscript names table if it is loaded */
if|if
condition|(
name|sfnt
operator|->
name|free_psnames
condition|)
name|sfnt
operator|->
name|free_psnames
argument_list|(
name|face
argument_list|)
expr_stmt|;
comment|/* destroy the embedded bitmaps table if it is loaded */
if|if
condition|(
name|sfnt
operator|->
name|free_eblc
condition|)
name|sfnt
operator|->
name|free_eblc
argument_list|(
name|face
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_BDF
comment|/* freeing the embedded BDF properties */
name|tt_face_free_bdf_props
argument_list|(
name|face
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* freeing the kerning table */
name|tt_face_done_kern
argument_list|(
name|face
argument_list|)
expr_stmt|;
comment|/* freeing the collection table */
name|FT_FREE
argument_list|(
name|face
operator|->
name|ttc_header
operator|.
name|offsets
argument_list|)
expr_stmt|;
name|face
operator|->
name|ttc_header
operator|.
name|count
operator|=
literal|0
expr_stmt|;
comment|/* freeing table directory */
name|FT_FREE
argument_list|(
name|face
operator|->
name|dir_tables
argument_list|)
expr_stmt|;
name|face
operator|->
name|num_tables
operator|=
literal|0
expr_stmt|;
block|{
name|FT_Stream
name|stream
init|=
name|FT_FACE_STREAM
argument_list|(
name|face
argument_list|)
decl_stmt|;
comment|/* simply release the 'cmap' table frame */
name|FT_FRAME_RELEASE
argument_list|(
name|face
operator|->
name|cmap_table
argument_list|)
expr_stmt|;
name|face
operator|->
name|cmap_size
operator|=
literal|0
expr_stmt|;
block|}
comment|/* freeing the horizontal metrics */
block|{
name|FT_Stream
name|stream
init|=
name|FT_FACE_STREAM
argument_list|(
name|face
argument_list|)
decl_stmt|;
name|FT_FRAME_RELEASE
argument_list|(
name|face
operator|->
name|horz_metrics
argument_list|)
expr_stmt|;
name|FT_FRAME_RELEASE
argument_list|(
name|face
operator|->
name|vert_metrics
argument_list|)
expr_stmt|;
name|face
operator|->
name|horz_metrics_size
operator|=
literal|0
expr_stmt|;
name|face
operator|->
name|vert_metrics_size
operator|=
literal|0
expr_stmt|;
block|}
comment|/* freeing the vertical ones, if any */
if|if
condition|(
name|face
operator|->
name|vertical_info
condition|)
block|{
name|FT_FREE
argument_list|(
name|face
operator|->
name|vertical
operator|.
name|long_metrics
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|face
operator|->
name|vertical
operator|.
name|short_metrics
argument_list|)
expr_stmt|;
name|face
operator|->
name|vertical_info
operator|=
literal|0
expr_stmt|;
block|}
comment|/* freeing the gasp table */
name|FT_FREE
argument_list|(
name|face
operator|->
name|gasp
operator|.
name|gaspRanges
argument_list|)
expr_stmt|;
name|face
operator|->
name|gasp
operator|.
name|numRanges
operator|=
literal|0
expr_stmt|;
comment|/* freeing the name table */
if|if
condition|(
name|sfnt
condition|)
name|sfnt
operator|->
name|free_name
argument_list|(
name|face
argument_list|)
expr_stmt|;
comment|/* freeing family and style name */
name|FT_FREE
argument_list|(
name|face
operator|->
name|root
operator|.
name|family_name
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|face
operator|->
name|root
operator|.
name|style_name
argument_list|)
expr_stmt|;
comment|/* freeing sbit size table */
name|FT_FREE
argument_list|(
name|face
operator|->
name|root
operator|.
name|available_sizes
argument_list|)
expr_stmt|;
name|face
operator|->
name|root
operator|.
name|num_fixed_sizes
operator|=
literal|0
expr_stmt|;
name|FT_FREE
argument_list|(
name|face
operator|->
name|postscript_name
argument_list|)
expr_stmt|;
name|face
operator|->
name|sfnt
operator|=
name|NULL
expr_stmt|;
block|}
end_block
begin_comment
comment|/* END */
end_comment
end_unit
