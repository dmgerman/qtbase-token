begin_unit
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  pngshim.c                                                              */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*    PNG Bitmap glyph support.                                            */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  Copyright 2013-2015 by                                                 */
end_comment
begin_comment
comment|/*  Google, Inc.                                                           */
end_comment
begin_comment
comment|/*  Written by Stuart Gill and Behdad Esfahbod.                            */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  This file is part of the FreeType project, and may only be used,       */
end_comment
begin_comment
comment|/*  modified, and distributed under the terms of the FreeType project      */
end_comment
begin_comment
comment|/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
end_comment
begin_comment
comment|/*  this file you indicate that you have read the license and              */
end_comment
begin_comment
comment|/*  understand and accept it fully.                                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<ft2build.h>
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_DEBUG_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_STREAM_H
end_include
begin_include
include|#
directive|include
include|FT_TRUETYPE_TAGS_H
end_include
begin_include
include|#
directive|include
include|FT_CONFIG_STANDARD_LIBRARY_H
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|FT_CONFIG_OPTION_USE_PNG
end_ifdef
begin_comment
comment|/* We always include<stjmp.h>, so make libpng shut up! */
end_comment
begin_define
DECL|macro|PNG_SKIP_SETJMP_CHECK
define|#
directive|define
name|PNG_SKIP_SETJMP_CHECK
value|1
end_define
begin_include
include|#
directive|include
file|<png.h>
end_include
begin_include
include|#
directive|include
file|"pngshim.h"
end_include
begin_include
include|#
directive|include
file|"sferrors.h"
end_include
begin_comment
comment|/* This code is freely based on cairo-png.c.  There's so many ways */
end_comment
begin_comment
comment|/* to call libpng, and the way cairo does it is defacto standard.  */
end_comment
begin_function
specifier|static
name|unsigned
name|int
DECL|function|multiply_alpha
name|multiply_alpha
parameter_list|(
name|unsigned
name|int
name|alpha
parameter_list|,
name|unsigned
name|int
name|color
parameter_list|)
block|{
name|unsigned
name|int
name|temp
init|=
name|alpha
operator|*
name|color
operator|+
literal|0x80
decl_stmt|;
return|return
operator|(
name|temp
operator|+
operator|(
name|temp
operator|>>
literal|8
operator|)
operator|)
operator|>>
literal|8
return|;
block|}
end_function
begin_comment
comment|/* Premultiplies data and converts RGBA bytes => native endian. */
end_comment
begin_function
specifier|static
name|void
DECL|function|premultiply_data
name|premultiply_data
parameter_list|(
name|png_structp
name|png
parameter_list|,
name|png_row_infop
name|row_info
parameter_list|,
name|png_bytep
name|data
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|FT_UNUSED
argument_list|(
name|png
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|row_info
operator|->
name|rowbytes
condition|;
name|i
operator|+=
literal|4
control|)
block|{
name|unsigned
name|char
modifier|*
name|base
init|=
operator|&
name|data
index|[
name|i
index|]
decl_stmt|;
name|unsigned
name|int
name|alpha
init|=
name|base
index|[
literal|3
index|]
decl_stmt|;
if|if
condition|(
name|alpha
operator|==
literal|0
condition|)
name|base
index|[
literal|0
index|]
operator|=
name|base
index|[
literal|1
index|]
operator|=
name|base
index|[
literal|2
index|]
operator|=
name|base
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|unsigned
name|int
name|red
init|=
name|base
index|[
literal|0
index|]
decl_stmt|;
name|unsigned
name|int
name|green
init|=
name|base
index|[
literal|1
index|]
decl_stmt|;
name|unsigned
name|int
name|blue
init|=
name|base
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|alpha
operator|!=
literal|0xFF
condition|)
block|{
name|red
operator|=
name|multiply_alpha
argument_list|(
name|alpha
argument_list|,
name|red
argument_list|)
expr_stmt|;
name|green
operator|=
name|multiply_alpha
argument_list|(
name|alpha
argument_list|,
name|green
argument_list|)
expr_stmt|;
name|blue
operator|=
name|multiply_alpha
argument_list|(
name|alpha
argument_list|,
name|blue
argument_list|)
expr_stmt|;
block|}
name|base
index|[
literal|0
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|blue
expr_stmt|;
name|base
index|[
literal|1
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|green
expr_stmt|;
name|base
index|[
literal|2
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|red
expr_stmt|;
name|base
index|[
literal|3
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|alpha
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/* Converts RGBx bytes to BGRA. */
end_comment
begin_function
specifier|static
name|void
DECL|function|convert_bytes_to_data
name|convert_bytes_to_data
parameter_list|(
name|png_structp
name|png
parameter_list|,
name|png_row_infop
name|row_info
parameter_list|,
name|png_bytep
name|data
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|FT_UNUSED
argument_list|(
name|png
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|row_info
operator|->
name|rowbytes
condition|;
name|i
operator|+=
literal|4
control|)
block|{
name|unsigned
name|char
modifier|*
name|base
init|=
operator|&
name|data
index|[
name|i
index|]
decl_stmt|;
name|unsigned
name|int
name|red
init|=
name|base
index|[
literal|0
index|]
decl_stmt|;
name|unsigned
name|int
name|green
init|=
name|base
index|[
literal|1
index|]
decl_stmt|;
name|unsigned
name|int
name|blue
init|=
name|base
index|[
literal|2
index|]
decl_stmt|;
name|base
index|[
literal|0
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|blue
expr_stmt|;
name|base
index|[
literal|1
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|green
expr_stmt|;
name|base
index|[
literal|2
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|red
expr_stmt|;
name|base
index|[
literal|3
index|]
operator|=
literal|0xFF
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/* Use error callback to avoid png writing to stderr. */
end_comment
begin_function
specifier|static
name|void
DECL|function|error_callback
name|error_callback
parameter_list|(
name|png_structp
name|png
parameter_list|,
name|png_const_charp
name|error_msg
parameter_list|)
block|{
name|FT_Error
modifier|*
name|error
init|=
operator|(
name|FT_Error
operator|*
operator|)
name|png_get_error_ptr
argument_list|(
name|png
argument_list|)
decl_stmt|;
name|FT_UNUSED
argument_list|(
name|error_msg
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|FT_THROW
argument_list|(
name|Out_Of_Memory
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PNG_SETJMP_SUPPORTED
name|ft_longjmp
argument_list|(
name|png_jmpbuf
argument_list|(
name|png
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* if we get here, then we have no choice but to abort ... */
block|}
end_function
begin_comment
comment|/* Use warning callback to avoid png writing to stderr. */
end_comment
begin_function
specifier|static
name|void
DECL|function|warning_callback
name|warning_callback
parameter_list|(
name|png_structp
name|png
parameter_list|,
name|png_const_charp
name|error_msg
parameter_list|)
block|{
name|FT_UNUSED
argument_list|(
name|png
argument_list|)
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|error_msg
argument_list|)
expr_stmt|;
comment|/* Just ignore warnings. */
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|read_data_from_FT_Stream
name|read_data_from_FT_Stream
parameter_list|(
name|png_structp
name|png
parameter_list|,
name|png_bytep
name|data
parameter_list|,
name|png_size_t
name|length
parameter_list|)
block|{
name|FT_Error
name|error
decl_stmt|;
name|png_voidp
name|p
init|=
name|png_get_io_ptr
argument_list|(
name|png
argument_list|)
decl_stmt|;
name|FT_Stream
name|stream
init|=
operator|(
name|FT_Stream
operator|)
name|p
decl_stmt|;
if|if
condition|(
name|FT_FRAME_ENTER
argument_list|(
name|length
argument_list|)
condition|)
block|{
name|FT_Error
modifier|*
name|e
init|=
operator|(
name|FT_Error
operator|*
operator|)
name|png_get_error_ptr
argument_list|(
name|png
argument_list|)
decl_stmt|;
operator|*
name|e
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Stream_Read
argument_list|)
expr_stmt|;
name|png_error
argument_list|(
name|png
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
name|memcpy
argument_list|(
name|data
argument_list|,
name|stream
operator|->
name|cursor
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|FT_FRAME_EXIT
argument_list|()
expr_stmt|;
block|}
end_function
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|Load_SBit_Png
argument_list|(
argument|FT_GlyphSlot     slot
argument_list|,
argument|FT_Int           x_offset
argument_list|,
argument|FT_Int           y_offset
argument_list|,
argument|FT_Int           pix_bits
argument_list|,
argument|TT_SBit_Metrics  metrics
argument_list|,
argument|FT_Memory        memory
argument_list|,
argument|FT_Byte*         data
argument_list|,
argument|FT_UInt          png_len
argument_list|,
argument|FT_Bool          populate_map_and_metrics
argument_list|)
end_macro
begin_block
block|{
name|FT_Bitmap
modifier|*
name|map
init|=
operator|&
name|slot
operator|->
name|bitmap
decl_stmt|;
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
name|FT_StreamRec
name|stream
decl_stmt|;
name|png_structp
name|png
decl_stmt|;
name|png_infop
name|info
decl_stmt|;
name|png_uint_32
name|imgWidth
decl_stmt|,
name|imgHeight
decl_stmt|;
name|int
name|bitdepth
decl_stmt|,
name|color_type
decl_stmt|,
name|interlace
decl_stmt|;
name|FT_Int
name|i
decl_stmt|;
name|png_byte
modifier|*
modifier|*
name|rows
init|=
name|NULL
decl_stmt|;
comment|/* pacify compiler */
if|if
condition|(
name|x_offset
operator|<
literal|0
operator|||
name|y_offset
operator|<
literal|0
condition|)
block|{
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Argument
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
operator|!
name|populate_map_and_metrics
operator|&&
operator|(
operator|(
name|FT_UInt
operator|)
name|x_offset
operator|+
name|metrics
operator|->
name|width
operator|>
name|map
operator|->
name|width
operator|||
operator|(
name|FT_UInt
operator|)
name|y_offset
operator|+
name|metrics
operator|->
name|height
operator|>
name|map
operator|->
name|rows
operator|||
name|pix_bits
operator|!=
literal|32
operator|||
name|map
operator|->
name|pixel_mode
operator|!=
name|FT_PIXEL_MODE_BGRA
operator|)
condition|)
block|{
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Argument
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|FT_Stream_OpenMemory
argument_list|(
operator|&
name|stream
argument_list|,
name|data
argument_list|,
name|png_len
argument_list|)
expr_stmt|;
name|png
operator|=
name|png_create_read_struct
argument_list|(
name|PNG_LIBPNG_VER_STRING
argument_list|,
operator|&
name|error
argument_list|,
name|error_callback
argument_list|,
name|warning_callback
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|png
condition|)
block|{
name|error
operator|=
name|FT_THROW
argument_list|(
name|Out_Of_Memory
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|info
operator|=
name|png_create_info_struct
argument_list|(
name|png
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|info
condition|)
block|{
name|error
operator|=
name|FT_THROW
argument_list|(
name|Out_Of_Memory
argument_list|)
expr_stmt|;
name|png_destroy_read_struct
argument_list|(
operator|&
name|png
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|ft_setjmp
argument_list|(
name|png_jmpbuf
argument_list|(
name|png
argument_list|)
argument_list|)
condition|)
block|{
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_File_Format
argument_list|)
expr_stmt|;
goto|goto
name|DestroyExit
goto|;
block|}
name|png_set_read_fn
argument_list|(
name|png
argument_list|,
operator|&
name|stream
argument_list|,
name|read_data_from_FT_Stream
argument_list|)
expr_stmt|;
name|png_read_info
argument_list|(
name|png
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|png_get_IHDR
argument_list|(
name|png
argument_list|,
name|info
argument_list|,
operator|&
name|imgWidth
argument_list|,
operator|&
name|imgHeight
argument_list|,
operator|&
name|bitdepth
argument_list|,
operator|&
name|color_type
argument_list|,
operator|&
name|interlace
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|(
operator|!
name|populate_map_and_metrics
operator|&&
operator|(
operator|(
name|FT_Int
operator|)
name|imgWidth
operator|!=
name|metrics
operator|->
name|width
operator|||
operator|(
name|FT_Int
operator|)
name|imgHeight
operator|!=
name|metrics
operator|->
name|height
operator|)
operator|)
condition|)
goto|goto
name|DestroyExit
goto|;
if|if
condition|(
name|populate_map_and_metrics
condition|)
block|{
name|FT_ULong
name|size
decl_stmt|;
name|metrics
operator|->
name|width
operator|=
operator|(
name|FT_UShort
operator|)
name|imgWidth
expr_stmt|;
name|metrics
operator|->
name|height
operator|=
operator|(
name|FT_UShort
operator|)
name|imgHeight
expr_stmt|;
name|map
operator|->
name|width
operator|=
name|metrics
operator|->
name|width
expr_stmt|;
name|map
operator|->
name|rows
operator|=
name|metrics
operator|->
name|height
expr_stmt|;
name|map
operator|->
name|pixel_mode
operator|=
name|FT_PIXEL_MODE_BGRA
expr_stmt|;
name|map
operator|->
name|pitch
operator|=
call|(
name|int
call|)
argument_list|(
name|map
operator|->
name|width
operator|*
literal|4
argument_list|)
expr_stmt|;
name|map
operator|->
name|num_grays
operator|=
literal|256
expr_stmt|;
comment|/* reject too large bitmaps similarly to the rasterizer */
if|if
condition|(
name|map
operator|->
name|rows
operator|>
literal|0x7FFF
operator|||
name|map
operator|->
name|width
operator|>
literal|0x7FFF
condition|)
block|{
name|error
operator|=
name|FT_THROW
argument_list|(
name|Array_Too_Large
argument_list|)
expr_stmt|;
goto|goto
name|DestroyExit
goto|;
block|}
comment|/* this doesn't overflow: 0x7FFF * 0x7FFF * 4< 2^32 */
name|size
operator|=
name|map
operator|->
name|rows
operator|*
operator|(
name|FT_ULong
operator|)
name|map
operator|->
name|pitch
expr_stmt|;
name|error
operator|=
name|ft_glyphslot_alloc_bitmap
argument_list|(
name|slot
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|DestroyExit
goto|;
block|}
comment|/* convert palette/gray image to rgb */
if|if
condition|(
name|color_type
operator|==
name|PNG_COLOR_TYPE_PALETTE
condition|)
name|png_set_palette_to_rgb
argument_list|(
name|png
argument_list|)
expr_stmt|;
comment|/* expand gray bit depth if needed */
if|if
condition|(
name|color_type
operator|==
name|PNG_COLOR_TYPE_GRAY
condition|)
block|{
if|#
directive|if
name|PNG_LIBPNG_VER
operator|>=
literal|10209
name|png_set_expand_gray_1_2_4_to_8
argument_list|(
name|png
argument_list|)
expr_stmt|;
else|#
directive|else
name|png_set_gray_1_2_4_to_8
argument_list|(
name|png
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* transform transparency to alpha */
if|if
condition|(
name|png_get_valid
argument_list|(
name|png
argument_list|,
name|info
argument_list|,
name|PNG_INFO_tRNS
argument_list|)
condition|)
name|png_set_tRNS_to_alpha
argument_list|(
name|png
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitdepth
operator|==
literal|16
condition|)
name|png_set_strip_16
argument_list|(
name|png
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitdepth
operator|<
literal|8
condition|)
name|png_set_packing
argument_list|(
name|png
argument_list|)
expr_stmt|;
comment|/* convert grayscale to RGB */
if|if
condition|(
name|color_type
operator|==
name|PNG_COLOR_TYPE_GRAY
operator|||
name|color_type
operator|==
name|PNG_COLOR_TYPE_GRAY_ALPHA
condition|)
name|png_set_gray_to_rgb
argument_list|(
name|png
argument_list|)
expr_stmt|;
if|if
condition|(
name|interlace
operator|!=
name|PNG_INTERLACE_NONE
condition|)
name|png_set_interlace_handling
argument_list|(
name|png
argument_list|)
expr_stmt|;
name|png_set_filler
argument_list|(
name|png
argument_list|,
literal|0xFF
argument_list|,
name|PNG_FILLER_AFTER
argument_list|)
expr_stmt|;
comment|/* recheck header after setting EXPAND options */
name|png_read_update_info
argument_list|(
name|png
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|png_get_IHDR
argument_list|(
name|png
argument_list|,
name|info
argument_list|,
operator|&
name|imgWidth
argument_list|,
operator|&
name|imgHeight
argument_list|,
operator|&
name|bitdepth
argument_list|,
operator|&
name|color_type
argument_list|,
operator|&
name|interlace
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitdepth
operator|!=
literal|8
operator|||
operator|!
operator|(
name|color_type
operator|==
name|PNG_COLOR_TYPE_RGB
operator|||
name|color_type
operator|==
name|PNG_COLOR_TYPE_RGB_ALPHA
operator|)
condition|)
block|{
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_File_Format
argument_list|)
expr_stmt|;
goto|goto
name|DestroyExit
goto|;
block|}
switch|switch
condition|(
name|color_type
condition|)
block|{
default|default:
comment|/* Shouldn't happen, but fall through. */
case|case
name|PNG_COLOR_TYPE_RGB_ALPHA
case|:
name|png_set_read_user_transform_fn
argument_list|(
name|png
argument_list|,
name|premultiply_data
argument_list|)
expr_stmt|;
break|break;
case|case
name|PNG_COLOR_TYPE_RGB
case|:
comment|/* Humm, this smells.  Carry on though. */
name|png_set_read_user_transform_fn
argument_list|(
name|png
argument_list|,
name|convert_bytes_to_data
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|rows
argument_list|,
name|imgHeight
argument_list|)
condition|)
block|{
name|error
operator|=
name|FT_THROW
argument_list|(
name|Out_Of_Memory
argument_list|)
expr_stmt|;
goto|goto
name|DestroyExit
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|FT_Int
operator|)
name|imgHeight
condition|;
name|i
operator|++
control|)
name|rows
index|[
name|i
index|]
operator|=
name|map
operator|->
name|buffer
operator|+
operator|(
name|y_offset
operator|+
name|i
operator|)
operator|*
name|map
operator|->
name|pitch
operator|+
name|x_offset
operator|*
literal|4
expr_stmt|;
name|png_read_image
argument_list|(
name|png
argument_list|,
name|rows
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|rows
argument_list|)
expr_stmt|;
name|png_read_end
argument_list|(
name|png
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|DestroyExit
label|:
name|png_destroy_read_struct
argument_list|(
operator|&
name|png
argument_list|,
operator|&
name|info
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|FT_Stream_Close
argument_list|(
operator|&
name|stream
argument_list|)
expr_stmt|;
name|Exit
label|:
return|return
name|error
return|;
block|}
end_block
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* FT_CONFIG_OPTION_USE_PNG */
end_comment
begin_comment
comment|/* END */
end_comment
end_unit
