begin_unit
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  ttsbit0.c                                                              */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*    TrueType and OpenType embedded bitmap support (body).                */
end_comment
begin_comment
comment|/*    This is a heap-optimized version.                                    */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  Copyright 2005, 2006, 2007, 2008, 2009 by                              */
end_comment
begin_comment
comment|/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  This file is part of the FreeType project, and may only be used,       */
end_comment
begin_comment
comment|/*  modified, and distributed under the terms of the FreeType project      */
end_comment
begin_comment
comment|/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
end_comment
begin_comment
comment|/*  this file you indicate that you have read the license and              */
end_comment
begin_comment
comment|/*  understand and accept it fully.                                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/* This file is included by ttsbit.c */
end_comment
begin_include
include|#
directive|include
file|<ft2build.h>
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_DEBUG_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_STREAM_H
end_include
begin_include
include|#
directive|include
include|FT_TRUETYPE_TAGS_H
end_include
begin_include
include|#
directive|include
file|"ttsbit.h"
end_include
begin_include
include|#
directive|include
file|"sferrors.h"
end_include
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
end_comment
begin_comment
comment|/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
end_comment
begin_comment
comment|/* messages during execution.                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_undef
DECL|macro|FT_COMPONENT
undef|#
directive|undef
name|FT_COMPONENT
end_undef
begin_define
DECL|macro|FT_COMPONENT
define|#
directive|define
name|FT_COMPONENT
value|trace_ttsbit
end_define
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|tt_face_load_eblc
argument_list|(
argument|TT_Face    face
argument_list|,
argument|FT_Stream  stream
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
init|=
name|SFNT_Err_Ok
decl_stmt|;
name|FT_Fixed
name|version
decl_stmt|;
name|FT_ULong
name|num_strikes
decl_stmt|,
name|table_size
decl_stmt|;
name|FT_Byte
modifier|*
name|p
decl_stmt|;
name|FT_Byte
modifier|*
name|p_limit
decl_stmt|;
name|FT_UInt
name|count
decl_stmt|;
name|face
operator|->
name|sbit_num_strikes
operator|=
literal|0
expr_stmt|;
comment|/* this table is optional */
name|error
operator|=
name|face
operator|->
name|goto_table
argument_list|(
name|face
argument_list|,
name|TTAG_EBLC
argument_list|,
name|stream
argument_list|,
operator|&
name|table_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|error
operator|=
name|face
operator|->
name|goto_table
argument_list|(
name|face
argument_list|,
name|TTAG_bloc
argument_list|,
name|stream
argument_list|,
operator|&
name|table_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
if|if
condition|(
name|table_size
operator|<
literal|8
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"tt_face_load_sbit_strikes: table too short\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|SFNT_Err_Invalid_File_Format
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|FT_FRAME_EXTRACT
argument_list|(
name|table_size
argument_list|,
name|face
operator|->
name|sbit_table
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|face
operator|->
name|sbit_table_size
operator|=
name|table_size
expr_stmt|;
name|p
operator|=
name|face
operator|->
name|sbit_table
expr_stmt|;
name|p_limit
operator|=
name|p
operator|+
name|table_size
expr_stmt|;
name|version
operator|=
name|FT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|num_strikes
operator|=
name|FT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|!=
literal|0x00020000UL
operator|||
name|num_strikes
operator|>=
literal|0x10000UL
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"tt_face_load_sbit_strikes: invalid table version\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|SFNT_Err_Invalid_File_Format
expr_stmt|;
goto|goto
name|Fail
goto|;
block|}
comment|/*      *  Count the number of strikes available in the table.  We are a bit      *  paranoid there and don't trust the data.      */
name|count
operator|=
operator|(
name|FT_UInt
operator|)
name|num_strikes
expr_stmt|;
if|if
condition|(
literal|8
operator|+
literal|48UL
operator|*
name|count
operator|>
name|table_size
condition|)
name|count
operator|=
call|(
name|FT_UInt
call|)
argument_list|(
operator|(
name|p_limit
operator|-
name|p
operator|)
operator|/
literal|48
argument_list|)
expr_stmt|;
name|face
operator|->
name|sbit_num_strikes
operator|=
name|count
expr_stmt|;
name|FT_TRACE3
argument_list|(
operator|(
literal|"sbit_num_strikes: %u\n"
operator|,
name|count
operator|)
argument_list|)
expr_stmt|;
name|Exit
label|:
return|return
name|error
return|;
name|Fail
label|:
name|FT_FRAME_RELEASE
argument_list|(
name|face
operator|->
name|sbit_table
argument_list|)
expr_stmt|;
name|face
operator|->
name|sbit_table_size
operator|=
literal|0
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
end_block
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|tt_face_free_eblc
name|tt_face_free_eblc
argument_list|(
argument|TT_Face  face
argument_list|)
end_macro
begin_block
block|{
name|FT_Stream
name|stream
init|=
name|face
operator|->
name|root
operator|.
name|stream
decl_stmt|;
name|FT_FRAME_RELEASE
argument_list|(
name|face
operator|->
name|sbit_table
argument_list|)
expr_stmt|;
name|face
operator|->
name|sbit_table_size
operator|=
literal|0
expr_stmt|;
name|face
operator|->
name|sbit_num_strikes
operator|=
literal|0
expr_stmt|;
block|}
end_block
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|tt_face_set_sbit_strike
argument_list|(
argument|TT_Face          face
argument_list|,
argument|FT_Size_Request  req
argument_list|,
argument|FT_ULong*        astrike_index
argument_list|)
end_macro
begin_block
block|{
return|return
name|FT_Match_Size
argument_list|(
operator|(
name|FT_Face
operator|)
name|face
argument_list|,
name|req
argument_list|,
literal|0
argument_list|,
name|astrike_index
argument_list|)
return|;
block|}
end_block
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|tt_face_load_strike_metrics
argument_list|(
argument|TT_Face           face
argument_list|,
argument|FT_ULong          strike_index
argument_list|,
argument|FT_Size_Metrics*  metrics
argument_list|)
end_macro
begin_block
block|{
name|FT_Byte
modifier|*
name|strike
decl_stmt|;
if|if
condition|(
name|strike_index
operator|>=
operator|(
name|FT_ULong
operator|)
name|face
operator|->
name|sbit_num_strikes
condition|)
return|return
name|SFNT_Err_Invalid_Argument
return|;
name|strike
operator|=
name|face
operator|->
name|sbit_table
operator|+
literal|8
operator|+
name|strike_index
operator|*
literal|48
expr_stmt|;
name|metrics
operator|->
name|x_ppem
operator|=
operator|(
name|FT_UShort
operator|)
name|strike
index|[
literal|44
index|]
expr_stmt|;
name|metrics
operator|->
name|y_ppem
operator|=
operator|(
name|FT_UShort
operator|)
name|strike
index|[
literal|45
index|]
expr_stmt|;
name|metrics
operator|->
name|ascender
operator|=
operator|(
name|FT_Char
operator|)
name|strike
index|[
literal|16
index|]
operator|<<
literal|6
expr_stmt|;
comment|/* hori.ascender  */
name|metrics
operator|->
name|descender
operator|=
operator|(
name|FT_Char
operator|)
name|strike
index|[
literal|17
index|]
operator|<<
literal|6
expr_stmt|;
comment|/* hori.descender */
name|metrics
operator|->
name|height
operator|=
name|metrics
operator|->
name|ascender
operator|-
name|metrics
operator|->
name|descender
expr_stmt|;
comment|/* XXX: Is this correct? */
name|metrics
operator|->
name|max_advance
operator|=
operator|(
operator|(
name|FT_Char
operator|)
name|strike
index|[
literal|22
index|]
operator|+
comment|/* min_origin_SB  */
name|strike
index|[
literal|18
index|]
operator|+
comment|/* max_width      */
operator|(
name|FT_Char
operator|)
name|strike
index|[
literal|23
index|]
comment|/* min_advance_SB */
operator|)
operator|<<
literal|6
expr_stmt|;
return|return
name|SFNT_Err_Ok
return|;
block|}
end_block
begin_typedef
DECL|struct|TT_SBitDecoderRec_
typedef|typedef
struct|struct
name|TT_SBitDecoderRec_
block|{
DECL|member|face
name|TT_Face
name|face
decl_stmt|;
DECL|member|stream
name|FT_Stream
name|stream
decl_stmt|;
DECL|member|bitmap
name|FT_Bitmap
modifier|*
name|bitmap
decl_stmt|;
DECL|member|metrics
name|TT_SBit_Metrics
name|metrics
decl_stmt|;
DECL|member|metrics_loaded
name|FT_Bool
name|metrics_loaded
decl_stmt|;
DECL|member|bitmap_allocated
name|FT_Bool
name|bitmap_allocated
decl_stmt|;
DECL|member|bit_depth
name|FT_Byte
name|bit_depth
decl_stmt|;
DECL|member|ebdt_start
name|FT_ULong
name|ebdt_start
decl_stmt|;
DECL|member|ebdt_size
name|FT_ULong
name|ebdt_size
decl_stmt|;
DECL|member|strike_index_array
name|FT_ULong
name|strike_index_array
decl_stmt|;
DECL|member|strike_index_count
name|FT_ULong
name|strike_index_count
decl_stmt|;
DECL|member|eblc_base
name|FT_Byte
modifier|*
name|eblc_base
decl_stmt|;
DECL|member|eblc_limit
name|FT_Byte
modifier|*
name|eblc_limit
decl_stmt|;
block|}
DECL|typedef|TT_SBitDecoderRec
DECL|typedef|TT_SBitDecoder
name|TT_SBitDecoderRec
operator|,
typedef|*
name|TT_SBitDecoder
typedef|;
end_typedef
begin_function
specifier|static
name|FT_Error
DECL|function|tt_sbit_decoder_init
name|tt_sbit_decoder_init
parameter_list|(
name|TT_SBitDecoder
name|decoder
parameter_list|,
name|TT_Face
name|face
parameter_list|,
name|FT_ULong
name|strike_index
parameter_list|,
name|TT_SBit_MetricsRec
modifier|*
name|metrics
parameter_list|)
block|{
name|FT_Error
name|error
decl_stmt|;
name|FT_Stream
name|stream
init|=
name|face
operator|->
name|root
operator|.
name|stream
decl_stmt|;
name|FT_ULong
name|ebdt_size
decl_stmt|;
name|error
operator|=
name|face
operator|->
name|goto_table
argument_list|(
name|face
argument_list|,
name|TTAG_EBDT
argument_list|,
name|stream
argument_list|,
operator|&
name|ebdt_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|error
operator|=
name|face
operator|->
name|goto_table
argument_list|(
name|face
argument_list|,
name|TTAG_bdat
argument_list|,
name|stream
argument_list|,
operator|&
name|ebdt_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|decoder
operator|->
name|face
operator|=
name|face
expr_stmt|;
name|decoder
operator|->
name|stream
operator|=
name|stream
expr_stmt|;
name|decoder
operator|->
name|bitmap
operator|=
operator|&
name|face
operator|->
name|root
operator|.
name|glyph
operator|->
name|bitmap
expr_stmt|;
name|decoder
operator|->
name|metrics
operator|=
name|metrics
expr_stmt|;
name|decoder
operator|->
name|metrics_loaded
operator|=
literal|0
expr_stmt|;
name|decoder
operator|->
name|bitmap_allocated
operator|=
literal|0
expr_stmt|;
name|decoder
operator|->
name|ebdt_start
operator|=
name|FT_STREAM_POS
argument_list|()
expr_stmt|;
name|decoder
operator|->
name|ebdt_size
operator|=
name|ebdt_size
expr_stmt|;
name|decoder
operator|->
name|eblc_base
operator|=
name|face
operator|->
name|sbit_table
expr_stmt|;
name|decoder
operator|->
name|eblc_limit
operator|=
name|face
operator|->
name|sbit_table
operator|+
name|face
operator|->
name|sbit_table_size
expr_stmt|;
comment|/* now find the strike corresponding to the index */
block|{
name|FT_Byte
modifier|*
name|p
decl_stmt|;
if|if
condition|(
literal|8
operator|+
literal|48
operator|*
name|strike_index
operator|+
literal|3
operator|*
literal|4
operator|+
literal|34
operator|+
literal|1
operator|>
name|face
operator|->
name|sbit_table_size
condition|)
block|{
name|error
operator|=
name|SFNT_Err_Invalid_File_Format
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|p
operator|=
name|decoder
operator|->
name|eblc_base
operator|+
literal|8
operator|+
literal|48
operator|*
name|strike_index
expr_stmt|;
name|decoder
operator|->
name|strike_index_array
operator|=
name|FT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|decoder
operator|->
name|strike_index_count
operator|=
name|FT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|34
expr_stmt|;
name|decoder
operator|->
name|bit_depth
operator|=
operator|*
name|p
expr_stmt|;
if|if
condition|(
name|decoder
operator|->
name|strike_index_array
operator|>
name|face
operator|->
name|sbit_table_size
operator|||
name|decoder
operator|->
name|strike_index_array
operator|+
literal|8
operator|*
name|decoder
operator|->
name|strike_index_count
operator|>
name|face
operator|->
name|sbit_table_size
condition|)
name|error
operator|=
name|SFNT_Err_Invalid_File_Format
expr_stmt|;
block|}
name|Exit
label|:
return|return
name|error
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|tt_sbit_decoder_done
name|tt_sbit_decoder_done
parameter_list|(
name|TT_SBitDecoder
name|decoder
parameter_list|)
block|{
name|FT_UNUSED
argument_list|(
name|decoder
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|tt_sbit_decoder_alloc_bitmap
name|tt_sbit_decoder_alloc_bitmap
parameter_list|(
name|TT_SBitDecoder
name|decoder
parameter_list|)
block|{
name|FT_Error
name|error
init|=
name|SFNT_Err_Ok
decl_stmt|;
name|FT_UInt
name|width
decl_stmt|,
name|height
decl_stmt|;
name|FT_Bitmap
modifier|*
name|map
init|=
name|decoder
operator|->
name|bitmap
decl_stmt|;
name|FT_Long
name|size
decl_stmt|;
if|if
condition|(
operator|!
name|decoder
operator|->
name|metrics_loaded
condition|)
block|{
name|error
operator|=
name|SFNT_Err_Invalid_Argument
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|width
operator|=
name|decoder
operator|->
name|metrics
operator|->
name|width
expr_stmt|;
name|height
operator|=
name|decoder
operator|->
name|metrics
operator|->
name|height
expr_stmt|;
name|map
operator|->
name|width
operator|=
operator|(
name|int
operator|)
name|width
expr_stmt|;
name|map
operator|->
name|rows
operator|=
operator|(
name|int
operator|)
name|height
expr_stmt|;
switch|switch
condition|(
name|decoder
operator|->
name|bit_depth
condition|)
block|{
case|case
literal|1
case|:
name|map
operator|->
name|pixel_mode
operator|=
name|FT_PIXEL_MODE_MONO
expr_stmt|;
name|map
operator|->
name|pitch
operator|=
operator|(
name|map
operator|->
name|width
operator|+
literal|7
operator|)
operator|>>
literal|3
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|map
operator|->
name|pixel_mode
operator|=
name|FT_PIXEL_MODE_GRAY2
expr_stmt|;
name|map
operator|->
name|pitch
operator|=
operator|(
name|map
operator|->
name|width
operator|+
literal|3
operator|)
operator|>>
literal|2
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|map
operator|->
name|pixel_mode
operator|=
name|FT_PIXEL_MODE_GRAY4
expr_stmt|;
name|map
operator|->
name|pitch
operator|=
operator|(
name|map
operator|->
name|width
operator|+
literal|1
operator|)
operator|>>
literal|1
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|map
operator|->
name|pixel_mode
operator|=
name|FT_PIXEL_MODE_GRAY
expr_stmt|;
name|map
operator|->
name|pitch
operator|=
name|map
operator|->
name|width
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|SFNT_Err_Invalid_File_Format
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|size
operator|=
name|map
operator|->
name|rows
operator|*
name|map
operator|->
name|pitch
expr_stmt|;
comment|/* check that there is no empty image */
if|if
condition|(
name|size
operator|==
literal|0
condition|)
goto|goto
name|Exit
goto|;
comment|/* exit successfully! */
name|error
operator|=
name|ft_glyphslot_alloc_bitmap
argument_list|(
name|decoder
operator|->
name|face
operator|->
name|root
operator|.
name|glyph
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|decoder
operator|->
name|bitmap_allocated
operator|=
literal|1
expr_stmt|;
name|Exit
label|:
return|return
name|error
return|;
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|tt_sbit_decoder_load_metrics
name|tt_sbit_decoder_load_metrics
parameter_list|(
name|TT_SBitDecoder
name|decoder
parameter_list|,
name|FT_Byte
modifier|*
modifier|*
name|pp
parameter_list|,
name|FT_Byte
modifier|*
name|limit
parameter_list|,
name|FT_Bool
name|big
parameter_list|)
block|{
name|FT_Byte
modifier|*
name|p
init|=
operator|*
name|pp
decl_stmt|;
name|TT_SBit_Metrics
name|metrics
init|=
name|decoder
operator|->
name|metrics
decl_stmt|;
if|if
condition|(
name|p
operator|+
literal|5
operator|>
name|limit
condition|)
goto|goto
name|Fail
goto|;
name|metrics
operator|->
name|height
operator|=
name|p
index|[
literal|0
index|]
expr_stmt|;
name|metrics
operator|->
name|width
operator|=
name|p
index|[
literal|1
index|]
expr_stmt|;
name|metrics
operator|->
name|horiBearingX
operator|=
operator|(
name|FT_Char
operator|)
name|p
index|[
literal|2
index|]
expr_stmt|;
name|metrics
operator|->
name|horiBearingY
operator|=
operator|(
name|FT_Char
operator|)
name|p
index|[
literal|3
index|]
expr_stmt|;
name|metrics
operator|->
name|horiAdvance
operator|=
name|p
index|[
literal|4
index|]
expr_stmt|;
name|p
operator|+=
literal|5
expr_stmt|;
if|if
condition|(
name|big
condition|)
block|{
if|if
condition|(
name|p
operator|+
literal|3
operator|>
name|limit
condition|)
goto|goto
name|Fail
goto|;
name|metrics
operator|->
name|vertBearingX
operator|=
operator|(
name|FT_Char
operator|)
name|p
index|[
literal|0
index|]
expr_stmt|;
name|metrics
operator|->
name|vertBearingY
operator|=
operator|(
name|FT_Char
operator|)
name|p
index|[
literal|1
index|]
expr_stmt|;
name|metrics
operator|->
name|vertAdvance
operator|=
name|p
index|[
literal|2
index|]
expr_stmt|;
name|p
operator|+=
literal|3
expr_stmt|;
block|}
name|decoder
operator|->
name|metrics_loaded
operator|=
literal|1
expr_stmt|;
operator|*
name|pp
operator|=
name|p
expr_stmt|;
return|return
name|SFNT_Err_Ok
return|;
name|Fail
label|:
return|return
name|SFNT_Err_Invalid_Argument
return|;
block|}
end_function
begin_comment
comment|/* forward declaration */
end_comment
begin_function_decl
specifier|static
name|FT_Error
name|tt_sbit_decoder_load_image
parameter_list|(
name|TT_SBitDecoder
name|decoder
parameter_list|,
name|FT_UInt
name|glyph_index
parameter_list|,
name|FT_Int
name|x_pos
parameter_list|,
name|FT_Int
name|y_pos
parameter_list|)
function_decl|;
end_function_decl
begin_typedef
DECL|typedef|TT_SBitDecoder_LoadFunc
typedef|typedef
name|FT_Error
function_decl|(
modifier|*
name|TT_SBitDecoder_LoadFunc
function_decl|)
parameter_list|(
name|TT_SBitDecoder
name|decoder
parameter_list|,
name|FT_Byte
modifier|*
name|p
parameter_list|,
name|FT_Byte
modifier|*
name|plimit
parameter_list|,
name|FT_Int
name|x_pos
parameter_list|,
name|FT_Int
name|y_pos
parameter_list|)
function_decl|;
end_typedef
begin_function
specifier|static
name|FT_Error
DECL|function|tt_sbit_decoder_load_byte_aligned
name|tt_sbit_decoder_load_byte_aligned
parameter_list|(
name|TT_SBitDecoder
name|decoder
parameter_list|,
name|FT_Byte
modifier|*
name|p
parameter_list|,
name|FT_Byte
modifier|*
name|limit
parameter_list|,
name|FT_Int
name|x_pos
parameter_list|,
name|FT_Int
name|y_pos
parameter_list|)
block|{
name|FT_Error
name|error
init|=
name|SFNT_Err_Ok
decl_stmt|;
name|FT_Byte
modifier|*
name|line
decl_stmt|;
name|FT_Int
name|bit_height
decl_stmt|,
name|bit_width
decl_stmt|,
name|pitch
decl_stmt|,
name|width
decl_stmt|,
name|height
decl_stmt|,
name|h
decl_stmt|;
name|FT_Bitmap
modifier|*
name|bitmap
decl_stmt|;
if|if
condition|(
operator|!
name|decoder
operator|->
name|bitmap_allocated
condition|)
block|{
name|error
operator|=
name|tt_sbit_decoder_alloc_bitmap
argument_list|(
name|decoder
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
block|}
comment|/* check that we can write the glyph into the bitmap */
name|bitmap
operator|=
name|decoder
operator|->
name|bitmap
expr_stmt|;
name|bit_width
operator|=
name|bitmap
operator|->
name|width
expr_stmt|;
name|bit_height
operator|=
name|bitmap
operator|->
name|rows
expr_stmt|;
name|pitch
operator|=
name|bitmap
operator|->
name|pitch
expr_stmt|;
name|line
operator|=
name|bitmap
operator|->
name|buffer
expr_stmt|;
name|width
operator|=
name|decoder
operator|->
name|metrics
operator|->
name|width
expr_stmt|;
name|height
operator|=
name|decoder
operator|->
name|metrics
operator|->
name|height
expr_stmt|;
if|if
condition|(
name|x_pos
operator|<
literal|0
operator|||
name|x_pos
operator|+
name|width
operator|>
name|bit_width
operator|||
name|y_pos
operator|<
literal|0
operator|||
name|y_pos
operator|+
name|height
operator|>
name|bit_height
condition|)
block|{
name|error
operator|=
name|SFNT_Err_Invalid_File_Format
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|p
operator|+
operator|(
operator|(
name|width
operator|+
literal|7
operator|)
operator|>>
literal|3
operator|)
operator|*
name|height
operator|>
name|limit
condition|)
block|{
name|error
operator|=
name|SFNT_Err_Invalid_File_Format
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* now do the blit */
name|line
operator|+=
name|y_pos
operator|*
name|pitch
operator|+
operator|(
name|x_pos
operator|>>
literal|3
operator|)
expr_stmt|;
name|x_pos
operator|&=
literal|7
expr_stmt|;
if|if
condition|(
name|x_pos
operator|==
literal|0
condition|)
comment|/* the easy one */
block|{
for|for
control|(
name|h
operator|=
name|height
init|;
name|h
operator|>
literal|0
condition|;
name|h
operator|--
operator|,
name|line
operator|+=
name|pitch
control|)
block|{
name|FT_Byte
modifier|*
name|write
init|=
name|line
decl_stmt|;
name|FT_Int
name|w
decl_stmt|;
for|for
control|(
name|w
operator|=
name|width
init|;
name|w
operator|>=
literal|8
condition|;
name|w
operator|-=
literal|8
control|)
block|{
name|write
index|[
literal|0
index|]
operator|=
call|(
name|FT_Byte
call|)
argument_list|(
name|write
index|[
literal|0
index|]
operator||
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
name|write
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|w
operator|>
literal|0
condition|)
name|write
index|[
literal|0
index|]
operator|=
call|(
name|FT_Byte
call|)
argument_list|(
name|write
index|[
literal|0
index|]
operator||
operator|(
operator|*
name|p
operator|++
operator|&
operator|(
literal|0xFF00U
operator|>>
name|w
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
comment|/* x_pos> 0 */
block|{
for|for
control|(
name|h
operator|=
name|height
init|;
name|h
operator|>
literal|0
condition|;
name|h
operator|--
operator|,
name|line
operator|+=
name|pitch
control|)
block|{
name|FT_Byte
modifier|*
name|write
init|=
name|line
decl_stmt|;
name|FT_Int
name|w
decl_stmt|;
name|FT_UInt
name|wval
init|=
literal|0
decl_stmt|;
for|for
control|(
name|w
operator|=
name|width
init|;
name|w
operator|>=
literal|8
condition|;
name|w
operator|-=
literal|8
control|)
block|{
name|wval
operator|=
call|(
name|FT_UInt
call|)
argument_list|(
name|wval
operator||
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
name|write
index|[
literal|0
index|]
operator|=
call|(
name|FT_Byte
call|)
argument_list|(
name|write
index|[
literal|0
index|]
operator||
operator|(
name|wval
operator|>>
name|x_pos
operator|)
argument_list|)
expr_stmt|;
name|write
operator|+=
literal|1
expr_stmt|;
name|wval
operator|<<=
literal|8
expr_stmt|;
block|}
if|if
condition|(
name|w
operator|>
literal|0
condition|)
name|wval
operator|=
call|(
name|FT_UInt
call|)
argument_list|(
name|wval
operator||
operator|(
operator|*
name|p
operator|++
operator|&
operator|(
literal|0xFF00U
operator|>>
name|w
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* all bits read and there are `x_pos + w' bits to be written */
name|write
index|[
literal|0
index|]
operator|=
call|(
name|FT_Byte
call|)
argument_list|(
name|write
index|[
literal|0
index|]
operator||
operator|(
name|wval
operator|>>
name|x_pos
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|x_pos
operator|+
name|w
operator|>
literal|8
condition|)
block|{
name|write
operator|++
expr_stmt|;
name|wval
operator|<<=
literal|8
expr_stmt|;
name|write
index|[
literal|0
index|]
operator|=
call|(
name|FT_Byte
call|)
argument_list|(
name|write
index|[
literal|0
index|]
operator||
operator|(
name|wval
operator|>>
name|x_pos
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|Exit
label|:
return|return
name|error
return|;
block|}
end_function
begin_comment
comment|/*    * Load a bit-aligned bitmap (with pointer `p') into a line-aligned bitmap    * (with pointer `write').  In the example below, the width is 3 pixel,    * and `x_pos' is 1 pixel.    *    *       p                               p+1    *     |                               |                               |    *     | 7   6   5   4   3   2   1   0 | 7   6   5   4   3   2   1   0 |...    *     |                               |                               |    *       +-------+   +-------+   +-------+ ...    *           .           .           .    *           .           .           .    *           v           .           .    *       +-------+       .           .    * |                               | .    * | 7   6   5   4   3   2   1   0 | .    * |                               | .    *   write               .           .    *                       .           .    *                       v           .    *                   +-------+       .    *             |                               |    *             | 7   6   5   4   3   2   1   0 |    *             |                               |    *               write+1             .    *                                   .    *                                   v    *                               +-------+    *                         |                               |    *                         | 7   6   5   4   3   2   1   0 |    *                         |                               |    *                           write+2    *    */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|tt_sbit_decoder_load_bit_aligned
name|tt_sbit_decoder_load_bit_aligned
parameter_list|(
name|TT_SBitDecoder
name|decoder
parameter_list|,
name|FT_Byte
modifier|*
name|p
parameter_list|,
name|FT_Byte
modifier|*
name|limit
parameter_list|,
name|FT_Int
name|x_pos
parameter_list|,
name|FT_Int
name|y_pos
parameter_list|)
block|{
name|FT_Error
name|error
init|=
name|SFNT_Err_Ok
decl_stmt|;
name|FT_Byte
modifier|*
name|line
decl_stmt|;
name|FT_Int
name|bit_height
decl_stmt|,
name|bit_width
decl_stmt|,
name|pitch
decl_stmt|,
name|width
decl_stmt|,
name|height
decl_stmt|,
name|h
decl_stmt|,
name|nbits
decl_stmt|;
name|FT_Bitmap
modifier|*
name|bitmap
decl_stmt|;
name|FT_UShort
name|rval
decl_stmt|;
if|if
condition|(
operator|!
name|decoder
operator|->
name|bitmap_allocated
condition|)
block|{
name|error
operator|=
name|tt_sbit_decoder_alloc_bitmap
argument_list|(
name|decoder
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
block|}
comment|/* check that we can write the glyph into the bitmap */
name|bitmap
operator|=
name|decoder
operator|->
name|bitmap
expr_stmt|;
name|bit_width
operator|=
name|bitmap
operator|->
name|width
expr_stmt|;
name|bit_height
operator|=
name|bitmap
operator|->
name|rows
expr_stmt|;
name|pitch
operator|=
name|bitmap
operator|->
name|pitch
expr_stmt|;
name|line
operator|=
name|bitmap
operator|->
name|buffer
expr_stmt|;
name|width
operator|=
name|decoder
operator|->
name|metrics
operator|->
name|width
expr_stmt|;
name|height
operator|=
name|decoder
operator|->
name|metrics
operator|->
name|height
expr_stmt|;
if|if
condition|(
name|x_pos
operator|<
literal|0
operator|||
name|x_pos
operator|+
name|width
operator|>
name|bit_width
operator|||
name|y_pos
operator|<
literal|0
operator|||
name|y_pos
operator|+
name|height
operator|>
name|bit_height
condition|)
block|{
name|error
operator|=
name|SFNT_Err_Invalid_File_Format
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|p
operator|+
operator|(
operator|(
name|width
operator|*
name|height
operator|+
literal|7
operator|)
operator|>>
literal|3
operator|)
operator|>
name|limit
condition|)
block|{
name|error
operator|=
name|SFNT_Err_Invalid_File_Format
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* now do the blit */
comment|/* adjust `line' to point to the first byte of the bitmap */
name|line
operator|+=
name|y_pos
operator|*
name|pitch
operator|+
operator|(
name|x_pos
operator|>>
literal|3
operator|)
expr_stmt|;
name|x_pos
operator|&=
literal|7
expr_stmt|;
comment|/* the higher byte of `rval' is used as a buffer */
name|rval
operator|=
literal|0
expr_stmt|;
name|nbits
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|h
operator|=
name|height
init|;
name|h
operator|>
literal|0
condition|;
name|h
operator|--
operator|,
name|line
operator|+=
name|pitch
control|)
block|{
name|FT_Byte
modifier|*
name|write
init|=
name|line
decl_stmt|;
name|FT_Int
name|w
init|=
name|width
decl_stmt|;
comment|/* handle initial byte (in target bitmap) specially if necessary */
if|if
condition|(
name|x_pos
condition|)
block|{
name|w
operator|=
operator|(
name|width
operator|<
literal|8
operator|-
name|x_pos
operator|)
condition|?
name|width
else|:
literal|8
operator|-
name|x_pos
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|height
condition|)
block|{
name|rval
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|nbits
operator|=
name|x_pos
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nbits
operator|<
name|w
condition|)
block|{
if|if
condition|(
name|p
operator|<
name|limit
condition|)
name|rval
operator||=
operator|*
name|p
operator|++
expr_stmt|;
name|nbits
operator|+=
literal|8
operator|-
name|w
expr_stmt|;
block|}
else|else
block|{
name|rval
operator|>>=
literal|8
expr_stmt|;
name|nbits
operator|-=
name|w
expr_stmt|;
block|}
operator|*
name|write
operator|++
operator||=
operator|(
operator|(
name|rval
operator|>>
name|nbits
operator|)
operator|&
literal|0xFF
operator|)
operator|&
operator|(
operator|~
operator|(
literal|0xFF
operator|<<
name|w
operator|)
operator|<<
operator|(
literal|8
operator|-
name|w
operator|-
name|x_pos
operator|)
operator|)
expr_stmt|;
name|rval
operator|<<=
literal|8
expr_stmt|;
name|w
operator|=
name|width
operator|-
name|w
expr_stmt|;
block|}
comment|/* handle medial bytes */
for|for
control|(
init|;
name|w
operator|>=
literal|8
condition|;
name|w
operator|-=
literal|8
control|)
block|{
name|rval
operator||=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|write
operator|++
operator||=
operator|(
name|rval
operator|>>
name|nbits
operator|)
operator|&
literal|0xFF
expr_stmt|;
name|rval
operator|<<=
literal|8
expr_stmt|;
block|}
comment|/* handle final byte if necessary */
if|if
condition|(
name|w
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|nbits
operator|<
name|w
condition|)
block|{
if|if
condition|(
name|p
operator|<
name|limit
condition|)
name|rval
operator||=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|write
operator||=
operator|(
operator|(
name|rval
operator|>>
name|nbits
operator|)
operator|&
literal|0xFF
operator|)
operator|&
operator|(
literal|0xFF00U
operator|>>
name|w
operator|)
expr_stmt|;
name|nbits
operator|+=
literal|8
operator|-
name|w
expr_stmt|;
name|rval
operator|<<=
literal|8
expr_stmt|;
block|}
else|else
block|{
operator|*
name|write
operator||=
operator|(
operator|(
name|rval
operator|>>
name|nbits
operator|)
operator|&
literal|0xFF
operator|)
operator|&
operator|(
literal|0xFF00U
operator|>>
name|w
operator|)
expr_stmt|;
name|nbits
operator|-=
name|w
expr_stmt|;
block|}
block|}
block|}
name|Exit
label|:
return|return
name|error
return|;
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|tt_sbit_decoder_load_compound
name|tt_sbit_decoder_load_compound
parameter_list|(
name|TT_SBitDecoder
name|decoder
parameter_list|,
name|FT_Byte
modifier|*
name|p
parameter_list|,
name|FT_Byte
modifier|*
name|limit
parameter_list|,
name|FT_Int
name|x_pos
parameter_list|,
name|FT_Int
name|y_pos
parameter_list|)
block|{
name|FT_Error
name|error
init|=
name|SFNT_Err_Ok
decl_stmt|;
name|FT_UInt
name|num_components
decl_stmt|,
name|nn
decl_stmt|;
name|FT_Char
name|horiBearingX
init|=
name|decoder
operator|->
name|metrics
operator|->
name|horiBearingX
decl_stmt|;
name|FT_Char
name|horiBearingY
init|=
name|decoder
operator|->
name|metrics
operator|->
name|horiBearingY
decl_stmt|;
name|FT_Byte
name|horiAdvance
init|=
name|decoder
operator|->
name|metrics
operator|->
name|horiAdvance
decl_stmt|;
name|FT_Char
name|vertBearingX
init|=
name|decoder
operator|->
name|metrics
operator|->
name|vertBearingX
decl_stmt|;
name|FT_Char
name|vertBearingY
init|=
name|decoder
operator|->
name|metrics
operator|->
name|vertBearingY
decl_stmt|;
name|FT_Byte
name|vertAdvance
init|=
name|decoder
operator|->
name|metrics
operator|->
name|vertAdvance
decl_stmt|;
if|if
condition|(
name|p
operator|+
literal|2
operator|>
name|limit
condition|)
goto|goto
name|Fail
goto|;
name|num_components
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|+
literal|4
operator|*
name|num_components
operator|>
name|limit
condition|)
goto|goto
name|Fail
goto|;
if|if
condition|(
operator|!
name|decoder
operator|->
name|bitmap_allocated
condition|)
block|{
name|error
operator|=
name|tt_sbit_decoder_alloc_bitmap
argument_list|(
name|decoder
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
block|}
for|for
control|(
name|nn
operator|=
literal|0
init|;
name|nn
operator|<
name|num_components
condition|;
name|nn
operator|++
control|)
block|{
name|FT_UInt
name|gindex
init|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|FT_Byte
name|dx
init|=
name|FT_NEXT_BYTE
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|FT_Byte
name|dy
init|=
name|FT_NEXT_BYTE
argument_list|(
name|p
argument_list|)
decl_stmt|;
comment|/* NB: a recursive call */
name|error
operator|=
name|tt_sbit_decoder_load_image
argument_list|(
name|decoder
argument_list|,
name|gindex
argument_list|,
name|x_pos
operator|+
name|dx
argument_list|,
name|y_pos
operator|+
name|dy
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
name|decoder
operator|->
name|metrics
operator|->
name|horiBearingX
operator|=
name|horiBearingX
expr_stmt|;
name|decoder
operator|->
name|metrics
operator|->
name|horiBearingY
operator|=
name|horiBearingY
expr_stmt|;
name|decoder
operator|->
name|metrics
operator|->
name|horiAdvance
operator|=
name|horiAdvance
expr_stmt|;
name|decoder
operator|->
name|metrics
operator|->
name|vertBearingX
operator|=
name|vertBearingX
expr_stmt|;
name|decoder
operator|->
name|metrics
operator|->
name|vertBearingY
operator|=
name|vertBearingY
expr_stmt|;
name|decoder
operator|->
name|metrics
operator|->
name|vertAdvance
operator|=
name|vertAdvance
expr_stmt|;
name|decoder
operator|->
name|metrics
operator|->
name|width
operator|=
operator|(
name|FT_UInt
operator|)
name|decoder
operator|->
name|bitmap
operator|->
name|width
expr_stmt|;
name|decoder
operator|->
name|metrics
operator|->
name|height
operator|=
operator|(
name|FT_UInt
operator|)
name|decoder
operator|->
name|bitmap
operator|->
name|rows
expr_stmt|;
name|Exit
label|:
return|return
name|error
return|;
name|Fail
label|:
name|error
operator|=
name|SFNT_Err_Invalid_File_Format
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|tt_sbit_decoder_load_bitmap
name|tt_sbit_decoder_load_bitmap
parameter_list|(
name|TT_SBitDecoder
name|decoder
parameter_list|,
name|FT_UInt
name|glyph_format
parameter_list|,
name|FT_ULong
name|glyph_start
parameter_list|,
name|FT_ULong
name|glyph_size
parameter_list|,
name|FT_Int
name|x_pos
parameter_list|,
name|FT_Int
name|y_pos
parameter_list|)
block|{
name|FT_Error
name|error
decl_stmt|;
name|FT_Stream
name|stream
init|=
name|decoder
operator|->
name|stream
decl_stmt|;
name|FT_Byte
modifier|*
name|p
decl_stmt|;
name|FT_Byte
modifier|*
name|p_limit
decl_stmt|;
name|FT_Byte
modifier|*
name|data
decl_stmt|;
comment|/* seek into the EBDT table now */
if|if
condition|(
name|glyph_start
operator|+
name|glyph_size
operator|>
name|decoder
operator|->
name|ebdt_size
condition|)
block|{
name|error
operator|=
name|SFNT_Err_Invalid_Argument
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|FT_STREAM_SEEK
argument_list|(
name|decoder
operator|->
name|ebdt_start
operator|+
name|glyph_start
argument_list|)
operator|||
name|FT_FRAME_EXTRACT
argument_list|(
name|glyph_size
argument_list|,
name|data
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|p
operator|=
name|data
expr_stmt|;
name|p_limit
operator|=
name|p
operator|+
name|glyph_size
expr_stmt|;
comment|/* read the data, depending on the glyph format */
switch|switch
condition|(
name|glyph_format
condition|)
block|{
case|case
literal|1
case|:
case|case
literal|2
case|:
case|case
literal|8
case|:
name|error
operator|=
name|tt_sbit_decoder_load_metrics
argument_list|(
name|decoder
argument_list|,
operator|&
name|p
argument_list|,
name|p_limit
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|6
case|:
case|case
literal|7
case|:
case|case
literal|9
case|:
name|error
operator|=
name|tt_sbit_decoder_load_metrics
argument_list|(
name|decoder
argument_list|,
operator|&
name|p
argument_list|,
name|p_limit
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|SFNT_Err_Ok
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
goto|goto
name|Fail
goto|;
block|{
name|TT_SBitDecoder_LoadFunc
name|loader
decl_stmt|;
switch|switch
condition|(
name|glyph_format
condition|)
block|{
case|case
literal|1
case|:
case|case
literal|6
case|:
name|loader
operator|=
name|tt_sbit_decoder_load_byte_aligned
expr_stmt|;
break|break;
case|case
literal|2
case|:
case|case
literal|5
case|:
case|case
literal|7
case|:
name|loader
operator|=
name|tt_sbit_decoder_load_bit_aligned
expr_stmt|;
break|break;
case|case
literal|8
case|:
if|if
condition|(
name|p
operator|+
literal|1
operator|>
name|p_limit
condition|)
goto|goto
name|Fail
goto|;
name|p
operator|+=
literal|1
expr_stmt|;
comment|/* skip padding */
comment|/* fall-through */
case|case
literal|9
case|:
name|loader
operator|=
name|tt_sbit_decoder_load_compound
expr_stmt|;
break|break;
default|default:
goto|goto
name|Fail
goto|;
block|}
name|error
operator|=
name|loader
argument_list|(
name|decoder
argument_list|,
name|p
argument_list|,
name|p_limit
argument_list|,
name|x_pos
argument_list|,
name|y_pos
argument_list|)
expr_stmt|;
block|}
name|Fail
label|:
name|FT_FRAME_RELEASE
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|Exit
label|:
return|return
name|error
return|;
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|tt_sbit_decoder_load_image
name|tt_sbit_decoder_load_image
parameter_list|(
name|TT_SBitDecoder
name|decoder
parameter_list|,
name|FT_UInt
name|glyph_index
parameter_list|,
name|FT_Int
name|x_pos
parameter_list|,
name|FT_Int
name|y_pos
parameter_list|)
block|{
comment|/*      *  First, we find the correct strike range that applies to this      *  glyph index.      */
name|FT_Byte
modifier|*
name|p
init|=
name|decoder
operator|->
name|eblc_base
operator|+
name|decoder
operator|->
name|strike_index_array
decl_stmt|;
name|FT_Byte
modifier|*
name|p_limit
init|=
name|decoder
operator|->
name|eblc_limit
decl_stmt|;
name|FT_ULong
name|num_ranges
init|=
name|decoder
operator|->
name|strike_index_count
decl_stmt|;
name|FT_UInt
name|start
decl_stmt|,
name|end
decl_stmt|,
name|index_format
decl_stmt|,
name|image_format
decl_stmt|;
name|FT_ULong
name|image_start
init|=
literal|0
decl_stmt|,
name|image_end
init|=
literal|0
decl_stmt|,
name|image_offset
decl_stmt|;
for|for
control|(
init|;
name|num_ranges
operator|>
literal|0
condition|;
name|num_ranges
operator|--
control|)
block|{
name|start
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|end
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|glyph_index
operator|>=
name|start
operator|&&
name|glyph_index
operator|<=
name|end
condition|)
goto|goto
name|FoundRange
goto|;
name|p
operator|+=
literal|4
expr_stmt|;
comment|/* ignore index offset */
block|}
goto|goto
name|NoBitmap
goto|;
name|FoundRange
label|:
name|image_offset
operator|=
name|FT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* overflow check */
if|if
condition|(
name|decoder
operator|->
name|eblc_base
operator|+
name|decoder
operator|->
name|strike_index_array
operator|+
name|image_offset
operator|<
name|decoder
operator|->
name|eblc_base
condition|)
goto|goto
name|Failure
goto|;
name|p
operator|=
name|decoder
operator|->
name|eblc_base
operator|+
name|decoder
operator|->
name|strike_index_array
operator|+
name|image_offset
expr_stmt|;
if|if
condition|(
name|p
operator|+
literal|8
operator|>
name|p_limit
condition|)
goto|goto
name|NoBitmap
goto|;
comment|/* now find the glyph's location and extend within the ebdt table */
name|index_format
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|image_format
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|image_offset
operator|=
name|FT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|index_format
condition|)
block|{
case|case
literal|1
case|:
comment|/* 4-byte offsets relative to `image_offset' */
block|{
name|p
operator|+=
literal|4
operator|*
operator|(
name|glyph_index
operator|-
name|start
operator|)
expr_stmt|;
if|if
condition|(
name|p
operator|+
literal|8
operator|>
name|p_limit
condition|)
goto|goto
name|NoBitmap
goto|;
name|image_start
operator|=
name|FT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|image_end
operator|=
name|FT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|image_start
operator|==
name|image_end
condition|)
comment|/* missing glyph */
goto|goto
name|NoBitmap
goto|;
block|}
break|break;
case|case
literal|2
case|:
comment|/* big metrics, constant image size */
block|{
name|FT_ULong
name|image_size
decl_stmt|;
if|if
condition|(
name|p
operator|+
literal|12
operator|>
name|p_limit
condition|)
goto|goto
name|NoBitmap
goto|;
name|image_size
operator|=
name|FT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|tt_sbit_decoder_load_metrics
argument_list|(
name|decoder
argument_list|,
operator|&
name|p
argument_list|,
name|p_limit
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|NoBitmap
goto|;
name|image_start
operator|=
name|image_size
operator|*
operator|(
name|glyph_index
operator|-
name|start
operator|)
expr_stmt|;
name|image_end
operator|=
name|image_start
operator|+
name|image_size
expr_stmt|;
block|}
break|break;
case|case
literal|3
case|:
comment|/* 2-byte offsets relative to 'image_offset' */
block|{
name|p
operator|+=
literal|2
operator|*
operator|(
name|glyph_index
operator|-
name|start
operator|)
expr_stmt|;
if|if
condition|(
name|p
operator|+
literal|4
operator|>
name|p_limit
condition|)
goto|goto
name|NoBitmap
goto|;
name|image_start
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|image_end
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|image_start
operator|==
name|image_end
condition|)
comment|/* missing glyph */
goto|goto
name|NoBitmap
goto|;
block|}
break|break;
case|case
literal|4
case|:
comment|/* sparse glyph array with (glyph,offset) pairs */
block|{
name|FT_ULong
name|mm
decl_stmt|,
name|num_glyphs
decl_stmt|;
if|if
condition|(
name|p
operator|+
literal|4
operator|>
name|p_limit
condition|)
goto|goto
name|NoBitmap
goto|;
name|num_glyphs
operator|=
name|FT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* overflow check */
if|if
condition|(
name|p
operator|+
operator|(
name|num_glyphs
operator|+
literal|1
operator|)
operator|*
literal|4
operator|<
name|p
condition|)
goto|goto
name|Failure
goto|;
if|if
condition|(
name|p
operator|+
operator|(
name|num_glyphs
operator|+
literal|1
operator|)
operator|*
literal|4
operator|>
name|p_limit
condition|)
goto|goto
name|NoBitmap
goto|;
for|for
control|(
name|mm
operator|=
literal|0
init|;
name|mm
operator|<
name|num_glyphs
condition|;
name|mm
operator|++
control|)
block|{
name|FT_UInt
name|gindex
init|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|gindex
operator|==
name|glyph_index
condition|)
block|{
name|image_start
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
name|image_end
operator|=
name|FT_PEEK_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
name|p
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|mm
operator|>=
name|num_glyphs
condition|)
goto|goto
name|NoBitmap
goto|;
block|}
break|break;
case|case
literal|5
case|:
comment|/* constant metrics with sparse glyph codes */
block|{
name|FT_ULong
name|image_size
decl_stmt|,
name|mm
decl_stmt|,
name|num_glyphs
decl_stmt|;
if|if
condition|(
name|p
operator|+
literal|16
operator|>
name|p_limit
condition|)
goto|goto
name|NoBitmap
goto|;
name|image_size
operator|=
name|FT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|tt_sbit_decoder_load_metrics
argument_list|(
name|decoder
argument_list|,
operator|&
name|p
argument_list|,
name|p_limit
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|NoBitmap
goto|;
name|num_glyphs
operator|=
name|FT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* overflow check */
if|if
condition|(
name|p
operator|+
literal|2
operator|*
name|num_glyphs
operator|<
name|p
condition|)
goto|goto
name|Failure
goto|;
if|if
condition|(
name|p
operator|+
literal|2
operator|*
name|num_glyphs
operator|>
name|p_limit
condition|)
goto|goto
name|NoBitmap
goto|;
for|for
control|(
name|mm
operator|=
literal|0
init|;
name|mm
operator|<
name|num_glyphs
condition|;
name|mm
operator|++
control|)
block|{
name|FT_UInt
name|gindex
init|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|gindex
operator|==
name|glyph_index
condition|)
break|break;
block|}
if|if
condition|(
name|mm
operator|>=
name|num_glyphs
condition|)
goto|goto
name|NoBitmap
goto|;
name|image_start
operator|=
name|image_size
operator|*
name|mm
expr_stmt|;
name|image_end
operator|=
name|image_start
operator|+
name|image_size
expr_stmt|;
block|}
break|break;
default|default:
goto|goto
name|NoBitmap
goto|;
block|}
if|if
condition|(
name|image_start
operator|>
name|image_end
condition|)
goto|goto
name|NoBitmap
goto|;
name|image_end
operator|-=
name|image_start
expr_stmt|;
name|image_start
operator|=
name|image_offset
operator|+
name|image_start
expr_stmt|;
return|return
name|tt_sbit_decoder_load_bitmap
argument_list|(
name|decoder
argument_list|,
name|image_format
argument_list|,
name|image_start
argument_list|,
name|image_end
argument_list|,
name|x_pos
argument_list|,
name|y_pos
argument_list|)
return|;
name|Failure
label|:
return|return
name|SFNT_Err_Invalid_Table
return|;
name|NoBitmap
label|:
return|return
name|SFNT_Err_Invalid_Argument
return|;
block|}
end_function
begin_macro
DECL|function|FT_LOCAL
name|FT_LOCAL
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|tt_face_load_sbit_image
argument_list|(
argument|TT_Face              face
argument_list|,
argument|FT_ULong             strike_index
argument_list|,
argument|FT_UInt              glyph_index
argument_list|,
argument|FT_UInt              load_flags
argument_list|,
argument|FT_Stream            stream
argument_list|,
argument|FT_Bitmap           *map
argument_list|,
argument|TT_SBit_MetricsRec  *metrics
argument_list|)
end_macro
begin_block
block|{
name|TT_SBitDecoderRec
name|decoder
index|[
literal|1
index|]
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|FT_UNUSED
argument_list|(
name|load_flags
argument_list|)
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|error
operator|=
name|tt_sbit_decoder_init
argument_list|(
name|decoder
argument_list|,
name|face
argument_list|,
name|strike_index
argument_list|,
name|metrics
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|error
operator|=
name|tt_sbit_decoder_load_image
argument_list|(
name|decoder
argument_list|,
name|glyph_index
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_sbit_decoder_done
argument_list|(
name|decoder
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/* EOF */
end_comment
end_unit
