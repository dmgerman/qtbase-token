begin_unit
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  ttsbit.c                                                               */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*    TrueType and OpenType embedded bitmap support (body).                */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  Copyright 2005-2009, 2013, 2014 by                                     */
end_comment
begin_comment
comment|/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  Copyright 2013 by Google, Inc.                                         */
end_comment
begin_comment
comment|/*  Google Author(s): Behdad Esfahbod.                                     */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  This file is part of the FreeType project, and may only be used,       */
end_comment
begin_comment
comment|/*  modified, and distributed under the terms of the FreeType project      */
end_comment
begin_comment
comment|/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
end_comment
begin_comment
comment|/*  this file you indicate that you have read the license and              */
end_comment
begin_comment
comment|/*  understand and accept it fully.                                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<ft2build.h>
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_DEBUG_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_STREAM_H
end_include
begin_include
include|#
directive|include
include|FT_TRUETYPE_TAGS_H
end_include
begin_include
include|#
directive|include
include|FT_BITMAP_H
end_include
begin_include
include|#
directive|include
file|"ttsbit.h"
end_include
begin_include
include|#
directive|include
file|"sferrors.h"
end_include
begin_include
include|#
directive|include
file|"ttmtx.h"
end_include
begin_include
include|#
directive|include
file|"pngshim.h"
end_include
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
end_comment
begin_comment
comment|/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
end_comment
begin_comment
comment|/* messages during execution.                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_undef
DECL|macro|FT_COMPONENT
undef|#
directive|undef
name|FT_COMPONENT
end_undef
begin_define
DECL|macro|FT_COMPONENT
define|#
directive|define
name|FT_COMPONENT
value|trace_ttsbit
end_define
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|tt_face_load_sbit
argument_list|(
argument|TT_Face    face
argument_list|,
argument|FT_Stream  stream
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
decl_stmt|;
name|FT_ULong
name|table_size
decl_stmt|;
name|face
operator|->
name|sbit_table
operator|=
name|NULL
expr_stmt|;
name|face
operator|->
name|sbit_table_size
operator|=
literal|0
expr_stmt|;
name|face
operator|->
name|sbit_table_type
operator|=
name|TT_SBIT_TABLE_TYPE_NONE
expr_stmt|;
name|face
operator|->
name|sbit_num_strikes
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|face
operator|->
name|goto_table
argument_list|(
name|face
argument_list|,
name|TTAG_CBLC
argument_list|,
name|stream
argument_list|,
operator|&
name|table_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|face
operator|->
name|sbit_table_type
operator|=
name|TT_SBIT_TABLE_TYPE_CBLC
expr_stmt|;
else|else
block|{
name|error
operator|=
name|face
operator|->
name|goto_table
argument_list|(
name|face
argument_list|,
name|TTAG_EBLC
argument_list|,
name|stream
argument_list|,
operator|&
name|table_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|error
operator|=
name|face
operator|->
name|goto_table
argument_list|(
name|face
argument_list|,
name|TTAG_bloc
argument_list|,
name|stream
argument_list|,
operator|&
name|table_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|face
operator|->
name|sbit_table_type
operator|=
name|TT_SBIT_TABLE_TYPE_EBLC
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|error
operator|=
name|face
operator|->
name|goto_table
argument_list|(
name|face
argument_list|,
name|TTAG_sbix
argument_list|,
name|stream
argument_list|,
operator|&
name|table_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|face
operator|->
name|sbit_table_type
operator|=
name|TT_SBIT_TABLE_TYPE_SBIX
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
if|if
condition|(
name|table_size
operator|<
literal|8
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"tt_face_load_sbit_strikes: table too short\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_File_Format
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
switch|switch
condition|(
operator|(
name|FT_UInt
operator|)
name|face
operator|->
name|sbit_table_type
condition|)
block|{
case|case
name|TT_SBIT_TABLE_TYPE_EBLC
case|:
case|case
name|TT_SBIT_TABLE_TYPE_CBLC
case|:
block|{
name|FT_Byte
modifier|*
name|p
decl_stmt|;
name|FT_Fixed
name|version
decl_stmt|;
name|FT_ULong
name|num_strikes
decl_stmt|;
name|FT_UInt
name|count
decl_stmt|;
if|if
condition|(
name|FT_FRAME_EXTRACT
argument_list|(
name|table_size
argument_list|,
name|face
operator|->
name|sbit_table
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|face
operator|->
name|sbit_table_size
operator|=
name|table_size
expr_stmt|;
name|p
operator|=
name|face
operator|->
name|sbit_table
expr_stmt|;
name|version
operator|=
name|FT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|num_strikes
operator|=
name|FT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|version
operator|&
literal|0xFFFF0000UL
operator|)
operator|!=
literal|0x00020000UL
condition|)
block|{
name|error
operator|=
name|FT_THROW
argument_list|(
name|Unknown_File_Format
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|num_strikes
operator|>=
literal|0x10000UL
condition|)
block|{
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_File_Format
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/*          *  Count the number of strikes available in the table.  We are a bit          *  paranoid there and don't trust the data.          */
name|count
operator|=
operator|(
name|FT_UInt
operator|)
name|num_strikes
expr_stmt|;
if|if
condition|(
literal|8
operator|+
literal|48UL
operator|*
name|count
operator|>
name|table_size
condition|)
name|count
operator|=
call|(
name|FT_UInt
call|)
argument_list|(
operator|(
name|table_size
operator|-
literal|8
operator|)
operator|/
literal|48
argument_list|)
expr_stmt|;
name|face
operator|->
name|sbit_num_strikes
operator|=
name|count
expr_stmt|;
block|}
break|break;
case|case
name|TT_SBIT_TABLE_TYPE_SBIX
case|:
block|{
name|FT_UShort
name|version
decl_stmt|;
name|FT_UShort
name|flags
decl_stmt|;
name|FT_ULong
name|num_strikes
decl_stmt|;
name|FT_UInt
name|count
decl_stmt|;
if|if
condition|(
name|FT_FRAME_ENTER
argument_list|(
literal|8
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|version
operator|=
name|FT_GET_USHORT
argument_list|()
expr_stmt|;
name|flags
operator|=
name|FT_GET_USHORT
argument_list|()
expr_stmt|;
name|num_strikes
operator|=
name|FT_GET_ULONG
argument_list|()
expr_stmt|;
name|FT_FRAME_EXIT
argument_list|()
expr_stmt|;
if|if
condition|(
name|version
operator|<
literal|1
condition|)
block|{
name|error
operator|=
name|FT_THROW
argument_list|(
name|Unknown_File_Format
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* Bit 0 must always be `1'.                            */
comment|/* Bit 1 controls the overlay of bitmaps with outlines. */
comment|/* All other bits should be zero.                       */
if|if
condition|(
operator|!
operator|(
name|flags
operator|==
literal|1
operator|||
name|flags
operator|==
literal|3
operator|)
operator|||
name|num_strikes
operator|>=
literal|0x10000UL
condition|)
block|{
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_File_Format
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* we currently don't support bit 1; however, it is better to */
comment|/* draw at least something...                                 */
if|if
condition|(
name|flags
operator|==
literal|3
condition|)
name|FT_TRACE1
argument_list|(
operator|(
literal|"tt_face_load_sbit_strikes:"
literal|" sbix overlay not supported yet\n"
literal|"                          "
literal|" expect bad rendering results\n"
operator|)
argument_list|)
expr_stmt|;
comment|/*          *  Count the number of strikes available in the table.  We are a bit          *  paranoid there and don't trust the data.          */
name|count
operator|=
operator|(
name|FT_UInt
operator|)
name|num_strikes
expr_stmt|;
if|if
condition|(
literal|8
operator|+
literal|4UL
operator|*
name|count
operator|>
name|table_size
condition|)
name|count
operator|=
call|(
name|FT_UInt
call|)
argument_list|(
operator|(
name|table_size
operator|-
literal|8
operator|)
operator|/
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|FT_STREAM_SEEK
argument_list|(
name|FT_STREAM_POS
argument_list|()
operator|-
literal|8
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|face
operator|->
name|sbit_table_size
operator|=
literal|8
operator|+
name|count
operator|*
literal|4
expr_stmt|;
if|if
condition|(
name|FT_FRAME_EXTRACT
argument_list|(
name|face
operator|->
name|sbit_table_size
argument_list|,
name|face
operator|->
name|sbit_table
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|face
operator|->
name|sbit_num_strikes
operator|=
name|count
expr_stmt|;
block|}
break|break;
default|default:
name|error
operator|=
name|FT_THROW
argument_list|(
name|Unknown_File_Format
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|error
condition|)
name|FT_TRACE3
argument_list|(
operator|(
literal|"sbit_num_strikes: %u\n"
operator|,
name|face
operator|->
name|sbit_num_strikes
operator|)
argument_list|)
expr_stmt|;
return|return
name|FT_Err_Ok
return|;
name|Exit
label|:
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|face
operator|->
name|sbit_table
condition|)
name|FT_FRAME_RELEASE
argument_list|(
name|face
operator|->
name|sbit_table
argument_list|)
expr_stmt|;
name|face
operator|->
name|sbit_table_size
operator|=
literal|0
expr_stmt|;
name|face
operator|->
name|sbit_table_type
operator|=
name|TT_SBIT_TABLE_TYPE_NONE
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_block
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|tt_face_free_sbit
name|tt_face_free_sbit
argument_list|(
argument|TT_Face  face
argument_list|)
end_macro
begin_block
block|{
name|FT_Stream
name|stream
init|=
name|face
operator|->
name|root
operator|.
name|stream
decl_stmt|;
name|FT_FRAME_RELEASE
argument_list|(
name|face
operator|->
name|sbit_table
argument_list|)
expr_stmt|;
name|face
operator|->
name|sbit_table_size
operator|=
literal|0
expr_stmt|;
name|face
operator|->
name|sbit_table_type
operator|=
name|TT_SBIT_TABLE_TYPE_NONE
expr_stmt|;
name|face
operator|->
name|sbit_num_strikes
operator|=
literal|0
expr_stmt|;
block|}
end_block
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|tt_face_set_sbit_strike
argument_list|(
argument|TT_Face          face
argument_list|,
argument|FT_Size_Request  req
argument_list|,
argument|FT_ULong*        astrike_index
argument_list|)
end_macro
begin_block
block|{
return|return
name|FT_Match_Size
argument_list|(
operator|(
name|FT_Face
operator|)
name|face
argument_list|,
name|req
argument_list|,
literal|0
argument_list|,
name|astrike_index
argument_list|)
return|;
block|}
end_block
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|tt_face_load_strike_metrics
argument_list|(
argument|TT_Face           face
argument_list|,
argument|FT_ULong          strike_index
argument_list|,
argument|FT_Size_Metrics*  metrics
argument_list|)
end_macro
begin_block
block|{
if|if
condition|(
name|strike_index
operator|>=
operator|(
name|FT_ULong
operator|)
name|face
operator|->
name|sbit_num_strikes
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_Argument
argument_list|)
return|;
switch|switch
condition|(
operator|(
name|FT_UInt
operator|)
name|face
operator|->
name|sbit_table_type
condition|)
block|{
case|case
name|TT_SBIT_TABLE_TYPE_EBLC
case|:
case|case
name|TT_SBIT_TABLE_TYPE_CBLC
case|:
block|{
name|FT_Byte
modifier|*
name|strike
decl_stmt|;
name|strike
operator|=
name|face
operator|->
name|sbit_table
operator|+
literal|8
operator|+
name|strike_index
operator|*
literal|48
expr_stmt|;
name|metrics
operator|->
name|x_ppem
operator|=
operator|(
name|FT_UShort
operator|)
name|strike
index|[
literal|44
index|]
expr_stmt|;
name|metrics
operator|->
name|y_ppem
operator|=
operator|(
name|FT_UShort
operator|)
name|strike
index|[
literal|45
index|]
expr_stmt|;
name|metrics
operator|->
name|ascender
operator|=
operator|(
name|FT_Char
operator|)
name|strike
index|[
literal|16
index|]
operator|<<
literal|6
expr_stmt|;
comment|/* hori.ascender  */
name|metrics
operator|->
name|descender
operator|=
operator|(
name|FT_Char
operator|)
name|strike
index|[
literal|17
index|]
operator|<<
literal|6
expr_stmt|;
comment|/* hori.descender */
name|metrics
operator|->
name|height
operator|=
name|metrics
operator|->
name|ascender
operator|-
name|metrics
operator|->
name|descender
expr_stmt|;
comment|/* Is this correct? */
name|metrics
operator|->
name|max_advance
operator|=
operator|(
operator|(
name|FT_Char
operator|)
name|strike
index|[
literal|22
index|]
operator|+
comment|/* min_origin_SB  */
name|strike
index|[
literal|18
index|]
operator|+
comment|/* max_width      */
operator|(
name|FT_Char
operator|)
name|strike
index|[
literal|23
index|]
comment|/* min_advance_SB */
operator|)
operator|<<
literal|6
expr_stmt|;
return|return
name|FT_Err_Ok
return|;
block|}
case|case
name|TT_SBIT_TABLE_TYPE_SBIX
case|:
block|{
name|FT_Stream
name|stream
init|=
name|face
operator|->
name|root
operator|.
name|stream
decl_stmt|;
name|FT_UInt
name|offset
decl_stmt|,
name|upem
decl_stmt|;
name|FT_UShort
name|ppem
decl_stmt|,
name|resolution
decl_stmt|;
name|TT_HoriHeader
modifier|*
name|hori
decl_stmt|;
name|FT_ULong
name|table_size
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|FT_Byte
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|face
operator|->
name|sbit_table
operator|+
literal|8
operator|+
literal|4
operator|*
name|strike_index
expr_stmt|;
name|offset
operator|=
name|FT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|error
operator|=
name|face
operator|->
name|goto_table
argument_list|(
name|face
argument_list|,
name|TTAG_sbix
argument_list|,
name|stream
argument_list|,
operator|&
name|table_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
name|offset
operator|+
literal|4
operator|>
name|table_size
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_File_Format
argument_list|)
return|;
if|if
condition|(
name|FT_STREAM_SEEK
argument_list|(
name|FT_STREAM_POS
argument_list|()
operator|+
name|offset
argument_list|)
operator|||
name|FT_FRAME_ENTER
argument_list|(
literal|4
argument_list|)
condition|)
return|return
name|error
return|;
name|ppem
operator|=
name|FT_GET_USHORT
argument_list|()
expr_stmt|;
name|resolution
operator|=
name|FT_GET_USHORT
argument_list|()
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|resolution
argument_list|)
expr_stmt|;
comment|/* What to do with this? */
name|FT_FRAME_EXIT
argument_list|()
expr_stmt|;
name|upem
operator|=
name|face
operator|->
name|header
operator|.
name|Units_Per_EM
expr_stmt|;
name|hori
operator|=
operator|&
name|face
operator|->
name|horizontal
expr_stmt|;
name|metrics
operator|->
name|x_ppem
operator|=
name|ppem
expr_stmt|;
name|metrics
operator|->
name|y_ppem
operator|=
name|ppem
expr_stmt|;
name|metrics
operator|->
name|ascender
operator|=
name|ppem
operator|*
name|hori
operator|->
name|Ascender
operator|*
literal|64
operator|/
name|upem
expr_stmt|;
name|metrics
operator|->
name|descender
operator|=
name|ppem
operator|*
name|hori
operator|->
name|Descender
operator|*
literal|64
operator|/
name|upem
expr_stmt|;
name|metrics
operator|->
name|height
operator|=
name|ppem
operator|*
operator|(
name|hori
operator|->
name|Ascender
operator|-
name|hori
operator|->
name|Descender
operator|+
name|hori
operator|->
name|Line_Gap
operator|)
operator|*
literal|64
operator|/
name|upem
expr_stmt|;
name|metrics
operator|->
name|max_advance
operator|=
name|ppem
operator|*
name|hori
operator|->
name|advance_Width_Max
operator|*
literal|64
operator|/
name|upem
expr_stmt|;
return|return
name|error
return|;
block|}
default|default:
return|return
name|FT_THROW
argument_list|(
name|Unknown_File_Format
argument_list|)
return|;
block|}
block|}
end_block
begin_typedef
DECL|struct|TT_SBitDecoderRec_
typedef|typedef
struct|struct
name|TT_SBitDecoderRec_
block|{
DECL|member|face
name|TT_Face
name|face
decl_stmt|;
DECL|member|stream
name|FT_Stream
name|stream
decl_stmt|;
DECL|member|bitmap
name|FT_Bitmap
modifier|*
name|bitmap
decl_stmt|;
DECL|member|metrics
name|TT_SBit_Metrics
name|metrics
decl_stmt|;
DECL|member|metrics_loaded
name|FT_Bool
name|metrics_loaded
decl_stmt|;
DECL|member|bitmap_allocated
name|FT_Bool
name|bitmap_allocated
decl_stmt|;
DECL|member|bit_depth
name|FT_Byte
name|bit_depth
decl_stmt|;
DECL|member|ebdt_start
name|FT_ULong
name|ebdt_start
decl_stmt|;
DECL|member|ebdt_size
name|FT_ULong
name|ebdt_size
decl_stmt|;
DECL|member|strike_index_array
name|FT_ULong
name|strike_index_array
decl_stmt|;
DECL|member|strike_index_count
name|FT_ULong
name|strike_index_count
decl_stmt|;
DECL|member|eblc_base
name|FT_Byte
modifier|*
name|eblc_base
decl_stmt|;
DECL|member|eblc_limit
name|FT_Byte
modifier|*
name|eblc_limit
decl_stmt|;
block|}
DECL|typedef|TT_SBitDecoderRec
DECL|typedef|TT_SBitDecoder
name|TT_SBitDecoderRec
operator|,
typedef|*
name|TT_SBitDecoder
typedef|;
end_typedef
begin_function
specifier|static
name|FT_Error
DECL|function|tt_sbit_decoder_init
name|tt_sbit_decoder_init
parameter_list|(
name|TT_SBitDecoder
name|decoder
parameter_list|,
name|TT_Face
name|face
parameter_list|,
name|FT_ULong
name|strike_index
parameter_list|,
name|TT_SBit_MetricsRec
modifier|*
name|metrics
parameter_list|)
block|{
name|FT_Error
name|error
decl_stmt|;
name|FT_Stream
name|stream
init|=
name|face
operator|->
name|root
operator|.
name|stream
decl_stmt|;
name|FT_ULong
name|ebdt_size
decl_stmt|;
name|error
operator|=
name|face
operator|->
name|goto_table
argument_list|(
name|face
argument_list|,
name|TTAG_CBDT
argument_list|,
name|stream
argument_list|,
operator|&
name|ebdt_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|error
operator|=
name|face
operator|->
name|goto_table
argument_list|(
name|face
argument_list|,
name|TTAG_EBDT
argument_list|,
name|stream
argument_list|,
operator|&
name|ebdt_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|error
operator|=
name|face
operator|->
name|goto_table
argument_list|(
name|face
argument_list|,
name|TTAG_bdat
argument_list|,
name|stream
argument_list|,
operator|&
name|ebdt_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|decoder
operator|->
name|face
operator|=
name|face
expr_stmt|;
name|decoder
operator|->
name|stream
operator|=
name|stream
expr_stmt|;
name|decoder
operator|->
name|bitmap
operator|=
operator|&
name|face
operator|->
name|root
operator|.
name|glyph
operator|->
name|bitmap
expr_stmt|;
name|decoder
operator|->
name|metrics
operator|=
name|metrics
expr_stmt|;
name|decoder
operator|->
name|metrics_loaded
operator|=
literal|0
expr_stmt|;
name|decoder
operator|->
name|bitmap_allocated
operator|=
literal|0
expr_stmt|;
name|decoder
operator|->
name|ebdt_start
operator|=
name|FT_STREAM_POS
argument_list|()
expr_stmt|;
name|decoder
operator|->
name|ebdt_size
operator|=
name|ebdt_size
expr_stmt|;
name|decoder
operator|->
name|eblc_base
operator|=
name|face
operator|->
name|sbit_table
expr_stmt|;
name|decoder
operator|->
name|eblc_limit
operator|=
name|face
operator|->
name|sbit_table
operator|+
name|face
operator|->
name|sbit_table_size
expr_stmt|;
comment|/* now find the strike corresponding to the index */
block|{
name|FT_Byte
modifier|*
name|p
decl_stmt|;
if|if
condition|(
literal|8
operator|+
literal|48
operator|*
name|strike_index
operator|+
literal|3
operator|*
literal|4
operator|+
literal|34
operator|+
literal|1
operator|>
name|face
operator|->
name|sbit_table_size
condition|)
block|{
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_File_Format
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|p
operator|=
name|decoder
operator|->
name|eblc_base
operator|+
literal|8
operator|+
literal|48
operator|*
name|strike_index
expr_stmt|;
name|decoder
operator|->
name|strike_index_array
operator|=
name|FT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|decoder
operator|->
name|strike_index_count
operator|=
name|FT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|34
expr_stmt|;
name|decoder
operator|->
name|bit_depth
operator|=
operator|*
name|p
expr_stmt|;
comment|/* decoder->strike_index_array +                               */
comment|/*   8 * decoder->strike_index_count> face->sbit_table_size ? */
if|if
condition|(
name|decoder
operator|->
name|strike_index_array
operator|>
name|face
operator|->
name|sbit_table_size
operator|||
name|decoder
operator|->
name|strike_index_count
operator|>
operator|(
name|face
operator|->
name|sbit_table_size
operator|-
name|decoder
operator|->
name|strike_index_array
operator|)
operator|/
literal|8
condition|)
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_File_Format
argument_list|)
expr_stmt|;
block|}
name|Exit
label|:
return|return
name|error
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|tt_sbit_decoder_done
name|tt_sbit_decoder_done
parameter_list|(
name|TT_SBitDecoder
name|decoder
parameter_list|)
block|{
name|FT_UNUSED
argument_list|(
name|decoder
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|tt_sbit_decoder_alloc_bitmap
name|tt_sbit_decoder_alloc_bitmap
parameter_list|(
name|TT_SBitDecoder
name|decoder
parameter_list|)
block|{
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
name|FT_UInt
name|width
decl_stmt|,
name|height
decl_stmt|;
name|FT_Bitmap
modifier|*
name|map
init|=
name|decoder
operator|->
name|bitmap
decl_stmt|;
name|FT_Long
name|size
decl_stmt|;
if|if
condition|(
operator|!
name|decoder
operator|->
name|metrics_loaded
condition|)
block|{
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Argument
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|width
operator|=
name|decoder
operator|->
name|metrics
operator|->
name|width
expr_stmt|;
name|height
operator|=
name|decoder
operator|->
name|metrics
operator|->
name|height
expr_stmt|;
name|map
operator|->
name|width
operator|=
operator|(
name|int
operator|)
name|width
expr_stmt|;
name|map
operator|->
name|rows
operator|=
operator|(
name|int
operator|)
name|height
expr_stmt|;
switch|switch
condition|(
name|decoder
operator|->
name|bit_depth
condition|)
block|{
case|case
literal|1
case|:
name|map
operator|->
name|pixel_mode
operator|=
name|FT_PIXEL_MODE_MONO
expr_stmt|;
name|map
operator|->
name|pitch
operator|=
operator|(
name|map
operator|->
name|width
operator|+
literal|7
operator|)
operator|>>
literal|3
expr_stmt|;
name|map
operator|->
name|num_grays
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|map
operator|->
name|pixel_mode
operator|=
name|FT_PIXEL_MODE_GRAY2
expr_stmt|;
name|map
operator|->
name|pitch
operator|=
operator|(
name|map
operator|->
name|width
operator|+
literal|3
operator|)
operator|>>
literal|2
expr_stmt|;
name|map
operator|->
name|num_grays
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|map
operator|->
name|pixel_mode
operator|=
name|FT_PIXEL_MODE_GRAY4
expr_stmt|;
name|map
operator|->
name|pitch
operator|=
operator|(
name|map
operator|->
name|width
operator|+
literal|1
operator|)
operator|>>
literal|1
expr_stmt|;
name|map
operator|->
name|num_grays
operator|=
literal|16
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|map
operator|->
name|pixel_mode
operator|=
name|FT_PIXEL_MODE_GRAY
expr_stmt|;
name|map
operator|->
name|pitch
operator|=
name|map
operator|->
name|width
expr_stmt|;
name|map
operator|->
name|num_grays
operator|=
literal|256
expr_stmt|;
break|break;
case|case
literal|32
case|:
name|map
operator|->
name|pixel_mode
operator|=
name|FT_PIXEL_MODE_BGRA
expr_stmt|;
name|map
operator|->
name|pitch
operator|=
name|map
operator|->
name|width
operator|*
literal|4
expr_stmt|;
name|map
operator|->
name|num_grays
operator|=
literal|256
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_File_Format
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|size
operator|=
name|map
operator|->
name|rows
operator|*
name|map
operator|->
name|pitch
expr_stmt|;
comment|/* check that there is no empty image */
if|if
condition|(
name|size
operator|==
literal|0
condition|)
goto|goto
name|Exit
goto|;
comment|/* exit successfully! */
name|error
operator|=
name|ft_glyphslot_alloc_bitmap
argument_list|(
name|decoder
operator|->
name|face
operator|->
name|root
operator|.
name|glyph
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|decoder
operator|->
name|bitmap_allocated
operator|=
literal|1
expr_stmt|;
name|Exit
label|:
return|return
name|error
return|;
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|tt_sbit_decoder_load_metrics
name|tt_sbit_decoder_load_metrics
parameter_list|(
name|TT_SBitDecoder
name|decoder
parameter_list|,
name|FT_Byte
modifier|*
modifier|*
name|pp
parameter_list|,
name|FT_Byte
modifier|*
name|limit
parameter_list|,
name|FT_Bool
name|big
parameter_list|)
block|{
name|FT_Byte
modifier|*
name|p
init|=
operator|*
name|pp
decl_stmt|;
name|TT_SBit_Metrics
name|metrics
init|=
name|decoder
operator|->
name|metrics
decl_stmt|;
if|if
condition|(
name|p
operator|+
literal|5
operator|>
name|limit
condition|)
goto|goto
name|Fail
goto|;
name|metrics
operator|->
name|height
operator|=
name|p
index|[
literal|0
index|]
expr_stmt|;
name|metrics
operator|->
name|width
operator|=
name|p
index|[
literal|1
index|]
expr_stmt|;
name|metrics
operator|->
name|horiBearingX
operator|=
operator|(
name|FT_Char
operator|)
name|p
index|[
literal|2
index|]
expr_stmt|;
name|metrics
operator|->
name|horiBearingY
operator|=
operator|(
name|FT_Char
operator|)
name|p
index|[
literal|3
index|]
expr_stmt|;
name|metrics
operator|->
name|horiAdvance
operator|=
name|p
index|[
literal|4
index|]
expr_stmt|;
name|p
operator|+=
literal|5
expr_stmt|;
if|if
condition|(
name|big
condition|)
block|{
if|if
condition|(
name|p
operator|+
literal|3
operator|>
name|limit
condition|)
goto|goto
name|Fail
goto|;
name|metrics
operator|->
name|vertBearingX
operator|=
operator|(
name|FT_Char
operator|)
name|p
index|[
literal|0
index|]
expr_stmt|;
name|metrics
operator|->
name|vertBearingY
operator|=
operator|(
name|FT_Char
operator|)
name|p
index|[
literal|1
index|]
expr_stmt|;
name|metrics
operator|->
name|vertAdvance
operator|=
name|p
index|[
literal|2
index|]
expr_stmt|;
name|p
operator|+=
literal|3
expr_stmt|;
block|}
else|else
block|{
comment|/* avoid uninitialized data in case there is no vertical info -- */
name|metrics
operator|->
name|vertBearingX
operator|=
literal|0
expr_stmt|;
name|metrics
operator|->
name|vertBearingY
operator|=
literal|0
expr_stmt|;
name|metrics
operator|->
name|vertAdvance
operator|=
literal|0
expr_stmt|;
block|}
name|decoder
operator|->
name|metrics_loaded
operator|=
literal|1
expr_stmt|;
operator|*
name|pp
operator|=
name|p
expr_stmt|;
return|return
name|FT_Err_Ok
return|;
name|Fail
label|:
name|FT_TRACE1
argument_list|(
operator|(
literal|"tt_sbit_decoder_load_metrics: broken table\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|FT_THROW
argument_list|(
name|Invalid_Argument
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/* forward declaration */
end_comment
begin_function_decl
specifier|static
name|FT_Error
name|tt_sbit_decoder_load_image
parameter_list|(
name|TT_SBitDecoder
name|decoder
parameter_list|,
name|FT_UInt
name|glyph_index
parameter_list|,
name|FT_Int
name|x_pos
parameter_list|,
name|FT_Int
name|y_pos
parameter_list|)
function_decl|;
end_function_decl
begin_typedef
DECL|typedef|TT_SBitDecoder_LoadFunc
typedef|typedef
name|FT_Error
function_decl|(
modifier|*
name|TT_SBitDecoder_LoadFunc
function_decl|)
parameter_list|(
name|TT_SBitDecoder
name|decoder
parameter_list|,
name|FT_Byte
modifier|*
name|p
parameter_list|,
name|FT_Byte
modifier|*
name|plimit
parameter_list|,
name|FT_Int
name|x_pos
parameter_list|,
name|FT_Int
name|y_pos
parameter_list|)
function_decl|;
end_typedef
begin_function
specifier|static
name|FT_Error
DECL|function|tt_sbit_decoder_load_byte_aligned
name|tt_sbit_decoder_load_byte_aligned
parameter_list|(
name|TT_SBitDecoder
name|decoder
parameter_list|,
name|FT_Byte
modifier|*
name|p
parameter_list|,
name|FT_Byte
modifier|*
name|limit
parameter_list|,
name|FT_Int
name|x_pos
parameter_list|,
name|FT_Int
name|y_pos
parameter_list|)
block|{
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
name|FT_Byte
modifier|*
name|line
decl_stmt|;
name|FT_Int
name|bit_height
decl_stmt|,
name|bit_width
decl_stmt|,
name|pitch
decl_stmt|,
name|width
decl_stmt|,
name|height
decl_stmt|,
name|line_bits
decl_stmt|,
name|h
decl_stmt|;
name|FT_Bitmap
modifier|*
name|bitmap
decl_stmt|;
comment|/* check that we can write the glyph into the bitmap */
name|bitmap
operator|=
name|decoder
operator|->
name|bitmap
expr_stmt|;
name|bit_width
operator|=
name|bitmap
operator|->
name|width
expr_stmt|;
name|bit_height
operator|=
name|bitmap
operator|->
name|rows
expr_stmt|;
name|pitch
operator|=
name|bitmap
operator|->
name|pitch
expr_stmt|;
name|line
operator|=
name|bitmap
operator|->
name|buffer
expr_stmt|;
name|width
operator|=
name|decoder
operator|->
name|metrics
operator|->
name|width
expr_stmt|;
name|height
operator|=
name|decoder
operator|->
name|metrics
operator|->
name|height
expr_stmt|;
name|line_bits
operator|=
name|width
operator|*
name|decoder
operator|->
name|bit_depth
expr_stmt|;
if|if
condition|(
name|x_pos
operator|<
literal|0
operator|||
name|x_pos
operator|+
name|width
operator|>
name|bit_width
operator|||
name|y_pos
operator|<
literal|0
operator|||
name|y_pos
operator|+
name|height
operator|>
name|bit_height
condition|)
block|{
name|FT_TRACE1
argument_list|(
operator|(
literal|"tt_sbit_decoder_load_byte_aligned:"
literal|" invalid bitmap dimensions\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_File_Format
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|p
operator|+
operator|(
operator|(
name|line_bits
operator|+
literal|7
operator|)
operator|>>
literal|3
operator|)
operator|*
name|height
operator|>
name|limit
condition|)
block|{
name|FT_TRACE1
argument_list|(
operator|(
literal|"tt_sbit_decoder_load_byte_aligned: broken bitmap\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_File_Format
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* now do the blit */
name|line
operator|+=
name|y_pos
operator|*
name|pitch
operator|+
operator|(
name|x_pos
operator|>>
literal|3
operator|)
expr_stmt|;
name|x_pos
operator|&=
literal|7
expr_stmt|;
if|if
condition|(
name|x_pos
operator|==
literal|0
condition|)
comment|/* the easy one */
block|{
for|for
control|(
name|h
operator|=
name|height
init|;
name|h
operator|>
literal|0
condition|;
name|h
operator|--
operator|,
name|line
operator|+=
name|pitch
control|)
block|{
name|FT_Byte
modifier|*
name|pwrite
init|=
name|line
decl_stmt|;
name|FT_Int
name|w
decl_stmt|;
for|for
control|(
name|w
operator|=
name|line_bits
init|;
name|w
operator|>=
literal|8
condition|;
name|w
operator|-=
literal|8
control|)
block|{
name|pwrite
index|[
literal|0
index|]
operator|=
call|(
name|FT_Byte
call|)
argument_list|(
name|pwrite
index|[
literal|0
index|]
operator||
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
name|pwrite
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|w
operator|>
literal|0
condition|)
name|pwrite
index|[
literal|0
index|]
operator|=
call|(
name|FT_Byte
call|)
argument_list|(
name|pwrite
index|[
literal|0
index|]
operator||
operator|(
operator|*
name|p
operator|++
operator|&
operator|(
literal|0xFF00U
operator|>>
name|w
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
comment|/* x_pos> 0 */
block|{
for|for
control|(
name|h
operator|=
name|height
init|;
name|h
operator|>
literal|0
condition|;
name|h
operator|--
operator|,
name|line
operator|+=
name|pitch
control|)
block|{
name|FT_Byte
modifier|*
name|pwrite
init|=
name|line
decl_stmt|;
name|FT_Int
name|w
decl_stmt|;
name|FT_UInt
name|wval
init|=
literal|0
decl_stmt|;
for|for
control|(
name|w
operator|=
name|line_bits
init|;
name|w
operator|>=
literal|8
condition|;
name|w
operator|-=
literal|8
control|)
block|{
name|wval
operator|=
call|(
name|FT_UInt
call|)
argument_list|(
name|wval
operator||
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
name|pwrite
index|[
literal|0
index|]
operator|=
call|(
name|FT_Byte
call|)
argument_list|(
name|pwrite
index|[
literal|0
index|]
operator||
operator|(
name|wval
operator|>>
name|x_pos
operator|)
argument_list|)
expr_stmt|;
name|pwrite
operator|+=
literal|1
expr_stmt|;
name|wval
operator|<<=
literal|8
expr_stmt|;
block|}
if|if
condition|(
name|w
operator|>
literal|0
condition|)
name|wval
operator|=
call|(
name|FT_UInt
call|)
argument_list|(
name|wval
operator||
operator|(
operator|*
name|p
operator|++
operator|&
operator|(
literal|0xFF00U
operator|>>
name|w
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* all bits read and there are `x_pos + w' bits to be written */
name|pwrite
index|[
literal|0
index|]
operator|=
call|(
name|FT_Byte
call|)
argument_list|(
name|pwrite
index|[
literal|0
index|]
operator||
operator|(
name|wval
operator|>>
name|x_pos
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|x_pos
operator|+
name|w
operator|>
literal|8
condition|)
block|{
name|pwrite
operator|++
expr_stmt|;
name|wval
operator|<<=
literal|8
expr_stmt|;
name|pwrite
index|[
literal|0
index|]
operator|=
call|(
name|FT_Byte
call|)
argument_list|(
name|pwrite
index|[
literal|0
index|]
operator||
operator|(
name|wval
operator|>>
name|x_pos
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|Exit
label|:
if|if
condition|(
operator|!
name|error
condition|)
name|FT_TRACE3
argument_list|(
operator|(
literal|"tt_sbit_decoder_load_byte_aligned: loaded\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_comment
comment|/*    * Load a bit-aligned bitmap (with pointer `p') into a line-aligned bitmap    * (with pointer `pwrite').  In the example below, the width is 3 pixel,    * and `x_pos' is 1 pixel.    *    *       p                               p+1    *     |                               |                               |    *     | 7   6   5   4   3   2   1   0 | 7   6   5   4   3   2   1   0 |...    *     |                               |                               |    *       +-------+   +-------+   +-------+ ...    *           .           .           .    *           .           .           .    *           v           .           .    *       +-------+       .           .    * |                               | .    * | 7   6   5   4   3   2   1   0 | .    * |                               | .    *   pwrite              .           .    *                       .           .    *                       v           .    *                   +-------+       .    *             |                               |    *             | 7   6   5   4   3   2   1   0 |    *             |                               |    *               pwrite+1            .    *                                   .    *                                   v    *                               +-------+    *                         |                               |    *                         | 7   6   5   4   3   2   1   0 |    *                         |                               |    *                           pwrite+2    *    */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|tt_sbit_decoder_load_bit_aligned
name|tt_sbit_decoder_load_bit_aligned
parameter_list|(
name|TT_SBitDecoder
name|decoder
parameter_list|,
name|FT_Byte
modifier|*
name|p
parameter_list|,
name|FT_Byte
modifier|*
name|limit
parameter_list|,
name|FT_Int
name|x_pos
parameter_list|,
name|FT_Int
name|y_pos
parameter_list|)
block|{
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
name|FT_Byte
modifier|*
name|line
decl_stmt|;
name|FT_Int
name|bit_height
decl_stmt|,
name|bit_width
decl_stmt|,
name|pitch
decl_stmt|,
name|width
decl_stmt|,
name|height
decl_stmt|,
name|line_bits
decl_stmt|,
name|h
decl_stmt|,
name|nbits
decl_stmt|;
name|FT_Bitmap
modifier|*
name|bitmap
decl_stmt|;
name|FT_UShort
name|rval
decl_stmt|;
comment|/* check that we can write the glyph into the bitmap */
name|bitmap
operator|=
name|decoder
operator|->
name|bitmap
expr_stmt|;
name|bit_width
operator|=
name|bitmap
operator|->
name|width
expr_stmt|;
name|bit_height
operator|=
name|bitmap
operator|->
name|rows
expr_stmt|;
name|pitch
operator|=
name|bitmap
operator|->
name|pitch
expr_stmt|;
name|line
operator|=
name|bitmap
operator|->
name|buffer
expr_stmt|;
name|width
operator|=
name|decoder
operator|->
name|metrics
operator|->
name|width
expr_stmt|;
name|height
operator|=
name|decoder
operator|->
name|metrics
operator|->
name|height
expr_stmt|;
name|line_bits
operator|=
name|width
operator|*
name|decoder
operator|->
name|bit_depth
expr_stmt|;
if|if
condition|(
name|x_pos
operator|<
literal|0
operator|||
name|x_pos
operator|+
name|width
operator|>
name|bit_width
operator|||
name|y_pos
operator|<
literal|0
operator|||
name|y_pos
operator|+
name|height
operator|>
name|bit_height
condition|)
block|{
name|FT_TRACE1
argument_list|(
operator|(
literal|"tt_sbit_decoder_load_bit_aligned:"
literal|" invalid bitmap dimensions\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_File_Format
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|p
operator|+
operator|(
operator|(
name|line_bits
operator|*
name|height
operator|+
literal|7
operator|)
operator|>>
literal|3
operator|)
operator|>
name|limit
condition|)
block|{
name|FT_TRACE1
argument_list|(
operator|(
literal|"tt_sbit_decoder_load_bit_aligned: broken bitmap\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_File_Format
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* now do the blit */
comment|/* adjust `line' to point to the first byte of the bitmap */
name|line
operator|+=
name|y_pos
operator|*
name|pitch
operator|+
operator|(
name|x_pos
operator|>>
literal|3
operator|)
expr_stmt|;
name|x_pos
operator|&=
literal|7
expr_stmt|;
comment|/* the higher byte of `rval' is used as a buffer */
name|rval
operator|=
literal|0
expr_stmt|;
name|nbits
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|h
operator|=
name|height
init|;
name|h
operator|>
literal|0
condition|;
name|h
operator|--
operator|,
name|line
operator|+=
name|pitch
control|)
block|{
name|FT_Byte
modifier|*
name|pwrite
init|=
name|line
decl_stmt|;
name|FT_Int
name|w
init|=
name|line_bits
decl_stmt|;
comment|/* handle initial byte (in target bitmap) specially if necessary */
if|if
condition|(
name|x_pos
condition|)
block|{
name|w
operator|=
operator|(
name|line_bits
operator|<
literal|8
operator|-
name|x_pos
operator|)
condition|?
name|line_bits
else|:
literal|8
operator|-
name|x_pos
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|height
condition|)
block|{
name|rval
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|nbits
operator|=
name|x_pos
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nbits
operator|<
name|w
condition|)
block|{
if|if
condition|(
name|p
operator|<
name|limit
condition|)
name|rval
operator||=
operator|*
name|p
operator|++
expr_stmt|;
name|nbits
operator|+=
literal|8
operator|-
name|w
expr_stmt|;
block|}
else|else
block|{
name|rval
operator|>>=
literal|8
expr_stmt|;
name|nbits
operator|-=
name|w
expr_stmt|;
block|}
operator|*
name|pwrite
operator|++
operator||=
operator|(
operator|(
name|rval
operator|>>
name|nbits
operator|)
operator|&
literal|0xFF
operator|)
operator|&
operator|(
operator|~
operator|(
literal|0xFF
operator|<<
name|w
operator|)
operator|<<
operator|(
literal|8
operator|-
name|w
operator|-
name|x_pos
operator|)
operator|)
expr_stmt|;
name|rval
operator|<<=
literal|8
expr_stmt|;
name|w
operator|=
name|line_bits
operator|-
name|w
expr_stmt|;
block|}
comment|/* handle medial bytes */
for|for
control|(
init|;
name|w
operator|>=
literal|8
condition|;
name|w
operator|-=
literal|8
control|)
block|{
name|rval
operator||=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|pwrite
operator|++
operator||=
operator|(
name|rval
operator|>>
name|nbits
operator|)
operator|&
literal|0xFF
expr_stmt|;
name|rval
operator|<<=
literal|8
expr_stmt|;
block|}
comment|/* handle final byte if necessary */
if|if
condition|(
name|w
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|nbits
operator|<
name|w
condition|)
block|{
if|if
condition|(
name|p
operator|<
name|limit
condition|)
name|rval
operator||=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|pwrite
operator||=
operator|(
operator|(
name|rval
operator|>>
name|nbits
operator|)
operator|&
literal|0xFF
operator|)
operator|&
operator|(
literal|0xFF00U
operator|>>
name|w
operator|)
expr_stmt|;
name|nbits
operator|+=
literal|8
operator|-
name|w
expr_stmt|;
name|rval
operator|<<=
literal|8
expr_stmt|;
block|}
else|else
block|{
operator|*
name|pwrite
operator||=
operator|(
operator|(
name|rval
operator|>>
name|nbits
operator|)
operator|&
literal|0xFF
operator|)
operator|&
operator|(
literal|0xFF00U
operator|>>
name|w
operator|)
expr_stmt|;
name|nbits
operator|-=
name|w
expr_stmt|;
block|}
block|}
block|}
name|Exit
label|:
if|if
condition|(
operator|!
name|error
condition|)
name|FT_TRACE3
argument_list|(
operator|(
literal|"tt_sbit_decoder_load_bit_aligned: loaded\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|tt_sbit_decoder_load_compound
name|tt_sbit_decoder_load_compound
parameter_list|(
name|TT_SBitDecoder
name|decoder
parameter_list|,
name|FT_Byte
modifier|*
name|p
parameter_list|,
name|FT_Byte
modifier|*
name|limit
parameter_list|,
name|FT_Int
name|x_pos
parameter_list|,
name|FT_Int
name|y_pos
parameter_list|)
block|{
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
name|FT_UInt
name|num_components
decl_stmt|,
name|nn
decl_stmt|;
name|FT_Char
name|horiBearingX
init|=
operator|(
name|FT_Char
operator|)
name|decoder
operator|->
name|metrics
operator|->
name|horiBearingX
decl_stmt|;
name|FT_Char
name|horiBearingY
init|=
operator|(
name|FT_Char
operator|)
name|decoder
operator|->
name|metrics
operator|->
name|horiBearingY
decl_stmt|;
name|FT_Byte
name|horiAdvance
init|=
operator|(
name|FT_Byte
operator|)
name|decoder
operator|->
name|metrics
operator|->
name|horiAdvance
decl_stmt|;
name|FT_Char
name|vertBearingX
init|=
operator|(
name|FT_Char
operator|)
name|decoder
operator|->
name|metrics
operator|->
name|vertBearingX
decl_stmt|;
name|FT_Char
name|vertBearingY
init|=
operator|(
name|FT_Char
operator|)
name|decoder
operator|->
name|metrics
operator|->
name|vertBearingY
decl_stmt|;
name|FT_Byte
name|vertAdvance
init|=
operator|(
name|FT_Byte
operator|)
name|decoder
operator|->
name|metrics
operator|->
name|vertAdvance
decl_stmt|;
if|if
condition|(
name|p
operator|+
literal|2
operator|>
name|limit
condition|)
goto|goto
name|Fail
goto|;
name|num_components
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|+
literal|4
operator|*
name|num_components
operator|>
name|limit
condition|)
block|{
name|FT_TRACE1
argument_list|(
operator|(
literal|"tt_sbit_decoder_load_compound: broken table\n"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|Fail
goto|;
block|}
name|FT_TRACE3
argument_list|(
operator|(
literal|"tt_sbit_decoder_load_compound: loading %d components\n"
operator|,
name|num_components
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|nn
operator|=
literal|0
init|;
name|nn
operator|<
name|num_components
condition|;
name|nn
operator|++
control|)
block|{
name|FT_UInt
name|gindex
init|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|FT_Byte
name|dx
init|=
name|FT_NEXT_BYTE
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|FT_Byte
name|dy
init|=
name|FT_NEXT_BYTE
argument_list|(
name|p
argument_list|)
decl_stmt|;
comment|/* NB: a recursive call */
name|error
operator|=
name|tt_sbit_decoder_load_image
argument_list|(
name|decoder
argument_list|,
name|gindex
argument_list|,
name|x_pos
operator|+
name|dx
argument_list|,
name|y_pos
operator|+
name|dy
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
name|FT_TRACE3
argument_list|(
operator|(
literal|"tt_sbit_decoder_load_compound: done\n"
operator|)
argument_list|)
expr_stmt|;
name|decoder
operator|->
name|metrics
operator|->
name|horiBearingX
operator|=
name|horiBearingX
expr_stmt|;
name|decoder
operator|->
name|metrics
operator|->
name|horiBearingY
operator|=
name|horiBearingY
expr_stmt|;
name|decoder
operator|->
name|metrics
operator|->
name|horiAdvance
operator|=
name|horiAdvance
expr_stmt|;
name|decoder
operator|->
name|metrics
operator|->
name|vertBearingX
operator|=
name|vertBearingX
expr_stmt|;
name|decoder
operator|->
name|metrics
operator|->
name|vertBearingY
operator|=
name|vertBearingY
expr_stmt|;
name|decoder
operator|->
name|metrics
operator|->
name|vertAdvance
operator|=
name|vertAdvance
expr_stmt|;
name|decoder
operator|->
name|metrics
operator|->
name|width
operator|=
operator|(
name|FT_Byte
operator|)
name|decoder
operator|->
name|bitmap
operator|->
name|width
expr_stmt|;
name|decoder
operator|->
name|metrics
operator|->
name|height
operator|=
operator|(
name|FT_Byte
operator|)
name|decoder
operator|->
name|bitmap
operator|->
name|rows
expr_stmt|;
name|Exit
label|:
return|return
name|error
return|;
name|Fail
label|:
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_File_Format
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|FT_CONFIG_OPTION_USE_PNG
end_ifdef
begin_function
specifier|static
name|FT_Error
DECL|function|tt_sbit_decoder_load_png
name|tt_sbit_decoder_load_png
parameter_list|(
name|TT_SBitDecoder
name|decoder
parameter_list|,
name|FT_Byte
modifier|*
name|p
parameter_list|,
name|FT_Byte
modifier|*
name|limit
parameter_list|,
name|FT_Int
name|x_pos
parameter_list|,
name|FT_Int
name|y_pos
parameter_list|)
block|{
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
name|FT_ULong
name|png_len
decl_stmt|;
if|if
condition|(
name|limit
operator|-
name|p
operator|<
literal|4
condition|)
block|{
name|FT_TRACE1
argument_list|(
operator|(
literal|"tt_sbit_decoder_load_png: broken bitmap\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_File_Format
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|png_len
operator|=
name|FT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
call|(
name|FT_ULong
call|)
argument_list|(
name|limit
operator|-
name|p
argument_list|)
operator|<
name|png_len
condition|)
block|{
name|FT_TRACE1
argument_list|(
operator|(
literal|"tt_sbit_decoder_load_png: broken bitmap\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_File_Format
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|error
operator|=
name|Load_SBit_Png
argument_list|(
name|decoder
operator|->
name|face
operator|->
name|root
operator|.
name|glyph
argument_list|,
name|x_pos
argument_list|,
name|y_pos
argument_list|,
name|decoder
operator|->
name|bit_depth
argument_list|,
name|decoder
operator|->
name|metrics
argument_list|,
name|decoder
operator|->
name|stream
operator|->
name|memory
argument_list|,
name|p
argument_list|,
name|png_len
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|Exit
label|:
if|if
condition|(
operator|!
name|error
condition|)
name|FT_TRACE3
argument_list|(
operator|(
literal|"tt_sbit_decoder_load_png: loaded\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* FT_CONFIG_OPTION_USE_PNG */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|tt_sbit_decoder_load_bitmap
name|tt_sbit_decoder_load_bitmap
parameter_list|(
name|TT_SBitDecoder
name|decoder
parameter_list|,
name|FT_UInt
name|glyph_format
parameter_list|,
name|FT_ULong
name|glyph_start
parameter_list|,
name|FT_ULong
name|glyph_size
parameter_list|,
name|FT_Int
name|x_pos
parameter_list|,
name|FT_Int
name|y_pos
parameter_list|)
block|{
name|FT_Error
name|error
decl_stmt|;
name|FT_Stream
name|stream
init|=
name|decoder
operator|->
name|stream
decl_stmt|;
name|FT_Byte
modifier|*
name|p
decl_stmt|;
name|FT_Byte
modifier|*
name|p_limit
decl_stmt|;
name|FT_Byte
modifier|*
name|data
decl_stmt|;
comment|/* seek into the EBDT table now */
if|if
condition|(
name|glyph_start
operator|+
name|glyph_size
operator|>
name|decoder
operator|->
name|ebdt_size
condition|)
block|{
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Argument
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|FT_STREAM_SEEK
argument_list|(
name|decoder
operator|->
name|ebdt_start
operator|+
name|glyph_start
argument_list|)
operator|||
name|FT_FRAME_EXTRACT
argument_list|(
name|glyph_size
argument_list|,
name|data
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|p
operator|=
name|data
expr_stmt|;
name|p_limit
operator|=
name|p
operator|+
name|glyph_size
expr_stmt|;
comment|/* read the data, depending on the glyph format */
switch|switch
condition|(
name|glyph_format
condition|)
block|{
case|case
literal|1
case|:
case|case
literal|2
case|:
case|case
literal|8
case|:
case|case
literal|17
case|:
name|error
operator|=
name|tt_sbit_decoder_load_metrics
argument_list|(
name|decoder
argument_list|,
operator|&
name|p
argument_list|,
name|p_limit
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|6
case|:
case|case
literal|7
case|:
case|case
literal|9
case|:
case|case
literal|18
case|:
name|error
operator|=
name|tt_sbit_decoder_load_metrics
argument_list|(
name|decoder
argument_list|,
operator|&
name|p
argument_list|,
name|p_limit
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|FT_Err_Ok
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
goto|goto
name|Fail
goto|;
block|{
name|TT_SBitDecoder_LoadFunc
name|loader
decl_stmt|;
switch|switch
condition|(
name|glyph_format
condition|)
block|{
case|case
literal|1
case|:
case|case
literal|6
case|:
name|loader
operator|=
name|tt_sbit_decoder_load_byte_aligned
expr_stmt|;
break|break;
case|case
literal|2
case|:
case|case
literal|7
case|:
block|{
comment|/* Don't trust `glyph_format'.  For example, Apple's main Korean */
comment|/* system font, `AppleMyungJo.ttf' (version 7.0d2e6), uses glyph */
comment|/* format 7, but the data is format 6.  We check whether we have */
comment|/* an excessive number of bytes in the image: If it is equal to  */
comment|/* the value for a byte-aligned glyph, use the other loading     */
comment|/* routine.                                                      */
comment|/*                                                               */
comment|/* Note that for some (width,height) combinations, where the     */
comment|/* width is not a multiple of 8, the sizes for bit- and          */
comment|/* byte-aligned data are equal, for example (7,7) or (15,6).  We */
comment|/* then prefer what `glyph_format' specifies.                    */
name|FT_UInt
name|width
init|=
name|decoder
operator|->
name|metrics
operator|->
name|width
decl_stmt|;
name|FT_UInt
name|height
init|=
name|decoder
operator|->
name|metrics
operator|->
name|height
decl_stmt|;
name|FT_UInt
name|bit_size
init|=
operator|(
name|width
operator|*
name|height
operator|+
literal|7
operator|)
operator|>>
literal|3
decl_stmt|;
name|FT_UInt
name|byte_size
init|=
name|height
operator|*
operator|(
operator|(
name|width
operator|+
literal|7
operator|)
operator|>>
literal|3
operator|)
decl_stmt|;
if|if
condition|(
name|bit_size
operator|<
name|byte_size
operator|&&
name|byte_size
operator|==
call|(
name|FT_UInt
call|)
argument_list|(
name|p_limit
operator|-
name|p
argument_list|)
condition|)
name|loader
operator|=
name|tt_sbit_decoder_load_byte_aligned
expr_stmt|;
else|else
name|loader
operator|=
name|tt_sbit_decoder_load_bit_aligned
expr_stmt|;
block|}
break|break;
case|case
literal|5
case|:
name|loader
operator|=
name|tt_sbit_decoder_load_bit_aligned
expr_stmt|;
break|break;
case|case
literal|8
case|:
if|if
condition|(
name|p
operator|+
literal|1
operator|>
name|p_limit
condition|)
goto|goto
name|Fail
goto|;
name|p
operator|+=
literal|1
expr_stmt|;
comment|/* skip padding */
comment|/* fall-through */
case|case
literal|9
case|:
name|loader
operator|=
name|tt_sbit_decoder_load_compound
expr_stmt|;
break|break;
case|case
literal|17
case|:
comment|/* small metrics, PNG image data   */
case|case
literal|18
case|:
comment|/* big metrics, PNG image data     */
case|case
literal|19
case|:
comment|/* metrics in EBLC, PNG image data */
ifdef|#
directive|ifdef
name|FT_CONFIG_OPTION_USE_PNG
name|loader
operator|=
name|tt_sbit_decoder_load_png
expr_stmt|;
break|break;
else|#
directive|else
name|error
operator|=
name|FT_THROW
argument_list|(
name|Unimplemented_Feature
argument_list|)
expr_stmt|;
goto|goto
name|Fail
goto|;
endif|#
directive|endif
comment|/* FT_CONFIG_OPTION_USE_PNG */
default|default:
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Table
argument_list|)
expr_stmt|;
goto|goto
name|Fail
goto|;
block|}
if|if
condition|(
operator|!
name|decoder
operator|->
name|bitmap_allocated
condition|)
block|{
name|error
operator|=
name|tt_sbit_decoder_alloc_bitmap
argument_list|(
name|decoder
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Fail
goto|;
block|}
name|error
operator|=
name|loader
argument_list|(
name|decoder
argument_list|,
name|p
argument_list|,
name|p_limit
argument_list|,
name|x_pos
argument_list|,
name|y_pos
argument_list|)
expr_stmt|;
block|}
name|Fail
label|:
name|FT_FRAME_RELEASE
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|Exit
label|:
return|return
name|error
return|;
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|tt_sbit_decoder_load_image
name|tt_sbit_decoder_load_image
parameter_list|(
name|TT_SBitDecoder
name|decoder
parameter_list|,
name|FT_UInt
name|glyph_index
parameter_list|,
name|FT_Int
name|x_pos
parameter_list|,
name|FT_Int
name|y_pos
parameter_list|)
block|{
comment|/*      *  First, we find the correct strike range that applies to this      *  glyph index.      */
name|FT_Byte
modifier|*
name|p
init|=
name|decoder
operator|->
name|eblc_base
operator|+
name|decoder
operator|->
name|strike_index_array
decl_stmt|;
name|FT_Byte
modifier|*
name|p_limit
init|=
name|decoder
operator|->
name|eblc_limit
decl_stmt|;
name|FT_ULong
name|num_ranges
init|=
name|decoder
operator|->
name|strike_index_count
decl_stmt|;
name|FT_UInt
name|start
decl_stmt|,
name|end
decl_stmt|,
name|index_format
decl_stmt|,
name|image_format
decl_stmt|;
name|FT_ULong
name|image_start
init|=
literal|0
decl_stmt|,
name|image_end
init|=
literal|0
decl_stmt|,
name|image_offset
decl_stmt|;
for|for
control|(
init|;
name|num_ranges
operator|>
literal|0
condition|;
name|num_ranges
operator|--
control|)
block|{
name|start
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|end
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|glyph_index
operator|>=
name|start
operator|&&
name|glyph_index
operator|<=
name|end
condition|)
goto|goto
name|FoundRange
goto|;
name|p
operator|+=
literal|4
expr_stmt|;
comment|/* ignore index offset */
block|}
goto|goto
name|NoBitmap
goto|;
name|FoundRange
label|:
name|image_offset
operator|=
name|FT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* overflow check */
name|p
operator|=
name|decoder
operator|->
name|eblc_base
operator|+
name|decoder
operator|->
name|strike_index_array
expr_stmt|;
if|if
condition|(
name|image_offset
operator|>
call|(
name|FT_ULong
call|)
argument_list|(
name|p_limit
operator|-
name|p
argument_list|)
condition|)
goto|goto
name|Failure
goto|;
name|p
operator|+=
name|image_offset
expr_stmt|;
if|if
condition|(
name|p
operator|+
literal|8
operator|>
name|p_limit
condition|)
goto|goto
name|NoBitmap
goto|;
comment|/* now find the glyph's location and extend within the ebdt table */
name|index_format
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|image_format
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|image_offset
operator|=
name|FT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|index_format
condition|)
block|{
case|case
literal|1
case|:
comment|/* 4-byte offsets relative to `image_offset' */
name|p
operator|+=
literal|4
operator|*
operator|(
name|glyph_index
operator|-
name|start
operator|)
expr_stmt|;
if|if
condition|(
name|p
operator|+
literal|8
operator|>
name|p_limit
condition|)
goto|goto
name|NoBitmap
goto|;
name|image_start
operator|=
name|FT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|image_end
operator|=
name|FT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|image_start
operator|==
name|image_end
condition|)
comment|/* missing glyph */
goto|goto
name|NoBitmap
goto|;
break|break;
case|case
literal|2
case|:
comment|/* big metrics, constant image size */
block|{
name|FT_ULong
name|image_size
decl_stmt|;
if|if
condition|(
name|p
operator|+
literal|12
operator|>
name|p_limit
condition|)
goto|goto
name|NoBitmap
goto|;
name|image_size
operator|=
name|FT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|tt_sbit_decoder_load_metrics
argument_list|(
name|decoder
argument_list|,
operator|&
name|p
argument_list|,
name|p_limit
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|NoBitmap
goto|;
name|image_start
operator|=
name|image_size
operator|*
operator|(
name|glyph_index
operator|-
name|start
operator|)
expr_stmt|;
name|image_end
operator|=
name|image_start
operator|+
name|image_size
expr_stmt|;
block|}
break|break;
case|case
literal|3
case|:
comment|/* 2-byte offsets relative to 'image_offset' */
name|p
operator|+=
literal|2
operator|*
operator|(
name|glyph_index
operator|-
name|start
operator|)
expr_stmt|;
if|if
condition|(
name|p
operator|+
literal|4
operator|>
name|p_limit
condition|)
goto|goto
name|NoBitmap
goto|;
name|image_start
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|image_end
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|image_start
operator|==
name|image_end
condition|)
comment|/* missing glyph */
goto|goto
name|NoBitmap
goto|;
break|break;
case|case
literal|4
case|:
comment|/* sparse glyph array with (glyph,offset) pairs */
block|{
name|FT_ULong
name|mm
decl_stmt|,
name|num_glyphs
decl_stmt|;
if|if
condition|(
name|p
operator|+
literal|4
operator|>
name|p_limit
condition|)
goto|goto
name|NoBitmap
goto|;
name|num_glyphs
operator|=
name|FT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* overflow check for p + ( num_glyphs + 1 ) * 4 */
if|if
condition|(
name|p
operator|+
literal|4
operator|>
name|p_limit
operator|||
name|num_glyphs
operator|>
call|(
name|FT_ULong
call|)
argument_list|(
operator|(
operator|(
name|p_limit
operator|-
name|p
operator|)
operator|>>
literal|2
operator|)
operator|-
literal|1
argument_list|)
condition|)
goto|goto
name|NoBitmap
goto|;
for|for
control|(
name|mm
operator|=
literal|0
init|;
name|mm
operator|<
name|num_glyphs
condition|;
name|mm
operator|++
control|)
block|{
name|FT_UInt
name|gindex
init|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|gindex
operator|==
name|glyph_index
condition|)
block|{
name|image_start
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
name|image_end
operator|=
name|FT_PEEK_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
name|p
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|mm
operator|>=
name|num_glyphs
condition|)
goto|goto
name|NoBitmap
goto|;
block|}
break|break;
case|case
literal|5
case|:
comment|/* constant metrics with sparse glyph codes */
case|case
literal|19
case|:
block|{
name|FT_ULong
name|image_size
decl_stmt|,
name|mm
decl_stmt|,
name|num_glyphs
decl_stmt|;
if|if
condition|(
name|p
operator|+
literal|16
operator|>
name|p_limit
condition|)
goto|goto
name|NoBitmap
goto|;
name|image_size
operator|=
name|FT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|tt_sbit_decoder_load_metrics
argument_list|(
name|decoder
argument_list|,
operator|&
name|p
argument_list|,
name|p_limit
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|NoBitmap
goto|;
name|num_glyphs
operator|=
name|FT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* overflow check for p + 2 * num_glyphs */
if|if
condition|(
name|num_glyphs
operator|>
call|(
name|FT_ULong
call|)
argument_list|(
operator|(
name|p_limit
operator|-
name|p
operator|)
operator|>>
literal|1
argument_list|)
condition|)
goto|goto
name|NoBitmap
goto|;
for|for
control|(
name|mm
operator|=
literal|0
init|;
name|mm
operator|<
name|num_glyphs
condition|;
name|mm
operator|++
control|)
block|{
name|FT_UInt
name|gindex
init|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|gindex
operator|==
name|glyph_index
condition|)
break|break;
block|}
if|if
condition|(
name|mm
operator|>=
name|num_glyphs
condition|)
goto|goto
name|NoBitmap
goto|;
name|image_start
operator|=
name|image_size
operator|*
name|mm
expr_stmt|;
name|image_end
operator|=
name|image_start
operator|+
name|image_size
expr_stmt|;
block|}
break|break;
default|default:
goto|goto
name|NoBitmap
goto|;
block|}
if|if
condition|(
name|image_start
operator|>
name|image_end
condition|)
goto|goto
name|NoBitmap
goto|;
name|image_end
operator|-=
name|image_start
expr_stmt|;
name|image_start
operator|=
name|image_offset
operator|+
name|image_start
expr_stmt|;
name|FT_TRACE3
argument_list|(
operator|(
literal|"tt_sbit_decoder_load_image:"
literal|" found sbit (format %d) for glyph index %d\n"
operator|,
name|image_format
operator|,
name|glyph_index
operator|)
argument_list|)
expr_stmt|;
return|return
name|tt_sbit_decoder_load_bitmap
argument_list|(
name|decoder
argument_list|,
name|image_format
argument_list|,
name|image_start
argument_list|,
name|image_end
argument_list|,
name|x_pos
argument_list|,
name|y_pos
argument_list|)
return|;
name|Failure
label|:
return|return
name|FT_THROW
argument_list|(
name|Invalid_Table
argument_list|)
return|;
name|NoBitmap
label|:
name|FT_TRACE4
argument_list|(
operator|(
literal|"tt_sbit_decoder_load_image:"
literal|" no sbit found for glyph index %d\n"
operator|,
name|glyph_index
operator|)
argument_list|)
expr_stmt|;
return|return
name|FT_THROW
argument_list|(
name|Invalid_Argument
argument_list|)
return|;
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|tt_face_load_sbix_image
name|tt_face_load_sbix_image
parameter_list|(
name|TT_Face
name|face
parameter_list|,
name|FT_ULong
name|strike_index
parameter_list|,
name|FT_UInt
name|glyph_index
parameter_list|,
name|FT_Stream
name|stream
parameter_list|,
name|FT_Bitmap
modifier|*
name|map
parameter_list|,
name|TT_SBit_MetricsRec
modifier|*
name|metrics
parameter_list|)
block|{
name|FT_UInt
name|sbix_pos
decl_stmt|,
name|strike_offset
decl_stmt|,
name|glyph_start
decl_stmt|,
name|glyph_end
decl_stmt|;
name|FT_ULong
name|table_size
decl_stmt|;
name|FT_Int
name|originOffsetX
decl_stmt|,
name|originOffsetY
decl_stmt|;
name|FT_Tag
name|graphicType
decl_stmt|;
name|FT_Int
name|recurse_depth
init|=
literal|0
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|FT_Byte
modifier|*
name|p
decl_stmt|;
name|FT_UNUSED
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|metrics
operator|->
name|width
operator|=
literal|0
expr_stmt|;
name|metrics
operator|->
name|height
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|face
operator|->
name|sbit_table
operator|+
literal|8
operator|+
literal|4
operator|*
name|strike_index
expr_stmt|;
name|strike_offset
operator|=
name|FT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|error
operator|=
name|face
operator|->
name|goto_table
argument_list|(
name|face
argument_list|,
name|TTAG_sbix
argument_list|,
name|stream
argument_list|,
operator|&
name|table_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|sbix_pos
operator|=
name|FT_STREAM_POS
argument_list|()
expr_stmt|;
name|retry
label|:
if|if
condition|(
name|glyph_index
operator|>
operator|(
name|FT_UInt
operator|)
name|face
operator|->
name|root
operator|.
name|num_glyphs
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_Argument
argument_list|)
return|;
if|if
condition|(
name|strike_offset
operator|>=
name|table_size
operator|||
name|table_size
operator|-
name|strike_offset
operator|<
literal|4
operator|+
name|glyph_index
operator|*
literal|4
operator|+
literal|8
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_File_Format
argument_list|)
return|;
if|if
condition|(
name|FT_STREAM_SEEK
argument_list|(
name|sbix_pos
operator|+
name|strike_offset
operator|+
literal|4
operator|+
name|glyph_index
operator|*
literal|4
argument_list|)
operator|||
name|FT_FRAME_ENTER
argument_list|(
literal|8
argument_list|)
condition|)
return|return
name|error
return|;
name|glyph_start
operator|=
name|FT_GET_ULONG
argument_list|()
expr_stmt|;
name|glyph_end
operator|=
name|FT_GET_ULONG
argument_list|()
expr_stmt|;
name|FT_FRAME_EXIT
argument_list|()
expr_stmt|;
if|if
condition|(
name|glyph_start
operator|==
name|glyph_end
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_Argument
argument_list|)
return|;
if|if
condition|(
name|glyph_start
operator|>
name|glyph_end
operator|||
name|glyph_end
operator|-
name|glyph_start
operator|<
literal|8
operator|||
name|table_size
operator|-
name|strike_offset
operator|<
name|glyph_end
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_File_Format
argument_list|)
return|;
if|if
condition|(
name|FT_STREAM_SEEK
argument_list|(
name|sbix_pos
operator|+
name|strike_offset
operator|+
name|glyph_start
argument_list|)
operator|||
name|FT_FRAME_ENTER
argument_list|(
name|glyph_end
operator|-
name|glyph_start
argument_list|)
condition|)
return|return
name|error
return|;
name|originOffsetX
operator|=
name|FT_GET_SHORT
argument_list|()
expr_stmt|;
name|originOffsetY
operator|=
name|FT_GET_SHORT
argument_list|()
expr_stmt|;
name|graphicType
operator|=
name|FT_GET_TAG4
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|graphicType
condition|)
block|{
case|case
name|FT_MAKE_TAG
argument_list|(
literal|'d'
argument_list|,
literal|'u'
argument_list|,
literal|'p'
argument_list|,
literal|'e'
argument_list|)
case|:
if|if
condition|(
name|recurse_depth
operator|<
literal|4
condition|)
block|{
name|glyph_index
operator|=
name|FT_GET_USHORT
argument_list|()
expr_stmt|;
name|FT_FRAME_EXIT
argument_list|()
expr_stmt|;
name|recurse_depth
operator|++
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_File_Format
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_MAKE_TAG
argument_list|(
literal|'p'
argument_list|,
literal|'n'
argument_list|,
literal|'g'
argument_list|,
literal|' '
argument_list|)
case|:
ifdef|#
directive|ifdef
name|FT_CONFIG_OPTION_USE_PNG
name|error
operator|=
name|Load_SBit_Png
argument_list|(
name|face
operator|->
name|root
operator|.
name|glyph
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|32
argument_list|,
name|metrics
argument_list|,
name|stream
operator|->
name|memory
argument_list|,
name|stream
operator|->
name|cursor
argument_list|,
name|glyph_end
operator|-
name|glyph_start
operator|-
literal|8
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
operator|=
name|FT_THROW
argument_list|(
name|Unimplemented_Feature
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|FT_MAKE_TAG
argument_list|(
literal|'j'
argument_list|,
literal|'p'
argument_list|,
literal|'g'
argument_list|,
literal|' '
argument_list|)
case|:
case|case
name|FT_MAKE_TAG
argument_list|(
literal|'t'
argument_list|,
literal|'i'
argument_list|,
literal|'f'
argument_list|,
literal|'f'
argument_list|)
case|:
case|case
name|FT_MAKE_TAG
argument_list|(
literal|'r'
argument_list|,
literal|'g'
argument_list|,
literal|'b'
argument_list|,
literal|'l'
argument_list|)
case|:
comment|/* used on iOS 7.1 */
name|error
operator|=
name|FT_THROW
argument_list|(
name|Unknown_File_Format
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|FT_THROW
argument_list|(
name|Unimplemented_Feature
argument_list|)
expr_stmt|;
break|break;
block|}
name|FT_FRAME_EXIT
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|FT_Short
name|abearing
decl_stmt|;
name|FT_UShort
name|aadvance
decl_stmt|;
name|tt_face_get_metrics
argument_list|(
name|face
argument_list|,
name|FALSE
argument_list|,
name|glyph_index
argument_list|,
operator|&
name|abearing
argument_list|,
operator|&
name|aadvance
argument_list|)
expr_stmt|;
name|metrics
operator|->
name|horiBearingX
operator|=
operator|(
name|FT_Short
operator|)
name|originOffsetX
expr_stmt|;
name|metrics
operator|->
name|horiBearingY
operator|=
call|(
name|FT_Short
call|)
argument_list|(
operator|-
name|originOffsetY
operator|+
name|metrics
operator|->
name|height
argument_list|)
expr_stmt|;
name|metrics
operator|->
name|horiAdvance
operator|=
call|(
name|FT_Short
call|)
argument_list|(
name|aadvance
operator|*
name|face
operator|->
name|root
operator|.
name|size
operator|->
name|metrics
operator|.
name|x_ppem
operator|/
name|face
operator|->
name|header
operator|.
name|Units_Per_EM
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function
begin_macro
DECL|function|FT_LOCAL
name|FT_LOCAL
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|tt_face_load_sbit_image
argument_list|(
argument|TT_Face              face
argument_list|,
argument|FT_ULong             strike_index
argument_list|,
argument|FT_UInt              glyph_index
argument_list|,
argument|FT_UInt              load_flags
argument_list|,
argument|FT_Stream            stream
argument_list|,
argument|FT_Bitmap           *map
argument_list|,
argument|TT_SBit_MetricsRec  *metrics
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
switch|switch
condition|(
operator|(
name|FT_UInt
operator|)
name|face
operator|->
name|sbit_table_type
condition|)
block|{
case|case
name|TT_SBIT_TABLE_TYPE_EBLC
case|:
case|case
name|TT_SBIT_TABLE_TYPE_CBLC
case|:
block|{
name|TT_SBitDecoderRec
name|decoder
index|[
literal|1
index|]
decl_stmt|;
name|error
operator|=
name|tt_sbit_decoder_init
argument_list|(
name|decoder
argument_list|,
name|face
argument_list|,
name|strike_index
argument_list|,
name|metrics
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|error
operator|=
name|tt_sbit_decoder_load_image
argument_list|(
name|decoder
argument_list|,
name|glyph_index
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_sbit_decoder_done
argument_list|(
name|decoder
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|TT_SBIT_TABLE_TYPE_SBIX
case|:
name|error
operator|=
name|tt_face_load_sbix_image
argument_list|(
name|face
argument_list|,
name|strike_index
argument_list|,
name|glyph_index
argument_list|,
name|stream
argument_list|,
name|map
argument_list|,
name|metrics
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|FT_THROW
argument_list|(
name|Unknown_File_Format
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Flatten color bitmaps if color was not requested. */
if|if
condition|(
operator|!
name|error
operator|&&
operator|!
operator|(
name|load_flags
operator|&
name|FT_LOAD_COLOR
operator|)
operator|&&
name|map
operator|->
name|pixel_mode
operator|==
name|FT_PIXEL_MODE_BGRA
condition|)
block|{
name|FT_Bitmap
name|new_map
decl_stmt|;
name|FT_Library
name|library
init|=
name|face
operator|->
name|root
operator|.
name|glyph
operator|->
name|library
decl_stmt|;
name|FT_Bitmap_New
argument_list|(
operator|&
name|new_map
argument_list|)
expr_stmt|;
comment|/* Convert to 8bit grayscale. */
name|error
operator|=
name|FT_Bitmap_Convert
argument_list|(
name|library
argument_list|,
name|map
argument_list|,
operator|&
name|new_map
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|FT_Bitmap_Done
argument_list|(
name|library
argument_list|,
operator|&
name|new_map
argument_list|)
expr_stmt|;
else|else
block|{
name|map
operator|->
name|pixel_mode
operator|=
name|new_map
operator|.
name|pixel_mode
expr_stmt|;
name|map
operator|->
name|pitch
operator|=
name|new_map
operator|.
name|pitch
expr_stmt|;
name|map
operator|->
name|num_grays
operator|=
name|new_map
operator|.
name|num_grays
expr_stmt|;
name|ft_glyphslot_set_bitmap
argument_list|(
name|face
operator|->
name|root
operator|.
name|glyph
argument_list|,
name|new_map
operator|.
name|buffer
argument_list|)
expr_stmt|;
name|face
operator|->
name|root
operator|.
name|glyph
operator|->
name|internal
operator|->
name|flags
operator||=
name|FT_GLYPH_OWN_BITMAP
expr_stmt|;
block|}
block|}
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/* EOF */
end_comment
end_unit
