begin_unit
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  ttsbit.c                                                               */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*    TrueType and OpenType embedded bitmap support (body).                */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 by */
end_comment
begin_comment
comment|/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  This file is part of the FreeType project, and may only be used,       */
end_comment
begin_comment
comment|/*  modified, and distributed under the terms of the FreeType project      */
end_comment
begin_comment
comment|/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
end_comment
begin_comment
comment|/*  this file you indicate that you have read the license and              */
end_comment
begin_comment
comment|/*  understand and accept it fully.                                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<ft2build.h>
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_DEBUG_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_STREAM_H
end_include
begin_include
include|#
directive|include
include|FT_TRUETYPE_TAGS_H
end_include
begin_comment
comment|/*    *  Alas, the memory-optimized sbit loader can't be used when implementing    *  the `old internals' hack    */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|FT_CONFIG_OPTION_OLD_INTERNALS
end_ifndef
begin_include
include|#
directive|include
file|"ttsbit0.c"
end_include
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* FT_CONFIG_OPTION_OLD_INTERNALS */
end_comment
begin_include
include|#
directive|include
file|<ft2build.h>
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_DEBUG_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_STREAM_H
end_include
begin_include
include|#
directive|include
include|FT_TRUETYPE_TAGS_H
end_include
begin_include
include|#
directive|include
file|"ttsbit.h"
end_include
begin_include
include|#
directive|include
file|"sferrors.h"
end_include
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
end_comment
begin_comment
comment|/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
end_comment
begin_comment
comment|/* messages during execution.                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_undef
DECL|macro|FT_COMPONENT
undef|#
directive|undef
name|FT_COMPONENT
end_undef
begin_define
DECL|macro|FT_COMPONENT
define|#
directive|define
name|FT_COMPONENT
value|trace_ttsbit
end_define
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    blit_sbit                                                          */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Blits a bitmap from an input stream into a given target.  Supports */
end_comment
begin_comment
comment|/*    x and y offsets as well as byte padded lines.                      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    target      :: The target bitmap/pixmap.                           */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    source      :: The input packed bitmap data.                       */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    line_bits   :: The number of bits per line.                        */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    byte_padded :: A flag which is true if lines are byte-padded.      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    x_offset    :: The horizontal offset.                              */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    y_offset    :: The vertical offset.                                */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Note>                                                                */
end_comment
begin_comment
comment|/*    IMPORTANT: The x and y offsets are relative to the top corner of   */
end_comment
begin_comment
comment|/*               the target bitmap (unlike the normal TrueType           */
end_comment
begin_comment
comment|/*               convention).  A positive y offset indicates a downwards */
end_comment
begin_comment
comment|/*               direction!                                              */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|blit_sbit
name|blit_sbit
parameter_list|(
name|FT_Bitmap
modifier|*
name|target
parameter_list|,
name|FT_Byte
modifier|*
name|source
parameter_list|,
name|FT_Int
name|line_bits
parameter_list|,
name|FT_Bool
name|byte_padded
parameter_list|,
name|FT_Int
name|x_offset
parameter_list|,
name|FT_Int
name|y_offset
parameter_list|,
name|FT_Int
name|source_height
parameter_list|)
block|{
name|FT_Byte
modifier|*
name|line_buff
decl_stmt|;
name|FT_Int
name|line_incr
decl_stmt|;
name|FT_Int
name|height
decl_stmt|;
name|FT_UShort
name|acc
decl_stmt|;
name|FT_UInt
name|loaded
decl_stmt|;
comment|/* first of all, compute starting write position */
name|line_incr
operator|=
name|target
operator|->
name|pitch
expr_stmt|;
name|line_buff
operator|=
name|target
operator|->
name|buffer
expr_stmt|;
if|if
condition|(
name|line_incr
operator|<
literal|0
condition|)
name|line_buff
operator|-=
name|line_incr
operator|*
operator|(
name|target
operator|->
name|rows
operator|-
literal|1
operator|)
expr_stmt|;
name|line_buff
operator|+=
operator|(
name|x_offset
operator|>>
literal|3
operator|)
operator|+
name|y_offset
operator|*
name|line_incr
expr_stmt|;
comment|/***********************************************************************/
comment|/*                                                                     */
comment|/* We use the extra-classic `accumulator' trick to extract the bits    */
comment|/* from the source byte stream.                                        */
comment|/*                                                                     */
comment|/* Namely, the variable `acc' is a 16-bit accumulator containing the   */
comment|/* last `loaded' bits from the input stream.  The bits are shifted to  */
comment|/* the upmost position in `acc'.                                       */
comment|/*                                                                     */
comment|/***********************************************************************/
name|acc
operator|=
literal|0
expr_stmt|;
comment|/* clear accumulator   */
name|loaded
operator|=
literal|0
expr_stmt|;
comment|/* no bits were loaded */
for|for
control|(
name|height
operator|=
name|source_height
init|;
name|height
operator|>
literal|0
condition|;
name|height
operator|--
control|)
block|{
name|FT_Byte
modifier|*
name|cur
init|=
name|line_buff
decl_stmt|;
comment|/* current write cursor          */
name|FT_Int
name|count
init|=
name|line_bits
decl_stmt|;
comment|/* # of bits to extract per line */
name|FT_Byte
name|shift
init|=
call|(
name|FT_Byte
call|)
argument_list|(
name|x_offset
operator|&
literal|7
argument_list|)
decl_stmt|;
comment|/* current write shift  */
name|FT_Byte
name|space
init|=
call|(
name|FT_Byte
call|)
argument_list|(
literal|8
operator|-
name|shift
argument_list|)
decl_stmt|;
comment|/* first of all, read individual source bytes */
if|if
condition|(
name|count
operator|>=
literal|8
condition|)
block|{
name|count
operator|-=
literal|8
expr_stmt|;
block|{
do|do
block|{
name|FT_Byte
name|val
decl_stmt|;
comment|/* ensure that there are at least 8 bits in the accumulator */
if|if
condition|(
name|loaded
operator|<
literal|8
condition|)
block|{
name|acc
operator||=
call|(
name|FT_UShort
call|)
argument_list|(
operator|(
name|FT_UShort
operator|)
operator|*
name|source
operator|++
operator|<<
operator|(
literal|8
operator|-
name|loaded
operator|)
argument_list|)
expr_stmt|;
name|loaded
operator|+=
literal|8
expr_stmt|;
block|}
comment|/* now write one byte */
name|val
operator|=
call|(
name|FT_Byte
call|)
argument_list|(
name|acc
operator|>>
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|shift
condition|)
block|{
name|cur
index|[
literal|0
index|]
operator||=
call|(
name|FT_Byte
call|)
argument_list|(
name|val
operator|>>
name|shift
argument_list|)
expr_stmt|;
name|cur
index|[
literal|1
index|]
operator||=
call|(
name|FT_Byte
call|)
argument_list|(
name|val
operator|<<
name|space
argument_list|)
expr_stmt|;
block|}
else|else
name|cur
index|[
literal|0
index|]
operator||=
name|val
expr_stmt|;
name|cur
operator|++
expr_stmt|;
name|acc
operator|<<=
literal|8
expr_stmt|;
comment|/* remove bits from accumulator */
name|loaded
operator|-=
literal|8
expr_stmt|;
name|count
operator|-=
literal|8
expr_stmt|;
block|}
do|while
condition|(
name|count
operator|>=
literal|0
condition|)
do|;
block|}
comment|/* restore `count' to correct value */
name|count
operator|+=
literal|8
expr_stmt|;
block|}
comment|/* now write remaining bits (count< 8) */
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|FT_Byte
name|val
decl_stmt|;
comment|/* ensure that there are at least `count' bits in the accumulator */
if|if
condition|(
operator|(
name|FT_Int
operator|)
name|loaded
operator|<
name|count
condition|)
block|{
name|acc
operator||=
call|(
name|FT_UShort
call|)
argument_list|(
operator|(
name|FT_UShort
operator|)
operator|*
name|source
operator|++
operator|<<
operator|(
literal|8
operator|-
name|loaded
operator|)
argument_list|)
expr_stmt|;
name|loaded
operator|+=
literal|8
expr_stmt|;
block|}
comment|/* now write remaining bits */
name|val
operator|=
call|(
name|FT_Byte
call|)
argument_list|(
operator|(
call|(
name|FT_Byte
call|)
argument_list|(
name|acc
operator|>>
literal|8
argument_list|)
operator|)
operator|&
operator|~
operator|(
literal|0xFF
operator|>>
name|count
operator|)
argument_list|)
expr_stmt|;
name|cur
index|[
literal|0
index|]
operator||=
call|(
name|FT_Byte
call|)
argument_list|(
name|val
operator|>>
name|shift
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
name|space
condition|)
name|cur
index|[
literal|1
index|]
operator||=
call|(
name|FT_Byte
call|)
argument_list|(
name|val
operator|<<
name|space
argument_list|)
expr_stmt|;
name|acc
operator|<<=
name|count
expr_stmt|;
name|loaded
operator|-=
name|count
expr_stmt|;
block|}
comment|/* now, skip to next line */
if|if
condition|(
name|byte_padded
condition|)
block|{
name|acc
operator|=
literal|0
expr_stmt|;
name|loaded
operator|=
literal|0
expr_stmt|;
comment|/* clear accumulator on byte-padded lines */
block|}
name|line_buff
operator|+=
name|line_incr
expr_stmt|;
block|}
block|}
end_function
begin_decl_stmt
DECL|variable|sbit_metrics_fields
specifier|static
specifier|const
name|FT_Frame_Field
name|sbit_metrics_fields
index|[]
init|=
block|{
DECL|macro|FT_STRUCTURE
undef|#
directive|undef
name|FT_STRUCTURE
DECL|macro|FT_STRUCTURE
define|#
directive|define
name|FT_STRUCTURE
value|TT_SBit_MetricsRec
name|FT_FRAME_START
argument_list|(
literal|8
argument_list|)
block|,
name|FT_FRAME_BYTE
argument_list|(
name|height
argument_list|)
block|,
name|FT_FRAME_BYTE
argument_list|(
name|width
argument_list|)
block|,
name|FT_FRAME_CHAR
argument_list|(
name|horiBearingX
argument_list|)
block|,
name|FT_FRAME_CHAR
argument_list|(
name|horiBearingY
argument_list|)
block|,
name|FT_FRAME_BYTE
argument_list|(
name|horiAdvance
argument_list|)
block|,
name|FT_FRAME_CHAR
argument_list|(
name|vertBearingX
argument_list|)
block|,
name|FT_FRAME_CHAR
argument_list|(
name|vertBearingY
argument_list|)
block|,
name|FT_FRAME_BYTE
argument_list|(
name|vertAdvance
argument_list|)
block|,
name|FT_FRAME_END
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    Load_SBit_Const_Metrics                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Loads the metrics for `EBLC' index tables format 2 and 5.          */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    range  :: The target range.                                        */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    stream :: The input stream.                                        */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    FreeType error code.  0 means success.                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|Load_SBit_Const_Metrics
name|Load_SBit_Const_Metrics
parameter_list|(
name|TT_SBit_Range
name|range
parameter_list|,
name|FT_Stream
name|stream
parameter_list|)
block|{
name|FT_Error
name|error
decl_stmt|;
if|if
condition|(
name|FT_READ_ULONG
argument_list|(
name|range
operator|->
name|image_size
argument_list|)
condition|)
return|return
name|error
return|;
return|return
name|FT_STREAM_READ_FIELDS
argument_list|(
name|sbit_metrics_fields
argument_list|,
operator|&
name|range
operator|->
name|metrics
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    Load_SBit_Range_Codes                                              */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Loads the range codes for `EBLC' index tables format 4 and 5.      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    range        :: The target range.                                  */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    stream       :: The input stream.                                  */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    load_offsets :: A flag whether to load the glyph offset table.     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    FreeType error code.  0 means success.                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|Load_SBit_Range_Codes
name|Load_SBit_Range_Codes
parameter_list|(
name|TT_SBit_Range
name|range
parameter_list|,
name|FT_Stream
name|stream
parameter_list|,
name|FT_Bool
name|load_offsets
parameter_list|)
block|{
name|FT_Error
name|error
decl_stmt|;
name|FT_ULong
name|count
decl_stmt|,
name|n
decl_stmt|,
name|size
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|stream
operator|->
name|memory
decl_stmt|;
if|if
condition|(
name|FT_READ_ULONG
argument_list|(
name|count
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|range
operator|->
name|num_glyphs
operator|=
name|count
expr_stmt|;
comment|/* Allocate glyph offsets table if needed */
if|if
condition|(
name|load_offsets
condition|)
block|{
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|range
operator|->
name|glyph_offsets
argument_list|,
name|count
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|size
operator|=
name|count
operator|*
literal|4L
expr_stmt|;
block|}
else|else
name|size
operator|=
name|count
operator|*
literal|2L
expr_stmt|;
comment|/* Allocate glyph codes table and access frame */
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|range
operator|->
name|glyph_codes
argument_list|,
name|count
argument_list|)
operator|||
name|FT_FRAME_ENTER
argument_list|(
name|size
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
block|{
name|range
operator|->
name|glyph_codes
index|[
name|n
index|]
operator|=
name|FT_GET_USHORT
argument_list|()
expr_stmt|;
if|if
condition|(
name|load_offsets
condition|)
name|range
operator|->
name|glyph_offsets
index|[
name|n
index|]
operator|=
operator|(
name|FT_ULong
operator|)
name|range
operator|->
name|image_offset
operator|+
name|FT_GET_USHORT
argument_list|()
expr_stmt|;
block|}
name|FT_FRAME_EXIT
argument_list|()
expr_stmt|;
name|Exit
label|:
return|return
name|error
return|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    Load_SBit_Range                                                    */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Loads a given `EBLC' index/range table.                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    range  :: The target range.                                        */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    stream :: The input stream.                                        */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    FreeType error code.  0 means success.                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|Load_SBit_Range
name|Load_SBit_Range
parameter_list|(
name|TT_SBit_Range
name|range
parameter_list|,
name|FT_Stream
name|stream
parameter_list|)
block|{
name|FT_Error
name|error
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|stream
operator|->
name|memory
decl_stmt|;
switch|switch
condition|(
name|range
operator|->
name|index_format
condition|)
block|{
case|case
literal|1
case|:
comment|/* variable metrics with 4-byte offsets */
case|case
literal|3
case|:
comment|/* variable metrics with 2-byte offsets */
block|{
name|FT_ULong
name|num_glyphs
decl_stmt|,
name|n
decl_stmt|;
name|FT_Int
name|size_elem
decl_stmt|;
name|FT_Bool
name|large
init|=
name|FT_BOOL
argument_list|(
name|range
operator|->
name|index_format
operator|==
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|range
operator|->
name|last_glyph
operator|<
name|range
operator|->
name|first_glyph
condition|)
block|{
name|error
operator|=
name|SFNT_Err_Invalid_File_Format
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|num_glyphs
operator|=
name|range
operator|->
name|last_glyph
operator|-
name|range
operator|->
name|first_glyph
operator|+
literal|1L
expr_stmt|;
name|range
operator|->
name|num_glyphs
operator|=
name|num_glyphs
expr_stmt|;
name|num_glyphs
operator|++
expr_stmt|;
comment|/* XXX: BEWARE - see spec */
name|size_elem
operator|=
name|large
condition|?
literal|4
else|:
literal|2
expr_stmt|;
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|range
operator|->
name|glyph_offsets
argument_list|,
name|num_glyphs
argument_list|)
operator|||
name|FT_FRAME_ENTER
argument_list|(
name|num_glyphs
operator|*
name|size_elem
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|num_glyphs
condition|;
name|n
operator|++
control|)
name|range
operator|->
name|glyph_offsets
index|[
name|n
index|]
operator|=
call|(
name|FT_ULong
call|)
argument_list|(
name|range
operator|->
name|image_offset
operator|+
operator|(
name|large
condition|?
name|FT_GET_ULONG
argument_list|()
else|:
name|FT_GET_USHORT
argument_list|()
operator|)
argument_list|)
expr_stmt|;
name|FT_FRAME_EXIT
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
comment|/* all glyphs have identical metrics */
name|error
operator|=
name|Load_SBit_Const_Metrics
argument_list|(
name|range
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|error
operator|=
name|Load_SBit_Range_Codes
argument_list|(
name|range
argument_list|,
name|stream
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|error
operator|=
name|Load_SBit_Const_Metrics
argument_list|(
name|range
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|Load_SBit_Range_Codes
argument_list|(
name|range
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|SFNT_Err_Invalid_File_Format
expr_stmt|;
block|}
name|Exit
label|:
return|return
name|error
return|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    tt_face_load_eblc                                                  */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Loads the table of embedded bitmap sizes for this face.            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    face   :: The target face object.                                  */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    stream :: The input stream.                                        */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    FreeType error code.  0 means success.                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|tt_face_load_eblc
argument_list|(
argument|TT_Face    face
argument_list|,
argument|FT_Stream  stream
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
init|=
literal|0
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|stream
operator|->
name|memory
decl_stmt|;
name|FT_Fixed
name|version
decl_stmt|;
name|FT_ULong
name|num_strikes
decl_stmt|;
name|FT_ULong
name|table_base
decl_stmt|;
specifier|static
specifier|const
name|FT_Frame_Field
name|sbit_line_metrics_fields
index|[]
init|=
block|{
DECL|macro|FT_STRUCTURE
undef|#
directive|undef
name|FT_STRUCTURE
DECL|macro|FT_STRUCTURE
define|#
directive|define
name|FT_STRUCTURE
value|TT_SBit_LineMetricsRec
comment|/* no FT_FRAME_START */
name|FT_FRAME_CHAR
argument_list|(
name|ascender
argument_list|)
block|,
name|FT_FRAME_CHAR
argument_list|(
name|descender
argument_list|)
block|,
name|FT_FRAME_BYTE
argument_list|(
name|max_width
argument_list|)
block|,
name|FT_FRAME_CHAR
argument_list|(
name|caret_slope_numerator
argument_list|)
block|,
name|FT_FRAME_CHAR
argument_list|(
name|caret_slope_denominator
argument_list|)
block|,
name|FT_FRAME_CHAR
argument_list|(
name|caret_offset
argument_list|)
block|,
name|FT_FRAME_CHAR
argument_list|(
name|min_origin_SB
argument_list|)
block|,
name|FT_FRAME_CHAR
argument_list|(
name|min_advance_SB
argument_list|)
block|,
name|FT_FRAME_CHAR
argument_list|(
name|max_before_BL
argument_list|)
block|,
name|FT_FRAME_CHAR
argument_list|(
name|min_after_BL
argument_list|)
block|,
name|FT_FRAME_CHAR
argument_list|(
name|pads
index|[
literal|0
index|]
argument_list|)
block|,
name|FT_FRAME_CHAR
argument_list|(
name|pads
index|[
literal|1
index|]
argument_list|)
block|,
name|FT_FRAME_END
block|}
decl_stmt|;
specifier|static
specifier|const
name|FT_Frame_Field
name|strike_start_fields
index|[]
init|=
block|{
DECL|macro|FT_STRUCTURE
undef|#
directive|undef
name|FT_STRUCTURE
DECL|macro|FT_STRUCTURE
define|#
directive|define
name|FT_STRUCTURE
value|TT_SBit_StrikeRec
comment|/* no FT_FRAME_START */
name|FT_FRAME_ULONG
argument_list|(
name|ranges_offset
argument_list|)
block|,
name|FT_FRAME_SKIP_LONG
block|,
name|FT_FRAME_ULONG
argument_list|(
name|num_ranges
argument_list|)
block|,
name|FT_FRAME_ULONG
argument_list|(
name|color_ref
argument_list|)
block|,
name|FT_FRAME_END
block|}
decl_stmt|;
specifier|static
specifier|const
name|FT_Frame_Field
name|strike_end_fields
index|[]
init|=
block|{
comment|/* no FT_FRAME_START */
name|FT_FRAME_USHORT
argument_list|(
name|start_glyph
argument_list|)
block|,
name|FT_FRAME_USHORT
argument_list|(
name|end_glyph
argument_list|)
block|,
name|FT_FRAME_BYTE
argument_list|(
name|x_ppem
argument_list|)
block|,
name|FT_FRAME_BYTE
argument_list|(
name|y_ppem
argument_list|)
block|,
name|FT_FRAME_BYTE
argument_list|(
name|bit_depth
argument_list|)
block|,
name|FT_FRAME_CHAR
argument_list|(
name|flags
argument_list|)
block|,
name|FT_FRAME_END
block|}
decl_stmt|;
name|face
operator|->
name|num_sbit_strikes
operator|=
literal|0
expr_stmt|;
comment|/* this table is optional */
name|error
operator|=
name|face
operator|->
name|goto_table
argument_list|(
name|face
argument_list|,
name|TTAG_EBLC
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|error
operator|=
name|face
operator|->
name|goto_table
argument_list|(
name|face
argument_list|,
name|TTAG_bloc
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|table_base
operator|=
name|FT_STREAM_POS
argument_list|()
expr_stmt|;
if|if
condition|(
name|FT_FRAME_ENTER
argument_list|(
literal|8L
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|version
operator|=
name|FT_GET_LONG
argument_list|()
expr_stmt|;
name|num_strikes
operator|=
name|FT_GET_ULONG
argument_list|()
expr_stmt|;
name|FT_FRAME_EXIT
argument_list|()
expr_stmt|;
comment|/* check version number and strike count */
if|if
condition|(
name|version
operator|!=
literal|0x00020000L
operator|||
name|num_strikes
operator|>=
literal|0x10000L
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"tt_face_load_sbit_strikes: invalid table version\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|SFNT_Err_Invalid_File_Format
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* allocate the strikes table */
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|face
operator|->
name|sbit_strikes
argument_list|,
name|num_strikes
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|face
operator|->
name|num_sbit_strikes
operator|=
name|num_strikes
expr_stmt|;
comment|/* now read each strike table separately */
block|{
name|TT_SBit_Strike
name|strike
init|=
name|face
operator|->
name|sbit_strikes
decl_stmt|;
name|FT_ULong
name|count
init|=
name|num_strikes
decl_stmt|;
if|if
condition|(
name|FT_FRAME_ENTER
argument_list|(
literal|48L
operator|*
name|num_strikes
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|FT_STREAM_READ_FIELDS
argument_list|(
name|strike_start_fields
argument_list|,
name|strike
argument_list|)
operator|||
name|FT_STREAM_READ_FIELDS
argument_list|(
name|sbit_line_metrics_fields
argument_list|,
operator|&
name|strike
operator|->
name|hori
argument_list|)
operator|||
name|FT_STREAM_READ_FIELDS
argument_list|(
name|sbit_line_metrics_fields
argument_list|,
operator|&
name|strike
operator|->
name|vert
argument_list|)
operator|||
name|FT_STREAM_READ_FIELDS
argument_list|(
name|strike_end_fields
argument_list|,
name|strike
argument_list|)
condition|)
break|break;
name|count
operator|--
expr_stmt|;
name|strike
operator|++
expr_stmt|;
block|}
name|FT_FRAME_EXIT
argument_list|()
expr_stmt|;
block|}
comment|/* allocate the index ranges for each strike table */
block|{
name|TT_SBit_Strike
name|strike
init|=
name|face
operator|->
name|sbit_strikes
decl_stmt|;
name|FT_ULong
name|count
init|=
name|num_strikes
decl_stmt|;
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|TT_SBit_Range
name|range
decl_stmt|;
name|FT_ULong
name|count2
init|=
name|strike
operator|->
name|num_ranges
decl_stmt|;
comment|/* read each range */
if|if
condition|(
name|FT_STREAM_SEEK
argument_list|(
name|table_base
operator|+
name|strike
operator|->
name|ranges_offset
argument_list|)
operator|||
name|FT_FRAME_ENTER
argument_list|(
name|strike
operator|->
name|num_ranges
operator|*
literal|8L
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|strike
operator|->
name|sbit_ranges
argument_list|,
name|strike
operator|->
name|num_ranges
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|range
operator|=
name|strike
operator|->
name|sbit_ranges
expr_stmt|;
while|while
condition|(
name|count2
operator|>
literal|0
condition|)
block|{
name|range
operator|->
name|first_glyph
operator|=
name|FT_GET_USHORT
argument_list|()
expr_stmt|;
name|range
operator|->
name|last_glyph
operator|=
name|FT_GET_USHORT
argument_list|()
expr_stmt|;
name|range
operator|->
name|table_offset
operator|=
name|table_base
operator|+
name|strike
operator|->
name|ranges_offset
operator|+
name|FT_GET_ULONG
argument_list|()
expr_stmt|;
name|count2
operator|--
expr_stmt|;
name|range
operator|++
expr_stmt|;
block|}
name|FT_FRAME_EXIT
argument_list|()
expr_stmt|;
comment|/* Now, read each index table */
name|count2
operator|=
name|strike
operator|->
name|num_ranges
expr_stmt|;
name|range
operator|=
name|strike
operator|->
name|sbit_ranges
expr_stmt|;
while|while
condition|(
name|count2
operator|>
literal|0
condition|)
block|{
comment|/* Read the header */
if|if
condition|(
name|FT_STREAM_SEEK
argument_list|(
name|range
operator|->
name|table_offset
argument_list|)
operator|||
name|FT_FRAME_ENTER
argument_list|(
literal|8L
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|range
operator|->
name|index_format
operator|=
name|FT_GET_USHORT
argument_list|()
expr_stmt|;
name|range
operator|->
name|image_format
operator|=
name|FT_GET_USHORT
argument_list|()
expr_stmt|;
name|range
operator|->
name|image_offset
operator|=
name|FT_GET_ULONG
argument_list|()
expr_stmt|;
name|FT_FRAME_EXIT
argument_list|()
expr_stmt|;
name|error
operator|=
name|Load_SBit_Range
argument_list|(
name|range
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|count2
operator|--
expr_stmt|;
name|range
operator|++
expr_stmt|;
block|}
name|count
operator|--
expr_stmt|;
name|strike
operator|++
expr_stmt|;
block|}
block|}
name|Exit
label|:
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    tt_face_free_eblc                                                  */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Releases the embedded bitmap tables.                               */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    face :: The target face object.                                    */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|tt_face_free_eblc
name|tt_face_free_eblc
argument_list|(
argument|TT_Face  face
argument_list|)
end_macro
begin_block
block|{
name|FT_Memory
name|memory
init|=
name|face
operator|->
name|root
operator|.
name|memory
decl_stmt|;
name|TT_SBit_Strike
name|strike
init|=
name|face
operator|->
name|sbit_strikes
decl_stmt|;
name|TT_SBit_Strike
name|strike_limit
init|=
name|strike
operator|+
name|face
operator|->
name|num_sbit_strikes
decl_stmt|;
if|if
condition|(
name|strike
condition|)
block|{
for|for
control|(
init|;
name|strike
operator|<
name|strike_limit
condition|;
name|strike
operator|++
control|)
block|{
name|TT_SBit_Range
name|range
init|=
name|strike
operator|->
name|sbit_ranges
decl_stmt|;
name|TT_SBit_Range
name|range_limit
init|=
name|range
operator|+
name|strike
operator|->
name|num_ranges
decl_stmt|;
if|if
condition|(
name|range
condition|)
block|{
for|for
control|(
init|;
name|range
operator|<
name|range_limit
condition|;
name|range
operator|++
control|)
block|{
comment|/* release the glyph offsets and codes tables */
comment|/* where appropriate                          */
name|FT_FREE
argument_list|(
name|range
operator|->
name|glyph_offsets
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|range
operator|->
name|glyph_codes
argument_list|)
expr_stmt|;
block|}
block|}
name|FT_FREE
argument_list|(
name|strike
operator|->
name|sbit_ranges
argument_list|)
expr_stmt|;
name|strike
operator|->
name|num_ranges
operator|=
literal|0
expr_stmt|;
block|}
name|FT_FREE
argument_list|(
name|face
operator|->
name|sbit_strikes
argument_list|)
expr_stmt|;
block|}
name|face
operator|->
name|num_sbit_strikes
operator|=
literal|0
expr_stmt|;
block|}
end_block
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|tt_face_set_sbit_strike
argument_list|(
argument|TT_Face          face
argument_list|,
argument|FT_Size_Request  req
argument_list|,
argument|FT_ULong*        astrike_index
argument_list|)
end_macro
begin_block
block|{
return|return
name|FT_Match_Size
argument_list|(
operator|(
name|FT_Face
operator|)
name|face
argument_list|,
name|req
argument_list|,
literal|0
argument_list|,
name|astrike_index
argument_list|)
return|;
block|}
end_block
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|tt_face_load_strike_metrics
argument_list|(
argument|TT_Face           face
argument_list|,
argument|FT_ULong          strike_index
argument_list|,
argument|FT_Size_Metrics*  metrics
argument_list|)
end_macro
begin_block
block|{
name|TT_SBit_Strike
name|strike
decl_stmt|;
if|if
condition|(
name|strike_index
operator|>=
name|face
operator|->
name|num_sbit_strikes
condition|)
return|return
name|SFNT_Err_Invalid_Argument
return|;
name|strike
operator|=
name|face
operator|->
name|sbit_strikes
operator|+
name|strike_index
expr_stmt|;
name|metrics
operator|->
name|x_ppem
operator|=
name|strike
operator|->
name|x_ppem
expr_stmt|;
name|metrics
operator|->
name|y_ppem
operator|=
name|strike
operator|->
name|y_ppem
expr_stmt|;
name|metrics
operator|->
name|ascender
operator|=
name|strike
operator|->
name|hori
operator|.
name|ascender
operator|<<
literal|6
expr_stmt|;
name|metrics
operator|->
name|descender
operator|=
name|strike
operator|->
name|hori
operator|.
name|descender
operator|<<
literal|6
expr_stmt|;
comment|/* XXX: Is this correct? */
name|metrics
operator|->
name|max_advance
operator|=
operator|(
name|strike
operator|->
name|hori
operator|.
name|min_origin_SB
operator|+
name|strike
operator|->
name|hori
operator|.
name|max_width
operator|+
name|strike
operator|->
name|hori
operator|.
name|min_advance_SB
operator|)
operator|<<
literal|6
expr_stmt|;
name|metrics
operator|->
name|height
operator|=
name|metrics
operator|->
name|ascender
operator|-
name|metrics
operator|->
name|descender
expr_stmt|;
return|return
name|SFNT_Err_Ok
return|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    find_sbit_range                                                    */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Scans a given strike's ranges and return, for a given glyph        */
end_comment
begin_comment
comment|/*    index, the corresponding sbit range, and `EBDT' offset.            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    glyph_index   :: The glyph index.                                  */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    strike        :: The source/current sbit strike.                   */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Output>                                                              */
end_comment
begin_comment
comment|/*    arange        :: The sbit range containing the glyph index.        */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    aglyph_offset :: The offset of the glyph data in `EBDT' table.     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    FreeType error code.  0 means the glyph index was found.           */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|find_sbit_range
name|find_sbit_range
parameter_list|(
name|FT_UInt
name|glyph_index
parameter_list|,
name|TT_SBit_Strike
name|strike
parameter_list|,
name|TT_SBit_Range
modifier|*
name|arange
parameter_list|,
name|FT_ULong
modifier|*
name|aglyph_offset
parameter_list|)
block|{
name|TT_SBit_RangeRec
modifier|*
name|range
decl_stmt|,
modifier|*
name|range_limit
decl_stmt|;
comment|/* check whether the glyph index is within this strike's */
comment|/* glyph range                                           */
if|if
condition|(
name|glyph_index
operator|<
operator|(
name|FT_UInt
operator|)
name|strike
operator|->
name|start_glyph
operator|||
name|glyph_index
operator|>
operator|(
name|FT_UInt
operator|)
name|strike
operator|->
name|end_glyph
condition|)
goto|goto
name|Fail
goto|;
comment|/* scan all ranges in strike */
name|range
operator|=
name|strike
operator|->
name|sbit_ranges
expr_stmt|;
name|range_limit
operator|=
name|range
operator|+
name|strike
operator|->
name|num_ranges
expr_stmt|;
if|if
condition|(
operator|!
name|range
condition|)
goto|goto
name|Fail
goto|;
for|for
control|(
init|;
name|range
operator|<
name|range_limit
condition|;
name|range
operator|++
control|)
block|{
if|if
condition|(
name|glyph_index
operator|>=
operator|(
name|FT_UInt
operator|)
name|range
operator|->
name|first_glyph
operator|&&
name|glyph_index
operator|<=
operator|(
name|FT_UInt
operator|)
name|range
operator|->
name|last_glyph
condition|)
block|{
name|FT_UShort
name|delta
init|=
call|(
name|FT_UShort
call|)
argument_list|(
name|glyph_index
operator|-
name|range
operator|->
name|first_glyph
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|range
operator|->
name|index_format
condition|)
block|{
case|case
literal|1
case|:
case|case
literal|3
case|:
operator|*
name|aglyph_offset
operator|=
name|range
operator|->
name|glyph_offsets
index|[
name|delta
index|]
expr_stmt|;
break|break;
case|case
literal|2
case|:
operator|*
name|aglyph_offset
operator|=
name|range
operator|->
name|image_offset
operator|+
name|range
operator|->
name|image_size
operator|*
name|delta
expr_stmt|;
break|break;
case|case
literal|4
case|:
case|case
literal|5
case|:
block|{
name|FT_ULong
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|range
operator|->
name|num_glyphs
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|FT_UInt
operator|)
name|range
operator|->
name|glyph_codes
index|[
name|n
index|]
operator|==
name|glyph_index
condition|)
block|{
if|if
condition|(
name|range
operator|->
name|index_format
operator|==
literal|4
condition|)
operator|*
name|aglyph_offset
operator|=
name|range
operator|->
name|glyph_offsets
index|[
name|n
index|]
expr_stmt|;
else|else
operator|*
name|aglyph_offset
operator|=
name|range
operator|->
name|image_offset
operator|+
name|n
operator|*
name|range
operator|->
name|image_size
expr_stmt|;
goto|goto
name|Found
goto|;
block|}
block|}
block|}
comment|/* fall-through */
default|default:
goto|goto
name|Fail
goto|;
block|}
name|Found
label|:
comment|/* return successfully! */
operator|*
name|arange
operator|=
name|range
expr_stmt|;
return|return
name|SFNT_Err_Ok
return|;
block|}
block|}
name|Fail
label|:
operator|*
name|arange
operator|=
literal|0
expr_stmt|;
operator|*
name|aglyph_offset
operator|=
literal|0
expr_stmt|;
return|return
name|SFNT_Err_Invalid_Argument
return|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    tt_find_sbit_image                                                 */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Checks whether an embedded bitmap (an `sbit') exists for a given   */
end_comment
begin_comment
comment|/*    glyph, at a given strike.                                          */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    face          :: The target face object.                           */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    glyph_index   :: The glyph index.                                  */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    strike_index  :: The current strike index.                         */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Output>                                                              */
end_comment
begin_comment
comment|/*    arange        :: The SBit range containing the glyph index.        */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    astrike       :: The SBit strike containing the glyph index.       */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    aglyph_offset :: The offset of the glyph data in `EBDT' table.     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    FreeType error code.  0 means success.  Returns                    */
end_comment
begin_comment
comment|/*    SFNT_Err_Invalid_Argument if no sbit exists for the requested      */
end_comment
begin_comment
comment|/*    glyph.                                                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_macro
DECL|function|FT_LOCAL
name|FT_LOCAL
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|tt_find_sbit_image
argument_list|(
argument|TT_Face          face
argument_list|,
argument|FT_UInt          glyph_index
argument_list|,
argument|FT_ULong         strike_index
argument_list|,
argument|TT_SBit_Range   *arange
argument_list|,
argument|TT_SBit_Strike  *astrike
argument_list|,
argument|FT_ULong        *aglyph_offset
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
decl_stmt|;
name|TT_SBit_Strike
name|strike
decl_stmt|;
if|if
condition|(
operator|!
name|face
operator|->
name|sbit_strikes
operator|||
operator|(
name|face
operator|->
name|num_sbit_strikes
operator|<=
name|strike_index
operator|)
condition|)
goto|goto
name|Fail
goto|;
name|strike
operator|=
operator|&
name|face
operator|->
name|sbit_strikes
index|[
name|strike_index
index|]
expr_stmt|;
name|error
operator|=
name|find_sbit_range
argument_list|(
name|glyph_index
argument_list|,
name|strike
argument_list|,
name|arange
argument_list|,
name|aglyph_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Fail
goto|;
operator|*
name|astrike
operator|=
name|strike
expr_stmt|;
return|return
name|SFNT_Err_Ok
return|;
name|Fail
label|:
comment|/* no embedded bitmap for this glyph in face */
operator|*
name|arange
operator|=
literal|0
expr_stmt|;
operator|*
name|astrike
operator|=
literal|0
expr_stmt|;
operator|*
name|aglyph_offset
operator|=
literal|0
expr_stmt|;
return|return
name|SFNT_Err_Invalid_Argument
return|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    tt_load_sbit_metrics                                               */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Gets the big metrics for a given SBit.                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    stream      :: The input stream.                                   */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    range       :: The SBit range containing the glyph.                */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Output>                                                              */
end_comment
begin_comment
comment|/*    big_metrics :: A big SBit metrics structure for the glyph.         */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    FreeType error code.  0 means success.                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Note>                                                                */
end_comment
begin_comment
comment|/*    The stream cursor must be positioned at the glyph's offset within  */
end_comment
begin_comment
comment|/*    the `EBDT' table before the call.                                  */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    If the image format uses variable metrics, the stream cursor is    */
end_comment
begin_comment
comment|/*    positioned just after the metrics header in the `EBDT' table on    */
end_comment
begin_comment
comment|/*    function exit.                                                     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_macro
DECL|function|FT_LOCAL
name|FT_LOCAL
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|tt_load_sbit_metrics
argument_list|(
argument|FT_Stream        stream
argument_list|,
argument|TT_SBit_Range    range
argument_list|,
argument|TT_SBit_Metrics  metrics
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
init|=
name|SFNT_Err_Ok
decl_stmt|;
switch|switch
condition|(
name|range
operator|->
name|image_format
condition|)
block|{
case|case
literal|1
case|:
case|case
literal|2
case|:
case|case
literal|8
case|:
comment|/* variable small metrics */
block|{
name|TT_SBit_SmallMetricsRec
name|smetrics
decl_stmt|;
specifier|static
specifier|const
name|FT_Frame_Field
name|sbit_small_metrics_fields
index|[]
init|=
block|{
DECL|macro|FT_STRUCTURE
undef|#
directive|undef
name|FT_STRUCTURE
DECL|macro|FT_STRUCTURE
define|#
directive|define
name|FT_STRUCTURE
value|TT_SBit_SmallMetricsRec
name|FT_FRAME_START
argument_list|(
literal|5
argument_list|)
block|,
name|FT_FRAME_BYTE
argument_list|(
name|height
argument_list|)
block|,
name|FT_FRAME_BYTE
argument_list|(
name|width
argument_list|)
block|,
name|FT_FRAME_CHAR
argument_list|(
name|bearingX
argument_list|)
block|,
name|FT_FRAME_CHAR
argument_list|(
name|bearingY
argument_list|)
block|,
name|FT_FRAME_BYTE
argument_list|(
name|advance
argument_list|)
block|,
name|FT_FRAME_END
block|}
decl_stmt|;
comment|/* read small metrics */
if|if
condition|(
name|FT_STREAM_READ_FIELDS
argument_list|(
name|sbit_small_metrics_fields
argument_list|,
operator|&
name|smetrics
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
comment|/* convert it to a big metrics */
name|metrics
operator|->
name|height
operator|=
name|smetrics
operator|.
name|height
expr_stmt|;
name|metrics
operator|->
name|width
operator|=
name|smetrics
operator|.
name|width
expr_stmt|;
name|metrics
operator|->
name|horiBearingX
operator|=
name|smetrics
operator|.
name|bearingX
expr_stmt|;
name|metrics
operator|->
name|horiBearingY
operator|=
name|smetrics
operator|.
name|bearingY
expr_stmt|;
name|metrics
operator|->
name|horiAdvance
operator|=
name|smetrics
operator|.
name|advance
expr_stmt|;
comment|/* these metrics are made up at a higher level when */
comment|/* needed.                                          */
name|metrics
operator|->
name|vertBearingX
operator|=
literal|0
expr_stmt|;
name|metrics
operator|->
name|vertBearingY
operator|=
literal|0
expr_stmt|;
name|metrics
operator|->
name|vertAdvance
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
literal|6
case|:
case|case
literal|7
case|:
case|case
literal|9
case|:
comment|/* variable big metrics */
if|if
condition|(
name|FT_STREAM_READ_FIELDS
argument_list|(
name|sbit_metrics_fields
argument_list|,
name|metrics
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
break|break;
case|case
literal|5
case|:
default|default:
comment|/* constant metrics */
if|if
condition|(
name|range
operator|->
name|index_format
operator|==
literal|2
operator|||
name|range
operator|->
name|index_format
operator|==
literal|5
condition|)
operator|*
name|metrics
operator|=
name|range
operator|->
name|metrics
expr_stmt|;
else|else
return|return
name|SFNT_Err_Invalid_File_Format
return|;
block|}
name|Exit
label|:
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    crop_bitmap                                                        */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Crops a bitmap to its tightest bounding box, and adjusts its       */
end_comment
begin_comment
comment|/*    metrics.                                                           */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<InOut>                                                               */
end_comment
begin_comment
comment|/*    map     :: The bitmap.                                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    metrics :: The corresponding metrics structure.                    */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|crop_bitmap
name|crop_bitmap
parameter_list|(
name|FT_Bitmap
modifier|*
name|map
parameter_list|,
name|TT_SBit_Metrics
name|metrics
parameter_list|)
block|{
comment|/***********************************************************************/
comment|/*                                                                     */
comment|/* In this situation, some bounding boxes of embedded bitmaps are too  */
comment|/* large.  We need to crop it to a reasonable size.                    */
comment|/*                                                                     */
comment|/*      ---------                                                      */
comment|/*      |       |                -----                                 */
comment|/*      |  ***  |                |***|                                 */
comment|/*      |   *   |                | * |                                 */
comment|/*      |   *   |    ------>     | * |                                 */
comment|/*      |   *   |                | * |                                 */
comment|/*      |   *   |                | * |                                 */
comment|/*      |  ***  |                |***|                                 */
comment|/*      ---------                -----                                 */
comment|/*                                                                     */
comment|/***********************************************************************/
name|FT_Int
name|rows
decl_stmt|,
name|count
decl_stmt|;
name|FT_Long
name|line_len
decl_stmt|;
name|FT_Byte
modifier|*
name|line
decl_stmt|;
comment|/***********************************************************************/
comment|/*                                                                     */
comment|/* first of all, check the top-most lines of the bitmap, and remove    */
comment|/* them if they're empty.                                              */
comment|/*                                                                     */
block|{
name|line
operator|=
operator|(
name|FT_Byte
operator|*
operator|)
name|map
operator|->
name|buffer
expr_stmt|;
name|rows
operator|=
name|map
operator|->
name|rows
expr_stmt|;
name|line_len
operator|=
name|map
operator|->
name|pitch
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|rows
condition|;
name|count
operator|++
control|)
block|{
name|FT_Byte
modifier|*
name|cur
init|=
name|line
decl_stmt|;
name|FT_Byte
modifier|*
name|limit
init|=
name|line
operator|+
name|line_len
decl_stmt|;
for|for
control|(
init|;
name|cur
operator|<
name|limit
condition|;
name|cur
operator|++
control|)
if|if
condition|(
name|cur
index|[
literal|0
index|]
condition|)
goto|goto
name|Found_Top
goto|;
comment|/* the current line was empty - skip to next one */
name|line
operator|=
name|limit
expr_stmt|;
block|}
name|Found_Top
label|:
comment|/* check that we have at least one filled line */
if|if
condition|(
name|count
operator|>=
name|rows
condition|)
goto|goto
name|Empty_Bitmap
goto|;
comment|/* now, crop the empty upper lines */
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|line
operator|=
operator|(
name|FT_Byte
operator|*
operator|)
name|map
operator|->
name|buffer
expr_stmt|;
name|FT_MEM_MOVE
argument_list|(
name|line
argument_list|,
name|line
operator|+
name|count
operator|*
name|line_len
argument_list|,
operator|(
name|rows
operator|-
name|count
operator|)
operator|*
name|line_len
argument_list|)
expr_stmt|;
name|metrics
operator|->
name|height
operator|=
call|(
name|FT_Byte
call|)
argument_list|(
name|metrics
operator|->
name|height
operator|-
name|count
argument_list|)
expr_stmt|;
name|metrics
operator|->
name|horiBearingY
operator|=
call|(
name|FT_Char
call|)
argument_list|(
name|metrics
operator|->
name|horiBearingY
operator|-
name|count
argument_list|)
expr_stmt|;
name|metrics
operator|->
name|vertBearingY
operator|=
call|(
name|FT_Char
call|)
argument_list|(
name|metrics
operator|->
name|vertBearingY
operator|-
name|count
argument_list|)
expr_stmt|;
name|map
operator|->
name|rows
operator|-=
name|count
expr_stmt|;
name|rows
operator|-=
name|count
expr_stmt|;
block|}
block|}
comment|/***********************************************************************/
comment|/*                                                                     */
comment|/* second, crop the lower lines                                        */
comment|/*                                                                     */
block|{
name|line
operator|=
operator|(
name|FT_Byte
operator|*
operator|)
name|map
operator|->
name|buffer
operator|+
operator|(
name|rows
operator|-
literal|1
operator|)
operator|*
name|line_len
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|rows
condition|;
name|count
operator|++
control|)
block|{
name|FT_Byte
modifier|*
name|cur
init|=
name|line
decl_stmt|;
name|FT_Byte
modifier|*
name|limit
init|=
name|line
operator|+
name|line_len
decl_stmt|;
for|for
control|(
init|;
name|cur
operator|<
name|limit
condition|;
name|cur
operator|++
control|)
if|if
condition|(
name|cur
index|[
literal|0
index|]
condition|)
goto|goto
name|Found_Bottom
goto|;
comment|/* the current line was empty - skip to previous one */
name|line
operator|-=
name|line_len
expr_stmt|;
block|}
name|Found_Bottom
label|:
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|metrics
operator|->
name|height
operator|=
call|(
name|FT_Byte
call|)
argument_list|(
name|metrics
operator|->
name|height
operator|-
name|count
argument_list|)
expr_stmt|;
name|rows
operator|-=
name|count
expr_stmt|;
name|map
operator|->
name|rows
operator|-=
name|count
expr_stmt|;
block|}
block|}
comment|/***********************************************************************/
comment|/*                                                                     */
comment|/* third, get rid of the space on the left side of the glyph           */
comment|/*                                                                     */
do|do
block|{
name|FT_Byte
modifier|*
name|limit
decl_stmt|;
name|line
operator|=
operator|(
name|FT_Byte
operator|*
operator|)
name|map
operator|->
name|buffer
expr_stmt|;
name|limit
operator|=
name|line
operator|+
name|rows
operator|*
name|line_len
expr_stmt|;
for|for
control|(
init|;
name|line
operator|<
name|limit
condition|;
name|line
operator|+=
name|line_len
control|)
if|if
condition|(
name|line
index|[
literal|0
index|]
operator|&
literal|0x80
condition|)
goto|goto
name|Found_Left
goto|;
comment|/* shift the whole glyph one pixel to the left */
name|line
operator|=
operator|(
name|FT_Byte
operator|*
operator|)
name|map
operator|->
name|buffer
expr_stmt|;
name|limit
operator|=
name|line
operator|+
name|rows
operator|*
name|line_len
expr_stmt|;
for|for
control|(
init|;
name|line
operator|<
name|limit
condition|;
name|line
operator|+=
name|line_len
control|)
block|{
name|FT_Int
name|n
decl_stmt|,
name|width
init|=
name|map
operator|->
name|width
decl_stmt|;
name|FT_Byte
name|old
decl_stmt|;
name|FT_Byte
modifier|*
name|cur
init|=
name|line
decl_stmt|;
name|old
operator|=
call|(
name|FT_Byte
call|)
argument_list|(
name|cur
index|[
literal|0
index|]
operator|<<
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|8
init|;
name|n
operator|<
name|width
condition|;
name|n
operator|+=
literal|8
control|)
block|{
name|FT_Byte
name|val
decl_stmt|;
name|val
operator|=
name|cur
index|[
literal|1
index|]
expr_stmt|;
name|cur
index|[
literal|0
index|]
operator|=
call|(
name|FT_Byte
call|)
argument_list|(
name|old
operator||
operator|(
name|val
operator|>>
literal|7
operator|)
argument_list|)
expr_stmt|;
name|old
operator|=
call|(
name|FT_Byte
call|)
argument_list|(
name|val
operator|<<
literal|1
argument_list|)
expr_stmt|;
name|cur
operator|++
expr_stmt|;
block|}
name|cur
index|[
literal|0
index|]
operator|=
name|old
expr_stmt|;
block|}
name|map
operator|->
name|width
operator|--
expr_stmt|;
name|metrics
operator|->
name|horiBearingX
operator|++
expr_stmt|;
name|metrics
operator|->
name|vertBearingX
operator|++
expr_stmt|;
name|metrics
operator|->
name|width
operator|--
expr_stmt|;
block|}
do|while
condition|(
name|map
operator|->
name|width
operator|>
literal|0
condition|)
do|;
name|Found_Left
label|:
comment|/***********************************************************************/
comment|/*                                                                     */
comment|/* finally, crop the bitmap width to get rid of the space on the right */
comment|/* side of the glyph.                                                  */
comment|/*                                                                     */
do|do
block|{
name|FT_Int
name|right
init|=
name|map
operator|->
name|width
operator|-
literal|1
decl_stmt|;
name|FT_Byte
modifier|*
name|limit
decl_stmt|;
name|FT_Byte
name|mask
decl_stmt|;
name|line
operator|=
operator|(
name|FT_Byte
operator|*
operator|)
name|map
operator|->
name|buffer
operator|+
operator|(
name|right
operator|>>
literal|3
operator|)
expr_stmt|;
name|limit
operator|=
name|line
operator|+
name|rows
operator|*
name|line_len
expr_stmt|;
name|mask
operator|=
call|(
name|FT_Byte
call|)
argument_list|(
literal|0x80
operator|>>
operator|(
name|right
operator|&
literal|7
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|line
operator|<
name|limit
condition|;
name|line
operator|+=
name|line_len
control|)
if|if
condition|(
name|line
index|[
literal|0
index|]
operator|&
name|mask
condition|)
goto|goto
name|Found_Right
goto|;
comment|/* crop the whole glyph to the right */
name|map
operator|->
name|width
operator|--
expr_stmt|;
name|metrics
operator|->
name|width
operator|--
expr_stmt|;
block|}
do|while
condition|(
name|map
operator|->
name|width
operator|>
literal|0
condition|)
do|;
name|Found_Right
label|:
comment|/* all right, the bitmap was cropped */
return|return;
name|Empty_Bitmap
label|:
name|map
operator|->
name|width
operator|=
literal|0
expr_stmt|;
name|map
operator|->
name|rows
operator|=
literal|0
expr_stmt|;
name|map
operator|->
name|pitch
operator|=
literal|0
expr_stmt|;
name|map
operator|->
name|pixel_mode
operator|=
name|FT_PIXEL_MODE_MONO
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|Load_SBit_Single
name|Load_SBit_Single
parameter_list|(
name|FT_Bitmap
modifier|*
name|map
parameter_list|,
name|FT_Int
name|x_offset
parameter_list|,
name|FT_Int
name|y_offset
parameter_list|,
name|FT_Int
name|pix_bits
parameter_list|,
name|FT_UShort
name|image_format
parameter_list|,
name|TT_SBit_Metrics
name|metrics
parameter_list|,
name|FT_Stream
name|stream
parameter_list|)
block|{
name|FT_Error
name|error
decl_stmt|;
comment|/* check that the source bitmap fits into the target pixmap */
if|if
condition|(
name|x_offset
operator|<
literal|0
operator|||
name|x_offset
operator|+
name|metrics
operator|->
name|width
operator|>
name|map
operator|->
name|width
operator|||
name|y_offset
operator|<
literal|0
operator|||
name|y_offset
operator|+
name|metrics
operator|->
name|height
operator|>
name|map
operator|->
name|rows
condition|)
block|{
name|error
operator|=
name|SFNT_Err_Invalid_Argument
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|{
name|FT_Int
name|glyph_width
init|=
name|metrics
operator|->
name|width
decl_stmt|;
name|FT_Int
name|glyph_height
init|=
name|metrics
operator|->
name|height
decl_stmt|;
name|FT_Int
name|glyph_size
decl_stmt|;
name|FT_Int
name|line_bits
init|=
name|pix_bits
operator|*
name|glyph_width
decl_stmt|;
name|FT_Bool
name|pad_bytes
init|=
literal|0
decl_stmt|;
comment|/* compute size of glyph image */
switch|switch
condition|(
name|image_format
condition|)
block|{
case|case
literal|1
case|:
comment|/* byte-padded formats */
case|case
literal|6
case|:
block|{
name|FT_Int
name|line_length
decl_stmt|;
switch|switch
condition|(
name|pix_bits
condition|)
block|{
case|case
literal|1
case|:
name|line_length
operator|=
operator|(
name|glyph_width
operator|+
literal|7
operator|)
operator|>>
literal|3
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|line_length
operator|=
operator|(
name|glyph_width
operator|+
literal|3
operator|)
operator|>>
literal|2
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|line_length
operator|=
operator|(
name|glyph_width
operator|+
literal|1
operator|)
operator|>>
literal|1
expr_stmt|;
break|break;
default|default:
name|line_length
operator|=
name|glyph_width
expr_stmt|;
block|}
name|glyph_size
operator|=
name|glyph_height
operator|*
name|line_length
expr_stmt|;
name|pad_bytes
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
case|case
literal|5
case|:
case|case
literal|7
case|:
name|line_bits
operator|=
name|glyph_width
operator|*
name|pix_bits
expr_stmt|;
name|glyph_size
operator|=
operator|(
name|glyph_height
operator|*
name|line_bits
operator|+
literal|7
operator|)
operator|>>
literal|3
expr_stmt|;
break|break;
default|default:
comment|/* invalid format */
return|return
name|SFNT_Err_Invalid_File_Format
return|;
block|}
comment|/* Now read data and draw glyph into target pixmap       */
if|if
condition|(
name|FT_FRAME_ENTER
argument_list|(
name|glyph_size
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
comment|/* don't forget to multiply `x_offset' by `map->pix_bits' as */
comment|/* the sbit blitter doesn't make a difference between pixmap */
comment|/* depths.                                                   */
name|blit_sbit
argument_list|(
name|map
argument_list|,
operator|(
name|FT_Byte
operator|*
operator|)
name|stream
operator|->
name|cursor
argument_list|,
name|line_bits
argument_list|,
name|pad_bytes
argument_list|,
name|x_offset
operator|*
name|pix_bits
argument_list|,
name|y_offset
argument_list|,
name|metrics
operator|->
name|height
argument_list|)
expr_stmt|;
name|FT_FRAME_EXIT
argument_list|()
expr_stmt|;
block|}
name|Exit
label|:
return|return
name|error
return|;
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|Load_SBit_Image
name|Load_SBit_Image
parameter_list|(
name|TT_SBit_Strike
name|strike
parameter_list|,
name|TT_SBit_Range
name|range
parameter_list|,
name|FT_ULong
name|ebdt_pos
parameter_list|,
name|FT_ULong
name|glyph_offset
parameter_list|,
name|FT_GlyphSlot
name|slot
parameter_list|,
name|FT_Int
name|x_offset
parameter_list|,
name|FT_Int
name|y_offset
parameter_list|,
name|FT_Stream
name|stream
parameter_list|,
name|TT_SBit_Metrics
name|metrics
parameter_list|,
name|FT_Int
name|depth
parameter_list|)
block|{
name|FT_Memory
name|memory
init|=
name|stream
operator|->
name|memory
decl_stmt|;
name|FT_Bitmap
modifier|*
name|map
init|=
operator|&
name|slot
operator|->
name|bitmap
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
comment|/* place stream at beginning of glyph data and read metrics */
if|if
condition|(
name|FT_STREAM_SEEK
argument_list|(
name|ebdt_pos
operator|+
name|glyph_offset
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|error
operator|=
name|tt_load_sbit_metrics
argument_list|(
name|stream
argument_list|,
name|range
argument_list|,
name|metrics
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
comment|/* This function is recursive.  At the top-level call, we  */
comment|/* compute the dimensions of the higher-level glyph to     */
comment|/* allocate the final pixmap buffer.                       */
if|if
condition|(
name|depth
operator|==
literal|0
condition|)
block|{
name|FT_Long
name|size
decl_stmt|;
name|map
operator|->
name|width
operator|=
name|metrics
operator|->
name|width
expr_stmt|;
name|map
operator|->
name|rows
operator|=
name|metrics
operator|->
name|height
expr_stmt|;
switch|switch
condition|(
name|strike
operator|->
name|bit_depth
condition|)
block|{
case|case
literal|1
case|:
name|map
operator|->
name|pixel_mode
operator|=
name|FT_PIXEL_MODE_MONO
expr_stmt|;
name|map
operator|->
name|pitch
operator|=
operator|(
name|map
operator|->
name|width
operator|+
literal|7
operator|)
operator|>>
literal|3
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|map
operator|->
name|pixel_mode
operator|=
name|FT_PIXEL_MODE_GRAY2
expr_stmt|;
name|map
operator|->
name|pitch
operator|=
operator|(
name|map
operator|->
name|width
operator|+
literal|3
operator|)
operator|>>
literal|2
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|map
operator|->
name|pixel_mode
operator|=
name|FT_PIXEL_MODE_GRAY4
expr_stmt|;
name|map
operator|->
name|pitch
operator|=
operator|(
name|map
operator|->
name|width
operator|+
literal|1
operator|)
operator|>>
literal|1
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|map
operator|->
name|pixel_mode
operator|=
name|FT_PIXEL_MODE_GRAY
expr_stmt|;
name|map
operator|->
name|pitch
operator|=
name|map
operator|->
name|width
expr_stmt|;
break|break;
default|default:
return|return
name|SFNT_Err_Invalid_File_Format
return|;
block|}
name|size
operator|=
name|map
operator|->
name|rows
operator|*
name|map
operator|->
name|pitch
expr_stmt|;
comment|/* check that there is no empty image */
if|if
condition|(
name|size
operator|==
literal|0
condition|)
goto|goto
name|Exit
goto|;
comment|/* exit successfully! */
name|error
operator|=
name|ft_glyphslot_alloc_bitmap
argument_list|(
name|slot
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
block|}
switch|switch
condition|(
name|range
operator|->
name|image_format
condition|)
block|{
case|case
literal|1
case|:
comment|/* single sbit image - load it */
case|case
literal|2
case|:
case|case
literal|5
case|:
case|case
literal|6
case|:
case|case
literal|7
case|:
return|return
name|Load_SBit_Single
argument_list|(
name|map
argument_list|,
name|x_offset
argument_list|,
name|y_offset
argument_list|,
name|strike
operator|->
name|bit_depth
argument_list|,
name|range
operator|->
name|image_format
argument_list|,
name|metrics
argument_list|,
name|stream
argument_list|)
return|;
case|case
literal|8
case|:
comment|/* compound format */
if|if
condition|(
name|FT_STREAM_SKIP
argument_list|(
literal|1L
argument_list|)
condition|)
block|{
name|error
operator|=
name|SFNT_Err_Invalid_Stream_Skip
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* fallthrough */
case|case
literal|9
case|:
break|break;
default|default:
comment|/* invalid image format */
return|return
name|SFNT_Err_Invalid_File_Format
return|;
block|}
comment|/* All right, we have a compound format.  First of all, read */
comment|/* the array of elements.                                    */
block|{
name|TT_SBit_Component
name|components
decl_stmt|;
name|TT_SBit_Component
name|comp
decl_stmt|;
name|FT_UShort
name|num_components
decl_stmt|,
name|count
decl_stmt|;
if|if
condition|(
name|FT_READ_USHORT
argument_list|(
name|num_components
argument_list|)
operator|||
name|FT_NEW_ARRAY
argument_list|(
name|components
argument_list|,
name|num_components
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|count
operator|=
name|num_components
expr_stmt|;
if|if
condition|(
name|FT_FRAME_ENTER
argument_list|(
literal|4L
operator|*
name|num_components
argument_list|)
condition|)
goto|goto
name|Fail_Memory
goto|;
for|for
control|(
name|comp
operator|=
name|components
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
operator|,
name|comp
operator|++
control|)
block|{
name|comp
operator|->
name|glyph_code
operator|=
name|FT_GET_USHORT
argument_list|()
expr_stmt|;
name|comp
operator|->
name|x_offset
operator|=
name|FT_GET_CHAR
argument_list|()
expr_stmt|;
name|comp
operator|->
name|y_offset
operator|=
name|FT_GET_CHAR
argument_list|()
expr_stmt|;
block|}
name|FT_FRAME_EXIT
argument_list|()
expr_stmt|;
comment|/* Now recursively load each element glyph */
name|count
operator|=
name|num_components
expr_stmt|;
name|comp
operator|=
name|components
expr_stmt|;
for|for
control|(
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
operator|,
name|comp
operator|++
control|)
block|{
name|TT_SBit_Range
name|elem_range
decl_stmt|;
name|TT_SBit_MetricsRec
name|elem_metrics
decl_stmt|;
name|FT_ULong
name|elem_offset
decl_stmt|;
comment|/* find the range for this element */
name|error
operator|=
name|find_sbit_range
argument_list|(
name|comp
operator|->
name|glyph_code
argument_list|,
name|strike
argument_list|,
operator|&
name|elem_range
argument_list|,
operator|&
name|elem_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Fail_Memory
goto|;
comment|/* now load the element, recursively */
name|error
operator|=
name|Load_SBit_Image
argument_list|(
name|strike
argument_list|,
name|elem_range
argument_list|,
name|ebdt_pos
argument_list|,
name|elem_offset
argument_list|,
name|slot
argument_list|,
name|x_offset
operator|+
name|comp
operator|->
name|x_offset
argument_list|,
name|y_offset
operator|+
name|comp
operator|->
name|y_offset
argument_list|,
name|stream
argument_list|,
operator|&
name|elem_metrics
argument_list|,
name|depth
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Fail_Memory
goto|;
block|}
name|Fail_Memory
label|:
name|FT_FREE
argument_list|(
name|components
argument_list|)
expr_stmt|;
block|}
name|Exit
label|:
return|return
name|error
return|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    tt_face_load_sbit_image                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Loads a given glyph sbit image from the font resource.  This also  */
end_comment
begin_comment
comment|/*    returns its metrics.                                               */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    face         :: The target face object.                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    strike_index :: The current strike index.                          */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    glyph_index  :: The current glyph index.                           */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    load_flags   :: The glyph load flags (the code checks for the flag */
end_comment
begin_comment
comment|/*                    FT_LOAD_CROP_BITMAP).                              */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    stream       :: The input stream.                                  */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Output>                                                              */
end_comment
begin_comment
comment|/*    map          :: The target pixmap.                                 */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    metrics      :: A big sbit metrics structure for the glyph image.  */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    FreeType error code.  0 means success.  Returns an error if no     */
end_comment
begin_comment
comment|/*    glyph sbit exists for the index.                                   */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Note>                                                               */
end_comment
begin_comment
comment|/*    The `map.buffer' field is always freed before the glyph is loaded. */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|tt_face_load_sbit_image
argument_list|(
argument|TT_Face              face
argument_list|,
argument|FT_ULong             strike_index
argument_list|,
argument|FT_UInt              glyph_index
argument_list|,
argument|FT_UInt              load_flags
argument_list|,
argument|FT_Stream            stream
argument_list|,
argument|FT_Bitmap           *map
argument_list|,
argument|TT_SBit_MetricsRec  *metrics
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
decl_stmt|;
name|FT_ULong
name|ebdt_pos
decl_stmt|,
name|glyph_offset
decl_stmt|;
name|TT_SBit_Strike
name|strike
decl_stmt|;
name|TT_SBit_Range
name|range
decl_stmt|;
comment|/* Check whether there is a glyph sbit for the current index */
name|error
operator|=
name|tt_find_sbit_image
argument_list|(
name|face
argument_list|,
name|glyph_index
argument_list|,
name|strike_index
argument_list|,
operator|&
name|range
argument_list|,
operator|&
name|strike
argument_list|,
operator|&
name|glyph_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
comment|/* now, find the location of the `EBDT' table in */
comment|/* the font file                                 */
name|error
operator|=
name|face
operator|->
name|goto_table
argument_list|(
name|face
argument_list|,
name|TTAG_EBDT
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|error
operator|=
name|face
operator|->
name|goto_table
argument_list|(
name|face
argument_list|,
name|TTAG_bdat
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|ebdt_pos
operator|=
name|FT_STREAM_POS
argument_list|()
expr_stmt|;
name|error
operator|=
name|Load_SBit_Image
argument_list|(
name|strike
argument_list|,
name|range
argument_list|,
name|ebdt_pos
argument_list|,
name|glyph_offset
argument_list|,
name|face
operator|->
name|root
operator|.
name|glyph
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|,
name|metrics
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
comment|/* setup vertical metrics if needed */
if|if
condition|(
name|strike
operator|->
name|flags
operator|&
literal|1
condition|)
block|{
comment|/* in case of a horizontal strike only */
name|FT_Int
name|advance
decl_stmt|;
name|advance
operator|=
name|strike
operator|->
name|hori
operator|.
name|ascender
operator|-
name|strike
operator|->
name|hori
operator|.
name|descender
expr_stmt|;
comment|/* some heuristic values */
name|metrics
operator|->
name|vertBearingX
operator|=
call|(
name|FT_Char
call|)
argument_list|(
operator|-
name|metrics
operator|->
name|width
operator|/
literal|2
argument_list|)
expr_stmt|;
name|metrics
operator|->
name|vertBearingY
operator|=
call|(
name|FT_Char
call|)
argument_list|(
operator|(
name|advance
operator|-
name|metrics
operator|->
name|height
operator|)
operator|/
literal|2
argument_list|)
expr_stmt|;
name|metrics
operator|->
name|vertAdvance
operator|=
call|(
name|FT_Char
call|)
argument_list|(
name|advance
operator|*
literal|12
operator|/
literal|10
argument_list|)
expr_stmt|;
block|}
comment|/* Crop the bitmap now, unless specified otherwise */
if|if
condition|(
name|load_flags
operator|&
name|FT_LOAD_CROP_BITMAP
condition|)
name|crop_bitmap
argument_list|(
name|map
argument_list|,
name|metrics
argument_list|)
expr_stmt|;
name|Exit
label|:
return|return
name|error
return|;
block|}
end_block
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* FT_CONFIG_OPTION_OLD_INTERNALS */
end_comment
begin_comment
comment|/* END */
end_comment
end_unit
