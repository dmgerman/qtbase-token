begin_unit
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  ttbdf.c                                                                */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*    TrueType and OpenType embedded BDF properties (body).                */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  Copyright 2005, 2006 by                                                */
end_comment
begin_comment
comment|/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  This file is part of the FreeType project, and may only be used,       */
end_comment
begin_comment
comment|/*  modified, and distributed under the terms of the FreeType project      */
end_comment
begin_comment
comment|/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
end_comment
begin_comment
comment|/*  this file you indicate that you have read the license and              */
end_comment
begin_comment
comment|/*  understand and accept it fully.                                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<ft2build.h>
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_DEBUG_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_STREAM_H
end_include
begin_include
include|#
directive|include
include|FT_TRUETYPE_TAGS_H
end_include
begin_include
include|#
directive|include
file|"ttbdf.h"
end_include
begin_include
include|#
directive|include
file|"sferrors.h"
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_BDF
end_ifdef
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
end_comment
begin_comment
comment|/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
end_comment
begin_comment
comment|/* messages during execution.                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_undef
DECL|macro|FT_COMPONENT
undef|#
directive|undef
name|FT_COMPONENT
end_undef
begin_define
DECL|macro|FT_COMPONENT
define|#
directive|define
name|FT_COMPONENT
value|trace_ttbdf
end_define
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|tt_face_free_bdf_props
name|tt_face_free_bdf_props
argument_list|(
argument|TT_Face  face
argument_list|)
end_macro
begin_block
block|{
name|TT_BDF
name|bdf
init|=
operator|&
name|face
operator|->
name|bdf
decl_stmt|;
if|if
condition|(
name|bdf
operator|->
name|loaded
condition|)
block|{
name|FT_Stream
name|stream
init|=
name|FT_FACE
argument_list|(
name|face
argument_list|)
operator|->
name|stream
decl_stmt|;
if|if
condition|(
name|bdf
operator|->
name|table
operator|!=
name|NULL
condition|)
name|FT_FRAME_RELEASE
argument_list|(
name|bdf
operator|->
name|table
argument_list|)
expr_stmt|;
name|bdf
operator|->
name|table_end
operator|=
name|NULL
expr_stmt|;
name|bdf
operator|->
name|strings
operator|=
name|NULL
expr_stmt|;
name|bdf
operator|->
name|strings_size
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block
begin_function
specifier|static
name|FT_Error
DECL|function|tt_face_load_bdf_props
name|tt_face_load_bdf_props
parameter_list|(
name|TT_Face
name|face
parameter_list|,
name|FT_Stream
name|stream
parameter_list|)
block|{
name|TT_BDF
name|bdf
init|=
operator|&
name|face
operator|->
name|bdf
decl_stmt|;
name|FT_ULong
name|length
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|FT_ZERO
argument_list|(
name|bdf
argument_list|)
expr_stmt|;
name|error
operator|=
name|tt_face_goto_table
argument_list|(
name|face
argument_list|,
name|TTAG_BDF
argument_list|,
name|stream
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|length
operator|<
literal|8
operator|||
name|FT_FRAME_EXTRACT
argument_list|(
name|length
argument_list|,
name|bdf
operator|->
name|table
argument_list|)
condition|)
block|{
name|error
operator|=
name|FT_Err_Invalid_Table
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|bdf
operator|->
name|table_end
operator|=
name|bdf
operator|->
name|table
operator|+
name|length
expr_stmt|;
block|{
name|FT_Byte
modifier|*
name|p
init|=
name|bdf
operator|->
name|table
decl_stmt|;
name|FT_UInt
name|version
init|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|FT_UInt
name|num_strikes
init|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|FT_ULong
name|strings
init|=
name|FT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|FT_UInt
name|count
decl_stmt|;
name|FT_Byte
modifier|*
name|strike
decl_stmt|;
if|if
condition|(
name|version
operator|!=
literal|0x0001
operator|||
name|strings
operator|<
literal|8
operator|||
operator|(
name|strings
operator|-
literal|8
operator|)
operator|/
literal|4
operator|<
name|num_strikes
operator|||
name|strings
operator|+
literal|1
operator|>
name|length
condition|)
block|{
goto|goto
name|BadTable
goto|;
block|}
name|bdf
operator|->
name|num_strikes
operator|=
name|num_strikes
expr_stmt|;
name|bdf
operator|->
name|strings
operator|=
name|bdf
operator|->
name|table
operator|+
name|strings
expr_stmt|;
name|bdf
operator|->
name|strings_size
operator|=
name|length
operator|-
name|strings
expr_stmt|;
name|count
operator|=
name|bdf
operator|->
name|num_strikes
expr_stmt|;
name|p
operator|=
name|bdf
operator|->
name|table
operator|+
literal|8
expr_stmt|;
name|strike
operator|=
name|p
operator|+
name|count
operator|*
literal|4
expr_stmt|;
for|for
control|(
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
control|)
block|{
name|FT_UInt
name|num_items
init|=
name|FT_PEEK_USHORT
argument_list|(
name|p
operator|+
literal|2
argument_list|)
decl_stmt|;
comment|/*          *  We don't need to check the value sets themselves, since this          *  is done later.          */
name|strike
operator|+=
literal|10
operator|*
name|num_items
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|strike
operator|>
name|bdf
operator|->
name|strings
condition|)
goto|goto
name|BadTable
goto|;
block|}
name|bdf
operator|->
name|loaded
operator|=
literal|1
expr_stmt|;
name|Exit
label|:
return|return
name|error
return|;
name|BadTable
label|:
name|FT_FRAME_RELEASE
argument_list|(
name|bdf
operator|->
name|table
argument_list|)
expr_stmt|;
name|FT_ZERO
argument_list|(
name|bdf
argument_list|)
expr_stmt|;
name|error
operator|=
name|FT_Err_Invalid_Table
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
end_function
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|tt_face_find_bdf_prop
argument_list|(
argument|TT_Face           face
argument_list|,
argument|const char*       property_name
argument_list|,
argument|BDF_PropertyRec  *aprop
argument_list|)
end_macro
begin_block
block|{
name|TT_BDF
name|bdf
init|=
operator|&
name|face
operator|->
name|bdf
decl_stmt|;
name|FT_Size
name|size
init|=
name|FT_FACE
argument_list|(
name|face
argument_list|)
operator|->
name|size
decl_stmt|;
name|FT_Error
name|error
init|=
literal|0
decl_stmt|;
name|FT_Byte
modifier|*
name|p
decl_stmt|;
name|FT_UInt
name|count
decl_stmt|;
name|FT_Byte
modifier|*
name|strike
decl_stmt|;
name|FT_Offset
name|property_len
decl_stmt|;
name|aprop
operator|->
name|type
operator|=
name|BDF_PROPERTY_TYPE_NONE
expr_stmt|;
if|if
condition|(
name|bdf
operator|->
name|loaded
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|tt_face_load_bdf_props
argument_list|(
name|face
argument_list|,
name|FT_FACE
argument_list|(
name|face
argument_list|)
operator|->
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
block|}
name|count
operator|=
name|bdf
operator|->
name|num_strikes
expr_stmt|;
name|p
operator|=
name|bdf
operator|->
name|table
operator|+
literal|8
expr_stmt|;
name|strike
operator|=
name|p
operator|+
literal|4
operator|*
name|count
expr_stmt|;
name|error
operator|=
name|FT_Err_Invalid_Argument
expr_stmt|;
if|if
condition|(
name|size
operator|==
name|NULL
operator|||
name|property_name
operator|==
name|NULL
condition|)
goto|goto
name|Exit
goto|;
name|property_len
operator|=
name|ft_strlen
argument_list|(
name|property_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|property_len
operator|==
literal|0
condition|)
goto|goto
name|Exit
goto|;
for|for
control|(
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
control|)
block|{
name|FT_UInt
name|_ppem
init|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|FT_UInt
name|_count
init|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|_ppem
operator|==
name|size
operator|->
name|metrics
operator|.
name|y_ppem
condition|)
block|{
name|count
operator|=
name|_count
expr_stmt|;
goto|goto
name|FoundStrike
goto|;
block|}
name|strike
operator|+=
literal|10
operator|*
name|_count
expr_stmt|;
block|}
goto|goto
name|Exit
goto|;
name|FoundStrike
label|:
name|p
operator|=
name|strike
expr_stmt|;
for|for
control|(
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
control|)
block|{
name|FT_UInt
name|type
init|=
name|FT_PEEK_USHORT
argument_list|(
name|p
operator|+
literal|4
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|type
operator|&
literal|0x10
operator|)
operator|!=
literal|0
condition|)
block|{
name|FT_UInt32
name|name_offset
init|=
name|FT_PEEK_ULONG
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|FT_UInt32
name|value
init|=
name|FT_PEEK_ULONG
argument_list|(
name|p
operator|+
literal|6
argument_list|)
decl_stmt|;
comment|/* be a bit paranoid for invalid entries here */
if|if
condition|(
name|name_offset
operator|<
name|bdf
operator|->
name|strings_size
operator|&&
name|property_len
operator|<
name|bdf
operator|->
name|strings_size
operator|-
name|name_offset
operator|&&
name|ft_strncmp
argument_list|(
name|property_name
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|bdf
operator|->
name|strings
operator|+
name|name_offset
argument_list|,
name|bdf
operator|->
name|strings_size
operator|-
name|name_offset
argument_list|)
operator|==
literal|0
condition|)
block|{
switch|switch
condition|(
name|type
operator|&
literal|0x0F
condition|)
block|{
case|case
literal|0x00
case|:
comment|/* string */
case|case
literal|0x01
case|:
comment|/* atoms */
comment|/* check that the content is really 0-terminated */
if|if
condition|(
name|value
operator|<
name|bdf
operator|->
name|strings_size
operator|&&
name|ft_memchr
argument_list|(
name|bdf
operator|->
name|strings
operator|+
name|value
argument_list|,
literal|0
argument_list|,
name|bdf
operator|->
name|strings_size
argument_list|)
condition|)
block|{
name|aprop
operator|->
name|type
operator|=
name|BDF_PROPERTY_TYPE_ATOM
expr_stmt|;
name|aprop
operator|->
name|u
operator|.
name|atom
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|bdf
operator|->
name|strings
operator|+
name|value
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
break|break;
case|case
literal|0x02
case|:
name|aprop
operator|->
name|type
operator|=
name|BDF_PROPERTY_TYPE_INTEGER
expr_stmt|;
name|aprop
operator|->
name|u
operator|.
name|integer
operator|=
operator|(
name|FT_Int32
operator|)
name|value
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
goto|goto
name|Exit
goto|;
case|case
literal|0x03
case|:
name|aprop
operator|->
name|type
operator|=
name|BDF_PROPERTY_TYPE_CARDINAL
expr_stmt|;
name|aprop
operator|->
name|u
operator|.
name|cardinal
operator|=
name|value
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
goto|goto
name|Exit
goto|;
default|default:
empty_stmt|;
block|}
block|}
block|}
name|p
operator|+=
literal|10
expr_stmt|;
block|}
name|Exit
label|:
return|return
name|error
return|;
block|}
end_block
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* TT_CONFIG_OPTION_BDF */
end_comment
begin_comment
comment|/* END */
end_comment
end_unit
