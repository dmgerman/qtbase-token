begin_unit
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  t1parse.c                                                              */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*    Type 1 parser (body).                                                */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2008, 2009 by             */
end_comment
begin_comment
comment|/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  This file is part of the FreeType project, and may only be used,       */
end_comment
begin_comment
comment|/*  modified, and distributed under the terms of the FreeType project      */
end_comment
begin_comment
comment|/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
end_comment
begin_comment
comment|/*  this file you indicate that you have read the license and              */
end_comment
begin_comment
comment|/*  understand and accept it fully.                                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* The Type 1 parser is in charge of the following:                      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*  - provide an implementation of a growing sequence of objects called  */
end_comment
begin_comment
comment|/*    a `T1_Table' (used to build various tables needed by the loader).  */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*  - opening .pfb and .pfa files to extract their top-level and private */
end_comment
begin_comment
comment|/*    dictionaries.                                                      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*  - read numbers, arrays& strings from any dictionary.                */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* See `t1load.c' to see how data is loaded from the font file.          */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<ft2build.h>
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_DEBUG_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_STREAM_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_POSTSCRIPT_AUX_H
end_include
begin_include
include|#
directive|include
file|"t1parse.h"
end_include
begin_include
include|#
directive|include
file|"t1errors.h"
end_include
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
end_comment
begin_comment
comment|/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
end_comment
begin_comment
comment|/* messages during execution.                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_undef
DECL|macro|FT_COMPONENT
undef|#
directive|undef
name|FT_COMPONENT
end_undef
begin_define
DECL|macro|FT_COMPONENT
define|#
directive|define
name|FT_COMPONENT
value|trace_t1parse
end_define
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****                   INPUT STREAM PARSER                         *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/* see Adobe Technical Note 5040.Download_Fonts.pdf */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|read_pfb_tag
name|read_pfb_tag
parameter_list|(
name|FT_Stream
name|stream
parameter_list|,
name|FT_UShort
modifier|*
name|atag
parameter_list|,
name|FT_ULong
modifier|*
name|asize
parameter_list|)
block|{
name|FT_Error
name|error
decl_stmt|;
name|FT_UShort
name|tag
decl_stmt|;
name|FT_ULong
name|size
decl_stmt|;
operator|*
name|atag
operator|=
literal|0
expr_stmt|;
operator|*
name|asize
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|FT_READ_USHORT
argument_list|(
name|tag
argument_list|)
condition|)
block|{
if|if
condition|(
name|tag
operator|==
literal|0x8001U
operator|||
name|tag
operator|==
literal|0x8002U
condition|)
block|{
if|if
condition|(
operator|!
name|FT_READ_ULONG_LE
argument_list|(
name|size
argument_list|)
condition|)
operator|*
name|asize
operator|=
name|size
expr_stmt|;
block|}
operator|*
name|atag
operator|=
name|tag
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|check_type1_format
name|check_type1_format
parameter_list|(
name|FT_Stream
name|stream
parameter_list|,
specifier|const
name|char
modifier|*
name|header_string
parameter_list|,
name|size_t
name|header_length
parameter_list|)
block|{
name|FT_Error
name|error
decl_stmt|;
name|FT_UShort
name|tag
decl_stmt|;
name|FT_ULong
name|dummy
decl_stmt|;
if|if
condition|(
name|FT_STREAM_SEEK
argument_list|(
literal|0
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|error
operator|=
name|read_pfb_tag
argument_list|(
name|stream
argument_list|,
operator|&
name|tag
argument_list|,
operator|&
name|dummy
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
comment|/* We assume that the first segment in a PFB is always encoded as   */
comment|/* text.  This might be wrong (and the specification doesn't insist */
comment|/* on that), but we have never seen a counterexample.               */
if|if
condition|(
name|tag
operator|!=
literal|0x8001U
operator|&&
name|FT_STREAM_SEEK
argument_list|(
literal|0
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
if|if
condition|(
operator|!
name|FT_FRAME_ENTER
argument_list|(
name|header_length
argument_list|)
condition|)
block|{
name|error
operator|=
name|T1_Err_Ok
expr_stmt|;
if|if
condition|(
name|ft_memcmp
argument_list|(
name|stream
operator|->
name|cursor
argument_list|,
name|header_string
argument_list|,
name|header_length
argument_list|)
operator|!=
literal|0
condition|)
name|error
operator|=
name|T1_Err_Unknown_File_Format
expr_stmt|;
name|FT_FRAME_EXIT
argument_list|()
expr_stmt|;
block|}
name|Exit
label|:
return|return
name|error
return|;
block|}
end_function
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|T1_New_Parser
argument_list|(
argument|T1_Parser      parser
argument_list|,
argument|FT_Stream      stream
argument_list|,
argument|FT_Memory      memory
argument_list|,
argument|PSAux_Service  psaux
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
decl_stmt|;
name|FT_UShort
name|tag
decl_stmt|;
name|FT_ULong
name|size
decl_stmt|;
name|psaux
operator|->
name|ps_parser_funcs
operator|->
name|init
argument_list|(
operator|&
name|parser
operator|->
name|root
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|memory
argument_list|)
expr_stmt|;
name|parser
operator|->
name|stream
operator|=
name|stream
expr_stmt|;
name|parser
operator|->
name|base_len
operator|=
literal|0
expr_stmt|;
name|parser
operator|->
name|base_dict
operator|=
literal|0
expr_stmt|;
name|parser
operator|->
name|private_len
operator|=
literal|0
expr_stmt|;
name|parser
operator|->
name|private_dict
operator|=
literal|0
expr_stmt|;
name|parser
operator|->
name|in_pfb
operator|=
literal|0
expr_stmt|;
name|parser
operator|->
name|in_memory
operator|=
literal|0
expr_stmt|;
name|parser
operator|->
name|single_block
operator|=
literal|0
expr_stmt|;
comment|/* check the header format */
name|error
operator|=
name|check_type1_format
argument_list|(
name|stream
argument_list|,
literal|"%!PS-AdobeFont"
argument_list|,
literal|14
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|error
operator|!=
name|T1_Err_Unknown_File_Format
condition|)
goto|goto
name|Exit
goto|;
name|error
operator|=
name|check_type1_format
argument_list|(
name|stream
argument_list|,
literal|"%!FontType"
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|FT_TRACE2
argument_list|(
operator|(
literal|"[not a Type1 font]\n"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
comment|/******************************************************************/
comment|/*                                                                */
comment|/* Here a short summary of what is going on:                      */
comment|/*                                                                */
comment|/*   When creating a new Type 1 parser, we try to locate and load */
comment|/*   the base dictionary if this is possible (i.e., for PFB       */
comment|/*   files).  Otherwise, we load the whole font into memory.      */
comment|/*                                                                */
comment|/*   When `loading' the base dictionary, we only setup pointers   */
comment|/*   in the case of a memory-based stream.  Otherwise, we         */
comment|/*   allocate and load the base dictionary in it.                 */
comment|/*                                                                */
comment|/*   parser->in_pfb is set if we are in a binary (`.pfb') font.   */
comment|/*   parser->in_memory is set if we have a memory stream.         */
comment|/*                                                                */
comment|/* try to compute the size of the base dictionary;     */
comment|/* look for a Postscript binary file tag, i.e., 0x8001 */
if|if
condition|(
name|FT_STREAM_SEEK
argument_list|(
literal|0L
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|error
operator|=
name|read_pfb_tag
argument_list|(
name|stream
argument_list|,
operator|&
name|tag
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
if|if
condition|(
name|tag
operator|!=
literal|0x8001U
condition|)
block|{
comment|/* assume that this is a PFA file for now; an error will */
comment|/* be produced later when more things are checked        */
if|if
condition|(
name|FT_STREAM_SEEK
argument_list|(
literal|0L
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|size
operator|=
name|stream
operator|->
name|size
expr_stmt|;
block|}
else|else
name|parser
operator|->
name|in_pfb
operator|=
literal|1
expr_stmt|;
comment|/* now, try to load `size' bytes of the `base' dictionary we */
comment|/* found previously                                          */
comment|/* if it is a memory-based resource, set up pointers */
if|if
condition|(
operator|!
name|stream
operator|->
name|read
condition|)
block|{
name|parser
operator|->
name|base_dict
operator|=
operator|(
name|FT_Byte
operator|*
operator|)
name|stream
operator|->
name|base
operator|+
name|stream
operator|->
name|pos
expr_stmt|;
name|parser
operator|->
name|base_len
operator|=
name|size
expr_stmt|;
name|parser
operator|->
name|in_memory
operator|=
literal|1
expr_stmt|;
comment|/* check that the `size' field is valid */
if|if
condition|(
name|FT_STREAM_SKIP
argument_list|(
name|size
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
block|}
else|else
block|{
comment|/* read segment in memory -- this is clumsy, but so does the format */
if|if
condition|(
name|FT_ALLOC
argument_list|(
name|parser
operator|->
name|base_dict
argument_list|,
name|size
argument_list|)
operator|||
name|FT_STREAM_READ
argument_list|(
name|parser
operator|->
name|base_dict
argument_list|,
name|size
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|parser
operator|->
name|base_len
operator|=
name|size
expr_stmt|;
block|}
name|parser
operator|->
name|root
operator|.
name|base
operator|=
name|parser
operator|->
name|base_dict
expr_stmt|;
name|parser
operator|->
name|root
operator|.
name|cursor
operator|=
name|parser
operator|->
name|base_dict
expr_stmt|;
name|parser
operator|->
name|root
operator|.
name|limit
operator|=
name|parser
operator|->
name|root
operator|.
name|cursor
operator|+
name|parser
operator|->
name|base_len
expr_stmt|;
name|Exit
label|:
if|if
condition|(
name|error
operator|&&
operator|!
name|parser
operator|->
name|in_memory
condition|)
name|FT_FREE
argument_list|(
name|parser
operator|->
name|base_dict
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_block
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|T1_Finalize_Parser
name|T1_Finalize_Parser
argument_list|(
argument|T1_Parser  parser
argument_list|)
end_macro
begin_block
block|{
name|FT_Memory
name|memory
init|=
name|parser
operator|->
name|root
operator|.
name|memory
decl_stmt|;
comment|/* always free the private dictionary */
name|FT_FREE
argument_list|(
name|parser
operator|->
name|private_dict
argument_list|)
expr_stmt|;
comment|/* free the base dictionary only when we have a disk stream */
if|if
condition|(
operator|!
name|parser
operator|->
name|in_memory
condition|)
name|FT_FREE
argument_list|(
name|parser
operator|->
name|base_dict
argument_list|)
expr_stmt|;
name|parser
operator|->
name|root
operator|.
name|funcs
operator|.
name|done
argument_list|(
operator|&
name|parser
operator|->
name|root
argument_list|)
expr_stmt|;
block|}
end_block
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|T1_Get_Private_Dict
argument_list|(
argument|T1_Parser      parser
argument_list|,
argument|PSAux_Service  psaux
argument_list|)
end_macro
begin_block
block|{
name|FT_Stream
name|stream
init|=
name|parser
operator|->
name|stream
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|parser
operator|->
name|root
operator|.
name|memory
decl_stmt|;
name|FT_Error
name|error
init|=
name|T1_Err_Ok
decl_stmt|;
name|FT_ULong
name|size
decl_stmt|;
if|if
condition|(
name|parser
operator|->
name|in_pfb
condition|)
block|{
comment|/* in the case of the PFB format, the private dictionary can be  */
comment|/* made of several segments.  We thus first read the number of   */
comment|/* segments to compute the total size of the private dictionary  */
comment|/* then re-read them into memory.                                */
name|FT_Long
name|start_pos
init|=
name|FT_STREAM_POS
argument_list|()
decl_stmt|;
name|FT_UShort
name|tag
decl_stmt|;
name|parser
operator|->
name|private_len
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|error
operator|=
name|read_pfb_tag
argument_list|(
name|stream
argument_list|,
operator|&
name|tag
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Fail
goto|;
if|if
condition|(
name|tag
operator|!=
literal|0x8002U
condition|)
break|break;
name|parser
operator|->
name|private_len
operator|+=
name|size
expr_stmt|;
if|if
condition|(
name|FT_STREAM_SKIP
argument_list|(
name|size
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
block|}
comment|/* Check that we have a private dictionary there */
comment|/* and allocate private dictionary buffer        */
if|if
condition|(
name|parser
operator|->
name|private_len
operator|==
literal|0
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"T1_Get_Private_Dict:"
literal|" invalid private dictionary section\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|T1_Err_Invalid_File_Format
expr_stmt|;
goto|goto
name|Fail
goto|;
block|}
if|if
condition|(
name|FT_STREAM_SEEK
argument_list|(
name|start_pos
argument_list|)
operator|||
name|FT_ALLOC
argument_list|(
name|parser
operator|->
name|private_dict
argument_list|,
name|parser
operator|->
name|private_len
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
name|parser
operator|->
name|private_len
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|error
operator|=
name|read_pfb_tag
argument_list|(
name|stream
argument_list|,
operator|&
name|tag
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|tag
operator|!=
literal|0x8002U
condition|)
block|{
name|error
operator|=
name|T1_Err_Ok
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|FT_STREAM_READ
argument_list|(
name|parser
operator|->
name|private_dict
operator|+
name|parser
operator|->
name|private_len
argument_list|,
name|size
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
name|parser
operator|->
name|private_len
operator|+=
name|size
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* We have already `loaded' the whole PFA font file into memory; */
comment|/* if this is a memory resource, allocate a new block to hold    */
comment|/* the private dict.  Otherwise, simply overwrite into the base  */
comment|/* dictionary block in the heap.                                 */
comment|/* first of all, look at the `eexec' keyword */
name|FT_Byte
modifier|*
name|cur
init|=
name|parser
operator|->
name|base_dict
decl_stmt|;
name|FT_Byte
modifier|*
name|limit
init|=
name|cur
operator|+
name|parser
operator|->
name|base_len
decl_stmt|;
name|FT_Byte
name|c
decl_stmt|;
name|Again
label|:
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|cur
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'e'
operator|&&
name|cur
operator|+
literal|9
operator|<
name|limit
condition|)
comment|/* 9 = 5 letters for `eexec' + */
comment|/* newline + 4 chars           */
block|{
if|if
condition|(
name|cur
index|[
literal|1
index|]
operator|==
literal|'e'
operator|&&
name|cur
index|[
literal|2
index|]
operator|==
literal|'x'
operator|&&
name|cur
index|[
literal|3
index|]
operator|==
literal|'e'
operator|&&
name|cur
index|[
literal|4
index|]
operator|==
literal|'c'
condition|)
break|break;
block|}
name|cur
operator|++
expr_stmt|;
if|if
condition|(
name|cur
operator|>=
name|limit
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"T1_Get_Private_Dict:"
literal|" could not find `eexec' keyword\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|T1_Err_Invalid_File_Format
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
comment|/* check whether `eexec' was real -- it could be in a comment */
comment|/* or string (as e.g. in u003043t.gsf from ghostscript)       */
name|parser
operator|->
name|root
operator|.
name|cursor
operator|=
name|parser
operator|->
name|base_dict
expr_stmt|;
name|parser
operator|->
name|root
operator|.
name|limit
operator|=
name|cur
operator|+
literal|9
expr_stmt|;
name|cur
operator|=
name|parser
operator|->
name|root
operator|.
name|cursor
expr_stmt|;
name|limit
operator|=
name|parser
operator|->
name|root
operator|.
name|limit
expr_stmt|;
while|while
condition|(
name|cur
operator|<
name|limit
condition|)
block|{
if|if
condition|(
operator|*
name|cur
operator|==
literal|'e'
operator|&&
name|ft_strncmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cur
argument_list|,
literal|"eexec"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|Found
goto|;
name|T1_Skip_PS_Token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|parser
operator|->
name|root
operator|.
name|error
condition|)
break|break;
name|T1_Skip_Spaces
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|cur
operator|=
name|parser
operator|->
name|root
operator|.
name|cursor
expr_stmt|;
block|}
comment|/* we haven't found the correct `eexec'; go back and continue */
comment|/* searching                                                  */
name|cur
operator|=
name|limit
expr_stmt|;
name|limit
operator|=
name|parser
operator|->
name|base_dict
operator|+
name|parser
operator|->
name|base_len
expr_stmt|;
goto|goto
name|Again
goto|;
comment|/* now determine where to write the _encrypted_ binary private  */
comment|/* dictionary.  We overwrite the base dictionary for disk-based */
comment|/* resources and allocate a new block otherwise                 */
name|Found
label|:
name|parser
operator|->
name|root
operator|.
name|limit
operator|=
name|parser
operator|->
name|base_dict
operator|+
name|parser
operator|->
name|base_len
expr_stmt|;
name|T1_Skip_PS_Token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|cur
operator|=
name|parser
operator|->
name|root
operator|.
name|cursor
expr_stmt|;
comment|/* according to the Type1 spec, the first cipher byte must not be  */
comment|/* an ASCII whitespace character code (blank, tab, carriage return */
comment|/* or line feed).  We have seen Type 1 fonts with two line feed    */
comment|/* characters...  So skip now all whitespace character codes.      */
while|while
condition|(
name|cur
operator|<
name|limit
operator|&&
operator|(
operator|*
name|cur
operator|==
literal|' '
operator|||
operator|*
name|cur
operator|==
literal|'\t'
operator|||
operator|*
name|cur
operator|==
literal|'\r'
operator|||
operator|*
name|cur
operator|==
literal|'\n'
operator|)
condition|)
operator|++
name|cur
expr_stmt|;
if|if
condition|(
name|cur
operator|>=
name|limit
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"T1_Get_Private_Dict:"
literal|" `eexec' not properly terminated\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|T1_Err_Invalid_File_Format
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|size
operator|=
name|parser
operator|->
name|base_len
operator|-
operator|(
name|cur
operator|-
name|parser
operator|->
name|base_dict
operator|)
expr_stmt|;
if|if
condition|(
name|parser
operator|->
name|in_memory
condition|)
block|{
comment|/* note that we allocate one more byte to put a terminating `0' */
if|if
condition|(
name|FT_ALLOC
argument_list|(
name|parser
operator|->
name|private_dict
argument_list|,
name|size
operator|+
literal|1
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
name|parser
operator|->
name|private_len
operator|=
name|size
expr_stmt|;
block|}
else|else
block|{
name|parser
operator|->
name|single_block
operator|=
literal|1
expr_stmt|;
name|parser
operator|->
name|private_dict
operator|=
name|parser
operator|->
name|base_dict
expr_stmt|;
name|parser
operator|->
name|private_len
operator|=
name|size
expr_stmt|;
name|parser
operator|->
name|base_dict
operator|=
literal|0
expr_stmt|;
name|parser
operator|->
name|base_len
operator|=
literal|0
expr_stmt|;
block|}
comment|/* now determine whether the private dictionary is encoded in binary */
comment|/* or hexadecimal ASCII format -- decode it accordingly              */
comment|/* we need to access the next 4 bytes (after the final \r following */
comment|/* the `eexec' keyword); if they all are hexadecimal digits, then   */
comment|/* we have a case of ASCII storage                                  */
if|if
condition|(
name|ft_isxdigit
argument_list|(
name|cur
index|[
literal|0
index|]
argument_list|)
operator|&&
name|ft_isxdigit
argument_list|(
name|cur
index|[
literal|1
index|]
argument_list|)
operator|&&
name|ft_isxdigit
argument_list|(
name|cur
index|[
literal|2
index|]
argument_list|)
operator|&&
name|ft_isxdigit
argument_list|(
name|cur
index|[
literal|3
index|]
argument_list|)
condition|)
block|{
comment|/* ASCII hexadecimal encoding */
name|FT_Long
name|len
decl_stmt|;
name|parser
operator|->
name|root
operator|.
name|cursor
operator|=
name|cur
expr_stmt|;
operator|(
name|void
operator|)
name|psaux
operator|->
name|ps_parser_funcs
operator|->
name|to_bytes
argument_list|(
operator|&
name|parser
operator|->
name|root
argument_list|,
name|parser
operator|->
name|private_dict
argument_list|,
name|parser
operator|->
name|private_len
argument_list|,
operator|&
name|len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|parser
operator|->
name|private_len
operator|=
name|len
expr_stmt|;
comment|/* put a safeguard */
name|parser
operator|->
name|private_dict
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
comment|/* binary encoding -- copy the private dict */
name|FT_MEM_MOVE
argument_list|(
name|parser
operator|->
name|private_dict
argument_list|,
name|cur
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
comment|/* we now decrypt the encoded binary private dictionary */
name|psaux
operator|->
name|t1_decrypt
argument_list|(
name|parser
operator|->
name|private_dict
argument_list|,
name|parser
operator|->
name|private_len
argument_list|,
literal|55665U
argument_list|)
expr_stmt|;
comment|/* replace the four random bytes at the beginning with whitespace */
name|parser
operator|->
name|private_dict
index|[
literal|0
index|]
operator|=
literal|' '
expr_stmt|;
name|parser
operator|->
name|private_dict
index|[
literal|1
index|]
operator|=
literal|' '
expr_stmt|;
name|parser
operator|->
name|private_dict
index|[
literal|2
index|]
operator|=
literal|' '
expr_stmt|;
name|parser
operator|->
name|private_dict
index|[
literal|3
index|]
operator|=
literal|' '
expr_stmt|;
name|parser
operator|->
name|root
operator|.
name|base
operator|=
name|parser
operator|->
name|private_dict
expr_stmt|;
name|parser
operator|->
name|root
operator|.
name|cursor
operator|=
name|parser
operator|->
name|private_dict
expr_stmt|;
name|parser
operator|->
name|root
operator|.
name|limit
operator|=
name|parser
operator|->
name|root
operator|.
name|cursor
operator|+
name|parser
operator|->
name|private_len
expr_stmt|;
name|Fail
label|:
name|Exit
label|:
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/* END */
end_comment
end_unit
