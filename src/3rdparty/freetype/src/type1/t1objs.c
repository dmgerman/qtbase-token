begin_unit
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  t1objs.c                                                               */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*    Type 1 objects manager (body).                                       */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  Copyright 1996-2009, 2011, 2013 by                                     */
end_comment
begin_comment
comment|/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  This file is part of the FreeType project, and may only be used,       */
end_comment
begin_comment
comment|/*  modified, and distributed under the terms of the FreeType project      */
end_comment
begin_comment
comment|/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
end_comment
begin_comment
comment|/*  this file you indicate that you have read the license and              */
end_comment
begin_comment
comment|/*  understand and accept it fully.                                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<ft2build.h>
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_CALC_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_DEBUG_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_STREAM_H
end_include
begin_include
include|#
directive|include
include|FT_TRUETYPE_IDS_H
end_include
begin_include
include|#
directive|include
file|"t1gload.h"
end_include
begin_include
include|#
directive|include
file|"t1load.h"
end_include
begin_include
include|#
directive|include
file|"t1errors.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|T1_CONFIG_OPTION_NO_AFM
end_ifndef
begin_include
include|#
directive|include
file|"t1afm.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
include|FT_SERVICE_POSTSCRIPT_CMAPS_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_POSTSCRIPT_AUX_H
end_include
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
end_comment
begin_comment
comment|/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
end_comment
begin_comment
comment|/* messages during execution.                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_undef
DECL|macro|FT_COMPONENT
undef|#
directive|undef
name|FT_COMPONENT
end_undef
begin_define
DECL|macro|FT_COMPONENT
define|#
directive|define
name|FT_COMPONENT
value|trace_t1objs
end_define
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*                            SIZE FUNCTIONS                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*  note that we store the global hints in the size's "internal" root    */
end_comment
begin_comment
comment|/*  field                                                                */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_function
specifier|static
name|PSH_Globals_Funcs
DECL|function|T1_Size_Get_Globals_Funcs
name|T1_Size_Get_Globals_Funcs
parameter_list|(
name|T1_Size
name|size
parameter_list|)
block|{
name|T1_Face
name|face
init|=
operator|(
name|T1_Face
operator|)
name|size
operator|->
name|root
operator|.
name|face
decl_stmt|;
name|PSHinter_Service
name|pshinter
init|=
operator|(
name|PSHinter_Service
operator|)
name|face
operator|->
name|pshinter
decl_stmt|;
name|FT_Module
name|module
decl_stmt|;
name|module
operator|=
name|FT_Get_Module
argument_list|(
name|size
operator|->
name|root
operator|.
name|face
operator|->
name|driver
operator|->
name|root
operator|.
name|library
argument_list|,
literal|"pshinter"
argument_list|)
expr_stmt|;
return|return
operator|(
name|module
operator|&&
name|pshinter
operator|&&
name|pshinter
operator|->
name|get_globals_funcs
operator|)
condition|?
name|pshinter
operator|->
name|get_globals_funcs
argument_list|(
name|module
argument_list|)
else|:
literal|0
return|;
block|}
end_function
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|T1_Size_Done
name|T1_Size_Done
argument_list|(
argument|FT_Size  t1size
argument_list|)
end_macro
begin_comment
DECL|function|T1_Size_Done
comment|/* T1_Size */
end_comment
begin_block
block|{
name|T1_Size
name|size
init|=
operator|(
name|T1_Size
operator|)
name|t1size
decl_stmt|;
if|if
condition|(
name|size
operator|->
name|root
operator|.
name|internal
condition|)
block|{
name|PSH_Globals_Funcs
name|funcs
decl_stmt|;
name|funcs
operator|=
name|T1_Size_Get_Globals_Funcs
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|funcs
condition|)
name|funcs
operator|->
name|destroy
argument_list|(
operator|(
name|PSH_Globals
operator|)
name|size
operator|->
name|root
operator|.
name|internal
argument_list|)
expr_stmt|;
name|size
operator|->
name|root
operator|.
name|internal
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|T1_Size_Init
argument_list|(
argument|FT_Size  t1size
argument_list|)
end_macro
begin_comment
comment|/* T1_Size */
end_comment
begin_block
block|{
name|T1_Size
name|size
init|=
operator|(
name|T1_Size
operator|)
name|t1size
decl_stmt|;
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
name|PSH_Globals_Funcs
name|funcs
init|=
name|T1_Size_Get_Globals_Funcs
argument_list|(
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|funcs
condition|)
block|{
name|PSH_Globals
name|globals
decl_stmt|;
name|T1_Face
name|face
init|=
operator|(
name|T1_Face
operator|)
name|size
operator|->
name|root
operator|.
name|face
decl_stmt|;
name|error
operator|=
name|funcs
operator|->
name|create
argument_list|(
name|size
operator|->
name|root
operator|.
name|face
operator|->
name|memory
argument_list|,
operator|&
name|face
operator|->
name|type1
operator|.
name|private_dict
argument_list|,
operator|&
name|globals
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|size
operator|->
name|root
operator|.
name|internal
operator|=
operator|(
name|FT_Size_Internal
operator|)
operator|(
name|void
operator|*
operator|)
name|globals
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_block
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|T1_Size_Request
argument_list|(
argument|FT_Size          t1size
argument_list|,
comment|/* T1_Size */
argument|FT_Size_Request  req
argument_list|)
end_macro
begin_block
block|{
name|T1_Size
name|size
init|=
operator|(
name|T1_Size
operator|)
name|t1size
decl_stmt|;
name|PSH_Globals_Funcs
name|funcs
init|=
name|T1_Size_Get_Globals_Funcs
argument_list|(
name|size
argument_list|)
decl_stmt|;
name|FT_Request_Metrics
argument_list|(
name|size
operator|->
name|root
operator|.
name|face
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|funcs
condition|)
name|funcs
operator|->
name|set_scale
argument_list|(
operator|(
name|PSH_Globals
operator|)
name|size
operator|->
name|root
operator|.
name|internal
argument_list|,
name|size
operator|->
name|root
operator|.
name|metrics
operator|.
name|x_scale
argument_list|,
name|size
operator|->
name|root
operator|.
name|metrics
operator|.
name|y_scale
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|FT_Err_Ok
return|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*                            SLOT  FUNCTIONS                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|T1_GlyphSlot_Done
name|T1_GlyphSlot_Done
argument_list|(
argument|FT_GlyphSlot  slot
argument_list|)
end_macro
begin_block
block|{
name|slot
operator|->
name|internal
operator|->
name|glyph_hints
operator|=
literal|0
expr_stmt|;
block|}
end_block
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|T1_GlyphSlot_Init
argument_list|(
argument|FT_GlyphSlot  slot
argument_list|)
end_macro
begin_block
block|{
name|T1_Face
name|face
decl_stmt|;
name|PSHinter_Service
name|pshinter
decl_stmt|;
name|face
operator|=
operator|(
name|T1_Face
operator|)
name|slot
operator|->
name|face
expr_stmt|;
name|pshinter
operator|=
operator|(
name|PSHinter_Service
operator|)
name|face
operator|->
name|pshinter
expr_stmt|;
if|if
condition|(
name|pshinter
condition|)
block|{
name|FT_Module
name|module
decl_stmt|;
name|module
operator|=
name|FT_Get_Module
argument_list|(
name|slot
operator|->
name|face
operator|->
name|driver
operator|->
name|root
operator|.
name|library
argument_list|,
literal|"pshinter"
argument_list|)
expr_stmt|;
if|if
condition|(
name|module
condition|)
block|{
name|T1_Hints_Funcs
name|funcs
decl_stmt|;
name|funcs
operator|=
name|pshinter
operator|->
name|get_t1_funcs
argument_list|(
name|module
argument_list|)
expr_stmt|;
name|slot
operator|->
name|internal
operator|->
name|glyph_hints
operator|=
operator|(
name|void
operator|*
operator|)
name|funcs
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*                            FACE  FUNCTIONS                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    T1_Face_Done                                                       */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    The face object destructor.                                        */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    face :: A typeless pointer to the face object to destroy.          */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|T1_Face_Done
name|T1_Face_Done
argument_list|(
argument|FT_Face  t1face
argument_list|)
end_macro
begin_comment
DECL|function|T1_Face_Done
comment|/* T1_Face */
end_comment
begin_block
block|{
name|T1_Face
name|face
init|=
operator|(
name|T1_Face
operator|)
name|t1face
decl_stmt|;
name|FT_Memory
name|memory
decl_stmt|;
name|T1_Font
name|type1
decl_stmt|;
if|if
condition|(
operator|!
name|face
condition|)
return|return;
name|memory
operator|=
name|face
operator|->
name|root
operator|.
name|memory
expr_stmt|;
name|type1
operator|=
operator|&
name|face
operator|->
name|type1
expr_stmt|;
ifndef|#
directive|ifndef
name|T1_CONFIG_OPTION_NO_MM_SUPPORT
comment|/* release multiple masters information */
name|FT_ASSERT
argument_list|(
operator|(
name|face
operator|->
name|len_buildchar
operator|==
literal|0
operator|)
operator|==
operator|(
name|face
operator|->
name|buildchar
operator|==
name|NULL
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|face
operator|->
name|buildchar
condition|)
block|{
name|FT_FREE
argument_list|(
name|face
operator|->
name|buildchar
argument_list|)
expr_stmt|;
name|face
operator|->
name|buildchar
operator|=
name|NULL
expr_stmt|;
name|face
operator|->
name|len_buildchar
operator|=
literal|0
expr_stmt|;
block|}
name|T1_Done_Blend
argument_list|(
name|face
argument_list|)
expr_stmt|;
name|face
operator|->
name|blend
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* release font info strings */
block|{
name|PS_FontInfo
name|info
init|=
operator|&
name|type1
operator|->
name|font_info
decl_stmt|;
name|FT_FREE
argument_list|(
name|info
operator|->
name|version
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|info
operator|->
name|notice
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|info
operator|->
name|full_name
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|info
operator|->
name|family_name
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|info
operator|->
name|weight
argument_list|)
expr_stmt|;
block|}
comment|/* release top dictionary */
name|FT_FREE
argument_list|(
name|type1
operator|->
name|charstrings_len
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|type1
operator|->
name|charstrings
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|type1
operator|->
name|glyph_names
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|type1
operator|->
name|subrs
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|type1
operator|->
name|subrs_len
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|type1
operator|->
name|subrs_block
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|type1
operator|->
name|charstrings_block
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|type1
operator|->
name|glyph_names_block
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|type1
operator|->
name|encoding
operator|.
name|char_index
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|type1
operator|->
name|encoding
operator|.
name|char_name
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|type1
operator|->
name|font_name
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|T1_CONFIG_OPTION_NO_AFM
comment|/* release afm data if present */
if|if
condition|(
name|face
operator|->
name|afm_data
condition|)
name|T1_Done_Metrics
argument_list|(
name|memory
argument_list|,
operator|(
name|AFM_FontInfo
operator|)
name|face
operator|->
name|afm_data
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* release unicode map, if any */
if|#
directive|if
literal|0
block|FT_FREE( face->unicode_map_rec.maps );     face->unicode_map_rec.num_maps = 0;     face->unicode_map              = NULL;
endif|#
directive|endif
name|face
operator|->
name|root
operator|.
name|family_name
operator|=
name|NULL
expr_stmt|;
name|face
operator|->
name|root
operator|.
name|style_name
operator|=
name|NULL
expr_stmt|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    T1_Face_Init                                                       */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    The face object constructor.                                       */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    stream     ::  input stream where to load font data.               */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    face_index :: The index of the font face in the resource.          */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    num_params :: Number of additional generic parameters.  Ignored.   */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    params     :: Additional generic parameters.  Ignored.             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<InOut>                                                               */
end_comment
begin_comment
comment|/*    face       :: The face record to build.                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    FreeType error code.  0 means success.                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|T1_Face_Init
argument_list|(
argument|FT_Stream      stream
argument_list|,
argument|FT_Face        t1face
argument_list|,
comment|/* T1_Face */
argument|FT_Int         face_index
argument_list|,
argument|FT_Int         num_params
argument_list|,
argument|FT_Parameter*  params
argument_list|)
end_macro
begin_block
block|{
name|T1_Face
name|face
init|=
operator|(
name|T1_Face
operator|)
name|t1face
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|FT_Service_PsCMaps
name|psnames
decl_stmt|;
name|PSAux_Service
name|psaux
decl_stmt|;
name|T1_Font
name|type1
init|=
operator|&
name|face
operator|->
name|type1
decl_stmt|;
name|PS_FontInfo
name|info
init|=
operator|&
name|type1
operator|->
name|font_info
decl_stmt|;
name|FT_UNUSED
argument_list|(
name|num_params
argument_list|)
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|params
argument_list|)
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|face
operator|->
name|root
operator|.
name|num_faces
operator|=
literal|1
expr_stmt|;
name|FT_FACE_FIND_GLOBAL_SERVICE
argument_list|(
name|face
argument_list|,
name|psnames
argument_list|,
name|POSTSCRIPT_CMAPS
argument_list|)
expr_stmt|;
name|face
operator|->
name|psnames
operator|=
name|psnames
expr_stmt|;
name|face
operator|->
name|psaux
operator|=
name|FT_Get_Module_Interface
argument_list|(
name|FT_FACE_LIBRARY
argument_list|(
name|face
argument_list|)
argument_list|,
literal|"psaux"
argument_list|)
expr_stmt|;
name|psaux
operator|=
operator|(
name|PSAux_Service
operator|)
name|face
operator|->
name|psaux
expr_stmt|;
if|if
condition|(
operator|!
name|psaux
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"T1_Face_Init: cannot access `psaux' module\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|FT_THROW
argument_list|(
name|Missing_Module
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|face
operator|->
name|pshinter
operator|=
name|FT_Get_Module_Interface
argument_list|(
name|FT_FACE_LIBRARY
argument_list|(
name|face
argument_list|)
argument_list|,
literal|"pshinter"
argument_list|)
expr_stmt|;
name|FT_TRACE2
argument_list|(
operator|(
literal|"Type 1 driver\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* open the tokenizer; this will also check the font format */
name|error
operator|=
name|T1_Open_Face
argument_list|(
name|face
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
comment|/* if we just wanted to check the format, leave successfully now */
if|if
condition|(
name|face_index
operator|<
literal|0
condition|)
goto|goto
name|Exit
goto|;
comment|/* check the face index */
if|if
condition|(
name|face_index
operator|>
literal|0
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"T1_Face_Init: invalid face index\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Argument
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* now load the font program into the face object */
comment|/* initialize the face object fields */
comment|/* set up root face fields */
block|{
name|FT_Face
name|root
init|=
operator|(
name|FT_Face
operator|)
operator|&
name|face
operator|->
name|root
decl_stmt|;
name|root
operator|->
name|num_glyphs
operator|=
name|type1
operator|->
name|num_glyphs
expr_stmt|;
name|root
operator|->
name|face_index
operator|=
literal|0
expr_stmt|;
name|root
operator|->
name|face_flags
operator||=
name|FT_FACE_FLAG_SCALABLE
operator||
name|FT_FACE_FLAG_HORIZONTAL
operator||
name|FT_FACE_FLAG_GLYPH_NAMES
operator||
name|FT_FACE_FLAG_HINTER
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|is_fixed_pitch
condition|)
name|root
operator|->
name|face_flags
operator||=
name|FT_FACE_FLAG_FIXED_WIDTH
expr_stmt|;
if|if
condition|(
name|face
operator|->
name|blend
condition|)
name|root
operator|->
name|face_flags
operator||=
name|FT_FACE_FLAG_MULTIPLE_MASTERS
expr_stmt|;
comment|/* XXX: TODO -- add kerning with .afm support */
comment|/* The following code to extract the family and the style is very   */
comment|/* simplistic and might get some things wrong.  For a full-featured */
comment|/* algorithm you might have a look at the whitepaper given at       */
comment|/*                                                                  */
comment|/*   http://blogs.msdn.com/text/archive/2007/04/23/wpf-font-selection-model.aspx */
comment|/* get style name -- be careful, some broken fonts only */
comment|/* have a `/FontName' dictionary entry!                 */
name|root
operator|->
name|family_name
operator|=
name|info
operator|->
name|family_name
expr_stmt|;
name|root
operator|->
name|style_name
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|root
operator|->
name|family_name
condition|)
block|{
name|char
modifier|*
name|full
init|=
name|info
operator|->
name|full_name
decl_stmt|;
name|char
modifier|*
name|family
init|=
name|root
operator|->
name|family_name
decl_stmt|;
if|if
condition|(
name|full
condition|)
block|{
name|FT_Bool
name|the_same
init|=
name|TRUE
decl_stmt|;
while|while
condition|(
operator|*
name|full
condition|)
block|{
if|if
condition|(
operator|*
name|full
operator|==
operator|*
name|family
condition|)
block|{
name|family
operator|++
expr_stmt|;
name|full
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|full
operator|==
literal|' '
operator|||
operator|*
name|full
operator|==
literal|'-'
condition|)
name|full
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|family
operator|==
literal|' '
operator|||
operator|*
name|family
operator|==
literal|'-'
condition|)
name|family
operator|++
expr_stmt|;
else|else
block|{
name|the_same
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|family
condition|)
name|root
operator|->
name|style_name
operator|=
name|full
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|the_same
condition|)
name|root
operator|->
name|style_name
operator|=
operator|(
name|char
operator|*
operator|)
literal|"Regular"
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* do we have a `/FontName'? */
if|if
condition|(
name|type1
operator|->
name|font_name
condition|)
name|root
operator|->
name|family_name
operator|=
name|type1
operator|->
name|font_name
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|root
operator|->
name|style_name
condition|)
block|{
if|if
condition|(
name|info
operator|->
name|weight
condition|)
name|root
operator|->
name|style_name
operator|=
name|info
operator|->
name|weight
expr_stmt|;
else|else
comment|/* assume `Regular' style because we don't know better */
name|root
operator|->
name|style_name
operator|=
operator|(
name|char
operator|*
operator|)
literal|"Regular"
expr_stmt|;
block|}
comment|/* compute style flags */
name|root
operator|->
name|style_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|italic_angle
condition|)
name|root
operator|->
name|style_flags
operator||=
name|FT_STYLE_FLAG_ITALIC
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|weight
condition|)
block|{
if|if
condition|(
operator|!
name|ft_strcmp
argument_list|(
name|info
operator|->
name|weight
argument_list|,
literal|"Bold"
argument_list|)
operator|||
operator|!
name|ft_strcmp
argument_list|(
name|info
operator|->
name|weight
argument_list|,
literal|"Black"
argument_list|)
condition|)
name|root
operator|->
name|style_flags
operator||=
name|FT_STYLE_FLAG_BOLD
expr_stmt|;
block|}
comment|/* no embedded bitmap support */
name|root
operator|->
name|num_fixed_sizes
operator|=
literal|0
expr_stmt|;
name|root
operator|->
name|available_sizes
operator|=
literal|0
expr_stmt|;
name|root
operator|->
name|bbox
operator|.
name|xMin
operator|=
name|type1
operator|->
name|font_bbox
operator|.
name|xMin
operator|>>
literal|16
expr_stmt|;
name|root
operator|->
name|bbox
operator|.
name|yMin
operator|=
name|type1
operator|->
name|font_bbox
operator|.
name|yMin
operator|>>
literal|16
expr_stmt|;
comment|/* no `U' suffix here to 0xFFFF! */
name|root
operator|->
name|bbox
operator|.
name|xMax
operator|=
operator|(
name|type1
operator|->
name|font_bbox
operator|.
name|xMax
operator|+
literal|0xFFFF
operator|)
operator|>>
literal|16
expr_stmt|;
name|root
operator|->
name|bbox
operator|.
name|yMax
operator|=
operator|(
name|type1
operator|->
name|font_bbox
operator|.
name|yMax
operator|+
literal|0xFFFF
operator|)
operator|>>
literal|16
expr_stmt|;
comment|/* Set units_per_EM if we didn't set it in t1_parse_font_matrix. */
if|if
condition|(
operator|!
name|root
operator|->
name|units_per_EM
condition|)
name|root
operator|->
name|units_per_EM
operator|=
literal|1000
expr_stmt|;
name|root
operator|->
name|ascender
operator|=
call|(
name|FT_Short
call|)
argument_list|(
name|root
operator|->
name|bbox
operator|.
name|yMax
argument_list|)
expr_stmt|;
name|root
operator|->
name|descender
operator|=
call|(
name|FT_Short
call|)
argument_list|(
name|root
operator|->
name|bbox
operator|.
name|yMin
argument_list|)
expr_stmt|;
name|root
operator|->
name|height
operator|=
call|(
name|FT_Short
call|)
argument_list|(
operator|(
name|root
operator|->
name|units_per_EM
operator|*
literal|12
operator|)
operator|/
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|root
operator|->
name|height
operator|<
name|root
operator|->
name|ascender
operator|-
name|root
operator|->
name|descender
condition|)
name|root
operator|->
name|height
operator|=
call|(
name|FT_Short
call|)
argument_list|(
name|root
operator|->
name|ascender
operator|-
name|root
operator|->
name|descender
argument_list|)
expr_stmt|;
comment|/* now compute the maximum advance width */
name|root
operator|->
name|max_advance_width
operator|=
call|(
name|FT_Short
call|)
argument_list|(
name|root
operator|->
name|bbox
operator|.
name|xMax
argument_list|)
expr_stmt|;
block|{
name|FT_Pos
name|max_advance
decl_stmt|;
name|error
operator|=
name|T1_Compute_Max_Advance
argument_list|(
name|face
argument_list|,
operator|&
name|max_advance
argument_list|)
expr_stmt|;
comment|/* in case of error, keep the standard width */
if|if
condition|(
operator|!
name|error
condition|)
name|root
operator|->
name|max_advance_width
operator|=
operator|(
name|FT_Short
operator|)
name|FIXED_TO_INT
argument_list|(
name|max_advance
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|FT_Err_Ok
expr_stmt|;
comment|/* clear error */
block|}
name|root
operator|->
name|max_advance_height
operator|=
name|root
operator|->
name|height
expr_stmt|;
name|root
operator|->
name|underline_position
operator|=
operator|(
name|FT_Short
operator|)
name|info
operator|->
name|underline_position
expr_stmt|;
name|root
operator|->
name|underline_thickness
operator|=
operator|(
name|FT_Short
operator|)
name|info
operator|->
name|underline_thickness
expr_stmt|;
block|}
block|{
name|FT_Face
name|root
init|=
operator|&
name|face
operator|->
name|root
decl_stmt|;
if|if
condition|(
name|psnames
condition|)
block|{
name|FT_CharMapRec
name|charmap
decl_stmt|;
name|T1_CMap_Classes
name|cmap_classes
init|=
name|psaux
operator|->
name|t1_cmap_classes
decl_stmt|;
name|FT_CMap_Class
name|clazz
decl_stmt|;
name|charmap
operator|.
name|face
operator|=
name|root
expr_stmt|;
comment|/* first of all, try to synthesize a Unicode charmap */
name|charmap
operator|.
name|platform_id
operator|=
name|TT_PLATFORM_MICROSOFT
expr_stmt|;
name|charmap
operator|.
name|encoding_id
operator|=
name|TT_MS_ID_UNICODE_CS
expr_stmt|;
name|charmap
operator|.
name|encoding
operator|=
name|FT_ENCODING_UNICODE
expr_stmt|;
name|error
operator|=
name|FT_CMap_New
argument_list|(
name|cmap_classes
operator|->
name|unicode
argument_list|,
name|NULL
argument_list|,
operator|&
name|charmap
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|FT_ERR_NEQ
argument_list|(
name|error
argument_list|,
name|No_Unicode_Glyph_Name
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|error
operator|=
name|FT_Err_Ok
expr_stmt|;
comment|/* now, generate an Adobe Standard encoding when appropriate */
name|charmap
operator|.
name|platform_id
operator|=
name|TT_PLATFORM_ADOBE
expr_stmt|;
name|clazz
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|type1
operator|->
name|encoding_type
condition|)
block|{
case|case
name|T1_ENCODING_TYPE_STANDARD
case|:
name|charmap
operator|.
name|encoding
operator|=
name|FT_ENCODING_ADOBE_STANDARD
expr_stmt|;
name|charmap
operator|.
name|encoding_id
operator|=
name|TT_ADOBE_ID_STANDARD
expr_stmt|;
name|clazz
operator|=
name|cmap_classes
operator|->
name|standard
expr_stmt|;
break|break;
case|case
name|T1_ENCODING_TYPE_EXPERT
case|:
name|charmap
operator|.
name|encoding
operator|=
name|FT_ENCODING_ADOBE_EXPERT
expr_stmt|;
name|charmap
operator|.
name|encoding_id
operator|=
name|TT_ADOBE_ID_EXPERT
expr_stmt|;
name|clazz
operator|=
name|cmap_classes
operator|->
name|expert
expr_stmt|;
break|break;
case|case
name|T1_ENCODING_TYPE_ARRAY
case|:
name|charmap
operator|.
name|encoding
operator|=
name|FT_ENCODING_ADOBE_CUSTOM
expr_stmt|;
name|charmap
operator|.
name|encoding_id
operator|=
name|TT_ADOBE_ID_CUSTOM
expr_stmt|;
name|clazz
operator|=
name|cmap_classes
operator|->
name|custom
expr_stmt|;
break|break;
case|case
name|T1_ENCODING_TYPE_ISOLATIN1
case|:
name|charmap
operator|.
name|encoding
operator|=
name|FT_ENCODING_ADOBE_LATIN_1
expr_stmt|;
name|charmap
operator|.
name|encoding_id
operator|=
name|TT_ADOBE_ID_LATIN_1
expr_stmt|;
name|clazz
operator|=
name|cmap_classes
operator|->
name|unicode
expr_stmt|;
break|break;
default|default:
empty_stmt|;
block|}
if|if
condition|(
name|clazz
condition|)
name|error
operator|=
name|FT_CMap_New
argument_list|(
name|clazz
argument_list|,
name|NULL
argument_list|,
operator|&
name|charmap
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Select default charmap */
block|if (root->num_charmaps)           root->charmap = root->charmaps[0];
endif|#
directive|endif
block|}
block|}
name|Exit
label|:
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    T1_Driver_Init                                                     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Initializes a given Type 1 driver object.                          */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    driver :: A handle to the target driver object.                    */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    FreeType error code.  0 means success.                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|T1_Driver_Init
argument_list|(
argument|FT_Module  driver
argument_list|)
end_macro
begin_block
block|{
name|FT_UNUSED
argument_list|(
name|driver
argument_list|)
expr_stmt|;
return|return
name|FT_Err_Ok
return|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    T1_Driver_Done                                                     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Finalizes a given Type 1 driver.                                   */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    driver :: A handle to the target Type 1 driver.                    */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|T1_Driver_Done
name|T1_Driver_Done
argument_list|(
argument|FT_Module  driver
argument_list|)
end_macro
begin_block
block|{
name|FT_UNUSED
argument_list|(
name|driver
argument_list|)
expr_stmt|;
block|}
end_block
begin_comment
comment|/* END */
end_comment
end_unit
