begin_unit
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  t1gload.c                                                              */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*    Type 1 Glyph Loader (body).                                          */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2008, 2009, 2010 by */
end_comment
begin_comment
comment|/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  This file is part of the FreeType project, and may only be used,       */
end_comment
begin_comment
comment|/*  modified, and distributed under the terms of the FreeType project      */
end_comment
begin_comment
comment|/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
end_comment
begin_comment
comment|/*  this file you indicate that you have read the license and              */
end_comment
begin_comment
comment|/*  understand and accept it fully.                                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<ft2build.h>
end_include
begin_include
include|#
directive|include
file|"t1gload.h"
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_CALC_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_DEBUG_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_STREAM_H
end_include
begin_include
include|#
directive|include
include|FT_OUTLINE_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_POSTSCRIPT_AUX_H
end_include
begin_include
include|#
directive|include
file|"t1errors.h"
end_include
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
end_comment
begin_comment
comment|/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
end_comment
begin_comment
comment|/* messages during execution.                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_undef
DECL|macro|FT_COMPONENT
undef|#
directive|undef
name|FT_COMPONENT
end_undef
begin_define
DECL|macro|FT_COMPONENT
define|#
directive|define
name|FT_COMPONENT
value|trace_t1gload
end_define
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/**********                                                      *********/
end_comment
begin_comment
comment|/**********            COMPUTE THE MAXIMUM ADVANCE WIDTH         *********/
end_comment
begin_comment
comment|/**********                                                      *********/
end_comment
begin_comment
comment|/**********    The following code is in charge of computing      *********/
end_comment
begin_comment
comment|/**********    the maximum advance width of the font.  It        *********/
end_comment
begin_comment
comment|/**********    quickly processes each glyph charstring to        *********/
end_comment
begin_comment
comment|/**********    extract the value from either a `sbw' or `seac'   *********/
end_comment
begin_comment
comment|/**********    operator.                                         *********/
end_comment
begin_comment
comment|/**********                                                      *********/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|T1_Parse_Glyph_And_Get_Char_String
argument_list|(
argument|T1_Decoder  decoder
argument_list|,
argument|FT_UInt     glyph_index
argument_list|,
argument|FT_Data*    char_string
argument_list|)
end_macro
begin_block
block|{
name|T1_Face
name|face
init|=
operator|(
name|T1_Face
operator|)
name|decoder
operator|->
name|builder
operator|.
name|face
decl_stmt|;
name|T1_Font
name|type1
init|=
operator|&
name|face
operator|->
name|type1
decl_stmt|;
name|FT_Error
name|error
init|=
name|T1_Err_Ok
decl_stmt|;
ifdef|#
directive|ifdef
name|FT_CONFIG_OPTION_INCREMENTAL
name|FT_Incremental_InterfaceRec
modifier|*
name|inc
init|=
name|face
operator|->
name|root
operator|.
name|internal
operator|->
name|incremental_interface
decl_stmt|;
endif|#
directive|endif
name|decoder
operator|->
name|font_matrix
operator|=
name|type1
operator|->
name|font_matrix
expr_stmt|;
name|decoder
operator|->
name|font_offset
operator|=
name|type1
operator|->
name|font_offset
expr_stmt|;
ifdef|#
directive|ifdef
name|FT_CONFIG_OPTION_INCREMENTAL
comment|/* For incremental fonts get the character data using the */
comment|/* callback function.                                     */
if|if
condition|(
name|inc
condition|)
name|error
operator|=
name|inc
operator|->
name|funcs
operator|->
name|get_glyph_data
argument_list|(
name|inc
operator|->
name|object
argument_list|,
name|glyph_index
argument_list|,
name|char_string
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* FT_CONFIG_OPTION_INCREMENTAL */
comment|/* For ordinary fonts get the character data stored in the face record. */
block|{
name|char_string
operator|->
name|pointer
operator|=
name|type1
operator|->
name|charstrings
index|[
name|glyph_index
index|]
expr_stmt|;
name|char_string
operator|->
name|length
operator|=
operator|(
name|FT_Int
operator|)
name|type1
operator|->
name|charstrings_len
index|[
name|glyph_index
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|decoder
operator|->
name|funcs
operator|.
name|parse_charstrings
argument_list|(
name|decoder
argument_list|,
operator|(
name|FT_Byte
operator|*
operator|)
name|char_string
operator|->
name|pointer
argument_list|,
name|char_string
operator|->
name|length
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FT_CONFIG_OPTION_INCREMENTAL
comment|/* Incremental fonts can optionally override the metrics. */
if|if
condition|(
operator|!
name|error
operator|&&
name|inc
operator|&&
name|inc
operator|->
name|funcs
operator|->
name|get_glyph_metrics
condition|)
block|{
name|FT_Incremental_MetricsRec
name|metrics
decl_stmt|;
name|metrics
operator|.
name|bearing_x
operator|=
name|FIXED_TO_INT
argument_list|(
name|decoder
operator|->
name|builder
operator|.
name|left_bearing
operator|.
name|x
argument_list|)
expr_stmt|;
name|metrics
operator|.
name|bearing_y
operator|=
literal|0
expr_stmt|;
name|metrics
operator|.
name|advance
operator|=
name|FIXED_TO_INT
argument_list|(
name|decoder
operator|->
name|builder
operator|.
name|advance
operator|.
name|x
argument_list|)
expr_stmt|;
name|metrics
operator|.
name|advance_v
operator|=
name|FIXED_TO_INT
argument_list|(
name|decoder
operator|->
name|builder
operator|.
name|advance
operator|.
name|y
argument_list|)
expr_stmt|;
name|error
operator|=
name|inc
operator|->
name|funcs
operator|->
name|get_glyph_metrics
argument_list|(
name|inc
operator|->
name|object
argument_list|,
name|glyph_index
argument_list|,
name|FALSE
argument_list|,
operator|&
name|metrics
argument_list|)
expr_stmt|;
name|decoder
operator|->
name|builder
operator|.
name|left_bearing
operator|.
name|x
operator|=
name|INT_TO_FIXED
argument_list|(
name|metrics
operator|.
name|bearing_x
argument_list|)
expr_stmt|;
name|decoder
operator|->
name|builder
operator|.
name|advance
operator|.
name|x
operator|=
name|INT_TO_FIXED
argument_list|(
name|metrics
operator|.
name|advance
argument_list|)
expr_stmt|;
name|decoder
operator|->
name|builder
operator|.
name|advance
operator|.
name|y
operator|=
name|INT_TO_FIXED
argument_list|(
name|metrics
operator|.
name|advance_v
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* FT_CONFIG_OPTION_INCREMENTAL */
return|return
name|error
return|;
block|}
end_block
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|T1_Parse_Glyph
argument_list|(
argument|T1_Decoder  decoder
argument_list|,
argument|FT_UInt     glyph_index
argument_list|)
end_macro
begin_block
block|{
name|FT_Data
name|glyph_data
decl_stmt|;
name|FT_Error
name|error
init|=
name|T1_Parse_Glyph_And_Get_Char_String
argument_list|(
name|decoder
argument_list|,
name|glyph_index
argument_list|,
operator|&
name|glyph_data
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|FT_CONFIG_OPTION_INCREMENTAL
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|T1_Face
name|face
init|=
operator|(
name|T1_Face
operator|)
name|decoder
operator|->
name|builder
operator|.
name|face
decl_stmt|;
if|if
condition|(
name|face
operator|->
name|root
operator|.
name|internal
operator|->
name|incremental_interface
condition|)
name|face
operator|->
name|root
operator|.
name|internal
operator|->
name|incremental_interface
operator|->
name|funcs
operator|->
name|free_glyph_data
argument_list|(
name|face
operator|->
name|root
operator|.
name|internal
operator|->
name|incremental_interface
operator|->
name|object
argument_list|,
operator|&
name|glyph_data
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* FT_CONFIG_OPTION_INCREMENTAL */
return|return
name|error
return|;
block|}
end_block
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|T1_Compute_Max_Advance
argument_list|(
argument|T1_Face  face
argument_list|,
argument|FT_Pos*  max_advance
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
decl_stmt|;
name|T1_DecoderRec
name|decoder
decl_stmt|;
name|FT_Int
name|glyph_index
decl_stmt|;
name|T1_Font
name|type1
init|=
operator|&
name|face
operator|->
name|type1
decl_stmt|;
name|PSAux_Service
name|psaux
init|=
operator|(
name|PSAux_Service
operator|)
name|face
operator|->
name|psaux
decl_stmt|;
name|FT_ASSERT
argument_list|(
operator|(
name|face
operator|->
name|len_buildchar
operator|==
literal|0
operator|)
operator|==
operator|(
name|face
operator|->
name|buildchar
operator|==
name|NULL
operator|)
argument_list|)
expr_stmt|;
operator|*
name|max_advance
operator|=
literal|0
expr_stmt|;
comment|/* initialize load decoder */
name|error
operator|=
name|psaux
operator|->
name|t1_decoder_funcs
operator|->
name|init
argument_list|(
operator|&
name|decoder
argument_list|,
operator|(
name|FT_Face
operator|)
name|face
argument_list|,
literal|0
argument_list|,
comment|/* size       */
literal|0
argument_list|,
comment|/* glyph slot */
operator|(
name|FT_Byte
operator|*
operator|*
operator|)
name|type1
operator|->
name|glyph_names
argument_list|,
name|face
operator|->
name|blend
argument_list|,
literal|0
argument_list|,
name|FT_RENDER_MODE_NORMAL
argument_list|,
name|T1_Parse_Glyph
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|decoder
operator|.
name|builder
operator|.
name|metrics_only
operator|=
literal|1
expr_stmt|;
name|decoder
operator|.
name|builder
operator|.
name|load_points
operator|=
literal|0
expr_stmt|;
name|decoder
operator|.
name|num_subrs
operator|=
name|type1
operator|->
name|num_subrs
expr_stmt|;
name|decoder
operator|.
name|subrs
operator|=
name|type1
operator|->
name|subrs
expr_stmt|;
name|decoder
operator|.
name|subrs_len
operator|=
name|type1
operator|->
name|subrs_len
expr_stmt|;
name|decoder
operator|.
name|buildchar
operator|=
name|face
operator|->
name|buildchar
expr_stmt|;
name|decoder
operator|.
name|len_buildchar
operator|=
name|face
operator|->
name|len_buildchar
expr_stmt|;
operator|*
name|max_advance
operator|=
literal|0
expr_stmt|;
comment|/* for each glyph, parse the glyph charstring and extract */
comment|/* the advance width                                      */
for|for
control|(
name|glyph_index
operator|=
literal|0
init|;
name|glyph_index
operator|<
name|type1
operator|->
name|num_glyphs
condition|;
name|glyph_index
operator|++
control|)
block|{
comment|/* now get load the unscaled outline */
name|error
operator|=
name|T1_Parse_Glyph
argument_list|(
operator|&
name|decoder
argument_list|,
name|glyph_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|glyph_index
operator|==
literal|0
operator|||
name|decoder
operator|.
name|builder
operator|.
name|advance
operator|.
name|x
operator|>
operator|*
name|max_advance
condition|)
operator|*
name|max_advance
operator|=
name|decoder
operator|.
name|builder
operator|.
name|advance
operator|.
name|x
expr_stmt|;
comment|/* ignore the error if one occurred - skip to next glyph */
block|}
name|psaux
operator|->
name|t1_decoder_funcs
operator|->
name|done
argument_list|(
operator|&
name|decoder
argument_list|)
expr_stmt|;
return|return
name|T1_Err_Ok
return|;
block|}
end_block
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|T1_Get_Advances
argument_list|(
argument|T1_Face    face
argument_list|,
argument|FT_UInt    first
argument_list|,
argument|FT_UInt    count
argument_list|,
argument|FT_ULong   load_flags
argument_list|,
argument|FT_Fixed*  advances
argument_list|)
end_macro
begin_block
block|{
name|T1_DecoderRec
name|decoder
decl_stmt|;
name|T1_Font
name|type1
init|=
operator|&
name|face
operator|->
name|type1
decl_stmt|;
name|PSAux_Service
name|psaux
init|=
operator|(
name|PSAux_Service
operator|)
name|face
operator|->
name|psaux
decl_stmt|;
name|FT_UInt
name|nn
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
if|if
condition|(
name|load_flags
operator|&
name|FT_LOAD_VERTICAL_LAYOUT
condition|)
block|{
for|for
control|(
name|nn
operator|=
literal|0
init|;
name|nn
operator|<
name|count
condition|;
name|nn
operator|++
control|)
name|advances
index|[
name|nn
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|T1_Err_Ok
return|;
block|}
name|error
operator|=
name|psaux
operator|->
name|t1_decoder_funcs
operator|->
name|init
argument_list|(
operator|&
name|decoder
argument_list|,
operator|(
name|FT_Face
operator|)
name|face
argument_list|,
literal|0
argument_list|,
comment|/* size       */
literal|0
argument_list|,
comment|/* glyph slot */
operator|(
name|FT_Byte
operator|*
operator|*
operator|)
name|type1
operator|->
name|glyph_names
argument_list|,
name|face
operator|->
name|blend
argument_list|,
literal|0
argument_list|,
name|FT_RENDER_MODE_NORMAL
argument_list|,
name|T1_Parse_Glyph
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|decoder
operator|.
name|builder
operator|.
name|metrics_only
operator|=
literal|1
expr_stmt|;
name|decoder
operator|.
name|builder
operator|.
name|load_points
operator|=
literal|0
expr_stmt|;
name|decoder
operator|.
name|num_subrs
operator|=
name|type1
operator|->
name|num_subrs
expr_stmt|;
name|decoder
operator|.
name|subrs
operator|=
name|type1
operator|->
name|subrs
expr_stmt|;
name|decoder
operator|.
name|subrs_len
operator|=
name|type1
operator|->
name|subrs_len
expr_stmt|;
name|decoder
operator|.
name|buildchar
operator|=
name|face
operator|->
name|buildchar
expr_stmt|;
name|decoder
operator|.
name|len_buildchar
operator|=
name|face
operator|->
name|len_buildchar
expr_stmt|;
for|for
control|(
name|nn
operator|=
literal|0
init|;
name|nn
operator|<
name|count
condition|;
name|nn
operator|++
control|)
block|{
name|error
operator|=
name|T1_Parse_Glyph
argument_list|(
operator|&
name|decoder
argument_list|,
name|first
operator|+
name|nn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|advances
index|[
name|nn
index|]
operator|=
name|FIXED_TO_INT
argument_list|(
name|decoder
operator|.
name|builder
operator|.
name|advance
operator|.
name|x
argument_list|)
expr_stmt|;
else|else
name|advances
index|[
name|nn
index|]
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|T1_Err_Ok
return|;
block|}
end_block
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|T1_Load_Glyph
argument_list|(
argument|T1_GlyphSlot  glyph
argument_list|,
argument|T1_Size       size
argument_list|,
argument|FT_UInt       glyph_index
argument_list|,
argument|FT_Int32      load_flags
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
decl_stmt|;
name|T1_DecoderRec
name|decoder
decl_stmt|;
name|T1_Face
name|face
init|=
operator|(
name|T1_Face
operator|)
name|glyph
operator|->
name|root
operator|.
name|face
decl_stmt|;
name|FT_Bool
name|hinting
decl_stmt|;
name|T1_Font
name|type1
init|=
operator|&
name|face
operator|->
name|type1
decl_stmt|;
name|PSAux_Service
name|psaux
init|=
operator|(
name|PSAux_Service
operator|)
name|face
operator|->
name|psaux
decl_stmt|;
specifier|const
name|T1_Decoder_Funcs
name|decoder_funcs
init|=
name|psaux
operator|->
name|t1_decoder_funcs
decl_stmt|;
name|FT_Matrix
name|font_matrix
decl_stmt|;
name|FT_Vector
name|font_offset
decl_stmt|;
name|FT_Data
name|glyph_data
decl_stmt|;
name|FT_Bool
name|must_finish_decoder
init|=
name|FALSE
decl_stmt|;
ifdef|#
directive|ifdef
name|FT_CONFIG_OPTION_INCREMENTAL
name|FT_Bool
name|glyph_data_loaded
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|FT_CONFIG_OPTION_INCREMENTAL
if|if
condition|(
name|glyph_index
operator|>=
operator|(
name|FT_UInt
operator|)
name|face
operator|->
name|root
operator|.
name|num_glyphs
operator|&&
operator|!
name|face
operator|->
name|root
operator|.
name|internal
operator|->
name|incremental_interface
condition|)
else|#
directive|else
if|if
condition|(
name|glyph_index
operator|>=
operator|(
name|FT_UInt
operator|)
name|face
operator|->
name|root
operator|.
name|num_glyphs
condition|)
endif|#
directive|endif
comment|/* FT_CONFIG_OPTION_INCREMENTAL */
block|{
name|error
operator|=
name|T1_Err_Invalid_Argument
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|FT_ASSERT
argument_list|(
operator|(
name|face
operator|->
name|len_buildchar
operator|==
literal|0
operator|)
operator|==
operator|(
name|face
operator|->
name|buildchar
operator|==
name|NULL
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|load_flags
operator|&
name|FT_LOAD_NO_RECURSE
condition|)
name|load_flags
operator||=
name|FT_LOAD_NO_SCALE
operator||
name|FT_LOAD_NO_HINTING
expr_stmt|;
if|if
condition|(
name|size
condition|)
block|{
name|glyph
operator|->
name|x_scale
operator|=
name|size
operator|->
name|root
operator|.
name|metrics
operator|.
name|x_scale
expr_stmt|;
name|glyph
operator|->
name|y_scale
operator|=
name|size
operator|->
name|root
operator|.
name|metrics
operator|.
name|y_scale
expr_stmt|;
block|}
else|else
block|{
name|glyph
operator|->
name|x_scale
operator|=
literal|0x10000L
expr_stmt|;
name|glyph
operator|->
name|y_scale
operator|=
literal|0x10000L
expr_stmt|;
block|}
name|glyph
operator|->
name|root
operator|.
name|outline
operator|.
name|n_points
operator|=
literal|0
expr_stmt|;
name|glyph
operator|->
name|root
operator|.
name|outline
operator|.
name|n_contours
operator|=
literal|0
expr_stmt|;
name|hinting
operator|=
name|FT_BOOL
argument_list|(
operator|(
name|load_flags
operator|&
name|FT_LOAD_NO_SCALE
operator|)
operator|==
literal|0
operator|&&
operator|(
name|load_flags
operator|&
name|FT_LOAD_NO_HINTING
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|glyph
operator|->
name|root
operator|.
name|format
operator|=
name|FT_GLYPH_FORMAT_OUTLINE
expr_stmt|;
name|error
operator|=
name|decoder_funcs
operator|->
name|init
argument_list|(
operator|&
name|decoder
argument_list|,
operator|(
name|FT_Face
operator|)
name|face
argument_list|,
operator|(
name|FT_Size
operator|)
name|size
argument_list|,
operator|(
name|FT_GlyphSlot
operator|)
name|glyph
argument_list|,
operator|(
name|FT_Byte
operator|*
operator|*
operator|)
name|type1
operator|->
name|glyph_names
argument_list|,
name|face
operator|->
name|blend
argument_list|,
name|FT_BOOL
argument_list|(
name|hinting
argument_list|)
argument_list|,
name|FT_LOAD_TARGET_MODE
argument_list|(
name|load_flags
argument_list|)
argument_list|,
name|T1_Parse_Glyph
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|must_finish_decoder
operator|=
name|TRUE
expr_stmt|;
name|decoder
operator|.
name|builder
operator|.
name|no_recurse
operator|=
name|FT_BOOL
argument_list|(
operator|(
name|load_flags
operator|&
name|FT_LOAD_NO_RECURSE
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|decoder
operator|.
name|num_subrs
operator|=
name|type1
operator|->
name|num_subrs
expr_stmt|;
name|decoder
operator|.
name|subrs
operator|=
name|type1
operator|->
name|subrs
expr_stmt|;
name|decoder
operator|.
name|subrs_len
operator|=
name|type1
operator|->
name|subrs_len
expr_stmt|;
name|decoder
operator|.
name|buildchar
operator|=
name|face
operator|->
name|buildchar
expr_stmt|;
name|decoder
operator|.
name|len_buildchar
operator|=
name|face
operator|->
name|len_buildchar
expr_stmt|;
comment|/* now load the unscaled outline */
name|error
operator|=
name|T1_Parse_Glyph_And_Get_Char_String
argument_list|(
operator|&
name|decoder
argument_list|,
name|glyph_index
argument_list|,
operator|&
name|glyph_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
ifdef|#
directive|ifdef
name|FT_CONFIG_OPTION_INCREMENTAL
name|glyph_data_loaded
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|font_matrix
operator|=
name|decoder
operator|.
name|font_matrix
expr_stmt|;
name|font_offset
operator|=
name|decoder
operator|.
name|font_offset
expr_stmt|;
comment|/* save new glyph tables */
name|decoder_funcs
operator|->
name|done
argument_list|(
operator|&
name|decoder
argument_list|)
expr_stmt|;
name|must_finish_decoder
operator|=
name|FALSE
expr_stmt|;
comment|/* now, set the metrics -- this is rather simple, as   */
comment|/* the left side bearing is the xMin, and the top side */
comment|/* bearing the yMax                                    */
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|glyph
operator|->
name|root
operator|.
name|outline
operator|.
name|flags
operator|&=
name|FT_OUTLINE_OWNER
expr_stmt|;
name|glyph
operator|->
name|root
operator|.
name|outline
operator|.
name|flags
operator||=
name|FT_OUTLINE_REVERSE_FILL
expr_stmt|;
comment|/* for composite glyphs, return only left side bearing and */
comment|/* advance width                                           */
if|if
condition|(
name|load_flags
operator|&
name|FT_LOAD_NO_RECURSE
condition|)
block|{
name|FT_Slot_Internal
name|internal
init|=
name|glyph
operator|->
name|root
operator|.
name|internal
decl_stmt|;
name|glyph
operator|->
name|root
operator|.
name|metrics
operator|.
name|horiBearingX
operator|=
name|FIXED_TO_INT
argument_list|(
name|decoder
operator|.
name|builder
operator|.
name|left_bearing
operator|.
name|x
argument_list|)
expr_stmt|;
name|glyph
operator|->
name|root
operator|.
name|metrics
operator|.
name|horiAdvance
operator|=
name|FIXED_TO_INT
argument_list|(
name|decoder
operator|.
name|builder
operator|.
name|advance
operator|.
name|x
argument_list|)
expr_stmt|;
name|internal
operator|->
name|glyph_matrix
operator|=
name|font_matrix
expr_stmt|;
name|internal
operator|->
name|glyph_delta
operator|=
name|font_offset
expr_stmt|;
name|internal
operator|->
name|glyph_transformed
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|FT_BBox
name|cbox
decl_stmt|;
name|FT_Glyph_Metrics
modifier|*
name|metrics
init|=
operator|&
name|glyph
operator|->
name|root
operator|.
name|metrics
decl_stmt|;
name|FT_Vector
name|advance
decl_stmt|;
comment|/* copy the _unscaled_ advance width */
name|metrics
operator|->
name|horiAdvance
operator|=
name|FIXED_TO_INT
argument_list|(
name|decoder
operator|.
name|builder
operator|.
name|advance
operator|.
name|x
argument_list|)
expr_stmt|;
name|glyph
operator|->
name|root
operator|.
name|linearHoriAdvance
operator|=
name|FIXED_TO_INT
argument_list|(
name|decoder
operator|.
name|builder
operator|.
name|advance
operator|.
name|x
argument_list|)
expr_stmt|;
name|glyph
operator|->
name|root
operator|.
name|internal
operator|->
name|glyph_transformed
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|load_flags
operator|&
name|FT_LOAD_VERTICAL_LAYOUT
condition|)
block|{
comment|/* make up vertical ones */
name|metrics
operator|->
name|vertAdvance
operator|=
operator|(
name|face
operator|->
name|type1
operator|.
name|font_bbox
operator|.
name|yMax
operator|-
name|face
operator|->
name|type1
operator|.
name|font_bbox
operator|.
name|yMin
operator|)
operator|>>
literal|16
expr_stmt|;
name|glyph
operator|->
name|root
operator|.
name|linearVertAdvance
operator|=
name|metrics
operator|->
name|vertAdvance
expr_stmt|;
block|}
else|else
block|{
name|metrics
operator|->
name|vertAdvance
operator|=
name|FIXED_TO_INT
argument_list|(
name|decoder
operator|.
name|builder
operator|.
name|advance
operator|.
name|y
argument_list|)
expr_stmt|;
name|glyph
operator|->
name|root
operator|.
name|linearVertAdvance
operator|=
name|FIXED_TO_INT
argument_list|(
name|decoder
operator|.
name|builder
operator|.
name|advance
operator|.
name|y
argument_list|)
expr_stmt|;
block|}
name|glyph
operator|->
name|root
operator|.
name|format
operator|=
name|FT_GLYPH_FORMAT_OUTLINE
expr_stmt|;
if|if
condition|(
name|size
operator|&&
name|size
operator|->
name|root
operator|.
name|metrics
operator|.
name|y_ppem
operator|<
literal|24
condition|)
name|glyph
operator|->
name|root
operator|.
name|outline
operator|.
name|flags
operator||=
name|FT_OUTLINE_HIGH_PRECISION
expr_stmt|;
if|#
directive|if
literal|1
comment|/* apply the font matrix, if any */
if|if
condition|(
name|font_matrix
operator|.
name|xx
operator|!=
literal|0x10000L
operator|||
name|font_matrix
operator|.
name|yy
operator|!=
name|font_matrix
operator|.
name|xx
operator|||
name|font_matrix
operator|.
name|xy
operator|!=
literal|0
operator|||
name|font_matrix
operator|.
name|yx
operator|!=
literal|0
condition|)
name|FT_Outline_Transform
argument_list|(
operator|&
name|glyph
operator|->
name|root
operator|.
name|outline
argument_list|,
operator|&
name|font_matrix
argument_list|)
expr_stmt|;
if|if
condition|(
name|font_offset
operator|.
name|x
operator|||
name|font_offset
operator|.
name|y
condition|)
name|FT_Outline_Translate
argument_list|(
operator|&
name|glyph
operator|->
name|root
operator|.
name|outline
argument_list|,
name|font_offset
operator|.
name|x
argument_list|,
name|font_offset
operator|.
name|y
argument_list|)
expr_stmt|;
name|advance
operator|.
name|x
operator|=
name|metrics
operator|->
name|horiAdvance
expr_stmt|;
name|advance
operator|.
name|y
operator|=
literal|0
expr_stmt|;
name|FT_Vector_Transform
argument_list|(
operator|&
name|advance
argument_list|,
operator|&
name|font_matrix
argument_list|)
expr_stmt|;
name|metrics
operator|->
name|horiAdvance
operator|=
name|advance
operator|.
name|x
operator|+
name|font_offset
operator|.
name|x
expr_stmt|;
name|advance
operator|.
name|x
operator|=
literal|0
expr_stmt|;
name|advance
operator|.
name|y
operator|=
name|metrics
operator|->
name|vertAdvance
expr_stmt|;
name|FT_Vector_Transform
argument_list|(
operator|&
name|advance
argument_list|,
operator|&
name|font_matrix
argument_list|)
expr_stmt|;
name|metrics
operator|->
name|vertAdvance
operator|=
name|advance
operator|.
name|y
operator|+
name|font_offset
operator|.
name|y
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|load_flags
operator|&
name|FT_LOAD_NO_SCALE
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* scale the outline and the metrics */
name|FT_Int
name|n
decl_stmt|;
name|FT_Outline
modifier|*
name|cur
init|=
name|decoder
operator|.
name|builder
operator|.
name|base
decl_stmt|;
name|FT_Vector
modifier|*
name|vec
init|=
name|cur
operator|->
name|points
decl_stmt|;
name|FT_Fixed
name|x_scale
init|=
name|glyph
operator|->
name|x_scale
decl_stmt|;
name|FT_Fixed
name|y_scale
init|=
name|glyph
operator|->
name|y_scale
decl_stmt|;
comment|/* First of all, scale the points, if we are not hinting */
if|if
condition|(
operator|!
name|hinting
operator|||
operator|!
name|decoder
operator|.
name|builder
operator|.
name|hints_funcs
condition|)
for|for
control|(
name|n
operator|=
name|cur
operator|->
name|n_points
init|;
name|n
operator|>
literal|0
condition|;
name|n
operator|--
operator|,
name|vec
operator|++
control|)
block|{
name|vec
operator|->
name|x
operator|=
name|FT_MulFix
argument_list|(
name|vec
operator|->
name|x
argument_list|,
name|x_scale
argument_list|)
expr_stmt|;
name|vec
operator|->
name|y
operator|=
name|FT_MulFix
argument_list|(
name|vec
operator|->
name|y
argument_list|,
name|y_scale
argument_list|)
expr_stmt|;
block|}
comment|/* Then scale the metrics */
name|metrics
operator|->
name|horiAdvance
operator|=
name|FT_MulFix
argument_list|(
name|metrics
operator|->
name|horiAdvance
argument_list|,
name|x_scale
argument_list|)
expr_stmt|;
name|metrics
operator|->
name|vertAdvance
operator|=
name|FT_MulFix
argument_list|(
name|metrics
operator|->
name|vertAdvance
argument_list|,
name|y_scale
argument_list|)
expr_stmt|;
block|}
comment|/* compute the other metrics */
name|FT_Outline_Get_CBox
argument_list|(
operator|&
name|glyph
operator|->
name|root
operator|.
name|outline
argument_list|,
operator|&
name|cbox
argument_list|)
expr_stmt|;
name|metrics
operator|->
name|width
operator|=
name|cbox
operator|.
name|xMax
operator|-
name|cbox
operator|.
name|xMin
expr_stmt|;
name|metrics
operator|->
name|height
operator|=
name|cbox
operator|.
name|yMax
operator|-
name|cbox
operator|.
name|yMin
expr_stmt|;
name|metrics
operator|->
name|horiBearingX
operator|=
name|cbox
operator|.
name|xMin
expr_stmt|;
name|metrics
operator|->
name|horiBearingY
operator|=
name|cbox
operator|.
name|yMax
expr_stmt|;
if|if
condition|(
name|load_flags
operator|&
name|FT_LOAD_VERTICAL_LAYOUT
condition|)
block|{
comment|/* make up vertical ones */
name|ft_synthesize_vertical_metrics
argument_list|(
name|metrics
argument_list|,
name|metrics
operator|->
name|vertAdvance
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Set control data to the glyph charstrings.  Note that this is */
comment|/* _not_ zero-terminated.                                        */
name|glyph
operator|->
name|root
operator|.
name|control_data
operator|=
operator|(
name|FT_Byte
operator|*
operator|)
name|glyph_data
operator|.
name|pointer
expr_stmt|;
name|glyph
operator|->
name|root
operator|.
name|control_len
operator|=
name|glyph_data
operator|.
name|length
expr_stmt|;
block|}
name|Exit
label|:
ifdef|#
directive|ifdef
name|FT_CONFIG_OPTION_INCREMENTAL
if|if
condition|(
name|glyph_data_loaded
operator|&&
name|face
operator|->
name|root
operator|.
name|internal
operator|->
name|incremental_interface
condition|)
block|{
name|face
operator|->
name|root
operator|.
name|internal
operator|->
name|incremental_interface
operator|->
name|funcs
operator|->
name|free_glyph_data
argument_list|(
name|face
operator|->
name|root
operator|.
name|internal
operator|->
name|incremental_interface
operator|->
name|object
argument_list|,
operator|&
name|glyph_data
argument_list|)
expr_stmt|;
comment|/* Set the control data to null - it is no longer available if   */
comment|/* loaded incrementally.                                         */
name|glyph
operator|->
name|root
operator|.
name|control_data
operator|=
literal|0
expr_stmt|;
name|glyph
operator|->
name|root
operator|.
name|control_len
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|must_finish_decoder
condition|)
name|decoder_funcs
operator|->
name|done
argument_list|(
operator|&
name|decoder
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/* END */
end_comment
end_unit
