begin_unit
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  t1load.c                                                               */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*    Type 1 font loader (body).                                           */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 by */
end_comment
begin_comment
comment|/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  This file is part of the FreeType project, and may only be used,       */
end_comment
begin_comment
comment|/*  modified, and distributed under the terms of the FreeType project      */
end_comment
begin_comment
comment|/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
end_comment
begin_comment
comment|/*  this file you indicate that you have read the license and              */
end_comment
begin_comment
comment|/*  understand and accept it fully.                                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* This is the new and improved Type 1 data loader for FreeType 2.  The  */
end_comment
begin_comment
comment|/* old loader has several problems: it is slow, complex, difficult to    */
end_comment
begin_comment
comment|/* maintain, and contains incredible hacks to make it accept some        */
end_comment
begin_comment
comment|/* ill-formed Type 1 fonts without hiccup-ing.  Moreover, about 5% of    */
end_comment
begin_comment
comment|/* the Type 1 fonts on my machine still aren't loaded correctly by it.   */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* This version is much simpler, much faster and also easier to read and */
end_comment
begin_comment
comment|/* maintain by a great order of magnitude.  The idea behind it is to     */
end_comment
begin_comment
comment|/* _not_ try to read the Type 1 token stream with a state machine (i.e.  */
end_comment
begin_comment
comment|/* a Postscript-like interpreter) but rather to perform simple pattern   */
end_comment
begin_comment
comment|/* matching.                                                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* Indeed, nearly all data definitions follow a simple pattern like      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*  ... /Field<data> ...                                                */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* where<data> can be a number, a boolean, a string, or an array of     */
end_comment
begin_comment
comment|/* numbers.  There are a few exceptions, namely the encoding, font name, */
end_comment
begin_comment
comment|/* charstrings, and subrs; they are handled with a special pattern       */
end_comment
begin_comment
comment|/* matching routine.                                                     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* All other common cases are handled very simply.  The matching rules   */
end_comment
begin_comment
comment|/* are defined in the file `t1tokens.h' through the use of several       */
end_comment
begin_comment
comment|/* macros calls PARSE_XXX.  This file is included twice here; the first  */
end_comment
begin_comment
comment|/* time to generate parsing callback functions, the second time to       */
end_comment
begin_comment
comment|/* generate a table of keywords (with pointers to the associated         */
end_comment
begin_comment
comment|/* callback functions).                                                  */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* The function `parse_dict' simply scans *linearly* a given dictionary  */
end_comment
begin_comment
comment|/* (either the top-level or private one) and calls the appropriate       */
end_comment
begin_comment
comment|/* callback when it encounters an immediate keyword.                     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* This is by far the fastest way one can find to parse and read all     */
end_comment
begin_comment
comment|/* data.                                                                 */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* This led to tremendous code size reduction.  Note that later, the     */
end_comment
begin_comment
comment|/* glyph loader will also be _greatly_ simplified, and the automatic     */
end_comment
begin_comment
comment|/* hinter will replace the clumsy `t1hinter'.                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<ft2build.h>
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_DEBUG_H
end_include
begin_include
include|#
directive|include
include|FT_CONFIG_CONFIG_H
end_include
begin_include
include|#
directive|include
include|FT_MULTIPLE_MASTERS_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_TYPE1_TYPES_H
end_include
begin_include
include|#
directive|include
file|"t1load.h"
end_include
begin_include
include|#
directive|include
file|"t1errors.h"
end_include
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
end_comment
begin_comment
comment|/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
end_comment
begin_comment
comment|/* messages during execution.                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_undef
DECL|macro|FT_COMPONENT
undef|#
directive|undef
name|FT_COMPONENT
end_undef
begin_define
DECL|macro|FT_COMPONENT
define|#
directive|define
name|FT_COMPONENT
value|trace_t1load
end_define
begin_ifndef
ifndef|#
directive|ifndef
name|T1_CONFIG_OPTION_NO_MM_SUPPORT
end_ifndef
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****                    MULTIPLE MASTERS SUPPORT                   *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|t1_allocate_blend
name|t1_allocate_blend
parameter_list|(
name|T1_Face
name|face
parameter_list|,
name|FT_UInt
name|num_designs
parameter_list|,
name|FT_UInt
name|num_axis
parameter_list|)
block|{
name|PS_Blend
name|blend
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|face
operator|->
name|root
operator|.
name|memory
decl_stmt|;
name|FT_Error
name|error
init|=
name|T1_Err_Ok
decl_stmt|;
name|blend
operator|=
name|face
operator|->
name|blend
expr_stmt|;
if|if
condition|(
operator|!
name|blend
condition|)
block|{
if|if
condition|(
name|FT_NEW
argument_list|(
name|blend
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|blend
operator|->
name|num_default_design_vector
operator|=
literal|0
expr_stmt|;
name|face
operator|->
name|blend
operator|=
name|blend
expr_stmt|;
block|}
comment|/* allocate design data if needed */
if|if
condition|(
name|num_designs
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|blend
operator|->
name|num_designs
operator|==
literal|0
condition|)
block|{
name|FT_UInt
name|nn
decl_stmt|;
comment|/* allocate the blend `private' and `font_info' dictionaries */
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|blend
operator|->
name|font_infos
index|[
literal|1
index|]
argument_list|,
name|num_designs
argument_list|)
operator|||
name|FT_NEW_ARRAY
argument_list|(
name|blend
operator|->
name|privates
index|[
literal|1
index|]
argument_list|,
name|num_designs
argument_list|)
operator|||
name|FT_NEW_ARRAY
argument_list|(
name|blend
operator|->
name|bboxes
index|[
literal|1
index|]
argument_list|,
name|num_designs
argument_list|)
operator|||
name|FT_NEW_ARRAY
argument_list|(
name|blend
operator|->
name|weight_vector
argument_list|,
name|num_designs
operator|*
literal|2
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|blend
operator|->
name|default_weight_vector
operator|=
name|blend
operator|->
name|weight_vector
operator|+
name|num_designs
expr_stmt|;
name|blend
operator|->
name|font_infos
index|[
literal|0
index|]
operator|=
operator|&
name|face
operator|->
name|type1
operator|.
name|font_info
expr_stmt|;
name|blend
operator|->
name|privates
index|[
literal|0
index|]
operator|=
operator|&
name|face
operator|->
name|type1
operator|.
name|private_dict
expr_stmt|;
name|blend
operator|->
name|bboxes
index|[
literal|0
index|]
operator|=
operator|&
name|face
operator|->
name|type1
operator|.
name|font_bbox
expr_stmt|;
for|for
control|(
name|nn
operator|=
literal|2
init|;
name|nn
operator|<=
name|num_designs
condition|;
name|nn
operator|++
control|)
block|{
name|blend
operator|->
name|privates
index|[
name|nn
index|]
operator|=
name|blend
operator|->
name|privates
index|[
name|nn
operator|-
literal|1
index|]
operator|+
literal|1
expr_stmt|;
name|blend
operator|->
name|font_infos
index|[
name|nn
index|]
operator|=
name|blend
operator|->
name|font_infos
index|[
name|nn
operator|-
literal|1
index|]
operator|+
literal|1
expr_stmt|;
name|blend
operator|->
name|bboxes
index|[
name|nn
index|]
operator|=
name|blend
operator|->
name|bboxes
index|[
name|nn
operator|-
literal|1
index|]
operator|+
literal|1
expr_stmt|;
block|}
name|blend
operator|->
name|num_designs
operator|=
name|num_designs
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|blend
operator|->
name|num_designs
operator|!=
name|num_designs
condition|)
goto|goto
name|Fail
goto|;
block|}
comment|/* allocate axis data if needed */
if|if
condition|(
name|num_axis
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|blend
operator|->
name|num_axis
operator|!=
literal|0
operator|&&
name|blend
operator|->
name|num_axis
operator|!=
name|num_axis
condition|)
goto|goto
name|Fail
goto|;
name|blend
operator|->
name|num_axis
operator|=
name|num_axis
expr_stmt|;
block|}
comment|/* allocate the blend design pos table if needed */
name|num_designs
operator|=
name|blend
operator|->
name|num_designs
expr_stmt|;
name|num_axis
operator|=
name|blend
operator|->
name|num_axis
expr_stmt|;
if|if
condition|(
name|num_designs
operator|&&
name|num_axis
operator|&&
name|blend
operator|->
name|design_pos
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|FT_UInt
name|n
decl_stmt|;
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|blend
operator|->
name|design_pos
index|[
literal|0
index|]
argument_list|,
name|num_designs
operator|*
name|num_axis
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
for|for
control|(
name|n
operator|=
literal|1
init|;
name|n
operator|<
name|num_designs
condition|;
name|n
operator|++
control|)
name|blend
operator|->
name|design_pos
index|[
name|n
index|]
operator|=
name|blend
operator|->
name|design_pos
index|[
literal|0
index|]
operator|+
name|num_axis
operator|*
name|n
expr_stmt|;
block|}
name|Exit
label|:
return|return
name|error
return|;
name|Fail
label|:
name|error
operator|=
name|T1_Err_Invalid_File_Format
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
end_function
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|T1_Get_Multi_Master
argument_list|(
argument|T1_Face           face
argument_list|,
argument|FT_Multi_Master*  master
argument_list|)
end_macro
begin_block
block|{
name|PS_Blend
name|blend
init|=
name|face
operator|->
name|blend
decl_stmt|;
name|FT_UInt
name|n
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|error
operator|=
name|T1_Err_Invalid_Argument
expr_stmt|;
if|if
condition|(
name|blend
condition|)
block|{
name|master
operator|->
name|num_axis
operator|=
name|blend
operator|->
name|num_axis
expr_stmt|;
name|master
operator|->
name|num_designs
operator|=
name|blend
operator|->
name|num_designs
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|blend
operator|->
name|num_axis
condition|;
name|n
operator|++
control|)
block|{
name|FT_MM_Axis
modifier|*
name|axis
init|=
name|master
operator|->
name|axis
operator|+
name|n
decl_stmt|;
name|PS_DesignMap
name|map
init|=
name|blend
operator|->
name|design_map
operator|+
name|n
decl_stmt|;
name|axis
operator|->
name|name
operator|=
name|blend
operator|->
name|axis_names
index|[
name|n
index|]
expr_stmt|;
name|axis
operator|->
name|minimum
operator|=
name|map
operator|->
name|design_points
index|[
literal|0
index|]
expr_stmt|;
name|axis
operator|->
name|maximum
operator|=
name|map
operator|->
name|design_points
index|[
name|map
operator|->
name|num_points
operator|-
literal|1
index|]
expr_stmt|;
block|}
name|error
operator|=
name|T1_Err_Ok
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_block
begin_define
DECL|macro|FT_INT_TO_FIXED
define|#
directive|define
name|FT_INT_TO_FIXED
parameter_list|(
name|a
parameter_list|)
value|( (a)<< 16 )
end_define
begin_define
DECL|macro|FT_FIXED_TO_INT
define|#
directive|define
name|FT_FIXED_TO_INT
parameter_list|(
name|a
parameter_list|)
value|( FT_RoundFix( a )>> 16 )
end_define
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* Given a normalized (blend) coordinate, figure out the design          */
end_comment
begin_comment
comment|/* coordinate appropriate for that value.                                */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Fixed
argument_list|)
end_macro
begin_macro
name|mm_axis_unmap
argument_list|(
argument|PS_DesignMap  axismap
argument_list|,
argument|FT_Fixed      ncv
argument_list|)
end_macro
begin_block
block|{
name|int
name|j
decl_stmt|;
if|if
condition|(
name|ncv
operator|<=
name|axismap
operator|->
name|blend_points
index|[
literal|0
index|]
condition|)
return|return
name|FT_INT_TO_FIXED
argument_list|(
name|axismap
operator|->
name|design_points
index|[
literal|0
index|]
argument_list|)
return|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|axismap
operator|->
name|num_points
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|ncv
operator|<=
name|axismap
operator|->
name|blend_points
index|[
name|j
index|]
condition|)
block|{
name|FT_Fixed
name|t
init|=
name|FT_MulDiv
argument_list|(
name|ncv
operator|-
name|axismap
operator|->
name|blend_points
index|[
name|j
operator|-
literal|1
index|]
argument_list|,
literal|0x10000L
argument_list|,
name|axismap
operator|->
name|blend_points
index|[
name|j
index|]
operator|-
name|axismap
operator|->
name|blend_points
index|[
name|j
operator|-
literal|1
index|]
argument_list|)
decl_stmt|;
return|return
name|FT_INT_TO_FIXED
argument_list|(
name|axismap
operator|->
name|design_points
index|[
name|j
operator|-
literal|1
index|]
argument_list|)
operator|+
name|FT_MulDiv
argument_list|(
name|t
argument_list|,
name|axismap
operator|->
name|design_points
index|[
name|j
index|]
operator|-
name|axismap
operator|->
name|design_points
index|[
name|j
operator|-
literal|1
index|]
argument_list|,
literal|1L
argument_list|)
return|;
block|}
block|}
return|return
name|FT_INT_TO_FIXED
argument_list|(
name|axismap
operator|->
name|design_points
index|[
name|axismap
operator|->
name|num_points
operator|-
literal|1
index|]
argument_list|)
return|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* Given a vector of weights, one for each design, figure out the        */
end_comment
begin_comment
comment|/* normalized axis coordinates which gave rise to those weights.         */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|mm_weights_unmap
name|mm_weights_unmap
argument_list|(
argument|FT_Fixed*  weights
argument_list|,
argument|FT_Fixed*  axiscoords
argument_list|,
argument|FT_UInt    axis_count
argument_list|)
end_macro
begin_block
block|{
name|FT_ASSERT
argument_list|(
name|axis_count
operator|<=
name|T1_MAX_MM_AXIS
argument_list|)
expr_stmt|;
if|if
condition|(
name|axis_count
operator|==
literal|1
condition|)
name|axiscoords
index|[
literal|0
index|]
operator|=
name|weights
index|[
literal|1
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|axis_count
operator|==
literal|2
condition|)
block|{
name|axiscoords
index|[
literal|0
index|]
operator|=
name|weights
index|[
literal|3
index|]
operator|+
name|weights
index|[
literal|1
index|]
expr_stmt|;
name|axiscoords
index|[
literal|1
index|]
operator|=
name|weights
index|[
literal|3
index|]
operator|+
name|weights
index|[
literal|2
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|axis_count
operator|==
literal|3
condition|)
block|{
name|axiscoords
index|[
literal|0
index|]
operator|=
name|weights
index|[
literal|7
index|]
operator|+
name|weights
index|[
literal|5
index|]
operator|+
name|weights
index|[
literal|3
index|]
operator|+
name|weights
index|[
literal|1
index|]
expr_stmt|;
name|axiscoords
index|[
literal|1
index|]
operator|=
name|weights
index|[
literal|7
index|]
operator|+
name|weights
index|[
literal|6
index|]
operator|+
name|weights
index|[
literal|3
index|]
operator|+
name|weights
index|[
literal|2
index|]
expr_stmt|;
name|axiscoords
index|[
literal|2
index|]
operator|=
name|weights
index|[
literal|7
index|]
operator|+
name|weights
index|[
literal|6
index|]
operator|+
name|weights
index|[
literal|5
index|]
operator|+
name|weights
index|[
literal|4
index|]
expr_stmt|;
block|}
else|else
block|{
name|axiscoords
index|[
literal|0
index|]
operator|=
name|weights
index|[
literal|15
index|]
operator|+
name|weights
index|[
literal|13
index|]
operator|+
name|weights
index|[
literal|11
index|]
operator|+
name|weights
index|[
literal|9
index|]
operator|+
name|weights
index|[
literal|7
index|]
operator|+
name|weights
index|[
literal|5
index|]
operator|+
name|weights
index|[
literal|3
index|]
operator|+
name|weights
index|[
literal|1
index|]
expr_stmt|;
name|axiscoords
index|[
literal|1
index|]
operator|=
name|weights
index|[
literal|15
index|]
operator|+
name|weights
index|[
literal|14
index|]
operator|+
name|weights
index|[
literal|11
index|]
operator|+
name|weights
index|[
literal|10
index|]
operator|+
name|weights
index|[
literal|7
index|]
operator|+
name|weights
index|[
literal|6
index|]
operator|+
name|weights
index|[
literal|3
index|]
operator|+
name|weights
index|[
literal|2
index|]
expr_stmt|;
name|axiscoords
index|[
literal|2
index|]
operator|=
name|weights
index|[
literal|15
index|]
operator|+
name|weights
index|[
literal|14
index|]
operator|+
name|weights
index|[
literal|13
index|]
operator|+
name|weights
index|[
literal|12
index|]
operator|+
name|weights
index|[
literal|7
index|]
operator|+
name|weights
index|[
literal|6
index|]
operator|+
name|weights
index|[
literal|5
index|]
operator|+
name|weights
index|[
literal|4
index|]
expr_stmt|;
name|axiscoords
index|[
literal|3
index|]
operator|=
name|weights
index|[
literal|15
index|]
operator|+
name|weights
index|[
literal|14
index|]
operator|+
name|weights
index|[
literal|13
index|]
operator|+
name|weights
index|[
literal|12
index|]
operator|+
name|weights
index|[
literal|11
index|]
operator|+
name|weights
index|[
literal|10
index|]
operator|+
name|weights
index|[
literal|9
index|]
operator|+
name|weights
index|[
literal|8
index|]
expr_stmt|;
block|}
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* Just a wrapper around T1_Get_Multi_Master to support the different    */
end_comment
begin_comment
comment|/*  arguments needed by the GX var distortable fonts.                    */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|T1_Get_MM_Var
argument_list|(
argument|T1_Face      face
argument_list|,
argument|FT_MM_Var*  *master
argument_list|)
end_macro
begin_block
block|{
name|FT_Memory
name|memory
init|=
name|face
operator|->
name|root
operator|.
name|memory
decl_stmt|;
name|FT_MM_Var
modifier|*
name|mmvar
decl_stmt|;
name|FT_Multi_Master
name|mmaster
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|FT_UInt
name|i
decl_stmt|;
name|FT_Fixed
name|axiscoords
index|[
name|T1_MAX_MM_AXIS
index|]
decl_stmt|;
name|PS_Blend
name|blend
init|=
name|face
operator|->
name|blend
decl_stmt|;
name|error
operator|=
name|T1_Get_Multi_Master
argument_list|(
name|face
argument_list|,
operator|&
name|mmaster
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
if|if
condition|(
name|FT_ALLOC
argument_list|(
name|mmvar
argument_list|,
sizeof|sizeof
argument_list|(
name|FT_MM_Var
argument_list|)
operator|+
name|mmaster
operator|.
name|num_axis
operator|*
sizeof|sizeof
argument_list|(
name|FT_Var_Axis
argument_list|)
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|mmvar
operator|->
name|num_axis
operator|=
name|mmaster
operator|.
name|num_axis
expr_stmt|;
name|mmvar
operator|->
name|num_designs
operator|=
name|mmaster
operator|.
name|num_designs
expr_stmt|;
name|mmvar
operator|->
name|num_namedstyles
operator|=
operator|(
name|FT_UInt
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* Does not apply */
name|mmvar
operator|->
name|axis
operator|=
operator|(
name|FT_Var_Axis
operator|*
operator|)
operator|&
name|mmvar
index|[
literal|1
index|]
expr_stmt|;
comment|/* Point to axes after MM_Var struct */
name|mmvar
operator|->
name|namedstyle
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mmaster
operator|.
name|num_axis
condition|;
operator|++
name|i
control|)
block|{
name|mmvar
operator|->
name|axis
index|[
name|i
index|]
operator|.
name|name
operator|=
name|mmaster
operator|.
name|axis
index|[
name|i
index|]
operator|.
name|name
expr_stmt|;
name|mmvar
operator|->
name|axis
index|[
name|i
index|]
operator|.
name|minimum
operator|=
name|FT_INT_TO_FIXED
argument_list|(
name|mmaster
operator|.
name|axis
index|[
name|i
index|]
operator|.
name|minimum
argument_list|)
expr_stmt|;
name|mmvar
operator|->
name|axis
index|[
name|i
index|]
operator|.
name|maximum
operator|=
name|FT_INT_TO_FIXED
argument_list|(
name|mmaster
operator|.
name|axis
index|[
name|i
index|]
operator|.
name|maximum
argument_list|)
expr_stmt|;
name|mmvar
operator|->
name|axis
index|[
name|i
index|]
operator|.
name|def
operator|=
operator|(
name|mmvar
operator|->
name|axis
index|[
name|i
index|]
operator|.
name|minimum
operator|+
name|mmvar
operator|->
name|axis
index|[
name|i
index|]
operator|.
name|maximum
operator|)
operator|/
literal|2
expr_stmt|;
comment|/* Does not apply.  But this value is in range */
name|mmvar
operator|->
name|axis
index|[
name|i
index|]
operator|.
name|strid
operator|=
operator|(
name|FT_UInt
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* Does not apply */
name|mmvar
operator|->
name|axis
index|[
name|i
index|]
operator|.
name|tag
operator|=
operator|(
name|FT_ULong
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* Does not apply */
if|if
condition|(
name|ft_strcmp
argument_list|(
name|mmvar
operator|->
name|axis
index|[
name|i
index|]
operator|.
name|name
argument_list|,
literal|"Weight"
argument_list|)
operator|==
literal|0
condition|)
name|mmvar
operator|->
name|axis
index|[
name|i
index|]
operator|.
name|tag
operator|=
name|FT_MAKE_TAG
argument_list|(
literal|'w'
argument_list|,
literal|'g'
argument_list|,
literal|'h'
argument_list|,
literal|'t'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ft_strcmp
argument_list|(
name|mmvar
operator|->
name|axis
index|[
name|i
index|]
operator|.
name|name
argument_list|,
literal|"Width"
argument_list|)
operator|==
literal|0
condition|)
name|mmvar
operator|->
name|axis
index|[
name|i
index|]
operator|.
name|tag
operator|=
name|FT_MAKE_TAG
argument_list|(
literal|'w'
argument_list|,
literal|'d'
argument_list|,
literal|'t'
argument_list|,
literal|'h'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ft_strcmp
argument_list|(
name|mmvar
operator|->
name|axis
index|[
name|i
index|]
operator|.
name|name
argument_list|,
literal|"OpticalSize"
argument_list|)
operator|==
literal|0
condition|)
name|mmvar
operator|->
name|axis
index|[
name|i
index|]
operator|.
name|tag
operator|=
name|FT_MAKE_TAG
argument_list|(
literal|'o'
argument_list|,
literal|'p'
argument_list|,
literal|'s'
argument_list|,
literal|'z'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|blend
operator|->
name|num_designs
operator|==
operator|(
literal|1U
operator|<<
name|blend
operator|->
name|num_axis
operator|)
condition|)
block|{
name|mm_weights_unmap
argument_list|(
name|blend
operator|->
name|default_weight_vector
argument_list|,
name|axiscoords
argument_list|,
name|blend
operator|->
name|num_axis
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mmaster
operator|.
name|num_axis
condition|;
operator|++
name|i
control|)
name|mmvar
operator|->
name|axis
index|[
name|i
index|]
operator|.
name|def
operator|=
name|mm_axis_unmap
argument_list|(
operator|&
name|blend
operator|->
name|design_map
index|[
name|i
index|]
argument_list|,
name|axiscoords
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
operator|*
name|master
operator|=
name|mmvar
expr_stmt|;
name|Exit
label|:
return|return
name|error
return|;
block|}
end_block
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|T1_Set_MM_Blend
argument_list|(
argument|T1_Face    face
argument_list|,
argument|FT_UInt    num_coords
argument_list|,
argument|FT_Fixed*  coords
argument_list|)
end_macro
begin_block
block|{
name|PS_Blend
name|blend
init|=
name|face
operator|->
name|blend
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|FT_UInt
name|n
decl_stmt|,
name|m
decl_stmt|;
name|error
operator|=
name|T1_Err_Invalid_Argument
expr_stmt|;
if|if
condition|(
name|blend
operator|&&
name|blend
operator|->
name|num_axis
operator|==
name|num_coords
condition|)
block|{
comment|/* recompute the weight vector from the blend coordinates */
name|error
operator|=
name|T1_Err_Ok
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|blend
operator|->
name|num_designs
condition|;
name|n
operator|++
control|)
block|{
name|FT_Fixed
name|result
init|=
literal|0x10000L
decl_stmt|;
comment|/* 1.0 fixed */
for|for
control|(
name|m
operator|=
literal|0
init|;
name|m
operator|<
name|blend
operator|->
name|num_axis
condition|;
name|m
operator|++
control|)
block|{
name|FT_Fixed
name|factor
decl_stmt|;
comment|/* get current blend axis position */
name|factor
operator|=
name|coords
index|[
name|m
index|]
expr_stmt|;
if|if
condition|(
name|factor
operator|<
literal|0
condition|)
name|factor
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|factor
operator|>
literal|0x10000L
condition|)
name|factor
operator|=
literal|0x10000L
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|&
operator|(
literal|1
operator|<<
name|m
operator|)
operator|)
operator|==
literal|0
condition|)
name|factor
operator|=
literal|0x10000L
operator|-
name|factor
expr_stmt|;
name|result
operator|=
name|FT_MulFix
argument_list|(
name|result
argument_list|,
name|factor
argument_list|)
expr_stmt|;
block|}
name|blend
operator|->
name|weight_vector
index|[
name|n
index|]
operator|=
name|result
expr_stmt|;
block|}
name|error
operator|=
name|T1_Err_Ok
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_block
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|T1_Set_MM_Design
argument_list|(
argument|T1_Face   face
argument_list|,
argument|FT_UInt   num_coords
argument_list|,
argument|FT_Long*  coords
argument_list|)
end_macro
begin_block
block|{
name|PS_Blend
name|blend
init|=
name|face
operator|->
name|blend
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|FT_UInt
name|n
decl_stmt|,
name|p
decl_stmt|;
name|error
operator|=
name|T1_Err_Invalid_Argument
expr_stmt|;
if|if
condition|(
name|blend
operator|&&
name|blend
operator|->
name|num_axis
operator|==
name|num_coords
condition|)
block|{
comment|/* compute the blend coordinates through the blend design map */
name|FT_Fixed
name|final_blends
index|[
name|T1_MAX_MM_DESIGNS
index|]
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|blend
operator|->
name|num_axis
condition|;
name|n
operator|++
control|)
block|{
name|FT_Long
name|design
init|=
name|coords
index|[
name|n
index|]
decl_stmt|;
name|FT_Fixed
name|the_blend
decl_stmt|;
name|PS_DesignMap
name|map
init|=
name|blend
operator|->
name|design_map
operator|+
name|n
decl_stmt|;
name|FT_Long
modifier|*
name|designs
init|=
name|map
operator|->
name|design_points
decl_stmt|;
name|FT_Fixed
modifier|*
name|blends
init|=
name|map
operator|->
name|blend_points
decl_stmt|;
name|FT_Int
name|before
init|=
operator|-
literal|1
decl_stmt|,
name|after
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|p
operator|=
literal|0
init|;
name|p
operator|<
operator|(
name|FT_UInt
operator|)
name|map
operator|->
name|num_points
condition|;
name|p
operator|++
control|)
block|{
name|FT_Long
name|p_design
init|=
name|designs
index|[
name|p
index|]
decl_stmt|;
comment|/* exact match? */
if|if
condition|(
name|design
operator|==
name|p_design
condition|)
block|{
name|the_blend
operator|=
name|blends
index|[
name|p
index|]
expr_stmt|;
goto|goto
name|Found
goto|;
block|}
if|if
condition|(
name|design
operator|<
name|p_design
condition|)
block|{
name|after
operator|=
name|p
expr_stmt|;
break|break;
block|}
name|before
operator|=
name|p
expr_stmt|;
block|}
comment|/* now interpolate if necessary */
if|if
condition|(
name|before
operator|<
literal|0
condition|)
name|the_blend
operator|=
name|blends
index|[
literal|0
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|after
operator|<
literal|0
condition|)
name|the_blend
operator|=
name|blends
index|[
name|map
operator|->
name|num_points
operator|-
literal|1
index|]
expr_stmt|;
else|else
name|the_blend
operator|=
name|FT_MulDiv
argument_list|(
name|design
operator|-
name|designs
index|[
name|before
index|]
argument_list|,
name|blends
index|[
name|after
index|]
operator|-
name|blends
index|[
name|before
index|]
argument_list|,
name|designs
index|[
name|after
index|]
operator|-
name|designs
index|[
name|before
index|]
argument_list|)
expr_stmt|;
name|Found
label|:
name|final_blends
index|[
name|n
index|]
operator|=
name|the_blend
expr_stmt|;
block|}
name|error
operator|=
name|T1_Set_MM_Blend
argument_list|(
name|face
argument_list|,
name|num_coords
argument_list|,
name|final_blends
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* Just a wrapper around T1_Set_MM_Design to support the different       */
end_comment
begin_comment
comment|/* arguments needed by the GX var distortable fonts.                     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|T1_Set_Var_Design
argument_list|(
argument|T1_Face    face
argument_list|,
argument|FT_UInt    num_coords
argument_list|,
argument|FT_Fixed*  coords
argument_list|)
end_macro
begin_block
block|{
name|FT_Long
name|lcoords
index|[
literal|4
index|]
decl_stmt|;
comment|/* maximum axis count is 4 */
name|FT_UInt
name|i
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|error
operator|=
name|T1_Err_Invalid_Argument
expr_stmt|;
if|if
condition|(
name|num_coords
operator|<=
literal|4
operator|&&
name|num_coords
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_coords
condition|;
operator|++
name|i
control|)
name|lcoords
index|[
name|i
index|]
operator|=
name|FT_FIXED_TO_INT
argument_list|(
name|coords
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|error
operator|=
name|T1_Set_MM_Design
argument_list|(
name|face
argument_list|,
name|num_coords
argument_list|,
name|lcoords
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_block
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|T1_Done_Blend
name|T1_Done_Blend
argument_list|(
argument|T1_Face  face
argument_list|)
end_macro
begin_block
block|{
name|FT_Memory
name|memory
init|=
name|face
operator|->
name|root
operator|.
name|memory
decl_stmt|;
name|PS_Blend
name|blend
init|=
name|face
operator|->
name|blend
decl_stmt|;
if|if
condition|(
name|blend
condition|)
block|{
name|FT_UInt
name|num_designs
init|=
name|blend
operator|->
name|num_designs
decl_stmt|;
name|FT_UInt
name|num_axis
init|=
name|blend
operator|->
name|num_axis
decl_stmt|;
name|FT_UInt
name|n
decl_stmt|;
comment|/* release design pos table */
name|FT_FREE
argument_list|(
name|blend
operator|->
name|design_pos
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|1
init|;
name|n
operator|<
name|num_designs
condition|;
name|n
operator|++
control|)
name|blend
operator|->
name|design_pos
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
comment|/* release blend `private' and `font info' dictionaries */
name|FT_FREE
argument_list|(
name|blend
operator|->
name|privates
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|blend
operator|->
name|font_infos
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|blend
operator|->
name|bboxes
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|num_designs
condition|;
name|n
operator|++
control|)
block|{
name|blend
operator|->
name|privates
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
name|blend
operator|->
name|font_infos
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
name|blend
operator|->
name|bboxes
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* release weight vectors */
name|FT_FREE
argument_list|(
name|blend
operator|->
name|weight_vector
argument_list|)
expr_stmt|;
name|blend
operator|->
name|default_weight_vector
operator|=
literal|0
expr_stmt|;
comment|/* release axis names */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|num_axis
condition|;
name|n
operator|++
control|)
name|FT_FREE
argument_list|(
name|blend
operator|->
name|axis_names
index|[
name|n
index|]
argument_list|)
expr_stmt|;
comment|/* release design map */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|num_axis
condition|;
name|n
operator|++
control|)
block|{
name|PS_DesignMap
name|dmap
init|=
name|blend
operator|->
name|design_map
operator|+
name|n
decl_stmt|;
name|FT_FREE
argument_list|(
name|dmap
operator|->
name|design_points
argument_list|)
expr_stmt|;
name|dmap
operator|->
name|num_points
operator|=
literal|0
expr_stmt|;
block|}
name|FT_FREE
argument_list|(
name|face
operator|->
name|blend
argument_list|)
expr_stmt|;
block|}
block|}
end_block
begin_function
specifier|static
name|void
DECL|function|parse_blend_axis_types
name|parse_blend_axis_types
parameter_list|(
name|T1_Face
name|face
parameter_list|,
name|T1_Loader
name|loader
parameter_list|)
block|{
name|T1_TokenRec
name|axis_tokens
index|[
name|T1_MAX_MM_AXIS
index|]
decl_stmt|;
name|FT_Int
name|n
decl_stmt|,
name|num_axis
decl_stmt|;
name|FT_Error
name|error
init|=
name|T1_Err_Ok
decl_stmt|;
name|PS_Blend
name|blend
decl_stmt|;
name|FT_Memory
name|memory
decl_stmt|;
comment|/* take an array of objects */
name|T1_ToTokenArray
argument_list|(
operator|&
name|loader
operator|->
name|parser
argument_list|,
name|axis_tokens
argument_list|,
name|T1_MAX_MM_AXIS
argument_list|,
operator|&
name|num_axis
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_axis
operator|<
literal|0
condition|)
block|{
name|error
operator|=
name|T1_Err_Ignore
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|num_axis
operator|==
literal|0
operator|||
name|num_axis
operator|>
name|T1_MAX_MM_AXIS
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"parse_blend_axis_types: incorrect number of axes: %d\n"
operator|,
name|num_axis
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|T1_Err_Invalid_File_Format
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* allocate blend if necessary */
name|error
operator|=
name|t1_allocate_blend
argument_list|(
name|face
argument_list|,
literal|0
argument_list|,
operator|(
name|FT_UInt
operator|)
name|num_axis
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|blend
operator|=
name|face
operator|->
name|blend
expr_stmt|;
name|memory
operator|=
name|face
operator|->
name|root
operator|.
name|memory
expr_stmt|;
comment|/* each token is an immediate containing the name of the axis */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|num_axis
condition|;
name|n
operator|++
control|)
block|{
name|T1_Token
name|token
init|=
name|axis_tokens
operator|+
name|n
decl_stmt|;
name|FT_Byte
modifier|*
name|name
decl_stmt|;
name|FT_PtrDist
name|len
decl_stmt|;
comment|/* skip first slash, if any */
if|if
condition|(
name|token
operator|->
name|start
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
name|token
operator|->
name|start
operator|++
expr_stmt|;
name|len
operator|=
name|token
operator|->
name|limit
operator|-
name|token
operator|->
name|start
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|T1_Err_Invalid_File_Format
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|FT_ALLOC
argument_list|(
name|blend
operator|->
name|axis_names
index|[
name|n
index|]
argument_list|,
name|len
operator|+
literal|1
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|name
operator|=
operator|(
name|FT_Byte
operator|*
operator|)
name|blend
operator|->
name|axis_names
index|[
name|n
index|]
expr_stmt|;
name|FT_MEM_COPY
argument_list|(
name|name
argument_list|,
name|token
operator|->
name|start
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|name
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|Exit
label|:
name|loader
operator|->
name|parser
operator|.
name|root
operator|.
name|error
operator|=
name|error
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|parse_blend_design_positions
name|parse_blend_design_positions
parameter_list|(
name|T1_Face
name|face
parameter_list|,
name|T1_Loader
name|loader
parameter_list|)
block|{
name|T1_TokenRec
name|design_tokens
index|[
name|T1_MAX_MM_DESIGNS
index|]
decl_stmt|;
name|FT_Int
name|num_designs
decl_stmt|;
name|FT_Int
name|num_axis
decl_stmt|;
name|T1_Parser
name|parser
init|=
operator|&
name|loader
operator|->
name|parser
decl_stmt|;
name|FT_Error
name|error
init|=
name|T1_Err_Ok
decl_stmt|;
name|PS_Blend
name|blend
decl_stmt|;
comment|/* get the array of design tokens -- compute number of designs */
name|T1_ToTokenArray
argument_list|(
name|parser
argument_list|,
name|design_tokens
argument_list|,
name|T1_MAX_MM_DESIGNS
argument_list|,
operator|&
name|num_designs
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_designs
operator|<
literal|0
condition|)
block|{
name|error
operator|=
name|T1_Err_Ignore
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|num_designs
operator|==
literal|0
operator|||
name|num_designs
operator|>
name|T1_MAX_MM_DESIGNS
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"parse_blend_design_positions:"
operator|)
argument_list|)
expr_stmt|;
name|FT_ERROR
argument_list|(
operator|(
literal|" incorrect number of designs: %d\n"
operator|,
name|num_designs
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|T1_Err_Invalid_File_Format
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|{
name|FT_Byte
modifier|*
name|old_cursor
init|=
name|parser
operator|->
name|root
operator|.
name|cursor
decl_stmt|;
name|FT_Byte
modifier|*
name|old_limit
init|=
name|parser
operator|->
name|root
operator|.
name|limit
decl_stmt|;
name|FT_Int
name|n
decl_stmt|;
name|blend
operator|=
name|face
operator|->
name|blend
expr_stmt|;
name|num_axis
operator|=
literal|0
expr_stmt|;
comment|/* make compiler happy */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|num_designs
condition|;
name|n
operator|++
control|)
block|{
name|T1_TokenRec
name|axis_tokens
index|[
name|T1_MAX_MM_AXIS
index|]
decl_stmt|;
name|T1_Token
name|token
decl_stmt|;
name|FT_Int
name|axis
decl_stmt|,
name|n_axis
decl_stmt|;
comment|/* read axis/coordinates tokens */
name|token
operator|=
name|design_tokens
operator|+
name|n
expr_stmt|;
name|parser
operator|->
name|root
operator|.
name|cursor
operator|=
name|token
operator|->
name|start
expr_stmt|;
name|parser
operator|->
name|root
operator|.
name|limit
operator|=
name|token
operator|->
name|limit
expr_stmt|;
name|T1_ToTokenArray
argument_list|(
name|parser
argument_list|,
name|axis_tokens
argument_list|,
name|T1_MAX_MM_AXIS
argument_list|,
operator|&
name|n_axis
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|n_axis
operator|<=
literal|0
operator|||
name|n_axis
operator|>
name|T1_MAX_MM_AXIS
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"parse_blend_design_positions:"
operator|)
argument_list|)
expr_stmt|;
name|FT_ERROR
argument_list|(
operator|(
literal|"  invalid number of axes: %d\n"
operator|,
name|n_axis
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|T1_Err_Invalid_File_Format
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|num_axis
operator|=
name|n_axis
expr_stmt|;
name|error
operator|=
name|t1_allocate_blend
argument_list|(
name|face
argument_list|,
name|num_designs
argument_list|,
name|num_axis
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|blend
operator|=
name|face
operator|->
name|blend
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n_axis
operator|!=
name|num_axis
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"parse_blend_design_positions: incorrect table\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|T1_Err_Invalid_File_Format
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* now read each axis token into the design position */
for|for
control|(
name|axis
operator|=
literal|0
init|;
name|axis
operator|<
name|n_axis
condition|;
name|axis
operator|++
control|)
block|{
name|T1_Token
name|token2
init|=
name|axis_tokens
operator|+
name|axis
decl_stmt|;
name|parser
operator|->
name|root
operator|.
name|cursor
operator|=
name|token2
operator|->
name|start
expr_stmt|;
name|parser
operator|->
name|root
operator|.
name|limit
operator|=
name|token2
operator|->
name|limit
expr_stmt|;
name|blend
operator|->
name|design_pos
index|[
name|n
index|]
index|[
name|axis
index|]
operator|=
name|T1_ToFixed
argument_list|(
name|parser
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|loader
operator|->
name|parser
operator|.
name|root
operator|.
name|cursor
operator|=
name|old_cursor
expr_stmt|;
name|loader
operator|->
name|parser
operator|.
name|root
operator|.
name|limit
operator|=
name|old_limit
expr_stmt|;
block|}
name|Exit
label|:
name|loader
operator|->
name|parser
operator|.
name|root
operator|.
name|error
operator|=
name|error
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|parse_blend_design_map
name|parse_blend_design_map
parameter_list|(
name|T1_Face
name|face
parameter_list|,
name|T1_Loader
name|loader
parameter_list|)
block|{
name|FT_Error
name|error
init|=
name|T1_Err_Ok
decl_stmt|;
name|T1_Parser
name|parser
init|=
operator|&
name|loader
operator|->
name|parser
decl_stmt|;
name|PS_Blend
name|blend
decl_stmt|;
name|T1_TokenRec
name|axis_tokens
index|[
name|T1_MAX_MM_AXIS
index|]
decl_stmt|;
name|FT_Int
name|n
decl_stmt|,
name|num_axis
decl_stmt|;
name|FT_Byte
modifier|*
name|old_cursor
decl_stmt|;
name|FT_Byte
modifier|*
name|old_limit
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|face
operator|->
name|root
operator|.
name|memory
decl_stmt|;
name|T1_ToTokenArray
argument_list|(
name|parser
argument_list|,
name|axis_tokens
argument_list|,
name|T1_MAX_MM_AXIS
argument_list|,
operator|&
name|num_axis
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_axis
operator|<
literal|0
condition|)
block|{
name|error
operator|=
name|T1_Err_Ignore
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|num_axis
operator|==
literal|0
operator|||
name|num_axis
operator|>
name|T1_MAX_MM_AXIS
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"parse_blend_design_map: incorrect number of axes: %d\n"
operator|,
name|num_axis
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|T1_Err_Invalid_File_Format
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|old_cursor
operator|=
name|parser
operator|->
name|root
operator|.
name|cursor
expr_stmt|;
name|old_limit
operator|=
name|parser
operator|->
name|root
operator|.
name|limit
expr_stmt|;
name|error
operator|=
name|t1_allocate_blend
argument_list|(
name|face
argument_list|,
literal|0
argument_list|,
name|num_axis
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|blend
operator|=
name|face
operator|->
name|blend
expr_stmt|;
comment|/* now read each axis design map */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|num_axis
condition|;
name|n
operator|++
control|)
block|{
name|PS_DesignMap
name|map
init|=
name|blend
operator|->
name|design_map
operator|+
name|n
decl_stmt|;
name|T1_Token
name|axis_token
decl_stmt|;
name|T1_TokenRec
name|point_tokens
index|[
name|T1_MAX_MM_MAP_POINTS
index|]
decl_stmt|;
name|FT_Int
name|p
decl_stmt|,
name|num_points
decl_stmt|;
name|axis_token
operator|=
name|axis_tokens
operator|+
name|n
expr_stmt|;
name|parser
operator|->
name|root
operator|.
name|cursor
operator|=
name|axis_token
operator|->
name|start
expr_stmt|;
name|parser
operator|->
name|root
operator|.
name|limit
operator|=
name|axis_token
operator|->
name|limit
expr_stmt|;
name|T1_ToTokenArray
argument_list|(
name|parser
argument_list|,
name|point_tokens
argument_list|,
name|T1_MAX_MM_MAP_POINTS
argument_list|,
operator|&
name|num_points
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_points
operator|<=
literal|0
operator|||
name|num_points
operator|>
name|T1_MAX_MM_MAP_POINTS
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"parse_blend_design_map: incorrect table\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|T1_Err_Invalid_File_Format
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* allocate design map data */
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|map
operator|->
name|design_points
argument_list|,
name|num_points
operator|*
literal|2
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|map
operator|->
name|blend_points
operator|=
name|map
operator|->
name|design_points
operator|+
name|num_points
expr_stmt|;
name|map
operator|->
name|num_points
operator|=
operator|(
name|FT_Byte
operator|)
name|num_points
expr_stmt|;
for|for
control|(
name|p
operator|=
literal|0
init|;
name|p
operator|<
name|num_points
condition|;
name|p
operator|++
control|)
block|{
name|T1_Token
name|point_token
decl_stmt|;
name|point_token
operator|=
name|point_tokens
operator|+
name|p
expr_stmt|;
comment|/* don't include delimiting brackets */
name|parser
operator|->
name|root
operator|.
name|cursor
operator|=
name|point_token
operator|->
name|start
operator|+
literal|1
expr_stmt|;
name|parser
operator|->
name|root
operator|.
name|limit
operator|=
name|point_token
operator|->
name|limit
operator|-
literal|1
expr_stmt|;
name|map
operator|->
name|design_points
index|[
name|p
index|]
operator|=
name|T1_ToInt
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|map
operator|->
name|blend_points
index|[
name|p
index|]
operator|=
name|T1_ToFixed
argument_list|(
name|parser
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|parser
operator|->
name|root
operator|.
name|cursor
operator|=
name|old_cursor
expr_stmt|;
name|parser
operator|->
name|root
operator|.
name|limit
operator|=
name|old_limit
expr_stmt|;
name|Exit
label|:
name|parser
operator|->
name|root
operator|.
name|error
operator|=
name|error
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|parse_weight_vector
name|parse_weight_vector
parameter_list|(
name|T1_Face
name|face
parameter_list|,
name|T1_Loader
name|loader
parameter_list|)
block|{
name|T1_TokenRec
name|design_tokens
index|[
name|T1_MAX_MM_DESIGNS
index|]
decl_stmt|;
name|FT_Int
name|num_designs
decl_stmt|;
name|FT_Error
name|error
init|=
name|T1_Err_Ok
decl_stmt|;
name|T1_Parser
name|parser
init|=
operator|&
name|loader
operator|->
name|parser
decl_stmt|;
name|PS_Blend
name|blend
init|=
name|face
operator|->
name|blend
decl_stmt|;
name|T1_Token
name|token
decl_stmt|;
name|FT_Int
name|n
decl_stmt|;
name|FT_Byte
modifier|*
name|old_cursor
decl_stmt|;
name|FT_Byte
modifier|*
name|old_limit
decl_stmt|;
name|T1_ToTokenArray
argument_list|(
name|parser
argument_list|,
name|design_tokens
argument_list|,
name|T1_MAX_MM_DESIGNS
argument_list|,
operator|&
name|num_designs
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_designs
operator|<
literal|0
condition|)
block|{
name|error
operator|=
name|T1_Err_Ignore
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|num_designs
operator|==
literal|0
operator|||
name|num_designs
operator|>
name|T1_MAX_MM_DESIGNS
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"parse_weight_vector:"
operator|)
argument_list|)
expr_stmt|;
name|FT_ERROR
argument_list|(
operator|(
literal|" incorrect number of designs: %d\n"
operator|,
name|num_designs
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|T1_Err_Invalid_File_Format
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
operator|!
name|blend
operator|||
operator|!
name|blend
operator|->
name|num_designs
condition|)
block|{
name|error
operator|=
name|t1_allocate_blend
argument_list|(
name|face
argument_list|,
name|num_designs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|blend
operator|=
name|face
operator|->
name|blend
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|blend
operator|->
name|num_designs
operator|!=
operator|(
name|FT_UInt
operator|)
name|num_designs
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"parse_weight_vector:"
literal|" /BlendDesignPosition and /WeightVector have\n"
operator|)
argument_list|)
expr_stmt|;
name|FT_ERROR
argument_list|(
operator|(
literal|"                    "
literal|" different number of elements!\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|T1_Err_Invalid_File_Format
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|old_cursor
operator|=
name|parser
operator|->
name|root
operator|.
name|cursor
expr_stmt|;
name|old_limit
operator|=
name|parser
operator|->
name|root
operator|.
name|limit
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|num_designs
condition|;
name|n
operator|++
control|)
block|{
name|token
operator|=
name|design_tokens
operator|+
name|n
expr_stmt|;
name|parser
operator|->
name|root
operator|.
name|cursor
operator|=
name|token
operator|->
name|start
expr_stmt|;
name|parser
operator|->
name|root
operator|.
name|limit
operator|=
name|token
operator|->
name|limit
expr_stmt|;
name|blend
operator|->
name|default_weight_vector
index|[
name|n
index|]
operator|=
name|blend
operator|->
name|weight_vector
index|[
name|n
index|]
operator|=
name|T1_ToFixed
argument_list|(
name|parser
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|parser
operator|->
name|root
operator|.
name|cursor
operator|=
name|old_cursor
expr_stmt|;
name|parser
operator|->
name|root
operator|.
name|limit
operator|=
name|old_limit
expr_stmt|;
name|Exit
label|:
name|parser
operator|->
name|root
operator|.
name|error
operator|=
name|error
expr_stmt|;
block|}
end_function
begin_comment
comment|/* e.g., /BuildCharArray [0 0 0 0 0 0 0 0] def           */
end_comment
begin_comment
comment|/* we're only interested in the number of array elements */
end_comment
begin_function
specifier|static
name|void
DECL|function|parse_buildchar
name|parse_buildchar
parameter_list|(
name|T1_Face
name|face
parameter_list|,
name|T1_Loader
name|loader
parameter_list|)
block|{
name|face
operator|->
name|len_buildchar
operator|=
name|T1_ToFixedArray
argument_list|(
operator|&
name|loader
operator|->
name|parser
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* T1_CONFIG_OPTION_NO_MM_SUPPORT */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****                      TYPE 1 SYMBOL PARSING                    *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|t1_load_keyword
name|t1_load_keyword
parameter_list|(
name|T1_Face
name|face
parameter_list|,
name|T1_Loader
name|loader
parameter_list|,
specifier|const
name|T1_Field
name|field
parameter_list|)
block|{
name|FT_Error
name|error
decl_stmt|;
name|void
modifier|*
name|dummy_object
decl_stmt|;
name|void
modifier|*
modifier|*
name|objects
decl_stmt|;
name|FT_UInt
name|max_objects
decl_stmt|;
name|PS_Blend
name|blend
init|=
name|face
operator|->
name|blend
decl_stmt|;
comment|/* if the keyword has a dedicated callback, call it */
if|if
condition|(
name|field
operator|->
name|type
operator|==
name|T1_FIELD_TYPE_CALLBACK
condition|)
block|{
name|field
operator|->
name|reader
argument_list|(
operator|(
name|FT_Face
operator|)
name|face
argument_list|,
name|loader
argument_list|)
expr_stmt|;
name|error
operator|=
name|loader
operator|->
name|parser
operator|.
name|root
operator|.
name|error
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* now, the keyword is either a simple field, or a table of fields; */
comment|/* we are now going to take care of it                              */
switch|switch
condition|(
name|field
operator|->
name|location
condition|)
block|{
case|case
name|T1_FIELD_LOCATION_FONT_INFO
case|:
name|dummy_object
operator|=
operator|&
name|face
operator|->
name|type1
operator|.
name|font_info
expr_stmt|;
name|objects
operator|=
operator|&
name|dummy_object
expr_stmt|;
name|max_objects
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|blend
condition|)
block|{
name|objects
operator|=
operator|(
name|void
operator|*
operator|*
operator|)
name|blend
operator|->
name|font_infos
expr_stmt|;
name|max_objects
operator|=
name|blend
operator|->
name|num_designs
expr_stmt|;
block|}
break|break;
case|case
name|T1_FIELD_LOCATION_FONT_EXTRA
case|:
name|dummy_object
operator|=
operator|&
name|face
operator|->
name|type1
operator|.
name|font_extra
expr_stmt|;
name|objects
operator|=
operator|&
name|dummy_object
expr_stmt|;
name|max_objects
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|T1_FIELD_LOCATION_PRIVATE
case|:
name|dummy_object
operator|=
operator|&
name|face
operator|->
name|type1
operator|.
name|private_dict
expr_stmt|;
name|objects
operator|=
operator|&
name|dummy_object
expr_stmt|;
name|max_objects
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|blend
condition|)
block|{
name|objects
operator|=
operator|(
name|void
operator|*
operator|*
operator|)
name|blend
operator|->
name|privates
expr_stmt|;
name|max_objects
operator|=
name|blend
operator|->
name|num_designs
expr_stmt|;
block|}
break|break;
case|case
name|T1_FIELD_LOCATION_BBOX
case|:
name|dummy_object
operator|=
operator|&
name|face
operator|->
name|type1
operator|.
name|font_bbox
expr_stmt|;
name|objects
operator|=
operator|&
name|dummy_object
expr_stmt|;
name|max_objects
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|blend
condition|)
block|{
name|objects
operator|=
operator|(
name|void
operator|*
operator|*
operator|)
name|blend
operator|->
name|bboxes
expr_stmt|;
name|max_objects
operator|=
name|blend
operator|->
name|num_designs
expr_stmt|;
block|}
break|break;
case|case
name|T1_FIELD_LOCATION_LOADER
case|:
name|dummy_object
operator|=
name|loader
expr_stmt|;
name|objects
operator|=
operator|&
name|dummy_object
expr_stmt|;
name|max_objects
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|T1_FIELD_LOCATION_FACE
case|:
name|dummy_object
operator|=
name|face
expr_stmt|;
name|objects
operator|=
operator|&
name|dummy_object
expr_stmt|;
name|max_objects
operator|=
literal|0
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|T1_CONFIG_OPTION_NO_MM_SUPPORT
case|case
name|T1_FIELD_LOCATION_BLEND
case|:
name|dummy_object
operator|=
name|face
operator|->
name|blend
expr_stmt|;
name|objects
operator|=
operator|&
name|dummy_object
expr_stmt|;
name|max_objects
operator|=
literal|0
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|dummy_object
operator|=
operator|&
name|face
operator|->
name|type1
expr_stmt|;
name|objects
operator|=
operator|&
name|dummy_object
expr_stmt|;
name|max_objects
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|field
operator|->
name|type
operator|==
name|T1_FIELD_TYPE_INTEGER_ARRAY
operator|||
name|field
operator|->
name|type
operator|==
name|T1_FIELD_TYPE_FIXED_ARRAY
condition|)
name|error
operator|=
name|T1_Load_Field_Table
argument_list|(
operator|&
name|loader
operator|->
name|parser
argument_list|,
name|field
argument_list|,
name|objects
argument_list|,
name|max_objects
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|T1_Load_Field
argument_list|(
operator|&
name|loader
operator|->
name|parser
argument_list|,
name|field
argument_list|,
name|objects
argument_list|,
name|max_objects
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Exit
label|:
return|return
name|error
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|parse_private
name|parse_private
parameter_list|(
name|T1_Face
name|face
parameter_list|,
name|T1_Loader
name|loader
parameter_list|)
block|{
name|FT_UNUSED
argument_list|(
name|face
argument_list|)
expr_stmt|;
name|loader
operator|->
name|keywords_encountered
operator||=
name|T1_PRIVATE
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|read_binary_data
name|read_binary_data
parameter_list|(
name|T1_Parser
name|parser
parameter_list|,
name|FT_Long
modifier|*
name|size
parameter_list|,
name|FT_Byte
modifier|*
modifier|*
name|base
parameter_list|)
block|{
name|FT_Byte
modifier|*
name|cur
decl_stmt|;
name|FT_Byte
modifier|*
name|limit
init|=
name|parser
operator|->
name|root
operator|.
name|limit
decl_stmt|;
comment|/* the binary data has one of the following formats */
comment|/*                                                  */
comment|/*   `size' [white*] RD white ....... ND            */
comment|/*   `size' [white*] -| white ....... |-            */
comment|/*                                                  */
name|T1_Skip_Spaces
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|cur
operator|=
name|parser
operator|->
name|root
operator|.
name|cursor
expr_stmt|;
if|if
condition|(
name|cur
operator|<
name|limit
operator|&&
name|ft_isdigit
argument_list|(
operator|*
name|cur
argument_list|)
condition|)
block|{
operator|*
name|size
operator|=
name|T1_ToInt
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|T1_Skip_PS_Token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* `RD' or `-|' or something else */
comment|/* there is only one whitespace char after the */
comment|/* `RD' or `-|' token                          */
operator|*
name|base
operator|=
name|parser
operator|->
name|root
operator|.
name|cursor
operator|+
literal|1
expr_stmt|;
name|parser
operator|->
name|root
operator|.
name|cursor
operator|+=
operator|*
name|size
operator|+
literal|1
expr_stmt|;
return|return
operator|!
name|parser
operator|->
name|root
operator|.
name|error
return|;
block|}
name|FT_ERROR
argument_list|(
operator|(
literal|"read_binary_data: invalid size field\n"
operator|)
argument_list|)
expr_stmt|;
name|parser
operator|->
name|root
operator|.
name|error
operator|=
name|T1_Err_Invalid_File_Format
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/* We now define the routines to handle the `/Encoding', `/Subrs', */
end_comment
begin_comment
comment|/* and `/CharStrings' dictionaries.                                */
end_comment
begin_function
specifier|static
name|void
DECL|function|parse_font_matrix
name|parse_font_matrix
parameter_list|(
name|T1_Face
name|face
parameter_list|,
name|T1_Loader
name|loader
parameter_list|)
block|{
name|T1_Parser
name|parser
init|=
operator|&
name|loader
operator|->
name|parser
decl_stmt|;
name|FT_Matrix
modifier|*
name|matrix
init|=
operator|&
name|face
operator|->
name|type1
operator|.
name|font_matrix
decl_stmt|;
name|FT_Vector
modifier|*
name|offset
init|=
operator|&
name|face
operator|->
name|type1
operator|.
name|font_offset
decl_stmt|;
name|FT_Face
name|root
init|=
operator|(
name|FT_Face
operator|)
operator|&
name|face
operator|->
name|root
decl_stmt|;
name|FT_Fixed
name|temp
index|[
literal|6
index|]
decl_stmt|;
name|FT_Fixed
name|temp_scale
decl_stmt|;
name|FT_Int
name|result
decl_stmt|;
name|result
operator|=
name|T1_ToFixedArray
argument_list|(
name|parser
argument_list|,
literal|6
argument_list|,
name|temp
argument_list|,
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
block|{
name|parser
operator|->
name|root
operator|.
name|error
operator|=
name|T1_Err_Invalid_File_Format
expr_stmt|;
return|return;
block|}
name|temp_scale
operator|=
name|FT_ABS
argument_list|(
name|temp
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp_scale
operator|==
literal|0
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"parse_font_matrix: invalid font matrix\n"
operator|)
argument_list|)
expr_stmt|;
name|parser
operator|->
name|root
operator|.
name|error
operator|=
name|T1_Err_Invalid_File_Format
expr_stmt|;
return|return;
block|}
comment|/* Set Units per EM based on FontMatrix values.  We set the value to */
comment|/* 1000 / temp_scale, because temp_scale was already multiplied by   */
comment|/* 1000 (in t1_tofixed, from psobjs.c).                              */
name|root
operator|->
name|units_per_EM
operator|=
call|(
name|FT_UShort
call|)
argument_list|(
name|FT_DivFix
argument_list|(
literal|1000
operator|*
literal|0x10000L
argument_list|,
name|temp_scale
argument_list|)
operator|>>
literal|16
argument_list|)
expr_stmt|;
comment|/* we need to scale the values by 1.0/temp_scale */
if|if
condition|(
name|temp_scale
operator|!=
literal|0x10000L
condition|)
block|{
name|temp
index|[
literal|0
index|]
operator|=
name|FT_DivFix
argument_list|(
name|temp
index|[
literal|0
index|]
argument_list|,
name|temp_scale
argument_list|)
expr_stmt|;
name|temp
index|[
literal|1
index|]
operator|=
name|FT_DivFix
argument_list|(
name|temp
index|[
literal|1
index|]
argument_list|,
name|temp_scale
argument_list|)
expr_stmt|;
name|temp
index|[
literal|2
index|]
operator|=
name|FT_DivFix
argument_list|(
name|temp
index|[
literal|2
index|]
argument_list|,
name|temp_scale
argument_list|)
expr_stmt|;
name|temp
index|[
literal|4
index|]
operator|=
name|FT_DivFix
argument_list|(
name|temp
index|[
literal|4
index|]
argument_list|,
name|temp_scale
argument_list|)
expr_stmt|;
name|temp
index|[
literal|5
index|]
operator|=
name|FT_DivFix
argument_list|(
name|temp
index|[
literal|5
index|]
argument_list|,
name|temp_scale
argument_list|)
expr_stmt|;
name|temp
index|[
literal|3
index|]
operator|=
literal|0x10000L
expr_stmt|;
block|}
name|matrix
operator|->
name|xx
operator|=
name|temp
index|[
literal|0
index|]
expr_stmt|;
name|matrix
operator|->
name|yx
operator|=
name|temp
index|[
literal|1
index|]
expr_stmt|;
name|matrix
operator|->
name|xy
operator|=
name|temp
index|[
literal|2
index|]
expr_stmt|;
name|matrix
operator|->
name|yy
operator|=
name|temp
index|[
literal|3
index|]
expr_stmt|;
comment|/* note that the offsets must be expressed in integer font units */
name|offset
operator|->
name|x
operator|=
name|temp
index|[
literal|4
index|]
operator|>>
literal|16
expr_stmt|;
name|offset
operator|->
name|y
operator|=
name|temp
index|[
literal|5
index|]
operator|>>
literal|16
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|parse_encoding
name|parse_encoding
parameter_list|(
name|T1_Face
name|face
parameter_list|,
name|T1_Loader
name|loader
parameter_list|)
block|{
name|T1_Parser
name|parser
init|=
operator|&
name|loader
operator|->
name|parser
decl_stmt|;
name|FT_Byte
modifier|*
name|cur
decl_stmt|;
name|FT_Byte
modifier|*
name|limit
init|=
name|parser
operator|->
name|root
operator|.
name|limit
decl_stmt|;
name|PSAux_Service
name|psaux
init|=
operator|(
name|PSAux_Service
operator|)
name|face
operator|->
name|psaux
decl_stmt|;
name|T1_Skip_Spaces
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|cur
operator|=
name|parser
operator|->
name|root
operator|.
name|cursor
expr_stmt|;
if|if
condition|(
name|cur
operator|>=
name|limit
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"parse_encoding: out of bounds!\n"
operator|)
argument_list|)
expr_stmt|;
name|parser
operator|->
name|root
operator|.
name|error
operator|=
name|T1_Err_Invalid_File_Format
expr_stmt|;
return|return;
block|}
comment|/* if we have a number or `[', the encoding is an array, */
comment|/* and we must load it now                               */
if|if
condition|(
name|ft_isdigit
argument_list|(
operator|*
name|cur
argument_list|)
operator|||
operator|*
name|cur
operator|==
literal|'['
condition|)
block|{
name|T1_Encoding
name|encode
init|=
operator|&
name|face
operator|->
name|type1
operator|.
name|encoding
decl_stmt|;
name|FT_Int
name|count
decl_stmt|,
name|n
decl_stmt|;
name|PS_Table
name|char_table
init|=
operator|&
name|loader
operator|->
name|encoding_table
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|parser
operator|->
name|root
operator|.
name|memory
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|FT_Bool
name|only_immediates
init|=
literal|0
decl_stmt|;
comment|/* read the number of entries in the encoding; should be 256 */
if|if
condition|(
operator|*
name|cur
operator|==
literal|'['
condition|)
block|{
name|count
operator|=
literal|256
expr_stmt|;
name|only_immediates
operator|=
literal|1
expr_stmt|;
name|parser
operator|->
name|root
operator|.
name|cursor
operator|++
expr_stmt|;
block|}
else|else
name|count
operator|=
operator|(
name|FT_Int
operator|)
name|T1_ToInt
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|T1_Skip_Spaces
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|parser
operator|->
name|root
operator|.
name|cursor
operator|>=
name|limit
condition|)
return|return;
comment|/* we use a T1_Table to store our charnames */
name|loader
operator|->
name|num_chars
operator|=
name|encode
operator|->
name|num_chars
operator|=
name|count
expr_stmt|;
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|encode
operator|->
name|char_index
argument_list|,
name|count
argument_list|)
operator|||
name|FT_NEW_ARRAY
argument_list|(
name|encode
operator|->
name|char_name
argument_list|,
name|count
argument_list|)
operator|||
name|FT_SET_ERROR
argument_list|(
name|psaux
operator|->
name|ps_table_funcs
operator|->
name|init
argument_list|(
name|char_table
argument_list|,
name|count
argument_list|,
name|memory
argument_list|)
argument_list|)
condition|)
block|{
name|parser
operator|->
name|root
operator|.
name|error
operator|=
name|error
expr_stmt|;
return|return;
block|}
comment|/* We need to `zero' out encoding_table.elements */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
block|{
name|char
modifier|*
name|notdef
init|=
operator|(
name|char
operator|*
operator|)
literal|".notdef"
decl_stmt|;
name|T1_Add_Table
argument_list|(
name|char_table
argument_list|,
name|n
argument_list|,
name|notdef
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
comment|/* Now we need to read records of the form                */
comment|/*                                                        */
comment|/*   ... charcode /charname ...                           */
comment|/*                                                        */
comment|/* for each entry in our table.                           */
comment|/*                                                        */
comment|/* We simply look for a number followed by an immediate   */
comment|/* name.  Note that this ignores correctly the sequence   */
comment|/* that is often seen in type1 fonts:                     */
comment|/*                                                        */
comment|/*   0 1 255 { 1 index exch /.notdef put } for dup        */
comment|/*                                                        */
comment|/* used to clean the encoding array before anything else. */
comment|/*                                                        */
comment|/* Alternatively, if the array is directly given as       */
comment|/*                                                        */
comment|/*   /Encoding [ ... ]                                    */
comment|/*                                                        */
comment|/* we only read immediates.                               */
name|n
operator|=
literal|0
expr_stmt|;
name|T1_Skip_Spaces
argument_list|(
name|parser
argument_list|)
expr_stmt|;
while|while
condition|(
name|parser
operator|->
name|root
operator|.
name|cursor
operator|<
name|limit
condition|)
block|{
name|cur
operator|=
name|parser
operator|->
name|root
operator|.
name|cursor
expr_stmt|;
comment|/* we stop when we encounter a `def' or `]' */
if|if
condition|(
operator|*
name|cur
operator|==
literal|'d'
operator|&&
name|cur
operator|+
literal|3
operator|<
name|limit
condition|)
block|{
if|if
condition|(
name|cur
index|[
literal|1
index|]
operator|==
literal|'e'
operator|&&
name|cur
index|[
literal|2
index|]
operator|==
literal|'f'
operator|&&
name|IS_PS_DELIM
argument_list|(
name|cur
index|[
literal|3
index|]
argument_list|)
condition|)
block|{
name|FT_TRACE6
argument_list|(
operator|(
literal|"encoding end\n"
operator|)
argument_list|)
expr_stmt|;
name|cur
operator|+=
literal|3
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|*
name|cur
operator|==
literal|']'
condition|)
block|{
name|FT_TRACE6
argument_list|(
operator|(
literal|"encoding end\n"
operator|)
argument_list|)
expr_stmt|;
name|cur
operator|++
expr_stmt|;
break|break;
block|}
comment|/* check whether we've found an entry */
if|if
condition|(
name|ft_isdigit
argument_list|(
operator|*
name|cur
argument_list|)
operator|||
name|only_immediates
condition|)
block|{
name|FT_Int
name|charcode
decl_stmt|;
if|if
condition|(
name|only_immediates
condition|)
name|charcode
operator|=
name|n
expr_stmt|;
else|else
block|{
name|charcode
operator|=
operator|(
name|FT_Int
operator|)
name|T1_ToInt
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|T1_Skip_Spaces
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
name|cur
operator|=
name|parser
operator|->
name|root
operator|.
name|cursor
expr_stmt|;
if|if
condition|(
operator|*
name|cur
operator|==
literal|'/'
operator|&&
name|cur
operator|+
literal|2
operator|<
name|limit
operator|&&
name|n
operator|<
name|count
condition|)
block|{
name|FT_PtrDist
name|len
decl_stmt|;
name|cur
operator|++
expr_stmt|;
name|parser
operator|->
name|root
operator|.
name|cursor
operator|=
name|cur
expr_stmt|;
name|T1_Skip_PS_Token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|parser
operator|->
name|root
operator|.
name|error
condition|)
return|return;
name|len
operator|=
name|parser
operator|->
name|root
operator|.
name|cursor
operator|-
name|cur
expr_stmt|;
name|parser
operator|->
name|root
operator|.
name|error
operator|=
name|T1_Add_Table
argument_list|(
name|char_table
argument_list|,
name|charcode
argument_list|,
name|cur
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|parser
operator|->
name|root
operator|.
name|error
condition|)
return|return;
name|char_table
operator|->
name|elements
index|[
name|charcode
index|]
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|only_immediates
condition|)
block|{
comment|/* Since the current position is not updated for           */
comment|/* immediates-only mode we would get an infinite loop if   */
comment|/* we don't do anything here.                              */
comment|/*                                                         */
comment|/* This encoding array is not valid according to the type1 */
comment|/* specification (it might be an encoding for a CID type1  */
comment|/* font, however), so we conclude that this font is NOT a  */
comment|/* type1 font.                                             */
name|parser
operator|->
name|root
operator|.
name|error
operator|=
name|FT_Err_Unknown_File_Format
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|T1_Skip_PS_Token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|parser
operator|->
name|root
operator|.
name|error
condition|)
return|return;
block|}
name|T1_Skip_Spaces
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
name|face
operator|->
name|type1
operator|.
name|encoding_type
operator|=
name|T1_ENCODING_TYPE_ARRAY
expr_stmt|;
name|parser
operator|->
name|root
operator|.
name|cursor
operator|=
name|cur
expr_stmt|;
block|}
comment|/* Otherwise, we should have either `StandardEncoding', */
comment|/* `ExpertEncoding', or `ISOLatin1Encoding'             */
else|else
block|{
if|if
condition|(
name|cur
operator|+
literal|17
operator|<
name|limit
operator|&&
name|ft_strncmp
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|cur
argument_list|,
literal|"StandardEncoding"
argument_list|,
literal|16
argument_list|)
operator|==
literal|0
condition|)
name|face
operator|->
name|type1
operator|.
name|encoding_type
operator|=
name|T1_ENCODING_TYPE_STANDARD
expr_stmt|;
elseif|else
if|if
condition|(
name|cur
operator|+
literal|15
operator|<
name|limit
operator|&&
name|ft_strncmp
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|cur
argument_list|,
literal|"ExpertEncoding"
argument_list|,
literal|14
argument_list|)
operator|==
literal|0
condition|)
name|face
operator|->
name|type1
operator|.
name|encoding_type
operator|=
name|T1_ENCODING_TYPE_EXPERT
expr_stmt|;
elseif|else
if|if
condition|(
name|cur
operator|+
literal|18
operator|<
name|limit
operator|&&
name|ft_strncmp
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|cur
argument_list|,
literal|"ISOLatin1Encoding"
argument_list|,
literal|17
argument_list|)
operator|==
literal|0
condition|)
name|face
operator|->
name|type1
operator|.
name|encoding_type
operator|=
name|T1_ENCODING_TYPE_ISOLATIN1
expr_stmt|;
else|else
name|parser
operator|->
name|root
operator|.
name|error
operator|=
name|T1_Err_Ignore
expr_stmt|;
block|}
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|parse_subrs
name|parse_subrs
parameter_list|(
name|T1_Face
name|face
parameter_list|,
name|T1_Loader
name|loader
parameter_list|)
block|{
name|T1_Parser
name|parser
init|=
operator|&
name|loader
operator|->
name|parser
decl_stmt|;
name|PS_Table
name|table
init|=
operator|&
name|loader
operator|->
name|subrs
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|parser
operator|->
name|root
operator|.
name|memory
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|FT_Int
name|num_subrs
decl_stmt|;
name|PSAux_Service
name|psaux
init|=
operator|(
name|PSAux_Service
operator|)
name|face
operator|->
name|psaux
decl_stmt|;
name|T1_Skip_Spaces
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* test for empty array */
if|if
condition|(
name|parser
operator|->
name|root
operator|.
name|cursor
operator|<
name|parser
operator|->
name|root
operator|.
name|limit
operator|&&
operator|*
name|parser
operator|->
name|root
operator|.
name|cursor
operator|==
literal|'['
condition|)
block|{
name|T1_Skip_PS_Token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|T1_Skip_Spaces
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|parser
operator|->
name|root
operator|.
name|cursor
operator|>=
name|parser
operator|->
name|root
operator|.
name|limit
operator|||
operator|*
name|parser
operator|->
name|root
operator|.
name|cursor
operator|!=
literal|']'
condition|)
name|parser
operator|->
name|root
operator|.
name|error
operator|=
name|T1_Err_Invalid_File_Format
expr_stmt|;
return|return;
block|}
name|num_subrs
operator|=
operator|(
name|FT_Int
operator|)
name|T1_ToInt
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* position the parser right before the `dup' of the first subr */
name|T1_Skip_PS_Token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* `array' */
if|if
condition|(
name|parser
operator|->
name|root
operator|.
name|error
condition|)
return|return;
name|T1_Skip_Spaces
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* initialize subrs array -- with synthetic fonts it is possible */
comment|/* we get here twice                                             */
if|if
condition|(
operator|!
name|loader
operator|->
name|num_subrs
condition|)
block|{
name|error
operator|=
name|psaux
operator|->
name|ps_table_funcs
operator|->
name|init
argument_list|(
name|table
argument_list|,
name|num_subrs
argument_list|,
name|memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Fail
goto|;
block|}
comment|/* the format is simple:   */
comment|/*                         */
comment|/*   `index' + binary data */
comment|/*                         */
for|for
control|(
init|;
condition|;
control|)
block|{
name|FT_Long
name|idx
decl_stmt|,
name|size
decl_stmt|;
name|FT_Byte
modifier|*
name|base
decl_stmt|;
comment|/* If the next token isn't `dup' we are done. */
if|if
condition|(
name|ft_strncmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|parser
operator|->
name|root
operator|.
name|cursor
argument_list|,
literal|"dup"
argument_list|,
literal|3
argument_list|)
operator|!=
literal|0
condition|)
break|break;
name|T1_Skip_PS_Token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* `dup' */
name|idx
operator|=
name|T1_ToInt
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|read_binary_data
argument_list|(
name|parser
argument_list|,
operator|&
name|size
argument_list|,
operator|&
name|base
argument_list|)
condition|)
return|return;
comment|/* The binary string is followed by one token, e.g. `NP' */
comment|/* (bound to `noaccess put') or by two separate tokens:  */
comment|/* `noaccess'& `put'.  We position the parser right     */
comment|/* before the next `dup', if any.                        */
name|T1_Skip_PS_Token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* `NP' or `|' or `noaccess' */
if|if
condition|(
name|parser
operator|->
name|root
operator|.
name|error
condition|)
return|return;
name|T1_Skip_Spaces
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|ft_strncmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|parser
operator|->
name|root
operator|.
name|cursor
argument_list|,
literal|"put"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|T1_Skip_PS_Token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* skip `put' */
name|T1_Skip_Spaces
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
comment|/* with synthetic fonts it is possible we get here twice */
if|if
condition|(
name|loader
operator|->
name|num_subrs
condition|)
continue|continue;
comment|/* some fonts use a value of -1 for lenIV to indicate that */
comment|/* the charstrings are unencoded                           */
comment|/*                                                         */
comment|/* thanks to Tom Kacvinsky for pointing this out           */
comment|/*                                                         */
if|if
condition|(
name|face
operator|->
name|type1
operator|.
name|private_dict
operator|.
name|lenIV
operator|>=
literal|0
condition|)
block|{
name|FT_Byte
modifier|*
name|temp
decl_stmt|;
comment|/* some fonts define empty subr records -- this is not totally */
comment|/* compliant to the specification (which says they should at   */
comment|/* least contain a `return'), but we support them anyway       */
if|if
condition|(
name|size
operator|<
name|face
operator|->
name|type1
operator|.
name|private_dict
operator|.
name|lenIV
condition|)
block|{
name|error
operator|=
name|T1_Err_Invalid_File_Format
expr_stmt|;
goto|goto
name|Fail
goto|;
block|}
comment|/* t1_decrypt() shouldn't write to base -- make temporary copy */
if|if
condition|(
name|FT_ALLOC
argument_list|(
name|temp
argument_list|,
name|size
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
name|FT_MEM_COPY
argument_list|(
name|temp
argument_list|,
name|base
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|psaux
operator|->
name|t1_decrypt
argument_list|(
name|temp
argument_list|,
name|size
argument_list|,
literal|4330
argument_list|)
expr_stmt|;
name|size
operator|-=
name|face
operator|->
name|type1
operator|.
name|private_dict
operator|.
name|lenIV
expr_stmt|;
name|error
operator|=
name|T1_Add_Table
argument_list|(
name|table
argument_list|,
operator|(
name|FT_Int
operator|)
name|idx
argument_list|,
name|temp
operator|+
name|face
operator|->
name|type1
operator|.
name|private_dict
operator|.
name|lenIV
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
else|else
name|error
operator|=
name|T1_Add_Table
argument_list|(
name|table
argument_list|,
operator|(
name|FT_Int
operator|)
name|idx
argument_list|,
name|base
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Fail
goto|;
block|}
if|if
condition|(
operator|!
name|loader
operator|->
name|num_subrs
condition|)
name|loader
operator|->
name|num_subrs
operator|=
name|num_subrs
expr_stmt|;
return|return;
name|Fail
label|:
name|parser
operator|->
name|root
operator|.
name|error
operator|=
name|error
expr_stmt|;
block|}
end_function
begin_define
DECL|macro|TABLE_EXTEND
define|#
directive|define
name|TABLE_EXTEND
value|5
end_define
begin_function
specifier|static
name|void
DECL|function|parse_charstrings
name|parse_charstrings
parameter_list|(
name|T1_Face
name|face
parameter_list|,
name|T1_Loader
name|loader
parameter_list|)
block|{
name|T1_Parser
name|parser
init|=
operator|&
name|loader
operator|->
name|parser
decl_stmt|;
name|PS_Table
name|code_table
init|=
operator|&
name|loader
operator|->
name|charstrings
decl_stmt|;
name|PS_Table
name|name_table
init|=
operator|&
name|loader
operator|->
name|glyph_names
decl_stmt|;
name|PS_Table
name|swap_table
init|=
operator|&
name|loader
operator|->
name|swap_table
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|parser
operator|->
name|root
operator|.
name|memory
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|PSAux_Service
name|psaux
init|=
operator|(
name|PSAux_Service
operator|)
name|face
operator|->
name|psaux
decl_stmt|;
name|FT_Byte
modifier|*
name|cur
decl_stmt|;
name|FT_Byte
modifier|*
name|limit
init|=
name|parser
operator|->
name|root
operator|.
name|limit
decl_stmt|;
name|FT_Int
name|n
decl_stmt|,
name|num_glyphs
decl_stmt|;
name|FT_UInt
name|notdef_index
init|=
literal|0
decl_stmt|;
name|FT_Byte
name|notdef_found
init|=
literal|0
decl_stmt|;
name|num_glyphs
operator|=
operator|(
name|FT_Int
operator|)
name|T1_ToInt
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* some fonts like Optima-Oblique not only define the /CharStrings */
comment|/* array but access it also                                        */
if|if
condition|(
name|num_glyphs
operator|==
literal|0
operator|||
name|parser
operator|->
name|root
operator|.
name|error
condition|)
return|return;
comment|/* initialize tables, leaving space for addition of .notdef, */
comment|/* if necessary, and a few other glyphs to handle buggy      */
comment|/* fonts which have more glyphs than specified.              */
comment|/* for some non-standard fonts like `Optima' which provides  */
comment|/* different outlines depending on the resolution it is      */
comment|/* possible to get here twice                                */
if|if
condition|(
operator|!
name|loader
operator|->
name|num_glyphs
condition|)
block|{
name|error
operator|=
name|psaux
operator|->
name|ps_table_funcs
operator|->
name|init
argument_list|(
name|code_table
argument_list|,
name|num_glyphs
operator|+
literal|1
operator|+
name|TABLE_EXTEND
argument_list|,
name|memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Fail
goto|;
name|error
operator|=
name|psaux
operator|->
name|ps_table_funcs
operator|->
name|init
argument_list|(
name|name_table
argument_list|,
name|num_glyphs
operator|+
literal|1
operator|+
name|TABLE_EXTEND
argument_list|,
name|memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Fail
goto|;
comment|/* Initialize table for swapping index notdef_index and */
comment|/* index 0 names and codes (if necessary).              */
name|error
operator|=
name|psaux
operator|->
name|ps_table_funcs
operator|->
name|init
argument_list|(
name|swap_table
argument_list|,
literal|4
argument_list|,
name|memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Fail
goto|;
block|}
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|FT_Long
name|size
decl_stmt|;
name|FT_Byte
modifier|*
name|base
decl_stmt|;
comment|/* the format is simple:        */
comment|/*   `/glyphname' + binary data */
name|T1_Skip_Spaces
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|cur
operator|=
name|parser
operator|->
name|root
operator|.
name|cursor
expr_stmt|;
if|if
condition|(
name|cur
operator|>=
name|limit
condition|)
break|break;
comment|/* we stop when we find a `def' or `end' keyword */
if|if
condition|(
name|cur
operator|+
literal|3
operator|<
name|limit
operator|&&
name|IS_PS_DELIM
argument_list|(
name|cur
index|[
literal|3
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|cur
index|[
literal|0
index|]
operator|==
literal|'d'
operator|&&
name|cur
index|[
literal|1
index|]
operator|==
literal|'e'
operator|&&
name|cur
index|[
literal|2
index|]
operator|==
literal|'f'
condition|)
block|{
comment|/* There are fonts which have this: */
comment|/*                                  */
comment|/*   /CharStrings 118 dict def      */
comment|/*   Private begin                  */
comment|/*   CharStrings begin              */
comment|/*   ...                            */
comment|/*                                  */
comment|/* To catch this we ignore `def' if */
comment|/* no charstring has actually been  */
comment|/* seen.                            */
if|if
condition|(
name|n
condition|)
break|break;
block|}
if|if
condition|(
name|cur
index|[
literal|0
index|]
operator|==
literal|'e'
operator|&&
name|cur
index|[
literal|1
index|]
operator|==
literal|'n'
operator|&&
name|cur
index|[
literal|2
index|]
operator|==
literal|'d'
condition|)
break|break;
block|}
name|T1_Skip_PS_Token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|parser
operator|->
name|root
operator|.
name|error
condition|)
return|return;
if|if
condition|(
operator|*
name|cur
operator|==
literal|'/'
condition|)
block|{
name|FT_PtrDist
name|len
decl_stmt|;
if|if
condition|(
name|cur
operator|+
literal|1
operator|>=
name|limit
condition|)
block|{
name|error
operator|=
name|T1_Err_Invalid_File_Format
expr_stmt|;
goto|goto
name|Fail
goto|;
block|}
name|cur
operator|++
expr_stmt|;
comment|/* skip `/' */
name|len
operator|=
name|parser
operator|->
name|root
operator|.
name|cursor
operator|-
name|cur
expr_stmt|;
if|if
condition|(
operator|!
name|read_binary_data
argument_list|(
name|parser
argument_list|,
operator|&
name|size
argument_list|,
operator|&
name|base
argument_list|)
condition|)
return|return;
comment|/* for some non-standard fonts like `Optima' which provides */
comment|/* different outlines depending on the resolution it is     */
comment|/* possible to get here twice                               */
if|if
condition|(
name|loader
operator|->
name|num_glyphs
condition|)
continue|continue;
name|error
operator|=
name|T1_Add_Table
argument_list|(
name|name_table
argument_list|,
name|n
argument_list|,
name|cur
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Fail
goto|;
comment|/* add a trailing zero to the name table */
name|name_table
operator|->
name|elements
index|[
name|n
index|]
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* record index of /.notdef */
if|if
condition|(
operator|*
name|cur
operator|==
literal|'.'
operator|&&
name|ft_strcmp
argument_list|(
literal|".notdef"
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
operator|(
name|name_table
operator|->
name|elements
index|[
name|n
index|]
operator|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|notdef_index
operator|=
name|n
expr_stmt|;
name|notdef_found
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|face
operator|->
name|type1
operator|.
name|private_dict
operator|.
name|lenIV
operator|>=
literal|0
operator|&&
name|n
operator|<
name|num_glyphs
operator|+
name|TABLE_EXTEND
condition|)
block|{
name|FT_Byte
modifier|*
name|temp
decl_stmt|;
if|if
condition|(
name|size
operator|<=
name|face
operator|->
name|type1
operator|.
name|private_dict
operator|.
name|lenIV
condition|)
block|{
name|error
operator|=
name|T1_Err_Invalid_File_Format
expr_stmt|;
goto|goto
name|Fail
goto|;
block|}
comment|/* t1_decrypt() shouldn't write to base -- make temporary copy */
if|if
condition|(
name|FT_ALLOC
argument_list|(
name|temp
argument_list|,
name|size
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
name|FT_MEM_COPY
argument_list|(
name|temp
argument_list|,
name|base
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|psaux
operator|->
name|t1_decrypt
argument_list|(
name|temp
argument_list|,
name|size
argument_list|,
literal|4330
argument_list|)
expr_stmt|;
name|size
operator|-=
name|face
operator|->
name|type1
operator|.
name|private_dict
operator|.
name|lenIV
expr_stmt|;
name|error
operator|=
name|T1_Add_Table
argument_list|(
name|code_table
argument_list|,
name|n
argument_list|,
name|temp
operator|+
name|face
operator|->
name|type1
operator|.
name|private_dict
operator|.
name|lenIV
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
else|else
name|error
operator|=
name|T1_Add_Table
argument_list|(
name|code_table
argument_list|,
name|n
argument_list|,
name|base
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Fail
goto|;
name|n
operator|++
expr_stmt|;
block|}
block|}
name|loader
operator|->
name|num_glyphs
operator|=
name|n
expr_stmt|;
comment|/* if /.notdef is found but does not occupy index 0, do our magic. */
if|if
condition|(
name|notdef_found
operator|&&
name|ft_strcmp
argument_list|(
literal|".notdef"
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|name_table
operator|->
name|elements
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
comment|/* Swap glyph in index 0 with /.notdef glyph.  First, add index 0  */
comment|/* name and code entries to swap_table.  Then place notdef_index   */
comment|/* name and code entries into swap_table.  Then swap name and code */
comment|/* entries at indices notdef_index and 0 using values stored in    */
comment|/* swap_table.                                                     */
comment|/* Index 0 name */
name|error
operator|=
name|T1_Add_Table
argument_list|(
name|swap_table
argument_list|,
literal|0
argument_list|,
name|name_table
operator|->
name|elements
index|[
literal|0
index|]
argument_list|,
name|name_table
operator|->
name|lengths
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Fail
goto|;
comment|/* Index 0 code */
name|error
operator|=
name|T1_Add_Table
argument_list|(
name|swap_table
argument_list|,
literal|1
argument_list|,
name|code_table
operator|->
name|elements
index|[
literal|0
index|]
argument_list|,
name|code_table
operator|->
name|lengths
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Fail
goto|;
comment|/* Index notdef_index name */
name|error
operator|=
name|T1_Add_Table
argument_list|(
name|swap_table
argument_list|,
literal|2
argument_list|,
name|name_table
operator|->
name|elements
index|[
name|notdef_index
index|]
argument_list|,
name|name_table
operator|->
name|lengths
index|[
name|notdef_index
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Fail
goto|;
comment|/* Index notdef_index code */
name|error
operator|=
name|T1_Add_Table
argument_list|(
name|swap_table
argument_list|,
literal|3
argument_list|,
name|code_table
operator|->
name|elements
index|[
name|notdef_index
index|]
argument_list|,
name|code_table
operator|->
name|lengths
index|[
name|notdef_index
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Fail
goto|;
name|error
operator|=
name|T1_Add_Table
argument_list|(
name|name_table
argument_list|,
name|notdef_index
argument_list|,
name|swap_table
operator|->
name|elements
index|[
literal|0
index|]
argument_list|,
name|swap_table
operator|->
name|lengths
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Fail
goto|;
name|error
operator|=
name|T1_Add_Table
argument_list|(
name|code_table
argument_list|,
name|notdef_index
argument_list|,
name|swap_table
operator|->
name|elements
index|[
literal|1
index|]
argument_list|,
name|swap_table
operator|->
name|lengths
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Fail
goto|;
name|error
operator|=
name|T1_Add_Table
argument_list|(
name|name_table
argument_list|,
literal|0
argument_list|,
name|swap_table
operator|->
name|elements
index|[
literal|2
index|]
argument_list|,
name|swap_table
operator|->
name|lengths
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Fail
goto|;
name|error
operator|=
name|T1_Add_Table
argument_list|(
name|code_table
argument_list|,
literal|0
argument_list|,
name|swap_table
operator|->
name|elements
index|[
literal|3
index|]
argument_list|,
name|swap_table
operator|->
name|lengths
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Fail
goto|;
block|}
elseif|else
if|if
condition|(
operator|!
name|notdef_found
condition|)
block|{
comment|/* notdef_index is already 0, or /.notdef is undefined in   */
comment|/* charstrings dictionary.  Worry about /.notdef undefined. */
comment|/* We take index 0 and add it to the end of the table(s)    */
comment|/* and add our own /.notdef glyph to index 0.               */
comment|/* 0 333 hsbw endchar */
name|FT_Byte
name|notdef_glyph
index|[]
init|=
block|{
literal|0x8B
block|,
literal|0xF7
block|,
literal|0xE1
block|,
literal|0x0D
block|,
literal|0x0E
block|}
decl_stmt|;
name|char
modifier|*
name|notdef_name
init|=
operator|(
name|char
operator|*
operator|)
literal|".notdef"
decl_stmt|;
name|error
operator|=
name|T1_Add_Table
argument_list|(
name|swap_table
argument_list|,
literal|0
argument_list|,
name|name_table
operator|->
name|elements
index|[
literal|0
index|]
argument_list|,
name|name_table
operator|->
name|lengths
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Fail
goto|;
name|error
operator|=
name|T1_Add_Table
argument_list|(
name|swap_table
argument_list|,
literal|1
argument_list|,
name|code_table
operator|->
name|elements
index|[
literal|0
index|]
argument_list|,
name|code_table
operator|->
name|lengths
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Fail
goto|;
name|error
operator|=
name|T1_Add_Table
argument_list|(
name|name_table
argument_list|,
literal|0
argument_list|,
name|notdef_name
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Fail
goto|;
name|error
operator|=
name|T1_Add_Table
argument_list|(
name|code_table
argument_list|,
literal|0
argument_list|,
name|notdef_glyph
argument_list|,
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Fail
goto|;
name|error
operator|=
name|T1_Add_Table
argument_list|(
name|name_table
argument_list|,
name|n
argument_list|,
name|swap_table
operator|->
name|elements
index|[
literal|0
index|]
argument_list|,
name|swap_table
operator|->
name|lengths
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Fail
goto|;
name|error
operator|=
name|T1_Add_Table
argument_list|(
name|code_table
argument_list|,
name|n
argument_list|,
name|swap_table
operator|->
name|elements
index|[
literal|1
index|]
argument_list|,
name|swap_table
operator|->
name|lengths
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Fail
goto|;
comment|/* we added a glyph. */
name|loader
operator|->
name|num_glyphs
operator|+=
literal|1
expr_stmt|;
block|}
return|return;
name|Fail
label|:
name|parser
operator|->
name|root
operator|.
name|error
operator|=
name|error
expr_stmt|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* Define the token field static variables.  This is a set of            */
end_comment
begin_comment
comment|/* T1_FieldRec variables.                                                */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_decl_stmt
specifier|static
DECL|variable|t1_keywords
specifier|const
name|T1_FieldRec
name|t1_keywords
index|[]
init|=
block|{
include|#
directive|include
file|"t1tokens.h"
comment|/* now add the special functions... */
name|T1_FIELD_CALLBACK
argument_list|(
literal|"FontMatrix"
argument_list|,
argument|parse_font_matrix
argument_list|,
argument|T1_FIELD_DICT_FONTDICT
argument_list|)
name|T1_FIELD_CALLBACK
argument_list|(
literal|"Encoding"
argument_list|,
argument|parse_encoding
argument_list|,
argument|T1_FIELD_DICT_FONTDICT
argument_list|)
name|T1_FIELD_CALLBACK
argument_list|(
literal|"Subrs"
argument_list|,
argument|parse_subrs
argument_list|,
argument|T1_FIELD_DICT_PRIVATE
argument_list|)
name|T1_FIELD_CALLBACK
argument_list|(
literal|"CharStrings"
argument_list|,
argument|parse_charstrings
argument_list|,
argument|T1_FIELD_DICT_PRIVATE
argument_list|)
name|T1_FIELD_CALLBACK
argument_list|(
literal|"Private"
argument_list|,
argument|parse_private
argument_list|,
argument|T1_FIELD_DICT_FONTDICT
argument_list|)
ifndef|#
directive|ifndef
name|T1_CONFIG_OPTION_NO_MM_SUPPORT
name|T1_FIELD_CALLBACK
argument_list|(
literal|"BlendDesignPositions"
argument_list|,
argument|parse_blend_design_positions
argument_list|,
argument|T1_FIELD_DICT_FONTDICT
argument_list|)
name|T1_FIELD_CALLBACK
argument_list|(
literal|"BlendDesignMap"
argument_list|,
argument|parse_blend_design_map
argument_list|,
argument|T1_FIELD_DICT_FONTDICT
argument_list|)
name|T1_FIELD_CALLBACK
argument_list|(
literal|"BlendAxisTypes"
argument_list|,
argument|parse_blend_axis_types
argument_list|,
argument|T1_FIELD_DICT_FONTDICT
argument_list|)
name|T1_FIELD_CALLBACK
argument_list|(
literal|"WeightVector"
argument_list|,
argument|parse_weight_vector
argument_list|,
argument|T1_FIELD_DICT_FONTDICT
argument_list|)
name|T1_FIELD_CALLBACK
argument_list|(
literal|"BuildCharArray"
argument_list|,
argument|parse_buildchar
argument_list|,
argument|T1_FIELD_DICT_PRIVATE
argument_list|)
endif|#
directive|endif
block|{
literal|0
block|,
name|T1_FIELD_LOCATION_CID_INFO
block|,
name|T1_FIELD_TYPE_NONE
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt
begin_define
DECL|macro|T1_FIELD_COUNT
define|#
directive|define
name|T1_FIELD_COUNT
define|\
value|( sizeof ( t1_keywords ) / sizeof ( t1_keywords[0] ) )
end_define
begin_function
specifier|static
name|FT_Error
DECL|function|parse_dict
name|parse_dict
parameter_list|(
name|T1_Face
name|face
parameter_list|,
name|T1_Loader
name|loader
parameter_list|,
name|FT_Byte
modifier|*
name|base
parameter_list|,
name|FT_Long
name|size
parameter_list|)
block|{
name|T1_Parser
name|parser
init|=
operator|&
name|loader
operator|->
name|parser
decl_stmt|;
name|FT_Byte
modifier|*
name|limit
decl_stmt|,
modifier|*
name|start_binary
init|=
name|NULL
decl_stmt|;
name|FT_Bool
name|have_integer
init|=
literal|0
decl_stmt|;
name|parser
operator|->
name|root
operator|.
name|cursor
operator|=
name|base
expr_stmt|;
name|parser
operator|->
name|root
operator|.
name|limit
operator|=
name|base
operator|+
name|size
expr_stmt|;
name|parser
operator|->
name|root
operator|.
name|error
operator|=
name|T1_Err_Ok
expr_stmt|;
name|limit
operator|=
name|parser
operator|->
name|root
operator|.
name|limit
expr_stmt|;
name|T1_Skip_Spaces
argument_list|(
name|parser
argument_list|)
expr_stmt|;
while|while
condition|(
name|parser
operator|->
name|root
operator|.
name|cursor
operator|<
name|limit
condition|)
block|{
name|FT_Byte
modifier|*
name|cur
decl_stmt|;
name|cur
operator|=
name|parser
operator|->
name|root
operator|.
name|cursor
expr_stmt|;
comment|/* look for `eexec' */
if|if
condition|(
name|IS_PS_TOKEN
argument_list|(
name|cur
argument_list|,
name|limit
argument_list|,
literal|"eexec"
argument_list|)
condition|)
break|break;
comment|/* look for `closefile' which ends the eexec section */
elseif|else
if|if
condition|(
name|IS_PS_TOKEN
argument_list|(
name|cur
argument_list|,
name|limit
argument_list|,
literal|"closefile"
argument_list|)
condition|)
break|break;
comment|/* in a synthetic font the base font starts after a           */
comment|/* `FontDictionary' token that is placed after a Private dict */
elseif|else
if|if
condition|(
name|IS_PS_TOKEN
argument_list|(
name|cur
argument_list|,
name|limit
argument_list|,
literal|"FontDirectory"
argument_list|)
condition|)
block|{
if|if
condition|(
name|loader
operator|->
name|keywords_encountered
operator|&
name|T1_PRIVATE
condition|)
name|loader
operator|->
name|keywords_encountered
operator||=
name|T1_FONTDIR_AFTER_PRIVATE
expr_stmt|;
name|parser
operator|->
name|root
operator|.
name|cursor
operator|+=
literal|13
expr_stmt|;
block|}
comment|/* check whether we have an integer */
elseif|else
if|if
condition|(
name|ft_isdigit
argument_list|(
operator|*
name|cur
argument_list|)
condition|)
block|{
name|start_binary
operator|=
name|cur
expr_stmt|;
name|T1_Skip_PS_Token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|parser
operator|->
name|root
operator|.
name|error
condition|)
goto|goto
name|Exit
goto|;
name|have_integer
operator|=
literal|1
expr_stmt|;
block|}
comment|/* in valid Type 1 fonts we don't see `RD' or `-|' directly */
comment|/* since those tokens are handled by parse_subrs and        */
comment|/* parse_charstrings                                        */
elseif|else
if|if
condition|(
operator|*
name|cur
operator|==
literal|'R'
operator|&&
name|cur
operator|+
literal|6
operator|<
name|limit
operator|&&
operator|*
operator|(
name|cur
operator|+
literal|1
operator|)
operator|==
literal|'D'
operator|&&
name|have_integer
condition|)
block|{
name|FT_Long
name|s
decl_stmt|;
name|FT_Byte
modifier|*
name|b
decl_stmt|;
name|parser
operator|->
name|root
operator|.
name|cursor
operator|=
name|start_binary
expr_stmt|;
if|if
condition|(
operator|!
name|read_binary_data
argument_list|(
name|parser
argument_list|,
operator|&
name|s
argument_list|,
operator|&
name|b
argument_list|)
condition|)
return|return
name|T1_Err_Invalid_File_Format
return|;
name|have_integer
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|cur
operator|==
literal|'-'
operator|&&
name|cur
operator|+
literal|6
operator|<
name|limit
operator|&&
operator|*
operator|(
name|cur
operator|+
literal|1
operator|)
operator|==
literal|'|'
operator|&&
name|have_integer
condition|)
block|{
name|FT_Long
name|s
decl_stmt|;
name|FT_Byte
modifier|*
name|b
decl_stmt|;
name|parser
operator|->
name|root
operator|.
name|cursor
operator|=
name|start_binary
expr_stmt|;
if|if
condition|(
operator|!
name|read_binary_data
argument_list|(
name|parser
argument_list|,
operator|&
name|s
argument_list|,
operator|&
name|b
argument_list|)
condition|)
return|return
name|T1_Err_Invalid_File_Format
return|;
name|have_integer
operator|=
literal|0
expr_stmt|;
block|}
comment|/* look for immediates */
elseif|else
if|if
condition|(
operator|*
name|cur
operator|==
literal|'/'
operator|&&
name|cur
operator|+
literal|2
operator|<
name|limit
condition|)
block|{
name|FT_PtrDist
name|len
decl_stmt|;
name|cur
operator|++
expr_stmt|;
name|parser
operator|->
name|root
operator|.
name|cursor
operator|=
name|cur
expr_stmt|;
name|T1_Skip_PS_Token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|parser
operator|->
name|root
operator|.
name|error
condition|)
goto|goto
name|Exit
goto|;
name|len
operator|=
name|parser
operator|->
name|root
operator|.
name|cursor
operator|-
name|cur
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
operator|&&
name|len
operator|<
literal|22
operator|&&
name|parser
operator|->
name|root
operator|.
name|cursor
operator|<
name|limit
condition|)
block|{
comment|/* now compare the immediate name to the keyword table */
name|T1_Field
name|keyword
init|=
operator|(
name|T1_Field
operator|)
name|t1_keywords
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|FT_Byte
modifier|*
name|name
decl_stmt|;
name|name
operator|=
operator|(
name|FT_Byte
operator|*
operator|)
name|keyword
operator|->
name|ident
expr_stmt|;
if|if
condition|(
operator|!
name|name
condition|)
break|break;
if|if
condition|(
name|cur
index|[
literal|0
index|]
operator|==
name|name
index|[
literal|0
index|]
operator|&&
name|len
operator|==
operator|(
name|FT_PtrDist
operator|)
name|ft_strlen
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|name
argument_list|)
operator|&&
name|ft_memcmp
argument_list|(
name|cur
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* We found it -- run the parsing callback!     */
comment|/* We record every instance of every field      */
comment|/* (until we reach the base font of a           */
comment|/* synthetic font) to deal adequately with      */
comment|/* multiple master fonts; this is also          */
comment|/* necessary because later PostScript           */
comment|/* definitions override earlier ones.           */
comment|/* Once we encounter `FontDirectory' after      */
comment|/* `/Private', we know that this is a synthetic */
comment|/* font; except for `/CharStrings' we are not   */
comment|/* interested in anything that follows this     */
comment|/* `FontDirectory'.                             */
comment|/* MM fonts have more than one /Private token at */
comment|/* the top level; let's hope that all the junk   */
comment|/* that follows the first /Private token is not  */
comment|/* interesting to us.                            */
comment|/* According to Adobe Tech Note #5175 (CID-Keyed */
comment|/* Font Installation for ATM Software) a `begin' */
comment|/* must be followed by exactly one `end', and    */
comment|/* `begin' -- `end' pairs must be accurately     */
comment|/* paired.  We could use this to distinguish     */
comment|/* between the global Private and the Private    */
comment|/* dict that is a member of the Blend dict.      */
specifier|const
name|FT_UInt
name|dict
init|=
operator|(
name|loader
operator|->
name|keywords_encountered
operator|&
name|T1_PRIVATE
operator|)
condition|?
name|T1_FIELD_DICT_PRIVATE
else|:
name|T1_FIELD_DICT_FONTDICT
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|dict
operator|&
name|keyword
operator|->
name|dict
operator|)
condition|)
block|{
name|FT_TRACE1
argument_list|(
operator|(
literal|"parse_dict: found %s but ignoring it "
literal|"since it is in the wrong dictionary\n"
operator|,
name|keyword
operator|->
name|ident
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
operator|(
name|loader
operator|->
name|keywords_encountered
operator|&
name|T1_FONTDIR_AFTER_PRIVATE
operator|)
operator|||
name|ft_strcmp
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|name
argument_list|,
literal|"CharStrings"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|parser
operator|->
name|root
operator|.
name|error
operator|=
name|t1_load_keyword
argument_list|(
name|face
argument_list|,
name|loader
argument_list|,
name|keyword
argument_list|)
expr_stmt|;
if|if
condition|(
name|parser
operator|->
name|root
operator|.
name|error
operator|!=
name|T1_Err_Ok
condition|)
block|{
if|if
condition|(
name|FT_ERROR_BASE
argument_list|(
name|parser
operator|->
name|root
operator|.
name|error
argument_list|)
operator|==
name|FT_Err_Ignore
condition|)
name|parser
operator|->
name|root
operator|.
name|error
operator|=
name|T1_Err_Ok
expr_stmt|;
else|else
return|return
name|parser
operator|->
name|root
operator|.
name|error
return|;
block|}
block|}
break|break;
block|}
name|keyword
operator|++
expr_stmt|;
block|}
block|}
name|have_integer
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|T1_Skip_PS_Token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|parser
operator|->
name|root
operator|.
name|error
condition|)
goto|goto
name|Exit
goto|;
name|have_integer
operator|=
literal|0
expr_stmt|;
block|}
name|T1_Skip_Spaces
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
name|Exit
label|:
return|return
name|parser
operator|->
name|root
operator|.
name|error
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|t1_init_loader
name|t1_init_loader
parameter_list|(
name|T1_Loader
name|loader
parameter_list|,
name|T1_Face
name|face
parameter_list|)
block|{
name|FT_UNUSED
argument_list|(
name|face
argument_list|)
expr_stmt|;
name|FT_MEM_ZERO
argument_list|(
name|loader
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|loader
argument_list|)
argument_list|)
expr_stmt|;
name|loader
operator|->
name|num_glyphs
operator|=
literal|0
expr_stmt|;
name|loader
operator|->
name|num_chars
operator|=
literal|0
expr_stmt|;
comment|/* initialize the tables -- simply set their `init' field to 0 */
name|loader
operator|->
name|encoding_table
operator|.
name|init
operator|=
literal|0
expr_stmt|;
name|loader
operator|->
name|charstrings
operator|.
name|init
operator|=
literal|0
expr_stmt|;
name|loader
operator|->
name|glyph_names
operator|.
name|init
operator|=
literal|0
expr_stmt|;
name|loader
operator|->
name|subrs
operator|.
name|init
operator|=
literal|0
expr_stmt|;
name|loader
operator|->
name|swap_table
operator|.
name|init
operator|=
literal|0
expr_stmt|;
name|loader
operator|->
name|fontdata
operator|=
literal|0
expr_stmt|;
name|loader
operator|->
name|keywords_encountered
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|t1_done_loader
name|t1_done_loader
parameter_list|(
name|T1_Loader
name|loader
parameter_list|)
block|{
name|T1_Parser
name|parser
init|=
operator|&
name|loader
operator|->
name|parser
decl_stmt|;
comment|/* finalize tables */
name|T1_Release_Table
argument_list|(
operator|&
name|loader
operator|->
name|encoding_table
argument_list|)
expr_stmt|;
name|T1_Release_Table
argument_list|(
operator|&
name|loader
operator|->
name|charstrings
argument_list|)
expr_stmt|;
name|T1_Release_Table
argument_list|(
operator|&
name|loader
operator|->
name|glyph_names
argument_list|)
expr_stmt|;
name|T1_Release_Table
argument_list|(
operator|&
name|loader
operator|->
name|swap_table
argument_list|)
expr_stmt|;
name|T1_Release_Table
argument_list|(
operator|&
name|loader
operator|->
name|subrs
argument_list|)
expr_stmt|;
comment|/* finalize parser */
name|T1_Finalize_Parser
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
end_function
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|T1_Open_Face
argument_list|(
argument|T1_Face  face
argument_list|)
end_macro
begin_block
block|{
name|T1_LoaderRec
name|loader
decl_stmt|;
name|T1_Parser
name|parser
decl_stmt|;
name|T1_Font
name|type1
init|=
operator|&
name|face
operator|->
name|type1
decl_stmt|;
name|PS_Private
name|priv
init|=
operator|&
name|type1
operator|->
name|private_dict
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|PSAux_Service
name|psaux
init|=
operator|(
name|PSAux_Service
operator|)
name|face
operator|->
name|psaux
decl_stmt|;
name|t1_init_loader
argument_list|(
operator|&
name|loader
argument_list|,
name|face
argument_list|)
expr_stmt|;
comment|/* default values */
name|face
operator|->
name|ndv_idx
operator|=
operator|-
literal|1
expr_stmt|;
name|face
operator|->
name|cdv_idx
operator|=
operator|-
literal|1
expr_stmt|;
name|face
operator|->
name|len_buildchar
operator|=
literal|0
expr_stmt|;
name|priv
operator|->
name|blue_shift
operator|=
literal|7
expr_stmt|;
name|priv
operator|->
name|blue_fuzz
operator|=
literal|1
expr_stmt|;
name|priv
operator|->
name|lenIV
operator|=
literal|4
expr_stmt|;
name|priv
operator|->
name|expansion_factor
operator|=
call|(
name|FT_Fixed
call|)
argument_list|(
literal|0.06
operator|*
literal|0x10000L
argument_list|)
expr_stmt|;
name|priv
operator|->
name|blue_scale
operator|=
call|(
name|FT_Fixed
call|)
argument_list|(
literal|0.039625
operator|*
literal|0x10000L
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|parser
operator|=
operator|&
name|loader
operator|.
name|parser
expr_stmt|;
name|error
operator|=
name|T1_New_Parser
argument_list|(
name|parser
argument_list|,
name|face
operator|->
name|root
operator|.
name|stream
argument_list|,
name|face
operator|->
name|root
operator|.
name|memory
argument_list|,
name|psaux
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|error
operator|=
name|parse_dict
argument_list|(
name|face
argument_list|,
operator|&
name|loader
argument_list|,
name|parser
operator|->
name|base_dict
argument_list|,
name|parser
operator|->
name|base_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|error
operator|=
name|T1_Get_Private_Dict
argument_list|(
name|parser
argument_list|,
name|psaux
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|error
operator|=
name|parse_dict
argument_list|(
name|face
argument_list|,
operator|&
name|loader
argument_list|,
name|parser
operator|->
name|private_dict
argument_list|,
name|parser
operator|->
name|private_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
comment|/* ensure even-ness of `num_blue_values' */
name|priv
operator|->
name|num_blue_values
operator|&=
operator|~
literal|1
expr_stmt|;
ifndef|#
directive|ifndef
name|T1_CONFIG_OPTION_NO_MM_SUPPORT
if|if
condition|(
name|face
operator|->
name|blend
operator|&&
name|face
operator|->
name|blend
operator|->
name|num_default_design_vector
operator|!=
literal|0
operator|&&
name|face
operator|->
name|blend
operator|->
name|num_default_design_vector
operator|!=
name|face
operator|->
name|blend
operator|->
name|num_axis
condition|)
block|{
comment|/* we don't use it currently so just warn, reset, and ignore */
name|FT_ERROR
argument_list|(
operator|(
literal|"T1_Open_Face(): /DesignVector contains %u entries "
literal|"while there are %u axes.\n"
operator|,
name|face
operator|->
name|blend
operator|->
name|num_default_design_vector
operator|,
name|face
operator|->
name|blend
operator|->
name|num_axis
operator|)
argument_list|)
expr_stmt|;
name|face
operator|->
name|blend
operator|->
name|num_default_design_vector
operator|=
literal|0
expr_stmt|;
block|}
comment|/* the following can happen for MM instances; we then treat the */
comment|/* font as a normal PS font                                     */
if|if
condition|(
name|face
operator|->
name|blend
operator|&&
operator|(
operator|!
name|face
operator|->
name|blend
operator|->
name|num_designs
operator|||
operator|!
name|face
operator|->
name|blend
operator|->
name|num_axis
operator|)
condition|)
name|T1_Done_Blend
argument_list|(
name|face
argument_list|)
expr_stmt|;
comment|/* another safety check */
if|if
condition|(
name|face
operator|->
name|blend
condition|)
block|{
name|FT_UInt
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|face
operator|->
name|blend
operator|->
name|num_axis
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|face
operator|->
name|blend
operator|->
name|design_map
index|[
name|i
index|]
operator|.
name|num_points
condition|)
block|{
name|T1_Done_Blend
argument_list|(
name|face
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|face
operator|->
name|blend
condition|)
block|{
if|if
condition|(
name|face
operator|->
name|len_buildchar
operator|>
literal|0
condition|)
block|{
name|FT_Memory
name|memory
init|=
name|face
operator|->
name|root
operator|.
name|memory
decl_stmt|;
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|face
operator|->
name|buildchar
argument_list|,
name|face
operator|->
name|len_buildchar
argument_list|)
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"T1_Open_Face: cannot allocate BuildCharArray\n"
operator|)
argument_list|)
expr_stmt|;
name|face
operator|->
name|len_buildchar
operator|=
literal|0
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* T1_CONFIG_OPTION_NO_MM_SUPPORT */
comment|/* now, propagate the subrs, charstrings, and glyphnames tables */
comment|/* to the Type1 data                                            */
name|type1
operator|->
name|num_glyphs
operator|=
name|loader
operator|.
name|num_glyphs
expr_stmt|;
if|if
condition|(
name|loader
operator|.
name|subrs
operator|.
name|init
condition|)
block|{
name|loader
operator|.
name|subrs
operator|.
name|init
operator|=
literal|0
expr_stmt|;
name|type1
operator|->
name|num_subrs
operator|=
name|loader
operator|.
name|num_subrs
expr_stmt|;
name|type1
operator|->
name|subrs_block
operator|=
name|loader
operator|.
name|subrs
operator|.
name|block
expr_stmt|;
name|type1
operator|->
name|subrs
operator|=
name|loader
operator|.
name|subrs
operator|.
name|elements
expr_stmt|;
name|type1
operator|->
name|subrs_len
operator|=
name|loader
operator|.
name|subrs
operator|.
name|lengths
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|FT_CONFIG_OPTION_INCREMENTAL
if|if
condition|(
operator|!
name|face
operator|->
name|root
operator|.
name|internal
operator|->
name|incremental_interface
condition|)
endif|#
directive|endif
if|if
condition|(
operator|!
name|loader
operator|.
name|charstrings
operator|.
name|init
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"T1_Open_Face: no `/CharStrings' array in face!\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|T1_Err_Invalid_File_Format
expr_stmt|;
block|}
name|loader
operator|.
name|charstrings
operator|.
name|init
operator|=
literal|0
expr_stmt|;
name|type1
operator|->
name|charstrings_block
operator|=
name|loader
operator|.
name|charstrings
operator|.
name|block
expr_stmt|;
name|type1
operator|->
name|charstrings
operator|=
name|loader
operator|.
name|charstrings
operator|.
name|elements
expr_stmt|;
name|type1
operator|->
name|charstrings_len
operator|=
name|loader
operator|.
name|charstrings
operator|.
name|lengths
expr_stmt|;
comment|/* we copy the glyph names `block' and `elements' fields; */
comment|/* the `lengths' field must be released later             */
name|type1
operator|->
name|glyph_names_block
operator|=
name|loader
operator|.
name|glyph_names
operator|.
name|block
expr_stmt|;
name|type1
operator|->
name|glyph_names
operator|=
operator|(
name|FT_String
operator|*
operator|*
operator|)
name|loader
operator|.
name|glyph_names
operator|.
name|elements
expr_stmt|;
name|loader
operator|.
name|glyph_names
operator|.
name|block
operator|=
literal|0
expr_stmt|;
name|loader
operator|.
name|glyph_names
operator|.
name|elements
operator|=
literal|0
expr_stmt|;
comment|/* we must now build type1.encoding when we have a custom array */
if|if
condition|(
name|type1
operator|->
name|encoding_type
operator|==
name|T1_ENCODING_TYPE_ARRAY
condition|)
block|{
name|FT_Int
name|charcode
decl_stmt|,
name|idx
decl_stmt|,
name|min_char
decl_stmt|,
name|max_char
decl_stmt|;
name|FT_Byte
modifier|*
name|char_name
decl_stmt|;
name|FT_Byte
modifier|*
name|glyph_name
decl_stmt|;
comment|/* OK, we do the following: for each element in the encoding  */
comment|/* table, look up the index of the glyph having the same name */
comment|/* the index is then stored in type1.encoding.char_index, and */
comment|/* a the name to type1.encoding.char_name                     */
name|min_char
operator|=
operator|+
literal|32000
expr_stmt|;
name|max_char
operator|=
operator|-
literal|32000
expr_stmt|;
name|charcode
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|charcode
operator|<
name|loader
operator|.
name|encoding_table
operator|.
name|max_elems
condition|;
name|charcode
operator|++
control|)
block|{
name|type1
operator|->
name|encoding
operator|.
name|char_index
index|[
name|charcode
index|]
operator|=
literal|0
expr_stmt|;
name|type1
operator|->
name|encoding
operator|.
name|char_name
index|[
name|charcode
index|]
operator|=
operator|(
name|char
operator|*
operator|)
literal|".notdef"
expr_stmt|;
name|char_name
operator|=
name|loader
operator|.
name|encoding_table
operator|.
name|elements
index|[
name|charcode
index|]
expr_stmt|;
if|if
condition|(
name|char_name
condition|)
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|type1
operator|->
name|num_glyphs
condition|;
name|idx
operator|++
control|)
block|{
name|glyph_name
operator|=
operator|(
name|FT_Byte
operator|*
operator|)
name|type1
operator|->
name|glyph_names
index|[
name|idx
index|]
expr_stmt|;
if|if
condition|(
name|ft_strcmp
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|char_name
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|glyph_name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|type1
operator|->
name|encoding
operator|.
name|char_index
index|[
name|charcode
index|]
operator|=
operator|(
name|FT_UShort
operator|)
name|idx
expr_stmt|;
name|type1
operator|->
name|encoding
operator|.
name|char_name
index|[
name|charcode
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|glyph_name
expr_stmt|;
comment|/* Change min/max encoded char only if glyph name is */
comment|/* not /.notdef                                      */
if|if
condition|(
name|ft_strcmp
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
literal|".notdef"
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|glyph_name
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|charcode
operator|<
name|min_char
condition|)
name|min_char
operator|=
name|charcode
expr_stmt|;
if|if
condition|(
name|charcode
operator|>
name|max_char
condition|)
name|max_char
operator|=
name|charcode
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
comment|/*        *  Yes, this happens: Certain PDF-embedded fonts have only a        *  `.notdef' glyph defined!        */
if|if
condition|(
name|min_char
operator|>
name|max_char
condition|)
block|{
name|min_char
operator|=
literal|0
expr_stmt|;
name|max_char
operator|=
name|loader
operator|.
name|encoding_table
operator|.
name|max_elems
expr_stmt|;
block|}
name|type1
operator|->
name|encoding
operator|.
name|code_first
operator|=
name|min_char
expr_stmt|;
name|type1
operator|->
name|encoding
operator|.
name|code_last
operator|=
name|max_char
expr_stmt|;
name|type1
operator|->
name|encoding
operator|.
name|num_chars
operator|=
name|loader
operator|.
name|num_chars
expr_stmt|;
block|}
name|Exit
label|:
name|t1_done_loader
argument_list|(
operator|&
name|loader
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/* END */
end_comment
end_unit
