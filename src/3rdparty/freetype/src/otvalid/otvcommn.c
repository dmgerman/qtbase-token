begin_unit
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  otvcommn.c                                                             */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*    OpenType common tables validation (body).                            */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  Copyright 2004-2015 by                                                 */
end_comment
begin_comment
comment|/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  This file is part of the FreeType project, and may only be used,       */
end_comment
begin_comment
comment|/*  modified, and distributed under the terms of the FreeType project      */
end_comment
begin_comment
comment|/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
end_comment
begin_comment
comment|/*  this file you indicate that you have read the license and              */
end_comment
begin_comment
comment|/*  understand and accept it fully.                                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"otvcommn.h"
end_include
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
end_comment
begin_comment
comment|/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
end_comment
begin_comment
comment|/* messages during execution.                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_undef
DECL|macro|FT_COMPONENT
undef|#
directive|undef
name|FT_COMPONENT
end_undef
begin_define
DECL|macro|FT_COMPONENT
define|#
directive|define
name|FT_COMPONENT
value|trace_otvcommon
end_define
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****                       COVERAGE TABLE                          *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|otv_Coverage_validate
name|otv_Coverage_validate
argument_list|(
argument|FT_Bytes       table
argument_list|,
argument|OTV_Validator  otvalid
argument_list|,
argument|FT_Int         expected_count
argument_list|)
end_macro
begin_block
block|{
name|FT_Bytes
name|p
init|=
name|table
decl_stmt|;
name|FT_UInt
name|CoverageFormat
decl_stmt|;
name|FT_UInt
name|total
init|=
literal|0
decl_stmt|;
name|OTV_NAME_ENTER
argument_list|(
literal|"Coverage"
argument_list|)
expr_stmt|;
name|OTV_LIMIT_CHECK
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|CoverageFormat
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|OTV_TRACE
argument_list|(
operator|(
literal|" (format %d)\n"
operator|,
name|CoverageFormat
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|CoverageFormat
condition|)
block|{
case|case
literal|1
case|:
comment|/* CoverageFormat1 */
block|{
name|FT_UInt
name|GlyphCount
decl_stmt|;
name|FT_UInt
name|i
decl_stmt|;
name|GlyphCount
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|OTV_TRACE
argument_list|(
operator|(
literal|" (GlyphCount = %d)\n"
operator|,
name|GlyphCount
operator|)
argument_list|)
expr_stmt|;
name|OTV_LIMIT_CHECK
argument_list|(
name|GlyphCount
operator|*
literal|2
argument_list|)
expr_stmt|;
comment|/* GlyphArray */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GlyphCount
condition|;
operator|++
name|i
control|)
block|{
name|FT_UInt
name|gid
decl_stmt|;
name|gid
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|gid
operator|>=
name|otvalid
operator|->
name|glyph_count
condition|)
name|FT_INVALID_GLYPH_ID
expr_stmt|;
block|}
name|total
operator|=
name|GlyphCount
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
comment|/* CoverageFormat2 */
block|{
name|FT_UInt
name|n
decl_stmt|,
name|RangeCount
decl_stmt|;
name|FT_UInt
name|Start
decl_stmt|,
name|End
decl_stmt|,
name|StartCoverageIndex
decl_stmt|,
name|last
init|=
literal|0
decl_stmt|;
name|RangeCount
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|OTV_TRACE
argument_list|(
operator|(
literal|" (RangeCount = %d)\n"
operator|,
name|RangeCount
operator|)
argument_list|)
expr_stmt|;
name|OTV_LIMIT_CHECK
argument_list|(
name|RangeCount
operator|*
literal|6
argument_list|)
expr_stmt|;
comment|/* RangeRecord */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|RangeCount
condition|;
name|n
operator|++
control|)
block|{
name|Start
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|End
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|StartCoverageIndex
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|Start
operator|>
name|End
operator|||
name|StartCoverageIndex
operator|!=
name|total
condition|)
name|FT_INVALID_DATA
expr_stmt|;
if|if
condition|(
name|End
operator|>=
name|otvalid
operator|->
name|glyph_count
condition|)
name|FT_INVALID_GLYPH_ID
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
operator|&&
name|Start
operator|<=
name|last
condition|)
name|FT_INVALID_DATA
expr_stmt|;
name|total
operator|+=
name|End
operator|-
name|Start
operator|+
literal|1
expr_stmt|;
name|last
operator|=
name|End
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|FT_INVALID_FORMAT
expr_stmt|;
block|}
comment|/* Generally, a coverage table offset has an associated count field.  */
comment|/* The number of glyphs in the table should match this field.  If     */
comment|/* there is no associated count, a value of -1 tells us not to check. */
if|if
condition|(
name|expected_count
operator|!=
operator|-
literal|1
operator|&&
operator|(
name|FT_UInt
operator|)
name|expected_count
operator|!=
name|total
condition|)
name|FT_INVALID_DATA
expr_stmt|;
name|OTV_EXIT
expr_stmt|;
block|}
end_block
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_UInt
argument_list|)
end_macro
begin_macro
name|otv_Coverage_get_first
argument_list|(
argument|FT_Bytes  table
argument_list|)
end_macro
begin_block
block|{
name|FT_Bytes
name|p
init|=
name|table
decl_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
comment|/* skip CoverageFormat and Glyph/RangeCount */
return|return
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
return|;
block|}
end_block
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_UInt
argument_list|)
end_macro
begin_macro
name|otv_Coverage_get_last
argument_list|(
argument|FT_Bytes  table
argument_list|)
end_macro
begin_block
block|{
name|FT_Bytes
name|p
init|=
name|table
decl_stmt|;
name|FT_UInt
name|CoverageFormat
init|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|FT_UInt
name|count
init|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
decl_stmt|;
comment|/* Glyph/RangeCount */
name|FT_UInt
name|result
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|CoverageFormat
condition|)
block|{
case|case
literal|1
case|:
name|p
operator|+=
operator|(
name|count
operator|-
literal|1
operator|)
operator|*
literal|2
expr_stmt|;
name|result
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|p
operator|+=
operator|(
name|count
operator|-
literal|1
operator|)
operator|*
literal|6
operator|+
literal|2
expr_stmt|;
name|result
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
default|default:
empty_stmt|;
block|}
return|return
name|result
return|;
block|}
end_block
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_UInt
argument_list|)
end_macro
begin_macro
name|otv_Coverage_get_count
argument_list|(
argument|FT_Bytes  table
argument_list|)
end_macro
begin_block
block|{
name|FT_Bytes
name|p
init|=
name|table
decl_stmt|;
name|FT_UInt
name|CoverageFormat
init|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|FT_UInt
name|count
init|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
decl_stmt|;
comment|/* Glyph/RangeCount */
name|FT_UInt
name|result
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|CoverageFormat
condition|)
block|{
case|case
literal|1
case|:
return|return
name|count
return|;
case|case
literal|2
case|:
block|{
name|FT_UInt
name|Start
decl_stmt|,
name|End
decl_stmt|;
for|for
control|(
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
control|)
block|{
name|Start
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|End
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
comment|/* skip StartCoverageIndex */
name|result
operator|+=
name|End
operator|-
name|Start
operator|+
literal|1
expr_stmt|;
block|}
block|}
break|break;
default|default:
empty_stmt|;
block|}
return|return
name|result
return|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****                   CLASS DEFINITION TABLE                      *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|otv_ClassDef_validate
name|otv_ClassDef_validate
argument_list|(
argument|FT_Bytes       table
argument_list|,
argument|OTV_Validator  otvalid
argument_list|)
end_macro
begin_block
block|{
name|FT_Bytes
name|p
init|=
name|table
decl_stmt|;
name|FT_UInt
name|ClassFormat
decl_stmt|;
name|OTV_NAME_ENTER
argument_list|(
literal|"ClassDef"
argument_list|)
expr_stmt|;
name|OTV_LIMIT_CHECK
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|ClassFormat
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|OTV_TRACE
argument_list|(
operator|(
literal|" (format %d)\n"
operator|,
name|ClassFormat
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ClassFormat
condition|)
block|{
case|case
literal|1
case|:
comment|/* ClassDefFormat1 */
block|{
name|FT_UInt
name|StartGlyph
decl_stmt|;
name|FT_UInt
name|GlyphCount
decl_stmt|;
name|OTV_LIMIT_CHECK
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|StartGlyph
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|GlyphCount
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|OTV_TRACE
argument_list|(
operator|(
literal|" (GlyphCount = %d)\n"
operator|,
name|GlyphCount
operator|)
argument_list|)
expr_stmt|;
name|OTV_LIMIT_CHECK
argument_list|(
name|GlyphCount
operator|*
literal|2
argument_list|)
expr_stmt|;
comment|/* ClassValueArray */
if|if
condition|(
name|StartGlyph
operator|+
name|GlyphCount
operator|-
literal|1
operator|>=
name|otvalid
operator|->
name|glyph_count
condition|)
name|FT_INVALID_GLYPH_ID
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
comment|/* ClassDefFormat2 */
block|{
name|FT_UInt
name|n
decl_stmt|,
name|ClassRangeCount
decl_stmt|;
name|FT_UInt
name|Start
decl_stmt|,
name|End
decl_stmt|,
name|last
init|=
literal|0
decl_stmt|;
name|ClassRangeCount
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|OTV_TRACE
argument_list|(
operator|(
literal|" (ClassRangeCount = %d)\n"
operator|,
name|ClassRangeCount
operator|)
argument_list|)
expr_stmt|;
name|OTV_LIMIT_CHECK
argument_list|(
name|ClassRangeCount
operator|*
literal|6
argument_list|)
expr_stmt|;
comment|/* ClassRangeRecord */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|ClassRangeCount
condition|;
name|n
operator|++
control|)
block|{
name|Start
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|End
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
comment|/* skip Class */
if|if
condition|(
name|Start
operator|>
name|End
operator|||
operator|(
name|n
operator|>
literal|0
operator|&&
name|Start
operator|<=
name|last
operator|)
condition|)
name|FT_INVALID_DATA
expr_stmt|;
if|if
condition|(
name|End
operator|>=
name|otvalid
operator|->
name|glyph_count
condition|)
name|FT_INVALID_GLYPH_ID
expr_stmt|;
name|last
operator|=
name|End
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|FT_INVALID_FORMAT
expr_stmt|;
block|}
comment|/* no need to check glyph indices used as input to class definition   */
comment|/* tables since even invalid glyph indices return a meaningful result */
name|OTV_EXIT
expr_stmt|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****                      DEVICE TABLE                             *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|otv_Device_validate
name|otv_Device_validate
argument_list|(
argument|FT_Bytes       table
argument_list|,
argument|OTV_Validator  otvalid
argument_list|)
end_macro
begin_block
block|{
name|FT_Bytes
name|p
init|=
name|table
decl_stmt|;
name|FT_UInt
name|StartSize
decl_stmt|,
name|EndSize
decl_stmt|,
name|DeltaFormat
decl_stmt|,
name|count
decl_stmt|;
name|OTV_NAME_ENTER
argument_list|(
literal|"Device"
argument_list|)
expr_stmt|;
name|OTV_LIMIT_CHECK
argument_list|(
literal|8
argument_list|)
expr_stmt|;
name|StartSize
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|EndSize
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|DeltaFormat
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|DeltaFormat
operator|<
literal|1
operator|||
name|DeltaFormat
operator|>
literal|3
condition|)
name|FT_INVALID_FORMAT
expr_stmt|;
if|if
condition|(
name|EndSize
operator|<
name|StartSize
condition|)
name|FT_INVALID_DATA
expr_stmt|;
name|count
operator|=
name|EndSize
operator|-
name|StartSize
operator|+
literal|1
expr_stmt|;
name|OTV_LIMIT_CHECK
argument_list|(
operator|(
literal|1
operator|<<
name|DeltaFormat
operator|)
operator|*
name|count
operator|/
literal|8
argument_list|)
expr_stmt|;
comment|/* DeltaValue */
name|OTV_EXIT
expr_stmt|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****                         LOOKUPS                               *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/* uses otvalid->type_count */
end_comment
begin_comment
comment|/* uses otvalid->type_funcs */
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|otv_Lookup_validate
name|otv_Lookup_validate
argument_list|(
argument|FT_Bytes       table
argument_list|,
argument|OTV_Validator  otvalid
argument_list|)
end_macro
begin_block
block|{
name|FT_Bytes
name|p
init|=
name|table
decl_stmt|;
name|FT_UInt
name|LookupType
decl_stmt|,
name|SubTableCount
decl_stmt|;
name|OTV_Validate_Func
name|validate
decl_stmt|;
name|OTV_NAME_ENTER
argument_list|(
literal|"Lookup"
argument_list|)
expr_stmt|;
name|OTV_LIMIT_CHECK
argument_list|(
literal|6
argument_list|)
expr_stmt|;
name|LookupType
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
comment|/* skip LookupFlag */
name|SubTableCount
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|OTV_TRACE
argument_list|(
operator|(
literal|" (type %d)\n"
operator|,
name|LookupType
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|LookupType
operator|==
literal|0
operator|||
name|LookupType
operator|>
name|otvalid
operator|->
name|type_count
condition|)
name|FT_INVALID_DATA
expr_stmt|;
name|validate
operator|=
name|otvalid
operator|->
name|type_funcs
index|[
name|LookupType
operator|-
literal|1
index|]
expr_stmt|;
name|OTV_TRACE
argument_list|(
operator|(
literal|" (SubTableCount = %d)\n"
operator|,
name|SubTableCount
operator|)
argument_list|)
expr_stmt|;
name|OTV_LIMIT_CHECK
argument_list|(
name|SubTableCount
operator|*
literal|2
argument_list|)
expr_stmt|;
comment|/* SubTable */
for|for
control|(
init|;
name|SubTableCount
operator|>
literal|0
condition|;
name|SubTableCount
operator|--
control|)
name|validate
argument_list|(
name|table
operator|+
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
argument_list|,
name|otvalid
argument_list|)
expr_stmt|;
name|OTV_EXIT
expr_stmt|;
block|}
end_block
begin_comment
comment|/* uses valid->lookup_count */
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|otv_LookupList_validate
name|otv_LookupList_validate
argument_list|(
argument|FT_Bytes       table
argument_list|,
argument|OTV_Validator  otvalid
argument_list|)
end_macro
begin_block
block|{
name|FT_Bytes
name|p
init|=
name|table
decl_stmt|;
name|FT_UInt
name|LookupCount
decl_stmt|;
name|OTV_NAME_ENTER
argument_list|(
literal|"LookupList"
argument_list|)
expr_stmt|;
name|OTV_LIMIT_CHECK
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|LookupCount
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|OTV_TRACE
argument_list|(
operator|(
literal|" (LookupCount = %d)\n"
operator|,
name|LookupCount
operator|)
argument_list|)
expr_stmt|;
name|OTV_LIMIT_CHECK
argument_list|(
name|LookupCount
operator|*
literal|2
argument_list|)
expr_stmt|;
name|otvalid
operator|->
name|lookup_count
operator|=
name|LookupCount
expr_stmt|;
comment|/* Lookup */
for|for
control|(
init|;
name|LookupCount
operator|>
literal|0
condition|;
name|LookupCount
operator|--
control|)
name|otv_Lookup_validate
argument_list|(
name|table
operator|+
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
argument_list|,
name|otvalid
argument_list|)
expr_stmt|;
name|OTV_EXIT
expr_stmt|;
block|}
end_block
begin_function
specifier|static
name|FT_UInt
DECL|function|otv_LookupList_get_count
name|otv_LookupList_get_count
parameter_list|(
name|FT_Bytes
name|table
parameter_list|)
block|{
return|return
name|FT_NEXT_USHORT
argument_list|(
name|table
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****                        FEATURES                               *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/* uses otvalid->lookup_count */
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|otv_Feature_validate
name|otv_Feature_validate
argument_list|(
argument|FT_Bytes       table
argument_list|,
argument|OTV_Validator  otvalid
argument_list|)
end_macro
begin_block
block|{
name|FT_Bytes
name|p
init|=
name|table
decl_stmt|;
name|FT_UInt
name|LookupCount
decl_stmt|;
name|OTV_NAME_ENTER
argument_list|(
literal|"Feature"
argument_list|)
expr_stmt|;
name|OTV_LIMIT_CHECK
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
comment|/* skip FeatureParams (unused) */
name|LookupCount
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|OTV_TRACE
argument_list|(
operator|(
literal|" (LookupCount = %d)\n"
operator|,
name|LookupCount
operator|)
argument_list|)
expr_stmt|;
name|OTV_LIMIT_CHECK
argument_list|(
name|LookupCount
operator|*
literal|2
argument_list|)
expr_stmt|;
comment|/* LookupListIndex */
for|for
control|(
init|;
name|LookupCount
operator|>
literal|0
condition|;
name|LookupCount
operator|--
control|)
if|if
condition|(
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
operator|>=
name|otvalid
operator|->
name|lookup_count
condition|)
name|FT_INVALID_DATA
expr_stmt|;
name|OTV_EXIT
expr_stmt|;
block|}
end_block
begin_function
specifier|static
name|FT_UInt
DECL|function|otv_Feature_get_count
name|otv_Feature_get_count
parameter_list|(
name|FT_Bytes
name|table
parameter_list|)
block|{
return|return
name|FT_NEXT_USHORT
argument_list|(
name|table
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/* sets otvalid->lookup_count */
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|otv_FeatureList_validate
name|otv_FeatureList_validate
argument_list|(
argument|FT_Bytes       table
argument_list|,
argument|FT_Bytes       lookups
argument_list|,
argument|OTV_Validator  otvalid
argument_list|)
end_macro
begin_block
block|{
name|FT_Bytes
name|p
init|=
name|table
decl_stmt|;
name|FT_UInt
name|FeatureCount
decl_stmt|;
name|OTV_NAME_ENTER
argument_list|(
literal|"FeatureList"
argument_list|)
expr_stmt|;
name|OTV_LIMIT_CHECK
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|FeatureCount
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|OTV_TRACE
argument_list|(
operator|(
literal|" (FeatureCount = %d)\n"
operator|,
name|FeatureCount
operator|)
argument_list|)
expr_stmt|;
name|OTV_LIMIT_CHECK
argument_list|(
name|FeatureCount
operator|*
literal|2
argument_list|)
expr_stmt|;
name|otvalid
operator|->
name|lookup_count
operator|=
name|otv_LookupList_get_count
argument_list|(
name|lookups
argument_list|)
expr_stmt|;
comment|/* FeatureRecord */
for|for
control|(
init|;
name|FeatureCount
operator|>
literal|0
condition|;
name|FeatureCount
operator|--
control|)
block|{
name|p
operator|+=
literal|4
expr_stmt|;
comment|/* skip FeatureTag */
comment|/* Feature */
name|otv_Feature_validate
argument_list|(
name|table
operator|+
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
argument_list|,
name|otvalid
argument_list|)
expr_stmt|;
block|}
name|OTV_EXIT
expr_stmt|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****                       LANGUAGE SYSTEM                         *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/* uses otvalid->extra1 (number of features) */
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|otv_LangSys_validate
name|otv_LangSys_validate
argument_list|(
argument|FT_Bytes       table
argument_list|,
argument|OTV_Validator  otvalid
argument_list|)
end_macro
begin_block
block|{
name|FT_Bytes
name|p
init|=
name|table
decl_stmt|;
name|FT_UInt
name|ReqFeatureIndex
decl_stmt|;
name|FT_UInt
name|FeatureCount
decl_stmt|;
name|OTV_NAME_ENTER
argument_list|(
literal|"LangSys"
argument_list|)
expr_stmt|;
name|OTV_LIMIT_CHECK
argument_list|(
literal|6
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
comment|/* skip LookupOrder (unused) */
name|ReqFeatureIndex
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|FeatureCount
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|OTV_TRACE
argument_list|(
operator|(
literal|" (ReqFeatureIndex = %d)\n"
operator|,
name|ReqFeatureIndex
operator|)
argument_list|)
expr_stmt|;
name|OTV_TRACE
argument_list|(
operator|(
literal|" (FeatureCount = %d)\n"
operator|,
name|FeatureCount
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ReqFeatureIndex
operator|!=
literal|0xFFFFU
operator|&&
name|ReqFeatureIndex
operator|>=
name|otvalid
operator|->
name|extra1
condition|)
name|FT_INVALID_DATA
expr_stmt|;
name|OTV_LIMIT_CHECK
argument_list|(
name|FeatureCount
operator|*
literal|2
argument_list|)
expr_stmt|;
comment|/* FeatureIndex */
for|for
control|(
init|;
name|FeatureCount
operator|>
literal|0
condition|;
name|FeatureCount
operator|--
control|)
if|if
condition|(
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
operator|>=
name|otvalid
operator|->
name|extra1
condition|)
name|FT_INVALID_DATA
expr_stmt|;
name|OTV_EXIT
expr_stmt|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****                           SCRIPTS                             *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|otv_Script_validate
name|otv_Script_validate
argument_list|(
argument|FT_Bytes       table
argument_list|,
argument|OTV_Validator  otvalid
argument_list|)
end_macro
begin_block
block|{
name|FT_UInt
name|DefaultLangSys
decl_stmt|,
name|LangSysCount
decl_stmt|;
name|FT_Bytes
name|p
init|=
name|table
decl_stmt|;
name|OTV_NAME_ENTER
argument_list|(
literal|"Script"
argument_list|)
expr_stmt|;
name|OTV_LIMIT_CHECK
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|DefaultLangSys
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|LangSysCount
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|OTV_TRACE
argument_list|(
operator|(
literal|" (LangSysCount = %d)\n"
operator|,
name|LangSysCount
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DefaultLangSys
operator|!=
literal|0
condition|)
name|otv_LangSys_validate
argument_list|(
name|table
operator|+
name|DefaultLangSys
argument_list|,
name|otvalid
argument_list|)
expr_stmt|;
name|OTV_LIMIT_CHECK
argument_list|(
name|LangSysCount
operator|*
literal|6
argument_list|)
expr_stmt|;
comment|/* LangSysRecord */
for|for
control|(
init|;
name|LangSysCount
operator|>
literal|0
condition|;
name|LangSysCount
operator|--
control|)
block|{
name|p
operator|+=
literal|4
expr_stmt|;
comment|/* skip LangSysTag */
comment|/* LangSys */
name|otv_LangSys_validate
argument_list|(
name|table
operator|+
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
argument_list|,
name|otvalid
argument_list|)
expr_stmt|;
block|}
name|OTV_EXIT
expr_stmt|;
block|}
end_block
begin_comment
comment|/* sets otvalid->extra1 (number of features) */
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|otv_ScriptList_validate
name|otv_ScriptList_validate
argument_list|(
argument|FT_Bytes       table
argument_list|,
argument|FT_Bytes       features
argument_list|,
argument|OTV_Validator  otvalid
argument_list|)
end_macro
begin_block
block|{
name|FT_UInt
name|ScriptCount
decl_stmt|;
name|FT_Bytes
name|p
init|=
name|table
decl_stmt|;
name|OTV_NAME_ENTER
argument_list|(
literal|"ScriptList"
argument_list|)
expr_stmt|;
name|OTV_LIMIT_CHECK
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|ScriptCount
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|OTV_TRACE
argument_list|(
operator|(
literal|" (ScriptCount = %d)\n"
operator|,
name|ScriptCount
operator|)
argument_list|)
expr_stmt|;
name|OTV_LIMIT_CHECK
argument_list|(
name|ScriptCount
operator|*
literal|6
argument_list|)
expr_stmt|;
name|otvalid
operator|->
name|extra1
operator|=
name|otv_Feature_get_count
argument_list|(
name|features
argument_list|)
expr_stmt|;
comment|/* ScriptRecord */
for|for
control|(
init|;
name|ScriptCount
operator|>
literal|0
condition|;
name|ScriptCount
operator|--
control|)
block|{
name|p
operator|+=
literal|4
expr_stmt|;
comment|/* skip ScriptTag */
name|otv_Script_validate
argument_list|(
name|table
operator|+
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
argument_list|,
name|otvalid
argument_list|)
expr_stmt|;
comment|/* Script */
block|}
name|OTV_EXIT
expr_stmt|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****                      UTILITY FUNCTIONS                        *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*      u:   uint16      ux:  unit16 [x]       s:   struct      sx:  struct [x]      sxy: struct [x], using external y count       x:   uint16 x       C:   Coverage       O:   Offset      On:  Offset (NULL)      Ox:  Offset [x]      Onx: Offset (NULL) [x]   */
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|otv_x_Ox
name|otv_x_Ox
argument_list|(
argument|FT_Bytes       table
argument_list|,
argument|OTV_Validator  otvalid
argument_list|)
end_macro
begin_block
block|{
name|FT_Bytes
name|p
init|=
name|table
decl_stmt|;
name|FT_UInt
name|Count
decl_stmt|;
name|OTV_Validate_Func
name|func
decl_stmt|;
name|OTV_ENTER
expr_stmt|;
name|OTV_LIMIT_CHECK
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|Count
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|OTV_TRACE
argument_list|(
operator|(
literal|" (Count = %d)\n"
operator|,
name|Count
operator|)
argument_list|)
expr_stmt|;
name|OTV_LIMIT_CHECK
argument_list|(
name|Count
operator|*
literal|2
argument_list|)
expr_stmt|;
name|otvalid
operator|->
name|nesting_level
operator|++
expr_stmt|;
name|func
operator|=
name|otvalid
operator|->
name|func
index|[
name|otvalid
operator|->
name|nesting_level
index|]
expr_stmt|;
for|for
control|(
init|;
name|Count
operator|>
literal|0
condition|;
name|Count
operator|--
control|)
name|func
argument_list|(
name|table
operator|+
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
argument_list|,
name|otvalid
argument_list|)
expr_stmt|;
name|otvalid
operator|->
name|nesting_level
operator|--
expr_stmt|;
name|OTV_EXIT
expr_stmt|;
block|}
end_block
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|otv_u_C_x_Ox
name|otv_u_C_x_Ox
argument_list|(
argument|FT_Bytes       table
argument_list|,
argument|OTV_Validator  otvalid
argument_list|)
end_macro
begin_block
block|{
name|FT_Bytes
name|p
init|=
name|table
decl_stmt|;
name|FT_UInt
name|Count
decl_stmt|,
name|Coverage
decl_stmt|;
name|OTV_Validate_Func
name|func
decl_stmt|;
name|OTV_ENTER
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
comment|/* skip Format */
name|OTV_LIMIT_CHECK
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|Coverage
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|Count
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|OTV_TRACE
argument_list|(
operator|(
literal|" (Count = %d)\n"
operator|,
name|Count
operator|)
argument_list|)
expr_stmt|;
name|otv_Coverage_validate
argument_list|(
name|table
operator|+
name|Coverage
argument_list|,
name|otvalid
argument_list|,
operator|(
name|FT_Int
operator|)
name|Count
argument_list|)
expr_stmt|;
name|OTV_LIMIT_CHECK
argument_list|(
name|Count
operator|*
literal|2
argument_list|)
expr_stmt|;
name|otvalid
operator|->
name|nesting_level
operator|++
expr_stmt|;
name|func
operator|=
name|otvalid
operator|->
name|func
index|[
name|otvalid
operator|->
name|nesting_level
index|]
expr_stmt|;
for|for
control|(
init|;
name|Count
operator|>
literal|0
condition|;
name|Count
operator|--
control|)
name|func
argument_list|(
name|table
operator|+
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
argument_list|,
name|otvalid
argument_list|)
expr_stmt|;
name|otvalid
operator|->
name|nesting_level
operator|--
expr_stmt|;
name|OTV_EXIT
expr_stmt|;
block|}
end_block
begin_comment
comment|/* uses otvalid->extra1 (if> 0: array value limit) */
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|otv_x_ux
name|otv_x_ux
argument_list|(
argument|FT_Bytes       table
argument_list|,
argument|OTV_Validator  otvalid
argument_list|)
end_macro
begin_block
block|{
name|FT_Bytes
name|p
init|=
name|table
decl_stmt|;
name|FT_UInt
name|Count
decl_stmt|;
name|OTV_ENTER
expr_stmt|;
name|OTV_LIMIT_CHECK
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|Count
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|OTV_TRACE
argument_list|(
operator|(
literal|" (Count = %d)\n"
operator|,
name|Count
operator|)
argument_list|)
expr_stmt|;
name|OTV_LIMIT_CHECK
argument_list|(
name|Count
operator|*
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|otvalid
operator|->
name|extra1
condition|)
block|{
for|for
control|(
init|;
name|Count
operator|>
literal|0
condition|;
name|Count
operator|--
control|)
if|if
condition|(
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
operator|>=
name|otvalid
operator|->
name|extra1
condition|)
name|FT_INVALID_DATA
expr_stmt|;
block|}
name|OTV_EXIT
expr_stmt|;
block|}
end_block
begin_comment
comment|/* `ux' in the function's name is not really correct since only x-1 */
end_comment
begin_comment
comment|/* elements are tested                                              */
end_comment
begin_comment
comment|/* uses otvalid->extra1 (array value limit) */
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|otv_x_y_ux_sy
name|otv_x_y_ux_sy
argument_list|(
argument|FT_Bytes       table
argument_list|,
argument|OTV_Validator  otvalid
argument_list|)
end_macro
begin_block
block|{
name|FT_Bytes
name|p
init|=
name|table
decl_stmt|;
name|FT_UInt
name|Count1
decl_stmt|,
name|Count2
decl_stmt|;
name|OTV_ENTER
expr_stmt|;
name|OTV_LIMIT_CHECK
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|Count1
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|Count2
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|OTV_TRACE
argument_list|(
operator|(
literal|" (Count1 = %d)\n"
operator|,
name|Count1
operator|)
argument_list|)
expr_stmt|;
name|OTV_TRACE
argument_list|(
operator|(
literal|" (Count2 = %d)\n"
operator|,
name|Count2
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|Count1
operator|==
literal|0
condition|)
name|FT_INVALID_DATA
expr_stmt|;
name|OTV_LIMIT_CHECK
argument_list|(
operator|(
name|Count1
operator|-
literal|1
operator|)
operator|*
literal|2
operator|+
name|Count2
operator|*
literal|4
argument_list|)
expr_stmt|;
name|p
operator|+=
operator|(
name|Count1
operator|-
literal|1
operator|)
operator|*
literal|2
expr_stmt|;
for|for
control|(
init|;
name|Count2
operator|>
literal|0
condition|;
name|Count2
operator|--
control|)
block|{
if|if
condition|(
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
operator|>=
name|Count1
condition|)
name|FT_INVALID_DATA
expr_stmt|;
if|if
condition|(
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
operator|>=
name|otvalid
operator|->
name|extra1
condition|)
name|FT_INVALID_DATA
expr_stmt|;
block|}
name|OTV_EXIT
expr_stmt|;
block|}
end_block
begin_comment
comment|/* `uy' in the function's name is not really correct since only y-1 */
end_comment
begin_comment
comment|/* elements are tested                                              */
end_comment
begin_comment
comment|/* uses otvalid->extra1 (array value limit) */
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|otv_x_ux_y_uy_z_uz_p_sp
name|otv_x_ux_y_uy_z_uz_p_sp
argument_list|(
argument|FT_Bytes       table
argument_list|,
argument|OTV_Validator  otvalid
argument_list|)
end_macro
begin_block
block|{
name|FT_Bytes
name|p
init|=
name|table
decl_stmt|;
name|FT_UInt
name|BacktrackCount
decl_stmt|,
name|InputCount
decl_stmt|,
name|LookaheadCount
decl_stmt|;
name|FT_UInt
name|Count
decl_stmt|;
name|OTV_ENTER
expr_stmt|;
name|OTV_LIMIT_CHECK
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|BacktrackCount
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|OTV_TRACE
argument_list|(
operator|(
literal|" (BacktrackCount = %d)\n"
operator|,
name|BacktrackCount
operator|)
argument_list|)
expr_stmt|;
name|OTV_LIMIT_CHECK
argument_list|(
name|BacktrackCount
operator|*
literal|2
operator|+
literal|2
argument_list|)
expr_stmt|;
name|p
operator|+=
name|BacktrackCount
operator|*
literal|2
expr_stmt|;
name|InputCount
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|InputCount
operator|==
literal|0
condition|)
name|FT_INVALID_DATA
expr_stmt|;
name|OTV_TRACE
argument_list|(
operator|(
literal|" (InputCount = %d)\n"
operator|,
name|InputCount
operator|)
argument_list|)
expr_stmt|;
name|OTV_LIMIT_CHECK
argument_list|(
name|InputCount
operator|*
literal|2
argument_list|)
expr_stmt|;
name|p
operator|+=
operator|(
name|InputCount
operator|-
literal|1
operator|)
operator|*
literal|2
expr_stmt|;
name|LookaheadCount
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|OTV_TRACE
argument_list|(
operator|(
literal|" (LookaheadCount = %d)\n"
operator|,
name|LookaheadCount
operator|)
argument_list|)
expr_stmt|;
name|OTV_LIMIT_CHECK
argument_list|(
name|LookaheadCount
operator|*
literal|2
operator|+
literal|2
argument_list|)
expr_stmt|;
name|p
operator|+=
name|LookaheadCount
operator|*
literal|2
expr_stmt|;
name|Count
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|OTV_TRACE
argument_list|(
operator|(
literal|" (Count = %d)\n"
operator|,
name|Count
operator|)
argument_list|)
expr_stmt|;
name|OTV_LIMIT_CHECK
argument_list|(
name|Count
operator|*
literal|4
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|Count
operator|>
literal|0
condition|;
name|Count
operator|--
control|)
block|{
if|if
condition|(
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
operator|>=
name|InputCount
condition|)
name|FT_INVALID_DATA
expr_stmt|;
if|if
condition|(
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
operator|>=
name|otvalid
operator|->
name|extra1
condition|)
name|FT_INVALID_DATA
expr_stmt|;
block|}
name|OTV_EXIT
expr_stmt|;
block|}
end_block
begin_comment
comment|/* sets otvalid->extra1 (valid->lookup_count) */
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|otv_u_O_O_x_Onx
name|otv_u_O_O_x_Onx
argument_list|(
argument|FT_Bytes       table
argument_list|,
argument|OTV_Validator  otvalid
argument_list|)
end_macro
begin_block
block|{
name|FT_Bytes
name|p
init|=
name|table
decl_stmt|;
name|FT_UInt
name|Coverage
decl_stmt|,
name|ClassDef
decl_stmt|,
name|ClassSetCount
decl_stmt|;
name|OTV_Validate_Func
name|func
decl_stmt|;
name|OTV_ENTER
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
comment|/* skip Format */
name|OTV_LIMIT_CHECK
argument_list|(
literal|6
argument_list|)
expr_stmt|;
name|Coverage
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|ClassDef
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|ClassSetCount
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|OTV_TRACE
argument_list|(
operator|(
literal|" (ClassSetCount = %d)\n"
operator|,
name|ClassSetCount
operator|)
argument_list|)
expr_stmt|;
name|otv_Coverage_validate
argument_list|(
name|table
operator|+
name|Coverage
argument_list|,
name|otvalid
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|otv_ClassDef_validate
argument_list|(
name|table
operator|+
name|ClassDef
argument_list|,
name|otvalid
argument_list|)
expr_stmt|;
name|OTV_LIMIT_CHECK
argument_list|(
name|ClassSetCount
operator|*
literal|2
argument_list|)
expr_stmt|;
name|otvalid
operator|->
name|nesting_level
operator|++
expr_stmt|;
name|func
operator|=
name|otvalid
operator|->
name|func
index|[
name|otvalid
operator|->
name|nesting_level
index|]
expr_stmt|;
name|otvalid
operator|->
name|extra1
operator|=
name|otvalid
operator|->
name|lookup_count
expr_stmt|;
for|for
control|(
init|;
name|ClassSetCount
operator|>
literal|0
condition|;
name|ClassSetCount
operator|--
control|)
block|{
name|FT_UInt
name|offset
init|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|offset
condition|)
name|func
argument_list|(
name|table
operator|+
name|offset
argument_list|,
name|otvalid
argument_list|)
expr_stmt|;
block|}
name|otvalid
operator|->
name|nesting_level
operator|--
expr_stmt|;
name|OTV_EXIT
expr_stmt|;
block|}
end_block
begin_comment
comment|/* uses otvalid->lookup_count */
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|otv_u_x_y_Ox_sy
name|otv_u_x_y_Ox_sy
argument_list|(
argument|FT_Bytes       table
argument_list|,
argument|OTV_Validator  otvalid
argument_list|)
end_macro
begin_block
block|{
name|FT_Bytes
name|p
init|=
name|table
decl_stmt|;
name|FT_UInt
name|GlyphCount
decl_stmt|,
name|Count
decl_stmt|,
name|count1
decl_stmt|;
name|OTV_ENTER
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
comment|/* skip Format */
name|OTV_LIMIT_CHECK
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|GlyphCount
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|Count
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|OTV_TRACE
argument_list|(
operator|(
literal|" (GlyphCount = %d)\n"
operator|,
name|GlyphCount
operator|)
argument_list|)
expr_stmt|;
name|OTV_TRACE
argument_list|(
operator|(
literal|" (Count = %d)\n"
operator|,
name|Count
operator|)
argument_list|)
expr_stmt|;
name|OTV_LIMIT_CHECK
argument_list|(
name|GlyphCount
operator|*
literal|2
operator|+
name|Count
operator|*
literal|4
argument_list|)
expr_stmt|;
for|for
control|(
name|count1
operator|=
name|GlyphCount
init|;
name|count1
operator|>
literal|0
condition|;
name|count1
operator|--
control|)
name|otv_Coverage_validate
argument_list|(
name|table
operator|+
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
argument_list|,
name|otvalid
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|Count
operator|>
literal|0
condition|;
name|Count
operator|--
control|)
block|{
if|if
condition|(
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
operator|>=
name|GlyphCount
condition|)
name|FT_INVALID_DATA
expr_stmt|;
if|if
condition|(
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
operator|>=
name|otvalid
operator|->
name|lookup_count
condition|)
name|FT_INVALID_DATA
expr_stmt|;
block|}
name|OTV_EXIT
expr_stmt|;
block|}
end_block
begin_comment
comment|/* sets otvalid->extra1 (valid->lookup_count)    */
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|otv_u_O_O_O_O_x_Onx
name|otv_u_O_O_O_O_x_Onx
argument_list|(
argument|FT_Bytes       table
argument_list|,
argument|OTV_Validator  otvalid
argument_list|)
end_macro
begin_block
block|{
name|FT_Bytes
name|p
init|=
name|table
decl_stmt|;
name|FT_UInt
name|Coverage
decl_stmt|;
name|FT_UInt
name|BacktrackClassDef
decl_stmt|,
name|InputClassDef
decl_stmt|,
name|LookaheadClassDef
decl_stmt|;
name|FT_UInt
name|ChainClassSetCount
decl_stmt|;
name|OTV_Validate_Func
name|func
decl_stmt|;
name|OTV_ENTER
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
comment|/* skip Format */
name|OTV_LIMIT_CHECK
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|Coverage
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|BacktrackClassDef
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|InputClassDef
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|LookaheadClassDef
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|ChainClassSetCount
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|OTV_TRACE
argument_list|(
operator|(
literal|" (ChainClassSetCount = %d)\n"
operator|,
name|ChainClassSetCount
operator|)
argument_list|)
expr_stmt|;
name|otv_Coverage_validate
argument_list|(
name|table
operator|+
name|Coverage
argument_list|,
name|otvalid
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|otv_ClassDef_validate
argument_list|(
name|table
operator|+
name|BacktrackClassDef
argument_list|,
name|otvalid
argument_list|)
expr_stmt|;
name|otv_ClassDef_validate
argument_list|(
name|table
operator|+
name|InputClassDef
argument_list|,
name|otvalid
argument_list|)
expr_stmt|;
name|otv_ClassDef_validate
argument_list|(
name|table
operator|+
name|LookaheadClassDef
argument_list|,
name|otvalid
argument_list|)
expr_stmt|;
name|OTV_LIMIT_CHECK
argument_list|(
name|ChainClassSetCount
operator|*
literal|2
argument_list|)
expr_stmt|;
name|otvalid
operator|->
name|nesting_level
operator|++
expr_stmt|;
name|func
operator|=
name|otvalid
operator|->
name|func
index|[
name|otvalid
operator|->
name|nesting_level
index|]
expr_stmt|;
name|otvalid
operator|->
name|extra1
operator|=
name|otvalid
operator|->
name|lookup_count
expr_stmt|;
for|for
control|(
init|;
name|ChainClassSetCount
operator|>
literal|0
condition|;
name|ChainClassSetCount
operator|--
control|)
block|{
name|FT_UInt
name|offset
init|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|offset
condition|)
name|func
argument_list|(
name|table
operator|+
name|offset
argument_list|,
name|otvalid
argument_list|)
expr_stmt|;
block|}
name|otvalid
operator|->
name|nesting_level
operator|--
expr_stmt|;
name|OTV_EXIT
expr_stmt|;
block|}
end_block
begin_comment
comment|/* uses otvalid->lookup_count */
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|otv_u_x_Ox_y_Oy_z_Oz_p_sp
name|otv_u_x_Ox_y_Oy_z_Oz_p_sp
argument_list|(
argument|FT_Bytes       table
argument_list|,
argument|OTV_Validator  otvalid
argument_list|)
end_macro
begin_block
block|{
name|FT_Bytes
name|p
init|=
name|table
decl_stmt|;
name|FT_UInt
name|BacktrackGlyphCount
decl_stmt|,
name|InputGlyphCount
decl_stmt|,
name|LookaheadGlyphCount
decl_stmt|;
name|FT_UInt
name|count1
decl_stmt|,
name|count2
decl_stmt|;
name|OTV_ENTER
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
comment|/* skip Format */
name|OTV_LIMIT_CHECK
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|BacktrackGlyphCount
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|OTV_TRACE
argument_list|(
operator|(
literal|" (BacktrackGlyphCount = %d)\n"
operator|,
name|BacktrackGlyphCount
operator|)
argument_list|)
expr_stmt|;
name|OTV_LIMIT_CHECK
argument_list|(
name|BacktrackGlyphCount
operator|*
literal|2
operator|+
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|BacktrackGlyphCount
operator|>
literal|0
condition|;
name|BacktrackGlyphCount
operator|--
control|)
name|otv_Coverage_validate
argument_list|(
name|table
operator|+
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
argument_list|,
name|otvalid
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|InputGlyphCount
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|OTV_TRACE
argument_list|(
operator|(
literal|" (InputGlyphCount = %d)\n"
operator|,
name|InputGlyphCount
operator|)
argument_list|)
expr_stmt|;
name|OTV_LIMIT_CHECK
argument_list|(
name|InputGlyphCount
operator|*
literal|2
operator|+
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|count1
operator|=
name|InputGlyphCount
init|;
name|count1
operator|>
literal|0
condition|;
name|count1
operator|--
control|)
name|otv_Coverage_validate
argument_list|(
name|table
operator|+
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
argument_list|,
name|otvalid
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|LookaheadGlyphCount
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|OTV_TRACE
argument_list|(
operator|(
literal|" (LookaheadGlyphCount = %d)\n"
operator|,
name|LookaheadGlyphCount
operator|)
argument_list|)
expr_stmt|;
name|OTV_LIMIT_CHECK
argument_list|(
name|LookaheadGlyphCount
operator|*
literal|2
operator|+
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|LookaheadGlyphCount
operator|>
literal|0
condition|;
name|LookaheadGlyphCount
operator|--
control|)
name|otv_Coverage_validate
argument_list|(
name|table
operator|+
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
argument_list|,
name|otvalid
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|count2
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|OTV_TRACE
argument_list|(
operator|(
literal|" (Count = %d)\n"
operator|,
name|count2
operator|)
argument_list|)
expr_stmt|;
name|OTV_LIMIT_CHECK
argument_list|(
name|count2
operator|*
literal|4
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|count2
operator|>
literal|0
condition|;
name|count2
operator|--
control|)
block|{
if|if
condition|(
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
operator|>=
name|InputGlyphCount
condition|)
name|FT_INVALID_DATA
expr_stmt|;
if|if
condition|(
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
operator|>=
name|otvalid
operator|->
name|lookup_count
condition|)
name|FT_INVALID_DATA
expr_stmt|;
block|}
name|OTV_EXIT
expr_stmt|;
block|}
end_block
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_UInt
argument_list|)
end_macro
begin_macro
name|otv_GSUBGPOS_get_Lookup_count
argument_list|(
argument|FT_Bytes  table
argument_list|)
end_macro
begin_block
block|{
name|FT_Bytes
name|p
init|=
name|table
operator|+
literal|8
decl_stmt|;
return|return
name|otv_LookupList_get_count
argument_list|(
name|table
operator|+
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
argument_list|)
return|;
block|}
end_block
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_UInt
argument_list|)
end_macro
begin_macro
name|otv_GSUBGPOS_have_MarkAttachmentType_flag
argument_list|(
argument|FT_Bytes  table
argument_list|)
end_macro
begin_block
block|{
name|FT_Bytes
name|p
decl_stmt|,
name|lookup
decl_stmt|;
name|FT_UInt
name|count
decl_stmt|;
if|if
condition|(
operator|!
name|table
condition|)
return|return
literal|0
return|;
comment|/* LookupList */
name|p
operator|=
name|table
operator|+
literal|8
expr_stmt|;
name|table
operator|+=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* LookupCount */
name|p
operator|=
name|table
expr_stmt|;
name|count
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
control|)
block|{
name|FT_Bytes
name|oldp
decl_stmt|;
comment|/* Lookup */
name|lookup
operator|=
name|table
operator|+
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|oldp
operator|=
name|p
expr_stmt|;
comment|/* LookupFlag */
name|p
operator|=
name|lookup
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
operator|&
literal|0xFF00U
condition|)
return|return
literal|1
return|;
name|p
operator|=
name|oldp
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_block
begin_comment
comment|/* END */
end_comment
end_unit
