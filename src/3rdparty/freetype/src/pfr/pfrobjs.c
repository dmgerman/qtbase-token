begin_unit
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  pfrobjs.c                                                              */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*    FreeType PFR object methods (body).                                  */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  Copyright 2002-2008, 2010-2011, 2013, 2014 by                          */
end_comment
begin_comment
comment|/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  This file is part of the FreeType project, and may only be used,       */
end_comment
begin_comment
comment|/*  modified, and distributed under the terms of the FreeType project      */
end_comment
begin_comment
comment|/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
end_comment
begin_comment
comment|/*  this file you indicate that you have read the license and              */
end_comment
begin_comment
comment|/*  understand and accept it fully.                                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"pfrobjs.h"
end_include
begin_include
include|#
directive|include
file|"pfrload.h"
end_include
begin_include
include|#
directive|include
file|"pfrgload.h"
end_include
begin_include
include|#
directive|include
file|"pfrcmap.h"
end_include
begin_include
include|#
directive|include
file|"pfrsbit.h"
end_include
begin_include
include|#
directive|include
include|FT_OUTLINE_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_DEBUG_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_CALC_H
end_include
begin_include
include|#
directive|include
include|FT_TRUETYPE_IDS_H
end_include
begin_include
include|#
directive|include
file|"pfrerror.h"
end_include
begin_undef
DECL|macro|FT_COMPONENT
undef|#
directive|undef
name|FT_COMPONENT
end_undef
begin_define
DECL|macro|FT_COMPONENT
define|#
directive|define
name|FT_COMPONENT
value|trace_pfr
end_define
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****                     FACE OBJECT METHODS                       *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|pfr_face_done
name|pfr_face_done
argument_list|(
argument|FT_Face  pfrface
argument_list|)
end_macro
begin_comment
DECL|function|pfr_face_done
comment|/* PFR_Face */
end_comment
begin_block
block|{
name|PFR_Face
name|face
init|=
operator|(
name|PFR_Face
operator|)
name|pfrface
decl_stmt|;
name|FT_Memory
name|memory
decl_stmt|;
if|if
condition|(
operator|!
name|face
condition|)
return|return;
name|memory
operator|=
name|pfrface
operator|->
name|driver
operator|->
name|root
operator|.
name|memory
expr_stmt|;
comment|/* we don't want dangling pointers */
name|pfrface
operator|->
name|family_name
operator|=
name|NULL
expr_stmt|;
name|pfrface
operator|->
name|style_name
operator|=
name|NULL
expr_stmt|;
comment|/* finalize the physical font record */
name|pfr_phy_font_done
argument_list|(
operator|&
name|face
operator|->
name|phy_font
argument_list|,
name|FT_FACE_MEMORY
argument_list|(
name|face
argument_list|)
argument_list|)
expr_stmt|;
comment|/* no need to finalize the logical font or the header */
name|FT_FREE
argument_list|(
name|pfrface
operator|->
name|available_sizes
argument_list|)
expr_stmt|;
block|}
end_block
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|pfr_face_init
argument_list|(
argument|FT_Stream      stream
argument_list|,
argument|FT_Face        pfrface
argument_list|,
argument|FT_Int         face_index
argument_list|,
argument|FT_Int         num_params
argument_list|,
argument|FT_Parameter*  params
argument_list|)
end_macro
begin_block
block|{
name|PFR_Face
name|face
init|=
operator|(
name|PFR_Face
operator|)
name|pfrface
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|FT_UNUSED
argument_list|(
name|num_params
argument_list|)
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|params
argument_list|)
expr_stmt|;
name|FT_TRACE2
argument_list|(
operator|(
literal|"PFR driver\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* load the header and check it */
name|error
operator|=
name|pfr_header_load
argument_list|(
operator|&
name|face
operator|->
name|header
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
if|if
condition|(
operator|!
name|pfr_header_check
argument_list|(
operator|&
name|face
operator|->
name|header
argument_list|)
condition|)
block|{
name|FT_TRACE2
argument_list|(
operator|(
literal|"  not a PFR font\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|FT_THROW
argument_list|(
name|Unknown_File_Format
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* check face index */
block|{
name|FT_UInt
name|num_faces
decl_stmt|;
name|error
operator|=
name|pfr_log_font_count
argument_list|(
name|stream
argument_list|,
name|face
operator|->
name|header
operator|.
name|log_dir_offset
argument_list|,
operator|&
name|num_faces
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|pfrface
operator|->
name|num_faces
operator|=
name|num_faces
expr_stmt|;
block|}
if|if
condition|(
name|face_index
operator|<
literal|0
condition|)
goto|goto
name|Exit
goto|;
if|if
condition|(
name|face_index
operator|>=
name|pfrface
operator|->
name|num_faces
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"pfr_face_init: invalid face index\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Argument
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* load the face */
name|error
operator|=
name|pfr_log_font_load
argument_list|(
operator|&
name|face
operator|->
name|log_font
argument_list|,
name|stream
argument_list|,
name|face_index
argument_list|,
name|face
operator|->
name|header
operator|.
name|log_dir_offset
argument_list|,
name|FT_BOOL
argument_list|(
name|face
operator|->
name|header
operator|.
name|phy_font_max_size_high
operator|!=
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
comment|/* now load the physical font descriptor */
name|error
operator|=
name|pfr_phy_font_load
argument_list|(
operator|&
name|face
operator|->
name|phy_font
argument_list|,
name|stream
argument_list|,
name|face
operator|->
name|log_font
operator|.
name|phys_offset
argument_list|,
name|face
operator|->
name|log_font
operator|.
name|phys_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
comment|/* now set up all root face fields */
block|{
name|PFR_PhyFont
name|phy_font
init|=
operator|&
name|face
operator|->
name|phy_font
decl_stmt|;
name|pfrface
operator|->
name|face_index
operator|=
name|face_index
expr_stmt|;
name|pfrface
operator|->
name|num_glyphs
operator|=
name|phy_font
operator|->
name|num_chars
operator|+
literal|1
expr_stmt|;
name|pfrface
operator|->
name|face_flags
operator||=
name|FT_FACE_FLAG_SCALABLE
expr_stmt|;
comment|/* if all characters point to the same gps_offset 0, we */
comment|/* assume that the font only contains bitmaps           */
block|{
name|FT_UInt
name|nn
decl_stmt|;
for|for
control|(
name|nn
operator|=
literal|0
init|;
name|nn
operator|<
name|phy_font
operator|->
name|num_chars
condition|;
name|nn
operator|++
control|)
if|if
condition|(
name|phy_font
operator|->
name|chars
index|[
name|nn
index|]
operator|.
name|gps_offset
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|nn
operator|==
name|phy_font
operator|->
name|num_chars
condition|)
block|{
if|if
condition|(
name|phy_font
operator|->
name|num_strikes
operator|>
literal|0
condition|)
name|pfrface
operator|->
name|face_flags
operator|=
literal|0
expr_stmt|;
comment|/* not scalable */
else|else
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"pfr_face_init: font doesn't contain glyphs\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_File_Format
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|phy_font
operator|->
name|flags
operator|&
name|PFR_PHY_PROPORTIONAL
operator|)
operator|==
literal|0
condition|)
name|pfrface
operator|->
name|face_flags
operator||=
name|FT_FACE_FLAG_FIXED_WIDTH
expr_stmt|;
if|if
condition|(
name|phy_font
operator|->
name|flags
operator|&
name|PFR_PHY_VERTICAL
condition|)
name|pfrface
operator|->
name|face_flags
operator||=
name|FT_FACE_FLAG_VERTICAL
expr_stmt|;
else|else
name|pfrface
operator|->
name|face_flags
operator||=
name|FT_FACE_FLAG_HORIZONTAL
expr_stmt|;
if|if
condition|(
name|phy_font
operator|->
name|num_strikes
operator|>
literal|0
condition|)
name|pfrface
operator|->
name|face_flags
operator||=
name|FT_FACE_FLAG_FIXED_SIZES
expr_stmt|;
if|if
condition|(
name|phy_font
operator|->
name|num_kern_pairs
operator|>
literal|0
condition|)
name|pfrface
operator|->
name|face_flags
operator||=
name|FT_FACE_FLAG_KERNING
expr_stmt|;
comment|/* If no family name was found in the "undocumented" auxiliary        * data, use the font ID instead.  This sucks but is better than        * nothing.        */
name|pfrface
operator|->
name|family_name
operator|=
name|phy_font
operator|->
name|family_name
expr_stmt|;
if|if
condition|(
name|pfrface
operator|->
name|family_name
operator|==
name|NULL
condition|)
name|pfrface
operator|->
name|family_name
operator|=
name|phy_font
operator|->
name|font_id
expr_stmt|;
comment|/* note that the style name can be NULL in certain PFR fonts,        * probably meaning "Regular"        */
name|pfrface
operator|->
name|style_name
operator|=
name|phy_font
operator|->
name|style_name
expr_stmt|;
name|pfrface
operator|->
name|num_fixed_sizes
operator|=
literal|0
expr_stmt|;
name|pfrface
operator|->
name|available_sizes
operator|=
literal|0
expr_stmt|;
name|pfrface
operator|->
name|bbox
operator|=
name|phy_font
operator|->
name|bbox
expr_stmt|;
name|pfrface
operator|->
name|units_per_EM
operator|=
operator|(
name|FT_UShort
operator|)
name|phy_font
operator|->
name|outline_resolution
expr_stmt|;
name|pfrface
operator|->
name|ascender
operator|=
operator|(
name|FT_Short
operator|)
name|phy_font
operator|->
name|bbox
operator|.
name|yMax
expr_stmt|;
name|pfrface
operator|->
name|descender
operator|=
operator|(
name|FT_Short
operator|)
name|phy_font
operator|->
name|bbox
operator|.
name|yMin
expr_stmt|;
name|pfrface
operator|->
name|height
operator|=
call|(
name|FT_Short
call|)
argument_list|(
operator|(
name|pfrface
operator|->
name|units_per_EM
operator|*
literal|12
operator|)
operator|/
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfrface
operator|->
name|height
operator|<
name|pfrface
operator|->
name|ascender
operator|-
name|pfrface
operator|->
name|descender
condition|)
name|pfrface
operator|->
name|height
operator|=
call|(
name|FT_Short
call|)
argument_list|(
name|pfrface
operator|->
name|ascender
operator|-
name|pfrface
operator|->
name|descender
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy_font
operator|->
name|num_strikes
operator|>
literal|0
condition|)
block|{
name|FT_UInt
name|n
decl_stmt|,
name|count
init|=
name|phy_font
operator|->
name|num_strikes
decl_stmt|;
name|FT_Bitmap_Size
modifier|*
name|size
decl_stmt|;
name|PFR_Strike
name|strike
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|pfrface
operator|->
name|stream
operator|->
name|memory
decl_stmt|;
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|pfrface
operator|->
name|available_sizes
argument_list|,
name|count
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|size
operator|=
name|pfrface
operator|->
name|available_sizes
expr_stmt|;
name|strike
operator|=
name|phy_font
operator|->
name|strikes
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
operator|,
name|size
operator|++
operator|,
name|strike
operator|++
control|)
block|{
name|size
operator|->
name|height
operator|=
operator|(
name|FT_UShort
operator|)
name|strike
operator|->
name|y_ppm
expr_stmt|;
name|size
operator|->
name|width
operator|=
operator|(
name|FT_UShort
operator|)
name|strike
operator|->
name|x_ppm
expr_stmt|;
name|size
operator|->
name|size
operator|=
name|strike
operator|->
name|y_ppm
operator|<<
literal|6
expr_stmt|;
name|size
operator|->
name|x_ppem
operator|=
name|strike
operator|->
name|x_ppm
operator|<<
literal|6
expr_stmt|;
name|size
operator|->
name|y_ppem
operator|=
name|strike
operator|->
name|y_ppm
operator|<<
literal|6
expr_stmt|;
block|}
name|pfrface
operator|->
name|num_fixed_sizes
operator|=
name|count
expr_stmt|;
block|}
comment|/* now compute maximum advance width */
if|if
condition|(
operator|(
name|phy_font
operator|->
name|flags
operator|&
name|PFR_PHY_PROPORTIONAL
operator|)
operator|==
literal|0
condition|)
name|pfrface
operator|->
name|max_advance_width
operator|=
operator|(
name|FT_Short
operator|)
name|phy_font
operator|->
name|standard_advance
expr_stmt|;
else|else
block|{
name|FT_Int
name|max
init|=
literal|0
decl_stmt|;
name|FT_UInt
name|count
init|=
name|phy_font
operator|->
name|num_chars
decl_stmt|;
name|PFR_Char
name|gchar
init|=
name|phy_font
operator|->
name|chars
decl_stmt|;
for|for
control|(
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
operator|,
name|gchar
operator|++
control|)
block|{
if|if
condition|(
name|max
operator|<
name|gchar
operator|->
name|advance
condition|)
name|max
operator|=
name|gchar
operator|->
name|advance
expr_stmt|;
block|}
name|pfrface
operator|->
name|max_advance_width
operator|=
operator|(
name|FT_Short
operator|)
name|max
expr_stmt|;
block|}
name|pfrface
operator|->
name|max_advance_height
operator|=
name|pfrface
operator|->
name|height
expr_stmt|;
name|pfrface
operator|->
name|underline_position
operator|=
call|(
name|FT_Short
call|)
argument_list|(
operator|-
name|pfrface
operator|->
name|units_per_EM
operator|/
literal|10
argument_list|)
expr_stmt|;
name|pfrface
operator|->
name|underline_thickness
operator|=
call|(
name|FT_Short
call|)
argument_list|(
name|pfrface
operator|->
name|units_per_EM
operator|/
literal|30
argument_list|)
expr_stmt|;
comment|/* create charmap */
block|{
name|FT_CharMapRec
name|charmap
decl_stmt|;
name|charmap
operator|.
name|face
operator|=
name|pfrface
expr_stmt|;
name|charmap
operator|.
name|platform_id
operator|=
name|TT_PLATFORM_MICROSOFT
expr_stmt|;
name|charmap
operator|.
name|encoding_id
operator|=
name|TT_MS_ID_UNICODE_CS
expr_stmt|;
name|charmap
operator|.
name|encoding
operator|=
name|FT_ENCODING_UNICODE
expr_stmt|;
name|error
operator|=
name|FT_CMap_New
argument_list|(
operator|&
name|pfr_cmap_class_rec
argument_list|,
name|NULL
argument_list|,
operator|&
name|charmap
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Select default charmap */
block|if ( pfrface->num_charmaps )           pfrface->charmap = pfrface->charmaps[0];
endif|#
directive|endif
block|}
comment|/* check whether we've loaded any kerning pairs */
if|if
condition|(
name|phy_font
operator|->
name|num_kern_pairs
condition|)
name|pfrface
operator|->
name|face_flags
operator||=
name|FT_FACE_FLAG_KERNING
expr_stmt|;
block|}
name|Exit
label|:
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****                    SLOT OBJECT METHOD                         *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|pfr_slot_init
argument_list|(
argument|FT_GlyphSlot  pfrslot
argument_list|)
end_macro
begin_comment
comment|/* PFR_Slot */
end_comment
begin_block
block|{
name|PFR_Slot
name|slot
init|=
operator|(
name|PFR_Slot
operator|)
name|pfrslot
decl_stmt|;
name|FT_GlyphLoader
name|loader
init|=
name|pfrslot
operator|->
name|internal
operator|->
name|loader
decl_stmt|;
name|pfr_glyph_init
argument_list|(
operator|&
name|slot
operator|->
name|glyph
argument_list|,
name|loader
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|pfr_slot_done
name|pfr_slot_done
argument_list|(
argument|FT_GlyphSlot  pfrslot
argument_list|)
end_macro
begin_comment
DECL|function|pfr_slot_done
comment|/* PFR_Slot */
end_comment
begin_block
block|{
name|PFR_Slot
name|slot
init|=
operator|(
name|PFR_Slot
operator|)
name|pfrslot
decl_stmt|;
name|pfr_glyph_done
argument_list|(
operator|&
name|slot
operator|->
name|glyph
argument_list|)
expr_stmt|;
block|}
end_block
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|pfr_slot_load
argument_list|(
argument|FT_GlyphSlot  pfrslot
argument_list|,
comment|/* PFR_Slot */
argument|FT_Size       pfrsize
argument_list|,
comment|/* PFR_Size */
argument|FT_UInt       gindex
argument_list|,
argument|FT_Int32      load_flags
argument_list|)
end_macro
begin_block
block|{
name|PFR_Slot
name|slot
init|=
operator|(
name|PFR_Slot
operator|)
name|pfrslot
decl_stmt|;
name|PFR_Size
name|size
init|=
operator|(
name|PFR_Size
operator|)
name|pfrsize
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|PFR_Face
name|face
init|=
operator|(
name|PFR_Face
operator|)
name|pfrslot
operator|->
name|face
decl_stmt|;
name|PFR_Char
name|gchar
decl_stmt|;
name|FT_Outline
modifier|*
name|outline
init|=
operator|&
name|pfrslot
operator|->
name|outline
decl_stmt|;
name|FT_ULong
name|gps_offset
decl_stmt|;
name|FT_TRACE1
argument_list|(
operator|(
literal|"pfr_slot_load: glyph index %d\n"
operator|,
name|gindex
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|gindex
operator|>
literal|0
condition|)
name|gindex
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|face
operator|||
name|gindex
operator|>=
name|face
operator|->
name|phy_font
operator|.
name|num_chars
condition|)
block|{
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Argument
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* try to load an embedded bitmap */
if|if
condition|(
operator|(
name|load_flags
operator|&
operator|(
name|FT_LOAD_NO_SCALE
operator||
name|FT_LOAD_NO_BITMAP
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|pfr_slot_load_bitmap
argument_list|(
name|slot
argument_list|,
name|size
argument_list|,
name|gindex
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|load_flags
operator|&
name|FT_LOAD_SBITS_ONLY
condition|)
block|{
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Argument
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|gchar
operator|=
name|face
operator|->
name|phy_font
operator|.
name|chars
operator|+
name|gindex
expr_stmt|;
name|pfrslot
operator|->
name|format
operator|=
name|FT_GLYPH_FORMAT_OUTLINE
expr_stmt|;
name|outline
operator|->
name|n_points
operator|=
literal|0
expr_stmt|;
name|outline
operator|->
name|n_contours
operator|=
literal|0
expr_stmt|;
name|gps_offset
operator|=
name|face
operator|->
name|header
operator|.
name|gps_section_offset
expr_stmt|;
comment|/* load the glyph outline (FT_LOAD_NO_RECURSE isn't supported) */
name|error
operator|=
name|pfr_glyph_load
argument_list|(
operator|&
name|slot
operator|->
name|glyph
argument_list|,
name|face
operator|->
name|root
operator|.
name|stream
argument_list|,
name|gps_offset
argument_list|,
name|gchar
operator|->
name|gps_offset
argument_list|,
name|gchar
operator|->
name|gps_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|FT_BBox
name|cbox
decl_stmt|;
name|FT_Glyph_Metrics
modifier|*
name|metrics
init|=
operator|&
name|pfrslot
operator|->
name|metrics
decl_stmt|;
name|FT_Pos
name|advance
decl_stmt|;
name|FT_Int
name|em_metrics
decl_stmt|,
name|em_outline
decl_stmt|;
name|FT_Bool
name|scaling
decl_stmt|;
name|scaling
operator|=
name|FT_BOOL
argument_list|(
operator|(
name|load_flags
operator|&
name|FT_LOAD_NO_SCALE
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* copy outline data */
operator|*
name|outline
operator|=
name|slot
operator|->
name|glyph
operator|.
name|loader
operator|->
name|base
operator|.
name|outline
expr_stmt|;
name|outline
operator|->
name|flags
operator|&=
operator|~
name|FT_OUTLINE_OWNER
expr_stmt|;
name|outline
operator|->
name|flags
operator||=
name|FT_OUTLINE_REVERSE_FILL
expr_stmt|;
if|if
condition|(
name|size
operator|&&
name|pfrsize
operator|->
name|metrics
operator|.
name|y_ppem
operator|<
literal|24
condition|)
name|outline
operator|->
name|flags
operator||=
name|FT_OUTLINE_HIGH_PRECISION
expr_stmt|;
comment|/* compute the advance vector */
name|metrics
operator|->
name|horiAdvance
operator|=
literal|0
expr_stmt|;
name|metrics
operator|->
name|vertAdvance
operator|=
literal|0
expr_stmt|;
name|advance
operator|=
name|gchar
operator|->
name|advance
expr_stmt|;
name|em_metrics
operator|=
name|face
operator|->
name|phy_font
operator|.
name|metrics_resolution
expr_stmt|;
name|em_outline
operator|=
name|face
operator|->
name|phy_font
operator|.
name|outline_resolution
expr_stmt|;
if|if
condition|(
name|em_metrics
operator|!=
name|em_outline
condition|)
name|advance
operator|=
name|FT_MulDiv
argument_list|(
name|advance
argument_list|,
name|em_outline
argument_list|,
name|em_metrics
argument_list|)
expr_stmt|;
if|if
condition|(
name|face
operator|->
name|phy_font
operator|.
name|flags
operator|&
name|PFR_PHY_VERTICAL
condition|)
name|metrics
operator|->
name|vertAdvance
operator|=
name|advance
expr_stmt|;
else|else
name|metrics
operator|->
name|horiAdvance
operator|=
name|advance
expr_stmt|;
name|pfrslot
operator|->
name|linearHoriAdvance
operator|=
name|metrics
operator|->
name|horiAdvance
expr_stmt|;
name|pfrslot
operator|->
name|linearVertAdvance
operator|=
name|metrics
operator|->
name|vertAdvance
expr_stmt|;
comment|/* make-up vertical metrics(?) */
name|metrics
operator|->
name|vertBearingX
operator|=
literal|0
expr_stmt|;
name|metrics
operator|->
name|vertBearingY
operator|=
literal|0
expr_stmt|;
if|#
directive|if
literal|0
comment|/* some fonts seem to be broken here! */
comment|/* Apply the font matrix, if any.                 */
comment|/* TODO: Test existing fonts with unusual matrix  */
comment|/* whether we have to adjust Units per EM.        */
block|{         FT_Matrix font_matrix;           font_matrix.xx = face->log_font.matrix[0]<< 8;         font_matrix.yx = face->log_font.matrix[1]<< 8;         font_matrix.xy = face->log_font.matrix[2]<< 8;         font_matrix.yy = face->log_font.matrix[3]<< 8;          FT_Outline_Transform( outline,&font_matrix );       }
endif|#
directive|endif
comment|/* scale when needed */
if|if
condition|(
name|scaling
condition|)
block|{
name|FT_Int
name|n
decl_stmt|;
name|FT_Fixed
name|x_scale
init|=
name|pfrsize
operator|->
name|metrics
operator|.
name|x_scale
decl_stmt|;
name|FT_Fixed
name|y_scale
init|=
name|pfrsize
operator|->
name|metrics
operator|.
name|y_scale
decl_stmt|;
name|FT_Vector
modifier|*
name|vec
init|=
name|outline
operator|->
name|points
decl_stmt|;
comment|/* scale outline points */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|outline
operator|->
name|n_points
condition|;
name|n
operator|++
operator|,
name|vec
operator|++
control|)
block|{
name|vec
operator|->
name|x
operator|=
name|FT_MulFix
argument_list|(
name|vec
operator|->
name|x
argument_list|,
name|x_scale
argument_list|)
expr_stmt|;
name|vec
operator|->
name|y
operator|=
name|FT_MulFix
argument_list|(
name|vec
operator|->
name|y
argument_list|,
name|y_scale
argument_list|)
expr_stmt|;
block|}
comment|/* scale the advance */
name|metrics
operator|->
name|horiAdvance
operator|=
name|FT_MulFix
argument_list|(
name|metrics
operator|->
name|horiAdvance
argument_list|,
name|x_scale
argument_list|)
expr_stmt|;
name|metrics
operator|->
name|vertAdvance
operator|=
name|FT_MulFix
argument_list|(
name|metrics
operator|->
name|vertAdvance
argument_list|,
name|y_scale
argument_list|)
expr_stmt|;
block|}
comment|/* compute the rest of the metrics */
name|FT_Outline_Get_CBox
argument_list|(
name|outline
argument_list|,
operator|&
name|cbox
argument_list|)
expr_stmt|;
name|metrics
operator|->
name|width
operator|=
name|cbox
operator|.
name|xMax
operator|-
name|cbox
operator|.
name|xMin
expr_stmt|;
name|metrics
operator|->
name|height
operator|=
name|cbox
operator|.
name|yMax
operator|-
name|cbox
operator|.
name|yMin
expr_stmt|;
name|metrics
operator|->
name|horiBearingX
operator|=
name|cbox
operator|.
name|xMin
expr_stmt|;
name|metrics
operator|->
name|horiBearingY
operator|=
name|cbox
operator|.
name|yMax
operator|-
name|metrics
operator|->
name|height
expr_stmt|;
block|}
name|Exit
label|:
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****                      KERNING METHOD                           *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|pfr_face_get_kerning
argument_list|(
argument|FT_Face     pfrface
argument_list|,
comment|/* PFR_Face */
argument|FT_UInt     glyph1
argument_list|,
argument|FT_UInt     glyph2
argument_list|,
argument|FT_Vector*  kerning
argument_list|)
end_macro
begin_block
block|{
name|PFR_Face
name|face
init|=
operator|(
name|PFR_Face
operator|)
name|pfrface
decl_stmt|;
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
name|PFR_PhyFont
name|phy_font
init|=
operator|&
name|face
operator|->
name|phy_font
decl_stmt|;
name|FT_UInt32
name|code1
decl_stmt|,
name|code2
decl_stmt|,
name|pair
decl_stmt|;
name|kerning
operator|->
name|x
operator|=
literal|0
expr_stmt|;
name|kerning
operator|->
name|y
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|glyph1
operator|>
literal|0
condition|)
name|glyph1
operator|--
expr_stmt|;
if|if
condition|(
name|glyph2
operator|>
literal|0
condition|)
name|glyph2
operator|--
expr_stmt|;
comment|/* convert glyph indices to character codes */
if|if
condition|(
name|glyph1
operator|>
name|phy_font
operator|->
name|num_chars
operator|||
name|glyph2
operator|>
name|phy_font
operator|->
name|num_chars
condition|)
goto|goto
name|Exit
goto|;
name|code1
operator|=
name|phy_font
operator|->
name|chars
index|[
name|glyph1
index|]
operator|.
name|char_code
expr_stmt|;
name|code2
operator|=
name|phy_font
operator|->
name|chars
index|[
name|glyph2
index|]
operator|.
name|char_code
expr_stmt|;
name|pair
operator|=
name|PFR_KERN_INDEX
argument_list|(
name|code1
argument_list|,
name|code2
argument_list|)
expr_stmt|;
comment|/* now search the list of kerning items */
block|{
name|PFR_KernItem
name|item
init|=
name|phy_font
operator|->
name|kern_items
decl_stmt|;
name|FT_Stream
name|stream
init|=
name|pfrface
operator|->
name|stream
decl_stmt|;
for|for
control|(
init|;
name|item
condition|;
name|item
operator|=
name|item
operator|->
name|next
control|)
block|{
if|if
condition|(
name|pair
operator|>=
name|item
operator|->
name|pair1
operator|&&
name|pair
operator|<=
name|item
operator|->
name|pair2
condition|)
goto|goto
name|FoundPair
goto|;
block|}
goto|goto
name|Exit
goto|;
name|FoundPair
label|:
comment|/* we found an item, now parse it and find the value if any */
if|if
condition|(
name|FT_STREAM_SEEK
argument_list|(
name|item
operator|->
name|offset
argument_list|)
operator|||
name|FT_FRAME_ENTER
argument_list|(
name|item
operator|->
name|pair_count
operator|*
name|item
operator|->
name|pair_size
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
block|{
name|FT_UInt
name|count
init|=
name|item
operator|->
name|pair_count
decl_stmt|;
name|FT_UInt
name|size
init|=
name|item
operator|->
name|pair_size
decl_stmt|;
name|FT_UInt
name|power
init|=
literal|1
operator|<<
name|FT_MSB
argument_list|(
name|count
argument_list|)
decl_stmt|;
name|FT_UInt
name|probe
init|=
name|power
operator|*
name|size
decl_stmt|;
name|FT_UInt
name|extra
init|=
name|count
operator|-
name|power
decl_stmt|;
name|FT_Byte
modifier|*
name|base
init|=
name|stream
operator|->
name|cursor
decl_stmt|;
name|FT_Bool
name|twobytes
init|=
name|FT_BOOL
argument_list|(
name|item
operator|->
name|flags
operator|&
literal|1
argument_list|)
decl_stmt|;
name|FT_Bool
name|twobyte_adj
init|=
name|FT_BOOL
argument_list|(
name|item
operator|->
name|flags
operator|&
literal|2
argument_list|)
decl_stmt|;
name|FT_Byte
modifier|*
name|p
decl_stmt|;
name|FT_UInt32
name|cpair
decl_stmt|;
if|if
condition|(
name|extra
operator|>
literal|0
condition|)
block|{
name|p
operator|=
name|base
operator|+
name|extra
operator|*
name|size
expr_stmt|;
if|if
condition|(
name|twobytes
condition|)
name|cpair
operator|=
name|FT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
name|cpair
operator|=
name|PFR_NEXT_KPAIR
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpair
operator|==
name|pair
condition|)
goto|goto
name|Found
goto|;
if|if
condition|(
name|cpair
operator|<
name|pair
condition|)
block|{
if|if
condition|(
name|twobyte_adj
condition|)
name|p
operator|+=
literal|2
expr_stmt|;
else|else
name|p
operator|++
expr_stmt|;
name|base
operator|=
name|p
expr_stmt|;
block|}
block|}
while|while
condition|(
name|probe
operator|>
name|size
condition|)
block|{
name|probe
operator|>>=
literal|1
expr_stmt|;
name|p
operator|=
name|base
operator|+
name|probe
expr_stmt|;
if|if
condition|(
name|twobytes
condition|)
name|cpair
operator|=
name|FT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
name|cpair
operator|=
name|PFR_NEXT_KPAIR
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpair
operator|==
name|pair
condition|)
goto|goto
name|Found
goto|;
if|if
condition|(
name|cpair
operator|<
name|pair
condition|)
name|base
operator|+=
name|probe
expr_stmt|;
block|}
name|p
operator|=
name|base
expr_stmt|;
if|if
condition|(
name|twobytes
condition|)
name|cpair
operator|=
name|FT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
name|cpair
operator|=
name|PFR_NEXT_KPAIR
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpair
operator|==
name|pair
condition|)
block|{
name|FT_Int
name|value
decl_stmt|;
name|Found
label|:
if|if
condition|(
name|twobyte_adj
condition|)
name|value
operator|=
name|FT_PEEK_SHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
name|value
operator|=
name|p
index|[
literal|0
index|]
expr_stmt|;
name|kerning
operator|->
name|x
operator|=
name|item
operator|->
name|base_adj
operator|+
name|value
expr_stmt|;
block|}
block|}
name|FT_FRAME_EXIT
argument_list|()
expr_stmt|;
block|}
name|Exit
label|:
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/* END */
end_comment
end_unit
