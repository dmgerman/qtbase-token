begin_unit
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  pfrgload.c                                                             */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*    FreeType PFR glyph loader (body).                                    */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  Copyright 2002, 2003, 2005, 2007 by                                    */
end_comment
begin_comment
comment|/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  This file is part of the FreeType project, and may only be used,       */
end_comment
begin_comment
comment|/*  modified, and distributed under the terms of the FreeType project      */
end_comment
begin_comment
comment|/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
end_comment
begin_comment
comment|/*  this file you indicate that you have read the license and              */
end_comment
begin_comment
comment|/*  understand and accept it fully.                                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"pfrgload.h"
end_include
begin_include
include|#
directive|include
file|"pfrsbit.h"
end_include
begin_include
include|#
directive|include
file|"pfrload.h"
end_include
begin_comment
comment|/* for macro definitions */
end_comment
begin_include
include|#
directive|include
include|FT_INTERNAL_DEBUG_H
end_include
begin_include
include|#
directive|include
file|"pfrerror.h"
end_include
begin_undef
DECL|macro|FT_COMPONENT
undef|#
directive|undef
name|FT_COMPONENT
end_undef
begin_define
DECL|macro|FT_COMPONENT
define|#
directive|define
name|FT_COMPONENT
value|trace_pfr
end_define
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****                      PFR GLYPH BUILDER                        *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|pfr_glyph_init
name|pfr_glyph_init
argument_list|(
argument|PFR_Glyph       glyph
argument_list|,
argument|FT_GlyphLoader  loader
argument_list|)
end_macro
begin_block
block|{
name|FT_ZERO
argument_list|(
name|glyph
argument_list|)
expr_stmt|;
name|glyph
operator|->
name|loader
operator|=
name|loader
expr_stmt|;
name|glyph
operator|->
name|path_begun
operator|=
literal|0
expr_stmt|;
name|FT_GlyphLoader_Rewind
argument_list|(
name|loader
argument_list|)
expr_stmt|;
block|}
end_block
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|pfr_glyph_done
name|pfr_glyph_done
argument_list|(
argument|PFR_Glyph  glyph
argument_list|)
end_macro
begin_block
block|{
name|FT_Memory
name|memory
init|=
name|glyph
operator|->
name|loader
operator|->
name|memory
decl_stmt|;
name|FT_FREE
argument_list|(
name|glyph
operator|->
name|x_control
argument_list|)
expr_stmt|;
name|glyph
operator|->
name|y_control
operator|=
name|NULL
expr_stmt|;
name|glyph
operator|->
name|max_xy_control
operator|=
literal|0
expr_stmt|;
if|#
directive|if
literal|0
block|glyph->num_x_control  = 0;     glyph->num_y_control  = 0;
endif|#
directive|endif
name|FT_FREE
argument_list|(
name|glyph
operator|->
name|subs
argument_list|)
expr_stmt|;
name|glyph
operator|->
name|max_subs
operator|=
literal|0
expr_stmt|;
name|glyph
operator|->
name|num_subs
operator|=
literal|0
expr_stmt|;
name|glyph
operator|->
name|loader
operator|=
name|NULL
expr_stmt|;
name|glyph
operator|->
name|path_begun
operator|=
literal|0
expr_stmt|;
block|}
end_block
begin_comment
comment|/* close current contour, if any */
end_comment
begin_function
specifier|static
name|void
DECL|function|pfr_glyph_close_contour
name|pfr_glyph_close_contour
parameter_list|(
name|PFR_Glyph
name|glyph
parameter_list|)
block|{
name|FT_GlyphLoader
name|loader
init|=
name|glyph
operator|->
name|loader
decl_stmt|;
name|FT_Outline
modifier|*
name|outline
init|=
operator|&
name|loader
operator|->
name|current
operator|.
name|outline
decl_stmt|;
name|FT_Int
name|last
decl_stmt|,
name|first
decl_stmt|;
if|if
condition|(
operator|!
name|glyph
operator|->
name|path_begun
condition|)
return|return;
comment|/* compute first and last point indices in current glyph outline */
name|last
operator|=
name|outline
operator|->
name|n_points
operator|-
literal|1
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|outline
operator|->
name|n_contours
operator|>
literal|0
condition|)
name|first
operator|=
name|outline
operator|->
name|contours
index|[
name|outline
operator|->
name|n_contours
operator|-
literal|1
index|]
expr_stmt|;
comment|/* if the last point falls on the same location than the first one */
comment|/* we need to delete it                                            */
if|if
condition|(
name|last
operator|>
name|first
condition|)
block|{
name|FT_Vector
modifier|*
name|p1
init|=
name|outline
operator|->
name|points
operator|+
name|first
decl_stmt|;
name|FT_Vector
modifier|*
name|p2
init|=
name|outline
operator|->
name|points
operator|+
name|last
decl_stmt|;
if|if
condition|(
name|p1
operator|->
name|x
operator|==
name|p2
operator|->
name|x
operator|&&
name|p1
operator|->
name|y
operator|==
name|p2
operator|->
name|y
condition|)
block|{
name|outline
operator|->
name|n_points
operator|--
expr_stmt|;
name|last
operator|--
expr_stmt|;
block|}
block|}
comment|/* don't add empty contours */
if|if
condition|(
name|last
operator|>=
name|first
condition|)
name|outline
operator|->
name|contours
index|[
name|outline
operator|->
name|n_contours
operator|++
index|]
operator|=
operator|(
name|short
operator|)
name|last
expr_stmt|;
name|glyph
operator|->
name|path_begun
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_comment
comment|/* reset glyph to start the loading of a new glyph */
end_comment
begin_function
specifier|static
name|void
DECL|function|pfr_glyph_start
name|pfr_glyph_start
parameter_list|(
name|PFR_Glyph
name|glyph
parameter_list|)
block|{
name|glyph
operator|->
name|path_begun
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|pfr_glyph_line_to
name|pfr_glyph_line_to
parameter_list|(
name|PFR_Glyph
name|glyph
parameter_list|,
name|FT_Vector
modifier|*
name|to
parameter_list|)
block|{
name|FT_GlyphLoader
name|loader
init|=
name|glyph
operator|->
name|loader
decl_stmt|;
name|FT_Outline
modifier|*
name|outline
init|=
operator|&
name|loader
operator|->
name|current
operator|.
name|outline
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
comment|/* check that we have begun a new path */
if|if
condition|(
operator|!
name|glyph
operator|->
name|path_begun
condition|)
block|{
name|error
operator|=
name|PFR_Err_Invalid_Table
expr_stmt|;
name|FT_ERROR
argument_list|(
operator|(
literal|"pfr_glyph_line_to: invalid glyph data\n"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|error
operator|=
name|FT_GLYPHLOADER_CHECK_POINTS
argument_list|(
name|loader
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|FT_UInt
name|n
init|=
name|outline
operator|->
name|n_points
decl_stmt|;
name|outline
operator|->
name|points
index|[
name|n
index|]
operator|=
operator|*
name|to
expr_stmt|;
name|outline
operator|->
name|tags
index|[
name|n
index|]
operator|=
name|FT_CURVE_TAG_ON
expr_stmt|;
name|outline
operator|->
name|n_points
operator|++
expr_stmt|;
block|}
name|Exit
label|:
return|return
name|error
return|;
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|pfr_glyph_curve_to
name|pfr_glyph_curve_to
parameter_list|(
name|PFR_Glyph
name|glyph
parameter_list|,
name|FT_Vector
modifier|*
name|control1
parameter_list|,
name|FT_Vector
modifier|*
name|control2
parameter_list|,
name|FT_Vector
modifier|*
name|to
parameter_list|)
block|{
name|FT_GlyphLoader
name|loader
init|=
name|glyph
operator|->
name|loader
decl_stmt|;
name|FT_Outline
modifier|*
name|outline
init|=
operator|&
name|loader
operator|->
name|current
operator|.
name|outline
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
comment|/* check that we have begun a new path */
if|if
condition|(
operator|!
name|glyph
operator|->
name|path_begun
condition|)
block|{
name|error
operator|=
name|PFR_Err_Invalid_Table
expr_stmt|;
name|FT_ERROR
argument_list|(
operator|(
literal|"pfr_glyph_line_to: invalid glyph data\n"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|error
operator|=
name|FT_GLYPHLOADER_CHECK_POINTS
argument_list|(
name|loader
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|FT_Vector
modifier|*
name|vec
init|=
name|outline
operator|->
name|points
operator|+
name|outline
operator|->
name|n_points
decl_stmt|;
name|FT_Byte
modifier|*
name|tag
init|=
operator|(
name|FT_Byte
operator|*
operator|)
name|outline
operator|->
name|tags
operator|+
name|outline
operator|->
name|n_points
decl_stmt|;
name|vec
index|[
literal|0
index|]
operator|=
operator|*
name|control1
expr_stmt|;
name|vec
index|[
literal|1
index|]
operator|=
operator|*
name|control2
expr_stmt|;
name|vec
index|[
literal|2
index|]
operator|=
operator|*
name|to
expr_stmt|;
name|tag
index|[
literal|0
index|]
operator|=
name|FT_CURVE_TAG_CUBIC
expr_stmt|;
name|tag
index|[
literal|1
index|]
operator|=
name|FT_CURVE_TAG_CUBIC
expr_stmt|;
name|tag
index|[
literal|2
index|]
operator|=
name|FT_CURVE_TAG_ON
expr_stmt|;
name|outline
operator|->
name|n_points
operator|=
call|(
name|FT_Short
call|)
argument_list|(
name|outline
operator|->
name|n_points
operator|+
literal|3
argument_list|)
expr_stmt|;
block|}
name|Exit
label|:
return|return
name|error
return|;
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|pfr_glyph_move_to
name|pfr_glyph_move_to
parameter_list|(
name|PFR_Glyph
name|glyph
parameter_list|,
name|FT_Vector
modifier|*
name|to
parameter_list|)
block|{
name|FT_GlyphLoader
name|loader
init|=
name|glyph
operator|->
name|loader
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
comment|/* close current contour if any */
name|pfr_glyph_close_contour
argument_list|(
name|glyph
argument_list|)
expr_stmt|;
comment|/* indicate that a new contour has started */
name|glyph
operator|->
name|path_begun
operator|=
literal|1
expr_stmt|;
comment|/* check that there is space for a new contour and a new point */
name|error
operator|=
name|FT_GLYPHLOADER_CHECK_POINTS
argument_list|(
name|loader
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
comment|/* add new start point */
name|error
operator|=
name|pfr_glyph_line_to
argument_list|(
name|glyph
argument_list|,
name|to
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|pfr_glyph_end
name|pfr_glyph_end
parameter_list|(
name|PFR_Glyph
name|glyph
parameter_list|)
block|{
comment|/* close current contour if any */
name|pfr_glyph_close_contour
argument_list|(
name|glyph
argument_list|)
expr_stmt|;
comment|/* merge the current glyph into the stack */
name|FT_GlyphLoader_Add
argument_list|(
name|glyph
operator|->
name|loader
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****                      PFR GLYPH LOADER                         *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/* load a simple glyph */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|pfr_glyph_load_simple
name|pfr_glyph_load_simple
parameter_list|(
name|PFR_Glyph
name|glyph
parameter_list|,
name|FT_Byte
modifier|*
name|p
parameter_list|,
name|FT_Byte
modifier|*
name|limit
parameter_list|)
block|{
name|FT_Error
name|error
init|=
literal|0
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|glyph
operator|->
name|loader
operator|->
name|memory
decl_stmt|;
name|FT_UInt
name|flags
decl_stmt|,
name|x_count
decl_stmt|,
name|y_count
decl_stmt|,
name|i
decl_stmt|,
name|count
decl_stmt|,
name|mask
decl_stmt|;
name|FT_Int
name|x
decl_stmt|;
name|PFR_CHECK
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|flags
operator|=
name|PFR_NEXT_BYTE
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* test for composite glyphs */
if|if
condition|(
name|flags
operator|&
name|PFR_GLYPH_IS_COMPOUND
condition|)
goto|goto
name|Failure
goto|;
name|x_count
operator|=
literal|0
expr_stmt|;
name|y_count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|PFR_GLYPH_1BYTE_XYCOUNT
condition|)
block|{
name|PFR_CHECK
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|count
operator|=
name|PFR_NEXT_BYTE
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|x_count
operator|=
operator|(
name|count
operator|&
literal|15
operator|)
expr_stmt|;
name|y_count
operator|=
operator|(
name|count
operator|>>
literal|4
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|flags
operator|&
name|PFR_GLYPH_XCOUNT
condition|)
block|{
name|PFR_CHECK
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|x_count
operator|=
name|PFR_NEXT_BYTE
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|PFR_GLYPH_YCOUNT
condition|)
block|{
name|PFR_CHECK
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|y_count
operator|=
name|PFR_NEXT_BYTE
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
name|count
operator|=
name|x_count
operator|+
name|y_count
expr_stmt|;
comment|/* re-allocate array when necessary */
if|if
condition|(
name|count
operator|>
name|glyph
operator|->
name|max_xy_control
condition|)
block|{
name|FT_UInt
name|new_max
init|=
name|FT_PAD_CEIL
argument_list|(
name|count
argument_list|,
literal|8
argument_list|)
decl_stmt|;
if|if
condition|(
name|FT_RENEW_ARRAY
argument_list|(
name|glyph
operator|->
name|x_control
argument_list|,
name|glyph
operator|->
name|max_xy_control
argument_list|,
name|new_max
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|glyph
operator|->
name|max_xy_control
operator|=
name|new_max
expr_stmt|;
block|}
name|glyph
operator|->
name|y_control
operator|=
name|glyph
operator|->
name|x_control
operator|+
name|x_count
expr_stmt|;
name|mask
operator|=
literal|0
expr_stmt|;
name|x
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|i
operator|&
literal|7
operator|)
operator|==
literal|0
condition|)
block|{
name|PFR_CHECK
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|mask
operator|=
name|PFR_NEXT_BYTE
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
literal|1
condition|)
block|{
name|PFR_CHECK
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|x
operator|=
name|PFR_NEXT_SHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PFR_CHECK
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|x
operator|+=
name|PFR_NEXT_BYTE
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|glyph
operator|->
name|x_control
index|[
name|i
index|]
operator|=
name|x
expr_stmt|;
name|mask
operator|>>=
literal|1
expr_stmt|;
block|}
comment|/* XXX: for now we ignore the secondary stroke and edge definitions */
comment|/*      since we don't want to support native PFR hinting           */
comment|/*                                                                  */
if|if
condition|(
name|flags
operator|&
name|PFR_GLYPH_EXTRA_ITEMS
condition|)
block|{
name|error
operator|=
name|pfr_extra_items_skip
argument_list|(
operator|&
name|p
argument_list|,
name|limit
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
block|}
name|pfr_glyph_start
argument_list|(
name|glyph
argument_list|)
expr_stmt|;
comment|/* now load a simple glyph */
block|{
name|FT_Vector
name|pos
index|[
literal|4
index|]
decl_stmt|;
name|FT_Vector
modifier|*
name|cur
decl_stmt|;
name|pos
index|[
literal|0
index|]
operator|.
name|x
operator|=
name|pos
index|[
literal|0
index|]
operator|.
name|y
operator|=
literal|0
expr_stmt|;
name|pos
index|[
literal|3
index|]
operator|=
name|pos
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|FT_UInt
name|format
decl_stmt|,
name|format_low
decl_stmt|,
name|args_format
init|=
literal|0
decl_stmt|,
name|args_count
decl_stmt|,
name|n
decl_stmt|;
comment|/***************************************************************/
comment|/*  read instruction                                           */
comment|/*                                                             */
name|PFR_CHECK
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|format
operator|=
name|PFR_NEXT_BYTE
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|format_low
operator|=
name|format
operator|&
literal|15
expr_stmt|;
switch|switch
condition|(
name|format
operator|>>
literal|4
condition|)
block|{
case|case
literal|0
case|:
comment|/* end glyph */
name|FT_TRACE6
argument_list|(
operator|(
literal|"- end glyph"
operator|)
argument_list|)
expr_stmt|;
name|args_count
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* general line operation */
name|FT_TRACE6
argument_list|(
operator|(
literal|"- general line"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|Line1
goto|;
case|case
literal|4
case|:
comment|/* move to inside contour  */
name|FT_TRACE6
argument_list|(
operator|(
literal|"- move to inside"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|Line1
goto|;
case|case
literal|5
case|:
comment|/* move to outside contour */
name|FT_TRACE6
argument_list|(
operator|(
literal|"- move to outside"
operator|)
argument_list|)
expr_stmt|;
name|Line1
label|:
name|args_format
operator|=
name|format_low
expr_stmt|;
name|args_count
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* horizontal line to */
name|FT_TRACE6
argument_list|(
operator|(
literal|"- horizontal line to cx.%d"
operator|,
name|format_low
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|format_low
operator|>
name|x_count
condition|)
goto|goto
name|Failure
goto|;
name|pos
index|[
literal|0
index|]
operator|.
name|x
operator|=
name|glyph
operator|->
name|x_control
index|[
name|format_low
index|]
expr_stmt|;
name|pos
index|[
literal|0
index|]
operator|.
name|y
operator|=
name|pos
index|[
literal|3
index|]
operator|.
name|y
expr_stmt|;
name|pos
index|[
literal|3
index|]
operator|=
name|pos
index|[
literal|0
index|]
expr_stmt|;
name|args_count
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* vertical line to */
name|FT_TRACE6
argument_list|(
operator|(
literal|"- vertical line to cy.%d"
operator|,
name|format_low
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|format_low
operator|>
name|y_count
condition|)
goto|goto
name|Failure
goto|;
name|pos
index|[
literal|0
index|]
operator|.
name|x
operator|=
name|pos
index|[
literal|3
index|]
operator|.
name|x
expr_stmt|;
name|pos
index|[
literal|0
index|]
operator|.
name|y
operator|=
name|glyph
operator|->
name|y_control
index|[
name|format_low
index|]
expr_stmt|;
name|pos
index|[
literal|3
index|]
operator|=
name|pos
index|[
literal|0
index|]
expr_stmt|;
name|args_count
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|6
case|:
comment|/* horizontal to vertical curve */
name|FT_TRACE6
argument_list|(
operator|(
literal|"- hv curve "
operator|)
argument_list|)
expr_stmt|;
name|args_format
operator|=
literal|0xB8E
expr_stmt|;
name|args_count
operator|=
literal|3
expr_stmt|;
break|break;
case|case
literal|7
case|:
comment|/* vertical to horizontal curve */
name|FT_TRACE6
argument_list|(
operator|(
literal|"- vh curve"
operator|)
argument_list|)
expr_stmt|;
name|args_format
operator|=
literal|0xE2B
expr_stmt|;
name|args_count
operator|=
literal|3
expr_stmt|;
break|break;
default|default:
comment|/* general curve to */
name|FT_TRACE6
argument_list|(
operator|(
literal|"- general curve"
operator|)
argument_list|)
expr_stmt|;
name|args_count
operator|=
literal|4
expr_stmt|;
name|args_format
operator|=
name|format_low
expr_stmt|;
block|}
comment|/***********************************************************/
comment|/*  now read arguments                                     */
comment|/*                                                         */
name|cur
operator|=
name|pos
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|args_count
condition|;
name|n
operator|++
control|)
block|{
name|FT_UInt
name|idx
decl_stmt|;
name|FT_Int
name|delta
decl_stmt|;
comment|/* read the X argument */
switch|switch
condition|(
name|args_format
operator|&
literal|3
condition|)
block|{
case|case
literal|0
case|:
comment|/* 8-bit index */
name|PFR_CHECK
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|idx
operator|=
name|PFR_NEXT_BYTE
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|>
name|x_count
condition|)
goto|goto
name|Failure
goto|;
name|cur
operator|->
name|x
operator|=
name|glyph
operator|->
name|x_control
index|[
name|idx
index|]
expr_stmt|;
name|FT_TRACE7
argument_list|(
operator|(
literal|" cx#%d"
operator|,
name|idx
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* 16-bit value */
name|PFR_CHECK
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|cur
operator|->
name|x
operator|=
name|PFR_NEXT_SHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|FT_TRACE7
argument_list|(
operator|(
literal|" x.%d"
operator|,
name|cur
operator|->
name|x
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* 8-bit delta */
name|PFR_CHECK
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|delta
operator|=
name|PFR_NEXT_INT8
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|cur
operator|->
name|x
operator|=
name|pos
index|[
literal|3
index|]
operator|.
name|x
operator|+
name|delta
expr_stmt|;
name|FT_TRACE7
argument_list|(
operator|(
literal|" dx.%d"
operator|,
name|delta
operator|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|FT_TRACE7
argument_list|(
operator|(
literal|" |"
operator|)
argument_list|)
expr_stmt|;
name|cur
operator|->
name|x
operator|=
name|pos
index|[
literal|3
index|]
operator|.
name|x
expr_stmt|;
block|}
comment|/* read the Y argument */
switch|switch
condition|(
operator|(
name|args_format
operator|>>
literal|2
operator|)
operator|&
literal|3
condition|)
block|{
case|case
literal|0
case|:
comment|/* 8-bit index */
name|PFR_CHECK
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|idx
operator|=
name|PFR_NEXT_BYTE
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|>
name|y_count
condition|)
goto|goto
name|Failure
goto|;
name|cur
operator|->
name|y
operator|=
name|glyph
operator|->
name|y_control
index|[
name|idx
index|]
expr_stmt|;
name|FT_TRACE7
argument_list|(
operator|(
literal|" cy#%d"
operator|,
name|idx
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* 16-bit absolute value */
name|PFR_CHECK
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|cur
operator|->
name|y
operator|=
name|PFR_NEXT_SHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|FT_TRACE7
argument_list|(
operator|(
literal|" y.%d"
operator|,
name|cur
operator|->
name|y
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* 8-bit delta */
name|PFR_CHECK
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|delta
operator|=
name|PFR_NEXT_INT8
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|cur
operator|->
name|y
operator|=
name|pos
index|[
literal|3
index|]
operator|.
name|y
operator|+
name|delta
expr_stmt|;
name|FT_TRACE7
argument_list|(
operator|(
literal|" dy.%d"
operator|,
name|delta
operator|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|FT_TRACE7
argument_list|(
operator|(
literal|" -"
operator|)
argument_list|)
expr_stmt|;
name|cur
operator|->
name|y
operator|=
name|pos
index|[
literal|3
index|]
operator|.
name|y
expr_stmt|;
block|}
comment|/* read the additional format flag for the general curve */
if|if
condition|(
name|n
operator|==
literal|0
operator|&&
name|args_count
operator|==
literal|4
condition|)
block|{
name|PFR_CHECK
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|args_format
operator|=
name|PFR_NEXT_BYTE
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|args_count
operator|--
expr_stmt|;
block|}
else|else
name|args_format
operator|>>=
literal|4
expr_stmt|;
comment|/* save the previous point */
name|pos
index|[
literal|3
index|]
operator|=
name|cur
index|[
literal|0
index|]
expr_stmt|;
name|cur
operator|++
expr_stmt|;
block|}
name|FT_TRACE7
argument_list|(
operator|(
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
comment|/***********************************************************/
comment|/*  finally, execute instruction                           */
comment|/*                                                         */
switch|switch
condition|(
name|format
operator|>>
literal|4
condition|)
block|{
case|case
literal|0
case|:
comment|/* end glyph => EXIT */
name|pfr_glyph_end
argument_list|(
name|glyph
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
case|case
literal|1
case|:
comment|/* line operations */
case|case
literal|2
case|:
case|case
literal|3
case|:
name|error
operator|=
name|pfr_glyph_line_to
argument_list|(
name|glyph
argument_list|,
name|pos
argument_list|)
expr_stmt|;
goto|goto
name|Test_Error
goto|;
case|case
literal|4
case|:
comment|/* move to inside contour  */
case|case
literal|5
case|:
comment|/* move to outside contour */
name|error
operator|=
name|pfr_glyph_move_to
argument_list|(
name|glyph
argument_list|,
name|pos
argument_list|)
expr_stmt|;
goto|goto
name|Test_Error
goto|;
default|default:
comment|/* curve operations */
name|error
operator|=
name|pfr_glyph_curve_to
argument_list|(
name|glyph
argument_list|,
name|pos
argument_list|,
name|pos
operator|+
literal|1
argument_list|,
name|pos
operator|+
literal|2
argument_list|)
expr_stmt|;
name|Test_Error
label|:
comment|/* test error condition */
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
block|}
block|}
comment|/* for (;;) */
block|}
name|Exit
label|:
return|return
name|error
return|;
name|Failure
label|:
name|Too_Short
label|:
name|error
operator|=
name|PFR_Err_Invalid_Table
expr_stmt|;
name|FT_ERROR
argument_list|(
operator|(
literal|"pfr_glyph_load_simple: invalid glyph data\n"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
end_function
begin_comment
comment|/* load a composite/compound glyph */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|pfr_glyph_load_compound
name|pfr_glyph_load_compound
parameter_list|(
name|PFR_Glyph
name|glyph
parameter_list|,
name|FT_Byte
modifier|*
name|p
parameter_list|,
name|FT_Byte
modifier|*
name|limit
parameter_list|)
block|{
name|FT_Error
name|error
init|=
literal|0
decl_stmt|;
name|FT_GlyphLoader
name|loader
init|=
name|glyph
operator|->
name|loader
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|loader
operator|->
name|memory
decl_stmt|;
name|PFR_SubGlyph
name|subglyph
decl_stmt|;
name|FT_UInt
name|flags
decl_stmt|,
name|i
decl_stmt|,
name|count
decl_stmt|,
name|org_count
decl_stmt|;
name|FT_Int
name|x_pos
decl_stmt|,
name|y_pos
decl_stmt|;
name|PFR_CHECK
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|flags
operator|=
name|PFR_NEXT_BYTE
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* test for composite glyphs */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|PFR_GLYPH_IS_COMPOUND
operator|)
condition|)
goto|goto
name|Failure
goto|;
name|count
operator|=
name|flags
operator|&
literal|0x3F
expr_stmt|;
comment|/* ignore extra items when present */
comment|/*                                 */
if|if
condition|(
name|flags
operator|&
name|PFR_GLYPH_EXTRA_ITEMS
condition|)
block|{
name|error
operator|=
name|pfr_extra_items_skip
argument_list|(
operator|&
name|p
argument_list|,
name|limit
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
block|}
comment|/* we can't rely on the FT_GlyphLoader to load sub-glyphs, because   */
comment|/* the PFR format is dumb, using direct file offsets to point to the */
comment|/* sub-glyphs (instead of glyph indices).  Sigh.                     */
comment|/*                                                                   */
comment|/* For now, we load the list of sub-glyphs into a different array    */
comment|/* but this will prevent us from using the auto-hinter at its best   */
comment|/* quality.                                                          */
comment|/*                                                                   */
name|org_count
operator|=
name|glyph
operator|->
name|num_subs
expr_stmt|;
if|if
condition|(
name|org_count
operator|+
name|count
operator|>
name|glyph
operator|->
name|max_subs
condition|)
block|{
name|FT_UInt
name|new_max
init|=
operator|(
name|org_count
operator|+
name|count
operator|+
literal|3
operator|)
operator|&
operator|(
name|FT_UInt
operator|)
operator|-
literal|4
decl_stmt|;
if|if
condition|(
name|FT_RENEW_ARRAY
argument_list|(
name|glyph
operator|->
name|subs
argument_list|,
name|glyph
operator|->
name|max_subs
argument_list|,
name|new_max
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|glyph
operator|->
name|max_subs
operator|=
name|new_max
expr_stmt|;
block|}
name|subglyph
operator|=
name|glyph
operator|->
name|subs
operator|+
name|org_count
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|subglyph
operator|++
control|)
block|{
name|FT_UInt
name|format
decl_stmt|;
name|x_pos
operator|=
literal|0
expr_stmt|;
name|y_pos
operator|=
literal|0
expr_stmt|;
name|PFR_CHECK
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|format
operator|=
name|PFR_NEXT_BYTE
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* read scale when available */
name|subglyph
operator|->
name|x_scale
operator|=
literal|0x10000L
expr_stmt|;
if|if
condition|(
name|format
operator|&
name|PFR_SUBGLYPH_XSCALE
condition|)
block|{
name|PFR_CHECK
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|subglyph
operator|->
name|x_scale
operator|=
name|PFR_NEXT_SHORT
argument_list|(
name|p
argument_list|)
operator|<<
literal|4
expr_stmt|;
block|}
name|subglyph
operator|->
name|y_scale
operator|=
literal|0x10000L
expr_stmt|;
if|if
condition|(
name|format
operator|&
name|PFR_SUBGLYPH_YSCALE
condition|)
block|{
name|PFR_CHECK
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|subglyph
operator|->
name|y_scale
operator|=
name|PFR_NEXT_SHORT
argument_list|(
name|p
argument_list|)
operator|<<
literal|4
expr_stmt|;
block|}
comment|/* read offset */
switch|switch
condition|(
name|format
operator|&
literal|3
condition|)
block|{
case|case
literal|1
case|:
name|PFR_CHECK
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|x_pos
operator|=
name|PFR_NEXT_SHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|PFR_CHECK
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|x_pos
operator|+=
name|PFR_NEXT_INT8
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
default|default:
empty_stmt|;
block|}
switch|switch
condition|(
operator|(
name|format
operator|>>
literal|2
operator|)
operator|&
literal|3
condition|)
block|{
case|case
literal|1
case|:
name|PFR_CHECK
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|y_pos
operator|=
name|PFR_NEXT_SHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|PFR_CHECK
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|y_pos
operator|+=
name|PFR_NEXT_INT8
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
default|default:
empty_stmt|;
block|}
name|subglyph
operator|->
name|x_delta
operator|=
name|x_pos
expr_stmt|;
name|subglyph
operator|->
name|y_delta
operator|=
name|y_pos
expr_stmt|;
comment|/* read glyph position and size now */
if|if
condition|(
name|format
operator|&
name|PFR_SUBGLYPH_2BYTE_SIZE
condition|)
block|{
name|PFR_CHECK
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|subglyph
operator|->
name|gps_size
operator|=
name|PFR_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PFR_CHECK
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|subglyph
operator|->
name|gps_size
operator|=
name|PFR_NEXT_BYTE
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|format
operator|&
name|PFR_SUBGLYPH_3BYTE_OFFSET
condition|)
block|{
name|PFR_CHECK
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|subglyph
operator|->
name|gps_offset
operator|=
name|PFR_NEXT_LONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PFR_CHECK
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|subglyph
operator|->
name|gps_offset
operator|=
name|PFR_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|glyph
operator|->
name|num_subs
operator|++
expr_stmt|;
block|}
name|Exit
label|:
return|return
name|error
return|;
name|Failure
label|:
name|Too_Short
label|:
name|error
operator|=
name|PFR_Err_Invalid_Table
expr_stmt|;
name|FT_ERROR
argument_list|(
operator|(
literal|"pfr_glyph_load_compound: invalid glyph data\n"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|pfr_glyph_load_rec
name|pfr_glyph_load_rec
parameter_list|(
name|PFR_Glyph
name|glyph
parameter_list|,
name|FT_Stream
name|stream
parameter_list|,
name|FT_ULong
name|gps_offset
parameter_list|,
name|FT_ULong
name|offset
parameter_list|,
name|FT_ULong
name|size
parameter_list|)
block|{
name|FT_Error
name|error
decl_stmt|;
name|FT_Byte
modifier|*
name|p
decl_stmt|;
name|FT_Byte
modifier|*
name|limit
decl_stmt|;
if|if
condition|(
name|FT_STREAM_SEEK
argument_list|(
name|gps_offset
operator|+
name|offset
argument_list|)
operator|||
name|FT_FRAME_ENTER
argument_list|(
name|size
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|p
operator|=
operator|(
name|FT_Byte
operator|*
operator|)
name|stream
operator|->
name|cursor
expr_stmt|;
name|limit
operator|=
name|p
operator|+
name|size
expr_stmt|;
if|if
condition|(
name|size
operator|>
literal|0
operator|&&
operator|*
name|p
operator|&
name|PFR_GLYPH_IS_COMPOUND
condition|)
block|{
name|FT_Int
name|n
decl_stmt|,
name|old_count
decl_stmt|,
name|count
decl_stmt|;
name|FT_GlyphLoader
name|loader
init|=
name|glyph
operator|->
name|loader
decl_stmt|;
name|FT_Outline
modifier|*
name|base
init|=
operator|&
name|loader
operator|->
name|base
operator|.
name|outline
decl_stmt|;
name|old_count
operator|=
name|glyph
operator|->
name|num_subs
expr_stmt|;
comment|/* this is a compound glyph - load it */
name|error
operator|=
name|pfr_glyph_load_compound
argument_list|(
name|glyph
argument_list|,
name|p
argument_list|,
name|limit
argument_list|)
expr_stmt|;
name|FT_FRAME_EXIT
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|count
operator|=
name|glyph
operator|->
name|num_subs
operator|-
name|old_count
expr_stmt|;
comment|/* now, load each individual glyph */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
block|{
name|FT_Int
name|i
decl_stmt|,
name|old_points
decl_stmt|,
name|num_points
decl_stmt|;
name|PFR_SubGlyph
name|subglyph
decl_stmt|;
name|subglyph
operator|=
name|glyph
operator|->
name|subs
operator|+
name|old_count
operator|+
name|n
expr_stmt|;
name|old_points
operator|=
name|base
operator|->
name|n_points
expr_stmt|;
name|error
operator|=
name|pfr_glyph_load_rec
argument_list|(
name|glyph
argument_list|,
name|stream
argument_list|,
name|gps_offset
argument_list|,
name|subglyph
operator|->
name|gps_offset
argument_list|,
name|subglyph
operator|->
name|gps_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
comment|/* note that `glyph->subs' might have been re-allocated */
name|subglyph
operator|=
name|glyph
operator|->
name|subs
operator|+
name|old_count
operator|+
name|n
expr_stmt|;
name|num_points
operator|=
name|base
operator|->
name|n_points
operator|-
name|old_points
expr_stmt|;
comment|/* translate and eventually scale the new glyph points */
if|if
condition|(
name|subglyph
operator|->
name|x_scale
operator|!=
literal|0x10000L
operator|||
name|subglyph
operator|->
name|y_scale
operator|!=
literal|0x10000L
condition|)
block|{
name|FT_Vector
modifier|*
name|vec
init|=
name|base
operator|->
name|points
operator|+
name|old_points
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_points
condition|;
name|i
operator|++
operator|,
name|vec
operator|++
control|)
block|{
name|vec
operator|->
name|x
operator|=
name|FT_MulFix
argument_list|(
name|vec
operator|->
name|x
argument_list|,
name|subglyph
operator|->
name|x_scale
argument_list|)
operator|+
name|subglyph
operator|->
name|x_delta
expr_stmt|;
name|vec
operator|->
name|y
operator|=
name|FT_MulFix
argument_list|(
name|vec
operator|->
name|y
argument_list|,
name|subglyph
operator|->
name|y_scale
argument_list|)
operator|+
name|subglyph
operator|->
name|y_delta
expr_stmt|;
block|}
block|}
else|else
block|{
name|FT_Vector
modifier|*
name|vec
init|=
name|loader
operator|->
name|base
operator|.
name|outline
operator|.
name|points
operator|+
name|old_points
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_points
condition|;
name|i
operator|++
operator|,
name|vec
operator|++
control|)
block|{
name|vec
operator|->
name|x
operator|+=
name|subglyph
operator|->
name|x_delta
expr_stmt|;
name|vec
operator|->
name|y
operator|+=
name|subglyph
operator|->
name|y_delta
expr_stmt|;
block|}
block|}
comment|/* proceed to next sub-glyph */
block|}
block|}
else|else
block|{
comment|/* load a simple glyph */
name|error
operator|=
name|pfr_glyph_load_simple
argument_list|(
name|glyph
argument_list|,
name|p
argument_list|,
name|limit
argument_list|)
expr_stmt|;
name|FT_FRAME_EXIT
argument_list|()
expr_stmt|;
block|}
name|Exit
label|:
return|return
name|error
return|;
block|}
end_function
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|pfr_glyph_load
argument_list|(
argument|PFR_Glyph  glyph
argument_list|,
argument|FT_Stream  stream
argument_list|,
argument|FT_ULong   gps_offset
argument_list|,
argument|FT_ULong   offset
argument_list|,
argument|FT_ULong   size
argument_list|)
end_macro
begin_block
block|{
comment|/* initialize glyph loader */
name|FT_GlyphLoader_Rewind
argument_list|(
name|glyph
operator|->
name|loader
argument_list|)
expr_stmt|;
name|glyph
operator|->
name|num_subs
operator|=
literal|0
expr_stmt|;
comment|/* load the glyph, recursively when needed */
return|return
name|pfr_glyph_load_rec
argument_list|(
name|glyph
argument_list|,
name|stream
argument_list|,
name|gps_offset
argument_list|,
name|offset
argument_list|,
name|size
argument_list|)
return|;
block|}
end_block
begin_comment
comment|/* END */
end_comment
end_unit
