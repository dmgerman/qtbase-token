begin_unit
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  pfrload.c                                                              */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*    FreeType PFR loader (body).                                          */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  Copyright 2002, 2003, 2004, 2005, 2007, 2009 by                        */
end_comment
begin_comment
comment|/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  This file is part of the FreeType project, and may only be used,       */
end_comment
begin_comment
comment|/*  modified, and distributed under the terms of the FreeType project      */
end_comment
begin_comment
comment|/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
end_comment
begin_comment
comment|/*  this file you indicate that you have read the license and              */
end_comment
begin_comment
comment|/*  understand and accept it fully.                                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"pfrload.h"
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_DEBUG_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_STREAM_H
end_include
begin_include
include|#
directive|include
file|"pfrerror.h"
end_include
begin_undef
DECL|macro|FT_COMPONENT
undef|#
directive|undef
name|FT_COMPONENT
end_undef
begin_define
DECL|macro|FT_COMPONENT
define|#
directive|define
name|FT_COMPONENT
value|trace_pfr
end_define
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****                          EXTRA ITEMS                          *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|pfr_extra_items_skip
argument_list|(
argument|FT_Byte*  *pp
argument_list|,
argument|FT_Byte*   limit
argument_list|)
end_macro
begin_block
block|{
return|return
name|pfr_extra_items_parse
argument_list|(
name|pp
argument_list|,
name|limit
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_block
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|pfr_extra_items_parse
argument_list|(
argument|FT_Byte*       *pp
argument_list|,
argument|FT_Byte*        limit
argument_list|,
argument|PFR_ExtraItem   item_list
argument_list|,
argument|FT_Pointer      item_data
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
init|=
literal|0
decl_stmt|;
name|FT_Byte
modifier|*
name|p
init|=
operator|*
name|pp
decl_stmt|;
name|FT_UInt
name|num_items
decl_stmt|,
name|item_type
decl_stmt|,
name|item_size
decl_stmt|;
name|PFR_CHECK
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|num_items
operator|=
name|PFR_NEXT_BYTE
argument_list|(
name|p
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|num_items
operator|>
literal|0
condition|;
name|num_items
operator|--
control|)
block|{
name|PFR_CHECK
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|item_size
operator|=
name|PFR_NEXT_BYTE
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|item_type
operator|=
name|PFR_NEXT_BYTE
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|PFR_CHECK
argument_list|(
name|item_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|item_list
condition|)
block|{
name|PFR_ExtraItem
name|extra
init|=
name|item_list
decl_stmt|;
for|for
control|(
name|extra
operator|=
name|item_list
init|;
name|extra
operator|->
name|parser
operator|!=
name|NULL
condition|;
name|extra
operator|++
control|)
block|{
if|if
condition|(
name|extra
operator|->
name|type
operator|==
name|item_type
condition|)
block|{
name|error
operator|=
name|extra
operator|->
name|parser
argument_list|(
name|p
argument_list|,
name|p
operator|+
name|item_size
argument_list|,
name|item_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
break|break;
block|}
block|}
block|}
name|p
operator|+=
name|item_size
expr_stmt|;
block|}
name|Exit
label|:
operator|*
name|pp
operator|=
name|p
expr_stmt|;
return|return
name|error
return|;
name|Too_Short
label|:
name|FT_ERROR
argument_list|(
operator|(
literal|"pfr_extra_items_parse: invalid extra items table\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|PFR_Err_Invalid_Table
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****                          PFR HEADER                           *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_decl_stmt
DECL|variable|pfr_header_fields
specifier|static
specifier|const
name|FT_Frame_Field
name|pfr_header_fields
index|[]
init|=
block|{
DECL|macro|FT_STRUCTURE
undef|#
directive|undef
name|FT_STRUCTURE
DECL|macro|FT_STRUCTURE
define|#
directive|define
name|FT_STRUCTURE
value|PFR_HeaderRec
name|FT_FRAME_START
argument_list|(
literal|58
argument_list|)
block|,
name|FT_FRAME_ULONG
argument_list|(
name|signature
argument_list|)
block|,
name|FT_FRAME_USHORT
argument_list|(
name|version
argument_list|)
block|,
name|FT_FRAME_USHORT
argument_list|(
name|signature2
argument_list|)
block|,
name|FT_FRAME_USHORT
argument_list|(
name|header_size
argument_list|)
block|,
name|FT_FRAME_USHORT
argument_list|(
name|log_dir_size
argument_list|)
block|,
name|FT_FRAME_USHORT
argument_list|(
name|log_dir_offset
argument_list|)
block|,
name|FT_FRAME_USHORT
argument_list|(
name|log_font_max_size
argument_list|)
block|,
name|FT_FRAME_UOFF3
argument_list|(
name|log_font_section_size
argument_list|)
block|,
name|FT_FRAME_UOFF3
argument_list|(
name|log_font_section_offset
argument_list|)
block|,
name|FT_FRAME_USHORT
argument_list|(
name|phy_font_max_size
argument_list|)
block|,
name|FT_FRAME_UOFF3
argument_list|(
name|phy_font_section_size
argument_list|)
block|,
name|FT_FRAME_UOFF3
argument_list|(
name|phy_font_section_offset
argument_list|)
block|,
name|FT_FRAME_USHORT
argument_list|(
name|gps_max_size
argument_list|)
block|,
name|FT_FRAME_UOFF3
argument_list|(
name|gps_section_size
argument_list|)
block|,
name|FT_FRAME_UOFF3
argument_list|(
name|gps_section_offset
argument_list|)
block|,
name|FT_FRAME_BYTE
argument_list|(
name|max_blue_values
argument_list|)
block|,
name|FT_FRAME_BYTE
argument_list|(
name|max_x_orus
argument_list|)
block|,
name|FT_FRAME_BYTE
argument_list|(
name|max_y_orus
argument_list|)
block|,
name|FT_FRAME_BYTE
argument_list|(
name|phy_font_max_size_high
argument_list|)
block|,
name|FT_FRAME_BYTE
argument_list|(
name|color_flags
argument_list|)
block|,
name|FT_FRAME_UOFF3
argument_list|(
name|bct_max_size
argument_list|)
block|,
name|FT_FRAME_UOFF3
argument_list|(
name|bct_set_max_size
argument_list|)
block|,
name|FT_FRAME_UOFF3
argument_list|(
name|phy_bct_set_max_size
argument_list|)
block|,
name|FT_FRAME_USHORT
argument_list|(
name|num_phy_fonts
argument_list|)
block|,
name|FT_FRAME_BYTE
argument_list|(
name|max_vert_stem_snap
argument_list|)
block|,
name|FT_FRAME_BYTE
argument_list|(
name|max_horz_stem_snap
argument_list|)
block|,
name|FT_FRAME_USHORT
argument_list|(
name|max_chars
argument_list|)
block|,
name|FT_FRAME_END
block|}
decl_stmt|;
end_decl_stmt
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|pfr_header_load
argument_list|(
argument|PFR_Header  header
argument_list|,
argument|FT_Stream   stream
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
decl_stmt|;
comment|/* read header directly */
if|if
condition|(
operator|!
name|FT_STREAM_SEEK
argument_list|(
literal|0
argument_list|)
operator|&&
operator|!
name|FT_STREAM_READ_FIELDS
argument_list|(
name|pfr_header_fields
argument_list|,
name|header
argument_list|)
condition|)
block|{
comment|/* make a few adjustments to the header */
name|header
operator|->
name|phy_font_max_size
operator|+=
operator|(
name|FT_UInt32
operator|)
name|header
operator|->
name|phy_font_max_size_high
operator|<<
literal|16
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_block
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Bool
argument_list|)
end_macro
begin_macro
name|pfr_header_check
argument_list|(
argument|PFR_Header  header
argument_list|)
end_macro
begin_block
block|{
name|FT_Bool
name|result
init|=
literal|1
decl_stmt|;
comment|/* check signature and header size */
if|if
condition|(
name|header
operator|->
name|signature
operator|!=
literal|0x50465230L
operator|||
comment|/* "PFR0" */
name|header
operator|->
name|version
operator|>
literal|4
operator|||
name|header
operator|->
name|header_size
operator|<
literal|58
operator|||
name|header
operator|->
name|signature2
operator|!=
literal|0x0d0a
condition|)
comment|/* CR/LF  */
block|{
name|result
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_block
begin_comment
comment|/***********************************************************************/
end_comment
begin_comment
comment|/***********************************************************************/
end_comment
begin_comment
comment|/*****                                                             *****/
end_comment
begin_comment
comment|/*****                    PFR LOGICAL FONTS                        *****/
end_comment
begin_comment
comment|/*****                                                             *****/
end_comment
begin_comment
comment|/***********************************************************************/
end_comment
begin_comment
comment|/***********************************************************************/
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|pfr_log_font_count
argument_list|(
argument|FT_Stream  stream
argument_list|,
argument|FT_UInt32  section_offset
argument_list|,
argument|FT_UInt   *acount
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
decl_stmt|;
name|FT_UInt
name|count
decl_stmt|;
name|FT_UInt
name|result
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|FT_STREAM_SEEK
argument_list|(
name|section_offset
argument_list|)
operator|||
name|FT_READ_USHORT
argument_list|(
name|count
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|result
operator|=
name|count
expr_stmt|;
name|Exit
label|:
operator|*
name|acount
operator|=
name|result
expr_stmt|;
return|return
name|error
return|;
block|}
end_block
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|pfr_log_font_load
argument_list|(
argument|PFR_LogFont  log_font
argument_list|,
argument|FT_Stream    stream
argument_list|,
argument|FT_UInt      idx
argument_list|,
argument|FT_UInt32    section_offset
argument_list|,
argument|FT_Bool      size_increment
argument_list|)
end_macro
begin_block
block|{
name|FT_UInt
name|num_log_fonts
decl_stmt|;
name|FT_UInt
name|flags
decl_stmt|;
name|FT_UInt32
name|offset
decl_stmt|;
name|FT_UInt32
name|size
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
if|if
condition|(
name|FT_STREAM_SEEK
argument_list|(
name|section_offset
argument_list|)
operator|||
name|FT_READ_USHORT
argument_list|(
name|num_log_fonts
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
if|if
condition|(
name|idx
operator|>=
name|num_log_fonts
condition|)
return|return
name|PFR_Err_Invalid_Argument
return|;
if|if
condition|(
name|FT_STREAM_SKIP
argument_list|(
name|idx
operator|*
literal|5
argument_list|)
operator|||
name|FT_READ_USHORT
argument_list|(
name|size
argument_list|)
operator|||
name|FT_READ_UOFF3
argument_list|(
name|offset
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
comment|/* save logical font size and offset */
name|log_font
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|log_font
operator|->
name|offset
operator|=
name|offset
expr_stmt|;
comment|/* now, check the rest of the table before loading it */
block|{
name|FT_Byte
modifier|*
name|p
decl_stmt|;
name|FT_Byte
modifier|*
name|limit
decl_stmt|;
name|FT_UInt
name|local
decl_stmt|;
if|if
condition|(
name|FT_STREAM_SEEK
argument_list|(
name|offset
argument_list|)
operator|||
name|FT_FRAME_ENTER
argument_list|(
name|size
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|p
operator|=
name|stream
operator|->
name|cursor
expr_stmt|;
name|limit
operator|=
name|p
operator|+
name|size
expr_stmt|;
name|PFR_CHECK
argument_list|(
literal|13
argument_list|)
expr_stmt|;
name|log_font
operator|->
name|matrix
index|[
literal|0
index|]
operator|=
name|PFR_NEXT_LONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|log_font
operator|->
name|matrix
index|[
literal|1
index|]
operator|=
name|PFR_NEXT_LONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|log_font
operator|->
name|matrix
index|[
literal|2
index|]
operator|=
name|PFR_NEXT_LONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|log_font
operator|->
name|matrix
index|[
literal|3
index|]
operator|=
name|PFR_NEXT_LONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|flags
operator|=
name|PFR_NEXT_BYTE
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|local
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|PFR_LOG_STROKE
condition|)
block|{
name|local
operator|++
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|PFR_LOG_2BYTE_STROKE
condition|)
name|local
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|PFR_LINE_JOIN_MASK
operator|)
operator|==
name|PFR_LINE_JOIN_MITER
condition|)
name|local
operator|+=
literal|3
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|PFR_LOG_BOLD
condition|)
block|{
name|local
operator|++
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|PFR_LOG_2BYTE_BOLD
condition|)
name|local
operator|++
expr_stmt|;
block|}
name|PFR_CHECK
argument_list|(
name|local
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|PFR_LOG_STROKE
condition|)
block|{
name|log_font
operator|->
name|stroke_thickness
operator|=
operator|(
name|flags
operator|&
name|PFR_LOG_2BYTE_STROKE
operator|)
condition|?
name|PFR_NEXT_SHORT
argument_list|(
name|p
argument_list|)
else|:
name|PFR_NEXT_BYTE
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|PFR_LINE_JOIN_MASK
operator|)
operator|==
name|PFR_LINE_JOIN_MITER
condition|)
name|log_font
operator|->
name|miter_limit
operator|=
name|PFR_NEXT_LONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|PFR_LOG_BOLD
condition|)
block|{
name|log_font
operator|->
name|bold_thickness
operator|=
operator|(
name|flags
operator|&
name|PFR_LOG_2BYTE_BOLD
operator|)
condition|?
name|PFR_NEXT_SHORT
argument_list|(
name|p
argument_list|)
else|:
name|PFR_NEXT_BYTE
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|PFR_LOG_EXTRA_ITEMS
condition|)
block|{
name|error
operator|=
name|pfr_extra_items_skip
argument_list|(
operator|&
name|p
argument_list|,
name|limit
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Fail
goto|;
block|}
name|PFR_CHECK
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|log_font
operator|->
name|phys_size
operator|=
name|PFR_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|log_font
operator|->
name|phys_offset
operator|=
name|PFR_NEXT_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|size_increment
condition|)
block|{
name|PFR_CHECK
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|log_font
operator|->
name|phys_size
operator|+=
operator|(
name|FT_UInt32
operator|)
name|PFR_NEXT_BYTE
argument_list|(
name|p
argument_list|)
operator|<<
literal|16
expr_stmt|;
block|}
block|}
name|Fail
label|:
name|FT_FRAME_EXIT
argument_list|()
expr_stmt|;
name|Exit
label|:
return|return
name|error
return|;
name|Too_Short
label|:
name|FT_ERROR
argument_list|(
operator|(
literal|"pfr_log_font_load: invalid logical font table\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|PFR_Err_Invalid_Table
expr_stmt|;
goto|goto
name|Fail
goto|;
block|}
end_block
begin_comment
comment|/***********************************************************************/
end_comment
begin_comment
comment|/***********************************************************************/
end_comment
begin_comment
comment|/*****                                                             *****/
end_comment
begin_comment
comment|/*****                    PFR PHYSICAL FONTS                       *****/
end_comment
begin_comment
comment|/*****                                                             *****/
end_comment
begin_comment
comment|/***********************************************************************/
end_comment
begin_comment
comment|/***********************************************************************/
end_comment
begin_comment
comment|/* load bitmap strikes lists */
end_comment
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|pfr_extra_item_load_bitmap_info
argument_list|(
argument|FT_Byte*     p
argument_list|,
argument|FT_Byte*     limit
argument_list|,
argument|PFR_PhyFont  phy_font
argument_list|)
end_macro
begin_block
block|{
name|FT_Memory
name|memory
init|=
name|phy_font
operator|->
name|memory
decl_stmt|;
name|PFR_Strike
name|strike
decl_stmt|;
name|FT_UInt
name|flags0
decl_stmt|;
name|FT_UInt
name|n
decl_stmt|,
name|count
decl_stmt|,
name|size1
decl_stmt|;
name|FT_Error
name|error
init|=
literal|0
decl_stmt|;
name|PFR_CHECK
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|3
expr_stmt|;
comment|/* skip bctSize */
name|flags0
operator|=
name|PFR_NEXT_BYTE
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|count
operator|=
name|PFR_NEXT_BYTE
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* re-allocate when needed */
if|if
condition|(
name|phy_font
operator|->
name|num_strikes
operator|+
name|count
operator|>
name|phy_font
operator|->
name|max_strikes
condition|)
block|{
name|FT_UInt
name|new_max
init|=
name|FT_PAD_CEIL
argument_list|(
name|phy_font
operator|->
name|num_strikes
operator|+
name|count
argument_list|,
literal|4
argument_list|)
decl_stmt|;
if|if
condition|(
name|FT_RENEW_ARRAY
argument_list|(
name|phy_font
operator|->
name|strikes
argument_list|,
name|phy_font
operator|->
name|num_strikes
argument_list|,
name|new_max
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|phy_font
operator|->
name|max_strikes
operator|=
name|new_max
expr_stmt|;
block|}
name|size1
operator|=
literal|1
operator|+
literal|1
operator|+
literal|1
operator|+
literal|2
operator|+
literal|2
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|flags0
operator|&
name|PFR_STRIKE_2BYTE_XPPM
condition|)
name|size1
operator|++
expr_stmt|;
if|if
condition|(
name|flags0
operator|&
name|PFR_STRIKE_2BYTE_YPPM
condition|)
name|size1
operator|++
expr_stmt|;
if|if
condition|(
name|flags0
operator|&
name|PFR_STRIKE_3BYTE_SIZE
condition|)
name|size1
operator|++
expr_stmt|;
if|if
condition|(
name|flags0
operator|&
name|PFR_STRIKE_3BYTE_OFFSET
condition|)
name|size1
operator|++
expr_stmt|;
if|if
condition|(
name|flags0
operator|&
name|PFR_STRIKE_2BYTE_COUNT
condition|)
name|size1
operator|++
expr_stmt|;
name|strike
operator|=
name|phy_font
operator|->
name|strikes
operator|+
name|phy_font
operator|->
name|num_strikes
expr_stmt|;
name|PFR_CHECK
argument_list|(
name|count
operator|*
name|size1
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
operator|,
name|strike
operator|++
control|)
block|{
name|strike
operator|->
name|x_ppm
operator|=
operator|(
name|flags0
operator|&
name|PFR_STRIKE_2BYTE_XPPM
operator|)
condition|?
name|PFR_NEXT_USHORT
argument_list|(
name|p
argument_list|)
else|:
name|PFR_NEXT_BYTE
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|strike
operator|->
name|y_ppm
operator|=
operator|(
name|flags0
operator|&
name|PFR_STRIKE_2BYTE_YPPM
operator|)
condition|?
name|PFR_NEXT_USHORT
argument_list|(
name|p
argument_list|)
else|:
name|PFR_NEXT_BYTE
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|strike
operator|->
name|flags
operator|=
name|PFR_NEXT_BYTE
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|strike
operator|->
name|bct_size
operator|=
operator|(
name|flags0
operator|&
name|PFR_STRIKE_3BYTE_SIZE
operator|)
condition|?
name|PFR_NEXT_ULONG
argument_list|(
name|p
argument_list|)
else|:
name|PFR_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|strike
operator|->
name|bct_offset
operator|=
operator|(
name|flags0
operator|&
name|PFR_STRIKE_3BYTE_OFFSET
operator|)
condition|?
name|PFR_NEXT_ULONG
argument_list|(
name|p
argument_list|)
else|:
name|PFR_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|strike
operator|->
name|num_bitmaps
operator|=
operator|(
name|flags0
operator|&
name|PFR_STRIKE_2BYTE_COUNT
operator|)
condition|?
name|PFR_NEXT_USHORT
argument_list|(
name|p
argument_list|)
else|:
name|PFR_NEXT_BYTE
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|phy_font
operator|->
name|num_strikes
operator|+=
name|count
expr_stmt|;
name|Exit
label|:
return|return
name|error
return|;
name|Too_Short
label|:
name|error
operator|=
name|PFR_Err_Invalid_Table
expr_stmt|;
name|FT_ERROR
argument_list|(
operator|(
literal|"pfr_extra_item_load_bitmap_info:"
literal|" invalid bitmap info table\n"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
end_block
begin_comment
comment|/* Load font ID.  This is a so-called "unique" name that is rather    * long and descriptive (like "Tiresias ScreenFont v7.51").    *    * Note that a PFR font's family name is contained in an *undocumented*    * string of the "auxiliary data" portion of a physical font record.  This    * may also contain the "real" style name!    *    * If no family name is present, the font ID is used instead for the    * family.    */
end_comment
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|pfr_extra_item_load_font_id
argument_list|(
argument|FT_Byte*     p
argument_list|,
argument|FT_Byte*     limit
argument_list|,
argument|PFR_PhyFont  phy_font
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
init|=
literal|0
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|phy_font
operator|->
name|memory
decl_stmt|;
name|FT_PtrDist
name|len
init|=
name|limit
operator|-
name|p
decl_stmt|;
if|if
condition|(
name|phy_font
operator|->
name|font_id
operator|!=
name|NULL
condition|)
goto|goto
name|Exit
goto|;
if|if
condition|(
name|FT_ALLOC
argument_list|(
name|phy_font
operator|->
name|font_id
argument_list|,
name|len
operator|+
literal|1
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
comment|/* copy font ID name, and terminate it for safety */
name|FT_MEM_COPY
argument_list|(
name|phy_font
operator|->
name|font_id
argument_list|,
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|phy_font
operator|->
name|font_id
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
name|Exit
label|:
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/* load stem snap tables */
end_comment
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|pfr_extra_item_load_stem_snaps
argument_list|(
argument|FT_Byte*     p
argument_list|,
argument|FT_Byte*     limit
argument_list|,
argument|PFR_PhyFont  phy_font
argument_list|)
end_macro
begin_block
block|{
name|FT_UInt
name|count
decl_stmt|,
name|num_vert
decl_stmt|,
name|num_horz
decl_stmt|;
name|FT_Int
modifier|*
name|snaps
decl_stmt|;
name|FT_Error
name|error
init|=
literal|0
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|phy_font
operator|->
name|memory
decl_stmt|;
if|if
condition|(
name|phy_font
operator|->
name|vertical
operator|.
name|stem_snaps
operator|!=
name|NULL
condition|)
goto|goto
name|Exit
goto|;
name|PFR_CHECK
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|count
operator|=
name|PFR_NEXT_BYTE
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|num_vert
operator|=
name|count
operator|&
literal|15
expr_stmt|;
name|num_horz
operator|=
name|count
operator|>>
literal|4
expr_stmt|;
name|count
operator|=
name|num_vert
operator|+
name|num_horz
expr_stmt|;
name|PFR_CHECK
argument_list|(
name|count
operator|*
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|snaps
argument_list|,
name|count
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|phy_font
operator|->
name|vertical
operator|.
name|stem_snaps
operator|=
name|snaps
expr_stmt|;
name|phy_font
operator|->
name|horizontal
operator|.
name|stem_snaps
operator|=
name|snaps
operator|+
name|num_vert
expr_stmt|;
for|for
control|(
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
operator|,
name|snaps
operator|++
control|)
operator|*
name|snaps
operator|=
name|FT_NEXT_SHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|Exit
label|:
return|return
name|error
return|;
name|Too_Short
label|:
name|error
operator|=
name|PFR_Err_Invalid_Table
expr_stmt|;
name|FT_ERROR
argument_list|(
operator|(
literal|"pfr_exta_item_load_stem_snaps:"
literal|" invalid stem snaps table\n"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
end_block
begin_comment
comment|/* load kerning pair data */
end_comment
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|pfr_extra_item_load_kerning_pairs
argument_list|(
argument|FT_Byte*     p
argument_list|,
argument|FT_Byte*     limit
argument_list|,
argument|PFR_PhyFont  phy_font
argument_list|)
end_macro
begin_block
block|{
name|PFR_KernItem
name|item
decl_stmt|;
name|FT_Error
name|error
init|=
literal|0
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|phy_font
operator|->
name|memory
decl_stmt|;
name|FT_TRACE2
argument_list|(
operator|(
literal|"pfr_extra_item_load_kerning_pairs()\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|FT_NEW
argument_list|(
name|item
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|PFR_CHECK
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|item
operator|->
name|pair_count
operator|=
name|PFR_NEXT_BYTE
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|item
operator|->
name|base_adj
operator|=
name|PFR_NEXT_SHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|item
operator|->
name|flags
operator|=
name|PFR_NEXT_BYTE
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|item
operator|->
name|offset
operator|=
name|phy_font
operator|->
name|offset
operator|+
operator|(
name|p
operator|-
name|phy_font
operator|->
name|cursor
operator|)
expr_stmt|;
ifndef|#
directive|ifndef
name|PFR_CONFIG_NO_CHECKS
name|item
operator|->
name|pair_size
operator|=
literal|3
expr_stmt|;
if|if
condition|(
name|item
operator|->
name|flags
operator|&
name|PFR_KERN_2BYTE_CHAR
condition|)
name|item
operator|->
name|pair_size
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|item
operator|->
name|flags
operator|&
name|PFR_KERN_2BYTE_ADJ
condition|)
name|item
operator|->
name|pair_size
operator|+=
literal|1
expr_stmt|;
name|PFR_CHECK
argument_list|(
name|item
operator|->
name|pair_count
operator|*
name|item
operator|->
name|pair_size
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* load first and last pairs into the item to speed up */
comment|/* lookup later...                                     */
if|if
condition|(
name|item
operator|->
name|pair_count
operator|>
literal|0
condition|)
block|{
name|FT_UInt
name|char1
decl_stmt|,
name|char2
decl_stmt|;
name|FT_Byte
modifier|*
name|q
decl_stmt|;
if|if
condition|(
name|item
operator|->
name|flags
operator|&
name|PFR_KERN_2BYTE_CHAR
condition|)
block|{
name|q
operator|=
name|p
expr_stmt|;
name|char1
operator|=
name|PFR_NEXT_USHORT
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|char2
operator|=
name|PFR_NEXT_USHORT
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|item
operator|->
name|pair1
operator|=
name|PFR_KERN_INDEX
argument_list|(
name|char1
argument_list|,
name|char2
argument_list|)
expr_stmt|;
name|q
operator|=
name|p
operator|+
name|item
operator|->
name|pair_size
operator|*
operator|(
name|item
operator|->
name|pair_count
operator|-
literal|1
operator|)
expr_stmt|;
name|char1
operator|=
name|PFR_NEXT_USHORT
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|char2
operator|=
name|PFR_NEXT_USHORT
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|item
operator|->
name|pair2
operator|=
name|PFR_KERN_INDEX
argument_list|(
name|char1
argument_list|,
name|char2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|q
operator|=
name|p
expr_stmt|;
name|char1
operator|=
name|PFR_NEXT_BYTE
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|char2
operator|=
name|PFR_NEXT_BYTE
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|item
operator|->
name|pair1
operator|=
name|PFR_KERN_INDEX
argument_list|(
name|char1
argument_list|,
name|char2
argument_list|)
expr_stmt|;
name|q
operator|=
name|p
operator|+
name|item
operator|->
name|pair_size
operator|*
operator|(
name|item
operator|->
name|pair_count
operator|-
literal|1
operator|)
expr_stmt|;
name|char1
operator|=
name|PFR_NEXT_BYTE
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|char2
operator|=
name|PFR_NEXT_BYTE
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|item
operator|->
name|pair2
operator|=
name|PFR_KERN_INDEX
argument_list|(
name|char1
argument_list|,
name|char2
argument_list|)
expr_stmt|;
block|}
comment|/* add new item to the current list */
name|item
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
operator|*
name|phy_font
operator|->
name|kern_items_tail
operator|=
name|item
expr_stmt|;
name|phy_font
operator|->
name|kern_items_tail
operator|=
operator|&
name|item
operator|->
name|next
expr_stmt|;
name|phy_font
operator|->
name|num_kern_pairs
operator|+=
name|item
operator|->
name|pair_count
expr_stmt|;
block|}
else|else
block|{
comment|/* empty item! */
name|FT_FREE
argument_list|(
name|item
argument_list|)
expr_stmt|;
block|}
name|Exit
label|:
return|return
name|error
return|;
name|Too_Short
label|:
name|FT_FREE
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|error
operator|=
name|PFR_Err_Invalid_Table
expr_stmt|;
name|FT_ERROR
argument_list|(
operator|(
literal|"pfr_extra_item_load_kerning_pairs:"
literal|" invalid kerning pairs table\n"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
end_block
begin_decl_stmt
DECL|variable|pfr_phy_font_extra_items
specifier|static
specifier|const
name|PFR_ExtraItemRec
name|pfr_phy_font_extra_items
index|[]
init|=
block|{
block|{
literal|1
block|,
operator|(
name|PFR_ExtraItem_ParseFunc
operator|)
name|pfr_extra_item_load_bitmap_info
block|}
block|,
block|{
literal|2
block|,
operator|(
name|PFR_ExtraItem_ParseFunc
operator|)
name|pfr_extra_item_load_font_id
block|}
block|,
block|{
literal|3
block|,
operator|(
name|PFR_ExtraItem_ParseFunc
operator|)
name|pfr_extra_item_load_stem_snaps
block|}
block|,
block|{
literal|4
block|,
operator|(
name|PFR_ExtraItem_ParseFunc
operator|)
name|pfr_extra_item_load_kerning_pairs
block|}
block|,
block|{
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* Loads a name from the auxiliary data.  Since this extracts undocumented    * strings from the font file, we need to be careful here.    */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|pfr_aux_name_load
name|pfr_aux_name_load
parameter_list|(
name|FT_Byte
modifier|*
name|p
parameter_list|,
name|FT_UInt
name|len
parameter_list|,
name|FT_Memory
name|memory
parameter_list|,
name|FT_String
modifier|*
modifier|*
name|astring
parameter_list|)
block|{
name|FT_Error
name|error
init|=
literal|0
decl_stmt|;
name|FT_String
modifier|*
name|result
init|=
name|NULL
decl_stmt|;
name|FT_UInt
name|n
decl_stmt|,
name|ok
decl_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
operator|&&
name|p
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|0
condition|)
name|len
operator|--
expr_stmt|;
comment|/* check that each character is ASCII for making sure not to        load garbage      */
name|ok
operator|=
operator|(
name|len
operator|>
literal|0
operator|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|len
condition|;
name|n
operator|++
control|)
if|if
condition|(
name|p
index|[
name|n
index|]
operator|<
literal|32
operator|||
name|p
index|[
name|n
index|]
operator|>
literal|127
condition|)
block|{
name|ok
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ok
condition|)
block|{
if|if
condition|(
name|FT_ALLOC
argument_list|(
name|result
argument_list|,
name|len
operator|+
literal|1
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|FT_MEM_COPY
argument_list|(
name|result
argument_list|,
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|result
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|Exit
label|:
operator|*
name|astring
operator|=
name|result
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|pfr_phy_font_done
name|pfr_phy_font_done
argument_list|(
argument|PFR_PhyFont  phy_font
argument_list|,
argument|FT_Memory    memory
argument_list|)
end_macro
begin_block
block|{
name|FT_FREE
argument_list|(
name|phy_font
operator|->
name|font_id
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|phy_font
operator|->
name|family_name
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|phy_font
operator|->
name|style_name
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|phy_font
operator|->
name|vertical
operator|.
name|stem_snaps
argument_list|)
expr_stmt|;
name|phy_font
operator|->
name|vertical
operator|.
name|num_stem_snaps
operator|=
literal|0
expr_stmt|;
name|phy_font
operator|->
name|horizontal
operator|.
name|stem_snaps
operator|=
name|NULL
expr_stmt|;
name|phy_font
operator|->
name|horizontal
operator|.
name|num_stem_snaps
operator|=
literal|0
expr_stmt|;
name|FT_FREE
argument_list|(
name|phy_font
operator|->
name|strikes
argument_list|)
expr_stmt|;
name|phy_font
operator|->
name|num_strikes
operator|=
literal|0
expr_stmt|;
name|phy_font
operator|->
name|max_strikes
operator|=
literal|0
expr_stmt|;
name|FT_FREE
argument_list|(
name|phy_font
operator|->
name|chars
argument_list|)
expr_stmt|;
name|phy_font
operator|->
name|num_chars
operator|=
literal|0
expr_stmt|;
name|phy_font
operator|->
name|chars_offset
operator|=
literal|0
expr_stmt|;
name|FT_FREE
argument_list|(
name|phy_font
operator|->
name|blue_values
argument_list|)
expr_stmt|;
name|phy_font
operator|->
name|num_blue_values
operator|=
literal|0
expr_stmt|;
block|{
name|PFR_KernItem
name|item
decl_stmt|,
name|next
decl_stmt|;
name|item
operator|=
name|phy_font
operator|->
name|kern_items
expr_stmt|;
while|while
condition|(
name|item
condition|)
block|{
name|next
operator|=
name|item
operator|->
name|next
expr_stmt|;
name|FT_FREE
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|item
operator|=
name|next
expr_stmt|;
block|}
name|phy_font
operator|->
name|kern_items
operator|=
name|NULL
expr_stmt|;
name|phy_font
operator|->
name|kern_items_tail
operator|=
name|NULL
expr_stmt|;
block|}
name|phy_font
operator|->
name|num_kern_pairs
operator|=
literal|0
expr_stmt|;
block|}
end_block
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|pfr_phy_font_load
argument_list|(
argument|PFR_PhyFont  phy_font
argument_list|,
argument|FT_Stream    stream
argument_list|,
argument|FT_UInt32    offset
argument_list|,
argument|FT_UInt32    size
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|stream
operator|->
name|memory
decl_stmt|;
name|FT_UInt
name|flags
decl_stmt|;
name|FT_ULong
name|num_aux
decl_stmt|;
name|FT_Byte
modifier|*
name|p
decl_stmt|;
name|FT_Byte
modifier|*
name|limit
decl_stmt|;
name|phy_font
operator|->
name|memory
operator|=
name|memory
expr_stmt|;
name|phy_font
operator|->
name|offset
operator|=
name|offset
expr_stmt|;
name|phy_font
operator|->
name|kern_items
operator|=
name|NULL
expr_stmt|;
name|phy_font
operator|->
name|kern_items_tail
operator|=
operator|&
name|phy_font
operator|->
name|kern_items
expr_stmt|;
if|if
condition|(
name|FT_STREAM_SEEK
argument_list|(
name|offset
argument_list|)
operator|||
name|FT_FRAME_ENTER
argument_list|(
name|size
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|phy_font
operator|->
name|cursor
operator|=
name|stream
operator|->
name|cursor
expr_stmt|;
name|p
operator|=
name|stream
operator|->
name|cursor
expr_stmt|;
name|limit
operator|=
name|p
operator|+
name|size
expr_stmt|;
name|PFR_CHECK
argument_list|(
literal|15
argument_list|)
expr_stmt|;
name|phy_font
operator|->
name|font_ref_number
operator|=
name|PFR_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|phy_font
operator|->
name|outline_resolution
operator|=
name|PFR_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|phy_font
operator|->
name|metrics_resolution
operator|=
name|PFR_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|phy_font
operator|->
name|bbox
operator|.
name|xMin
operator|=
name|PFR_NEXT_SHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|phy_font
operator|->
name|bbox
operator|.
name|yMin
operator|=
name|PFR_NEXT_SHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|phy_font
operator|->
name|bbox
operator|.
name|xMax
operator|=
name|PFR_NEXT_SHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|phy_font
operator|->
name|bbox
operator|.
name|yMax
operator|=
name|PFR_NEXT_SHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|phy_font
operator|->
name|flags
operator|=
name|flags
operator|=
name|PFR_NEXT_BYTE
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* get the standard advance for non-proportional fonts */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|PFR_PHY_PROPORTIONAL
operator|)
condition|)
block|{
name|PFR_CHECK
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|phy_font
operator|->
name|standard_advance
operator|=
name|PFR_NEXT_SHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
comment|/* load the extra items when present */
if|if
condition|(
name|flags
operator|&
name|PFR_PHY_EXTRA_ITEMS
condition|)
block|{
name|error
operator|=
name|pfr_extra_items_parse
argument_list|(
operator|&
name|p
argument_list|,
name|limit
argument_list|,
name|pfr_phy_font_extra_items
argument_list|,
name|phy_font
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Fail
goto|;
block|}
comment|/* In certain fonts, the auxiliary bytes contain interesting  */
comment|/* information. These are not in the specification but can be */
comment|/* guessed by looking at the content of a few PFR0 fonts.     */
name|PFR_CHECK
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|num_aux
operator|=
name|PFR_NEXT_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_aux
operator|>
literal|0
condition|)
block|{
name|FT_Byte
modifier|*
name|q
init|=
name|p
decl_stmt|;
name|FT_Byte
modifier|*
name|q2
decl_stmt|;
name|PFR_CHECK
argument_list|(
name|num_aux
argument_list|)
expr_stmt|;
name|p
operator|+=
name|num_aux
expr_stmt|;
while|while
condition|(
name|num_aux
operator|>
literal|0
condition|)
block|{
name|FT_UInt
name|length
decl_stmt|,
name|type
decl_stmt|;
if|if
condition|(
name|q
operator|+
literal|4
operator|>
name|p
condition|)
break|break;
name|length
operator|=
name|PFR_NEXT_USHORT
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|<
literal|4
operator|||
name|length
operator|>
name|num_aux
condition|)
break|break;
name|q2
operator|=
name|q
operator|+
name|length
operator|-
literal|2
expr_stmt|;
name|type
operator|=
name|PFR_NEXT_USHORT
argument_list|(
name|q
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|1
case|:
comment|/* this seems to correspond to the font's family name,            * padded to 16-bits with one zero when necessary            */
name|error
operator|=
name|pfr_aux_name_load
argument_list|(
name|q
argument_list|,
name|length
operator|-
literal|4U
argument_list|,
name|memory
argument_list|,
operator|&
name|phy_font
operator|->
name|family_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
break|break;
case|case
literal|2
case|:
if|if
condition|(
name|q
operator|+
literal|32
operator|>
name|q2
condition|)
break|break;
name|q
operator|+=
literal|10
expr_stmt|;
name|phy_font
operator|->
name|ascent
operator|=
name|PFR_NEXT_SHORT
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|phy_font
operator|->
name|descent
operator|=
name|PFR_NEXT_SHORT
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|phy_font
operator|->
name|leading
operator|=
name|PFR_NEXT_SHORT
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|q
operator|+=
literal|16
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* this seems to correspond to the font's style name,            * padded to 16-bits with one zero when necessary            */
name|error
operator|=
name|pfr_aux_name_load
argument_list|(
name|q
argument_list|,
name|length
operator|-
literal|4U
argument_list|,
name|memory
argument_list|,
operator|&
name|phy_font
operator|->
name|style_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
break|break;
default|default:
empty_stmt|;
block|}
name|q
operator|=
name|q2
expr_stmt|;
name|num_aux
operator|-=
name|length
expr_stmt|;
block|}
block|}
comment|/* read the blue values */
block|{
name|FT_UInt
name|n
decl_stmt|,
name|count
decl_stmt|;
name|PFR_CHECK
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|phy_font
operator|->
name|num_blue_values
operator|=
name|count
operator|=
name|PFR_NEXT_BYTE
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|PFR_CHECK
argument_list|(
name|count
operator|*
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|phy_font
operator|->
name|blue_values
argument_list|,
name|count
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
name|phy_font
operator|->
name|blue_values
index|[
name|n
index|]
operator|=
name|PFR_NEXT_SHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|PFR_CHECK
argument_list|(
literal|8
argument_list|)
expr_stmt|;
name|phy_font
operator|->
name|blue_fuzz
operator|=
name|PFR_NEXT_BYTE
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|phy_font
operator|->
name|blue_scale
operator|=
name|PFR_NEXT_BYTE
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|phy_font
operator|->
name|vertical
operator|.
name|standard
operator|=
name|PFR_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|phy_font
operator|->
name|horizontal
operator|.
name|standard
operator|=
name|PFR_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* read the character descriptors */
block|{
name|FT_UInt
name|n
decl_stmt|,
name|count
decl_stmt|,
name|Size
decl_stmt|;
name|phy_font
operator|->
name|num_chars
operator|=
name|count
operator|=
name|PFR_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|phy_font
operator|->
name|chars_offset
operator|=
name|offset
operator|+
operator|(
name|p
operator|-
name|stream
operator|->
name|cursor
operator|)
expr_stmt|;
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|phy_font
operator|->
name|chars
argument_list|,
name|count
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
name|Size
operator|=
literal|1
operator|+
literal|1
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|PFR_PHY_2BYTE_CHARCODE
condition|)
name|Size
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|PFR_PHY_PROPORTIONAL
condition|)
name|Size
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|PFR_PHY_ASCII_CODE
condition|)
name|Size
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|PFR_PHY_2BYTE_GPS_SIZE
condition|)
name|Size
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|PFR_PHY_3BYTE_GPS_OFFSET
condition|)
name|Size
operator|+=
literal|1
expr_stmt|;
name|PFR_CHECK
argument_list|(
name|count
operator|*
name|Size
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
block|{
name|PFR_Char
name|cur
init|=
operator|&
name|phy_font
operator|->
name|chars
index|[
name|n
index|]
decl_stmt|;
name|cur
operator|->
name|char_code
operator|=
operator|(
name|flags
operator|&
name|PFR_PHY_2BYTE_CHARCODE
operator|)
condition|?
name|PFR_NEXT_USHORT
argument_list|(
name|p
argument_list|)
else|:
name|PFR_NEXT_BYTE
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|cur
operator|->
name|advance
operator|=
operator|(
name|flags
operator|&
name|PFR_PHY_PROPORTIONAL
operator|)
condition|?
name|PFR_NEXT_SHORT
argument_list|(
name|p
argument_list|)
else|:
operator|(
name|FT_Int
operator|)
name|phy_font
operator|->
name|standard_advance
expr_stmt|;
if|#
directive|if
literal|0
block|cur->ascii     = ( flags& PFR_PHY_ASCII_CODE )                          ? PFR_NEXT_BYTE( p )                          : 0;
else|#
directive|else
if|if
condition|(
name|flags
operator|&
name|PFR_PHY_ASCII_CODE
condition|)
name|p
operator|+=
literal|1
expr_stmt|;
endif|#
directive|endif
name|cur
operator|->
name|gps_size
operator|=
operator|(
name|flags
operator|&
name|PFR_PHY_2BYTE_GPS_SIZE
operator|)
condition|?
name|PFR_NEXT_USHORT
argument_list|(
name|p
argument_list|)
else|:
name|PFR_NEXT_BYTE
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|cur
operator|->
name|gps_offset
operator|=
operator|(
name|flags
operator|&
name|PFR_PHY_3BYTE_GPS_OFFSET
operator|)
condition|?
name|PFR_NEXT_ULONG
argument_list|(
name|p
argument_list|)
else|:
name|PFR_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* that's it! */
name|Fail
label|:
name|FT_FRAME_EXIT
argument_list|()
expr_stmt|;
comment|/* save position of bitmap info */
name|phy_font
operator|->
name|bct_offset
operator|=
name|FT_STREAM_POS
argument_list|()
expr_stmt|;
name|phy_font
operator|->
name|cursor
operator|=
name|NULL
expr_stmt|;
name|Exit
label|:
return|return
name|error
return|;
name|Too_Short
label|:
name|error
operator|=
name|PFR_Err_Invalid_Table
expr_stmt|;
name|FT_ERROR
argument_list|(
operator|(
literal|"pfr_phy_font_load: invalid physical font table\n"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|Fail
goto|;
block|}
end_block
begin_comment
comment|/* END */
end_comment
end_unit
