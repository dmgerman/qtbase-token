begin_unit
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  cf2ft.c                                                                */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*    FreeType Glue Component to Adobe's Interpreter (body).               */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  Copyright 2013-2014 Adobe Systems Incorporated.                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  This software, and all works of authorship, whether in source or       */
end_comment
begin_comment
comment|/*  object code form as indicated by the copyright notice(s) included      */
end_comment
begin_comment
comment|/*  herein (collectively, the "Work") is made available, and may only be   */
end_comment
begin_comment
comment|/*  used, modified, and distributed under the FreeType Project License,    */
end_comment
begin_comment
comment|/*  LICENSE.TXT.  Additionally, subject to the terms and conditions of the */
end_comment
begin_comment
comment|/*  FreeType Project License, each contributor to the Work hereby grants   */
end_comment
begin_comment
comment|/*  to any individual or legal entity exercising permissions granted by    */
end_comment
begin_comment
comment|/*  the FreeType Project License and this section (hereafter, "You" or     */
end_comment
begin_comment
comment|/*  "Your") a perpetual, worldwide, non-exclusive, no-charge,              */
end_comment
begin_comment
comment|/*  royalty-free, irrevocable (except as stated in this section) patent    */
end_comment
begin_comment
comment|/*  license to make, have made, use, offer to sell, sell, import, and      */
end_comment
begin_comment
comment|/*  otherwise transfer the Work, where such license applies only to those  */
end_comment
begin_comment
comment|/*  patent claims licensable by such contributor that are necessarily      */
end_comment
begin_comment
comment|/*  infringed by their contribution(s) alone or by combination of their    */
end_comment
begin_comment
comment|/*  contribution(s) with the Work to which such contribution(s) was        */
end_comment
begin_comment
comment|/*  submitted.  If You institute patent litigation against any entity      */
end_comment
begin_comment
comment|/*  (including a cross-claim or counterclaim in a lawsuit) alleging that   */
end_comment
begin_comment
comment|/*  the Work or a contribution incorporated within the Work constitutes    */
end_comment
begin_comment
comment|/*  direct or contributory patent infringement, then any patent licenses   */
end_comment
begin_comment
comment|/*  granted to You under this License for that Work shall terminate as of  */
end_comment
begin_comment
comment|/*  the date such litigation is filed.                                     */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  By using, modifying, or distributing the Work you indicate that you    */
end_comment
begin_comment
comment|/*  have read and understood the terms and conditions of the               */
end_comment
begin_comment
comment|/*  FreeType Project License as well as those provided in this section,    */
end_comment
begin_comment
comment|/*  and you accept them fully.                                             */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"cf2ft.h"
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_DEBUG_H
end_include
begin_include
include|#
directive|include
file|"cf2font.h"
end_include
begin_include
include|#
directive|include
file|"cf2error.h"
end_include
begin_define
DECL|macro|CF2_MAX_SIZE
define|#
directive|define
name|CF2_MAX_SIZE
value|cf2_intToFixed( 2000 )
end_define
begin_comment
DECL|macro|CF2_MAX_SIZE
comment|/* max ppem */
end_comment
begin_comment
comment|/*    * This check should avoid most internal overflow cases.  Clients should    * generally respond to `Glyph_Too_Big' by getting a glyph outline    * at EM size, scaling it and filling it as a graphics operation.    *    */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|cf2_checkTransform
name|cf2_checkTransform
parameter_list|(
specifier|const
name|CF2_Matrix
modifier|*
name|transform
parameter_list|,
name|CF2_Int
name|unitsPerEm
parameter_list|)
block|{
name|CF2_Fixed
name|maxScale
decl_stmt|;
name|FT_ASSERT
argument_list|(
name|unitsPerEm
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|transform
operator|->
name|a
operator|<=
literal|0
operator|||
name|transform
operator|->
name|d
operator|<=
literal|0
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_Size_Handle
argument_list|)
return|;
name|FT_ASSERT
argument_list|(
name|transform
operator|->
name|b
operator|==
literal|0
operator|&&
name|transform
operator|->
name|c
operator|==
literal|0
argument_list|)
expr_stmt|;
name|FT_ASSERT
argument_list|(
name|transform
operator|->
name|tx
operator|==
literal|0
operator|&&
name|transform
operator|->
name|ty
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|unitsPerEm
operator|>
literal|0x7FFF
condition|)
return|return
name|FT_THROW
argument_list|(
name|Glyph_Too_Big
argument_list|)
return|;
name|maxScale
operator|=
name|FT_DivFix
argument_list|(
name|CF2_MAX_SIZE
argument_list|,
name|cf2_intToFixed
argument_list|(
name|unitsPerEm
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|transform
operator|->
name|a
operator|>
name|maxScale
operator|||
name|transform
operator|->
name|d
operator|>
name|maxScale
condition|)
return|return
name|FT_THROW
argument_list|(
name|Glyph_Too_Big
argument_list|)
return|;
return|return
name|FT_Err_Ok
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|cf2_setGlyphWidth
name|cf2_setGlyphWidth
parameter_list|(
name|CF2_Outline
name|outline
parameter_list|,
name|CF2_Fixed
name|width
parameter_list|)
block|{
name|CFF_Decoder
modifier|*
name|decoder
init|=
name|outline
operator|->
name|decoder
decl_stmt|;
name|FT_ASSERT
argument_list|(
name|decoder
argument_list|)
expr_stmt|;
name|decoder
operator|->
name|glyph_width
operator|=
name|cf2_fixedToInt
argument_list|(
name|width
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* Clean up font instance. */
end_comment
begin_function
specifier|static
name|void
DECL|function|cf2_free_instance
name|cf2_free_instance
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|CF2_Font
name|font
init|=
operator|(
name|CF2_Font
operator|)
name|ptr
decl_stmt|;
if|if
condition|(
name|font
condition|)
block|{
name|FT_Memory
name|memory
init|=
name|font
operator|->
name|memory
decl_stmt|;
operator|(
name|void
operator|)
name|memory
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/********************************************/
end_comment
begin_comment
comment|/*                                          */
end_comment
begin_comment
comment|/* functions for handling client outline;   */
end_comment
begin_comment
comment|/* FreeType uses coordinates in 26.6 format */
end_comment
begin_comment
comment|/*                                          */
end_comment
begin_comment
comment|/********************************************/
end_comment
begin_function
specifier|static
name|void
DECL|function|cf2_builder_moveTo
name|cf2_builder_moveTo
parameter_list|(
name|CF2_OutlineCallbacks
name|callbacks
parameter_list|,
specifier|const
name|CF2_CallbackParams
name|params
parameter_list|)
block|{
comment|/* downcast the object pointer */
name|CF2_Outline
name|outline
init|=
operator|(
name|CF2_Outline
operator|)
name|callbacks
decl_stmt|;
name|CFF_Builder
modifier|*
name|builder
decl_stmt|;
operator|(
name|void
operator|)
name|params
expr_stmt|;
comment|/* only used in debug mode */
name|FT_ASSERT
argument_list|(
name|outline
operator|&&
name|outline
operator|->
name|decoder
argument_list|)
expr_stmt|;
name|FT_ASSERT
argument_list|(
name|params
operator|->
name|op
operator|==
name|CF2_PathOpMoveTo
argument_list|)
expr_stmt|;
name|builder
operator|=
operator|&
name|outline
operator|->
name|decoder
operator|->
name|builder
expr_stmt|;
comment|/* note: two successive moves simply close the contour twice */
name|cff_builder_close_contour
argument_list|(
name|builder
argument_list|)
expr_stmt|;
name|builder
operator|->
name|path_begun
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|cf2_builder_lineTo
name|cf2_builder_lineTo
parameter_list|(
name|CF2_OutlineCallbacks
name|callbacks
parameter_list|,
specifier|const
name|CF2_CallbackParams
name|params
parameter_list|)
block|{
name|FT_Error
name|error
decl_stmt|;
comment|/* downcast the object pointer */
name|CF2_Outline
name|outline
init|=
operator|(
name|CF2_Outline
operator|)
name|callbacks
decl_stmt|;
name|CFF_Builder
modifier|*
name|builder
decl_stmt|;
name|FT_ASSERT
argument_list|(
name|outline
operator|&&
name|outline
operator|->
name|decoder
argument_list|)
expr_stmt|;
name|FT_ASSERT
argument_list|(
name|params
operator|->
name|op
operator|==
name|CF2_PathOpLineTo
argument_list|)
expr_stmt|;
name|builder
operator|=
operator|&
name|outline
operator|->
name|decoder
operator|->
name|builder
expr_stmt|;
if|if
condition|(
operator|!
name|builder
operator|->
name|path_begun
condition|)
block|{
comment|/* record the move before the line; also check points and set */
comment|/* `path_begun'                                               */
name|error
operator|=
name|cff_builder_start_point
argument_list|(
name|builder
argument_list|,
name|params
operator|->
name|pt0
operator|.
name|x
argument_list|,
name|params
operator|->
name|pt0
operator|.
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
operator|!
operator|*
name|callbacks
operator|->
name|error
condition|)
operator|*
name|callbacks
operator|->
name|error
operator|=
name|error
expr_stmt|;
return|return;
block|}
block|}
comment|/* `cff_builder_add_point1' includes a check_points call for one point */
name|error
operator|=
name|cff_builder_add_point1
argument_list|(
name|builder
argument_list|,
name|params
operator|->
name|pt1
operator|.
name|x
argument_list|,
name|params
operator|->
name|pt1
operator|.
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
operator|!
operator|*
name|callbacks
operator|->
name|error
condition|)
operator|*
name|callbacks
operator|->
name|error
operator|=
name|error
expr_stmt|;
return|return;
block|}
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|cf2_builder_cubeTo
name|cf2_builder_cubeTo
parameter_list|(
name|CF2_OutlineCallbacks
name|callbacks
parameter_list|,
specifier|const
name|CF2_CallbackParams
name|params
parameter_list|)
block|{
name|FT_Error
name|error
decl_stmt|;
comment|/* downcast the object pointer */
name|CF2_Outline
name|outline
init|=
operator|(
name|CF2_Outline
operator|)
name|callbacks
decl_stmt|;
name|CFF_Builder
modifier|*
name|builder
decl_stmt|;
name|FT_ASSERT
argument_list|(
name|outline
operator|&&
name|outline
operator|->
name|decoder
argument_list|)
expr_stmt|;
name|FT_ASSERT
argument_list|(
name|params
operator|->
name|op
operator|==
name|CF2_PathOpCubeTo
argument_list|)
expr_stmt|;
name|builder
operator|=
operator|&
name|outline
operator|->
name|decoder
operator|->
name|builder
expr_stmt|;
if|if
condition|(
operator|!
name|builder
operator|->
name|path_begun
condition|)
block|{
comment|/* record the move before the line; also check points and set */
comment|/* `path_begun'                                               */
name|error
operator|=
name|cff_builder_start_point
argument_list|(
name|builder
argument_list|,
name|params
operator|->
name|pt0
operator|.
name|x
argument_list|,
name|params
operator|->
name|pt0
operator|.
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
operator|!
operator|*
name|callbacks
operator|->
name|error
condition|)
operator|*
name|callbacks
operator|->
name|error
operator|=
name|error
expr_stmt|;
return|return;
block|}
block|}
comment|/* prepare room for 3 points: 2 off-curve, 1 on-curve */
name|error
operator|=
name|cff_check_points
argument_list|(
name|builder
argument_list|,
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
operator|!
operator|*
name|callbacks
operator|->
name|error
condition|)
operator|*
name|callbacks
operator|->
name|error
operator|=
name|error
expr_stmt|;
return|return;
block|}
name|cff_builder_add_point
argument_list|(
name|builder
argument_list|,
name|params
operator|->
name|pt1
operator|.
name|x
argument_list|,
name|params
operator|->
name|pt1
operator|.
name|y
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cff_builder_add_point
argument_list|(
name|builder
argument_list|,
name|params
operator|->
name|pt2
operator|.
name|x
argument_list|,
name|params
operator|->
name|pt2
operator|.
name|y
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cff_builder_add_point
argument_list|(
name|builder
argument_list|,
name|params
operator|->
name|pt3
operator|.
name|x
argument_list|,
name|params
operator|->
name|pt3
operator|.
name|y
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|cf2_outline_init
name|cf2_outline_init
parameter_list|(
name|CF2_Outline
name|outline
parameter_list|,
name|FT_Memory
name|memory
parameter_list|,
name|FT_Error
modifier|*
name|error
parameter_list|)
block|{
name|FT_MEM_ZERO
argument_list|(
name|outline
argument_list|,
sizeof|sizeof
argument_list|(
name|CF2_OutlineRec
argument_list|)
argument_list|)
expr_stmt|;
name|outline
operator|->
name|root
operator|.
name|memory
operator|=
name|memory
expr_stmt|;
name|outline
operator|->
name|root
operator|.
name|error
operator|=
name|error
expr_stmt|;
name|outline
operator|->
name|root
operator|.
name|moveTo
operator|=
name|cf2_builder_moveTo
expr_stmt|;
name|outline
operator|->
name|root
operator|.
name|lineTo
operator|=
name|cf2_builder_lineTo
expr_stmt|;
name|outline
operator|->
name|root
operator|.
name|cubeTo
operator|=
name|cf2_builder_cubeTo
expr_stmt|;
block|}
end_function
begin_comment
comment|/* get scaling and hint flag from GlyphSlot */
end_comment
begin_function
specifier|static
name|void
DECL|function|cf2_getScaleAndHintFlag
name|cf2_getScaleAndHintFlag
parameter_list|(
name|CFF_Decoder
modifier|*
name|decoder
parameter_list|,
name|CF2_Fixed
modifier|*
name|x_scale
parameter_list|,
name|CF2_Fixed
modifier|*
name|y_scale
parameter_list|,
name|FT_Bool
modifier|*
name|hinted
parameter_list|,
name|FT_Bool
modifier|*
name|scaled
parameter_list|)
block|{
name|FT_ASSERT
argument_list|(
name|decoder
operator|&&
name|decoder
operator|->
name|builder
operator|.
name|glyph
argument_list|)
expr_stmt|;
comment|/* note: FreeType scale includes a factor of 64 */
operator|*
name|hinted
operator|=
name|decoder
operator|->
name|builder
operator|.
name|glyph
operator|->
name|hint
expr_stmt|;
operator|*
name|scaled
operator|=
name|decoder
operator|->
name|builder
operator|.
name|glyph
operator|->
name|scaled
expr_stmt|;
if|if
condition|(
operator|*
name|hinted
condition|)
block|{
operator|*
name|x_scale
operator|=
operator|(
name|decoder
operator|->
name|builder
operator|.
name|glyph
operator|->
name|x_scale
operator|+
literal|32
operator|)
operator|/
literal|64
expr_stmt|;
operator|*
name|y_scale
operator|=
operator|(
name|decoder
operator|->
name|builder
operator|.
name|glyph
operator|->
name|y_scale
operator|+
literal|32
operator|)
operator|/
literal|64
expr_stmt|;
block|}
else|else
block|{
comment|/* for unhinted outlines, `cff_slot_load' does the scaling, */
comment|/* thus render at `unity' scale                             */
operator|*
name|x_scale
operator|=
literal|0x0400
expr_stmt|;
comment|/* 1/64 as 16.16 */
operator|*
name|y_scale
operator|=
literal|0x0400
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/* get units per em from `FT_Face' */
end_comment
begin_comment
comment|/* TODO: should handle font matrix concatenation? */
end_comment
begin_function
specifier|static
name|FT_UShort
DECL|function|cf2_getUnitsPerEm
name|cf2_getUnitsPerEm
parameter_list|(
name|CFF_Decoder
modifier|*
name|decoder
parameter_list|)
block|{
name|FT_ASSERT
argument_list|(
name|decoder
operator|&&
name|decoder
operator|->
name|builder
operator|.
name|face
argument_list|)
expr_stmt|;
name|FT_ASSERT
argument_list|(
name|decoder
operator|->
name|builder
operator|.
name|face
operator|->
name|root
operator|.
name|units_per_EM
argument_list|)
expr_stmt|;
return|return
name|decoder
operator|->
name|builder
operator|.
name|face
operator|->
name|root
operator|.
name|units_per_EM
return|;
block|}
end_function
begin_comment
comment|/* Main entry point: Render one glyph. */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|cf2_decoder_parse_charstrings
argument_list|(
argument|CFF_Decoder*  decoder
argument_list|,
argument|FT_Byte*      charstring_base
argument_list|,
argument|FT_ULong      charstring_len
argument_list|)
end_macro
begin_block
block|{
name|FT_Memory
name|memory
decl_stmt|;
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
name|CF2_Font
name|font
decl_stmt|;
name|FT_ASSERT
argument_list|(
name|decoder
operator|&&
name|decoder
operator|->
name|cff
argument_list|)
expr_stmt|;
name|memory
operator|=
name|decoder
operator|->
name|builder
operator|.
name|memory
expr_stmt|;
comment|/* CF2 data is saved here across glyphs */
name|font
operator|=
operator|(
name|CF2_Font
operator|)
name|decoder
operator|->
name|cff
operator|->
name|cf2_instance
operator|.
name|data
expr_stmt|;
comment|/* on first glyph, allocate instance structure */
if|if
condition|(
name|decoder
operator|->
name|cff
operator|->
name|cf2_instance
operator|.
name|data
operator|==
name|NULL
condition|)
block|{
name|decoder
operator|->
name|cff
operator|->
name|cf2_instance
operator|.
name|finalizer
operator|=
operator|(
name|FT_Generic_Finalizer
operator|)
name|cf2_free_instance
expr_stmt|;
if|if
condition|(
name|FT_ALLOC
argument_list|(
name|decoder
operator|->
name|cff
operator|->
name|cf2_instance
operator|.
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|CF2_FontRec
argument_list|)
argument_list|)
condition|)
return|return
name|FT_THROW
argument_list|(
name|Out_Of_Memory
argument_list|)
return|;
name|font
operator|=
operator|(
name|CF2_Font
operator|)
name|decoder
operator|->
name|cff
operator|->
name|cf2_instance
operator|.
name|data
expr_stmt|;
name|font
operator|->
name|memory
operator|=
name|memory
expr_stmt|;
comment|/* initialize a client outline, to be shared by each glyph rendered */
name|cf2_outline_init
argument_list|(
operator|&
name|font
operator|->
name|outline
argument_list|,
name|font
operator|->
name|memory
argument_list|,
operator|&
name|font
operator|->
name|error
argument_list|)
expr_stmt|;
block|}
comment|/* save decoder; it is a stack variable and will be different on each */
comment|/* call                                                               */
name|font
operator|->
name|decoder
operator|=
name|decoder
expr_stmt|;
name|font
operator|->
name|outline
operator|.
name|decoder
operator|=
name|decoder
expr_stmt|;
block|{
comment|/* build parameters for Adobe engine */
name|CFF_Builder
modifier|*
name|builder
init|=
operator|&
name|decoder
operator|->
name|builder
decl_stmt|;
name|CFF_Driver
name|driver
init|=
operator|(
name|CFF_Driver
operator|)
name|FT_FACE_DRIVER
argument_list|(
name|builder
operator|->
name|face
argument_list|)
decl_stmt|;
comment|/* local error */
name|FT_Error
name|error2
init|=
name|FT_Err_Ok
decl_stmt|;
name|CF2_BufferRec
name|buf
decl_stmt|;
name|CF2_Matrix
name|transform
decl_stmt|;
name|CF2_F16Dot16
name|glyphWidth
decl_stmt|;
name|FT_Bool
name|hinted
decl_stmt|;
name|FT_Bool
name|scaled
decl_stmt|;
comment|/* FreeType has already looked up the GID; convert to         */
comment|/* `RegionBuffer', assuming that the input has been validated */
name|FT_ASSERT
argument_list|(
name|charstring_base
operator|+
name|charstring_len
operator|>=
name|charstring_base
argument_list|)
expr_stmt|;
name|FT_ZERO
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|.
name|start
operator|=
name|buf
operator|.
name|ptr
operator|=
name|charstring_base
expr_stmt|;
name|buf
operator|.
name|end
operator|=
name|charstring_base
operator|+
name|charstring_len
expr_stmt|;
name|FT_ZERO
argument_list|(
operator|&
name|transform
argument_list|)
expr_stmt|;
name|cf2_getScaleAndHintFlag
argument_list|(
name|decoder
argument_list|,
operator|&
name|transform
operator|.
name|a
argument_list|,
operator|&
name|transform
operator|.
name|d
argument_list|,
operator|&
name|hinted
argument_list|,
operator|&
name|scaled
argument_list|)
expr_stmt|;
name|font
operator|->
name|renderingFlags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|hinted
condition|)
name|font
operator|->
name|renderingFlags
operator||=
name|CF2_FlagsHinted
expr_stmt|;
if|if
condition|(
name|scaled
operator|&&
operator|!
name|driver
operator|->
name|no_stem_darkening
condition|)
name|font
operator|->
name|renderingFlags
operator||=
name|CF2_FlagsDarkened
expr_stmt|;
name|font
operator|->
name|darkenParams
index|[
literal|0
index|]
operator|=
name|driver
operator|->
name|darken_params
index|[
literal|0
index|]
expr_stmt|;
name|font
operator|->
name|darkenParams
index|[
literal|1
index|]
operator|=
name|driver
operator|->
name|darken_params
index|[
literal|1
index|]
expr_stmt|;
name|font
operator|->
name|darkenParams
index|[
literal|2
index|]
operator|=
name|driver
operator|->
name|darken_params
index|[
literal|2
index|]
expr_stmt|;
name|font
operator|->
name|darkenParams
index|[
literal|3
index|]
operator|=
name|driver
operator|->
name|darken_params
index|[
literal|3
index|]
expr_stmt|;
name|font
operator|->
name|darkenParams
index|[
literal|4
index|]
operator|=
name|driver
operator|->
name|darken_params
index|[
literal|4
index|]
expr_stmt|;
name|font
operator|->
name|darkenParams
index|[
literal|5
index|]
operator|=
name|driver
operator|->
name|darken_params
index|[
literal|5
index|]
expr_stmt|;
name|font
operator|->
name|darkenParams
index|[
literal|6
index|]
operator|=
name|driver
operator|->
name|darken_params
index|[
literal|6
index|]
expr_stmt|;
name|font
operator|->
name|darkenParams
index|[
literal|7
index|]
operator|=
name|driver
operator|->
name|darken_params
index|[
literal|7
index|]
expr_stmt|;
comment|/* now get an outline for this glyph;      */
comment|/* also get units per em to validate scale */
name|font
operator|->
name|unitsPerEm
operator|=
operator|(
name|CF2_Int
operator|)
name|cf2_getUnitsPerEm
argument_list|(
name|decoder
argument_list|)
expr_stmt|;
if|if
condition|(
name|scaled
condition|)
block|{
name|error2
operator|=
name|cf2_checkTransform
argument_list|(
operator|&
name|transform
argument_list|,
name|font
operator|->
name|unitsPerEm
argument_list|)
expr_stmt|;
if|if
condition|(
name|error2
condition|)
return|return
name|error2
return|;
block|}
name|error2
operator|=
name|cf2_getGlyphOutline
argument_list|(
name|font
argument_list|,
operator|&
name|buf
argument_list|,
operator|&
name|transform
argument_list|,
operator|&
name|glyphWidth
argument_list|)
expr_stmt|;
if|if
condition|(
name|error2
condition|)
return|return
name|FT_ERR
argument_list|(
name|Invalid_File_Format
argument_list|)
return|;
name|cf2_setGlyphWidth
argument_list|(
operator|&
name|font
operator|->
name|outline
argument_list|,
name|glyphWidth
argument_list|)
expr_stmt|;
return|return
name|FT_Err_Ok
return|;
block|}
block|}
end_block
begin_comment
comment|/* get pointer to current FreeType subfont (based on current glyphID) */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|CFF_SubFont
argument_list|)
end_macro
begin_macro
name|cf2_getSubfont
argument_list|(
argument|CFF_Decoder*  decoder
argument_list|)
end_macro
begin_block
block|{
name|FT_ASSERT
argument_list|(
name|decoder
operator|&&
name|decoder
operator|->
name|current_subfont
argument_list|)
expr_stmt|;
return|return
name|decoder
operator|->
name|current_subfont
return|;
block|}
end_block
begin_comment
comment|/* get `y_ppem' from `CFF_Size' */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|CF2_Fixed
argument_list|)
end_macro
begin_macro
name|cf2_getPpemY
argument_list|(
argument|CFF_Decoder*  decoder
argument_list|)
end_macro
begin_block
block|{
name|FT_ASSERT
argument_list|(
name|decoder
operator|&&
name|decoder
operator|->
name|builder
operator|.
name|face
operator|&&
name|decoder
operator|->
name|builder
operator|.
name|face
operator|->
name|root
operator|.
name|size
argument_list|)
expr_stmt|;
comment|/*      * Note that `y_ppem' can be zero if there wasn't a call to      * `FT_Set_Char_Size' or something similar.  However, this isn't a      * problem since we come to this place in the code only if      * FT_LOAD_NO_SCALE is set (the other case gets caught by      * `cf2_checkTransform').  The ppem value is needed to compute the stem      * darkening, which is disabled for getting the unscaled outline.      *      */
return|return
name|cf2_intToFixed
argument_list|(
name|decoder
operator|->
name|builder
operator|.
name|face
operator|->
name|root
operator|.
name|size
operator|->
name|metrics
operator|.
name|y_ppem
argument_list|)
return|;
block|}
end_block
begin_comment
comment|/* get standard stem widths for the current subfont; */
end_comment
begin_comment
comment|/* FreeType stores these as integer font units       */
end_comment
begin_comment
comment|/* (note: variable names seem swapped)               */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|CF2_Fixed
argument_list|)
end_macro
begin_macro
name|cf2_getStdVW
argument_list|(
argument|CFF_Decoder*  decoder
argument_list|)
end_macro
begin_block
block|{
name|FT_ASSERT
argument_list|(
name|decoder
operator|&&
name|decoder
operator|->
name|current_subfont
argument_list|)
expr_stmt|;
return|return
name|cf2_intToFixed
argument_list|(
name|decoder
operator|->
name|current_subfont
operator|->
name|private_dict
operator|.
name|standard_height
argument_list|)
return|;
block|}
end_block
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|CF2_Fixed
argument_list|)
end_macro
begin_macro
name|cf2_getStdHW
argument_list|(
argument|CFF_Decoder*  decoder
argument_list|)
end_macro
begin_block
block|{
name|FT_ASSERT
argument_list|(
name|decoder
operator|&&
name|decoder
operator|->
name|current_subfont
argument_list|)
expr_stmt|;
return|return
name|cf2_intToFixed
argument_list|(
name|decoder
operator|->
name|current_subfont
operator|->
name|private_dict
operator|.
name|standard_width
argument_list|)
return|;
block|}
end_block
begin_comment
comment|/* note: FreeType stores 1000 times the actual value for `BlueScale' */
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|cf2_getBlueMetrics
name|cf2_getBlueMetrics
argument_list|(
argument|CFF_Decoder*  decoder
argument_list|,
argument|CF2_Fixed*    blueScale
argument_list|,
argument|CF2_Fixed*    blueShift
argument_list|,
argument|CF2_Fixed*    blueFuzz
argument_list|)
end_macro
begin_block
block|{
name|FT_ASSERT
argument_list|(
name|decoder
operator|&&
name|decoder
operator|->
name|current_subfont
argument_list|)
expr_stmt|;
operator|*
name|blueScale
operator|=
name|FT_DivFix
argument_list|(
name|decoder
operator|->
name|current_subfont
operator|->
name|private_dict
operator|.
name|blue_scale
argument_list|,
name|cf2_intToFixed
argument_list|(
literal|1000
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|blueShift
operator|=
name|cf2_intToFixed
argument_list|(
name|decoder
operator|->
name|current_subfont
operator|->
name|private_dict
operator|.
name|blue_shift
argument_list|)
expr_stmt|;
operator|*
name|blueFuzz
operator|=
name|cf2_intToFixed
argument_list|(
name|decoder
operator|->
name|current_subfont
operator|->
name|private_dict
operator|.
name|blue_fuzz
argument_list|)
expr_stmt|;
block|}
end_block
begin_comment
comment|/* get blue values counts and arrays; the FreeType parser has validated */
end_comment
begin_comment
comment|/* the counts and verified that each is an even number                  */
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|cf2_getBlueValues
name|cf2_getBlueValues
argument_list|(
argument|CFF_Decoder*  decoder
argument_list|,
argument|size_t*       count
argument_list|,
argument|FT_Pos*      *data
argument_list|)
end_macro
begin_block
block|{
name|FT_ASSERT
argument_list|(
name|decoder
operator|&&
name|decoder
operator|->
name|current_subfont
argument_list|)
expr_stmt|;
operator|*
name|count
operator|=
name|decoder
operator|->
name|current_subfont
operator|->
name|private_dict
operator|.
name|num_blue_values
expr_stmt|;
operator|*
name|data
operator|=
operator|(
name|FT_Pos
operator|*
operator|)
operator|&
name|decoder
operator|->
name|current_subfont
operator|->
name|private_dict
operator|.
name|blue_values
expr_stmt|;
block|}
end_block
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|cf2_getOtherBlues
name|cf2_getOtherBlues
argument_list|(
argument|CFF_Decoder*  decoder
argument_list|,
argument|size_t*       count
argument_list|,
argument|FT_Pos*      *data
argument_list|)
end_macro
begin_block
block|{
name|FT_ASSERT
argument_list|(
name|decoder
operator|&&
name|decoder
operator|->
name|current_subfont
argument_list|)
expr_stmt|;
operator|*
name|count
operator|=
name|decoder
operator|->
name|current_subfont
operator|->
name|private_dict
operator|.
name|num_other_blues
expr_stmt|;
operator|*
name|data
operator|=
operator|(
name|FT_Pos
operator|*
operator|)
operator|&
name|decoder
operator|->
name|current_subfont
operator|->
name|private_dict
operator|.
name|other_blues
expr_stmt|;
block|}
end_block
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|cf2_getFamilyBlues
name|cf2_getFamilyBlues
argument_list|(
argument|CFF_Decoder*  decoder
argument_list|,
argument|size_t*       count
argument_list|,
argument|FT_Pos*      *data
argument_list|)
end_macro
begin_block
block|{
name|FT_ASSERT
argument_list|(
name|decoder
operator|&&
name|decoder
operator|->
name|current_subfont
argument_list|)
expr_stmt|;
operator|*
name|count
operator|=
name|decoder
operator|->
name|current_subfont
operator|->
name|private_dict
operator|.
name|num_family_blues
expr_stmt|;
operator|*
name|data
operator|=
operator|(
name|FT_Pos
operator|*
operator|)
operator|&
name|decoder
operator|->
name|current_subfont
operator|->
name|private_dict
operator|.
name|family_blues
expr_stmt|;
block|}
end_block
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|cf2_getFamilyOtherBlues
name|cf2_getFamilyOtherBlues
argument_list|(
argument|CFF_Decoder*  decoder
argument_list|,
argument|size_t*       count
argument_list|,
argument|FT_Pos*      *data
argument_list|)
end_macro
begin_block
block|{
name|FT_ASSERT
argument_list|(
name|decoder
operator|&&
name|decoder
operator|->
name|current_subfont
argument_list|)
expr_stmt|;
operator|*
name|count
operator|=
name|decoder
operator|->
name|current_subfont
operator|->
name|private_dict
operator|.
name|num_family_other_blues
expr_stmt|;
operator|*
name|data
operator|=
operator|(
name|FT_Pos
operator|*
operator|)
operator|&
name|decoder
operator|->
name|current_subfont
operator|->
name|private_dict
operator|.
name|family_other_blues
expr_stmt|;
block|}
end_block
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|CF2_Int
argument_list|)
end_macro
begin_macro
name|cf2_getLanguageGroup
argument_list|(
argument|CFF_Decoder*  decoder
argument_list|)
end_macro
begin_block
block|{
name|FT_ASSERT
argument_list|(
name|decoder
operator|&&
name|decoder
operator|->
name|current_subfont
argument_list|)
expr_stmt|;
return|return
name|decoder
operator|->
name|current_subfont
operator|->
name|private_dict
operator|.
name|language_group
return|;
block|}
end_block
begin_comment
comment|/* convert unbiased subroutine index to `CF2_Buffer' and */
end_comment
begin_comment
comment|/* return 0 on success                                   */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|CF2_Int
argument_list|)
end_macro
begin_macro
name|cf2_initGlobalRegionBuffer
argument_list|(
argument|CFF_Decoder*  decoder
argument_list|,
argument|CF2_UInt      idx
argument_list|,
argument|CF2_Buffer    buf
argument_list|)
end_macro
begin_block
block|{
name|FT_ASSERT
argument_list|(
name|decoder
argument_list|)
expr_stmt|;
name|FT_ZERO
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|idx
operator|+=
name|decoder
operator|->
name|globals_bias
expr_stmt|;
if|if
condition|(
name|idx
operator|>=
name|decoder
operator|->
name|num_globals
condition|)
return|return
name|TRUE
return|;
comment|/* error */
name|FT_ASSERT
argument_list|(
name|decoder
operator|->
name|globals
argument_list|)
expr_stmt|;
name|buf
operator|->
name|start
operator|=
name|buf
operator|->
name|ptr
operator|=
name|decoder
operator|->
name|globals
index|[
name|idx
index|]
expr_stmt|;
name|buf
operator|->
name|end
operator|=
name|decoder
operator|->
name|globals
index|[
name|idx
operator|+
literal|1
index|]
expr_stmt|;
return|return
name|FALSE
return|;
comment|/* success */
block|}
end_block
begin_comment
comment|/* convert AdobeStandardEncoding code to CF2_Buffer; */
end_comment
begin_comment
comment|/* used for seac component                           */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|cf2_getSeacComponent
argument_list|(
argument|CFF_Decoder*  decoder
argument_list|,
argument|CF2_UInt      code
argument_list|,
argument|CF2_Buffer    buf
argument_list|)
end_macro
begin_block
block|{
name|CF2_Int
name|gid
decl_stmt|;
name|FT_Byte
modifier|*
name|charstring
decl_stmt|;
name|FT_ULong
name|len
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|FT_ASSERT
argument_list|(
name|decoder
argument_list|)
expr_stmt|;
name|FT_ZERO
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|gid
operator|=
name|cff_lookup_glyph_by_stdcharcode
argument_list|(
name|decoder
operator|->
name|cff
argument_list|,
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|gid
operator|<
literal|0
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_Glyph_Format
argument_list|)
return|;
name|error
operator|=
name|cff_get_glyph_data
argument_list|(
name|decoder
operator|->
name|builder
operator|.
name|face
argument_list|,
name|gid
argument_list|,
operator|&
name|charstring
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
comment|/* TODO: for now, just pass the FreeType error through */
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
comment|/* assume input has been validated */
name|FT_ASSERT
argument_list|(
name|charstring
operator|+
name|len
operator|>=
name|charstring
argument_list|)
expr_stmt|;
name|buf
operator|->
name|start
operator|=
name|charstring
expr_stmt|;
name|buf
operator|->
name|end
operator|=
name|charstring
operator|+
name|len
expr_stmt|;
name|buf
operator|->
name|ptr
operator|=
name|buf
operator|->
name|start
expr_stmt|;
return|return
name|FT_Err_Ok
return|;
block|}
end_block
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|cf2_freeSeacComponent
name|cf2_freeSeacComponent
argument_list|(
argument|CFF_Decoder*  decoder
argument_list|,
argument|CF2_Buffer    buf
argument_list|)
end_macro
begin_block
block|{
name|FT_ASSERT
argument_list|(
name|decoder
argument_list|)
expr_stmt|;
name|cff_free_glyph_data
argument_list|(
name|decoder
operator|->
name|builder
operator|.
name|face
argument_list|,
operator|(
name|FT_Byte
operator|*
operator|*
operator|)
operator|&
name|buf
operator|->
name|start
argument_list|,
call|(
name|FT_ULong
call|)
argument_list|(
name|buf
operator|->
name|end
operator|-
name|buf
operator|->
name|start
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|CF2_Int
argument_list|)
end_macro
begin_macro
name|cf2_initLocalRegionBuffer
argument_list|(
argument|CFF_Decoder*  decoder
argument_list|,
argument|CF2_UInt      idx
argument_list|,
argument|CF2_Buffer    buf
argument_list|)
end_macro
begin_block
block|{
name|FT_ASSERT
argument_list|(
name|decoder
argument_list|)
expr_stmt|;
name|FT_ZERO
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|idx
operator|+=
name|decoder
operator|->
name|locals_bias
expr_stmt|;
if|if
condition|(
name|idx
operator|>=
name|decoder
operator|->
name|num_locals
condition|)
return|return
name|TRUE
return|;
comment|/* error */
name|FT_ASSERT
argument_list|(
name|decoder
operator|->
name|locals
argument_list|)
expr_stmt|;
name|buf
operator|->
name|start
operator|=
name|buf
operator|->
name|ptr
operator|=
name|decoder
operator|->
name|locals
index|[
name|idx
index|]
expr_stmt|;
name|buf
operator|->
name|end
operator|=
name|decoder
operator|->
name|locals
index|[
name|idx
operator|+
literal|1
index|]
expr_stmt|;
return|return
name|FALSE
return|;
comment|/* success */
block|}
end_block
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|CF2_Fixed
argument_list|)
end_macro
begin_macro
name|cf2_getDefaultWidthX
argument_list|(
argument|CFF_Decoder*  decoder
argument_list|)
end_macro
begin_block
block|{
name|FT_ASSERT
argument_list|(
name|decoder
operator|&&
name|decoder
operator|->
name|current_subfont
argument_list|)
expr_stmt|;
return|return
name|cf2_intToFixed
argument_list|(
name|decoder
operator|->
name|current_subfont
operator|->
name|private_dict
operator|.
name|default_width
argument_list|)
return|;
block|}
end_block
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|CF2_Fixed
argument_list|)
end_macro
begin_macro
name|cf2_getNominalWidthX
argument_list|(
argument|CFF_Decoder*  decoder
argument_list|)
end_macro
begin_block
block|{
name|FT_ASSERT
argument_list|(
name|decoder
operator|&&
name|decoder
operator|->
name|current_subfont
argument_list|)
expr_stmt|;
return|return
name|cf2_intToFixed
argument_list|(
name|decoder
operator|->
name|current_subfont
operator|->
name|private_dict
operator|.
name|nominal_width
argument_list|)
return|;
block|}
end_block
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|cf2_outline_reset
name|cf2_outline_reset
argument_list|(
argument|CF2_Outline  outline
argument_list|)
end_macro
begin_block
block|{
name|CFF_Decoder
modifier|*
name|decoder
init|=
name|outline
operator|->
name|decoder
decl_stmt|;
name|FT_ASSERT
argument_list|(
name|decoder
argument_list|)
expr_stmt|;
name|outline
operator|->
name|root
operator|.
name|windingMomentum
operator|=
literal|0
expr_stmt|;
name|FT_GlyphLoader_Rewind
argument_list|(
name|decoder
operator|->
name|builder
operator|.
name|loader
argument_list|)
expr_stmt|;
block|}
end_block
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|cf2_outline_close
name|cf2_outline_close
argument_list|(
argument|CF2_Outline  outline
argument_list|)
end_macro
begin_block
block|{
name|CFF_Decoder
modifier|*
name|decoder
init|=
name|outline
operator|->
name|decoder
decl_stmt|;
name|FT_ASSERT
argument_list|(
name|decoder
argument_list|)
expr_stmt|;
name|cff_builder_close_contour
argument_list|(
operator|&
name|decoder
operator|->
name|builder
argument_list|)
expr_stmt|;
name|FT_GlyphLoader_Add
argument_list|(
name|decoder
operator|->
name|builder
operator|.
name|loader
argument_list|)
expr_stmt|;
block|}
end_block
begin_comment
comment|/* END */
end_comment
end_unit
