begin_unit
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  cf2blues.c                                                             */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*    Adobe's code for handling Blue Zones (body).                         */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  Copyright 2009-2014 Adobe Systems Incorporated.                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  This software, and all works of authorship, whether in source or       */
end_comment
begin_comment
comment|/*  object code form as indicated by the copyright notice(s) included      */
end_comment
begin_comment
comment|/*  herein (collectively, the "Work") is made available, and may only be   */
end_comment
begin_comment
comment|/*  used, modified, and distributed under the FreeType Project License,    */
end_comment
begin_comment
comment|/*  LICENSE.TXT.  Additionally, subject to the terms and conditions of the */
end_comment
begin_comment
comment|/*  FreeType Project License, each contributor to the Work hereby grants   */
end_comment
begin_comment
comment|/*  to any individual or legal entity exercising permissions granted by    */
end_comment
begin_comment
comment|/*  the FreeType Project License and this section (hereafter, "You" or     */
end_comment
begin_comment
comment|/*  "Your") a perpetual, worldwide, non-exclusive, no-charge,              */
end_comment
begin_comment
comment|/*  royalty-free, irrevocable (except as stated in this section) patent    */
end_comment
begin_comment
comment|/*  license to make, have made, use, offer to sell, sell, import, and      */
end_comment
begin_comment
comment|/*  otherwise transfer the Work, where such license applies only to those  */
end_comment
begin_comment
comment|/*  patent claims licensable by such contributor that are necessarily      */
end_comment
begin_comment
comment|/*  infringed by their contribution(s) alone or by combination of their    */
end_comment
begin_comment
comment|/*  contribution(s) with the Work to which such contribution(s) was        */
end_comment
begin_comment
comment|/*  submitted.  If You institute patent litigation against any entity      */
end_comment
begin_comment
comment|/*  (including a cross-claim or counterclaim in a lawsuit) alleging that   */
end_comment
begin_comment
comment|/*  the Work or a contribution incorporated within the Work constitutes    */
end_comment
begin_comment
comment|/*  direct or contributory patent infringement, then any patent licenses   */
end_comment
begin_comment
comment|/*  granted to You under this License for that Work shall terminate as of  */
end_comment
begin_comment
comment|/*  the date such litigation is filed.                                     */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  By using, modifying, or distributing the Work you indicate that you    */
end_comment
begin_comment
comment|/*  have read and understood the terms and conditions of the               */
end_comment
begin_comment
comment|/*  FreeType Project License as well as those provided in this section,    */
end_comment
begin_comment
comment|/*  and you accept them fully.                                             */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"cf2ft.h"
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_DEBUG_H
end_include
begin_include
include|#
directive|include
file|"cf2blues.h"
end_include
begin_include
include|#
directive|include
file|"cf2hints.h"
end_include
begin_include
include|#
directive|include
file|"cf2font.h"
end_include
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
end_comment
begin_comment
comment|/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
end_comment
begin_comment
comment|/* messages during execution.                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_undef
DECL|macro|FT_COMPONENT
undef|#
directive|undef
name|FT_COMPONENT
end_undef
begin_define
DECL|macro|FT_COMPONENT
define|#
directive|define
name|FT_COMPONENT
value|trace_cf2blues
end_define
begin_comment
comment|/*    * For blue values, the FreeType parser produces an array of integers,    * while the Adobe CFF engine produces an array of fixed.    * Define a macro to convert FreeType to fixed.    */
end_comment
begin_define
DECL|macro|cf2_blueToFixed
define|#
directive|define
name|cf2_blueToFixed
parameter_list|(
name|x
parameter_list|)
value|cf2_intToFixed( x )
end_define
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|cf2_blues_init
name|cf2_blues_init
argument_list|(
argument|CF2_Blues  blues
argument_list|,
argument|CF2_Font   font
argument_list|)
end_macro
begin_block
block|{
comment|/* pointer to parsed font object */
name|CFF_Decoder
modifier|*
name|decoder
init|=
name|font
operator|->
name|decoder
decl_stmt|;
name|CF2_Fixed
name|zoneHeight
decl_stmt|;
name|CF2_Fixed
name|maxZoneHeight
init|=
literal|0
decl_stmt|;
name|CF2_Fixed
name|csUnitsPerPixel
decl_stmt|;
name|size_t
name|numBlueValues
decl_stmt|;
name|size_t
name|numOtherBlues
decl_stmt|;
name|size_t
name|numFamilyBlues
decl_stmt|;
name|size_t
name|numFamilyOtherBlues
decl_stmt|;
name|FT_Pos
modifier|*
name|blueValues
decl_stmt|;
name|FT_Pos
modifier|*
name|otherBlues
decl_stmt|;
name|FT_Pos
modifier|*
name|familyBlues
decl_stmt|;
name|FT_Pos
modifier|*
name|familyOtherBlues
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|CF2_Fixed
name|emBoxBottom
decl_stmt|,
name|emBoxTop
decl_stmt|;
if|#
directive|if
literal|0
block|CF2_Int  unitsPerEm = font->unitsPerEm;       if ( unitsPerEm == 0 )       unitsPerEm = 1000;
endif|#
directive|endif
name|FT_ZERO
argument_list|(
name|blues
argument_list|)
expr_stmt|;
name|blues
operator|->
name|scale
operator|=
name|font
operator|->
name|innerTransform
operator|.
name|d
expr_stmt|;
name|cf2_getBlueMetrics
argument_list|(
name|decoder
argument_list|,
operator|&
name|blues
operator|->
name|blueScale
argument_list|,
operator|&
name|blues
operator|->
name|blueShift
argument_list|,
operator|&
name|blues
operator|->
name|blueFuzz
argument_list|)
expr_stmt|;
name|cf2_getBlueValues
argument_list|(
name|decoder
argument_list|,
operator|&
name|numBlueValues
argument_list|,
operator|&
name|blueValues
argument_list|)
expr_stmt|;
name|cf2_getOtherBlues
argument_list|(
name|decoder
argument_list|,
operator|&
name|numOtherBlues
argument_list|,
operator|&
name|otherBlues
argument_list|)
expr_stmt|;
name|cf2_getFamilyBlues
argument_list|(
name|decoder
argument_list|,
operator|&
name|numFamilyBlues
argument_list|,
operator|&
name|familyBlues
argument_list|)
expr_stmt|;
name|cf2_getFamilyOtherBlues
argument_list|(
name|decoder
argument_list|,
operator|&
name|numFamilyOtherBlues
argument_list|,
operator|&
name|familyOtherBlues
argument_list|)
expr_stmt|;
comment|/*      * synthetic em box hint heuristic      *      * Apply this when ideographic dictionary (LanguageGroup 1) has no      * real alignment zones.  Adobe tools generate dummy zones at -250 and      * 1100 for a 1000 unit em.  Fonts with ICF-based alignment zones      * should not enable the heuristic.  When the heuristic is enabled,      * the font's blue zones are ignored.      *      */
comment|/* get em box from OS/2 typoAscender/Descender                      */
comment|/* TODO: FreeType does not parse these metrics.  Skip them for now. */
if|#
directive|if
literal|0
block|FCM_getHorizontalLineMetrics(&e,                                   font->font,&ascender,&descender,&linegap );     if ( ascender - descender == unitsPerEm )     {       emBoxBottom = cf2_intToFixed( descender );       emBoxTop    = cf2_intToFixed( ascender );     }     else
endif|#
directive|endif
block|{
name|emBoxBottom
operator|=
name|CF2_ICF_Bottom
expr_stmt|;
name|emBoxTop
operator|=
name|CF2_ICF_Top
expr_stmt|;
block|}
if|if
condition|(
name|cf2_getLanguageGroup
argument_list|(
name|decoder
argument_list|)
operator|==
literal|1
operator|&&
operator|(
name|numBlueValues
operator|==
literal|0
operator|||
operator|(
name|numBlueValues
operator|==
literal|4
operator|&&
name|cf2_blueToFixed
argument_list|(
name|blueValues
index|[
literal|0
index|]
argument_list|)
operator|<
name|emBoxBottom
operator|&&
name|cf2_blueToFixed
argument_list|(
name|blueValues
index|[
literal|1
index|]
argument_list|)
operator|<
name|emBoxBottom
operator|&&
name|cf2_blueToFixed
argument_list|(
name|blueValues
index|[
literal|2
index|]
argument_list|)
operator|>
name|emBoxTop
operator|&&
name|cf2_blueToFixed
argument_list|(
name|blueValues
index|[
literal|3
index|]
argument_list|)
operator|>
name|emBoxTop
operator|)
operator|)
condition|)
block|{
comment|/*        * Construct hint edges suitable for synthetic ghost hints at top        * and bottom of em box.  +-CF2_MIN_COUNTER allows for unhinted        * features above or below the last hinted edge.  This also gives a        * net 1 pixel boost to the height of ideographic glyphs.        *        * Note: Adjust synthetic hints outward by epsilon (0x.0001) to        *       avoid interference.  E.g., some fonts have real hints at        *       880 and -120.        */
name|blues
operator|->
name|emBoxBottomEdge
operator|.
name|csCoord
operator|=
name|emBoxBottom
operator|-
name|CF2_FIXED_EPSILON
expr_stmt|;
name|blues
operator|->
name|emBoxBottomEdge
operator|.
name|dsCoord
operator|=
name|cf2_fixedRound
argument_list|(
name|FT_MulFix
argument_list|(
name|blues
operator|->
name|emBoxBottomEdge
operator|.
name|csCoord
argument_list|,
name|blues
operator|->
name|scale
argument_list|)
argument_list|)
operator|-
name|CF2_MIN_COUNTER
expr_stmt|;
name|blues
operator|->
name|emBoxBottomEdge
operator|.
name|scale
operator|=
name|blues
operator|->
name|scale
expr_stmt|;
name|blues
operator|->
name|emBoxBottomEdge
operator|.
name|flags
operator|=
name|CF2_GhostBottom
operator||
name|CF2_Locked
operator||
name|CF2_Synthetic
expr_stmt|;
name|blues
operator|->
name|emBoxTopEdge
operator|.
name|csCoord
operator|=
name|emBoxTop
operator|+
name|CF2_FIXED_EPSILON
operator|+
literal|2
operator|*
name|font
operator|->
name|darkenY
expr_stmt|;
name|blues
operator|->
name|emBoxTopEdge
operator|.
name|dsCoord
operator|=
name|cf2_fixedRound
argument_list|(
name|FT_MulFix
argument_list|(
name|blues
operator|->
name|emBoxTopEdge
operator|.
name|csCoord
argument_list|,
name|blues
operator|->
name|scale
argument_list|)
argument_list|)
operator|+
name|CF2_MIN_COUNTER
expr_stmt|;
name|blues
operator|->
name|emBoxTopEdge
operator|.
name|scale
operator|=
name|blues
operator|->
name|scale
expr_stmt|;
name|blues
operator|->
name|emBoxTopEdge
operator|.
name|flags
operator|=
name|CF2_GhostTop
operator||
name|CF2_Locked
operator||
name|CF2_Synthetic
expr_stmt|;
name|blues
operator|->
name|doEmBoxHints
operator|=
name|TRUE
expr_stmt|;
comment|/* enable the heuristic */
return|return;
block|}
comment|/* copy `BlueValues' and `OtherBlues' to a combined array of top and */
comment|/* bottom zones                                                      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numBlueValues
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|blues
operator|->
name|zone
index|[
name|blues
operator|->
name|count
index|]
operator|.
name|csBottomEdge
operator|=
name|cf2_blueToFixed
argument_list|(
name|blueValues
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|blues
operator|->
name|zone
index|[
name|blues
operator|->
name|count
index|]
operator|.
name|csTopEdge
operator|=
name|cf2_blueToFixed
argument_list|(
name|blueValues
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
name|zoneHeight
operator|=
name|blues
operator|->
name|zone
index|[
name|blues
operator|->
name|count
index|]
operator|.
name|csTopEdge
operator|-
name|blues
operator|->
name|zone
index|[
name|blues
operator|->
name|count
index|]
operator|.
name|csBottomEdge
expr_stmt|;
if|if
condition|(
name|zoneHeight
operator|<
literal|0
condition|)
block|{
name|FT_TRACE4
argument_list|(
operator|(
literal|"cf2_blues_init: ignoring negative zone height\n"
operator|)
argument_list|)
expr_stmt|;
continue|continue;
comment|/* reject this zone */
block|}
if|if
condition|(
name|zoneHeight
operator|>
name|maxZoneHeight
condition|)
block|{
comment|/* take maximum before darkening adjustment      */
comment|/* so overshoot suppression point doesn't change */
name|maxZoneHeight
operator|=
name|zoneHeight
expr_stmt|;
block|}
comment|/* adjust both edges of top zone upward by twice darkening amount */
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
name|blues
operator|->
name|zone
index|[
name|blues
operator|->
name|count
index|]
operator|.
name|csTopEdge
operator|+=
literal|2
operator|*
name|font
operator|->
name|darkenY
expr_stmt|;
name|blues
operator|->
name|zone
index|[
name|blues
operator|->
name|count
index|]
operator|.
name|csBottomEdge
operator|+=
literal|2
operator|*
name|font
operator|->
name|darkenY
expr_stmt|;
block|}
comment|/* first `BlueValue' is bottom zone; others are top */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|blues
operator|->
name|zone
index|[
name|blues
operator|->
name|count
index|]
operator|.
name|bottomZone
operator|=
name|TRUE
expr_stmt|;
name|blues
operator|->
name|zone
index|[
name|blues
operator|->
name|count
index|]
operator|.
name|csFlatEdge
operator|=
name|blues
operator|->
name|zone
index|[
name|blues
operator|->
name|count
index|]
operator|.
name|csTopEdge
expr_stmt|;
block|}
else|else
block|{
name|blues
operator|->
name|zone
index|[
name|blues
operator|->
name|count
index|]
operator|.
name|bottomZone
operator|=
name|FALSE
expr_stmt|;
name|blues
operator|->
name|zone
index|[
name|blues
operator|->
name|count
index|]
operator|.
name|csFlatEdge
operator|=
name|blues
operator|->
name|zone
index|[
name|blues
operator|->
name|count
index|]
operator|.
name|csBottomEdge
expr_stmt|;
block|}
name|blues
operator|->
name|count
operator|+=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numOtherBlues
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|blues
operator|->
name|zone
index|[
name|blues
operator|->
name|count
index|]
operator|.
name|csBottomEdge
operator|=
name|cf2_blueToFixed
argument_list|(
name|otherBlues
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|blues
operator|->
name|zone
index|[
name|blues
operator|->
name|count
index|]
operator|.
name|csTopEdge
operator|=
name|cf2_blueToFixed
argument_list|(
name|otherBlues
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
name|zoneHeight
operator|=
name|blues
operator|->
name|zone
index|[
name|blues
operator|->
name|count
index|]
operator|.
name|csTopEdge
operator|-
name|blues
operator|->
name|zone
index|[
name|blues
operator|->
name|count
index|]
operator|.
name|csBottomEdge
expr_stmt|;
if|if
condition|(
name|zoneHeight
operator|<
literal|0
condition|)
block|{
name|FT_TRACE4
argument_list|(
operator|(
literal|"cf2_blues_init: ignoring negative zone height\n"
operator|)
argument_list|)
expr_stmt|;
continue|continue;
comment|/* reject this zone */
block|}
if|if
condition|(
name|zoneHeight
operator|>
name|maxZoneHeight
condition|)
block|{
comment|/* take maximum before darkening adjustment      */
comment|/* so overshoot suppression point doesn't change */
name|maxZoneHeight
operator|=
name|zoneHeight
expr_stmt|;
block|}
comment|/* Note: bottom zones are not adjusted for darkening amount */
comment|/* all OtherBlues are bottom zone */
name|blues
operator|->
name|zone
index|[
name|blues
operator|->
name|count
index|]
operator|.
name|bottomZone
operator|=
name|TRUE
expr_stmt|;
name|blues
operator|->
name|zone
index|[
name|blues
operator|->
name|count
index|]
operator|.
name|csFlatEdge
operator|=
name|blues
operator|->
name|zone
index|[
name|blues
operator|->
name|count
index|]
operator|.
name|csTopEdge
expr_stmt|;
name|blues
operator|->
name|count
operator|+=
literal|1
expr_stmt|;
block|}
comment|/* Adjust for FamilyBlues */
comment|/* Search for the nearest flat edge in `FamilyBlues' or                */
comment|/* `FamilyOtherBlues'.  According to the Black Book, any matching edge */
comment|/* must be within one device pixel                                     */
name|csUnitsPerPixel
operator|=
name|FT_DivFix
argument_list|(
name|cf2_intToFixed
argument_list|(
literal|1
argument_list|)
argument_list|,
name|blues
operator|->
name|scale
argument_list|)
expr_stmt|;
comment|/* loop on all zones in this font */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|blues
operator|->
name|count
condition|;
name|i
operator|++
control|)
block|{
name|size_t
name|j
decl_stmt|;
name|CF2_Fixed
name|minDiff
decl_stmt|;
name|CF2_Fixed
name|flatFamilyEdge
decl_stmt|,
name|diff
decl_stmt|;
comment|/* value for this font */
name|CF2_Fixed
name|flatEdge
init|=
name|blues
operator|->
name|zone
index|[
name|i
index|]
operator|.
name|csFlatEdge
decl_stmt|;
if|if
condition|(
name|blues
operator|->
name|zone
index|[
name|i
index|]
operator|.
name|bottomZone
condition|)
block|{
comment|/* In a bottom zone, the top edge is the flat edge.             */
comment|/* Search `FamilyOtherBlues' for bottom zones; look for closest */
comment|/* Family edge that is within the one pixel threshold.          */
name|minDiff
operator|=
name|CF2_FIXED_MAX
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|numFamilyOtherBlues
condition|;
name|j
operator|+=
literal|2
control|)
block|{
comment|/* top edge */
name|flatFamilyEdge
operator|=
name|cf2_blueToFixed
argument_list|(
name|familyOtherBlues
index|[
name|j
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
name|diff
operator|=
name|cf2_fixedAbs
argument_list|(
name|flatEdge
operator|-
name|flatFamilyEdge
argument_list|)
expr_stmt|;
if|if
condition|(
name|diff
operator|<
name|minDiff
operator|&&
name|diff
operator|<
name|csUnitsPerPixel
condition|)
block|{
name|blues
operator|->
name|zone
index|[
name|i
index|]
operator|.
name|csFlatEdge
operator|=
name|flatFamilyEdge
expr_stmt|;
name|minDiff
operator|=
name|diff
expr_stmt|;
if|if
condition|(
name|diff
operator|==
literal|0
condition|)
break|break;
block|}
block|}
comment|/* check the first member of FamilyBlues, which is a bottom zone */
if|if
condition|(
name|numFamilyBlues
operator|>=
literal|2
condition|)
block|{
comment|/* top edge */
name|flatFamilyEdge
operator|=
name|cf2_blueToFixed
argument_list|(
name|familyBlues
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|diff
operator|=
name|cf2_fixedAbs
argument_list|(
name|flatEdge
operator|-
name|flatFamilyEdge
argument_list|)
expr_stmt|;
if|if
condition|(
name|diff
operator|<
name|minDiff
operator|&&
name|diff
operator|<
name|csUnitsPerPixel
condition|)
name|blues
operator|->
name|zone
index|[
name|i
index|]
operator|.
name|csFlatEdge
operator|=
name|flatFamilyEdge
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* In a top zone, the bottom edge is the flat edge.                */
comment|/* Search `FamilyBlues' for top zones; skip first zone, which is a */
comment|/* bottom zone; look for closest Family edge that is within the    */
comment|/* one pixel threshold                                             */
name|minDiff
operator|=
name|CF2_FIXED_MAX
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|2
init|;
name|j
operator|<
name|numFamilyBlues
condition|;
name|j
operator|+=
literal|2
control|)
block|{
comment|/* bottom edge */
name|flatFamilyEdge
operator|=
name|cf2_blueToFixed
argument_list|(
name|familyBlues
index|[
name|j
index|]
argument_list|)
expr_stmt|;
comment|/* adjust edges of top zone upward by twice darkening amount */
name|flatFamilyEdge
operator|+=
literal|2
operator|*
name|font
operator|->
name|darkenY
expr_stmt|;
comment|/* bottom edge */
name|diff
operator|=
name|cf2_fixedAbs
argument_list|(
name|flatEdge
operator|-
name|flatFamilyEdge
argument_list|)
expr_stmt|;
if|if
condition|(
name|diff
operator|<
name|minDiff
operator|&&
name|diff
operator|<
name|csUnitsPerPixel
condition|)
block|{
name|blues
operator|->
name|zone
index|[
name|i
index|]
operator|.
name|csFlatEdge
operator|=
name|flatFamilyEdge
expr_stmt|;
name|minDiff
operator|=
name|diff
expr_stmt|;
if|if
condition|(
name|diff
operator|==
literal|0
condition|)
break|break;
block|}
block|}
block|}
block|}
comment|/* TODO: enforce separation of zones, including BlueFuzz */
comment|/* Adjust BlueScale; similar to AdjustBlueScale() in coretype */
comment|/* `bcsetup.c'.                                               */
if|if
condition|(
name|maxZoneHeight
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|blues
operator|->
name|blueScale
operator|>
name|FT_DivFix
argument_list|(
name|cf2_intToFixed
argument_list|(
literal|1
argument_list|)
argument_list|,
name|maxZoneHeight
argument_list|)
condition|)
block|{
comment|/* clamp at maximum scale */
name|blues
operator|->
name|blueScale
operator|=
name|FT_DivFix
argument_list|(
name|cf2_intToFixed
argument_list|(
literal|1
argument_list|)
argument_list|,
name|maxZoneHeight
argument_list|)
expr_stmt|;
block|}
comment|/*        * TODO: Revisit the bug fix for 613448.  The minimum scale        *       requirement catches a number of library fonts.  For        *       example, with default BlueScale (.039625) and 0.4 minimum,        *       the test below catches any font with maxZoneHeight< 10.1.        *       There are library fonts ranging from 2 to 10 that get        *       caught, including e.g., Eurostile LT Std Medium with        *       maxZoneHeight of 6.        *        */
if|#
directive|if
literal|0
block|if ( blueScale< .4 / maxZoneHeight )       {         tetraphilia_assert( 0 );
comment|/* clamp at minimum scale, per bug 0613448 fix */
block|blueScale = .4 / maxZoneHeight;       }
endif|#
directive|endif
block|}
comment|/*      * Suppress overshoot and boost blue zones at small sizes.  Boost      * amount varies linearly from 0.5 pixel near 0 to 0 pixel at      * blueScale cutoff.      * Note: This boost amount is different from the coretype heuristic.      *      */
if|if
condition|(
name|blues
operator|->
name|scale
operator|<
name|blues
operator|->
name|blueScale
condition|)
block|{
name|blues
operator|->
name|suppressOvershoot
operator|=
name|TRUE
expr_stmt|;
comment|/* Change rounding threshold for `dsFlatEdge'.                    */
comment|/* Note: constant changed from 0.5 to 0.6 to avoid a problem with */
comment|/*       10ppem Arial                                             */
name|blues
operator|->
name|boost
operator|=
name|cf2_floatToFixed
argument_list|(
literal|.6
argument_list|)
operator|-
name|FT_MulDiv
argument_list|(
name|cf2_floatToFixed
argument_list|(
literal|.6
argument_list|)
argument_list|,
name|blues
operator|->
name|scale
argument_list|,
name|blues
operator|->
name|blueScale
argument_list|)
expr_stmt|;
if|if
condition|(
name|blues
operator|->
name|boost
operator|>
literal|0x7FFF
condition|)
block|{
comment|/* boost must remain less than 0.5, or baseline could go negative */
name|blues
operator|->
name|boost
operator|=
literal|0x7FFF
expr_stmt|;
block|}
block|}
comment|/* boost and darkening have similar effects; don't do both */
if|if
condition|(
name|font
operator|->
name|stemDarkened
condition|)
name|blues
operator|->
name|boost
operator|=
literal|0
expr_stmt|;
comment|/* set device space alignment for each zone;    */
comment|/* apply boost amount before rounding flat edge */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|blues
operator|->
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|blues
operator|->
name|zone
index|[
name|i
index|]
operator|.
name|bottomZone
condition|)
name|blues
operator|->
name|zone
index|[
name|i
index|]
operator|.
name|dsFlatEdge
operator|=
name|cf2_fixedRound
argument_list|(
name|FT_MulFix
argument_list|(
name|blues
operator|->
name|zone
index|[
name|i
index|]
operator|.
name|csFlatEdge
argument_list|,
name|blues
operator|->
name|scale
argument_list|)
operator|-
name|blues
operator|->
name|boost
argument_list|)
expr_stmt|;
else|else
name|blues
operator|->
name|zone
index|[
name|i
index|]
operator|.
name|dsFlatEdge
operator|=
name|cf2_fixedRound
argument_list|(
name|FT_MulFix
argument_list|(
name|blues
operator|->
name|zone
index|[
name|i
index|]
operator|.
name|csFlatEdge
argument_list|,
name|blues
operator|->
name|scale
argument_list|)
operator|+
name|blues
operator|->
name|boost
argument_list|)
expr_stmt|;
block|}
block|}
end_block
begin_comment
comment|/*    * Check whether `stemHint' is captured by one of the blue zones.    *    * Zero, one or both edges may be valid; only valid edges can be    * captured.  For compatibility with CoolType, search top and bottom    * zones in the same pass (see `BlueLock').  If a hint is captured,    * return true and position the edge(s) in one of 3 ways:    *    *  1) If `BlueScale' suppresses overshoot, position the captured edge    *     at the flat edge of the zone.    *  2) If overshoot is not suppressed and `BlueShift' requires    *     overshoot, position the captured edge a minimum of 1 device pixel    *     from the flat edge.    *  3) If overshoot is not suppressed or required, position the captured    *     edge at the nearest device pixel.    *    */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Bool
argument_list|)
end_macro
begin_macro
name|cf2_blues_capture
argument_list|(
argument|const CF2_Blues  blues
argument_list|,
argument|CF2_Hint         bottomHintEdge
argument_list|,
argument|CF2_Hint         topHintEdge
argument_list|)
end_macro
begin_block
block|{
comment|/* TODO: validate? */
name|CF2_Fixed
name|csFuzz
init|=
name|blues
operator|->
name|blueFuzz
decl_stmt|;
comment|/* new position of captured edge */
name|CF2_Fixed
name|dsNew
decl_stmt|;
comment|/* amount that hint is moved when positioned */
name|CF2_Fixed
name|dsMove
init|=
literal|0
decl_stmt|;
name|FT_Bool
name|captured
init|=
name|FALSE
decl_stmt|;
name|CF2_UInt
name|i
decl_stmt|;
comment|/* assert edge flags are consistent */
name|FT_ASSERT
argument_list|(
operator|!
name|cf2_hint_isTop
argument_list|(
name|bottomHintEdge
argument_list|)
operator|&&
operator|!
name|cf2_hint_isBottom
argument_list|(
name|topHintEdge
argument_list|)
argument_list|)
expr_stmt|;
comment|/* TODO: search once without blue fuzz for compatibility with coretype? */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|blues
operator|->
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|blues
operator|->
name|zone
index|[
name|i
index|]
operator|.
name|bottomZone
operator|&&
name|cf2_hint_isBottom
argument_list|(
name|bottomHintEdge
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|blues
operator|->
name|zone
index|[
name|i
index|]
operator|.
name|csBottomEdge
operator|-
name|csFuzz
operator|)
operator|<=
name|bottomHintEdge
operator|->
name|csCoord
operator|&&
name|bottomHintEdge
operator|->
name|csCoord
operator|<=
operator|(
name|blues
operator|->
name|zone
index|[
name|i
index|]
operator|.
name|csTopEdge
operator|+
name|csFuzz
operator|)
condition|)
block|{
comment|/* bottom edge captured by bottom zone */
if|if
condition|(
name|blues
operator|->
name|suppressOvershoot
condition|)
name|dsNew
operator|=
name|blues
operator|->
name|zone
index|[
name|i
index|]
operator|.
name|dsFlatEdge
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|blues
operator|->
name|zone
index|[
name|i
index|]
operator|.
name|csTopEdge
operator|-
name|bottomHintEdge
operator|->
name|csCoord
operator|)
operator|>=
name|blues
operator|->
name|blueShift
condition|)
block|{
comment|/* guarantee minimum of 1 pixel overshoot */
name|dsNew
operator|=
name|FT_MIN
argument_list|(
name|cf2_fixedRound
argument_list|(
name|bottomHintEdge
operator|->
name|dsCoord
argument_list|)
argument_list|,
name|blues
operator|->
name|zone
index|[
name|i
index|]
operator|.
name|dsFlatEdge
operator|-
name|cf2_intToFixed
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* simply round captured edge */
name|dsNew
operator|=
name|cf2_fixedRound
argument_list|(
name|bottomHintEdge
operator|->
name|dsCoord
argument_list|)
expr_stmt|;
block|}
name|dsMove
operator|=
name|dsNew
operator|-
name|bottomHintEdge
operator|->
name|dsCoord
expr_stmt|;
name|captured
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|blues
operator|->
name|zone
index|[
name|i
index|]
operator|.
name|bottomZone
operator|&&
name|cf2_hint_isTop
argument_list|(
name|topHintEdge
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|blues
operator|->
name|zone
index|[
name|i
index|]
operator|.
name|csBottomEdge
operator|-
name|csFuzz
operator|)
operator|<=
name|topHintEdge
operator|->
name|csCoord
operator|&&
name|topHintEdge
operator|->
name|csCoord
operator|<=
operator|(
name|blues
operator|->
name|zone
index|[
name|i
index|]
operator|.
name|csTopEdge
operator|+
name|csFuzz
operator|)
condition|)
block|{
comment|/* top edge captured by top zone */
if|if
condition|(
name|blues
operator|->
name|suppressOvershoot
condition|)
name|dsNew
operator|=
name|blues
operator|->
name|zone
index|[
name|i
index|]
operator|.
name|dsFlatEdge
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|topHintEdge
operator|->
name|csCoord
operator|-
name|blues
operator|->
name|zone
index|[
name|i
index|]
operator|.
name|csBottomEdge
operator|)
operator|>=
name|blues
operator|->
name|blueShift
condition|)
block|{
comment|/* guarantee minimum of 1 pixel overshoot */
name|dsNew
operator|=
name|FT_MAX
argument_list|(
name|cf2_fixedRound
argument_list|(
name|topHintEdge
operator|->
name|dsCoord
argument_list|)
argument_list|,
name|blues
operator|->
name|zone
index|[
name|i
index|]
operator|.
name|dsFlatEdge
operator|+
name|cf2_intToFixed
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* simply round captured edge */
name|dsNew
operator|=
name|cf2_fixedRound
argument_list|(
name|topHintEdge
operator|->
name|dsCoord
argument_list|)
expr_stmt|;
block|}
name|dsMove
operator|=
name|dsNew
operator|-
name|topHintEdge
operator|->
name|dsCoord
expr_stmt|;
name|captured
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|captured
condition|)
block|{
comment|/* move both edges and flag them `locked' */
if|if
condition|(
name|cf2_hint_isValid
argument_list|(
name|bottomHintEdge
argument_list|)
condition|)
block|{
name|bottomHintEdge
operator|->
name|dsCoord
operator|+=
name|dsMove
expr_stmt|;
name|cf2_hint_lock
argument_list|(
name|bottomHintEdge
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cf2_hint_isValid
argument_list|(
name|topHintEdge
argument_list|)
condition|)
block|{
name|topHintEdge
operator|->
name|dsCoord
operator|+=
name|dsMove
expr_stmt|;
name|cf2_hint_lock
argument_list|(
name|topHintEdge
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|captured
return|;
block|}
end_block
begin_comment
comment|/* END */
end_comment
end_unit
