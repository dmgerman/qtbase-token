begin_unit
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  cf2hints.c                                                             */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*    Adobe's code for handling CFF hints (body).                          */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  Copyright 2007-2014 Adobe Systems Incorporated.                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  This software, and all works of authorship, whether in source or       */
end_comment
begin_comment
comment|/*  object code form as indicated by the copyright notice(s) included      */
end_comment
begin_comment
comment|/*  herein (collectively, the "Work") is made available, and may only be   */
end_comment
begin_comment
comment|/*  used, modified, and distributed under the FreeType Project License,    */
end_comment
begin_comment
comment|/*  LICENSE.TXT.  Additionally, subject to the terms and conditions of the */
end_comment
begin_comment
comment|/*  FreeType Project License, each contributor to the Work hereby grants   */
end_comment
begin_comment
comment|/*  to any individual or legal entity exercising permissions granted by    */
end_comment
begin_comment
comment|/*  the FreeType Project License and this section (hereafter, "You" or     */
end_comment
begin_comment
comment|/*  "Your") a perpetual, worldwide, non-exclusive, no-charge,              */
end_comment
begin_comment
comment|/*  royalty-free, irrevocable (except as stated in this section) patent    */
end_comment
begin_comment
comment|/*  license to make, have made, use, offer to sell, sell, import, and      */
end_comment
begin_comment
comment|/*  otherwise transfer the Work, where such license applies only to those  */
end_comment
begin_comment
comment|/*  patent claims licensable by such contributor that are necessarily      */
end_comment
begin_comment
comment|/*  infringed by their contribution(s) alone or by combination of their    */
end_comment
begin_comment
comment|/*  contribution(s) with the Work to which such contribution(s) was        */
end_comment
begin_comment
comment|/*  submitted.  If You institute patent litigation against any entity      */
end_comment
begin_comment
comment|/*  (including a cross-claim or counterclaim in a lawsuit) alleging that   */
end_comment
begin_comment
comment|/*  the Work or a contribution incorporated within the Work constitutes    */
end_comment
begin_comment
comment|/*  direct or contributory patent infringement, then any patent licenses   */
end_comment
begin_comment
comment|/*  granted to You under this License for that Work shall terminate as of  */
end_comment
begin_comment
comment|/*  the date such litigation is filed.                                     */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  By using, modifying, or distributing the Work you indicate that you    */
end_comment
begin_comment
comment|/*  have read and understood the terms and conditions of the               */
end_comment
begin_comment
comment|/*  FreeType Project License as well as those provided in this section,    */
end_comment
begin_comment
comment|/*  and you accept them fully.                                             */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"cf2ft.h"
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_DEBUG_H
end_include
begin_include
include|#
directive|include
file|"cf2glue.h"
end_include
begin_include
include|#
directive|include
file|"cf2font.h"
end_include
begin_include
include|#
directive|include
file|"cf2hints.h"
end_include
begin_include
include|#
directive|include
file|"cf2intrp.h"
end_include
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
end_comment
begin_comment
comment|/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
end_comment
begin_comment
comment|/* messages during execution.                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_undef
DECL|macro|FT_COMPONENT
undef|#
directive|undef
name|FT_COMPONENT
end_undef
begin_define
DECL|macro|FT_COMPONENT
define|#
directive|define
name|FT_COMPONENT
value|trace_cf2hints
end_define
begin_typedef
DECL|struct|CF2_HintMoveRec_
typedef|typedef
struct|struct
name|CF2_HintMoveRec_
block|{
DECL|member|j
name|size_t
name|j
decl_stmt|;
comment|/* index of upper hint map edge   */
DECL|member|moveUp
name|CF2_Fixed
name|moveUp
decl_stmt|;
comment|/* adjustment to optimum position */
block|}
DECL|typedef|CF2_HintMoveRec
DECL|typedef|CF2_HintMove
name|CF2_HintMoveRec
operator|,
typedef|*
name|CF2_HintMove
typedef|;
end_typedef
begin_comment
comment|/* Compute angular momentum for winding order detection.  It is called */
end_comment
begin_comment
comment|/* for all lines and curves, but not necessarily in element order.     */
end_comment
begin_function
specifier|static
name|CF2_Int
DECL|function|cf2_getWindingMomentum
name|cf2_getWindingMomentum
parameter_list|(
name|CF2_Fixed
name|x1
parameter_list|,
name|CF2_Fixed
name|y1
parameter_list|,
name|CF2_Fixed
name|x2
parameter_list|,
name|CF2_Fixed
name|y2
parameter_list|)
block|{
comment|/* cross product of pt1 position from origin with pt2 position from  */
comment|/* pt1; we reduce the precision so that the result fits into 32 bits */
return|return
operator|(
name|x1
operator|>>
literal|16
operator|)
operator|*
operator|(
operator|(
name|y2
operator|-
name|y1
operator|)
operator|>>
literal|16
operator|)
operator|-
operator|(
name|y1
operator|>>
literal|16
operator|)
operator|*
operator|(
operator|(
name|x2
operator|-
name|x1
operator|)
operator|>>
literal|16
operator|)
return|;
block|}
end_function
begin_comment
comment|/*    * Construct from a StemHint; this is used as a parameter to    * `cf2_blues_capture'.    * `hintOrigin' is the character space displacement of a seac accent.    * Adjust stem hint for darkening here.    *    */
end_comment
begin_function
specifier|static
name|void
DECL|function|cf2_hint_init
name|cf2_hint_init
parameter_list|(
name|CF2_Hint
name|hint
parameter_list|,
specifier|const
name|CF2_ArrStack
name|stemHintArray
parameter_list|,
name|size_t
name|indexStemHint
parameter_list|,
specifier|const
name|CF2_Font
name|font
parameter_list|,
name|CF2_Fixed
name|hintOrigin
parameter_list|,
name|CF2_Fixed
name|scale
parameter_list|,
name|FT_Bool
name|bottom
parameter_list|)
block|{
name|CF2_Fixed
name|width
decl_stmt|;
specifier|const
name|CF2_StemHintRec
modifier|*
name|stemHint
decl_stmt|;
name|FT_ZERO
argument_list|(
name|hint
argument_list|)
expr_stmt|;
name|stemHint
operator|=
operator|(
specifier|const
name|CF2_StemHintRec
operator|*
operator|)
name|cf2_arrstack_getPointer
argument_list|(
name|stemHintArray
argument_list|,
name|indexStemHint
argument_list|)
expr_stmt|;
name|width
operator|=
name|stemHint
operator|->
name|max
operator|-
name|stemHint
operator|->
name|min
expr_stmt|;
if|if
condition|(
name|width
operator|==
name|cf2_intToFixed
argument_list|(
operator|-
literal|21
argument_list|)
condition|)
block|{
comment|/* ghost bottom */
if|if
condition|(
name|bottom
condition|)
block|{
name|hint
operator|->
name|csCoord
operator|=
name|stemHint
operator|->
name|max
expr_stmt|;
name|hint
operator|->
name|flags
operator|=
name|CF2_GhostBottom
expr_stmt|;
block|}
else|else
name|hint
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|width
operator|==
name|cf2_intToFixed
argument_list|(
operator|-
literal|20
argument_list|)
condition|)
block|{
comment|/* ghost top */
if|if
condition|(
name|bottom
condition|)
name|hint
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|hint
operator|->
name|csCoord
operator|=
name|stemHint
operator|->
name|min
expr_stmt|;
name|hint
operator|->
name|flags
operator|=
name|CF2_GhostTop
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|width
operator|<
literal|0
condition|)
block|{
comment|/* inverted pair */
comment|/*        * Hints with negative widths were produced by an early version of a        * non-Adobe font tool.  The Type 2 spec allows edge (ghost) hints        * with negative widths, but says        *        *   All other negative widths have undefined meaning.        *        * CoolType has a silent workaround that negates the hint width; for        * permissive mode, we do the same here.        *        * Note: Such fonts cannot use ghost hints, but should otherwise work.        * Note: Some poor hints in our faux fonts can produce negative        *       widths at some blends.  For example, see a light weight of        *       `u' in ASerifMM.        *        */
if|if
condition|(
name|bottom
condition|)
block|{
name|hint
operator|->
name|csCoord
operator|=
name|stemHint
operator|->
name|max
expr_stmt|;
name|hint
operator|->
name|flags
operator|=
name|CF2_PairBottom
expr_stmt|;
block|}
else|else
block|{
name|hint
operator|->
name|csCoord
operator|=
name|stemHint
operator|->
name|min
expr_stmt|;
name|hint
operator|->
name|flags
operator|=
name|CF2_PairTop
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* normal pair */
if|if
condition|(
name|bottom
condition|)
block|{
name|hint
operator|->
name|csCoord
operator|=
name|stemHint
operator|->
name|min
expr_stmt|;
name|hint
operator|->
name|flags
operator|=
name|CF2_PairBottom
expr_stmt|;
block|}
else|else
block|{
name|hint
operator|->
name|csCoord
operator|=
name|stemHint
operator|->
name|max
expr_stmt|;
name|hint
operator|->
name|flags
operator|=
name|CF2_PairTop
expr_stmt|;
block|}
block|}
comment|/* Now that ghost hints have been detected, adjust this edge for      */
comment|/* darkening.  Bottoms are not changed; tops are incremented by twice */
comment|/* `darkenY'.                                                         */
if|if
condition|(
name|cf2_hint_isTop
argument_list|(
name|hint
argument_list|)
condition|)
name|hint
operator|->
name|csCoord
operator|+=
literal|2
operator|*
name|font
operator|->
name|darkenY
expr_stmt|;
name|hint
operator|->
name|csCoord
operator|+=
name|hintOrigin
expr_stmt|;
name|hint
operator|->
name|scale
operator|=
name|scale
expr_stmt|;
name|hint
operator|->
name|index
operator|=
name|indexStemHint
expr_stmt|;
comment|/* index in original stem hint array */
comment|/* if original stem hint has been used, use the same position */
if|if
condition|(
name|hint
operator|->
name|flags
operator|!=
literal|0
operator|&&
name|stemHint
operator|->
name|used
condition|)
block|{
if|if
condition|(
name|cf2_hint_isTop
argument_list|(
name|hint
argument_list|)
condition|)
name|hint
operator|->
name|dsCoord
operator|=
name|stemHint
operator|->
name|maxDS
expr_stmt|;
else|else
name|hint
operator|->
name|dsCoord
operator|=
name|stemHint
operator|->
name|minDS
expr_stmt|;
name|cf2_hint_lock
argument_list|(
name|hint
argument_list|)
expr_stmt|;
block|}
else|else
name|hint
operator|->
name|dsCoord
operator|=
name|FT_MulFix
argument_list|(
name|hint
operator|->
name|csCoord
argument_list|,
name|scale
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* initialize an invalid hint map element */
end_comment
begin_function
specifier|static
name|void
DECL|function|cf2_hint_initZero
name|cf2_hint_initZero
parameter_list|(
name|CF2_Hint
name|hint
parameter_list|)
block|{
name|FT_ZERO
argument_list|(
name|hint
argument_list|)
expr_stmt|;
block|}
end_function
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Bool
argument_list|)
end_macro
begin_macro
name|cf2_hint_isValid
argument_list|(
argument|const CF2_Hint  hint
argument_list|)
end_macro
begin_block
block|{
return|return
call|(
name|FT_Bool
call|)
argument_list|(
name|hint
operator|->
name|flags
operator|!=
literal|0
argument_list|)
return|;
block|}
end_block
begin_function
specifier|static
name|FT_Bool
DECL|function|cf2_hint_isPair
name|cf2_hint_isPair
parameter_list|(
specifier|const
name|CF2_Hint
name|hint
parameter_list|)
block|{
return|return
call|(
name|FT_Bool
call|)
argument_list|(
operator|(
name|hint
operator|->
name|flags
operator|&
operator|(
name|CF2_PairBottom
operator||
name|CF2_PairTop
operator|)
operator|)
operator|!=
literal|0
argument_list|)
return|;
block|}
end_function
begin_function
specifier|static
name|FT_Bool
DECL|function|cf2_hint_isPairTop
name|cf2_hint_isPairTop
parameter_list|(
specifier|const
name|CF2_Hint
name|hint
parameter_list|)
block|{
return|return
call|(
name|FT_Bool
call|)
argument_list|(
operator|(
name|hint
operator|->
name|flags
operator|&
name|CF2_PairTop
operator|)
operator|!=
literal|0
argument_list|)
return|;
block|}
end_function
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Bool
argument_list|)
end_macro
begin_macro
name|cf2_hint_isTop
argument_list|(
argument|const CF2_Hint  hint
argument_list|)
end_macro
begin_block
block|{
return|return
call|(
name|FT_Bool
call|)
argument_list|(
operator|(
name|hint
operator|->
name|flags
operator|&
operator|(
name|CF2_PairTop
operator||
name|CF2_GhostTop
operator|)
operator|)
operator|!=
literal|0
argument_list|)
return|;
block|}
end_block
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Bool
argument_list|)
end_macro
begin_macro
name|cf2_hint_isBottom
argument_list|(
argument|const CF2_Hint  hint
argument_list|)
end_macro
begin_block
block|{
return|return
call|(
name|FT_Bool
call|)
argument_list|(
operator|(
name|hint
operator|->
name|flags
operator|&
operator|(
name|CF2_PairBottom
operator||
name|CF2_GhostBottom
operator|)
operator|)
operator|!=
literal|0
argument_list|)
return|;
block|}
end_block
begin_function
specifier|static
name|FT_Bool
DECL|function|cf2_hint_isLocked
name|cf2_hint_isLocked
parameter_list|(
specifier|const
name|CF2_Hint
name|hint
parameter_list|)
block|{
return|return
call|(
name|FT_Bool
call|)
argument_list|(
operator|(
name|hint
operator|->
name|flags
operator|&
name|CF2_Locked
operator|)
operator|!=
literal|0
argument_list|)
return|;
block|}
end_function
begin_function
specifier|static
name|FT_Bool
DECL|function|cf2_hint_isSynthetic
name|cf2_hint_isSynthetic
parameter_list|(
specifier|const
name|CF2_Hint
name|hint
parameter_list|)
block|{
return|return
call|(
name|FT_Bool
call|)
argument_list|(
operator|(
name|hint
operator|->
name|flags
operator|&
name|CF2_Synthetic
operator|)
operator|!=
literal|0
argument_list|)
return|;
block|}
end_function
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|cf2_hint_lock
name|cf2_hint_lock
argument_list|(
argument|CF2_Hint  hint
argument_list|)
end_macro
begin_block
block|{
name|hint
operator|->
name|flags
operator||=
name|CF2_Locked
expr_stmt|;
block|}
end_block
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|cf2_hintmap_init
name|cf2_hintmap_init
argument_list|(
argument|CF2_HintMap   hintmap
argument_list|,
argument|CF2_Font      font
argument_list|,
argument|CF2_HintMap   initialMap
argument_list|,
argument|CF2_ArrStack  hintMoves
argument_list|,
argument|CF2_Fixed     scale
argument_list|)
end_macro
begin_block
block|{
name|FT_ZERO
argument_list|(
name|hintmap
argument_list|)
expr_stmt|;
comment|/* copy parameters from font instance */
name|hintmap
operator|->
name|hinted
operator|=
name|font
operator|->
name|hinted
expr_stmt|;
name|hintmap
operator|->
name|scale
operator|=
name|scale
expr_stmt|;
name|hintmap
operator|->
name|font
operator|=
name|font
expr_stmt|;
name|hintmap
operator|->
name|initialHintMap
operator|=
name|initialMap
expr_stmt|;
comment|/* will clear in `cf2_hintmap_adjustHints' */
name|hintmap
operator|->
name|hintMoves
operator|=
name|hintMoves
expr_stmt|;
block|}
end_block
begin_function
specifier|static
name|FT_Bool
DECL|function|cf2_hintmap_isValid
name|cf2_hintmap_isValid
parameter_list|(
specifier|const
name|CF2_HintMap
name|hintmap
parameter_list|)
block|{
return|return
name|hintmap
operator|->
name|isValid
return|;
block|}
end_function
begin_comment
comment|/* transform character space coordinate to device space using hint map */
end_comment
begin_function
specifier|static
name|CF2_Fixed
DECL|function|cf2_hintmap_map
name|cf2_hintmap_map
parameter_list|(
name|CF2_HintMap
name|hintmap
parameter_list|,
name|CF2_Fixed
name|csCoord
parameter_list|)
block|{
if|if
condition|(
name|hintmap
operator|->
name|count
operator|==
literal|0
operator|||
operator|!
name|hintmap
operator|->
name|hinted
condition|)
block|{
comment|/* there are no hints; use uniform scale and zero offset */
return|return
name|FT_MulFix
argument_list|(
name|csCoord
argument_list|,
name|hintmap
operator|->
name|scale
argument_list|)
return|;
block|}
else|else
block|{
comment|/* start linear search from last hit */
name|CF2_UInt
name|i
init|=
name|hintmap
operator|->
name|lastIndex
decl_stmt|;
name|FT_ASSERT
argument_list|(
name|hintmap
operator|->
name|lastIndex
operator|<
name|CF2_MAX_HINT_EDGES
argument_list|)
expr_stmt|;
comment|/* search up */
while|while
condition|(
name|i
operator|<
name|hintmap
operator|->
name|count
operator|-
literal|1
operator|&&
name|csCoord
operator|>=
name|hintmap
operator|->
name|edge
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|csCoord
condition|)
name|i
operator|+=
literal|1
expr_stmt|;
comment|/* search down */
while|while
condition|(
name|i
operator|>
literal|0
operator|&&
name|csCoord
operator|<
name|hintmap
operator|->
name|edge
index|[
name|i
index|]
operator|.
name|csCoord
condition|)
name|i
operator|-=
literal|1
expr_stmt|;
name|hintmap
operator|->
name|lastIndex
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
operator|&&
name|csCoord
operator|<
name|hintmap
operator|->
name|edge
index|[
literal|0
index|]
operator|.
name|csCoord
condition|)
block|{
comment|/* special case for points below first edge: use uniform scale */
return|return
name|FT_MulFix
argument_list|(
name|csCoord
operator|-
name|hintmap
operator|->
name|edge
index|[
literal|0
index|]
operator|.
name|csCoord
argument_list|,
name|hintmap
operator|->
name|scale
argument_list|)
operator|+
name|hintmap
operator|->
name|edge
index|[
literal|0
index|]
operator|.
name|dsCoord
return|;
block|}
else|else
block|{
comment|/*          * Note: entries with duplicate csCoord are allowed.          * Use edge[i], the highest entry where csCoord>= entry[i].csCoord          */
return|return
name|FT_MulFix
argument_list|(
name|csCoord
operator|-
name|hintmap
operator|->
name|edge
index|[
name|i
index|]
operator|.
name|csCoord
argument_list|,
name|hintmap
operator|->
name|edge
index|[
name|i
index|]
operator|.
name|scale
argument_list|)
operator|+
name|hintmap
operator|->
name|edge
index|[
name|i
index|]
operator|.
name|dsCoord
return|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*    * This hinting policy moves a hint pair in device space so that one of    * its two edges is on a device pixel boundary (its fractional part is    * zero).  `cf2_hintmap_insertHint' guarantees no overlap in CS    * space.  Ensure here that there is no overlap in DS.    *    * In the first pass, edges are adjusted relative to adjacent hints.    * Those that are below have already been adjusted.  Those that are    * above have not yet been adjusted.  If a hint above blocks an    * adjustment to an optimal position, we will try again in a second    * pass.  The second pass is top-down.    *    */
end_comment
begin_function
specifier|static
name|void
DECL|function|cf2_hintmap_adjustHints
name|cf2_hintmap_adjustHints
parameter_list|(
name|CF2_HintMap
name|hintmap
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|,
name|j
decl_stmt|;
name|cf2_arrstack_clear
argument_list|(
name|hintmap
operator|->
name|hintMoves
argument_list|)
expr_stmt|;
comment|/* working storage */
comment|/*      * First pass is bottom-up (font hint order) without look-ahead.      * Locked edges are already adjusted.      * Unlocked edges begin with dsCoord from `initialHintMap'.      * Save edges that are not optimally adjusted in `hintMoves' array,      * and process them in second pass.      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hintmap
operator|->
name|count
condition|;
name|i
operator|++
control|)
block|{
name|FT_Bool
name|isPair
init|=
name|cf2_hint_isPair
argument_list|(
operator|&
name|hintmap
operator|->
name|edge
index|[
name|i
index|]
argument_list|)
decl_stmt|;
comment|/* index of upper edge (same value for ghost hint) */
name|j
operator|=
name|isPair
condition|?
name|i
operator|+
literal|1
else|:
name|i
expr_stmt|;
name|FT_ASSERT
argument_list|(
name|j
operator|<
name|hintmap
operator|->
name|count
argument_list|)
expr_stmt|;
name|FT_ASSERT
argument_list|(
name|cf2_hint_isValid
argument_list|(
operator|&
name|hintmap
operator|->
name|edge
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|FT_ASSERT
argument_list|(
name|cf2_hint_isValid
argument_list|(
operator|&
name|hintmap
operator|->
name|edge
index|[
name|j
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|FT_ASSERT
argument_list|(
name|cf2_hint_isLocked
argument_list|(
operator|&
name|hintmap
operator|->
name|edge
index|[
name|i
index|]
argument_list|)
operator|==
name|cf2_hint_isLocked
argument_list|(
operator|&
name|hintmap
operator|->
name|edge
index|[
name|j
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cf2_hint_isLocked
argument_list|(
operator|&
name|hintmap
operator|->
name|edge
index|[
name|i
index|]
argument_list|)
condition|)
block|{
comment|/* hint edge is not locked, we can adjust it */
name|CF2_Fixed
name|fracDown
init|=
name|cf2_fixedFraction
argument_list|(
name|hintmap
operator|->
name|edge
index|[
name|i
index|]
operator|.
name|dsCoord
argument_list|)
decl_stmt|;
name|CF2_Fixed
name|fracUp
init|=
name|cf2_fixedFraction
argument_list|(
name|hintmap
operator|->
name|edge
index|[
name|j
index|]
operator|.
name|dsCoord
argument_list|)
decl_stmt|;
comment|/* calculate all four possibilities; moves down are negative */
name|CF2_Fixed
name|downMoveDown
init|=
literal|0
operator|-
name|fracDown
decl_stmt|;
name|CF2_Fixed
name|upMoveDown
init|=
literal|0
operator|-
name|fracUp
decl_stmt|;
name|CF2_Fixed
name|downMoveUp
init|=
name|fracDown
operator|==
literal|0
condition|?
literal|0
else|:
name|cf2_intToFixed
argument_list|(
literal|1
argument_list|)
operator|-
name|fracDown
decl_stmt|;
name|CF2_Fixed
name|upMoveUp
init|=
name|fracUp
operator|==
literal|0
condition|?
literal|0
else|:
name|cf2_intToFixed
argument_list|(
literal|1
argument_list|)
operator|-
name|fracUp
decl_stmt|;
comment|/* smallest move up */
name|CF2_Fixed
name|moveUp
init|=
name|FT_MIN
argument_list|(
name|downMoveUp
argument_list|,
name|upMoveUp
argument_list|)
decl_stmt|;
comment|/* smallest move down */
name|CF2_Fixed
name|moveDown
init|=
name|FT_MAX
argument_list|(
name|downMoveDown
argument_list|,
name|upMoveDown
argument_list|)
decl_stmt|;
comment|/* final amount to move edge or edge pair */
name|CF2_Fixed
name|move
decl_stmt|;
name|CF2_Fixed
name|downMinCounter
init|=
name|CF2_MIN_COUNTER
decl_stmt|;
name|CF2_Fixed
name|upMinCounter
init|=
name|CF2_MIN_COUNTER
decl_stmt|;
name|FT_Bool
name|saveEdge
init|=
name|FALSE
decl_stmt|;
comment|/* minimum counter constraint doesn't apply when adjacent edges */
comment|/* are synthetic                                                */
comment|/* TODO: doesn't seem a big effect; for now, reduce the code    */
if|#
directive|if
literal|0
block|if ( i == 0                                        ||              cf2_hint_isSynthetic(&hintmap->edge[i - 1] ) )           downMinCounter = 0;          if ( j>= hintmap->count - 1                       ||              cf2_hint_isSynthetic(&hintmap->edge[j + 1] ) )           upMinCounter = 0;
endif|#
directive|endif
comment|/* is there room to move up?                                    */
comment|/* there is if we are at top of array or the next edge is at or */
comment|/* beyond proposed move up?                                     */
if|if
condition|(
name|j
operator|>=
name|hintmap
operator|->
name|count
operator|-
literal|1
operator|||
name|hintmap
operator|->
name|edge
index|[
name|j
operator|+
literal|1
index|]
operator|.
name|dsCoord
operator|>=
name|hintmap
operator|->
name|edge
index|[
name|j
index|]
operator|.
name|dsCoord
operator|+
name|moveUp
operator|+
name|upMinCounter
condition|)
block|{
comment|/* there is room to move up; is there also room to move down? */
if|if
condition|(
name|i
operator|==
literal|0
operator|||
name|hintmap
operator|->
name|edge
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|dsCoord
operator|<=
name|hintmap
operator|->
name|edge
index|[
name|i
index|]
operator|.
name|dsCoord
operator|+
name|moveDown
operator|-
name|downMinCounter
condition|)
block|{
comment|/* move smaller absolute amount */
name|move
operator|=
operator|(
operator|-
name|moveDown
operator|<
name|moveUp
operator|)
condition|?
name|moveDown
else|:
name|moveUp
expr_stmt|;
comment|/* optimum */
block|}
else|else
name|move
operator|=
name|moveUp
expr_stmt|;
block|}
else|else
block|{
comment|/* is there room to move down? */
if|if
condition|(
name|i
operator|==
literal|0
operator|||
name|hintmap
operator|->
name|edge
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|dsCoord
operator|<=
name|hintmap
operator|->
name|edge
index|[
name|i
index|]
operator|.
name|dsCoord
operator|+
name|moveDown
operator|-
name|downMinCounter
condition|)
block|{
name|move
operator|=
name|moveDown
expr_stmt|;
comment|/* true if non-optimum move */
name|saveEdge
operator|=
call|(
name|FT_Bool
call|)
argument_list|(
name|moveUp
operator|<
operator|-
name|moveDown
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* no room to move either way without overlapping or reducing */
comment|/* the counter too much                                       */
name|move
operator|=
literal|0
expr_stmt|;
name|saveEdge
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
comment|/* Identify non-moves and moves down that aren't optimal, and save */
comment|/* them for second pass.                                           */
comment|/* Do this only if there is an unlocked edge above (which could    */
comment|/* possibly move).                                                 */
if|if
condition|(
name|saveEdge
operator|&&
name|j
operator|<
name|hintmap
operator|->
name|count
operator|-
literal|1
operator|&&
operator|!
name|cf2_hint_isLocked
argument_list|(
operator|&
name|hintmap
operator|->
name|edge
index|[
name|j
operator|+
literal|1
index|]
argument_list|)
condition|)
block|{
name|CF2_HintMoveRec
name|savedMove
decl_stmt|;
name|savedMove
operator|.
name|j
operator|=
name|j
expr_stmt|;
comment|/* desired adjustment in second pass */
name|savedMove
operator|.
name|moveUp
operator|=
name|moveUp
operator|-
name|move
expr_stmt|;
name|cf2_arrstack_push
argument_list|(
name|hintmap
operator|->
name|hintMoves
argument_list|,
operator|&
name|savedMove
argument_list|)
expr_stmt|;
block|}
comment|/* move the edge(s) */
name|hintmap
operator|->
name|edge
index|[
name|i
index|]
operator|.
name|dsCoord
operator|+=
name|move
expr_stmt|;
if|if
condition|(
name|isPair
condition|)
name|hintmap
operator|->
name|edge
index|[
name|j
index|]
operator|.
name|dsCoord
operator|+=
name|move
expr_stmt|;
block|}
comment|/* assert there are no overlaps in device space */
name|FT_ASSERT
argument_list|(
name|i
operator|==
literal|0
operator|||
name|hintmap
operator|->
name|edge
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|dsCoord
operator|<=
name|hintmap
operator|->
name|edge
index|[
name|i
index|]
operator|.
name|dsCoord
argument_list|)
expr_stmt|;
name|FT_ASSERT
argument_list|(
name|i
operator|<
name|j
operator|||
name|hintmap
operator|->
name|edge
index|[
name|i
index|]
operator|.
name|dsCoord
operator|<=
name|hintmap
operator|->
name|edge
index|[
name|j
index|]
operator|.
name|dsCoord
argument_list|)
expr_stmt|;
comment|/* adjust the scales, avoiding divide by zero */
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|hintmap
operator|->
name|edge
index|[
name|i
index|]
operator|.
name|csCoord
operator|!=
name|hintmap
operator|->
name|edge
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|csCoord
condition|)
name|hintmap
operator|->
name|edge
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|scale
operator|=
name|FT_DivFix
argument_list|(
name|hintmap
operator|->
name|edge
index|[
name|i
index|]
operator|.
name|dsCoord
operator|-
name|hintmap
operator|->
name|edge
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|dsCoord
argument_list|,
name|hintmap
operator|->
name|edge
index|[
name|i
index|]
operator|.
name|csCoord
operator|-
name|hintmap
operator|->
name|edge
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|csCoord
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isPair
condition|)
block|{
if|if
condition|(
name|hintmap
operator|->
name|edge
index|[
name|j
index|]
operator|.
name|csCoord
operator|!=
name|hintmap
operator|->
name|edge
index|[
name|j
operator|-
literal|1
index|]
operator|.
name|csCoord
condition|)
name|hintmap
operator|->
name|edge
index|[
name|j
operator|-
literal|1
index|]
operator|.
name|scale
operator|=
name|FT_DivFix
argument_list|(
name|hintmap
operator|->
name|edge
index|[
name|j
index|]
operator|.
name|dsCoord
operator|-
name|hintmap
operator|->
name|edge
index|[
name|j
operator|-
literal|1
index|]
operator|.
name|dsCoord
argument_list|,
name|hintmap
operator|->
name|edge
index|[
name|j
index|]
operator|.
name|csCoord
operator|-
name|hintmap
operator|->
name|edge
index|[
name|j
operator|-
literal|1
index|]
operator|.
name|csCoord
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|1
expr_stmt|;
comment|/* skip upper edge on next loop */
block|}
block|}
comment|/* second pass tries to move non-optimal hints up, in case there is */
comment|/* room now                                                         */
for|for
control|(
name|i
operator|=
name|cf2_arrstack_size
argument_list|(
name|hintmap
operator|->
name|hintMoves
argument_list|)
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|CF2_HintMove
name|hintMove
init|=
operator|(
name|CF2_HintMove
operator|)
name|cf2_arrstack_getPointer
argument_list|(
name|hintmap
operator|->
name|hintMoves
argument_list|,
name|i
operator|-
literal|1
argument_list|)
decl_stmt|;
name|j
operator|=
name|hintMove
operator|->
name|j
expr_stmt|;
comment|/* this was tested before the push, above */
name|FT_ASSERT
argument_list|(
name|j
operator|<
name|hintmap
operator|->
name|count
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* is there room to move up? */
if|if
condition|(
name|hintmap
operator|->
name|edge
index|[
name|j
operator|+
literal|1
index|]
operator|.
name|dsCoord
operator|>=
name|hintmap
operator|->
name|edge
index|[
name|j
index|]
operator|.
name|dsCoord
operator|+
name|hintMove
operator|->
name|moveUp
operator|+
name|CF2_MIN_COUNTER
condition|)
block|{
comment|/* there is more room now, move edge up */
name|hintmap
operator|->
name|edge
index|[
name|j
index|]
operator|.
name|dsCoord
operator|+=
name|hintMove
operator|->
name|moveUp
expr_stmt|;
if|if
condition|(
name|cf2_hint_isPair
argument_list|(
operator|&
name|hintmap
operator|->
name|edge
index|[
name|j
index|]
argument_list|)
condition|)
block|{
name|FT_ASSERT
argument_list|(
name|j
operator|>
literal|0
argument_list|)
expr_stmt|;
name|hintmap
operator|->
name|edge
index|[
name|j
operator|-
literal|1
index|]
operator|.
name|dsCoord
operator|+=
name|hintMove
operator|->
name|moveUp
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_comment
comment|/* insert hint edges into map, sorted by csCoord */
end_comment
begin_function
specifier|static
name|void
DECL|function|cf2_hintmap_insertHint
name|cf2_hintmap_insertHint
parameter_list|(
name|CF2_HintMap
name|hintmap
parameter_list|,
name|CF2_Hint
name|bottomHintEdge
parameter_list|,
name|CF2_Hint
name|topHintEdge
parameter_list|)
block|{
name|CF2_UInt
name|indexInsert
decl_stmt|;
comment|/* set default values, then check for edge hints */
name|FT_Bool
name|isPair
init|=
name|TRUE
decl_stmt|;
name|CF2_Hint
name|firstHintEdge
init|=
name|bottomHintEdge
decl_stmt|;
name|CF2_Hint
name|secondHintEdge
init|=
name|topHintEdge
decl_stmt|;
comment|/* one or none of the input params may be invalid when dealing with */
comment|/* edge hints; at least one edge must be valid                      */
name|FT_ASSERT
argument_list|(
name|cf2_hint_isValid
argument_list|(
name|bottomHintEdge
argument_list|)
operator|||
name|cf2_hint_isValid
argument_list|(
name|topHintEdge
argument_list|)
argument_list|)
expr_stmt|;
comment|/* determine how many and which edges to insert */
if|if
condition|(
operator|!
name|cf2_hint_isValid
argument_list|(
name|bottomHintEdge
argument_list|)
condition|)
block|{
comment|/* insert only the top edge */
name|firstHintEdge
operator|=
name|topHintEdge
expr_stmt|;
name|isPair
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|cf2_hint_isValid
argument_list|(
name|topHintEdge
argument_list|)
condition|)
block|{
comment|/* insert only the bottom edge */
name|isPair
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/* paired edges must be in proper order */
name|FT_ASSERT
argument_list|(
operator|!
name|isPair
operator|||
name|topHintEdge
operator|->
name|csCoord
operator|>=
name|bottomHintEdge
operator|->
name|csCoord
argument_list|)
expr_stmt|;
comment|/* linear search to find index value of insertion point */
name|indexInsert
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|indexInsert
operator|<
name|hintmap
operator|->
name|count
condition|;
name|indexInsert
operator|++
control|)
block|{
if|if
condition|(
name|hintmap
operator|->
name|edge
index|[
name|indexInsert
index|]
operator|.
name|csCoord
operator|>=
name|firstHintEdge
operator|->
name|csCoord
condition|)
break|break;
block|}
comment|/*      * Discard any hints that overlap in character space.  Most often, this      * is while building the initial map, where captured hints from all      * zones are combined.  Define overlap to include hints that `touch'      * (overlap zero).  Hiragino Sans/Gothic fonts have numerous hints that      * touch.  Some fonts have non-ideographic glyphs that overlap our      * synthetic hints.      *      * Overlap also occurs when darkening stem hints that are close.      *      */
if|if
condition|(
name|indexInsert
operator|<
name|hintmap
operator|->
name|count
condition|)
block|{
comment|/* we are inserting before an existing edge:    */
comment|/* verify that an existing edge is not the same */
if|if
condition|(
name|hintmap
operator|->
name|edge
index|[
name|indexInsert
index|]
operator|.
name|csCoord
operator|==
name|firstHintEdge
operator|->
name|csCoord
condition|)
return|return;
comment|/* ignore overlapping stem hint */
comment|/* verify that a new pair does not straddle the next edge */
if|if
condition|(
name|isPair
operator|&&
name|hintmap
operator|->
name|edge
index|[
name|indexInsert
index|]
operator|.
name|csCoord
operator|<=
name|secondHintEdge
operator|->
name|csCoord
condition|)
return|return;
comment|/* ignore overlapping stem hint */
comment|/* verify that we are not inserting between paired edges */
if|if
condition|(
name|cf2_hint_isPairTop
argument_list|(
operator|&
name|hintmap
operator|->
name|edge
index|[
name|indexInsert
index|]
argument_list|)
condition|)
return|return;
comment|/* ignore overlapping stem hint */
block|}
comment|/* recompute device space locations using initial hint map */
if|if
condition|(
name|cf2_hintmap_isValid
argument_list|(
name|hintmap
operator|->
name|initialHintMap
argument_list|)
operator|&&
operator|!
name|cf2_hint_isLocked
argument_list|(
name|firstHintEdge
argument_list|)
condition|)
block|{
if|if
condition|(
name|isPair
condition|)
block|{
comment|/* Use hint map to position the center of stem, and nominal scale */
comment|/* to position the two edges.  This preserves the stem width.     */
name|CF2_Fixed
name|midpoint
init|=
name|cf2_hintmap_map
argument_list|(
name|hintmap
operator|->
name|initialHintMap
argument_list|,
operator|(
name|secondHintEdge
operator|->
name|csCoord
operator|+
name|firstHintEdge
operator|->
name|csCoord
operator|)
operator|/
literal|2
argument_list|)
decl_stmt|;
name|CF2_Fixed
name|halfWidth
init|=
name|FT_MulFix
argument_list|(
operator|(
name|secondHintEdge
operator|->
name|csCoord
operator|-
name|firstHintEdge
operator|->
name|csCoord
operator|)
operator|/
literal|2
argument_list|,
name|hintmap
operator|->
name|scale
argument_list|)
decl_stmt|;
name|firstHintEdge
operator|->
name|dsCoord
operator|=
name|midpoint
operator|-
name|halfWidth
expr_stmt|;
name|secondHintEdge
operator|->
name|dsCoord
operator|=
name|midpoint
operator|+
name|halfWidth
expr_stmt|;
block|}
else|else
name|firstHintEdge
operator|->
name|dsCoord
operator|=
name|cf2_hintmap_map
argument_list|(
name|hintmap
operator|->
name|initialHintMap
argument_list|,
name|firstHintEdge
operator|->
name|csCoord
argument_list|)
expr_stmt|;
block|}
comment|/*      * Discard any hints that overlap in device space; this can occur      * because locked hints have been moved to align with blue zones.      *      * TODO: Although we might correct this later during adjustment, we      * don't currently have a way to delete a conflicting hint once it has      * been inserted.  See v2.030 MinionPro-Regular, 12 ppem darkened,      * initial hint map for second path, glyph 945 (the perispomeni (tilde)      * in U+1F6E, Greek omega with psili and perispomeni).  Darkening is      * 25.  Pair 667,747 initially conflicts in design space with top edge      * 660.  This is because 667 maps to 7.87, and the top edge was      * captured by a zone at 8.0.  The pair is later successfully inserted      * in a zone without the top edge.  In this zone it is adjusted to 8.0,      * and no longer conflicts with the top edge in design space.  This      * means it can be included in yet a later zone which does have the top      * edge hint.  This produces a small mismatch between the first and      * last points of this path, even though the hint masks are the same.      * The density map difference is tiny (1/256).      *      */
if|if
condition|(
name|indexInsert
operator|>
literal|0
condition|)
block|{
comment|/* we are inserting after an existing edge */
if|if
condition|(
name|firstHintEdge
operator|->
name|dsCoord
operator|<
name|hintmap
operator|->
name|edge
index|[
name|indexInsert
operator|-
literal|1
index|]
operator|.
name|dsCoord
condition|)
return|return;
block|}
if|if
condition|(
name|indexInsert
operator|<
name|hintmap
operator|->
name|count
condition|)
block|{
comment|/* we are inserting before an existing edge */
if|if
condition|(
name|isPair
condition|)
block|{
if|if
condition|(
name|secondHintEdge
operator|->
name|dsCoord
operator|>
name|hintmap
operator|->
name|edge
index|[
name|indexInsert
index|]
operator|.
name|dsCoord
condition|)
return|return;
block|}
else|else
block|{
if|if
condition|(
name|firstHintEdge
operator|->
name|dsCoord
operator|>
name|hintmap
operator|->
name|edge
index|[
name|indexInsert
index|]
operator|.
name|dsCoord
condition|)
return|return;
block|}
block|}
comment|/* make room to insert */
block|{
name|CF2_Int
name|iSrc
init|=
name|hintmap
operator|->
name|count
operator|-
literal|1
decl_stmt|;
name|CF2_Int
name|iDst
init|=
name|isPair
condition|?
name|hintmap
operator|->
name|count
operator|+
literal|1
else|:
name|hintmap
operator|->
name|count
decl_stmt|;
name|CF2_Int
name|count
init|=
name|hintmap
operator|->
name|count
operator|-
name|indexInsert
decl_stmt|;
if|if
condition|(
name|iDst
operator|>=
name|CF2_MAX_HINT_EDGES
condition|)
block|{
name|FT_TRACE4
argument_list|(
operator|(
literal|"cf2_hintmap_insertHint: too many hintmaps\n"
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|count
operator|--
condition|)
name|hintmap
operator|->
name|edge
index|[
name|iDst
operator|--
index|]
operator|=
name|hintmap
operator|->
name|edge
index|[
name|iSrc
operator|--
index|]
expr_stmt|;
comment|/* insert first edge */
name|hintmap
operator|->
name|edge
index|[
name|indexInsert
index|]
operator|=
operator|*
name|firstHintEdge
expr_stmt|;
comment|/* copy struct */
name|hintmap
operator|->
name|count
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|isPair
condition|)
block|{
comment|/* insert second edge */
name|hintmap
operator|->
name|edge
index|[
name|indexInsert
operator|+
literal|1
index|]
operator|=
operator|*
name|secondHintEdge
expr_stmt|;
comment|/* copy struct */
name|hintmap
operator|->
name|count
operator|+=
literal|1
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function
begin_comment
comment|/*    * Build a map from hints and mask.    *    * This function may recur one level if `hintmap->initialHintMap' is not yet    * valid.    * If `initialMap' is true, simply build initial map.    *    * Synthetic hints are used in two ways.  A hint at zero is inserted, if    * needed, in the initial hint map, to prevent translations from    * propagating across the origin.  If synthetic em box hints are enabled    * for ideographic dictionaries, then they are inserted in all hint    * maps, including the initial one.    *    */
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|cf2_hintmap_build
name|cf2_hintmap_build
argument_list|(
argument|CF2_HintMap   hintmap
argument_list|,
argument|CF2_ArrStack  hStemHintArray
argument_list|,
argument|CF2_ArrStack  vStemHintArray
argument_list|,
argument|CF2_HintMask  hintMask
argument_list|,
argument|CF2_Fixed     hintOrigin
argument_list|,
argument|FT_Bool       initialMap
argument_list|)
end_macro
begin_block
block|{
name|FT_Byte
modifier|*
name|maskPtr
decl_stmt|;
name|CF2_Font
name|font
init|=
name|hintmap
operator|->
name|font
decl_stmt|;
name|CF2_HintMaskRec
name|tempHintMask
decl_stmt|;
name|size_t
name|bitCount
decl_stmt|,
name|i
decl_stmt|;
name|FT_Byte
name|maskByte
decl_stmt|;
comment|/* check whether initial map is constructed */
if|if
condition|(
operator|!
name|initialMap
operator|&&
operator|!
name|cf2_hintmap_isValid
argument_list|(
name|hintmap
operator|->
name|initialHintMap
argument_list|)
condition|)
block|{
comment|/* make recursive call with initialHintMap and temporary mask; */
comment|/* temporary mask will get all bits set, below */
name|cf2_hintmask_init
argument_list|(
operator|&
name|tempHintMask
argument_list|,
name|hintMask
operator|->
name|error
argument_list|)
expr_stmt|;
name|cf2_hintmap_build
argument_list|(
name|hintmap
operator|->
name|initialHintMap
argument_list|,
name|hStemHintArray
argument_list|,
name|vStemHintArray
argument_list|,
operator|&
name|tempHintMask
argument_list|,
name|hintOrigin
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|cf2_hintmask_isValid
argument_list|(
name|hintMask
argument_list|)
condition|)
block|{
comment|/* without a hint mask, assume all hints are active */
name|cf2_hintmask_setAll
argument_list|(
name|hintMask
argument_list|,
name|cf2_arrstack_size
argument_list|(
name|hStemHintArray
argument_list|)
operator|+
name|cf2_arrstack_size
argument_list|(
name|vStemHintArray
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cf2_hintmask_isValid
argument_list|(
name|hintMask
argument_list|)
condition|)
return|return;
comment|/* too many stem hints */
block|}
comment|/* begin by clearing the map */
name|hintmap
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|hintmap
operator|->
name|lastIndex
operator|=
literal|0
expr_stmt|;
comment|/* make a copy of the hint mask so we can modify it */
name|tempHintMask
operator|=
operator|*
name|hintMask
expr_stmt|;
name|maskPtr
operator|=
name|cf2_hintmask_getMaskPtr
argument_list|(
operator|&
name|tempHintMask
argument_list|)
expr_stmt|;
comment|/* use the hStem hints only, which are first in the mask */
name|bitCount
operator|=
name|cf2_arrstack_size
argument_list|(
name|hStemHintArray
argument_list|)
expr_stmt|;
comment|/* Defense-in-depth.  Should never return here. */
if|if
condition|(
name|bitCount
operator|>
name|hintMask
operator|->
name|bitCount
condition|)
return|return;
comment|/* synthetic embox hints get highest priority */
if|if
condition|(
name|font
operator|->
name|blues
operator|.
name|doEmBoxHints
condition|)
block|{
name|CF2_HintRec
name|dummy
decl_stmt|;
name|cf2_hint_initZero
argument_list|(
operator|&
name|dummy
argument_list|)
expr_stmt|;
comment|/* invalid hint map element */
comment|/* ghost bottom */
name|cf2_hintmap_insertHint
argument_list|(
name|hintmap
argument_list|,
operator|&
name|font
operator|->
name|blues
operator|.
name|emBoxBottomEdge
argument_list|,
operator|&
name|dummy
argument_list|)
expr_stmt|;
comment|/* ghost top */
name|cf2_hintmap_insertHint
argument_list|(
name|hintmap
argument_list|,
operator|&
name|dummy
argument_list|,
operator|&
name|font
operator|->
name|blues
operator|.
name|emBoxTopEdge
argument_list|)
expr_stmt|;
block|}
comment|/* insert hints captured by a blue zone or already locked (higher */
comment|/* priority)                                                      */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|maskByte
operator|=
literal|0x80
init|;
name|i
operator|<
name|bitCount
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|maskByte
operator|&
operator|*
name|maskPtr
condition|)
block|{
comment|/* expand StemHint into two `CF2_Hint' elements */
name|CF2_HintRec
name|bottomHintEdge
decl_stmt|,
name|topHintEdge
decl_stmt|;
name|cf2_hint_init
argument_list|(
operator|&
name|bottomHintEdge
argument_list|,
name|hStemHintArray
argument_list|,
name|i
argument_list|,
name|font
argument_list|,
name|hintOrigin
argument_list|,
name|hintmap
operator|->
name|scale
argument_list|,
name|TRUE
comment|/* bottom */
argument_list|)
expr_stmt|;
name|cf2_hint_init
argument_list|(
operator|&
name|topHintEdge
argument_list|,
name|hStemHintArray
argument_list|,
name|i
argument_list|,
name|font
argument_list|,
name|hintOrigin
argument_list|,
name|hintmap
operator|->
name|scale
argument_list|,
name|FALSE
comment|/* top */
argument_list|)
expr_stmt|;
if|if
condition|(
name|cf2_hint_isLocked
argument_list|(
operator|&
name|bottomHintEdge
argument_list|)
operator|||
name|cf2_hint_isLocked
argument_list|(
operator|&
name|topHintEdge
argument_list|)
operator|||
name|cf2_blues_capture
argument_list|(
operator|&
name|font
operator|->
name|blues
argument_list|,
operator|&
name|bottomHintEdge
argument_list|,
operator|&
name|topHintEdge
argument_list|)
condition|)
block|{
comment|/* insert captured hint into map */
name|cf2_hintmap_insertHint
argument_list|(
name|hintmap
argument_list|,
operator|&
name|bottomHintEdge
argument_list|,
operator|&
name|topHintEdge
argument_list|)
expr_stmt|;
operator|*
name|maskPtr
operator|&=
operator|~
name|maskByte
expr_stmt|;
comment|/* turn off the bit for this hint */
block|}
block|}
if|if
condition|(
operator|(
name|i
operator|&
literal|7
operator|)
operator|==
literal|7
condition|)
block|{
comment|/* move to next mask byte */
name|maskPtr
operator|++
expr_stmt|;
name|maskByte
operator|=
literal|0x80
expr_stmt|;
block|}
else|else
name|maskByte
operator|>>=
literal|1
expr_stmt|;
block|}
comment|/* initial hint map includes only captured hints plus maybe one at 0 */
comment|/*      * TODO: There is a problem here because we are trying to build a      *       single hint map containing all captured hints.  It is      *       possible for there to be conflicts between captured hints,      *       either because of darkening or because the hints are in      *       separate hint zones (we are ignoring hint zones for the      *       initial map).  An example of the latter is MinionPro-Regular      *       v2.030 glyph 883 (Greek Capital Alpha with Psili) at 15ppem.      *       A stem hint for the psili conflicts with the top edge hint      *       for the base character.  The stem hint gets priority because      *       of its sort order.  In glyph 884 (Greek Capital Alpha with      *       Psili and Oxia), the top of the base character gets a stem      *       hint, and the psili does not.  This creates different initial      *       maps for the two glyphs resulting in different renderings of      *       the base character.  Will probably defer this either as not      *       worth the cost or as a font bug.  I don't think there is any      *       good reason for an accent to be captured by an alignment      *       zone.  -darnold 2/12/10      */
if|if
condition|(
name|initialMap
condition|)
block|{
comment|/* Apply a heuristic that inserts a point for (0,0), unless it's     */
comment|/* already covered by a mapping.  This locks the baseline for glyphs */
comment|/* that have no baseline hints.                                      */
if|if
condition|(
name|hintmap
operator|->
name|count
operator|==
literal|0
operator|||
name|hintmap
operator|->
name|edge
index|[
literal|0
index|]
operator|.
name|csCoord
operator|>
literal|0
operator|||
name|hintmap
operator|->
name|edge
index|[
name|hintmap
operator|->
name|count
operator|-
literal|1
index|]
operator|.
name|csCoord
operator|<
literal|0
condition|)
block|{
comment|/* all edges are above 0 or all edges are below 0; */
comment|/* construct a locked edge hint at 0               */
name|CF2_HintRec
name|edge
decl_stmt|,
name|invalid
decl_stmt|;
name|cf2_hint_initZero
argument_list|(
operator|&
name|edge
argument_list|)
expr_stmt|;
name|edge
operator|.
name|flags
operator|=
name|CF2_GhostBottom
operator||
name|CF2_Locked
operator||
name|CF2_Synthetic
expr_stmt|;
name|edge
operator|.
name|scale
operator|=
name|hintmap
operator|->
name|scale
expr_stmt|;
name|cf2_hint_initZero
argument_list|(
operator|&
name|invalid
argument_list|)
expr_stmt|;
name|cf2_hintmap_insertHint
argument_list|(
name|hintmap
argument_list|,
operator|&
name|edge
argument_list|,
operator|&
name|invalid
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* insert remaining hints */
name|maskPtr
operator|=
name|cf2_hintmask_getMaskPtr
argument_list|(
operator|&
name|tempHintMask
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|maskByte
operator|=
literal|0x80
init|;
name|i
operator|<
name|bitCount
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|maskByte
operator|&
operator|*
name|maskPtr
condition|)
block|{
name|CF2_HintRec
name|bottomHintEdge
decl_stmt|,
name|topHintEdge
decl_stmt|;
name|cf2_hint_init
argument_list|(
operator|&
name|bottomHintEdge
argument_list|,
name|hStemHintArray
argument_list|,
name|i
argument_list|,
name|font
argument_list|,
name|hintOrigin
argument_list|,
name|hintmap
operator|->
name|scale
argument_list|,
name|TRUE
comment|/* bottom */
argument_list|)
expr_stmt|;
name|cf2_hint_init
argument_list|(
operator|&
name|topHintEdge
argument_list|,
name|hStemHintArray
argument_list|,
name|i
argument_list|,
name|font
argument_list|,
name|hintOrigin
argument_list|,
name|hintmap
operator|->
name|scale
argument_list|,
name|FALSE
comment|/* top */
argument_list|)
expr_stmt|;
name|cf2_hintmap_insertHint
argument_list|(
name|hintmap
argument_list|,
operator|&
name|bottomHintEdge
argument_list|,
operator|&
name|topHintEdge
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|i
operator|&
literal|7
operator|)
operator|==
literal|7
condition|)
block|{
comment|/* move to next mask byte */
name|maskPtr
operator|++
expr_stmt|;
name|maskByte
operator|=
literal|0x80
expr_stmt|;
block|}
else|else
name|maskByte
operator|>>=
literal|1
expr_stmt|;
block|}
block|}
comment|/*      * Note: The following line is a convenient place to break when      *       debugging hinting.  Examine `hintmap->edge' for the list of      *       enabled hints, then step over the call to see the effect of      *       adjustment.  We stop here first on the recursive call that      *       creates the initial map, and then on each counter group and      *       hint zone.      */
comment|/* adjust positions of hint edges that are not locked to blue zones */
name|cf2_hintmap_adjustHints
argument_list|(
name|hintmap
argument_list|)
expr_stmt|;
comment|/* save the position of all hints that were used in this hint map; */
comment|/* if we use them again, we'll locate them in the same position    */
if|if
condition|(
operator|!
name|initialMap
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hintmap
operator|->
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|cf2_hint_isSynthetic
argument_list|(
operator|&
name|hintmap
operator|->
name|edge
index|[
name|i
index|]
argument_list|)
condition|)
block|{
comment|/* Note: include both valid and invalid edges            */
comment|/* Note: top and bottom edges are copied back separately */
name|CF2_StemHint
name|stemhint
init|=
operator|(
name|CF2_StemHint
operator|)
name|cf2_arrstack_getPointer
argument_list|(
name|hStemHintArray
argument_list|,
name|hintmap
operator|->
name|edge
index|[
name|i
index|]
operator|.
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
name|cf2_hint_isTop
argument_list|(
operator|&
name|hintmap
operator|->
name|edge
index|[
name|i
index|]
argument_list|)
condition|)
name|stemhint
operator|->
name|maxDS
operator|=
name|hintmap
operator|->
name|edge
index|[
name|i
index|]
operator|.
name|dsCoord
expr_stmt|;
else|else
name|stemhint
operator|->
name|minDS
operator|=
name|hintmap
operator|->
name|edge
index|[
name|i
index|]
operator|.
name|dsCoord
expr_stmt|;
name|stemhint
operator|->
name|used
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
comment|/* hint map is ready to use */
name|hintmap
operator|->
name|isValid
operator|=
name|TRUE
expr_stmt|;
comment|/* remember this mask has been used */
name|cf2_hintmask_setNew
argument_list|(
name|hintMask
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_block
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|cf2_glyphpath_init
name|cf2_glyphpath_init
argument_list|(
argument|CF2_GlyphPath         glyphpath
argument_list|,
argument|CF2_Font              font
argument_list|,
argument|CF2_OutlineCallbacks  callbacks
argument_list|,
argument|CF2_Fixed             scaleY
argument_list|,
comment|/* CF2_Fixed  hShift, */
argument|CF2_ArrStack          hStemHintArray
argument_list|,
argument|CF2_ArrStack          vStemHintArray
argument_list|,
argument|CF2_HintMask          hintMask
argument_list|,
argument|CF2_Fixed             hintOriginY
argument_list|,
argument|const CF2_Blues       blues
argument_list|,
argument|const FT_Vector*      fractionalTranslation
argument_list|)
end_macro
begin_block
block|{
name|FT_ZERO
argument_list|(
name|glyphpath
argument_list|)
expr_stmt|;
name|glyphpath
operator|->
name|font
operator|=
name|font
expr_stmt|;
name|glyphpath
operator|->
name|callbacks
operator|=
name|callbacks
expr_stmt|;
name|cf2_arrstack_init
argument_list|(
operator|&
name|glyphpath
operator|->
name|hintMoves
argument_list|,
name|font
operator|->
name|memory
argument_list|,
operator|&
name|font
operator|->
name|error
argument_list|,
sizeof|sizeof
argument_list|(
name|CF2_HintMoveRec
argument_list|)
argument_list|)
expr_stmt|;
name|cf2_hintmap_init
argument_list|(
operator|&
name|glyphpath
operator|->
name|initialHintMap
argument_list|,
name|font
argument_list|,
operator|&
name|glyphpath
operator|->
name|initialHintMap
argument_list|,
operator|&
name|glyphpath
operator|->
name|hintMoves
argument_list|,
name|scaleY
argument_list|)
expr_stmt|;
name|cf2_hintmap_init
argument_list|(
operator|&
name|glyphpath
operator|->
name|firstHintMap
argument_list|,
name|font
argument_list|,
operator|&
name|glyphpath
operator|->
name|initialHintMap
argument_list|,
operator|&
name|glyphpath
operator|->
name|hintMoves
argument_list|,
name|scaleY
argument_list|)
expr_stmt|;
name|cf2_hintmap_init
argument_list|(
operator|&
name|glyphpath
operator|->
name|hintMap
argument_list|,
name|font
argument_list|,
operator|&
name|glyphpath
operator|->
name|initialHintMap
argument_list|,
operator|&
name|glyphpath
operator|->
name|hintMoves
argument_list|,
name|scaleY
argument_list|)
expr_stmt|;
name|glyphpath
operator|->
name|scaleX
operator|=
name|font
operator|->
name|innerTransform
operator|.
name|a
expr_stmt|;
name|glyphpath
operator|->
name|scaleC
operator|=
name|font
operator|->
name|innerTransform
operator|.
name|c
expr_stmt|;
name|glyphpath
operator|->
name|scaleY
operator|=
name|font
operator|->
name|innerTransform
operator|.
name|d
expr_stmt|;
name|glyphpath
operator|->
name|fractionalTranslation
operator|=
operator|*
name|fractionalTranslation
expr_stmt|;
if|#
directive|if
literal|0
block|glyphpath->hShift = hShift;
comment|/* for fauxing */
endif|#
directive|endif
name|glyphpath
operator|->
name|hStemHintArray
operator|=
name|hStemHintArray
expr_stmt|;
name|glyphpath
operator|->
name|vStemHintArray
operator|=
name|vStemHintArray
expr_stmt|;
name|glyphpath
operator|->
name|hintMask
operator|=
name|hintMask
expr_stmt|;
comment|/* ptr to current mask */
name|glyphpath
operator|->
name|hintOriginY
operator|=
name|hintOriginY
expr_stmt|;
name|glyphpath
operator|->
name|blues
operator|=
name|blues
expr_stmt|;
name|glyphpath
operator|->
name|darken
operator|=
name|font
operator|->
name|darkened
expr_stmt|;
comment|/* TODO: should we make copies? */
name|glyphpath
operator|->
name|xOffset
operator|=
name|font
operator|->
name|darkenX
expr_stmt|;
name|glyphpath
operator|->
name|yOffset
operator|=
name|font
operator|->
name|darkenY
expr_stmt|;
name|glyphpath
operator|->
name|miterLimit
operator|=
literal|2
operator|*
name|FT_MAX
argument_list|(
name|cf2_fixedAbs
argument_list|(
name|glyphpath
operator|->
name|xOffset
argument_list|)
argument_list|,
name|cf2_fixedAbs
argument_list|(
name|glyphpath
operator|->
name|yOffset
argument_list|)
argument_list|)
expr_stmt|;
comment|/* .1 character space unit */
name|glyphpath
operator|->
name|snapThreshold
operator|=
name|cf2_floatToFixed
argument_list|(
literal|0.1f
argument_list|)
expr_stmt|;
name|glyphpath
operator|->
name|moveIsPending
operator|=
name|TRUE
expr_stmt|;
name|glyphpath
operator|->
name|pathIsOpen
operator|=
name|FALSE
expr_stmt|;
name|glyphpath
operator|->
name|pathIsClosing
operator|=
name|FALSE
expr_stmt|;
name|glyphpath
operator|->
name|elemIsQueued
operator|=
name|FALSE
expr_stmt|;
block|}
end_block
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|cf2_glyphpath_finalize
name|cf2_glyphpath_finalize
argument_list|(
argument|CF2_GlyphPath  glyphpath
argument_list|)
end_macro
begin_block
block|{
name|cf2_arrstack_finalize
argument_list|(
operator|&
name|glyphpath
operator|->
name|hintMoves
argument_list|)
expr_stmt|;
block|}
end_block
begin_comment
comment|/*    * Hint point in y-direction and apply outerTransform.    * Input `current' hint map (which is actually delayed by one element).    * Input x,y point in Character Space.    * Output x,y point in Device Space, including translation.    */
end_comment
begin_function
specifier|static
name|void
DECL|function|cf2_glyphpath_hintPoint
name|cf2_glyphpath_hintPoint
parameter_list|(
name|CF2_GlyphPath
name|glyphpath
parameter_list|,
name|CF2_HintMap
name|hintmap
parameter_list|,
name|FT_Vector
modifier|*
name|ppt
parameter_list|,
name|CF2_Fixed
name|x
parameter_list|,
name|CF2_Fixed
name|y
parameter_list|)
block|{
name|FT_Vector
name|pt
decl_stmt|;
comment|/* hinted point in upright DS */
name|pt
operator|.
name|x
operator|=
name|FT_MulFix
argument_list|(
name|glyphpath
operator|->
name|scaleX
argument_list|,
name|x
argument_list|)
operator|+
name|FT_MulFix
argument_list|(
name|glyphpath
operator|->
name|scaleC
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|pt
operator|.
name|y
operator|=
name|cf2_hintmap_map
argument_list|(
name|hintmap
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|ppt
operator|->
name|x
operator|=
name|FT_MulFix
argument_list|(
name|glyphpath
operator|->
name|font
operator|->
name|outerTransform
operator|.
name|a
argument_list|,
name|pt
operator|.
name|x
argument_list|)
operator|+
name|FT_MulFix
argument_list|(
name|glyphpath
operator|->
name|font
operator|->
name|outerTransform
operator|.
name|c
argument_list|,
name|pt
operator|.
name|y
argument_list|)
operator|+
name|glyphpath
operator|->
name|fractionalTranslation
operator|.
name|x
expr_stmt|;
name|ppt
operator|->
name|y
operator|=
name|FT_MulFix
argument_list|(
name|glyphpath
operator|->
name|font
operator|->
name|outerTransform
operator|.
name|b
argument_list|,
name|pt
operator|.
name|x
argument_list|)
operator|+
name|FT_MulFix
argument_list|(
name|glyphpath
operator|->
name|font
operator|->
name|outerTransform
operator|.
name|d
argument_list|,
name|pt
operator|.
name|y
argument_list|)
operator|+
name|glyphpath
operator|->
name|fractionalTranslation
operator|.
name|y
expr_stmt|;
block|}
end_function
begin_comment
comment|/*    * From two line segments, (u1,u2) and (v1,v2), compute a point of    * intersection on the corresponding lines.    * Return false if no intersection is found, or if the intersection is    * too far away from the ends of the line segments, u2 and v1.    *    */
end_comment
begin_function
specifier|static
name|FT_Bool
DECL|function|cf2_glyphpath_computeIntersection
name|cf2_glyphpath_computeIntersection
parameter_list|(
name|CF2_GlyphPath
name|glyphpath
parameter_list|,
specifier|const
name|FT_Vector
modifier|*
name|u1
parameter_list|,
specifier|const
name|FT_Vector
modifier|*
name|u2
parameter_list|,
specifier|const
name|FT_Vector
modifier|*
name|v1
parameter_list|,
specifier|const
name|FT_Vector
modifier|*
name|v2
parameter_list|,
name|FT_Vector
modifier|*
name|intersection
parameter_list|)
block|{
comment|/*      * Let `u' be a zero-based vector from the first segment, `v' from the      * second segment.      * Let `w 'be the zero-based vector from `u1' to `v1'.      * `perp' is the `perpendicular dot product'; see      * http://mathworld.wolfram.com/PerpDotProduct.html.      * `s' is the parameter for the parametric line for the first segment      * (`u').      *      * See notation in      * http://softsurfer.com/Archive/algorithm_0104/algorithm_0104B.htm.      * Calculations are done in 16.16, but must handle the squaring of      * line lengths in character space.  We scale all vectors by 1/32 to      * avoid overflow.  This allows values up to 4095 to be squared.  The      * scale factor cancels in the divide.      *      * TODO: the scale factor could be computed from UnitsPerEm.      *      */
DECL|macro|cf2_perp
define|#
directive|define
name|cf2_perp
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
define|\
value|( FT_MulFix( a.x, b.y ) - FT_MulFix( a.y, b.x ) )
comment|/* round and divide by 32 */
DECL|macro|CF2_CS_SCALE
define|#
directive|define
name|CF2_CS_SCALE
parameter_list|(
name|x
parameter_list|)
define|\
value|( ( (x) + 0x10 )>> 5 )
name|FT_Vector
name|u
decl_stmt|,
name|v
decl_stmt|,
name|w
decl_stmt|;
comment|/* scaled vectors */
name|CF2_Fixed
name|denominator
decl_stmt|,
name|s
decl_stmt|;
name|u
operator|.
name|x
operator|=
name|CF2_CS_SCALE
argument_list|(
name|u2
operator|->
name|x
operator|-
name|u1
operator|->
name|x
argument_list|)
expr_stmt|;
name|u
operator|.
name|y
operator|=
name|CF2_CS_SCALE
argument_list|(
name|u2
operator|->
name|y
operator|-
name|u1
operator|->
name|y
argument_list|)
expr_stmt|;
name|v
operator|.
name|x
operator|=
name|CF2_CS_SCALE
argument_list|(
name|v2
operator|->
name|x
operator|-
name|v1
operator|->
name|x
argument_list|)
expr_stmt|;
name|v
operator|.
name|y
operator|=
name|CF2_CS_SCALE
argument_list|(
name|v2
operator|->
name|y
operator|-
name|v1
operator|->
name|y
argument_list|)
expr_stmt|;
name|w
operator|.
name|x
operator|=
name|CF2_CS_SCALE
argument_list|(
name|v1
operator|->
name|x
operator|-
name|u1
operator|->
name|x
argument_list|)
expr_stmt|;
name|w
operator|.
name|y
operator|=
name|CF2_CS_SCALE
argument_list|(
name|v1
operator|->
name|y
operator|-
name|u1
operator|->
name|y
argument_list|)
expr_stmt|;
name|denominator
operator|=
name|cf2_perp
argument_list|(
name|u
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|denominator
operator|==
literal|0
condition|)
return|return
name|FALSE
return|;
comment|/* parallel or coincident lines */
name|s
operator|=
name|FT_DivFix
argument_list|(
name|cf2_perp
argument_list|(
name|w
argument_list|,
name|v
argument_list|)
argument_list|,
name|denominator
argument_list|)
expr_stmt|;
name|intersection
operator|->
name|x
operator|=
name|u1
operator|->
name|x
operator|+
name|FT_MulFix
argument_list|(
name|s
argument_list|,
name|u2
operator|->
name|x
operator|-
name|u1
operator|->
name|x
argument_list|)
expr_stmt|;
name|intersection
operator|->
name|y
operator|=
name|u1
operator|->
name|y
operator|+
name|FT_MulFix
argument_list|(
name|s
argument_list|,
name|u2
operator|->
name|y
operator|-
name|u1
operator|->
name|y
argument_list|)
expr_stmt|;
comment|/*      * Special case snapping for horizontal and vertical lines.      * This cleans up intersections and reduces problems with winding      * order detection.      * Sample case is sbc cd KozGoPr6N-Medium.otf 20 16685.      * Note: these calculations are in character space.      *      */
if|if
condition|(
name|u1
operator|->
name|x
operator|==
name|u2
operator|->
name|x
operator|&&
name|cf2_fixedAbs
argument_list|(
name|intersection
operator|->
name|x
operator|-
name|u1
operator|->
name|x
argument_list|)
operator|<
name|glyphpath
operator|->
name|snapThreshold
condition|)
name|intersection
operator|->
name|x
operator|=
name|u1
operator|->
name|x
expr_stmt|;
if|if
condition|(
name|u1
operator|->
name|y
operator|==
name|u2
operator|->
name|y
operator|&&
name|cf2_fixedAbs
argument_list|(
name|intersection
operator|->
name|y
operator|-
name|u1
operator|->
name|y
argument_list|)
operator|<
name|glyphpath
operator|->
name|snapThreshold
condition|)
name|intersection
operator|->
name|y
operator|=
name|u1
operator|->
name|y
expr_stmt|;
if|if
condition|(
name|v1
operator|->
name|x
operator|==
name|v2
operator|->
name|x
operator|&&
name|cf2_fixedAbs
argument_list|(
name|intersection
operator|->
name|x
operator|-
name|v1
operator|->
name|x
argument_list|)
operator|<
name|glyphpath
operator|->
name|snapThreshold
condition|)
name|intersection
operator|->
name|x
operator|=
name|v1
operator|->
name|x
expr_stmt|;
if|if
condition|(
name|v1
operator|->
name|y
operator|==
name|v2
operator|->
name|y
operator|&&
name|cf2_fixedAbs
argument_list|(
name|intersection
operator|->
name|y
operator|-
name|v1
operator|->
name|y
argument_list|)
operator|<
name|glyphpath
operator|->
name|snapThreshold
condition|)
name|intersection
operator|->
name|y
operator|=
name|v1
operator|->
name|y
expr_stmt|;
comment|/* limit the intersection distance from midpoint of u2 and v1 */
if|if
condition|(
name|cf2_fixedAbs
argument_list|(
name|intersection
operator|->
name|x
operator|-
operator|(
name|u2
operator|->
name|x
operator|+
name|v1
operator|->
name|x
operator|)
operator|/
literal|2
argument_list|)
operator|>
name|glyphpath
operator|->
name|miterLimit
operator|||
name|cf2_fixedAbs
argument_list|(
name|intersection
operator|->
name|y
operator|-
operator|(
name|u2
operator|->
name|y
operator|+
name|v1
operator|->
name|y
operator|)
operator|/
literal|2
argument_list|)
operator|>
name|glyphpath
operator|->
name|miterLimit
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function
begin_comment
comment|/*    * Push the cached element (glyphpath->prevElem*) to the outline    * consumer.  When a darkening offset is used, the end point of the    * cached element may be adjusted to an intersection point or we may    * synthesize a connecting line to the current element.  If we are    * closing a subpath, we may also generate a connecting line to the start    * point.    *    * This is where Character Space (CS) is converted to Device Space (DS)    * using a hint map.  This calculation must use a HintMap that was valid    * at the time the element was saved.  For the first point in a subpath,    * that is a saved HintMap.  For most elements, it just means the caller    * has delayed building a HintMap from the current HintMask.    *    * Transform each point with outerTransform and call the outline    * callbacks.  This is a general 3x3 transform:    *    *   x' = a*x + c*y + tx, y' = b*x + d*y + ty    *    * but it uses 4 elements from CF2_Font and the translation part    * from CF2_GlyphPath.    *    */
end_comment
begin_function
specifier|static
name|void
DECL|function|cf2_glyphpath_pushPrevElem
name|cf2_glyphpath_pushPrevElem
parameter_list|(
name|CF2_GlyphPath
name|glyphpath
parameter_list|,
name|CF2_HintMap
name|hintmap
parameter_list|,
name|FT_Vector
modifier|*
name|nextP0
parameter_list|,
name|FT_Vector
name|nextP1
parameter_list|,
name|FT_Bool
name|close
parameter_list|)
block|{
name|CF2_CallbackParamsRec
name|params
decl_stmt|;
name|FT_Vector
modifier|*
name|prevP0
decl_stmt|;
name|FT_Vector
modifier|*
name|prevP1
decl_stmt|;
name|FT_Vector
name|intersection
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|FT_Bool
name|useIntersection
init|=
name|FALSE
decl_stmt|;
name|FT_ASSERT
argument_list|(
name|glyphpath
operator|->
name|prevElemOp
operator|==
name|CF2_PathOpLineTo
operator|||
name|glyphpath
operator|->
name|prevElemOp
operator|==
name|CF2_PathOpCubeTo
argument_list|)
expr_stmt|;
if|if
condition|(
name|glyphpath
operator|->
name|prevElemOp
operator|==
name|CF2_PathOpLineTo
condition|)
block|{
name|prevP0
operator|=
operator|&
name|glyphpath
operator|->
name|prevElemP0
expr_stmt|;
name|prevP1
operator|=
operator|&
name|glyphpath
operator|->
name|prevElemP1
expr_stmt|;
block|}
else|else
block|{
name|prevP0
operator|=
operator|&
name|glyphpath
operator|->
name|prevElemP2
expr_stmt|;
name|prevP1
operator|=
operator|&
name|glyphpath
operator|->
name|prevElemP3
expr_stmt|;
block|}
comment|/* optimization: if previous and next elements are offset by the same */
comment|/* amount, then there will be no gap, and no need to compute an       */
comment|/* intersection.                                                      */
if|if
condition|(
name|prevP1
operator|->
name|x
operator|!=
name|nextP0
operator|->
name|x
operator|||
name|prevP1
operator|->
name|y
operator|!=
name|nextP0
operator|->
name|y
condition|)
block|{
comment|/* previous element does not join next element:             */
comment|/* adjust end point of previous element to the intersection */
name|useIntersection
operator|=
name|cf2_glyphpath_computeIntersection
argument_list|(
name|glyphpath
argument_list|,
name|prevP0
argument_list|,
name|prevP1
argument_list|,
name|nextP0
argument_list|,
operator|&
name|nextP1
argument_list|,
operator|&
name|intersection
argument_list|)
expr_stmt|;
if|if
condition|(
name|useIntersection
condition|)
block|{
comment|/* modify the last point of the cached element (either line or */
comment|/* curve)                                                      */
operator|*
name|prevP1
operator|=
name|intersection
expr_stmt|;
block|}
block|}
name|params
operator|.
name|pt0
operator|=
name|glyphpath
operator|->
name|currentDS
expr_stmt|;
switch|switch
condition|(
name|glyphpath
operator|->
name|prevElemOp
condition|)
block|{
case|case
name|CF2_PathOpLineTo
case|:
name|params
operator|.
name|op
operator|=
name|CF2_PathOpLineTo
expr_stmt|;
comment|/* note: pt2 and pt3 are unused */
if|if
condition|(
name|close
condition|)
block|{
comment|/* use first hint map if closing */
name|cf2_glyphpath_hintPoint
argument_list|(
name|glyphpath
argument_list|,
operator|&
name|glyphpath
operator|->
name|firstHintMap
argument_list|,
operator|&
name|params
operator|.
name|pt1
argument_list|,
name|glyphpath
operator|->
name|prevElemP1
operator|.
name|x
argument_list|,
name|glyphpath
operator|->
name|prevElemP1
operator|.
name|y
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cf2_glyphpath_hintPoint
argument_list|(
name|glyphpath
argument_list|,
name|hintmap
argument_list|,
operator|&
name|params
operator|.
name|pt1
argument_list|,
name|glyphpath
operator|->
name|prevElemP1
operator|.
name|x
argument_list|,
name|glyphpath
operator|->
name|prevElemP1
operator|.
name|y
argument_list|)
expr_stmt|;
block|}
comment|/* output only non-zero length lines */
if|if
condition|(
name|params
operator|.
name|pt0
operator|.
name|x
operator|!=
name|params
operator|.
name|pt1
operator|.
name|x
operator|||
name|params
operator|.
name|pt0
operator|.
name|y
operator|!=
name|params
operator|.
name|pt1
operator|.
name|y
condition|)
block|{
name|glyphpath
operator|->
name|callbacks
operator|->
name|lineTo
argument_list|(
name|glyphpath
operator|->
name|callbacks
argument_list|,
operator|&
name|params
argument_list|)
expr_stmt|;
name|glyphpath
operator|->
name|currentDS
operator|=
name|params
operator|.
name|pt1
expr_stmt|;
block|}
break|break;
case|case
name|CF2_PathOpCubeTo
case|:
name|params
operator|.
name|op
operator|=
name|CF2_PathOpCubeTo
expr_stmt|;
comment|/* TODO: should we intersect the interior joins (p1-p2 and p2-p3)? */
name|cf2_glyphpath_hintPoint
argument_list|(
name|glyphpath
argument_list|,
name|hintmap
argument_list|,
operator|&
name|params
operator|.
name|pt1
argument_list|,
name|glyphpath
operator|->
name|prevElemP1
operator|.
name|x
argument_list|,
name|glyphpath
operator|->
name|prevElemP1
operator|.
name|y
argument_list|)
expr_stmt|;
name|cf2_glyphpath_hintPoint
argument_list|(
name|glyphpath
argument_list|,
name|hintmap
argument_list|,
operator|&
name|params
operator|.
name|pt2
argument_list|,
name|glyphpath
operator|->
name|prevElemP2
operator|.
name|x
argument_list|,
name|glyphpath
operator|->
name|prevElemP2
operator|.
name|y
argument_list|)
expr_stmt|;
name|cf2_glyphpath_hintPoint
argument_list|(
name|glyphpath
argument_list|,
name|hintmap
argument_list|,
operator|&
name|params
operator|.
name|pt3
argument_list|,
name|glyphpath
operator|->
name|prevElemP3
operator|.
name|x
argument_list|,
name|glyphpath
operator|->
name|prevElemP3
operator|.
name|y
argument_list|)
expr_stmt|;
name|glyphpath
operator|->
name|callbacks
operator|->
name|cubeTo
argument_list|(
name|glyphpath
operator|->
name|callbacks
argument_list|,
operator|&
name|params
argument_list|)
expr_stmt|;
name|glyphpath
operator|->
name|currentDS
operator|=
name|params
operator|.
name|pt3
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|useIntersection
operator|||
name|close
condition|)
block|{
comment|/* insert connecting line between end of previous element and start */
comment|/* of current one                                                   */
comment|/* note: at the end of a subpath, we might do both, so use `nextP0' */
comment|/* before we change it, below                                       */
if|if
condition|(
name|close
condition|)
block|{
comment|/* if we are closing the subpath, then nextP0 is in the first     */
comment|/* hint zone                                                      */
name|cf2_glyphpath_hintPoint
argument_list|(
name|glyphpath
argument_list|,
operator|&
name|glyphpath
operator|->
name|firstHintMap
argument_list|,
operator|&
name|params
operator|.
name|pt1
argument_list|,
name|nextP0
operator|->
name|x
argument_list|,
name|nextP0
operator|->
name|y
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cf2_glyphpath_hintPoint
argument_list|(
name|glyphpath
argument_list|,
name|hintmap
argument_list|,
operator|&
name|params
operator|.
name|pt1
argument_list|,
name|nextP0
operator|->
name|x
argument_list|,
name|nextP0
operator|->
name|y
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|params
operator|.
name|pt1
operator|.
name|x
operator|!=
name|glyphpath
operator|->
name|currentDS
operator|.
name|x
operator|||
name|params
operator|.
name|pt1
operator|.
name|y
operator|!=
name|glyphpath
operator|->
name|currentDS
operator|.
name|y
condition|)
block|{
comment|/* length is nonzero */
name|params
operator|.
name|op
operator|=
name|CF2_PathOpLineTo
expr_stmt|;
name|params
operator|.
name|pt0
operator|=
name|glyphpath
operator|->
name|currentDS
expr_stmt|;
comment|/* note: pt2 and pt3 are unused */
name|glyphpath
operator|->
name|callbacks
operator|->
name|lineTo
argument_list|(
name|glyphpath
operator|->
name|callbacks
argument_list|,
operator|&
name|params
argument_list|)
expr_stmt|;
name|glyphpath
operator|->
name|currentDS
operator|=
name|params
operator|.
name|pt1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|useIntersection
condition|)
block|{
comment|/* return intersection point to caller */
operator|*
name|nextP0
operator|=
name|intersection
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/* push a MoveTo element based on current point and offset of current */
end_comment
begin_comment
comment|/* element                                                            */
end_comment
begin_function
specifier|static
name|void
DECL|function|cf2_glyphpath_pushMove
name|cf2_glyphpath_pushMove
parameter_list|(
name|CF2_GlyphPath
name|glyphpath
parameter_list|,
name|FT_Vector
name|start
parameter_list|)
block|{
name|CF2_CallbackParamsRec
name|params
decl_stmt|;
name|params
operator|.
name|op
operator|=
name|CF2_PathOpMoveTo
expr_stmt|;
name|params
operator|.
name|pt0
operator|=
name|glyphpath
operator|->
name|currentDS
expr_stmt|;
comment|/* Test if move has really happened yet; it would have called */
comment|/* `cf2_hintmap_build' to set `isValid'.                   */
if|if
condition|(
operator|!
name|cf2_hintmap_isValid
argument_list|(
operator|&
name|glyphpath
operator|->
name|hintMap
argument_list|)
condition|)
block|{
comment|/* we are here iff first subpath is missing a moveto operator: */
comment|/* synthesize first moveTo to finish initialization of hintMap */
name|cf2_glyphpath_moveTo
argument_list|(
name|glyphpath
argument_list|,
name|glyphpath
operator|->
name|start
operator|.
name|x
argument_list|,
name|glyphpath
operator|->
name|start
operator|.
name|y
argument_list|)
expr_stmt|;
block|}
name|cf2_glyphpath_hintPoint
argument_list|(
name|glyphpath
argument_list|,
operator|&
name|glyphpath
operator|->
name|hintMap
argument_list|,
operator|&
name|params
operator|.
name|pt1
argument_list|,
name|start
operator|.
name|x
argument_list|,
name|start
operator|.
name|y
argument_list|)
expr_stmt|;
comment|/* note: pt2 and pt3 are unused */
name|glyphpath
operator|->
name|callbacks
operator|->
name|moveTo
argument_list|(
name|glyphpath
operator|->
name|callbacks
argument_list|,
operator|&
name|params
argument_list|)
expr_stmt|;
name|glyphpath
operator|->
name|currentDS
operator|=
name|params
operator|.
name|pt1
expr_stmt|;
name|glyphpath
operator|->
name|offsetStart0
operator|=
name|start
expr_stmt|;
block|}
end_function
begin_comment
comment|/*    * All coordinates are in character space.    * On input, (x1, y1) and (x2, y2) give line segment.    * On output, (x, y) give offset vector.    * We use a piecewise approximation to trig functions.    *    * TODO: Offset true perpendicular and proper length    *       supply the y-translation for hinting here, too,    *       that adds yOffset unconditionally to *y.    */
end_comment
begin_function
specifier|static
name|void
DECL|function|cf2_glyphpath_computeOffset
name|cf2_glyphpath_computeOffset
parameter_list|(
name|CF2_GlyphPath
name|glyphpath
parameter_list|,
name|CF2_Fixed
name|x1
parameter_list|,
name|CF2_Fixed
name|y1
parameter_list|,
name|CF2_Fixed
name|x2
parameter_list|,
name|CF2_Fixed
name|y2
parameter_list|,
name|CF2_Fixed
modifier|*
name|x
parameter_list|,
name|CF2_Fixed
modifier|*
name|y
parameter_list|)
block|{
name|CF2_Fixed
name|dx
init|=
name|x2
operator|-
name|x1
decl_stmt|;
name|CF2_Fixed
name|dy
init|=
name|y2
operator|-
name|y1
decl_stmt|;
comment|/* note: negative offsets don't work here; negate deltas to change */
comment|/* quadrants, below                                                */
if|if
condition|(
name|glyphpath
operator|->
name|font
operator|->
name|reverseWinding
condition|)
block|{
name|dx
operator|=
operator|-
name|dx
expr_stmt|;
name|dy
operator|=
operator|-
name|dy
expr_stmt|;
block|}
operator|*
name|x
operator|=
operator|*
name|y
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|glyphpath
operator|->
name|darken
condition|)
return|return;
comment|/* add momentum for this path element */
name|glyphpath
operator|->
name|callbacks
operator|->
name|windingMomentum
operator|+=
name|cf2_getWindingMomentum
argument_list|(
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|)
expr_stmt|;
comment|/* note: allow mixed integer and fixed multiplication here */
if|if
condition|(
name|dx
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|dy
operator|>=
literal|0
condition|)
block|{
comment|/* first quadrant, +x +y */
if|if
condition|(
name|dx
operator|>
literal|2
operator|*
name|dy
condition|)
block|{
comment|/* +x */
operator|*
name|x
operator|=
literal|0
expr_stmt|;
operator|*
name|y
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dy
operator|>
literal|2
operator|*
name|dx
condition|)
block|{
comment|/* +y */
operator|*
name|x
operator|=
name|glyphpath
operator|->
name|xOffset
expr_stmt|;
operator|*
name|y
operator|=
name|glyphpath
operator|->
name|yOffset
expr_stmt|;
block|}
else|else
block|{
comment|/* +x +y */
operator|*
name|x
operator|=
name|FT_MulFix
argument_list|(
name|cf2_floatToFixed
argument_list|(
literal|0.7
argument_list|)
argument_list|,
name|glyphpath
operator|->
name|xOffset
argument_list|)
expr_stmt|;
operator|*
name|y
operator|=
name|FT_MulFix
argument_list|(
name|cf2_floatToFixed
argument_list|(
literal|1.0
operator|-
literal|0.7
argument_list|)
argument_list|,
name|glyphpath
operator|->
name|yOffset
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* fourth quadrant, +x -y */
if|if
condition|(
name|dx
operator|>
operator|-
literal|2
operator|*
name|dy
condition|)
block|{
comment|/* +x */
operator|*
name|x
operator|=
literal|0
expr_stmt|;
operator|*
name|y
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|-
name|dy
operator|>
literal|2
operator|*
name|dx
condition|)
block|{
comment|/* -y */
operator|*
name|x
operator|=
operator|-
name|glyphpath
operator|->
name|xOffset
expr_stmt|;
operator|*
name|y
operator|=
name|glyphpath
operator|->
name|yOffset
expr_stmt|;
block|}
else|else
block|{
comment|/* +x -y */
operator|*
name|x
operator|=
name|FT_MulFix
argument_list|(
name|cf2_floatToFixed
argument_list|(
operator|-
literal|0.7
argument_list|)
argument_list|,
name|glyphpath
operator|->
name|xOffset
argument_list|)
expr_stmt|;
operator|*
name|y
operator|=
name|FT_MulFix
argument_list|(
name|cf2_floatToFixed
argument_list|(
literal|1.0
operator|-
literal|0.7
argument_list|)
argument_list|,
name|glyphpath
operator|->
name|yOffset
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|dy
operator|>=
literal|0
condition|)
block|{
comment|/* second quadrant, -x +y */
if|if
condition|(
operator|-
name|dx
operator|>
literal|2
operator|*
name|dy
condition|)
block|{
comment|/* -x */
operator|*
name|x
operator|=
literal|0
expr_stmt|;
operator|*
name|y
operator|=
literal|2
operator|*
name|glyphpath
operator|->
name|yOffset
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dy
operator|>
operator|-
literal|2
operator|*
name|dx
condition|)
block|{
comment|/* +y */
operator|*
name|x
operator|=
name|glyphpath
operator|->
name|xOffset
expr_stmt|;
operator|*
name|y
operator|=
name|glyphpath
operator|->
name|yOffset
expr_stmt|;
block|}
else|else
block|{
comment|/* -x +y */
operator|*
name|x
operator|=
name|FT_MulFix
argument_list|(
name|cf2_floatToFixed
argument_list|(
literal|0.7
argument_list|)
argument_list|,
name|glyphpath
operator|->
name|xOffset
argument_list|)
expr_stmt|;
operator|*
name|y
operator|=
name|FT_MulFix
argument_list|(
name|cf2_floatToFixed
argument_list|(
literal|1.0
operator|+
literal|0.7
argument_list|)
argument_list|,
name|glyphpath
operator|->
name|yOffset
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* third quadrant, -x -y */
if|if
condition|(
operator|-
name|dx
operator|>
operator|-
literal|2
operator|*
name|dy
condition|)
block|{
comment|/* -x */
operator|*
name|x
operator|=
literal|0
expr_stmt|;
operator|*
name|y
operator|=
literal|2
operator|*
name|glyphpath
operator|->
name|yOffset
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|-
name|dy
operator|>
operator|-
literal|2
operator|*
name|dx
condition|)
block|{
comment|/* -y */
operator|*
name|x
operator|=
operator|-
name|glyphpath
operator|->
name|xOffset
expr_stmt|;
operator|*
name|y
operator|=
name|glyphpath
operator|->
name|yOffset
expr_stmt|;
block|}
else|else
block|{
comment|/* -x -y */
operator|*
name|x
operator|=
name|FT_MulFix
argument_list|(
name|cf2_floatToFixed
argument_list|(
operator|-
literal|0.7
argument_list|)
argument_list|,
name|glyphpath
operator|->
name|xOffset
argument_list|)
expr_stmt|;
operator|*
name|y
operator|=
name|FT_MulFix
argument_list|(
name|cf2_floatToFixed
argument_list|(
literal|1.0
operator|+
literal|0.7
argument_list|)
argument_list|,
name|glyphpath
operator|->
name|yOffset
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_comment
comment|/*    * The functions cf2_glyphpath_{moveTo,lineTo,curveTo,closeOpenPath} are    * called by the interpreter with Character Space (CS) coordinates.  Each    * path element is placed into a queue of length one to await the    * calculation of the following element.  At that time, the darkening    * offset of the following element is known and joins can be computed,    * including possible modification of this element, before mapping to    * Device Space (DS) and passing it on to the outline consumer.    *    */
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|cf2_glyphpath_moveTo
name|cf2_glyphpath_moveTo
argument_list|(
argument|CF2_GlyphPath  glyphpath
argument_list|,
argument|CF2_Fixed      x
argument_list|,
argument|CF2_Fixed      y
argument_list|)
end_macro
begin_block
block|{
name|cf2_glyphpath_closeOpenPath
argument_list|(
name|glyphpath
argument_list|)
expr_stmt|;
comment|/* save the parameters of the move for later, when we'll know how to */
comment|/* offset it;                                                        */
comment|/* also save last move point */
name|glyphpath
operator|->
name|currentCS
operator|.
name|x
operator|=
name|glyphpath
operator|->
name|start
operator|.
name|x
operator|=
name|x
expr_stmt|;
name|glyphpath
operator|->
name|currentCS
operator|.
name|y
operator|=
name|glyphpath
operator|->
name|start
operator|.
name|y
operator|=
name|y
expr_stmt|;
name|glyphpath
operator|->
name|moveIsPending
operator|=
name|TRUE
expr_stmt|;
comment|/* ensure we have a valid map with current mask */
if|if
condition|(
operator|!
name|cf2_hintmap_isValid
argument_list|(
operator|&
name|glyphpath
operator|->
name|hintMap
argument_list|)
operator|||
name|cf2_hintmask_isNew
argument_list|(
name|glyphpath
operator|->
name|hintMask
argument_list|)
condition|)
name|cf2_hintmap_build
argument_list|(
operator|&
name|glyphpath
operator|->
name|hintMap
argument_list|,
name|glyphpath
operator|->
name|hStemHintArray
argument_list|,
name|glyphpath
operator|->
name|vStemHintArray
argument_list|,
name|glyphpath
operator|->
name|hintMask
argument_list|,
name|glyphpath
operator|->
name|hintOriginY
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* save a copy of current HintMap to use when drawing initial point */
name|glyphpath
operator|->
name|firstHintMap
operator|=
name|glyphpath
operator|->
name|hintMap
expr_stmt|;
comment|/* structure copy */
block|}
end_block
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|cf2_glyphpath_lineTo
name|cf2_glyphpath_lineTo
argument_list|(
argument|CF2_GlyphPath  glyphpath
argument_list|,
argument|CF2_Fixed      x
argument_list|,
argument|CF2_Fixed      y
argument_list|)
end_macro
begin_block
block|{
name|CF2_Fixed
name|xOffset
decl_stmt|,
name|yOffset
decl_stmt|;
name|FT_Vector
name|P0
decl_stmt|,
name|P1
decl_stmt|;
name|FT_Bool
name|newHintMap
decl_stmt|;
comment|/*      * New hints will be applied after cf2_glyphpath_pushPrevElem has run.      * In case this is a synthesized closing line, any new hints should be      * delayed until this path is closed (`cf2_hintmask_isNew' will be      * called again before the next line or curve).      */
comment|/* true if new hint map not on close */
name|newHintMap
operator|=
name|cf2_hintmask_isNew
argument_list|(
name|glyphpath
operator|->
name|hintMask
argument_list|)
operator|&&
operator|!
name|glyphpath
operator|->
name|pathIsClosing
expr_stmt|;
comment|/*      * Zero-length lines may occur in the charstring.  Because we cannot      * compute darkening offsets or intersections from zero-length lines,      * it is best to remove them and avoid artifacts.  However, zero-length      * lines in CS at the start of a new hint map can generate non-zero      * lines in DS due to hint substitution.  We detect a change in hint      * map here and pass those zero-length lines along.      */
comment|/*      * Note: Find explicitly closed paths here with a conditional      *       breakpoint using      *      *         !gp->pathIsClosing&& gp->start.x == x&& gp->start.y == y      *      */
if|if
condition|(
name|glyphpath
operator|->
name|currentCS
operator|.
name|x
operator|==
name|x
operator|&&
name|glyphpath
operator|->
name|currentCS
operator|.
name|y
operator|==
name|y
operator|&&
operator|!
name|newHintMap
condition|)
comment|/*        * Ignore zero-length lines in CS where the hint map is the same        * because the line in DS will also be zero length.        *        * Ignore zero-length lines when we synthesize a closing line because        * the close will be handled in cf2_glyphPath_pushPrevElem.        */
return|return;
name|cf2_glyphpath_computeOffset
argument_list|(
name|glyphpath
argument_list|,
name|glyphpath
operator|->
name|currentCS
operator|.
name|x
argument_list|,
name|glyphpath
operator|->
name|currentCS
operator|.
name|y
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
operator|&
name|xOffset
argument_list|,
operator|&
name|yOffset
argument_list|)
expr_stmt|;
comment|/* construct offset points */
name|P0
operator|.
name|x
operator|=
name|glyphpath
operator|->
name|currentCS
operator|.
name|x
operator|+
name|xOffset
expr_stmt|;
name|P0
operator|.
name|y
operator|=
name|glyphpath
operator|->
name|currentCS
operator|.
name|y
operator|+
name|yOffset
expr_stmt|;
name|P1
operator|.
name|x
operator|=
name|x
operator|+
name|xOffset
expr_stmt|;
name|P1
operator|.
name|y
operator|=
name|y
operator|+
name|yOffset
expr_stmt|;
if|if
condition|(
name|glyphpath
operator|->
name|moveIsPending
condition|)
block|{
comment|/* emit offset 1st point as MoveTo */
name|cf2_glyphpath_pushMove
argument_list|(
name|glyphpath
argument_list|,
name|P0
argument_list|)
expr_stmt|;
name|glyphpath
operator|->
name|moveIsPending
operator|=
name|FALSE
expr_stmt|;
comment|/* adjust state machine */
name|glyphpath
operator|->
name|pathIsOpen
operator|=
name|TRUE
expr_stmt|;
name|glyphpath
operator|->
name|offsetStart1
operator|=
name|P1
expr_stmt|;
comment|/* record second point */
block|}
if|if
condition|(
name|glyphpath
operator|->
name|elemIsQueued
condition|)
block|{
name|FT_ASSERT
argument_list|(
name|cf2_hintmap_isValid
argument_list|(
operator|&
name|glyphpath
operator|->
name|hintMap
argument_list|)
operator|||
name|glyphpath
operator|->
name|hintMap
operator|.
name|count
operator|==
literal|0
argument_list|)
expr_stmt|;
name|cf2_glyphpath_pushPrevElem
argument_list|(
name|glyphpath
argument_list|,
operator|&
name|glyphpath
operator|->
name|hintMap
argument_list|,
operator|&
name|P0
argument_list|,
name|P1
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* queue the current element with offset points */
name|glyphpath
operator|->
name|elemIsQueued
operator|=
name|TRUE
expr_stmt|;
name|glyphpath
operator|->
name|prevElemOp
operator|=
name|CF2_PathOpLineTo
expr_stmt|;
name|glyphpath
operator|->
name|prevElemP0
operator|=
name|P0
expr_stmt|;
name|glyphpath
operator|->
name|prevElemP1
operator|=
name|P1
expr_stmt|;
comment|/* update current map */
if|if
condition|(
name|newHintMap
condition|)
name|cf2_hintmap_build
argument_list|(
operator|&
name|glyphpath
operator|->
name|hintMap
argument_list|,
name|glyphpath
operator|->
name|hStemHintArray
argument_list|,
name|glyphpath
operator|->
name|vStemHintArray
argument_list|,
name|glyphpath
operator|->
name|hintMask
argument_list|,
name|glyphpath
operator|->
name|hintOriginY
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|glyphpath
operator|->
name|currentCS
operator|.
name|x
operator|=
name|x
expr_stmt|;
comment|/* pre-offset current point */
name|glyphpath
operator|->
name|currentCS
operator|.
name|y
operator|=
name|y
expr_stmt|;
block|}
end_block
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|cf2_glyphpath_curveTo
name|cf2_glyphpath_curveTo
argument_list|(
argument|CF2_GlyphPath  glyphpath
argument_list|,
argument|CF2_Fixed      x1
argument_list|,
argument|CF2_Fixed      y1
argument_list|,
argument|CF2_Fixed      x2
argument_list|,
argument|CF2_Fixed      y2
argument_list|,
argument|CF2_Fixed      x3
argument_list|,
argument|CF2_Fixed      y3
argument_list|)
end_macro
begin_block
block|{
name|CF2_Fixed
name|xOffset1
decl_stmt|,
name|yOffset1
decl_stmt|,
name|xOffset3
decl_stmt|,
name|yOffset3
decl_stmt|;
name|FT_Vector
name|P0
decl_stmt|,
name|P1
decl_stmt|,
name|P2
decl_stmt|,
name|P3
decl_stmt|;
comment|/* TODO: ignore zero length portions of curve?? */
name|cf2_glyphpath_computeOffset
argument_list|(
name|glyphpath
argument_list|,
name|glyphpath
operator|->
name|currentCS
operator|.
name|x
argument_list|,
name|glyphpath
operator|->
name|currentCS
operator|.
name|y
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
operator|&
name|xOffset1
argument_list|,
operator|&
name|yOffset1
argument_list|)
expr_stmt|;
name|cf2_glyphpath_computeOffset
argument_list|(
name|glyphpath
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|,
name|x3
argument_list|,
name|y3
argument_list|,
operator|&
name|xOffset3
argument_list|,
operator|&
name|yOffset3
argument_list|)
expr_stmt|;
comment|/* add momentum from the middle segment */
name|glyphpath
operator|->
name|callbacks
operator|->
name|windingMomentum
operator|+=
name|cf2_getWindingMomentum
argument_list|(
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|)
expr_stmt|;
comment|/* construct offset points */
name|P0
operator|.
name|x
operator|=
name|glyphpath
operator|->
name|currentCS
operator|.
name|x
operator|+
name|xOffset1
expr_stmt|;
name|P0
operator|.
name|y
operator|=
name|glyphpath
operator|->
name|currentCS
operator|.
name|y
operator|+
name|yOffset1
expr_stmt|;
name|P1
operator|.
name|x
operator|=
name|x1
operator|+
name|xOffset1
expr_stmt|;
name|P1
operator|.
name|y
operator|=
name|y1
operator|+
name|yOffset1
expr_stmt|;
comment|/* note: preserve angle of final segment by using offset3 at both ends */
name|P2
operator|.
name|x
operator|=
name|x2
operator|+
name|xOffset3
expr_stmt|;
name|P2
operator|.
name|y
operator|=
name|y2
operator|+
name|yOffset3
expr_stmt|;
name|P3
operator|.
name|x
operator|=
name|x3
operator|+
name|xOffset3
expr_stmt|;
name|P3
operator|.
name|y
operator|=
name|y3
operator|+
name|yOffset3
expr_stmt|;
if|if
condition|(
name|glyphpath
operator|->
name|moveIsPending
condition|)
block|{
comment|/* emit offset 1st point as MoveTo */
name|cf2_glyphpath_pushMove
argument_list|(
name|glyphpath
argument_list|,
name|P0
argument_list|)
expr_stmt|;
name|glyphpath
operator|->
name|moveIsPending
operator|=
name|FALSE
expr_stmt|;
name|glyphpath
operator|->
name|pathIsOpen
operator|=
name|TRUE
expr_stmt|;
name|glyphpath
operator|->
name|offsetStart1
operator|=
name|P1
expr_stmt|;
comment|/* record second point */
block|}
if|if
condition|(
name|glyphpath
operator|->
name|elemIsQueued
condition|)
block|{
name|FT_ASSERT
argument_list|(
name|cf2_hintmap_isValid
argument_list|(
operator|&
name|glyphpath
operator|->
name|hintMap
argument_list|)
operator|||
name|glyphpath
operator|->
name|hintMap
operator|.
name|count
operator|==
literal|0
argument_list|)
expr_stmt|;
name|cf2_glyphpath_pushPrevElem
argument_list|(
name|glyphpath
argument_list|,
operator|&
name|glyphpath
operator|->
name|hintMap
argument_list|,
operator|&
name|P0
argument_list|,
name|P1
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* queue the current element with offset points */
name|glyphpath
operator|->
name|elemIsQueued
operator|=
name|TRUE
expr_stmt|;
name|glyphpath
operator|->
name|prevElemOp
operator|=
name|CF2_PathOpCubeTo
expr_stmt|;
name|glyphpath
operator|->
name|prevElemP0
operator|=
name|P0
expr_stmt|;
name|glyphpath
operator|->
name|prevElemP1
operator|=
name|P1
expr_stmt|;
name|glyphpath
operator|->
name|prevElemP2
operator|=
name|P2
expr_stmt|;
name|glyphpath
operator|->
name|prevElemP3
operator|=
name|P3
expr_stmt|;
comment|/* update current map */
if|if
condition|(
name|cf2_hintmask_isNew
argument_list|(
name|glyphpath
operator|->
name|hintMask
argument_list|)
condition|)
name|cf2_hintmap_build
argument_list|(
operator|&
name|glyphpath
operator|->
name|hintMap
argument_list|,
name|glyphpath
operator|->
name|hStemHintArray
argument_list|,
name|glyphpath
operator|->
name|vStemHintArray
argument_list|,
name|glyphpath
operator|->
name|hintMask
argument_list|,
name|glyphpath
operator|->
name|hintOriginY
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|glyphpath
operator|->
name|currentCS
operator|.
name|x
operator|=
name|x3
expr_stmt|;
comment|/* pre-offset current point */
name|glyphpath
operator|->
name|currentCS
operator|.
name|y
operator|=
name|y3
expr_stmt|;
block|}
end_block
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|cf2_glyphpath_closeOpenPath
name|cf2_glyphpath_closeOpenPath
argument_list|(
argument|CF2_GlyphPath  glyphpath
argument_list|)
end_macro
begin_block
block|{
if|if
condition|(
name|glyphpath
operator|->
name|pathIsOpen
condition|)
block|{
comment|/*        * A closing line in Character Space line is always generated below        * with `cf2_glyphPath_lineTo'.  It may be ignored later if it turns        * out to be zero length in Device Space.        */
name|glyphpath
operator|->
name|pathIsClosing
operator|=
name|TRUE
expr_stmt|;
name|cf2_glyphpath_lineTo
argument_list|(
name|glyphpath
argument_list|,
name|glyphpath
operator|->
name|start
operator|.
name|x
argument_list|,
name|glyphpath
operator|->
name|start
operator|.
name|y
argument_list|)
expr_stmt|;
comment|/* empty the final element from the queue and close the path */
if|if
condition|(
name|glyphpath
operator|->
name|elemIsQueued
condition|)
name|cf2_glyphpath_pushPrevElem
argument_list|(
name|glyphpath
argument_list|,
operator|&
name|glyphpath
operator|->
name|hintMap
argument_list|,
operator|&
name|glyphpath
operator|->
name|offsetStart0
argument_list|,
name|glyphpath
operator|->
name|offsetStart1
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* reset state machine */
name|glyphpath
operator|->
name|moveIsPending
operator|=
name|TRUE
expr_stmt|;
name|glyphpath
operator|->
name|pathIsOpen
operator|=
name|FALSE
expr_stmt|;
name|glyphpath
operator|->
name|pathIsClosing
operator|=
name|FALSE
expr_stmt|;
name|glyphpath
operator|->
name|elemIsQueued
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
end_block
begin_comment
comment|/* END */
end_comment
end_unit
