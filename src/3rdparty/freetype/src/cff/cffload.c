begin_unit
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  cffload.c                                                              */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*    OpenType and CFF data/program tables loader (body).                  */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 by */
end_comment
begin_comment
comment|/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  This file is part of the FreeType project, and may only be used,       */
end_comment
begin_comment
comment|/*  modified, and distributed under the terms of the FreeType project      */
end_comment
begin_comment
comment|/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
end_comment
begin_comment
comment|/*  this file you indicate that you have read the license and              */
end_comment
begin_comment
comment|/*  understand and accept it fully.                                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<ft2build.h>
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_DEBUG_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_OBJECTS_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_STREAM_H
end_include
begin_include
include|#
directive|include
include|FT_SERVICE_POSTSCRIPT_CMAPS_H
end_include
begin_include
include|#
directive|include
include|FT_TRUETYPE_TAGS_H
end_include
begin_include
include|#
directive|include
include|FT_TYPE1_TABLES_H
end_include
begin_include
include|#
directive|include
file|"cffload.h"
end_include
begin_include
include|#
directive|include
file|"cffparse.h"
end_include
begin_include
include|#
directive|include
file|"cfferrs.h"
end_include
begin_if
if|#
directive|if
literal|1
end_if
begin_decl_stmt
DECL|variable|cff_isoadobe_charset
specifier|static
specifier|const
name|FT_UShort
name|cff_isoadobe_charset
index|[
literal|229
index|]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|16
block|,
literal|17
block|,
literal|18
block|,
literal|19
block|,
literal|20
block|,
literal|21
block|,
literal|22
block|,
literal|23
block|,
literal|24
block|,
literal|25
block|,
literal|26
block|,
literal|27
block|,
literal|28
block|,
literal|29
block|,
literal|30
block|,
literal|31
block|,
literal|32
block|,
literal|33
block|,
literal|34
block|,
literal|35
block|,
literal|36
block|,
literal|37
block|,
literal|38
block|,
literal|39
block|,
literal|40
block|,
literal|41
block|,
literal|42
block|,
literal|43
block|,
literal|44
block|,
literal|45
block|,
literal|46
block|,
literal|47
block|,
literal|48
block|,
literal|49
block|,
literal|50
block|,
literal|51
block|,
literal|52
block|,
literal|53
block|,
literal|54
block|,
literal|55
block|,
literal|56
block|,
literal|57
block|,
literal|58
block|,
literal|59
block|,
literal|60
block|,
literal|61
block|,
literal|62
block|,
literal|63
block|,
literal|64
block|,
literal|65
block|,
literal|66
block|,
literal|67
block|,
literal|68
block|,
literal|69
block|,
literal|70
block|,
literal|71
block|,
literal|72
block|,
literal|73
block|,
literal|74
block|,
literal|75
block|,
literal|76
block|,
literal|77
block|,
literal|78
block|,
literal|79
block|,
literal|80
block|,
literal|81
block|,
literal|82
block|,
literal|83
block|,
literal|84
block|,
literal|85
block|,
literal|86
block|,
literal|87
block|,
literal|88
block|,
literal|89
block|,
literal|90
block|,
literal|91
block|,
literal|92
block|,
literal|93
block|,
literal|94
block|,
literal|95
block|,
literal|96
block|,
literal|97
block|,
literal|98
block|,
literal|99
block|,
literal|100
block|,
literal|101
block|,
literal|102
block|,
literal|103
block|,
literal|104
block|,
literal|105
block|,
literal|106
block|,
literal|107
block|,
literal|108
block|,
literal|109
block|,
literal|110
block|,
literal|111
block|,
literal|112
block|,
literal|113
block|,
literal|114
block|,
literal|115
block|,
literal|116
block|,
literal|117
block|,
literal|118
block|,
literal|119
block|,
literal|120
block|,
literal|121
block|,
literal|122
block|,
literal|123
block|,
literal|124
block|,
literal|125
block|,
literal|126
block|,
literal|127
block|,
literal|128
block|,
literal|129
block|,
literal|130
block|,
literal|131
block|,
literal|132
block|,
literal|133
block|,
literal|134
block|,
literal|135
block|,
literal|136
block|,
literal|137
block|,
literal|138
block|,
literal|139
block|,
literal|140
block|,
literal|141
block|,
literal|142
block|,
literal|143
block|,
literal|144
block|,
literal|145
block|,
literal|146
block|,
literal|147
block|,
literal|148
block|,
literal|149
block|,
literal|150
block|,
literal|151
block|,
literal|152
block|,
literal|153
block|,
literal|154
block|,
literal|155
block|,
literal|156
block|,
literal|157
block|,
literal|158
block|,
literal|159
block|,
literal|160
block|,
literal|161
block|,
literal|162
block|,
literal|163
block|,
literal|164
block|,
literal|165
block|,
literal|166
block|,
literal|167
block|,
literal|168
block|,
literal|169
block|,
literal|170
block|,
literal|171
block|,
literal|172
block|,
literal|173
block|,
literal|174
block|,
literal|175
block|,
literal|176
block|,
literal|177
block|,
literal|178
block|,
literal|179
block|,
literal|180
block|,
literal|181
block|,
literal|182
block|,
literal|183
block|,
literal|184
block|,
literal|185
block|,
literal|186
block|,
literal|187
block|,
literal|188
block|,
literal|189
block|,
literal|190
block|,
literal|191
block|,
literal|192
block|,
literal|193
block|,
literal|194
block|,
literal|195
block|,
literal|196
block|,
literal|197
block|,
literal|198
block|,
literal|199
block|,
literal|200
block|,
literal|201
block|,
literal|202
block|,
literal|203
block|,
literal|204
block|,
literal|205
block|,
literal|206
block|,
literal|207
block|,
literal|208
block|,
literal|209
block|,
literal|210
block|,
literal|211
block|,
literal|212
block|,
literal|213
block|,
literal|214
block|,
literal|215
block|,
literal|216
block|,
literal|217
block|,
literal|218
block|,
literal|219
block|,
literal|220
block|,
literal|221
block|,
literal|222
block|,
literal|223
block|,
literal|224
block|,
literal|225
block|,
literal|226
block|,
literal|227
block|,
literal|228
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|cff_expert_charset
specifier|static
specifier|const
name|FT_UShort
name|cff_expert_charset
index|[
literal|166
index|]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|229
block|,
literal|230
block|,
literal|231
block|,
literal|232
block|,
literal|233
block|,
literal|234
block|,
literal|235
block|,
literal|236
block|,
literal|237
block|,
literal|238
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|99
block|,
literal|239
block|,
literal|240
block|,
literal|241
block|,
literal|242
block|,
literal|243
block|,
literal|244
block|,
literal|245
block|,
literal|246
block|,
literal|247
block|,
literal|248
block|,
literal|27
block|,
literal|28
block|,
literal|249
block|,
literal|250
block|,
literal|251
block|,
literal|252
block|,
literal|253
block|,
literal|254
block|,
literal|255
block|,
literal|256
block|,
literal|257
block|,
literal|258
block|,
literal|259
block|,
literal|260
block|,
literal|261
block|,
literal|262
block|,
literal|263
block|,
literal|264
block|,
literal|265
block|,
literal|266
block|,
literal|109
block|,
literal|110
block|,
literal|267
block|,
literal|268
block|,
literal|269
block|,
literal|270
block|,
literal|271
block|,
literal|272
block|,
literal|273
block|,
literal|274
block|,
literal|275
block|,
literal|276
block|,
literal|277
block|,
literal|278
block|,
literal|279
block|,
literal|280
block|,
literal|281
block|,
literal|282
block|,
literal|283
block|,
literal|284
block|,
literal|285
block|,
literal|286
block|,
literal|287
block|,
literal|288
block|,
literal|289
block|,
literal|290
block|,
literal|291
block|,
literal|292
block|,
literal|293
block|,
literal|294
block|,
literal|295
block|,
literal|296
block|,
literal|297
block|,
literal|298
block|,
literal|299
block|,
literal|300
block|,
literal|301
block|,
literal|302
block|,
literal|303
block|,
literal|304
block|,
literal|305
block|,
literal|306
block|,
literal|307
block|,
literal|308
block|,
literal|309
block|,
literal|310
block|,
literal|311
block|,
literal|312
block|,
literal|313
block|,
literal|314
block|,
literal|315
block|,
literal|316
block|,
literal|317
block|,
literal|318
block|,
literal|158
block|,
literal|155
block|,
literal|163
block|,
literal|319
block|,
literal|320
block|,
literal|321
block|,
literal|322
block|,
literal|323
block|,
literal|324
block|,
literal|325
block|,
literal|326
block|,
literal|150
block|,
literal|164
block|,
literal|169
block|,
literal|327
block|,
literal|328
block|,
literal|329
block|,
literal|330
block|,
literal|331
block|,
literal|332
block|,
literal|333
block|,
literal|334
block|,
literal|335
block|,
literal|336
block|,
literal|337
block|,
literal|338
block|,
literal|339
block|,
literal|340
block|,
literal|341
block|,
literal|342
block|,
literal|343
block|,
literal|344
block|,
literal|345
block|,
literal|346
block|,
literal|347
block|,
literal|348
block|,
literal|349
block|,
literal|350
block|,
literal|351
block|,
literal|352
block|,
literal|353
block|,
literal|354
block|,
literal|355
block|,
literal|356
block|,
literal|357
block|,
literal|358
block|,
literal|359
block|,
literal|360
block|,
literal|361
block|,
literal|362
block|,
literal|363
block|,
literal|364
block|,
literal|365
block|,
literal|366
block|,
literal|367
block|,
literal|368
block|,
literal|369
block|,
literal|370
block|,
literal|371
block|,
literal|372
block|,
literal|373
block|,
literal|374
block|,
literal|375
block|,
literal|376
block|,
literal|377
block|,
literal|378
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|cff_expertsubset_charset
specifier|static
specifier|const
name|FT_UShort
name|cff_expertsubset_charset
index|[
literal|87
index|]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|231
block|,
literal|232
block|,
literal|235
block|,
literal|236
block|,
literal|237
block|,
literal|238
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|99
block|,
literal|239
block|,
literal|240
block|,
literal|241
block|,
literal|242
block|,
literal|243
block|,
literal|244
block|,
literal|245
block|,
literal|246
block|,
literal|247
block|,
literal|248
block|,
literal|27
block|,
literal|28
block|,
literal|249
block|,
literal|250
block|,
literal|251
block|,
literal|253
block|,
literal|254
block|,
literal|255
block|,
literal|256
block|,
literal|257
block|,
literal|258
block|,
literal|259
block|,
literal|260
block|,
literal|261
block|,
literal|262
block|,
literal|263
block|,
literal|264
block|,
literal|265
block|,
literal|266
block|,
literal|109
block|,
literal|110
block|,
literal|267
block|,
literal|268
block|,
literal|269
block|,
literal|270
block|,
literal|272
block|,
literal|300
block|,
literal|301
block|,
literal|302
block|,
literal|305
block|,
literal|314
block|,
literal|315
block|,
literal|158
block|,
literal|155
block|,
literal|163
block|,
literal|320
block|,
literal|321
block|,
literal|322
block|,
literal|323
block|,
literal|324
block|,
literal|325
block|,
literal|326
block|,
literal|150
block|,
literal|164
block|,
literal|169
block|,
literal|327
block|,
literal|328
block|,
literal|329
block|,
literal|330
block|,
literal|331
block|,
literal|332
block|,
literal|333
block|,
literal|334
block|,
literal|335
block|,
literal|336
block|,
literal|337
block|,
literal|338
block|,
literal|339
block|,
literal|340
block|,
literal|341
block|,
literal|342
block|,
literal|343
block|,
literal|344
block|,
literal|345
block|,
literal|346
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|cff_standard_encoding
specifier|static
specifier|const
name|FT_UShort
name|cff_standard_encoding
index|[
literal|256
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|16
block|,
literal|17
block|,
literal|18
block|,
literal|19
block|,
literal|20
block|,
literal|21
block|,
literal|22
block|,
literal|23
block|,
literal|24
block|,
literal|25
block|,
literal|26
block|,
literal|27
block|,
literal|28
block|,
literal|29
block|,
literal|30
block|,
literal|31
block|,
literal|32
block|,
literal|33
block|,
literal|34
block|,
literal|35
block|,
literal|36
block|,
literal|37
block|,
literal|38
block|,
literal|39
block|,
literal|40
block|,
literal|41
block|,
literal|42
block|,
literal|43
block|,
literal|44
block|,
literal|45
block|,
literal|46
block|,
literal|47
block|,
literal|48
block|,
literal|49
block|,
literal|50
block|,
literal|51
block|,
literal|52
block|,
literal|53
block|,
literal|54
block|,
literal|55
block|,
literal|56
block|,
literal|57
block|,
literal|58
block|,
literal|59
block|,
literal|60
block|,
literal|61
block|,
literal|62
block|,
literal|63
block|,
literal|64
block|,
literal|65
block|,
literal|66
block|,
literal|67
block|,
literal|68
block|,
literal|69
block|,
literal|70
block|,
literal|71
block|,
literal|72
block|,
literal|73
block|,
literal|74
block|,
literal|75
block|,
literal|76
block|,
literal|77
block|,
literal|78
block|,
literal|79
block|,
literal|80
block|,
literal|81
block|,
literal|82
block|,
literal|83
block|,
literal|84
block|,
literal|85
block|,
literal|86
block|,
literal|87
block|,
literal|88
block|,
literal|89
block|,
literal|90
block|,
literal|91
block|,
literal|92
block|,
literal|93
block|,
literal|94
block|,
literal|95
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|96
block|,
literal|97
block|,
literal|98
block|,
literal|99
block|,
literal|100
block|,
literal|101
block|,
literal|102
block|,
literal|103
block|,
literal|104
block|,
literal|105
block|,
literal|106
block|,
literal|107
block|,
literal|108
block|,
literal|109
block|,
literal|110
block|,
literal|0
block|,
literal|111
block|,
literal|112
block|,
literal|113
block|,
literal|114
block|,
literal|0
block|,
literal|115
block|,
literal|116
block|,
literal|117
block|,
literal|118
block|,
literal|119
block|,
literal|120
block|,
literal|121
block|,
literal|122
block|,
literal|0
block|,
literal|123
block|,
literal|0
block|,
literal|124
block|,
literal|125
block|,
literal|126
block|,
literal|127
block|,
literal|128
block|,
literal|129
block|,
literal|130
block|,
literal|131
block|,
literal|0
block|,
literal|132
block|,
literal|133
block|,
literal|0
block|,
literal|134
block|,
literal|135
block|,
literal|136
block|,
literal|137
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|138
block|,
literal|0
block|,
literal|139
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|140
block|,
literal|141
block|,
literal|142
block|,
literal|143
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|144
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|145
block|,
literal|0
block|,
literal|0
block|,
literal|146
block|,
literal|147
block|,
literal|148
block|,
literal|149
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|cff_expert_encoding
specifier|static
specifier|const
name|FT_UShort
name|cff_expert_encoding
index|[
literal|256
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|229
block|,
literal|230
block|,
literal|0
block|,
literal|231
block|,
literal|232
block|,
literal|233
block|,
literal|234
block|,
literal|235
block|,
literal|236
block|,
literal|237
block|,
literal|238
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|99
block|,
literal|239
block|,
literal|240
block|,
literal|241
block|,
literal|242
block|,
literal|243
block|,
literal|244
block|,
literal|245
block|,
literal|246
block|,
literal|247
block|,
literal|248
block|,
literal|27
block|,
literal|28
block|,
literal|249
block|,
literal|250
block|,
literal|251
block|,
literal|252
block|,
literal|0
block|,
literal|253
block|,
literal|254
block|,
literal|255
block|,
literal|256
block|,
literal|257
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|258
block|,
literal|0
block|,
literal|0
block|,
literal|259
block|,
literal|260
block|,
literal|261
block|,
literal|262
block|,
literal|0
block|,
literal|0
block|,
literal|263
block|,
literal|264
block|,
literal|265
block|,
literal|0
block|,
literal|266
block|,
literal|109
block|,
literal|110
block|,
literal|267
block|,
literal|268
block|,
literal|269
block|,
literal|0
block|,
literal|270
block|,
literal|271
block|,
literal|272
block|,
literal|273
block|,
literal|274
block|,
literal|275
block|,
literal|276
block|,
literal|277
block|,
literal|278
block|,
literal|279
block|,
literal|280
block|,
literal|281
block|,
literal|282
block|,
literal|283
block|,
literal|284
block|,
literal|285
block|,
literal|286
block|,
literal|287
block|,
literal|288
block|,
literal|289
block|,
literal|290
block|,
literal|291
block|,
literal|292
block|,
literal|293
block|,
literal|294
block|,
literal|295
block|,
literal|296
block|,
literal|297
block|,
literal|298
block|,
literal|299
block|,
literal|300
block|,
literal|301
block|,
literal|302
block|,
literal|303
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|304
block|,
literal|305
block|,
literal|306
block|,
literal|0
block|,
literal|0
block|,
literal|307
block|,
literal|308
block|,
literal|309
block|,
literal|310
block|,
literal|311
block|,
literal|0
block|,
literal|312
block|,
literal|0
block|,
literal|0
block|,
literal|312
block|,
literal|0
block|,
literal|0
block|,
literal|314
block|,
literal|315
block|,
literal|0
block|,
literal|0
block|,
literal|316
block|,
literal|317
block|,
literal|318
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|158
block|,
literal|155
block|,
literal|163
block|,
literal|319
block|,
literal|320
block|,
literal|321
block|,
literal|322
block|,
literal|323
block|,
literal|324
block|,
literal|325
block|,
literal|0
block|,
literal|0
block|,
literal|326
block|,
literal|150
block|,
literal|164
block|,
literal|169
block|,
literal|327
block|,
literal|328
block|,
literal|329
block|,
literal|330
block|,
literal|331
block|,
literal|332
block|,
literal|333
block|,
literal|334
block|,
literal|335
block|,
literal|336
block|,
literal|337
block|,
literal|338
block|,
literal|339
block|,
literal|340
block|,
literal|341
block|,
literal|342
block|,
literal|343
block|,
literal|344
block|,
literal|345
block|,
literal|346
block|,
literal|347
block|,
literal|348
block|,
literal|349
block|,
literal|350
block|,
literal|351
block|,
literal|352
block|,
literal|353
block|,
literal|354
block|,
literal|355
block|,
literal|356
block|,
literal|357
block|,
literal|358
block|,
literal|359
block|,
literal|360
block|,
literal|361
block|,
literal|362
block|,
literal|363
block|,
literal|364
block|,
literal|365
block|,
literal|366
block|,
literal|367
block|,
literal|368
block|,
literal|369
block|,
literal|370
block|,
literal|371
block|,
literal|372
block|,
literal|373
block|,
literal|374
block|,
literal|375
block|,
literal|376
block|,
literal|377
block|,
literal|378
block|}
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* 1 */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_UShort
argument_list|)
end_macro
begin_macro
name|cff_get_standard_encoding
argument_list|(
argument|FT_UInt  charcode
argument_list|)
end_macro
begin_block
block|{
return|return
call|(
name|FT_UShort
call|)
argument_list|(
name|charcode
operator|<
literal|256
condition|?
name|cff_standard_encoding
index|[
name|charcode
index|]
else|:
literal|0
argument_list|)
return|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
end_comment
begin_comment
comment|/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
end_comment
begin_comment
comment|/* messages during execution.                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_undef
DECL|macro|FT_COMPONENT
undef|#
directive|undef
name|FT_COMPONENT
end_undef
begin_define
DECL|macro|FT_COMPONENT
define|#
directive|define
name|FT_COMPONENT
value|trace_cffload
end_define
begin_comment
comment|/* read an offset from the index's stream current position */
end_comment
begin_function
specifier|static
name|FT_ULong
DECL|function|cff_index_read_offset
name|cff_index_read_offset
parameter_list|(
name|CFF_Index
name|idx
parameter_list|,
name|FT_Error
modifier|*
name|errorp
parameter_list|)
block|{
name|FT_Error
name|error
decl_stmt|;
name|FT_Stream
name|stream
init|=
name|idx
operator|->
name|stream
decl_stmt|;
name|FT_Byte
name|tmp
index|[
literal|4
index|]
decl_stmt|;
name|FT_ULong
name|result
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|FT_STREAM_READ
argument_list|(
name|tmp
argument_list|,
name|idx
operator|->
name|off_size
argument_list|)
condition|)
block|{
name|FT_Int
name|nn
decl_stmt|;
for|for
control|(
name|nn
operator|=
literal|0
init|;
name|nn
operator|<
name|idx
operator|->
name|off_size
condition|;
name|nn
operator|++
control|)
name|result
operator|=
operator|(
name|result
operator|<<
literal|8
operator|)
operator||
name|tmp
index|[
name|nn
index|]
expr_stmt|;
block|}
operator|*
name|errorp
operator|=
name|error
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|cff_index_init
name|cff_index_init
parameter_list|(
name|CFF_Index
name|idx
parameter_list|,
name|FT_Stream
name|stream
parameter_list|,
name|FT_Bool
name|load
parameter_list|)
block|{
name|FT_Error
name|error
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|stream
operator|->
name|memory
decl_stmt|;
name|FT_UShort
name|count
decl_stmt|;
name|FT_MEM_ZERO
argument_list|(
name|idx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|idx
argument_list|)
argument_list|)
expr_stmt|;
name|idx
operator|->
name|stream
operator|=
name|stream
expr_stmt|;
name|idx
operator|->
name|start
operator|=
name|FT_STREAM_POS
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|FT_READ_USHORT
argument_list|(
name|count
argument_list|)
operator|&&
name|count
operator|>
literal|0
condition|)
block|{
name|FT_Byte
name|offsize
decl_stmt|;
name|FT_ULong
name|size
decl_stmt|;
comment|/* there is at least one element; read the offset size,           */
comment|/* then access the offset table to compute the index's total size */
if|if
condition|(
name|FT_READ_BYTE
argument_list|(
name|offsize
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
if|if
condition|(
name|offsize
operator|<
literal|1
operator|||
name|offsize
operator|>
literal|4
condition|)
block|{
name|error
operator|=
name|FT_Err_Invalid_Table
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|idx
operator|->
name|count
operator|=
name|count
expr_stmt|;
name|idx
operator|->
name|off_size
operator|=
name|offsize
expr_stmt|;
name|size
operator|=
call|(
name|FT_ULong
call|)
argument_list|(
name|count
operator|+
literal|1
argument_list|)
operator|*
name|offsize
expr_stmt|;
name|idx
operator|->
name|data_offset
operator|=
name|idx
operator|->
name|start
operator|+
literal|3
operator|+
name|size
expr_stmt|;
if|if
condition|(
name|FT_STREAM_SKIP
argument_list|(
name|size
operator|-
name|offsize
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|size
operator|=
name|cff_index_read_offset
argument_list|(
name|idx
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|CFF_Err_Invalid_Table
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|idx
operator|->
name|data_size
operator|=
operator|--
name|size
expr_stmt|;
if|if
condition|(
name|load
condition|)
block|{
comment|/* load the data */
if|if
condition|(
name|FT_FRAME_EXTRACT
argument_list|(
name|size
argument_list|,
name|idx
operator|->
name|bytes
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
block|}
else|else
block|{
comment|/* skip the data */
if|if
condition|(
name|FT_STREAM_SKIP
argument_list|(
name|size
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
block|}
block|}
name|Exit
label|:
if|if
condition|(
name|error
condition|)
name|FT_FREE
argument_list|(
name|idx
operator|->
name|offsets
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|cff_index_done
name|cff_index_done
parameter_list|(
name|CFF_Index
name|idx
parameter_list|)
block|{
if|if
condition|(
name|idx
operator|->
name|stream
condition|)
block|{
name|FT_Stream
name|stream
init|=
name|idx
operator|->
name|stream
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|stream
operator|->
name|memory
decl_stmt|;
if|if
condition|(
name|idx
operator|->
name|bytes
condition|)
name|FT_FRAME_RELEASE
argument_list|(
name|idx
operator|->
name|bytes
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|idx
operator|->
name|offsets
argument_list|)
expr_stmt|;
name|FT_MEM_ZERO
argument_list|(
name|idx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|idx
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|cff_index_load_offsets
name|cff_index_load_offsets
parameter_list|(
name|CFF_Index
name|idx
parameter_list|)
block|{
name|FT_Error
name|error
init|=
name|CFF_Err_Ok
decl_stmt|;
name|FT_Stream
name|stream
init|=
name|idx
operator|->
name|stream
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|stream
operator|->
name|memory
decl_stmt|;
if|if
condition|(
name|idx
operator|->
name|count
operator|>
literal|0
operator|&&
name|idx
operator|->
name|offsets
operator|==
name|NULL
condition|)
block|{
name|FT_Byte
name|offsize
init|=
name|idx
operator|->
name|off_size
decl_stmt|;
name|FT_ULong
name|data_size
decl_stmt|;
name|FT_Byte
modifier|*
name|p
decl_stmt|;
name|FT_Byte
modifier|*
name|p_end
decl_stmt|;
name|FT_ULong
modifier|*
name|poff
decl_stmt|;
name|data_size
operator|=
call|(
name|FT_ULong
call|)
argument_list|(
name|idx
operator|->
name|count
operator|+
literal|1
argument_list|)
operator|*
name|offsize
expr_stmt|;
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|idx
operator|->
name|offsets
argument_list|,
name|idx
operator|->
name|count
operator|+
literal|1
argument_list|)
operator|||
name|FT_STREAM_SEEK
argument_list|(
name|idx
operator|->
name|start
operator|+
literal|3
argument_list|)
operator|||
name|FT_FRAME_ENTER
argument_list|(
name|data_size
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|poff
operator|=
name|idx
operator|->
name|offsets
expr_stmt|;
name|p
operator|=
operator|(
name|FT_Byte
operator|*
operator|)
name|stream
operator|->
name|cursor
expr_stmt|;
name|p_end
operator|=
name|p
operator|+
name|data_size
expr_stmt|;
switch|switch
condition|(
name|offsize
condition|)
block|{
case|case
literal|1
case|:
for|for
control|(
init|;
name|p
operator|<
name|p_end
condition|;
name|p
operator|++
operator|,
name|poff
operator|++
control|)
name|poff
index|[
literal|0
index|]
operator|=
name|p
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
literal|2
case|:
for|for
control|(
init|;
name|p
operator|<
name|p_end
condition|;
name|p
operator|+=
literal|2
operator|,
name|poff
operator|++
control|)
name|poff
index|[
literal|0
index|]
operator|=
name|FT_PEEK_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
for|for
control|(
init|;
name|p
operator|<
name|p_end
condition|;
name|p
operator|+=
literal|3
operator|,
name|poff
operator|++
control|)
name|poff
index|[
literal|0
index|]
operator|=
name|FT_PEEK_OFF3
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
default|default:
for|for
control|(
init|;
name|p
operator|<
name|p_end
condition|;
name|p
operator|+=
literal|4
operator|,
name|poff
operator|++
control|)
name|poff
index|[
literal|0
index|]
operator|=
name|FT_PEEK_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|FT_FRAME_EXIT
argument_list|()
expr_stmt|;
block|}
name|Exit
label|:
if|if
condition|(
name|error
condition|)
name|FT_FREE
argument_list|(
name|idx
operator|->
name|offsets
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_comment
comment|/* allocate a table containing pointers to an index's elements */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|cff_index_get_pointers
name|cff_index_get_pointers
parameter_list|(
name|CFF_Index
name|idx
parameter_list|,
name|FT_Byte
modifier|*
modifier|*
modifier|*
name|table
parameter_list|)
block|{
name|FT_Error
name|error
init|=
name|CFF_Err_Ok
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|idx
operator|->
name|stream
operator|->
name|memory
decl_stmt|;
name|FT_ULong
name|n
decl_stmt|,
name|offset
decl_stmt|,
name|old_offset
decl_stmt|;
name|FT_Byte
modifier|*
modifier|*
name|t
decl_stmt|;
operator|*
name|table
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|idx
operator|->
name|offsets
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|cff_index_load_offsets
argument_list|(
name|idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|idx
operator|->
name|count
operator|>
literal|0
operator|&&
operator|!
name|FT_NEW_ARRAY
argument_list|(
name|t
argument_list|,
name|idx
operator|->
name|count
operator|+
literal|1
argument_list|)
condition|)
block|{
name|old_offset
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<=
name|idx
operator|->
name|count
condition|;
name|n
operator|++
control|)
block|{
comment|/* at this point, `idx->offsets' can't be NULL */
name|offset
operator|=
name|idx
operator|->
name|offsets
index|[
name|n
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|offset
condition|)
name|offset
operator|=
name|old_offset
expr_stmt|;
comment|/* two sanity checks for invalid offset tables */
elseif|else
if|if
condition|(
name|offset
operator|<
name|old_offset
condition|)
name|offset
operator|=
name|old_offset
expr_stmt|;
elseif|else
if|if
condition|(
name|offset
operator|-
literal|1
operator|>=
name|idx
operator|->
name|data_size
operator|&&
name|n
operator|<
name|idx
operator|->
name|count
condition|)
name|offset
operator|=
name|old_offset
expr_stmt|;
name|t
index|[
name|n
index|]
operator|=
name|idx
operator|->
name|bytes
operator|+
name|offset
operator|-
literal|1
expr_stmt|;
name|old_offset
operator|=
name|offset
expr_stmt|;
block|}
operator|*
name|table
operator|=
name|t
expr_stmt|;
block|}
name|Exit
label|:
return|return
name|error
return|;
block|}
end_function
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|cff_index_access_element
argument_list|(
argument|CFF_Index  idx
argument_list|,
argument|FT_UInt    element
argument_list|,
argument|FT_Byte**  pbytes
argument_list|,
argument|FT_ULong*  pbyte_len
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
init|=
name|CFF_Err_Ok
decl_stmt|;
if|if
condition|(
name|idx
operator|&&
name|idx
operator|->
name|count
operator|>
name|element
condition|)
block|{
comment|/* compute start and end offsets */
name|FT_Stream
name|stream
init|=
name|idx
operator|->
name|stream
decl_stmt|;
name|FT_ULong
name|off1
decl_stmt|,
name|off2
init|=
literal|0
decl_stmt|;
comment|/* load offsets from file or the offset table */
if|if
condition|(
operator|!
name|idx
operator|->
name|offsets
condition|)
block|{
name|FT_ULong
name|pos
init|=
name|element
operator|*
name|idx
operator|->
name|off_size
decl_stmt|;
if|if
condition|(
name|FT_STREAM_SEEK
argument_list|(
name|idx
operator|->
name|start
operator|+
literal|3
operator|+
name|pos
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|off1
operator|=
name|cff_index_read_offset
argument_list|(
name|idx
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
if|if
condition|(
name|off1
operator|!=
literal|0
condition|)
block|{
do|do
block|{
name|element
operator|++
expr_stmt|;
name|off2
operator|=
name|cff_index_read_offset
argument_list|(
name|idx
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|off2
operator|==
literal|0
operator|&&
name|element
operator|<
name|idx
operator|->
name|count
condition|)
do|;
block|}
block|}
else|else
comment|/* use offsets table */
block|{
name|off1
operator|=
name|idx
operator|->
name|offsets
index|[
name|element
index|]
expr_stmt|;
if|if
condition|(
name|off1
condition|)
block|{
do|do
block|{
name|element
operator|++
expr_stmt|;
name|off2
operator|=
name|idx
operator|->
name|offsets
index|[
name|element
index|]
expr_stmt|;
block|}
do|while
condition|(
name|off2
operator|==
literal|0
operator|&&
name|element
operator|<
name|idx
operator|->
name|count
condition|)
do|;
block|}
block|}
comment|/* access element */
if|if
condition|(
name|off1
operator|&&
name|off2
operator|>
name|off1
condition|)
block|{
operator|*
name|pbyte_len
operator|=
name|off2
operator|-
name|off1
expr_stmt|;
if|if
condition|(
name|idx
operator|->
name|bytes
condition|)
block|{
comment|/* this index was completely loaded in memory, that's easy */
operator|*
name|pbytes
operator|=
name|idx
operator|->
name|bytes
operator|+
name|off1
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* this index is still on disk/file, access it through a frame */
if|if
condition|(
name|FT_STREAM_SEEK
argument_list|(
name|idx
operator|->
name|data_offset
operator|+
name|off1
operator|-
literal|1
argument_list|)
operator|||
name|FT_FRAME_EXTRACT
argument_list|(
name|off2
operator|-
name|off1
argument_list|,
operator|*
name|pbytes
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
block|}
block|}
else|else
block|{
comment|/* empty index element */
operator|*
name|pbytes
operator|=
literal|0
expr_stmt|;
operator|*
name|pbyte_len
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
name|error
operator|=
name|CFF_Err_Invalid_Argument
expr_stmt|;
name|Exit
label|:
return|return
name|error
return|;
block|}
end_block
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|cff_index_forget_element
name|cff_index_forget_element
argument_list|(
argument|CFF_Index  idx
argument_list|,
argument|FT_Byte**  pbytes
argument_list|)
end_macro
begin_block
block|{
if|if
condition|(
name|idx
operator|->
name|bytes
operator|==
literal|0
condition|)
block|{
name|FT_Stream
name|stream
init|=
name|idx
operator|->
name|stream
decl_stmt|;
name|FT_FRAME_RELEASE
argument_list|(
operator|*
name|pbytes
argument_list|)
expr_stmt|;
block|}
block|}
end_block
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|FT_String*
argument_list|)
end_macro
begin_macro
DECL|function|cff_index_get_name
name|cff_index_get_name
argument_list|(
argument|CFF_Index  idx
argument_list|,
argument|FT_UInt    element
argument_list|)
end_macro
begin_block
block|{
name|FT_Memory
name|memory
init|=
name|idx
operator|->
name|stream
operator|->
name|memory
decl_stmt|;
name|FT_Byte
modifier|*
name|bytes
decl_stmt|;
name|FT_ULong
name|byte_len
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|FT_String
modifier|*
name|name
init|=
literal|0
decl_stmt|;
name|error
operator|=
name|cff_index_access_element
argument_list|(
name|idx
argument_list|,
name|element
argument_list|,
operator|&
name|bytes
argument_list|,
operator|&
name|byte_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
if|if
condition|(
operator|!
name|FT_ALLOC
argument_list|(
name|name
argument_list|,
name|byte_len
operator|+
literal|1
argument_list|)
condition|)
block|{
name|FT_MEM_COPY
argument_list|(
name|name
argument_list|,
name|bytes
argument_list|,
name|byte_len
argument_list|)
expr_stmt|;
name|name
index|[
name|byte_len
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|cff_index_forget_element
argument_list|(
name|idx
argument_list|,
operator|&
name|bytes
argument_list|)
expr_stmt|;
name|Exit
label|:
return|return
name|name
return|;
block|}
end_block
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|FT_String*
argument_list|)
end_macro
begin_macro
DECL|function|cff_index_get_sid_string
name|cff_index_get_sid_string
argument_list|(
argument|CFF_Index           idx
argument_list|,
argument|FT_UInt             sid
argument_list|,
argument|FT_Service_PsCMaps  psnames
argument_list|)
end_macro
begin_block
block|{
comment|/* value 0xFFFFU indicates a missing dictionary entry */
if|if
condition|(
name|sid
operator|==
literal|0xFFFFU
condition|)
return|return
literal|0
return|;
comment|/* if it is not a standard string, return it */
if|if
condition|(
name|sid
operator|>
literal|390
condition|)
return|return
name|cff_index_get_name
argument_list|(
name|idx
argument_list|,
name|sid
operator|-
literal|391
argument_list|)
return|;
comment|/* CID-keyed CFF fonts don't have glyph names */
if|if
condition|(
operator|!
name|psnames
condition|)
return|return
literal|0
return|;
comment|/* that's a standard string, fetch a copy from the PSName module */
block|{
name|FT_String
modifier|*
name|name
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|adobe_name
init|=
name|psnames
operator|->
name|adobe_std_strings
argument_list|(
name|sid
argument_list|)
decl_stmt|;
if|if
condition|(
name|adobe_name
condition|)
block|{
name|FT_Memory
name|memory
init|=
name|idx
operator|->
name|stream
operator|->
name|memory
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
operator|(
name|void
operator|)
name|FT_STRDUP
argument_list|(
name|name
argument_list|,
name|adobe_name
argument_list|)
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
return|return
name|name
return|;
block|}
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/***                                                                   ***/
end_comment
begin_comment
comment|/***   FD Select table support                                         ***/
end_comment
begin_comment
comment|/***                                                                   ***/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_function
specifier|static
name|void
DECL|function|CFF_Done_FD_Select
name|CFF_Done_FD_Select
parameter_list|(
name|CFF_FDSelect
name|fdselect
parameter_list|,
name|FT_Stream
name|stream
parameter_list|)
block|{
if|if
condition|(
name|fdselect
operator|->
name|data
condition|)
name|FT_FRAME_RELEASE
argument_list|(
name|fdselect
operator|->
name|data
argument_list|)
expr_stmt|;
name|fdselect
operator|->
name|data_size
operator|=
literal|0
expr_stmt|;
name|fdselect
operator|->
name|format
operator|=
literal|0
expr_stmt|;
name|fdselect
operator|->
name|range_count
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|CFF_Load_FD_Select
name|CFF_Load_FD_Select
parameter_list|(
name|CFF_FDSelect
name|fdselect
parameter_list|,
name|FT_UInt
name|num_glyphs
parameter_list|,
name|FT_Stream
name|stream
parameter_list|,
name|FT_ULong
name|offset
parameter_list|)
block|{
name|FT_Error
name|error
decl_stmt|;
name|FT_Byte
name|format
decl_stmt|;
name|FT_UInt
name|num_ranges
decl_stmt|;
comment|/* read format */
if|if
condition|(
name|FT_STREAM_SEEK
argument_list|(
name|offset
argument_list|)
operator|||
name|FT_READ_BYTE
argument_list|(
name|format
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|fdselect
operator|->
name|format
operator|=
name|format
expr_stmt|;
name|fdselect
operator|->
name|cache_count
operator|=
literal|0
expr_stmt|;
comment|/* clear cache */
switch|switch
condition|(
name|format
condition|)
block|{
case|case
literal|0
case|:
comment|/* format 0, that's simple */
name|fdselect
operator|->
name|data_size
operator|=
name|num_glyphs
expr_stmt|;
goto|goto
name|Load_Data
goto|;
case|case
literal|3
case|:
comment|/* format 3, a tad more complex */
if|if
condition|(
name|FT_READ_USHORT
argument_list|(
name|num_ranges
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|fdselect
operator|->
name|data_size
operator|=
name|num_ranges
operator|*
literal|3
operator|+
literal|2
expr_stmt|;
name|Load_Data
label|:
if|if
condition|(
name|FT_FRAME_EXTRACT
argument_list|(
name|fdselect
operator|->
name|data_size
argument_list|,
name|fdselect
operator|->
name|data
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
break|break;
default|default:
comment|/* hmm... that's wrong */
name|error
operator|=
name|CFF_Err_Invalid_File_Format
expr_stmt|;
block|}
name|Exit
label|:
return|return
name|error
return|;
block|}
end_function
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Byte
argument_list|)
end_macro
begin_macro
name|cff_fd_select_get
argument_list|(
argument|CFF_FDSelect  fdselect
argument_list|,
argument|FT_UInt       glyph_index
argument_list|)
end_macro
begin_block
block|{
name|FT_Byte
name|fd
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|fdselect
operator|->
name|format
condition|)
block|{
case|case
literal|0
case|:
name|fd
operator|=
name|fdselect
operator|->
name|data
index|[
name|glyph_index
index|]
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* first, compare to cache */
if|if
condition|(
call|(
name|FT_UInt
call|)
argument_list|(
name|glyph_index
operator|-
name|fdselect
operator|->
name|cache_first
argument_list|)
operator|<
name|fdselect
operator|->
name|cache_count
condition|)
block|{
name|fd
operator|=
name|fdselect
operator|->
name|cache_fd
expr_stmt|;
break|break;
block|}
comment|/* then, lookup the ranges array */
block|{
name|FT_Byte
modifier|*
name|p
init|=
name|fdselect
operator|->
name|data
decl_stmt|;
name|FT_Byte
modifier|*
name|p_limit
init|=
name|p
operator|+
name|fdselect
operator|->
name|data_size
decl_stmt|;
name|FT_Byte
name|fd2
decl_stmt|;
name|FT_UInt
name|first
decl_stmt|,
name|limit
decl_stmt|;
name|first
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|glyph_index
operator|<
name|first
condition|)
break|break;
name|fd2
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|limit
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|glyph_index
operator|<
name|limit
condition|)
block|{
name|fd
operator|=
name|fd2
expr_stmt|;
comment|/* update cache */
name|fdselect
operator|->
name|cache_first
operator|=
name|first
expr_stmt|;
name|fdselect
operator|->
name|cache_count
operator|=
name|limit
operator|-
name|first
expr_stmt|;
name|fdselect
operator|->
name|cache_fd
operator|=
name|fd2
expr_stmt|;
break|break;
block|}
name|first
operator|=
name|limit
expr_stmt|;
block|}
do|while
condition|(
name|p
operator|<
name|p_limit
condition|)
do|;
block|}
break|break;
default|default:
empty_stmt|;
block|}
return|return
name|fd
return|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/***                                                                   ***/
end_comment
begin_comment
comment|/***   CFF font support                                                ***/
end_comment
begin_comment
comment|/***                                                                   ***/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|cff_charset_compute_cids
name|cff_charset_compute_cids
parameter_list|(
name|CFF_Charset
name|charset
parameter_list|,
name|FT_UInt
name|num_glyphs
parameter_list|,
name|FT_Memory
name|memory
parameter_list|)
block|{
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
name|FT_UInt
name|i
decl_stmt|;
name|FT_Long
name|j
decl_stmt|;
name|FT_UShort
name|max_cid
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|charset
operator|->
name|max_cid
operator|>
literal|0
condition|)
goto|goto
name|Exit
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_glyphs
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|charset
operator|->
name|sids
index|[
name|i
index|]
operator|>
name|max_cid
condition|)
name|max_cid
operator|=
name|charset
operator|->
name|sids
index|[
name|i
index|]
expr_stmt|;
name|max_cid
operator|++
expr_stmt|;
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|charset
operator|->
name|cids
argument_list|,
name|max_cid
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
comment|/* When multiple GIDs map to the same CID, we choose the lowest */
comment|/* GID.  This is not described in any spec, but it matches the  */
comment|/* behaviour of recent Acroread versions.                       */
for|for
control|(
name|j
operator|=
name|num_glyphs
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|charset
operator|->
name|cids
index|[
name|charset
operator|->
name|sids
index|[
name|j
index|]
index|]
operator|=
operator|(
name|FT_UShort
operator|)
name|j
expr_stmt|;
name|charset
operator|->
name|max_cid
operator|=
name|max_cid
expr_stmt|;
name|charset
operator|->
name|num_glyphs
operator|=
name|num_glyphs
expr_stmt|;
name|Exit
label|:
return|return
name|error
return|;
block|}
end_function
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_UInt
argument_list|)
end_macro
begin_macro
name|cff_charset_cid_to_gindex
argument_list|(
argument|CFF_Charset  charset
argument_list|,
argument|FT_UInt      cid
argument_list|)
end_macro
begin_block
block|{
name|FT_UInt
name|result
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|cid
operator|<
name|charset
operator|->
name|max_cid
condition|)
name|result
operator|=
name|charset
operator|->
name|cids
index|[
name|cid
index|]
expr_stmt|;
return|return
name|result
return|;
block|}
end_block
begin_function
specifier|static
name|void
DECL|function|cff_charset_free_cids
name|cff_charset_free_cids
parameter_list|(
name|CFF_Charset
name|charset
parameter_list|,
name|FT_Memory
name|memory
parameter_list|)
block|{
name|FT_FREE
argument_list|(
name|charset
operator|->
name|cids
argument_list|)
expr_stmt|;
name|charset
operator|->
name|max_cid
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|cff_charset_done
name|cff_charset_done
parameter_list|(
name|CFF_Charset
name|charset
parameter_list|,
name|FT_Stream
name|stream
parameter_list|)
block|{
name|FT_Memory
name|memory
init|=
name|stream
operator|->
name|memory
decl_stmt|;
name|cff_charset_free_cids
argument_list|(
name|charset
argument_list|,
name|memory
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|charset
operator|->
name|sids
argument_list|)
expr_stmt|;
name|charset
operator|->
name|format
operator|=
literal|0
expr_stmt|;
name|charset
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|cff_charset_load
name|cff_charset_load
parameter_list|(
name|CFF_Charset
name|charset
parameter_list|,
name|FT_UInt
name|num_glyphs
parameter_list|,
name|FT_Stream
name|stream
parameter_list|,
name|FT_ULong
name|base_offset
parameter_list|,
name|FT_ULong
name|offset
parameter_list|,
name|FT_Bool
name|invert
parameter_list|)
block|{
name|FT_Memory
name|memory
init|=
name|stream
operator|->
name|memory
decl_stmt|;
name|FT_Error
name|error
init|=
name|CFF_Err_Ok
decl_stmt|;
name|FT_UShort
name|glyph_sid
decl_stmt|;
comment|/* If the the offset is greater than 2, we have to parse the */
comment|/* charset table.                                            */
if|if
condition|(
name|offset
operator|>
literal|2
condition|)
block|{
name|FT_UInt
name|j
decl_stmt|;
name|charset
operator|->
name|offset
operator|=
name|base_offset
operator|+
name|offset
expr_stmt|;
comment|/* Get the format of the table. */
if|if
condition|(
name|FT_STREAM_SEEK
argument_list|(
name|charset
operator|->
name|offset
argument_list|)
operator|||
name|FT_READ_BYTE
argument_list|(
name|charset
operator|->
name|format
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
comment|/* Allocate memory for sids. */
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|charset
operator|->
name|sids
argument_list|,
name|num_glyphs
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
comment|/* assign the .notdef glyph */
name|charset
operator|->
name|sids
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|charset
operator|->
name|format
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
name|num_glyphs
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|FT_FRAME_ENTER
argument_list|(
operator|(
name|num_glyphs
operator|-
literal|1
operator|)
operator|*
literal|2
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|num_glyphs
condition|;
name|j
operator|++
control|)
block|{
name|FT_UShort
name|sid
init|=
name|FT_GET_USHORT
argument_list|()
decl_stmt|;
comment|/* this constant is given in the CFF specification */
if|if
condition|(
name|sid
operator|<
literal|65000L
condition|)
name|charset
operator|->
name|sids
index|[
name|j
index|]
operator|=
name|sid
expr_stmt|;
else|else
block|{
name|FT_TRACE0
argument_list|(
operator|(
literal|"cff_charset_load:"
literal|" invalid SID value %d set to zero\n"
operator|,
name|sid
operator|)
argument_list|)
expr_stmt|;
name|charset
operator|->
name|sids
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|FT_FRAME_EXIT
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
literal|1
case|:
case|case
literal|2
case|:
block|{
name|FT_UInt
name|nleft
decl_stmt|;
name|FT_UInt
name|i
decl_stmt|;
name|j
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|j
operator|<
name|num_glyphs
condition|)
block|{
comment|/* Read the first glyph sid of the range. */
if|if
condition|(
name|FT_READ_USHORT
argument_list|(
name|glyph_sid
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
comment|/* Read the number of glyphs in the range.  */
if|if
condition|(
name|charset
operator|->
name|format
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|FT_READ_USHORT
argument_list|(
name|nleft
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
block|}
else|else
block|{
if|if
condition|(
name|FT_READ_BYTE
argument_list|(
name|nleft
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
block|}
comment|/* check whether the range contains at least one valid glyph; */
comment|/* the constant is given in the CFF specification             */
if|if
condition|(
name|glyph_sid
operator|>=
literal|65000L
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"cff_charset_load: invalid SID range\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|CFF_Err_Invalid_File_Format
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* try to rescue some of the SIDs if `nleft' is too large */
if|if
condition|(
name|nleft
operator|>
literal|65000L
operator|-
literal|1L
operator|||
name|glyph_sid
operator|>=
literal|65000L
operator|-
name|nleft
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"cff_charset_load: invalid SID range trimmed\n"
operator|)
argument_list|)
expr_stmt|;
name|nleft
operator|=
call|(
name|FT_UInt
call|)
argument_list|(
literal|65000L
operator|-
literal|1L
operator|-
name|glyph_sid
argument_list|)
expr_stmt|;
block|}
comment|/* Fill in the range of sids -- `nleft + 1' glyphs. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|j
operator|<
name|num_glyphs
operator|&&
name|i
operator|<=
name|nleft
condition|;
name|i
operator|++
operator|,
name|j
operator|++
operator|,
name|glyph_sid
operator|++
control|)
name|charset
operator|->
name|sids
index|[
name|j
index|]
operator|=
name|glyph_sid
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|FT_ERROR
argument_list|(
operator|(
literal|"cff_charset_load: invalid table format\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|CFF_Err_Invalid_File_Format
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
else|else
block|{
comment|/* Parse default tables corresponding to offset == 0, 1, or 2.  */
comment|/* CFF specification intimates the following:                   */
comment|/*                                                              */
comment|/* In order to use a predefined charset, the following must be  */
comment|/* true: The charset constructed for the glyphs in the font's   */
comment|/* charstrings dictionary must match the predefined charset in  */
comment|/* the first num_glyphs.                                        */
name|charset
operator|->
name|offset
operator|=
name|offset
expr_stmt|;
comment|/* record charset type */
switch|switch
condition|(
operator|(
name|FT_UInt
operator|)
name|offset
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
name|num_glyphs
operator|>
literal|229
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"cff_charset_load: implicit charset larger than\n"
literal|"predefined charset (Adobe ISO-Latin)\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|CFF_Err_Invalid_File_Format
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* Allocate memory for sids. */
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|charset
operator|->
name|sids
argument_list|,
name|num_glyphs
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
comment|/* Copy the predefined charset into the allocated memory. */
name|FT_ARRAY_COPY
argument_list|(
name|charset
operator|->
name|sids
argument_list|,
name|cff_isoadobe_charset
argument_list|,
name|num_glyphs
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
if|if
condition|(
name|num_glyphs
operator|>
literal|166
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"cff_charset_load: implicit charset larger than\n"
literal|"predefined charset (Adobe Expert)\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|CFF_Err_Invalid_File_Format
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* Allocate memory for sids. */
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|charset
operator|->
name|sids
argument_list|,
name|num_glyphs
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
comment|/* Copy the predefined charset into the allocated memory.     */
name|FT_ARRAY_COPY
argument_list|(
name|charset
operator|->
name|sids
argument_list|,
name|cff_expert_charset
argument_list|,
name|num_glyphs
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
if|if
condition|(
name|num_glyphs
operator|>
literal|87
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"cff_charset_load: implicit charset larger than\n"
literal|"predefined charset (Adobe Expert Subset)\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|CFF_Err_Invalid_File_Format
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* Allocate memory for sids. */
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|charset
operator|->
name|sids
argument_list|,
name|num_glyphs
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
comment|/* Copy the predefined charset into the allocated memory.     */
name|FT_ARRAY_COPY
argument_list|(
name|charset
operator|->
name|sids
argument_list|,
name|cff_expertsubset_charset
argument_list|,
name|num_glyphs
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|CFF_Err_Invalid_File_Format
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
comment|/* we have to invert the `sids' array for subsetted CID-keyed fonts */
if|if
condition|(
name|invert
condition|)
name|error
operator|=
name|cff_charset_compute_cids
argument_list|(
name|charset
argument_list|,
name|num_glyphs
argument_list|,
name|memory
argument_list|)
expr_stmt|;
name|Exit
label|:
comment|/* Clean up if there was an error. */
if|if
condition|(
name|error
condition|)
block|{
name|FT_FREE
argument_list|(
name|charset
operator|->
name|sids
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|charset
operator|->
name|cids
argument_list|)
expr_stmt|;
name|charset
operator|->
name|format
operator|=
literal|0
expr_stmt|;
name|charset
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|charset
operator|->
name|sids
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|cff_encoding_done
name|cff_encoding_done
parameter_list|(
name|CFF_Encoding
name|encoding
parameter_list|)
block|{
name|encoding
operator|->
name|format
operator|=
literal|0
expr_stmt|;
name|encoding
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|encoding
operator|->
name|count
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|cff_encoding_load
name|cff_encoding_load
parameter_list|(
name|CFF_Encoding
name|encoding
parameter_list|,
name|CFF_Charset
name|charset
parameter_list|,
name|FT_UInt
name|num_glyphs
parameter_list|,
name|FT_Stream
name|stream
parameter_list|,
name|FT_ULong
name|base_offset
parameter_list|,
name|FT_ULong
name|offset
parameter_list|)
block|{
name|FT_Error
name|error
init|=
name|CFF_Err_Ok
decl_stmt|;
name|FT_UInt
name|count
decl_stmt|;
name|FT_UInt
name|j
decl_stmt|;
name|FT_UShort
name|glyph_sid
decl_stmt|;
name|FT_UInt
name|glyph_code
decl_stmt|;
comment|/* Check for charset->sids.  If we do not have this, we fail. */
if|if
condition|(
operator|!
name|charset
operator|->
name|sids
condition|)
block|{
name|error
operator|=
name|CFF_Err_Invalid_File_Format
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* Zero out the code to gid/sid mappings. */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|256
condition|;
name|j
operator|++
control|)
block|{
name|encoding
operator|->
name|sids
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
name|encoding
operator|->
name|codes
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Note: The encoding table in a CFF font is indexed by glyph index;  */
comment|/* the first encoded glyph index is 1.  Hence, we read the character  */
comment|/* code (`glyph_code') at index j and make the assignment:            */
comment|/*                                                                    */
comment|/*    encoding->codes[glyph_code] = j + 1                             */
comment|/*                                                                    */
comment|/* We also make the assignment:                                       */
comment|/*                                                                    */
comment|/*    encoding->sids[glyph_code] = charset->sids[j + 1]               */
comment|/*                                                                    */
comment|/* This gives us both a code to GID and a code to SID mapping.        */
if|if
condition|(
name|offset
operator|>
literal|1
condition|)
block|{
name|encoding
operator|->
name|offset
operator|=
name|base_offset
operator|+
name|offset
expr_stmt|;
comment|/* we need to parse the table to determine its size */
if|if
condition|(
name|FT_STREAM_SEEK
argument_list|(
name|encoding
operator|->
name|offset
argument_list|)
operator|||
name|FT_READ_BYTE
argument_list|(
name|encoding
operator|->
name|format
argument_list|)
operator|||
name|FT_READ_BYTE
argument_list|(
name|count
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
switch|switch
condition|(
name|encoding
operator|->
name|format
operator|&
literal|0x7F
condition|)
block|{
case|case
literal|0
case|:
block|{
name|FT_Byte
modifier|*
name|p
decl_stmt|;
comment|/* By convention, GID 0 is always ".notdef" and is never */
comment|/* coded in the font.  Hence, the number of codes found  */
comment|/* in the table is `count+1'.                            */
comment|/*                                                       */
name|encoding
operator|->
name|count
operator|=
name|count
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|FT_FRAME_ENTER
argument_list|(
name|count
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|p
operator|=
operator|(
name|FT_Byte
operator|*
operator|)
name|stream
operator|->
name|cursor
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|count
condition|;
name|j
operator|++
control|)
block|{
name|glyph_code
operator|=
operator|*
name|p
operator|++
expr_stmt|;
comment|/* Make sure j is not too big. */
if|if
condition|(
name|j
operator|<
name|num_glyphs
condition|)
block|{
comment|/* Assign code to GID mapping. */
name|encoding
operator|->
name|codes
index|[
name|glyph_code
index|]
operator|=
operator|(
name|FT_UShort
operator|)
name|j
expr_stmt|;
comment|/* Assign code to SID mapping. */
name|encoding
operator|->
name|sids
index|[
name|glyph_code
index|]
operator|=
name|charset
operator|->
name|sids
index|[
name|j
index|]
expr_stmt|;
block|}
block|}
name|FT_FRAME_EXIT
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
literal|1
case|:
block|{
name|FT_UInt
name|nleft
decl_stmt|;
name|FT_UInt
name|i
init|=
literal|1
decl_stmt|;
name|FT_UInt
name|k
decl_stmt|;
name|encoding
operator|->
name|count
operator|=
literal|0
expr_stmt|;
comment|/* Parse the Format1 ranges. */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|count
condition|;
name|j
operator|++
operator|,
name|i
operator|+=
name|nleft
control|)
block|{
comment|/* Read the first glyph code of the range. */
if|if
condition|(
name|FT_READ_BYTE
argument_list|(
name|glyph_code
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
comment|/* Read the number of codes in the range. */
if|if
condition|(
name|FT_READ_BYTE
argument_list|(
name|nleft
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
comment|/* Increment nleft, so we read `nleft + 1' codes/sids. */
name|nleft
operator|++
expr_stmt|;
comment|/* compute max number of character codes */
if|if
condition|(
operator|(
name|FT_UInt
operator|)
name|nleft
operator|>
name|encoding
operator|->
name|count
condition|)
name|encoding
operator|->
name|count
operator|=
name|nleft
expr_stmt|;
comment|/* Fill in the range of codes/sids. */
for|for
control|(
name|k
operator|=
name|i
init|;
name|k
operator|<
name|nleft
operator|+
name|i
condition|;
name|k
operator|++
operator|,
name|glyph_code
operator|++
control|)
block|{
comment|/* Make sure k is not too big. */
if|if
condition|(
name|k
operator|<
name|num_glyphs
operator|&&
name|glyph_code
operator|<
literal|256
condition|)
block|{
comment|/* Assign code to GID mapping. */
name|encoding
operator|->
name|codes
index|[
name|glyph_code
index|]
operator|=
operator|(
name|FT_UShort
operator|)
name|k
expr_stmt|;
comment|/* Assign code to SID mapping. */
name|encoding
operator|->
name|sids
index|[
name|glyph_code
index|]
operator|=
name|charset
operator|->
name|sids
index|[
name|k
index|]
expr_stmt|;
block|}
block|}
block|}
comment|/* simple check; one never knows what can be found in a font */
if|if
condition|(
name|encoding
operator|->
name|count
operator|>
literal|256
condition|)
name|encoding
operator|->
name|count
operator|=
literal|256
expr_stmt|;
block|}
break|break;
default|default:
name|FT_ERROR
argument_list|(
operator|(
literal|"cff_encoding_load: invalid table format\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|CFF_Err_Invalid_File_Format
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* Parse supplemental encodings, if any. */
if|if
condition|(
name|encoding
operator|->
name|format
operator|&
literal|0x80
condition|)
block|{
name|FT_UInt
name|gindex
decl_stmt|;
comment|/* count supplements */
if|if
condition|(
name|FT_READ_BYTE
argument_list|(
name|count
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|count
condition|;
name|j
operator|++
control|)
block|{
comment|/* Read supplemental glyph code. */
if|if
condition|(
name|FT_READ_BYTE
argument_list|(
name|glyph_code
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
comment|/* Read the SID associated with this glyph code. */
if|if
condition|(
name|FT_READ_USHORT
argument_list|(
name|glyph_sid
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
comment|/* Assign code to SID mapping. */
name|encoding
operator|->
name|sids
index|[
name|glyph_code
index|]
operator|=
name|glyph_sid
expr_stmt|;
comment|/* First, look up GID which has been assigned to */
comment|/* SID glyph_sid.                                */
for|for
control|(
name|gindex
operator|=
literal|0
init|;
name|gindex
operator|<
name|num_glyphs
condition|;
name|gindex
operator|++
control|)
block|{
if|if
condition|(
name|charset
operator|->
name|sids
index|[
name|gindex
index|]
operator|==
name|glyph_sid
condition|)
block|{
name|encoding
operator|->
name|codes
index|[
name|glyph_code
index|]
operator|=
operator|(
name|FT_UShort
operator|)
name|gindex
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
else|else
block|{
comment|/* We take into account the fact a CFF font can use a predefined */
comment|/* encoding without containing all of the glyphs encoded by this */
comment|/* encoding (see the note at the end of section 12 in the CFF    */
comment|/* specification).                                               */
switch|switch
condition|(
operator|(
name|FT_UInt
operator|)
name|offset
condition|)
block|{
case|case
literal|0
case|:
comment|/* First, copy the code to SID mapping. */
name|FT_ARRAY_COPY
argument_list|(
name|encoding
operator|->
name|sids
argument_list|,
name|cff_standard_encoding
argument_list|,
literal|256
argument_list|)
expr_stmt|;
goto|goto
name|Populate
goto|;
case|case
literal|1
case|:
comment|/* First, copy the code to SID mapping. */
name|FT_ARRAY_COPY
argument_list|(
name|encoding
operator|->
name|sids
argument_list|,
name|cff_expert_encoding
argument_list|,
literal|256
argument_list|)
expr_stmt|;
name|Populate
label|:
comment|/* Construct code to GID mapping from code to SID mapping */
comment|/* and charset.                                           */
name|encoding
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|cff_charset_compute_cids
argument_list|(
name|charset
argument_list|,
name|num_glyphs
argument_list|,
name|stream
operator|->
name|memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|256
condition|;
name|j
operator|++
control|)
block|{
name|FT_UInt
name|sid
init|=
name|encoding
operator|->
name|sids
index|[
name|j
index|]
decl_stmt|;
name|FT_UInt
name|gid
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|sid
condition|)
name|gid
operator|=
name|cff_charset_cid_to_gindex
argument_list|(
name|charset
argument_list|,
name|sid
argument_list|)
expr_stmt|;
if|if
condition|(
name|gid
operator|!=
literal|0
condition|)
block|{
name|encoding
operator|->
name|codes
index|[
name|j
index|]
operator|=
operator|(
name|FT_UShort
operator|)
name|gid
expr_stmt|;
if|if
condition|(
name|encoding
operator|->
name|count
operator|<
name|j
operator|+
literal|1
condition|)
name|encoding
operator|->
name|count
operator|=
name|j
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|encoding
operator|->
name|codes
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
name|encoding
operator|->
name|sids
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|FT_ERROR
argument_list|(
operator|(
literal|"cff_encoding_load: invalid table format\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|CFF_Err_Invalid_File_Format
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
name|Exit
label|:
comment|/* Clean up if there was an error. */
return|return
name|error
return|;
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|cff_subfont_load
name|cff_subfont_load
parameter_list|(
name|CFF_SubFont
name|font
parameter_list|,
name|CFF_Index
name|idx
parameter_list|,
name|FT_UInt
name|font_index
parameter_list|,
name|FT_Stream
name|stream
parameter_list|,
name|FT_ULong
name|base_offset
parameter_list|,
name|FT_Library
name|library
parameter_list|)
block|{
name|FT_Error
name|error
decl_stmt|;
name|CFF_ParserRec
name|parser
decl_stmt|;
name|FT_Byte
modifier|*
name|dict
init|=
name|NULL
decl_stmt|;
name|FT_ULong
name|dict_len
decl_stmt|;
name|CFF_FontRecDict
name|top
init|=
operator|&
name|font
operator|->
name|font_dict
decl_stmt|;
name|CFF_Private
name|priv
init|=
operator|&
name|font
operator|->
name|private_dict
decl_stmt|;
name|cff_parser_init
argument_list|(
operator|&
name|parser
argument_list|,
name|CFF_CODE_TOPDICT
argument_list|,
operator|&
name|font
operator|->
name|font_dict
argument_list|,
name|library
argument_list|)
expr_stmt|;
comment|/* set defaults */
name|FT_MEM_ZERO
argument_list|(
name|top
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|top
argument_list|)
argument_list|)
expr_stmt|;
name|top
operator|->
name|underline_position
operator|=
operator|-
literal|100L
operator|<<
literal|16
expr_stmt|;
name|top
operator|->
name|underline_thickness
operator|=
literal|50L
operator|<<
literal|16
expr_stmt|;
name|top
operator|->
name|charstring_type
operator|=
literal|2
expr_stmt|;
name|top
operator|->
name|font_matrix
operator|.
name|xx
operator|=
literal|0x10000L
expr_stmt|;
name|top
operator|->
name|font_matrix
operator|.
name|yy
operator|=
literal|0x10000L
expr_stmt|;
name|top
operator|->
name|cid_count
operator|=
literal|8720
expr_stmt|;
comment|/* we use the implementation specific SID value 0xFFFF to indicate */
comment|/* missing entries                                                 */
name|top
operator|->
name|version
operator|=
literal|0xFFFFU
expr_stmt|;
name|top
operator|->
name|notice
operator|=
literal|0xFFFFU
expr_stmt|;
name|top
operator|->
name|copyright
operator|=
literal|0xFFFFU
expr_stmt|;
name|top
operator|->
name|full_name
operator|=
literal|0xFFFFU
expr_stmt|;
name|top
operator|->
name|family_name
operator|=
literal|0xFFFFU
expr_stmt|;
name|top
operator|->
name|weight
operator|=
literal|0xFFFFU
expr_stmt|;
name|top
operator|->
name|embedded_postscript
operator|=
literal|0xFFFFU
expr_stmt|;
name|top
operator|->
name|cid_registry
operator|=
literal|0xFFFFU
expr_stmt|;
name|top
operator|->
name|cid_ordering
operator|=
literal|0xFFFFU
expr_stmt|;
name|top
operator|->
name|cid_font_name
operator|=
literal|0xFFFFU
expr_stmt|;
name|error
operator|=
name|cff_index_access_element
argument_list|(
name|idx
argument_list|,
name|font_index
argument_list|,
operator|&
name|dict
argument_list|,
operator|&
name|dict_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|cff_parser_run
argument_list|(
operator|&
name|parser
argument_list|,
name|dict
argument_list|,
name|dict
operator|+
name|dict_len
argument_list|)
expr_stmt|;
name|cff_index_forget_element
argument_list|(
name|idx
argument_list|,
operator|&
name|dict
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
comment|/* if it is a CID font, we stop there */
if|if
condition|(
name|top
operator|->
name|cid_registry
operator|!=
literal|0xFFFFU
condition|)
goto|goto
name|Exit
goto|;
comment|/* parse the private dictionary, if any */
if|if
condition|(
name|top
operator|->
name|private_offset
operator|&&
name|top
operator|->
name|private_size
condition|)
block|{
comment|/* set defaults */
name|FT_MEM_ZERO
argument_list|(
name|priv
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|priv
argument_list|)
argument_list|)
expr_stmt|;
name|priv
operator|->
name|blue_shift
operator|=
literal|7
expr_stmt|;
name|priv
operator|->
name|blue_fuzz
operator|=
literal|1
expr_stmt|;
name|priv
operator|->
name|lenIV
operator|=
operator|-
literal|1
expr_stmt|;
name|priv
operator|->
name|expansion_factor
operator|=
call|(
name|FT_Fixed
call|)
argument_list|(
literal|0.06
operator|*
literal|0x10000L
argument_list|)
expr_stmt|;
name|priv
operator|->
name|blue_scale
operator|=
call|(
name|FT_Fixed
call|)
argument_list|(
literal|0.039625
operator|*
literal|0x10000L
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|cff_parser_init
argument_list|(
operator|&
name|parser
argument_list|,
name|CFF_CODE_PRIVATE
argument_list|,
name|priv
argument_list|,
name|library
argument_list|)
expr_stmt|;
if|if
condition|(
name|FT_STREAM_SEEK
argument_list|(
name|base_offset
operator|+
name|font
operator|->
name|font_dict
operator|.
name|private_offset
argument_list|)
operator|||
name|FT_FRAME_ENTER
argument_list|(
name|font
operator|->
name|font_dict
operator|.
name|private_size
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|error
operator|=
name|cff_parser_run
argument_list|(
operator|&
name|parser
argument_list|,
operator|(
name|FT_Byte
operator|*
operator|)
name|stream
operator|->
name|cursor
argument_list|,
operator|(
name|FT_Byte
operator|*
operator|)
name|stream
operator|->
name|limit
argument_list|)
expr_stmt|;
name|FT_FRAME_EXIT
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
comment|/* ensure that `num_blue_values' is even */
name|priv
operator|->
name|num_blue_values
operator|&=
operator|~
literal|1
expr_stmt|;
block|}
comment|/* read the local subrs, if any */
if|if
condition|(
name|priv
operator|->
name|local_subrs_offset
condition|)
block|{
if|if
condition|(
name|FT_STREAM_SEEK
argument_list|(
name|base_offset
operator|+
name|top
operator|->
name|private_offset
operator|+
name|priv
operator|->
name|local_subrs_offset
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|error
operator|=
name|cff_index_init
argument_list|(
operator|&
name|font
operator|->
name|local_subrs_index
argument_list|,
name|stream
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|font
operator|->
name|num_local_subrs
operator|=
name|font
operator|->
name|local_subrs_index
operator|.
name|count
expr_stmt|;
name|error
operator|=
name|cff_index_get_pointers
argument_list|(
operator|&
name|font
operator|->
name|local_subrs_index
argument_list|,
operator|&
name|font
operator|->
name|local_subrs
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
block|}
name|Exit
label|:
return|return
name|error
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|cff_subfont_done
name|cff_subfont_done
parameter_list|(
name|FT_Memory
name|memory
parameter_list|,
name|CFF_SubFont
name|subfont
parameter_list|)
block|{
if|if
condition|(
name|subfont
condition|)
block|{
name|cff_index_done
argument_list|(
operator|&
name|subfont
operator|->
name|local_subrs_index
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|subfont
operator|->
name|local_subrs
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|cff_font_load
argument_list|(
argument|FT_Library library
argument_list|,
argument|FT_Stream  stream
argument_list|,
argument|FT_Int     face_index
argument_list|,
argument|CFF_Font   font
argument_list|,
argument|FT_Bool    pure_cff
argument_list|)
end_macro
begin_block
block|{
specifier|static
specifier|const
name|FT_Frame_Field
name|cff_header_fields
index|[]
init|=
block|{
DECL|macro|FT_STRUCTURE
undef|#
directive|undef
name|FT_STRUCTURE
DECL|macro|FT_STRUCTURE
define|#
directive|define
name|FT_STRUCTURE
value|CFF_FontRec
name|FT_FRAME_START
argument_list|(
literal|4
argument_list|)
block|,
name|FT_FRAME_BYTE
argument_list|(
name|version_major
argument_list|)
block|,
name|FT_FRAME_BYTE
argument_list|(
name|version_minor
argument_list|)
block|,
name|FT_FRAME_BYTE
argument_list|(
name|header_size
argument_list|)
block|,
name|FT_FRAME_BYTE
argument_list|(
name|absolute_offsize
argument_list|)
block|,
name|FT_FRAME_END
block|}
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|stream
operator|->
name|memory
decl_stmt|;
name|FT_ULong
name|base_offset
decl_stmt|;
name|CFF_FontRecDict
name|dict
decl_stmt|;
name|FT_ZERO
argument_list|(
name|font
argument_list|)
expr_stmt|;
name|font
operator|->
name|stream
operator|=
name|stream
expr_stmt|;
name|font
operator|->
name|memory
operator|=
name|memory
expr_stmt|;
name|dict
operator|=
operator|&
name|font
operator|->
name|top_font
operator|.
name|font_dict
expr_stmt|;
name|base_offset
operator|=
name|FT_STREAM_POS
argument_list|()
expr_stmt|;
comment|/* read CFF font header */
if|if
condition|(
name|FT_STREAM_READ_FIELDS
argument_list|(
name|cff_header_fields
argument_list|,
name|font
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
comment|/* check format */
if|if
condition|(
name|font
operator|->
name|version_major
operator|!=
literal|1
operator|||
name|font
operator|->
name|header_size
operator|<
literal|4
operator|||
name|font
operator|->
name|absolute_offsize
operator|>
literal|4
condition|)
block|{
name|FT_TRACE2
argument_list|(
operator|(
literal|"[not a CFF font header]\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|CFF_Err_Unknown_File_Format
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* skip the rest of the header */
if|if
condition|(
name|FT_STREAM_SKIP
argument_list|(
name|font
operator|->
name|header_size
operator|-
literal|4
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
comment|/* read the name, top dict, string and global subrs index */
if|if
condition|(
name|FT_SET_ERROR
argument_list|(
name|cff_index_init
argument_list|(
operator|&
name|font
operator|->
name|name_index
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
name|FT_SET_ERROR
argument_list|(
name|cff_index_init
argument_list|(
operator|&
name|font
operator|->
name|font_dict_index
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
name|FT_SET_ERROR
argument_list|(
name|cff_index_init
argument_list|(
operator|&
name|font
operator|->
name|string_index
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
name|FT_SET_ERROR
argument_list|(
name|cff_index_init
argument_list|(
operator|&
name|font
operator|->
name|global_subrs_index
argument_list|,
name|stream
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
comment|/* well, we don't really forget the `disabled' fonts... */
name|font
operator|->
name|num_faces
operator|=
name|font
operator|->
name|name_index
operator|.
name|count
expr_stmt|;
if|if
condition|(
name|face_index
operator|>=
operator|(
name|FT_Int
operator|)
name|font
operator|->
name|num_faces
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"cff_font_load: incorrect face index = %d\n"
operator|,
name|face_index
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|CFF_Err_Invalid_Argument
expr_stmt|;
block|}
comment|/* in case of a font format check, simply exit now */
if|if
condition|(
name|face_index
operator|<
literal|0
condition|)
goto|goto
name|Exit
goto|;
comment|/* now, parse the top-level font dictionary */
name|error
operator|=
name|cff_subfont_load
argument_list|(
operator|&
name|font
operator|->
name|top_font
argument_list|,
operator|&
name|font
operator|->
name|font_dict_index
argument_list|,
name|face_index
argument_list|,
name|stream
argument_list|,
name|base_offset
argument_list|,
name|library
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
if|if
condition|(
name|FT_STREAM_SEEK
argument_list|(
name|base_offset
operator|+
name|dict
operator|->
name|charstrings_offset
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|error
operator|=
name|cff_index_init
argument_list|(
operator|&
name|font
operator|->
name|charstrings_index
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
comment|/* now, check for a CID font */
if|if
condition|(
name|dict
operator|->
name|cid_registry
operator|!=
literal|0xFFFFU
condition|)
block|{
name|CFF_IndexRec
name|fd_index
decl_stmt|;
name|CFF_SubFont
name|sub
decl_stmt|;
name|FT_UInt
name|idx
decl_stmt|;
comment|/* this is a CID-keyed font, we must now allocate a table of */
comment|/* sub-fonts, then load each of them separately              */
if|if
condition|(
name|FT_STREAM_SEEK
argument_list|(
name|base_offset
operator|+
name|dict
operator|->
name|cid_fd_array_offset
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|error
operator|=
name|cff_index_init
argument_list|(
operator|&
name|fd_index
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
if|if
condition|(
name|fd_index
operator|.
name|count
operator|>
name|CFF_MAX_CID_FONTS
condition|)
block|{
name|FT_TRACE0
argument_list|(
operator|(
literal|"cff_font_load: FD array too large in CID font\n"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|Fail_CID
goto|;
block|}
comment|/* allocate& read each font dict independently */
name|font
operator|->
name|num_subfonts
operator|=
name|fd_index
operator|.
name|count
expr_stmt|;
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|sub
argument_list|,
name|fd_index
operator|.
name|count
argument_list|)
condition|)
goto|goto
name|Fail_CID
goto|;
comment|/* set up pointer table */
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|fd_index
operator|.
name|count
condition|;
name|idx
operator|++
control|)
name|font
operator|->
name|subfonts
index|[
name|idx
index|]
operator|=
name|sub
operator|+
name|idx
expr_stmt|;
comment|/* now load each subfont independently */
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|fd_index
operator|.
name|count
condition|;
name|idx
operator|++
control|)
block|{
name|sub
operator|=
name|font
operator|->
name|subfonts
index|[
name|idx
index|]
expr_stmt|;
name|error
operator|=
name|cff_subfont_load
argument_list|(
name|sub
argument_list|,
operator|&
name|fd_index
argument_list|,
name|idx
argument_list|,
name|stream
argument_list|,
name|base_offset
argument_list|,
name|library
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Fail_CID
goto|;
block|}
comment|/* now load the FD Select array */
name|error
operator|=
name|CFF_Load_FD_Select
argument_list|(
operator|&
name|font
operator|->
name|fd_select
argument_list|,
name|font
operator|->
name|charstrings_index
operator|.
name|count
argument_list|,
name|stream
argument_list|,
name|base_offset
operator|+
name|dict
operator|->
name|cid_fd_select_offset
argument_list|)
expr_stmt|;
name|Fail_CID
label|:
name|cff_index_done
argument_list|(
operator|&
name|fd_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
block|}
else|else
name|font
operator|->
name|num_subfonts
operator|=
literal|0
expr_stmt|;
comment|/* read the charstrings index now */
if|if
condition|(
name|dict
operator|->
name|charstrings_offset
operator|==
literal|0
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"cff_font_load: no charstrings offset\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|CFF_Err_Unknown_File_Format
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* explicit the global subrs */
name|font
operator|->
name|num_global_subrs
operator|=
name|font
operator|->
name|global_subrs_index
operator|.
name|count
expr_stmt|;
name|font
operator|->
name|num_glyphs
operator|=
name|font
operator|->
name|charstrings_index
operator|.
name|count
expr_stmt|;
name|error
operator|=
name|cff_index_get_pointers
argument_list|(
operator|&
name|font
operator|->
name|global_subrs_index
argument_list|,
operator|&
name|font
operator|->
name|global_subrs
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
comment|/* read the Charset and Encoding tables if available */
if|if
condition|(
name|font
operator|->
name|num_glyphs
operator|>
literal|0
condition|)
block|{
name|FT_Bool
name|invert
init|=
name|FT_BOOL
argument_list|(
name|dict
operator|->
name|cid_registry
operator|!=
literal|0xFFFFU
operator|&&
name|pure_cff
argument_list|)
decl_stmt|;
name|error
operator|=
name|cff_charset_load
argument_list|(
operator|&
name|font
operator|->
name|charset
argument_list|,
name|font
operator|->
name|num_glyphs
argument_list|,
name|stream
argument_list|,
name|base_offset
argument_list|,
name|dict
operator|->
name|charset_offset
argument_list|,
name|invert
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
comment|/* CID-keyed CFFs don't have an encoding */
if|if
condition|(
name|dict
operator|->
name|cid_registry
operator|==
literal|0xFFFFU
condition|)
block|{
name|error
operator|=
name|cff_encoding_load
argument_list|(
operator|&
name|font
operator|->
name|encoding
argument_list|,
operator|&
name|font
operator|->
name|charset
argument_list|,
name|font
operator|->
name|num_glyphs
argument_list|,
name|stream
argument_list|,
name|base_offset
argument_list|,
name|dict
operator|->
name|encoding_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
block|}
block|}
comment|/* get the font name (/CIDFontName for CID-keyed fonts, */
comment|/* /FontName otherwise)                                 */
name|font
operator|->
name|font_name
operator|=
name|cff_index_get_name
argument_list|(
operator|&
name|font
operator|->
name|name_index
argument_list|,
name|face_index
argument_list|)
expr_stmt|;
name|Exit
label|:
return|return
name|error
return|;
block|}
end_block
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|cff_font_done
name|cff_font_done
argument_list|(
argument|CFF_Font  font
argument_list|)
end_macro
begin_block
block|{
name|FT_Memory
name|memory
init|=
name|font
operator|->
name|memory
decl_stmt|;
name|FT_UInt
name|idx
decl_stmt|;
name|cff_index_done
argument_list|(
operator|&
name|font
operator|->
name|global_subrs_index
argument_list|)
expr_stmt|;
name|cff_index_done
argument_list|(
operator|&
name|font
operator|->
name|string_index
argument_list|)
expr_stmt|;
name|cff_index_done
argument_list|(
operator|&
name|font
operator|->
name|font_dict_index
argument_list|)
expr_stmt|;
name|cff_index_done
argument_list|(
operator|&
name|font
operator|->
name|name_index
argument_list|)
expr_stmt|;
name|cff_index_done
argument_list|(
operator|&
name|font
operator|->
name|charstrings_index
argument_list|)
expr_stmt|;
comment|/* release font dictionaries, but only if working with */
comment|/* a CID keyed CFF font                                */
if|if
condition|(
name|font
operator|->
name|num_subfonts
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|font
operator|->
name|num_subfonts
condition|;
name|idx
operator|++
control|)
name|cff_subfont_done
argument_list|(
name|memory
argument_list|,
name|font
operator|->
name|subfonts
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
comment|/* the subfonts array has been allocated as a single block */
name|FT_FREE
argument_list|(
name|font
operator|->
name|subfonts
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
name|cff_encoding_done
argument_list|(
operator|&
name|font
operator|->
name|encoding
argument_list|)
expr_stmt|;
name|cff_charset_done
argument_list|(
operator|&
name|font
operator|->
name|charset
argument_list|,
name|font
operator|->
name|stream
argument_list|)
expr_stmt|;
name|cff_subfont_done
argument_list|(
name|memory
argument_list|,
operator|&
name|font
operator|->
name|top_font
argument_list|)
expr_stmt|;
name|CFF_Done_FD_Select
argument_list|(
operator|&
name|font
operator|->
name|fd_select
argument_list|,
name|font
operator|->
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|font
operator|->
name|font_info
operator|!=
name|NULL
condition|)
block|{
name|FT_FREE
argument_list|(
name|font
operator|->
name|font_info
operator|->
name|version
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|font
operator|->
name|font_info
operator|->
name|notice
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|font
operator|->
name|font_info
operator|->
name|full_name
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|font
operator|->
name|font_info
operator|->
name|family_name
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|font
operator|->
name|font_info
operator|->
name|weight
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|font
operator|->
name|font_info
argument_list|)
expr_stmt|;
block|}
name|FT_FREE
argument_list|(
name|font
operator|->
name|registry
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|font
operator|->
name|ordering
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|font
operator|->
name|global_subrs
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|font
operator|->
name|font_name
argument_list|)
expr_stmt|;
block|}
end_block
begin_comment
comment|/* END */
end_comment
end_unit
