begin_unit
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  cffgload.c                                                             */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*    OpenType Glyph Loader (body).                                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,   */
end_comment
begin_comment
comment|/*            2010 by                                                      */
end_comment
begin_comment
comment|/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  This file is part of the FreeType project, and may only be used,       */
end_comment
begin_comment
comment|/*  modified, and distributed under the terms of the FreeType project      */
end_comment
begin_comment
comment|/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
end_comment
begin_comment
comment|/*  this file you indicate that you have read the license and              */
end_comment
begin_comment
comment|/*  understand and accept it fully.                                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<ft2build.h>
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_DEBUG_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_STREAM_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_SFNT_H
end_include
begin_include
include|#
directive|include
include|FT_OUTLINE_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_POSTSCRIPT_HINTS_H
end_include
begin_include
include|#
directive|include
file|"cffobjs.h"
end_include
begin_include
include|#
directive|include
file|"cffload.h"
end_include
begin_include
include|#
directive|include
file|"cffgload.h"
end_include
begin_include
include|#
directive|include
file|"cfferrs.h"
end_include
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
end_comment
begin_comment
comment|/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
end_comment
begin_comment
comment|/* messages during execution.                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_undef
DECL|macro|FT_COMPONENT
undef|#
directive|undef
name|FT_COMPONENT
end_undef
begin_define
DECL|macro|FT_COMPONENT
define|#
directive|define
name|FT_COMPONENT
value|trace_cffgload
end_define
begin_typedef
DECL|enum|CFF_Operator_
typedef|typedef
enum|enum
name|CFF_Operator_
block|{
DECL|enumerator|cff_op_unknown
name|cff_op_unknown
init|=
literal|0
block|,
DECL|enumerator|cff_op_rmoveto
name|cff_op_rmoveto
block|,
DECL|enumerator|cff_op_hmoveto
name|cff_op_hmoveto
block|,
DECL|enumerator|cff_op_vmoveto
name|cff_op_vmoveto
block|,
DECL|enumerator|cff_op_rlineto
name|cff_op_rlineto
block|,
DECL|enumerator|cff_op_hlineto
name|cff_op_hlineto
block|,
DECL|enumerator|cff_op_vlineto
name|cff_op_vlineto
block|,
DECL|enumerator|cff_op_rrcurveto
name|cff_op_rrcurveto
block|,
DECL|enumerator|cff_op_hhcurveto
name|cff_op_hhcurveto
block|,
DECL|enumerator|cff_op_hvcurveto
name|cff_op_hvcurveto
block|,
DECL|enumerator|cff_op_rcurveline
name|cff_op_rcurveline
block|,
DECL|enumerator|cff_op_rlinecurve
name|cff_op_rlinecurve
block|,
DECL|enumerator|cff_op_vhcurveto
name|cff_op_vhcurveto
block|,
DECL|enumerator|cff_op_vvcurveto
name|cff_op_vvcurveto
block|,
DECL|enumerator|cff_op_flex
name|cff_op_flex
block|,
DECL|enumerator|cff_op_hflex
name|cff_op_hflex
block|,
DECL|enumerator|cff_op_hflex1
name|cff_op_hflex1
block|,
DECL|enumerator|cff_op_flex1
name|cff_op_flex1
block|,
DECL|enumerator|cff_op_endchar
name|cff_op_endchar
block|,
DECL|enumerator|cff_op_hstem
name|cff_op_hstem
block|,
DECL|enumerator|cff_op_vstem
name|cff_op_vstem
block|,
DECL|enumerator|cff_op_hstemhm
name|cff_op_hstemhm
block|,
DECL|enumerator|cff_op_vstemhm
name|cff_op_vstemhm
block|,
DECL|enumerator|cff_op_hintmask
name|cff_op_hintmask
block|,
DECL|enumerator|cff_op_cntrmask
name|cff_op_cntrmask
block|,
DECL|enumerator|cff_op_dotsection
name|cff_op_dotsection
block|,
comment|/* deprecated, acts as no-op */
DECL|enumerator|cff_op_abs
name|cff_op_abs
block|,
DECL|enumerator|cff_op_add
name|cff_op_add
block|,
DECL|enumerator|cff_op_sub
name|cff_op_sub
block|,
DECL|enumerator|cff_op_div
name|cff_op_div
block|,
DECL|enumerator|cff_op_neg
name|cff_op_neg
block|,
DECL|enumerator|cff_op_random
name|cff_op_random
block|,
DECL|enumerator|cff_op_mul
name|cff_op_mul
block|,
DECL|enumerator|cff_op_sqrt
name|cff_op_sqrt
block|,
DECL|enumerator|cff_op_blend
name|cff_op_blend
block|,
DECL|enumerator|cff_op_drop
name|cff_op_drop
block|,
DECL|enumerator|cff_op_exch
name|cff_op_exch
block|,
DECL|enumerator|cff_op_index
name|cff_op_index
block|,
DECL|enumerator|cff_op_roll
name|cff_op_roll
block|,
DECL|enumerator|cff_op_dup
name|cff_op_dup
block|,
DECL|enumerator|cff_op_put
name|cff_op_put
block|,
DECL|enumerator|cff_op_get
name|cff_op_get
block|,
DECL|enumerator|cff_op_store
name|cff_op_store
block|,
DECL|enumerator|cff_op_load
name|cff_op_load
block|,
DECL|enumerator|cff_op_and
name|cff_op_and
block|,
DECL|enumerator|cff_op_or
name|cff_op_or
block|,
DECL|enumerator|cff_op_not
name|cff_op_not
block|,
DECL|enumerator|cff_op_eq
name|cff_op_eq
block|,
DECL|enumerator|cff_op_ifelse
name|cff_op_ifelse
block|,
DECL|enumerator|cff_op_callsubr
name|cff_op_callsubr
block|,
DECL|enumerator|cff_op_callgsubr
name|cff_op_callgsubr
block|,
DECL|enumerator|cff_op_return
name|cff_op_return
block|,
comment|/* Type 1 opcodes: invalid but seen in real life */
DECL|enumerator|cff_op_hsbw
name|cff_op_hsbw
block|,
DECL|enumerator|cff_op_closepath
name|cff_op_closepath
block|,
DECL|enumerator|cff_op_callothersubr
name|cff_op_callothersubr
block|,
DECL|enumerator|cff_op_pop
name|cff_op_pop
block|,
DECL|enumerator|cff_op_seac
name|cff_op_seac
block|,
DECL|enumerator|cff_op_sbw
name|cff_op_sbw
block|,
DECL|enumerator|cff_op_setcurrentpoint
name|cff_op_setcurrentpoint
block|,
comment|/* do not remove */
DECL|enumerator|cff_op_max
name|cff_op_max
block|}
DECL|typedef|CFF_Operator
name|CFF_Operator
typedef|;
end_typedef
begin_define
DECL|macro|CFF_COUNT_CHECK_WIDTH
define|#
directive|define
name|CFF_COUNT_CHECK_WIDTH
value|0x80
end_define
begin_define
DECL|macro|CFF_COUNT_EXACT
define|#
directive|define
name|CFF_COUNT_EXACT
value|0x40
end_define
begin_define
DECL|macro|CFF_COUNT_CLEAR_STACK
define|#
directive|define
name|CFF_COUNT_CLEAR_STACK
value|0x20
end_define
begin_comment
comment|/* count values which have the `CFF_COUNT_CHECK_WIDTH' flag set are  */
end_comment
begin_comment
comment|/* used for checking the width and requested numbers of arguments    */
end_comment
begin_comment
comment|/* only; they are set to zero afterwards                             */
end_comment
begin_comment
comment|/* the other two flags are informative only and unused currently     */
end_comment
begin_decl_stmt
DECL|variable|cff_argument_counts
specifier|static
specifier|const
name|FT_Byte
name|cff_argument_counts
index|[]
init|=
block|{
literal|0
block|,
comment|/* unknown */
literal|2
operator||
name|CFF_COUNT_CHECK_WIDTH
operator||
name|CFF_COUNT_EXACT
block|,
comment|/* rmoveto */
literal|1
operator||
name|CFF_COUNT_CHECK_WIDTH
operator||
name|CFF_COUNT_EXACT
block|,
literal|1
operator||
name|CFF_COUNT_CHECK_WIDTH
operator||
name|CFF_COUNT_EXACT
block|,
literal|0
operator||
name|CFF_COUNT_CLEAR_STACK
block|,
comment|/* rlineto */
literal|0
operator||
name|CFF_COUNT_CLEAR_STACK
block|,
literal|0
operator||
name|CFF_COUNT_CLEAR_STACK
block|,
literal|0
operator||
name|CFF_COUNT_CLEAR_STACK
block|,
comment|/* rrcurveto */
literal|0
operator||
name|CFF_COUNT_CLEAR_STACK
block|,
literal|0
operator||
name|CFF_COUNT_CLEAR_STACK
block|,
literal|0
operator||
name|CFF_COUNT_CLEAR_STACK
block|,
literal|0
operator||
name|CFF_COUNT_CLEAR_STACK
block|,
literal|0
operator||
name|CFF_COUNT_CLEAR_STACK
block|,
literal|0
operator||
name|CFF_COUNT_CLEAR_STACK
block|,
literal|13
block|,
comment|/* flex */
literal|7
block|,
literal|9
block|,
literal|11
block|,
literal|0
operator||
name|CFF_COUNT_CHECK_WIDTH
block|,
comment|/* endchar */
literal|2
operator||
name|CFF_COUNT_CHECK_WIDTH
block|,
comment|/* hstem */
literal|2
operator||
name|CFF_COUNT_CHECK_WIDTH
block|,
literal|2
operator||
name|CFF_COUNT_CHECK_WIDTH
block|,
literal|2
operator||
name|CFF_COUNT_CHECK_WIDTH
block|,
literal|0
operator||
name|CFF_COUNT_CHECK_WIDTH
block|,
comment|/* hintmask */
literal|0
operator||
name|CFF_COUNT_CHECK_WIDTH
block|,
comment|/* cntrmask */
literal|0
block|,
comment|/* dotsection */
literal|1
block|,
comment|/* abs */
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|1
block|,
literal|1
block|,
comment|/* blend */
literal|1
block|,
comment|/* drop */
literal|2
block|,
literal|1
block|,
literal|2
block|,
literal|1
block|,
literal|2
block|,
comment|/* put */
literal|1
block|,
literal|4
block|,
literal|3
block|,
literal|2
block|,
comment|/* and */
literal|2
block|,
literal|1
block|,
literal|2
block|,
literal|4
block|,
literal|1
block|,
comment|/* callsubr */
literal|1
block|,
literal|0
block|,
literal|2
block|,
comment|/* hsbw */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|5
block|,
comment|/* seac */
literal|4
block|,
comment|/* sbw */
literal|2
comment|/* setcurrentpoint */
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/**********                                                      *********/
end_comment
begin_comment
comment|/**********                                                      *********/
end_comment
begin_comment
comment|/**********             GENERIC CHARSTRING PARSING               *********/
end_comment
begin_comment
comment|/**********                                                      *********/
end_comment
begin_comment
comment|/**********                                                      *********/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    cff_builder_init                                                   */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Initializes a given glyph builder.                                 */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<InOut>                                                               */
end_comment
begin_comment
comment|/*    builder :: A pointer to the glyph builder to initialize.           */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    face    :: The current face object.                                */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    size    :: The current size object.                                */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    glyph   :: The current glyph object.                               */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    hinting :: Whether hinting is active.                              */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|cff_builder_init
name|cff_builder_init
parameter_list|(
name|CFF_Builder
modifier|*
name|builder
parameter_list|,
name|TT_Face
name|face
parameter_list|,
name|CFF_Size
name|size
parameter_list|,
name|CFF_GlyphSlot
name|glyph
parameter_list|,
name|FT_Bool
name|hinting
parameter_list|)
block|{
name|builder
operator|->
name|path_begun
operator|=
literal|0
expr_stmt|;
name|builder
operator|->
name|load_points
operator|=
literal|1
expr_stmt|;
name|builder
operator|->
name|face
operator|=
name|face
expr_stmt|;
name|builder
operator|->
name|glyph
operator|=
name|glyph
expr_stmt|;
name|builder
operator|->
name|memory
operator|=
name|face
operator|->
name|root
operator|.
name|memory
expr_stmt|;
if|if
condition|(
name|glyph
condition|)
block|{
name|FT_GlyphLoader
name|loader
init|=
name|glyph
operator|->
name|root
operator|.
name|internal
operator|->
name|loader
decl_stmt|;
name|builder
operator|->
name|loader
operator|=
name|loader
expr_stmt|;
name|builder
operator|->
name|base
operator|=
operator|&
name|loader
operator|->
name|base
operator|.
name|outline
expr_stmt|;
name|builder
operator|->
name|current
operator|=
operator|&
name|loader
operator|->
name|current
operator|.
name|outline
expr_stmt|;
name|FT_GlyphLoader_Rewind
argument_list|(
name|loader
argument_list|)
expr_stmt|;
name|builder
operator|->
name|hints_globals
operator|=
literal|0
expr_stmt|;
name|builder
operator|->
name|hints_funcs
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|hinting
operator|&&
name|size
condition|)
block|{
name|CFF_Internal
name|internal
init|=
operator|(
name|CFF_Internal
operator|)
name|size
operator|->
name|root
operator|.
name|internal
decl_stmt|;
name|builder
operator|->
name|hints_globals
operator|=
operator|(
name|void
operator|*
operator|)
name|internal
operator|->
name|topfont
expr_stmt|;
name|builder
operator|->
name|hints_funcs
operator|=
name|glyph
operator|->
name|root
operator|.
name|internal
operator|->
name|glyph_hints
expr_stmt|;
block|}
block|}
name|builder
operator|->
name|pos_x
operator|=
literal|0
expr_stmt|;
name|builder
operator|->
name|pos_y
operator|=
literal|0
expr_stmt|;
name|builder
operator|->
name|left_bearing
operator|.
name|x
operator|=
literal|0
expr_stmt|;
name|builder
operator|->
name|left_bearing
operator|.
name|y
operator|=
literal|0
expr_stmt|;
name|builder
operator|->
name|advance
operator|.
name|x
operator|=
literal|0
expr_stmt|;
name|builder
operator|->
name|advance
operator|.
name|y
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    cff_builder_done                                                   */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Finalizes a given glyph builder.  Its contents can still be used   */
end_comment
begin_comment
comment|/*    after the call, but the function saves important information       */
end_comment
begin_comment
comment|/*    within the corresponding glyph slot.                               */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    builder :: A pointer to the glyph builder to finalize.             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_function
specifier|static
name|void
DECL|function|cff_builder_done
name|cff_builder_done
parameter_list|(
name|CFF_Builder
modifier|*
name|builder
parameter_list|)
block|{
name|CFF_GlyphSlot
name|glyph
init|=
name|builder
operator|->
name|glyph
decl_stmt|;
if|if
condition|(
name|glyph
condition|)
name|glyph
operator|->
name|root
operator|.
name|outline
operator|=
operator|*
name|builder
operator|->
name|base
expr_stmt|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    cff_compute_bias                                                   */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Computes the bias value in dependence of the number of glyph       */
end_comment
begin_comment
comment|/*    subroutines.                                                       */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    in_charstring_type :: The `CharstringType' value of the top DICT   */
end_comment
begin_comment
comment|/*                          dictionary.                                  */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    num_subrs          :: The number of glyph subroutines.             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    The bias value.                                                    */
end_comment
begin_function
specifier|static
name|FT_Int
DECL|function|cff_compute_bias
name|cff_compute_bias
parameter_list|(
name|FT_Int
name|in_charstring_type
parameter_list|,
name|FT_UInt
name|num_subrs
parameter_list|)
block|{
name|FT_Int
name|result
decl_stmt|;
if|if
condition|(
name|in_charstring_type
operator|==
literal|1
condition|)
name|result
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|num_subrs
operator|<
literal|1240
condition|)
name|result
operator|=
literal|107
expr_stmt|;
elseif|else
if|if
condition|(
name|num_subrs
operator|<
literal|33900U
condition|)
name|result
operator|=
literal|1131
expr_stmt|;
else|else
name|result
operator|=
literal|32768U
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    cff_decoder_init                                                   */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Initializes a given glyph decoder.                                 */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<InOut>                                                               */
end_comment
begin_comment
comment|/*    decoder :: A pointer to the glyph builder to initialize.           */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    face      :: The current face object.                              */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    size      :: The current size object.                              */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    slot      :: The current glyph object.                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    hinting   :: Whether hinting is active.                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    hint_mode :: The hinting mode.                                     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|cff_decoder_init
name|cff_decoder_init
argument_list|(
argument|CFF_Decoder*    decoder
argument_list|,
argument|TT_Face         face
argument_list|,
argument|CFF_Size        size
argument_list|,
argument|CFF_GlyphSlot   slot
argument_list|,
argument|FT_Bool         hinting
argument_list|,
argument|FT_Render_Mode  hint_mode
argument_list|)
end_macro
begin_block
block|{
name|CFF_Font
name|cff
init|=
operator|(
name|CFF_Font
operator|)
name|face
operator|->
name|extra
operator|.
name|data
decl_stmt|;
comment|/* clear everything */
name|FT_MEM_ZERO
argument_list|(
name|decoder
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|decoder
argument_list|)
argument_list|)
expr_stmt|;
comment|/* initialize builder */
name|cff_builder_init
argument_list|(
operator|&
name|decoder
operator|->
name|builder
argument_list|,
name|face
argument_list|,
name|size
argument_list|,
name|slot
argument_list|,
name|hinting
argument_list|)
expr_stmt|;
comment|/* initialize Type2 decoder */
name|decoder
operator|->
name|cff
operator|=
name|cff
expr_stmt|;
name|decoder
operator|->
name|num_globals
operator|=
name|cff
operator|->
name|num_global_subrs
expr_stmt|;
name|decoder
operator|->
name|globals
operator|=
name|cff
operator|->
name|global_subrs
expr_stmt|;
name|decoder
operator|->
name|globals_bias
operator|=
name|cff_compute_bias
argument_list|(
name|cff
operator|->
name|top_font
operator|.
name|font_dict
operator|.
name|charstring_type
argument_list|,
name|decoder
operator|->
name|num_globals
argument_list|)
expr_stmt|;
name|decoder
operator|->
name|hint_mode
operator|=
name|hint_mode
expr_stmt|;
block|}
end_block
begin_comment
comment|/* this function is used to select the subfont */
end_comment
begin_comment
comment|/* and the locals subrs array                  */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|cff_decoder_prepare
argument_list|(
argument|CFF_Decoder*  decoder
argument_list|,
argument|CFF_Size      size
argument_list|,
argument|FT_UInt       glyph_index
argument_list|)
end_macro
begin_block
block|{
name|CFF_Builder
modifier|*
name|builder
init|=
operator|&
name|decoder
operator|->
name|builder
decl_stmt|;
name|CFF_Font
name|cff
init|=
operator|(
name|CFF_Font
operator|)
name|builder
operator|->
name|face
operator|->
name|extra
operator|.
name|data
decl_stmt|;
name|CFF_SubFont
name|sub
init|=
operator|&
name|cff
operator|->
name|top_font
decl_stmt|;
name|FT_Error
name|error
init|=
name|CFF_Err_Ok
decl_stmt|;
comment|/* manage CID fonts */
if|if
condition|(
name|cff
operator|->
name|num_subfonts
condition|)
block|{
name|FT_Byte
name|fd_index
init|=
name|cff_fd_select_get
argument_list|(
operator|&
name|cff
operator|->
name|fd_select
argument_list|,
name|glyph_index
argument_list|)
decl_stmt|;
if|if
condition|(
name|fd_index
operator|>=
name|cff
operator|->
name|num_subfonts
condition|)
block|{
name|FT_TRACE4
argument_list|(
operator|(
literal|"cff_decoder_prepare: invalid CID subfont index\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|CFF_Err_Invalid_File_Format
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|FT_TRACE4
argument_list|(
operator|(
literal|"glyph index %d (subfont %d):\n"
operator|,
name|glyph_index
operator|,
name|fd_index
operator|)
argument_list|)
expr_stmt|;
name|sub
operator|=
name|cff
operator|->
name|subfonts
index|[
name|fd_index
index|]
expr_stmt|;
if|if
condition|(
name|builder
operator|->
name|hints_funcs
operator|&&
name|size
condition|)
block|{
name|CFF_Internal
name|internal
init|=
operator|(
name|CFF_Internal
operator|)
name|size
operator|->
name|root
operator|.
name|internal
decl_stmt|;
comment|/* for CFFs without subfonts, this value has already been set */
name|builder
operator|->
name|hints_globals
operator|=
operator|(
name|void
operator|*
operator|)
name|internal
operator|->
name|subfonts
index|[
name|fd_index
index|]
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|FT_DEBUG_LEVEL_TRACE
else|else
name|FT_TRACE4
argument_list|(
operator|(
literal|"glyph index %d:\n"
operator|,
name|glyph_index
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|decoder
operator|->
name|num_locals
operator|=
name|sub
operator|->
name|num_local_subrs
expr_stmt|;
name|decoder
operator|->
name|locals
operator|=
name|sub
operator|->
name|local_subrs
expr_stmt|;
name|decoder
operator|->
name|locals_bias
operator|=
name|cff_compute_bias
argument_list|(
name|decoder
operator|->
name|cff
operator|->
name|top_font
operator|.
name|font_dict
operator|.
name|charstring_type
argument_list|,
name|decoder
operator|->
name|num_locals
argument_list|)
expr_stmt|;
name|decoder
operator|->
name|glyph_width
operator|=
name|sub
operator|->
name|private_dict
operator|.
name|default_width
expr_stmt|;
name|decoder
operator|->
name|nominal_width
operator|=
name|sub
operator|->
name|private_dict
operator|.
name|nominal_width
expr_stmt|;
name|Exit
label|:
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/* check that there is enough space for `count' more points */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|check_points
name|check_points
parameter_list|(
name|CFF_Builder
modifier|*
name|builder
parameter_list|,
name|FT_Int
name|count
parameter_list|)
block|{
return|return
name|FT_GLYPHLOADER_CHECK_POINTS
argument_list|(
name|builder
operator|->
name|loader
argument_list|,
name|count
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/* add a new point, do not check space */
end_comment
begin_function
specifier|static
name|void
DECL|function|cff_builder_add_point
name|cff_builder_add_point
parameter_list|(
name|CFF_Builder
modifier|*
name|builder
parameter_list|,
name|FT_Pos
name|x
parameter_list|,
name|FT_Pos
name|y
parameter_list|,
name|FT_Byte
name|flag
parameter_list|)
block|{
name|FT_Outline
modifier|*
name|outline
init|=
name|builder
operator|->
name|current
decl_stmt|;
if|if
condition|(
name|builder
operator|->
name|load_points
condition|)
block|{
name|FT_Vector
modifier|*
name|point
init|=
name|outline
operator|->
name|points
operator|+
name|outline
operator|->
name|n_points
decl_stmt|;
name|FT_Byte
modifier|*
name|control
init|=
operator|(
name|FT_Byte
operator|*
operator|)
name|outline
operator|->
name|tags
operator|+
name|outline
operator|->
name|n_points
decl_stmt|;
name|point
operator|->
name|x
operator|=
name|x
operator|>>
literal|16
expr_stmt|;
name|point
operator|->
name|y
operator|=
name|y
operator|>>
literal|16
expr_stmt|;
operator|*
name|control
operator|=
call|(
name|FT_Byte
call|)
argument_list|(
name|flag
condition|?
name|FT_CURVE_TAG_ON
else|:
name|FT_CURVE_TAG_CUBIC
argument_list|)
expr_stmt|;
block|}
name|outline
operator|->
name|n_points
operator|++
expr_stmt|;
block|}
end_function
begin_comment
comment|/* check space for a new on-curve point, then add it */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|cff_builder_add_point1
name|cff_builder_add_point1
parameter_list|(
name|CFF_Builder
modifier|*
name|builder
parameter_list|,
name|FT_Pos
name|x
parameter_list|,
name|FT_Pos
name|y
parameter_list|)
block|{
name|FT_Error
name|error
decl_stmt|;
name|error
operator|=
name|check_points
argument_list|(
name|builder
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|cff_builder_add_point
argument_list|(
name|builder
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_comment
comment|/* check space for a new contour, then add it */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|cff_builder_add_contour
name|cff_builder_add_contour
parameter_list|(
name|CFF_Builder
modifier|*
name|builder
parameter_list|)
block|{
name|FT_Outline
modifier|*
name|outline
init|=
name|builder
operator|->
name|current
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
if|if
condition|(
operator|!
name|builder
operator|->
name|load_points
condition|)
block|{
name|outline
operator|->
name|n_contours
operator|++
expr_stmt|;
return|return
name|CFF_Err_Ok
return|;
block|}
name|error
operator|=
name|FT_GLYPHLOADER_CHECK_POINTS
argument_list|(
name|builder
operator|->
name|loader
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
if|if
condition|(
name|outline
operator|->
name|n_contours
operator|>
literal|0
condition|)
name|outline
operator|->
name|contours
index|[
name|outline
operator|->
name|n_contours
operator|-
literal|1
index|]
operator|=
call|(
name|short
call|)
argument_list|(
name|outline
operator|->
name|n_points
operator|-
literal|1
argument_list|)
expr_stmt|;
name|outline
operator|->
name|n_contours
operator|++
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function
begin_comment
comment|/* if a path was begun, add its first on-curve point */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|cff_builder_start_point
name|cff_builder_start_point
parameter_list|(
name|CFF_Builder
modifier|*
name|builder
parameter_list|,
name|FT_Pos
name|x
parameter_list|,
name|FT_Pos
name|y
parameter_list|)
block|{
name|FT_Error
name|error
init|=
name|CFF_Err_Ok
decl_stmt|;
comment|/* test whether we are building a new contour */
if|if
condition|(
operator|!
name|builder
operator|->
name|path_begun
condition|)
block|{
name|builder
operator|->
name|path_begun
operator|=
literal|1
expr_stmt|;
name|error
operator|=
name|cff_builder_add_contour
argument_list|(
name|builder
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|cff_builder_add_point1
argument_list|(
name|builder
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function
begin_comment
comment|/* close the current contour */
end_comment
begin_function
specifier|static
name|void
DECL|function|cff_builder_close_contour
name|cff_builder_close_contour
parameter_list|(
name|CFF_Builder
modifier|*
name|builder
parameter_list|)
block|{
name|FT_Outline
modifier|*
name|outline
init|=
name|builder
operator|->
name|current
decl_stmt|;
name|FT_Int
name|first
decl_stmt|;
if|if
condition|(
operator|!
name|outline
condition|)
return|return;
name|first
operator|=
name|outline
operator|->
name|n_contours
operator|<=
literal|1
condition|?
literal|0
else|:
name|outline
operator|->
name|contours
index|[
name|outline
operator|->
name|n_contours
operator|-
literal|2
index|]
operator|+
literal|1
expr_stmt|;
comment|/* We must not include the last point in the path if it */
comment|/* is located on the first point.                       */
if|if
condition|(
name|outline
operator|->
name|n_points
operator|>
literal|1
condition|)
block|{
name|FT_Vector
modifier|*
name|p1
init|=
name|outline
operator|->
name|points
operator|+
name|first
decl_stmt|;
name|FT_Vector
modifier|*
name|p2
init|=
name|outline
operator|->
name|points
operator|+
name|outline
operator|->
name|n_points
operator|-
literal|1
decl_stmt|;
name|FT_Byte
modifier|*
name|control
init|=
operator|(
name|FT_Byte
operator|*
operator|)
name|outline
operator|->
name|tags
operator|+
name|outline
operator|->
name|n_points
operator|-
literal|1
decl_stmt|;
comment|/* `delete' last point only if it coincides with the first    */
comment|/* point and if it is not a control point (which can happen). */
if|if
condition|(
name|p1
operator|->
name|x
operator|==
name|p2
operator|->
name|x
operator|&&
name|p1
operator|->
name|y
operator|==
name|p2
operator|->
name|y
condition|)
if|if
condition|(
operator|*
name|control
operator|==
name|FT_CURVE_TAG_ON
condition|)
name|outline
operator|->
name|n_points
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|outline
operator|->
name|n_contours
operator|>
literal|0
condition|)
block|{
comment|/* Don't add contours only consisting of one point, i.e., */
comment|/* check whether begin point and last point are the same. */
if|if
condition|(
name|first
operator|==
name|outline
operator|->
name|n_points
operator|-
literal|1
condition|)
block|{
name|outline
operator|->
name|n_contours
operator|--
expr_stmt|;
name|outline
operator|->
name|n_points
operator|--
expr_stmt|;
block|}
else|else
name|outline
operator|->
name|contours
index|[
name|outline
operator|->
name|n_contours
operator|-
literal|1
index|]
operator|=
call|(
name|short
call|)
argument_list|(
name|outline
operator|->
name|n_points
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
specifier|static
name|FT_Int
DECL|function|cff_lookup_glyph_by_stdcharcode
name|cff_lookup_glyph_by_stdcharcode
parameter_list|(
name|CFF_Font
name|cff
parameter_list|,
name|FT_Int
name|charcode
parameter_list|)
block|{
name|FT_UInt
name|n
decl_stmt|;
name|FT_UShort
name|glyph_sid
decl_stmt|;
comment|/* CID-keyed fonts don't have glyph names */
if|if
condition|(
operator|!
name|cff
operator|->
name|charset
operator|.
name|sids
condition|)
return|return
operator|-
literal|1
return|;
comment|/* check range of standard char code */
if|if
condition|(
name|charcode
operator|<
literal|0
operator|||
name|charcode
operator|>
literal|255
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Get code to SID mapping from `cff_standard_encoding'. */
name|glyph_sid
operator|=
name|cff_get_standard_encoding
argument_list|(
operator|(
name|FT_UInt
operator|)
name|charcode
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|cff
operator|->
name|num_glyphs
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|cff
operator|->
name|charset
operator|.
name|sids
index|[
name|n
index|]
operator|==
name|glyph_sid
condition|)
return|return
name|n
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|cff_get_glyph_data
name|cff_get_glyph_data
parameter_list|(
name|TT_Face
name|face
parameter_list|,
name|FT_UInt
name|glyph_index
parameter_list|,
name|FT_Byte
modifier|*
modifier|*
name|pointer
parameter_list|,
name|FT_ULong
modifier|*
name|length
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|FT_CONFIG_OPTION_INCREMENTAL
comment|/* For incremental fonts get the character data using the */
comment|/* callback function.                                     */
if|if
condition|(
name|face
operator|->
name|root
operator|.
name|internal
operator|->
name|incremental_interface
condition|)
block|{
name|FT_Data
name|data
decl_stmt|;
name|FT_Error
name|error
init|=
name|face
operator|->
name|root
operator|.
name|internal
operator|->
name|incremental_interface
operator|->
name|funcs
operator|->
name|get_glyph_data
argument_list|(
name|face
operator|->
name|root
operator|.
name|internal
operator|->
name|incremental_interface
operator|->
name|object
argument_list|,
name|glyph_index
argument_list|,
operator|&
name|data
argument_list|)
decl_stmt|;
operator|*
name|pointer
operator|=
operator|(
name|FT_Byte
operator|*
operator|)
name|data
operator|.
name|pointer
expr_stmt|;
operator|*
name|length
operator|=
name|data
operator|.
name|length
expr_stmt|;
return|return
name|error
return|;
block|}
else|else
endif|#
directive|endif
comment|/* FT_CONFIG_OPTION_INCREMENTAL */
block|{
name|CFF_Font
name|cff
init|=
call|(
name|CFF_Font
call|)
argument_list|(
name|face
operator|->
name|extra
operator|.
name|data
argument_list|)
decl_stmt|;
return|return
name|cff_index_access_element
argument_list|(
operator|&
name|cff
operator|->
name|charstrings_index
argument_list|,
name|glyph_index
argument_list|,
name|pointer
argument_list|,
name|length
argument_list|)
return|;
block|}
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|cff_free_glyph_data
name|cff_free_glyph_data
parameter_list|(
name|TT_Face
name|face
parameter_list|,
name|FT_Byte
modifier|*
modifier|*
name|pointer
parameter_list|,
name|FT_ULong
name|length
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|FT_CONFIG_OPTION_INCREMENTAL
name|FT_UNUSED
argument_list|(
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|FT_CONFIG_OPTION_INCREMENTAL
comment|/* For incremental fonts get the character data using the */
comment|/* callback function.                                     */
if|if
condition|(
name|face
operator|->
name|root
operator|.
name|internal
operator|->
name|incremental_interface
condition|)
block|{
name|FT_Data
name|data
decl_stmt|;
name|data
operator|.
name|pointer
operator|=
operator|*
name|pointer
expr_stmt|;
name|data
operator|.
name|length
operator|=
name|length
expr_stmt|;
name|face
operator|->
name|root
operator|.
name|internal
operator|->
name|incremental_interface
operator|->
name|funcs
operator|->
name|free_glyph_data
argument_list|(
name|face
operator|->
name|root
operator|.
name|internal
operator|->
name|incremental_interface
operator|->
name|object
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* FT_CONFIG_OPTION_INCREMENTAL */
block|{
name|CFF_Font
name|cff
init|=
call|(
name|CFF_Font
call|)
argument_list|(
name|face
operator|->
name|extra
operator|.
name|data
argument_list|)
decl_stmt|;
name|cff_index_forget_element
argument_list|(
operator|&
name|cff
operator|->
name|charstrings_index
argument_list|,
name|pointer
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|cff_operator_seac
name|cff_operator_seac
parameter_list|(
name|CFF_Decoder
modifier|*
name|decoder
parameter_list|,
name|FT_Pos
name|asb
parameter_list|,
name|FT_Pos
name|adx
parameter_list|,
name|FT_Pos
name|ady
parameter_list|,
name|FT_Int
name|bchar
parameter_list|,
name|FT_Int
name|achar
parameter_list|)
block|{
name|FT_Error
name|error
decl_stmt|;
name|CFF_Builder
modifier|*
name|builder
init|=
operator|&
name|decoder
operator|->
name|builder
decl_stmt|;
name|FT_Int
name|bchar_index
decl_stmt|,
name|achar_index
decl_stmt|;
name|TT_Face
name|face
init|=
name|decoder
operator|->
name|builder
operator|.
name|face
decl_stmt|;
name|FT_Vector
name|left_bearing
decl_stmt|,
name|advance
decl_stmt|;
name|FT_Byte
modifier|*
name|charstring
decl_stmt|;
name|FT_ULong
name|charstring_len
decl_stmt|;
name|FT_Pos
name|glyph_width
decl_stmt|;
if|if
condition|(
name|decoder
operator|->
name|seac
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"cff_operator_seac: invalid nested seac\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|CFF_Err_Syntax_Error
return|;
block|}
name|adx
operator|+=
name|decoder
operator|->
name|builder
operator|.
name|left_bearing
operator|.
name|x
expr_stmt|;
name|ady
operator|+=
name|decoder
operator|->
name|builder
operator|.
name|left_bearing
operator|.
name|y
expr_stmt|;
ifdef|#
directive|ifdef
name|FT_CONFIG_OPTION_INCREMENTAL
comment|/* Incremental fonts don't necessarily have valid charsets.        */
comment|/* They use the character code, not the glyph index, in this case. */
if|if
condition|(
name|face
operator|->
name|root
operator|.
name|internal
operator|->
name|incremental_interface
condition|)
block|{
name|bchar_index
operator|=
name|bchar
expr_stmt|;
name|achar_index
operator|=
name|achar
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* FT_CONFIG_OPTION_INCREMENTAL */
block|{
name|CFF_Font
name|cff
init|=
call|(
name|CFF_Font
call|)
argument_list|(
name|face
operator|->
name|extra
operator|.
name|data
argument_list|)
decl_stmt|;
name|bchar_index
operator|=
name|cff_lookup_glyph_by_stdcharcode
argument_list|(
name|cff
argument_list|,
name|bchar
argument_list|)
expr_stmt|;
name|achar_index
operator|=
name|cff_lookup_glyph_by_stdcharcode
argument_list|(
name|cff
argument_list|,
name|achar
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bchar_index
operator|<
literal|0
operator|||
name|achar_index
operator|<
literal|0
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"cff_operator_seac:"
literal|" invalid seac character code arguments\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|CFF_Err_Syntax_Error
return|;
block|}
comment|/* If we are trying to load a composite glyph, do not load the */
comment|/* accent character and return the array of subglyphs.         */
if|if
condition|(
name|builder
operator|->
name|no_recurse
condition|)
block|{
name|FT_GlyphSlot
name|glyph
init|=
operator|(
name|FT_GlyphSlot
operator|)
name|builder
operator|->
name|glyph
decl_stmt|;
name|FT_GlyphLoader
name|loader
init|=
name|glyph
operator|->
name|internal
operator|->
name|loader
decl_stmt|;
name|FT_SubGlyph
name|subg
decl_stmt|;
comment|/* reallocate subglyph array if necessary */
name|error
operator|=
name|FT_GlyphLoader_CheckSubGlyphs
argument_list|(
name|loader
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|subg
operator|=
name|loader
operator|->
name|current
operator|.
name|subglyphs
expr_stmt|;
comment|/* subglyph 0 = base character */
name|subg
operator|->
name|index
operator|=
name|bchar_index
expr_stmt|;
name|subg
operator|->
name|flags
operator|=
name|FT_SUBGLYPH_FLAG_ARGS_ARE_XY_VALUES
operator||
name|FT_SUBGLYPH_FLAG_USE_MY_METRICS
expr_stmt|;
name|subg
operator|->
name|arg1
operator|=
literal|0
expr_stmt|;
name|subg
operator|->
name|arg2
operator|=
literal|0
expr_stmt|;
name|subg
operator|++
expr_stmt|;
comment|/* subglyph 1 = accent character */
name|subg
operator|->
name|index
operator|=
name|achar_index
expr_stmt|;
name|subg
operator|->
name|flags
operator|=
name|FT_SUBGLYPH_FLAG_ARGS_ARE_XY_VALUES
expr_stmt|;
name|subg
operator|->
name|arg1
operator|=
call|(
name|FT_Int
call|)
argument_list|(
name|adx
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|subg
operator|->
name|arg2
operator|=
call|(
name|FT_Int
call|)
argument_list|(
name|ady
operator|>>
literal|16
argument_list|)
expr_stmt|;
comment|/* set up remaining glyph fields */
name|glyph
operator|->
name|num_subglyphs
operator|=
literal|2
expr_stmt|;
name|glyph
operator|->
name|subglyphs
operator|=
name|loader
operator|->
name|base
operator|.
name|subglyphs
expr_stmt|;
name|glyph
operator|->
name|format
operator|=
name|FT_GLYPH_FORMAT_COMPOSITE
expr_stmt|;
name|loader
operator|->
name|current
operator|.
name|num_subglyphs
operator|=
literal|2
expr_stmt|;
block|}
name|FT_GlyphLoader_Prepare
argument_list|(
name|builder
operator|->
name|loader
argument_list|)
expr_stmt|;
comment|/* First load `bchar' in builder */
name|error
operator|=
name|cff_get_glyph_data
argument_list|(
name|face
argument_list|,
name|bchar_index
argument_list|,
operator|&
name|charstring
argument_list|,
operator|&
name|charstring_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
comment|/* the seac operator must not be nested */
name|decoder
operator|->
name|seac
operator|=
name|TRUE
expr_stmt|;
name|error
operator|=
name|cff_decoder_parse_charstrings
argument_list|(
name|decoder
argument_list|,
name|charstring
argument_list|,
name|charstring_len
argument_list|)
expr_stmt|;
name|decoder
operator|->
name|seac
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|cff_free_glyph_data
argument_list|(
name|face
argument_list|,
operator|&
name|charstring
argument_list|,
name|charstring_len
argument_list|)
expr_stmt|;
block|}
comment|/* Save the left bearing, advance and glyph width of the base */
comment|/* character as they will be erased by the next load.         */
name|left_bearing
operator|=
name|builder
operator|->
name|left_bearing
expr_stmt|;
name|advance
operator|=
name|builder
operator|->
name|advance
expr_stmt|;
name|glyph_width
operator|=
name|decoder
operator|->
name|glyph_width
expr_stmt|;
name|builder
operator|->
name|left_bearing
operator|.
name|x
operator|=
literal|0
expr_stmt|;
name|builder
operator|->
name|left_bearing
operator|.
name|y
operator|=
literal|0
expr_stmt|;
name|builder
operator|->
name|pos_x
operator|=
name|adx
operator|-
name|asb
expr_stmt|;
name|builder
operator|->
name|pos_y
operator|=
name|ady
expr_stmt|;
comment|/* Now load `achar' on top of the base outline. */
name|error
operator|=
name|cff_get_glyph_data
argument_list|(
name|face
argument_list|,
name|achar_index
argument_list|,
operator|&
name|charstring
argument_list|,
operator|&
name|charstring_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
comment|/* the seac operator must not be nested */
name|decoder
operator|->
name|seac
operator|=
name|TRUE
expr_stmt|;
name|error
operator|=
name|cff_decoder_parse_charstrings
argument_list|(
name|decoder
argument_list|,
name|charstring
argument_list|,
name|charstring_len
argument_list|)
expr_stmt|;
name|decoder
operator|->
name|seac
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|cff_free_glyph_data
argument_list|(
name|face
argument_list|,
operator|&
name|charstring
argument_list|,
name|charstring_len
argument_list|)
expr_stmt|;
block|}
comment|/* Restore the left side bearing, advance and glyph width */
comment|/* of the base character.                                 */
name|builder
operator|->
name|left_bearing
operator|=
name|left_bearing
expr_stmt|;
name|builder
operator|->
name|advance
operator|=
name|advance
expr_stmt|;
name|decoder
operator|->
name|glyph_width
operator|=
name|glyph_width
expr_stmt|;
name|builder
operator|->
name|pos_x
operator|=
literal|0
expr_stmt|;
name|builder
operator|->
name|pos_y
operator|=
literal|0
expr_stmt|;
name|Exit
label|:
return|return
name|error
return|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    cff_decoder_parse_charstrings                                      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    Parses a given Type 2 charstrings program.                         */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<InOut>                                                               */
end_comment
begin_comment
comment|/*    decoder         :: The current Type 1 decoder.                     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    charstring_base :: The base of the charstring stream.              */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    charstring_len  :: The length in bytes of the charstring stream.   */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    FreeType error code.  0 means success.                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|cff_decoder_parse_charstrings
argument_list|(
argument|CFF_Decoder*  decoder
argument_list|,
argument|FT_Byte*      charstring_base
argument_list|,
argument|FT_ULong      charstring_len
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
decl_stmt|;
name|CFF_Decoder_Zone
modifier|*
name|zone
decl_stmt|;
name|FT_Byte
modifier|*
name|ip
decl_stmt|;
name|FT_Byte
modifier|*
name|limit
decl_stmt|;
name|CFF_Builder
modifier|*
name|builder
init|=
operator|&
name|decoder
operator|->
name|builder
decl_stmt|;
name|FT_Pos
name|x
decl_stmt|,
name|y
decl_stmt|;
name|FT_Fixed
name|seed
decl_stmt|;
name|FT_Fixed
modifier|*
name|stack
decl_stmt|;
name|FT_Int
name|charstring_type
init|=
name|decoder
operator|->
name|cff
operator|->
name|top_font
operator|.
name|font_dict
operator|.
name|charstring_type
decl_stmt|;
name|T2_Hints_Funcs
name|hinter
decl_stmt|;
comment|/* set default width */
name|decoder
operator|->
name|num_hints
operator|=
literal|0
expr_stmt|;
name|decoder
operator|->
name|read_width
operator|=
literal|1
expr_stmt|;
comment|/* compute random seed from stack address of parameter */
name|seed
operator|=
call|(
name|FT_Fixed
call|)
argument_list|(
operator|(
call|(
name|FT_PtrDist
call|)
argument_list|(
name|char
operator|*
argument_list|)
operator|&
name|seed
operator|^
call|(
name|FT_PtrDist
call|)
argument_list|(
name|char
operator|*
argument_list|)
operator|&
name|decoder
operator|^
call|(
name|FT_PtrDist
call|)
argument_list|(
name|char
operator|*
argument_list|)
operator|&
name|charstring_base
operator|)
operator|&
name|FT_ULONG_MAX
argument_list|)
expr_stmt|;
name|seed
operator|=
operator|(
name|seed
operator|^
operator|(
name|seed
operator|>>
literal|10
operator|)
operator|^
operator|(
name|seed
operator|>>
literal|20
operator|)
operator|)
operator|&
literal|0xFFFFL
expr_stmt|;
if|if
condition|(
name|seed
operator|==
literal|0
condition|)
name|seed
operator|=
literal|0x7384
expr_stmt|;
comment|/* initialize the decoder */
name|decoder
operator|->
name|top
operator|=
name|decoder
operator|->
name|stack
expr_stmt|;
name|decoder
operator|->
name|zone
operator|=
name|decoder
operator|->
name|zones
expr_stmt|;
name|zone
operator|=
name|decoder
operator|->
name|zones
expr_stmt|;
name|stack
operator|=
name|decoder
operator|->
name|top
expr_stmt|;
name|hinter
operator|=
operator|(
name|T2_Hints_Funcs
operator|)
name|builder
operator|->
name|hints_funcs
expr_stmt|;
name|builder
operator|->
name|path_begun
operator|=
literal|0
expr_stmt|;
name|zone
operator|->
name|base
operator|=
name|charstring_base
expr_stmt|;
name|limit
operator|=
name|zone
operator|->
name|limit
operator|=
name|charstring_base
operator|+
name|charstring_len
expr_stmt|;
name|ip
operator|=
name|zone
operator|->
name|cursor
operator|=
name|zone
operator|->
name|base
expr_stmt|;
name|error
operator|=
name|CFF_Err_Ok
expr_stmt|;
name|x
operator|=
name|builder
operator|->
name|pos_x
expr_stmt|;
name|y
operator|=
name|builder
operator|->
name|pos_y
expr_stmt|;
comment|/* begin hints recording session, if any */
if|if
condition|(
name|hinter
condition|)
name|hinter
operator|->
name|open
argument_list|(
name|hinter
operator|->
name|hints
argument_list|)
expr_stmt|;
comment|/* now execute loop */
while|while
condition|(
name|ip
operator|<
name|limit
condition|)
block|{
name|CFF_Operator
name|op
decl_stmt|;
name|FT_Byte
name|v
decl_stmt|;
comment|/********************************************************************/
comment|/*                                                                  */
comment|/* Decode operator or operand                                       */
comment|/*                                                                  */
name|v
operator|=
operator|*
name|ip
operator|++
expr_stmt|;
if|if
condition|(
name|v
operator|>=
literal|32
operator|||
name|v
operator|==
literal|28
condition|)
block|{
name|FT_Int
name|shift
init|=
literal|16
decl_stmt|;
name|FT_Int32
name|val
decl_stmt|;
comment|/* this is an operand, push it on the stack */
if|if
condition|(
name|v
operator|==
literal|28
condition|)
block|{
if|if
condition|(
name|ip
operator|+
literal|1
operator|>=
name|limit
condition|)
goto|goto
name|Syntax_Error
goto|;
name|val
operator|=
call|(
name|FT_Short
call|)
argument_list|(
operator|(
operator|(
name|FT_Short
operator|)
name|ip
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator||
name|ip
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ip
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|v
operator|<
literal|247
condition|)
name|val
operator|=
operator|(
name|FT_Int32
operator|)
name|v
operator|-
literal|139
expr_stmt|;
elseif|else
if|if
condition|(
name|v
operator|<
literal|251
condition|)
block|{
if|if
condition|(
name|ip
operator|>=
name|limit
condition|)
goto|goto
name|Syntax_Error
goto|;
name|val
operator|=
operator|(
operator|(
name|FT_Int32
operator|)
name|v
operator|-
literal|247
operator|)
operator|*
literal|256
operator|+
operator|*
name|ip
operator|++
operator|+
literal|108
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|v
operator|<
literal|255
condition|)
block|{
if|if
condition|(
name|ip
operator|>=
name|limit
condition|)
goto|goto
name|Syntax_Error
goto|;
name|val
operator|=
operator|-
operator|(
operator|(
name|FT_Int32
operator|)
name|v
operator|-
literal|251
operator|)
operator|*
literal|256
operator|-
operator|*
name|ip
operator|++
operator|-
literal|108
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ip
operator|+
literal|3
operator|>=
name|limit
condition|)
goto|goto
name|Syntax_Error
goto|;
name|val
operator|=
operator|(
operator|(
name|FT_Int32
operator|)
name|ip
index|[
literal|0
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
name|FT_Int32
operator|)
name|ip
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|FT_Int32
operator|)
name|ip
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator||
name|ip
index|[
literal|3
index|]
expr_stmt|;
name|ip
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|charstring_type
operator|==
literal|2
condition|)
name|shift
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|decoder
operator|->
name|top
operator|-
name|stack
operator|>=
name|CFF_MAX_OPERANDS
condition|)
goto|goto
name|Stack_Overflow
goto|;
name|val
operator|<<=
name|shift
expr_stmt|;
operator|*
name|decoder
operator|->
name|top
operator|++
operator|=
name|val
expr_stmt|;
ifdef|#
directive|ifdef
name|FT_DEBUG_LEVEL_TRACE
if|if
condition|(
operator|!
operator|(
name|val
operator|&
literal|0xFFFFL
operator|)
condition|)
name|FT_TRACE4
argument_list|(
operator|(
literal|" %ld"
operator|,
call|(
name|FT_Int32
call|)
argument_list|(
name|val
operator|>>
literal|16
argument_list|)
operator|)
argument_list|)
expr_stmt|;
else|else
name|FT_TRACE4
argument_list|(
operator|(
literal|" %.2f"
operator|,
name|val
operator|/
literal|65536.0
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
comment|/* The specification says that normally arguments are to be taken */
comment|/* from the bottom of the stack.  However, this seems not to be   */
comment|/* correct, at least for Acroread 7.0.8 on GNU/Linux: It pops the */
comment|/* arguments similar to a PS interpreter.                         */
name|FT_Fixed
modifier|*
name|args
init|=
name|decoder
operator|->
name|top
decl_stmt|;
name|FT_Int
name|num_args
init|=
call|(
name|FT_Int
call|)
argument_list|(
name|args
operator|-
name|decoder
operator|->
name|stack
argument_list|)
decl_stmt|;
name|FT_Int
name|req_args
decl_stmt|;
comment|/* find operator */
name|op
operator|=
name|cff_op_unknown
expr_stmt|;
switch|switch
condition|(
name|v
condition|)
block|{
case|case
literal|1
case|:
name|op
operator|=
name|cff_op_hstem
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|op
operator|=
name|cff_op_vstem
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|op
operator|=
name|cff_op_vmoveto
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|op
operator|=
name|cff_op_rlineto
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|op
operator|=
name|cff_op_hlineto
expr_stmt|;
break|break;
case|case
literal|7
case|:
name|op
operator|=
name|cff_op_vlineto
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|op
operator|=
name|cff_op_rrcurveto
expr_stmt|;
break|break;
case|case
literal|9
case|:
name|op
operator|=
name|cff_op_closepath
expr_stmt|;
break|break;
case|case
literal|10
case|:
name|op
operator|=
name|cff_op_callsubr
expr_stmt|;
break|break;
case|case
literal|11
case|:
name|op
operator|=
name|cff_op_return
expr_stmt|;
break|break;
case|case
literal|12
case|:
block|{
if|if
condition|(
name|ip
operator|>=
name|limit
condition|)
goto|goto
name|Syntax_Error
goto|;
name|v
operator|=
operator|*
name|ip
operator|++
expr_stmt|;
switch|switch
condition|(
name|v
condition|)
block|{
case|case
literal|0
case|:
name|op
operator|=
name|cff_op_dotsection
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* this is actually the Type1 vstem3 operator */
name|op
operator|=
name|cff_op_vstem
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* this is actually the Type1 hstem3 operator */
name|op
operator|=
name|cff_op_hstem
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|op
operator|=
name|cff_op_and
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|op
operator|=
name|cff_op_or
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|op
operator|=
name|cff_op_not
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|op
operator|=
name|cff_op_seac
expr_stmt|;
break|break;
case|case
literal|7
case|:
name|op
operator|=
name|cff_op_sbw
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|op
operator|=
name|cff_op_store
expr_stmt|;
break|break;
case|case
literal|9
case|:
name|op
operator|=
name|cff_op_abs
expr_stmt|;
break|break;
case|case
literal|10
case|:
name|op
operator|=
name|cff_op_add
expr_stmt|;
break|break;
case|case
literal|11
case|:
name|op
operator|=
name|cff_op_sub
expr_stmt|;
break|break;
case|case
literal|12
case|:
name|op
operator|=
name|cff_op_div
expr_stmt|;
break|break;
case|case
literal|13
case|:
name|op
operator|=
name|cff_op_load
expr_stmt|;
break|break;
case|case
literal|14
case|:
name|op
operator|=
name|cff_op_neg
expr_stmt|;
break|break;
case|case
literal|15
case|:
name|op
operator|=
name|cff_op_eq
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|op
operator|=
name|cff_op_callothersubr
expr_stmt|;
break|break;
case|case
literal|17
case|:
name|op
operator|=
name|cff_op_pop
expr_stmt|;
break|break;
case|case
literal|18
case|:
name|op
operator|=
name|cff_op_drop
expr_stmt|;
break|break;
case|case
literal|20
case|:
name|op
operator|=
name|cff_op_put
expr_stmt|;
break|break;
case|case
literal|21
case|:
name|op
operator|=
name|cff_op_get
expr_stmt|;
break|break;
case|case
literal|22
case|:
name|op
operator|=
name|cff_op_ifelse
expr_stmt|;
break|break;
case|case
literal|23
case|:
name|op
operator|=
name|cff_op_random
expr_stmt|;
break|break;
case|case
literal|24
case|:
name|op
operator|=
name|cff_op_mul
expr_stmt|;
break|break;
case|case
literal|26
case|:
name|op
operator|=
name|cff_op_sqrt
expr_stmt|;
break|break;
case|case
literal|27
case|:
name|op
operator|=
name|cff_op_dup
expr_stmt|;
break|break;
case|case
literal|28
case|:
name|op
operator|=
name|cff_op_exch
expr_stmt|;
break|break;
case|case
literal|29
case|:
name|op
operator|=
name|cff_op_index
expr_stmt|;
break|break;
case|case
literal|30
case|:
name|op
operator|=
name|cff_op_roll
expr_stmt|;
break|break;
case|case
literal|33
case|:
name|op
operator|=
name|cff_op_setcurrentpoint
expr_stmt|;
break|break;
case|case
literal|34
case|:
name|op
operator|=
name|cff_op_hflex
expr_stmt|;
break|break;
case|case
literal|35
case|:
name|op
operator|=
name|cff_op_flex
expr_stmt|;
break|break;
case|case
literal|36
case|:
name|op
operator|=
name|cff_op_hflex1
expr_stmt|;
break|break;
case|case
literal|37
case|:
name|op
operator|=
name|cff_op_flex1
expr_stmt|;
break|break;
default|default:
comment|/* decrement ip for syntax error message */
name|ip
operator|--
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|13
case|:
name|op
operator|=
name|cff_op_hsbw
expr_stmt|;
break|break;
case|case
literal|14
case|:
name|op
operator|=
name|cff_op_endchar
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|op
operator|=
name|cff_op_blend
expr_stmt|;
break|break;
case|case
literal|18
case|:
name|op
operator|=
name|cff_op_hstemhm
expr_stmt|;
break|break;
case|case
literal|19
case|:
name|op
operator|=
name|cff_op_hintmask
expr_stmt|;
break|break;
case|case
literal|20
case|:
name|op
operator|=
name|cff_op_cntrmask
expr_stmt|;
break|break;
case|case
literal|21
case|:
name|op
operator|=
name|cff_op_rmoveto
expr_stmt|;
break|break;
case|case
literal|22
case|:
name|op
operator|=
name|cff_op_hmoveto
expr_stmt|;
break|break;
case|case
literal|23
case|:
name|op
operator|=
name|cff_op_vstemhm
expr_stmt|;
break|break;
case|case
literal|24
case|:
name|op
operator|=
name|cff_op_rcurveline
expr_stmt|;
break|break;
case|case
literal|25
case|:
name|op
operator|=
name|cff_op_rlinecurve
expr_stmt|;
break|break;
case|case
literal|26
case|:
name|op
operator|=
name|cff_op_vvcurveto
expr_stmt|;
break|break;
case|case
literal|27
case|:
name|op
operator|=
name|cff_op_hhcurveto
expr_stmt|;
break|break;
case|case
literal|29
case|:
name|op
operator|=
name|cff_op_callgsubr
expr_stmt|;
break|break;
case|case
literal|30
case|:
name|op
operator|=
name|cff_op_vhcurveto
expr_stmt|;
break|break;
case|case
literal|31
case|:
name|op
operator|=
name|cff_op_hvcurveto
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|op
operator|==
name|cff_op_unknown
condition|)
goto|goto
name|Syntax_Error
goto|;
comment|/* check arguments */
name|req_args
operator|=
name|cff_argument_counts
index|[
name|op
index|]
expr_stmt|;
if|if
condition|(
name|req_args
operator|&
name|CFF_COUNT_CHECK_WIDTH
condition|)
block|{
if|if
condition|(
name|num_args
operator|>
literal|0
operator|&&
name|decoder
operator|->
name|read_width
condition|)
block|{
comment|/* If `nominal_width' is non-zero, the number is really a      */
comment|/* difference against `nominal_width'.  Else, the number here  */
comment|/* is truly a width, not a difference against `nominal_width'. */
comment|/* If the font does not set `nominal_width', then              */
comment|/* `nominal_width' defaults to zero, and so we can set         */
comment|/* `glyph_width' to `nominal_width' plus number on the stack   */
comment|/* -- for either case.                                         */
name|FT_Int
name|set_width_ok
decl_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|cff_op_hmoveto
case|:
case|case
name|cff_op_vmoveto
case|:
name|set_width_ok
operator|=
name|num_args
operator|&
literal|2
expr_stmt|;
break|break;
case|case
name|cff_op_hstem
case|:
case|case
name|cff_op_vstem
case|:
case|case
name|cff_op_hstemhm
case|:
case|case
name|cff_op_vstemhm
case|:
case|case
name|cff_op_rmoveto
case|:
case|case
name|cff_op_hintmask
case|:
case|case
name|cff_op_cntrmask
case|:
name|set_width_ok
operator|=
name|num_args
operator|&
literal|1
expr_stmt|;
break|break;
case|case
name|cff_op_endchar
case|:
comment|/* If there is a width specified for endchar, we either have */
comment|/* 1 argument or 5 arguments.  We like to argue.             */
name|set_width_ok
operator|=
operator|(
name|num_args
operator|==
literal|5
operator|)
operator|||
operator|(
name|num_args
operator|==
literal|1
operator|)
expr_stmt|;
break|break;
default|default:
name|set_width_ok
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|set_width_ok
condition|)
block|{
name|decoder
operator|->
name|glyph_width
operator|=
name|decoder
operator|->
name|nominal_width
operator|+
operator|(
name|stack
index|[
literal|0
index|]
operator|>>
literal|16
operator|)
expr_stmt|;
if|if
condition|(
name|decoder
operator|->
name|width_only
condition|)
block|{
comment|/* we only want the advance width; stop here */
break|break;
block|}
comment|/* Consumed an argument. */
name|num_args
operator|--
expr_stmt|;
block|}
block|}
name|decoder
operator|->
name|read_width
operator|=
literal|0
expr_stmt|;
name|req_args
operator|=
literal|0
expr_stmt|;
block|}
name|req_args
operator|&=
literal|0x000F
expr_stmt|;
if|if
condition|(
name|num_args
operator|<
name|req_args
condition|)
goto|goto
name|Stack_Underflow
goto|;
name|args
operator|-=
name|req_args
expr_stmt|;
name|num_args
operator|-=
name|req_args
expr_stmt|;
comment|/* At this point, `args' points to the first argument of the  */
comment|/* operand in case `req_args' isn't zero.  Otherwise, we have */
comment|/* to adjust `args' manually.                                 */
comment|/* Note that we only pop arguments from the stack which we    */
comment|/* really need and can digest so that we can continue in case */
comment|/* of superfluous stack elements.                             */
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|cff_op_hstem
case|:
case|case
name|cff_op_vstem
case|:
case|case
name|cff_op_hstemhm
case|:
case|case
name|cff_op_vstemhm
case|:
comment|/* the number of arguments is always even here */
name|FT_TRACE4
argument_list|(
operator|(
name|op
operator|==
name|cff_op_hstem
condition|?
literal|" hstem\n"
else|:
operator|(
name|op
operator|==
name|cff_op_vstem
condition|?
literal|" vstem\n"
else|:
operator|(
name|op
operator|==
name|cff_op_hstemhm
condition|?
literal|" hstemhm\n"
else|:
literal|" vstemhm\n"
operator|)
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hinter
condition|)
name|hinter
operator|->
name|stems
argument_list|(
name|hinter
operator|->
name|hints
argument_list|,
operator|(
name|op
operator|==
name|cff_op_hstem
operator|||
name|op
operator|==
name|cff_op_hstemhm
operator|)
argument_list|,
name|num_args
operator|/
literal|2
argument_list|,
name|args
operator|-
operator|(
name|num_args
operator|&
operator|~
literal|1
operator|)
argument_list|)
expr_stmt|;
name|decoder
operator|->
name|num_hints
operator|+=
name|num_args
operator|/
literal|2
expr_stmt|;
name|args
operator|=
name|stack
expr_stmt|;
break|break;
case|case
name|cff_op_hintmask
case|:
case|case
name|cff_op_cntrmask
case|:
name|FT_TRACE4
argument_list|(
operator|(
name|op
operator|==
name|cff_op_hintmask
condition|?
literal|" hintmask"
else|:
literal|" cntrmask"
operator|)
argument_list|)
expr_stmt|;
comment|/* implement vstem when needed --                        */
comment|/* the specification doesn't say it, but this also works */
comment|/* with the 'cntrmask' operator                          */
comment|/*                                                       */
if|if
condition|(
name|num_args
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|hinter
condition|)
name|hinter
operator|->
name|stems
argument_list|(
name|hinter
operator|->
name|hints
argument_list|,
literal|0
argument_list|,
name|num_args
operator|/
literal|2
argument_list|,
name|args
operator|-
operator|(
name|num_args
operator|&
operator|~
literal|1
operator|)
argument_list|)
expr_stmt|;
name|decoder
operator|->
name|num_hints
operator|+=
name|num_args
operator|/
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|hinter
condition|)
block|{
if|if
condition|(
name|op
operator|==
name|cff_op_hintmask
condition|)
name|hinter
operator|->
name|hintmask
argument_list|(
name|hinter
operator|->
name|hints
argument_list|,
name|builder
operator|->
name|current
operator|->
name|n_points
argument_list|,
name|decoder
operator|->
name|num_hints
argument_list|,
name|ip
argument_list|)
expr_stmt|;
else|else
name|hinter
operator|->
name|counter
argument_list|(
name|hinter
operator|->
name|hints
argument_list|,
name|decoder
operator|->
name|num_hints
argument_list|,
name|ip
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|FT_DEBUG_LEVEL_TRACE
block|{
name|FT_UInt
name|maskbyte
decl_stmt|;
name|FT_TRACE4
argument_list|(
operator|(
literal|" (maskbytes: "
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|maskbyte
operator|=
literal|0
init|;
name|maskbyte
operator|<
call|(
name|FT_UInt
call|)
argument_list|(
operator|(
name|decoder
operator|->
name|num_hints
operator|+
literal|7
operator|)
operator|>>
literal|3
argument_list|)
condition|;
name|maskbyte
operator|++
operator|,
name|ip
operator|++
control|)
name|FT_TRACE4
argument_list|(
operator|(
literal|"0x%02X"
operator|,
operator|*
name|ip
operator|)
argument_list|)
expr_stmt|;
name|FT_TRACE4
argument_list|(
operator|(
literal|")\n"
operator|)
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|ip
operator|+=
operator|(
name|decoder
operator|->
name|num_hints
operator|+
literal|7
operator|)
operator|>>
literal|3
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ip
operator|>=
name|limit
condition|)
goto|goto
name|Syntax_Error
goto|;
name|args
operator|=
name|stack
expr_stmt|;
break|break;
case|case
name|cff_op_rmoveto
case|:
name|FT_TRACE4
argument_list|(
operator|(
literal|" rmoveto\n"
operator|)
argument_list|)
expr_stmt|;
name|cff_builder_close_contour
argument_list|(
name|builder
argument_list|)
expr_stmt|;
name|builder
operator|->
name|path_begun
operator|=
literal|0
expr_stmt|;
name|x
operator|+=
name|args
index|[
operator|-
literal|2
index|]
expr_stmt|;
name|y
operator|+=
name|args
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|args
operator|=
name|stack
expr_stmt|;
break|break;
case|case
name|cff_op_vmoveto
case|:
name|FT_TRACE4
argument_list|(
operator|(
literal|" vmoveto\n"
operator|)
argument_list|)
expr_stmt|;
name|cff_builder_close_contour
argument_list|(
name|builder
argument_list|)
expr_stmt|;
name|builder
operator|->
name|path_begun
operator|=
literal|0
expr_stmt|;
name|y
operator|+=
name|args
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|args
operator|=
name|stack
expr_stmt|;
break|break;
case|case
name|cff_op_hmoveto
case|:
name|FT_TRACE4
argument_list|(
operator|(
literal|" hmoveto\n"
operator|)
argument_list|)
expr_stmt|;
name|cff_builder_close_contour
argument_list|(
name|builder
argument_list|)
expr_stmt|;
name|builder
operator|->
name|path_begun
operator|=
literal|0
expr_stmt|;
name|x
operator|+=
name|args
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|args
operator|=
name|stack
expr_stmt|;
break|break;
case|case
name|cff_op_rlineto
case|:
name|FT_TRACE4
argument_list|(
operator|(
literal|" rlineto\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cff_builder_start_point
argument_list|(
name|builder
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
operator|||
name|check_points
argument_list|(
name|builder
argument_list|,
name|num_args
operator|/
literal|2
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
if|if
condition|(
name|num_args
operator|<
literal|2
condition|)
goto|goto
name|Stack_Underflow
goto|;
name|args
operator|-=
name|num_args
operator|&
operator|~
literal|1
expr_stmt|;
while|while
condition|(
name|args
operator|<
name|decoder
operator|->
name|top
condition|)
block|{
name|x
operator|+=
name|args
index|[
literal|0
index|]
expr_stmt|;
name|y
operator|+=
name|args
index|[
literal|1
index|]
expr_stmt|;
name|cff_builder_add_point
argument_list|(
name|builder
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|args
operator|+=
literal|2
expr_stmt|;
block|}
name|args
operator|=
name|stack
expr_stmt|;
break|break;
case|case
name|cff_op_hlineto
case|:
case|case
name|cff_op_vlineto
case|:
block|{
name|FT_Int
name|phase
init|=
operator|(
name|op
operator|==
name|cff_op_hlineto
operator|)
decl_stmt|;
name|FT_TRACE4
argument_list|(
operator|(
name|op
operator|==
name|cff_op_hlineto
condition|?
literal|" hlineto\n"
else|:
literal|" vlineto\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_args
operator|<
literal|1
condition|)
goto|goto
name|Stack_Underflow
goto|;
if|if
condition|(
name|cff_builder_start_point
argument_list|(
name|builder
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
operator|||
name|check_points
argument_list|(
name|builder
argument_list|,
name|num_args
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
name|args
operator|=
name|stack
expr_stmt|;
while|while
condition|(
name|args
operator|<
name|decoder
operator|->
name|top
condition|)
block|{
if|if
condition|(
name|phase
condition|)
name|x
operator|+=
name|args
index|[
literal|0
index|]
expr_stmt|;
else|else
name|y
operator|+=
name|args
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|cff_builder_add_point1
argument_list|(
name|builder
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
name|args
operator|++
expr_stmt|;
name|phase
operator|^=
literal|1
expr_stmt|;
block|}
name|args
operator|=
name|stack
expr_stmt|;
block|}
break|break;
case|case
name|cff_op_rrcurveto
case|:
block|{
name|FT_Int
name|nargs
decl_stmt|;
name|FT_TRACE4
argument_list|(
operator|(
literal|" rrcurveto\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_args
operator|<
literal|6
condition|)
goto|goto
name|Stack_Underflow
goto|;
name|nargs
operator|=
name|num_args
operator|-
name|num_args
operator|%
literal|6
expr_stmt|;
if|if
condition|(
name|cff_builder_start_point
argument_list|(
name|builder
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
operator|||
name|check_points
argument_list|(
name|builder
argument_list|,
name|nargs
operator|/
literal|2
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
name|args
operator|-=
name|nargs
expr_stmt|;
while|while
condition|(
name|args
operator|<
name|decoder
operator|->
name|top
condition|)
block|{
name|x
operator|+=
name|args
index|[
literal|0
index|]
expr_stmt|;
name|y
operator|+=
name|args
index|[
literal|1
index|]
expr_stmt|;
name|cff_builder_add_point
argument_list|(
name|builder
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|x
operator|+=
name|args
index|[
literal|2
index|]
expr_stmt|;
name|y
operator|+=
name|args
index|[
literal|3
index|]
expr_stmt|;
name|cff_builder_add_point
argument_list|(
name|builder
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|x
operator|+=
name|args
index|[
literal|4
index|]
expr_stmt|;
name|y
operator|+=
name|args
index|[
literal|5
index|]
expr_stmt|;
name|cff_builder_add_point
argument_list|(
name|builder
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|args
operator|+=
literal|6
expr_stmt|;
block|}
name|args
operator|=
name|stack
expr_stmt|;
block|}
break|break;
case|case
name|cff_op_vvcurveto
case|:
block|{
name|FT_Int
name|nargs
decl_stmt|;
name|FT_TRACE4
argument_list|(
operator|(
literal|" vvcurveto\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_args
operator|<
literal|4
condition|)
goto|goto
name|Stack_Underflow
goto|;
comment|/* if num_args isn't of the form 4n or 4n+1, */
comment|/* we reduce it to 4n+1                      */
name|nargs
operator|=
name|num_args
operator|-
name|num_args
operator|%
literal|4
expr_stmt|;
if|if
condition|(
name|num_args
operator|-
name|nargs
operator|>
literal|0
condition|)
name|nargs
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|cff_builder_start_point
argument_list|(
name|builder
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
name|args
operator|-=
name|nargs
expr_stmt|;
if|if
condition|(
name|nargs
operator|&
literal|1
condition|)
block|{
name|x
operator|+=
name|args
index|[
literal|0
index|]
expr_stmt|;
name|args
operator|++
expr_stmt|;
name|nargs
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|check_points
argument_list|(
name|builder
argument_list|,
literal|3
operator|*
operator|(
name|nargs
operator|/
literal|4
operator|)
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
while|while
condition|(
name|args
operator|<
name|decoder
operator|->
name|top
condition|)
block|{
name|y
operator|+=
name|args
index|[
literal|0
index|]
expr_stmt|;
name|cff_builder_add_point
argument_list|(
name|builder
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|x
operator|+=
name|args
index|[
literal|1
index|]
expr_stmt|;
name|y
operator|+=
name|args
index|[
literal|2
index|]
expr_stmt|;
name|cff_builder_add_point
argument_list|(
name|builder
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|y
operator|+=
name|args
index|[
literal|3
index|]
expr_stmt|;
name|cff_builder_add_point
argument_list|(
name|builder
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|args
operator|+=
literal|4
expr_stmt|;
block|}
name|args
operator|=
name|stack
expr_stmt|;
block|}
break|break;
case|case
name|cff_op_hhcurveto
case|:
block|{
name|FT_Int
name|nargs
decl_stmt|;
name|FT_TRACE4
argument_list|(
operator|(
literal|" hhcurveto\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_args
operator|<
literal|4
condition|)
goto|goto
name|Stack_Underflow
goto|;
comment|/* if num_args isn't of the form 4n or 4n+1, */
comment|/* we reduce it to 4n+1                      */
name|nargs
operator|=
name|num_args
operator|-
name|num_args
operator|%
literal|4
expr_stmt|;
if|if
condition|(
name|num_args
operator|-
name|nargs
operator|>
literal|0
condition|)
name|nargs
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|cff_builder_start_point
argument_list|(
name|builder
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
name|args
operator|-=
name|nargs
expr_stmt|;
if|if
condition|(
name|nargs
operator|&
literal|1
condition|)
block|{
name|y
operator|+=
name|args
index|[
literal|0
index|]
expr_stmt|;
name|args
operator|++
expr_stmt|;
name|nargs
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|check_points
argument_list|(
name|builder
argument_list|,
literal|3
operator|*
operator|(
name|nargs
operator|/
literal|4
operator|)
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
while|while
condition|(
name|args
operator|<
name|decoder
operator|->
name|top
condition|)
block|{
name|x
operator|+=
name|args
index|[
literal|0
index|]
expr_stmt|;
name|cff_builder_add_point
argument_list|(
name|builder
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|x
operator|+=
name|args
index|[
literal|1
index|]
expr_stmt|;
name|y
operator|+=
name|args
index|[
literal|2
index|]
expr_stmt|;
name|cff_builder_add_point
argument_list|(
name|builder
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|x
operator|+=
name|args
index|[
literal|3
index|]
expr_stmt|;
name|cff_builder_add_point
argument_list|(
name|builder
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|args
operator|+=
literal|4
expr_stmt|;
block|}
name|args
operator|=
name|stack
expr_stmt|;
block|}
break|break;
case|case
name|cff_op_vhcurveto
case|:
case|case
name|cff_op_hvcurveto
case|:
block|{
name|FT_Int
name|phase
decl_stmt|;
name|FT_Int
name|nargs
decl_stmt|;
name|FT_TRACE4
argument_list|(
operator|(
name|op
operator|==
name|cff_op_vhcurveto
condition|?
literal|" vhcurveto\n"
else|:
literal|" hvcurveto\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cff_builder_start_point
argument_list|(
name|builder
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
if|if
condition|(
name|num_args
operator|<
literal|4
condition|)
goto|goto
name|Stack_Underflow
goto|;
comment|/* if num_args isn't of the form 8n, 8n+1, 8n+4, or 8n+5, */
comment|/* we reduce it to the largest one which fits             */
name|nargs
operator|=
name|num_args
operator|-
name|num_args
operator|%
literal|4
expr_stmt|;
if|if
condition|(
name|num_args
operator|-
name|nargs
operator|>
literal|0
condition|)
name|nargs
operator|+=
literal|1
expr_stmt|;
name|args
operator|-=
name|nargs
expr_stmt|;
if|if
condition|(
name|check_points
argument_list|(
name|builder
argument_list|,
operator|(
name|nargs
operator|/
literal|4
operator|)
operator|*
literal|3
argument_list|)
condition|)
goto|goto
name|Stack_Underflow
goto|;
name|phase
operator|=
operator|(
name|op
operator|==
name|cff_op_hvcurveto
operator|)
expr_stmt|;
while|while
condition|(
name|nargs
operator|>=
literal|4
condition|)
block|{
name|nargs
operator|-=
literal|4
expr_stmt|;
if|if
condition|(
name|phase
condition|)
block|{
name|x
operator|+=
name|args
index|[
literal|0
index|]
expr_stmt|;
name|cff_builder_add_point
argument_list|(
name|builder
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|x
operator|+=
name|args
index|[
literal|1
index|]
expr_stmt|;
name|y
operator|+=
name|args
index|[
literal|2
index|]
expr_stmt|;
name|cff_builder_add_point
argument_list|(
name|builder
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|y
operator|+=
name|args
index|[
literal|3
index|]
expr_stmt|;
if|if
condition|(
name|nargs
operator|==
literal|1
condition|)
name|x
operator|+=
name|args
index|[
literal|4
index|]
expr_stmt|;
name|cff_builder_add_point
argument_list|(
name|builder
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|y
operator|+=
name|args
index|[
literal|0
index|]
expr_stmt|;
name|cff_builder_add_point
argument_list|(
name|builder
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|x
operator|+=
name|args
index|[
literal|1
index|]
expr_stmt|;
name|y
operator|+=
name|args
index|[
literal|2
index|]
expr_stmt|;
name|cff_builder_add_point
argument_list|(
name|builder
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|x
operator|+=
name|args
index|[
literal|3
index|]
expr_stmt|;
if|if
condition|(
name|nargs
operator|==
literal|1
condition|)
name|y
operator|+=
name|args
index|[
literal|4
index|]
expr_stmt|;
name|cff_builder_add_point
argument_list|(
name|builder
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|args
operator|+=
literal|4
expr_stmt|;
name|phase
operator|^=
literal|1
expr_stmt|;
block|}
name|args
operator|=
name|stack
expr_stmt|;
block|}
break|break;
case|case
name|cff_op_rlinecurve
case|:
block|{
name|FT_Int
name|num_lines
decl_stmt|;
name|FT_Int
name|nargs
decl_stmt|;
name|FT_TRACE4
argument_list|(
operator|(
literal|" rlinecurve\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_args
operator|<
literal|8
condition|)
goto|goto
name|Stack_Underflow
goto|;
name|nargs
operator|=
name|num_args
operator|&
operator|~
literal|1
expr_stmt|;
name|num_lines
operator|=
operator|(
name|nargs
operator|-
literal|6
operator|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|cff_builder_start_point
argument_list|(
name|builder
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
operator|||
name|check_points
argument_list|(
name|builder
argument_list|,
name|num_lines
operator|+
literal|3
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
name|args
operator|-=
name|nargs
expr_stmt|;
comment|/* first, add the line segments */
while|while
condition|(
name|num_lines
operator|>
literal|0
condition|)
block|{
name|x
operator|+=
name|args
index|[
literal|0
index|]
expr_stmt|;
name|y
operator|+=
name|args
index|[
literal|1
index|]
expr_stmt|;
name|cff_builder_add_point
argument_list|(
name|builder
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|args
operator|+=
literal|2
expr_stmt|;
name|num_lines
operator|--
expr_stmt|;
block|}
comment|/* then the curve */
name|x
operator|+=
name|args
index|[
literal|0
index|]
expr_stmt|;
name|y
operator|+=
name|args
index|[
literal|1
index|]
expr_stmt|;
name|cff_builder_add_point
argument_list|(
name|builder
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|x
operator|+=
name|args
index|[
literal|2
index|]
expr_stmt|;
name|y
operator|+=
name|args
index|[
literal|3
index|]
expr_stmt|;
name|cff_builder_add_point
argument_list|(
name|builder
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|x
operator|+=
name|args
index|[
literal|4
index|]
expr_stmt|;
name|y
operator|+=
name|args
index|[
literal|5
index|]
expr_stmt|;
name|cff_builder_add_point
argument_list|(
name|builder
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|args
operator|=
name|stack
expr_stmt|;
block|}
break|break;
case|case
name|cff_op_rcurveline
case|:
block|{
name|FT_Int
name|num_curves
decl_stmt|;
name|FT_Int
name|nargs
decl_stmt|;
name|FT_TRACE4
argument_list|(
operator|(
literal|" rcurveline\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_args
operator|<
literal|8
condition|)
goto|goto
name|Stack_Underflow
goto|;
name|nargs
operator|=
name|num_args
operator|-
literal|2
expr_stmt|;
name|nargs
operator|=
name|nargs
operator|-
name|nargs
operator|%
literal|6
operator|+
literal|2
expr_stmt|;
name|num_curves
operator|=
operator|(
name|nargs
operator|-
literal|2
operator|)
operator|/
literal|6
expr_stmt|;
if|if
condition|(
name|cff_builder_start_point
argument_list|(
name|builder
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
operator|||
name|check_points
argument_list|(
name|builder
argument_list|,
name|num_curves
operator|*
literal|3
operator|+
literal|2
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
name|args
operator|-=
name|nargs
expr_stmt|;
comment|/* first, add the curves */
while|while
condition|(
name|num_curves
operator|>
literal|0
condition|)
block|{
name|x
operator|+=
name|args
index|[
literal|0
index|]
expr_stmt|;
name|y
operator|+=
name|args
index|[
literal|1
index|]
expr_stmt|;
name|cff_builder_add_point
argument_list|(
name|builder
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|x
operator|+=
name|args
index|[
literal|2
index|]
expr_stmt|;
name|y
operator|+=
name|args
index|[
literal|3
index|]
expr_stmt|;
name|cff_builder_add_point
argument_list|(
name|builder
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|x
operator|+=
name|args
index|[
literal|4
index|]
expr_stmt|;
name|y
operator|+=
name|args
index|[
literal|5
index|]
expr_stmt|;
name|cff_builder_add_point
argument_list|(
name|builder
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|args
operator|+=
literal|6
expr_stmt|;
name|num_curves
operator|--
expr_stmt|;
block|}
comment|/* then the final line */
name|x
operator|+=
name|args
index|[
literal|0
index|]
expr_stmt|;
name|y
operator|+=
name|args
index|[
literal|1
index|]
expr_stmt|;
name|cff_builder_add_point
argument_list|(
name|builder
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|args
operator|=
name|stack
expr_stmt|;
block|}
break|break;
case|case
name|cff_op_hflex1
case|:
block|{
name|FT_Pos
name|start_y
decl_stmt|;
name|FT_TRACE4
argument_list|(
operator|(
literal|" hflex1\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* adding five more points: 4 control points, 1 on-curve point */
comment|/* -- make sure we have enough space for the start point if it */
comment|/* needs to be added                                           */
if|if
condition|(
name|cff_builder_start_point
argument_list|(
name|builder
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
operator|||
name|check_points
argument_list|(
name|builder
argument_list|,
literal|6
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
comment|/* record the starting point's y position for later use */
name|start_y
operator|=
name|y
expr_stmt|;
comment|/* first control point */
name|x
operator|+=
name|args
index|[
literal|0
index|]
expr_stmt|;
name|y
operator|+=
name|args
index|[
literal|1
index|]
expr_stmt|;
name|cff_builder_add_point
argument_list|(
name|builder
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* second control point */
name|x
operator|+=
name|args
index|[
literal|2
index|]
expr_stmt|;
name|y
operator|+=
name|args
index|[
literal|3
index|]
expr_stmt|;
name|cff_builder_add_point
argument_list|(
name|builder
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* join point; on curve, with y-value the same as the last */
comment|/* control point's y-value                                 */
name|x
operator|+=
name|args
index|[
literal|4
index|]
expr_stmt|;
name|cff_builder_add_point
argument_list|(
name|builder
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* third control point, with y-value the same as the join */
comment|/* point's y-value                                        */
name|x
operator|+=
name|args
index|[
literal|5
index|]
expr_stmt|;
name|cff_builder_add_point
argument_list|(
name|builder
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* fourth control point */
name|x
operator|+=
name|args
index|[
literal|6
index|]
expr_stmt|;
name|y
operator|+=
name|args
index|[
literal|7
index|]
expr_stmt|;
name|cff_builder_add_point
argument_list|(
name|builder
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* ending point, with y-value the same as the start   */
name|x
operator|+=
name|args
index|[
literal|8
index|]
expr_stmt|;
name|y
operator|=
name|start_y
expr_stmt|;
name|cff_builder_add_point
argument_list|(
name|builder
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|args
operator|=
name|stack
expr_stmt|;
break|break;
block|}
case|case
name|cff_op_hflex
case|:
block|{
name|FT_Pos
name|start_y
decl_stmt|;
name|FT_TRACE4
argument_list|(
operator|(
literal|" hflex\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* adding six more points; 4 control points, 2 on-curve points */
if|if
condition|(
name|cff_builder_start_point
argument_list|(
name|builder
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
operator|||
name|check_points
argument_list|(
name|builder
argument_list|,
literal|6
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
comment|/* record the starting point's y-position for later use */
name|start_y
operator|=
name|y
expr_stmt|;
comment|/* first control point */
name|x
operator|+=
name|args
index|[
literal|0
index|]
expr_stmt|;
name|cff_builder_add_point
argument_list|(
name|builder
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* second control point */
name|x
operator|+=
name|args
index|[
literal|1
index|]
expr_stmt|;
name|y
operator|+=
name|args
index|[
literal|2
index|]
expr_stmt|;
name|cff_builder_add_point
argument_list|(
name|builder
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* join point; on curve, with y-value the same as the last */
comment|/* control point's y-value                                 */
name|x
operator|+=
name|args
index|[
literal|3
index|]
expr_stmt|;
name|cff_builder_add_point
argument_list|(
name|builder
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* third control point, with y-value the same as the join */
comment|/* point's y-value                                        */
name|x
operator|+=
name|args
index|[
literal|4
index|]
expr_stmt|;
name|cff_builder_add_point
argument_list|(
name|builder
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* fourth control point */
name|x
operator|+=
name|args
index|[
literal|5
index|]
expr_stmt|;
name|y
operator|=
name|start_y
expr_stmt|;
name|cff_builder_add_point
argument_list|(
name|builder
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* ending point, with y-value the same as the start point's */
comment|/* y-value -- we don't add this point, though               */
name|x
operator|+=
name|args
index|[
literal|6
index|]
expr_stmt|;
name|cff_builder_add_point
argument_list|(
name|builder
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|args
operator|=
name|stack
expr_stmt|;
break|break;
block|}
case|case
name|cff_op_flex1
case|:
block|{
name|FT_Pos
name|start_x
decl_stmt|,
name|start_y
decl_stmt|;
comment|/* record start x, y values for */
comment|/* alter use                    */
name|FT_Fixed
name|dx
init|=
literal|0
decl_stmt|,
name|dy
init|=
literal|0
decl_stmt|;
comment|/* used in horizontal/vertical  */
comment|/* algorithm below              */
name|FT_Int
name|horizontal
decl_stmt|,
name|count
decl_stmt|;
name|FT_Fixed
modifier|*
name|temp
decl_stmt|;
name|FT_TRACE4
argument_list|(
operator|(
literal|" flex1\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* adding six more points; 4 control points, 2 on-curve points */
if|if
condition|(
name|cff_builder_start_point
argument_list|(
name|builder
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
operator|||
name|check_points
argument_list|(
name|builder
argument_list|,
literal|6
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
comment|/* record the starting point's x, y position for later use */
name|start_x
operator|=
name|x
expr_stmt|;
name|start_y
operator|=
name|y
expr_stmt|;
comment|/* XXX: figure out whether this is supposed to be a horizontal */
comment|/*      or vertical flex; the Type 2 specification is vague... */
name|temp
operator|=
name|args
expr_stmt|;
comment|/* grab up to the last argument */
for|for
control|(
name|count
operator|=
literal|5
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
control|)
block|{
name|dx
operator|+=
name|temp
index|[
literal|0
index|]
expr_stmt|;
name|dy
operator|+=
name|temp
index|[
literal|1
index|]
expr_stmt|;
name|temp
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|dx
operator|<
literal|0
condition|)
name|dx
operator|=
operator|-
name|dx
expr_stmt|;
if|if
condition|(
name|dy
operator|<
literal|0
condition|)
name|dy
operator|=
operator|-
name|dy
expr_stmt|;
comment|/* strange test, but here it is... */
name|horizontal
operator|=
operator|(
name|dx
operator|>
name|dy
operator|)
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|5
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
control|)
block|{
name|x
operator|+=
name|args
index|[
literal|0
index|]
expr_stmt|;
name|y
operator|+=
name|args
index|[
literal|1
index|]
expr_stmt|;
name|cff_builder_add_point
argument_list|(
name|builder
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
call|(
name|FT_Bool
call|)
argument_list|(
name|count
operator|==
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|args
operator|+=
literal|2
expr_stmt|;
block|}
comment|/* is last operand an x- or y-delta? */
if|if
condition|(
name|horizontal
condition|)
block|{
name|x
operator|+=
name|args
index|[
literal|0
index|]
expr_stmt|;
name|y
operator|=
name|start_y
expr_stmt|;
block|}
else|else
block|{
name|x
operator|=
name|start_x
expr_stmt|;
name|y
operator|+=
name|args
index|[
literal|0
index|]
expr_stmt|;
block|}
name|cff_builder_add_point
argument_list|(
name|builder
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|args
operator|=
name|stack
expr_stmt|;
break|break;
block|}
case|case
name|cff_op_flex
case|:
block|{
name|FT_UInt
name|count
decl_stmt|;
name|FT_TRACE4
argument_list|(
operator|(
literal|" flex\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cff_builder_start_point
argument_list|(
name|builder
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
operator|||
name|check_points
argument_list|(
name|builder
argument_list|,
literal|6
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
for|for
control|(
name|count
operator|=
literal|6
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
control|)
block|{
name|x
operator|+=
name|args
index|[
literal|0
index|]
expr_stmt|;
name|y
operator|+=
name|args
index|[
literal|1
index|]
expr_stmt|;
name|cff_builder_add_point
argument_list|(
name|builder
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
call|(
name|FT_Bool
call|)
argument_list|(
name|count
operator|==
literal|4
operator|||
name|count
operator|==
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|args
operator|+=
literal|2
expr_stmt|;
block|}
name|args
operator|=
name|stack
expr_stmt|;
block|}
break|break;
case|case
name|cff_op_seac
case|:
name|FT_TRACE4
argument_list|(
operator|(
literal|" seac\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|cff_operator_seac
argument_list|(
name|decoder
argument_list|,
name|args
index|[
literal|0
index|]
argument_list|,
name|args
index|[
literal|1
index|]
argument_list|,
name|args
index|[
literal|2
index|]
argument_list|,
call|(
name|FT_Int
call|)
argument_list|(
name|args
index|[
literal|3
index|]
operator|>>
literal|16
argument_list|)
argument_list|,
call|(
name|FT_Int
call|)
argument_list|(
name|args
index|[
literal|4
index|]
operator|>>
literal|16
argument_list|)
argument_list|)
expr_stmt|;
comment|/* add current outline to the glyph slot */
name|FT_GlyphLoader_Add
argument_list|(
name|builder
operator|->
name|loader
argument_list|)
expr_stmt|;
comment|/* return now! */
name|FT_TRACE4
argument_list|(
operator|(
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|error
return|;
case|case
name|cff_op_endchar
case|:
name|FT_TRACE4
argument_list|(
operator|(
literal|" endchar\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* We are going to emulate the seac operator. */
if|if
condition|(
name|num_args
operator|>=
literal|4
condition|)
block|{
comment|/* Save glyph width so that the subglyphs don't overwrite it. */
name|FT_Pos
name|glyph_width
init|=
name|decoder
operator|->
name|glyph_width
decl_stmt|;
name|error
operator|=
name|cff_operator_seac
argument_list|(
name|decoder
argument_list|,
literal|0L
argument_list|,
name|args
index|[
operator|-
literal|4
index|]
argument_list|,
name|args
index|[
operator|-
literal|3
index|]
argument_list|,
call|(
name|FT_Int
call|)
argument_list|(
name|args
index|[
operator|-
literal|2
index|]
operator|>>
literal|16
argument_list|)
argument_list|,
call|(
name|FT_Int
call|)
argument_list|(
name|args
index|[
operator|-
literal|1
index|]
operator|>>
literal|16
argument_list|)
argument_list|)
expr_stmt|;
name|decoder
operator|->
name|glyph_width
operator|=
name|glyph_width
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|CFF_Err_Ok
expr_stmt|;
name|cff_builder_close_contour
argument_list|(
name|builder
argument_list|)
expr_stmt|;
comment|/* close hints recording session */
if|if
condition|(
name|hinter
condition|)
block|{
if|if
condition|(
name|hinter
operator|->
name|close
argument_list|(
name|hinter
operator|->
name|hints
argument_list|,
name|builder
operator|->
name|current
operator|->
name|n_points
argument_list|)
condition|)
goto|goto
name|Syntax_Error
goto|;
comment|/* apply hints to the loaded glyph outline now */
name|hinter
operator|->
name|apply
argument_list|(
name|hinter
operator|->
name|hints
argument_list|,
name|builder
operator|->
name|current
argument_list|,
operator|(
name|PSH_Globals
operator|)
name|builder
operator|->
name|hints_globals
argument_list|,
name|decoder
operator|->
name|hint_mode
argument_list|)
expr_stmt|;
block|}
comment|/* add current outline to the glyph slot */
name|FT_GlyphLoader_Add
argument_list|(
name|builder
operator|->
name|loader
argument_list|)
expr_stmt|;
block|}
comment|/* return now! */
name|FT_TRACE4
argument_list|(
operator|(
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|error
return|;
case|case
name|cff_op_abs
case|:
name|FT_TRACE4
argument_list|(
operator|(
literal|" abs\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
index|[
literal|0
index|]
operator|<
literal|0
condition|)
name|args
index|[
literal|0
index|]
operator|=
operator|-
name|args
index|[
literal|0
index|]
expr_stmt|;
name|args
operator|++
expr_stmt|;
break|break;
case|case
name|cff_op_add
case|:
name|FT_TRACE4
argument_list|(
operator|(
literal|" add\n"
operator|)
argument_list|)
expr_stmt|;
name|args
index|[
literal|0
index|]
operator|+=
name|args
index|[
literal|1
index|]
expr_stmt|;
name|args
operator|++
expr_stmt|;
break|break;
case|case
name|cff_op_sub
case|:
name|FT_TRACE4
argument_list|(
operator|(
literal|" sub\n"
operator|)
argument_list|)
expr_stmt|;
name|args
index|[
literal|0
index|]
operator|-=
name|args
index|[
literal|1
index|]
expr_stmt|;
name|args
operator|++
expr_stmt|;
break|break;
case|case
name|cff_op_div
case|:
name|FT_TRACE4
argument_list|(
operator|(
literal|" div\n"
operator|)
argument_list|)
expr_stmt|;
name|args
index|[
literal|0
index|]
operator|=
name|FT_DivFix
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
name|args
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|args
operator|++
expr_stmt|;
break|break;
case|case
name|cff_op_neg
case|:
name|FT_TRACE4
argument_list|(
operator|(
literal|" neg\n"
operator|)
argument_list|)
expr_stmt|;
name|args
index|[
literal|0
index|]
operator|=
operator|-
name|args
index|[
literal|0
index|]
expr_stmt|;
name|args
operator|++
expr_stmt|;
break|break;
case|case
name|cff_op_random
case|:
block|{
name|FT_Fixed
name|Rand
decl_stmt|;
name|FT_TRACE4
argument_list|(
operator|(
literal|" rand\n"
operator|)
argument_list|)
expr_stmt|;
name|Rand
operator|=
name|seed
expr_stmt|;
if|if
condition|(
name|Rand
operator|>=
literal|0x8000L
condition|)
name|Rand
operator|++
expr_stmt|;
name|args
index|[
literal|0
index|]
operator|=
name|Rand
expr_stmt|;
name|seed
operator|=
name|FT_MulFix
argument_list|(
name|seed
argument_list|,
literal|0x10000L
operator|-
name|seed
argument_list|)
expr_stmt|;
if|if
condition|(
name|seed
operator|==
literal|0
condition|)
name|seed
operator|+=
literal|0x2873
expr_stmt|;
name|args
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|cff_op_mul
case|:
name|FT_TRACE4
argument_list|(
operator|(
literal|" mul\n"
operator|)
argument_list|)
expr_stmt|;
name|args
index|[
literal|0
index|]
operator|=
name|FT_MulFix
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
name|args
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|args
operator|++
expr_stmt|;
break|break;
case|case
name|cff_op_sqrt
case|:
name|FT_TRACE4
argument_list|(
operator|(
literal|" sqrt\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
index|[
literal|0
index|]
operator|>
literal|0
condition|)
block|{
name|FT_Int
name|count
init|=
literal|9
decl_stmt|;
name|FT_Fixed
name|root
init|=
name|args
index|[
literal|0
index|]
decl_stmt|;
name|FT_Fixed
name|new_root
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|new_root
operator|=
operator|(
name|root
operator|+
name|FT_DivFix
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
name|root
argument_list|)
operator|+
literal|1
operator|)
operator|>>
literal|1
expr_stmt|;
if|if
condition|(
name|new_root
operator|==
name|root
operator|||
name|count
operator|<=
literal|0
condition|)
break|break;
name|root
operator|=
name|new_root
expr_stmt|;
block|}
name|args
index|[
literal|0
index|]
operator|=
name|new_root
expr_stmt|;
block|}
else|else
name|args
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|args
operator|++
expr_stmt|;
break|break;
case|case
name|cff_op_drop
case|:
comment|/* nothing */
name|FT_TRACE4
argument_list|(
operator|(
literal|" drop\n"
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|cff_op_exch
case|:
block|{
name|FT_Fixed
name|tmp
decl_stmt|;
name|FT_TRACE4
argument_list|(
operator|(
literal|" exch\n"
operator|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|args
index|[
literal|0
index|]
expr_stmt|;
name|args
index|[
literal|0
index|]
operator|=
name|args
index|[
literal|1
index|]
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|tmp
expr_stmt|;
name|args
operator|+=
literal|2
expr_stmt|;
block|}
break|break;
case|case
name|cff_op_index
case|:
block|{
name|FT_Int
name|idx
init|=
call|(
name|FT_Int
call|)
argument_list|(
name|args
index|[
literal|0
index|]
operator|>>
literal|16
argument_list|)
decl_stmt|;
name|FT_TRACE4
argument_list|(
operator|(
literal|" index\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|<
literal|0
condition|)
name|idx
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|idx
operator|>
name|num_args
operator|-
literal|2
condition|)
name|idx
operator|=
name|num_args
operator|-
literal|2
expr_stmt|;
name|args
index|[
literal|0
index|]
operator|=
name|args
index|[
operator|-
operator|(
name|idx
operator|+
literal|1
operator|)
index|]
expr_stmt|;
name|args
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|cff_op_roll
case|:
block|{
name|FT_Int
name|count
init|=
call|(
name|FT_Int
call|)
argument_list|(
name|args
index|[
literal|0
index|]
operator|>>
literal|16
argument_list|)
decl_stmt|;
name|FT_Int
name|idx
init|=
call|(
name|FT_Int
call|)
argument_list|(
name|args
index|[
literal|1
index|]
operator|>>
literal|16
argument_list|)
decl_stmt|;
name|FT_TRACE4
argument_list|(
operator|(
literal|" roll\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<=
literal|0
condition|)
name|count
operator|=
literal|1
expr_stmt|;
name|args
operator|-=
name|count
expr_stmt|;
if|if
condition|(
name|args
operator|<
name|stack
condition|)
goto|goto
name|Stack_Underflow
goto|;
if|if
condition|(
name|idx
operator|>=
literal|0
condition|)
block|{
while|while
condition|(
name|idx
operator|>
literal|0
condition|)
block|{
name|FT_Fixed
name|tmp
init|=
name|args
index|[
name|count
operator|-
literal|1
index|]
decl_stmt|;
name|FT_Int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|count
operator|-
literal|2
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|args
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|args
index|[
name|i
index|]
expr_stmt|;
name|args
index|[
literal|0
index|]
operator|=
name|tmp
expr_stmt|;
name|idx
operator|--
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|idx
operator|<
literal|0
condition|)
block|{
name|FT_Fixed
name|tmp
init|=
name|args
index|[
literal|0
index|]
decl_stmt|;
name|FT_Int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
operator|-
literal|1
condition|;
name|i
operator|++
control|)
name|args
index|[
name|i
index|]
operator|=
name|args
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|args
index|[
name|count
operator|-
literal|1
index|]
operator|=
name|tmp
expr_stmt|;
name|idx
operator|++
expr_stmt|;
block|}
block|}
name|args
operator|+=
name|count
expr_stmt|;
block|}
break|break;
case|case
name|cff_op_dup
case|:
name|FT_TRACE4
argument_list|(
operator|(
literal|" dup\n"
operator|)
argument_list|)
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|args
index|[
literal|0
index|]
expr_stmt|;
name|args
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|cff_op_put
case|:
block|{
name|FT_Fixed
name|val
init|=
name|args
index|[
literal|0
index|]
decl_stmt|;
name|FT_Int
name|idx
init|=
call|(
name|FT_Int
call|)
argument_list|(
name|args
index|[
literal|1
index|]
operator|>>
literal|16
argument_list|)
decl_stmt|;
name|FT_TRACE4
argument_list|(
operator|(
literal|" put\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|>=
literal|0
operator|&&
name|idx
operator|<
name|CFF_MAX_TRANS_ELEMENTS
condition|)
name|decoder
operator|->
name|buildchar
index|[
name|idx
index|]
operator|=
name|val
expr_stmt|;
block|}
break|break;
case|case
name|cff_op_get
case|:
block|{
name|FT_Int
name|idx
init|=
call|(
name|FT_Int
call|)
argument_list|(
name|args
index|[
literal|0
index|]
operator|>>
literal|16
argument_list|)
decl_stmt|;
name|FT_Fixed
name|val
init|=
literal|0
decl_stmt|;
name|FT_TRACE4
argument_list|(
operator|(
literal|" get\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|>=
literal|0
operator|&&
name|idx
operator|<
name|CFF_MAX_TRANS_ELEMENTS
condition|)
name|val
operator|=
name|decoder
operator|->
name|buildchar
index|[
name|idx
index|]
expr_stmt|;
name|args
index|[
literal|0
index|]
operator|=
name|val
expr_stmt|;
name|args
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|cff_op_store
case|:
name|FT_TRACE4
argument_list|(
operator|(
literal|" store\n"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|Unimplemented
goto|;
case|case
name|cff_op_load
case|:
name|FT_TRACE4
argument_list|(
operator|(
literal|" load\n"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|Unimplemented
goto|;
case|case
name|cff_op_dotsection
case|:
comment|/* this operator is deprecated and ignored by the parser */
name|FT_TRACE4
argument_list|(
operator|(
literal|" dotsection\n"
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|cff_op_closepath
case|:
comment|/* this is an invalid Type 2 operator; however, there        */
comment|/* exist fonts which are incorrectly converted from probably */
comment|/* Type 1 to CFF, and some parsers seem to accept it         */
name|FT_TRACE4
argument_list|(
operator|(
literal|" closepath (invalid op)\n"
operator|)
argument_list|)
expr_stmt|;
name|args
operator|=
name|stack
expr_stmt|;
break|break;
case|case
name|cff_op_hsbw
case|:
comment|/* this is an invalid Type 2 operator; however, there        */
comment|/* exist fonts which are incorrectly converted from probably */
comment|/* Type 1 to CFF, and some parsers seem to accept it         */
name|FT_TRACE4
argument_list|(
operator|(
literal|" hsbw (invalid op)\n"
operator|)
argument_list|)
expr_stmt|;
name|decoder
operator|->
name|glyph_width
operator|=
name|decoder
operator|->
name|nominal_width
operator|+
operator|(
name|args
index|[
literal|1
index|]
operator|>>
literal|16
operator|)
expr_stmt|;
name|decoder
operator|->
name|builder
operator|.
name|left_bearing
operator|.
name|x
operator|=
name|args
index|[
literal|0
index|]
expr_stmt|;
name|decoder
operator|->
name|builder
operator|.
name|left_bearing
operator|.
name|y
operator|=
literal|0
expr_stmt|;
name|x
operator|=
name|decoder
operator|->
name|builder
operator|.
name|pos_x
operator|+
name|args
index|[
literal|0
index|]
expr_stmt|;
name|y
operator|=
name|decoder
operator|->
name|builder
operator|.
name|pos_y
expr_stmt|;
name|args
operator|=
name|stack
expr_stmt|;
break|break;
case|case
name|cff_op_sbw
case|:
comment|/* this is an invalid Type 2 operator; however, there        */
comment|/* exist fonts which are incorrectly converted from probably */
comment|/* Type 1 to CFF, and some parsers seem to accept it         */
name|FT_TRACE4
argument_list|(
operator|(
literal|" sbw (invalid op)\n"
operator|)
argument_list|)
expr_stmt|;
name|decoder
operator|->
name|glyph_width
operator|=
name|decoder
operator|->
name|nominal_width
operator|+
operator|(
name|args
index|[
literal|2
index|]
operator|>>
literal|16
operator|)
expr_stmt|;
name|decoder
operator|->
name|builder
operator|.
name|left_bearing
operator|.
name|x
operator|=
name|args
index|[
literal|0
index|]
expr_stmt|;
name|decoder
operator|->
name|builder
operator|.
name|left_bearing
operator|.
name|y
operator|=
name|args
index|[
literal|1
index|]
expr_stmt|;
name|x
operator|=
name|decoder
operator|->
name|builder
operator|.
name|pos_x
operator|+
name|args
index|[
literal|0
index|]
expr_stmt|;
name|y
operator|=
name|decoder
operator|->
name|builder
operator|.
name|pos_y
operator|+
name|args
index|[
literal|1
index|]
expr_stmt|;
name|args
operator|=
name|stack
expr_stmt|;
break|break;
case|case
name|cff_op_setcurrentpoint
case|:
comment|/* this is an invalid Type 2 operator; however, there        */
comment|/* exist fonts which are incorrectly converted from probably */
comment|/* Type 1 to CFF, and some parsers seem to accept it         */
name|FT_TRACE4
argument_list|(
operator|(
literal|" setcurrentpoint (invalid op)\n"
operator|)
argument_list|)
expr_stmt|;
name|x
operator|=
name|decoder
operator|->
name|builder
operator|.
name|pos_x
operator|+
name|args
index|[
literal|0
index|]
expr_stmt|;
name|y
operator|=
name|decoder
operator|->
name|builder
operator|.
name|pos_y
operator|+
name|args
index|[
literal|1
index|]
expr_stmt|;
name|args
operator|=
name|stack
expr_stmt|;
break|break;
case|case
name|cff_op_callothersubr
case|:
comment|/* this is an invalid Type 2 operator; however, there        */
comment|/* exist fonts which are incorrectly converted from probably */
comment|/* Type 1 to CFF, and some parsers seem to accept it         */
name|FT_TRACE4
argument_list|(
operator|(
literal|" callothersubr (invalid op)\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* subsequent `pop' operands should add the arguments,       */
comment|/* this is the implementation described for `unknown' other  */
comment|/* subroutines in the Type1 spec.                            */
name|args
operator|-=
literal|2
operator|+
operator|(
name|args
index|[
operator|-
literal|2
index|]
operator|>>
literal|16
operator|)
expr_stmt|;
break|break;
case|case
name|cff_op_pop
case|:
comment|/* this is an invalid Type 2 operator; however, there        */
comment|/* exist fonts which are incorrectly converted from probably */
comment|/* Type 1 to CFF, and some parsers seem to accept it         */
name|FT_TRACE4
argument_list|(
operator|(
literal|" pop (invalid op)\n"
operator|)
argument_list|)
expr_stmt|;
name|args
operator|++
expr_stmt|;
break|break;
case|case
name|cff_op_and
case|:
block|{
name|FT_Fixed
name|cond
init|=
name|args
index|[
literal|0
index|]
operator|&&
name|args
index|[
literal|1
index|]
decl_stmt|;
name|FT_TRACE4
argument_list|(
operator|(
literal|" and\n"
operator|)
argument_list|)
expr_stmt|;
name|args
index|[
literal|0
index|]
operator|=
name|cond
condition|?
literal|0x10000L
else|:
literal|0
expr_stmt|;
name|args
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|cff_op_or
case|:
block|{
name|FT_Fixed
name|cond
init|=
name|args
index|[
literal|0
index|]
operator|||
name|args
index|[
literal|1
index|]
decl_stmt|;
name|FT_TRACE4
argument_list|(
operator|(
literal|" or\n"
operator|)
argument_list|)
expr_stmt|;
name|args
index|[
literal|0
index|]
operator|=
name|cond
condition|?
literal|0x10000L
else|:
literal|0
expr_stmt|;
name|args
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|cff_op_eq
case|:
block|{
name|FT_Fixed
name|cond
init|=
operator|!
name|args
index|[
literal|0
index|]
decl_stmt|;
name|FT_TRACE4
argument_list|(
operator|(
literal|" eq\n"
operator|)
argument_list|)
expr_stmt|;
name|args
index|[
literal|0
index|]
operator|=
name|cond
condition|?
literal|0x10000L
else|:
literal|0
expr_stmt|;
name|args
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|cff_op_ifelse
case|:
block|{
name|FT_Fixed
name|cond
init|=
operator|(
name|args
index|[
literal|2
index|]
operator|<=
name|args
index|[
literal|3
index|]
operator|)
decl_stmt|;
name|FT_TRACE4
argument_list|(
operator|(
literal|" ifelse\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cond
condition|)
name|args
index|[
literal|0
index|]
operator|=
name|args
index|[
literal|1
index|]
expr_stmt|;
name|args
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|cff_op_callsubr
case|:
block|{
name|FT_UInt
name|idx
init|=
call|(
name|FT_UInt
call|)
argument_list|(
operator|(
name|args
index|[
literal|0
index|]
operator|>>
literal|16
operator|)
operator|+
name|decoder
operator|->
name|locals_bias
argument_list|)
decl_stmt|;
name|FT_TRACE4
argument_list|(
operator|(
literal|" callsubr(%d)\n"
operator|,
name|idx
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|>=
name|decoder
operator|->
name|num_locals
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"cff_decoder_parse_charstrings:"
literal|" invalid local subr index\n"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|Syntax_Error
goto|;
block|}
if|if
condition|(
name|zone
operator|-
name|decoder
operator|->
name|zones
operator|>=
name|CFF_MAX_SUBRS_CALLS
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"cff_decoder_parse_charstrings:"
literal|" too many nested subrs\n"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|Syntax_Error
goto|;
block|}
name|zone
operator|->
name|cursor
operator|=
name|ip
expr_stmt|;
comment|/* save current instruction pointer */
name|zone
operator|++
expr_stmt|;
name|zone
operator|->
name|base
operator|=
name|decoder
operator|->
name|locals
index|[
name|idx
index|]
expr_stmt|;
name|zone
operator|->
name|limit
operator|=
name|decoder
operator|->
name|locals
index|[
name|idx
operator|+
literal|1
index|]
expr_stmt|;
name|zone
operator|->
name|cursor
operator|=
name|zone
operator|->
name|base
expr_stmt|;
if|if
condition|(
operator|!
name|zone
operator|->
name|base
operator|||
name|zone
operator|->
name|limit
operator|==
name|zone
operator|->
name|base
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"cff_decoder_parse_charstrings:"
literal|" invoking empty subrs\n"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|Syntax_Error
goto|;
block|}
name|decoder
operator|->
name|zone
operator|=
name|zone
expr_stmt|;
name|ip
operator|=
name|zone
operator|->
name|base
expr_stmt|;
name|limit
operator|=
name|zone
operator|->
name|limit
expr_stmt|;
block|}
break|break;
case|case
name|cff_op_callgsubr
case|:
block|{
name|FT_UInt
name|idx
init|=
call|(
name|FT_UInt
call|)
argument_list|(
operator|(
name|args
index|[
literal|0
index|]
operator|>>
literal|16
operator|)
operator|+
name|decoder
operator|->
name|globals_bias
argument_list|)
decl_stmt|;
name|FT_TRACE4
argument_list|(
operator|(
literal|" callgsubr(%d)\n"
operator|,
name|idx
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|>=
name|decoder
operator|->
name|num_globals
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"cff_decoder_parse_charstrings:"
literal|" invalid global subr index\n"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|Syntax_Error
goto|;
block|}
if|if
condition|(
name|zone
operator|-
name|decoder
operator|->
name|zones
operator|>=
name|CFF_MAX_SUBRS_CALLS
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"cff_decoder_parse_charstrings:"
literal|" too many nested subrs\n"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|Syntax_Error
goto|;
block|}
name|zone
operator|->
name|cursor
operator|=
name|ip
expr_stmt|;
comment|/* save current instruction pointer */
name|zone
operator|++
expr_stmt|;
name|zone
operator|->
name|base
operator|=
name|decoder
operator|->
name|globals
index|[
name|idx
index|]
expr_stmt|;
name|zone
operator|->
name|limit
operator|=
name|decoder
operator|->
name|globals
index|[
name|idx
operator|+
literal|1
index|]
expr_stmt|;
name|zone
operator|->
name|cursor
operator|=
name|zone
operator|->
name|base
expr_stmt|;
if|if
condition|(
operator|!
name|zone
operator|->
name|base
operator|||
name|zone
operator|->
name|limit
operator|==
name|zone
operator|->
name|base
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"cff_decoder_parse_charstrings:"
literal|" invoking empty subrs\n"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|Syntax_Error
goto|;
block|}
name|decoder
operator|->
name|zone
operator|=
name|zone
expr_stmt|;
name|ip
operator|=
name|zone
operator|->
name|base
expr_stmt|;
name|limit
operator|=
name|zone
operator|->
name|limit
expr_stmt|;
block|}
break|break;
case|case
name|cff_op_return
case|:
name|FT_TRACE4
argument_list|(
operator|(
literal|" return\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|decoder
operator|->
name|zone
operator|<=
name|decoder
operator|->
name|zones
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"cff_decoder_parse_charstrings:"
literal|" unexpected return\n"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|Syntax_Error
goto|;
block|}
name|decoder
operator|->
name|zone
operator|--
expr_stmt|;
name|zone
operator|=
name|decoder
operator|->
name|zone
expr_stmt|;
name|ip
operator|=
name|zone
operator|->
name|cursor
expr_stmt|;
name|limit
operator|=
name|zone
operator|->
name|limit
expr_stmt|;
break|break;
default|default:
name|Unimplemented
label|:
name|FT_ERROR
argument_list|(
operator|(
literal|"Unimplemented opcode: %d"
operator|,
name|ip
index|[
operator|-
literal|1
index|]
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
index|[
operator|-
literal|1
index|]
operator|==
literal|12
condition|)
name|FT_ERROR
argument_list|(
operator|(
literal|" %d"
operator|,
name|ip
index|[
literal|0
index|]
operator|)
argument_list|)
expr_stmt|;
name|FT_ERROR
argument_list|(
operator|(
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|CFF_Err_Unimplemented_Feature
return|;
block|}
name|decoder
operator|->
name|top
operator|=
name|args
expr_stmt|;
block|}
comment|/* general operator processing */
block|}
comment|/* while ip< limit */
name|FT_TRACE4
argument_list|(
operator|(
literal|"..end..\n\n"
operator|)
argument_list|)
expr_stmt|;
name|Fail
label|:
return|return
name|error
return|;
name|Syntax_Error
label|:
name|FT_TRACE4
argument_list|(
operator|(
literal|"cff_decoder_parse_charstrings: syntax error\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|CFF_Err_Invalid_File_Format
return|;
name|Stack_Underflow
label|:
name|FT_TRACE4
argument_list|(
operator|(
literal|"cff_decoder_parse_charstrings: stack underflow\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|CFF_Err_Too_Few_Arguments
return|;
name|Stack_Overflow
label|:
name|FT_TRACE4
argument_list|(
operator|(
literal|"cff_decoder_parse_charstrings: stack overflow\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|CFF_Err_Stack_Overflow
return|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/**********                                                      *********/
end_comment
begin_comment
comment|/**********                                                      *********/
end_comment
begin_comment
comment|/**********            COMPUTE THE MAXIMUM ADVANCE WIDTH         *********/
end_comment
begin_comment
comment|/**********                                                      *********/
end_comment
begin_comment
comment|/**********    The following code is in charge of computing      *********/
end_comment
begin_comment
comment|/**********    the maximum advance width of the font.  It        *********/
end_comment
begin_comment
comment|/**********    quickly processes each glyph charstring to        *********/
end_comment
begin_comment
comment|/**********    extract the value from either a `sbw' or `seac'   *********/
end_comment
begin_comment
comment|/**********    operator.                                         *********/
end_comment
begin_comment
comment|/**********                                                      *********/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_if
if|#
directive|if
literal|0
end_if
begin_comment
comment|/* unused until we support pure CFF fonts */
end_comment
begin_comment
unit|FT_LOCAL_DEF( FT_Error )   cff_compute_max_advance( TT_Face  face,                            FT_Int*  max_advance )   {     FT_Error     error = CFF_Err_Ok;     CFF_Decoder  decoder;     FT_Int       glyph_index;     CFF_Font     cff = (CFF_Font)face->other;       *max_advance = 0;
comment|/* Initialize load decoder */
end_comment
begin_comment
unit|cff_decoder_init(&decoder, face, 0, 0, 0, 0 );      decoder.builder.metrics_only = 1;     decoder.builder.load_points  = 0;
comment|/* For each glyph, parse the glyph charstring and extract */
end_comment
begin_comment
comment|/* the advance width.                                     */
end_comment
begin_comment
unit|for ( glyph_index = 0; glyph_index< face->root.num_glyphs;           glyph_index++ )     {       FT_Byte*  charstring;       FT_ULong  charstring_len;
comment|/* now get load the unscaled outline */
end_comment
begin_comment
unit|error = cff_get_glyph_data( face, glyph_index,&charstring,&charstring_len );       if ( !error )       {         error = cff_decoder_prepare(&decoder, size, glyph_index );         if ( !error )           error = cff_decoder_parse_charstrings(&decoder,                                                  charstring,                                                  charstring_len );          cff_free_glyph_data( face,&charstring,&charstring_len );       }
comment|/* ignore the error if one has occurred -- skip to next glyph */
end_comment
begin_endif
unit|error = CFF_Err_Ok;     }      *max_advance = decoder.builder.advance.x;      return CFF_Err_Ok;   }
endif|#
directive|endif
end_endif
begin_comment
comment|/* 0 */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|cff_slot_load
argument_list|(
argument|CFF_GlyphSlot  glyph
argument_list|,
argument|CFF_Size       size
argument_list|,
argument|FT_UInt        glyph_index
argument_list|,
argument|FT_Int32       load_flags
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
decl_stmt|;
name|CFF_Decoder
name|decoder
decl_stmt|;
name|TT_Face
name|face
init|=
operator|(
name|TT_Face
operator|)
name|glyph
operator|->
name|root
operator|.
name|face
decl_stmt|;
name|FT_Bool
name|hinting
decl_stmt|,
name|force_scaling
decl_stmt|;
name|CFF_Font
name|cff
init|=
operator|(
name|CFF_Font
operator|)
name|face
operator|->
name|extra
operator|.
name|data
decl_stmt|;
name|FT_Matrix
name|font_matrix
decl_stmt|;
name|FT_Vector
name|font_offset
decl_stmt|;
name|force_scaling
operator|=
name|FALSE
expr_stmt|;
comment|/* in a CID-keyed font, consider `glyph_index' as a CID and map */
comment|/* it immediately to the real glyph_index -- if it isn't a      */
comment|/* subsetted font, glyph_indices and CIDs are identical, though */
if|if
condition|(
name|cff
operator|->
name|top_font
operator|.
name|font_dict
operator|.
name|cid_registry
operator|!=
literal|0xFFFFU
operator|&&
name|cff
operator|->
name|charset
operator|.
name|cids
condition|)
block|{
comment|/* don't handle CID 0 (.notdef) which is directly mapped to GID 0 */
if|if
condition|(
name|glyph_index
operator|!=
literal|0
condition|)
block|{
name|glyph_index
operator|=
name|cff_charset_cid_to_gindex
argument_list|(
operator|&
name|cff
operator|->
name|charset
argument_list|,
name|glyph_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|glyph_index
operator|==
literal|0
condition|)
return|return
name|CFF_Err_Invalid_Argument
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|glyph_index
operator|>=
name|cff
operator|->
name|num_glyphs
condition|)
return|return
name|CFF_Err_Invalid_Argument
return|;
if|if
condition|(
name|load_flags
operator|&
name|FT_LOAD_NO_RECURSE
condition|)
name|load_flags
operator||=
name|FT_LOAD_NO_SCALE
operator||
name|FT_LOAD_NO_HINTING
expr_stmt|;
name|glyph
operator|->
name|x_scale
operator|=
literal|0x10000L
expr_stmt|;
name|glyph
operator|->
name|y_scale
operator|=
literal|0x10000L
expr_stmt|;
if|if
condition|(
name|size
condition|)
block|{
name|glyph
operator|->
name|x_scale
operator|=
name|size
operator|->
name|root
operator|.
name|metrics
operator|.
name|x_scale
expr_stmt|;
name|glyph
operator|->
name|y_scale
operator|=
name|size
operator|->
name|root
operator|.
name|metrics
operator|.
name|y_scale
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_EMBEDDED_BITMAPS
comment|/* try to load embedded bitmap if any              */
comment|/*                                                 */
comment|/* XXX: The convention should be emphasized in     */
comment|/*      the documents because it can be confusing. */
if|if
condition|(
name|size
condition|)
block|{
name|CFF_Face
name|cff_face
init|=
operator|(
name|CFF_Face
operator|)
name|size
operator|->
name|root
operator|.
name|face
decl_stmt|;
name|SFNT_Service
name|sfnt
init|=
operator|(
name|SFNT_Service
operator|)
name|cff_face
operator|->
name|sfnt
decl_stmt|;
name|FT_Stream
name|stream
init|=
name|cff_face
operator|->
name|root
operator|.
name|stream
decl_stmt|;
if|if
condition|(
name|size
operator|->
name|strike_index
operator|!=
literal|0xFFFFFFFFUL
operator|&&
name|sfnt
operator|->
name|load_eblc
operator|&&
operator|(
name|load_flags
operator|&
name|FT_LOAD_NO_BITMAP
operator|)
operator|==
literal|0
condition|)
block|{
name|TT_SBit_MetricsRec
name|metrics
decl_stmt|;
name|error
operator|=
name|sfnt
operator|->
name|load_sbit_image
argument_list|(
name|face
argument_list|,
name|size
operator|->
name|strike_index
argument_list|,
name|glyph_index
argument_list|,
operator|(
name|FT_Int
operator|)
name|load_flags
argument_list|,
name|stream
argument_list|,
operator|&
name|glyph
operator|->
name|root
operator|.
name|bitmap
argument_list|,
operator|&
name|metrics
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|glyph
operator|->
name|root
operator|.
name|outline
operator|.
name|n_points
operator|=
literal|0
expr_stmt|;
name|glyph
operator|->
name|root
operator|.
name|outline
operator|.
name|n_contours
operator|=
literal|0
expr_stmt|;
name|glyph
operator|->
name|root
operator|.
name|metrics
operator|.
name|width
operator|=
operator|(
name|FT_Pos
operator|)
name|metrics
operator|.
name|width
operator|<<
literal|6
expr_stmt|;
name|glyph
operator|->
name|root
operator|.
name|metrics
operator|.
name|height
operator|=
operator|(
name|FT_Pos
operator|)
name|metrics
operator|.
name|height
operator|<<
literal|6
expr_stmt|;
name|glyph
operator|->
name|root
operator|.
name|metrics
operator|.
name|horiBearingX
operator|=
operator|(
name|FT_Pos
operator|)
name|metrics
operator|.
name|horiBearingX
operator|<<
literal|6
expr_stmt|;
name|glyph
operator|->
name|root
operator|.
name|metrics
operator|.
name|horiBearingY
operator|=
operator|(
name|FT_Pos
operator|)
name|metrics
operator|.
name|horiBearingY
operator|<<
literal|6
expr_stmt|;
name|glyph
operator|->
name|root
operator|.
name|metrics
operator|.
name|horiAdvance
operator|=
operator|(
name|FT_Pos
operator|)
name|metrics
operator|.
name|horiAdvance
operator|<<
literal|6
expr_stmt|;
name|glyph
operator|->
name|root
operator|.
name|metrics
operator|.
name|vertBearingX
operator|=
operator|(
name|FT_Pos
operator|)
name|metrics
operator|.
name|vertBearingX
operator|<<
literal|6
expr_stmt|;
name|glyph
operator|->
name|root
operator|.
name|metrics
operator|.
name|vertBearingY
operator|=
operator|(
name|FT_Pos
operator|)
name|metrics
operator|.
name|vertBearingY
operator|<<
literal|6
expr_stmt|;
name|glyph
operator|->
name|root
operator|.
name|metrics
operator|.
name|vertAdvance
operator|=
operator|(
name|FT_Pos
operator|)
name|metrics
operator|.
name|vertAdvance
operator|<<
literal|6
expr_stmt|;
name|glyph
operator|->
name|root
operator|.
name|format
operator|=
name|FT_GLYPH_FORMAT_BITMAP
expr_stmt|;
if|if
condition|(
name|load_flags
operator|&
name|FT_LOAD_VERTICAL_LAYOUT
condition|)
block|{
name|glyph
operator|->
name|root
operator|.
name|bitmap_left
operator|=
name|metrics
operator|.
name|vertBearingX
expr_stmt|;
name|glyph
operator|->
name|root
operator|.
name|bitmap_top
operator|=
name|metrics
operator|.
name|vertBearingY
expr_stmt|;
block|}
else|else
block|{
name|glyph
operator|->
name|root
operator|.
name|bitmap_left
operator|=
name|metrics
operator|.
name|horiBearingX
expr_stmt|;
name|glyph
operator|->
name|root
operator|.
name|bitmap_top
operator|=
name|metrics
operator|.
name|horiBearingY
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* TT_CONFIG_OPTION_EMBEDDED_BITMAPS */
comment|/* return immediately if we only want the embedded bitmaps */
if|if
condition|(
name|load_flags
operator|&
name|FT_LOAD_SBITS_ONLY
condition|)
return|return
name|CFF_Err_Invalid_Argument
return|;
comment|/* if we have a CID subfont, use its matrix (which has already */
comment|/* been multiplied with the root matrix)                       */
comment|/* this scaling is only relevant if the PS hinter isn't active */
if|if
condition|(
name|cff
operator|->
name|num_subfonts
condition|)
block|{
name|FT_Byte
name|fd_index
init|=
name|cff_fd_select_get
argument_list|(
operator|&
name|cff
operator|->
name|fd_select
argument_list|,
name|glyph_index
argument_list|)
decl_stmt|;
name|FT_ULong
name|top_upm
init|=
name|cff
operator|->
name|top_font
operator|.
name|font_dict
operator|.
name|units_per_em
decl_stmt|;
name|FT_ULong
name|sub_upm
init|=
name|cff
operator|->
name|subfonts
index|[
name|fd_index
index|]
operator|->
name|font_dict
operator|.
name|units_per_em
decl_stmt|;
name|font_matrix
operator|=
name|cff
operator|->
name|subfonts
index|[
name|fd_index
index|]
operator|->
name|font_dict
operator|.
name|font_matrix
expr_stmt|;
name|font_offset
operator|=
name|cff
operator|->
name|subfonts
index|[
name|fd_index
index|]
operator|->
name|font_dict
operator|.
name|font_offset
expr_stmt|;
if|if
condition|(
name|top_upm
operator|!=
name|sub_upm
condition|)
block|{
name|glyph
operator|->
name|x_scale
operator|=
name|FT_MulDiv
argument_list|(
name|glyph
operator|->
name|x_scale
argument_list|,
name|top_upm
argument_list|,
name|sub_upm
argument_list|)
expr_stmt|;
name|glyph
operator|->
name|y_scale
operator|=
name|FT_MulDiv
argument_list|(
name|glyph
operator|->
name|y_scale
argument_list|,
name|top_upm
argument_list|,
name|sub_upm
argument_list|)
expr_stmt|;
name|force_scaling
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
else|else
block|{
name|font_matrix
operator|=
name|cff
operator|->
name|top_font
operator|.
name|font_dict
operator|.
name|font_matrix
expr_stmt|;
name|font_offset
operator|=
name|cff
operator|->
name|top_font
operator|.
name|font_dict
operator|.
name|font_offset
expr_stmt|;
block|}
name|glyph
operator|->
name|root
operator|.
name|outline
operator|.
name|n_points
operator|=
literal|0
expr_stmt|;
name|glyph
operator|->
name|root
operator|.
name|outline
operator|.
name|n_contours
operator|=
literal|0
expr_stmt|;
name|hinting
operator|=
name|FT_BOOL
argument_list|(
operator|(
name|load_flags
operator|&
name|FT_LOAD_NO_SCALE
operator|)
operator|==
literal|0
operator|&&
operator|(
name|load_flags
operator|&
name|FT_LOAD_NO_HINTING
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|glyph
operator|->
name|root
operator|.
name|format
operator|=
name|FT_GLYPH_FORMAT_OUTLINE
expr_stmt|;
comment|/* by default */
block|{
name|FT_Byte
modifier|*
name|charstring
decl_stmt|;
name|FT_ULong
name|charstring_len
decl_stmt|;
name|cff_decoder_init
argument_list|(
operator|&
name|decoder
argument_list|,
name|face
argument_list|,
name|size
argument_list|,
name|glyph
argument_list|,
name|hinting
argument_list|,
name|FT_LOAD_TARGET_MODE
argument_list|(
name|load_flags
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|load_flags
operator|&
name|FT_LOAD_ADVANCE_ONLY
condition|)
name|decoder
operator|.
name|width_only
operator|=
name|TRUE
expr_stmt|;
name|decoder
operator|.
name|builder
operator|.
name|no_recurse
operator|=
call|(
name|FT_Bool
call|)
argument_list|(
name|load_flags
operator|&
name|FT_LOAD_NO_RECURSE
argument_list|)
expr_stmt|;
comment|/* now load the unscaled outline */
name|error
operator|=
name|cff_get_glyph_data
argument_list|(
name|face
argument_list|,
name|glyph_index
argument_list|,
operator|&
name|charstring
argument_list|,
operator|&
name|charstring_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|error
operator|=
name|cff_decoder_prepare
argument_list|(
operator|&
name|decoder
argument_list|,
name|size
argument_list|,
name|glyph_index
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|error
operator|=
name|cff_decoder_parse_charstrings
argument_list|(
operator|&
name|decoder
argument_list|,
name|charstring
argument_list|,
name|charstring_len
argument_list|)
expr_stmt|;
name|cff_free_glyph_data
argument_list|(
name|face
argument_list|,
operator|&
name|charstring
argument_list|,
name|charstring_len
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FT_CONFIG_OPTION_INCREMENTAL
comment|/* Control data and length may not be available for incremental */
comment|/* fonts.                                                       */
if|if
condition|(
name|face
operator|->
name|root
operator|.
name|internal
operator|->
name|incremental_interface
condition|)
block|{
name|glyph
operator|->
name|root
operator|.
name|control_data
operator|=
literal|0
expr_stmt|;
name|glyph
operator|->
name|root
operator|.
name|control_len
operator|=
literal|0
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* FT_CONFIG_OPTION_INCREMENTAL */
comment|/* We set control_data and control_len if charstrings is loaded. */
comment|/* See how charstring loads at cff_index_access_element() in     */
comment|/* cffload.c.                                                    */
block|{
name|CFF_Index
name|csindex
init|=
operator|&
name|cff
operator|->
name|charstrings_index
decl_stmt|;
if|if
condition|(
name|csindex
operator|->
name|offsets
condition|)
block|{
name|glyph
operator|->
name|root
operator|.
name|control_data
operator|=
name|csindex
operator|->
name|bytes
operator|+
name|csindex
operator|->
name|offsets
index|[
name|glyph_index
index|]
operator|-
literal|1
expr_stmt|;
name|glyph
operator|->
name|root
operator|.
name|control_len
operator|=
name|charstring_len
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* save new glyph tables */
name|cff_builder_done
argument_list|(
operator|&
name|decoder
operator|.
name|builder
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|FT_CONFIG_OPTION_INCREMENTAL
comment|/* Incremental fonts can optionally override the metrics. */
if|if
condition|(
operator|!
name|error
operator|&&
name|face
operator|->
name|root
operator|.
name|internal
operator|->
name|incremental_interface
operator|&&
name|face
operator|->
name|root
operator|.
name|internal
operator|->
name|incremental_interface
operator|->
name|funcs
operator|->
name|get_glyph_metrics
condition|)
block|{
name|FT_Incremental_MetricsRec
name|metrics
decl_stmt|;
name|metrics
operator|.
name|bearing_x
operator|=
name|decoder
operator|.
name|builder
operator|.
name|left_bearing
operator|.
name|x
expr_stmt|;
name|metrics
operator|.
name|bearing_y
operator|=
literal|0
expr_stmt|;
name|metrics
operator|.
name|advance
operator|=
name|decoder
operator|.
name|builder
operator|.
name|advance
operator|.
name|x
expr_stmt|;
name|metrics
operator|.
name|advance_v
operator|=
name|decoder
operator|.
name|builder
operator|.
name|advance
operator|.
name|y
expr_stmt|;
name|error
operator|=
name|face
operator|->
name|root
operator|.
name|internal
operator|->
name|incremental_interface
operator|->
name|funcs
operator|->
name|get_glyph_metrics
argument_list|(
name|face
operator|->
name|root
operator|.
name|internal
operator|->
name|incremental_interface
operator|->
name|object
argument_list|,
name|glyph_index
argument_list|,
name|FALSE
argument_list|,
operator|&
name|metrics
argument_list|)
expr_stmt|;
name|decoder
operator|.
name|builder
operator|.
name|left_bearing
operator|.
name|x
operator|=
name|metrics
operator|.
name|bearing_x
expr_stmt|;
name|decoder
operator|.
name|builder
operator|.
name|advance
operator|.
name|x
operator|=
name|metrics
operator|.
name|advance
expr_stmt|;
name|decoder
operator|.
name|builder
operator|.
name|advance
operator|.
name|y
operator|=
name|metrics
operator|.
name|advance_v
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* FT_CONFIG_OPTION_INCREMENTAL */
if|if
condition|(
operator|!
name|error
condition|)
block|{
comment|/* Now, set the metrics -- this is rather simple, as   */
comment|/* the left side bearing is the xMin, and the top side */
comment|/* bearing the yMax.                                   */
comment|/* For composite glyphs, return only left side bearing and */
comment|/* advance width.                                          */
if|if
condition|(
name|load_flags
operator|&
name|FT_LOAD_NO_RECURSE
condition|)
block|{
name|FT_Slot_Internal
name|internal
init|=
name|glyph
operator|->
name|root
operator|.
name|internal
decl_stmt|;
name|glyph
operator|->
name|root
operator|.
name|metrics
operator|.
name|horiBearingX
operator|=
name|decoder
operator|.
name|builder
operator|.
name|left_bearing
operator|.
name|x
expr_stmt|;
name|glyph
operator|->
name|root
operator|.
name|metrics
operator|.
name|horiAdvance
operator|=
name|decoder
operator|.
name|glyph_width
expr_stmt|;
name|internal
operator|->
name|glyph_matrix
operator|=
name|font_matrix
expr_stmt|;
name|internal
operator|->
name|glyph_delta
operator|=
name|font_offset
expr_stmt|;
name|internal
operator|->
name|glyph_transformed
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|FT_BBox
name|cbox
decl_stmt|;
name|FT_Glyph_Metrics
modifier|*
name|metrics
init|=
operator|&
name|glyph
operator|->
name|root
operator|.
name|metrics
decl_stmt|;
name|FT_Vector
name|advance
decl_stmt|;
name|FT_Bool
name|has_vertical_info
decl_stmt|;
comment|/* copy the _unscaled_ advance width */
name|metrics
operator|->
name|horiAdvance
operator|=
name|decoder
operator|.
name|glyph_width
expr_stmt|;
name|glyph
operator|->
name|root
operator|.
name|linearHoriAdvance
operator|=
name|decoder
operator|.
name|glyph_width
expr_stmt|;
name|glyph
operator|->
name|root
operator|.
name|internal
operator|->
name|glyph_transformed
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|FT_CONFIG_OPTION_OLD_INTERNALS
name|has_vertical_info
operator|=
name|FT_BOOL
argument_list|(
name|face
operator|->
name|vertical_info
operator|&&
name|face
operator|->
name|vertical
operator|.
name|number_Of_VMetrics
operator|>
literal|0
operator|&&
name|face
operator|->
name|vertical
operator|.
name|long_metrics
argument_list|)
expr_stmt|;
else|#
directive|else
name|has_vertical_info
operator|=
name|FT_BOOL
argument_list|(
name|face
operator|->
name|vertical_info
operator|&&
name|face
operator|->
name|vertical
operator|.
name|number_Of_VMetrics
operator|>
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* get the vertical metrics from the vtmx table if we have one */
if|if
condition|(
name|has_vertical_info
condition|)
block|{
name|FT_Short
name|vertBearingY
init|=
literal|0
decl_stmt|;
name|FT_UShort
name|vertAdvance
init|=
literal|0
decl_stmt|;
operator|(
operator|(
name|SFNT_Service
operator|)
name|face
operator|->
name|sfnt
operator|)
operator|->
name|get_metrics
argument_list|(
name|face
argument_list|,
literal|1
argument_list|,
name|glyph_index
argument_list|,
operator|&
name|vertBearingY
argument_list|,
operator|&
name|vertAdvance
argument_list|)
expr_stmt|;
name|metrics
operator|->
name|vertBearingY
operator|=
name|vertBearingY
expr_stmt|;
name|metrics
operator|->
name|vertAdvance
operator|=
name|vertAdvance
expr_stmt|;
block|}
else|else
block|{
comment|/* make up vertical ones */
if|if
condition|(
name|face
operator|->
name|os2
operator|.
name|version
operator|!=
literal|0xFFFFU
condition|)
name|metrics
operator|->
name|vertAdvance
operator|=
call|(
name|FT_Pos
call|)
argument_list|(
name|face
operator|->
name|os2
operator|.
name|sTypoAscender
operator|-
name|face
operator|->
name|os2
operator|.
name|sTypoDescender
argument_list|)
expr_stmt|;
else|else
name|metrics
operator|->
name|vertAdvance
operator|=
call|(
name|FT_Pos
call|)
argument_list|(
name|face
operator|->
name|horizontal
operator|.
name|Ascender
operator|-
name|face
operator|->
name|horizontal
operator|.
name|Descender
argument_list|)
expr_stmt|;
block|}
name|glyph
operator|->
name|root
operator|.
name|linearVertAdvance
operator|=
name|metrics
operator|->
name|vertAdvance
expr_stmt|;
name|glyph
operator|->
name|root
operator|.
name|format
operator|=
name|FT_GLYPH_FORMAT_OUTLINE
expr_stmt|;
name|glyph
operator|->
name|root
operator|.
name|outline
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|size
operator|&&
name|size
operator|->
name|root
operator|.
name|metrics
operator|.
name|y_ppem
operator|<
literal|24
condition|)
name|glyph
operator|->
name|root
operator|.
name|outline
operator|.
name|flags
operator||=
name|FT_OUTLINE_HIGH_PRECISION
expr_stmt|;
name|glyph
operator|->
name|root
operator|.
name|outline
operator|.
name|flags
operator||=
name|FT_OUTLINE_REVERSE_FILL
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|font_matrix
operator|.
name|xx
operator|==
literal|0x10000L
operator|&&
name|font_matrix
operator|.
name|yy
operator|==
literal|0x10000L
operator|&&
name|font_matrix
operator|.
name|xy
operator|==
literal|0
operator|&&
name|font_matrix
operator|.
name|yx
operator|==
literal|0
operator|)
condition|)
name|FT_Outline_Transform
argument_list|(
operator|&
name|glyph
operator|->
name|root
operator|.
name|outline
argument_list|,
operator|&
name|font_matrix
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|font_offset
operator|.
name|x
operator|==
literal|0
operator|&&
name|font_offset
operator|.
name|y
operator|==
literal|0
operator|)
condition|)
name|FT_Outline_Translate
argument_list|(
operator|&
name|glyph
operator|->
name|root
operator|.
name|outline
argument_list|,
name|font_offset
operator|.
name|x
argument_list|,
name|font_offset
operator|.
name|y
argument_list|)
expr_stmt|;
name|advance
operator|.
name|x
operator|=
name|metrics
operator|->
name|horiAdvance
expr_stmt|;
name|advance
operator|.
name|y
operator|=
literal|0
expr_stmt|;
name|FT_Vector_Transform
argument_list|(
operator|&
name|advance
argument_list|,
operator|&
name|font_matrix
argument_list|)
expr_stmt|;
name|metrics
operator|->
name|horiAdvance
operator|=
name|advance
operator|.
name|x
operator|+
name|font_offset
operator|.
name|x
expr_stmt|;
name|advance
operator|.
name|x
operator|=
literal|0
expr_stmt|;
name|advance
operator|.
name|y
operator|=
name|metrics
operator|->
name|vertAdvance
expr_stmt|;
name|FT_Vector_Transform
argument_list|(
operator|&
name|advance
argument_list|,
operator|&
name|font_matrix
argument_list|)
expr_stmt|;
name|metrics
operator|->
name|vertAdvance
operator|=
name|advance
operator|.
name|y
operator|+
name|font_offset
operator|.
name|y
expr_stmt|;
if|if
condition|(
operator|(
name|load_flags
operator|&
name|FT_LOAD_NO_SCALE
operator|)
operator|==
literal|0
operator|||
name|force_scaling
condition|)
block|{
comment|/* scale the outline and the metrics */
name|FT_Int
name|n
decl_stmt|;
name|FT_Outline
modifier|*
name|cur
init|=
operator|&
name|glyph
operator|->
name|root
operator|.
name|outline
decl_stmt|;
name|FT_Vector
modifier|*
name|vec
init|=
name|cur
operator|->
name|points
decl_stmt|;
name|FT_Fixed
name|x_scale
init|=
name|glyph
operator|->
name|x_scale
decl_stmt|;
name|FT_Fixed
name|y_scale
init|=
name|glyph
operator|->
name|y_scale
decl_stmt|;
comment|/* First of all, scale the points */
if|if
condition|(
operator|!
name|hinting
operator|||
operator|!
name|decoder
operator|.
name|builder
operator|.
name|hints_funcs
condition|)
for|for
control|(
name|n
operator|=
name|cur
operator|->
name|n_points
init|;
name|n
operator|>
literal|0
condition|;
name|n
operator|--
operator|,
name|vec
operator|++
control|)
block|{
name|vec
operator|->
name|x
operator|=
name|FT_MulFix
argument_list|(
name|vec
operator|->
name|x
argument_list|,
name|x_scale
argument_list|)
expr_stmt|;
name|vec
operator|->
name|y
operator|=
name|FT_MulFix
argument_list|(
name|vec
operator|->
name|y
argument_list|,
name|y_scale
argument_list|)
expr_stmt|;
block|}
comment|/* Then scale the metrics */
name|metrics
operator|->
name|horiAdvance
operator|=
name|FT_MulFix
argument_list|(
name|metrics
operator|->
name|horiAdvance
argument_list|,
name|x_scale
argument_list|)
expr_stmt|;
name|metrics
operator|->
name|vertAdvance
operator|=
name|FT_MulFix
argument_list|(
name|metrics
operator|->
name|vertAdvance
argument_list|,
name|y_scale
argument_list|)
expr_stmt|;
block|}
comment|/* compute the other metrics */
name|FT_Outline_Get_CBox
argument_list|(
operator|&
name|glyph
operator|->
name|root
operator|.
name|outline
argument_list|,
operator|&
name|cbox
argument_list|)
expr_stmt|;
name|metrics
operator|->
name|width
operator|=
name|cbox
operator|.
name|xMax
operator|-
name|cbox
operator|.
name|xMin
expr_stmt|;
name|metrics
operator|->
name|height
operator|=
name|cbox
operator|.
name|yMax
operator|-
name|cbox
operator|.
name|yMin
expr_stmt|;
name|metrics
operator|->
name|horiBearingX
operator|=
name|cbox
operator|.
name|xMin
expr_stmt|;
name|metrics
operator|->
name|horiBearingY
operator|=
name|cbox
operator|.
name|yMax
expr_stmt|;
if|if
condition|(
name|has_vertical_info
condition|)
name|metrics
operator|->
name|vertBearingX
operator|=
name|metrics
operator|->
name|horiBearingX
operator|-
name|metrics
operator|->
name|horiAdvance
operator|/
literal|2
expr_stmt|;
else|else
block|{
if|if
condition|(
name|load_flags
operator|&
name|FT_LOAD_VERTICAL_LAYOUT
condition|)
name|ft_synthesize_vertical_metrics
argument_list|(
name|metrics
argument_list|,
name|metrics
operator|->
name|vertAdvance
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/* END */
end_comment
end_unit
