begin_unit
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  cffobjs.c                                                              */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*    OpenType objects manager (body).                                     */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 by */
end_comment
begin_comment
comment|/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  This file is part of the FreeType project, and may only be used,       */
end_comment
begin_comment
comment|/*  modified, and distributed under the terms of the FreeType project      */
end_comment
begin_comment
comment|/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
end_comment
begin_comment
comment|/*  this file you indicate that you have read the license and              */
end_comment
begin_comment
comment|/*  understand and accept it fully.                                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<ft2build.h>
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_DEBUG_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_CALC_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_STREAM_H
end_include
begin_include
include|#
directive|include
include|FT_ERRORS_H
end_include
begin_include
include|#
directive|include
include|FT_TRUETYPE_IDS_H
end_include
begin_include
include|#
directive|include
include|FT_TRUETYPE_TAGS_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_SFNT_H
end_include
begin_include
include|#
directive|include
include|FT_SERVICE_POSTSCRIPT_CMAPS_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_POSTSCRIPT_HINTS_H
end_include
begin_include
include|#
directive|include
file|"cffobjs.h"
end_include
begin_include
include|#
directive|include
file|"cffload.h"
end_include
begin_include
include|#
directive|include
file|"cffcmap.h"
end_include
begin_include
include|#
directive|include
file|"cfferrs.h"
end_include
begin_include
include|#
directive|include
file|"cffpic.h"
end_include
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
end_comment
begin_comment
comment|/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
end_comment
begin_comment
comment|/* messages during execution.                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_undef
DECL|macro|FT_COMPONENT
undef|#
directive|undef
name|FT_COMPONENT
end_undef
begin_define
DECL|macro|FT_COMPONENT
define|#
directive|define
name|FT_COMPONENT
value|trace_cffobjs
end_define
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*                            SIZE FUNCTIONS                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*  Note that we store the global hints in the size's `internal' root    */
end_comment
begin_comment
comment|/*  field.                                                               */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_function
specifier|static
name|PSH_Globals_Funcs
DECL|function|cff_size_get_globals_funcs
name|cff_size_get_globals_funcs
parameter_list|(
name|CFF_Size
name|size
parameter_list|)
block|{
name|CFF_Face
name|face
init|=
operator|(
name|CFF_Face
operator|)
name|size
operator|->
name|root
operator|.
name|face
decl_stmt|;
name|CFF_Font
name|font
init|=
operator|(
name|CFF_Font
operator|)
name|face
operator|->
name|extra
operator|.
name|data
decl_stmt|;
name|PSHinter_Service
name|pshinter
init|=
operator|(
name|PSHinter_Service
operator|)
name|font
operator|->
name|pshinter
decl_stmt|;
name|FT_Module
name|module
decl_stmt|;
name|module
operator|=
name|FT_Get_Module
argument_list|(
name|size
operator|->
name|root
operator|.
name|face
operator|->
name|driver
operator|->
name|root
operator|.
name|library
argument_list|,
literal|"pshinter"
argument_list|)
expr_stmt|;
return|return
operator|(
name|module
operator|&&
name|pshinter
operator|&&
name|pshinter
operator|->
name|get_globals_funcs
operator|)
condition|?
name|pshinter
operator|->
name|get_globals_funcs
argument_list|(
name|module
argument_list|)
else|:
literal|0
return|;
block|}
end_function
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|cff_size_done
name|cff_size_done
argument_list|(
argument|FT_Size  cffsize
argument_list|)
end_macro
begin_comment
DECL|function|cff_size_done
comment|/* CFF_Size */
end_comment
begin_block
block|{
name|CFF_Size
name|size
init|=
operator|(
name|CFF_Size
operator|)
name|cffsize
decl_stmt|;
name|CFF_Face
name|face
init|=
operator|(
name|CFF_Face
operator|)
name|size
operator|->
name|root
operator|.
name|face
decl_stmt|;
name|CFF_Font
name|font
init|=
operator|(
name|CFF_Font
operator|)
name|face
operator|->
name|extra
operator|.
name|data
decl_stmt|;
name|CFF_Internal
name|internal
init|=
operator|(
name|CFF_Internal
operator|)
name|cffsize
operator|->
name|internal
decl_stmt|;
if|if
condition|(
name|internal
condition|)
block|{
name|PSH_Globals_Funcs
name|funcs
decl_stmt|;
name|funcs
operator|=
name|cff_size_get_globals_funcs
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|funcs
condition|)
block|{
name|FT_UInt
name|i
decl_stmt|;
name|funcs
operator|->
name|destroy
argument_list|(
name|internal
operator|->
name|topfont
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|font
operator|->
name|num_subfonts
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
name|funcs
operator|->
name|destroy
argument_list|(
name|internal
operator|->
name|subfonts
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* `internal' is freed by destroy_size (in ftobjs.c) */
block|}
block|}
end_block
begin_comment
comment|/* CFF and Type 1 private dictionaries have slightly different      */
end_comment
begin_comment
comment|/* structures; we need to synthesize a Type 1 dictionary on the fly */
end_comment
begin_function
specifier|static
name|void
DECL|function|cff_make_private_dict
name|cff_make_private_dict
parameter_list|(
name|CFF_SubFont
name|subfont
parameter_list|,
name|PS_Private
name|priv
parameter_list|)
block|{
name|CFF_Private
name|cpriv
init|=
operator|&
name|subfont
operator|->
name|private_dict
decl_stmt|;
name|FT_UInt
name|n
decl_stmt|,
name|count
decl_stmt|;
name|FT_MEM_ZERO
argument_list|(
name|priv
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|priv
argument_list|)
argument_list|)
expr_stmt|;
name|count
operator|=
name|priv
operator|->
name|num_blue_values
operator|=
name|cpriv
operator|->
name|num_blue_values
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
name|priv
operator|->
name|blue_values
index|[
name|n
index|]
operator|=
operator|(
name|FT_Short
operator|)
name|cpriv
operator|->
name|blue_values
index|[
name|n
index|]
expr_stmt|;
name|count
operator|=
name|priv
operator|->
name|num_other_blues
operator|=
name|cpriv
operator|->
name|num_other_blues
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
name|priv
operator|->
name|other_blues
index|[
name|n
index|]
operator|=
operator|(
name|FT_Short
operator|)
name|cpriv
operator|->
name|other_blues
index|[
name|n
index|]
expr_stmt|;
name|count
operator|=
name|priv
operator|->
name|num_family_blues
operator|=
name|cpriv
operator|->
name|num_family_blues
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
name|priv
operator|->
name|family_blues
index|[
name|n
index|]
operator|=
operator|(
name|FT_Short
operator|)
name|cpriv
operator|->
name|family_blues
index|[
name|n
index|]
expr_stmt|;
name|count
operator|=
name|priv
operator|->
name|num_family_other_blues
operator|=
name|cpriv
operator|->
name|num_family_other_blues
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
name|priv
operator|->
name|family_other_blues
index|[
name|n
index|]
operator|=
operator|(
name|FT_Short
operator|)
name|cpriv
operator|->
name|family_other_blues
index|[
name|n
index|]
expr_stmt|;
name|priv
operator|->
name|blue_scale
operator|=
name|cpriv
operator|->
name|blue_scale
expr_stmt|;
name|priv
operator|->
name|blue_shift
operator|=
operator|(
name|FT_Int
operator|)
name|cpriv
operator|->
name|blue_shift
expr_stmt|;
name|priv
operator|->
name|blue_fuzz
operator|=
operator|(
name|FT_Int
operator|)
name|cpriv
operator|->
name|blue_fuzz
expr_stmt|;
name|priv
operator|->
name|standard_width
index|[
literal|0
index|]
operator|=
operator|(
name|FT_UShort
operator|)
name|cpriv
operator|->
name|standard_width
expr_stmt|;
name|priv
operator|->
name|standard_height
index|[
literal|0
index|]
operator|=
operator|(
name|FT_UShort
operator|)
name|cpriv
operator|->
name|standard_height
expr_stmt|;
name|count
operator|=
name|priv
operator|->
name|num_snap_widths
operator|=
name|cpriv
operator|->
name|num_snap_widths
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
name|priv
operator|->
name|snap_widths
index|[
name|n
index|]
operator|=
operator|(
name|FT_Short
operator|)
name|cpriv
operator|->
name|snap_widths
index|[
name|n
index|]
expr_stmt|;
name|count
operator|=
name|priv
operator|->
name|num_snap_heights
operator|=
name|cpriv
operator|->
name|num_snap_heights
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
name|priv
operator|->
name|snap_heights
index|[
name|n
index|]
operator|=
operator|(
name|FT_Short
operator|)
name|cpriv
operator|->
name|snap_heights
index|[
name|n
index|]
expr_stmt|;
name|priv
operator|->
name|force_bold
operator|=
name|cpriv
operator|->
name|force_bold
expr_stmt|;
name|priv
operator|->
name|language_group
operator|=
name|cpriv
operator|->
name|language_group
expr_stmt|;
name|priv
operator|->
name|lenIV
operator|=
name|cpriv
operator|->
name|lenIV
expr_stmt|;
block|}
end_function
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|cff_size_init
argument_list|(
argument|FT_Size  cffsize
argument_list|)
end_macro
begin_comment
comment|/* CFF_Size */
end_comment
begin_block
block|{
name|CFF_Size
name|size
init|=
operator|(
name|CFF_Size
operator|)
name|cffsize
decl_stmt|;
name|FT_Error
name|error
init|=
name|CFF_Err_Ok
decl_stmt|;
name|PSH_Globals_Funcs
name|funcs
init|=
name|cff_size_get_globals_funcs
argument_list|(
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|funcs
condition|)
block|{
name|CFF_Face
name|face
init|=
operator|(
name|CFF_Face
operator|)
name|cffsize
operator|->
name|face
decl_stmt|;
name|CFF_Font
name|font
init|=
operator|(
name|CFF_Font
operator|)
name|face
operator|->
name|extra
operator|.
name|data
decl_stmt|;
name|CFF_Internal
name|internal
decl_stmt|;
name|PS_PrivateRec
name|priv
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|cffsize
operator|->
name|face
operator|->
name|memory
decl_stmt|;
name|FT_UInt
name|i
decl_stmt|;
if|if
condition|(
name|FT_NEW
argument_list|(
name|internal
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|cff_make_private_dict
argument_list|(
operator|&
name|font
operator|->
name|top_font
argument_list|,
operator|&
name|priv
argument_list|)
expr_stmt|;
name|error
operator|=
name|funcs
operator|->
name|create
argument_list|(
name|cffsize
operator|->
name|face
operator|->
name|memory
argument_list|,
operator|&
name|priv
argument_list|,
operator|&
name|internal
operator|->
name|topfont
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
for|for
control|(
name|i
operator|=
name|font
operator|->
name|num_subfonts
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|CFF_SubFont
name|sub
init|=
name|font
operator|->
name|subfonts
index|[
name|i
operator|-
literal|1
index|]
decl_stmt|;
name|cff_make_private_dict
argument_list|(
name|sub
argument_list|,
operator|&
name|priv
argument_list|)
expr_stmt|;
name|error
operator|=
name|funcs
operator|->
name|create
argument_list|(
name|cffsize
operator|->
name|face
operator|->
name|memory
argument_list|,
operator|&
name|priv
argument_list|,
operator|&
name|internal
operator|->
name|subfonts
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
block|}
name|cffsize
operator|->
name|internal
operator|=
operator|(
name|FT_Size_Internal
operator|)
operator|(
name|void
operator|*
operator|)
name|internal
expr_stmt|;
block|}
name|size
operator|->
name|strike_index
operator|=
literal|0xFFFFFFFFUL
expr_stmt|;
name|Exit
label|:
return|return
name|error
return|;
block|}
end_block
begin_ifdef
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_EMBEDDED_BITMAPS
end_ifdef
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|cff_size_select
argument_list|(
argument|FT_Size   size
argument_list|,
argument|FT_ULong  strike_index
argument_list|)
end_macro
begin_block
block|{
name|CFF_Size
name|cffsize
init|=
operator|(
name|CFF_Size
operator|)
name|size
decl_stmt|;
name|PSH_Globals_Funcs
name|funcs
decl_stmt|;
name|cffsize
operator|->
name|strike_index
operator|=
name|strike_index
expr_stmt|;
name|FT_Select_Metrics
argument_list|(
name|size
operator|->
name|face
argument_list|,
name|strike_index
argument_list|)
expr_stmt|;
name|funcs
operator|=
name|cff_size_get_globals_funcs
argument_list|(
name|cffsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|funcs
condition|)
block|{
name|CFF_Face
name|face
init|=
operator|(
name|CFF_Face
operator|)
name|size
operator|->
name|face
decl_stmt|;
name|CFF_Font
name|font
init|=
operator|(
name|CFF_Font
operator|)
name|face
operator|->
name|extra
operator|.
name|data
decl_stmt|;
name|CFF_Internal
name|internal
init|=
operator|(
name|CFF_Internal
operator|)
name|size
operator|->
name|internal
decl_stmt|;
name|FT_ULong
name|top_upm
init|=
name|font
operator|->
name|top_font
operator|.
name|font_dict
operator|.
name|units_per_em
decl_stmt|;
name|FT_UInt
name|i
decl_stmt|;
name|funcs
operator|->
name|set_scale
argument_list|(
name|internal
operator|->
name|topfont
argument_list|,
name|size
operator|->
name|metrics
operator|.
name|x_scale
argument_list|,
name|size
operator|->
name|metrics
operator|.
name|y_scale
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|font
operator|->
name|num_subfonts
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|CFF_SubFont
name|sub
init|=
name|font
operator|->
name|subfonts
index|[
name|i
operator|-
literal|1
index|]
decl_stmt|;
name|FT_ULong
name|sub_upm
init|=
name|sub
operator|->
name|font_dict
operator|.
name|units_per_em
decl_stmt|;
name|FT_Pos
name|x_scale
decl_stmt|,
name|y_scale
decl_stmt|;
if|if
condition|(
name|top_upm
operator|!=
name|sub_upm
condition|)
block|{
name|x_scale
operator|=
name|FT_MulDiv
argument_list|(
name|size
operator|->
name|metrics
operator|.
name|x_scale
argument_list|,
name|top_upm
argument_list|,
name|sub_upm
argument_list|)
expr_stmt|;
name|y_scale
operator|=
name|FT_MulDiv
argument_list|(
name|size
operator|->
name|metrics
operator|.
name|y_scale
argument_list|,
name|top_upm
argument_list|,
name|sub_upm
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|x_scale
operator|=
name|size
operator|->
name|metrics
operator|.
name|x_scale
expr_stmt|;
name|y_scale
operator|=
name|size
operator|->
name|metrics
operator|.
name|y_scale
expr_stmt|;
block|}
name|funcs
operator|->
name|set_scale
argument_list|(
name|internal
operator|->
name|subfonts
index|[
name|i
operator|-
literal|1
index|]
argument_list|,
name|x_scale
argument_list|,
name|y_scale
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|CFF_Err_Ok
return|;
block|}
end_block
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* TT_CONFIG_OPTION_EMBEDDED_BITMAPS */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|cff_size_request
argument_list|(
argument|FT_Size          size
argument_list|,
argument|FT_Size_Request  req
argument_list|)
end_macro
begin_block
block|{
name|CFF_Size
name|cffsize
init|=
operator|(
name|CFF_Size
operator|)
name|size
decl_stmt|;
name|PSH_Globals_Funcs
name|funcs
decl_stmt|;
ifdef|#
directive|ifdef
name|TT_CONFIG_OPTION_EMBEDDED_BITMAPS
if|if
condition|(
name|FT_HAS_FIXED_SIZES
argument_list|(
name|size
operator|->
name|face
argument_list|)
condition|)
block|{
name|CFF_Face
name|cffface
init|=
operator|(
name|CFF_Face
operator|)
name|size
operator|->
name|face
decl_stmt|;
name|SFNT_Service
name|sfnt
init|=
operator|(
name|SFNT_Service
operator|)
name|cffface
operator|->
name|sfnt
decl_stmt|;
name|FT_ULong
name|strike_index
decl_stmt|;
if|if
condition|(
name|sfnt
operator|->
name|set_sbit_strike
argument_list|(
name|cffface
argument_list|,
name|req
argument_list|,
operator|&
name|strike_index
argument_list|)
condition|)
name|cffsize
operator|->
name|strike_index
operator|=
literal|0xFFFFFFFFUL
expr_stmt|;
else|else
return|return
name|cff_size_select
argument_list|(
name|size
argument_list|,
name|strike_index
argument_list|)
return|;
block|}
endif|#
directive|endif
comment|/* TT_CONFIG_OPTION_EMBEDDED_BITMAPS */
name|FT_Request_Metrics
argument_list|(
name|size
operator|->
name|face
argument_list|,
name|req
argument_list|)
expr_stmt|;
name|funcs
operator|=
name|cff_size_get_globals_funcs
argument_list|(
name|cffsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|funcs
condition|)
block|{
name|CFF_Face
name|cffface
init|=
operator|(
name|CFF_Face
operator|)
name|size
operator|->
name|face
decl_stmt|;
name|CFF_Font
name|font
init|=
operator|(
name|CFF_Font
operator|)
name|cffface
operator|->
name|extra
operator|.
name|data
decl_stmt|;
name|CFF_Internal
name|internal
init|=
operator|(
name|CFF_Internal
operator|)
name|size
operator|->
name|internal
decl_stmt|;
name|FT_ULong
name|top_upm
init|=
name|font
operator|->
name|top_font
operator|.
name|font_dict
operator|.
name|units_per_em
decl_stmt|;
name|FT_UInt
name|i
decl_stmt|;
name|funcs
operator|->
name|set_scale
argument_list|(
name|internal
operator|->
name|topfont
argument_list|,
name|size
operator|->
name|metrics
operator|.
name|x_scale
argument_list|,
name|size
operator|->
name|metrics
operator|.
name|y_scale
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|font
operator|->
name|num_subfonts
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|CFF_SubFont
name|sub
init|=
name|font
operator|->
name|subfonts
index|[
name|i
operator|-
literal|1
index|]
decl_stmt|;
name|FT_ULong
name|sub_upm
init|=
name|sub
operator|->
name|font_dict
operator|.
name|units_per_em
decl_stmt|;
name|FT_Pos
name|x_scale
decl_stmt|,
name|y_scale
decl_stmt|;
if|if
condition|(
name|top_upm
operator|!=
name|sub_upm
condition|)
block|{
name|x_scale
operator|=
name|FT_MulDiv
argument_list|(
name|size
operator|->
name|metrics
operator|.
name|x_scale
argument_list|,
name|top_upm
argument_list|,
name|sub_upm
argument_list|)
expr_stmt|;
name|y_scale
operator|=
name|FT_MulDiv
argument_list|(
name|size
operator|->
name|metrics
operator|.
name|y_scale
argument_list|,
name|top_upm
argument_list|,
name|sub_upm
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|x_scale
operator|=
name|size
operator|->
name|metrics
operator|.
name|x_scale
expr_stmt|;
name|y_scale
operator|=
name|size
operator|->
name|metrics
operator|.
name|y_scale
expr_stmt|;
block|}
name|funcs
operator|->
name|set_scale
argument_list|(
name|internal
operator|->
name|subfonts
index|[
name|i
operator|-
literal|1
index|]
argument_list|,
name|x_scale
argument_list|,
name|y_scale
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|CFF_Err_Ok
return|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*                            SLOT  FUNCTIONS                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|cff_slot_done
name|cff_slot_done
argument_list|(
argument|FT_GlyphSlot  slot
argument_list|)
end_macro
begin_block
block|{
name|slot
operator|->
name|internal
operator|->
name|glyph_hints
operator|=
literal|0
expr_stmt|;
block|}
end_block
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|cff_slot_init
argument_list|(
argument|FT_GlyphSlot  slot
argument_list|)
end_macro
begin_block
block|{
name|CFF_Face
name|face
init|=
operator|(
name|CFF_Face
operator|)
name|slot
operator|->
name|face
decl_stmt|;
name|CFF_Font
name|font
init|=
operator|(
name|CFF_Font
operator|)
name|face
operator|->
name|extra
operator|.
name|data
decl_stmt|;
name|PSHinter_Service
name|pshinter
init|=
operator|(
name|PSHinter_Service
operator|)
name|font
operator|->
name|pshinter
decl_stmt|;
if|if
condition|(
name|pshinter
condition|)
block|{
name|FT_Module
name|module
decl_stmt|;
name|module
operator|=
name|FT_Get_Module
argument_list|(
name|slot
operator|->
name|face
operator|->
name|driver
operator|->
name|root
operator|.
name|library
argument_list|,
literal|"pshinter"
argument_list|)
expr_stmt|;
if|if
condition|(
name|module
condition|)
block|{
name|T2_Hints_Funcs
name|funcs
decl_stmt|;
name|funcs
operator|=
name|pshinter
operator|->
name|get_t2_funcs
argument_list|(
name|module
argument_list|)
expr_stmt|;
name|slot
operator|->
name|internal
operator|->
name|glyph_hints
operator|=
operator|(
name|void
operator|*
operator|)
name|funcs
expr_stmt|;
block|}
block|}
return|return
name|CFF_Err_Ok
return|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*                           FACE  FUNCTIONS                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_function
specifier|static
name|FT_String
modifier|*
DECL|function|cff_strcpy
name|cff_strcpy
parameter_list|(
name|FT_Memory
name|memory
parameter_list|,
specifier|const
name|FT_String
modifier|*
name|source
parameter_list|)
block|{
name|FT_Error
name|error
decl_stmt|;
name|FT_String
modifier|*
name|result
decl_stmt|;
operator|(
name|void
operator|)
name|FT_STRDUP
argument_list|(
name|result
argument_list|,
name|source
argument_list|)
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|error
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|cff_face_init
argument_list|(
argument|FT_Stream      stream
argument_list|,
argument|FT_Face        cffface
argument_list|,
comment|/* CFF_Face */
argument|FT_Int         face_index
argument_list|,
argument|FT_Int         num_params
argument_list|,
argument|FT_Parameter*  params
argument_list|)
end_macro
begin_block
block|{
name|CFF_Face
name|face
init|=
operator|(
name|CFF_Face
operator|)
name|cffface
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|SFNT_Service
name|sfnt
decl_stmt|;
name|FT_Service_PsCMaps
name|psnames
decl_stmt|;
name|PSHinter_Service
name|pshinter
decl_stmt|;
name|FT_Bool
name|pure_cff
init|=
literal|1
decl_stmt|;
name|FT_Bool
name|sfnt_format
init|=
literal|0
decl_stmt|;
name|FT_Library
name|library
init|=
name|cffface
operator|->
name|driver
operator|->
name|root
operator|.
name|library
decl_stmt|;
if|#
directive|if
literal|0
block|FT_FACE_FIND_GLOBAL_SERVICE( face, sfnt,     SFNT );     FT_FACE_FIND_GLOBAL_SERVICE( face, psnames,  POSTSCRIPT_NAMES );     FT_FACE_FIND_GLOBAL_SERVICE( face, pshinter, POSTSCRIPT_HINTER );      if ( !sfnt )       goto Bad_Format;
else|#
directive|else
name|sfnt
operator|=
operator|(
name|SFNT_Service
operator|)
name|FT_Get_Module_Interface
argument_list|(
name|library
argument_list|,
literal|"sfnt"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sfnt
condition|)
goto|goto
name|Bad_Format
goto|;
name|FT_FACE_FIND_GLOBAL_SERVICE
argument_list|(
name|face
argument_list|,
name|psnames
argument_list|,
name|POSTSCRIPT_CMAPS
argument_list|)
expr_stmt|;
name|pshinter
operator|=
operator|(
name|PSHinter_Service
operator|)
name|FT_Get_Module_Interface
argument_list|(
name|library
argument_list|,
literal|"pshinter"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* create input stream from resource */
if|if
condition|(
name|FT_STREAM_SEEK
argument_list|(
literal|0
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
comment|/* check whether we have a valid OpenType file */
name|error
operator|=
name|sfnt
operator|->
name|init_face
argument_list|(
name|stream
argument_list|,
name|face
argument_list|,
name|face_index
argument_list|,
name|num_params
argument_list|,
name|params
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
if|if
condition|(
name|face
operator|->
name|format_tag
operator|!=
name|TTAG_OTTO
condition|)
comment|/* `OTTO'; OpenType/CFF font */
block|{
name|FT_TRACE2
argument_list|(
operator|(
literal|"[not a valid OpenType/CFF font]\n"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|Bad_Format
goto|;
block|}
comment|/* if we are performing a simple font format check, exit immediately */
if|if
condition|(
name|face_index
operator|<
literal|0
condition|)
return|return
name|CFF_Err_Ok
return|;
comment|/* UNDOCUMENTED!  A CFF in an SFNT can have only a single font. */
if|if
condition|(
name|face_index
operator|>
literal|0
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"cff_face_init: invalid face index\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|CFF_Err_Invalid_Argument
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|sfnt_format
operator|=
literal|1
expr_stmt|;
comment|/* now, the font can be either an OpenType/CFF font, or an SVG CEF */
comment|/* font; in the latter case it doesn't have a `head' table         */
name|error
operator|=
name|face
operator|->
name|goto_table
argument_list|(
name|face
argument_list|,
name|TTAG_head
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|pure_cff
operator|=
literal|0
expr_stmt|;
comment|/* load font directory */
name|error
operator|=
name|sfnt
operator|->
name|load_face
argument_list|(
name|stream
argument_list|,
name|face
argument_list|,
literal|0
argument_list|,
name|num_params
argument_list|,
name|params
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
block|}
else|else
block|{
comment|/* load the `cmap' table explicitly */
name|error
operator|=
name|sfnt
operator|->
name|load_cmap
argument_list|(
name|face
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
comment|/* XXX: we don't load the GPOS table, as OpenType Layout     */
comment|/* support will be added later to a layout library on top of */
comment|/* FreeType 2                                                */
block|}
comment|/* now load the CFF part of the file */
name|error
operator|=
name|face
operator|->
name|goto_table
argument_list|(
name|face
argument_list|,
name|TTAG_CFF
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
block|}
else|else
block|{
comment|/* rewind to start of file; we are going to load a pure-CFF font */
if|if
condition|(
name|FT_STREAM_SEEK
argument_list|(
literal|0
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|error
operator|=
name|CFF_Err_Ok
expr_stmt|;
block|}
comment|/* now load and parse the CFF table in the file */
block|{
name|CFF_Font
name|cff
decl_stmt|;
name|CFF_FontRecDict
name|dict
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|cffface
operator|->
name|memory
decl_stmt|;
name|FT_Int32
name|flags
decl_stmt|;
name|FT_UInt
name|i
decl_stmt|;
if|if
condition|(
name|FT_NEW
argument_list|(
name|cff
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|face
operator|->
name|extra
operator|.
name|data
operator|=
name|cff
expr_stmt|;
name|error
operator|=
name|cff_font_load
argument_list|(
name|library
argument_list|,
name|stream
argument_list|,
name|face_index
argument_list|,
name|cff
argument_list|,
name|pure_cff
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|cff
operator|->
name|pshinter
operator|=
name|pshinter
expr_stmt|;
name|cff
operator|->
name|psnames
operator|=
operator|(
name|void
operator|*
operator|)
name|psnames
expr_stmt|;
name|cffface
operator|->
name|face_index
operator|=
name|face_index
expr_stmt|;
comment|/* Complement the root flags with some interesting information. */
comment|/* Note that this is only necessary for pure CFF and CEF fonts; */
comment|/* SFNT based fonts use the `name' table instead.               */
name|cffface
operator|->
name|num_glyphs
operator|=
name|cff
operator|->
name|num_glyphs
expr_stmt|;
name|dict
operator|=
operator|&
name|cff
operator|->
name|top_font
operator|.
name|font_dict
expr_stmt|;
comment|/* we need the `PSNames' module for CFF and CEF formats */
comment|/* which aren't CID-keyed                               */
if|if
condition|(
name|dict
operator|->
name|cid_registry
operator|==
literal|0xFFFFU
operator|&&
operator|!
name|psnames
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"cff_face_init:"
literal|" cannot open CFF& CEF fonts\n"
literal|"              "
literal|" without the `PSNames' module\n"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|Bad_Format
goto|;
block|}
if|if
condition|(
operator|!
name|dict
operator|->
name|units_per_em
condition|)
name|dict
operator|->
name|units_per_em
operator|=
name|pure_cff
condition|?
literal|1000
else|:
name|face
operator|->
name|root
operator|.
name|units_per_EM
expr_stmt|;
comment|/* Normalize the font matrix so that `matrix->xx' is 1; the */
comment|/* scaling is done with `units_per_em' then (at this point, */
comment|/* it already contains the scaling factor, but without      */
comment|/* normalization of the matrix).                            */
comment|/*                                                          */
comment|/* Note that the offsets must be expressed in integer font  */
comment|/* units.                                                   */
block|{
name|FT_Matrix
modifier|*
name|matrix
init|=
operator|&
name|dict
operator|->
name|font_matrix
decl_stmt|;
name|FT_Vector
modifier|*
name|offset
init|=
operator|&
name|dict
operator|->
name|font_offset
decl_stmt|;
name|FT_ULong
modifier|*
name|upm
init|=
operator|&
name|dict
operator|->
name|units_per_em
decl_stmt|;
name|FT_Fixed
name|temp
init|=
name|FT_ABS
argument_list|(
name|matrix
operator|->
name|yy
argument_list|)
decl_stmt|;
if|if
condition|(
name|temp
operator|!=
literal|0x10000L
condition|)
block|{
operator|*
name|upm
operator|=
name|FT_DivFix
argument_list|(
operator|*
name|upm
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|matrix
operator|->
name|xx
operator|=
name|FT_DivFix
argument_list|(
name|matrix
operator|->
name|xx
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|matrix
operator|->
name|yx
operator|=
name|FT_DivFix
argument_list|(
name|matrix
operator|->
name|yx
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|matrix
operator|->
name|xy
operator|=
name|FT_DivFix
argument_list|(
name|matrix
operator|->
name|xy
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|matrix
operator|->
name|yy
operator|=
name|FT_DivFix
argument_list|(
name|matrix
operator|->
name|yy
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|offset
operator|->
name|x
operator|=
name|FT_DivFix
argument_list|(
name|offset
operator|->
name|x
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|offset
operator|->
name|y
operator|=
name|FT_DivFix
argument_list|(
name|offset
operator|->
name|y
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
name|offset
operator|->
name|x
operator|>>=
literal|16
expr_stmt|;
name|offset
operator|->
name|y
operator|>>=
literal|16
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|cff
operator|->
name|num_subfonts
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|CFF_FontRecDict
name|sub
init|=
operator|&
name|cff
operator|->
name|subfonts
index|[
name|i
operator|-
literal|1
index|]
operator|->
name|font_dict
decl_stmt|;
name|CFF_FontRecDict
name|top
init|=
operator|&
name|cff
operator|->
name|top_font
operator|.
name|font_dict
decl_stmt|;
name|FT_Matrix
modifier|*
name|matrix
decl_stmt|;
name|FT_Vector
modifier|*
name|offset
decl_stmt|;
name|FT_ULong
modifier|*
name|upm
decl_stmt|;
name|FT_Fixed
name|temp
decl_stmt|;
if|if
condition|(
name|sub
operator|->
name|units_per_em
condition|)
block|{
name|FT_Long
name|scaling
decl_stmt|;
if|if
condition|(
name|top
operator|->
name|units_per_em
operator|>
literal|1
operator|&&
name|sub
operator|->
name|units_per_em
operator|>
literal|1
condition|)
name|scaling
operator|=
name|FT_MIN
argument_list|(
name|top
operator|->
name|units_per_em
argument_list|,
name|sub
operator|->
name|units_per_em
argument_list|)
expr_stmt|;
else|else
name|scaling
operator|=
literal|1
expr_stmt|;
name|FT_Matrix_Multiply_Scaled
argument_list|(
operator|&
name|top
operator|->
name|font_matrix
argument_list|,
operator|&
name|sub
operator|->
name|font_matrix
argument_list|,
name|scaling
argument_list|)
expr_stmt|;
name|FT_Vector_Transform_Scaled
argument_list|(
operator|&
name|sub
operator|->
name|font_offset
argument_list|,
operator|&
name|top
operator|->
name|font_matrix
argument_list|,
name|scaling
argument_list|)
expr_stmt|;
name|sub
operator|->
name|units_per_em
operator|=
name|FT_MulDiv
argument_list|(
name|sub
operator|->
name|units_per_em
argument_list|,
name|top
operator|->
name|units_per_em
argument_list|,
name|scaling
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sub
operator|->
name|font_matrix
operator|=
name|top
operator|->
name|font_matrix
expr_stmt|;
name|sub
operator|->
name|font_offset
operator|=
name|top
operator|->
name|font_offset
expr_stmt|;
name|sub
operator|->
name|units_per_em
operator|=
name|top
operator|->
name|units_per_em
expr_stmt|;
block|}
name|matrix
operator|=
operator|&
name|sub
operator|->
name|font_matrix
expr_stmt|;
name|offset
operator|=
operator|&
name|sub
operator|->
name|font_offset
expr_stmt|;
name|upm
operator|=
operator|&
name|sub
operator|->
name|units_per_em
expr_stmt|;
name|temp
operator|=
name|FT_ABS
argument_list|(
name|matrix
operator|->
name|yy
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
literal|0x10000L
condition|)
block|{
operator|*
name|upm
operator|=
name|FT_DivFix
argument_list|(
operator|*
name|upm
argument_list|,
name|temp
argument_list|)
expr_stmt|;
comment|/* if *upm is larger than 100*1000 we divide by 1000 --     */
comment|/* this can happen if e.g. there is no top-font FontMatrix  */
comment|/* and the subfont FontMatrix already contains the complete */
comment|/* scaling for the subfont (see section 5.11 of the PLRM)   */
comment|/* 100 is a heuristic value */
if|if
condition|(
operator|*
name|upm
operator|>
literal|100L
operator|*
literal|1000L
condition|)
operator|*
name|upm
operator|=
operator|(
operator|*
name|upm
operator|+
literal|500
operator|)
operator|/
literal|1000
expr_stmt|;
name|matrix
operator|->
name|xx
operator|=
name|FT_DivFix
argument_list|(
name|matrix
operator|->
name|xx
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|matrix
operator|->
name|yx
operator|=
name|FT_DivFix
argument_list|(
name|matrix
operator|->
name|yx
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|matrix
operator|->
name|xy
operator|=
name|FT_DivFix
argument_list|(
name|matrix
operator|->
name|xy
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|matrix
operator|->
name|yy
operator|=
name|FT_DivFix
argument_list|(
name|matrix
operator|->
name|yy
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|offset
operator|->
name|x
operator|=
name|FT_DivFix
argument_list|(
name|offset
operator|->
name|x
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|offset
operator|->
name|y
operator|=
name|FT_DivFix
argument_list|(
name|offset
operator|->
name|y
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
name|offset
operator|->
name|x
operator|>>=
literal|16
expr_stmt|;
name|offset
operator|->
name|y
operator|>>=
literal|16
expr_stmt|;
block|}
if|if
condition|(
name|pure_cff
condition|)
block|{
name|char
modifier|*
name|style_name
init|=
name|NULL
decl_stmt|;
comment|/* set up num_faces */
name|cffface
operator|->
name|num_faces
operator|=
name|cff
operator|->
name|num_faces
expr_stmt|;
comment|/* compute number of glyphs */
if|if
condition|(
name|dict
operator|->
name|cid_registry
operator|!=
literal|0xFFFFU
condition|)
name|cffface
operator|->
name|num_glyphs
operator|=
name|cff
operator|->
name|charset
operator|.
name|max_cid
expr_stmt|;
else|else
name|cffface
operator|->
name|num_glyphs
operator|=
name|cff
operator|->
name|charstrings_index
operator|.
name|count
expr_stmt|;
comment|/* set global bbox, as well as EM size */
name|cffface
operator|->
name|bbox
operator|.
name|xMin
operator|=
name|dict
operator|->
name|font_bbox
operator|.
name|xMin
operator|>>
literal|16
expr_stmt|;
name|cffface
operator|->
name|bbox
operator|.
name|yMin
operator|=
name|dict
operator|->
name|font_bbox
operator|.
name|yMin
operator|>>
literal|16
expr_stmt|;
comment|/* no `U' suffix here to 0xFFFF! */
name|cffface
operator|->
name|bbox
operator|.
name|xMax
operator|=
operator|(
name|dict
operator|->
name|font_bbox
operator|.
name|xMax
operator|+
literal|0xFFFF
operator|)
operator|>>
literal|16
expr_stmt|;
name|cffface
operator|->
name|bbox
operator|.
name|yMax
operator|=
operator|(
name|dict
operator|->
name|font_bbox
operator|.
name|yMax
operator|+
literal|0xFFFF
operator|)
operator|>>
literal|16
expr_stmt|;
name|cffface
operator|->
name|units_per_EM
operator|=
call|(
name|FT_UShort
call|)
argument_list|(
name|dict
operator|->
name|units_per_em
argument_list|)
expr_stmt|;
name|cffface
operator|->
name|ascender
operator|=
call|(
name|FT_Short
call|)
argument_list|(
name|cffface
operator|->
name|bbox
operator|.
name|yMax
argument_list|)
expr_stmt|;
name|cffface
operator|->
name|descender
operator|=
call|(
name|FT_Short
call|)
argument_list|(
name|cffface
operator|->
name|bbox
operator|.
name|yMin
argument_list|)
expr_stmt|;
name|cffface
operator|->
name|height
operator|=
call|(
name|FT_Short
call|)
argument_list|(
operator|(
name|cffface
operator|->
name|units_per_EM
operator|*
literal|12
operator|)
operator|/
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|cffface
operator|->
name|height
operator|<
name|cffface
operator|->
name|ascender
operator|-
name|cffface
operator|->
name|descender
condition|)
name|cffface
operator|->
name|height
operator|=
call|(
name|FT_Short
call|)
argument_list|(
name|cffface
operator|->
name|ascender
operator|-
name|cffface
operator|->
name|descender
argument_list|)
expr_stmt|;
name|cffface
operator|->
name|underline_position
operator|=
call|(
name|FT_Short
call|)
argument_list|(
name|dict
operator|->
name|underline_position
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|cffface
operator|->
name|underline_thickness
operator|=
call|(
name|FT_Short
call|)
argument_list|(
name|dict
operator|->
name|underline_thickness
operator|>>
literal|16
argument_list|)
expr_stmt|;
comment|/* retrieve font family& style name */
name|cffface
operator|->
name|family_name
operator|=
name|cff_index_get_name
argument_list|(
operator|&
name|cff
operator|->
name|name_index
argument_list|,
name|face_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|cffface
operator|->
name|family_name
condition|)
block|{
name|char
modifier|*
name|full
init|=
name|cff_index_get_sid_string
argument_list|(
operator|&
name|cff
operator|->
name|string_index
argument_list|,
name|dict
operator|->
name|full_name
argument_list|,
name|psnames
argument_list|)
decl_stmt|;
name|char
modifier|*
name|fullp
init|=
name|full
decl_stmt|;
name|char
modifier|*
name|family
init|=
name|cffface
operator|->
name|family_name
decl_stmt|;
name|char
modifier|*
name|family_name
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|dict
operator|->
name|family_name
condition|)
block|{
name|family_name
operator|=
name|cff_index_get_sid_string
argument_list|(
operator|&
name|cff
operator|->
name|string_index
argument_list|,
name|dict
operator|->
name|family_name
argument_list|,
name|psnames
argument_list|)
expr_stmt|;
if|if
condition|(
name|family_name
condition|)
name|family
operator|=
name|family_name
expr_stmt|;
block|}
comment|/* We try to extract the style name from the full name.   */
comment|/* We need to ignore spaces and dashes during the search. */
if|if
condition|(
name|full
operator|&&
name|family
condition|)
block|{
while|while
condition|(
operator|*
name|fullp
condition|)
block|{
comment|/* skip common characters at the start of both strings */
if|if
condition|(
operator|*
name|fullp
operator|==
operator|*
name|family
condition|)
block|{
name|family
operator|++
expr_stmt|;
name|fullp
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* ignore spaces and dashes in full name during comparison */
if|if
condition|(
operator|*
name|fullp
operator|==
literal|' '
operator|||
operator|*
name|fullp
operator|==
literal|'-'
condition|)
block|{
name|fullp
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* ignore spaces and dashes in family name during comparison */
if|if
condition|(
operator|*
name|family
operator|==
literal|' '
operator|||
operator|*
name|family
operator|==
literal|'-'
condition|)
block|{
name|family
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
operator|*
name|family
operator|&&
operator|*
name|fullp
condition|)
block|{
comment|/* The full name begins with the same characters as the  */
comment|/* family name, with spaces and dashes removed.  In this */
comment|/* case, the remaining string in `fullp' will be used as */
comment|/* the style name.                                       */
name|style_name
operator|=
name|cff_strcpy
argument_list|(
name|memory
argument_list|,
name|fullp
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|family_name
condition|)
name|FT_FREE
argument_list|(
name|family_name
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|full
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|char
modifier|*
name|cid_font_name
init|=
name|cff_index_get_sid_string
argument_list|(
operator|&
name|cff
operator|->
name|string_index
argument_list|,
name|dict
operator|->
name|cid_font_name
argument_list|,
name|psnames
argument_list|)
decl_stmt|;
comment|/* do we have a `/FontName' for a CID-keyed font? */
if|if
condition|(
name|cid_font_name
condition|)
name|cffface
operator|->
name|family_name
operator|=
name|cid_font_name
expr_stmt|;
block|}
if|if
condition|(
name|style_name
condition|)
name|cffface
operator|->
name|style_name
operator|=
name|style_name
expr_stmt|;
else|else
comment|/* assume "Regular" style if we don't know better */
name|cffface
operator|->
name|style_name
operator|=
name|cff_strcpy
argument_list|(
name|memory
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|"Regular"
argument_list|)
expr_stmt|;
comment|/*******************************************************************/
comment|/*                                                                 */
comment|/* Compute face flags.                                             */
comment|/*                                                                 */
name|flags
operator|=
call|(
name|FT_UInt32
call|)
argument_list|(
name|FT_FACE_FLAG_SCALABLE
operator||
comment|/* scalable outlines */
name|FT_FACE_FLAG_HORIZONTAL
operator||
comment|/* horizontal data   */
name|FT_FACE_FLAG_HINTER
argument_list|)
expr_stmt|;
comment|/* has native hinter */
if|if
condition|(
name|sfnt_format
condition|)
name|flags
operator||=
operator|(
name|FT_UInt32
operator|)
name|FT_FACE_FLAG_SFNT
expr_stmt|;
comment|/* fixed width font? */
if|if
condition|(
name|dict
operator|->
name|is_fixed_pitch
condition|)
name|flags
operator||=
operator|(
name|FT_UInt32
operator|)
name|FT_FACE_FLAG_FIXED_WIDTH
expr_stmt|;
comment|/* XXX: WE DO NOT SUPPORT KERNING METRICS IN THE GPOS TABLE FOR NOW */
if|#
directive|if
literal|0
comment|/* kerning available? */
block|if ( face->kern_pairs )           flags |= (FT_UInt32)FT_FACE_FLAG_KERNING;
endif|#
directive|endif
name|cffface
operator|->
name|face_flags
operator|=
name|flags
expr_stmt|;
comment|/*******************************************************************/
comment|/*                                                                 */
comment|/* Compute style flags.                                            */
comment|/*                                                                 */
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dict
operator|->
name|italic_angle
condition|)
name|flags
operator||=
name|FT_STYLE_FLAG_ITALIC
expr_stmt|;
block|{
name|char
modifier|*
name|weight
init|=
name|cff_index_get_sid_string
argument_list|(
operator|&
name|cff
operator|->
name|string_index
argument_list|,
name|dict
operator|->
name|weight
argument_list|,
name|psnames
argument_list|)
decl_stmt|;
if|if
condition|(
name|weight
condition|)
if|if
condition|(
operator|!
name|ft_strcmp
argument_list|(
name|weight
argument_list|,
literal|"Bold"
argument_list|)
operator|||
operator|!
name|ft_strcmp
argument_list|(
name|weight
argument_list|,
literal|"Black"
argument_list|)
condition|)
name|flags
operator||=
name|FT_STYLE_FLAG_BOLD
expr_stmt|;
name|FT_FREE
argument_list|(
name|weight
argument_list|)
expr_stmt|;
block|}
comment|/* double check */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|FT_STYLE_FLAG_BOLD
operator|)
operator|&&
name|cffface
operator|->
name|style_name
condition|)
if|if
condition|(
operator|!
name|ft_strncmp
argument_list|(
name|cffface
operator|->
name|style_name
argument_list|,
literal|"Bold"
argument_list|,
literal|4
argument_list|)
operator|||
operator|!
name|ft_strncmp
argument_list|(
name|cffface
operator|->
name|style_name
argument_list|,
literal|"Black"
argument_list|,
literal|5
argument_list|)
condition|)
name|flags
operator||=
name|FT_STYLE_FLAG_BOLD
expr_stmt|;
name|cffface
operator|->
name|style_flags
operator|=
name|flags
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|FT_CONFIG_OPTION_NO_GLYPH_NAMES
comment|/* CID-keyed CFF fonts don't have glyph names -- the SFNT loader */
comment|/* has unset this flag because of the 3.0 `post' table.          */
if|if
condition|(
name|dict
operator|->
name|cid_registry
operator|==
literal|0xFFFFU
condition|)
name|cffface
operator|->
name|face_flags
operator||=
name|FT_FACE_FLAG_GLYPH_NAMES
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|dict
operator|->
name|cid_registry
operator|!=
literal|0xFFFFU
operator|&&
name|pure_cff
condition|)
name|cffface
operator|->
name|face_flags
operator||=
name|FT_FACE_FLAG_CID_KEYED
expr_stmt|;
comment|/*******************************************************************/
comment|/*                                                                 */
comment|/* Compute char maps.                                              */
comment|/*                                                                 */
comment|/* Try to synthesize a Unicode charmap if there is none available */
comment|/* already.  If an OpenType font contains a Unicode "cmap", we    */
comment|/* will use it, whatever be in the CFF part of the file.          */
block|{
name|FT_CharMapRec
name|cmaprec
decl_stmt|;
name|FT_CharMap
name|cmap
decl_stmt|;
name|FT_UInt
name|nn
decl_stmt|;
name|CFF_Encoding
name|encoding
init|=
operator|&
name|cff
operator|->
name|encoding
decl_stmt|;
for|for
control|(
name|nn
operator|=
literal|0
init|;
name|nn
operator|<
operator|(
name|FT_UInt
operator|)
name|cffface
operator|->
name|num_charmaps
condition|;
name|nn
operator|++
control|)
block|{
name|cmap
operator|=
name|cffface
operator|->
name|charmaps
index|[
name|nn
index|]
expr_stmt|;
comment|/* Windows Unicode (3,1)? */
if|if
condition|(
name|cmap
operator|->
name|platform_id
operator|==
literal|3
operator|&&
name|cmap
operator|->
name|encoding_id
operator|==
literal|1
condition|)
goto|goto
name|Skip_Unicode
goto|;
comment|/* Deprecated Unicode platform id? */
if|if
condition|(
name|cmap
operator|->
name|platform_id
operator|==
literal|0
condition|)
goto|goto
name|Skip_Unicode
goto|;
comment|/* Standard Unicode (deprecated) */
block|}
comment|/* since CID-keyed fonts don't contain glyph names, we can't */
comment|/* construct a cmap                                          */
if|if
condition|(
name|pure_cff
operator|&&
name|cff
operator|->
name|top_font
operator|.
name|font_dict
operator|.
name|cid_registry
operator|!=
literal|0xFFFFU
condition|)
goto|goto
name|Exit
goto|;
comment|/* we didn't find a Unicode charmap -- synthesize one */
name|cmaprec
operator|.
name|face
operator|=
name|cffface
expr_stmt|;
name|cmaprec
operator|.
name|platform_id
operator|=
literal|3
expr_stmt|;
name|cmaprec
operator|.
name|encoding_id
operator|=
literal|1
expr_stmt|;
name|cmaprec
operator|.
name|encoding
operator|=
name|FT_ENCODING_UNICODE
expr_stmt|;
name|nn
operator|=
operator|(
name|FT_UInt
operator|)
name|cffface
operator|->
name|num_charmaps
expr_stmt|;
name|FT_CMap_New
argument_list|(
operator|&
name|FT_CFF_CMAP_UNICODE_CLASS_REC_GET
argument_list|,
name|NULL
argument_list|,
operator|&
name|cmaprec
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* if no Unicode charmap was previously selected, select this one */
if|if
condition|(
name|cffface
operator|->
name|charmap
operator|==
name|NULL
operator|&&
name|nn
operator|!=
operator|(
name|FT_UInt
operator|)
name|cffface
operator|->
name|num_charmaps
condition|)
name|cffface
operator|->
name|charmap
operator|=
name|cffface
operator|->
name|charmaps
index|[
name|nn
index|]
expr_stmt|;
name|Skip_Unicode
label|:
if|if
condition|(
name|encoding
operator|->
name|count
operator|>
literal|0
condition|)
block|{
name|FT_CMap_Class
name|clazz
decl_stmt|;
name|cmaprec
operator|.
name|face
operator|=
name|cffface
expr_stmt|;
name|cmaprec
operator|.
name|platform_id
operator|=
literal|7
expr_stmt|;
comment|/* Adobe platform id */
if|if
condition|(
name|encoding
operator|->
name|offset
operator|==
literal|0
condition|)
block|{
name|cmaprec
operator|.
name|encoding_id
operator|=
name|TT_ADOBE_ID_STANDARD
expr_stmt|;
name|cmaprec
operator|.
name|encoding
operator|=
name|FT_ENCODING_ADOBE_STANDARD
expr_stmt|;
name|clazz
operator|=
operator|&
name|FT_CFF_CMAP_ENCODING_CLASS_REC_GET
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|encoding
operator|->
name|offset
operator|==
literal|1
condition|)
block|{
name|cmaprec
operator|.
name|encoding_id
operator|=
name|TT_ADOBE_ID_EXPERT
expr_stmt|;
name|cmaprec
operator|.
name|encoding
operator|=
name|FT_ENCODING_ADOBE_EXPERT
expr_stmt|;
name|clazz
operator|=
operator|&
name|FT_CFF_CMAP_ENCODING_CLASS_REC_GET
expr_stmt|;
block|}
else|else
block|{
name|cmaprec
operator|.
name|encoding_id
operator|=
name|TT_ADOBE_ID_CUSTOM
expr_stmt|;
name|cmaprec
operator|.
name|encoding
operator|=
name|FT_ENCODING_ADOBE_CUSTOM
expr_stmt|;
name|clazz
operator|=
operator|&
name|FT_CFF_CMAP_ENCODING_CLASS_REC_GET
expr_stmt|;
block|}
name|FT_CMap_New
argument_list|(
name|clazz
argument_list|,
name|NULL
argument_list|,
operator|&
name|cmaprec
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|Exit
label|:
return|return
name|error
return|;
name|Bad_Format
label|:
name|error
operator|=
name|CFF_Err_Unknown_File_Format
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
end_block
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|cff_face_done
name|cff_face_done
argument_list|(
argument|FT_Face  cffface
argument_list|)
end_macro
begin_comment
DECL|function|cff_face_done
comment|/* CFF_Face */
end_comment
begin_block
block|{
name|CFF_Face
name|face
init|=
operator|(
name|CFF_Face
operator|)
name|cffface
decl_stmt|;
name|FT_Memory
name|memory
decl_stmt|;
name|SFNT_Service
name|sfnt
decl_stmt|;
if|if
condition|(
operator|!
name|face
condition|)
return|return;
name|memory
operator|=
name|cffface
operator|->
name|memory
expr_stmt|;
name|sfnt
operator|=
operator|(
name|SFNT_Service
operator|)
name|face
operator|->
name|sfnt
expr_stmt|;
if|if
condition|(
name|sfnt
condition|)
name|sfnt
operator|->
name|done_face
argument_list|(
name|face
argument_list|)
expr_stmt|;
block|{
name|CFF_Font
name|cff
init|=
operator|(
name|CFF_Font
operator|)
name|face
operator|->
name|extra
operator|.
name|data
decl_stmt|;
if|if
condition|(
name|cff
condition|)
block|{
name|cff_font_done
argument_list|(
name|cff
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|face
operator|->
name|extra
operator|.
name|data
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|cff_driver_init
argument_list|(
argument|FT_Module  module
argument_list|)
end_macro
begin_block
block|{
name|FT_UNUSED
argument_list|(
name|module
argument_list|)
expr_stmt|;
return|return
name|CFF_Err_Ok
return|;
block|}
end_block
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|cff_driver_done
name|cff_driver_done
argument_list|(
argument|FT_Module  module
argument_list|)
end_macro
begin_block
block|{
name|FT_UNUSED
argument_list|(
name|module
argument_list|)
expr_stmt|;
block|}
end_block
begin_comment
comment|/* END */
end_comment
end_unit
