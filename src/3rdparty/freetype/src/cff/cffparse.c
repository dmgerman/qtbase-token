begin_unit
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  cffparse.c                                                             */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*    CFF token stream parser (body)                                       */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  Copyright 1996-2001, 2002, 2003, 2004, 2007, 2008, 2009 by             */
end_comment
begin_comment
comment|/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  This file is part of the FreeType project, and may only be used,       */
end_comment
begin_comment
comment|/*  modified, and distributed under the terms of the FreeType project      */
end_comment
begin_comment
comment|/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
end_comment
begin_comment
comment|/*  this file you indicate that you have read the license and              */
end_comment
begin_comment
comment|/*  understand and accept it fully.                                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<ft2build.h>
end_include
begin_include
include|#
directive|include
file|"cffparse.h"
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_STREAM_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_DEBUG_H
end_include
begin_include
include|#
directive|include
file|"cfferrs.h"
end_include
begin_include
include|#
directive|include
file|"cffpic.h"
end_include
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
end_comment
begin_comment
comment|/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
end_comment
begin_comment
comment|/* messages during execution.                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_undef
DECL|macro|FT_COMPONENT
undef|#
directive|undef
name|FT_COMPONENT
end_undef
begin_define
DECL|macro|FT_COMPONENT
define|#
directive|define
name|FT_COMPONENT
value|trace_cffparse
end_define
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|cff_parser_init
name|cff_parser_init
argument_list|(
argument|CFF_Parser  parser
argument_list|,
argument|FT_UInt     code
argument_list|,
argument|void*       object
argument_list|,
argument|FT_Library  library
argument_list|)
end_macro
begin_block
block|{
name|FT_MEM_ZERO
argument_list|(
name|parser
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|parser
argument_list|)
argument_list|)
expr_stmt|;
name|parser
operator|->
name|top
operator|=
name|parser
operator|->
name|stack
expr_stmt|;
name|parser
operator|->
name|object_code
operator|=
name|code
expr_stmt|;
name|parser
operator|->
name|object
operator|=
name|object
expr_stmt|;
name|parser
operator|->
name|library
operator|=
name|library
expr_stmt|;
block|}
end_block
begin_comment
comment|/* read an integer */
end_comment
begin_function
specifier|static
name|FT_Long
DECL|function|cff_parse_integer
name|cff_parse_integer
parameter_list|(
name|FT_Byte
modifier|*
name|start
parameter_list|,
name|FT_Byte
modifier|*
name|limit
parameter_list|)
block|{
name|FT_Byte
modifier|*
name|p
init|=
name|start
decl_stmt|;
name|FT_Int
name|v
init|=
operator|*
name|p
operator|++
decl_stmt|;
name|FT_Long
name|val
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|v
operator|==
literal|28
condition|)
block|{
if|if
condition|(
name|p
operator|+
literal|2
operator|>
name|limit
condition|)
goto|goto
name|Bad
goto|;
name|val
operator|=
call|(
name|FT_Short
call|)
argument_list|(
operator|(
operator|(
name|FT_Int
operator|)
name|p
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator||
name|p
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|v
operator|==
literal|29
condition|)
block|{
if|if
condition|(
name|p
operator|+
literal|4
operator|>
name|limit
condition|)
goto|goto
name|Bad
goto|;
name|val
operator|=
operator|(
operator|(
name|FT_Long
operator|)
name|p
index|[
literal|0
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
name|FT_Long
operator|)
name|p
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|FT_Long
operator|)
name|p
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator||
name|p
index|[
literal|3
index|]
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|v
operator|<
literal|247
condition|)
block|{
name|val
operator|=
name|v
operator|-
literal|139
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|v
operator|<
literal|251
condition|)
block|{
if|if
condition|(
name|p
operator|+
literal|1
operator|>
name|limit
condition|)
goto|goto
name|Bad
goto|;
name|val
operator|=
operator|(
name|v
operator|-
literal|247
operator|)
operator|*
literal|256
operator|+
name|p
index|[
literal|0
index|]
operator|+
literal|108
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|p
operator|+
literal|1
operator|>
name|limit
condition|)
goto|goto
name|Bad
goto|;
name|val
operator|=
operator|-
operator|(
name|v
operator|-
literal|251
operator|)
operator|*
literal|256
operator|-
name|p
index|[
literal|0
index|]
operator|-
literal|108
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
name|Exit
label|:
return|return
name|val
return|;
name|Bad
label|:
name|val
operator|=
literal|0
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
end_function
begin_decl_stmt
DECL|variable|power_tens
specifier|static
specifier|const
name|FT_Long
name|power_tens
index|[]
init|=
block|{
literal|1L
block|,
literal|10L
block|,
literal|100L
block|,
literal|1000L
block|,
literal|10000L
block|,
literal|100000L
block|,
literal|1000000L
block|,
literal|10000000L
block|,
literal|100000000L
block|,
literal|1000000000L
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* read a real */
end_comment
begin_function
specifier|static
name|FT_Fixed
DECL|function|cff_parse_real
name|cff_parse_real
parameter_list|(
name|FT_Byte
modifier|*
name|start
parameter_list|,
name|FT_Byte
modifier|*
name|limit
parameter_list|,
name|FT_Long
name|power_ten
parameter_list|,
name|FT_Long
modifier|*
name|scaling
parameter_list|)
block|{
name|FT_Byte
modifier|*
name|p
init|=
name|start
decl_stmt|;
name|FT_UInt
name|nib
decl_stmt|;
name|FT_UInt
name|phase
decl_stmt|;
name|FT_Long
name|result
decl_stmt|,
name|number
decl_stmt|,
name|rest
decl_stmt|,
name|exponent
decl_stmt|;
name|FT_Int
name|sign
init|=
literal|0
decl_stmt|,
name|exponent_sign
init|=
literal|0
decl_stmt|;
name|FT_Long
name|exponent_add
decl_stmt|,
name|integer_length
decl_stmt|,
name|fraction_length
decl_stmt|;
if|if
condition|(
name|scaling
condition|)
operator|*
name|scaling
operator|=
literal|0
expr_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
name|number
operator|=
literal|0
expr_stmt|;
name|rest
operator|=
literal|0
expr_stmt|;
name|exponent
operator|=
literal|0
expr_stmt|;
name|exponent_add
operator|=
literal|0
expr_stmt|;
name|integer_length
operator|=
literal|0
expr_stmt|;
name|fraction_length
operator|=
literal|0
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|rest
argument_list|)
expr_stmt|;
comment|/* First of all, read the integer part. */
name|phase
operator|=
literal|4
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* If we entered this iteration with phase == 4, we need to */
comment|/* read a new byte.  This also skips past the initial 0x1E. */
if|if
condition|(
name|phase
condition|)
block|{
name|p
operator|++
expr_stmt|;
comment|/* Make sure we don't read past the end. */
if|if
condition|(
name|p
operator|>=
name|limit
condition|)
goto|goto
name|Exit
goto|;
block|}
comment|/* Get the nibble. */
name|nib
operator|=
operator|(
name|p
index|[
literal|0
index|]
operator|>>
name|phase
operator|)
operator|&
literal|0xF
expr_stmt|;
name|phase
operator|=
literal|4
operator|-
name|phase
expr_stmt|;
if|if
condition|(
name|nib
operator|==
literal|0xE
condition|)
name|sign
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|nib
operator|>
literal|9
condition|)
break|break;
else|else
block|{
comment|/* Increase exponent if we can't add the digit. */
if|if
condition|(
name|number
operator|>=
literal|0xCCCCCCCL
condition|)
name|exponent_add
operator|++
expr_stmt|;
comment|/* Skip leading zeros. */
elseif|else
if|if
condition|(
name|nib
operator|||
name|number
condition|)
block|{
name|integer_length
operator|++
expr_stmt|;
name|number
operator|=
name|number
operator|*
literal|10
operator|+
name|nib
expr_stmt|;
block|}
block|}
block|}
comment|/* Read fraction part, if any. */
if|if
condition|(
name|nib
operator|==
literal|0xa
condition|)
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* If we entered this iteration with phase == 4, we need */
comment|/* to read a new byte.                                   */
if|if
condition|(
name|phase
condition|)
block|{
name|p
operator|++
expr_stmt|;
comment|/* Make sure we don't read past the end. */
if|if
condition|(
name|p
operator|>=
name|limit
condition|)
goto|goto
name|Exit
goto|;
block|}
comment|/* Get the nibble. */
name|nib
operator|=
operator|(
name|p
index|[
literal|0
index|]
operator|>>
name|phase
operator|)
operator|&
literal|0xF
expr_stmt|;
name|phase
operator|=
literal|4
operator|-
name|phase
expr_stmt|;
if|if
condition|(
name|nib
operator|>=
literal|10
condition|)
break|break;
comment|/* Skip leading zeros if possible. */
if|if
condition|(
operator|!
name|nib
operator|&&
operator|!
name|number
condition|)
name|exponent_add
operator|--
expr_stmt|;
comment|/* Only add digit if we don't overflow. */
elseif|else
if|if
condition|(
name|number
operator|<
literal|0xCCCCCCCL
operator|&&
name|fraction_length
operator|<
literal|9
condition|)
block|{
name|fraction_length
operator|++
expr_stmt|;
name|number
operator|=
name|number
operator|*
literal|10
operator|+
name|nib
expr_stmt|;
block|}
block|}
comment|/* Read exponent, if any. */
if|if
condition|(
name|nib
operator|==
literal|12
condition|)
block|{
name|exponent_sign
operator|=
literal|1
expr_stmt|;
name|nib
operator|=
literal|11
expr_stmt|;
block|}
if|if
condition|(
name|nib
operator|==
literal|11
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* If we entered this iteration with phase == 4, */
comment|/* we need to read a new byte.                   */
if|if
condition|(
name|phase
condition|)
block|{
name|p
operator|++
expr_stmt|;
comment|/* Make sure we don't read past the end. */
if|if
condition|(
name|p
operator|>=
name|limit
condition|)
goto|goto
name|Exit
goto|;
block|}
comment|/* Get the nibble. */
name|nib
operator|=
operator|(
name|p
index|[
literal|0
index|]
operator|>>
name|phase
operator|)
operator|&
literal|0xF
expr_stmt|;
name|phase
operator|=
literal|4
operator|-
name|phase
expr_stmt|;
if|if
condition|(
name|nib
operator|>=
literal|10
condition|)
break|break;
name|exponent
operator|=
name|exponent
operator|*
literal|10
operator|+
name|nib
expr_stmt|;
comment|/* Arbitrarily limit exponent. */
if|if
condition|(
name|exponent
operator|>
literal|1000
condition|)
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|exponent_sign
condition|)
name|exponent
operator|=
operator|-
name|exponent
expr_stmt|;
block|}
comment|/* We don't check `power_ten' and `exponent_add'. */
name|exponent
operator|+=
name|power_ten
operator|+
name|exponent_add
expr_stmt|;
if|if
condition|(
name|scaling
condition|)
block|{
comment|/* Only use `fraction_length'. */
name|fraction_length
operator|+=
name|integer_length
expr_stmt|;
name|exponent
operator|+=
name|integer_length
expr_stmt|;
if|if
condition|(
name|fraction_length
operator|<=
literal|5
condition|)
block|{
if|if
condition|(
name|number
operator|>
literal|0x7FFFL
condition|)
block|{
name|result
operator|=
name|FT_DivFix
argument_list|(
name|number
argument_list|,
literal|10
argument_list|)
expr_stmt|;
operator|*
name|scaling
operator|=
name|exponent
operator|-
name|fraction_length
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|exponent
operator|>
literal|0
condition|)
block|{
name|FT_Long
name|new_fraction_length
decl_stmt|,
name|shift
decl_stmt|;
comment|/* Make `scaling' as small as possible. */
name|new_fraction_length
operator|=
name|FT_MIN
argument_list|(
name|exponent
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|exponent
operator|-=
name|new_fraction_length
expr_stmt|;
name|shift
operator|=
name|new_fraction_length
operator|-
name|fraction_length
expr_stmt|;
name|number
operator|*=
name|power_tens
index|[
name|shift
index|]
expr_stmt|;
if|if
condition|(
name|number
operator|>
literal|0x7FFFL
condition|)
block|{
name|number
operator|/=
literal|10
expr_stmt|;
name|exponent
operator|+=
literal|1
expr_stmt|;
block|}
block|}
else|else
name|exponent
operator|-=
name|fraction_length
expr_stmt|;
name|result
operator|=
name|number
operator|<<
literal|16
expr_stmt|;
operator|*
name|scaling
operator|=
name|exponent
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|number
operator|/
name|power_tens
index|[
name|fraction_length
operator|-
literal|5
index|]
operator|)
operator|>
literal|0x7FFFL
condition|)
block|{
name|result
operator|=
name|FT_DivFix
argument_list|(
name|number
argument_list|,
name|power_tens
index|[
name|fraction_length
operator|-
literal|4
index|]
argument_list|)
expr_stmt|;
operator|*
name|scaling
operator|=
name|exponent
operator|-
literal|4
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|FT_DivFix
argument_list|(
name|number
argument_list|,
name|power_tens
index|[
name|fraction_length
operator|-
literal|5
index|]
argument_list|)
expr_stmt|;
operator|*
name|scaling
operator|=
name|exponent
operator|-
literal|5
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|integer_length
operator|+=
name|exponent
expr_stmt|;
name|fraction_length
operator|-=
name|exponent
expr_stmt|;
comment|/* Check for overflow and underflow. */
if|if
condition|(
name|FT_ABS
argument_list|(
name|integer_length
argument_list|)
operator|>
literal|5
condition|)
goto|goto
name|Exit
goto|;
comment|/* Remove non-significant digits. */
if|if
condition|(
name|integer_length
operator|<
literal|0
condition|)
block|{
name|number
operator|/=
name|power_tens
index|[
operator|-
name|integer_length
index|]
expr_stmt|;
name|fraction_length
operator|+=
name|integer_length
expr_stmt|;
block|}
comment|/* Convert into 16.16 format. */
if|if
condition|(
name|fraction_length
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|number
operator|/
name|power_tens
index|[
name|fraction_length
index|]
operator|)
operator|>
literal|0x7FFFL
condition|)
goto|goto
name|Exit
goto|;
name|result
operator|=
name|FT_DivFix
argument_list|(
name|number
argument_list|,
name|power_tens
index|[
name|fraction_length
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|number
operator|*=
name|power_tens
index|[
operator|-
name|fraction_length
index|]
expr_stmt|;
if|if
condition|(
name|number
operator|>
literal|0x7FFFL
condition|)
goto|goto
name|Exit
goto|;
name|result
operator|=
name|number
operator|<<
literal|16
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sign
condition|)
name|result
operator|=
operator|-
name|result
expr_stmt|;
name|Exit
label|:
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/* read a number, either integer or real */
end_comment
begin_function
specifier|static
name|FT_Long
DECL|function|cff_parse_num
name|cff_parse_num
parameter_list|(
name|FT_Byte
modifier|*
modifier|*
name|d
parameter_list|)
block|{
return|return
operator|*
operator|*
name|d
operator|==
literal|30
condition|?
operator|(
name|cff_parse_real
argument_list|(
name|d
index|[
literal|0
index|]
argument_list|,
name|d
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
operator|>>
literal|16
operator|)
else|:
name|cff_parse_integer
argument_list|(
name|d
index|[
literal|0
index|]
argument_list|,
name|d
index|[
literal|1
index|]
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/* read a floating point number, either integer or real */
end_comment
begin_function
specifier|static
name|FT_Fixed
DECL|function|cff_parse_fixed
name|cff_parse_fixed
parameter_list|(
name|FT_Byte
modifier|*
modifier|*
name|d
parameter_list|)
block|{
return|return
operator|*
operator|*
name|d
operator|==
literal|30
condition|?
name|cff_parse_real
argument_list|(
name|d
index|[
literal|0
index|]
argument_list|,
name|d
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
else|:
name|cff_parse_integer
argument_list|(
name|d
index|[
literal|0
index|]
argument_list|,
name|d
index|[
literal|1
index|]
argument_list|)
operator|<<
literal|16
return|;
block|}
end_function
begin_comment
comment|/* read a floating point number, either integer or real, */
end_comment
begin_comment
comment|/* but return `10^scaling' times the number read in      */
end_comment
begin_function
specifier|static
name|FT_Fixed
DECL|function|cff_parse_fixed_scaled
name|cff_parse_fixed_scaled
parameter_list|(
name|FT_Byte
modifier|*
modifier|*
name|d
parameter_list|,
name|FT_Long
name|scaling
parameter_list|)
block|{
return|return
operator|*
operator|*
name|d
operator|==
literal|30
condition|?
name|cff_parse_real
argument_list|(
name|d
index|[
literal|0
index|]
argument_list|,
name|d
index|[
literal|1
index|]
argument_list|,
name|scaling
argument_list|,
name|NULL
argument_list|)
else|:
operator|(
name|cff_parse_integer
argument_list|(
name|d
index|[
literal|0
index|]
argument_list|,
name|d
index|[
literal|1
index|]
argument_list|)
operator|*
name|power_tens
index|[
name|scaling
index|]
operator|)
operator|<<
literal|16
return|;
block|}
end_function
begin_comment
comment|/* read a floating point number, either integer or real,     */
end_comment
begin_comment
comment|/* and return it as precise as possible -- `scaling' returns */
end_comment
begin_comment
comment|/* the scaling factor (as a power of 10)                     */
end_comment
begin_function
specifier|static
name|FT_Fixed
DECL|function|cff_parse_fixed_dynamic
name|cff_parse_fixed_dynamic
parameter_list|(
name|FT_Byte
modifier|*
modifier|*
name|d
parameter_list|,
name|FT_Long
modifier|*
name|scaling
parameter_list|)
block|{
name|FT_ASSERT
argument_list|(
name|scaling
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|d
operator|==
literal|30
condition|)
return|return
name|cff_parse_real
argument_list|(
name|d
index|[
literal|0
index|]
argument_list|,
name|d
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|,
name|scaling
argument_list|)
return|;
else|else
block|{
name|FT_Long
name|number
decl_stmt|;
name|FT_Int
name|integer_length
decl_stmt|;
name|number
operator|=
name|cff_parse_integer
argument_list|(
name|d
index|[
literal|0
index|]
argument_list|,
name|d
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|number
operator|>
literal|0x7FFFL
condition|)
block|{
for|for
control|(
name|integer_length
operator|=
literal|5
init|;
name|integer_length
operator|<
literal|10
condition|;
name|integer_length
operator|++
control|)
if|if
condition|(
name|number
operator|<
name|power_tens
index|[
name|integer_length
index|]
condition|)
break|break;
if|if
condition|(
operator|(
name|number
operator|/
name|power_tens
index|[
name|integer_length
operator|-
literal|5
index|]
operator|)
operator|>
literal|0x7FFFL
condition|)
block|{
operator|*
name|scaling
operator|=
name|integer_length
operator|-
literal|4
expr_stmt|;
return|return
name|FT_DivFix
argument_list|(
name|number
argument_list|,
name|power_tens
index|[
name|integer_length
operator|-
literal|4
index|]
argument_list|)
return|;
block|}
else|else
block|{
operator|*
name|scaling
operator|=
name|integer_length
operator|-
literal|5
expr_stmt|;
return|return
name|FT_DivFix
argument_list|(
name|number
argument_list|,
name|power_tens
index|[
name|integer_length
operator|-
literal|5
index|]
argument_list|)
return|;
block|}
block|}
else|else
block|{
operator|*
name|scaling
operator|=
literal|0
expr_stmt|;
return|return
name|number
operator|<<
literal|16
return|;
block|}
block|}
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|cff_parse_font_matrix
name|cff_parse_font_matrix
parameter_list|(
name|CFF_Parser
name|parser
parameter_list|)
block|{
name|CFF_FontRecDict
name|dict
init|=
operator|(
name|CFF_FontRecDict
operator|)
name|parser
operator|->
name|object
decl_stmt|;
name|FT_Matrix
modifier|*
name|matrix
init|=
operator|&
name|dict
operator|->
name|font_matrix
decl_stmt|;
name|FT_Vector
modifier|*
name|offset
init|=
operator|&
name|dict
operator|->
name|font_offset
decl_stmt|;
name|FT_ULong
modifier|*
name|upm
init|=
operator|&
name|dict
operator|->
name|units_per_em
decl_stmt|;
name|FT_Byte
modifier|*
modifier|*
name|data
init|=
name|parser
operator|->
name|stack
decl_stmt|;
name|FT_Error
name|error
init|=
name|CFF_Err_Stack_Underflow
decl_stmt|;
if|if
condition|(
name|parser
operator|->
name|top
operator|>=
name|parser
operator|->
name|stack
operator|+
literal|6
condition|)
block|{
name|FT_Long
name|scaling
decl_stmt|;
name|error
operator|=
name|CFF_Err_Ok
expr_stmt|;
comment|/* We expect a well-formed font matrix, this is, the matrix elements */
comment|/* `xx' and `yy' are of approximately the same magnitude.  To avoid  */
comment|/* loss of precision, we use the magnitude of element `xx' to scale  */
comment|/* all other elements.  The scaling factor is then contained in the  */
comment|/* `units_per_em' value.                                             */
name|matrix
operator|->
name|xx
operator|=
name|cff_parse_fixed_dynamic
argument_list|(
name|data
operator|++
argument_list|,
operator|&
name|scaling
argument_list|)
expr_stmt|;
name|scaling
operator|=
operator|-
name|scaling
expr_stmt|;
if|if
condition|(
name|scaling
operator|<
literal|0
operator|||
name|scaling
operator|>
literal|9
condition|)
block|{
comment|/* Return default matrix in case of unlikely values. */
name|matrix
operator|->
name|xx
operator|=
literal|0x10000L
expr_stmt|;
name|matrix
operator|->
name|yx
operator|=
literal|0
expr_stmt|;
name|matrix
operator|->
name|yx
operator|=
literal|0
expr_stmt|;
name|matrix
operator|->
name|yy
operator|=
literal|0x10000L
expr_stmt|;
name|offset
operator|->
name|x
operator|=
literal|0
expr_stmt|;
name|offset
operator|->
name|y
operator|=
literal|0
expr_stmt|;
operator|*
name|upm
operator|=
literal|1
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|matrix
operator|->
name|yx
operator|=
name|cff_parse_fixed_scaled
argument_list|(
name|data
operator|++
argument_list|,
name|scaling
argument_list|)
expr_stmt|;
name|matrix
operator|->
name|xy
operator|=
name|cff_parse_fixed_scaled
argument_list|(
name|data
operator|++
argument_list|,
name|scaling
argument_list|)
expr_stmt|;
name|matrix
operator|->
name|yy
operator|=
name|cff_parse_fixed_scaled
argument_list|(
name|data
operator|++
argument_list|,
name|scaling
argument_list|)
expr_stmt|;
name|offset
operator|->
name|x
operator|=
name|cff_parse_fixed_scaled
argument_list|(
name|data
operator|++
argument_list|,
name|scaling
argument_list|)
expr_stmt|;
name|offset
operator|->
name|y
operator|=
name|cff_parse_fixed_scaled
argument_list|(
name|data
argument_list|,
name|scaling
argument_list|)
expr_stmt|;
operator|*
name|upm
operator|=
name|power_tens
index|[
name|scaling
index|]
expr_stmt|;
block|}
name|Exit
label|:
return|return
name|error
return|;
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|cff_parse_font_bbox
name|cff_parse_font_bbox
parameter_list|(
name|CFF_Parser
name|parser
parameter_list|)
block|{
name|CFF_FontRecDict
name|dict
init|=
operator|(
name|CFF_FontRecDict
operator|)
name|parser
operator|->
name|object
decl_stmt|;
name|FT_BBox
modifier|*
name|bbox
init|=
operator|&
name|dict
operator|->
name|font_bbox
decl_stmt|;
name|FT_Byte
modifier|*
modifier|*
name|data
init|=
name|parser
operator|->
name|stack
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|error
operator|=
name|CFF_Err_Stack_Underflow
expr_stmt|;
if|if
condition|(
name|parser
operator|->
name|top
operator|>=
name|parser
operator|->
name|stack
operator|+
literal|4
condition|)
block|{
name|bbox
operator|->
name|xMin
operator|=
name|FT_RoundFix
argument_list|(
name|cff_parse_fixed
argument_list|(
name|data
operator|++
argument_list|)
argument_list|)
expr_stmt|;
name|bbox
operator|->
name|yMin
operator|=
name|FT_RoundFix
argument_list|(
name|cff_parse_fixed
argument_list|(
name|data
operator|++
argument_list|)
argument_list|)
expr_stmt|;
name|bbox
operator|->
name|xMax
operator|=
name|FT_RoundFix
argument_list|(
name|cff_parse_fixed
argument_list|(
name|data
operator|++
argument_list|)
argument_list|)
expr_stmt|;
name|bbox
operator|->
name|yMax
operator|=
name|FT_RoundFix
argument_list|(
name|cff_parse_fixed
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|CFF_Err_Ok
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|cff_parse_private_dict
name|cff_parse_private_dict
parameter_list|(
name|CFF_Parser
name|parser
parameter_list|)
block|{
name|CFF_FontRecDict
name|dict
init|=
operator|(
name|CFF_FontRecDict
operator|)
name|parser
operator|->
name|object
decl_stmt|;
name|FT_Byte
modifier|*
modifier|*
name|data
init|=
name|parser
operator|->
name|stack
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|error
operator|=
name|CFF_Err_Stack_Underflow
expr_stmt|;
if|if
condition|(
name|parser
operator|->
name|top
operator|>=
name|parser
operator|->
name|stack
operator|+
literal|2
condition|)
block|{
name|dict
operator|->
name|private_size
operator|=
name|cff_parse_num
argument_list|(
name|data
operator|++
argument_list|)
expr_stmt|;
name|dict
operator|->
name|private_offset
operator|=
name|cff_parse_num
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|error
operator|=
name|CFF_Err_Ok
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|cff_parse_cid_ros
name|cff_parse_cid_ros
parameter_list|(
name|CFF_Parser
name|parser
parameter_list|)
block|{
name|CFF_FontRecDict
name|dict
init|=
operator|(
name|CFF_FontRecDict
operator|)
name|parser
operator|->
name|object
decl_stmt|;
name|FT_Byte
modifier|*
modifier|*
name|data
init|=
name|parser
operator|->
name|stack
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|error
operator|=
name|CFF_Err_Stack_Underflow
expr_stmt|;
if|if
condition|(
name|parser
operator|->
name|top
operator|>=
name|parser
operator|->
name|stack
operator|+
literal|3
condition|)
block|{
name|dict
operator|->
name|cid_registry
operator|=
operator|(
name|FT_UInt
operator|)
name|cff_parse_num
argument_list|(
name|data
operator|++
argument_list|)
expr_stmt|;
name|dict
operator|->
name|cid_ordering
operator|=
operator|(
name|FT_UInt
operator|)
name|cff_parse_num
argument_list|(
name|data
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|data
operator|==
literal|30
condition|)
name|FT_TRACE1
argument_list|(
operator|(
literal|"cff_parse_cid_ros: real supplement is rounded\n"
operator|)
argument_list|)
expr_stmt|;
name|dict
operator|->
name|cid_supplement
operator|=
name|cff_parse_num
argument_list|(
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|dict
operator|->
name|cid_supplement
operator|<
literal|0
condition|)
name|FT_TRACE1
argument_list|(
operator|(
literal|"cff_parse_cid_ros: negative supplement %d is found\n"
operator|,
name|dict
operator|->
name|cid_supplement
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|CFF_Err_Ok
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function
begin_define
DECL|macro|CFF_FIELD_NUM
define|#
directive|define
name|CFF_FIELD_NUM
parameter_list|(
name|code
parameter_list|,
name|name
parameter_list|)
define|\
value|CFF_FIELD( code, name, cff_kind_num )
end_define
begin_define
DECL|macro|CFF_FIELD_FIXED
define|#
directive|define
name|CFF_FIELD_FIXED
parameter_list|(
name|code
parameter_list|,
name|name
parameter_list|)
define|\
value|CFF_FIELD( code, name, cff_kind_fixed )
end_define
begin_define
DECL|macro|CFF_FIELD_FIXED_1000
define|#
directive|define
name|CFF_FIELD_FIXED_1000
parameter_list|(
name|code
parameter_list|,
name|name
parameter_list|)
define|\
value|CFF_FIELD( code, name, cff_kind_fixed_thousand )
end_define
begin_define
DECL|macro|CFF_FIELD_STRING
define|#
directive|define
name|CFF_FIELD_STRING
parameter_list|(
name|code
parameter_list|,
name|name
parameter_list|)
define|\
value|CFF_FIELD( code, name, cff_kind_string )
end_define
begin_define
DECL|macro|CFF_FIELD_BOOL
define|#
directive|define
name|CFF_FIELD_BOOL
parameter_list|(
name|code
parameter_list|,
name|name
parameter_list|)
define|\
value|CFF_FIELD( code, name, cff_kind_bool )
end_define
begin_define
DECL|macro|CFF_FIELD_DELTA
define|#
directive|define
name|CFF_FIELD_DELTA
parameter_list|(
name|code
parameter_list|,
name|name
parameter_list|,
name|max
parameter_list|)
define|\
value|CFF_FIELD( code, name, cff_kind_delta )
end_define
begin_define
DECL|macro|CFFCODE_TOPDICT
define|#
directive|define
name|CFFCODE_TOPDICT
value|0x1000
end_define
begin_define
DECL|macro|CFFCODE_PRIVATE
define|#
directive|define
name|CFFCODE_PRIVATE
value|0x2000
end_define
begin_ifndef
ifndef|#
directive|ifndef
name|FT_CONFIG_OPTION_PIC
end_ifndef
begin_define
DECL|macro|CFF_FIELD_CALLBACK
define|#
directive|define
name|CFF_FIELD_CALLBACK
parameter_list|(
name|code
parameter_list|,
name|name
parameter_list|)
define|\
value|{                              \             cff_kind_callback,           \             code | CFFCODE,              \             0, 0,                        \             cff_parse_ ## name,          \             0, 0                         \           },
end_define
begin_undef
DECL|macro|CFF_FIELD
undef|#
directive|undef
name|CFF_FIELD
end_undef
begin_define
DECL|macro|CFF_FIELD
define|#
directive|define
name|CFF_FIELD
parameter_list|(
name|code
parameter_list|,
name|name
parameter_list|,
name|kind
parameter_list|)
define|\
value|{                          \             kind,                    \             code | CFFCODE,          \             FT_FIELD_OFFSET( name ), \             FT_FIELD_SIZE( name ),   \             0, 0, 0                  \           },
end_define
begin_undef
DECL|macro|CFF_FIELD_DELTA
undef|#
directive|undef
name|CFF_FIELD_DELTA
end_undef
begin_define
DECL|macro|CFF_FIELD_DELTA
define|#
directive|define
name|CFF_FIELD_DELTA
parameter_list|(
name|code
parameter_list|,
name|name
parameter_list|,
name|max
parameter_list|)
define|\
value|{                                  \           cff_kind_delta,                  \           code | CFFCODE,                  \           FT_FIELD_OFFSET( name ),         \           FT_FIELD_SIZE_DELTA( name ),     \           0,                               \           max,                             \           FT_FIELD_OFFSET( num_ ## name )  \         },
end_define
begin_decl_stmt
DECL|variable|cff_field_handlers
specifier|static
specifier|const
name|CFF_Field_Handler
name|cff_field_handlers
index|[]
init|=
block|{
include|#
directive|include
file|"cfftoken.h"
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* FT_CONFIG_OPTION_PIC */
end_comment
begin_function
DECL|function|FT_Destroy_Class_cff_field_handlers
name|void
name|FT_Destroy_Class_cff_field_handlers
parameter_list|(
name|FT_Library
name|library
parameter_list|,
name|CFF_Field_Handler
modifier|*
name|clazz
parameter_list|)
block|{
name|FT_Memory
name|memory
init|=
name|library
operator|->
name|memory
decl_stmt|;
if|if
condition|(
name|clazz
condition|)
name|FT_FREE
argument_list|(
name|clazz
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|FT_Create_Class_cff_field_handlers
name|FT_Error
name|FT_Create_Class_cff_field_handlers
parameter_list|(
name|FT_Library
name|library
parameter_list|,
name|CFF_Field_Handler
modifier|*
modifier|*
name|output_class
parameter_list|)
block|{
name|CFF_Field_Handler
modifier|*
name|clazz
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|library
operator|->
name|memory
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
DECL|macro|CFF_FIELD
undef|#
directive|undef
name|CFF_FIELD
DECL|macro|CFF_FIELD_DELTA
undef|#
directive|undef
name|CFF_FIELD_DELTA
DECL|macro|CFF_FIELD_CALLBACK
undef|#
directive|undef
name|CFF_FIELD_CALLBACK
DECL|macro|CFF_FIELD_CALLBACK
define|#
directive|define
name|CFF_FIELD_CALLBACK
parameter_list|(
name|code
parameter_list|,
name|name
parameter_list|)
value|i++;
DECL|macro|CFF_FIELD
define|#
directive|define
name|CFF_FIELD
parameter_list|(
name|code
parameter_list|,
name|name
parameter_list|,
name|kind
parameter_list|)
value|i++;
DECL|macro|CFF_FIELD_DELTA
define|#
directive|define
name|CFF_FIELD_DELTA
parameter_list|(
name|code
parameter_list|,
name|name
parameter_list|,
name|max
parameter_list|)
value|i++;
include|#
directive|include
file|"cfftoken.h"
name|i
operator|++
expr_stmt|;
comment|/*{ 0, 0, 0, 0, 0, 0, 0 }*/
if|if
condition|(
name|FT_ALLOC
argument_list|(
name|clazz
argument_list|,
sizeof|sizeof
argument_list|(
name|CFF_Field_Handler
argument_list|)
operator|*
name|i
argument_list|)
condition|)
return|return
name|error
return|;
name|i
operator|=
literal|0
expr_stmt|;
DECL|macro|CFF_FIELD
undef|#
directive|undef
name|CFF_FIELD
DECL|macro|CFF_FIELD_DELTA
undef|#
directive|undef
name|CFF_FIELD_DELTA
DECL|macro|CFF_FIELD_CALLBACK
undef|#
directive|undef
name|CFF_FIELD_CALLBACK
DECL|macro|CFF_FIELD_CALLBACK
define|#
directive|define
name|CFF_FIELD_CALLBACK
parameter_list|(
name|code_
parameter_list|,
name|name_
parameter_list|)
define|\
value|clazz[i].kind = cff_kind_callback;                                       \     clazz[i].code = code_ | CFFCODE;                                         \     clazz[i].offset = 0;                                                     \     clazz[i].size = 0;                                                       \     clazz[i].reader = cff_parse_ ## name_;                                   \     clazz[i].array_max = 0;                                                  \     clazz[i].count_offset = 0;                                               \     i++;
DECL|macro|CFF_FIELD
undef|#
directive|undef
name|CFF_FIELD
DECL|macro|CFF_FIELD
define|#
directive|define
name|CFF_FIELD
parameter_list|(
name|code_
parameter_list|,
name|name_
parameter_list|,
name|kind_
parameter_list|)
define|\
value|clazz[i].kind = kind_;                                                   \     clazz[i].code = code_ | CFFCODE;                                         \     clazz[i].offset = FT_FIELD_OFFSET( name_ );                              \     clazz[i].size = FT_FIELD_SIZE( name_ );                                  \     clazz[i].reader = 0;                                                     \     clazz[i].array_max = 0;                                                  \     clazz[i].count_offset = 0;                                               \     i++;                                                                     \  #undef  CFF_FIELD_DELTA
DECL|macro|CFF_FIELD_DELTA
define|#
directive|define
name|CFF_FIELD_DELTA
parameter_list|(
name|code_
parameter_list|,
name|name_
parameter_list|,
name|max_
parameter_list|)
define|\
value|clazz[i].kind = cff_kind_delta;                                          \     clazz[i].code = code_ | CFFCODE;                                         \     clazz[i].offset = FT_FIELD_OFFSET( name_ );                              \     clazz[i].size = FT_FIELD_SIZE_DELTA( name_ );                            \     clazz[i].reader = 0;                                                     \     clazz[i].array_max = max_;                                               \     clazz[i].count_offset = FT_FIELD_OFFSET( num_ ## name_ );                \     i++;
include|#
directive|include
file|"cfftoken.h"
name|clazz
index|[
name|i
index|]
operator|.
name|kind
operator|=
literal|0
expr_stmt|;
name|clazz
index|[
name|i
index|]
operator|.
name|code
operator|=
literal|0
expr_stmt|;
name|clazz
index|[
name|i
index|]
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|clazz
index|[
name|i
index|]
operator|.
name|size
operator|=
literal|0
expr_stmt|;
name|clazz
index|[
name|i
index|]
operator|.
name|reader
operator|=
literal|0
expr_stmt|;
name|clazz
index|[
name|i
index|]
operator|.
name|array_max
operator|=
literal|0
expr_stmt|;
name|clazz
index|[
name|i
index|]
operator|.
name|count_offset
operator|=
literal|0
expr_stmt|;
operator|*
name|output_class
operator|=
name|clazz
expr_stmt|;
return|return
name|FT_Err_Ok
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* FT_CONFIG_OPTION_PIC */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|cff_parser_run
argument_list|(
argument|CFF_Parser  parser
argument_list|,
argument|FT_Byte*    start
argument_list|,
argument|FT_Byte*    limit
argument_list|)
end_macro
begin_block
block|{
name|FT_Byte
modifier|*
name|p
init|=
name|start
decl_stmt|;
name|FT_Error
name|error
init|=
name|CFF_Err_Ok
decl_stmt|;
name|FT_Library
name|library
init|=
name|parser
operator|->
name|library
decl_stmt|;
name|FT_UNUSED
argument_list|(
name|library
argument_list|)
expr_stmt|;
name|parser
operator|->
name|top
operator|=
name|parser
operator|->
name|stack
expr_stmt|;
name|parser
operator|->
name|start
operator|=
name|start
expr_stmt|;
name|parser
operator|->
name|limit
operator|=
name|limit
expr_stmt|;
name|parser
operator|->
name|cursor
operator|=
name|start
expr_stmt|;
while|while
condition|(
name|p
operator|<
name|limit
condition|)
block|{
name|FT_UInt
name|v
init|=
operator|*
name|p
decl_stmt|;
if|if
condition|(
name|v
operator|>=
literal|27
operator|&&
name|v
operator|!=
literal|31
condition|)
block|{
comment|/* it's a number; we will push its position on the stack */
if|if
condition|(
name|parser
operator|->
name|top
operator|-
name|parser
operator|->
name|stack
operator|>=
name|CFF_MAX_STACK_DEPTH
condition|)
goto|goto
name|Stack_Overflow
goto|;
operator|*
name|parser
operator|->
name|top
operator|++
operator|=
name|p
expr_stmt|;
comment|/* now, skip it */
if|if
condition|(
name|v
operator|==
literal|30
condition|)
block|{
comment|/* skip real number */
name|p
operator|++
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* An unterminated floating point number at the */
comment|/* end of a dictionary is invalid but harmless. */
if|if
condition|(
name|p
operator|>=
name|limit
condition|)
goto|goto
name|Exit
goto|;
name|v
operator|=
name|p
index|[
literal|0
index|]
operator|>>
literal|4
expr_stmt|;
if|if
condition|(
name|v
operator|==
literal|15
condition|)
break|break;
name|v
operator|=
name|p
index|[
literal|0
index|]
operator|&
literal|0xF
expr_stmt|;
if|if
condition|(
name|v
operator|==
literal|15
condition|)
break|break;
name|p
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|v
operator|==
literal|28
condition|)
name|p
operator|+=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|v
operator|==
literal|29
condition|)
name|p
operator|+=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|v
operator|>
literal|246
condition|)
name|p
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* This is not a number, hence it's an operator.  Compute its code */
comment|/* and look for it in our current list.                            */
name|FT_UInt
name|code
decl_stmt|;
name|FT_UInt
name|num_args
init|=
call|(
name|FT_UInt
call|)
argument_list|(
name|parser
operator|->
name|top
operator|-
name|parser
operator|->
name|stack
argument_list|)
decl_stmt|;
specifier|const
name|CFF_Field_Handler
modifier|*
name|field
decl_stmt|;
operator|*
name|parser
operator|->
name|top
operator|=
name|p
expr_stmt|;
name|code
operator|=
name|v
expr_stmt|;
if|if
condition|(
name|v
operator|==
literal|12
condition|)
block|{
comment|/* two byte operator */
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|p
operator|>=
name|limit
condition|)
goto|goto
name|Syntax_Error
goto|;
name|code
operator|=
literal|0x100
operator||
name|p
index|[
literal|0
index|]
expr_stmt|;
block|}
name|code
operator|=
name|code
operator||
name|parser
operator|->
name|object_code
expr_stmt|;
for|for
control|(
name|field
operator|=
name|FT_CFF_FIELD_HANDLERS_GET
init|;
name|field
operator|->
name|kind
condition|;
name|field
operator|++
control|)
block|{
if|if
condition|(
name|field
operator|->
name|code
operator|==
operator|(
name|FT_Int
operator|)
name|code
condition|)
block|{
comment|/* we found our field's handler; read it */
name|FT_Long
name|val
decl_stmt|;
name|FT_Byte
modifier|*
name|q
init|=
operator|(
name|FT_Byte
operator|*
operator|)
name|parser
operator|->
name|object
operator|+
name|field
operator|->
name|offset
decl_stmt|;
comment|/* check that we have enough arguments -- except for */
comment|/* delta encoded arrays, which can be empty          */
if|if
condition|(
name|field
operator|->
name|kind
operator|!=
name|cff_kind_delta
operator|&&
name|num_args
operator|<
literal|1
condition|)
goto|goto
name|Stack_Underflow
goto|;
switch|switch
condition|(
name|field
operator|->
name|kind
condition|)
block|{
case|case
name|cff_kind_bool
case|:
case|case
name|cff_kind_string
case|:
case|case
name|cff_kind_num
case|:
name|val
operator|=
name|cff_parse_num
argument_list|(
name|parser
operator|->
name|stack
argument_list|)
expr_stmt|;
goto|goto
name|Store_Number
goto|;
case|case
name|cff_kind_fixed
case|:
name|val
operator|=
name|cff_parse_fixed
argument_list|(
name|parser
operator|->
name|stack
argument_list|)
expr_stmt|;
goto|goto
name|Store_Number
goto|;
case|case
name|cff_kind_fixed_thousand
case|:
name|val
operator|=
name|cff_parse_fixed_scaled
argument_list|(
name|parser
operator|->
name|stack
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|Store_Number
label|:
switch|switch
condition|(
name|field
operator|->
name|size
condition|)
block|{
case|case
operator|(
literal|8
operator|/
name|FT_CHAR_BIT
operator|)
case|:
operator|*
operator|(
name|FT_Byte
operator|*
operator|)
name|q
operator|=
operator|(
name|FT_Byte
operator|)
name|val
expr_stmt|;
break|break;
case|case
operator|(
literal|16
operator|/
name|FT_CHAR_BIT
operator|)
case|:
operator|*
operator|(
name|FT_Short
operator|*
operator|)
name|q
operator|=
operator|(
name|FT_Short
operator|)
name|val
expr_stmt|;
break|break;
case|case
operator|(
literal|32
operator|/
name|FT_CHAR_BIT
operator|)
case|:
operator|*
operator|(
name|FT_Int32
operator|*
operator|)
name|q
operator|=
operator|(
name|FT_Int
operator|)
name|val
expr_stmt|;
break|break;
default|default:
comment|/* for 64-bit systems */
operator|*
operator|(
name|FT_Long
operator|*
operator|)
name|q
operator|=
name|val
expr_stmt|;
block|}
break|break;
case|case
name|cff_kind_delta
case|:
block|{
name|FT_Byte
modifier|*
name|qcount
init|=
operator|(
name|FT_Byte
operator|*
operator|)
name|parser
operator|->
name|object
operator|+
name|field
operator|->
name|count_offset
decl_stmt|;
name|FT_Byte
modifier|*
modifier|*
name|data
init|=
name|parser
operator|->
name|stack
decl_stmt|;
if|if
condition|(
name|num_args
operator|>
name|field
operator|->
name|array_max
condition|)
name|num_args
operator|=
name|field
operator|->
name|array_max
expr_stmt|;
comment|/* store count */
operator|*
name|qcount
operator|=
operator|(
name|FT_Byte
operator|)
name|num_args
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|num_args
operator|>
literal|0
condition|)
block|{
name|val
operator|+=
name|cff_parse_num
argument_list|(
name|data
operator|++
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|field
operator|->
name|size
condition|)
block|{
case|case
operator|(
literal|8
operator|/
name|FT_CHAR_BIT
operator|)
case|:
operator|*
operator|(
name|FT_Byte
operator|*
operator|)
name|q
operator|=
operator|(
name|FT_Byte
operator|)
name|val
expr_stmt|;
break|break;
case|case
operator|(
literal|16
operator|/
name|FT_CHAR_BIT
operator|)
case|:
operator|*
operator|(
name|FT_Short
operator|*
operator|)
name|q
operator|=
operator|(
name|FT_Short
operator|)
name|val
expr_stmt|;
break|break;
case|case
operator|(
literal|32
operator|/
name|FT_CHAR_BIT
operator|)
case|:
operator|*
operator|(
name|FT_Int32
operator|*
operator|)
name|q
operator|=
operator|(
name|FT_Int
operator|)
name|val
expr_stmt|;
break|break;
default|default:
comment|/* for 64-bit systems */
operator|*
operator|(
name|FT_Long
operator|*
operator|)
name|q
operator|=
name|val
expr_stmt|;
block|}
name|q
operator|+=
name|field
operator|->
name|size
expr_stmt|;
name|num_args
operator|--
expr_stmt|;
block|}
block|}
break|break;
default|default:
comment|/* callback */
name|error
operator|=
name|field
operator|->
name|reader
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
block|}
goto|goto
name|Found
goto|;
block|}
block|}
comment|/* this is an unknown operator, or it is unsupported; */
comment|/* we will ignore it for now.                         */
name|Found
label|:
comment|/* clear stack */
name|parser
operator|->
name|top
operator|=
name|parser
operator|->
name|stack
expr_stmt|;
block|}
name|p
operator|++
expr_stmt|;
block|}
name|Exit
label|:
return|return
name|error
return|;
name|Stack_Overflow
label|:
name|error
operator|=
name|CFF_Err_Invalid_Argument
expr_stmt|;
goto|goto
name|Exit
goto|;
name|Stack_Underflow
label|:
name|error
operator|=
name|CFF_Err_Invalid_Argument
expr_stmt|;
goto|goto
name|Exit
goto|;
name|Syntax_Error
label|:
name|error
operator|=
name|CFF_Err_Invalid_Argument
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
end_block
begin_comment
comment|/* END */
end_comment
end_unit
