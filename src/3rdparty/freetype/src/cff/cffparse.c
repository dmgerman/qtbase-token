begin_unit
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  cffparse.c                                                             */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*    CFF token stream parser (body)                                       */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  Copyright 1996-2004, 2007-2014 by                                      */
end_comment
begin_comment
comment|/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  This file is part of the FreeType project, and may only be used,       */
end_comment
begin_comment
comment|/*  modified, and distributed under the terms of the FreeType project      */
end_comment
begin_comment
comment|/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
end_comment
begin_comment
comment|/*  this file you indicate that you have read the license and              */
end_comment
begin_comment
comment|/*  understand and accept it fully.                                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<ft2build.h>
end_include
begin_include
include|#
directive|include
file|"cffparse.h"
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_STREAM_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_DEBUG_H
end_include
begin_include
include|#
directive|include
file|"cfferrs.h"
end_include
begin_include
include|#
directive|include
file|"cffpic.h"
end_include
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
end_comment
begin_comment
comment|/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
end_comment
begin_comment
comment|/* messages during execution.                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_undef
DECL|macro|FT_COMPONENT
undef|#
directive|undef
name|FT_COMPONENT
end_undef
begin_define
DECL|macro|FT_COMPONENT
define|#
directive|define
name|FT_COMPONENT
value|trace_cffparse
end_define
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|cff_parser_init
name|cff_parser_init
argument_list|(
argument|CFF_Parser  parser
argument_list|,
argument|FT_UInt     code
argument_list|,
argument|void*       object
argument_list|,
argument|FT_Library  library
argument_list|)
end_macro
begin_block
block|{
name|FT_MEM_ZERO
argument_list|(
name|parser
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|parser
argument_list|)
argument_list|)
expr_stmt|;
name|parser
operator|->
name|top
operator|=
name|parser
operator|->
name|stack
expr_stmt|;
name|parser
operator|->
name|object_code
operator|=
name|code
expr_stmt|;
name|parser
operator|->
name|object
operator|=
name|object
expr_stmt|;
name|parser
operator|->
name|library
operator|=
name|library
expr_stmt|;
block|}
end_block
begin_comment
comment|/* read an integer */
end_comment
begin_function
specifier|static
name|FT_Long
DECL|function|cff_parse_integer
name|cff_parse_integer
parameter_list|(
name|FT_Byte
modifier|*
name|start
parameter_list|,
name|FT_Byte
modifier|*
name|limit
parameter_list|)
block|{
name|FT_Byte
modifier|*
name|p
init|=
name|start
decl_stmt|;
name|FT_Int
name|v
init|=
operator|*
name|p
operator|++
decl_stmt|;
name|FT_Long
name|val
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|v
operator|==
literal|28
condition|)
block|{
if|if
condition|(
name|p
operator|+
literal|2
operator|>
name|limit
condition|)
goto|goto
name|Bad
goto|;
name|val
operator|=
call|(
name|FT_Short
call|)
argument_list|(
operator|(
operator|(
name|FT_UShort
operator|)
name|p
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator||
name|p
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|v
operator|==
literal|29
condition|)
block|{
if|if
condition|(
name|p
operator|+
literal|4
operator|>
name|limit
condition|)
goto|goto
name|Bad
goto|;
name|val
operator|=
call|(
name|FT_Long
call|)
argument_list|(
operator|(
operator|(
name|FT_ULong
operator|)
name|p
index|[
literal|0
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
name|FT_ULong
operator|)
name|p
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|FT_ULong
operator|)
name|p
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|FT_ULong
operator|)
name|p
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|v
operator|<
literal|247
condition|)
block|{
name|val
operator|=
name|v
operator|-
literal|139
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|v
operator|<
literal|251
condition|)
block|{
if|if
condition|(
name|p
operator|+
literal|1
operator|>
name|limit
condition|)
goto|goto
name|Bad
goto|;
name|val
operator|=
operator|(
name|v
operator|-
literal|247
operator|)
operator|*
literal|256
operator|+
name|p
index|[
literal|0
index|]
operator|+
literal|108
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|p
operator|+
literal|1
operator|>
name|limit
condition|)
goto|goto
name|Bad
goto|;
name|val
operator|=
operator|-
operator|(
name|v
operator|-
literal|251
operator|)
operator|*
literal|256
operator|-
name|p
index|[
literal|0
index|]
operator|-
literal|108
expr_stmt|;
block|}
name|Exit
label|:
return|return
name|val
return|;
name|Bad
label|:
name|val
operator|=
literal|0
expr_stmt|;
name|FT_TRACE4
argument_list|(
operator|(
literal|"!!!END OF DATA:!!!"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
end_function
begin_decl_stmt
DECL|variable|power_tens
specifier|static
specifier|const
name|FT_Long
name|power_tens
index|[]
init|=
block|{
literal|1L
block|,
literal|10L
block|,
literal|100L
block|,
literal|1000L
block|,
literal|10000L
block|,
literal|100000L
block|,
literal|1000000L
block|,
literal|10000000L
block|,
literal|100000000L
block|,
literal|1000000000L
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* read a real */
end_comment
begin_function
specifier|static
name|FT_Fixed
DECL|function|cff_parse_real
name|cff_parse_real
parameter_list|(
name|FT_Byte
modifier|*
name|start
parameter_list|,
name|FT_Byte
modifier|*
name|limit
parameter_list|,
name|FT_Long
name|power_ten
parameter_list|,
name|FT_Long
modifier|*
name|scaling
parameter_list|)
block|{
name|FT_Byte
modifier|*
name|p
init|=
name|start
decl_stmt|;
name|FT_UInt
name|nib
decl_stmt|;
name|FT_UInt
name|phase
decl_stmt|;
name|FT_Long
name|result
decl_stmt|,
name|number
decl_stmt|,
name|exponent
decl_stmt|;
name|FT_Int
name|sign
init|=
literal|0
decl_stmt|,
name|exponent_sign
init|=
literal|0
decl_stmt|,
name|have_overflow
init|=
literal|0
decl_stmt|;
name|FT_Long
name|exponent_add
decl_stmt|,
name|integer_length
decl_stmt|,
name|fraction_length
decl_stmt|;
if|if
condition|(
name|scaling
condition|)
operator|*
name|scaling
operator|=
literal|0
expr_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
name|number
operator|=
literal|0
expr_stmt|;
name|exponent
operator|=
literal|0
expr_stmt|;
name|exponent_add
operator|=
literal|0
expr_stmt|;
name|integer_length
operator|=
literal|0
expr_stmt|;
name|fraction_length
operator|=
literal|0
expr_stmt|;
comment|/* First of all, read the integer part. */
name|phase
operator|=
literal|4
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* If we entered this iteration with phase == 4, we need to */
comment|/* read a new byte.  This also skips past the initial 0x1E. */
if|if
condition|(
name|phase
condition|)
block|{
name|p
operator|++
expr_stmt|;
comment|/* Make sure we don't read past the end. */
if|if
condition|(
name|p
operator|>=
name|limit
condition|)
goto|goto
name|Bad
goto|;
block|}
comment|/* Get the nibble. */
name|nib
operator|=
operator|(
name|p
index|[
literal|0
index|]
operator|>>
name|phase
operator|)
operator|&
literal|0xF
expr_stmt|;
name|phase
operator|=
literal|4
operator|-
name|phase
expr_stmt|;
if|if
condition|(
name|nib
operator|==
literal|0xE
condition|)
name|sign
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|nib
operator|>
literal|9
condition|)
break|break;
else|else
block|{
comment|/* Increase exponent if we can't add the digit. */
if|if
condition|(
name|number
operator|>=
literal|0xCCCCCCCL
condition|)
name|exponent_add
operator|++
expr_stmt|;
comment|/* Skip leading zeros. */
elseif|else
if|if
condition|(
name|nib
operator|||
name|number
condition|)
block|{
name|integer_length
operator|++
expr_stmt|;
name|number
operator|=
name|number
operator|*
literal|10
operator|+
name|nib
expr_stmt|;
block|}
block|}
block|}
comment|/* Read fraction part, if any. */
if|if
condition|(
name|nib
operator|==
literal|0xA
condition|)
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* If we entered this iteration with phase == 4, we need */
comment|/* to read a new byte.                                   */
if|if
condition|(
name|phase
condition|)
block|{
name|p
operator|++
expr_stmt|;
comment|/* Make sure we don't read past the end. */
if|if
condition|(
name|p
operator|>=
name|limit
condition|)
goto|goto
name|Bad
goto|;
block|}
comment|/* Get the nibble. */
name|nib
operator|=
operator|(
name|p
index|[
literal|0
index|]
operator|>>
name|phase
operator|)
operator|&
literal|0xF
expr_stmt|;
name|phase
operator|=
literal|4
operator|-
name|phase
expr_stmt|;
if|if
condition|(
name|nib
operator|>=
literal|10
condition|)
break|break;
comment|/* Skip leading zeros if possible. */
if|if
condition|(
operator|!
name|nib
operator|&&
operator|!
name|number
condition|)
name|exponent_add
operator|--
expr_stmt|;
comment|/* Only add digit if we don't overflow. */
elseif|else
if|if
condition|(
name|number
operator|<
literal|0xCCCCCCCL
operator|&&
name|fraction_length
operator|<
literal|9
condition|)
block|{
name|fraction_length
operator|++
expr_stmt|;
name|number
operator|=
name|number
operator|*
literal|10
operator|+
name|nib
expr_stmt|;
block|}
block|}
comment|/* Read exponent, if any. */
if|if
condition|(
name|nib
operator|==
literal|12
condition|)
block|{
name|exponent_sign
operator|=
literal|1
expr_stmt|;
name|nib
operator|=
literal|11
expr_stmt|;
block|}
if|if
condition|(
name|nib
operator|==
literal|11
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* If we entered this iteration with phase == 4, */
comment|/* we need to read a new byte.                   */
if|if
condition|(
name|phase
condition|)
block|{
name|p
operator|++
expr_stmt|;
comment|/* Make sure we don't read past the end. */
if|if
condition|(
name|p
operator|>=
name|limit
condition|)
goto|goto
name|Bad
goto|;
block|}
comment|/* Get the nibble. */
name|nib
operator|=
operator|(
name|p
index|[
literal|0
index|]
operator|>>
name|phase
operator|)
operator|&
literal|0xF
expr_stmt|;
name|phase
operator|=
literal|4
operator|-
name|phase
expr_stmt|;
if|if
condition|(
name|nib
operator|>=
literal|10
condition|)
break|break;
comment|/* Arbitrarily limit exponent. */
if|if
condition|(
name|exponent
operator|>
literal|1000
condition|)
name|have_overflow
operator|=
literal|1
expr_stmt|;
else|else
name|exponent
operator|=
name|exponent
operator|*
literal|10
operator|+
name|nib
expr_stmt|;
block|}
if|if
condition|(
name|exponent_sign
condition|)
name|exponent
operator|=
operator|-
name|exponent
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|number
condition|)
goto|goto
name|Exit
goto|;
if|if
condition|(
name|have_overflow
condition|)
block|{
if|if
condition|(
name|exponent_sign
condition|)
goto|goto
name|Underflow
goto|;
else|else
goto|goto
name|Overflow
goto|;
block|}
comment|/* We don't check `power_ten' and `exponent_add'. */
name|exponent
operator|+=
name|power_ten
operator|+
name|exponent_add
expr_stmt|;
if|if
condition|(
name|scaling
condition|)
block|{
comment|/* Only use `fraction_length'. */
name|fraction_length
operator|+=
name|integer_length
expr_stmt|;
name|exponent
operator|+=
name|integer_length
expr_stmt|;
if|if
condition|(
name|fraction_length
operator|<=
literal|5
condition|)
block|{
if|if
condition|(
name|number
operator|>
literal|0x7FFFL
condition|)
block|{
name|result
operator|=
name|FT_DivFix
argument_list|(
name|number
argument_list|,
literal|10
argument_list|)
expr_stmt|;
operator|*
name|scaling
operator|=
name|exponent
operator|-
name|fraction_length
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|exponent
operator|>
literal|0
condition|)
block|{
name|FT_Long
name|new_fraction_length
decl_stmt|,
name|shift
decl_stmt|;
comment|/* Make `scaling' as small as possible. */
name|new_fraction_length
operator|=
name|FT_MIN
argument_list|(
name|exponent
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|shift
operator|=
name|new_fraction_length
operator|-
name|fraction_length
expr_stmt|;
if|if
condition|(
name|shift
operator|>
literal|0
condition|)
block|{
name|exponent
operator|-=
name|new_fraction_length
expr_stmt|;
name|number
operator|*=
name|power_tens
index|[
name|shift
index|]
expr_stmt|;
if|if
condition|(
name|number
operator|>
literal|0x7FFFL
condition|)
block|{
name|number
operator|/=
literal|10
expr_stmt|;
name|exponent
operator|+=
literal|1
expr_stmt|;
block|}
block|}
else|else
name|exponent
operator|-=
name|fraction_length
expr_stmt|;
block|}
else|else
name|exponent
operator|-=
name|fraction_length
expr_stmt|;
name|result
operator|=
call|(
name|FT_Long
call|)
argument_list|(
operator|(
name|FT_ULong
operator|)
name|number
operator|<<
literal|16
argument_list|)
expr_stmt|;
operator|*
name|scaling
operator|=
name|exponent
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|number
operator|/
name|power_tens
index|[
name|fraction_length
operator|-
literal|5
index|]
operator|)
operator|>
literal|0x7FFFL
condition|)
block|{
name|result
operator|=
name|FT_DivFix
argument_list|(
name|number
argument_list|,
name|power_tens
index|[
name|fraction_length
operator|-
literal|4
index|]
argument_list|)
expr_stmt|;
operator|*
name|scaling
operator|=
name|exponent
operator|-
literal|4
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|FT_DivFix
argument_list|(
name|number
argument_list|,
name|power_tens
index|[
name|fraction_length
operator|-
literal|5
index|]
argument_list|)
expr_stmt|;
operator|*
name|scaling
operator|=
name|exponent
operator|-
literal|5
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|integer_length
operator|+=
name|exponent
expr_stmt|;
name|fraction_length
operator|-=
name|exponent
expr_stmt|;
if|if
condition|(
name|integer_length
operator|>
literal|5
condition|)
goto|goto
name|Overflow
goto|;
if|if
condition|(
name|integer_length
operator|<
operator|-
literal|5
condition|)
goto|goto
name|Underflow
goto|;
comment|/* Remove non-significant digits. */
if|if
condition|(
name|integer_length
operator|<
literal|0
condition|)
block|{
name|number
operator|/=
name|power_tens
index|[
operator|-
name|integer_length
index|]
expr_stmt|;
name|fraction_length
operator|+=
name|integer_length
expr_stmt|;
block|}
comment|/* this can only happen if exponent was non-zero */
if|if
condition|(
name|fraction_length
operator|==
literal|10
condition|)
block|{
name|number
operator|/=
literal|10
expr_stmt|;
name|fraction_length
operator|-=
literal|1
expr_stmt|;
block|}
comment|/* Convert into 16.16 format. */
if|if
condition|(
name|fraction_length
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|number
operator|/
name|power_tens
index|[
name|fraction_length
index|]
operator|)
operator|>
literal|0x7FFFL
condition|)
goto|goto
name|Exit
goto|;
name|result
operator|=
name|FT_DivFix
argument_list|(
name|number
argument_list|,
name|power_tens
index|[
name|fraction_length
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|number
operator|*=
name|power_tens
index|[
operator|-
name|fraction_length
index|]
expr_stmt|;
if|if
condition|(
name|number
operator|>
literal|0x7FFFL
condition|)
goto|goto
name|Overflow
goto|;
name|result
operator|=
call|(
name|FT_Long
call|)
argument_list|(
operator|(
name|FT_ULong
operator|)
name|number
operator|<<
literal|16
argument_list|)
expr_stmt|;
block|}
block|}
name|Exit
label|:
if|if
condition|(
name|sign
condition|)
name|result
operator|=
operator|-
name|result
expr_stmt|;
return|return
name|result
return|;
name|Overflow
label|:
name|result
operator|=
literal|0x7FFFFFFFL
expr_stmt|;
name|FT_TRACE4
argument_list|(
operator|(
literal|"!!!OVERFLOW:!!!"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
name|Underflow
label|:
name|result
operator|=
literal|0
expr_stmt|;
name|FT_TRACE4
argument_list|(
operator|(
literal|"!!!UNDERFLOW:!!!"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
name|Bad
label|:
name|result
operator|=
literal|0
expr_stmt|;
name|FT_TRACE4
argument_list|(
operator|(
literal|"!!!END OF DATA:!!!"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
end_function
begin_comment
comment|/* read a number, either integer or real */
end_comment
begin_function
specifier|static
name|FT_Long
DECL|function|cff_parse_num
name|cff_parse_num
parameter_list|(
name|FT_Byte
modifier|*
modifier|*
name|d
parameter_list|)
block|{
return|return
operator|*
operator|*
name|d
operator|==
literal|30
condition|?
operator|(
name|cff_parse_real
argument_list|(
name|d
index|[
literal|0
index|]
argument_list|,
name|d
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
operator|>>
literal|16
operator|)
else|:
name|cff_parse_integer
argument_list|(
name|d
index|[
literal|0
index|]
argument_list|,
name|d
index|[
literal|1
index|]
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/* read a floating point number, either integer or real */
end_comment
begin_function
specifier|static
name|FT_Fixed
DECL|function|do_fixed
name|do_fixed
parameter_list|(
name|FT_Byte
modifier|*
modifier|*
name|d
parameter_list|,
name|FT_Long
name|scaling
parameter_list|)
block|{
if|if
condition|(
operator|*
operator|*
name|d
operator|==
literal|30
condition|)
return|return
name|cff_parse_real
argument_list|(
name|d
index|[
literal|0
index|]
argument_list|,
name|d
index|[
literal|1
index|]
argument_list|,
name|scaling
argument_list|,
name|NULL
argument_list|)
return|;
else|else
block|{
name|FT_Long
name|val
init|=
name|cff_parse_integer
argument_list|(
name|d
index|[
literal|0
index|]
argument_list|,
name|d
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|scaling
condition|)
name|val
operator|*=
name|power_tens
index|[
name|scaling
index|]
expr_stmt|;
if|if
condition|(
name|val
operator|>
literal|0x7FFF
condition|)
block|{
name|val
operator|=
literal|0x7FFFFFFFL
expr_stmt|;
goto|goto
name|Overflow
goto|;
block|}
elseif|else
if|if
condition|(
name|val
operator|<
operator|-
literal|0x7FFF
condition|)
block|{
name|val
operator|=
operator|-
literal|0x7FFFFFFFL
expr_stmt|;
goto|goto
name|Overflow
goto|;
block|}
return|return
call|(
name|FT_Long
call|)
argument_list|(
operator|(
name|FT_ULong
operator|)
name|val
operator|<<
literal|16
argument_list|)
return|;
name|Overflow
label|:
name|FT_TRACE4
argument_list|(
operator|(
literal|"!!!OVERFLOW:!!!"
operator|)
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
block|}
end_function
begin_comment
comment|/* read a floating point number, either integer or real */
end_comment
begin_function
specifier|static
name|FT_Fixed
DECL|function|cff_parse_fixed
name|cff_parse_fixed
parameter_list|(
name|FT_Byte
modifier|*
modifier|*
name|d
parameter_list|)
block|{
return|return
name|do_fixed
argument_list|(
name|d
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/* read a floating point number, either integer or real, */
end_comment
begin_comment
comment|/* but return `10^scaling' times the number read in      */
end_comment
begin_function
specifier|static
name|FT_Fixed
DECL|function|cff_parse_fixed_scaled
name|cff_parse_fixed_scaled
parameter_list|(
name|FT_Byte
modifier|*
modifier|*
name|d
parameter_list|,
name|FT_Long
name|scaling
parameter_list|)
block|{
return|return
name|do_fixed
argument_list|(
name|d
argument_list|,
name|scaling
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/* read a floating point number, either integer or real,     */
end_comment
begin_comment
comment|/* and return it as precise as possible -- `scaling' returns */
end_comment
begin_comment
comment|/* the scaling factor (as a power of 10)                     */
end_comment
begin_function
specifier|static
name|FT_Fixed
DECL|function|cff_parse_fixed_dynamic
name|cff_parse_fixed_dynamic
parameter_list|(
name|FT_Byte
modifier|*
modifier|*
name|d
parameter_list|,
name|FT_Long
modifier|*
name|scaling
parameter_list|)
block|{
name|FT_ASSERT
argument_list|(
name|scaling
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|d
operator|==
literal|30
condition|)
return|return
name|cff_parse_real
argument_list|(
name|d
index|[
literal|0
index|]
argument_list|,
name|d
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|,
name|scaling
argument_list|)
return|;
else|else
block|{
name|FT_Long
name|number
decl_stmt|;
name|FT_Int
name|integer_length
decl_stmt|;
name|number
operator|=
name|cff_parse_integer
argument_list|(
name|d
index|[
literal|0
index|]
argument_list|,
name|d
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|number
operator|>
literal|0x7FFFL
condition|)
block|{
for|for
control|(
name|integer_length
operator|=
literal|5
init|;
name|integer_length
operator|<
literal|10
condition|;
name|integer_length
operator|++
control|)
if|if
condition|(
name|number
operator|<
name|power_tens
index|[
name|integer_length
index|]
condition|)
break|break;
if|if
condition|(
operator|(
name|number
operator|/
name|power_tens
index|[
name|integer_length
operator|-
literal|5
index|]
operator|)
operator|>
literal|0x7FFFL
condition|)
block|{
operator|*
name|scaling
operator|=
name|integer_length
operator|-
literal|4
expr_stmt|;
return|return
name|FT_DivFix
argument_list|(
name|number
argument_list|,
name|power_tens
index|[
name|integer_length
operator|-
literal|4
index|]
argument_list|)
return|;
block|}
else|else
block|{
operator|*
name|scaling
operator|=
name|integer_length
operator|-
literal|5
expr_stmt|;
return|return
name|FT_DivFix
argument_list|(
name|number
argument_list|,
name|power_tens
index|[
name|integer_length
operator|-
literal|5
index|]
argument_list|)
return|;
block|}
block|}
else|else
block|{
operator|*
name|scaling
operator|=
literal|0
expr_stmt|;
return|return
call|(
name|FT_Long
call|)
argument_list|(
operator|(
name|FT_ULong
operator|)
name|number
operator|<<
literal|16
argument_list|)
return|;
block|}
block|}
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|cff_parse_font_matrix
name|cff_parse_font_matrix
parameter_list|(
name|CFF_Parser
name|parser
parameter_list|)
block|{
name|CFF_FontRecDict
name|dict
init|=
operator|(
name|CFF_FontRecDict
operator|)
name|parser
operator|->
name|object
decl_stmt|;
name|FT_Matrix
modifier|*
name|matrix
init|=
operator|&
name|dict
operator|->
name|font_matrix
decl_stmt|;
name|FT_Vector
modifier|*
name|offset
init|=
operator|&
name|dict
operator|->
name|font_offset
decl_stmt|;
name|FT_ULong
modifier|*
name|upm
init|=
operator|&
name|dict
operator|->
name|units_per_em
decl_stmt|;
name|FT_Byte
modifier|*
modifier|*
name|data
init|=
name|parser
operator|->
name|stack
decl_stmt|;
name|FT_Error
name|error
init|=
name|FT_ERR
argument_list|(
name|Stack_Underflow
argument_list|)
decl_stmt|;
if|if
condition|(
name|parser
operator|->
name|top
operator|>=
name|parser
operator|->
name|stack
operator|+
literal|6
condition|)
block|{
name|FT_Long
name|scaling
decl_stmt|;
name|error
operator|=
name|FT_Err_Ok
expr_stmt|;
name|dict
operator|->
name|has_font_matrix
operator|=
name|TRUE
expr_stmt|;
comment|/* We expect a well-formed font matrix, this is, the matrix elements */
comment|/* `xx' and `yy' are of approximately the same magnitude.  To avoid  */
comment|/* loss of precision, we use the magnitude of element `xx' to scale  */
comment|/* all other elements.  The scaling factor is then contained in the  */
comment|/* `units_per_em' value.                                             */
name|matrix
operator|->
name|xx
operator|=
name|cff_parse_fixed_dynamic
argument_list|(
name|data
operator|++
argument_list|,
operator|&
name|scaling
argument_list|)
expr_stmt|;
name|scaling
operator|=
operator|-
name|scaling
expr_stmt|;
if|if
condition|(
name|scaling
operator|<
literal|0
operator|||
name|scaling
operator|>
literal|9
condition|)
block|{
comment|/* Return default matrix in case of unlikely values. */
name|FT_TRACE1
argument_list|(
operator|(
literal|"cff_parse_font_matrix:"
literal|" strange scaling value for xx element (%d),\n"
literal|"                      "
literal|" using default matrix\n"
operator|,
name|scaling
operator|)
argument_list|)
expr_stmt|;
name|matrix
operator|->
name|xx
operator|=
literal|0x10000L
expr_stmt|;
name|matrix
operator|->
name|yx
operator|=
literal|0
expr_stmt|;
name|matrix
operator|->
name|xy
operator|=
literal|0
expr_stmt|;
name|matrix
operator|->
name|yy
operator|=
literal|0x10000L
expr_stmt|;
name|offset
operator|->
name|x
operator|=
literal|0
expr_stmt|;
name|offset
operator|->
name|y
operator|=
literal|0
expr_stmt|;
operator|*
name|upm
operator|=
literal|1
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|matrix
operator|->
name|yx
operator|=
name|cff_parse_fixed_scaled
argument_list|(
name|data
operator|++
argument_list|,
name|scaling
argument_list|)
expr_stmt|;
name|matrix
operator|->
name|xy
operator|=
name|cff_parse_fixed_scaled
argument_list|(
name|data
operator|++
argument_list|,
name|scaling
argument_list|)
expr_stmt|;
name|matrix
operator|->
name|yy
operator|=
name|cff_parse_fixed_scaled
argument_list|(
name|data
operator|++
argument_list|,
name|scaling
argument_list|)
expr_stmt|;
name|offset
operator|->
name|x
operator|=
name|cff_parse_fixed_scaled
argument_list|(
name|data
operator|++
argument_list|,
name|scaling
argument_list|)
expr_stmt|;
name|offset
operator|->
name|y
operator|=
name|cff_parse_fixed_scaled
argument_list|(
name|data
argument_list|,
name|scaling
argument_list|)
expr_stmt|;
operator|*
name|upm
operator|=
name|power_tens
index|[
name|scaling
index|]
expr_stmt|;
name|FT_TRACE4
argument_list|(
operator|(
literal|" [%f %f %f %f %f %f]\n"
operator|,
operator|(
name|double
operator|)
name|matrix
operator|->
name|xx
operator|/
operator|*
name|upm
operator|/
literal|65536
operator|,
operator|(
name|double
operator|)
name|matrix
operator|->
name|xy
operator|/
operator|*
name|upm
operator|/
literal|65536
operator|,
operator|(
name|double
operator|)
name|matrix
operator|->
name|yx
operator|/
operator|*
name|upm
operator|/
literal|65536
operator|,
operator|(
name|double
operator|)
name|matrix
operator|->
name|yy
operator|/
operator|*
name|upm
operator|/
literal|65536
operator|,
operator|(
name|double
operator|)
name|offset
operator|->
name|x
operator|/
operator|*
name|upm
operator|/
literal|65536
operator|,
operator|(
name|double
operator|)
name|offset
operator|->
name|y
operator|/
operator|*
name|upm
operator|/
literal|65536
operator|)
argument_list|)
expr_stmt|;
block|}
name|Exit
label|:
return|return
name|error
return|;
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|cff_parse_font_bbox
name|cff_parse_font_bbox
parameter_list|(
name|CFF_Parser
name|parser
parameter_list|)
block|{
name|CFF_FontRecDict
name|dict
init|=
operator|(
name|CFF_FontRecDict
operator|)
name|parser
operator|->
name|object
decl_stmt|;
name|FT_BBox
modifier|*
name|bbox
init|=
operator|&
name|dict
operator|->
name|font_bbox
decl_stmt|;
name|FT_Byte
modifier|*
modifier|*
name|data
init|=
name|parser
operator|->
name|stack
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|error
operator|=
name|FT_ERR
argument_list|(
name|Stack_Underflow
argument_list|)
expr_stmt|;
if|if
condition|(
name|parser
operator|->
name|top
operator|>=
name|parser
operator|->
name|stack
operator|+
literal|4
condition|)
block|{
name|bbox
operator|->
name|xMin
operator|=
name|FT_RoundFix
argument_list|(
name|cff_parse_fixed
argument_list|(
name|data
operator|++
argument_list|)
argument_list|)
expr_stmt|;
name|bbox
operator|->
name|yMin
operator|=
name|FT_RoundFix
argument_list|(
name|cff_parse_fixed
argument_list|(
name|data
operator|++
argument_list|)
argument_list|)
expr_stmt|;
name|bbox
operator|->
name|xMax
operator|=
name|FT_RoundFix
argument_list|(
name|cff_parse_fixed
argument_list|(
name|data
operator|++
argument_list|)
argument_list|)
expr_stmt|;
name|bbox
operator|->
name|yMax
operator|=
name|FT_RoundFix
argument_list|(
name|cff_parse_fixed
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|FT_Err_Ok
expr_stmt|;
name|FT_TRACE4
argument_list|(
operator|(
literal|" [%d %d %d %d]\n"
operator|,
name|bbox
operator|->
name|xMin
operator|/
literal|65536
operator|,
name|bbox
operator|->
name|yMin
operator|/
literal|65536
operator|,
name|bbox
operator|->
name|xMax
operator|/
literal|65536
operator|,
name|bbox
operator|->
name|yMax
operator|/
literal|65536
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|cff_parse_private_dict
name|cff_parse_private_dict
parameter_list|(
name|CFF_Parser
name|parser
parameter_list|)
block|{
name|CFF_FontRecDict
name|dict
init|=
operator|(
name|CFF_FontRecDict
operator|)
name|parser
operator|->
name|object
decl_stmt|;
name|FT_Byte
modifier|*
modifier|*
name|data
init|=
name|parser
operator|->
name|stack
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|error
operator|=
name|FT_ERR
argument_list|(
name|Stack_Underflow
argument_list|)
expr_stmt|;
if|if
condition|(
name|parser
operator|->
name|top
operator|>=
name|parser
operator|->
name|stack
operator|+
literal|2
condition|)
block|{
name|dict
operator|->
name|private_size
operator|=
name|cff_parse_num
argument_list|(
name|data
operator|++
argument_list|)
expr_stmt|;
name|dict
operator|->
name|private_offset
operator|=
name|cff_parse_num
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|FT_TRACE4
argument_list|(
operator|(
literal|" %lu %lu\n"
operator|,
name|dict
operator|->
name|private_size
operator|,
name|dict
operator|->
name|private_offset
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|FT_Err_Ok
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|cff_parse_cid_ros
name|cff_parse_cid_ros
parameter_list|(
name|CFF_Parser
name|parser
parameter_list|)
block|{
name|CFF_FontRecDict
name|dict
init|=
operator|(
name|CFF_FontRecDict
operator|)
name|parser
operator|->
name|object
decl_stmt|;
name|FT_Byte
modifier|*
modifier|*
name|data
init|=
name|parser
operator|->
name|stack
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|error
operator|=
name|FT_ERR
argument_list|(
name|Stack_Underflow
argument_list|)
expr_stmt|;
if|if
condition|(
name|parser
operator|->
name|top
operator|>=
name|parser
operator|->
name|stack
operator|+
literal|3
condition|)
block|{
name|dict
operator|->
name|cid_registry
operator|=
operator|(
name|FT_UInt
operator|)
name|cff_parse_num
argument_list|(
name|data
operator|++
argument_list|)
expr_stmt|;
name|dict
operator|->
name|cid_ordering
operator|=
operator|(
name|FT_UInt
operator|)
name|cff_parse_num
argument_list|(
name|data
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|data
operator|==
literal|30
condition|)
name|FT_TRACE1
argument_list|(
operator|(
literal|"cff_parse_cid_ros: real supplement is rounded\n"
operator|)
argument_list|)
expr_stmt|;
name|dict
operator|->
name|cid_supplement
operator|=
name|cff_parse_num
argument_list|(
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|dict
operator|->
name|cid_supplement
operator|<
literal|0
condition|)
name|FT_TRACE1
argument_list|(
operator|(
literal|"cff_parse_cid_ros: negative supplement %d is found\n"
operator|,
name|dict
operator|->
name|cid_supplement
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|FT_Err_Ok
expr_stmt|;
name|FT_TRACE4
argument_list|(
operator|(
literal|" %d %d %d\n"
operator|,
name|dict
operator|->
name|cid_registry
operator|,
name|dict
operator|->
name|cid_ordering
operator|,
name|dict
operator|->
name|cid_supplement
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function
begin_define
DECL|macro|CFF_FIELD_NUM
define|#
directive|define
name|CFF_FIELD_NUM
parameter_list|(
name|code
parameter_list|,
name|name
parameter_list|,
name|id
parameter_list|)
define|\
value|CFF_FIELD( code, name, id, cff_kind_num )
end_define
begin_define
DECL|macro|CFF_FIELD_FIXED
define|#
directive|define
name|CFF_FIELD_FIXED
parameter_list|(
name|code
parameter_list|,
name|name
parameter_list|,
name|id
parameter_list|)
define|\
value|CFF_FIELD( code, name, id, cff_kind_fixed )
end_define
begin_define
DECL|macro|CFF_FIELD_FIXED_1000
define|#
directive|define
name|CFF_FIELD_FIXED_1000
parameter_list|(
name|code
parameter_list|,
name|name
parameter_list|,
name|id
parameter_list|)
define|\
value|CFF_FIELD( code, name, id, cff_kind_fixed_thousand )
end_define
begin_define
DECL|macro|CFF_FIELD_STRING
define|#
directive|define
name|CFF_FIELD_STRING
parameter_list|(
name|code
parameter_list|,
name|name
parameter_list|,
name|id
parameter_list|)
define|\
value|CFF_FIELD( code, name, id, cff_kind_string )
end_define
begin_define
DECL|macro|CFF_FIELD_BOOL
define|#
directive|define
name|CFF_FIELD_BOOL
parameter_list|(
name|code
parameter_list|,
name|name
parameter_list|,
name|id
parameter_list|)
define|\
value|CFF_FIELD( code, name, id, cff_kind_bool )
end_define
begin_define
DECL|macro|CFFCODE_TOPDICT
define|#
directive|define
name|CFFCODE_TOPDICT
value|0x1000
end_define
begin_define
DECL|macro|CFFCODE_PRIVATE
define|#
directive|define
name|CFFCODE_PRIVATE
value|0x2000
end_define
begin_ifndef
ifndef|#
directive|ifndef
name|FT_CONFIG_OPTION_PIC
end_ifndef
begin_undef
DECL|macro|CFF_FIELD
undef|#
directive|undef
name|CFF_FIELD
end_undef
begin_undef
DECL|macro|CFF_FIELD_DELTA
undef|#
directive|undef
name|CFF_FIELD_DELTA
end_undef
begin_ifndef
ifndef|#
directive|ifndef
name|FT_DEBUG_LEVEL_TRACE
end_ifndef
begin_define
DECL|macro|CFF_FIELD_CALLBACK
define|#
directive|define
name|CFF_FIELD_CALLBACK
parameter_list|(
name|code
parameter_list|,
name|name
parameter_list|,
name|id
parameter_list|)
define|\
value|{                                  \             cff_kind_callback,               \             code | CFFCODE,                  \             0, 0,                            \             cff_parse_ ## name,              \             0, 0                             \           },
end_define
begin_define
DECL|macro|CFF_FIELD
define|#
directive|define
name|CFF_FIELD
parameter_list|(
name|code
parameter_list|,
name|name
parameter_list|,
name|id
parameter_list|,
name|kind
parameter_list|)
define|\
value|{                               \             kind,                         \             code | CFFCODE,               \             FT_FIELD_OFFSET( name ),      \             FT_FIELD_SIZE( name ),        \             0, 0, 0                       \           },
end_define
begin_define
DECL|macro|CFF_FIELD_DELTA
define|#
directive|define
name|CFF_FIELD_DELTA
parameter_list|(
name|code
parameter_list|,
name|name
parameter_list|,
name|max
parameter_list|,
name|id
parameter_list|)
define|\
value|{                                    \             cff_kind_delta,                    \             code | CFFCODE,                    \             FT_FIELD_OFFSET( name ),           \             FT_FIELD_SIZE_DELTA( name ),       \             0,                                 \             max,                               \             FT_FIELD_OFFSET( num_ ## name )    \           },
end_define
begin_decl_stmt
DECL|variable|cff_field_handlers
specifier|static
specifier|const
name|CFF_Field_Handler
name|cff_field_handlers
index|[]
init|=
block|{
include|#
directive|include
file|"cfftoken.h"
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* FT_DEBUG_LEVEL_TRACE */
end_comment
begin_define
DECL|macro|CFF_FIELD_CALLBACK
define|#
directive|define
name|CFF_FIELD_CALLBACK
parameter_list|(
name|code
parameter_list|,
name|name
parameter_list|,
name|id
parameter_list|)
define|\
value|{                                  \             cff_kind_callback,               \             code | CFFCODE,                  \             0, 0,                            \             cff_parse_ ## name,              \             0, 0,                            \             id                               \           },
end_define
begin_define
DECL|macro|CFF_FIELD
define|#
directive|define
name|CFF_FIELD
parameter_list|(
name|code
parameter_list|,
name|name
parameter_list|,
name|id
parameter_list|,
name|kind
parameter_list|)
define|\
value|{                               \             kind,                         \             code | CFFCODE,               \             FT_FIELD_OFFSET( name ),      \             FT_FIELD_SIZE( name ),        \             0, 0, 0,                      \             id                            \           },
end_define
begin_define
DECL|macro|CFF_FIELD_DELTA
define|#
directive|define
name|CFF_FIELD_DELTA
parameter_list|(
name|code
parameter_list|,
name|name
parameter_list|,
name|max
parameter_list|,
name|id
parameter_list|)
define|\
value|{                                    \             cff_kind_delta,                    \             code | CFFCODE,                    \             FT_FIELD_OFFSET( name ),           \             FT_FIELD_SIZE_DELTA( name ),       \             0,                                 \             max,                               \             FT_FIELD_OFFSET( num_ ## name ),   \             id                                 \           },
end_define
begin_decl_stmt
DECL|variable|cff_field_handlers
specifier|static
specifier|const
name|CFF_Field_Handler
name|cff_field_handlers
index|[]
init|=
block|{
include|#
directive|include
file|"cfftoken.h"
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* FT_DEBUG_LEVEL_TRACE */
end_comment
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* FT_CONFIG_OPTION_PIC */
end_comment
begin_function
name|void
DECL|function|FT_Destroy_Class_cff_field_handlers
name|FT_Destroy_Class_cff_field_handlers
parameter_list|(
name|FT_Library
name|library
parameter_list|,
name|CFF_Field_Handler
modifier|*
name|clazz
parameter_list|)
block|{
name|FT_Memory
name|memory
init|=
name|library
operator|->
name|memory
decl_stmt|;
if|if
condition|(
name|clazz
condition|)
name|FT_FREE
argument_list|(
name|clazz
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
name|FT_Error
DECL|function|FT_Create_Class_cff_field_handlers
name|FT_Create_Class_cff_field_handlers
parameter_list|(
name|FT_Library
name|library
parameter_list|,
name|CFF_Field_Handler
modifier|*
modifier|*
name|output_class
parameter_list|)
block|{
name|CFF_Field_Handler
modifier|*
name|clazz
init|=
name|NULL
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|library
operator|->
name|memory
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
DECL|macro|CFF_FIELD
undef|#
directive|undef
name|CFF_FIELD
DECL|macro|CFF_FIELD
define|#
directive|define
name|CFF_FIELD
parameter_list|(
name|code
parameter_list|,
name|name
parameter_list|,
name|id
parameter_list|,
name|kind
parameter_list|)
value|i++;
DECL|macro|CFF_FIELD_DELTA
undef|#
directive|undef
name|CFF_FIELD_DELTA
DECL|macro|CFF_FIELD_DELTA
define|#
directive|define
name|CFF_FIELD_DELTA
parameter_list|(
name|code
parameter_list|,
name|name
parameter_list|,
name|max
parameter_list|,
name|id
parameter_list|)
value|i++;
DECL|macro|CFF_FIELD_CALLBACK
undef|#
directive|undef
name|CFF_FIELD_CALLBACK
DECL|macro|CFF_FIELD_CALLBACK
define|#
directive|define
name|CFF_FIELD_CALLBACK
parameter_list|(
name|code
parameter_list|,
name|name
parameter_list|,
name|id
parameter_list|)
value|i++;
include|#
directive|include
file|"cfftoken.h"
name|i
operator|++
expr_stmt|;
comment|/* { 0, 0, 0, 0, 0, 0, 0 } */
if|if
condition|(
name|FT_ALLOC
argument_list|(
name|clazz
argument_list|,
sizeof|sizeof
argument_list|(
name|CFF_Field_Handler
argument_list|)
operator|*
name|i
argument_list|)
condition|)
return|return
name|error
return|;
name|i
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|FT_DEBUG_LEVEL_TRACE
DECL|macro|CFF_FIELD_CALLBACK
undef|#
directive|undef
name|CFF_FIELD_CALLBACK
DECL|macro|CFF_FIELD_CALLBACK
define|#
directive|define
name|CFF_FIELD_CALLBACK
parameter_list|(
name|code_
parameter_list|,
name|name_
parameter_list|,
name|id_
parameter_list|)
define|\
value|clazz[i].kind         = cff_kind_callback;   \           clazz[i].code         = code_ | CFFCODE;     \           clazz[i].offset       = 0;                   \           clazz[i].size         = 0;                   \           clazz[i].reader       = cff_parse_ ## name_; \           clazz[i].array_max    = 0;                   \           clazz[i].count_offset = 0;                   \           i++;
DECL|macro|CFF_FIELD
undef|#
directive|undef
name|CFF_FIELD
DECL|macro|CFF_FIELD
define|#
directive|define
name|CFF_FIELD
parameter_list|(
name|code_
parameter_list|,
name|name_
parameter_list|,
name|id_
parameter_list|,
name|kind_
parameter_list|)
define|\
value|clazz[i].kind         = kind_;                    \           clazz[i].code         = code_ | CFFCODE;          \           clazz[i].offset       = FT_FIELD_OFFSET( name_ ); \           clazz[i].size         = FT_FIELD_SIZE( name_ );   \           clazz[i].reader       = 0;                        \           clazz[i].array_max    = 0;                        \           clazz[i].count_offset = 0;                        \           i++;                                              \  #undef  CFF_FIELD_DELTA
DECL|macro|CFF_FIELD_DELTA
define|#
directive|define
name|CFF_FIELD_DELTA
parameter_list|(
name|code_
parameter_list|,
name|name_
parameter_list|,
name|max_
parameter_list|,
name|id_
parameter_list|)
define|\
value|clazz[i].kind         = cff_kind_delta;                   \           clazz[i].code         = code_ | CFFCODE;                  \           clazz[i].offset       = FT_FIELD_OFFSET( name_ );         \           clazz[i].size         = FT_FIELD_SIZE_DELTA( name_ );     \           clazz[i].reader       = 0;                                \           clazz[i].array_max    = max_;                             \           clazz[i].count_offset = FT_FIELD_OFFSET( num_ ## name_ ); \           i++;
include|#
directive|include
file|"cfftoken.h"
name|clazz
index|[
name|i
index|]
operator|.
name|kind
operator|=
literal|0
expr_stmt|;
name|clazz
index|[
name|i
index|]
operator|.
name|code
operator|=
literal|0
expr_stmt|;
name|clazz
index|[
name|i
index|]
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|clazz
index|[
name|i
index|]
operator|.
name|size
operator|=
literal|0
expr_stmt|;
name|clazz
index|[
name|i
index|]
operator|.
name|reader
operator|=
literal|0
expr_stmt|;
name|clazz
index|[
name|i
index|]
operator|.
name|array_max
operator|=
literal|0
expr_stmt|;
name|clazz
index|[
name|i
index|]
operator|.
name|count_offset
operator|=
literal|0
expr_stmt|;
else|#
directive|else
comment|/* FT_DEBUG_LEVEL_TRACE */
undef|#
directive|undef
name|CFF_FIELD_CALLBACK
define|#
directive|define
name|CFF_FIELD_CALLBACK
parameter_list|(
name|code_
parameter_list|,
name|name_
parameter_list|,
name|id_
parameter_list|)
define|\
value|clazz[i].kind         = cff_kind_callback;   \           clazz[i].code         = code_ | CFFCODE;     \           clazz[i].offset       = 0;                   \           clazz[i].size         = 0;                   \           clazz[i].reader       = cff_parse_ ## name_; \           clazz[i].array_max    = 0;                   \           clazz[i].count_offset = 0;                   \           clazz[i].id           = id_;                 \           i++;
undef|#
directive|undef
name|CFF_FIELD
define|#
directive|define
name|CFF_FIELD
parameter_list|(
name|code_
parameter_list|,
name|name_
parameter_list|,
name|id_
parameter_list|,
name|kind_
parameter_list|)
define|\
value|clazz[i].kind         = kind_;                    \           clazz[i].code         = code_ | CFFCODE;          \           clazz[i].offset       = FT_FIELD_OFFSET( name_ ); \           clazz[i].size         = FT_FIELD_SIZE( name_ );   \           clazz[i].reader       = 0;                        \           clazz[i].array_max    = 0;                        \           clazz[i].count_offset = 0;                        \           clazz[i].id           = id_;                      \           i++;                                              \  #undef  CFF_FIELD_DELTA
define|#
directive|define
name|CFF_FIELD_DELTA
parameter_list|(
name|code_
parameter_list|,
name|name_
parameter_list|,
name|max_
parameter_list|,
name|id_
parameter_list|)
define|\
value|clazz[i].kind         = cff_kind_delta;                   \           clazz[i].code         = code_ | CFFCODE;                  \           clazz[i].offset       = FT_FIELD_OFFSET( name_ );         \           clazz[i].size         = FT_FIELD_SIZE_DELTA( name_ );     \           clazz[i].reader       = 0;                                \           clazz[i].array_max    = max_;                             \           clazz[i].count_offset = FT_FIELD_OFFSET( num_ ## name_ ); \           clazz[i].id           = id_;                              \           i++;
include|#
directive|include
file|"cfftoken.h"
name|clazz
index|[
name|i
index|]
operator|.
name|kind
operator|=
literal|0
expr_stmt|;
name|clazz
index|[
name|i
index|]
operator|.
name|code
operator|=
literal|0
expr_stmt|;
name|clazz
index|[
name|i
index|]
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|clazz
index|[
name|i
index|]
operator|.
name|size
operator|=
literal|0
expr_stmt|;
name|clazz
index|[
name|i
index|]
operator|.
name|reader
operator|=
literal|0
expr_stmt|;
name|clazz
index|[
name|i
index|]
operator|.
name|array_max
operator|=
literal|0
expr_stmt|;
name|clazz
index|[
name|i
index|]
operator|.
name|count_offset
operator|=
literal|0
expr_stmt|;
name|clazz
index|[
name|i
index|]
operator|.
name|id
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* FT_DEBUG_LEVEL_TRACE */
operator|*
name|output_class
operator|=
name|clazz
expr_stmt|;
return|return
name|FT_Err_Ok
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* FT_CONFIG_OPTION_PIC */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|cff_parser_run
argument_list|(
argument|CFF_Parser  parser
argument_list|,
argument|FT_Byte*    start
argument_list|,
argument|FT_Byte*    limit
argument_list|)
end_macro
begin_block
block|{
name|FT_Byte
modifier|*
name|p
init|=
name|start
decl_stmt|;
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
name|FT_Library
name|library
init|=
name|parser
operator|->
name|library
decl_stmt|;
name|FT_UNUSED
argument_list|(
name|library
argument_list|)
expr_stmt|;
name|parser
operator|->
name|top
operator|=
name|parser
operator|->
name|stack
expr_stmt|;
name|parser
operator|->
name|start
operator|=
name|start
expr_stmt|;
name|parser
operator|->
name|limit
operator|=
name|limit
expr_stmt|;
name|parser
operator|->
name|cursor
operator|=
name|start
expr_stmt|;
while|while
condition|(
name|p
operator|<
name|limit
condition|)
block|{
name|FT_UInt
name|v
init|=
operator|*
name|p
decl_stmt|;
if|if
condition|(
name|v
operator|>=
literal|27
operator|&&
name|v
operator|!=
literal|31
condition|)
block|{
comment|/* it's a number; we will push its position on the stack */
if|if
condition|(
name|parser
operator|->
name|top
operator|-
name|parser
operator|->
name|stack
operator|>=
name|CFF_MAX_STACK_DEPTH
condition|)
goto|goto
name|Stack_Overflow
goto|;
operator|*
name|parser
operator|->
name|top
operator|++
operator|=
name|p
expr_stmt|;
comment|/* now, skip it */
if|if
condition|(
name|v
operator|==
literal|30
condition|)
block|{
comment|/* skip real number */
name|p
operator|++
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* An unterminated floating point number at the */
comment|/* end of a dictionary is invalid but harmless. */
if|if
condition|(
name|p
operator|>=
name|limit
condition|)
goto|goto
name|Exit
goto|;
name|v
operator|=
name|p
index|[
literal|0
index|]
operator|>>
literal|4
expr_stmt|;
if|if
condition|(
name|v
operator|==
literal|15
condition|)
break|break;
name|v
operator|=
name|p
index|[
literal|0
index|]
operator|&
literal|0xF
expr_stmt|;
if|if
condition|(
name|v
operator|==
literal|15
condition|)
break|break;
name|p
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|v
operator|==
literal|28
condition|)
name|p
operator|+=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|v
operator|==
literal|29
condition|)
name|p
operator|+=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|v
operator|>
literal|246
condition|)
name|p
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* This is not a number, hence it's an operator.  Compute its code */
comment|/* and look for it in our current list.                            */
name|FT_UInt
name|code
decl_stmt|;
name|FT_UInt
name|num_args
init|=
call|(
name|FT_UInt
call|)
argument_list|(
name|parser
operator|->
name|top
operator|-
name|parser
operator|->
name|stack
argument_list|)
decl_stmt|;
specifier|const
name|CFF_Field_Handler
modifier|*
name|field
decl_stmt|;
operator|*
name|parser
operator|->
name|top
operator|=
name|p
expr_stmt|;
name|code
operator|=
name|v
expr_stmt|;
if|if
condition|(
name|v
operator|==
literal|12
condition|)
block|{
comment|/* two byte operator */
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|p
operator|>=
name|limit
condition|)
goto|goto
name|Syntax_Error
goto|;
name|code
operator|=
literal|0x100
operator||
name|p
index|[
literal|0
index|]
expr_stmt|;
block|}
name|code
operator|=
name|code
operator||
name|parser
operator|->
name|object_code
expr_stmt|;
for|for
control|(
name|field
operator|=
name|CFF_FIELD_HANDLERS_GET
init|;
name|field
operator|->
name|kind
condition|;
name|field
operator|++
control|)
block|{
if|if
condition|(
name|field
operator|->
name|code
operator|==
operator|(
name|FT_Int
operator|)
name|code
condition|)
block|{
comment|/* we found our field's handler; read it */
name|FT_Long
name|val
decl_stmt|;
name|FT_Byte
modifier|*
name|q
init|=
operator|(
name|FT_Byte
operator|*
operator|)
name|parser
operator|->
name|object
operator|+
name|field
operator|->
name|offset
decl_stmt|;
ifdef|#
directive|ifdef
name|FT_DEBUG_LEVEL_TRACE
name|FT_TRACE4
argument_list|(
operator|(
literal|"  %s"
operator|,
name|field
operator|->
name|id
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* check that we have enough arguments -- except for */
comment|/* delta encoded arrays, which can be empty          */
if|if
condition|(
name|field
operator|->
name|kind
operator|!=
name|cff_kind_delta
operator|&&
name|num_args
operator|<
literal|1
condition|)
goto|goto
name|Stack_Underflow
goto|;
switch|switch
condition|(
name|field
operator|->
name|kind
condition|)
block|{
case|case
name|cff_kind_bool
case|:
case|case
name|cff_kind_string
case|:
case|case
name|cff_kind_num
case|:
name|val
operator|=
name|cff_parse_num
argument_list|(
name|parser
operator|->
name|stack
argument_list|)
expr_stmt|;
goto|goto
name|Store_Number
goto|;
case|case
name|cff_kind_fixed
case|:
name|val
operator|=
name|cff_parse_fixed
argument_list|(
name|parser
operator|->
name|stack
argument_list|)
expr_stmt|;
goto|goto
name|Store_Number
goto|;
case|case
name|cff_kind_fixed_thousand
case|:
name|val
operator|=
name|cff_parse_fixed_scaled
argument_list|(
name|parser
operator|->
name|stack
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|Store_Number
label|:
switch|switch
condition|(
name|field
operator|->
name|size
condition|)
block|{
case|case
operator|(
literal|8
operator|/
name|FT_CHAR_BIT
operator|)
case|:
operator|*
operator|(
name|FT_Byte
operator|*
operator|)
name|q
operator|=
operator|(
name|FT_Byte
operator|)
name|val
expr_stmt|;
break|break;
case|case
operator|(
literal|16
operator|/
name|FT_CHAR_BIT
operator|)
case|:
operator|*
operator|(
name|FT_Short
operator|*
operator|)
name|q
operator|=
operator|(
name|FT_Short
operator|)
name|val
expr_stmt|;
break|break;
case|case
operator|(
literal|32
operator|/
name|FT_CHAR_BIT
operator|)
case|:
operator|*
operator|(
name|FT_Int32
operator|*
operator|)
name|q
operator|=
operator|(
name|FT_Int
operator|)
name|val
expr_stmt|;
break|break;
default|default:
comment|/* for 64-bit systems */
operator|*
operator|(
name|FT_Long
operator|*
operator|)
name|q
operator|=
name|val
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|FT_DEBUG_LEVEL_TRACE
switch|switch
condition|(
name|field
operator|->
name|kind
condition|)
block|{
case|case
name|cff_kind_bool
case|:
name|FT_TRACE4
argument_list|(
operator|(
literal|" %s\n"
operator|,
name|val
condition|?
literal|"true"
else|:
literal|"false"
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|cff_kind_string
case|:
name|FT_TRACE4
argument_list|(
operator|(
literal|" %ld (SID)\n"
operator|,
name|val
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|cff_kind_num
case|:
name|FT_TRACE4
argument_list|(
operator|(
literal|" %ld\n"
operator|,
name|val
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|cff_kind_fixed
case|:
name|FT_TRACE4
argument_list|(
operator|(
literal|" %f\n"
operator|,
operator|(
name|double
operator|)
name|val
operator|/
literal|65536
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|cff_kind_fixed_thousand
case|:
name|FT_TRACE4
argument_list|(
operator|(
literal|" %f\n"
operator|,
operator|(
name|double
operator|)
name|val
operator|/
literal|65536
operator|/
literal|1000
operator|)
argument_list|)
expr_stmt|;
default|default:
empty_stmt|;
comment|/* never reached */
block|}
endif|#
directive|endif
break|break;
case|case
name|cff_kind_delta
case|:
block|{
name|FT_Byte
modifier|*
name|qcount
init|=
operator|(
name|FT_Byte
operator|*
operator|)
name|parser
operator|->
name|object
operator|+
name|field
operator|->
name|count_offset
decl_stmt|;
name|FT_Byte
modifier|*
modifier|*
name|data
init|=
name|parser
operator|->
name|stack
decl_stmt|;
if|if
condition|(
name|num_args
operator|>
name|field
operator|->
name|array_max
condition|)
name|num_args
operator|=
name|field
operator|->
name|array_max
expr_stmt|;
name|FT_TRACE4
argument_list|(
operator|(
literal|" ["
operator|)
argument_list|)
expr_stmt|;
comment|/* store count */
operator|*
name|qcount
operator|=
operator|(
name|FT_Byte
operator|)
name|num_args
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|num_args
operator|>
literal|0
condition|)
block|{
name|val
operator|+=
name|cff_parse_num
argument_list|(
name|data
operator|++
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|field
operator|->
name|size
condition|)
block|{
case|case
operator|(
literal|8
operator|/
name|FT_CHAR_BIT
operator|)
case|:
operator|*
operator|(
name|FT_Byte
operator|*
operator|)
name|q
operator|=
operator|(
name|FT_Byte
operator|)
name|val
expr_stmt|;
break|break;
case|case
operator|(
literal|16
operator|/
name|FT_CHAR_BIT
operator|)
case|:
operator|*
operator|(
name|FT_Short
operator|*
operator|)
name|q
operator|=
operator|(
name|FT_Short
operator|)
name|val
expr_stmt|;
break|break;
case|case
operator|(
literal|32
operator|/
name|FT_CHAR_BIT
operator|)
case|:
operator|*
operator|(
name|FT_Int32
operator|*
operator|)
name|q
operator|=
operator|(
name|FT_Int
operator|)
name|val
expr_stmt|;
break|break;
default|default:
comment|/* for 64-bit systems */
operator|*
operator|(
name|FT_Long
operator|*
operator|)
name|q
operator|=
name|val
expr_stmt|;
block|}
name|FT_TRACE4
argument_list|(
operator|(
literal|" %ld"
operator|,
name|val
operator|)
argument_list|)
expr_stmt|;
name|q
operator|+=
name|field
operator|->
name|size
expr_stmt|;
name|num_args
operator|--
expr_stmt|;
block|}
name|FT_TRACE4
argument_list|(
operator|(
literal|"]\n"
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
comment|/* callback */
name|error
operator|=
name|field
operator|->
name|reader
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
block|}
goto|goto
name|Found
goto|;
block|}
block|}
comment|/* this is an unknown operator, or it is unsupported; */
comment|/* we will ignore it for now.                         */
name|Found
label|:
comment|/* clear stack */
name|parser
operator|->
name|top
operator|=
name|parser
operator|->
name|stack
expr_stmt|;
block|}
name|p
operator|++
expr_stmt|;
block|}
name|Exit
label|:
return|return
name|error
return|;
name|Stack_Overflow
label|:
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Argument
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
name|Stack_Underflow
label|:
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Argument
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
name|Syntax_Error
label|:
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Argument
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
end_block
begin_comment
comment|/* END */
end_comment
end_unit
