begin_unit
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  cf2font.c                                                              */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*    Adobe's code for font instances (body).                              */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  Copyright 2007-2014 Adobe Systems Incorporated.                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  This software, and all works of authorship, whether in source or       */
end_comment
begin_comment
comment|/*  object code form as indicated by the copyright notice(s) included      */
end_comment
begin_comment
comment|/*  herein (collectively, the "Work") is made available, and may only be   */
end_comment
begin_comment
comment|/*  used, modified, and distributed under the FreeType Project License,    */
end_comment
begin_comment
comment|/*  LICENSE.TXT.  Additionally, subject to the terms and conditions of the */
end_comment
begin_comment
comment|/*  FreeType Project License, each contributor to the Work hereby grants   */
end_comment
begin_comment
comment|/*  to any individual or legal entity exercising permissions granted by    */
end_comment
begin_comment
comment|/*  the FreeType Project License and this section (hereafter, "You" or     */
end_comment
begin_comment
comment|/*  "Your") a perpetual, worldwide, non-exclusive, no-charge,              */
end_comment
begin_comment
comment|/*  royalty-free, irrevocable (except as stated in this section) patent    */
end_comment
begin_comment
comment|/*  license to make, have made, use, offer to sell, sell, import, and      */
end_comment
begin_comment
comment|/*  otherwise transfer the Work, where such license applies only to those  */
end_comment
begin_comment
comment|/*  patent claims licensable by such contributor that are necessarily      */
end_comment
begin_comment
comment|/*  infringed by their contribution(s) alone or by combination of their    */
end_comment
begin_comment
comment|/*  contribution(s) with the Work to which such contribution(s) was        */
end_comment
begin_comment
comment|/*  submitted.  If You institute patent litigation against any entity      */
end_comment
begin_comment
comment|/*  (including a cross-claim or counterclaim in a lawsuit) alleging that   */
end_comment
begin_comment
comment|/*  the Work or a contribution incorporated within the Work constitutes    */
end_comment
begin_comment
comment|/*  direct or contributory patent infringement, then any patent licenses   */
end_comment
begin_comment
comment|/*  granted to You under this License for that Work shall terminate as of  */
end_comment
begin_comment
comment|/*  the date such litigation is filed.                                     */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  By using, modifying, or distributing the Work you indicate that you    */
end_comment
begin_comment
comment|/*  have read and understood the terms and conditions of the               */
end_comment
begin_comment
comment|/*  FreeType Project License as well as those provided in this section,    */
end_comment
begin_comment
comment|/*  and you accept them fully.                                             */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<ft2build.h>
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_CALC_H
end_include
begin_include
include|#
directive|include
file|"cf2ft.h"
end_include
begin_include
include|#
directive|include
file|"cf2glue.h"
end_include
begin_include
include|#
directive|include
file|"cf2font.h"
end_include
begin_include
include|#
directive|include
file|"cf2error.h"
end_include
begin_include
include|#
directive|include
file|"cf2intrp.h"
end_include
begin_comment
comment|/* Compute a stem darkening amount in character space. */
end_comment
begin_function
specifier|static
name|void
DECL|function|cf2_computeDarkening
name|cf2_computeDarkening
parameter_list|(
name|CF2_Fixed
name|emRatio
parameter_list|,
name|CF2_Fixed
name|ppem
parameter_list|,
name|CF2_Fixed
name|stemWidth
parameter_list|,
name|CF2_Fixed
modifier|*
name|darkenAmount
parameter_list|,
name|CF2_Fixed
name|boldenAmount
parameter_list|,
name|FT_Bool
name|stemDarkened
parameter_list|,
name|FT_Int
modifier|*
name|darkenParams
parameter_list|)
block|{
comment|/*      * Total darkening amount is computed in 1000 unit character space      * using the modified 5 part curve as Adobe's Avalon rasterizer.      * The darkening amount is smaller for thicker stems.      * It becomes zero when the stem is thicker than 2.333 pixels.      *      * By default, we use      *      *   darkenAmount = 0.4 pixels   if scaledStem<= 0.5 pixels,      *   darkenAmount = 0.275 pixels if 1<= scaledStem<= 1.667 pixels,      *   darkenAmount = 0 pixel      if scaledStem>= 2.333 pixels,      *      * and piecewise linear in-between:      *      *      *   darkening      *       ^      *       |      *       |      (x1,y1)      *       |--------+      *       |         \      *       |          \      *       |           \          (x3,y3)      *       |            +----------+      *       |        (x2,y2)         \      *       |                         \      *       |                          \      *       |                           +-----------------      *       |                         (x4,y4)      *       +--------------------------------------------->   stem      *                                                       thickness      *      *      * This corresponds to the following values for the      * `darkening-parameters' property:      *      *   (x1, y1) = (500, 400)      *   (x2, y2) = (1000, 275)      *   (x3, y3) = (1667, 275)      *   (x4, y4) = (2333, 0)      *      */
comment|/* Internal calculations are done in units per thousand for */
comment|/* convenience. The x axis is scaled stem width in          */
comment|/* thousandths of a pixel. That is, 1000 is 1 pixel.        */
comment|/* The y axis is darkening amount in thousandths of a pixel.*/
comment|/* In the code, below, dividing by ppem and                 */
comment|/* adjusting for emRatio converts darkenAmount to character */
comment|/* space (font units).                                      */
name|CF2_Fixed
name|stemWidthPer1000
decl_stmt|,
name|scaledStem
decl_stmt|;
name|FT_Int
name|logBase2
decl_stmt|;
operator|*
name|darkenAmount
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|boldenAmount
operator|==
literal|0
operator|&&
operator|!
name|stemDarkened
condition|)
return|return;
comment|/* protect against range problems and divide by zero */
if|if
condition|(
name|emRatio
operator|<
name|cf2_floatToFixed
argument_list|(
literal|.01
argument_list|)
condition|)
return|return;
if|if
condition|(
name|stemDarkened
condition|)
block|{
name|FT_Int
name|x1
init|=
name|darkenParams
index|[
literal|0
index|]
decl_stmt|;
name|FT_Int
name|y1
init|=
name|darkenParams
index|[
literal|1
index|]
decl_stmt|;
name|FT_Int
name|x2
init|=
name|darkenParams
index|[
literal|2
index|]
decl_stmt|;
name|FT_Int
name|y2
init|=
name|darkenParams
index|[
literal|3
index|]
decl_stmt|;
name|FT_Int
name|x3
init|=
name|darkenParams
index|[
literal|4
index|]
decl_stmt|;
name|FT_Int
name|y3
init|=
name|darkenParams
index|[
literal|5
index|]
decl_stmt|;
name|FT_Int
name|x4
init|=
name|darkenParams
index|[
literal|6
index|]
decl_stmt|;
name|FT_Int
name|y4
init|=
name|darkenParams
index|[
literal|7
index|]
decl_stmt|;
comment|/* convert from true character space to 1000 unit character space; */
comment|/* add synthetic emboldening effect                                */
comment|/* `stemWidthPer1000' will not overflow for a legitimate font      */
name|stemWidthPer1000
operator|=
name|FT_MulFix
argument_list|(
name|stemWidth
operator|+
name|boldenAmount
argument_list|,
name|emRatio
argument_list|)
expr_stmt|;
comment|/* `scaledStem' can easily overflow, so we must clamp its maximum  */
comment|/* value; the test doesn't need to be precise, but must be         */
comment|/* conservative.  The clamp value (default 2333) where             */
comment|/* `darkenAmount' is zero is well below the overflow value of      */
comment|/* 32767.                                                          */
comment|/*                                                                 */
comment|/* FT_MSB computes the integer part of the base 2 logarithm.  The  */
comment|/* number of bits for the product is 1 or 2 more than the sum of   */
comment|/* logarithms; remembering that the 16 lowest bits of the fraction */
comment|/* are dropped this is correct to within a factor of almost 4.     */
comment|/* For example, 0x80.0000 * 0x80.0000 = 0x4000.0000 is 23+23 and   */
comment|/* is flagged as possible overflow because 0xFF.FFFF * 0xFF.FFFF = */
comment|/* 0xFFFF.FE00 is also 23+23.                                      */
name|logBase2
operator|=
name|FT_MSB
argument_list|(
operator|(
name|FT_UInt32
operator|)
name|stemWidthPer1000
argument_list|)
operator|+
name|FT_MSB
argument_list|(
operator|(
name|FT_UInt32
operator|)
name|ppem
argument_list|)
expr_stmt|;
if|if
condition|(
name|logBase2
operator|>=
literal|46
condition|)
comment|/* possible overflow */
name|scaledStem
operator|=
name|cf2_intToFixed
argument_list|(
name|x4
argument_list|)
expr_stmt|;
else|else
name|scaledStem
operator|=
name|FT_MulFix
argument_list|(
name|stemWidthPer1000
argument_list|,
name|ppem
argument_list|)
expr_stmt|;
comment|/* now apply the darkening parameters */
if|if
condition|(
name|scaledStem
operator|<
name|cf2_intToFixed
argument_list|(
name|x1
argument_list|)
condition|)
operator|*
name|darkenAmount
operator|=
name|FT_DivFix
argument_list|(
name|cf2_intToFixed
argument_list|(
name|y1
argument_list|)
argument_list|,
name|ppem
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|scaledStem
operator|<
name|cf2_intToFixed
argument_list|(
name|x2
argument_list|)
condition|)
block|{
name|FT_Int
name|xdelta
init|=
name|x2
operator|-
name|x1
decl_stmt|;
name|FT_Int
name|ydelta
init|=
name|y2
operator|-
name|y1
decl_stmt|;
name|FT_Int
name|x
init|=
name|stemWidthPer1000
operator|-
name|FT_DivFix
argument_list|(
name|cf2_intToFixed
argument_list|(
name|x1
argument_list|)
argument_list|,
name|ppem
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|xdelta
condition|)
goto|goto
name|Try_x3
goto|;
operator|*
name|darkenAmount
operator|=
name|FT_MulDiv
argument_list|(
name|x
argument_list|,
name|ydelta
argument_list|,
name|xdelta
argument_list|)
operator|+
name|FT_DivFix
argument_list|(
name|cf2_intToFixed
argument_list|(
name|y1
argument_list|)
argument_list|,
name|ppem
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scaledStem
operator|<
name|cf2_intToFixed
argument_list|(
name|x3
argument_list|)
condition|)
block|{
name|Try_x3
label|:
block|{
name|FT_Int
name|xdelta
init|=
name|x3
operator|-
name|x2
decl_stmt|;
name|FT_Int
name|ydelta
init|=
name|y3
operator|-
name|y2
decl_stmt|;
name|FT_Int
name|x
init|=
name|stemWidthPer1000
operator|-
name|FT_DivFix
argument_list|(
name|cf2_intToFixed
argument_list|(
name|x2
argument_list|)
argument_list|,
name|ppem
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|xdelta
condition|)
goto|goto
name|Try_x4
goto|;
operator|*
name|darkenAmount
operator|=
name|FT_MulDiv
argument_list|(
name|x
argument_list|,
name|ydelta
argument_list|,
name|xdelta
argument_list|)
operator|+
name|FT_DivFix
argument_list|(
name|cf2_intToFixed
argument_list|(
name|y2
argument_list|)
argument_list|,
name|ppem
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|scaledStem
operator|<
name|cf2_intToFixed
argument_list|(
name|x4
argument_list|)
condition|)
block|{
name|Try_x4
label|:
block|{
name|FT_Int
name|xdelta
init|=
name|x4
operator|-
name|x3
decl_stmt|;
name|FT_Int
name|ydelta
init|=
name|y4
operator|-
name|y3
decl_stmt|;
name|FT_Int
name|x
init|=
name|stemWidthPer1000
operator|-
name|FT_DivFix
argument_list|(
name|cf2_intToFixed
argument_list|(
name|x3
argument_list|)
argument_list|,
name|ppem
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|xdelta
condition|)
goto|goto
name|Use_y4
goto|;
operator|*
name|darkenAmount
operator|=
name|FT_MulDiv
argument_list|(
name|x
argument_list|,
name|ydelta
argument_list|,
name|xdelta
argument_list|)
operator|+
name|FT_DivFix
argument_list|(
name|cf2_intToFixed
argument_list|(
name|y3
argument_list|)
argument_list|,
name|ppem
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|Use_y4
label|:
operator|*
name|darkenAmount
operator|=
name|FT_DivFix
argument_list|(
name|cf2_intToFixed
argument_list|(
name|y4
argument_list|)
argument_list|,
name|ppem
argument_list|)
expr_stmt|;
block|}
comment|/* use half the amount on each side and convert back to true */
comment|/* character space                                           */
operator|*
name|darkenAmount
operator|=
name|FT_DivFix
argument_list|(
operator|*
name|darkenAmount
argument_list|,
literal|2
operator|*
name|emRatio
argument_list|)
expr_stmt|;
block|}
comment|/* add synthetic emboldening effect in character space */
operator|*
name|darkenAmount
operator|+=
name|boldenAmount
operator|/
literal|2
expr_stmt|;
block|}
end_function
begin_comment
comment|/* set up values for the current FontDict and matrix */
end_comment
begin_comment
comment|/* caller's transform is adjusted for subpixel positioning */
end_comment
begin_function
specifier|static
name|void
DECL|function|cf2_font_setup
name|cf2_font_setup
parameter_list|(
name|CF2_Font
name|font
parameter_list|,
specifier|const
name|CF2_Matrix
modifier|*
name|transform
parameter_list|)
block|{
comment|/* pointer to parsed font object */
name|CFF_Decoder
modifier|*
name|decoder
init|=
name|font
operator|->
name|decoder
decl_stmt|;
name|FT_Bool
name|needExtraSetup
init|=
name|FALSE
decl_stmt|;
comment|/* character space units */
name|CF2_Fixed
name|boldenX
init|=
name|font
operator|->
name|syntheticEmboldeningAmountX
decl_stmt|;
name|CF2_Fixed
name|boldenY
init|=
name|font
operator|->
name|syntheticEmboldeningAmountY
decl_stmt|;
name|CFF_SubFont
name|subFont
decl_stmt|;
name|CF2_Fixed
name|ppem
decl_stmt|;
comment|/* clear previous error */
name|font
operator|->
name|error
operator|=
name|FT_Err_Ok
expr_stmt|;
comment|/* if a CID fontDict has changed, we need to recompute some cached */
comment|/* data                                                            */
name|subFont
operator|=
name|cf2_getSubfont
argument_list|(
name|decoder
argument_list|)
expr_stmt|;
if|if
condition|(
name|font
operator|->
name|lastSubfont
operator|!=
name|subFont
condition|)
block|{
name|font
operator|->
name|lastSubfont
operator|=
name|subFont
expr_stmt|;
name|needExtraSetup
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* if ppem has changed, we need to recompute some cached data         */
comment|/* note: because of CID font matrix concatenation, ppem and transform */
comment|/*       do not necessarily track.                                    */
name|ppem
operator|=
name|cf2_getPpemY
argument_list|(
name|decoder
argument_list|)
expr_stmt|;
if|if
condition|(
name|font
operator|->
name|ppem
operator|!=
name|ppem
condition|)
block|{
name|font
operator|->
name|ppem
operator|=
name|ppem
expr_stmt|;
name|needExtraSetup
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* copy hinted flag on each call */
name|font
operator|->
name|hinted
operator|=
call|(
name|FT_Bool
call|)
argument_list|(
name|font
operator|->
name|renderingFlags
operator|&
name|CF2_FlagsHinted
argument_list|)
expr_stmt|;
comment|/* determine if transform has changed;       */
comment|/* include Fontmatrix but ignore translation */
if|if
condition|(
name|ft_memcmp
argument_list|(
name|transform
argument_list|,
operator|&
name|font
operator|->
name|currentTransform
argument_list|,
literal|4
operator|*
sizeof|sizeof
argument_list|(
name|CF2_Fixed
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* save `key' information for `cache of one' matrix data; */
comment|/* save client transform, without the translation         */
name|font
operator|->
name|currentTransform
operator|=
operator|*
name|transform
expr_stmt|;
name|font
operator|->
name|currentTransform
operator|.
name|tx
operator|=
name|font
operator|->
name|currentTransform
operator|.
name|ty
operator|=
name|cf2_intToFixed
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* TODO: FreeType transform is simple scalar; for now, use identity */
comment|/*       for outer                                                  */
name|font
operator|->
name|innerTransform
operator|=
operator|*
name|transform
expr_stmt|;
name|font
operator|->
name|outerTransform
operator|.
name|a
operator|=
name|font
operator|->
name|outerTransform
operator|.
name|d
operator|=
name|cf2_intToFixed
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|font
operator|->
name|outerTransform
operator|.
name|b
operator|=
name|font
operator|->
name|outerTransform
operator|.
name|c
operator|=
name|cf2_intToFixed
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|needExtraSetup
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/*      * font->darkened is set to true if there is a stem darkening request or      * the font is synthetic emboldened.      * font->darkened controls whether to adjust blue zones, winding order,      * and hinting.      *      */
if|if
condition|(
name|font
operator|->
name|stemDarkened
operator|!=
operator|(
name|font
operator|->
name|renderingFlags
operator|&
name|CF2_FlagsDarkened
operator|)
condition|)
block|{
name|font
operator|->
name|stemDarkened
operator|=
call|(
name|FT_Bool
call|)
argument_list|(
name|font
operator|->
name|renderingFlags
operator|&
name|CF2_FlagsDarkened
argument_list|)
expr_stmt|;
comment|/* blue zones depend on darkened flag */
name|needExtraSetup
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* recompute variables that are dependent on transform or FontDict or */
comment|/* darken flag                                                        */
if|if
condition|(
name|needExtraSetup
condition|)
block|{
comment|/* StdVW is found in the private dictionary;                       */
comment|/* recompute darkening amounts whenever private dictionary or      */
comment|/* transform change                                                */
comment|/* Note: a rendering flag turns darkening on or off, so we want to */
comment|/*       store the `on' amounts;                                   */
comment|/*       darkening amount is computed in character space           */
comment|/* TODO: testing size-dependent darkening here;                    */
comment|/*       what to do for rotations?                                 */
name|CF2_Fixed
name|emRatio
decl_stmt|;
name|CF2_Fixed
name|stdHW
decl_stmt|;
name|CF2_Int
name|unitsPerEm
init|=
name|font
operator|->
name|unitsPerEm
decl_stmt|;
if|if
condition|(
name|unitsPerEm
operator|==
literal|0
condition|)
name|unitsPerEm
operator|=
literal|1000
expr_stmt|;
name|ppem
operator|=
name|FT_MAX
argument_list|(
name|cf2_intToFixed
argument_list|(
literal|4
argument_list|)
argument_list|,
name|font
operator|->
name|ppem
argument_list|)
expr_stmt|;
comment|/* use minimum ppem of 4 */
if|#
directive|if
literal|0
comment|/* since vstem is measured in the x-direction, we use the `a' member */
comment|/* of the fontMatrix                                                 */
block|emRatio = cf2_fixedFracMul( cf2_intToFixed( 1000 ), fontMatrix->a );
endif|#
directive|endif
comment|/* Freetype does not preserve the fontMatrix when parsing; use */
comment|/* unitsPerEm instead.                                         */
comment|/* TODO: check precision of this                               */
name|emRatio
operator|=
name|cf2_intToFixed
argument_list|(
literal|1000
argument_list|)
operator|/
name|unitsPerEm
expr_stmt|;
name|font
operator|->
name|stdVW
operator|=
name|cf2_getStdVW
argument_list|(
name|decoder
argument_list|)
expr_stmt|;
if|if
condition|(
name|font
operator|->
name|stdVW
operator|<=
literal|0
condition|)
name|font
operator|->
name|stdVW
operator|=
name|FT_DivFix
argument_list|(
name|cf2_intToFixed
argument_list|(
literal|75
argument_list|)
argument_list|,
name|emRatio
argument_list|)
expr_stmt|;
if|if
condition|(
name|boldenX
operator|>
literal|0
condition|)
block|{
comment|/* Ensure that boldenX is at least 1 pixel for synthetic bold font */
comment|/* (similar to what Avalon does)                                   */
name|boldenX
operator|=
name|FT_MAX
argument_list|(
name|boldenX
argument_list|,
name|FT_DivFix
argument_list|(
name|cf2_intToFixed
argument_list|(
name|unitsPerEm
argument_list|)
argument_list|,
name|ppem
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Synthetic emboldening adds at least 1 pixel to darkenX, while */
comment|/* stem darkening adds at most half pixel.  Since the purpose of */
comment|/* stem darkening (readability at small sizes) is met with       */
comment|/* synthetic emboldening, no need to add stem darkening for a    */
comment|/* synthetic bold font.                                          */
name|cf2_computeDarkening
argument_list|(
name|emRatio
argument_list|,
name|ppem
argument_list|,
name|font
operator|->
name|stdVW
argument_list|,
operator|&
name|font
operator|->
name|darkenX
argument_list|,
name|boldenX
argument_list|,
name|FALSE
argument_list|,
name|font
operator|->
name|darkenParams
argument_list|)
expr_stmt|;
block|}
else|else
name|cf2_computeDarkening
argument_list|(
name|emRatio
argument_list|,
name|ppem
argument_list|,
name|font
operator|->
name|stdVW
argument_list|,
operator|&
name|font
operator|->
name|darkenX
argument_list|,
literal|0
argument_list|,
name|font
operator|->
name|stemDarkened
argument_list|,
name|font
operator|->
name|darkenParams
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* since hstem is measured in the y-direction, we use the `d' member */
comment|/* of the fontMatrix                                                 */
comment|/* TODO: use the same units per em as above; check this              */
block|emRatio = cf2_fixedFracMul( cf2_intToFixed( 1000 ), fontMatrix->d );
endif|#
directive|endif
comment|/* set the default stem width, because it must be the same for all */
comment|/* family members;                                                 */
comment|/* choose a constant for StdHW that depends on font contrast       */
name|stdHW
operator|=
name|cf2_getStdHW
argument_list|(
name|decoder
argument_list|)
expr_stmt|;
if|if
condition|(
name|stdHW
operator|>
literal|0
operator|&&
name|font
operator|->
name|stdVW
operator|>
literal|2
operator|*
name|stdHW
condition|)
name|font
operator|->
name|stdHW
operator|=
name|FT_DivFix
argument_list|(
name|cf2_intToFixed
argument_list|(
literal|75
argument_list|)
argument_list|,
name|emRatio
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* low contrast font gets less hstem darkening */
name|font
operator|->
name|stdHW
operator|=
name|FT_DivFix
argument_list|(
name|cf2_intToFixed
argument_list|(
literal|110
argument_list|)
argument_list|,
name|emRatio
argument_list|)
expr_stmt|;
block|}
name|cf2_computeDarkening
argument_list|(
name|emRatio
argument_list|,
name|ppem
argument_list|,
name|font
operator|->
name|stdHW
argument_list|,
operator|&
name|font
operator|->
name|darkenY
argument_list|,
name|boldenY
argument_list|,
name|font
operator|->
name|stemDarkened
argument_list|,
name|font
operator|->
name|darkenParams
argument_list|)
expr_stmt|;
if|if
condition|(
name|font
operator|->
name|darkenX
operator|!=
literal|0
operator|||
name|font
operator|->
name|darkenY
operator|!=
literal|0
condition|)
name|font
operator|->
name|darkened
operator|=
name|TRUE
expr_stmt|;
else|else
name|font
operator|->
name|darkened
operator|=
name|FALSE
expr_stmt|;
name|font
operator|->
name|reverseWinding
operator|=
name|FALSE
expr_stmt|;
comment|/* initial expectation is CCW */
comment|/* compute blue zones for this instance */
name|cf2_blues_init
argument_list|(
operator|&
name|font
operator|->
name|blues
argument_list|,
name|font
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/* equivalent to AdobeGetOutline */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|cf2_getGlyphOutline
argument_list|(
argument|CF2_Font           font
argument_list|,
argument|CF2_Buffer         charstring
argument_list|,
argument|const CF2_Matrix*  transform
argument_list|,
argument|CF2_F16Dot16*      glyphWidth
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|lastError
init|=
name|FT_Err_Ok
decl_stmt|;
name|FT_Vector
name|translation
decl_stmt|;
if|#
directive|if
literal|0
block|FT_Vector  advancePoint;
endif|#
directive|endif
name|CF2_Fixed
name|advWidth
init|=
literal|0
decl_stmt|;
name|FT_Bool
name|needWinding
decl_stmt|;
comment|/* Note: use both integer and fraction for outlines.  This allows bbox */
comment|/*       to come out directly.                                         */
name|translation
operator|.
name|x
operator|=
name|transform
operator|->
name|tx
expr_stmt|;
name|translation
operator|.
name|y
operator|=
name|transform
operator|->
name|ty
expr_stmt|;
comment|/* set up values based on transform */
name|cf2_font_setup
argument_list|(
name|font
argument_list|,
name|transform
argument_list|)
expr_stmt|;
if|if
condition|(
name|font
operator|->
name|error
condition|)
goto|goto
name|exit
goto|;
comment|/* setup encountered an error */
comment|/* reset darken direction */
name|font
operator|->
name|reverseWinding
operator|=
name|FALSE
expr_stmt|;
comment|/* winding order only affects darkening */
name|needWinding
operator|=
name|font
operator|->
name|darkened
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* reset output buffer */
name|cf2_outline_reset
argument_list|(
operator|&
name|font
operator|->
name|outline
argument_list|)
expr_stmt|;
comment|/* build the outline, passing the full translation */
name|cf2_interpT2CharString
argument_list|(
name|font
argument_list|,
name|charstring
argument_list|,
operator|(
name|CF2_OutlineCallbacks
operator|)
operator|&
name|font
operator|->
name|outline
argument_list|,
operator|&
name|translation
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|advWidth
argument_list|)
expr_stmt|;
if|if
condition|(
name|font
operator|->
name|error
condition|)
goto|goto
name|exit
goto|;
if|if
condition|(
operator|!
name|needWinding
condition|)
break|break;
comment|/* check winding order */
if|if
condition|(
name|font
operator|->
name|outline
operator|.
name|root
operator|.
name|windingMomentum
operator|>=
literal|0
condition|)
comment|/* CFF is CCW */
break|break;
comment|/* invert darkening and render again                            */
comment|/* TODO: this should be a parameter to getOutline-computeOffset */
name|font
operator|->
name|reverseWinding
operator|=
name|TRUE
expr_stmt|;
name|needWinding
operator|=
name|FALSE
expr_stmt|;
comment|/* exit after next iteration */
block|}
comment|/* finish storing client outline */
name|cf2_outline_close
argument_list|(
operator|&
name|font
operator|->
name|outline
argument_list|)
expr_stmt|;
name|exit
label|:
comment|/* FreeType just wants the advance width; there is no translation */
operator|*
name|glyphWidth
operator|=
name|advWidth
expr_stmt|;
comment|/* free resources and collect errors from objects we've used */
name|cf2_setError
argument_list|(
operator|&
name|font
operator|->
name|error
argument_list|,
name|lastError
argument_list|)
expr_stmt|;
return|return
name|font
operator|->
name|error
return|;
block|}
end_block
begin_comment
comment|/* END */
end_comment
end_unit
