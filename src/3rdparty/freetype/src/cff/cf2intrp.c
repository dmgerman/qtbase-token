begin_unit
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  cf2intrp.c                                                             */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*    Adobe's CFF Interpreter (body).                                      */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  Copyright 2007-2014 Adobe Systems Incorporated.                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  This software, and all works of authorship, whether in source or       */
end_comment
begin_comment
comment|/*  object code form as indicated by the copyright notice(s) included      */
end_comment
begin_comment
comment|/*  herein (collectively, the "Work") is made available, and may only be   */
end_comment
begin_comment
comment|/*  used, modified, and distributed under the FreeType Project License,    */
end_comment
begin_comment
comment|/*  LICENSE.TXT.  Additionally, subject to the terms and conditions of the */
end_comment
begin_comment
comment|/*  FreeType Project License, each contributor to the Work hereby grants   */
end_comment
begin_comment
comment|/*  to any individual or legal entity exercising permissions granted by    */
end_comment
begin_comment
comment|/*  the FreeType Project License and this section (hereafter, "You" or     */
end_comment
begin_comment
comment|/*  "Your") a perpetual, worldwide, non-exclusive, no-charge,              */
end_comment
begin_comment
comment|/*  royalty-free, irrevocable (except as stated in this section) patent    */
end_comment
begin_comment
comment|/*  license to make, have made, use, offer to sell, sell, import, and      */
end_comment
begin_comment
comment|/*  otherwise transfer the Work, where such license applies only to those  */
end_comment
begin_comment
comment|/*  patent claims licensable by such contributor that are necessarily      */
end_comment
begin_comment
comment|/*  infringed by their contribution(s) alone or by combination of their    */
end_comment
begin_comment
comment|/*  contribution(s) with the Work to which such contribution(s) was        */
end_comment
begin_comment
comment|/*  submitted.  If You institute patent litigation against any entity      */
end_comment
begin_comment
comment|/*  (including a cross-claim or counterclaim in a lawsuit) alleging that   */
end_comment
begin_comment
comment|/*  the Work or a contribution incorporated within the Work constitutes    */
end_comment
begin_comment
comment|/*  direct or contributory patent infringement, then any patent licenses   */
end_comment
begin_comment
comment|/*  granted to You under this License for that Work shall terminate as of  */
end_comment
begin_comment
comment|/*  the date such litigation is filed.                                     */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  By using, modifying, or distributing the Work you indicate that you    */
end_comment
begin_comment
comment|/*  have read and understood the terms and conditions of the               */
end_comment
begin_comment
comment|/*  FreeType Project License as well as those provided in this section,    */
end_comment
begin_comment
comment|/*  and you accept them fully.                                             */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"cf2ft.h"
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_DEBUG_H
end_include
begin_include
include|#
directive|include
file|"cf2glue.h"
end_include
begin_include
include|#
directive|include
file|"cf2font.h"
end_include
begin_include
include|#
directive|include
file|"cf2stack.h"
end_include
begin_include
include|#
directive|include
file|"cf2hints.h"
end_include
begin_include
include|#
directive|include
file|"cf2error.h"
end_include
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
end_comment
begin_comment
comment|/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
end_comment
begin_comment
comment|/* messages during execution.                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_undef
DECL|macro|FT_COMPONENT
undef|#
directive|undef
name|FT_COMPONENT
end_undef
begin_define
DECL|macro|FT_COMPONENT
define|#
directive|define
name|FT_COMPONENT
value|trace_cf2interp
end_define
begin_comment
comment|/* some operators are not implemented yet */
end_comment
begin_define
DECL|macro|CF2_FIXME
define|#
directive|define
name|CF2_FIXME
value|FT_TRACE4(( "cf2_interpT2CharString:"            \                                " operator not implemented yet\n" ))
end_define
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|cf2_hintmask_init
name|cf2_hintmask_init
argument_list|(
argument|CF2_HintMask  hintmask
argument_list|,
argument|FT_Error*     error
argument_list|)
end_macro
begin_block
block|{
name|FT_ZERO
argument_list|(
name|hintmask
argument_list|)
expr_stmt|;
name|hintmask
operator|->
name|error
operator|=
name|error
expr_stmt|;
block|}
end_block
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Bool
argument_list|)
end_macro
begin_macro
name|cf2_hintmask_isValid
argument_list|(
argument|const CF2_HintMask  hintmask
argument_list|)
end_macro
begin_block
block|{
return|return
name|hintmask
operator|->
name|isValid
return|;
block|}
end_block
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Bool
argument_list|)
end_macro
begin_macro
name|cf2_hintmask_isNew
argument_list|(
argument|const CF2_HintMask  hintmask
argument_list|)
end_macro
begin_block
block|{
return|return
name|hintmask
operator|->
name|isNew
return|;
block|}
end_block
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|cf2_hintmask_setNew
name|cf2_hintmask_setNew
argument_list|(
argument|CF2_HintMask  hintmask
argument_list|,
argument|FT_Bool       val
argument_list|)
end_macro
begin_block
block|{
name|hintmask
operator|->
name|isNew
operator|=
name|val
expr_stmt|;
block|}
end_block
begin_comment
comment|/* clients call `getMaskPtr' in order to iterate */
end_comment
begin_comment
comment|/* through hint mask                             */
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Byte*
argument_list|)
end_macro
begin_macro
DECL|function|cf2_hintmask_getMaskPtr
name|cf2_hintmask_getMaskPtr
argument_list|(
argument|CF2_HintMask  hintmask
argument_list|)
end_macro
begin_block
block|{
return|return
name|hintmask
operator|->
name|mask
return|;
block|}
end_block
begin_function
specifier|static
name|size_t
DECL|function|cf2_hintmask_setCounts
name|cf2_hintmask_setCounts
parameter_list|(
name|CF2_HintMask
name|hintmask
parameter_list|,
name|size_t
name|bitCount
parameter_list|)
block|{
if|if
condition|(
name|bitCount
operator|>
name|CF2_MAX_HINTS
condition|)
block|{
comment|/* total of h and v stems must be<= 96 */
name|CF2_SET_ERROR
argument_list|(
name|hintmask
operator|->
name|error
argument_list|,
name|Invalid_Glyph_Format
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|hintmask
operator|->
name|bitCount
operator|=
name|bitCount
expr_stmt|;
name|hintmask
operator|->
name|byteCount
operator|=
operator|(
name|hintmask
operator|->
name|bitCount
operator|+
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
name|hintmask
operator|->
name|isValid
operator|=
name|TRUE
expr_stmt|;
name|hintmask
operator|->
name|isNew
operator|=
name|TRUE
expr_stmt|;
return|return
name|bitCount
return|;
block|}
end_function
begin_comment
comment|/* consume the hintmask bytes from the charstring, advancing the src */
end_comment
begin_comment
comment|/* pointer                                                           */
end_comment
begin_function
specifier|static
name|void
DECL|function|cf2_hintmask_read
name|cf2_hintmask_read
parameter_list|(
name|CF2_HintMask
name|hintmask
parameter_list|,
name|CF2_Buffer
name|charstring
parameter_list|,
name|size_t
name|bitCount
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
ifndef|#
directive|ifndef
name|CF2_NDEBUG
comment|/* these are the bits in the final mask byte that should be zero  */
comment|/* Note: this variable is only used in an assert expression below */
comment|/* and then only if CF2_NDEBUG is not defined                     */
name|CF2_UInt
name|mask
init|=
operator|(
literal|1
operator|<<
operator|(
operator|-
operator|(
name|CF2_Int
operator|)
name|bitCount
operator|&
literal|7
operator|)
operator|)
operator|-
literal|1
decl_stmt|;
endif|#
directive|endif
comment|/* initialize counts and isValid */
if|if
condition|(
name|cf2_hintmask_setCounts
argument_list|(
name|hintmask
argument_list|,
name|bitCount
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|FT_ASSERT
argument_list|(
name|hintmask
operator|->
name|byteCount
operator|>
literal|0
argument_list|)
expr_stmt|;
name|FT_TRACE4
argument_list|(
operator|(
literal|" (maskbytes:"
operator|)
argument_list|)
expr_stmt|;
comment|/* set mask and advance interpreter's charstring pointer */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hintmask
operator|->
name|byteCount
condition|;
name|i
operator|++
control|)
block|{
name|hintmask
operator|->
name|mask
index|[
name|i
index|]
operator|=
operator|(
name|FT_Byte
operator|)
name|cf2_buf_readByte
argument_list|(
name|charstring
argument_list|)
expr_stmt|;
name|FT_TRACE4
argument_list|(
operator|(
literal|" 0x%02X"
operator|,
name|hintmask
operator|->
name|mask
index|[
name|i
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
name|FT_TRACE4
argument_list|(
operator|(
literal|")\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* assert any unused bits in last byte are zero unless there's a prior */
comment|/* error                                                               */
comment|/* bitCount -> mask, 0 -> 0, 1 -> 7f, 2 -> 3f, ... 6 -> 3, 7 -> 1      */
ifndef|#
directive|ifndef
name|CF2_NDEBUG
name|FT_ASSERT
argument_list|(
operator|(
name|hintmask
operator|->
name|mask
index|[
name|hintmask
operator|->
name|byteCount
operator|-
literal|1
index|]
operator|&
name|mask
operator|)
operator|==
literal|0
operator|||
operator|*
name|hintmask
operator|->
name|error
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|cf2_hintmask_setAll
name|cf2_hintmask_setAll
argument_list|(
argument|CF2_HintMask  hintmask
argument_list|,
argument|size_t        bitCount
argument_list|)
end_macro
begin_block
block|{
name|size_t
name|i
decl_stmt|;
name|CF2_UInt
name|mask
init|=
operator|(
literal|1
operator|<<
operator|(
operator|-
operator|(
name|CF2_Int
operator|)
name|bitCount
operator|&
literal|7
operator|)
operator|)
operator|-
literal|1
decl_stmt|;
comment|/* initialize counts and isValid */
if|if
condition|(
name|cf2_hintmask_setCounts
argument_list|(
name|hintmask
argument_list|,
name|bitCount
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|FT_ASSERT
argument_list|(
name|hintmask
operator|->
name|byteCount
operator|>
literal|0
argument_list|)
expr_stmt|;
name|FT_ASSERT
argument_list|(
name|hintmask
operator|->
name|byteCount
operator|<
sizeof|sizeof
argument_list|(
name|hintmask
operator|->
name|mask
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|hintmask
operator|->
name|mask
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set mask to all ones */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hintmask
operator|->
name|byteCount
condition|;
name|i
operator|++
control|)
name|hintmask
operator|->
name|mask
index|[
name|i
index|]
operator|=
literal|0xFF
expr_stmt|;
comment|/* clear unused bits                                              */
comment|/* bitCount -> mask, 0 -> 0, 1 -> 7f, 2 -> 3f, ... 6 -> 3, 7 -> 1 */
name|hintmask
operator|->
name|mask
index|[
name|hintmask
operator|->
name|byteCount
operator|-
literal|1
index|]
operator|&=
operator|~
name|mask
expr_stmt|;
block|}
end_block
begin_comment
comment|/* Type2 charstring opcodes */
end_comment
begin_enum
enum|enum
block|{
DECL|enumerator|cf2_cmdRESERVED_0
name|cf2_cmdRESERVED_0
block|,
comment|/* 0 */
DECL|enumerator|cf2_cmdHSTEM
name|cf2_cmdHSTEM
block|,
comment|/* 1 */
DECL|enumerator|cf2_cmdRESERVED_2
name|cf2_cmdRESERVED_2
block|,
comment|/* 2 */
DECL|enumerator|cf2_cmdVSTEM
name|cf2_cmdVSTEM
block|,
comment|/* 3 */
DECL|enumerator|cf2_cmdVMOVETO
name|cf2_cmdVMOVETO
block|,
comment|/* 4 */
DECL|enumerator|cf2_cmdRLINETO
name|cf2_cmdRLINETO
block|,
comment|/* 5 */
DECL|enumerator|cf2_cmdHLINETO
name|cf2_cmdHLINETO
block|,
comment|/* 6 */
DECL|enumerator|cf2_cmdVLINETO
name|cf2_cmdVLINETO
block|,
comment|/* 7 */
DECL|enumerator|cf2_cmdRRCURVETO
name|cf2_cmdRRCURVETO
block|,
comment|/* 8 */
DECL|enumerator|cf2_cmdRESERVED_9
name|cf2_cmdRESERVED_9
block|,
comment|/* 9 */
DECL|enumerator|cf2_cmdCALLSUBR
name|cf2_cmdCALLSUBR
block|,
comment|/* 10 */
DECL|enumerator|cf2_cmdRETURN
name|cf2_cmdRETURN
block|,
comment|/* 11 */
DECL|enumerator|cf2_cmdESC
name|cf2_cmdESC
block|,
comment|/* 12 */
DECL|enumerator|cf2_cmdRESERVED_13
name|cf2_cmdRESERVED_13
block|,
comment|/* 13 */
DECL|enumerator|cf2_cmdENDCHAR
name|cf2_cmdENDCHAR
block|,
comment|/* 14 */
DECL|enumerator|cf2_cmdRESERVED_15
name|cf2_cmdRESERVED_15
block|,
comment|/* 15 */
DECL|enumerator|cf2_cmdRESERVED_16
name|cf2_cmdRESERVED_16
block|,
comment|/* 16 */
DECL|enumerator|cf2_cmdRESERVED_17
name|cf2_cmdRESERVED_17
block|,
comment|/* 17 */
DECL|enumerator|cf2_cmdHSTEMHM
name|cf2_cmdHSTEMHM
block|,
comment|/* 18 */
DECL|enumerator|cf2_cmdHINTMASK
name|cf2_cmdHINTMASK
block|,
comment|/* 19 */
DECL|enumerator|cf2_cmdCNTRMASK
name|cf2_cmdCNTRMASK
block|,
comment|/* 20 */
DECL|enumerator|cf2_cmdRMOVETO
name|cf2_cmdRMOVETO
block|,
comment|/* 21 */
DECL|enumerator|cf2_cmdHMOVETO
name|cf2_cmdHMOVETO
block|,
comment|/* 22 */
DECL|enumerator|cf2_cmdVSTEMHM
name|cf2_cmdVSTEMHM
block|,
comment|/* 23 */
DECL|enumerator|cf2_cmdRCURVELINE
name|cf2_cmdRCURVELINE
block|,
comment|/* 24 */
DECL|enumerator|cf2_cmdRLINECURVE
name|cf2_cmdRLINECURVE
block|,
comment|/* 25 */
DECL|enumerator|cf2_cmdVVCURVETO
name|cf2_cmdVVCURVETO
block|,
comment|/* 26 */
DECL|enumerator|cf2_cmdHHCURVETO
name|cf2_cmdHHCURVETO
block|,
comment|/* 27 */
DECL|enumerator|cf2_cmdEXTENDEDNMBR
name|cf2_cmdEXTENDEDNMBR
block|,
comment|/* 28 */
DECL|enumerator|cf2_cmdCALLGSUBR
name|cf2_cmdCALLGSUBR
block|,
comment|/* 29 */
DECL|enumerator|cf2_cmdVHCURVETO
name|cf2_cmdVHCURVETO
block|,
comment|/* 30 */
DECL|enumerator|cf2_cmdHVCURVETO
name|cf2_cmdHVCURVETO
comment|/* 31 */
block|}
enum|;
end_enum
begin_enum
enum|enum
block|{
DECL|enumerator|cf2_escDOTSECTION
name|cf2_escDOTSECTION
block|,
comment|/* 0 */
DECL|enumerator|cf2_escRESERVED_1
name|cf2_escRESERVED_1
block|,
comment|/* 1 */
DECL|enumerator|cf2_escRESERVED_2
name|cf2_escRESERVED_2
block|,
comment|/* 2 */
DECL|enumerator|cf2_escAND
name|cf2_escAND
block|,
comment|/* 3 */
DECL|enumerator|cf2_escOR
name|cf2_escOR
block|,
comment|/* 4 */
DECL|enumerator|cf2_escNOT
name|cf2_escNOT
block|,
comment|/* 5 */
DECL|enumerator|cf2_escRESERVED_6
name|cf2_escRESERVED_6
block|,
comment|/* 6 */
DECL|enumerator|cf2_escRESERVED_7
name|cf2_escRESERVED_7
block|,
comment|/* 7 */
DECL|enumerator|cf2_escRESERVED_8
name|cf2_escRESERVED_8
block|,
comment|/* 8 */
DECL|enumerator|cf2_escABS
name|cf2_escABS
block|,
comment|/* 9 */
DECL|enumerator|cf2_escADD
name|cf2_escADD
block|,
comment|/* 10     like otherADD */
DECL|enumerator|cf2_escSUB
name|cf2_escSUB
block|,
comment|/* 11     like otherSUB */
DECL|enumerator|cf2_escDIV
name|cf2_escDIV
block|,
comment|/* 12 */
DECL|enumerator|cf2_escRESERVED_13
name|cf2_escRESERVED_13
block|,
comment|/* 13 */
DECL|enumerator|cf2_escNEG
name|cf2_escNEG
block|,
comment|/* 14 */
DECL|enumerator|cf2_escEQ
name|cf2_escEQ
block|,
comment|/* 15 */
DECL|enumerator|cf2_escRESERVED_16
name|cf2_escRESERVED_16
block|,
comment|/* 16 */
DECL|enumerator|cf2_escRESERVED_17
name|cf2_escRESERVED_17
block|,
comment|/* 17 */
DECL|enumerator|cf2_escDROP
name|cf2_escDROP
block|,
comment|/* 18 */
DECL|enumerator|cf2_escRESERVED_19
name|cf2_escRESERVED_19
block|,
comment|/* 19 */
DECL|enumerator|cf2_escPUT
name|cf2_escPUT
block|,
comment|/* 20     like otherPUT    */
DECL|enumerator|cf2_escGET
name|cf2_escGET
block|,
comment|/* 21     like otherGET    */
DECL|enumerator|cf2_escIFELSE
name|cf2_escIFELSE
block|,
comment|/* 22     like otherIFELSE */
DECL|enumerator|cf2_escRANDOM
name|cf2_escRANDOM
block|,
comment|/* 23     like otherRANDOM */
DECL|enumerator|cf2_escMUL
name|cf2_escMUL
block|,
comment|/* 24     like otherMUL    */
DECL|enumerator|cf2_escRESERVED_25
name|cf2_escRESERVED_25
block|,
comment|/* 25 */
DECL|enumerator|cf2_escSQRT
name|cf2_escSQRT
block|,
comment|/* 26 */
DECL|enumerator|cf2_escDUP
name|cf2_escDUP
block|,
comment|/* 27     like otherDUP    */
DECL|enumerator|cf2_escEXCH
name|cf2_escEXCH
block|,
comment|/* 28     like otherEXCH   */
DECL|enumerator|cf2_escINDEX
name|cf2_escINDEX
block|,
comment|/* 29 */
DECL|enumerator|cf2_escROLL
name|cf2_escROLL
block|,
comment|/* 30 */
DECL|enumerator|cf2_escRESERVED_31
name|cf2_escRESERVED_31
block|,
comment|/* 31 */
DECL|enumerator|cf2_escRESERVED_32
name|cf2_escRESERVED_32
block|,
comment|/* 32 */
DECL|enumerator|cf2_escRESERVED_33
name|cf2_escRESERVED_33
block|,
comment|/* 33 */
DECL|enumerator|cf2_escHFLEX
name|cf2_escHFLEX
block|,
comment|/* 34 */
DECL|enumerator|cf2_escFLEX
name|cf2_escFLEX
block|,
comment|/* 35 */
DECL|enumerator|cf2_escHFLEX1
name|cf2_escHFLEX1
block|,
comment|/* 36 */
DECL|enumerator|cf2_escFLEX1
name|cf2_escFLEX1
comment|/* 37 */
block|}
enum|;
end_enum
begin_comment
comment|/* `stemHintArray' does not change once we start drawing the outline. */
end_comment
begin_function
specifier|static
name|void
DECL|function|cf2_doStems
name|cf2_doStems
parameter_list|(
specifier|const
name|CF2_Font
name|font
parameter_list|,
name|CF2_Stack
name|opStack
parameter_list|,
name|CF2_ArrStack
name|stemHintArray
parameter_list|,
name|CF2_Fixed
modifier|*
name|width
parameter_list|,
name|FT_Bool
modifier|*
name|haveWidth
parameter_list|,
name|CF2_Fixed
name|hintOffset
parameter_list|)
block|{
name|CF2_UInt
name|i
decl_stmt|;
name|CF2_UInt
name|count
init|=
name|cf2_stack_count
argument_list|(
name|opStack
argument_list|)
decl_stmt|;
name|FT_Bool
name|hasWidthArg
init|=
call|(
name|FT_Bool
call|)
argument_list|(
name|count
operator|&
literal|1
argument_list|)
decl_stmt|;
comment|/* variable accumulates delta values from operand stack */
name|CF2_Fixed
name|position
init|=
name|hintOffset
decl_stmt|;
if|if
condition|(
name|hasWidthArg
operator|&&
operator|!
operator|*
name|haveWidth
condition|)
operator|*
name|width
operator|=
name|cf2_stack_getReal
argument_list|(
name|opStack
argument_list|,
literal|0
argument_list|)
operator|+
name|cf2_getNominalWidthX
argument_list|(
name|font
operator|->
name|decoder
argument_list|)
expr_stmt|;
if|if
condition|(
name|font
operator|->
name|decoder
operator|->
name|width_only
condition|)
goto|goto
name|exit
goto|;
for|for
control|(
name|i
operator|=
name|hasWidthArg
condition|?
literal|1
else|:
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|+=
literal|2
control|)
block|{
comment|/* construct a CF2_StemHint and push it onto the list */
name|CF2_StemHintRec
name|stemhint
decl_stmt|;
name|stemhint
operator|.
name|min
operator|=
name|position
operator|+=
name|cf2_stack_getReal
argument_list|(
name|opStack
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|stemhint
operator|.
name|max
operator|=
name|position
operator|+=
name|cf2_stack_getReal
argument_list|(
name|opStack
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|stemhint
operator|.
name|used
operator|=
name|FALSE
expr_stmt|;
name|stemhint
operator|.
name|maxDS
operator|=
name|stemhint
operator|.
name|minDS
operator|=
literal|0
expr_stmt|;
name|cf2_arrstack_push
argument_list|(
name|stemHintArray
argument_list|,
operator|&
name|stemhint
argument_list|)
expr_stmt|;
comment|/* defer error check */
block|}
name|cf2_stack_clear
argument_list|(
name|opStack
argument_list|)
expr_stmt|;
name|exit
label|:
comment|/* cf2_doStems must define a width (may be default) */
operator|*
name|haveWidth
operator|=
name|TRUE
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|cf2_doFlex
name|cf2_doFlex
parameter_list|(
name|CF2_Stack
name|opStack
parameter_list|,
name|CF2_Fixed
modifier|*
name|curX
parameter_list|,
name|CF2_Fixed
modifier|*
name|curY
parameter_list|,
name|CF2_GlyphPath
name|glyphPath
parameter_list|,
specifier|const
name|FT_Bool
modifier|*
name|readFromStack
parameter_list|,
name|FT_Bool
name|doConditionalLastRead
parameter_list|)
block|{
name|CF2_Fixed
name|vals
index|[
literal|14
index|]
decl_stmt|;
name|CF2_UInt
name|index
decl_stmt|;
name|FT_Bool
name|isHFlex
decl_stmt|;
name|CF2_Int
name|top
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|vals
index|[
literal|0
index|]
operator|=
operator|*
name|curX
expr_stmt|;
name|vals
index|[
literal|1
index|]
operator|=
operator|*
name|curY
expr_stmt|;
name|index
operator|=
literal|0
expr_stmt|;
name|isHFlex
operator|=
name|readFromStack
index|[
literal|9
index|]
operator|==
name|FALSE
expr_stmt|;
name|top
operator|=
name|isHFlex
condition|?
literal|9
else|:
literal|10
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|top
condition|;
name|i
operator|++
control|)
block|{
name|vals
index|[
name|i
operator|+
literal|2
index|]
operator|=
name|vals
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|readFromStack
index|[
name|i
index|]
condition|)
name|vals
index|[
name|i
operator|+
literal|2
index|]
operator|+=
name|cf2_stack_getReal
argument_list|(
name|opStack
argument_list|,
name|index
operator|++
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isHFlex
condition|)
name|vals
index|[
literal|9
operator|+
literal|2
index|]
operator|=
operator|*
name|curY
expr_stmt|;
if|if
condition|(
name|doConditionalLastRead
condition|)
block|{
name|FT_Bool
name|lastIsX
init|=
call|(
name|FT_Bool
call|)
argument_list|(
name|cf2_fixedAbs
argument_list|(
name|vals
index|[
literal|10
index|]
operator|-
operator|*
name|curX
argument_list|)
operator|>
name|cf2_fixedAbs
argument_list|(
name|vals
index|[
literal|11
index|]
operator|-
operator|*
name|curY
argument_list|)
argument_list|)
decl_stmt|;
name|CF2_Fixed
name|lastVal
init|=
name|cf2_stack_getReal
argument_list|(
name|opStack
argument_list|,
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
name|lastIsX
condition|)
block|{
name|vals
index|[
literal|12
index|]
operator|=
name|vals
index|[
literal|10
index|]
operator|+
name|lastVal
expr_stmt|;
name|vals
index|[
literal|13
index|]
operator|=
operator|*
name|curY
expr_stmt|;
block|}
else|else
block|{
name|vals
index|[
literal|12
index|]
operator|=
operator|*
name|curX
expr_stmt|;
name|vals
index|[
literal|13
index|]
operator|=
name|vals
index|[
literal|11
index|]
operator|+
name|lastVal
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|readFromStack
index|[
literal|10
index|]
condition|)
name|vals
index|[
literal|12
index|]
operator|=
name|vals
index|[
literal|10
index|]
operator|+
name|cf2_stack_getReal
argument_list|(
name|opStack
argument_list|,
name|index
operator|++
argument_list|)
expr_stmt|;
else|else
name|vals
index|[
literal|12
index|]
operator|=
operator|*
name|curX
expr_stmt|;
if|if
condition|(
name|readFromStack
index|[
literal|11
index|]
condition|)
name|vals
index|[
literal|13
index|]
operator|=
name|vals
index|[
literal|11
index|]
operator|+
name|cf2_stack_getReal
argument_list|(
name|opStack
argument_list|,
name|index
argument_list|)
expr_stmt|;
else|else
name|vals
index|[
literal|13
index|]
operator|=
operator|*
name|curY
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|2
condition|;
name|j
operator|++
control|)
name|cf2_glyphpath_curveTo
argument_list|(
name|glyphPath
argument_list|,
name|vals
index|[
name|j
operator|*
literal|6
operator|+
literal|2
index|]
argument_list|,
name|vals
index|[
name|j
operator|*
literal|6
operator|+
literal|3
index|]
argument_list|,
name|vals
index|[
name|j
operator|*
literal|6
operator|+
literal|4
index|]
argument_list|,
name|vals
index|[
name|j
operator|*
literal|6
operator|+
literal|5
index|]
argument_list|,
name|vals
index|[
name|j
operator|*
literal|6
operator|+
literal|6
index|]
argument_list|,
name|vals
index|[
name|j
operator|*
literal|6
operator|+
literal|7
index|]
argument_list|)
expr_stmt|;
name|cf2_stack_clear
argument_list|(
name|opStack
argument_list|)
expr_stmt|;
operator|*
name|curX
operator|=
name|vals
index|[
literal|12
index|]
expr_stmt|;
operator|*
name|curY
operator|=
name|vals
index|[
literal|13
index|]
expr_stmt|;
block|}
end_function
begin_comment
comment|/*    * `error' is a shared error code used by many objects in this    * routine.  Before the code continues from an error, it must check and    * record the error in `*error'.  The idea is that this shared    * error code will record the first error encountered.  If testing    * for an error anyway, the cost of `goto exit' is small, so we do it,    * even if continuing would be safe.  In this case, `lastError' is    * set, so the testing and storing can be done in one place, at `exit'.    *    * Continuing after an error is intended for objects which do their own    * testing of `*error', e.g., array stack functions.  This allows us to    * avoid an extra test after the call.    *    * Unimplemented opcodes are ignored.    *    */
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|cf2_interpT2CharString
name|cf2_interpT2CharString
argument_list|(
argument|CF2_Font              font
argument_list|,
argument|CF2_Buffer            buf
argument_list|,
argument|CF2_OutlineCallbacks  callbacks
argument_list|,
argument|const FT_Vector*      translation
argument_list|,
argument|FT_Bool               doingSeac
argument_list|,
argument|CF2_Fixed             curX
argument_list|,
argument|CF2_Fixed             curY
argument_list|,
argument|CF2_Fixed*            width
argument_list|)
end_macro
begin_block
block|{
comment|/* lastError is used for errors that are immediately tested */
name|FT_Error
name|lastError
init|=
name|FT_Err_Ok
decl_stmt|;
comment|/* pointer to parsed font object */
name|CFF_Decoder
modifier|*
name|decoder
init|=
name|font
operator|->
name|decoder
decl_stmt|;
name|FT_Error
modifier|*
name|error
init|=
operator|&
name|font
operator|->
name|error
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|font
operator|->
name|memory
decl_stmt|;
name|CF2_Fixed
name|scaleY
init|=
name|font
operator|->
name|innerTransform
operator|.
name|d
decl_stmt|;
name|CF2_Fixed
name|nominalWidthX
init|=
name|cf2_getNominalWidthX
argument_list|(
name|decoder
argument_list|)
decl_stmt|;
comment|/* save this for hinting seac accents */
name|CF2_Fixed
name|hintOriginY
init|=
name|curY
decl_stmt|;
name|CF2_Stack
name|opStack
init|=
name|NULL
decl_stmt|;
name|FT_Byte
name|op1
decl_stmt|;
comment|/* first opcode byte */
comment|/* instruction limit; 20,000,000 matches Avalon */
name|FT_UInt32
name|instructionLimit
init|=
literal|20000000UL
decl_stmt|;
name|CF2_ArrStackRec
name|subrStack
decl_stmt|;
name|FT_Bool
name|haveWidth
decl_stmt|;
name|CF2_Buffer
name|charstring
init|=
name|NULL
decl_stmt|;
name|CF2_Int
name|charstringIndex
init|=
operator|-
literal|1
decl_stmt|;
comment|/* initialize to empty */
comment|/* TODO: placeholders for hint structures */
comment|/* objects used for hinting */
name|CF2_ArrStackRec
name|hStemHintArray
decl_stmt|;
name|CF2_ArrStackRec
name|vStemHintArray
decl_stmt|;
name|CF2_HintMaskRec
name|hintMask
decl_stmt|;
name|CF2_GlyphPathRec
name|glyphPath
decl_stmt|;
comment|/* initialize the remaining objects */
name|cf2_arrstack_init
argument_list|(
operator|&
name|subrStack
argument_list|,
name|memory
argument_list|,
name|error
argument_list|,
sizeof|sizeof
argument_list|(
name|CF2_BufferRec
argument_list|)
argument_list|)
expr_stmt|;
name|cf2_arrstack_init
argument_list|(
operator|&
name|hStemHintArray
argument_list|,
name|memory
argument_list|,
name|error
argument_list|,
sizeof|sizeof
argument_list|(
name|CF2_StemHintRec
argument_list|)
argument_list|)
expr_stmt|;
name|cf2_arrstack_init
argument_list|(
operator|&
name|vStemHintArray
argument_list|,
name|memory
argument_list|,
name|error
argument_list|,
sizeof|sizeof
argument_list|(
name|CF2_StemHintRec
argument_list|)
argument_list|)
expr_stmt|;
comment|/* initialize CF2_StemHint arrays */
name|cf2_hintmask_init
argument_list|(
operator|&
name|hintMask
argument_list|,
name|error
argument_list|)
expr_stmt|;
comment|/* initialize path map to manage drawing operations */
comment|/* Note: last 4 params are used to handle `MoveToPermissive', which */
comment|/*       may need to call `hintMap.Build'                           */
comment|/* TODO: MoveToPermissive is gone; are these still needed?          */
name|cf2_glyphpath_init
argument_list|(
operator|&
name|glyphPath
argument_list|,
name|font
argument_list|,
name|callbacks
argument_list|,
name|scaleY
argument_list|,
comment|/* hShift, */
operator|&
name|hStemHintArray
argument_list|,
operator|&
name|vStemHintArray
argument_list|,
operator|&
name|hintMask
argument_list|,
name|hintOriginY
argument_list|,
operator|&
name|font
operator|->
name|blues
argument_list|,
name|translation
argument_list|)
expr_stmt|;
comment|/*      * Initialize state for width parsing.  From the CFF Spec:      *      *   The first stack-clearing operator, which must be one of hstem,      *   hstemhm, vstem, vstemhm, cntrmask, hintmask, hmoveto, vmoveto,      *   rmoveto, or endchar, takes an additional argument - the width (as      *   described earlier), which may be expressed as zero or one numeric      *   argument.      *      * What we implement here uses the first validly specified width, but      * does not detect errors for specifying more than one width.      *      * If one of the above operators occurs without explicitly specifying      * a width, we assume the default width.      *      */
name|haveWidth
operator|=
name|FALSE
expr_stmt|;
operator|*
name|width
operator|=
name|cf2_getDefaultWidthX
argument_list|(
name|decoder
argument_list|)
expr_stmt|;
comment|/*      * Note: at this point, all pointers to resources must be NULL      * and all local objects must be initialized.      * There must be no branches to exit: above this point.      *      */
comment|/* allocate an operand stack */
name|opStack
operator|=
name|cf2_stack_init
argument_list|(
name|memory
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|opStack
condition|)
block|{
name|lastError
operator|=
name|FT_THROW
argument_list|(
name|Out_Of_Memory
argument_list|)
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
comment|/* initialize subroutine stack by placing top level charstring as */
comment|/* first element (max depth plus one for the charstring)          */
comment|/* Note: Caller owns and must finalize the first charstring.      */
comment|/*       Our copy of it does not change that requirement.         */
name|cf2_arrstack_setCount
argument_list|(
operator|&
name|subrStack
argument_list|,
name|CF2_MAX_SUBR
operator|+
literal|1
argument_list|)
expr_stmt|;
name|charstring
operator|=
operator|(
name|CF2_Buffer
operator|)
name|cf2_arrstack_getBuffer
argument_list|(
operator|&
name|subrStack
argument_list|)
expr_stmt|;
operator|*
name|charstring
operator|=
operator|*
name|buf
expr_stmt|;
comment|/* structure copy */
name|charstringIndex
operator|=
literal|0
expr_stmt|;
comment|/* entry is valid now */
comment|/* catch errors so far */
if|if
condition|(
operator|*
name|error
condition|)
goto|goto
name|exit
goto|;
comment|/* main interpreter loop */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|cf2_buf_isEnd
argument_list|(
name|charstring
argument_list|)
condition|)
block|{
comment|/* If we've reached the end of the charstring, simulate a */
comment|/* cf2_cmdRETURN or cf2_cmdENDCHAR.                       */
if|if
condition|(
name|charstringIndex
condition|)
name|op1
operator|=
name|cf2_cmdRETURN
expr_stmt|;
comment|/* end of buffer for subroutine */
else|else
name|op1
operator|=
name|cf2_cmdENDCHAR
expr_stmt|;
comment|/* end of buffer for top level charstring */
block|}
else|else
name|op1
operator|=
operator|(
name|FT_Byte
operator|)
name|cf2_buf_readByte
argument_list|(
name|charstring
argument_list|)
expr_stmt|;
comment|/* check for errors once per loop */
if|if
condition|(
operator|*
name|error
condition|)
goto|goto
name|exit
goto|;
name|instructionLimit
operator|--
expr_stmt|;
if|if
condition|(
name|instructionLimit
operator|==
literal|0
condition|)
block|{
name|lastError
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Glyph_Format
argument_list|)
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
switch|switch
condition|(
name|op1
condition|)
block|{
case|case
name|cf2_cmdRESERVED_0
case|:
case|case
name|cf2_cmdRESERVED_2
case|:
case|case
name|cf2_cmdRESERVED_9
case|:
case|case
name|cf2_cmdRESERVED_13
case|:
case|case
name|cf2_cmdRESERVED_15
case|:
case|case
name|cf2_cmdRESERVED_16
case|:
case|case
name|cf2_cmdRESERVED_17
case|:
comment|/* we may get here if we have a prior error */
name|FT_TRACE4
argument_list|(
operator|(
literal|" unknown op (%d)\n"
operator|,
name|op1
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|cf2_cmdHSTEMHM
case|:
case|case
name|cf2_cmdHSTEM
case|:
name|FT_TRACE4
argument_list|(
operator|(
name|op1
operator|==
name|cf2_cmdHSTEMHM
condition|?
literal|" hstemhm\n"
else|:
literal|" hstem\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* never add hints after the mask is computed */
if|if
condition|(
name|cf2_hintmask_isValid
argument_list|(
operator|&
name|hintMask
argument_list|)
condition|)
block|{
name|FT_TRACE4
argument_list|(
operator|(
literal|"cf2_interpT2CharString:"
literal|" invalid horizontal hint mask\n"
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|cf2_doStems
argument_list|(
name|font
argument_list|,
name|opStack
argument_list|,
operator|&
name|hStemHintArray
argument_list|,
name|width
argument_list|,
operator|&
name|haveWidth
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|font
operator|->
name|decoder
operator|->
name|width_only
condition|)
goto|goto
name|exit
goto|;
break|break;
case|case
name|cf2_cmdVSTEMHM
case|:
case|case
name|cf2_cmdVSTEM
case|:
name|FT_TRACE4
argument_list|(
operator|(
name|op1
operator|==
name|cf2_cmdVSTEMHM
condition|?
literal|" vstemhm\n"
else|:
literal|" vstem\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* never add hints after the mask is computed */
if|if
condition|(
name|cf2_hintmask_isValid
argument_list|(
operator|&
name|hintMask
argument_list|)
condition|)
block|{
name|FT_TRACE4
argument_list|(
operator|(
literal|"cf2_interpT2CharString:"
literal|" invalid vertical hint mask\n"
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|cf2_doStems
argument_list|(
name|font
argument_list|,
name|opStack
argument_list|,
operator|&
name|vStemHintArray
argument_list|,
name|width
argument_list|,
operator|&
name|haveWidth
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|font
operator|->
name|decoder
operator|->
name|width_only
condition|)
goto|goto
name|exit
goto|;
break|break;
case|case
name|cf2_cmdVMOVETO
case|:
name|FT_TRACE4
argument_list|(
operator|(
literal|" vmoveto\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cf2_stack_count
argument_list|(
name|opStack
argument_list|)
operator|>
literal|1
operator|&&
operator|!
name|haveWidth
condition|)
operator|*
name|width
operator|=
name|cf2_stack_getReal
argument_list|(
name|opStack
argument_list|,
literal|0
argument_list|)
operator|+
name|nominalWidthX
expr_stmt|;
comment|/* width is defined or default after this */
name|haveWidth
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|font
operator|->
name|decoder
operator|->
name|width_only
condition|)
goto|goto
name|exit
goto|;
name|curY
operator|+=
name|cf2_stack_popFixed
argument_list|(
name|opStack
argument_list|)
expr_stmt|;
name|cf2_glyphpath_moveTo
argument_list|(
operator|&
name|glyphPath
argument_list|,
name|curX
argument_list|,
name|curY
argument_list|)
expr_stmt|;
break|break;
case|case
name|cf2_cmdRLINETO
case|:
block|{
name|CF2_UInt
name|index
decl_stmt|;
name|CF2_UInt
name|count
init|=
name|cf2_stack_count
argument_list|(
name|opStack
argument_list|)
decl_stmt|;
name|FT_TRACE4
argument_list|(
operator|(
literal|" rlineto\n"
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|count
condition|;
name|index
operator|+=
literal|2
control|)
block|{
name|curX
operator|+=
name|cf2_stack_getReal
argument_list|(
name|opStack
argument_list|,
name|index
operator|+
literal|0
argument_list|)
expr_stmt|;
name|curY
operator|+=
name|cf2_stack_getReal
argument_list|(
name|opStack
argument_list|,
name|index
operator|+
literal|1
argument_list|)
expr_stmt|;
name|cf2_glyphpath_lineTo
argument_list|(
operator|&
name|glyphPath
argument_list|,
name|curX
argument_list|,
name|curY
argument_list|)
expr_stmt|;
block|}
name|cf2_stack_clear
argument_list|(
name|opStack
argument_list|)
expr_stmt|;
block|}
continue|continue;
comment|/* no need to clear stack again */
case|case
name|cf2_cmdHLINETO
case|:
case|case
name|cf2_cmdVLINETO
case|:
block|{
name|CF2_UInt
name|index
decl_stmt|;
name|CF2_UInt
name|count
init|=
name|cf2_stack_count
argument_list|(
name|opStack
argument_list|)
decl_stmt|;
name|FT_Bool
name|isX
init|=
name|op1
operator|==
name|cf2_cmdHLINETO
decl_stmt|;
name|FT_TRACE4
argument_list|(
operator|(
name|isX
condition|?
literal|" hlineto\n"
else|:
literal|" vlineto\n"
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|count
condition|;
name|index
operator|++
control|)
block|{
name|CF2_Fixed
name|v
init|=
name|cf2_stack_getReal
argument_list|(
name|opStack
argument_list|,
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
name|isX
condition|)
name|curX
operator|+=
name|v
expr_stmt|;
else|else
name|curY
operator|+=
name|v
expr_stmt|;
name|isX
operator|=
operator|!
name|isX
expr_stmt|;
name|cf2_glyphpath_lineTo
argument_list|(
operator|&
name|glyphPath
argument_list|,
name|curX
argument_list|,
name|curY
argument_list|)
expr_stmt|;
block|}
name|cf2_stack_clear
argument_list|(
name|opStack
argument_list|)
expr_stmt|;
block|}
continue|continue;
case|case
name|cf2_cmdRCURVELINE
case|:
case|case
name|cf2_cmdRRCURVETO
case|:
block|{
name|CF2_UInt
name|count
init|=
name|cf2_stack_count
argument_list|(
name|opStack
argument_list|)
decl_stmt|;
name|CF2_UInt
name|index
init|=
literal|0
decl_stmt|;
name|FT_TRACE4
argument_list|(
operator|(
name|op1
operator|==
name|cf2_cmdRCURVELINE
condition|?
literal|" rcurveline\n"
else|:
literal|" rrcurveto\n"
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|index
operator|+
literal|6
operator|<=
name|count
condition|)
block|{
name|CF2_Fixed
name|x1
init|=
name|cf2_stack_getReal
argument_list|(
name|opStack
argument_list|,
name|index
operator|+
literal|0
argument_list|)
operator|+
name|curX
decl_stmt|;
name|CF2_Fixed
name|y1
init|=
name|cf2_stack_getReal
argument_list|(
name|opStack
argument_list|,
name|index
operator|+
literal|1
argument_list|)
operator|+
name|curY
decl_stmt|;
name|CF2_Fixed
name|x2
init|=
name|cf2_stack_getReal
argument_list|(
name|opStack
argument_list|,
name|index
operator|+
literal|2
argument_list|)
operator|+
name|x1
decl_stmt|;
name|CF2_Fixed
name|y2
init|=
name|cf2_stack_getReal
argument_list|(
name|opStack
argument_list|,
name|index
operator|+
literal|3
argument_list|)
operator|+
name|y1
decl_stmt|;
name|CF2_Fixed
name|x3
init|=
name|cf2_stack_getReal
argument_list|(
name|opStack
argument_list|,
name|index
operator|+
literal|4
argument_list|)
operator|+
name|x2
decl_stmt|;
name|CF2_Fixed
name|y3
init|=
name|cf2_stack_getReal
argument_list|(
name|opStack
argument_list|,
name|index
operator|+
literal|5
argument_list|)
operator|+
name|y2
decl_stmt|;
name|cf2_glyphpath_curveTo
argument_list|(
operator|&
name|glyphPath
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|,
name|x3
argument_list|,
name|y3
argument_list|)
expr_stmt|;
name|curX
operator|=
name|x3
expr_stmt|;
name|curY
operator|=
name|y3
expr_stmt|;
name|index
operator|+=
literal|6
expr_stmt|;
block|}
if|if
condition|(
name|op1
operator|==
name|cf2_cmdRCURVELINE
condition|)
block|{
name|curX
operator|+=
name|cf2_stack_getReal
argument_list|(
name|opStack
argument_list|,
name|index
operator|+
literal|0
argument_list|)
expr_stmt|;
name|curY
operator|+=
name|cf2_stack_getReal
argument_list|(
name|opStack
argument_list|,
name|index
operator|+
literal|1
argument_list|)
expr_stmt|;
name|cf2_glyphpath_lineTo
argument_list|(
operator|&
name|glyphPath
argument_list|,
name|curX
argument_list|,
name|curY
argument_list|)
expr_stmt|;
block|}
name|cf2_stack_clear
argument_list|(
name|opStack
argument_list|)
expr_stmt|;
block|}
continue|continue;
comment|/* no need to clear stack again */
case|case
name|cf2_cmdCALLGSUBR
case|:
case|case
name|cf2_cmdCALLSUBR
case|:
block|{
name|CF2_UInt
name|subrIndex
decl_stmt|;
name|FT_TRACE4
argument_list|(
operator|(
name|op1
operator|==
name|cf2_cmdCALLGSUBR
condition|?
literal|" callgsubr"
else|:
literal|" callsubr"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|charstringIndex
operator|>
name|CF2_MAX_SUBR
condition|)
block|{
comment|/* max subr plus one for charstring */
name|lastError
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Glyph_Format
argument_list|)
expr_stmt|;
goto|goto
name|exit
goto|;
comment|/* overflow of stack */
block|}
comment|/* push our current CFF charstring region on subrStack */
name|charstring
operator|=
operator|(
name|CF2_Buffer
operator|)
name|cf2_arrstack_getPointer
argument_list|(
operator|&
name|subrStack
argument_list|,
name|charstringIndex
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* set up the new CFF region and pointer */
name|subrIndex
operator|=
name|cf2_stack_popInt
argument_list|(
name|opStack
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|op1
condition|)
block|{
case|case
name|cf2_cmdCALLGSUBR
case|:
name|FT_TRACE4
argument_list|(
operator|(
literal|"(%d)\n"
operator|,
name|subrIndex
operator|+
name|decoder
operator|->
name|globals_bias
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cf2_initGlobalRegionBuffer
argument_list|(
name|decoder
argument_list|,
name|subrIndex
argument_list|,
name|charstring
argument_list|)
condition|)
block|{
name|lastError
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Glyph_Format
argument_list|)
expr_stmt|;
goto|goto
name|exit
goto|;
comment|/* subroutine lookup or stream error */
block|}
break|break;
default|default:
comment|/* cf2_cmdCALLSUBR */
name|FT_TRACE4
argument_list|(
operator|(
literal|"(%d)\n"
operator|,
name|subrIndex
operator|+
name|decoder
operator|->
name|locals_bias
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cf2_initLocalRegionBuffer
argument_list|(
name|decoder
argument_list|,
name|subrIndex
argument_list|,
name|charstring
argument_list|)
condition|)
block|{
name|lastError
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Glyph_Format
argument_list|)
expr_stmt|;
goto|goto
name|exit
goto|;
comment|/* subroutine lookup or stream error */
block|}
block|}
name|charstringIndex
operator|+=
literal|1
expr_stmt|;
comment|/* entry is valid now */
block|}
continue|continue;
comment|/* do not clear the stack */
case|case
name|cf2_cmdRETURN
case|:
name|FT_TRACE4
argument_list|(
operator|(
literal|" return\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|charstringIndex
operator|<
literal|1
condition|)
block|{
comment|/* Note: cannot return from top charstring */
name|lastError
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Glyph_Format
argument_list|)
expr_stmt|;
goto|goto
name|exit
goto|;
comment|/* underflow of stack */
block|}
comment|/* restore position in previous charstring */
name|charstring
operator|=
operator|(
name|CF2_Buffer
operator|)
name|cf2_arrstack_getPointer
argument_list|(
operator|&
name|subrStack
argument_list|,
operator|--
name|charstringIndex
argument_list|)
expr_stmt|;
continue|continue;
comment|/* do not clear the stack */
case|case
name|cf2_cmdESC
case|:
block|{
name|FT_Byte
name|op2
init|=
operator|(
name|FT_Byte
operator|)
name|cf2_buf_readByte
argument_list|(
name|charstring
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|op2
condition|)
block|{
case|case
name|cf2_escDOTSECTION
case|:
comment|/* something about `flip type of locking' -- ignore it */
name|FT_TRACE4
argument_list|(
operator|(
literal|" dotsection\n"
operator|)
argument_list|)
expr_stmt|;
break|break;
comment|/* TODO: should these operators be supported? */
case|case
name|cf2_escAND
case|:
comment|/* in spec */
name|FT_TRACE4
argument_list|(
operator|(
literal|" and\n"
operator|)
argument_list|)
expr_stmt|;
name|CF2_FIXME
expr_stmt|;
break|break;
case|case
name|cf2_escOR
case|:
comment|/* in spec */
name|FT_TRACE4
argument_list|(
operator|(
literal|" or\n"
operator|)
argument_list|)
expr_stmt|;
name|CF2_FIXME
expr_stmt|;
break|break;
case|case
name|cf2_escNOT
case|:
comment|/* in spec */
name|FT_TRACE4
argument_list|(
operator|(
literal|" not\n"
operator|)
argument_list|)
expr_stmt|;
name|CF2_FIXME
expr_stmt|;
break|break;
case|case
name|cf2_escABS
case|:
comment|/* in spec */
name|FT_TRACE4
argument_list|(
operator|(
literal|" abs\n"
operator|)
argument_list|)
expr_stmt|;
name|CF2_FIXME
expr_stmt|;
break|break;
case|case
name|cf2_escADD
case|:
comment|/* in spec */
name|FT_TRACE4
argument_list|(
operator|(
literal|" add\n"
operator|)
argument_list|)
expr_stmt|;
name|CF2_FIXME
expr_stmt|;
break|break;
case|case
name|cf2_escSUB
case|:
comment|/* in spec */
name|FT_TRACE4
argument_list|(
operator|(
literal|" sub\n"
operator|)
argument_list|)
expr_stmt|;
name|CF2_FIXME
expr_stmt|;
break|break;
case|case
name|cf2_escDIV
case|:
comment|/* in spec */
name|FT_TRACE4
argument_list|(
operator|(
literal|" div\n"
operator|)
argument_list|)
expr_stmt|;
name|CF2_FIXME
expr_stmt|;
break|break;
case|case
name|cf2_escNEG
case|:
comment|/* in spec */
name|FT_TRACE4
argument_list|(
operator|(
literal|" neg\n"
operator|)
argument_list|)
expr_stmt|;
name|CF2_FIXME
expr_stmt|;
break|break;
case|case
name|cf2_escEQ
case|:
comment|/* in spec */
name|FT_TRACE4
argument_list|(
operator|(
literal|" eq\n"
operator|)
argument_list|)
expr_stmt|;
name|CF2_FIXME
expr_stmt|;
break|break;
case|case
name|cf2_escDROP
case|:
comment|/* in spec */
name|FT_TRACE4
argument_list|(
operator|(
literal|" drop\n"
operator|)
argument_list|)
expr_stmt|;
name|CF2_FIXME
expr_stmt|;
break|break;
case|case
name|cf2_escPUT
case|:
comment|/* in spec */
name|FT_TRACE4
argument_list|(
operator|(
literal|" put\n"
operator|)
argument_list|)
expr_stmt|;
name|CF2_FIXME
expr_stmt|;
break|break;
case|case
name|cf2_escGET
case|:
comment|/* in spec */
name|FT_TRACE4
argument_list|(
operator|(
literal|" get\n"
operator|)
argument_list|)
expr_stmt|;
name|CF2_FIXME
expr_stmt|;
break|break;
case|case
name|cf2_escIFELSE
case|:
comment|/* in spec */
name|FT_TRACE4
argument_list|(
operator|(
literal|" ifelse\n"
operator|)
argument_list|)
expr_stmt|;
name|CF2_FIXME
expr_stmt|;
break|break;
case|case
name|cf2_escRANDOM
case|:
comment|/* in spec */
name|FT_TRACE4
argument_list|(
operator|(
literal|" random\n"
operator|)
argument_list|)
expr_stmt|;
name|CF2_FIXME
expr_stmt|;
break|break;
case|case
name|cf2_escMUL
case|:
comment|/* in spec */
name|FT_TRACE4
argument_list|(
operator|(
literal|" mul\n"
operator|)
argument_list|)
expr_stmt|;
name|CF2_FIXME
expr_stmt|;
break|break;
case|case
name|cf2_escSQRT
case|:
comment|/* in spec */
name|FT_TRACE4
argument_list|(
operator|(
literal|" sqrt\n"
operator|)
argument_list|)
expr_stmt|;
name|CF2_FIXME
expr_stmt|;
break|break;
case|case
name|cf2_escDUP
case|:
comment|/* in spec */
name|FT_TRACE4
argument_list|(
operator|(
literal|" dup\n"
operator|)
argument_list|)
expr_stmt|;
name|CF2_FIXME
expr_stmt|;
break|break;
case|case
name|cf2_escEXCH
case|:
comment|/* in spec */
name|FT_TRACE4
argument_list|(
operator|(
literal|" exch\n"
operator|)
argument_list|)
expr_stmt|;
name|CF2_FIXME
expr_stmt|;
break|break;
case|case
name|cf2_escINDEX
case|:
comment|/* in spec */
name|FT_TRACE4
argument_list|(
operator|(
literal|" index\n"
operator|)
argument_list|)
expr_stmt|;
name|CF2_FIXME
expr_stmt|;
break|break;
case|case
name|cf2_escROLL
case|:
comment|/* in spec */
name|FT_TRACE4
argument_list|(
operator|(
literal|" roll\n"
operator|)
argument_list|)
expr_stmt|;
name|CF2_FIXME
expr_stmt|;
break|break;
case|case
name|cf2_escHFLEX
case|:
block|{
specifier|static
specifier|const
name|FT_Bool
name|readFromStack
index|[
literal|12
index|]
init|=
block|{
name|TRUE
comment|/* dx1 */
block|,
name|FALSE
comment|/* dy1 */
block|,
name|TRUE
comment|/* dx2 */
block|,
name|TRUE
comment|/* dy2 */
block|,
name|TRUE
comment|/* dx3 */
block|,
name|FALSE
comment|/* dy3 */
block|,
name|TRUE
comment|/* dx4 */
block|,
name|FALSE
comment|/* dy4 */
block|,
name|TRUE
comment|/* dx5 */
block|,
name|FALSE
comment|/* dy5 */
block|,
name|TRUE
comment|/* dx6 */
block|,
name|FALSE
comment|/* dy6 */
block|}
decl_stmt|;
name|FT_TRACE4
argument_list|(
operator|(
literal|" hflex\n"
operator|)
argument_list|)
expr_stmt|;
name|cf2_doFlex
argument_list|(
name|opStack
argument_list|,
operator|&
name|curX
argument_list|,
operator|&
name|curY
argument_list|,
operator|&
name|glyphPath
argument_list|,
name|readFromStack
argument_list|,
name|FALSE
comment|/* doConditionalLastRead */
argument_list|)
expr_stmt|;
block|}
continue|continue;
case|case
name|cf2_escFLEX
case|:
block|{
specifier|static
specifier|const
name|FT_Bool
name|readFromStack
index|[
literal|12
index|]
init|=
block|{
name|TRUE
comment|/* dx1 */
block|,
name|TRUE
comment|/* dy1 */
block|,
name|TRUE
comment|/* dx2 */
block|,
name|TRUE
comment|/* dy2 */
block|,
name|TRUE
comment|/* dx3 */
block|,
name|TRUE
comment|/* dy3 */
block|,
name|TRUE
comment|/* dx4 */
block|,
name|TRUE
comment|/* dy4 */
block|,
name|TRUE
comment|/* dx5 */
block|,
name|TRUE
comment|/* dy5 */
block|,
name|TRUE
comment|/* dx6 */
block|,
name|TRUE
comment|/* dy6 */
block|}
decl_stmt|;
name|FT_TRACE4
argument_list|(
operator|(
literal|" flex\n"
operator|)
argument_list|)
expr_stmt|;
name|cf2_doFlex
argument_list|(
name|opStack
argument_list|,
operator|&
name|curX
argument_list|,
operator|&
name|curY
argument_list|,
operator|&
name|glyphPath
argument_list|,
name|readFromStack
argument_list|,
name|FALSE
comment|/* doConditionalLastRead */
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* TODO: why is this not a continue? */
case|case
name|cf2_escHFLEX1
case|:
block|{
specifier|static
specifier|const
name|FT_Bool
name|readFromStack
index|[
literal|12
index|]
init|=
block|{
name|TRUE
comment|/* dx1 */
block|,
name|TRUE
comment|/* dy1 */
block|,
name|TRUE
comment|/* dx2 */
block|,
name|TRUE
comment|/* dy2 */
block|,
name|TRUE
comment|/* dx3 */
block|,
name|FALSE
comment|/* dy3 */
block|,
name|TRUE
comment|/* dx4 */
block|,
name|FALSE
comment|/* dy4 */
block|,
name|TRUE
comment|/* dx5 */
block|,
name|TRUE
comment|/* dy5 */
block|,
name|TRUE
comment|/* dx6 */
block|,
name|FALSE
comment|/* dy6 */
block|}
decl_stmt|;
name|FT_TRACE4
argument_list|(
operator|(
literal|" hflex1\n"
operator|)
argument_list|)
expr_stmt|;
name|cf2_doFlex
argument_list|(
name|opStack
argument_list|,
operator|&
name|curX
argument_list|,
operator|&
name|curY
argument_list|,
operator|&
name|glyphPath
argument_list|,
name|readFromStack
argument_list|,
name|FALSE
comment|/* doConditionalLastRead */
argument_list|)
expr_stmt|;
block|}
continue|continue;
case|case
name|cf2_escFLEX1
case|:
block|{
specifier|static
specifier|const
name|FT_Bool
name|readFromStack
index|[
literal|12
index|]
init|=
block|{
name|TRUE
comment|/* dx1 */
block|,
name|TRUE
comment|/* dy1 */
block|,
name|TRUE
comment|/* dx2 */
block|,
name|TRUE
comment|/* dy2 */
block|,
name|TRUE
comment|/* dx3 */
block|,
name|TRUE
comment|/* dy3 */
block|,
name|TRUE
comment|/* dx4 */
block|,
name|TRUE
comment|/* dy4 */
block|,
name|TRUE
comment|/* dx5 */
block|,
name|TRUE
comment|/* dy5 */
block|,
name|FALSE
comment|/* dx6 */
block|,
name|FALSE
comment|/* dy6 */
block|}
decl_stmt|;
name|FT_TRACE4
argument_list|(
operator|(
literal|" flex1\n"
operator|)
argument_list|)
expr_stmt|;
name|cf2_doFlex
argument_list|(
name|opStack
argument_list|,
operator|&
name|curX
argument_list|,
operator|&
name|curY
argument_list|,
operator|&
name|glyphPath
argument_list|,
name|readFromStack
argument_list|,
name|TRUE
comment|/* doConditionalLastRead */
argument_list|)
expr_stmt|;
block|}
continue|continue;
case|case
name|cf2_escRESERVED_1
case|:
case|case
name|cf2_escRESERVED_2
case|:
case|case
name|cf2_escRESERVED_6
case|:
case|case
name|cf2_escRESERVED_7
case|:
case|case
name|cf2_escRESERVED_8
case|:
case|case
name|cf2_escRESERVED_13
case|:
case|case
name|cf2_escRESERVED_16
case|:
case|case
name|cf2_escRESERVED_17
case|:
case|case
name|cf2_escRESERVED_19
case|:
case|case
name|cf2_escRESERVED_25
case|:
case|case
name|cf2_escRESERVED_31
case|:
case|case
name|cf2_escRESERVED_32
case|:
case|case
name|cf2_escRESERVED_33
case|:
default|default:
name|FT_TRACE4
argument_list|(
operator|(
literal|" unknown op (12, %d)\n"
operator|,
name|op2
operator|)
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
comment|/* end of switch statement checking `op2' */
block|}
comment|/* case cf2_cmdESC */
break|break;
case|case
name|cf2_cmdENDCHAR
case|:
name|FT_TRACE4
argument_list|(
operator|(
literal|" endchar\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cf2_stack_count
argument_list|(
name|opStack
argument_list|)
operator|==
literal|1
operator|||
name|cf2_stack_count
argument_list|(
name|opStack
argument_list|)
operator|==
literal|5
condition|)
block|{
if|if
condition|(
operator|!
name|haveWidth
condition|)
operator|*
name|width
operator|=
name|cf2_stack_getReal
argument_list|(
name|opStack
argument_list|,
literal|0
argument_list|)
operator|+
name|nominalWidthX
expr_stmt|;
block|}
comment|/* width is defined or default after this */
name|haveWidth
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|font
operator|->
name|decoder
operator|->
name|width_only
condition|)
goto|goto
name|exit
goto|;
comment|/* close path if still open */
name|cf2_glyphpath_closeOpenPath
argument_list|(
operator|&
name|glyphPath
argument_list|)
expr_stmt|;
if|if
condition|(
name|cf2_stack_count
argument_list|(
name|opStack
argument_list|)
operator|>
literal|1
condition|)
block|{
comment|/* must be either 4 or 5 --                       */
comment|/* this is a (deprecated) implied `seac' operator */
name|CF2_UInt
name|achar
decl_stmt|;
name|CF2_UInt
name|bchar
decl_stmt|;
name|CF2_BufferRec
name|component
decl_stmt|;
name|CF2_Fixed
name|dummyWidth
decl_stmt|;
comment|/* ignore component width */
name|FT_Error
name|error2
decl_stmt|;
if|if
condition|(
name|doingSeac
condition|)
block|{
name|lastError
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Glyph_Format
argument_list|)
expr_stmt|;
goto|goto
name|exit
goto|;
comment|/* nested seac */
block|}
name|achar
operator|=
name|cf2_stack_popInt
argument_list|(
name|opStack
argument_list|)
expr_stmt|;
name|bchar
operator|=
name|cf2_stack_popInt
argument_list|(
name|opStack
argument_list|)
expr_stmt|;
name|curY
operator|=
name|cf2_stack_popFixed
argument_list|(
name|opStack
argument_list|)
expr_stmt|;
name|curX
operator|=
name|cf2_stack_popFixed
argument_list|(
name|opStack
argument_list|)
expr_stmt|;
name|error2
operator|=
name|cf2_getSeacComponent
argument_list|(
name|decoder
argument_list|,
name|achar
argument_list|,
operator|&
name|component
argument_list|)
expr_stmt|;
if|if
condition|(
name|error2
condition|)
block|{
name|lastError
operator|=
name|error2
expr_stmt|;
comment|/* pass FreeType error through */
goto|goto
name|exit
goto|;
block|}
name|cf2_interpT2CharString
argument_list|(
name|font
argument_list|,
operator|&
name|component
argument_list|,
name|callbacks
argument_list|,
name|translation
argument_list|,
name|TRUE
argument_list|,
name|curX
argument_list|,
name|curY
argument_list|,
operator|&
name|dummyWidth
argument_list|)
expr_stmt|;
name|cf2_freeSeacComponent
argument_list|(
name|decoder
argument_list|,
operator|&
name|component
argument_list|)
expr_stmt|;
name|error2
operator|=
name|cf2_getSeacComponent
argument_list|(
name|decoder
argument_list|,
name|bchar
argument_list|,
operator|&
name|component
argument_list|)
expr_stmt|;
if|if
condition|(
name|error2
condition|)
block|{
name|lastError
operator|=
name|error2
expr_stmt|;
comment|/* pass FreeType error through */
goto|goto
name|exit
goto|;
block|}
name|cf2_interpT2CharString
argument_list|(
name|font
argument_list|,
operator|&
name|component
argument_list|,
name|callbacks
argument_list|,
name|translation
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|dummyWidth
argument_list|)
expr_stmt|;
name|cf2_freeSeacComponent
argument_list|(
name|decoder
argument_list|,
operator|&
name|component
argument_list|)
expr_stmt|;
block|}
goto|goto
name|exit
goto|;
case|case
name|cf2_cmdCNTRMASK
case|:
case|case
name|cf2_cmdHINTMASK
case|:
comment|/* the final \n in the tracing message gets added in      */
comment|/* `cf2_hintmask_read' (which also traces the mask bytes) */
name|FT_TRACE4
argument_list|(
operator|(
name|op1
operator|==
name|cf2_cmdCNTRMASK
condition|?
literal|" cntrmask"
else|:
literal|" hintmask"
operator|)
argument_list|)
expr_stmt|;
comment|/* never add hints after the mask is computed */
if|if
condition|(
name|cf2_stack_count
argument_list|(
name|opStack
argument_list|)
operator|>
literal|1
operator|&&
name|cf2_hintmask_isValid
argument_list|(
operator|&
name|hintMask
argument_list|)
condition|)
block|{
name|FT_TRACE4
argument_list|(
operator|(
literal|"cf2_interpT2CharString: invalid hint mask\n"
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* if there are arguments on the stack, there this is an */
comment|/* implied cf2_cmdVSTEMHM                                */
name|cf2_doStems
argument_list|(
name|font
argument_list|,
name|opStack
argument_list|,
operator|&
name|vStemHintArray
argument_list|,
name|width
argument_list|,
operator|&
name|haveWidth
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|font
operator|->
name|decoder
operator|->
name|width_only
condition|)
goto|goto
name|exit
goto|;
if|if
condition|(
name|op1
operator|==
name|cf2_cmdHINTMASK
condition|)
block|{
comment|/* consume the hint mask bytes which follow the operator */
name|cf2_hintmask_read
argument_list|(
operator|&
name|hintMask
argument_list|,
name|charstring
argument_list|,
name|cf2_arrstack_size
argument_list|(
operator|&
name|hStemHintArray
argument_list|)
operator|+
name|cf2_arrstack_size
argument_list|(
operator|&
name|vStemHintArray
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*            * Consume the counter mask bytes which follow the operator:            * Build a temporary hint map, just to place and lock those            * stems participating in the counter mask.  These are most            * likely the dominant hstems, and are grouped together in a            * few counter groups, not necessarily in correspondence            * with the hint groups.  This reduces the chances of            * conflicts between hstems that are initially placed in            * separate hint groups and then brought together.  The            * positions are copied back to `hStemHintArray', so we can            * discard `counterMask' and `counterHintMap'.            *            */
name|CF2_HintMapRec
name|counterHintMap
decl_stmt|;
name|CF2_HintMaskRec
name|counterMask
decl_stmt|;
name|cf2_hintmap_init
argument_list|(
operator|&
name|counterHintMap
argument_list|,
name|font
argument_list|,
operator|&
name|glyphPath
operator|.
name|initialHintMap
argument_list|,
operator|&
name|glyphPath
operator|.
name|hintMoves
argument_list|,
name|scaleY
argument_list|)
expr_stmt|;
name|cf2_hintmask_init
argument_list|(
operator|&
name|counterMask
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|cf2_hintmask_read
argument_list|(
operator|&
name|counterMask
argument_list|,
name|charstring
argument_list|,
name|cf2_arrstack_size
argument_list|(
operator|&
name|hStemHintArray
argument_list|)
operator|+
name|cf2_arrstack_size
argument_list|(
operator|&
name|vStemHintArray
argument_list|)
argument_list|)
expr_stmt|;
name|cf2_hintmap_build
argument_list|(
operator|&
name|counterHintMap
argument_list|,
operator|&
name|hStemHintArray
argument_list|,
operator|&
name|vStemHintArray
argument_list|,
operator|&
name|counterMask
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|cf2_cmdRMOVETO
case|:
name|FT_TRACE4
argument_list|(
operator|(
literal|" rmoveto\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cf2_stack_count
argument_list|(
name|opStack
argument_list|)
operator|>
literal|2
operator|&&
operator|!
name|haveWidth
condition|)
operator|*
name|width
operator|=
name|cf2_stack_getReal
argument_list|(
name|opStack
argument_list|,
literal|0
argument_list|)
operator|+
name|nominalWidthX
expr_stmt|;
comment|/* width is defined or default after this */
name|haveWidth
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|font
operator|->
name|decoder
operator|->
name|width_only
condition|)
goto|goto
name|exit
goto|;
name|curY
operator|+=
name|cf2_stack_popFixed
argument_list|(
name|opStack
argument_list|)
expr_stmt|;
name|curX
operator|+=
name|cf2_stack_popFixed
argument_list|(
name|opStack
argument_list|)
expr_stmt|;
name|cf2_glyphpath_moveTo
argument_list|(
operator|&
name|glyphPath
argument_list|,
name|curX
argument_list|,
name|curY
argument_list|)
expr_stmt|;
break|break;
case|case
name|cf2_cmdHMOVETO
case|:
name|FT_TRACE4
argument_list|(
operator|(
literal|" hmoveto\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cf2_stack_count
argument_list|(
name|opStack
argument_list|)
operator|>
literal|1
operator|&&
operator|!
name|haveWidth
condition|)
operator|*
name|width
operator|=
name|cf2_stack_getReal
argument_list|(
name|opStack
argument_list|,
literal|0
argument_list|)
operator|+
name|nominalWidthX
expr_stmt|;
comment|/* width is defined or default after this */
name|haveWidth
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|font
operator|->
name|decoder
operator|->
name|width_only
condition|)
goto|goto
name|exit
goto|;
name|curX
operator|+=
name|cf2_stack_popFixed
argument_list|(
name|opStack
argument_list|)
expr_stmt|;
name|cf2_glyphpath_moveTo
argument_list|(
operator|&
name|glyphPath
argument_list|,
name|curX
argument_list|,
name|curY
argument_list|)
expr_stmt|;
break|break;
case|case
name|cf2_cmdRLINECURVE
case|:
block|{
name|CF2_UInt
name|count
init|=
name|cf2_stack_count
argument_list|(
name|opStack
argument_list|)
decl_stmt|;
name|CF2_UInt
name|index
init|=
literal|0
decl_stmt|;
name|FT_TRACE4
argument_list|(
operator|(
literal|" rlinecurve\n"
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|index
operator|+
literal|6
operator|<
name|count
condition|)
block|{
name|curX
operator|+=
name|cf2_stack_getReal
argument_list|(
name|opStack
argument_list|,
name|index
operator|+
literal|0
argument_list|)
expr_stmt|;
name|curY
operator|+=
name|cf2_stack_getReal
argument_list|(
name|opStack
argument_list|,
name|index
operator|+
literal|1
argument_list|)
expr_stmt|;
name|cf2_glyphpath_lineTo
argument_list|(
operator|&
name|glyphPath
argument_list|,
name|curX
argument_list|,
name|curY
argument_list|)
expr_stmt|;
name|index
operator|+=
literal|2
expr_stmt|;
block|}
while|while
condition|(
name|index
operator|<
name|count
condition|)
block|{
name|CF2_Fixed
name|x1
init|=
name|cf2_stack_getReal
argument_list|(
name|opStack
argument_list|,
name|index
operator|+
literal|0
argument_list|)
operator|+
name|curX
decl_stmt|;
name|CF2_Fixed
name|y1
init|=
name|cf2_stack_getReal
argument_list|(
name|opStack
argument_list|,
name|index
operator|+
literal|1
argument_list|)
operator|+
name|curY
decl_stmt|;
name|CF2_Fixed
name|x2
init|=
name|cf2_stack_getReal
argument_list|(
name|opStack
argument_list|,
name|index
operator|+
literal|2
argument_list|)
operator|+
name|x1
decl_stmt|;
name|CF2_Fixed
name|y2
init|=
name|cf2_stack_getReal
argument_list|(
name|opStack
argument_list|,
name|index
operator|+
literal|3
argument_list|)
operator|+
name|y1
decl_stmt|;
name|CF2_Fixed
name|x3
init|=
name|cf2_stack_getReal
argument_list|(
name|opStack
argument_list|,
name|index
operator|+
literal|4
argument_list|)
operator|+
name|x2
decl_stmt|;
name|CF2_Fixed
name|y3
init|=
name|cf2_stack_getReal
argument_list|(
name|opStack
argument_list|,
name|index
operator|+
literal|5
argument_list|)
operator|+
name|y2
decl_stmt|;
name|cf2_glyphpath_curveTo
argument_list|(
operator|&
name|glyphPath
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|,
name|x3
argument_list|,
name|y3
argument_list|)
expr_stmt|;
name|curX
operator|=
name|x3
expr_stmt|;
name|curY
operator|=
name|y3
expr_stmt|;
name|index
operator|+=
literal|6
expr_stmt|;
block|}
name|cf2_stack_clear
argument_list|(
name|opStack
argument_list|)
expr_stmt|;
block|}
continue|continue;
comment|/* no need to clear stack again */
case|case
name|cf2_cmdVVCURVETO
case|:
block|{
name|CF2_UInt
name|count
init|=
name|cf2_stack_count
argument_list|(
name|opStack
argument_list|)
decl_stmt|;
name|CF2_UInt
name|index
init|=
literal|0
decl_stmt|;
name|FT_TRACE4
argument_list|(
operator|(
literal|" vvcurveto\n"
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|index
operator|<
name|count
condition|)
block|{
name|CF2_Fixed
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|,
name|x3
decl_stmt|,
name|y3
decl_stmt|;
if|if
condition|(
operator|(
name|count
operator|-
name|index
operator|)
operator|&
literal|1
condition|)
block|{
name|x1
operator|=
name|cf2_stack_getReal
argument_list|(
name|opStack
argument_list|,
name|index
argument_list|)
operator|+
name|curX
expr_stmt|;
operator|++
name|index
expr_stmt|;
block|}
else|else
name|x1
operator|=
name|curX
expr_stmt|;
name|y1
operator|=
name|cf2_stack_getReal
argument_list|(
name|opStack
argument_list|,
name|index
operator|+
literal|0
argument_list|)
operator|+
name|curY
expr_stmt|;
name|x2
operator|=
name|cf2_stack_getReal
argument_list|(
name|opStack
argument_list|,
name|index
operator|+
literal|1
argument_list|)
operator|+
name|x1
expr_stmt|;
name|y2
operator|=
name|cf2_stack_getReal
argument_list|(
name|opStack
argument_list|,
name|index
operator|+
literal|2
argument_list|)
operator|+
name|y1
expr_stmt|;
name|x3
operator|=
name|x2
expr_stmt|;
name|y3
operator|=
name|cf2_stack_getReal
argument_list|(
name|opStack
argument_list|,
name|index
operator|+
literal|3
argument_list|)
operator|+
name|y2
expr_stmt|;
name|cf2_glyphpath_curveTo
argument_list|(
operator|&
name|glyphPath
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|,
name|x3
argument_list|,
name|y3
argument_list|)
expr_stmt|;
name|curX
operator|=
name|x3
expr_stmt|;
name|curY
operator|=
name|y3
expr_stmt|;
name|index
operator|+=
literal|4
expr_stmt|;
block|}
name|cf2_stack_clear
argument_list|(
name|opStack
argument_list|)
expr_stmt|;
block|}
continue|continue;
comment|/* no need to clear stack again */
case|case
name|cf2_cmdHHCURVETO
case|:
block|{
name|CF2_UInt
name|count
init|=
name|cf2_stack_count
argument_list|(
name|opStack
argument_list|)
decl_stmt|;
name|CF2_UInt
name|index
init|=
literal|0
decl_stmt|;
name|FT_TRACE4
argument_list|(
operator|(
literal|" hhcurveto\n"
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|index
operator|<
name|count
condition|)
block|{
name|CF2_Fixed
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|,
name|x3
decl_stmt|,
name|y3
decl_stmt|;
if|if
condition|(
operator|(
name|count
operator|-
name|index
operator|)
operator|&
literal|1
condition|)
block|{
name|y1
operator|=
name|cf2_stack_getReal
argument_list|(
name|opStack
argument_list|,
name|index
argument_list|)
operator|+
name|curY
expr_stmt|;
operator|++
name|index
expr_stmt|;
block|}
else|else
name|y1
operator|=
name|curY
expr_stmt|;
name|x1
operator|=
name|cf2_stack_getReal
argument_list|(
name|opStack
argument_list|,
name|index
operator|+
literal|0
argument_list|)
operator|+
name|curX
expr_stmt|;
name|x2
operator|=
name|cf2_stack_getReal
argument_list|(
name|opStack
argument_list|,
name|index
operator|+
literal|1
argument_list|)
operator|+
name|x1
expr_stmt|;
name|y2
operator|=
name|cf2_stack_getReal
argument_list|(
name|opStack
argument_list|,
name|index
operator|+
literal|2
argument_list|)
operator|+
name|y1
expr_stmt|;
name|x3
operator|=
name|cf2_stack_getReal
argument_list|(
name|opStack
argument_list|,
name|index
operator|+
literal|3
argument_list|)
operator|+
name|x2
expr_stmt|;
name|y3
operator|=
name|y2
expr_stmt|;
name|cf2_glyphpath_curveTo
argument_list|(
operator|&
name|glyphPath
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|,
name|x3
argument_list|,
name|y3
argument_list|)
expr_stmt|;
name|curX
operator|=
name|x3
expr_stmt|;
name|curY
operator|=
name|y3
expr_stmt|;
name|index
operator|+=
literal|4
expr_stmt|;
block|}
name|cf2_stack_clear
argument_list|(
name|opStack
argument_list|)
expr_stmt|;
block|}
continue|continue;
comment|/* no need to clear stack again */
case|case
name|cf2_cmdVHCURVETO
case|:
case|case
name|cf2_cmdHVCURVETO
case|:
block|{
name|CF2_UInt
name|count
init|=
name|cf2_stack_count
argument_list|(
name|opStack
argument_list|)
decl_stmt|;
name|CF2_UInt
name|index
init|=
literal|0
decl_stmt|;
name|FT_Bool
name|alternate
init|=
name|op1
operator|==
name|cf2_cmdHVCURVETO
decl_stmt|;
name|FT_TRACE4
argument_list|(
operator|(
name|alternate
condition|?
literal|" hvcurveto\n"
else|:
literal|" vhcurveto\n"
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|index
operator|<
name|count
condition|)
block|{
name|CF2_Fixed
name|x1
decl_stmt|,
name|x2
decl_stmt|,
name|x3
decl_stmt|,
name|y1
decl_stmt|,
name|y2
decl_stmt|,
name|y3
decl_stmt|;
if|if
condition|(
name|alternate
condition|)
block|{
name|x1
operator|=
name|cf2_stack_getReal
argument_list|(
name|opStack
argument_list|,
name|index
operator|+
literal|0
argument_list|)
operator|+
name|curX
expr_stmt|;
name|y1
operator|=
name|curY
expr_stmt|;
name|x2
operator|=
name|cf2_stack_getReal
argument_list|(
name|opStack
argument_list|,
name|index
operator|+
literal|1
argument_list|)
operator|+
name|x1
expr_stmt|;
name|y2
operator|=
name|cf2_stack_getReal
argument_list|(
name|opStack
argument_list|,
name|index
operator|+
literal|2
argument_list|)
operator|+
name|y1
expr_stmt|;
name|y3
operator|=
name|cf2_stack_getReal
argument_list|(
name|opStack
argument_list|,
name|index
operator|+
literal|3
argument_list|)
operator|+
name|y2
expr_stmt|;
if|if
condition|(
name|count
operator|-
name|index
operator|==
literal|5
condition|)
block|{
name|x3
operator|=
name|cf2_stack_getReal
argument_list|(
name|opStack
argument_list|,
name|index
operator|+
literal|4
argument_list|)
operator|+
name|x2
expr_stmt|;
operator|++
name|index
expr_stmt|;
block|}
else|else
name|x3
operator|=
name|x2
expr_stmt|;
name|alternate
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|x1
operator|=
name|curX
expr_stmt|;
name|y1
operator|=
name|cf2_stack_getReal
argument_list|(
name|opStack
argument_list|,
name|index
operator|+
literal|0
argument_list|)
operator|+
name|curY
expr_stmt|;
name|x2
operator|=
name|cf2_stack_getReal
argument_list|(
name|opStack
argument_list|,
name|index
operator|+
literal|1
argument_list|)
operator|+
name|x1
expr_stmt|;
name|y2
operator|=
name|cf2_stack_getReal
argument_list|(
name|opStack
argument_list|,
name|index
operator|+
literal|2
argument_list|)
operator|+
name|y1
expr_stmt|;
name|x3
operator|=
name|cf2_stack_getReal
argument_list|(
name|opStack
argument_list|,
name|index
operator|+
literal|3
argument_list|)
operator|+
name|x2
expr_stmt|;
if|if
condition|(
name|count
operator|-
name|index
operator|==
literal|5
condition|)
block|{
name|y3
operator|=
name|cf2_stack_getReal
argument_list|(
name|opStack
argument_list|,
name|index
operator|+
literal|4
argument_list|)
operator|+
name|y2
expr_stmt|;
operator|++
name|index
expr_stmt|;
block|}
else|else
name|y3
operator|=
name|y2
expr_stmt|;
name|alternate
operator|=
name|TRUE
expr_stmt|;
block|}
name|cf2_glyphpath_curveTo
argument_list|(
operator|&
name|glyphPath
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|,
name|x3
argument_list|,
name|y3
argument_list|)
expr_stmt|;
name|curX
operator|=
name|x3
expr_stmt|;
name|curY
operator|=
name|y3
expr_stmt|;
name|index
operator|+=
literal|4
expr_stmt|;
block|}
name|cf2_stack_clear
argument_list|(
name|opStack
argument_list|)
expr_stmt|;
block|}
continue|continue;
comment|/* no need to clear stack again */
case|case
name|cf2_cmdEXTENDEDNMBR
case|:
block|{
name|CF2_Int
name|v
decl_stmt|;
name|v
operator|=
call|(
name|FT_Short
call|)
argument_list|(
operator|(
name|cf2_buf_readByte
argument_list|(
name|charstring
argument_list|)
operator|<<
literal|8
operator|)
operator||
name|cf2_buf_readByte
argument_list|(
name|charstring
argument_list|)
argument_list|)
expr_stmt|;
name|FT_TRACE4
argument_list|(
operator|(
literal|" %d"
operator|,
name|v
operator|)
argument_list|)
expr_stmt|;
name|cf2_stack_pushInt
argument_list|(
name|opStack
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
continue|continue;
default|default:
comment|/* numbers */
block|{
if|if
condition|(
comment|/* op1>= 32&& */
name|op1
operator|<=
literal|246
condition|)
block|{
name|CF2_Int
name|v
decl_stmt|;
name|v
operator|=
name|op1
operator|-
literal|139
expr_stmt|;
name|FT_TRACE4
argument_list|(
operator|(
literal|" %d"
operator|,
name|v
operator|)
argument_list|)
expr_stmt|;
comment|/* -107 .. 107 */
name|cf2_stack_pushInt
argument_list|(
name|opStack
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
comment|/* op1>= 247&& */
name|op1
operator|<=
literal|250
condition|)
block|{
name|CF2_Int
name|v
decl_stmt|;
name|v
operator|=
name|op1
expr_stmt|;
name|v
operator|-=
literal|247
expr_stmt|;
name|v
operator|*=
literal|256
expr_stmt|;
name|v
operator|+=
name|cf2_buf_readByte
argument_list|(
name|charstring
argument_list|)
expr_stmt|;
name|v
operator|+=
literal|108
expr_stmt|;
name|FT_TRACE4
argument_list|(
operator|(
literal|" %d"
operator|,
name|v
operator|)
argument_list|)
expr_stmt|;
comment|/* 108 .. 1131 */
name|cf2_stack_pushInt
argument_list|(
name|opStack
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
comment|/* op1>= 251&& */
name|op1
operator|<=
literal|254
condition|)
block|{
name|CF2_Int
name|v
decl_stmt|;
name|v
operator|=
name|op1
expr_stmt|;
name|v
operator|-=
literal|251
expr_stmt|;
name|v
operator|*=
literal|256
expr_stmt|;
name|v
operator|+=
name|cf2_buf_readByte
argument_list|(
name|charstring
argument_list|)
expr_stmt|;
name|v
operator|=
operator|-
name|v
operator|-
literal|108
expr_stmt|;
name|FT_TRACE4
argument_list|(
operator|(
literal|" %d"
operator|,
name|v
operator|)
argument_list|)
expr_stmt|;
comment|/* -1131 .. -108 */
name|cf2_stack_pushInt
argument_list|(
name|opStack
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* op1 == 255 */
block|{
name|CF2_Fixed
name|v
decl_stmt|;
name|v
operator|=
call|(
name|CF2_Fixed
call|)
argument_list|(
operator|(
operator|(
name|FT_UInt32
operator|)
name|cf2_buf_readByte
argument_list|(
name|charstring
argument_list|)
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
name|FT_UInt32
operator|)
name|cf2_buf_readByte
argument_list|(
name|charstring
argument_list|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|FT_UInt32
operator|)
name|cf2_buf_readByte
argument_list|(
name|charstring
argument_list|)
operator|<<
literal|8
operator|)
operator||
operator|(
name|FT_UInt32
operator|)
name|cf2_buf_readByte
argument_list|(
name|charstring
argument_list|)
argument_list|)
expr_stmt|;
name|FT_TRACE4
argument_list|(
operator|(
literal|" %.2f"
operator|,
name|v
operator|/
literal|65536.0
operator|)
argument_list|)
expr_stmt|;
name|cf2_stack_pushFixed
argument_list|(
name|opStack
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
block|}
continue|continue;
comment|/* don't clear stack */
block|}
comment|/* end of switch statement checking `op1' */
name|cf2_stack_clear
argument_list|(
name|opStack
argument_list|)
expr_stmt|;
block|}
comment|/* end of main interpreter loop */
comment|/* we get here if the charstring ends without cf2_cmdENDCHAR */
name|FT_TRACE4
argument_list|(
operator|(
literal|"cf2_interpT2CharString:"
literal|"  charstring ends without ENDCHAR\n"
operator|)
argument_list|)
expr_stmt|;
name|exit
label|:
comment|/* check whether last error seen is also the first one */
name|cf2_setError
argument_list|(
name|error
argument_list|,
name|lastError
argument_list|)
expr_stmt|;
comment|/* free resources from objects we've used */
name|cf2_glyphpath_finalize
argument_list|(
operator|&
name|glyphPath
argument_list|)
expr_stmt|;
name|cf2_arrstack_finalize
argument_list|(
operator|&
name|vStemHintArray
argument_list|)
expr_stmt|;
name|cf2_arrstack_finalize
argument_list|(
operator|&
name|hStemHintArray
argument_list|)
expr_stmt|;
name|cf2_arrstack_finalize
argument_list|(
operator|&
name|subrStack
argument_list|)
expr_stmt|;
name|cf2_stack_free
argument_list|(
name|opStack
argument_list|)
expr_stmt|;
name|FT_TRACE4
argument_list|(
operator|(
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_block
begin_comment
comment|/* END */
end_comment
end_unit
