begin_unit
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  gxvcommn.c                                                             */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*    TrueTypeGX/AAT common tables validation (body).                      */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  Copyright 2004, 2005, 2009                                             */
end_comment
begin_comment
comment|/*  by suzuki toshiya, Masatake YAMATO, Red Hat K.K.,                      */
end_comment
begin_comment
comment|/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  This file is part of the FreeType project, and may only be used,       */
end_comment
begin_comment
comment|/*  modified, and distributed under the terms of the FreeType project      */
end_comment
begin_comment
comment|/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
end_comment
begin_comment
comment|/*  this file you indicate that you have read the license and              */
end_comment
begin_comment
comment|/*  understand and accept it fully.                                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/* gxvalid is derived from both gxlayout module and otvalid module.        */
end_comment
begin_comment
comment|/* Development of gxlayout is supported by the Information-technology      */
end_comment
begin_comment
comment|/* Promotion Agency(IPA), Japan.                                           */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"gxvcommn.h"
end_include
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
end_comment
begin_comment
comment|/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
end_comment
begin_comment
comment|/* messages during execution.                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_undef
DECL|macro|FT_COMPONENT
undef|#
directive|undef
name|FT_COMPONENT
end_undef
begin_define
DECL|macro|FT_COMPONENT
define|#
directive|define
name|FT_COMPONENT
value|trace_gxvcommon
end_define
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****                       16bit offset sorter                     *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_function
specifier|static
name|int
DECL|function|gxv_compare_ushort_offset
name|gxv_compare_ushort_offset
parameter_list|(
name|FT_UShort
modifier|*
name|a
parameter_list|,
name|FT_UShort
modifier|*
name|b
parameter_list|)
block|{
if|if
condition|(
operator|*
name|a
operator|<
operator|*
name|b
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
operator|*
name|a
operator|>
operator|*
name|b
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|gxv_set_length_by_ushort_offset
name|gxv_set_length_by_ushort_offset
argument_list|(
argument|FT_UShort*     offset
argument_list|,
argument|FT_UShort**    length
argument_list|,
argument|FT_UShort*     buff
argument_list|,
argument|FT_UInt        nmemb
argument_list|,
argument|FT_UShort      limit
argument_list|,
argument|GXV_Validator  valid
argument_list|)
end_macro
begin_block
block|{
name|FT_UInt
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nmemb
condition|;
name|i
operator|++
control|)
operator|*
operator|(
name|length
index|[
name|i
index|]
operator|)
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nmemb
condition|;
name|i
operator|++
control|)
name|buff
index|[
name|i
index|]
operator|=
name|offset
index|[
name|i
index|]
expr_stmt|;
name|buff
index|[
name|nmemb
index|]
operator|=
name|limit
expr_stmt|;
name|ft_qsort
argument_list|(
name|buff
argument_list|,
operator|(
name|nmemb
operator|+
literal|1
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|FT_UShort
argument_list|)
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
specifier|const
name|void
operator|*
argument_list|,
specifier|const
name|void
operator|*
argument_list|)
operator|)
name|gxv_compare_ushort_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|buff
index|[
name|nmemb
index|]
operator|>
name|limit
condition|)
name|FT_INVALID_OFFSET
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nmemb
condition|;
name|i
operator|++
control|)
block|{
name|FT_UInt
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nmemb
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|buff
index|[
name|j
index|]
operator|==
name|offset
index|[
name|i
index|]
condition|)
break|break;
if|if
condition|(
name|j
operator|==
name|nmemb
condition|)
name|FT_INVALID_OFFSET
expr_stmt|;
operator|*
operator|(
name|length
index|[
name|i
index|]
operator|)
operator|=
call|(
name|FT_UShort
call|)
argument_list|(
name|buff
index|[
name|j
operator|+
literal|1
index|]
operator|-
name|buff
index|[
name|j
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|!=
name|offset
index|[
name|i
index|]
operator|&&
literal|0
operator|==
operator|*
operator|(
name|length
index|[
name|i
index|]
operator|)
condition|)
name|FT_INVALID_OFFSET
expr_stmt|;
block|}
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****                       32bit offset sorter                     *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_function
specifier|static
name|int
DECL|function|gxv_compare_ulong_offset
name|gxv_compare_ulong_offset
parameter_list|(
name|FT_ULong
modifier|*
name|a
parameter_list|,
name|FT_ULong
modifier|*
name|b
parameter_list|)
block|{
if|if
condition|(
operator|*
name|a
operator|<
operator|*
name|b
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
operator|*
name|a
operator|>
operator|*
name|b
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|gxv_set_length_by_ulong_offset
name|gxv_set_length_by_ulong_offset
argument_list|(
argument|FT_ULong*      offset
argument_list|,
argument|FT_ULong**     length
argument_list|,
argument|FT_ULong*      buff
argument_list|,
argument|FT_UInt        nmemb
argument_list|,
argument|FT_ULong       limit
argument_list|,
argument|GXV_Validator  valid
argument_list|)
end_macro
begin_block
block|{
name|FT_UInt
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nmemb
condition|;
name|i
operator|++
control|)
operator|*
operator|(
name|length
index|[
name|i
index|]
operator|)
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nmemb
condition|;
name|i
operator|++
control|)
name|buff
index|[
name|i
index|]
operator|=
name|offset
index|[
name|i
index|]
expr_stmt|;
name|buff
index|[
name|nmemb
index|]
operator|=
name|limit
expr_stmt|;
name|ft_qsort
argument_list|(
name|buff
argument_list|,
operator|(
name|nmemb
operator|+
literal|1
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|FT_ULong
argument_list|)
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
specifier|const
name|void
operator|*
argument_list|,
specifier|const
name|void
operator|*
argument_list|)
operator|)
name|gxv_compare_ulong_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|buff
index|[
name|nmemb
index|]
operator|>
name|limit
condition|)
name|FT_INVALID_OFFSET
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nmemb
condition|;
name|i
operator|++
control|)
block|{
name|FT_UInt
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nmemb
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|buff
index|[
name|j
index|]
operator|==
name|offset
index|[
name|i
index|]
condition|)
break|break;
if|if
condition|(
name|j
operator|==
name|nmemb
condition|)
name|FT_INVALID_OFFSET
expr_stmt|;
operator|*
operator|(
name|length
index|[
name|i
index|]
operator|)
operator|=
name|buff
index|[
name|j
operator|+
literal|1
index|]
operator|-
name|buff
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
literal|0
operator|!=
name|offset
index|[
name|i
index|]
operator|&&
literal|0
operator|==
operator|*
operator|(
name|length
index|[
name|i
index|]
operator|)
condition|)
name|FT_INVALID_OFFSET
expr_stmt|;
block|}
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****               scan value array and get min& max              *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|gxv_array_getlimits_byte
name|gxv_array_getlimits_byte
argument_list|(
argument|FT_Bytes       table
argument_list|,
argument|FT_Bytes       limit
argument_list|,
argument|FT_Byte*       min
argument_list|,
argument|FT_Byte*       max
argument_list|,
argument|GXV_Validator  valid
argument_list|)
end_macro
begin_block
block|{
name|FT_Bytes
name|p
init|=
name|table
decl_stmt|;
operator|*
name|min
operator|=
literal|0xFF
expr_stmt|;
operator|*
name|max
operator|=
literal|0x00
expr_stmt|;
while|while
condition|(
name|p
operator|<
name|limit
condition|)
block|{
name|FT_Byte
name|val
decl_stmt|;
name|GXV_LIMIT_CHECK
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|val
operator|=
name|FT_NEXT_BYTE
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|*
name|min
operator|=
operator|(
name|FT_Byte
operator|)
name|FT_MIN
argument_list|(
operator|*
name|min
argument_list|,
name|val
argument_list|)
expr_stmt|;
operator|*
name|max
operator|=
operator|(
name|FT_Byte
operator|)
name|FT_MAX
argument_list|(
operator|*
name|max
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
name|valid
operator|->
name|subtable_length
operator|=
name|p
operator|-
name|table
expr_stmt|;
block|}
end_block
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|gxv_array_getlimits_ushort
name|gxv_array_getlimits_ushort
argument_list|(
argument|FT_Bytes       table
argument_list|,
argument|FT_Bytes       limit
argument_list|,
argument|FT_UShort*     min
argument_list|,
argument|FT_UShort*     max
argument_list|,
argument|GXV_Validator  valid
argument_list|)
end_macro
begin_block
block|{
name|FT_Bytes
name|p
init|=
name|table
decl_stmt|;
operator|*
name|min
operator|=
literal|0xFFFFU
expr_stmt|;
operator|*
name|max
operator|=
literal|0x0000
expr_stmt|;
while|while
condition|(
name|p
operator|<
name|limit
condition|)
block|{
name|FT_UShort
name|val
decl_stmt|;
name|GXV_LIMIT_CHECK
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|val
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|*
name|min
operator|=
operator|(
name|FT_Byte
operator|)
name|FT_MIN
argument_list|(
operator|*
name|min
argument_list|,
name|val
argument_list|)
expr_stmt|;
operator|*
name|max
operator|=
operator|(
name|FT_Byte
operator|)
name|FT_MAX
argument_list|(
operator|*
name|max
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
name|valid
operator|->
name|subtable_length
operator|=
name|p
operator|-
name|table
expr_stmt|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****                       BINSEARCHHEADER                         *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_typedef
DECL|struct|GXV_BinSrchHeader_
typedef|typedef
struct|struct
name|GXV_BinSrchHeader_
block|{
DECL|member|unitSize
name|FT_UShort
name|unitSize
decl_stmt|;
DECL|member|nUnits
name|FT_UShort
name|nUnits
decl_stmt|;
DECL|member|searchRange
name|FT_UShort
name|searchRange
decl_stmt|;
DECL|member|entrySelector
name|FT_UShort
name|entrySelector
decl_stmt|;
DECL|member|rangeShift
name|FT_UShort
name|rangeShift
decl_stmt|;
block|}
DECL|typedef|GXV_BinSrchHeader
name|GXV_BinSrchHeader
typedef|;
end_typedef
begin_function
specifier|static
name|void
DECL|function|gxv_BinSrchHeader_check_consistency
name|gxv_BinSrchHeader_check_consistency
parameter_list|(
name|GXV_BinSrchHeader
modifier|*
name|binSrchHeader
parameter_list|,
name|GXV_Validator
name|valid
parameter_list|)
block|{
name|FT_UShort
name|searchRange
decl_stmt|;
name|FT_UShort
name|entrySelector
decl_stmt|;
name|FT_UShort
name|rangeShift
decl_stmt|;
if|if
condition|(
name|binSrchHeader
operator|->
name|unitSize
operator|==
literal|0
condition|)
name|FT_INVALID_DATA
expr_stmt|;
if|if
condition|(
name|binSrchHeader
operator|->
name|nUnits
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|binSrchHeader
operator|->
name|searchRange
operator|==
literal|0
operator|&&
name|binSrchHeader
operator|->
name|entrySelector
operator|==
literal|0
operator|&&
name|binSrchHeader
operator|->
name|rangeShift
operator|==
literal|0
condition|)
return|return;
else|else
name|FT_INVALID_DATA
expr_stmt|;
block|}
for|for
control|(
name|searchRange
operator|=
literal|1
operator|,
name|entrySelector
operator|=
literal|1
init|;
operator|(
name|searchRange
operator|*
literal|2
operator|)
operator|<=
name|binSrchHeader
operator|->
name|nUnits
operator|&&
name|searchRange
operator|<
literal|0x8000U
condition|;
name|searchRange
operator|*=
literal|2
operator|,
name|entrySelector
operator|++
control|)
empty_stmt|;
name|entrySelector
operator|--
expr_stmt|;
name|searchRange
operator|=
call|(
name|FT_UShort
call|)
argument_list|(
name|searchRange
operator|*
name|binSrchHeader
operator|->
name|unitSize
argument_list|)
expr_stmt|;
name|rangeShift
operator|=
call|(
name|FT_UShort
call|)
argument_list|(
name|binSrchHeader
operator|->
name|nUnits
operator|*
name|binSrchHeader
operator|->
name|unitSize
operator|-
name|searchRange
argument_list|)
expr_stmt|;
if|if
condition|(
name|searchRange
operator|!=
name|binSrchHeader
operator|->
name|searchRange
operator|||
name|entrySelector
operator|!=
name|binSrchHeader
operator|->
name|entrySelector
operator|||
name|rangeShift
operator|!=
name|binSrchHeader
operator|->
name|rangeShift
condition|)
block|{
name|GXV_TRACE
argument_list|(
operator|(
literal|"Inconsistency found in BinSrchHeader\n"
operator|)
argument_list|)
expr_stmt|;
name|GXV_TRACE
argument_list|(
operator|(
literal|"originally: unitSize=%d, nUnits=%d, "
literal|"searchRange=%d, entrySelector=%d, "
literal|"rangeShift=%d\n"
operator|,
name|binSrchHeader
operator|->
name|unitSize
operator|,
name|binSrchHeader
operator|->
name|nUnits
operator|,
name|binSrchHeader
operator|->
name|searchRange
operator|,
name|binSrchHeader
operator|->
name|entrySelector
operator|,
name|binSrchHeader
operator|->
name|rangeShift
operator|)
argument_list|)
expr_stmt|;
name|GXV_TRACE
argument_list|(
operator|(
literal|"calculated: unitSize=%d, nUnits=%d, "
literal|"searchRange=%d, entrySelector=%d, "
literal|"rangeShift=%d\n"
operator|,
name|binSrchHeader
operator|->
name|unitSize
operator|,
name|binSrchHeader
operator|->
name|nUnits
operator|,
name|searchRange
operator|,
name|entrySelector
operator|,
name|rangeShift
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|valid
operator|->
name|root
operator|->
name|level
operator|>=
name|FT_VALIDATE_PARANOID
condition|)
name|FT_INVALID_DATA
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*    * parser& validator of BinSrchHeader    * which is used in LookupTable format 2, 4, 6.    *    * Essential parameters (unitSize, nUnits) are returned by    * given pointer, others (searchRange, entrySelector, rangeShift)    * can be calculated by essential parameters, so they are just    * validated and discarded.    *    * However, wrong values in searchRange, entrySelector, rangeShift    * won't cause fatal errors, because these parameters might be    * only used in old m68k font driver in MacOS.    *   -- suzuki toshiya<mpsuzuki@hiroshima-u.ac.jp>    */
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|gxv_BinSrchHeader_validate
name|gxv_BinSrchHeader_validate
argument_list|(
argument|FT_Bytes       table
argument_list|,
argument|FT_Bytes       limit
argument_list|,
argument|FT_UShort*     unitSize_p
argument_list|,
argument|FT_UShort*     nUnits_p
argument_list|,
argument|GXV_Validator  valid
argument_list|)
end_macro
begin_block
block|{
name|FT_Bytes
name|p
init|=
name|table
decl_stmt|;
name|GXV_BinSrchHeader
name|binSrchHeader
decl_stmt|;
name|GXV_NAME_ENTER
argument_list|(
literal|"BinSrchHeader validate"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|unitSize_p
operator|==
literal|0
condition|)
block|{
name|GXV_LIMIT_CHECK
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|binSrchHeader
operator|.
name|unitSize
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
name|binSrchHeader
operator|.
name|unitSize
operator|=
operator|*
name|unitSize_p
expr_stmt|;
if|if
condition|(
operator|*
name|nUnits_p
operator|==
literal|0
condition|)
block|{
name|GXV_LIMIT_CHECK
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|binSrchHeader
operator|.
name|nUnits
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
name|binSrchHeader
operator|.
name|nUnits
operator|=
operator|*
name|nUnits_p
expr_stmt|;
name|GXV_LIMIT_CHECK
argument_list|(
literal|2
operator|+
literal|2
operator|+
literal|2
argument_list|)
expr_stmt|;
name|binSrchHeader
operator|.
name|searchRange
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|binSrchHeader
operator|.
name|entrySelector
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|binSrchHeader
operator|.
name|rangeShift
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|GXV_TRACE
argument_list|(
operator|(
literal|"nUnits %d\n"
operator|,
name|binSrchHeader
operator|.
name|nUnits
operator|)
argument_list|)
expr_stmt|;
name|gxv_BinSrchHeader_check_consistency
argument_list|(
operator|&
name|binSrchHeader
argument_list|,
name|valid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|unitSize_p
operator|==
literal|0
condition|)
operator|*
name|unitSize_p
operator|=
name|binSrchHeader
operator|.
name|unitSize
expr_stmt|;
if|if
condition|(
operator|*
name|nUnits_p
operator|==
literal|0
condition|)
operator|*
name|nUnits_p
operator|=
name|binSrchHeader
operator|.
name|nUnits
expr_stmt|;
name|valid
operator|->
name|subtable_length
operator|=
name|p
operator|-
name|table
expr_stmt|;
name|GXV_EXIT
expr_stmt|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****                         LOOKUP TABLE                          *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_define
DECL|macro|GXV_LOOKUP_VALUE_LOAD
define|#
directive|define
name|GXV_LOOKUP_VALUE_LOAD
parameter_list|(
name|P
parameter_list|,
name|SIGNSPEC
parameter_list|)
define|\
value|( P += 2, gxv_lookup_value_load( P - 2, SIGNSPEC ) )
end_define
begin_function
specifier|static
name|GXV_LookupValueDesc
DECL|function|gxv_lookup_value_load
name|gxv_lookup_value_load
parameter_list|(
name|FT_Bytes
name|p
parameter_list|,
name|int
name|signspec
parameter_list|)
block|{
name|GXV_LookupValueDesc
name|v
decl_stmt|;
if|if
condition|(
name|signspec
operator|==
name|GXV_LOOKUPVALUE_UNSIGNED
condition|)
name|v
operator|.
name|u
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
name|v
operator|.
name|s
operator|=
name|FT_NEXT_SHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|v
return|;
block|}
end_function
begin_define
DECL|macro|GXV_UNITSIZE_VALIDATE
define|#
directive|define
name|GXV_UNITSIZE_VALIDATE
parameter_list|(
name|FORMAT
parameter_list|,
name|UNITSIZE
parameter_list|,
name|NUNITS
parameter_list|,
name|CORRECTSIZE
parameter_list|)
define|\
value|FT_BEGIN_STMNT                                               \             if ( UNITSIZE != CORRECTSIZE )                             \             {                                                          \               FT_ERROR(( "unitSize=%d differs from"                    \                          " expected unitSize=%d"                       \                          " in LookupTable %s\n",                       \                           UNITSIZE, CORRECTSIZE, FORMAT ));            \               if ( UNITSIZE != 0&& NUNITS != 0 )                      \               {                                                        \                 FT_ERROR(( " cannot validate anymore\n" ));            \                 FT_INVALID_FORMAT;                                     \               }                                                        \               else                                                     \                 FT_ERROR(( " forcibly continues\n" ));                 \             }                                                          \           FT_END_STMNT
end_define
begin_comment
comment|/* ================= Simple Array Format 0 Lookup Table ================ */
end_comment
begin_function
specifier|static
name|void
DECL|function|gxv_LookupTable_fmt0_validate
name|gxv_LookupTable_fmt0_validate
parameter_list|(
name|FT_Bytes
name|table
parameter_list|,
name|FT_Bytes
name|limit
parameter_list|,
name|GXV_Validator
name|valid
parameter_list|)
block|{
name|FT_Bytes
name|p
init|=
name|table
decl_stmt|;
name|FT_UShort
name|i
decl_stmt|;
name|GXV_LookupValueDesc
name|value
decl_stmt|;
name|GXV_NAME_ENTER
argument_list|(
literal|"LookupTable format 0"
argument_list|)
expr_stmt|;
name|GXV_LIMIT_CHECK
argument_list|(
literal|2
operator|*
name|valid
operator|->
name|face
operator|->
name|num_glyphs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|valid
operator|->
name|face
operator|->
name|num_glyphs
condition|;
name|i
operator|++
control|)
block|{
name|GXV_LIMIT_CHECK
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|+
literal|2
operator|>=
name|limit
condition|)
comment|/* some fonts have too-short fmt0 array */
block|{
name|GXV_TRACE
argument_list|(
operator|(
literal|"too short, glyphs %d - %d are missing\n"
operator|,
name|i
operator|,
name|valid
operator|->
name|face
operator|->
name|num_glyphs
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|valid
operator|->
name|root
operator|->
name|level
operator|>=
name|FT_VALIDATE_PARANOID
condition|)
name|FT_INVALID_GLYPH_ID
expr_stmt|;
break|break;
block|}
name|value
operator|=
name|GXV_LOOKUP_VALUE_LOAD
argument_list|(
name|p
argument_list|,
name|valid
operator|->
name|lookupval_sign
argument_list|)
expr_stmt|;
name|valid
operator|->
name|lookupval_func
argument_list|(
name|i
argument_list|,
operator|&
name|value
argument_list|,
name|valid
argument_list|)
expr_stmt|;
block|}
name|valid
operator|->
name|subtable_length
operator|=
name|p
operator|-
name|table
expr_stmt|;
name|GXV_EXIT
expr_stmt|;
block|}
end_function
begin_comment
comment|/* ================= Segment Single Format 2 Loolup Table ============== */
end_comment
begin_comment
comment|/*    * Apple spec says:    *    *   To guarantee that a binary search terminates, you must include one or    *   more special `end of search table' values at the end of the data to    *   be searched.  The number of termination values that need to be    *   included is table-specific.  The value that indicates binary search    *   termination is 0xFFFF.    *    * The problem is that nUnits does not include this end-marker.  It's    * quite difficult to discriminate whether the following 0xFFFF comes from    * the end-marker or some next data.    *    *   -- suzuki toshiya<mpsuzuki@hiroshima-u.ac.jp>    */
end_comment
begin_function
specifier|static
name|void
DECL|function|gxv_LookupTable_fmt2_skip_endmarkers
name|gxv_LookupTable_fmt2_skip_endmarkers
parameter_list|(
name|FT_Bytes
name|table
parameter_list|,
name|FT_UShort
name|unitSize
parameter_list|,
name|GXV_Validator
name|valid
parameter_list|)
block|{
name|FT_Bytes
name|p
init|=
name|table
decl_stmt|;
while|while
condition|(
operator|(
name|p
operator|+
literal|4
operator|)
operator|<
name|valid
operator|->
name|root
operator|->
name|limit
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|!=
literal|0xFF
operator|||
name|p
index|[
literal|1
index|]
operator|!=
literal|0xFF
operator|||
comment|/* lastGlyph */
name|p
index|[
literal|2
index|]
operator|!=
literal|0xFF
operator|||
name|p
index|[
literal|3
index|]
operator|!=
literal|0xFF
condition|)
comment|/* firstGlyph */
break|break;
name|p
operator|+=
name|unitSize
expr_stmt|;
block|}
name|valid
operator|->
name|subtable_length
operator|=
name|p
operator|-
name|table
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|gxv_LookupTable_fmt2_validate
name|gxv_LookupTable_fmt2_validate
parameter_list|(
name|FT_Bytes
name|table
parameter_list|,
name|FT_Bytes
name|limit
parameter_list|,
name|GXV_Validator
name|valid
parameter_list|)
block|{
name|FT_Bytes
name|p
init|=
name|table
decl_stmt|;
name|FT_UShort
name|gid
decl_stmt|;
name|FT_UShort
name|unitSize
decl_stmt|;
name|FT_UShort
name|nUnits
decl_stmt|;
name|FT_UShort
name|unit
decl_stmt|;
name|FT_UShort
name|lastGlyph
decl_stmt|;
name|FT_UShort
name|firstGlyph
decl_stmt|;
name|GXV_LookupValueDesc
name|value
decl_stmt|;
name|GXV_NAME_ENTER
argument_list|(
literal|"LookupTable format 2"
argument_list|)
expr_stmt|;
name|unitSize
operator|=
name|nUnits
operator|=
literal|0
expr_stmt|;
name|gxv_BinSrchHeader_validate
argument_list|(
name|p
argument_list|,
name|limit
argument_list|,
operator|&
name|unitSize
argument_list|,
operator|&
name|nUnits
argument_list|,
name|valid
argument_list|)
expr_stmt|;
name|p
operator|+=
name|valid
operator|->
name|subtable_length
expr_stmt|;
name|GXV_UNITSIZE_VALIDATE
argument_list|(
literal|"format2"
argument_list|,
name|unitSize
argument_list|,
name|nUnits
argument_list|,
literal|6
argument_list|)
expr_stmt|;
for|for
control|(
name|unit
operator|=
literal|0
operator|,
name|gid
operator|=
literal|0
init|;
name|unit
operator|<
name|nUnits
condition|;
name|unit
operator|++
control|)
block|{
name|GXV_LIMIT_CHECK
argument_list|(
literal|2
operator|+
literal|2
operator|+
literal|2
argument_list|)
expr_stmt|;
name|lastGlyph
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|firstGlyph
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|value
operator|=
name|GXV_LOOKUP_VALUE_LOAD
argument_list|(
name|p
argument_list|,
name|valid
operator|->
name|lookupval_sign
argument_list|)
expr_stmt|;
name|gxv_glyphid_validate
argument_list|(
name|firstGlyph
argument_list|,
name|valid
argument_list|)
expr_stmt|;
name|gxv_glyphid_validate
argument_list|(
name|lastGlyph
argument_list|,
name|valid
argument_list|)
expr_stmt|;
if|if
condition|(
name|lastGlyph
operator|<
name|gid
condition|)
block|{
name|GXV_TRACE
argument_list|(
operator|(
literal|"reverse ordered segment specification:"
literal|" lastGlyph[%d]=%d< lastGlyph[%d]=%d\n"
operator|,
name|unit
operator|,
name|lastGlyph
operator|,
name|unit
operator|-
literal|1
operator|,
name|gid
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|valid
operator|->
name|root
operator|->
name|level
operator|>=
name|FT_VALIDATE_PARANOID
condition|)
name|FT_INVALID_GLYPH_ID
expr_stmt|;
block|}
if|if
condition|(
name|lastGlyph
operator|<
name|firstGlyph
condition|)
block|{
name|GXV_TRACE
argument_list|(
operator|(
literal|"reverse ordered range specification at unit %d:"
operator|,
literal|" lastGlyph %d< firstGlyph %d "
operator|,
name|unit
operator|,
name|lastGlyph
operator|,
name|firstGlyph
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|valid
operator|->
name|root
operator|->
name|level
operator|>=
name|FT_VALIDATE_PARANOID
condition|)
name|FT_INVALID_GLYPH_ID
expr_stmt|;
if|if
condition|(
name|valid
operator|->
name|root
operator|->
name|level
operator|==
name|FT_VALIDATE_TIGHT
condition|)
continue|continue;
comment|/* ftxvalidator silently skips such an entry */
name|FT_TRACE4
argument_list|(
operator|(
literal|"continuing with exchanged values\n"
operator|)
argument_list|)
expr_stmt|;
name|gid
operator|=
name|firstGlyph
expr_stmt|;
name|firstGlyph
operator|=
name|lastGlyph
expr_stmt|;
name|lastGlyph
operator|=
name|gid
expr_stmt|;
block|}
for|for
control|(
name|gid
operator|=
name|firstGlyph
init|;
name|gid
operator|<=
name|lastGlyph
condition|;
name|gid
operator|++
control|)
name|valid
operator|->
name|lookupval_func
argument_list|(
name|gid
argument_list|,
operator|&
name|value
argument_list|,
name|valid
argument_list|)
expr_stmt|;
block|}
name|gxv_LookupTable_fmt2_skip_endmarkers
argument_list|(
name|p
argument_list|,
name|unitSize
argument_list|,
name|valid
argument_list|)
expr_stmt|;
name|p
operator|+=
name|valid
operator|->
name|subtable_length
expr_stmt|;
name|valid
operator|->
name|subtable_length
operator|=
name|p
operator|-
name|table
expr_stmt|;
name|GXV_EXIT
expr_stmt|;
block|}
end_function
begin_comment
comment|/* ================= Segment Array Format 4 Lookup Table =============== */
end_comment
begin_function
specifier|static
name|void
DECL|function|gxv_LookupTable_fmt4_validate
name|gxv_LookupTable_fmt4_validate
parameter_list|(
name|FT_Bytes
name|table
parameter_list|,
name|FT_Bytes
name|limit
parameter_list|,
name|GXV_Validator
name|valid
parameter_list|)
block|{
name|FT_Bytes
name|p
init|=
name|table
decl_stmt|;
name|FT_UShort
name|unit
decl_stmt|;
name|FT_UShort
name|gid
decl_stmt|;
name|FT_UShort
name|unitSize
decl_stmt|;
name|FT_UShort
name|nUnits
decl_stmt|;
name|FT_UShort
name|lastGlyph
decl_stmt|;
name|FT_UShort
name|firstGlyph
decl_stmt|;
name|GXV_LookupValueDesc
name|base_value
decl_stmt|;
name|GXV_LookupValueDesc
name|value
decl_stmt|;
name|GXV_NAME_ENTER
argument_list|(
literal|"LookupTable format 4"
argument_list|)
expr_stmt|;
name|unitSize
operator|=
name|nUnits
operator|=
literal|0
expr_stmt|;
name|gxv_BinSrchHeader_validate
argument_list|(
name|p
argument_list|,
name|limit
argument_list|,
operator|&
name|unitSize
argument_list|,
operator|&
name|nUnits
argument_list|,
name|valid
argument_list|)
expr_stmt|;
name|p
operator|+=
name|valid
operator|->
name|subtable_length
expr_stmt|;
name|GXV_UNITSIZE_VALIDATE
argument_list|(
literal|"format4"
argument_list|,
name|unitSize
argument_list|,
name|nUnits
argument_list|,
literal|6
argument_list|)
expr_stmt|;
for|for
control|(
name|unit
operator|=
literal|0
operator|,
name|gid
operator|=
literal|0
init|;
name|unit
operator|<
name|nUnits
condition|;
name|unit
operator|++
control|)
block|{
name|GXV_LIMIT_CHECK
argument_list|(
literal|2
operator|+
literal|2
argument_list|)
expr_stmt|;
name|lastGlyph
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|firstGlyph
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|gxv_glyphid_validate
argument_list|(
name|firstGlyph
argument_list|,
name|valid
argument_list|)
expr_stmt|;
name|gxv_glyphid_validate
argument_list|(
name|lastGlyph
argument_list|,
name|valid
argument_list|)
expr_stmt|;
if|if
condition|(
name|lastGlyph
operator|<
name|gid
condition|)
block|{
name|GXV_TRACE
argument_list|(
operator|(
literal|"reverse ordered segment specification:"
literal|" lastGlyph[%d]=%d< lastGlyph[%d]=%d\n"
operator|,
name|unit
operator|,
name|lastGlyph
operator|,
name|unit
operator|-
literal|1
operator|,
name|gid
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|valid
operator|->
name|root
operator|->
name|level
operator|>=
name|FT_VALIDATE_PARANOID
condition|)
name|FT_INVALID_GLYPH_ID
expr_stmt|;
block|}
if|if
condition|(
name|lastGlyph
operator|<
name|firstGlyph
condition|)
block|{
name|GXV_TRACE
argument_list|(
operator|(
literal|"reverse ordered range specification at unit %d:"
operator|,
literal|" lastGlyph %d< firstGlyph %d "
operator|,
name|unit
operator|,
name|lastGlyph
operator|,
name|firstGlyph
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|valid
operator|->
name|root
operator|->
name|level
operator|>=
name|FT_VALIDATE_PARANOID
condition|)
name|FT_INVALID_GLYPH_ID
expr_stmt|;
if|if
condition|(
name|valid
operator|->
name|root
operator|->
name|level
operator|==
name|FT_VALIDATE_TIGHT
condition|)
continue|continue;
comment|/* ftxvalidator silently skips such an entry */
name|FT_TRACE4
argument_list|(
operator|(
literal|"continuing with exchanged values\n"
operator|)
argument_list|)
expr_stmt|;
name|gid
operator|=
name|firstGlyph
expr_stmt|;
name|firstGlyph
operator|=
name|lastGlyph
expr_stmt|;
name|lastGlyph
operator|=
name|gid
expr_stmt|;
block|}
name|GXV_LIMIT_CHECK
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|base_value
operator|=
name|GXV_LOOKUP_VALUE_LOAD
argument_list|(
name|p
argument_list|,
name|GXV_LOOKUPVALUE_UNSIGNED
argument_list|)
expr_stmt|;
for|for
control|(
name|gid
operator|=
name|firstGlyph
init|;
name|gid
operator|<=
name|lastGlyph
condition|;
name|gid
operator|++
control|)
block|{
name|value
operator|=
name|valid
operator|->
name|lookupfmt4_trans
argument_list|(
call|(
name|FT_UShort
call|)
argument_list|(
name|gid
operator|-
name|firstGlyph
argument_list|)
argument_list|,
operator|&
name|base_value
argument_list|,
name|limit
argument_list|,
name|valid
argument_list|)
expr_stmt|;
name|valid
operator|->
name|lookupval_func
argument_list|(
name|gid
argument_list|,
operator|&
name|value
argument_list|,
name|valid
argument_list|)
expr_stmt|;
block|}
block|}
name|gxv_LookupTable_fmt2_skip_endmarkers
argument_list|(
name|p
argument_list|,
name|unitSize
argument_list|,
name|valid
argument_list|)
expr_stmt|;
name|p
operator|+=
name|valid
operator|->
name|subtable_length
expr_stmt|;
name|valid
operator|->
name|subtable_length
operator|=
name|p
operator|-
name|table
expr_stmt|;
name|GXV_EXIT
expr_stmt|;
block|}
end_function
begin_comment
comment|/* ================= Segment Table Format 6 Lookup Table =============== */
end_comment
begin_function
specifier|static
name|void
DECL|function|gxv_LookupTable_fmt6_skip_endmarkers
name|gxv_LookupTable_fmt6_skip_endmarkers
parameter_list|(
name|FT_Bytes
name|table
parameter_list|,
name|FT_UShort
name|unitSize
parameter_list|,
name|GXV_Validator
name|valid
parameter_list|)
block|{
name|FT_Bytes
name|p
init|=
name|table
decl_stmt|;
while|while
condition|(
name|p
operator|<
name|valid
operator|->
name|root
operator|->
name|limit
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|!=
literal|0xFF
operator|||
name|p
index|[
literal|1
index|]
operator|!=
literal|0xFF
condition|)
break|break;
name|p
operator|+=
name|unitSize
expr_stmt|;
block|}
name|valid
operator|->
name|subtable_length
operator|=
name|p
operator|-
name|table
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|gxv_LookupTable_fmt6_validate
name|gxv_LookupTable_fmt6_validate
parameter_list|(
name|FT_Bytes
name|table
parameter_list|,
name|FT_Bytes
name|limit
parameter_list|,
name|GXV_Validator
name|valid
parameter_list|)
block|{
name|FT_Bytes
name|p
init|=
name|table
decl_stmt|;
name|FT_UShort
name|unit
decl_stmt|;
name|FT_UShort
name|prev_glyph
decl_stmt|;
name|FT_UShort
name|unitSize
decl_stmt|;
name|FT_UShort
name|nUnits
decl_stmt|;
name|FT_UShort
name|glyph
decl_stmt|;
name|GXV_LookupValueDesc
name|value
decl_stmt|;
name|GXV_NAME_ENTER
argument_list|(
literal|"LookupTable format 6"
argument_list|)
expr_stmt|;
name|unitSize
operator|=
name|nUnits
operator|=
literal|0
expr_stmt|;
name|gxv_BinSrchHeader_validate
argument_list|(
name|p
argument_list|,
name|limit
argument_list|,
operator|&
name|unitSize
argument_list|,
operator|&
name|nUnits
argument_list|,
name|valid
argument_list|)
expr_stmt|;
name|p
operator|+=
name|valid
operator|->
name|subtable_length
expr_stmt|;
name|GXV_UNITSIZE_VALIDATE
argument_list|(
literal|"format6"
argument_list|,
name|unitSize
argument_list|,
name|nUnits
argument_list|,
literal|4
argument_list|)
expr_stmt|;
for|for
control|(
name|unit
operator|=
literal|0
operator|,
name|prev_glyph
operator|=
literal|0
init|;
name|unit
operator|<
name|nUnits
condition|;
name|unit
operator|++
control|)
block|{
name|GXV_LIMIT_CHECK
argument_list|(
literal|2
operator|+
literal|2
argument_list|)
expr_stmt|;
name|glyph
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|value
operator|=
name|GXV_LOOKUP_VALUE_LOAD
argument_list|(
name|p
argument_list|,
name|valid
operator|->
name|lookupval_sign
argument_list|)
expr_stmt|;
if|if
condition|(
name|gxv_glyphid_validate
argument_list|(
name|glyph
argument_list|,
name|valid
argument_list|)
condition|)
name|GXV_TRACE
argument_list|(
operator|(
literal|" endmarker found within defined range"
literal|" (entry %d< nUnits=%d)\n"
operator|,
name|unit
operator|,
name|nUnits
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev_glyph
operator|>
name|glyph
condition|)
block|{
name|GXV_TRACE
argument_list|(
operator|(
literal|"current gid 0x%04x< previous gid 0x%04x\n"
operator|,
name|glyph
operator|,
name|prev_glyph
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|valid
operator|->
name|root
operator|->
name|level
operator|>=
name|FT_VALIDATE_PARANOID
condition|)
name|FT_INVALID_GLYPH_ID
expr_stmt|;
block|}
name|prev_glyph
operator|=
name|glyph
expr_stmt|;
name|valid
operator|->
name|lookupval_func
argument_list|(
name|glyph
argument_list|,
operator|&
name|value
argument_list|,
name|valid
argument_list|)
expr_stmt|;
block|}
name|gxv_LookupTable_fmt6_skip_endmarkers
argument_list|(
name|p
argument_list|,
name|unitSize
argument_list|,
name|valid
argument_list|)
expr_stmt|;
name|p
operator|+=
name|valid
operator|->
name|subtable_length
expr_stmt|;
name|valid
operator|->
name|subtable_length
operator|=
name|p
operator|-
name|table
expr_stmt|;
name|GXV_EXIT
expr_stmt|;
block|}
end_function
begin_comment
comment|/* ================= Trimmed Array Format 8 Lookup Table =============== */
end_comment
begin_function
specifier|static
name|void
DECL|function|gxv_LookupTable_fmt8_validate
name|gxv_LookupTable_fmt8_validate
parameter_list|(
name|FT_Bytes
name|table
parameter_list|,
name|FT_Bytes
name|limit
parameter_list|,
name|GXV_Validator
name|valid
parameter_list|)
block|{
name|FT_Bytes
name|p
init|=
name|table
decl_stmt|;
name|FT_UShort
name|i
decl_stmt|;
name|GXV_LookupValueDesc
name|value
decl_stmt|;
name|FT_UShort
name|firstGlyph
decl_stmt|;
name|FT_UShort
name|glyphCount
decl_stmt|;
name|GXV_NAME_ENTER
argument_list|(
literal|"LookupTable format 8"
argument_list|)
expr_stmt|;
comment|/* firstGlyph + glyphCount */
name|GXV_LIMIT_CHECK
argument_list|(
literal|2
operator|+
literal|2
argument_list|)
expr_stmt|;
name|firstGlyph
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|glyphCount
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|gxv_glyphid_validate
argument_list|(
name|firstGlyph
argument_list|,
name|valid
argument_list|)
expr_stmt|;
name|gxv_glyphid_validate
argument_list|(
call|(
name|FT_UShort
call|)
argument_list|(
name|firstGlyph
operator|+
name|glyphCount
argument_list|)
argument_list|,
name|valid
argument_list|)
expr_stmt|;
comment|/* valueArray */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|glyphCount
condition|;
name|i
operator|++
control|)
block|{
name|GXV_LIMIT_CHECK
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|value
operator|=
name|GXV_LOOKUP_VALUE_LOAD
argument_list|(
name|p
argument_list|,
name|valid
operator|->
name|lookupval_sign
argument_list|)
expr_stmt|;
name|valid
operator|->
name|lookupval_func
argument_list|(
call|(
name|FT_UShort
call|)
argument_list|(
name|firstGlyph
operator|+
name|i
argument_list|)
argument_list|,
operator|&
name|value
argument_list|,
name|valid
argument_list|)
expr_stmt|;
block|}
name|valid
operator|->
name|subtable_length
operator|=
name|p
operator|-
name|table
expr_stmt|;
name|GXV_EXIT
expr_stmt|;
block|}
end_function
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|gxv_LookupTable_validate
name|gxv_LookupTable_validate
argument_list|(
argument|FT_Bytes       table
argument_list|,
argument|FT_Bytes       limit
argument_list|,
argument|GXV_Validator  valid
argument_list|)
end_macro
begin_block
block|{
name|FT_Bytes
name|p
init|=
name|table
decl_stmt|;
name|FT_UShort
name|format
decl_stmt|;
name|GXV_Validate_Func
name|fmt_funcs_table
index|[]
init|=
block|{
name|gxv_LookupTable_fmt0_validate
block|,
comment|/* 0 */
name|NULL
block|,
comment|/* 1 */
name|gxv_LookupTable_fmt2_validate
block|,
comment|/* 2 */
name|NULL
block|,
comment|/* 3 */
name|gxv_LookupTable_fmt4_validate
block|,
comment|/* 4 */
name|NULL
block|,
comment|/* 5 */
name|gxv_LookupTable_fmt6_validate
block|,
comment|/* 6 */
name|NULL
block|,
comment|/* 7 */
name|gxv_LookupTable_fmt8_validate
block|,
comment|/* 8 */
block|}
decl_stmt|;
name|GXV_Validate_Func
name|func
decl_stmt|;
name|GXV_NAME_ENTER
argument_list|(
literal|"LookupTable"
argument_list|)
expr_stmt|;
comment|/* lookuptbl_head may be used in fmt4 transit function. */
name|valid
operator|->
name|lookuptbl_head
operator|=
name|table
expr_stmt|;
comment|/* format */
name|GXV_LIMIT_CHECK
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|format
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|GXV_TRACE
argument_list|(
operator|(
literal|" (format %d)\n"
operator|,
name|format
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|format
operator|>
literal|8
condition|)
name|FT_INVALID_FORMAT
expr_stmt|;
name|func
operator|=
name|fmt_funcs_table
index|[
name|format
index|]
expr_stmt|;
if|if
condition|(
name|func
operator|==
name|NULL
condition|)
name|FT_INVALID_FORMAT
expr_stmt|;
name|func
argument_list|(
name|p
argument_list|,
name|limit
argument_list|,
name|valid
argument_list|)
expr_stmt|;
name|p
operator|+=
name|valid
operator|->
name|subtable_length
expr_stmt|;
name|valid
operator|->
name|subtable_length
operator|=
name|p
operator|-
name|table
expr_stmt|;
name|GXV_EXIT
expr_stmt|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****                          Glyph ID                             *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Int
argument_list|)
end_macro
begin_macro
name|gxv_glyphid_validate
argument_list|(
argument|FT_UShort      gid
argument_list|,
argument|GXV_Validator  valid
argument_list|)
end_macro
begin_block
block|{
name|FT_Face
name|face
decl_stmt|;
if|if
condition|(
name|gid
operator|==
literal|0xFFFFU
condition|)
block|{
name|GXV_EXIT
expr_stmt|;
return|return
literal|1
return|;
block|}
name|face
operator|=
name|valid
operator|->
name|face
expr_stmt|;
if|if
condition|(
name|face
operator|->
name|num_glyphs
operator|<
name|gid
condition|)
block|{
name|GXV_TRACE
argument_list|(
operator|(
literal|" gxv_glyphid_check() gid overflow: num_glyphs %d< %d\n"
operator|,
name|face
operator|->
name|num_glyphs
operator|,
name|gid
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|valid
operator|->
name|root
operator|->
name|level
operator|>=
name|FT_VALIDATE_PARANOID
condition|)
name|FT_INVALID_GLYPH_ID
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****                        CONTROL POINT                          *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|gxv_ctlPoint_validate
name|gxv_ctlPoint_validate
argument_list|(
argument|FT_UShort      gid
argument_list|,
argument|FT_Short       ctl_point
argument_list|,
argument|GXV_Validator  valid
argument_list|)
end_macro
begin_block
block|{
name|FT_Face
name|face
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|FT_GlyphSlot
name|glyph
decl_stmt|;
name|FT_Outline
name|outline
decl_stmt|;
name|short
name|n_points
decl_stmt|;
name|face
operator|=
name|valid
operator|->
name|face
expr_stmt|;
name|error
operator|=
name|FT_Load_Glyph
argument_list|(
name|face
argument_list|,
name|gid
argument_list|,
name|FT_LOAD_NO_BITMAP
operator||
name|FT_LOAD_IGNORE_TRANSFORM
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|FT_INVALID_GLYPH_ID
expr_stmt|;
name|glyph
operator|=
name|face
operator|->
name|glyph
expr_stmt|;
name|outline
operator|=
name|glyph
operator|->
name|outline
expr_stmt|;
name|n_points
operator|=
name|outline
operator|.
name|n_points
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ctl_point
operator|<
name|n_points
operator|)
condition|)
name|FT_INVALID_DATA
expr_stmt|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****                          SFNT NAME                            *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|gxv_sfntName_validate
name|gxv_sfntName_validate
argument_list|(
argument|FT_UShort      name_index
argument_list|,
argument|FT_UShort      min_index
argument_list|,
argument|FT_UShort      max_index
argument_list|,
argument|GXV_Validator  valid
argument_list|)
end_macro
begin_block
block|{
name|FT_SfntName
name|name
decl_stmt|;
name|FT_UInt
name|i
decl_stmt|;
name|FT_UInt
name|nnames
decl_stmt|;
name|GXV_NAME_ENTER
argument_list|(
literal|"sfntName"
argument_list|)
expr_stmt|;
if|if
condition|(
name|name_index
operator|<
name|min_index
operator|||
name|max_index
operator|<
name|name_index
condition|)
name|FT_INVALID_FORMAT
expr_stmt|;
name|nnames
operator|=
name|FT_Get_Sfnt_Name_Count
argument_list|(
name|valid
operator|->
name|face
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nnames
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|FT_Get_Sfnt_Name
argument_list|(
name|valid
operator|->
name|face
argument_list|,
name|i
argument_list|,
operator|&
name|name
argument_list|)
operator|!=
name|FT_Err_Ok
condition|)
continue|continue ;
if|if
condition|(
name|name
operator|.
name|name_id
operator|==
name|name_index
condition|)
goto|goto
name|Out
goto|;
block|}
name|GXV_TRACE
argument_list|(
operator|(
literal|"  nameIndex = %d (UNTITLED)\n"
operator|,
name|name_index
operator|)
argument_list|)
expr_stmt|;
name|FT_INVALID_DATA
expr_stmt|;
goto|goto
name|Exit
goto|;
comment|/* make compiler happy */
name|Out
label|:
name|FT_TRACE1
argument_list|(
operator|(
literal|"  nameIndex = %d ("
operator|,
name|name_index
operator|)
argument_list|)
expr_stmt|;
name|GXV_TRACE_HEXDUMP_SFNTNAME
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|FT_TRACE1
argument_list|(
operator|(
literal|")\n"
operator|)
argument_list|)
expr_stmt|;
name|Exit
label|:
name|GXV_EXIT
expr_stmt|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****                          STATE TABLE                          *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/* -------------------------- Class Table --------------------------- */
end_comment
begin_comment
comment|/*    * highestClass specifies how many classes are defined in this    * Class Subtable.  Apple spec does not mention whether undefined    * holes in the class (e.g.: 0-3 are predefined, 4 is unused, 5 is used)    * are permitted.  At present, holes in a defined class are not checked.    *   -- suzuki toshiya<mpsuzuki@hiroshima-u.ac.jp>    */
end_comment
begin_function
specifier|static
name|void
DECL|function|gxv_ClassTable_validate
name|gxv_ClassTable_validate
parameter_list|(
name|FT_Bytes
name|table
parameter_list|,
name|FT_UShort
modifier|*
name|length_p
parameter_list|,
name|FT_UShort
name|stateSize
parameter_list|,
name|FT_Byte
modifier|*
name|maxClassID_p
parameter_list|,
name|GXV_Validator
name|valid
parameter_list|)
block|{
name|FT_Bytes
name|p
init|=
name|table
decl_stmt|;
name|FT_Bytes
name|limit
init|=
name|table
operator|+
operator|*
name|length_p
decl_stmt|;
name|FT_UShort
name|firstGlyph
decl_stmt|;
name|FT_UShort
name|nGlyphs
decl_stmt|;
name|GXV_NAME_ENTER
argument_list|(
literal|"ClassTable"
argument_list|)
expr_stmt|;
operator|*
name|maxClassID_p
operator|=
literal|3
expr_stmt|;
comment|/* Classes 0, 2, and 3 are predefined */
name|GXV_LIMIT_CHECK
argument_list|(
literal|2
operator|+
literal|2
argument_list|)
expr_stmt|;
name|firstGlyph
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|nGlyphs
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|GXV_TRACE
argument_list|(
operator|(
literal|" (firstGlyph = %d, nGlyphs = %d)\n"
operator|,
name|firstGlyph
operator|,
name|nGlyphs
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nGlyphs
condition|)
goto|goto
name|Out
goto|;
name|gxv_glyphid_validate
argument_list|(
call|(
name|FT_UShort
call|)
argument_list|(
name|firstGlyph
operator|+
name|nGlyphs
argument_list|)
argument_list|,
name|valid
argument_list|)
expr_stmt|;
block|{
name|FT_Byte
name|nGlyphInClass
index|[
literal|256
index|]
decl_stmt|;
name|FT_Byte
name|classID
decl_stmt|;
name|FT_UShort
name|i
decl_stmt|;
name|ft_memset
argument_list|(
name|nGlyphInClass
argument_list|,
literal|0
argument_list|,
literal|256
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nGlyphs
condition|;
name|i
operator|++
control|)
block|{
name|GXV_LIMIT_CHECK
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|classID
operator|=
name|FT_NEXT_BYTE
argument_list|(
name|p
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|classID
condition|)
block|{
comment|/* following classes should not appear in class array */
case|case
literal|0
case|:
comment|/* end of text */
case|case
literal|2
case|:
comment|/* out of bounds */
case|case
literal|3
case|:
comment|/* end of line */
name|FT_INVALID_DATA
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* out of bounds */
default|default:
comment|/* user-defined: 4 - ( stateSize - 1 ) */
if|if
condition|(
name|classID
operator|>=
name|stateSize
condition|)
name|FT_INVALID_DATA
expr_stmt|;
comment|/* assign glyph to undefined state */
name|nGlyphInClass
index|[
name|classID
index|]
operator|++
expr_stmt|;
break|break;
block|}
block|}
operator|*
name|length_p
operator|=
call|(
name|FT_UShort
call|)
argument_list|(
name|p
operator|-
name|table
argument_list|)
expr_stmt|;
comment|/* scan max ClassID in use */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|stateSize
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
literal|3
operator|<
name|i
operator|)
operator|&&
operator|(
name|nGlyphInClass
index|[
name|i
index|]
operator|>
literal|0
operator|)
condition|)
operator|*
name|maxClassID_p
operator|=
operator|(
name|FT_Byte
operator|)
name|i
expr_stmt|;
comment|/* XXX: Check Range? */
block|}
name|Out
label|:
name|GXV_TRACE
argument_list|(
operator|(
literal|"Declared stateSize=0x%02x, Used maxClassID=0x%02x\n"
operator|,
name|stateSize
operator|,
operator|*
name|maxClassID_p
operator|)
argument_list|)
expr_stmt|;
name|GXV_EXIT
expr_stmt|;
block|}
end_function
begin_comment
comment|/* --------------------------- State Array ----------------------------- */
end_comment
begin_function
specifier|static
name|void
DECL|function|gxv_StateArray_validate
name|gxv_StateArray_validate
parameter_list|(
name|FT_Bytes
name|table
parameter_list|,
name|FT_UShort
modifier|*
name|length_p
parameter_list|,
name|FT_Byte
name|maxClassID
parameter_list|,
name|FT_UShort
name|stateSize
parameter_list|,
name|FT_Byte
modifier|*
name|maxState_p
parameter_list|,
name|FT_Byte
modifier|*
name|maxEntry_p
parameter_list|,
name|GXV_Validator
name|valid
parameter_list|)
block|{
name|FT_Bytes
name|p
init|=
name|table
decl_stmt|;
name|FT_Bytes
name|limit
init|=
name|table
operator|+
operator|*
name|length_p
decl_stmt|;
name|FT_Byte
name|clazz
decl_stmt|;
name|FT_Byte
name|entry
decl_stmt|;
name|FT_UNUSED
argument_list|(
name|stateSize
argument_list|)
expr_stmt|;
comment|/* for the non-debugging case */
name|GXV_NAME_ENTER
argument_list|(
literal|"StateArray"
argument_list|)
expr_stmt|;
name|GXV_TRACE
argument_list|(
operator|(
literal|"parse %d bytes by stateSize=%d maxClassID=%d\n"
operator|,
call|(
name|int
call|)
argument_list|(
operator|*
name|length_p
argument_list|)
operator|,
name|stateSize
operator|,
call|(
name|int
call|)
argument_list|(
name|maxClassID
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/*      * 2 states are predefined and must be described in StateArray:      * state 0 (start of text), 1 (start of line)      */
name|GXV_LIMIT_CHECK
argument_list|(
operator|(
literal|1
operator|+
name|maxClassID
operator|)
operator|*
literal|2
argument_list|)
expr_stmt|;
operator|*
name|maxState_p
operator|=
literal|0
expr_stmt|;
operator|*
name|maxEntry_p
operator|=
literal|0
expr_stmt|;
comment|/* read if enough to read another state */
while|while
condition|(
name|p
operator|+
operator|(
literal|1
operator|+
name|maxClassID
operator|)
operator|<=
name|limit
condition|)
block|{
operator|(
operator|*
name|maxState_p
operator|)
operator|++
expr_stmt|;
for|for
control|(
name|clazz
operator|=
literal|0
init|;
name|clazz
operator|<=
name|maxClassID
condition|;
name|clazz
operator|++
control|)
block|{
name|entry
operator|=
name|FT_NEXT_BYTE
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|*
name|maxEntry_p
operator|=
operator|(
name|FT_Byte
operator|)
name|FT_MAX
argument_list|(
operator|*
name|maxEntry_p
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
block|}
name|GXV_TRACE
argument_list|(
operator|(
literal|"parsed: maxState=%d, maxEntry=%d\n"
operator|,
operator|*
name|maxState_p
operator|,
operator|*
name|maxEntry_p
operator|)
argument_list|)
expr_stmt|;
operator|*
name|length_p
operator|=
call|(
name|FT_UShort
call|)
argument_list|(
name|p
operator|-
name|table
argument_list|)
expr_stmt|;
name|GXV_EXIT
expr_stmt|;
block|}
end_function
begin_comment
comment|/* --------------------------- Entry Table ----------------------------- */
end_comment
begin_function
specifier|static
name|void
DECL|function|gxv_EntryTable_validate
name|gxv_EntryTable_validate
parameter_list|(
name|FT_Bytes
name|table
parameter_list|,
name|FT_UShort
modifier|*
name|length_p
parameter_list|,
name|FT_Byte
name|maxEntry
parameter_list|,
name|FT_UShort
name|stateArray
parameter_list|,
name|FT_UShort
name|stateArray_length
parameter_list|,
name|FT_Byte
name|maxClassID
parameter_list|,
name|FT_Bytes
name|statetable_table
parameter_list|,
name|FT_Bytes
name|statetable_limit
parameter_list|,
name|GXV_Validator
name|valid
parameter_list|)
block|{
name|FT_Bytes
name|p
init|=
name|table
decl_stmt|;
name|FT_Bytes
name|limit
init|=
name|table
operator|+
operator|*
name|length_p
decl_stmt|;
name|FT_Byte
name|entry
decl_stmt|;
name|FT_Byte
name|state
decl_stmt|;
name|FT_Int
name|entrySize
init|=
literal|2
operator|+
literal|2
operator|+
name|GXV_GLYPHOFFSET_SIZE
argument_list|(
name|statetable
argument_list|)
decl_stmt|;
name|GXV_XStateTable_GlyphOffsetDesc
name|glyphOffset
decl_stmt|;
name|GXV_NAME_ENTER
argument_list|(
literal|"EntryTable"
argument_list|)
expr_stmt|;
name|GXV_TRACE
argument_list|(
operator|(
literal|"maxEntry=%d entrySize=%d\n"
operator|,
name|maxEntry
operator|,
name|entrySize
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|maxEntry
operator|+
literal|1
operator|)
operator|*
name|entrySize
operator|>
operator|*
name|length_p
condition|)
block|{
if|if
condition|(
name|valid
operator|->
name|root
operator|->
name|level
operator|>=
name|FT_VALIDATE_PARANOID
condition|)
name|FT_INVALID_TOO_SHORT
expr_stmt|;
comment|/* ftxvalidator and FontValidator both warn and continue */
name|maxEntry
operator|=
call|(
name|FT_Byte
call|)
argument_list|(
operator|*
name|length_p
operator|/
name|entrySize
operator|-
literal|1
argument_list|)
expr_stmt|;
name|GXV_TRACE
argument_list|(
operator|(
literal|"too large maxEntry, shrinking to %d fit EntryTable length\n"
operator|,
name|maxEntry
operator|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|entry
operator|=
literal|0
init|;
name|entry
operator|<=
name|maxEntry
condition|;
name|entry
operator|++
control|)
block|{
name|FT_UShort
name|newState
decl_stmt|;
name|FT_UShort
name|flags
decl_stmt|;
name|GXV_LIMIT_CHECK
argument_list|(
literal|2
operator|+
literal|2
argument_list|)
expr_stmt|;
name|newState
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|flags
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|newState
operator|<
name|stateArray
operator|||
name|stateArray
operator|+
name|stateArray_length
operator|<
name|newState
condition|)
block|{
name|GXV_TRACE
argument_list|(
operator|(
literal|" newState offset 0x%04x is out of stateArray\n"
operator|,
name|newState
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|valid
operator|->
name|root
operator|->
name|level
operator|>=
name|FT_VALIDATE_PARANOID
condition|)
name|FT_INVALID_OFFSET
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
literal|0
operator|!=
operator|(
operator|(
name|newState
operator|-
name|stateArray
operator|)
operator|%
operator|(
literal|1
operator|+
name|maxClassID
operator|)
operator|)
condition|)
block|{
name|GXV_TRACE
argument_list|(
operator|(
literal|" newState offset 0x%04x is not aligned to %d-classes\n"
operator|,
name|newState
operator|,
literal|1
operator|+
name|maxClassID
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|valid
operator|->
name|root
operator|->
name|level
operator|>=
name|FT_VALIDATE_PARANOID
condition|)
name|FT_INVALID_OFFSET
expr_stmt|;
continue|continue;
block|}
name|state
operator|=
call|(
name|FT_Byte
call|)
argument_list|(
operator|(
name|newState
operator|-
name|stateArray
operator|)
operator|/
operator|(
literal|1
operator|+
name|maxClassID
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GXV_GLYPHOFFSET_FMT
argument_list|(
name|statetable
argument_list|)
condition|)
block|{
case|case
name|GXV_GLYPHOFFSET_NONE
case|:
name|glyphOffset
operator|.
name|uc
operator|=
literal|0
expr_stmt|;
comment|/* make compiler happy */
break|break;
case|case
name|GXV_GLYPHOFFSET_UCHAR
case|:
name|glyphOffset
operator|.
name|uc
operator|=
name|FT_NEXT_BYTE
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|GXV_GLYPHOFFSET_CHAR
case|:
name|glyphOffset
operator|.
name|c
operator|=
name|FT_NEXT_CHAR
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|GXV_GLYPHOFFSET_USHORT
case|:
name|glyphOffset
operator|.
name|u
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|GXV_GLYPHOFFSET_SHORT
case|:
name|glyphOffset
operator|.
name|s
operator|=
name|FT_NEXT_SHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|GXV_GLYPHOFFSET_ULONG
case|:
name|glyphOffset
operator|.
name|ul
operator|=
name|FT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|GXV_GLYPHOFFSET_LONG
case|:
name|glyphOffset
operator|.
name|l
operator|=
name|FT_NEXT_LONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|valid
operator|->
name|root
operator|->
name|level
operator|>=
name|FT_VALIDATE_PARANOID
condition|)
name|FT_INVALID_FORMAT
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|NULL
operator|!=
name|valid
operator|->
name|statetable
operator|.
name|entry_validate_func
condition|)
name|valid
operator|->
name|statetable
operator|.
name|entry_validate_func
argument_list|(
name|state
argument_list|,
name|flags
argument_list|,
operator|&
name|glyphOffset
argument_list|,
name|statetable_table
argument_list|,
name|statetable_limit
argument_list|,
name|valid
argument_list|)
expr_stmt|;
block|}
name|Exit
label|:
operator|*
name|length_p
operator|=
call|(
name|FT_UShort
call|)
argument_list|(
name|p
operator|-
name|table
argument_list|)
expr_stmt|;
name|GXV_EXIT
expr_stmt|;
block|}
end_function
begin_comment
comment|/* =========================== State Table ============================= */
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|gxv_StateTable_subtable_setup
name|gxv_StateTable_subtable_setup
argument_list|(
argument|FT_UShort      table_size
argument_list|,
argument|FT_UShort      classTable
argument_list|,
argument|FT_UShort      stateArray
argument_list|,
argument|FT_UShort      entryTable
argument_list|,
argument|FT_UShort*     classTable_length_p
argument_list|,
argument|FT_UShort*     stateArray_length_p
argument_list|,
argument|FT_UShort*     entryTable_length_p
argument_list|,
argument|GXV_Validator  valid
argument_list|)
end_macro
begin_block
block|{
name|FT_UShort
name|o
index|[
literal|3
index|]
decl_stmt|;
name|FT_UShort
modifier|*
name|l
index|[
literal|3
index|]
decl_stmt|;
name|FT_UShort
name|buff
index|[
literal|4
index|]
decl_stmt|;
name|o
index|[
literal|0
index|]
operator|=
name|classTable
expr_stmt|;
name|o
index|[
literal|1
index|]
operator|=
name|stateArray
expr_stmt|;
name|o
index|[
literal|2
index|]
operator|=
name|entryTable
expr_stmt|;
name|l
index|[
literal|0
index|]
operator|=
name|classTable_length_p
expr_stmt|;
name|l
index|[
literal|1
index|]
operator|=
name|stateArray_length_p
expr_stmt|;
name|l
index|[
literal|2
index|]
operator|=
name|entryTable_length_p
expr_stmt|;
name|gxv_set_length_by_ushort_offset
argument_list|(
name|o
argument_list|,
name|l
argument_list|,
name|buff
argument_list|,
literal|3
argument_list|,
name|table_size
argument_list|,
name|valid
argument_list|)
expr_stmt|;
block|}
end_block
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|gxv_StateTable_validate
name|gxv_StateTable_validate
argument_list|(
argument|FT_Bytes       table
argument_list|,
argument|FT_Bytes       limit
argument_list|,
argument|GXV_Validator  valid
argument_list|)
end_macro
begin_block
block|{
name|FT_UShort
name|stateSize
decl_stmt|;
name|FT_UShort
name|classTable
decl_stmt|;
comment|/* offset to Class(Sub)Table */
name|FT_UShort
name|stateArray
decl_stmt|;
comment|/* offset to StateArray */
name|FT_UShort
name|entryTable
decl_stmt|;
comment|/* offset to EntryTable */
name|FT_UShort
name|classTable_length
decl_stmt|;
name|FT_UShort
name|stateArray_length
decl_stmt|;
name|FT_UShort
name|entryTable_length
decl_stmt|;
name|FT_Byte
name|maxClassID
decl_stmt|;
name|FT_Byte
name|maxState
decl_stmt|;
name|FT_Byte
name|maxEntry
decl_stmt|;
name|GXV_StateTable_Subtable_Setup_Func
name|setup_func
decl_stmt|;
name|FT_Bytes
name|p
init|=
name|table
decl_stmt|;
name|GXV_NAME_ENTER
argument_list|(
literal|"StateTable"
argument_list|)
expr_stmt|;
name|GXV_TRACE
argument_list|(
operator|(
literal|"StateTable header\n"
operator|)
argument_list|)
expr_stmt|;
name|GXV_LIMIT_CHECK
argument_list|(
literal|2
operator|+
literal|2
operator|+
literal|2
operator|+
literal|2
argument_list|)
expr_stmt|;
name|stateSize
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|classTable
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|stateArray
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|entryTable
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|GXV_TRACE
argument_list|(
operator|(
literal|"stateSize=0x%04x\n"
operator|,
name|stateSize
operator|)
argument_list|)
expr_stmt|;
name|GXV_TRACE
argument_list|(
operator|(
literal|"offset to classTable=0x%04x\n"
operator|,
name|classTable
operator|)
argument_list|)
expr_stmt|;
name|GXV_TRACE
argument_list|(
operator|(
literal|"offset to stateArray=0x%04x\n"
operator|,
name|stateArray
operator|)
argument_list|)
expr_stmt|;
name|GXV_TRACE
argument_list|(
operator|(
literal|"offset to entryTable=0x%04x\n"
operator|,
name|entryTable
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|stateSize
operator|>
literal|0xFF
condition|)
name|FT_INVALID_DATA
expr_stmt|;
if|if
condition|(
name|valid
operator|->
name|statetable
operator|.
name|optdata_load_func
operator|!=
name|NULL
condition|)
name|valid
operator|->
name|statetable
operator|.
name|optdata_load_func
argument_list|(
name|p
argument_list|,
name|limit
argument_list|,
name|valid
argument_list|)
expr_stmt|;
if|if
condition|(
name|valid
operator|->
name|statetable
operator|.
name|subtable_setup_func
operator|!=
name|NULL
condition|)
name|setup_func
operator|=
name|valid
operator|->
name|statetable
operator|.
name|subtable_setup_func
expr_stmt|;
else|else
name|setup_func
operator|=
name|gxv_StateTable_subtable_setup
expr_stmt|;
name|setup_func
argument_list|(
call|(
name|FT_UShort
call|)
argument_list|(
name|limit
operator|-
name|table
argument_list|)
argument_list|,
name|classTable
argument_list|,
name|stateArray
argument_list|,
name|entryTable
argument_list|,
operator|&
name|classTable_length
argument_list|,
operator|&
name|stateArray_length
argument_list|,
operator|&
name|entryTable_length
argument_list|,
name|valid
argument_list|)
expr_stmt|;
name|GXV_TRACE
argument_list|(
operator|(
literal|"StateTable Subtables\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|classTable
operator|!=
literal|0
condition|)
name|gxv_ClassTable_validate
argument_list|(
name|table
operator|+
name|classTable
argument_list|,
operator|&
name|classTable_length
argument_list|,
name|stateSize
argument_list|,
operator|&
name|maxClassID
argument_list|,
name|valid
argument_list|)
expr_stmt|;
else|else
name|maxClassID
operator|=
call|(
name|FT_Byte
call|)
argument_list|(
name|stateSize
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|stateArray
operator|!=
literal|0
condition|)
name|gxv_StateArray_validate
argument_list|(
name|table
operator|+
name|stateArray
argument_list|,
operator|&
name|stateArray_length
argument_list|,
name|maxClassID
argument_list|,
name|stateSize
argument_list|,
operator|&
name|maxState
argument_list|,
operator|&
name|maxEntry
argument_list|,
name|valid
argument_list|)
expr_stmt|;
else|else
block|{
name|maxState
operator|=
literal|1
expr_stmt|;
comment|/* 0:start of text, 1:start of line are predefined */
name|maxEntry
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|maxEntry
operator|>
literal|0
operator|&&
name|entryTable
operator|==
literal|0
condition|)
name|FT_INVALID_OFFSET
expr_stmt|;
if|if
condition|(
name|entryTable
operator|!=
literal|0
condition|)
name|gxv_EntryTable_validate
argument_list|(
name|table
operator|+
name|entryTable
argument_list|,
operator|&
name|entryTable_length
argument_list|,
name|maxEntry
argument_list|,
name|stateArray
argument_list|,
name|stateArray_length
argument_list|,
name|maxClassID
argument_list|,
name|table
argument_list|,
name|limit
argument_list|,
name|valid
argument_list|)
expr_stmt|;
name|GXV_EXIT
expr_stmt|;
block|}
end_block
begin_comment
comment|/* ================= eXtended State Table (for morx) =================== */
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|gxv_XStateTable_subtable_setup
name|gxv_XStateTable_subtable_setup
argument_list|(
argument|FT_ULong       table_size
argument_list|,
argument|FT_ULong       classTable
argument_list|,
argument|FT_ULong       stateArray
argument_list|,
argument|FT_ULong       entryTable
argument_list|,
argument|FT_ULong*      classTable_length_p
argument_list|,
argument|FT_ULong*      stateArray_length_p
argument_list|,
argument|FT_ULong*      entryTable_length_p
argument_list|,
argument|GXV_Validator  valid
argument_list|)
end_macro
begin_block
block|{
name|FT_ULong
name|o
index|[
literal|3
index|]
decl_stmt|;
name|FT_ULong
modifier|*
name|l
index|[
literal|3
index|]
decl_stmt|;
name|FT_ULong
name|buff
index|[
literal|4
index|]
decl_stmt|;
name|o
index|[
literal|0
index|]
operator|=
name|classTable
expr_stmt|;
name|o
index|[
literal|1
index|]
operator|=
name|stateArray
expr_stmt|;
name|o
index|[
literal|2
index|]
operator|=
name|entryTable
expr_stmt|;
name|l
index|[
literal|0
index|]
operator|=
name|classTable_length_p
expr_stmt|;
name|l
index|[
literal|1
index|]
operator|=
name|stateArray_length_p
expr_stmt|;
name|l
index|[
literal|2
index|]
operator|=
name|entryTable_length_p
expr_stmt|;
name|gxv_set_length_by_ulong_offset
argument_list|(
name|o
argument_list|,
name|l
argument_list|,
name|buff
argument_list|,
literal|4
argument_list|,
name|table_size
argument_list|,
name|valid
argument_list|)
expr_stmt|;
block|}
end_block
begin_function
specifier|static
name|void
DECL|function|gxv_XClassTable_lookupval_validate
name|gxv_XClassTable_lookupval_validate
parameter_list|(
name|FT_UShort
name|glyph
parameter_list|,
name|GXV_LookupValueCPtr
name|value_p
parameter_list|,
name|GXV_Validator
name|valid
parameter_list|)
block|{
name|FT_UNUSED
argument_list|(
name|glyph
argument_list|)
expr_stmt|;
if|if
condition|(
name|value_p
operator|->
name|u
operator|>=
name|valid
operator|->
name|xstatetable
operator|.
name|nClasses
condition|)
name|FT_INVALID_DATA
expr_stmt|;
if|if
condition|(
name|value_p
operator|->
name|u
operator|>
name|valid
operator|->
name|xstatetable
operator|.
name|maxClassID
condition|)
name|valid
operator|->
name|xstatetable
operator|.
name|maxClassID
operator|=
name|value_p
operator|->
name|u
expr_stmt|;
block|}
end_function
begin_comment
comment|/*     +===============+ --------+     | lookup header |         |     +===============+         |     | BinSrchHeader |         |     +===============+         |     | lastGlyph[0]  |         |     +---------------+         |     | firstGlyph[0] |         |    head of lookup table     +---------------+         |             +     | offset[0]     |    ->   |          offset            [byte]     +===============+         |             +     | lastGlyph[1]  |         | (glyphID - firstGlyph) * 2 [byte]     +---------------+         |     | firstGlyph[1] |         |     +---------------+         |     | offset[1]     |         |     +===============+         |                               |      ....                     |                               |     16bit value array         |     +===============+         |     |     value     |<-------+      ....   */
end_comment
begin_function
specifier|static
name|GXV_LookupValueDesc
DECL|function|gxv_XClassTable_lookupfmt4_transit
name|gxv_XClassTable_lookupfmt4_transit
parameter_list|(
name|FT_UShort
name|relative_gindex
parameter_list|,
name|GXV_LookupValueCPtr
name|base_value_p
parameter_list|,
name|FT_Bytes
name|lookuptbl_limit
parameter_list|,
name|GXV_Validator
name|valid
parameter_list|)
block|{
name|FT_Bytes
name|p
decl_stmt|;
name|FT_Bytes
name|limit
decl_stmt|;
name|FT_UShort
name|offset
decl_stmt|;
name|GXV_LookupValueDesc
name|value
decl_stmt|;
comment|/* XXX: check range? */
name|offset
operator|=
call|(
name|FT_UShort
call|)
argument_list|(
name|base_value_p
operator|->
name|u
operator|+
name|relative_gindex
operator|*
sizeof|sizeof
argument_list|(
name|FT_UShort
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|valid
operator|->
name|lookuptbl_head
operator|+
name|offset
expr_stmt|;
name|limit
operator|=
name|lookuptbl_limit
expr_stmt|;
name|GXV_LIMIT_CHECK
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|value
operator|.
name|u
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|gxv_XStateArray_validate
name|gxv_XStateArray_validate
parameter_list|(
name|FT_Bytes
name|table
parameter_list|,
name|FT_ULong
modifier|*
name|length_p
parameter_list|,
name|FT_UShort
name|maxClassID
parameter_list|,
name|FT_ULong
name|stateSize
parameter_list|,
name|FT_UShort
modifier|*
name|maxState_p
parameter_list|,
name|FT_UShort
modifier|*
name|maxEntry_p
parameter_list|,
name|GXV_Validator
name|valid
parameter_list|)
block|{
name|FT_Bytes
name|p
init|=
name|table
decl_stmt|;
name|FT_Bytes
name|limit
init|=
name|table
operator|+
operator|*
name|length_p
decl_stmt|;
name|FT_UShort
name|clazz
decl_stmt|;
name|FT_UShort
name|entry
decl_stmt|;
name|FT_UNUSED
argument_list|(
name|stateSize
argument_list|)
expr_stmt|;
comment|/* for the non-debugging case */
name|GXV_NAME_ENTER
argument_list|(
literal|"XStateArray"
argument_list|)
expr_stmt|;
name|GXV_TRACE
argument_list|(
operator|(
literal|"parse % 3d bytes by stateSize=% 3d maxClassID=% 3d\n"
operator|,
call|(
name|int
call|)
argument_list|(
operator|*
name|length_p
argument_list|)
operator|,
name|stateSize
operator|,
call|(
name|int
call|)
argument_list|(
name|maxClassID
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/*      * 2 states are predefined and must be described:      * state 0 (start of text), 1 (start of line)      */
name|GXV_LIMIT_CHECK
argument_list|(
operator|(
literal|1
operator|+
name|maxClassID
operator|)
operator|*
literal|2
operator|*
literal|2
argument_list|)
expr_stmt|;
operator|*
name|maxState_p
operator|=
literal|0
expr_stmt|;
operator|*
name|maxEntry_p
operator|=
literal|0
expr_stmt|;
comment|/* read if enough to read another state */
while|while
condition|(
name|p
operator|+
operator|(
operator|(
literal|1
operator|+
name|maxClassID
operator|)
operator|*
literal|2
operator|)
operator|<=
name|limit
condition|)
block|{
operator|(
operator|*
name|maxState_p
operator|)
operator|++
expr_stmt|;
for|for
control|(
name|clazz
operator|=
literal|0
init|;
name|clazz
operator|<=
name|maxClassID
condition|;
name|clazz
operator|++
control|)
block|{
name|entry
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|*
name|maxEntry_p
operator|=
operator|(
name|FT_UShort
operator|)
name|FT_MAX
argument_list|(
operator|*
name|maxEntry_p
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
block|}
name|GXV_TRACE
argument_list|(
operator|(
literal|"parsed: maxState=%d, maxEntry=%d\n"
operator|,
operator|*
name|maxState_p
operator|,
operator|*
name|maxEntry_p
operator|)
argument_list|)
expr_stmt|;
operator|*
name|length_p
operator|=
name|p
operator|-
name|table
expr_stmt|;
name|GXV_EXIT
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|gxv_XEntryTable_validate
name|gxv_XEntryTable_validate
parameter_list|(
name|FT_Bytes
name|table
parameter_list|,
name|FT_ULong
modifier|*
name|length_p
parameter_list|,
name|FT_UShort
name|maxEntry
parameter_list|,
name|FT_ULong
name|stateArray_length
parameter_list|,
name|FT_UShort
name|maxClassID
parameter_list|,
name|FT_Bytes
name|xstatetable_table
parameter_list|,
name|FT_Bytes
name|xstatetable_limit
parameter_list|,
name|GXV_Validator
name|valid
parameter_list|)
block|{
name|FT_Bytes
name|p
init|=
name|table
decl_stmt|;
name|FT_Bytes
name|limit
init|=
name|table
operator|+
operator|*
name|length_p
decl_stmt|;
name|FT_UShort
name|entry
decl_stmt|;
name|FT_UShort
name|state
decl_stmt|;
name|FT_Int
name|entrySize
init|=
literal|2
operator|+
literal|2
operator|+
name|GXV_GLYPHOFFSET_SIZE
argument_list|(
name|xstatetable
argument_list|)
decl_stmt|;
name|GXV_NAME_ENTER
argument_list|(
literal|"XEntryTable"
argument_list|)
expr_stmt|;
name|GXV_TRACE
argument_list|(
operator|(
literal|"maxEntry=%d entrySize=%d\n"
operator|,
name|maxEntry
operator|,
name|entrySize
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|+
operator|(
name|maxEntry
operator|+
literal|1
operator|)
operator|*
name|entrySize
operator|)
operator|>
name|limit
condition|)
name|FT_INVALID_TOO_SHORT
expr_stmt|;
for|for
control|(
name|entry
operator|=
literal|0
init|;
name|entry
operator|<=
name|maxEntry
condition|;
name|entry
operator|++
control|)
block|{
name|FT_UShort
name|newState_idx
decl_stmt|;
name|FT_UShort
name|flags
decl_stmt|;
name|GXV_XStateTable_GlyphOffsetDesc
name|glyphOffset
decl_stmt|;
name|GXV_LIMIT_CHECK
argument_list|(
literal|2
operator|+
literal|2
argument_list|)
expr_stmt|;
name|newState_idx
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|flags
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|stateArray_length
operator|<
call|(
name|FT_ULong
call|)
argument_list|(
name|newState_idx
operator|*
literal|2
argument_list|)
condition|)
block|{
name|GXV_TRACE
argument_list|(
operator|(
literal|"  newState index 0x%04x points out of stateArray\n"
operator|,
name|newState_idx
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|valid
operator|->
name|root
operator|->
name|level
operator|>=
name|FT_VALIDATE_PARANOID
condition|)
name|FT_INVALID_OFFSET
expr_stmt|;
block|}
name|state
operator|=
call|(
name|FT_UShort
call|)
argument_list|(
name|newState_idx
operator|/
operator|(
literal|1
operator|+
name|maxClassID
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|!=
operator|(
name|newState_idx
operator|%
operator|(
literal|1
operator|+
name|maxClassID
operator|)
operator|)
condition|)
block|{
name|FT_TRACE4
argument_list|(
operator|(
literal|"-> new state = %d (supposed)\n"
literal|"but newState index 0x%04x is not aligned to %d-classes\n"
operator|,
name|state
operator|,
name|newState_idx
operator|,
literal|1
operator|+
name|maxClassID
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|valid
operator|->
name|root
operator|->
name|level
operator|>=
name|FT_VALIDATE_PARANOID
condition|)
name|FT_INVALID_OFFSET
expr_stmt|;
block|}
switch|switch
condition|(
name|GXV_GLYPHOFFSET_FMT
argument_list|(
name|xstatetable
argument_list|)
condition|)
block|{
case|case
name|GXV_GLYPHOFFSET_NONE
case|:
name|glyphOffset
operator|.
name|uc
operator|=
literal|0
expr_stmt|;
comment|/* make compiler happy */
break|break;
case|case
name|GXV_GLYPHOFFSET_UCHAR
case|:
name|glyphOffset
operator|.
name|uc
operator|=
name|FT_NEXT_BYTE
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|GXV_GLYPHOFFSET_CHAR
case|:
name|glyphOffset
operator|.
name|c
operator|=
name|FT_NEXT_CHAR
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|GXV_GLYPHOFFSET_USHORT
case|:
name|glyphOffset
operator|.
name|u
operator|=
name|FT_NEXT_USHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|GXV_GLYPHOFFSET_SHORT
case|:
name|glyphOffset
operator|.
name|s
operator|=
name|FT_NEXT_SHORT
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|GXV_GLYPHOFFSET_ULONG
case|:
name|glyphOffset
operator|.
name|ul
operator|=
name|FT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|GXV_GLYPHOFFSET_LONG
case|:
name|glyphOffset
operator|.
name|l
operator|=
name|FT_NEXT_LONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|valid
operator|->
name|root
operator|->
name|level
operator|>=
name|FT_VALIDATE_PARANOID
condition|)
name|FT_INVALID_FORMAT
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|NULL
operator|!=
name|valid
operator|->
name|xstatetable
operator|.
name|entry_validate_func
condition|)
name|valid
operator|->
name|xstatetable
operator|.
name|entry_validate_func
argument_list|(
name|state
argument_list|,
name|flags
argument_list|,
operator|&
name|glyphOffset
argument_list|,
name|xstatetable_table
argument_list|,
name|xstatetable_limit
argument_list|,
name|valid
argument_list|)
expr_stmt|;
block|}
name|Exit
label|:
operator|*
name|length_p
operator|=
name|p
operator|-
name|table
expr_stmt|;
name|GXV_EXIT
expr_stmt|;
block|}
end_function
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|gxv_XStateTable_validate
name|gxv_XStateTable_validate
argument_list|(
argument|FT_Bytes       table
argument_list|,
argument|FT_Bytes       limit
argument_list|,
argument|GXV_Validator  valid
argument_list|)
end_macro
begin_block
block|{
comment|/* StateHeader members */
name|FT_ULong
name|classTable
decl_stmt|;
comment|/* offset to Class(Sub)Table */
name|FT_ULong
name|stateArray
decl_stmt|;
comment|/* offset to StateArray */
name|FT_ULong
name|entryTable
decl_stmt|;
comment|/* offset to EntryTable */
name|FT_ULong
name|classTable_length
decl_stmt|;
name|FT_ULong
name|stateArray_length
decl_stmt|;
name|FT_ULong
name|entryTable_length
decl_stmt|;
name|FT_UShort
name|maxState
decl_stmt|;
name|FT_UShort
name|maxEntry
decl_stmt|;
name|GXV_XStateTable_Subtable_Setup_Func
name|setup_func
decl_stmt|;
name|FT_Bytes
name|p
init|=
name|table
decl_stmt|;
name|GXV_NAME_ENTER
argument_list|(
literal|"XStateTable"
argument_list|)
expr_stmt|;
name|GXV_TRACE
argument_list|(
operator|(
literal|"XStateTable header\n"
operator|)
argument_list|)
expr_stmt|;
name|GXV_LIMIT_CHECK
argument_list|(
literal|4
operator|+
literal|4
operator|+
literal|4
operator|+
literal|4
argument_list|)
expr_stmt|;
name|valid
operator|->
name|xstatetable
operator|.
name|nClasses
operator|=
name|FT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|classTable
operator|=
name|FT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|stateArray
operator|=
name|FT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|entryTable
operator|=
name|FT_NEXT_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|GXV_TRACE
argument_list|(
operator|(
literal|"nClasses =0x%08x\n"
operator|,
name|valid
operator|->
name|xstatetable
operator|.
name|nClasses
operator|)
argument_list|)
expr_stmt|;
name|GXV_TRACE
argument_list|(
operator|(
literal|"offset to classTable=0x%08x\n"
operator|,
name|classTable
operator|)
argument_list|)
expr_stmt|;
name|GXV_TRACE
argument_list|(
operator|(
literal|"offset to stateArray=0x%08x\n"
operator|,
name|stateArray
operator|)
argument_list|)
expr_stmt|;
name|GXV_TRACE
argument_list|(
operator|(
literal|"offset to entryTable=0x%08x\n"
operator|,
name|entryTable
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|valid
operator|->
name|xstatetable
operator|.
name|nClasses
operator|>
literal|0xFFFFU
condition|)
name|FT_INVALID_DATA
expr_stmt|;
name|GXV_TRACE
argument_list|(
operator|(
literal|"StateTable Subtables\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|valid
operator|->
name|xstatetable
operator|.
name|optdata_load_func
operator|!=
name|NULL
condition|)
name|valid
operator|->
name|xstatetable
operator|.
name|optdata_load_func
argument_list|(
name|p
argument_list|,
name|limit
argument_list|,
name|valid
argument_list|)
expr_stmt|;
if|if
condition|(
name|valid
operator|->
name|xstatetable
operator|.
name|subtable_setup_func
operator|!=
name|NULL
condition|)
name|setup_func
operator|=
name|valid
operator|->
name|xstatetable
operator|.
name|subtable_setup_func
expr_stmt|;
else|else
name|setup_func
operator|=
name|gxv_XStateTable_subtable_setup
expr_stmt|;
name|setup_func
argument_list|(
name|limit
operator|-
name|table
argument_list|,
name|classTable
argument_list|,
name|stateArray
argument_list|,
name|entryTable
argument_list|,
operator|&
name|classTable_length
argument_list|,
operator|&
name|stateArray_length
argument_list|,
operator|&
name|entryTable_length
argument_list|,
name|valid
argument_list|)
expr_stmt|;
if|if
condition|(
name|classTable
operator|!=
literal|0
condition|)
block|{
name|valid
operator|->
name|xstatetable
operator|.
name|maxClassID
operator|=
literal|0
expr_stmt|;
name|valid
operator|->
name|lookupval_sign
operator|=
name|GXV_LOOKUPVALUE_UNSIGNED
expr_stmt|;
name|valid
operator|->
name|lookupval_func
operator|=
name|gxv_XClassTable_lookupval_validate
expr_stmt|;
name|valid
operator|->
name|lookupfmt4_trans
operator|=
name|gxv_XClassTable_lookupfmt4_transit
expr_stmt|;
name|gxv_LookupTable_validate
argument_list|(
name|table
operator|+
name|classTable
argument_list|,
name|table
operator|+
name|classTable
operator|+
name|classTable_length
argument_list|,
name|valid
argument_list|)
expr_stmt|;
if|if
condition|(
name|valid
operator|->
name|subtable_length
operator|<
name|classTable_length
condition|)
name|classTable_length
operator|=
name|valid
operator|->
name|subtable_length
expr_stmt|;
block|}
else|else
block|{
comment|/* XXX: check range? */
name|valid
operator|->
name|xstatetable
operator|.
name|maxClassID
operator|=
call|(
name|FT_UShort
call|)
argument_list|(
name|valid
operator|->
name|xstatetable
operator|.
name|nClasses
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stateArray
operator|!=
literal|0
condition|)
name|gxv_XStateArray_validate
argument_list|(
name|table
operator|+
name|stateArray
argument_list|,
operator|&
name|stateArray_length
argument_list|,
name|valid
operator|->
name|xstatetable
operator|.
name|maxClassID
argument_list|,
name|valid
operator|->
name|xstatetable
operator|.
name|nClasses
argument_list|,
operator|&
name|maxState
argument_list|,
operator|&
name|maxEntry
argument_list|,
name|valid
argument_list|)
expr_stmt|;
else|else
block|{
name|maxState
operator|=
literal|1
expr_stmt|;
comment|/* 0:start of text, 1:start of line are predefined */
name|maxEntry
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|maxEntry
operator|>
literal|0
operator|&&
name|entryTable
operator|==
literal|0
condition|)
name|FT_INVALID_OFFSET
expr_stmt|;
if|if
condition|(
name|entryTable
operator|!=
literal|0
condition|)
name|gxv_XEntryTable_validate
argument_list|(
name|table
operator|+
name|entryTable
argument_list|,
operator|&
name|entryTable_length
argument_list|,
name|maxEntry
argument_list|,
name|stateArray_length
argument_list|,
name|valid
operator|->
name|xstatetable
operator|.
name|maxClassID
argument_list|,
name|table
argument_list|,
name|limit
argument_list|,
name|valid
argument_list|)
expr_stmt|;
name|GXV_EXIT
expr_stmt|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****                        Table overlapping                      *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_function
specifier|static
name|int
DECL|function|gxv_compare_ranges
name|gxv_compare_ranges
parameter_list|(
name|FT_Bytes
name|table1_start
parameter_list|,
name|FT_ULong
name|table1_length
parameter_list|,
name|FT_Bytes
name|table2_start
parameter_list|,
name|FT_ULong
name|table2_length
parameter_list|)
block|{
if|if
condition|(
name|table1_start
operator|==
name|table2_start
condition|)
block|{
if|if
condition|(
operator|(
name|table1_length
operator|==
literal|0
operator|||
name|table2_length
operator|==
literal|0
operator|)
condition|)
goto|goto
name|Out
goto|;
block|}
elseif|else
if|if
condition|(
name|table1_start
operator|<
name|table2_start
condition|)
block|{
if|if
condition|(
operator|(
name|table1_start
operator|+
name|table1_length
operator|)
operator|<=
name|table2_start
condition|)
goto|goto
name|Out
goto|;
block|}
elseif|else
if|if
condition|(
name|table1_start
operator|>
name|table2_start
condition|)
block|{
if|if
condition|(
operator|(
name|table1_start
operator|>=
name|table2_start
operator|+
name|table2_length
operator|)
condition|)
goto|goto
name|Out
goto|;
block|}
return|return
literal|1
return|;
name|Out
label|:
return|return
literal|0
return|;
block|}
end_function
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|gxv_odtect_add_range
name|gxv_odtect_add_range
argument_list|(
argument|FT_Bytes          start
argument_list|,
argument|FT_ULong          length
argument_list|,
argument|const FT_String*  name
argument_list|,
argument|GXV_odtect_Range  odtect
argument_list|)
end_macro
begin_block
block|{
name|odtect
operator|->
name|range
index|[
name|odtect
operator|->
name|nRanges
index|]
operator|.
name|start
operator|=
name|start
expr_stmt|;
name|odtect
operator|->
name|range
index|[
name|odtect
operator|->
name|nRanges
index|]
operator|.
name|length
operator|=
name|length
expr_stmt|;
name|odtect
operator|->
name|range
index|[
name|odtect
operator|->
name|nRanges
index|]
operator|.
name|name
operator|=
operator|(
name|FT_String
operator|*
operator|)
name|name
expr_stmt|;
name|odtect
operator|->
name|nRanges
operator|++
expr_stmt|;
block|}
end_block
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|gxv_odtect_validate
name|gxv_odtect_validate
argument_list|(
argument|GXV_odtect_Range  odtect
argument_list|,
argument|GXV_Validator     valid
argument_list|)
end_macro
begin_block
block|{
name|FT_UInt
name|i
decl_stmt|,
name|j
decl_stmt|;
name|GXV_NAME_ENTER
argument_list|(
literal|"check overlap among multi ranges"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|odtect
operator|->
name|nRanges
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
if|if
condition|(
literal|0
operator|!=
name|gxv_compare_ranges
argument_list|(
name|odtect
operator|->
name|range
index|[
name|i
index|]
operator|.
name|start
argument_list|,
name|odtect
operator|->
name|range
index|[
name|i
index|]
operator|.
name|length
argument_list|,
name|odtect
operator|->
name|range
index|[
name|j
index|]
operator|.
name|start
argument_list|,
name|odtect
operator|->
name|range
index|[
name|j
index|]
operator|.
name|length
argument_list|)
condition|)
block|{
if|if
condition|(
name|odtect
operator|->
name|range
index|[
name|i
index|]
operator|.
name|name
operator|||
name|odtect
operator|->
name|range
index|[
name|j
index|]
operator|.
name|name
condition|)
name|GXV_TRACE
argument_list|(
operator|(
literal|"found overlap between range %d and range %d\n"
operator|,
name|i
operator|,
name|j
operator|)
argument_list|)
expr_stmt|;
else|else
name|GXV_TRACE
argument_list|(
operator|(
literal|"found overlap between `%s' and `%s\'\n"
operator|,
name|odtect
operator|->
name|range
index|[
name|i
index|]
operator|.
name|name
operator|,
name|odtect
operator|->
name|range
index|[
name|j
index|]
operator|.
name|name
operator|)
argument_list|)
expr_stmt|;
name|FT_INVALID_OFFSET
expr_stmt|;
block|}
name|GXV_EXIT
expr_stmt|;
block|}
end_block
begin_comment
comment|/* END */
end_comment
end_unit
