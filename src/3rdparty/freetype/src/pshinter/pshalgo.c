begin_unit
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  pshalgo.c                                                              */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*    PostScript hinting algorithm (body).                                 */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  Copyright 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 by      */
end_comment
begin_comment
comment|/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  This file is part of the FreeType project, and may only be used        */
end_comment
begin_comment
comment|/*  modified and distributed under the terms of the FreeType project       */
end_comment
begin_comment
comment|/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
end_comment
begin_comment
comment|/*  this file you indicate that you have read the license and              */
end_comment
begin_comment
comment|/*  understand and accept it fully.                                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<ft2build.h>
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_OBJECTS_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_DEBUG_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_CALC_H
end_include
begin_include
include|#
directive|include
file|"pshalgo.h"
end_include
begin_include
include|#
directive|include
file|"pshnterr.h"
end_include
begin_undef
DECL|macro|FT_COMPONENT
undef|#
directive|undef
name|FT_COMPONENT
end_undef
begin_define
DECL|macro|FT_COMPONENT
define|#
directive|define
name|FT_COMPONENT
value|trace_pshalgo2
end_define
begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG_HINTER
end_ifdef
begin_decl_stmt
DECL|variable|ps_debug_hint_table
name|PSH_Hint_Table
name|ps_debug_hint_table
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|ps_debug_hint_func
name|PSH_HintFunc
name|ps_debug_hint_func
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|ps_debug_glyph
name|PSH_Glyph
name|ps_debug_glyph
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|COMPUTE_INFLEXS
define|#
directive|define
name|COMPUTE_INFLEXS
end_define
begin_comment
DECL|macro|COMPUTE_INFLEXS
comment|/* compute inflection points to optimize `S' */
end_comment
begin_comment
comment|/* and similar glyphs                        */
end_comment
begin_define
DECL|macro|STRONGER
define|#
directive|define
name|STRONGER
end_define
begin_comment
DECL|macro|STRONGER
comment|/* slightly increase the contrast of smooth  */
end_comment
begin_comment
comment|/* hinting                                   */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****                  BASIC HINTS RECORDINGS                       *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/* return true if two stem hints overlap */
end_comment
begin_function
specifier|static
name|FT_Int
DECL|function|psh_hint_overlap
name|psh_hint_overlap
parameter_list|(
name|PSH_Hint
name|hint1
parameter_list|,
name|PSH_Hint
name|hint2
parameter_list|)
block|{
return|return
name|hint1
operator|->
name|org_pos
operator|+
name|hint1
operator|->
name|org_len
operator|>=
name|hint2
operator|->
name|org_pos
operator|&&
name|hint2
operator|->
name|org_pos
operator|+
name|hint2
operator|->
name|org_len
operator|>=
name|hint1
operator|->
name|org_pos
return|;
block|}
end_function
begin_comment
comment|/* destroy hints table */
end_comment
begin_function
specifier|static
name|void
DECL|function|psh_hint_table_done
name|psh_hint_table_done
parameter_list|(
name|PSH_Hint_Table
name|table
parameter_list|,
name|FT_Memory
name|memory
parameter_list|)
block|{
name|FT_FREE
argument_list|(
name|table
operator|->
name|zones
argument_list|)
expr_stmt|;
name|table
operator|->
name|num_zones
operator|=
literal|0
expr_stmt|;
name|table
operator|->
name|zone
operator|=
literal|0
expr_stmt|;
name|FT_FREE
argument_list|(
name|table
operator|->
name|sort
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|table
operator|->
name|hints
argument_list|)
expr_stmt|;
name|table
operator|->
name|num_hints
operator|=
literal|0
expr_stmt|;
name|table
operator|->
name|max_hints
operator|=
literal|0
expr_stmt|;
name|table
operator|->
name|sort_global
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_comment
comment|/* deactivate all hints in a table */
end_comment
begin_function
specifier|static
name|void
DECL|function|psh_hint_table_deactivate
name|psh_hint_table_deactivate
parameter_list|(
name|PSH_Hint_Table
name|table
parameter_list|)
block|{
name|FT_UInt
name|count
init|=
name|table
operator|->
name|max_hints
decl_stmt|;
name|PSH_Hint
name|hint
init|=
name|table
operator|->
name|hints
decl_stmt|;
for|for
control|(
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
operator|,
name|hint
operator|++
control|)
block|{
name|psh_hint_deactivate
argument_list|(
name|hint
argument_list|)
expr_stmt|;
name|hint
operator|->
name|order
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/* internal function to record a new hint */
end_comment
begin_function
specifier|static
name|void
DECL|function|psh_hint_table_record
name|psh_hint_table_record
parameter_list|(
name|PSH_Hint_Table
name|table
parameter_list|,
name|FT_UInt
name|idx
parameter_list|)
block|{
name|PSH_Hint
name|hint
init|=
name|table
operator|->
name|hints
operator|+
name|idx
decl_stmt|;
if|if
condition|(
name|idx
operator|>=
name|table
operator|->
name|max_hints
condition|)
block|{
name|FT_TRACE0
argument_list|(
operator|(
literal|"psh_hint_table_record: invalid hint index %d\n"
operator|,
name|idx
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* ignore active hints */
if|if
condition|(
name|psh_hint_is_active
argument_list|(
name|hint
argument_list|)
condition|)
return|return;
name|psh_hint_activate
argument_list|(
name|hint
argument_list|)
expr_stmt|;
comment|/* now scan the current active hint set to check */
comment|/* whether `hint' overlaps with another hint     */
block|{
name|PSH_Hint
modifier|*
name|sorted
init|=
name|table
operator|->
name|sort_global
decl_stmt|;
name|FT_UInt
name|count
init|=
name|table
operator|->
name|num_hints
decl_stmt|;
name|PSH_Hint
name|hint2
decl_stmt|;
name|hint
operator|->
name|parent
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
operator|,
name|sorted
operator|++
control|)
block|{
name|hint2
operator|=
name|sorted
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|psh_hint_overlap
argument_list|(
name|hint
argument_list|,
name|hint2
argument_list|)
condition|)
block|{
name|hint
operator|->
name|parent
operator|=
name|hint2
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|table
operator|->
name|num_hints
operator|<
name|table
operator|->
name|max_hints
condition|)
name|table
operator|->
name|sort_global
index|[
name|table
operator|->
name|num_hints
operator|++
index|]
operator|=
name|hint
expr_stmt|;
else|else
name|FT_TRACE0
argument_list|(
operator|(
literal|"psh_hint_table_record: too many sorted hints!  BUG!\n"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|psh_hint_table_record_mask
name|psh_hint_table_record_mask
parameter_list|(
name|PSH_Hint_Table
name|table
parameter_list|,
name|PS_Mask
name|hint_mask
parameter_list|)
block|{
name|FT_Int
name|mask
init|=
literal|0
decl_stmt|,
name|val
init|=
literal|0
decl_stmt|;
name|FT_Byte
modifier|*
name|cursor
init|=
name|hint_mask
operator|->
name|bytes
decl_stmt|;
name|FT_UInt
name|idx
decl_stmt|,
name|limit
decl_stmt|;
name|limit
operator|=
name|hint_mask
operator|->
name|num_bits
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|limit
condition|;
name|idx
operator|++
control|)
block|{
if|if
condition|(
name|mask
operator|==
literal|0
condition|)
block|{
name|val
operator|=
operator|*
name|cursor
operator|++
expr_stmt|;
name|mask
operator|=
literal|0x80
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|&
name|mask
condition|)
name|psh_hint_table_record
argument_list|(
name|table
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|mask
operator|>>=
literal|1
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/* create hints table */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|psh_hint_table_init
name|psh_hint_table_init
parameter_list|(
name|PSH_Hint_Table
name|table
parameter_list|,
name|PS_Hint_Table
name|hints
parameter_list|,
name|PS_Mask_Table
name|hint_masks
parameter_list|,
name|PS_Mask_Table
name|counter_masks
parameter_list|,
name|FT_Memory
name|memory
parameter_list|)
block|{
name|FT_UInt
name|count
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|FT_UNUSED
argument_list|(
name|counter_masks
argument_list|)
expr_stmt|;
name|count
operator|=
name|hints
operator|->
name|num_hints
expr_stmt|;
comment|/* allocate our tables */
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|table
operator|->
name|sort
argument_list|,
literal|2
operator|*
name|count
argument_list|)
operator|||
name|FT_NEW_ARRAY
argument_list|(
name|table
operator|->
name|hints
argument_list|,
name|count
argument_list|)
operator|||
name|FT_NEW_ARRAY
argument_list|(
name|table
operator|->
name|zones
argument_list|,
literal|2
operator|*
name|count
operator|+
literal|1
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|table
operator|->
name|max_hints
operator|=
name|count
expr_stmt|;
name|table
operator|->
name|sort_global
operator|=
name|table
operator|->
name|sort
operator|+
name|count
expr_stmt|;
name|table
operator|->
name|num_hints
operator|=
literal|0
expr_stmt|;
name|table
operator|->
name|num_zones
operator|=
literal|0
expr_stmt|;
name|table
operator|->
name|zone
operator|=
literal|0
expr_stmt|;
comment|/* initialize the `table->hints' array */
block|{
name|PSH_Hint
name|write
init|=
name|table
operator|->
name|hints
decl_stmt|;
name|PS_Hint
name|read
init|=
name|hints
operator|->
name|hints
decl_stmt|;
for|for
control|(
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
operator|,
name|write
operator|++
operator|,
name|read
operator|++
control|)
block|{
name|write
operator|->
name|org_pos
operator|=
name|read
operator|->
name|pos
expr_stmt|;
name|write
operator|->
name|org_len
operator|=
name|read
operator|->
name|len
expr_stmt|;
name|write
operator|->
name|flags
operator|=
name|read
operator|->
name|flags
expr_stmt|;
block|}
block|}
comment|/* we now need to determine the initial `parent' stems; first  */
comment|/* activate the hints that are given by the initial hint masks */
if|if
condition|(
name|hint_masks
condition|)
block|{
name|PS_Mask
name|mask
init|=
name|hint_masks
operator|->
name|masks
decl_stmt|;
name|count
operator|=
name|hint_masks
operator|->
name|num_masks
expr_stmt|;
name|table
operator|->
name|hint_masks
operator|=
name|hint_masks
expr_stmt|;
for|for
control|(
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
operator|,
name|mask
operator|++
control|)
name|psh_hint_table_record_mask
argument_list|(
name|table
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
comment|/* finally, do a linear parse in case some hints were left alone */
if|if
condition|(
name|table
operator|->
name|num_hints
operator|!=
name|table
operator|->
name|max_hints
condition|)
block|{
name|FT_UInt
name|idx
decl_stmt|;
name|FT_TRACE0
argument_list|(
operator|(
literal|"psh_hint_table_init: missing/incorrect hint masks\n"
operator|)
argument_list|)
expr_stmt|;
name|count
operator|=
name|table
operator|->
name|max_hints
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|count
condition|;
name|idx
operator|++
control|)
name|psh_hint_table_record
argument_list|(
name|table
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
name|Exit
label|:
return|return
name|error
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|psh_hint_table_activate_mask
name|psh_hint_table_activate_mask
parameter_list|(
name|PSH_Hint_Table
name|table
parameter_list|,
name|PS_Mask
name|hint_mask
parameter_list|)
block|{
name|FT_Int
name|mask
init|=
literal|0
decl_stmt|,
name|val
init|=
literal|0
decl_stmt|;
name|FT_Byte
modifier|*
name|cursor
init|=
name|hint_mask
operator|->
name|bytes
decl_stmt|;
name|FT_UInt
name|idx
decl_stmt|,
name|limit
decl_stmt|,
name|count
decl_stmt|;
name|limit
operator|=
name|hint_mask
operator|->
name|num_bits
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|psh_hint_table_deactivate
argument_list|(
name|table
argument_list|)
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|limit
condition|;
name|idx
operator|++
control|)
block|{
if|if
condition|(
name|mask
operator|==
literal|0
condition|)
block|{
name|val
operator|=
operator|*
name|cursor
operator|++
expr_stmt|;
name|mask
operator|=
literal|0x80
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|&
name|mask
condition|)
block|{
name|PSH_Hint
name|hint
init|=
operator|&
name|table
operator|->
name|hints
index|[
name|idx
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|psh_hint_is_active
argument_list|(
name|hint
argument_list|)
condition|)
block|{
name|FT_UInt
name|count2
decl_stmt|;
if|#
directive|if
literal|0
block|PSH_Hint*  sort = table->sort;           PSH_Hint   hint2;             for ( count2 = count; count2> 0; count2--, sort++ )           {             hint2 = sort[0];             if ( psh_hint_overlap( hint, hint2 ) )               FT_TRACE0(( "psh_hint_table_activate_mask:"                           " found overlapping hints\n" ))           }
else|#
directive|else
name|count2
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|count2
operator|==
literal|0
condition|)
block|{
name|psh_hint_activate
argument_list|(
name|hint
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<
name|table
operator|->
name|max_hints
condition|)
name|table
operator|->
name|sort
index|[
name|count
operator|++
index|]
operator|=
name|hint
expr_stmt|;
else|else
name|FT_TRACE0
argument_list|(
operator|(
literal|"psh_hint_tableactivate_mask:"
literal|" too many active hints\n"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|mask
operator|>>=
literal|1
expr_stmt|;
block|}
name|table
operator|->
name|num_hints
operator|=
name|count
expr_stmt|;
comment|/* now, sort the hints; they are guaranteed to not overlap */
comment|/* so we can compare their "org_pos" field directly        */
block|{
name|FT_Int
name|i1
decl_stmt|,
name|i2
decl_stmt|;
name|PSH_Hint
name|hint1
decl_stmt|,
name|hint2
decl_stmt|;
name|PSH_Hint
modifier|*
name|sort
init|=
name|table
operator|->
name|sort
decl_stmt|;
comment|/* a simple bubble sort will do, since in 99% of cases, the hints */
comment|/* will be already sorted -- and the sort will be linear          */
for|for
control|(
name|i1
operator|=
literal|1
init|;
name|i1
operator|<
operator|(
name|FT_Int
operator|)
name|count
condition|;
name|i1
operator|++
control|)
block|{
name|hint1
operator|=
name|sort
index|[
name|i1
index|]
expr_stmt|;
for|for
control|(
name|i2
operator|=
name|i1
operator|-
literal|1
init|;
name|i2
operator|>=
literal|0
condition|;
name|i2
operator|--
control|)
block|{
name|hint2
operator|=
name|sort
index|[
name|i2
index|]
expr_stmt|;
if|if
condition|(
name|hint2
operator|->
name|org_pos
operator|<
name|hint1
operator|->
name|org_pos
condition|)
break|break;
name|sort
index|[
name|i2
operator|+
literal|1
index|]
operator|=
name|hint2
expr_stmt|;
name|sort
index|[
name|i2
index|]
operator|=
name|hint1
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****               HINTS GRID-FITTING AND OPTIMIZATION             *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_if
if|#
directive|if
literal|1
end_if
begin_function
specifier|static
name|FT_Pos
DECL|function|psh_dimension_quantize_len
name|psh_dimension_quantize_len
parameter_list|(
name|PSH_Dimension
name|dim
parameter_list|,
name|FT_Pos
name|len
parameter_list|,
name|FT_Bool
name|do_snapping
parameter_list|)
block|{
if|if
condition|(
name|len
operator|<=
literal|64
condition|)
name|len
operator|=
literal|64
expr_stmt|;
else|else
block|{
name|FT_Pos
name|delta
init|=
name|len
operator|-
name|dim
operator|->
name|stdw
operator|.
name|widths
index|[
literal|0
index|]
operator|.
name|cur
decl_stmt|;
if|if
condition|(
name|delta
operator|<
literal|0
condition|)
name|delta
operator|=
operator|-
name|delta
expr_stmt|;
if|if
condition|(
name|delta
operator|<
literal|40
condition|)
block|{
name|len
operator|=
name|dim
operator|->
name|stdw
operator|.
name|widths
index|[
literal|0
index|]
operator|.
name|cur
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|48
condition|)
name|len
operator|=
literal|48
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|<
literal|3
operator|*
literal|64
condition|)
block|{
name|delta
operator|=
operator|(
name|len
operator|&
literal|63
operator|)
expr_stmt|;
name|len
operator|&=
operator|-
literal|64
expr_stmt|;
if|if
condition|(
name|delta
operator|<
literal|10
condition|)
name|len
operator|+=
name|delta
expr_stmt|;
elseif|else
if|if
condition|(
name|delta
operator|<
literal|32
condition|)
name|len
operator|+=
literal|10
expr_stmt|;
elseif|else
if|if
condition|(
name|delta
operator|<
literal|54
condition|)
name|len
operator|+=
literal|54
expr_stmt|;
else|else
name|len
operator|+=
name|delta
expr_stmt|;
block|}
else|else
name|len
operator|=
name|FT_PIX_ROUND
argument_list|(
name|len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|do_snapping
condition|)
name|len
operator|=
name|FT_PIX_ROUND
argument_list|(
name|len
argument_list|)
expr_stmt|;
return|return
name|len
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* 0 */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG_HINTER
end_ifdef
begin_function
specifier|static
name|void
DECL|function|ps_simple_scale
name|ps_simple_scale
parameter_list|(
name|PSH_Hint_Table
name|table
parameter_list|,
name|FT_Fixed
name|scale
parameter_list|,
name|FT_Fixed
name|delta
parameter_list|,
name|FT_Int
name|dimension
parameter_list|)
block|{
name|PSH_Hint
name|hint
decl_stmt|;
name|FT_UInt
name|count
decl_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|table
operator|->
name|max_hints
condition|;
name|count
operator|++
control|)
block|{
name|hint
operator|=
name|table
operator|->
name|hints
operator|+
name|count
expr_stmt|;
name|hint
operator|->
name|cur_pos
operator|=
name|FT_MulFix
argument_list|(
name|hint
operator|->
name|org_pos
argument_list|,
name|scale
argument_list|)
operator|+
name|delta
expr_stmt|;
name|hint
operator|->
name|cur_len
operator|=
name|FT_MulFix
argument_list|(
name|hint
operator|->
name|org_len
argument_list|,
name|scale
argument_list|)
expr_stmt|;
if|if
condition|(
name|ps_debug_hint_func
condition|)
name|ps_debug_hint_func
argument_list|(
name|hint
argument_list|,
name|dimension
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* DEBUG_HINTER */
end_comment
begin_function
specifier|static
name|FT_Fixed
DECL|function|psh_hint_snap_stem_side_delta
name|psh_hint_snap_stem_side_delta
parameter_list|(
name|FT_Fixed
name|pos
parameter_list|,
name|FT_Fixed
name|len
parameter_list|)
block|{
name|FT_Fixed
name|delta1
init|=
name|FT_PIX_ROUND
argument_list|(
name|pos
argument_list|)
operator|-
name|pos
decl_stmt|;
name|FT_Fixed
name|delta2
init|=
name|FT_PIX_ROUND
argument_list|(
name|pos
operator|+
name|len
argument_list|)
operator|-
name|pos
operator|-
name|len
decl_stmt|;
if|if
condition|(
name|FT_ABS
argument_list|(
name|delta1
argument_list|)
operator|<=
name|FT_ABS
argument_list|(
name|delta2
argument_list|)
condition|)
return|return
name|delta1
return|;
else|else
return|return
name|delta2
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|psh_hint_align
name|psh_hint_align
parameter_list|(
name|PSH_Hint
name|hint
parameter_list|,
name|PSH_Globals
name|globals
parameter_list|,
name|FT_Int
name|dimension
parameter_list|,
name|PSH_Glyph
name|glyph
parameter_list|)
block|{
name|PSH_Dimension
name|dim
init|=
operator|&
name|globals
operator|->
name|dimension
index|[
name|dimension
index|]
decl_stmt|;
name|FT_Fixed
name|scale
init|=
name|dim
operator|->
name|scale_mult
decl_stmt|;
name|FT_Fixed
name|delta
init|=
name|dim
operator|->
name|scale_delta
decl_stmt|;
if|if
condition|(
operator|!
name|psh_hint_is_fitted
argument_list|(
name|hint
argument_list|)
condition|)
block|{
name|FT_Pos
name|pos
init|=
name|FT_MulFix
argument_list|(
name|hint
operator|->
name|org_pos
argument_list|,
name|scale
argument_list|)
operator|+
name|delta
decl_stmt|;
name|FT_Pos
name|len
init|=
name|FT_MulFix
argument_list|(
name|hint
operator|->
name|org_len
argument_list|,
name|scale
argument_list|)
decl_stmt|;
name|FT_Int
name|do_snapping
decl_stmt|;
name|FT_Pos
name|fit_len
decl_stmt|;
name|PSH_AlignmentRec
name|align
decl_stmt|;
comment|/* ignore stem alignments when requested through the hint flags */
if|if
condition|(
operator|(
name|dimension
operator|==
literal|0
operator|&&
operator|!
name|glyph
operator|->
name|do_horz_hints
operator|)
operator|||
operator|(
name|dimension
operator|==
literal|1
operator|&&
operator|!
name|glyph
operator|->
name|do_vert_hints
operator|)
condition|)
block|{
name|hint
operator|->
name|cur_pos
operator|=
name|pos
expr_stmt|;
name|hint
operator|->
name|cur_len
operator|=
name|len
expr_stmt|;
name|psh_hint_set_fitted
argument_list|(
name|hint
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* perform stem snapping when requested - this is necessary        * for monochrome and LCD hinting modes only        */
name|do_snapping
operator|=
operator|(
name|dimension
operator|==
literal|0
operator|&&
name|glyph
operator|->
name|do_horz_snapping
operator|)
operator|||
operator|(
name|dimension
operator|==
literal|1
operator|&&
name|glyph
operator|->
name|do_vert_snapping
operator|)
expr_stmt|;
name|hint
operator|->
name|cur_len
operator|=
name|fit_len
operator|=
name|len
expr_stmt|;
comment|/* check blue zones for horizontal stems */
name|align
operator|.
name|align
operator|=
name|PSH_BLUE_ALIGN_NONE
expr_stmt|;
name|align
operator|.
name|align_bot
operator|=
name|align
operator|.
name|align_top
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dimension
operator|==
literal|1
condition|)
name|psh_blues_snap_stem
argument_list|(
operator|&
name|globals
operator|->
name|blues
argument_list|,
name|hint
operator|->
name|org_pos
operator|+
name|hint
operator|->
name|org_len
argument_list|,
name|hint
operator|->
name|org_pos
argument_list|,
operator|&
name|align
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|align
operator|.
name|align
condition|)
block|{
case|case
name|PSH_BLUE_ALIGN_TOP
case|:
comment|/* the top of the stem is aligned against a blue zone */
name|hint
operator|->
name|cur_pos
operator|=
name|align
operator|.
name|align_top
operator|-
name|fit_len
expr_stmt|;
break|break;
case|case
name|PSH_BLUE_ALIGN_BOT
case|:
comment|/* the bottom of the stem is aligned against a blue zone */
name|hint
operator|->
name|cur_pos
operator|=
name|align
operator|.
name|align_bot
expr_stmt|;
break|break;
case|case
name|PSH_BLUE_ALIGN_TOP
operator||
name|PSH_BLUE_ALIGN_BOT
case|:
comment|/* both edges of the stem are aligned against blue zones */
name|hint
operator|->
name|cur_pos
operator|=
name|align
operator|.
name|align_bot
expr_stmt|;
name|hint
operator|->
name|cur_len
operator|=
name|align
operator|.
name|align_top
operator|-
name|align
operator|.
name|align_bot
expr_stmt|;
break|break;
default|default:
block|{
name|PSH_Hint
name|parent
init|=
name|hint
operator|->
name|parent
decl_stmt|;
if|if
condition|(
name|parent
condition|)
block|{
name|FT_Pos
name|par_org_center
decl_stmt|,
name|par_cur_center
decl_stmt|;
name|FT_Pos
name|cur_org_center
decl_stmt|,
name|cur_delta
decl_stmt|;
comment|/* ensure that parent is already fitted */
if|if
condition|(
operator|!
name|psh_hint_is_fitted
argument_list|(
name|parent
argument_list|)
condition|)
name|psh_hint_align
argument_list|(
name|parent
argument_list|,
name|globals
argument_list|,
name|dimension
argument_list|,
name|glyph
argument_list|)
expr_stmt|;
comment|/* keep original relation between hints, this is, use the */
comment|/* scaled distance between the centers of the hints to    */
comment|/* compute the new position                               */
name|par_org_center
operator|=
name|parent
operator|->
name|org_pos
operator|+
operator|(
name|parent
operator|->
name|org_len
operator|>>
literal|1
operator|)
expr_stmt|;
name|par_cur_center
operator|=
name|parent
operator|->
name|cur_pos
operator|+
operator|(
name|parent
operator|->
name|cur_len
operator|>>
literal|1
operator|)
expr_stmt|;
name|cur_org_center
operator|=
name|hint
operator|->
name|org_pos
operator|+
operator|(
name|hint
operator|->
name|org_len
operator|>>
literal|1
operator|)
expr_stmt|;
name|cur_delta
operator|=
name|FT_MulFix
argument_list|(
name|cur_org_center
operator|-
name|par_org_center
argument_list|,
name|scale
argument_list|)
expr_stmt|;
name|pos
operator|=
name|par_cur_center
operator|+
name|cur_delta
operator|-
operator|(
name|len
operator|>>
literal|1
operator|)
expr_stmt|;
block|}
name|hint
operator|->
name|cur_pos
operator|=
name|pos
expr_stmt|;
name|hint
operator|->
name|cur_len
operator|=
name|fit_len
expr_stmt|;
comment|/* Stem adjustment tries to snap stem widths to standard            * ones.  This is important to prevent unpleasant rounding            * artefacts.            */
if|if
condition|(
name|glyph
operator|->
name|do_stem_adjust
condition|)
block|{
if|if
condition|(
name|len
operator|<=
literal|64
condition|)
block|{
comment|/* the stem is less than one pixel; we will center it                * around the nearest pixel center                */
if|if
condition|(
name|len
operator|>=
literal|32
condition|)
block|{
comment|/* This is a special case where we also widen the stem                  * and align it to the pixel grid.                  *                  *   stem_center          = pos + (len/2)                  *   nearest_pixel_center = FT_ROUND(stem_center-32)+32                  *   new_pos              = nearest_pixel_center-32                  *                        = FT_ROUND(stem_center-32)                  *                        = FT_FLOOR(stem_center-32+32)                  *                        = FT_FLOOR(stem_center)                  *   new_len              = 64                  */
name|pos
operator|=
name|FT_PIX_FLOOR
argument_list|(
name|pos
operator|+
operator|(
name|len
operator|>>
literal|1
operator|)
argument_list|)
expr_stmt|;
name|len
operator|=
literal|64
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
comment|/* This is a very small stem; we simply align it to the                  * pixel grid, trying to find the minimal displacement.                  *                  * left               = pos                  * right              = pos + len                  * left_nearest_edge  = ROUND(pos)                  * right_nearest_edge = ROUND(right)                  *                  * if ( ABS(left_nearest_edge - left)<=                  *      ABS(right_nearest_edge - right) )                  *    new_pos = left                  * else                  *    new_pos = right                  */
name|FT_Pos
name|left_nearest
init|=
name|FT_PIX_ROUND
argument_list|(
name|pos
argument_list|)
decl_stmt|;
name|FT_Pos
name|right_nearest
init|=
name|FT_PIX_ROUND
argument_list|(
name|pos
operator|+
name|len
argument_list|)
decl_stmt|;
name|FT_Pos
name|left_disp
init|=
name|left_nearest
operator|-
name|pos
decl_stmt|;
name|FT_Pos
name|right_disp
init|=
name|right_nearest
operator|-
operator|(
name|pos
operator|+
name|len
operator|)
decl_stmt|;
if|if
condition|(
name|left_disp
operator|<
literal|0
condition|)
name|left_disp
operator|=
operator|-
name|left_disp
expr_stmt|;
if|if
condition|(
name|right_disp
operator|<
literal|0
condition|)
name|right_disp
operator|=
operator|-
name|right_disp
expr_stmt|;
if|if
condition|(
name|left_disp
operator|<=
name|right_disp
condition|)
name|pos
operator|=
name|left_nearest
expr_stmt|;
else|else
name|pos
operator|=
name|right_nearest
expr_stmt|;
block|}
else|else
block|{
comment|/* this is a ghost stem; we simply round it */
name|pos
operator|=
name|FT_PIX_ROUND
argument_list|(
name|pos
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|len
operator|=
name|psh_dimension_quantize_len
argument_list|(
name|dim
argument_list|,
name|len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* now that we have a good hinted stem width, try to position */
comment|/* the stem along a pixel grid integer coordinate             */
name|hint
operator|->
name|cur_pos
operator|=
name|pos
operator|+
name|psh_hint_snap_stem_side_delta
argument_list|(
name|pos
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|hint
operator|->
name|cur_len
operator|=
name|len
expr_stmt|;
block|}
block|}
if|if
condition|(
name|do_snapping
condition|)
block|{
name|pos
operator|=
name|hint
operator|->
name|cur_pos
expr_stmt|;
name|len
operator|=
name|hint
operator|->
name|cur_len
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|64
condition|)
name|len
operator|=
literal|64
expr_stmt|;
else|else
name|len
operator|=
name|FT_PIX_ROUND
argument_list|(
name|len
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|align
operator|.
name|align
condition|)
block|{
case|case
name|PSH_BLUE_ALIGN_TOP
case|:
name|hint
operator|->
name|cur_pos
operator|=
name|align
operator|.
name|align_top
operator|-
name|len
expr_stmt|;
name|hint
operator|->
name|cur_len
operator|=
name|len
expr_stmt|;
break|break;
case|case
name|PSH_BLUE_ALIGN_BOT
case|:
name|hint
operator|->
name|cur_len
operator|=
name|len
expr_stmt|;
break|break;
case|case
name|PSH_BLUE_ALIGN_BOT
operator||
name|PSH_BLUE_ALIGN_TOP
case|:
comment|/* don't touch */
break|break;
default|default:
name|hint
operator|->
name|cur_len
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|len
operator|&
literal|64
condition|)
name|pos
operator|=
name|FT_PIX_FLOOR
argument_list|(
name|pos
operator|+
operator|(
name|len
operator|>>
literal|1
operator|)
argument_list|)
operator|+
literal|32
expr_stmt|;
else|else
name|pos
operator|=
name|FT_PIX_ROUND
argument_list|(
name|pos
operator|+
operator|(
name|len
operator|>>
literal|1
operator|)
argument_list|)
expr_stmt|;
name|hint
operator|->
name|cur_pos
operator|=
name|pos
operator|-
operator|(
name|len
operator|>>
literal|1
operator|)
expr_stmt|;
name|hint
operator|->
name|cur_len
operator|=
name|len
expr_stmt|;
block|}
block|}
name|psh_hint_set_fitted
argument_list|(
name|hint
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_HINTER
if|if
condition|(
name|ps_debug_hint_func
condition|)
name|ps_debug_hint_func
argument_list|(
name|hint
argument_list|,
name|dimension
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function
begin_if
if|#
directive|if
literal|0
end_if
begin_comment
comment|/* not used for now, experimental */
end_comment
begin_comment
comment|/*   *  A variant to perform "light" hinting (i.e. FT_RENDER_MODE_LIGHT)   *  of stems   */
end_comment
begin_comment
unit|static void   psh_hint_align_light( PSH_Hint     hint,                         PSH_Globals  globals,                         FT_Int       dimension,                         PSH_Glyph    glyph )   {     PSH_Dimension  dim   =&globals->dimension[dimension];     FT_Fixed       scale = dim->scale_mult;     FT_Fixed       delta = dim->scale_delta;       if ( !psh_hint_is_fitted( hint ) )     {       FT_Pos  pos = FT_MulFix( hint->org_pos, scale ) + delta;       FT_Pos  len = FT_MulFix( hint->org_len, scale );        FT_Pos  fit_len;        PSH_AlignmentRec  align;
comment|/* ignore stem alignments when requested through the hint flags */
end_comment
begin_comment
unit|if ( ( dimension == 0&& !glyph->do_horz_hints ) ||            ( dimension == 1&& !glyph->do_vert_hints ) )       {         hint->cur_pos = pos;         hint->cur_len = len;          psh_hint_set_fitted( hint );         return;       }        fit_len = len;        hint->cur_len = fit_len;
comment|/* check blue zones for horizontal stems */
end_comment
begin_comment
unit|align.align = PSH_BLUE_ALIGN_NONE;       align.align_bot = align.align_top = 0;        if ( dimension == 1 )         psh_blues_snap_stem(&globals->blues,                              hint->org_pos + hint->org_len,                              hint->org_pos,&align );        switch ( align.align )       {       case PSH_BLUE_ALIGN_TOP:
comment|/* the top of the stem is aligned against a blue zone */
end_comment
begin_comment
unit|hint->cur_pos = align.align_top - fit_len;         break;        case PSH_BLUE_ALIGN_BOT:
comment|/* the bottom of the stem is aligned against a blue zone */
end_comment
begin_comment
unit|hint->cur_pos = align.align_bot;         break;        case PSH_BLUE_ALIGN_TOP | PSH_BLUE_ALIGN_BOT:
comment|/* both edges of the stem are aligned against blue zones */
end_comment
begin_comment
unit|hint->cur_pos = align.align_bot;         hint->cur_len = align.align_top - align.align_bot;         break;        default:         {           PSH_Hint  parent = hint->parent;             if ( parent )           {             FT_Pos  par_org_center, par_cur_center;             FT_Pos  cur_org_center, cur_delta;
comment|/* ensure that parent is already fitted */
end_comment
begin_comment
unit|if ( !psh_hint_is_fitted( parent ) )               psh_hint_align_light( parent, globals, dimension, glyph );              par_org_center = parent->org_pos + ( parent->org_len / 2 );             par_cur_center = parent->cur_pos + ( parent->cur_len / 2 );             cur_org_center = hint->org_pos   + ( hint->org_len   / 2 );              cur_delta = FT_MulFix( cur_org_center - par_org_center, scale );             pos       = par_cur_center + cur_delta - ( len>> 1 );           }
comment|/* Stems less than one pixel wide are easy -- we want to            * make them as dark as possible, so they must fall within            * one pixel.  If the stem is split between two pixels            * then snap the edge that is nearer to the pixel boundary            * to the pixel boundary.            */
end_comment
begin_comment
unit|if ( len<= 64 )           {             if ( ( pos + len + 63 ) / 64  != pos / 64 + 1 )               pos += psh_hint_snap_stem_side_delta ( pos, len );           }
comment|/* Position stems other to minimize the amount of mid-grays.            * There are, in general, two positions that do this,            * illustrated as A) and B) below.            *            *   +                   +                   +                   +            *            * A)             |--------------------------------|            * B)   |--------------------------------|            * C)       |--------------------------------|            *            * Position A) (split the excess stem equally) should be better            * for stems of width N + f where f< 0.5.            *            * Position B) (split the deficiency equally) should be better            * for stems of width N + f where f> 0.5.            *            * It turns out though that minimizing the total number of lit            * pixels is also important, so position C), with one edge            * aligned with a pixel boundary is actually preferable            * to A).  There are also more possibile positions for C) than            * for A) or B), so it involves less distortion of the overall            * character shape.            */
end_comment
begin_comment
unit|else
comment|/* len> 64 */
end_comment
begin_comment
unit|{             FT_Fixed  frac_len = len& 63;             FT_Fixed  center = pos + ( len>> 1 );             FT_Fixed  delta_a, delta_b;               if ( ( len / 64 )& 1 )             {               delta_a = FT_PIX_FLOOR( center ) + 32 - center;               delta_b = FT_PIX_ROUND( center ) - center;             }             else             {               delta_a = FT_PIX_ROUND( center ) - center;               delta_b = FT_PIX_FLOOR( center ) + 32 - center;             }
comment|/* We choose between B) and C) above based on the amount              * of fractinal stem width; for small amounts, choose              * C) always, for large amounts, B) always, and inbetween,              * pick whichever one involves less stem movement.              */
end_comment
begin_comment
unit|if ( frac_len< 32 )             {               pos += psh_hint_snap_stem_side_delta ( pos, len );             }             else if ( frac_len< 48 )             {               FT_Fixed  side_delta = psh_hint_snap_stem_side_delta ( pos,                                                                      len );                if ( FT_ABS( side_delta )< FT_ABS( delta_b ) )                 pos += side_delta;               else                 pos += delta_b;             }             else             {               pos += delta_b;             }           }            hint->cur_pos = pos;         }       }
comment|/* switch */
end_comment
begin_ifdef
unit|psh_hint_set_fitted( hint );
ifdef|#
directive|ifdef
name|DEBUG_HINTER
end_ifdef
begin_endif
unit|if ( ps_debug_hint_func )         ps_debug_hint_func( hint, dimension );
endif|#
directive|endif
end_endif
begin_endif
unit|}   }
endif|#
directive|endif
end_endif
begin_comment
comment|/* 0 */
end_comment
begin_function
specifier|static
name|void
DECL|function|psh_hint_table_align_hints
name|psh_hint_table_align_hints
parameter_list|(
name|PSH_Hint_Table
name|table
parameter_list|,
name|PSH_Globals
name|globals
parameter_list|,
name|FT_Int
name|dimension
parameter_list|,
name|PSH_Glyph
name|glyph
parameter_list|)
block|{
name|PSH_Hint
name|hint
decl_stmt|;
name|FT_UInt
name|count
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_HINTER
name|PSH_Dimension
name|dim
init|=
operator|&
name|globals
operator|->
name|dimension
index|[
name|dimension
index|]
decl_stmt|;
name|FT_Fixed
name|scale
init|=
name|dim
operator|->
name|scale_mult
decl_stmt|;
name|FT_Fixed
name|delta
init|=
name|dim
operator|->
name|scale_delta
decl_stmt|;
if|if
condition|(
name|ps_debug_no_vert_hints
operator|&&
name|dimension
operator|==
literal|0
condition|)
block|{
name|ps_simple_scale
argument_list|(
name|table
argument_list|,
name|scale
argument_list|,
name|delta
argument_list|,
name|dimension
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ps_debug_no_horz_hints
operator|&&
name|dimension
operator|==
literal|1
condition|)
block|{
name|ps_simple_scale
argument_list|(
name|table
argument_list|,
name|scale
argument_list|,
name|delta
argument_list|,
name|dimension
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* DEBUG_HINTER*/
name|hint
operator|=
name|table
operator|->
name|hints
expr_stmt|;
name|count
operator|=
name|table
operator|->
name|max_hints
expr_stmt|;
for|for
control|(
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
operator|,
name|hint
operator|++
control|)
name|psh_hint_align
argument_list|(
name|hint
argument_list|,
name|globals
argument_list|,
name|dimension
argument_list|,
name|glyph
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****                POINTS INTERPOLATION ROUTINES                  *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_define
DECL|macro|PSH_ZONE_MIN
define|#
directive|define
name|PSH_ZONE_MIN
value|-3200000L
end_define
begin_define
DECL|macro|PSH_ZONE_MAX
define|#
directive|define
name|PSH_ZONE_MAX
value|+3200000L
end_define
begin_define
DECL|macro|xxDEBUG_ZONES
define|#
directive|define
name|xxDEBUG_ZONES
end_define
begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG_ZONES
end_ifdef
begin_include
include|#
directive|include
include|FT_CONFIG_STANDARD_LIBRARY_H
end_include
begin_function
specifier|static
name|void
DECL|function|psh_print_zone
name|psh_print_zone
parameter_list|(
name|PSH_Zone
name|zone
parameter_list|)
block|{
name|printf
argument_list|(
literal|"zone [scale,delta,min,max] = [%.3f,%.3f,%d,%d]\n"
argument_list|,
name|zone
operator|->
name|scale
operator|/
literal|65536.0
argument_list|,
name|zone
operator|->
name|delta
operator|/
literal|64.0
argument_list|,
name|zone
operator|->
name|min
argument_list|,
name|zone
operator|->
name|max
argument_list|)
expr_stmt|;
block|}
end_function
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|psh_print_zone
define|#
directive|define
name|psh_print_zone
parameter_list|(
name|x
parameter_list|)
value|do { } while ( 0 )
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* DEBUG_ZONES */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****                    HINTER GLYPH MANAGEMENT                    *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_if
if|#
directive|if
literal|1
end_if
begin_define
DECL|macro|psh_corner_is_flat
define|#
directive|define
name|psh_corner_is_flat
value|ft_corner_is_flat
end_define
begin_define
DECL|macro|psh_corner_orientation
define|#
directive|define
name|psh_corner_orientation
value|ft_corner_orientation
end_define
begin_else
else|#
directive|else
end_else
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Int
argument_list|)
end_macro
begin_macro
name|psh_corner_is_flat
argument_list|(
argument|FT_Pos  x_in
argument_list|,
argument|FT_Pos  y_in
argument_list|,
argument|FT_Pos  x_out
argument_list|,
argument|FT_Pos  y_out
argument_list|)
end_macro
begin_block
block|{
name|FT_Pos
name|ax
init|=
name|x_in
decl_stmt|;
name|FT_Pos
name|ay
init|=
name|y_in
decl_stmt|;
name|FT_Pos
name|d_in
decl_stmt|,
name|d_out
decl_stmt|,
name|d_corner
decl_stmt|;
if|if
condition|(
name|ax
operator|<
literal|0
condition|)
name|ax
operator|=
operator|-
name|ax
expr_stmt|;
if|if
condition|(
name|ay
operator|<
literal|0
condition|)
name|ay
operator|=
operator|-
name|ay
expr_stmt|;
name|d_in
operator|=
name|ax
operator|+
name|ay
expr_stmt|;
name|ax
operator|=
name|x_out
expr_stmt|;
if|if
condition|(
name|ax
operator|<
literal|0
condition|)
name|ax
operator|=
operator|-
name|ax
expr_stmt|;
name|ay
operator|=
name|y_out
expr_stmt|;
if|if
condition|(
name|ay
operator|<
literal|0
condition|)
name|ay
operator|=
operator|-
name|ay
expr_stmt|;
name|d_out
operator|=
name|ax
operator|+
name|ay
expr_stmt|;
name|ax
operator|=
name|x_out
operator|+
name|x_in
expr_stmt|;
if|if
condition|(
name|ax
operator|<
literal|0
condition|)
name|ax
operator|=
operator|-
name|ax
expr_stmt|;
name|ay
operator|=
name|y_out
operator|+
name|y_in
expr_stmt|;
if|if
condition|(
name|ay
operator|<
literal|0
condition|)
name|ay
operator|=
operator|-
name|ay
expr_stmt|;
name|d_corner
operator|=
name|ax
operator|+
name|ay
expr_stmt|;
return|return
operator|(
name|d_in
operator|+
name|d_out
operator|-
name|d_corner
operator|)
operator|<
operator|(
name|d_corner
operator|>>
literal|4
operator|)
return|;
block|}
end_block
begin_function
specifier|static
name|FT_Int
DECL|function|psh_corner_orientation
name|psh_corner_orientation
parameter_list|(
name|FT_Pos
name|in_x
parameter_list|,
name|FT_Pos
name|in_y
parameter_list|,
name|FT_Pos
name|out_x
parameter_list|,
name|FT_Pos
name|out_y
parameter_list|)
block|{
name|FT_Int
name|result
decl_stmt|;
comment|/* deal with the trivial cases quickly */
if|if
condition|(
name|in_y
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|in_x
operator|>=
literal|0
condition|)
name|result
operator|=
name|out_y
expr_stmt|;
else|else
name|result
operator|=
operator|-
name|out_y
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|in_x
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|in_y
operator|>=
literal|0
condition|)
name|result
operator|=
operator|-
name|out_x
expr_stmt|;
else|else
name|result
operator|=
name|out_x
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|out_y
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|out_x
operator|>=
literal|0
condition|)
name|result
operator|=
name|in_y
expr_stmt|;
else|else
name|result
operator|=
operator|-
name|in_y
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|out_x
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|out_y
operator|>=
literal|0
condition|)
name|result
operator|=
operator|-
name|in_x
expr_stmt|;
else|else
name|result
operator|=
name|in_x
expr_stmt|;
block|}
else|else
comment|/* general case */
block|{
name|long
name|long
name|delta
init|=
operator|(
name|long
name|long
operator|)
name|in_x
operator|*
name|out_y
operator|-
operator|(
name|long
name|long
operator|)
name|in_y
operator|*
name|out_x
decl_stmt|;
if|if
condition|(
name|delta
operator|==
literal|0
condition|)
name|result
operator|=
literal|0
expr_stmt|;
else|else
name|result
operator|=
literal|1
operator|-
literal|2
operator|*
operator|(
name|delta
operator|<
literal|0
operator|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* !1 */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|COMPUTE_INFLEXS
end_ifdef
begin_comment
comment|/* compute all inflex points in a given glyph */
end_comment
begin_function
specifier|static
name|void
DECL|function|psh_glyph_compute_inflections
name|psh_glyph_compute_inflections
parameter_list|(
name|PSH_Glyph
name|glyph
parameter_list|)
block|{
name|FT_UInt
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|glyph
operator|->
name|num_contours
condition|;
name|n
operator|++
control|)
block|{
name|PSH_Point
name|first
decl_stmt|,
name|start
decl_stmt|,
name|end
decl_stmt|,
name|before
decl_stmt|,
name|after
decl_stmt|;
name|FT_Pos
name|in_x
decl_stmt|,
name|in_y
decl_stmt|,
name|out_x
decl_stmt|,
name|out_y
decl_stmt|;
name|FT_Int
name|orient_prev
decl_stmt|,
name|orient_cur
decl_stmt|;
name|FT_Int
name|finished
init|=
literal|0
decl_stmt|;
comment|/* we need at least 4 points to create an inflection point */
if|if
condition|(
name|glyph
operator|->
name|contours
index|[
name|n
index|]
operator|.
name|count
operator|<
literal|4
condition|)
continue|continue;
comment|/* compute first segment in contour */
name|first
operator|=
name|glyph
operator|->
name|contours
index|[
name|n
index|]
operator|.
name|start
expr_stmt|;
name|start
operator|=
name|end
operator|=
name|first
expr_stmt|;
do|do
block|{
name|end
operator|=
name|end
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|end
operator|==
name|first
condition|)
goto|goto
name|Skip
goto|;
name|in_x
operator|=
name|end
operator|->
name|org_u
operator|-
name|start
operator|->
name|org_u
expr_stmt|;
name|in_y
operator|=
name|end
operator|->
name|org_v
operator|-
name|start
operator|->
name|org_v
expr_stmt|;
block|}
do|while
condition|(
name|in_x
operator|==
literal|0
operator|&&
name|in_y
operator|==
literal|0
condition|)
do|;
comment|/* extend the segment start whenever possible */
name|before
operator|=
name|start
expr_stmt|;
do|do
block|{
do|do
block|{
name|start
operator|=
name|before
expr_stmt|;
name|before
operator|=
name|before
operator|->
name|prev
expr_stmt|;
if|if
condition|(
name|before
operator|==
name|first
condition|)
goto|goto
name|Skip
goto|;
name|out_x
operator|=
name|start
operator|->
name|org_u
operator|-
name|before
operator|->
name|org_u
expr_stmt|;
name|out_y
operator|=
name|start
operator|->
name|org_v
operator|-
name|before
operator|->
name|org_v
expr_stmt|;
block|}
do|while
condition|(
name|out_x
operator|==
literal|0
operator|&&
name|out_y
operator|==
literal|0
condition|)
do|;
name|orient_prev
operator|=
name|psh_corner_orientation
argument_list|(
name|in_x
argument_list|,
name|in_y
argument_list|,
name|out_x
argument_list|,
name|out_y
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|orient_prev
operator|==
literal|0
condition|)
do|;
name|first
operator|=
name|start
expr_stmt|;
name|in_x
operator|=
name|out_x
expr_stmt|;
name|in_y
operator|=
name|out_y
expr_stmt|;
comment|/* now, process all segments in the contour */
do|do
block|{
comment|/* first, extend current segment's end whenever possible */
name|after
operator|=
name|end
expr_stmt|;
do|do
block|{
do|do
block|{
name|end
operator|=
name|after
expr_stmt|;
name|after
operator|=
name|after
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|after
operator|==
name|first
condition|)
name|finished
operator|=
literal|1
expr_stmt|;
name|out_x
operator|=
name|after
operator|->
name|org_u
operator|-
name|end
operator|->
name|org_u
expr_stmt|;
name|out_y
operator|=
name|after
operator|->
name|org_v
operator|-
name|end
operator|->
name|org_v
expr_stmt|;
block|}
do|while
condition|(
name|out_x
operator|==
literal|0
operator|&&
name|out_y
operator|==
literal|0
condition|)
do|;
name|orient_cur
operator|=
name|psh_corner_orientation
argument_list|(
name|in_x
argument_list|,
name|in_y
argument_list|,
name|out_x
argument_list|,
name|out_y
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|orient_cur
operator|==
literal|0
condition|)
do|;
if|if
condition|(
operator|(
name|orient_cur
operator|^
name|orient_prev
operator|)
operator|<
literal|0
condition|)
block|{
do|do
block|{
name|psh_point_set_inflex
argument_list|(
name|start
argument_list|)
expr_stmt|;
name|start
operator|=
name|start
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|start
operator|!=
name|end
condition|)
do|;
name|psh_point_set_inflex
argument_list|(
name|start
argument_list|)
expr_stmt|;
block|}
name|start
operator|=
name|end
expr_stmt|;
name|end
operator|=
name|after
expr_stmt|;
name|orient_prev
operator|=
name|orient_cur
expr_stmt|;
name|in_x
operator|=
name|out_x
expr_stmt|;
name|in_y
operator|=
name|out_y
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|finished
condition|)
do|;
name|Skip
label|:
empty_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* COMPUTE_INFLEXS */
end_comment
begin_function
specifier|static
name|void
DECL|function|psh_glyph_done
name|psh_glyph_done
parameter_list|(
name|PSH_Glyph
name|glyph
parameter_list|)
block|{
name|FT_Memory
name|memory
init|=
name|glyph
operator|->
name|memory
decl_stmt|;
name|psh_hint_table_done
argument_list|(
operator|&
name|glyph
operator|->
name|hint_tables
index|[
literal|1
index|]
argument_list|,
name|memory
argument_list|)
expr_stmt|;
name|psh_hint_table_done
argument_list|(
operator|&
name|glyph
operator|->
name|hint_tables
index|[
literal|0
index|]
argument_list|,
name|memory
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|glyph
operator|->
name|points
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|glyph
operator|->
name|contours
argument_list|)
expr_stmt|;
name|glyph
operator|->
name|num_points
operator|=
literal|0
expr_stmt|;
name|glyph
operator|->
name|num_contours
operator|=
literal|0
expr_stmt|;
name|glyph
operator|->
name|memory
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|int
DECL|function|psh_compute_dir
name|psh_compute_dir
parameter_list|(
name|FT_Pos
name|dx
parameter_list|,
name|FT_Pos
name|dy
parameter_list|)
block|{
name|FT_Pos
name|ax
decl_stmt|,
name|ay
decl_stmt|;
name|int
name|result
init|=
name|PSH_DIR_NONE
decl_stmt|;
name|ax
operator|=
operator|(
name|dx
operator|>=
literal|0
operator|)
condition|?
name|dx
else|:
operator|-
name|dx
expr_stmt|;
name|ay
operator|=
operator|(
name|dy
operator|>=
literal|0
operator|)
condition|?
name|dy
else|:
operator|-
name|dy
expr_stmt|;
if|if
condition|(
name|ay
operator|*
literal|12
operator|<
name|ax
condition|)
block|{
comment|/* |dy|<<< |dx|  means a near-horizontal segment */
name|result
operator|=
operator|(
name|dx
operator|>=
literal|0
operator|)
condition|?
name|PSH_DIR_RIGHT
else|:
name|PSH_DIR_LEFT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ax
operator|*
literal|12
operator|<
name|ay
condition|)
block|{
comment|/* |dx|<<< |dy|  means a near-vertical segment */
name|result
operator|=
operator|(
name|dy
operator|>=
literal|0
operator|)
condition|?
name|PSH_DIR_UP
else|:
name|PSH_DIR_DOWN
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/* load outline point coordinates into hinter glyph */
end_comment
begin_function
specifier|static
name|void
DECL|function|psh_glyph_load_points
name|psh_glyph_load_points
parameter_list|(
name|PSH_Glyph
name|glyph
parameter_list|,
name|FT_Int
name|dimension
parameter_list|)
block|{
name|FT_Vector
modifier|*
name|vec
init|=
name|glyph
operator|->
name|outline
operator|->
name|points
decl_stmt|;
name|PSH_Point
name|point
init|=
name|glyph
operator|->
name|points
decl_stmt|;
name|FT_UInt
name|count
init|=
name|glyph
operator|->
name|num_points
decl_stmt|;
for|for
control|(
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
operator|,
name|point
operator|++
operator|,
name|vec
operator|++
control|)
block|{
name|point
operator|->
name|flags2
operator|=
literal|0
expr_stmt|;
name|point
operator|->
name|hint
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|dimension
operator|==
literal|0
condition|)
block|{
name|point
operator|->
name|org_u
operator|=
name|vec
operator|->
name|x
expr_stmt|;
name|point
operator|->
name|org_v
operator|=
name|vec
operator|->
name|y
expr_stmt|;
block|}
else|else
block|{
name|point
operator|->
name|org_u
operator|=
name|vec
operator|->
name|y
expr_stmt|;
name|point
operator|->
name|org_v
operator|=
name|vec
operator|->
name|x
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG_HINTER
name|point
operator|->
name|org_x
operator|=
name|vec
operator|->
name|x
expr_stmt|;
name|point
operator|->
name|org_y
operator|=
name|vec
operator|->
name|y
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function
begin_comment
comment|/* save hinted point coordinates back to outline */
end_comment
begin_function
specifier|static
name|void
DECL|function|psh_glyph_save_points
name|psh_glyph_save_points
parameter_list|(
name|PSH_Glyph
name|glyph
parameter_list|,
name|FT_Int
name|dimension
parameter_list|)
block|{
name|FT_UInt
name|n
decl_stmt|;
name|PSH_Point
name|point
init|=
name|glyph
operator|->
name|points
decl_stmt|;
name|FT_Vector
modifier|*
name|vec
init|=
name|glyph
operator|->
name|outline
operator|->
name|points
decl_stmt|;
name|char
modifier|*
name|tags
init|=
name|glyph
operator|->
name|outline
operator|->
name|tags
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|glyph
operator|->
name|num_points
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|dimension
operator|==
literal|0
condition|)
name|vec
index|[
name|n
index|]
operator|.
name|x
operator|=
name|point
operator|->
name|cur_u
expr_stmt|;
else|else
name|vec
index|[
name|n
index|]
operator|.
name|y
operator|=
name|point
operator|->
name|cur_u
expr_stmt|;
if|if
condition|(
name|psh_point_is_strong
argument_list|(
name|point
argument_list|)
condition|)
name|tags
index|[
name|n
index|]
operator||=
call|(
name|char
call|)
argument_list|(
operator|(
name|dimension
operator|==
literal|0
operator|)
condition|?
literal|32
else|:
literal|64
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_HINTER
if|if
condition|(
name|dimension
operator|==
literal|0
condition|)
block|{
name|point
operator|->
name|cur_x
operator|=
name|point
operator|->
name|cur_u
expr_stmt|;
name|point
operator|->
name|flags_x
operator|=
name|point
operator|->
name|flags2
operator||
name|point
operator|->
name|flags
expr_stmt|;
block|}
else|else
block|{
name|point
operator|->
name|cur_y
operator|=
name|point
operator|->
name|cur_u
expr_stmt|;
name|point
operator|->
name|flags_y
operator|=
name|point
operator|->
name|flags2
operator||
name|point
operator|->
name|flags
expr_stmt|;
block|}
endif|#
directive|endif
name|point
operator|++
expr_stmt|;
block|}
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|psh_glyph_init
name|psh_glyph_init
parameter_list|(
name|PSH_Glyph
name|glyph
parameter_list|,
name|FT_Outline
modifier|*
name|outline
parameter_list|,
name|PS_Hints
name|ps_hints
parameter_list|,
name|PSH_Globals
name|globals
parameter_list|)
block|{
name|FT_Error
name|error
decl_stmt|;
name|FT_Memory
name|memory
decl_stmt|;
comment|/* clear all fields */
name|FT_MEM_ZERO
argument_list|(
name|glyph
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|glyph
argument_list|)
argument_list|)
expr_stmt|;
name|memory
operator|=
name|glyph
operator|->
name|memory
operator|=
name|globals
operator|->
name|memory
expr_stmt|;
comment|/* allocate and setup points + contours arrays */
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|glyph
operator|->
name|points
argument_list|,
name|outline
operator|->
name|n_points
argument_list|)
operator|||
name|FT_NEW_ARRAY
argument_list|(
name|glyph
operator|->
name|contours
argument_list|,
name|outline
operator|->
name|n_contours
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|glyph
operator|->
name|num_points
operator|=
name|outline
operator|->
name|n_points
expr_stmt|;
name|glyph
operator|->
name|num_contours
operator|=
name|outline
operator|->
name|n_contours
expr_stmt|;
block|{
name|FT_UInt
name|first
init|=
literal|0
decl_stmt|,
name|next
decl_stmt|,
name|n
decl_stmt|;
name|PSH_Point
name|points
init|=
name|glyph
operator|->
name|points
decl_stmt|;
name|PSH_Contour
name|contour
init|=
name|glyph
operator|->
name|contours
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|glyph
operator|->
name|num_contours
condition|;
name|n
operator|++
control|)
block|{
name|FT_Int
name|count
decl_stmt|;
name|PSH_Point
name|point
decl_stmt|;
name|next
operator|=
name|outline
operator|->
name|contours
index|[
name|n
index|]
operator|+
literal|1
expr_stmt|;
name|count
operator|=
name|next
operator|-
name|first
expr_stmt|;
name|contour
operator|->
name|start
operator|=
name|points
operator|+
name|first
expr_stmt|;
name|contour
operator|->
name|count
operator|=
operator|(
name|FT_UInt
operator|)
name|count
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|point
operator|=
name|points
operator|+
name|first
expr_stmt|;
name|point
operator|->
name|prev
operator|=
name|points
operator|+
name|next
operator|-
literal|1
expr_stmt|;
name|point
operator|->
name|contour
operator|=
name|contour
expr_stmt|;
for|for
control|(
init|;
name|count
operator|>
literal|1
condition|;
name|count
operator|--
control|)
block|{
name|point
index|[
literal|0
index|]
operator|.
name|next
operator|=
name|point
operator|+
literal|1
expr_stmt|;
name|point
index|[
literal|1
index|]
operator|.
name|prev
operator|=
name|point
expr_stmt|;
name|point
operator|++
expr_stmt|;
name|point
operator|->
name|contour
operator|=
name|contour
expr_stmt|;
block|}
name|point
operator|->
name|next
operator|=
name|points
operator|+
name|first
expr_stmt|;
block|}
name|contour
operator|++
expr_stmt|;
name|first
operator|=
name|next
expr_stmt|;
block|}
block|}
block|{
name|PSH_Point
name|points
init|=
name|glyph
operator|->
name|points
decl_stmt|;
name|PSH_Point
name|point
init|=
name|points
decl_stmt|;
name|FT_Vector
modifier|*
name|vec
init|=
name|outline
operator|->
name|points
decl_stmt|;
name|FT_UInt
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|glyph
operator|->
name|num_points
condition|;
name|n
operator|++
operator|,
name|point
operator|++
control|)
block|{
name|FT_Int
name|n_prev
init|=
call|(
name|FT_Int
call|)
argument_list|(
name|point
operator|->
name|prev
operator|-
name|points
argument_list|)
decl_stmt|;
name|FT_Int
name|n_next
init|=
call|(
name|FT_Int
call|)
argument_list|(
name|point
operator|->
name|next
operator|-
name|points
argument_list|)
decl_stmt|;
name|FT_Pos
name|dxi
decl_stmt|,
name|dyi
decl_stmt|,
name|dxo
decl_stmt|,
name|dyo
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|outline
operator|->
name|tags
index|[
name|n
index|]
operator|&
name|FT_CURVE_TAG_ON
operator|)
condition|)
name|point
operator|->
name|flags
operator|=
name|PSH_POINT_OFF
expr_stmt|;
name|dxi
operator|=
name|vec
index|[
name|n
index|]
operator|.
name|x
operator|-
name|vec
index|[
name|n_prev
index|]
operator|.
name|x
expr_stmt|;
name|dyi
operator|=
name|vec
index|[
name|n
index|]
operator|.
name|y
operator|-
name|vec
index|[
name|n_prev
index|]
operator|.
name|y
expr_stmt|;
name|point
operator|->
name|dir_in
operator|=
operator|(
name|FT_Char
operator|)
name|psh_compute_dir
argument_list|(
name|dxi
argument_list|,
name|dyi
argument_list|)
expr_stmt|;
name|dxo
operator|=
name|vec
index|[
name|n_next
index|]
operator|.
name|x
operator|-
name|vec
index|[
name|n
index|]
operator|.
name|x
expr_stmt|;
name|dyo
operator|=
name|vec
index|[
name|n_next
index|]
operator|.
name|y
operator|-
name|vec
index|[
name|n
index|]
operator|.
name|y
expr_stmt|;
name|point
operator|->
name|dir_out
operator|=
operator|(
name|FT_Char
operator|)
name|psh_compute_dir
argument_list|(
name|dxo
argument_list|,
name|dyo
argument_list|)
expr_stmt|;
comment|/* detect smooth points */
if|if
condition|(
name|point
operator|->
name|flags
operator|&
name|PSH_POINT_OFF
condition|)
name|point
operator|->
name|flags
operator||=
name|PSH_POINT_SMOOTH
expr_stmt|;
elseif|else
if|if
condition|(
name|point
operator|->
name|dir_in
operator|==
name|point
operator|->
name|dir_out
condition|)
block|{
if|if
condition|(
name|point
operator|->
name|dir_out
operator|!=
name|PSH_DIR_NONE
operator|||
name|psh_corner_is_flat
argument_list|(
name|dxi
argument_list|,
name|dyi
argument_list|,
name|dxo
argument_list|,
name|dyo
argument_list|)
condition|)
name|point
operator|->
name|flags
operator||=
name|PSH_POINT_SMOOTH
expr_stmt|;
block|}
block|}
block|}
name|glyph
operator|->
name|outline
operator|=
name|outline
expr_stmt|;
name|glyph
operator|->
name|globals
operator|=
name|globals
expr_stmt|;
ifdef|#
directive|ifdef
name|COMPUTE_INFLEXS
name|psh_glyph_load_points
argument_list|(
name|glyph
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|psh_glyph_compute_inflections
argument_list|(
name|glyph
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* COMPUTE_INFLEXS */
comment|/* now deal with hints tables */
name|error
operator|=
name|psh_hint_table_init
argument_list|(
operator|&
name|glyph
operator|->
name|hint_tables
index|[
literal|0
index|]
argument_list|,
operator|&
name|ps_hints
operator|->
name|dimension
index|[
literal|0
index|]
operator|.
name|hints
argument_list|,
operator|&
name|ps_hints
operator|->
name|dimension
index|[
literal|0
index|]
operator|.
name|masks
argument_list|,
operator|&
name|ps_hints
operator|->
name|dimension
index|[
literal|0
index|]
operator|.
name|counters
argument_list|,
name|memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|error
operator|=
name|psh_hint_table_init
argument_list|(
operator|&
name|glyph
operator|->
name|hint_tables
index|[
literal|1
index|]
argument_list|,
operator|&
name|ps_hints
operator|->
name|dimension
index|[
literal|1
index|]
operator|.
name|hints
argument_list|,
operator|&
name|ps_hints
operator|->
name|dimension
index|[
literal|1
index|]
operator|.
name|masks
argument_list|,
operator|&
name|ps_hints
operator|->
name|dimension
index|[
literal|1
index|]
operator|.
name|counters
argument_list|,
name|memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|Exit
label|:
return|return
name|error
return|;
block|}
end_function
begin_comment
comment|/* compute all extrema in a glyph for a given dimension */
end_comment
begin_function
specifier|static
name|void
DECL|function|psh_glyph_compute_extrema
name|psh_glyph_compute_extrema
parameter_list|(
name|PSH_Glyph
name|glyph
parameter_list|)
block|{
name|FT_UInt
name|n
decl_stmt|;
comment|/* first of all, compute all local extrema */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|glyph
operator|->
name|num_contours
condition|;
name|n
operator|++
control|)
block|{
name|PSH_Point
name|first
init|=
name|glyph
operator|->
name|contours
index|[
name|n
index|]
operator|.
name|start
decl_stmt|;
name|PSH_Point
name|point
decl_stmt|,
name|before
decl_stmt|,
name|after
decl_stmt|;
if|if
condition|(
name|glyph
operator|->
name|contours
index|[
name|n
index|]
operator|.
name|count
operator|==
literal|0
condition|)
continue|continue;
name|point
operator|=
name|first
expr_stmt|;
name|before
operator|=
name|point
expr_stmt|;
name|after
operator|=
name|point
expr_stmt|;
do|do
block|{
name|before
operator|=
name|before
operator|->
name|prev
expr_stmt|;
if|if
condition|(
name|before
operator|==
name|first
condition|)
goto|goto
name|Skip
goto|;
block|}
do|while
condition|(
name|before
operator|->
name|org_u
operator|==
name|point
operator|->
name|org_u
condition|)
do|;
name|first
operator|=
name|point
operator|=
name|before
operator|->
name|next
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|after
operator|=
name|point
expr_stmt|;
do|do
block|{
name|after
operator|=
name|after
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|after
operator|==
name|first
condition|)
goto|goto
name|Next
goto|;
block|}
do|while
condition|(
name|after
operator|->
name|org_u
operator|==
name|point
operator|->
name|org_u
condition|)
do|;
if|if
condition|(
name|before
operator|->
name|org_u
operator|<
name|point
operator|->
name|org_u
condition|)
block|{
if|if
condition|(
name|after
operator|->
name|org_u
operator|<
name|point
operator|->
name|org_u
condition|)
block|{
comment|/* local maximum */
goto|goto
name|Extremum
goto|;
block|}
block|}
else|else
comment|/* before->org_u> point->org_u */
block|{
if|if
condition|(
name|after
operator|->
name|org_u
operator|>
name|point
operator|->
name|org_u
condition|)
block|{
comment|/* local minimum */
name|Extremum
label|:
do|do
block|{
name|psh_point_set_extremum
argument_list|(
name|point
argument_list|)
expr_stmt|;
name|point
operator|=
name|point
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|point
operator|!=
name|after
condition|)
do|;
block|}
block|}
name|before
operator|=
name|after
operator|->
name|prev
expr_stmt|;
name|point
operator|=
name|after
expr_stmt|;
block|}
comment|/* for  */
name|Next
label|:
empty_stmt|;
block|}
comment|/* for each extremum, determine its direction along the */
comment|/* orthogonal axis                                      */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|glyph
operator|->
name|num_points
condition|;
name|n
operator|++
control|)
block|{
name|PSH_Point
name|point
decl_stmt|,
name|before
decl_stmt|,
name|after
decl_stmt|;
name|point
operator|=
operator|&
name|glyph
operator|->
name|points
index|[
name|n
index|]
expr_stmt|;
name|before
operator|=
name|point
expr_stmt|;
name|after
operator|=
name|point
expr_stmt|;
if|if
condition|(
name|psh_point_is_extremum
argument_list|(
name|point
argument_list|)
condition|)
block|{
do|do
block|{
name|before
operator|=
name|before
operator|->
name|prev
expr_stmt|;
if|if
condition|(
name|before
operator|==
name|point
condition|)
goto|goto
name|Skip
goto|;
block|}
do|while
condition|(
name|before
operator|->
name|org_v
operator|==
name|point
operator|->
name|org_v
condition|)
do|;
do|do
block|{
name|after
operator|=
name|after
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|after
operator|==
name|point
condition|)
goto|goto
name|Skip
goto|;
block|}
do|while
condition|(
name|after
operator|->
name|org_v
operator|==
name|point
operator|->
name|org_v
condition|)
do|;
block|}
if|if
condition|(
name|before
operator|->
name|org_v
operator|<
name|point
operator|->
name|org_v
operator|&&
name|after
operator|->
name|org_v
operator|>
name|point
operator|->
name|org_v
condition|)
block|{
name|psh_point_set_positive
argument_list|(
name|point
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|before
operator|->
name|org_v
operator|>
name|point
operator|->
name|org_v
operator|&&
name|after
operator|->
name|org_v
operator|<
name|point
operator|->
name|org_v
condition|)
block|{
name|psh_point_set_negative
argument_list|(
name|point
argument_list|)
expr_stmt|;
block|}
name|Skip
label|:
empty_stmt|;
block|}
block|}
end_function
begin_comment
comment|/* major_dir is the direction for points on the bottom/left of the stem; */
end_comment
begin_comment
comment|/* Points on the top/right of the stem will have a direction of          */
end_comment
begin_comment
comment|/* -major_dir.                                                           */
end_comment
begin_function
specifier|static
name|void
DECL|function|psh_hint_table_find_strong_points
name|psh_hint_table_find_strong_points
parameter_list|(
name|PSH_Hint_Table
name|table
parameter_list|,
name|PSH_Point
name|point
parameter_list|,
name|FT_UInt
name|count
parameter_list|,
name|FT_Int
name|threshold
parameter_list|,
name|FT_Int
name|major_dir
parameter_list|)
block|{
name|PSH_Hint
modifier|*
name|sort
init|=
name|table
operator|->
name|sort
decl_stmt|;
name|FT_UInt
name|num_hints
init|=
name|table
operator|->
name|num_hints
decl_stmt|;
for|for
control|(
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
operator|,
name|point
operator|++
control|)
block|{
name|FT_Int
name|point_dir
init|=
literal|0
decl_stmt|;
name|FT_Pos
name|org_u
init|=
name|point
operator|->
name|org_u
decl_stmt|;
if|if
condition|(
name|psh_point_is_strong
argument_list|(
name|point
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|PSH_DIR_COMPARE
argument_list|(
name|point
operator|->
name|dir_in
argument_list|,
name|major_dir
argument_list|)
condition|)
name|point_dir
operator|=
name|point
operator|->
name|dir_in
expr_stmt|;
elseif|else
if|if
condition|(
name|PSH_DIR_COMPARE
argument_list|(
name|point
operator|->
name|dir_out
argument_list|,
name|major_dir
argument_list|)
condition|)
name|point_dir
operator|=
name|point
operator|->
name|dir_out
expr_stmt|;
if|if
condition|(
name|point_dir
condition|)
block|{
if|if
condition|(
name|point_dir
operator|==
name|major_dir
condition|)
block|{
name|FT_UInt
name|nn
decl_stmt|;
for|for
control|(
name|nn
operator|=
literal|0
init|;
name|nn
operator|<
name|num_hints
condition|;
name|nn
operator|++
control|)
block|{
name|PSH_Hint
name|hint
init|=
name|sort
index|[
name|nn
index|]
decl_stmt|;
name|FT_Pos
name|d
init|=
name|org_u
operator|-
name|hint
operator|->
name|org_pos
decl_stmt|;
if|if
condition|(
name|d
operator|<
name|threshold
operator|&&
operator|-
name|d
operator|<
name|threshold
condition|)
block|{
name|psh_point_set_strong
argument_list|(
name|point
argument_list|)
expr_stmt|;
name|point
operator|->
name|flags2
operator||=
name|PSH_POINT_EDGE_MIN
expr_stmt|;
name|point
operator|->
name|hint
operator|=
name|hint
expr_stmt|;
break|break;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|point_dir
operator|==
operator|-
name|major_dir
condition|)
block|{
name|FT_UInt
name|nn
decl_stmt|;
for|for
control|(
name|nn
operator|=
literal|0
init|;
name|nn
operator|<
name|num_hints
condition|;
name|nn
operator|++
control|)
block|{
name|PSH_Hint
name|hint
init|=
name|sort
index|[
name|nn
index|]
decl_stmt|;
name|FT_Pos
name|d
init|=
name|org_u
operator|-
name|hint
operator|->
name|org_pos
operator|-
name|hint
operator|->
name|org_len
decl_stmt|;
if|if
condition|(
name|d
operator|<
name|threshold
operator|&&
operator|-
name|d
operator|<
name|threshold
condition|)
block|{
name|psh_point_set_strong
argument_list|(
name|point
argument_list|)
expr_stmt|;
name|point
operator|->
name|flags2
operator||=
name|PSH_POINT_EDGE_MAX
expr_stmt|;
name|point
operator|->
name|hint
operator|=
name|hint
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
if|#
directive|if
literal|1
elseif|else
if|if
condition|(
name|psh_point_is_extremum
argument_list|(
name|point
argument_list|)
condition|)
block|{
comment|/* treat extrema as special cases for stem edge alignment */
name|FT_UInt
name|nn
decl_stmt|,
name|min_flag
decl_stmt|,
name|max_flag
decl_stmt|;
if|if
condition|(
name|major_dir
operator|==
name|PSH_DIR_HORIZONTAL
condition|)
block|{
name|min_flag
operator|=
name|PSH_POINT_POSITIVE
expr_stmt|;
name|max_flag
operator|=
name|PSH_POINT_NEGATIVE
expr_stmt|;
block|}
else|else
block|{
name|min_flag
operator|=
name|PSH_POINT_NEGATIVE
expr_stmt|;
name|max_flag
operator|=
name|PSH_POINT_POSITIVE
expr_stmt|;
block|}
if|if
condition|(
name|point
operator|->
name|flags2
operator|&
name|min_flag
condition|)
block|{
for|for
control|(
name|nn
operator|=
literal|0
init|;
name|nn
operator|<
name|num_hints
condition|;
name|nn
operator|++
control|)
block|{
name|PSH_Hint
name|hint
init|=
name|sort
index|[
name|nn
index|]
decl_stmt|;
name|FT_Pos
name|d
init|=
name|org_u
operator|-
name|hint
operator|->
name|org_pos
decl_stmt|;
if|if
condition|(
name|d
operator|<
name|threshold
operator|&&
operator|-
name|d
operator|<
name|threshold
condition|)
block|{
name|point
operator|->
name|flags2
operator||=
name|PSH_POINT_EDGE_MIN
expr_stmt|;
name|point
operator|->
name|hint
operator|=
name|hint
expr_stmt|;
name|psh_point_set_strong
argument_list|(
name|point
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|point
operator|->
name|flags2
operator|&
name|max_flag
condition|)
block|{
for|for
control|(
name|nn
operator|=
literal|0
init|;
name|nn
operator|<
name|num_hints
condition|;
name|nn
operator|++
control|)
block|{
name|PSH_Hint
name|hint
init|=
name|sort
index|[
name|nn
index|]
decl_stmt|;
name|FT_Pos
name|d
init|=
name|org_u
operator|-
name|hint
operator|->
name|org_pos
operator|-
name|hint
operator|->
name|org_len
decl_stmt|;
if|if
condition|(
name|d
operator|<
name|threshold
operator|&&
operator|-
name|d
operator|<
name|threshold
condition|)
block|{
name|point
operator|->
name|flags2
operator||=
name|PSH_POINT_EDGE_MAX
expr_stmt|;
name|point
operator|->
name|hint
operator|=
name|hint
expr_stmt|;
name|psh_point_set_strong
argument_list|(
name|point
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|point
operator|->
name|hint
operator|==
name|NULL
condition|)
block|{
for|for
control|(
name|nn
operator|=
literal|0
init|;
name|nn
operator|<
name|num_hints
condition|;
name|nn
operator|++
control|)
block|{
name|PSH_Hint
name|hint
init|=
name|sort
index|[
name|nn
index|]
decl_stmt|;
if|if
condition|(
name|org_u
operator|>=
name|hint
operator|->
name|org_pos
operator|&&
name|org_u
operator|<=
name|hint
operator|->
name|org_pos
operator|+
name|hint
operator|->
name|org_len
condition|)
block|{
name|point
operator|->
name|hint
operator|=
name|hint
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
endif|#
directive|endif
comment|/* 1 */
block|}
block|}
end_function
begin_comment
comment|/* the accepted shift for strong points in fractional pixels */
end_comment
begin_define
DECL|macro|PSH_STRONG_THRESHOLD
define|#
directive|define
name|PSH_STRONG_THRESHOLD
value|32
end_define
begin_comment
comment|/* the maximum shift value in font units */
end_comment
begin_define
DECL|macro|PSH_STRONG_THRESHOLD_MAXIMUM
define|#
directive|define
name|PSH_STRONG_THRESHOLD_MAXIMUM
value|30
end_define
begin_comment
comment|/* find strong points in a glyph */
end_comment
begin_function
specifier|static
name|void
DECL|function|psh_glyph_find_strong_points
name|psh_glyph_find_strong_points
parameter_list|(
name|PSH_Glyph
name|glyph
parameter_list|,
name|FT_Int
name|dimension
parameter_list|)
block|{
comment|/* a point is `strong' if it is located on a stem edge and       */
comment|/* has an `in' or `out' tangent parallel to the hint's direction */
name|PSH_Hint_Table
name|table
init|=
operator|&
name|glyph
operator|->
name|hint_tables
index|[
name|dimension
index|]
decl_stmt|;
name|PS_Mask
name|mask
init|=
name|table
operator|->
name|hint_masks
operator|->
name|masks
decl_stmt|;
name|FT_UInt
name|num_masks
init|=
name|table
operator|->
name|hint_masks
operator|->
name|num_masks
decl_stmt|;
name|FT_UInt
name|first
init|=
literal|0
decl_stmt|;
name|FT_Int
name|major_dir
init|=
name|dimension
operator|==
literal|0
condition|?
name|PSH_DIR_VERTICAL
else|:
name|PSH_DIR_HORIZONTAL
decl_stmt|;
name|PSH_Dimension
name|dim
init|=
operator|&
name|glyph
operator|->
name|globals
operator|->
name|dimension
index|[
name|dimension
index|]
decl_stmt|;
name|FT_Fixed
name|scale
init|=
name|dim
operator|->
name|scale_mult
decl_stmt|;
name|FT_Int
name|threshold
decl_stmt|;
name|threshold
operator|=
operator|(
name|FT_Int
operator|)
name|FT_DivFix
argument_list|(
name|PSH_STRONG_THRESHOLD
argument_list|,
name|scale
argument_list|)
expr_stmt|;
if|if
condition|(
name|threshold
operator|>
name|PSH_STRONG_THRESHOLD_MAXIMUM
condition|)
name|threshold
operator|=
name|PSH_STRONG_THRESHOLD_MAXIMUM
expr_stmt|;
comment|/* process secondary hints to `selected' points */
if|if
condition|(
name|num_masks
operator|>
literal|1
operator|&&
name|glyph
operator|->
name|num_points
operator|>
literal|0
condition|)
block|{
name|first
operator|=
name|mask
operator|->
name|end_point
expr_stmt|;
name|mask
operator|++
expr_stmt|;
for|for
control|(
init|;
name|num_masks
operator|>
literal|1
condition|;
name|num_masks
operator|--
operator|,
name|mask
operator|++
control|)
block|{
name|FT_UInt
name|next
decl_stmt|;
name|FT_Int
name|count
decl_stmt|;
name|next
operator|=
name|mask
operator|->
name|end_point
expr_stmt|;
name|count
operator|=
name|next
operator|-
name|first
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|PSH_Point
name|point
init|=
name|glyph
operator|->
name|points
operator|+
name|first
decl_stmt|;
name|psh_hint_table_activate_mask
argument_list|(
name|table
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|psh_hint_table_find_strong_points
argument_list|(
name|table
argument_list|,
name|point
argument_list|,
name|count
argument_list|,
name|threshold
argument_list|,
name|major_dir
argument_list|)
expr_stmt|;
block|}
name|first
operator|=
name|next
expr_stmt|;
block|}
block|}
comment|/* process primary hints for all points */
if|if
condition|(
name|num_masks
operator|==
literal|1
condition|)
block|{
name|FT_UInt
name|count
init|=
name|glyph
operator|->
name|num_points
decl_stmt|;
name|PSH_Point
name|point
init|=
name|glyph
operator|->
name|points
decl_stmt|;
name|psh_hint_table_activate_mask
argument_list|(
name|table
argument_list|,
name|table
operator|->
name|hint_masks
operator|->
name|masks
argument_list|)
expr_stmt|;
name|psh_hint_table_find_strong_points
argument_list|(
name|table
argument_list|,
name|point
argument_list|,
name|count
argument_list|,
name|threshold
argument_list|,
name|major_dir
argument_list|)
expr_stmt|;
block|}
comment|/* now, certain points may have been attached to a hint and */
comment|/* not marked as strong; update their flags then            */
block|{
name|FT_UInt
name|count
init|=
name|glyph
operator|->
name|num_points
decl_stmt|;
name|PSH_Point
name|point
init|=
name|glyph
operator|->
name|points
decl_stmt|;
for|for
control|(
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
operator|,
name|point
operator|++
control|)
if|if
condition|(
name|point
operator|->
name|hint
operator|&&
operator|!
name|psh_point_is_strong
argument_list|(
name|point
argument_list|)
condition|)
name|psh_point_set_strong
argument_list|(
name|point
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/* find points in a glyph which are in a blue zone and have `in' or */
end_comment
begin_comment
comment|/* `out' tangents parallel to the horizontal axis                   */
end_comment
begin_function
specifier|static
name|void
DECL|function|psh_glyph_find_blue_points
name|psh_glyph_find_blue_points
parameter_list|(
name|PSH_Blues
name|blues
parameter_list|,
name|PSH_Glyph
name|glyph
parameter_list|)
block|{
name|PSH_Blue_Table
name|table
decl_stmt|;
name|PSH_Blue_Zone
name|zone
decl_stmt|;
name|FT_UInt
name|glyph_count
init|=
name|glyph
operator|->
name|num_points
decl_stmt|;
name|FT_UInt
name|blue_count
decl_stmt|;
name|PSH_Point
name|point
init|=
name|glyph
operator|->
name|points
decl_stmt|;
for|for
control|(
init|;
name|glyph_count
operator|>
literal|0
condition|;
name|glyph_count
operator|--
operator|,
name|point
operator|++
control|)
block|{
name|FT_Pos
name|y
decl_stmt|;
comment|/* check tangents */
if|if
condition|(
operator|!
name|PSH_DIR_COMPARE
argument_list|(
name|point
operator|->
name|dir_in
argument_list|,
name|PSH_DIR_HORIZONTAL
argument_list|)
operator|&&
operator|!
name|PSH_DIR_COMPARE
argument_list|(
name|point
operator|->
name|dir_out
argument_list|,
name|PSH_DIR_HORIZONTAL
argument_list|)
condition|)
continue|continue;
comment|/* skip strong points */
if|if
condition|(
name|psh_point_is_strong
argument_list|(
name|point
argument_list|)
condition|)
continue|continue;
name|y
operator|=
name|point
operator|->
name|org_u
expr_stmt|;
comment|/* look up top zones */
name|table
operator|=
operator|&
name|blues
operator|->
name|normal_top
expr_stmt|;
name|blue_count
operator|=
name|table
operator|->
name|count
expr_stmt|;
name|zone
operator|=
name|table
operator|->
name|zones
expr_stmt|;
for|for
control|(
init|;
name|blue_count
operator|>
literal|0
condition|;
name|blue_count
operator|--
operator|,
name|zone
operator|++
control|)
block|{
name|FT_Pos
name|delta
init|=
name|y
operator|-
name|zone
operator|->
name|org_bottom
decl_stmt|;
if|if
condition|(
name|delta
operator|<
operator|-
name|blues
operator|->
name|blue_fuzz
condition|)
break|break;
if|if
condition|(
name|y
operator|<=
name|zone
operator|->
name|org_top
operator|+
name|blues
operator|->
name|blue_fuzz
condition|)
if|if
condition|(
name|blues
operator|->
name|no_overshoots
operator|||
name|delta
operator|<=
name|blues
operator|->
name|blue_threshold
condition|)
block|{
name|point
operator|->
name|cur_u
operator|=
name|zone
operator|->
name|cur_bottom
expr_stmt|;
name|psh_point_set_strong
argument_list|(
name|point
argument_list|)
expr_stmt|;
name|psh_point_set_fitted
argument_list|(
name|point
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* look up bottom zones */
name|table
operator|=
operator|&
name|blues
operator|->
name|normal_bottom
expr_stmt|;
name|blue_count
operator|=
name|table
operator|->
name|count
expr_stmt|;
name|zone
operator|=
name|table
operator|->
name|zones
operator|+
name|blue_count
operator|-
literal|1
expr_stmt|;
for|for
control|(
init|;
name|blue_count
operator|>
literal|0
condition|;
name|blue_count
operator|--
operator|,
name|zone
operator|--
control|)
block|{
name|FT_Pos
name|delta
init|=
name|zone
operator|->
name|org_top
operator|-
name|y
decl_stmt|;
if|if
condition|(
name|delta
operator|<
operator|-
name|blues
operator|->
name|blue_fuzz
condition|)
break|break;
if|if
condition|(
name|y
operator|>=
name|zone
operator|->
name|org_bottom
operator|-
name|blues
operator|->
name|blue_fuzz
condition|)
if|if
condition|(
name|blues
operator|->
name|no_overshoots
operator|||
name|delta
operator|<
name|blues
operator|->
name|blue_threshold
condition|)
block|{
name|point
operator|->
name|cur_u
operator|=
name|zone
operator|->
name|cur_top
expr_stmt|;
name|psh_point_set_strong
argument_list|(
name|point
argument_list|)
expr_stmt|;
name|psh_point_set_fitted
argument_list|(
name|point
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_comment
comment|/* interpolate strong points with the help of hinted coordinates */
end_comment
begin_function
specifier|static
name|void
DECL|function|psh_glyph_interpolate_strong_points
name|psh_glyph_interpolate_strong_points
parameter_list|(
name|PSH_Glyph
name|glyph
parameter_list|,
name|FT_Int
name|dimension
parameter_list|)
block|{
name|PSH_Dimension
name|dim
init|=
operator|&
name|glyph
operator|->
name|globals
operator|->
name|dimension
index|[
name|dimension
index|]
decl_stmt|;
name|FT_Fixed
name|scale
init|=
name|dim
operator|->
name|scale_mult
decl_stmt|;
name|FT_UInt
name|count
init|=
name|glyph
operator|->
name|num_points
decl_stmt|;
name|PSH_Point
name|point
init|=
name|glyph
operator|->
name|points
decl_stmt|;
for|for
control|(
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
operator|,
name|point
operator|++
control|)
block|{
name|PSH_Hint
name|hint
init|=
name|point
operator|->
name|hint
decl_stmt|;
if|if
condition|(
name|hint
condition|)
block|{
name|FT_Pos
name|delta
decl_stmt|;
if|if
condition|(
name|psh_point_is_edge_min
argument_list|(
name|point
argument_list|)
condition|)
name|point
operator|->
name|cur_u
operator|=
name|hint
operator|->
name|cur_pos
expr_stmt|;
elseif|else
if|if
condition|(
name|psh_point_is_edge_max
argument_list|(
name|point
argument_list|)
condition|)
name|point
operator|->
name|cur_u
operator|=
name|hint
operator|->
name|cur_pos
operator|+
name|hint
operator|->
name|cur_len
expr_stmt|;
else|else
block|{
name|delta
operator|=
name|point
operator|->
name|org_u
operator|-
name|hint
operator|->
name|org_pos
expr_stmt|;
if|if
condition|(
name|delta
operator|<=
literal|0
condition|)
name|point
operator|->
name|cur_u
operator|=
name|hint
operator|->
name|cur_pos
operator|+
name|FT_MulFix
argument_list|(
name|delta
argument_list|,
name|scale
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|delta
operator|>=
name|hint
operator|->
name|org_len
condition|)
name|point
operator|->
name|cur_u
operator|=
name|hint
operator|->
name|cur_pos
operator|+
name|hint
operator|->
name|cur_len
operator|+
name|FT_MulFix
argument_list|(
name|delta
operator|-
name|hint
operator|->
name|org_len
argument_list|,
name|scale
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|hint
operator|->
name|org_len
operator|>
literal|0
condition|)
name|point
operator|->
name|cur_u
operator|=
name|hint
operator|->
name|cur_pos
operator|+
name|FT_MulDiv
argument_list|(
name|delta
argument_list|,
name|hint
operator|->
name|cur_len
argument_list|,
name|hint
operator|->
name|org_len
argument_list|)
expr_stmt|;
else|else
name|point
operator|->
name|cur_u
operator|=
name|hint
operator|->
name|cur_pos
expr_stmt|;
block|}
name|psh_point_set_fitted
argument_list|(
name|point
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_define
DECL|macro|PSH_MAX_STRONG_INTERNAL
define|#
directive|define
name|PSH_MAX_STRONG_INTERNAL
value|16
end_define
begin_function
specifier|static
name|void
DECL|function|psh_glyph_interpolate_normal_points
name|psh_glyph_interpolate_normal_points
parameter_list|(
name|PSH_Glyph
name|glyph
parameter_list|,
name|FT_Int
name|dimension
parameter_list|)
block|{
if|#
directive|if
literal|1
comment|/* first technique: a point is strong if it is a local extremum */
name|PSH_Dimension
name|dim
init|=
operator|&
name|glyph
operator|->
name|globals
operator|->
name|dimension
index|[
name|dimension
index|]
decl_stmt|;
name|FT_Fixed
name|scale
init|=
name|dim
operator|->
name|scale_mult
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|glyph
operator|->
name|memory
decl_stmt|;
name|PSH_Point
modifier|*
name|strongs
init|=
name|NULL
decl_stmt|;
name|PSH_Point
name|strongs_0
index|[
name|PSH_MAX_STRONG_INTERNAL
index|]
decl_stmt|;
name|FT_UInt
name|num_strongs
init|=
literal|0
decl_stmt|;
name|PSH_Point
name|points
init|=
name|glyph
operator|->
name|points
decl_stmt|;
name|PSH_Point
name|points_end
init|=
name|points
operator|+
name|glyph
operator|->
name|num_points
decl_stmt|;
name|PSH_Point
name|point
decl_stmt|;
comment|/* first count the number of strong points */
for|for
control|(
name|point
operator|=
name|points
init|;
name|point
operator|<
name|points_end
condition|;
name|point
operator|++
control|)
block|{
if|if
condition|(
name|psh_point_is_strong
argument_list|(
name|point
argument_list|)
condition|)
name|num_strongs
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|num_strongs
operator|==
literal|0
condition|)
comment|/* nothing to do here */
return|return;
comment|/* allocate an array to store a list of points, */
comment|/* stored in increasing org_u order             */
if|if
condition|(
name|num_strongs
operator|<=
name|PSH_MAX_STRONG_INTERNAL
condition|)
name|strongs
operator|=
name|strongs_0
expr_stmt|;
else|else
block|{
name|FT_Error
name|error
decl_stmt|;
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|strongs
argument_list|,
name|num_strongs
argument_list|)
condition|)
return|return;
block|}
name|num_strongs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|point
operator|=
name|points
init|;
name|point
operator|<
name|points_end
condition|;
name|point
operator|++
control|)
block|{
name|PSH_Point
modifier|*
name|insert
decl_stmt|;
if|if
condition|(
operator|!
name|psh_point_is_strong
argument_list|(
name|point
argument_list|)
condition|)
continue|continue;
for|for
control|(
name|insert
operator|=
name|strongs
operator|+
name|num_strongs
init|;
name|insert
operator|>
name|strongs
condition|;
name|insert
operator|--
control|)
block|{
if|if
condition|(
name|insert
index|[
operator|-
literal|1
index|]
operator|->
name|org_u
operator|<=
name|point
operator|->
name|org_u
condition|)
break|break;
name|insert
index|[
literal|0
index|]
operator|=
name|insert
index|[
operator|-
literal|1
index|]
expr_stmt|;
block|}
name|insert
index|[
literal|0
index|]
operator|=
name|point
expr_stmt|;
name|num_strongs
operator|++
expr_stmt|;
block|}
comment|/* now try to interpolate all normal points */
for|for
control|(
name|point
operator|=
name|points
init|;
name|point
operator|<
name|points_end
condition|;
name|point
operator|++
control|)
block|{
if|if
condition|(
name|psh_point_is_strong
argument_list|(
name|point
argument_list|)
condition|)
continue|continue;
comment|/* sometimes, some local extrema are smooth points */
if|if
condition|(
name|psh_point_is_smooth
argument_list|(
name|point
argument_list|)
condition|)
block|{
if|if
condition|(
name|point
operator|->
name|dir_in
operator|==
name|PSH_DIR_NONE
operator|||
name|point
operator|->
name|dir_in
operator|!=
name|point
operator|->
name|dir_out
condition|)
continue|continue;
if|if
condition|(
operator|!
name|psh_point_is_extremum
argument_list|(
name|point
argument_list|)
operator|&&
operator|!
name|psh_point_is_inflex
argument_list|(
name|point
argument_list|)
condition|)
continue|continue;
name|point
operator|->
name|flags
operator|&=
operator|~
name|PSH_POINT_SMOOTH
expr_stmt|;
block|}
comment|/* find best enclosing point coordinates then interpolate */
block|{
name|PSH_Point
name|before
decl_stmt|,
name|after
decl_stmt|;
name|FT_UInt
name|nn
decl_stmt|;
for|for
control|(
name|nn
operator|=
literal|0
init|;
name|nn
operator|<
name|num_strongs
condition|;
name|nn
operator|++
control|)
if|if
condition|(
name|strongs
index|[
name|nn
index|]
operator|->
name|org_u
operator|>
name|point
operator|->
name|org_u
condition|)
break|break;
if|if
condition|(
name|nn
operator|==
literal|0
condition|)
comment|/* point before the first strong point */
block|{
name|after
operator|=
name|strongs
index|[
literal|0
index|]
expr_stmt|;
name|point
operator|->
name|cur_u
operator|=
name|after
operator|->
name|cur_u
operator|+
name|FT_MulFix
argument_list|(
name|point
operator|->
name|org_u
operator|-
name|after
operator|->
name|org_u
argument_list|,
name|scale
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|before
operator|=
name|strongs
index|[
name|nn
operator|-
literal|1
index|]
expr_stmt|;
for|for
control|(
name|nn
operator|=
name|num_strongs
init|;
name|nn
operator|>
literal|0
condition|;
name|nn
operator|--
control|)
if|if
condition|(
name|strongs
index|[
name|nn
operator|-
literal|1
index|]
operator|->
name|org_u
operator|<
name|point
operator|->
name|org_u
condition|)
break|break;
if|if
condition|(
name|nn
operator|==
name|num_strongs
condition|)
comment|/* point is after last strong point */
block|{
name|before
operator|=
name|strongs
index|[
name|nn
operator|-
literal|1
index|]
expr_stmt|;
name|point
operator|->
name|cur_u
operator|=
name|before
operator|->
name|cur_u
operator|+
name|FT_MulFix
argument_list|(
name|point
operator|->
name|org_u
operator|-
name|before
operator|->
name|org_u
argument_list|,
name|scale
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|FT_Pos
name|u
decl_stmt|;
name|after
operator|=
name|strongs
index|[
name|nn
index|]
expr_stmt|;
comment|/* now interpolate point between before and after */
name|u
operator|=
name|point
operator|->
name|org_u
expr_stmt|;
if|if
condition|(
name|u
operator|==
name|before
operator|->
name|org_u
condition|)
name|point
operator|->
name|cur_u
operator|=
name|before
operator|->
name|cur_u
expr_stmt|;
elseif|else
if|if
condition|(
name|u
operator|==
name|after
operator|->
name|org_u
condition|)
name|point
operator|->
name|cur_u
operator|=
name|after
operator|->
name|cur_u
expr_stmt|;
else|else
name|point
operator|->
name|cur_u
operator|=
name|before
operator|->
name|cur_u
operator|+
name|FT_MulDiv
argument_list|(
name|u
operator|-
name|before
operator|->
name|org_u
argument_list|,
name|after
operator|->
name|cur_u
operator|-
name|before
operator|->
name|cur_u
argument_list|,
name|after
operator|->
name|org_u
operator|-
name|before
operator|->
name|org_u
argument_list|)
expr_stmt|;
block|}
block|}
name|psh_point_set_fitted
argument_list|(
name|point
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|strongs
operator|!=
name|strongs_0
condition|)
name|FT_FREE
argument_list|(
name|strongs
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 1 */
block|}
end_function
begin_comment
comment|/* interpolate other points */
end_comment
begin_function
specifier|static
name|void
DECL|function|psh_glyph_interpolate_other_points
name|psh_glyph_interpolate_other_points
parameter_list|(
name|PSH_Glyph
name|glyph
parameter_list|,
name|FT_Int
name|dimension
parameter_list|)
block|{
name|PSH_Dimension
name|dim
init|=
operator|&
name|glyph
operator|->
name|globals
operator|->
name|dimension
index|[
name|dimension
index|]
decl_stmt|;
name|FT_Fixed
name|scale
init|=
name|dim
operator|->
name|scale_mult
decl_stmt|;
name|FT_Fixed
name|delta
init|=
name|dim
operator|->
name|scale_delta
decl_stmt|;
name|PSH_Contour
name|contour
init|=
name|glyph
operator|->
name|contours
decl_stmt|;
name|FT_UInt
name|num_contours
init|=
name|glyph
operator|->
name|num_contours
decl_stmt|;
for|for
control|(
init|;
name|num_contours
operator|>
literal|0
condition|;
name|num_contours
operator|--
operator|,
name|contour
operator|++
control|)
block|{
name|PSH_Point
name|start
init|=
name|contour
operator|->
name|start
decl_stmt|;
name|PSH_Point
name|first
decl_stmt|,
name|next
decl_stmt|,
name|point
decl_stmt|;
name|FT_UInt
name|fit_count
decl_stmt|;
comment|/* count the number of strong points in this contour */
name|next
operator|=
name|start
operator|+
name|contour
operator|->
name|count
expr_stmt|;
name|fit_count
operator|=
literal|0
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|point
operator|=
name|start
init|;
name|point
operator|<
name|next
condition|;
name|point
operator|++
control|)
if|if
condition|(
name|psh_point_is_fitted
argument_list|(
name|point
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|first
condition|)
name|first
operator|=
name|point
expr_stmt|;
name|fit_count
operator|++
expr_stmt|;
block|}
comment|/* if there are less than 2 fitted points in the contour, we */
comment|/* simply scale and eventually translate the contour points  */
if|if
condition|(
name|fit_count
operator|<
literal|2
condition|)
block|{
if|if
condition|(
name|fit_count
operator|==
literal|1
condition|)
name|delta
operator|=
name|first
operator|->
name|cur_u
operator|-
name|FT_MulFix
argument_list|(
name|first
operator|->
name|org_u
argument_list|,
name|scale
argument_list|)
expr_stmt|;
for|for
control|(
name|point
operator|=
name|start
init|;
name|point
operator|<
name|next
condition|;
name|point
operator|++
control|)
if|if
condition|(
name|point
operator|!=
name|first
condition|)
name|point
operator|->
name|cur_u
operator|=
name|FT_MulFix
argument_list|(
name|point
operator|->
name|org_u
argument_list|,
name|scale
argument_list|)
operator|+
name|delta
expr_stmt|;
goto|goto
name|Next_Contour
goto|;
block|}
comment|/* there are more than 2 strong points in this contour; we */
comment|/* need to interpolate weak points between them            */
name|start
operator|=
name|first
expr_stmt|;
do|do
block|{
name|point
operator|=
name|first
expr_stmt|;
comment|/* skip consecutive fitted points */
for|for
control|(
init|;
condition|;
control|)
block|{
name|next
operator|=
name|first
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|next
operator|==
name|start
condition|)
goto|goto
name|Next_Contour
goto|;
if|if
condition|(
operator|!
name|psh_point_is_fitted
argument_list|(
name|next
argument_list|)
condition|)
break|break;
name|first
operator|=
name|next
expr_stmt|;
block|}
comment|/* find next fitted point after unfitted one */
for|for
control|(
init|;
condition|;
control|)
block|{
name|next
operator|=
name|next
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|psh_point_is_fitted
argument_list|(
name|next
argument_list|)
condition|)
break|break;
block|}
comment|/* now interpolate between them */
block|{
name|FT_Pos
name|org_a
decl_stmt|,
name|org_ab
decl_stmt|,
name|cur_a
decl_stmt|,
name|cur_ab
decl_stmt|;
name|FT_Pos
name|org_c
decl_stmt|,
name|org_ac
decl_stmt|,
name|cur_c
decl_stmt|;
name|FT_Fixed
name|scale_ab
decl_stmt|;
if|if
condition|(
name|first
operator|->
name|org_u
operator|<=
name|next
operator|->
name|org_u
condition|)
block|{
name|org_a
operator|=
name|first
operator|->
name|org_u
expr_stmt|;
name|cur_a
operator|=
name|first
operator|->
name|cur_u
expr_stmt|;
name|org_ab
operator|=
name|next
operator|->
name|org_u
operator|-
name|org_a
expr_stmt|;
name|cur_ab
operator|=
name|next
operator|->
name|cur_u
operator|-
name|cur_a
expr_stmt|;
block|}
else|else
block|{
name|org_a
operator|=
name|next
operator|->
name|org_u
expr_stmt|;
name|cur_a
operator|=
name|next
operator|->
name|cur_u
expr_stmt|;
name|org_ab
operator|=
name|first
operator|->
name|org_u
operator|-
name|org_a
expr_stmt|;
name|cur_ab
operator|=
name|first
operator|->
name|cur_u
operator|-
name|cur_a
expr_stmt|;
block|}
name|scale_ab
operator|=
literal|0x10000L
expr_stmt|;
if|if
condition|(
name|org_ab
operator|>
literal|0
condition|)
name|scale_ab
operator|=
name|FT_DivFix
argument_list|(
name|cur_ab
argument_list|,
name|org_ab
argument_list|)
expr_stmt|;
name|point
operator|=
name|first
operator|->
name|next
expr_stmt|;
do|do
block|{
name|org_c
operator|=
name|point
operator|->
name|org_u
expr_stmt|;
name|org_ac
operator|=
name|org_c
operator|-
name|org_a
expr_stmt|;
if|if
condition|(
name|org_ac
operator|<=
literal|0
condition|)
block|{
comment|/* on the left of the interpolation zone */
name|cur_c
operator|=
name|cur_a
operator|+
name|FT_MulFix
argument_list|(
name|org_ac
argument_list|,
name|scale
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|org_ac
operator|>=
name|org_ab
condition|)
block|{
comment|/* on the right on the interpolation zone */
name|cur_c
operator|=
name|cur_a
operator|+
name|cur_ab
operator|+
name|FT_MulFix
argument_list|(
name|org_ac
operator|-
name|org_ab
argument_list|,
name|scale
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* within the interpolation zone */
name|cur_c
operator|=
name|cur_a
operator|+
name|FT_MulFix
argument_list|(
name|org_ac
argument_list|,
name|scale_ab
argument_list|)
expr_stmt|;
block|}
name|point
operator|->
name|cur_u
operator|=
name|cur_c
expr_stmt|;
name|point
operator|=
name|point
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|point
operator|!=
name|next
condition|)
do|;
block|}
comment|/* keep going until all points in the contours have been processed */
name|first
operator|=
name|next
expr_stmt|;
block|}
do|while
condition|(
name|first
operator|!=
name|start
condition|)
do|;
name|Next_Contour
label|:
empty_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****                     HIGH-LEVEL INTERFACE                      *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_function
name|FT_Error
DECL|function|ps_hints_apply
name|ps_hints_apply
parameter_list|(
name|PS_Hints
name|ps_hints
parameter_list|,
name|FT_Outline
modifier|*
name|outline
parameter_list|,
name|PSH_Globals
name|globals
parameter_list|,
name|FT_Render_Mode
name|hint_mode
parameter_list|)
block|{
name|PSH_GlyphRec
name|glyphrec
decl_stmt|;
name|PSH_Glyph
name|glyph
init|=
operator|&
name|glyphrec
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_HINTER
name|FT_Memory
name|memory
decl_stmt|;
endif|#
directive|endif
name|FT_Int
name|dimension
decl_stmt|;
comment|/* something to do? */
if|if
condition|(
name|outline
operator|->
name|n_points
operator|==
literal|0
operator|||
name|outline
operator|->
name|n_contours
operator|==
literal|0
condition|)
return|return
name|PSH_Err_Ok
return|;
ifdef|#
directive|ifdef
name|DEBUG_HINTER
name|memory
operator|=
name|globals
operator|->
name|memory
expr_stmt|;
if|if
condition|(
name|ps_debug_glyph
condition|)
block|{
name|psh_glyph_done
argument_list|(
name|ps_debug_glyph
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|ps_debug_glyph
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|FT_NEW
argument_list|(
name|glyph
argument_list|)
condition|)
return|return
name|error
return|;
name|ps_debug_glyph
operator|=
name|glyph
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG_HINTER */
name|error
operator|=
name|psh_glyph_init
argument_list|(
name|glyph
argument_list|,
name|outline
argument_list|,
name|ps_hints
argument_list|,
name|globals
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
comment|/* try to optimize the y_scale so that the top of non-capital letters      * is aligned on a pixel boundary whenever possible      */
block|{
name|PSH_Dimension
name|dim_x
init|=
operator|&
name|glyph
operator|->
name|globals
operator|->
name|dimension
index|[
literal|0
index|]
decl_stmt|;
name|PSH_Dimension
name|dim_y
init|=
operator|&
name|glyph
operator|->
name|globals
operator|->
name|dimension
index|[
literal|1
index|]
decl_stmt|;
name|FT_Fixed
name|x_scale
init|=
name|dim_x
operator|->
name|scale_mult
decl_stmt|;
name|FT_Fixed
name|y_scale
init|=
name|dim_y
operator|->
name|scale_mult
decl_stmt|;
name|FT_Fixed
name|old_x_scale
init|=
name|x_scale
decl_stmt|;
name|FT_Fixed
name|old_y_scale
init|=
name|y_scale
decl_stmt|;
name|FT_Fixed
name|scaled
decl_stmt|;
name|FT_Fixed
name|fitted
decl_stmt|;
name|FT_Bool
name|rescale
init|=
name|FALSE
decl_stmt|;
name|scaled
operator|=
name|FT_MulFix
argument_list|(
name|globals
operator|->
name|blues
operator|.
name|normal_top
operator|.
name|zones
operator|->
name|org_ref
argument_list|,
name|y_scale
argument_list|)
expr_stmt|;
name|fitted
operator|=
name|FT_PIX_ROUND
argument_list|(
name|scaled
argument_list|)
expr_stmt|;
if|if
condition|(
name|fitted
operator|!=
literal|0
operator|&&
name|scaled
operator|!=
name|fitted
condition|)
block|{
name|rescale
operator|=
name|TRUE
expr_stmt|;
name|y_scale
operator|=
name|FT_MulDiv
argument_list|(
name|y_scale
argument_list|,
name|fitted
argument_list|,
name|scaled
argument_list|)
expr_stmt|;
if|if
condition|(
name|fitted
operator|<
name|scaled
condition|)
name|x_scale
operator|-=
name|x_scale
operator|/
literal|50
expr_stmt|;
name|psh_globals_set_scale
argument_list|(
name|glyph
operator|->
name|globals
argument_list|,
name|x_scale
argument_list|,
name|y_scale
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|glyph
operator|->
name|do_horz_hints
operator|=
literal|1
expr_stmt|;
name|glyph
operator|->
name|do_vert_hints
operator|=
literal|1
expr_stmt|;
name|glyph
operator|->
name|do_horz_snapping
operator|=
name|FT_BOOL
argument_list|(
name|hint_mode
operator|==
name|FT_RENDER_MODE_MONO
operator|||
name|hint_mode
operator|==
name|FT_RENDER_MODE_LCD
argument_list|)
expr_stmt|;
name|glyph
operator|->
name|do_vert_snapping
operator|=
name|FT_BOOL
argument_list|(
name|hint_mode
operator|==
name|FT_RENDER_MODE_MONO
operator|||
name|hint_mode
operator|==
name|FT_RENDER_MODE_LCD_V
argument_list|)
expr_stmt|;
name|glyph
operator|->
name|do_stem_adjust
operator|=
name|FT_BOOL
argument_list|(
name|hint_mode
operator|!=
name|FT_RENDER_MODE_LIGHT
argument_list|)
expr_stmt|;
for|for
control|(
name|dimension
operator|=
literal|0
init|;
name|dimension
operator|<
literal|2
condition|;
name|dimension
operator|++
control|)
block|{
comment|/* load outline coordinates into glyph */
name|psh_glyph_load_points
argument_list|(
name|glyph
argument_list|,
name|dimension
argument_list|)
expr_stmt|;
comment|/* compute local extrema */
name|psh_glyph_compute_extrema
argument_list|(
name|glyph
argument_list|)
expr_stmt|;
comment|/* compute aligned stem/hints positions */
name|psh_hint_table_align_hints
argument_list|(
operator|&
name|glyph
operator|->
name|hint_tables
index|[
name|dimension
index|]
argument_list|,
name|glyph
operator|->
name|globals
argument_list|,
name|dimension
argument_list|,
name|glyph
argument_list|)
expr_stmt|;
comment|/* find strong points, align them, then interpolate others */
name|psh_glyph_find_strong_points
argument_list|(
name|glyph
argument_list|,
name|dimension
argument_list|)
expr_stmt|;
if|if
condition|(
name|dimension
operator|==
literal|1
condition|)
name|psh_glyph_find_blue_points
argument_list|(
operator|&
name|globals
operator|->
name|blues
argument_list|,
name|glyph
argument_list|)
expr_stmt|;
name|psh_glyph_interpolate_strong_points
argument_list|(
name|glyph
argument_list|,
name|dimension
argument_list|)
expr_stmt|;
name|psh_glyph_interpolate_normal_points
argument_list|(
name|glyph
argument_list|,
name|dimension
argument_list|)
expr_stmt|;
name|psh_glyph_interpolate_other_points
argument_list|(
name|glyph
argument_list|,
name|dimension
argument_list|)
expr_stmt|;
comment|/* save hinted coordinates back to outline */
name|psh_glyph_save_points
argument_list|(
name|glyph
argument_list|,
name|dimension
argument_list|)
expr_stmt|;
if|if
condition|(
name|rescale
condition|)
name|psh_globals_set_scale
argument_list|(
name|glyph
operator|->
name|globals
argument_list|,
name|old_x_scale
argument_list|,
name|old_y_scale
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|Exit
label|:
ifndef|#
directive|ifndef
name|DEBUG_HINTER
name|psh_glyph_done
argument_list|(
name|glyph
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|error
return|;
block|}
end_function
begin_comment
comment|/* END */
end_comment
end_unit
