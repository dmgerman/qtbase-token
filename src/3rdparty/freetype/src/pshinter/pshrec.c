begin_unit
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  pshrec.c                                                               */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*    FreeType PostScript hints recorder (body).                           */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  Copyright 2001, 2002, 2003, 2004, 2007, 2009 by                        */
end_comment
begin_comment
comment|/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  This file is part of the FreeType project, and may only be used,       */
end_comment
begin_comment
comment|/*  modified, and distributed under the terms of the FreeType project      */
end_comment
begin_comment
comment|/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
end_comment
begin_comment
comment|/*  this file you indicate that you have read the license and              */
end_comment
begin_comment
comment|/*  understand and accept it fully.                                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<ft2build.h>
end_include
begin_include
include|#
directive|include
include|FT_FREETYPE_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_OBJECTS_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_DEBUG_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_CALC_H
end_include
begin_include
include|#
directive|include
file|"pshrec.h"
end_include
begin_include
include|#
directive|include
file|"pshalgo.h"
end_include
begin_include
include|#
directive|include
file|"pshnterr.h"
end_include
begin_undef
DECL|macro|FT_COMPONENT
undef|#
directive|undef
name|FT_COMPONENT
end_undef
begin_define
DECL|macro|FT_COMPONENT
define|#
directive|define
name|FT_COMPONENT
value|trace_pshrec
end_define
begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG_HINTER
end_ifdef
begin_decl_stmt
DECL|variable|ps_debug_hints
name|PS_Hints
name|ps_debug_hints
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|ps_debug_no_horz_hints
name|int
name|ps_debug_no_horz_hints
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|ps_debug_no_vert_hints
name|int
name|ps_debug_no_vert_hints
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****                      PS_HINT MANAGEMENT                       *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/* destroy hints table */
end_comment
begin_function
specifier|static
name|void
DECL|function|ps_hint_table_done
name|ps_hint_table_done
parameter_list|(
name|PS_Hint_Table
name|table
parameter_list|,
name|FT_Memory
name|memory
parameter_list|)
block|{
name|FT_FREE
argument_list|(
name|table
operator|->
name|hints
argument_list|)
expr_stmt|;
name|table
operator|->
name|num_hints
operator|=
literal|0
expr_stmt|;
name|table
operator|->
name|max_hints
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_comment
comment|/* ensure that a table can contain "count" elements */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|ps_hint_table_ensure
name|ps_hint_table_ensure
parameter_list|(
name|PS_Hint_Table
name|table
parameter_list|,
name|FT_UInt
name|count
parameter_list|,
name|FT_Memory
name|memory
parameter_list|)
block|{
name|FT_UInt
name|old_max
init|=
name|table
operator|->
name|max_hints
decl_stmt|;
name|FT_UInt
name|new_max
init|=
name|count
decl_stmt|;
name|FT_Error
name|error
init|=
name|PSH_Err_Ok
decl_stmt|;
if|if
condition|(
name|new_max
operator|>
name|old_max
condition|)
block|{
comment|/* try to grow the table */
name|new_max
operator|=
name|FT_PAD_CEIL
argument_list|(
name|new_max
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|FT_RENEW_ARRAY
argument_list|(
name|table
operator|->
name|hints
argument_list|,
name|old_max
argument_list|,
name|new_max
argument_list|)
condition|)
name|table
operator|->
name|max_hints
operator|=
name|new_max
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|ps_hint_table_alloc
name|ps_hint_table_alloc
parameter_list|(
name|PS_Hint_Table
name|table
parameter_list|,
name|FT_Memory
name|memory
parameter_list|,
name|PS_Hint
modifier|*
name|ahint
parameter_list|)
block|{
name|FT_Error
name|error
init|=
name|PSH_Err_Ok
decl_stmt|;
name|FT_UInt
name|count
decl_stmt|;
name|PS_Hint
name|hint
init|=
literal|0
decl_stmt|;
name|count
operator|=
name|table
operator|->
name|num_hints
expr_stmt|;
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|count
operator|>=
name|table
operator|->
name|max_hints
condition|)
block|{
name|error
operator|=
name|ps_hint_table_ensure
argument_list|(
name|table
argument_list|,
name|count
argument_list|,
name|memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
block|}
name|hint
operator|=
name|table
operator|->
name|hints
operator|+
name|count
operator|-
literal|1
expr_stmt|;
name|hint
operator|->
name|pos
operator|=
literal|0
expr_stmt|;
name|hint
operator|->
name|len
operator|=
literal|0
expr_stmt|;
name|hint
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|table
operator|->
name|num_hints
operator|=
name|count
expr_stmt|;
name|Exit
label|:
operator|*
name|ahint
operator|=
name|hint
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****                      PS_MASK MANAGEMENT                       *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/* destroy mask */
end_comment
begin_function
specifier|static
name|void
DECL|function|ps_mask_done
name|ps_mask_done
parameter_list|(
name|PS_Mask
name|mask
parameter_list|,
name|FT_Memory
name|memory
parameter_list|)
block|{
name|FT_FREE
argument_list|(
name|mask
operator|->
name|bytes
argument_list|)
expr_stmt|;
name|mask
operator|->
name|num_bits
operator|=
literal|0
expr_stmt|;
name|mask
operator|->
name|max_bits
operator|=
literal|0
expr_stmt|;
name|mask
operator|->
name|end_point
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_comment
comment|/* ensure that a mask can contain "count" bits */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|ps_mask_ensure
name|ps_mask_ensure
parameter_list|(
name|PS_Mask
name|mask
parameter_list|,
name|FT_UInt
name|count
parameter_list|,
name|FT_Memory
name|memory
parameter_list|)
block|{
name|FT_UInt
name|old_max
init|=
operator|(
name|mask
operator|->
name|max_bits
operator|+
literal|7
operator|)
operator|>>
literal|3
decl_stmt|;
name|FT_UInt
name|new_max
init|=
operator|(
name|count
operator|+
literal|7
operator|)
operator|>>
literal|3
decl_stmt|;
name|FT_Error
name|error
init|=
name|PSH_Err_Ok
decl_stmt|;
if|if
condition|(
name|new_max
operator|>
name|old_max
condition|)
block|{
name|new_max
operator|=
name|FT_PAD_CEIL
argument_list|(
name|new_max
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|FT_RENEW_ARRAY
argument_list|(
name|mask
operator|->
name|bytes
argument_list|,
name|old_max
argument_list|,
name|new_max
argument_list|)
condition|)
name|mask
operator|->
name|max_bits
operator|=
name|new_max
operator|*
literal|8
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function
begin_comment
comment|/* test a bit value in a given mask */
end_comment
begin_function
specifier|static
name|FT_Int
DECL|function|ps_mask_test_bit
name|ps_mask_test_bit
parameter_list|(
name|PS_Mask
name|mask
parameter_list|,
name|FT_Int
name|idx
parameter_list|)
block|{
if|if
condition|(
operator|(
name|FT_UInt
operator|)
name|idx
operator|>=
name|mask
operator|->
name|num_bits
condition|)
return|return
literal|0
return|;
return|return
name|mask
operator|->
name|bytes
index|[
name|idx
operator|>>
literal|3
index|]
operator|&
operator|(
literal|0x80
operator|>>
operator|(
name|idx
operator|&
literal|7
operator|)
operator|)
return|;
block|}
end_function
begin_comment
comment|/* clear a given bit */
end_comment
begin_function
specifier|static
name|void
DECL|function|ps_mask_clear_bit
name|ps_mask_clear_bit
parameter_list|(
name|PS_Mask
name|mask
parameter_list|,
name|FT_Int
name|idx
parameter_list|)
block|{
name|FT_Byte
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|FT_UInt
operator|)
name|idx
operator|>=
name|mask
operator|->
name|num_bits
condition|)
return|return;
name|p
operator|=
name|mask
operator|->
name|bytes
operator|+
operator|(
name|idx
operator|>>
literal|3
operator|)
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|=
call|(
name|FT_Byte
call|)
argument_list|(
name|p
index|[
literal|0
index|]
operator|&
operator|~
operator|(
literal|0x80
operator|>>
operator|(
name|idx
operator|&
literal|7
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* set a given bit, possibly grow the mask */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|ps_mask_set_bit
name|ps_mask_set_bit
parameter_list|(
name|PS_Mask
name|mask
parameter_list|,
name|FT_Int
name|idx
parameter_list|,
name|FT_Memory
name|memory
parameter_list|)
block|{
name|FT_Error
name|error
init|=
name|PSH_Err_Ok
decl_stmt|;
name|FT_Byte
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|idx
operator|<
literal|0
condition|)
goto|goto
name|Exit
goto|;
if|if
condition|(
operator|(
name|FT_UInt
operator|)
name|idx
operator|>=
name|mask
operator|->
name|num_bits
condition|)
block|{
name|error
operator|=
name|ps_mask_ensure
argument_list|(
name|mask
argument_list|,
name|idx
operator|+
literal|1
argument_list|,
name|memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|mask
operator|->
name|num_bits
operator|=
name|idx
operator|+
literal|1
expr_stmt|;
block|}
name|p
operator|=
name|mask
operator|->
name|bytes
operator|+
operator|(
name|idx
operator|>>
literal|3
operator|)
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|=
call|(
name|FT_Byte
call|)
argument_list|(
name|p
index|[
literal|0
index|]
operator||
operator|(
literal|0x80
operator|>>
operator|(
name|idx
operator|&
literal|7
operator|)
operator|)
argument_list|)
expr_stmt|;
name|Exit
label|:
return|return
name|error
return|;
block|}
end_function
begin_comment
comment|/* destroy mask table */
end_comment
begin_function
specifier|static
name|void
DECL|function|ps_mask_table_done
name|ps_mask_table_done
parameter_list|(
name|PS_Mask_Table
name|table
parameter_list|,
name|FT_Memory
name|memory
parameter_list|)
block|{
name|FT_UInt
name|count
init|=
name|table
operator|->
name|max_masks
decl_stmt|;
name|PS_Mask
name|mask
init|=
name|table
operator|->
name|masks
decl_stmt|;
for|for
control|(
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
operator|,
name|mask
operator|++
control|)
name|ps_mask_done
argument_list|(
name|mask
argument_list|,
name|memory
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|table
operator|->
name|masks
argument_list|)
expr_stmt|;
name|table
operator|->
name|num_masks
operator|=
literal|0
expr_stmt|;
name|table
operator|->
name|max_masks
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_comment
comment|/* ensure that a mask table can contain "count" masks */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|ps_mask_table_ensure
name|ps_mask_table_ensure
parameter_list|(
name|PS_Mask_Table
name|table
parameter_list|,
name|FT_UInt
name|count
parameter_list|,
name|FT_Memory
name|memory
parameter_list|)
block|{
name|FT_UInt
name|old_max
init|=
name|table
operator|->
name|max_masks
decl_stmt|;
name|FT_UInt
name|new_max
init|=
name|count
decl_stmt|;
name|FT_Error
name|error
init|=
name|PSH_Err_Ok
decl_stmt|;
if|if
condition|(
name|new_max
operator|>
name|old_max
condition|)
block|{
name|new_max
operator|=
name|FT_PAD_CEIL
argument_list|(
name|new_max
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|FT_RENEW_ARRAY
argument_list|(
name|table
operator|->
name|masks
argument_list|,
name|old_max
argument_list|,
name|new_max
argument_list|)
condition|)
name|table
operator|->
name|max_masks
operator|=
name|new_max
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function
begin_comment
comment|/* allocate a new mask in a table */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|ps_mask_table_alloc
name|ps_mask_table_alloc
parameter_list|(
name|PS_Mask_Table
name|table
parameter_list|,
name|FT_Memory
name|memory
parameter_list|,
name|PS_Mask
modifier|*
name|amask
parameter_list|)
block|{
name|FT_UInt
name|count
decl_stmt|;
name|FT_Error
name|error
init|=
name|PSH_Err_Ok
decl_stmt|;
name|PS_Mask
name|mask
init|=
literal|0
decl_stmt|;
name|count
operator|=
name|table
operator|->
name|num_masks
expr_stmt|;
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|count
operator|>
name|table
operator|->
name|max_masks
condition|)
block|{
name|error
operator|=
name|ps_mask_table_ensure
argument_list|(
name|table
argument_list|,
name|count
argument_list|,
name|memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
block|}
name|mask
operator|=
name|table
operator|->
name|masks
operator|+
name|count
operator|-
literal|1
expr_stmt|;
name|mask
operator|->
name|num_bits
operator|=
literal|0
expr_stmt|;
name|mask
operator|->
name|end_point
operator|=
literal|0
expr_stmt|;
name|table
operator|->
name|num_masks
operator|=
name|count
expr_stmt|;
name|Exit
label|:
operator|*
name|amask
operator|=
name|mask
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_comment
comment|/* return last hint mask in a table, create one if the table is empty */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|ps_mask_table_last
name|ps_mask_table_last
parameter_list|(
name|PS_Mask_Table
name|table
parameter_list|,
name|FT_Memory
name|memory
parameter_list|,
name|PS_Mask
modifier|*
name|amask
parameter_list|)
block|{
name|FT_Error
name|error
init|=
name|PSH_Err_Ok
decl_stmt|;
name|FT_UInt
name|count
decl_stmt|;
name|PS_Mask
name|mask
decl_stmt|;
name|count
operator|=
name|table
operator|->
name|num_masks
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|ps_mask_table_alloc
argument_list|(
name|table
argument_list|,
name|memory
argument_list|,
operator|&
name|mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
block|}
else|else
name|mask
operator|=
name|table
operator|->
name|masks
operator|+
name|count
operator|-
literal|1
expr_stmt|;
name|Exit
label|:
operator|*
name|amask
operator|=
name|mask
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_comment
comment|/* set a new mask to a given bit range */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|ps_mask_table_set_bits
name|ps_mask_table_set_bits
parameter_list|(
name|PS_Mask_Table
name|table
parameter_list|,
specifier|const
name|FT_Byte
modifier|*
name|source
parameter_list|,
name|FT_UInt
name|bit_pos
parameter_list|,
name|FT_UInt
name|bit_count
parameter_list|,
name|FT_Memory
name|memory
parameter_list|)
block|{
name|FT_Error
name|error
init|=
name|PSH_Err_Ok
decl_stmt|;
name|PS_Mask
name|mask
decl_stmt|;
name|error
operator|=
name|ps_mask_table_last
argument_list|(
name|table
argument_list|,
name|memory
argument_list|,
operator|&
name|mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|error
operator|=
name|ps_mask_ensure
argument_list|(
name|mask
argument_list|,
name|bit_count
argument_list|,
name|memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|mask
operator|->
name|num_bits
operator|=
name|bit_count
expr_stmt|;
comment|/* now, copy bits */
block|{
name|FT_Byte
modifier|*
name|read
init|=
operator|(
name|FT_Byte
operator|*
operator|)
name|source
operator|+
operator|(
name|bit_pos
operator|>>
literal|3
operator|)
decl_stmt|;
name|FT_Int
name|rmask
init|=
literal|0x80
operator|>>
operator|(
name|bit_pos
operator|&
literal|7
operator|)
decl_stmt|;
name|FT_Byte
modifier|*
name|write
init|=
name|mask
operator|->
name|bytes
decl_stmt|;
name|FT_Int
name|wmask
init|=
literal|0x80
decl_stmt|;
name|FT_Int
name|val
decl_stmt|;
for|for
control|(
init|;
name|bit_count
operator|>
literal|0
condition|;
name|bit_count
operator|--
control|)
block|{
name|val
operator|=
name|write
index|[
literal|0
index|]
operator|&
operator|~
name|wmask
expr_stmt|;
if|if
condition|(
name|read
index|[
literal|0
index|]
operator|&
name|rmask
condition|)
name|val
operator||=
name|wmask
expr_stmt|;
name|write
index|[
literal|0
index|]
operator|=
operator|(
name|FT_Byte
operator|)
name|val
expr_stmt|;
name|rmask
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|rmask
operator|==
literal|0
condition|)
block|{
name|read
operator|++
expr_stmt|;
name|rmask
operator|=
literal|0x80
expr_stmt|;
block|}
name|wmask
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|wmask
operator|==
literal|0
condition|)
block|{
name|write
operator|++
expr_stmt|;
name|wmask
operator|=
literal|0x80
expr_stmt|;
block|}
block|}
block|}
name|Exit
label|:
return|return
name|error
return|;
block|}
end_function
begin_comment
comment|/* test whether two masks in a table intersect */
end_comment
begin_function
specifier|static
name|FT_Int
DECL|function|ps_mask_table_test_intersect
name|ps_mask_table_test_intersect
parameter_list|(
name|PS_Mask_Table
name|table
parameter_list|,
name|FT_Int
name|index1
parameter_list|,
name|FT_Int
name|index2
parameter_list|)
block|{
name|PS_Mask
name|mask1
init|=
name|table
operator|->
name|masks
operator|+
name|index1
decl_stmt|;
name|PS_Mask
name|mask2
init|=
name|table
operator|->
name|masks
operator|+
name|index2
decl_stmt|;
name|FT_Byte
modifier|*
name|p1
init|=
name|mask1
operator|->
name|bytes
decl_stmt|;
name|FT_Byte
modifier|*
name|p2
init|=
name|mask2
operator|->
name|bytes
decl_stmt|;
name|FT_UInt
name|count1
init|=
name|mask1
operator|->
name|num_bits
decl_stmt|;
name|FT_UInt
name|count2
init|=
name|mask2
operator|->
name|num_bits
decl_stmt|;
name|FT_UInt
name|count
decl_stmt|;
name|count
operator|=
operator|(
name|count1
operator|<=
name|count2
operator|)
condition|?
name|count1
else|:
name|count2
expr_stmt|;
for|for
control|(
init|;
name|count
operator|>=
literal|8
condition|;
name|count
operator|-=
literal|8
control|)
block|{
if|if
condition|(
name|p1
index|[
literal|0
index|]
operator|&
name|p2
index|[
literal|0
index|]
condition|)
return|return
literal|1
return|;
name|p1
operator|++
expr_stmt|;
name|p2
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|p1
index|[
literal|0
index|]
operator|&
name|p2
index|[
literal|0
index|]
operator|)
operator|&
operator|~
operator|(
literal|0xFF
operator|>>
name|count
operator|)
return|;
block|}
end_function
begin_comment
comment|/* merge two masks, used by ps_mask_table_merge_all */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|ps_mask_table_merge
name|ps_mask_table_merge
parameter_list|(
name|PS_Mask_Table
name|table
parameter_list|,
name|FT_Int
name|index1
parameter_list|,
name|FT_Int
name|index2
parameter_list|,
name|FT_Memory
name|memory
parameter_list|)
block|{
name|FT_UInt
name|temp
decl_stmt|;
name|FT_Error
name|error
init|=
name|PSH_Err_Ok
decl_stmt|;
comment|/* swap index1 and index2 so that index1< index2 */
if|if
condition|(
name|index1
operator|>
name|index2
condition|)
block|{
name|temp
operator|=
name|index1
expr_stmt|;
name|index1
operator|=
name|index2
expr_stmt|;
name|index2
operator|=
name|temp
expr_stmt|;
block|}
if|if
condition|(
name|index1
operator|<
name|index2
operator|&&
name|index1
operator|>=
literal|0
operator|&&
name|index2
operator|<
operator|(
name|FT_Int
operator|)
name|table
operator|->
name|num_masks
condition|)
block|{
comment|/* we need to merge the bitsets of index1 and index2 with a */
comment|/* simple union                                             */
name|PS_Mask
name|mask1
init|=
name|table
operator|->
name|masks
operator|+
name|index1
decl_stmt|;
name|PS_Mask
name|mask2
init|=
name|table
operator|->
name|masks
operator|+
name|index2
decl_stmt|;
name|FT_UInt
name|count1
init|=
name|mask1
operator|->
name|num_bits
decl_stmt|;
name|FT_UInt
name|count2
init|=
name|mask2
operator|->
name|num_bits
decl_stmt|;
name|FT_Int
name|delta
decl_stmt|;
if|if
condition|(
name|count2
operator|>
literal|0
condition|)
block|{
name|FT_UInt
name|pos
decl_stmt|;
name|FT_Byte
modifier|*
name|read
decl_stmt|;
name|FT_Byte
modifier|*
name|write
decl_stmt|;
comment|/* if "count2" is greater than "count1", we need to grow the */
comment|/* first bitset, and clear the highest bits                  */
if|if
condition|(
name|count2
operator|>
name|count1
condition|)
block|{
name|error
operator|=
name|ps_mask_ensure
argument_list|(
name|mask1
argument_list|,
name|count2
argument_list|,
name|memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
for|for
control|(
name|pos
operator|=
name|count1
init|;
name|pos
operator|<
name|count2
condition|;
name|pos
operator|++
control|)
name|ps_mask_clear_bit
argument_list|(
name|mask1
argument_list|,
name|pos
argument_list|)
expr_stmt|;
block|}
comment|/* merge (unite) the bitsets */
name|read
operator|=
name|mask2
operator|->
name|bytes
expr_stmt|;
name|write
operator|=
name|mask1
operator|->
name|bytes
expr_stmt|;
name|pos
operator|=
call|(
name|FT_UInt
call|)
argument_list|(
operator|(
name|count2
operator|+
literal|7
operator|)
operator|>>
literal|3
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|pos
operator|>
literal|0
condition|;
name|pos
operator|--
control|)
block|{
name|write
index|[
literal|0
index|]
operator|=
call|(
name|FT_Byte
call|)
argument_list|(
name|write
index|[
literal|0
index|]
operator||
name|read
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|write
operator|++
expr_stmt|;
name|read
operator|++
expr_stmt|;
block|}
block|}
comment|/* Now, remove "mask2" from the list.  We need to keep the masks */
comment|/* sorted in order of importance, so move table elements.        */
name|mask2
operator|->
name|num_bits
operator|=
literal|0
expr_stmt|;
name|mask2
operator|->
name|end_point
operator|=
literal|0
expr_stmt|;
name|delta
operator|=
name|table
operator|->
name|num_masks
operator|-
literal|1
operator|-
name|index2
expr_stmt|;
comment|/* number of masks to move */
if|if
condition|(
name|delta
operator|>
literal|0
condition|)
block|{
comment|/* move to end of table for reuse */
name|PS_MaskRec
name|dummy
init|=
operator|*
name|mask2
decl_stmt|;
name|ft_memmove
argument_list|(
name|mask2
argument_list|,
name|mask2
operator|+
literal|1
argument_list|,
name|delta
operator|*
sizeof|sizeof
argument_list|(
name|PS_MaskRec
argument_list|)
argument_list|)
expr_stmt|;
name|mask2
index|[
name|delta
index|]
operator|=
name|dummy
expr_stmt|;
block|}
name|table
operator|->
name|num_masks
operator|--
expr_stmt|;
block|}
else|else
name|FT_TRACE0
argument_list|(
operator|(
literal|"ps_mask_table_merge: ignoring invalid indices (%d,%d)\n"
operator|,
name|index1
operator|,
name|index2
operator|)
argument_list|)
expr_stmt|;
name|Exit
label|:
return|return
name|error
return|;
block|}
end_function
begin_comment
comment|/* Try to merge all masks in a given table.  This is used to merge */
end_comment
begin_comment
comment|/* all counter masks into independent counter "paths".             */
end_comment
begin_comment
comment|/*                                                                 */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|ps_mask_table_merge_all
name|ps_mask_table_merge_all
parameter_list|(
name|PS_Mask_Table
name|table
parameter_list|,
name|FT_Memory
name|memory
parameter_list|)
block|{
name|FT_Int
name|index1
decl_stmt|,
name|index2
decl_stmt|;
name|FT_Error
name|error
init|=
name|PSH_Err_Ok
decl_stmt|;
for|for
control|(
name|index1
operator|=
name|table
operator|->
name|num_masks
operator|-
literal|1
init|;
name|index1
operator|>
literal|0
condition|;
name|index1
operator|--
control|)
block|{
for|for
control|(
name|index2
operator|=
name|index1
operator|-
literal|1
init|;
name|index2
operator|>=
literal|0
condition|;
name|index2
operator|--
control|)
block|{
if|if
condition|(
name|ps_mask_table_test_intersect
argument_list|(
name|table
argument_list|,
name|index1
argument_list|,
name|index2
argument_list|)
condition|)
block|{
name|error
operator|=
name|ps_mask_table_merge
argument_list|(
name|table
argument_list|,
name|index2
argument_list|,
name|index1
argument_list|,
name|memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
break|break;
block|}
block|}
block|}
name|Exit
label|:
return|return
name|error
return|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****                    PS_DIMENSION MANAGEMENT                    *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/* finalize a given dimension */
end_comment
begin_function
specifier|static
name|void
DECL|function|ps_dimension_done
name|ps_dimension_done
parameter_list|(
name|PS_Dimension
name|dimension
parameter_list|,
name|FT_Memory
name|memory
parameter_list|)
block|{
name|ps_mask_table_done
argument_list|(
operator|&
name|dimension
operator|->
name|counters
argument_list|,
name|memory
argument_list|)
expr_stmt|;
name|ps_mask_table_done
argument_list|(
operator|&
name|dimension
operator|->
name|masks
argument_list|,
name|memory
argument_list|)
expr_stmt|;
name|ps_hint_table_done
argument_list|(
operator|&
name|dimension
operator|->
name|hints
argument_list|,
name|memory
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* initialize a given dimension */
end_comment
begin_function
specifier|static
name|void
DECL|function|ps_dimension_init
name|ps_dimension_init
parameter_list|(
name|PS_Dimension
name|dimension
parameter_list|)
block|{
name|dimension
operator|->
name|hints
operator|.
name|num_hints
operator|=
literal|0
expr_stmt|;
name|dimension
operator|->
name|masks
operator|.
name|num_masks
operator|=
literal|0
expr_stmt|;
name|dimension
operator|->
name|counters
operator|.
name|num_masks
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_if
if|#
directive|if
literal|0
end_if
begin_comment
comment|/* set a bit at a given index in the current hint mask */
end_comment
begin_comment
unit|static FT_Error   ps_dimension_set_mask_bit( PS_Dimension  dim,                              FT_UInt       idx,                              FT_Memory     memory )   {     PS_Mask   mask;     FT_Error  error = PSH_Err_Ok;
comment|/* get last hint mask */
end_comment
begin_endif
unit|error = ps_mask_table_last(&dim->masks, memory,&mask );     if ( error )       goto Exit;      error = ps_mask_set_bit( mask, idx, memory );    Exit:     return error;   }
endif|#
directive|endif
end_endif
begin_comment
comment|/* set the end point in a mask, called from "End"& "Reset" methods */
end_comment
begin_function
specifier|static
name|void
DECL|function|ps_dimension_end_mask
name|ps_dimension_end_mask
parameter_list|(
name|PS_Dimension
name|dim
parameter_list|,
name|FT_UInt
name|end_point
parameter_list|)
block|{
name|FT_UInt
name|count
init|=
name|dim
operator|->
name|masks
operator|.
name|num_masks
decl_stmt|;
name|PS_Mask
name|mask
decl_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|mask
operator|=
name|dim
operator|->
name|masks
operator|.
name|masks
operator|+
name|count
operator|-
literal|1
expr_stmt|;
name|mask
operator|->
name|end_point
operator|=
name|end_point
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/* set the end point in the current mask, then create a new empty one */
end_comment
begin_comment
comment|/* (called by "Reset" method)                                         */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|ps_dimension_reset_mask
name|ps_dimension_reset_mask
parameter_list|(
name|PS_Dimension
name|dim
parameter_list|,
name|FT_UInt
name|end_point
parameter_list|,
name|FT_Memory
name|memory
parameter_list|)
block|{
name|PS_Mask
name|mask
decl_stmt|;
comment|/* end current mask */
name|ps_dimension_end_mask
argument_list|(
name|dim
argument_list|,
name|end_point
argument_list|)
expr_stmt|;
comment|/* allocate new one */
return|return
name|ps_mask_table_alloc
argument_list|(
operator|&
name|dim
operator|->
name|masks
argument_list|,
name|memory
argument_list|,
operator|&
name|mask
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/* set a new mask, called from the "T2Stem" method */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|ps_dimension_set_mask_bits
name|ps_dimension_set_mask_bits
parameter_list|(
name|PS_Dimension
name|dim
parameter_list|,
specifier|const
name|FT_Byte
modifier|*
name|source
parameter_list|,
name|FT_UInt
name|source_pos
parameter_list|,
name|FT_UInt
name|source_bits
parameter_list|,
name|FT_UInt
name|end_point
parameter_list|,
name|FT_Memory
name|memory
parameter_list|)
block|{
name|FT_Error
name|error
init|=
name|PSH_Err_Ok
decl_stmt|;
comment|/* reset current mask, if any */
name|error
operator|=
name|ps_dimension_reset_mask
argument_list|(
name|dim
argument_list|,
name|end_point
argument_list|,
name|memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
comment|/* set bits in new mask */
name|error
operator|=
name|ps_mask_table_set_bits
argument_list|(
operator|&
name|dim
operator|->
name|masks
argument_list|,
name|source
argument_list|,
name|source_pos
argument_list|,
name|source_bits
argument_list|,
name|memory
argument_list|)
expr_stmt|;
name|Exit
label|:
return|return
name|error
return|;
block|}
end_function
begin_comment
comment|/* add a new single stem (called from "T1Stem" method) */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|ps_dimension_add_t1stem
name|ps_dimension_add_t1stem
parameter_list|(
name|PS_Dimension
name|dim
parameter_list|,
name|FT_Int
name|pos
parameter_list|,
name|FT_Int
name|len
parameter_list|,
name|FT_Memory
name|memory
parameter_list|,
name|FT_Int
modifier|*
name|aindex
parameter_list|)
block|{
name|FT_Error
name|error
init|=
name|PSH_Err_Ok
decl_stmt|;
name|FT_UInt
name|flags
init|=
literal|0
decl_stmt|;
comment|/* detect ghost stem */
if|if
condition|(
name|len
operator|<
literal|0
condition|)
block|{
name|flags
operator||=
name|PS_HINT_FLAG_GHOST
expr_stmt|;
if|if
condition|(
name|len
operator|==
operator|-
literal|21
condition|)
block|{
name|flags
operator||=
name|PS_HINT_FLAG_BOTTOM
expr_stmt|;
name|pos
operator|+=
name|len
expr_stmt|;
block|}
name|len
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|aindex
condition|)
operator|*
name|aindex
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* now, lookup stem in the current hints table */
block|{
name|PS_Mask
name|mask
decl_stmt|;
name|FT_UInt
name|idx
decl_stmt|;
name|FT_UInt
name|max
init|=
name|dim
operator|->
name|hints
operator|.
name|num_hints
decl_stmt|;
name|PS_Hint
name|hint
init|=
name|dim
operator|->
name|hints
operator|.
name|hints
decl_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|max
condition|;
name|idx
operator|++
operator|,
name|hint
operator|++
control|)
block|{
if|if
condition|(
name|hint
operator|->
name|pos
operator|==
name|pos
operator|&&
name|hint
operator|->
name|len
operator|==
name|len
condition|)
break|break;
block|}
comment|/* we need to create a new hint in the table */
if|if
condition|(
name|idx
operator|>=
name|max
condition|)
block|{
name|error
operator|=
name|ps_hint_table_alloc
argument_list|(
operator|&
name|dim
operator|->
name|hints
argument_list|,
name|memory
argument_list|,
operator|&
name|hint
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|hint
operator|->
name|pos
operator|=
name|pos
expr_stmt|;
name|hint
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|hint
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
block|}
comment|/* now, store the hint in the current mask */
name|error
operator|=
name|ps_mask_table_last
argument_list|(
operator|&
name|dim
operator|->
name|masks
argument_list|,
name|memory
argument_list|,
operator|&
name|mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|error
operator|=
name|ps_mask_set_bit
argument_list|(
name|mask
argument_list|,
name|idx
argument_list|,
name|memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
if|if
condition|(
name|aindex
condition|)
operator|*
name|aindex
operator|=
operator|(
name|FT_Int
operator|)
name|idx
expr_stmt|;
block|}
name|Exit
label|:
return|return
name|error
return|;
block|}
end_function
begin_comment
comment|/* add a "hstem3/vstem3" counter to our dimension table */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|ps_dimension_add_counter
name|ps_dimension_add_counter
parameter_list|(
name|PS_Dimension
name|dim
parameter_list|,
name|FT_Int
name|hint1
parameter_list|,
name|FT_Int
name|hint2
parameter_list|,
name|FT_Int
name|hint3
parameter_list|,
name|FT_Memory
name|memory
parameter_list|)
block|{
name|FT_Error
name|error
init|=
name|PSH_Err_Ok
decl_stmt|;
name|FT_UInt
name|count
init|=
name|dim
operator|->
name|counters
operator|.
name|num_masks
decl_stmt|;
name|PS_Mask
name|counter
init|=
name|dim
operator|->
name|counters
operator|.
name|masks
decl_stmt|;
comment|/* try to find an existing counter mask that already uses */
comment|/* one of these stems here                                */
for|for
control|(
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
operator|,
name|counter
operator|++
control|)
block|{
if|if
condition|(
name|ps_mask_test_bit
argument_list|(
name|counter
argument_list|,
name|hint1
argument_list|)
operator|||
name|ps_mask_test_bit
argument_list|(
name|counter
argument_list|,
name|hint2
argument_list|)
operator|||
name|ps_mask_test_bit
argument_list|(
name|counter
argument_list|,
name|hint3
argument_list|)
condition|)
break|break;
block|}
comment|/* create a new counter when needed */
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|ps_mask_table_alloc
argument_list|(
operator|&
name|dim
operator|->
name|counters
argument_list|,
name|memory
argument_list|,
operator|&
name|counter
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
block|}
comment|/* now, set the bits for our hints in the counter mask */
name|error
operator|=
name|ps_mask_set_bit
argument_list|(
name|counter
argument_list|,
name|hint1
argument_list|,
name|memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|error
operator|=
name|ps_mask_set_bit
argument_list|(
name|counter
argument_list|,
name|hint2
argument_list|,
name|memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|error
operator|=
name|ps_mask_set_bit
argument_list|(
name|counter
argument_list|,
name|hint3
argument_list|,
name|memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|Exit
label|:
return|return
name|error
return|;
block|}
end_function
begin_comment
comment|/* end of recording session for a given dimension */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|ps_dimension_end
name|ps_dimension_end
parameter_list|(
name|PS_Dimension
name|dim
parameter_list|,
name|FT_UInt
name|end_point
parameter_list|,
name|FT_Memory
name|memory
parameter_list|)
block|{
comment|/* end hint mask table */
name|ps_dimension_end_mask
argument_list|(
name|dim
argument_list|,
name|end_point
argument_list|)
expr_stmt|;
comment|/* merge all counter masks into independent "paths" */
return|return
name|ps_mask_table_merge_all
argument_list|(
operator|&
name|dim
operator|->
name|counters
argument_list|,
name|memory
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****                    PS_RECORDER MANAGEMENT                     *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/* destroy hints */
end_comment
begin_macro
name|FT_LOCAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|ps_hints_done
name|ps_hints_done
argument_list|(
argument|PS_Hints  hints
argument_list|)
end_macro
begin_block
block|{
name|FT_Memory
name|memory
init|=
name|hints
operator|->
name|memory
decl_stmt|;
name|ps_dimension_done
argument_list|(
operator|&
name|hints
operator|->
name|dimension
index|[
literal|0
index|]
argument_list|,
name|memory
argument_list|)
expr_stmt|;
name|ps_dimension_done
argument_list|(
operator|&
name|hints
operator|->
name|dimension
index|[
literal|1
index|]
argument_list|,
name|memory
argument_list|)
expr_stmt|;
name|hints
operator|->
name|error
operator|=
name|PSH_Err_Ok
expr_stmt|;
name|hints
operator|->
name|memory
operator|=
literal|0
expr_stmt|;
block|}
end_block
begin_macro
DECL|function|FT_LOCAL
name|FT_LOCAL
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|ps_hints_init
argument_list|(
argument|PS_Hints   hints
argument_list|,
argument|FT_Memory  memory
argument_list|)
end_macro
begin_block
block|{
name|FT_MEM_ZERO
argument_list|(
name|hints
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|hints
argument_list|)
argument_list|)
expr_stmt|;
name|hints
operator|->
name|memory
operator|=
name|memory
expr_stmt|;
return|return
name|PSH_Err_Ok
return|;
block|}
end_block
begin_comment
comment|/* initialize a hints for a new session */
end_comment
begin_function
specifier|static
name|void
DECL|function|ps_hints_open
name|ps_hints_open
parameter_list|(
name|PS_Hints
name|hints
parameter_list|,
name|PS_Hint_Type
name|hint_type
parameter_list|)
block|{
switch|switch
condition|(
name|hint_type
condition|)
block|{
case|case
name|PS_HINT_TYPE_1
case|:
case|case
name|PS_HINT_TYPE_2
case|:
name|hints
operator|->
name|error
operator|=
name|PSH_Err_Ok
expr_stmt|;
name|hints
operator|->
name|hint_type
operator|=
name|hint_type
expr_stmt|;
name|ps_dimension_init
argument_list|(
operator|&
name|hints
operator|->
name|dimension
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ps_dimension_init
argument_list|(
operator|&
name|hints
operator|->
name|dimension
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
default|default:
name|hints
operator|->
name|error
operator|=
name|PSH_Err_Invalid_Argument
expr_stmt|;
name|hints
operator|->
name|hint_type
operator|=
name|hint_type
expr_stmt|;
name|FT_TRACE0
argument_list|(
operator|(
literal|"ps_hints_open: invalid charstring type\n"
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function
begin_comment
comment|/* add one or more stems to the current hints table */
end_comment
begin_function
specifier|static
name|void
DECL|function|ps_hints_stem
name|ps_hints_stem
parameter_list|(
name|PS_Hints
name|hints
parameter_list|,
name|FT_Int
name|dimension
parameter_list|,
name|FT_UInt
name|count
parameter_list|,
name|FT_Long
modifier|*
name|stems
parameter_list|)
block|{
if|if
condition|(
operator|!
name|hints
operator|->
name|error
condition|)
block|{
comment|/* limit "dimension" to 0..1 */
if|if
condition|(
name|dimension
operator|<
literal|0
operator|||
name|dimension
operator|>
literal|1
condition|)
block|{
name|FT_TRACE0
argument_list|(
operator|(
literal|"ps_hints_stem: invalid dimension (%d) used\n"
operator|,
name|dimension
operator|)
argument_list|)
expr_stmt|;
name|dimension
operator|=
operator|(
name|dimension
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
comment|/* record the stems in the current hints/masks table */
switch|switch
condition|(
name|hints
operator|->
name|hint_type
condition|)
block|{
case|case
name|PS_HINT_TYPE_1
case|:
comment|/* Type 1 "hstem" or "vstem" operator */
case|case
name|PS_HINT_TYPE_2
case|:
comment|/* Type 2 "hstem" or "vstem" operator */
block|{
name|PS_Dimension
name|dim
init|=
operator|&
name|hints
operator|->
name|dimension
index|[
name|dimension
index|]
decl_stmt|;
for|for
control|(
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
operator|,
name|stems
operator|+=
literal|2
control|)
block|{
name|FT_Error
name|error
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|hints
operator|->
name|memory
decl_stmt|;
name|error
operator|=
name|ps_dimension_add_t1stem
argument_list|(
name|dim
argument_list|,
operator|(
name|FT_Int
operator|)
name|stems
index|[
literal|0
index|]
argument_list|,
operator|(
name|FT_Int
operator|)
name|stems
index|[
literal|1
index|]
argument_list|,
name|memory
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"ps_hints_stem: could not add stem"
literal|" (%d,%d) to hints table\n"
operator|,
name|stems
index|[
literal|0
index|]
operator|,
name|stems
index|[
literal|1
index|]
operator|)
argument_list|)
expr_stmt|;
name|hints
operator|->
name|error
operator|=
name|error
expr_stmt|;
return|return;
block|}
block|}
break|break;
block|}
default|default:
name|FT_TRACE0
argument_list|(
operator|(
literal|"ps_hints_stem: called with invalid hint type (%d)\n"
operator|,
name|hints
operator|->
name|hint_type
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function
begin_comment
comment|/* add one Type1 counter stem to the current hints table */
end_comment
begin_function
specifier|static
name|void
DECL|function|ps_hints_t1stem3
name|ps_hints_t1stem3
parameter_list|(
name|PS_Hints
name|hints
parameter_list|,
name|FT_Int
name|dimension
parameter_list|,
name|FT_Fixed
modifier|*
name|stems
parameter_list|)
block|{
name|FT_Error
name|error
init|=
name|PSH_Err_Ok
decl_stmt|;
if|if
condition|(
operator|!
name|hints
operator|->
name|error
condition|)
block|{
name|PS_Dimension
name|dim
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|hints
operator|->
name|memory
decl_stmt|;
name|FT_Int
name|count
decl_stmt|;
name|FT_Int
name|idx
index|[
literal|3
index|]
decl_stmt|;
comment|/* limit "dimension" to 0..1 */
if|if
condition|(
name|dimension
operator|<
literal|0
operator|||
name|dimension
operator|>
literal|1
condition|)
block|{
name|FT_TRACE0
argument_list|(
operator|(
literal|"ps_hints_t1stem3: invalid dimension (%d) used\n"
operator|,
name|dimension
operator|)
argument_list|)
expr_stmt|;
name|dimension
operator|=
operator|(
name|dimension
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
name|dim
operator|=
operator|&
name|hints
operator|->
name|dimension
index|[
name|dimension
index|]
expr_stmt|;
comment|/* there must be 6 elements in the 'stem' array */
if|if
condition|(
name|hints
operator|->
name|hint_type
operator|==
name|PS_HINT_TYPE_1
condition|)
block|{
comment|/* add the three stems to our hints/masks table */
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
literal|3
condition|;
name|count
operator|++
operator|,
name|stems
operator|+=
literal|2
control|)
block|{
name|error
operator|=
name|ps_dimension_add_t1stem
argument_list|(
name|dim
argument_list|,
operator|(
name|FT_Int
operator|)
name|FIXED_TO_INT
argument_list|(
name|stems
index|[
literal|0
index|]
argument_list|)
argument_list|,
operator|(
name|FT_Int
operator|)
name|FIXED_TO_INT
argument_list|(
name|stems
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|memory
argument_list|,
operator|&
name|idx
index|[
name|count
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Fail
goto|;
block|}
comment|/* now, add the hints to the counters table */
name|error
operator|=
name|ps_dimension_add_counter
argument_list|(
name|dim
argument_list|,
name|idx
index|[
literal|0
index|]
argument_list|,
name|idx
index|[
literal|1
index|]
argument_list|,
name|idx
index|[
literal|2
index|]
argument_list|,
name|memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Fail
goto|;
block|}
else|else
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"ps_hints_t1stem3: called with invalid hint type\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|PSH_Err_Invalid_Argument
expr_stmt|;
goto|goto
name|Fail
goto|;
block|}
block|}
return|return;
name|Fail
label|:
name|FT_ERROR
argument_list|(
operator|(
literal|"ps_hints_t1stem3: could not add counter stems to table\n"
operator|)
argument_list|)
expr_stmt|;
name|hints
operator|->
name|error
operator|=
name|error
expr_stmt|;
block|}
end_function
begin_comment
comment|/* reset hints (only with Type 1 hints) */
end_comment
begin_function
specifier|static
name|void
DECL|function|ps_hints_t1reset
name|ps_hints_t1reset
parameter_list|(
name|PS_Hints
name|hints
parameter_list|,
name|FT_UInt
name|end_point
parameter_list|)
block|{
name|FT_Error
name|error
init|=
name|PSH_Err_Ok
decl_stmt|;
if|if
condition|(
operator|!
name|hints
operator|->
name|error
condition|)
block|{
name|FT_Memory
name|memory
init|=
name|hints
operator|->
name|memory
decl_stmt|;
if|if
condition|(
name|hints
operator|->
name|hint_type
operator|==
name|PS_HINT_TYPE_1
condition|)
block|{
name|error
operator|=
name|ps_dimension_reset_mask
argument_list|(
operator|&
name|hints
operator|->
name|dimension
index|[
literal|0
index|]
argument_list|,
name|end_point
argument_list|,
name|memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Fail
goto|;
name|error
operator|=
name|ps_dimension_reset_mask
argument_list|(
operator|&
name|hints
operator|->
name|dimension
index|[
literal|1
index|]
argument_list|,
name|end_point
argument_list|,
name|memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Fail
goto|;
block|}
else|else
block|{
comment|/* invalid hint type */
name|error
operator|=
name|PSH_Err_Invalid_Argument
expr_stmt|;
goto|goto
name|Fail
goto|;
block|}
block|}
return|return;
name|Fail
label|:
name|hints
operator|->
name|error
operator|=
name|error
expr_stmt|;
block|}
end_function
begin_comment
comment|/* Type2 "hintmask" operator, add a new hintmask to each direction */
end_comment
begin_function
specifier|static
name|void
DECL|function|ps_hints_t2mask
name|ps_hints_t2mask
parameter_list|(
name|PS_Hints
name|hints
parameter_list|,
name|FT_UInt
name|end_point
parameter_list|,
name|FT_UInt
name|bit_count
parameter_list|,
specifier|const
name|FT_Byte
modifier|*
name|bytes
parameter_list|)
block|{
name|FT_Error
name|error
decl_stmt|;
if|if
condition|(
operator|!
name|hints
operator|->
name|error
condition|)
block|{
name|PS_Dimension
name|dim
init|=
name|hints
operator|->
name|dimension
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|hints
operator|->
name|memory
decl_stmt|;
name|FT_UInt
name|count1
init|=
name|dim
index|[
literal|0
index|]
operator|.
name|hints
operator|.
name|num_hints
decl_stmt|;
name|FT_UInt
name|count2
init|=
name|dim
index|[
literal|1
index|]
operator|.
name|hints
operator|.
name|num_hints
decl_stmt|;
comment|/* check bit count; must be equal to current total hint count */
if|if
condition|(
name|bit_count
operator|!=
name|count1
operator|+
name|count2
condition|)
block|{
name|FT_TRACE0
argument_list|(
operator|(
literal|"ps_hints_t2mask:"
literal|" called with invalid bitcount %d (instead of %d)\n"
operator|,
name|bit_count
operator|,
name|count1
operator|+
name|count2
operator|)
argument_list|)
expr_stmt|;
comment|/* simply ignore the operator */
return|return;
block|}
comment|/* set-up new horizontal and vertical hint mask now */
name|error
operator|=
name|ps_dimension_set_mask_bits
argument_list|(
operator|&
name|dim
index|[
literal|0
index|]
argument_list|,
name|bytes
argument_list|,
name|count2
argument_list|,
name|count1
argument_list|,
name|end_point
argument_list|,
name|memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Fail
goto|;
name|error
operator|=
name|ps_dimension_set_mask_bits
argument_list|(
operator|&
name|dim
index|[
literal|1
index|]
argument_list|,
name|bytes
argument_list|,
literal|0
argument_list|,
name|count2
argument_list|,
name|end_point
argument_list|,
name|memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Fail
goto|;
block|}
return|return;
name|Fail
label|:
name|hints
operator|->
name|error
operator|=
name|error
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|ps_hints_t2counter
name|ps_hints_t2counter
parameter_list|(
name|PS_Hints
name|hints
parameter_list|,
name|FT_UInt
name|bit_count
parameter_list|,
specifier|const
name|FT_Byte
modifier|*
name|bytes
parameter_list|)
block|{
name|FT_Error
name|error
decl_stmt|;
if|if
condition|(
operator|!
name|hints
operator|->
name|error
condition|)
block|{
name|PS_Dimension
name|dim
init|=
name|hints
operator|->
name|dimension
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|hints
operator|->
name|memory
decl_stmt|;
name|FT_UInt
name|count1
init|=
name|dim
index|[
literal|0
index|]
operator|.
name|hints
operator|.
name|num_hints
decl_stmt|;
name|FT_UInt
name|count2
init|=
name|dim
index|[
literal|1
index|]
operator|.
name|hints
operator|.
name|num_hints
decl_stmt|;
comment|/* check bit count, must be equal to current total hint count */
if|if
condition|(
name|bit_count
operator|!=
name|count1
operator|+
name|count2
condition|)
block|{
name|FT_TRACE0
argument_list|(
operator|(
literal|"ps_hints_t2counter:"
literal|" called with invalid bitcount %d (instead of %d)\n"
operator|,
name|bit_count
operator|,
name|count1
operator|+
name|count2
operator|)
argument_list|)
expr_stmt|;
comment|/* simply ignore the operator */
return|return;
block|}
comment|/* set-up new horizontal and vertical hint mask now */
name|error
operator|=
name|ps_dimension_set_mask_bits
argument_list|(
operator|&
name|dim
index|[
literal|0
index|]
argument_list|,
name|bytes
argument_list|,
literal|0
argument_list|,
name|count1
argument_list|,
literal|0
argument_list|,
name|memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Fail
goto|;
name|error
operator|=
name|ps_dimension_set_mask_bits
argument_list|(
operator|&
name|dim
index|[
literal|1
index|]
argument_list|,
name|bytes
argument_list|,
name|count1
argument_list|,
name|count2
argument_list|,
literal|0
argument_list|,
name|memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Fail
goto|;
block|}
return|return;
name|Fail
label|:
name|hints
operator|->
name|error
operator|=
name|error
expr_stmt|;
block|}
end_function
begin_comment
comment|/* end recording session */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|ps_hints_close
name|ps_hints_close
parameter_list|(
name|PS_Hints
name|hints
parameter_list|,
name|FT_UInt
name|end_point
parameter_list|)
block|{
name|FT_Error
name|error
decl_stmt|;
name|error
operator|=
name|hints
operator|->
name|error
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|FT_Memory
name|memory
init|=
name|hints
operator|->
name|memory
decl_stmt|;
name|PS_Dimension
name|dim
init|=
name|hints
operator|->
name|dimension
decl_stmt|;
name|error
operator|=
name|ps_dimension_end
argument_list|(
operator|&
name|dim
index|[
literal|0
index|]
argument_list|,
name|end_point
argument_list|,
name|memory
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|error
operator|=
name|ps_dimension_end
argument_list|(
operator|&
name|dim
index|[
literal|1
index|]
argument_list|,
name|end_point
argument_list|,
name|memory
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUG_HINTER
if|if
condition|(
operator|!
name|error
condition|)
name|ps_debug_hints
operator|=
name|hints
expr_stmt|;
endif|#
directive|endif
return|return
name|error
return|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****                TYPE 1 HINTS RECORDING INTERFACE               *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_function
specifier|static
name|void
DECL|function|t1_hints_open
name|t1_hints_open
parameter_list|(
name|T1_Hints
name|hints
parameter_list|)
block|{
name|ps_hints_open
argument_list|(
operator|(
name|PS_Hints
operator|)
name|hints
argument_list|,
name|PS_HINT_TYPE_1
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|t1_hints_stem
name|t1_hints_stem
parameter_list|(
name|T1_Hints
name|hints
parameter_list|,
name|FT_Int
name|dimension
parameter_list|,
name|FT_Fixed
modifier|*
name|coords
parameter_list|)
block|{
name|FT_Pos
name|stems
index|[
literal|2
index|]
decl_stmt|;
name|stems
index|[
literal|0
index|]
operator|=
name|FIXED_TO_INT
argument_list|(
name|coords
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|stems
index|[
literal|1
index|]
operator|=
name|FIXED_TO_INT
argument_list|(
name|coords
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ps_hints_stem
argument_list|(
operator|(
name|PS_Hints
operator|)
name|hints
argument_list|,
name|dimension
argument_list|,
literal|1
argument_list|,
name|stems
argument_list|)
expr_stmt|;
block|}
end_function
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|t1_hints_funcs_init
name|t1_hints_funcs_init
argument_list|(
argument|T1_Hints_FuncsRec*  funcs
argument_list|)
end_macro
begin_block
block|{
name|FT_MEM_ZERO
argument_list|(
operator|(
name|char
operator|*
operator|)
name|funcs
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|funcs
argument_list|)
argument_list|)
expr_stmt|;
name|funcs
operator|->
name|open
operator|=
operator|(
name|T1_Hints_OpenFunc
operator|)
name|t1_hints_open
expr_stmt|;
name|funcs
operator|->
name|close
operator|=
operator|(
name|T1_Hints_CloseFunc
operator|)
name|ps_hints_close
expr_stmt|;
name|funcs
operator|->
name|stem
operator|=
operator|(
name|T1_Hints_SetStemFunc
operator|)
name|t1_hints_stem
expr_stmt|;
name|funcs
operator|->
name|stem3
operator|=
operator|(
name|T1_Hints_SetStem3Func
operator|)
name|ps_hints_t1stem3
expr_stmt|;
name|funcs
operator|->
name|reset
operator|=
operator|(
name|T1_Hints_ResetFunc
operator|)
name|ps_hints_t1reset
expr_stmt|;
name|funcs
operator|->
name|apply
operator|=
operator|(
name|T1_Hints_ApplyFunc
operator|)
name|ps_hints_apply
expr_stmt|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****                TYPE 2 HINTS RECORDING INTERFACE               *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_function
specifier|static
name|void
DECL|function|t2_hints_open
name|t2_hints_open
parameter_list|(
name|T2_Hints
name|hints
parameter_list|)
block|{
name|ps_hints_open
argument_list|(
operator|(
name|PS_Hints
operator|)
name|hints
argument_list|,
name|PS_HINT_TYPE_2
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|t2_hints_stems
name|t2_hints_stems
parameter_list|(
name|T2_Hints
name|hints
parameter_list|,
name|FT_Int
name|dimension
parameter_list|,
name|FT_Int
name|count
parameter_list|,
name|FT_Fixed
modifier|*
name|coords
parameter_list|)
block|{
name|FT_Pos
name|stems
index|[
literal|32
index|]
decl_stmt|,
name|y
decl_stmt|,
name|n
decl_stmt|;
name|FT_Int
name|total
init|=
name|count
decl_stmt|;
name|y
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|total
operator|>
literal|0
condition|)
block|{
comment|/* determine number of stems to write */
name|count
operator|=
name|total
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|16
condition|)
name|count
operator|=
literal|16
expr_stmt|;
comment|/* compute integer stem positions in font units */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
operator|*
literal|2
condition|;
name|n
operator|++
control|)
block|{
name|y
operator|+=
name|coords
index|[
name|n
index|]
expr_stmt|;
name|stems
index|[
name|n
index|]
operator|=
name|FIXED_TO_INT
argument_list|(
name|y
argument_list|)
expr_stmt|;
block|}
comment|/* compute lengths */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
operator|*
literal|2
condition|;
name|n
operator|+=
literal|2
control|)
name|stems
index|[
name|n
operator|+
literal|1
index|]
operator|=
name|stems
index|[
name|n
operator|+
literal|1
index|]
operator|-
name|stems
index|[
name|n
index|]
expr_stmt|;
comment|/* add them to the current dimension */
name|ps_hints_stem
argument_list|(
operator|(
name|PS_Hints
operator|)
name|hints
argument_list|,
name|dimension
argument_list|,
name|count
argument_list|,
name|stems
argument_list|)
expr_stmt|;
name|total
operator|-=
name|count
expr_stmt|;
block|}
block|}
end_function
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|t2_hints_funcs_init
name|t2_hints_funcs_init
argument_list|(
argument|T2_Hints_FuncsRec*  funcs
argument_list|)
end_macro
begin_block
block|{
name|FT_MEM_ZERO
argument_list|(
name|funcs
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|funcs
argument_list|)
argument_list|)
expr_stmt|;
name|funcs
operator|->
name|open
operator|=
operator|(
name|T2_Hints_OpenFunc
operator|)
name|t2_hints_open
expr_stmt|;
name|funcs
operator|->
name|close
operator|=
operator|(
name|T2_Hints_CloseFunc
operator|)
name|ps_hints_close
expr_stmt|;
name|funcs
operator|->
name|stems
operator|=
operator|(
name|T2_Hints_StemsFunc
operator|)
name|t2_hints_stems
expr_stmt|;
name|funcs
operator|->
name|hintmask
operator|=
operator|(
name|T2_Hints_MaskFunc
operator|)
name|ps_hints_t2mask
expr_stmt|;
name|funcs
operator|->
name|counter
operator|=
operator|(
name|T2_Hints_CounterFunc
operator|)
name|ps_hints_t2counter
expr_stmt|;
name|funcs
operator|->
name|apply
operator|=
operator|(
name|T2_Hints_ApplyFunc
operator|)
name|ps_hints_apply
expr_stmt|;
block|}
end_block
begin_comment
comment|/* END */
end_comment
end_unit
