begin_unit
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  pshglob.c                                                              */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*    PostScript hinter global hinting management (body).                  */
end_comment
begin_comment
comment|/*    Inspired by the new auto-hinter module.                              */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  Copyright 2001-2015 by                                                 */
end_comment
begin_comment
comment|/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  This file is part of the FreeType project, and may only be used        */
end_comment
begin_comment
comment|/*  modified and distributed under the terms of the FreeType project       */
end_comment
begin_comment
comment|/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
end_comment
begin_comment
comment|/*  this file you indicate that you have read the license and              */
end_comment
begin_comment
comment|/*  understand and accept it fully.                                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<ft2build.h>
end_include
begin_include
include|#
directive|include
include|FT_FREETYPE_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_OBJECTS_H
end_include
begin_include
include|#
directive|include
file|"pshglob.h"
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG_HINTER
end_ifdef
begin_decl_stmt
DECL|variable|ps_debug_globals
name|PSH_Globals
name|ps_debug_globals
init|=
name|NULL
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****                       STANDARD WIDTHS                         *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/* scale the widths/heights table */
end_comment
begin_function
specifier|static
name|void
DECL|function|psh_globals_scale_widths
name|psh_globals_scale_widths
parameter_list|(
name|PSH_Globals
name|globals
parameter_list|,
name|FT_UInt
name|direction
parameter_list|)
block|{
name|PSH_Dimension
name|dim
init|=
operator|&
name|globals
operator|->
name|dimension
index|[
name|direction
index|]
decl_stmt|;
name|PSH_Widths
name|stdw
init|=
operator|&
name|dim
operator|->
name|stdw
decl_stmt|;
name|FT_UInt
name|count
init|=
name|stdw
operator|->
name|count
decl_stmt|;
name|PSH_Width
name|width
init|=
name|stdw
operator|->
name|widths
decl_stmt|;
name|PSH_Width
name|stand
init|=
name|width
decl_stmt|;
comment|/* standard width/height */
name|FT_Fixed
name|scale
init|=
name|dim
operator|->
name|scale_mult
decl_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|width
operator|->
name|cur
operator|=
name|FT_MulFix
argument_list|(
name|width
operator|->
name|org
argument_list|,
name|scale
argument_list|)
expr_stmt|;
name|width
operator|->
name|fit
operator|=
name|FT_PIX_ROUND
argument_list|(
name|width
operator|->
name|cur
argument_list|)
expr_stmt|;
name|width
operator|++
expr_stmt|;
name|count
operator|--
expr_stmt|;
for|for
control|(
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
operator|,
name|width
operator|++
control|)
block|{
name|FT_Pos
name|w
decl_stmt|,
name|dist
decl_stmt|;
name|w
operator|=
name|FT_MulFix
argument_list|(
name|width
operator|->
name|org
argument_list|,
name|scale
argument_list|)
expr_stmt|;
name|dist
operator|=
name|w
operator|-
name|stand
operator|->
name|cur
expr_stmt|;
if|if
condition|(
name|dist
operator|<
literal|0
condition|)
name|dist
operator|=
operator|-
name|dist
expr_stmt|;
if|if
condition|(
name|dist
operator|<
literal|128
condition|)
name|w
operator|=
name|stand
operator|->
name|cur
expr_stmt|;
name|width
operator|->
name|cur
operator|=
name|w
expr_stmt|;
name|width
operator|->
name|fit
operator|=
name|FT_PIX_ROUND
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_if
if|#
directive|if
literal|0
end_if
begin_comment
comment|/* org_width is is font units, result in device pixels, 26.6 format */
end_comment
begin_endif
unit|FT_LOCAL_DEF( FT_Pos )   psh_dimension_snap_width( PSH_Dimension  dimension,                             FT_Int         org_width )   {     FT_UInt  n;     FT_Pos   width     = FT_MulFix( org_width, dimension->scale_mult );     FT_Pos   best      = 64 + 32 + 2;     FT_Pos   reference = width;       for ( n = 0; n< dimension->stdw.count; n++ )     {       FT_Pos  w;       FT_Pos  dist;         w = dimension->stdw.widths[n].cur;       dist = width - w;       if ( dist< 0 )         dist = -dist;       if ( dist< best )       {         best      = dist;         reference = w;       }     }      if ( width>= reference )     {       width -= 0x21;       if ( width< reference )         width = reference;     }     else     {       width += 0x21;       if ( width> reference )         width = reference;     }      return width;   }
endif|#
directive|endif
end_endif
begin_comment
comment|/* 0 */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****                       BLUE ZONES                              *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_function
specifier|static
name|void
DECL|function|psh_blues_set_zones_0
name|psh_blues_set_zones_0
parameter_list|(
name|PSH_Blues
name|target
parameter_list|,
name|FT_Bool
name|is_others
parameter_list|,
name|FT_UInt
name|read_count
parameter_list|,
name|FT_Short
modifier|*
name|read
parameter_list|,
name|PSH_Blue_Table
name|top_table
parameter_list|,
name|PSH_Blue_Table
name|bot_table
parameter_list|)
block|{
name|FT_UInt
name|count_top
init|=
name|top_table
operator|->
name|count
decl_stmt|;
name|FT_UInt
name|count_bot
init|=
name|bot_table
operator|->
name|count
decl_stmt|;
name|FT_Bool
name|first
init|=
literal|1
decl_stmt|;
name|FT_UNUSED
argument_list|(
name|target
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|read_count
operator|>
literal|1
condition|;
name|read_count
operator|-=
literal|2
control|)
block|{
name|FT_Int
name|reference
decl_stmt|,
name|delta
decl_stmt|;
name|FT_UInt
name|count
decl_stmt|;
name|PSH_Blue_Zone
name|zones
decl_stmt|,
name|zone
decl_stmt|;
name|FT_Bool
name|top
decl_stmt|;
comment|/* read blue zone entry, and select target top/bottom zone */
name|top
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|first
operator|||
name|is_others
condition|)
block|{
name|reference
operator|=
name|read
index|[
literal|1
index|]
expr_stmt|;
name|delta
operator|=
name|read
index|[
literal|0
index|]
operator|-
name|reference
expr_stmt|;
name|zones
operator|=
name|bot_table
operator|->
name|zones
expr_stmt|;
name|count
operator|=
name|count_bot
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|reference
operator|=
name|read
index|[
literal|0
index|]
expr_stmt|;
name|delta
operator|=
name|read
index|[
literal|1
index|]
operator|-
name|reference
expr_stmt|;
name|zones
operator|=
name|top_table
operator|->
name|zones
expr_stmt|;
name|count
operator|=
name|count_top
expr_stmt|;
name|top
operator|=
literal|1
expr_stmt|;
block|}
comment|/* insert into sorted table */
name|zone
operator|=
name|zones
expr_stmt|;
for|for
control|(
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
operator|,
name|zone
operator|++
control|)
block|{
if|if
condition|(
name|reference
operator|<
name|zone
operator|->
name|org_ref
condition|)
break|break;
if|if
condition|(
name|reference
operator|==
name|zone
operator|->
name|org_ref
condition|)
block|{
name|FT_Int
name|delta0
init|=
name|zone
operator|->
name|org_delta
decl_stmt|;
comment|/* we have two zones on the same reference position -- */
comment|/* only keep the largest one                           */
if|if
condition|(
name|delta
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|delta
operator|<
name|delta0
condition|)
name|zone
operator|->
name|org_delta
operator|=
name|delta
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|delta
operator|>
name|delta0
condition|)
name|zone
operator|->
name|org_delta
operator|=
name|delta
expr_stmt|;
block|}
goto|goto
name|Skip
goto|;
block|}
block|}
for|for
control|(
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
control|)
name|zone
index|[
name|count
index|]
operator|=
name|zone
index|[
name|count
operator|-
literal|1
index|]
expr_stmt|;
name|zone
operator|->
name|org_ref
operator|=
name|reference
expr_stmt|;
name|zone
operator|->
name|org_delta
operator|=
name|delta
expr_stmt|;
if|if
condition|(
name|top
condition|)
name|count_top
operator|++
expr_stmt|;
else|else
name|count_bot
operator|++
expr_stmt|;
name|Skip
label|:
name|read
operator|+=
literal|2
expr_stmt|;
block|}
name|top_table
operator|->
name|count
operator|=
name|count_top
expr_stmt|;
name|bot_table
operator|->
name|count
operator|=
name|count_bot
expr_stmt|;
block|}
end_function
begin_comment
comment|/* Re-read blue zones from the original fonts and store them into out */
end_comment
begin_comment
comment|/* private structure.  This function re-orders, sanitizes and         */
end_comment
begin_comment
comment|/* fuzz-expands the zones as well.                                    */
end_comment
begin_function
specifier|static
name|void
DECL|function|psh_blues_set_zones
name|psh_blues_set_zones
parameter_list|(
name|PSH_Blues
name|target
parameter_list|,
name|FT_UInt
name|count
parameter_list|,
name|FT_Short
modifier|*
name|blues
parameter_list|,
name|FT_UInt
name|count_others
parameter_list|,
name|FT_Short
modifier|*
name|other_blues
parameter_list|,
name|FT_Int
name|fuzz
parameter_list|,
name|FT_Int
name|family
parameter_list|)
block|{
name|PSH_Blue_Table
name|top_table
decl_stmt|,
name|bot_table
decl_stmt|;
name|FT_UInt
name|count_top
decl_stmt|,
name|count_bot
decl_stmt|;
if|if
condition|(
name|family
condition|)
block|{
name|top_table
operator|=
operator|&
name|target
operator|->
name|family_top
expr_stmt|;
name|bot_table
operator|=
operator|&
name|target
operator|->
name|family_bottom
expr_stmt|;
block|}
else|else
block|{
name|top_table
operator|=
operator|&
name|target
operator|->
name|normal_top
expr_stmt|;
name|bot_table
operator|=
operator|&
name|target
operator|->
name|normal_bottom
expr_stmt|;
block|}
comment|/* read the input blue zones, and build two sorted tables  */
comment|/* (one for the top zones, the other for the bottom zones) */
name|top_table
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|bot_table
operator|->
name|count
operator|=
literal|0
expr_stmt|;
comment|/* first, the blues */
name|psh_blues_set_zones_0
argument_list|(
name|target
argument_list|,
literal|0
argument_list|,
name|count
argument_list|,
name|blues
argument_list|,
name|top_table
argument_list|,
name|bot_table
argument_list|)
expr_stmt|;
name|psh_blues_set_zones_0
argument_list|(
name|target
argument_list|,
literal|1
argument_list|,
name|count_others
argument_list|,
name|other_blues
argument_list|,
name|top_table
argument_list|,
name|bot_table
argument_list|)
expr_stmt|;
name|count_top
operator|=
name|top_table
operator|->
name|count
expr_stmt|;
name|count_bot
operator|=
name|bot_table
operator|->
name|count
expr_stmt|;
comment|/* sanitize top table */
if|if
condition|(
name|count_top
operator|>
literal|0
condition|)
block|{
name|PSH_Blue_Zone
name|zone
init|=
name|top_table
operator|->
name|zones
decl_stmt|;
for|for
control|(
name|count
operator|=
name|count_top
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
operator|,
name|zone
operator|++
control|)
block|{
name|FT_Int
name|delta
decl_stmt|;
if|if
condition|(
name|count
operator|>
literal|1
condition|)
block|{
name|delta
operator|=
name|zone
index|[
literal|1
index|]
operator|.
name|org_ref
operator|-
name|zone
index|[
literal|0
index|]
operator|.
name|org_ref
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|org_delta
operator|>
name|delta
condition|)
name|zone
operator|->
name|org_delta
operator|=
name|delta
expr_stmt|;
block|}
name|zone
operator|->
name|org_bottom
operator|=
name|zone
operator|->
name|org_ref
expr_stmt|;
name|zone
operator|->
name|org_top
operator|=
name|zone
operator|->
name|org_delta
operator|+
name|zone
operator|->
name|org_ref
expr_stmt|;
block|}
block|}
comment|/* sanitize bottom table */
if|if
condition|(
name|count_bot
operator|>
literal|0
condition|)
block|{
name|PSH_Blue_Zone
name|zone
init|=
name|bot_table
operator|->
name|zones
decl_stmt|;
for|for
control|(
name|count
operator|=
name|count_bot
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
operator|,
name|zone
operator|++
control|)
block|{
name|FT_Int
name|delta
decl_stmt|;
if|if
condition|(
name|count
operator|>
literal|1
condition|)
block|{
name|delta
operator|=
name|zone
index|[
literal|0
index|]
operator|.
name|org_ref
operator|-
name|zone
index|[
literal|1
index|]
operator|.
name|org_ref
expr_stmt|;
if|if
condition|(
name|zone
operator|->
name|org_delta
operator|<
name|delta
condition|)
name|zone
operator|->
name|org_delta
operator|=
name|delta
expr_stmt|;
block|}
name|zone
operator|->
name|org_top
operator|=
name|zone
operator|->
name|org_ref
expr_stmt|;
name|zone
operator|->
name|org_bottom
operator|=
name|zone
operator|->
name|org_delta
operator|+
name|zone
operator|->
name|org_ref
expr_stmt|;
block|}
block|}
comment|/* expand top and bottom tables with blue fuzz */
block|{
name|FT_Int
name|dim
decl_stmt|,
name|top
decl_stmt|,
name|bot
decl_stmt|,
name|delta
decl_stmt|;
name|PSH_Blue_Zone
name|zone
decl_stmt|;
name|zone
operator|=
name|top_table
operator|->
name|zones
expr_stmt|;
name|count
operator|=
name|count_top
expr_stmt|;
for|for
control|(
name|dim
operator|=
literal|1
init|;
name|dim
operator|>=
literal|0
condition|;
name|dim
operator|--
control|)
block|{
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
comment|/* expand the bottom of the lowest zone normally */
name|zone
operator|->
name|org_bottom
operator|-=
name|fuzz
expr_stmt|;
comment|/* expand the top and bottom of intermediate zones;    */
comment|/* checking that the interval is smaller than the fuzz */
name|top
operator|=
name|zone
operator|->
name|org_top
expr_stmt|;
for|for
control|(
name|count
operator|--
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
control|)
block|{
name|bot
operator|=
name|zone
index|[
literal|1
index|]
operator|.
name|org_bottom
expr_stmt|;
name|delta
operator|=
name|bot
operator|-
name|top
expr_stmt|;
if|if
condition|(
name|delta
operator|/
literal|2
operator|<
name|fuzz
condition|)
name|zone
index|[
literal|0
index|]
operator|.
name|org_top
operator|=
name|zone
index|[
literal|1
index|]
operator|.
name|org_bottom
operator|=
name|top
operator|+
name|delta
operator|/
literal|2
expr_stmt|;
else|else
block|{
name|zone
index|[
literal|0
index|]
operator|.
name|org_top
operator|=
name|top
operator|+
name|fuzz
expr_stmt|;
name|zone
index|[
literal|1
index|]
operator|.
name|org_bottom
operator|=
name|bot
operator|-
name|fuzz
expr_stmt|;
block|}
name|zone
operator|++
expr_stmt|;
name|top
operator|=
name|zone
operator|->
name|org_top
expr_stmt|;
block|}
comment|/* expand the top of the highest zone normally */
name|zone
operator|->
name|org_top
operator|=
name|top
operator|+
name|fuzz
expr_stmt|;
block|}
name|zone
operator|=
name|bot_table
operator|->
name|zones
expr_stmt|;
name|count
operator|=
name|count_bot
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/* reset the blues table when the device transform changes */
end_comment
begin_function
specifier|static
name|void
DECL|function|psh_blues_scale_zones
name|psh_blues_scale_zones
parameter_list|(
name|PSH_Blues
name|blues
parameter_list|,
name|FT_Fixed
name|scale
parameter_list|,
name|FT_Pos
name|delta
parameter_list|)
block|{
name|FT_UInt
name|count
decl_stmt|;
name|FT_UInt
name|num
decl_stmt|;
name|PSH_Blue_Table
name|table
init|=
name|NULL
decl_stmt|;
comment|/*                                                        */
comment|/* Determine whether we need to suppress overshoots or    */
comment|/* not.  We simply need to compare the vertical scale     */
comment|/* parameter to the raw bluescale value.  Here is why:    */
comment|/*                                                        */
comment|/*   We need to suppress overshoots for all pointsizes.   */
comment|/*   At 300dpi that satisfies:                            */
comment|/*                                                        */
comment|/*      pointsize< 240*bluescale + 0.49                  */
comment|/*                                                        */
comment|/*   This corresponds to:                                 */
comment|/*                                                        */
comment|/*      pixelsize< 1000*bluescale + 49/24                */
comment|/*                                                        */
comment|/*      scale*EM_Size< 1000*bluescale + 49/24            */
comment|/*                                                        */
comment|/*   However, for normal Type 1 fonts, EM_Size is 1000!   */
comment|/*   We thus only check:                                  */
comment|/*                                                        */
comment|/*      scale< bluescale + 49/24000                      */
comment|/*                                                        */
comment|/*   which we shorten to                                  */
comment|/*                                                        */
comment|/*      "scale< bluescale"                               */
comment|/*                                                        */
comment|/* Note that `blue_scale' is stored 1000 times its real   */
comment|/* value, and that `scale' converts from font units to    */
comment|/* fractional pixels.                                     */
comment|/*                                                        */
comment|/* 1000 / 64 = 125 / 8 */
if|if
condition|(
name|scale
operator|>=
literal|0x20C49BAL
condition|)
name|blues
operator|->
name|no_overshoots
operator|=
name|FT_BOOL
argument_list|(
name|scale
operator|<
name|blues
operator|->
name|blue_scale
operator|*
literal|8
operator|/
literal|125
argument_list|)
expr_stmt|;
else|else
name|blues
operator|->
name|no_overshoots
operator|=
name|FT_BOOL
argument_list|(
name|scale
operator|*
literal|125
operator|<
name|blues
operator|->
name|blue_scale
operator|*
literal|8
argument_list|)
expr_stmt|;
comment|/*                                                        */
comment|/*  The blue threshold is the font units distance under   */
comment|/*  which overshoots are suppressed due to the BlueShift  */
comment|/*  even if the scale is greater than BlueScale.          */
comment|/*                                                        */
comment|/*  It is the smallest distance such that                 */
comment|/*                                                        */
comment|/*    dist<= BlueShift&& dist*scale<= 0.5 pixels       */
comment|/*                                                        */
block|{
name|FT_Int
name|threshold
init|=
name|blues
operator|->
name|blue_shift
decl_stmt|;
while|while
condition|(
name|threshold
operator|>
literal|0
operator|&&
name|FT_MulFix
argument_list|(
name|threshold
argument_list|,
name|scale
argument_list|)
operator|>
literal|32
condition|)
name|threshold
operator|--
expr_stmt|;
name|blues
operator|->
name|blue_threshold
operator|=
name|threshold
expr_stmt|;
block|}
for|for
control|(
name|num
operator|=
literal|0
init|;
name|num
operator|<
literal|4
condition|;
name|num
operator|++
control|)
block|{
name|PSH_Blue_Zone
name|zone
decl_stmt|;
switch|switch
condition|(
name|num
condition|)
block|{
case|case
literal|0
case|:
name|table
operator|=
operator|&
name|blues
operator|->
name|normal_top
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|table
operator|=
operator|&
name|blues
operator|->
name|normal_bottom
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|table
operator|=
operator|&
name|blues
operator|->
name|family_top
expr_stmt|;
break|break;
default|default:
name|table
operator|=
operator|&
name|blues
operator|->
name|family_bottom
expr_stmt|;
break|break;
block|}
name|zone
operator|=
name|table
operator|->
name|zones
expr_stmt|;
name|count
operator|=
name|table
operator|->
name|count
expr_stmt|;
for|for
control|(
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
operator|,
name|zone
operator|++
control|)
block|{
name|zone
operator|->
name|cur_top
operator|=
name|FT_MulFix
argument_list|(
name|zone
operator|->
name|org_top
argument_list|,
name|scale
argument_list|)
operator|+
name|delta
expr_stmt|;
name|zone
operator|->
name|cur_bottom
operator|=
name|FT_MulFix
argument_list|(
name|zone
operator|->
name|org_bottom
argument_list|,
name|scale
argument_list|)
operator|+
name|delta
expr_stmt|;
name|zone
operator|->
name|cur_ref
operator|=
name|FT_MulFix
argument_list|(
name|zone
operator|->
name|org_ref
argument_list|,
name|scale
argument_list|)
operator|+
name|delta
expr_stmt|;
name|zone
operator|->
name|cur_delta
operator|=
name|FT_MulFix
argument_list|(
name|zone
operator|->
name|org_delta
argument_list|,
name|scale
argument_list|)
expr_stmt|;
comment|/* round scaled reference position */
name|zone
operator|->
name|cur_ref
operator|=
name|FT_PIX_ROUND
argument_list|(
name|zone
operator|->
name|cur_ref
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if ( zone->cur_ref> zone->cur_top )           zone->cur_ref -= 64;         else if ( zone->cur_ref< zone->cur_bottom )           zone->cur_ref += 64;
endif|#
directive|endif
block|}
block|}
comment|/* process the families now */
for|for
control|(
name|num
operator|=
literal|0
init|;
name|num
operator|<
literal|2
condition|;
name|num
operator|++
control|)
block|{
name|PSH_Blue_Zone
name|zone1
decl_stmt|,
name|zone2
decl_stmt|;
name|FT_UInt
name|count1
decl_stmt|,
name|count2
decl_stmt|;
name|PSH_Blue_Table
name|normal
decl_stmt|,
name|family
decl_stmt|;
switch|switch
condition|(
name|num
condition|)
block|{
case|case
literal|0
case|:
name|normal
operator|=
operator|&
name|blues
operator|->
name|normal_top
expr_stmt|;
name|family
operator|=
operator|&
name|blues
operator|->
name|family_top
expr_stmt|;
break|break;
default|default:
name|normal
operator|=
operator|&
name|blues
operator|->
name|normal_bottom
expr_stmt|;
name|family
operator|=
operator|&
name|blues
operator|->
name|family_bottom
expr_stmt|;
block|}
name|zone1
operator|=
name|normal
operator|->
name|zones
expr_stmt|;
name|count1
operator|=
name|normal
operator|->
name|count
expr_stmt|;
for|for
control|(
init|;
name|count1
operator|>
literal|0
condition|;
name|count1
operator|--
operator|,
name|zone1
operator|++
control|)
block|{
comment|/* try to find a family zone whose reference position is less */
comment|/* than 1 pixel far from the current zone                     */
name|zone2
operator|=
name|family
operator|->
name|zones
expr_stmt|;
name|count2
operator|=
name|family
operator|->
name|count
expr_stmt|;
for|for
control|(
init|;
name|count2
operator|>
literal|0
condition|;
name|count2
operator|--
operator|,
name|zone2
operator|++
control|)
block|{
name|FT_Pos
name|Delta
decl_stmt|;
name|Delta
operator|=
name|zone1
operator|->
name|org_ref
operator|-
name|zone2
operator|->
name|org_ref
expr_stmt|;
if|if
condition|(
name|Delta
operator|<
literal|0
condition|)
name|Delta
operator|=
operator|-
name|Delta
expr_stmt|;
if|if
condition|(
name|FT_MulFix
argument_list|(
name|Delta
argument_list|,
name|scale
argument_list|)
operator|<
literal|64
condition|)
block|{
name|zone1
operator|->
name|cur_top
operator|=
name|zone2
operator|->
name|cur_top
expr_stmt|;
name|zone1
operator|->
name|cur_bottom
operator|=
name|zone2
operator|->
name|cur_bottom
expr_stmt|;
name|zone1
operator|->
name|cur_ref
operator|=
name|zone2
operator|->
name|cur_ref
expr_stmt|;
name|zone1
operator|->
name|cur_delta
operator|=
name|zone2
operator|->
name|cur_delta
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
end_function
begin_comment
comment|/* calculate the maximum height of given blue zones */
end_comment
begin_function
specifier|static
name|FT_Short
DECL|function|psh_calc_max_height
name|psh_calc_max_height
parameter_list|(
name|FT_UInt
name|num
parameter_list|,
specifier|const
name|FT_Short
modifier|*
name|values
parameter_list|,
name|FT_Short
name|cur_max
parameter_list|)
block|{
name|FT_UInt
name|count
decl_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|num
condition|;
name|count
operator|+=
literal|2
control|)
block|{
name|FT_Short
name|cur_height
init|=
name|values
index|[
name|count
operator|+
literal|1
index|]
operator|-
name|values
index|[
name|count
index|]
decl_stmt|;
if|if
condition|(
name|cur_height
operator|>
name|cur_max
condition|)
name|cur_max
operator|=
name|cur_height
expr_stmt|;
block|}
return|return
name|cur_max
return|;
block|}
end_function
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|psh_blues_snap_stem
name|psh_blues_snap_stem
argument_list|(
argument|PSH_Blues      blues
argument_list|,
argument|FT_Int         stem_top
argument_list|,
argument|FT_Int         stem_bot
argument_list|,
argument|PSH_Alignment  alignment
argument_list|)
end_macro
begin_block
block|{
name|PSH_Blue_Table
name|table
decl_stmt|;
name|FT_UInt
name|count
decl_stmt|;
name|FT_Pos
name|delta
decl_stmt|;
name|PSH_Blue_Zone
name|zone
decl_stmt|;
name|FT_Int
name|no_shoots
decl_stmt|;
name|alignment
operator|->
name|align
operator|=
name|PSH_BLUE_ALIGN_NONE
expr_stmt|;
name|no_shoots
operator|=
name|blues
operator|->
name|no_overshoots
expr_stmt|;
comment|/* look up stem top in top zones table */
name|table
operator|=
operator|&
name|blues
operator|->
name|normal_top
expr_stmt|;
name|count
operator|=
name|table
operator|->
name|count
expr_stmt|;
name|zone
operator|=
name|table
operator|->
name|zones
expr_stmt|;
for|for
control|(
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
operator|,
name|zone
operator|++
control|)
block|{
name|delta
operator|=
name|stem_top
operator|-
name|zone
operator|->
name|org_bottom
expr_stmt|;
if|if
condition|(
name|delta
operator|<
operator|-
name|blues
operator|->
name|blue_fuzz
condition|)
break|break;
if|if
condition|(
name|stem_top
operator|<=
name|zone
operator|->
name|org_top
operator|+
name|blues
operator|->
name|blue_fuzz
condition|)
block|{
if|if
condition|(
name|no_shoots
operator|||
name|delta
operator|<=
name|blues
operator|->
name|blue_threshold
condition|)
block|{
name|alignment
operator|->
name|align
operator||=
name|PSH_BLUE_ALIGN_TOP
expr_stmt|;
name|alignment
operator|->
name|align_top
operator|=
name|zone
operator|->
name|cur_ref
expr_stmt|;
block|}
break|break;
block|}
block|}
comment|/* look up stem bottom in bottom zones table */
name|table
operator|=
operator|&
name|blues
operator|->
name|normal_bottom
expr_stmt|;
name|count
operator|=
name|table
operator|->
name|count
expr_stmt|;
name|zone
operator|=
name|table
operator|->
name|zones
operator|+
name|count
operator|-
literal|1
expr_stmt|;
for|for
control|(
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
operator|,
name|zone
operator|--
control|)
block|{
name|delta
operator|=
name|zone
operator|->
name|org_top
operator|-
name|stem_bot
expr_stmt|;
if|if
condition|(
name|delta
operator|<
operator|-
name|blues
operator|->
name|blue_fuzz
condition|)
break|break;
if|if
condition|(
name|stem_bot
operator|>=
name|zone
operator|->
name|org_bottom
operator|-
name|blues
operator|->
name|blue_fuzz
condition|)
block|{
if|if
condition|(
name|no_shoots
operator|||
name|delta
operator|<
name|blues
operator|->
name|blue_threshold
condition|)
block|{
name|alignment
operator|->
name|align
operator||=
name|PSH_BLUE_ALIGN_BOT
expr_stmt|;
name|alignment
operator|->
name|align_bot
operator|=
name|zone
operator|->
name|cur_ref
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****                        GLOBAL HINTS                           *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_function
specifier|static
name|void
DECL|function|psh_globals_destroy
name|psh_globals_destroy
parameter_list|(
name|PSH_Globals
name|globals
parameter_list|)
block|{
if|if
condition|(
name|globals
condition|)
block|{
name|FT_Memory
name|memory
decl_stmt|;
name|memory
operator|=
name|globals
operator|->
name|memory
expr_stmt|;
name|globals
operator|->
name|dimension
index|[
literal|0
index|]
operator|.
name|stdw
operator|.
name|count
operator|=
literal|0
expr_stmt|;
name|globals
operator|->
name|dimension
index|[
literal|1
index|]
operator|.
name|stdw
operator|.
name|count
operator|=
literal|0
expr_stmt|;
name|globals
operator|->
name|blues
operator|.
name|normal_top
operator|.
name|count
operator|=
literal|0
expr_stmt|;
name|globals
operator|->
name|blues
operator|.
name|normal_bottom
operator|.
name|count
operator|=
literal|0
expr_stmt|;
name|globals
operator|->
name|blues
operator|.
name|family_top
operator|.
name|count
operator|=
literal|0
expr_stmt|;
name|globals
operator|->
name|blues
operator|.
name|family_bottom
operator|.
name|count
operator|=
literal|0
expr_stmt|;
name|FT_FREE
argument_list|(
name|globals
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_HINTER
name|ps_debug_globals
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|psh_globals_new
name|psh_globals_new
parameter_list|(
name|FT_Memory
name|memory
parameter_list|,
name|T1_Private
modifier|*
name|priv
parameter_list|,
name|PSH_Globals
modifier|*
name|aglobals
parameter_list|)
block|{
name|PSH_Globals
name|globals
init|=
name|NULL
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
if|if
condition|(
operator|!
name|FT_NEW
argument_list|(
name|globals
argument_list|)
condition|)
block|{
name|FT_UInt
name|count
decl_stmt|;
name|FT_Short
modifier|*
name|read
decl_stmt|;
name|globals
operator|->
name|memory
operator|=
name|memory
expr_stmt|;
comment|/* copy standard widths */
block|{
name|PSH_Dimension
name|dim
init|=
operator|&
name|globals
operator|->
name|dimension
index|[
literal|1
index|]
decl_stmt|;
name|PSH_Width
name|write
init|=
name|dim
operator|->
name|stdw
operator|.
name|widths
decl_stmt|;
name|write
operator|->
name|org
operator|=
name|priv
operator|->
name|standard_width
index|[
literal|0
index|]
expr_stmt|;
name|write
operator|++
expr_stmt|;
name|read
operator|=
name|priv
operator|->
name|snap_widths
expr_stmt|;
for|for
control|(
name|count
operator|=
name|priv
operator|->
name|num_snap_widths
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
control|)
block|{
name|write
operator|->
name|org
operator|=
operator|*
name|read
expr_stmt|;
name|write
operator|++
expr_stmt|;
name|read
operator|++
expr_stmt|;
block|}
name|dim
operator|->
name|stdw
operator|.
name|count
operator|=
name|priv
operator|->
name|num_snap_widths
operator|+
literal|1
expr_stmt|;
block|}
comment|/* copy standard heights */
block|{
name|PSH_Dimension
name|dim
init|=
operator|&
name|globals
operator|->
name|dimension
index|[
literal|0
index|]
decl_stmt|;
name|PSH_Width
name|write
init|=
name|dim
operator|->
name|stdw
operator|.
name|widths
decl_stmt|;
name|write
operator|->
name|org
operator|=
name|priv
operator|->
name|standard_height
index|[
literal|0
index|]
expr_stmt|;
name|write
operator|++
expr_stmt|;
name|read
operator|=
name|priv
operator|->
name|snap_heights
expr_stmt|;
for|for
control|(
name|count
operator|=
name|priv
operator|->
name|num_snap_heights
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
control|)
block|{
name|write
operator|->
name|org
operator|=
operator|*
name|read
expr_stmt|;
name|write
operator|++
expr_stmt|;
name|read
operator|++
expr_stmt|;
block|}
name|dim
operator|->
name|stdw
operator|.
name|count
operator|=
name|priv
operator|->
name|num_snap_heights
operator|+
literal|1
expr_stmt|;
block|}
comment|/* copy blue zones */
name|psh_blues_set_zones
argument_list|(
operator|&
name|globals
operator|->
name|blues
argument_list|,
name|priv
operator|->
name|num_blue_values
argument_list|,
name|priv
operator|->
name|blue_values
argument_list|,
name|priv
operator|->
name|num_other_blues
argument_list|,
name|priv
operator|->
name|other_blues
argument_list|,
name|priv
operator|->
name|blue_fuzz
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|psh_blues_set_zones
argument_list|(
operator|&
name|globals
operator|->
name|blues
argument_list|,
name|priv
operator|->
name|num_family_blues
argument_list|,
name|priv
operator|->
name|family_blues
argument_list|,
name|priv
operator|->
name|num_family_other_blues
argument_list|,
name|priv
operator|->
name|family_other_blues
argument_list|,
name|priv
operator|->
name|blue_fuzz
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* limit the BlueScale value to `1 / max_of_blue_zone_heights' */
block|{
name|FT_Fixed
name|max_scale
decl_stmt|;
name|FT_Short
name|max_height
init|=
literal|1
decl_stmt|;
name|max_height
operator|=
name|psh_calc_max_height
argument_list|(
name|priv
operator|->
name|num_blue_values
argument_list|,
name|priv
operator|->
name|blue_values
argument_list|,
name|max_height
argument_list|)
expr_stmt|;
name|max_height
operator|=
name|psh_calc_max_height
argument_list|(
name|priv
operator|->
name|num_other_blues
argument_list|,
name|priv
operator|->
name|other_blues
argument_list|,
name|max_height
argument_list|)
expr_stmt|;
name|max_height
operator|=
name|psh_calc_max_height
argument_list|(
name|priv
operator|->
name|num_family_blues
argument_list|,
name|priv
operator|->
name|family_blues
argument_list|,
name|max_height
argument_list|)
expr_stmt|;
name|max_height
operator|=
name|psh_calc_max_height
argument_list|(
name|priv
operator|->
name|num_family_other_blues
argument_list|,
name|priv
operator|->
name|family_other_blues
argument_list|,
name|max_height
argument_list|)
expr_stmt|;
comment|/* BlueScale is scaled 1000 times */
name|max_scale
operator|=
name|FT_DivFix
argument_list|(
literal|1000
argument_list|,
name|max_height
argument_list|)
expr_stmt|;
name|globals
operator|->
name|blues
operator|.
name|blue_scale
operator|=
name|priv
operator|->
name|blue_scale
operator|<
name|max_scale
condition|?
name|priv
operator|->
name|blue_scale
else|:
name|max_scale
expr_stmt|;
block|}
name|globals
operator|->
name|blues
operator|.
name|blue_shift
operator|=
name|priv
operator|->
name|blue_shift
expr_stmt|;
name|globals
operator|->
name|blues
operator|.
name|blue_fuzz
operator|=
name|priv
operator|->
name|blue_fuzz
expr_stmt|;
name|globals
operator|->
name|dimension
index|[
literal|0
index|]
operator|.
name|scale_mult
operator|=
literal|0
expr_stmt|;
name|globals
operator|->
name|dimension
index|[
literal|0
index|]
operator|.
name|scale_delta
operator|=
literal|0
expr_stmt|;
name|globals
operator|->
name|dimension
index|[
literal|1
index|]
operator|.
name|scale_mult
operator|=
literal|0
expr_stmt|;
name|globals
operator|->
name|dimension
index|[
literal|1
index|]
operator|.
name|scale_delta
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_HINTER
name|ps_debug_globals
operator|=
name|globals
expr_stmt|;
endif|#
directive|endif
block|}
operator|*
name|aglobals
operator|=
name|globals
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|psh_globals_set_scale
name|psh_globals_set_scale
argument_list|(
argument|PSH_Globals  globals
argument_list|,
argument|FT_Fixed     x_scale
argument_list|,
argument|FT_Fixed     y_scale
argument_list|,
argument|FT_Fixed     x_delta
argument_list|,
argument|FT_Fixed     y_delta
argument_list|)
end_macro
begin_block
block|{
name|PSH_Dimension
name|dim
decl_stmt|;
name|dim
operator|=
operator|&
name|globals
operator|->
name|dimension
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|x_scale
operator|!=
name|dim
operator|->
name|scale_mult
operator|||
name|x_delta
operator|!=
name|dim
operator|->
name|scale_delta
condition|)
block|{
name|dim
operator|->
name|scale_mult
operator|=
name|x_scale
expr_stmt|;
name|dim
operator|->
name|scale_delta
operator|=
name|x_delta
expr_stmt|;
name|psh_globals_scale_widths
argument_list|(
name|globals
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|dim
operator|=
operator|&
name|globals
operator|->
name|dimension
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|y_scale
operator|!=
name|dim
operator|->
name|scale_mult
operator|||
name|y_delta
operator|!=
name|dim
operator|->
name|scale_delta
condition|)
block|{
name|dim
operator|->
name|scale_mult
operator|=
name|y_scale
expr_stmt|;
name|dim
operator|->
name|scale_delta
operator|=
name|y_delta
expr_stmt|;
name|psh_globals_scale_widths
argument_list|(
name|globals
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|psh_blues_scale_zones
argument_list|(
operator|&
name|globals
operator|->
name|blues
argument_list|,
name|y_scale
argument_list|,
name|y_delta
argument_list|)
expr_stmt|;
block|}
block|}
end_block
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|psh_globals_funcs_init
name|psh_globals_funcs_init
argument_list|(
argument|PSH_Globals_FuncsRec*  funcs
argument_list|)
end_macro
begin_block
block|{
name|funcs
operator|->
name|create
operator|=
name|psh_globals_new
expr_stmt|;
name|funcs
operator|->
name|set_scale
operator|=
name|psh_globals_set_scale
expr_stmt|;
name|funcs
operator|->
name|destroy
operator|=
name|psh_globals_destroy
expr_stmt|;
block|}
end_block
begin_comment
comment|/* END */
end_comment
end_unit
