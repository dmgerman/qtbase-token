begin_unit
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  afangles.c                                                             */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*    Routines used to compute vector angles with limited accuracy         */
end_comment
begin_comment
comment|/*    and very high speed.  It also contains sorting routines (body).      */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  Copyright 2003-2006, 2011-2012 by                                      */
end_comment
begin_comment
comment|/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  This file is part of the FreeType project, and may only be used,       */
end_comment
begin_comment
comment|/*  modified, and distributed under the terms of the FreeType project      */
end_comment
begin_comment
comment|/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
end_comment
begin_comment
comment|/*  this file you indicate that you have read the license and              */
end_comment
begin_comment
comment|/*  understand and accept it fully.                                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"aftypes.h"
end_include
begin_comment
comment|/*    *  We are not using `af_angle_atan' anymore, but we keep the source    *  code below just in case...    */
end_comment
begin_if
if|#
directive|if
literal|0
end_if
begin_comment
comment|/*    *  The trick here is to realize that we don't need a very accurate angle    *  approximation.  We are going to use the result of `af_angle_atan' to    *  only compare the sign of angle differences, or check whether its    *  magnitude is very small.    *    *  The approximation    *    *    dy * PI / (|dx|+|dy|)    *    *  should be enough, and much faster to compute.    */
end_comment
begin_elif
unit|FT_LOCAL_DEF( AF_Angle )   af_angle_atan( FT_Fixed  dx,                  FT_Fixed  dy )   {     AF_Angle  angle;     FT_Fixed  ax = dx;     FT_Fixed  ay = dy;       if ( ax< 0 )       ax = -ax;     if ( ay< 0 )       ay = -ay;      ax += ay;      if ( ax == 0 )       angle = 0;     else     {       angle = ( AF_ANGLE_PI2 * dy ) / ( ax + ay );       if ( dx< 0 )       {         if ( angle>= 0 )           angle = AF_ANGLE_PI - angle;         else           angle = -AF_ANGLE_PI - angle;       }     }      return angle;   }
elif|#
directive|elif
literal|0
end_elif
begin_comment
comment|/* the following table has been automatically generated with */
end_comment
begin_comment
comment|/* the `mather.py' Python script                             */
end_comment
begin_define
DECL|macro|AF_ATAN_BITS
define|#
directive|define
name|AF_ATAN_BITS
value|8
end_define
begin_decl_stmt
DECL|variable|af_arctan
specifier|static
specifier|const
name|FT_Byte
name|af_arctan
index|[
literal|1L
operator|<<
name|AF_ATAN_BITS
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|12
block|,
literal|12
block|,
literal|12
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|14
block|,
literal|14
block|,
literal|14
block|,
literal|14
block|,
literal|15
block|,
literal|15
block|,
literal|15
block|,
literal|16
block|,
literal|16
block|,
literal|16
block|,
literal|17
block|,
literal|17
block|,
literal|17
block|,
literal|18
block|,
literal|18
block|,
literal|18
block|,
literal|18
block|,
literal|19
block|,
literal|19
block|,
literal|19
block|,
literal|20
block|,
literal|20
block|,
literal|20
block|,
literal|21
block|,
literal|21
block|,
literal|21
block|,
literal|21
block|,
literal|22
block|,
literal|22
block|,
literal|22
block|,
literal|23
block|,
literal|23
block|,
literal|23
block|,
literal|24
block|,
literal|24
block|,
literal|24
block|,
literal|24
block|,
literal|25
block|,
literal|25
block|,
literal|25
block|,
literal|26
block|,
literal|26
block|,
literal|26
block|,
literal|26
block|,
literal|27
block|,
literal|27
block|,
literal|27
block|,
literal|28
block|,
literal|28
block|,
literal|28
block|,
literal|28
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|30
block|,
literal|30
block|,
literal|30
block|,
literal|30
block|,
literal|31
block|,
literal|31
block|,
literal|31
block|,
literal|31
block|,
literal|32
block|,
literal|32
block|,
literal|32
block|,
literal|33
block|,
literal|33
block|,
literal|33
block|,
literal|33
block|,
literal|34
block|,
literal|34
block|,
literal|34
block|,
literal|34
block|,
literal|35
block|,
literal|35
block|,
literal|35
block|,
literal|35
block|,
literal|36
block|,
literal|36
block|,
literal|36
block|,
literal|36
block|,
literal|37
block|,
literal|37
block|,
literal|37
block|,
literal|38
block|,
literal|38
block|,
literal|38
block|,
literal|38
block|,
literal|39
block|,
literal|39
block|,
literal|39
block|,
literal|39
block|,
literal|40
block|,
literal|40
block|,
literal|40
block|,
literal|40
block|,
literal|41
block|,
literal|41
block|,
literal|41
block|,
literal|41
block|,
literal|42
block|,
literal|42
block|,
literal|42
block|,
literal|42
block|,
literal|42
block|,
literal|43
block|,
literal|43
block|,
literal|43
block|,
literal|43
block|,
literal|44
block|,
literal|44
block|,
literal|44
block|,
literal|44
block|,
literal|45
block|,
literal|45
block|,
literal|45
block|,
literal|45
block|,
literal|46
block|,
literal|46
block|,
literal|46
block|,
literal|46
block|,
literal|46
block|,
literal|47
block|,
literal|47
block|,
literal|47
block|,
literal|47
block|,
literal|48
block|,
literal|48
block|,
literal|48
block|,
literal|48
block|,
literal|48
block|,
literal|49
block|,
literal|49
block|,
literal|49
block|,
literal|49
block|,
literal|50
block|,
literal|50
block|,
literal|50
block|,
literal|50
block|,
literal|50
block|,
literal|51
block|,
literal|51
block|,
literal|51
block|,
literal|51
block|,
literal|51
block|,
literal|52
block|,
literal|52
block|,
literal|52
block|,
literal|52
block|,
literal|52
block|,
literal|53
block|,
literal|53
block|,
literal|53
block|,
literal|53
block|,
literal|53
block|,
literal|54
block|,
literal|54
block|,
literal|54
block|,
literal|54
block|,
literal|54
block|,
literal|55
block|,
literal|55
block|,
literal|55
block|,
literal|55
block|,
literal|55
block|,
literal|56
block|,
literal|56
block|,
literal|56
block|,
literal|56
block|,
literal|56
block|,
literal|57
block|,
literal|57
block|,
literal|57
block|,
literal|57
block|,
literal|57
block|,
literal|57
block|,
literal|58
block|,
literal|58
block|,
literal|58
block|,
literal|58
block|,
literal|58
block|,
literal|59
block|,
literal|59
block|,
literal|59
block|,
literal|59
block|,
literal|59
block|,
literal|59
block|,
literal|60
block|,
literal|60
block|,
literal|60
block|,
literal|60
block|,
literal|60
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|62
block|,
literal|62
block|,
literal|62
block|,
literal|62
block|,
literal|62
block|,
literal|62
block|,
literal|63
block|,
literal|63
block|,
literal|63
block|,
literal|63
block|,
literal|63
block|,
literal|63
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|}
decl_stmt|;
end_decl_stmt
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|AF_Angle
argument_list|)
end_macro
begin_macro
name|af_angle_atan
argument_list|(
argument|FT_Fixed  dx
argument_list|,
argument|FT_Fixed  dy
argument_list|)
end_macro
begin_block
block|{
name|AF_Angle
name|angle
decl_stmt|;
comment|/* check trivial cases */
if|if
condition|(
name|dy
operator|==
literal|0
condition|)
block|{
name|angle
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dx
operator|<
literal|0
condition|)
name|angle
operator|=
name|AF_ANGLE_PI
expr_stmt|;
return|return
name|angle
return|;
block|}
elseif|else
if|if
condition|(
name|dx
operator|==
literal|0
condition|)
block|{
name|angle
operator|=
name|AF_ANGLE_PI2
expr_stmt|;
if|if
condition|(
name|dy
operator|<
literal|0
condition|)
name|angle
operator|=
operator|-
name|AF_ANGLE_PI2
expr_stmt|;
return|return
name|angle
return|;
block|}
name|angle
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dx
operator|<
literal|0
condition|)
block|{
name|dx
operator|=
operator|-
name|dx
expr_stmt|;
name|dy
operator|=
operator|-
name|dy
expr_stmt|;
name|angle
operator|=
name|AF_ANGLE_PI
expr_stmt|;
block|}
if|if
condition|(
name|dy
operator|<
literal|0
condition|)
block|{
name|FT_Pos
name|tmp
decl_stmt|;
name|tmp
operator|=
name|dx
expr_stmt|;
name|dx
operator|=
operator|-
name|dy
expr_stmt|;
name|dy
operator|=
name|tmp
expr_stmt|;
name|angle
operator|-=
name|AF_ANGLE_PI2
expr_stmt|;
block|}
if|if
condition|(
name|dx
operator|==
literal|0
operator|&&
name|dy
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|dx
operator|==
name|dy
condition|)
name|angle
operator|+=
name|AF_ANGLE_PI4
expr_stmt|;
elseif|else
if|if
condition|(
name|dx
operator|>
name|dy
condition|)
name|angle
operator|+=
name|af_arctan
index|[
name|FT_DivFix
argument_list|(
name|dy
argument_list|,
name|dx
argument_list|)
operator|>>
operator|(
literal|16
operator|-
name|AF_ATAN_BITS
operator|)
index|]
expr_stmt|;
else|else
name|angle
operator|+=
name|AF_ANGLE_PI2
operator|-
name|af_arctan
index|[
name|FT_DivFix
argument_list|(
name|dx
argument_list|,
name|dy
argument_list|)
operator|>>
operator|(
literal|16
operator|-
name|AF_ATAN_BITS
operator|)
index|]
expr_stmt|;
if|if
condition|(
name|angle
operator|>
name|AF_ANGLE_PI
condition|)
name|angle
operator|-=
name|AF_ANGLE_2PI
expr_stmt|;
return|return
name|angle
return|;
block|}
end_block
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* 0 */
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|af_sort_pos
name|af_sort_pos
argument_list|(
argument|FT_UInt  count
argument_list|,
argument|FT_Pos*  table
argument_list|)
end_macro
begin_block
block|{
name|FT_UInt
name|i
decl_stmt|,
name|j
decl_stmt|;
name|FT_Pos
name|swap
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|>
literal|0
condition|;
name|j
operator|--
control|)
block|{
if|if
condition|(
name|table
index|[
name|j
index|]
operator|>=
name|table
index|[
name|j
operator|-
literal|1
index|]
condition|)
break|break;
name|swap
operator|=
name|table
index|[
name|j
index|]
expr_stmt|;
name|table
index|[
name|j
index|]
operator|=
name|table
index|[
name|j
operator|-
literal|1
index|]
expr_stmt|;
name|table
index|[
name|j
operator|-
literal|1
index|]
operator|=
name|swap
expr_stmt|;
block|}
block|}
block|}
end_block
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|af_sort_and_quantize_widths
name|af_sort_and_quantize_widths
argument_list|(
argument|FT_UInt*  count
argument_list|,
argument|AF_Width  table
argument_list|,
argument|FT_Pos    threshold
argument_list|)
end_macro
begin_block
block|{
name|FT_UInt
name|i
decl_stmt|,
name|j
decl_stmt|;
name|FT_UInt
name|cur_idx
decl_stmt|;
name|FT_Pos
name|cur_val
decl_stmt|;
name|FT_Pos
name|sum
decl_stmt|;
name|AF_WidthRec
name|swap
decl_stmt|;
if|if
condition|(
operator|*
name|count
operator|==
literal|1
condition|)
return|return;
comment|/* sort */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
operator|*
name|count
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|>
literal|0
condition|;
name|j
operator|--
control|)
block|{
if|if
condition|(
name|table
index|[
name|j
index|]
operator|.
name|org
operator|>=
name|table
index|[
name|j
operator|-
literal|1
index|]
operator|.
name|org
condition|)
break|break;
name|swap
operator|=
name|table
index|[
name|j
index|]
expr_stmt|;
name|table
index|[
name|j
index|]
operator|=
name|table
index|[
name|j
operator|-
literal|1
index|]
expr_stmt|;
name|table
index|[
name|j
operator|-
literal|1
index|]
operator|=
name|swap
expr_stmt|;
block|}
block|}
name|cur_idx
operator|=
literal|0
expr_stmt|;
name|cur_val
operator|=
name|table
index|[
name|cur_idx
index|]
operator|.
name|org
expr_stmt|;
comment|/* compute and use mean values for clusters not larger than  */
comment|/* `threshold'; this is very primitive and might not yield   */
comment|/* the best result, but normally, using reference character  */
comment|/* `o', `*count' is 2, so the code below is fully sufficient */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
operator|*
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|table
index|[
name|i
index|]
operator|.
name|org
operator|-
name|cur_val
operator|>
name|threshold
operator|||
name|i
operator|==
operator|*
name|count
operator|-
literal|1
condition|)
block|{
name|sum
operator|=
literal|0
expr_stmt|;
comment|/* fix loop for end of array */
if|if
condition|(
name|table
index|[
name|i
index|]
operator|.
name|org
operator|-
name|cur_val
operator|<=
name|threshold
operator|&&
name|i
operator|==
operator|*
name|count
operator|-
literal|1
condition|)
name|i
operator|++
expr_stmt|;
for|for
control|(
name|j
operator|=
name|cur_idx
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
block|{
name|sum
operator|+=
name|table
index|[
name|j
index|]
operator|.
name|org
expr_stmt|;
name|table
index|[
name|j
index|]
operator|.
name|org
operator|=
literal|0
expr_stmt|;
block|}
name|table
index|[
name|cur_idx
index|]
operator|.
name|org
operator|=
name|sum
operator|/
name|j
expr_stmt|;
if|if
condition|(
name|i
operator|<
operator|*
name|count
operator|-
literal|1
condition|)
block|{
name|cur_idx
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|cur_val
operator|=
name|table
index|[
name|cur_idx
index|]
operator|.
name|org
expr_stmt|;
block|}
block|}
block|}
name|cur_idx
operator|=
literal|1
expr_stmt|;
comment|/* compress array to remove zero values */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
operator|*
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|table
index|[
name|i
index|]
operator|.
name|org
condition|)
name|table
index|[
name|cur_idx
operator|++
index|]
operator|=
name|table
index|[
name|i
index|]
expr_stmt|;
block|}
operator|*
name|count
operator|=
name|cur_idx
expr_stmt|;
block|}
end_block
begin_comment
comment|/* END */
end_comment
end_unit
