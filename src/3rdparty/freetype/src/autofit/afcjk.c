begin_unit
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  afcjk.c                                                                */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*    Auto-fitter hinting routines for CJK writing system (body).          */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  Copyright 2006-2014 by                                                 */
end_comment
begin_comment
comment|/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  This file is part of the FreeType project, and may only be used,       */
end_comment
begin_comment
comment|/*  modified, and distributed under the terms of the FreeType project      */
end_comment
begin_comment
comment|/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
end_comment
begin_comment
comment|/*  this file you indicate that you have read the license and              */
end_comment
begin_comment
comment|/*  understand and accept it fully.                                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*    *  The algorithm is based on akito's autohint patch, available here:    *    *  http://www.kde.gr.jp/~akito/patch/freetype2/    *    */
end_comment
begin_include
include|#
directive|include
file|<ft2build.h>
end_include
begin_include
include|#
directive|include
include|FT_ADVANCES_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_DEBUG_H
end_include
begin_include
include|#
directive|include
file|"afglobal.h"
end_include
begin_include
include|#
directive|include
file|"afpic.h"
end_include
begin_include
include|#
directive|include
file|"aflatin.h"
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|AF_CONFIG_OPTION_CJK
end_ifdef
begin_undef
DECL|macro|AF_CONFIG_OPTION_CJK_BLUE_HANI_VERT
undef|#
directive|undef
name|AF_CONFIG_OPTION_CJK_BLUE_HANI_VERT
end_undef
begin_include
include|#
directive|include
file|"afcjk.h"
end_include
begin_include
include|#
directive|include
file|"aferrors.h"
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|AF_CONFIG_OPTION_USE_WARPER
end_ifdef
begin_include
include|#
directive|include
file|"afwarp.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
end_comment
begin_comment
comment|/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
end_comment
begin_comment
comment|/* messages during execution.                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_undef
DECL|macro|FT_COMPONENT
undef|#
directive|undef
name|FT_COMPONENT
end_undef
begin_define
DECL|macro|FT_COMPONENT
define|#
directive|define
name|FT_COMPONENT
value|trace_afcjk
end_define
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****              C J K   G L O B A L   M E T R I C S              *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/* Basically the Latin version with AF_CJKMetrics */
end_comment
begin_comment
comment|/* to replace AF_LatinMetrics.                    */
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|af_cjk_metrics_init_widths
name|af_cjk_metrics_init_widths
argument_list|(
argument|AF_CJKMetrics  metrics
argument_list|,
argument|FT_Face        face
argument_list|)
end_macro
begin_block
block|{
comment|/* scan the array of segments in each direction */
name|AF_GlyphHintsRec
name|hints
index|[
literal|1
index|]
decl_stmt|;
name|FT_TRACE5
argument_list|(
operator|(
literal|"\n"
literal|"cjk standard widths computation (style `%s')\n"
literal|"===================================================\n"
literal|"\n"
operator|,
name|af_style_names
index|[
name|metrics
operator|->
name|root
operator|.
name|style_class
operator|->
name|style
index|]
operator|)
argument_list|)
expr_stmt|;
name|af_glyph_hints_init
argument_list|(
name|hints
argument_list|,
name|face
operator|->
name|memory
argument_list|)
expr_stmt|;
name|metrics
operator|->
name|axis
index|[
name|AF_DIMENSION_HORZ
index|]
operator|.
name|width_count
operator|=
literal|0
expr_stmt|;
name|metrics
operator|->
name|axis
index|[
name|AF_DIMENSION_VERT
index|]
operator|.
name|width_count
operator|=
literal|0
expr_stmt|;
block|{
name|FT_Error
name|error
decl_stmt|;
name|FT_ULong
name|glyph_index
decl_stmt|;
name|FT_Long
name|y_offset
decl_stmt|;
name|int
name|dim
decl_stmt|;
name|AF_CJKMetricsRec
name|dummy
index|[
literal|1
index|]
decl_stmt|;
name|AF_Scaler
name|scaler
init|=
operator|&
name|dummy
operator|->
name|root
operator|.
name|scaler
decl_stmt|;
ifdef|#
directive|ifdef
name|FT_CONFIG_OPTION_PIC
name|AF_FaceGlobals
name|globals
init|=
name|metrics
operator|->
name|root
operator|.
name|globals
decl_stmt|;
endif|#
directive|endif
name|AF_StyleClass
name|style_class
init|=
name|metrics
operator|->
name|root
operator|.
name|style_class
decl_stmt|;
name|AF_ScriptClass
name|script_class
init|=
name|AF_SCRIPT_CLASSES_GET
index|[
name|style_class
operator|->
name|script
index|]
decl_stmt|;
name|FT_UInt32
name|standard_char
decl_stmt|;
name|standard_char
operator|=
name|script_class
operator|->
name|standard_char1
expr_stmt|;
name|af_get_char_index
argument_list|(
operator|&
name|metrics
operator|->
name|root
argument_list|,
name|standard_char
argument_list|,
operator|&
name|glyph_index
argument_list|,
operator|&
name|y_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|glyph_index
condition|)
block|{
if|if
condition|(
name|script_class
operator|->
name|standard_char2
condition|)
block|{
name|standard_char
operator|=
name|script_class
operator|->
name|standard_char2
expr_stmt|;
name|af_get_char_index
argument_list|(
operator|&
name|metrics
operator|->
name|root
argument_list|,
name|standard_char
argument_list|,
operator|&
name|glyph_index
argument_list|,
operator|&
name|y_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|glyph_index
condition|)
block|{
if|if
condition|(
name|script_class
operator|->
name|standard_char3
condition|)
block|{
name|standard_char
operator|=
name|script_class
operator|->
name|standard_char3
expr_stmt|;
name|af_get_char_index
argument_list|(
operator|&
name|metrics
operator|->
name|root
argument_list|,
name|standard_char
argument_list|,
operator|&
name|glyph_index
argument_list|,
operator|&
name|y_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|glyph_index
condition|)
goto|goto
name|Exit
goto|;
block|}
else|else
goto|goto
name|Exit
goto|;
block|}
block|}
else|else
goto|goto
name|Exit
goto|;
block|}
name|FT_TRACE5
argument_list|(
operator|(
literal|"standard character: U+%04lX (glyph index %d)\n"
operator|,
name|standard_char
operator|,
name|glyph_index
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|FT_Load_Glyph
argument_list|(
name|face
argument_list|,
name|glyph_index
argument_list|,
name|FT_LOAD_NO_SCALE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|face
operator|->
name|glyph
operator|->
name|outline
operator|.
name|n_points
operator|<=
literal|0
condition|)
goto|goto
name|Exit
goto|;
name|FT_ZERO
argument_list|(
name|dummy
argument_list|)
expr_stmt|;
name|dummy
operator|->
name|units_per_em
operator|=
name|metrics
operator|->
name|units_per_em
expr_stmt|;
name|scaler
operator|->
name|x_scale
operator|=
literal|0x10000L
expr_stmt|;
name|scaler
operator|->
name|y_scale
operator|=
literal|0x10000L
expr_stmt|;
name|scaler
operator|->
name|x_delta
operator|=
literal|0
expr_stmt|;
name|scaler
operator|->
name|y_delta
operator|=
literal|0
expr_stmt|;
name|scaler
operator|->
name|face
operator|=
name|face
expr_stmt|;
name|scaler
operator|->
name|render_mode
operator|=
name|FT_RENDER_MODE_NORMAL
expr_stmt|;
name|scaler
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|af_glyph_hints_rescale
argument_list|(
name|hints
argument_list|,
operator|(
name|AF_StyleMetrics
operator|)
name|dummy
argument_list|)
expr_stmt|;
name|error
operator|=
name|af_glyph_hints_reload
argument_list|(
name|hints
argument_list|,
operator|&
name|face
operator|->
name|glyph
operator|->
name|outline
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
for|for
control|(
name|dim
operator|=
literal|0
init|;
name|dim
operator|<
name|AF_DIMENSION_MAX
condition|;
name|dim
operator|++
control|)
block|{
name|AF_CJKAxis
name|axis
init|=
operator|&
name|metrics
operator|->
name|axis
index|[
name|dim
index|]
decl_stmt|;
name|AF_AxisHints
name|axhints
init|=
operator|&
name|hints
operator|->
name|axis
index|[
name|dim
index|]
decl_stmt|;
name|AF_Segment
name|seg
decl_stmt|,
name|limit
decl_stmt|,
name|link
decl_stmt|;
name|FT_UInt
name|num_widths
init|=
literal|0
decl_stmt|;
name|error
operator|=
name|af_latin_hints_compute_segments
argument_list|(
name|hints
argument_list|,
operator|(
name|AF_Dimension
operator|)
name|dim
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|af_latin_hints_link_segments
argument_list|(
name|hints
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|(
name|AF_Dimension
operator|)
name|dim
argument_list|)
expr_stmt|;
name|seg
operator|=
name|axhints
operator|->
name|segments
expr_stmt|;
name|limit
operator|=
name|seg
operator|+
name|axhints
operator|->
name|num_segments
expr_stmt|;
for|for
control|(
init|;
name|seg
operator|<
name|limit
condition|;
name|seg
operator|++
control|)
block|{
name|link
operator|=
name|seg
operator|->
name|link
expr_stmt|;
comment|/* we only consider stem segments there! */
if|if
condition|(
name|link
operator|&&
name|link
operator|->
name|link
operator|==
name|seg
operator|&&
name|link
operator|>
name|seg
condition|)
block|{
name|FT_Pos
name|dist
decl_stmt|;
name|dist
operator|=
name|seg
operator|->
name|pos
operator|-
name|link
operator|->
name|pos
expr_stmt|;
if|if
condition|(
name|dist
operator|<
literal|0
condition|)
name|dist
operator|=
operator|-
name|dist
expr_stmt|;
if|if
condition|(
name|num_widths
operator|<
name|AF_CJK_MAX_WIDTHS
condition|)
name|axis
operator|->
name|widths
index|[
name|num_widths
operator|++
index|]
operator|.
name|org
operator|=
name|dist
expr_stmt|;
block|}
block|}
comment|/* this also replaces multiple almost identical stem widths */
comment|/* with a single one (the value 100 is heuristic)           */
name|af_sort_and_quantize_widths
argument_list|(
operator|&
name|num_widths
argument_list|,
name|axis
operator|->
name|widths
argument_list|,
name|dummy
operator|->
name|units_per_em
operator|/
literal|100
argument_list|)
expr_stmt|;
name|axis
operator|->
name|width_count
operator|=
name|num_widths
expr_stmt|;
block|}
name|Exit
label|:
for|for
control|(
name|dim
operator|=
literal|0
init|;
name|dim
operator|<
name|AF_DIMENSION_MAX
condition|;
name|dim
operator|++
control|)
block|{
name|AF_CJKAxis
name|axis
init|=
operator|&
name|metrics
operator|->
name|axis
index|[
name|dim
index|]
decl_stmt|;
name|FT_Pos
name|stdw
decl_stmt|;
name|stdw
operator|=
operator|(
name|axis
operator|->
name|width_count
operator|>
literal|0
operator|)
condition|?
name|axis
operator|->
name|widths
index|[
literal|0
index|]
operator|.
name|org
else|:
name|AF_LATIN_CONSTANT
argument_list|(
name|metrics
argument_list|,
literal|50
argument_list|)
expr_stmt|;
comment|/* let's try 20% of the smallest width */
name|axis
operator|->
name|edge_distance_threshold
operator|=
name|stdw
operator|/
literal|5
expr_stmt|;
name|axis
operator|->
name|standard_width
operator|=
name|stdw
expr_stmt|;
name|axis
operator|->
name|extra_light
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|FT_DEBUG_LEVEL_TRACE
block|{
name|FT_UInt
name|i
decl_stmt|;
name|FT_TRACE5
argument_list|(
operator|(
literal|"%s widths:\n"
operator|,
name|dim
operator|==
name|AF_DIMENSION_VERT
condition|?
literal|"horizontal"
else|:
literal|"vertical"
operator|)
argument_list|)
expr_stmt|;
name|FT_TRACE5
argument_list|(
operator|(
literal|"  %d (standard)"
operator|,
name|axis
operator|->
name|standard_width
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|axis
operator|->
name|width_count
condition|;
name|i
operator|++
control|)
name|FT_TRACE5
argument_list|(
operator|(
literal|" %d"
operator|,
name|axis
operator|->
name|widths
index|[
name|i
index|]
operator|.
name|org
operator|)
argument_list|)
expr_stmt|;
name|FT_TRACE5
argument_list|(
operator|(
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
name|FT_TRACE5
argument_list|(
operator|(
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
name|af_glyph_hints_done
argument_list|(
name|hints
argument_list|)
expr_stmt|;
block|}
end_block
begin_comment
comment|/* Find all blue zones. */
end_comment
begin_function
specifier|static
name|void
DECL|function|af_cjk_metrics_init_blues
name|af_cjk_metrics_init_blues
parameter_list|(
name|AF_CJKMetrics
name|metrics
parameter_list|,
name|FT_Face
name|face
parameter_list|)
block|{
name|FT_Pos
name|fills
index|[
name|AF_BLUE_STRING_MAX_LEN
index|]
decl_stmt|;
name|FT_Pos
name|flats
index|[
name|AF_BLUE_STRING_MAX_LEN
index|]
decl_stmt|;
name|FT_Int
name|num_fills
decl_stmt|;
name|FT_Int
name|num_flats
decl_stmt|;
name|FT_Bool
name|fill
decl_stmt|;
name|AF_CJKBlue
name|blue
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|AF_CJKAxis
name|axis
decl_stmt|;
name|FT_Outline
name|outline
decl_stmt|;
name|AF_StyleClass
name|sc
init|=
name|metrics
operator|->
name|root
operator|.
name|style_class
decl_stmt|;
name|AF_Blue_Stringset
name|bss
init|=
name|sc
operator|->
name|blue_stringset
decl_stmt|;
specifier|const
name|AF_Blue_StringRec
modifier|*
name|bs
init|=
operator|&
name|af_blue_stringsets
index|[
name|bss
index|]
decl_stmt|;
comment|/* we walk over the blue character strings as specified in the   */
comment|/* style's entry in the `af_blue_stringset' array, computing its */
comment|/* extremum points (depending on the string properties)          */
name|FT_TRACE5
argument_list|(
operator|(
literal|"cjk blue zones computation\n"
literal|"==========================\n"
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|bs
operator|->
name|string
operator|!=
name|AF_BLUE_STRING_MAX
condition|;
name|bs
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|p
init|=
operator|&
name|af_blue_strings
index|[
name|bs
operator|->
name|string
index|]
decl_stmt|;
name|FT_Pos
modifier|*
name|blue_ref
decl_stmt|;
name|FT_Pos
modifier|*
name|blue_shoot
decl_stmt|;
if|if
condition|(
name|AF_CJK_IS_HORIZ_BLUE
argument_list|(
name|bs
argument_list|)
condition|)
name|axis
operator|=
operator|&
name|metrics
operator|->
name|axis
index|[
name|AF_DIMENSION_HORZ
index|]
expr_stmt|;
else|else
name|axis
operator|=
operator|&
name|metrics
operator|->
name|axis
index|[
name|AF_DIMENSION_VERT
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|FT_DEBUG_LEVEL_TRACE
block|{
name|FT_String
modifier|*
name|cjk_blue_name
index|[
literal|4
index|]
init|=
block|{
operator|(
name|FT_String
operator|*
operator|)
literal|"bottom"
block|,
comment|/* --   , --  */
operator|(
name|FT_String
operator|*
operator|)
literal|"top"
block|,
comment|/* --   , TOP */
operator|(
name|FT_String
operator|*
operator|)
literal|"left"
block|,
comment|/* HORIZ, --  */
operator|(
name|FT_String
operator|*
operator|)
literal|"right"
comment|/* HORIZ, TOP */
block|}
decl_stmt|;
name|FT_TRACE5
argument_list|(
operator|(
literal|"blue zone %d (%s):\n"
operator|,
name|axis
operator|->
name|blue_count
operator|,
name|cjk_blue_name
index|[
name|AF_CJK_IS_HORIZ_BLUE
argument_list|(
name|bs
argument_list|)
operator||
name|AF_CJK_IS_TOP_BLUE
argument_list|(
name|bs
argument_list|)
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* FT_DEBUG_LEVEL_TRACE */
name|num_fills
operator|=
literal|0
expr_stmt|;
name|num_flats
operator|=
literal|0
expr_stmt|;
name|fill
operator|=
literal|1
expr_stmt|;
comment|/* start with characters that define fill values */
name|FT_TRACE5
argument_list|(
operator|(
literal|"  [overshoot values]\n"
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
name|FT_ULong
name|ch
decl_stmt|;
name|FT_ULong
name|glyph_index
decl_stmt|;
name|FT_Long
name|y_offset
decl_stmt|;
name|FT_Pos
name|best_pos
decl_stmt|;
comment|/* same as points.y or points.x, resp. */
name|FT_Int
name|best_point
decl_stmt|;
name|FT_Vector
modifier|*
name|points
decl_stmt|;
name|GET_UTF8_CHAR
argument_list|(
name|ch
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* switch to characters that define flat values */
if|if
condition|(
name|ch
operator|==
literal|'|'
condition|)
block|{
name|fill
operator|=
literal|0
expr_stmt|;
name|FT_TRACE5
argument_list|(
operator|(
literal|"  [reference values]\n"
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* load the character in the face -- skip unknown or empty ones */
name|af_get_char_index
argument_list|(
operator|&
name|metrics
operator|->
name|root
argument_list|,
name|ch
argument_list|,
operator|&
name|glyph_index
argument_list|,
operator|&
name|y_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|glyph_index
operator|==
literal|0
condition|)
block|{
name|FT_TRACE5
argument_list|(
operator|(
literal|"  U+%04lX unavailable\n"
operator|,
name|ch
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|error
operator|=
name|FT_Load_Glyph
argument_list|(
name|face
argument_list|,
name|glyph_index
argument_list|,
name|FT_LOAD_NO_SCALE
argument_list|)
expr_stmt|;
name|outline
operator|=
name|face
operator|->
name|glyph
operator|->
name|outline
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|outline
operator|.
name|n_points
operator|<=
literal|0
condition|)
block|{
name|FT_TRACE5
argument_list|(
operator|(
literal|"  U+%04lX contains no outlines\n"
operator|,
name|ch
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* now compute min or max point indices and coordinates */
name|points
operator|=
name|outline
operator|.
name|points
expr_stmt|;
name|best_point
operator|=
operator|-
literal|1
expr_stmt|;
name|best_pos
operator|=
literal|0
expr_stmt|;
comment|/* make compiler happy */
block|{
name|FT_Int
name|nn
decl_stmt|;
name|FT_Int
name|first
init|=
literal|0
decl_stmt|;
name|FT_Int
name|last
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|nn
operator|=
literal|0
init|;
name|nn
operator|<
name|outline
operator|.
name|n_contours
condition|;
name|first
operator|=
name|last
operator|+
literal|1
operator|,
name|nn
operator|++
control|)
block|{
name|FT_Int
name|pp
decl_stmt|;
name|last
operator|=
name|outline
operator|.
name|contours
index|[
name|nn
index|]
expr_stmt|;
comment|/* Avoid single-point contours since they are never rasterized. */
comment|/* In some fonts, they correspond to mark attachment points     */
comment|/* which are way outside of the glyph's real outline.           */
if|if
condition|(
name|last
operator|<=
name|first
condition|)
continue|continue;
if|if
condition|(
name|AF_CJK_IS_HORIZ_BLUE
argument_list|(
name|bs
argument_list|)
condition|)
block|{
if|if
condition|(
name|AF_CJK_IS_RIGHT_BLUE
argument_list|(
name|bs
argument_list|)
condition|)
block|{
for|for
control|(
name|pp
operator|=
name|first
init|;
name|pp
operator|<=
name|last
condition|;
name|pp
operator|++
control|)
if|if
condition|(
name|best_point
operator|<
literal|0
operator|||
name|points
index|[
name|pp
index|]
operator|.
name|x
operator|>
name|best_pos
condition|)
block|{
name|best_point
operator|=
name|pp
expr_stmt|;
name|best_pos
operator|=
name|points
index|[
name|pp
index|]
operator|.
name|x
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|pp
operator|=
name|first
init|;
name|pp
operator|<=
name|last
condition|;
name|pp
operator|++
control|)
if|if
condition|(
name|best_point
operator|<
literal|0
operator|||
name|points
index|[
name|pp
index|]
operator|.
name|x
operator|<
name|best_pos
condition|)
block|{
name|best_point
operator|=
name|pp
expr_stmt|;
name|best_pos
operator|=
name|points
index|[
name|pp
index|]
operator|.
name|x
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|AF_CJK_IS_TOP_BLUE
argument_list|(
name|bs
argument_list|)
condition|)
block|{
for|for
control|(
name|pp
operator|=
name|first
init|;
name|pp
operator|<=
name|last
condition|;
name|pp
operator|++
control|)
if|if
condition|(
name|best_point
operator|<
literal|0
operator|||
name|points
index|[
name|pp
index|]
operator|.
name|y
operator|>
name|best_pos
condition|)
block|{
name|best_point
operator|=
name|pp
expr_stmt|;
name|best_pos
operator|=
name|points
index|[
name|pp
index|]
operator|.
name|y
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|pp
operator|=
name|first
init|;
name|pp
operator|<=
name|last
condition|;
name|pp
operator|++
control|)
if|if
condition|(
name|best_point
operator|<
literal|0
operator|||
name|points
index|[
name|pp
index|]
operator|.
name|y
operator|<
name|best_pos
condition|)
block|{
name|best_point
operator|=
name|pp
expr_stmt|;
name|best_pos
operator|=
name|points
index|[
name|pp
index|]
operator|.
name|y
expr_stmt|;
block|}
block|}
block|}
block|}
name|FT_TRACE5
argument_list|(
operator|(
literal|"  U+%04lX: best_pos = %5ld\n"
operator|,
name|ch
operator|,
name|best_pos
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fill
condition|)
name|fills
index|[
name|num_fills
operator|++
index|]
operator|=
name|best_pos
expr_stmt|;
else|else
name|flats
index|[
name|num_flats
operator|++
index|]
operator|=
name|best_pos
expr_stmt|;
block|}
if|if
condition|(
name|num_flats
operator|==
literal|0
operator|&&
name|num_fills
operator|==
literal|0
condition|)
block|{
comment|/*          *  we couldn't find a single glyph to compute this blue zone,          *  we will simply ignore it then          */
name|FT_TRACE5
argument_list|(
operator|(
literal|"  empty\n"
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* we have computed the contents of the `fill' and `flats' tables,   */
comment|/* now determine the reference and overshoot position of the blue -- */
comment|/* we simply take the median value after a simple sort               */
name|af_sort_pos
argument_list|(
name|num_fills
argument_list|,
name|fills
argument_list|)
expr_stmt|;
name|af_sort_pos
argument_list|(
name|num_flats
argument_list|,
name|flats
argument_list|)
expr_stmt|;
name|blue
operator|=
operator|&
name|axis
operator|->
name|blues
index|[
name|axis
operator|->
name|blue_count
index|]
expr_stmt|;
name|blue_ref
operator|=
operator|&
name|blue
operator|->
name|ref
operator|.
name|org
expr_stmt|;
name|blue_shoot
operator|=
operator|&
name|blue
operator|->
name|shoot
operator|.
name|org
expr_stmt|;
name|axis
operator|->
name|blue_count
operator|++
expr_stmt|;
if|if
condition|(
name|num_flats
operator|==
literal|0
condition|)
block|{
operator|*
name|blue_ref
operator|=
operator|*
name|blue_shoot
operator|=
name|fills
index|[
name|num_fills
operator|/
literal|2
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|num_fills
operator|==
literal|0
condition|)
block|{
operator|*
name|blue_ref
operator|=
operator|*
name|blue_shoot
operator|=
name|flats
index|[
name|num_flats
operator|/
literal|2
index|]
expr_stmt|;
block|}
else|else
block|{
operator|*
name|blue_ref
operator|=
name|fills
index|[
name|num_fills
operator|/
literal|2
index|]
expr_stmt|;
operator|*
name|blue_shoot
operator|=
name|flats
index|[
name|num_flats
operator|/
literal|2
index|]
expr_stmt|;
block|}
comment|/* make sure blue_ref>= blue_shoot for top/right or */
comment|/* vice versa for bottom/left                        */
if|if
condition|(
operator|*
name|blue_shoot
operator|!=
operator|*
name|blue_ref
condition|)
block|{
name|FT_Pos
name|ref
init|=
operator|*
name|blue_ref
decl_stmt|;
name|FT_Pos
name|shoot
init|=
operator|*
name|blue_shoot
decl_stmt|;
name|FT_Bool
name|under_ref
init|=
name|FT_BOOL
argument_list|(
name|shoot
operator|<
name|ref
argument_list|)
decl_stmt|;
comment|/* AF_CJK_IS_TOP_BLUE covers `right' and `top' */
if|if
condition|(
name|AF_CJK_IS_TOP_BLUE
argument_list|(
name|bs
argument_list|)
operator|^
name|under_ref
condition|)
block|{
operator|*
name|blue_ref
operator|=
operator|*
name|blue_shoot
operator|=
operator|(
name|shoot
operator|+
name|ref
operator|)
operator|/
literal|2
expr_stmt|;
name|FT_TRACE5
argument_list|(
operator|(
literal|"  [reference smaller than overshoot,"
literal|" taking mean value]\n"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
name|blue
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|AF_CJK_IS_TOP_BLUE
argument_list|(
name|bs
argument_list|)
condition|)
name|blue
operator|->
name|flags
operator||=
name|AF_CJK_BLUE_TOP
expr_stmt|;
name|FT_TRACE5
argument_list|(
operator|(
literal|"    -> reference = %ld\n"
literal|"       overshoot = %ld\n"
operator|,
operator|*
name|blue_ref
operator|,
operator|*
name|blue_shoot
operator|)
argument_list|)
expr_stmt|;
block|}
name|FT_TRACE5
argument_list|(
operator|(
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function
begin_comment
comment|/* Basically the Latin version with type AF_CJKMetrics for metrics. */
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|af_cjk_metrics_check_digits
name|af_cjk_metrics_check_digits
argument_list|(
argument|AF_CJKMetrics  metrics
argument_list|,
argument|FT_Face        face
argument_list|)
end_macro
begin_block
block|{
name|FT_UInt
name|i
decl_stmt|;
name|FT_Bool
name|started
init|=
literal|0
decl_stmt|,
name|same_width
init|=
literal|1
decl_stmt|;
name|FT_Fixed
name|advance
decl_stmt|,
name|old_advance
init|=
literal|0
decl_stmt|;
comment|/* digit `0' is 0x30 in all supported charmaps */
for|for
control|(
name|i
operator|=
literal|0x30
init|;
name|i
operator|<=
literal|0x39
condition|;
name|i
operator|++
control|)
block|{
name|FT_ULong
name|glyph_index
decl_stmt|;
name|FT_Long
name|y_offset
decl_stmt|;
name|af_get_char_index
argument_list|(
operator|&
name|metrics
operator|->
name|root
argument_list|,
name|i
argument_list|,
operator|&
name|glyph_index
argument_list|,
operator|&
name|y_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|glyph_index
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|FT_Get_Advance
argument_list|(
name|face
argument_list|,
name|glyph_index
argument_list|,
name|FT_LOAD_NO_SCALE
operator||
name|FT_LOAD_NO_HINTING
operator||
name|FT_LOAD_IGNORE_TRANSFORM
argument_list|,
operator|&
name|advance
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|started
condition|)
block|{
if|if
condition|(
name|advance
operator|!=
name|old_advance
condition|)
block|{
name|same_width
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|old_advance
operator|=
name|advance
expr_stmt|;
name|started
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|metrics
operator|->
name|root
operator|.
name|digits_have_same_width
operator|=
name|same_width
expr_stmt|;
block|}
end_block
begin_comment
comment|/* Initialize global metrics. */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|af_cjk_metrics_init
argument_list|(
argument|AF_CJKMetrics  metrics
argument_list|,
argument|FT_Face        face
argument_list|)
end_macro
begin_block
block|{
name|FT_CharMap
name|oldmap
init|=
name|face
operator|->
name|charmap
decl_stmt|;
name|metrics
operator|->
name|units_per_em
operator|=
name|face
operator|->
name|units_per_EM
expr_stmt|;
if|if
condition|(
operator|!
name|FT_Select_Charmap
argument_list|(
name|face
argument_list|,
name|FT_ENCODING_UNICODE
argument_list|)
condition|)
block|{
name|af_cjk_metrics_init_widths
argument_list|(
name|metrics
argument_list|,
name|face
argument_list|)
expr_stmt|;
name|af_cjk_metrics_init_blues
argument_list|(
name|metrics
argument_list|,
name|face
argument_list|)
expr_stmt|;
name|af_cjk_metrics_check_digits
argument_list|(
name|metrics
argument_list|,
name|face
argument_list|)
expr_stmt|;
block|}
name|FT_Set_Charmap
argument_list|(
name|face
argument_list|,
name|oldmap
argument_list|)
expr_stmt|;
return|return
name|FT_Err_Ok
return|;
block|}
end_block
begin_comment
comment|/* Adjust scaling value, then scale and shift widths   */
end_comment
begin_comment
comment|/* and blue zones (if applicable) for given dimension. */
end_comment
begin_function
specifier|static
name|void
DECL|function|af_cjk_metrics_scale_dim
name|af_cjk_metrics_scale_dim
parameter_list|(
name|AF_CJKMetrics
name|metrics
parameter_list|,
name|AF_Scaler
name|scaler
parameter_list|,
name|AF_Dimension
name|dim
parameter_list|)
block|{
name|FT_Fixed
name|scale
decl_stmt|;
name|FT_Pos
name|delta
decl_stmt|;
name|AF_CJKAxis
name|axis
decl_stmt|;
name|FT_UInt
name|nn
decl_stmt|;
if|if
condition|(
name|dim
operator|==
name|AF_DIMENSION_HORZ
condition|)
block|{
name|scale
operator|=
name|scaler
operator|->
name|x_scale
expr_stmt|;
name|delta
operator|=
name|scaler
operator|->
name|x_delta
expr_stmt|;
block|}
else|else
block|{
name|scale
operator|=
name|scaler
operator|->
name|y_scale
expr_stmt|;
name|delta
operator|=
name|scaler
operator|->
name|y_delta
expr_stmt|;
block|}
name|axis
operator|=
operator|&
name|metrics
operator|->
name|axis
index|[
name|dim
index|]
expr_stmt|;
if|if
condition|(
name|axis
operator|->
name|org_scale
operator|==
name|scale
operator|&&
name|axis
operator|->
name|org_delta
operator|==
name|delta
condition|)
return|return;
name|axis
operator|->
name|org_scale
operator|=
name|scale
expr_stmt|;
name|axis
operator|->
name|org_delta
operator|=
name|delta
expr_stmt|;
name|axis
operator|->
name|scale
operator|=
name|scale
expr_stmt|;
name|axis
operator|->
name|delta
operator|=
name|delta
expr_stmt|;
comment|/* scale the blue zones */
for|for
control|(
name|nn
operator|=
literal|0
init|;
name|nn
operator|<
name|axis
operator|->
name|blue_count
condition|;
name|nn
operator|++
control|)
block|{
name|AF_CJKBlue
name|blue
init|=
operator|&
name|axis
operator|->
name|blues
index|[
name|nn
index|]
decl_stmt|;
name|FT_Pos
name|dist
decl_stmt|;
name|blue
operator|->
name|ref
operator|.
name|cur
operator|=
name|FT_MulFix
argument_list|(
name|blue
operator|->
name|ref
operator|.
name|org
argument_list|,
name|scale
argument_list|)
operator|+
name|delta
expr_stmt|;
name|blue
operator|->
name|ref
operator|.
name|fit
operator|=
name|blue
operator|->
name|ref
operator|.
name|cur
expr_stmt|;
name|blue
operator|->
name|shoot
operator|.
name|cur
operator|=
name|FT_MulFix
argument_list|(
name|blue
operator|->
name|shoot
operator|.
name|org
argument_list|,
name|scale
argument_list|)
operator|+
name|delta
expr_stmt|;
name|blue
operator|->
name|shoot
operator|.
name|fit
operator|=
name|blue
operator|->
name|shoot
operator|.
name|cur
expr_stmt|;
name|blue
operator|->
name|flags
operator|&=
operator|~
name|AF_CJK_BLUE_ACTIVE
expr_stmt|;
comment|/* a blue zone is only active if it is less than 3/4 pixels tall */
name|dist
operator|=
name|FT_MulFix
argument_list|(
name|blue
operator|->
name|ref
operator|.
name|org
operator|-
name|blue
operator|->
name|shoot
operator|.
name|org
argument_list|,
name|scale
argument_list|)
expr_stmt|;
if|if
condition|(
name|dist
operator|<=
literal|48
operator|&&
name|dist
operator|>=
operator|-
literal|48
condition|)
block|{
name|FT_Pos
name|delta1
decl_stmt|,
name|delta2
decl_stmt|;
name|blue
operator|->
name|ref
operator|.
name|fit
operator|=
name|FT_PIX_ROUND
argument_list|(
name|blue
operator|->
name|ref
operator|.
name|cur
argument_list|)
expr_stmt|;
comment|/* shoot is under shoot for cjk */
name|delta1
operator|=
name|FT_DivFix
argument_list|(
name|blue
operator|->
name|ref
operator|.
name|fit
argument_list|,
name|scale
argument_list|)
operator|-
name|blue
operator|->
name|shoot
operator|.
name|org
expr_stmt|;
name|delta2
operator|=
name|delta1
expr_stmt|;
if|if
condition|(
name|delta1
operator|<
literal|0
condition|)
name|delta2
operator|=
operator|-
name|delta2
expr_stmt|;
name|delta2
operator|=
name|FT_MulFix
argument_list|(
name|delta2
argument_list|,
name|scale
argument_list|)
expr_stmt|;
name|FT_TRACE5
argument_list|(
operator|(
literal|"delta: %d"
operator|,
name|delta1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|delta2
operator|<
literal|32
condition|)
name|delta2
operator|=
literal|0
expr_stmt|;
if|#
directive|if
literal|0
if|else if ( delta2< 64 )           delta2 = 32 + ( ( ( delta2 - 32 ) + 16 )& ~31 );
endif|#
directive|endif
else|else
name|delta2
operator|=
name|FT_PIX_ROUND
argument_list|(
name|delta2
argument_list|)
expr_stmt|;
name|FT_TRACE5
argument_list|(
operator|(
literal|"/%d\n"
operator|,
name|delta2
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|delta1
operator|<
literal|0
condition|)
name|delta2
operator|=
operator|-
name|delta2
expr_stmt|;
name|blue
operator|->
name|shoot
operator|.
name|fit
operator|=
name|blue
operator|->
name|ref
operator|.
name|fit
operator|-
name|delta2
expr_stmt|;
name|FT_TRACE5
argument_list|(
operator|(
literal|">> active cjk blue zone %c%d[%ld/%ld]:\n"
literal|"     ref:   cur=%.2f fit=%.2f\n"
literal|"     shoot: cur=%.2f fit=%.2f\n"
operator|,
operator|(
name|dim
operator|==
name|AF_DIMENSION_HORZ
operator|)
condition|?
literal|'H'
else|:
literal|'V'
operator|,
name|nn
operator|,
name|blue
operator|->
name|ref
operator|.
name|org
operator|,
name|blue
operator|->
name|shoot
operator|.
name|org
operator|,
name|blue
operator|->
name|ref
operator|.
name|cur
operator|/
literal|64.0
operator|,
name|blue
operator|->
name|ref
operator|.
name|fit
operator|/
literal|64.0
operator|,
name|blue
operator|->
name|shoot
operator|.
name|cur
operator|/
literal|64.0
operator|,
name|blue
operator|->
name|shoot
operator|.
name|fit
operator|/
literal|64.0
operator|)
argument_list|)
expr_stmt|;
name|blue
operator|->
name|flags
operator||=
name|AF_CJK_BLUE_ACTIVE
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/* Scale global values in both directions. */
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|af_cjk_metrics_scale
name|af_cjk_metrics_scale
argument_list|(
argument|AF_CJKMetrics  metrics
argument_list|,
argument|AF_Scaler      scaler
argument_list|)
end_macro
begin_block
block|{
comment|/* we copy the whole structure since the x and y scaling values */
comment|/* are not modified, contrary to e.g. the `latin' auto-hinter   */
name|metrics
operator|->
name|root
operator|.
name|scaler
operator|=
operator|*
name|scaler
expr_stmt|;
name|af_cjk_metrics_scale_dim
argument_list|(
name|metrics
argument_list|,
name|scaler
argument_list|,
name|AF_DIMENSION_HORZ
argument_list|)
expr_stmt|;
name|af_cjk_metrics_scale_dim
argument_list|(
name|metrics
argument_list|,
name|scaler
argument_list|,
name|AF_DIMENSION_VERT
argument_list|)
expr_stmt|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****              C J K   G L Y P H   A N A L Y S I S              *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/* Walk over all contours and compute its segments. */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|af_cjk_hints_compute_segments
name|af_cjk_hints_compute_segments
parameter_list|(
name|AF_GlyphHints
name|hints
parameter_list|,
name|AF_Dimension
name|dim
parameter_list|)
block|{
name|AF_AxisHints
name|axis
init|=
operator|&
name|hints
operator|->
name|axis
index|[
name|dim
index|]
decl_stmt|;
name|AF_Segment
name|segments
init|=
name|axis
operator|->
name|segments
decl_stmt|;
name|AF_Segment
name|segment_limit
init|=
name|segments
operator|+
name|axis
operator|->
name|num_segments
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|AF_Segment
name|seg
decl_stmt|;
name|error
operator|=
name|af_latin_hints_compute_segments
argument_list|(
name|hints
argument_list|,
name|dim
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
comment|/* a segment is round if it doesn't have successive */
comment|/* on-curve points.                                 */
for|for
control|(
name|seg
operator|=
name|segments
init|;
name|seg
operator|<
name|segment_limit
condition|;
name|seg
operator|++
control|)
block|{
name|AF_Point
name|pt
init|=
name|seg
operator|->
name|first
decl_stmt|;
name|AF_Point
name|last
init|=
name|seg
operator|->
name|last
decl_stmt|;
name|AF_Flags
name|f0
init|=
call|(
name|AF_Flags
call|)
argument_list|(
name|pt
operator|->
name|flags
operator|&
name|AF_FLAG_CONTROL
argument_list|)
decl_stmt|;
name|AF_Flags
name|f1
decl_stmt|;
name|seg
operator|->
name|flags
operator|&=
operator|~
name|AF_EDGE_ROUND
expr_stmt|;
for|for
control|(
init|;
name|pt
operator|!=
name|last
condition|;
name|f0
operator|=
name|f1
control|)
block|{
name|pt
operator|=
name|pt
operator|->
name|next
expr_stmt|;
name|f1
operator|=
call|(
name|AF_Flags
call|)
argument_list|(
name|pt
operator|->
name|flags
operator|&
name|AF_FLAG_CONTROL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|f0
operator|&&
operator|!
name|f1
condition|)
break|break;
if|if
condition|(
name|pt
operator|==
name|last
condition|)
name|seg
operator|->
name|flags
operator||=
name|AF_EDGE_ROUND
expr_stmt|;
block|}
block|}
return|return
name|FT_Err_Ok
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|af_cjk_hints_link_segments
name|af_cjk_hints_link_segments
parameter_list|(
name|AF_GlyphHints
name|hints
parameter_list|,
name|AF_Dimension
name|dim
parameter_list|)
block|{
name|AF_AxisHints
name|axis
init|=
operator|&
name|hints
operator|->
name|axis
index|[
name|dim
index|]
decl_stmt|;
name|AF_Segment
name|segments
init|=
name|axis
operator|->
name|segments
decl_stmt|;
name|AF_Segment
name|segment_limit
init|=
name|segments
operator|+
name|axis
operator|->
name|num_segments
decl_stmt|;
name|AF_Direction
name|major_dir
init|=
name|axis
operator|->
name|major_dir
decl_stmt|;
name|AF_Segment
name|seg1
decl_stmt|,
name|seg2
decl_stmt|;
name|FT_Pos
name|len_threshold
decl_stmt|;
name|FT_Pos
name|dist_threshold
decl_stmt|;
name|len_threshold
operator|=
name|AF_LATIN_CONSTANT
argument_list|(
name|hints
operator|->
name|metrics
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|dist_threshold
operator|=
operator|(
name|dim
operator|==
name|AF_DIMENSION_HORZ
operator|)
condition|?
name|hints
operator|->
name|x_scale
else|:
name|hints
operator|->
name|y_scale
expr_stmt|;
name|dist_threshold
operator|=
name|FT_DivFix
argument_list|(
literal|64
operator|*
literal|3
argument_list|,
name|dist_threshold
argument_list|)
expr_stmt|;
comment|/* now compare each segment to the others */
for|for
control|(
name|seg1
operator|=
name|segments
init|;
name|seg1
operator|<
name|segment_limit
condition|;
name|seg1
operator|++
control|)
block|{
if|if
condition|(
name|seg1
operator|->
name|dir
operator|!=
name|major_dir
condition|)
continue|continue;
for|for
control|(
name|seg2
operator|=
name|segments
init|;
name|seg2
operator|<
name|segment_limit
condition|;
name|seg2
operator|++
control|)
if|if
condition|(
name|seg2
operator|!=
name|seg1
operator|&&
name|seg1
operator|->
name|dir
operator|+
name|seg2
operator|->
name|dir
operator|==
literal|0
condition|)
block|{
name|FT_Pos
name|dist
init|=
name|seg2
operator|->
name|pos
operator|-
name|seg1
operator|->
name|pos
decl_stmt|;
if|if
condition|(
name|dist
operator|<
literal|0
condition|)
continue|continue;
block|{
name|FT_Pos
name|min
init|=
name|seg1
operator|->
name|min_coord
decl_stmt|;
name|FT_Pos
name|max
init|=
name|seg1
operator|->
name|max_coord
decl_stmt|;
name|FT_Pos
name|len
decl_stmt|;
if|if
condition|(
name|min
operator|<
name|seg2
operator|->
name|min_coord
condition|)
name|min
operator|=
name|seg2
operator|->
name|min_coord
expr_stmt|;
if|if
condition|(
name|max
operator|>
name|seg2
operator|->
name|max_coord
condition|)
name|max
operator|=
name|seg2
operator|->
name|max_coord
expr_stmt|;
name|len
operator|=
name|max
operator|-
name|min
expr_stmt|;
if|if
condition|(
name|len
operator|>=
name|len_threshold
condition|)
block|{
if|if
condition|(
name|dist
operator|*
literal|8
operator|<
name|seg1
operator|->
name|score
operator|*
literal|9
operator|&&
operator|(
name|dist
operator|*
literal|8
operator|<
name|seg1
operator|->
name|score
operator|*
literal|7
operator|||
name|seg1
operator|->
name|len
operator|<
name|len
operator|)
condition|)
block|{
name|seg1
operator|->
name|score
operator|=
name|dist
expr_stmt|;
name|seg1
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|seg1
operator|->
name|link
operator|=
name|seg2
expr_stmt|;
block|}
if|if
condition|(
name|dist
operator|*
literal|8
operator|<
name|seg2
operator|->
name|score
operator|*
literal|9
operator|&&
operator|(
name|dist
operator|*
literal|8
operator|<
name|seg2
operator|->
name|score
operator|*
literal|7
operator|||
name|seg2
operator|->
name|len
operator|<
name|len
operator|)
condition|)
block|{
name|seg2
operator|->
name|score
operator|=
name|dist
expr_stmt|;
name|seg2
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|seg2
operator|->
name|link
operator|=
name|seg1
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/*      *  now compute the `serif' segments      *      *  In Hanzi, some strokes are wider on one or both of the ends.      *  We either identify the stems on the ends as serifs or remove      *  the linkage, depending on the length of the stems.      *      */
block|{
name|AF_Segment
name|link1
decl_stmt|,
name|link2
decl_stmt|;
for|for
control|(
name|seg1
operator|=
name|segments
init|;
name|seg1
operator|<
name|segment_limit
condition|;
name|seg1
operator|++
control|)
block|{
name|link1
operator|=
name|seg1
operator|->
name|link
expr_stmt|;
if|if
condition|(
operator|!
name|link1
operator|||
name|link1
operator|->
name|link
operator|!=
name|seg1
operator|||
name|link1
operator|->
name|pos
operator|<=
name|seg1
operator|->
name|pos
condition|)
continue|continue;
if|if
condition|(
name|seg1
operator|->
name|score
operator|>=
name|dist_threshold
condition|)
continue|continue;
for|for
control|(
name|seg2
operator|=
name|segments
init|;
name|seg2
operator|<
name|segment_limit
condition|;
name|seg2
operator|++
control|)
block|{
if|if
condition|(
name|seg2
operator|->
name|pos
operator|>
name|seg1
operator|->
name|pos
operator|||
name|seg1
operator|==
name|seg2
condition|)
continue|continue;
name|link2
operator|=
name|seg2
operator|->
name|link
expr_stmt|;
if|if
condition|(
operator|!
name|link2
operator|||
name|link2
operator|->
name|link
operator|!=
name|seg2
operator|||
name|link2
operator|->
name|pos
operator|<
name|link1
operator|->
name|pos
condition|)
continue|continue;
if|if
condition|(
name|seg1
operator|->
name|pos
operator|==
name|seg2
operator|->
name|pos
operator|&&
name|link1
operator|->
name|pos
operator|==
name|link2
operator|->
name|pos
condition|)
continue|continue;
if|if
condition|(
name|seg2
operator|->
name|score
operator|<=
name|seg1
operator|->
name|score
operator|||
name|seg1
operator|->
name|score
operator|*
literal|4
operator|<=
name|seg2
operator|->
name|score
condition|)
continue|continue;
comment|/* seg2< seg1< link1< link2 */
if|if
condition|(
name|seg1
operator|->
name|len
operator|>=
name|seg2
operator|->
name|len
operator|*
literal|3
condition|)
block|{
name|AF_Segment
name|seg
decl_stmt|;
for|for
control|(
name|seg
operator|=
name|segments
init|;
name|seg
operator|<
name|segment_limit
condition|;
name|seg
operator|++
control|)
block|{
name|AF_Segment
name|link
init|=
name|seg
operator|->
name|link
decl_stmt|;
if|if
condition|(
name|link
operator|==
name|seg2
condition|)
block|{
name|seg
operator|->
name|link
operator|=
literal|0
expr_stmt|;
name|seg
operator|->
name|serif
operator|=
name|link1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|link
operator|==
name|link2
condition|)
block|{
name|seg
operator|->
name|link
operator|=
literal|0
expr_stmt|;
name|seg
operator|->
name|serif
operator|=
name|seg1
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|seg1
operator|->
name|link
operator|=
name|link1
operator|->
name|link
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
for|for
control|(
name|seg1
operator|=
name|segments
init|;
name|seg1
operator|<
name|segment_limit
condition|;
name|seg1
operator|++
control|)
block|{
name|seg2
operator|=
name|seg1
operator|->
name|link
expr_stmt|;
if|if
condition|(
name|seg2
condition|)
block|{
name|seg2
operator|->
name|num_linked
operator|++
expr_stmt|;
if|if
condition|(
name|seg2
operator|->
name|link
operator|!=
name|seg1
condition|)
block|{
name|seg1
operator|->
name|link
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|seg2
operator|->
name|score
operator|<
name|dist_threshold
operator|||
name|seg1
operator|->
name|score
operator|<
name|seg2
operator|->
name|score
operator|*
literal|4
condition|)
name|seg1
operator|->
name|serif
operator|=
name|seg2
operator|->
name|link
expr_stmt|;
else|else
name|seg2
operator|->
name|num_linked
operator|--
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|af_cjk_hints_compute_edges
name|af_cjk_hints_compute_edges
parameter_list|(
name|AF_GlyphHints
name|hints
parameter_list|,
name|AF_Dimension
name|dim
parameter_list|)
block|{
name|AF_AxisHints
name|axis
init|=
operator|&
name|hints
operator|->
name|axis
index|[
name|dim
index|]
decl_stmt|;
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|hints
operator|->
name|memory
decl_stmt|;
name|AF_CJKAxis
name|laxis
init|=
operator|&
operator|(
operator|(
name|AF_CJKMetrics
operator|)
name|hints
operator|->
name|metrics
operator|)
operator|->
name|axis
index|[
name|dim
index|]
decl_stmt|;
name|AF_Segment
name|segments
init|=
name|axis
operator|->
name|segments
decl_stmt|;
name|AF_Segment
name|segment_limit
init|=
name|segments
operator|+
name|axis
operator|->
name|num_segments
decl_stmt|;
name|AF_Segment
name|seg
decl_stmt|;
name|FT_Fixed
name|scale
decl_stmt|;
name|FT_Pos
name|edge_distance_threshold
decl_stmt|;
name|axis
operator|->
name|num_edges
operator|=
literal|0
expr_stmt|;
name|scale
operator|=
operator|(
name|dim
operator|==
name|AF_DIMENSION_HORZ
operator|)
condition|?
name|hints
operator|->
name|x_scale
else|:
name|hints
operator|->
name|y_scale
expr_stmt|;
comment|/*********************************************************************/
comment|/*                                                                   */
comment|/* We begin by generating a sorted table of edges for the current    */
comment|/* direction.  To do so, we simply scan each segment and try to find */
comment|/* an edge in our table that corresponds to its position.            */
comment|/*                                                                   */
comment|/* If no edge is found, we create and insert a new edge in the       */
comment|/* sorted table.  Otherwise, we simply add the segment to the edge's */
comment|/* list which is then processed in the second step to compute the    */
comment|/* edge's properties.                                                */
comment|/*                                                                   */
comment|/* Note that the edges table is sorted along the segment/edge        */
comment|/* position.                                                         */
comment|/*                                                                   */
comment|/*********************************************************************/
name|edge_distance_threshold
operator|=
name|FT_MulFix
argument_list|(
name|laxis
operator|->
name|edge_distance_threshold
argument_list|,
name|scale
argument_list|)
expr_stmt|;
if|if
condition|(
name|edge_distance_threshold
operator|>
literal|64
operator|/
literal|4
condition|)
name|edge_distance_threshold
operator|=
name|FT_DivFix
argument_list|(
literal|64
operator|/
literal|4
argument_list|,
name|scale
argument_list|)
expr_stmt|;
else|else
name|edge_distance_threshold
operator|=
name|laxis
operator|->
name|edge_distance_threshold
expr_stmt|;
for|for
control|(
name|seg
operator|=
name|segments
init|;
name|seg
operator|<
name|segment_limit
condition|;
name|seg
operator|++
control|)
block|{
name|AF_Edge
name|found
init|=
name|NULL
decl_stmt|;
name|FT_Pos
name|best
init|=
literal|0xFFFFU
decl_stmt|;
name|FT_Int
name|ee
decl_stmt|;
comment|/* look for an edge corresponding to the segment */
for|for
control|(
name|ee
operator|=
literal|0
init|;
name|ee
operator|<
name|axis
operator|->
name|num_edges
condition|;
name|ee
operator|++
control|)
block|{
name|AF_Edge
name|edge
init|=
name|axis
operator|->
name|edges
operator|+
name|ee
decl_stmt|;
name|FT_Pos
name|dist
decl_stmt|;
if|if
condition|(
name|edge
operator|->
name|dir
operator|!=
name|seg
operator|->
name|dir
condition|)
continue|continue;
name|dist
operator|=
name|seg
operator|->
name|pos
operator|-
name|edge
operator|->
name|fpos
expr_stmt|;
if|if
condition|(
name|dist
operator|<
literal|0
condition|)
name|dist
operator|=
operator|-
name|dist
expr_stmt|;
if|if
condition|(
name|dist
operator|<
name|edge_distance_threshold
operator|&&
name|dist
operator|<
name|best
condition|)
block|{
name|AF_Segment
name|link
init|=
name|seg
operator|->
name|link
decl_stmt|;
comment|/* check whether all linked segments of the candidate edge */
comment|/* can make a single edge.                                 */
if|if
condition|(
name|link
condition|)
block|{
name|AF_Segment
name|seg1
init|=
name|edge
operator|->
name|first
decl_stmt|;
name|FT_Pos
name|dist2
init|=
literal|0
decl_stmt|;
do|do
block|{
name|AF_Segment
name|link1
init|=
name|seg1
operator|->
name|link
decl_stmt|;
if|if
condition|(
name|link1
condition|)
block|{
name|dist2
operator|=
name|AF_SEGMENT_DIST
argument_list|(
name|link
argument_list|,
name|link1
argument_list|)
expr_stmt|;
if|if
condition|(
name|dist2
operator|>=
name|edge_distance_threshold
condition|)
break|break;
block|}
block|}
do|while
condition|(
operator|(
name|seg1
operator|=
name|seg1
operator|->
name|edge_next
operator|)
operator|!=
name|edge
operator|->
name|first
condition|)
do|;
if|if
condition|(
name|dist2
operator|>=
name|edge_distance_threshold
condition|)
continue|continue;
block|}
name|best
operator|=
name|dist
expr_stmt|;
name|found
operator|=
name|edge
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|AF_Edge
name|edge
decl_stmt|;
comment|/* insert a new edge in the list and */
comment|/* sort according to the position    */
name|error
operator|=
name|af_axis_hints_new_edge
argument_list|(
name|axis
argument_list|,
name|seg
operator|->
name|pos
argument_list|,
operator|(
name|AF_Direction
operator|)
name|seg
operator|->
name|dir
argument_list|,
name|memory
argument_list|,
operator|&
name|edge
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
comment|/* add the segment to the new edge's list */
name|FT_ZERO
argument_list|(
name|edge
argument_list|)
expr_stmt|;
name|edge
operator|->
name|first
operator|=
name|seg
expr_stmt|;
name|edge
operator|->
name|last
operator|=
name|seg
expr_stmt|;
name|edge
operator|->
name|dir
operator|=
name|seg
operator|->
name|dir
expr_stmt|;
name|edge
operator|->
name|fpos
operator|=
name|seg
operator|->
name|pos
expr_stmt|;
name|edge
operator|->
name|opos
operator|=
name|FT_MulFix
argument_list|(
name|seg
operator|->
name|pos
argument_list|,
name|scale
argument_list|)
expr_stmt|;
name|edge
operator|->
name|pos
operator|=
name|edge
operator|->
name|opos
expr_stmt|;
name|seg
operator|->
name|edge_next
operator|=
name|seg
expr_stmt|;
block|}
else|else
block|{
comment|/* if an edge was found, simply add the segment to the edge's */
comment|/* list                                                       */
name|seg
operator|->
name|edge_next
operator|=
name|found
operator|->
name|first
expr_stmt|;
name|found
operator|->
name|last
operator|->
name|edge_next
operator|=
name|seg
expr_stmt|;
name|found
operator|->
name|last
operator|=
name|seg
expr_stmt|;
block|}
block|}
comment|/******************************************************************/
comment|/*                                                                */
comment|/* Good, we now compute each edge's properties according to the   */
comment|/* segments found on its position.  Basically, these are          */
comment|/*                                                                */
comment|/*  - the edge's main direction                                   */
comment|/*  - stem edge, serif edge or both (which defaults to stem then) */
comment|/*  - rounded edge, straight or both (which defaults to straight) */
comment|/*  - link for edge                                               */
comment|/*                                                                */
comment|/******************************************************************/
comment|/* first of all, set the `edge' field in each segment -- this is */
comment|/* required in order to compute edge links                       */
comment|/*      * Note that removing this loop and setting the `edge' field of each      * segment directly in the code above slows down execution speed for      * some reasons on platforms like the Sun.      */
block|{
name|AF_Edge
name|edges
init|=
name|axis
operator|->
name|edges
decl_stmt|;
name|AF_Edge
name|edge_limit
init|=
name|edges
operator|+
name|axis
operator|->
name|num_edges
decl_stmt|;
name|AF_Edge
name|edge
decl_stmt|;
for|for
control|(
name|edge
operator|=
name|edges
init|;
name|edge
operator|<
name|edge_limit
condition|;
name|edge
operator|++
control|)
block|{
name|seg
operator|=
name|edge
operator|->
name|first
expr_stmt|;
if|if
condition|(
name|seg
condition|)
do|do
block|{
name|seg
operator|->
name|edge
operator|=
name|edge
expr_stmt|;
name|seg
operator|=
name|seg
operator|->
name|edge_next
expr_stmt|;
block|}
do|while
condition|(
name|seg
operator|!=
name|edge
operator|->
name|first
condition|)
do|;
block|}
comment|/* now compute each edge properties */
for|for
control|(
name|edge
operator|=
name|edges
init|;
name|edge
operator|<
name|edge_limit
condition|;
name|edge
operator|++
control|)
block|{
name|FT_Int
name|is_round
init|=
literal|0
decl_stmt|;
comment|/* does it contain round segments?    */
name|FT_Int
name|is_straight
init|=
literal|0
decl_stmt|;
comment|/* does it contain straight segments? */
name|seg
operator|=
name|edge
operator|->
name|first
expr_stmt|;
do|do
block|{
name|FT_Bool
name|is_serif
decl_stmt|;
comment|/* check for roundness of segment */
if|if
condition|(
name|seg
operator|->
name|flags
operator|&
name|AF_EDGE_ROUND
condition|)
name|is_round
operator|++
expr_stmt|;
else|else
name|is_straight
operator|++
expr_stmt|;
comment|/* check for links -- if seg->serif is set, then seg->link must */
comment|/* be ignored                                                   */
name|is_serif
operator|=
call|(
name|FT_Bool
call|)
argument_list|(
name|seg
operator|->
name|serif
operator|&&
name|seg
operator|->
name|serif
operator|->
name|edge
operator|!=
name|edge
argument_list|)
expr_stmt|;
if|if
condition|(
name|seg
operator|->
name|link
operator|||
name|is_serif
condition|)
block|{
name|AF_Edge
name|edge2
decl_stmt|;
name|AF_Segment
name|seg2
decl_stmt|;
name|edge2
operator|=
name|edge
operator|->
name|link
expr_stmt|;
name|seg2
operator|=
name|seg
operator|->
name|link
expr_stmt|;
if|if
condition|(
name|is_serif
condition|)
block|{
name|seg2
operator|=
name|seg
operator|->
name|serif
expr_stmt|;
name|edge2
operator|=
name|edge
operator|->
name|serif
expr_stmt|;
block|}
if|if
condition|(
name|edge2
condition|)
block|{
name|FT_Pos
name|edge_delta
decl_stmt|;
name|FT_Pos
name|seg_delta
decl_stmt|;
name|edge_delta
operator|=
name|edge
operator|->
name|fpos
operator|-
name|edge2
operator|->
name|fpos
expr_stmt|;
if|if
condition|(
name|edge_delta
operator|<
literal|0
condition|)
name|edge_delta
operator|=
operator|-
name|edge_delta
expr_stmt|;
name|seg_delta
operator|=
name|AF_SEGMENT_DIST
argument_list|(
name|seg
argument_list|,
name|seg2
argument_list|)
expr_stmt|;
if|if
condition|(
name|seg_delta
operator|<
name|edge_delta
condition|)
name|edge2
operator|=
name|seg2
operator|->
name|edge
expr_stmt|;
block|}
else|else
name|edge2
operator|=
name|seg2
operator|->
name|edge
expr_stmt|;
if|if
condition|(
name|is_serif
condition|)
block|{
name|edge
operator|->
name|serif
operator|=
name|edge2
expr_stmt|;
name|edge2
operator|->
name|flags
operator||=
name|AF_EDGE_SERIF
expr_stmt|;
block|}
else|else
name|edge
operator|->
name|link
operator|=
name|edge2
expr_stmt|;
block|}
name|seg
operator|=
name|seg
operator|->
name|edge_next
expr_stmt|;
block|}
do|while
condition|(
name|seg
operator|!=
name|edge
operator|->
name|first
condition|)
do|;
comment|/* set the round/straight flags */
name|edge
operator|->
name|flags
operator|=
name|AF_EDGE_NORMAL
expr_stmt|;
if|if
condition|(
name|is_round
operator|>
literal|0
operator|&&
name|is_round
operator|>=
name|is_straight
condition|)
name|edge
operator|->
name|flags
operator||=
name|AF_EDGE_ROUND
expr_stmt|;
comment|/* get rid of serifs if link is set                 */
comment|/* XXX: This gets rid of many unpleasant artefacts! */
comment|/*      Example: the `c' in cour.pfa at size 13     */
if|if
condition|(
name|edge
operator|->
name|serif
operator|&&
name|edge
operator|->
name|link
condition|)
name|edge
operator|->
name|serif
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|Exit
label|:
return|return
name|error
return|;
block|}
end_function
begin_comment
comment|/* Detect segments and edges for given dimension. */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|af_cjk_hints_detect_features
name|af_cjk_hints_detect_features
parameter_list|(
name|AF_GlyphHints
name|hints
parameter_list|,
name|AF_Dimension
name|dim
parameter_list|)
block|{
name|FT_Error
name|error
decl_stmt|;
name|error
operator|=
name|af_cjk_hints_compute_segments
argument_list|(
name|hints
argument_list|,
name|dim
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|af_cjk_hints_link_segments
argument_list|(
name|hints
argument_list|,
name|dim
argument_list|)
expr_stmt|;
name|error
operator|=
name|af_cjk_hints_compute_edges
argument_list|(
name|hints
argument_list|,
name|dim
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function
begin_comment
comment|/* Compute all edges which lie within blue zones. */
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|af_cjk_hints_compute_blue_edges
name|af_cjk_hints_compute_blue_edges
argument_list|(
argument|AF_GlyphHints  hints
argument_list|,
argument|AF_CJKMetrics  metrics
argument_list|,
argument|AF_Dimension   dim
argument_list|)
end_macro
begin_block
block|{
name|AF_AxisHints
name|axis
init|=
operator|&
name|hints
operator|->
name|axis
index|[
name|dim
index|]
decl_stmt|;
name|AF_Edge
name|edge
init|=
name|axis
operator|->
name|edges
decl_stmt|;
name|AF_Edge
name|edge_limit
init|=
name|edge
operator|+
name|axis
operator|->
name|num_edges
decl_stmt|;
name|AF_CJKAxis
name|cjk
init|=
operator|&
name|metrics
operator|->
name|axis
index|[
name|dim
index|]
decl_stmt|;
name|FT_Fixed
name|scale
init|=
name|cjk
operator|->
name|scale
decl_stmt|;
name|FT_Pos
name|best_dist0
decl_stmt|;
comment|/* initial threshold */
comment|/* compute the initial threshold as a fraction of the EM size */
name|best_dist0
operator|=
name|FT_MulFix
argument_list|(
name|metrics
operator|->
name|units_per_em
operator|/
literal|40
argument_list|,
name|scale
argument_list|)
expr_stmt|;
if|if
condition|(
name|best_dist0
operator|>
literal|64
operator|/
literal|2
condition|)
comment|/* maximum 1/2 pixel */
name|best_dist0
operator|=
literal|64
operator|/
literal|2
expr_stmt|;
comment|/* compute which blue zones are active, i.e. have their scaled */
comment|/* size< 3/4 pixels                                           */
comment|/* If the distant between an edge and a blue zone is shorter than */
comment|/* best_dist0, set the blue zone for the edge.  Then search for   */
comment|/* the blue zone with the smallest best_dist to the edge.         */
for|for
control|(
init|;
name|edge
operator|<
name|edge_limit
condition|;
name|edge
operator|++
control|)
block|{
name|FT_UInt
name|bb
decl_stmt|;
name|AF_Width
name|best_blue
init|=
name|NULL
decl_stmt|;
name|FT_Pos
name|best_dist
init|=
name|best_dist0
decl_stmt|;
for|for
control|(
name|bb
operator|=
literal|0
init|;
name|bb
operator|<
name|cjk
operator|->
name|blue_count
condition|;
name|bb
operator|++
control|)
block|{
name|AF_CJKBlue
name|blue
init|=
name|cjk
operator|->
name|blues
operator|+
name|bb
decl_stmt|;
name|FT_Bool
name|is_top_right_blue
decl_stmt|,
name|is_major_dir
decl_stmt|;
comment|/* skip inactive blue zones (i.e., those that are too small) */
if|if
condition|(
operator|!
operator|(
name|blue
operator|->
name|flags
operator|&
name|AF_CJK_BLUE_ACTIVE
operator|)
condition|)
continue|continue;
comment|/* if it is a top zone, check for right edges -- if it is a bottom */
comment|/* zone, check for left edges                                      */
comment|/*                                                                 */
comment|/* of course, that's for TrueType                                  */
name|is_top_right_blue
operator|=
call|(
name|FT_Byte
call|)
argument_list|(
operator|(
name|blue
operator|->
name|flags
operator|&
name|AF_CJK_BLUE_TOP
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|is_major_dir
operator|=
name|FT_BOOL
argument_list|(
name|edge
operator|->
name|dir
operator|==
name|axis
operator|->
name|major_dir
argument_list|)
expr_stmt|;
comment|/* if it is a top zone, the edge must be against the major    */
comment|/* direction; if it is a bottom zone, it must be in the major */
comment|/* direction                                                  */
if|if
condition|(
name|is_top_right_blue
operator|^
name|is_major_dir
condition|)
block|{
name|FT_Pos
name|dist
decl_stmt|;
name|AF_Width
name|compare
decl_stmt|;
comment|/* Compare the edge to the closest blue zone type */
if|if
condition|(
name|FT_ABS
argument_list|(
name|edge
operator|->
name|fpos
operator|-
name|blue
operator|->
name|ref
operator|.
name|org
argument_list|)
operator|>
name|FT_ABS
argument_list|(
name|edge
operator|->
name|fpos
operator|-
name|blue
operator|->
name|shoot
operator|.
name|org
argument_list|)
condition|)
name|compare
operator|=
operator|&
name|blue
operator|->
name|shoot
expr_stmt|;
else|else
name|compare
operator|=
operator|&
name|blue
operator|->
name|ref
expr_stmt|;
name|dist
operator|=
name|edge
operator|->
name|fpos
operator|-
name|compare
operator|->
name|org
expr_stmt|;
if|if
condition|(
name|dist
operator|<
literal|0
condition|)
name|dist
operator|=
operator|-
name|dist
expr_stmt|;
name|dist
operator|=
name|FT_MulFix
argument_list|(
name|dist
argument_list|,
name|scale
argument_list|)
expr_stmt|;
if|if
condition|(
name|dist
operator|<
name|best_dist
condition|)
block|{
name|best_dist
operator|=
name|dist
expr_stmt|;
name|best_blue
operator|=
name|compare
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|best_blue
condition|)
name|edge
operator|->
name|blue_edge
operator|=
name|best_blue
expr_stmt|;
block|}
block|}
end_block
begin_comment
comment|/* Initalize hinting engine. */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|af_cjk_hints_init
argument_list|(
argument|AF_GlyphHints  hints
argument_list|,
argument|AF_CJKMetrics  metrics
argument_list|)
end_macro
begin_block
block|{
name|FT_Render_Mode
name|mode
decl_stmt|;
name|FT_UInt32
name|scaler_flags
decl_stmt|,
name|other_flags
decl_stmt|;
name|af_glyph_hints_rescale
argument_list|(
name|hints
argument_list|,
operator|(
name|AF_StyleMetrics
operator|)
name|metrics
argument_list|)
expr_stmt|;
comment|/*      *  correct x_scale and y_scale when needed, since they may have      *  been modified af_cjk_scale_dim above      */
name|hints
operator|->
name|x_scale
operator|=
name|metrics
operator|->
name|axis
index|[
name|AF_DIMENSION_HORZ
index|]
operator|.
name|scale
expr_stmt|;
name|hints
operator|->
name|x_delta
operator|=
name|metrics
operator|->
name|axis
index|[
name|AF_DIMENSION_HORZ
index|]
operator|.
name|delta
expr_stmt|;
name|hints
operator|->
name|y_scale
operator|=
name|metrics
operator|->
name|axis
index|[
name|AF_DIMENSION_VERT
index|]
operator|.
name|scale
expr_stmt|;
name|hints
operator|->
name|y_delta
operator|=
name|metrics
operator|->
name|axis
index|[
name|AF_DIMENSION_VERT
index|]
operator|.
name|delta
expr_stmt|;
comment|/* compute flags depending on render mode, etc. */
name|mode
operator|=
name|metrics
operator|->
name|root
operator|.
name|scaler
operator|.
name|render_mode
expr_stmt|;
ifdef|#
directive|ifdef
name|AF_CONFIG_OPTION_USE_WARPER
if|if
condition|(
name|mode
operator|==
name|FT_RENDER_MODE_LCD
operator|||
name|mode
operator|==
name|FT_RENDER_MODE_LCD_V
condition|)
name|metrics
operator|->
name|root
operator|.
name|scaler
operator|.
name|render_mode
operator|=
name|mode
operator|=
name|FT_RENDER_MODE_NORMAL
expr_stmt|;
endif|#
directive|endif
name|scaler_flags
operator|=
name|hints
operator|->
name|scaler_flags
expr_stmt|;
name|other_flags
operator|=
literal|0
expr_stmt|;
comment|/*      *  We snap the width of vertical stems for the monochrome and      *  horizontal LCD rendering targets only.      */
if|if
condition|(
name|mode
operator|==
name|FT_RENDER_MODE_MONO
operator|||
name|mode
operator|==
name|FT_RENDER_MODE_LCD
condition|)
name|other_flags
operator||=
name|AF_LATIN_HINTS_HORZ_SNAP
expr_stmt|;
comment|/*      *  We snap the width of horizontal stems for the monochrome and      *  vertical LCD rendering targets only.      */
if|if
condition|(
name|mode
operator|==
name|FT_RENDER_MODE_MONO
operator|||
name|mode
operator|==
name|FT_RENDER_MODE_LCD_V
condition|)
name|other_flags
operator||=
name|AF_LATIN_HINTS_VERT_SNAP
expr_stmt|;
comment|/*      *  We adjust stems to full pixels only if we don't use the `light' mode.      */
if|if
condition|(
name|mode
operator|!=
name|FT_RENDER_MODE_LIGHT
condition|)
name|other_flags
operator||=
name|AF_LATIN_HINTS_STEM_ADJUST
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|FT_RENDER_MODE_MONO
condition|)
name|other_flags
operator||=
name|AF_LATIN_HINTS_MONO
expr_stmt|;
name|scaler_flags
operator||=
name|AF_SCALER_FLAG_NO_ADVANCE
expr_stmt|;
name|hints
operator|->
name|scaler_flags
operator|=
name|scaler_flags
expr_stmt|;
name|hints
operator|->
name|other_flags
operator|=
name|other_flags
expr_stmt|;
return|return
name|FT_Err_Ok
return|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****          C J K   G L Y P H   G R I D - F I T T I N G          *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/* Snap a given width in scaled coordinates to one of the */
end_comment
begin_comment
comment|/* current standard widths.                               */
end_comment
begin_function
specifier|static
name|FT_Pos
DECL|function|af_cjk_snap_width
name|af_cjk_snap_width
parameter_list|(
name|AF_Width
name|widths
parameter_list|,
name|FT_Int
name|count
parameter_list|,
name|FT_Pos
name|width
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
name|FT_Pos
name|best
init|=
literal|64
operator|+
literal|32
operator|+
literal|2
decl_stmt|;
name|FT_Pos
name|reference
init|=
name|width
decl_stmt|;
name|FT_Pos
name|scaled
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
block|{
name|FT_Pos
name|w
decl_stmt|;
name|FT_Pos
name|dist
decl_stmt|;
name|w
operator|=
name|widths
index|[
name|n
index|]
operator|.
name|cur
expr_stmt|;
name|dist
operator|=
name|width
operator|-
name|w
expr_stmt|;
if|if
condition|(
name|dist
operator|<
literal|0
condition|)
name|dist
operator|=
operator|-
name|dist
expr_stmt|;
if|if
condition|(
name|dist
operator|<
name|best
condition|)
block|{
name|best
operator|=
name|dist
expr_stmt|;
name|reference
operator|=
name|w
expr_stmt|;
block|}
block|}
name|scaled
operator|=
name|FT_PIX_ROUND
argument_list|(
name|reference
argument_list|)
expr_stmt|;
if|if
condition|(
name|width
operator|>=
name|reference
condition|)
block|{
if|if
condition|(
name|width
operator|<
name|scaled
operator|+
literal|48
condition|)
name|width
operator|=
name|reference
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|width
operator|>
name|scaled
operator|-
literal|48
condition|)
name|width
operator|=
name|reference
expr_stmt|;
block|}
return|return
name|width
return|;
block|}
end_function
begin_comment
comment|/* Compute the snapped width of a given stem.                          */
end_comment
begin_comment
comment|/* There is a lot of voodoo in this function; changing the hard-coded  */
end_comment
begin_comment
comment|/* parameters influence the whole hinting process.                     */
end_comment
begin_function
specifier|static
name|FT_Pos
DECL|function|af_cjk_compute_stem_width
name|af_cjk_compute_stem_width
parameter_list|(
name|AF_GlyphHints
name|hints
parameter_list|,
name|AF_Dimension
name|dim
parameter_list|,
name|FT_Pos
name|width
parameter_list|,
name|AF_Edge_Flags
name|base_flags
parameter_list|,
name|AF_Edge_Flags
name|stem_flags
parameter_list|)
block|{
name|AF_CJKMetrics
name|metrics
init|=
operator|(
name|AF_CJKMetrics
operator|)
name|hints
operator|->
name|metrics
decl_stmt|;
name|AF_CJKAxis
name|axis
init|=
operator|&
name|metrics
operator|->
name|axis
index|[
name|dim
index|]
decl_stmt|;
name|FT_Pos
name|dist
init|=
name|width
decl_stmt|;
name|FT_Int
name|sign
init|=
literal|0
decl_stmt|;
name|FT_Bool
name|vertical
init|=
name|FT_BOOL
argument_list|(
name|dim
operator|==
name|AF_DIMENSION_VERT
argument_list|)
decl_stmt|;
name|FT_UNUSED
argument_list|(
name|base_flags
argument_list|)
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|stem_flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|AF_LATIN_HINTS_DO_STEM_ADJUST
argument_list|(
name|hints
argument_list|)
condition|)
return|return
name|width
return|;
if|if
condition|(
name|dist
operator|<
literal|0
condition|)
block|{
name|dist
operator|=
operator|-
name|width
expr_stmt|;
name|sign
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|vertical
operator|&&
operator|!
name|AF_LATIN_HINTS_DO_VERT_SNAP
argument_list|(
name|hints
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|vertical
operator|&&
operator|!
name|AF_LATIN_HINTS_DO_HORZ_SNAP
argument_list|(
name|hints
argument_list|)
operator|)
condition|)
block|{
comment|/* smooth hinting process: very lightly quantize the stem width */
if|if
condition|(
name|axis
operator|->
name|width_count
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|FT_ABS
argument_list|(
name|dist
operator|-
name|axis
operator|->
name|widths
index|[
literal|0
index|]
operator|.
name|cur
argument_list|)
operator|<
literal|40
condition|)
block|{
name|dist
operator|=
name|axis
operator|->
name|widths
index|[
literal|0
index|]
operator|.
name|cur
expr_stmt|;
if|if
condition|(
name|dist
operator|<
literal|48
condition|)
name|dist
operator|=
literal|48
expr_stmt|;
goto|goto
name|Done_Width
goto|;
block|}
block|}
if|if
condition|(
name|dist
operator|<
literal|54
condition|)
name|dist
operator|+=
operator|(
literal|54
operator|-
name|dist
operator|)
operator|/
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|dist
operator|<
literal|3
operator|*
literal|64
condition|)
block|{
name|FT_Pos
name|delta
decl_stmt|;
name|delta
operator|=
name|dist
operator|&
literal|63
expr_stmt|;
name|dist
operator|&=
operator|-
literal|64
expr_stmt|;
if|if
condition|(
name|delta
operator|<
literal|10
condition|)
name|dist
operator|+=
name|delta
expr_stmt|;
elseif|else
if|if
condition|(
name|delta
operator|<
literal|22
condition|)
name|dist
operator|+=
literal|10
expr_stmt|;
elseif|else
if|if
condition|(
name|delta
operator|<
literal|42
condition|)
name|dist
operator|+=
name|delta
expr_stmt|;
elseif|else
if|if
condition|(
name|delta
operator|<
literal|54
condition|)
name|dist
operator|+=
literal|54
expr_stmt|;
else|else
name|dist
operator|+=
name|delta
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* strong hinting process: snap the stem width to integer pixels */
name|dist
operator|=
name|af_cjk_snap_width
argument_list|(
name|axis
operator|->
name|widths
argument_list|,
name|axis
operator|->
name|width_count
argument_list|,
name|dist
argument_list|)
expr_stmt|;
if|if
condition|(
name|vertical
condition|)
block|{
comment|/* in the case of vertical hinting, always round */
comment|/* the stem heights to integer pixels            */
if|if
condition|(
name|dist
operator|>=
literal|64
condition|)
name|dist
operator|=
operator|(
name|dist
operator|+
literal|16
operator|)
operator|&
operator|~
literal|63
expr_stmt|;
else|else
name|dist
operator|=
literal|64
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|AF_LATIN_HINTS_DO_MONO
argument_list|(
name|hints
argument_list|)
condition|)
block|{
comment|/* monochrome horizontal hinting: snap widths to integer pixels */
comment|/* with a different threshold                                   */
if|if
condition|(
name|dist
operator|<
literal|64
condition|)
name|dist
operator|=
literal|64
expr_stmt|;
else|else
name|dist
operator|=
operator|(
name|dist
operator|+
literal|32
operator|)
operator|&
operator|~
literal|63
expr_stmt|;
block|}
else|else
block|{
comment|/* for horizontal anti-aliased hinting, we adopt a more subtle */
comment|/* approach: we strengthen small stems, round stems whose size */
comment|/* is between 1 and 2 pixels to an integer, otherwise nothing  */
if|if
condition|(
name|dist
operator|<
literal|48
condition|)
name|dist
operator|=
operator|(
name|dist
operator|+
literal|64
operator|)
operator|>>
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|dist
operator|<
literal|128
condition|)
name|dist
operator|=
operator|(
name|dist
operator|+
literal|22
operator|)
operator|&
operator|~
literal|63
expr_stmt|;
else|else
comment|/* round otherwise to prevent color fringes in LCD mode */
name|dist
operator|=
operator|(
name|dist
operator|+
literal|32
operator|)
operator|&
operator|~
literal|63
expr_stmt|;
block|}
block|}
block|}
name|Done_Width
label|:
if|if
condition|(
name|sign
condition|)
name|dist
operator|=
operator|-
name|dist
expr_stmt|;
return|return
name|dist
return|;
block|}
end_function
begin_comment
comment|/* Align one stem edge relative to the previous stem edge. */
end_comment
begin_function
specifier|static
name|void
DECL|function|af_cjk_align_linked_edge
name|af_cjk_align_linked_edge
parameter_list|(
name|AF_GlyphHints
name|hints
parameter_list|,
name|AF_Dimension
name|dim
parameter_list|,
name|AF_Edge
name|base_edge
parameter_list|,
name|AF_Edge
name|stem_edge
parameter_list|)
block|{
name|FT_Pos
name|dist
init|=
name|stem_edge
operator|->
name|opos
operator|-
name|base_edge
operator|->
name|opos
decl_stmt|;
name|FT_Pos
name|fitted_width
init|=
name|af_cjk_compute_stem_width
argument_list|(
name|hints
argument_list|,
name|dim
argument_list|,
name|dist
argument_list|,
operator|(
name|AF_Edge_Flags
operator|)
name|base_edge
operator|->
name|flags
argument_list|,
operator|(
name|AF_Edge_Flags
operator|)
name|stem_edge
operator|->
name|flags
argument_list|)
decl_stmt|;
name|stem_edge
operator|->
name|pos
operator|=
name|base_edge
operator|->
name|pos
operator|+
name|fitted_width
expr_stmt|;
name|FT_TRACE5
argument_list|(
operator|(
literal|"  CJKLINK: edge %d @%d (opos=%.2f) linked to %.2f,"
literal|" dist was %.2f, now %.2f\n"
operator|,
name|stem_edge
operator|-
name|hints
operator|->
name|axis
index|[
name|dim
index|]
operator|.
name|edges
operator|,
name|stem_edge
operator|->
name|fpos
operator|,
name|stem_edge
operator|->
name|opos
operator|/
literal|64.0
operator|,
name|stem_edge
operator|->
name|pos
operator|/
literal|64.0
operator|,
name|dist
operator|/
literal|64.0
operator|,
name|fitted_width
operator|/
literal|64.0
operator|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* Shift the coordinates of the `serif' edge by the same amount */
end_comment
begin_comment
comment|/* as the corresponding `base' edge has been moved already.     */
end_comment
begin_function
specifier|static
name|void
DECL|function|af_cjk_align_serif_edge
name|af_cjk_align_serif_edge
parameter_list|(
name|AF_GlyphHints
name|hints
parameter_list|,
name|AF_Edge
name|base
parameter_list|,
name|AF_Edge
name|serif
parameter_list|)
block|{
name|FT_UNUSED
argument_list|(
name|hints
argument_list|)
expr_stmt|;
name|serif
operator|->
name|pos
operator|=
name|base
operator|->
name|pos
operator|+
operator|(
name|serif
operator|->
name|opos
operator|-
name|base
operator|->
name|opos
operator|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/****                                                                 ****/
end_comment
begin_comment
comment|/****                    E D G E   H I N T I N G                      ****/
end_comment
begin_comment
comment|/****                                                                 ****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_define
DECL|macro|AF_LIGHT_MODE_MAX_HORZ_GAP
define|#
directive|define
name|AF_LIGHT_MODE_MAX_HORZ_GAP
value|9
end_define
begin_define
DECL|macro|AF_LIGHT_MODE_MAX_VERT_GAP
define|#
directive|define
name|AF_LIGHT_MODE_MAX_VERT_GAP
value|15
end_define
begin_define
DECL|macro|AF_LIGHT_MODE_MAX_DELTA_ABS
define|#
directive|define
name|AF_LIGHT_MODE_MAX_DELTA_ABS
value|14
end_define
begin_function
specifier|static
name|FT_Pos
DECL|function|af_hint_normal_stem
name|af_hint_normal_stem
parameter_list|(
name|AF_GlyphHints
name|hints
parameter_list|,
name|AF_Edge
name|edge
parameter_list|,
name|AF_Edge
name|edge2
parameter_list|,
name|FT_Pos
name|anchor
parameter_list|,
name|AF_Dimension
name|dim
parameter_list|)
block|{
name|FT_Pos
name|org_len
decl_stmt|,
name|cur_len
decl_stmt|,
name|org_center
decl_stmt|;
name|FT_Pos
name|cur_pos1
decl_stmt|,
name|cur_pos2
decl_stmt|;
name|FT_Pos
name|d_off1
decl_stmt|,
name|u_off1
decl_stmt|,
name|d_off2
decl_stmt|,
name|u_off2
decl_stmt|,
name|delta
decl_stmt|;
name|FT_Pos
name|offset
decl_stmt|;
name|FT_Pos
name|threshold
init|=
literal|64
decl_stmt|;
if|if
condition|(
operator|!
name|AF_LATIN_HINTS_DO_STEM_ADJUST
argument_list|(
name|hints
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|edge
operator|->
name|flags
operator|&
name|AF_EDGE_ROUND
operator|)
operator|&&
operator|(
name|edge2
operator|->
name|flags
operator|&
name|AF_EDGE_ROUND
operator|)
condition|)
block|{
if|if
condition|(
name|dim
operator|==
name|AF_DIMENSION_VERT
condition|)
name|threshold
operator|=
literal|64
operator|-
name|AF_LIGHT_MODE_MAX_HORZ_GAP
expr_stmt|;
else|else
name|threshold
operator|=
literal|64
operator|-
name|AF_LIGHT_MODE_MAX_VERT_GAP
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|dim
operator|==
name|AF_DIMENSION_VERT
condition|)
name|threshold
operator|=
literal|64
operator|-
name|AF_LIGHT_MODE_MAX_HORZ_GAP
operator|/
literal|3
expr_stmt|;
else|else
name|threshold
operator|=
literal|64
operator|-
name|AF_LIGHT_MODE_MAX_VERT_GAP
operator|/
literal|3
expr_stmt|;
block|}
block|}
name|org_len
operator|=
name|edge2
operator|->
name|opos
operator|-
name|edge
operator|->
name|opos
expr_stmt|;
name|cur_len
operator|=
name|af_cjk_compute_stem_width
argument_list|(
name|hints
argument_list|,
name|dim
argument_list|,
name|org_len
argument_list|,
operator|(
name|AF_Edge_Flags
operator|)
name|edge
operator|->
name|flags
argument_list|,
operator|(
name|AF_Edge_Flags
operator|)
name|edge2
operator|->
name|flags
argument_list|)
expr_stmt|;
name|org_center
operator|=
operator|(
name|edge
operator|->
name|opos
operator|+
name|edge2
operator|->
name|opos
operator|)
operator|/
literal|2
operator|+
name|anchor
expr_stmt|;
name|cur_pos1
operator|=
name|org_center
operator|-
name|cur_len
operator|/
literal|2
expr_stmt|;
name|cur_pos2
operator|=
name|cur_pos1
operator|+
name|cur_len
expr_stmt|;
name|d_off1
operator|=
name|cur_pos1
operator|-
name|FT_PIX_FLOOR
argument_list|(
name|cur_pos1
argument_list|)
expr_stmt|;
name|d_off2
operator|=
name|cur_pos2
operator|-
name|FT_PIX_FLOOR
argument_list|(
name|cur_pos2
argument_list|)
expr_stmt|;
name|u_off1
operator|=
literal|64
operator|-
name|d_off1
expr_stmt|;
name|u_off2
operator|=
literal|64
operator|-
name|d_off2
expr_stmt|;
name|delta
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|d_off1
operator|==
literal|0
operator|||
name|d_off2
operator|==
literal|0
condition|)
goto|goto
name|Exit
goto|;
if|if
condition|(
name|cur_len
operator|<=
name|threshold
condition|)
block|{
if|if
condition|(
name|d_off2
operator|<
name|cur_len
condition|)
block|{
if|if
condition|(
name|u_off1
operator|<=
name|d_off2
condition|)
name|delta
operator|=
name|u_off1
expr_stmt|;
else|else
name|delta
operator|=
operator|-
name|d_off2
expr_stmt|;
block|}
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|threshold
operator|<
literal|64
condition|)
block|{
if|if
condition|(
name|d_off1
operator|>=
name|threshold
operator|||
name|u_off1
operator|>=
name|threshold
operator|||
name|d_off2
operator|>=
name|threshold
operator|||
name|u_off2
operator|>=
name|threshold
condition|)
goto|goto
name|Exit
goto|;
block|}
name|offset
operator|=
name|cur_len
operator|&
literal|63
expr_stmt|;
if|if
condition|(
name|offset
operator|<
literal|32
condition|)
block|{
if|if
condition|(
name|u_off1
operator|<=
name|offset
operator|||
name|d_off2
operator|<=
name|offset
condition|)
goto|goto
name|Exit
goto|;
block|}
else|else
name|offset
operator|=
literal|64
operator|-
name|threshold
expr_stmt|;
name|d_off1
operator|=
name|threshold
operator|-
name|u_off1
expr_stmt|;
name|u_off1
operator|=
name|u_off1
operator|-
name|offset
expr_stmt|;
name|u_off2
operator|=
name|threshold
operator|-
name|d_off2
expr_stmt|;
name|d_off2
operator|=
name|d_off2
operator|-
name|offset
expr_stmt|;
if|if
condition|(
name|d_off1
operator|<=
name|u_off1
condition|)
name|u_off1
operator|=
operator|-
name|d_off1
expr_stmt|;
if|if
condition|(
name|d_off2
operator|<=
name|u_off2
condition|)
name|u_off2
operator|=
operator|-
name|d_off2
expr_stmt|;
if|if
condition|(
name|FT_ABS
argument_list|(
name|u_off1
argument_list|)
operator|<=
name|FT_ABS
argument_list|(
name|u_off2
argument_list|)
condition|)
name|delta
operator|=
name|u_off1
expr_stmt|;
else|else
name|delta
operator|=
name|u_off2
expr_stmt|;
name|Exit
label|:
if|#
directive|if
literal|1
if|if
condition|(
operator|!
name|AF_LATIN_HINTS_DO_STEM_ADJUST
argument_list|(
name|hints
argument_list|)
condition|)
block|{
if|if
condition|(
name|delta
operator|>
name|AF_LIGHT_MODE_MAX_DELTA_ABS
condition|)
name|delta
operator|=
name|AF_LIGHT_MODE_MAX_DELTA_ABS
expr_stmt|;
elseif|else
if|if
condition|(
name|delta
operator|<
operator|-
name|AF_LIGHT_MODE_MAX_DELTA_ABS
condition|)
name|delta
operator|=
operator|-
name|AF_LIGHT_MODE_MAX_DELTA_ABS
expr_stmt|;
block|}
endif|#
directive|endif
name|cur_pos1
operator|+=
name|delta
expr_stmt|;
if|if
condition|(
name|edge
operator|->
name|opos
operator|<
name|edge2
operator|->
name|opos
condition|)
block|{
name|edge
operator|->
name|pos
operator|=
name|cur_pos1
expr_stmt|;
name|edge2
operator|->
name|pos
operator|=
name|cur_pos1
operator|+
name|cur_len
expr_stmt|;
block|}
else|else
block|{
name|edge
operator|->
name|pos
operator|=
name|cur_pos1
operator|+
name|cur_len
expr_stmt|;
name|edge2
operator|->
name|pos
operator|=
name|cur_pos1
expr_stmt|;
block|}
return|return
name|delta
return|;
block|}
end_function
begin_comment
comment|/* The main grid-fitting routine. */
end_comment
begin_function
specifier|static
name|void
DECL|function|af_cjk_hint_edges
name|af_cjk_hint_edges
parameter_list|(
name|AF_GlyphHints
name|hints
parameter_list|,
name|AF_Dimension
name|dim
parameter_list|)
block|{
name|AF_AxisHints
name|axis
init|=
operator|&
name|hints
operator|->
name|axis
index|[
name|dim
index|]
decl_stmt|;
name|AF_Edge
name|edges
init|=
name|axis
operator|->
name|edges
decl_stmt|;
name|AF_Edge
name|edge_limit
init|=
name|edges
operator|+
name|axis
operator|->
name|num_edges
decl_stmt|;
name|FT_PtrDist
name|n_edges
decl_stmt|;
name|AF_Edge
name|edge
decl_stmt|;
name|AF_Edge
name|anchor
init|=
literal|0
decl_stmt|;
name|FT_Pos
name|delta
init|=
literal|0
decl_stmt|;
name|FT_Int
name|skipped
init|=
literal|0
decl_stmt|;
name|FT_Bool
name|has_last_stem
init|=
name|FALSE
decl_stmt|;
name|FT_Pos
name|last_stem_pos
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|FT_DEBUG_LEVEL_TRACE
name|FT_UInt
name|num_actions
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|FT_TRACE5
argument_list|(
operator|(
literal|"cjk %s edge hinting (style `%s')\n"
operator|,
name|dim
operator|==
name|AF_DIMENSION_VERT
condition|?
literal|"horizontal"
else|:
literal|"vertical"
operator|,
name|af_style_names
index|[
name|hints
operator|->
name|metrics
operator|->
name|style_class
operator|->
name|style
index|]
operator|)
argument_list|)
expr_stmt|;
comment|/* we begin by aligning all stems relative to the blue zone */
if|if
condition|(
name|AF_HINTS_DO_BLUES
argument_list|(
name|hints
argument_list|)
condition|)
block|{
for|for
control|(
name|edge
operator|=
name|edges
init|;
name|edge
operator|<
name|edge_limit
condition|;
name|edge
operator|++
control|)
block|{
name|AF_Width
name|blue
decl_stmt|;
name|AF_Edge
name|edge1
decl_stmt|,
name|edge2
decl_stmt|;
if|if
condition|(
name|edge
operator|->
name|flags
operator|&
name|AF_EDGE_DONE
condition|)
continue|continue;
name|blue
operator|=
name|edge
operator|->
name|blue_edge
expr_stmt|;
name|edge1
operator|=
name|NULL
expr_stmt|;
name|edge2
operator|=
name|edge
operator|->
name|link
expr_stmt|;
if|if
condition|(
name|blue
condition|)
block|{
name|edge1
operator|=
name|edge
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|edge2
operator|&&
name|edge2
operator|->
name|blue_edge
condition|)
block|{
name|blue
operator|=
name|edge2
operator|->
name|blue_edge
expr_stmt|;
name|edge1
operator|=
name|edge2
expr_stmt|;
name|edge2
operator|=
name|edge
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|edge1
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|FT_DEBUG_LEVEL_TRACE
name|FT_TRACE5
argument_list|(
operator|(
literal|"  CJKBLUE: edge %d @%d (opos=%.2f) snapped to %.2f,"
literal|" was %.2f\n"
operator|,
name|edge1
operator|-
name|edges
operator|,
name|edge1
operator|->
name|fpos
operator|,
name|edge1
operator|->
name|opos
operator|/
literal|64.0
operator|,
name|blue
operator|->
name|fit
operator|/
literal|64.0
operator|,
name|edge1
operator|->
name|pos
operator|/
literal|64.0
operator|)
argument_list|)
expr_stmt|;
name|num_actions
operator|++
expr_stmt|;
endif|#
directive|endif
name|edge1
operator|->
name|pos
operator|=
name|blue
operator|->
name|fit
expr_stmt|;
name|edge1
operator|->
name|flags
operator||=
name|AF_EDGE_DONE
expr_stmt|;
if|if
condition|(
name|edge2
operator|&&
operator|!
name|edge2
operator|->
name|blue_edge
condition|)
block|{
name|af_cjk_align_linked_edge
argument_list|(
name|hints
argument_list|,
name|dim
argument_list|,
name|edge1
argument_list|,
name|edge2
argument_list|)
expr_stmt|;
name|edge2
operator|->
name|flags
operator||=
name|AF_EDGE_DONE
expr_stmt|;
ifdef|#
directive|ifdef
name|FT_DEBUG_LEVEL_TRACE
name|num_actions
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
operator|!
name|anchor
condition|)
name|anchor
operator|=
name|edge
expr_stmt|;
block|}
block|}
comment|/* now we align all stem edges. */
for|for
control|(
name|edge
operator|=
name|edges
init|;
name|edge
operator|<
name|edge_limit
condition|;
name|edge
operator|++
control|)
block|{
name|AF_Edge
name|edge2
decl_stmt|;
if|if
condition|(
name|edge
operator|->
name|flags
operator|&
name|AF_EDGE_DONE
condition|)
continue|continue;
comment|/* skip all non-stem edges */
name|edge2
operator|=
name|edge
operator|->
name|link
expr_stmt|;
if|if
condition|(
operator|!
name|edge2
condition|)
block|{
name|skipped
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* Some CJK characters have so many stems that        * the hinter is likely to merge two adjacent ones.        * To solve this problem, if either edge of a stem        * is too close to the previous one, we avoid        * aligning the two edges, but rather interpolate        * their locations at the end of this function in        * order to preserve the space between the stems.        */
if|if
condition|(
name|has_last_stem
operator|&&
operator|(
name|edge
operator|->
name|pos
operator|<
name|last_stem_pos
operator|+
literal|64
operator|||
name|edge2
operator|->
name|pos
operator|<
name|last_stem_pos
operator|+
literal|64
operator|)
condition|)
block|{
name|skipped
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* now align the stem */
comment|/* this should not happen, but it's better to be safe */
if|if
condition|(
name|edge2
operator|->
name|blue_edge
condition|)
block|{
name|FT_TRACE5
argument_list|(
operator|(
literal|"ASSERTION FAILED for edge %d\n"
operator|,
name|edge2
operator|-
name|edges
operator|)
argument_list|)
expr_stmt|;
name|af_cjk_align_linked_edge
argument_list|(
name|hints
argument_list|,
name|dim
argument_list|,
name|edge2
argument_list|,
name|edge
argument_list|)
expr_stmt|;
name|edge
operator|->
name|flags
operator||=
name|AF_EDGE_DONE
expr_stmt|;
ifdef|#
directive|ifdef
name|FT_DEBUG_LEVEL_TRACE
name|num_actions
operator|++
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
if|if
condition|(
name|edge2
operator|<
name|edge
condition|)
block|{
name|af_cjk_align_linked_edge
argument_list|(
name|hints
argument_list|,
name|dim
argument_list|,
name|edge2
argument_list|,
name|edge
argument_list|)
expr_stmt|;
name|edge
operator|->
name|flags
operator||=
name|AF_EDGE_DONE
expr_stmt|;
ifdef|#
directive|ifdef
name|FT_DEBUG_LEVEL_TRACE
name|num_actions
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* We rarely reaches here it seems;          * usually the two edges belonging          * to one stem are marked as DONE together          */
name|has_last_stem
operator|=
name|TRUE
expr_stmt|;
name|last_stem_pos
operator|=
name|edge
operator|->
name|pos
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|dim
operator|!=
name|AF_DIMENSION_VERT
operator|&&
operator|!
name|anchor
condition|)
block|{
if|#
directive|if
literal|0
block|if ( fixedpitch )         {           AF_Edge     left  = edge;           AF_Edge     right = edge_limit - 1;           AF_EdgeRec  left1, left2, right1, right2;           FT_Pos      target, center1, center2;           FT_Pos      delta1, delta2, d1, d2;             while ( right> left&& !right->link )             right--;            left1  = *left;           left2  = *left->link;           right1 = *right->link;           right2 = *right;            delta  = ( ( ( hinter->pp2.x + 32 )& -64 ) - hinter->pp2.x ) / 2;           target = left->opos + ( right->opos - left->opos ) / 2 + delta - 16;            delta1  = delta;           delta1 += af_hint_normal_stem( hints, left, left->link,                                          delta1, 0 );            if ( left->link != right )             af_hint_normal_stem( hints, right->link, right, delta1, 0 );            center1 = left->pos + ( right->pos - left->pos ) / 2;            if ( center1>= target )             delta2 = delta - 32;           else             delta2 = delta + 32;            delta2 += af_hint_normal_stem( hints,&left1,&left2, delta2, 0 );            if ( delta1 != delta2 )           {             if ( left->link != right )               af_hint_normal_stem( hints,&right1,&right2, delta2, 0 );              center2 = left1.pos + ( right2.pos - left1.pos ) / 2;              d1 = center1 - target;             d2 = center2 - target;              if ( FT_ABS( d2 )< FT_ABS( d1 ) )             {               left->pos       = left1.pos;               left->link->pos = left2.pos;                if ( left->link != right )               {                 right->link->pos = right1.pos;                 right->pos       = right2.pos;               }                delta1 = delta2;             }           }            delta               = delta1;           right->link->flags |= AF_EDGE_DONE;           right->flags       |= AF_EDGE_DONE;         }         else
endif|#
directive|endif
comment|/* 0 */
name|delta
operator|=
name|af_hint_normal_stem
argument_list|(
name|hints
argument_list|,
name|edge
argument_list|,
name|edge2
argument_list|,
literal|0
argument_list|,
name|AF_DIMENSION_HORZ
argument_list|)
expr_stmt|;
block|}
else|else
name|af_hint_normal_stem
argument_list|(
name|hints
argument_list|,
name|edge
argument_list|,
name|edge2
argument_list|,
name|delta
argument_list|,
name|dim
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|printf( "stem (%d,%d) adjusted (%.1f,%.1f)\n",                edge - edges, edge2 - edges,                ( edge->pos - edge->opos ) / 64.0,                ( edge2->pos - edge2->opos ) / 64.0 );
endif|#
directive|endif
name|anchor
operator|=
name|edge
expr_stmt|;
name|edge
operator|->
name|flags
operator||=
name|AF_EDGE_DONE
expr_stmt|;
name|edge2
operator|->
name|flags
operator||=
name|AF_EDGE_DONE
expr_stmt|;
name|has_last_stem
operator|=
name|TRUE
expr_stmt|;
name|last_stem_pos
operator|=
name|edge2
operator|->
name|pos
expr_stmt|;
block|}
comment|/* make sure that lowercase m's maintain their symmetry */
comment|/* In general, lowercase m's have six vertical edges if they are sans */
comment|/* serif, or twelve if they are with serifs.  This implementation is  */
comment|/* based on that assumption, and seems to work very well with most    */
comment|/* faces.  However, if for a certain face this assumption is not      */
comment|/* true, the m is just rendered like before.  In addition, any stem   */
comment|/* correction will only be applied to symmetrical glyphs (even if the */
comment|/* glyph is not an m), so the potential for unwanted distortion is    */
comment|/* relatively low.                                                    */
comment|/* We don't handle horizontal edges since we can't easily assure that */
comment|/* the third (lowest) stem aligns with the base line; it might end up */
comment|/* one pixel higher or lower.                                         */
name|n_edges
operator|=
name|edge_limit
operator|-
name|edges
expr_stmt|;
if|if
condition|(
name|dim
operator|==
name|AF_DIMENSION_HORZ
operator|&&
operator|(
name|n_edges
operator|==
literal|6
operator|||
name|n_edges
operator|==
literal|12
operator|)
condition|)
block|{
name|AF_Edge
name|edge1
decl_stmt|,
name|edge2
decl_stmt|,
name|edge3
decl_stmt|;
name|FT_Pos
name|dist1
decl_stmt|,
name|dist2
decl_stmt|,
name|span
decl_stmt|;
if|if
condition|(
name|n_edges
operator|==
literal|6
condition|)
block|{
name|edge1
operator|=
name|edges
expr_stmt|;
name|edge2
operator|=
name|edges
operator|+
literal|2
expr_stmt|;
name|edge3
operator|=
name|edges
operator|+
literal|4
expr_stmt|;
block|}
else|else
block|{
name|edge1
operator|=
name|edges
operator|+
literal|1
expr_stmt|;
name|edge2
operator|=
name|edges
operator|+
literal|5
expr_stmt|;
name|edge3
operator|=
name|edges
operator|+
literal|9
expr_stmt|;
block|}
name|dist1
operator|=
name|edge2
operator|->
name|opos
operator|-
name|edge1
operator|->
name|opos
expr_stmt|;
name|dist2
operator|=
name|edge3
operator|->
name|opos
operator|-
name|edge2
operator|->
name|opos
expr_stmt|;
name|span
operator|=
name|dist1
operator|-
name|dist2
expr_stmt|;
if|if
condition|(
name|span
operator|<
literal|0
condition|)
name|span
operator|=
operator|-
name|span
expr_stmt|;
if|if
condition|(
name|edge1
operator|->
name|link
operator|==
name|edge1
operator|+
literal|1
operator|&&
name|edge2
operator|->
name|link
operator|==
name|edge2
operator|+
literal|1
operator|&&
name|edge3
operator|->
name|link
operator|==
name|edge3
operator|+
literal|1
operator|&&
name|span
operator|<
literal|8
condition|)
block|{
name|delta
operator|=
name|edge3
operator|->
name|pos
operator|-
operator|(
literal|2
operator|*
name|edge2
operator|->
name|pos
operator|-
name|edge1
operator|->
name|pos
operator|)
expr_stmt|;
name|edge3
operator|->
name|pos
operator|-=
name|delta
expr_stmt|;
if|if
condition|(
name|edge3
operator|->
name|link
condition|)
name|edge3
operator|->
name|link
operator|->
name|pos
operator|-=
name|delta
expr_stmt|;
comment|/* move the serifs along with the stem */
if|if
condition|(
name|n_edges
operator|==
literal|12
condition|)
block|{
operator|(
name|edges
operator|+
literal|8
operator|)
operator|->
name|pos
operator|-=
name|delta
expr_stmt|;
operator|(
name|edges
operator|+
literal|11
operator|)
operator|->
name|pos
operator|-=
name|delta
expr_stmt|;
block|}
name|edge3
operator|->
name|flags
operator||=
name|AF_EDGE_DONE
expr_stmt|;
if|if
condition|(
name|edge3
operator|->
name|link
condition|)
name|edge3
operator|->
name|link
operator|->
name|flags
operator||=
name|AF_EDGE_DONE
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|skipped
condition|)
goto|goto
name|Exit
goto|;
comment|/*      *  now hint the remaining edges (serifs and single) in order      *  to complete our processing      */
for|for
control|(
name|edge
operator|=
name|edges
init|;
name|edge
operator|<
name|edge_limit
condition|;
name|edge
operator|++
control|)
block|{
if|if
condition|(
name|edge
operator|->
name|flags
operator|&
name|AF_EDGE_DONE
condition|)
continue|continue;
if|if
condition|(
name|edge
operator|->
name|serif
condition|)
block|{
name|af_cjk_align_serif_edge
argument_list|(
name|hints
argument_list|,
name|edge
operator|->
name|serif
argument_list|,
name|edge
argument_list|)
expr_stmt|;
name|edge
operator|->
name|flags
operator||=
name|AF_EDGE_DONE
expr_stmt|;
name|skipped
operator|--
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|skipped
condition|)
goto|goto
name|Exit
goto|;
for|for
control|(
name|edge
operator|=
name|edges
init|;
name|edge
operator|<
name|edge_limit
condition|;
name|edge
operator|++
control|)
block|{
name|AF_Edge
name|before
decl_stmt|,
name|after
decl_stmt|;
if|if
condition|(
name|edge
operator|->
name|flags
operator|&
name|AF_EDGE_DONE
condition|)
continue|continue;
name|before
operator|=
name|after
operator|=
name|edge
expr_stmt|;
while|while
condition|(
operator|--
name|before
operator|>=
name|edges
condition|)
if|if
condition|(
name|before
operator|->
name|flags
operator|&
name|AF_EDGE_DONE
condition|)
break|break;
while|while
condition|(
operator|++
name|after
operator|<
name|edge_limit
condition|)
if|if
condition|(
name|after
operator|->
name|flags
operator|&
name|AF_EDGE_DONE
condition|)
break|break;
if|if
condition|(
name|before
operator|>=
name|edges
operator|||
name|after
operator|<
name|edge_limit
condition|)
block|{
if|if
condition|(
name|before
operator|<
name|edges
condition|)
name|af_cjk_align_serif_edge
argument_list|(
name|hints
argument_list|,
name|after
argument_list|,
name|edge
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|after
operator|>=
name|edge_limit
condition|)
name|af_cjk_align_serif_edge
argument_list|(
name|hints
argument_list|,
name|before
argument_list|,
name|edge
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|after
operator|->
name|fpos
operator|==
name|before
operator|->
name|fpos
condition|)
name|edge
operator|->
name|pos
operator|=
name|before
operator|->
name|pos
expr_stmt|;
else|else
name|edge
operator|->
name|pos
operator|=
name|before
operator|->
name|pos
operator|+
name|FT_MulDiv
argument_list|(
name|edge
operator|->
name|fpos
operator|-
name|before
operator|->
name|fpos
argument_list|,
name|after
operator|->
name|pos
operator|-
name|before
operator|->
name|pos
argument_list|,
name|after
operator|->
name|fpos
operator|-
name|before
operator|->
name|fpos
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|Exit
label|:
ifdef|#
directive|ifdef
name|FT_DEBUG_LEVEL_TRACE
if|if
condition|(
operator|!
name|num_actions
condition|)
name|FT_TRACE5
argument_list|(
operator|(
literal|"  (none)\n"
operator|)
argument_list|)
expr_stmt|;
name|FT_TRACE5
argument_list|(
operator|(
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|af_cjk_align_edge_points
name|af_cjk_align_edge_points
parameter_list|(
name|AF_GlyphHints
name|hints
parameter_list|,
name|AF_Dimension
name|dim
parameter_list|)
block|{
name|AF_AxisHints
name|axis
init|=
operator|&
name|hints
operator|->
name|axis
index|[
name|dim
index|]
decl_stmt|;
name|AF_Edge
name|edges
init|=
name|axis
operator|->
name|edges
decl_stmt|;
name|AF_Edge
name|edge_limit
init|=
name|edges
operator|+
name|axis
operator|->
name|num_edges
decl_stmt|;
name|AF_Edge
name|edge
decl_stmt|;
name|FT_Bool
name|snapping
decl_stmt|;
name|snapping
operator|=
name|FT_BOOL
argument_list|(
operator|(
name|dim
operator|==
name|AF_DIMENSION_HORZ
operator|&&
name|AF_LATIN_HINTS_DO_HORZ_SNAP
argument_list|(
name|hints
argument_list|)
operator|)
operator|||
operator|(
name|dim
operator|==
name|AF_DIMENSION_VERT
operator|&&
name|AF_LATIN_HINTS_DO_VERT_SNAP
argument_list|(
name|hints
argument_list|)
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|edge
operator|=
name|edges
init|;
name|edge
operator|<
name|edge_limit
condition|;
name|edge
operator|++
control|)
block|{
comment|/* move the points of each segment     */
comment|/* in each edge to the edge's position */
name|AF_Segment
name|seg
init|=
name|edge
operator|->
name|first
decl_stmt|;
if|if
condition|(
name|snapping
condition|)
block|{
do|do
block|{
name|AF_Point
name|point
init|=
name|seg
operator|->
name|first
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|dim
operator|==
name|AF_DIMENSION_HORZ
condition|)
block|{
name|point
operator|->
name|x
operator|=
name|edge
operator|->
name|pos
expr_stmt|;
name|point
operator|->
name|flags
operator||=
name|AF_FLAG_TOUCH_X
expr_stmt|;
block|}
else|else
block|{
name|point
operator|->
name|y
operator|=
name|edge
operator|->
name|pos
expr_stmt|;
name|point
operator|->
name|flags
operator||=
name|AF_FLAG_TOUCH_Y
expr_stmt|;
block|}
if|if
condition|(
name|point
operator|==
name|seg
operator|->
name|last
condition|)
break|break;
name|point
operator|=
name|point
operator|->
name|next
expr_stmt|;
block|}
name|seg
operator|=
name|seg
operator|->
name|edge_next
expr_stmt|;
block|}
do|while
condition|(
name|seg
operator|!=
name|edge
operator|->
name|first
condition|)
do|;
block|}
else|else
block|{
name|FT_Pos
name|delta
init|=
name|edge
operator|->
name|pos
operator|-
name|edge
operator|->
name|opos
decl_stmt|;
do|do
block|{
name|AF_Point
name|point
init|=
name|seg
operator|->
name|first
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|dim
operator|==
name|AF_DIMENSION_HORZ
condition|)
block|{
name|point
operator|->
name|x
operator|+=
name|delta
expr_stmt|;
name|point
operator|->
name|flags
operator||=
name|AF_FLAG_TOUCH_X
expr_stmt|;
block|}
else|else
block|{
name|point
operator|->
name|y
operator|+=
name|delta
expr_stmt|;
name|point
operator|->
name|flags
operator||=
name|AF_FLAG_TOUCH_Y
expr_stmt|;
block|}
if|if
condition|(
name|point
operator|==
name|seg
operator|->
name|last
condition|)
break|break;
name|point
operator|=
name|point
operator|->
name|next
expr_stmt|;
block|}
name|seg
operator|=
name|seg
operator|->
name|edge_next
expr_stmt|;
block|}
do|while
condition|(
name|seg
operator|!=
name|edge
operator|->
name|first
condition|)
do|;
block|}
block|}
block|}
end_function
begin_comment
comment|/* Apply the complete hinting algorithm to a CJK glyph. */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|af_cjk_hints_apply
argument_list|(
argument|AF_GlyphHints  hints
argument_list|,
argument|FT_Outline*    outline
argument_list|,
argument|AF_CJKMetrics  metrics
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
decl_stmt|;
name|int
name|dim
decl_stmt|;
name|FT_UNUSED
argument_list|(
name|metrics
argument_list|)
expr_stmt|;
name|error
operator|=
name|af_glyph_hints_reload
argument_list|(
name|hints
argument_list|,
name|outline
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
comment|/* analyze glyph outline */
if|if
condition|(
name|AF_HINTS_DO_HORIZONTAL
argument_list|(
name|hints
argument_list|)
condition|)
block|{
name|error
operator|=
name|af_cjk_hints_detect_features
argument_list|(
name|hints
argument_list|,
name|AF_DIMENSION_HORZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|af_cjk_hints_compute_blue_edges
argument_list|(
name|hints
argument_list|,
name|metrics
argument_list|,
name|AF_DIMENSION_HORZ
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|AF_HINTS_DO_VERTICAL
argument_list|(
name|hints
argument_list|)
condition|)
block|{
name|error
operator|=
name|af_cjk_hints_detect_features
argument_list|(
name|hints
argument_list|,
name|AF_DIMENSION_VERT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|af_cjk_hints_compute_blue_edges
argument_list|(
name|hints
argument_list|,
name|metrics
argument_list|,
name|AF_DIMENSION_VERT
argument_list|)
expr_stmt|;
block|}
comment|/* grid-fit the outline */
for|for
control|(
name|dim
operator|=
literal|0
init|;
name|dim
operator|<
name|AF_DIMENSION_MAX
condition|;
name|dim
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|dim
operator|==
name|AF_DIMENSION_HORZ
operator|&&
name|AF_HINTS_DO_HORIZONTAL
argument_list|(
name|hints
argument_list|)
operator|)
operator|||
operator|(
name|dim
operator|==
name|AF_DIMENSION_VERT
operator|&&
name|AF_HINTS_DO_VERTICAL
argument_list|(
name|hints
argument_list|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|AF_CONFIG_OPTION_USE_WARPER
if|if
condition|(
name|dim
operator|==
name|AF_DIMENSION_HORZ
operator|&&
name|metrics
operator|->
name|root
operator|.
name|scaler
operator|.
name|render_mode
operator|==
name|FT_RENDER_MODE_NORMAL
condition|)
block|{
name|AF_WarperRec
name|warper
decl_stmt|;
name|FT_Fixed
name|scale
decl_stmt|;
name|FT_Pos
name|delta
decl_stmt|;
name|af_warper_compute
argument_list|(
operator|&
name|warper
argument_list|,
name|hints
argument_list|,
operator|(
name|AF_Dimension
operator|)
name|dim
argument_list|,
operator|&
name|scale
argument_list|,
operator|&
name|delta
argument_list|)
expr_stmt|;
name|af_glyph_hints_scale_dim
argument_list|(
name|hints
argument_list|,
operator|(
name|AF_Dimension
operator|)
name|dim
argument_list|,
name|scale
argument_list|,
name|delta
argument_list|)
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
comment|/* AF_CONFIG_OPTION_USE_WARPER */
name|af_cjk_hint_edges
argument_list|(
name|hints
argument_list|,
operator|(
name|AF_Dimension
operator|)
name|dim
argument_list|)
expr_stmt|;
name|af_cjk_align_edge_points
argument_list|(
name|hints
argument_list|,
operator|(
name|AF_Dimension
operator|)
name|dim
argument_list|)
expr_stmt|;
name|af_glyph_hints_align_strong_points
argument_list|(
name|hints
argument_list|,
operator|(
name|AF_Dimension
operator|)
name|dim
argument_list|)
expr_stmt|;
name|af_glyph_hints_align_weak_points
argument_list|(
name|hints
argument_list|,
operator|(
name|AF_Dimension
operator|)
name|dim
argument_list|)
expr_stmt|;
block|}
block|}
if|#
directive|if
literal|0
block|af_glyph_hints_dump_points( hints );     af_glyph_hints_dump_segments( hints );     af_glyph_hints_dump_edges( hints );
endif|#
directive|endif
name|af_glyph_hints_save
argument_list|(
name|hints
argument_list|,
name|outline
argument_list|)
expr_stmt|;
name|Exit
label|:
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****                C J K   S C R I P T   C L A S S                *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_macro
name|AF_DEFINE_WRITING_SYSTEM_CLASS
argument_list|(
argument|af_cjk_writing_system_class
argument_list|,
argument|AF_WRITING_SYSTEM_CJK
argument_list|,
argument|sizeof ( AF_CJKMetricsRec )
argument_list|,
argument|(AF_WritingSystem_InitMetricsFunc) af_cjk_metrics_init
argument_list|,
argument|(AF_WritingSystem_ScaleMetricsFunc)af_cjk_metrics_scale
argument_list|,
argument|(AF_WritingSystem_DoneMetricsFunc) NULL
argument_list|,
argument|(AF_WritingSystem_InitHintsFunc)   af_cjk_hints_init
argument_list|,
argument|(AF_WritingSystem_ApplyHintsFunc)  af_cjk_hints_apply
argument_list|)
end_macro
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* !AF_CONFIG_OPTION_CJK */
end_comment
begin_macro
name|AF_DEFINE_WRITING_SYSTEM_CLASS
argument_list|(
argument|af_cjk_writing_system_class
argument_list|,
argument|AF_WRITING_SYSTEM_CJK
argument_list|,
argument|sizeof ( AF_CJKMetricsRec )
argument_list|,
argument|(AF_WritingSystem_InitMetricsFunc) NULL
argument_list|,
argument|(AF_WritingSystem_ScaleMetricsFunc)NULL
argument_list|,
argument|(AF_WritingSystem_DoneMetricsFunc) NULL
argument_list|,
argument|(AF_WritingSystem_InitHintsFunc)   NULL
argument_list|,
argument|(AF_WritingSystem_ApplyHintsFunc)  NULL
argument_list|)
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* !AF_CONFIG_OPTION_CJK */
end_comment
begin_comment
comment|/* END */
end_comment
end_unit
