begin_unit
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  afcjk.c                                                                */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*    Auto-fitter hinting routines for CJK script (body).                  */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  Copyright 2006, 2007, 2008, 2009 by                                    */
end_comment
begin_comment
comment|/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  This file is part of the FreeType project, and may only be used,       */
end_comment
begin_comment
comment|/*  modified, and distributed under the terms of the FreeType project      */
end_comment
begin_comment
comment|/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
end_comment
begin_comment
comment|/*  this file you indicate that you have read the license and              */
end_comment
begin_comment
comment|/*  understand and accept it fully.                                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*    *  The algorithm is based on akito's autohint patch, available here:    *    *  http://www.kde.gr.jp/~akito/patch/freetype2/    *    */
end_comment
begin_include
include|#
directive|include
file|"aftypes.h"
end_include
begin_include
include|#
directive|include
file|"aflatin.h"
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|AF_CONFIG_OPTION_CJK
end_ifdef
begin_include
include|#
directive|include
file|"afcjk.h"
end_include
begin_include
include|#
directive|include
file|"aferrors.h"
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|AF_USE_WARPER
end_ifdef
begin_include
include|#
directive|include
file|"afwarp.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****              C J K   G L O B A L   M E T R I C S              *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|af_cjk_metrics_init
argument_list|(
argument|AF_LatinMetrics  metrics
argument_list|,
argument|FT_Face          face
argument_list|)
end_macro
begin_block
block|{
name|FT_CharMap
name|oldmap
init|=
name|face
operator|->
name|charmap
decl_stmt|;
name|metrics
operator|->
name|units_per_em
operator|=
name|face
operator|->
name|units_per_EM
expr_stmt|;
comment|/* TODO are there blues? */
if|if
condition|(
name|FT_Select_Charmap
argument_list|(
name|face
argument_list|,
name|FT_ENCODING_UNICODE
argument_list|)
condition|)
name|face
operator|->
name|charmap
operator|=
name|NULL
expr_stmt|;
else|else
block|{
comment|/* latin's version would suffice */
name|af_latin_metrics_init_widths
argument_list|(
name|metrics
argument_list|,
name|face
argument_list|,
literal|0x7530
argument_list|)
expr_stmt|;
name|af_latin_metrics_check_digits
argument_list|(
name|metrics
argument_list|,
name|face
argument_list|)
expr_stmt|;
block|}
name|FT_Set_Charmap
argument_list|(
name|face
argument_list|,
name|oldmap
argument_list|)
expr_stmt|;
return|return
name|AF_Err_Ok
return|;
block|}
end_block
begin_function
specifier|static
name|void
DECL|function|af_cjk_metrics_scale_dim
name|af_cjk_metrics_scale_dim
parameter_list|(
name|AF_LatinMetrics
name|metrics
parameter_list|,
name|AF_Scaler
name|scaler
parameter_list|,
name|AF_Dimension
name|dim
parameter_list|)
block|{
name|AF_LatinAxis
name|axis
decl_stmt|;
name|axis
operator|=
operator|&
name|metrics
operator|->
name|axis
index|[
name|dim
index|]
expr_stmt|;
if|if
condition|(
name|dim
operator|==
name|AF_DIMENSION_HORZ
condition|)
block|{
name|axis
operator|->
name|scale
operator|=
name|scaler
operator|->
name|x_scale
expr_stmt|;
name|axis
operator|->
name|delta
operator|=
name|scaler
operator|->
name|x_delta
expr_stmt|;
block|}
else|else
block|{
name|axis
operator|->
name|scale
operator|=
name|scaler
operator|->
name|y_scale
expr_stmt|;
name|axis
operator|->
name|delta
operator|=
name|scaler
operator|->
name|y_delta
expr_stmt|;
block|}
block|}
end_function
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|af_cjk_metrics_scale
name|af_cjk_metrics_scale
argument_list|(
argument|AF_LatinMetrics  metrics
argument_list|,
argument|AF_Scaler        scaler
argument_list|)
end_macro
begin_block
block|{
name|metrics
operator|->
name|root
operator|.
name|scaler
operator|=
operator|*
name|scaler
expr_stmt|;
name|af_cjk_metrics_scale_dim
argument_list|(
name|metrics
argument_list|,
name|scaler
argument_list|,
name|AF_DIMENSION_HORZ
argument_list|)
expr_stmt|;
name|af_cjk_metrics_scale_dim
argument_list|(
name|metrics
argument_list|,
name|scaler
argument_list|,
name|AF_DIMENSION_VERT
argument_list|)
expr_stmt|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****              C J K   G L Y P H   A N A L Y S I S              *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|af_cjk_hints_compute_segments
name|af_cjk_hints_compute_segments
parameter_list|(
name|AF_GlyphHints
name|hints
parameter_list|,
name|AF_Dimension
name|dim
parameter_list|)
block|{
name|AF_AxisHints
name|axis
init|=
operator|&
name|hints
operator|->
name|axis
index|[
name|dim
index|]
decl_stmt|;
name|AF_Segment
name|segments
init|=
name|axis
operator|->
name|segments
decl_stmt|;
name|AF_Segment
name|segment_limit
init|=
name|segments
operator|+
name|axis
operator|->
name|num_segments
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|AF_Segment
name|seg
decl_stmt|;
name|error
operator|=
name|af_latin_hints_compute_segments
argument_list|(
name|hints
argument_list|,
name|dim
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
comment|/* a segment is round if it doesn't have successive */
comment|/* on-curve points.                                 */
for|for
control|(
name|seg
operator|=
name|segments
init|;
name|seg
operator|<
name|segment_limit
condition|;
name|seg
operator|++
control|)
block|{
name|AF_Point
name|pt
init|=
name|seg
operator|->
name|first
decl_stmt|;
name|AF_Point
name|last
init|=
name|seg
operator|->
name|last
decl_stmt|;
name|AF_Flags
name|f0
init|=
call|(
name|AF_Flags
call|)
argument_list|(
name|pt
operator|->
name|flags
operator|&
name|AF_FLAG_CONTROL
argument_list|)
decl_stmt|;
name|AF_Flags
name|f1
decl_stmt|;
name|seg
operator|->
name|flags
operator|&=
operator|~
name|AF_EDGE_ROUND
expr_stmt|;
for|for
control|(
init|;
name|pt
operator|!=
name|last
condition|;
name|f0
operator|=
name|f1
control|)
block|{
name|pt
operator|=
name|pt
operator|->
name|next
expr_stmt|;
name|f1
operator|=
call|(
name|AF_Flags
call|)
argument_list|(
name|pt
operator|->
name|flags
operator|&
name|AF_FLAG_CONTROL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|f0
operator|&&
operator|!
name|f1
condition|)
break|break;
if|if
condition|(
name|pt
operator|==
name|last
condition|)
name|seg
operator|->
name|flags
operator||=
name|AF_EDGE_ROUND
expr_stmt|;
block|}
block|}
return|return
name|AF_Err_Ok
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|af_cjk_hints_link_segments
name|af_cjk_hints_link_segments
parameter_list|(
name|AF_GlyphHints
name|hints
parameter_list|,
name|AF_Dimension
name|dim
parameter_list|)
block|{
name|AF_AxisHints
name|axis
init|=
operator|&
name|hints
operator|->
name|axis
index|[
name|dim
index|]
decl_stmt|;
name|AF_Segment
name|segments
init|=
name|axis
operator|->
name|segments
decl_stmt|;
name|AF_Segment
name|segment_limit
init|=
name|segments
operator|+
name|axis
operator|->
name|num_segments
decl_stmt|;
name|AF_Direction
name|major_dir
init|=
name|axis
operator|->
name|major_dir
decl_stmt|;
name|AF_Segment
name|seg1
decl_stmt|,
name|seg2
decl_stmt|;
name|FT_Pos
name|len_threshold
decl_stmt|;
name|FT_Pos
name|dist_threshold
decl_stmt|;
name|len_threshold
operator|=
name|AF_LATIN_CONSTANT
argument_list|(
name|hints
operator|->
name|metrics
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|dist_threshold
operator|=
operator|(
name|dim
operator|==
name|AF_DIMENSION_HORZ
operator|)
condition|?
name|hints
operator|->
name|x_scale
else|:
name|hints
operator|->
name|y_scale
expr_stmt|;
name|dist_threshold
operator|=
name|FT_DivFix
argument_list|(
literal|64
operator|*
literal|3
argument_list|,
name|dist_threshold
argument_list|)
expr_stmt|;
comment|/* now compare each segment to the others */
for|for
control|(
name|seg1
operator|=
name|segments
init|;
name|seg1
operator|<
name|segment_limit
condition|;
name|seg1
operator|++
control|)
block|{
comment|/* the fake segments are for metrics hinting only */
if|if
condition|(
name|seg1
operator|->
name|first
operator|==
name|seg1
operator|->
name|last
condition|)
continue|continue;
if|if
condition|(
name|seg1
operator|->
name|dir
operator|!=
name|major_dir
condition|)
continue|continue;
for|for
control|(
name|seg2
operator|=
name|segments
init|;
name|seg2
operator|<
name|segment_limit
condition|;
name|seg2
operator|++
control|)
if|if
condition|(
name|seg2
operator|!=
name|seg1
operator|&&
name|seg1
operator|->
name|dir
operator|+
name|seg2
operator|->
name|dir
operator|==
literal|0
condition|)
block|{
name|FT_Pos
name|dist
init|=
name|seg2
operator|->
name|pos
operator|-
name|seg1
operator|->
name|pos
decl_stmt|;
if|if
condition|(
name|dist
operator|<
literal|0
condition|)
continue|continue;
block|{
name|FT_Pos
name|min
init|=
name|seg1
operator|->
name|min_coord
decl_stmt|;
name|FT_Pos
name|max
init|=
name|seg1
operator|->
name|max_coord
decl_stmt|;
name|FT_Pos
name|len
decl_stmt|;
if|if
condition|(
name|min
operator|<
name|seg2
operator|->
name|min_coord
condition|)
name|min
operator|=
name|seg2
operator|->
name|min_coord
expr_stmt|;
if|if
condition|(
name|max
operator|>
name|seg2
operator|->
name|max_coord
condition|)
name|max
operator|=
name|seg2
operator|->
name|max_coord
expr_stmt|;
name|len
operator|=
name|max
operator|-
name|min
expr_stmt|;
if|if
condition|(
name|len
operator|>=
name|len_threshold
condition|)
block|{
if|if
condition|(
name|dist
operator|*
literal|8
operator|<
name|seg1
operator|->
name|score
operator|*
literal|9
operator|&&
operator|(
name|dist
operator|*
literal|8
operator|<
name|seg1
operator|->
name|score
operator|*
literal|7
operator|||
name|seg1
operator|->
name|len
operator|<
name|len
operator|)
condition|)
block|{
name|seg1
operator|->
name|score
operator|=
name|dist
expr_stmt|;
name|seg1
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|seg1
operator|->
name|link
operator|=
name|seg2
expr_stmt|;
block|}
if|if
condition|(
name|dist
operator|*
literal|8
operator|<
name|seg2
operator|->
name|score
operator|*
literal|9
operator|&&
operator|(
name|dist
operator|*
literal|8
operator|<
name|seg2
operator|->
name|score
operator|*
literal|7
operator|||
name|seg2
operator|->
name|len
operator|<
name|len
operator|)
condition|)
block|{
name|seg2
operator|->
name|score
operator|=
name|dist
expr_stmt|;
name|seg2
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|seg2
operator|->
name|link
operator|=
name|seg1
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/*      *  now compute the `serif' segments      *      *  In Hanzi, some strokes are wider on one or both of the ends.      *  We either identify the stems on the ends as serifs or remove      *  the linkage, depending on the length of the stems.      *      */
block|{
name|AF_Segment
name|link1
decl_stmt|,
name|link2
decl_stmt|;
for|for
control|(
name|seg1
operator|=
name|segments
init|;
name|seg1
operator|<
name|segment_limit
condition|;
name|seg1
operator|++
control|)
block|{
name|link1
operator|=
name|seg1
operator|->
name|link
expr_stmt|;
if|if
condition|(
operator|!
name|link1
operator|||
name|link1
operator|->
name|link
operator|!=
name|seg1
operator|||
name|link1
operator|->
name|pos
operator|<=
name|seg1
operator|->
name|pos
condition|)
continue|continue;
if|if
condition|(
name|seg1
operator|->
name|score
operator|>=
name|dist_threshold
condition|)
continue|continue;
for|for
control|(
name|seg2
operator|=
name|segments
init|;
name|seg2
operator|<
name|segment_limit
condition|;
name|seg2
operator|++
control|)
block|{
if|if
condition|(
name|seg2
operator|->
name|pos
operator|>
name|seg1
operator|->
name|pos
operator|||
name|seg1
operator|==
name|seg2
condition|)
continue|continue;
name|link2
operator|=
name|seg2
operator|->
name|link
expr_stmt|;
if|if
condition|(
operator|!
name|link2
operator|||
name|link2
operator|->
name|link
operator|!=
name|seg2
operator|||
name|link2
operator|->
name|pos
operator|<
name|link1
operator|->
name|pos
condition|)
continue|continue;
if|if
condition|(
name|seg1
operator|->
name|pos
operator|==
name|seg2
operator|->
name|pos
operator|&&
name|link1
operator|->
name|pos
operator|==
name|link2
operator|->
name|pos
condition|)
continue|continue;
if|if
condition|(
name|seg2
operator|->
name|score
operator|<=
name|seg1
operator|->
name|score
operator|||
name|seg1
operator|->
name|score
operator|*
literal|4
operator|<=
name|seg2
operator|->
name|score
condition|)
continue|continue;
comment|/* seg2< seg1< link1< link2 */
if|if
condition|(
name|seg1
operator|->
name|len
operator|>=
name|seg2
operator|->
name|len
operator|*
literal|3
condition|)
block|{
name|AF_Segment
name|seg
decl_stmt|;
for|for
control|(
name|seg
operator|=
name|segments
init|;
name|seg
operator|<
name|segment_limit
condition|;
name|seg
operator|++
control|)
block|{
name|AF_Segment
name|link
init|=
name|seg
operator|->
name|link
decl_stmt|;
if|if
condition|(
name|link
operator|==
name|seg2
condition|)
block|{
name|seg
operator|->
name|link
operator|=
literal|0
expr_stmt|;
name|seg
operator|->
name|serif
operator|=
name|link1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|link
operator|==
name|link2
condition|)
block|{
name|seg
operator|->
name|link
operator|=
literal|0
expr_stmt|;
name|seg
operator|->
name|serif
operator|=
name|seg1
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|seg1
operator|->
name|link
operator|=
name|link1
operator|->
name|link
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
for|for
control|(
name|seg1
operator|=
name|segments
init|;
name|seg1
operator|<
name|segment_limit
condition|;
name|seg1
operator|++
control|)
block|{
name|seg2
operator|=
name|seg1
operator|->
name|link
expr_stmt|;
if|if
condition|(
name|seg2
condition|)
block|{
name|seg2
operator|->
name|num_linked
operator|++
expr_stmt|;
if|if
condition|(
name|seg2
operator|->
name|link
operator|!=
name|seg1
condition|)
block|{
name|seg1
operator|->
name|link
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|seg2
operator|->
name|score
operator|<
name|dist_threshold
operator|||
name|seg1
operator|->
name|score
operator|<
name|seg2
operator|->
name|score
operator|*
literal|4
condition|)
name|seg1
operator|->
name|serif
operator|=
name|seg2
operator|->
name|link
expr_stmt|;
else|else
name|seg2
operator|->
name|num_linked
operator|--
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|af_cjk_hints_compute_edges
name|af_cjk_hints_compute_edges
parameter_list|(
name|AF_GlyphHints
name|hints
parameter_list|,
name|AF_Dimension
name|dim
parameter_list|)
block|{
name|AF_AxisHints
name|axis
init|=
operator|&
name|hints
operator|->
name|axis
index|[
name|dim
index|]
decl_stmt|;
name|FT_Error
name|error
init|=
name|AF_Err_Ok
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|hints
operator|->
name|memory
decl_stmt|;
name|AF_LatinAxis
name|laxis
init|=
operator|&
operator|(
operator|(
name|AF_LatinMetrics
operator|)
name|hints
operator|->
name|metrics
operator|)
operator|->
name|axis
index|[
name|dim
index|]
decl_stmt|;
name|AF_Segment
name|segments
init|=
name|axis
operator|->
name|segments
decl_stmt|;
name|AF_Segment
name|segment_limit
init|=
name|segments
operator|+
name|axis
operator|->
name|num_segments
decl_stmt|;
name|AF_Segment
name|seg
decl_stmt|;
name|FT_Fixed
name|scale
decl_stmt|;
name|FT_Pos
name|edge_distance_threshold
decl_stmt|;
name|axis
operator|->
name|num_edges
operator|=
literal|0
expr_stmt|;
name|scale
operator|=
operator|(
name|dim
operator|==
name|AF_DIMENSION_HORZ
operator|)
condition|?
name|hints
operator|->
name|x_scale
else|:
name|hints
operator|->
name|y_scale
expr_stmt|;
comment|/*********************************************************************/
comment|/*                                                                   */
comment|/* We begin by generating a sorted table of edges for the current    */
comment|/* direction.  To do so, we simply scan each segment and try to find */
comment|/* an edge in our table that corresponds to its position.            */
comment|/*                                                                   */
comment|/* If no edge is found, we create and insert a new edge in the       */
comment|/* sorted table.  Otherwise, we simply add the segment to the edge's */
comment|/* list which is then processed in the second step to compute the    */
comment|/* edge's properties.                                                */
comment|/*                                                                   */
comment|/* Note that the edges table is sorted along the segment/edge        */
comment|/* position.                                                         */
comment|/*                                                                   */
comment|/*********************************************************************/
name|edge_distance_threshold
operator|=
name|FT_MulFix
argument_list|(
name|laxis
operator|->
name|edge_distance_threshold
argument_list|,
name|scale
argument_list|)
expr_stmt|;
if|if
condition|(
name|edge_distance_threshold
operator|>
literal|64
operator|/
literal|4
condition|)
name|edge_distance_threshold
operator|=
name|FT_DivFix
argument_list|(
literal|64
operator|/
literal|4
argument_list|,
name|scale
argument_list|)
expr_stmt|;
else|else
name|edge_distance_threshold
operator|=
name|laxis
operator|->
name|edge_distance_threshold
expr_stmt|;
for|for
control|(
name|seg
operator|=
name|segments
init|;
name|seg
operator|<
name|segment_limit
condition|;
name|seg
operator|++
control|)
block|{
name|AF_Edge
name|found
init|=
literal|0
decl_stmt|;
name|FT_Pos
name|best
init|=
literal|0xFFFFU
decl_stmt|;
name|FT_Int
name|ee
decl_stmt|;
comment|/* look for an edge corresponding to the segment */
for|for
control|(
name|ee
operator|=
literal|0
init|;
name|ee
operator|<
name|axis
operator|->
name|num_edges
condition|;
name|ee
operator|++
control|)
block|{
name|AF_Edge
name|edge
init|=
name|axis
operator|->
name|edges
operator|+
name|ee
decl_stmt|;
name|FT_Pos
name|dist
decl_stmt|;
if|if
condition|(
name|edge
operator|->
name|dir
operator|!=
name|seg
operator|->
name|dir
condition|)
continue|continue;
name|dist
operator|=
name|seg
operator|->
name|pos
operator|-
name|edge
operator|->
name|fpos
expr_stmt|;
if|if
condition|(
name|dist
operator|<
literal|0
condition|)
name|dist
operator|=
operator|-
name|dist
expr_stmt|;
if|if
condition|(
name|dist
operator|<
name|edge_distance_threshold
operator|&&
name|dist
operator|<
name|best
condition|)
block|{
name|AF_Segment
name|link
init|=
name|seg
operator|->
name|link
decl_stmt|;
comment|/* check whether all linked segments of the candidate edge */
comment|/* can make a single edge.                                 */
if|if
condition|(
name|link
condition|)
block|{
name|AF_Segment
name|seg1
init|=
name|edge
operator|->
name|first
decl_stmt|;
name|AF_Segment
name|link1
decl_stmt|;
name|FT_Pos
name|dist2
init|=
literal|0
decl_stmt|;
do|do
block|{
name|link1
operator|=
name|seg1
operator|->
name|link
expr_stmt|;
if|if
condition|(
name|link1
condition|)
block|{
name|dist2
operator|=
name|AF_SEGMENT_DIST
argument_list|(
name|link
argument_list|,
name|link1
argument_list|)
expr_stmt|;
if|if
condition|(
name|dist2
operator|>=
name|edge_distance_threshold
condition|)
break|break;
block|}
block|}
do|while
condition|(
operator|(
name|seg1
operator|=
name|seg1
operator|->
name|edge_next
operator|)
operator|!=
name|edge
operator|->
name|first
condition|)
do|;
if|if
condition|(
name|dist2
operator|>=
name|edge_distance_threshold
condition|)
continue|continue;
block|}
name|best
operator|=
name|dist
expr_stmt|;
name|found
operator|=
name|edge
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|AF_Edge
name|edge
decl_stmt|;
comment|/* insert a new edge in the list and */
comment|/* sort according to the position    */
name|error
operator|=
name|af_axis_hints_new_edge
argument_list|(
name|axis
argument_list|,
name|seg
operator|->
name|pos
argument_list|,
operator|(
name|AF_Direction
operator|)
name|seg
operator|->
name|dir
argument_list|,
name|memory
argument_list|,
operator|&
name|edge
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
comment|/* add the segment to the new edge's list */
name|FT_ZERO
argument_list|(
name|edge
argument_list|)
expr_stmt|;
name|edge
operator|->
name|first
operator|=
name|seg
expr_stmt|;
name|edge
operator|->
name|last
operator|=
name|seg
expr_stmt|;
name|edge
operator|->
name|fpos
operator|=
name|seg
operator|->
name|pos
expr_stmt|;
name|edge
operator|->
name|opos
operator|=
name|edge
operator|->
name|pos
operator|=
name|FT_MulFix
argument_list|(
name|seg
operator|->
name|pos
argument_list|,
name|scale
argument_list|)
expr_stmt|;
name|seg
operator|->
name|edge_next
operator|=
name|seg
expr_stmt|;
name|edge
operator|->
name|dir
operator|=
name|seg
operator|->
name|dir
expr_stmt|;
block|}
else|else
block|{
comment|/* if an edge was found, simply add the segment to the edge's */
comment|/* list                                                       */
name|seg
operator|->
name|edge_next
operator|=
name|found
operator|->
name|first
expr_stmt|;
name|found
operator|->
name|last
operator|->
name|edge_next
operator|=
name|seg
expr_stmt|;
name|found
operator|->
name|last
operator|=
name|seg
expr_stmt|;
block|}
block|}
comment|/*********************************************************************/
comment|/*                                                                   */
comment|/* Good, we now compute each edge's properties according to segments */
comment|/* found on its position.  Basically, these are as follows.          */
comment|/*                                                                   */
comment|/*  - edge's main direction                                          */
comment|/*  - stem edge, serif edge or both (which defaults to stem then)    */
comment|/*  - rounded edge, straight or both (which defaults to straight)    */
comment|/*  - link for edge                                                  */
comment|/*                                                                   */
comment|/*********************************************************************/
comment|/* first of all, set the `edge' field in each segment -- this is     */
comment|/* required in order to compute edge links                           */
comment|/*                                                                   */
comment|/* Note that removing this loop and setting the `edge' field of each */
comment|/* segment directly in the code above slows down execution speed for */
comment|/* some reasons on platforms like the Sun.                           */
block|{
name|AF_Edge
name|edges
init|=
name|axis
operator|->
name|edges
decl_stmt|;
name|AF_Edge
name|edge_limit
init|=
name|edges
operator|+
name|axis
operator|->
name|num_edges
decl_stmt|;
name|AF_Edge
name|edge
decl_stmt|;
for|for
control|(
name|edge
operator|=
name|edges
init|;
name|edge
operator|<
name|edge_limit
condition|;
name|edge
operator|++
control|)
block|{
name|seg
operator|=
name|edge
operator|->
name|first
expr_stmt|;
if|if
condition|(
name|seg
condition|)
do|do
block|{
name|seg
operator|->
name|edge
operator|=
name|edge
expr_stmt|;
name|seg
operator|=
name|seg
operator|->
name|edge_next
expr_stmt|;
block|}
do|while
condition|(
name|seg
operator|!=
name|edge
operator|->
name|first
condition|)
do|;
block|}
comment|/* now compute each edge properties */
for|for
control|(
name|edge
operator|=
name|edges
init|;
name|edge
operator|<
name|edge_limit
condition|;
name|edge
operator|++
control|)
block|{
name|FT_Int
name|is_round
init|=
literal|0
decl_stmt|;
comment|/* does it contain round segments?    */
name|FT_Int
name|is_straight
init|=
literal|0
decl_stmt|;
comment|/* does it contain straight segments? */
name|seg
operator|=
name|edge
operator|->
name|first
expr_stmt|;
do|do
block|{
name|FT_Bool
name|is_serif
decl_stmt|;
comment|/* check for roundness of segment */
if|if
condition|(
name|seg
operator|->
name|flags
operator|&
name|AF_EDGE_ROUND
condition|)
name|is_round
operator|++
expr_stmt|;
else|else
name|is_straight
operator|++
expr_stmt|;
comment|/* check for links -- if seg->serif is set, then seg->link must */
comment|/* be ignored                                                   */
name|is_serif
operator|=
call|(
name|FT_Bool
call|)
argument_list|(
name|seg
operator|->
name|serif
operator|&&
name|seg
operator|->
name|serif
operator|->
name|edge
operator|!=
name|edge
argument_list|)
expr_stmt|;
if|if
condition|(
name|seg
operator|->
name|link
operator|||
name|is_serif
condition|)
block|{
name|AF_Edge
name|edge2
decl_stmt|;
name|AF_Segment
name|seg2
decl_stmt|;
name|edge2
operator|=
name|edge
operator|->
name|link
expr_stmt|;
name|seg2
operator|=
name|seg
operator|->
name|link
expr_stmt|;
if|if
condition|(
name|is_serif
condition|)
block|{
name|seg2
operator|=
name|seg
operator|->
name|serif
expr_stmt|;
name|edge2
operator|=
name|edge
operator|->
name|serif
expr_stmt|;
block|}
if|if
condition|(
name|edge2
condition|)
block|{
name|FT_Pos
name|edge_delta
decl_stmt|;
name|FT_Pos
name|seg_delta
decl_stmt|;
name|edge_delta
operator|=
name|edge
operator|->
name|fpos
operator|-
name|edge2
operator|->
name|fpos
expr_stmt|;
if|if
condition|(
name|edge_delta
operator|<
literal|0
condition|)
name|edge_delta
operator|=
operator|-
name|edge_delta
expr_stmt|;
name|seg_delta
operator|=
name|AF_SEGMENT_DIST
argument_list|(
name|seg
argument_list|,
name|seg2
argument_list|)
expr_stmt|;
if|if
condition|(
name|seg_delta
operator|<
name|edge_delta
condition|)
name|edge2
operator|=
name|seg2
operator|->
name|edge
expr_stmt|;
block|}
else|else
name|edge2
operator|=
name|seg2
operator|->
name|edge
expr_stmt|;
if|if
condition|(
name|is_serif
condition|)
block|{
name|edge
operator|->
name|serif
operator|=
name|edge2
expr_stmt|;
name|edge2
operator|->
name|flags
operator||=
name|AF_EDGE_SERIF
expr_stmt|;
block|}
else|else
name|edge
operator|->
name|link
operator|=
name|edge2
expr_stmt|;
block|}
name|seg
operator|=
name|seg
operator|->
name|edge_next
expr_stmt|;
block|}
do|while
condition|(
name|seg
operator|!=
name|edge
operator|->
name|first
condition|)
do|;
comment|/* set the round/straight flags */
name|edge
operator|->
name|flags
operator|=
name|AF_EDGE_NORMAL
expr_stmt|;
if|if
condition|(
name|is_round
operator|>
literal|0
operator|&&
name|is_round
operator|>=
name|is_straight
condition|)
name|edge
operator|->
name|flags
operator||=
name|AF_EDGE_ROUND
expr_stmt|;
comment|/* get rid of serifs if link is set                 */
comment|/* XXX: This gets rid of many unpleasant artefacts! */
comment|/*      Example: the `c' in cour.pfa at size 13     */
if|if
condition|(
name|edge
operator|->
name|serif
operator|&&
name|edge
operator|->
name|link
condition|)
name|edge
operator|->
name|serif
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|Exit
label|:
return|return
name|error
return|;
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|af_cjk_hints_detect_features
name|af_cjk_hints_detect_features
parameter_list|(
name|AF_GlyphHints
name|hints
parameter_list|,
name|AF_Dimension
name|dim
parameter_list|)
block|{
name|FT_Error
name|error
decl_stmt|;
name|error
operator|=
name|af_cjk_hints_compute_segments
argument_list|(
name|hints
argument_list|,
name|dim
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|af_cjk_hints_link_segments
argument_list|(
name|hints
argument_list|,
name|dim
argument_list|)
expr_stmt|;
name|error
operator|=
name|af_cjk_hints_compute_edges
argument_list|(
name|hints
argument_list|,
name|dim
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|af_cjk_hints_init
argument_list|(
argument|AF_GlyphHints    hints
argument_list|,
argument|AF_LatinMetrics  metrics
argument_list|)
end_macro
begin_block
block|{
name|FT_Render_Mode
name|mode
decl_stmt|;
name|FT_UInt32
name|scaler_flags
decl_stmt|,
name|other_flags
decl_stmt|;
name|af_glyph_hints_rescale
argument_list|(
name|hints
argument_list|,
operator|(
name|AF_ScriptMetrics
operator|)
name|metrics
argument_list|)
expr_stmt|;
comment|/*      *  correct x_scale and y_scale when needed, since they may have      *  been modified af_cjk_scale_dim above      */
name|hints
operator|->
name|x_scale
operator|=
name|metrics
operator|->
name|axis
index|[
name|AF_DIMENSION_HORZ
index|]
operator|.
name|scale
expr_stmt|;
name|hints
operator|->
name|x_delta
operator|=
name|metrics
operator|->
name|axis
index|[
name|AF_DIMENSION_HORZ
index|]
operator|.
name|delta
expr_stmt|;
name|hints
operator|->
name|y_scale
operator|=
name|metrics
operator|->
name|axis
index|[
name|AF_DIMENSION_VERT
index|]
operator|.
name|scale
expr_stmt|;
name|hints
operator|->
name|y_delta
operator|=
name|metrics
operator|->
name|axis
index|[
name|AF_DIMENSION_VERT
index|]
operator|.
name|delta
expr_stmt|;
comment|/* compute flags depending on render mode, etc. */
name|mode
operator|=
name|metrics
operator|->
name|root
operator|.
name|scaler
operator|.
name|render_mode
expr_stmt|;
ifdef|#
directive|ifdef
name|AF_USE_WARPER
if|if
condition|(
name|mode
operator|==
name|FT_RENDER_MODE_LCD
operator|||
name|mode
operator|==
name|FT_RENDER_MODE_LCD_V
condition|)
name|metrics
operator|->
name|root
operator|.
name|scaler
operator|.
name|render_mode
operator|=
name|mode
operator|=
name|FT_RENDER_MODE_NORMAL
expr_stmt|;
endif|#
directive|endif
name|scaler_flags
operator|=
name|hints
operator|->
name|scaler_flags
expr_stmt|;
name|other_flags
operator|=
literal|0
expr_stmt|;
comment|/*      *  We snap the width of vertical stems for the monochrome and      *  horizontal LCD rendering targets only.      */
if|if
condition|(
name|mode
operator|==
name|FT_RENDER_MODE_MONO
operator|||
name|mode
operator|==
name|FT_RENDER_MODE_LCD
condition|)
name|other_flags
operator||=
name|AF_LATIN_HINTS_HORZ_SNAP
expr_stmt|;
comment|/*      *  We snap the width of horizontal stems for the monochrome and      *  vertical LCD rendering targets only.      */
if|if
condition|(
name|mode
operator|==
name|FT_RENDER_MODE_MONO
operator|||
name|mode
operator|==
name|FT_RENDER_MODE_LCD_V
condition|)
name|other_flags
operator||=
name|AF_LATIN_HINTS_VERT_SNAP
expr_stmt|;
comment|/*      *  We adjust stems to full pixels only if we don't use the `light' mode.      */
if|if
condition|(
name|mode
operator|!=
name|FT_RENDER_MODE_LIGHT
condition|)
name|other_flags
operator||=
name|AF_LATIN_HINTS_STEM_ADJUST
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|FT_RENDER_MODE_MONO
condition|)
name|other_flags
operator||=
name|AF_LATIN_HINTS_MONO
expr_stmt|;
name|scaler_flags
operator||=
name|AF_SCALER_FLAG_NO_ADVANCE
expr_stmt|;
name|hints
operator|->
name|scaler_flags
operator|=
name|scaler_flags
expr_stmt|;
name|hints
operator|->
name|other_flags
operator|=
name|other_flags
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****          C J K   G L Y P H   G R I D - F I T T I N G          *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/* snap a given width in scaled coordinates to one of the */
end_comment
begin_comment
comment|/* current standard widths                                */
end_comment
begin_function
specifier|static
name|FT_Pos
DECL|function|af_cjk_snap_width
name|af_cjk_snap_width
parameter_list|(
name|AF_Width
name|widths
parameter_list|,
name|FT_Int
name|count
parameter_list|,
name|FT_Pos
name|width
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
name|FT_Pos
name|best
init|=
literal|64
operator|+
literal|32
operator|+
literal|2
decl_stmt|;
name|FT_Pos
name|reference
init|=
name|width
decl_stmt|;
name|FT_Pos
name|scaled
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
block|{
name|FT_Pos
name|w
decl_stmt|;
name|FT_Pos
name|dist
decl_stmt|;
name|w
operator|=
name|widths
index|[
name|n
index|]
operator|.
name|cur
expr_stmt|;
name|dist
operator|=
name|width
operator|-
name|w
expr_stmt|;
if|if
condition|(
name|dist
operator|<
literal|0
condition|)
name|dist
operator|=
operator|-
name|dist
expr_stmt|;
if|if
condition|(
name|dist
operator|<
name|best
condition|)
block|{
name|best
operator|=
name|dist
expr_stmt|;
name|reference
operator|=
name|w
expr_stmt|;
block|}
block|}
name|scaled
operator|=
name|FT_PIX_ROUND
argument_list|(
name|reference
argument_list|)
expr_stmt|;
if|if
condition|(
name|width
operator|>=
name|reference
condition|)
block|{
if|if
condition|(
name|width
operator|<
name|scaled
operator|+
literal|48
condition|)
name|width
operator|=
name|reference
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|width
operator|>
name|scaled
operator|-
literal|48
condition|)
name|width
operator|=
name|reference
expr_stmt|;
block|}
return|return
name|width
return|;
block|}
end_function
begin_comment
comment|/* compute the snapped width of a given stem */
end_comment
begin_function
specifier|static
name|FT_Pos
DECL|function|af_cjk_compute_stem_width
name|af_cjk_compute_stem_width
parameter_list|(
name|AF_GlyphHints
name|hints
parameter_list|,
name|AF_Dimension
name|dim
parameter_list|,
name|FT_Pos
name|width
parameter_list|,
name|AF_Edge_Flags
name|base_flags
parameter_list|,
name|AF_Edge_Flags
name|stem_flags
parameter_list|)
block|{
name|AF_LatinMetrics
name|metrics
init|=
operator|(
name|AF_LatinMetrics
operator|)
name|hints
operator|->
name|metrics
decl_stmt|;
name|AF_LatinAxis
name|axis
init|=
operator|&
name|metrics
operator|->
name|axis
index|[
name|dim
index|]
decl_stmt|;
name|FT_Pos
name|dist
init|=
name|width
decl_stmt|;
name|FT_Int
name|sign
init|=
literal|0
decl_stmt|;
name|FT_Int
name|vertical
init|=
operator|(
name|dim
operator|==
name|AF_DIMENSION_VERT
operator|)
decl_stmt|;
name|FT_UNUSED
argument_list|(
name|base_flags
argument_list|)
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|stem_flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|AF_LATIN_HINTS_DO_STEM_ADJUST
argument_list|(
name|hints
argument_list|)
condition|)
return|return
name|width
return|;
if|if
condition|(
name|dist
operator|<
literal|0
condition|)
block|{
name|dist
operator|=
operator|-
name|width
expr_stmt|;
name|sign
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|vertical
operator|&&
operator|!
name|AF_LATIN_HINTS_DO_VERT_SNAP
argument_list|(
name|hints
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|vertical
operator|&&
operator|!
name|AF_LATIN_HINTS_DO_HORZ_SNAP
argument_list|(
name|hints
argument_list|)
operator|)
condition|)
block|{
comment|/* smooth hinting process: very lightly quantize the stem width */
if|if
condition|(
name|axis
operator|->
name|width_count
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|FT_ABS
argument_list|(
name|dist
operator|-
name|axis
operator|->
name|widths
index|[
literal|0
index|]
operator|.
name|cur
argument_list|)
operator|<
literal|40
condition|)
block|{
name|dist
operator|=
name|axis
operator|->
name|widths
index|[
literal|0
index|]
operator|.
name|cur
expr_stmt|;
if|if
condition|(
name|dist
operator|<
literal|48
condition|)
name|dist
operator|=
literal|48
expr_stmt|;
goto|goto
name|Done_Width
goto|;
block|}
block|}
if|if
condition|(
name|dist
operator|<
literal|54
condition|)
name|dist
operator|+=
operator|(
literal|54
operator|-
name|dist
operator|)
operator|/
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|dist
operator|<
literal|3
operator|*
literal|64
condition|)
block|{
name|FT_Pos
name|delta
decl_stmt|;
name|delta
operator|=
name|dist
operator|&
literal|63
expr_stmt|;
name|dist
operator|&=
operator|-
literal|64
expr_stmt|;
if|if
condition|(
name|delta
operator|<
literal|10
condition|)
name|dist
operator|+=
name|delta
expr_stmt|;
elseif|else
if|if
condition|(
name|delta
operator|<
literal|22
condition|)
name|dist
operator|+=
literal|10
expr_stmt|;
elseif|else
if|if
condition|(
name|delta
operator|<
literal|42
condition|)
name|dist
operator|+=
name|delta
expr_stmt|;
elseif|else
if|if
condition|(
name|delta
operator|<
literal|54
condition|)
name|dist
operator|+=
literal|54
expr_stmt|;
else|else
name|dist
operator|+=
name|delta
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* strong hinting process: snap the stem width to integer pixels */
name|dist
operator|=
name|af_cjk_snap_width
argument_list|(
name|axis
operator|->
name|widths
argument_list|,
name|axis
operator|->
name|width_count
argument_list|,
name|dist
argument_list|)
expr_stmt|;
if|if
condition|(
name|vertical
condition|)
block|{
comment|/* in the case of vertical hinting, always round */
comment|/* the stem heights to integer pixels            */
if|if
condition|(
name|dist
operator|>=
literal|64
condition|)
name|dist
operator|=
operator|(
name|dist
operator|+
literal|16
operator|)
operator|&
operator|~
literal|63
expr_stmt|;
else|else
name|dist
operator|=
literal|64
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|AF_LATIN_HINTS_DO_MONO
argument_list|(
name|hints
argument_list|)
condition|)
block|{
comment|/* monochrome horizontal hinting: snap widths to integer pixels */
comment|/* with a different threshold                                   */
if|if
condition|(
name|dist
operator|<
literal|64
condition|)
name|dist
operator|=
literal|64
expr_stmt|;
else|else
name|dist
operator|=
operator|(
name|dist
operator|+
literal|32
operator|)
operator|&
operator|~
literal|63
expr_stmt|;
block|}
else|else
block|{
comment|/* for horizontal anti-aliased hinting, we adopt a more subtle */
comment|/* approach: we strengthen small stems, round stems whose size */
comment|/* is between 1 and 2 pixels to an integer, otherwise nothing  */
if|if
condition|(
name|dist
operator|<
literal|48
condition|)
name|dist
operator|=
operator|(
name|dist
operator|+
literal|64
operator|)
operator|>>
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|dist
operator|<
literal|128
condition|)
name|dist
operator|=
operator|(
name|dist
operator|+
literal|22
operator|)
operator|&
operator|~
literal|63
expr_stmt|;
else|else
comment|/* round otherwise to prevent color fringes in LCD mode */
name|dist
operator|=
operator|(
name|dist
operator|+
literal|32
operator|)
operator|&
operator|~
literal|63
expr_stmt|;
block|}
block|}
block|}
name|Done_Width
label|:
if|if
condition|(
name|sign
condition|)
name|dist
operator|=
operator|-
name|dist
expr_stmt|;
return|return
name|dist
return|;
block|}
end_function
begin_comment
comment|/* align one stem edge relative to the previous stem edge */
end_comment
begin_function
specifier|static
name|void
DECL|function|af_cjk_align_linked_edge
name|af_cjk_align_linked_edge
parameter_list|(
name|AF_GlyphHints
name|hints
parameter_list|,
name|AF_Dimension
name|dim
parameter_list|,
name|AF_Edge
name|base_edge
parameter_list|,
name|AF_Edge
name|stem_edge
parameter_list|)
block|{
name|FT_Pos
name|dist
init|=
name|stem_edge
operator|->
name|opos
operator|-
name|base_edge
operator|->
name|opos
decl_stmt|;
name|FT_Pos
name|fitted_width
init|=
name|af_cjk_compute_stem_width
argument_list|(
name|hints
argument_list|,
name|dim
argument_list|,
name|dist
argument_list|,
operator|(
name|AF_Edge_Flags
operator|)
name|base_edge
operator|->
name|flags
argument_list|,
operator|(
name|AF_Edge_Flags
operator|)
name|stem_edge
operator|->
name|flags
argument_list|)
decl_stmt|;
name|stem_edge
operator|->
name|pos
operator|=
name|base_edge
operator|->
name|pos
operator|+
name|fitted_width
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|af_cjk_align_serif_edge
name|af_cjk_align_serif_edge
parameter_list|(
name|AF_GlyphHints
name|hints
parameter_list|,
name|AF_Edge
name|base
parameter_list|,
name|AF_Edge
name|serif
parameter_list|)
block|{
name|FT_UNUSED
argument_list|(
name|hints
argument_list|)
expr_stmt|;
name|serif
operator|->
name|pos
operator|=
name|base
operator|->
name|pos
operator|+
operator|(
name|serif
operator|->
name|opos
operator|-
name|base
operator|->
name|opos
operator|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/****                                                                 ****/
end_comment
begin_comment
comment|/****                    E D G E   H I N T I N G                      ****/
end_comment
begin_comment
comment|/****                                                                 ****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_define
DECL|macro|AF_LIGHT_MODE_MAX_HORZ_GAP
define|#
directive|define
name|AF_LIGHT_MODE_MAX_HORZ_GAP
value|9
end_define
begin_define
DECL|macro|AF_LIGHT_MODE_MAX_VERT_GAP
define|#
directive|define
name|AF_LIGHT_MODE_MAX_VERT_GAP
value|15
end_define
begin_define
DECL|macro|AF_LIGHT_MODE_MAX_DELTA_ABS
define|#
directive|define
name|AF_LIGHT_MODE_MAX_DELTA_ABS
value|14
end_define
begin_function
specifier|static
name|FT_Pos
DECL|function|af_hint_normal_stem
name|af_hint_normal_stem
parameter_list|(
name|AF_GlyphHints
name|hints
parameter_list|,
name|AF_Edge
name|edge
parameter_list|,
name|AF_Edge
name|edge2
parameter_list|,
name|FT_Pos
name|anchor
parameter_list|,
name|AF_Dimension
name|dim
parameter_list|)
block|{
name|FT_Pos
name|org_len
decl_stmt|,
name|cur_len
decl_stmt|,
name|org_center
decl_stmt|;
name|FT_Pos
name|cur_pos1
decl_stmt|,
name|cur_pos2
decl_stmt|;
name|FT_Pos
name|d_off1
decl_stmt|,
name|u_off1
decl_stmt|,
name|d_off2
decl_stmt|,
name|u_off2
decl_stmt|,
name|delta
decl_stmt|;
name|FT_Pos
name|offset
decl_stmt|;
name|FT_Pos
name|threshold
init|=
literal|64
decl_stmt|;
if|if
condition|(
operator|!
name|AF_LATIN_HINTS_DO_STEM_ADJUST
argument_list|(
name|hints
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|edge
operator|->
name|flags
operator|&
name|AF_EDGE_ROUND
operator|)
operator|&&
operator|(
name|edge2
operator|->
name|flags
operator|&
name|AF_EDGE_ROUND
operator|)
condition|)
block|{
if|if
condition|(
name|dim
operator|==
name|AF_DIMENSION_VERT
condition|)
name|threshold
operator|=
literal|64
operator|-
name|AF_LIGHT_MODE_MAX_HORZ_GAP
expr_stmt|;
else|else
name|threshold
operator|=
literal|64
operator|-
name|AF_LIGHT_MODE_MAX_VERT_GAP
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|dim
operator|==
name|AF_DIMENSION_VERT
condition|)
name|threshold
operator|=
literal|64
operator|-
name|AF_LIGHT_MODE_MAX_HORZ_GAP
operator|/
literal|3
expr_stmt|;
else|else
name|threshold
operator|=
literal|64
operator|-
name|AF_LIGHT_MODE_MAX_VERT_GAP
operator|/
literal|3
expr_stmt|;
block|}
block|}
name|org_len
operator|=
name|edge2
operator|->
name|opos
operator|-
name|edge
operator|->
name|opos
expr_stmt|;
name|cur_len
operator|=
name|af_cjk_compute_stem_width
argument_list|(
name|hints
argument_list|,
name|dim
argument_list|,
name|org_len
argument_list|,
operator|(
name|AF_Edge_Flags
operator|)
name|edge
operator|->
name|flags
argument_list|,
operator|(
name|AF_Edge_Flags
operator|)
name|edge2
operator|->
name|flags
argument_list|)
expr_stmt|;
name|org_center
operator|=
operator|(
name|edge
operator|->
name|opos
operator|+
name|edge2
operator|->
name|opos
operator|)
operator|/
literal|2
operator|+
name|anchor
expr_stmt|;
name|cur_pos1
operator|=
name|org_center
operator|-
name|cur_len
operator|/
literal|2
expr_stmt|;
name|cur_pos2
operator|=
name|cur_pos1
operator|+
name|cur_len
expr_stmt|;
name|d_off1
operator|=
name|cur_pos1
operator|-
name|FT_PIX_FLOOR
argument_list|(
name|cur_pos1
argument_list|)
expr_stmt|;
name|d_off2
operator|=
name|cur_pos2
operator|-
name|FT_PIX_FLOOR
argument_list|(
name|cur_pos2
argument_list|)
expr_stmt|;
name|u_off1
operator|=
literal|64
operator|-
name|d_off1
expr_stmt|;
name|u_off2
operator|=
literal|64
operator|-
name|d_off2
expr_stmt|;
name|delta
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|d_off1
operator|==
literal|0
operator|||
name|d_off2
operator|==
literal|0
condition|)
goto|goto
name|Exit
goto|;
if|if
condition|(
name|cur_len
operator|<=
name|threshold
condition|)
block|{
if|if
condition|(
name|d_off2
operator|<
name|cur_len
condition|)
block|{
if|if
condition|(
name|u_off1
operator|<=
name|d_off2
condition|)
name|delta
operator|=
name|u_off1
expr_stmt|;
else|else
name|delta
operator|=
operator|-
name|d_off2
expr_stmt|;
block|}
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|threshold
operator|<
literal|64
condition|)
block|{
if|if
condition|(
name|d_off1
operator|>=
name|threshold
operator|||
name|u_off1
operator|>=
name|threshold
operator|||
name|d_off2
operator|>=
name|threshold
operator|||
name|u_off2
operator|>=
name|threshold
condition|)
goto|goto
name|Exit
goto|;
block|}
name|offset
operator|=
name|cur_len
operator|%
literal|64
expr_stmt|;
if|if
condition|(
name|offset
operator|<
literal|32
condition|)
block|{
if|if
condition|(
name|u_off1
operator|<=
name|offset
operator|||
name|d_off2
operator|<=
name|offset
condition|)
goto|goto
name|Exit
goto|;
block|}
else|else
name|offset
operator|=
literal|64
operator|-
name|threshold
expr_stmt|;
name|d_off1
operator|=
name|threshold
operator|-
name|u_off1
expr_stmt|;
name|u_off1
operator|=
name|u_off1
operator|-
name|offset
expr_stmt|;
name|u_off2
operator|=
name|threshold
operator|-
name|d_off2
expr_stmt|;
name|d_off2
operator|=
name|d_off2
operator|-
name|offset
expr_stmt|;
if|if
condition|(
name|d_off1
operator|<=
name|u_off1
condition|)
name|u_off1
operator|=
operator|-
name|d_off1
expr_stmt|;
if|if
condition|(
name|d_off2
operator|<=
name|u_off2
condition|)
name|u_off2
operator|=
operator|-
name|d_off2
expr_stmt|;
if|if
condition|(
name|FT_ABS
argument_list|(
name|u_off1
argument_list|)
operator|<=
name|FT_ABS
argument_list|(
name|u_off2
argument_list|)
condition|)
name|delta
operator|=
name|u_off1
expr_stmt|;
else|else
name|delta
operator|=
name|u_off2
expr_stmt|;
name|Exit
label|:
if|#
directive|if
literal|1
if|if
condition|(
operator|!
name|AF_LATIN_HINTS_DO_STEM_ADJUST
argument_list|(
name|hints
argument_list|)
condition|)
block|{
if|if
condition|(
name|delta
operator|>
name|AF_LIGHT_MODE_MAX_DELTA_ABS
condition|)
name|delta
operator|=
name|AF_LIGHT_MODE_MAX_DELTA_ABS
expr_stmt|;
elseif|else
if|if
condition|(
name|delta
operator|<
operator|-
name|AF_LIGHT_MODE_MAX_DELTA_ABS
condition|)
name|delta
operator|=
operator|-
name|AF_LIGHT_MODE_MAX_DELTA_ABS
expr_stmt|;
block|}
endif|#
directive|endif
name|cur_pos1
operator|+=
name|delta
expr_stmt|;
if|if
condition|(
name|edge
operator|->
name|opos
operator|<
name|edge2
operator|->
name|opos
condition|)
block|{
name|edge
operator|->
name|pos
operator|=
name|cur_pos1
expr_stmt|;
name|edge2
operator|->
name|pos
operator|=
name|cur_pos1
operator|+
name|cur_len
expr_stmt|;
block|}
else|else
block|{
name|edge
operator|->
name|pos
operator|=
name|cur_pos1
operator|+
name|cur_len
expr_stmt|;
name|edge2
operator|->
name|pos
operator|=
name|cur_pos1
expr_stmt|;
block|}
return|return
name|delta
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|af_cjk_hint_edges
name|af_cjk_hint_edges
parameter_list|(
name|AF_GlyphHints
name|hints
parameter_list|,
name|AF_Dimension
name|dim
parameter_list|)
block|{
name|AF_AxisHints
name|axis
init|=
operator|&
name|hints
operator|->
name|axis
index|[
name|dim
index|]
decl_stmt|;
name|AF_Edge
name|edges
init|=
name|axis
operator|->
name|edges
decl_stmt|;
name|AF_Edge
name|edge_limit
init|=
name|edges
operator|+
name|axis
operator|->
name|num_edges
decl_stmt|;
name|FT_PtrDist
name|n_edges
decl_stmt|;
name|AF_Edge
name|edge
decl_stmt|;
name|AF_Edge
name|anchor
init|=
literal|0
decl_stmt|;
name|FT_Pos
name|delta
init|=
literal|0
decl_stmt|;
name|FT_Int
name|skipped
init|=
literal|0
decl_stmt|;
comment|/* now we align all stem edges. */
for|for
control|(
name|edge
operator|=
name|edges
init|;
name|edge
operator|<
name|edge_limit
condition|;
name|edge
operator|++
control|)
block|{
name|AF_Edge
name|edge2
decl_stmt|;
if|if
condition|(
name|edge
operator|->
name|flags
operator|&
name|AF_EDGE_DONE
condition|)
continue|continue;
comment|/* skip all non-stem edges */
name|edge2
operator|=
name|edge
operator|->
name|link
expr_stmt|;
if|if
condition|(
operator|!
name|edge2
condition|)
block|{
name|skipped
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* now align the stem */
if|if
condition|(
name|edge2
operator|<
name|edge
condition|)
block|{
name|af_cjk_align_linked_edge
argument_list|(
name|hints
argument_list|,
name|dim
argument_list|,
name|edge2
argument_list|,
name|edge
argument_list|)
expr_stmt|;
name|edge
operator|->
name|flags
operator||=
name|AF_EDGE_DONE
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|dim
operator|!=
name|AF_DIMENSION_VERT
operator|&&
operator|!
name|anchor
condition|)
block|{
if|#
directive|if
literal|0
block|if ( fixedpitch )         {           AF_Edge     left  = edge;           AF_Edge     right = edge_limit - 1;           AF_EdgeRec  left1, left2, right1, right2;           FT_Pos      target, center1, center2;           FT_Pos      delta1, delta2, d1, d2;             while ( right> left&& !right->link )             right--;            left1  = *left;           left2  = *left->link;           right1 = *right->link;           right2 = *right;            delta  = ( ( ( hinter->pp2.x + 32 )& -64 ) - hinter->pp2.x ) / 2;           target = left->opos + ( right->opos - left->opos ) / 2 + delta - 16;            delta1  = delta;           delta1 += af_hint_normal_stem( hints, left, left->link,                                          delta1, 0 );            if ( left->link != right )             af_hint_normal_stem( hints, right->link, right, delta1, 0 );            center1 = left->pos + ( right->pos - left->pos ) / 2;            if ( center1>= target )             delta2 = delta - 32;           else             delta2 = delta + 32;            delta2 += af_hint_normal_stem( hints,&left1,&left2, delta2, 0 );            if ( delta1 != delta2 )           {             if ( left->link != right )               af_hint_normal_stem( hints,&right1,&right2, delta2, 0 );              center2 = left1.pos + ( right2.pos - left1.pos ) / 2;              d1 = center1 - target;             d2 = center2 - target;              if ( FT_ABS( d2 )< FT_ABS( d1 ) )             {               left->pos       = left1.pos;               left->link->pos = left2.pos;                if ( left->link != right )               {                 right->link->pos = right1.pos;                 right->pos       = right2.pos;               }                delta1 = delta2;             }           }            delta               = delta1;           right->link->flags |= AF_EDGE_DONE;           right->flags       |= AF_EDGE_DONE;         }         else
endif|#
directive|endif
comment|/* 0 */
name|delta
operator|=
name|af_hint_normal_stem
argument_list|(
name|hints
argument_list|,
name|edge
argument_list|,
name|edge2
argument_list|,
literal|0
argument_list|,
name|AF_DIMENSION_HORZ
argument_list|)
expr_stmt|;
block|}
else|else
name|af_hint_normal_stem
argument_list|(
name|hints
argument_list|,
name|edge
argument_list|,
name|edge2
argument_list|,
name|delta
argument_list|,
name|dim
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|printf( "stem (%d,%d) adjusted (%.1f,%.1f)\n",                edge - edges, edge2 - edges,                ( edge->pos - edge->opos ) / 64.0,                ( edge2->pos - edge2->opos ) / 64.0 );
endif|#
directive|endif
name|anchor
operator|=
name|edge
expr_stmt|;
name|edge
operator|->
name|flags
operator||=
name|AF_EDGE_DONE
expr_stmt|;
name|edge2
operator|->
name|flags
operator||=
name|AF_EDGE_DONE
expr_stmt|;
block|}
comment|/* make sure that lowercase m's maintain their symmetry */
comment|/* In general, lowercase m's have six vertical edges if they are sans */
comment|/* serif, or twelve if they are with serifs.  This implementation is  */
comment|/* based on that assumption, and seems to work very well with most    */
comment|/* faces.  However, if for a certain face this assumption is not      */
comment|/* true, the m is just rendered like before.  In addition, any stem   */
comment|/* correction will only be applied to symmetrical glyphs (even if the */
comment|/* glyph is not an m), so the potential for unwanted distortion is    */
comment|/* relatively low.                                                    */
comment|/* We don't handle horizontal edges since we can't easily assure that */
comment|/* the third (lowest) stem aligns with the base line; it might end up */
comment|/* one pixel higher or lower.                                         */
name|n_edges
operator|=
name|edge_limit
operator|-
name|edges
expr_stmt|;
if|if
condition|(
name|dim
operator|==
name|AF_DIMENSION_HORZ
operator|&&
operator|(
name|n_edges
operator|==
literal|6
operator|||
name|n_edges
operator|==
literal|12
operator|)
condition|)
block|{
name|AF_Edge
name|edge1
decl_stmt|,
name|edge2
decl_stmt|,
name|edge3
decl_stmt|;
name|FT_Pos
name|dist1
decl_stmt|,
name|dist2
decl_stmt|,
name|span
decl_stmt|;
if|if
condition|(
name|n_edges
operator|==
literal|6
condition|)
block|{
name|edge1
operator|=
name|edges
expr_stmt|;
name|edge2
operator|=
name|edges
operator|+
literal|2
expr_stmt|;
name|edge3
operator|=
name|edges
operator|+
literal|4
expr_stmt|;
block|}
else|else
block|{
name|edge1
operator|=
name|edges
operator|+
literal|1
expr_stmt|;
name|edge2
operator|=
name|edges
operator|+
literal|5
expr_stmt|;
name|edge3
operator|=
name|edges
operator|+
literal|9
expr_stmt|;
block|}
name|dist1
operator|=
name|edge2
operator|->
name|opos
operator|-
name|edge1
operator|->
name|opos
expr_stmt|;
name|dist2
operator|=
name|edge3
operator|->
name|opos
operator|-
name|edge2
operator|->
name|opos
expr_stmt|;
name|span
operator|=
name|dist1
operator|-
name|dist2
expr_stmt|;
if|if
condition|(
name|span
operator|<
literal|0
condition|)
name|span
operator|=
operator|-
name|span
expr_stmt|;
if|if
condition|(
name|edge1
operator|->
name|link
operator|==
name|edge1
operator|+
literal|1
operator|&&
name|edge2
operator|->
name|link
operator|==
name|edge2
operator|+
literal|1
operator|&&
name|edge3
operator|->
name|link
operator|==
name|edge3
operator|+
literal|1
operator|&&
name|span
operator|<
literal|8
condition|)
block|{
name|delta
operator|=
name|edge3
operator|->
name|pos
operator|-
operator|(
literal|2
operator|*
name|edge2
operator|->
name|pos
operator|-
name|edge1
operator|->
name|pos
operator|)
expr_stmt|;
name|edge3
operator|->
name|pos
operator|-=
name|delta
expr_stmt|;
if|if
condition|(
name|edge3
operator|->
name|link
condition|)
name|edge3
operator|->
name|link
operator|->
name|pos
operator|-=
name|delta
expr_stmt|;
comment|/* move the serifs along with the stem */
if|if
condition|(
name|n_edges
operator|==
literal|12
condition|)
block|{
operator|(
name|edges
operator|+
literal|8
operator|)
operator|->
name|pos
operator|-=
name|delta
expr_stmt|;
operator|(
name|edges
operator|+
literal|11
operator|)
operator|->
name|pos
operator|-=
name|delta
expr_stmt|;
block|}
name|edge3
operator|->
name|flags
operator||=
name|AF_EDGE_DONE
expr_stmt|;
if|if
condition|(
name|edge3
operator|->
name|link
condition|)
name|edge3
operator|->
name|link
operator|->
name|flags
operator||=
name|AF_EDGE_DONE
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|skipped
condition|)
return|return;
comment|/*      *  now hint the remaining edges (serifs and single) in order      *  to complete our processing      */
for|for
control|(
name|edge
operator|=
name|edges
init|;
name|edge
operator|<
name|edge_limit
condition|;
name|edge
operator|++
control|)
block|{
if|if
condition|(
name|edge
operator|->
name|flags
operator|&
name|AF_EDGE_DONE
condition|)
continue|continue;
if|if
condition|(
name|edge
operator|->
name|serif
condition|)
block|{
name|af_cjk_align_serif_edge
argument_list|(
name|hints
argument_list|,
name|edge
operator|->
name|serif
argument_list|,
name|edge
argument_list|)
expr_stmt|;
name|edge
operator|->
name|flags
operator||=
name|AF_EDGE_DONE
expr_stmt|;
name|skipped
operator|--
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|skipped
condition|)
return|return;
for|for
control|(
name|edge
operator|=
name|edges
init|;
name|edge
operator|<
name|edge_limit
condition|;
name|edge
operator|++
control|)
block|{
name|AF_Edge
name|before
decl_stmt|,
name|after
decl_stmt|;
if|if
condition|(
name|edge
operator|->
name|flags
operator|&
name|AF_EDGE_DONE
condition|)
continue|continue;
name|before
operator|=
name|after
operator|=
name|edge
expr_stmt|;
while|while
condition|(
operator|--
name|before
operator|>=
name|edges
condition|)
if|if
condition|(
name|before
operator|->
name|flags
operator|&
name|AF_EDGE_DONE
condition|)
break|break;
while|while
condition|(
operator|++
name|after
operator|<
name|edge_limit
condition|)
if|if
condition|(
name|after
operator|->
name|flags
operator|&
name|AF_EDGE_DONE
condition|)
break|break;
if|if
condition|(
name|before
operator|>=
name|edges
operator|||
name|after
operator|<
name|edge_limit
condition|)
block|{
if|if
condition|(
name|before
operator|<
name|edges
condition|)
name|af_cjk_align_serif_edge
argument_list|(
name|hints
argument_list|,
name|after
argument_list|,
name|edge
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|after
operator|>=
name|edge_limit
condition|)
name|af_cjk_align_serif_edge
argument_list|(
name|hints
argument_list|,
name|before
argument_list|,
name|edge
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|after
operator|->
name|fpos
operator|==
name|before
operator|->
name|fpos
condition|)
name|edge
operator|->
name|pos
operator|=
name|before
operator|->
name|pos
expr_stmt|;
else|else
name|edge
operator|->
name|pos
operator|=
name|before
operator|->
name|pos
operator|+
name|FT_MulDiv
argument_list|(
name|edge
operator|->
name|fpos
operator|-
name|before
operator|->
name|fpos
argument_list|,
name|after
operator|->
name|pos
operator|-
name|before
operator|->
name|pos
argument_list|,
name|after
operator|->
name|fpos
operator|-
name|before
operator|->
name|fpos
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|af_cjk_align_edge_points
name|af_cjk_align_edge_points
parameter_list|(
name|AF_GlyphHints
name|hints
parameter_list|,
name|AF_Dimension
name|dim
parameter_list|)
block|{
name|AF_AxisHints
name|axis
init|=
operator|&
name|hints
operator|->
name|axis
index|[
name|dim
index|]
decl_stmt|;
name|AF_Edge
name|edges
init|=
name|axis
operator|->
name|edges
decl_stmt|;
name|AF_Edge
name|edge_limit
init|=
name|edges
operator|+
name|axis
operator|->
name|num_edges
decl_stmt|;
name|AF_Edge
name|edge
decl_stmt|;
name|FT_Bool
name|snapping
decl_stmt|;
name|snapping
operator|=
name|FT_BOOL
argument_list|(
operator|(
name|dim
operator|==
name|AF_DIMENSION_HORZ
operator|&&
name|AF_LATIN_HINTS_DO_HORZ_SNAP
argument_list|(
name|hints
argument_list|)
operator|)
operator|||
operator|(
name|dim
operator|==
name|AF_DIMENSION_VERT
operator|&&
name|AF_LATIN_HINTS_DO_VERT_SNAP
argument_list|(
name|hints
argument_list|)
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|edge
operator|=
name|edges
init|;
name|edge
operator|<
name|edge_limit
condition|;
name|edge
operator|++
control|)
block|{
comment|/* move the points of each segment     */
comment|/* in each edge to the edge's position */
name|AF_Segment
name|seg
init|=
name|edge
operator|->
name|first
decl_stmt|;
if|if
condition|(
name|snapping
condition|)
block|{
do|do
block|{
name|AF_Point
name|point
init|=
name|seg
operator|->
name|first
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|dim
operator|==
name|AF_DIMENSION_HORZ
condition|)
block|{
name|point
operator|->
name|x
operator|=
name|edge
operator|->
name|pos
expr_stmt|;
name|point
operator|->
name|flags
operator||=
name|AF_FLAG_TOUCH_X
expr_stmt|;
block|}
else|else
block|{
name|point
operator|->
name|y
operator|=
name|edge
operator|->
name|pos
expr_stmt|;
name|point
operator|->
name|flags
operator||=
name|AF_FLAG_TOUCH_Y
expr_stmt|;
block|}
if|if
condition|(
name|point
operator|==
name|seg
operator|->
name|last
condition|)
break|break;
name|point
operator|=
name|point
operator|->
name|next
expr_stmt|;
block|}
name|seg
operator|=
name|seg
operator|->
name|edge_next
expr_stmt|;
block|}
do|while
condition|(
name|seg
operator|!=
name|edge
operator|->
name|first
condition|)
do|;
block|}
else|else
block|{
name|FT_Pos
name|delta
init|=
name|edge
operator|->
name|pos
operator|-
name|edge
operator|->
name|opos
decl_stmt|;
do|do
block|{
name|AF_Point
name|point
init|=
name|seg
operator|->
name|first
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|dim
operator|==
name|AF_DIMENSION_HORZ
condition|)
block|{
name|point
operator|->
name|x
operator|+=
name|delta
expr_stmt|;
name|point
operator|->
name|flags
operator||=
name|AF_FLAG_TOUCH_X
expr_stmt|;
block|}
else|else
block|{
name|point
operator|->
name|y
operator|+=
name|delta
expr_stmt|;
name|point
operator|->
name|flags
operator||=
name|AF_FLAG_TOUCH_Y
expr_stmt|;
block|}
if|if
condition|(
name|point
operator|==
name|seg
operator|->
name|last
condition|)
break|break;
name|point
operator|=
name|point
operator|->
name|next
expr_stmt|;
block|}
name|seg
operator|=
name|seg
operator|->
name|edge_next
expr_stmt|;
block|}
do|while
condition|(
name|seg
operator|!=
name|edge
operator|->
name|first
condition|)
do|;
block|}
block|}
block|}
end_function
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|af_cjk_hints_apply
argument_list|(
argument|AF_GlyphHints    hints
argument_list|,
argument|FT_Outline*      outline
argument_list|,
argument|AF_LatinMetrics  metrics
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
decl_stmt|;
name|int
name|dim
decl_stmt|;
name|FT_UNUSED
argument_list|(
name|metrics
argument_list|)
expr_stmt|;
name|error
operator|=
name|af_glyph_hints_reload
argument_list|(
name|hints
argument_list|,
name|outline
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
comment|/* analyze glyph outline */
if|if
condition|(
name|AF_HINTS_DO_HORIZONTAL
argument_list|(
name|hints
argument_list|)
condition|)
block|{
name|error
operator|=
name|af_cjk_hints_detect_features
argument_list|(
name|hints
argument_list|,
name|AF_DIMENSION_HORZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|AF_HINTS_DO_VERTICAL
argument_list|(
name|hints
argument_list|)
condition|)
block|{
name|error
operator|=
name|af_cjk_hints_detect_features
argument_list|(
name|hints
argument_list|,
name|AF_DIMENSION_VERT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
block|}
comment|/* grid-fit the outline */
for|for
control|(
name|dim
operator|=
literal|0
init|;
name|dim
operator|<
name|AF_DIMENSION_MAX
condition|;
name|dim
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|dim
operator|==
name|AF_DIMENSION_HORZ
operator|&&
name|AF_HINTS_DO_HORIZONTAL
argument_list|(
name|hints
argument_list|)
operator|)
operator|||
operator|(
name|dim
operator|==
name|AF_DIMENSION_VERT
operator|&&
name|AF_HINTS_DO_VERTICAL
argument_list|(
name|hints
argument_list|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|AF_USE_WARPER
if|if
condition|(
name|dim
operator|==
name|AF_DIMENSION_HORZ
operator|&&
name|metrics
operator|->
name|root
operator|.
name|scaler
operator|.
name|render_mode
operator|==
name|FT_RENDER_MODE_NORMAL
condition|)
block|{
name|AF_WarperRec
name|warper
decl_stmt|;
name|FT_Fixed
name|scale
decl_stmt|;
name|FT_Pos
name|delta
decl_stmt|;
name|af_warper_compute
argument_list|(
operator|&
name|warper
argument_list|,
name|hints
argument_list|,
name|dim
argument_list|,
operator|&
name|scale
argument_list|,
operator|&
name|delta
argument_list|)
expr_stmt|;
name|af_glyph_hints_scale_dim
argument_list|(
name|hints
argument_list|,
name|dim
argument_list|,
name|scale
argument_list|,
name|delta
argument_list|)
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
comment|/* AF_USE_WARPER */
name|af_cjk_hint_edges
argument_list|(
name|hints
argument_list|,
operator|(
name|AF_Dimension
operator|)
name|dim
argument_list|)
expr_stmt|;
name|af_cjk_align_edge_points
argument_list|(
name|hints
argument_list|,
operator|(
name|AF_Dimension
operator|)
name|dim
argument_list|)
expr_stmt|;
name|af_glyph_hints_align_strong_points
argument_list|(
name|hints
argument_list|,
operator|(
name|AF_Dimension
operator|)
name|dim
argument_list|)
expr_stmt|;
name|af_glyph_hints_align_weak_points
argument_list|(
name|hints
argument_list|,
operator|(
name|AF_Dimension
operator|)
name|dim
argument_list|)
expr_stmt|;
block|}
block|}
if|#
directive|if
literal|0
block|af_glyph_hints_dump_points( hints );     af_glyph_hints_dump_segments( hints );     af_glyph_hints_dump_edges( hints );
endif|#
directive|endif
name|af_glyph_hints_save
argument_list|(
name|hints
argument_list|,
name|outline
argument_list|)
expr_stmt|;
name|Exit
label|:
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****                C J K   S C R I P T   C L A S S                *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_decl_stmt
DECL|variable|af_cjk_uniranges
specifier|static
specifier|const
name|AF_Script_UniRangeRec
name|af_cjk_uniranges
index|[]
init|=
block|{
if|#
directive|if
literal|0
block|AF_UNIRANGE_REC(  0x0100UL,  0xFFFFUL ),
comment|/* why this? */
endif|#
directive|endif
name|AF_UNIRANGE_REC
argument_list|(
literal|0x2E80UL
argument_list|,
literal|0x2EFFUL
argument_list|)
block|,
comment|/* CJK Radicals Supplement                 */
name|AF_UNIRANGE_REC
argument_list|(
literal|0x2F00UL
argument_list|,
literal|0x2FDFUL
argument_list|)
block|,
comment|/* Kangxi Radicals                         */
name|AF_UNIRANGE_REC
argument_list|(
literal|0x3000UL
argument_list|,
literal|0x303FUL
argument_list|)
block|,
comment|/* CJK Symbols and Punctuation             */
name|AF_UNIRANGE_REC
argument_list|(
literal|0x3040UL
argument_list|,
literal|0x309FUL
argument_list|)
block|,
comment|/* Hiragana                                */
name|AF_UNIRANGE_REC
argument_list|(
literal|0x30A0UL
argument_list|,
literal|0x30FFUL
argument_list|)
block|,
comment|/* Katakana                                */
name|AF_UNIRANGE_REC
argument_list|(
literal|0x3100UL
argument_list|,
literal|0x312FUL
argument_list|)
block|,
comment|/* Bopomofo                                */
name|AF_UNIRANGE_REC
argument_list|(
literal|0x3130UL
argument_list|,
literal|0x318FUL
argument_list|)
block|,
comment|/* Hangul Compatibility Jamo               */
name|AF_UNIRANGE_REC
argument_list|(
literal|0x31A0UL
argument_list|,
literal|0x31BFUL
argument_list|)
block|,
comment|/* Bopomofo Extended                       */
name|AF_UNIRANGE_REC
argument_list|(
literal|0x31C0UL
argument_list|,
literal|0x31EFUL
argument_list|)
block|,
comment|/* CJK Strokes                             */
name|AF_UNIRANGE_REC
argument_list|(
literal|0x31F0UL
argument_list|,
literal|0x31FFUL
argument_list|)
block|,
comment|/* Katakana Phonetic Extensions            */
name|AF_UNIRANGE_REC
argument_list|(
literal|0x3200UL
argument_list|,
literal|0x32FFUL
argument_list|)
block|,
comment|/* Enclosed CJK Letters and Months         */
name|AF_UNIRANGE_REC
argument_list|(
literal|0x3300UL
argument_list|,
literal|0x33FFUL
argument_list|)
block|,
comment|/* CJK Compatibility                       */
name|AF_UNIRANGE_REC
argument_list|(
literal|0x3400UL
argument_list|,
literal|0x4DBFUL
argument_list|)
block|,
comment|/* CJK Unified Ideographs Extension A      */
name|AF_UNIRANGE_REC
argument_list|(
literal|0x4DC0UL
argument_list|,
literal|0x4DFFUL
argument_list|)
block|,
comment|/* Yijing Hexagram Symbols                 */
name|AF_UNIRANGE_REC
argument_list|(
literal|0x4E00UL
argument_list|,
literal|0x9FFFUL
argument_list|)
block|,
comment|/* CJK Unified Ideographs                  */
name|AF_UNIRANGE_REC
argument_list|(
literal|0xF900UL
argument_list|,
literal|0xFAFFUL
argument_list|)
block|,
comment|/* CJK Compatibility Ideographs            */
name|AF_UNIRANGE_REC
argument_list|(
literal|0xFE30UL
argument_list|,
literal|0xFE4FUL
argument_list|)
block|,
comment|/* CJK Compatibility Forms                 */
name|AF_UNIRANGE_REC
argument_list|(
literal|0xFF00UL
argument_list|,
literal|0xFFEFUL
argument_list|)
block|,
comment|/* Halfwidth and Fullwidth Forms           */
name|AF_UNIRANGE_REC
argument_list|(
literal|0x20000UL
argument_list|,
literal|0x2A6DFUL
argument_list|)
block|,
comment|/* CJK Unified Ideographs Extension B      */
name|AF_UNIRANGE_REC
argument_list|(
literal|0x2F800UL
argument_list|,
literal|0x2FA1FUL
argument_list|)
block|,
comment|/* CJK Compatibility Ideographs Supplement */
name|AF_UNIRANGE_REC
argument_list|(
literal|0UL
argument_list|,
literal|0UL
argument_list|)
block|}
decl_stmt|;
end_decl_stmt
begin_macro
name|AF_DEFINE_SCRIPT_CLASS
argument_list|(
argument|af_cjk_script_class
argument_list|,
argument|AF_SCRIPT_CJK
argument_list|,
argument|af_cjk_uniranges
argument_list|,
argument|sizeof( AF_LatinMetricsRec )
argument_list|,
argument|(AF_Script_InitMetricsFunc) af_cjk_metrics_init
argument_list|,
argument|(AF_Script_ScaleMetricsFunc)af_cjk_metrics_scale
argument_list|,
argument|(AF_Script_DoneMetricsFunc) NULL
argument_list|,
argument|(AF_Script_InitHintsFunc)   af_cjk_hints_init
argument_list|,
argument|(AF_Script_ApplyHintsFunc)  af_cjk_hints_apply
argument_list|)
end_macro
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* !AF_CONFIG_OPTION_CJK */
end_comment
begin_decl_stmt
specifier|static
specifier|const
name|AF_Script_UniRangeRec
name|af_cjk_uniranges
index|[]
init|=
block|{
name|AF_UNIRANGE_REC
argument_list|(
literal|0UL
argument_list|,
literal|0UL
argument_list|)
block|}
decl_stmt|;
end_decl_stmt
begin_macro
name|AF_DEFINE_SCRIPT_CLASS
argument_list|(
argument|af_cjk_script_class
argument_list|,
argument|AF_SCRIPT_CJK
argument_list|,
argument|af_cjk_uniranges
argument_list|,
argument|sizeof( AF_LatinMetricsRec )
argument_list|,
argument|(AF_Script_InitMetricsFunc) NULL
argument_list|,
argument|(AF_Script_ScaleMetricsFunc)NULL
argument_list|,
argument|(AF_Script_DoneMetricsFunc) NULL
argument_list|,
argument|(AF_Script_InitHintsFunc)   NULL
argument_list|,
argument|(AF_Script_ApplyHintsFunc)  NULL
argument_list|)
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* !AF_CONFIG_OPTION_CJK */
end_comment
begin_comment
comment|/* END */
end_comment
end_unit
