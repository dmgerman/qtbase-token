begin_unit
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  hbshim.c                                                               */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*    HarfBuzz interface for accessing OpenType features (body).           */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  Copyright 2013-2015 by                                                 */
end_comment
begin_comment
comment|/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  This file is part of the FreeType project, and may only be used,       */
end_comment
begin_comment
comment|/*  modified, and distributed under the terms of the FreeType project      */
end_comment
begin_comment
comment|/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
end_comment
begin_comment
comment|/*  this file you indicate that you have read the license and              */
end_comment
begin_comment
comment|/*  understand and accept it fully.                                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<ft2build.h>
end_include
begin_include
include|#
directive|include
include|FT_FREETYPE_H
end_include
begin_include
include|#
directive|include
file|"afglobal.h"
end_include
begin_include
include|#
directive|include
file|"aftypes.h"
end_include
begin_include
include|#
directive|include
file|"hbshim.h"
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|FT_CONFIG_OPTION_USE_HARFBUZZ
end_ifdef
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
end_comment
begin_comment
comment|/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
end_comment
begin_comment
comment|/* messages during execution.                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_undef
DECL|macro|FT_COMPONENT
undef|#
directive|undef
name|FT_COMPONENT
end_undef
begin_define
DECL|macro|FT_COMPONENT
define|#
directive|define
name|FT_COMPONENT
value|trace_afharfbuzz
end_define
begin_comment
comment|/*    * We use `sets' (in the HarfBuzz sense, which comes quite near to the    * usual mathematical meaning) to manage both lookups and glyph indices.    *    * 1. For each coverage, collect lookup IDs in a set.  Note that an    *    auto-hinter `coverage' is represented by one `feature', and a    *    feature consists of an arbitrary number of (font specific) `lookup's    *    that actually do the mapping job.  Please check the OpenType    *    specification for more details on features and lookups.    *    * 2. Create glyph ID sets from the corresponding lookup sets.    *    * 3. The glyph set corresponding to AF_COVERAGE_DEFAULT is computed    *    with all lookups specific to the OpenType script activated.  It    *    relies on the order of AF_DEFINE_STYLE_CLASS entries so that    *    special coverages (like `oldstyle figures') don't get overwritten.    *    */
end_comment
begin_comment
comment|/* load coverage tags */
end_comment
begin_undef
DECL|macro|COVERAGE
undef|#
directive|undef
name|COVERAGE
end_undef
begin_define
DECL|macro|COVERAGE
define|#
directive|define
name|COVERAGE
parameter_list|(
name|name
parameter_list|,
name|NAME
parameter_list|,
name|description
parameter_list|,             \
name|tag1
parameter_list|,
name|tag2
parameter_list|,
name|tag3
parameter_list|,
name|tag4
parameter_list|)
define|\
value|static const hb_tag_t  name ## _coverage[] = \           {                                            \             HB_TAG( tag1, tag2, tag3, tag4 ),          \             HB_TAG_NONE                                \           };
end_define
begin_include
include|#
directive|include
file|"afcover.h"
end_include
begin_comment
comment|/* define mapping between coverage tags and AF_Coverage */
end_comment
begin_undef
DECL|macro|COVERAGE
undef|#
directive|undef
name|COVERAGE
end_undef
begin_define
DECL|macro|COVERAGE
define|#
directive|define
name|COVERAGE
parameter_list|(
name|name
parameter_list|,
name|NAME
parameter_list|,
name|description
parameter_list|, \
name|tag1
parameter_list|,
name|tag2
parameter_list|,
name|tag3
parameter_list|,
name|tag4
parameter_list|)
define|\
value|name ## _coverage,
end_define
begin_decl_stmt
DECL|variable|coverages
specifier|static
specifier|const
name|hb_tag_t
modifier|*
name|coverages
index|[]
init|=
block|{
include|#
directive|include
file|"afcover.h"
name|NULL
comment|/* AF_COVERAGE_DEFAULT */
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* load HarfBuzz script tags */
end_comment
begin_undef
DECL|macro|SCRIPT
undef|#
directive|undef
name|SCRIPT
end_undef
begin_define
DECL|macro|SCRIPT
define|#
directive|define
name|SCRIPT
parameter_list|(
name|s
parameter_list|,
name|S
parameter_list|,
name|d
parameter_list|,
name|h
parameter_list|,
name|sc1
parameter_list|,
name|sc2
parameter_list|,
name|sc3
parameter_list|)
value|h,
end_define
begin_decl_stmt
DECL|variable|scripts
specifier|static
specifier|const
name|hb_script_t
name|scripts
index|[]
init|=
block|{
include|#
directive|include
file|"afscript.h"
block|}
decl_stmt|;
end_decl_stmt
begin_function
name|FT_Error
DECL|function|af_get_coverage
name|af_get_coverage
parameter_list|(
name|AF_FaceGlobals
name|globals
parameter_list|,
name|AF_StyleClass
name|style_class
parameter_list|,
name|FT_UShort
modifier|*
name|gstyles
parameter_list|)
block|{
name|hb_face_t
modifier|*
name|face
decl_stmt|;
name|hb_set_t
modifier|*
name|gsub_lookups
decl_stmt|;
comment|/* GSUB lookups for a given script */
name|hb_set_t
modifier|*
name|gsub_glyphs
decl_stmt|;
comment|/* glyphs covered by GSUB lookups  */
name|hb_set_t
modifier|*
name|gpos_lookups
decl_stmt|;
comment|/* GPOS lookups for a given script */
name|hb_set_t
modifier|*
name|gpos_glyphs
decl_stmt|;
comment|/* glyphs covered by GPOS lookups  */
name|hb_script_t
name|script
decl_stmt|;
specifier|const
name|hb_tag_t
modifier|*
name|coverage_tags
decl_stmt|;
name|hb_tag_t
name|script_tags
index|[]
init|=
block|{
name|HB_TAG_NONE
block|,
name|HB_TAG_NONE
block|,
name|HB_TAG_NONE
block|,
name|HB_TAG_NONE
block|}
decl_stmt|;
name|hb_codepoint_t
name|idx
decl_stmt|;
ifdef|#
directive|ifdef
name|FT_DEBUG_LEVEL_TRACE
name|int
name|count
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|globals
operator|||
operator|!
name|style_class
operator|||
operator|!
name|gstyles
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_Argument
argument_list|)
return|;
name|face
operator|=
name|hb_font_get_face
argument_list|(
name|globals
operator|->
name|hb_font
argument_list|)
expr_stmt|;
name|gsub_lookups
operator|=
name|hb_set_create
argument_list|()
expr_stmt|;
name|gsub_glyphs
operator|=
name|hb_set_create
argument_list|()
expr_stmt|;
name|gpos_lookups
operator|=
name|hb_set_create
argument_list|()
expr_stmt|;
name|gpos_glyphs
operator|=
name|hb_set_create
argument_list|()
expr_stmt|;
name|coverage_tags
operator|=
name|coverages
index|[
name|style_class
operator|->
name|coverage
index|]
expr_stmt|;
name|script
operator|=
name|scripts
index|[
name|style_class
operator|->
name|script
index|]
expr_stmt|;
comment|/* Convert a HarfBuzz script tag into the corresponding OpenType */
comment|/* tag or tags -- some Indic scripts like Devanagari have an old */
comment|/* and a new set of features.                                    */
name|hb_ot_tags_from_script
argument_list|(
name|script
argument_list|,
operator|&
name|script_tags
index|[
literal|0
index|]
argument_list|,
operator|&
name|script_tags
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* `hb_ot_tags_from_script' usually returns HB_OT_TAG_DEFAULT_SCRIPT */
comment|/* as the second tag.  We change that to HB_TAG_NONE except for the  */
comment|/* default script.                                                   */
if|if
condition|(
name|style_class
operator|->
name|script
operator|==
name|globals
operator|->
name|module
operator|->
name|default_script
operator|&&
name|style_class
operator|->
name|coverage
operator|==
name|AF_COVERAGE_DEFAULT
condition|)
block|{
if|if
condition|(
name|script_tags
index|[
literal|0
index|]
operator|==
name|HB_TAG_NONE
condition|)
name|script_tags
index|[
literal|0
index|]
operator|=
name|HB_OT_TAG_DEFAULT_SCRIPT
expr_stmt|;
else|else
block|{
if|if
condition|(
name|script_tags
index|[
literal|1
index|]
operator|==
name|HB_TAG_NONE
condition|)
name|script_tags
index|[
literal|1
index|]
operator|=
name|HB_OT_TAG_DEFAULT_SCRIPT
expr_stmt|;
elseif|else
if|if
condition|(
name|script_tags
index|[
literal|1
index|]
operator|!=
name|HB_OT_TAG_DEFAULT_SCRIPT
condition|)
name|script_tags
index|[
literal|2
index|]
operator|=
name|HB_OT_TAG_DEFAULT_SCRIPT
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|script_tags
index|[
literal|1
index|]
operator|==
name|HB_OT_TAG_DEFAULT_SCRIPT
condition|)
name|script_tags
index|[
literal|1
index|]
operator|=
name|HB_TAG_NONE
expr_stmt|;
block|}
name|hb_ot_layout_collect_lookups
argument_list|(
name|face
argument_list|,
name|HB_OT_TAG_GSUB
argument_list|,
name|script_tags
argument_list|,
name|NULL
argument_list|,
name|coverage_tags
argument_list|,
name|gsub_lookups
argument_list|)
expr_stmt|;
if|if
condition|(
name|hb_set_is_empty
argument_list|(
name|gsub_lookups
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
comment|/* nothing to do */
name|hb_ot_layout_collect_lookups
argument_list|(
name|face
argument_list|,
name|HB_OT_TAG_GPOS
argument_list|,
name|script_tags
argument_list|,
name|NULL
argument_list|,
name|coverage_tags
argument_list|,
name|gpos_lookups
argument_list|)
expr_stmt|;
name|FT_TRACE4
argument_list|(
operator|(
literal|"GSUB lookups (style `%s'):\n"
literal|" "
operator|,
name|af_style_names
index|[
name|style_class
operator|->
name|style
index|]
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FT_DEBUG_LEVEL_TRACE
name|count
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|idx
operator|=
name|HB_SET_VALUE_INVALID
init|;
name|hb_set_next
argument_list|(
name|gsub_lookups
argument_list|,
operator|&
name|idx
argument_list|)
condition|;
control|)
block|{
ifdef|#
directive|ifdef
name|FT_DEBUG_LEVEL_TRACE
name|FT_TRACE4
argument_list|(
operator|(
literal|" %d"
operator|,
name|idx
operator|)
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* get output coverage of GSUB feature */
name|hb_ot_layout_lookup_collect_glyphs
argument_list|(
name|face
argument_list|,
name|HB_OT_TAG_GSUB
argument_list|,
name|idx
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|gsub_glyphs
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|FT_DEBUG_LEVEL_TRACE
if|if
condition|(
operator|!
name|count
condition|)
name|FT_TRACE4
argument_list|(
operator|(
literal|" (none)"
operator|)
argument_list|)
expr_stmt|;
name|FT_TRACE4
argument_list|(
operator|(
literal|"\n\n"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|FT_TRACE4
argument_list|(
operator|(
literal|"GPOS lookups (style `%s'):\n"
literal|" "
operator|,
name|af_style_names
index|[
name|style_class
operator|->
name|style
index|]
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FT_DEBUG_LEVEL_TRACE
name|count
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|idx
operator|=
name|HB_SET_VALUE_INVALID
init|;
name|hb_set_next
argument_list|(
name|gpos_lookups
argument_list|,
operator|&
name|idx
argument_list|)
condition|;
control|)
block|{
ifdef|#
directive|ifdef
name|FT_DEBUG_LEVEL_TRACE
name|FT_TRACE4
argument_list|(
operator|(
literal|" %d"
operator|,
name|idx
operator|)
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* get input coverage of GPOS feature */
name|hb_ot_layout_lookup_collect_glyphs
argument_list|(
name|face
argument_list|,
name|HB_OT_TAG_GPOS
argument_list|,
name|idx
argument_list|,
name|NULL
argument_list|,
name|gpos_glyphs
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|FT_DEBUG_LEVEL_TRACE
if|if
condition|(
operator|!
name|count
condition|)
name|FT_TRACE4
argument_list|(
operator|(
literal|" (none)"
operator|)
argument_list|)
expr_stmt|;
name|FT_TRACE4
argument_list|(
operator|(
literal|"\n\n"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*      * We now check whether we can construct blue zones, using glyphs      * covered by the feature only.  In case there is not a single zone      * (this is, not a single character is covered), we skip this coverage.      *      */
if|if
condition|(
name|style_class
operator|->
name|coverage
operator|!=
name|AF_COVERAGE_DEFAULT
condition|)
block|{
name|AF_Blue_Stringset
name|bss
init|=
name|style_class
operator|->
name|blue_stringset
decl_stmt|;
specifier|const
name|AF_Blue_StringRec
modifier|*
name|bs
init|=
operator|&
name|af_blue_stringsets
index|[
name|bss
index|]
decl_stmt|;
name|FT_Bool
name|found
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|bs
operator|->
name|string
operator|!=
name|AF_BLUE_STRING_MAX
condition|;
name|bs
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|p
init|=
operator|&
name|af_blue_strings
index|[
name|bs
operator|->
name|string
index|]
decl_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
name|hb_codepoint_t
name|ch
decl_stmt|;
name|GET_UTF8_CHAR
argument_list|(
name|ch
argument_list|,
name|p
argument_list|)
expr_stmt|;
for|for
control|(
name|idx
operator|=
name|HB_SET_VALUE_INVALID
init|;
name|hb_set_next
argument_list|(
name|gsub_lookups
argument_list|,
operator|&
name|idx
argument_list|)
condition|;
control|)
block|{
name|hb_codepoint_t
name|gidx
init|=
name|FT_Get_Char_Index
argument_list|(
name|globals
operator|->
name|face
argument_list|,
name|ch
argument_list|)
decl_stmt|;
if|if
condition|(
name|hb_ot_layout_lookup_would_substitute
argument_list|(
name|face
argument_list|,
name|idx
argument_list|,
operator|&
name|gidx
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|FT_TRACE4
argument_list|(
operator|(
literal|"  no blue characters found; style skipped\n"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
comment|/*      * Various OpenType features might use the same glyphs at different      * vertical positions; for example, superscript and subscript glyphs      * could be the same.  However, the auto-hinter is completely      * agnostic of OpenType features after the feature analysis has been      * completed: The engine then simply receives a glyph index and returns a      * hinted and usually rendered glyph.      *      * Consider the superscript feature of font `pala.ttf': Some of the      * glyphs are `real', this is, they have a zero vertical offset, but      * most of them are small caps glyphs shifted up to the superscript      * position (this is, the `sups' feature is present in both the GSUB and      * GPOS tables).  The code for blue zones computation actually uses a      * feature's y offset so that the `real' glyphs get correct hints.  But      * later on it is impossible to decide whether a glyph index belongs to,      * say, the small caps or superscript feature.      *      * For this reason, we don't assign a style to a glyph if the current      * feature covers the glyph in both the GSUB and the GPOS tables.  This      * is quite a broad condition, assuming that      *      *   (a) glyphs that get used in multiple features are present in a      *       feature without vertical shift,      *      * and      *      *   (b) a feature's GPOS data really moves the glyph vertically.      *      * Not fulfilling condition (a) makes a font larger; it would also      * reduce the number of glyphs that could be addressed directly without      * using OpenType features, so this assumption is rather strong.      *      * Condition (b) is much weaker, and there might be glyphs which get      * missed.  However, the OpenType features we are going to handle are      * primarily located in GSUB, and HarfBuzz doesn't provide an API to      * directly get the necessary information from the GPOS table.  A      * possible solution might be to directly parse the GPOS table to find      * out whether a glyph gets shifted vertically, but this is something I      * would like to avoid if not really necessary.      *      * Note that we don't follow this logic for the default coverage.      * Complex scripts like Devanagari have mandatory GPOS features to      * position many glyph elements, using mark-to-base or mark-to-ligature      * tables; the number of glyphs missed due to condition (b) would be far      * too large.      *      */
if|if
condition|(
name|style_class
operator|->
name|coverage
operator|!=
name|AF_COVERAGE_DEFAULT
condition|)
name|hb_set_subtract
argument_list|(
name|gsub_glyphs
argument_list|,
name|gpos_glyphs
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FT_DEBUG_LEVEL_TRACE
name|FT_TRACE4
argument_list|(
operator|(
literal|"  glyphs without GPOS data (`*' means already assigned)"
operator|)
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|idx
operator|=
name|HB_SET_VALUE_INVALID
init|;
name|hb_set_next
argument_list|(
name|gsub_glyphs
argument_list|,
operator|&
name|idx
argument_list|)
condition|;
control|)
block|{
ifdef|#
directive|ifdef
name|FT_DEBUG_LEVEL_TRACE
if|if
condition|(
operator|!
operator|(
name|count
operator|%
literal|10
operator|)
condition|)
name|FT_TRACE4
argument_list|(
operator|(
literal|"\n"
literal|"   "
operator|)
argument_list|)
expr_stmt|;
name|FT_TRACE4
argument_list|(
operator|(
literal|" %d"
operator|,
name|idx
operator|)
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* glyph indices returned by `hb_ot_layout_lookup_collect_glyphs' */
comment|/* can be arbitrary: some fonts use fake indices for processing   */
comment|/* internal to GSUB or GPOS, which is fully valid                 */
if|if
condition|(
name|idx
operator|>=
operator|(
name|hb_codepoint_t
operator|)
name|globals
operator|->
name|glyph_count
condition|)
continue|continue;
if|if
condition|(
name|gstyles
index|[
name|idx
index|]
operator|==
name|AF_STYLE_UNASSIGNED
condition|)
name|gstyles
index|[
name|idx
index|]
operator|=
operator|(
name|FT_UShort
operator|)
name|style_class
operator|->
name|style
expr_stmt|;
ifdef|#
directive|ifdef
name|FT_DEBUG_LEVEL_TRACE
else|else
name|FT_TRACE4
argument_list|(
operator|(
literal|"*"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|FT_DEBUG_LEVEL_TRACE
if|if
condition|(
operator|!
name|count
condition|)
name|FT_TRACE4
argument_list|(
operator|(
literal|"\n"
literal|"    (none)"
operator|)
argument_list|)
expr_stmt|;
name|FT_TRACE4
argument_list|(
operator|(
literal|"\n\n"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|Exit
label|:
name|hb_set_destroy
argument_list|(
name|gsub_lookups
argument_list|)
expr_stmt|;
name|hb_set_destroy
argument_list|(
name|gsub_glyphs
argument_list|)
expr_stmt|;
name|hb_set_destroy
argument_list|(
name|gpos_lookups
argument_list|)
expr_stmt|;
name|hb_set_destroy
argument_list|(
name|gpos_glyphs
argument_list|)
expr_stmt|;
return|return
name|FT_Err_Ok
return|;
block|}
end_function
begin_comment
comment|/* construct HarfBuzz features */
end_comment
begin_undef
DECL|macro|COVERAGE
undef|#
directive|undef
name|COVERAGE
end_undef
begin_define
DECL|macro|COVERAGE
define|#
directive|define
name|COVERAGE
parameter_list|(
name|name
parameter_list|,
name|NAME
parameter_list|,
name|description
parameter_list|,                \
name|tag1
parameter_list|,
name|tag2
parameter_list|,
name|tag3
parameter_list|,
name|tag4
parameter_list|)
define|\
value|static const hb_feature_t  name ## _feature[] = \           {                                               \             {                                             \               HB_TAG( tag1, tag2, tag3, tag4 ),           \               1, 0, (unsigned int)-1                      \             }                                             \           };
end_define
begin_include
include|#
directive|include
file|"afcover.h"
end_include
begin_comment
comment|/* define mapping between HarfBuzz features and AF_Coverage */
end_comment
begin_undef
DECL|macro|COVERAGE
undef|#
directive|undef
name|COVERAGE
end_undef
begin_define
DECL|macro|COVERAGE
define|#
directive|define
name|COVERAGE
parameter_list|(
name|name
parameter_list|,
name|NAME
parameter_list|,
name|description
parameter_list|, \
name|tag1
parameter_list|,
name|tag2
parameter_list|,
name|tag3
parameter_list|,
name|tag4
parameter_list|)
define|\
value|name ## _feature,
end_define
begin_decl_stmt
DECL|variable|features
specifier|static
specifier|const
name|hb_feature_t
modifier|*
name|features
index|[]
init|=
block|{
include|#
directive|include
file|"afcover.h"
name|NULL
comment|/* AF_COVERAGE_DEFAULT */
block|}
decl_stmt|;
end_decl_stmt
begin_function
name|FT_Error
DECL|function|af_get_char_index
name|af_get_char_index
parameter_list|(
name|AF_StyleMetrics
name|metrics
parameter_list|,
name|FT_ULong
name|charcode
parameter_list|,
name|FT_ULong
modifier|*
name|codepoint
parameter_list|,
name|FT_Long
modifier|*
name|y_offset
parameter_list|)
block|{
name|AF_StyleClass
name|style_class
decl_stmt|;
specifier|const
name|hb_feature_t
modifier|*
name|feature
decl_stmt|;
name|FT_ULong
name|in_idx
decl_stmt|,
name|out_idx
decl_stmt|;
if|if
condition|(
operator|!
name|metrics
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_Argument
argument_list|)
return|;
name|in_idx
operator|=
name|FT_Get_Char_Index
argument_list|(
name|metrics
operator|->
name|globals
operator|->
name|face
argument_list|,
name|charcode
argument_list|)
expr_stmt|;
name|style_class
operator|=
name|metrics
operator|->
name|style_class
expr_stmt|;
name|feature
operator|=
name|features
index|[
name|style_class
operator|->
name|coverage
index|]
expr_stmt|;
if|if
condition|(
name|feature
condition|)
block|{
name|FT_Int
name|upem
init|=
operator|(
name|FT_Int
operator|)
name|metrics
operator|->
name|globals
operator|->
name|face
operator|->
name|units_per_EM
decl_stmt|;
name|hb_font_t
modifier|*
name|font
init|=
name|metrics
operator|->
name|globals
operator|->
name|hb_font
decl_stmt|;
name|hb_buffer_t
modifier|*
name|buf
init|=
name|hb_buffer_create
argument_list|()
decl_stmt|;
name|uint32_t
name|c
init|=
operator|(
name|uint32_t
operator|)
name|charcode
decl_stmt|;
name|hb_glyph_info_t
modifier|*
name|ginfo
decl_stmt|;
name|hb_glyph_position_t
modifier|*
name|gpos
decl_stmt|;
name|unsigned
name|int
name|gcount
decl_stmt|;
comment|/* we shape at a size of units per EM; this means font units */
name|hb_font_set_scale
argument_list|(
name|font
argument_list|,
name|upem
argument_list|,
name|upem
argument_list|)
expr_stmt|;
comment|/* XXX: is this sufficient for a single character of any script? */
name|hb_buffer_set_direction
argument_list|(
name|buf
argument_list|,
name|HB_DIRECTION_LTR
argument_list|)
expr_stmt|;
name|hb_buffer_set_script
argument_list|(
name|buf
argument_list|,
name|scripts
index|[
name|style_class
operator|->
name|script
index|]
argument_list|)
expr_stmt|;
comment|/* we add one character to `buf' ... */
name|hb_buffer_add_utf32
argument_list|(
name|buf
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* ... and apply one feature */
name|hb_shape
argument_list|(
name|font
argument_list|,
name|buf
argument_list|,
name|feature
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ginfo
operator|=
name|hb_buffer_get_glyph_infos
argument_list|(
name|buf
argument_list|,
operator|&
name|gcount
argument_list|)
expr_stmt|;
name|gpos
operator|=
name|hb_buffer_get_glyph_positions
argument_list|(
name|buf
argument_list|,
operator|&
name|gcount
argument_list|)
expr_stmt|;
name|out_idx
operator|=
name|ginfo
index|[
literal|0
index|]
operator|.
name|codepoint
expr_stmt|;
comment|/* getting the same index indicates no substitution,         */
comment|/* which means that the glyph isn't available in the feature */
if|if
condition|(
name|in_idx
operator|==
name|out_idx
condition|)
block|{
operator|*
name|codepoint
operator|=
literal|0
expr_stmt|;
operator|*
name|y_offset
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
operator|*
name|codepoint
operator|=
name|out_idx
expr_stmt|;
operator|*
name|y_offset
operator|=
name|gpos
index|[
literal|0
index|]
operator|.
name|y_offset
expr_stmt|;
block|}
name|hb_buffer_destroy
argument_list|(
name|buf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FT_DEBUG_LEVEL_TRACE
if|if
condition|(
name|gcount
operator|>
literal|1
condition|)
name|FT_TRACE1
argument_list|(
operator|(
literal|"af_get_char_index:"
literal|" input character mapped to multiple glyphs\n"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
operator|*
name|codepoint
operator|=
name|in_idx
expr_stmt|;
operator|*
name|y_offset
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|FT_Err_Ok
return|;
block|}
end_function
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* !FT_CONFIG_OPTION_USE_HARFBUZZ */
end_comment
begin_function
name|FT_Error
DECL|function|af_get_coverage
name|af_get_coverage
parameter_list|(
name|AF_FaceGlobals
name|globals
parameter_list|,
name|AF_StyleClass
name|style_class
parameter_list|,
name|FT_UShort
modifier|*
name|gstyles
parameter_list|)
block|{
name|FT_UNUSED
argument_list|(
name|globals
argument_list|)
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|style_class
argument_list|)
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|gstyles
argument_list|)
expr_stmt|;
return|return
name|FT_Err_Ok
return|;
block|}
end_function
begin_function
name|FT_Error
DECL|function|af_get_char_index
name|af_get_char_index
parameter_list|(
name|AF_StyleMetrics
name|metrics
parameter_list|,
name|FT_ULong
name|charcode
parameter_list|,
name|FT_ULong
modifier|*
name|codepoint
parameter_list|,
name|FT_Long
modifier|*
name|y_offset
parameter_list|)
block|{
name|FT_Face
name|face
decl_stmt|;
if|if
condition|(
operator|!
name|metrics
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_Argument
argument_list|)
return|;
name|face
operator|=
name|metrics
operator|->
name|globals
operator|->
name|face
expr_stmt|;
operator|*
name|codepoint
operator|=
name|FT_Get_Char_Index
argument_list|(
name|face
argument_list|,
name|charcode
argument_list|)
expr_stmt|;
operator|*
name|y_offset
operator|=
literal|0
expr_stmt|;
return|return
name|FT_Err_Ok
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* !FT_CONFIG_OPTION_USE_HARFBUZZ */
end_comment
begin_comment
comment|/* END */
end_comment
end_unit
