begin_unit
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  aflatin.c                                                              */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*    Auto-fitter hinting routines for latin script (body).                */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  Copyright 2003, 2004, 2005, 2006, 2007, 2008, 2009 by                  */
end_comment
begin_comment
comment|/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  This file is part of the FreeType project, and may only be used,       */
end_comment
begin_comment
comment|/*  modified, and distributed under the terms of the FreeType project      */
end_comment
begin_comment
comment|/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
end_comment
begin_comment
comment|/*  this file you indicate that you have read the license and              */
end_comment
begin_comment
comment|/*  understand and accept it fully.                                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_include
include|#
directive|include
include|FT_ADVANCES_H
end_include
begin_include
include|#
directive|include
file|"aflatin.h"
end_include
begin_include
include|#
directive|include
file|"aflatin2.h"
end_include
begin_include
include|#
directive|include
file|"aferrors.h"
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|AF_USE_WARPER
end_ifdef
begin_include
include|#
directive|include
file|"afwarp.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|af_latin2_hints_compute_segments
argument_list|(
argument|AF_GlyphHints  hints
argument_list|,
argument|AF_Dimension   dim
argument_list|)
end_macro
begin_empty_stmt
empty_stmt|;
end_empty_stmt
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|variable|af_latin2_hints_link_segments
name|af_latin2_hints_link_segments
argument_list|(
argument|AF_GlyphHints  hints
argument_list|,
argument|AF_Dimension   dim
argument_list|)
end_macro
begin_empty_stmt
empty_stmt|;
end_empty_stmt
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****            L A T I N   G L O B A L   M E T R I C S            *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|af_latin2_metrics_init_widths
name|af_latin2_metrics_init_widths
argument_list|(
argument|AF_LatinMetrics  metrics
argument_list|,
argument|FT_Face          face
argument_list|,
argument|FT_ULong         charcode
argument_list|)
end_macro
begin_block
block|{
comment|/* scan the array of segments in each direction */
name|AF_GlyphHintsRec
name|hints
index|[
literal|1
index|]
decl_stmt|;
name|af_glyph_hints_init
argument_list|(
name|hints
argument_list|,
name|face
operator|->
name|memory
argument_list|)
expr_stmt|;
name|metrics
operator|->
name|axis
index|[
name|AF_DIMENSION_HORZ
index|]
operator|.
name|width_count
operator|=
literal|0
expr_stmt|;
name|metrics
operator|->
name|axis
index|[
name|AF_DIMENSION_VERT
index|]
operator|.
name|width_count
operator|=
literal|0
expr_stmt|;
block|{
name|FT_Error
name|error
decl_stmt|;
name|FT_UInt
name|glyph_index
decl_stmt|;
name|int
name|dim
decl_stmt|;
name|AF_LatinMetricsRec
name|dummy
index|[
literal|1
index|]
decl_stmt|;
name|AF_Scaler
name|scaler
init|=
operator|&
name|dummy
operator|->
name|root
operator|.
name|scaler
decl_stmt|;
name|glyph_index
operator|=
name|FT_Get_Char_Index
argument_list|(
name|face
argument_list|,
name|charcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|glyph_index
operator|==
literal|0
condition|)
goto|goto
name|Exit
goto|;
name|error
operator|=
name|FT_Load_Glyph
argument_list|(
name|face
argument_list|,
name|glyph_index
argument_list|,
name|FT_LOAD_NO_SCALE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|face
operator|->
name|glyph
operator|->
name|outline
operator|.
name|n_points
operator|<=
literal|0
condition|)
goto|goto
name|Exit
goto|;
name|FT_ZERO
argument_list|(
name|dummy
argument_list|)
expr_stmt|;
name|dummy
operator|->
name|units_per_em
operator|=
name|metrics
operator|->
name|units_per_em
expr_stmt|;
name|scaler
operator|->
name|x_scale
operator|=
name|scaler
operator|->
name|y_scale
operator|=
literal|0x10000L
expr_stmt|;
name|scaler
operator|->
name|x_delta
operator|=
name|scaler
operator|->
name|y_delta
operator|=
literal|0
expr_stmt|;
name|scaler
operator|->
name|face
operator|=
name|face
expr_stmt|;
name|scaler
operator|->
name|render_mode
operator|=
name|FT_RENDER_MODE_NORMAL
expr_stmt|;
name|scaler
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|af_glyph_hints_rescale
argument_list|(
name|hints
argument_list|,
operator|(
name|AF_ScriptMetrics
operator|)
name|dummy
argument_list|)
expr_stmt|;
name|error
operator|=
name|af_glyph_hints_reload
argument_list|(
name|hints
argument_list|,
operator|&
name|face
operator|->
name|glyph
operator|->
name|outline
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
for|for
control|(
name|dim
operator|=
literal|0
init|;
name|dim
operator|<
name|AF_DIMENSION_MAX
condition|;
name|dim
operator|++
control|)
block|{
name|AF_LatinAxis
name|axis
init|=
operator|&
name|metrics
operator|->
name|axis
index|[
name|dim
index|]
decl_stmt|;
name|AF_AxisHints
name|axhints
init|=
operator|&
name|hints
operator|->
name|axis
index|[
name|dim
index|]
decl_stmt|;
name|AF_Segment
name|seg
decl_stmt|,
name|limit
decl_stmt|,
name|link
decl_stmt|;
name|FT_UInt
name|num_widths
init|=
literal|0
decl_stmt|;
name|error
operator|=
name|af_latin2_hints_compute_segments
argument_list|(
name|hints
argument_list|,
operator|(
name|AF_Dimension
operator|)
name|dim
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|af_latin2_hints_link_segments
argument_list|(
name|hints
argument_list|,
operator|(
name|AF_Dimension
operator|)
name|dim
argument_list|)
expr_stmt|;
name|seg
operator|=
name|axhints
operator|->
name|segments
expr_stmt|;
name|limit
operator|=
name|seg
operator|+
name|axhints
operator|->
name|num_segments
expr_stmt|;
for|for
control|(
init|;
name|seg
operator|<
name|limit
condition|;
name|seg
operator|++
control|)
block|{
name|link
operator|=
name|seg
operator|->
name|link
expr_stmt|;
comment|/* we only consider stem segments there! */
if|if
condition|(
name|link
operator|&&
name|link
operator|->
name|link
operator|==
name|seg
operator|&&
name|link
operator|>
name|seg
condition|)
block|{
name|FT_Pos
name|dist
decl_stmt|;
name|dist
operator|=
name|seg
operator|->
name|pos
operator|-
name|link
operator|->
name|pos
expr_stmt|;
if|if
condition|(
name|dist
operator|<
literal|0
condition|)
name|dist
operator|=
operator|-
name|dist
expr_stmt|;
if|if
condition|(
name|num_widths
operator|<
name|AF_LATIN_MAX_WIDTHS
condition|)
name|axis
operator|->
name|widths
index|[
name|num_widths
operator|++
index|]
operator|.
name|org
operator|=
name|dist
expr_stmt|;
block|}
block|}
name|af_sort_widths
argument_list|(
name|num_widths
argument_list|,
name|axis
operator|->
name|widths
argument_list|)
expr_stmt|;
name|axis
operator|->
name|width_count
operator|=
name|num_widths
expr_stmt|;
block|}
name|Exit
label|:
for|for
control|(
name|dim
operator|=
literal|0
init|;
name|dim
operator|<
name|AF_DIMENSION_MAX
condition|;
name|dim
operator|++
control|)
block|{
name|AF_LatinAxis
name|axis
init|=
operator|&
name|metrics
operator|->
name|axis
index|[
name|dim
index|]
decl_stmt|;
name|FT_Pos
name|stdw
decl_stmt|;
name|stdw
operator|=
operator|(
name|axis
operator|->
name|width_count
operator|>
literal|0
operator|)
condition|?
name|axis
operator|->
name|widths
index|[
literal|0
index|]
operator|.
name|org
else|:
name|AF_LATIN_CONSTANT
argument_list|(
name|metrics
argument_list|,
literal|50
argument_list|)
expr_stmt|;
comment|/* let's try 20% of the smallest width */
name|axis
operator|->
name|edge_distance_threshold
operator|=
name|stdw
operator|/
literal|5
expr_stmt|;
name|axis
operator|->
name|standard_width
operator|=
name|stdw
expr_stmt|;
name|axis
operator|->
name|extra_light
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|af_glyph_hints_done
argument_list|(
name|hints
argument_list|)
expr_stmt|;
block|}
end_block
begin_define
DECL|macro|AF_LATIN_MAX_TEST_CHARACTERS
define|#
directive|define
name|AF_LATIN_MAX_TEST_CHARACTERS
value|12
end_define
begin_decl_stmt
DECL|variable|af_latin2_blue_chars
specifier|static
specifier|const
name|char
name|af_latin2_blue_chars
index|[
name|AF_LATIN_MAX_BLUES
index|]
index|[
name|AF_LATIN_MAX_TEST_CHARACTERS
operator|+
literal|1
index|]
init|=
block|{
literal|"THEZOCQS"
block|,
literal|"HEZLOCUS"
block|,
literal|"fijkdbh"
block|,
literal|"xzroesc"
block|,
literal|"xzroesc"
block|,
literal|"pqgjy"
block|}
decl_stmt|;
end_decl_stmt
begin_function
specifier|static
name|void
DECL|function|af_latin2_metrics_init_blues
name|af_latin2_metrics_init_blues
parameter_list|(
name|AF_LatinMetrics
name|metrics
parameter_list|,
name|FT_Face
name|face
parameter_list|)
block|{
name|FT_Pos
name|flats
index|[
name|AF_LATIN_MAX_TEST_CHARACTERS
index|]
decl_stmt|;
name|FT_Pos
name|rounds
index|[
name|AF_LATIN_MAX_TEST_CHARACTERS
index|]
decl_stmt|;
name|FT_Int
name|num_flats
decl_stmt|;
name|FT_Int
name|num_rounds
decl_stmt|;
name|FT_Int
name|bb
decl_stmt|;
name|AF_LatinBlue
name|blue
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|AF_LatinAxis
name|axis
init|=
operator|&
name|metrics
operator|->
name|axis
index|[
name|AF_DIMENSION_VERT
index|]
decl_stmt|;
name|FT_GlyphSlot
name|glyph
init|=
name|face
operator|->
name|glyph
decl_stmt|;
comment|/* we compute the blues simply by loading each character from the    */
comment|/* 'af_latin2_blue_chars[blues]' string, then compute its top-most or */
comment|/* bottom-most points (depending on `AF_IS_TOP_BLUE')                */
name|AF_LOG
argument_list|(
operator|(
literal|"blue zones computation\n"
operator|)
argument_list|)
expr_stmt|;
name|AF_LOG
argument_list|(
operator|(
literal|"------------------------------------------------\n"
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|bb
operator|=
literal|0
init|;
name|bb
operator|<
name|AF_LATIN_BLUE_MAX
condition|;
name|bb
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|af_latin2_blue_chars
index|[
name|bb
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|limit
init|=
name|p
operator|+
name|AF_LATIN_MAX_TEST_CHARACTERS
decl_stmt|;
name|FT_Pos
modifier|*
name|blue_ref
decl_stmt|;
name|FT_Pos
modifier|*
name|blue_shoot
decl_stmt|;
name|AF_LOG
argument_list|(
operator|(
literal|"blue %3d: "
operator|,
name|bb
operator|)
argument_list|)
expr_stmt|;
name|num_flats
operator|=
literal|0
expr_stmt|;
name|num_rounds
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|p
operator|<
name|limit
operator|&&
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
name|FT_UInt
name|glyph_index
decl_stmt|;
name|FT_Int
name|best_point
decl_stmt|,
name|best_y
decl_stmt|,
name|best_first
decl_stmt|,
name|best_last
decl_stmt|;
name|FT_Vector
modifier|*
name|points
decl_stmt|;
name|FT_Bool
name|round
decl_stmt|;
name|AF_LOG
argument_list|(
operator|(
literal|"'%c'"
operator|,
operator|*
name|p
operator|)
argument_list|)
expr_stmt|;
comment|/* load the character in the face -- skip unknown or empty ones */
name|glyph_index
operator|=
name|FT_Get_Char_Index
argument_list|(
name|face
argument_list|,
operator|(
name|FT_UInt
operator|)
operator|*
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|glyph_index
operator|==
literal|0
condition|)
continue|continue;
name|error
operator|=
name|FT_Load_Glyph
argument_list|(
name|face
argument_list|,
name|glyph_index
argument_list|,
name|FT_LOAD_NO_SCALE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|glyph
operator|->
name|outline
operator|.
name|n_points
operator|<=
literal|0
condition|)
continue|continue;
comment|/* now compute min or max point indices and coordinates */
name|points
operator|=
name|glyph
operator|->
name|outline
operator|.
name|points
expr_stmt|;
name|best_point
operator|=
operator|-
literal|1
expr_stmt|;
name|best_y
operator|=
literal|0
expr_stmt|;
comment|/* make compiler happy */
name|best_first
operator|=
literal|0
expr_stmt|;
comment|/* ditto */
name|best_last
operator|=
literal|0
expr_stmt|;
comment|/* ditto */
block|{
name|FT_Int
name|nn
decl_stmt|;
name|FT_Int
name|first
init|=
literal|0
decl_stmt|;
name|FT_Int
name|last
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|nn
operator|=
literal|0
init|;
name|nn
operator|<
name|glyph
operator|->
name|outline
operator|.
name|n_contours
condition|;
name|first
operator|=
name|last
operator|+
literal|1
operator|,
name|nn
operator|++
control|)
block|{
name|FT_Int
name|old_best_point
init|=
name|best_point
decl_stmt|;
name|FT_Int
name|pp
decl_stmt|;
name|last
operator|=
name|glyph
operator|->
name|outline
operator|.
name|contours
index|[
name|nn
index|]
expr_stmt|;
comment|/* Avoid single-point contours since they are never rasterized. */
comment|/* In some fonts, they correspond to mark attachment points     */
comment|/* which are way outside of the glyph's real outline.           */
if|if
condition|(
name|last
operator|==
name|first
condition|)
continue|continue;
if|if
condition|(
name|AF_LATIN_IS_TOP_BLUE
argument_list|(
name|bb
argument_list|)
condition|)
block|{
for|for
control|(
name|pp
operator|=
name|first
init|;
name|pp
operator|<=
name|last
condition|;
name|pp
operator|++
control|)
if|if
condition|(
name|best_point
operator|<
literal|0
operator|||
name|points
index|[
name|pp
index|]
operator|.
name|y
operator|>
name|best_y
condition|)
block|{
name|best_point
operator|=
name|pp
expr_stmt|;
name|best_y
operator|=
name|points
index|[
name|pp
index|]
operator|.
name|y
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|pp
operator|=
name|first
init|;
name|pp
operator|<=
name|last
condition|;
name|pp
operator|++
control|)
if|if
condition|(
name|best_point
operator|<
literal|0
operator|||
name|points
index|[
name|pp
index|]
operator|.
name|y
operator|<
name|best_y
condition|)
block|{
name|best_point
operator|=
name|pp
expr_stmt|;
name|best_y
operator|=
name|points
index|[
name|pp
index|]
operator|.
name|y
expr_stmt|;
block|}
block|}
if|if
condition|(
name|best_point
operator|!=
name|old_best_point
condition|)
block|{
name|best_first
operator|=
name|first
expr_stmt|;
name|best_last
operator|=
name|last
expr_stmt|;
block|}
block|}
name|AF_LOG
argument_list|(
operator|(
literal|"%5d"
operator|,
name|best_y
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* now check whether the point belongs to a straight or round   */
comment|/* segment; we first need to find in which contour the extremum */
comment|/* lies, then inspect its previous and next points              */
block|{
name|FT_Int
name|start
decl_stmt|,
name|end
decl_stmt|,
name|prev
decl_stmt|,
name|next
decl_stmt|;
name|FT_Pos
name|dist
decl_stmt|;
comment|/* now look for the previous and next points that are not on the */
comment|/* same Y coordinate.  Threshold the `closeness'...              */
name|start
operator|=
name|end
operator|=
name|best_point
expr_stmt|;
do|do
block|{
name|prev
operator|=
name|start
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|prev
operator|<
name|best_first
condition|)
name|prev
operator|=
name|best_last
expr_stmt|;
name|dist
operator|=
name|points
index|[
name|prev
index|]
operator|.
name|y
operator|-
name|best_y
expr_stmt|;
if|if
condition|(
name|dist
operator|<
operator|-
literal|5
operator|||
name|dist
operator|>
literal|5
condition|)
break|break;
name|start
operator|=
name|prev
expr_stmt|;
block|}
do|while
condition|(
name|start
operator|!=
name|best_point
condition|)
do|;
do|do
block|{
name|next
operator|=
name|end
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|next
operator|>
name|best_last
condition|)
name|next
operator|=
name|best_first
expr_stmt|;
name|dist
operator|=
name|points
index|[
name|next
index|]
operator|.
name|y
operator|-
name|best_y
expr_stmt|;
if|if
condition|(
name|dist
operator|<
operator|-
literal|5
operator|||
name|dist
operator|>
literal|5
condition|)
break|break;
name|end
operator|=
name|next
expr_stmt|;
block|}
do|while
condition|(
name|end
operator|!=
name|best_point
condition|)
do|;
comment|/* now, set the `round' flag depending on the segment's kind */
name|round
operator|=
name|FT_BOOL
argument_list|(
name|FT_CURVE_TAG
argument_list|(
name|glyph
operator|->
name|outline
operator|.
name|tags
index|[
name|start
index|]
argument_list|)
operator|!=
name|FT_CURVE_TAG_ON
operator|||
name|FT_CURVE_TAG
argument_list|(
name|glyph
operator|->
name|outline
operator|.
name|tags
index|[
name|end
index|]
argument_list|)
operator|!=
name|FT_CURVE_TAG_ON
argument_list|)
expr_stmt|;
name|AF_LOG
argument_list|(
operator|(
literal|"%c "
operator|,
name|round
condition|?
literal|'r'
else|:
literal|'f'
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|round
condition|)
name|rounds
index|[
name|num_rounds
operator|++
index|]
operator|=
name|best_y
expr_stmt|;
else|else
name|flats
index|[
name|num_flats
operator|++
index|]
operator|=
name|best_y
expr_stmt|;
block|}
name|AF_LOG
argument_list|(
operator|(
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_flats
operator|==
literal|0
operator|&&
name|num_rounds
operator|==
literal|0
condition|)
block|{
comment|/*          *  we couldn't find a single glyph to compute this blue zone,          *  we will simply ignore it then          */
name|AF_LOG
argument_list|(
operator|(
literal|"empty\n"
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* we have computed the contents of the `rounds' and `flats' tables, */
comment|/* now determine the reference and overshoot position of the blue -- */
comment|/* we simply take the median value after a simple sort               */
name|af_sort_pos
argument_list|(
name|num_rounds
argument_list|,
name|rounds
argument_list|)
expr_stmt|;
name|af_sort_pos
argument_list|(
name|num_flats
argument_list|,
name|flats
argument_list|)
expr_stmt|;
name|blue
operator|=
operator|&
name|axis
operator|->
name|blues
index|[
name|axis
operator|->
name|blue_count
index|]
expr_stmt|;
name|blue_ref
operator|=
operator|&
name|blue
operator|->
name|ref
operator|.
name|org
expr_stmt|;
name|blue_shoot
operator|=
operator|&
name|blue
operator|->
name|shoot
operator|.
name|org
expr_stmt|;
name|axis
operator|->
name|blue_count
operator|++
expr_stmt|;
if|if
condition|(
name|num_flats
operator|==
literal|0
condition|)
block|{
operator|*
name|blue_ref
operator|=
operator|*
name|blue_shoot
operator|=
name|rounds
index|[
name|num_rounds
operator|/
literal|2
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|num_rounds
operator|==
literal|0
condition|)
block|{
operator|*
name|blue_ref
operator|=
operator|*
name|blue_shoot
operator|=
name|flats
index|[
name|num_flats
operator|/
literal|2
index|]
expr_stmt|;
block|}
else|else
block|{
operator|*
name|blue_ref
operator|=
name|flats
index|[
name|num_flats
operator|/
literal|2
index|]
expr_stmt|;
operator|*
name|blue_shoot
operator|=
name|rounds
index|[
name|num_rounds
operator|/
literal|2
index|]
expr_stmt|;
block|}
comment|/* there are sometimes problems: if the overshoot position of top     */
comment|/* zones is under its reference position, or the opposite for bottom  */
comment|/* zones.  We must thus check everything there and correct the errors */
if|if
condition|(
operator|*
name|blue_shoot
operator|!=
operator|*
name|blue_ref
condition|)
block|{
name|FT_Pos
name|ref
init|=
operator|*
name|blue_ref
decl_stmt|;
name|FT_Pos
name|shoot
init|=
operator|*
name|blue_shoot
decl_stmt|;
name|FT_Bool
name|over_ref
init|=
name|FT_BOOL
argument_list|(
name|shoot
operator|>
name|ref
argument_list|)
decl_stmt|;
if|if
condition|(
name|AF_LATIN_IS_TOP_BLUE
argument_list|(
name|bb
argument_list|)
operator|^
name|over_ref
condition|)
operator|*
name|blue_shoot
operator|=
operator|*
name|blue_ref
operator|=
operator|(
name|shoot
operator|+
name|ref
operator|)
operator|/
literal|2
expr_stmt|;
block|}
name|blue
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|AF_LATIN_IS_TOP_BLUE
argument_list|(
name|bb
argument_list|)
condition|)
name|blue
operator|->
name|flags
operator||=
name|AF_LATIN_BLUE_TOP
expr_stmt|;
comment|/*        * The following flags is used later to adjust the y and x scales        * in order to optimize the pixel grid alignment of the top of small        * letters.        */
if|if
condition|(
name|bb
operator|==
name|AF_LATIN_BLUE_SMALL_TOP
condition|)
name|blue
operator|->
name|flags
operator||=
name|AF_LATIN_BLUE_ADJUSTMENT
expr_stmt|;
name|AF_LOG
argument_list|(
operator|(
literal|"-- ref = %ld, shoot = %ld\n"
operator|,
operator|*
name|blue_ref
operator|,
operator|*
name|blue_shoot
operator|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|af_latin2_metrics_check_digits
name|af_latin2_metrics_check_digits
argument_list|(
argument|AF_LatinMetrics  metrics
argument_list|,
argument|FT_Face          face
argument_list|)
end_macro
begin_block
block|{
name|FT_UInt
name|i
decl_stmt|;
name|FT_Bool
name|started
init|=
literal|0
decl_stmt|,
name|same_width
init|=
literal|1
decl_stmt|;
name|FT_Fixed
name|advance
decl_stmt|,
name|old_advance
init|=
literal|0
decl_stmt|;
comment|/* check whether all ASCII digits have the same advance width; */
comment|/* digit `0' is 0x30 in all supported charmaps                 */
for|for
control|(
name|i
operator|=
literal|0x30
init|;
name|i
operator|<=
literal|0x39
condition|;
name|i
operator|++
control|)
block|{
name|FT_UInt
name|glyph_index
decl_stmt|;
name|glyph_index
operator|=
name|FT_Get_Char_Index
argument_list|(
name|face
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|glyph_index
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|FT_Get_Advance
argument_list|(
name|face
argument_list|,
name|glyph_index
argument_list|,
name|FT_LOAD_NO_SCALE
operator||
name|FT_LOAD_NO_HINTING
operator||
name|FT_LOAD_IGNORE_TRANSFORM
argument_list|,
operator|&
name|advance
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|started
condition|)
block|{
if|if
condition|(
name|advance
operator|!=
name|old_advance
condition|)
block|{
name|same_width
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|old_advance
operator|=
name|advance
expr_stmt|;
name|started
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|metrics
operator|->
name|root
operator|.
name|digits_have_same_width
operator|=
name|same_width
expr_stmt|;
block|}
end_block
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|af_latin2_metrics_init
argument_list|(
argument|AF_LatinMetrics  metrics
argument_list|,
argument|FT_Face          face
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
init|=
name|AF_Err_Ok
decl_stmt|;
name|FT_CharMap
name|oldmap
init|=
name|face
operator|->
name|charmap
decl_stmt|;
name|FT_UInt
name|ee
decl_stmt|;
specifier|static
specifier|const
name|FT_Encoding
name|latin_encodings
index|[]
init|=
block|{
name|FT_ENCODING_UNICODE
block|,
name|FT_ENCODING_APPLE_ROMAN
block|,
name|FT_ENCODING_ADOBE_STANDARD
block|,
name|FT_ENCODING_ADOBE_LATIN_1
block|,
name|FT_ENCODING_NONE
comment|/* end of list */
block|}
decl_stmt|;
name|metrics
operator|->
name|units_per_em
operator|=
name|face
operator|->
name|units_per_EM
expr_stmt|;
comment|/* do we have a latin charmap in there? */
for|for
control|(
name|ee
operator|=
literal|0
init|;
name|latin_encodings
index|[
name|ee
index|]
operator|!=
name|FT_ENCODING_NONE
condition|;
name|ee
operator|++
control|)
block|{
name|error
operator|=
name|FT_Select_Charmap
argument_list|(
name|face
argument_list|,
name|latin_encodings
index|[
name|ee
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|error
condition|)
block|{
comment|/* For now, compute the standard width and height from the `o'. */
name|af_latin2_metrics_init_widths
argument_list|(
name|metrics
argument_list|,
name|face
argument_list|,
literal|'o'
argument_list|)
expr_stmt|;
name|af_latin2_metrics_init_blues
argument_list|(
name|metrics
argument_list|,
name|face
argument_list|)
expr_stmt|;
name|af_latin2_metrics_check_digits
argument_list|(
name|metrics
argument_list|,
name|face
argument_list|)
expr_stmt|;
block|}
name|FT_Set_Charmap
argument_list|(
name|face
argument_list|,
name|oldmap
argument_list|)
expr_stmt|;
return|return
name|AF_Err_Ok
return|;
block|}
end_block
begin_function
specifier|static
name|void
DECL|function|af_latin2_metrics_scale_dim
name|af_latin2_metrics_scale_dim
parameter_list|(
name|AF_LatinMetrics
name|metrics
parameter_list|,
name|AF_Scaler
name|scaler
parameter_list|,
name|AF_Dimension
name|dim
parameter_list|)
block|{
name|FT_Fixed
name|scale
decl_stmt|;
name|FT_Pos
name|delta
decl_stmt|;
name|AF_LatinAxis
name|axis
decl_stmt|;
name|FT_UInt
name|nn
decl_stmt|;
if|if
condition|(
name|dim
operator|==
name|AF_DIMENSION_HORZ
condition|)
block|{
name|scale
operator|=
name|scaler
operator|->
name|x_scale
expr_stmt|;
name|delta
operator|=
name|scaler
operator|->
name|x_delta
expr_stmt|;
block|}
else|else
block|{
name|scale
operator|=
name|scaler
operator|->
name|y_scale
expr_stmt|;
name|delta
operator|=
name|scaler
operator|->
name|y_delta
expr_stmt|;
block|}
name|axis
operator|=
operator|&
name|metrics
operator|->
name|axis
index|[
name|dim
index|]
expr_stmt|;
if|if
condition|(
name|axis
operator|->
name|org_scale
operator|==
name|scale
operator|&&
name|axis
operator|->
name|org_delta
operator|==
name|delta
condition|)
return|return;
name|axis
operator|->
name|org_scale
operator|=
name|scale
expr_stmt|;
name|axis
operator|->
name|org_delta
operator|=
name|delta
expr_stmt|;
comment|/*      * correct Y scale to optimize the alignment of the top of small      * letters to the pixel grid      */
if|if
condition|(
name|dim
operator|==
name|AF_DIMENSION_VERT
condition|)
block|{
name|AF_LatinAxis
name|vaxis
init|=
operator|&
name|metrics
operator|->
name|axis
index|[
name|AF_DIMENSION_VERT
index|]
decl_stmt|;
name|AF_LatinBlue
name|blue
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|nn
operator|=
literal|0
init|;
name|nn
operator|<
name|vaxis
operator|->
name|blue_count
condition|;
name|nn
operator|++
control|)
block|{
if|if
condition|(
name|vaxis
operator|->
name|blues
index|[
name|nn
index|]
operator|.
name|flags
operator|&
name|AF_LATIN_BLUE_ADJUSTMENT
condition|)
block|{
name|blue
operator|=
operator|&
name|vaxis
operator|->
name|blues
index|[
name|nn
index|]
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|blue
condition|)
block|{
name|FT_Pos
name|scaled
init|=
name|FT_MulFix
argument_list|(
name|blue
operator|->
name|shoot
operator|.
name|org
argument_list|,
name|scaler
operator|->
name|y_scale
argument_list|)
decl_stmt|;
name|FT_Pos
name|fitted
init|=
operator|(
name|scaled
operator|+
literal|40
operator|)
operator|&
operator|~
literal|63
decl_stmt|;
if|#
directive|if
literal|1
if|if
condition|(
name|scaled
operator|!=
name|fitted
condition|)
block|{
name|scale
operator|=
name|FT_MulDiv
argument_list|(
name|scale
argument_list|,
name|fitted
argument_list|,
name|scaled
argument_list|)
expr_stmt|;
name|AF_LOG
argument_list|(
operator|(
literal|"== scaled x-top = %.2g  fitted = %.2g, scaling = %.4g\n"
operator|,
name|scaled
operator|/
literal|64.0
operator|,
name|fitted
operator|/
literal|64.0
operator|,
operator|(
name|fitted
operator|*
literal|1.0
operator|)
operator|/
name|scaled
operator|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
name|axis
operator|->
name|scale
operator|=
name|scale
expr_stmt|;
name|axis
operator|->
name|delta
operator|=
name|delta
expr_stmt|;
if|if
condition|(
name|dim
operator|==
name|AF_DIMENSION_HORZ
condition|)
block|{
name|metrics
operator|->
name|root
operator|.
name|scaler
operator|.
name|x_scale
operator|=
name|scale
expr_stmt|;
name|metrics
operator|->
name|root
operator|.
name|scaler
operator|.
name|x_delta
operator|=
name|delta
expr_stmt|;
block|}
else|else
block|{
name|metrics
operator|->
name|root
operator|.
name|scaler
operator|.
name|y_scale
operator|=
name|scale
expr_stmt|;
name|metrics
operator|->
name|root
operator|.
name|scaler
operator|.
name|y_delta
operator|=
name|delta
expr_stmt|;
block|}
comment|/* scale the standard widths */
for|for
control|(
name|nn
operator|=
literal|0
init|;
name|nn
operator|<
name|axis
operator|->
name|width_count
condition|;
name|nn
operator|++
control|)
block|{
name|AF_Width
name|width
init|=
name|axis
operator|->
name|widths
operator|+
name|nn
decl_stmt|;
name|width
operator|->
name|cur
operator|=
name|FT_MulFix
argument_list|(
name|width
operator|->
name|org
argument_list|,
name|scale
argument_list|)
expr_stmt|;
name|width
operator|->
name|fit
operator|=
name|width
operator|->
name|cur
expr_stmt|;
block|}
comment|/* an extra-light axis corresponds to a standard width that is */
comment|/* smaller than 0.75 pixels                                    */
name|axis
operator|->
name|extra_light
operator|=
call|(
name|FT_Bool
call|)
argument_list|(
name|FT_MulFix
argument_list|(
name|axis
operator|->
name|standard_width
argument_list|,
name|scale
argument_list|)
operator|<
literal|32
operator|+
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|dim
operator|==
name|AF_DIMENSION_VERT
condition|)
block|{
comment|/* scale the blue zones */
for|for
control|(
name|nn
operator|=
literal|0
init|;
name|nn
operator|<
name|axis
operator|->
name|blue_count
condition|;
name|nn
operator|++
control|)
block|{
name|AF_LatinBlue
name|blue
init|=
operator|&
name|axis
operator|->
name|blues
index|[
name|nn
index|]
decl_stmt|;
name|FT_Pos
name|dist
decl_stmt|;
name|blue
operator|->
name|ref
operator|.
name|cur
operator|=
name|FT_MulFix
argument_list|(
name|blue
operator|->
name|ref
operator|.
name|org
argument_list|,
name|scale
argument_list|)
operator|+
name|delta
expr_stmt|;
name|blue
operator|->
name|ref
operator|.
name|fit
operator|=
name|blue
operator|->
name|ref
operator|.
name|cur
expr_stmt|;
name|blue
operator|->
name|shoot
operator|.
name|cur
operator|=
name|FT_MulFix
argument_list|(
name|blue
operator|->
name|shoot
operator|.
name|org
argument_list|,
name|scale
argument_list|)
operator|+
name|delta
expr_stmt|;
name|blue
operator|->
name|shoot
operator|.
name|fit
operator|=
name|blue
operator|->
name|shoot
operator|.
name|cur
expr_stmt|;
name|blue
operator|->
name|flags
operator|&=
operator|~
name|AF_LATIN_BLUE_ACTIVE
expr_stmt|;
comment|/* a blue zone is only active if it is less than 3/4 pixels tall */
name|dist
operator|=
name|FT_MulFix
argument_list|(
name|blue
operator|->
name|ref
operator|.
name|org
operator|-
name|blue
operator|->
name|shoot
operator|.
name|org
argument_list|,
name|scale
argument_list|)
expr_stmt|;
if|if
condition|(
name|dist
operator|<=
literal|48
operator|&&
name|dist
operator|>=
operator|-
literal|48
condition|)
block|{
name|FT_Pos
name|delta1
decl_stmt|,
name|delta2
decl_stmt|;
name|delta1
operator|=
name|blue
operator|->
name|shoot
operator|.
name|org
operator|-
name|blue
operator|->
name|ref
operator|.
name|org
expr_stmt|;
name|delta2
operator|=
name|delta1
expr_stmt|;
if|if
condition|(
name|delta1
operator|<
literal|0
condition|)
name|delta2
operator|=
operator|-
name|delta2
expr_stmt|;
name|delta2
operator|=
name|FT_MulFix
argument_list|(
name|delta2
argument_list|,
name|scale
argument_list|)
expr_stmt|;
if|if
condition|(
name|delta2
operator|<
literal|32
condition|)
name|delta2
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|delta2
operator|<
literal|64
condition|)
name|delta2
operator|=
literal|32
operator|+
operator|(
operator|(
operator|(
name|delta2
operator|-
literal|32
operator|)
operator|+
literal|16
operator|)
operator|&
operator|~
literal|31
operator|)
expr_stmt|;
else|else
name|delta2
operator|=
name|FT_PIX_ROUND
argument_list|(
name|delta2
argument_list|)
expr_stmt|;
if|if
condition|(
name|delta1
operator|<
literal|0
condition|)
name|delta2
operator|=
operator|-
name|delta2
expr_stmt|;
name|blue
operator|->
name|ref
operator|.
name|fit
operator|=
name|FT_PIX_ROUND
argument_list|(
name|blue
operator|->
name|ref
operator|.
name|cur
argument_list|)
expr_stmt|;
name|blue
operator|->
name|shoot
operator|.
name|fit
operator|=
name|blue
operator|->
name|ref
operator|.
name|fit
operator|+
name|delta2
expr_stmt|;
name|AF_LOG
argument_list|(
operator|(
literal|">> activating blue zone %d:  ref.cur=%.2g ref.fit=%.2g shoot.cur=%.2g shoot.fit=%.2g\n"
operator|,
name|nn
operator|,
name|blue
operator|->
name|ref
operator|.
name|cur
operator|/
literal|64.0
operator|,
name|blue
operator|->
name|ref
operator|.
name|fit
operator|/
literal|64.0
operator|,
name|blue
operator|->
name|shoot
operator|.
name|cur
operator|/
literal|64.0
operator|,
name|blue
operator|->
name|shoot
operator|.
name|fit
operator|/
literal|64.0
operator|)
argument_list|)
expr_stmt|;
name|blue
operator|->
name|flags
operator||=
name|AF_LATIN_BLUE_ACTIVE
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|af_latin2_metrics_scale
name|af_latin2_metrics_scale
argument_list|(
argument|AF_LatinMetrics  metrics
argument_list|,
argument|AF_Scaler        scaler
argument_list|)
end_macro
begin_block
block|{
name|metrics
operator|->
name|root
operator|.
name|scaler
operator|.
name|render_mode
operator|=
name|scaler
operator|->
name|render_mode
expr_stmt|;
name|metrics
operator|->
name|root
operator|.
name|scaler
operator|.
name|face
operator|=
name|scaler
operator|->
name|face
expr_stmt|;
name|af_latin2_metrics_scale_dim
argument_list|(
name|metrics
argument_list|,
name|scaler
argument_list|,
name|AF_DIMENSION_HORZ
argument_list|)
expr_stmt|;
name|af_latin2_metrics_scale_dim
argument_list|(
name|metrics
argument_list|,
name|scaler
argument_list|,
name|AF_DIMENSION_VERT
argument_list|)
expr_stmt|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****           L A T I N   G L Y P H   A N A L Y S I S             *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_define
DECL|macro|SORT_SEGMENTS
define|#
directive|define
name|SORT_SEGMENTS
end_define
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|af_latin2_hints_compute_segments
argument_list|(
argument|AF_GlyphHints  hints
argument_list|,
argument|AF_Dimension   dim
argument_list|)
end_macro
begin_block
block|{
name|AF_AxisHints
name|axis
init|=
operator|&
name|hints
operator|->
name|axis
index|[
name|dim
index|]
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|hints
operator|->
name|memory
decl_stmt|;
name|FT_Error
name|error
init|=
name|AF_Err_Ok
decl_stmt|;
name|AF_Segment
name|segment
init|=
name|NULL
decl_stmt|;
name|AF_SegmentRec
name|seg0
decl_stmt|;
name|AF_Point
modifier|*
name|contour
init|=
name|hints
operator|->
name|contours
decl_stmt|;
name|AF_Point
modifier|*
name|contour_limit
init|=
name|contour
operator|+
name|hints
operator|->
name|num_contours
decl_stmt|;
name|AF_Direction
name|major_dir
decl_stmt|,
name|segment_dir
decl_stmt|;
name|FT_ZERO
argument_list|(
operator|&
name|seg0
argument_list|)
expr_stmt|;
name|seg0
operator|.
name|score
operator|=
literal|32000
expr_stmt|;
name|seg0
operator|.
name|flags
operator|=
name|AF_EDGE_NORMAL
expr_stmt|;
name|major_dir
operator|=
operator|(
name|AF_Direction
operator|)
name|FT_ABS
argument_list|(
name|axis
operator|->
name|major_dir
argument_list|)
expr_stmt|;
name|segment_dir
operator|=
name|major_dir
expr_stmt|;
name|axis
operator|->
name|num_segments
operator|=
literal|0
expr_stmt|;
comment|/* set up (u,v) in each point */
if|if
condition|(
name|dim
operator|==
name|AF_DIMENSION_HORZ
condition|)
block|{
name|AF_Point
name|point
init|=
name|hints
operator|->
name|points
decl_stmt|;
name|AF_Point
name|limit
init|=
name|point
operator|+
name|hints
operator|->
name|num_points
decl_stmt|;
for|for
control|(
init|;
name|point
operator|<
name|limit
condition|;
name|point
operator|++
control|)
block|{
name|point
operator|->
name|u
operator|=
name|point
operator|->
name|fx
expr_stmt|;
name|point
operator|->
name|v
operator|=
name|point
operator|->
name|fy
expr_stmt|;
block|}
block|}
else|else
block|{
name|AF_Point
name|point
init|=
name|hints
operator|->
name|points
decl_stmt|;
name|AF_Point
name|limit
init|=
name|point
operator|+
name|hints
operator|->
name|num_points
decl_stmt|;
for|for
control|(
init|;
name|point
operator|<
name|limit
condition|;
name|point
operator|++
control|)
block|{
name|point
operator|->
name|u
operator|=
name|point
operator|->
name|fy
expr_stmt|;
name|point
operator|->
name|v
operator|=
name|point
operator|->
name|fx
expr_stmt|;
block|}
block|}
comment|/* do each contour separately */
for|for
control|(
init|;
name|contour
operator|<
name|contour_limit
condition|;
name|contour
operator|++
control|)
block|{
name|AF_Point
name|point
init|=
name|contour
index|[
literal|0
index|]
decl_stmt|;
name|AF_Point
name|start
init|=
name|point
decl_stmt|;
name|AF_Point
name|last
init|=
name|point
operator|->
name|prev
decl_stmt|;
if|if
condition|(
name|point
operator|==
name|last
condition|)
comment|/* skip singletons -- just in case */
continue|continue;
comment|/* already on an edge ?, backtrack to find its start */
if|if
condition|(
name|FT_ABS
argument_list|(
name|point
operator|->
name|in_dir
argument_list|)
operator|==
name|major_dir
condition|)
block|{
name|point
operator|=
name|point
operator|->
name|prev
expr_stmt|;
while|while
condition|(
name|point
operator|->
name|in_dir
operator|==
name|start
operator|->
name|in_dir
condition|)
name|point
operator|=
name|point
operator|->
name|prev
expr_stmt|;
block|}
else|else
comment|/* otherwise, find first segment start, if any */
block|{
while|while
condition|(
name|FT_ABS
argument_list|(
name|point
operator|->
name|out_dir
argument_list|)
operator|!=
name|major_dir
condition|)
block|{
name|point
operator|=
name|point
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|point
operator|==
name|start
condition|)
goto|goto
name|NextContour
goto|;
block|}
block|}
name|start
operator|=
name|point
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|AF_Point
name|first
decl_stmt|;
name|FT_Pos
name|min_u
decl_stmt|,
name|min_v
decl_stmt|,
name|max_u
decl_stmt|,
name|max_v
decl_stmt|;
comment|/* we're at the start of a new segment */
name|FT_ASSERT
argument_list|(
name|FT_ABS
argument_list|(
name|point
operator|->
name|out_dir
argument_list|)
operator|==
name|major_dir
operator|&&
name|point
operator|->
name|in_dir
operator|!=
name|point
operator|->
name|out_dir
argument_list|)
expr_stmt|;
name|first
operator|=
name|point
expr_stmt|;
name|min_u
operator|=
name|max_u
operator|=
name|point
operator|->
name|u
expr_stmt|;
name|min_v
operator|=
name|max_v
operator|=
name|point
operator|->
name|v
expr_stmt|;
name|point
operator|=
name|point
operator|->
name|next
expr_stmt|;
while|while
condition|(
name|point
operator|->
name|out_dir
operator|==
name|first
operator|->
name|out_dir
condition|)
block|{
name|point
operator|=
name|point
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|point
operator|->
name|u
operator|<
name|min_u
condition|)
name|min_u
operator|=
name|point
operator|->
name|u
expr_stmt|;
if|if
condition|(
name|point
operator|->
name|u
operator|>
name|max_u
condition|)
name|max_u
operator|=
name|point
operator|->
name|u
expr_stmt|;
block|}
if|if
condition|(
name|point
operator|->
name|v
operator|<
name|min_v
condition|)
name|min_v
operator|=
name|point
operator|->
name|v
expr_stmt|;
if|if
condition|(
name|point
operator|->
name|v
operator|>
name|max_v
condition|)
name|max_v
operator|=
name|point
operator|->
name|v
expr_stmt|;
comment|/* record new segment */
name|error
operator|=
name|af_axis_hints_new_segment
argument_list|(
name|axis
argument_list|,
name|memory
argument_list|,
operator|&
name|segment
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|segment
index|[
literal|0
index|]
operator|=
name|seg0
expr_stmt|;
name|segment
operator|->
name|dir
operator|=
name|first
operator|->
name|out_dir
expr_stmt|;
name|segment
operator|->
name|first
operator|=
name|first
expr_stmt|;
name|segment
operator|->
name|last
operator|=
name|point
expr_stmt|;
name|segment
operator|->
name|contour
operator|=
name|contour
expr_stmt|;
name|segment
operator|->
name|pos
operator|=
call|(
name|FT_Short
call|)
argument_list|(
operator|(
name|min_u
operator|+
name|max_u
operator|)
operator|>>
literal|1
argument_list|)
expr_stmt|;
name|segment
operator|->
name|min_coord
operator|=
operator|(
name|FT_Short
operator|)
name|min_v
expr_stmt|;
name|segment
operator|->
name|max_coord
operator|=
operator|(
name|FT_Short
operator|)
name|max_v
expr_stmt|;
name|segment
operator|->
name|height
operator|=
call|(
name|FT_Short
call|)
argument_list|(
name|max_v
operator|-
name|min_v
argument_list|)
expr_stmt|;
comment|/* a segment is round if it doesn't have successive */
comment|/* on-curve points.                                 */
block|{
name|AF_Point
name|pt
init|=
name|first
decl_stmt|;
name|AF_Point
name|last
init|=
name|point
decl_stmt|;
name|AF_Flags
name|f0
init|=
call|(
name|AF_Flags
call|)
argument_list|(
name|pt
operator|->
name|flags
operator|&
name|AF_FLAG_CONTROL
argument_list|)
decl_stmt|;
name|AF_Flags
name|f1
decl_stmt|;
name|segment
operator|->
name|flags
operator|&=
operator|~
name|AF_EDGE_ROUND
expr_stmt|;
for|for
control|(
init|;
name|pt
operator|!=
name|last
condition|;
name|f0
operator|=
name|f1
control|)
block|{
name|pt
operator|=
name|pt
operator|->
name|next
expr_stmt|;
name|f1
operator|=
call|(
name|AF_Flags
call|)
argument_list|(
name|pt
operator|->
name|flags
operator|&
name|AF_FLAG_CONTROL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|f0
operator|&&
operator|!
name|f1
condition|)
break|break;
if|if
condition|(
name|pt
operator|==
name|last
condition|)
name|segment
operator|->
name|flags
operator||=
name|AF_EDGE_ROUND
expr_stmt|;
block|}
block|}
comment|/* this can happen in the case of a degenerate contour         * e.g. a 2-point vertical contour         */
if|if
condition|(
name|point
operator|==
name|start
condition|)
break|break;
comment|/* jump to the start of the next segment, if any */
while|while
condition|(
name|FT_ABS
argument_list|(
name|point
operator|->
name|out_dir
argument_list|)
operator|!=
name|major_dir
condition|)
block|{
name|point
operator|=
name|point
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|point
operator|==
name|start
condition|)
goto|goto
name|NextContour
goto|;
block|}
block|}
name|NextContour
label|:
empty_stmt|;
block|}
comment|/* contours */
comment|/* now slightly increase the height of segments when this makes */
comment|/* sense -- this is used to better detect and ignore serifs     */
block|{
name|AF_Segment
name|segments
init|=
name|axis
operator|->
name|segments
decl_stmt|;
name|AF_Segment
name|segments_end
init|=
name|segments
operator|+
name|axis
operator|->
name|num_segments
decl_stmt|;
for|for
control|(
name|segment
operator|=
name|segments
init|;
name|segment
operator|<
name|segments_end
condition|;
name|segment
operator|++
control|)
block|{
name|AF_Point
name|first
init|=
name|segment
operator|->
name|first
decl_stmt|;
name|AF_Point
name|last
init|=
name|segment
operator|->
name|last
decl_stmt|;
name|AF_Point
name|p
decl_stmt|;
name|FT_Pos
name|first_v
init|=
name|first
operator|->
name|v
decl_stmt|;
name|FT_Pos
name|last_v
init|=
name|last
operator|->
name|v
decl_stmt|;
if|if
condition|(
name|first
operator|==
name|last
condition|)
continue|continue;
if|if
condition|(
name|first_v
operator|<
name|last_v
condition|)
block|{
name|p
operator|=
name|first
operator|->
name|prev
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|v
operator|<
name|first_v
condition|)
name|segment
operator|->
name|height
operator|=
call|(
name|FT_Short
call|)
argument_list|(
name|segment
operator|->
name|height
operator|+
operator|(
operator|(
name|first_v
operator|-
name|p
operator|->
name|v
operator|)
operator|>>
literal|1
operator|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|last
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|v
operator|>
name|last_v
condition|)
name|segment
operator|->
name|height
operator|=
call|(
name|FT_Short
call|)
argument_list|(
name|segment
operator|->
name|height
operator|+
operator|(
operator|(
name|p
operator|->
name|v
operator|-
name|last_v
operator|)
operator|>>
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|first
operator|->
name|prev
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|v
operator|>
name|first_v
condition|)
name|segment
operator|->
name|height
operator|=
call|(
name|FT_Short
call|)
argument_list|(
name|segment
operator|->
name|height
operator|+
operator|(
operator|(
name|p
operator|->
name|v
operator|-
name|first_v
operator|)
operator|>>
literal|1
operator|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|last
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|v
operator|<
name|last_v
condition|)
name|segment
operator|->
name|height
operator|=
call|(
name|FT_Short
call|)
argument_list|(
name|segment
operator|->
name|height
operator|+
operator|(
operator|(
name|last_v
operator|-
name|p
operator|->
name|v
operator|)
operator|>>
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|AF_SORT_SEGMENTS
comment|/* place all segments with a negative direction to the start     * of the array, used to speed up segment linking later...     */
block|{
name|AF_Segment
name|segments
init|=
name|axis
operator|->
name|segments
decl_stmt|;
name|FT_UInt
name|count
init|=
name|axis
operator|->
name|num_segments
decl_stmt|;
name|FT_UInt
name|ii
decl_stmt|,
name|jj
decl_stmt|;
for|for
control|(
name|ii
operator|=
literal|0
init|;
name|ii
operator|<
name|count
condition|;
name|ii
operator|++
control|)
block|{
if|if
condition|(
name|segments
index|[
name|ii
index|]
operator|.
name|dir
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|jj
operator|=
name|ii
operator|+
literal|1
init|;
name|jj
operator|<
name|count
condition|;
name|jj
operator|++
control|)
block|{
if|if
condition|(
name|segments
index|[
name|jj
index|]
operator|.
name|dir
operator|<
literal|0
condition|)
block|{
name|AF_SegmentRec
name|tmp
decl_stmt|;
name|tmp
operator|=
name|segments
index|[
name|ii
index|]
expr_stmt|;
name|segments
index|[
name|ii
index|]
operator|=
name|segments
index|[
name|jj
index|]
expr_stmt|;
name|segments
index|[
name|jj
index|]
operator|=
name|tmp
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|jj
operator|==
name|count
condition|)
break|break;
block|}
block|}
name|axis
operator|->
name|mid_segments
operator|=
name|ii
expr_stmt|;
block|}
endif|#
directive|endif
name|Exit
label|:
return|return
name|error
return|;
block|}
end_block
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|af_latin2_hints_link_segments
name|af_latin2_hints_link_segments
argument_list|(
argument|AF_GlyphHints  hints
argument_list|,
argument|AF_Dimension   dim
argument_list|)
end_macro
begin_block
block|{
name|AF_AxisHints
name|axis
init|=
operator|&
name|hints
operator|->
name|axis
index|[
name|dim
index|]
decl_stmt|;
name|AF_Segment
name|segments
init|=
name|axis
operator|->
name|segments
decl_stmt|;
name|AF_Segment
name|segment_limit
init|=
name|segments
operator|+
name|axis
operator|->
name|num_segments
decl_stmt|;
ifdef|#
directive|ifdef
name|AF_SORT_SEGMENTS
name|AF_Segment
name|segment_mid
init|=
name|segments
operator|+
name|axis
operator|->
name|mid_segments
decl_stmt|;
endif|#
directive|endif
name|FT_Pos
name|len_threshold
decl_stmt|,
name|len_score
decl_stmt|;
name|AF_Segment
name|seg1
decl_stmt|,
name|seg2
decl_stmt|;
name|len_threshold
operator|=
name|AF_LATIN_CONSTANT
argument_list|(
name|hints
operator|->
name|metrics
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|len_threshold
operator|==
literal|0
condition|)
name|len_threshold
operator|=
literal|1
expr_stmt|;
name|len_score
operator|=
name|AF_LATIN_CONSTANT
argument_list|(
name|hints
operator|->
name|metrics
argument_list|,
literal|6000
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AF_SORT_SEGMENTS
for|for
control|(
name|seg1
operator|=
name|segments
init|;
name|seg1
operator|<
name|segment_mid
condition|;
name|seg1
operator|++
control|)
block|{
if|if
condition|(
name|seg1
operator|->
name|dir
operator|!=
name|axis
operator|->
name|major_dir
operator|||
name|seg1
operator|->
name|first
operator|==
name|seg1
operator|->
name|last
condition|)
continue|continue;
for|for
control|(
name|seg2
operator|=
name|segment_mid
init|;
name|seg2
operator|<
name|segment_limit
condition|;
name|seg2
operator|++
control|)
else|#
directive|else
comment|/* now compare each segment to the others */
for|for
control|(
name|seg1
operator|=
name|segments
init|;
name|seg1
operator|<
name|segment_limit
condition|;
name|seg1
operator|++
control|)
block|{
comment|/* the fake segments are introduced to hint the metrics -- */
comment|/* we must never link them to anything                     */
if|if
condition|(
name|seg1
operator|->
name|dir
operator|!=
name|axis
operator|->
name|major_dir
operator|||
name|seg1
operator|->
name|first
operator|==
name|seg1
operator|->
name|last
condition|)
continue|continue;
for|for
control|(
name|seg2
operator|=
name|segments
init|;
name|seg2
operator|<
name|segment_limit
condition|;
name|seg2
operator|++
control|)
if|if
condition|(
name|seg1
operator|->
name|dir
operator|+
name|seg2
operator|->
name|dir
operator|==
literal|0
operator|&&
name|seg2
operator|->
name|pos
operator|>
name|seg1
operator|->
name|pos
condition|)
endif|#
directive|endif
block|{
name|FT_Pos
name|pos1
init|=
name|seg1
operator|->
name|pos
decl_stmt|;
name|FT_Pos
name|pos2
init|=
name|seg2
operator|->
name|pos
decl_stmt|;
name|FT_Pos
name|dist
init|=
name|pos2
operator|-
name|pos1
decl_stmt|;
if|if
condition|(
name|dist
operator|<
literal|0
condition|)
continue|continue;
block|{
name|FT_Pos
name|min
init|=
name|seg1
operator|->
name|min_coord
decl_stmt|;
name|FT_Pos
name|max
init|=
name|seg1
operator|->
name|max_coord
decl_stmt|;
name|FT_Pos
name|len
decl_stmt|,
name|score
decl_stmt|;
if|if
condition|(
name|min
operator|<
name|seg2
operator|->
name|min_coord
condition|)
name|min
operator|=
name|seg2
operator|->
name|min_coord
expr_stmt|;
if|if
condition|(
name|max
operator|>
name|seg2
operator|->
name|max_coord
condition|)
name|max
operator|=
name|seg2
operator|->
name|max_coord
expr_stmt|;
name|len
operator|=
name|max
operator|-
name|min
expr_stmt|;
if|if
condition|(
name|len
operator|>=
name|len_threshold
condition|)
block|{
name|score
operator|=
name|dist
operator|+
name|len_score
operator|/
name|len
expr_stmt|;
if|if
condition|(
name|score
operator|<
name|seg1
operator|->
name|score
condition|)
block|{
name|seg1
operator|->
name|score
operator|=
name|score
expr_stmt|;
name|seg1
operator|->
name|link
operator|=
name|seg2
expr_stmt|;
block|}
if|if
condition|(
name|score
operator|<
name|seg2
operator|->
name|score
condition|)
block|{
name|seg2
operator|->
name|score
operator|=
name|score
expr_stmt|;
name|seg2
operator|->
name|link
operator|=
name|seg1
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
if|#
directive|if
literal|0
block|}
endif|#
directive|endif
comment|/* now, compute the `serif' segments */
for|for
control|(
name|seg1
operator|=
name|segments
init|;
name|seg1
operator|<
name|segment_limit
condition|;
name|seg1
operator|++
control|)
block|{
name|seg2
operator|=
name|seg1
operator|->
name|link
expr_stmt|;
if|if
condition|(
name|seg2
condition|)
block|{
if|if
condition|(
name|seg2
operator|->
name|link
operator|!=
name|seg1
condition|)
block|{
name|seg1
operator|->
name|link
operator|=
literal|0
expr_stmt|;
name|seg1
operator|->
name|serif
operator|=
name|seg2
operator|->
name|link
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
name|af_latin2_hints_compute_edges
argument_list|(
argument|AF_GlyphHints  hints
argument_list|,
argument|AF_Dimension   dim
argument_list|)
block|{
name|AF_AxisHints
name|axis
init|=
operator|&
name|hints
operator|->
name|axis
index|[
name|dim
index|]
decl_stmt|;
name|FT_Error
name|error
init|=
name|AF_Err_Ok
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|hints
operator|->
name|memory
decl_stmt|;
name|AF_LatinAxis
name|laxis
init|=
operator|&
operator|(
operator|(
name|AF_LatinMetrics
operator|)
name|hints
operator|->
name|metrics
operator|)
operator|->
name|axis
index|[
name|dim
index|]
decl_stmt|;
name|AF_Segment
name|segments
init|=
name|axis
operator|->
name|segments
decl_stmt|;
name|AF_Segment
name|segment_limit
init|=
name|segments
operator|+
name|axis
operator|->
name|num_segments
decl_stmt|;
name|AF_Segment
name|seg
decl_stmt|;
name|AF_Direction
name|up_dir
decl_stmt|;
name|FT_Fixed
name|scale
decl_stmt|;
name|FT_Pos
name|edge_distance_threshold
decl_stmt|;
name|FT_Pos
name|segment_length_threshold
decl_stmt|;
name|axis
operator|->
name|num_edges
operator|=
literal|0
expr_stmt|;
name|scale
operator|=
operator|(
name|dim
operator|==
name|AF_DIMENSION_HORZ
operator|)
condition|?
name|hints
operator|->
name|x_scale
else|:
name|hints
operator|->
name|y_scale
expr_stmt|;
name|up_dir
operator|=
operator|(
name|dim
operator|==
name|AF_DIMENSION_HORZ
operator|)
condition|?
name|AF_DIR_UP
else|:
name|AF_DIR_RIGHT
expr_stmt|;
comment|/*      *  We want to ignore very small (mostly serif) segments, we do that      *  by ignoring those that whose length is less than a given fraction      *  of the standard width. If there is no standard width, we ignore      *  those that are less than a given size in pixels      *      *  also, unlink serif segments that are linked to segments farther      *  than 50% of the standard width      */
if|if
condition|(
name|dim
operator|==
name|AF_DIMENSION_HORZ
condition|)
block|{
if|if
condition|(
name|laxis
operator|->
name|width_count
operator|>
literal|0
condition|)
name|segment_length_threshold
operator|=
operator|(
name|laxis
operator|->
name|standard_width
operator|*
literal|10
operator|)
operator|>>
literal|4
expr_stmt|;
else|else
name|segment_length_threshold
operator|=
name|FT_DivFix
argument_list|(
literal|64
argument_list|,
name|hints
operator|->
name|y_scale
argument_list|)
expr_stmt|;
block|}
else|else
name|segment_length_threshold
operator|=
literal|0
expr_stmt|;
comment|/*********************************************************************/
comment|/*                                                                   */
comment|/* We will begin by generating a sorted table of edges for the       */
comment|/* current direction.  To do so, we simply scan each segment and try */
comment|/* to find an edge in our table that corresponds to its position.    */
comment|/*                                                                   */
comment|/* If no edge is found, we create and insert a new edge in the       */
comment|/* sorted table.  Otherwise, we simply add the segment to the edge's */
comment|/* list which will be processed in the second step to compute the    */
comment|/* edge's properties.                                                */
comment|/*                                                                   */
comment|/* Note that the edges table is sorted along the segment/edge        */
comment|/* position.                                                         */
comment|/*                                                                   */
comment|/*********************************************************************/
name|edge_distance_threshold
operator|=
name|FT_MulFix
argument_list|(
name|laxis
operator|->
name|edge_distance_threshold
argument_list|,
name|scale
argument_list|)
expr_stmt|;
if|if
condition|(
name|edge_distance_threshold
operator|>
literal|64
operator|/
literal|4
condition|)
name|edge_distance_threshold
operator|=
literal|64
operator|/
literal|4
expr_stmt|;
name|edge_distance_threshold
operator|=
name|FT_DivFix
argument_list|(
name|edge_distance_threshold
argument_list|,
name|scale
argument_list|)
expr_stmt|;
for|for
control|(
name|seg
operator|=
name|segments
init|;
name|seg
operator|<
name|segment_limit
condition|;
name|seg
operator|++
control|)
block|{
name|AF_Edge
name|found
init|=
literal|0
decl_stmt|;
name|FT_Int
name|ee
decl_stmt|;
if|if
condition|(
name|seg
operator|->
name|height
operator|<
name|segment_length_threshold
condition|)
continue|continue;
comment|/* A special case for serif edges: If they are smaller than */
comment|/* 1.5 pixels we ignore them.                               */
if|if
condition|(
name|seg
operator|->
name|serif
condition|)
block|{
name|FT_Pos
name|dist
init|=
name|seg
operator|->
name|serif
operator|->
name|pos
operator|-
name|seg
operator|->
name|pos
decl_stmt|;
if|if
condition|(
name|dist
operator|<
literal|0
condition|)
name|dist
operator|=
operator|-
name|dist
expr_stmt|;
if|if
condition|(
name|dist
operator|>=
name|laxis
operator|->
name|standard_width
operator|>>
literal|1
condition|)
block|{
comment|/* unlink this serif, it is too distant from its reference stem */
name|seg
operator|->
name|serif
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|2
operator|*
name|seg
operator|->
name|height
operator|<
literal|3
operator|*
name|segment_length_threshold
condition|)
continue|continue;
block|}
comment|/* look for an edge corresponding to the segment */
for|for
control|(
name|ee
operator|=
literal|0
init|;
name|ee
operator|<
name|axis
operator|->
name|num_edges
condition|;
name|ee
operator|++
control|)
block|{
name|AF_Edge
name|edge
init|=
name|axis
operator|->
name|edges
operator|+
name|ee
decl_stmt|;
name|FT_Pos
name|dist
decl_stmt|;
name|dist
operator|=
name|seg
operator|->
name|pos
operator|-
name|edge
operator|->
name|fpos
expr_stmt|;
if|if
condition|(
name|dist
operator|<
literal|0
condition|)
name|dist
operator|=
operator|-
name|dist
expr_stmt|;
if|if
condition|(
name|dist
operator|<
name|edge_distance_threshold
operator|&&
name|edge
operator|->
name|dir
operator|==
name|seg
operator|->
name|dir
condition|)
block|{
name|found
operator|=
name|edge
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|AF_Edge
name|edge
decl_stmt|;
comment|/* insert a new edge in the list and */
comment|/* sort according to the position    */
name|error
operator|=
name|af_axis_hints_new_edge
argument_list|(
name|axis
argument_list|,
name|seg
operator|->
name|pos
argument_list|,
name|seg
operator|->
name|dir
argument_list|,
name|memory
argument_list|,
operator|&
name|edge
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
comment|/* add the segment to the new edge's list */
name|FT_ZERO
argument_list|(
name|edge
argument_list|)
expr_stmt|;
name|edge
operator|->
name|first
operator|=
name|seg
expr_stmt|;
name|edge
operator|->
name|last
operator|=
name|seg
expr_stmt|;
name|edge
operator|->
name|fpos
operator|=
name|seg
operator|->
name|pos
expr_stmt|;
name|edge
operator|->
name|dir
operator|=
name|seg
operator|->
name|dir
expr_stmt|;
name|edge
operator|->
name|opos
operator|=
name|edge
operator|->
name|pos
operator|=
name|FT_MulFix
argument_list|(
name|seg
operator|->
name|pos
argument_list|,
name|scale
argument_list|)
expr_stmt|;
name|seg
operator|->
name|edge_next
operator|=
name|seg
expr_stmt|;
block|}
else|else
block|{
comment|/* if an edge was found, simply add the segment to the edge's */
comment|/* list                                                       */
name|seg
operator|->
name|edge_next
operator|=
name|found
operator|->
name|first
expr_stmt|;
name|found
operator|->
name|last
operator|->
name|edge_next
operator|=
name|seg
expr_stmt|;
name|found
operator|->
name|last
operator|=
name|seg
expr_stmt|;
block|}
block|}
comment|/*********************************************************************/
comment|/*                                                                   */
comment|/* Good, we will now compute each edge's properties according to     */
comment|/* segments found on its position.  Basically, these are:            */
comment|/*                                                                   */
comment|/*  - edge's main direction                                          */
comment|/*  - stem edge, serif edge or both (which defaults to stem then)    */
comment|/*  - rounded edge, straight or both (which defaults to straight)    */
comment|/*  - link for edge                                                  */
comment|/*                                                                   */
comment|/*********************************************************************/
comment|/* first of all, set the `edge' field in each segment -- this is */
comment|/* required in order to compute edge links                       */
comment|/*      * Note that removing this loop and setting the `edge' field of each      * segment directly in the code above slows down execution speed for      * some reasons on platforms like the Sun.      */
block|{
name|AF_Edge
name|edges
init|=
name|axis
operator|->
name|edges
decl_stmt|;
name|AF_Edge
name|edge_limit
init|=
name|edges
operator|+
name|axis
operator|->
name|num_edges
decl_stmt|;
name|AF_Edge
name|edge
decl_stmt|;
for|for
control|(
name|edge
operator|=
name|edges
init|;
name|edge
operator|<
name|edge_limit
condition|;
name|edge
operator|++
control|)
block|{
name|seg
operator|=
name|edge
operator|->
name|first
expr_stmt|;
if|if
condition|(
name|seg
condition|)
do|do
block|{
name|seg
operator|->
name|edge
operator|=
name|edge
expr_stmt|;
name|seg
operator|=
name|seg
operator|->
name|edge_next
expr_stmt|;
block|}
do|while
condition|(
name|seg
operator|!=
name|edge
operator|->
name|first
condition|)
do|;
block|}
comment|/* now, compute each edge properties */
for|for
control|(
name|edge
operator|=
name|edges
init|;
name|edge
operator|<
name|edge_limit
condition|;
name|edge
operator|++
control|)
block|{
name|FT_Int
name|is_round
init|=
literal|0
decl_stmt|;
comment|/* does it contain round segments?    */
name|FT_Int
name|is_straight
init|=
literal|0
decl_stmt|;
comment|/* does it contain straight segments? */
name|FT_Pos
name|ups
init|=
literal|0
decl_stmt|;
comment|/* number of upwards segments         */
name|FT_Pos
name|downs
init|=
literal|0
decl_stmt|;
comment|/* number of downwards segments       */
name|seg
operator|=
name|edge
operator|->
name|first
expr_stmt|;
do|do
block|{
name|FT_Bool
name|is_serif
decl_stmt|;
comment|/* check for roundness of segment */
if|if
condition|(
name|seg
operator|->
name|flags
operator|&
name|AF_EDGE_ROUND
condition|)
name|is_round
operator|++
expr_stmt|;
else|else
name|is_straight
operator|++
expr_stmt|;
comment|/* check for segment direction */
if|if
condition|(
name|seg
operator|->
name|dir
operator|==
name|up_dir
condition|)
name|ups
operator|+=
name|seg
operator|->
name|max_coord
operator|-
name|seg
operator|->
name|min_coord
expr_stmt|;
else|else
name|downs
operator|+=
name|seg
operator|->
name|max_coord
operator|-
name|seg
operator|->
name|min_coord
expr_stmt|;
comment|/* check for links -- if seg->serif is set, then seg->link must */
comment|/* be ignored                                                   */
name|is_serif
operator|=
call|(
name|FT_Bool
call|)
argument_list|(
name|seg
operator|->
name|serif
operator|&&
name|seg
operator|->
name|serif
operator|->
name|edge
operator|&&
name|seg
operator|->
name|serif
operator|->
name|edge
operator|!=
name|edge
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|seg
operator|->
name|link
operator|&&
name|seg
operator|->
name|link
operator|->
name|edge
operator|!=
name|NULL
operator|)
operator|||
name|is_serif
condition|)
block|{
name|AF_Edge
name|edge2
decl_stmt|;
name|AF_Segment
name|seg2
decl_stmt|;
name|edge2
operator|=
name|edge
operator|->
name|link
expr_stmt|;
name|seg2
operator|=
name|seg
operator|->
name|link
expr_stmt|;
if|if
condition|(
name|is_serif
condition|)
block|{
name|seg2
operator|=
name|seg
operator|->
name|serif
expr_stmt|;
name|edge2
operator|=
name|edge
operator|->
name|serif
expr_stmt|;
block|}
if|if
condition|(
name|edge2
condition|)
block|{
name|FT_Pos
name|edge_delta
decl_stmt|;
name|FT_Pos
name|seg_delta
decl_stmt|;
name|edge_delta
operator|=
name|edge
operator|->
name|fpos
operator|-
name|edge2
operator|->
name|fpos
expr_stmt|;
if|if
condition|(
name|edge_delta
operator|<
literal|0
condition|)
name|edge_delta
operator|=
operator|-
name|edge_delta
expr_stmt|;
name|seg_delta
operator|=
name|seg
operator|->
name|pos
operator|-
name|seg2
operator|->
name|pos
expr_stmt|;
if|if
condition|(
name|seg_delta
operator|<
literal|0
condition|)
name|seg_delta
operator|=
operator|-
name|seg_delta
expr_stmt|;
if|if
condition|(
name|seg_delta
operator|<
name|edge_delta
condition|)
name|edge2
operator|=
name|seg2
operator|->
name|edge
expr_stmt|;
block|}
else|else
name|edge2
operator|=
name|seg2
operator|->
name|edge
expr_stmt|;
if|if
condition|(
name|is_serif
condition|)
block|{
name|edge
operator|->
name|serif
operator|=
name|edge2
expr_stmt|;
name|edge2
operator|->
name|flags
operator||=
name|AF_EDGE_SERIF
expr_stmt|;
block|}
else|else
name|edge
operator|->
name|link
operator|=
name|edge2
expr_stmt|;
block|}
name|seg
operator|=
name|seg
operator|->
name|edge_next
expr_stmt|;
block|}
do|while
condition|(
name|seg
operator|!=
name|edge
operator|->
name|first
condition|)
do|;
comment|/* set the round/straight flags */
name|edge
operator|->
name|flags
operator|=
name|AF_EDGE_NORMAL
expr_stmt|;
if|if
condition|(
name|is_round
operator|>
literal|0
operator|&&
name|is_round
operator|>=
name|is_straight
condition|)
name|edge
operator|->
name|flags
operator||=
name|AF_EDGE_ROUND
expr_stmt|;
if|#
directive|if
literal|0
comment|/* set the edge's main direction */
block|edge->dir = AF_DIR_NONE;          if ( ups> downs )           edge->dir = (FT_Char)up_dir;          else if ( ups< downs )           edge->dir = (FT_Char)-up_dir;          else if ( ups == downs )           edge->dir = 0;
comment|/* both up and down! */
endif|#
directive|endif
comment|/* gets rid of serifs if link is set                */
comment|/* XXX: This gets rid of many unpleasant artefacts! */
comment|/*      Example: the `c' in cour.pfa at size 13     */
if|if
condition|(
name|edge
operator|->
name|serif
operator|&&
name|edge
operator|->
name|link
condition|)
name|edge
operator|->
name|serif
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|Exit
label|:
return|return
name|error
return|;
block|}
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
name|af_latin2_hints_detect_features
argument_list|(
argument|AF_GlyphHints  hints
argument_list|,
argument|AF_Dimension   dim
argument_list|)
block|{
name|FT_Error
name|error
decl_stmt|;
name|error
operator|=
name|af_latin2_hints_compute_segments
argument_list|(
name|hints
argument_list|,
name|dim
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|af_latin2_hints_link_segments
argument_list|(
name|hints
argument_list|,
name|dim
argument_list|)
expr_stmt|;
name|error
operator|=
name|af_latin2_hints_compute_edges
argument_list|(
name|hints
argument_list|,
name|dim
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
DECL|function|af_latin2_hints_compute_blue_edges
name|af_latin2_hints_compute_blue_edges
argument_list|(
argument|AF_GlyphHints    hints
argument_list|,
argument|AF_LatinMetrics  metrics
argument_list|)
block|{
name|AF_AxisHints
name|axis
init|=
operator|&
name|hints
operator|->
name|axis
index|[
name|AF_DIMENSION_VERT
index|]
decl_stmt|;
name|AF_Edge
name|edge
init|=
name|axis
operator|->
name|edges
decl_stmt|;
name|AF_Edge
name|edge_limit
init|=
name|edge
operator|+
name|axis
operator|->
name|num_edges
decl_stmt|;
name|AF_LatinAxis
name|latin
init|=
operator|&
name|metrics
operator|->
name|axis
index|[
name|AF_DIMENSION_VERT
index|]
decl_stmt|;
name|FT_Fixed
name|scale
init|=
name|latin
operator|->
name|scale
decl_stmt|;
name|FT_Pos
name|best_dist0
decl_stmt|;
comment|/* initial threshold */
comment|/* compute the initial threshold as a fraction of the EM size */
name|best_dist0
operator|=
name|FT_MulFix
argument_list|(
name|metrics
operator|->
name|units_per_em
operator|/
literal|40
argument_list|,
name|scale
argument_list|)
expr_stmt|;
if|if
condition|(
name|best_dist0
operator|>
literal|64
operator|/
literal|2
condition|)
name|best_dist0
operator|=
literal|64
operator|/
literal|2
expr_stmt|;
comment|/* compute which blue zones are active, i.e. have their scaled */
comment|/* size< 3/4 pixels                                           */
comment|/* for each horizontal edge search the blue zone which is closest */
for|for
control|(
init|;
name|edge
operator|<
name|edge_limit
condition|;
name|edge
operator|++
control|)
block|{
name|FT_Int
name|bb
decl_stmt|;
name|AF_Width
name|best_blue
init|=
name|NULL
decl_stmt|;
name|FT_Pos
name|best_dist
init|=
name|best_dist0
decl_stmt|;
for|for
control|(
name|bb
operator|=
literal|0
init|;
name|bb
operator|<
name|AF_LATIN_BLUE_MAX
condition|;
name|bb
operator|++
control|)
block|{
name|AF_LatinBlue
name|blue
init|=
name|latin
operator|->
name|blues
operator|+
name|bb
decl_stmt|;
name|FT_Bool
name|is_top_blue
decl_stmt|,
name|is_major_dir
decl_stmt|;
comment|/* skip inactive blue zones (i.e., those that are too small) */
if|if
condition|(
operator|!
operator|(
name|blue
operator|->
name|flags
operator|&
name|AF_LATIN_BLUE_ACTIVE
operator|)
condition|)
continue|continue;
comment|/* if it is a top zone, check for right edges -- if it is a bottom */
comment|/* zone, check for left edges                                      */
comment|/*                                                                 */
comment|/* of course, that's for TrueType                                  */
name|is_top_blue
operator|=
call|(
name|FT_Byte
call|)
argument_list|(
operator|(
name|blue
operator|->
name|flags
operator|&
name|AF_LATIN_BLUE_TOP
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|is_major_dir
operator|=
name|FT_BOOL
argument_list|(
name|edge
operator|->
name|dir
operator|==
name|axis
operator|->
name|major_dir
argument_list|)
expr_stmt|;
comment|/* if it is a top zone, the edge must be against the major    */
comment|/* direction; if it is a bottom zone, it must be in the major */
comment|/* direction                                                  */
if|if
condition|(
name|is_top_blue
operator|^
name|is_major_dir
condition|)
block|{
name|FT_Pos
name|dist
decl_stmt|;
name|AF_Width
name|compare
decl_stmt|;
comment|/* if it's a rounded edge, compare it to the overshoot position */
comment|/* if it's a flat edge, compare it to the reference position    */
if|if
condition|(
name|edge
operator|->
name|flags
operator|&
name|AF_EDGE_ROUND
condition|)
name|compare
operator|=
operator|&
name|blue
operator|->
name|shoot
expr_stmt|;
else|else
name|compare
operator|=
operator|&
name|blue
operator|->
name|ref
expr_stmt|;
name|dist
operator|=
name|edge
operator|->
name|fpos
operator|-
name|compare
operator|->
name|org
expr_stmt|;
if|if
condition|(
name|dist
operator|<
literal|0
condition|)
name|dist
operator|=
operator|-
name|dist
expr_stmt|;
name|dist
operator|=
name|FT_MulFix
argument_list|(
name|dist
argument_list|,
name|scale
argument_list|)
expr_stmt|;
if|if
condition|(
name|dist
operator|<
name|best_dist
condition|)
block|{
name|best_dist
operator|=
name|dist
expr_stmt|;
name|best_blue
operator|=
name|compare
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* now, compare it to the overshoot position if the edge is     */
comment|/* rounded, and if the edge is over the reference position of a */
comment|/* top zone, or under the reference position of a bottom zone   */
block|if ( edge->flags& AF_EDGE_ROUND&& dist != 0 )           {             FT_Bool  is_under_ref = FT_BOOL( edge->fpos< blue->ref.org );               if ( is_top_blue ^ is_under_ref )             {               blue = latin->blues + bb;               dist = edge->fpos - blue->shoot.org;               if ( dist< 0 )                 dist = -dist;                dist = FT_MulFix( dist, scale );               if ( dist< best_dist )               {                 best_dist = dist;                 best_blue =& blue->shoot;               }             }           }
endif|#
directive|endif
block|}
block|}
if|if
condition|(
name|best_blue
condition|)
name|edge
operator|->
name|blue_edge
operator|=
name|best_blue
expr_stmt|;
block|}
block|}
specifier|static
name|FT_Error
DECL|function|af_latin2_hints_init
name|af_latin2_hints_init
parameter_list|(
name|AF_GlyphHints
name|hints
parameter_list|,
name|AF_LatinMetrics
name|metrics
parameter_list|)
block|{
name|FT_Render_Mode
name|mode
decl_stmt|;
name|FT_UInt32
name|scaler_flags
decl_stmt|,
name|other_flags
decl_stmt|;
name|FT_Face
name|face
init|=
name|metrics
operator|->
name|root
operator|.
name|scaler
operator|.
name|face
decl_stmt|;
name|af_glyph_hints_rescale
argument_list|(
name|hints
argument_list|,
operator|(
name|AF_ScriptMetrics
operator|)
name|metrics
argument_list|)
expr_stmt|;
comment|/*      *  correct x_scale and y_scale if needed, since they may have      *  been modified `af_latin2_metrics_scale_dim' above      */
name|hints
operator|->
name|x_scale
operator|=
name|metrics
operator|->
name|axis
index|[
name|AF_DIMENSION_HORZ
index|]
operator|.
name|scale
expr_stmt|;
name|hints
operator|->
name|x_delta
operator|=
name|metrics
operator|->
name|axis
index|[
name|AF_DIMENSION_HORZ
index|]
operator|.
name|delta
expr_stmt|;
name|hints
operator|->
name|y_scale
operator|=
name|metrics
operator|->
name|axis
index|[
name|AF_DIMENSION_VERT
index|]
operator|.
name|scale
expr_stmt|;
name|hints
operator|->
name|y_delta
operator|=
name|metrics
operator|->
name|axis
index|[
name|AF_DIMENSION_VERT
index|]
operator|.
name|delta
expr_stmt|;
comment|/* compute flags depending on render mode, etc. */
name|mode
operator|=
name|metrics
operator|->
name|root
operator|.
name|scaler
operator|.
name|render_mode
expr_stmt|;
if|#
directive|if
literal|0
comment|/* #ifdef AF_USE_WARPER */
block|if ( mode == FT_RENDER_MODE_LCD || mode == FT_RENDER_MODE_LCD_V )     {       metrics->root.scaler.render_mode = mode = FT_RENDER_MODE_NORMAL;     }
endif|#
directive|endif
name|scaler_flags
operator|=
name|hints
operator|->
name|scaler_flags
expr_stmt|;
name|other_flags
operator|=
literal|0
expr_stmt|;
comment|/*      *  We snap the width of vertical stems for the monochrome and      *  horizontal LCD rendering targets only.      */
if|if
condition|(
name|mode
operator|==
name|FT_RENDER_MODE_MONO
operator|||
name|mode
operator|==
name|FT_RENDER_MODE_LCD
condition|)
name|other_flags
operator||=
name|AF_LATIN_HINTS_HORZ_SNAP
expr_stmt|;
comment|/*      *  We snap the width of horizontal stems for the monochrome and      *  vertical LCD rendering targets only.      */
if|if
condition|(
name|mode
operator|==
name|FT_RENDER_MODE_MONO
operator|||
name|mode
operator|==
name|FT_RENDER_MODE_LCD_V
condition|)
name|other_flags
operator||=
name|AF_LATIN_HINTS_VERT_SNAP
expr_stmt|;
comment|/*      *  We adjust stems to full pixels only if we don't use the `light' mode.      */
if|if
condition|(
name|mode
operator|!=
name|FT_RENDER_MODE_LIGHT
condition|)
name|other_flags
operator||=
name|AF_LATIN_HINTS_STEM_ADJUST
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|FT_RENDER_MODE_MONO
condition|)
name|other_flags
operator||=
name|AF_LATIN_HINTS_MONO
expr_stmt|;
comment|/*      *  In `light' hinting mode we disable horizontal hinting completely.      *  We also do it if the face is italic.      */
if|if
condition|(
name|mode
operator|==
name|FT_RENDER_MODE_LIGHT
operator|||
operator|(
name|face
operator|->
name|style_flags
operator|&
name|FT_STYLE_FLAG_ITALIC
operator|)
operator|!=
literal|0
condition|)
name|scaler_flags
operator||=
name|AF_SCALER_FLAG_NO_HORIZONTAL
expr_stmt|;
name|hints
operator|->
name|scaler_flags
operator|=
name|scaler_flags
expr_stmt|;
name|hints
operator|->
name|other_flags
operator|=
name|other_flags
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/*************************************************************************/
comment|/*************************************************************************/
comment|/*****                                                               *****/
comment|/*****        L A T I N   G L Y P H   G R I D - F I T T I N G        *****/
comment|/*****                                                               *****/
comment|/*************************************************************************/
comment|/*************************************************************************/
comment|/* snap a given width in scaled coordinates to one of the */
comment|/* current standard widths                                */
specifier|static
name|FT_Pos
DECL|function|af_latin2_snap_width
name|af_latin2_snap_width
parameter_list|(
name|AF_Width
name|widths
parameter_list|,
name|FT_Int
name|count
parameter_list|,
name|FT_Pos
name|width
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
name|FT_Pos
name|best
init|=
literal|64
operator|+
literal|32
operator|+
literal|2
decl_stmt|;
name|FT_Pos
name|reference
init|=
name|width
decl_stmt|;
name|FT_Pos
name|scaled
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
block|{
name|FT_Pos
name|w
decl_stmt|;
name|FT_Pos
name|dist
decl_stmt|;
name|w
operator|=
name|widths
index|[
name|n
index|]
operator|.
name|cur
expr_stmt|;
name|dist
operator|=
name|width
operator|-
name|w
expr_stmt|;
if|if
condition|(
name|dist
operator|<
literal|0
condition|)
name|dist
operator|=
operator|-
name|dist
expr_stmt|;
if|if
condition|(
name|dist
operator|<
name|best
condition|)
block|{
name|best
operator|=
name|dist
expr_stmt|;
name|reference
operator|=
name|w
expr_stmt|;
block|}
block|}
name|scaled
operator|=
name|FT_PIX_ROUND
argument_list|(
name|reference
argument_list|)
expr_stmt|;
if|if
condition|(
name|width
operator|>=
name|reference
condition|)
block|{
if|if
condition|(
name|width
operator|<
name|scaled
operator|+
literal|48
condition|)
name|width
operator|=
name|reference
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|width
operator|>
name|scaled
operator|-
literal|48
condition|)
name|width
operator|=
name|reference
expr_stmt|;
block|}
return|return
name|width
return|;
block|}
comment|/* compute the snapped width of a given stem */
specifier|static
name|FT_Pos
DECL|function|af_latin2_compute_stem_width
name|af_latin2_compute_stem_width
parameter_list|(
name|AF_GlyphHints
name|hints
parameter_list|,
name|AF_Dimension
name|dim
parameter_list|,
name|FT_Pos
name|width
parameter_list|,
name|AF_Edge_Flags
name|base_flags
parameter_list|,
name|AF_Edge_Flags
name|stem_flags
parameter_list|)
block|{
name|AF_LatinMetrics
name|metrics
init|=
operator|(
name|AF_LatinMetrics
operator|)
name|hints
operator|->
name|metrics
decl_stmt|;
name|AF_LatinAxis
name|axis
init|=
operator|&
name|metrics
operator|->
name|axis
index|[
name|dim
index|]
decl_stmt|;
name|FT_Pos
name|dist
init|=
name|width
decl_stmt|;
name|FT_Int
name|sign
init|=
literal|0
decl_stmt|;
name|FT_Int
name|vertical
init|=
operator|(
name|dim
operator|==
name|AF_DIMENSION_VERT
operator|)
decl_stmt|;
name|FT_UNUSED
argument_list|(
name|base_flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|AF_LATIN_HINTS_DO_STEM_ADJUST
argument_list|(
name|hints
argument_list|)
operator|||
name|axis
operator|->
name|extra_light
condition|)
return|return
name|width
return|;
if|if
condition|(
name|dist
operator|<
literal|0
condition|)
block|{
name|dist
operator|=
operator|-
name|width
expr_stmt|;
name|sign
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|vertical
operator|&&
operator|!
name|AF_LATIN_HINTS_DO_VERT_SNAP
argument_list|(
name|hints
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|vertical
operator|&&
operator|!
name|AF_LATIN_HINTS_DO_HORZ_SNAP
argument_list|(
name|hints
argument_list|)
operator|)
condition|)
block|{
comment|/* smooth hinting process: very lightly quantize the stem width */
comment|/* leave the widths of serifs alone */
if|if
condition|(
operator|(
name|stem_flags
operator|&
name|AF_EDGE_SERIF
operator|)
operator|&&
name|vertical
operator|&&
operator|(
name|dist
operator|<
literal|3
operator|*
literal|64
operator|)
condition|)
goto|goto
name|Done_Width
goto|;
if|#
directive|if
literal|0
block|else if ( ( base_flags& AF_EDGE_ROUND ) )       {         if ( dist< 80 )           dist = 64;       }       else if ( dist< 56 )         dist = 56;
endif|#
directive|endif
if|if
condition|(
name|axis
operator|->
name|width_count
operator|>
literal|0
condition|)
block|{
name|FT_Pos
name|delta
decl_stmt|;
comment|/* compare to standard width */
if|if
condition|(
name|axis
operator|->
name|width_count
operator|>
literal|0
condition|)
block|{
name|delta
operator|=
name|dist
operator|-
name|axis
operator|->
name|widths
index|[
literal|0
index|]
operator|.
name|cur
expr_stmt|;
if|if
condition|(
name|delta
operator|<
literal|0
condition|)
name|delta
operator|=
operator|-
name|delta
expr_stmt|;
if|if
condition|(
name|delta
operator|<
literal|40
condition|)
block|{
name|dist
operator|=
name|axis
operator|->
name|widths
index|[
literal|0
index|]
operator|.
name|cur
expr_stmt|;
if|if
condition|(
name|dist
operator|<
literal|48
condition|)
name|dist
operator|=
literal|48
expr_stmt|;
goto|goto
name|Done_Width
goto|;
block|}
block|}
if|if
condition|(
name|dist
operator|<
literal|3
operator|*
literal|64
condition|)
block|{
name|delta
operator|=
name|dist
operator|&
literal|63
expr_stmt|;
name|dist
operator|&=
operator|-
literal|64
expr_stmt|;
if|if
condition|(
name|delta
operator|<
literal|10
condition|)
name|dist
operator|+=
name|delta
expr_stmt|;
elseif|else
if|if
condition|(
name|delta
operator|<
literal|32
condition|)
name|dist
operator|+=
literal|10
expr_stmt|;
elseif|else
if|if
condition|(
name|delta
operator|<
literal|54
condition|)
name|dist
operator|+=
literal|54
expr_stmt|;
else|else
name|dist
operator|+=
name|delta
expr_stmt|;
block|}
else|else
name|dist
operator|=
operator|(
name|dist
operator|+
literal|32
operator|)
operator|&
operator|~
literal|63
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* strong hinting process: snap the stem width to integer pixels */
name|FT_Pos
name|org_dist
init|=
name|dist
decl_stmt|;
name|dist
operator|=
name|af_latin2_snap_width
argument_list|(
name|axis
operator|->
name|widths
argument_list|,
name|axis
operator|->
name|width_count
argument_list|,
name|dist
argument_list|)
expr_stmt|;
if|if
condition|(
name|vertical
condition|)
block|{
comment|/* in the case of vertical hinting, always round */
comment|/* the stem heights to integer pixels            */
if|if
condition|(
name|dist
operator|>=
literal|64
condition|)
name|dist
operator|=
operator|(
name|dist
operator|+
literal|16
operator|)
operator|&
operator|~
literal|63
expr_stmt|;
else|else
name|dist
operator|=
literal|64
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|AF_LATIN_HINTS_DO_MONO
argument_list|(
name|hints
argument_list|)
condition|)
block|{
comment|/* monochrome horizontal hinting: snap widths to integer pixels */
comment|/* with a different threshold                                   */
if|if
condition|(
name|dist
operator|<
literal|64
condition|)
name|dist
operator|=
literal|64
expr_stmt|;
else|else
name|dist
operator|=
operator|(
name|dist
operator|+
literal|32
operator|)
operator|&
operator|~
literal|63
expr_stmt|;
block|}
else|else
block|{
comment|/* for horizontal anti-aliased hinting, we adopt a more subtle */
comment|/* approach: we strengthen small stems, round stems whose size */
comment|/* is between 1 and 2 pixels to an integer, otherwise nothing  */
if|if
condition|(
name|dist
operator|<
literal|48
condition|)
name|dist
operator|=
operator|(
name|dist
operator|+
literal|64
operator|)
operator|>>
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|dist
operator|<
literal|128
condition|)
block|{
comment|/* We only round to an integer width if the corresponding */
comment|/* distortion is less than 1/4 pixel.  Otherwise this     */
comment|/* makes everything worse since the diagonals, which are  */
comment|/* not hinted, appear a lot bolder or thinner than the    */
comment|/* vertical stems.                                        */
name|FT_Int
name|delta
decl_stmt|;
name|dist
operator|=
operator|(
name|dist
operator|+
literal|22
operator|)
operator|&
operator|~
literal|63
expr_stmt|;
name|delta
operator|=
name|dist
operator|-
name|org_dist
expr_stmt|;
if|if
condition|(
name|delta
operator|<
literal|0
condition|)
name|delta
operator|=
operator|-
name|delta
expr_stmt|;
if|if
condition|(
name|delta
operator|>=
literal|16
condition|)
block|{
name|dist
operator|=
name|org_dist
expr_stmt|;
if|if
condition|(
name|dist
operator|<
literal|48
condition|)
name|dist
operator|=
operator|(
name|dist
operator|+
literal|64
operator|)
operator|>>
literal|1
expr_stmt|;
block|}
block|}
else|else
comment|/* round otherwise to prevent color fringes in LCD mode */
name|dist
operator|=
operator|(
name|dist
operator|+
literal|32
operator|)
operator|&
operator|~
literal|63
expr_stmt|;
block|}
block|}
block|}
name|Done_Width
label|:
if|if
condition|(
name|sign
condition|)
name|dist
operator|=
operator|-
name|dist
expr_stmt|;
return|return
name|dist
return|;
block|}
comment|/* align one stem edge relative to the previous stem edge */
specifier|static
name|void
DECL|function|af_latin2_align_linked_edge
name|af_latin2_align_linked_edge
parameter_list|(
name|AF_GlyphHints
name|hints
parameter_list|,
name|AF_Dimension
name|dim
parameter_list|,
name|AF_Edge
name|base_edge
parameter_list|,
name|AF_Edge
name|stem_edge
parameter_list|)
block|{
name|FT_Pos
name|dist
init|=
name|stem_edge
operator|->
name|opos
operator|-
name|base_edge
operator|->
name|opos
decl_stmt|;
name|FT_Pos
name|fitted_width
init|=
name|af_latin2_compute_stem_width
argument_list|(
name|hints
argument_list|,
name|dim
argument_list|,
name|dist
argument_list|,
operator|(
name|AF_Edge_Flags
operator|)
name|base_edge
operator|->
name|flags
argument_list|,
operator|(
name|AF_Edge_Flags
operator|)
name|stem_edge
operator|->
name|flags
argument_list|)
decl_stmt|;
name|stem_edge
operator|->
name|pos
operator|=
name|base_edge
operator|->
name|pos
operator|+
name|fitted_width
expr_stmt|;
name|AF_LOG
argument_list|(
operator|(
literal|"LINK: edge %d (opos=%.2f) linked to (%.2f), "
literal|"dist was %.2f, now %.2f\n"
operator|,
name|stem_edge
operator|-
name|hints
operator|->
name|axis
index|[
name|dim
index|]
operator|.
name|edges
operator|,
name|stem_edge
operator|->
name|opos
operator|/
literal|64.0
operator|,
name|stem_edge
operator|->
name|pos
operator|/
literal|64.0
operator|,
name|dist
operator|/
literal|64.0
operator|,
name|fitted_width
operator|/
literal|64.0
operator|)
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
DECL|function|af_latin2_align_serif_edge
name|af_latin2_align_serif_edge
parameter_list|(
name|AF_GlyphHints
name|hints
parameter_list|,
name|AF_Edge
name|base
parameter_list|,
name|AF_Edge
name|serif
parameter_list|)
block|{
name|FT_UNUSED
argument_list|(
name|hints
argument_list|)
expr_stmt|;
name|serif
operator|->
name|pos
operator|=
name|base
operator|->
name|pos
operator|+
operator|(
name|serif
operator|->
name|opos
operator|-
name|base
operator|->
name|opos
operator|)
expr_stmt|;
block|}
comment|/*************************************************************************/
comment|/*************************************************************************/
comment|/*************************************************************************/
comment|/****                                                                 ****/
comment|/****                    E D G E   H I N T I N G                      ****/
comment|/****                                                                 ****/
comment|/*************************************************************************/
comment|/*************************************************************************/
comment|/*************************************************************************/
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
DECL|function|af_latin2_hint_edges
name|af_latin2_hint_edges
argument_list|(
argument|AF_GlyphHints  hints
argument_list|,
argument|AF_Dimension   dim
argument_list|)
block|{
name|AF_AxisHints
name|axis
init|=
operator|&
name|hints
operator|->
name|axis
index|[
name|dim
index|]
decl_stmt|;
name|AF_Edge
name|edges
init|=
name|axis
operator|->
name|edges
decl_stmt|;
name|AF_Edge
name|edge_limit
init|=
name|edges
operator|+
name|axis
operator|->
name|num_edges
decl_stmt|;
name|AF_Edge
name|edge
decl_stmt|;
name|AF_Edge
name|anchor
init|=
literal|0
decl_stmt|;
name|FT_Int
name|has_serifs
init|=
literal|0
decl_stmt|;
name|FT_Pos
name|anchor_drift
init|=
literal|0
decl_stmt|;
name|AF_LOG
argument_list|(
operator|(
literal|"==== hinting %s edges =====\n"
operator|,
name|dim
operator|==
name|AF_DIMENSION_HORZ
condition|?
literal|"vertical"
else|:
literal|"horizontal"
operator|)
argument_list|)
expr_stmt|;
comment|/* we begin by aligning all stems relative to the blue zone */
comment|/* if needed -- that's only for horizontal edges            */
if|if
condition|(
name|dim
operator|==
name|AF_DIMENSION_VERT
operator|&&
name|AF_HINTS_DO_BLUES
argument_list|(
name|hints
argument_list|)
condition|)
block|{
for|for
control|(
name|edge
operator|=
name|edges
init|;
name|edge
operator|<
name|edge_limit
condition|;
name|edge
operator|++
control|)
block|{
name|AF_Width
name|blue
decl_stmt|;
name|AF_Edge
name|edge1
decl_stmt|,
name|edge2
decl_stmt|;
if|if
condition|(
name|edge
operator|->
name|flags
operator|&
name|AF_EDGE_DONE
condition|)
continue|continue;
name|blue
operator|=
name|edge
operator|->
name|blue_edge
expr_stmt|;
name|edge1
operator|=
name|NULL
expr_stmt|;
name|edge2
operator|=
name|edge
operator|->
name|link
expr_stmt|;
if|if
condition|(
name|blue
condition|)
block|{
name|edge1
operator|=
name|edge
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|edge2
operator|&&
name|edge2
operator|->
name|blue_edge
condition|)
block|{
name|blue
operator|=
name|edge2
operator|->
name|blue_edge
expr_stmt|;
name|edge1
operator|=
name|edge2
expr_stmt|;
name|edge2
operator|=
name|edge
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|edge1
condition|)
continue|continue;
name|AF_LOG
argument_list|(
operator|(
literal|"BLUE: edge %d (opos=%.2f) snapped to (%.2f), "
literal|"was (%.2f)\n"
operator|,
name|edge1
operator|-
name|edges
operator|,
name|edge1
operator|->
name|opos
operator|/
literal|64.0
operator|,
name|blue
operator|->
name|fit
operator|/
literal|64.0
operator|,
name|edge1
operator|->
name|pos
operator|/
literal|64.0
operator|)
argument_list|)
expr_stmt|;
name|edge1
operator|->
name|pos
operator|=
name|blue
operator|->
name|fit
expr_stmt|;
name|edge1
operator|->
name|flags
operator||=
name|AF_EDGE_DONE
expr_stmt|;
if|if
condition|(
name|edge2
operator|&&
operator|!
name|edge2
operator|->
name|blue_edge
condition|)
block|{
name|af_latin2_align_linked_edge
argument_list|(
name|hints
argument_list|,
name|dim
argument_list|,
name|edge1
argument_list|,
name|edge2
argument_list|)
expr_stmt|;
name|edge2
operator|->
name|flags
operator||=
name|AF_EDGE_DONE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|anchor
condition|)
block|{
name|anchor
operator|=
name|edge
expr_stmt|;
name|anchor_drift
operator|=
operator|(
name|anchor
operator|->
name|pos
operator|-
name|anchor
operator|->
name|opos
operator|)
expr_stmt|;
if|if
condition|(
name|edge2
condition|)
name|anchor_drift
operator|=
operator|(
name|anchor_drift
operator|+
operator|(
name|edge2
operator|->
name|pos
operator|-
name|edge2
operator|->
name|opos
operator|)
operator|)
operator|>>
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|/* now we will align all stem edges, trying to maintain the */
comment|/* relative order of stems in the glyph                     */
for|for
control|(
name|edge
operator|=
name|edges
init|;
name|edge
operator|<
name|edge_limit
condition|;
name|edge
operator|++
control|)
block|{
name|AF_Edge
name|edge2
decl_stmt|;
if|if
condition|(
name|edge
operator|->
name|flags
operator|&
name|AF_EDGE_DONE
condition|)
continue|continue;
comment|/* skip all non-stem edges */
name|edge2
operator|=
name|edge
operator|->
name|link
expr_stmt|;
if|if
condition|(
operator|!
name|edge2
condition|)
block|{
name|has_serifs
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* now align the stem */
comment|/* this should not happen, but it's better to be safe */
if|if
condition|(
name|edge2
operator|->
name|blue_edge
condition|)
block|{
name|AF_LOG
argument_list|(
operator|(
literal|"ASSERTION FAILED for edge %d\n"
operator|,
name|edge2
operator|-
name|edges
operator|)
argument_list|)
expr_stmt|;
name|af_latin2_align_linked_edge
argument_list|(
name|hints
argument_list|,
name|dim
argument_list|,
name|edge2
argument_list|,
name|edge
argument_list|)
expr_stmt|;
name|edge
operator|->
name|flags
operator||=
name|AF_EDGE_DONE
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|anchor
condition|)
block|{
name|FT_Pos
name|org_len
decl_stmt|,
name|org_center
decl_stmt|,
name|cur_len
decl_stmt|;
name|FT_Pos
name|cur_pos1
decl_stmt|,
name|error1
decl_stmt|,
name|error2
decl_stmt|,
name|u_off
decl_stmt|,
name|d_off
decl_stmt|;
name|org_len
operator|=
name|edge2
operator|->
name|opos
operator|-
name|edge
operator|->
name|opos
expr_stmt|;
name|cur_len
operator|=
name|af_latin2_compute_stem_width
argument_list|(
name|hints
argument_list|,
name|dim
argument_list|,
name|org_len
argument_list|,
operator|(
name|AF_Edge_Flags
operator|)
name|edge
operator|->
name|flags
argument_list|,
operator|(
name|AF_Edge_Flags
operator|)
name|edge2
operator|->
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur_len
operator|<=
literal|64
condition|)
name|u_off
operator|=
name|d_off
operator|=
literal|32
expr_stmt|;
else|else
block|{
name|u_off
operator|=
literal|38
expr_stmt|;
name|d_off
operator|=
literal|26
expr_stmt|;
block|}
if|if
condition|(
name|cur_len
operator|<
literal|96
condition|)
block|{
name|org_center
operator|=
name|edge
operator|->
name|opos
operator|+
operator|(
name|org_len
operator|>>
literal|1
operator|)
expr_stmt|;
name|cur_pos1
operator|=
name|FT_PIX_ROUND
argument_list|(
name|org_center
argument_list|)
expr_stmt|;
name|error1
operator|=
name|org_center
operator|-
operator|(
name|cur_pos1
operator|-
name|u_off
operator|)
expr_stmt|;
if|if
condition|(
name|error1
operator|<
literal|0
condition|)
name|error1
operator|=
operator|-
name|error1
expr_stmt|;
name|error2
operator|=
name|org_center
operator|-
operator|(
name|cur_pos1
operator|+
name|d_off
operator|)
expr_stmt|;
if|if
condition|(
name|error2
operator|<
literal|0
condition|)
name|error2
operator|=
operator|-
name|error2
expr_stmt|;
if|if
condition|(
name|error1
operator|<
name|error2
condition|)
name|cur_pos1
operator|-=
name|u_off
expr_stmt|;
else|else
name|cur_pos1
operator|+=
name|d_off
expr_stmt|;
name|edge
operator|->
name|pos
operator|=
name|cur_pos1
operator|-
name|cur_len
operator|/
literal|2
expr_stmt|;
name|edge2
operator|->
name|pos
operator|=
name|edge
operator|->
name|pos
operator|+
name|cur_len
expr_stmt|;
block|}
else|else
name|edge
operator|->
name|pos
operator|=
name|FT_PIX_ROUND
argument_list|(
name|edge
operator|->
name|opos
argument_list|)
expr_stmt|;
name|AF_LOG
argument_list|(
operator|(
literal|"ANCHOR: edge %d (opos=%.2f) and %d (opos=%.2f) "
literal|"snapped to (%.2f) (%.2f)\n"
operator|,
name|edge
operator|-
name|edges
operator|,
name|edge
operator|->
name|opos
operator|/
literal|64.0
operator|,
name|edge2
operator|-
name|edges
operator|,
name|edge2
operator|->
name|opos
operator|/
literal|64.0
operator|,
name|edge
operator|->
name|pos
operator|/
literal|64.0
operator|,
name|edge2
operator|->
name|pos
operator|/
literal|64.0
operator|)
argument_list|)
expr_stmt|;
name|anchor
operator|=
name|edge
expr_stmt|;
name|edge
operator|->
name|flags
operator||=
name|AF_EDGE_DONE
expr_stmt|;
name|af_latin2_align_linked_edge
argument_list|(
name|hints
argument_list|,
name|dim
argument_list|,
name|edge
argument_list|,
name|edge2
argument_list|)
expr_stmt|;
name|edge2
operator|->
name|flags
operator||=
name|AF_EDGE_DONE
expr_stmt|;
name|anchor_drift
operator|=
operator|(
operator|(
name|anchor
operator|->
name|pos
operator|-
name|anchor
operator|->
name|opos
operator|)
operator|+
operator|(
name|edge2
operator|->
name|pos
operator|-
name|edge2
operator|->
name|opos
operator|)
operator|)
operator|>>
literal|1
expr_stmt|;
name|AF_LOG
argument_list|(
operator|(
literal|"DRIFT: %.2f\n"
operator|,
name|anchor_drift
operator|/
literal|64.0
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|FT_Pos
name|org_pos
decl_stmt|,
name|org_len
decl_stmt|,
name|org_center
decl_stmt|,
name|cur_center
decl_stmt|,
name|cur_len
decl_stmt|;
name|FT_Pos
name|org_left
decl_stmt|,
name|org_right
decl_stmt|;
name|org_pos
operator|=
name|edge
operator|->
name|opos
operator|+
name|anchor_drift
expr_stmt|;
name|org_len
operator|=
name|edge2
operator|->
name|opos
operator|-
name|edge
operator|->
name|opos
expr_stmt|;
name|org_center
operator|=
name|org_pos
operator|+
operator|(
name|org_len
operator|>>
literal|1
operator|)
expr_stmt|;
name|cur_len
operator|=
name|af_latin2_compute_stem_width
argument_list|(
name|hints
argument_list|,
name|dim
argument_list|,
name|org_len
argument_list|,
operator|(
name|AF_Edge_Flags
operator|)
name|edge
operator|->
name|flags
argument_list|,
operator|(
name|AF_Edge_Flags
operator|)
name|edge2
operator|->
name|flags
argument_list|)
expr_stmt|;
name|org_left
operator|=
name|org_pos
operator|+
operator|(
operator|(
name|org_len
operator|-
name|cur_len
operator|)
operator|>>
literal|1
operator|)
expr_stmt|;
name|org_right
operator|=
name|org_pos
operator|+
operator|(
operator|(
name|org_len
operator|+
name|cur_len
operator|)
operator|>>
literal|1
operator|)
expr_stmt|;
name|AF_LOG
argument_list|(
operator|(
literal|"ALIGN: left=%.2f right=%.2f "
operator|,
name|org_left
operator|/
literal|64.0
operator|,
name|org_right
operator|/
literal|64.0
operator|)
argument_list|)
expr_stmt|;
name|cur_center
operator|=
name|org_center
expr_stmt|;
if|if
condition|(
name|edge2
operator|->
name|flags
operator|&
name|AF_EDGE_DONE
condition|)
block|{
name|AF_LOG
argument_list|(
operator|(
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
name|edge
operator|->
name|pos
operator|=
name|edge2
operator|->
name|pos
operator|-
name|cur_len
expr_stmt|;
block|}
else|else
block|{
comment|/* we want to compare several displacement, and choose           * the one that increases fitness while minimizing           * distortion as well           */
name|FT_Pos
name|displacements
index|[
literal|6
index|]
decl_stmt|,
name|scores
index|[
literal|6
index|]
decl_stmt|,
name|org
decl_stmt|,
name|fit
decl_stmt|,
name|delta
decl_stmt|;
name|FT_UInt
name|count
init|=
literal|0
decl_stmt|;
comment|/* note: don't even try to fit tiny stems */
if|if
condition|(
name|cur_len
operator|<
literal|32
condition|)
block|{
name|AF_LOG
argument_list|(
operator|(
literal|"tiny stem\n"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|AlignStem
goto|;
block|}
comment|/* if the span is within a single pixel, don't touch it */
if|if
condition|(
name|FT_PIX_FLOOR
argument_list|(
name|org_left
argument_list|)
operator|==
name|FT_PIX_CEIL
argument_list|(
name|org_right
argument_list|)
condition|)
block|{
name|AF_LOG
argument_list|(
operator|(
literal|"single pixel stem\n"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|AlignStem
goto|;
block|}
if|if
condition|(
name|cur_len
operator|<=
literal|96
condition|)
block|{
comment|/* we want to avoid the absolute worst case which is             * when the left and right edges of the span each represent             * about 50% of the gray. we'd better want to change this             * to 25/75%, since this is much more pleasant to the eye with             * very acceptable distortion             */
name|FT_Pos
name|frac_left
init|=
operator|(
name|org_left
operator|)
operator|&
literal|63
decl_stmt|;
name|FT_Pos
name|frac_right
init|=
operator|(
name|org_right
operator|)
operator|&
literal|63
decl_stmt|;
if|if
condition|(
name|frac_left
operator|>=
literal|22
operator|&&
name|frac_left
operator|<=
literal|42
operator|&&
name|frac_right
operator|>=
literal|22
operator|&&
name|frac_right
operator|<=
literal|42
condition|)
block|{
name|org
operator|=
name|frac_left
expr_stmt|;
name|fit
operator|=
operator|(
name|org
operator|<=
literal|32
operator|)
condition|?
literal|16
else|:
literal|48
expr_stmt|;
name|delta
operator|=
name|FT_ABS
argument_list|(
name|fit
operator|-
name|org
argument_list|)
expr_stmt|;
name|displacements
index|[
name|count
index|]
operator|=
name|fit
operator|-
name|org
expr_stmt|;
name|scores
index|[
name|count
operator|++
index|]
operator|=
name|delta
expr_stmt|;
name|AF_LOG
argument_list|(
operator|(
literal|"dispA=%.2f (%d) "
operator|,
operator|(
name|fit
operator|-
name|org
operator|)
operator|/
literal|64.0
operator|,
name|delta
operator|)
argument_list|)
expr_stmt|;
name|org
operator|=
name|frac_right
expr_stmt|;
name|fit
operator|=
operator|(
name|org
operator|<=
literal|32
operator|)
condition|?
literal|16
else|:
literal|48
expr_stmt|;
name|delta
operator|=
name|FT_ABS
argument_list|(
name|fit
operator|-
name|org
argument_list|)
expr_stmt|;
name|displacements
index|[
name|count
index|]
operator|=
name|fit
operator|-
name|org
expr_stmt|;
name|scores
index|[
name|count
operator|++
index|]
operator|=
name|delta
expr_stmt|;
name|AF_LOG
argument_list|(
operator|(
literal|"dispB=%.2f (%d) "
operator|,
operator|(
name|fit
operator|-
name|org
operator|)
operator|/
literal|64.0
operator|,
name|delta
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* snapping the left edge to the grid */
name|org
operator|=
name|org_left
expr_stmt|;
name|fit
operator|=
name|FT_PIX_ROUND
argument_list|(
name|org
argument_list|)
expr_stmt|;
name|delta
operator|=
name|FT_ABS
argument_list|(
name|fit
operator|-
name|org
argument_list|)
expr_stmt|;
name|displacements
index|[
name|count
index|]
operator|=
name|fit
operator|-
name|org
expr_stmt|;
name|scores
index|[
name|count
operator|++
index|]
operator|=
name|delta
expr_stmt|;
name|AF_LOG
argument_list|(
operator|(
literal|"dispC=%.2f (%d) "
operator|,
operator|(
name|fit
operator|-
name|org
operator|)
operator|/
literal|64.0
operator|,
name|delta
operator|)
argument_list|)
expr_stmt|;
comment|/* snapping the right edge to the grid */
name|org
operator|=
name|org_right
expr_stmt|;
name|fit
operator|=
name|FT_PIX_ROUND
argument_list|(
name|org
argument_list|)
expr_stmt|;
name|delta
operator|=
name|FT_ABS
argument_list|(
name|fit
operator|-
name|org
argument_list|)
expr_stmt|;
name|displacements
index|[
name|count
index|]
operator|=
name|fit
operator|-
name|org
expr_stmt|;
name|scores
index|[
name|count
operator|++
index|]
operator|=
name|delta
expr_stmt|;
name|AF_LOG
argument_list|(
operator|(
literal|"dispD=%.2f (%d) "
operator|,
operator|(
name|fit
operator|-
name|org
operator|)
operator|/
literal|64.0
operator|,
name|delta
operator|)
argument_list|)
expr_stmt|;
comment|/* now find the best displacement */
block|{
name|FT_Pos
name|best_score
init|=
name|scores
index|[
literal|0
index|]
decl_stmt|;
name|FT_Pos
name|best_disp
init|=
name|displacements
index|[
literal|0
index|]
decl_stmt|;
name|FT_UInt
name|nn
decl_stmt|;
for|for
control|(
name|nn
operator|=
literal|1
init|;
name|nn
operator|<
name|count
condition|;
name|nn
operator|++
control|)
block|{
if|if
condition|(
name|scores
index|[
name|nn
index|]
operator|<
name|best_score
condition|)
block|{
name|best_score
operator|=
name|scores
index|[
name|nn
index|]
expr_stmt|;
name|best_disp
operator|=
name|displacements
index|[
name|nn
index|]
expr_stmt|;
block|}
block|}
name|cur_center
operator|=
name|org_center
operator|+
name|best_disp
expr_stmt|;
block|}
name|AF_LOG
argument_list|(
operator|(
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
block|}
name|AlignStem
label|:
name|edge
operator|->
name|pos
operator|=
name|cur_center
operator|-
operator|(
name|cur_len
operator|>>
literal|1
operator|)
expr_stmt|;
name|edge2
operator|->
name|pos
operator|=
name|edge
operator|->
name|pos
operator|+
name|cur_len
expr_stmt|;
name|AF_LOG
argument_list|(
operator|(
literal|"STEM1: %d (opos=%.2f) to %d (opos=%.2f) "
literal|"snapped to (%.2f) and (%.2f), org_len = %.2f cur_len=%.2f\n"
operator|,
name|edge
operator|-
name|edges
operator|,
name|edge
operator|->
name|opos
operator|/
literal|64.0
operator|,
name|edge2
operator|-
name|edges
operator|,
name|edge2
operator|->
name|opos
operator|/
literal|64.0
operator|,
name|edge
operator|->
name|pos
operator|/
literal|64.0
operator|,
name|edge2
operator|->
name|pos
operator|/
literal|64.0
operator|,
name|org_len
operator|/
literal|64.0
operator|,
name|cur_len
operator|/
literal|64.0
operator|)
argument_list|)
expr_stmt|;
name|edge
operator|->
name|flags
operator||=
name|AF_EDGE_DONE
expr_stmt|;
name|edge2
operator|->
name|flags
operator||=
name|AF_EDGE_DONE
expr_stmt|;
if|if
condition|(
name|edge
operator|>
name|edges
operator|&&
name|edge
operator|->
name|pos
operator|<
name|edge
index|[
operator|-
literal|1
index|]
operator|.
name|pos
condition|)
block|{
name|AF_LOG
argument_list|(
operator|(
literal|"BOUND: %d (pos=%.2f) to (%.2f)\n"
operator|,
name|edge
operator|-
name|edges
operator|,
name|edge
operator|->
name|pos
operator|/
literal|64.0
operator|,
name|edge
index|[
operator|-
literal|1
index|]
operator|.
name|pos
operator|/
literal|64.0
operator|)
argument_list|)
expr_stmt|;
name|edge
operator|->
name|pos
operator|=
name|edge
index|[
operator|-
literal|1
index|]
operator|.
name|pos
expr_stmt|;
block|}
block|}
block|}
comment|/* make sure that lowercase m's maintain their symmetry */
comment|/* In general, lowercase m's have six vertical edges if they are sans */
comment|/* serif, or twelve if they are with serifs.  This implementation is  */
comment|/* based on that assumption, and seems to work very well with most    */
comment|/* faces.  However, if for a certain face this assumption is not      */
comment|/* true, the m is just rendered like before.  In addition, any stem   */
comment|/* correction will only be applied to symmetrical glyphs (even if the */
comment|/* glyph is not an m), so the potential for unwanted distortion is    */
comment|/* relatively low.                                                    */
comment|/* We don't handle horizontal edges since we can't easily assure that */
comment|/* the third (lowest) stem aligns with the base line; it might end up */
comment|/* one pixel higher or lower.                                         */
if|#
directive|if
literal|0
block|{       FT_Int  n_edges = edge_limit - edges;         if ( dim == AF_DIMENSION_HORZ&& ( n_edges == 6 || n_edges == 12 ) )       {         AF_Edge  edge1, edge2, edge3;         FT_Pos   dist1, dist2, span, delta;           if ( n_edges == 6 )         {           edge1 = edges;           edge2 = edges + 2;           edge3 = edges + 4;         }         else         {           edge1 = edges + 1;           edge2 = edges + 5;           edge3 = edges + 9;         }          dist1 = edge2->opos - edge1->opos;         dist2 = edge3->opos - edge2->opos;          span = dist1 - dist2;         if ( span< 0 )           span = -span;          if ( span< 8 )         {           delta = edge3->pos - ( 2 * edge2->pos - edge1->pos );           edge3->pos -= delta;           if ( edge3->link )             edge3->link->pos -= delta;
comment|/* move the serifs along with the stem */
block|if ( n_edges == 12 )           {             ( edges + 8 )->pos -= delta;             ( edges + 11 )->pos -= delta;           }            edge3->flags |= AF_EDGE_DONE;           if ( edge3->link )             edge3->link->flags |= AF_EDGE_DONE;         }       }     }
endif|#
directive|endif
if|if
condition|(
name|has_serifs
operator|||
operator|!
name|anchor
condition|)
block|{
comment|/*        *  now hint the remaining edges (serifs and single) in order        *  to complete our processing        */
for|for
control|(
name|edge
operator|=
name|edges
init|;
name|edge
operator|<
name|edge_limit
condition|;
name|edge
operator|++
control|)
block|{
name|FT_Pos
name|delta
decl_stmt|;
if|if
condition|(
name|edge
operator|->
name|flags
operator|&
name|AF_EDGE_DONE
condition|)
continue|continue;
name|delta
operator|=
literal|1000
expr_stmt|;
if|if
condition|(
name|edge
operator|->
name|serif
condition|)
block|{
name|delta
operator|=
name|edge
operator|->
name|serif
operator|->
name|opos
operator|-
name|edge
operator|->
name|opos
expr_stmt|;
if|if
condition|(
name|delta
operator|<
literal|0
condition|)
name|delta
operator|=
operator|-
name|delta
expr_stmt|;
block|}
if|if
condition|(
name|delta
operator|<
literal|64
operator|+
literal|16
condition|)
block|{
name|af_latin2_align_serif_edge
argument_list|(
name|hints
argument_list|,
name|edge
operator|->
name|serif
argument_list|,
name|edge
argument_list|)
expr_stmt|;
name|AF_LOG
argument_list|(
operator|(
literal|"SERIF: edge %d (opos=%.2f) serif to %d (opos=%.2f) "
literal|"aligned to (%.2f)\n"
operator|,
name|edge
operator|-
name|edges
operator|,
name|edge
operator|->
name|opos
operator|/
literal|64.0
operator|,
name|edge
operator|->
name|serif
operator|-
name|edges
operator|,
name|edge
operator|->
name|serif
operator|->
name|opos
operator|/
literal|64.0
operator|,
name|edge
operator|->
name|pos
operator|/
literal|64.0
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|anchor
condition|)
block|{
name|AF_LOG
argument_list|(
operator|(
literal|"SERIF_ANCHOR: edge %d (opos=%.2f) snapped to (%.2f)\n"
operator|,
name|edge
operator|-
name|edges
operator|,
name|edge
operator|->
name|opos
operator|/
literal|64.0
operator|,
name|edge
operator|->
name|pos
operator|/
literal|64.0
operator|)
argument_list|)
expr_stmt|;
name|edge
operator|->
name|pos
operator|=
name|FT_PIX_ROUND
argument_list|(
name|edge
operator|->
name|opos
argument_list|)
expr_stmt|;
name|anchor
operator|=
name|edge
expr_stmt|;
block|}
else|else
block|{
name|AF_Edge
name|before
decl_stmt|,
name|after
decl_stmt|;
for|for
control|(
name|before
operator|=
name|edge
operator|-
literal|1
init|;
name|before
operator|>=
name|edges
condition|;
name|before
operator|--
control|)
if|if
condition|(
name|before
operator|->
name|flags
operator|&
name|AF_EDGE_DONE
condition|)
break|break;
for|for
control|(
name|after
operator|=
name|edge
operator|+
literal|1
init|;
name|after
operator|<
name|edge_limit
condition|;
name|after
operator|++
control|)
if|if
condition|(
name|after
operator|->
name|flags
operator|&
name|AF_EDGE_DONE
condition|)
break|break;
if|if
condition|(
name|before
operator|>=
name|edges
operator|&&
name|before
operator|<
name|edge
operator|&&
name|after
operator|<
name|edge_limit
operator|&&
name|after
operator|>
name|edge
condition|)
block|{
if|if
condition|(
name|after
operator|->
name|opos
operator|==
name|before
operator|->
name|opos
condition|)
name|edge
operator|->
name|pos
operator|=
name|before
operator|->
name|pos
expr_stmt|;
else|else
name|edge
operator|->
name|pos
operator|=
name|before
operator|->
name|pos
operator|+
name|FT_MulDiv
argument_list|(
name|edge
operator|->
name|opos
operator|-
name|before
operator|->
name|opos
argument_list|,
name|after
operator|->
name|pos
operator|-
name|before
operator|->
name|pos
argument_list|,
name|after
operator|->
name|opos
operator|-
name|before
operator|->
name|opos
argument_list|)
expr_stmt|;
name|AF_LOG
argument_list|(
operator|(
literal|"SERIF_LINK1: edge %d (opos=%.2f) snapped to (%.2f) from %d (opos=%.2f)\n"
operator|,
name|edge
operator|-
name|edges
operator|,
name|edge
operator|->
name|opos
operator|/
literal|64.0
operator|,
name|edge
operator|->
name|pos
operator|/
literal|64.0
operator|,
name|before
operator|-
name|edges
operator|,
name|before
operator|->
name|opos
operator|/
literal|64.0
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|edge
operator|->
name|pos
operator|=
name|anchor
operator|->
name|pos
operator|+
operator|(
operator|(
name|edge
operator|->
name|opos
operator|-
name|anchor
operator|->
name|opos
operator|+
literal|16
operator|)
operator|&
operator|~
literal|31
operator|)
expr_stmt|;
name|AF_LOG
argument_list|(
operator|(
literal|"SERIF_LINK2: edge %d (opos=%.2f) snapped to (%.2f)\n"
operator|,
name|edge
operator|-
name|edges
operator|,
name|edge
operator|->
name|opos
operator|/
literal|64.0
operator|,
name|edge
operator|->
name|pos
operator|/
literal|64.0
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
name|edge
operator|->
name|flags
operator||=
name|AF_EDGE_DONE
expr_stmt|;
if|if
condition|(
name|edge
operator|>
name|edges
operator|&&
name|edge
operator|->
name|pos
operator|<
name|edge
index|[
operator|-
literal|1
index|]
operator|.
name|pos
condition|)
name|edge
operator|->
name|pos
operator|=
name|edge
index|[
operator|-
literal|1
index|]
operator|.
name|pos
expr_stmt|;
if|if
condition|(
name|edge
operator|+
literal|1
operator|<
name|edge_limit
operator|&&
name|edge
index|[
literal|1
index|]
operator|.
name|flags
operator|&
name|AF_EDGE_DONE
operator|&&
name|edge
operator|->
name|pos
operator|>
name|edge
index|[
literal|1
index|]
operator|.
name|pos
condition|)
name|edge
operator|->
name|pos
operator|=
name|edge
index|[
literal|1
index|]
operator|.
name|pos
expr_stmt|;
block|}
block|}
block|}
specifier|static
name|FT_Error
DECL|function|af_latin2_hints_apply
name|af_latin2_hints_apply
parameter_list|(
name|AF_GlyphHints
name|hints
parameter_list|,
name|FT_Outline
modifier|*
name|outline
parameter_list|,
name|AF_LatinMetrics
name|metrics
parameter_list|)
block|{
name|FT_Error
name|error
decl_stmt|;
name|int
name|dim
decl_stmt|;
name|error
operator|=
name|af_glyph_hints_reload
argument_list|(
name|hints
argument_list|,
name|outline
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
comment|/* analyze glyph outline */
ifdef|#
directive|ifdef
name|AF_USE_WARPER
if|if
condition|(
name|metrics
operator|->
name|root
operator|.
name|scaler
operator|.
name|render_mode
operator|==
name|FT_RENDER_MODE_LIGHT
operator|||
name|AF_HINTS_DO_HORIZONTAL
argument_list|(
name|hints
argument_list|)
condition|)
else|#
directive|else
if|if
condition|(
name|AF_HINTS_DO_HORIZONTAL
argument_list|(
name|hints
argument_list|)
condition|)
endif|#
directive|endif
block|{
name|error
operator|=
name|af_latin2_hints_detect_features
argument_list|(
name|hints
argument_list|,
name|AF_DIMENSION_HORZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|AF_HINTS_DO_VERTICAL
argument_list|(
name|hints
argument_list|)
condition|)
block|{
name|error
operator|=
name|af_latin2_hints_detect_features
argument_list|(
name|hints
argument_list|,
name|AF_DIMENSION_VERT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|af_latin2_hints_compute_blue_edges
argument_list|(
name|hints
argument_list|,
name|metrics
argument_list|)
expr_stmt|;
block|}
comment|/* grid-fit the outline */
for|for
control|(
name|dim
operator|=
literal|0
init|;
name|dim
operator|<
name|AF_DIMENSION_MAX
condition|;
name|dim
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|AF_USE_WARPER
if|if
condition|(
operator|(
name|dim
operator|==
name|AF_DIMENSION_HORZ
operator|&&
name|metrics
operator|->
name|root
operator|.
name|scaler
operator|.
name|render_mode
operator|==
name|FT_RENDER_MODE_LIGHT
operator|)
condition|)
block|{
name|AF_WarperRec
name|warper
decl_stmt|;
name|FT_Fixed
name|scale
decl_stmt|;
name|FT_Pos
name|delta
decl_stmt|;
name|af_warper_compute
argument_list|(
operator|&
name|warper
argument_list|,
name|hints
argument_list|,
name|dim
argument_list|,
operator|&
name|scale
argument_list|,
operator|&
name|delta
argument_list|)
expr_stmt|;
name|af_glyph_hints_scale_dim
argument_list|(
name|hints
argument_list|,
name|dim
argument_list|,
name|scale
argument_list|,
name|delta
argument_list|)
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|dim
operator|==
name|AF_DIMENSION_HORZ
operator|&&
name|AF_HINTS_DO_HORIZONTAL
argument_list|(
name|hints
argument_list|)
operator|)
operator|||
operator|(
name|dim
operator|==
name|AF_DIMENSION_VERT
operator|&&
name|AF_HINTS_DO_VERTICAL
argument_list|(
name|hints
argument_list|)
operator|)
condition|)
block|{
name|af_latin2_hint_edges
argument_list|(
name|hints
argument_list|,
operator|(
name|AF_Dimension
operator|)
name|dim
argument_list|)
expr_stmt|;
name|af_glyph_hints_align_edge_points
argument_list|(
name|hints
argument_list|,
operator|(
name|AF_Dimension
operator|)
name|dim
argument_list|)
expr_stmt|;
name|af_glyph_hints_align_strong_points
argument_list|(
name|hints
argument_list|,
operator|(
name|AF_Dimension
operator|)
name|dim
argument_list|)
expr_stmt|;
name|af_glyph_hints_align_weak_points
argument_list|(
name|hints
argument_list|,
operator|(
name|AF_Dimension
operator|)
name|dim
argument_list|)
expr_stmt|;
block|}
block|}
name|af_glyph_hints_save
argument_list|(
name|hints
argument_list|,
name|outline
argument_list|)
expr_stmt|;
name|Exit
label|:
return|return
name|error
return|;
block|}
comment|/*************************************************************************/
comment|/*************************************************************************/
comment|/*****                                                               *****/
comment|/*****              L A T I N   S C R I P T   C L A S S              *****/
comment|/*****                                                               *****/
comment|/*************************************************************************/
comment|/*************************************************************************/
DECL|variable|af_latin2_uniranges
specifier|static
specifier|const
name|AF_Script_UniRangeRec
name|af_latin2_uniranges
index|[]
init|=
block|{
name|AF_UNIRANGE_REC
argument_list|(
literal|32UL
argument_list|,
literal|127UL
argument_list|)
block|,
comment|/* XXX: TODO: Add new Unicode ranges here! */
name|AF_UNIRANGE_REC
argument_list|(
literal|160UL
argument_list|,
literal|255UL
argument_list|)
block|,
name|AF_UNIRANGE_REC
argument_list|(
literal|0UL
argument_list|,
literal|0UL
argument_list|)
block|}
decl_stmt|;
name|AF_DEFINE_SCRIPT_CLASS
argument_list|(
argument|af_latin2_script_class
argument_list|,
argument|AF_SCRIPT_LATIN2
argument_list|,
argument|af_latin2_uniranges
argument_list|,
argument|sizeof( AF_LatinMetricsRec )
argument_list|,
argument|(AF_Script_InitMetricsFunc) af_latin2_metrics_init
argument_list|,
argument|(AF_Script_ScaleMetricsFunc)af_latin2_metrics_scale
argument_list|,
argument|(AF_Script_DoneMetricsFunc) NULL
argument_list|,
argument|(AF_Script_InitHintsFunc)   af_latin2_hints_init
argument_list|,
argument|(AF_Script_ApplyHintsFunc)  af_latin2_hints_apply
argument_list|)
end_block
begin_comment
comment|/* END */
end_comment
end_unit
