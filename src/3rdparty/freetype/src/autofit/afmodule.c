begin_unit
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  afmodule.c                                                             */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*    Auto-fitter module implementation (body).                            */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  Copyright 2003-2015 by                                                 */
end_comment
begin_comment
comment|/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  This file is part of the FreeType project, and may only be used,       */
end_comment
begin_comment
comment|/*  modified, and distributed under the terms of the FreeType project      */
end_comment
begin_comment
comment|/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
end_comment
begin_comment
comment|/*  this file you indicate that you have read the license and              */
end_comment
begin_comment
comment|/*  understand and accept it fully.                                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"afglobal.h"
end_include
begin_include
include|#
directive|include
file|"afmodule.h"
end_include
begin_include
include|#
directive|include
file|"afloader.h"
end_include
begin_include
include|#
directive|include
file|"aferrors.h"
end_include
begin_include
include|#
directive|include
file|"afpic.h"
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|FT_DEBUG_AUTOFIT
end_ifdef
begin_ifndef
ifndef|#
directive|ifndef
name|FT_MAKE_OPTION_SINGLE_OBJECT
end_ifndef
begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef
begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
specifier|extern
name|void
name|af_glyph_hints_dump_segments
parameter_list|(
name|AF_GlyphHints
name|hints
parameter_list|,
name|FT_Bool
name|to_stdout
parameter_list|)
function_decl|;
specifier|extern
name|void
name|af_glyph_hints_dump_points
parameter_list|(
name|AF_GlyphHints
name|hints
parameter_list|,
name|FT_Bool
name|to_stdout
parameter_list|)
function_decl|;
specifier|extern
name|void
name|af_glyph_hints_dump_edges
parameter_list|(
name|AF_GlyphHints
name|hints
parameter_list|,
name|FT_Bool
name|to_stdout
parameter_list|)
function_decl|;
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_decl_stmt
DECL|variable|_af_debug_disable_horz_hints
name|int
name|_af_debug_disable_horz_hints
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|_af_debug_disable_vert_hints
name|int
name|_af_debug_disable_vert_hints
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|_af_debug_disable_blue_hints
name|int
name|_af_debug_disable_blue_hints
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* we use a global object instead of a local one for debugging */
end_comment
begin_decl_stmt
DECL|variable|_af_debug_hints_rec
name|AF_GlyphHintsRec
name|_af_debug_hints_rec
index|[
literal|1
index|]
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|_af_debug_hints
name|void
modifier|*
name|_af_debug_hints
init|=
name|_af_debug_hints_rec
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
include|FT_INTERNAL_OBJECTS_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_DEBUG_H
end_include
begin_include
include|#
directive|include
include|FT_AUTOHINTER_H
end_include
begin_include
include|#
directive|include
include|FT_SERVICE_PROPERTIES_H
end_include
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
end_comment
begin_comment
comment|/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
end_comment
begin_comment
comment|/* messages during execution.                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_undef
DECL|macro|FT_COMPONENT
undef|#
directive|undef
name|FT_COMPONENT
end_undef
begin_define
DECL|macro|FT_COMPONENT
define|#
directive|define
name|FT_COMPONENT
value|trace_afmodule
end_define
begin_function
specifier|static
name|FT_Error
DECL|function|af_property_get_face_globals
name|af_property_get_face_globals
parameter_list|(
name|FT_Face
name|face
parameter_list|,
name|AF_FaceGlobals
modifier|*
name|aglobals
parameter_list|,
name|AF_Module
name|module
parameter_list|)
block|{
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
name|AF_FaceGlobals
name|globals
decl_stmt|;
if|if
condition|(
operator|!
name|face
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_Face_Handle
argument_list|)
return|;
name|globals
operator|=
operator|(
name|AF_FaceGlobals
operator|)
name|face
operator|->
name|autohint
operator|.
name|data
expr_stmt|;
if|if
condition|(
operator|!
name|globals
condition|)
block|{
comment|/* trigger computation of the global style data */
comment|/* in case it hasn't been done yet              */
name|error
operator|=
name|af_face_globals_new
argument_list|(
name|face
argument_list|,
operator|&
name|globals
argument_list|,
name|module
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|face
operator|->
name|autohint
operator|.
name|data
operator|=
operator|(
name|FT_Pointer
operator|)
name|globals
expr_stmt|;
name|face
operator|->
name|autohint
operator|.
name|finalizer
operator|=
operator|(
name|FT_Generic_Finalizer
operator|)
name|af_face_globals_free
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|error
condition|)
operator|*
name|aglobals
operator|=
name|globals
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|af_property_set
name|af_property_set
parameter_list|(
name|FT_Module
name|ft_module
parameter_list|,
specifier|const
name|char
modifier|*
name|property_name
parameter_list|,
specifier|const
name|void
modifier|*
name|value
parameter_list|)
block|{
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
name|AF_Module
name|module
init|=
operator|(
name|AF_Module
operator|)
name|ft_module
decl_stmt|;
if|if
condition|(
operator|!
name|ft_strcmp
argument_list|(
name|property_name
argument_list|,
literal|"fallback-script"
argument_list|)
condition|)
block|{
name|FT_UInt
modifier|*
name|fallback_script
init|=
operator|(
name|FT_UInt
operator|*
operator|)
name|value
decl_stmt|;
name|FT_UInt
name|ss
decl_stmt|;
comment|/* We translate the fallback script to a fallback style that uses */
comment|/* `fallback-script' as its script and `AF_COVERAGE_NONE' as its  */
comment|/* coverage value.                                                */
for|for
control|(
name|ss
operator|=
literal|0
init|;
name|AF_STYLE_CLASSES_GET
index|[
name|ss
index|]
condition|;
name|ss
operator|++
control|)
block|{
name|AF_StyleClass
name|style_class
init|=
name|AF_STYLE_CLASSES_GET
index|[
name|ss
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|FT_UInt
operator|)
name|style_class
operator|->
name|script
operator|==
operator|*
name|fallback_script
operator|&&
name|style_class
operator|->
name|coverage
operator|==
name|AF_COVERAGE_DEFAULT
condition|)
block|{
name|module
operator|->
name|fallback_style
operator|=
name|ss
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|AF_STYLE_CLASSES_GET
index|[
name|ss
index|]
condition|)
block|{
name|FT_TRACE0
argument_list|(
operator|(
literal|"af_property_set: Invalid value %d for property `%s'\n"
operator|,
name|fallback_script
operator|,
name|property_name
operator|)
argument_list|)
expr_stmt|;
return|return
name|FT_THROW
argument_list|(
name|Invalid_Argument
argument_list|)
return|;
block|}
return|return
name|error
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|ft_strcmp
argument_list|(
name|property_name
argument_list|,
literal|"default-script"
argument_list|)
condition|)
block|{
name|FT_UInt
modifier|*
name|default_script
init|=
operator|(
name|FT_UInt
operator|*
operator|)
name|value
decl_stmt|;
name|module
operator|->
name|default_script
operator|=
operator|*
name|default_script
expr_stmt|;
return|return
name|error
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|ft_strcmp
argument_list|(
name|property_name
argument_list|,
literal|"increase-x-height"
argument_list|)
condition|)
block|{
name|FT_Prop_IncreaseXHeight
modifier|*
name|prop
init|=
operator|(
name|FT_Prop_IncreaseXHeight
operator|*
operator|)
name|value
decl_stmt|;
name|AF_FaceGlobals
name|globals
decl_stmt|;
name|error
operator|=
name|af_property_get_face_globals
argument_list|(
name|prop
operator|->
name|face
argument_list|,
operator|&
name|globals
argument_list|,
name|module
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|globals
operator|->
name|increase_x_height
operator|=
name|prop
operator|->
name|limit
expr_stmt|;
return|return
name|error
return|;
block|}
ifdef|#
directive|ifdef
name|AF_CONFIG_OPTION_USE_WARPER
elseif|else
if|if
condition|(
operator|!
name|ft_strcmp
argument_list|(
name|property_name
argument_list|,
literal|"warping"
argument_list|)
condition|)
block|{
name|FT_Bool
modifier|*
name|warping
init|=
operator|(
name|FT_Bool
operator|*
operator|)
name|value
decl_stmt|;
name|module
operator|->
name|warping
operator|=
operator|*
name|warping
expr_stmt|;
return|return
name|error
return|;
block|}
endif|#
directive|endif
comment|/* AF_CONFIG_OPTION_USE_WARPER */
name|FT_TRACE0
argument_list|(
operator|(
literal|"af_property_set: missing property `%s'\n"
operator|,
name|property_name
operator|)
argument_list|)
expr_stmt|;
return|return
name|FT_THROW
argument_list|(
name|Missing_Property
argument_list|)
return|;
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|af_property_get
name|af_property_get
parameter_list|(
name|FT_Module
name|ft_module
parameter_list|,
specifier|const
name|char
modifier|*
name|property_name
parameter_list|,
name|void
modifier|*
name|value
parameter_list|)
block|{
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
name|AF_Module
name|module
init|=
operator|(
name|AF_Module
operator|)
name|ft_module
decl_stmt|;
name|FT_UInt
name|fallback_style
init|=
name|module
operator|->
name|fallback_style
decl_stmt|;
name|FT_UInt
name|default_script
init|=
name|module
operator|->
name|default_script
decl_stmt|;
ifdef|#
directive|ifdef
name|AF_CONFIG_OPTION_USE_WARPER
name|FT_Bool
name|warping
init|=
name|module
operator|->
name|warping
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|ft_strcmp
argument_list|(
name|property_name
argument_list|,
literal|"glyph-to-script-map"
argument_list|)
condition|)
block|{
name|FT_Prop_GlyphToScriptMap
modifier|*
name|prop
init|=
operator|(
name|FT_Prop_GlyphToScriptMap
operator|*
operator|)
name|value
decl_stmt|;
name|AF_FaceGlobals
name|globals
decl_stmt|;
name|error
operator|=
name|af_property_get_face_globals
argument_list|(
name|prop
operator|->
name|face
argument_list|,
operator|&
name|globals
argument_list|,
name|module
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|prop
operator|->
name|map
operator|=
name|globals
operator|->
name|glyph_styles
expr_stmt|;
return|return
name|error
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|ft_strcmp
argument_list|(
name|property_name
argument_list|,
literal|"fallback-script"
argument_list|)
condition|)
block|{
name|FT_UInt
modifier|*
name|val
init|=
operator|(
name|FT_UInt
operator|*
operator|)
name|value
decl_stmt|;
name|AF_StyleClass
name|style_class
init|=
name|AF_STYLE_CLASSES_GET
index|[
name|fallback_style
index|]
decl_stmt|;
operator|*
name|val
operator|=
name|style_class
operator|->
name|script
expr_stmt|;
return|return
name|error
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|ft_strcmp
argument_list|(
name|property_name
argument_list|,
literal|"default-script"
argument_list|)
condition|)
block|{
name|FT_UInt
modifier|*
name|val
init|=
operator|(
name|FT_UInt
operator|*
operator|)
name|value
decl_stmt|;
operator|*
name|val
operator|=
name|default_script
expr_stmt|;
return|return
name|error
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|ft_strcmp
argument_list|(
name|property_name
argument_list|,
literal|"increase-x-height"
argument_list|)
condition|)
block|{
name|FT_Prop_IncreaseXHeight
modifier|*
name|prop
init|=
operator|(
name|FT_Prop_IncreaseXHeight
operator|*
operator|)
name|value
decl_stmt|;
name|AF_FaceGlobals
name|globals
decl_stmt|;
name|error
operator|=
name|af_property_get_face_globals
argument_list|(
name|prop
operator|->
name|face
argument_list|,
operator|&
name|globals
argument_list|,
name|module
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|prop
operator|->
name|limit
operator|=
name|globals
operator|->
name|increase_x_height
expr_stmt|;
return|return
name|error
return|;
block|}
ifdef|#
directive|ifdef
name|AF_CONFIG_OPTION_USE_WARPER
elseif|else
if|if
condition|(
operator|!
name|ft_strcmp
argument_list|(
name|property_name
argument_list|,
literal|"warping"
argument_list|)
condition|)
block|{
name|FT_Bool
modifier|*
name|val
init|=
operator|(
name|FT_Bool
operator|*
operator|)
name|value
decl_stmt|;
operator|*
name|val
operator|=
name|warping
expr_stmt|;
return|return
name|error
return|;
block|}
endif|#
directive|endif
comment|/* AF_CONFIG_OPTION_USE_WARPER */
name|FT_TRACE0
argument_list|(
operator|(
literal|"af_property_get: missing property `%s'\n"
operator|,
name|property_name
operator|)
argument_list|)
expr_stmt|;
return|return
name|FT_THROW
argument_list|(
name|Missing_Property
argument_list|)
return|;
block|}
end_function
begin_macro
name|FT_DEFINE_SERVICE_PROPERTIESREC
argument_list|(
argument|af_service_properties
argument_list|,
argument|(FT_Properties_SetFunc)af_property_set
argument_list|,
argument|(FT_Properties_GetFunc)af_property_get
argument_list|)
end_macro
begin_macro
name|FT_DEFINE_SERVICEDESCREC1
argument_list|(
argument|af_services
argument_list|,
argument|FT_SERVICE_ID_PROPERTIES
argument_list|,
argument|&AF_SERVICE_PROPERTIES_GET
argument_list|)
end_macro
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_Module_Interface
argument_list|)
end_macro
begin_macro
name|af_get_interface
argument_list|(
argument|FT_Module    module
argument_list|,
argument|const char*  module_interface
argument_list|)
end_macro
begin_block
block|{
comment|/* AF_SERVICES_GET dereferences `library' in PIC mode */
ifdef|#
directive|ifdef
name|FT_CONFIG_OPTION_PIC
name|FT_Library
name|library
decl_stmt|;
if|if
condition|(
operator|!
name|module
condition|)
return|return
name|NULL
return|;
name|library
operator|=
name|module
operator|->
name|library
expr_stmt|;
if|if
condition|(
operator|!
name|library
condition|)
return|return
name|NULL
return|;
else|#
directive|else
name|FT_UNUSED
argument_list|(
name|module
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|ft_service_list_lookup
argument_list|(
name|AF_SERVICES_GET
argument_list|,
name|module_interface
argument_list|)
return|;
block|}
end_block
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|af_autofitter_init
argument_list|(
argument|FT_Module  ft_module
argument_list|)
end_macro
begin_comment
comment|/* AF_Module */
end_comment
begin_block
block|{
name|AF_Module
name|module
init|=
operator|(
name|AF_Module
operator|)
name|ft_module
decl_stmt|;
name|module
operator|->
name|fallback_style
operator|=
name|AF_STYLE_FALLBACK
expr_stmt|;
name|module
operator|->
name|default_script
operator|=
name|AF_SCRIPT_DEFAULT
expr_stmt|;
ifdef|#
directive|ifdef
name|AF_CONFIG_OPTION_USE_WARPER
name|module
operator|->
name|warping
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
return|return
name|FT_Err_Ok
return|;
block|}
end_block
begin_macro
name|FT_CALLBACK_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|af_autofitter_done
name|af_autofitter_done
argument_list|(
argument|FT_Module  ft_module
argument_list|)
end_macro
begin_comment
DECL|function|af_autofitter_done
comment|/* AF_Module */
end_comment
begin_block
block|{
name|FT_UNUSED
argument_list|(
name|ft_module
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FT_DEBUG_AUTOFIT
if|if
condition|(
name|_af_debug_hints_rec
operator|->
name|memory
condition|)
name|af_glyph_hints_done
argument_list|(
name|_af_debug_hints_rec
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block
begin_macro
DECL|function|FT_CALLBACK_DEF
name|FT_CALLBACK_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|af_autofitter_load_glyph
argument_list|(
argument|AF_Module     module
argument_list|,
argument|FT_GlyphSlot  slot
argument_list|,
argument|FT_Size       size
argument_list|,
argument|FT_UInt       glyph_index
argument_list|,
argument|FT_Int32      load_flags
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|module
operator|->
name|root
operator|.
name|library
operator|->
name|memory
decl_stmt|;
ifdef|#
directive|ifdef
name|FT_DEBUG_AUTOFIT
comment|/* in debug mode, we use a global object that survives this routine */
name|AF_GlyphHints
name|hints
init|=
name|_af_debug_hints_rec
decl_stmt|;
name|AF_LoaderRec
name|loader
index|[
literal|1
index|]
decl_stmt|;
name|FT_UNUSED
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|hints
operator|->
name|memory
condition|)
name|af_glyph_hints_done
argument_list|(
name|hints
argument_list|)
expr_stmt|;
name|af_glyph_hints_init
argument_list|(
name|hints
argument_list|,
name|memory
argument_list|)
expr_stmt|;
name|af_loader_init
argument_list|(
name|loader
argument_list|,
name|hints
argument_list|)
expr_stmt|;
name|error
operator|=
name|af_loader_load_glyph
argument_list|(
name|loader
argument_list|,
name|module
argument_list|,
name|slot
operator|->
name|face
argument_list|,
name|glyph_index
argument_list|,
name|load_flags
argument_list|)
expr_stmt|;
name|af_glyph_hints_dump_points
argument_list|(
name|hints
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|af_glyph_hints_dump_segments
argument_list|(
name|hints
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|af_glyph_hints_dump_edges
argument_list|(
name|hints
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|af_loader_done
argument_list|(
name|loader
argument_list|)
expr_stmt|;
return|return
name|error
return|;
else|#
directive|else
comment|/* !FT_DEBUG_AUTOFIT */
name|AF_GlyphHintsRec
name|hints
index|[
literal|1
index|]
decl_stmt|;
name|AF_LoaderRec
name|loader
index|[
literal|1
index|]
decl_stmt|;
name|FT_UNUSED
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|af_glyph_hints_init
argument_list|(
name|hints
argument_list|,
name|memory
argument_list|)
expr_stmt|;
name|af_loader_init
argument_list|(
name|loader
argument_list|,
name|hints
argument_list|)
expr_stmt|;
name|error
operator|=
name|af_loader_load_glyph
argument_list|(
name|loader
argument_list|,
name|module
argument_list|,
name|slot
operator|->
name|face
argument_list|,
name|glyph_index
argument_list|,
name|load_flags
argument_list|)
expr_stmt|;
name|af_loader_done
argument_list|(
name|loader
argument_list|)
expr_stmt|;
name|af_glyph_hints_done
argument_list|(
name|hints
argument_list|)
expr_stmt|;
return|return
name|error
return|;
endif|#
directive|endif
comment|/* !FT_DEBUG_AUTOFIT */
block|}
end_block
begin_macro
name|FT_DEFINE_AUTOHINTER_INTERFACE
argument_list|(
argument|af_autofitter_interface
argument_list|,
argument|NULL
argument_list|,
comment|/* reset_face */
argument|NULL
argument_list|,
comment|/* get_global_hints */
argument|NULL
argument_list|,
comment|/* done_global_hints */
argument|(FT_AutoHinter_GlyphLoadFunc)af_autofitter_load_glyph
argument_list|)
end_macro
begin_comment
comment|/* load_glyph */
end_comment
begin_macro
name|FT_DEFINE_MODULE
argument_list|(
argument|autofit_module_class
argument_list|,
argument|FT_MODULE_HINTER
argument_list|,
argument|sizeof ( AF_ModuleRec )
argument_list|,
literal|"autofitter"
argument_list|,
literal|0x10000L
argument_list|,
comment|/* version 1.0 of the autofitter  */
literal|0x20000L
argument_list|,
comment|/* requires FreeType 2.0 or above */
argument|(const void*)&AF_INTERFACE_GET
argument_list|,
argument|(FT_Module_Constructor)af_autofitter_init
argument_list|,
argument|(FT_Module_Destructor) af_autofitter_done
argument_list|,
argument|(FT_Module_Requester)  af_get_interface
argument_list|)
end_macro
begin_comment
comment|/* END */
end_comment
end_unit
