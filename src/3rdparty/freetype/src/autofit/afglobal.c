begin_unit
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  afglobal.c                                                             */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*    Auto-fitter routines to compute global hinting values (body).        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  Copyright 2003, 2004, 2005, 2006, 2007, 2008, 2009 by                  */
end_comment
begin_comment
comment|/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  This file is part of the FreeType project, and may only be used,       */
end_comment
begin_comment
comment|/*  modified, and distributed under the terms of the FreeType project      */
end_comment
begin_comment
comment|/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
end_comment
begin_comment
comment|/*  this file you indicate that you have read the license and              */
end_comment
begin_comment
comment|/*  understand and accept it fully.                                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"afglobal.h"
end_include
begin_include
include|#
directive|include
file|"afdummy.h"
end_include
begin_include
include|#
directive|include
file|"aflatin.h"
end_include
begin_include
include|#
directive|include
file|"afcjk.h"
end_include
begin_include
include|#
directive|include
file|"afindic.h"
end_include
begin_include
include|#
directive|include
file|"afpic.h"
end_include
begin_include
include|#
directive|include
file|"aferrors.h"
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|FT_OPTION_AUTOFIT2
end_ifdef
begin_include
include|#
directive|include
file|"aflatin2.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|FT_CONFIG_OPTION_PIC
end_ifndef
begin_comment
comment|/* when updating this table, don't forget to update    AF_SCRIPT_CLASSES_COUNT and autofit_module_class_pic_init */
end_comment
begin_comment
comment|/* populate this list when you add new scripts */
end_comment
begin_decl_stmt
DECL|variable|af_script_classes
specifier|static
name|AF_ScriptClass
specifier|const
name|af_script_classes
index|[]
init|=
block|{
operator|&
name|af_dummy_script_class
block|,
ifdef|#
directive|ifdef
name|FT_OPTION_AUTOFIT2
operator|&
name|af_latin2_script_class
block|,
endif|#
directive|endif
operator|&
name|af_latin_script_class
block|,
operator|&
name|af_cjk_script_class
block|,
operator|&
name|af_indic_script_class
block|,
name|NULL
comment|/* do not remove */
block|}
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* FT_CONFIG_OPTION_PIC */
end_comment
begin_comment
comment|/* index of default script in `af_script_classes' */
end_comment
begin_define
DECL|macro|AF_SCRIPT_LIST_DEFAULT
define|#
directive|define
name|AF_SCRIPT_LIST_DEFAULT
value|2
end_define
begin_comment
comment|/* a bit mask indicating an uncovered glyph       */
end_comment
begin_define
DECL|macro|AF_SCRIPT_LIST_NONE
define|#
directive|define
name|AF_SCRIPT_LIST_NONE
value|0x7F
end_define
begin_comment
comment|/* if this flag is set, we have an ASCII digit    */
end_comment
begin_define
DECL|macro|AF_DIGIT
define|#
directive|define
name|AF_DIGIT
value|0x80
end_define
begin_comment
comment|/*    *  Note that glyph_scripts[] is used to map each glyph into    *  an index into the `af_script_classes' array.    *    */
end_comment
begin_typedef
DECL|struct|AF_FaceGlobalsRec_
typedef|typedef
struct|struct
name|AF_FaceGlobalsRec_
block|{
DECL|member|face
name|FT_Face
name|face
decl_stmt|;
DECL|member|glyph_count
name|FT_Long
name|glyph_count
decl_stmt|;
comment|/* same as face->num_glyphs */
DECL|member|glyph_scripts
name|FT_Byte
modifier|*
name|glyph_scripts
decl_stmt|;
DECL|member|metrics
name|AF_ScriptMetrics
name|metrics
index|[
name|AF_SCRIPT_MAX
index|]
decl_stmt|;
block|}
DECL|typedef|AF_FaceGlobalsRec
name|AF_FaceGlobalsRec
typedef|;
end_typedef
begin_comment
comment|/* Compute the script index of each glyph within a given face. */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|af_face_globals_compute_script_coverage
name|af_face_globals_compute_script_coverage
parameter_list|(
name|AF_FaceGlobals
name|globals
parameter_list|)
block|{
name|FT_Error
name|error
init|=
name|AF_Err_Ok
decl_stmt|;
name|FT_Face
name|face
init|=
name|globals
operator|->
name|face
decl_stmt|;
name|FT_CharMap
name|old_charmap
init|=
name|face
operator|->
name|charmap
decl_stmt|;
name|FT_Byte
modifier|*
name|gscripts
init|=
name|globals
operator|->
name|glyph_scripts
decl_stmt|;
name|FT_UInt
name|ss
decl_stmt|,
name|i
decl_stmt|;
comment|/* the value 255 means `uncovered glyph' */
name|FT_MEM_SET
argument_list|(
name|globals
operator|->
name|glyph_scripts
argument_list|,
name|AF_SCRIPT_LIST_NONE
argument_list|,
name|globals
operator|->
name|glyph_count
argument_list|)
expr_stmt|;
name|error
operator|=
name|FT_Select_Charmap
argument_list|(
name|face
argument_list|,
name|FT_ENCODING_UNICODE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/*       *  Ignore this error; we simply use the default script.       *  XXX: Shouldn't we rather disable hinting?       */
name|error
operator|=
name|AF_Err_Ok
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* scan each script in a Unicode charmap */
for|for
control|(
name|ss
operator|=
literal|0
init|;
name|AF_SCRIPT_CLASSES_GET
index|[
name|ss
index|]
condition|;
name|ss
operator|++
control|)
block|{
name|AF_ScriptClass
name|clazz
init|=
name|AF_SCRIPT_CLASSES_GET
index|[
name|ss
index|]
decl_stmt|;
name|AF_Script_UniRange
name|range
decl_stmt|;
if|if
condition|(
name|clazz
operator|->
name|script_uni_ranges
operator|==
name|NULL
condition|)
continue|continue;
comment|/*        *  Scan all unicode points in the range and set the corresponding        *  glyph script index.        */
for|for
control|(
name|range
operator|=
name|clazz
operator|->
name|script_uni_ranges
init|;
name|range
operator|->
name|first
operator|!=
literal|0
condition|;
name|range
operator|++
control|)
block|{
name|FT_ULong
name|charcode
init|=
name|range
operator|->
name|first
decl_stmt|;
name|FT_UInt
name|gindex
decl_stmt|;
name|gindex
operator|=
name|FT_Get_Char_Index
argument_list|(
name|face
argument_list|,
name|charcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|gindex
operator|!=
literal|0
operator|&&
name|gindex
operator|<
operator|(
name|FT_ULong
operator|)
name|globals
operator|->
name|glyph_count
operator|&&
name|gscripts
index|[
name|gindex
index|]
operator|==
name|AF_SCRIPT_LIST_NONE
condition|)
block|{
name|gscripts
index|[
name|gindex
index|]
operator|=
operator|(
name|FT_Byte
operator|)
name|ss
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|charcode
operator|=
name|FT_Get_Next_Char
argument_list|(
name|face
argument_list|,
name|charcode
argument_list|,
operator|&
name|gindex
argument_list|)
expr_stmt|;
if|if
condition|(
name|gindex
operator|==
literal|0
operator|||
name|charcode
operator|>
name|range
operator|->
name|last
condition|)
break|break;
if|if
condition|(
name|gindex
operator|<
operator|(
name|FT_ULong
operator|)
name|globals
operator|->
name|glyph_count
operator|&&
name|gscripts
index|[
name|gindex
index|]
operator|==
name|AF_SCRIPT_LIST_NONE
condition|)
block|{
name|gscripts
index|[
name|gindex
index|]
operator|=
operator|(
name|FT_Byte
operator|)
name|ss
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* mark ASCII digits */
for|for
control|(
name|i
operator|=
literal|0x30
init|;
name|i
operator|<=
literal|0x39
condition|;
name|i
operator|++
control|)
block|{
name|FT_UInt
name|gindex
init|=
name|FT_Get_Char_Index
argument_list|(
name|face
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|gindex
operator|!=
literal|0
operator|&&
name|gindex
operator|<
operator|(
name|FT_ULong
operator|)
name|globals
operator|->
name|glyph_count
condition|)
name|gscripts
index|[
name|gindex
index|]
operator||=
name|AF_DIGIT
expr_stmt|;
block|}
name|Exit
label|:
comment|/*      *  By default, all uncovered glyphs are set to the latin script.      *  XXX: Shouldn't we disable hinting or do something similar?      */
block|{
name|FT_Long
name|nn
decl_stmt|;
for|for
control|(
name|nn
operator|=
literal|0
init|;
name|nn
operator|<
name|globals
operator|->
name|glyph_count
condition|;
name|nn
operator|++
control|)
block|{
if|if
condition|(
name|gscripts
index|[
name|nn
index|]
operator|==
name|AF_SCRIPT_LIST_NONE
condition|)
name|gscripts
index|[
name|nn
index|]
operator|=
name|AF_SCRIPT_LIST_DEFAULT
expr_stmt|;
block|}
block|}
name|FT_Set_Charmap
argument_list|(
name|face
argument_list|,
name|old_charmap
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|af_face_globals_new
argument_list|(
argument|FT_Face          face
argument_list|,
argument|AF_FaceGlobals  *aglobals
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
decl_stmt|;
name|FT_Memory
name|memory
decl_stmt|;
name|AF_FaceGlobals
name|globals
decl_stmt|;
name|memory
operator|=
name|face
operator|->
name|memory
expr_stmt|;
if|if
condition|(
operator|!
name|FT_ALLOC
argument_list|(
name|globals
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|globals
argument_list|)
operator|+
name|face
operator|->
name|num_glyphs
operator|*
sizeof|sizeof
argument_list|(
name|FT_Byte
argument_list|)
argument_list|)
condition|)
block|{
name|globals
operator|->
name|face
operator|=
name|face
expr_stmt|;
name|globals
operator|->
name|glyph_count
operator|=
name|face
operator|->
name|num_glyphs
expr_stmt|;
name|globals
operator|->
name|glyph_scripts
operator|=
operator|(
name|FT_Byte
operator|*
operator|)
operator|(
name|globals
operator|+
literal|1
operator|)
expr_stmt|;
name|error
operator|=
name|af_face_globals_compute_script_coverage
argument_list|(
name|globals
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|af_face_globals_free
argument_list|(
name|globals
argument_list|)
expr_stmt|;
name|globals
operator|=
name|NULL
expr_stmt|;
block|}
block|}
operator|*
name|aglobals
operator|=
name|globals
expr_stmt|;
return|return
name|error
return|;
block|}
end_block
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|af_face_globals_free
name|af_face_globals_free
argument_list|(
argument|AF_FaceGlobals  globals
argument_list|)
end_macro
begin_block
block|{
if|if
condition|(
name|globals
condition|)
block|{
name|FT_Memory
name|memory
init|=
name|globals
operator|->
name|face
operator|->
name|memory
decl_stmt|;
name|FT_UInt
name|nn
decl_stmt|;
for|for
control|(
name|nn
operator|=
literal|0
init|;
name|nn
operator|<
name|AF_SCRIPT_MAX
condition|;
name|nn
operator|++
control|)
block|{
if|if
condition|(
name|globals
operator|->
name|metrics
index|[
name|nn
index|]
condition|)
block|{
name|AF_ScriptClass
name|clazz
init|=
name|AF_SCRIPT_CLASSES_GET
index|[
name|nn
index|]
decl_stmt|;
name|FT_ASSERT
argument_list|(
name|globals
operator|->
name|metrics
index|[
name|nn
index|]
operator|->
name|clazz
operator|==
name|clazz
argument_list|)
expr_stmt|;
if|if
condition|(
name|clazz
operator|->
name|script_metrics_done
condition|)
name|clazz
operator|->
name|script_metrics_done
argument_list|(
name|globals
operator|->
name|metrics
index|[
name|nn
index|]
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|globals
operator|->
name|metrics
index|[
name|nn
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|globals
operator|->
name|glyph_count
operator|=
literal|0
expr_stmt|;
name|globals
operator|->
name|glyph_scripts
operator|=
name|NULL
expr_stmt|;
comment|/* no need to free this one! */
name|globals
operator|->
name|face
operator|=
name|NULL
expr_stmt|;
name|FT_FREE
argument_list|(
name|globals
argument_list|)
expr_stmt|;
block|}
block|}
end_block
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|af_face_globals_get_metrics
argument_list|(
argument|AF_FaceGlobals     globals
argument_list|,
argument|FT_UInt            gindex
argument_list|,
argument|FT_UInt            options
argument_list|,
argument|AF_ScriptMetrics  *ametrics
argument_list|)
end_macro
begin_block
block|{
name|AF_ScriptMetrics
name|metrics
init|=
name|NULL
decl_stmt|;
name|FT_UInt
name|gidx
decl_stmt|;
name|AF_ScriptClass
name|clazz
decl_stmt|;
name|FT_UInt
name|script
init|=
name|options
operator|&
literal|15
decl_stmt|;
specifier|const
name|FT_Offset
name|script_max
init|=
sizeof|sizeof
argument_list|(
name|AF_SCRIPT_CLASSES_GET
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|AF_SCRIPT_CLASSES_GET
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|FT_Error
name|error
init|=
name|AF_Err_Ok
decl_stmt|;
if|if
condition|(
name|gindex
operator|>=
operator|(
name|FT_ULong
operator|)
name|globals
operator|->
name|glyph_count
condition|)
block|{
name|error
operator|=
name|AF_Err_Invalid_Argument
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|gidx
operator|=
name|script
expr_stmt|;
if|if
condition|(
name|gidx
operator|==
literal|0
operator|||
name|gidx
operator|+
literal|1
operator|>=
name|script_max
condition|)
name|gidx
operator|=
name|globals
operator|->
name|glyph_scripts
index|[
name|gindex
index|]
operator|&
name|AF_SCRIPT_LIST_NONE
expr_stmt|;
name|clazz
operator|=
name|AF_SCRIPT_CLASSES_GET
index|[
name|gidx
index|]
expr_stmt|;
if|if
condition|(
name|script
operator|==
literal|0
condition|)
name|script
operator|=
name|clazz
operator|->
name|script
expr_stmt|;
name|metrics
operator|=
name|globals
operator|->
name|metrics
index|[
name|clazz
operator|->
name|script
index|]
expr_stmt|;
if|if
condition|(
name|metrics
operator|==
name|NULL
condition|)
block|{
comment|/* create the global metrics object when needed */
name|FT_Memory
name|memory
init|=
name|globals
operator|->
name|face
operator|->
name|memory
decl_stmt|;
if|if
condition|(
name|FT_ALLOC
argument_list|(
name|metrics
argument_list|,
name|clazz
operator|->
name|script_metrics_size
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|metrics
operator|->
name|clazz
operator|=
name|clazz
expr_stmt|;
if|if
condition|(
name|clazz
operator|->
name|script_metrics_init
condition|)
block|{
name|error
operator|=
name|clazz
operator|->
name|script_metrics_init
argument_list|(
name|metrics
argument_list|,
name|globals
operator|->
name|face
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|clazz
operator|->
name|script_metrics_done
condition|)
name|clazz
operator|->
name|script_metrics_done
argument_list|(
name|metrics
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|metrics
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
name|globals
operator|->
name|metrics
index|[
name|clazz
operator|->
name|script
index|]
operator|=
name|metrics
expr_stmt|;
block|}
name|Exit
label|:
operator|*
name|ametrics
operator|=
name|metrics
expr_stmt|;
return|return
name|error
return|;
block|}
end_block
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Bool
argument_list|)
end_macro
begin_macro
name|af_face_globals_is_digit
argument_list|(
argument|AF_FaceGlobals  globals
argument_list|,
argument|FT_UInt         gindex
argument_list|)
end_macro
begin_block
block|{
if|if
condition|(
name|gindex
operator|<
operator|(
name|FT_ULong
operator|)
name|globals
operator|->
name|glyph_count
condition|)
return|return
call|(
name|FT_Bool
call|)
argument_list|(
name|globals
operator|->
name|glyph_scripts
index|[
name|gindex
index|]
operator|&
name|AF_DIGIT
argument_list|)
return|;
return|return
operator|(
name|FT_Bool
operator|)
literal|0
return|;
block|}
end_block
begin_comment
comment|/* END */
end_comment
end_unit
