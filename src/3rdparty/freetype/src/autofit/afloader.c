begin_unit
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  afloader.c                                                             */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*    Auto-fitter glyph loading routines (body).                           */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  Copyright 2003-2009, 2011-2014 by                                      */
end_comment
begin_comment
comment|/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  This file is part of the FreeType project, and may only be used,       */
end_comment
begin_comment
comment|/*  modified, and distributed under the terms of the FreeType project      */
end_comment
begin_comment
comment|/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
end_comment
begin_comment
comment|/*  this file you indicate that you have read the license and              */
end_comment
begin_comment
comment|/*  understand and accept it fully.                                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"afglobal.h"
end_include
begin_include
include|#
directive|include
file|"afloader.h"
end_include
begin_include
include|#
directive|include
file|"afhints.h"
end_include
begin_include
include|#
directive|include
file|"aferrors.h"
end_include
begin_include
include|#
directive|include
file|"afmodule.h"
end_include
begin_include
include|#
directive|include
file|"afpic.h"
end_include
begin_comment
comment|/* Initialize glyph loader. */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|af_loader_init
argument_list|(
argument|AF_Module  module
argument_list|)
end_macro
begin_block
block|{
name|AF_Loader
name|loader
init|=
name|module
operator|->
name|loader
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|module
operator|->
name|root
operator|.
name|library
operator|->
name|memory
decl_stmt|;
name|FT_ZERO
argument_list|(
name|loader
argument_list|)
expr_stmt|;
name|af_glyph_hints_init
argument_list|(
operator|&
name|loader
operator|->
name|hints
argument_list|,
name|memory
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FT_DEBUG_AUTOFIT
name|_af_debug_hints
operator|=
operator|&
name|loader
operator|->
name|hints
expr_stmt|;
endif|#
directive|endif
return|return
name|FT_GlyphLoader_New
argument_list|(
name|memory
argument_list|,
operator|&
name|loader
operator|->
name|gloader
argument_list|)
return|;
block|}
end_block
begin_comment
comment|/* Reset glyph loader and compute globals if necessary. */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|af_loader_reset
argument_list|(
argument|AF_Module  module
argument_list|,
argument|FT_Face    face
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
name|AF_Loader
name|loader
init|=
name|module
operator|->
name|loader
decl_stmt|;
name|loader
operator|->
name|face
operator|=
name|face
expr_stmt|;
name|loader
operator|->
name|globals
operator|=
operator|(
name|AF_FaceGlobals
operator|)
name|face
operator|->
name|autohint
operator|.
name|data
expr_stmt|;
name|FT_GlyphLoader_Rewind
argument_list|(
name|loader
operator|->
name|gloader
argument_list|)
expr_stmt|;
if|if
condition|(
name|loader
operator|->
name|globals
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|af_face_globals_new
argument_list|(
name|face
argument_list|,
operator|&
name|loader
operator|->
name|globals
argument_list|,
name|module
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|face
operator|->
name|autohint
operator|.
name|data
operator|=
operator|(
name|FT_Pointer
operator|)
name|loader
operator|->
name|globals
expr_stmt|;
name|face
operator|->
name|autohint
operator|.
name|finalizer
operator|=
operator|(
name|FT_Generic_Finalizer
operator|)
name|af_face_globals_free
expr_stmt|;
block|}
block|}
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/* Finalize glyph loader. */
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|af_loader_done
name|af_loader_done
argument_list|(
argument|AF_Module  module
argument_list|)
end_macro
begin_block
block|{
name|AF_Loader
name|loader
init|=
name|module
operator|->
name|loader
decl_stmt|;
name|af_glyph_hints_done
argument_list|(
operator|&
name|loader
operator|->
name|hints
argument_list|)
expr_stmt|;
name|loader
operator|->
name|face
operator|=
name|NULL
expr_stmt|;
name|loader
operator|->
name|globals
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|FT_DEBUG_AUTOFIT
name|_af_debug_hints
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
name|FT_GlyphLoader_Done
argument_list|(
name|loader
operator|->
name|gloader
argument_list|)
expr_stmt|;
name|loader
operator|->
name|gloader
operator|=
name|NULL
expr_stmt|;
block|}
end_block
begin_comment
comment|/* Load a single glyph component.  This routine calls itself */
end_comment
begin_comment
comment|/* recursively, if necessary, and does the main work of      */
end_comment
begin_comment
comment|/* `af_loader_load_glyph.'                                   */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|af_loader_load_g
name|af_loader_load_g
parameter_list|(
name|AF_Loader
name|loader
parameter_list|,
name|AF_Scaler
name|scaler
parameter_list|,
name|FT_UInt
name|glyph_index
parameter_list|,
name|FT_Int32
name|load_flags
parameter_list|,
name|FT_UInt
name|depth
parameter_list|)
block|{
name|FT_Error
name|error
decl_stmt|;
name|FT_Face
name|face
init|=
name|loader
operator|->
name|face
decl_stmt|;
name|FT_GlyphLoader
name|gloader
init|=
name|loader
operator|->
name|gloader
decl_stmt|;
name|AF_StyleMetrics
name|metrics
init|=
name|loader
operator|->
name|metrics
decl_stmt|;
name|AF_GlyphHints
name|hints
init|=
operator|&
name|loader
operator|->
name|hints
decl_stmt|;
name|FT_GlyphSlot
name|slot
init|=
name|face
operator|->
name|glyph
decl_stmt|;
name|FT_Slot_Internal
name|internal
init|=
name|slot
operator|->
name|internal
decl_stmt|;
name|FT_Int32
name|flags
decl_stmt|;
name|flags
operator|=
name|load_flags
operator||
name|FT_LOAD_LINEAR_DESIGN
expr_stmt|;
name|error
operator|=
name|FT_Load_Glyph
argument_list|(
name|face
argument_list|,
name|glyph_index
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|loader
operator|->
name|transformed
operator|=
name|internal
operator|->
name|glyph_transformed
expr_stmt|;
if|if
condition|(
name|loader
operator|->
name|transformed
condition|)
block|{
name|FT_Matrix
name|inverse
decl_stmt|;
name|loader
operator|->
name|trans_matrix
operator|=
name|internal
operator|->
name|glyph_matrix
expr_stmt|;
name|loader
operator|->
name|trans_delta
operator|=
name|internal
operator|->
name|glyph_delta
expr_stmt|;
name|inverse
operator|=
name|loader
operator|->
name|trans_matrix
expr_stmt|;
if|if
condition|(
operator|!
name|FT_Matrix_Invert
argument_list|(
operator|&
name|inverse
argument_list|)
condition|)
name|FT_Vector_Transform
argument_list|(
operator|&
name|loader
operator|->
name|trans_delta
argument_list|,
operator|&
name|inverse
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|slot
operator|->
name|format
condition|)
block|{
case|case
name|FT_GLYPH_FORMAT_OUTLINE
case|:
comment|/* translate the loaded glyph when an internal transform is needed */
if|if
condition|(
name|loader
operator|->
name|transformed
condition|)
name|FT_Outline_Translate
argument_list|(
operator|&
name|slot
operator|->
name|outline
argument_list|,
name|loader
operator|->
name|trans_delta
operator|.
name|x
argument_list|,
name|loader
operator|->
name|trans_delta
operator|.
name|y
argument_list|)
expr_stmt|;
comment|/* copy the outline points in the loader's current                */
comment|/* extra points which are used to keep original glyph coordinates */
name|error
operator|=
name|FT_GLYPHLOADER_CHECK_POINTS
argument_list|(
name|gloader
argument_list|,
name|slot
operator|->
name|outline
operator|.
name|n_points
operator|+
literal|4
argument_list|,
name|slot
operator|->
name|outline
operator|.
name|n_contours
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|FT_ARRAY_COPY
argument_list|(
name|gloader
operator|->
name|current
operator|.
name|outline
operator|.
name|points
argument_list|,
name|slot
operator|->
name|outline
operator|.
name|points
argument_list|,
name|slot
operator|->
name|outline
operator|.
name|n_points
argument_list|)
expr_stmt|;
name|FT_ARRAY_COPY
argument_list|(
name|gloader
operator|->
name|current
operator|.
name|outline
operator|.
name|contours
argument_list|,
name|slot
operator|->
name|outline
operator|.
name|contours
argument_list|,
name|slot
operator|->
name|outline
operator|.
name|n_contours
argument_list|)
expr_stmt|;
name|FT_ARRAY_COPY
argument_list|(
name|gloader
operator|->
name|current
operator|.
name|outline
operator|.
name|tags
argument_list|,
name|slot
operator|->
name|outline
operator|.
name|tags
argument_list|,
name|slot
operator|->
name|outline
operator|.
name|n_points
argument_list|)
expr_stmt|;
name|gloader
operator|->
name|current
operator|.
name|outline
operator|.
name|n_points
operator|=
name|slot
operator|->
name|outline
operator|.
name|n_points
expr_stmt|;
name|gloader
operator|->
name|current
operator|.
name|outline
operator|.
name|n_contours
operator|=
name|slot
operator|->
name|outline
operator|.
name|n_contours
expr_stmt|;
comment|/* compute original horizontal phantom points (and ignore */
comment|/* vertical ones)                                         */
name|loader
operator|->
name|pp1
operator|.
name|x
operator|=
name|hints
operator|->
name|x_delta
expr_stmt|;
name|loader
operator|->
name|pp1
operator|.
name|y
operator|=
name|hints
operator|->
name|y_delta
expr_stmt|;
name|loader
operator|->
name|pp2
operator|.
name|x
operator|=
name|FT_MulFix
argument_list|(
name|slot
operator|->
name|metrics
operator|.
name|horiAdvance
argument_list|,
name|hints
operator|->
name|x_scale
argument_list|)
operator|+
name|hints
operator|->
name|x_delta
expr_stmt|;
name|loader
operator|->
name|pp2
operator|.
name|y
operator|=
name|hints
operator|->
name|y_delta
expr_stmt|;
comment|/* be sure to check for spacing glyphs */
if|if
condition|(
name|slot
operator|->
name|outline
operator|.
name|n_points
operator|==
literal|0
condition|)
goto|goto
name|Hint_Metrics
goto|;
comment|/* now load the slot image into the auto-outline and run the */
comment|/* automatic hinting process                                 */
block|{
ifdef|#
directive|ifdef
name|FT_CONFIG_OPTION_PIC
name|AF_FaceGlobals
name|globals
init|=
name|loader
operator|->
name|globals
decl_stmt|;
endif|#
directive|endif
name|AF_StyleClass
name|style_class
init|=
name|metrics
operator|->
name|style_class
decl_stmt|;
name|AF_WritingSystemClass
name|writing_system_class
init|=
name|AF_WRITING_SYSTEM_CLASSES_GET
index|[
name|style_class
operator|->
name|writing_system
index|]
decl_stmt|;
if|if
condition|(
name|writing_system_class
operator|->
name|style_hints_apply
condition|)
name|writing_system_class
operator|->
name|style_hints_apply
argument_list|(
name|hints
argument_list|,
operator|&
name|gloader
operator|->
name|current
operator|.
name|outline
argument_list|,
name|metrics
argument_list|)
expr_stmt|;
block|}
comment|/* we now need to adjust the metrics according to the change in */
comment|/* width/positioning that occurred during the hinting process   */
if|if
condition|(
name|scaler
operator|->
name|render_mode
operator|!=
name|FT_RENDER_MODE_LIGHT
condition|)
block|{
name|FT_Pos
name|old_rsb
decl_stmt|,
name|old_lsb
decl_stmt|,
name|new_lsb
decl_stmt|;
name|FT_Pos
name|pp1x_uh
decl_stmt|,
name|pp2x_uh
decl_stmt|;
name|AF_AxisHints
name|axis
init|=
operator|&
name|hints
operator|->
name|axis
index|[
name|AF_DIMENSION_HORZ
index|]
decl_stmt|;
name|AF_Edge
name|edge1
init|=
name|axis
operator|->
name|edges
decl_stmt|;
comment|/* leftmost edge  */
name|AF_Edge
name|edge2
init|=
name|edge1
operator|+
name|axis
operator|->
name|num_edges
operator|-
literal|1
decl_stmt|;
comment|/* rightmost edge */
if|if
condition|(
name|axis
operator|->
name|num_edges
operator|>
literal|1
operator|&&
name|AF_HINTS_DO_ADVANCE
argument_list|(
name|hints
argument_list|)
condition|)
block|{
name|old_rsb
operator|=
name|loader
operator|->
name|pp2
operator|.
name|x
operator|-
name|edge2
operator|->
name|opos
expr_stmt|;
name|old_lsb
operator|=
name|edge1
operator|->
name|opos
expr_stmt|;
name|new_lsb
operator|=
name|edge1
operator|->
name|pos
expr_stmt|;
comment|/* remember unhinted values to later account */
comment|/* for rounding errors                       */
name|pp1x_uh
operator|=
name|new_lsb
operator|-
name|old_lsb
expr_stmt|;
name|pp2x_uh
operator|=
name|edge2
operator|->
name|pos
operator|+
name|old_rsb
expr_stmt|;
comment|/* prefer too much space over too little space */
comment|/* for very small sizes                        */
if|if
condition|(
name|old_lsb
operator|<
literal|24
condition|)
name|pp1x_uh
operator|-=
literal|8
expr_stmt|;
if|if
condition|(
name|old_rsb
operator|<
literal|24
condition|)
name|pp2x_uh
operator|+=
literal|8
expr_stmt|;
name|loader
operator|->
name|pp1
operator|.
name|x
operator|=
name|FT_PIX_ROUND
argument_list|(
name|pp1x_uh
argument_list|)
expr_stmt|;
name|loader
operator|->
name|pp2
operator|.
name|x
operator|=
name|FT_PIX_ROUND
argument_list|(
name|pp2x_uh
argument_list|)
expr_stmt|;
if|if
condition|(
name|loader
operator|->
name|pp1
operator|.
name|x
operator|>=
name|new_lsb
operator|&&
name|old_lsb
operator|>
literal|0
condition|)
name|loader
operator|->
name|pp1
operator|.
name|x
operator|-=
literal|64
expr_stmt|;
if|if
condition|(
name|loader
operator|->
name|pp2
operator|.
name|x
operator|<=
name|edge2
operator|->
name|pos
operator|&&
name|old_rsb
operator|>
literal|0
condition|)
name|loader
operator|->
name|pp2
operator|.
name|x
operator|+=
literal|64
expr_stmt|;
name|slot
operator|->
name|lsb_delta
operator|=
name|loader
operator|->
name|pp1
operator|.
name|x
operator|-
name|pp1x_uh
expr_stmt|;
name|slot
operator|->
name|rsb_delta
operator|=
name|loader
operator|->
name|pp2
operator|.
name|x
operator|-
name|pp2x_uh
expr_stmt|;
block|}
else|else
block|{
name|FT_Pos
name|pp1x
init|=
name|loader
operator|->
name|pp1
operator|.
name|x
decl_stmt|;
name|FT_Pos
name|pp2x
init|=
name|loader
operator|->
name|pp2
operator|.
name|x
decl_stmt|;
name|loader
operator|->
name|pp1
operator|.
name|x
operator|=
name|FT_PIX_ROUND
argument_list|(
name|pp1x
argument_list|)
expr_stmt|;
name|loader
operator|->
name|pp2
operator|.
name|x
operator|=
name|FT_PIX_ROUND
argument_list|(
name|pp2x
argument_list|)
expr_stmt|;
name|slot
operator|->
name|lsb_delta
operator|=
name|loader
operator|->
name|pp1
operator|.
name|x
operator|-
name|pp1x
expr_stmt|;
name|slot
operator|->
name|rsb_delta
operator|=
name|loader
operator|->
name|pp2
operator|.
name|x
operator|-
name|pp2x
expr_stmt|;
block|}
block|}
else|else
block|{
name|FT_Pos
name|pp1x
init|=
name|loader
operator|->
name|pp1
operator|.
name|x
decl_stmt|;
name|FT_Pos
name|pp2x
init|=
name|loader
operator|->
name|pp2
operator|.
name|x
decl_stmt|;
name|loader
operator|->
name|pp1
operator|.
name|x
operator|=
name|FT_PIX_ROUND
argument_list|(
name|pp1x
operator|+
name|hints
operator|->
name|xmin_delta
argument_list|)
expr_stmt|;
name|loader
operator|->
name|pp2
operator|.
name|x
operator|=
name|FT_PIX_ROUND
argument_list|(
name|pp2x
operator|+
name|hints
operator|->
name|xmax_delta
argument_list|)
expr_stmt|;
name|slot
operator|->
name|lsb_delta
operator|=
name|loader
operator|->
name|pp1
operator|.
name|x
operator|-
name|pp1x
expr_stmt|;
name|slot
operator|->
name|rsb_delta
operator|=
name|loader
operator|->
name|pp2
operator|.
name|x
operator|-
name|pp2x
expr_stmt|;
block|}
comment|/* good, we simply add the glyph to our loader's base */
name|FT_GlyphLoader_Add
argument_list|(
name|gloader
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_GLYPH_FORMAT_COMPOSITE
case|:
block|{
name|FT_UInt
name|nn
decl_stmt|,
name|num_subglyphs
init|=
name|slot
operator|->
name|num_subglyphs
decl_stmt|;
name|FT_UInt
name|num_base_subgs
decl_stmt|,
name|start_point
decl_stmt|;
name|FT_SubGlyph
name|subglyph
decl_stmt|;
name|start_point
operator|=
name|gloader
operator|->
name|base
operator|.
name|outline
operator|.
name|n_points
expr_stmt|;
comment|/* first of all, copy the subglyph descriptors in the glyph loader */
name|error
operator|=
name|FT_GlyphLoader_CheckSubGlyphs
argument_list|(
name|gloader
argument_list|,
name|num_subglyphs
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|FT_ARRAY_COPY
argument_list|(
name|gloader
operator|->
name|current
operator|.
name|subglyphs
argument_list|,
name|slot
operator|->
name|subglyphs
argument_list|,
name|num_subglyphs
argument_list|)
expr_stmt|;
name|gloader
operator|->
name|current
operator|.
name|num_subglyphs
operator|=
name|num_subglyphs
expr_stmt|;
name|num_base_subgs
operator|=
name|gloader
operator|->
name|base
operator|.
name|num_subglyphs
expr_stmt|;
comment|/* now read each subglyph independently */
for|for
control|(
name|nn
operator|=
literal|0
init|;
name|nn
operator|<
name|num_subglyphs
condition|;
name|nn
operator|++
control|)
block|{
name|FT_Vector
name|pp1
decl_stmt|,
name|pp2
decl_stmt|;
name|FT_Pos
name|x
decl_stmt|,
name|y
decl_stmt|;
name|FT_UInt
name|num_points
decl_stmt|,
name|num_new_points
decl_stmt|,
name|num_base_points
decl_stmt|;
comment|/* gloader.current.subglyphs can change during glyph loading due */
comment|/* to re-allocation -- we must recompute the current subglyph on */
comment|/* each iteration                                                */
name|subglyph
operator|=
name|gloader
operator|->
name|base
operator|.
name|subglyphs
operator|+
name|num_base_subgs
operator|+
name|nn
expr_stmt|;
name|pp1
operator|=
name|loader
operator|->
name|pp1
expr_stmt|;
name|pp2
operator|=
name|loader
operator|->
name|pp2
expr_stmt|;
name|num_base_points
operator|=
name|gloader
operator|->
name|base
operator|.
name|outline
operator|.
name|n_points
expr_stmt|;
name|error
operator|=
name|af_loader_load_g
argument_list|(
name|loader
argument_list|,
name|scaler
argument_list|,
name|subglyph
operator|->
name|index
argument_list|,
name|load_flags
argument_list|,
name|depth
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
comment|/* recompute subglyph pointer */
name|subglyph
operator|=
name|gloader
operator|->
name|base
operator|.
name|subglyphs
operator|+
name|num_base_subgs
operator|+
name|nn
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|subglyph
operator|->
name|flags
operator|&
name|FT_SUBGLYPH_FLAG_USE_MY_METRICS
operator|)
condition|)
block|{
name|loader
operator|->
name|pp1
operator|=
name|pp1
expr_stmt|;
name|loader
operator|->
name|pp2
operator|=
name|pp2
expr_stmt|;
block|}
name|num_points
operator|=
name|gloader
operator|->
name|base
operator|.
name|outline
operator|.
name|n_points
expr_stmt|;
name|num_new_points
operator|=
name|num_points
operator|-
name|num_base_points
expr_stmt|;
comment|/* now perform the transformation required for this subglyph */
if|if
condition|(
name|subglyph
operator|->
name|flags
operator|&
operator|(
name|FT_SUBGLYPH_FLAG_SCALE
operator||
name|FT_SUBGLYPH_FLAG_XY_SCALE
operator||
name|FT_SUBGLYPH_FLAG_2X2
operator|)
condition|)
block|{
name|FT_Vector
modifier|*
name|cur
init|=
name|gloader
operator|->
name|base
operator|.
name|outline
operator|.
name|points
operator|+
name|num_base_points
decl_stmt|;
name|FT_Vector
modifier|*
name|limit
init|=
name|cur
operator|+
name|num_new_points
decl_stmt|;
for|for
control|(
init|;
name|cur
operator|<
name|limit
condition|;
name|cur
operator|++
control|)
name|FT_Vector_Transform
argument_list|(
name|cur
argument_list|,
operator|&
name|subglyph
operator|->
name|transform
argument_list|)
expr_stmt|;
block|}
comment|/* apply offset */
if|if
condition|(
operator|!
operator|(
name|subglyph
operator|->
name|flags
operator|&
name|FT_SUBGLYPH_FLAG_ARGS_ARE_XY_VALUES
operator|)
condition|)
block|{
name|FT_Int
name|k
init|=
name|subglyph
operator|->
name|arg1
decl_stmt|;
name|FT_UInt
name|l
init|=
name|subglyph
operator|->
name|arg2
decl_stmt|;
name|FT_Vector
modifier|*
name|p1
decl_stmt|;
name|FT_Vector
modifier|*
name|p2
decl_stmt|;
if|if
condition|(
name|start_point
operator|+
name|k
operator|>=
name|num_base_points
operator|||
name|l
operator|>=
operator|(
name|FT_UInt
operator|)
name|num_new_points
condition|)
block|{
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Composite
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|l
operator|+=
name|num_base_points
expr_stmt|;
comment|/* for now, only use the current point coordinates; */
comment|/* we eventually may consider another approach      */
name|p1
operator|=
name|gloader
operator|->
name|base
operator|.
name|outline
operator|.
name|points
operator|+
name|start_point
operator|+
name|k
expr_stmt|;
name|p2
operator|=
name|gloader
operator|->
name|base
operator|.
name|outline
operator|.
name|points
operator|+
name|start_point
operator|+
name|l
expr_stmt|;
name|x
operator|=
name|p1
operator|->
name|x
operator|-
name|p2
operator|->
name|x
expr_stmt|;
name|y
operator|=
name|p1
operator|->
name|y
operator|-
name|p2
operator|->
name|y
expr_stmt|;
block|}
else|else
block|{
name|x
operator|=
name|FT_MulFix
argument_list|(
name|subglyph
operator|->
name|arg1
argument_list|,
name|hints
operator|->
name|x_scale
argument_list|)
operator|+
name|hints
operator|->
name|x_delta
expr_stmt|;
name|y
operator|=
name|FT_MulFix
argument_list|(
name|subglyph
operator|->
name|arg2
argument_list|,
name|hints
operator|->
name|y_scale
argument_list|)
operator|+
name|hints
operator|->
name|y_delta
expr_stmt|;
name|x
operator|=
name|FT_PIX_ROUND
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|y
operator|=
name|FT_PIX_ROUND
argument_list|(
name|y
argument_list|)
expr_stmt|;
block|}
block|{
name|FT_Outline
name|dummy
init|=
name|gloader
operator|->
name|base
operator|.
name|outline
decl_stmt|;
name|dummy
operator|.
name|points
operator|+=
name|num_base_points
expr_stmt|;
name|dummy
operator|.
name|n_points
operator|=
operator|(
name|short
operator|)
name|num_new_points
expr_stmt|;
name|FT_Outline_Translate
argument_list|(
operator|&
name|dummy
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
default|default:
comment|/* we don't support other formats (yet?) */
name|error
operator|=
name|FT_THROW
argument_list|(
name|Unimplemented_Feature
argument_list|)
expr_stmt|;
block|}
name|Hint_Metrics
label|:
if|if
condition|(
name|depth
operator|==
literal|0
condition|)
block|{
name|FT_BBox
name|bbox
decl_stmt|;
name|FT_Vector
name|vvector
decl_stmt|;
name|vvector
operator|.
name|x
operator|=
name|slot
operator|->
name|metrics
operator|.
name|vertBearingX
operator|-
name|slot
operator|->
name|metrics
operator|.
name|horiBearingX
expr_stmt|;
name|vvector
operator|.
name|y
operator|=
name|slot
operator|->
name|metrics
operator|.
name|vertBearingY
operator|-
name|slot
operator|->
name|metrics
operator|.
name|horiBearingY
expr_stmt|;
name|vvector
operator|.
name|x
operator|=
name|FT_MulFix
argument_list|(
name|vvector
operator|.
name|x
argument_list|,
name|metrics
operator|->
name|scaler
operator|.
name|x_scale
argument_list|)
expr_stmt|;
name|vvector
operator|.
name|y
operator|=
name|FT_MulFix
argument_list|(
name|vvector
operator|.
name|y
argument_list|,
name|metrics
operator|->
name|scaler
operator|.
name|y_scale
argument_list|)
expr_stmt|;
comment|/* transform the hinted outline if needed */
if|if
condition|(
name|loader
operator|->
name|transformed
condition|)
block|{
name|FT_Outline_Transform
argument_list|(
operator|&
name|gloader
operator|->
name|base
operator|.
name|outline
argument_list|,
operator|&
name|loader
operator|->
name|trans_matrix
argument_list|)
expr_stmt|;
name|FT_Vector_Transform
argument_list|(
operator|&
name|vvector
argument_list|,
operator|&
name|loader
operator|->
name|trans_matrix
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|1
comment|/* we must translate our final outline by -pp1.x and compute */
comment|/* the new metrics                                           */
if|if
condition|(
name|loader
operator|->
name|pp1
operator|.
name|x
condition|)
name|FT_Outline_Translate
argument_list|(
operator|&
name|gloader
operator|->
name|base
operator|.
name|outline
argument_list|,
operator|-
name|loader
operator|->
name|pp1
operator|.
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|FT_Outline_Get_CBox
argument_list|(
operator|&
name|gloader
operator|->
name|base
operator|.
name|outline
argument_list|,
operator|&
name|bbox
argument_list|)
expr_stmt|;
name|bbox
operator|.
name|xMin
operator|=
name|FT_PIX_FLOOR
argument_list|(
name|bbox
operator|.
name|xMin
argument_list|)
expr_stmt|;
name|bbox
operator|.
name|yMin
operator|=
name|FT_PIX_FLOOR
argument_list|(
name|bbox
operator|.
name|yMin
argument_list|)
expr_stmt|;
name|bbox
operator|.
name|xMax
operator|=
name|FT_PIX_CEIL
argument_list|(
name|bbox
operator|.
name|xMax
argument_list|)
expr_stmt|;
name|bbox
operator|.
name|yMax
operator|=
name|FT_PIX_CEIL
argument_list|(
name|bbox
operator|.
name|yMax
argument_list|)
expr_stmt|;
name|slot
operator|->
name|metrics
operator|.
name|width
operator|=
name|bbox
operator|.
name|xMax
operator|-
name|bbox
operator|.
name|xMin
expr_stmt|;
name|slot
operator|->
name|metrics
operator|.
name|height
operator|=
name|bbox
operator|.
name|yMax
operator|-
name|bbox
operator|.
name|yMin
expr_stmt|;
name|slot
operator|->
name|metrics
operator|.
name|horiBearingX
operator|=
name|bbox
operator|.
name|xMin
expr_stmt|;
name|slot
operator|->
name|metrics
operator|.
name|horiBearingY
operator|=
name|bbox
operator|.
name|yMax
expr_stmt|;
name|slot
operator|->
name|metrics
operator|.
name|vertBearingX
operator|=
name|FT_PIX_FLOOR
argument_list|(
name|bbox
operator|.
name|xMin
operator|+
name|vvector
operator|.
name|x
argument_list|)
expr_stmt|;
name|slot
operator|->
name|metrics
operator|.
name|vertBearingY
operator|=
name|FT_PIX_FLOOR
argument_list|(
name|bbox
operator|.
name|yMax
operator|+
name|vvector
operator|.
name|y
argument_list|)
expr_stmt|;
comment|/* for mono-width fonts (like Andale, Courier, etc.) we need */
comment|/* to keep the original rounded advance width; ditto for     */
comment|/* digits if all have the same advance width                 */
if|#
directive|if
literal|0
block|if ( !FT_IS_FIXED_WIDTH( slot->face ) )         slot->metrics.horiAdvance = loader->pp2.x - loader->pp1.x;       else         slot->metrics.horiAdvance = FT_MulFix( slot->metrics.horiAdvance,                                                x_scale );
else|#
directive|else
if|if
condition|(
name|scaler
operator|->
name|render_mode
operator|!=
name|FT_RENDER_MODE_LIGHT
operator|&&
operator|(
name|FT_IS_FIXED_WIDTH
argument_list|(
name|slot
operator|->
name|face
argument_list|)
operator|||
operator|(
name|af_face_globals_is_digit
argument_list|(
name|loader
operator|->
name|globals
argument_list|,
name|glyph_index
argument_list|)
operator|&&
name|metrics
operator|->
name|digits_have_same_width
operator|)
operator|)
condition|)
block|{
name|slot
operator|->
name|metrics
operator|.
name|horiAdvance
operator|=
name|FT_MulFix
argument_list|(
name|slot
operator|->
name|metrics
operator|.
name|horiAdvance
argument_list|,
name|metrics
operator|->
name|scaler
operator|.
name|x_scale
argument_list|)
expr_stmt|;
comment|/* Set delta values to 0.  Otherwise code that uses them is */
comment|/* going to ruin the fixed advance width.                   */
name|slot
operator|->
name|lsb_delta
operator|=
literal|0
expr_stmt|;
name|slot
operator|->
name|rsb_delta
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* non-spacing glyphs must stay as-is */
if|if
condition|(
name|slot
operator|->
name|metrics
operator|.
name|horiAdvance
condition|)
name|slot
operator|->
name|metrics
operator|.
name|horiAdvance
operator|=
name|loader
operator|->
name|pp2
operator|.
name|x
operator|-
name|loader
operator|->
name|pp1
operator|.
name|x
expr_stmt|;
block|}
endif|#
directive|endif
name|slot
operator|->
name|metrics
operator|.
name|vertAdvance
operator|=
name|FT_MulFix
argument_list|(
name|slot
operator|->
name|metrics
operator|.
name|vertAdvance
argument_list|,
name|metrics
operator|->
name|scaler
operator|.
name|y_scale
argument_list|)
expr_stmt|;
name|slot
operator|->
name|metrics
operator|.
name|horiAdvance
operator|=
name|FT_PIX_ROUND
argument_list|(
name|slot
operator|->
name|metrics
operator|.
name|horiAdvance
argument_list|)
expr_stmt|;
name|slot
operator|->
name|metrics
operator|.
name|vertAdvance
operator|=
name|FT_PIX_ROUND
argument_list|(
name|slot
operator|->
name|metrics
operator|.
name|vertAdvance
argument_list|)
expr_stmt|;
comment|/* now copy outline into glyph slot */
name|FT_GlyphLoader_Rewind
argument_list|(
name|internal
operator|->
name|loader
argument_list|)
expr_stmt|;
name|error
operator|=
name|FT_GlyphLoader_CopyPoints
argument_list|(
name|internal
operator|->
name|loader
argument_list|,
name|gloader
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
comment|/* reassign all outline fields except flags to protect them */
name|slot
operator|->
name|outline
operator|.
name|n_contours
operator|=
name|internal
operator|->
name|loader
operator|->
name|base
operator|.
name|outline
operator|.
name|n_contours
expr_stmt|;
name|slot
operator|->
name|outline
operator|.
name|n_points
operator|=
name|internal
operator|->
name|loader
operator|->
name|base
operator|.
name|outline
operator|.
name|n_points
expr_stmt|;
name|slot
operator|->
name|outline
operator|.
name|points
operator|=
name|internal
operator|->
name|loader
operator|->
name|base
operator|.
name|outline
operator|.
name|points
expr_stmt|;
name|slot
operator|->
name|outline
operator|.
name|tags
operator|=
name|internal
operator|->
name|loader
operator|->
name|base
operator|.
name|outline
operator|.
name|tags
expr_stmt|;
name|slot
operator|->
name|outline
operator|.
name|contours
operator|=
name|internal
operator|->
name|loader
operator|->
name|base
operator|.
name|outline
operator|.
name|contours
expr_stmt|;
name|slot
operator|->
name|format
operator|=
name|FT_GLYPH_FORMAT_OUTLINE
expr_stmt|;
block|}
name|Exit
label|:
return|return
name|error
return|;
block|}
end_function
begin_comment
comment|/* Load a glyph. */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|af_loader_load_glyph
argument_list|(
argument|AF_Module  module
argument_list|,
argument|FT_Face    face
argument_list|,
argument|FT_UInt    gindex
argument_list|,
argument|FT_Int32   load_flags
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
decl_stmt|;
name|FT_Size
name|size
init|=
name|face
operator|->
name|size
decl_stmt|;
name|AF_Loader
name|loader
init|=
name|module
operator|->
name|loader
decl_stmt|;
name|AF_ScalerRec
name|scaler
decl_stmt|;
if|if
condition|(
operator|!
name|size
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_Size_Handle
argument_list|)
return|;
name|FT_ZERO
argument_list|(
operator|&
name|scaler
argument_list|)
expr_stmt|;
name|scaler
operator|.
name|face
operator|=
name|face
expr_stmt|;
name|scaler
operator|.
name|x_scale
operator|=
name|size
operator|->
name|metrics
operator|.
name|x_scale
expr_stmt|;
name|scaler
operator|.
name|x_delta
operator|=
literal|0
expr_stmt|;
comment|/* XXX: TODO: add support for sub-pixel hinting */
name|scaler
operator|.
name|y_scale
operator|=
name|size
operator|->
name|metrics
operator|.
name|y_scale
expr_stmt|;
name|scaler
operator|.
name|y_delta
operator|=
literal|0
expr_stmt|;
comment|/* XXX: TODO: add support for sub-pixel hinting */
name|scaler
operator|.
name|render_mode
operator|=
name|FT_LOAD_TARGET_MODE
argument_list|(
name|load_flags
argument_list|)
expr_stmt|;
name|scaler
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
comment|/* XXX: fix this */
name|error
operator|=
name|af_loader_reset
argument_list|(
name|module
argument_list|,
name|face
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|AF_StyleMetrics
name|metrics
decl_stmt|;
name|FT_UInt
name|options
init|=
name|AF_STYLE_NONE_DFLT
decl_stmt|;
ifdef|#
directive|ifdef
name|FT_OPTION_AUTOFIT2
comment|/* XXX: undocumented hook to activate the latin2 writing system */
if|if
condition|(
name|load_flags
operator|&
operator|(
literal|1UL
operator|<<
literal|20
operator|)
condition|)
name|options
operator|=
name|AF_STYLE_LTN2_DFLT
expr_stmt|;
endif|#
directive|endif
name|error
operator|=
name|af_face_globals_get_metrics
argument_list|(
name|loader
operator|->
name|globals
argument_list|,
name|gindex
argument_list|,
name|options
argument_list|,
operator|&
name|metrics
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
ifdef|#
directive|ifdef
name|FT_CONFIG_OPTION_PIC
name|AF_FaceGlobals
name|globals
init|=
name|loader
operator|->
name|globals
decl_stmt|;
endif|#
directive|endif
name|AF_StyleClass
name|style_class
init|=
name|metrics
operator|->
name|style_class
decl_stmt|;
name|AF_WritingSystemClass
name|writing_system_class
init|=
name|AF_WRITING_SYSTEM_CLASSES_GET
index|[
name|style_class
operator|->
name|writing_system
index|]
decl_stmt|;
name|loader
operator|->
name|metrics
operator|=
name|metrics
expr_stmt|;
if|if
condition|(
name|writing_system_class
operator|->
name|style_metrics_scale
condition|)
name|writing_system_class
operator|->
name|style_metrics_scale
argument_list|(
name|metrics
argument_list|,
operator|&
name|scaler
argument_list|)
expr_stmt|;
else|else
name|metrics
operator|->
name|scaler
operator|=
name|scaler
expr_stmt|;
name|load_flags
operator||=
name|FT_LOAD_NO_SCALE
operator||
name|FT_LOAD_IGNORE_TRANSFORM
expr_stmt|;
name|load_flags
operator|&=
operator|~
name|FT_LOAD_RENDER
expr_stmt|;
if|if
condition|(
name|writing_system_class
operator|->
name|style_hints_init
condition|)
block|{
name|error
operator|=
name|writing_system_class
operator|->
name|style_hints_init
argument_list|(
operator|&
name|loader
operator|->
name|hints
argument_list|,
name|metrics
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
block|}
name|error
operator|=
name|af_loader_load_g
argument_list|(
name|loader
argument_list|,
operator|&
name|scaler
argument_list|,
name|gindex
argument_list|,
name|load_flags
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|Exit
label|:
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/* END */
end_comment
end_unit
