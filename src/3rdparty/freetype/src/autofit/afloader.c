begin_unit
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  afloader.c                                                             */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*    Auto-fitter glyph loading routines (body).                           */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  Copyright 2003-2015 by                                                 */
end_comment
begin_comment
comment|/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  This file is part of the FreeType project, and may only be used,       */
end_comment
begin_comment
comment|/*  modified, and distributed under the terms of the FreeType project      */
end_comment
begin_comment
comment|/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
end_comment
begin_comment
comment|/*  this file you indicate that you have read the license and              */
end_comment
begin_comment
comment|/*  understand and accept it fully.                                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"afglobal.h"
end_include
begin_include
include|#
directive|include
file|"afloader.h"
end_include
begin_include
include|#
directive|include
file|"afhints.h"
end_include
begin_include
include|#
directive|include
file|"aferrors.h"
end_include
begin_include
include|#
directive|include
file|"afmodule.h"
end_include
begin_include
include|#
directive|include
file|"afpic.h"
end_include
begin_comment
comment|/* Initialize glyph loader. */
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|af_loader_init
name|af_loader_init
argument_list|(
argument|AF_Loader      loader
argument_list|,
argument|AF_GlyphHints  hints
argument_list|)
end_macro
begin_block
block|{
name|FT_ZERO
argument_list|(
name|loader
argument_list|)
expr_stmt|;
name|loader
operator|->
name|hints
operator|=
name|hints
expr_stmt|;
block|}
end_block
begin_comment
comment|/* Reset glyph loader and compute globals if necessary. */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|af_loader_reset
argument_list|(
argument|AF_Loader  loader
argument_list|,
argument|AF_Module  module
argument_list|,
argument|FT_Face    face
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
name|loader
operator|->
name|face
operator|=
name|face
expr_stmt|;
name|loader
operator|->
name|globals
operator|=
operator|(
name|AF_FaceGlobals
operator|)
name|face
operator|->
name|autohint
operator|.
name|data
expr_stmt|;
if|if
condition|(
name|loader
operator|->
name|globals
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|af_face_globals_new
argument_list|(
name|face
argument_list|,
operator|&
name|loader
operator|->
name|globals
argument_list|,
name|module
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|face
operator|->
name|autohint
operator|.
name|data
operator|=
operator|(
name|FT_Pointer
operator|)
name|loader
operator|->
name|globals
expr_stmt|;
name|face
operator|->
name|autohint
operator|.
name|finalizer
operator|=
operator|(
name|FT_Generic_Finalizer
operator|)
name|af_face_globals_free
expr_stmt|;
block|}
block|}
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/* Finalize glyph loader. */
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|af_loader_done
name|af_loader_done
argument_list|(
argument|AF_Loader  loader
argument_list|)
end_macro
begin_block
block|{
name|loader
operator|->
name|face
operator|=
name|NULL
expr_stmt|;
name|loader
operator|->
name|globals
operator|=
name|NULL
expr_stmt|;
name|loader
operator|->
name|hints
operator|=
name|NULL
expr_stmt|;
block|}
end_block
begin_comment
comment|/* Do the main work of `af_loader_load_glyph'.  Note that we never   */
end_comment
begin_comment
comment|/* have to deal with composite glyphs as those get loaded into       */
end_comment
begin_comment
comment|/* FT_GLYPH_FORMAT_OUTLINE by the recursed `FT_Load_Glyph' function. */
end_comment
begin_comment
comment|/* In the rare cases where FT_LOAD_NO_RECURSE is set, it implies     */
end_comment
begin_comment
comment|/* FT_LOAD_NO_SCALE and as such the auto-hinter is never called.     */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|af_loader_load_g
name|af_loader_load_g
parameter_list|(
name|AF_Loader
name|loader
parameter_list|,
name|AF_Scaler
name|scaler
parameter_list|,
name|FT_UInt
name|glyph_index
parameter_list|,
name|FT_Int32
name|load_flags
parameter_list|)
block|{
name|FT_Error
name|error
decl_stmt|;
name|FT_Face
name|face
init|=
name|loader
operator|->
name|face
decl_stmt|;
name|AF_StyleMetrics
name|metrics
init|=
name|loader
operator|->
name|metrics
decl_stmt|;
name|AF_GlyphHints
name|hints
init|=
name|loader
operator|->
name|hints
decl_stmt|;
name|FT_GlyphSlot
name|slot
init|=
name|face
operator|->
name|glyph
decl_stmt|;
name|FT_Slot_Internal
name|internal
init|=
name|slot
operator|->
name|internal
decl_stmt|;
name|FT_GlyphLoader
name|gloader
init|=
name|internal
operator|->
name|loader
decl_stmt|;
name|FT_Int32
name|flags
decl_stmt|;
name|flags
operator|=
name|load_flags
operator||
name|FT_LOAD_LINEAR_DESIGN
expr_stmt|;
name|error
operator|=
name|FT_Load_Glyph
argument_list|(
name|face
argument_list|,
name|glyph_index
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|loader
operator|->
name|transformed
operator|=
name|internal
operator|->
name|glyph_transformed
expr_stmt|;
if|if
condition|(
name|loader
operator|->
name|transformed
condition|)
block|{
name|FT_Matrix
name|inverse
decl_stmt|;
name|loader
operator|->
name|trans_matrix
operator|=
name|internal
operator|->
name|glyph_matrix
expr_stmt|;
name|loader
operator|->
name|trans_delta
operator|=
name|internal
operator|->
name|glyph_delta
expr_stmt|;
name|inverse
operator|=
name|loader
operator|->
name|trans_matrix
expr_stmt|;
if|if
condition|(
operator|!
name|FT_Matrix_Invert
argument_list|(
operator|&
name|inverse
argument_list|)
condition|)
name|FT_Vector_Transform
argument_list|(
operator|&
name|loader
operator|->
name|trans_delta
argument_list|,
operator|&
name|inverse
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|slot
operator|->
name|format
condition|)
block|{
case|case
name|FT_GLYPH_FORMAT_OUTLINE
case|:
comment|/* translate the loaded glyph when an internal transform is needed */
if|if
condition|(
name|loader
operator|->
name|transformed
condition|)
name|FT_Outline_Translate
argument_list|(
operator|&
name|slot
operator|->
name|outline
argument_list|,
name|loader
operator|->
name|trans_delta
operator|.
name|x
argument_list|,
name|loader
operator|->
name|trans_delta
operator|.
name|y
argument_list|)
expr_stmt|;
comment|/* compute original horizontal phantom points (and ignore */
comment|/* vertical ones)                                         */
name|loader
operator|->
name|pp1
operator|.
name|x
operator|=
name|hints
operator|->
name|x_delta
expr_stmt|;
name|loader
operator|->
name|pp1
operator|.
name|y
operator|=
name|hints
operator|->
name|y_delta
expr_stmt|;
name|loader
operator|->
name|pp2
operator|.
name|x
operator|=
name|FT_MulFix
argument_list|(
name|slot
operator|->
name|metrics
operator|.
name|horiAdvance
argument_list|,
name|hints
operator|->
name|x_scale
argument_list|)
operator|+
name|hints
operator|->
name|x_delta
expr_stmt|;
name|loader
operator|->
name|pp2
operator|.
name|y
operator|=
name|hints
operator|->
name|y_delta
expr_stmt|;
comment|/* be sure to check for spacing glyphs */
if|if
condition|(
name|slot
operator|->
name|outline
operator|.
name|n_points
operator|==
literal|0
condition|)
goto|goto
name|Hint_Metrics
goto|;
comment|/* now load the slot image into the auto-outline and run the */
comment|/* automatic hinting process                                 */
block|{
ifdef|#
directive|ifdef
name|FT_CONFIG_OPTION_PIC
name|AF_FaceGlobals
name|globals
init|=
name|loader
operator|->
name|globals
decl_stmt|;
endif|#
directive|endif
name|AF_StyleClass
name|style_class
init|=
name|metrics
operator|->
name|style_class
decl_stmt|;
name|AF_WritingSystemClass
name|writing_system_class
init|=
name|AF_WRITING_SYSTEM_CLASSES_GET
index|[
name|style_class
operator|->
name|writing_system
index|]
decl_stmt|;
if|if
condition|(
name|writing_system_class
operator|->
name|style_hints_apply
condition|)
name|writing_system_class
operator|->
name|style_hints_apply
argument_list|(
name|glyph_index
argument_list|,
name|hints
argument_list|,
operator|&
name|gloader
operator|->
name|base
operator|.
name|outline
argument_list|,
name|metrics
argument_list|)
expr_stmt|;
block|}
comment|/* we now need to adjust the metrics according to the change in */
comment|/* width/positioning that occurred during the hinting process   */
if|if
condition|(
name|scaler
operator|->
name|render_mode
operator|!=
name|FT_RENDER_MODE_LIGHT
condition|)
block|{
name|FT_Pos
name|old_rsb
decl_stmt|,
name|old_lsb
decl_stmt|,
name|new_lsb
decl_stmt|;
name|FT_Pos
name|pp1x_uh
decl_stmt|,
name|pp2x_uh
decl_stmt|;
name|AF_AxisHints
name|axis
init|=
operator|&
name|hints
operator|->
name|axis
index|[
name|AF_DIMENSION_HORZ
index|]
decl_stmt|;
name|AF_Edge
name|edge1
init|=
name|axis
operator|->
name|edges
decl_stmt|;
comment|/* leftmost edge  */
name|AF_Edge
name|edge2
init|=
name|edge1
operator|+
name|axis
operator|->
name|num_edges
operator|-
literal|1
decl_stmt|;
comment|/* rightmost edge */
if|if
condition|(
name|axis
operator|->
name|num_edges
operator|>
literal|1
operator|&&
name|AF_HINTS_DO_ADVANCE
argument_list|(
name|hints
argument_list|)
condition|)
block|{
name|old_rsb
operator|=
name|loader
operator|->
name|pp2
operator|.
name|x
operator|-
name|edge2
operator|->
name|opos
expr_stmt|;
name|old_lsb
operator|=
name|edge1
operator|->
name|opos
expr_stmt|;
name|new_lsb
operator|=
name|edge1
operator|->
name|pos
expr_stmt|;
comment|/* remember unhinted values to later account */
comment|/* for rounding errors                       */
name|pp1x_uh
operator|=
name|new_lsb
operator|-
name|old_lsb
expr_stmt|;
name|pp2x_uh
operator|=
name|edge2
operator|->
name|pos
operator|+
name|old_rsb
expr_stmt|;
comment|/* prefer too much space over too little space */
comment|/* for very small sizes                        */
if|if
condition|(
name|old_lsb
operator|<
literal|24
condition|)
name|pp1x_uh
operator|-=
literal|8
expr_stmt|;
if|if
condition|(
name|old_rsb
operator|<
literal|24
condition|)
name|pp2x_uh
operator|+=
literal|8
expr_stmt|;
name|loader
operator|->
name|pp1
operator|.
name|x
operator|=
name|FT_PIX_ROUND
argument_list|(
name|pp1x_uh
argument_list|)
expr_stmt|;
name|loader
operator|->
name|pp2
operator|.
name|x
operator|=
name|FT_PIX_ROUND
argument_list|(
name|pp2x_uh
argument_list|)
expr_stmt|;
if|if
condition|(
name|loader
operator|->
name|pp1
operator|.
name|x
operator|>=
name|new_lsb
operator|&&
name|old_lsb
operator|>
literal|0
condition|)
name|loader
operator|->
name|pp1
operator|.
name|x
operator|-=
literal|64
expr_stmt|;
if|if
condition|(
name|loader
operator|->
name|pp2
operator|.
name|x
operator|<=
name|edge2
operator|->
name|pos
operator|&&
name|old_rsb
operator|>
literal|0
condition|)
name|loader
operator|->
name|pp2
operator|.
name|x
operator|+=
literal|64
expr_stmt|;
name|slot
operator|->
name|lsb_delta
operator|=
name|loader
operator|->
name|pp1
operator|.
name|x
operator|-
name|pp1x_uh
expr_stmt|;
name|slot
operator|->
name|rsb_delta
operator|=
name|loader
operator|->
name|pp2
operator|.
name|x
operator|-
name|pp2x_uh
expr_stmt|;
block|}
else|else
block|{
name|FT_Pos
name|pp1x
init|=
name|loader
operator|->
name|pp1
operator|.
name|x
decl_stmt|;
name|FT_Pos
name|pp2x
init|=
name|loader
operator|->
name|pp2
operator|.
name|x
decl_stmt|;
name|loader
operator|->
name|pp1
operator|.
name|x
operator|=
name|FT_PIX_ROUND
argument_list|(
name|pp1x
argument_list|)
expr_stmt|;
name|loader
operator|->
name|pp2
operator|.
name|x
operator|=
name|FT_PIX_ROUND
argument_list|(
name|pp2x
argument_list|)
expr_stmt|;
name|slot
operator|->
name|lsb_delta
operator|=
name|loader
operator|->
name|pp1
operator|.
name|x
operator|-
name|pp1x
expr_stmt|;
name|slot
operator|->
name|rsb_delta
operator|=
name|loader
operator|->
name|pp2
operator|.
name|x
operator|-
name|pp2x
expr_stmt|;
block|}
block|}
else|else
block|{
name|FT_Pos
name|pp1x
init|=
name|loader
operator|->
name|pp1
operator|.
name|x
decl_stmt|;
name|FT_Pos
name|pp2x
init|=
name|loader
operator|->
name|pp2
operator|.
name|x
decl_stmt|;
name|loader
operator|->
name|pp1
operator|.
name|x
operator|=
name|FT_PIX_ROUND
argument_list|(
name|pp1x
operator|+
name|hints
operator|->
name|xmin_delta
argument_list|)
expr_stmt|;
name|loader
operator|->
name|pp2
operator|.
name|x
operator|=
name|FT_PIX_ROUND
argument_list|(
name|pp2x
operator|+
name|hints
operator|->
name|xmax_delta
argument_list|)
expr_stmt|;
name|slot
operator|->
name|lsb_delta
operator|=
name|loader
operator|->
name|pp1
operator|.
name|x
operator|-
name|pp1x
expr_stmt|;
name|slot
operator|->
name|rsb_delta
operator|=
name|loader
operator|->
name|pp2
operator|.
name|x
operator|-
name|pp2x
expr_stmt|;
block|}
break|break;
default|default:
comment|/* we don't support other formats (yet?) */
name|error
operator|=
name|FT_THROW
argument_list|(
name|Unimplemented_Feature
argument_list|)
expr_stmt|;
block|}
name|Hint_Metrics
label|:
block|{
name|FT_BBox
name|bbox
decl_stmt|;
name|FT_Vector
name|vvector
decl_stmt|;
name|vvector
operator|.
name|x
operator|=
name|slot
operator|->
name|metrics
operator|.
name|vertBearingX
operator|-
name|slot
operator|->
name|metrics
operator|.
name|horiBearingX
expr_stmt|;
name|vvector
operator|.
name|y
operator|=
name|slot
operator|->
name|metrics
operator|.
name|vertBearingY
operator|-
name|slot
operator|->
name|metrics
operator|.
name|horiBearingY
expr_stmt|;
name|vvector
operator|.
name|x
operator|=
name|FT_MulFix
argument_list|(
name|vvector
operator|.
name|x
argument_list|,
name|metrics
operator|->
name|scaler
operator|.
name|x_scale
argument_list|)
expr_stmt|;
name|vvector
operator|.
name|y
operator|=
name|FT_MulFix
argument_list|(
name|vvector
operator|.
name|y
argument_list|,
name|metrics
operator|->
name|scaler
operator|.
name|y_scale
argument_list|)
expr_stmt|;
comment|/* transform the hinted outline if needed */
if|if
condition|(
name|loader
operator|->
name|transformed
condition|)
block|{
name|FT_Outline_Transform
argument_list|(
operator|&
name|gloader
operator|->
name|base
operator|.
name|outline
argument_list|,
operator|&
name|loader
operator|->
name|trans_matrix
argument_list|)
expr_stmt|;
name|FT_Vector_Transform
argument_list|(
operator|&
name|vvector
argument_list|,
operator|&
name|loader
operator|->
name|trans_matrix
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|1
comment|/* we must translate our final outline by -pp1.x and compute */
comment|/* the new metrics                                           */
if|if
condition|(
name|loader
operator|->
name|pp1
operator|.
name|x
condition|)
name|FT_Outline_Translate
argument_list|(
operator|&
name|gloader
operator|->
name|base
operator|.
name|outline
argument_list|,
operator|-
name|loader
operator|->
name|pp1
operator|.
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|FT_Outline_Get_CBox
argument_list|(
operator|&
name|gloader
operator|->
name|base
operator|.
name|outline
argument_list|,
operator|&
name|bbox
argument_list|)
expr_stmt|;
name|bbox
operator|.
name|xMin
operator|=
name|FT_PIX_FLOOR
argument_list|(
name|bbox
operator|.
name|xMin
argument_list|)
expr_stmt|;
name|bbox
operator|.
name|yMin
operator|=
name|FT_PIX_FLOOR
argument_list|(
name|bbox
operator|.
name|yMin
argument_list|)
expr_stmt|;
name|bbox
operator|.
name|xMax
operator|=
name|FT_PIX_CEIL
argument_list|(
name|bbox
operator|.
name|xMax
argument_list|)
expr_stmt|;
name|bbox
operator|.
name|yMax
operator|=
name|FT_PIX_CEIL
argument_list|(
name|bbox
operator|.
name|yMax
argument_list|)
expr_stmt|;
name|slot
operator|->
name|metrics
operator|.
name|width
operator|=
name|bbox
operator|.
name|xMax
operator|-
name|bbox
operator|.
name|xMin
expr_stmt|;
name|slot
operator|->
name|metrics
operator|.
name|height
operator|=
name|bbox
operator|.
name|yMax
operator|-
name|bbox
operator|.
name|yMin
expr_stmt|;
name|slot
operator|->
name|metrics
operator|.
name|horiBearingX
operator|=
name|bbox
operator|.
name|xMin
expr_stmt|;
name|slot
operator|->
name|metrics
operator|.
name|horiBearingY
operator|=
name|bbox
operator|.
name|yMax
expr_stmt|;
name|slot
operator|->
name|metrics
operator|.
name|vertBearingX
operator|=
name|FT_PIX_FLOOR
argument_list|(
name|bbox
operator|.
name|xMin
operator|+
name|vvector
operator|.
name|x
argument_list|)
expr_stmt|;
name|slot
operator|->
name|metrics
operator|.
name|vertBearingY
operator|=
name|FT_PIX_FLOOR
argument_list|(
name|bbox
operator|.
name|yMax
operator|+
name|vvector
operator|.
name|y
argument_list|)
expr_stmt|;
comment|/* for mono-width fonts (like Andale, Courier, etc.) we need */
comment|/* to keep the original rounded advance width; ditto for     */
comment|/* digits if all have the same advance width                 */
if|#
directive|if
literal|0
block|if ( !FT_IS_FIXED_WIDTH( slot->face ) )         slot->metrics.horiAdvance = loader->pp2.x - loader->pp1.x;       else         slot->metrics.horiAdvance = FT_MulFix( slot->metrics.horiAdvance,                                                x_scale );
else|#
directive|else
if|if
condition|(
name|scaler
operator|->
name|render_mode
operator|!=
name|FT_RENDER_MODE_LIGHT
operator|&&
operator|(
name|FT_IS_FIXED_WIDTH
argument_list|(
name|slot
operator|->
name|face
argument_list|)
operator|||
operator|(
name|af_face_globals_is_digit
argument_list|(
name|loader
operator|->
name|globals
argument_list|,
name|glyph_index
argument_list|)
operator|&&
name|metrics
operator|->
name|digits_have_same_width
operator|)
operator|)
condition|)
block|{
name|slot
operator|->
name|metrics
operator|.
name|horiAdvance
operator|=
name|FT_MulFix
argument_list|(
name|slot
operator|->
name|metrics
operator|.
name|horiAdvance
argument_list|,
name|metrics
operator|->
name|scaler
operator|.
name|x_scale
argument_list|)
expr_stmt|;
comment|/* Set delta values to 0.  Otherwise code that uses them is */
comment|/* going to ruin the fixed advance width.                   */
name|slot
operator|->
name|lsb_delta
operator|=
literal|0
expr_stmt|;
name|slot
operator|->
name|rsb_delta
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* non-spacing glyphs must stay as-is */
if|if
condition|(
name|slot
operator|->
name|metrics
operator|.
name|horiAdvance
condition|)
name|slot
operator|->
name|metrics
operator|.
name|horiAdvance
operator|=
name|loader
operator|->
name|pp2
operator|.
name|x
operator|-
name|loader
operator|->
name|pp1
operator|.
name|x
expr_stmt|;
block|}
endif|#
directive|endif
name|slot
operator|->
name|metrics
operator|.
name|vertAdvance
operator|=
name|FT_MulFix
argument_list|(
name|slot
operator|->
name|metrics
operator|.
name|vertAdvance
argument_list|,
name|metrics
operator|->
name|scaler
operator|.
name|y_scale
argument_list|)
expr_stmt|;
name|slot
operator|->
name|metrics
operator|.
name|horiAdvance
operator|=
name|FT_PIX_ROUND
argument_list|(
name|slot
operator|->
name|metrics
operator|.
name|horiAdvance
argument_list|)
expr_stmt|;
name|slot
operator|->
name|metrics
operator|.
name|vertAdvance
operator|=
name|FT_PIX_ROUND
argument_list|(
name|slot
operator|->
name|metrics
operator|.
name|vertAdvance
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* reassign all outline fields except flags to protect them */
block|slot->outline.n_contours = internal->loader->base.outline.n_contours;       slot->outline.n_points   = internal->loader->base.outline.n_points;       slot->outline.points     = internal->loader->base.outline.points;       slot->outline.tags       = internal->loader->base.outline.tags;       slot->outline.contours   = internal->loader->base.outline.contours;
endif|#
directive|endif
name|slot
operator|->
name|format
operator|=
name|FT_GLYPH_FORMAT_OUTLINE
expr_stmt|;
block|}
name|Exit
label|:
return|return
name|error
return|;
block|}
end_function
begin_comment
comment|/* Load a glyph. */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|af_loader_load_glyph
argument_list|(
argument|AF_Loader  loader
argument_list|,
argument|AF_Module  module
argument_list|,
argument|FT_Face    face
argument_list|,
argument|FT_UInt    gindex
argument_list|,
argument|FT_Int32   load_flags
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
decl_stmt|;
name|FT_Size
name|size
init|=
name|face
operator|->
name|size
decl_stmt|;
name|AF_ScalerRec
name|scaler
decl_stmt|;
if|if
condition|(
operator|!
name|size
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_Size_Handle
argument_list|)
return|;
name|FT_ZERO
argument_list|(
operator|&
name|scaler
argument_list|)
expr_stmt|;
name|scaler
operator|.
name|face
operator|=
name|face
expr_stmt|;
name|scaler
operator|.
name|x_scale
operator|=
name|size
operator|->
name|metrics
operator|.
name|x_scale
expr_stmt|;
name|scaler
operator|.
name|x_delta
operator|=
literal|0
expr_stmt|;
comment|/* XXX: TODO: add support for sub-pixel hinting */
name|scaler
operator|.
name|y_scale
operator|=
name|size
operator|->
name|metrics
operator|.
name|y_scale
expr_stmt|;
name|scaler
operator|.
name|y_delta
operator|=
literal|0
expr_stmt|;
comment|/* XXX: TODO: add support for sub-pixel hinting */
name|scaler
operator|.
name|render_mode
operator|=
name|FT_LOAD_TARGET_MODE
argument_list|(
name|load_flags
argument_list|)
expr_stmt|;
name|scaler
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
comment|/* XXX: fix this */
name|error
operator|=
name|af_loader_reset
argument_list|(
name|loader
argument_list|,
name|module
argument_list|,
name|face
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|AF_StyleMetrics
name|metrics
decl_stmt|;
name|FT_UInt
name|options
init|=
name|AF_STYLE_NONE_DFLT
decl_stmt|;
ifdef|#
directive|ifdef
name|FT_OPTION_AUTOFIT2
comment|/* XXX: undocumented hook to activate the latin2 writing system */
if|if
condition|(
name|load_flags
operator|&
operator|(
literal|1UL
operator|<<
literal|20
operator|)
condition|)
name|options
operator|=
name|AF_STYLE_LTN2_DFLT
expr_stmt|;
endif|#
directive|endif
name|error
operator|=
name|af_face_globals_get_metrics
argument_list|(
name|loader
operator|->
name|globals
argument_list|,
name|gindex
argument_list|,
name|options
argument_list|,
operator|&
name|metrics
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
ifdef|#
directive|ifdef
name|FT_CONFIG_OPTION_PIC
name|AF_FaceGlobals
name|globals
init|=
name|loader
operator|->
name|globals
decl_stmt|;
endif|#
directive|endif
name|AF_StyleClass
name|style_class
init|=
name|metrics
operator|->
name|style_class
decl_stmt|;
name|AF_WritingSystemClass
name|writing_system_class
init|=
name|AF_WRITING_SYSTEM_CLASSES_GET
index|[
name|style_class
operator|->
name|writing_system
index|]
decl_stmt|;
name|loader
operator|->
name|metrics
operator|=
name|metrics
expr_stmt|;
if|if
condition|(
name|writing_system_class
operator|->
name|style_metrics_scale
condition|)
name|writing_system_class
operator|->
name|style_metrics_scale
argument_list|(
name|metrics
argument_list|,
operator|&
name|scaler
argument_list|)
expr_stmt|;
else|else
name|metrics
operator|->
name|scaler
operator|=
name|scaler
expr_stmt|;
name|load_flags
operator||=
name|FT_LOAD_NO_SCALE
operator||
name|FT_LOAD_IGNORE_TRANSFORM
expr_stmt|;
name|load_flags
operator|&=
operator|~
name|FT_LOAD_RENDER
expr_stmt|;
if|if
condition|(
name|writing_system_class
operator|->
name|style_hints_init
condition|)
block|{
name|error
operator|=
name|writing_system_class
operator|->
name|style_hints_init
argument_list|(
name|loader
operator|->
name|hints
argument_list|,
name|metrics
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
block|}
name|error
operator|=
name|af_loader_load_g
argument_list|(
name|loader
argument_list|,
operator|&
name|scaler
argument_list|,
name|gindex
argument_list|,
name|load_flags
argument_list|)
expr_stmt|;
block|}
block|}
name|Exit
label|:
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/* END */
end_comment
end_unit
