begin_unit
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  afwarp.c                                                               */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*    Auto-fitter warping algorithm (body).                                */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  Copyright 2006, 2007 by                                                */
end_comment
begin_comment
comment|/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  This file is part of the FreeType project, and may only be used,       */
end_comment
begin_comment
comment|/*  modified, and distributed under the terms of the FreeType project      */
end_comment
begin_comment
comment|/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
end_comment
begin_comment
comment|/*  this file you indicate that you have read the license and              */
end_comment
begin_comment
comment|/*  understand and accept it fully.                                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"afwarp.h"
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|AF_USE_WARPER
end_ifdef
begin_if
if|#
directive|if
literal|1
end_if
begin_decl_stmt
specifier|static
specifier|const
name|AF_WarpScore
DECL|variable|af_warper_weights
name|af_warper_weights
index|[
literal|64
index|]
init|=
block|{
literal|35
block|,
literal|32
block|,
literal|30
block|,
literal|25
block|,
literal|20
block|,
literal|15
block|,
literal|12
block|,
literal|10
block|,
literal|5
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
operator|-
literal|1
block|,
operator|-
literal|2
block|,
operator|-
literal|5
block|,
operator|-
literal|8
block|,
operator|-
literal|10
block|,
operator|-
literal|10
block|,
operator|-
literal|20
block|,
operator|-
literal|20
block|,
operator|-
literal|30
block|,
operator|-
literal|30
block|,
operator|-
literal|30
block|,
operator|-
literal|30
block|,
operator|-
literal|20
block|,
operator|-
literal|20
block|,
operator|-
literal|10
block|,
operator|-
literal|10
block|,
operator|-
literal|8
block|,
operator|-
literal|5
block|,
operator|-
literal|2
block|,
operator|-
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|5
block|,
literal|10
block|,
literal|12
block|,
literal|15
block|,
literal|20
block|,
literal|25
block|,
literal|30
block|,
literal|32
block|,   }
decl_stmt|;
end_decl_stmt
begin_else
else|#
directive|else
end_else
begin_decl_stmt
specifier|static
specifier|const
name|AF_WarpScore
DECL|variable|af_warper_weights
name|af_warper_weights
index|[
literal|64
index|]
init|=
block|{
literal|30
block|,
literal|20
block|,
literal|10
block|,
literal|5
block|,
literal|4
block|,
literal|4
block|,
literal|3
block|,
literal|2
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
operator|-
literal|1
block|,
operator|-
literal|2
block|,
operator|-
literal|2
block|,
operator|-
literal|5
block|,
operator|-
literal|5
block|,
operator|-
literal|10
block|,
operator|-
literal|10
block|,
operator|-
literal|15
block|,
operator|-
literal|20
block|,
operator|-
literal|20
block|,
operator|-
literal|15
block|,
operator|-
literal|15
block|,
operator|-
literal|10
block|,
operator|-
literal|10
block|,
operator|-
literal|5
block|,
operator|-
literal|5
block|,
operator|-
literal|2
block|,
operator|-
literal|2
block|,
operator|-
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|4
block|,
literal|5
block|,
literal|10
block|,
literal|20
block|,   }
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_function
specifier|static
name|void
DECL|function|af_warper_compute_line_best
name|af_warper_compute_line_best
parameter_list|(
name|AF_Warper
name|warper
parameter_list|,
name|FT_Fixed
name|scale
parameter_list|,
name|FT_Pos
name|delta
parameter_list|,
name|FT_Pos
name|xx1
parameter_list|,
name|FT_Pos
name|xx2
parameter_list|,
name|AF_WarpScore
name|base_distort
parameter_list|,
name|AF_Segment
name|segments
parameter_list|,
name|FT_UInt
name|num_segments
parameter_list|)
block|{
name|FT_Int
name|idx_min
decl_stmt|,
name|idx_max
decl_stmt|,
name|idx0
decl_stmt|;
name|FT_UInt
name|nn
decl_stmt|;
name|AF_WarpScore
name|scores
index|[
literal|65
index|]
decl_stmt|;
for|for
control|(
name|nn
operator|=
literal|0
init|;
name|nn
operator|<
literal|65
condition|;
name|nn
operator|++
control|)
name|scores
index|[
name|nn
index|]
operator|=
literal|0
expr_stmt|;
name|idx0
operator|=
name|xx1
operator|-
name|warper
operator|->
name|t1
expr_stmt|;
comment|/* compute minimum and maximum indices */
block|{
name|FT_Pos
name|xx1min
init|=
name|warper
operator|->
name|x1min
decl_stmt|;
name|FT_Pos
name|xx1max
init|=
name|warper
operator|->
name|x1max
decl_stmt|;
name|FT_Pos
name|w
init|=
name|xx2
operator|-
name|xx1
decl_stmt|;
if|if
condition|(
name|xx1min
operator|+
name|w
operator|<
name|warper
operator|->
name|x2min
condition|)
name|xx1min
operator|=
name|warper
operator|->
name|x2min
operator|-
name|w
expr_stmt|;
name|xx1max
operator|=
name|warper
operator|->
name|x1max
expr_stmt|;
if|if
condition|(
name|xx1max
operator|+
name|w
operator|>
name|warper
operator|->
name|x2max
condition|)
name|xx1max
operator|=
name|warper
operator|->
name|x2max
operator|-
name|w
expr_stmt|;
name|idx_min
operator|=
name|xx1min
operator|-
name|warper
operator|->
name|t1
expr_stmt|;
name|idx_max
operator|=
name|xx1max
operator|-
name|warper
operator|->
name|t1
expr_stmt|;
if|if
condition|(
name|idx_min
operator|<
literal|0
operator|||
name|idx_min
operator|>
name|idx_max
operator|||
name|idx_max
operator|>
literal|64
condition|)
block|{
name|AF_LOG
argument_list|(
operator|(
literal|"invalid indices:\n"
literal|"  min=%d max=%d, xx1=%ld xx2=%ld,\n"
literal|"  x1min=%ld x1max=%ld, x2min=%ld x2max=%ld\n"
operator|,
name|idx_min
operator|,
name|idx_max
operator|,
name|xx1
operator|,
name|xx2
operator|,
name|warper
operator|->
name|x1min
operator|,
name|warper
operator|->
name|x1max
operator|,
name|warper
operator|->
name|x2min
operator|,
name|warper
operator|->
name|x2max
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
for|for
control|(
name|nn
operator|=
literal|0
init|;
name|nn
operator|<
name|num_segments
condition|;
name|nn
operator|++
control|)
block|{
name|FT_Pos
name|len
init|=
name|segments
index|[
name|nn
index|]
operator|.
name|max_coord
operator|-
name|segments
index|[
name|nn
index|]
operator|.
name|min_coord
decl_stmt|;
name|FT_Pos
name|y0
init|=
name|FT_MulFix
argument_list|(
name|segments
index|[
name|nn
index|]
operator|.
name|pos
argument_list|,
name|scale
argument_list|)
operator|+
name|delta
decl_stmt|;
name|FT_Pos
name|y
init|=
name|y0
operator|+
operator|(
name|idx_min
operator|-
name|idx0
operator|)
decl_stmt|;
name|FT_Int
name|idx
decl_stmt|;
for|for
control|(
name|idx
operator|=
name|idx_min
init|;
name|idx
operator|<=
name|idx_max
condition|;
name|idx
operator|++
operator|,
name|y
operator|++
control|)
name|scores
index|[
name|idx
index|]
operator|+=
name|af_warper_weights
index|[
name|y
operator|&
literal|63
index|]
operator|*
name|len
expr_stmt|;
block|}
comment|/* find best score */
block|{
name|FT_Int
name|idx
decl_stmt|;
for|for
control|(
name|idx
operator|=
name|idx_min
init|;
name|idx
operator|<=
name|idx_max
condition|;
name|idx
operator|++
control|)
block|{
name|AF_WarpScore
name|score
init|=
name|scores
index|[
name|idx
index|]
decl_stmt|;
name|AF_WarpScore
name|distort
init|=
name|base_distort
operator|+
operator|(
name|idx
operator|-
name|idx0
operator|)
decl_stmt|;
if|if
condition|(
name|score
operator|>
name|warper
operator|->
name|best_score
operator|||
operator|(
name|score
operator|==
name|warper
operator|->
name|best_score
operator|&&
name|distort
operator|<
name|warper
operator|->
name|best_distort
operator|)
condition|)
block|{
name|warper
operator|->
name|best_score
operator|=
name|score
expr_stmt|;
name|warper
operator|->
name|best_distort
operator|=
name|distort
expr_stmt|;
name|warper
operator|->
name|best_scale
operator|=
name|scale
expr_stmt|;
name|warper
operator|->
name|best_delta
operator|=
name|delta
operator|+
operator|(
name|idx
operator|-
name|idx0
operator|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|af_warper_compute
name|af_warper_compute
argument_list|(
argument|AF_Warper      warper
argument_list|,
argument|AF_GlyphHints  hints
argument_list|,
argument|AF_Dimension   dim
argument_list|,
argument|FT_Fixed      *a_scale
argument_list|,
argument|FT_Pos        *a_delta
argument_list|)
end_macro
begin_block
block|{
name|AF_AxisHints
name|axis
decl_stmt|;
name|AF_Point
name|points
decl_stmt|;
name|FT_Fixed
name|org_scale
decl_stmt|;
name|FT_Pos
name|org_delta
decl_stmt|;
name|FT_UInt
name|nn
decl_stmt|,
name|num_points
decl_stmt|,
name|num_segments
decl_stmt|;
name|FT_Int
name|X1
decl_stmt|,
name|X2
decl_stmt|;
name|FT_Int
name|w
decl_stmt|;
name|AF_WarpScore
name|base_distort
decl_stmt|;
name|AF_Segment
name|segments
decl_stmt|;
comment|/* get original scaling transformation */
if|if
condition|(
name|dim
operator|==
name|AF_DIMENSION_VERT
condition|)
block|{
name|org_scale
operator|=
name|hints
operator|->
name|y_scale
expr_stmt|;
name|org_delta
operator|=
name|hints
operator|->
name|y_delta
expr_stmt|;
block|}
else|else
block|{
name|org_scale
operator|=
name|hints
operator|->
name|x_scale
expr_stmt|;
name|org_delta
operator|=
name|hints
operator|->
name|x_delta
expr_stmt|;
block|}
name|warper
operator|->
name|best_scale
operator|=
name|org_scale
expr_stmt|;
name|warper
operator|->
name|best_delta
operator|=
name|org_delta
expr_stmt|;
name|warper
operator|->
name|best_score
operator|=
name|INT_MIN
expr_stmt|;
name|warper
operator|->
name|best_distort
operator|=
literal|0
expr_stmt|;
name|axis
operator|=
operator|&
name|hints
operator|->
name|axis
index|[
name|dim
index|]
expr_stmt|;
name|segments
operator|=
name|axis
operator|->
name|segments
expr_stmt|;
name|num_segments
operator|=
name|axis
operator|->
name|num_segments
expr_stmt|;
name|points
operator|=
name|hints
operator|->
name|points
expr_stmt|;
name|num_points
operator|=
name|hints
operator|->
name|num_points
expr_stmt|;
operator|*
name|a_scale
operator|=
name|org_scale
expr_stmt|;
operator|*
name|a_delta
operator|=
name|org_delta
expr_stmt|;
comment|/* get X1 and X2, minimum and maximum in original coordinates */
if|if
condition|(
name|num_segments
operator|<
literal|1
condition|)
return|return;
if|#
directive|if
literal|1
name|X1
operator|=
name|X2
operator|=
name|points
index|[
literal|0
index|]
operator|.
name|fx
expr_stmt|;
for|for
control|(
name|nn
operator|=
literal|1
init|;
name|nn
operator|<
name|num_points
condition|;
name|nn
operator|++
control|)
block|{
name|FT_Int
name|X
init|=
name|points
index|[
name|nn
index|]
operator|.
name|fx
decl_stmt|;
if|if
condition|(
name|X
operator|<
name|X1
condition|)
name|X1
operator|=
name|X
expr_stmt|;
if|if
condition|(
name|X
operator|>
name|X2
condition|)
name|X2
operator|=
name|X
expr_stmt|;
block|}
else|#
directive|else
name|X1
operator|=
name|X2
operator|=
name|segments
index|[
literal|0
index|]
operator|.
name|pos
expr_stmt|;
for|for
control|(
name|nn
operator|=
literal|1
init|;
name|nn
operator|<
name|num_segments
condition|;
name|nn
operator|++
control|)
block|{
name|FT_Int
name|X
init|=
name|segments
index|[
name|nn
index|]
operator|.
name|pos
decl_stmt|;
if|if
condition|(
name|X
operator|<
name|X1
condition|)
name|X1
operator|=
name|X
expr_stmt|;
if|if
condition|(
name|X
operator|>
name|X2
condition|)
name|X2
operator|=
name|X
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|X1
operator|>=
name|X2
condition|)
return|return;
name|warper
operator|->
name|x1
operator|=
name|FT_MulFix
argument_list|(
name|X1
argument_list|,
name|org_scale
argument_list|)
operator|+
name|org_delta
expr_stmt|;
name|warper
operator|->
name|x2
operator|=
name|FT_MulFix
argument_list|(
name|X2
argument_list|,
name|org_scale
argument_list|)
operator|+
name|org_delta
expr_stmt|;
name|warper
operator|->
name|t1
operator|=
name|AF_WARPER_FLOOR
argument_list|(
name|warper
operator|->
name|x1
argument_list|)
expr_stmt|;
name|warper
operator|->
name|t2
operator|=
name|AF_WARPER_CEIL
argument_list|(
name|warper
operator|->
name|x2
argument_list|)
expr_stmt|;
name|warper
operator|->
name|x1min
operator|=
name|warper
operator|->
name|x1
operator|&
operator|~
literal|31
expr_stmt|;
name|warper
operator|->
name|x1max
operator|=
name|warper
operator|->
name|x1min
operator|+
literal|32
expr_stmt|;
name|warper
operator|->
name|x2min
operator|=
name|warper
operator|->
name|x2
operator|&
operator|~
literal|31
expr_stmt|;
name|warper
operator|->
name|x2max
operator|=
name|warper
operator|->
name|x2min
operator|+
literal|32
expr_stmt|;
if|if
condition|(
name|warper
operator|->
name|x1max
operator|>
name|warper
operator|->
name|x2
condition|)
name|warper
operator|->
name|x1max
operator|=
name|warper
operator|->
name|x2
expr_stmt|;
if|if
condition|(
name|warper
operator|->
name|x2min
operator|<
name|warper
operator|->
name|x1
condition|)
name|warper
operator|->
name|x2min
operator|=
name|warper
operator|->
name|x1
expr_stmt|;
name|warper
operator|->
name|w0
operator|=
name|warper
operator|->
name|x2
operator|-
name|warper
operator|->
name|x1
expr_stmt|;
if|if
condition|(
name|warper
operator|->
name|w0
operator|<=
literal|64
condition|)
block|{
name|warper
operator|->
name|x1max
operator|=
name|warper
operator|->
name|x1
expr_stmt|;
name|warper
operator|->
name|x2min
operator|=
name|warper
operator|->
name|x2
expr_stmt|;
block|}
name|warper
operator|->
name|wmin
operator|=
name|warper
operator|->
name|x2min
operator|-
name|warper
operator|->
name|x1max
expr_stmt|;
name|warper
operator|->
name|wmax
operator|=
name|warper
operator|->
name|x2max
operator|-
name|warper
operator|->
name|x1min
expr_stmt|;
if|#
directive|if
literal|1
block|{
name|int
name|margin
init|=
literal|16
decl_stmt|;
if|if
condition|(
name|warper
operator|->
name|w0
operator|<=
literal|128
condition|)
block|{
name|margin
operator|=
literal|8
expr_stmt|;
if|if
condition|(
name|warper
operator|->
name|w0
operator|<=
literal|96
condition|)
name|margin
operator|=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|warper
operator|->
name|wmin
operator|<
name|warper
operator|->
name|w0
operator|-
name|margin
condition|)
name|warper
operator|->
name|wmin
operator|=
name|warper
operator|->
name|w0
operator|-
name|margin
expr_stmt|;
if|if
condition|(
name|warper
operator|->
name|wmax
operator|>
name|warper
operator|->
name|w0
operator|+
name|margin
condition|)
name|warper
operator|->
name|wmax
operator|=
name|warper
operator|->
name|w0
operator|+
name|margin
expr_stmt|;
block|}
if|if
condition|(
name|warper
operator|->
name|wmin
operator|<
name|warper
operator|->
name|w0
operator|*
literal|3
operator|/
literal|4
condition|)
name|warper
operator|->
name|wmin
operator|=
name|warper
operator|->
name|w0
operator|*
literal|3
operator|/
literal|4
expr_stmt|;
if|if
condition|(
name|warper
operator|->
name|wmax
operator|>
name|warper
operator|->
name|w0
operator|*
literal|5
operator|/
literal|4
condition|)
name|warper
operator|->
name|wmax
operator|=
name|warper
operator|->
name|w0
operator|*
literal|5
operator|/
literal|4
expr_stmt|;
else|#
directive|else
comment|/* no scaling, just translation */
name|warper
operator|->
name|wmin
operator|=
name|warper
operator|->
name|wmax
operator|=
name|warper
operator|->
name|w0
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|w
operator|=
name|warper
operator|->
name|wmin
init|;
name|w
operator|<=
name|warper
operator|->
name|wmax
condition|;
name|w
operator|++
control|)
block|{
name|FT_Fixed
name|new_scale
decl_stmt|;
name|FT_Pos
name|new_delta
decl_stmt|;
name|FT_Pos
name|xx1
decl_stmt|,
name|xx2
decl_stmt|;
name|xx1
operator|=
name|warper
operator|->
name|x1
expr_stmt|;
name|xx2
operator|=
name|warper
operator|->
name|x2
expr_stmt|;
if|if
condition|(
name|w
operator|>=
name|warper
operator|->
name|w0
condition|)
block|{
name|xx1
operator|-=
name|w
operator|-
name|warper
operator|->
name|w0
expr_stmt|;
if|if
condition|(
name|xx1
operator|<
name|warper
operator|->
name|x1min
condition|)
block|{
name|xx2
operator|+=
name|warper
operator|->
name|x1min
operator|-
name|xx1
expr_stmt|;
name|xx1
operator|=
name|warper
operator|->
name|x1min
expr_stmt|;
block|}
block|}
else|else
block|{
name|xx1
operator|-=
name|w
operator|-
name|warper
operator|->
name|w0
expr_stmt|;
if|if
condition|(
name|xx1
operator|>
name|warper
operator|->
name|x1max
condition|)
block|{
name|xx2
operator|-=
name|xx1
operator|-
name|warper
operator|->
name|x1max
expr_stmt|;
name|xx1
operator|=
name|warper
operator|->
name|x1max
expr_stmt|;
block|}
block|}
if|if
condition|(
name|xx1
operator|<
name|warper
operator|->
name|x1
condition|)
name|base_distort
operator|=
name|warper
operator|->
name|x1
operator|-
name|xx1
expr_stmt|;
else|else
name|base_distort
operator|=
name|xx1
operator|-
name|warper
operator|->
name|x1
expr_stmt|;
if|if
condition|(
name|xx2
operator|<
name|warper
operator|->
name|x2
condition|)
name|base_distort
operator|+=
name|warper
operator|->
name|x2
operator|-
name|xx2
expr_stmt|;
else|else
name|base_distort
operator|+=
name|xx2
operator|-
name|warper
operator|->
name|x2
expr_stmt|;
name|base_distort
operator|*=
literal|10
expr_stmt|;
name|new_scale
operator|=
name|org_scale
operator|+
name|FT_DivFix
argument_list|(
name|w
operator|-
name|warper
operator|->
name|w0
argument_list|,
name|X2
operator|-
name|X1
argument_list|)
expr_stmt|;
name|new_delta
operator|=
name|xx1
operator|-
name|FT_MulFix
argument_list|(
name|X1
argument_list|,
name|new_scale
argument_list|)
expr_stmt|;
name|af_warper_compute_line_best
argument_list|(
name|warper
argument_list|,
name|new_scale
argument_list|,
name|new_delta
argument_list|,
name|xx1
argument_list|,
name|xx2
argument_list|,
name|base_distort
argument_list|,
name|segments
argument_list|,
name|num_segments
argument_list|)
expr_stmt|;
block|}
block|{
name|FT_Fixed
name|best_scale
init|=
name|warper
operator|->
name|best_scale
decl_stmt|;
name|FT_Pos
name|best_delta
init|=
name|warper
operator|->
name|best_delta
decl_stmt|;
name|hints
operator|->
name|xmin_delta
operator|=
name|FT_MulFix
argument_list|(
name|X1
argument_list|,
name|best_scale
operator|-
name|org_scale
argument_list|)
operator|+
name|best_delta
expr_stmt|;
name|hints
operator|->
name|xmax_delta
operator|=
name|FT_MulFix
argument_list|(
name|X2
argument_list|,
name|best_scale
operator|-
name|org_scale
argument_list|)
operator|+
name|best_delta
expr_stmt|;
operator|*
name|a_scale
operator|=
name|best_scale
expr_stmt|;
operator|*
name|a_delta
operator|=
name|best_delta
expr_stmt|;
block|}
block|}
end_block
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* !AF_USE_WARPER */
end_comment
begin_decl_stmt
DECL|variable|af_warper_dummy
name|char
name|af_warper_dummy
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_comment
DECL|variable|af_warper_dummy
comment|/* make compiler happy */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* !AF_USE_WARPER */
end_comment
begin_comment
comment|/* END */
end_comment
end_unit
