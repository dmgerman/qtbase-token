begin_unit
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  afhints.c                                                              */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*    Auto-fitter hinting routines (body).                                 */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  Copyright 2003-2007, 2009-2014 by                                      */
end_comment
begin_comment
comment|/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  This file is part of the FreeType project, and may only be used,       */
end_comment
begin_comment
comment|/*  modified, and distributed under the terms of the FreeType project      */
end_comment
begin_comment
comment|/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
end_comment
begin_comment
comment|/*  this file you indicate that you have read the license and              */
end_comment
begin_comment
comment|/*  understand and accept it fully.                                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"afhints.h"
end_include
begin_include
include|#
directive|include
file|"aferrors.h"
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_CALC_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_DEBUG_H
end_include
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
end_comment
begin_comment
comment|/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
end_comment
begin_comment
comment|/* messages during execution.                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_undef
DECL|macro|FT_COMPONENT
undef|#
directive|undef
name|FT_COMPONENT
end_undef
begin_define
DECL|macro|FT_COMPONENT
define|#
directive|define
name|FT_COMPONENT
value|trace_afhints
end_define
begin_comment
comment|/* Get new segment for given axis. */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|af_axis_hints_new_segment
argument_list|(
argument|AF_AxisHints  axis
argument_list|,
argument|FT_Memory     memory
argument_list|,
argument|AF_Segment   *asegment
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
name|AF_Segment
name|segment
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|axis
operator|->
name|num_segments
operator|>=
name|axis
operator|->
name|max_segments
condition|)
block|{
name|FT_Int
name|old_max
init|=
name|axis
operator|->
name|max_segments
decl_stmt|;
name|FT_Int
name|new_max
init|=
name|old_max
decl_stmt|;
name|FT_Int
name|big_max
init|=
call|(
name|FT_Int
call|)
argument_list|(
name|FT_INT_MAX
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|segment
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|old_max
operator|>=
name|big_max
condition|)
block|{
name|error
operator|=
name|FT_THROW
argument_list|(
name|Out_Of_Memory
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|new_max
operator|+=
operator|(
name|new_max
operator|>>
literal|2
operator|)
operator|+
literal|4
expr_stmt|;
if|if
condition|(
name|new_max
operator|<
name|old_max
operator|||
name|new_max
operator|>
name|big_max
condition|)
name|new_max
operator|=
name|big_max
expr_stmt|;
if|if
condition|(
name|FT_RENEW_ARRAY
argument_list|(
name|axis
operator|->
name|segments
argument_list|,
name|old_max
argument_list|,
name|new_max
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|axis
operator|->
name|max_segments
operator|=
name|new_max
expr_stmt|;
block|}
name|segment
operator|=
name|axis
operator|->
name|segments
operator|+
name|axis
operator|->
name|num_segments
operator|++
expr_stmt|;
name|Exit
label|:
operator|*
name|asegment
operator|=
name|segment
expr_stmt|;
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/* Get new edge for given axis, direction, and position, */
end_comment
begin_comment
comment|/* without initializing the edge itself.                 */
end_comment
begin_macro
DECL|function|FT_LOCAL
name|FT_LOCAL
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|af_axis_hints_new_edge
argument_list|(
argument|AF_AxisHints  axis
argument_list|,
argument|FT_Int        fpos
argument_list|,
argument|AF_Direction  dir
argument_list|,
argument|FT_Memory     memory
argument_list|,
argument|AF_Edge      *anedge
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
name|AF_Edge
name|edge
init|=
name|NULL
decl_stmt|;
name|AF_Edge
name|edges
decl_stmt|;
if|if
condition|(
name|axis
operator|->
name|num_edges
operator|>=
name|axis
operator|->
name|max_edges
condition|)
block|{
name|FT_Int
name|old_max
init|=
name|axis
operator|->
name|max_edges
decl_stmt|;
name|FT_Int
name|new_max
init|=
name|old_max
decl_stmt|;
name|FT_Int
name|big_max
init|=
call|(
name|FT_Int
call|)
argument_list|(
name|FT_INT_MAX
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|edge
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|old_max
operator|>=
name|big_max
condition|)
block|{
name|error
operator|=
name|FT_THROW
argument_list|(
name|Out_Of_Memory
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|new_max
operator|+=
operator|(
name|new_max
operator|>>
literal|2
operator|)
operator|+
literal|4
expr_stmt|;
if|if
condition|(
name|new_max
operator|<
name|old_max
operator|||
name|new_max
operator|>
name|big_max
condition|)
name|new_max
operator|=
name|big_max
expr_stmt|;
if|if
condition|(
name|FT_RENEW_ARRAY
argument_list|(
name|axis
operator|->
name|edges
argument_list|,
name|old_max
argument_list|,
name|new_max
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|axis
operator|->
name|max_edges
operator|=
name|new_max
expr_stmt|;
block|}
name|edges
operator|=
name|axis
operator|->
name|edges
expr_stmt|;
name|edge
operator|=
name|edges
operator|+
name|axis
operator|->
name|num_edges
expr_stmt|;
while|while
condition|(
name|edge
operator|>
name|edges
condition|)
block|{
if|if
condition|(
name|edge
index|[
operator|-
literal|1
index|]
operator|.
name|fpos
operator|<
name|fpos
condition|)
break|break;
comment|/* we want the edge with same position and minor direction */
comment|/* to appear before those in the major one in the list     */
if|if
condition|(
name|edge
index|[
operator|-
literal|1
index|]
operator|.
name|fpos
operator|==
name|fpos
operator|&&
name|dir
operator|==
name|axis
operator|->
name|major_dir
condition|)
break|break;
name|edge
index|[
literal|0
index|]
operator|=
name|edge
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|edge
operator|--
expr_stmt|;
block|}
name|axis
operator|->
name|num_edges
operator|++
expr_stmt|;
name|Exit
label|:
operator|*
name|anedge
operator|=
name|edge
expr_stmt|;
return|return
name|error
return|;
block|}
end_block
begin_ifdef
ifdef|#
directive|ifdef
name|FT_DEBUG_AUTOFIT
end_ifdef
begin_include
include|#
directive|include
include|FT_CONFIG_STANDARD_LIBRARY_H
end_include
begin_comment
comment|/* The dump functions are used in the `ftgrid' demo program, too. */
end_comment
begin_define
DECL|macro|AF_DUMP
define|#
directive|define
name|AF_DUMP
parameter_list|(
name|varformat
parameter_list|)
define|\
value|do                          \           {                           \             if ( to_stdout )          \               printf varformat;       \             else                      \               FT_TRACE7( varformat ); \           } while ( 0 )
end_define
begin_function
specifier|static
specifier|const
name|char
modifier|*
DECL|function|af_dir_str
name|af_dir_str
parameter_list|(
name|AF_Direction
name|dir
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|result
decl_stmt|;
switch|switch
condition|(
name|dir
condition|)
block|{
case|case
name|AF_DIR_UP
case|:
name|result
operator|=
literal|"up"
expr_stmt|;
break|break;
case|case
name|AF_DIR_DOWN
case|:
name|result
operator|=
literal|"down"
expr_stmt|;
break|break;
case|case
name|AF_DIR_LEFT
case|:
name|result
operator|=
literal|"left"
expr_stmt|;
break|break;
case|case
name|AF_DIR_RIGHT
case|:
name|result
operator|=
literal|"right"
expr_stmt|;
break|break;
default|default:
name|result
operator|=
literal|"none"
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function
begin_define
DECL|macro|AF_INDEX_NUM
define|#
directive|define
name|AF_INDEX_NUM
parameter_list|(
name|ptr
parameter_list|,
name|base
parameter_list|)
value|(int)( (ptr) ? ( (ptr) - (base) ) : -1 )
end_define
begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef
begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
name|void
DECL|function|af_glyph_hints_dump_points
name|af_glyph_hints_dump_points
parameter_list|(
name|AF_GlyphHints
name|hints
parameter_list|,
name|FT_Bool
name|to_stdout
parameter_list|)
block|{
name|AF_Point
name|points
init|=
name|hints
operator|->
name|points
decl_stmt|;
name|AF_Point
name|limit
init|=
name|points
operator|+
name|hints
operator|->
name|num_points
decl_stmt|;
name|AF_Point
name|point
decl_stmt|;
name|AF_DUMP
argument_list|(
operator|(
literal|"Table of points:\n"
literal|"  [ index |  xorg |  yorg | xscale | yscale"
literal|" |  xfit |  yfit |  flags ]\n"
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|point
operator|=
name|points
init|;
name|point
operator|<
name|limit
condition|;
name|point
operator|++
control|)
name|AF_DUMP
argument_list|(
operator|(
literal|"  [ %5d | %5d | %5d | %6.2f | %6.2f"
literal|" | %5.2f | %5.2f | %c ]\n"
operator|,
name|AF_INDEX_NUM
argument_list|(
name|point
argument_list|,
name|points
argument_list|)
operator|,
name|point
operator|->
name|fx
operator|,
name|point
operator|->
name|fy
operator|,
name|point
operator|->
name|ox
operator|/
literal|64.0
operator|,
name|point
operator|->
name|oy
operator|/
literal|64.0
operator|,
name|point
operator|->
name|x
operator|/
literal|64.0
operator|,
name|point
operator|->
name|y
operator|/
literal|64.0
operator|,
operator|(
name|point
operator|->
name|flags
operator|&
name|AF_FLAG_WEAK_INTERPOLATION
operator|)
condition|?
literal|'w'
else|:
literal|' '
operator|)
argument_list|)
expr_stmt|;
name|AF_DUMP
argument_list|(
operator|(
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern
begin_endif
endif|#
directive|endif
end_endif
begin_function
specifier|static
specifier|const
name|char
modifier|*
DECL|function|af_edge_flags_to_string
name|af_edge_flags_to_string
parameter_list|(
name|AF_Edge_Flags
name|flags
parameter_list|)
block|{
specifier|static
name|char
name|temp
index|[
literal|32
index|]
decl_stmt|;
name|int
name|pos
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|AF_EDGE_ROUND
condition|)
block|{
name|ft_memcpy
argument_list|(
name|temp
operator|+
name|pos
argument_list|,
literal|"round"
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|pos
operator|+=
literal|5
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|AF_EDGE_SERIF
condition|)
block|{
if|if
condition|(
name|pos
operator|>
literal|0
condition|)
name|temp
index|[
name|pos
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
name|ft_memcpy
argument_list|(
name|temp
operator|+
name|pos
argument_list|,
literal|"serif"
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|pos
operator|+=
literal|5
expr_stmt|;
block|}
if|if
condition|(
name|pos
operator|==
literal|0
condition|)
return|return
literal|"normal"
return|;
name|temp
index|[
name|pos
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|temp
return|;
block|}
end_function
begin_comment
comment|/* Dump the array of linked segments. */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef
begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
name|void
DECL|function|af_glyph_hints_dump_segments
name|af_glyph_hints_dump_segments
parameter_list|(
name|AF_GlyphHints
name|hints
parameter_list|,
name|FT_Bool
name|to_stdout
parameter_list|)
block|{
name|FT_Int
name|dimension
decl_stmt|;
for|for
control|(
name|dimension
operator|=
literal|1
init|;
name|dimension
operator|>=
literal|0
condition|;
name|dimension
operator|--
control|)
block|{
name|AF_AxisHints
name|axis
init|=
operator|&
name|hints
operator|->
name|axis
index|[
name|dimension
index|]
decl_stmt|;
name|AF_Point
name|points
init|=
name|hints
operator|->
name|points
decl_stmt|;
name|AF_Edge
name|edges
init|=
name|axis
operator|->
name|edges
decl_stmt|;
name|AF_Segment
name|segments
init|=
name|axis
operator|->
name|segments
decl_stmt|;
name|AF_Segment
name|limit
init|=
name|segments
operator|+
name|axis
operator|->
name|num_segments
decl_stmt|;
name|AF_Segment
name|seg
decl_stmt|;
name|AF_DUMP
argument_list|(
operator|(
literal|"Table of %s segments:\n"
operator|,
name|dimension
operator|==
name|AF_DIMENSION_HORZ
condition|?
literal|"vertical"
else|:
literal|"horizontal"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|axis
operator|->
name|num_segments
condition|)
name|AF_DUMP
argument_list|(
operator|(
literal|"  [ index |  pos  |  dir  | from"
literal|" |  to  | link | serif | edge"
literal|" | height | extra |    flags    ]\n"
operator|)
argument_list|)
expr_stmt|;
else|else
name|AF_DUMP
argument_list|(
operator|(
literal|"  (none)\n"
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|seg
operator|=
name|segments
init|;
name|seg
operator|<
name|limit
condition|;
name|seg
operator|++
control|)
name|AF_DUMP
argument_list|(
operator|(
literal|"  [ %5d | %5.2g | %5s | %4d"
literal|" | %4d | %4d | %5d | %4d"
literal|" | %6d | %5d | %11s ]\n"
operator|,
name|AF_INDEX_NUM
argument_list|(
name|seg
argument_list|,
name|segments
argument_list|)
operator|,
name|dimension
operator|==
name|AF_DIMENSION_HORZ
condition|?
operator|(
name|int
operator|)
name|seg
operator|->
name|first
operator|->
name|ox
operator|/
literal|64.0
else|:
operator|(
name|int
operator|)
name|seg
operator|->
name|first
operator|->
name|oy
operator|/
literal|64.0
operator|,
name|af_dir_str
argument_list|(
operator|(
name|AF_Direction
operator|)
name|seg
operator|->
name|dir
argument_list|)
operator|,
name|AF_INDEX_NUM
argument_list|(
name|seg
operator|->
name|first
argument_list|,
name|points
argument_list|)
operator|,
name|AF_INDEX_NUM
argument_list|(
name|seg
operator|->
name|last
argument_list|,
name|points
argument_list|)
operator|,
name|AF_INDEX_NUM
argument_list|(
name|seg
operator|->
name|link
argument_list|,
name|segments
argument_list|)
operator|,
name|AF_INDEX_NUM
argument_list|(
name|seg
operator|->
name|serif
argument_list|,
name|segments
argument_list|)
operator|,
name|AF_INDEX_NUM
argument_list|(
name|seg
operator|->
name|edge
argument_list|,
name|edges
argument_list|)
operator|,
name|seg
operator|->
name|height
operator|,
name|seg
operator|->
name|height
operator|-
operator|(
name|seg
operator|->
name|max_coord
operator|-
name|seg
operator|->
name|min_coord
operator|)
operator|,
name|af_edge_flags_to_string
argument_list|(
operator|(
name|AF_Edge_Flags
operator|)
name|seg
operator|->
name|flags
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|AF_DUMP
argument_list|(
operator|(
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* Fetch number of segments. */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef
begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
name|FT_Error
DECL|function|af_glyph_hints_get_num_segments
name|af_glyph_hints_get_num_segments
parameter_list|(
name|AF_GlyphHints
name|hints
parameter_list|,
name|FT_Int
name|dimension
parameter_list|,
name|FT_Int
modifier|*
name|num_segments
parameter_list|)
block|{
name|AF_Dimension
name|dim
decl_stmt|;
name|AF_AxisHints
name|axis
decl_stmt|;
name|dim
operator|=
operator|(
name|dimension
operator|==
literal|0
operator|)
condition|?
name|AF_DIMENSION_HORZ
else|:
name|AF_DIMENSION_VERT
expr_stmt|;
name|axis
operator|=
operator|&
name|hints
operator|->
name|axis
index|[
name|dim
index|]
expr_stmt|;
operator|*
name|num_segments
operator|=
name|axis
operator|->
name|num_segments
expr_stmt|;
return|return
name|FT_Err_Ok
return|;
block|}
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* Fetch offset of segments into user supplied offset array. */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef
begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
name|FT_Error
DECL|function|af_glyph_hints_get_segment_offset
name|af_glyph_hints_get_segment_offset
parameter_list|(
name|AF_GlyphHints
name|hints
parameter_list|,
name|FT_Int
name|dimension
parameter_list|,
name|FT_Int
name|idx
parameter_list|,
name|FT_Pos
modifier|*
name|offset
parameter_list|,
name|FT_Bool
modifier|*
name|is_blue
parameter_list|,
name|FT_Pos
modifier|*
name|blue_offset
parameter_list|)
block|{
name|AF_Dimension
name|dim
decl_stmt|;
name|AF_AxisHints
name|axis
decl_stmt|;
name|AF_Segment
name|seg
decl_stmt|;
if|if
condition|(
operator|!
name|offset
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_Argument
argument_list|)
return|;
name|dim
operator|=
operator|(
name|dimension
operator|==
literal|0
operator|)
condition|?
name|AF_DIMENSION_HORZ
else|:
name|AF_DIMENSION_VERT
expr_stmt|;
name|axis
operator|=
operator|&
name|hints
operator|->
name|axis
index|[
name|dim
index|]
expr_stmt|;
if|if
condition|(
name|idx
operator|<
literal|0
operator|||
name|idx
operator|>=
name|axis
operator|->
name|num_segments
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_Argument
argument_list|)
return|;
name|seg
operator|=
operator|&
name|axis
operator|->
name|segments
index|[
name|idx
index|]
expr_stmt|;
operator|*
name|offset
operator|=
operator|(
name|dim
operator|==
name|AF_DIMENSION_HORZ
operator|)
condition|?
name|seg
operator|->
name|first
operator|->
name|ox
else|:
name|seg
operator|->
name|first
operator|->
name|oy
expr_stmt|;
if|if
condition|(
name|seg
operator|->
name|edge
condition|)
operator|*
name|is_blue
operator|=
call|(
name|FT_Bool
call|)
argument_list|(
name|seg
operator|->
name|edge
operator|->
name|blue_edge
operator|!=
literal|0
argument_list|)
expr_stmt|;
else|else
operator|*
name|is_blue
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|*
name|is_blue
condition|)
operator|*
name|blue_offset
operator|=
name|seg
operator|->
name|edge
operator|->
name|blue_edge
operator|->
name|cur
expr_stmt|;
else|else
operator|*
name|blue_offset
operator|=
literal|0
expr_stmt|;
return|return
name|FT_Err_Ok
return|;
block|}
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* Dump the array of linked edges. */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef
begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
name|void
DECL|function|af_glyph_hints_dump_edges
name|af_glyph_hints_dump_edges
parameter_list|(
name|AF_GlyphHints
name|hints
parameter_list|,
name|FT_Bool
name|to_stdout
parameter_list|)
block|{
name|FT_Int
name|dimension
decl_stmt|;
for|for
control|(
name|dimension
operator|=
literal|1
init|;
name|dimension
operator|>=
literal|0
condition|;
name|dimension
operator|--
control|)
block|{
name|AF_AxisHints
name|axis
init|=
operator|&
name|hints
operator|->
name|axis
index|[
name|dimension
index|]
decl_stmt|;
name|AF_Edge
name|edges
init|=
name|axis
operator|->
name|edges
decl_stmt|;
name|AF_Edge
name|limit
init|=
name|edges
operator|+
name|axis
operator|->
name|num_edges
decl_stmt|;
name|AF_Edge
name|edge
decl_stmt|;
comment|/*        *  note: AF_DIMENSION_HORZ corresponds to _vertical_ edges        *        since they have a constant X coordinate.        */
name|AF_DUMP
argument_list|(
operator|(
literal|"Table of %s edges:\n"
operator|,
name|dimension
operator|==
name|AF_DIMENSION_HORZ
condition|?
literal|"vertical"
else|:
literal|"horizontal"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|axis
operator|->
name|num_edges
condition|)
name|AF_DUMP
argument_list|(
operator|(
literal|"  [ index |  pos  |  dir  | link"
literal|" | serif | blue | opos  |  pos  |    flags    ]\n"
operator|)
argument_list|)
expr_stmt|;
else|else
name|AF_DUMP
argument_list|(
operator|(
literal|"  (none)\n"
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|edge
operator|=
name|edges
init|;
name|edge
operator|<
name|limit
condition|;
name|edge
operator|++
control|)
name|AF_DUMP
argument_list|(
operator|(
literal|"  [ %5d | %5.2g | %5s | %4d"
literal|" | %5d |   %c  | %5.2f | %5.2f | %11s ]\n"
operator|,
name|AF_INDEX_NUM
argument_list|(
name|edge
argument_list|,
name|edges
argument_list|)
operator|,
operator|(
name|int
operator|)
name|edge
operator|->
name|opos
operator|/
literal|64.0
operator|,
name|af_dir_str
argument_list|(
operator|(
name|AF_Direction
operator|)
name|edge
operator|->
name|dir
argument_list|)
operator|,
name|AF_INDEX_NUM
argument_list|(
name|edge
operator|->
name|link
argument_list|,
name|edges
argument_list|)
operator|,
name|AF_INDEX_NUM
argument_list|(
name|edge
operator|->
name|serif
argument_list|,
name|edges
argument_list|)
operator|,
name|edge
operator|->
name|blue_edge
condition|?
literal|'y'
else|:
literal|'n'
operator|,
name|edge
operator|->
name|opos
operator|/
literal|64.0
operator|,
name|edge
operator|->
name|pos
operator|/
literal|64.0
operator|,
name|af_edge_flags_to_string
argument_list|(
operator|(
name|AF_Edge_Flags
operator|)
name|edge
operator|->
name|flags
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|AF_DUMP
argument_list|(
operator|(
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern
begin_endif
endif|#
directive|endif
end_endif
begin_undef
DECL|macro|AF_DUMP
undef|#
directive|undef
name|AF_DUMP
end_undef
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* !FT_DEBUG_AUTOFIT */
end_comment
begin_comment
comment|/* Compute the direction value of a given vector. */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|AF_Direction
argument_list|)
end_macro
begin_macro
name|af_direction_compute
argument_list|(
argument|FT_Pos  dx
argument_list|,
argument|FT_Pos  dy
argument_list|)
end_macro
begin_block
block|{
name|FT_Pos
name|ll
decl_stmt|,
name|ss
decl_stmt|;
comment|/* long and short arm lengths */
name|AF_Direction
name|dir
decl_stmt|;
comment|/* candidate direction        */
if|if
condition|(
name|dy
operator|>=
name|dx
condition|)
block|{
if|if
condition|(
name|dy
operator|>=
operator|-
name|dx
condition|)
block|{
name|dir
operator|=
name|AF_DIR_UP
expr_stmt|;
name|ll
operator|=
name|dy
expr_stmt|;
name|ss
operator|=
name|dx
expr_stmt|;
block|}
else|else
block|{
name|dir
operator|=
name|AF_DIR_LEFT
expr_stmt|;
name|ll
operator|=
operator|-
name|dx
expr_stmt|;
name|ss
operator|=
name|dy
expr_stmt|;
block|}
block|}
else|else
comment|/* dy< dx */
block|{
if|if
condition|(
name|dy
operator|>=
operator|-
name|dx
condition|)
block|{
name|dir
operator|=
name|AF_DIR_RIGHT
expr_stmt|;
name|ll
operator|=
name|dx
expr_stmt|;
name|ss
operator|=
name|dy
expr_stmt|;
block|}
else|else
block|{
name|dir
operator|=
name|AF_DIR_DOWN
expr_stmt|;
name|ll
operator|=
name|dy
expr_stmt|;
name|ss
operator|=
name|dx
expr_stmt|;
block|}
block|}
comment|/* return no direction if arm lengths differ too much            */
comment|/* (value 14 is heuristic, corresponding to approx. 4.1 degrees) */
name|ss
operator|*=
literal|14
expr_stmt|;
if|if
condition|(
name|FT_ABS
argument_list|(
name|ll
argument_list|)
operator|<=
name|FT_ABS
argument_list|(
name|ss
argument_list|)
condition|)
name|dir
operator|=
name|AF_DIR_NONE
expr_stmt|;
return|return
name|dir
return|;
block|}
end_block
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|af_glyph_hints_init
name|af_glyph_hints_init
argument_list|(
argument|AF_GlyphHints  hints
argument_list|,
argument|FT_Memory      memory
argument_list|)
end_macro
begin_block
block|{
name|FT_ZERO
argument_list|(
name|hints
argument_list|)
expr_stmt|;
name|hints
operator|->
name|memory
operator|=
name|memory
expr_stmt|;
block|}
end_block
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|af_glyph_hints_done
name|af_glyph_hints_done
argument_list|(
argument|AF_GlyphHints  hints
argument_list|)
end_macro
begin_block
block|{
name|FT_Memory
name|memory
init|=
name|hints
operator|->
name|memory
decl_stmt|;
name|int
name|dim
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|hints
operator|&&
name|hints
operator|->
name|memory
operator|)
condition|)
return|return;
comment|/*      *  note that we don't need to free the segment and edge      *  buffers since they are really within the hints->points array      */
for|for
control|(
name|dim
operator|=
literal|0
init|;
name|dim
operator|<
name|AF_DIMENSION_MAX
condition|;
name|dim
operator|++
control|)
block|{
name|AF_AxisHints
name|axis
init|=
operator|&
name|hints
operator|->
name|axis
index|[
name|dim
index|]
decl_stmt|;
name|axis
operator|->
name|num_segments
operator|=
literal|0
expr_stmt|;
name|axis
operator|->
name|max_segments
operator|=
literal|0
expr_stmt|;
name|FT_FREE
argument_list|(
name|axis
operator|->
name|segments
argument_list|)
expr_stmt|;
name|axis
operator|->
name|num_edges
operator|=
literal|0
expr_stmt|;
name|axis
operator|->
name|max_edges
operator|=
literal|0
expr_stmt|;
name|FT_FREE
argument_list|(
name|axis
operator|->
name|edges
argument_list|)
expr_stmt|;
block|}
name|FT_FREE
argument_list|(
name|hints
operator|->
name|contours
argument_list|)
expr_stmt|;
name|hints
operator|->
name|max_contours
operator|=
literal|0
expr_stmt|;
name|hints
operator|->
name|num_contours
operator|=
literal|0
expr_stmt|;
name|FT_FREE
argument_list|(
name|hints
operator|->
name|points
argument_list|)
expr_stmt|;
name|hints
operator|->
name|num_points
operator|=
literal|0
expr_stmt|;
name|hints
operator|->
name|max_points
operator|=
literal|0
expr_stmt|;
name|hints
operator|->
name|memory
operator|=
name|NULL
expr_stmt|;
block|}
end_block
begin_comment
comment|/* Reset metrics. */
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|af_glyph_hints_rescale
name|af_glyph_hints_rescale
argument_list|(
argument|AF_GlyphHints    hints
argument_list|,
argument|AF_StyleMetrics  metrics
argument_list|)
end_macro
begin_block
block|{
name|hints
operator|->
name|metrics
operator|=
name|metrics
expr_stmt|;
name|hints
operator|->
name|scaler_flags
operator|=
name|metrics
operator|->
name|scaler
operator|.
name|flags
expr_stmt|;
block|}
end_block
begin_comment
comment|/* Recompute all AF_Point in AF_GlyphHints from the definitions */
end_comment
begin_comment
comment|/* in a source outline.                                         */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|af_glyph_hints_reload
argument_list|(
argument|AF_GlyphHints  hints
argument_list|,
argument|FT_Outline*    outline
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
name|AF_Point
name|points
decl_stmt|;
name|FT_UInt
name|old_max
decl_stmt|,
name|new_max
decl_stmt|;
name|FT_Fixed
name|x_scale
init|=
name|hints
operator|->
name|x_scale
decl_stmt|;
name|FT_Fixed
name|y_scale
init|=
name|hints
operator|->
name|y_scale
decl_stmt|;
name|FT_Pos
name|x_delta
init|=
name|hints
operator|->
name|x_delta
decl_stmt|;
name|FT_Pos
name|y_delta
init|=
name|hints
operator|->
name|y_delta
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|hints
operator|->
name|memory
decl_stmt|;
name|hints
operator|->
name|num_points
operator|=
literal|0
expr_stmt|;
name|hints
operator|->
name|num_contours
operator|=
literal|0
expr_stmt|;
name|hints
operator|->
name|axis
index|[
literal|0
index|]
operator|.
name|num_segments
operator|=
literal|0
expr_stmt|;
name|hints
operator|->
name|axis
index|[
literal|0
index|]
operator|.
name|num_edges
operator|=
literal|0
expr_stmt|;
name|hints
operator|->
name|axis
index|[
literal|1
index|]
operator|.
name|num_segments
operator|=
literal|0
expr_stmt|;
name|hints
operator|->
name|axis
index|[
literal|1
index|]
operator|.
name|num_edges
operator|=
literal|0
expr_stmt|;
comment|/* first of all, reallocate the contours array if necessary */
name|new_max
operator|=
operator|(
name|FT_UInt
operator|)
name|outline
operator|->
name|n_contours
expr_stmt|;
name|old_max
operator|=
name|hints
operator|->
name|max_contours
expr_stmt|;
if|if
condition|(
name|new_max
operator|>
name|old_max
condition|)
block|{
name|new_max
operator|=
operator|(
name|new_max
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
expr_stmt|;
comment|/* round up to a multiple of 4 */
if|if
condition|(
name|FT_RENEW_ARRAY
argument_list|(
name|hints
operator|->
name|contours
argument_list|,
name|old_max
argument_list|,
name|new_max
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|hints
operator|->
name|max_contours
operator|=
name|new_max
expr_stmt|;
block|}
comment|/*      *  then reallocate the points arrays if necessary --      *  note that we reserve two additional point positions, used to      *  hint metrics appropriately      */
name|new_max
operator|=
call|(
name|FT_UInt
call|)
argument_list|(
name|outline
operator|->
name|n_points
operator|+
literal|2
argument_list|)
expr_stmt|;
name|old_max
operator|=
name|hints
operator|->
name|max_points
expr_stmt|;
if|if
condition|(
name|new_max
operator|>
name|old_max
condition|)
block|{
name|new_max
operator|=
operator|(
name|new_max
operator|+
literal|2
operator|+
literal|7
operator|)
operator|&
operator|~
literal|7
expr_stmt|;
comment|/* round up to a multiple of 8 */
if|if
condition|(
name|FT_RENEW_ARRAY
argument_list|(
name|hints
operator|->
name|points
argument_list|,
name|old_max
argument_list|,
name|new_max
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|hints
operator|->
name|max_points
operator|=
name|new_max
expr_stmt|;
block|}
name|hints
operator|->
name|num_points
operator|=
name|outline
operator|->
name|n_points
expr_stmt|;
name|hints
operator|->
name|num_contours
operator|=
name|outline
operator|->
name|n_contours
expr_stmt|;
comment|/* We can't rely on the value of `FT_Outline.flags' to know the fill   */
comment|/* direction used for a glyph, given that some fonts are broken (e.g., */
comment|/* the Arphic ones).  We thus recompute it each time we need to.       */
comment|/*                                                                     */
name|hints
operator|->
name|axis
index|[
name|AF_DIMENSION_HORZ
index|]
operator|.
name|major_dir
operator|=
name|AF_DIR_UP
expr_stmt|;
name|hints
operator|->
name|axis
index|[
name|AF_DIMENSION_VERT
index|]
operator|.
name|major_dir
operator|=
name|AF_DIR_LEFT
expr_stmt|;
if|if
condition|(
name|FT_Outline_Get_Orientation
argument_list|(
name|outline
argument_list|)
operator|==
name|FT_ORIENTATION_POSTSCRIPT
condition|)
block|{
name|hints
operator|->
name|axis
index|[
name|AF_DIMENSION_HORZ
index|]
operator|.
name|major_dir
operator|=
name|AF_DIR_DOWN
expr_stmt|;
name|hints
operator|->
name|axis
index|[
name|AF_DIMENSION_VERT
index|]
operator|.
name|major_dir
operator|=
name|AF_DIR_RIGHT
expr_stmt|;
block|}
name|hints
operator|->
name|x_scale
operator|=
name|x_scale
expr_stmt|;
name|hints
operator|->
name|y_scale
operator|=
name|y_scale
expr_stmt|;
name|hints
operator|->
name|x_delta
operator|=
name|x_delta
expr_stmt|;
name|hints
operator|->
name|y_delta
operator|=
name|y_delta
expr_stmt|;
name|hints
operator|->
name|xmin_delta
operator|=
literal|0
expr_stmt|;
name|hints
operator|->
name|xmax_delta
operator|=
literal|0
expr_stmt|;
name|points
operator|=
name|hints
operator|->
name|points
expr_stmt|;
if|if
condition|(
name|hints
operator|->
name|num_points
operator|==
literal|0
condition|)
goto|goto
name|Exit
goto|;
block|{
name|AF_Point
name|point
decl_stmt|;
name|AF_Point
name|point_limit
init|=
name|points
operator|+
name|hints
operator|->
name|num_points
decl_stmt|;
comment|/* compute coordinates& Bezier flags, next and prev */
block|{
name|FT_Vector
modifier|*
name|vec
init|=
name|outline
operator|->
name|points
decl_stmt|;
name|char
modifier|*
name|tag
init|=
name|outline
operator|->
name|tags
decl_stmt|;
name|AF_Point
name|end
init|=
name|points
operator|+
name|outline
operator|->
name|contours
index|[
literal|0
index|]
decl_stmt|;
name|AF_Point
name|prev
init|=
name|end
decl_stmt|;
name|FT_Int
name|contour_index
init|=
literal|0
decl_stmt|;
for|for
control|(
name|point
operator|=
name|points
init|;
name|point
operator|<
name|point_limit
condition|;
name|point
operator|++
operator|,
name|vec
operator|++
operator|,
name|tag
operator|++
control|)
block|{
name|point
operator|->
name|in_dir
operator|=
operator|(
name|FT_Char
operator|)
name|AF_DIR_NONE
expr_stmt|;
name|point
operator|->
name|out_dir
operator|=
operator|(
name|FT_Char
operator|)
name|AF_DIR_NONE
expr_stmt|;
name|point
operator|->
name|fx
operator|=
operator|(
name|FT_Short
operator|)
name|vec
operator|->
name|x
expr_stmt|;
name|point
operator|->
name|fy
operator|=
operator|(
name|FT_Short
operator|)
name|vec
operator|->
name|y
expr_stmt|;
name|point
operator|->
name|ox
operator|=
name|point
operator|->
name|x
operator|=
name|FT_MulFix
argument_list|(
name|vec
operator|->
name|x
argument_list|,
name|x_scale
argument_list|)
operator|+
name|x_delta
expr_stmt|;
name|point
operator|->
name|oy
operator|=
name|point
operator|->
name|y
operator|=
name|FT_MulFix
argument_list|(
name|vec
operator|->
name|y
argument_list|,
name|y_scale
argument_list|)
operator|+
name|y_delta
expr_stmt|;
switch|switch
condition|(
name|FT_CURVE_TAG
argument_list|(
operator|*
name|tag
argument_list|)
condition|)
block|{
case|case
name|FT_CURVE_TAG_CONIC
case|:
name|point
operator|->
name|flags
operator|=
name|AF_FLAG_CONIC
expr_stmt|;
break|break;
case|case
name|FT_CURVE_TAG_CUBIC
case|:
name|point
operator|->
name|flags
operator|=
name|AF_FLAG_CUBIC
expr_stmt|;
break|break;
default|default:
name|point
operator|->
name|flags
operator|=
name|AF_FLAG_NONE
expr_stmt|;
block|}
name|point
operator|->
name|prev
operator|=
name|prev
expr_stmt|;
name|prev
operator|->
name|next
operator|=
name|point
expr_stmt|;
name|prev
operator|=
name|point
expr_stmt|;
if|if
condition|(
name|point
operator|==
name|end
condition|)
block|{
if|if
condition|(
operator|++
name|contour_index
operator|<
name|outline
operator|->
name|n_contours
condition|)
block|{
name|end
operator|=
name|points
operator|+
name|outline
operator|->
name|contours
index|[
name|contour_index
index|]
expr_stmt|;
name|prev
operator|=
name|end
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* set up the contours array */
block|{
name|AF_Point
modifier|*
name|contour
init|=
name|hints
operator|->
name|contours
decl_stmt|;
name|AF_Point
modifier|*
name|contour_limit
init|=
name|contour
operator|+
name|hints
operator|->
name|num_contours
decl_stmt|;
name|short
modifier|*
name|end
init|=
name|outline
operator|->
name|contours
decl_stmt|;
name|short
name|idx
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|contour
operator|<
name|contour_limit
condition|;
name|contour
operator|++
operator|,
name|end
operator|++
control|)
block|{
name|contour
index|[
literal|0
index|]
operator|=
name|points
operator|+
name|idx
expr_stmt|;
name|idx
operator|=
call|(
name|short
call|)
argument_list|(
name|end
index|[
literal|0
index|]
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|{
comment|/*          *  Compute directions of `in' and `out' vectors.          *          *  Note that distances between points that are very near to each          *  other are accumulated.  In other words, the auto-hinter          *  prepends the small vectors between near points to the first          *  non-near vector.  All intermediate points are tagged as          *  weak; the directions are adjusted also to be equal to the          *  accumulated one.          */
comment|/* value 20 in `near_limit' is heuristic */
name|FT_UInt
name|units_per_em
init|=
name|hints
operator|->
name|metrics
operator|->
name|scaler
operator|.
name|face
operator|->
name|units_per_EM
decl_stmt|;
name|FT_Int
name|near_limit
init|=
literal|20
operator|*
name|units_per_em
operator|/
literal|2048
decl_stmt|;
name|FT_Int
name|near_limit2
init|=
literal|2
operator|*
name|near_limit
operator|-
literal|1
decl_stmt|;
name|AF_Point
modifier|*
name|contour
decl_stmt|;
name|AF_Point
modifier|*
name|contour_limit
init|=
name|hints
operator|->
name|contours
operator|+
name|hints
operator|->
name|num_contours
decl_stmt|;
for|for
control|(
name|contour
operator|=
name|hints
operator|->
name|contours
init|;
name|contour
operator|<
name|contour_limit
condition|;
name|contour
operator|++
control|)
block|{
name|AF_Point
name|first
init|=
operator|*
name|contour
decl_stmt|;
name|AF_Point
name|next
decl_stmt|,
name|prev
decl_stmt|,
name|curr
decl_stmt|;
name|FT_Pos
name|out_x
decl_stmt|,
name|out_y
decl_stmt|;
name|FT_Bool
name|is_first
decl_stmt|;
comment|/* since the first point of a contour could be part of a */
comment|/* series of near points, go backwards to find the first */
comment|/* non-near point and adjust `first'                     */
name|point
operator|=
name|first
expr_stmt|;
name|prev
operator|=
name|first
operator|->
name|prev
expr_stmt|;
while|while
condition|(
name|prev
operator|!=
name|first
condition|)
block|{
name|out_x
operator|=
name|point
operator|->
name|fx
operator|-
name|prev
operator|->
name|fx
expr_stmt|;
name|out_y
operator|=
name|point
operator|->
name|fy
operator|-
name|prev
operator|->
name|fy
expr_stmt|;
comment|/*              *  We use Taxicab metrics to measure the vector length.              *              *  Note that the accumulated distances so far could have the              *  opposite direction of the distance measured here.  For this              *  reason we use `near_limit2' for the comparison to get a              *  non-near point even in the worst case.              */
if|if
condition|(
name|FT_ABS
argument_list|(
name|out_x
argument_list|)
operator|+
name|FT_ABS
argument_list|(
name|out_y
argument_list|)
operator|>=
name|near_limit2
condition|)
break|break;
name|point
operator|=
name|prev
expr_stmt|;
name|prev
operator|=
name|prev
operator|->
name|prev
expr_stmt|;
block|}
comment|/* adjust first point */
name|first
operator|=
name|point
expr_stmt|;
comment|/* now loop over all points of the contour to get */
comment|/* `in' and `out' vector directions               */
name|curr
operator|=
name|first
expr_stmt|;
comment|/*            *  We abuse the `u' and `v' fields to store index deltas to the            *  next and previous non-near point, respectively.            *            *  To avoid problems with not having non-near points, we point to            *  `first' by default as the next non-near point.            *            */
name|curr
operator|->
name|u
operator|=
call|(
name|FT_Pos
call|)
argument_list|(
name|first
operator|-
name|curr
argument_list|)
expr_stmt|;
name|first
operator|->
name|v
operator|=
operator|-
name|curr
operator|->
name|u
expr_stmt|;
name|out_x
operator|=
literal|0
expr_stmt|;
name|out_y
operator|=
literal|0
expr_stmt|;
name|is_first
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|point
operator|=
name|first
init|;
name|point
operator|!=
name|first
operator|||
name|is_first
condition|;
name|point
operator|=
name|point
operator|->
name|next
control|)
block|{
name|AF_Direction
name|out_dir
decl_stmt|;
name|is_first
operator|=
literal|0
expr_stmt|;
name|next
operator|=
name|point
operator|->
name|next
expr_stmt|;
name|out_x
operator|+=
name|next
operator|->
name|fx
operator|-
name|point
operator|->
name|fx
expr_stmt|;
name|out_y
operator|+=
name|next
operator|->
name|fy
operator|-
name|point
operator|->
name|fy
expr_stmt|;
if|if
condition|(
name|FT_ABS
argument_list|(
name|out_x
argument_list|)
operator|+
name|FT_ABS
argument_list|(
name|out_y
argument_list|)
operator|<
name|near_limit
condition|)
block|{
name|next
operator|->
name|flags
operator||=
name|AF_FLAG_WEAK_INTERPOLATION
expr_stmt|;
continue|continue;
block|}
name|curr
operator|->
name|u
operator|=
call|(
name|FT_Pos
call|)
argument_list|(
name|next
operator|-
name|curr
argument_list|)
expr_stmt|;
name|next
operator|->
name|v
operator|=
operator|-
name|curr
operator|->
name|u
expr_stmt|;
name|out_dir
operator|=
name|af_direction_compute
argument_list|(
name|out_x
argument_list|,
name|out_y
argument_list|)
expr_stmt|;
comment|/* adjust directions for all points inbetween; */
comment|/* the loop also updates position of `curr'    */
name|curr
operator|->
name|out_dir
operator|=
operator|(
name|FT_Char
operator|)
name|out_dir
expr_stmt|;
for|for
control|(
name|curr
operator|=
name|curr
operator|->
name|next
init|;
name|curr
operator|!=
name|next
condition|;
name|curr
operator|=
name|curr
operator|->
name|next
control|)
block|{
name|curr
operator|->
name|in_dir
operator|=
operator|(
name|FT_Char
operator|)
name|out_dir
expr_stmt|;
name|curr
operator|->
name|out_dir
operator|=
operator|(
name|FT_Char
operator|)
name|out_dir
expr_stmt|;
block|}
name|next
operator|->
name|in_dir
operator|=
operator|(
name|FT_Char
operator|)
name|out_dir
expr_stmt|;
name|curr
operator|->
name|u
operator|=
call|(
name|FT_Pos
call|)
argument_list|(
name|first
operator|-
name|curr
argument_list|)
expr_stmt|;
name|first
operator|->
name|v
operator|=
operator|-
name|curr
operator|->
name|u
expr_stmt|;
name|out_x
operator|=
literal|0
expr_stmt|;
name|out_y
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/*          *  The next step is to `simplify' an outline's topology so that we          *  can identify local extrema more reliably: A series of          *  non-horizontal or non-vertical vectors pointing into the same          *  quadrant are handled as a single, long vector.  From a          *  topological point of the view, the intermediate points are of no          *  interest and thus tagged as weak.          */
for|for
control|(
name|point
operator|=
name|points
init|;
name|point
operator|<
name|point_limit
condition|;
name|point
operator|++
control|)
block|{
if|if
condition|(
name|point
operator|->
name|flags
operator|&
name|AF_FLAG_WEAK_INTERPOLATION
condition|)
continue|continue;
if|if
condition|(
name|point
operator|->
name|in_dir
operator|==
name|AF_DIR_NONE
operator|&&
name|point
operator|->
name|out_dir
operator|==
name|AF_DIR_NONE
condition|)
block|{
comment|/* check whether both vectors point into the same quadrant */
name|FT_Pos
name|in_x
decl_stmt|,
name|in_y
decl_stmt|;
name|FT_Pos
name|out_x
decl_stmt|,
name|out_y
decl_stmt|;
name|AF_Point
name|next_u
init|=
name|point
operator|+
name|point
operator|->
name|u
decl_stmt|;
name|AF_Point
name|prev_v
init|=
name|point
operator|+
name|point
operator|->
name|v
decl_stmt|;
name|in_x
operator|=
name|point
operator|->
name|fx
operator|-
name|prev_v
operator|->
name|fx
expr_stmt|;
name|in_y
operator|=
name|point
operator|->
name|fy
operator|-
name|prev_v
operator|->
name|fy
expr_stmt|;
name|out_x
operator|=
name|next_u
operator|->
name|fx
operator|-
name|point
operator|->
name|fx
expr_stmt|;
name|out_y
operator|=
name|next_u
operator|->
name|fy
operator|-
name|point
operator|->
name|fy
expr_stmt|;
if|if
condition|(
operator|(
name|in_x
operator|^
name|out_x
operator|)
operator|>=
literal|0
operator|&&
operator|(
name|in_y
operator|^
name|out_y
operator|)
operator|>=
literal|0
condition|)
block|{
comment|/* yes, so tag current point as weak */
comment|/* and update index deltas           */
name|point
operator|->
name|flags
operator||=
name|AF_FLAG_WEAK_INTERPOLATION
expr_stmt|;
name|prev_v
operator|->
name|u
operator|=
call|(
name|FT_Pos
call|)
argument_list|(
name|next_u
operator|-
name|prev_v
argument_list|)
expr_stmt|;
name|next_u
operator|->
name|v
operator|=
operator|-
name|prev_v
operator|->
name|u
expr_stmt|;
block|}
block|}
block|}
comment|/*          *  Finally, check for remaining weak points.  Everything else not          *  collected in edges so far is then implicitly classified as strong          *  points.          */
for|for
control|(
name|point
operator|=
name|points
init|;
name|point
operator|<
name|point_limit
condition|;
name|point
operator|++
control|)
block|{
if|if
condition|(
name|point
operator|->
name|flags
operator|&
name|AF_FLAG_WEAK_INTERPOLATION
condition|)
continue|continue;
if|if
condition|(
name|point
operator|->
name|flags
operator|&
name|AF_FLAG_CONTROL
condition|)
block|{
comment|/* control points are always weak */
name|Is_Weak_Point
label|:
name|point
operator|->
name|flags
operator||=
name|AF_FLAG_WEAK_INTERPOLATION
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|point
operator|->
name|out_dir
operator|==
name|point
operator|->
name|in_dir
condition|)
block|{
if|if
condition|(
name|point
operator|->
name|out_dir
operator|!=
name|AF_DIR_NONE
condition|)
block|{
comment|/* current point lies on a horizontal or          */
comment|/* vertical segment (but doesn't start or end it) */
goto|goto
name|Is_Weak_Point
goto|;
block|}
block|{
name|AF_Point
name|next_u
init|=
name|point
operator|+
name|point
operator|->
name|u
decl_stmt|;
name|AF_Point
name|prev_v
init|=
name|point
operator|+
name|point
operator|->
name|v
decl_stmt|;
if|if
condition|(
name|ft_corner_is_flat
argument_list|(
name|point
operator|->
name|fx
operator|-
name|prev_v
operator|->
name|fx
argument_list|,
name|point
operator|->
name|fy
operator|-
name|prev_v
operator|->
name|fy
argument_list|,
name|next_u
operator|->
name|fx
operator|-
name|point
operator|->
name|fx
argument_list|,
name|next_u
operator|->
name|fy
operator|-
name|point
operator|->
name|fy
argument_list|)
condition|)
block|{
comment|/* either the `in' or the `out' vector is much more  */
comment|/* dominant than the other one, so tag current point */
comment|/* as weak and update index deltas                   */
name|prev_v
operator|->
name|u
operator|=
call|(
name|FT_Pos
call|)
argument_list|(
name|next_u
operator|-
name|prev_v
argument_list|)
expr_stmt|;
name|next_u
operator|->
name|v
operator|=
operator|-
name|prev_v
operator|->
name|u
expr_stmt|;
goto|goto
name|Is_Weak_Point
goto|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|point
operator|->
name|in_dir
operator|==
operator|-
name|point
operator|->
name|out_dir
condition|)
block|{
comment|/* current point forms a spike */
goto|goto
name|Is_Weak_Point
goto|;
block|}
block|}
block|}
block|}
name|Exit
label|:
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/* Store the hinted outline in an FT_Outline structure. */
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|af_glyph_hints_save
name|af_glyph_hints_save
argument_list|(
argument|AF_GlyphHints  hints
argument_list|,
argument|FT_Outline*    outline
argument_list|)
end_macro
begin_block
block|{
name|AF_Point
name|point
init|=
name|hints
operator|->
name|points
decl_stmt|;
name|AF_Point
name|limit
init|=
name|point
operator|+
name|hints
operator|->
name|num_points
decl_stmt|;
name|FT_Vector
modifier|*
name|vec
init|=
name|outline
operator|->
name|points
decl_stmt|;
name|char
modifier|*
name|tag
init|=
name|outline
operator|->
name|tags
decl_stmt|;
for|for
control|(
init|;
name|point
operator|<
name|limit
condition|;
name|point
operator|++
operator|,
name|vec
operator|++
operator|,
name|tag
operator|++
control|)
block|{
name|vec
operator|->
name|x
operator|=
name|point
operator|->
name|x
expr_stmt|;
name|vec
operator|->
name|y
operator|=
name|point
operator|->
name|y
expr_stmt|;
if|if
condition|(
name|point
operator|->
name|flags
operator|&
name|AF_FLAG_CONIC
condition|)
name|tag
index|[
literal|0
index|]
operator|=
name|FT_CURVE_TAG_CONIC
expr_stmt|;
elseif|else
if|if
condition|(
name|point
operator|->
name|flags
operator|&
name|AF_FLAG_CUBIC
condition|)
name|tag
index|[
literal|0
index|]
operator|=
name|FT_CURVE_TAG_CUBIC
expr_stmt|;
else|else
name|tag
index|[
literal|0
index|]
operator|=
name|FT_CURVE_TAG_ON
expr_stmt|;
block|}
block|}
end_block
begin_comment
comment|/****************************************************************    *    *                     EDGE POINT GRID-FITTING    *    ****************************************************************/
end_comment
begin_comment
comment|/* Align all points of an edge to the same coordinate value, */
end_comment
begin_comment
comment|/* either horizontally or vertically.                        */
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|af_glyph_hints_align_edge_points
name|af_glyph_hints_align_edge_points
argument_list|(
argument|AF_GlyphHints  hints
argument_list|,
argument|AF_Dimension   dim
argument_list|)
end_macro
begin_block
block|{
name|AF_AxisHints
name|axis
init|=
operator|&
name|hints
operator|->
name|axis
index|[
name|dim
index|]
decl_stmt|;
name|AF_Segment
name|segments
init|=
name|axis
operator|->
name|segments
decl_stmt|;
name|AF_Segment
name|segment_limit
init|=
name|segments
operator|+
name|axis
operator|->
name|num_segments
decl_stmt|;
name|AF_Segment
name|seg
decl_stmt|;
if|if
condition|(
name|dim
operator|==
name|AF_DIMENSION_HORZ
condition|)
block|{
for|for
control|(
name|seg
operator|=
name|segments
init|;
name|seg
operator|<
name|segment_limit
condition|;
name|seg
operator|++
control|)
block|{
name|AF_Edge
name|edge
init|=
name|seg
operator|->
name|edge
decl_stmt|;
name|AF_Point
name|point
decl_stmt|,
name|first
decl_stmt|,
name|last
decl_stmt|;
if|if
condition|(
name|edge
operator|==
name|NULL
condition|)
continue|continue;
name|first
operator|=
name|seg
operator|->
name|first
expr_stmt|;
name|last
operator|=
name|seg
operator|->
name|last
expr_stmt|;
name|point
operator|=
name|first
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|point
operator|->
name|x
operator|=
name|edge
operator|->
name|pos
expr_stmt|;
name|point
operator|->
name|flags
operator||=
name|AF_FLAG_TOUCH_X
expr_stmt|;
if|if
condition|(
name|point
operator|==
name|last
condition|)
break|break;
name|point
operator|=
name|point
operator|->
name|next
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|seg
operator|=
name|segments
init|;
name|seg
operator|<
name|segment_limit
condition|;
name|seg
operator|++
control|)
block|{
name|AF_Edge
name|edge
init|=
name|seg
operator|->
name|edge
decl_stmt|;
name|AF_Point
name|point
decl_stmt|,
name|first
decl_stmt|,
name|last
decl_stmt|;
if|if
condition|(
name|edge
operator|==
name|NULL
condition|)
continue|continue;
name|first
operator|=
name|seg
operator|->
name|first
expr_stmt|;
name|last
operator|=
name|seg
operator|->
name|last
expr_stmt|;
name|point
operator|=
name|first
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|point
operator|->
name|y
operator|=
name|edge
operator|->
name|pos
expr_stmt|;
name|point
operator|->
name|flags
operator||=
name|AF_FLAG_TOUCH_Y
expr_stmt|;
if|if
condition|(
name|point
operator|==
name|last
condition|)
break|break;
name|point
operator|=
name|point
operator|->
name|next
expr_stmt|;
block|}
block|}
block|}
block|}
end_block
begin_comment
comment|/****************************************************************    *    *                    STRONG POINT INTERPOLATION    *    ****************************************************************/
end_comment
begin_comment
comment|/* Hint the strong points -- this is equivalent to the TrueType `IP' */
end_comment
begin_comment
comment|/* hinting instruction.                                              */
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|af_glyph_hints_align_strong_points
name|af_glyph_hints_align_strong_points
argument_list|(
argument|AF_GlyphHints  hints
argument_list|,
argument|AF_Dimension   dim
argument_list|)
end_macro
begin_block
block|{
name|AF_Point
name|points
init|=
name|hints
operator|->
name|points
decl_stmt|;
name|AF_Point
name|point_limit
init|=
name|points
operator|+
name|hints
operator|->
name|num_points
decl_stmt|;
name|AF_AxisHints
name|axis
init|=
operator|&
name|hints
operator|->
name|axis
index|[
name|dim
index|]
decl_stmt|;
name|AF_Edge
name|edges
init|=
name|axis
operator|->
name|edges
decl_stmt|;
name|AF_Edge
name|edge_limit
init|=
name|edges
operator|+
name|axis
operator|->
name|num_edges
decl_stmt|;
name|AF_Flags
name|touch_flag
decl_stmt|;
if|if
condition|(
name|dim
operator|==
name|AF_DIMENSION_HORZ
condition|)
name|touch_flag
operator|=
name|AF_FLAG_TOUCH_X
expr_stmt|;
else|else
name|touch_flag
operator|=
name|AF_FLAG_TOUCH_Y
expr_stmt|;
if|if
condition|(
name|edges
operator|<
name|edge_limit
condition|)
block|{
name|AF_Point
name|point
decl_stmt|;
name|AF_Edge
name|edge
decl_stmt|;
for|for
control|(
name|point
operator|=
name|points
init|;
name|point
operator|<
name|point_limit
condition|;
name|point
operator|++
control|)
block|{
name|FT_Pos
name|u
decl_stmt|,
name|ou
decl_stmt|,
name|fu
decl_stmt|;
comment|/* point position */
name|FT_Pos
name|delta
decl_stmt|;
if|if
condition|(
name|point
operator|->
name|flags
operator|&
name|touch_flag
condition|)
continue|continue;
comment|/* if this point is candidate to weak interpolation, we       */
comment|/* interpolate it after all strong points have been processed */
if|if
condition|(
operator|(
name|point
operator|->
name|flags
operator|&
name|AF_FLAG_WEAK_INTERPOLATION
operator|)
condition|)
continue|continue;
if|if
condition|(
name|dim
operator|==
name|AF_DIMENSION_VERT
condition|)
block|{
name|u
operator|=
name|point
operator|->
name|fy
expr_stmt|;
name|ou
operator|=
name|point
operator|->
name|oy
expr_stmt|;
block|}
else|else
block|{
name|u
operator|=
name|point
operator|->
name|fx
expr_stmt|;
name|ou
operator|=
name|point
operator|->
name|ox
expr_stmt|;
block|}
name|fu
operator|=
name|u
expr_stmt|;
comment|/* is the point before the first edge? */
name|edge
operator|=
name|edges
expr_stmt|;
name|delta
operator|=
name|edge
operator|->
name|fpos
operator|-
name|u
expr_stmt|;
if|if
condition|(
name|delta
operator|>=
literal|0
condition|)
block|{
name|u
operator|=
name|edge
operator|->
name|pos
operator|-
operator|(
name|edge
operator|->
name|opos
operator|-
name|ou
operator|)
expr_stmt|;
goto|goto
name|Store_Point
goto|;
block|}
comment|/* is the point after the last edge? */
name|edge
operator|=
name|edge_limit
operator|-
literal|1
expr_stmt|;
name|delta
operator|=
name|u
operator|-
name|edge
operator|->
name|fpos
expr_stmt|;
if|if
condition|(
name|delta
operator|>=
literal|0
condition|)
block|{
name|u
operator|=
name|edge
operator|->
name|pos
operator|+
operator|(
name|ou
operator|-
name|edge
operator|->
name|opos
operator|)
expr_stmt|;
goto|goto
name|Store_Point
goto|;
block|}
block|{
name|FT_PtrDist
name|min
decl_stmt|,
name|max
decl_stmt|,
name|mid
decl_stmt|;
name|FT_Pos
name|fpos
decl_stmt|;
comment|/* find enclosing edges */
name|min
operator|=
literal|0
expr_stmt|;
name|max
operator|=
name|edge_limit
operator|-
name|edges
expr_stmt|;
if|#
directive|if
literal|1
comment|/* for a small number of edges, a linear search is better */
if|if
condition|(
name|max
operator|<=
literal|8
condition|)
block|{
name|FT_PtrDist
name|nn
decl_stmt|;
for|for
control|(
name|nn
operator|=
literal|0
init|;
name|nn
operator|<
name|max
condition|;
name|nn
operator|++
control|)
if|if
condition|(
name|edges
index|[
name|nn
index|]
operator|.
name|fpos
operator|>=
name|u
condition|)
break|break;
if|if
condition|(
name|edges
index|[
name|nn
index|]
operator|.
name|fpos
operator|==
name|u
condition|)
block|{
name|u
operator|=
name|edges
index|[
name|nn
index|]
operator|.
name|pos
expr_stmt|;
goto|goto
name|Store_Point
goto|;
block|}
name|min
operator|=
name|nn
expr_stmt|;
block|}
else|else
endif|#
directive|endif
while|while
condition|(
name|min
operator|<
name|max
condition|)
block|{
name|mid
operator|=
operator|(
name|max
operator|+
name|min
operator|)
operator|>>
literal|1
expr_stmt|;
name|edge
operator|=
name|edges
operator|+
name|mid
expr_stmt|;
name|fpos
operator|=
name|edge
operator|->
name|fpos
expr_stmt|;
if|if
condition|(
name|u
operator|<
name|fpos
condition|)
name|max
operator|=
name|mid
expr_stmt|;
elseif|else
if|if
condition|(
name|u
operator|>
name|fpos
condition|)
name|min
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
else|else
block|{
comment|/* we are on the edge */
name|u
operator|=
name|edge
operator|->
name|pos
expr_stmt|;
goto|goto
name|Store_Point
goto|;
block|}
block|}
comment|/* point is not on an edge */
block|{
name|AF_Edge
name|before
init|=
name|edges
operator|+
name|min
operator|-
literal|1
decl_stmt|;
name|AF_Edge
name|after
init|=
name|edges
operator|+
name|min
operator|+
literal|0
decl_stmt|;
comment|/* assert( before&& after&& before != after ) */
if|if
condition|(
name|before
operator|->
name|scale
operator|==
literal|0
condition|)
name|before
operator|->
name|scale
operator|=
name|FT_DivFix
argument_list|(
name|after
operator|->
name|pos
operator|-
name|before
operator|->
name|pos
argument_list|,
name|after
operator|->
name|fpos
operator|-
name|before
operator|->
name|fpos
argument_list|)
expr_stmt|;
name|u
operator|=
name|before
operator|->
name|pos
operator|+
name|FT_MulFix
argument_list|(
name|fu
operator|-
name|before
operator|->
name|fpos
argument_list|,
name|before
operator|->
name|scale
argument_list|)
expr_stmt|;
block|}
block|}
name|Store_Point
label|:
comment|/* save the point position */
if|if
condition|(
name|dim
operator|==
name|AF_DIMENSION_HORZ
condition|)
name|point
operator|->
name|x
operator|=
name|u
expr_stmt|;
else|else
name|point
operator|->
name|y
operator|=
name|u
expr_stmt|;
name|point
operator|->
name|flags
operator||=
name|touch_flag
expr_stmt|;
block|}
block|}
block|}
end_block
begin_comment
comment|/****************************************************************    *    *                    WEAK POINT INTERPOLATION    *    ****************************************************************/
end_comment
begin_comment
comment|/* Shift the original coordinates of all points between `p1' and */
end_comment
begin_comment
comment|/* `p2' to get hinted coordinates, using the same difference as  */
end_comment
begin_comment
comment|/* given by `ref'.                                               */
end_comment
begin_function
specifier|static
name|void
DECL|function|af_iup_shift
name|af_iup_shift
parameter_list|(
name|AF_Point
name|p1
parameter_list|,
name|AF_Point
name|p2
parameter_list|,
name|AF_Point
name|ref
parameter_list|)
block|{
name|AF_Point
name|p
decl_stmt|;
name|FT_Pos
name|delta
init|=
name|ref
operator|->
name|u
operator|-
name|ref
operator|->
name|v
decl_stmt|;
if|if
condition|(
name|delta
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|p
operator|=
name|p1
init|;
name|p
operator|<
name|ref
condition|;
name|p
operator|++
control|)
name|p
operator|->
name|u
operator|=
name|p
operator|->
name|v
operator|+
name|delta
expr_stmt|;
for|for
control|(
name|p
operator|=
name|ref
operator|+
literal|1
init|;
name|p
operator|<=
name|p2
condition|;
name|p
operator|++
control|)
name|p
operator|->
name|u
operator|=
name|p
operator|->
name|v
operator|+
name|delta
expr_stmt|;
block|}
end_function
begin_comment
comment|/* Interpolate the original coordinates of all points between `p1' and  */
end_comment
begin_comment
comment|/* `p2' to get hinted coordinates, using `ref1' and `ref2' as the       */
end_comment
begin_comment
comment|/* reference points.  The `u' and `v' members are the current and       */
end_comment
begin_comment
comment|/* original coordinate values, respectively.                            */
end_comment
begin_comment
comment|/*                                                                      */
end_comment
begin_comment
comment|/* Details can be found in the TrueType bytecode specification.         */
end_comment
begin_function
specifier|static
name|void
DECL|function|af_iup_interp
name|af_iup_interp
parameter_list|(
name|AF_Point
name|p1
parameter_list|,
name|AF_Point
name|p2
parameter_list|,
name|AF_Point
name|ref1
parameter_list|,
name|AF_Point
name|ref2
parameter_list|)
block|{
name|AF_Point
name|p
decl_stmt|;
name|FT_Pos
name|u
decl_stmt|;
name|FT_Pos
name|v1
init|=
name|ref1
operator|->
name|v
decl_stmt|;
name|FT_Pos
name|v2
init|=
name|ref2
operator|->
name|v
decl_stmt|;
name|FT_Pos
name|d1
init|=
name|ref1
operator|->
name|u
operator|-
name|v1
decl_stmt|;
name|FT_Pos
name|d2
init|=
name|ref2
operator|->
name|u
operator|-
name|v2
decl_stmt|;
if|if
condition|(
name|p1
operator|>
name|p2
condition|)
return|return;
if|if
condition|(
name|v1
operator|==
name|v2
condition|)
block|{
for|for
control|(
name|p
operator|=
name|p1
init|;
name|p
operator|<=
name|p2
condition|;
name|p
operator|++
control|)
block|{
name|u
operator|=
name|p
operator|->
name|v
expr_stmt|;
if|if
condition|(
name|u
operator|<=
name|v1
condition|)
name|u
operator|+=
name|d1
expr_stmt|;
else|else
name|u
operator|+=
name|d2
expr_stmt|;
name|p
operator|->
name|u
operator|=
name|u
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|v1
operator|<
name|v2
condition|)
block|{
for|for
control|(
name|p
operator|=
name|p1
init|;
name|p
operator|<=
name|p2
condition|;
name|p
operator|++
control|)
block|{
name|u
operator|=
name|p
operator|->
name|v
expr_stmt|;
if|if
condition|(
name|u
operator|<=
name|v1
condition|)
name|u
operator|+=
name|d1
expr_stmt|;
elseif|else
if|if
condition|(
name|u
operator|>=
name|v2
condition|)
name|u
operator|+=
name|d2
expr_stmt|;
else|else
name|u
operator|=
name|ref1
operator|->
name|u
operator|+
name|FT_MulDiv
argument_list|(
name|u
operator|-
name|v1
argument_list|,
name|ref2
operator|->
name|u
operator|-
name|ref1
operator|->
name|u
argument_list|,
name|v2
operator|-
name|v1
argument_list|)
expr_stmt|;
name|p
operator|->
name|u
operator|=
name|u
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|p
operator|=
name|p1
init|;
name|p
operator|<=
name|p2
condition|;
name|p
operator|++
control|)
block|{
name|u
operator|=
name|p
operator|->
name|v
expr_stmt|;
if|if
condition|(
name|u
operator|<=
name|v2
condition|)
name|u
operator|+=
name|d2
expr_stmt|;
elseif|else
if|if
condition|(
name|u
operator|>=
name|v1
condition|)
name|u
operator|+=
name|d1
expr_stmt|;
else|else
name|u
operator|=
name|ref1
operator|->
name|u
operator|+
name|FT_MulDiv
argument_list|(
name|u
operator|-
name|v1
argument_list|,
name|ref2
operator|->
name|u
operator|-
name|ref1
operator|->
name|u
argument_list|,
name|v2
operator|-
name|v1
argument_list|)
expr_stmt|;
name|p
operator|->
name|u
operator|=
name|u
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/* Hint the weak points -- this is equivalent to the TrueType `IUP' */
end_comment
begin_comment
comment|/* hinting instruction.                                             */
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|af_glyph_hints_align_weak_points
name|af_glyph_hints_align_weak_points
argument_list|(
argument|AF_GlyphHints  hints
argument_list|,
argument|AF_Dimension   dim
argument_list|)
end_macro
begin_block
block|{
name|AF_Point
name|points
init|=
name|hints
operator|->
name|points
decl_stmt|;
name|AF_Point
name|point_limit
init|=
name|points
operator|+
name|hints
operator|->
name|num_points
decl_stmt|;
name|AF_Point
modifier|*
name|contour
init|=
name|hints
operator|->
name|contours
decl_stmt|;
name|AF_Point
modifier|*
name|contour_limit
init|=
name|contour
operator|+
name|hints
operator|->
name|num_contours
decl_stmt|;
name|AF_Flags
name|touch_flag
decl_stmt|;
name|AF_Point
name|point
decl_stmt|;
name|AF_Point
name|end_point
decl_stmt|;
name|AF_Point
name|first_point
decl_stmt|;
comment|/* PASS 1: Move segment points to edge positions */
if|if
condition|(
name|dim
operator|==
name|AF_DIMENSION_HORZ
condition|)
block|{
name|touch_flag
operator|=
name|AF_FLAG_TOUCH_X
expr_stmt|;
for|for
control|(
name|point
operator|=
name|points
init|;
name|point
operator|<
name|point_limit
condition|;
name|point
operator|++
control|)
block|{
name|point
operator|->
name|u
operator|=
name|point
operator|->
name|x
expr_stmt|;
name|point
operator|->
name|v
operator|=
name|point
operator|->
name|ox
expr_stmt|;
block|}
block|}
else|else
block|{
name|touch_flag
operator|=
name|AF_FLAG_TOUCH_Y
expr_stmt|;
for|for
control|(
name|point
operator|=
name|points
init|;
name|point
operator|<
name|point_limit
condition|;
name|point
operator|++
control|)
block|{
name|point
operator|->
name|u
operator|=
name|point
operator|->
name|y
expr_stmt|;
name|point
operator|->
name|v
operator|=
name|point
operator|->
name|oy
expr_stmt|;
block|}
block|}
for|for
control|(
init|;
name|contour
operator|<
name|contour_limit
condition|;
name|contour
operator|++
control|)
block|{
name|AF_Point
name|first_touched
decl_stmt|,
name|last_touched
decl_stmt|;
name|point
operator|=
operator|*
name|contour
expr_stmt|;
name|end_point
operator|=
name|point
operator|->
name|prev
expr_stmt|;
name|first_point
operator|=
name|point
expr_stmt|;
comment|/* find first touched point */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|point
operator|>
name|end_point
condition|)
comment|/* no touched point in contour */
goto|goto
name|NextContour
goto|;
if|if
condition|(
name|point
operator|->
name|flags
operator|&
name|touch_flag
condition|)
break|break;
name|point
operator|++
expr_stmt|;
block|}
name|first_touched
operator|=
name|point
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|FT_ASSERT
argument_list|(
name|point
operator|<=
name|end_point
operator|&&
operator|(
name|point
operator|->
name|flags
operator|&
name|touch_flag
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/* skip any touched neighbours */
while|while
condition|(
name|point
operator|<
name|end_point
operator|&&
operator|(
name|point
index|[
literal|1
index|]
operator|.
name|flags
operator|&
name|touch_flag
operator|)
operator|!=
literal|0
condition|)
name|point
operator|++
expr_stmt|;
name|last_touched
operator|=
name|point
expr_stmt|;
comment|/* find the next touched point, if any */
name|point
operator|++
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|point
operator|>
name|end_point
condition|)
goto|goto
name|EndContour
goto|;
if|if
condition|(
operator|(
name|point
operator|->
name|flags
operator|&
name|touch_flag
operator|)
operator|!=
literal|0
condition|)
break|break;
name|point
operator|++
expr_stmt|;
block|}
comment|/* interpolate between last_touched and point */
name|af_iup_interp
argument_list|(
name|last_touched
operator|+
literal|1
argument_list|,
name|point
operator|-
literal|1
argument_list|,
name|last_touched
argument_list|,
name|point
argument_list|)
expr_stmt|;
block|}
name|EndContour
label|:
comment|/* special case: only one point was touched */
if|if
condition|(
name|last_touched
operator|==
name|first_touched
condition|)
name|af_iup_shift
argument_list|(
name|first_point
argument_list|,
name|end_point
argument_list|,
name|first_touched
argument_list|)
expr_stmt|;
else|else
comment|/* interpolate the last part */
block|{
if|if
condition|(
name|last_touched
operator|<
name|end_point
condition|)
name|af_iup_interp
argument_list|(
name|last_touched
operator|+
literal|1
argument_list|,
name|end_point
argument_list|,
name|last_touched
argument_list|,
name|first_touched
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_touched
operator|>
name|points
condition|)
name|af_iup_interp
argument_list|(
name|first_point
argument_list|,
name|first_touched
operator|-
literal|1
argument_list|,
name|last_touched
argument_list|,
name|first_touched
argument_list|)
expr_stmt|;
block|}
name|NextContour
label|:
empty_stmt|;
block|}
comment|/* now save the interpolated values back to x/y */
if|if
condition|(
name|dim
operator|==
name|AF_DIMENSION_HORZ
condition|)
block|{
for|for
control|(
name|point
operator|=
name|points
init|;
name|point
operator|<
name|point_limit
condition|;
name|point
operator|++
control|)
name|point
operator|->
name|x
operator|=
name|point
operator|->
name|u
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|point
operator|=
name|points
init|;
name|point
operator|<
name|point_limit
condition|;
name|point
operator|++
control|)
name|point
operator|->
name|y
operator|=
name|point
operator|->
name|u
expr_stmt|;
block|}
block|}
end_block
begin_ifdef
ifdef|#
directive|ifdef
name|AF_CONFIG_OPTION_USE_WARPER
end_ifdef
begin_comment
comment|/* Apply (small) warp scale and warp delta for given dimension. */
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|af_glyph_hints_scale_dim
name|af_glyph_hints_scale_dim
argument_list|(
argument|AF_GlyphHints  hints
argument_list|,
argument|AF_Dimension   dim
argument_list|,
argument|FT_Fixed       scale
argument_list|,
argument|FT_Pos         delta
argument_list|)
end_macro
begin_block
block|{
name|AF_Point
name|points
init|=
name|hints
operator|->
name|points
decl_stmt|;
name|AF_Point
name|points_limit
init|=
name|points
operator|+
name|hints
operator|->
name|num_points
decl_stmt|;
name|AF_Point
name|point
decl_stmt|;
if|if
condition|(
name|dim
operator|==
name|AF_DIMENSION_HORZ
condition|)
block|{
for|for
control|(
name|point
operator|=
name|points
init|;
name|point
operator|<
name|points_limit
condition|;
name|point
operator|++
control|)
name|point
operator|->
name|x
operator|=
name|FT_MulFix
argument_list|(
name|point
operator|->
name|fx
argument_list|,
name|scale
argument_list|)
operator|+
name|delta
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|point
operator|=
name|points
init|;
name|point
operator|<
name|points_limit
condition|;
name|point
operator|++
control|)
name|point
operator|->
name|y
operator|=
name|FT_MulFix
argument_list|(
name|point
operator|->
name|fy
argument_list|,
name|scale
argument_list|)
operator|+
name|delta
expr_stmt|;
block|}
block|}
end_block
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* AF_CONFIG_OPTION_USE_WARPER */
end_comment
begin_comment
comment|/* END */
end_comment
end_unit
