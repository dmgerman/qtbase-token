begin_unit
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  afhints.c                                                              */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*    Auto-fitter hinting routines (body).                                 */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  Copyright 2003, 2004, 2005, 2006, 2007, 2009 by                        */
end_comment
begin_comment
comment|/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  This file is part of the FreeType project, and may only be used,       */
end_comment
begin_comment
comment|/*  modified, and distributed under the terms of the FreeType project      */
end_comment
begin_comment
comment|/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
end_comment
begin_comment
comment|/*  this file you indicate that you have read the license and              */
end_comment
begin_comment
comment|/*  understand and accept it fully.                                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"afhints.h"
end_include
begin_include
include|#
directive|include
file|"aferrors.h"
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_CALC_H
end_include
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|af_axis_hints_new_segment
argument_list|(
argument|AF_AxisHints  axis
argument_list|,
argument|FT_Memory     memory
argument_list|,
argument|AF_Segment   *asegment
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
init|=
name|AF_Err_Ok
decl_stmt|;
name|AF_Segment
name|segment
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|axis
operator|->
name|num_segments
operator|>=
name|axis
operator|->
name|max_segments
condition|)
block|{
name|FT_Int
name|old_max
init|=
name|axis
operator|->
name|max_segments
decl_stmt|;
name|FT_Int
name|new_max
init|=
name|old_max
decl_stmt|;
name|FT_Int
name|big_max
init|=
call|(
name|FT_Int
call|)
argument_list|(
name|FT_INT_MAX
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|segment
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|old_max
operator|>=
name|big_max
condition|)
block|{
name|error
operator|=
name|AF_Err_Out_Of_Memory
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|new_max
operator|+=
operator|(
name|new_max
operator|>>
literal|2
operator|)
operator|+
literal|4
expr_stmt|;
if|if
condition|(
name|new_max
operator|<
name|old_max
operator|||
name|new_max
operator|>
name|big_max
condition|)
name|new_max
operator|=
name|big_max
expr_stmt|;
if|if
condition|(
name|FT_RENEW_ARRAY
argument_list|(
name|axis
operator|->
name|segments
argument_list|,
name|old_max
argument_list|,
name|new_max
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|axis
operator|->
name|max_segments
operator|=
name|new_max
expr_stmt|;
block|}
name|segment
operator|=
name|axis
operator|->
name|segments
operator|+
name|axis
operator|->
name|num_segments
operator|++
expr_stmt|;
name|Exit
label|:
operator|*
name|asegment
operator|=
name|segment
expr_stmt|;
return|return
name|error
return|;
block|}
end_block
begin_macro
DECL|function|FT_LOCAL
name|FT_LOCAL
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|af_axis_hints_new_edge
argument_list|(
argument|AF_AxisHints  axis
argument_list|,
argument|FT_Int        fpos
argument_list|,
argument|AF_Direction  dir
argument_list|,
argument|FT_Memory     memory
argument_list|,
argument|AF_Edge      *aedge
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
init|=
name|AF_Err_Ok
decl_stmt|;
name|AF_Edge
name|edge
init|=
name|NULL
decl_stmt|;
name|AF_Edge
name|edges
decl_stmt|;
if|if
condition|(
name|axis
operator|->
name|num_edges
operator|>=
name|axis
operator|->
name|max_edges
condition|)
block|{
name|FT_Int
name|old_max
init|=
name|axis
operator|->
name|max_edges
decl_stmt|;
name|FT_Int
name|new_max
init|=
name|old_max
decl_stmt|;
name|FT_Int
name|big_max
init|=
call|(
name|FT_Int
call|)
argument_list|(
name|FT_INT_MAX
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|edge
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|old_max
operator|>=
name|big_max
condition|)
block|{
name|error
operator|=
name|AF_Err_Out_Of_Memory
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|new_max
operator|+=
operator|(
name|new_max
operator|>>
literal|2
operator|)
operator|+
literal|4
expr_stmt|;
if|if
condition|(
name|new_max
operator|<
name|old_max
operator|||
name|new_max
operator|>
name|big_max
condition|)
name|new_max
operator|=
name|big_max
expr_stmt|;
if|if
condition|(
name|FT_RENEW_ARRAY
argument_list|(
name|axis
operator|->
name|edges
argument_list|,
name|old_max
argument_list|,
name|new_max
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|axis
operator|->
name|max_edges
operator|=
name|new_max
expr_stmt|;
block|}
name|edges
operator|=
name|axis
operator|->
name|edges
expr_stmt|;
name|edge
operator|=
name|edges
operator|+
name|axis
operator|->
name|num_edges
expr_stmt|;
while|while
condition|(
name|edge
operator|>
name|edges
condition|)
block|{
if|if
condition|(
name|edge
index|[
operator|-
literal|1
index|]
operator|.
name|fpos
operator|<
name|fpos
condition|)
break|break;
comment|/* we want the edge with same position and minor direction */
comment|/* to appear before those in the major one in the list     */
if|if
condition|(
name|edge
index|[
operator|-
literal|1
index|]
operator|.
name|fpos
operator|==
name|fpos
operator|&&
name|dir
operator|==
name|axis
operator|->
name|major_dir
condition|)
break|break;
name|edge
index|[
literal|0
index|]
operator|=
name|edge
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|edge
operator|--
expr_stmt|;
block|}
name|axis
operator|->
name|num_edges
operator|++
expr_stmt|;
name|FT_ZERO
argument_list|(
name|edge
argument_list|)
expr_stmt|;
name|edge
operator|->
name|fpos
operator|=
operator|(
name|FT_Short
operator|)
name|fpos
expr_stmt|;
name|edge
operator|->
name|dir
operator|=
operator|(
name|FT_Char
operator|)
name|dir
expr_stmt|;
name|Exit
label|:
operator|*
name|aedge
operator|=
name|edge
expr_stmt|;
return|return
name|error
return|;
block|}
end_block
begin_ifdef
ifdef|#
directive|ifdef
name|AF_DEBUG
end_ifdef
begin_include
include|#
directive|include
include|FT_CONFIG_STANDARD_LIBRARY_H
end_include
begin_function
specifier|static
specifier|const
name|char
modifier|*
DECL|function|af_dir_str
name|af_dir_str
parameter_list|(
name|AF_Direction
name|dir
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|result
decl_stmt|;
switch|switch
condition|(
name|dir
condition|)
block|{
case|case
name|AF_DIR_UP
case|:
name|result
operator|=
literal|"up"
expr_stmt|;
break|break;
case|case
name|AF_DIR_DOWN
case|:
name|result
operator|=
literal|"down"
expr_stmt|;
break|break;
case|case
name|AF_DIR_LEFT
case|:
name|result
operator|=
literal|"left"
expr_stmt|;
break|break;
case|case
name|AF_DIR_RIGHT
case|:
name|result
operator|=
literal|"right"
expr_stmt|;
break|break;
default|default:
name|result
operator|=
literal|"none"
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function
begin_define
DECL|macro|AF_INDEX_NUM
define|#
directive|define
name|AF_INDEX_NUM
parameter_list|(
name|ptr
parameter_list|,
name|base
parameter_list|)
value|( (ptr) ? ( (ptr) - (base) ) : -1 )
end_define
begin_function
name|void
DECL|function|af_glyph_hints_dump_points
name|af_glyph_hints_dump_points
parameter_list|(
name|AF_GlyphHints
name|hints
parameter_list|)
block|{
name|AF_Point
name|points
init|=
name|hints
operator|->
name|points
decl_stmt|;
name|AF_Point
name|limit
init|=
name|points
operator|+
name|hints
operator|->
name|num_points
decl_stmt|;
name|AF_Point
name|point
decl_stmt|;
name|printf
argument_list|(
literal|"Table of points:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  [ index |  xorg |  yorg |  xscale |  yscale "
literal|"|  xfit  |  yfit  |  flags ]\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|point
operator|=
name|points
init|;
name|point
operator|<
name|limit
condition|;
name|point
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"  [ %5d | %5d | %5d | %-5.2f | %-5.2f "
literal|"| %-5.2f | %-5.2f | %c%c%c%c%c%c ]\n"
argument_list|,
name|point
operator|-
name|points
argument_list|,
name|point
operator|->
name|fx
argument_list|,
name|point
operator|->
name|fy
argument_list|,
name|point
operator|->
name|ox
operator|/
literal|64.0
argument_list|,
name|point
operator|->
name|oy
operator|/
literal|64.0
argument_list|,
name|point
operator|->
name|x
operator|/
literal|64.0
argument_list|,
name|point
operator|->
name|y
operator|/
literal|64.0
argument_list|,
operator|(
name|point
operator|->
name|flags
operator|&
name|AF_FLAG_WEAK_INTERPOLATION
operator|)
condition|?
literal|'w'
else|:
literal|' '
argument_list|,
operator|(
name|point
operator|->
name|flags
operator|&
name|AF_FLAG_INFLECTION
operator|)
condition|?
literal|'i'
else|:
literal|' '
argument_list|,
operator|(
name|point
operator|->
name|flags
operator|&
name|AF_FLAG_EXTREMA_X
operator|)
condition|?
literal|'<'
else|:
literal|' '
argument_list|,
operator|(
name|point
operator|->
name|flags
operator|&
name|AF_FLAG_EXTREMA_Y
operator|)
condition|?
literal|'v'
else|:
literal|' '
argument_list|,
operator|(
name|point
operator|->
name|flags
operator|&
name|AF_FLAG_ROUND_X
operator|)
condition|?
literal|'('
else|:
literal|' '
argument_list|,
operator|(
name|point
operator|->
name|flags
operator|&
name|AF_FLAG_ROUND_Y
operator|)
condition|?
literal|'u'
else|:
literal|' '
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
specifier|const
name|char
modifier|*
DECL|function|af_edge_flags_to_string
name|af_edge_flags_to_string
parameter_list|(
name|AF_Edge_Flags
name|flags
parameter_list|)
block|{
specifier|static
name|char
name|temp
index|[
literal|32
index|]
decl_stmt|;
name|int
name|pos
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|AF_EDGE_ROUND
condition|)
block|{
name|ft_memcpy
argument_list|(
name|temp
operator|+
name|pos
argument_list|,
literal|"round"
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|pos
operator|+=
literal|5
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|AF_EDGE_SERIF
condition|)
block|{
if|if
condition|(
name|pos
operator|>
literal|0
condition|)
name|temp
index|[
name|pos
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
name|ft_memcpy
argument_list|(
name|temp
operator|+
name|pos
argument_list|,
literal|"serif"
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|pos
operator|+=
literal|5
expr_stmt|;
block|}
if|if
condition|(
name|pos
operator|==
literal|0
condition|)
return|return
literal|"normal"
return|;
name|temp
index|[
name|pos
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|temp
return|;
block|}
end_function
begin_comment
comment|/* A function to dump the array of linked segments. */
end_comment
begin_function
name|void
DECL|function|af_glyph_hints_dump_segments
name|af_glyph_hints_dump_segments
parameter_list|(
name|AF_GlyphHints
name|hints
parameter_list|)
block|{
name|FT_Int
name|dimension
decl_stmt|;
for|for
control|(
name|dimension
operator|=
literal|1
init|;
name|dimension
operator|>=
literal|0
condition|;
name|dimension
operator|--
control|)
block|{
name|AF_AxisHints
name|axis
init|=
operator|&
name|hints
operator|->
name|axis
index|[
name|dimension
index|]
decl_stmt|;
name|AF_Segment
name|segments
init|=
name|axis
operator|->
name|segments
decl_stmt|;
name|AF_Segment
name|limit
init|=
name|segments
operator|+
name|axis
operator|->
name|num_segments
decl_stmt|;
name|AF_Segment
name|seg
decl_stmt|;
name|printf
argument_list|(
literal|"Table of %s segments:\n"
argument_list|,
name|dimension
operator|==
name|AF_DIMENSION_HORZ
condition|?
literal|"vertical"
else|:
literal|"horizontal"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  [ index |  pos  |  dir  | link | serif |"
literal|" height  | extra | flags    ]\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|seg
operator|=
name|segments
init|;
name|seg
operator|<
name|limit
condition|;
name|seg
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"  [ %5d | %5.2g | %5s | %4d | %5d | %5d | %5d | %s ]\n"
argument_list|,
name|seg
operator|-
name|segments
argument_list|,
name|dimension
operator|==
name|AF_DIMENSION_HORZ
condition|?
operator|(
name|int
operator|)
name|seg
operator|->
name|first
operator|->
name|ox
operator|/
literal|64.0
else|:
operator|(
name|int
operator|)
name|seg
operator|->
name|first
operator|->
name|oy
operator|/
literal|64.0
argument_list|,
name|af_dir_str
argument_list|(
operator|(
name|AF_Direction
operator|)
name|seg
operator|->
name|dir
argument_list|)
argument_list|,
name|AF_INDEX_NUM
argument_list|(
name|seg
operator|->
name|link
argument_list|,
name|segments
argument_list|)
argument_list|,
name|AF_INDEX_NUM
argument_list|(
name|seg
operator|->
name|serif
argument_list|,
name|segments
argument_list|)
argument_list|,
name|seg
operator|->
name|height
argument_list|,
name|seg
operator|->
name|height
operator|-
operator|(
name|seg
operator|->
name|max_coord
operator|-
name|seg
operator|->
name|min_coord
operator|)
argument_list|,
name|af_edge_flags_to_string
argument_list|(
name|seg
operator|->
name|flags
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
name|void
DECL|function|af_glyph_hints_dump_edges
name|af_glyph_hints_dump_edges
parameter_list|(
name|AF_GlyphHints
name|hints
parameter_list|)
block|{
name|FT_Int
name|dimension
decl_stmt|;
for|for
control|(
name|dimension
operator|=
literal|1
init|;
name|dimension
operator|>=
literal|0
condition|;
name|dimension
operator|--
control|)
block|{
name|AF_AxisHints
name|axis
init|=
operator|&
name|hints
operator|->
name|axis
index|[
name|dimension
index|]
decl_stmt|;
name|AF_Edge
name|edges
init|=
name|axis
operator|->
name|edges
decl_stmt|;
name|AF_Edge
name|limit
init|=
name|edges
operator|+
name|axis
operator|->
name|num_edges
decl_stmt|;
name|AF_Edge
name|edge
decl_stmt|;
comment|/*        *  note: AF_DIMENSION_HORZ corresponds to _vertical_ edges        *        since they have constant a X coordinate.        */
name|printf
argument_list|(
literal|"Table of %s edges:\n"
argument_list|,
name|dimension
operator|==
name|AF_DIMENSION_HORZ
condition|?
literal|"vertical"
else|:
literal|"horizontal"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  [ index |  pos  |  dir  | link |"
literal|" serif | blue | opos  |  pos  | flags   ]\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|edge
operator|=
name|edges
init|;
name|edge
operator|<
name|limit
condition|;
name|edge
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"  [ %5d | %5.2g | %5s | %4d |"
literal|" %5d |   %c  | %5.2f | %5.2f | %s ]\n"
argument_list|,
name|edge
operator|-
name|edges
argument_list|,
operator|(
name|int
operator|)
name|edge
operator|->
name|opos
operator|/
literal|64.0
argument_list|,
name|af_dir_str
argument_list|(
operator|(
name|AF_Direction
operator|)
name|edge
operator|->
name|dir
argument_list|)
argument_list|,
name|AF_INDEX_NUM
argument_list|(
name|edge
operator|->
name|link
argument_list|,
name|edges
argument_list|)
argument_list|,
name|AF_INDEX_NUM
argument_list|(
name|edge
operator|->
name|serif
argument_list|,
name|edges
argument_list|)
argument_list|,
name|edge
operator|->
name|blue_edge
condition|?
literal|'y'
else|:
literal|'n'
argument_list|,
name|edge
operator|->
name|opos
operator|/
literal|64.0
argument_list|,
name|edge
operator|->
name|pos
operator|/
literal|64.0
argument_list|,
name|af_edge_flags_to_string
argument_list|(
name|edge
operator|->
name|flags
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* !AF_DEBUG */
end_comment
begin_comment
comment|/* these empty stubs are only used to link the `ftgrid' test program */
end_comment
begin_comment
comment|/* when debugging is disabled                                        */
end_comment
begin_function
name|void
DECL|function|af_glyph_hints_dump_points
name|af_glyph_hints_dump_points
parameter_list|(
name|AF_GlyphHints
name|hints
parameter_list|)
block|{
name|FT_UNUSED
argument_list|(
name|hints
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
name|void
DECL|function|af_glyph_hints_dump_segments
name|af_glyph_hints_dump_segments
parameter_list|(
name|AF_GlyphHints
name|hints
parameter_list|)
block|{
name|FT_UNUSED
argument_list|(
name|hints
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
name|void
DECL|function|af_glyph_hints_dump_edges
name|af_glyph_hints_dump_edges
parameter_list|(
name|AF_GlyphHints
name|hints
parameter_list|)
block|{
name|FT_UNUSED
argument_list|(
name|hints
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* !AF_DEBUG */
end_comment
begin_comment
comment|/* compute the direction value of a given vector */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|AF_Direction
argument_list|)
end_macro
begin_macro
name|af_direction_compute
argument_list|(
argument|FT_Pos  dx
argument_list|,
argument|FT_Pos  dy
argument_list|)
end_macro
begin_block
block|{
name|FT_Pos
name|ll
decl_stmt|,
name|ss
decl_stmt|;
comment|/* long and short arm lengths */
name|AF_Direction
name|dir
decl_stmt|;
comment|/* candidate direction        */
if|if
condition|(
name|dy
operator|>=
name|dx
condition|)
block|{
if|if
condition|(
name|dy
operator|>=
operator|-
name|dx
condition|)
block|{
name|dir
operator|=
name|AF_DIR_UP
expr_stmt|;
name|ll
operator|=
name|dy
expr_stmt|;
name|ss
operator|=
name|dx
expr_stmt|;
block|}
else|else
block|{
name|dir
operator|=
name|AF_DIR_LEFT
expr_stmt|;
name|ll
operator|=
operator|-
name|dx
expr_stmt|;
name|ss
operator|=
name|dy
expr_stmt|;
block|}
block|}
else|else
comment|/* dy< dx */
block|{
if|if
condition|(
name|dy
operator|>=
operator|-
name|dx
condition|)
block|{
name|dir
operator|=
name|AF_DIR_RIGHT
expr_stmt|;
name|ll
operator|=
name|dx
expr_stmt|;
name|ss
operator|=
name|dy
expr_stmt|;
block|}
else|else
block|{
name|dir
operator|=
name|AF_DIR_DOWN
expr_stmt|;
name|ll
operator|=
name|dy
expr_stmt|;
name|ss
operator|=
name|dx
expr_stmt|;
block|}
block|}
name|ss
operator|*=
literal|14
expr_stmt|;
if|if
condition|(
name|FT_ABS
argument_list|(
name|ll
argument_list|)
operator|<=
name|FT_ABS
argument_list|(
name|ss
argument_list|)
condition|)
name|dir
operator|=
name|AF_DIR_NONE
expr_stmt|;
return|return
name|dir
return|;
block|}
end_block
begin_comment
comment|/* compute all inflex points in a given glyph */
end_comment
begin_function
specifier|static
name|void
DECL|function|af_glyph_hints_compute_inflections
name|af_glyph_hints_compute_inflections
parameter_list|(
name|AF_GlyphHints
name|hints
parameter_list|)
block|{
name|AF_Point
modifier|*
name|contour
init|=
name|hints
operator|->
name|contours
decl_stmt|;
name|AF_Point
modifier|*
name|contour_limit
init|=
name|contour
operator|+
name|hints
operator|->
name|num_contours
decl_stmt|;
comment|/* do each contour separately */
for|for
control|(
init|;
name|contour
operator|<
name|contour_limit
condition|;
name|contour
operator|++
control|)
block|{
name|AF_Point
name|point
init|=
name|contour
index|[
literal|0
index|]
decl_stmt|;
name|AF_Point
name|first
init|=
name|point
decl_stmt|;
name|AF_Point
name|start
init|=
name|point
decl_stmt|;
name|AF_Point
name|end
init|=
name|point
decl_stmt|;
name|AF_Point
name|before
decl_stmt|;
name|AF_Point
name|after
decl_stmt|;
name|FT_Pos
name|in_x
decl_stmt|,
name|in_y
decl_stmt|,
name|out_x
decl_stmt|,
name|out_y
decl_stmt|;
name|AF_Angle
name|orient_prev
decl_stmt|,
name|orient_cur
decl_stmt|;
name|FT_Int
name|finished
init|=
literal|0
decl_stmt|;
comment|/* compute first segment in contour */
name|first
operator|=
name|point
expr_stmt|;
name|start
operator|=
name|end
operator|=
name|first
expr_stmt|;
do|do
block|{
name|end
operator|=
name|end
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|end
operator|==
name|first
condition|)
goto|goto
name|Skip
goto|;
name|in_x
operator|=
name|end
operator|->
name|fx
operator|-
name|start
operator|->
name|fx
expr_stmt|;
name|in_y
operator|=
name|end
operator|->
name|fy
operator|-
name|start
operator|->
name|fy
expr_stmt|;
block|}
do|while
condition|(
name|in_x
operator|==
literal|0
operator|&&
name|in_y
operator|==
literal|0
condition|)
do|;
comment|/* extend the segment start whenever possible */
name|before
operator|=
name|start
expr_stmt|;
do|do
block|{
do|do
block|{
name|start
operator|=
name|before
expr_stmt|;
name|before
operator|=
name|before
operator|->
name|prev
expr_stmt|;
if|if
condition|(
name|before
operator|==
name|first
condition|)
goto|goto
name|Skip
goto|;
name|out_x
operator|=
name|start
operator|->
name|fx
operator|-
name|before
operator|->
name|fx
expr_stmt|;
name|out_y
operator|=
name|start
operator|->
name|fy
operator|-
name|before
operator|->
name|fy
expr_stmt|;
block|}
do|while
condition|(
name|out_x
operator|==
literal|0
operator|&&
name|out_y
operator|==
literal|0
condition|)
do|;
name|orient_prev
operator|=
name|ft_corner_orientation
argument_list|(
name|in_x
argument_list|,
name|in_y
argument_list|,
name|out_x
argument_list|,
name|out_y
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|orient_prev
operator|==
literal|0
condition|)
do|;
name|first
operator|=
name|start
expr_stmt|;
name|in_x
operator|=
name|out_x
expr_stmt|;
name|in_y
operator|=
name|out_y
expr_stmt|;
comment|/* now process all segments in the contour */
do|do
block|{
comment|/* first, extend current segment's end whenever possible */
name|after
operator|=
name|end
expr_stmt|;
do|do
block|{
do|do
block|{
name|end
operator|=
name|after
expr_stmt|;
name|after
operator|=
name|after
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|after
operator|==
name|first
condition|)
name|finished
operator|=
literal|1
expr_stmt|;
name|out_x
operator|=
name|after
operator|->
name|fx
operator|-
name|end
operator|->
name|fx
expr_stmt|;
name|out_y
operator|=
name|after
operator|->
name|fy
operator|-
name|end
operator|->
name|fy
expr_stmt|;
block|}
do|while
condition|(
name|out_x
operator|==
literal|0
operator|&&
name|out_y
operator|==
literal|0
condition|)
do|;
name|orient_cur
operator|=
name|ft_corner_orientation
argument_list|(
name|in_x
argument_list|,
name|in_y
argument_list|,
name|out_x
argument_list|,
name|out_y
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|orient_cur
operator|==
literal|0
condition|)
do|;
if|if
condition|(
operator|(
name|orient_prev
operator|+
name|orient_cur
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* we have an inflection point here */
do|do
block|{
name|start
operator|->
name|flags
operator||=
name|AF_FLAG_INFLECTION
expr_stmt|;
name|start
operator|=
name|start
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|start
operator|!=
name|end
condition|)
do|;
name|start
operator|->
name|flags
operator||=
name|AF_FLAG_INFLECTION
expr_stmt|;
block|}
name|start
operator|=
name|end
expr_stmt|;
name|end
operator|=
name|after
expr_stmt|;
name|orient_prev
operator|=
name|orient_cur
expr_stmt|;
name|in_x
operator|=
name|out_x
expr_stmt|;
name|in_y
operator|=
name|out_y
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|finished
condition|)
do|;
name|Skip
label|:
empty_stmt|;
block|}
block|}
end_function
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|af_glyph_hints_init
name|af_glyph_hints_init
argument_list|(
argument|AF_GlyphHints  hints
argument_list|,
argument|FT_Memory      memory
argument_list|)
end_macro
begin_block
block|{
name|FT_ZERO
argument_list|(
name|hints
argument_list|)
expr_stmt|;
name|hints
operator|->
name|memory
operator|=
name|memory
expr_stmt|;
block|}
end_block
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|af_glyph_hints_done
name|af_glyph_hints_done
argument_list|(
argument|AF_GlyphHints  hints
argument_list|)
end_macro
begin_block
block|{
if|if
condition|(
name|hints
operator|&&
name|hints
operator|->
name|memory
condition|)
block|{
name|FT_Memory
name|memory
init|=
name|hints
operator|->
name|memory
decl_stmt|;
name|int
name|dim
decl_stmt|;
comment|/*        *  note that we don't need to free the segment and edge        *  buffers, since they are really within the hints->points array        */
for|for
control|(
name|dim
operator|=
literal|0
init|;
name|dim
operator|<
name|AF_DIMENSION_MAX
condition|;
name|dim
operator|++
control|)
block|{
name|AF_AxisHints
name|axis
init|=
operator|&
name|hints
operator|->
name|axis
index|[
name|dim
index|]
decl_stmt|;
name|axis
operator|->
name|num_segments
operator|=
literal|0
expr_stmt|;
name|axis
operator|->
name|max_segments
operator|=
literal|0
expr_stmt|;
name|FT_FREE
argument_list|(
name|axis
operator|->
name|segments
argument_list|)
expr_stmt|;
name|axis
operator|->
name|num_edges
operator|=
literal|0
expr_stmt|;
name|axis
operator|->
name|max_edges
operator|=
literal|0
expr_stmt|;
name|FT_FREE
argument_list|(
name|axis
operator|->
name|edges
argument_list|)
expr_stmt|;
block|}
name|FT_FREE
argument_list|(
name|hints
operator|->
name|contours
argument_list|)
expr_stmt|;
name|hints
operator|->
name|max_contours
operator|=
literal|0
expr_stmt|;
name|hints
operator|->
name|num_contours
operator|=
literal|0
expr_stmt|;
name|FT_FREE
argument_list|(
name|hints
operator|->
name|points
argument_list|)
expr_stmt|;
name|hints
operator|->
name|num_points
operator|=
literal|0
expr_stmt|;
name|hints
operator|->
name|max_points
operator|=
literal|0
expr_stmt|;
name|hints
operator|->
name|memory
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_block
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|af_glyph_hints_rescale
name|af_glyph_hints_rescale
argument_list|(
argument|AF_GlyphHints     hints
argument_list|,
argument|AF_ScriptMetrics  metrics
argument_list|)
end_macro
begin_block
block|{
name|hints
operator|->
name|metrics
operator|=
name|metrics
expr_stmt|;
name|hints
operator|->
name|scaler_flags
operator|=
name|metrics
operator|->
name|scaler
operator|.
name|flags
expr_stmt|;
block|}
end_block
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|af_glyph_hints_reload
argument_list|(
argument|AF_GlyphHints  hints
argument_list|,
argument|FT_Outline*    outline
argument_list|,
argument|FT_Bool        get_inflections
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
init|=
name|AF_Err_Ok
decl_stmt|;
name|AF_Point
name|points
decl_stmt|;
name|FT_UInt
name|old_max
decl_stmt|,
name|new_max
decl_stmt|;
name|FT_Fixed
name|x_scale
init|=
name|hints
operator|->
name|x_scale
decl_stmt|;
name|FT_Fixed
name|y_scale
init|=
name|hints
operator|->
name|y_scale
decl_stmt|;
name|FT_Pos
name|x_delta
init|=
name|hints
operator|->
name|x_delta
decl_stmt|;
name|FT_Pos
name|y_delta
init|=
name|hints
operator|->
name|y_delta
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|hints
operator|->
name|memory
decl_stmt|;
name|hints
operator|->
name|num_points
operator|=
literal|0
expr_stmt|;
name|hints
operator|->
name|num_contours
operator|=
literal|0
expr_stmt|;
name|hints
operator|->
name|axis
index|[
literal|0
index|]
operator|.
name|num_segments
operator|=
literal|0
expr_stmt|;
name|hints
operator|->
name|axis
index|[
literal|0
index|]
operator|.
name|num_edges
operator|=
literal|0
expr_stmt|;
name|hints
operator|->
name|axis
index|[
literal|1
index|]
operator|.
name|num_segments
operator|=
literal|0
expr_stmt|;
name|hints
operator|->
name|axis
index|[
literal|1
index|]
operator|.
name|num_edges
operator|=
literal|0
expr_stmt|;
comment|/* first of all, reallocate the contours array when necessary */
name|new_max
operator|=
operator|(
name|FT_UInt
operator|)
name|outline
operator|->
name|n_contours
expr_stmt|;
name|old_max
operator|=
name|hints
operator|->
name|max_contours
expr_stmt|;
if|if
condition|(
name|new_max
operator|>
name|old_max
condition|)
block|{
name|new_max
operator|=
operator|(
name|new_max
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
expr_stmt|;
if|if
condition|(
name|FT_RENEW_ARRAY
argument_list|(
name|hints
operator|->
name|contours
argument_list|,
name|old_max
argument_list|,
name|new_max
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|hints
operator|->
name|max_contours
operator|=
name|new_max
expr_stmt|;
block|}
comment|/*      *  then reallocate the points arrays if necessary --      *  note that we reserve two additional point positions, used to      *  hint metrics appropriately      */
name|new_max
operator|=
call|(
name|FT_UInt
call|)
argument_list|(
name|outline
operator|->
name|n_points
operator|+
literal|2
argument_list|)
expr_stmt|;
name|old_max
operator|=
name|hints
operator|->
name|max_points
expr_stmt|;
if|if
condition|(
name|new_max
operator|>
name|old_max
condition|)
block|{
name|new_max
operator|=
operator|(
name|new_max
operator|+
literal|2
operator|+
literal|7
operator|)
operator|&
operator|~
literal|7
expr_stmt|;
if|if
condition|(
name|FT_RENEW_ARRAY
argument_list|(
name|hints
operator|->
name|points
argument_list|,
name|old_max
argument_list|,
name|new_max
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|hints
operator|->
name|max_points
operator|=
name|new_max
expr_stmt|;
block|}
name|hints
operator|->
name|num_points
operator|=
name|outline
operator|->
name|n_points
expr_stmt|;
name|hints
operator|->
name|num_contours
operator|=
name|outline
operator|->
name|n_contours
expr_stmt|;
comment|/* We can't rely on the value of `FT_Outline.flags' to know the fill   */
comment|/* direction used for a glyph, given that some fonts are broken (e.g., */
comment|/* the Arphic ones).  We thus recompute it each time we need to.       */
comment|/*                                                                     */
name|hints
operator|->
name|axis
index|[
name|AF_DIMENSION_HORZ
index|]
operator|.
name|major_dir
operator|=
name|AF_DIR_UP
expr_stmt|;
name|hints
operator|->
name|axis
index|[
name|AF_DIMENSION_VERT
index|]
operator|.
name|major_dir
operator|=
name|AF_DIR_LEFT
expr_stmt|;
if|if
condition|(
name|FT_Outline_Get_Orientation
argument_list|(
name|outline
argument_list|)
operator|==
name|FT_ORIENTATION_POSTSCRIPT
condition|)
block|{
name|hints
operator|->
name|axis
index|[
name|AF_DIMENSION_HORZ
index|]
operator|.
name|major_dir
operator|=
name|AF_DIR_DOWN
expr_stmt|;
name|hints
operator|->
name|axis
index|[
name|AF_DIMENSION_VERT
index|]
operator|.
name|major_dir
operator|=
name|AF_DIR_RIGHT
expr_stmt|;
block|}
name|hints
operator|->
name|x_scale
operator|=
name|x_scale
expr_stmt|;
name|hints
operator|->
name|y_scale
operator|=
name|y_scale
expr_stmt|;
name|hints
operator|->
name|x_delta
operator|=
name|x_delta
expr_stmt|;
name|hints
operator|->
name|y_delta
operator|=
name|y_delta
expr_stmt|;
name|hints
operator|->
name|xmin_delta
operator|=
literal|0
expr_stmt|;
name|hints
operator|->
name|xmax_delta
operator|=
literal|0
expr_stmt|;
name|points
operator|=
name|hints
operator|->
name|points
expr_stmt|;
if|if
condition|(
name|hints
operator|->
name|num_points
operator|==
literal|0
condition|)
goto|goto
name|Exit
goto|;
block|{
name|AF_Point
name|point
decl_stmt|;
name|AF_Point
name|point_limit
init|=
name|points
operator|+
name|hints
operator|->
name|num_points
decl_stmt|;
comment|/* compute coordinates& Bezier flags, next and prev */
block|{
name|FT_Vector
modifier|*
name|vec
init|=
name|outline
operator|->
name|points
decl_stmt|;
name|char
modifier|*
name|tag
init|=
name|outline
operator|->
name|tags
decl_stmt|;
name|AF_Point
name|first
init|=
name|points
decl_stmt|;
name|AF_Point
name|end
init|=
name|points
operator|+
name|outline
operator|->
name|contours
index|[
literal|0
index|]
decl_stmt|;
name|AF_Point
name|prev
init|=
name|end
decl_stmt|;
name|FT_Int
name|contour_index
init|=
literal|0
decl_stmt|;
name|FT_UNUSED
argument_list|(
name|first
argument_list|)
expr_stmt|;
for|for
control|(
name|point
operator|=
name|points
init|;
name|point
operator|<
name|point_limit
condition|;
name|point
operator|++
operator|,
name|vec
operator|++
operator|,
name|tag
operator|++
control|)
block|{
name|point
operator|->
name|fx
operator|=
operator|(
name|FT_Short
operator|)
name|vec
operator|->
name|x
expr_stmt|;
name|point
operator|->
name|fy
operator|=
operator|(
name|FT_Short
operator|)
name|vec
operator|->
name|y
expr_stmt|;
name|point
operator|->
name|ox
operator|=
name|point
operator|->
name|x
operator|=
name|FT_MulFix
argument_list|(
name|vec
operator|->
name|x
argument_list|,
name|x_scale
argument_list|)
operator|+
name|x_delta
expr_stmt|;
name|point
operator|->
name|oy
operator|=
name|point
operator|->
name|y
operator|=
name|FT_MulFix
argument_list|(
name|vec
operator|->
name|y
argument_list|,
name|y_scale
argument_list|)
operator|+
name|y_delta
expr_stmt|;
switch|switch
condition|(
name|FT_CURVE_TAG
argument_list|(
operator|*
name|tag
argument_list|)
condition|)
block|{
case|case
name|FT_CURVE_TAG_CONIC
case|:
name|point
operator|->
name|flags
operator|=
name|AF_FLAG_CONIC
expr_stmt|;
break|break;
case|case
name|FT_CURVE_TAG_CUBIC
case|:
name|point
operator|->
name|flags
operator|=
name|AF_FLAG_CUBIC
expr_stmt|;
break|break;
default|default:
name|point
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
block|}
name|point
operator|->
name|prev
operator|=
name|prev
expr_stmt|;
name|prev
operator|->
name|next
operator|=
name|point
expr_stmt|;
name|prev
operator|=
name|point
expr_stmt|;
if|if
condition|(
name|point
operator|==
name|end
condition|)
block|{
if|if
condition|(
operator|++
name|contour_index
operator|<
name|outline
operator|->
name|n_contours
condition|)
block|{
name|first
operator|=
name|point
operator|+
literal|1
expr_stmt|;
name|end
operator|=
name|points
operator|+
name|outline
operator|->
name|contours
index|[
name|contour_index
index|]
expr_stmt|;
name|prev
operator|=
name|end
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* set-up the contours array */
block|{
name|AF_Point
modifier|*
name|contour
init|=
name|hints
operator|->
name|contours
decl_stmt|;
name|AF_Point
modifier|*
name|contour_limit
init|=
name|contour
operator|+
name|hints
operator|->
name|num_contours
decl_stmt|;
name|short
modifier|*
name|end
init|=
name|outline
operator|->
name|contours
decl_stmt|;
name|short
name|idx
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|contour
operator|<
name|contour_limit
condition|;
name|contour
operator|++
operator|,
name|end
operator|++
control|)
block|{
name|contour
index|[
literal|0
index|]
operator|=
name|points
operator|+
name|idx
expr_stmt|;
name|idx
operator|=
call|(
name|short
call|)
argument_list|(
name|end
index|[
literal|0
index|]
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* compute directions of in& out vectors */
block|{
name|AF_Point
name|first
init|=
name|points
decl_stmt|;
name|AF_Point
name|prev
init|=
name|NULL
decl_stmt|;
name|FT_Pos
name|in_x
init|=
literal|0
decl_stmt|;
name|FT_Pos
name|in_y
init|=
literal|0
decl_stmt|;
name|AF_Direction
name|in_dir
init|=
name|AF_DIR_NONE
decl_stmt|;
for|for
control|(
name|point
operator|=
name|points
init|;
name|point
operator|<
name|point_limit
condition|;
name|point
operator|++
control|)
block|{
name|AF_Point
name|next
decl_stmt|;
name|FT_Pos
name|out_x
decl_stmt|,
name|out_y
decl_stmt|;
if|if
condition|(
name|point
operator|==
name|first
condition|)
block|{
name|prev
operator|=
name|first
operator|->
name|prev
expr_stmt|;
name|in_x
operator|=
name|first
operator|->
name|fx
operator|-
name|prev
operator|->
name|fx
expr_stmt|;
name|in_y
operator|=
name|first
operator|->
name|fy
operator|-
name|prev
operator|->
name|fy
expr_stmt|;
name|in_dir
operator|=
name|af_direction_compute
argument_list|(
name|in_x
argument_list|,
name|in_y
argument_list|)
expr_stmt|;
name|first
operator|=
name|prev
operator|+
literal|1
expr_stmt|;
block|}
name|point
operator|->
name|in_dir
operator|=
operator|(
name|FT_Char
operator|)
name|in_dir
expr_stmt|;
name|next
operator|=
name|point
operator|->
name|next
expr_stmt|;
name|out_x
operator|=
name|next
operator|->
name|fx
operator|-
name|point
operator|->
name|fx
expr_stmt|;
name|out_y
operator|=
name|next
operator|->
name|fy
operator|-
name|point
operator|->
name|fy
expr_stmt|;
name|in_dir
operator|=
name|af_direction_compute
argument_list|(
name|out_x
argument_list|,
name|out_y
argument_list|)
expr_stmt|;
name|point
operator|->
name|out_dir
operator|=
operator|(
name|FT_Char
operator|)
name|in_dir
expr_stmt|;
if|if
condition|(
name|point
operator|->
name|flags
operator|&
operator|(
name|AF_FLAG_CONIC
operator||
name|AF_FLAG_CUBIC
operator|)
condition|)
block|{
name|Is_Weak_Point
label|:
name|point
operator|->
name|flags
operator||=
name|AF_FLAG_WEAK_INTERPOLATION
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|point
operator|->
name|out_dir
operator|==
name|point
operator|->
name|in_dir
condition|)
block|{
if|if
condition|(
name|point
operator|->
name|out_dir
operator|!=
name|AF_DIR_NONE
condition|)
goto|goto
name|Is_Weak_Point
goto|;
if|if
condition|(
name|ft_corner_is_flat
argument_list|(
name|in_x
argument_list|,
name|in_y
argument_list|,
name|out_x
argument_list|,
name|out_y
argument_list|)
condition|)
goto|goto
name|Is_Weak_Point
goto|;
block|}
elseif|else
if|if
condition|(
name|point
operator|->
name|in_dir
operator|==
operator|-
name|point
operator|->
name|out_dir
condition|)
goto|goto
name|Is_Weak_Point
goto|;
name|in_x
operator|=
name|out_x
expr_stmt|;
name|in_y
operator|=
name|out_y
expr_stmt|;
name|prev
operator|=
name|point
expr_stmt|;
block|}
block|}
block|}
comment|/* compute inflection points --                 */
comment|/* disabled due to no longer perceived benefits */
if|if
condition|(
literal|0
operator|&&
name|get_inflections
condition|)
name|af_glyph_hints_compute_inflections
argument_list|(
name|hints
argument_list|)
expr_stmt|;
name|Exit
label|:
return|return
name|error
return|;
block|}
end_block
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|af_glyph_hints_save
name|af_glyph_hints_save
argument_list|(
argument|AF_GlyphHints  hints
argument_list|,
argument|FT_Outline*    outline
argument_list|)
end_macro
begin_block
block|{
name|AF_Point
name|point
init|=
name|hints
operator|->
name|points
decl_stmt|;
name|AF_Point
name|limit
init|=
name|point
operator|+
name|hints
operator|->
name|num_points
decl_stmt|;
name|FT_Vector
modifier|*
name|vec
init|=
name|outline
operator|->
name|points
decl_stmt|;
name|char
modifier|*
name|tag
init|=
name|outline
operator|->
name|tags
decl_stmt|;
for|for
control|(
init|;
name|point
operator|<
name|limit
condition|;
name|point
operator|++
operator|,
name|vec
operator|++
operator|,
name|tag
operator|++
control|)
block|{
name|vec
operator|->
name|x
operator|=
name|point
operator|->
name|x
expr_stmt|;
name|vec
operator|->
name|y
operator|=
name|point
operator|->
name|y
expr_stmt|;
if|if
condition|(
name|point
operator|->
name|flags
operator|&
name|AF_FLAG_CONIC
condition|)
name|tag
index|[
literal|0
index|]
operator|=
name|FT_CURVE_TAG_CONIC
expr_stmt|;
elseif|else
if|if
condition|(
name|point
operator|->
name|flags
operator|&
name|AF_FLAG_CUBIC
condition|)
name|tag
index|[
literal|0
index|]
operator|=
name|FT_CURVE_TAG_CUBIC
expr_stmt|;
else|else
name|tag
index|[
literal|0
index|]
operator|=
name|FT_CURVE_TAG_ON
expr_stmt|;
block|}
block|}
end_block
begin_comment
comment|/****************************************************************    *    *                     EDGE POINT GRID-FITTING    *    ****************************************************************/
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|af_glyph_hints_align_edge_points
name|af_glyph_hints_align_edge_points
argument_list|(
argument|AF_GlyphHints  hints
argument_list|,
argument|AF_Dimension   dim
argument_list|)
end_macro
begin_block
block|{
name|AF_AxisHints
name|axis
init|=
operator|&
name|hints
operator|->
name|axis
index|[
name|dim
index|]
decl_stmt|;
name|AF_Segment
name|segments
init|=
name|axis
operator|->
name|segments
decl_stmt|;
name|AF_Segment
name|segment_limit
init|=
name|segments
operator|+
name|axis
operator|->
name|num_segments
decl_stmt|;
name|AF_Segment
name|seg
decl_stmt|;
if|if
condition|(
name|dim
operator|==
name|AF_DIMENSION_HORZ
condition|)
block|{
for|for
control|(
name|seg
operator|=
name|segments
init|;
name|seg
operator|<
name|segment_limit
condition|;
name|seg
operator|++
control|)
block|{
name|AF_Edge
name|edge
init|=
name|seg
operator|->
name|edge
decl_stmt|;
name|AF_Point
name|point
decl_stmt|,
name|first
decl_stmt|,
name|last
decl_stmt|;
if|if
condition|(
name|edge
operator|==
name|NULL
condition|)
continue|continue;
name|first
operator|=
name|seg
operator|->
name|first
expr_stmt|;
name|last
operator|=
name|seg
operator|->
name|last
expr_stmt|;
name|point
operator|=
name|first
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|point
operator|->
name|x
operator|=
name|edge
operator|->
name|pos
expr_stmt|;
name|point
operator|->
name|flags
operator||=
name|AF_FLAG_TOUCH_X
expr_stmt|;
if|if
condition|(
name|point
operator|==
name|last
condition|)
break|break;
name|point
operator|=
name|point
operator|->
name|next
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|seg
operator|=
name|segments
init|;
name|seg
operator|<
name|segment_limit
condition|;
name|seg
operator|++
control|)
block|{
name|AF_Edge
name|edge
init|=
name|seg
operator|->
name|edge
decl_stmt|;
name|AF_Point
name|point
decl_stmt|,
name|first
decl_stmt|,
name|last
decl_stmt|;
if|if
condition|(
name|edge
operator|==
name|NULL
condition|)
continue|continue;
name|first
operator|=
name|seg
operator|->
name|first
expr_stmt|;
name|last
operator|=
name|seg
operator|->
name|last
expr_stmt|;
name|point
operator|=
name|first
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|point
operator|->
name|y
operator|=
name|edge
operator|->
name|pos
expr_stmt|;
name|point
operator|->
name|flags
operator||=
name|AF_FLAG_TOUCH_Y
expr_stmt|;
if|if
condition|(
name|point
operator|==
name|last
condition|)
break|break;
name|point
operator|=
name|point
operator|->
name|next
expr_stmt|;
block|}
block|}
block|}
block|}
end_block
begin_comment
comment|/****************************************************************    *    *                    STRONG POINT INTERPOLATION    *    ****************************************************************/
end_comment
begin_comment
comment|/* hint the strong points -- this is equivalent to the TrueType `IP' */
end_comment
begin_comment
comment|/* hinting instruction                                               */
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|af_glyph_hints_align_strong_points
name|af_glyph_hints_align_strong_points
argument_list|(
argument|AF_GlyphHints  hints
argument_list|,
argument|AF_Dimension   dim
argument_list|)
end_macro
begin_block
block|{
name|AF_Point
name|points
init|=
name|hints
operator|->
name|points
decl_stmt|;
name|AF_Point
name|point_limit
init|=
name|points
operator|+
name|hints
operator|->
name|num_points
decl_stmt|;
name|AF_AxisHints
name|axis
init|=
operator|&
name|hints
operator|->
name|axis
index|[
name|dim
index|]
decl_stmt|;
name|AF_Edge
name|edges
init|=
name|axis
operator|->
name|edges
decl_stmt|;
name|AF_Edge
name|edge_limit
init|=
name|edges
operator|+
name|axis
operator|->
name|num_edges
decl_stmt|;
name|AF_Flags
name|touch_flag
decl_stmt|;
if|if
condition|(
name|dim
operator|==
name|AF_DIMENSION_HORZ
condition|)
name|touch_flag
operator|=
name|AF_FLAG_TOUCH_X
expr_stmt|;
else|else
name|touch_flag
operator|=
name|AF_FLAG_TOUCH_Y
expr_stmt|;
if|if
condition|(
name|edges
operator|<
name|edge_limit
condition|)
block|{
name|AF_Point
name|point
decl_stmt|;
name|AF_Edge
name|edge
decl_stmt|;
for|for
control|(
name|point
operator|=
name|points
init|;
name|point
operator|<
name|point_limit
condition|;
name|point
operator|++
control|)
block|{
name|FT_Pos
name|u
decl_stmt|,
name|ou
decl_stmt|,
name|fu
decl_stmt|;
comment|/* point position */
name|FT_Pos
name|delta
decl_stmt|;
if|if
condition|(
name|point
operator|->
name|flags
operator|&
name|touch_flag
condition|)
continue|continue;
comment|/* if this point is candidate to weak interpolation, we       */
comment|/* interpolate it after all strong points have been processed */
if|if
condition|(
operator|(
name|point
operator|->
name|flags
operator|&
name|AF_FLAG_WEAK_INTERPOLATION
operator|)
operator|&&
operator|!
operator|(
name|point
operator|->
name|flags
operator|&
name|AF_FLAG_INFLECTION
operator|)
condition|)
continue|continue;
if|if
condition|(
name|dim
operator|==
name|AF_DIMENSION_VERT
condition|)
block|{
name|u
operator|=
name|point
operator|->
name|fy
expr_stmt|;
name|ou
operator|=
name|point
operator|->
name|oy
expr_stmt|;
block|}
else|else
block|{
name|u
operator|=
name|point
operator|->
name|fx
expr_stmt|;
name|ou
operator|=
name|point
operator|->
name|ox
expr_stmt|;
block|}
name|fu
operator|=
name|u
expr_stmt|;
comment|/* is the point before the first edge? */
name|edge
operator|=
name|edges
expr_stmt|;
name|delta
operator|=
name|edge
operator|->
name|fpos
operator|-
name|u
expr_stmt|;
if|if
condition|(
name|delta
operator|>=
literal|0
condition|)
block|{
name|u
operator|=
name|edge
operator|->
name|pos
operator|-
operator|(
name|edge
operator|->
name|opos
operator|-
name|ou
operator|)
expr_stmt|;
goto|goto
name|Store_Point
goto|;
block|}
comment|/* is the point after the last edge? */
name|edge
operator|=
name|edge_limit
operator|-
literal|1
expr_stmt|;
name|delta
operator|=
name|u
operator|-
name|edge
operator|->
name|fpos
expr_stmt|;
if|if
condition|(
name|delta
operator|>=
literal|0
condition|)
block|{
name|u
operator|=
name|edge
operator|->
name|pos
operator|+
operator|(
name|ou
operator|-
name|edge
operator|->
name|opos
operator|)
expr_stmt|;
goto|goto
name|Store_Point
goto|;
block|}
block|{
name|FT_PtrDist
name|min
decl_stmt|,
name|max
decl_stmt|,
name|mid
decl_stmt|;
name|FT_Pos
name|fpos
decl_stmt|;
comment|/* find enclosing edges */
name|min
operator|=
literal|0
expr_stmt|;
name|max
operator|=
name|edge_limit
operator|-
name|edges
expr_stmt|;
if|#
directive|if
literal|1
comment|/* for small edge counts, a linear search is better */
if|if
condition|(
name|max
operator|<=
literal|8
condition|)
block|{
name|FT_PtrDist
name|nn
decl_stmt|;
for|for
control|(
name|nn
operator|=
literal|0
init|;
name|nn
operator|<
name|max
condition|;
name|nn
operator|++
control|)
if|if
condition|(
name|edges
index|[
name|nn
index|]
operator|.
name|fpos
operator|>=
name|u
condition|)
break|break;
if|if
condition|(
name|edges
index|[
name|nn
index|]
operator|.
name|fpos
operator|==
name|u
condition|)
block|{
name|u
operator|=
name|edges
index|[
name|nn
index|]
operator|.
name|pos
expr_stmt|;
goto|goto
name|Store_Point
goto|;
block|}
name|min
operator|=
name|nn
expr_stmt|;
block|}
else|else
endif|#
directive|endif
while|while
condition|(
name|min
operator|<
name|max
condition|)
block|{
name|mid
operator|=
operator|(
name|max
operator|+
name|min
operator|)
operator|>>
literal|1
expr_stmt|;
name|edge
operator|=
name|edges
operator|+
name|mid
expr_stmt|;
name|fpos
operator|=
name|edge
operator|->
name|fpos
expr_stmt|;
if|if
condition|(
name|u
operator|<
name|fpos
condition|)
name|max
operator|=
name|mid
expr_stmt|;
elseif|else
if|if
condition|(
name|u
operator|>
name|fpos
condition|)
name|min
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
else|else
block|{
comment|/* we are on the edge */
name|u
operator|=
name|edge
operator|->
name|pos
expr_stmt|;
goto|goto
name|Store_Point
goto|;
block|}
block|}
block|{
name|AF_Edge
name|before
init|=
name|edges
operator|+
name|min
operator|-
literal|1
decl_stmt|;
name|AF_Edge
name|after
init|=
name|edges
operator|+
name|min
operator|+
literal|0
decl_stmt|;
comment|/* assert( before&& after&& before != after ) */
if|if
condition|(
name|before
operator|->
name|scale
operator|==
literal|0
condition|)
name|before
operator|->
name|scale
operator|=
name|FT_DivFix
argument_list|(
name|after
operator|->
name|pos
operator|-
name|before
operator|->
name|pos
argument_list|,
name|after
operator|->
name|fpos
operator|-
name|before
operator|->
name|fpos
argument_list|)
expr_stmt|;
name|u
operator|=
name|before
operator|->
name|pos
operator|+
name|FT_MulFix
argument_list|(
name|fu
operator|-
name|before
operator|->
name|fpos
argument_list|,
name|before
operator|->
name|scale
argument_list|)
expr_stmt|;
block|}
block|}
name|Store_Point
label|:
comment|/* save the point position */
if|if
condition|(
name|dim
operator|==
name|AF_DIMENSION_HORZ
condition|)
name|point
operator|->
name|x
operator|=
name|u
expr_stmt|;
else|else
name|point
operator|->
name|y
operator|=
name|u
expr_stmt|;
name|point
operator|->
name|flags
operator||=
name|touch_flag
expr_stmt|;
block|}
block|}
block|}
end_block
begin_comment
comment|/****************************************************************    *    *                    WEAK POINT INTERPOLATION    *    ****************************************************************/
end_comment
begin_function
specifier|static
name|void
DECL|function|af_iup_shift
name|af_iup_shift
parameter_list|(
name|AF_Point
name|p1
parameter_list|,
name|AF_Point
name|p2
parameter_list|,
name|AF_Point
name|ref
parameter_list|)
block|{
name|AF_Point
name|p
decl_stmt|;
name|FT_Pos
name|delta
init|=
name|ref
operator|->
name|u
operator|-
name|ref
operator|->
name|v
decl_stmt|;
if|if
condition|(
name|delta
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|p
operator|=
name|p1
init|;
name|p
operator|<
name|ref
condition|;
name|p
operator|++
control|)
name|p
operator|->
name|u
operator|=
name|p
operator|->
name|v
operator|+
name|delta
expr_stmt|;
for|for
control|(
name|p
operator|=
name|ref
operator|+
literal|1
init|;
name|p
operator|<=
name|p2
condition|;
name|p
operator|++
control|)
name|p
operator|->
name|u
operator|=
name|p
operator|->
name|v
operator|+
name|delta
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|af_iup_interp
name|af_iup_interp
parameter_list|(
name|AF_Point
name|p1
parameter_list|,
name|AF_Point
name|p2
parameter_list|,
name|AF_Point
name|ref1
parameter_list|,
name|AF_Point
name|ref2
parameter_list|)
block|{
name|AF_Point
name|p
decl_stmt|;
name|FT_Pos
name|u
decl_stmt|;
name|FT_Pos
name|v1
init|=
name|ref1
operator|->
name|v
decl_stmt|;
name|FT_Pos
name|v2
init|=
name|ref2
operator|->
name|v
decl_stmt|;
name|FT_Pos
name|d1
init|=
name|ref1
operator|->
name|u
operator|-
name|v1
decl_stmt|;
name|FT_Pos
name|d2
init|=
name|ref2
operator|->
name|u
operator|-
name|v2
decl_stmt|;
if|if
condition|(
name|p1
operator|>
name|p2
condition|)
return|return;
if|if
condition|(
name|v1
operator|==
name|v2
condition|)
block|{
for|for
control|(
name|p
operator|=
name|p1
init|;
name|p
operator|<=
name|p2
condition|;
name|p
operator|++
control|)
block|{
name|u
operator|=
name|p
operator|->
name|v
expr_stmt|;
if|if
condition|(
name|u
operator|<=
name|v1
condition|)
name|u
operator|+=
name|d1
expr_stmt|;
else|else
name|u
operator|+=
name|d2
expr_stmt|;
name|p
operator|->
name|u
operator|=
name|u
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|v1
operator|<
name|v2
condition|)
block|{
for|for
control|(
name|p
operator|=
name|p1
init|;
name|p
operator|<=
name|p2
condition|;
name|p
operator|++
control|)
block|{
name|u
operator|=
name|p
operator|->
name|v
expr_stmt|;
if|if
condition|(
name|u
operator|<=
name|v1
condition|)
name|u
operator|+=
name|d1
expr_stmt|;
elseif|else
if|if
condition|(
name|u
operator|>=
name|v2
condition|)
name|u
operator|+=
name|d2
expr_stmt|;
else|else
name|u
operator|=
name|ref1
operator|->
name|u
operator|+
name|FT_MulDiv
argument_list|(
name|u
operator|-
name|v1
argument_list|,
name|ref2
operator|->
name|u
operator|-
name|ref1
operator|->
name|u
argument_list|,
name|v2
operator|-
name|v1
argument_list|)
expr_stmt|;
name|p
operator|->
name|u
operator|=
name|u
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|p
operator|=
name|p1
init|;
name|p
operator|<=
name|p2
condition|;
name|p
operator|++
control|)
block|{
name|u
operator|=
name|p
operator|->
name|v
expr_stmt|;
if|if
condition|(
name|u
operator|<=
name|v2
condition|)
name|u
operator|+=
name|d2
expr_stmt|;
elseif|else
if|if
condition|(
name|u
operator|>=
name|v1
condition|)
name|u
operator|+=
name|d1
expr_stmt|;
else|else
name|u
operator|=
name|ref1
operator|->
name|u
operator|+
name|FT_MulDiv
argument_list|(
name|u
operator|-
name|v1
argument_list|,
name|ref2
operator|->
name|u
operator|-
name|ref1
operator|->
name|u
argument_list|,
name|v2
operator|-
name|v1
argument_list|)
expr_stmt|;
name|p
operator|->
name|u
operator|=
name|u
expr_stmt|;
block|}
block|}
block|}
end_function
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|af_glyph_hints_align_weak_points
name|af_glyph_hints_align_weak_points
argument_list|(
argument|AF_GlyphHints  hints
argument_list|,
argument|AF_Dimension   dim
argument_list|)
end_macro
begin_block
block|{
name|AF_Point
name|points
init|=
name|hints
operator|->
name|points
decl_stmt|;
name|AF_Point
name|point_limit
init|=
name|points
operator|+
name|hints
operator|->
name|num_points
decl_stmt|;
name|AF_Point
modifier|*
name|contour
init|=
name|hints
operator|->
name|contours
decl_stmt|;
name|AF_Point
modifier|*
name|contour_limit
init|=
name|contour
operator|+
name|hints
operator|->
name|num_contours
decl_stmt|;
name|AF_Flags
name|touch_flag
decl_stmt|;
name|AF_Point
name|point
decl_stmt|;
name|AF_Point
name|end_point
decl_stmt|;
name|AF_Point
name|first_point
decl_stmt|;
comment|/* PASS 1: Move segment points to edge positions */
if|if
condition|(
name|dim
operator|==
name|AF_DIMENSION_HORZ
condition|)
block|{
name|touch_flag
operator|=
name|AF_FLAG_TOUCH_X
expr_stmt|;
for|for
control|(
name|point
operator|=
name|points
init|;
name|point
operator|<
name|point_limit
condition|;
name|point
operator|++
control|)
block|{
name|point
operator|->
name|u
operator|=
name|point
operator|->
name|x
expr_stmt|;
name|point
operator|->
name|v
operator|=
name|point
operator|->
name|ox
expr_stmt|;
block|}
block|}
else|else
block|{
name|touch_flag
operator|=
name|AF_FLAG_TOUCH_Y
expr_stmt|;
for|for
control|(
name|point
operator|=
name|points
init|;
name|point
operator|<
name|point_limit
condition|;
name|point
operator|++
control|)
block|{
name|point
operator|->
name|u
operator|=
name|point
operator|->
name|y
expr_stmt|;
name|point
operator|->
name|v
operator|=
name|point
operator|->
name|oy
expr_stmt|;
block|}
block|}
name|point
operator|=
name|points
expr_stmt|;
for|for
control|(
init|;
name|contour
operator|<
name|contour_limit
condition|;
name|contour
operator|++
control|)
block|{
name|AF_Point
name|first_touched
decl_stmt|,
name|last_touched
decl_stmt|;
name|point
operator|=
operator|*
name|contour
expr_stmt|;
name|end_point
operator|=
name|point
operator|->
name|prev
expr_stmt|;
name|first_point
operator|=
name|point
expr_stmt|;
comment|/* find first touched point */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|point
operator|>
name|end_point
condition|)
comment|/* no touched point in contour */
goto|goto
name|NextContour
goto|;
if|if
condition|(
name|point
operator|->
name|flags
operator|&
name|touch_flag
condition|)
break|break;
name|point
operator|++
expr_stmt|;
block|}
name|first_touched
operator|=
name|point
expr_stmt|;
name|last_touched
operator|=
name|point
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|FT_ASSERT
argument_list|(
name|point
operator|<=
name|end_point
operator|&&
operator|(
name|point
operator|->
name|flags
operator|&
name|touch_flag
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/* skip any touched neighbhours */
while|while
condition|(
name|point
operator|<
name|end_point
operator|&&
operator|(
name|point
index|[
literal|1
index|]
operator|.
name|flags
operator|&
name|touch_flag
operator|)
operator|!=
literal|0
condition|)
name|point
operator|++
expr_stmt|;
name|last_touched
operator|=
name|point
expr_stmt|;
comment|/* find the next touched point, if any */
name|point
operator|++
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|point
operator|>
name|end_point
condition|)
goto|goto
name|EndContour
goto|;
if|if
condition|(
operator|(
name|point
operator|->
name|flags
operator|&
name|touch_flag
operator|)
operator|!=
literal|0
condition|)
break|break;
name|point
operator|++
expr_stmt|;
block|}
comment|/* interpolate between last_touched and point */
name|af_iup_interp
argument_list|(
name|last_touched
operator|+
literal|1
argument_list|,
name|point
operator|-
literal|1
argument_list|,
name|last_touched
argument_list|,
name|point
argument_list|)
expr_stmt|;
block|}
name|EndContour
label|:
comment|/* special case: only one point was touched */
if|if
condition|(
name|last_touched
operator|==
name|first_touched
condition|)
block|{
name|af_iup_shift
argument_list|(
name|first_point
argument_list|,
name|end_point
argument_list|,
name|first_touched
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* interpolate the last part */
block|{
if|if
condition|(
name|last_touched
operator|<
name|end_point
condition|)
name|af_iup_interp
argument_list|(
name|last_touched
operator|+
literal|1
argument_list|,
name|end_point
argument_list|,
name|last_touched
argument_list|,
name|first_touched
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_touched
operator|>
name|points
condition|)
name|af_iup_interp
argument_list|(
name|first_point
argument_list|,
name|first_touched
operator|-
literal|1
argument_list|,
name|last_touched
argument_list|,
name|first_touched
argument_list|)
expr_stmt|;
block|}
name|NextContour
label|:
empty_stmt|;
block|}
comment|/* now save the interpolated values back to x/y */
if|if
condition|(
name|dim
operator|==
name|AF_DIMENSION_HORZ
condition|)
block|{
for|for
control|(
name|point
operator|=
name|points
init|;
name|point
operator|<
name|point_limit
condition|;
name|point
operator|++
control|)
name|point
operator|->
name|x
operator|=
name|point
operator|->
name|u
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|point
operator|=
name|points
init|;
name|point
operator|<
name|point_limit
condition|;
name|point
operator|++
control|)
name|point
operator|->
name|y
operator|=
name|point
operator|->
name|u
expr_stmt|;
block|}
block|}
end_block
begin_ifdef
ifdef|#
directive|ifdef
name|AF_USE_WARPER
end_ifdef
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|af_glyph_hints_scale_dim
name|af_glyph_hints_scale_dim
argument_list|(
argument|AF_GlyphHints  hints
argument_list|,
argument|AF_Dimension   dim
argument_list|,
argument|FT_Fixed       scale
argument_list|,
argument|FT_Pos         delta
argument_list|)
end_macro
begin_block
block|{
name|AF_Point
name|points
init|=
name|hints
operator|->
name|points
decl_stmt|;
name|AF_Point
name|points_limit
init|=
name|points
operator|+
name|hints
operator|->
name|num_points
decl_stmt|;
name|AF_Point
name|point
decl_stmt|;
if|if
condition|(
name|dim
operator|==
name|AF_DIMENSION_HORZ
condition|)
block|{
for|for
control|(
name|point
operator|=
name|points
init|;
name|point
operator|<
name|points_limit
condition|;
name|point
operator|++
control|)
name|point
operator|->
name|x
operator|=
name|FT_MulFix
argument_list|(
name|point
operator|->
name|fx
argument_list|,
name|scale
argument_list|)
operator|+
name|delta
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|point
operator|=
name|points
init|;
name|point
operator|<
name|points_limit
condition|;
name|point
operator|++
control|)
name|point
operator|->
name|y
operator|=
name|FT_MulFix
argument_list|(
name|point
operator|->
name|fy
argument_list|,
name|scale
argument_list|)
operator|+
name|delta
expr_stmt|;
block|}
block|}
end_block
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* AF_USE_WARPER */
end_comment
begin_comment
comment|/* END */
end_comment
end_unit
