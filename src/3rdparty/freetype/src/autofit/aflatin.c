begin_unit
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  aflatin.c                                                              */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*    Auto-fitter hinting routines for latin writing system (body).        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  Copyright 2003-2015 by                                                 */
end_comment
begin_comment
comment|/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  This file is part of the FreeType project, and may only be used,       */
end_comment
begin_comment
comment|/*  modified, and distributed under the terms of the FreeType project      */
end_comment
begin_comment
comment|/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
end_comment
begin_comment
comment|/*  this file you indicate that you have read the license and              */
end_comment
begin_comment
comment|/*  understand and accept it fully.                                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<ft2build.h>
end_include
begin_include
include|#
directive|include
include|FT_ADVANCES_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_DEBUG_H
end_include
begin_include
include|#
directive|include
file|"afglobal.h"
end_include
begin_include
include|#
directive|include
file|"afpic.h"
end_include
begin_include
include|#
directive|include
file|"aflatin.h"
end_include
begin_include
include|#
directive|include
file|"aferrors.h"
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|AF_CONFIG_OPTION_USE_WARPER
end_ifdef
begin_include
include|#
directive|include
file|"afwarp.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
end_comment
begin_comment
comment|/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
end_comment
begin_comment
comment|/* messages during execution.                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_undef
DECL|macro|FT_COMPONENT
undef|#
directive|undef
name|FT_COMPONENT
end_undef
begin_define
DECL|macro|FT_COMPONENT
define|#
directive|define
name|FT_COMPONENT
value|trace_aflatin
end_define
begin_comment
comment|/* needed for computation of round vs. flat segments */
end_comment
begin_define
DECL|macro|FLAT_THRESHOLD
define|#
directive|define
name|FLAT_THRESHOLD
parameter_list|(
name|x
parameter_list|)
value|( x / 14 )
end_define
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****            L A T I N   G L O B A L   M E T R I C S            *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/* Find segments and links, compute all stem widths, and initialize */
end_comment
begin_comment
comment|/* standard width and height for the glyph with given charcode.     */
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|af_latin_metrics_init_widths
name|af_latin_metrics_init_widths
argument_list|(
argument|AF_LatinMetrics  metrics
argument_list|,
argument|FT_Face          face
argument_list|)
end_macro
begin_block
block|{
comment|/* scan the array of segments in each direction */
name|AF_GlyphHintsRec
name|hints
index|[
literal|1
index|]
decl_stmt|;
name|FT_TRACE5
argument_list|(
operator|(
literal|"\n"
literal|"latin standard widths computation (style `%s')\n"
literal|"=====================================================\n"
literal|"\n"
operator|,
name|af_style_names
index|[
name|metrics
operator|->
name|root
operator|.
name|style_class
operator|->
name|style
index|]
operator|)
argument_list|)
expr_stmt|;
name|af_glyph_hints_init
argument_list|(
name|hints
argument_list|,
name|face
operator|->
name|memory
argument_list|)
expr_stmt|;
name|metrics
operator|->
name|axis
index|[
name|AF_DIMENSION_HORZ
index|]
operator|.
name|width_count
operator|=
literal|0
expr_stmt|;
name|metrics
operator|->
name|axis
index|[
name|AF_DIMENSION_VERT
index|]
operator|.
name|width_count
operator|=
literal|0
expr_stmt|;
block|{
name|FT_Error
name|error
decl_stmt|;
name|FT_ULong
name|glyph_index
decl_stmt|;
name|FT_Long
name|y_offset
decl_stmt|;
name|int
name|dim
decl_stmt|;
name|AF_LatinMetricsRec
name|dummy
index|[
literal|1
index|]
decl_stmt|;
name|AF_Scaler
name|scaler
init|=
operator|&
name|dummy
operator|->
name|root
operator|.
name|scaler
decl_stmt|;
ifdef|#
directive|ifdef
name|FT_CONFIG_OPTION_PIC
name|AF_FaceGlobals
name|globals
init|=
name|metrics
operator|->
name|root
operator|.
name|globals
decl_stmt|;
endif|#
directive|endif
name|AF_StyleClass
name|style_class
init|=
name|metrics
operator|->
name|root
operator|.
name|style_class
decl_stmt|;
name|AF_ScriptClass
name|script_class
init|=
name|AF_SCRIPT_CLASSES_GET
index|[
name|style_class
operator|->
name|script
index|]
decl_stmt|;
name|FT_UInt32
name|standard_char
decl_stmt|;
comment|/*        * We check more than a single standard character to catch features        * like `c2sc' (small caps from caps) that don't contain lowercase        * letters by definition, or other features that mainly operate on        * numerals.        */
name|standard_char
operator|=
name|script_class
operator|->
name|standard_char1
expr_stmt|;
name|af_get_char_index
argument_list|(
operator|&
name|metrics
operator|->
name|root
argument_list|,
name|standard_char
argument_list|,
operator|&
name|glyph_index
argument_list|,
operator|&
name|y_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|glyph_index
condition|)
block|{
if|if
condition|(
name|script_class
operator|->
name|standard_char2
condition|)
block|{
name|standard_char
operator|=
name|script_class
operator|->
name|standard_char2
expr_stmt|;
name|af_get_char_index
argument_list|(
operator|&
name|metrics
operator|->
name|root
argument_list|,
name|standard_char
argument_list|,
operator|&
name|glyph_index
argument_list|,
operator|&
name|y_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|glyph_index
condition|)
block|{
if|if
condition|(
name|script_class
operator|->
name|standard_char3
condition|)
block|{
name|standard_char
operator|=
name|script_class
operator|->
name|standard_char3
expr_stmt|;
name|af_get_char_index
argument_list|(
operator|&
name|metrics
operator|->
name|root
argument_list|,
name|standard_char
argument_list|,
operator|&
name|glyph_index
argument_list|,
operator|&
name|y_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|glyph_index
condition|)
goto|goto
name|Exit
goto|;
block|}
else|else
goto|goto
name|Exit
goto|;
block|}
block|}
else|else
goto|goto
name|Exit
goto|;
block|}
name|FT_TRACE5
argument_list|(
operator|(
literal|"standard character: U+%04lX (glyph index %d)\n"
operator|,
name|standard_char
operator|,
name|glyph_index
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|FT_Load_Glyph
argument_list|(
name|face
argument_list|,
name|glyph_index
argument_list|,
name|FT_LOAD_NO_SCALE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|face
operator|->
name|glyph
operator|->
name|outline
operator|.
name|n_points
operator|<=
literal|0
condition|)
goto|goto
name|Exit
goto|;
name|FT_ZERO
argument_list|(
name|dummy
argument_list|)
expr_stmt|;
name|dummy
operator|->
name|units_per_em
operator|=
name|metrics
operator|->
name|units_per_em
expr_stmt|;
name|scaler
operator|->
name|x_scale
operator|=
literal|0x10000L
expr_stmt|;
name|scaler
operator|->
name|y_scale
operator|=
literal|0x10000L
expr_stmt|;
name|scaler
operator|->
name|x_delta
operator|=
literal|0
expr_stmt|;
name|scaler
operator|->
name|y_delta
operator|=
literal|0
expr_stmt|;
name|scaler
operator|->
name|face
operator|=
name|face
expr_stmt|;
name|scaler
operator|->
name|render_mode
operator|=
name|FT_RENDER_MODE_NORMAL
expr_stmt|;
name|scaler
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|af_glyph_hints_rescale
argument_list|(
name|hints
argument_list|,
operator|(
name|AF_StyleMetrics
operator|)
name|dummy
argument_list|)
expr_stmt|;
name|error
operator|=
name|af_glyph_hints_reload
argument_list|(
name|hints
argument_list|,
operator|&
name|face
operator|->
name|glyph
operator|->
name|outline
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
for|for
control|(
name|dim
operator|=
literal|0
init|;
name|dim
operator|<
name|AF_DIMENSION_MAX
condition|;
name|dim
operator|++
control|)
block|{
name|AF_LatinAxis
name|axis
init|=
operator|&
name|metrics
operator|->
name|axis
index|[
name|dim
index|]
decl_stmt|;
name|AF_AxisHints
name|axhints
init|=
operator|&
name|hints
operator|->
name|axis
index|[
name|dim
index|]
decl_stmt|;
name|AF_Segment
name|seg
decl_stmt|,
name|limit
decl_stmt|,
name|link
decl_stmt|;
name|FT_UInt
name|num_widths
init|=
literal|0
decl_stmt|;
name|error
operator|=
name|af_latin_hints_compute_segments
argument_list|(
name|hints
argument_list|,
operator|(
name|AF_Dimension
operator|)
name|dim
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
comment|/*          *  We assume that the glyphs selected for the stem width          *  computation are `featureless' enough so that the linking          *  algorithm works fine without adjustments of its scoring          *  function.          */
name|af_latin_hints_link_segments
argument_list|(
name|hints
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|(
name|AF_Dimension
operator|)
name|dim
argument_list|)
expr_stmt|;
name|seg
operator|=
name|axhints
operator|->
name|segments
expr_stmt|;
name|limit
operator|=
name|seg
operator|+
name|axhints
operator|->
name|num_segments
expr_stmt|;
for|for
control|(
init|;
name|seg
operator|<
name|limit
condition|;
name|seg
operator|++
control|)
block|{
name|link
operator|=
name|seg
operator|->
name|link
expr_stmt|;
comment|/* we only consider stem segments there! */
if|if
condition|(
name|link
operator|&&
name|link
operator|->
name|link
operator|==
name|seg
operator|&&
name|link
operator|>
name|seg
condition|)
block|{
name|FT_Pos
name|dist
decl_stmt|;
name|dist
operator|=
name|seg
operator|->
name|pos
operator|-
name|link
operator|->
name|pos
expr_stmt|;
if|if
condition|(
name|dist
operator|<
literal|0
condition|)
name|dist
operator|=
operator|-
name|dist
expr_stmt|;
if|if
condition|(
name|num_widths
operator|<
name|AF_LATIN_MAX_WIDTHS
condition|)
name|axis
operator|->
name|widths
index|[
name|num_widths
operator|++
index|]
operator|.
name|org
operator|=
name|dist
expr_stmt|;
block|}
block|}
comment|/* this also replaces multiple almost identical stem widths */
comment|/* with a single one (the value 100 is heuristic)           */
name|af_sort_and_quantize_widths
argument_list|(
operator|&
name|num_widths
argument_list|,
name|axis
operator|->
name|widths
argument_list|,
name|dummy
operator|->
name|units_per_em
operator|/
literal|100
argument_list|)
expr_stmt|;
name|axis
operator|->
name|width_count
operator|=
name|num_widths
expr_stmt|;
block|}
name|Exit
label|:
for|for
control|(
name|dim
operator|=
literal|0
init|;
name|dim
operator|<
name|AF_DIMENSION_MAX
condition|;
name|dim
operator|++
control|)
block|{
name|AF_LatinAxis
name|axis
init|=
operator|&
name|metrics
operator|->
name|axis
index|[
name|dim
index|]
decl_stmt|;
name|FT_Pos
name|stdw
decl_stmt|;
name|stdw
operator|=
operator|(
name|axis
operator|->
name|width_count
operator|>
literal|0
operator|)
condition|?
name|axis
operator|->
name|widths
index|[
literal|0
index|]
operator|.
name|org
else|:
name|AF_LATIN_CONSTANT
argument_list|(
name|metrics
argument_list|,
literal|50
argument_list|)
expr_stmt|;
comment|/* let's try 20% of the smallest width */
name|axis
operator|->
name|edge_distance_threshold
operator|=
name|stdw
operator|/
literal|5
expr_stmt|;
name|axis
operator|->
name|standard_width
operator|=
name|stdw
expr_stmt|;
name|axis
operator|->
name|extra_light
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|FT_DEBUG_LEVEL_TRACE
block|{
name|FT_UInt
name|i
decl_stmt|;
name|FT_TRACE5
argument_list|(
operator|(
literal|"%s widths:\n"
operator|,
name|dim
operator|==
name|AF_DIMENSION_VERT
condition|?
literal|"horizontal"
else|:
literal|"vertical"
operator|)
argument_list|)
expr_stmt|;
name|FT_TRACE5
argument_list|(
operator|(
literal|"  %d (standard)"
operator|,
name|axis
operator|->
name|standard_width
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|axis
operator|->
name|width_count
condition|;
name|i
operator|++
control|)
name|FT_TRACE5
argument_list|(
operator|(
literal|" %d"
operator|,
name|axis
operator|->
name|widths
index|[
name|i
index|]
operator|.
name|org
operator|)
argument_list|)
expr_stmt|;
name|FT_TRACE5
argument_list|(
operator|(
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
name|FT_TRACE5
argument_list|(
operator|(
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
name|af_glyph_hints_done
argument_list|(
name|hints
argument_list|)
expr_stmt|;
block|}
end_block
begin_comment
comment|/* Find all blue zones.  Flat segments give the reference points, */
end_comment
begin_comment
comment|/* round segments the overshoot positions.                        */
end_comment
begin_function
specifier|static
name|void
DECL|function|af_latin_metrics_init_blues
name|af_latin_metrics_init_blues
parameter_list|(
name|AF_LatinMetrics
name|metrics
parameter_list|,
name|FT_Face
name|face
parameter_list|)
block|{
name|FT_Pos
name|flats
index|[
name|AF_BLUE_STRING_MAX_LEN
index|]
decl_stmt|;
name|FT_Pos
name|rounds
index|[
name|AF_BLUE_STRING_MAX_LEN
index|]
decl_stmt|;
name|FT_UInt
name|num_flats
decl_stmt|;
name|FT_UInt
name|num_rounds
decl_stmt|;
name|AF_LatinBlue
name|blue
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|AF_LatinAxis
name|axis
init|=
operator|&
name|metrics
operator|->
name|axis
index|[
name|AF_DIMENSION_VERT
index|]
decl_stmt|;
name|FT_Outline
name|outline
decl_stmt|;
name|AF_StyleClass
name|sc
init|=
name|metrics
operator|->
name|root
operator|.
name|style_class
decl_stmt|;
name|AF_Blue_Stringset
name|bss
init|=
name|sc
operator|->
name|blue_stringset
decl_stmt|;
specifier|const
name|AF_Blue_StringRec
modifier|*
name|bs
init|=
operator|&
name|af_blue_stringsets
index|[
name|bss
index|]
decl_stmt|;
name|FT_Pos
name|flat_threshold
init|=
name|FLAT_THRESHOLD
argument_list|(
name|metrics
operator|->
name|units_per_em
argument_list|)
decl_stmt|;
comment|/* we walk over the blue character strings as specified in the */
comment|/* style's entry in the `af_blue_stringset' array              */
name|FT_TRACE5
argument_list|(
operator|(
literal|"latin blue zones computation\n"
literal|"============================\n"
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|bs
operator|->
name|string
operator|!=
name|AF_BLUE_STRING_MAX
condition|;
name|bs
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|p
init|=
operator|&
name|af_blue_strings
index|[
name|bs
operator|->
name|string
index|]
decl_stmt|;
name|FT_Pos
modifier|*
name|blue_ref
decl_stmt|;
name|FT_Pos
modifier|*
name|blue_shoot
decl_stmt|;
ifdef|#
directive|ifdef
name|FT_DEBUG_LEVEL_TRACE
block|{
name|FT_Bool
name|have_flag
init|=
literal|0
decl_stmt|;
name|FT_TRACE5
argument_list|(
operator|(
literal|"blue zone %d"
operator|,
name|axis
operator|->
name|blue_count
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bs
operator|->
name|properties
condition|)
block|{
name|FT_TRACE5
argument_list|(
operator|(
literal|" ("
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|AF_LATIN_IS_TOP_BLUE
argument_list|(
name|bs
argument_list|)
condition|)
block|{
name|FT_TRACE5
argument_list|(
operator|(
literal|"top"
operator|)
argument_list|)
expr_stmt|;
name|have_flag
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|AF_LATIN_IS_NEUTRAL_BLUE
argument_list|(
name|bs
argument_list|)
condition|)
block|{
if|if
condition|(
name|have_flag
condition|)
name|FT_TRACE5
argument_list|(
operator|(
literal|", "
operator|)
argument_list|)
expr_stmt|;
name|FT_TRACE5
argument_list|(
operator|(
literal|"neutral"
operator|)
argument_list|)
expr_stmt|;
name|have_flag
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|AF_LATIN_IS_X_HEIGHT_BLUE
argument_list|(
name|bs
argument_list|)
condition|)
block|{
if|if
condition|(
name|have_flag
condition|)
name|FT_TRACE5
argument_list|(
operator|(
literal|", "
operator|)
argument_list|)
expr_stmt|;
name|FT_TRACE5
argument_list|(
operator|(
literal|"small top"
operator|)
argument_list|)
expr_stmt|;
name|have_flag
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|AF_LATIN_IS_LONG_BLUE
argument_list|(
name|bs
argument_list|)
condition|)
block|{
if|if
condition|(
name|have_flag
condition|)
name|FT_TRACE5
argument_list|(
operator|(
literal|", "
operator|)
argument_list|)
expr_stmt|;
name|FT_TRACE5
argument_list|(
operator|(
literal|"long"
operator|)
argument_list|)
expr_stmt|;
block|}
name|FT_TRACE5
argument_list|(
operator|(
literal|")"
operator|)
argument_list|)
expr_stmt|;
block|}
name|FT_TRACE5
argument_list|(
operator|(
literal|":\n"
operator|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* FT_DEBUG_LEVEL_TRACE */
name|num_flats
operator|=
literal|0
expr_stmt|;
name|num_rounds
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
name|FT_ULong
name|ch
decl_stmt|;
name|FT_ULong
name|glyph_index
decl_stmt|;
name|FT_Long
name|y_offset
decl_stmt|;
name|FT_Pos
name|best_y
decl_stmt|;
comment|/* same as points.y */
name|FT_Int
name|best_point
decl_stmt|,
name|best_contour_first
decl_stmt|,
name|best_contour_last
decl_stmt|;
name|FT_Vector
modifier|*
name|points
decl_stmt|;
name|FT_Bool
name|round
init|=
literal|0
decl_stmt|;
name|GET_UTF8_CHAR
argument_list|(
name|ch
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* load the character in the face -- skip unknown or empty ones */
name|af_get_char_index
argument_list|(
operator|&
name|metrics
operator|->
name|root
argument_list|,
name|ch
argument_list|,
operator|&
name|glyph_index
argument_list|,
operator|&
name|y_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|glyph_index
operator|==
literal|0
condition|)
block|{
name|FT_TRACE5
argument_list|(
operator|(
literal|"  U+%04lX unavailable\n"
operator|,
name|ch
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|error
operator|=
name|FT_Load_Glyph
argument_list|(
name|face
argument_list|,
name|glyph_index
argument_list|,
name|FT_LOAD_NO_SCALE
argument_list|)
expr_stmt|;
name|outline
operator|=
name|face
operator|->
name|glyph
operator|->
name|outline
expr_stmt|;
comment|/* reject glyphs that don't produce any rendering */
if|if
condition|(
name|error
operator|||
name|outline
operator|.
name|n_points
operator|<=
literal|2
condition|)
block|{
name|FT_TRACE5
argument_list|(
operator|(
literal|"  U+%04lX contains no (usable) outlines\n"
operator|,
name|ch
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* now compute min or max point indices and coordinates */
name|points
operator|=
name|outline
operator|.
name|points
expr_stmt|;
name|best_point
operator|=
operator|-
literal|1
expr_stmt|;
name|best_y
operator|=
literal|0
expr_stmt|;
comment|/* make compiler happy */
name|best_contour_first
operator|=
literal|0
expr_stmt|;
comment|/* ditto */
name|best_contour_last
operator|=
literal|0
expr_stmt|;
comment|/* ditto */
block|{
name|FT_Int
name|nn
decl_stmt|;
name|FT_Int
name|first
init|=
literal|0
decl_stmt|;
name|FT_Int
name|last
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|nn
operator|=
literal|0
init|;
name|nn
operator|<
name|outline
operator|.
name|n_contours
condition|;
name|first
operator|=
name|last
operator|+
literal|1
operator|,
name|nn
operator|++
control|)
block|{
name|FT_Int
name|old_best_point
init|=
name|best_point
decl_stmt|;
name|FT_Int
name|pp
decl_stmt|;
name|last
operator|=
name|outline
operator|.
name|contours
index|[
name|nn
index|]
expr_stmt|;
comment|/* Avoid single-point contours since they are never rasterized. */
comment|/* In some fonts, they correspond to mark attachment points     */
comment|/* that are way outside of the glyph's real outline.            */
if|if
condition|(
name|last
operator|<=
name|first
condition|)
continue|continue;
if|if
condition|(
name|AF_LATIN_IS_TOP_BLUE
argument_list|(
name|bs
argument_list|)
condition|)
block|{
for|for
control|(
name|pp
operator|=
name|first
init|;
name|pp
operator|<=
name|last
condition|;
name|pp
operator|++
control|)
if|if
condition|(
name|best_point
operator|<
literal|0
operator|||
name|points
index|[
name|pp
index|]
operator|.
name|y
operator|>
name|best_y
condition|)
block|{
name|best_point
operator|=
name|pp
expr_stmt|;
name|best_y
operator|=
name|points
index|[
name|pp
index|]
operator|.
name|y
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|pp
operator|=
name|first
init|;
name|pp
operator|<=
name|last
condition|;
name|pp
operator|++
control|)
if|if
condition|(
name|best_point
operator|<
literal|0
operator|||
name|points
index|[
name|pp
index|]
operator|.
name|y
operator|<
name|best_y
condition|)
block|{
name|best_point
operator|=
name|pp
expr_stmt|;
name|best_y
operator|=
name|points
index|[
name|pp
index|]
operator|.
name|y
expr_stmt|;
block|}
block|}
if|if
condition|(
name|best_point
operator|!=
name|old_best_point
condition|)
block|{
name|best_contour_first
operator|=
name|first
expr_stmt|;
name|best_contour_last
operator|=
name|last
expr_stmt|;
block|}
block|}
block|}
comment|/* now check whether the point belongs to a straight or round   */
comment|/* segment; we first need to find in which contour the extremum */
comment|/* lies, then inspect its previous and next points              */
if|if
condition|(
name|best_point
operator|>=
literal|0
condition|)
block|{
name|FT_Pos
name|best_x
init|=
name|points
index|[
name|best_point
index|]
operator|.
name|x
decl_stmt|;
name|FT_Int
name|prev
decl_stmt|,
name|next
decl_stmt|;
name|FT_Int
name|best_segment_first
decl_stmt|,
name|best_segment_last
decl_stmt|;
name|FT_Int
name|best_on_point_first
decl_stmt|,
name|best_on_point_last
decl_stmt|;
name|FT_Pos
name|dist
decl_stmt|;
name|best_segment_first
operator|=
name|best_point
expr_stmt|;
name|best_segment_last
operator|=
name|best_point
expr_stmt|;
if|if
condition|(
name|FT_CURVE_TAG
argument_list|(
name|outline
operator|.
name|tags
index|[
name|best_point
index|]
argument_list|)
operator|==
name|FT_CURVE_TAG_ON
condition|)
block|{
name|best_on_point_first
operator|=
name|best_point
expr_stmt|;
name|best_on_point_last
operator|=
name|best_point
expr_stmt|;
block|}
else|else
block|{
name|best_on_point_first
operator|=
operator|-
literal|1
expr_stmt|;
name|best_on_point_last
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* look for the previous and next points on the contour  */
comment|/* that are not on the same Y coordinate, then threshold */
comment|/* the `closeness'...                                    */
name|prev
operator|=
name|best_point
expr_stmt|;
name|next
operator|=
name|prev
expr_stmt|;
do|do
block|{
if|if
condition|(
name|prev
operator|>
name|best_contour_first
condition|)
name|prev
operator|--
expr_stmt|;
else|else
name|prev
operator|=
name|best_contour_last
expr_stmt|;
name|dist
operator|=
name|FT_ABS
argument_list|(
name|points
index|[
name|prev
index|]
operator|.
name|y
operator|-
name|best_y
argument_list|)
expr_stmt|;
comment|/* accept a small distance or a small angle (both values are */
comment|/* heuristic; value 20 corresponds to approx. 2.9 degrees)   */
if|if
condition|(
name|dist
operator|>
literal|5
condition|)
if|if
condition|(
name|FT_ABS
argument_list|(
name|points
index|[
name|prev
index|]
operator|.
name|x
operator|-
name|best_x
argument_list|)
operator|<=
literal|20
operator|*
name|dist
condition|)
break|break;
name|best_segment_first
operator|=
name|prev
expr_stmt|;
if|if
condition|(
name|FT_CURVE_TAG
argument_list|(
name|outline
operator|.
name|tags
index|[
name|prev
index|]
argument_list|)
operator|==
name|FT_CURVE_TAG_ON
condition|)
block|{
name|best_on_point_first
operator|=
name|prev
expr_stmt|;
if|if
condition|(
name|best_on_point_last
operator|<
literal|0
condition|)
name|best_on_point_last
operator|=
name|prev
expr_stmt|;
block|}
block|}
do|while
condition|(
name|prev
operator|!=
name|best_point
condition|)
do|;
do|do
block|{
if|if
condition|(
name|next
operator|<
name|best_contour_last
condition|)
name|next
operator|++
expr_stmt|;
else|else
name|next
operator|=
name|best_contour_first
expr_stmt|;
name|dist
operator|=
name|FT_ABS
argument_list|(
name|points
index|[
name|next
index|]
operator|.
name|y
operator|-
name|best_y
argument_list|)
expr_stmt|;
if|if
condition|(
name|dist
operator|>
literal|5
condition|)
if|if
condition|(
name|FT_ABS
argument_list|(
name|points
index|[
name|next
index|]
operator|.
name|x
operator|-
name|best_x
argument_list|)
operator|<=
literal|20
operator|*
name|dist
condition|)
break|break;
name|best_segment_last
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|FT_CURVE_TAG
argument_list|(
name|outline
operator|.
name|tags
index|[
name|next
index|]
argument_list|)
operator|==
name|FT_CURVE_TAG_ON
condition|)
block|{
name|best_on_point_last
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|best_on_point_first
operator|<
literal|0
condition|)
name|best_on_point_first
operator|=
name|next
expr_stmt|;
block|}
block|}
do|while
condition|(
name|next
operator|!=
name|best_point
condition|)
do|;
if|if
condition|(
name|AF_LATIN_IS_LONG_BLUE
argument_list|(
name|bs
argument_list|)
condition|)
block|{
comment|/* If this flag is set, we have an additional constraint to  */
comment|/* get the blue zone distance: Find a segment of the topmost */
comment|/* (or bottommost) contour that is longer than a heuristic   */
comment|/* threshold.  This ensures that small bumps in the outline  */
comment|/* are ignored (for example, the `vertical serifs' found in  */
comment|/* many Hebrew glyph designs).                               */
comment|/* If this segment is long enough, we are done.  Otherwise,  */
comment|/* search the segment next to the extremum that is long      */
comment|/* enough, has the same direction, and a not too large       */
comment|/* vertical distance from the extremum.  Note that the       */
comment|/* algorithm doesn't check whether the found segment is      */
comment|/* actually the one (vertically) nearest to the extremum.    */
comment|/* heuristic threshold value */
name|FT_Pos
name|length_threshold
init|=
name|metrics
operator|->
name|units_per_em
operator|/
literal|25
decl_stmt|;
name|dist
operator|=
name|FT_ABS
argument_list|(
name|points
index|[
name|best_segment_last
index|]
operator|.
name|x
operator|-
name|points
index|[
name|best_segment_first
index|]
operator|.
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|dist
operator|<
name|length_threshold
operator|&&
name|best_segment_last
operator|-
name|best_segment_first
operator|+
literal|2
operator|<=
name|best_contour_last
operator|-
name|best_contour_first
condition|)
block|{
comment|/* heuristic threshold value */
name|FT_Pos
name|height_threshold
init|=
name|metrics
operator|->
name|units_per_em
operator|/
literal|4
decl_stmt|;
name|FT_Int
name|first
decl_stmt|;
name|FT_Int
name|last
decl_stmt|;
name|FT_Bool
name|hit
decl_stmt|;
comment|/* we intentionally declare these two variables        */
comment|/* outside of the loop since various compilers emit    */
comment|/* incorrect warning messages otherwise, talking about */
comment|/* `possibly uninitialized variables'                  */
name|FT_Int
name|p_first
init|=
literal|0
decl_stmt|;
comment|/* make compiler happy */
name|FT_Int
name|p_last
init|=
literal|0
decl_stmt|;
name|FT_Bool
name|left2right
decl_stmt|;
comment|/* compute direction */
name|prev
operator|=
name|best_point
expr_stmt|;
do|do
block|{
if|if
condition|(
name|prev
operator|>
name|best_contour_first
condition|)
name|prev
operator|--
expr_stmt|;
else|else
name|prev
operator|=
name|best_contour_last
expr_stmt|;
if|if
condition|(
name|points
index|[
name|prev
index|]
operator|.
name|x
operator|!=
name|best_x
condition|)
break|break;
block|}
do|while
condition|(
name|prev
operator|!=
name|best_point
condition|)
do|;
comment|/* skip glyph for the degenerate case */
if|if
condition|(
name|prev
operator|==
name|best_point
condition|)
continue|continue;
name|left2right
operator|=
name|FT_BOOL
argument_list|(
name|points
index|[
name|prev
index|]
operator|.
name|x
operator|<
name|points
index|[
name|best_point
index|]
operator|.
name|x
argument_list|)
expr_stmt|;
name|first
operator|=
name|best_segment_last
expr_stmt|;
name|last
operator|=
name|first
expr_stmt|;
name|hit
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|FT_Bool
name|l2r
decl_stmt|;
name|FT_Pos
name|d
decl_stmt|;
if|if
condition|(
operator|!
name|hit
condition|)
block|{
comment|/* no hit; adjust first point */
name|first
operator|=
name|last
expr_stmt|;
comment|/* also adjust first and last on point */
if|if
condition|(
name|FT_CURVE_TAG
argument_list|(
name|outline
operator|.
name|tags
index|[
name|first
index|]
argument_list|)
operator|==
name|FT_CURVE_TAG_ON
condition|)
block|{
name|p_first
operator|=
name|first
expr_stmt|;
name|p_last
operator|=
name|first
expr_stmt|;
block|}
else|else
block|{
name|p_first
operator|=
operator|-
literal|1
expr_stmt|;
name|p_last
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|hit
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|last
operator|<
name|best_contour_last
condition|)
name|last
operator|++
expr_stmt|;
else|else
name|last
operator|=
name|best_contour_first
expr_stmt|;
if|if
condition|(
name|FT_ABS
argument_list|(
name|best_y
operator|-
name|points
index|[
name|first
index|]
operator|.
name|y
argument_list|)
operator|>
name|height_threshold
condition|)
block|{
comment|/* vertical distance too large */
name|hit
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
comment|/* same test as above */
name|dist
operator|=
name|FT_ABS
argument_list|(
name|points
index|[
name|last
index|]
operator|.
name|y
operator|-
name|points
index|[
name|first
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|dist
operator|>
literal|5
condition|)
if|if
condition|(
name|FT_ABS
argument_list|(
name|points
index|[
name|last
index|]
operator|.
name|x
operator|-
name|points
index|[
name|first
index|]
operator|.
name|x
argument_list|)
operator|<=
literal|20
operator|*
name|dist
condition|)
block|{
name|hit
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|FT_CURVE_TAG
argument_list|(
name|outline
operator|.
name|tags
index|[
name|last
index|]
argument_list|)
operator|==
name|FT_CURVE_TAG_ON
condition|)
block|{
name|p_last
operator|=
name|last
expr_stmt|;
if|if
condition|(
name|p_first
operator|<
literal|0
condition|)
name|p_first
operator|=
name|last
expr_stmt|;
block|}
name|l2r
operator|=
name|FT_BOOL
argument_list|(
name|points
index|[
name|first
index|]
operator|.
name|x
operator|<
name|points
index|[
name|last
index|]
operator|.
name|x
argument_list|)
expr_stmt|;
name|d
operator|=
name|FT_ABS
argument_list|(
name|points
index|[
name|last
index|]
operator|.
name|x
operator|-
name|points
index|[
name|first
index|]
operator|.
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|l2r
operator|==
name|left2right
operator|&&
name|d
operator|>=
name|length_threshold
condition|)
block|{
comment|/* all constraints are met; update segment after finding */
comment|/* its end                                               */
do|do
block|{
if|if
condition|(
name|last
operator|<
name|best_contour_last
condition|)
name|last
operator|++
expr_stmt|;
else|else
name|last
operator|=
name|best_contour_first
expr_stmt|;
name|d
operator|=
name|FT_ABS
argument_list|(
name|points
index|[
name|last
index|]
operator|.
name|y
operator|-
name|points
index|[
name|first
index|]
operator|.
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|>
literal|5
condition|)
if|if
condition|(
name|FT_ABS
argument_list|(
name|points
index|[
name|next
index|]
operator|.
name|x
operator|-
name|points
index|[
name|first
index|]
operator|.
name|x
argument_list|)
operator|<=
literal|20
operator|*
name|dist
condition|)
block|{
if|if
condition|(
name|last
operator|>
name|best_contour_first
condition|)
name|last
operator|--
expr_stmt|;
else|else
name|last
operator|=
name|best_contour_last
expr_stmt|;
break|break;
block|}
name|p_last
operator|=
name|last
expr_stmt|;
if|if
condition|(
name|FT_CURVE_TAG
argument_list|(
name|outline
operator|.
name|tags
index|[
name|last
index|]
argument_list|)
operator|==
name|FT_CURVE_TAG_ON
condition|)
block|{
name|p_last
operator|=
name|last
expr_stmt|;
if|if
condition|(
name|p_first
operator|<
literal|0
condition|)
name|p_first
operator|=
name|last
expr_stmt|;
block|}
block|}
do|while
condition|(
name|last
operator|!=
name|best_segment_first
condition|)
do|;
name|best_y
operator|=
name|points
index|[
name|first
index|]
operator|.
name|y
expr_stmt|;
name|best_segment_first
operator|=
name|first
expr_stmt|;
name|best_segment_last
operator|=
name|last
expr_stmt|;
name|best_on_point_first
operator|=
name|p_first
expr_stmt|;
name|best_on_point_last
operator|=
name|p_last
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|last
operator|!=
name|best_segment_first
condition|)
do|;
block|}
block|}
comment|/* for computing blue zones, we add the y offset as returned */
comment|/* by the currently used OpenType feature -- for example,    */
comment|/* superscript glyphs might be identical to subscript glyphs */
comment|/* with a vertical shift                                     */
name|best_y
operator|+=
name|y_offset
expr_stmt|;
name|FT_TRACE5
argument_list|(
operator|(
literal|"  U+%04lX: best_y = %5ld"
operator|,
name|ch
operator|,
name|best_y
operator|)
argument_list|)
expr_stmt|;
comment|/* now set the `round' flag depending on the segment's kind: */
comment|/*                                                           */
comment|/* - if the horizontal distance between the first and last   */
comment|/*   `on' point is larger than a heuristic threshold         */
comment|/*   we have a flat segment                                  */
comment|/* - if either the first or the last point of the segment is */
comment|/*   an `off' point, the segment is round, otherwise it is   */
comment|/*   flat                                                    */
if|if
condition|(
name|best_on_point_first
operator|>=
literal|0
operator|&&
name|best_on_point_last
operator|>=
literal|0
operator|&&
operator|(
name|FT_ABS
argument_list|(
name|points
index|[
name|best_on_point_last
index|]
operator|.
name|x
operator|-
name|points
index|[
name|best_on_point_first
index|]
operator|.
name|x
argument_list|)
operator|)
operator|>
name|flat_threshold
condition|)
name|round
operator|=
literal|0
expr_stmt|;
else|else
name|round
operator|=
name|FT_BOOL
argument_list|(
name|FT_CURVE_TAG
argument_list|(
name|outline
operator|.
name|tags
index|[
name|best_segment_first
index|]
argument_list|)
operator|!=
name|FT_CURVE_TAG_ON
operator|||
name|FT_CURVE_TAG
argument_list|(
name|outline
operator|.
name|tags
index|[
name|best_segment_last
index|]
argument_list|)
operator|!=
name|FT_CURVE_TAG_ON
argument_list|)
expr_stmt|;
if|if
condition|(
name|round
operator|&&
name|AF_LATIN_IS_NEUTRAL_BLUE
argument_list|(
name|bs
argument_list|)
condition|)
block|{
comment|/* only use flat segments for a neutral blue zone */
name|FT_TRACE5
argument_list|(
operator|(
literal|" (round, skipped)\n"
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|FT_TRACE5
argument_list|(
operator|(
literal|" (%s)\n"
operator|,
name|round
condition|?
literal|"round"
else|:
literal|"flat"
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|round
condition|)
name|rounds
index|[
name|num_rounds
operator|++
index|]
operator|=
name|best_y
expr_stmt|;
else|else
name|flats
index|[
name|num_flats
operator|++
index|]
operator|=
name|best_y
expr_stmt|;
block|}
if|if
condition|(
name|num_flats
operator|==
literal|0
operator|&&
name|num_rounds
operator|==
literal|0
condition|)
block|{
comment|/*          *  we couldn't find a single glyph to compute this blue zone,          *  we will simply ignore it then          */
name|FT_TRACE5
argument_list|(
operator|(
literal|"  empty\n"
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* we have computed the contents of the `rounds' and `flats' tables, */
comment|/* now determine the reference and overshoot position of the blue -- */
comment|/* we simply take the median value after a simple sort               */
name|af_sort_pos
argument_list|(
name|num_rounds
argument_list|,
name|rounds
argument_list|)
expr_stmt|;
name|af_sort_pos
argument_list|(
name|num_flats
argument_list|,
name|flats
argument_list|)
expr_stmt|;
name|blue
operator|=
operator|&
name|axis
operator|->
name|blues
index|[
name|axis
operator|->
name|blue_count
index|]
expr_stmt|;
name|blue_ref
operator|=
operator|&
name|blue
operator|->
name|ref
operator|.
name|org
expr_stmt|;
name|blue_shoot
operator|=
operator|&
name|blue
operator|->
name|shoot
operator|.
name|org
expr_stmt|;
name|axis
operator|->
name|blue_count
operator|++
expr_stmt|;
if|if
condition|(
name|num_flats
operator|==
literal|0
condition|)
block|{
operator|*
name|blue_ref
operator|=
operator|*
name|blue_shoot
operator|=
name|rounds
index|[
name|num_rounds
operator|/
literal|2
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|num_rounds
operator|==
literal|0
condition|)
block|{
operator|*
name|blue_ref
operator|=
operator|*
name|blue_shoot
operator|=
name|flats
index|[
name|num_flats
operator|/
literal|2
index|]
expr_stmt|;
block|}
else|else
block|{
operator|*
name|blue_ref
operator|=
name|flats
index|[
name|num_flats
operator|/
literal|2
index|]
expr_stmt|;
operator|*
name|blue_shoot
operator|=
name|rounds
index|[
name|num_rounds
operator|/
literal|2
index|]
expr_stmt|;
block|}
comment|/* there are sometimes problems: if the overshoot position of top     */
comment|/* zones is under its reference position, or the opposite for bottom  */
comment|/* zones.  We must thus check everything there and correct the errors */
if|if
condition|(
operator|*
name|blue_shoot
operator|!=
operator|*
name|blue_ref
condition|)
block|{
name|FT_Pos
name|ref
init|=
operator|*
name|blue_ref
decl_stmt|;
name|FT_Pos
name|shoot
init|=
operator|*
name|blue_shoot
decl_stmt|;
name|FT_Bool
name|over_ref
init|=
name|FT_BOOL
argument_list|(
name|shoot
operator|>
name|ref
argument_list|)
decl_stmt|;
if|if
condition|(
name|AF_LATIN_IS_TOP_BLUE
argument_list|(
name|bs
argument_list|)
operator|^
name|over_ref
condition|)
block|{
operator|*
name|blue_ref
operator|=
operator|*
name|blue_shoot
operator|=
operator|(
name|shoot
operator|+
name|ref
operator|)
operator|/
literal|2
expr_stmt|;
name|FT_TRACE5
argument_list|(
operator|(
literal|"  [overshoot smaller than reference,"
literal|" taking mean value]\n"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
name|blue
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|AF_LATIN_IS_TOP_BLUE
argument_list|(
name|bs
argument_list|)
condition|)
name|blue
operator|->
name|flags
operator||=
name|AF_LATIN_BLUE_TOP
expr_stmt|;
if|if
condition|(
name|AF_LATIN_IS_NEUTRAL_BLUE
argument_list|(
name|bs
argument_list|)
condition|)
name|blue
operator|->
name|flags
operator||=
name|AF_LATIN_BLUE_NEUTRAL
expr_stmt|;
comment|/*        * The following flag is used later to adjust the y and x scales        * in order to optimize the pixel grid alignment of the top of small        * letters.        */
if|if
condition|(
name|AF_LATIN_IS_X_HEIGHT_BLUE
argument_list|(
name|bs
argument_list|)
condition|)
name|blue
operator|->
name|flags
operator||=
name|AF_LATIN_BLUE_ADJUSTMENT
expr_stmt|;
name|FT_TRACE5
argument_list|(
operator|(
literal|"    -> reference = %ld\n"
literal|"       overshoot = %ld\n"
operator|,
operator|*
name|blue_ref
operator|,
operator|*
name|blue_shoot
operator|)
argument_list|)
expr_stmt|;
block|}
name|FT_TRACE5
argument_list|(
operator|(
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function
begin_comment
comment|/* Check whether all ASCII digits have the same advance width. */
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|af_latin_metrics_check_digits
name|af_latin_metrics_check_digits
argument_list|(
argument|AF_LatinMetrics  metrics
argument_list|,
argument|FT_Face          face
argument_list|)
end_macro
begin_block
block|{
name|FT_UInt
name|i
decl_stmt|;
name|FT_Bool
name|started
init|=
literal|0
decl_stmt|,
name|same_width
init|=
literal|1
decl_stmt|;
name|FT_Fixed
name|advance
decl_stmt|,
name|old_advance
init|=
literal|0
decl_stmt|;
comment|/* digit `0' is 0x30 in all supported charmaps */
for|for
control|(
name|i
operator|=
literal|0x30
init|;
name|i
operator|<=
literal|0x39
condition|;
name|i
operator|++
control|)
block|{
name|FT_ULong
name|glyph_index
decl_stmt|;
name|FT_Long
name|y_offset
decl_stmt|;
name|af_get_char_index
argument_list|(
operator|&
name|metrics
operator|->
name|root
argument_list|,
name|i
argument_list|,
operator|&
name|glyph_index
argument_list|,
operator|&
name|y_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|glyph_index
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|FT_Get_Advance
argument_list|(
name|face
argument_list|,
name|glyph_index
argument_list|,
name|FT_LOAD_NO_SCALE
operator||
name|FT_LOAD_NO_HINTING
operator||
name|FT_LOAD_IGNORE_TRANSFORM
argument_list|,
operator|&
name|advance
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|started
condition|)
block|{
if|if
condition|(
name|advance
operator|!=
name|old_advance
condition|)
block|{
name|same_width
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|old_advance
operator|=
name|advance
expr_stmt|;
name|started
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|metrics
operator|->
name|root
operator|.
name|digits_have_same_width
operator|=
name|same_width
expr_stmt|;
block|}
end_block
begin_comment
comment|/* Initialize global metrics. */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|af_latin_metrics_init
argument_list|(
argument|AF_LatinMetrics  metrics
argument_list|,
argument|FT_Face          face
argument_list|)
end_macro
begin_block
block|{
name|FT_CharMap
name|oldmap
init|=
name|face
operator|->
name|charmap
decl_stmt|;
name|metrics
operator|->
name|units_per_em
operator|=
name|face
operator|->
name|units_per_EM
expr_stmt|;
if|if
condition|(
operator|!
name|FT_Select_Charmap
argument_list|(
name|face
argument_list|,
name|FT_ENCODING_UNICODE
argument_list|)
condition|)
block|{
name|af_latin_metrics_init_widths
argument_list|(
name|metrics
argument_list|,
name|face
argument_list|)
expr_stmt|;
name|af_latin_metrics_init_blues
argument_list|(
name|metrics
argument_list|,
name|face
argument_list|)
expr_stmt|;
name|af_latin_metrics_check_digits
argument_list|(
name|metrics
argument_list|,
name|face
argument_list|)
expr_stmt|;
block|}
name|FT_Set_Charmap
argument_list|(
name|face
argument_list|,
name|oldmap
argument_list|)
expr_stmt|;
return|return
name|FT_Err_Ok
return|;
block|}
end_block
begin_comment
comment|/* Adjust scaling value, then scale and shift widths   */
end_comment
begin_comment
comment|/* and blue zones (if applicable) for given dimension. */
end_comment
begin_function
specifier|static
name|void
DECL|function|af_latin_metrics_scale_dim
name|af_latin_metrics_scale_dim
parameter_list|(
name|AF_LatinMetrics
name|metrics
parameter_list|,
name|AF_Scaler
name|scaler
parameter_list|,
name|AF_Dimension
name|dim
parameter_list|)
block|{
name|FT_Fixed
name|scale
decl_stmt|;
name|FT_Pos
name|delta
decl_stmt|;
name|AF_LatinAxis
name|axis
decl_stmt|;
name|FT_UInt
name|nn
decl_stmt|;
if|if
condition|(
name|dim
operator|==
name|AF_DIMENSION_HORZ
condition|)
block|{
name|scale
operator|=
name|scaler
operator|->
name|x_scale
expr_stmt|;
name|delta
operator|=
name|scaler
operator|->
name|x_delta
expr_stmt|;
block|}
else|else
block|{
name|scale
operator|=
name|scaler
operator|->
name|y_scale
expr_stmt|;
name|delta
operator|=
name|scaler
operator|->
name|y_delta
expr_stmt|;
block|}
name|axis
operator|=
operator|&
name|metrics
operator|->
name|axis
index|[
name|dim
index|]
expr_stmt|;
if|if
condition|(
name|axis
operator|->
name|org_scale
operator|==
name|scale
operator|&&
name|axis
operator|->
name|org_delta
operator|==
name|delta
condition|)
return|return;
name|axis
operator|->
name|org_scale
operator|=
name|scale
expr_stmt|;
name|axis
operator|->
name|org_delta
operator|=
name|delta
expr_stmt|;
comment|/*      * correct X and Y scale to optimize the alignment of the top of small      * letters to the pixel grid      */
block|{
name|AF_LatinAxis
name|Axis
init|=
operator|&
name|metrics
operator|->
name|axis
index|[
name|AF_DIMENSION_VERT
index|]
decl_stmt|;
name|AF_LatinBlue
name|blue
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|nn
operator|=
literal|0
init|;
name|nn
operator|<
name|Axis
operator|->
name|blue_count
condition|;
name|nn
operator|++
control|)
block|{
if|if
condition|(
name|Axis
operator|->
name|blues
index|[
name|nn
index|]
operator|.
name|flags
operator|&
name|AF_LATIN_BLUE_ADJUSTMENT
condition|)
block|{
name|blue
operator|=
operator|&
name|Axis
operator|->
name|blues
index|[
name|nn
index|]
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|blue
condition|)
block|{
name|FT_Pos
name|scaled
decl_stmt|;
name|FT_Pos
name|threshold
decl_stmt|;
name|FT_Pos
name|fitted
decl_stmt|;
name|FT_UInt
name|limit
decl_stmt|;
name|FT_UInt
name|ppem
decl_stmt|;
name|scaled
operator|=
name|FT_MulFix
argument_list|(
name|blue
operator|->
name|shoot
operator|.
name|org
argument_list|,
name|scaler
operator|->
name|y_scale
argument_list|)
expr_stmt|;
name|ppem
operator|=
name|metrics
operator|->
name|root
operator|.
name|scaler
operator|.
name|face
operator|->
name|size
operator|->
name|metrics
operator|.
name|x_ppem
expr_stmt|;
name|limit
operator|=
name|metrics
operator|->
name|root
operator|.
name|globals
operator|->
name|increase_x_height
expr_stmt|;
name|threshold
operator|=
literal|40
expr_stmt|;
comment|/* if the `increase-x-height' property is active, */
comment|/* we round up much more often                    */
if|if
condition|(
name|limit
operator|&&
name|ppem
operator|<=
name|limit
operator|&&
name|ppem
operator|>=
name|AF_PROP_INCREASE_X_HEIGHT_MIN
condition|)
name|threshold
operator|=
literal|52
expr_stmt|;
name|fitted
operator|=
operator|(
name|scaled
operator|+
name|threshold
operator|)
operator|&
operator|~
literal|63
expr_stmt|;
if|if
condition|(
name|scaled
operator|!=
name|fitted
condition|)
block|{
if|#
directive|if
literal|0
block|if ( dim == AF_DIMENSION_HORZ )           {             if ( fitted< scaled )               scale -= scale / 50;
comment|/* scale *= 0.98 */
block|}           else
endif|#
directive|endif
if|if
condition|(
name|dim
operator|==
name|AF_DIMENSION_VERT
condition|)
block|{
name|scale
operator|=
name|FT_MulDiv
argument_list|(
name|scale
argument_list|,
name|fitted
argument_list|,
name|scaled
argument_list|)
expr_stmt|;
name|FT_TRACE5
argument_list|(
operator|(
literal|"af_latin_metrics_scale_dim:"
literal|" x height alignment (style `%s'):\n"
literal|"                           "
literal|" vertical scaling changed from %.4f to %.4f (by %d%%)\n"
literal|"\n"
operator|,
name|af_style_names
index|[
name|metrics
operator|->
name|root
operator|.
name|style_class
operator|->
name|style
index|]
operator|,
name|axis
operator|->
name|org_scale
operator|/
literal|65536.0
operator|,
name|scale
operator|/
literal|65536.0
operator|,
operator|(
name|fitted
operator|-
name|scaled
operator|)
operator|*
literal|100
operator|/
name|scaled
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|axis
operator|->
name|scale
operator|=
name|scale
expr_stmt|;
name|axis
operator|->
name|delta
operator|=
name|delta
expr_stmt|;
if|if
condition|(
name|dim
operator|==
name|AF_DIMENSION_HORZ
condition|)
block|{
name|metrics
operator|->
name|root
operator|.
name|scaler
operator|.
name|x_scale
operator|=
name|scale
expr_stmt|;
name|metrics
operator|->
name|root
operator|.
name|scaler
operator|.
name|x_delta
operator|=
name|delta
expr_stmt|;
block|}
else|else
block|{
name|metrics
operator|->
name|root
operator|.
name|scaler
operator|.
name|y_scale
operator|=
name|scale
expr_stmt|;
name|metrics
operator|->
name|root
operator|.
name|scaler
operator|.
name|y_delta
operator|=
name|delta
expr_stmt|;
block|}
name|FT_TRACE5
argument_list|(
operator|(
literal|"%s widths (style `%s')\n"
operator|,
name|dim
operator|==
name|AF_DIMENSION_HORZ
condition|?
literal|"horizontal"
else|:
literal|"vertical"
operator|,
name|af_style_names
index|[
name|metrics
operator|->
name|root
operator|.
name|style_class
operator|->
name|style
index|]
operator|)
argument_list|)
expr_stmt|;
comment|/* scale the widths */
for|for
control|(
name|nn
operator|=
literal|0
init|;
name|nn
operator|<
name|axis
operator|->
name|width_count
condition|;
name|nn
operator|++
control|)
block|{
name|AF_Width
name|width
init|=
name|axis
operator|->
name|widths
operator|+
name|nn
decl_stmt|;
name|width
operator|->
name|cur
operator|=
name|FT_MulFix
argument_list|(
name|width
operator|->
name|org
argument_list|,
name|scale
argument_list|)
expr_stmt|;
name|width
operator|->
name|fit
operator|=
name|width
operator|->
name|cur
expr_stmt|;
name|FT_TRACE5
argument_list|(
operator|(
literal|"  %d scaled to %.2f\n"
operator|,
name|width
operator|->
name|org
operator|,
name|width
operator|->
name|cur
operator|/
literal|64.0
operator|)
argument_list|)
expr_stmt|;
block|}
name|FT_TRACE5
argument_list|(
operator|(
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* an extra-light axis corresponds to a standard width that is */
comment|/* smaller than 5/8 pixels                                     */
name|axis
operator|->
name|extra_light
operator|=
call|(
name|FT_Bool
call|)
argument_list|(
name|FT_MulFix
argument_list|(
name|axis
operator|->
name|standard_width
argument_list|,
name|scale
argument_list|)
operator|<
literal|32
operator|+
literal|8
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FT_DEBUG_LEVEL_TRACE
if|if
condition|(
name|axis
operator|->
name|extra_light
condition|)
name|FT_TRACE5
argument_list|(
operator|(
literal|"`%s' style is extra light (at current resolution)\n"
literal|"\n"
operator|,
name|af_style_names
index|[
name|metrics
operator|->
name|root
operator|.
name|style_class
operator|->
name|style
index|]
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|dim
operator|==
name|AF_DIMENSION_VERT
condition|)
block|{
ifdef|#
directive|ifdef
name|FT_DEBUG_LEVEL_TRACE
if|if
condition|(
name|axis
operator|->
name|blue_count
condition|)
name|FT_TRACE5
argument_list|(
operator|(
literal|"blue zones (style `%s')\n"
operator|,
name|af_style_names
index|[
name|metrics
operator|->
name|root
operator|.
name|style_class
operator|->
name|style
index|]
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* scale the blue zones */
for|for
control|(
name|nn
operator|=
literal|0
init|;
name|nn
operator|<
name|axis
operator|->
name|blue_count
condition|;
name|nn
operator|++
control|)
block|{
name|AF_LatinBlue
name|blue
init|=
operator|&
name|axis
operator|->
name|blues
index|[
name|nn
index|]
decl_stmt|;
name|FT_Pos
name|dist
decl_stmt|;
name|blue
operator|->
name|ref
operator|.
name|cur
operator|=
name|FT_MulFix
argument_list|(
name|blue
operator|->
name|ref
operator|.
name|org
argument_list|,
name|scale
argument_list|)
operator|+
name|delta
expr_stmt|;
name|blue
operator|->
name|ref
operator|.
name|fit
operator|=
name|blue
operator|->
name|ref
operator|.
name|cur
expr_stmt|;
name|blue
operator|->
name|shoot
operator|.
name|cur
operator|=
name|FT_MulFix
argument_list|(
name|blue
operator|->
name|shoot
operator|.
name|org
argument_list|,
name|scale
argument_list|)
operator|+
name|delta
expr_stmt|;
name|blue
operator|->
name|shoot
operator|.
name|fit
operator|=
name|blue
operator|->
name|shoot
operator|.
name|cur
expr_stmt|;
name|blue
operator|->
name|flags
operator|&=
operator|~
name|AF_LATIN_BLUE_ACTIVE
expr_stmt|;
comment|/* a blue zone is only active if it is less than 3/4 pixels tall */
name|dist
operator|=
name|FT_MulFix
argument_list|(
name|blue
operator|->
name|ref
operator|.
name|org
operator|-
name|blue
operator|->
name|shoot
operator|.
name|org
argument_list|,
name|scale
argument_list|)
expr_stmt|;
if|if
condition|(
name|dist
operator|<=
literal|48
operator|&&
name|dist
operator|>=
operator|-
literal|48
condition|)
block|{
if|#
directive|if
literal|0
block|FT_Pos  delta1;
endif|#
directive|endif
name|FT_Pos
name|delta2
decl_stmt|;
comment|/* use discrete values for blue zone widths */
if|#
directive|if
literal|0
comment|/* generic, original code */
block|delta1 = blue->shoot.org - blue->ref.org;           delta2 = delta1;           if ( delta1< 0 )             delta2 = -delta2;            delta2 = FT_MulFix( delta2, scale );            if ( delta2< 32 )             delta2 = 0;           else if ( delta2< 64 )             delta2 = 32 + ( ( ( delta2 - 32 ) + 16 )& ~31 );           else             delta2 = FT_PIX_ROUND( delta2 );            if ( delta1< 0 )             delta2 = -delta2;            blue->ref.fit   = FT_PIX_ROUND( blue->ref.cur );           blue->shoot.fit = blue->ref.fit + delta2;
else|#
directive|else
comment|/* simplified version due to abs(dist)<= 48 */
name|delta2
operator|=
name|dist
expr_stmt|;
if|if
condition|(
name|dist
operator|<
literal|0
condition|)
name|delta2
operator|=
operator|-
name|delta2
expr_stmt|;
if|if
condition|(
name|delta2
operator|<
literal|32
condition|)
name|delta2
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|delta2
operator|<
literal|48
condition|)
name|delta2
operator|=
literal|32
expr_stmt|;
else|else
name|delta2
operator|=
literal|64
expr_stmt|;
if|if
condition|(
name|dist
operator|<
literal|0
condition|)
name|delta2
operator|=
operator|-
name|delta2
expr_stmt|;
name|blue
operator|->
name|ref
operator|.
name|fit
operator|=
name|FT_PIX_ROUND
argument_list|(
name|blue
operator|->
name|ref
operator|.
name|cur
argument_list|)
expr_stmt|;
name|blue
operator|->
name|shoot
operator|.
name|fit
operator|=
name|blue
operator|->
name|ref
operator|.
name|fit
operator|-
name|delta2
expr_stmt|;
endif|#
directive|endif
name|blue
operator|->
name|flags
operator||=
name|AF_LATIN_BLUE_ACTIVE
expr_stmt|;
name|FT_TRACE5
argument_list|(
operator|(
literal|"  reference %d: %d scaled to %.2f%s\n"
literal|"  overshoot %d: %d scaled to %.2f%s\n"
operator|,
name|nn
operator|,
name|blue
operator|->
name|ref
operator|.
name|org
operator|,
name|blue
operator|->
name|ref
operator|.
name|fit
operator|/
literal|64.0
operator|,
name|blue
operator|->
name|flags
operator|&
name|AF_LATIN_BLUE_ACTIVE
condition|?
literal|""
else|:
literal|" (inactive)"
operator|,
name|nn
operator|,
name|blue
operator|->
name|shoot
operator|.
name|org
operator|,
name|blue
operator|->
name|shoot
operator|.
name|fit
operator|/
literal|64.0
operator|,
name|blue
operator|->
name|flags
operator|&
name|AF_LATIN_BLUE_ACTIVE
condition|?
literal|""
else|:
literal|" (inactive)"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_comment
comment|/* Scale global values in both directions. */
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|af_latin_metrics_scale
name|af_latin_metrics_scale
argument_list|(
argument|AF_LatinMetrics  metrics
argument_list|,
argument|AF_Scaler        scaler
argument_list|)
end_macro
begin_block
block|{
name|metrics
operator|->
name|root
operator|.
name|scaler
operator|.
name|render_mode
operator|=
name|scaler
operator|->
name|render_mode
expr_stmt|;
name|metrics
operator|->
name|root
operator|.
name|scaler
operator|.
name|face
operator|=
name|scaler
operator|->
name|face
expr_stmt|;
name|metrics
operator|->
name|root
operator|.
name|scaler
operator|.
name|flags
operator|=
name|scaler
operator|->
name|flags
expr_stmt|;
name|af_latin_metrics_scale_dim
argument_list|(
name|metrics
argument_list|,
name|scaler
argument_list|,
name|AF_DIMENSION_HORZ
argument_list|)
expr_stmt|;
name|af_latin_metrics_scale_dim
argument_list|(
name|metrics
argument_list|,
name|scaler
argument_list|,
name|AF_DIMENSION_VERT
argument_list|)
expr_stmt|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****           L A T I N   G L Y P H   A N A L Y S I S             *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/* Walk over all contours and compute its segments. */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|af_latin_hints_compute_segments
argument_list|(
argument|AF_GlyphHints  hints
argument_list|,
argument|AF_Dimension   dim
argument_list|)
end_macro
begin_block
block|{
name|AF_LatinMetrics
name|metrics
init|=
operator|(
name|AF_LatinMetrics
operator|)
name|hints
operator|->
name|metrics
decl_stmt|;
name|AF_AxisHints
name|axis
init|=
operator|&
name|hints
operator|->
name|axis
index|[
name|dim
index|]
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|hints
operator|->
name|memory
decl_stmt|;
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
name|AF_Segment
name|segment
init|=
name|NULL
decl_stmt|;
name|AF_SegmentRec
name|seg0
decl_stmt|;
name|AF_Point
modifier|*
name|contour
init|=
name|hints
operator|->
name|contours
decl_stmt|;
name|AF_Point
modifier|*
name|contour_limit
init|=
name|contour
operator|+
name|hints
operator|->
name|num_contours
decl_stmt|;
name|AF_Direction
name|major_dir
decl_stmt|,
name|segment_dir
decl_stmt|;
name|FT_Pos
name|flat_threshold
init|=
name|FLAT_THRESHOLD
argument_list|(
name|metrics
operator|->
name|units_per_em
argument_list|)
decl_stmt|;
name|FT_ZERO
argument_list|(
operator|&
name|seg0
argument_list|)
expr_stmt|;
name|seg0
operator|.
name|score
operator|=
literal|32000
expr_stmt|;
name|seg0
operator|.
name|flags
operator|=
name|AF_EDGE_NORMAL
expr_stmt|;
name|major_dir
operator|=
operator|(
name|AF_Direction
operator|)
name|FT_ABS
argument_list|(
name|axis
operator|->
name|major_dir
argument_list|)
expr_stmt|;
name|segment_dir
operator|=
name|major_dir
expr_stmt|;
name|axis
operator|->
name|num_segments
operator|=
literal|0
expr_stmt|;
comment|/* set up (u,v) in each point */
if|if
condition|(
name|dim
operator|==
name|AF_DIMENSION_HORZ
condition|)
block|{
name|AF_Point
name|point
init|=
name|hints
operator|->
name|points
decl_stmt|;
name|AF_Point
name|limit
init|=
name|point
operator|+
name|hints
operator|->
name|num_points
decl_stmt|;
for|for
control|(
init|;
name|point
operator|<
name|limit
condition|;
name|point
operator|++
control|)
block|{
name|point
operator|->
name|u
operator|=
name|point
operator|->
name|fx
expr_stmt|;
name|point
operator|->
name|v
operator|=
name|point
operator|->
name|fy
expr_stmt|;
block|}
block|}
else|else
block|{
name|AF_Point
name|point
init|=
name|hints
operator|->
name|points
decl_stmt|;
name|AF_Point
name|limit
init|=
name|point
operator|+
name|hints
operator|->
name|num_points
decl_stmt|;
for|for
control|(
init|;
name|point
operator|<
name|limit
condition|;
name|point
operator|++
control|)
block|{
name|point
operator|->
name|u
operator|=
name|point
operator|->
name|fy
expr_stmt|;
name|point
operator|->
name|v
operator|=
name|point
operator|->
name|fx
expr_stmt|;
block|}
block|}
comment|/* do each contour separately */
for|for
control|(
init|;
name|contour
operator|<
name|contour_limit
condition|;
name|contour
operator|++
control|)
block|{
name|AF_Point
name|point
init|=
name|contour
index|[
literal|0
index|]
decl_stmt|;
name|AF_Point
name|last
init|=
name|point
operator|->
name|prev
decl_stmt|;
name|int
name|on_edge
init|=
literal|0
decl_stmt|;
name|FT_Pos
name|min_pos
init|=
literal|32000
decl_stmt|;
comment|/* minimum segment pos != min_coord */
name|FT_Pos
name|max_pos
init|=
operator|-
literal|32000
decl_stmt|;
comment|/* maximum segment pos != max_coord */
name|FT_Pos
name|min_on_pos
init|=
literal|32000
decl_stmt|;
name|FT_Pos
name|max_on_pos
init|=
operator|-
literal|32000
decl_stmt|;
name|FT_Bool
name|passed
decl_stmt|;
if|if
condition|(
name|point
operator|==
name|last
condition|)
comment|/* skip singletons -- just in case */
continue|continue;
if|if
condition|(
name|FT_ABS
argument_list|(
name|last
operator|->
name|out_dir
argument_list|)
operator|==
name|major_dir
operator|&&
name|FT_ABS
argument_list|(
name|point
operator|->
name|out_dir
argument_list|)
operator|==
name|major_dir
condition|)
block|{
comment|/* we are already on an edge, try to locate its start */
name|last
operator|=
name|point
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|point
operator|=
name|point
operator|->
name|prev
expr_stmt|;
if|if
condition|(
name|FT_ABS
argument_list|(
name|point
operator|->
name|out_dir
argument_list|)
operator|!=
name|major_dir
condition|)
block|{
name|point
operator|=
name|point
operator|->
name|next
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|point
operator|==
name|last
condition|)
break|break;
block|}
block|}
name|last
operator|=
name|point
expr_stmt|;
name|passed
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|FT_Pos
name|u
decl_stmt|,
name|v
decl_stmt|;
if|if
condition|(
name|on_edge
condition|)
block|{
name|u
operator|=
name|point
operator|->
name|u
expr_stmt|;
if|if
condition|(
name|u
operator|<
name|min_pos
condition|)
name|min_pos
operator|=
name|u
expr_stmt|;
if|if
condition|(
name|u
operator|>
name|max_pos
condition|)
name|max_pos
operator|=
name|u
expr_stmt|;
comment|/* get minimum and maximum coordinate of on points */
if|if
condition|(
operator|!
operator|(
name|point
operator|->
name|flags
operator|&
name|AF_FLAG_CONTROL
operator|)
condition|)
block|{
name|v
operator|=
name|point
operator|->
name|v
expr_stmt|;
if|if
condition|(
name|v
operator|<
name|min_on_pos
condition|)
name|min_on_pos
operator|=
name|v
expr_stmt|;
if|if
condition|(
name|v
operator|>
name|max_on_pos
condition|)
name|max_on_pos
operator|=
name|v
expr_stmt|;
block|}
if|if
condition|(
name|point
operator|->
name|out_dir
operator|!=
name|segment_dir
operator|||
name|point
operator|==
name|last
condition|)
block|{
comment|/* we are just leaving an edge; record a new segment! */
name|segment
operator|->
name|last
operator|=
name|point
expr_stmt|;
name|segment
operator|->
name|pos
operator|=
call|(
name|FT_Short
call|)
argument_list|(
operator|(
name|min_pos
operator|+
name|max_pos
operator|)
operator|>>
literal|1
argument_list|)
expr_stmt|;
comment|/* a segment is round if either its first or last point */
comment|/* is a control point, and the length of the on points  */
comment|/* inbetween doesn't exceed a heuristic limit           */
if|if
condition|(
operator|(
name|segment
operator|->
name|first
operator|->
name|flags
operator||
name|point
operator|->
name|flags
operator|)
operator|&
name|AF_FLAG_CONTROL
operator|&&
operator|(
name|max_on_pos
operator|-
name|min_on_pos
operator|)
operator|<
name|flat_threshold
condition|)
name|segment
operator|->
name|flags
operator||=
name|AF_EDGE_ROUND
expr_stmt|;
comment|/* compute segment size */
name|min_pos
operator|=
name|max_pos
operator|=
name|point
operator|->
name|v
expr_stmt|;
name|v
operator|=
name|segment
operator|->
name|first
operator|->
name|v
expr_stmt|;
if|if
condition|(
name|v
operator|<
name|min_pos
condition|)
name|min_pos
operator|=
name|v
expr_stmt|;
if|if
condition|(
name|v
operator|>
name|max_pos
condition|)
name|max_pos
operator|=
name|v
expr_stmt|;
name|segment
operator|->
name|min_coord
operator|=
operator|(
name|FT_Short
operator|)
name|min_pos
expr_stmt|;
name|segment
operator|->
name|max_coord
operator|=
operator|(
name|FT_Short
operator|)
name|max_pos
expr_stmt|;
name|segment
operator|->
name|height
operator|=
call|(
name|FT_Short
call|)
argument_list|(
name|segment
operator|->
name|max_coord
operator|-
name|segment
operator|->
name|min_coord
argument_list|)
expr_stmt|;
name|on_edge
operator|=
literal|0
expr_stmt|;
name|segment
operator|=
name|NULL
expr_stmt|;
comment|/* fall through */
block|}
block|}
comment|/* now exit if we are at the start/end point */
if|if
condition|(
name|point
operator|==
name|last
condition|)
block|{
if|if
condition|(
name|passed
condition|)
break|break;
name|passed
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|on_edge
operator|&&
name|FT_ABS
argument_list|(
name|point
operator|->
name|out_dir
argument_list|)
operator|==
name|major_dir
condition|)
block|{
comment|/* this is the start of a new segment! */
name|segment_dir
operator|=
operator|(
name|AF_Direction
operator|)
name|point
operator|->
name|out_dir
expr_stmt|;
name|error
operator|=
name|af_axis_hints_new_segment
argument_list|(
name|axis
argument_list|,
name|memory
argument_list|,
operator|&
name|segment
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
comment|/* clear all segment fields */
name|segment
index|[
literal|0
index|]
operator|=
name|seg0
expr_stmt|;
name|segment
operator|->
name|dir
operator|=
operator|(
name|FT_Char
operator|)
name|segment_dir
expr_stmt|;
name|segment
operator|->
name|first
operator|=
name|point
expr_stmt|;
name|segment
operator|->
name|last
operator|=
name|point
expr_stmt|;
name|min_pos
operator|=
name|max_pos
operator|=
name|point
operator|->
name|u
expr_stmt|;
if|if
condition|(
name|point
operator|->
name|flags
operator|&
name|AF_FLAG_CONTROL
condition|)
block|{
name|min_on_pos
operator|=
literal|32000
expr_stmt|;
name|max_on_pos
operator|=
operator|-
literal|32000
expr_stmt|;
block|}
else|else
name|min_on_pos
operator|=
name|max_on_pos
operator|=
name|point
operator|->
name|v
expr_stmt|;
name|on_edge
operator|=
literal|1
expr_stmt|;
block|}
name|point
operator|=
name|point
operator|->
name|next
expr_stmt|;
block|}
block|}
comment|/* contours */
comment|/* now slightly increase the height of segments if this makes */
comment|/* sense -- this is used to better detect and ignore serifs   */
block|{
name|AF_Segment
name|segments
init|=
name|axis
operator|->
name|segments
decl_stmt|;
name|AF_Segment
name|segments_end
init|=
name|segments
operator|+
name|axis
operator|->
name|num_segments
decl_stmt|;
for|for
control|(
name|segment
operator|=
name|segments
init|;
name|segment
operator|<
name|segments_end
condition|;
name|segment
operator|++
control|)
block|{
name|AF_Point
name|first
init|=
name|segment
operator|->
name|first
decl_stmt|;
name|AF_Point
name|last
init|=
name|segment
operator|->
name|last
decl_stmt|;
name|FT_Pos
name|first_v
init|=
name|first
operator|->
name|v
decl_stmt|;
name|FT_Pos
name|last_v
init|=
name|last
operator|->
name|v
decl_stmt|;
if|if
condition|(
name|first_v
operator|<
name|last_v
condition|)
block|{
name|AF_Point
name|p
decl_stmt|;
name|p
operator|=
name|first
operator|->
name|prev
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|v
operator|<
name|first_v
condition|)
name|segment
operator|->
name|height
operator|=
call|(
name|FT_Short
call|)
argument_list|(
name|segment
operator|->
name|height
operator|+
operator|(
operator|(
name|first_v
operator|-
name|p
operator|->
name|v
operator|)
operator|>>
literal|1
operator|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|last
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|v
operator|>
name|last_v
condition|)
name|segment
operator|->
name|height
operator|=
call|(
name|FT_Short
call|)
argument_list|(
name|segment
operator|->
name|height
operator|+
operator|(
operator|(
name|p
operator|->
name|v
operator|-
name|last_v
operator|)
operator|>>
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|AF_Point
name|p
decl_stmt|;
name|p
operator|=
name|first
operator|->
name|prev
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|v
operator|>
name|first_v
condition|)
name|segment
operator|->
name|height
operator|=
call|(
name|FT_Short
call|)
argument_list|(
name|segment
operator|->
name|height
operator|+
operator|(
operator|(
name|p
operator|->
name|v
operator|-
name|first_v
operator|)
operator|>>
literal|1
operator|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|last
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|v
operator|<
name|last_v
condition|)
name|segment
operator|->
name|height
operator|=
call|(
name|FT_Short
call|)
argument_list|(
name|segment
operator|->
name|height
operator|+
operator|(
operator|(
name|last_v
operator|-
name|p
operator|->
name|v
operator|)
operator|>>
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|Exit
label|:
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/* Link segments to form stems and serifs.  If `width_count' and      */
end_comment
begin_comment
comment|/* `widths' are non-zero, use them to fine-tune the scoring function. */
end_comment
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|af_latin_hints_link_segments
name|af_latin_hints_link_segments
argument_list|(
argument|AF_GlyphHints  hints
argument_list|,
argument|FT_UInt        width_count
argument_list|,
argument|AF_WidthRec*   widths
argument_list|,
argument|AF_Dimension   dim
argument_list|)
end_macro
begin_block
block|{
name|AF_AxisHints
name|axis
init|=
operator|&
name|hints
operator|->
name|axis
index|[
name|dim
index|]
decl_stmt|;
name|AF_Segment
name|segments
init|=
name|axis
operator|->
name|segments
decl_stmt|;
name|AF_Segment
name|segment_limit
init|=
name|segments
operator|+
name|axis
operator|->
name|num_segments
decl_stmt|;
name|FT_Pos
name|len_threshold
decl_stmt|,
name|len_score
decl_stmt|,
name|dist_score
decl_stmt|,
name|max_width
decl_stmt|;
name|AF_Segment
name|seg1
decl_stmt|,
name|seg2
decl_stmt|;
if|if
condition|(
name|width_count
condition|)
name|max_width
operator|=
name|widths
index|[
name|width_count
operator|-
literal|1
index|]
operator|.
name|org
expr_stmt|;
else|else
name|max_width
operator|=
literal|0
expr_stmt|;
comment|/* a heuristic value to set up a minimum value for overlapping */
name|len_threshold
operator|=
name|AF_LATIN_CONSTANT
argument_list|(
name|hints
operator|->
name|metrics
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|len_threshold
operator|==
literal|0
condition|)
name|len_threshold
operator|=
literal|1
expr_stmt|;
comment|/* a heuristic value to weight lengths */
name|len_score
operator|=
name|AF_LATIN_CONSTANT
argument_list|(
name|hints
operator|->
name|metrics
argument_list|,
literal|6000
argument_list|)
expr_stmt|;
comment|/* a heuristic value to weight distances (no call to    */
comment|/* AF_LATIN_CONSTANT needed, since we work on multiples */
comment|/* of the stem width)                                   */
name|dist_score
operator|=
literal|3000
expr_stmt|;
comment|/* now compare each segment to the others */
for|for
control|(
name|seg1
operator|=
name|segments
init|;
name|seg1
operator|<
name|segment_limit
condition|;
name|seg1
operator|++
control|)
block|{
if|if
condition|(
name|seg1
operator|->
name|dir
operator|!=
name|axis
operator|->
name|major_dir
condition|)
continue|continue;
comment|/* search for stems having opposite directions, */
comment|/* with seg1 to the `left' of seg2              */
for|for
control|(
name|seg2
operator|=
name|segments
init|;
name|seg2
operator|<
name|segment_limit
condition|;
name|seg2
operator|++
control|)
block|{
name|FT_Pos
name|pos1
init|=
name|seg1
operator|->
name|pos
decl_stmt|;
name|FT_Pos
name|pos2
init|=
name|seg2
operator|->
name|pos
decl_stmt|;
if|if
condition|(
name|seg1
operator|->
name|dir
operator|+
name|seg2
operator|->
name|dir
operator|==
literal|0
operator|&&
name|pos2
operator|>
name|pos1
condition|)
block|{
comment|/* compute distance between the two segments */
name|FT_Pos
name|min
init|=
name|seg1
operator|->
name|min_coord
decl_stmt|;
name|FT_Pos
name|max
init|=
name|seg1
operator|->
name|max_coord
decl_stmt|;
name|FT_Pos
name|len
decl_stmt|;
if|if
condition|(
name|min
operator|<
name|seg2
operator|->
name|min_coord
condition|)
name|min
operator|=
name|seg2
operator|->
name|min_coord
expr_stmt|;
if|if
condition|(
name|max
operator|>
name|seg2
operator|->
name|max_coord
condition|)
name|max
operator|=
name|seg2
operator|->
name|max_coord
expr_stmt|;
comment|/* compute maximum coordinate difference of the two segments */
comment|/* (this is, how much they overlap)                          */
name|len
operator|=
name|max
operator|-
name|min
expr_stmt|;
if|if
condition|(
name|len
operator|>=
name|len_threshold
condition|)
block|{
comment|/*              *  The score is the sum of two demerits indicating the              *  `badness' of a fit, measured along the segments' main axis              *  and orthogonal to it, respectively.              *              *  o The less overlapping along the main axis, the worse it              *    is, causing a larger demerit.              *              *  o The nearer the orthogonal distance to a stem width, the              *    better it is, causing a smaller demerit.  For simplicity,              *    however, we only increase the demerit for values that              *    exceed the largest stem width.              */
name|FT_Pos
name|dist
init|=
name|pos2
operator|-
name|pos1
decl_stmt|;
name|FT_Pos
name|dist_demerit
decl_stmt|,
name|score
decl_stmt|;
if|if
condition|(
name|max_width
condition|)
block|{
comment|/* distance demerits are based on multiples of `max_width'; */
comment|/* we scale by 1024 for getting more precision              */
name|FT_Pos
name|delta
init|=
operator|(
name|dist
operator|<<
literal|10
operator|)
operator|/
name|max_width
operator|-
operator|(
literal|1
operator|<<
literal|10
operator|)
decl_stmt|;
if|if
condition|(
name|delta
operator|>
literal|10000
condition|)
name|dist_demerit
operator|=
literal|32000
expr_stmt|;
elseif|else
if|if
condition|(
name|delta
operator|>
literal|0
condition|)
name|dist_demerit
operator|=
name|delta
operator|*
name|delta
operator|/
name|dist_score
expr_stmt|;
else|else
name|dist_demerit
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|dist_demerit
operator|=
name|dist
expr_stmt|;
comment|/* default if no widths available */
name|score
operator|=
name|dist_demerit
operator|+
name|len_score
operator|/
name|len
expr_stmt|;
comment|/* and we search for the smallest score */
if|if
condition|(
name|score
operator|<
name|seg1
operator|->
name|score
condition|)
block|{
name|seg1
operator|->
name|score
operator|=
name|score
expr_stmt|;
name|seg1
operator|->
name|link
operator|=
name|seg2
expr_stmt|;
block|}
if|if
condition|(
name|score
operator|<
name|seg2
operator|->
name|score
condition|)
block|{
name|seg2
operator|->
name|score
operator|=
name|score
expr_stmt|;
name|seg2
operator|->
name|link
operator|=
name|seg1
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/* now compute the `serif' segments, cf. explanations in `afhints.h' */
for|for
control|(
name|seg1
operator|=
name|segments
init|;
name|seg1
operator|<
name|segment_limit
condition|;
name|seg1
operator|++
control|)
block|{
name|seg2
operator|=
name|seg1
operator|->
name|link
expr_stmt|;
if|if
condition|(
name|seg2
condition|)
block|{
if|if
condition|(
name|seg2
operator|->
name|link
operator|!=
name|seg1
condition|)
block|{
name|seg1
operator|->
name|link
operator|=
literal|0
expr_stmt|;
name|seg1
operator|->
name|serif
operator|=
name|seg2
operator|->
name|link
expr_stmt|;
block|}
block|}
block|}
block|}
end_block
begin_comment
comment|/* Link segments to edges, using feature analysis for selection. */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|af_latin_hints_compute_edges
argument_list|(
argument|AF_GlyphHints  hints
argument_list|,
argument|AF_Dimension   dim
argument_list|)
end_macro
begin_block
block|{
name|AF_AxisHints
name|axis
init|=
operator|&
name|hints
operator|->
name|axis
index|[
name|dim
index|]
decl_stmt|;
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|hints
operator|->
name|memory
decl_stmt|;
name|AF_LatinAxis
name|laxis
init|=
operator|&
operator|(
operator|(
name|AF_LatinMetrics
operator|)
name|hints
operator|->
name|metrics
operator|)
operator|->
name|axis
index|[
name|dim
index|]
decl_stmt|;
name|AF_Segment
name|segments
init|=
name|axis
operator|->
name|segments
decl_stmt|;
name|AF_Segment
name|segment_limit
init|=
name|segments
operator|+
name|axis
operator|->
name|num_segments
decl_stmt|;
name|AF_Segment
name|seg
decl_stmt|;
if|#
directive|if
literal|0
block|AF_Direction  up_dir;
endif|#
directive|endif
name|FT_Fixed
name|scale
decl_stmt|;
name|FT_Pos
name|edge_distance_threshold
decl_stmt|;
name|FT_Pos
name|segment_length_threshold
decl_stmt|;
name|axis
operator|->
name|num_edges
operator|=
literal|0
expr_stmt|;
name|scale
operator|=
operator|(
name|dim
operator|==
name|AF_DIMENSION_HORZ
operator|)
condition|?
name|hints
operator|->
name|x_scale
else|:
name|hints
operator|->
name|y_scale
expr_stmt|;
if|#
directive|if
literal|0
block|up_dir = ( dim == AF_DIMENSION_HORZ ) ? AF_DIR_UP                                           : AF_DIR_RIGHT;
endif|#
directive|endif
comment|/*      *  We ignore all segments that are less than 1 pixel in length      *  to avoid many problems with serif fonts.  We compute the      *  corresponding threshold in font units.      */
if|if
condition|(
name|dim
operator|==
name|AF_DIMENSION_HORZ
condition|)
name|segment_length_threshold
operator|=
name|FT_DivFix
argument_list|(
literal|64
argument_list|,
name|hints
operator|->
name|y_scale
argument_list|)
expr_stmt|;
else|else
name|segment_length_threshold
operator|=
literal|0
expr_stmt|;
comment|/*********************************************************************/
comment|/*                                                                   */
comment|/* We begin by generating a sorted table of edges for the current    */
comment|/* direction.  To do so, we simply scan each segment and try to find */
comment|/* an edge in our table that corresponds to its position.            */
comment|/*                                                                   */
comment|/* If no edge is found, we create and insert a new edge in the       */
comment|/* sorted table.  Otherwise, we simply add the segment to the edge's */
comment|/* list which gets processed in the second step to compute the       */
comment|/* edge's properties.                                                */
comment|/*                                                                   */
comment|/* Note that the table of edges is sorted along the segment/edge     */
comment|/* position.                                                         */
comment|/*                                                                   */
comment|/*********************************************************************/
comment|/* assure that edge distance threshold is at most 0.25px */
name|edge_distance_threshold
operator|=
name|FT_MulFix
argument_list|(
name|laxis
operator|->
name|edge_distance_threshold
argument_list|,
name|scale
argument_list|)
expr_stmt|;
if|if
condition|(
name|edge_distance_threshold
operator|>
literal|64
operator|/
literal|4
condition|)
name|edge_distance_threshold
operator|=
literal|64
operator|/
literal|4
expr_stmt|;
name|edge_distance_threshold
operator|=
name|FT_DivFix
argument_list|(
name|edge_distance_threshold
argument_list|,
name|scale
argument_list|)
expr_stmt|;
for|for
control|(
name|seg
operator|=
name|segments
init|;
name|seg
operator|<
name|segment_limit
condition|;
name|seg
operator|++
control|)
block|{
name|AF_Edge
name|found
init|=
name|NULL
decl_stmt|;
name|FT_Int
name|ee
decl_stmt|;
if|if
condition|(
name|seg
operator|->
name|height
operator|<
name|segment_length_threshold
condition|)
continue|continue;
comment|/* A special case for serif edges: If they are smaller than */
comment|/* 1.5 pixels we ignore them.                               */
if|if
condition|(
name|seg
operator|->
name|serif
operator|&&
literal|2
operator|*
name|seg
operator|->
name|height
operator|<
literal|3
operator|*
name|segment_length_threshold
condition|)
continue|continue;
comment|/* look for an edge corresponding to the segment */
for|for
control|(
name|ee
operator|=
literal|0
init|;
name|ee
operator|<
name|axis
operator|->
name|num_edges
condition|;
name|ee
operator|++
control|)
block|{
name|AF_Edge
name|edge
init|=
name|axis
operator|->
name|edges
operator|+
name|ee
decl_stmt|;
name|FT_Pos
name|dist
decl_stmt|;
name|dist
operator|=
name|seg
operator|->
name|pos
operator|-
name|edge
operator|->
name|fpos
expr_stmt|;
if|if
condition|(
name|dist
operator|<
literal|0
condition|)
name|dist
operator|=
operator|-
name|dist
expr_stmt|;
if|if
condition|(
name|dist
operator|<
name|edge_distance_threshold
operator|&&
name|edge
operator|->
name|dir
operator|==
name|seg
operator|->
name|dir
condition|)
block|{
name|found
operator|=
name|edge
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|AF_Edge
name|edge
decl_stmt|;
comment|/* insert a new edge in the list and */
comment|/* sort according to the position    */
name|error
operator|=
name|af_axis_hints_new_edge
argument_list|(
name|axis
argument_list|,
name|seg
operator|->
name|pos
argument_list|,
operator|(
name|AF_Direction
operator|)
name|seg
operator|->
name|dir
argument_list|,
name|memory
argument_list|,
operator|&
name|edge
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
comment|/* add the segment to the new edge's list */
name|FT_ZERO
argument_list|(
name|edge
argument_list|)
expr_stmt|;
name|edge
operator|->
name|first
operator|=
name|seg
expr_stmt|;
name|edge
operator|->
name|last
operator|=
name|seg
expr_stmt|;
name|edge
operator|->
name|dir
operator|=
name|seg
operator|->
name|dir
expr_stmt|;
name|edge
operator|->
name|fpos
operator|=
name|seg
operator|->
name|pos
expr_stmt|;
name|edge
operator|->
name|opos
operator|=
name|FT_MulFix
argument_list|(
name|seg
operator|->
name|pos
argument_list|,
name|scale
argument_list|)
expr_stmt|;
name|edge
operator|->
name|pos
operator|=
name|edge
operator|->
name|opos
expr_stmt|;
name|seg
operator|->
name|edge_next
operator|=
name|seg
expr_stmt|;
block|}
else|else
block|{
comment|/* if an edge was found, simply add the segment to the edge's */
comment|/* list                                                       */
name|seg
operator|->
name|edge_next
operator|=
name|found
operator|->
name|first
expr_stmt|;
name|found
operator|->
name|last
operator|->
name|edge_next
operator|=
name|seg
expr_stmt|;
name|found
operator|->
name|last
operator|=
name|seg
expr_stmt|;
block|}
block|}
comment|/******************************************************************/
comment|/*                                                                */
comment|/* Good, we now compute each edge's properties according to the   */
comment|/* segments found on its position.  Basically, these are          */
comment|/*                                                                */
comment|/*  - the edge's main direction                                   */
comment|/*  - stem edge, serif edge or both (which defaults to stem then) */
comment|/*  - rounded edge, straight or both (which defaults to straight) */
comment|/*  - link for edge                                               */
comment|/*                                                                */
comment|/******************************************************************/
comment|/* first of all, set the `edge' field in each segment -- this is */
comment|/* required in order to compute edge links                       */
comment|/*      * Note that removing this loop and setting the `edge' field of each      * segment directly in the code above slows down execution speed for      * some reasons on platforms like the Sun.      */
block|{
name|AF_Edge
name|edges
init|=
name|axis
operator|->
name|edges
decl_stmt|;
name|AF_Edge
name|edge_limit
init|=
name|edges
operator|+
name|axis
operator|->
name|num_edges
decl_stmt|;
name|AF_Edge
name|edge
decl_stmt|;
for|for
control|(
name|edge
operator|=
name|edges
init|;
name|edge
operator|<
name|edge_limit
condition|;
name|edge
operator|++
control|)
block|{
name|seg
operator|=
name|edge
operator|->
name|first
expr_stmt|;
if|if
condition|(
name|seg
condition|)
do|do
block|{
name|seg
operator|->
name|edge
operator|=
name|edge
expr_stmt|;
name|seg
operator|=
name|seg
operator|->
name|edge_next
expr_stmt|;
block|}
do|while
condition|(
name|seg
operator|!=
name|edge
operator|->
name|first
condition|)
do|;
block|}
comment|/* now compute each edge properties */
for|for
control|(
name|edge
operator|=
name|edges
init|;
name|edge
operator|<
name|edge_limit
condition|;
name|edge
operator|++
control|)
block|{
name|FT_Int
name|is_round
init|=
literal|0
decl_stmt|;
comment|/* does it contain round segments?    */
name|FT_Int
name|is_straight
init|=
literal|0
decl_stmt|;
comment|/* does it contain straight segments? */
if|#
directive|if
literal|0
block|FT_Pos  ups         = 0;
comment|/* number of upwards segments         */
block|FT_Pos  downs       = 0;
comment|/* number of downwards segments       */
endif|#
directive|endif
name|seg
operator|=
name|edge
operator|->
name|first
expr_stmt|;
do|do
block|{
name|FT_Bool
name|is_serif
decl_stmt|;
comment|/* check for roundness of segment */
if|if
condition|(
name|seg
operator|->
name|flags
operator|&
name|AF_EDGE_ROUND
condition|)
name|is_round
operator|++
expr_stmt|;
else|else
name|is_straight
operator|++
expr_stmt|;
if|#
directive|if
literal|0
comment|/* check for segment direction */
block|if ( seg->dir == up_dir )             ups   += seg->max_coord - seg->min_coord;           else             downs += seg->max_coord - seg->min_coord;
endif|#
directive|endif
comment|/* check for links -- if seg->serif is set, then seg->link must */
comment|/* be ignored                                                   */
name|is_serif
operator|=
call|(
name|FT_Bool
call|)
argument_list|(
name|seg
operator|->
name|serif
operator|&&
name|seg
operator|->
name|serif
operator|->
name|edge
operator|&&
name|seg
operator|->
name|serif
operator|->
name|edge
operator|!=
name|edge
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|seg
operator|->
name|link
operator|&&
name|seg
operator|->
name|link
operator|->
name|edge
operator|!=
name|NULL
operator|)
operator|||
name|is_serif
condition|)
block|{
name|AF_Edge
name|edge2
decl_stmt|;
name|AF_Segment
name|seg2
decl_stmt|;
name|edge2
operator|=
name|edge
operator|->
name|link
expr_stmt|;
name|seg2
operator|=
name|seg
operator|->
name|link
expr_stmt|;
if|if
condition|(
name|is_serif
condition|)
block|{
name|seg2
operator|=
name|seg
operator|->
name|serif
expr_stmt|;
name|edge2
operator|=
name|edge
operator|->
name|serif
expr_stmt|;
block|}
if|if
condition|(
name|edge2
condition|)
block|{
name|FT_Pos
name|edge_delta
decl_stmt|;
name|FT_Pos
name|seg_delta
decl_stmt|;
name|edge_delta
operator|=
name|edge
operator|->
name|fpos
operator|-
name|edge2
operator|->
name|fpos
expr_stmt|;
if|if
condition|(
name|edge_delta
operator|<
literal|0
condition|)
name|edge_delta
operator|=
operator|-
name|edge_delta
expr_stmt|;
name|seg_delta
operator|=
name|seg
operator|->
name|pos
operator|-
name|seg2
operator|->
name|pos
expr_stmt|;
if|if
condition|(
name|seg_delta
operator|<
literal|0
condition|)
name|seg_delta
operator|=
operator|-
name|seg_delta
expr_stmt|;
if|if
condition|(
name|seg_delta
operator|<
name|edge_delta
condition|)
name|edge2
operator|=
name|seg2
operator|->
name|edge
expr_stmt|;
block|}
else|else
name|edge2
operator|=
name|seg2
operator|->
name|edge
expr_stmt|;
if|if
condition|(
name|is_serif
condition|)
block|{
name|edge
operator|->
name|serif
operator|=
name|edge2
expr_stmt|;
name|edge2
operator|->
name|flags
operator||=
name|AF_EDGE_SERIF
expr_stmt|;
block|}
else|else
name|edge
operator|->
name|link
operator|=
name|edge2
expr_stmt|;
block|}
name|seg
operator|=
name|seg
operator|->
name|edge_next
expr_stmt|;
block|}
do|while
condition|(
name|seg
operator|!=
name|edge
operator|->
name|first
condition|)
do|;
comment|/* set the round/straight flags */
name|edge
operator|->
name|flags
operator|=
name|AF_EDGE_NORMAL
expr_stmt|;
if|if
condition|(
name|is_round
operator|>
literal|0
operator|&&
name|is_round
operator|>=
name|is_straight
condition|)
name|edge
operator|->
name|flags
operator||=
name|AF_EDGE_ROUND
expr_stmt|;
if|#
directive|if
literal|0
comment|/* set the edge's main direction */
block|edge->dir = AF_DIR_NONE;          if ( ups> downs )           edge->dir = (FT_Char)up_dir;          else if ( ups< downs )           edge->dir = (FT_Char)-up_dir;          else if ( ups == downs )           edge->dir = 0;
comment|/* both up and down! */
endif|#
directive|endif
comment|/* get rid of serifs if link is set                 */
comment|/* XXX: This gets rid of many unpleasant artefacts! */
comment|/*      Example: the `c' in cour.pfa at size 13     */
if|if
condition|(
name|edge
operator|->
name|serif
operator|&&
name|edge
operator|->
name|link
condition|)
name|edge
operator|->
name|serif
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|Exit
label|:
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/* Detect segments and edges for given dimension. */
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|af_latin_hints_detect_features
argument_list|(
argument|AF_GlyphHints  hints
argument_list|,
argument|FT_UInt        width_count
argument_list|,
argument|AF_WidthRec*   widths
argument_list|,
argument|AF_Dimension   dim
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
decl_stmt|;
name|error
operator|=
name|af_latin_hints_compute_segments
argument_list|(
name|hints
argument_list|,
name|dim
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|af_latin_hints_link_segments
argument_list|(
name|hints
argument_list|,
name|width_count
argument_list|,
name|widths
argument_list|,
name|dim
argument_list|)
expr_stmt|;
name|error
operator|=
name|af_latin_hints_compute_edges
argument_list|(
name|hints
argument_list|,
name|dim
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/* Compute all edges which lie within blue zones. */
end_comment
begin_function
specifier|static
name|void
DECL|function|af_latin_hints_compute_blue_edges
name|af_latin_hints_compute_blue_edges
parameter_list|(
name|AF_GlyphHints
name|hints
parameter_list|,
name|AF_LatinMetrics
name|metrics
parameter_list|)
block|{
name|AF_AxisHints
name|axis
init|=
operator|&
name|hints
operator|->
name|axis
index|[
name|AF_DIMENSION_VERT
index|]
decl_stmt|;
name|AF_Edge
name|edge
init|=
name|axis
operator|->
name|edges
decl_stmt|;
name|AF_Edge
name|edge_limit
init|=
name|edge
operator|+
name|axis
operator|->
name|num_edges
decl_stmt|;
name|AF_LatinAxis
name|latin
init|=
operator|&
name|metrics
operator|->
name|axis
index|[
name|AF_DIMENSION_VERT
index|]
decl_stmt|;
name|FT_Fixed
name|scale
init|=
name|latin
operator|->
name|scale
decl_stmt|;
comment|/* compute which blue zones are active, i.e. have their scaled */
comment|/* size< 3/4 pixels                                           */
comment|/* for each horizontal edge search the blue zone which is closest */
for|for
control|(
init|;
name|edge
operator|<
name|edge_limit
condition|;
name|edge
operator|++
control|)
block|{
name|FT_UInt
name|bb
decl_stmt|;
name|AF_Width
name|best_blue
init|=
name|NULL
decl_stmt|;
name|FT_Bool
name|best_blue_is_neutral
init|=
literal|0
decl_stmt|;
name|FT_Pos
name|best_dist
decl_stmt|;
comment|/* initial threshold */
comment|/* compute the initial threshold as a fraction of the EM size */
comment|/* (the value 40 is heuristic)                                */
name|best_dist
operator|=
name|FT_MulFix
argument_list|(
name|metrics
operator|->
name|units_per_em
operator|/
literal|40
argument_list|,
name|scale
argument_list|)
expr_stmt|;
comment|/* assure a minimum distance of 0.5px */
if|if
condition|(
name|best_dist
operator|>
literal|64
operator|/
literal|2
condition|)
name|best_dist
operator|=
literal|64
operator|/
literal|2
expr_stmt|;
for|for
control|(
name|bb
operator|=
literal|0
init|;
name|bb
operator|<
name|latin
operator|->
name|blue_count
condition|;
name|bb
operator|++
control|)
block|{
name|AF_LatinBlue
name|blue
init|=
name|latin
operator|->
name|blues
operator|+
name|bb
decl_stmt|;
name|FT_Bool
name|is_top_blue
decl_stmt|,
name|is_neutral_blue
decl_stmt|,
name|is_major_dir
decl_stmt|;
comment|/* skip inactive blue zones (i.e., those that are too large) */
if|if
condition|(
operator|!
operator|(
name|blue
operator|->
name|flags
operator|&
name|AF_LATIN_BLUE_ACTIVE
operator|)
condition|)
continue|continue;
comment|/* if it is a top zone, check for right edges (against the major */
comment|/* direction); if it is a bottom zone, check for left edges (in  */
comment|/* the major direction) -- this assumes the TrueType convention  */
comment|/* for the orientation of contours                               */
name|is_top_blue
operator|=
call|(
name|FT_Byte
call|)
argument_list|(
operator|(
name|blue
operator|->
name|flags
operator|&
name|AF_LATIN_BLUE_TOP
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|is_neutral_blue
operator|=
call|(
name|FT_Byte
call|)
argument_list|(
operator|(
name|blue
operator|->
name|flags
operator|&
name|AF_LATIN_BLUE_NEUTRAL
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|is_major_dir
operator|=
name|FT_BOOL
argument_list|(
name|edge
operator|->
name|dir
operator|==
name|axis
operator|->
name|major_dir
argument_list|)
expr_stmt|;
comment|/* neutral blue zones are handled for both directions */
if|if
condition|(
name|is_top_blue
operator|^
name|is_major_dir
operator|||
name|is_neutral_blue
condition|)
block|{
name|FT_Pos
name|dist
decl_stmt|;
comment|/* first of all, compare it to the reference position */
name|dist
operator|=
name|edge
operator|->
name|fpos
operator|-
name|blue
operator|->
name|ref
operator|.
name|org
expr_stmt|;
if|if
condition|(
name|dist
operator|<
literal|0
condition|)
name|dist
operator|=
operator|-
name|dist
expr_stmt|;
name|dist
operator|=
name|FT_MulFix
argument_list|(
name|dist
argument_list|,
name|scale
argument_list|)
expr_stmt|;
if|if
condition|(
name|dist
operator|<
name|best_dist
condition|)
block|{
name|best_dist
operator|=
name|dist
expr_stmt|;
name|best_blue
operator|=
operator|&
name|blue
operator|->
name|ref
expr_stmt|;
name|best_blue_is_neutral
operator|=
name|is_neutral_blue
expr_stmt|;
block|}
comment|/* now compare it to the overshoot position and check whether */
comment|/* the edge is rounded, and whether the edge is over the      */
comment|/* reference position of a top zone, or under the reference   */
comment|/* position of a bottom zone (provided we don't have a        */
comment|/* neutral blue zone)                                         */
if|if
condition|(
name|edge
operator|->
name|flags
operator|&
name|AF_EDGE_ROUND
operator|&&
name|dist
operator|!=
literal|0
operator|&&
operator|!
name|is_neutral_blue
condition|)
block|{
name|FT_Bool
name|is_under_ref
init|=
name|FT_BOOL
argument_list|(
name|edge
operator|->
name|fpos
operator|<
name|blue
operator|->
name|ref
operator|.
name|org
argument_list|)
decl_stmt|;
if|if
condition|(
name|is_top_blue
operator|^
name|is_under_ref
condition|)
block|{
name|dist
operator|=
name|edge
operator|->
name|fpos
operator|-
name|blue
operator|->
name|shoot
operator|.
name|org
expr_stmt|;
if|if
condition|(
name|dist
operator|<
literal|0
condition|)
name|dist
operator|=
operator|-
name|dist
expr_stmt|;
name|dist
operator|=
name|FT_MulFix
argument_list|(
name|dist
argument_list|,
name|scale
argument_list|)
expr_stmt|;
if|if
condition|(
name|dist
operator|<
name|best_dist
condition|)
block|{
name|best_dist
operator|=
name|dist
expr_stmt|;
name|best_blue
operator|=
operator|&
name|blue
operator|->
name|shoot
expr_stmt|;
name|best_blue_is_neutral
operator|=
name|is_neutral_blue
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
if|if
condition|(
name|best_blue
condition|)
block|{
name|edge
operator|->
name|blue_edge
operator|=
name|best_blue
expr_stmt|;
if|if
condition|(
name|best_blue_is_neutral
condition|)
name|edge
operator|->
name|flags
operator||=
name|AF_EDGE_NEUTRAL
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/* Initalize hinting engine. */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|af_latin_hints_init
name|af_latin_hints_init
parameter_list|(
name|AF_GlyphHints
name|hints
parameter_list|,
name|AF_LatinMetrics
name|metrics
parameter_list|)
block|{
name|FT_Render_Mode
name|mode
decl_stmt|;
name|FT_UInt32
name|scaler_flags
decl_stmt|,
name|other_flags
decl_stmt|;
name|FT_Face
name|face
init|=
name|metrics
operator|->
name|root
operator|.
name|scaler
operator|.
name|face
decl_stmt|;
name|af_glyph_hints_rescale
argument_list|(
name|hints
argument_list|,
operator|(
name|AF_StyleMetrics
operator|)
name|metrics
argument_list|)
expr_stmt|;
comment|/*      *  correct x_scale and y_scale if needed, since they may have      *  been modified by `af_latin_metrics_scale_dim' above      */
name|hints
operator|->
name|x_scale
operator|=
name|metrics
operator|->
name|axis
index|[
name|AF_DIMENSION_HORZ
index|]
operator|.
name|scale
expr_stmt|;
name|hints
operator|->
name|x_delta
operator|=
name|metrics
operator|->
name|axis
index|[
name|AF_DIMENSION_HORZ
index|]
operator|.
name|delta
expr_stmt|;
name|hints
operator|->
name|y_scale
operator|=
name|metrics
operator|->
name|axis
index|[
name|AF_DIMENSION_VERT
index|]
operator|.
name|scale
expr_stmt|;
name|hints
operator|->
name|y_delta
operator|=
name|metrics
operator|->
name|axis
index|[
name|AF_DIMENSION_VERT
index|]
operator|.
name|delta
expr_stmt|;
comment|/* compute flags depending on render mode, etc. */
name|mode
operator|=
name|metrics
operator|->
name|root
operator|.
name|scaler
operator|.
name|render_mode
expr_stmt|;
if|#
directive|if
literal|0
comment|/* #ifdef AF_CONFIG_OPTION_USE_WARPER */
block|if ( mode == FT_RENDER_MODE_LCD || mode == FT_RENDER_MODE_LCD_V )       metrics->root.scaler.render_mode = mode = FT_RENDER_MODE_NORMAL;
endif|#
directive|endif
name|scaler_flags
operator|=
name|hints
operator|->
name|scaler_flags
expr_stmt|;
name|other_flags
operator|=
literal|0
expr_stmt|;
comment|/*      *  We snap the width of vertical stems for the monochrome and      *  horizontal LCD rendering targets only.      */
if|if
condition|(
name|mode
operator|==
name|FT_RENDER_MODE_MONO
operator|||
name|mode
operator|==
name|FT_RENDER_MODE_LCD
condition|)
name|other_flags
operator||=
name|AF_LATIN_HINTS_HORZ_SNAP
expr_stmt|;
comment|/*      *  We snap the width of horizontal stems for the monochrome and      *  vertical LCD rendering targets only.      */
if|if
condition|(
name|mode
operator|==
name|FT_RENDER_MODE_MONO
operator|||
name|mode
operator|==
name|FT_RENDER_MODE_LCD_V
condition|)
name|other_flags
operator||=
name|AF_LATIN_HINTS_VERT_SNAP
expr_stmt|;
comment|/*      *  We adjust stems to full pixels only if we don't use the `light' mode.      */
if|if
condition|(
name|mode
operator|!=
name|FT_RENDER_MODE_LIGHT
condition|)
name|other_flags
operator||=
name|AF_LATIN_HINTS_STEM_ADJUST
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|FT_RENDER_MODE_MONO
condition|)
name|other_flags
operator||=
name|AF_LATIN_HINTS_MONO
expr_stmt|;
comment|/*      *  In `light' hinting mode we disable horizontal hinting completely.      *  We also do it if the face is italic.      *      *  However, if warping is enabled (which only works in `light' hinting      *  mode), advance widths get adjusted, too.      */
if|if
condition|(
name|mode
operator|==
name|FT_RENDER_MODE_LIGHT
operator|||
operator|(
name|face
operator|->
name|style_flags
operator|&
name|FT_STYLE_FLAG_ITALIC
operator|)
operator|!=
literal|0
condition|)
name|scaler_flags
operator||=
name|AF_SCALER_FLAG_NO_HORIZONTAL
expr_stmt|;
ifdef|#
directive|ifdef
name|AF_CONFIG_OPTION_USE_WARPER
comment|/* get (global) warper flag */
if|if
condition|(
operator|!
name|metrics
operator|->
name|root
operator|.
name|globals
operator|->
name|module
operator|->
name|warping
condition|)
name|scaler_flags
operator||=
name|AF_SCALER_FLAG_NO_WARPER
expr_stmt|;
endif|#
directive|endif
name|hints
operator|->
name|scaler_flags
operator|=
name|scaler_flags
expr_stmt|;
name|hints
operator|->
name|other_flags
operator|=
name|other_flags
expr_stmt|;
return|return
name|FT_Err_Ok
return|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****        L A T I N   G L Y P H   G R I D - F I T T I N G        *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/* Snap a given width in scaled coordinates to one of the */
end_comment
begin_comment
comment|/* current standard widths.                               */
end_comment
begin_function
specifier|static
name|FT_Pos
DECL|function|af_latin_snap_width
name|af_latin_snap_width
parameter_list|(
name|AF_Width
name|widths
parameter_list|,
name|FT_UInt
name|count
parameter_list|,
name|FT_Pos
name|width
parameter_list|)
block|{
name|FT_UInt
name|n
decl_stmt|;
name|FT_Pos
name|best
init|=
literal|64
operator|+
literal|32
operator|+
literal|2
decl_stmt|;
name|FT_Pos
name|reference
init|=
name|width
decl_stmt|;
name|FT_Pos
name|scaled
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
block|{
name|FT_Pos
name|w
decl_stmt|;
name|FT_Pos
name|dist
decl_stmt|;
name|w
operator|=
name|widths
index|[
name|n
index|]
operator|.
name|cur
expr_stmt|;
name|dist
operator|=
name|width
operator|-
name|w
expr_stmt|;
if|if
condition|(
name|dist
operator|<
literal|0
condition|)
name|dist
operator|=
operator|-
name|dist
expr_stmt|;
if|if
condition|(
name|dist
operator|<
name|best
condition|)
block|{
name|best
operator|=
name|dist
expr_stmt|;
name|reference
operator|=
name|w
expr_stmt|;
block|}
block|}
name|scaled
operator|=
name|FT_PIX_ROUND
argument_list|(
name|reference
argument_list|)
expr_stmt|;
if|if
condition|(
name|width
operator|>=
name|reference
condition|)
block|{
if|if
condition|(
name|width
operator|<
name|scaled
operator|+
literal|48
condition|)
name|width
operator|=
name|reference
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|width
operator|>
name|scaled
operator|-
literal|48
condition|)
name|width
operator|=
name|reference
expr_stmt|;
block|}
return|return
name|width
return|;
block|}
end_function
begin_comment
comment|/* Compute the snapped width of a given stem, ignoring very thin ones. */
end_comment
begin_comment
comment|/* There is a lot of voodoo in this function; changing the hard-coded  */
end_comment
begin_comment
comment|/* parameters influence the whole hinting process.                     */
end_comment
begin_function
specifier|static
name|FT_Pos
DECL|function|af_latin_compute_stem_width
name|af_latin_compute_stem_width
parameter_list|(
name|AF_GlyphHints
name|hints
parameter_list|,
name|AF_Dimension
name|dim
parameter_list|,
name|FT_Pos
name|width
parameter_list|,
name|FT_UInt
name|base_flags
parameter_list|,
name|FT_UInt
name|stem_flags
parameter_list|)
block|{
name|AF_LatinMetrics
name|metrics
init|=
operator|(
name|AF_LatinMetrics
operator|)
name|hints
operator|->
name|metrics
decl_stmt|;
name|AF_LatinAxis
name|axis
init|=
operator|&
name|metrics
operator|->
name|axis
index|[
name|dim
index|]
decl_stmt|;
name|FT_Pos
name|dist
init|=
name|width
decl_stmt|;
name|FT_Int
name|sign
init|=
literal|0
decl_stmt|;
name|FT_Int
name|vertical
init|=
operator|(
name|dim
operator|==
name|AF_DIMENSION_VERT
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|AF_LATIN_HINTS_DO_STEM_ADJUST
argument_list|(
name|hints
argument_list|)
operator|||
name|axis
operator|->
name|extra_light
condition|)
return|return
name|width
return|;
if|if
condition|(
name|dist
operator|<
literal|0
condition|)
block|{
name|dist
operator|=
operator|-
name|width
expr_stmt|;
name|sign
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|vertical
operator|&&
operator|!
name|AF_LATIN_HINTS_DO_VERT_SNAP
argument_list|(
name|hints
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|vertical
operator|&&
operator|!
name|AF_LATIN_HINTS_DO_HORZ_SNAP
argument_list|(
name|hints
argument_list|)
operator|)
condition|)
block|{
comment|/* smooth hinting process: very lightly quantize the stem width */
comment|/* leave the widths of serifs alone */
if|if
condition|(
operator|(
name|stem_flags
operator|&
name|AF_EDGE_SERIF
operator|)
operator|&&
name|vertical
operator|&&
operator|(
name|dist
operator|<
literal|3
operator|*
literal|64
operator|)
condition|)
goto|goto
name|Done_Width
goto|;
elseif|else
if|if
condition|(
name|base_flags
operator|&
name|AF_EDGE_ROUND
condition|)
block|{
if|if
condition|(
name|dist
operator|<
literal|80
condition|)
name|dist
operator|=
literal|64
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dist
operator|<
literal|56
condition|)
name|dist
operator|=
literal|56
expr_stmt|;
if|if
condition|(
name|axis
operator|->
name|width_count
operator|>
literal|0
condition|)
block|{
name|FT_Pos
name|delta
decl_stmt|;
comment|/* compare to standard width */
name|delta
operator|=
name|dist
operator|-
name|axis
operator|->
name|widths
index|[
literal|0
index|]
operator|.
name|cur
expr_stmt|;
if|if
condition|(
name|delta
operator|<
literal|0
condition|)
name|delta
operator|=
operator|-
name|delta
expr_stmt|;
if|if
condition|(
name|delta
operator|<
literal|40
condition|)
block|{
name|dist
operator|=
name|axis
operator|->
name|widths
index|[
literal|0
index|]
operator|.
name|cur
expr_stmt|;
if|if
condition|(
name|dist
operator|<
literal|48
condition|)
name|dist
operator|=
literal|48
expr_stmt|;
goto|goto
name|Done_Width
goto|;
block|}
if|if
condition|(
name|dist
operator|<
literal|3
operator|*
literal|64
condition|)
block|{
name|delta
operator|=
name|dist
operator|&
literal|63
expr_stmt|;
name|dist
operator|&=
operator|-
literal|64
expr_stmt|;
if|if
condition|(
name|delta
operator|<
literal|10
condition|)
name|dist
operator|+=
name|delta
expr_stmt|;
elseif|else
if|if
condition|(
name|delta
operator|<
literal|32
condition|)
name|dist
operator|+=
literal|10
expr_stmt|;
elseif|else
if|if
condition|(
name|delta
operator|<
literal|54
condition|)
name|dist
operator|+=
literal|54
expr_stmt|;
else|else
name|dist
operator|+=
name|delta
expr_stmt|;
block|}
else|else
name|dist
operator|=
operator|(
name|dist
operator|+
literal|32
operator|)
operator|&
operator|~
literal|63
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* strong hinting process: snap the stem width to integer pixels */
name|FT_Pos
name|org_dist
init|=
name|dist
decl_stmt|;
name|dist
operator|=
name|af_latin_snap_width
argument_list|(
name|axis
operator|->
name|widths
argument_list|,
name|axis
operator|->
name|width_count
argument_list|,
name|dist
argument_list|)
expr_stmt|;
if|if
condition|(
name|vertical
condition|)
block|{
comment|/* in the case of vertical hinting, always round */
comment|/* the stem heights to integer pixels            */
if|if
condition|(
name|dist
operator|>=
literal|64
condition|)
name|dist
operator|=
operator|(
name|dist
operator|+
literal|16
operator|)
operator|&
operator|~
literal|63
expr_stmt|;
else|else
name|dist
operator|=
literal|64
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|AF_LATIN_HINTS_DO_MONO
argument_list|(
name|hints
argument_list|)
condition|)
block|{
comment|/* monochrome horizontal hinting: snap widths to integer pixels */
comment|/* with a different threshold                                   */
if|if
condition|(
name|dist
operator|<
literal|64
condition|)
name|dist
operator|=
literal|64
expr_stmt|;
else|else
name|dist
operator|=
operator|(
name|dist
operator|+
literal|32
operator|)
operator|&
operator|~
literal|63
expr_stmt|;
block|}
else|else
block|{
comment|/* for horizontal anti-aliased hinting, we adopt a more subtle */
comment|/* approach: we strengthen small stems, round stems whose size */
comment|/* is between 1 and 2 pixels to an integer, otherwise nothing  */
if|if
condition|(
name|dist
operator|<
literal|48
condition|)
name|dist
operator|=
operator|(
name|dist
operator|+
literal|64
operator|)
operator|>>
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|dist
operator|<
literal|128
condition|)
block|{
comment|/* We only round to an integer width if the corresponding */
comment|/* distortion is less than 1/4 pixel.  Otherwise this     */
comment|/* makes everything worse since the diagonals, which are  */
comment|/* not hinted, appear a lot bolder or thinner than the    */
comment|/* vertical stems.                                        */
name|FT_Pos
name|delta
decl_stmt|;
name|dist
operator|=
operator|(
name|dist
operator|+
literal|22
operator|)
operator|&
operator|~
literal|63
expr_stmt|;
name|delta
operator|=
name|dist
operator|-
name|org_dist
expr_stmt|;
if|if
condition|(
name|delta
operator|<
literal|0
condition|)
name|delta
operator|=
operator|-
name|delta
expr_stmt|;
if|if
condition|(
name|delta
operator|>=
literal|16
condition|)
block|{
name|dist
operator|=
name|org_dist
expr_stmt|;
if|if
condition|(
name|dist
operator|<
literal|48
condition|)
name|dist
operator|=
operator|(
name|dist
operator|+
literal|64
operator|)
operator|>>
literal|1
expr_stmt|;
block|}
block|}
else|else
comment|/* round otherwise to prevent color fringes in LCD mode */
name|dist
operator|=
operator|(
name|dist
operator|+
literal|32
operator|)
operator|&
operator|~
literal|63
expr_stmt|;
block|}
block|}
block|}
name|Done_Width
label|:
if|if
condition|(
name|sign
condition|)
name|dist
operator|=
operator|-
name|dist
expr_stmt|;
return|return
name|dist
return|;
block|}
end_function
begin_comment
comment|/* Align one stem edge relative to the previous stem edge. */
end_comment
begin_function
specifier|static
name|void
DECL|function|af_latin_align_linked_edge
name|af_latin_align_linked_edge
parameter_list|(
name|AF_GlyphHints
name|hints
parameter_list|,
name|AF_Dimension
name|dim
parameter_list|,
name|AF_Edge
name|base_edge
parameter_list|,
name|AF_Edge
name|stem_edge
parameter_list|)
block|{
name|FT_Pos
name|dist
init|=
name|stem_edge
operator|->
name|opos
operator|-
name|base_edge
operator|->
name|opos
decl_stmt|;
name|FT_Pos
name|fitted_width
init|=
name|af_latin_compute_stem_width
argument_list|(
name|hints
argument_list|,
name|dim
argument_list|,
name|dist
argument_list|,
name|base_edge
operator|->
name|flags
argument_list|,
name|stem_edge
operator|->
name|flags
argument_list|)
decl_stmt|;
name|stem_edge
operator|->
name|pos
operator|=
name|base_edge
operator|->
name|pos
operator|+
name|fitted_width
expr_stmt|;
name|FT_TRACE5
argument_list|(
operator|(
literal|"  LINK: edge %d (opos=%.2f) linked to %.2f,"
literal|" dist was %.2f, now %.2f\n"
operator|,
name|stem_edge
operator|-
name|hints
operator|->
name|axis
index|[
name|dim
index|]
operator|.
name|edges
operator|,
name|stem_edge
operator|->
name|opos
operator|/
literal|64.0
operator|,
name|stem_edge
operator|->
name|pos
operator|/
literal|64.0
operator|,
name|dist
operator|/
literal|64.0
operator|,
name|fitted_width
operator|/
literal|64.0
operator|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* Shift the coordinates of the `serif' edge by the same amount */
end_comment
begin_comment
comment|/* as the corresponding `base' edge has been moved already.     */
end_comment
begin_function
specifier|static
name|void
DECL|function|af_latin_align_serif_edge
name|af_latin_align_serif_edge
parameter_list|(
name|AF_GlyphHints
name|hints
parameter_list|,
name|AF_Edge
name|base
parameter_list|,
name|AF_Edge
name|serif
parameter_list|)
block|{
name|FT_UNUSED
argument_list|(
name|hints
argument_list|)
expr_stmt|;
name|serif
operator|->
name|pos
operator|=
name|base
operator|->
name|pos
operator|+
operator|(
name|serif
operator|->
name|opos
operator|-
name|base
operator|->
name|opos
operator|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/****                                                                 ****/
end_comment
begin_comment
comment|/****                    E D G E   H I N T I N G                      ****/
end_comment
begin_comment
comment|/****                                                                 ****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/* The main grid-fitting routine. */
end_comment
begin_function
specifier|static
name|void
DECL|function|af_latin_hint_edges
name|af_latin_hint_edges
parameter_list|(
name|AF_GlyphHints
name|hints
parameter_list|,
name|AF_Dimension
name|dim
parameter_list|)
block|{
name|AF_AxisHints
name|axis
init|=
operator|&
name|hints
operator|->
name|axis
index|[
name|dim
index|]
decl_stmt|;
name|AF_Edge
name|edges
init|=
name|axis
operator|->
name|edges
decl_stmt|;
name|AF_Edge
name|edge_limit
init|=
name|edges
operator|+
name|axis
operator|->
name|num_edges
decl_stmt|;
name|FT_PtrDist
name|n_edges
decl_stmt|;
name|AF_Edge
name|edge
decl_stmt|;
name|AF_Edge
name|anchor
init|=
name|NULL
decl_stmt|;
name|FT_Int
name|has_serifs
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|FT_DEBUG_LEVEL_TRACE
name|FT_UInt
name|num_actions
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|FT_TRACE5
argument_list|(
operator|(
literal|"latin %s edge hinting (style `%s')\n"
operator|,
name|dim
operator|==
name|AF_DIMENSION_VERT
condition|?
literal|"horizontal"
else|:
literal|"vertical"
operator|,
name|af_style_names
index|[
name|hints
operator|->
name|metrics
operator|->
name|style_class
operator|->
name|style
index|]
operator|)
argument_list|)
expr_stmt|;
comment|/* we begin by aligning all stems relative to the blue zone */
comment|/* if needed -- that's only for horizontal edges            */
if|if
condition|(
name|dim
operator|==
name|AF_DIMENSION_VERT
operator|&&
name|AF_HINTS_DO_BLUES
argument_list|(
name|hints
argument_list|)
condition|)
block|{
for|for
control|(
name|edge
operator|=
name|edges
init|;
name|edge
operator|<
name|edge_limit
condition|;
name|edge
operator|++
control|)
block|{
name|AF_Width
name|blue
decl_stmt|;
name|AF_Edge
name|edge1
decl_stmt|,
name|edge2
decl_stmt|;
comment|/* these edges form the stem to check */
if|if
condition|(
name|edge
operator|->
name|flags
operator|&
name|AF_EDGE_DONE
condition|)
continue|continue;
name|edge1
operator|=
name|NULL
expr_stmt|;
name|edge2
operator|=
name|edge
operator|->
name|link
expr_stmt|;
comment|/*          *  If a stem contains both a neutral and a non-neutral blue zone,          *  skip the neutral one.  Otherwise, outlines with different          *  directions might be incorrectly aligned at the same vertical          *  position.          *          *  If we have two neutral blue zones, skip one of them.          *          */
if|if
condition|(
name|edge
operator|->
name|blue_edge
operator|&&
name|edge2
operator|&&
name|edge2
operator|->
name|blue_edge
condition|)
block|{
name|FT_Byte
name|neutral
init|=
name|edge
operator|->
name|flags
operator|&
name|AF_EDGE_NEUTRAL
decl_stmt|;
name|FT_Byte
name|neutral2
init|=
name|edge2
operator|->
name|flags
operator|&
name|AF_EDGE_NEUTRAL
decl_stmt|;
if|if
condition|(
name|neutral2
condition|)
block|{
name|edge2
operator|->
name|blue_edge
operator|=
name|NULL
expr_stmt|;
name|edge2
operator|->
name|flags
operator|&=
operator|~
name|AF_EDGE_NEUTRAL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|neutral
condition|)
block|{
name|edge
operator|->
name|blue_edge
operator|=
name|NULL
expr_stmt|;
name|edge
operator|->
name|flags
operator|&=
operator|~
name|AF_EDGE_NEUTRAL
expr_stmt|;
block|}
block|}
name|blue
operator|=
name|edge
operator|->
name|blue_edge
expr_stmt|;
if|if
condition|(
name|blue
condition|)
name|edge1
operator|=
name|edge
expr_stmt|;
comment|/* flip edges if the other edge is aligned to a blue zone */
elseif|else
if|if
condition|(
name|edge2
operator|&&
name|edge2
operator|->
name|blue_edge
condition|)
block|{
name|blue
operator|=
name|edge2
operator|->
name|blue_edge
expr_stmt|;
name|edge1
operator|=
name|edge2
expr_stmt|;
name|edge2
operator|=
name|edge
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|edge1
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|FT_DEBUG_LEVEL_TRACE
if|if
condition|(
operator|!
name|anchor
condition|)
name|FT_TRACE5
argument_list|(
operator|(
literal|"  BLUE_ANCHOR: edge %d (opos=%.2f) snapped to %.2f,"
literal|" was %.2f (anchor=edge %d)\n"
operator|,
name|edge1
operator|-
name|edges
operator|,
name|edge1
operator|->
name|opos
operator|/
literal|64.0
operator|,
name|blue
operator|->
name|fit
operator|/
literal|64.0
operator|,
name|edge1
operator|->
name|pos
operator|/
literal|64.0
operator|,
name|edge
operator|-
name|edges
operator|)
argument_list|)
expr_stmt|;
else|else
name|FT_TRACE5
argument_list|(
operator|(
literal|"  BLUE: edge %d (opos=%.2f) snapped to %.2f,"
literal|" was %.2f\n"
operator|,
name|edge1
operator|-
name|edges
operator|,
name|edge1
operator|->
name|opos
operator|/
literal|64.0
operator|,
name|blue
operator|->
name|fit
operator|/
literal|64.0
operator|,
name|edge1
operator|->
name|pos
operator|/
literal|64.0
operator|)
argument_list|)
expr_stmt|;
name|num_actions
operator|++
expr_stmt|;
endif|#
directive|endif
name|edge1
operator|->
name|pos
operator|=
name|blue
operator|->
name|fit
expr_stmt|;
name|edge1
operator|->
name|flags
operator||=
name|AF_EDGE_DONE
expr_stmt|;
if|if
condition|(
name|edge2
operator|&&
operator|!
name|edge2
operator|->
name|blue_edge
condition|)
block|{
name|af_latin_align_linked_edge
argument_list|(
name|hints
argument_list|,
name|dim
argument_list|,
name|edge1
argument_list|,
name|edge2
argument_list|)
expr_stmt|;
name|edge2
operator|->
name|flags
operator||=
name|AF_EDGE_DONE
expr_stmt|;
ifdef|#
directive|ifdef
name|FT_DEBUG_LEVEL_TRACE
name|num_actions
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
operator|!
name|anchor
condition|)
name|anchor
operator|=
name|edge
expr_stmt|;
block|}
block|}
comment|/* now we align all other stem edges, trying to maintain the */
comment|/* relative order of stems in the glyph                      */
for|for
control|(
name|edge
operator|=
name|edges
init|;
name|edge
operator|<
name|edge_limit
condition|;
name|edge
operator|++
control|)
block|{
name|AF_Edge
name|edge2
decl_stmt|;
if|if
condition|(
name|edge
operator|->
name|flags
operator|&
name|AF_EDGE_DONE
condition|)
continue|continue;
comment|/* skip all non-stem edges */
name|edge2
operator|=
name|edge
operator|->
name|link
expr_stmt|;
if|if
condition|(
operator|!
name|edge2
condition|)
block|{
name|has_serifs
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* now align the stem */
comment|/* this should not happen, but it's better to be safe */
if|if
condition|(
name|edge2
operator|->
name|blue_edge
condition|)
block|{
name|FT_TRACE5
argument_list|(
operator|(
literal|"  ASSERTION FAILED for edge %d\n"
operator|,
name|edge2
operator|-
name|edges
operator|)
argument_list|)
expr_stmt|;
name|af_latin_align_linked_edge
argument_list|(
name|hints
argument_list|,
name|dim
argument_list|,
name|edge2
argument_list|,
name|edge
argument_list|)
expr_stmt|;
name|edge
operator|->
name|flags
operator||=
name|AF_EDGE_DONE
expr_stmt|;
ifdef|#
directive|ifdef
name|FT_DEBUG_LEVEL_TRACE
name|num_actions
operator|++
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
if|if
condition|(
operator|!
name|anchor
condition|)
block|{
comment|/* if we reach this if clause, no stem has been aligned yet */
name|FT_Pos
name|org_len
decl_stmt|,
name|org_center
decl_stmt|,
name|cur_len
decl_stmt|;
name|FT_Pos
name|cur_pos1
decl_stmt|,
name|error1
decl_stmt|,
name|error2
decl_stmt|,
name|u_off
decl_stmt|,
name|d_off
decl_stmt|;
name|org_len
operator|=
name|edge2
operator|->
name|opos
operator|-
name|edge
operator|->
name|opos
expr_stmt|;
name|cur_len
operator|=
name|af_latin_compute_stem_width
argument_list|(
name|hints
argument_list|,
name|dim
argument_list|,
name|org_len
argument_list|,
name|edge
operator|->
name|flags
argument_list|,
name|edge2
operator|->
name|flags
argument_list|)
expr_stmt|;
comment|/* some voodoo to specially round edges for small stem widths; */
comment|/* the idea is to align the center of a stem, then shifting    */
comment|/* the stem edges to suitable positions                        */
if|if
condition|(
name|cur_len
operator|<=
literal|64
condition|)
block|{
comment|/* width<= 1px */
name|u_off
operator|=
literal|32
expr_stmt|;
name|d_off
operator|=
literal|32
expr_stmt|;
block|}
else|else
block|{
comment|/* 1px< width< 1.5px */
name|u_off
operator|=
literal|38
expr_stmt|;
name|d_off
operator|=
literal|26
expr_stmt|;
block|}
if|if
condition|(
name|cur_len
operator|<
literal|96
condition|)
block|{
name|org_center
operator|=
name|edge
operator|->
name|opos
operator|+
operator|(
name|org_len
operator|>>
literal|1
operator|)
expr_stmt|;
name|cur_pos1
operator|=
name|FT_PIX_ROUND
argument_list|(
name|org_center
argument_list|)
expr_stmt|;
name|error1
operator|=
name|org_center
operator|-
operator|(
name|cur_pos1
operator|-
name|u_off
operator|)
expr_stmt|;
if|if
condition|(
name|error1
operator|<
literal|0
condition|)
name|error1
operator|=
operator|-
name|error1
expr_stmt|;
name|error2
operator|=
name|org_center
operator|-
operator|(
name|cur_pos1
operator|+
name|d_off
operator|)
expr_stmt|;
if|if
condition|(
name|error2
operator|<
literal|0
condition|)
name|error2
operator|=
operator|-
name|error2
expr_stmt|;
if|if
condition|(
name|error1
operator|<
name|error2
condition|)
name|cur_pos1
operator|-=
name|u_off
expr_stmt|;
else|else
name|cur_pos1
operator|+=
name|d_off
expr_stmt|;
name|edge
operator|->
name|pos
operator|=
name|cur_pos1
operator|-
name|cur_len
operator|/
literal|2
expr_stmt|;
name|edge2
operator|->
name|pos
operator|=
name|edge
operator|->
name|pos
operator|+
name|cur_len
expr_stmt|;
block|}
else|else
name|edge
operator|->
name|pos
operator|=
name|FT_PIX_ROUND
argument_list|(
name|edge
operator|->
name|opos
argument_list|)
expr_stmt|;
name|anchor
operator|=
name|edge
expr_stmt|;
name|edge
operator|->
name|flags
operator||=
name|AF_EDGE_DONE
expr_stmt|;
name|FT_TRACE5
argument_list|(
operator|(
literal|"  ANCHOR: edge %d (opos=%.2f) and %d (opos=%.2f)"
literal|" snapped to %.2f and %.2f\n"
operator|,
name|edge
operator|-
name|edges
operator|,
name|edge
operator|->
name|opos
operator|/
literal|64.0
operator|,
name|edge2
operator|-
name|edges
operator|,
name|edge2
operator|->
name|opos
operator|/
literal|64.0
operator|,
name|edge
operator|->
name|pos
operator|/
literal|64.0
operator|,
name|edge2
operator|->
name|pos
operator|/
literal|64.0
operator|)
argument_list|)
expr_stmt|;
name|af_latin_align_linked_edge
argument_list|(
name|hints
argument_list|,
name|dim
argument_list|,
name|edge
argument_list|,
name|edge2
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FT_DEBUG_LEVEL_TRACE
name|num_actions
operator|+=
literal|2
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|FT_Pos
name|org_pos
decl_stmt|,
name|org_len
decl_stmt|,
name|org_center
decl_stmt|,
name|cur_len
decl_stmt|;
name|FT_Pos
name|cur_pos1
decl_stmt|,
name|cur_pos2
decl_stmt|,
name|delta1
decl_stmt|,
name|delta2
decl_stmt|;
name|org_pos
operator|=
name|anchor
operator|->
name|pos
operator|+
operator|(
name|edge
operator|->
name|opos
operator|-
name|anchor
operator|->
name|opos
operator|)
expr_stmt|;
name|org_len
operator|=
name|edge2
operator|->
name|opos
operator|-
name|edge
operator|->
name|opos
expr_stmt|;
name|org_center
operator|=
name|org_pos
operator|+
operator|(
name|org_len
operator|>>
literal|1
operator|)
expr_stmt|;
name|cur_len
operator|=
name|af_latin_compute_stem_width
argument_list|(
name|hints
argument_list|,
name|dim
argument_list|,
name|org_len
argument_list|,
name|edge
operator|->
name|flags
argument_list|,
name|edge2
operator|->
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|edge2
operator|->
name|flags
operator|&
name|AF_EDGE_DONE
condition|)
block|{
name|FT_TRACE5
argument_list|(
operator|(
literal|"  ADJUST: edge %d (pos=%.2f) moved to %.2f\n"
operator|,
name|edge
operator|-
name|edges
operator|,
name|edge
operator|->
name|pos
operator|/
literal|64.0
operator|,
operator|(
name|edge2
operator|->
name|pos
operator|-
name|cur_len
operator|)
operator|/
literal|64.0
operator|)
argument_list|)
expr_stmt|;
name|edge
operator|->
name|pos
operator|=
name|edge2
operator|->
name|pos
operator|-
name|cur_len
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cur_len
operator|<
literal|96
condition|)
block|{
name|FT_Pos
name|u_off
decl_stmt|,
name|d_off
decl_stmt|;
name|cur_pos1
operator|=
name|FT_PIX_ROUND
argument_list|(
name|org_center
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur_len
operator|<=
literal|64
condition|)
block|{
name|u_off
operator|=
literal|32
expr_stmt|;
name|d_off
operator|=
literal|32
expr_stmt|;
block|}
else|else
block|{
name|u_off
operator|=
literal|38
expr_stmt|;
name|d_off
operator|=
literal|26
expr_stmt|;
block|}
name|delta1
operator|=
name|org_center
operator|-
operator|(
name|cur_pos1
operator|-
name|u_off
operator|)
expr_stmt|;
if|if
condition|(
name|delta1
operator|<
literal|0
condition|)
name|delta1
operator|=
operator|-
name|delta1
expr_stmt|;
name|delta2
operator|=
name|org_center
operator|-
operator|(
name|cur_pos1
operator|+
name|d_off
operator|)
expr_stmt|;
if|if
condition|(
name|delta2
operator|<
literal|0
condition|)
name|delta2
operator|=
operator|-
name|delta2
expr_stmt|;
if|if
condition|(
name|delta1
operator|<
name|delta2
condition|)
name|cur_pos1
operator|-=
name|u_off
expr_stmt|;
else|else
name|cur_pos1
operator|+=
name|d_off
expr_stmt|;
name|edge
operator|->
name|pos
operator|=
name|cur_pos1
operator|-
name|cur_len
operator|/
literal|2
expr_stmt|;
name|edge2
operator|->
name|pos
operator|=
name|cur_pos1
operator|+
name|cur_len
operator|/
literal|2
expr_stmt|;
name|FT_TRACE5
argument_list|(
operator|(
literal|"  STEM: edge %d (opos=%.2f) linked to %d (opos=%.2f)"
literal|" snapped to %.2f and %.2f\n"
operator|,
name|edge
operator|-
name|edges
operator|,
name|edge
operator|->
name|opos
operator|/
literal|64.0
operator|,
name|edge2
operator|-
name|edges
operator|,
name|edge2
operator|->
name|opos
operator|/
literal|64.0
operator|,
name|edge
operator|->
name|pos
operator|/
literal|64.0
operator|,
name|edge2
operator|->
name|pos
operator|/
literal|64.0
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|org_pos
operator|=
name|anchor
operator|->
name|pos
operator|+
operator|(
name|edge
operator|->
name|opos
operator|-
name|anchor
operator|->
name|opos
operator|)
expr_stmt|;
name|org_len
operator|=
name|edge2
operator|->
name|opos
operator|-
name|edge
operator|->
name|opos
expr_stmt|;
name|org_center
operator|=
name|org_pos
operator|+
operator|(
name|org_len
operator|>>
literal|1
operator|)
expr_stmt|;
name|cur_len
operator|=
name|af_latin_compute_stem_width
argument_list|(
name|hints
argument_list|,
name|dim
argument_list|,
name|org_len
argument_list|,
name|edge
operator|->
name|flags
argument_list|,
name|edge2
operator|->
name|flags
argument_list|)
expr_stmt|;
name|cur_pos1
operator|=
name|FT_PIX_ROUND
argument_list|(
name|org_pos
argument_list|)
expr_stmt|;
name|delta1
operator|=
name|cur_pos1
operator|+
operator|(
name|cur_len
operator|>>
literal|1
operator|)
operator|-
name|org_center
expr_stmt|;
if|if
condition|(
name|delta1
operator|<
literal|0
condition|)
name|delta1
operator|=
operator|-
name|delta1
expr_stmt|;
name|cur_pos2
operator|=
name|FT_PIX_ROUND
argument_list|(
name|org_pos
operator|+
name|org_len
argument_list|)
operator|-
name|cur_len
expr_stmt|;
name|delta2
operator|=
name|cur_pos2
operator|+
operator|(
name|cur_len
operator|>>
literal|1
operator|)
operator|-
name|org_center
expr_stmt|;
if|if
condition|(
name|delta2
operator|<
literal|0
condition|)
name|delta2
operator|=
operator|-
name|delta2
expr_stmt|;
name|edge
operator|->
name|pos
operator|=
operator|(
name|delta1
operator|<
name|delta2
operator|)
condition|?
name|cur_pos1
else|:
name|cur_pos2
expr_stmt|;
name|edge2
operator|->
name|pos
operator|=
name|edge
operator|->
name|pos
operator|+
name|cur_len
expr_stmt|;
name|FT_TRACE5
argument_list|(
operator|(
literal|"  STEM: edge %d (opos=%.2f) linked to %d (opos=%.2f)"
literal|" snapped to %.2f and %.2f\n"
operator|,
name|edge
operator|-
name|edges
operator|,
name|edge
operator|->
name|opos
operator|/
literal|64.0
operator|,
name|edge2
operator|-
name|edges
operator|,
name|edge2
operator|->
name|opos
operator|/
literal|64.0
operator|,
name|edge
operator|->
name|pos
operator|/
literal|64.0
operator|,
name|edge2
operator|->
name|pos
operator|/
literal|64.0
operator|)
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|FT_DEBUG_LEVEL_TRACE
name|num_actions
operator|++
expr_stmt|;
endif|#
directive|endif
name|edge
operator|->
name|flags
operator||=
name|AF_EDGE_DONE
expr_stmt|;
name|edge2
operator|->
name|flags
operator||=
name|AF_EDGE_DONE
expr_stmt|;
if|if
condition|(
name|edge
operator|>
name|edges
operator|&&
name|edge
operator|->
name|pos
operator|<
name|edge
index|[
operator|-
literal|1
index|]
operator|.
name|pos
condition|)
block|{
ifdef|#
directive|ifdef
name|FT_DEBUG_LEVEL_TRACE
name|FT_TRACE5
argument_list|(
operator|(
literal|"  BOUND: edge %d (pos=%.2f) moved to %.2f\n"
operator|,
name|edge
operator|-
name|edges
operator|,
name|edge
operator|->
name|pos
operator|/
literal|64.0
operator|,
name|edge
index|[
operator|-
literal|1
index|]
operator|.
name|pos
operator|/
literal|64.0
operator|)
argument_list|)
expr_stmt|;
name|num_actions
operator|++
expr_stmt|;
endif|#
directive|endif
name|edge
operator|->
name|pos
operator|=
name|edge
index|[
operator|-
literal|1
index|]
operator|.
name|pos
expr_stmt|;
block|}
block|}
block|}
comment|/* make sure that lowercase m's maintain their symmetry */
comment|/* In general, lowercase m's have six vertical edges if they are sans */
comment|/* serif, or twelve if they are with serifs.  This implementation is  */
comment|/* based on that assumption, and seems to work very well with most    */
comment|/* faces.  However, if for a certain face this assumption is not      */
comment|/* true, the m is just rendered like before.  In addition, any stem   */
comment|/* correction will only be applied to symmetrical glyphs (even if the */
comment|/* glyph is not an m), so the potential for unwanted distortion is    */
comment|/* relatively low.                                                    */
comment|/* We don't handle horizontal edges since we can't easily assure that */
comment|/* the third (lowest) stem aligns with the base line; it might end up */
comment|/* one pixel higher or lower.                                         */
name|n_edges
operator|=
name|edge_limit
operator|-
name|edges
expr_stmt|;
if|if
condition|(
name|dim
operator|==
name|AF_DIMENSION_HORZ
operator|&&
operator|(
name|n_edges
operator|==
literal|6
operator|||
name|n_edges
operator|==
literal|12
operator|)
condition|)
block|{
name|AF_Edge
name|edge1
decl_stmt|,
name|edge2
decl_stmt|,
name|edge3
decl_stmt|;
name|FT_Pos
name|dist1
decl_stmt|,
name|dist2
decl_stmt|,
name|span
decl_stmt|,
name|delta
decl_stmt|;
if|if
condition|(
name|n_edges
operator|==
literal|6
condition|)
block|{
name|edge1
operator|=
name|edges
expr_stmt|;
name|edge2
operator|=
name|edges
operator|+
literal|2
expr_stmt|;
name|edge3
operator|=
name|edges
operator|+
literal|4
expr_stmt|;
block|}
else|else
block|{
name|edge1
operator|=
name|edges
operator|+
literal|1
expr_stmt|;
name|edge2
operator|=
name|edges
operator|+
literal|5
expr_stmt|;
name|edge3
operator|=
name|edges
operator|+
literal|9
expr_stmt|;
block|}
name|dist1
operator|=
name|edge2
operator|->
name|opos
operator|-
name|edge1
operator|->
name|opos
expr_stmt|;
name|dist2
operator|=
name|edge3
operator|->
name|opos
operator|-
name|edge2
operator|->
name|opos
expr_stmt|;
name|span
operator|=
name|dist1
operator|-
name|dist2
expr_stmt|;
if|if
condition|(
name|span
operator|<
literal|0
condition|)
name|span
operator|=
operator|-
name|span
expr_stmt|;
if|if
condition|(
name|span
operator|<
literal|8
condition|)
block|{
name|delta
operator|=
name|edge3
operator|->
name|pos
operator|-
operator|(
literal|2
operator|*
name|edge2
operator|->
name|pos
operator|-
name|edge1
operator|->
name|pos
operator|)
expr_stmt|;
name|edge3
operator|->
name|pos
operator|-=
name|delta
expr_stmt|;
if|if
condition|(
name|edge3
operator|->
name|link
condition|)
name|edge3
operator|->
name|link
operator|->
name|pos
operator|-=
name|delta
expr_stmt|;
comment|/* move the serifs along with the stem */
if|if
condition|(
name|n_edges
operator|==
literal|12
condition|)
block|{
operator|(
name|edges
operator|+
literal|8
operator|)
operator|->
name|pos
operator|-=
name|delta
expr_stmt|;
operator|(
name|edges
operator|+
literal|11
operator|)
operator|->
name|pos
operator|-=
name|delta
expr_stmt|;
block|}
name|edge3
operator|->
name|flags
operator||=
name|AF_EDGE_DONE
expr_stmt|;
if|if
condition|(
name|edge3
operator|->
name|link
condition|)
name|edge3
operator|->
name|link
operator|->
name|flags
operator||=
name|AF_EDGE_DONE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|has_serifs
operator|||
operator|!
name|anchor
condition|)
block|{
comment|/*        *  now hint the remaining edges (serifs and single) in order        *  to complete our processing        */
for|for
control|(
name|edge
operator|=
name|edges
init|;
name|edge
operator|<
name|edge_limit
condition|;
name|edge
operator|++
control|)
block|{
name|FT_Pos
name|delta
decl_stmt|;
if|if
condition|(
name|edge
operator|->
name|flags
operator|&
name|AF_EDGE_DONE
condition|)
continue|continue;
name|delta
operator|=
literal|1000
expr_stmt|;
if|if
condition|(
name|edge
operator|->
name|serif
condition|)
block|{
name|delta
operator|=
name|edge
operator|->
name|serif
operator|->
name|opos
operator|-
name|edge
operator|->
name|opos
expr_stmt|;
if|if
condition|(
name|delta
operator|<
literal|0
condition|)
name|delta
operator|=
operator|-
name|delta
expr_stmt|;
block|}
if|if
condition|(
name|delta
operator|<
literal|64
operator|+
literal|16
condition|)
block|{
name|af_latin_align_serif_edge
argument_list|(
name|hints
argument_list|,
name|edge
operator|->
name|serif
argument_list|,
name|edge
argument_list|)
expr_stmt|;
name|FT_TRACE5
argument_list|(
operator|(
literal|"  SERIF: edge %d (opos=%.2f) serif to %d (opos=%.2f)"
literal|" aligned to %.2f\n"
operator|,
name|edge
operator|-
name|edges
operator|,
name|edge
operator|->
name|opos
operator|/
literal|64.0
operator|,
name|edge
operator|->
name|serif
operator|-
name|edges
operator|,
name|edge
operator|->
name|serif
operator|->
name|opos
operator|/
literal|64.0
operator|,
name|edge
operator|->
name|pos
operator|/
literal|64.0
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|anchor
condition|)
block|{
name|edge
operator|->
name|pos
operator|=
name|FT_PIX_ROUND
argument_list|(
name|edge
operator|->
name|opos
argument_list|)
expr_stmt|;
name|anchor
operator|=
name|edge
expr_stmt|;
name|FT_TRACE5
argument_list|(
operator|(
literal|"  SERIF_ANCHOR: edge %d (opos=%.2f)"
literal|" snapped to %.2f\n"
operator|,
name|edge
operator|-
name|edges
operator|,
name|edge
operator|->
name|opos
operator|/
literal|64.0
operator|,
name|edge
operator|->
name|pos
operator|/
literal|64.0
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|AF_Edge
name|before
decl_stmt|,
name|after
decl_stmt|;
for|for
control|(
name|before
operator|=
name|edge
operator|-
literal|1
init|;
name|before
operator|>=
name|edges
condition|;
name|before
operator|--
control|)
if|if
condition|(
name|before
operator|->
name|flags
operator|&
name|AF_EDGE_DONE
condition|)
break|break;
for|for
control|(
name|after
operator|=
name|edge
operator|+
literal|1
init|;
name|after
operator|<
name|edge_limit
condition|;
name|after
operator|++
control|)
if|if
condition|(
name|after
operator|->
name|flags
operator|&
name|AF_EDGE_DONE
condition|)
break|break;
if|if
condition|(
name|before
operator|>=
name|edges
operator|&&
name|before
operator|<
name|edge
operator|&&
name|after
operator|<
name|edge_limit
operator|&&
name|after
operator|>
name|edge
condition|)
block|{
if|if
condition|(
name|after
operator|->
name|opos
operator|==
name|before
operator|->
name|opos
condition|)
name|edge
operator|->
name|pos
operator|=
name|before
operator|->
name|pos
expr_stmt|;
else|else
name|edge
operator|->
name|pos
operator|=
name|before
operator|->
name|pos
operator|+
name|FT_MulDiv
argument_list|(
name|edge
operator|->
name|opos
operator|-
name|before
operator|->
name|opos
argument_list|,
name|after
operator|->
name|pos
operator|-
name|before
operator|->
name|pos
argument_list|,
name|after
operator|->
name|opos
operator|-
name|before
operator|->
name|opos
argument_list|)
expr_stmt|;
name|FT_TRACE5
argument_list|(
operator|(
literal|"  SERIF_LINK1: edge %d (opos=%.2f) snapped to %.2f"
literal|" from %d (opos=%.2f)\n"
operator|,
name|edge
operator|-
name|edges
operator|,
name|edge
operator|->
name|opos
operator|/
literal|64.0
operator|,
name|edge
operator|->
name|pos
operator|/
literal|64.0
operator|,
name|before
operator|-
name|edges
operator|,
name|before
operator|->
name|opos
operator|/
literal|64.0
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|edge
operator|->
name|pos
operator|=
name|anchor
operator|->
name|pos
operator|+
operator|(
operator|(
name|edge
operator|->
name|opos
operator|-
name|anchor
operator|->
name|opos
operator|+
literal|16
operator|)
operator|&
operator|~
literal|31
operator|)
expr_stmt|;
name|FT_TRACE5
argument_list|(
operator|(
literal|"  SERIF_LINK2: edge %d (opos=%.2f)"
literal|" snapped to %.2f\n"
operator|,
name|edge
operator|-
name|edges
operator|,
name|edge
operator|->
name|opos
operator|/
literal|64.0
operator|,
name|edge
operator|->
name|pos
operator|/
literal|64.0
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|FT_DEBUG_LEVEL_TRACE
name|num_actions
operator|++
expr_stmt|;
endif|#
directive|endif
name|edge
operator|->
name|flags
operator||=
name|AF_EDGE_DONE
expr_stmt|;
if|if
condition|(
name|edge
operator|>
name|edges
operator|&&
name|edge
operator|->
name|pos
operator|<
name|edge
index|[
operator|-
literal|1
index|]
operator|.
name|pos
condition|)
block|{
ifdef|#
directive|ifdef
name|FT_DEBUG_LEVEL_TRACE
name|FT_TRACE5
argument_list|(
operator|(
literal|"  BOUND: edge %d (pos=%.2f) moved to %.2f\n"
operator|,
name|edge
operator|-
name|edges
operator|,
name|edge
operator|->
name|pos
operator|/
literal|64.0
operator|,
name|edge
index|[
operator|-
literal|1
index|]
operator|.
name|pos
operator|/
literal|64.0
operator|)
argument_list|)
expr_stmt|;
name|num_actions
operator|++
expr_stmt|;
endif|#
directive|endif
name|edge
operator|->
name|pos
operator|=
name|edge
index|[
operator|-
literal|1
index|]
operator|.
name|pos
expr_stmt|;
block|}
if|if
condition|(
name|edge
operator|+
literal|1
operator|<
name|edge_limit
operator|&&
name|edge
index|[
literal|1
index|]
operator|.
name|flags
operator|&
name|AF_EDGE_DONE
operator|&&
name|edge
operator|->
name|pos
operator|>
name|edge
index|[
literal|1
index|]
operator|.
name|pos
condition|)
block|{
ifdef|#
directive|ifdef
name|FT_DEBUG_LEVEL_TRACE
name|FT_TRACE5
argument_list|(
operator|(
literal|"  BOUND: edge %d (pos=%.2f) moved to %.2f\n"
operator|,
name|edge
operator|-
name|edges
operator|,
name|edge
operator|->
name|pos
operator|/
literal|64.0
operator|,
name|edge
index|[
literal|1
index|]
operator|.
name|pos
operator|/
literal|64.0
operator|)
argument_list|)
expr_stmt|;
name|num_actions
operator|++
expr_stmt|;
endif|#
directive|endif
name|edge
operator|->
name|pos
operator|=
name|edge
index|[
literal|1
index|]
operator|.
name|pos
expr_stmt|;
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|FT_DEBUG_LEVEL_TRACE
if|if
condition|(
operator|!
name|num_actions
condition|)
name|FT_TRACE5
argument_list|(
operator|(
literal|"  (none)\n"
operator|)
argument_list|)
expr_stmt|;
name|FT_TRACE5
argument_list|(
operator|(
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/* Apply the complete hinting algorithm to a latin glyph. */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|af_latin_hints_apply
name|af_latin_hints_apply
parameter_list|(
name|FT_UInt
name|glyph_index
parameter_list|,
name|AF_GlyphHints
name|hints
parameter_list|,
name|FT_Outline
modifier|*
name|outline
parameter_list|,
name|AF_LatinMetrics
name|metrics
parameter_list|)
block|{
name|FT_Error
name|error
decl_stmt|;
name|int
name|dim
decl_stmt|;
name|AF_LatinAxis
name|axis
decl_stmt|;
name|error
operator|=
name|af_glyph_hints_reload
argument_list|(
name|hints
argument_list|,
name|outline
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
comment|/* analyze glyph outline */
ifdef|#
directive|ifdef
name|AF_CONFIG_OPTION_USE_WARPER
if|if
condition|(
operator|(
name|metrics
operator|->
name|root
operator|.
name|scaler
operator|.
name|render_mode
operator|==
name|FT_RENDER_MODE_LIGHT
operator|&&
name|AF_HINTS_DO_WARP
argument_list|(
name|hints
argument_list|)
operator|)
operator|||
name|AF_HINTS_DO_HORIZONTAL
argument_list|(
name|hints
argument_list|)
condition|)
else|#
directive|else
if|if
condition|(
name|AF_HINTS_DO_HORIZONTAL
argument_list|(
name|hints
argument_list|)
condition|)
endif|#
directive|endif
block|{
name|axis
operator|=
operator|&
name|metrics
operator|->
name|axis
index|[
name|AF_DIMENSION_HORZ
index|]
expr_stmt|;
name|error
operator|=
name|af_latin_hints_detect_features
argument_list|(
name|hints
argument_list|,
name|axis
operator|->
name|width_count
argument_list|,
name|axis
operator|->
name|widths
argument_list|,
name|AF_DIMENSION_HORZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|AF_HINTS_DO_VERTICAL
argument_list|(
name|hints
argument_list|)
condition|)
block|{
name|axis
operator|=
operator|&
name|metrics
operator|->
name|axis
index|[
name|AF_DIMENSION_VERT
index|]
expr_stmt|;
name|error
operator|=
name|af_latin_hints_detect_features
argument_list|(
name|hints
argument_list|,
name|axis
operator|->
name|width_count
argument_list|,
name|axis
operator|->
name|widths
argument_list|,
name|AF_DIMENSION_VERT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
comment|/* apply blue zones to base characters only */
if|if
condition|(
operator|!
operator|(
name|metrics
operator|->
name|root
operator|.
name|globals
operator|->
name|glyph_styles
index|[
name|glyph_index
index|]
operator|&
name|AF_NONBASE
operator|)
condition|)
name|af_latin_hints_compute_blue_edges
argument_list|(
name|hints
argument_list|,
name|metrics
argument_list|)
expr_stmt|;
block|}
comment|/* grid-fit the outline */
for|for
control|(
name|dim
operator|=
literal|0
init|;
name|dim
operator|<
name|AF_DIMENSION_MAX
condition|;
name|dim
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|AF_CONFIG_OPTION_USE_WARPER
if|if
condition|(
name|dim
operator|==
name|AF_DIMENSION_HORZ
operator|&&
name|metrics
operator|->
name|root
operator|.
name|scaler
operator|.
name|render_mode
operator|==
name|FT_RENDER_MODE_LIGHT
operator|&&
name|AF_HINTS_DO_WARP
argument_list|(
name|hints
argument_list|)
condition|)
block|{
name|AF_WarperRec
name|warper
decl_stmt|;
name|FT_Fixed
name|scale
decl_stmt|;
name|FT_Pos
name|delta
decl_stmt|;
name|af_warper_compute
argument_list|(
operator|&
name|warper
argument_list|,
name|hints
argument_list|,
operator|(
name|AF_Dimension
operator|)
name|dim
argument_list|,
operator|&
name|scale
argument_list|,
operator|&
name|delta
argument_list|)
expr_stmt|;
name|af_glyph_hints_scale_dim
argument_list|(
name|hints
argument_list|,
operator|(
name|AF_Dimension
operator|)
name|dim
argument_list|,
name|scale
argument_list|,
name|delta
argument_list|)
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
comment|/* AF_CONFIG_OPTION_USE_WARPER */
if|if
condition|(
operator|(
name|dim
operator|==
name|AF_DIMENSION_HORZ
operator|&&
name|AF_HINTS_DO_HORIZONTAL
argument_list|(
name|hints
argument_list|)
operator|)
operator|||
operator|(
name|dim
operator|==
name|AF_DIMENSION_VERT
operator|&&
name|AF_HINTS_DO_VERTICAL
argument_list|(
name|hints
argument_list|)
operator|)
condition|)
block|{
name|af_latin_hint_edges
argument_list|(
name|hints
argument_list|,
operator|(
name|AF_Dimension
operator|)
name|dim
argument_list|)
expr_stmt|;
name|af_glyph_hints_align_edge_points
argument_list|(
name|hints
argument_list|,
operator|(
name|AF_Dimension
operator|)
name|dim
argument_list|)
expr_stmt|;
name|af_glyph_hints_align_strong_points
argument_list|(
name|hints
argument_list|,
operator|(
name|AF_Dimension
operator|)
name|dim
argument_list|)
expr_stmt|;
name|af_glyph_hints_align_weak_points
argument_list|(
name|hints
argument_list|,
operator|(
name|AF_Dimension
operator|)
name|dim
argument_list|)
expr_stmt|;
block|}
block|}
name|af_glyph_hints_save
argument_list|(
name|hints
argument_list|,
name|outline
argument_list|)
expr_stmt|;
name|Exit
label|:
return|return
name|error
return|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*****              L A T I N   S C R I P T   C L A S S              *****/
end_comment
begin_comment
comment|/*****                                                               *****/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_macro
name|AF_DEFINE_WRITING_SYSTEM_CLASS
argument_list|(
argument|af_latin_writing_system_class
argument_list|,
argument|AF_WRITING_SYSTEM_LATIN
argument_list|,
argument|sizeof ( AF_LatinMetricsRec )
argument_list|,
argument|(AF_WritingSystem_InitMetricsFunc) af_latin_metrics_init
argument_list|,
argument|(AF_WritingSystem_ScaleMetricsFunc)af_latin_metrics_scale
argument_list|,
argument|(AF_WritingSystem_DoneMetricsFunc) NULL
argument_list|,
argument|(AF_WritingSystem_InitHintsFunc)   af_latin_hints_init
argument_list|,
argument|(AF_WritingSystem_ApplyHintsFunc)  af_latin_hints_apply
argument_list|)
end_macro
begin_comment
comment|/* END */
end_comment
end_unit
