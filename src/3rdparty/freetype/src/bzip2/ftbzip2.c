begin_unit
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  ftbzip2.c                                                              */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*    FreeType support for .bz2 compressed files.                          */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  This optional component relies on libbz2.  It should mainly be used to */
end_comment
begin_comment
comment|/*  parse compressed PCF fonts, as found with many X11 server              */
end_comment
begin_comment
comment|/*  distributions.                                                         */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  Copyright 2010, 2012-2014 by                                           */
end_comment
begin_comment
comment|/*  Joel Klinghed.                                                         */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  Based on src/gzip/ftgzip.c, Copyright 2002 - 2010 by                   */
end_comment
begin_comment
comment|/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  This file is part of the FreeType project, and may only be used,       */
end_comment
begin_comment
comment|/*  modified, and distributed under the terms of the FreeType project      */
end_comment
begin_comment
comment|/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
end_comment
begin_comment
comment|/*  this file you indicate that you have read the license and              */
end_comment
begin_comment
comment|/*  understand and accept it fully.                                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<ft2build.h>
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_MEMORY_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_STREAM_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_DEBUG_H
end_include
begin_include
include|#
directive|include
include|FT_BZIP2_H
end_include
begin_include
include|#
directive|include
include|FT_CONFIG_STANDARD_LIBRARY_H
end_include
begin_include
include|#
directive|include
include|FT_MODULE_ERRORS_H
end_include
begin_undef
DECL|macro|__FTERRORS_H__
undef|#
directive|undef
name|__FTERRORS_H__
end_undef
begin_undef
DECL|macro|FT_ERR_PREFIX
undef|#
directive|undef
name|FT_ERR_PREFIX
end_undef
begin_define
DECL|macro|FT_ERR_PREFIX
define|#
directive|define
name|FT_ERR_PREFIX
value|Bzip2_Err_
end_define
begin_define
DECL|macro|FT_ERR_BASE
define|#
directive|define
name|FT_ERR_BASE
value|FT_Mod_Err_Bzip2
end_define
begin_include
include|#
directive|include
include|FT_ERRORS_H
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|FT_CONFIG_OPTION_USE_BZIP2
end_ifdef
begin_ifdef
ifdef|#
directive|ifdef
name|FT_CONFIG_OPTION_PIC
end_ifdef
begin_error
error|#
directive|error
literal|"bzip2 code does not support PIC yet"
end_error
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|BZ_NO_STDIO
define|#
directive|define
name|BZ_NO_STDIO
end_define
begin_comment
DECL|macro|BZ_NO_STDIO
comment|/* Do not need FILE */
end_comment
begin_include
include|#
directive|include
file|<bzlib.h>
end_include
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*****                                                                 *****/
end_comment
begin_comment
comment|/*****           B Z I P 2   M E M O R Y   M A N A G E M E N T         *****/
end_comment
begin_comment
comment|/*****                                                                 *****/
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/* it is better to use FreeType memory routines instead of raw      'malloc/free' */
end_comment
begin_typedef
DECL|typedef|alloc_func
typedef|typedef
name|void
modifier|*
function_decl|(
modifier|*
name|alloc_func
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_typedef
begin_typedef
DECL|typedef|free_func
typedef|typedef
name|void
function_decl|(
modifier|*
name|free_func
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_typedef
begin_function
specifier|static
name|void
modifier|*
DECL|function|ft_bzip2_alloc
name|ft_bzip2_alloc
parameter_list|(
name|FT_Memory
name|memory
parameter_list|,
name|int
name|items
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|FT_ULong
name|sz
init|=
operator|(
name|FT_ULong
operator|)
name|size
operator|*
name|items
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|FT_Pointer
name|p
init|=
name|NULL
decl_stmt|;
operator|(
name|void
operator|)
name|FT_ALLOC
argument_list|(
name|p
argument_list|,
name|sz
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|ft_bzip2_free
name|ft_bzip2_free
parameter_list|(
name|FT_Memory
name|memory
parameter_list|,
name|void
modifier|*
name|address
parameter_list|)
block|{
name|FT_MEM_FREE
argument_list|(
name|address
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*****                                                                 *****/
end_comment
begin_comment
comment|/*****              B Z I P 2   F I L E   D E S C R I P T O R          *****/
end_comment
begin_comment
comment|/*****                                                                 *****/
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_define
DECL|macro|FT_BZIP2_BUFFER_SIZE
define|#
directive|define
name|FT_BZIP2_BUFFER_SIZE
value|4096
end_define
begin_typedef
DECL|struct|FT_BZip2FileRec_
typedef|typedef
struct|struct
name|FT_BZip2FileRec_
block|{
DECL|member|source
name|FT_Stream
name|source
decl_stmt|;
comment|/* parent/source stream        */
DECL|member|stream
name|FT_Stream
name|stream
decl_stmt|;
comment|/* embedding stream            */
DECL|member|memory
name|FT_Memory
name|memory
decl_stmt|;
comment|/* memory allocator            */
DECL|member|bzstream
name|bz_stream
name|bzstream
decl_stmt|;
comment|/* bzlib input stream          */
DECL|member|input
name|FT_Byte
name|input
index|[
name|FT_BZIP2_BUFFER_SIZE
index|]
decl_stmt|;
comment|/* input read buffer  */
DECL|member|buffer
name|FT_Byte
name|buffer
index|[
name|FT_BZIP2_BUFFER_SIZE
index|]
decl_stmt|;
comment|/* output buffer      */
DECL|member|pos
name|FT_ULong
name|pos
decl_stmt|;
comment|/* position in output */
DECL|member|cursor
name|FT_Byte
modifier|*
name|cursor
decl_stmt|;
DECL|member|limit
name|FT_Byte
modifier|*
name|limit
decl_stmt|;
block|}
DECL|typedef|FT_BZip2FileRec
DECL|typedef|FT_BZip2File
name|FT_BZip2FileRec
operator|,
typedef|*
name|FT_BZip2File
typedef|;
end_typedef
begin_comment
comment|/* check and skip .bz2 header - we don't support `transparent' compression */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|ft_bzip2_check_header
name|ft_bzip2_check_header
parameter_list|(
name|FT_Stream
name|stream
parameter_list|)
block|{
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
name|FT_Byte
name|head
index|[
literal|4
index|]
decl_stmt|;
if|if
condition|(
name|FT_STREAM_SEEK
argument_list|(
literal|0
argument_list|)
operator|||
name|FT_STREAM_READ
argument_list|(
name|head
argument_list|,
literal|4
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
comment|/* head[0]&& head[1] are the magic numbers;    */
comment|/* head[2] is the version, and head[3] the blocksize */
if|if
condition|(
name|head
index|[
literal|0
index|]
operator|!=
literal|0x42
operator|||
name|head
index|[
literal|1
index|]
operator|!=
literal|0x5A
operator|||
name|head
index|[
literal|2
index|]
operator|!=
literal|0x68
condition|)
comment|/* only support bzip2 (huffman) */
block|{
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_File_Format
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|Exit
label|:
return|return
name|error
return|;
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|ft_bzip2_file_init
name|ft_bzip2_file_init
parameter_list|(
name|FT_BZip2File
name|zip
parameter_list|,
name|FT_Stream
name|stream
parameter_list|,
name|FT_Stream
name|source
parameter_list|)
block|{
name|bz_stream
modifier|*
name|bzstream
init|=
operator|&
name|zip
operator|->
name|bzstream
decl_stmt|;
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
name|zip
operator|->
name|stream
operator|=
name|stream
expr_stmt|;
name|zip
operator|->
name|source
operator|=
name|source
expr_stmt|;
name|zip
operator|->
name|memory
operator|=
name|stream
operator|->
name|memory
expr_stmt|;
name|zip
operator|->
name|limit
operator|=
name|zip
operator|->
name|buffer
operator|+
name|FT_BZIP2_BUFFER_SIZE
expr_stmt|;
name|zip
operator|->
name|cursor
operator|=
name|zip
operator|->
name|limit
expr_stmt|;
name|zip
operator|->
name|pos
operator|=
literal|0
expr_stmt|;
comment|/* check .bz2 header */
block|{
name|stream
operator|=
name|source
expr_stmt|;
name|error
operator|=
name|ft_bzip2_check_header
argument_list|(
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
if|if
condition|(
name|FT_STREAM_SEEK
argument_list|(
literal|0
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
block|}
comment|/* initialize bzlib */
name|bzstream
operator|->
name|bzalloc
operator|=
operator|(
name|alloc_func
operator|)
name|ft_bzip2_alloc
expr_stmt|;
name|bzstream
operator|->
name|bzfree
operator|=
operator|(
name|free_func
operator|)
name|ft_bzip2_free
expr_stmt|;
name|bzstream
operator|->
name|opaque
operator|=
name|zip
operator|->
name|memory
expr_stmt|;
name|bzstream
operator|->
name|avail_in
operator|=
literal|0
expr_stmt|;
name|bzstream
operator|->
name|next_in
operator|=
operator|(
name|char
operator|*
operator|)
name|zip
operator|->
name|buffer
expr_stmt|;
if|if
condition|(
name|BZ2_bzDecompressInit
argument_list|(
name|bzstream
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|!=
name|BZ_OK
operator|||
name|bzstream
operator|->
name|next_in
operator|==
name|NULL
condition|)
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_File_Format
argument_list|)
expr_stmt|;
name|Exit
label|:
return|return
name|error
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|ft_bzip2_file_done
name|ft_bzip2_file_done
parameter_list|(
name|FT_BZip2File
name|zip
parameter_list|)
block|{
name|bz_stream
modifier|*
name|bzstream
init|=
operator|&
name|zip
operator|->
name|bzstream
decl_stmt|;
name|BZ2_bzDecompressEnd
argument_list|(
name|bzstream
argument_list|)
expr_stmt|;
comment|/* clear the rest */
name|bzstream
operator|->
name|bzalloc
operator|=
name|NULL
expr_stmt|;
name|bzstream
operator|->
name|bzfree
operator|=
name|NULL
expr_stmt|;
name|bzstream
operator|->
name|opaque
operator|=
name|NULL
expr_stmt|;
name|bzstream
operator|->
name|next_in
operator|=
name|NULL
expr_stmt|;
name|bzstream
operator|->
name|next_out
operator|=
name|NULL
expr_stmt|;
name|bzstream
operator|->
name|avail_in
operator|=
literal|0
expr_stmt|;
name|bzstream
operator|->
name|avail_out
operator|=
literal|0
expr_stmt|;
name|zip
operator|->
name|memory
operator|=
name|NULL
expr_stmt|;
name|zip
operator|->
name|source
operator|=
name|NULL
expr_stmt|;
name|zip
operator|->
name|stream
operator|=
name|NULL
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|ft_bzip2_file_reset
name|ft_bzip2_file_reset
parameter_list|(
name|FT_BZip2File
name|zip
parameter_list|)
block|{
name|FT_Stream
name|stream
init|=
name|zip
operator|->
name|source
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
if|if
condition|(
operator|!
name|FT_STREAM_SEEK
argument_list|(
literal|0
argument_list|)
condition|)
block|{
name|bz_stream
modifier|*
name|bzstream
init|=
operator|&
name|zip
operator|->
name|bzstream
decl_stmt|;
name|BZ2_bzDecompressEnd
argument_list|(
name|bzstream
argument_list|)
expr_stmt|;
name|bzstream
operator|->
name|avail_in
operator|=
literal|0
expr_stmt|;
name|bzstream
operator|->
name|next_in
operator|=
operator|(
name|char
operator|*
operator|)
name|zip
operator|->
name|input
expr_stmt|;
name|bzstream
operator|->
name|avail_out
operator|=
literal|0
expr_stmt|;
name|bzstream
operator|->
name|next_out
operator|=
operator|(
name|char
operator|*
operator|)
name|zip
operator|->
name|buffer
expr_stmt|;
name|zip
operator|->
name|limit
operator|=
name|zip
operator|->
name|buffer
operator|+
name|FT_BZIP2_BUFFER_SIZE
expr_stmt|;
name|zip
operator|->
name|cursor
operator|=
name|zip
operator|->
name|limit
expr_stmt|;
name|zip
operator|->
name|pos
operator|=
literal|0
expr_stmt|;
name|BZ2_bzDecompressInit
argument_list|(
name|bzstream
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|ft_bzip2_file_fill_input
name|ft_bzip2_file_fill_input
parameter_list|(
name|FT_BZip2File
name|zip
parameter_list|)
block|{
name|bz_stream
modifier|*
name|bzstream
init|=
operator|&
name|zip
operator|->
name|bzstream
decl_stmt|;
name|FT_Stream
name|stream
init|=
name|zip
operator|->
name|source
decl_stmt|;
name|FT_ULong
name|size
decl_stmt|;
if|if
condition|(
name|stream
operator|->
name|read
condition|)
block|{
name|size
operator|=
name|stream
operator|->
name|read
argument_list|(
name|stream
argument_list|,
name|stream
operator|->
name|pos
argument_list|,
name|zip
operator|->
name|input
argument_list|,
name|FT_BZIP2_BUFFER_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_Stream_Operation
argument_list|)
return|;
block|}
else|else
block|{
name|size
operator|=
name|stream
operator|->
name|size
operator|-
name|stream
operator|->
name|pos
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|FT_BZIP2_BUFFER_SIZE
condition|)
name|size
operator|=
name|FT_BZIP2_BUFFER_SIZE
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
return|return
name|FT_THROW
argument_list|(
name|Invalid_Stream_Operation
argument_list|)
return|;
name|FT_MEM_COPY
argument_list|(
name|zip
operator|->
name|input
argument_list|,
name|stream
operator|->
name|base
operator|+
name|stream
operator|->
name|pos
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
name|stream
operator|->
name|pos
operator|+=
name|size
expr_stmt|;
name|bzstream
operator|->
name|next_in
operator|=
operator|(
name|char
operator|*
operator|)
name|zip
operator|->
name|input
expr_stmt|;
name|bzstream
operator|->
name|avail_in
operator|=
name|size
expr_stmt|;
return|return
name|FT_Err_Ok
return|;
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|ft_bzip2_file_fill_output
name|ft_bzip2_file_fill_output
parameter_list|(
name|FT_BZip2File
name|zip
parameter_list|)
block|{
name|bz_stream
modifier|*
name|bzstream
init|=
operator|&
name|zip
operator|->
name|bzstream
decl_stmt|;
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
name|zip
operator|->
name|cursor
operator|=
name|zip
operator|->
name|buffer
expr_stmt|;
name|bzstream
operator|->
name|next_out
operator|=
operator|(
name|char
operator|*
operator|)
name|zip
operator|->
name|cursor
expr_stmt|;
name|bzstream
operator|->
name|avail_out
operator|=
name|FT_BZIP2_BUFFER_SIZE
expr_stmt|;
while|while
condition|(
name|bzstream
operator|->
name|avail_out
operator|>
literal|0
condition|)
block|{
name|int
name|err
decl_stmt|;
if|if
condition|(
name|bzstream
operator|->
name|avail_in
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|ft_bzip2_file_fill_input
argument_list|(
name|zip
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
name|err
operator|=
name|BZ2_bzDecompress
argument_list|(
name|bzstream
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|BZ_STREAM_END
condition|)
block|{
name|zip
operator|->
name|limit
operator|=
operator|(
name|FT_Byte
operator|*
operator|)
name|bzstream
operator|->
name|next_out
expr_stmt|;
if|if
condition|(
name|zip
operator|->
name|limit
operator|==
name|zip
operator|->
name|cursor
condition|)
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Stream_Operation
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|err
operator|!=
name|BZ_OK
condition|)
block|{
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Stream_Operation
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|error
return|;
block|}
end_function
begin_comment
comment|/* fill output buffer; `count' must be<= FT_BZIP2_BUFFER_SIZE */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|ft_bzip2_file_skip_output
name|ft_bzip2_file_skip_output
parameter_list|(
name|FT_BZip2File
name|zip
parameter_list|,
name|FT_ULong
name|count
parameter_list|)
block|{
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
name|FT_ULong
name|delta
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|delta
operator|=
call|(
name|FT_ULong
call|)
argument_list|(
name|zip
operator|->
name|limit
operator|-
name|zip
operator|->
name|cursor
argument_list|)
expr_stmt|;
if|if
condition|(
name|delta
operator|>=
name|count
condition|)
name|delta
operator|=
name|count
expr_stmt|;
name|zip
operator|->
name|cursor
operator|+=
name|delta
expr_stmt|;
name|zip
operator|->
name|pos
operator|+=
name|delta
expr_stmt|;
name|count
operator|-=
name|delta
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
break|break;
name|error
operator|=
name|ft_bzip2_file_fill_output
argument_list|(
name|zip
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
return|return
name|error
return|;
block|}
end_function
begin_function
specifier|static
name|FT_ULong
DECL|function|ft_bzip2_file_io
name|ft_bzip2_file_io
parameter_list|(
name|FT_BZip2File
name|zip
parameter_list|,
name|FT_ULong
name|pos
parameter_list|,
name|FT_Byte
modifier|*
name|buffer
parameter_list|,
name|FT_ULong
name|count
parameter_list|)
block|{
name|FT_ULong
name|result
init|=
literal|0
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
comment|/* Reset inflate stream if we're seeking backwards.        */
comment|/* Yes, that is not too efficient, but it saves memory :-) */
if|if
condition|(
name|pos
operator|<
name|zip
operator|->
name|pos
condition|)
block|{
name|error
operator|=
name|ft_bzip2_file_reset
argument_list|(
name|zip
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
block|}
comment|/* skip unwanted bytes */
if|if
condition|(
name|pos
operator|>
name|zip
operator|->
name|pos
condition|)
block|{
name|error
operator|=
name|ft_bzip2_file_skip_output
argument_list|(
name|zip
argument_list|,
call|(
name|FT_ULong
call|)
argument_list|(
name|pos
operator|-
name|zip
operator|->
name|pos
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|count
operator|==
literal|0
condition|)
goto|goto
name|Exit
goto|;
comment|/* now read the data */
for|for
control|(
init|;
condition|;
control|)
block|{
name|FT_ULong
name|delta
decl_stmt|;
name|delta
operator|=
call|(
name|FT_ULong
call|)
argument_list|(
name|zip
operator|->
name|limit
operator|-
name|zip
operator|->
name|cursor
argument_list|)
expr_stmt|;
if|if
condition|(
name|delta
operator|>=
name|count
condition|)
name|delta
operator|=
name|count
expr_stmt|;
name|FT_MEM_COPY
argument_list|(
name|buffer
argument_list|,
name|zip
operator|->
name|cursor
argument_list|,
name|delta
argument_list|)
expr_stmt|;
name|buffer
operator|+=
name|delta
expr_stmt|;
name|result
operator|+=
name|delta
expr_stmt|;
name|zip
operator|->
name|cursor
operator|+=
name|delta
expr_stmt|;
name|zip
operator|->
name|pos
operator|+=
name|delta
expr_stmt|;
name|count
operator|-=
name|delta
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
break|break;
name|error
operator|=
name|ft_bzip2_file_fill_output
argument_list|(
name|zip
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
name|Exit
label|:
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*****                                                                 *****/
end_comment
begin_comment
comment|/*****               B Z   E M B E D D I N G   S T R E A M             *****/
end_comment
begin_comment
comment|/*****                                                                 *****/
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_function
specifier|static
name|void
DECL|function|ft_bzip2_stream_close
name|ft_bzip2_stream_close
parameter_list|(
name|FT_Stream
name|stream
parameter_list|)
block|{
name|FT_BZip2File
name|zip
init|=
operator|(
name|FT_BZip2File
operator|)
name|stream
operator|->
name|descriptor
operator|.
name|pointer
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|stream
operator|->
name|memory
decl_stmt|;
if|if
condition|(
name|zip
condition|)
block|{
comment|/* finalize bzip file descriptor */
name|ft_bzip2_file_done
argument_list|(
name|zip
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|zip
argument_list|)
expr_stmt|;
name|stream
operator|->
name|descriptor
operator|.
name|pointer
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function
begin_function
specifier|static
name|FT_ULong
DECL|function|ft_bzip2_stream_io
name|ft_bzip2_stream_io
parameter_list|(
name|FT_Stream
name|stream
parameter_list|,
name|FT_ULong
name|pos
parameter_list|,
name|FT_Byte
modifier|*
name|buffer
parameter_list|,
name|FT_ULong
name|count
parameter_list|)
block|{
name|FT_BZip2File
name|zip
init|=
operator|(
name|FT_BZip2File
operator|)
name|stream
operator|->
name|descriptor
operator|.
name|pointer
decl_stmt|;
return|return
name|ft_bzip2_file_io
argument_list|(
name|zip
argument_list|,
name|pos
argument_list|,
name|buffer
argument_list|,
name|count
argument_list|)
return|;
block|}
end_function
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_Stream_OpenBzip2
argument_list|(
argument|FT_Stream  stream
argument_list|,
argument|FT_Stream  source
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
decl_stmt|;
name|FT_Memory
name|memory
decl_stmt|;
name|FT_BZip2File
name|zip
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|stream
operator|||
operator|!
name|source
condition|)
block|{
name|error
operator|=
name|FT_THROW
argument_list|(
name|Invalid_Stream_Handle
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|memory
operator|=
name|source
operator|->
name|memory
expr_stmt|;
comment|/*      *  check the header right now; this prevents allocating unnecessary      *  objects when we don't need them      */
name|error
operator|=
name|ft_bzip2_check_header
argument_list|(
name|source
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Exit
goto|;
name|FT_ZERO
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|stream
operator|->
name|memory
operator|=
name|memory
expr_stmt|;
if|if
condition|(
operator|!
name|FT_QNEW
argument_list|(
name|zip
argument_list|)
condition|)
block|{
name|error
operator|=
name|ft_bzip2_file_init
argument_list|(
name|zip
argument_list|,
name|stream
argument_list|,
name|source
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|FT_FREE
argument_list|(
name|zip
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|stream
operator|->
name|descriptor
operator|.
name|pointer
operator|=
name|zip
expr_stmt|;
block|}
name|stream
operator|->
name|size
operator|=
literal|0x7FFFFFFFL
expr_stmt|;
comment|/* don't know the real size! */
name|stream
operator|->
name|pos
operator|=
literal|0
expr_stmt|;
name|stream
operator|->
name|base
operator|=
literal|0
expr_stmt|;
name|stream
operator|->
name|read
operator|=
name|ft_bzip2_stream_io
expr_stmt|;
name|stream
operator|->
name|close
operator|=
name|ft_bzip2_stream_close
expr_stmt|;
name|Exit
label|:
return|return
name|error
return|;
block|}
end_block
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* !FT_CONFIG_OPTION_USE_BZIP2 */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_Stream_OpenBzip2
argument_list|(
argument|FT_Stream  stream
argument_list|,
argument|FT_Stream  source
argument_list|)
end_macro
begin_block
block|{
name|FT_UNUSED
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|source
argument_list|)
expr_stmt|;
return|return
name|FT_THROW
argument_list|(
name|Unimplemented_Feature
argument_list|)
return|;
block|}
end_block
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* !FT_CONFIG_OPTION_USE_BZIP2 */
end_comment
begin_comment
comment|/* END */
end_comment
end_unit
