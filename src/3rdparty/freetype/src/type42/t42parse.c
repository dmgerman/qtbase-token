begin_unit
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  t42parse.c                                                             */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*    Type 42 font parser (body).                                          */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  Copyright 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 by            */
end_comment
begin_comment
comment|/*  Roberto Alameda.                                                       */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  This file is part of the FreeType project, and may only be used,       */
end_comment
begin_comment
comment|/*  modified, and distributed under the terms of the FreeType project      */
end_comment
begin_comment
comment|/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
end_comment
begin_comment
comment|/*  this file you indicate that you have read the license and              */
end_comment
begin_comment
comment|/*  understand and accept it fully.                                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"t42parse.h"
end_include
begin_include
include|#
directive|include
file|"t42error.h"
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_DEBUG_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_STREAM_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_POSTSCRIPT_AUX_H
end_include
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
end_comment
begin_comment
comment|/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
end_comment
begin_comment
comment|/* messages during execution.                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_undef
DECL|macro|FT_COMPONENT
undef|#
directive|undef
name|FT_COMPONENT
end_undef
begin_define
DECL|macro|FT_COMPONENT
define|#
directive|define
name|FT_COMPONENT
value|trace_t42
end_define
begin_function_decl
specifier|static
name|void
name|t42_parse_font_matrix
parameter_list|(
name|T42_Face
name|face
parameter_list|,
name|T42_Loader
name|loader
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|void
name|t42_parse_encoding
parameter_list|(
name|T42_Face
name|face
parameter_list|,
name|T42_Loader
name|loader
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|void
name|t42_parse_charstrings
parameter_list|(
name|T42_Face
name|face
parameter_list|,
name|T42_Loader
name|loader
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|void
name|t42_parse_sfnts
parameter_list|(
name|T42_Face
name|face
parameter_list|,
name|T42_Loader
name|loader
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/* as Type42 fonts have no Private dict,         */
end_comment
begin_comment
comment|/* we set the last argument of T1_FIELD_XXX to 0 */
end_comment
begin_decl_stmt
specifier|static
specifier|const
DECL|variable|t42_keywords
name|T1_FieldRec
name|t42_keywords
index|[]
init|=
block|{
DECL|macro|FT_STRUCTURE
undef|#
directive|undef
name|FT_STRUCTURE
DECL|macro|FT_STRUCTURE
define|#
directive|define
name|FT_STRUCTURE
value|T1_FontInfo
DECL|macro|T1CODE
undef|#
directive|undef
name|T1CODE
DECL|macro|T1CODE
define|#
directive|define
name|T1CODE
value|T1_FIELD_LOCATION_FONT_INFO
name|T1_FIELD_STRING
argument_list|(
literal|"version"
argument_list|,
argument|version
argument_list|,
literal|0
argument_list|)
name|T1_FIELD_STRING
argument_list|(
literal|"Notice"
argument_list|,
argument|notice
argument_list|,
literal|0
argument_list|)
name|T1_FIELD_STRING
argument_list|(
literal|"FullName"
argument_list|,
argument|full_name
argument_list|,
literal|0
argument_list|)
name|T1_FIELD_STRING
argument_list|(
literal|"FamilyName"
argument_list|,
argument|family_name
argument_list|,
literal|0
argument_list|)
name|T1_FIELD_STRING
argument_list|(
literal|"Weight"
argument_list|,
argument|weight
argument_list|,
literal|0
argument_list|)
name|T1_FIELD_NUM
argument_list|(
literal|"ItalicAngle"
argument_list|,
argument|italic_angle
argument_list|,
literal|0
argument_list|)
name|T1_FIELD_BOOL
argument_list|(
literal|"isFixedPitch"
argument_list|,
argument|is_fixed_pitch
argument_list|,
literal|0
argument_list|)
name|T1_FIELD_NUM
argument_list|(
literal|"UnderlinePosition"
argument_list|,
argument|underline_position
argument_list|,
literal|0
argument_list|)
name|T1_FIELD_NUM
argument_list|(
literal|"UnderlineThickness"
argument_list|,
argument|underline_thickness
argument_list|,
literal|0
argument_list|)
DECL|macro|FT_STRUCTURE
undef|#
directive|undef
name|FT_STRUCTURE
DECL|macro|FT_STRUCTURE
define|#
directive|define
name|FT_STRUCTURE
value|PS_FontExtraRec
DECL|macro|T1CODE
undef|#
directive|undef
name|T1CODE
DECL|macro|T1CODE
define|#
directive|define
name|T1CODE
value|T1_FIELD_LOCATION_FONT_EXTRA
name|T1_FIELD_NUM
argument_list|(
literal|"FSType"
argument_list|,
argument|fs_type
argument_list|,
literal|0
argument_list|)
DECL|macro|FT_STRUCTURE
undef|#
directive|undef
name|FT_STRUCTURE
DECL|macro|FT_STRUCTURE
define|#
directive|define
name|FT_STRUCTURE
value|T1_FontRec
DECL|macro|T1CODE
undef|#
directive|undef
name|T1CODE
DECL|macro|T1CODE
define|#
directive|define
name|T1CODE
value|T1_FIELD_LOCATION_FONT_DICT
name|T1_FIELD_KEY
argument_list|(
literal|"FontName"
argument_list|,
argument|font_name
argument_list|,
literal|0
argument_list|)
name|T1_FIELD_NUM
argument_list|(
literal|"PaintType"
argument_list|,
argument|paint_type
argument_list|,
literal|0
argument_list|)
name|T1_FIELD_NUM
argument_list|(
literal|"FontType"
argument_list|,
argument|font_type
argument_list|,
literal|0
argument_list|)
name|T1_FIELD_FIXED
argument_list|(
literal|"StrokeWidth"
argument_list|,
argument|stroke_width
argument_list|,
literal|0
argument_list|)
DECL|macro|FT_STRUCTURE
undef|#
directive|undef
name|FT_STRUCTURE
DECL|macro|FT_STRUCTURE
define|#
directive|define
name|FT_STRUCTURE
value|FT_BBox
DECL|macro|T1CODE
undef|#
directive|undef
name|T1CODE
DECL|macro|T1CODE
define|#
directive|define
name|T1CODE
value|T1_FIELD_LOCATION_BBOX
name|T1_FIELD_BBOX
argument_list|(
literal|"FontBBox"
argument_list|,
argument|xMin
argument_list|,
literal|0
argument_list|)
name|T1_FIELD_CALLBACK
argument_list|(
literal|"FontMatrix"
argument_list|,
argument|t42_parse_font_matrix
argument_list|,
literal|0
argument_list|)
name|T1_FIELD_CALLBACK
argument_list|(
literal|"Encoding"
argument_list|,
argument|t42_parse_encoding
argument_list|,
literal|0
argument_list|)
name|T1_FIELD_CALLBACK
argument_list|(
literal|"CharStrings"
argument_list|,
argument|t42_parse_charstrings
argument_list|,
literal|0
argument_list|)
name|T1_FIELD_CALLBACK
argument_list|(
literal|"sfnts"
argument_list|,
argument|t42_parse_sfnts
argument_list|,
literal|0
argument_list|)
block|{
literal|0
block|,
name|T1_FIELD_LOCATION_CID_INFO
block|,
name|T1_FIELD_TYPE_NONE
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt
begin_define
DECL|macro|T1_Add_Table
define|#
directive|define
name|T1_Add_Table
parameter_list|(
name|p
parameter_list|,
name|i
parameter_list|,
name|o
parameter_list|,
name|l
parameter_list|)
value|(p)->funcs.add( (p), i, o, l )
end_define
begin_define
DECL|macro|T1_Done_Table
define|#
directive|define
name|T1_Done_Table
parameter_list|(
name|p
parameter_list|)
define|\
value|do                        \           {                         \             if ( (p)->funcs.done )  \               (p)->funcs.done( p ); \           } while ( 0 )
end_define
begin_define
DECL|macro|T1_Release_Table
define|#
directive|define
name|T1_Release_Table
parameter_list|(
name|p
parameter_list|)
define|\
value|do                           \           {                            \             if ( (p)->funcs.release )  \               (p)->funcs.release( p ); \           } while ( 0 )
end_define
begin_define
DECL|macro|T1_Skip_Spaces
define|#
directive|define
name|T1_Skip_Spaces
parameter_list|(
name|p
parameter_list|)
value|(p)->root.funcs.skip_spaces(&(p)->root )
end_define
begin_define
DECL|macro|T1_Skip_PS_Token
define|#
directive|define
name|T1_Skip_PS_Token
parameter_list|(
name|p
parameter_list|)
value|(p)->root.funcs.skip_PS_token(&(p)->root )
end_define
begin_define
DECL|macro|T1_ToInt
define|#
directive|define
name|T1_ToInt
parameter_list|(
name|p
parameter_list|)
define|\
value|(p)->root.funcs.to_int(&(p)->root )
end_define
begin_define
DECL|macro|T1_ToBytes
define|#
directive|define
name|T1_ToBytes
parameter_list|(
name|p
parameter_list|,
name|b
parameter_list|,
name|m
parameter_list|,
name|n
parameter_list|,
name|d
parameter_list|)
define|\
value|(p)->root.funcs.to_bytes(&(p)->root, b, m, n, d )
end_define
begin_define
DECL|macro|T1_ToFixedArray
define|#
directive|define
name|T1_ToFixedArray
parameter_list|(
name|p
parameter_list|,
name|m
parameter_list|,
name|f
parameter_list|,
name|t
parameter_list|)
define|\
value|(p)->root.funcs.to_fixed_array(&(p)->root, m, f, t )
end_define
begin_define
DECL|macro|T1_ToToken
define|#
directive|define
name|T1_ToToken
parameter_list|(
name|p
parameter_list|,
name|t
parameter_list|)
define|\
value|(p)->root.funcs.to_token(&(p)->root, t )
end_define
begin_define
DECL|macro|T1_Load_Field
define|#
directive|define
name|T1_Load_Field
parameter_list|(
name|p
parameter_list|,
name|f
parameter_list|,
name|o
parameter_list|,
name|m
parameter_list|,
name|pf
parameter_list|)
define|\
value|(p)->root.funcs.load_field(&(p)->root, f, o, m, pf )
end_define
begin_define
DECL|macro|T1_Load_Field_Table
define|#
directive|define
name|T1_Load_Field_Table
parameter_list|(
name|p
parameter_list|,
name|f
parameter_list|,
name|o
parameter_list|,
name|m
parameter_list|,
name|pf
parameter_list|)
define|\
value|(p)->root.funcs.load_field_table(&(p)->root, f, o, m, pf )
end_define
begin_comment
comment|/********************* Parsing Functions ******************/
end_comment
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|t42_parser_init
argument_list|(
argument|T42_Parser     parser
argument_list|,
argument|FT_Stream      stream
argument_list|,
argument|FT_Memory      memory
argument_list|,
argument|PSAux_Service  psaux
argument_list|)
end_macro
begin_block
block|{
name|FT_Error
name|error
init|=
name|T42_Err_Ok
decl_stmt|;
name|FT_Long
name|size
decl_stmt|;
name|psaux
operator|->
name|ps_parser_funcs
operator|->
name|init
argument_list|(
operator|&
name|parser
operator|->
name|root
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|memory
argument_list|)
expr_stmt|;
name|parser
operator|->
name|stream
operator|=
name|stream
expr_stmt|;
name|parser
operator|->
name|base_len
operator|=
literal|0
expr_stmt|;
name|parser
operator|->
name|base_dict
operator|=
literal|0
expr_stmt|;
name|parser
operator|->
name|in_memory
operator|=
literal|0
expr_stmt|;
comment|/*******************************************************************/
comment|/*                                                                 */
comment|/* Here a short summary of what is going on:                       */
comment|/*                                                                 */
comment|/*   When creating a new Type 42 parser, we try to locate and load */
comment|/*   the base dictionary, loading the whole font into memory.      */
comment|/*                                                                 */
comment|/*   When `loading' the base dictionary, we only set up pointers   */
comment|/*   in the case of a memory-based stream.  Otherwise, we allocate */
comment|/*   and load the base dictionary in it.                           */
comment|/*                                                                 */
comment|/*   parser->in_memory is set if we have a memory stream.          */
comment|/*                                                                 */
if|if
condition|(
name|FT_STREAM_SEEK
argument_list|(
literal|0L
argument_list|)
operator|||
name|FT_FRAME_ENTER
argument_list|(
literal|17
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
if|if
condition|(
name|ft_memcmp
argument_list|(
name|stream
operator|->
name|cursor
argument_list|,
literal|"%!PS-TrueTypeFont"
argument_list|,
literal|17
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|FT_TRACE2
argument_list|(
operator|(
literal|"not a Type42 font\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|T42_Err_Unknown_File_Format
expr_stmt|;
block|}
name|FT_FRAME_EXIT
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|FT_STREAM_SEEK
argument_list|(
literal|0
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|size
operator|=
name|stream
operator|->
name|size
expr_stmt|;
comment|/* now, try to load `size' bytes of the `base' dictionary we */
comment|/* found previously                                          */
comment|/* if it is a memory-based resource, set up pointers */
if|if
condition|(
operator|!
name|stream
operator|->
name|read
condition|)
block|{
name|parser
operator|->
name|base_dict
operator|=
operator|(
name|FT_Byte
operator|*
operator|)
name|stream
operator|->
name|base
operator|+
name|stream
operator|->
name|pos
expr_stmt|;
name|parser
operator|->
name|base_len
operator|=
name|size
expr_stmt|;
name|parser
operator|->
name|in_memory
operator|=
literal|1
expr_stmt|;
comment|/* check that the `size' field is valid */
if|if
condition|(
name|FT_STREAM_SKIP
argument_list|(
name|size
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
block|}
else|else
block|{
comment|/* read segment in memory */
if|if
condition|(
name|FT_ALLOC
argument_list|(
name|parser
operator|->
name|base_dict
argument_list|,
name|size
argument_list|)
operator|||
name|FT_STREAM_READ
argument_list|(
name|parser
operator|->
name|base_dict
argument_list|,
name|size
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|parser
operator|->
name|base_len
operator|=
name|size
expr_stmt|;
block|}
name|parser
operator|->
name|root
operator|.
name|base
operator|=
name|parser
operator|->
name|base_dict
expr_stmt|;
name|parser
operator|->
name|root
operator|.
name|cursor
operator|=
name|parser
operator|->
name|base_dict
expr_stmt|;
name|parser
operator|->
name|root
operator|.
name|limit
operator|=
name|parser
operator|->
name|root
operator|.
name|cursor
operator|+
name|parser
operator|->
name|base_len
expr_stmt|;
name|Exit
label|:
if|if
condition|(
name|error
operator|&&
operator|!
name|parser
operator|->
name|in_memory
condition|)
name|FT_FREE
argument_list|(
name|parser
operator|->
name|base_dict
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_block
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|t42_parser_done
name|t42_parser_done
argument_list|(
argument|T42_Parser  parser
argument_list|)
end_macro
begin_block
block|{
name|FT_Memory
name|memory
init|=
name|parser
operator|->
name|root
operator|.
name|memory
decl_stmt|;
comment|/* free the base dictionary only when we have a disk stream */
if|if
condition|(
operator|!
name|parser
operator|->
name|in_memory
condition|)
name|FT_FREE
argument_list|(
name|parser
operator|->
name|base_dict
argument_list|)
expr_stmt|;
name|parser
operator|->
name|root
operator|.
name|funcs
operator|.
name|done
argument_list|(
operator|&
name|parser
operator|->
name|root
argument_list|)
expr_stmt|;
block|}
end_block
begin_function
specifier|static
name|int
DECL|function|t42_is_space
name|t42_is_space
parameter_list|(
name|FT_Byte
name|c
parameter_list|)
block|{
return|return
operator|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\r'
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|'\f'
operator|||
name|c
operator|==
literal|'\0'
operator|)
return|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|t42_parse_font_matrix
name|t42_parse_font_matrix
parameter_list|(
name|T42_Face
name|face
parameter_list|,
name|T42_Loader
name|loader
parameter_list|)
block|{
name|T42_Parser
name|parser
init|=
operator|&
name|loader
operator|->
name|parser
decl_stmt|;
name|FT_Matrix
modifier|*
name|matrix
init|=
operator|&
name|face
operator|->
name|type1
operator|.
name|font_matrix
decl_stmt|;
name|FT_Vector
modifier|*
name|offset
init|=
operator|&
name|face
operator|->
name|type1
operator|.
name|font_offset
decl_stmt|;
name|FT_Face
name|root
init|=
operator|(
name|FT_Face
operator|)
operator|&
name|face
operator|->
name|root
decl_stmt|;
name|FT_Fixed
name|temp
index|[
literal|6
index|]
decl_stmt|;
name|FT_Fixed
name|temp_scale
decl_stmt|;
operator|(
name|void
operator|)
name|T1_ToFixedArray
argument_list|(
name|parser
argument_list|,
literal|6
argument_list|,
name|temp
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|temp_scale
operator|=
name|FT_ABS
argument_list|(
name|temp
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
comment|/* Set Units per EM based on FontMatrix values.  We set the value to */
comment|/* 1000 / temp_scale, because temp_scale was already multiplied by   */
comment|/* 1000 (in t1_tofixed, from psobjs.c).                              */
name|root
operator|->
name|units_per_EM
operator|=
call|(
name|FT_UShort
call|)
argument_list|(
name|FT_DivFix
argument_list|(
literal|1000
operator|*
literal|0x10000L
argument_list|,
name|temp_scale
argument_list|)
operator|>>
literal|16
argument_list|)
expr_stmt|;
comment|/* we need to scale the values by 1.0/temp_scale */
if|if
condition|(
name|temp_scale
operator|!=
literal|0x10000L
condition|)
block|{
name|temp
index|[
literal|0
index|]
operator|=
name|FT_DivFix
argument_list|(
name|temp
index|[
literal|0
index|]
argument_list|,
name|temp_scale
argument_list|)
expr_stmt|;
name|temp
index|[
literal|1
index|]
operator|=
name|FT_DivFix
argument_list|(
name|temp
index|[
literal|1
index|]
argument_list|,
name|temp_scale
argument_list|)
expr_stmt|;
name|temp
index|[
literal|2
index|]
operator|=
name|FT_DivFix
argument_list|(
name|temp
index|[
literal|2
index|]
argument_list|,
name|temp_scale
argument_list|)
expr_stmt|;
name|temp
index|[
literal|4
index|]
operator|=
name|FT_DivFix
argument_list|(
name|temp
index|[
literal|4
index|]
argument_list|,
name|temp_scale
argument_list|)
expr_stmt|;
name|temp
index|[
literal|5
index|]
operator|=
name|FT_DivFix
argument_list|(
name|temp
index|[
literal|5
index|]
argument_list|,
name|temp_scale
argument_list|)
expr_stmt|;
name|temp
index|[
literal|3
index|]
operator|=
literal|0x10000L
expr_stmt|;
block|}
name|matrix
operator|->
name|xx
operator|=
name|temp
index|[
literal|0
index|]
expr_stmt|;
name|matrix
operator|->
name|yx
operator|=
name|temp
index|[
literal|1
index|]
expr_stmt|;
name|matrix
operator|->
name|xy
operator|=
name|temp
index|[
literal|2
index|]
expr_stmt|;
name|matrix
operator|->
name|yy
operator|=
name|temp
index|[
literal|3
index|]
expr_stmt|;
comment|/* note that the offsets must be expressed in integer font units */
name|offset
operator|->
name|x
operator|=
name|temp
index|[
literal|4
index|]
operator|>>
literal|16
expr_stmt|;
name|offset
operator|->
name|y
operator|=
name|temp
index|[
literal|5
index|]
operator|>>
literal|16
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|t42_parse_encoding
name|t42_parse_encoding
parameter_list|(
name|T42_Face
name|face
parameter_list|,
name|T42_Loader
name|loader
parameter_list|)
block|{
name|T42_Parser
name|parser
init|=
operator|&
name|loader
operator|->
name|parser
decl_stmt|;
name|FT_Byte
modifier|*
name|cur
decl_stmt|;
name|FT_Byte
modifier|*
name|limit
init|=
name|parser
operator|->
name|root
operator|.
name|limit
decl_stmt|;
name|PSAux_Service
name|psaux
init|=
operator|(
name|PSAux_Service
operator|)
name|face
operator|->
name|psaux
decl_stmt|;
name|T1_Skip_Spaces
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|cur
operator|=
name|parser
operator|->
name|root
operator|.
name|cursor
expr_stmt|;
if|if
condition|(
name|cur
operator|>=
name|limit
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"t42_parse_encoding: out of bounds\n"
operator|)
argument_list|)
expr_stmt|;
name|parser
operator|->
name|root
operator|.
name|error
operator|=
name|T42_Err_Invalid_File_Format
expr_stmt|;
return|return;
block|}
comment|/* if we have a number or `[', the encoding is an array, */
comment|/* and we must load it now                               */
if|if
condition|(
name|ft_isdigit
argument_list|(
operator|*
name|cur
argument_list|)
operator|||
operator|*
name|cur
operator|==
literal|'['
condition|)
block|{
name|T1_Encoding
name|encode
init|=
operator|&
name|face
operator|->
name|type1
operator|.
name|encoding
decl_stmt|;
name|FT_UInt
name|count
decl_stmt|,
name|n
decl_stmt|;
name|PS_Table
name|char_table
init|=
operator|&
name|loader
operator|->
name|encoding_table
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|parser
operator|->
name|root
operator|.
name|memory
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|FT_Bool
name|only_immediates
init|=
literal|0
decl_stmt|;
comment|/* read the number of entries in the encoding; should be 256 */
if|if
condition|(
operator|*
name|cur
operator|==
literal|'['
condition|)
block|{
name|count
operator|=
literal|256
expr_stmt|;
name|only_immediates
operator|=
literal|1
expr_stmt|;
name|parser
operator|->
name|root
operator|.
name|cursor
operator|++
expr_stmt|;
block|}
else|else
name|count
operator|=
operator|(
name|FT_UInt
operator|)
name|T1_ToInt
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|T1_Skip_Spaces
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|parser
operator|->
name|root
operator|.
name|cursor
operator|>=
name|limit
condition|)
return|return;
comment|/* we use a T1_Table to store our charnames */
name|loader
operator|->
name|num_chars
operator|=
name|encode
operator|->
name|num_chars
operator|=
name|count
expr_stmt|;
if|if
condition|(
name|FT_NEW_ARRAY
argument_list|(
name|encode
operator|->
name|char_index
argument_list|,
name|count
argument_list|)
operator|||
name|FT_NEW_ARRAY
argument_list|(
name|encode
operator|->
name|char_name
argument_list|,
name|count
argument_list|)
operator|||
name|FT_SET_ERROR
argument_list|(
name|psaux
operator|->
name|ps_table_funcs
operator|->
name|init
argument_list|(
name|char_table
argument_list|,
name|count
argument_list|,
name|memory
argument_list|)
argument_list|)
condition|)
block|{
name|parser
operator|->
name|root
operator|.
name|error
operator|=
name|error
expr_stmt|;
return|return;
block|}
comment|/* We need to `zero' out encoding_table.elements */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
block|{
name|char
modifier|*
name|notdef
init|=
operator|(
name|char
operator|*
operator|)
literal|".notdef"
decl_stmt|;
name|T1_Add_Table
argument_list|(
name|char_table
argument_list|,
name|n
argument_list|,
name|notdef
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
comment|/* Now we need to read records of the form                */
comment|/*                                                        */
comment|/*   ... charcode /charname ...                           */
comment|/*                                                        */
comment|/* for each entry in our table.                           */
comment|/*                                                        */
comment|/* We simply look for a number followed by an immediate   */
comment|/* name.  Note that this ignores correctly the sequence   */
comment|/* that is often seen in type42 fonts:                    */
comment|/*                                                        */
comment|/*   0 1 255 { 1 index exch /.notdef put } for dup        */
comment|/*                                                        */
comment|/* used to clean the encoding array before anything else. */
comment|/*                                                        */
comment|/* Alternatively, if the array is directly given as       */
comment|/*                                                        */
comment|/*   /Encoding [ ... ]                                    */
comment|/*                                                        */
comment|/* we only read immediates.                               */
name|n
operator|=
literal|0
expr_stmt|;
name|T1_Skip_Spaces
argument_list|(
name|parser
argument_list|)
expr_stmt|;
while|while
condition|(
name|parser
operator|->
name|root
operator|.
name|cursor
operator|<
name|limit
condition|)
block|{
name|cur
operator|=
name|parser
operator|->
name|root
operator|.
name|cursor
expr_stmt|;
comment|/* we stop when we encounter `def' or `]' */
if|if
condition|(
operator|*
name|cur
operator|==
literal|'d'
operator|&&
name|cur
operator|+
literal|3
operator|<
name|limit
condition|)
block|{
if|if
condition|(
name|cur
index|[
literal|1
index|]
operator|==
literal|'e'
operator|&&
name|cur
index|[
literal|2
index|]
operator|==
literal|'f'
operator|&&
name|t42_is_space
argument_list|(
name|cur
index|[
literal|3
index|]
argument_list|)
condition|)
block|{
name|FT_TRACE6
argument_list|(
operator|(
literal|"encoding end\n"
operator|)
argument_list|)
expr_stmt|;
name|cur
operator|+=
literal|3
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|*
name|cur
operator|==
literal|']'
condition|)
block|{
name|FT_TRACE6
argument_list|(
operator|(
literal|"encoding end\n"
operator|)
argument_list|)
expr_stmt|;
name|cur
operator|++
expr_stmt|;
break|break;
block|}
comment|/* check whether we have found an entry */
if|if
condition|(
name|ft_isdigit
argument_list|(
operator|*
name|cur
argument_list|)
operator|||
name|only_immediates
condition|)
block|{
name|FT_Int
name|charcode
decl_stmt|;
if|if
condition|(
name|only_immediates
condition|)
name|charcode
operator|=
name|n
expr_stmt|;
else|else
block|{
name|charcode
operator|=
operator|(
name|FT_Int
operator|)
name|T1_ToInt
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|T1_Skip_Spaces
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
name|cur
operator|=
name|parser
operator|->
name|root
operator|.
name|cursor
expr_stmt|;
if|if
condition|(
operator|*
name|cur
operator|==
literal|'/'
operator|&&
name|cur
operator|+
literal|2
operator|<
name|limit
operator|&&
name|n
operator|<
name|count
condition|)
block|{
name|FT_PtrDist
name|len
decl_stmt|;
name|cur
operator|++
expr_stmt|;
name|parser
operator|->
name|root
operator|.
name|cursor
operator|=
name|cur
expr_stmt|;
name|T1_Skip_PS_Token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|parser
operator|->
name|root
operator|.
name|error
condition|)
return|return;
name|len
operator|=
name|parser
operator|->
name|root
operator|.
name|cursor
operator|-
name|cur
expr_stmt|;
name|parser
operator|->
name|root
operator|.
name|error
operator|=
name|T1_Add_Table
argument_list|(
name|char_table
argument_list|,
name|charcode
argument_list|,
name|cur
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|parser
operator|->
name|root
operator|.
name|error
condition|)
return|return;
name|char_table
operator|->
name|elements
index|[
name|charcode
index|]
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|T1_Skip_PS_Token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|parser
operator|->
name|root
operator|.
name|error
condition|)
return|return;
block|}
name|T1_Skip_Spaces
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
name|face
operator|->
name|type1
operator|.
name|encoding_type
operator|=
name|T1_ENCODING_TYPE_ARRAY
expr_stmt|;
name|parser
operator|->
name|root
operator|.
name|cursor
operator|=
name|cur
expr_stmt|;
block|}
comment|/* Otherwise, we should have either `StandardEncoding', */
comment|/* `ExpertEncoding', or `ISOLatin1Encoding'             */
else|else
block|{
if|if
condition|(
name|cur
operator|+
literal|17
operator|<
name|limit
operator|&&
name|ft_strncmp
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|cur
argument_list|,
literal|"StandardEncoding"
argument_list|,
literal|16
argument_list|)
operator|==
literal|0
condition|)
name|face
operator|->
name|type1
operator|.
name|encoding_type
operator|=
name|T1_ENCODING_TYPE_STANDARD
expr_stmt|;
elseif|else
if|if
condition|(
name|cur
operator|+
literal|15
operator|<
name|limit
operator|&&
name|ft_strncmp
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|cur
argument_list|,
literal|"ExpertEncoding"
argument_list|,
literal|14
argument_list|)
operator|==
literal|0
condition|)
name|face
operator|->
name|type1
operator|.
name|encoding_type
operator|=
name|T1_ENCODING_TYPE_EXPERT
expr_stmt|;
elseif|else
if|if
condition|(
name|cur
operator|+
literal|18
operator|<
name|limit
operator|&&
name|ft_strncmp
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|cur
argument_list|,
literal|"ISOLatin1Encoding"
argument_list|,
literal|17
argument_list|)
operator|==
literal|0
condition|)
name|face
operator|->
name|type1
operator|.
name|encoding_type
operator|=
name|T1_ENCODING_TYPE_ISOLATIN1
expr_stmt|;
else|else
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"t42_parse_encoding: invalid token\n"
operator|)
argument_list|)
expr_stmt|;
name|parser
operator|->
name|root
operator|.
name|error
operator|=
name|T42_Err_Invalid_File_Format
expr_stmt|;
block|}
block|}
block|}
end_function
begin_typedef
DECL|enum|T42_Load_Status_
typedef|typedef
enum|enum
name|T42_Load_Status_
block|{
DECL|enumerator|BEFORE_START
name|BEFORE_START
block|,
DECL|enumerator|BEFORE_TABLE_DIR
name|BEFORE_TABLE_DIR
block|,
DECL|enumerator|OTHER_TABLES
name|OTHER_TABLES
block|}
DECL|typedef|T42_Load_Status
name|T42_Load_Status
typedef|;
end_typedef
begin_function
specifier|static
name|void
DECL|function|t42_parse_sfnts
name|t42_parse_sfnts
parameter_list|(
name|T42_Face
name|face
parameter_list|,
name|T42_Loader
name|loader
parameter_list|)
block|{
name|T42_Parser
name|parser
init|=
operator|&
name|loader
operator|->
name|parser
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|parser
operator|->
name|root
operator|.
name|memory
decl_stmt|;
name|FT_Byte
modifier|*
name|cur
decl_stmt|;
name|FT_Byte
modifier|*
name|limit
init|=
name|parser
operator|->
name|root
operator|.
name|limit
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|FT_Int
name|num_tables
init|=
literal|0
decl_stmt|;
name|FT_ULong
name|count
decl_stmt|,
name|ttf_size
init|=
literal|0
decl_stmt|;
name|FT_Long
name|n
decl_stmt|,
name|string_size
decl_stmt|,
name|old_string_size
decl_stmt|,
name|real_size
decl_stmt|;
name|FT_Byte
modifier|*
name|string_buf
init|=
name|NULL
decl_stmt|;
name|FT_Bool
name|allocated
init|=
literal|0
decl_stmt|;
name|T42_Load_Status
name|status
decl_stmt|;
comment|/* The format is                                */
comment|/*                                              */
comment|/*   /sfnts [<hexstring><hexstring> ... ] def */
comment|/*                                              */
comment|/* or                                           */
comment|/*                                              */
comment|/*   /sfnts [                                   */
comment|/*<num_bin_bytes> RD<binary data>        */
comment|/*<num_bin_bytes> RD<binary data>        */
comment|/*      ...                                     */
comment|/*   ] def                                      */
comment|/*                                              */
comment|/* with exactly one space after the `RD' token. */
name|T1_Skip_Spaces
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|parser
operator|->
name|root
operator|.
name|cursor
operator|>=
name|limit
operator|||
operator|*
name|parser
operator|->
name|root
operator|.
name|cursor
operator|++
operator|!=
literal|'['
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"t42_parse_sfnts: can't find begin of sfnts vector\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|T42_Err_Invalid_File_Format
expr_stmt|;
goto|goto
name|Fail
goto|;
block|}
name|T1_Skip_Spaces
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|status
operator|=
name|BEFORE_START
expr_stmt|;
name|string_size
operator|=
literal|0
expr_stmt|;
name|old_string_size
operator|=
literal|0
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|parser
operator|->
name|root
operator|.
name|cursor
operator|<
name|limit
condition|)
block|{
name|cur
operator|=
name|parser
operator|->
name|root
operator|.
name|cursor
expr_stmt|;
if|if
condition|(
operator|*
name|cur
operator|==
literal|']'
condition|)
block|{
name|parser
operator|->
name|root
operator|.
name|cursor
operator|++
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
elseif|else
if|if
condition|(
operator|*
name|cur
operator|==
literal|'<'
condition|)
block|{
name|T1_Skip_PS_Token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|parser
operator|->
name|root
operator|.
name|error
condition|)
goto|goto
name|Exit
goto|;
comment|/* don't include delimiters */
name|string_size
operator|=
call|(
name|FT_Long
call|)
argument_list|(
operator|(
name|parser
operator|->
name|root
operator|.
name|cursor
operator|-
name|cur
operator|-
literal|2
operator|+
literal|1
operator|)
operator|/
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|FT_REALLOC
argument_list|(
name|string_buf
argument_list|,
name|old_string_size
argument_list|,
name|string_size
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
name|allocated
operator|=
literal|1
expr_stmt|;
name|parser
operator|->
name|root
operator|.
name|cursor
operator|=
name|cur
expr_stmt|;
operator|(
name|void
operator|)
name|T1_ToBytes
argument_list|(
name|parser
argument_list|,
name|string_buf
argument_list|,
name|string_size
argument_list|,
operator|&
name|real_size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|old_string_size
operator|=
name|string_size
expr_stmt|;
name|string_size
operator|=
name|real_size
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ft_isdigit
argument_list|(
operator|*
name|cur
argument_list|)
condition|)
block|{
if|if
condition|(
name|allocated
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"t42_parse_sfnts: "
literal|"can't handle mixed binary and hex strings\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|T42_Err_Invalid_File_Format
expr_stmt|;
goto|goto
name|Fail
goto|;
block|}
name|string_size
operator|=
name|T1_ToInt
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|T1_Skip_PS_Token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* `RD' */
if|if
condition|(
name|parser
operator|->
name|root
operator|.
name|error
condition|)
return|return;
name|string_buf
operator|=
name|parser
operator|->
name|root
operator|.
name|cursor
operator|+
literal|1
expr_stmt|;
comment|/* one space after `RD' */
name|parser
operator|->
name|root
operator|.
name|cursor
operator|+=
name|string_size
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|parser
operator|->
name|root
operator|.
name|cursor
operator|>=
name|limit
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"t42_parse_sfnts: too many binary data\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|T42_Err_Invalid_File_Format
expr_stmt|;
goto|goto
name|Fail
goto|;
block|}
block|}
if|if
condition|(
operator|!
name|string_buf
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"t42_parse_sfnts: invalid data in sfnts array\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|T42_Err_Invalid_File_Format
expr_stmt|;
goto|goto
name|Fail
goto|;
block|}
comment|/* A string can have a trailing zero byte for padding.  Ignore it. */
if|if
condition|(
name|string_buf
index|[
name|string_size
operator|-
literal|1
index|]
operator|==
literal|0
operator|&&
operator|(
name|string_size
operator|%
literal|2
operator|==
literal|1
operator|)
condition|)
name|string_size
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|string_size
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"t42_parse_sfnts: invalid string\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|T42_Err_Invalid_File_Format
expr_stmt|;
goto|goto
name|Fail
goto|;
block|}
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|string_size
condition|;
name|n
operator|++
control|)
block|{
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|BEFORE_START
case|:
comment|/* load offset table, 12 bytes */
if|if
condition|(
name|count
operator|<
literal|12
condition|)
block|{
name|face
operator|->
name|ttf_data
index|[
name|count
operator|++
index|]
operator|=
name|string_buf
index|[
name|n
index|]
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|num_tables
operator|=
literal|16
operator|*
name|face
operator|->
name|ttf_data
index|[
literal|4
index|]
operator|+
name|face
operator|->
name|ttf_data
index|[
literal|5
index|]
expr_stmt|;
name|status
operator|=
name|BEFORE_TABLE_DIR
expr_stmt|;
name|ttf_size
operator|=
literal|12
operator|+
literal|16
operator|*
name|num_tables
expr_stmt|;
if|if
condition|(
name|FT_REALLOC
argument_list|(
name|face
operator|->
name|ttf_data
argument_list|,
literal|12
argument_list|,
name|ttf_size
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
block|}
comment|/* fall through */
case|case
name|BEFORE_TABLE_DIR
case|:
comment|/* the offset table is read; read the table directory */
if|if
condition|(
name|count
operator|<
name|ttf_size
condition|)
block|{
name|face
operator|->
name|ttf_data
index|[
name|count
operator|++
index|]
operator|=
name|string_buf
index|[
name|n
index|]
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
name|FT_ULong
name|len
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_tables
condition|;
name|i
operator|++
control|)
block|{
name|FT_Byte
modifier|*
name|p
init|=
name|face
operator|->
name|ttf_data
operator|+
literal|12
operator|+
literal|16
operator|*
name|i
operator|+
literal|12
decl_stmt|;
name|len
operator|=
name|FT_PEEK_ULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* Pad to a 4-byte boundary length */
name|ttf_size
operator|+=
operator|(
name|len
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
expr_stmt|;
block|}
name|status
operator|=
name|OTHER_TABLES
expr_stmt|;
name|face
operator|->
name|ttf_size
operator|=
name|ttf_size
expr_stmt|;
comment|/* there are no more than 256 tables, so no size check here */
if|if
condition|(
name|FT_REALLOC
argument_list|(
name|face
operator|->
name|ttf_data
argument_list|,
literal|12
operator|+
literal|16
operator|*
name|num_tables
argument_list|,
name|ttf_size
operator|+
literal|1
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
block|}
comment|/* fall through */
case|case
name|OTHER_TABLES
case|:
comment|/* all other tables are just copied */
if|if
condition|(
name|count
operator|>=
name|ttf_size
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"t42_parse_sfnts: too many binary data\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|T42_Err_Invalid_File_Format
expr_stmt|;
goto|goto
name|Fail
goto|;
block|}
name|face
operator|->
name|ttf_data
index|[
name|count
operator|++
index|]
operator|=
name|string_buf
index|[
name|n
index|]
expr_stmt|;
block|}
block|}
name|T1_Skip_Spaces
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
comment|/* if control reaches this point, the format was not valid */
name|error
operator|=
name|T42_Err_Invalid_File_Format
expr_stmt|;
name|Fail
label|:
name|parser
operator|->
name|root
operator|.
name|error
operator|=
name|error
expr_stmt|;
name|Exit
label|:
if|if
condition|(
name|allocated
condition|)
name|FT_FREE
argument_list|(
name|string_buf
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|t42_parse_charstrings
name|t42_parse_charstrings
parameter_list|(
name|T42_Face
name|face
parameter_list|,
name|T42_Loader
name|loader
parameter_list|)
block|{
name|T42_Parser
name|parser
init|=
operator|&
name|loader
operator|->
name|parser
decl_stmt|;
name|PS_Table
name|code_table
init|=
operator|&
name|loader
operator|->
name|charstrings
decl_stmt|;
name|PS_Table
name|name_table
init|=
operator|&
name|loader
operator|->
name|glyph_names
decl_stmt|;
name|PS_Table
name|swap_table
init|=
operator|&
name|loader
operator|->
name|swap_table
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|parser
operator|->
name|root
operator|.
name|memory
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|PSAux_Service
name|psaux
init|=
operator|(
name|PSAux_Service
operator|)
name|face
operator|->
name|psaux
decl_stmt|;
name|FT_Byte
modifier|*
name|cur
decl_stmt|;
name|FT_Byte
modifier|*
name|limit
init|=
name|parser
operator|->
name|root
operator|.
name|limit
decl_stmt|;
name|FT_UInt
name|n
decl_stmt|;
name|FT_UInt
name|notdef_index
init|=
literal|0
decl_stmt|;
name|FT_Byte
name|notdef_found
init|=
literal|0
decl_stmt|;
name|T1_Skip_Spaces
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|parser
operator|->
name|root
operator|.
name|cursor
operator|>=
name|limit
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"t42_parse_charstrings: out of bounds\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|T42_Err_Invalid_File_Format
expr_stmt|;
goto|goto
name|Fail
goto|;
block|}
if|if
condition|(
name|ft_isdigit
argument_list|(
operator|*
name|parser
operator|->
name|root
operator|.
name|cursor
argument_list|)
condition|)
block|{
name|loader
operator|->
name|num_glyphs
operator|=
operator|(
name|FT_UInt
operator|)
name|T1_ToInt
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|parser
operator|->
name|root
operator|.
name|error
condition|)
return|return;
block|}
elseif|else
if|if
condition|(
operator|*
name|parser
operator|->
name|root
operator|.
name|cursor
operator|==
literal|'<'
condition|)
block|{
comment|/* We have `<< ...>>'.  Count the number of `/' in the dictionary */
comment|/* to get its size.                                                */
name|FT_UInt
name|count
init|=
literal|0
decl_stmt|;
name|T1_Skip_PS_Token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|parser
operator|->
name|root
operator|.
name|error
condition|)
return|return;
name|T1_Skip_Spaces
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|cur
operator|=
name|parser
operator|->
name|root
operator|.
name|cursor
expr_stmt|;
while|while
condition|(
name|parser
operator|->
name|root
operator|.
name|cursor
operator|<
name|limit
condition|)
block|{
if|if
condition|(
operator|*
name|parser
operator|->
name|root
operator|.
name|cursor
operator|==
literal|'/'
condition|)
name|count
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|parser
operator|->
name|root
operator|.
name|cursor
operator|==
literal|'>'
condition|)
block|{
name|loader
operator|->
name|num_glyphs
operator|=
name|count
expr_stmt|;
name|parser
operator|->
name|root
operator|.
name|cursor
operator|=
name|cur
expr_stmt|;
comment|/* rewind */
break|break;
block|}
name|T1_Skip_PS_Token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|parser
operator|->
name|root
operator|.
name|error
condition|)
return|return;
name|T1_Skip_Spaces
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"t42_parse_charstrings: invalid token\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|T42_Err_Invalid_File_Format
expr_stmt|;
goto|goto
name|Fail
goto|;
block|}
if|if
condition|(
name|parser
operator|->
name|root
operator|.
name|cursor
operator|>=
name|limit
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"t42_parse_charstrings: out of bounds\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|T42_Err_Invalid_File_Format
expr_stmt|;
goto|goto
name|Fail
goto|;
block|}
comment|/* initialize tables */
name|error
operator|=
name|psaux
operator|->
name|ps_table_funcs
operator|->
name|init
argument_list|(
name|code_table
argument_list|,
name|loader
operator|->
name|num_glyphs
argument_list|,
name|memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Fail
goto|;
name|error
operator|=
name|psaux
operator|->
name|ps_table_funcs
operator|->
name|init
argument_list|(
name|name_table
argument_list|,
name|loader
operator|->
name|num_glyphs
argument_list|,
name|memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Fail
goto|;
comment|/* Initialize table for swapping index notdef_index and */
comment|/* index 0 names and codes (if necessary).              */
name|error
operator|=
name|psaux
operator|->
name|ps_table_funcs
operator|->
name|init
argument_list|(
name|swap_table
argument_list|,
literal|4
argument_list|,
name|memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Fail
goto|;
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* The format is simple:                   */
comment|/*   `/glyphname' + index [+ def]          */
name|T1_Skip_Spaces
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|cur
operator|=
name|parser
operator|->
name|root
operator|.
name|cursor
expr_stmt|;
if|if
condition|(
name|cur
operator|>=
name|limit
condition|)
break|break;
comment|/* We stop when we find an `end' keyword or '>' */
if|if
condition|(
operator|*
name|cur
operator|==
literal|'e'
operator|&&
name|cur
operator|+
literal|3
operator|<
name|limit
operator|&&
name|cur
index|[
literal|1
index|]
operator|==
literal|'n'
operator|&&
name|cur
index|[
literal|2
index|]
operator|==
literal|'d'
operator|&&
name|t42_is_space
argument_list|(
name|cur
index|[
literal|3
index|]
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|*
name|cur
operator|==
literal|'>'
condition|)
break|break;
name|T1_Skip_PS_Token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|parser
operator|->
name|root
operator|.
name|error
condition|)
return|return;
if|if
condition|(
operator|*
name|cur
operator|==
literal|'/'
condition|)
block|{
name|FT_PtrDist
name|len
decl_stmt|;
if|if
condition|(
name|cur
operator|+
literal|1
operator|>=
name|limit
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"t42_parse_charstrings: out of bounds\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|T42_Err_Invalid_File_Format
expr_stmt|;
goto|goto
name|Fail
goto|;
block|}
name|cur
operator|++
expr_stmt|;
comment|/* skip `/' */
name|len
operator|=
name|parser
operator|->
name|root
operator|.
name|cursor
operator|-
name|cur
expr_stmt|;
name|error
operator|=
name|T1_Add_Table
argument_list|(
name|name_table
argument_list|,
name|n
argument_list|,
name|cur
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Fail
goto|;
comment|/* add a trailing zero to the name table */
name|name_table
operator|->
name|elements
index|[
name|n
index|]
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* record index of /.notdef */
if|if
condition|(
operator|*
name|cur
operator|==
literal|'.'
operator|&&
name|ft_strcmp
argument_list|(
literal|".notdef"
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
operator|(
name|name_table
operator|->
name|elements
index|[
name|n
index|]
operator|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|notdef_index
operator|=
name|n
expr_stmt|;
name|notdef_found
operator|=
literal|1
expr_stmt|;
block|}
name|T1_Skip_Spaces
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|cur
operator|=
name|parser
operator|->
name|root
operator|.
name|cursor
expr_stmt|;
operator|(
name|void
operator|)
name|T1_ToInt
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|parser
operator|->
name|root
operator|.
name|cursor
operator|>=
name|limit
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"t42_parse_charstrings: out of bounds\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|T42_Err_Invalid_File_Format
expr_stmt|;
goto|goto
name|Fail
goto|;
block|}
name|len
operator|=
name|parser
operator|->
name|root
operator|.
name|cursor
operator|-
name|cur
expr_stmt|;
name|error
operator|=
name|T1_Add_Table
argument_list|(
name|code_table
argument_list|,
name|n
argument_list|,
name|cur
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Fail
goto|;
name|code_table
operator|->
name|elements
index|[
name|n
index|]
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|n
operator|++
expr_stmt|;
if|if
condition|(
name|n
operator|>=
name|loader
operator|->
name|num_glyphs
condition|)
break|break;
block|}
block|}
name|loader
operator|->
name|num_glyphs
operator|=
name|n
expr_stmt|;
if|if
condition|(
operator|!
name|notdef_found
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"t42_parse_charstrings: no /.notdef glyph\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|T42_Err_Invalid_File_Format
expr_stmt|;
goto|goto
name|Fail
goto|;
block|}
comment|/* if /.notdef does not occupy index 0, do our magic. */
if|if
condition|(
name|ft_strcmp
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
literal|".notdef"
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|name_table
operator|->
name|elements
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
comment|/* Swap glyph in index 0 with /.notdef glyph.  First, add index 0  */
comment|/* name and code entries to swap_table.  Then place notdef_index   */
comment|/* name and code entries into swap_table.  Then swap name and code */
comment|/* entries at indices notdef_index and 0 using values stored in    */
comment|/* swap_table.                                                     */
comment|/* Index 0 name */
name|error
operator|=
name|T1_Add_Table
argument_list|(
name|swap_table
argument_list|,
literal|0
argument_list|,
name|name_table
operator|->
name|elements
index|[
literal|0
index|]
argument_list|,
name|name_table
operator|->
name|lengths
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Fail
goto|;
comment|/* Index 0 code */
name|error
operator|=
name|T1_Add_Table
argument_list|(
name|swap_table
argument_list|,
literal|1
argument_list|,
name|code_table
operator|->
name|elements
index|[
literal|0
index|]
argument_list|,
name|code_table
operator|->
name|lengths
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Fail
goto|;
comment|/* Index notdef_index name */
name|error
operator|=
name|T1_Add_Table
argument_list|(
name|swap_table
argument_list|,
literal|2
argument_list|,
name|name_table
operator|->
name|elements
index|[
name|notdef_index
index|]
argument_list|,
name|name_table
operator|->
name|lengths
index|[
name|notdef_index
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Fail
goto|;
comment|/* Index notdef_index code */
name|error
operator|=
name|T1_Add_Table
argument_list|(
name|swap_table
argument_list|,
literal|3
argument_list|,
name|code_table
operator|->
name|elements
index|[
name|notdef_index
index|]
argument_list|,
name|code_table
operator|->
name|lengths
index|[
name|notdef_index
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Fail
goto|;
name|error
operator|=
name|T1_Add_Table
argument_list|(
name|name_table
argument_list|,
name|notdef_index
argument_list|,
name|swap_table
operator|->
name|elements
index|[
literal|0
index|]
argument_list|,
name|swap_table
operator|->
name|lengths
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Fail
goto|;
name|error
operator|=
name|T1_Add_Table
argument_list|(
name|code_table
argument_list|,
name|notdef_index
argument_list|,
name|swap_table
operator|->
name|elements
index|[
literal|1
index|]
argument_list|,
name|swap_table
operator|->
name|lengths
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Fail
goto|;
name|error
operator|=
name|T1_Add_Table
argument_list|(
name|name_table
argument_list|,
literal|0
argument_list|,
name|swap_table
operator|->
name|elements
index|[
literal|2
index|]
argument_list|,
name|swap_table
operator|->
name|lengths
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Fail
goto|;
name|error
operator|=
name|T1_Add_Table
argument_list|(
name|code_table
argument_list|,
literal|0
argument_list|,
name|swap_table
operator|->
name|elements
index|[
literal|3
index|]
argument_list|,
name|swap_table
operator|->
name|lengths
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Fail
goto|;
block|}
return|return;
name|Fail
label|:
name|parser
operator|->
name|root
operator|.
name|error
operator|=
name|error
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|t42_load_keyword
name|t42_load_keyword
parameter_list|(
name|T42_Face
name|face
parameter_list|,
name|T42_Loader
name|loader
parameter_list|,
name|T1_Field
name|field
parameter_list|)
block|{
name|FT_Error
name|error
decl_stmt|;
name|void
modifier|*
name|dummy_object
decl_stmt|;
name|void
modifier|*
modifier|*
name|objects
decl_stmt|;
name|FT_UInt
name|max_objects
init|=
literal|0
decl_stmt|;
comment|/* if the keyword has a dedicated callback, call it */
if|if
condition|(
name|field
operator|->
name|type
operator|==
name|T1_FIELD_TYPE_CALLBACK
condition|)
block|{
name|field
operator|->
name|reader
argument_list|(
operator|(
name|FT_Face
operator|)
name|face
argument_list|,
name|loader
argument_list|)
expr_stmt|;
name|error
operator|=
name|loader
operator|->
name|parser
operator|.
name|root
operator|.
name|error
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* now the keyword is either a simple field or a table of fields; */
comment|/* we are now going to take care of it                            */
switch|switch
condition|(
name|field
operator|->
name|location
condition|)
block|{
case|case
name|T1_FIELD_LOCATION_FONT_INFO
case|:
name|dummy_object
operator|=
operator|&
name|face
operator|->
name|type1
operator|.
name|font_info
expr_stmt|;
break|break;
case|case
name|T1_FIELD_LOCATION_FONT_EXTRA
case|:
name|dummy_object
operator|=
operator|&
name|face
operator|->
name|type1
operator|.
name|font_extra
expr_stmt|;
break|break;
case|case
name|T1_FIELD_LOCATION_BBOX
case|:
name|dummy_object
operator|=
operator|&
name|face
operator|->
name|type1
operator|.
name|font_bbox
expr_stmt|;
break|break;
default|default:
name|dummy_object
operator|=
operator|&
name|face
operator|->
name|type1
expr_stmt|;
block|}
name|objects
operator|=
operator|&
name|dummy_object
expr_stmt|;
if|if
condition|(
name|field
operator|->
name|type
operator|==
name|T1_FIELD_TYPE_INTEGER_ARRAY
operator|||
name|field
operator|->
name|type
operator|==
name|T1_FIELD_TYPE_FIXED_ARRAY
condition|)
name|error
operator|=
name|T1_Load_Field_Table
argument_list|(
operator|&
name|loader
operator|->
name|parser
argument_list|,
name|field
argument_list|,
name|objects
argument_list|,
name|max_objects
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|T1_Load_Field
argument_list|(
operator|&
name|loader
operator|->
name|parser
argument_list|,
name|field
argument_list|,
name|objects
argument_list|,
name|max_objects
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Exit
label|:
return|return
name|error
return|;
block|}
end_function
begin_macro
DECL|function|FT_LOCAL_DEF
name|FT_LOCAL_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|t42_parse_dict
argument_list|(
argument|T42_Face    face
argument_list|,
argument|T42_Loader  loader
argument_list|,
argument|FT_Byte*    base
argument_list|,
argument|FT_Long     size
argument_list|)
end_macro
begin_block
block|{
name|T42_Parser
name|parser
init|=
operator|&
name|loader
operator|->
name|parser
decl_stmt|;
name|FT_Byte
modifier|*
name|limit
decl_stmt|;
name|FT_Int
name|n_keywords
init|=
call|(
name|FT_Int
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|t42_keywords
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|t42_keywords
index|[
literal|0
index|]
argument_list|)
argument_list|)
decl_stmt|;
name|parser
operator|->
name|root
operator|.
name|cursor
operator|=
name|base
expr_stmt|;
name|parser
operator|->
name|root
operator|.
name|limit
operator|=
name|base
operator|+
name|size
expr_stmt|;
name|parser
operator|->
name|root
operator|.
name|error
operator|=
name|T42_Err_Ok
expr_stmt|;
name|limit
operator|=
name|parser
operator|->
name|root
operator|.
name|limit
expr_stmt|;
name|T1_Skip_Spaces
argument_list|(
name|parser
argument_list|)
expr_stmt|;
while|while
condition|(
name|parser
operator|->
name|root
operator|.
name|cursor
operator|<
name|limit
condition|)
block|{
name|FT_Byte
modifier|*
name|cur
decl_stmt|;
name|cur
operator|=
name|parser
operator|->
name|root
operator|.
name|cursor
expr_stmt|;
comment|/* look for `FontDirectory' which causes problems for some fonts */
if|if
condition|(
operator|*
name|cur
operator|==
literal|'F'
operator|&&
name|cur
operator|+
literal|25
operator|<
name|limit
operator|&&
name|ft_strncmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cur
argument_list|,
literal|"FontDirectory"
argument_list|,
literal|13
argument_list|)
operator|==
literal|0
condition|)
block|{
name|FT_Byte
modifier|*
name|cur2
decl_stmt|;
comment|/* skip the `FontDirectory' keyword */
name|T1_Skip_PS_Token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|T1_Skip_Spaces
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|cur
operator|=
name|cur2
operator|=
name|parser
operator|->
name|root
operator|.
name|cursor
expr_stmt|;
comment|/* look up the `known' keyword */
while|while
condition|(
name|cur
operator|<
name|limit
condition|)
block|{
if|if
condition|(
operator|*
name|cur
operator|==
literal|'k'
operator|&&
name|cur
operator|+
literal|5
operator|<
name|limit
operator|&&
name|ft_strncmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cur
argument_list|,
literal|"known"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|T1_Skip_PS_Token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|parser
operator|->
name|root
operator|.
name|error
condition|)
goto|goto
name|Exit
goto|;
name|T1_Skip_Spaces
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|cur
operator|=
name|parser
operator|->
name|root
operator|.
name|cursor
expr_stmt|;
block|}
if|if
condition|(
name|cur
operator|<
name|limit
condition|)
block|{
name|T1_TokenRec
name|token
decl_stmt|;
comment|/* skip the `known' keyword and the token following it */
name|T1_Skip_PS_Token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|T1_ToToken
argument_list|(
name|parser
argument_list|,
operator|&
name|token
argument_list|)
expr_stmt|;
comment|/* if the last token was an array, skip it! */
if|if
condition|(
name|token
operator|.
name|type
operator|==
name|T1_TOKEN_TYPE_ARRAY
condition|)
name|cur2
operator|=
name|parser
operator|->
name|root
operator|.
name|cursor
expr_stmt|;
block|}
name|parser
operator|->
name|root
operator|.
name|cursor
operator|=
name|cur2
expr_stmt|;
block|}
comment|/* look for immediates */
elseif|else
if|if
condition|(
operator|*
name|cur
operator|==
literal|'/'
operator|&&
name|cur
operator|+
literal|2
operator|<
name|limit
condition|)
block|{
name|FT_PtrDist
name|len
decl_stmt|;
name|cur
operator|++
expr_stmt|;
name|parser
operator|->
name|root
operator|.
name|cursor
operator|=
name|cur
expr_stmt|;
name|T1_Skip_PS_Token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|parser
operator|->
name|root
operator|.
name|error
condition|)
goto|goto
name|Exit
goto|;
name|len
operator|=
name|parser
operator|->
name|root
operator|.
name|cursor
operator|-
name|cur
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
operator|&&
name|len
operator|<
literal|22
operator|&&
name|parser
operator|->
name|root
operator|.
name|cursor
operator|<
name|limit
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* now compare the immediate name to the keyword table */
comment|/* loop through all known keywords */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_keywords
condition|;
name|i
operator|++
control|)
block|{
name|T1_Field
name|keyword
init|=
operator|(
name|T1_Field
operator|)
operator|&
name|t42_keywords
index|[
name|i
index|]
decl_stmt|;
name|FT_Byte
modifier|*
name|name
init|=
operator|(
name|FT_Byte
operator|*
operator|)
name|keyword
operator|->
name|ident
decl_stmt|;
if|if
condition|(
operator|!
name|name
condition|)
continue|continue;
if|if
condition|(
name|cur
index|[
literal|0
index|]
operator|==
name|name
index|[
literal|0
index|]
operator|&&
name|len
operator|==
operator|(
name|FT_PtrDist
operator|)
name|ft_strlen
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|name
argument_list|)
operator|&&
name|ft_memcmp
argument_list|(
name|cur
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* we found it -- run the parsing callback! */
name|parser
operator|->
name|root
operator|.
name|error
operator|=
name|t42_load_keyword
argument_list|(
name|face
argument_list|,
name|loader
argument_list|,
name|keyword
argument_list|)
expr_stmt|;
if|if
condition|(
name|parser
operator|->
name|root
operator|.
name|error
condition|)
return|return
name|parser
operator|->
name|root
operator|.
name|error
return|;
break|break;
block|}
block|}
block|}
block|}
else|else
block|{
name|T1_Skip_PS_Token
argument_list|(
name|parser
argument_list|)
expr_stmt|;
if|if
condition|(
name|parser
operator|->
name|root
operator|.
name|error
condition|)
goto|goto
name|Exit
goto|;
block|}
name|T1_Skip_Spaces
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
name|Exit
label|:
return|return
name|parser
operator|->
name|root
operator|.
name|error
return|;
block|}
end_block
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|t42_loader_init
name|t42_loader_init
argument_list|(
argument|T42_Loader  loader
argument_list|,
argument|T42_Face    face
argument_list|)
end_macro
begin_block
block|{
name|FT_UNUSED
argument_list|(
name|face
argument_list|)
expr_stmt|;
name|FT_MEM_ZERO
argument_list|(
name|loader
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|loader
argument_list|)
argument_list|)
expr_stmt|;
name|loader
operator|->
name|num_glyphs
operator|=
literal|0
expr_stmt|;
name|loader
operator|->
name|num_chars
operator|=
literal|0
expr_stmt|;
comment|/* initialize the tables -- simply set their `init' field to 0 */
name|loader
operator|->
name|encoding_table
operator|.
name|init
operator|=
literal|0
expr_stmt|;
name|loader
operator|->
name|charstrings
operator|.
name|init
operator|=
literal|0
expr_stmt|;
name|loader
operator|->
name|glyph_names
operator|.
name|init
operator|=
literal|0
expr_stmt|;
block|}
end_block
begin_macro
name|FT_LOCAL_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|t42_loader_done
name|t42_loader_done
argument_list|(
argument|T42_Loader  loader
argument_list|)
end_macro
begin_block
block|{
name|T42_Parser
name|parser
init|=
operator|&
name|loader
operator|->
name|parser
decl_stmt|;
comment|/* finalize tables */
name|T1_Release_Table
argument_list|(
operator|&
name|loader
operator|->
name|encoding_table
argument_list|)
expr_stmt|;
name|T1_Release_Table
argument_list|(
operator|&
name|loader
operator|->
name|charstrings
argument_list|)
expr_stmt|;
name|T1_Release_Table
argument_list|(
operator|&
name|loader
operator|->
name|glyph_names
argument_list|)
expr_stmt|;
name|T1_Release_Table
argument_list|(
operator|&
name|loader
operator|->
name|swap_table
argument_list|)
expr_stmt|;
comment|/* finalize parser */
name|t42_parser_done
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
end_block
begin_comment
comment|/* END */
end_comment
end_unit
