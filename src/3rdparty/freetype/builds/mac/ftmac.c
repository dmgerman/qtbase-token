begin_unit
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  ftmac.c                                                                */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*    Mac FOND support.  Written by just@letterror.com.                    */
end_comment
begin_comment
comment|/*  Heavily Fixed by mpsuzuki, George Williams and Sean McBride            */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 by       */
end_comment
begin_comment
comment|/*  Just van Rossum, David Turner, Robert Wilhelm, and Werner Lemberg.     */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  This file is part of the FreeType project, and may only be used,       */
end_comment
begin_comment
comment|/*  modified, and distributed under the terms of the FreeType project      */
end_comment
begin_comment
comment|/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
end_comment
begin_comment
comment|/*  this file you indicate that you have read the license and              */
end_comment
begin_comment
comment|/*  understand and accept it fully.                                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*     Notes      Mac suitcase files can (and often do!) contain multiple fonts.  To     support this I use the face_index argument of FT_(Open|New)_Face()     functions, and pretend the suitcase file is a collection.      Warning: fbit and NFNT bitmap resources are not supported yet.  In old     sfnt fonts, bitmap glyph data for each size is stored in each `NFNT'     resources instead of the `bdat' table in the sfnt resource.  Therefore,     face->num_fixed_sizes is set to 0, because bitmap data in `NFNT'     resource is unavailable at present.      The Mac FOND support works roughly like this:      - Check whether the offered stream points to a Mac suitcase file.  This       is done by checking the file type: it has to be 'FFIL' or 'tfil'.  The       stream that gets passed to our init_face() routine is a stdio stream,       which isn't usable for us, since the FOND resources live in the       resource fork.  So we just grab the stream->pathname field.      - Read the FOND resource into memory, then check whether there is a       TrueType font and/or(!) a Type 1 font available.      - If there is a Type 1 font available (as a separate `LWFN' file), read       its data into memory, massage it slightly so it becomes PFB data, wrap       it into a memory stream, load the Type 1 driver and delegate the rest       of the work to it by calling FT_Open_Face().  (XXX TODO: after this       has been done, the kerning data from the FOND resource should be       appended to the face: On the Mac there are usually no AFM files       available.  However, this is tricky since we need to map Mac char       codes to ps glyph names to glyph ID's...)      - If there is a TrueType font (an `sfnt' resource), read it into memory,       wrap it into a memory stream, load the TrueType driver and delegate       the rest of the work to it, by calling FT_Open_Face().      - Some suitcase fonts (notably Onyx) might point the `LWFN' file to       itself, even though it doesn't contains `POST' resources.  To handle       this special case without opening the file an extra time, we just       ignore errors from the `LWFN' and fallback to the `sfnt' if both are       available.   */
end_comment
begin_include
include|#
directive|include
file|<ft2build.h>
end_include
begin_include
include|#
directive|include
include|FT_FREETYPE_H
end_include
begin_include
include|#
directive|include
include|FT_TRUETYPE_TAGS_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_STREAM_H
end_include
begin_include
include|#
directive|include
file|"ftbase.h"
end_include
begin_if
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|||
name|defined
argument_list|(
name|__IBMC__
argument_list|)
end_if
begin_comment
comment|/* This is for Mac OS X.  Without redefinition, OS_INLINE */
end_comment
begin_comment
comment|/* expands to `static inline' which doesn't survive the   */
end_comment
begin_comment
comment|/* -ansi compilation flag of GCC.                         */
end_comment
begin_if
if|#
directive|if
operator|!
name|HAVE_ANSI_OS_INLINE
end_if
begin_undef
DECL|macro|OS_INLINE
undef|#
directive|undef
name|OS_INLINE
end_undef
begin_define
DECL|macro|OS_INLINE
define|#
directive|define
name|OS_INLINE
value|static __inline__
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|<CoreServices/CoreServices.h>
end_include
begin_include
include|#
directive|include
file|<ApplicationServices/ApplicationServices.h>
end_include
begin_include
include|#
directive|include
file|<sys/syslimits.h>
end_include
begin_comment
comment|/* PATH_MAX */
end_comment
begin_else
else|#
directive|else
end_else
begin_include
include|#
directive|include
file|<Resources.h>
end_include
begin_include
include|#
directive|include
file|<Fonts.h>
end_include
begin_include
include|#
directive|include
file|<Endian.h>
end_include
begin_include
include|#
directive|include
file|<Errors.h>
end_include
begin_include
include|#
directive|include
file|<Files.h>
end_include
begin_include
include|#
directive|include
file|<TextUtils.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|PATH_MAX
end_ifndef
begin_define
DECL|macro|PATH_MAX
define|#
directive|define
name|PATH_MAX
value|1024
end_define
begin_comment
DECL|macro|PATH_MAX
comment|/* same with Mac OS X's syslimits.h */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|__MWERKS__
argument_list|)
operator|&&
operator|!
name|TARGET_RT_MAC_MACHO
end_if
begin_include
include|#
directive|include
file|<FSp_fopen.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|FT_DEPRECATED_ATTRIBUTE
define|#
directive|define
name|FT_DEPRECATED_ATTRIBUTE
end_define
begin_include
include|#
directive|include
include|FT_MAC_H
end_include
begin_comment
comment|/* undefine blocking-macros in ftmac.h */
end_comment
begin_undef
DECL|macro|FT_GetFile_From_Mac_Name
undef|#
directive|undef
name|FT_GetFile_From_Mac_Name
end_undef
begin_undef
DECL|macro|FT_GetFile_From_Mac_ATS_Name
undef|#
directive|undef
name|FT_GetFile_From_Mac_ATS_Name
end_undef
begin_undef
DECL|macro|FT_New_Face_From_FOND
undef|#
directive|undef
name|FT_New_Face_From_FOND
end_undef
begin_undef
DECL|macro|FT_New_Face_From_FSSpec
undef|#
directive|undef
name|FT_New_Face_From_FSSpec
end_undef
begin_undef
DECL|macro|FT_New_Face_From_FSRef
undef|#
directive|undef
name|FT_New_Face_From_FSRef
end_undef
begin_comment
comment|/* FSSpec functions are deprecated since Mac OS X 10.4 */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_FSSPEC
end_ifndef
begin_if
if|#
directive|if
name|TARGET_API_MAC_OS8
operator|||
name|TARGET_API_MAC_CARBON
end_if
begin_define
DECL|macro|HAVE_FSSPEC
define|#
directive|define
name|HAVE_FSSPEC
value|1
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|HAVE_FSSPEC
define|#
directive|define
name|HAVE_FSSPEC
value|0
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* most FSRef functions were introduced since Mac OS 9 */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_FSREF
end_ifndef
begin_if
if|#
directive|if
name|TARGET_API_MAC_OSX
end_if
begin_define
DECL|macro|HAVE_FSREF
define|#
directive|define
name|HAVE_FSREF
value|1
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|HAVE_FSREF
define|#
directive|define
name|HAVE_FSREF
value|0
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* QuickDraw is deprecated since Mac OS X 10.4 */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_QUICKDRAW_CARBON
end_ifndef
begin_if
if|#
directive|if
name|TARGET_API_MAC_OS8
operator|||
name|TARGET_API_MAC_CARBON
end_if
begin_define
DECL|macro|HAVE_QUICKDRAW_CARBON
define|#
directive|define
name|HAVE_QUICKDRAW_CARBON
value|1
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|HAVE_QUICKDRAW_CARBON
define|#
directive|define
name|HAVE_QUICKDRAW_CARBON
value|0
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* AppleTypeService is available since Mac OS X */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_ATS
end_ifndef
begin_if
if|#
directive|if
name|TARGET_API_MAC_OSX
end_if
begin_define
DECL|macro|HAVE_ATS
define|#
directive|define
name|HAVE_ATS
value|1
end_define
begin_ifndef
ifndef|#
directive|ifndef
name|kATSOptionFlagsUnRestrictedScope
end_ifndef
begin_comment
comment|/* since Mac OS X 10.1 */
end_comment
begin_define
DECL|macro|kATSOptionFlagsUnRestrictedScope
define|#
directive|define
name|kATSOptionFlagsUnRestrictedScope
value|kATSOptionFlagsDefault
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|HAVE_ATS
define|#
directive|define
name|HAVE_ATS
value|0
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* `configure' checks the availability of `ResourceIndex' strictly */
end_comment
begin_comment
comment|/* and sets HAVE_TYPE_RESOURCE_INDEX to 1 or 0 always.  If it is   */
end_comment
begin_comment
comment|/* not set (e.g., a build without `configure'), the availability   */
end_comment
begin_comment
comment|/* is guessed from the SDK version.                                */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_TYPE_RESOURCE_INDEX
end_ifndef
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MAC_OS_X_VERSION_10_5
argument_list|)
operator|||
expr|\
operator|(
name|MAC_OS_X_VERSION_MAX_ALLOWED
operator|<
name|MAC_OS_X_VERSION_10_5
operator|)
end_if
begin_define
DECL|macro|HAVE_TYPE_RESOURCE_INDEX
define|#
directive|define
name|HAVE_TYPE_RESOURCE_INDEX
value|0
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|HAVE_TYPE_RESOURCE_INDEX
define|#
directive|define
name|HAVE_TYPE_RESOURCE_INDEX
value|1
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* !HAVE_TYPE_RESOURCE_INDEX */
end_comment
begin_if
if|#
directive|if
operator|(
name|HAVE_TYPE_RESOURCE_INDEX
operator|==
literal|0
operator|)
end_if
begin_typedef
DECL|typedef|ResourceIndex
typedef|typedef
name|short
name|ResourceIndex
typedef|;
end_typedef
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* Set PREFER_LWFN to 1 if LWFN (Type 1) is preferred over      TrueType in case *both* are available (this is not common,      but it *is* possible). */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|PREFER_LWFN
end_ifndef
begin_define
DECL|macro|PREFER_LWFN
define|#
directive|define
name|PREFER_LWFN
value|1
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
operator|!
name|HAVE_QUICKDRAW_CARBON
end_if
begin_comment
comment|/* QuickDraw is deprecated since Mac OS X 10.4 */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_GetFile_From_Mac_Name
argument_list|(
argument|const char*  fontName
argument_list|,
argument|FSSpec*      pathSpec
argument_list|,
argument|FT_Long*     face_index
argument_list|)
end_macro
begin_block
block|{
name|FT_UNUSED
argument_list|(
name|fontName
argument_list|)
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|pathSpec
argument_list|)
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|face_index
argument_list|)
expr_stmt|;
return|return
name|FT_Err_Unimplemented_Feature
return|;
block|}
end_block
begin_else
else|#
directive|else
end_else
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_GetFile_From_Mac_Name
argument_list|(
argument|const char*  fontName
argument_list|,
argument|FSSpec*      pathSpec
argument_list|,
argument|FT_Long*     face_index
argument_list|)
end_macro
begin_block
block|{
name|OptionBits
name|options
init|=
name|kFMUseGlobalScopeOption
decl_stmt|;
name|FMFontFamilyIterator
name|famIter
decl_stmt|;
name|OSStatus
name|status
init|=
name|FMCreateFontFamilyIterator
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|options
argument_list|,
operator|&
name|famIter
argument_list|)
decl_stmt|;
name|FMFont
name|the_font
init|=
literal|0
decl_stmt|;
name|FMFontFamily
name|family
init|=
literal|0
decl_stmt|;
operator|*
name|face_index
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|status
operator|==
literal|0
operator|&&
operator|!
name|the_font
condition|)
block|{
name|status
operator|=
name|FMGetNextFontFamily
argument_list|(
operator|&
name|famIter
argument_list|,
operator|&
name|family
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
block|{
name|int
name|stat2
decl_stmt|;
name|FMFontFamilyInstanceIterator
name|instIter
decl_stmt|;
name|Str255
name|famNameStr
decl_stmt|;
name|char
name|famName
index|[
literal|256
index|]
decl_stmt|;
comment|/* get the family name */
name|FMGetFontFamilyName
argument_list|(
name|family
argument_list|,
name|famNameStr
argument_list|)
expr_stmt|;
name|CopyPascalStringToC
argument_list|(
name|famNameStr
argument_list|,
name|famName
argument_list|)
expr_stmt|;
comment|/* iterate through the styles */
name|FMCreateFontFamilyInstanceIterator
argument_list|(
name|family
argument_list|,
operator|&
name|instIter
argument_list|)
expr_stmt|;
operator|*
name|face_index
operator|=
literal|0
expr_stmt|;
name|stat2
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|stat2
operator|==
literal|0
operator|&&
operator|!
name|the_font
condition|)
block|{
name|FMFontStyle
name|style
decl_stmt|;
name|FMFontSize
name|size
decl_stmt|;
name|FMFont
name|font
decl_stmt|;
name|stat2
operator|=
name|FMGetNextFontFamilyInstance
argument_list|(
operator|&
name|instIter
argument_list|,
operator|&
name|font
argument_list|,
operator|&
name|style
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat2
operator|==
literal|0
operator|&&
name|size
operator|==
literal|0
condition|)
block|{
name|char
name|fullName
index|[
literal|256
index|]
decl_stmt|;
comment|/* build up a complete face name */
name|ft_strcpy
argument_list|(
name|fullName
argument_list|,
name|famName
argument_list|)
expr_stmt|;
if|if
condition|(
name|style
operator|&
name|bold
condition|)
name|ft_strcat
argument_list|(
name|fullName
argument_list|,
literal|" Bold"
argument_list|)
expr_stmt|;
if|if
condition|(
name|style
operator|&
name|italic
condition|)
name|ft_strcat
argument_list|(
name|fullName
argument_list|,
literal|" Italic"
argument_list|)
expr_stmt|;
comment|/* compare with the name we are looking for */
if|if
condition|(
name|ft_strcmp
argument_list|(
name|fullName
argument_list|,
name|fontName
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* found it! */
name|the_font
operator|=
name|font
expr_stmt|;
block|}
else|else
operator|++
operator|(
operator|*
name|face_index
operator|)
expr_stmt|;
block|}
block|}
name|FMDisposeFontFamilyInstanceIterator
argument_list|(
operator|&
name|instIter
argument_list|)
expr_stmt|;
block|}
block|}
name|FMDisposeFontFamilyIterator
argument_list|(
operator|&
name|famIter
argument_list|)
expr_stmt|;
if|if
condition|(
name|the_font
condition|)
block|{
name|FMGetFontContainer
argument_list|(
name|the_font
argument_list|,
name|pathSpec
argument_list|)
expr_stmt|;
return|return
name|FT_Err_Ok
return|;
block|}
else|else
return|return
name|FT_Err_Unknown_File_Format
return|;
block|}
end_block
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* HAVE_QUICKDRAW_CARBON */
end_comment
begin_if
if|#
directive|if
name|HAVE_ATS
end_if
begin_comment
comment|/* Private function.                                         */
end_comment
begin_comment
comment|/* The FSSpec type has been discouraged for a long time,     */
end_comment
begin_comment
comment|/* unfortunately an FSRef replacement API for                */
end_comment
begin_comment
comment|/* ATSFontGetFileSpecification() is only available in        */
end_comment
begin_comment
comment|/* Mac OS X 10.5 and later.                                  */
end_comment
begin_function
specifier|static
name|OSStatus
DECL|function|FT_ATSFontGetFileReference
name|FT_ATSFontGetFileReference
parameter_list|(
name|ATSFontRef
name|ats_font_id
parameter_list|,
name|FSRef
modifier|*
name|ats_font_ref
parameter_list|)
block|{
name|OSStatus
name|err
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MAC_OS_X_VERSION_10_5
argument_list|)
operator|||
expr|\
name|MAC_OS_X_VERSION_MIN_REQUIRED
operator|<
name|MAC_OS_X_VERSION_10_5
name|FSSpec
name|spec
decl_stmt|;
name|err
operator|=
name|ATSFontGetFileSpecification
argument_list|(
name|ats_font_id
argument_list|,
operator|&
name|spec
argument_list|)
expr_stmt|;
if|if
condition|(
name|noErr
operator|==
name|err
condition|)
name|err
operator|=
name|FSpMakeFSRef
argument_list|(
operator|&
name|spec
argument_list|,
name|ats_font_ref
argument_list|)
expr_stmt|;
else|#
directive|else
name|err
operator|=
name|ATSFontGetFileReference
argument_list|(
name|ats_font_id
argument_list|,
name|ats_font_ref
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|err
return|;
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|FT_GetFileRef_From_Mac_ATS_Name
name|FT_GetFileRef_From_Mac_ATS_Name
parameter_list|(
specifier|const
name|char
modifier|*
name|fontName
parameter_list|,
name|FSRef
modifier|*
name|ats_font_ref
parameter_list|,
name|FT_Long
modifier|*
name|face_index
parameter_list|)
block|{
name|CFStringRef
name|cf_fontName
decl_stmt|;
name|ATSFontRef
name|ats_font_id
decl_stmt|;
operator|*
name|face_index
operator|=
literal|0
expr_stmt|;
name|cf_fontName
operator|=
name|CFStringCreateWithCString
argument_list|(
name|NULL
argument_list|,
name|fontName
argument_list|,
name|kCFStringEncodingMacRoman
argument_list|)
expr_stmt|;
name|ats_font_id
operator|=
name|ATSFontFindFromName
argument_list|(
name|cf_fontName
argument_list|,
name|kATSOptionFlagsUnRestrictedScope
argument_list|)
expr_stmt|;
name|CFRelease
argument_list|(
name|cf_fontName
argument_list|)
expr_stmt|;
if|if
condition|(
name|ats_font_id
operator|==
literal|0
operator|||
name|ats_font_id
operator|==
literal|0xFFFFFFFFUL
condition|)
return|return
name|FT_Err_Unknown_File_Format
return|;
if|if
condition|(
name|noErr
operator|!=
name|FT_ATSFontGetFileReference
argument_list|(
name|ats_font_id
argument_list|,
name|ats_font_ref
argument_list|)
condition|)
return|return
name|FT_Err_Unknown_File_Format
return|;
comment|/* face_index calculation by searching preceding fontIDs */
comment|/* with same FSRef                                       */
block|{
name|ATSFontRef
name|id2
init|=
name|ats_font_id
operator|-
literal|1
decl_stmt|;
name|FSRef
name|ref2
decl_stmt|;
while|while
condition|(
name|id2
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|noErr
operator|!=
name|FT_ATSFontGetFileReference
argument_list|(
name|id2
argument_list|,
operator|&
name|ref2
argument_list|)
condition|)
break|break;
if|if
condition|(
name|noErr
operator|!=
name|FSCompareFSRefs
argument_list|(
name|ats_font_ref
argument_list|,
operator|&
name|ref2
argument_list|)
condition|)
break|break;
name|id2
operator|--
expr_stmt|;
block|}
operator|*
name|face_index
operator|=
name|ats_font_id
operator|-
operator|(
name|id2
operator|+
literal|1
operator|)
expr_stmt|;
block|}
return|return
name|FT_Err_Ok
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
operator|!
name|HAVE_ATS
end_if
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_GetFilePath_From_Mac_ATS_Name
argument_list|(
argument|const char*  fontName
argument_list|,
argument|UInt8*       path
argument_list|,
argument|UInt32       maxPathSize
argument_list|,
argument|FT_Long*     face_index
argument_list|)
end_macro
begin_block
block|{
name|FT_UNUSED
argument_list|(
name|fontName
argument_list|)
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|maxPathSize
argument_list|)
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|face_index
argument_list|)
expr_stmt|;
return|return
name|FT_Err_Unimplemented_Feature
return|;
block|}
end_block
begin_else
else|#
directive|else
end_else
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_GetFilePath_From_Mac_ATS_Name
argument_list|(
argument|const char*  fontName
argument_list|,
argument|UInt8*       path
argument_list|,
argument|UInt32       maxPathSize
argument_list|,
argument|FT_Long*     face_index
argument_list|)
end_macro
begin_block
block|{
name|FSRef
name|ref
decl_stmt|;
name|FT_Error
name|err
decl_stmt|;
name|err
operator|=
name|FT_GetFileRef_From_Mac_ATS_Name
argument_list|(
name|fontName
argument_list|,
operator|&
name|ref
argument_list|,
name|face_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|FT_Err_Ok
operator|!=
name|err
condition|)
return|return
name|err
return|;
if|if
condition|(
name|noErr
operator|!=
name|FSRefMakePath
argument_list|(
operator|&
name|ref
argument_list|,
name|path
argument_list|,
name|maxPathSize
argument_list|)
condition|)
return|return
name|FT_Err_Unknown_File_Format
return|;
return|return
name|FT_Err_Ok
return|;
block|}
end_block
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* HAVE_ATS */
end_comment
begin_if
if|#
directive|if
operator|!
name|HAVE_FSSPEC
operator|||
operator|!
name|HAVE_ATS
end_if
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_GetFile_From_Mac_ATS_Name
argument_list|(
argument|const char*  fontName
argument_list|,
argument|FSSpec*      pathSpec
argument_list|,
argument|FT_Long*     face_index
argument_list|)
end_macro
begin_block
block|{
name|FT_UNUSED
argument_list|(
name|fontName
argument_list|)
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|pathSpec
argument_list|)
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|face_index
argument_list|)
expr_stmt|;
return|return
name|FT_Err_Unimplemented_Feature
return|;
block|}
end_block
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* This function is deprecated because FSSpec is deprecated in Mac OS X. */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_GetFile_From_Mac_ATS_Name
argument_list|(
argument|const char*  fontName
argument_list|,
argument|FSSpec*      pathSpec
argument_list|,
argument|FT_Long*     face_index
argument_list|)
end_macro
begin_block
block|{
name|FSRef
name|ref
decl_stmt|;
name|FT_Error
name|err
decl_stmt|;
name|err
operator|=
name|FT_GetFileRef_From_Mac_ATS_Name
argument_list|(
name|fontName
argument_list|,
operator|&
name|ref
argument_list|,
name|face_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|FT_Err_Ok
operator|!=
name|err
condition|)
return|return
name|err
return|;
if|if
condition|(
name|noErr
operator|!=
name|FSGetCatalogInfo
argument_list|(
operator|&
name|ref
argument_list|,
name|kFSCatInfoNone
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pathSpec
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
name|FT_Err_Unknown_File_Format
return|;
return|return
name|FT_Err_Ok
return|;
block|}
end_block
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|__MWERKS__
argument_list|)
operator|&&
operator|!
name|TARGET_RT_MAC_MACHO
end_if
begin_define
DECL|macro|STREAM_FILE
define|#
directive|define
name|STREAM_FILE
parameter_list|(
name|stream
parameter_list|)
value|( (FT_FILE*)stream->descriptor.pointer )
end_define
begin_macro
name|FT_CALLBACK_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|ft_FSp_stream_close
name|ft_FSp_stream_close
argument_list|(
argument|FT_Stream  stream
argument_list|)
end_macro
begin_block
block|{
name|ft_fclose
argument_list|(
name|STREAM_FILE
argument_list|(
name|stream
argument_list|)
argument_list|)
expr_stmt|;
name|stream
operator|->
name|descriptor
operator|.
name|pointer
operator|=
name|NULL
expr_stmt|;
name|stream
operator|->
name|size
operator|=
literal|0
expr_stmt|;
name|stream
operator|->
name|base
operator|=
literal|0
expr_stmt|;
block|}
end_block
begin_macro
name|FT_CALLBACK_DEF
argument_list|(
argument|unsigned long
argument_list|)
end_macro
begin_macro
DECL|function|ft_FSp_stream_io
name|ft_FSp_stream_io
argument_list|(
argument|FT_Stream       stream
argument_list|,
argument|unsigned long   offset
argument_list|,
argument|unsigned char*  buffer
argument_list|,
argument|unsigned long   count
argument_list|)
end_macro
begin_block
block|{
name|FT_FILE
modifier|*
name|file
decl_stmt|;
name|file
operator|=
name|STREAM_FILE
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|ft_fseek
argument_list|(
name|file
argument_list|,
name|offset
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
return|return
operator|(
name|unsigned
name|long
operator|)
name|ft_fread
argument_list|(
name|buffer
argument_list|,
literal|1
argument_list|,
name|count
argument_list|,
name|file
argument_list|)
return|;
block|}
end_block
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* __MWERKS__&& !TARGET_RT_MAC_MACHO */
end_comment
begin_if
if|#
directive|if
name|HAVE_FSSPEC
operator|&&
operator|!
name|HAVE_FSREF
end_if
begin_comment
comment|/* isDirectory is a dummy to synchronize API with FSPathMakeRef() */
end_comment
begin_function
specifier|static
name|OSErr
DECL|function|FT_FSPathMakeSpec
name|FT_FSPathMakeSpec
parameter_list|(
specifier|const
name|UInt8
modifier|*
name|pathname
parameter_list|,
name|FSSpec
modifier|*
name|spec_p
parameter_list|,
name|Boolean
name|isDirectory
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|short
name|vRefNum
decl_stmt|;
name|long
name|dirID
decl_stmt|;
name|Str255
name|nodeName
decl_stmt|;
name|OSErr
name|err
decl_stmt|;
name|FT_UNUSED
argument_list|(
name|isDirectory
argument_list|)
expr_stmt|;
name|p
operator|=
name|q
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|pathname
expr_stmt|;
name|dirID
operator|=
literal|0
expr_stmt|;
name|vRefNum
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|len
init|=
name|ft_strlen
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|>
literal|255
condition|)
name|len
operator|=
literal|255
expr_stmt|;
name|q
operator|=
name|p
operator|+
name|len
expr_stmt|;
if|if
condition|(
name|q
operator|==
name|p
condition|)
return|return
literal|0
return|;
if|if
condition|(
literal|255
operator|<
name|ft_strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pathname
argument_list|)
condition|)
block|{
while|while
condition|(
name|p
operator|<
name|q
operator|&&
operator|*
name|q
operator|!=
literal|':'
condition|)
name|q
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|<
name|q
condition|)
operator|*
operator|(
name|char
operator|*
operator|)
name|nodeName
operator|=
name|q
operator|-
name|p
expr_stmt|;
elseif|else
if|if
condition|(
name|ft_strlen
argument_list|(
name|p
argument_list|)
operator|<
literal|256
condition|)
operator|*
operator|(
name|char
operator|*
operator|)
name|nodeName
operator|=
name|ft_strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
return|return
name|errFSNameTooLong
return|;
name|ft_strncpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|nodeName
operator|+
literal|1
argument_list|,
operator|(
name|char
operator|*
operator|)
name|p
argument_list|,
operator|*
operator|(
name|char
operator|*
operator|)
name|nodeName
argument_list|)
expr_stmt|;
name|err
operator|=
name|FSMakeFSSpec
argument_list|(
name|vRefNum
argument_list|,
name|dirID
argument_list|,
name|nodeName
argument_list|,
name|spec_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|||
literal|'\0'
operator|==
operator|*
name|q
condition|)
return|return
name|err
return|;
name|vRefNum
operator|=
name|spec_p
operator|->
name|vRefNum
expr_stmt|;
name|dirID
operator|=
name|spec_p
operator|->
name|parID
expr_stmt|;
name|p
operator|=
name|q
expr_stmt|;
block|}
block|}
end_function
begin_function
specifier|static
name|OSErr
DECL|function|FT_FSpMakePath
name|FT_FSpMakePath
parameter_list|(
specifier|const
name|FSSpec
modifier|*
name|spec_p
parameter_list|,
name|UInt8
modifier|*
name|path
parameter_list|,
name|UInt32
name|maxPathSize
parameter_list|)
block|{
name|OSErr
name|err
decl_stmt|;
name|FSSpec
name|spec
init|=
operator|*
name|spec_p
decl_stmt|;
name|short
name|vRefNum
decl_stmt|;
name|long
name|dirID
decl_stmt|;
name|Str255
name|parDir_name
decl_stmt|;
name|FT_MEM_SET
argument_list|(
name|path
argument_list|,
literal|0
argument_list|,
name|maxPathSize
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|child_namelen
init|=
name|ft_strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|path
argument_list|)
decl_stmt|;
name|unsigned
name|char
name|node_namelen
init|=
name|spec
operator|.
name|name
index|[
literal|0
index|]
decl_stmt|;
name|unsigned
name|char
modifier|*
name|node_name
init|=
name|spec
operator|.
name|name
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|node_namelen
operator|+
name|child_namelen
operator|>
name|maxPathSize
condition|)
return|return
name|errFSNameTooLong
return|;
name|FT_MEM_MOVE
argument_list|(
name|path
operator|+
name|node_namelen
operator|+
literal|1
argument_list|,
name|path
argument_list|,
name|child_namelen
argument_list|)
expr_stmt|;
name|FT_MEM_COPY
argument_list|(
name|path
argument_list|,
name|node_name
argument_list|,
name|node_namelen
argument_list|)
expr_stmt|;
if|if
condition|(
name|child_namelen
operator|>
literal|0
condition|)
name|path
index|[
name|node_namelen
index|]
operator|=
literal|':'
expr_stmt|;
name|vRefNum
operator|=
name|spec
operator|.
name|vRefNum
expr_stmt|;
name|dirID
operator|=
name|spec
operator|.
name|parID
expr_stmt|;
name|parDir_name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|err
operator|=
name|FSMakeFSSpec
argument_list|(
name|vRefNum
argument_list|,
name|dirID
argument_list|,
name|parDir_name
argument_list|,
operator|&
name|spec
argument_list|)
expr_stmt|;
if|if
condition|(
name|noErr
operator|!=
name|err
operator|||
name|dirID
operator|==
name|spec
operator|.
name|parID
condition|)
break|break;
block|}
return|return
name|noErr
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* HAVE_FSSPEC&& !HAVE_FSREF */
end_comment
begin_function
specifier|static
name|OSErr
DECL|function|FT_FSPathMakeRes
name|FT_FSPathMakeRes
parameter_list|(
specifier|const
name|UInt8
modifier|*
name|pathname
parameter_list|,
name|ResFileRefNum
modifier|*
name|res
parameter_list|)
block|{
if|#
directive|if
name|HAVE_FSREF
name|OSErr
name|err
decl_stmt|;
name|FSRef
name|ref
decl_stmt|;
if|if
condition|(
name|noErr
operator|!=
name|FSPathMakeRef
argument_list|(
name|pathname
argument_list|,
operator|&
name|ref
argument_list|,
name|FALSE
argument_list|)
condition|)
return|return
name|FT_Err_Cannot_Open_Resource
return|;
comment|/* at present, no support for dfont format */
name|err
operator|=
name|FSOpenResourceFile
argument_list|(
operator|&
name|ref
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|fsRdPerm
argument_list|,
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|noErr
operator|==
name|err
condition|)
return|return
name|err
return|;
comment|/* fallback to original resource-fork font */
operator|*
name|res
operator|=
name|FSOpenResFile
argument_list|(
operator|&
name|ref
argument_list|,
name|fsRdPerm
argument_list|)
expr_stmt|;
name|err
operator|=
name|ResError
argument_list|()
expr_stmt|;
else|#
directive|else
name|OSErr
name|err
decl_stmt|;
name|FSSpec
name|spec
decl_stmt|;
if|if
condition|(
name|noErr
operator|!=
name|FT_FSPathMakeSpec
argument_list|(
name|pathname
argument_list|,
operator|&
name|spec
argument_list|,
name|FALSE
argument_list|)
condition|)
return|return
name|FT_Err_Cannot_Open_Resource
return|;
comment|/* at present, no support for dfont format without FSRef */
comment|/* (see above), try original resource-fork font          */
operator|*
name|res
operator|=
name|FSpOpenResFile
argument_list|(
operator|&
name|spec
argument_list|,
name|fsRdPerm
argument_list|)
expr_stmt|;
name|err
operator|=
name|ResError
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_FSREF */
return|return
name|err
return|;
block|}
end_function
begin_comment
comment|/* Return the file type for given pathname */
end_comment
begin_function
specifier|static
name|OSType
DECL|function|get_file_type_from_path
name|get_file_type_from_path
parameter_list|(
specifier|const
name|UInt8
modifier|*
name|pathname
parameter_list|)
block|{
if|#
directive|if
name|HAVE_FSREF
name|FSRef
name|ref
decl_stmt|;
name|FSCatalogInfo
name|info
decl_stmt|;
if|if
condition|(
name|noErr
operator|!=
name|FSPathMakeRef
argument_list|(
name|pathname
argument_list|,
operator|&
name|ref
argument_list|,
name|FALSE
argument_list|)
condition|)
return|return
operator|(
name|OSType
operator|)
literal|0
return|;
if|if
condition|(
name|noErr
operator|!=
name|FSGetCatalogInfo
argument_list|(
operator|&
name|ref
argument_list|,
name|kFSCatInfoFinderInfo
argument_list|,
operator|&
name|info
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|(
name|OSType
operator|)
literal|0
return|;
return|return
operator|(
operator|(
name|FInfo
operator|*
operator|)
operator|(
name|info
operator|.
name|finderInfo
operator|)
operator|)
operator|->
name|fdType
return|;
else|#
directive|else
name|FSSpec
name|spec
decl_stmt|;
name|FInfo
name|finfo
decl_stmt|;
if|if
condition|(
name|noErr
operator|!=
name|FT_FSPathMakeSpec
argument_list|(
name|pathname
argument_list|,
operator|&
name|spec
argument_list|,
name|FALSE
argument_list|)
condition|)
return|return
operator|(
name|OSType
operator|)
literal|0
return|;
if|if
condition|(
name|noErr
operator|!=
name|FSpGetFInfo
argument_list|(
operator|&
name|spec
argument_list|,
operator|&
name|finfo
argument_list|)
condition|)
return|return
operator|(
name|OSType
operator|)
literal|0
return|;
return|return
name|finfo
operator|.
name|fdType
return|;
endif|#
directive|endif
comment|/* HAVE_FSREF */
block|}
end_function
begin_comment
comment|/* Given a PostScript font name, create the Macintosh LWFN file name. */
end_comment
begin_function
specifier|static
name|void
DECL|function|create_lwfn_name
name|create_lwfn_name
parameter_list|(
name|char
modifier|*
name|ps_name
parameter_list|,
name|Str255
name|lwfn_file_name
parameter_list|)
block|{
name|int
name|max
init|=
literal|5
decl_stmt|,
name|count
init|=
literal|0
decl_stmt|;
name|FT_Byte
modifier|*
name|p
init|=
name|lwfn_file_name
decl_stmt|;
name|FT_Byte
modifier|*
name|q
init|=
operator|(
name|FT_Byte
operator|*
operator|)
name|ps_name
decl_stmt|;
name|lwfn_file_name
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|q
condition|)
block|{
if|if
condition|(
name|ft_isupper
argument_list|(
operator|*
name|q
argument_list|)
condition|)
block|{
if|if
condition|(
name|count
condition|)
name|max
operator|=
literal|3
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|<
name|max
operator|&&
operator|(
name|ft_isalnum
argument_list|(
operator|*
name|q
argument_list|)
operator|||
operator|*
name|q
operator|==
literal|'_'
operator|)
condition|)
block|{
operator|*
operator|++
name|p
operator|=
operator|*
name|q
expr_stmt|;
name|lwfn_file_name
index|[
literal|0
index|]
operator|++
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
name|q
operator|++
expr_stmt|;
block|}
block|}
end_function
begin_function
specifier|static
name|short
DECL|function|count_faces_sfnt
name|count_faces_sfnt
parameter_list|(
name|char
modifier|*
name|fond_data
parameter_list|)
block|{
comment|/* The count is 1 greater than the value in the FOND.  */
comment|/* Isn't that cute? :-)                                */
return|return
name|EndianS16_BtoN
argument_list|(
operator|*
operator|(
operator|(
name|short
operator|*
operator|)
operator|(
name|fond_data
operator|+
sizeof|sizeof
argument_list|(
name|FamRec
argument_list|)
operator|)
operator|)
argument_list|)
operator|+
literal|1
return|;
block|}
end_function
begin_function
specifier|static
name|short
DECL|function|count_faces_scalable
name|count_faces_scalable
parameter_list|(
name|char
modifier|*
name|fond_data
parameter_list|)
block|{
name|AsscEntry
modifier|*
name|assoc
decl_stmt|;
name|FamRec
modifier|*
name|fond
decl_stmt|;
name|short
name|i
decl_stmt|,
name|face
decl_stmt|,
name|face_all
decl_stmt|;
name|fond
operator|=
operator|(
name|FamRec
operator|*
operator|)
name|fond_data
expr_stmt|;
name|face_all
operator|=
name|EndianS16_BtoN
argument_list|(
operator|*
operator|(
operator|(
name|short
operator|*
operator|)
operator|(
name|fond_data
operator|+
sizeof|sizeof
argument_list|(
name|FamRec
argument_list|)
operator|)
operator|)
argument_list|)
operator|+
literal|1
expr_stmt|;
name|assoc
operator|=
operator|(
name|AsscEntry
operator|*
operator|)
operator|(
name|fond_data
operator|+
sizeof|sizeof
argument_list|(
name|FamRec
argument_list|)
operator|+
literal|2
operator|)
expr_stmt|;
name|face
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|face_all
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
literal|0
operator|==
name|EndianS16_BtoN
argument_list|(
name|assoc
index|[
name|i
index|]
operator|.
name|fontSize
argument_list|)
condition|)
name|face
operator|++
expr_stmt|;
block|}
return|return
name|face
return|;
block|}
end_function
begin_comment
comment|/* Look inside the FOND data, answer whether there should be an SFNT      resource, and answer the name of a possible LWFN Type 1 file.       Thanks to Paul Miller (paulm@profoundeffects.com) for the fix      to load a face OTHER than the first one in the FOND!   */
end_comment
begin_function
specifier|static
name|void
DECL|function|parse_fond
name|parse_fond
parameter_list|(
name|char
modifier|*
name|fond_data
parameter_list|,
name|short
modifier|*
name|have_sfnt
parameter_list|,
name|ResID
modifier|*
name|sfnt_id
parameter_list|,
name|Str255
name|lwfn_file_name
parameter_list|,
name|short
name|face_index
parameter_list|)
block|{
name|AsscEntry
modifier|*
name|assoc
decl_stmt|;
name|AsscEntry
modifier|*
name|base_assoc
decl_stmt|;
name|FamRec
modifier|*
name|fond
decl_stmt|;
operator|*
name|sfnt_id
operator|=
literal|0
expr_stmt|;
operator|*
name|have_sfnt
operator|=
literal|0
expr_stmt|;
name|lwfn_file_name
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|fond
operator|=
operator|(
name|FamRec
operator|*
operator|)
name|fond_data
expr_stmt|;
name|assoc
operator|=
operator|(
name|AsscEntry
operator|*
operator|)
operator|(
name|fond_data
operator|+
sizeof|sizeof
argument_list|(
name|FamRec
argument_list|)
operator|+
literal|2
operator|)
expr_stmt|;
name|base_assoc
operator|=
name|assoc
expr_stmt|;
comment|/* the maximum faces in a FOND is 48, size of StyleTable.indexes[] */
if|if
condition|(
literal|47
operator|<
name|face_index
condition|)
return|return;
comment|/* Let's do a little range checking before we get too excited here */
if|if
condition|(
name|face_index
operator|<
name|count_faces_sfnt
argument_list|(
name|fond_data
argument_list|)
condition|)
block|{
name|assoc
operator|+=
name|face_index
expr_stmt|;
comment|/* add on the face_index! */
comment|/* if the face at this index is not scalable,          fall back to the first one (old behavior) */
if|if
condition|(
name|EndianS16_BtoN
argument_list|(
name|assoc
operator|->
name|fontSize
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|have_sfnt
operator|=
literal|1
expr_stmt|;
operator|*
name|sfnt_id
operator|=
name|EndianS16_BtoN
argument_list|(
name|assoc
operator|->
name|fontID
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|base_assoc
operator|->
name|fontSize
operator|==
literal|0
condition|)
block|{
operator|*
name|have_sfnt
operator|=
literal|1
expr_stmt|;
operator|*
name|sfnt_id
operator|=
name|EndianS16_BtoN
argument_list|(
name|base_assoc
operator|->
name|fontID
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|EndianS32_BtoN
argument_list|(
name|fond
operator|->
name|ffStylOff
argument_list|)
condition|)
block|{
name|unsigned
name|char
modifier|*
name|p
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|fond_data
decl_stmt|;
name|StyleTable
modifier|*
name|style
decl_stmt|;
name|unsigned
name|short
name|string_count
decl_stmt|;
name|char
name|ps_name
index|[
literal|256
index|]
decl_stmt|;
name|unsigned
name|char
modifier|*
name|names
index|[
literal|64
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|p
operator|+=
name|EndianS32_BtoN
argument_list|(
name|fond
operator|->
name|ffStylOff
argument_list|)
expr_stmt|;
name|style
operator|=
operator|(
name|StyleTable
operator|*
operator|)
name|p
expr_stmt|;
name|p
operator|+=
sizeof|sizeof
argument_list|(
name|StyleTable
argument_list|)
expr_stmt|;
name|string_count
operator|=
name|EndianS16_BtoN
argument_list|(
operator|*
operator|(
name|short
operator|*
operator|)
operator|(
name|p
operator|)
argument_list|)
expr_stmt|;
name|p
operator|+=
sizeof|sizeof
argument_list|(
name|short
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|string_count
operator|&&
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
block|{
name|names
index|[
name|i
index|]
operator|=
name|p
expr_stmt|;
name|p
operator|+=
name|names
index|[
name|i
index|]
index|[
literal|0
index|]
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
block|{
name|size_t
name|ps_name_len
init|=
operator|(
name|size_t
operator|)
name|names
index|[
literal|0
index|]
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
name|ps_name_len
operator|!=
literal|0
condition|)
block|{
name|ft_memcpy
argument_list|(
name|ps_name
argument_list|,
name|names
index|[
literal|0
index|]
operator|+
literal|1
argument_list|,
name|ps_name_len
argument_list|)
expr_stmt|;
name|ps_name
index|[
name|ps_name_len
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|style
operator|->
name|indexes
index|[
name|face_index
index|]
operator|>
literal|1
operator|&&
name|style
operator|->
name|indexes
index|[
name|face_index
index|]
operator|<=
name|FT_MIN
argument_list|(
name|string_count
argument_list|,
literal|64
argument_list|)
condition|)
block|{
name|unsigned
name|char
modifier|*
name|suffixes
init|=
name|names
index|[
name|style
operator|->
name|indexes
index|[
name|face_index
index|]
operator|-
literal|1
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|suffixes
index|[
literal|0
index|]
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|char
modifier|*
name|s
decl_stmt|;
name|size_t
name|j
init|=
name|suffixes
index|[
name|i
index|]
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|j
operator|<
name|string_count
operator|&&
operator|(
name|s
operator|=
name|names
index|[
name|j
index|]
operator|)
operator|!=
name|NULL
condition|)
block|{
name|size_t
name|s_len
init|=
operator|(
name|size_t
operator|)
name|s
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
name|s_len
operator|!=
literal|0
operator|&&
name|ps_name_len
operator|+
name|s_len
operator|<
sizeof|sizeof
argument_list|(
name|ps_name
argument_list|)
condition|)
block|{
name|ft_memcpy
argument_list|(
name|ps_name
operator|+
name|ps_name_len
argument_list|,
name|s
operator|+
literal|1
argument_list|,
name|s_len
argument_list|)
expr_stmt|;
name|ps_name_len
operator|+=
name|s_len
expr_stmt|;
name|ps_name
index|[
name|ps_name_len
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
name|create_lwfn_name
argument_list|(
name|ps_name
argument_list|,
name|lwfn_file_name
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
specifier|static
name|FT_Error
DECL|function|lookup_lwfn_by_fond
name|lookup_lwfn_by_fond
parameter_list|(
specifier|const
name|UInt8
modifier|*
name|path_fond
parameter_list|,
name|ConstStr255Param
name|base_lwfn
parameter_list|,
name|UInt8
modifier|*
name|path_lwfn
parameter_list|,
name|int
name|path_size
parameter_list|)
block|{
if|#
directive|if
name|HAVE_FSREF
name|FSRef
name|ref
decl_stmt|,
name|par_ref
decl_stmt|;
name|int
name|dirname_len
decl_stmt|;
comment|/* Pathname for FSRef can be in various formats: HFS, HFS+, and POSIX. */
comment|/* We should not extract parent directory by string manipulation.      */
if|if
condition|(
name|noErr
operator|!=
name|FSPathMakeRef
argument_list|(
name|path_fond
argument_list|,
operator|&
name|ref
argument_list|,
name|FALSE
argument_list|)
condition|)
return|return
name|FT_Err_Invalid_Argument
return|;
if|if
condition|(
name|noErr
operator|!=
name|FSGetCatalogInfo
argument_list|(
operator|&
name|ref
argument_list|,
name|kFSCatInfoNone
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|par_ref
argument_list|)
condition|)
return|return
name|FT_Err_Invalid_Argument
return|;
if|if
condition|(
name|noErr
operator|!=
name|FSRefMakePath
argument_list|(
operator|&
name|par_ref
argument_list|,
name|path_lwfn
argument_list|,
name|path_size
argument_list|)
condition|)
return|return
name|FT_Err_Invalid_Argument
return|;
if|if
condition|(
name|ft_strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|path_lwfn
argument_list|)
operator|+
literal|1
operator|+
name|base_lwfn
index|[
literal|0
index|]
operator|>
name|path_size
condition|)
return|return
name|FT_Err_Invalid_Argument
return|;
comment|/* now we have absolute dirname in path_lwfn */
if|if
condition|(
name|path_lwfn
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
name|ft_strcat
argument_list|(
operator|(
name|char
operator|*
operator|)
name|path_lwfn
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
else|else
name|ft_strcat
argument_list|(
operator|(
name|char
operator|*
operator|)
name|path_lwfn
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|dirname_len
operator|=
name|ft_strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|path_lwfn
argument_list|)
expr_stmt|;
name|ft_strcat
argument_list|(
operator|(
name|char
operator|*
operator|)
name|path_lwfn
argument_list|,
operator|(
name|char
operator|*
operator|)
name|base_lwfn
operator|+
literal|1
argument_list|)
expr_stmt|;
name|path_lwfn
index|[
name|dirname_len
operator|+
name|base_lwfn
index|[
literal|0
index|]
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|noErr
operator|!=
name|FSPathMakeRef
argument_list|(
name|path_lwfn
argument_list|,
operator|&
name|ref
argument_list|,
name|FALSE
argument_list|)
condition|)
return|return
name|FT_Err_Cannot_Open_Resource
return|;
if|if
condition|(
name|noErr
operator|!=
name|FSGetCatalogInfo
argument_list|(
operator|&
name|ref
argument_list|,
name|kFSCatInfoNone
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
name|FT_Err_Cannot_Open_Resource
return|;
return|return
name|FT_Err_Ok
return|;
else|#
directive|else
name|int
name|i
decl_stmt|;
name|FSSpec
name|spec
decl_stmt|;
comment|/* pathname for FSSpec is always HFS format */
if|if
condition|(
name|ft_strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|path_fond
argument_list|)
operator|>
name|path_size
condition|)
return|return
name|FT_Err_Invalid_Argument
return|;
name|ft_strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|path_lwfn
argument_list|,
operator|(
name|char
operator|*
operator|)
name|path_fond
argument_list|)
expr_stmt|;
name|i
operator|=
name|ft_strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|path_lwfn
argument_list|)
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|i
operator|>
literal|0
operator|&&
literal|':'
operator|!=
name|path_lwfn
index|[
name|i
index|]
condition|)
name|i
operator|--
expr_stmt|;
if|if
condition|(
name|i
operator|+
literal|1
operator|+
name|base_lwfn
index|[
literal|0
index|]
operator|>
name|path_size
condition|)
return|return
name|FT_Err_Invalid_Argument
return|;
if|if
condition|(
literal|':'
operator|==
name|path_lwfn
index|[
name|i
index|]
condition|)
block|{
name|ft_strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|path_lwfn
operator|+
name|i
operator|+
literal|1
argument_list|,
operator|(
name|char
operator|*
operator|)
name|base_lwfn
operator|+
literal|1
argument_list|)
expr_stmt|;
name|path_lwfn
index|[
name|i
operator|+
literal|1
operator|+
name|base_lwfn
index|[
literal|0
index|]
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|ft_strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|path_lwfn
argument_list|,
operator|(
name|char
operator|*
operator|)
name|base_lwfn
operator|+
literal|1
argument_list|)
expr_stmt|;
name|path_lwfn
index|[
name|base_lwfn
index|[
literal|0
index|]
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|noErr
operator|!=
name|FT_FSPathMakeSpec
argument_list|(
name|path_lwfn
argument_list|,
operator|&
name|spec
argument_list|,
name|FALSE
argument_list|)
condition|)
return|return
name|FT_Err_Cannot_Open_Resource
return|;
return|return
name|FT_Err_Ok
return|;
endif|#
directive|endif
comment|/* HAVE_FSREF */
block|}
end_function
begin_function
specifier|static
name|short
DECL|function|count_faces
name|count_faces
parameter_list|(
name|Handle
name|fond
parameter_list|,
specifier|const
name|UInt8
modifier|*
name|pathname
parameter_list|)
block|{
name|ResID
name|sfnt_id
decl_stmt|;
name|short
name|have_sfnt
decl_stmt|,
name|have_lwfn
decl_stmt|;
name|Str255
name|lwfn_file_name
decl_stmt|;
name|UInt8
name|buff
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|FT_Error
name|err
decl_stmt|;
name|short
name|num_faces
decl_stmt|;
name|have_sfnt
operator|=
name|have_lwfn
operator|=
literal|0
expr_stmt|;
name|HLock
argument_list|(
name|fond
argument_list|)
expr_stmt|;
name|parse_fond
argument_list|(
operator|*
name|fond
argument_list|,
operator|&
name|have_sfnt
argument_list|,
operator|&
name|sfnt_id
argument_list|,
name|lwfn_file_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|lwfn_file_name
index|[
literal|0
index|]
condition|)
block|{
name|err
operator|=
name|lookup_lwfn_by_fond
argument_list|(
name|pathname
argument_list|,
name|lwfn_file_name
argument_list|,
name|buff
argument_list|,
sizeof|sizeof
argument_list|(
name|buff
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|FT_Err_Ok
operator|==
name|err
condition|)
name|have_lwfn
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|have_lwfn
operator|&&
operator|(
operator|!
name|have_sfnt
operator|||
name|PREFER_LWFN
operator|)
condition|)
name|num_faces
operator|=
literal|1
expr_stmt|;
else|else
name|num_faces
operator|=
name|count_faces_scalable
argument_list|(
operator|*
name|fond
argument_list|)
expr_stmt|;
name|HUnlock
argument_list|(
name|fond
argument_list|)
expr_stmt|;
return|return
name|num_faces
return|;
block|}
end_function
begin_comment
comment|/* Read Type 1 data from the POST resources inside the LWFN file,      return a PFB buffer.  This is somewhat convoluted because the FT2      PFB parser wants the ASCII header as one chunk, and the LWFN      chunks are often not organized that way, so we glue chunks      of the same type together. */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|read_lwfn
name|read_lwfn
parameter_list|(
name|FT_Memory
name|memory
parameter_list|,
name|ResFileRefNum
name|res
parameter_list|,
name|FT_Byte
modifier|*
modifier|*
name|pfb_data
parameter_list|,
name|FT_ULong
modifier|*
name|size
parameter_list|)
block|{
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
name|ResID
name|res_id
decl_stmt|;
name|unsigned
name|char
modifier|*
name|buffer
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|size_p
init|=
name|NULL
decl_stmt|;
name|FT_ULong
name|total_size
init|=
literal|0
decl_stmt|;
name|FT_ULong
name|old_total_size
init|=
literal|0
decl_stmt|;
name|FT_ULong
name|post_size
decl_stmt|,
name|pfb_chunk_size
decl_stmt|;
name|Handle
name|post_data
decl_stmt|;
name|char
name|code
decl_stmt|,
name|last_code
decl_stmt|;
name|UseResFile
argument_list|(
name|res
argument_list|)
expr_stmt|;
comment|/* First pass: load all POST resources, and determine the size of */
comment|/* the output buffer.                                             */
name|res_id
operator|=
literal|501
expr_stmt|;
name|last_code
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|post_data
operator|=
name|Get1Resource
argument_list|(
name|TTAG_POST
argument_list|,
name|res_id
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|post_data
operator|==
name|NULL
condition|)
break|break;
comment|/* we are done */
name|code
operator|=
operator|(
operator|*
name|post_data
operator|)
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|code
operator|!=
name|last_code
condition|)
block|{
if|if
condition|(
name|code
operator|==
literal|5
condition|)
name|total_size
operator|+=
literal|2
expr_stmt|;
comment|/* just the end code */
else|else
name|total_size
operator|+=
literal|6
expr_stmt|;
comment|/* code + 4 bytes chunk length */
block|}
name|total_size
operator|+=
name|GetHandleSize
argument_list|(
name|post_data
argument_list|)
operator|-
literal|2
expr_stmt|;
name|last_code
operator|=
name|code
expr_stmt|;
comment|/* detect integer overflows */
if|if
condition|(
name|total_size
operator|<
name|old_total_size
condition|)
block|{
name|error
operator|=
name|FT_Err_Array_Too_Large
expr_stmt|;
goto|goto
name|Error
goto|;
block|}
name|old_total_size
operator|=
name|total_size
expr_stmt|;
block|}
if|if
condition|(
name|FT_ALLOC
argument_list|(
name|buffer
argument_list|,
operator|(
name|FT_Long
operator|)
name|total_size
argument_list|)
condition|)
goto|goto
name|Error
goto|;
comment|/* Second pass: append all POST data to the buffer, add PFB fields. */
comment|/* Glue all consecutive chunks of the same type together.           */
name|p
operator|=
name|buffer
expr_stmt|;
name|res_id
operator|=
literal|501
expr_stmt|;
name|last_code
operator|=
operator|-
literal|1
expr_stmt|;
name|pfb_chunk_size
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|post_data
operator|=
name|Get1Resource
argument_list|(
name|TTAG_POST
argument_list|,
name|res_id
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|post_data
operator|==
name|NULL
condition|)
break|break;
comment|/* we are done */
name|post_size
operator|=
operator|(
name|FT_ULong
operator|)
name|GetHandleSize
argument_list|(
name|post_data
argument_list|)
operator|-
literal|2
expr_stmt|;
name|code
operator|=
operator|(
operator|*
name|post_data
operator|)
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|code
operator|!=
name|last_code
condition|)
block|{
if|if
condition|(
name|last_code
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* we are done adding a chunk, fill in the size field */
if|if
condition|(
name|size_p
operator|!=
name|NULL
condition|)
block|{
operator|*
name|size_p
operator|++
operator|=
call|(
name|FT_Byte
call|)
argument_list|(
name|pfb_chunk_size
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
operator|*
name|size_p
operator|++
operator|=
call|(
name|FT_Byte
call|)
argument_list|(
operator|(
name|pfb_chunk_size
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
operator|*
name|size_p
operator|++
operator|=
call|(
name|FT_Byte
call|)
argument_list|(
operator|(
name|pfb_chunk_size
operator|>>
literal|16
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
operator|*
name|size_p
operator|++
operator|=
call|(
name|FT_Byte
call|)
argument_list|(
operator|(
name|pfb_chunk_size
operator|>>
literal|24
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
block|}
name|pfb_chunk_size
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|p
operator|++
operator|=
literal|0x80
expr_stmt|;
if|if
condition|(
name|code
operator|==
literal|5
condition|)
operator|*
name|p
operator|++
operator|=
literal|0x03
expr_stmt|;
comment|/* the end */
elseif|else
if|if
condition|(
name|code
operator|==
literal|2
condition|)
operator|*
name|p
operator|++
operator|=
literal|0x02
expr_stmt|;
comment|/* binary segment */
else|else
operator|*
name|p
operator|++
operator|=
literal|0x01
expr_stmt|;
comment|/* ASCII segment */
if|if
condition|(
name|code
operator|!=
literal|5
condition|)
block|{
name|size_p
operator|=
name|p
expr_stmt|;
comment|/* save for later */
name|p
operator|+=
literal|4
expr_stmt|;
comment|/* make space for size field */
block|}
block|}
name|ft_memcpy
argument_list|(
name|p
argument_list|,
operator|*
name|post_data
operator|+
literal|2
argument_list|,
name|post_size
argument_list|)
expr_stmt|;
name|pfb_chunk_size
operator|+=
name|post_size
expr_stmt|;
name|p
operator|+=
name|post_size
expr_stmt|;
name|last_code
operator|=
name|code
expr_stmt|;
block|}
operator|*
name|pfb_data
operator|=
name|buffer
expr_stmt|;
operator|*
name|size
operator|=
name|total_size
expr_stmt|;
name|Error
label|:
name|CloseResFile
argument_list|(
name|res
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_comment
comment|/* Create a new FT_Face from a file spec to an LWFN file. */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|FT_New_Face_From_LWFN
name|FT_New_Face_From_LWFN
parameter_list|(
name|FT_Library
name|library
parameter_list|,
specifier|const
name|UInt8
modifier|*
name|pathname
parameter_list|,
name|FT_Long
name|face_index
parameter_list|,
name|FT_Face
modifier|*
name|aface
parameter_list|)
block|{
name|FT_Byte
modifier|*
name|pfb_data
decl_stmt|;
name|FT_ULong
name|pfb_size
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
name|ResFileRefNum
name|res
decl_stmt|;
if|if
condition|(
name|noErr
operator|!=
name|FT_FSPathMakeRes
argument_list|(
name|pathname
argument_list|,
operator|&
name|res
argument_list|)
condition|)
return|return
name|FT_Err_Cannot_Open_Resource
return|;
name|pfb_data
operator|=
name|NULL
expr_stmt|;
name|pfb_size
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|read_lwfn
argument_list|(
name|library
operator|->
name|memory
argument_list|,
name|res
argument_list|,
operator|&
name|pfb_data
argument_list|,
operator|&
name|pfb_size
argument_list|)
expr_stmt|;
name|CloseResFile
argument_list|(
name|res
argument_list|)
expr_stmt|;
comment|/* PFB is already loaded, useless anymore */
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
return|return
name|open_face_from_buffer
argument_list|(
name|library
argument_list|,
name|pfb_data
argument_list|,
name|pfb_size
argument_list|,
name|face_index
argument_list|,
literal|"type1"
argument_list|,
name|aface
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/* Create a new FT_Face from an SFNT resource, specified by res ID. */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|FT_New_Face_From_SFNT
name|FT_New_Face_From_SFNT
parameter_list|(
name|FT_Library
name|library
parameter_list|,
name|ResID
name|sfnt_id
parameter_list|,
name|FT_Long
name|face_index
parameter_list|,
name|FT_Face
modifier|*
name|aface
parameter_list|)
block|{
name|Handle
name|sfnt
init|=
name|NULL
decl_stmt|;
name|FT_Byte
modifier|*
name|sfnt_data
decl_stmt|;
name|size_t
name|sfnt_size
decl_stmt|;
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
name|FT_Memory
name|memory
init|=
name|library
operator|->
name|memory
decl_stmt|;
name|int
name|is_cff
decl_stmt|,
name|is_sfnt_ps
decl_stmt|;
name|sfnt
operator|=
name|GetResource
argument_list|(
name|TTAG_sfnt
argument_list|,
name|sfnt_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|sfnt
operator|==
name|NULL
condition|)
return|return
name|FT_Err_Invalid_Handle
return|;
name|sfnt_size
operator|=
operator|(
name|FT_ULong
operator|)
name|GetHandleSize
argument_list|(
name|sfnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|FT_ALLOC
argument_list|(
name|sfnt_data
argument_list|,
operator|(
name|FT_Long
operator|)
name|sfnt_size
argument_list|)
condition|)
block|{
name|ReleaseResource
argument_list|(
name|sfnt
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|HLock
argument_list|(
name|sfnt
argument_list|)
expr_stmt|;
name|ft_memcpy
argument_list|(
name|sfnt_data
argument_list|,
operator|*
name|sfnt
argument_list|,
name|sfnt_size
argument_list|)
expr_stmt|;
name|HUnlock
argument_list|(
name|sfnt
argument_list|)
expr_stmt|;
name|ReleaseResource
argument_list|(
name|sfnt
argument_list|)
expr_stmt|;
name|is_cff
operator|=
name|sfnt_size
operator|>
literal|4
operator|&&
operator|!
name|ft_memcmp
argument_list|(
name|sfnt_data
argument_list|,
literal|"OTTO"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|is_sfnt_ps
operator|=
name|sfnt_size
operator|>
literal|4
operator|&&
operator|!
name|ft_memcmp
argument_list|(
name|sfnt_data
argument_list|,
literal|"typ1"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_sfnt_ps
condition|)
block|{
name|FT_Stream
name|stream
decl_stmt|;
if|if
condition|(
name|FT_NEW
argument_list|(
name|stream
argument_list|)
condition|)
goto|goto
name|Try_OpenType
goto|;
name|FT_Stream_OpenMemory
argument_list|(
name|stream
argument_list|,
name|sfnt_data
argument_list|,
name|sfnt_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|open_face_PS_from_sfnt_stream
argument_list|(
name|library
argument_list|,
name|stream
argument_list|,
name|face_index
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|aface
argument_list|)
condition|)
block|{
name|FT_Stream_Close
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|FT_FREE
argument_list|(
name|sfnt_data
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|FT_FREE
argument_list|(
name|stream
argument_list|)
expr_stmt|;
block|}
name|Try_OpenType
label|:
name|error
operator|=
name|open_face_from_buffer
argument_list|(
name|library
argument_list|,
name|sfnt_data
argument_list|,
name|sfnt_size
argument_list|,
name|face_index
argument_list|,
name|is_cff
condition|?
literal|"cff"
else|:
literal|"truetype"
argument_list|,
name|aface
argument_list|)
expr_stmt|;
name|Exit
label|:
return|return
name|error
return|;
block|}
end_function
begin_comment
comment|/* Create a new FT_Face from a file spec to a suitcase file. */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|FT_New_Face_From_Suitcase
name|FT_New_Face_From_Suitcase
parameter_list|(
name|FT_Library
name|library
parameter_list|,
specifier|const
name|UInt8
modifier|*
name|pathname
parameter_list|,
name|FT_Long
name|face_index
parameter_list|,
name|FT_Face
modifier|*
name|aface
parameter_list|)
block|{
name|FT_Error
name|error
init|=
name|FT_Err_Cannot_Open_Resource
decl_stmt|;
name|ResFileRefNum
name|res_ref
decl_stmt|;
name|ResourceIndex
name|res_index
decl_stmt|;
name|Handle
name|fond
decl_stmt|;
name|short
name|num_faces_in_res
decl_stmt|,
name|num_faces_in_fond
decl_stmt|;
if|if
condition|(
name|noErr
operator|!=
name|FT_FSPathMakeRes
argument_list|(
name|pathname
argument_list|,
operator|&
name|res_ref
argument_list|)
condition|)
return|return
name|FT_Err_Cannot_Open_Resource
return|;
name|UseResFile
argument_list|(
name|res_ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|ResError
argument_list|()
condition|)
return|return
name|FT_Err_Cannot_Open_Resource
return|;
name|num_faces_in_res
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|res_index
operator|=
literal|1
init|;
condition|;
operator|++
name|res_index
control|)
block|{
name|fond
operator|=
name|Get1IndResource
argument_list|(
name|TTAG_FOND
argument_list|,
name|res_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|ResError
argument_list|()
condition|)
break|break;
name|num_faces_in_fond
operator|=
name|count_faces
argument_list|(
name|fond
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
name|num_faces_in_res
operator|+=
name|num_faces_in_fond
expr_stmt|;
if|if
condition|(
literal|0
operator|<=
name|face_index
operator|&&
name|face_index
operator|<
name|num_faces_in_fond
operator|&&
name|error
condition|)
name|error
operator|=
name|FT_New_Face_From_FOND
argument_list|(
name|library
argument_list|,
name|fond
argument_list|,
name|face_index
argument_list|,
name|aface
argument_list|)
expr_stmt|;
name|face_index
operator|-=
name|num_faces_in_fond
expr_stmt|;
block|}
name|CloseResFile
argument_list|(
name|res_ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|FT_Err_Ok
operator|==
name|error
operator|&&
name|NULL
operator|!=
name|aface
condition|)
operator|(
operator|*
name|aface
operator|)
operator|->
name|num_faces
operator|=
name|num_faces_in_res
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_comment
comment|/* documentation is in ftmac.h */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_New_Face_From_FOND
argument_list|(
argument|FT_Library  library
argument_list|,
argument|Handle      fond
argument_list|,
argument|FT_Long     face_index
argument_list|,
argument|FT_Face*    aface
argument_list|)
end_macro
begin_block
block|{
name|short
name|have_sfnt
decl_stmt|,
name|have_lwfn
init|=
literal|0
decl_stmt|;
name|ResID
name|sfnt_id
decl_stmt|,
name|fond_id
decl_stmt|;
name|OSType
name|fond_type
decl_stmt|;
name|Str255
name|fond_name
decl_stmt|;
name|Str255
name|lwfn_file_name
decl_stmt|;
name|UInt8
name|path_lwfn
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|OSErr
name|err
decl_stmt|;
name|FT_Error
name|error
init|=
name|FT_Err_Ok
decl_stmt|;
name|GetResInfo
argument_list|(
name|fond
argument_list|,
operator|&
name|fond_id
argument_list|,
operator|&
name|fond_type
argument_list|,
name|fond_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ResError
argument_list|()
operator|!=
name|noErr
operator|||
name|fond_type
operator|!=
name|TTAG_FOND
condition|)
return|return
name|FT_Err_Invalid_File_Format
return|;
name|HLock
argument_list|(
name|fond
argument_list|)
expr_stmt|;
name|parse_fond
argument_list|(
operator|*
name|fond
argument_list|,
operator|&
name|have_sfnt
argument_list|,
operator|&
name|sfnt_id
argument_list|,
name|lwfn_file_name
argument_list|,
name|face_index
argument_list|)
expr_stmt|;
name|HUnlock
argument_list|(
name|fond
argument_list|)
expr_stmt|;
if|if
condition|(
name|lwfn_file_name
index|[
literal|0
index|]
condition|)
block|{
name|ResFileRefNum
name|res
decl_stmt|;
name|res
operator|=
name|HomeResFile
argument_list|(
name|fond
argument_list|)
expr_stmt|;
if|if
condition|(
name|noErr
operator|!=
name|ResError
argument_list|()
condition|)
goto|goto
name|found_no_lwfn_file
goto|;
if|#
directive|if
name|HAVE_FSREF
block|{
name|UInt8
name|path_fond
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|FSRef
name|ref
decl_stmt|;
name|err
operator|=
name|FSGetForkCBInfo
argument_list|(
name|res
argument_list|,
name|kFSInvalidVolumeRefNum
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|ref
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|noErr
operator|!=
name|err
condition|)
goto|goto
name|found_no_lwfn_file
goto|;
name|err
operator|=
name|FSRefMakePath
argument_list|(
operator|&
name|ref
argument_list|,
name|path_fond
argument_list|,
sizeof|sizeof
argument_list|(
name|path_fond
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|noErr
operator|!=
name|err
condition|)
goto|goto
name|found_no_lwfn_file
goto|;
name|error
operator|=
name|lookup_lwfn_by_fond
argument_list|(
name|path_fond
argument_list|,
name|lwfn_file_name
argument_list|,
name|path_lwfn
argument_list|,
sizeof|sizeof
argument_list|(
name|path_lwfn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|FT_Err_Ok
operator|==
name|error
condition|)
name|have_lwfn
operator|=
literal|1
expr_stmt|;
block|}
elif|#
directive|elif
name|HAVE_FSSPEC
block|{
name|UInt8
name|path_fond
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|FCBPBRec
name|pb
decl_stmt|;
name|Str255
name|fond_file_name
decl_stmt|;
name|FSSpec
name|spec
decl_stmt|;
name|FT_MEM_SET
argument_list|(
operator|&
name|spec
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|FSSpec
argument_list|)
argument_list|)
expr_stmt|;
name|FT_MEM_SET
argument_list|(
operator|&
name|pb
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|FCBPBRec
argument_list|)
argument_list|)
expr_stmt|;
name|pb
operator|.
name|ioNamePtr
operator|=
name|fond_file_name
expr_stmt|;
name|pb
operator|.
name|ioVRefNum
operator|=
literal|0
expr_stmt|;
name|pb
operator|.
name|ioRefNum
operator|=
name|res
expr_stmt|;
name|pb
operator|.
name|ioFCBIndx
operator|=
literal|0
expr_stmt|;
name|err
operator|=
name|PBGetFCBInfoSync
argument_list|(
operator|&
name|pb
argument_list|)
expr_stmt|;
if|if
condition|(
name|noErr
operator|!=
name|err
condition|)
goto|goto
name|found_no_lwfn_file
goto|;
name|err
operator|=
name|FSMakeFSSpec
argument_list|(
name|pb
operator|.
name|ioFCBVRefNum
argument_list|,
name|pb
operator|.
name|ioFCBParID
argument_list|,
name|fond_file_name
argument_list|,
operator|&
name|spec
argument_list|)
expr_stmt|;
if|if
condition|(
name|noErr
operator|!=
name|err
condition|)
goto|goto
name|found_no_lwfn_file
goto|;
name|err
operator|=
name|FT_FSpMakePath
argument_list|(
operator|&
name|spec
argument_list|,
name|path_fond
argument_list|,
sizeof|sizeof
argument_list|(
name|path_fond
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|noErr
operator|!=
name|err
condition|)
goto|goto
name|found_no_lwfn_file
goto|;
name|error
operator|=
name|lookup_lwfn_by_fond
argument_list|(
name|path_fond
argument_list|,
name|lwfn_file_name
argument_list|,
name|path_lwfn
argument_list|,
sizeof|sizeof
argument_list|(
name|path_lwfn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|FT_Err_Ok
operator|==
name|error
condition|)
name|have_lwfn
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* HAVE_FSREF, HAVE_FSSPEC */
block|}
if|if
condition|(
name|have_lwfn
operator|&&
operator|(
operator|!
name|have_sfnt
operator|||
name|PREFER_LWFN
operator|)
condition|)
name|error
operator|=
name|FT_New_Face_From_LWFN
argument_list|(
name|library
argument_list|,
name|path_lwfn
argument_list|,
name|face_index
argument_list|,
name|aface
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|FT_Err_Unknown_File_Format
expr_stmt|;
name|found_no_lwfn_file
label|:
if|if
condition|(
name|have_sfnt
operator|&&
name|FT_Err_Ok
operator|!=
name|error
condition|)
name|error
operator|=
name|FT_New_Face_From_SFNT
argument_list|(
name|library
argument_list|,
name|sfnt_id
argument_list|,
name|face_index
argument_list|,
name|aface
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_block
begin_comment
comment|/* Common function to load a new FT_Face from a resource file. */
end_comment
begin_function
specifier|static
name|FT_Error
DECL|function|FT_New_Face_From_Resource
name|FT_New_Face_From_Resource
parameter_list|(
name|FT_Library
name|library
parameter_list|,
specifier|const
name|UInt8
modifier|*
name|pathname
parameter_list|,
name|FT_Long
name|face_index
parameter_list|,
name|FT_Face
modifier|*
name|aface
parameter_list|)
block|{
name|OSType
name|file_type
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
comment|/* LWFN is a (very) specific file format, check for it explicitly */
name|file_type
operator|=
name|get_file_type_from_path
argument_list|(
name|pathname
argument_list|)
expr_stmt|;
if|if
condition|(
name|file_type
operator|==
name|TTAG_LWFN
condition|)
return|return
name|FT_New_Face_From_LWFN
argument_list|(
name|library
argument_list|,
name|pathname
argument_list|,
name|face_index
argument_list|,
name|aface
argument_list|)
return|;
comment|/* Otherwise the file type doesn't matter (there are more than  */
comment|/* `FFIL' and `tfil').  Just try opening it as a font suitcase; */
comment|/* if it works, fine.                                           */
name|error
operator|=
name|FT_New_Face_From_Suitcase
argument_list|(
name|library
argument_list|,
name|pathname
argument_list|,
name|face_index
argument_list|,
name|aface
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
return|return
name|error
return|;
comment|/* let it fall through to normal loader (.ttf, .otf, etc.); */
comment|/* we signal this by returning no error and no FT_Face      */
operator|*
name|aface
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    FT_New_Face                                                        */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    This is the Mac-specific implementation of FT_New_Face.  In        */
end_comment
begin_comment
comment|/*    addition to the standard FT_New_Face() functionality, it also      */
end_comment
begin_comment
comment|/*    accepts pathnames to Mac suitcase files.  For further              */
end_comment
begin_comment
comment|/*    documentation see the original FT_New_Face() in freetype.h.        */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_New_Face
argument_list|(
argument|FT_Library   library
argument_list|,
argument|const char*  pathname
argument_list|,
argument|FT_Long      face_index
argument_list|,
argument|FT_Face*     aface
argument_list|)
end_macro
begin_block
block|{
name|FT_Open_Args
name|args
decl_stmt|;
name|FT_Error
name|error
decl_stmt|;
comment|/* test for valid `library' and `aface' delayed to FT_Open_Face() */
if|if
condition|(
operator|!
name|pathname
condition|)
return|return
name|FT_Err_Invalid_Argument
return|;
name|error
operator|=
name|FT_Err_Ok
expr_stmt|;
operator|*
name|aface
operator|=
name|NULL
expr_stmt|;
comment|/* try resourcefork based font: LWFN, FFIL */
name|error
operator|=
name|FT_New_Face_From_Resource
argument_list|(
name|library
argument_list|,
operator|(
name|UInt8
operator|*
operator|)
name|pathname
argument_list|,
name|face_index
argument_list|,
name|aface
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
operator|*
name|aface
operator|!=
name|NULL
condition|)
return|return
name|error
return|;
comment|/* let it fall through to normal loader (.ttf, .otf, etc.) */
name|args
operator|.
name|flags
operator|=
name|FT_OPEN_PATHNAME
expr_stmt|;
name|args
operator|.
name|pathname
operator|=
operator|(
name|char
operator|*
operator|)
name|pathname
expr_stmt|;
return|return
name|FT_Open_Face
argument_list|(
name|library
argument_list|,
operator|&
name|args
argument_list|,
name|face_index
argument_list|,
name|aface
argument_list|)
return|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    FT_New_Face_From_FSRef                                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    FT_New_Face_From_FSRef is identical to FT_New_Face except it       */
end_comment
begin_comment
comment|/*    accepts an FSRef instead of a path.                                */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* This function is deprecated because Carbon data types (FSRef)         */
end_comment
begin_comment
comment|/* are not cross-platform, and thus not suitable for the freetype API.   */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_New_Face_From_FSRef
argument_list|(
argument|FT_Library    library
argument_list|,
argument|const FSRef*  ref
argument_list|,
argument|FT_Long       face_index
argument_list|,
argument|FT_Face*      aface
argument_list|)
end_macro
begin_block
block|{
if|#
directive|if
operator|!
name|HAVE_FSREF
name|FT_UNUSED
argument_list|(
name|library
argument_list|)
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|ref
argument_list|)
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|face_index
argument_list|)
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|aface
argument_list|)
expr_stmt|;
return|return
name|FT_Err_Unimplemented_Feature
return|;
else|#
directive|else
name|FT_Error
name|error
decl_stmt|;
name|FT_Open_Args
name|args
decl_stmt|;
name|OSErr
name|err
decl_stmt|;
name|UInt8
name|pathname
index|[
name|PATH_MAX
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|ref
condition|)
return|return
name|FT_Err_Invalid_Argument
return|;
name|err
operator|=
name|FSRefMakePath
argument_list|(
name|ref
argument_list|,
name|pathname
argument_list|,
sizeof|sizeof
argument_list|(
name|pathname
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|error
operator|=
name|FT_Err_Cannot_Open_Resource
expr_stmt|;
name|error
operator|=
name|FT_New_Face_From_Resource
argument_list|(
name|library
argument_list|,
name|pathname
argument_list|,
name|face_index
argument_list|,
name|aface
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
operator|*
name|aface
operator|!=
name|NULL
condition|)
return|return
name|error
return|;
comment|/* fallback to datafork font */
name|args
operator|.
name|flags
operator|=
name|FT_OPEN_PATHNAME
expr_stmt|;
name|args
operator|.
name|pathname
operator|=
operator|(
name|char
operator|*
operator|)
name|pathname
expr_stmt|;
return|return
name|FT_Open_Face
argument_list|(
name|library
argument_list|,
operator|&
name|args
argument_list|,
name|face_index
argument_list|,
name|aface
argument_list|)
return|;
endif|#
directive|endif
comment|/* HAVE_FSREF */
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    FT_New_Face_From_FSSpec                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    FT_New_Face_From_FSSpec is identical to FT_New_Face except it      */
end_comment
begin_comment
comment|/*    accepts an FSSpec instead of a path.                               */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* This function is deprecated because Carbon data types (FSSpec)        */
end_comment
begin_comment
comment|/* are not cross-platform, and thus not suitable for the freetype API.   */
end_comment
begin_macro
DECL|function|FT_EXPORT_DEF
name|FT_EXPORT_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_New_Face_From_FSSpec
argument_list|(
argument|FT_Library     library
argument_list|,
argument|const FSSpec*  spec
argument_list|,
argument|FT_Long        face_index
argument_list|,
argument|FT_Face*       aface
argument_list|)
end_macro
begin_block
block|{
if|#
directive|if
name|HAVE_FSREF
name|FSRef
name|ref
decl_stmt|;
if|if
condition|(
operator|!
name|spec
operator|||
name|FSpMakeFSRef
argument_list|(
name|spec
argument_list|,
operator|&
name|ref
argument_list|)
operator|!=
name|noErr
condition|)
return|return
name|FT_Err_Invalid_Argument
return|;
else|else
return|return
name|FT_New_Face_From_FSRef
argument_list|(
name|library
argument_list|,
operator|&
name|ref
argument_list|,
name|face_index
argument_list|,
name|aface
argument_list|)
return|;
elif|#
directive|elif
name|HAVE_FSSPEC
name|FT_Error
name|error
decl_stmt|;
name|FT_Open_Args
name|args
decl_stmt|;
name|OSErr
name|err
decl_stmt|;
name|UInt8
name|pathname
index|[
name|PATH_MAX
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|spec
condition|)
return|return
name|FT_Err_Invalid_Argument
return|;
name|err
operator|=
name|FT_FSpMakePath
argument_list|(
name|spec
argument_list|,
name|pathname
argument_list|,
sizeof|sizeof
argument_list|(
name|pathname
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|error
operator|=
name|FT_Err_Cannot_Open_Resource
expr_stmt|;
name|error
operator|=
name|FT_New_Face_From_Resource
argument_list|(
name|library
argument_list|,
name|pathname
argument_list|,
name|face_index
argument_list|,
name|aface
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
operator|*
name|aface
operator|!=
name|NULL
condition|)
return|return
name|error
return|;
comment|/* fallback to datafork font */
name|args
operator|.
name|flags
operator|=
name|FT_OPEN_PATHNAME
expr_stmt|;
name|args
operator|.
name|pathname
operator|=
operator|(
name|char
operator|*
operator|)
name|pathname
expr_stmt|;
return|return
name|FT_Open_Face
argument_list|(
name|library
argument_list|,
operator|&
name|args
argument_list|,
name|face_index
argument_list|,
name|aface
argument_list|)
return|;
else|#
directive|else
name|FT_UNUSED
argument_list|(
name|library
argument_list|)
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|spec
argument_list|)
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|face_index
argument_list|)
expr_stmt|;
name|FT_UNUSED
argument_list|(
name|aface
argument_list|)
expr_stmt|;
return|return
name|FT_Err_Unimplemented_Feature
return|;
endif|#
directive|endif
comment|/* HAVE_FSREF, HAVE_FSSPEC */
block|}
end_block
begin_comment
comment|/* END */
end_comment
end_unit
