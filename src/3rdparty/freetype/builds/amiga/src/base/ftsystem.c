begin_unit
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  ftsystem.c                                                             */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*    Amiga-specific FreeType low-level system interface (body).           */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  Copyright 1996-2001, 2002, 2005, 2006, 2007 by                         */
end_comment
begin_comment
comment|/*  David Turner, Robert Wilhelm, Werner Lemberg and Detlef Würkner.       */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/*  This file is part of the FreeType project, and may only be used,       */
end_comment
begin_comment
comment|/*  modified, and distributed under the terms of the FreeType project      */
end_comment
begin_comment
comment|/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
end_comment
begin_comment
comment|/*  this file you indicate that you have read the license and              */
end_comment
begin_comment
comment|/*  understand and accept it fully.                                        */
end_comment
begin_comment
comment|/*                                                                         */
end_comment
begin_comment
comment|/***************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* This file contains the Amiga interface used by FreeType to access     */
end_comment
begin_comment
comment|/* low-level, i.e. memory management, i/o access as well as thread       */
end_comment
begin_comment
comment|/* synchronisation.                                                      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* Maintained by Detlef Würkner<TetiSoft@apg.lahn.de>                   */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* Based on the original ftsystem.c,                                     */
end_comment
begin_comment
comment|/* modified to avoid fopen(), fclose(), fread(), fseek(), ftell(),       */
end_comment
begin_comment
comment|/* malloc(), realloc(), and free().                                      */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* Those C library functions are often not thread-safe or cant be        */
end_comment
begin_comment
comment|/* used in a shared Amiga library. If that's not a problem for you,       */
end_comment
begin_comment
comment|/* you can of course use the default ftsystem.c with C library calls     */
end_comment
begin_comment
comment|/* instead.                                                              */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* This implementation needs exec V39+ because it uses AllocPooled() etc */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_define
DECL|macro|__NOLIBBASE__
define|#
directive|define
name|__NOLIBBASE__
end_define
begin_define
DECL|macro|__NOGLOBALIFACE__
define|#
directive|define
name|__NOGLOBALIFACE__
end_define
begin_define
DECL|macro|__USE_INLINE__
define|#
directive|define
name|__USE_INLINE__
end_define
begin_include
include|#
directive|include
file|<proto/exec.h>
end_include
begin_include
include|#
directive|include
file|<dos/stdio.h>
end_include
begin_include
include|#
directive|include
file|<proto/dos.h>
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|__amigaos4__
end_ifdef
begin_decl_stmt
specifier|extern
name|struct
name|ExecIFace
modifier|*
name|IExec
decl_stmt|;
end_decl_stmt
begin_decl_stmt
specifier|extern
name|struct
name|DOSIFace
modifier|*
name|IDOS
decl_stmt|;
end_decl_stmt
begin_else
else|#
directive|else
end_else
begin_decl_stmt
specifier|extern
name|struct
name|Library
modifier|*
name|SysBase
decl_stmt|;
end_decl_stmt
begin_decl_stmt
specifier|extern
name|struct
name|Library
modifier|*
name|DOSBase
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|IOBUF_SIZE
define|#
directive|define
name|IOBUF_SIZE
value|512
end_define
begin_comment
comment|/* structure that helps us to avoid  * useless calls of Seek() and Read()  */
end_comment
begin_struct
DECL|struct|SysFile
struct|struct
name|SysFile
block|{
DECL|member|file
name|BPTR
name|file
decl_stmt|;
DECL|member|iobuf_start
name|ULONG
name|iobuf_start
decl_stmt|;
DECL|member|iobuf_end
name|ULONG
name|iobuf_end
decl_stmt|;
DECL|member|iobuf
name|UBYTE
name|iobuf
index|[
name|IOBUF_SIZE
index|]
decl_stmt|;
block|}
struct|;
end_struct
begin_ifndef
ifndef|#
directive|ifndef
name|__amigaos4__
end_ifndef
begin_comment
comment|/* C implementation of AllocVecPooled (see autodoc exec/AllocPooled) */
end_comment
begin_function
name|APTR
DECL|function|Alloc_VecPooled
name|Alloc_VecPooled
parameter_list|(
name|APTR
name|poolHeader
parameter_list|,
name|ULONG
name|memSize
parameter_list|)
block|{
name|ULONG
name|newSize
init|=
name|memSize
operator|+
sizeof|sizeof
argument_list|(
name|ULONG
argument_list|)
decl_stmt|;
name|ULONG
modifier|*
name|mem
init|=
name|AllocPooled
argument_list|(
name|poolHeader
argument_list|,
name|newSize
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|mem
condition|)
return|return
name|NULL
return|;
operator|*
name|mem
operator|=
name|newSize
expr_stmt|;
return|return
name|mem
operator|+
literal|1
return|;
block|}
end_function
begin_comment
comment|/* C implementation of FreeVecPooled (see autodoc exec/AllocPooled) */
end_comment
begin_function
name|void
DECL|function|Free_VecPooled
name|Free_VecPooled
parameter_list|(
name|APTR
name|poolHeader
parameter_list|,
name|APTR
name|memory
parameter_list|)
block|{
name|ULONG
modifier|*
name|realmem
init|=
operator|(
name|ULONG
operator|*
operator|)
name|memory
operator|-
literal|1
decl_stmt|;
name|FreePooled
argument_list|(
name|poolHeader
argument_list|,
name|realmem
argument_list|,
operator|*
name|realmem
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|<ft2build.h>
end_include
begin_include
include|#
directive|include
include|FT_CONFIG_CONFIG_H
end_include
begin_include
include|#
directive|include
include|FT_INTERNAL_DEBUG_H
end_include
begin_include
include|#
directive|include
include|FT_SYSTEM_H
end_include
begin_include
include|#
directive|include
include|FT_ERRORS_H
end_include
begin_include
include|#
directive|include
include|FT_TYPES_H
end_include
begin_include
include|#
directive|include
file|<stdio.h>
end_include
begin_include
include|#
directive|include
file|<stdlib.h>
end_include
begin_include
include|#
directive|include
file|<string.h>
end_include
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*                       MEMORY MANAGEMENT INTERFACE                     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* It is not necessary to do any error checking for the                  */
end_comment
begin_comment
comment|/* allocation-related functions.  This is done by the higher level       */
end_comment
begin_comment
comment|/* routines like ft_mem_alloc() or ft_mem_realloc().                     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    ft_alloc                                                           */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    The memory allocation function.                                    */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    memory :: A pointer to the memory object.                          */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    size   :: The requested size in bytes.                             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    The address of newly allocated block.                              */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_macro
name|FT_CALLBACK_DEF
argument_list|(
argument|void*
argument_list|)
end_macro
begin_macro
DECL|function|ft_alloc
name|ft_alloc
argument_list|(
argument|FT_Memory  memory
argument_list|,
argument|long       size
argument_list|)
end_macro
begin_block
block|{
ifdef|#
directive|ifdef
name|__amigaos4__
return|return
name|AllocVecPooled
argument_list|(
name|memory
operator|->
name|user
argument_list|,
name|size
argument_list|)
return|;
else|#
directive|else
return|return
name|Alloc_VecPooled
argument_list|(
name|memory
operator|->
name|user
argument_list|,
name|size
argument_list|)
return|;
endif|#
directive|endif
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    ft_realloc                                                         */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    The memory reallocation function.                                  */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    memory   :: A pointer to the memory object.                        */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    cur_size :: The current size of the allocated memory block.        */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    new_size :: The newly requested size in bytes.                     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    block    :: The current address of the block in memory.            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    The address of the reallocated memory block.                       */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_macro
name|FT_CALLBACK_DEF
argument_list|(
argument|void*
argument_list|)
end_macro
begin_macro
DECL|function|ft_realloc
name|ft_realloc
argument_list|(
argument|FT_Memory  memory
argument_list|,
argument|long       cur_size
argument_list|,
argument|long       new_size
argument_list|,
argument|void*      block
argument_list|)
end_macro
begin_block
block|{
name|void
modifier|*
name|new_block
decl_stmt|;
ifdef|#
directive|ifdef
name|__amigaos4__
name|new_block
operator|=
name|AllocVecPooled
argument_list|(
name|memory
operator|->
name|user
argument_list|,
name|new_size
argument_list|)
expr_stmt|;
else|#
directive|else
name|new_block
operator|=
name|Alloc_VecPooled
argument_list|(
name|memory
operator|->
name|user
argument_list|,
name|new_size
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|new_block
operator|!=
name|NULL
condition|)
block|{
name|CopyMem
argument_list|(
name|block
argument_list|,
name|new_block
argument_list|,
operator|(
name|new_size
operator|>
name|cur_size
operator|)
condition|?
name|cur_size
else|:
name|new_size
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__amigaos4__
name|FreeVecPooled
argument_list|(
name|memory
operator|->
name|user
argument_list|,
name|block
argument_list|)
expr_stmt|;
else|#
directive|else
name|Free_VecPooled
argument_list|(
name|memory
operator|->
name|user
argument_list|,
name|block
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
name|new_block
return|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    ft_free                                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    The memory release function.                                       */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    memory  :: A pointer to the memory object.                         */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    block   :: The address of block in memory to be freed.             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_macro
name|FT_CALLBACK_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|ft_free
name|ft_free
argument_list|(
argument|FT_Memory  memory
argument_list|,
argument|void*      block
argument_list|)
end_macro
begin_block
block|{
ifdef|#
directive|ifdef
name|__amigaos4__
name|FreeVecPooled
argument_list|(
name|memory
operator|->
name|user
argument_list|,
name|block
argument_list|)
expr_stmt|;
else|#
directive|else
name|Free_VecPooled
argument_list|(
name|memory
operator|->
name|user
argument_list|,
name|block
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*                     RESOURCE MANAGEMENT INTERFACE                     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
end_comment
begin_comment
comment|/* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
end_comment
begin_comment
comment|/* messages during execution.                                            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_undef
DECL|macro|FT_COMPONENT
undef|#
directive|undef
name|FT_COMPONENT
end_undef
begin_define
DECL|macro|FT_COMPONENT
define|#
directive|define
name|FT_COMPONENT
value|trace_io
end_define
begin_comment
comment|/* We use the macro STREAM_FILE for convenience to extract the       */
end_comment
begin_comment
comment|/* system-specific stream handle from a given FreeType stream object */
end_comment
begin_define
DECL|macro|STREAM_FILE
define|#
directive|define
name|STREAM_FILE
parameter_list|(
name|stream
parameter_list|)
value|( (struct SysFile *)stream->descriptor.pointer )
end_define
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    ft_amiga_stream_close                                              */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    The function to close a stream.                                    */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    stream :: A pointer to the stream object.                          */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_macro
name|FT_CALLBACK_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|ft_amiga_stream_close
name|ft_amiga_stream_close
argument_list|(
argument|FT_Stream  stream
argument_list|)
end_macro
begin_block
block|{
name|struct
name|SysFile
modifier|*
name|sysfile
decl_stmt|;
name|sysfile
operator|=
name|STREAM_FILE
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|Close
argument_list|(
name|sysfile
operator|->
name|file
argument_list|)
expr_stmt|;
name|FreeMem
argument_list|(
name|sysfile
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|SysFile
argument_list|)
argument_list|)
expr_stmt|;
name|stream
operator|->
name|descriptor
operator|.
name|pointer
operator|=
name|NULL
expr_stmt|;
name|stream
operator|->
name|size
operator|=
literal|0
expr_stmt|;
name|stream
operator|->
name|base
operator|=
literal|0
expr_stmt|;
block|}
end_block
begin_comment
comment|/*************************************************************************/
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Function>                                                            */
end_comment
begin_comment
comment|/*    ft_amiga_stream_io                                                 */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Description>                                                         */
end_comment
begin_comment
comment|/*    The function to open a stream.                                     */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Input>                                                               */
end_comment
begin_comment
comment|/*    stream :: A pointer to the stream object.                          */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    offset :: The position in the data stream to start reading.        */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    buffer :: The address of buffer to store the read data.            */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*    count  :: The number of bytes to read from the stream.             */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_comment
comment|/*<Return>                                                              */
end_comment
begin_comment
comment|/*    The number of bytes actually read.                                 */
end_comment
begin_comment
comment|/*                                                                       */
end_comment
begin_macro
name|FT_CALLBACK_DEF
argument_list|(
argument|unsigned long
argument_list|)
end_macro
begin_macro
DECL|function|ft_amiga_stream_io
name|ft_amiga_stream_io
argument_list|(
argument|FT_Stream       stream
argument_list|,
argument|unsigned long   offset
argument_list|,
argument|unsigned char*  buffer
argument_list|,
argument|unsigned long   count
argument_list|)
end_macro
begin_block
block|{
name|struct
name|SysFile
modifier|*
name|sysfile
decl_stmt|;
name|unsigned
name|long
name|read_bytes
decl_stmt|;
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
block|{
name|sysfile
operator|=
name|STREAM_FILE
argument_list|(
name|stream
argument_list|)
expr_stmt|;
comment|/* handle the seek */
if|if
condition|(
operator|(
name|offset
operator|<
name|sysfile
operator|->
name|iobuf_start
operator|)
operator|||
operator|(
name|offset
operator|+
name|count
operator|>
name|sysfile
operator|->
name|iobuf_end
operator|)
condition|)
block|{
comment|/* requested offset implies we need a buffer refill */
if|if
condition|(
operator|!
name|sysfile
operator|->
name|iobuf_end
operator|||
name|offset
operator|!=
name|sysfile
operator|->
name|iobuf_end
condition|)
block|{
comment|/* a physical seek is necessary */
name|Seek
argument_list|(
name|sysfile
operator|->
name|file
argument_list|,
name|offset
argument_list|,
name|OFFSET_BEGINNING
argument_list|)
expr_stmt|;
block|}
name|sysfile
operator|->
name|iobuf_start
operator|=
name|offset
expr_stmt|;
name|sysfile
operator|->
name|iobuf_end
operator|=
literal|0
expr_stmt|;
comment|/* trigger a buffer refill */
block|}
comment|/* handle the read */
if|if
condition|(
name|offset
operator|+
name|count
operator|<=
name|sysfile
operator|->
name|iobuf_end
condition|)
block|{
comment|/* we have buffer and requested bytes are all inside our buffer */
name|CopyMem
argument_list|(
operator|&
name|sysfile
operator|->
name|iobuf
index|[
name|offset
operator|-
name|sysfile
operator|->
name|iobuf_start
index|]
argument_list|,
name|buffer
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|read_bytes
operator|=
name|count
expr_stmt|;
block|}
else|else
block|{
comment|/* (re)fill buffer */
if|if
condition|(
name|count
operator|<=
name|IOBUF_SIZE
condition|)
block|{
comment|/* requested bytes is a subset of the buffer */
name|read_bytes
operator|=
name|Read
argument_list|(
name|sysfile
operator|->
name|file
argument_list|,
name|sysfile
operator|->
name|iobuf
argument_list|,
name|IOBUF_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_bytes
operator|==
operator|-
literal|1UL
condition|)
block|{
comment|/* error */
name|read_bytes
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|sysfile
operator|->
name|iobuf_end
operator|=
name|offset
operator|+
name|read_bytes
expr_stmt|;
name|CopyMem
argument_list|(
name|sysfile
operator|->
name|iobuf
argument_list|,
name|buffer
argument_list|,
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_bytes
operator|>
name|count
condition|)
block|{
name|read_bytes
operator|=
name|count
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* we actually need more than our buffer can hold, so we decide           ** to do a single big read, and then copy the last IOBUF_SIZE           ** bytes of that to our internal buffer for later use */
name|read_bytes
operator|=
name|Read
argument_list|(
name|sysfile
operator|->
name|file
argument_list|,
name|buffer
argument_list|,
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_bytes
operator|==
operator|-
literal|1UL
condition|)
block|{
comment|/* error */
name|read_bytes
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|ULONG
name|bufsize
decl_stmt|;
name|bufsize
operator|=
operator|(
name|read_bytes
operator|>
name|IOBUF_SIZE
operator|)
condition|?
name|IOBUF_SIZE
else|:
name|read_bytes
expr_stmt|;
name|sysfile
operator|->
name|iobuf_end
operator|=
name|offset
operator|+
name|read_bytes
expr_stmt|;
name|sysfile
operator|->
name|iobuf_start
operator|=
name|sysfile
operator|->
name|iobuf_end
operator|-
name|bufsize
expr_stmt|;
name|CopyMem
argument_list|(
operator|&
name|buffer
index|[
name|read_bytes
operator|-
name|bufsize
index|]
argument_list|,
name|sysfile
operator|->
name|iobuf
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
name|read_bytes
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|read_bytes
return|;
block|}
end_block
begin_comment
comment|/* documentation is in ftobjs.h */
end_comment
begin_macro
DECL|function|FT_BASE_DEF
name|FT_BASE_DEF
argument_list|(
argument|FT_Error
argument_list|)
end_macro
begin_macro
name|FT_Stream_Open
argument_list|(
argument|FT_Stream    stream
argument_list|,
argument|const char*  filepathname
argument_list|)
end_macro
begin_block
block|{
name|struct
name|FileInfoBlock
modifier|*
name|fib
decl_stmt|;
name|struct
name|SysFile
modifier|*
name|sysfile
decl_stmt|;
if|if
condition|(
operator|!
name|stream
condition|)
return|return
name|FT_Err_Invalid_Stream_Handle
return|;
ifdef|#
directive|ifdef
name|__amigaos4__
name|sysfile
operator|=
name|AllocMem
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|SysFile
argument_list|)
argument_list|,
name|MEMF_SHARED
argument_list|)
expr_stmt|;
else|#
directive|else
name|sysfile
operator|=
name|AllocMem
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|SysFile
argument_list|)
argument_list|,
name|MEMF_PUBLIC
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|sysfile
condition|)
block|{
name|FT_ERROR
argument_list|(
operator|(
literal|"FT_Stream_Open:"
operator|)
argument_list|)
expr_stmt|;
name|FT_ERROR
argument_list|(
operator|(
literal|" could not open `%s'\n"
operator|,
name|filepathname
operator|)
argument_list|)
expr_stmt|;
return|return
name|FT_Err_Cannot_Open_Resource
return|;
block|}
name|sysfile
operator|->
name|file
operator|=
name|Open
argument_list|(
operator|(
name|STRPTR
operator|)
name|filepathname
argument_list|,
name|MODE_OLDFILE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sysfile
operator|->
name|file
condition|)
block|{
name|FreeMem
argument_list|(
name|sysfile
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|SysFile
argument_list|)
argument_list|)
expr_stmt|;
name|FT_ERROR
argument_list|(
operator|(
literal|"FT_Stream_Open:"
operator|)
argument_list|)
expr_stmt|;
name|FT_ERROR
argument_list|(
operator|(
literal|" could not open `%s'\n"
operator|,
name|filepathname
operator|)
argument_list|)
expr_stmt|;
return|return
name|FT_Err_Cannot_Open_Resource
return|;
block|}
name|fib
operator|=
name|AllocDosObject
argument_list|(
name|DOS_FIB
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fib
condition|)
block|{
name|Close
argument_list|(
name|sysfile
operator|->
name|file
argument_list|)
expr_stmt|;
name|FreeMem
argument_list|(
name|sysfile
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|SysFile
argument_list|)
argument_list|)
expr_stmt|;
name|FT_ERROR
argument_list|(
operator|(
literal|"FT_Stream_Open:"
operator|)
argument_list|)
expr_stmt|;
name|FT_ERROR
argument_list|(
operator|(
literal|" could not open `%s'\n"
operator|,
name|filepathname
operator|)
argument_list|)
expr_stmt|;
return|return
name|FT_Err_Cannot_Open_Resource
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|ExamineFH
argument_list|(
name|sysfile
operator|->
name|file
argument_list|,
name|fib
argument_list|)
operator|)
condition|)
block|{
name|FreeDosObject
argument_list|(
name|DOS_FIB
argument_list|,
name|fib
argument_list|)
expr_stmt|;
name|Close
argument_list|(
name|sysfile
operator|->
name|file
argument_list|)
expr_stmt|;
name|FreeMem
argument_list|(
name|sysfile
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|SysFile
argument_list|)
argument_list|)
expr_stmt|;
name|FT_ERROR
argument_list|(
operator|(
literal|"FT_Stream_Open:"
operator|)
argument_list|)
expr_stmt|;
name|FT_ERROR
argument_list|(
operator|(
literal|" could not open `%s'\n"
operator|,
name|filepathname
operator|)
argument_list|)
expr_stmt|;
return|return
name|FT_Err_Cannot_Open_Resource
return|;
block|}
name|stream
operator|->
name|size
operator|=
name|fib
operator|->
name|fib_Size
expr_stmt|;
name|FreeDosObject
argument_list|(
name|DOS_FIB
argument_list|,
name|fib
argument_list|)
expr_stmt|;
name|stream
operator|->
name|descriptor
operator|.
name|pointer
operator|=
operator|(
name|void
operator|*
operator|)
name|sysfile
expr_stmt|;
name|stream
operator|->
name|pathname
operator|.
name|pointer
operator|=
operator|(
name|char
operator|*
operator|)
name|filepathname
expr_stmt|;
name|sysfile
operator|->
name|iobuf_start
operator|=
literal|0
expr_stmt|;
name|sysfile
operator|->
name|iobuf_end
operator|=
literal|0
expr_stmt|;
name|stream
operator|->
name|pos
operator|=
literal|0
expr_stmt|;
name|stream
operator|->
name|read
operator|=
name|ft_amiga_stream_io
expr_stmt|;
name|stream
operator|->
name|close
operator|=
name|ft_amiga_stream_close
expr_stmt|;
name|FT_TRACE1
argument_list|(
operator|(
literal|"FT_Stream_Open:"
operator|)
argument_list|)
expr_stmt|;
name|FT_TRACE1
argument_list|(
operator|(
literal|" opened `%s' (%ld bytes) successfully\n"
operator|,
name|filepathname
operator|,
name|stream
operator|->
name|size
operator|)
argument_list|)
expr_stmt|;
return|return
name|FT_Err_Ok
return|;
block|}
end_block
begin_ifdef
ifdef|#
directive|ifdef
name|FT_DEBUG_MEMORY
end_ifdef
begin_function_decl
specifier|extern
name|FT_Int
name|ft_mem_debug_init
parameter_list|(
name|FT_Memory
name|memory
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|extern
name|void
name|ft_mem_debug_done
parameter_list|(
name|FT_Memory
name|memory
parameter_list|)
function_decl|;
end_function_decl
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* documentation is in ftobjs.h */
end_comment
begin_macro
DECL|function|FT_BASE_DEF
name|FT_BASE_DEF
argument_list|(
argument|FT_Memory
argument_list|)
end_macro
begin_macro
name|FT_New_Memory
argument_list|(
argument|void
argument_list|)
end_macro
begin_block
block|{
name|FT_Memory
name|memory
decl_stmt|;
ifdef|#
directive|ifdef
name|__amigaos4__
name|memory
operator|=
operator|(
name|FT_Memory
operator|)
name|AllocVec
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|memory
argument_list|)
argument_list|,
name|MEMF_SHARED
argument_list|)
expr_stmt|;
else|#
directive|else
name|memory
operator|=
operator|(
name|FT_Memory
operator|)
name|AllocVec
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|memory
argument_list|)
argument_list|,
name|MEMF_PUBLIC
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|memory
condition|)
block|{
ifdef|#
directive|ifdef
name|__amigaos4__
name|memory
operator|->
name|user
operator|=
name|CreatePool
argument_list|(
name|MEMF_SHARED
argument_list|,
literal|16384
argument_list|,
literal|16384
argument_list|)
expr_stmt|;
else|#
directive|else
name|memory
operator|->
name|user
operator|=
name|CreatePool
argument_list|(
name|MEMF_PUBLIC
argument_list|,
literal|16384
argument_list|,
literal|16384
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|memory
operator|->
name|user
operator|==
name|NULL
condition|)
block|{
name|FreeVec
argument_list|(
name|memory
argument_list|)
expr_stmt|;
name|memory
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|memory
operator|->
name|alloc
operator|=
name|ft_alloc
expr_stmt|;
name|memory
operator|->
name|realloc
operator|=
name|ft_realloc
expr_stmt|;
name|memory
operator|->
name|free
operator|=
name|ft_free
expr_stmt|;
ifdef|#
directive|ifdef
name|FT_DEBUG_MEMORY
name|ft_mem_debug_init
argument_list|(
name|memory
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
return|return
name|memory
return|;
block|}
end_block
begin_comment
comment|/* documentation is in ftobjs.h */
end_comment
begin_macro
name|FT_BASE_DEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|FT_Done_Memory
name|FT_Done_Memory
argument_list|(
argument|FT_Memory  memory
argument_list|)
end_macro
begin_block
block|{
ifdef|#
directive|ifdef
name|FT_DEBUG_MEMORY
name|ft_mem_debug_done
argument_list|(
name|memory
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|DeletePool
argument_list|(
name|memory
operator|->
name|user
argument_list|)
expr_stmt|;
name|FreeVec
argument_list|(
name|memory
argument_list|)
expr_stmt|;
block|}
end_block
begin_comment
comment|/* Local Variables: coding: latin-1 End: */
end_comment
begin_comment
comment|/* END */
end_comment
end_unit
