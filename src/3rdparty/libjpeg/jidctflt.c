begin_unit
begin_comment
comment|/*  * jidctflt.c  *  * Copyright (C) 1994-1998, Thomas G. Lane.  * Modified 2010 by Guido Vollbeding.  * This file is part of the Independent JPEG Group's software.  * For conditions of distribution and use, see the accompanying README file.  *  * This file contains a floating-point implementation of the  * inverse DCT (Discrete Cosine Transform).  In the IJG code, this routine  * must also perform dequantization of the input coefficients.  *  * This implementation should be more accurate than either of the integer  * IDCT implementations.  However, it may not give the same results on all  * machines because of differences in roundoff behavior.  Speed will depend  * on the hardware's floating point capacity.  *  * A 2-D IDCT can be done by 1-D IDCT on each column followed by 1-D IDCT  * on each row (or vice versa, but it's more convenient to emit a row at  * a time).  Direct algorithms are also available, but they are much more  * complex and seem not to be any faster when reduced to code.  *  * This implementation is based on Arai, Agui, and Nakajima's algorithm for  * scaled DCT.  Their original paper (Trans. IEICE E-71(11):1095) is in  * Japanese, but the algorithm is described in the Pennebaker& Mitchell  * JPEG textbook (see REFERENCES section in file README).  The following code  * is based directly on figure 4-8 in P&M.  * While an 8-point DCT cannot be done in less than 11 multiplies, it is  * possible to arrange the computation so that many of the multiplies are  * simple scalings of the final outputs.  These multiplies can then be  * folded into the multiplications or divisions by the JPEG quantization  * table entries.  The AA&N method leaves only 5 multiplies and 29 adds  * to be done in the DCT itself.  * The primary disadvantage of this method is that with a fixed-point  * implementation, accuracy is lost due to imprecise representation of the  * scaled quantization values.  However, that problem does not arise if  * we use floating point arithmetic.  */
end_comment
begin_define
DECL|macro|JPEG_INTERNALS
define|#
directive|define
name|JPEG_INTERNALS
end_define
begin_include
include|#
directive|include
file|"jinclude.h"
end_include
begin_include
include|#
directive|include
file|"jpeglib.h"
end_include
begin_include
include|#
directive|include
file|"jdct.h"
end_include
begin_comment
comment|/* Private declarations for DCT subsystem */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|DCT_FLOAT_SUPPORTED
end_ifdef
begin_comment
comment|/*  * This module is specialized to the case DCTSIZE = 8.  */
end_comment
begin_if
if|#
directive|if
name|DCTSIZE
operator|!=
literal|8
end_if
begin_expr_stmt
name|Sorry
operator|,
name|this
name|code
name|only
name|copes
name|with
literal|8x8
name|DCTs
operator|.
comment|/* deliberate syntax err */
endif|#
directive|endif
comment|/* Dequantize a coefficient by multiplying it by the multiplier-table  * entry; produce a float result.  */
DECL|macro|DEQUANTIZE
define|#
directive|define
name|DEQUANTIZE
parameter_list|(
name|coef
parameter_list|,
name|quantval
parameter_list|)
value|(((FAST_FLOAT) (coef)) * (quantval))
comment|/*  * Perform dequantization and inverse DCT on one block of coefficients.  */
name|GLOBAL
argument_list|(
argument|void
argument_list|)
DECL|function|jpeg_idct_float
name|jpeg_idct_float
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|,
argument|jpeg_component_info * compptr
argument_list|,
argument|JCOEFPTR coef_block
argument_list|,
argument|JSAMPARRAY output_buf
argument_list|,
argument|JDIMENSION output_col
argument_list|)
block|{
name|FAST_FLOAT
name|tmp0
block|,
name|tmp1
block|,
name|tmp2
block|,
name|tmp3
block|,
name|tmp4
block|,
name|tmp5
block|,
name|tmp6
block|,
name|tmp7
block|;
name|FAST_FLOAT
name|tmp10
block|,
name|tmp11
block|,
name|tmp12
block|,
name|tmp13
block|;
name|FAST_FLOAT
name|z5
block|,
name|z10
block|,
name|z11
block|,
name|z12
block|,
name|z13
block|;
name|JCOEFPTR
name|inptr
block|;
name|FLOAT_MULT_TYPE
operator|*
name|quantptr
block|;
name|FAST_FLOAT
operator|*
name|wsptr
block|;
name|JSAMPROW
name|outptr
block|;
name|JSAMPLE
operator|*
name|range_limit
operator|=
name|cinfo
operator|->
name|sample_range_limit
block|;
name|int
name|ctr
block|;
name|FAST_FLOAT
name|workspace
index|[
name|DCTSIZE2
index|]
block|;
comment|/* buffers data between passes */
comment|/* Pass 1: process columns from input, store into work array. */
name|inptr
operator|=
name|coef_block
block|;
name|quantptr
operator|=
operator|(
name|FLOAT_MULT_TYPE
operator|*
operator|)
name|compptr
operator|->
name|dct_table
block|;
name|wsptr
operator|=
name|workspace
block|;
for|for
control|(
name|ctr
operator|=
name|DCTSIZE
init|;
name|ctr
operator|>
literal|0
condition|;
name|ctr
operator|--
control|)
block|{
comment|/* Due to quantization, we will usually find that many of the input      * coefficients are zero, especially the AC terms.  We can exploit this      * by short-circuiting the IDCT calculation for any column in which all      * the AC terms are zero.  In that case each output is equal to the      * DC coefficient (with scale factor as needed).      * With typical images and quantization tables, half or more of the      * column DCT calculations can be simplified this way.      */
if|if
condition|(
name|inptr
index|[
name|DCTSIZE
operator|*
literal|1
index|]
operator|==
literal|0
operator|&&
name|inptr
index|[
name|DCTSIZE
operator|*
literal|2
index|]
operator|==
literal|0
operator|&&
name|inptr
index|[
name|DCTSIZE
operator|*
literal|3
index|]
operator|==
literal|0
operator|&&
name|inptr
index|[
name|DCTSIZE
operator|*
literal|4
index|]
operator|==
literal|0
operator|&&
name|inptr
index|[
name|DCTSIZE
operator|*
literal|5
index|]
operator|==
literal|0
operator|&&
name|inptr
index|[
name|DCTSIZE
operator|*
literal|6
index|]
operator|==
literal|0
operator|&&
name|inptr
index|[
name|DCTSIZE
operator|*
literal|7
index|]
operator|==
literal|0
condition|)
block|{
comment|/* AC terms all zero */
name|FAST_FLOAT
name|dcval
init|=
name|DEQUANTIZE
argument_list|(
name|inptr
index|[
name|DCTSIZE
operator|*
literal|0
index|]
argument_list|,
name|quantptr
index|[
name|DCTSIZE
operator|*
literal|0
index|]
argument_list|)
decl_stmt|;
name|wsptr
index|[
name|DCTSIZE
operator|*
literal|0
index|]
operator|=
name|dcval
expr_stmt|;
name|wsptr
index|[
name|DCTSIZE
operator|*
literal|1
index|]
operator|=
name|dcval
expr_stmt|;
name|wsptr
index|[
name|DCTSIZE
operator|*
literal|2
index|]
operator|=
name|dcval
expr_stmt|;
name|wsptr
index|[
name|DCTSIZE
operator|*
literal|3
index|]
operator|=
name|dcval
expr_stmt|;
name|wsptr
index|[
name|DCTSIZE
operator|*
literal|4
index|]
operator|=
name|dcval
expr_stmt|;
name|wsptr
index|[
name|DCTSIZE
operator|*
literal|5
index|]
operator|=
name|dcval
expr_stmt|;
name|wsptr
index|[
name|DCTSIZE
operator|*
literal|6
index|]
operator|=
name|dcval
expr_stmt|;
name|wsptr
index|[
name|DCTSIZE
operator|*
literal|7
index|]
operator|=
name|dcval
expr_stmt|;
name|inptr
operator|++
expr_stmt|;
comment|/* advance pointers to next column */
name|quantptr
operator|++
expr_stmt|;
name|wsptr
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* Even part */
name|tmp0
operator|=
name|DEQUANTIZE
argument_list|(
name|inptr
index|[
name|DCTSIZE
operator|*
literal|0
index|]
argument_list|,
name|quantptr
index|[
name|DCTSIZE
operator|*
literal|0
index|]
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|tmp1
operator|=
name|DEQUANTIZE
argument_list|(
name|inptr
index|[
name|DCTSIZE
operator|*
literal|2
index|]
argument_list|,
name|quantptr
index|[
name|DCTSIZE
operator|*
literal|2
index|]
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|tmp2
operator|=
name|DEQUANTIZE
argument_list|(
name|inptr
index|[
name|DCTSIZE
operator|*
literal|4
index|]
argument_list|,
name|quantptr
index|[
name|DCTSIZE
operator|*
literal|4
index|]
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|tmp3
operator|=
name|DEQUANTIZE
argument_list|(
name|inptr
index|[
name|DCTSIZE
operator|*
literal|6
index|]
argument_list|,
name|quantptr
index|[
name|DCTSIZE
operator|*
literal|6
index|]
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|tmp10
operator|=
name|tmp0
operator|+
name|tmp2
expr_stmt|;
end_expr_stmt
begin_comment
comment|/* phase 3 */
end_comment
begin_expr_stmt
name|tmp11
operator|=
name|tmp0
operator|-
name|tmp2
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|tmp13
operator|=
name|tmp1
operator|+
name|tmp3
expr_stmt|;
end_expr_stmt
begin_comment
comment|/* phases 5-3 */
end_comment
begin_expr_stmt
name|tmp12
operator|=
operator|(
name|tmp1
operator|-
name|tmp3
operator|)
operator|*
operator|(
operator|(
name|FAST_FLOAT
operator|)
literal|1.414213562
operator|)
operator|-
name|tmp13
expr_stmt|;
end_expr_stmt
begin_comment
comment|/* 2*c4 */
end_comment
begin_expr_stmt
name|tmp0
operator|=
name|tmp10
operator|+
name|tmp13
expr_stmt|;
end_expr_stmt
begin_comment
comment|/* phase 2 */
end_comment
begin_expr_stmt
name|tmp3
operator|=
name|tmp10
operator|-
name|tmp13
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|tmp1
operator|=
name|tmp11
operator|+
name|tmp12
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|tmp2
operator|=
name|tmp11
operator|-
name|tmp12
expr_stmt|;
end_expr_stmt
begin_comment
comment|/* Odd part */
end_comment
begin_expr_stmt
name|tmp4
operator|=
name|DEQUANTIZE
argument_list|(
name|inptr
index|[
name|DCTSIZE
operator|*
literal|1
index|]
argument_list|,
name|quantptr
index|[
name|DCTSIZE
operator|*
literal|1
index|]
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|tmp5
operator|=
name|DEQUANTIZE
argument_list|(
name|inptr
index|[
name|DCTSIZE
operator|*
literal|3
index|]
argument_list|,
name|quantptr
index|[
name|DCTSIZE
operator|*
literal|3
index|]
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|tmp6
operator|=
name|DEQUANTIZE
argument_list|(
name|inptr
index|[
name|DCTSIZE
operator|*
literal|5
index|]
argument_list|,
name|quantptr
index|[
name|DCTSIZE
operator|*
literal|5
index|]
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|tmp7
operator|=
name|DEQUANTIZE
argument_list|(
name|inptr
index|[
name|DCTSIZE
operator|*
literal|7
index|]
argument_list|,
name|quantptr
index|[
name|DCTSIZE
operator|*
literal|7
index|]
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|z13
operator|=
name|tmp6
operator|+
name|tmp5
expr_stmt|;
end_expr_stmt
begin_comment
comment|/* phase 6 */
end_comment
begin_expr_stmt
name|z10
operator|=
name|tmp6
operator|-
name|tmp5
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|z11
operator|=
name|tmp4
operator|+
name|tmp7
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|z12
operator|=
name|tmp4
operator|-
name|tmp7
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|tmp7
operator|=
name|z11
operator|+
name|z13
expr_stmt|;
end_expr_stmt
begin_comment
comment|/* phase 5 */
end_comment
begin_expr_stmt
name|tmp11
operator|=
operator|(
name|z11
operator|-
name|z13
operator|)
operator|*
operator|(
operator|(
name|FAST_FLOAT
operator|)
literal|1.414213562
operator|)
expr_stmt|;
end_expr_stmt
begin_comment
comment|/* 2*c4 */
end_comment
begin_expr_stmt
name|z5
operator|=
operator|(
name|z10
operator|+
name|z12
operator|)
operator|*
operator|(
operator|(
name|FAST_FLOAT
operator|)
literal|1.847759065
operator|)
expr_stmt|;
end_expr_stmt
begin_comment
comment|/* 2*c2 */
end_comment
begin_expr_stmt
name|tmp10
operator|=
name|z5
operator|-
name|z12
operator|*
operator|(
operator|(
name|FAST_FLOAT
operator|)
literal|1.082392200
operator|)
expr_stmt|;
end_expr_stmt
begin_comment
comment|/* 2*(c2-c6) */
end_comment
begin_expr_stmt
name|tmp12
operator|=
name|z5
operator|-
name|z10
operator|*
operator|(
operator|(
name|FAST_FLOAT
operator|)
literal|2.613125930
operator|)
expr_stmt|;
end_expr_stmt
begin_comment
comment|/* 2*(c2+c6) */
end_comment
begin_expr_stmt
name|tmp6
operator|=
name|tmp12
operator|-
name|tmp7
expr_stmt|;
end_expr_stmt
begin_comment
comment|/* phase 2 */
end_comment
begin_expr_stmt
name|tmp5
operator|=
name|tmp11
operator|-
name|tmp6
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|tmp4
operator|=
name|tmp10
operator|-
name|tmp5
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|wsptr
index|[
name|DCTSIZE
operator|*
literal|0
index|]
operator|=
name|tmp0
operator|+
name|tmp7
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|wsptr
index|[
name|DCTSIZE
operator|*
literal|7
index|]
operator|=
name|tmp0
operator|-
name|tmp7
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|wsptr
index|[
name|DCTSIZE
operator|*
literal|1
index|]
operator|=
name|tmp1
operator|+
name|tmp6
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|wsptr
index|[
name|DCTSIZE
operator|*
literal|6
index|]
operator|=
name|tmp1
operator|-
name|tmp6
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|wsptr
index|[
name|DCTSIZE
operator|*
literal|2
index|]
operator|=
name|tmp2
operator|+
name|tmp5
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|wsptr
index|[
name|DCTSIZE
operator|*
literal|5
index|]
operator|=
name|tmp2
operator|-
name|tmp5
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|wsptr
index|[
name|DCTSIZE
operator|*
literal|3
index|]
operator|=
name|tmp3
operator|+
name|tmp4
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|wsptr
index|[
name|DCTSIZE
operator|*
literal|4
index|]
operator|=
name|tmp3
operator|-
name|tmp4
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|inptr
operator|++
expr_stmt|;
end_expr_stmt
begin_comment
comment|/* advance pointers to next column */
end_comment
begin_expr_stmt
name|quantptr
operator|++
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|wsptr
operator|++
expr_stmt|;
end_expr_stmt
begin_comment
unit|}
comment|/* Pass 2: process rows from work array, store into output array. */
end_comment
begin_expr_stmt
unit|wsptr
operator|=
name|workspace
expr_stmt|;
end_expr_stmt
begin_for
for|for
control|(
name|ctr
operator|=
literal|0
init|;
name|ctr
operator|<
name|DCTSIZE
condition|;
name|ctr
operator|++
control|)
block|{
name|outptr
operator|=
name|output_buf
index|[
name|ctr
index|]
operator|+
name|output_col
expr_stmt|;
comment|/* Rows of zeroes can be exploited in the same way as we did with columns.      * However, the column calculation has created many nonzero AC terms, so      * the simplification applies less often (typically 5% to 10% of the time).      * And testing floats for zero is relatively expensive, so we don't bother.      */
comment|/* Even part */
comment|/* Apply signed->unsigned and prepare float->int conversion */
name|z5
operator|=
name|wsptr
index|[
literal|0
index|]
operator|+
operator|(
operator|(
name|FAST_FLOAT
operator|)
name|CENTERJSAMPLE
operator|+
operator|(
name|FAST_FLOAT
operator|)
literal|0.5
operator|)
expr_stmt|;
name|tmp10
operator|=
name|z5
operator|+
name|wsptr
index|[
literal|4
index|]
expr_stmt|;
name|tmp11
operator|=
name|z5
operator|-
name|wsptr
index|[
literal|4
index|]
expr_stmt|;
name|tmp13
operator|=
name|wsptr
index|[
literal|2
index|]
operator|+
name|wsptr
index|[
literal|6
index|]
expr_stmt|;
name|tmp12
operator|=
operator|(
name|wsptr
index|[
literal|2
index|]
operator|-
name|wsptr
index|[
literal|6
index|]
operator|)
operator|*
operator|(
operator|(
name|FAST_FLOAT
operator|)
literal|1.414213562
operator|)
operator|-
name|tmp13
expr_stmt|;
name|tmp0
operator|=
name|tmp10
operator|+
name|tmp13
expr_stmt|;
name|tmp3
operator|=
name|tmp10
operator|-
name|tmp13
expr_stmt|;
name|tmp1
operator|=
name|tmp11
operator|+
name|tmp12
expr_stmt|;
name|tmp2
operator|=
name|tmp11
operator|-
name|tmp12
expr_stmt|;
comment|/* Odd part */
name|z13
operator|=
name|wsptr
index|[
literal|5
index|]
operator|+
name|wsptr
index|[
literal|3
index|]
expr_stmt|;
name|z10
operator|=
name|wsptr
index|[
literal|5
index|]
operator|-
name|wsptr
index|[
literal|3
index|]
expr_stmt|;
name|z11
operator|=
name|wsptr
index|[
literal|1
index|]
operator|+
name|wsptr
index|[
literal|7
index|]
expr_stmt|;
name|z12
operator|=
name|wsptr
index|[
literal|1
index|]
operator|-
name|wsptr
index|[
literal|7
index|]
expr_stmt|;
name|tmp7
operator|=
name|z11
operator|+
name|z13
expr_stmt|;
name|tmp11
operator|=
operator|(
name|z11
operator|-
name|z13
operator|)
operator|*
operator|(
operator|(
name|FAST_FLOAT
operator|)
literal|1.414213562
operator|)
expr_stmt|;
name|z5
operator|=
operator|(
name|z10
operator|+
name|z12
operator|)
operator|*
operator|(
operator|(
name|FAST_FLOAT
operator|)
literal|1.847759065
operator|)
expr_stmt|;
comment|/* 2*c2 */
name|tmp10
operator|=
name|z5
operator|-
name|z12
operator|*
operator|(
operator|(
name|FAST_FLOAT
operator|)
literal|1.082392200
operator|)
expr_stmt|;
comment|/* 2*(c2-c6) */
name|tmp12
operator|=
name|z5
operator|-
name|z10
operator|*
operator|(
operator|(
name|FAST_FLOAT
operator|)
literal|2.613125930
operator|)
expr_stmt|;
comment|/* 2*(c2+c6) */
name|tmp6
operator|=
name|tmp12
operator|-
name|tmp7
expr_stmt|;
name|tmp5
operator|=
name|tmp11
operator|-
name|tmp6
expr_stmt|;
name|tmp4
operator|=
name|tmp10
operator|-
name|tmp5
expr_stmt|;
comment|/* Final output stage: float->int conversion and range-limit */
name|outptr
index|[
literal|0
index|]
operator|=
name|range_limit
index|[
operator|(
call|(
name|int
call|)
argument_list|(
name|tmp0
operator|+
name|tmp7
argument_list|)
operator|)
operator|&
name|RANGE_MASK
index|]
expr_stmt|;
name|outptr
index|[
literal|7
index|]
operator|=
name|range_limit
index|[
operator|(
call|(
name|int
call|)
argument_list|(
name|tmp0
operator|-
name|tmp7
argument_list|)
operator|)
operator|&
name|RANGE_MASK
index|]
expr_stmt|;
name|outptr
index|[
literal|1
index|]
operator|=
name|range_limit
index|[
operator|(
call|(
name|int
call|)
argument_list|(
name|tmp1
operator|+
name|tmp6
argument_list|)
operator|)
operator|&
name|RANGE_MASK
index|]
expr_stmt|;
name|outptr
index|[
literal|6
index|]
operator|=
name|range_limit
index|[
operator|(
call|(
name|int
call|)
argument_list|(
name|tmp1
operator|-
name|tmp6
argument_list|)
operator|)
operator|&
name|RANGE_MASK
index|]
expr_stmt|;
name|outptr
index|[
literal|2
index|]
operator|=
name|range_limit
index|[
operator|(
call|(
name|int
call|)
argument_list|(
name|tmp2
operator|+
name|tmp5
argument_list|)
operator|)
operator|&
name|RANGE_MASK
index|]
expr_stmt|;
name|outptr
index|[
literal|5
index|]
operator|=
name|range_limit
index|[
operator|(
call|(
name|int
call|)
argument_list|(
name|tmp2
operator|-
name|tmp5
argument_list|)
operator|)
operator|&
name|RANGE_MASK
index|]
expr_stmt|;
name|outptr
index|[
literal|3
index|]
operator|=
name|range_limit
index|[
operator|(
call|(
name|int
call|)
argument_list|(
name|tmp3
operator|+
name|tmp4
argument_list|)
operator|)
operator|&
name|RANGE_MASK
index|]
expr_stmt|;
name|outptr
index|[
literal|4
index|]
operator|=
name|range_limit
index|[
operator|(
call|(
name|int
call|)
argument_list|(
name|tmp3
operator|-
name|tmp4
argument_list|)
operator|)
operator|&
name|RANGE_MASK
index|]
expr_stmt|;
name|wsptr
operator|+=
name|DCTSIZE
expr_stmt|;
comment|/* advance pointer to next row */
block|}
end_for
begin_endif
unit|}
endif|#
directive|endif
end_endif
begin_comment
comment|/* DCT_FLOAT_SUPPORTED */
end_comment
end_unit
