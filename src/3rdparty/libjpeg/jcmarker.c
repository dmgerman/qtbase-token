begin_unit
begin_comment
comment|/*  * jcmarker.c  *  * Copyright (C) 1991-1998, Thomas G. Lane.  * Modified 2003-2010 by Guido Vollbeding.  * This file is part of the Independent JPEG Group's software.  * For conditions of distribution and use, see the accompanying README file.  *  * This file contains routines to write JPEG datastream markers.  */
end_comment
begin_define
DECL|macro|JPEG_INTERNALS
define|#
directive|define
name|JPEG_INTERNALS
end_define
begin_include
include|#
directive|include
file|"jinclude.h"
end_include
begin_include
include|#
directive|include
file|"jpeglib.h"
end_include
begin_typedef
typedef|typedef
enum|enum
block|{
comment|/* JPEG marker codes */
DECL|enumerator|M_SOF0
name|M_SOF0
init|=
literal|0xc0
block|,
DECL|enumerator|M_SOF1
name|M_SOF1
init|=
literal|0xc1
block|,
DECL|enumerator|M_SOF2
name|M_SOF2
init|=
literal|0xc2
block|,
DECL|enumerator|M_SOF3
name|M_SOF3
init|=
literal|0xc3
block|,
DECL|enumerator|M_SOF5
name|M_SOF5
init|=
literal|0xc5
block|,
DECL|enumerator|M_SOF6
name|M_SOF6
init|=
literal|0xc6
block|,
DECL|enumerator|M_SOF7
name|M_SOF7
init|=
literal|0xc7
block|,
DECL|enumerator|M_JPG
name|M_JPG
init|=
literal|0xc8
block|,
DECL|enumerator|M_SOF9
name|M_SOF9
init|=
literal|0xc9
block|,
DECL|enumerator|M_SOF10
name|M_SOF10
init|=
literal|0xca
block|,
DECL|enumerator|M_SOF11
name|M_SOF11
init|=
literal|0xcb
block|,
DECL|enumerator|M_SOF13
name|M_SOF13
init|=
literal|0xcd
block|,
DECL|enumerator|M_SOF14
name|M_SOF14
init|=
literal|0xce
block|,
DECL|enumerator|M_SOF15
name|M_SOF15
init|=
literal|0xcf
block|,
DECL|enumerator|M_DHT
name|M_DHT
init|=
literal|0xc4
block|,
DECL|enumerator|M_DAC
name|M_DAC
init|=
literal|0xcc
block|,
DECL|enumerator|M_RST0
name|M_RST0
init|=
literal|0xd0
block|,
DECL|enumerator|M_RST1
name|M_RST1
init|=
literal|0xd1
block|,
DECL|enumerator|M_RST2
name|M_RST2
init|=
literal|0xd2
block|,
DECL|enumerator|M_RST3
name|M_RST3
init|=
literal|0xd3
block|,
DECL|enumerator|M_RST4
name|M_RST4
init|=
literal|0xd4
block|,
DECL|enumerator|M_RST5
name|M_RST5
init|=
literal|0xd5
block|,
DECL|enumerator|M_RST6
name|M_RST6
init|=
literal|0xd6
block|,
DECL|enumerator|M_RST7
name|M_RST7
init|=
literal|0xd7
block|,
DECL|enumerator|M_SOI
name|M_SOI
init|=
literal|0xd8
block|,
DECL|enumerator|M_EOI
name|M_EOI
init|=
literal|0xd9
block|,
DECL|enumerator|M_SOS
name|M_SOS
init|=
literal|0xda
block|,
DECL|enumerator|M_DQT
name|M_DQT
init|=
literal|0xdb
block|,
DECL|enumerator|M_DNL
name|M_DNL
init|=
literal|0xdc
block|,
DECL|enumerator|M_DRI
name|M_DRI
init|=
literal|0xdd
block|,
DECL|enumerator|M_DHP
name|M_DHP
init|=
literal|0xde
block|,
DECL|enumerator|M_EXP
name|M_EXP
init|=
literal|0xdf
block|,
DECL|enumerator|M_APP0
name|M_APP0
init|=
literal|0xe0
block|,
DECL|enumerator|M_APP1
name|M_APP1
init|=
literal|0xe1
block|,
DECL|enumerator|M_APP2
name|M_APP2
init|=
literal|0xe2
block|,
DECL|enumerator|M_APP3
name|M_APP3
init|=
literal|0xe3
block|,
DECL|enumerator|M_APP4
name|M_APP4
init|=
literal|0xe4
block|,
DECL|enumerator|M_APP5
name|M_APP5
init|=
literal|0xe5
block|,
DECL|enumerator|M_APP6
name|M_APP6
init|=
literal|0xe6
block|,
DECL|enumerator|M_APP7
name|M_APP7
init|=
literal|0xe7
block|,
DECL|enumerator|M_APP8
name|M_APP8
init|=
literal|0xe8
block|,
DECL|enumerator|M_APP9
name|M_APP9
init|=
literal|0xe9
block|,
DECL|enumerator|M_APP10
name|M_APP10
init|=
literal|0xea
block|,
DECL|enumerator|M_APP11
name|M_APP11
init|=
literal|0xeb
block|,
DECL|enumerator|M_APP12
name|M_APP12
init|=
literal|0xec
block|,
DECL|enumerator|M_APP13
name|M_APP13
init|=
literal|0xed
block|,
DECL|enumerator|M_APP14
name|M_APP14
init|=
literal|0xee
block|,
DECL|enumerator|M_APP15
name|M_APP15
init|=
literal|0xef
block|,
DECL|enumerator|M_JPG0
name|M_JPG0
init|=
literal|0xf0
block|,
DECL|enumerator|M_JPG13
name|M_JPG13
init|=
literal|0xfd
block|,
DECL|enumerator|M_COM
name|M_COM
init|=
literal|0xfe
block|,
DECL|enumerator|M_TEM
name|M_TEM
init|=
literal|0x01
block|,
DECL|enumerator|M_ERROR
name|M_ERROR
init|=
literal|0x100
block|}
DECL|typedef|JPEG_MARKER
name|JPEG_MARKER
typedef|;
end_typedef
begin_comment
comment|/* Private state */
end_comment
begin_typedef
typedef|typedef
struct|struct
block|{
DECL|member|pub
name|struct
name|jpeg_marker_writer
name|pub
decl_stmt|;
comment|/* public fields */
DECL|member|last_restart_interval
name|unsigned
name|int
name|last_restart_interval
decl_stmt|;
comment|/* last DRI value emitted; 0 after SOI */
block|}
DECL|typedef|my_marker_writer
name|my_marker_writer
typedef|;
end_typedef
begin_typedef
DECL|typedef|my_marker_ptr
typedef|typedef
name|my_marker_writer
modifier|*
name|my_marker_ptr
typedef|;
end_typedef
begin_comment
comment|/*  * Basic output routines.  *  * Note that we do not support suspension while writing a marker.  * Therefore, an application using suspension must ensure that there is  * enough buffer space for the initial markers (typ. 600-700 bytes) before  * calling jpeg_start_compress, and enough space to write the trailing EOI  * (a few bytes) before calling jpeg_finish_compress.  Multipass compression  * modes are not supported at all with suspension, so those two are the only  * points where markers will be written.  */
end_comment
begin_macro
name|LOCAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|emit_byte
name|emit_byte
argument_list|(
argument|j_compress_ptr cinfo
argument_list|,
argument|int val
argument_list|)
end_macro
begin_comment
comment|/* Emit a byte */
end_comment
begin_block
block|{
name|struct
name|jpeg_destination_mgr
modifier|*
name|dest
init|=
name|cinfo
operator|->
name|dest
decl_stmt|;
operator|*
operator|(
name|dest
operator|->
name|next_output_byte
operator|)
operator|++
operator|=
operator|(
name|JOCTET
operator|)
name|val
expr_stmt|;
if|if
condition|(
operator|--
name|dest
operator|->
name|free_in_buffer
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
call|(
modifier|*
name|dest
operator|->
name|empty_output_buffer
call|)
argument_list|(
name|cinfo
argument_list|)
condition|)
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_CANT_SUSPEND
argument_list|)
expr_stmt|;
block|}
block|}
end_block
begin_macro
name|LOCAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|emit_marker
name|emit_marker
argument_list|(
argument|j_compress_ptr cinfo
argument_list|,
argument|JPEG_MARKER mark
argument_list|)
end_macro
begin_comment
comment|/* Emit a marker code */
end_comment
begin_block
block|{
name|emit_byte
argument_list|(
name|cinfo
argument_list|,
literal|0xFF
argument_list|)
expr_stmt|;
name|emit_byte
argument_list|(
name|cinfo
argument_list|,
operator|(
name|int
operator|)
name|mark
argument_list|)
expr_stmt|;
block|}
end_block
begin_macro
name|LOCAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|emit_2bytes
name|emit_2bytes
argument_list|(
argument|j_compress_ptr cinfo
argument_list|,
argument|int value
argument_list|)
end_macro
begin_comment
comment|/* Emit a 2-byte integer; these are always MSB first in JPEG files */
end_comment
begin_block
block|{
name|emit_byte
argument_list|(
name|cinfo
argument_list|,
operator|(
name|value
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|emit_byte
argument_list|(
name|cinfo
argument_list|,
name|value
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
block|}
end_block
begin_comment
comment|/*  * Routines to write specific marker types.  */
end_comment
begin_macro
name|LOCAL
argument_list|(
argument|int
argument_list|)
end_macro
begin_macro
DECL|function|emit_dqt
name|emit_dqt
argument_list|(
argument|j_compress_ptr cinfo
argument_list|,
argument|int index
argument_list|)
end_macro
begin_comment
comment|/* Emit a DQT marker */
end_comment
begin_comment
comment|/* Returns the precision used (0 = 8bits, 1 = 16bits) for baseline checking */
end_comment
begin_block
block|{
name|JQUANT_TBL
modifier|*
name|qtbl
init|=
name|cinfo
operator|->
name|quant_tbl_ptrs
index|[
name|index
index|]
decl_stmt|;
name|int
name|prec
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|qtbl
operator|==
name|NULL
condition|)
name|ERREXIT1
argument_list|(
name|cinfo
argument_list|,
name|JERR_NO_QUANT_TABLE
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|prec
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|cinfo
operator|->
name|lim_Se
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|qtbl
operator|->
name|quantval
index|[
name|cinfo
operator|->
name|natural_order
index|[
name|i
index|]
index|]
operator|>
literal|255
condition|)
name|prec
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|qtbl
operator|->
name|sent_table
condition|)
block|{
name|emit_marker
argument_list|(
name|cinfo
argument_list|,
name|M_DQT
argument_list|)
expr_stmt|;
name|emit_2bytes
argument_list|(
name|cinfo
argument_list|,
name|prec
condition|?
name|cinfo
operator|->
name|lim_Se
operator|*
literal|2
operator|+
literal|2
operator|+
literal|1
operator|+
literal|2
else|:
name|cinfo
operator|->
name|lim_Se
operator|+
literal|1
operator|+
literal|1
operator|+
literal|2
argument_list|)
expr_stmt|;
name|emit_byte
argument_list|(
name|cinfo
argument_list|,
name|index
operator|+
operator|(
name|prec
operator|<<
literal|4
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|cinfo
operator|->
name|lim_Se
condition|;
name|i
operator|++
control|)
block|{
comment|/* The table entries must be emitted in zigzag order. */
name|unsigned
name|int
name|qval
init|=
name|qtbl
operator|->
name|quantval
index|[
name|cinfo
operator|->
name|natural_order
index|[
name|i
index|]
index|]
decl_stmt|;
if|if
condition|(
name|prec
condition|)
name|emit_byte
argument_list|(
name|cinfo
argument_list|,
call|(
name|int
call|)
argument_list|(
name|qval
operator|>>
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|emit_byte
argument_list|(
name|cinfo
argument_list|,
call|(
name|int
call|)
argument_list|(
name|qval
operator|&
literal|0xFF
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|qtbl
operator|->
name|sent_table
operator|=
name|TRUE
expr_stmt|;
block|}
return|return
name|prec
return|;
block|}
end_block
begin_macro
name|LOCAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|emit_dht
name|emit_dht
argument_list|(
argument|j_compress_ptr cinfo
argument_list|,
argument|int index
argument_list|,
argument|boolean is_ac
argument_list|)
end_macro
begin_comment
comment|/* Emit a DHT marker */
end_comment
begin_block
block|{
name|JHUFF_TBL
modifier|*
name|htbl
decl_stmt|;
name|int
name|length
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|is_ac
condition|)
block|{
name|htbl
operator|=
name|cinfo
operator|->
name|ac_huff_tbl_ptrs
index|[
name|index
index|]
expr_stmt|;
name|index
operator|+=
literal|0x10
expr_stmt|;
comment|/* output index has AC bit set */
block|}
else|else
block|{
name|htbl
operator|=
name|cinfo
operator|->
name|dc_huff_tbl_ptrs
index|[
name|index
index|]
expr_stmt|;
block|}
if|if
condition|(
name|htbl
operator|==
name|NULL
condition|)
name|ERREXIT1
argument_list|(
name|cinfo
argument_list|,
name|JERR_NO_HUFF_TABLE
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|htbl
operator|->
name|sent_table
condition|)
block|{
name|emit_marker
argument_list|(
name|cinfo
argument_list|,
name|M_DHT
argument_list|)
expr_stmt|;
name|length
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
literal|16
condition|;
name|i
operator|++
control|)
name|length
operator|+=
name|htbl
operator|->
name|bits
index|[
name|i
index|]
expr_stmt|;
name|emit_2bytes
argument_list|(
name|cinfo
argument_list|,
name|length
operator|+
literal|2
operator|+
literal|1
operator|+
literal|16
argument_list|)
expr_stmt|;
name|emit_byte
argument_list|(
name|cinfo
argument_list|,
name|index
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
literal|16
condition|;
name|i
operator|++
control|)
name|emit_byte
argument_list|(
name|cinfo
argument_list|,
name|htbl
operator|->
name|bits
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
name|emit_byte
argument_list|(
name|cinfo
argument_list|,
name|htbl
operator|->
name|huffval
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|htbl
operator|->
name|sent_table
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
end_block
begin_macro
name|LOCAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|emit_dac
name|emit_dac
argument_list|(
argument|j_compress_ptr cinfo
argument_list|)
end_macro
begin_comment
comment|/* Emit a DAC marker */
end_comment
begin_comment
comment|/* Since the useful info is so small, we want to emit all the tables in */
end_comment
begin_comment
comment|/* one DAC marker.  Therefore this routine does its own scan of the table. */
end_comment
begin_block
block|{
ifdef|#
directive|ifdef
name|C_ARITH_CODING_SUPPORTED
name|char
name|dc_in_use
index|[
name|NUM_ARITH_TBLS
index|]
decl_stmt|;
name|char
name|ac_in_use
index|[
name|NUM_ARITH_TBLS
index|]
decl_stmt|;
name|int
name|length
decl_stmt|,
name|i
decl_stmt|;
name|jpeg_component_info
modifier|*
name|compptr
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_ARITH_TBLS
condition|;
name|i
operator|++
control|)
name|dc_in_use
index|[
name|i
index|]
operator|=
name|ac_in_use
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cinfo
operator|->
name|comps_in_scan
condition|;
name|i
operator|++
control|)
block|{
name|compptr
operator|=
name|cinfo
operator|->
name|cur_comp_info
index|[
name|i
index|]
expr_stmt|;
comment|/* DC needs no table for refinement scan */
if|if
condition|(
name|cinfo
operator|->
name|Ss
operator|==
literal|0
operator|&&
name|cinfo
operator|->
name|Ah
operator|==
literal|0
condition|)
name|dc_in_use
index|[
name|compptr
operator|->
name|dc_tbl_no
index|]
operator|=
literal|1
expr_stmt|;
comment|/* AC needs no table when not present */
if|if
condition|(
name|cinfo
operator|->
name|Se
condition|)
name|ac_in_use
index|[
name|compptr
operator|->
name|ac_tbl_no
index|]
operator|=
literal|1
expr_stmt|;
block|}
name|length
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_ARITH_TBLS
condition|;
name|i
operator|++
control|)
name|length
operator|+=
name|dc_in_use
index|[
name|i
index|]
operator|+
name|ac_in_use
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|length
condition|)
block|{
name|emit_marker
argument_list|(
name|cinfo
argument_list|,
name|M_DAC
argument_list|)
expr_stmt|;
name|emit_2bytes
argument_list|(
name|cinfo
argument_list|,
name|length
operator|*
literal|2
operator|+
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_ARITH_TBLS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dc_in_use
index|[
name|i
index|]
condition|)
block|{
name|emit_byte
argument_list|(
name|cinfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|emit_byte
argument_list|(
name|cinfo
argument_list|,
name|cinfo
operator|->
name|arith_dc_L
index|[
name|i
index|]
operator|+
operator|(
name|cinfo
operator|->
name|arith_dc_U
index|[
name|i
index|]
operator|<<
literal|4
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ac_in_use
index|[
name|i
index|]
condition|)
block|{
name|emit_byte
argument_list|(
name|cinfo
argument_list|,
name|i
operator|+
literal|0x10
argument_list|)
expr_stmt|;
name|emit_byte
argument_list|(
name|cinfo
argument_list|,
name|cinfo
operator|->
name|arith_ac_K
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* C_ARITH_CODING_SUPPORTED */
block|}
end_block
begin_macro
name|LOCAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|emit_dri
name|emit_dri
argument_list|(
argument|j_compress_ptr cinfo
argument_list|)
end_macro
begin_comment
comment|/* Emit a DRI marker */
end_comment
begin_block
block|{
name|emit_marker
argument_list|(
name|cinfo
argument_list|,
name|M_DRI
argument_list|)
expr_stmt|;
name|emit_2bytes
argument_list|(
name|cinfo
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* fixed length */
name|emit_2bytes
argument_list|(
name|cinfo
argument_list|,
operator|(
name|int
operator|)
name|cinfo
operator|->
name|restart_interval
argument_list|)
expr_stmt|;
block|}
end_block
begin_macro
name|LOCAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|emit_sof
name|emit_sof
argument_list|(
argument|j_compress_ptr cinfo
argument_list|,
argument|JPEG_MARKER code
argument_list|)
end_macro
begin_comment
comment|/* Emit a SOF marker */
end_comment
begin_block
block|{
name|int
name|ci
decl_stmt|;
name|jpeg_component_info
modifier|*
name|compptr
decl_stmt|;
name|emit_marker
argument_list|(
name|cinfo
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|emit_2bytes
argument_list|(
name|cinfo
argument_list|,
literal|3
operator|*
name|cinfo
operator|->
name|num_components
operator|+
literal|2
operator|+
literal|5
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* length */
comment|/* Make sure image isn't bigger than SOF field can handle */
if|if
condition|(
operator|(
name|long
operator|)
name|cinfo
operator|->
name|jpeg_height
operator|>
literal|65535L
operator|||
operator|(
name|long
operator|)
name|cinfo
operator|->
name|jpeg_width
operator|>
literal|65535L
condition|)
name|ERREXIT1
argument_list|(
name|cinfo
argument_list|,
name|JERR_IMAGE_TOO_BIG
argument_list|,
operator|(
name|unsigned
name|int
operator|)
literal|65535
argument_list|)
expr_stmt|;
name|emit_byte
argument_list|(
name|cinfo
argument_list|,
name|cinfo
operator|->
name|data_precision
argument_list|)
expr_stmt|;
name|emit_2bytes
argument_list|(
name|cinfo
argument_list|,
operator|(
name|int
operator|)
name|cinfo
operator|->
name|jpeg_height
argument_list|)
expr_stmt|;
name|emit_2bytes
argument_list|(
name|cinfo
argument_list|,
operator|(
name|int
operator|)
name|cinfo
operator|->
name|jpeg_width
argument_list|)
expr_stmt|;
name|emit_byte
argument_list|(
name|cinfo
argument_list|,
name|cinfo
operator|->
name|num_components
argument_list|)
expr_stmt|;
for|for
control|(
name|ci
operator|=
literal|0
operator|,
name|compptr
operator|=
name|cinfo
operator|->
name|comp_info
init|;
name|ci
operator|<
name|cinfo
operator|->
name|num_components
condition|;
name|ci
operator|++
operator|,
name|compptr
operator|++
control|)
block|{
name|emit_byte
argument_list|(
name|cinfo
argument_list|,
name|compptr
operator|->
name|component_id
argument_list|)
expr_stmt|;
name|emit_byte
argument_list|(
name|cinfo
argument_list|,
operator|(
name|compptr
operator|->
name|h_samp_factor
operator|<<
literal|4
operator|)
operator|+
name|compptr
operator|->
name|v_samp_factor
argument_list|)
expr_stmt|;
name|emit_byte
argument_list|(
name|cinfo
argument_list|,
name|compptr
operator|->
name|quant_tbl_no
argument_list|)
expr_stmt|;
block|}
block|}
end_block
begin_macro
name|LOCAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|emit_sos
name|emit_sos
argument_list|(
argument|j_compress_ptr cinfo
argument_list|)
end_macro
begin_comment
comment|/* Emit a SOS marker */
end_comment
begin_block
block|{
name|int
name|i
decl_stmt|,
name|td
decl_stmt|,
name|ta
decl_stmt|;
name|jpeg_component_info
modifier|*
name|compptr
decl_stmt|;
name|emit_marker
argument_list|(
name|cinfo
argument_list|,
name|M_SOS
argument_list|)
expr_stmt|;
name|emit_2bytes
argument_list|(
name|cinfo
argument_list|,
literal|2
operator|*
name|cinfo
operator|->
name|comps_in_scan
operator|+
literal|2
operator|+
literal|1
operator|+
literal|3
argument_list|)
expr_stmt|;
comment|/* length */
name|emit_byte
argument_list|(
name|cinfo
argument_list|,
name|cinfo
operator|->
name|comps_in_scan
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cinfo
operator|->
name|comps_in_scan
condition|;
name|i
operator|++
control|)
block|{
name|compptr
operator|=
name|cinfo
operator|->
name|cur_comp_info
index|[
name|i
index|]
expr_stmt|;
name|emit_byte
argument_list|(
name|cinfo
argument_list|,
name|compptr
operator|->
name|component_id
argument_list|)
expr_stmt|;
comment|/* We emit 0 for unused field(s); this is recommended by the P&M text      * but does not seem to be specified in the standard.      */
comment|/* DC needs no table for refinement scan */
name|td
operator|=
name|cinfo
operator|->
name|Ss
operator|==
literal|0
operator|&&
name|cinfo
operator|->
name|Ah
operator|==
literal|0
condition|?
name|compptr
operator|->
name|dc_tbl_no
else|:
literal|0
expr_stmt|;
comment|/* AC needs no table when not present */
name|ta
operator|=
name|cinfo
operator|->
name|Se
condition|?
name|compptr
operator|->
name|ac_tbl_no
else|:
literal|0
expr_stmt|;
name|emit_byte
argument_list|(
name|cinfo
argument_list|,
operator|(
name|td
operator|<<
literal|4
operator|)
operator|+
name|ta
argument_list|)
expr_stmt|;
block|}
name|emit_byte
argument_list|(
name|cinfo
argument_list|,
name|cinfo
operator|->
name|Ss
argument_list|)
expr_stmt|;
name|emit_byte
argument_list|(
name|cinfo
argument_list|,
name|cinfo
operator|->
name|Se
argument_list|)
expr_stmt|;
name|emit_byte
argument_list|(
name|cinfo
argument_list|,
operator|(
name|cinfo
operator|->
name|Ah
operator|<<
literal|4
operator|)
operator|+
name|cinfo
operator|->
name|Al
argument_list|)
expr_stmt|;
block|}
end_block
begin_macro
name|LOCAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|emit_pseudo_sos
name|emit_pseudo_sos
argument_list|(
argument|j_compress_ptr cinfo
argument_list|)
end_macro
begin_comment
comment|/* Emit a pseudo SOS marker */
end_comment
begin_block
block|{
name|emit_marker
argument_list|(
name|cinfo
argument_list|,
name|M_SOS
argument_list|)
expr_stmt|;
name|emit_2bytes
argument_list|(
name|cinfo
argument_list|,
literal|2
operator|+
literal|1
operator|+
literal|3
argument_list|)
expr_stmt|;
comment|/* length */
name|emit_byte
argument_list|(
name|cinfo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Ns */
name|emit_byte
argument_list|(
name|cinfo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Ss */
name|emit_byte
argument_list|(
name|cinfo
argument_list|,
name|cinfo
operator|->
name|block_size
operator|*
name|cinfo
operator|->
name|block_size
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Se */
name|emit_byte
argument_list|(
name|cinfo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Ah/Al */
block|}
end_block
begin_macro
name|LOCAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|emit_jfif_app0
name|emit_jfif_app0
argument_list|(
argument|j_compress_ptr cinfo
argument_list|)
end_macro
begin_comment
comment|/* Emit a JFIF-compliant APP0 marker */
end_comment
begin_block
block|{
comment|/*    * Length of APP0 block	(2 bytes)    * Block ID			(4 bytes - ASCII "JFIF")    * Zero byte			(1 byte to terminate the ID string)    * Version Major, Minor	(2 bytes - major first)    * Units			(1 byte - 0x00 = none, 0x01 = inch, 0x02 = cm)    * Xdpu			(2 bytes - dots per unit horizontal)    * Ydpu			(2 bytes - dots per unit vertical)    * Thumbnail X size		(1 byte)    * Thumbnail Y size		(1 byte)    */
name|emit_marker
argument_list|(
name|cinfo
argument_list|,
name|M_APP0
argument_list|)
expr_stmt|;
name|emit_2bytes
argument_list|(
name|cinfo
argument_list|,
literal|2
operator|+
literal|4
operator|+
literal|1
operator|+
literal|2
operator|+
literal|1
operator|+
literal|2
operator|+
literal|2
operator|+
literal|1
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* length */
name|emit_byte
argument_list|(
name|cinfo
argument_list|,
literal|0x4A
argument_list|)
expr_stmt|;
comment|/* Identifier: ASCII "JFIF" */
name|emit_byte
argument_list|(
name|cinfo
argument_list|,
literal|0x46
argument_list|)
expr_stmt|;
name|emit_byte
argument_list|(
name|cinfo
argument_list|,
literal|0x49
argument_list|)
expr_stmt|;
name|emit_byte
argument_list|(
name|cinfo
argument_list|,
literal|0x46
argument_list|)
expr_stmt|;
name|emit_byte
argument_list|(
name|cinfo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_byte
argument_list|(
name|cinfo
argument_list|,
name|cinfo
operator|->
name|JFIF_major_version
argument_list|)
expr_stmt|;
comment|/* Version fields */
name|emit_byte
argument_list|(
name|cinfo
argument_list|,
name|cinfo
operator|->
name|JFIF_minor_version
argument_list|)
expr_stmt|;
name|emit_byte
argument_list|(
name|cinfo
argument_list|,
name|cinfo
operator|->
name|density_unit
argument_list|)
expr_stmt|;
comment|/* Pixel size information */
name|emit_2bytes
argument_list|(
name|cinfo
argument_list|,
operator|(
name|int
operator|)
name|cinfo
operator|->
name|X_density
argument_list|)
expr_stmt|;
name|emit_2bytes
argument_list|(
name|cinfo
argument_list|,
operator|(
name|int
operator|)
name|cinfo
operator|->
name|Y_density
argument_list|)
expr_stmt|;
name|emit_byte
argument_list|(
name|cinfo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* No thumbnail image */
name|emit_byte
argument_list|(
name|cinfo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block
begin_macro
name|LOCAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|emit_adobe_app14
name|emit_adobe_app14
argument_list|(
argument|j_compress_ptr cinfo
argument_list|)
end_macro
begin_comment
comment|/* Emit an Adobe APP14 marker */
end_comment
begin_block
block|{
comment|/*    * Length of APP14 block	(2 bytes)    * Block ID			(5 bytes - ASCII "Adobe")    * Version Number		(2 bytes - currently 100)    * Flags0			(2 bytes - currently 0)    * Flags1			(2 bytes - currently 0)    * Color transform		(1 byte)    *    * Although Adobe TN 5116 mentions Version = 101, all the Adobe files    * now in circulation seem to use Version = 100, so that's what we write.    *    * We write the color transform byte as 1 if the JPEG color space is    * YCbCr, 2 if it's YCCK, 0 otherwise.  Adobe's definition has to do with    * whether the encoder performed a transformation, which is pretty useless.    */
name|emit_marker
argument_list|(
name|cinfo
argument_list|,
name|M_APP14
argument_list|)
expr_stmt|;
name|emit_2bytes
argument_list|(
name|cinfo
argument_list|,
literal|2
operator|+
literal|5
operator|+
literal|2
operator|+
literal|2
operator|+
literal|2
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* length */
name|emit_byte
argument_list|(
name|cinfo
argument_list|,
literal|0x41
argument_list|)
expr_stmt|;
comment|/* Identifier: ASCII "Adobe" */
name|emit_byte
argument_list|(
name|cinfo
argument_list|,
literal|0x64
argument_list|)
expr_stmt|;
name|emit_byte
argument_list|(
name|cinfo
argument_list|,
literal|0x6F
argument_list|)
expr_stmt|;
name|emit_byte
argument_list|(
name|cinfo
argument_list|,
literal|0x62
argument_list|)
expr_stmt|;
name|emit_byte
argument_list|(
name|cinfo
argument_list|,
literal|0x65
argument_list|)
expr_stmt|;
name|emit_2bytes
argument_list|(
name|cinfo
argument_list|,
literal|100
argument_list|)
expr_stmt|;
comment|/* Version */
name|emit_2bytes
argument_list|(
name|cinfo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Flags0 */
name|emit_2bytes
argument_list|(
name|cinfo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Flags1 */
switch|switch
condition|(
name|cinfo
operator|->
name|jpeg_color_space
condition|)
block|{
case|case
name|JCS_YCbCr
case|:
name|emit_byte
argument_list|(
name|cinfo
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Color transform = 1 */
break|break;
case|case
name|JCS_YCCK
case|:
name|emit_byte
argument_list|(
name|cinfo
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Color transform = 2 */
break|break;
default|default:
name|emit_byte
argument_list|(
name|cinfo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Color transform = 0 */
break|break;
block|}
block|}
end_block
begin_comment
comment|/*  * These routines allow writing an arbitrary marker with parameters.  * The only intended use is to emit COM or APPn markers after calling  * write_file_header and before calling write_frame_header.  * Other uses are not guaranteed to produce desirable results.  * Counting the parameter bytes properly is the caller's responsibility.  */
end_comment
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|write_marker_header
name|write_marker_header
argument_list|(
argument|j_compress_ptr cinfo
argument_list|,
argument|int marker
argument_list|,
argument|unsigned int datalen
argument_list|)
end_macro
begin_comment
comment|/* Emit an arbitrary marker header */
end_comment
begin_block
block|{
if|if
condition|(
name|datalen
operator|>
operator|(
name|unsigned
name|int
operator|)
literal|65533
condition|)
comment|/* safety check */
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_LENGTH
argument_list|)
expr_stmt|;
name|emit_marker
argument_list|(
name|cinfo
argument_list|,
operator|(
name|JPEG_MARKER
operator|)
name|marker
argument_list|)
expr_stmt|;
name|emit_2bytes
argument_list|(
name|cinfo
argument_list|,
call|(
name|int
call|)
argument_list|(
name|datalen
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
comment|/* total length */
block|}
end_block
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|write_marker_byte
name|write_marker_byte
argument_list|(
argument|j_compress_ptr cinfo
argument_list|,
argument|int val
argument_list|)
end_macro
begin_comment
comment|/* Emit one byte of marker parameters following write_marker_header */
end_comment
begin_block
block|{
name|emit_byte
argument_list|(
name|cinfo
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_block
begin_comment
comment|/*  * Write datastream header.  * This consists of an SOI and optional APPn markers.  * We recommend use of the JFIF marker, but not the Adobe marker,  * when using YCbCr or grayscale data.  The JFIF marker should NOT  * be used for any other JPEG colorspace.  The Adobe marker is helpful  * to distinguish RGB, CMYK, and YCCK colorspaces.  * Note that an application can write additional header markers after  * jpeg_start_compress returns.  */
end_comment
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|write_file_header
name|write_file_header
argument_list|(
argument|j_compress_ptr cinfo
argument_list|)
end_macro
begin_block
block|{
name|my_marker_ptr
name|marker
init|=
operator|(
name|my_marker_ptr
operator|)
name|cinfo
operator|->
name|marker
decl_stmt|;
name|emit_marker
argument_list|(
name|cinfo
argument_list|,
name|M_SOI
argument_list|)
expr_stmt|;
comment|/* first the SOI */
comment|/* SOI is defined to reset restart interval to 0 */
name|marker
operator|->
name|last_restart_interval
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cinfo
operator|->
name|write_JFIF_header
condition|)
comment|/* next an optional JFIF APP0 */
name|emit_jfif_app0
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|cinfo
operator|->
name|write_Adobe_marker
condition|)
comment|/* next an optional Adobe APP14 */
name|emit_adobe_app14
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
block|}
end_block
begin_comment
comment|/*  * Write frame header.  * This consists of DQT and SOFn markers, and a conditional pseudo SOS marker.  * Note that we do not emit the SOF until we have emitted the DQT(s).  * This avoids compatibility problems with incorrect implementations that  * try to error-check the quant table numbers as soon as they see the SOF.  */
end_comment
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|write_frame_header
name|write_frame_header
argument_list|(
argument|j_compress_ptr cinfo
argument_list|)
end_macro
begin_block
block|{
name|int
name|ci
decl_stmt|,
name|prec
decl_stmt|;
name|boolean
name|is_baseline
decl_stmt|;
name|jpeg_component_info
modifier|*
name|compptr
decl_stmt|;
comment|/* Emit DQT for each quantization table.    * Note that emit_dqt() suppresses any duplicate tables.    */
name|prec
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ci
operator|=
literal|0
operator|,
name|compptr
operator|=
name|cinfo
operator|->
name|comp_info
init|;
name|ci
operator|<
name|cinfo
operator|->
name|num_components
condition|;
name|ci
operator|++
operator|,
name|compptr
operator|++
control|)
block|{
name|prec
operator|+=
name|emit_dqt
argument_list|(
name|cinfo
argument_list|,
name|compptr
operator|->
name|quant_tbl_no
argument_list|)
expr_stmt|;
block|}
comment|/* now prec is nonzero iff there are any 16-bit quant tables. */
comment|/* Check for a non-baseline specification.    * Note we assume that Huffman table numbers won't be changed later.    */
if|if
condition|(
name|cinfo
operator|->
name|arith_code
operator|||
name|cinfo
operator|->
name|progressive_mode
operator|||
name|cinfo
operator|->
name|data_precision
operator|!=
literal|8
operator|||
name|cinfo
operator|->
name|block_size
operator|!=
name|DCTSIZE
condition|)
block|{
name|is_baseline
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|is_baseline
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
name|ci
operator|=
literal|0
operator|,
name|compptr
operator|=
name|cinfo
operator|->
name|comp_info
init|;
name|ci
operator|<
name|cinfo
operator|->
name|num_components
condition|;
name|ci
operator|++
operator|,
name|compptr
operator|++
control|)
block|{
if|if
condition|(
name|compptr
operator|->
name|dc_tbl_no
operator|>
literal|1
operator|||
name|compptr
operator|->
name|ac_tbl_no
operator|>
literal|1
condition|)
name|is_baseline
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|prec
operator|&&
name|is_baseline
condition|)
block|{
name|is_baseline
operator|=
name|FALSE
expr_stmt|;
comment|/* If it's baseline except for quantizer size, warn the user */
name|TRACEMS
argument_list|(
name|cinfo
argument_list|,
literal|0
argument_list|,
name|JTRC_16BIT_TABLES
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Emit the proper SOF marker */
if|if
condition|(
name|cinfo
operator|->
name|arith_code
condition|)
block|{
if|if
condition|(
name|cinfo
operator|->
name|progressive_mode
condition|)
name|emit_sof
argument_list|(
name|cinfo
argument_list|,
name|M_SOF10
argument_list|)
expr_stmt|;
comment|/* SOF code for progressive arithmetic */
else|else
name|emit_sof
argument_list|(
name|cinfo
argument_list|,
name|M_SOF9
argument_list|)
expr_stmt|;
comment|/* SOF code for sequential arithmetic */
block|}
else|else
block|{
if|if
condition|(
name|cinfo
operator|->
name|progressive_mode
condition|)
name|emit_sof
argument_list|(
name|cinfo
argument_list|,
name|M_SOF2
argument_list|)
expr_stmt|;
comment|/* SOF code for progressive Huffman */
elseif|else
if|if
condition|(
name|is_baseline
condition|)
name|emit_sof
argument_list|(
name|cinfo
argument_list|,
name|M_SOF0
argument_list|)
expr_stmt|;
comment|/* SOF code for baseline implementation */
else|else
name|emit_sof
argument_list|(
name|cinfo
argument_list|,
name|M_SOF1
argument_list|)
expr_stmt|;
comment|/* SOF code for non-baseline Huffman file */
block|}
comment|/* Check to emit pseudo SOS marker */
if|if
condition|(
name|cinfo
operator|->
name|progressive_mode
operator|&&
name|cinfo
operator|->
name|block_size
operator|!=
name|DCTSIZE
condition|)
name|emit_pseudo_sos
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
block|}
end_block
begin_comment
comment|/*  * Write scan header.  * This consists of DHT or DAC markers, optional DRI, and SOS.  * Compressed data will be written following the SOS.  */
end_comment
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|write_scan_header
name|write_scan_header
argument_list|(
argument|j_compress_ptr cinfo
argument_list|)
end_macro
begin_block
block|{
name|my_marker_ptr
name|marker
init|=
operator|(
name|my_marker_ptr
operator|)
name|cinfo
operator|->
name|marker
decl_stmt|;
name|int
name|i
decl_stmt|;
name|jpeg_component_info
modifier|*
name|compptr
decl_stmt|;
if|if
condition|(
name|cinfo
operator|->
name|arith_code
condition|)
block|{
comment|/* Emit arith conditioning info.  We may have some duplication      * if the file has multiple scans, but it's so small it's hardly      * worth worrying about.      */
name|emit_dac
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Emit Huffman tables.      * Note that emit_dht() suppresses any duplicate tables.      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cinfo
operator|->
name|comps_in_scan
condition|;
name|i
operator|++
control|)
block|{
name|compptr
operator|=
name|cinfo
operator|->
name|cur_comp_info
index|[
name|i
index|]
expr_stmt|;
comment|/* DC needs no table for refinement scan */
if|if
condition|(
name|cinfo
operator|->
name|Ss
operator|==
literal|0
operator|&&
name|cinfo
operator|->
name|Ah
operator|==
literal|0
condition|)
name|emit_dht
argument_list|(
name|cinfo
argument_list|,
name|compptr
operator|->
name|dc_tbl_no
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* AC needs no table when not present */
if|if
condition|(
name|cinfo
operator|->
name|Se
condition|)
name|emit_dht
argument_list|(
name|cinfo
argument_list|,
name|compptr
operator|->
name|ac_tbl_no
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Emit DRI if required --- note that DRI value could change for each scan.    * We avoid wasting space with unnecessary DRIs, however.    */
if|if
condition|(
name|cinfo
operator|->
name|restart_interval
operator|!=
name|marker
operator|->
name|last_restart_interval
condition|)
block|{
name|emit_dri
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
name|marker
operator|->
name|last_restart_interval
operator|=
name|cinfo
operator|->
name|restart_interval
expr_stmt|;
block|}
name|emit_sos
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
block|}
end_block
begin_comment
comment|/*  * Write datastream trailer.  */
end_comment
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|write_file_trailer
name|write_file_trailer
argument_list|(
argument|j_compress_ptr cinfo
argument_list|)
end_macro
begin_block
block|{
name|emit_marker
argument_list|(
name|cinfo
argument_list|,
name|M_EOI
argument_list|)
expr_stmt|;
block|}
end_block
begin_comment
comment|/*  * Write an abbreviated table-specification datastream.  * This consists of SOI, DQT and DHT tables, and EOI.  * Any table that is defined and not marked sent_table = TRUE will be  * emitted.  Note that all tables will be marked sent_table = TRUE at exit.  */
end_comment
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|write_tables_only
name|write_tables_only
argument_list|(
argument|j_compress_ptr cinfo
argument_list|)
end_macro
begin_block
block|{
name|int
name|i
decl_stmt|;
name|emit_marker
argument_list|(
name|cinfo
argument_list|,
name|M_SOI
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_QUANT_TBLS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cinfo
operator|->
name|quant_tbl_ptrs
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|emit_dqt
argument_list|(
name|cinfo
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|cinfo
operator|->
name|arith_code
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_HUFF_TBLS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cinfo
operator|->
name|dc_huff_tbl_ptrs
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|emit_dht
argument_list|(
name|cinfo
argument_list|,
name|i
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|cinfo
operator|->
name|ac_huff_tbl_ptrs
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|emit_dht
argument_list|(
name|cinfo
argument_list|,
name|i
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
name|emit_marker
argument_list|(
name|cinfo
argument_list|,
name|M_EOI
argument_list|)
expr_stmt|;
block|}
end_block
begin_comment
comment|/*  * Initialize the marker writer module.  */
end_comment
begin_macro
name|GLOBAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|jinit_marker_writer
name|jinit_marker_writer
argument_list|(
argument|j_compress_ptr cinfo
argument_list|)
end_macro
begin_block
block|{
name|my_marker_ptr
name|marker
decl_stmt|;
comment|/* Create the subobject */
name|marker
operator|=
call|(
name|my_marker_ptr
call|)
argument_list|(
operator|*
name|cinfo
operator|->
name|mem
operator|->
name|alloc_small
argument_list|)
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|,
name|JPOOL_IMAGE
argument_list|,
name|SIZEOF
argument_list|(
name|my_marker_writer
argument_list|)
argument_list|)
expr_stmt|;
name|cinfo
operator|->
name|marker
operator|=
operator|(
expr|struct
name|jpeg_marker_writer
operator|*
operator|)
name|marker
expr_stmt|;
comment|/* Initialize method pointers */
name|marker
operator|->
name|pub
operator|.
name|write_file_header
operator|=
name|write_file_header
expr_stmt|;
name|marker
operator|->
name|pub
operator|.
name|write_frame_header
operator|=
name|write_frame_header
expr_stmt|;
name|marker
operator|->
name|pub
operator|.
name|write_scan_header
operator|=
name|write_scan_header
expr_stmt|;
name|marker
operator|->
name|pub
operator|.
name|write_file_trailer
operator|=
name|write_file_trailer
expr_stmt|;
name|marker
operator|->
name|pub
operator|.
name|write_tables_only
operator|=
name|write_tables_only
expr_stmt|;
name|marker
operator|->
name|pub
operator|.
name|write_marker_header
operator|=
name|write_marker_header
expr_stmt|;
name|marker
operator|->
name|pub
operator|.
name|write_marker_byte
operator|=
name|write_marker_byte
expr_stmt|;
comment|/* Initialize private state */
name|marker
operator|->
name|last_restart_interval
operator|=
literal|0
expr_stmt|;
block|}
end_block
end_unit
