begin_unit
begin_comment
comment|/*  * jcparam.c  *  * Copyright (C) 1991-1998, Thomas G. Lane.  * Modified 2003-2008 by Guido Vollbeding.  * This file is part of the Independent JPEG Group's software.  * For conditions of distribution and use, see the accompanying README file.  *  * This file contains optional default-setting code for the JPEG compressor.  * Applications do not have to use this file, but those that don't use it  * must know a lot more about the innards of the JPEG code.  */
end_comment
begin_define
DECL|macro|JPEG_INTERNALS
define|#
directive|define
name|JPEG_INTERNALS
end_define
begin_include
include|#
directive|include
file|"jinclude.h"
end_include
begin_include
include|#
directive|include
file|"jpeglib.h"
end_include
begin_comment
comment|/*  * Quantization table setup routines  */
end_comment
begin_macro
name|GLOBAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|jpeg_add_quant_table
name|jpeg_add_quant_table
argument_list|(
argument|j_compress_ptr cinfo
argument_list|,
argument|int which_tbl
argument_list|,
argument|const unsigned int *basic_table
argument_list|,
argument|int scale_factor
argument_list|,
argument|boolean force_baseline
argument_list|)
end_macro
begin_comment
comment|/* Define a quantization table equal to the basic_table times  * a scale factor (given as a percentage).  * If force_baseline is TRUE, the computed quantization table entries  * are limited to 1..255 for JPEG baseline compatibility.  */
end_comment
begin_block
block|{
name|JQUANT_TBL
modifier|*
modifier|*
name|qtblptr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|long
name|temp
decl_stmt|;
comment|/* Safety check to ensure start_compress not called yet. */
if|if
condition|(
name|cinfo
operator|->
name|global_state
operator|!=
name|CSTATE_START
condition|)
name|ERREXIT1
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_STATE
argument_list|,
name|cinfo
operator|->
name|global_state
argument_list|)
expr_stmt|;
if|if
condition|(
name|which_tbl
operator|<
literal|0
operator|||
name|which_tbl
operator|>=
name|NUM_QUANT_TBLS
condition|)
name|ERREXIT1
argument_list|(
name|cinfo
argument_list|,
name|JERR_DQT_INDEX
argument_list|,
name|which_tbl
argument_list|)
expr_stmt|;
name|qtblptr
operator|=
operator|&
name|cinfo
operator|->
name|quant_tbl_ptrs
index|[
name|which_tbl
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|qtblptr
operator|==
name|NULL
condition|)
operator|*
name|qtblptr
operator|=
name|jpeg_alloc_quant_table
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DCTSIZE2
condition|;
name|i
operator|++
control|)
block|{
name|temp
operator|=
operator|(
operator|(
name|long
operator|)
name|basic_table
index|[
name|i
index|]
operator|*
name|scale_factor
operator|+
literal|50L
operator|)
operator|/
literal|100L
expr_stmt|;
comment|/* limit the values to the valid range */
if|if
condition|(
name|temp
operator|<=
literal|0L
condition|)
name|temp
operator|=
literal|1L
expr_stmt|;
if|if
condition|(
name|temp
operator|>
literal|32767L
condition|)
name|temp
operator|=
literal|32767L
expr_stmt|;
comment|/* max quantizer needed for 12 bits */
if|if
condition|(
name|force_baseline
operator|&&
name|temp
operator|>
literal|255L
condition|)
name|temp
operator|=
literal|255L
expr_stmt|;
comment|/* limit to baseline range if requested */
operator|(
operator|*
name|qtblptr
operator|)
operator|->
name|quantval
index|[
name|i
index|]
operator|=
operator|(
name|UINT16
operator|)
name|temp
expr_stmt|;
block|}
comment|/* Initialize sent_table FALSE so table will be written to JPEG file. */
operator|(
operator|*
name|qtblptr
operator|)
operator|->
name|sent_table
operator|=
name|FALSE
expr_stmt|;
block|}
end_block
begin_comment
comment|/* These are the sample quantization tables given in JPEG spec section K.1.  * The spec says that the values given produce "good" quality, and  * when divided by 2, "very good" quality.  */
end_comment
begin_decl_stmt
DECL|variable|std_luminance_quant_tbl
specifier|static
specifier|const
name|unsigned
name|int
name|std_luminance_quant_tbl
index|[
name|DCTSIZE2
index|]
init|=
block|{
literal|16
block|,
literal|11
block|,
literal|10
block|,
literal|16
block|,
literal|24
block|,
literal|40
block|,
literal|51
block|,
literal|61
block|,
literal|12
block|,
literal|12
block|,
literal|14
block|,
literal|19
block|,
literal|26
block|,
literal|58
block|,
literal|60
block|,
literal|55
block|,
literal|14
block|,
literal|13
block|,
literal|16
block|,
literal|24
block|,
literal|40
block|,
literal|57
block|,
literal|69
block|,
literal|56
block|,
literal|14
block|,
literal|17
block|,
literal|22
block|,
literal|29
block|,
literal|51
block|,
literal|87
block|,
literal|80
block|,
literal|62
block|,
literal|18
block|,
literal|22
block|,
literal|37
block|,
literal|56
block|,
literal|68
block|,
literal|109
block|,
literal|103
block|,
literal|77
block|,
literal|24
block|,
literal|35
block|,
literal|55
block|,
literal|64
block|,
literal|81
block|,
literal|104
block|,
literal|113
block|,
literal|92
block|,
literal|49
block|,
literal|64
block|,
literal|78
block|,
literal|87
block|,
literal|103
block|,
literal|121
block|,
literal|120
block|,
literal|101
block|,
literal|72
block|,
literal|92
block|,
literal|95
block|,
literal|98
block|,
literal|112
block|,
literal|100
block|,
literal|103
block|,
literal|99
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|std_chrominance_quant_tbl
specifier|static
specifier|const
name|unsigned
name|int
name|std_chrominance_quant_tbl
index|[
name|DCTSIZE2
index|]
init|=
block|{
literal|17
block|,
literal|18
block|,
literal|24
block|,
literal|47
block|,
literal|99
block|,
literal|99
block|,
literal|99
block|,
literal|99
block|,
literal|18
block|,
literal|21
block|,
literal|26
block|,
literal|66
block|,
literal|99
block|,
literal|99
block|,
literal|99
block|,
literal|99
block|,
literal|24
block|,
literal|26
block|,
literal|56
block|,
literal|99
block|,
literal|99
block|,
literal|99
block|,
literal|99
block|,
literal|99
block|,
literal|47
block|,
literal|66
block|,
literal|99
block|,
literal|99
block|,
literal|99
block|,
literal|99
block|,
literal|99
block|,
literal|99
block|,
literal|99
block|,
literal|99
block|,
literal|99
block|,
literal|99
block|,
literal|99
block|,
literal|99
block|,
literal|99
block|,
literal|99
block|,
literal|99
block|,
literal|99
block|,
literal|99
block|,
literal|99
block|,
literal|99
block|,
literal|99
block|,
literal|99
block|,
literal|99
block|,
literal|99
block|,
literal|99
block|,
literal|99
block|,
literal|99
block|,
literal|99
block|,
literal|99
block|,
literal|99
block|,
literal|99
block|,
literal|99
block|,
literal|99
block|,
literal|99
block|,
literal|99
block|,
literal|99
block|,
literal|99
block|,
literal|99
block|,
literal|99
block|}
decl_stmt|;
end_decl_stmt
begin_macro
name|GLOBAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|jpeg_default_qtables
name|jpeg_default_qtables
argument_list|(
argument|j_compress_ptr cinfo
argument_list|,
argument|boolean force_baseline
argument_list|)
end_macro
begin_comment
comment|/* Set or change the 'quality' (quantization) setting, using default tables  * and straight percentage-scaling quality scales.  * This entry point allows different scalings for luminance and chrominance.  */
end_comment
begin_block
block|{
comment|/* Set up two quantization tables using the specified scaling */
name|jpeg_add_quant_table
argument_list|(
name|cinfo
argument_list|,
literal|0
argument_list|,
name|std_luminance_quant_tbl
argument_list|,
name|cinfo
operator|->
name|q_scale_factor
index|[
literal|0
index|]
argument_list|,
name|force_baseline
argument_list|)
expr_stmt|;
name|jpeg_add_quant_table
argument_list|(
name|cinfo
argument_list|,
literal|1
argument_list|,
name|std_chrominance_quant_tbl
argument_list|,
name|cinfo
operator|->
name|q_scale_factor
index|[
literal|1
index|]
argument_list|,
name|force_baseline
argument_list|)
expr_stmt|;
block|}
end_block
begin_macro
name|GLOBAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|jpeg_set_linear_quality
name|jpeg_set_linear_quality
argument_list|(
argument|j_compress_ptr cinfo
argument_list|,
argument|int scale_factor
argument_list|,
argument|boolean force_baseline
argument_list|)
end_macro
begin_comment
comment|/* Set or change the 'quality' (quantization) setting, using default tables  * and a straight percentage-scaling quality scale.  In most cases it's better  * to use jpeg_set_quality (below); this entry point is provided for  * applications that insist on a linear percentage scaling.  */
end_comment
begin_block
block|{
comment|/* Set up two quantization tables using the specified scaling */
name|jpeg_add_quant_table
argument_list|(
name|cinfo
argument_list|,
literal|0
argument_list|,
name|std_luminance_quant_tbl
argument_list|,
name|scale_factor
argument_list|,
name|force_baseline
argument_list|)
expr_stmt|;
name|jpeg_add_quant_table
argument_list|(
name|cinfo
argument_list|,
literal|1
argument_list|,
name|std_chrominance_quant_tbl
argument_list|,
name|scale_factor
argument_list|,
name|force_baseline
argument_list|)
expr_stmt|;
block|}
end_block
begin_macro
name|GLOBAL
argument_list|(
argument|int
argument_list|)
end_macro
begin_macro
DECL|function|jpeg_quality_scaling
name|jpeg_quality_scaling
argument_list|(
argument|int quality
argument_list|)
end_macro
begin_comment
comment|/* Convert a user-specified quality rating to a percentage scaling factor  * for an underlying quantization table, using our recommended scaling curve.  * The input 'quality' factor should be 0 (terrible) to 100 (very good).  */
end_comment
begin_block
block|{
comment|/* Safety limit on quality factor.  Convert 0 to 1 to avoid zero divide. */
if|if
condition|(
name|quality
operator|<=
literal|0
condition|)
name|quality
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|quality
operator|>
literal|100
condition|)
name|quality
operator|=
literal|100
expr_stmt|;
comment|/* The basic table is used as-is (scaling 100) for a quality of 50.    * Qualities 50..100 are converted to scaling percentage 200 - 2*Q;    * note that at Q=100 the scaling is 0, which will cause jpeg_add_quant_table    * to make all the table entries 1 (hence, minimum quantization loss).    * Qualities 1..50 are converted to scaling percentage 5000/Q.    */
if|if
condition|(
name|quality
operator|<
literal|50
condition|)
name|quality
operator|=
literal|5000
operator|/
name|quality
expr_stmt|;
else|else
name|quality
operator|=
literal|200
operator|-
name|quality
operator|*
literal|2
expr_stmt|;
return|return
name|quality
return|;
block|}
end_block
begin_macro
name|GLOBAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|jpeg_set_quality
name|jpeg_set_quality
argument_list|(
argument|j_compress_ptr cinfo
argument_list|,
argument|int quality
argument_list|,
argument|boolean force_baseline
argument_list|)
end_macro
begin_comment
comment|/* Set or change the 'quality' (quantization) setting, using default tables.  * This is the standard quality-adjusting entry point for typical user  * interfaces; only those who want detailed control over quantization tables  * would use the preceding three routines directly.  */
end_comment
begin_block
block|{
comment|/* Convert user 0-100 rating to percentage scaling */
name|quality
operator|=
name|jpeg_quality_scaling
argument_list|(
name|quality
argument_list|)
expr_stmt|;
comment|/* Set up standard quality tables */
name|jpeg_set_linear_quality
argument_list|(
name|cinfo
argument_list|,
name|quality
argument_list|,
name|force_baseline
argument_list|)
expr_stmt|;
block|}
end_block
begin_comment
comment|/*  * Huffman table setup routines  */
end_comment
begin_macro
name|LOCAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|add_huff_table
name|add_huff_table
argument_list|(
argument|j_compress_ptr cinfo
argument_list|,
argument|JHUFF_TBL **htblptr
argument_list|,
argument|const UINT8 *bits
argument_list|,
argument|const UINT8 *val
argument_list|)
end_macro
begin_comment
comment|/* Define a Huffman table */
end_comment
begin_block
block|{
name|int
name|nsymbols
decl_stmt|,
name|len
decl_stmt|;
if|if
condition|(
operator|*
name|htblptr
operator|==
name|NULL
condition|)
operator|*
name|htblptr
operator|=
name|jpeg_alloc_huff_table
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|)
expr_stmt|;
comment|/* Copy the number-of-symbols-of-each-code-length counts */
name|MEMCOPY
argument_list|(
operator|(
operator|*
name|htblptr
operator|)
operator|->
name|bits
argument_list|,
name|bits
argument_list|,
name|SIZEOF
argument_list|(
operator|(
operator|*
name|htblptr
operator|)
operator|->
name|bits
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Validate the counts.  We do this here mainly so we can copy the right    * number of symbols from the val[] array, without risking marching off    * the end of memory.  jchuff.c will do a more thorough test later.    */
name|nsymbols
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|len
operator|=
literal|1
init|;
name|len
operator|<=
literal|16
condition|;
name|len
operator|++
control|)
name|nsymbols
operator|+=
name|bits
index|[
name|len
index|]
expr_stmt|;
if|if
condition|(
name|nsymbols
operator|<
literal|1
operator|||
name|nsymbols
operator|>
literal|256
condition|)
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_HUFF_TABLE
argument_list|)
expr_stmt|;
name|MEMCOPY
argument_list|(
operator|(
operator|*
name|htblptr
operator|)
operator|->
name|huffval
argument_list|,
name|val
argument_list|,
name|nsymbols
operator|*
name|SIZEOF
argument_list|(
name|UINT8
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialize sent_table FALSE so table will be written to JPEG file. */
operator|(
operator|*
name|htblptr
operator|)
operator|->
name|sent_table
operator|=
name|FALSE
expr_stmt|;
block|}
end_block
begin_macro
name|LOCAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|std_huff_tables
name|std_huff_tables
argument_list|(
argument|j_compress_ptr cinfo
argument_list|)
end_macro
begin_comment
comment|/* Set up the standard Huffman tables (cf. JPEG standard section K.3) */
end_comment
begin_comment
comment|/* IMPORTANT: these are only valid for 8-bit data precision! */
end_comment
begin_block
block|{
specifier|static
specifier|const
name|UINT8
name|bits_dc_luminance
index|[
literal|17
index|]
init|=
block|{
comment|/* 0-base */
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|5
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
specifier|static
specifier|const
name|UINT8
name|val_dc_luminance
index|[]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|}
decl_stmt|;
specifier|static
specifier|const
name|UINT8
name|bits_dc_chrominance
index|[
literal|17
index|]
init|=
block|{
comment|/* 0-base */
literal|0
block|,
literal|0
block|,
literal|3
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
specifier|static
specifier|const
name|UINT8
name|val_dc_chrominance
index|[]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|}
decl_stmt|;
specifier|static
specifier|const
name|UINT8
name|bits_ac_luminance
index|[
literal|17
index|]
init|=
block|{
comment|/* 0-base */
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|1
block|,
literal|3
block|,
literal|3
block|,
literal|2
block|,
literal|4
block|,
literal|3
block|,
literal|5
block|,
literal|5
block|,
literal|4
block|,
literal|4
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0x7d
block|}
decl_stmt|;
specifier|static
specifier|const
name|UINT8
name|val_ac_luminance
index|[]
init|=
block|{
literal|0x01
block|,
literal|0x02
block|,
literal|0x03
block|,
literal|0x00
block|,
literal|0x04
block|,
literal|0x11
block|,
literal|0x05
block|,
literal|0x12
block|,
literal|0x21
block|,
literal|0x31
block|,
literal|0x41
block|,
literal|0x06
block|,
literal|0x13
block|,
literal|0x51
block|,
literal|0x61
block|,
literal|0x07
block|,
literal|0x22
block|,
literal|0x71
block|,
literal|0x14
block|,
literal|0x32
block|,
literal|0x81
block|,
literal|0x91
block|,
literal|0xa1
block|,
literal|0x08
block|,
literal|0x23
block|,
literal|0x42
block|,
literal|0xb1
block|,
literal|0xc1
block|,
literal|0x15
block|,
literal|0x52
block|,
literal|0xd1
block|,
literal|0xf0
block|,
literal|0x24
block|,
literal|0x33
block|,
literal|0x62
block|,
literal|0x72
block|,
literal|0x82
block|,
literal|0x09
block|,
literal|0x0a
block|,
literal|0x16
block|,
literal|0x17
block|,
literal|0x18
block|,
literal|0x19
block|,
literal|0x1a
block|,
literal|0x25
block|,
literal|0x26
block|,
literal|0x27
block|,
literal|0x28
block|,
literal|0x29
block|,
literal|0x2a
block|,
literal|0x34
block|,
literal|0x35
block|,
literal|0x36
block|,
literal|0x37
block|,
literal|0x38
block|,
literal|0x39
block|,
literal|0x3a
block|,
literal|0x43
block|,
literal|0x44
block|,
literal|0x45
block|,
literal|0x46
block|,
literal|0x47
block|,
literal|0x48
block|,
literal|0x49
block|,
literal|0x4a
block|,
literal|0x53
block|,
literal|0x54
block|,
literal|0x55
block|,
literal|0x56
block|,
literal|0x57
block|,
literal|0x58
block|,
literal|0x59
block|,
literal|0x5a
block|,
literal|0x63
block|,
literal|0x64
block|,
literal|0x65
block|,
literal|0x66
block|,
literal|0x67
block|,
literal|0x68
block|,
literal|0x69
block|,
literal|0x6a
block|,
literal|0x73
block|,
literal|0x74
block|,
literal|0x75
block|,
literal|0x76
block|,
literal|0x77
block|,
literal|0x78
block|,
literal|0x79
block|,
literal|0x7a
block|,
literal|0x83
block|,
literal|0x84
block|,
literal|0x85
block|,
literal|0x86
block|,
literal|0x87
block|,
literal|0x88
block|,
literal|0x89
block|,
literal|0x8a
block|,
literal|0x92
block|,
literal|0x93
block|,
literal|0x94
block|,
literal|0x95
block|,
literal|0x96
block|,
literal|0x97
block|,
literal|0x98
block|,
literal|0x99
block|,
literal|0x9a
block|,
literal|0xa2
block|,
literal|0xa3
block|,
literal|0xa4
block|,
literal|0xa5
block|,
literal|0xa6
block|,
literal|0xa7
block|,
literal|0xa8
block|,
literal|0xa9
block|,
literal|0xaa
block|,
literal|0xb2
block|,
literal|0xb3
block|,
literal|0xb4
block|,
literal|0xb5
block|,
literal|0xb6
block|,
literal|0xb7
block|,
literal|0xb8
block|,
literal|0xb9
block|,
literal|0xba
block|,
literal|0xc2
block|,
literal|0xc3
block|,
literal|0xc4
block|,
literal|0xc5
block|,
literal|0xc6
block|,
literal|0xc7
block|,
literal|0xc8
block|,
literal|0xc9
block|,
literal|0xca
block|,
literal|0xd2
block|,
literal|0xd3
block|,
literal|0xd4
block|,
literal|0xd5
block|,
literal|0xd6
block|,
literal|0xd7
block|,
literal|0xd8
block|,
literal|0xd9
block|,
literal|0xda
block|,
literal|0xe1
block|,
literal|0xe2
block|,
literal|0xe3
block|,
literal|0xe4
block|,
literal|0xe5
block|,
literal|0xe6
block|,
literal|0xe7
block|,
literal|0xe8
block|,
literal|0xe9
block|,
literal|0xea
block|,
literal|0xf1
block|,
literal|0xf2
block|,
literal|0xf3
block|,
literal|0xf4
block|,
literal|0xf5
block|,
literal|0xf6
block|,
literal|0xf7
block|,
literal|0xf8
block|,
literal|0xf9
block|,
literal|0xfa
block|}
decl_stmt|;
specifier|static
specifier|const
name|UINT8
name|bits_ac_chrominance
index|[
literal|17
index|]
init|=
block|{
comment|/* 0-base */
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|1
block|,
literal|2
block|,
literal|4
block|,
literal|4
block|,
literal|3
block|,
literal|4
block|,
literal|7
block|,
literal|5
block|,
literal|4
block|,
literal|4
block|,
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|0x77
block|}
decl_stmt|;
specifier|static
specifier|const
name|UINT8
name|val_ac_chrominance
index|[]
init|=
block|{
literal|0x00
block|,
literal|0x01
block|,
literal|0x02
block|,
literal|0x03
block|,
literal|0x11
block|,
literal|0x04
block|,
literal|0x05
block|,
literal|0x21
block|,
literal|0x31
block|,
literal|0x06
block|,
literal|0x12
block|,
literal|0x41
block|,
literal|0x51
block|,
literal|0x07
block|,
literal|0x61
block|,
literal|0x71
block|,
literal|0x13
block|,
literal|0x22
block|,
literal|0x32
block|,
literal|0x81
block|,
literal|0x08
block|,
literal|0x14
block|,
literal|0x42
block|,
literal|0x91
block|,
literal|0xa1
block|,
literal|0xb1
block|,
literal|0xc1
block|,
literal|0x09
block|,
literal|0x23
block|,
literal|0x33
block|,
literal|0x52
block|,
literal|0xf0
block|,
literal|0x15
block|,
literal|0x62
block|,
literal|0x72
block|,
literal|0xd1
block|,
literal|0x0a
block|,
literal|0x16
block|,
literal|0x24
block|,
literal|0x34
block|,
literal|0xe1
block|,
literal|0x25
block|,
literal|0xf1
block|,
literal|0x17
block|,
literal|0x18
block|,
literal|0x19
block|,
literal|0x1a
block|,
literal|0x26
block|,
literal|0x27
block|,
literal|0x28
block|,
literal|0x29
block|,
literal|0x2a
block|,
literal|0x35
block|,
literal|0x36
block|,
literal|0x37
block|,
literal|0x38
block|,
literal|0x39
block|,
literal|0x3a
block|,
literal|0x43
block|,
literal|0x44
block|,
literal|0x45
block|,
literal|0x46
block|,
literal|0x47
block|,
literal|0x48
block|,
literal|0x49
block|,
literal|0x4a
block|,
literal|0x53
block|,
literal|0x54
block|,
literal|0x55
block|,
literal|0x56
block|,
literal|0x57
block|,
literal|0x58
block|,
literal|0x59
block|,
literal|0x5a
block|,
literal|0x63
block|,
literal|0x64
block|,
literal|0x65
block|,
literal|0x66
block|,
literal|0x67
block|,
literal|0x68
block|,
literal|0x69
block|,
literal|0x6a
block|,
literal|0x73
block|,
literal|0x74
block|,
literal|0x75
block|,
literal|0x76
block|,
literal|0x77
block|,
literal|0x78
block|,
literal|0x79
block|,
literal|0x7a
block|,
literal|0x82
block|,
literal|0x83
block|,
literal|0x84
block|,
literal|0x85
block|,
literal|0x86
block|,
literal|0x87
block|,
literal|0x88
block|,
literal|0x89
block|,
literal|0x8a
block|,
literal|0x92
block|,
literal|0x93
block|,
literal|0x94
block|,
literal|0x95
block|,
literal|0x96
block|,
literal|0x97
block|,
literal|0x98
block|,
literal|0x99
block|,
literal|0x9a
block|,
literal|0xa2
block|,
literal|0xa3
block|,
literal|0xa4
block|,
literal|0xa5
block|,
literal|0xa6
block|,
literal|0xa7
block|,
literal|0xa8
block|,
literal|0xa9
block|,
literal|0xaa
block|,
literal|0xb2
block|,
literal|0xb3
block|,
literal|0xb4
block|,
literal|0xb5
block|,
literal|0xb6
block|,
literal|0xb7
block|,
literal|0xb8
block|,
literal|0xb9
block|,
literal|0xba
block|,
literal|0xc2
block|,
literal|0xc3
block|,
literal|0xc4
block|,
literal|0xc5
block|,
literal|0xc6
block|,
literal|0xc7
block|,
literal|0xc8
block|,
literal|0xc9
block|,
literal|0xca
block|,
literal|0xd2
block|,
literal|0xd3
block|,
literal|0xd4
block|,
literal|0xd5
block|,
literal|0xd6
block|,
literal|0xd7
block|,
literal|0xd8
block|,
literal|0xd9
block|,
literal|0xda
block|,
literal|0xe2
block|,
literal|0xe3
block|,
literal|0xe4
block|,
literal|0xe5
block|,
literal|0xe6
block|,
literal|0xe7
block|,
literal|0xe8
block|,
literal|0xe9
block|,
literal|0xea
block|,
literal|0xf2
block|,
literal|0xf3
block|,
literal|0xf4
block|,
literal|0xf5
block|,
literal|0xf6
block|,
literal|0xf7
block|,
literal|0xf8
block|,
literal|0xf9
block|,
literal|0xfa
block|}
decl_stmt|;
name|add_huff_table
argument_list|(
name|cinfo
argument_list|,
operator|&
name|cinfo
operator|->
name|dc_huff_tbl_ptrs
index|[
literal|0
index|]
argument_list|,
name|bits_dc_luminance
argument_list|,
name|val_dc_luminance
argument_list|)
expr_stmt|;
name|add_huff_table
argument_list|(
name|cinfo
argument_list|,
operator|&
name|cinfo
operator|->
name|ac_huff_tbl_ptrs
index|[
literal|0
index|]
argument_list|,
name|bits_ac_luminance
argument_list|,
name|val_ac_luminance
argument_list|)
expr_stmt|;
name|add_huff_table
argument_list|(
name|cinfo
argument_list|,
operator|&
name|cinfo
operator|->
name|dc_huff_tbl_ptrs
index|[
literal|1
index|]
argument_list|,
name|bits_dc_chrominance
argument_list|,
name|val_dc_chrominance
argument_list|)
expr_stmt|;
name|add_huff_table
argument_list|(
name|cinfo
argument_list|,
operator|&
name|cinfo
operator|->
name|ac_huff_tbl_ptrs
index|[
literal|1
index|]
argument_list|,
name|bits_ac_chrominance
argument_list|,
name|val_ac_chrominance
argument_list|)
expr_stmt|;
block|}
end_block
begin_comment
comment|/*  * Default parameter setup for compression.  *  * Applications that don't choose to use this routine must do their  * own setup of all these parameters.  Alternately, you can call this  * to establish defaults and then alter parameters selectively.  This  * is the recommended approach since, if we add any new parameters,  * your code will still work (they'll be set to reasonable defaults).  */
end_comment
begin_macro
name|GLOBAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|jpeg_set_defaults
name|jpeg_set_defaults
argument_list|(
argument|j_compress_ptr cinfo
argument_list|)
end_macro
begin_block
block|{
name|int
name|i
decl_stmt|;
comment|/* Safety check to ensure start_compress not called yet. */
if|if
condition|(
name|cinfo
operator|->
name|global_state
operator|!=
name|CSTATE_START
condition|)
name|ERREXIT1
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_STATE
argument_list|,
name|cinfo
operator|->
name|global_state
argument_list|)
expr_stmt|;
comment|/* Allocate comp_info array large enough for maximum component count.    * Array is made permanent in case application wants to compress    * multiple images at same param settings.    */
if|if
condition|(
name|cinfo
operator|->
name|comp_info
operator|==
name|NULL
condition|)
name|cinfo
operator|->
name|comp_info
operator|=
operator|(
name|jpeg_component_info
operator|*
operator|)
call|(
modifier|*
name|cinfo
operator|->
name|mem
operator|->
name|alloc_small
call|)
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|,
name|JPOOL_PERMANENT
argument_list|,
name|MAX_COMPONENTS
operator|*
name|SIZEOF
argument_list|(
name|jpeg_component_info
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialize everything not dependent on the color space */
name|cinfo
operator|->
name|scale_num
operator|=
literal|1
expr_stmt|;
comment|/* 1:1 scaling */
name|cinfo
operator|->
name|scale_denom
operator|=
literal|1
expr_stmt|;
name|cinfo
operator|->
name|data_precision
operator|=
name|BITS_IN_JSAMPLE
expr_stmt|;
comment|/* Set up two quantization tables using default quality of 75 */
name|jpeg_set_quality
argument_list|(
name|cinfo
argument_list|,
literal|75
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* Set up two Huffman tables */
name|std_huff_tables
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
comment|/* Initialize default arithmetic coding conditioning */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_ARITH_TBLS
condition|;
name|i
operator|++
control|)
block|{
name|cinfo
operator|->
name|arith_dc_L
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|cinfo
operator|->
name|arith_dc_U
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|cinfo
operator|->
name|arith_ac_K
index|[
name|i
index|]
operator|=
literal|5
expr_stmt|;
block|}
comment|/* Default is no multiple-scan output */
name|cinfo
operator|->
name|scan_info
operator|=
name|NULL
expr_stmt|;
name|cinfo
operator|->
name|num_scans
operator|=
literal|0
expr_stmt|;
comment|/* Expect normal source image, not raw downsampled data */
name|cinfo
operator|->
name|raw_data_in
operator|=
name|FALSE
expr_stmt|;
comment|/* Use Huffman coding, not arithmetic coding, by default */
name|cinfo
operator|->
name|arith_code
operator|=
name|FALSE
expr_stmt|;
comment|/* By default, don't do extra passes to optimize entropy coding */
name|cinfo
operator|->
name|optimize_coding
operator|=
name|FALSE
expr_stmt|;
comment|/* The standard Huffman tables are only valid for 8-bit data precision.    * If the precision is higher, force optimization on so that usable    * tables will be computed.  This test can be removed if default tables    * are supplied that are valid for the desired precision.    */
if|if
condition|(
name|cinfo
operator|->
name|data_precision
operator|>
literal|8
condition|)
name|cinfo
operator|->
name|optimize_coding
operator|=
name|TRUE
expr_stmt|;
comment|/* By default, use the simpler non-cosited sampling alignment */
name|cinfo
operator|->
name|CCIR601_sampling
operator|=
name|FALSE
expr_stmt|;
comment|/* By default, apply fancy downsampling */
name|cinfo
operator|->
name|do_fancy_downsampling
operator|=
name|TRUE
expr_stmt|;
comment|/* No input smoothing */
name|cinfo
operator|->
name|smoothing_factor
operator|=
literal|0
expr_stmt|;
comment|/* DCT algorithm preference */
name|cinfo
operator|->
name|dct_method
operator|=
name|JDCT_DEFAULT
expr_stmt|;
comment|/* No restart markers */
name|cinfo
operator|->
name|restart_interval
operator|=
literal|0
expr_stmt|;
name|cinfo
operator|->
name|restart_in_rows
operator|=
literal|0
expr_stmt|;
comment|/* Fill in default JFIF marker parameters.  Note that whether the marker    * will actually be written is determined by jpeg_set_colorspace.    *    * By default, the library emits JFIF version code 1.01.    * An application that wants to emit JFIF 1.02 extension markers should set    * JFIF_minor_version to 2.  We could probably get away with just defaulting    * to 1.02, but there may still be some decoders in use that will complain    * about that; saying 1.01 should minimize compatibility problems.    */
name|cinfo
operator|->
name|JFIF_major_version
operator|=
literal|1
expr_stmt|;
comment|/* Default JFIF version = 1.01 */
name|cinfo
operator|->
name|JFIF_minor_version
operator|=
literal|1
expr_stmt|;
name|cinfo
operator|->
name|density_unit
operator|=
literal|0
expr_stmt|;
comment|/* Pixel size is unknown by default */
name|cinfo
operator|->
name|X_density
operator|=
literal|1
expr_stmt|;
comment|/* Pixel aspect ratio is square by default */
name|cinfo
operator|->
name|Y_density
operator|=
literal|1
expr_stmt|;
comment|/* Choose JPEG colorspace based on input space, set defaults accordingly */
name|jpeg_default_colorspace
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
block|}
end_block
begin_comment
comment|/*  * Select an appropriate JPEG colorspace for in_color_space.  */
end_comment
begin_macro
name|GLOBAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|jpeg_default_colorspace
name|jpeg_default_colorspace
argument_list|(
argument|j_compress_ptr cinfo
argument_list|)
end_macro
begin_block
block|{
switch|switch
condition|(
name|cinfo
operator|->
name|in_color_space
condition|)
block|{
case|case
name|JCS_GRAYSCALE
case|:
name|jpeg_set_colorspace
argument_list|(
name|cinfo
argument_list|,
name|JCS_GRAYSCALE
argument_list|)
expr_stmt|;
break|break;
case|case
name|JCS_RGB
case|:
name|jpeg_set_colorspace
argument_list|(
name|cinfo
argument_list|,
name|JCS_YCbCr
argument_list|)
expr_stmt|;
break|break;
case|case
name|JCS_YCbCr
case|:
name|jpeg_set_colorspace
argument_list|(
name|cinfo
argument_list|,
name|JCS_YCbCr
argument_list|)
expr_stmt|;
break|break;
case|case
name|JCS_CMYK
case|:
name|jpeg_set_colorspace
argument_list|(
name|cinfo
argument_list|,
name|JCS_CMYK
argument_list|)
expr_stmt|;
comment|/* By default, no translation */
break|break;
case|case
name|JCS_YCCK
case|:
name|jpeg_set_colorspace
argument_list|(
name|cinfo
argument_list|,
name|JCS_YCCK
argument_list|)
expr_stmt|;
break|break;
case|case
name|JCS_UNKNOWN
case|:
name|jpeg_set_colorspace
argument_list|(
name|cinfo
argument_list|,
name|JCS_UNKNOWN
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_IN_COLORSPACE
argument_list|)
expr_stmt|;
block|}
block|}
end_block
begin_comment
comment|/*  * Set the JPEG colorspace, and choose colorspace-dependent default values.  */
end_comment
begin_macro
name|GLOBAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|jpeg_set_colorspace
name|jpeg_set_colorspace
argument_list|(
argument|j_compress_ptr cinfo
argument_list|,
argument|J_COLOR_SPACE colorspace
argument_list|)
end_macro
begin_block
block|{
name|jpeg_component_info
modifier|*
name|compptr
decl_stmt|;
name|int
name|ci
decl_stmt|;
DECL|macro|SET_COMP
define|#
directive|define
name|SET_COMP
parameter_list|(
name|index
parameter_list|,
name|id
parameter_list|,
name|hsamp
parameter_list|,
name|vsamp
parameter_list|,
name|quant
parameter_list|,
name|dctbl
parameter_list|,
name|actbl
parameter_list|)
define|\
value|(compptr =&cinfo->comp_info[index], \    compptr->component_id = (id), \    compptr->h_samp_factor = (hsamp), \    compptr->v_samp_factor = (vsamp), \    compptr->quant_tbl_no = (quant), \    compptr->dc_tbl_no = (dctbl), \    compptr->ac_tbl_no = (actbl) )
comment|/* Safety check to ensure start_compress not called yet. */
if|if
condition|(
name|cinfo
operator|->
name|global_state
operator|!=
name|CSTATE_START
condition|)
name|ERREXIT1
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_STATE
argument_list|,
name|cinfo
operator|->
name|global_state
argument_list|)
expr_stmt|;
comment|/* For all colorspaces, we use Q and Huff tables 0 for luminance components,    * tables 1 for chrominance components.    */
name|cinfo
operator|->
name|jpeg_color_space
operator|=
name|colorspace
expr_stmt|;
name|cinfo
operator|->
name|write_JFIF_header
operator|=
name|FALSE
expr_stmt|;
comment|/* No marker for non-JFIF colorspaces */
name|cinfo
operator|->
name|write_Adobe_marker
operator|=
name|FALSE
expr_stmt|;
comment|/* write no Adobe marker by default */
switch|switch
condition|(
name|colorspace
condition|)
block|{
case|case
name|JCS_GRAYSCALE
case|:
name|cinfo
operator|->
name|write_JFIF_header
operator|=
name|TRUE
expr_stmt|;
comment|/* Write a JFIF marker */
name|cinfo
operator|->
name|num_components
operator|=
literal|1
expr_stmt|;
comment|/* JFIF specifies component ID 1 */
name|SET_COMP
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|JCS_RGB
case|:
name|cinfo
operator|->
name|write_Adobe_marker
operator|=
name|TRUE
expr_stmt|;
comment|/* write Adobe marker to flag RGB */
name|cinfo
operator|->
name|num_components
operator|=
literal|3
expr_stmt|;
name|SET_COMP
argument_list|(
literal|0
argument_list|,
literal|0x52
comment|/* 'R' */
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SET_COMP
argument_list|(
literal|1
argument_list|,
literal|0x47
comment|/* 'G' */
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SET_COMP
argument_list|(
literal|2
argument_list|,
literal|0x42
comment|/* 'B' */
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|JCS_YCbCr
case|:
name|cinfo
operator|->
name|write_JFIF_header
operator|=
name|TRUE
expr_stmt|;
comment|/* Write a JFIF marker */
name|cinfo
operator|->
name|num_components
operator|=
literal|3
expr_stmt|;
comment|/* JFIF specifies component IDs 1,2,3 */
comment|/* We default to 2x2 subsamples of chrominance */
name|SET_COMP
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SET_COMP
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SET_COMP
argument_list|(
literal|2
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|JCS_CMYK
case|:
name|cinfo
operator|->
name|write_Adobe_marker
operator|=
name|TRUE
expr_stmt|;
comment|/* write Adobe marker to flag CMYK */
name|cinfo
operator|->
name|num_components
operator|=
literal|4
expr_stmt|;
name|SET_COMP
argument_list|(
literal|0
argument_list|,
literal|0x43
comment|/* 'C' */
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SET_COMP
argument_list|(
literal|1
argument_list|,
literal|0x4D
comment|/* 'M' */
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SET_COMP
argument_list|(
literal|2
argument_list|,
literal|0x59
comment|/* 'Y' */
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SET_COMP
argument_list|(
literal|3
argument_list|,
literal|0x4B
comment|/* 'K' */
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|JCS_YCCK
case|:
name|cinfo
operator|->
name|write_Adobe_marker
operator|=
name|TRUE
expr_stmt|;
comment|/* write Adobe marker to flag YCCK */
name|cinfo
operator|->
name|num_components
operator|=
literal|4
expr_stmt|;
name|SET_COMP
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SET_COMP
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SET_COMP
argument_list|(
literal|2
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SET_COMP
argument_list|(
literal|3
argument_list|,
literal|4
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|JCS_UNKNOWN
case|:
name|cinfo
operator|->
name|num_components
operator|=
name|cinfo
operator|->
name|input_components
expr_stmt|;
if|if
condition|(
name|cinfo
operator|->
name|num_components
operator|<
literal|1
operator|||
name|cinfo
operator|->
name|num_components
operator|>
name|MAX_COMPONENTS
condition|)
name|ERREXIT2
argument_list|(
name|cinfo
argument_list|,
name|JERR_COMPONENT_COUNT
argument_list|,
name|cinfo
operator|->
name|num_components
argument_list|,
name|MAX_COMPONENTS
argument_list|)
expr_stmt|;
for|for
control|(
name|ci
operator|=
literal|0
init|;
name|ci
operator|<
name|cinfo
operator|->
name|num_components
condition|;
name|ci
operator|++
control|)
block|{
name|SET_COMP
argument_list|(
name|ci
argument_list|,
name|ci
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_J_COLORSPACE
argument_list|)
expr_stmt|;
block|}
block|}
end_block
begin_ifdef
ifdef|#
directive|ifdef
name|C_PROGRESSIVE_SUPPORTED
end_ifdef
begin_macro
name|LOCAL
argument_list|(
argument|jpeg_scan_info *
argument_list|)
end_macro
begin_macro
DECL|function|fill_a_scan
name|fill_a_scan
argument_list|(
argument|jpeg_scan_info * scanptr
argument_list|,
argument|int ci
argument_list|,
argument|int Ss
argument_list|,
argument|int Se
argument_list|,
argument|int Ah
argument_list|,
argument|int Al
argument_list|)
end_macro
begin_comment
comment|/* Support routine: generate one scan for specified component */
end_comment
begin_block
block|{
name|scanptr
operator|->
name|comps_in_scan
operator|=
literal|1
expr_stmt|;
name|scanptr
operator|->
name|component_index
index|[
literal|0
index|]
operator|=
name|ci
expr_stmt|;
name|scanptr
operator|->
name|Ss
operator|=
name|Ss
expr_stmt|;
name|scanptr
operator|->
name|Se
operator|=
name|Se
expr_stmt|;
name|scanptr
operator|->
name|Ah
operator|=
name|Ah
expr_stmt|;
name|scanptr
operator|->
name|Al
operator|=
name|Al
expr_stmt|;
name|scanptr
operator|++
expr_stmt|;
return|return
name|scanptr
return|;
block|}
end_block
begin_macro
name|LOCAL
argument_list|(
argument|jpeg_scan_info *
argument_list|)
end_macro
begin_macro
DECL|function|fill_scans
name|fill_scans
argument_list|(
argument|jpeg_scan_info * scanptr
argument_list|,
argument|int ncomps
argument_list|,
argument|int Ss
argument_list|,
argument|int Se
argument_list|,
argument|int Ah
argument_list|,
argument|int Al
argument_list|)
end_macro
begin_comment
comment|/* Support routine: generate one scan for each component */
end_comment
begin_block
block|{
name|int
name|ci
decl_stmt|;
for|for
control|(
name|ci
operator|=
literal|0
init|;
name|ci
operator|<
name|ncomps
condition|;
name|ci
operator|++
control|)
block|{
name|scanptr
operator|->
name|comps_in_scan
operator|=
literal|1
expr_stmt|;
name|scanptr
operator|->
name|component_index
index|[
literal|0
index|]
operator|=
name|ci
expr_stmt|;
name|scanptr
operator|->
name|Ss
operator|=
name|Ss
expr_stmt|;
name|scanptr
operator|->
name|Se
operator|=
name|Se
expr_stmt|;
name|scanptr
operator|->
name|Ah
operator|=
name|Ah
expr_stmt|;
name|scanptr
operator|->
name|Al
operator|=
name|Al
expr_stmt|;
name|scanptr
operator|++
expr_stmt|;
block|}
return|return
name|scanptr
return|;
block|}
end_block
begin_macro
name|LOCAL
argument_list|(
argument|jpeg_scan_info *
argument_list|)
end_macro
begin_macro
DECL|function|fill_dc_scans
name|fill_dc_scans
argument_list|(
argument|jpeg_scan_info * scanptr
argument_list|,
argument|int ncomps
argument_list|,
argument|int Ah
argument_list|,
argument|int Al
argument_list|)
end_macro
begin_comment
comment|/* Support routine: generate interleaved DC scan if possible, else N scans */
end_comment
begin_block
block|{
name|int
name|ci
decl_stmt|;
if|if
condition|(
name|ncomps
operator|<=
name|MAX_COMPS_IN_SCAN
condition|)
block|{
comment|/* Single interleaved DC scan */
name|scanptr
operator|->
name|comps_in_scan
operator|=
name|ncomps
expr_stmt|;
for|for
control|(
name|ci
operator|=
literal|0
init|;
name|ci
operator|<
name|ncomps
condition|;
name|ci
operator|++
control|)
name|scanptr
operator|->
name|component_index
index|[
name|ci
index|]
operator|=
name|ci
expr_stmt|;
name|scanptr
operator|->
name|Ss
operator|=
name|scanptr
operator|->
name|Se
operator|=
literal|0
expr_stmt|;
name|scanptr
operator|->
name|Ah
operator|=
name|Ah
expr_stmt|;
name|scanptr
operator|->
name|Al
operator|=
name|Al
expr_stmt|;
name|scanptr
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* Noninterleaved DC scan for each component */
name|scanptr
operator|=
name|fill_scans
argument_list|(
name|scanptr
argument_list|,
name|ncomps
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|Ah
argument_list|,
name|Al
argument_list|)
expr_stmt|;
block|}
return|return
name|scanptr
return|;
block|}
end_block
begin_comment
comment|/*  * Create a recommended progressive-JPEG script.  * cinfo->num_components and cinfo->jpeg_color_space must be correct.  */
end_comment
begin_macro
name|GLOBAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|jpeg_simple_progression
name|jpeg_simple_progression
argument_list|(
argument|j_compress_ptr cinfo
argument_list|)
end_macro
begin_block
block|{
name|int
name|ncomps
init|=
name|cinfo
operator|->
name|num_components
decl_stmt|;
name|int
name|nscans
decl_stmt|;
name|jpeg_scan_info
modifier|*
name|scanptr
decl_stmt|;
comment|/* Safety check to ensure start_compress not called yet. */
if|if
condition|(
name|cinfo
operator|->
name|global_state
operator|!=
name|CSTATE_START
condition|)
name|ERREXIT1
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_STATE
argument_list|,
name|cinfo
operator|->
name|global_state
argument_list|)
expr_stmt|;
comment|/* Figure space needed for script.  Calculation must match code below! */
if|if
condition|(
name|ncomps
operator|==
literal|3
operator|&&
name|cinfo
operator|->
name|jpeg_color_space
operator|==
name|JCS_YCbCr
condition|)
block|{
comment|/* Custom script for YCbCr color images. */
name|nscans
operator|=
literal|10
expr_stmt|;
block|}
else|else
block|{
comment|/* All-purpose script for other color spaces. */
if|if
condition|(
name|ncomps
operator|>
name|MAX_COMPS_IN_SCAN
condition|)
name|nscans
operator|=
literal|6
operator|*
name|ncomps
expr_stmt|;
comment|/* 2 DC + 4 AC scans per component */
else|else
name|nscans
operator|=
literal|2
operator|+
literal|4
operator|*
name|ncomps
expr_stmt|;
comment|/* 2 DC scans; 4 AC scans per component */
block|}
comment|/* Allocate space for script.    * We need to put it in the permanent pool in case the application performs    * multiple compressions without changing the settings.  To avoid a memory    * leak if jpeg_simple_progression is called repeatedly for the same JPEG    * object, we try to re-use previously allocated space, and we allocate    * enough space to handle YCbCr even if initially asked for grayscale.    */
if|if
condition|(
name|cinfo
operator|->
name|script_space
operator|==
name|NULL
operator|||
name|cinfo
operator|->
name|script_space_size
operator|<
name|nscans
condition|)
block|{
name|cinfo
operator|->
name|script_space_size
operator|=
name|MAX
argument_list|(
name|nscans
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|cinfo
operator|->
name|script_space
operator|=
operator|(
name|jpeg_scan_info
operator|*
operator|)
call|(
modifier|*
name|cinfo
operator|->
name|mem
operator|->
name|alloc_small
call|)
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|,
name|JPOOL_PERMANENT
argument_list|,
name|cinfo
operator|->
name|script_space_size
operator|*
name|SIZEOF
argument_list|(
name|jpeg_scan_info
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|scanptr
operator|=
name|cinfo
operator|->
name|script_space
expr_stmt|;
name|cinfo
operator|->
name|scan_info
operator|=
name|scanptr
expr_stmt|;
name|cinfo
operator|->
name|num_scans
operator|=
name|nscans
expr_stmt|;
if|if
condition|(
name|ncomps
operator|==
literal|3
operator|&&
name|cinfo
operator|->
name|jpeg_color_space
operator|==
name|JCS_YCbCr
condition|)
block|{
comment|/* Custom script for YCbCr color images. */
comment|/* Initial DC scan */
name|scanptr
operator|=
name|fill_dc_scans
argument_list|(
name|scanptr
argument_list|,
name|ncomps
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Initial AC scan: get some luma data out in a hurry */
name|scanptr
operator|=
name|fill_a_scan
argument_list|(
name|scanptr
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|5
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Chroma data is too small to be worth expending many scans on */
name|scanptr
operator|=
name|fill_a_scan
argument_list|(
name|scanptr
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
literal|63
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|scanptr
operator|=
name|fill_a_scan
argument_list|(
name|scanptr
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|63
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Complete spectral selection for luma AC */
name|scanptr
operator|=
name|fill_a_scan
argument_list|(
name|scanptr
argument_list|,
literal|0
argument_list|,
literal|6
argument_list|,
literal|63
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Refine next bit of luma AC */
name|scanptr
operator|=
name|fill_a_scan
argument_list|(
name|scanptr
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|63
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Finish DC successive approximation */
name|scanptr
operator|=
name|fill_dc_scans
argument_list|(
name|scanptr
argument_list|,
name|ncomps
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Finish AC successive approximation */
name|scanptr
operator|=
name|fill_a_scan
argument_list|(
name|scanptr
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
literal|63
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|scanptr
operator|=
name|fill_a_scan
argument_list|(
name|scanptr
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|63
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Luma bottom bit comes last since it's usually largest scan */
name|scanptr
operator|=
name|fill_a_scan
argument_list|(
name|scanptr
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|63
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* All-purpose script for other color spaces. */
comment|/* Successive approximation first pass */
name|scanptr
operator|=
name|fill_dc_scans
argument_list|(
name|scanptr
argument_list|,
name|ncomps
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|scanptr
operator|=
name|fill_scans
argument_list|(
name|scanptr
argument_list|,
name|ncomps
argument_list|,
literal|1
argument_list|,
literal|5
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|scanptr
operator|=
name|fill_scans
argument_list|(
name|scanptr
argument_list|,
name|ncomps
argument_list|,
literal|6
argument_list|,
literal|63
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Successive approximation second pass */
name|scanptr
operator|=
name|fill_scans
argument_list|(
name|scanptr
argument_list|,
name|ncomps
argument_list|,
literal|1
argument_list|,
literal|63
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Successive approximation final pass */
name|scanptr
operator|=
name|fill_dc_scans
argument_list|(
name|scanptr
argument_list|,
name|ncomps
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|scanptr
operator|=
name|fill_scans
argument_list|(
name|scanptr
argument_list|,
name|ncomps
argument_list|,
literal|1
argument_list|,
literal|63
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_block
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* C_PROGRESSIVE_SUPPORTED */
end_comment
end_unit
