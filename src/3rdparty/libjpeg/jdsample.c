begin_unit
begin_comment
comment|/*  * jdsample.c  *  * Copyright (C) 1991-1996, Thomas G. Lane.  * Modified 2002-2008 by Guido Vollbeding.  * This file is part of the Independent JPEG Group's software.  * For conditions of distribution and use, see the accompanying README file.  *  * This file contains upsampling routines.  *  * Upsampling input data is counted in "row groups".  A row group  * is defined to be (v_samp_factor * DCT_v_scaled_size / min_DCT_v_scaled_size)  * sample rows of each component.  Upsampling will normally produce  * max_v_samp_factor pixel rows from each row group (but this could vary  * if the upsampler is applying a scale factor of its own).  *  * An excellent reference for image resampling is  *   Digital Image Warping, George Wolberg, 1990.  *   Pub. by IEEE Computer Society Press, Los Alamitos, CA. ISBN 0-8186-8944-7.  */
end_comment
begin_define
DECL|macro|JPEG_INTERNALS
define|#
directive|define
name|JPEG_INTERNALS
end_define
begin_include
include|#
directive|include
file|"jinclude.h"
end_include
begin_include
include|#
directive|include
file|"jpeglib.h"
end_include
begin_comment
comment|/* Pointer to routine to upsample a single component */
end_comment
begin_typedef
DECL|typedef|JMETHOD
typedef|typedef
name|JMETHOD
argument_list|(
name|void
argument_list|,
name|upsample1_ptr
argument_list|,
operator|(
name|j_decompress_ptr
name|cinfo
operator|,
name|jpeg_component_info
operator|*
name|compptr
operator|,
name|JSAMPARRAY
name|input_data
operator|,
name|JSAMPARRAY
operator|*
name|output_data_ptr
operator|)
argument_list|)
expr_stmt|;
end_typedef
begin_comment
comment|/* Private subobject */
end_comment
begin_typedef
typedef|typedef
struct|struct
block|{
DECL|member|pub
name|struct
name|jpeg_upsampler
name|pub
decl_stmt|;
comment|/* public fields */
comment|/* Color conversion buffer.  When using separate upsampling and color    * conversion steps, this buffer holds one upsampled row group until it    * has been color converted and output.    * Note: we do not allocate any storage for component(s) which are full-size,    * ie do not need rescaling.  The corresponding entry of color_buf[] is    * simply set to point to the input data array, thereby avoiding copying.    */
DECL|member|color_buf
name|JSAMPARRAY
name|color_buf
index|[
name|MAX_COMPONENTS
index|]
decl_stmt|;
comment|/* Per-component upsampling method pointers */
DECL|member|methods
name|upsample1_ptr
name|methods
index|[
name|MAX_COMPONENTS
index|]
decl_stmt|;
DECL|member|next_row_out
name|int
name|next_row_out
decl_stmt|;
comment|/* counts rows emitted from color_buf */
DECL|member|rows_to_go
name|JDIMENSION
name|rows_to_go
decl_stmt|;
comment|/* counts rows remaining in image */
comment|/* Height of an input row group for each component. */
DECL|member|rowgroup_height
name|int
name|rowgroup_height
index|[
name|MAX_COMPONENTS
index|]
decl_stmt|;
comment|/* These arrays save pixel expansion factors so that int_expand need not    * recompute them each time.  They are unused for other upsampling methods.    */
DECL|member|h_expand
name|UINT8
name|h_expand
index|[
name|MAX_COMPONENTS
index|]
decl_stmt|;
DECL|member|v_expand
name|UINT8
name|v_expand
index|[
name|MAX_COMPONENTS
index|]
decl_stmt|;
block|}
DECL|typedef|my_upsampler
name|my_upsampler
typedef|;
end_typedef
begin_typedef
DECL|typedef|my_upsample_ptr
typedef|typedef
name|my_upsampler
modifier|*
name|my_upsample_ptr
typedef|;
end_typedef
begin_comment
comment|/*  * Initialize for an upsampling pass.  */
end_comment
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|start_pass_upsample
name|start_pass_upsample
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|)
end_macro
begin_block
block|{
name|my_upsample_ptr
name|upsample
init|=
operator|(
name|my_upsample_ptr
operator|)
name|cinfo
operator|->
name|upsample
decl_stmt|;
comment|/* Mark the conversion buffer empty */
name|upsample
operator|->
name|next_row_out
operator|=
name|cinfo
operator|->
name|max_v_samp_factor
expr_stmt|;
comment|/* Initialize total-height counter for detecting bottom of image */
name|upsample
operator|->
name|rows_to_go
operator|=
name|cinfo
operator|->
name|output_height
expr_stmt|;
block|}
end_block
begin_comment
comment|/*  * Control routine to do upsampling (and color conversion).  *  * In this version we upsample each component independently.  * We upsample one row group into the conversion buffer, then apply  * color conversion a row at a time.  */
end_comment
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|sep_upsample
name|sep_upsample
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|,
argument|JSAMPIMAGE input_buf
argument_list|,
argument|JDIMENSION *in_row_group_ctr
argument_list|,
argument|JDIMENSION in_row_groups_avail
argument_list|,
argument|JSAMPARRAY output_buf
argument_list|,
argument|JDIMENSION *out_row_ctr
argument_list|,
argument|JDIMENSION out_rows_avail
argument_list|)
end_macro
begin_block
block|{
name|my_upsample_ptr
name|upsample
init|=
operator|(
name|my_upsample_ptr
operator|)
name|cinfo
operator|->
name|upsample
decl_stmt|;
name|int
name|ci
decl_stmt|;
name|jpeg_component_info
modifier|*
name|compptr
decl_stmt|;
name|JDIMENSION
name|num_rows
decl_stmt|;
comment|/* Fill the conversion buffer, if it's empty */
if|if
condition|(
name|upsample
operator|->
name|next_row_out
operator|>=
name|cinfo
operator|->
name|max_v_samp_factor
condition|)
block|{
for|for
control|(
name|ci
operator|=
literal|0
operator|,
name|compptr
operator|=
name|cinfo
operator|->
name|comp_info
init|;
name|ci
operator|<
name|cinfo
operator|->
name|num_components
condition|;
name|ci
operator|++
operator|,
name|compptr
operator|++
control|)
block|{
comment|/* Invoke per-component upsample method.  Notice we pass a POINTER        * to color_buf[ci], so that fullsize_upsample can change it.        */
call|(
modifier|*
name|upsample
operator|->
name|methods
index|[
name|ci
index|]
call|)
argument_list|(
name|cinfo
argument_list|,
name|compptr
argument_list|,
name|input_buf
index|[
name|ci
index|]
operator|+
operator|(
operator|*
name|in_row_group_ctr
operator|*
name|upsample
operator|->
name|rowgroup_height
index|[
name|ci
index|]
operator|)
argument_list|,
name|upsample
operator|->
name|color_buf
operator|+
name|ci
argument_list|)
expr_stmt|;
block|}
name|upsample
operator|->
name|next_row_out
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Color-convert and emit rows */
comment|/* How many we have in the buffer: */
name|num_rows
operator|=
call|(
name|JDIMENSION
call|)
argument_list|(
name|cinfo
operator|->
name|max_v_samp_factor
operator|-
name|upsample
operator|->
name|next_row_out
argument_list|)
expr_stmt|;
comment|/* Not more than the distance to the end of the image.  Need this test    * in case the image height is not a multiple of max_v_samp_factor:    */
if|if
condition|(
name|num_rows
operator|>
name|upsample
operator|->
name|rows_to_go
condition|)
name|num_rows
operator|=
name|upsample
operator|->
name|rows_to_go
expr_stmt|;
comment|/* And not more than what the client can accept: */
name|out_rows_avail
operator|-=
operator|*
name|out_row_ctr
expr_stmt|;
if|if
condition|(
name|num_rows
operator|>
name|out_rows_avail
condition|)
name|num_rows
operator|=
name|out_rows_avail
expr_stmt|;
call|(
modifier|*
name|cinfo
operator|->
name|cconvert
operator|->
name|color_convert
call|)
argument_list|(
name|cinfo
argument_list|,
name|upsample
operator|->
name|color_buf
argument_list|,
operator|(
name|JDIMENSION
operator|)
name|upsample
operator|->
name|next_row_out
argument_list|,
name|output_buf
operator|+
operator|*
name|out_row_ctr
argument_list|,
operator|(
name|int
operator|)
name|num_rows
argument_list|)
expr_stmt|;
comment|/* Adjust counts */
operator|*
name|out_row_ctr
operator|+=
name|num_rows
expr_stmt|;
name|upsample
operator|->
name|rows_to_go
operator|-=
name|num_rows
expr_stmt|;
name|upsample
operator|->
name|next_row_out
operator|+=
name|num_rows
expr_stmt|;
comment|/* When the buffer is emptied, declare this input row group consumed */
if|if
condition|(
name|upsample
operator|->
name|next_row_out
operator|>=
name|cinfo
operator|->
name|max_v_samp_factor
condition|)
operator|(
operator|*
name|in_row_group_ctr
operator|)
operator|++
expr_stmt|;
block|}
end_block
begin_comment
comment|/*  * These are the routines invoked by sep_upsample to upsample pixel values  * of a single component.  One row group is processed per call.  */
end_comment
begin_comment
comment|/*  * For full-size components, we just make color_buf[ci] point at the  * input buffer, and thus avoid copying any data.  Note that this is  * safe only because sep_upsample doesn't declare the input row group  * "consumed" until we are done color converting and emitting it.  */
end_comment
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|fullsize_upsample
name|fullsize_upsample
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|,
argument|jpeg_component_info * compptr
argument_list|,
argument|JSAMPARRAY input_data
argument_list|,
argument|JSAMPARRAY * output_data_ptr
argument_list|)
end_macro
begin_block
block|{
operator|*
name|output_data_ptr
operator|=
name|input_data
expr_stmt|;
block|}
end_block
begin_comment
comment|/*  * This is a no-op version used for "uninteresting" components.  * These components will not be referenced by color conversion.  */
end_comment
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|noop_upsample
name|noop_upsample
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|,
argument|jpeg_component_info * compptr
argument_list|,
argument|JSAMPARRAY input_data
argument_list|,
argument|JSAMPARRAY * output_data_ptr
argument_list|)
end_macro
begin_block
block|{
operator|*
name|output_data_ptr
operator|=
name|NULL
expr_stmt|;
comment|/* safety check */
block|}
end_block
begin_comment
comment|/*  * This version handles any integral sampling ratios.  * This is not used for typical JPEG files, so it need not be fast.  * Nor, for that matter, is it particularly accurate: the algorithm is  * simple replication of the input pixel onto the corresponding output  * pixels.  The hi-falutin sampling literature refers to this as a  * "box filter".  A box filter tends to introduce visible artifacts,  * so if you are actually going to use 3:1 or 4:1 sampling ratios  * you would be well advised to improve this code.  */
end_comment
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|int_upsample
name|int_upsample
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|,
argument|jpeg_component_info * compptr
argument_list|,
argument|JSAMPARRAY input_data
argument_list|,
argument|JSAMPARRAY * output_data_ptr
argument_list|)
end_macro
begin_block
block|{
name|my_upsample_ptr
name|upsample
init|=
operator|(
name|my_upsample_ptr
operator|)
name|cinfo
operator|->
name|upsample
decl_stmt|;
name|JSAMPARRAY
name|output_data
init|=
operator|*
name|output_data_ptr
decl_stmt|;
specifier|register
name|JSAMPROW
name|inptr
decl_stmt|,
name|outptr
decl_stmt|;
specifier|register
name|JSAMPLE
name|invalue
decl_stmt|;
specifier|register
name|int
name|h
decl_stmt|;
name|JSAMPROW
name|outend
decl_stmt|;
name|int
name|h_expand
decl_stmt|,
name|v_expand
decl_stmt|;
name|int
name|inrow
decl_stmt|,
name|outrow
decl_stmt|;
name|h_expand
operator|=
name|upsample
operator|->
name|h_expand
index|[
name|compptr
operator|->
name|component_index
index|]
expr_stmt|;
name|v_expand
operator|=
name|upsample
operator|->
name|v_expand
index|[
name|compptr
operator|->
name|component_index
index|]
expr_stmt|;
name|inrow
operator|=
name|outrow
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|outrow
operator|<
name|cinfo
operator|->
name|max_v_samp_factor
condition|)
block|{
comment|/* Generate one output row with proper horizontal expansion */
name|inptr
operator|=
name|input_data
index|[
name|inrow
index|]
expr_stmt|;
name|outptr
operator|=
name|output_data
index|[
name|outrow
index|]
expr_stmt|;
name|outend
operator|=
name|outptr
operator|+
name|cinfo
operator|->
name|output_width
expr_stmt|;
while|while
condition|(
name|outptr
operator|<
name|outend
condition|)
block|{
name|invalue
operator|=
operator|*
name|inptr
operator|++
expr_stmt|;
comment|/* don't need GETJSAMPLE() here */
for|for
control|(
name|h
operator|=
name|h_expand
init|;
name|h
operator|>
literal|0
condition|;
name|h
operator|--
control|)
block|{
operator|*
name|outptr
operator|++
operator|=
name|invalue
expr_stmt|;
block|}
block|}
comment|/* Generate any additional output rows by duplicating the first one */
if|if
condition|(
name|v_expand
operator|>
literal|1
condition|)
block|{
name|jcopy_sample_rows
argument_list|(
name|output_data
argument_list|,
name|outrow
argument_list|,
name|output_data
argument_list|,
name|outrow
operator|+
literal|1
argument_list|,
name|v_expand
operator|-
literal|1
argument_list|,
name|cinfo
operator|->
name|output_width
argument_list|)
expr_stmt|;
block|}
name|inrow
operator|++
expr_stmt|;
name|outrow
operator|+=
name|v_expand
expr_stmt|;
block|}
block|}
end_block
begin_comment
comment|/*  * Fast processing for the common case of 2:1 horizontal and 1:1 vertical.  * It's still a box filter.  */
end_comment
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|h2v1_upsample
name|h2v1_upsample
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|,
argument|jpeg_component_info * compptr
argument_list|,
argument|JSAMPARRAY input_data
argument_list|,
argument|JSAMPARRAY * output_data_ptr
argument_list|)
end_macro
begin_block
block|{
name|JSAMPARRAY
name|output_data
init|=
operator|*
name|output_data_ptr
decl_stmt|;
specifier|register
name|JSAMPROW
name|inptr
decl_stmt|,
name|outptr
decl_stmt|;
specifier|register
name|JSAMPLE
name|invalue
decl_stmt|;
name|JSAMPROW
name|outend
decl_stmt|;
name|int
name|outrow
decl_stmt|;
for|for
control|(
name|outrow
operator|=
literal|0
init|;
name|outrow
operator|<
name|cinfo
operator|->
name|max_v_samp_factor
condition|;
name|outrow
operator|++
control|)
block|{
name|inptr
operator|=
name|input_data
index|[
name|outrow
index|]
expr_stmt|;
name|outptr
operator|=
name|output_data
index|[
name|outrow
index|]
expr_stmt|;
name|outend
operator|=
name|outptr
operator|+
name|cinfo
operator|->
name|output_width
expr_stmt|;
while|while
condition|(
name|outptr
operator|<
name|outend
condition|)
block|{
name|invalue
operator|=
operator|*
name|inptr
operator|++
expr_stmt|;
comment|/* don't need GETJSAMPLE() here */
operator|*
name|outptr
operator|++
operator|=
name|invalue
expr_stmt|;
operator|*
name|outptr
operator|++
operator|=
name|invalue
expr_stmt|;
block|}
block|}
block|}
end_block
begin_comment
comment|/*  * Fast processing for the common case of 2:1 horizontal and 2:1 vertical.  * It's still a box filter.  */
end_comment
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|h2v2_upsample
name|h2v2_upsample
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|,
argument|jpeg_component_info * compptr
argument_list|,
argument|JSAMPARRAY input_data
argument_list|,
argument|JSAMPARRAY * output_data_ptr
argument_list|)
end_macro
begin_block
block|{
name|JSAMPARRAY
name|output_data
init|=
operator|*
name|output_data_ptr
decl_stmt|;
specifier|register
name|JSAMPROW
name|inptr
decl_stmt|,
name|outptr
decl_stmt|;
specifier|register
name|JSAMPLE
name|invalue
decl_stmt|;
name|JSAMPROW
name|outend
decl_stmt|;
name|int
name|inrow
decl_stmt|,
name|outrow
decl_stmt|;
name|inrow
operator|=
name|outrow
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|outrow
operator|<
name|cinfo
operator|->
name|max_v_samp_factor
condition|)
block|{
name|inptr
operator|=
name|input_data
index|[
name|inrow
index|]
expr_stmt|;
name|outptr
operator|=
name|output_data
index|[
name|outrow
index|]
expr_stmt|;
name|outend
operator|=
name|outptr
operator|+
name|cinfo
operator|->
name|output_width
expr_stmt|;
while|while
condition|(
name|outptr
operator|<
name|outend
condition|)
block|{
name|invalue
operator|=
operator|*
name|inptr
operator|++
expr_stmt|;
comment|/* don't need GETJSAMPLE() here */
operator|*
name|outptr
operator|++
operator|=
name|invalue
expr_stmt|;
operator|*
name|outptr
operator|++
operator|=
name|invalue
expr_stmt|;
block|}
name|jcopy_sample_rows
argument_list|(
name|output_data
argument_list|,
name|outrow
argument_list|,
name|output_data
argument_list|,
name|outrow
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
name|cinfo
operator|->
name|output_width
argument_list|)
expr_stmt|;
name|inrow
operator|++
expr_stmt|;
name|outrow
operator|+=
literal|2
expr_stmt|;
block|}
block|}
end_block
begin_comment
comment|/*  * Module initialization routine for upsampling.  */
end_comment
begin_macro
name|GLOBAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|jinit_upsampler
name|jinit_upsampler
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|)
end_macro
begin_block
block|{
name|my_upsample_ptr
name|upsample
decl_stmt|;
name|int
name|ci
decl_stmt|;
name|jpeg_component_info
modifier|*
name|compptr
decl_stmt|;
name|boolean
name|need_buffer
decl_stmt|;
name|int
name|h_in_group
decl_stmt|,
name|v_in_group
decl_stmt|,
name|h_out_group
decl_stmt|,
name|v_out_group
decl_stmt|;
name|upsample
operator|=
call|(
name|my_upsample_ptr
call|)
argument_list|(
operator|*
name|cinfo
operator|->
name|mem
operator|->
name|alloc_small
argument_list|)
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|,
name|JPOOL_IMAGE
argument_list|,
name|SIZEOF
argument_list|(
name|my_upsampler
argument_list|)
argument_list|)
expr_stmt|;
name|cinfo
operator|->
name|upsample
operator|=
operator|(
expr|struct
name|jpeg_upsampler
operator|*
operator|)
name|upsample
expr_stmt|;
name|upsample
operator|->
name|pub
operator|.
name|start_pass
operator|=
name|start_pass_upsample
expr_stmt|;
name|upsample
operator|->
name|pub
operator|.
name|upsample
operator|=
name|sep_upsample
expr_stmt|;
name|upsample
operator|->
name|pub
operator|.
name|need_context_rows
operator|=
name|FALSE
expr_stmt|;
comment|/* until we find out differently */
if|if
condition|(
name|cinfo
operator|->
name|CCIR601_sampling
condition|)
comment|/* this isn't supported */
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_CCIR601_NOTIMPL
argument_list|)
expr_stmt|;
comment|/* Verify we can handle the sampling factors, select per-component methods,    * and create storage as needed.    */
for|for
control|(
name|ci
operator|=
literal|0
operator|,
name|compptr
operator|=
name|cinfo
operator|->
name|comp_info
init|;
name|ci
operator|<
name|cinfo
operator|->
name|num_components
condition|;
name|ci
operator|++
operator|,
name|compptr
operator|++
control|)
block|{
comment|/* Compute size of an "input group" after IDCT scaling.  This many samples      * are to be converted to max_h_samp_factor * max_v_samp_factor pixels.      */
name|h_in_group
operator|=
operator|(
name|compptr
operator|->
name|h_samp_factor
operator|*
name|compptr
operator|->
name|DCT_h_scaled_size
operator|)
operator|/
name|cinfo
operator|->
name|min_DCT_h_scaled_size
expr_stmt|;
name|v_in_group
operator|=
operator|(
name|compptr
operator|->
name|v_samp_factor
operator|*
name|compptr
operator|->
name|DCT_v_scaled_size
operator|)
operator|/
name|cinfo
operator|->
name|min_DCT_v_scaled_size
expr_stmt|;
name|h_out_group
operator|=
name|cinfo
operator|->
name|max_h_samp_factor
expr_stmt|;
name|v_out_group
operator|=
name|cinfo
operator|->
name|max_v_samp_factor
expr_stmt|;
name|upsample
operator|->
name|rowgroup_height
index|[
name|ci
index|]
operator|=
name|v_in_group
expr_stmt|;
comment|/* save for use later */
name|need_buffer
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|compptr
operator|->
name|component_needed
condition|)
block|{
comment|/* Don't bother to upsample an uninteresting component. */
name|upsample
operator|->
name|methods
index|[
name|ci
index|]
operator|=
name|noop_upsample
expr_stmt|;
name|need_buffer
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|h_in_group
operator|==
name|h_out_group
operator|&&
name|v_in_group
operator|==
name|v_out_group
condition|)
block|{
comment|/* Fullsize components can be processed without any work. */
name|upsample
operator|->
name|methods
index|[
name|ci
index|]
operator|=
name|fullsize_upsample
expr_stmt|;
name|need_buffer
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|h_in_group
operator|*
literal|2
operator|==
name|h_out_group
operator|&&
name|v_in_group
operator|==
name|v_out_group
condition|)
block|{
comment|/* Special case for 2h1v upsampling */
name|upsample
operator|->
name|methods
index|[
name|ci
index|]
operator|=
name|h2v1_upsample
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|h_in_group
operator|*
literal|2
operator|==
name|h_out_group
operator|&&
name|v_in_group
operator|*
literal|2
operator|==
name|v_out_group
condition|)
block|{
comment|/* Special case for 2h2v upsampling */
name|upsample
operator|->
name|methods
index|[
name|ci
index|]
operator|=
name|h2v2_upsample
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|h_out_group
operator|%
name|h_in_group
operator|)
operator|==
literal|0
operator|&&
operator|(
name|v_out_group
operator|%
name|v_in_group
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Generic integral-factors upsampling method */
name|upsample
operator|->
name|methods
index|[
name|ci
index|]
operator|=
name|int_upsample
expr_stmt|;
name|upsample
operator|->
name|h_expand
index|[
name|ci
index|]
operator|=
call|(
name|UINT8
call|)
argument_list|(
name|h_out_group
operator|/
name|h_in_group
argument_list|)
expr_stmt|;
name|upsample
operator|->
name|v_expand
index|[
name|ci
index|]
operator|=
call|(
name|UINT8
call|)
argument_list|(
name|v_out_group
operator|/
name|v_in_group
argument_list|)
expr_stmt|;
block|}
else|else
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_FRACT_SAMPLE_NOTIMPL
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_buffer
condition|)
block|{
name|upsample
operator|->
name|color_buf
index|[
name|ci
index|]
operator|=
call|(
modifier|*
name|cinfo
operator|->
name|mem
operator|->
name|alloc_sarray
call|)
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|,
name|JPOOL_IMAGE
argument_list|,
operator|(
name|JDIMENSION
operator|)
name|jround_up
argument_list|(
operator|(
name|long
operator|)
name|cinfo
operator|->
name|output_width
argument_list|,
operator|(
name|long
operator|)
name|cinfo
operator|->
name|max_h_samp_factor
argument_list|)
argument_list|,
operator|(
name|JDIMENSION
operator|)
name|cinfo
operator|->
name|max_v_samp_factor
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block
end_unit
