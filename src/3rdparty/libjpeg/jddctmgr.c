begin_unit
begin_comment
comment|/*  * jddctmgr.c  *  * Copyright (C) 1994-1996, Thomas G. Lane.  * Modified 2002-2010 by Guido Vollbeding.  * This file is part of the Independent JPEG Group's software.  * For conditions of distribution and use, see the accompanying README file.  *  * This file contains the inverse-DCT management logic.  * This code selects a particular IDCT implementation to be used,  * and it performs related housekeeping chores.  No code in this file  * is executed per IDCT step, only during output pass setup.  *  * Note that the IDCT routines are responsible for performing coefficient  * dequantization as well as the IDCT proper.  This module sets up the  * dequantization multiplier table needed by the IDCT routine.  */
end_comment
begin_define
DECL|macro|JPEG_INTERNALS
define|#
directive|define
name|JPEG_INTERNALS
end_define
begin_include
include|#
directive|include
file|"jinclude.h"
end_include
begin_include
include|#
directive|include
file|"jpeglib.h"
end_include
begin_include
include|#
directive|include
file|"jdct.h"
end_include
begin_comment
comment|/* Private declarations for DCT subsystem */
end_comment
begin_comment
comment|/*  * The decompressor input side (jdinput.c) saves away the appropriate  * quantization table for each component at the start of the first scan  * involving that component.  (This is necessary in order to correctly  * decode files that reuse Q-table slots.)  * When we are ready to make an output pass, the saved Q-table is converted  * to a multiplier table that will actually be used by the IDCT routine.  * The multiplier table contents are IDCT-method-dependent.  To support  * application changes in IDCT method between scans, we can remake the  * multiplier tables if necessary.  * In buffered-image mode, the first output pass may occur before any data  * has been seen for some components, and thus before their Q-tables have  * been saved away.  To handle this case, multiplier tables are preset  * to zeroes; the result of the IDCT will be a neutral gray level.  */
end_comment
begin_comment
comment|/* Private subobject for this module */
end_comment
begin_typedef
typedef|typedef
struct|struct
block|{
DECL|member|pub
name|struct
name|jpeg_inverse_dct
name|pub
decl_stmt|;
comment|/* public fields */
comment|/* This array contains the IDCT method code that each multiplier table    * is currently set up for, or -1 if it's not yet set up.    * The actual multiplier tables are pointed to by dct_table in the    * per-component comp_info structures.    */
DECL|member|cur_method
name|int
name|cur_method
index|[
name|MAX_COMPONENTS
index|]
decl_stmt|;
block|}
DECL|typedef|my_idct_controller
name|my_idct_controller
typedef|;
end_typedef
begin_typedef
DECL|typedef|my_idct_ptr
typedef|typedef
name|my_idct_controller
modifier|*
name|my_idct_ptr
typedef|;
end_typedef
begin_comment
comment|/* Allocated multiplier tables: big enough for any supported variant */
end_comment
begin_typedef
typedef|typedef
union|union
block|{
DECL|member|islow_array
name|ISLOW_MULT_TYPE
name|islow_array
index|[
name|DCTSIZE2
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|DCT_IFAST_SUPPORTED
DECL|member|ifast_array
name|IFAST_MULT_TYPE
name|ifast_array
index|[
name|DCTSIZE2
index|]
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DCT_FLOAT_SUPPORTED
DECL|member|float_array
name|FLOAT_MULT_TYPE
name|float_array
index|[
name|DCTSIZE2
index|]
decl_stmt|;
endif|#
directive|endif
block|}
DECL|typedef|multiplier_table
name|multiplier_table
typedef|;
end_typedef
begin_comment
comment|/* The current scaled-IDCT routines require ISLOW-style multiplier tables,  * so be sure to compile that code if either ISLOW or SCALING is requested.  */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|DCT_ISLOW_SUPPORTED
end_ifdef
begin_define
DECL|macro|PROVIDE_ISLOW_TABLES
define|#
directive|define
name|PROVIDE_ISLOW_TABLES
end_define
begin_else
else|#
directive|else
end_else
begin_ifdef
ifdef|#
directive|ifdef
name|IDCT_SCALING_SUPPORTED
end_ifdef
begin_define
DECL|macro|PROVIDE_ISLOW_TABLES
define|#
directive|define
name|PROVIDE_ISLOW_TABLES
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*  * Prepare for an output pass.  * Here we select the proper IDCT routine for each component and build  * a matching multiplier table.  */
end_comment
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|start_pass
name|start_pass
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|)
end_macro
begin_block
block|{
name|my_idct_ptr
name|idct
init|=
operator|(
name|my_idct_ptr
operator|)
name|cinfo
operator|->
name|idct
decl_stmt|;
name|int
name|ci
decl_stmt|,
name|i
decl_stmt|;
name|jpeg_component_info
modifier|*
name|compptr
decl_stmt|;
name|int
name|method
init|=
literal|0
decl_stmt|;
name|inverse_DCT_method_ptr
name|method_ptr
init|=
name|NULL
decl_stmt|;
name|JQUANT_TBL
modifier|*
name|qtbl
decl_stmt|;
for|for
control|(
name|ci
operator|=
literal|0
operator|,
name|compptr
operator|=
name|cinfo
operator|->
name|comp_info
init|;
name|ci
operator|<
name|cinfo
operator|->
name|num_components
condition|;
name|ci
operator|++
operator|,
name|compptr
operator|++
control|)
block|{
comment|/* Select the proper IDCT routine for this component's scaling */
switch|switch
condition|(
operator|(
name|compptr
operator|->
name|DCT_h_scaled_size
operator|<<
literal|8
operator|)
operator|+
name|compptr
operator|->
name|DCT_v_scaled_size
condition|)
block|{
ifdef|#
directive|ifdef
name|IDCT_SCALING_SUPPORTED
case|case
operator|(
operator|(
literal|1
operator|<<
literal|8
operator|)
operator|+
literal|1
operator|)
case|:
name|method_ptr
operator|=
name|jpeg_idct_1x1
expr_stmt|;
name|method
operator|=
name|JDCT_ISLOW
expr_stmt|;
comment|/* jidctint uses islow-style table */
break|break;
case|case
operator|(
operator|(
literal|2
operator|<<
literal|8
operator|)
operator|+
literal|2
operator|)
case|:
name|method_ptr
operator|=
name|jpeg_idct_2x2
expr_stmt|;
name|method
operator|=
name|JDCT_ISLOW
expr_stmt|;
comment|/* jidctint uses islow-style table */
break|break;
case|case
operator|(
operator|(
literal|3
operator|<<
literal|8
operator|)
operator|+
literal|3
operator|)
case|:
name|method_ptr
operator|=
name|jpeg_idct_3x3
expr_stmt|;
name|method
operator|=
name|JDCT_ISLOW
expr_stmt|;
comment|/* jidctint uses islow-style table */
break|break;
case|case
operator|(
operator|(
literal|4
operator|<<
literal|8
operator|)
operator|+
literal|4
operator|)
case|:
name|method_ptr
operator|=
name|jpeg_idct_4x4
expr_stmt|;
name|method
operator|=
name|JDCT_ISLOW
expr_stmt|;
comment|/* jidctint uses islow-style table */
break|break;
case|case
operator|(
operator|(
literal|5
operator|<<
literal|8
operator|)
operator|+
literal|5
operator|)
case|:
name|method_ptr
operator|=
name|jpeg_idct_5x5
expr_stmt|;
name|method
operator|=
name|JDCT_ISLOW
expr_stmt|;
comment|/* jidctint uses islow-style table */
break|break;
case|case
operator|(
operator|(
literal|6
operator|<<
literal|8
operator|)
operator|+
literal|6
operator|)
case|:
name|method_ptr
operator|=
name|jpeg_idct_6x6
expr_stmt|;
name|method
operator|=
name|JDCT_ISLOW
expr_stmt|;
comment|/* jidctint uses islow-style table */
break|break;
case|case
operator|(
operator|(
literal|7
operator|<<
literal|8
operator|)
operator|+
literal|7
operator|)
case|:
name|method_ptr
operator|=
name|jpeg_idct_7x7
expr_stmt|;
name|method
operator|=
name|JDCT_ISLOW
expr_stmt|;
comment|/* jidctint uses islow-style table */
break|break;
case|case
operator|(
operator|(
literal|9
operator|<<
literal|8
operator|)
operator|+
literal|9
operator|)
case|:
name|method_ptr
operator|=
name|jpeg_idct_9x9
expr_stmt|;
name|method
operator|=
name|JDCT_ISLOW
expr_stmt|;
comment|/* jidctint uses islow-style table */
break|break;
case|case
operator|(
operator|(
literal|10
operator|<<
literal|8
operator|)
operator|+
literal|10
operator|)
case|:
name|method_ptr
operator|=
name|jpeg_idct_10x10
expr_stmt|;
name|method
operator|=
name|JDCT_ISLOW
expr_stmt|;
comment|/* jidctint uses islow-style table */
break|break;
case|case
operator|(
operator|(
literal|11
operator|<<
literal|8
operator|)
operator|+
literal|11
operator|)
case|:
name|method_ptr
operator|=
name|jpeg_idct_11x11
expr_stmt|;
name|method
operator|=
name|JDCT_ISLOW
expr_stmt|;
comment|/* jidctint uses islow-style table */
break|break;
case|case
operator|(
operator|(
literal|12
operator|<<
literal|8
operator|)
operator|+
literal|12
operator|)
case|:
name|method_ptr
operator|=
name|jpeg_idct_12x12
expr_stmt|;
name|method
operator|=
name|JDCT_ISLOW
expr_stmt|;
comment|/* jidctint uses islow-style table */
break|break;
case|case
operator|(
operator|(
literal|13
operator|<<
literal|8
operator|)
operator|+
literal|13
operator|)
case|:
name|method_ptr
operator|=
name|jpeg_idct_13x13
expr_stmt|;
name|method
operator|=
name|JDCT_ISLOW
expr_stmt|;
comment|/* jidctint uses islow-style table */
break|break;
case|case
operator|(
operator|(
literal|14
operator|<<
literal|8
operator|)
operator|+
literal|14
operator|)
case|:
name|method_ptr
operator|=
name|jpeg_idct_14x14
expr_stmt|;
name|method
operator|=
name|JDCT_ISLOW
expr_stmt|;
comment|/* jidctint uses islow-style table */
break|break;
case|case
operator|(
operator|(
literal|15
operator|<<
literal|8
operator|)
operator|+
literal|15
operator|)
case|:
name|method_ptr
operator|=
name|jpeg_idct_15x15
expr_stmt|;
name|method
operator|=
name|JDCT_ISLOW
expr_stmt|;
comment|/* jidctint uses islow-style table */
break|break;
case|case
operator|(
operator|(
literal|16
operator|<<
literal|8
operator|)
operator|+
literal|16
operator|)
case|:
name|method_ptr
operator|=
name|jpeg_idct_16x16
expr_stmt|;
name|method
operator|=
name|JDCT_ISLOW
expr_stmt|;
comment|/* jidctint uses islow-style table */
break|break;
case|case
operator|(
operator|(
literal|16
operator|<<
literal|8
operator|)
operator|+
literal|8
operator|)
case|:
name|method_ptr
operator|=
name|jpeg_idct_16x8
expr_stmt|;
name|method
operator|=
name|JDCT_ISLOW
expr_stmt|;
comment|/* jidctint uses islow-style table */
break|break;
case|case
operator|(
operator|(
literal|14
operator|<<
literal|8
operator|)
operator|+
literal|7
operator|)
case|:
name|method_ptr
operator|=
name|jpeg_idct_14x7
expr_stmt|;
name|method
operator|=
name|JDCT_ISLOW
expr_stmt|;
comment|/* jidctint uses islow-style table */
break|break;
case|case
operator|(
operator|(
literal|12
operator|<<
literal|8
operator|)
operator|+
literal|6
operator|)
case|:
name|method_ptr
operator|=
name|jpeg_idct_12x6
expr_stmt|;
name|method
operator|=
name|JDCT_ISLOW
expr_stmt|;
comment|/* jidctint uses islow-style table */
break|break;
case|case
operator|(
operator|(
literal|10
operator|<<
literal|8
operator|)
operator|+
literal|5
operator|)
case|:
name|method_ptr
operator|=
name|jpeg_idct_10x5
expr_stmt|;
name|method
operator|=
name|JDCT_ISLOW
expr_stmt|;
comment|/* jidctint uses islow-style table */
break|break;
case|case
operator|(
operator|(
literal|8
operator|<<
literal|8
operator|)
operator|+
literal|4
operator|)
case|:
name|method_ptr
operator|=
name|jpeg_idct_8x4
expr_stmt|;
name|method
operator|=
name|JDCT_ISLOW
expr_stmt|;
comment|/* jidctint uses islow-style table */
break|break;
case|case
operator|(
operator|(
literal|6
operator|<<
literal|8
operator|)
operator|+
literal|3
operator|)
case|:
name|method_ptr
operator|=
name|jpeg_idct_6x3
expr_stmt|;
name|method
operator|=
name|JDCT_ISLOW
expr_stmt|;
comment|/* jidctint uses islow-style table */
break|break;
case|case
operator|(
operator|(
literal|4
operator|<<
literal|8
operator|)
operator|+
literal|2
operator|)
case|:
name|method_ptr
operator|=
name|jpeg_idct_4x2
expr_stmt|;
name|method
operator|=
name|JDCT_ISLOW
expr_stmt|;
comment|/* jidctint uses islow-style table */
break|break;
case|case
operator|(
operator|(
literal|2
operator|<<
literal|8
operator|)
operator|+
literal|1
operator|)
case|:
name|method_ptr
operator|=
name|jpeg_idct_2x1
expr_stmt|;
name|method
operator|=
name|JDCT_ISLOW
expr_stmt|;
comment|/* jidctint uses islow-style table */
break|break;
case|case
operator|(
operator|(
literal|8
operator|<<
literal|8
operator|)
operator|+
literal|16
operator|)
case|:
name|method_ptr
operator|=
name|jpeg_idct_8x16
expr_stmt|;
name|method
operator|=
name|JDCT_ISLOW
expr_stmt|;
comment|/* jidctint uses islow-style table */
break|break;
case|case
operator|(
operator|(
literal|7
operator|<<
literal|8
operator|)
operator|+
literal|14
operator|)
case|:
name|method_ptr
operator|=
name|jpeg_idct_7x14
expr_stmt|;
name|method
operator|=
name|JDCT_ISLOW
expr_stmt|;
comment|/* jidctint uses islow-style table */
break|break;
case|case
operator|(
operator|(
literal|6
operator|<<
literal|8
operator|)
operator|+
literal|12
operator|)
case|:
name|method_ptr
operator|=
name|jpeg_idct_6x12
expr_stmt|;
name|method
operator|=
name|JDCT_ISLOW
expr_stmt|;
comment|/* jidctint uses islow-style table */
break|break;
case|case
operator|(
operator|(
literal|5
operator|<<
literal|8
operator|)
operator|+
literal|10
operator|)
case|:
name|method_ptr
operator|=
name|jpeg_idct_5x10
expr_stmt|;
name|method
operator|=
name|JDCT_ISLOW
expr_stmt|;
comment|/* jidctint uses islow-style table */
break|break;
case|case
operator|(
operator|(
literal|4
operator|<<
literal|8
operator|)
operator|+
literal|8
operator|)
case|:
name|method_ptr
operator|=
name|jpeg_idct_4x8
expr_stmt|;
name|method
operator|=
name|JDCT_ISLOW
expr_stmt|;
comment|/* jidctint uses islow-style table */
break|break;
case|case
operator|(
operator|(
literal|3
operator|<<
literal|8
operator|)
operator|+
literal|6
operator|)
case|:
name|method_ptr
operator|=
name|jpeg_idct_3x6
expr_stmt|;
name|method
operator|=
name|JDCT_ISLOW
expr_stmt|;
comment|/* jidctint uses islow-style table */
break|break;
case|case
operator|(
operator|(
literal|2
operator|<<
literal|8
operator|)
operator|+
literal|4
operator|)
case|:
name|method_ptr
operator|=
name|jpeg_idct_2x4
expr_stmt|;
name|method
operator|=
name|JDCT_ISLOW
expr_stmt|;
comment|/* jidctint uses islow-style table */
break|break;
case|case
operator|(
operator|(
literal|1
operator|<<
literal|8
operator|)
operator|+
literal|2
operator|)
case|:
name|method_ptr
operator|=
name|jpeg_idct_1x2
expr_stmt|;
name|method
operator|=
name|JDCT_ISLOW
expr_stmt|;
comment|/* jidctint uses islow-style table */
break|break;
endif|#
directive|endif
case|case
operator|(
operator|(
name|DCTSIZE
operator|<<
literal|8
operator|)
operator|+
name|DCTSIZE
operator|)
case|:
switch|switch
condition|(
name|cinfo
operator|->
name|dct_method
condition|)
block|{
ifdef|#
directive|ifdef
name|DCT_ISLOW_SUPPORTED
case|case
name|JDCT_ISLOW
case|:
name|method_ptr
operator|=
name|jpeg_idct_islow
expr_stmt|;
name|method
operator|=
name|JDCT_ISLOW
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DCT_IFAST_SUPPORTED
case|case
name|JDCT_IFAST
case|:
name|method_ptr
operator|=
name|jpeg_idct_ifast
expr_stmt|;
name|method
operator|=
name|JDCT_IFAST
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DCT_FLOAT_SUPPORTED
case|case
name|JDCT_FLOAT
case|:
name|method_ptr
operator|=
name|jpeg_idct_float
expr_stmt|;
name|method
operator|=
name|JDCT_FLOAT
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_NOT_COMPILED
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|ERREXIT2
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_DCTSIZE
argument_list|,
name|compptr
operator|->
name|DCT_h_scaled_size
argument_list|,
name|compptr
operator|->
name|DCT_v_scaled_size
argument_list|)
expr_stmt|;
break|break;
block|}
name|idct
operator|->
name|pub
operator|.
name|inverse_DCT
index|[
name|ci
index|]
operator|=
name|method_ptr
expr_stmt|;
comment|/* Create multiplier table from quant table.      * However, we can skip this if the component is uninteresting      * or if we already built the table.  Also, if no quant table      * has yet been saved for the component, we leave the      * multiplier table all-zero; we'll be reading zeroes from the      * coefficient controller's buffer anyway.      */
if|if
condition|(
operator|!
name|compptr
operator|->
name|component_needed
operator|||
name|idct
operator|->
name|cur_method
index|[
name|ci
index|]
operator|==
name|method
condition|)
continue|continue;
name|qtbl
operator|=
name|compptr
operator|->
name|quant_table
expr_stmt|;
if|if
condition|(
name|qtbl
operator|==
name|NULL
condition|)
comment|/* happens if no data yet for component */
continue|continue;
name|idct
operator|->
name|cur_method
index|[
name|ci
index|]
operator|=
name|method
expr_stmt|;
switch|switch
condition|(
name|method
condition|)
block|{
ifdef|#
directive|ifdef
name|PROVIDE_ISLOW_TABLES
case|case
name|JDCT_ISLOW
case|:
block|{
comment|/* For LL&M IDCT method, multipliers are equal to raw quantization 	 * coefficients, but are stored as ints to ensure access efficiency. 	 */
name|ISLOW_MULT_TYPE
modifier|*
name|ismtbl
init|=
operator|(
name|ISLOW_MULT_TYPE
operator|*
operator|)
name|compptr
operator|->
name|dct_table
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DCTSIZE2
condition|;
name|i
operator|++
control|)
block|{
name|ismtbl
index|[
name|i
index|]
operator|=
operator|(
name|ISLOW_MULT_TYPE
operator|)
name|qtbl
operator|->
name|quantval
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DCT_IFAST_SUPPORTED
case|case
name|JDCT_IFAST
case|:
block|{
comment|/* For AA&N IDCT method, multipliers are equal to quantization 	 * coefficients scaled by scalefactor[row]*scalefactor[col], where 	 *   scalefactor[0] = 1 	 *   scalefactor[k] = cos(k*PI/16) * sqrt(2)    for k=1..7 	 * For integer operation, the multiplier table is to be scaled by 	 * IFAST_SCALE_BITS. 	 */
name|IFAST_MULT_TYPE
modifier|*
name|ifmtbl
init|=
operator|(
name|IFAST_MULT_TYPE
operator|*
operator|)
name|compptr
operator|->
name|dct_table
decl_stmt|;
DECL|macro|CONST_BITS
define|#
directive|define
name|CONST_BITS
value|14
specifier|static
specifier|const
name|INT16
name|aanscales
index|[
name|DCTSIZE2
index|]
init|=
block|{
comment|/* precomputed values scaled up by 14 bits */
literal|16384
block|,
literal|22725
block|,
literal|21407
block|,
literal|19266
block|,
literal|16384
block|,
literal|12873
block|,
literal|8867
block|,
literal|4520
block|,
literal|22725
block|,
literal|31521
block|,
literal|29692
block|,
literal|26722
block|,
literal|22725
block|,
literal|17855
block|,
literal|12299
block|,
literal|6270
block|,
literal|21407
block|,
literal|29692
block|,
literal|27969
block|,
literal|25172
block|,
literal|21407
block|,
literal|16819
block|,
literal|11585
block|,
literal|5906
block|,
literal|19266
block|,
literal|26722
block|,
literal|25172
block|,
literal|22654
block|,
literal|19266
block|,
literal|15137
block|,
literal|10426
block|,
literal|5315
block|,
literal|16384
block|,
literal|22725
block|,
literal|21407
block|,
literal|19266
block|,
literal|16384
block|,
literal|12873
block|,
literal|8867
block|,
literal|4520
block|,
literal|12873
block|,
literal|17855
block|,
literal|16819
block|,
literal|15137
block|,
literal|12873
block|,
literal|10114
block|,
literal|6967
block|,
literal|3552
block|,
literal|8867
block|,
literal|12299
block|,
literal|11585
block|,
literal|10426
block|,
literal|8867
block|,
literal|6967
block|,
literal|4799
block|,
literal|2446
block|,
literal|4520
block|,
literal|6270
block|,
literal|5906
block|,
literal|5315
block|,
literal|4520
block|,
literal|3552
block|,
literal|2446
block|,
literal|1247
block|}
decl_stmt|;
name|SHIFT_TEMPS
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DCTSIZE2
condition|;
name|i
operator|++
control|)
block|{
name|ifmtbl
index|[
name|i
index|]
operator|=
operator|(
name|IFAST_MULT_TYPE
operator|)
name|DESCALE
argument_list|(
name|MULTIPLY16V16
argument_list|(
operator|(
name|INT32
operator|)
name|qtbl
operator|->
name|quantval
index|[
name|i
index|]
argument_list|,
operator|(
name|INT32
operator|)
name|aanscales
index|[
name|i
index|]
argument_list|)
argument_list|,
name|CONST_BITS
operator|-
name|IFAST_SCALE_BITS
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DCT_FLOAT_SUPPORTED
case|case
name|JDCT_FLOAT
case|:
block|{
comment|/* For float AA&N IDCT method, multipliers are equal to quantization 	 * coefficients scaled by scalefactor[row]*scalefactor[col], where 	 *   scalefactor[0] = 1 	 *   scalefactor[k] = cos(k*PI/16) * sqrt(2)    for k=1..7 	 * We apply a further scale factor of 1/8. 	 */
name|FLOAT_MULT_TYPE
modifier|*
name|fmtbl
init|=
operator|(
name|FLOAT_MULT_TYPE
operator|*
operator|)
name|compptr
operator|->
name|dct_table
decl_stmt|;
name|int
name|row
decl_stmt|,
name|col
decl_stmt|;
specifier|static
specifier|const
name|double
name|aanscalefactor
index|[
name|DCTSIZE
index|]
init|=
block|{
literal|1.0
block|,
literal|1.387039845
block|,
literal|1.306562965
block|,
literal|1.175875602
block|,
literal|1.0
block|,
literal|0.785694958
block|,
literal|0.541196100
block|,
literal|0.275899379
block|}
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|row
operator|=
literal|0
init|;
name|row
operator|<
name|DCTSIZE
condition|;
name|row
operator|++
control|)
block|{
for|for
control|(
name|col
operator|=
literal|0
init|;
name|col
operator|<
name|DCTSIZE
condition|;
name|col
operator|++
control|)
block|{
name|fmtbl
index|[
name|i
index|]
operator|=
call|(
name|FLOAT_MULT_TYPE
call|)
argument_list|(
operator|(
name|double
operator|)
name|qtbl
operator|->
name|quantval
index|[
name|i
index|]
operator|*
name|aanscalefactor
index|[
name|row
index|]
operator|*
name|aanscalefactor
index|[
name|col
index|]
operator|*
literal|0.125
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
block|}
break|break;
endif|#
directive|endif
default|default:
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_NOT_COMPILED
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_block
begin_comment
comment|/*  * Initialize IDCT manager.  */
end_comment
begin_macro
name|GLOBAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|jinit_inverse_dct
name|jinit_inverse_dct
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|)
end_macro
begin_block
block|{
name|my_idct_ptr
name|idct
decl_stmt|;
name|int
name|ci
decl_stmt|;
name|jpeg_component_info
modifier|*
name|compptr
decl_stmt|;
name|idct
operator|=
call|(
name|my_idct_ptr
call|)
argument_list|(
operator|*
name|cinfo
operator|->
name|mem
operator|->
name|alloc_small
argument_list|)
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|,
name|JPOOL_IMAGE
argument_list|,
name|SIZEOF
argument_list|(
name|my_idct_controller
argument_list|)
argument_list|)
expr_stmt|;
name|cinfo
operator|->
name|idct
operator|=
operator|(
expr|struct
name|jpeg_inverse_dct
operator|*
operator|)
name|idct
expr_stmt|;
name|idct
operator|->
name|pub
operator|.
name|start_pass
operator|=
name|start_pass
expr_stmt|;
for|for
control|(
name|ci
operator|=
literal|0
operator|,
name|compptr
operator|=
name|cinfo
operator|->
name|comp_info
init|;
name|ci
operator|<
name|cinfo
operator|->
name|num_components
condition|;
name|ci
operator|++
operator|,
name|compptr
operator|++
control|)
block|{
comment|/* Allocate and pre-zero a multiplier table for each component */
name|compptr
operator|->
name|dct_table
operator|=
call|(
modifier|*
name|cinfo
operator|->
name|mem
operator|->
name|alloc_small
call|)
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|,
name|JPOOL_IMAGE
argument_list|,
name|SIZEOF
argument_list|(
name|multiplier_table
argument_list|)
argument_list|)
expr_stmt|;
name|MEMZERO
argument_list|(
name|compptr
operator|->
name|dct_table
argument_list|,
name|SIZEOF
argument_list|(
name|multiplier_table
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Mark multiplier table not yet set up for any method */
name|idct
operator|->
name|cur_method
index|[
name|ci
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
end_block
end_unit
