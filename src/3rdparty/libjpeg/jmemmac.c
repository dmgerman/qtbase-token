begin_unit
begin_comment
comment|/*  * jmemmac.c  *  * Copyright (C) 1992-1997, Thomas G. Lane.  * This file is part of the Independent JPEG Group's software.  * For conditions of distribution and use, see the accompanying README file.  *  * jmemmac.c provides an Apple Macintosh implementation of the system-  * dependent portion of the JPEG memory manager.  *  * If you use jmemmac.c, then you must define USE_MAC_MEMMGR in the  * JPEG_INTERNALS part of jconfig.h.  *  * jmemmac.c uses the Macintosh toolbox routines NewPtr and DisposePtr  * instead of malloc and free.  It accurately determines the amount of  * memory available by using CompactMem.  Notice that if left to its  * own devices, this code can chew up all available space in the  * application's zone, with the exception of the rather small "slop"  * factor computed in jpeg_mem_available().  The application can ensure  * that more space is left over by reducing max_memory_to_use.  *  * Large images are swapped to disk using temporary files and System 7.0+'s  * temporary folder functionality.  *  * Note that jmemmac.c depends on two features of MacOS that were first  * introduced in System 7: FindFolder and the FSSpec-based calls.  * If your application uses jmemmac.c and is run under System 6 or earlier,  * and the jpeg library decides it needs a temporary file, it will abort,  * printing error messages about requiring System 7.  (If no temporary files  * are created, it will run fine.)  *  * If you want to use jmemmac.c in an application that might be used with  * System 6 or earlier, then you should remove dependencies on FindFolder  * and the FSSpec calls.  You will need to replace FindFolder with some  * other mechanism for finding a place to put temporary files, and you  * should replace the FSSpec calls with their HFS equivalents:  *  *     FSpDelete     ->  HDelete  *     FSpGetFInfo   ->  HGetFInfo  *     FSpCreate     ->  HCreate  *     FSpOpenDF     ->  HOpen      *** Note: not HOpenDF ***  *     FSMakeFSSpec  ->  (fill in spec by hand.)  *  * (Use HOpen instead of HOpenDF.  HOpen is just a glue-interface to PBHOpen,  * which is on all HFS macs.  HOpenDF is a System 7 addition which avoids the  * ages-old problem of names starting with a period.)  *  * Contributed by Sam Bushell (jsam@iagu.on.net) and  * Dan Gildor (gyld@in-touch.com).  */
end_comment
begin_define
DECL|macro|JPEG_INTERNALS
define|#
directive|define
name|JPEG_INTERNALS
end_define
begin_include
include|#
directive|include
file|"jinclude.h"
end_include
begin_include
include|#
directive|include
file|"jpeglib.h"
end_include
begin_include
include|#
directive|include
file|"jmemsys.h"
end_include
begin_comment
comment|/* import the system-dependent declarations */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|USE_MAC_MEMMGR
end_ifndef
begin_comment
comment|/* make sure user got configuration right */
end_comment
begin_expr_stmt
name|You
name|forgot
name|to
name|define
name|USE_MAC_MEMMGR
name|in
name|jconfig
operator|.
name|h
operator|.
comment|/* deliberate syntax error */
endif|#
directive|endif
include|#
directive|include
file|<Memory.h>
comment|/* we use the MacOS memory manager */
include|#
directive|include
file|<Files.h>
comment|/* we use the MacOS File stuff */
include|#
directive|include
file|<Folders.h>
comment|/* we use the MacOS HFS stuff */
include|#
directive|include
file|<Script.h>
comment|/* for smSystemScript */
include|#
directive|include
file|<Gestalt.h>
comment|/* we use Gestalt to test for specific functionality */
ifndef|#
directive|ifndef
name|TEMP_FILE_NAME
comment|/* can override from jconfig.h or Makefile */
DECL|macro|TEMP_FILE_NAME
define|#
directive|define
name|TEMP_FILE_NAME
value|"JPG%03d.TMP"
endif|#
directive|endif
expr|static
DECL|variable|next_file_num
name|int
name|next_file_num
expr_stmt|;
end_expr_stmt
begin_comment
DECL|variable|next_file_num
comment|/* to distinguish among several temp files */
end_comment
begin_comment
comment|/*  * Memory allocation and freeing are controlled by the MacOS library  * routines NewPtr() and DisposePtr(), which allocate fixed-address  * storage.  Unfortunately, the IJG library isn't smart enough to cope  * with relocatable storage.  */
end_comment
begin_macro
name|GLOBAL
argument_list|(
argument|void *
argument_list|)
end_macro
begin_macro
DECL|function|jpeg_get_small
name|jpeg_get_small
argument_list|(
argument|j_common_ptr cinfo
argument_list|,
argument|size_t sizeofobject
argument_list|)
end_macro
begin_block
block|{
return|return
operator|(
name|void
operator|*
operator|)
name|NewPtr
argument_list|(
name|sizeofobject
argument_list|)
return|;
block|}
end_block
begin_macro
name|GLOBAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|jpeg_free_small
name|jpeg_free_small
argument_list|(
argument|j_common_ptr cinfo
argument_list|,
argument|void * object
argument_list|,
argument|size_t sizeofobject
argument_list|)
end_macro
begin_block
block|{
name|DisposePtr
argument_list|(
operator|(
name|Ptr
operator|)
name|object
argument_list|)
expr_stmt|;
block|}
end_block
begin_comment
comment|/*  * "Large" objects are treated the same as "small" ones.  * NB: we include FAR keywords in the routine declarations simply for  * consistency with the rest of the IJG code; FAR should expand to empty  * on rational architectures like the Mac.  */
end_comment
begin_macro
name|GLOBAL
argument_list|(
argument|void FAR *
argument_list|)
end_macro
begin_macro
DECL|function|jpeg_get_large
name|jpeg_get_large
argument_list|(
argument|j_common_ptr cinfo
argument_list|,
argument|size_t sizeofobject
argument_list|)
end_macro
begin_block
block|{
return|return
operator|(
name|void
name|FAR
operator|*
operator|)
name|NewPtr
argument_list|(
name|sizeofobject
argument_list|)
return|;
block|}
end_block
begin_macro
name|GLOBAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|jpeg_free_large
name|jpeg_free_large
argument_list|(
argument|j_common_ptr cinfo
argument_list|,
argument|void FAR * object
argument_list|,
argument|size_t sizeofobject
argument_list|)
end_macro
begin_block
block|{
name|DisposePtr
argument_list|(
operator|(
name|Ptr
operator|)
name|object
argument_list|)
expr_stmt|;
block|}
end_block
begin_comment
comment|/*  * This routine computes the total memory space available for allocation.  */
end_comment
begin_macro
name|GLOBAL
argument_list|(
argument|long
argument_list|)
end_macro
begin_macro
DECL|function|jpeg_mem_available
name|jpeg_mem_available
argument_list|(
argument|j_common_ptr cinfo
argument_list|,
argument|long min_bytes_needed
argument_list|,
argument|long max_bytes_needed
argument_list|,
argument|long already_allocated
argument_list|)
end_macro
begin_block
block|{
name|long
name|limit
init|=
name|cinfo
operator|->
name|mem
operator|->
name|max_memory_to_use
operator|-
name|already_allocated
decl_stmt|;
name|long
name|slop
decl_stmt|,
name|mem
decl_stmt|;
comment|/* Don't ask for more than what application has told us we may use */
if|if
condition|(
name|max_bytes_needed
operator|>
name|limit
operator|&&
name|limit
operator|>
literal|0
condition|)
name|max_bytes_needed
operator|=
name|limit
expr_stmt|;
comment|/* Find whether there's a big enough free block in the heap.    * CompactMem tries to create a contiguous block of the requested size,    * and then returns the size of the largest free block (which could be    * much more or much less than we asked for).    * We add some slop to ensure we don't use up all available memory.    */
name|slop
operator|=
name|max_bytes_needed
operator|/
literal|16
operator|+
literal|32768L
expr_stmt|;
name|mem
operator|=
name|CompactMem
argument_list|(
name|max_bytes_needed
operator|+
name|slop
argument_list|)
operator|-
name|slop
expr_stmt|;
if|if
condition|(
name|mem
operator|<
literal|0
condition|)
name|mem
operator|=
literal|0
expr_stmt|;
comment|/* sigh, couldn't even get the slop */
comment|/* Don't take more than the application says we can have */
if|if
condition|(
name|mem
operator|>
name|limit
operator|&&
name|limit
operator|>
literal|0
condition|)
name|mem
operator|=
name|limit
expr_stmt|;
return|return
name|mem
return|;
block|}
end_block
begin_comment
comment|/*  * Backing store (temporary file) management.  * Backing store objects are only used when the value returned by  * jpeg_mem_available is less than the total space needed.  You can dispense  * with these routines if you have plenty of virtual memory; see jmemnobs.c.  */
end_comment
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|read_backing_store
name|read_backing_store
argument_list|(
argument|j_common_ptr cinfo
argument_list|,
argument|backing_store_ptr info
argument_list|,
argument|void FAR * buffer_address
argument_list|,
argument|long file_offset
argument_list|,
argument|long byte_count
argument_list|)
end_macro
begin_block
block|{
name|long
name|bytes
init|=
name|byte_count
decl_stmt|;
name|long
name|retVal
decl_stmt|;
if|if
condition|(
name|SetFPos
argument_list|(
name|info
operator|->
name|temp_file
argument_list|,
name|fsFromStart
argument_list|,
name|file_offset
argument_list|)
operator|!=
name|noErr
condition|)
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_TFILE_SEEK
argument_list|)
expr_stmt|;
name|retVal
operator|=
name|FSRead
argument_list|(
name|info
operator|->
name|temp_file
argument_list|,
operator|&
name|bytes
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|buffer_address
argument_list|)
expr_stmt|;
if|if
condition|(
name|retVal
operator|!=
name|noErr
operator|||
name|bytes
operator|!=
name|byte_count
condition|)
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_TFILE_READ
argument_list|)
expr_stmt|;
block|}
end_block
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|write_backing_store
name|write_backing_store
argument_list|(
argument|j_common_ptr cinfo
argument_list|,
argument|backing_store_ptr info
argument_list|,
argument|void FAR * buffer_address
argument_list|,
argument|long file_offset
argument_list|,
argument|long byte_count
argument_list|)
end_macro
begin_block
block|{
name|long
name|bytes
init|=
name|byte_count
decl_stmt|;
name|long
name|retVal
decl_stmt|;
if|if
condition|(
name|SetFPos
argument_list|(
name|info
operator|->
name|temp_file
argument_list|,
name|fsFromStart
argument_list|,
name|file_offset
argument_list|)
operator|!=
name|noErr
condition|)
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_TFILE_SEEK
argument_list|)
expr_stmt|;
name|retVal
operator|=
name|FSWrite
argument_list|(
name|info
operator|->
name|temp_file
argument_list|,
operator|&
name|bytes
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|buffer_address
argument_list|)
expr_stmt|;
if|if
condition|(
name|retVal
operator|!=
name|noErr
operator|||
name|bytes
operator|!=
name|byte_count
condition|)
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_TFILE_WRITE
argument_list|)
expr_stmt|;
block|}
end_block
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|close_backing_store
name|close_backing_store
argument_list|(
argument|j_common_ptr cinfo
argument_list|,
argument|backing_store_ptr info
argument_list|)
end_macro
begin_block
block|{
name|FSClose
argument_list|(
name|info
operator|->
name|temp_file
argument_list|)
expr_stmt|;
name|FSpDelete
argument_list|(
operator|&
operator|(
name|info
operator|->
name|tempSpec
operator|)
argument_list|)
expr_stmt|;
block|}
end_block
begin_comment
comment|/*  * Initial opening of a backing-store object.  *  * This version uses FindFolder to find the Temporary Items folder,  * and puts the temporary file in there.  */
end_comment
begin_macro
name|GLOBAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|jpeg_open_backing_store
name|jpeg_open_backing_store
argument_list|(
argument|j_common_ptr cinfo
argument_list|,
argument|backing_store_ptr info
argument_list|,
argument|long total_bytes_needed
argument_list|)
end_macro
begin_block
block|{
name|short
name|tmpRef
decl_stmt|,
name|vRefNum
decl_stmt|;
name|long
name|dirID
decl_stmt|;
name|FInfo
name|finderInfo
decl_stmt|;
name|FSSpec
name|theSpec
decl_stmt|;
name|Str255
name|fName
decl_stmt|;
name|OSErr
name|osErr
decl_stmt|;
name|long
name|gestaltResponse
init|=
literal|0
decl_stmt|;
comment|/* Check that FSSpec calls are available. */
name|osErr
operator|=
name|Gestalt
argument_list|(
name|gestaltFSAttr
argument_list|,
operator|&
name|gestaltResponse
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|osErr
operator|!=
name|noErr
operator|)
operator|||
operator|!
operator|(
name|gestaltResponse
operator|&
operator|(
literal|1
operator|<<
name|gestaltHasFSSpecCalls
operator|)
operator|)
condition|)
name|ERREXITS
argument_list|(
name|cinfo
argument_list|,
name|JERR_TFILE_CREATE
argument_list|,
literal|"- System 7.0 or later required"
argument_list|)
expr_stmt|;
comment|/* TO DO: add a proper error message to jerror.h. */
comment|/* Check that FindFolder is available. */
name|osErr
operator|=
name|Gestalt
argument_list|(
name|gestaltFindFolderAttr
argument_list|,
operator|&
name|gestaltResponse
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|osErr
operator|!=
name|noErr
operator|)
operator|||
operator|!
operator|(
name|gestaltResponse
operator|&
operator|(
literal|1
operator|<<
name|gestaltFindFolderPresent
operator|)
operator|)
condition|)
name|ERREXITS
argument_list|(
name|cinfo
argument_list|,
name|JERR_TFILE_CREATE
argument_list|,
literal|"- System 7.0 or later required."
argument_list|)
expr_stmt|;
comment|/* TO DO: add a proper error message to jerror.h. */
name|osErr
operator|=
name|FindFolder
argument_list|(
name|kOnSystemDisk
argument_list|,
name|kTemporaryFolderType
argument_list|,
name|kCreateFolder
argument_list|,
operator|&
name|vRefNum
argument_list|,
operator|&
name|dirID
argument_list|)
expr_stmt|;
if|if
condition|(
name|osErr
operator|!=
name|noErr
condition|)
name|ERREXITS
argument_list|(
name|cinfo
argument_list|,
name|JERR_TFILE_CREATE
argument_list|,
literal|"- temporary items folder unavailable"
argument_list|)
expr_stmt|;
comment|/* TO DO: Try putting the temp files somewhere else. */
comment|/* Keep generating file names till we find one that's not in use */
for|for
control|(
init|;
condition|;
control|)
block|{
name|next_file_num
operator|++
expr_stmt|;
comment|/* advance counter */
name|sprintf
argument_list|(
name|info
operator|->
name|temp_name
argument_list|,
name|TEMP_FILE_NAME
argument_list|,
name|next_file_num
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
operator|(
name|Ptr
operator|)
name|fName
operator|+
literal|1
argument_list|,
name|info
operator|->
name|temp_name
argument_list|)
expr_stmt|;
operator|*
name|fName
operator|=
name|strlen
argument_list|(
name|info
operator|->
name|temp_name
argument_list|)
expr_stmt|;
name|osErr
operator|=
name|FSMakeFSSpec
argument_list|(
name|vRefNum
argument_list|,
name|dirID
argument_list|,
name|fName
argument_list|,
operator|&
name|theSpec
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|osErr
operator|=
name|FSpGetFInfo
argument_list|(
operator|&
name|theSpec
argument_list|,
operator|&
name|finderInfo
argument_list|)
operator|)
operator|!=
name|noErr
condition|)
break|break;
block|}
name|osErr
operator|=
name|FSpCreate
argument_list|(
operator|&
name|theSpec
argument_list|,
literal|'????'
argument_list|,
literal|'????'
argument_list|,
name|smSystemScript
argument_list|)
expr_stmt|;
if|if
condition|(
name|osErr
operator|!=
name|noErr
condition|)
name|ERREXITS
argument_list|(
name|cinfo
argument_list|,
name|JERR_TFILE_CREATE
argument_list|,
name|info
operator|->
name|temp_name
argument_list|)
expr_stmt|;
name|osErr
operator|=
name|FSpOpenDF
argument_list|(
operator|&
name|theSpec
argument_list|,
name|fsRdWrPerm
argument_list|,
operator|&
operator|(
name|info
operator|->
name|temp_file
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|osErr
operator|!=
name|noErr
condition|)
name|ERREXITS
argument_list|(
name|cinfo
argument_list|,
name|JERR_TFILE_CREATE
argument_list|,
name|info
operator|->
name|temp_name
argument_list|)
expr_stmt|;
name|info
operator|->
name|tempSpec
operator|=
name|theSpec
expr_stmt|;
name|info
operator|->
name|read_backing_store
operator|=
name|read_backing_store
expr_stmt|;
name|info
operator|->
name|write_backing_store
operator|=
name|write_backing_store
expr_stmt|;
name|info
operator|->
name|close_backing_store
operator|=
name|close_backing_store
expr_stmt|;
name|TRACEMSS
argument_list|(
name|cinfo
argument_list|,
literal|1
argument_list|,
name|JTRC_TFILE_OPEN
argument_list|,
name|info
operator|->
name|temp_name
argument_list|)
expr_stmt|;
block|}
end_block
begin_comment
comment|/*  * These routines take care of any system-dependent initialization and  * cleanup required.  */
end_comment
begin_macro
name|GLOBAL
argument_list|(
argument|long
argument_list|)
end_macro
begin_macro
DECL|function|jpeg_mem_init
name|jpeg_mem_init
argument_list|(
argument|j_common_ptr cinfo
argument_list|)
end_macro
begin_block
block|{
name|next_file_num
operator|=
literal|0
expr_stmt|;
comment|/* max_memory_to_use will be initialized to FreeMem()'s result;    * the calling application might later reduce it, for example    * to leave room to invoke multiple JPEG objects.    * Note that FreeMem returns the total number of free bytes;    * it may not be possible to allocate a single block of this size.    */
return|return
name|FreeMem
argument_list|()
return|;
block|}
end_block
begin_macro
name|GLOBAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|jpeg_mem_term
name|jpeg_mem_term
argument_list|(
argument|j_common_ptr cinfo
argument_list|)
end_macro
begin_block
block|{
comment|/* no work */
block|}
end_block
end_unit
