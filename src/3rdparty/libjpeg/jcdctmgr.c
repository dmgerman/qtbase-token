begin_unit
begin_comment
comment|/*  * jcdctmgr.c  *  * Copyright (C) 1994-1996, Thomas G. Lane.  * This file is part of the Independent JPEG Group's software.  * For conditions of distribution and use, see the accompanying README file.  *  * This file contains the forward-DCT management logic.  * This code selects a particular DCT implementation to be used,  * and it performs related housekeeping chores including coefficient  * quantization.  */
end_comment
begin_define
DECL|macro|JPEG_INTERNALS
define|#
directive|define
name|JPEG_INTERNALS
end_define
begin_include
include|#
directive|include
file|"jinclude.h"
end_include
begin_include
include|#
directive|include
file|"jpeglib.h"
end_include
begin_include
include|#
directive|include
file|"jdct.h"
end_include
begin_comment
comment|/* Private declarations for DCT subsystem */
end_comment
begin_comment
comment|/* Private subobject for this module */
end_comment
begin_typedef
typedef|typedef
struct|struct
block|{
DECL|member|pub
name|struct
name|jpeg_forward_dct
name|pub
decl_stmt|;
comment|/* public fields */
comment|/* Pointer to the DCT routine actually in use */
DECL|member|do_dct
name|forward_DCT_method_ptr
name|do_dct
index|[
name|MAX_COMPONENTS
index|]
decl_stmt|;
comment|/* The actual post-DCT divisors --- not identical to the quant table    * entries, because of scaling (especially for an unnormalized DCT).    * Each table is given in normal array order.    */
DECL|member|divisors
name|DCTELEM
modifier|*
name|divisors
index|[
name|NUM_QUANT_TBLS
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|DCT_FLOAT_SUPPORTED
comment|/* Same as above for the floating-point case. */
DECL|member|do_float_dct
name|float_DCT_method_ptr
name|do_float_dct
index|[
name|MAX_COMPONENTS
index|]
decl_stmt|;
DECL|member|float_divisors
name|FAST_FLOAT
modifier|*
name|float_divisors
index|[
name|NUM_QUANT_TBLS
index|]
decl_stmt|;
endif|#
directive|endif
block|}
DECL|typedef|my_fdct_controller
name|my_fdct_controller
typedef|;
end_typedef
begin_typedef
DECL|typedef|my_fdct_ptr
typedef|typedef
name|my_fdct_controller
modifier|*
name|my_fdct_ptr
typedef|;
end_typedef
begin_comment
comment|/* The current scaled-DCT routines require ISLOW-style divisor tables,  * so be sure to compile that code if either ISLOW or SCALING is requested.  */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|DCT_ISLOW_SUPPORTED
end_ifdef
begin_define
DECL|macro|PROVIDE_ISLOW_TABLES
define|#
directive|define
name|PROVIDE_ISLOW_TABLES
end_define
begin_else
else|#
directive|else
end_else
begin_ifdef
ifdef|#
directive|ifdef
name|DCT_SCALING_SUPPORTED
end_ifdef
begin_define
DECL|macro|PROVIDE_ISLOW_TABLES
define|#
directive|define
name|PROVIDE_ISLOW_TABLES
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*  * Perform forward DCT on one or more blocks of a component.  *  * The input samples are taken from the sample_data[] array starting at  * position start_row/start_col, and moving to the right for any additional  * blocks. The quantized coefficients are returned in coef_blocks[].  */
end_comment
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|forward_DCT
name|forward_DCT
argument_list|(
argument|j_compress_ptr cinfo
argument_list|,
argument|jpeg_component_info * compptr
argument_list|,
argument|JSAMPARRAY sample_data
argument_list|,
argument|JBLOCKROW coef_blocks
argument_list|,
argument|JDIMENSION start_row
argument_list|,
argument|JDIMENSION start_col
argument_list|,
argument|JDIMENSION num_blocks
argument_list|)
end_macro
begin_comment
comment|/* This version is used for integer DCT implementations. */
end_comment
begin_block
block|{
comment|/* This routine is heavily used, so it's worth coding it tightly. */
name|my_fdct_ptr
name|fdct
init|=
operator|(
name|my_fdct_ptr
operator|)
name|cinfo
operator|->
name|fdct
decl_stmt|;
name|forward_DCT_method_ptr
name|do_dct
init|=
name|fdct
operator|->
name|do_dct
index|[
name|compptr
operator|->
name|component_index
index|]
decl_stmt|;
name|DCTELEM
modifier|*
name|divisors
init|=
name|fdct
operator|->
name|divisors
index|[
name|compptr
operator|->
name|quant_tbl_no
index|]
decl_stmt|;
name|DCTELEM
name|workspace
index|[
name|DCTSIZE2
index|]
decl_stmt|;
comment|/* work area for FDCT subroutine */
name|JDIMENSION
name|bi
decl_stmt|;
name|sample_data
operator|+=
name|start_row
expr_stmt|;
comment|/* fold in the vertical offset once */
for|for
control|(
name|bi
operator|=
literal|0
init|;
name|bi
operator|<
name|num_blocks
condition|;
name|bi
operator|++
operator|,
name|start_col
operator|+=
name|compptr
operator|->
name|DCT_h_scaled_size
control|)
block|{
comment|/* Perform the DCT */
call|(
modifier|*
name|do_dct
call|)
argument_list|(
name|workspace
argument_list|,
name|sample_data
argument_list|,
name|start_col
argument_list|)
expr_stmt|;
comment|/* Quantize/descale the coefficients, and store into coef_blocks[] */
block|{
specifier|register
name|DCTELEM
name|temp
decl_stmt|,
name|qval
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|JCOEFPTR
name|output_ptr
init|=
name|coef_blocks
index|[
name|bi
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DCTSIZE2
condition|;
name|i
operator|++
control|)
block|{
name|qval
operator|=
name|divisors
index|[
name|i
index|]
expr_stmt|;
name|temp
operator|=
name|workspace
index|[
name|i
index|]
expr_stmt|;
comment|/* Divide the coefficient value by qval, ensuring proper rounding. 	 * Since C does not specify the direction of rounding for negative 	 * quotients, we have to force the dividend positive for portability. 	 * 	 * In most files, at least half of the output values will be zero 	 * (at default quantization settings, more like three-quarters...) 	 * so we should ensure that this case is fast.  On many machines, 	 * a comparison is enough cheaper than a divide to make a special test 	 * a win.  Since both inputs will be nonnegative, we need only test 	 * for a< b to discover whether a/b is 0. 	 * If your machine's division is fast enough, define FAST_DIVIDE. 	 */
ifdef|#
directive|ifdef
name|FAST_DIVIDE
DECL|macro|DIVIDE_BY
define|#
directive|define
name|DIVIDE_BY
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|a /= b
else|#
directive|else
define|#
directive|define
name|DIVIDE_BY
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|if (a>= b) a /= b; else a = 0
endif|#
directive|endif
if|if
condition|(
name|temp
operator|<
literal|0
condition|)
block|{
name|temp
operator|=
operator|-
name|temp
expr_stmt|;
name|temp
operator|+=
name|qval
operator|>>
literal|1
expr_stmt|;
comment|/* for rounding */
name|DIVIDE_BY
argument_list|(
name|temp
argument_list|,
name|qval
argument_list|)
expr_stmt|;
name|temp
operator|=
operator|-
name|temp
expr_stmt|;
block|}
else|else
block|{
name|temp
operator|+=
name|qval
operator|>>
literal|1
expr_stmt|;
comment|/* for rounding */
name|DIVIDE_BY
argument_list|(
name|temp
argument_list|,
name|qval
argument_list|)
expr_stmt|;
block|}
name|output_ptr
index|[
name|i
index|]
operator|=
operator|(
name|JCOEF
operator|)
name|temp
expr_stmt|;
block|}
block|}
block|}
block|}
end_block
begin_ifdef
ifdef|#
directive|ifdef
name|DCT_FLOAT_SUPPORTED
end_ifdef
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|forward_DCT_float
name|forward_DCT_float
argument_list|(
argument|j_compress_ptr cinfo
argument_list|,
argument|jpeg_component_info * compptr
argument_list|,
argument|JSAMPARRAY sample_data
argument_list|,
argument|JBLOCKROW coef_blocks
argument_list|,
argument|JDIMENSION start_row
argument_list|,
argument|JDIMENSION start_col
argument_list|,
argument|JDIMENSION num_blocks
argument_list|)
end_macro
begin_comment
comment|/* This version is used for floating-point DCT implementations. */
end_comment
begin_block
block|{
comment|/* This routine is heavily used, so it's worth coding it tightly. */
name|my_fdct_ptr
name|fdct
init|=
operator|(
name|my_fdct_ptr
operator|)
name|cinfo
operator|->
name|fdct
decl_stmt|;
name|float_DCT_method_ptr
name|do_dct
init|=
name|fdct
operator|->
name|do_float_dct
index|[
name|compptr
operator|->
name|component_index
index|]
decl_stmt|;
name|FAST_FLOAT
modifier|*
name|divisors
init|=
name|fdct
operator|->
name|float_divisors
index|[
name|compptr
operator|->
name|quant_tbl_no
index|]
decl_stmt|;
name|FAST_FLOAT
name|workspace
index|[
name|DCTSIZE2
index|]
decl_stmt|;
comment|/* work area for FDCT subroutine */
name|JDIMENSION
name|bi
decl_stmt|;
name|sample_data
operator|+=
name|start_row
expr_stmt|;
comment|/* fold in the vertical offset once */
for|for
control|(
name|bi
operator|=
literal|0
init|;
name|bi
operator|<
name|num_blocks
condition|;
name|bi
operator|++
operator|,
name|start_col
operator|+=
name|compptr
operator|->
name|DCT_h_scaled_size
control|)
block|{
comment|/* Perform the DCT */
call|(
modifier|*
name|do_dct
call|)
argument_list|(
name|workspace
argument_list|,
name|sample_data
argument_list|,
name|start_col
argument_list|)
expr_stmt|;
comment|/* Quantize/descale the coefficients, and store into coef_blocks[] */
block|{
specifier|register
name|FAST_FLOAT
name|temp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|JCOEFPTR
name|output_ptr
init|=
name|coef_blocks
index|[
name|bi
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DCTSIZE2
condition|;
name|i
operator|++
control|)
block|{
comment|/* Apply the quantization and scaling factor */
name|temp
operator|=
name|workspace
index|[
name|i
index|]
operator|*
name|divisors
index|[
name|i
index|]
expr_stmt|;
comment|/* Round to nearest integer. 	 * Since C does not specify the direction of rounding for negative 	 * quotients, we have to force the dividend positive for portability. 	 * The maximum coefficient size is +-16K (for 12-bit data), so this 	 * code should work for either 16-bit or 32-bit ints. 	 */
name|output_ptr
index|[
name|i
index|]
operator|=
call|(
name|JCOEF
call|)
argument_list|(
call|(
name|int
call|)
argument_list|(
name|temp
operator|+
operator|(
name|FAST_FLOAT
operator|)
literal|16384.5
argument_list|)
operator|-
literal|16384
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_block
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* DCT_FLOAT_SUPPORTED */
end_comment
begin_comment
comment|/*  * Initialize for a processing pass.  * Verify that all referenced Q-tables are present, and set up  * the divisor table for each one.  * In the current implementation, DCT of all components is done during  * the first pass, even if only some components will be output in the  * first scan.  Hence all components should be examined here.  */
end_comment
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|start_pass_fdctmgr
name|start_pass_fdctmgr
argument_list|(
argument|j_compress_ptr cinfo
argument_list|)
end_macro
begin_block
block|{
name|my_fdct_ptr
name|fdct
init|=
operator|(
name|my_fdct_ptr
operator|)
name|cinfo
operator|->
name|fdct
decl_stmt|;
name|int
name|ci
decl_stmt|,
name|qtblno
decl_stmt|,
name|i
decl_stmt|;
name|jpeg_component_info
modifier|*
name|compptr
decl_stmt|;
name|int
name|method
init|=
literal|0
decl_stmt|;
name|JQUANT_TBL
modifier|*
name|qtbl
decl_stmt|;
name|DCTELEM
modifier|*
name|dtbl
decl_stmt|;
for|for
control|(
name|ci
operator|=
literal|0
operator|,
name|compptr
operator|=
name|cinfo
operator|->
name|comp_info
init|;
name|ci
operator|<
name|cinfo
operator|->
name|num_components
condition|;
name|ci
operator|++
operator|,
name|compptr
operator|++
control|)
block|{
comment|/* Select the proper DCT routine for this component's scaling */
switch|switch
condition|(
operator|(
name|compptr
operator|->
name|DCT_h_scaled_size
operator|<<
literal|8
operator|)
operator|+
name|compptr
operator|->
name|DCT_v_scaled_size
condition|)
block|{
ifdef|#
directive|ifdef
name|DCT_SCALING_SUPPORTED
case|case
operator|(
operator|(
literal|1
operator|<<
literal|8
operator|)
operator|+
literal|1
operator|)
case|:
name|fdct
operator|->
name|do_dct
index|[
name|ci
index|]
operator|=
name|jpeg_fdct_1x1
expr_stmt|;
name|method
operator|=
name|JDCT_ISLOW
expr_stmt|;
comment|/* jfdctint uses islow-style table */
break|break;
case|case
operator|(
operator|(
literal|2
operator|<<
literal|8
operator|)
operator|+
literal|2
operator|)
case|:
name|fdct
operator|->
name|do_dct
index|[
name|ci
index|]
operator|=
name|jpeg_fdct_2x2
expr_stmt|;
name|method
operator|=
name|JDCT_ISLOW
expr_stmt|;
comment|/* jfdctint uses islow-style table */
break|break;
case|case
operator|(
operator|(
literal|3
operator|<<
literal|8
operator|)
operator|+
literal|3
operator|)
case|:
name|fdct
operator|->
name|do_dct
index|[
name|ci
index|]
operator|=
name|jpeg_fdct_3x3
expr_stmt|;
name|method
operator|=
name|JDCT_ISLOW
expr_stmt|;
comment|/* jfdctint uses islow-style table */
break|break;
case|case
operator|(
operator|(
literal|4
operator|<<
literal|8
operator|)
operator|+
literal|4
operator|)
case|:
name|fdct
operator|->
name|do_dct
index|[
name|ci
index|]
operator|=
name|jpeg_fdct_4x4
expr_stmt|;
name|method
operator|=
name|JDCT_ISLOW
expr_stmt|;
comment|/* jfdctint uses islow-style table */
break|break;
case|case
operator|(
operator|(
literal|5
operator|<<
literal|8
operator|)
operator|+
literal|5
operator|)
case|:
name|fdct
operator|->
name|do_dct
index|[
name|ci
index|]
operator|=
name|jpeg_fdct_5x5
expr_stmt|;
name|method
operator|=
name|JDCT_ISLOW
expr_stmt|;
comment|/* jfdctint uses islow-style table */
break|break;
case|case
operator|(
operator|(
literal|6
operator|<<
literal|8
operator|)
operator|+
literal|6
operator|)
case|:
name|fdct
operator|->
name|do_dct
index|[
name|ci
index|]
operator|=
name|jpeg_fdct_6x6
expr_stmt|;
name|method
operator|=
name|JDCT_ISLOW
expr_stmt|;
comment|/* jfdctint uses islow-style table */
break|break;
case|case
operator|(
operator|(
literal|7
operator|<<
literal|8
operator|)
operator|+
literal|7
operator|)
case|:
name|fdct
operator|->
name|do_dct
index|[
name|ci
index|]
operator|=
name|jpeg_fdct_7x7
expr_stmt|;
name|method
operator|=
name|JDCT_ISLOW
expr_stmt|;
comment|/* jfdctint uses islow-style table */
break|break;
case|case
operator|(
operator|(
literal|9
operator|<<
literal|8
operator|)
operator|+
literal|9
operator|)
case|:
name|fdct
operator|->
name|do_dct
index|[
name|ci
index|]
operator|=
name|jpeg_fdct_9x9
expr_stmt|;
name|method
operator|=
name|JDCT_ISLOW
expr_stmt|;
comment|/* jfdctint uses islow-style table */
break|break;
case|case
operator|(
operator|(
literal|10
operator|<<
literal|8
operator|)
operator|+
literal|10
operator|)
case|:
name|fdct
operator|->
name|do_dct
index|[
name|ci
index|]
operator|=
name|jpeg_fdct_10x10
expr_stmt|;
name|method
operator|=
name|JDCT_ISLOW
expr_stmt|;
comment|/* jfdctint uses islow-style table */
break|break;
case|case
operator|(
operator|(
literal|11
operator|<<
literal|8
operator|)
operator|+
literal|11
operator|)
case|:
name|fdct
operator|->
name|do_dct
index|[
name|ci
index|]
operator|=
name|jpeg_fdct_11x11
expr_stmt|;
name|method
operator|=
name|JDCT_ISLOW
expr_stmt|;
comment|/* jfdctint uses islow-style table */
break|break;
case|case
operator|(
operator|(
literal|12
operator|<<
literal|8
operator|)
operator|+
literal|12
operator|)
case|:
name|fdct
operator|->
name|do_dct
index|[
name|ci
index|]
operator|=
name|jpeg_fdct_12x12
expr_stmt|;
name|method
operator|=
name|JDCT_ISLOW
expr_stmt|;
comment|/* jfdctint uses islow-style table */
break|break;
case|case
operator|(
operator|(
literal|13
operator|<<
literal|8
operator|)
operator|+
literal|13
operator|)
case|:
name|fdct
operator|->
name|do_dct
index|[
name|ci
index|]
operator|=
name|jpeg_fdct_13x13
expr_stmt|;
name|method
operator|=
name|JDCT_ISLOW
expr_stmt|;
comment|/* jfdctint uses islow-style table */
break|break;
case|case
operator|(
operator|(
literal|14
operator|<<
literal|8
operator|)
operator|+
literal|14
operator|)
case|:
name|fdct
operator|->
name|do_dct
index|[
name|ci
index|]
operator|=
name|jpeg_fdct_14x14
expr_stmt|;
name|method
operator|=
name|JDCT_ISLOW
expr_stmt|;
comment|/* jfdctint uses islow-style table */
break|break;
case|case
operator|(
operator|(
literal|15
operator|<<
literal|8
operator|)
operator|+
literal|15
operator|)
case|:
name|fdct
operator|->
name|do_dct
index|[
name|ci
index|]
operator|=
name|jpeg_fdct_15x15
expr_stmt|;
name|method
operator|=
name|JDCT_ISLOW
expr_stmt|;
comment|/* jfdctint uses islow-style table */
break|break;
case|case
operator|(
operator|(
literal|16
operator|<<
literal|8
operator|)
operator|+
literal|16
operator|)
case|:
name|fdct
operator|->
name|do_dct
index|[
name|ci
index|]
operator|=
name|jpeg_fdct_16x16
expr_stmt|;
name|method
operator|=
name|JDCT_ISLOW
expr_stmt|;
comment|/* jfdctint uses islow-style table */
break|break;
case|case
operator|(
operator|(
literal|16
operator|<<
literal|8
operator|)
operator|+
literal|8
operator|)
case|:
name|fdct
operator|->
name|do_dct
index|[
name|ci
index|]
operator|=
name|jpeg_fdct_16x8
expr_stmt|;
name|method
operator|=
name|JDCT_ISLOW
expr_stmt|;
comment|/* jfdctint uses islow-style table */
break|break;
case|case
operator|(
operator|(
literal|14
operator|<<
literal|8
operator|)
operator|+
literal|7
operator|)
case|:
name|fdct
operator|->
name|do_dct
index|[
name|ci
index|]
operator|=
name|jpeg_fdct_14x7
expr_stmt|;
name|method
operator|=
name|JDCT_ISLOW
expr_stmt|;
comment|/* jfdctint uses islow-style table */
break|break;
case|case
operator|(
operator|(
literal|12
operator|<<
literal|8
operator|)
operator|+
literal|6
operator|)
case|:
name|fdct
operator|->
name|do_dct
index|[
name|ci
index|]
operator|=
name|jpeg_fdct_12x6
expr_stmt|;
name|method
operator|=
name|JDCT_ISLOW
expr_stmt|;
comment|/* jfdctint uses islow-style table */
break|break;
case|case
operator|(
operator|(
literal|10
operator|<<
literal|8
operator|)
operator|+
literal|5
operator|)
case|:
name|fdct
operator|->
name|do_dct
index|[
name|ci
index|]
operator|=
name|jpeg_fdct_10x5
expr_stmt|;
name|method
operator|=
name|JDCT_ISLOW
expr_stmt|;
comment|/* jfdctint uses islow-style table */
break|break;
case|case
operator|(
operator|(
literal|8
operator|<<
literal|8
operator|)
operator|+
literal|4
operator|)
case|:
name|fdct
operator|->
name|do_dct
index|[
name|ci
index|]
operator|=
name|jpeg_fdct_8x4
expr_stmt|;
name|method
operator|=
name|JDCT_ISLOW
expr_stmt|;
comment|/* jfdctint uses islow-style table */
break|break;
case|case
operator|(
operator|(
literal|6
operator|<<
literal|8
operator|)
operator|+
literal|3
operator|)
case|:
name|fdct
operator|->
name|do_dct
index|[
name|ci
index|]
operator|=
name|jpeg_fdct_6x3
expr_stmt|;
name|method
operator|=
name|JDCT_ISLOW
expr_stmt|;
comment|/* jfdctint uses islow-style table */
break|break;
case|case
operator|(
operator|(
literal|4
operator|<<
literal|8
operator|)
operator|+
literal|2
operator|)
case|:
name|fdct
operator|->
name|do_dct
index|[
name|ci
index|]
operator|=
name|jpeg_fdct_4x2
expr_stmt|;
name|method
operator|=
name|JDCT_ISLOW
expr_stmt|;
comment|/* jfdctint uses islow-style table */
break|break;
case|case
operator|(
operator|(
literal|2
operator|<<
literal|8
operator|)
operator|+
literal|1
operator|)
case|:
name|fdct
operator|->
name|do_dct
index|[
name|ci
index|]
operator|=
name|jpeg_fdct_2x1
expr_stmt|;
name|method
operator|=
name|JDCT_ISLOW
expr_stmt|;
comment|/* jfdctint uses islow-style table */
break|break;
case|case
operator|(
operator|(
literal|8
operator|<<
literal|8
operator|)
operator|+
literal|16
operator|)
case|:
name|fdct
operator|->
name|do_dct
index|[
name|ci
index|]
operator|=
name|jpeg_fdct_8x16
expr_stmt|;
name|method
operator|=
name|JDCT_ISLOW
expr_stmt|;
comment|/* jfdctint uses islow-style table */
break|break;
case|case
operator|(
operator|(
literal|7
operator|<<
literal|8
operator|)
operator|+
literal|14
operator|)
case|:
name|fdct
operator|->
name|do_dct
index|[
name|ci
index|]
operator|=
name|jpeg_fdct_7x14
expr_stmt|;
name|method
operator|=
name|JDCT_ISLOW
expr_stmt|;
comment|/* jfdctint uses islow-style table */
break|break;
case|case
operator|(
operator|(
literal|6
operator|<<
literal|8
operator|)
operator|+
literal|12
operator|)
case|:
name|fdct
operator|->
name|do_dct
index|[
name|ci
index|]
operator|=
name|jpeg_fdct_6x12
expr_stmt|;
name|method
operator|=
name|JDCT_ISLOW
expr_stmt|;
comment|/* jfdctint uses islow-style table */
break|break;
case|case
operator|(
operator|(
literal|5
operator|<<
literal|8
operator|)
operator|+
literal|10
operator|)
case|:
name|fdct
operator|->
name|do_dct
index|[
name|ci
index|]
operator|=
name|jpeg_fdct_5x10
expr_stmt|;
name|method
operator|=
name|JDCT_ISLOW
expr_stmt|;
comment|/* jfdctint uses islow-style table */
break|break;
case|case
operator|(
operator|(
literal|4
operator|<<
literal|8
operator|)
operator|+
literal|8
operator|)
case|:
name|fdct
operator|->
name|do_dct
index|[
name|ci
index|]
operator|=
name|jpeg_fdct_4x8
expr_stmt|;
name|method
operator|=
name|JDCT_ISLOW
expr_stmt|;
comment|/* jfdctint uses islow-style table */
break|break;
case|case
operator|(
operator|(
literal|3
operator|<<
literal|8
operator|)
operator|+
literal|6
operator|)
case|:
name|fdct
operator|->
name|do_dct
index|[
name|ci
index|]
operator|=
name|jpeg_fdct_3x6
expr_stmt|;
name|method
operator|=
name|JDCT_ISLOW
expr_stmt|;
comment|/* jfdctint uses islow-style table */
break|break;
case|case
operator|(
operator|(
literal|2
operator|<<
literal|8
operator|)
operator|+
literal|4
operator|)
case|:
name|fdct
operator|->
name|do_dct
index|[
name|ci
index|]
operator|=
name|jpeg_fdct_2x4
expr_stmt|;
name|method
operator|=
name|JDCT_ISLOW
expr_stmt|;
comment|/* jfdctint uses islow-style table */
break|break;
case|case
operator|(
operator|(
literal|1
operator|<<
literal|8
operator|)
operator|+
literal|2
operator|)
case|:
name|fdct
operator|->
name|do_dct
index|[
name|ci
index|]
operator|=
name|jpeg_fdct_1x2
expr_stmt|;
name|method
operator|=
name|JDCT_ISLOW
expr_stmt|;
comment|/* jfdctint uses islow-style table */
break|break;
endif|#
directive|endif
case|case
operator|(
operator|(
name|DCTSIZE
operator|<<
literal|8
operator|)
operator|+
name|DCTSIZE
operator|)
case|:
switch|switch
condition|(
name|cinfo
operator|->
name|dct_method
condition|)
block|{
ifdef|#
directive|ifdef
name|DCT_ISLOW_SUPPORTED
case|case
name|JDCT_ISLOW
case|:
name|fdct
operator|->
name|do_dct
index|[
name|ci
index|]
operator|=
name|jpeg_fdct_islow
expr_stmt|;
name|method
operator|=
name|JDCT_ISLOW
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DCT_IFAST_SUPPORTED
case|case
name|JDCT_IFAST
case|:
name|fdct
operator|->
name|do_dct
index|[
name|ci
index|]
operator|=
name|jpeg_fdct_ifast
expr_stmt|;
name|method
operator|=
name|JDCT_IFAST
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DCT_FLOAT_SUPPORTED
case|case
name|JDCT_FLOAT
case|:
name|fdct
operator|->
name|do_float_dct
index|[
name|ci
index|]
operator|=
name|jpeg_fdct_float
expr_stmt|;
name|method
operator|=
name|JDCT_FLOAT
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_NOT_COMPILED
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|ERREXIT2
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_DCTSIZE
argument_list|,
name|compptr
operator|->
name|DCT_h_scaled_size
argument_list|,
name|compptr
operator|->
name|DCT_v_scaled_size
argument_list|)
expr_stmt|;
break|break;
block|}
name|qtblno
operator|=
name|compptr
operator|->
name|quant_tbl_no
expr_stmt|;
comment|/* Make sure specified quantization table is present */
if|if
condition|(
name|qtblno
operator|<
literal|0
operator|||
name|qtblno
operator|>=
name|NUM_QUANT_TBLS
operator|||
name|cinfo
operator|->
name|quant_tbl_ptrs
index|[
name|qtblno
index|]
operator|==
name|NULL
condition|)
name|ERREXIT1
argument_list|(
name|cinfo
argument_list|,
name|JERR_NO_QUANT_TABLE
argument_list|,
name|qtblno
argument_list|)
expr_stmt|;
name|qtbl
operator|=
name|cinfo
operator|->
name|quant_tbl_ptrs
index|[
name|qtblno
index|]
expr_stmt|;
comment|/* Compute divisors for this quant table */
comment|/* We may do this more than once for same table, but it's not a big deal */
switch|switch
condition|(
name|method
condition|)
block|{
ifdef|#
directive|ifdef
name|PROVIDE_ISLOW_TABLES
case|case
name|JDCT_ISLOW
case|:
comment|/* For LL&M IDCT method, divisors are equal to raw quantization        * coefficients multiplied by 8 (to counteract scaling).        */
if|if
condition|(
name|fdct
operator|->
name|divisors
index|[
name|qtblno
index|]
operator|==
name|NULL
condition|)
block|{
name|fdct
operator|->
name|divisors
index|[
name|qtblno
index|]
operator|=
operator|(
name|DCTELEM
operator|*
operator|)
call|(
modifier|*
name|cinfo
operator|->
name|mem
operator|->
name|alloc_small
call|)
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|,
name|JPOOL_IMAGE
argument_list|,
name|DCTSIZE2
operator|*
name|SIZEOF
argument_list|(
name|DCTELEM
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dtbl
operator|=
name|fdct
operator|->
name|divisors
index|[
name|qtblno
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DCTSIZE2
condition|;
name|i
operator|++
control|)
block|{
name|dtbl
index|[
name|i
index|]
operator|=
operator|(
operator|(
name|DCTELEM
operator|)
name|qtbl
operator|->
name|quantval
index|[
name|i
index|]
operator|)
operator|<<
literal|3
expr_stmt|;
block|}
name|fdct
operator|->
name|pub
operator|.
name|forward_DCT
index|[
name|ci
index|]
operator|=
name|forward_DCT
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DCT_IFAST_SUPPORTED
case|case
name|JDCT_IFAST
case|:
block|{
comment|/* For AA&N IDCT method, divisors are equal to quantization 	 * coefficients scaled by scalefactor[row]*scalefactor[col], where 	 *   scalefactor[0] = 1 	 *   scalefactor[k] = cos(k*PI/16) * sqrt(2)    for k=1..7 	 * We apply a further scale factor of 8. 	 */
DECL|macro|CONST_BITS
define|#
directive|define
name|CONST_BITS
value|14
specifier|static
specifier|const
name|INT16
name|aanscales
index|[
name|DCTSIZE2
index|]
init|=
block|{
comment|/* precomputed values scaled up by 14 bits */
literal|16384
block|,
literal|22725
block|,
literal|21407
block|,
literal|19266
block|,
literal|16384
block|,
literal|12873
block|,
literal|8867
block|,
literal|4520
block|,
literal|22725
block|,
literal|31521
block|,
literal|29692
block|,
literal|26722
block|,
literal|22725
block|,
literal|17855
block|,
literal|12299
block|,
literal|6270
block|,
literal|21407
block|,
literal|29692
block|,
literal|27969
block|,
literal|25172
block|,
literal|21407
block|,
literal|16819
block|,
literal|11585
block|,
literal|5906
block|,
literal|19266
block|,
literal|26722
block|,
literal|25172
block|,
literal|22654
block|,
literal|19266
block|,
literal|15137
block|,
literal|10426
block|,
literal|5315
block|,
literal|16384
block|,
literal|22725
block|,
literal|21407
block|,
literal|19266
block|,
literal|16384
block|,
literal|12873
block|,
literal|8867
block|,
literal|4520
block|,
literal|12873
block|,
literal|17855
block|,
literal|16819
block|,
literal|15137
block|,
literal|12873
block|,
literal|10114
block|,
literal|6967
block|,
literal|3552
block|,
literal|8867
block|,
literal|12299
block|,
literal|11585
block|,
literal|10426
block|,
literal|8867
block|,
literal|6967
block|,
literal|4799
block|,
literal|2446
block|,
literal|4520
block|,
literal|6270
block|,
literal|5906
block|,
literal|5315
block|,
literal|4520
block|,
literal|3552
block|,
literal|2446
block|,
literal|1247
block|}
decl_stmt|;
name|SHIFT_TEMPS
if|if
condition|(
name|fdct
operator|->
name|divisors
index|[
name|qtblno
index|]
operator|==
name|NULL
condition|)
block|{
name|fdct
operator|->
name|divisors
index|[
name|qtblno
index|]
operator|=
operator|(
name|DCTELEM
operator|*
operator|)
call|(
modifier|*
name|cinfo
operator|->
name|mem
operator|->
name|alloc_small
call|)
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|,
name|JPOOL_IMAGE
argument_list|,
name|DCTSIZE2
operator|*
name|SIZEOF
argument_list|(
name|DCTELEM
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dtbl
operator|=
name|fdct
operator|->
name|divisors
index|[
name|qtblno
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DCTSIZE2
condition|;
name|i
operator|++
control|)
block|{
name|dtbl
index|[
name|i
index|]
operator|=
operator|(
name|DCTELEM
operator|)
name|DESCALE
argument_list|(
name|MULTIPLY16V16
argument_list|(
operator|(
name|INT32
operator|)
name|qtbl
operator|->
name|quantval
index|[
name|i
index|]
argument_list|,
operator|(
name|INT32
operator|)
name|aanscales
index|[
name|i
index|]
argument_list|)
argument_list|,
name|CONST_BITS
operator|-
literal|3
argument_list|)
expr_stmt|;
block|}
block|}
name|fdct
operator|->
name|pub
operator|.
name|forward_DCT
index|[
name|ci
index|]
operator|=
name|forward_DCT
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DCT_FLOAT_SUPPORTED
case|case
name|JDCT_FLOAT
case|:
block|{
comment|/* For float AA&N IDCT method, divisors are equal to quantization 	 * coefficients scaled by scalefactor[row]*scalefactor[col], where 	 *   scalefactor[0] = 1 	 *   scalefactor[k] = cos(k*PI/16) * sqrt(2)    for k=1..7 	 * We apply a further scale factor of 8. 	 * What's actually stored is 1/divisor so that the inner loop can 	 * use a multiplication rather than a division. 	 */
name|FAST_FLOAT
modifier|*
name|fdtbl
decl_stmt|;
name|int
name|row
decl_stmt|,
name|col
decl_stmt|;
specifier|static
specifier|const
name|double
name|aanscalefactor
index|[
name|DCTSIZE
index|]
init|=
block|{
literal|1.0
block|,
literal|1.387039845
block|,
literal|1.306562965
block|,
literal|1.175875602
block|,
literal|1.0
block|,
literal|0.785694958
block|,
literal|0.541196100
block|,
literal|0.275899379
block|}
decl_stmt|;
if|if
condition|(
name|fdct
operator|->
name|float_divisors
index|[
name|qtblno
index|]
operator|==
name|NULL
condition|)
block|{
name|fdct
operator|->
name|float_divisors
index|[
name|qtblno
index|]
operator|=
operator|(
name|FAST_FLOAT
operator|*
operator|)
call|(
modifier|*
name|cinfo
operator|->
name|mem
operator|->
name|alloc_small
call|)
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|,
name|JPOOL_IMAGE
argument_list|,
name|DCTSIZE2
operator|*
name|SIZEOF
argument_list|(
name|FAST_FLOAT
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fdtbl
operator|=
name|fdct
operator|->
name|float_divisors
index|[
name|qtblno
index|]
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|row
operator|=
literal|0
init|;
name|row
operator|<
name|DCTSIZE
condition|;
name|row
operator|++
control|)
block|{
for|for
control|(
name|col
operator|=
literal|0
init|;
name|col
operator|<
name|DCTSIZE
condition|;
name|col
operator|++
control|)
block|{
name|fdtbl
index|[
name|i
index|]
operator|=
call|(
name|FAST_FLOAT
call|)
argument_list|(
literal|1.0
operator|/
operator|(
operator|(
operator|(
name|double
operator|)
name|qtbl
operator|->
name|quantval
index|[
name|i
index|]
operator|*
name|aanscalefactor
index|[
name|row
index|]
operator|*
name|aanscalefactor
index|[
name|col
index|]
operator|*
literal|8.0
operator|)
operator|)
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
block|}
name|fdct
operator|->
name|pub
operator|.
name|forward_DCT
index|[
name|ci
index|]
operator|=
name|forward_DCT_float
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_NOT_COMPILED
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_block
begin_comment
comment|/*  * Initialize FDCT manager.  */
end_comment
begin_macro
name|GLOBAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|jinit_forward_dct
name|jinit_forward_dct
argument_list|(
argument|j_compress_ptr cinfo
argument_list|)
end_macro
begin_block
block|{
name|my_fdct_ptr
name|fdct
decl_stmt|;
name|int
name|i
decl_stmt|;
name|fdct
operator|=
call|(
name|my_fdct_ptr
call|)
argument_list|(
operator|*
name|cinfo
operator|->
name|mem
operator|->
name|alloc_small
argument_list|)
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|,
name|JPOOL_IMAGE
argument_list|,
name|SIZEOF
argument_list|(
name|my_fdct_controller
argument_list|)
argument_list|)
expr_stmt|;
name|cinfo
operator|->
name|fdct
operator|=
operator|(
expr|struct
name|jpeg_forward_dct
operator|*
operator|)
name|fdct
expr_stmt|;
name|fdct
operator|->
name|pub
operator|.
name|start_pass
operator|=
name|start_pass_fdctmgr
expr_stmt|;
comment|/* Mark divisor tables unallocated */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_QUANT_TBLS
condition|;
name|i
operator|++
control|)
block|{
name|fdct
operator|->
name|divisors
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|DCT_FLOAT_SUPPORTED
name|fdct
operator|->
name|float_divisors
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_block
end_unit
