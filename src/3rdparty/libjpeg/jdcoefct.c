begin_unit
begin_comment
comment|/*  * jdcoefct.c  *  * Copyright (C) 1994-1997, Thomas G. Lane.  * This file is part of the Independent JPEG Group's software.  * For conditions of distribution and use, see the accompanying README file.  *  * This file contains the coefficient buffer controller for decompression.  * This controller is the top level of the JPEG decompressor proper.  * The coefficient buffer lies between entropy decoding and inverse-DCT steps.  *  * In buffered-image mode, this controller is the interface between  * input-oriented processing and output-oriented processing.  * Also, the input side (only) is used when reading a file for transcoding.  */
end_comment
begin_define
DECL|macro|JPEG_INTERNALS
define|#
directive|define
name|JPEG_INTERNALS
end_define
begin_include
include|#
directive|include
file|"jinclude.h"
end_include
begin_include
include|#
directive|include
file|"jpeglib.h"
end_include
begin_comment
comment|/* Block smoothing is only applicable for progressive JPEG, so: */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|D_PROGRESSIVE_SUPPORTED
end_ifndef
begin_undef
DECL|macro|BLOCK_SMOOTHING_SUPPORTED
undef|#
directive|undef
name|BLOCK_SMOOTHING_SUPPORTED
end_undef
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* Private buffer controller object */
end_comment
begin_typedef
typedef|typedef
struct|struct
block|{
DECL|member|pub
name|struct
name|jpeg_d_coef_controller
name|pub
decl_stmt|;
comment|/* public fields */
comment|/* These variables keep track of the current location of the input side. */
comment|/* cinfo->input_iMCU_row is also used for this. */
DECL|member|MCU_ctr
name|JDIMENSION
name|MCU_ctr
decl_stmt|;
comment|/* counts MCUs processed in current row */
DECL|member|MCU_vert_offset
name|int
name|MCU_vert_offset
decl_stmt|;
comment|/* counts MCU rows within iMCU row */
DECL|member|MCU_rows_per_iMCU_row
name|int
name|MCU_rows_per_iMCU_row
decl_stmt|;
comment|/* number of such rows needed */
comment|/* The output side's location is represented by cinfo->output_iMCU_row. */
comment|/* In single-pass modes, it's sufficient to buffer just one MCU.    * We allocate a workspace of D_MAX_BLOCKS_IN_MCU coefficient blocks,    * and let the entropy decoder write into that workspace each time.    * (On 80x86, the workspace is FAR even though it's not really very big;    * this is to keep the module interfaces unchanged when a large coefficient    * buffer is necessary.)    * In multi-pass modes, this array points to the current MCU's blocks    * within the virtual arrays; it is used only by the input side.    */
DECL|member|MCU_buffer
name|JBLOCKROW
name|MCU_buffer
index|[
name|D_MAX_BLOCKS_IN_MCU
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|D_MULTISCAN_FILES_SUPPORTED
comment|/* In multi-pass modes, we need a virtual block array for each component. */
DECL|member|whole_image
name|jvirt_barray_ptr
name|whole_image
index|[
name|MAX_COMPONENTS
index|]
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BLOCK_SMOOTHING_SUPPORTED
comment|/* When doing block smoothing, we latch coefficient Al values here */
DECL|member|coef_bits_latch
name|int
modifier|*
name|coef_bits_latch
decl_stmt|;
DECL|macro|SAVED_COEFS
define|#
directive|define
name|SAVED_COEFS
value|6
comment|/* we save coef_bits[0..5] */
endif|#
directive|endif
block|}
DECL|typedef|my_coef_controller
name|my_coef_controller
typedef|;
end_typedef
begin_typedef
DECL|typedef|my_coef_ptr
typedef|typedef
name|my_coef_controller
modifier|*
name|my_coef_ptr
typedef|;
end_typedef
begin_comment
comment|/* Forward declarations */
end_comment
begin_macro
name|METHODDEF
argument_list|(
argument|int
argument_list|)
end_macro
begin_decl_stmt
name|decompress_onepass
name|JPP
argument_list|(
operator|(
name|j_decompress_ptr
name|cinfo
operator|,
name|JSAMPIMAGE
name|output_buf
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt
begin_ifdef
ifdef|#
directive|ifdef
name|D_MULTISCAN_FILES_SUPPORTED
end_ifdef
begin_macro
name|METHODDEF
argument_list|(
argument|int
argument_list|)
end_macro
begin_decl_stmt
name|decompress_data
name|JPP
argument_list|(
operator|(
name|j_decompress_ptr
name|cinfo
operator|,
name|JSAMPIMAGE
name|output_buf
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|BLOCK_SMOOTHING_SUPPORTED
end_ifdef
begin_macro
name|LOCAL
argument_list|(
argument|boolean
argument_list|)
end_macro
begin_decl_stmt
name|smoothing_ok
name|JPP
argument_list|(
operator|(
name|j_decompress_ptr
name|cinfo
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt
begin_macro
DECL|variable|decompress_smooth_data
name|METHODDEF
argument_list|(
argument|int
argument_list|)
end_macro
begin_decl_stmt
DECL|variable|decompress_smooth_data
name|decompress_smooth_data
name|JPP
argument_list|(
operator|(
name|j_decompress_ptr
name|cinfo
operator|,
name|JSAMPIMAGE
name|output_buf
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_macro
name|LOCAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|start_iMCU_row
name|start_iMCU_row
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|)
end_macro
begin_comment
comment|/* Reset within-iMCU-row counters for a new row (input side) */
end_comment
begin_block
block|{
name|my_coef_ptr
name|coef
init|=
operator|(
name|my_coef_ptr
operator|)
name|cinfo
operator|->
name|coef
decl_stmt|;
comment|/* In an interleaved scan, an MCU row is the same as an iMCU row.    * In a noninterleaved scan, an iMCU row has v_samp_factor MCU rows.    * But at the bottom of the image, process only what's left.    */
if|if
condition|(
name|cinfo
operator|->
name|comps_in_scan
operator|>
literal|1
condition|)
block|{
name|coef
operator|->
name|MCU_rows_per_iMCU_row
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|cinfo
operator|->
name|input_iMCU_row
operator|<
operator|(
name|cinfo
operator|->
name|total_iMCU_rows
operator|-
literal|1
operator|)
condition|)
name|coef
operator|->
name|MCU_rows_per_iMCU_row
operator|=
name|cinfo
operator|->
name|cur_comp_info
index|[
literal|0
index|]
operator|->
name|v_samp_factor
expr_stmt|;
else|else
name|coef
operator|->
name|MCU_rows_per_iMCU_row
operator|=
name|cinfo
operator|->
name|cur_comp_info
index|[
literal|0
index|]
operator|->
name|last_row_height
expr_stmt|;
block|}
name|coef
operator|->
name|MCU_ctr
operator|=
literal|0
expr_stmt|;
name|coef
operator|->
name|MCU_vert_offset
operator|=
literal|0
expr_stmt|;
block|}
end_block
begin_comment
comment|/*  * Initialize for an input processing pass.  */
end_comment
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|start_input_pass
name|start_input_pass
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|)
end_macro
begin_block
block|{
name|cinfo
operator|->
name|input_iMCU_row
operator|=
literal|0
expr_stmt|;
name|start_iMCU_row
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
block|}
end_block
begin_comment
comment|/*  * Initialize for an output processing pass.  */
end_comment
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|start_output_pass
name|start_output_pass
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|)
end_macro
begin_block
block|{
ifdef|#
directive|ifdef
name|BLOCK_SMOOTHING_SUPPORTED
name|my_coef_ptr
name|coef
init|=
operator|(
name|my_coef_ptr
operator|)
name|cinfo
operator|->
name|coef
decl_stmt|;
comment|/* If multipass, check to see whether to use block smoothing on this pass */
if|if
condition|(
name|coef
operator|->
name|pub
operator|.
name|coef_arrays
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|cinfo
operator|->
name|do_block_smoothing
operator|&&
name|smoothing_ok
argument_list|(
name|cinfo
argument_list|)
condition|)
name|coef
operator|->
name|pub
operator|.
name|decompress_data
operator|=
name|decompress_smooth_data
expr_stmt|;
else|else
name|coef
operator|->
name|pub
operator|.
name|decompress_data
operator|=
name|decompress_data
expr_stmt|;
block|}
endif|#
directive|endif
name|cinfo
operator|->
name|output_iMCU_row
operator|=
literal|0
expr_stmt|;
block|}
end_block
begin_comment
comment|/*  * Decompress and return some data in the single-pass case.  * Always attempts to emit one fully interleaved MCU row ("iMCU" row).  * Input and output must run in lockstep since we have only a one-MCU buffer.  * Return value is JPEG_ROW_COMPLETED, JPEG_SCAN_COMPLETED, or JPEG_SUSPENDED.  *  * NB: output_buf contains a plane for each component in image,  * which we index according to the component's SOF position.  */
end_comment
begin_macro
name|METHODDEF
argument_list|(
argument|int
argument_list|)
end_macro
begin_macro
DECL|function|decompress_onepass
name|decompress_onepass
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|,
argument|JSAMPIMAGE output_buf
argument_list|)
end_macro
begin_block
block|{
name|my_coef_ptr
name|coef
init|=
operator|(
name|my_coef_ptr
operator|)
name|cinfo
operator|->
name|coef
decl_stmt|;
name|JDIMENSION
name|MCU_col_num
decl_stmt|;
comment|/* index of current MCU within row */
name|JDIMENSION
name|last_MCU_col
init|=
name|cinfo
operator|->
name|MCUs_per_row
operator|-
literal|1
decl_stmt|;
name|JDIMENSION
name|last_iMCU_row
init|=
name|cinfo
operator|->
name|total_iMCU_rows
operator|-
literal|1
decl_stmt|;
name|int
name|blkn
decl_stmt|,
name|ci
decl_stmt|,
name|xindex
decl_stmt|,
name|yindex
decl_stmt|,
name|yoffset
decl_stmt|,
name|useful_width
decl_stmt|;
name|JSAMPARRAY
name|output_ptr
decl_stmt|;
name|JDIMENSION
name|start_col
decl_stmt|,
name|output_col
decl_stmt|;
name|jpeg_component_info
modifier|*
name|compptr
decl_stmt|;
name|inverse_DCT_method_ptr
name|inverse_DCT
decl_stmt|;
comment|/* Loop to process as much as one whole iMCU row */
for|for
control|(
name|yoffset
operator|=
name|coef
operator|->
name|MCU_vert_offset
init|;
name|yoffset
operator|<
name|coef
operator|->
name|MCU_rows_per_iMCU_row
condition|;
name|yoffset
operator|++
control|)
block|{
for|for
control|(
name|MCU_col_num
operator|=
name|coef
operator|->
name|MCU_ctr
init|;
name|MCU_col_num
operator|<=
name|last_MCU_col
condition|;
name|MCU_col_num
operator|++
control|)
block|{
comment|/* Try to fetch an MCU.  Entropy decoder expects buffer to be zeroed. */
name|jzero_far
argument_list|(
operator|(
name|void
name|FAR
operator|*
operator|)
name|coef
operator|->
name|MCU_buffer
index|[
literal|0
index|]
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|cinfo
operator|->
name|blocks_in_MCU
operator|*
name|SIZEOF
argument_list|(
name|JBLOCK
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|cinfo
operator|->
name|entropy
operator|->
name|decode_mcu
call|)
argument_list|(
name|cinfo
argument_list|,
name|coef
operator|->
name|MCU_buffer
argument_list|)
condition|)
block|{
comment|/* Suspension forced; update state counters and exit */
name|coef
operator|->
name|MCU_vert_offset
operator|=
name|yoffset
expr_stmt|;
name|coef
operator|->
name|MCU_ctr
operator|=
name|MCU_col_num
expr_stmt|;
return|return
name|JPEG_SUSPENDED
return|;
block|}
comment|/* Determine where data should go in output_buf and do the IDCT thing.        * We skip dummy blocks at the right and bottom edges (but blkn gets        * incremented past them!).  Note the inner loop relies on having        * allocated the MCU_buffer[] blocks sequentially.        */
name|blkn
operator|=
literal|0
expr_stmt|;
comment|/* index of current DCT block within MCU */
for|for
control|(
name|ci
operator|=
literal|0
init|;
name|ci
operator|<
name|cinfo
operator|->
name|comps_in_scan
condition|;
name|ci
operator|++
control|)
block|{
name|compptr
operator|=
name|cinfo
operator|->
name|cur_comp_info
index|[
name|ci
index|]
expr_stmt|;
comment|/* Don't bother to IDCT an uninteresting component. */
if|if
condition|(
operator|!
name|compptr
operator|->
name|component_needed
condition|)
block|{
name|blkn
operator|+=
name|compptr
operator|->
name|MCU_blocks
expr_stmt|;
continue|continue;
block|}
name|inverse_DCT
operator|=
name|cinfo
operator|->
name|idct
operator|->
name|inverse_DCT
index|[
name|compptr
operator|->
name|component_index
index|]
expr_stmt|;
name|useful_width
operator|=
operator|(
name|MCU_col_num
operator|<
name|last_MCU_col
operator|)
condition|?
name|compptr
operator|->
name|MCU_width
else|:
name|compptr
operator|->
name|last_col_width
expr_stmt|;
name|output_ptr
operator|=
name|output_buf
index|[
name|compptr
operator|->
name|component_index
index|]
operator|+
name|yoffset
operator|*
name|compptr
operator|->
name|DCT_v_scaled_size
expr_stmt|;
name|start_col
operator|=
name|MCU_col_num
operator|*
name|compptr
operator|->
name|MCU_sample_width
expr_stmt|;
for|for
control|(
name|yindex
operator|=
literal|0
init|;
name|yindex
operator|<
name|compptr
operator|->
name|MCU_height
condition|;
name|yindex
operator|++
control|)
block|{
if|if
condition|(
name|cinfo
operator|->
name|input_iMCU_row
operator|<
name|last_iMCU_row
operator|||
name|yoffset
operator|+
name|yindex
operator|<
name|compptr
operator|->
name|last_row_height
condition|)
block|{
name|output_col
operator|=
name|start_col
expr_stmt|;
for|for
control|(
name|xindex
operator|=
literal|0
init|;
name|xindex
operator|<
name|useful_width
condition|;
name|xindex
operator|++
control|)
block|{
call|(
modifier|*
name|inverse_DCT
call|)
argument_list|(
name|cinfo
argument_list|,
name|compptr
argument_list|,
operator|(
name|JCOEFPTR
operator|)
name|coef
operator|->
name|MCU_buffer
index|[
name|blkn
operator|+
name|xindex
index|]
argument_list|,
name|output_ptr
argument_list|,
name|output_col
argument_list|)
expr_stmt|;
name|output_col
operator|+=
name|compptr
operator|->
name|DCT_h_scaled_size
expr_stmt|;
block|}
block|}
name|blkn
operator|+=
name|compptr
operator|->
name|MCU_width
expr_stmt|;
name|output_ptr
operator|+=
name|compptr
operator|->
name|DCT_v_scaled_size
expr_stmt|;
block|}
block|}
block|}
comment|/* Completed an MCU row, but perhaps not an iMCU row */
name|coef
operator|->
name|MCU_ctr
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Completed the iMCU row, advance counters for next one */
name|cinfo
operator|->
name|output_iMCU_row
operator|++
expr_stmt|;
if|if
condition|(
operator|++
operator|(
name|cinfo
operator|->
name|input_iMCU_row
operator|)
operator|<
name|cinfo
operator|->
name|total_iMCU_rows
condition|)
block|{
name|start_iMCU_row
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
return|return
name|JPEG_ROW_COMPLETED
return|;
block|}
comment|/* Completed the scan */
call|(
modifier|*
name|cinfo
operator|->
name|inputctl
operator|->
name|finish_input_pass
call|)
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
return|return
name|JPEG_SCAN_COMPLETED
return|;
block|}
end_block
begin_comment
comment|/*  * Dummy consume-input routine for single-pass operation.  */
end_comment
begin_macro
name|METHODDEF
argument_list|(
argument|int
argument_list|)
end_macro
begin_macro
DECL|function|dummy_consume_data
name|dummy_consume_data
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|)
end_macro
begin_block
block|{
return|return
name|JPEG_SUSPENDED
return|;
comment|/* Always indicate nothing was done */
block|}
end_block
begin_ifdef
ifdef|#
directive|ifdef
name|D_MULTISCAN_FILES_SUPPORTED
end_ifdef
begin_comment
comment|/*  * Consume input data and store it in the full-image coefficient buffer.  * We read as much as one fully interleaved MCU row ("iMCU" row) per call,  * ie, v_samp_factor block rows for each component in the scan.  * Return value is JPEG_ROW_COMPLETED, JPEG_SCAN_COMPLETED, or JPEG_SUSPENDED.  */
end_comment
begin_macro
name|METHODDEF
argument_list|(
argument|int
argument_list|)
end_macro
begin_macro
DECL|function|consume_data
name|consume_data
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|)
end_macro
begin_block
block|{
name|my_coef_ptr
name|coef
init|=
operator|(
name|my_coef_ptr
operator|)
name|cinfo
operator|->
name|coef
decl_stmt|;
name|JDIMENSION
name|MCU_col_num
decl_stmt|;
comment|/* index of current MCU within row */
name|int
name|blkn
decl_stmt|,
name|ci
decl_stmt|,
name|xindex
decl_stmt|,
name|yindex
decl_stmt|,
name|yoffset
decl_stmt|;
name|JDIMENSION
name|start_col
decl_stmt|;
name|JBLOCKARRAY
name|buffer
index|[
name|MAX_COMPS_IN_SCAN
index|]
decl_stmt|;
name|JBLOCKROW
name|buffer_ptr
decl_stmt|;
name|jpeg_component_info
modifier|*
name|compptr
decl_stmt|;
comment|/* Align the virtual buffers for the components used in this scan. */
for|for
control|(
name|ci
operator|=
literal|0
init|;
name|ci
operator|<
name|cinfo
operator|->
name|comps_in_scan
condition|;
name|ci
operator|++
control|)
block|{
name|compptr
operator|=
name|cinfo
operator|->
name|cur_comp_info
index|[
name|ci
index|]
expr_stmt|;
name|buffer
index|[
name|ci
index|]
operator|=
call|(
modifier|*
name|cinfo
operator|->
name|mem
operator|->
name|access_virt_barray
call|)
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|,
name|coef
operator|->
name|whole_image
index|[
name|compptr
operator|->
name|component_index
index|]
argument_list|,
name|cinfo
operator|->
name|input_iMCU_row
operator|*
name|compptr
operator|->
name|v_samp_factor
argument_list|,
operator|(
name|JDIMENSION
operator|)
name|compptr
operator|->
name|v_samp_factor
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* Note: entropy decoder expects buffer to be zeroed,      * but this is handled automatically by the memory manager      * because we requested a pre-zeroed array.      */
block|}
comment|/* Loop to process one whole iMCU row */
for|for
control|(
name|yoffset
operator|=
name|coef
operator|->
name|MCU_vert_offset
init|;
name|yoffset
operator|<
name|coef
operator|->
name|MCU_rows_per_iMCU_row
condition|;
name|yoffset
operator|++
control|)
block|{
for|for
control|(
name|MCU_col_num
operator|=
name|coef
operator|->
name|MCU_ctr
init|;
name|MCU_col_num
operator|<
name|cinfo
operator|->
name|MCUs_per_row
condition|;
name|MCU_col_num
operator|++
control|)
block|{
comment|/* Construct list of pointers to DCT blocks belonging to this MCU */
name|blkn
operator|=
literal|0
expr_stmt|;
comment|/* index of current DCT block within MCU */
for|for
control|(
name|ci
operator|=
literal|0
init|;
name|ci
operator|<
name|cinfo
operator|->
name|comps_in_scan
condition|;
name|ci
operator|++
control|)
block|{
name|compptr
operator|=
name|cinfo
operator|->
name|cur_comp_info
index|[
name|ci
index|]
expr_stmt|;
name|start_col
operator|=
name|MCU_col_num
operator|*
name|compptr
operator|->
name|MCU_width
expr_stmt|;
for|for
control|(
name|yindex
operator|=
literal|0
init|;
name|yindex
operator|<
name|compptr
operator|->
name|MCU_height
condition|;
name|yindex
operator|++
control|)
block|{
name|buffer_ptr
operator|=
name|buffer
index|[
name|ci
index|]
index|[
name|yindex
operator|+
name|yoffset
index|]
operator|+
name|start_col
expr_stmt|;
for|for
control|(
name|xindex
operator|=
literal|0
init|;
name|xindex
operator|<
name|compptr
operator|->
name|MCU_width
condition|;
name|xindex
operator|++
control|)
block|{
name|coef
operator|->
name|MCU_buffer
index|[
name|blkn
operator|++
index|]
operator|=
name|buffer_ptr
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|/* Try to fetch the MCU. */
if|if
condition|(
operator|!
call|(
modifier|*
name|cinfo
operator|->
name|entropy
operator|->
name|decode_mcu
call|)
argument_list|(
name|cinfo
argument_list|,
name|coef
operator|->
name|MCU_buffer
argument_list|)
condition|)
block|{
comment|/* Suspension forced; update state counters and exit */
name|coef
operator|->
name|MCU_vert_offset
operator|=
name|yoffset
expr_stmt|;
name|coef
operator|->
name|MCU_ctr
operator|=
name|MCU_col_num
expr_stmt|;
return|return
name|JPEG_SUSPENDED
return|;
block|}
block|}
comment|/* Completed an MCU row, but perhaps not an iMCU row */
name|coef
operator|->
name|MCU_ctr
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Completed the iMCU row, advance counters for next one */
if|if
condition|(
operator|++
operator|(
name|cinfo
operator|->
name|input_iMCU_row
operator|)
operator|<
name|cinfo
operator|->
name|total_iMCU_rows
condition|)
block|{
name|start_iMCU_row
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
return|return
name|JPEG_ROW_COMPLETED
return|;
block|}
comment|/* Completed the scan */
call|(
modifier|*
name|cinfo
operator|->
name|inputctl
operator|->
name|finish_input_pass
call|)
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
return|return
name|JPEG_SCAN_COMPLETED
return|;
block|}
end_block
begin_comment
comment|/*  * Decompress and return some data in the multi-pass case.  * Always attempts to emit one fully interleaved MCU row ("iMCU" row).  * Return value is JPEG_ROW_COMPLETED, JPEG_SCAN_COMPLETED, or JPEG_SUSPENDED.  *  * NB: output_buf contains a plane for each component in image.  */
end_comment
begin_macro
name|METHODDEF
argument_list|(
argument|int
argument_list|)
end_macro
begin_macro
DECL|function|decompress_data
name|decompress_data
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|,
argument|JSAMPIMAGE output_buf
argument_list|)
end_macro
begin_block
block|{
name|my_coef_ptr
name|coef
init|=
operator|(
name|my_coef_ptr
operator|)
name|cinfo
operator|->
name|coef
decl_stmt|;
name|JDIMENSION
name|last_iMCU_row
init|=
name|cinfo
operator|->
name|total_iMCU_rows
operator|-
literal|1
decl_stmt|;
name|JDIMENSION
name|block_num
decl_stmt|;
name|int
name|ci
decl_stmt|,
name|block_row
decl_stmt|,
name|block_rows
decl_stmt|;
name|JBLOCKARRAY
name|buffer
decl_stmt|;
name|JBLOCKROW
name|buffer_ptr
decl_stmt|;
name|JSAMPARRAY
name|output_ptr
decl_stmt|;
name|JDIMENSION
name|output_col
decl_stmt|;
name|jpeg_component_info
modifier|*
name|compptr
decl_stmt|;
name|inverse_DCT_method_ptr
name|inverse_DCT
decl_stmt|;
comment|/* Force some input to be done if we are getting ahead of the input. */
while|while
condition|(
name|cinfo
operator|->
name|input_scan_number
operator|<
name|cinfo
operator|->
name|output_scan_number
operator|||
operator|(
name|cinfo
operator|->
name|input_scan_number
operator|==
name|cinfo
operator|->
name|output_scan_number
operator|&&
name|cinfo
operator|->
name|input_iMCU_row
operator|<=
name|cinfo
operator|->
name|output_iMCU_row
operator|)
condition|)
block|{
if|if
condition|(
call|(
modifier|*
name|cinfo
operator|->
name|inputctl
operator|->
name|consume_input
call|)
argument_list|(
name|cinfo
argument_list|)
operator|==
name|JPEG_SUSPENDED
condition|)
return|return
name|JPEG_SUSPENDED
return|;
block|}
comment|/* OK, output from the virtual arrays. */
for|for
control|(
name|ci
operator|=
literal|0
operator|,
name|compptr
operator|=
name|cinfo
operator|->
name|comp_info
init|;
name|ci
operator|<
name|cinfo
operator|->
name|num_components
condition|;
name|ci
operator|++
operator|,
name|compptr
operator|++
control|)
block|{
comment|/* Don't bother to IDCT an uninteresting component. */
if|if
condition|(
operator|!
name|compptr
operator|->
name|component_needed
condition|)
continue|continue;
comment|/* Align the virtual buffer for this component. */
name|buffer
operator|=
call|(
modifier|*
name|cinfo
operator|->
name|mem
operator|->
name|access_virt_barray
call|)
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|,
name|coef
operator|->
name|whole_image
index|[
name|ci
index|]
argument_list|,
name|cinfo
operator|->
name|output_iMCU_row
operator|*
name|compptr
operator|->
name|v_samp_factor
argument_list|,
operator|(
name|JDIMENSION
operator|)
name|compptr
operator|->
name|v_samp_factor
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* Count non-dummy DCT block rows in this iMCU row. */
if|if
condition|(
name|cinfo
operator|->
name|output_iMCU_row
operator|<
name|last_iMCU_row
condition|)
name|block_rows
operator|=
name|compptr
operator|->
name|v_samp_factor
expr_stmt|;
else|else
block|{
comment|/* NB: can't use last_row_height here; it is input-side-dependent! */
name|block_rows
operator|=
call|(
name|int
call|)
argument_list|(
name|compptr
operator|->
name|height_in_blocks
operator|%
name|compptr
operator|->
name|v_samp_factor
argument_list|)
expr_stmt|;
if|if
condition|(
name|block_rows
operator|==
literal|0
condition|)
name|block_rows
operator|=
name|compptr
operator|->
name|v_samp_factor
expr_stmt|;
block|}
name|inverse_DCT
operator|=
name|cinfo
operator|->
name|idct
operator|->
name|inverse_DCT
index|[
name|ci
index|]
expr_stmt|;
name|output_ptr
operator|=
name|output_buf
index|[
name|ci
index|]
expr_stmt|;
comment|/* Loop over all DCT blocks to be processed. */
for|for
control|(
name|block_row
operator|=
literal|0
init|;
name|block_row
operator|<
name|block_rows
condition|;
name|block_row
operator|++
control|)
block|{
name|buffer_ptr
operator|=
name|buffer
index|[
name|block_row
index|]
expr_stmt|;
name|output_col
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|block_num
operator|=
literal|0
init|;
name|block_num
operator|<
name|compptr
operator|->
name|width_in_blocks
condition|;
name|block_num
operator|++
control|)
block|{
call|(
modifier|*
name|inverse_DCT
call|)
argument_list|(
name|cinfo
argument_list|,
name|compptr
argument_list|,
operator|(
name|JCOEFPTR
operator|)
name|buffer_ptr
argument_list|,
name|output_ptr
argument_list|,
name|output_col
argument_list|)
expr_stmt|;
name|buffer_ptr
operator|++
expr_stmt|;
name|output_col
operator|+=
name|compptr
operator|->
name|DCT_h_scaled_size
expr_stmt|;
block|}
name|output_ptr
operator|+=
name|compptr
operator|->
name|DCT_v_scaled_size
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|++
operator|(
name|cinfo
operator|->
name|output_iMCU_row
operator|)
operator|<
name|cinfo
operator|->
name|total_iMCU_rows
condition|)
return|return
name|JPEG_ROW_COMPLETED
return|;
return|return
name|JPEG_SCAN_COMPLETED
return|;
block|}
end_block
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* D_MULTISCAN_FILES_SUPPORTED */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|BLOCK_SMOOTHING_SUPPORTED
end_ifdef
begin_comment
comment|/*  * This code applies interblock smoothing as described by section K.8  * of the JPEG standard: the first 5 AC coefficients are estimated from  * the DC values of a DCT block and its 8 neighboring blocks.  * We apply smoothing only for progressive JPEG decoding, and only if  * the coefficients it can estimate are not yet known to full precision.  */
end_comment
begin_comment
comment|/* Natural-order array positions of the first 5 zigzag-order coefficients */
end_comment
begin_define
DECL|macro|Q01_POS
define|#
directive|define
name|Q01_POS
value|1
end_define
begin_define
DECL|macro|Q10_POS
define|#
directive|define
name|Q10_POS
value|8
end_define
begin_define
DECL|macro|Q20_POS
define|#
directive|define
name|Q20_POS
value|16
end_define
begin_define
DECL|macro|Q11_POS
define|#
directive|define
name|Q11_POS
value|9
end_define
begin_define
DECL|macro|Q02_POS
define|#
directive|define
name|Q02_POS
value|2
end_define
begin_comment
comment|/*  * Determine whether block smoothing is applicable and safe.  * We also latch the current states of the coef_bits[] entries for the  * AC coefficients; otherwise, if the input side of the decompressor  * advances into a new scan, we might think the coefficients are known  * more accurately than they really are.  */
end_comment
begin_macro
DECL|function|LOCAL
name|LOCAL
argument_list|(
argument|boolean
argument_list|)
end_macro
begin_macro
name|smoothing_ok
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|)
end_macro
begin_block
block|{
name|my_coef_ptr
name|coef
init|=
operator|(
name|my_coef_ptr
operator|)
name|cinfo
operator|->
name|coef
decl_stmt|;
name|boolean
name|smoothing_useful
init|=
name|FALSE
decl_stmt|;
name|int
name|ci
decl_stmt|,
name|coefi
decl_stmt|;
name|jpeg_component_info
modifier|*
name|compptr
decl_stmt|;
name|JQUANT_TBL
modifier|*
name|qtable
decl_stmt|;
name|int
modifier|*
name|coef_bits
decl_stmt|;
name|int
modifier|*
name|coef_bits_latch
decl_stmt|;
if|if
condition|(
operator|!
name|cinfo
operator|->
name|progressive_mode
operator|||
name|cinfo
operator|->
name|coef_bits
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
comment|/* Allocate latch area if not already done */
if|if
condition|(
name|coef
operator|->
name|coef_bits_latch
operator|==
name|NULL
condition|)
name|coef
operator|->
name|coef_bits_latch
operator|=
operator|(
name|int
operator|*
operator|)
call|(
modifier|*
name|cinfo
operator|->
name|mem
operator|->
name|alloc_small
call|)
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|,
name|JPOOL_IMAGE
argument_list|,
name|cinfo
operator|->
name|num_components
operator|*
operator|(
name|SAVED_COEFS
operator|*
name|SIZEOF
argument_list|(
name|int
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|coef_bits_latch
operator|=
name|coef
operator|->
name|coef_bits_latch
expr_stmt|;
for|for
control|(
name|ci
operator|=
literal|0
operator|,
name|compptr
operator|=
name|cinfo
operator|->
name|comp_info
init|;
name|ci
operator|<
name|cinfo
operator|->
name|num_components
condition|;
name|ci
operator|++
operator|,
name|compptr
operator|++
control|)
block|{
comment|/* All components' quantization values must already be latched. */
if|if
condition|(
operator|(
name|qtable
operator|=
name|compptr
operator|->
name|quant_table
operator|)
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
comment|/* Verify DC& first 5 AC quantizers are nonzero to avoid zero-divide. */
if|if
condition|(
name|qtable
operator|->
name|quantval
index|[
literal|0
index|]
operator|==
literal|0
operator|||
name|qtable
operator|->
name|quantval
index|[
name|Q01_POS
index|]
operator|==
literal|0
operator|||
name|qtable
operator|->
name|quantval
index|[
name|Q10_POS
index|]
operator|==
literal|0
operator|||
name|qtable
operator|->
name|quantval
index|[
name|Q20_POS
index|]
operator|==
literal|0
operator|||
name|qtable
operator|->
name|quantval
index|[
name|Q11_POS
index|]
operator|==
literal|0
operator|||
name|qtable
operator|->
name|quantval
index|[
name|Q02_POS
index|]
operator|==
literal|0
condition|)
return|return
name|FALSE
return|;
comment|/* DC values must be at least partly known for all components. */
name|coef_bits
operator|=
name|cinfo
operator|->
name|coef_bits
index|[
name|ci
index|]
expr_stmt|;
if|if
condition|(
name|coef_bits
index|[
literal|0
index|]
operator|<
literal|0
condition|)
return|return
name|FALSE
return|;
comment|/* Block smoothing is helpful if some AC coefficients remain inaccurate. */
for|for
control|(
name|coefi
operator|=
literal|1
init|;
name|coefi
operator|<=
literal|5
condition|;
name|coefi
operator|++
control|)
block|{
name|coef_bits_latch
index|[
name|coefi
index|]
operator|=
name|coef_bits
index|[
name|coefi
index|]
expr_stmt|;
if|if
condition|(
name|coef_bits
index|[
name|coefi
index|]
operator|!=
literal|0
condition|)
name|smoothing_useful
operator|=
name|TRUE
expr_stmt|;
block|}
name|coef_bits_latch
operator|+=
name|SAVED_COEFS
expr_stmt|;
block|}
return|return
name|smoothing_useful
return|;
block|}
end_block
begin_comment
comment|/*  * Variant of decompress_data for use when doing block smoothing.  */
end_comment
begin_macro
name|METHODDEF
argument_list|(
argument|int
argument_list|)
end_macro
begin_macro
DECL|function|decompress_smooth_data
name|decompress_smooth_data
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|,
argument|JSAMPIMAGE output_buf
argument_list|)
end_macro
begin_block
block|{
name|my_coef_ptr
name|coef
init|=
operator|(
name|my_coef_ptr
operator|)
name|cinfo
operator|->
name|coef
decl_stmt|;
name|JDIMENSION
name|last_iMCU_row
init|=
name|cinfo
operator|->
name|total_iMCU_rows
operator|-
literal|1
decl_stmt|;
name|JDIMENSION
name|block_num
decl_stmt|,
name|last_block_column
decl_stmt|;
name|int
name|ci
decl_stmt|,
name|block_row
decl_stmt|,
name|block_rows
decl_stmt|,
name|access_rows
decl_stmt|;
name|JBLOCKARRAY
name|buffer
decl_stmt|;
name|JBLOCKROW
name|buffer_ptr
decl_stmt|,
name|prev_block_row
decl_stmt|,
name|next_block_row
decl_stmt|;
name|JSAMPARRAY
name|output_ptr
decl_stmt|;
name|JDIMENSION
name|output_col
decl_stmt|;
name|jpeg_component_info
modifier|*
name|compptr
decl_stmt|;
name|inverse_DCT_method_ptr
name|inverse_DCT
decl_stmt|;
name|boolean
name|first_row
decl_stmt|,
name|last_row
decl_stmt|;
name|JBLOCK
name|workspace
decl_stmt|;
name|int
modifier|*
name|coef_bits
decl_stmt|;
name|JQUANT_TBL
modifier|*
name|quanttbl
decl_stmt|;
name|INT32
name|Q00
decl_stmt|,
name|Q01
decl_stmt|,
name|Q02
decl_stmt|,
name|Q10
decl_stmt|,
name|Q11
decl_stmt|,
name|Q20
decl_stmt|,
name|num
decl_stmt|;
name|int
name|DC1
decl_stmt|,
name|DC2
decl_stmt|,
name|DC3
decl_stmt|,
name|DC4
decl_stmt|,
name|DC5
decl_stmt|,
name|DC6
decl_stmt|,
name|DC7
decl_stmt|,
name|DC8
decl_stmt|,
name|DC9
decl_stmt|;
name|int
name|Al
decl_stmt|,
name|pred
decl_stmt|;
comment|/* Force some input to be done if we are getting ahead of the input. */
while|while
condition|(
name|cinfo
operator|->
name|input_scan_number
operator|<=
name|cinfo
operator|->
name|output_scan_number
operator|&&
operator|!
name|cinfo
operator|->
name|inputctl
operator|->
name|eoi_reached
condition|)
block|{
if|if
condition|(
name|cinfo
operator|->
name|input_scan_number
operator|==
name|cinfo
operator|->
name|output_scan_number
condition|)
block|{
comment|/* If input is working on current scan, we ordinarily want it to        * have completed the current row.  But if input scan is DC,        * we want it to keep one row ahead so that next block row's DC        * values are up to date.        */
name|JDIMENSION
name|delta
init|=
operator|(
name|cinfo
operator|->
name|Ss
operator|==
literal|0
operator|)
condition|?
literal|1
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|cinfo
operator|->
name|input_iMCU_row
operator|>
name|cinfo
operator|->
name|output_iMCU_row
operator|+
name|delta
condition|)
break|break;
block|}
if|if
condition|(
call|(
modifier|*
name|cinfo
operator|->
name|inputctl
operator|->
name|consume_input
call|)
argument_list|(
name|cinfo
argument_list|)
operator|==
name|JPEG_SUSPENDED
condition|)
return|return
name|JPEG_SUSPENDED
return|;
block|}
comment|/* OK, output from the virtual arrays. */
for|for
control|(
name|ci
operator|=
literal|0
operator|,
name|compptr
operator|=
name|cinfo
operator|->
name|comp_info
init|;
name|ci
operator|<
name|cinfo
operator|->
name|num_components
condition|;
name|ci
operator|++
operator|,
name|compptr
operator|++
control|)
block|{
comment|/* Don't bother to IDCT an uninteresting component. */
if|if
condition|(
operator|!
name|compptr
operator|->
name|component_needed
condition|)
continue|continue;
comment|/* Count non-dummy DCT block rows in this iMCU row. */
if|if
condition|(
name|cinfo
operator|->
name|output_iMCU_row
operator|<
name|last_iMCU_row
condition|)
block|{
name|block_rows
operator|=
name|compptr
operator|->
name|v_samp_factor
expr_stmt|;
name|access_rows
operator|=
name|block_rows
operator|*
literal|2
expr_stmt|;
comment|/* this and next iMCU row */
name|last_row
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
comment|/* NB: can't use last_row_height here; it is input-side-dependent! */
name|block_rows
operator|=
call|(
name|int
call|)
argument_list|(
name|compptr
operator|->
name|height_in_blocks
operator|%
name|compptr
operator|->
name|v_samp_factor
argument_list|)
expr_stmt|;
if|if
condition|(
name|block_rows
operator|==
literal|0
condition|)
name|block_rows
operator|=
name|compptr
operator|->
name|v_samp_factor
expr_stmt|;
name|access_rows
operator|=
name|block_rows
expr_stmt|;
comment|/* this iMCU row only */
name|last_row
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* Align the virtual buffer for this component. */
if|if
condition|(
name|cinfo
operator|->
name|output_iMCU_row
operator|>
literal|0
condition|)
block|{
name|access_rows
operator|+=
name|compptr
operator|->
name|v_samp_factor
expr_stmt|;
comment|/* prior iMCU row too */
name|buffer
operator|=
call|(
modifier|*
name|cinfo
operator|->
name|mem
operator|->
name|access_virt_barray
call|)
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|,
name|coef
operator|->
name|whole_image
index|[
name|ci
index|]
argument_list|,
operator|(
name|cinfo
operator|->
name|output_iMCU_row
operator|-
literal|1
operator|)
operator|*
name|compptr
operator|->
name|v_samp_factor
argument_list|,
operator|(
name|JDIMENSION
operator|)
name|access_rows
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|buffer
operator|+=
name|compptr
operator|->
name|v_samp_factor
expr_stmt|;
comment|/* point to current iMCU row */
name|first_row
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|buffer
operator|=
call|(
modifier|*
name|cinfo
operator|->
name|mem
operator|->
name|access_virt_barray
call|)
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|,
name|coef
operator|->
name|whole_image
index|[
name|ci
index|]
argument_list|,
operator|(
name|JDIMENSION
operator|)
literal|0
argument_list|,
operator|(
name|JDIMENSION
operator|)
name|access_rows
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|first_row
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* Fetch component-dependent info */
name|coef_bits
operator|=
name|coef
operator|->
name|coef_bits_latch
operator|+
operator|(
name|ci
operator|*
name|SAVED_COEFS
operator|)
expr_stmt|;
name|quanttbl
operator|=
name|compptr
operator|->
name|quant_table
expr_stmt|;
name|Q00
operator|=
name|quanttbl
operator|->
name|quantval
index|[
literal|0
index|]
expr_stmt|;
name|Q01
operator|=
name|quanttbl
operator|->
name|quantval
index|[
name|Q01_POS
index|]
expr_stmt|;
name|Q10
operator|=
name|quanttbl
operator|->
name|quantval
index|[
name|Q10_POS
index|]
expr_stmt|;
name|Q20
operator|=
name|quanttbl
operator|->
name|quantval
index|[
name|Q20_POS
index|]
expr_stmt|;
name|Q11
operator|=
name|quanttbl
operator|->
name|quantval
index|[
name|Q11_POS
index|]
expr_stmt|;
name|Q02
operator|=
name|quanttbl
operator|->
name|quantval
index|[
name|Q02_POS
index|]
expr_stmt|;
name|inverse_DCT
operator|=
name|cinfo
operator|->
name|idct
operator|->
name|inverse_DCT
index|[
name|ci
index|]
expr_stmt|;
name|output_ptr
operator|=
name|output_buf
index|[
name|ci
index|]
expr_stmt|;
comment|/* Loop over all DCT blocks to be processed. */
for|for
control|(
name|block_row
operator|=
literal|0
init|;
name|block_row
operator|<
name|block_rows
condition|;
name|block_row
operator|++
control|)
block|{
name|buffer_ptr
operator|=
name|buffer
index|[
name|block_row
index|]
expr_stmt|;
if|if
condition|(
name|first_row
operator|&&
name|block_row
operator|==
literal|0
condition|)
name|prev_block_row
operator|=
name|buffer_ptr
expr_stmt|;
else|else
name|prev_block_row
operator|=
name|buffer
index|[
name|block_row
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|last_row
operator|&&
name|block_row
operator|==
name|block_rows
operator|-
literal|1
condition|)
name|next_block_row
operator|=
name|buffer_ptr
expr_stmt|;
else|else
name|next_block_row
operator|=
name|buffer
index|[
name|block_row
operator|+
literal|1
index|]
expr_stmt|;
comment|/* We fetch the surrounding DC values using a sliding-register approach.        * Initialize all nine here so as to do the right thing on narrow pics.        */
name|DC1
operator|=
name|DC2
operator|=
name|DC3
operator|=
operator|(
name|int
operator|)
name|prev_block_row
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
name|DC4
operator|=
name|DC5
operator|=
name|DC6
operator|=
operator|(
name|int
operator|)
name|buffer_ptr
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
name|DC7
operator|=
name|DC8
operator|=
name|DC9
operator|=
operator|(
name|int
operator|)
name|next_block_row
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
name|output_col
operator|=
literal|0
expr_stmt|;
name|last_block_column
operator|=
name|compptr
operator|->
name|width_in_blocks
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|block_num
operator|=
literal|0
init|;
name|block_num
operator|<=
name|last_block_column
condition|;
name|block_num
operator|++
control|)
block|{
comment|/* Fetch current DCT block into workspace so we can modify it. */
name|jcopy_block_row
argument_list|(
name|buffer_ptr
argument_list|,
operator|(
name|JBLOCKROW
operator|)
name|workspace
argument_list|,
operator|(
name|JDIMENSION
operator|)
literal|1
argument_list|)
expr_stmt|;
comment|/* Update DC values */
if|if
condition|(
name|block_num
operator|<
name|last_block_column
condition|)
block|{
name|DC3
operator|=
operator|(
name|int
operator|)
name|prev_block_row
index|[
literal|1
index|]
index|[
literal|0
index|]
expr_stmt|;
name|DC6
operator|=
operator|(
name|int
operator|)
name|buffer_ptr
index|[
literal|1
index|]
index|[
literal|0
index|]
expr_stmt|;
name|DC9
operator|=
operator|(
name|int
operator|)
name|next_block_row
index|[
literal|1
index|]
index|[
literal|0
index|]
expr_stmt|;
block|}
comment|/* Compute coefficient estimates per K.8. 	 * An estimate is applied only if coefficient is still zero, 	 * and is not known to be fully accurate. 	 */
comment|/* AC01 */
if|if
condition|(
operator|(
name|Al
operator|=
name|coef_bits
index|[
literal|1
index|]
operator|)
operator|!=
literal|0
operator|&&
name|workspace
index|[
literal|1
index|]
operator|==
literal|0
condition|)
block|{
name|num
operator|=
literal|36
operator|*
name|Q00
operator|*
operator|(
name|DC4
operator|-
name|DC6
operator|)
expr_stmt|;
if|if
condition|(
name|num
operator|>=
literal|0
condition|)
block|{
name|pred
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
operator|(
name|Q01
operator|<<
literal|7
operator|)
operator|+
name|num
operator|)
operator|/
operator|(
name|Q01
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|Al
operator|>
literal|0
operator|&&
name|pred
operator|>=
operator|(
literal|1
operator|<<
name|Al
operator|)
condition|)
name|pred
operator|=
operator|(
literal|1
operator|<<
name|Al
operator|)
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|pred
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
operator|(
name|Q01
operator|<<
literal|7
operator|)
operator|-
name|num
operator|)
operator|/
operator|(
name|Q01
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|Al
operator|>
literal|0
operator|&&
name|pred
operator|>=
operator|(
literal|1
operator|<<
name|Al
operator|)
condition|)
name|pred
operator|=
operator|(
literal|1
operator|<<
name|Al
operator|)
operator|-
literal|1
expr_stmt|;
name|pred
operator|=
operator|-
name|pred
expr_stmt|;
block|}
name|workspace
index|[
literal|1
index|]
operator|=
operator|(
name|JCOEF
operator|)
name|pred
expr_stmt|;
block|}
comment|/* AC10 */
if|if
condition|(
operator|(
name|Al
operator|=
name|coef_bits
index|[
literal|2
index|]
operator|)
operator|!=
literal|0
operator|&&
name|workspace
index|[
literal|8
index|]
operator|==
literal|0
condition|)
block|{
name|num
operator|=
literal|36
operator|*
name|Q00
operator|*
operator|(
name|DC2
operator|-
name|DC8
operator|)
expr_stmt|;
if|if
condition|(
name|num
operator|>=
literal|0
condition|)
block|{
name|pred
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
operator|(
name|Q10
operator|<<
literal|7
operator|)
operator|+
name|num
operator|)
operator|/
operator|(
name|Q10
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|Al
operator|>
literal|0
operator|&&
name|pred
operator|>=
operator|(
literal|1
operator|<<
name|Al
operator|)
condition|)
name|pred
operator|=
operator|(
literal|1
operator|<<
name|Al
operator|)
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|pred
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
operator|(
name|Q10
operator|<<
literal|7
operator|)
operator|-
name|num
operator|)
operator|/
operator|(
name|Q10
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|Al
operator|>
literal|0
operator|&&
name|pred
operator|>=
operator|(
literal|1
operator|<<
name|Al
operator|)
condition|)
name|pred
operator|=
operator|(
literal|1
operator|<<
name|Al
operator|)
operator|-
literal|1
expr_stmt|;
name|pred
operator|=
operator|-
name|pred
expr_stmt|;
block|}
name|workspace
index|[
literal|8
index|]
operator|=
operator|(
name|JCOEF
operator|)
name|pred
expr_stmt|;
block|}
comment|/* AC20 */
if|if
condition|(
operator|(
name|Al
operator|=
name|coef_bits
index|[
literal|3
index|]
operator|)
operator|!=
literal|0
operator|&&
name|workspace
index|[
literal|16
index|]
operator|==
literal|0
condition|)
block|{
name|num
operator|=
literal|9
operator|*
name|Q00
operator|*
operator|(
name|DC2
operator|+
name|DC8
operator|-
literal|2
operator|*
name|DC5
operator|)
expr_stmt|;
if|if
condition|(
name|num
operator|>=
literal|0
condition|)
block|{
name|pred
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
operator|(
name|Q20
operator|<<
literal|7
operator|)
operator|+
name|num
operator|)
operator|/
operator|(
name|Q20
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|Al
operator|>
literal|0
operator|&&
name|pred
operator|>=
operator|(
literal|1
operator|<<
name|Al
operator|)
condition|)
name|pred
operator|=
operator|(
literal|1
operator|<<
name|Al
operator|)
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|pred
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
operator|(
name|Q20
operator|<<
literal|7
operator|)
operator|-
name|num
operator|)
operator|/
operator|(
name|Q20
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|Al
operator|>
literal|0
operator|&&
name|pred
operator|>=
operator|(
literal|1
operator|<<
name|Al
operator|)
condition|)
name|pred
operator|=
operator|(
literal|1
operator|<<
name|Al
operator|)
operator|-
literal|1
expr_stmt|;
name|pred
operator|=
operator|-
name|pred
expr_stmt|;
block|}
name|workspace
index|[
literal|16
index|]
operator|=
operator|(
name|JCOEF
operator|)
name|pred
expr_stmt|;
block|}
comment|/* AC11 */
if|if
condition|(
operator|(
name|Al
operator|=
name|coef_bits
index|[
literal|4
index|]
operator|)
operator|!=
literal|0
operator|&&
name|workspace
index|[
literal|9
index|]
operator|==
literal|0
condition|)
block|{
name|num
operator|=
literal|5
operator|*
name|Q00
operator|*
operator|(
name|DC1
operator|-
name|DC3
operator|-
name|DC7
operator|+
name|DC9
operator|)
expr_stmt|;
if|if
condition|(
name|num
operator|>=
literal|0
condition|)
block|{
name|pred
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
operator|(
name|Q11
operator|<<
literal|7
operator|)
operator|+
name|num
operator|)
operator|/
operator|(
name|Q11
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|Al
operator|>
literal|0
operator|&&
name|pred
operator|>=
operator|(
literal|1
operator|<<
name|Al
operator|)
condition|)
name|pred
operator|=
operator|(
literal|1
operator|<<
name|Al
operator|)
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|pred
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
operator|(
name|Q11
operator|<<
literal|7
operator|)
operator|-
name|num
operator|)
operator|/
operator|(
name|Q11
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|Al
operator|>
literal|0
operator|&&
name|pred
operator|>=
operator|(
literal|1
operator|<<
name|Al
operator|)
condition|)
name|pred
operator|=
operator|(
literal|1
operator|<<
name|Al
operator|)
operator|-
literal|1
expr_stmt|;
name|pred
operator|=
operator|-
name|pred
expr_stmt|;
block|}
name|workspace
index|[
literal|9
index|]
operator|=
operator|(
name|JCOEF
operator|)
name|pred
expr_stmt|;
block|}
comment|/* AC02 */
if|if
condition|(
operator|(
name|Al
operator|=
name|coef_bits
index|[
literal|5
index|]
operator|)
operator|!=
literal|0
operator|&&
name|workspace
index|[
literal|2
index|]
operator|==
literal|0
condition|)
block|{
name|num
operator|=
literal|9
operator|*
name|Q00
operator|*
operator|(
name|DC4
operator|+
name|DC6
operator|-
literal|2
operator|*
name|DC5
operator|)
expr_stmt|;
if|if
condition|(
name|num
operator|>=
literal|0
condition|)
block|{
name|pred
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
operator|(
name|Q02
operator|<<
literal|7
operator|)
operator|+
name|num
operator|)
operator|/
operator|(
name|Q02
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|Al
operator|>
literal|0
operator|&&
name|pred
operator|>=
operator|(
literal|1
operator|<<
name|Al
operator|)
condition|)
name|pred
operator|=
operator|(
literal|1
operator|<<
name|Al
operator|)
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|pred
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
operator|(
name|Q02
operator|<<
literal|7
operator|)
operator|-
name|num
operator|)
operator|/
operator|(
name|Q02
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|Al
operator|>
literal|0
operator|&&
name|pred
operator|>=
operator|(
literal|1
operator|<<
name|Al
operator|)
condition|)
name|pred
operator|=
operator|(
literal|1
operator|<<
name|Al
operator|)
operator|-
literal|1
expr_stmt|;
name|pred
operator|=
operator|-
name|pred
expr_stmt|;
block|}
name|workspace
index|[
literal|2
index|]
operator|=
operator|(
name|JCOEF
operator|)
name|pred
expr_stmt|;
block|}
comment|/* OK, do the IDCT */
call|(
modifier|*
name|inverse_DCT
call|)
argument_list|(
name|cinfo
argument_list|,
name|compptr
argument_list|,
operator|(
name|JCOEFPTR
operator|)
name|workspace
argument_list|,
name|output_ptr
argument_list|,
name|output_col
argument_list|)
expr_stmt|;
comment|/* Advance for next column */
name|DC1
operator|=
name|DC2
expr_stmt|;
name|DC2
operator|=
name|DC3
expr_stmt|;
name|DC4
operator|=
name|DC5
expr_stmt|;
name|DC5
operator|=
name|DC6
expr_stmt|;
name|DC7
operator|=
name|DC8
expr_stmt|;
name|DC8
operator|=
name|DC9
expr_stmt|;
name|buffer_ptr
operator|++
operator|,
name|prev_block_row
operator|++
operator|,
name|next_block_row
operator|++
expr_stmt|;
name|output_col
operator|+=
name|compptr
operator|->
name|DCT_h_scaled_size
expr_stmt|;
block|}
name|output_ptr
operator|+=
name|compptr
operator|->
name|DCT_v_scaled_size
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|++
operator|(
name|cinfo
operator|->
name|output_iMCU_row
operator|)
operator|<
name|cinfo
operator|->
name|total_iMCU_rows
condition|)
return|return
name|JPEG_ROW_COMPLETED
return|;
return|return
name|JPEG_SCAN_COMPLETED
return|;
block|}
end_block
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* BLOCK_SMOOTHING_SUPPORTED */
end_comment
begin_comment
comment|/*  * Initialize coefficient buffer controller.  */
end_comment
begin_macro
name|GLOBAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|jinit_d_coef_controller
name|jinit_d_coef_controller
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|,
argument|boolean need_full_buffer
argument_list|)
end_macro
begin_block
block|{
name|my_coef_ptr
name|coef
decl_stmt|;
name|coef
operator|=
call|(
name|my_coef_ptr
call|)
argument_list|(
operator|*
name|cinfo
operator|->
name|mem
operator|->
name|alloc_small
argument_list|)
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|,
name|JPOOL_IMAGE
argument_list|,
name|SIZEOF
argument_list|(
name|my_coef_controller
argument_list|)
argument_list|)
expr_stmt|;
name|cinfo
operator|->
name|coef
operator|=
operator|(
expr|struct
name|jpeg_d_coef_controller
operator|*
operator|)
name|coef
expr_stmt|;
name|coef
operator|->
name|pub
operator|.
name|start_input_pass
operator|=
name|start_input_pass
expr_stmt|;
name|coef
operator|->
name|pub
operator|.
name|start_output_pass
operator|=
name|start_output_pass
expr_stmt|;
ifdef|#
directive|ifdef
name|BLOCK_SMOOTHING_SUPPORTED
name|coef
operator|->
name|coef_bits_latch
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
comment|/* Create the coefficient buffer. */
if|if
condition|(
name|need_full_buffer
condition|)
block|{
ifdef|#
directive|ifdef
name|D_MULTISCAN_FILES_SUPPORTED
comment|/* Allocate a full-image virtual array for each component, */
comment|/* padded to a multiple of samp_factor DCT blocks in each direction. */
comment|/* Note we ask for a pre-zeroed array. */
name|int
name|ci
decl_stmt|,
name|access_rows
decl_stmt|;
name|jpeg_component_info
modifier|*
name|compptr
decl_stmt|;
for|for
control|(
name|ci
operator|=
literal|0
operator|,
name|compptr
operator|=
name|cinfo
operator|->
name|comp_info
init|;
name|ci
operator|<
name|cinfo
operator|->
name|num_components
condition|;
name|ci
operator|++
operator|,
name|compptr
operator|++
control|)
block|{
name|access_rows
operator|=
name|compptr
operator|->
name|v_samp_factor
expr_stmt|;
ifdef|#
directive|ifdef
name|BLOCK_SMOOTHING_SUPPORTED
comment|/* If block smoothing could be used, need a bigger window */
if|if
condition|(
name|cinfo
operator|->
name|progressive_mode
condition|)
name|access_rows
operator|*=
literal|3
expr_stmt|;
endif|#
directive|endif
name|coef
operator|->
name|whole_image
index|[
name|ci
index|]
operator|=
call|(
modifier|*
name|cinfo
operator|->
name|mem
operator|->
name|request_virt_barray
call|)
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|,
name|JPOOL_IMAGE
argument_list|,
name|TRUE
argument_list|,
operator|(
name|JDIMENSION
operator|)
name|jround_up
argument_list|(
operator|(
name|long
operator|)
name|compptr
operator|->
name|width_in_blocks
argument_list|,
operator|(
name|long
operator|)
name|compptr
operator|->
name|h_samp_factor
argument_list|)
argument_list|,
operator|(
name|JDIMENSION
operator|)
name|jround_up
argument_list|(
operator|(
name|long
operator|)
name|compptr
operator|->
name|height_in_blocks
argument_list|,
operator|(
name|long
operator|)
name|compptr
operator|->
name|v_samp_factor
argument_list|)
argument_list|,
operator|(
name|JDIMENSION
operator|)
name|access_rows
argument_list|)
expr_stmt|;
block|}
name|coef
operator|->
name|pub
operator|.
name|consume_data
operator|=
name|consume_data
expr_stmt|;
name|coef
operator|->
name|pub
operator|.
name|decompress_data
operator|=
name|decompress_data
expr_stmt|;
name|coef
operator|->
name|pub
operator|.
name|coef_arrays
operator|=
name|coef
operator|->
name|whole_image
expr_stmt|;
comment|/* link to virtual arrays */
else|#
directive|else
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_NOT_COMPILED
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
comment|/* We only need a single-MCU buffer. */
name|JBLOCKROW
name|buffer
decl_stmt|;
name|int
name|i
decl_stmt|;
name|buffer
operator|=
call|(
name|JBLOCKROW
call|)
argument_list|(
operator|*
name|cinfo
operator|->
name|mem
operator|->
name|alloc_large
argument_list|)
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|,
name|JPOOL_IMAGE
argument_list|,
name|D_MAX_BLOCKS_IN_MCU
operator|*
name|SIZEOF
argument_list|(
name|JBLOCK
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|D_MAX_BLOCKS_IN_MCU
condition|;
name|i
operator|++
control|)
block|{
name|coef
operator|->
name|MCU_buffer
index|[
name|i
index|]
operator|=
name|buffer
operator|+
name|i
expr_stmt|;
block|}
name|coef
operator|->
name|pub
operator|.
name|consume_data
operator|=
name|dummy_consume_data
expr_stmt|;
name|coef
operator|->
name|pub
operator|.
name|decompress_data
operator|=
name|decompress_onepass
expr_stmt|;
name|coef
operator|->
name|pub
operator|.
name|coef_arrays
operator|=
name|NULL
expr_stmt|;
comment|/* flag for no virtual arrays */
block|}
block|}
end_block
end_unit
