begin_unit
begin_comment
comment|/*  * jcapimin.c  *  * Copyright (C) 1994-1998, Thomas G. Lane.  * Modified 2003-2010 by Guido Vollbeding.  * This file is part of the Independent JPEG Group's software.  * For conditions of distribution and use, see the accompanying README file.  *  * This file contains application interface code for the compression half  * of the JPEG library.  These are the "minimum" API routines that may be  * needed in either the normal full-compression case or the transcoding-only  * case.  *  * Most of the routines intended to be called directly by an application  * are in this file or in jcapistd.c.  But also see jcparam.c for  * parameter-setup helper routines, jcomapi.c for routines shared by  * compression and decompression, and jctrans.c for the transcoding case.  */
end_comment
begin_define
DECL|macro|JPEG_INTERNALS
define|#
directive|define
name|JPEG_INTERNALS
end_define
begin_include
include|#
directive|include
file|"jinclude.h"
end_include
begin_include
include|#
directive|include
file|"jpeglib.h"
end_include
begin_comment
comment|/*  * Initialization of a JPEG compression object.  * The error manager must already be set up (in case memory manager fails).  */
end_comment
begin_macro
name|GLOBAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|jpeg_CreateCompress
name|jpeg_CreateCompress
argument_list|(
argument|j_compress_ptr cinfo
argument_list|,
argument|int version
argument_list|,
argument|size_t structsize
argument_list|)
end_macro
begin_block
block|{
name|int
name|i
decl_stmt|;
comment|/* Guard against version mismatches between library and caller. */
name|cinfo
operator|->
name|mem
operator|=
name|NULL
expr_stmt|;
comment|/* so jpeg_destroy knows mem mgr not called */
if|if
condition|(
name|version
operator|!=
name|JPEG_LIB_VERSION
condition|)
name|ERREXIT2
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_LIB_VERSION
argument_list|,
name|JPEG_LIB_VERSION
argument_list|,
name|version
argument_list|)
expr_stmt|;
if|if
condition|(
name|structsize
operator|!=
name|SIZEOF
argument_list|(
expr|struct
name|jpeg_compress_struct
argument_list|)
condition|)
name|ERREXIT2
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_STRUCT_SIZE
argument_list|,
operator|(
name|int
operator|)
name|SIZEOF
argument_list|(
expr|struct
name|jpeg_compress_struct
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|structsize
argument_list|)
expr_stmt|;
comment|/* For debugging purposes, we zero the whole master structure.    * But the application has already set the err pointer, and may have set    * client_data, so we have to save and restore those fields.    * Note: if application hasn't set client_data, tools like Purify may    * complain here.    */
block|{
name|struct
name|jpeg_error_mgr
modifier|*
name|err
init|=
name|cinfo
operator|->
name|err
decl_stmt|;
name|void
modifier|*
name|client_data
init|=
name|cinfo
operator|->
name|client_data
decl_stmt|;
comment|/* ignore Purify complaint here */
name|MEMZERO
argument_list|(
name|cinfo
argument_list|,
name|SIZEOF
argument_list|(
expr|struct
name|jpeg_compress_struct
argument_list|)
argument_list|)
expr_stmt|;
name|cinfo
operator|->
name|err
operator|=
name|err
expr_stmt|;
name|cinfo
operator|->
name|client_data
operator|=
name|client_data
expr_stmt|;
block|}
name|cinfo
operator|->
name|is_decompressor
operator|=
name|FALSE
expr_stmt|;
comment|/* Initialize a memory manager instance for this object */
name|jinit_memory_mgr
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|)
expr_stmt|;
comment|/* Zero out pointers to permanent structures. */
name|cinfo
operator|->
name|progress
operator|=
name|NULL
expr_stmt|;
name|cinfo
operator|->
name|dest
operator|=
name|NULL
expr_stmt|;
name|cinfo
operator|->
name|comp_info
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_QUANT_TBLS
condition|;
name|i
operator|++
control|)
block|{
name|cinfo
operator|->
name|quant_tbl_ptrs
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|cinfo
operator|->
name|q_scale_factor
index|[
name|i
index|]
operator|=
literal|100
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_HUFF_TBLS
condition|;
name|i
operator|++
control|)
block|{
name|cinfo
operator|->
name|dc_huff_tbl_ptrs
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|cinfo
operator|->
name|ac_huff_tbl_ptrs
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Must do it here for emit_dqt in case jpeg_write_tables is used */
name|cinfo
operator|->
name|block_size
operator|=
name|DCTSIZE
expr_stmt|;
name|cinfo
operator|->
name|natural_order
operator|=
name|jpeg_natural_order
expr_stmt|;
name|cinfo
operator|->
name|lim_Se
operator|=
name|DCTSIZE2
operator|-
literal|1
expr_stmt|;
name|cinfo
operator|->
name|script_space
operator|=
name|NULL
expr_stmt|;
name|cinfo
operator|->
name|input_gamma
operator|=
literal|1.0
expr_stmt|;
comment|/* in case application forgets */
comment|/* OK, I'm ready */
name|cinfo
operator|->
name|global_state
operator|=
name|CSTATE_START
expr_stmt|;
block|}
end_block
begin_comment
comment|/*  * Destruction of a JPEG compression object  */
end_comment
begin_macro
name|GLOBAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|jpeg_destroy_compress
name|jpeg_destroy_compress
argument_list|(
argument|j_compress_ptr cinfo
argument_list|)
end_macro
begin_block
block|{
name|jpeg_destroy
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|)
expr_stmt|;
comment|/* use common routine */
block|}
end_block
begin_comment
comment|/*  * Abort processing of a JPEG compression operation,  * but don't destroy the object itself.  */
end_comment
begin_macro
name|GLOBAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|jpeg_abort_compress
name|jpeg_abort_compress
argument_list|(
argument|j_compress_ptr cinfo
argument_list|)
end_macro
begin_block
block|{
name|jpeg_abort
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|)
expr_stmt|;
comment|/* use common routine */
block|}
end_block
begin_comment
comment|/*  * Forcibly suppress or un-suppress all quantization and Huffman tables.  * Marks all currently defined tables as already written (if suppress)  * or not written (if !suppress).  This will control whether they get emitted  * by a subsequent jpeg_start_compress call.  *  * This routine is exported for use by applications that want to produce  * abbreviated JPEG datastreams.  It logically belongs in jcparam.c, but  * since it is called by jpeg_start_compress, we put it here --- otherwise  * jcparam.o would be linked whether the application used it or not.  */
end_comment
begin_macro
name|GLOBAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|jpeg_suppress_tables
name|jpeg_suppress_tables
argument_list|(
argument|j_compress_ptr cinfo
argument_list|,
argument|boolean suppress
argument_list|)
end_macro
begin_block
block|{
name|int
name|i
decl_stmt|;
name|JQUANT_TBL
modifier|*
name|qtbl
decl_stmt|;
name|JHUFF_TBL
modifier|*
name|htbl
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_QUANT_TBLS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|qtbl
operator|=
name|cinfo
operator|->
name|quant_tbl_ptrs
index|[
name|i
index|]
operator|)
operator|!=
name|NULL
condition|)
name|qtbl
operator|->
name|sent_table
operator|=
name|suppress
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_HUFF_TBLS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|htbl
operator|=
name|cinfo
operator|->
name|dc_huff_tbl_ptrs
index|[
name|i
index|]
operator|)
operator|!=
name|NULL
condition|)
name|htbl
operator|->
name|sent_table
operator|=
name|suppress
expr_stmt|;
if|if
condition|(
operator|(
name|htbl
operator|=
name|cinfo
operator|->
name|ac_huff_tbl_ptrs
index|[
name|i
index|]
operator|)
operator|!=
name|NULL
condition|)
name|htbl
operator|->
name|sent_table
operator|=
name|suppress
expr_stmt|;
block|}
block|}
end_block
begin_comment
comment|/*  * Finish JPEG compression.  *  * If a multipass operating mode was selected, this may do a great deal of  * work including most of the actual output.  */
end_comment
begin_macro
name|GLOBAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|jpeg_finish_compress
name|jpeg_finish_compress
argument_list|(
argument|j_compress_ptr cinfo
argument_list|)
end_macro
begin_block
block|{
name|JDIMENSION
name|iMCU_row
decl_stmt|;
if|if
condition|(
name|cinfo
operator|->
name|global_state
operator|==
name|CSTATE_SCANNING
operator|||
name|cinfo
operator|->
name|global_state
operator|==
name|CSTATE_RAW_OK
condition|)
block|{
comment|/* Terminate first pass */
if|if
condition|(
name|cinfo
operator|->
name|next_scanline
operator|<
name|cinfo
operator|->
name|image_height
condition|)
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_TOO_LITTLE_DATA
argument_list|)
expr_stmt|;
call|(
modifier|*
name|cinfo
operator|->
name|master
operator|->
name|finish_pass
call|)
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cinfo
operator|->
name|global_state
operator|!=
name|CSTATE_WRCOEFS
condition|)
name|ERREXIT1
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_STATE
argument_list|,
name|cinfo
operator|->
name|global_state
argument_list|)
expr_stmt|;
comment|/* Perform any remaining passes */
while|while
condition|(
operator|!
name|cinfo
operator|->
name|master
operator|->
name|is_last_pass
condition|)
block|{
call|(
modifier|*
name|cinfo
operator|->
name|master
operator|->
name|prepare_for_pass
call|)
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
for|for
control|(
name|iMCU_row
operator|=
literal|0
init|;
name|iMCU_row
operator|<
name|cinfo
operator|->
name|total_iMCU_rows
condition|;
name|iMCU_row
operator|++
control|)
block|{
if|if
condition|(
name|cinfo
operator|->
name|progress
operator|!=
name|NULL
condition|)
block|{
name|cinfo
operator|->
name|progress
operator|->
name|pass_counter
operator|=
operator|(
name|long
operator|)
name|iMCU_row
expr_stmt|;
name|cinfo
operator|->
name|progress
operator|->
name|pass_limit
operator|=
operator|(
name|long
operator|)
name|cinfo
operator|->
name|total_iMCU_rows
expr_stmt|;
call|(
modifier|*
name|cinfo
operator|->
name|progress
operator|->
name|progress_monitor
call|)
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|)
expr_stmt|;
block|}
comment|/* We bypass the main controller and invoke coef controller directly;        * all work is being done from the coefficient buffer.        */
if|if
condition|(
operator|!
call|(
modifier|*
name|cinfo
operator|->
name|coef
operator|->
name|compress_data
call|)
argument_list|(
name|cinfo
argument_list|,
operator|(
name|JSAMPIMAGE
operator|)
name|NULL
argument_list|)
condition|)
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_CANT_SUSPEND
argument_list|)
expr_stmt|;
block|}
call|(
modifier|*
name|cinfo
operator|->
name|master
operator|->
name|finish_pass
call|)
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
block|}
comment|/* Write EOI, do final cleanup */
call|(
modifier|*
name|cinfo
operator|->
name|marker
operator|->
name|write_file_trailer
call|)
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
call|(
modifier|*
name|cinfo
operator|->
name|dest
operator|->
name|term_destination
call|)
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
comment|/* We can use jpeg_abort to release memory and reset global_state */
name|jpeg_abort
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|)
expr_stmt|;
block|}
end_block
begin_comment
comment|/*  * Write a special marker.  * This is only recommended for writing COM or APPn markers.  * Must be called after jpeg_start_compress() and before  * first call to jpeg_write_scanlines() or jpeg_write_raw_data().  */
end_comment
begin_macro
name|GLOBAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|jpeg_write_marker
name|jpeg_write_marker
argument_list|(
argument|j_compress_ptr cinfo
argument_list|,
argument|int marker
argument_list|,
argument|const JOCTET *dataptr
argument_list|,
argument|unsigned int datalen
argument_list|)
end_macro
begin_block
block|{
name|JMETHOD
argument_list|(
name|void
argument_list|,
name|write_marker_byte
argument_list|,
operator|(
name|j_compress_ptr
name|info
operator|,
name|int
name|val
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cinfo
operator|->
name|next_scanline
operator|!=
literal|0
operator|||
operator|(
name|cinfo
operator|->
name|global_state
operator|!=
name|CSTATE_SCANNING
operator|&&
name|cinfo
operator|->
name|global_state
operator|!=
name|CSTATE_RAW_OK
operator|&&
name|cinfo
operator|->
name|global_state
operator|!=
name|CSTATE_WRCOEFS
operator|)
condition|)
name|ERREXIT1
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_STATE
argument_list|,
name|cinfo
operator|->
name|global_state
argument_list|)
expr_stmt|;
call|(
modifier|*
name|cinfo
operator|->
name|marker
operator|->
name|write_marker_header
call|)
argument_list|(
name|cinfo
argument_list|,
name|marker
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
name|write_marker_byte
operator|=
name|cinfo
operator|->
name|marker
operator|->
name|write_marker_byte
expr_stmt|;
comment|/* copy for speed */
while|while
condition|(
name|datalen
operator|--
condition|)
block|{
call|(
modifier|*
name|write_marker_byte
call|)
argument_list|(
name|cinfo
argument_list|,
operator|*
name|dataptr
argument_list|)
expr_stmt|;
name|dataptr
operator|++
expr_stmt|;
block|}
block|}
end_block
begin_comment
comment|/* Same, but piecemeal. */
end_comment
begin_macro
name|GLOBAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|jpeg_write_m_header
name|jpeg_write_m_header
argument_list|(
argument|j_compress_ptr cinfo
argument_list|,
argument|int marker
argument_list|,
argument|unsigned int datalen
argument_list|)
end_macro
begin_block
block|{
if|if
condition|(
name|cinfo
operator|->
name|next_scanline
operator|!=
literal|0
operator|||
operator|(
name|cinfo
operator|->
name|global_state
operator|!=
name|CSTATE_SCANNING
operator|&&
name|cinfo
operator|->
name|global_state
operator|!=
name|CSTATE_RAW_OK
operator|&&
name|cinfo
operator|->
name|global_state
operator|!=
name|CSTATE_WRCOEFS
operator|)
condition|)
name|ERREXIT1
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_STATE
argument_list|,
name|cinfo
operator|->
name|global_state
argument_list|)
expr_stmt|;
call|(
modifier|*
name|cinfo
operator|->
name|marker
operator|->
name|write_marker_header
call|)
argument_list|(
name|cinfo
argument_list|,
name|marker
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
block|}
end_block
begin_macro
name|GLOBAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|jpeg_write_m_byte
name|jpeg_write_m_byte
argument_list|(
argument|j_compress_ptr cinfo
argument_list|,
argument|int val
argument_list|)
end_macro
begin_block
block|{
call|(
modifier|*
name|cinfo
operator|->
name|marker
operator|->
name|write_marker_byte
call|)
argument_list|(
name|cinfo
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_block
begin_comment
comment|/*  * Alternate compression function: just write an abbreviated table file.  * Before calling this, all parameters and a data destination must be set up.  *  * To produce a pair of files containing abbreviated tables and abbreviated  * image data, one would proceed as follows:  *  *		initialize JPEG object  *		set JPEG parameters  *		set destination to table file  *		jpeg_write_tables(cinfo);  *		set destination to image file  *		jpeg_start_compress(cinfo, FALSE);  *		write data...  *		jpeg_finish_compress(cinfo);  *  * jpeg_write_tables has the side effect of marking all tables written  * (same as jpeg_suppress_tables(..., TRUE)).  Thus a subsequent start_compress  * will not re-emit the tables unless it is passed write_all_tables=TRUE.  */
end_comment
begin_macro
name|GLOBAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|jpeg_write_tables
name|jpeg_write_tables
argument_list|(
argument|j_compress_ptr cinfo
argument_list|)
end_macro
begin_block
block|{
if|if
condition|(
name|cinfo
operator|->
name|global_state
operator|!=
name|CSTATE_START
condition|)
name|ERREXIT1
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_STATE
argument_list|,
name|cinfo
operator|->
name|global_state
argument_list|)
expr_stmt|;
comment|/* (Re)initialize error mgr and destination modules */
call|(
modifier|*
name|cinfo
operator|->
name|err
operator|->
name|reset_error_mgr
call|)
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|)
expr_stmt|;
call|(
modifier|*
name|cinfo
operator|->
name|dest
operator|->
name|init_destination
call|)
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
comment|/* Initialize the marker writer ... bit of a crock to do it here. */
name|jinit_marker_writer
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
comment|/* Write them tables! */
call|(
modifier|*
name|cinfo
operator|->
name|marker
operator|->
name|write_tables_only
call|)
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
comment|/* And clean up. */
call|(
modifier|*
name|cinfo
operator|->
name|dest
operator|->
name|term_destination
call|)
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
comment|/*    * In library releases up through v6a, we called jpeg_abort() here to free    * any working memory allocated by the destination manager and marker    * writer.  Some applications had a problem with that: they allocated space    * of their own from the library memory manager, and didn't want it to go    * away during write_tables.  So now we do nothing.  This will cause a    * memory leak if an app calls write_tables repeatedly without doing a full    * compression cycle or otherwise resetting the JPEG object.  However, that    * seems less bad than unexpectedly freeing memory in the normal case.    * An app that prefers the old behavior can call jpeg_abort for itself after    * each call to jpeg_write_tables().    */
block|}
end_block
end_unit
