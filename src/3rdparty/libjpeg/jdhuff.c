begin_unit
begin_comment
comment|/*  * jdhuff.c  *  * Copyright (C) 1991-1997, Thomas G. Lane.  * Modified 2006-2009 by Guido Vollbeding.  * This file is part of the Independent JPEG Group's software.  * For conditions of distribution and use, see the accompanying README file.  *  * This file contains Huffman entropy decoding routines.  * Both sequential and progressive modes are supported in this single module.  *  * Much of the complexity here has to do with supporting input suspension.  * If the data source module demands suspension, we want to be able to back  * up to the start of the current MCU.  To do this, we copy state variables  * into local working storage, and update them back to the permanent  * storage only upon successful completion of an MCU.  */
end_comment
begin_define
DECL|macro|JPEG_INTERNALS
define|#
directive|define
name|JPEG_INTERNALS
end_define
begin_include
include|#
directive|include
file|"jinclude.h"
end_include
begin_include
include|#
directive|include
file|"jpeglib.h"
end_include
begin_comment
comment|/* Derived data constructed for each Huffman table */
end_comment
begin_define
DECL|macro|HUFF_LOOKAHEAD
define|#
directive|define
name|HUFF_LOOKAHEAD
value|8
end_define
begin_comment
DECL|macro|HUFF_LOOKAHEAD
comment|/* # of bits of lookahead */
end_comment
begin_typedef
typedef|typedef
struct|struct
block|{
comment|/* Basic tables: (element [0] of each array is unused) */
DECL|member|maxcode
name|INT32
name|maxcode
index|[
literal|18
index|]
decl_stmt|;
comment|/* largest code of length k (-1 if none) */
comment|/* (maxcode[17] is a sentinel to ensure jpeg_huff_decode terminates) */
DECL|member|valoffset
name|INT32
name|valoffset
index|[
literal|17
index|]
decl_stmt|;
comment|/* huffval[] offset for codes of length k */
comment|/* valoffset[k] = huffval[] index of 1st symbol of code length k, less    * the smallest code of length k; so given a code of length k, the    * corresponding symbol is huffval[code + valoffset[k]]    */
comment|/* Link to public Huffman table (needed only in jpeg_huff_decode) */
DECL|member|pub
name|JHUFF_TBL
modifier|*
name|pub
decl_stmt|;
comment|/* Lookahead tables: indexed by the next HUFF_LOOKAHEAD bits of    * the input data stream.  If the next Huffman code is no more    * than HUFF_LOOKAHEAD bits long, we can obtain its length and    * the corresponding symbol directly from these tables.    */
DECL|member|look_nbits
name|int
name|look_nbits
index|[
literal|1
operator|<<
name|HUFF_LOOKAHEAD
index|]
decl_stmt|;
comment|/* # bits, or 0 if too long */
DECL|member|look_sym
name|UINT8
name|look_sym
index|[
literal|1
operator|<<
name|HUFF_LOOKAHEAD
index|]
decl_stmt|;
comment|/* symbol, or unused */
block|}
DECL|typedef|d_derived_tbl
name|d_derived_tbl
typedef|;
end_typedef
begin_comment
comment|/*  * Fetching the next N bits from the input stream is a time-critical operation  * for the Huffman decoders.  We implement it with a combination of inline  * macros and out-of-line subroutines.  Note that N (the number of bits  * demanded at one time) never exceeds 15 for JPEG use.  *  * We read source bytes into get_buffer and dole out bits as needed.  * If get_buffer already contains enough bits, they are fetched in-line  * by the macros CHECK_BIT_BUFFER and GET_BITS.  When there aren't enough  * bits, jpeg_fill_bit_buffer is called; it will attempt to fill get_buffer  * as full as possible (not just to the number of bits needed; this  * prefetching reduces the overhead cost of calling jpeg_fill_bit_buffer).  * Note that jpeg_fill_bit_buffer may return FALSE to indicate suspension.  * On TRUE return, jpeg_fill_bit_buffer guarantees that get_buffer contains  * at least the requested number of bits --- dummy zeroes are inserted if  * necessary.  */
end_comment
begin_typedef
DECL|typedef|bit_buf_type
typedef|typedef
name|INT32
name|bit_buf_type
typedef|;
end_typedef
begin_comment
DECL|typedef|bit_buf_type
comment|/* type of bit-extraction buffer */
end_comment
begin_define
DECL|macro|BIT_BUF_SIZE
define|#
directive|define
name|BIT_BUF_SIZE
value|32
end_define
begin_comment
DECL|macro|BIT_BUF_SIZE
comment|/* size of buffer in bits */
end_comment
begin_comment
comment|/* If long is> 32 bits on your machine, and shifting/masking longs is  * reasonably fast, making bit_buf_type be long and setting BIT_BUF_SIZE  * appropriately should be a win.  Unfortunately we can't define the size  * with something like  #define BIT_BUF_SIZE (sizeof(bit_buf_type)*8)  * because not all machines measure sizeof in 8-bit bytes.  */
end_comment
begin_typedef
typedef|typedef
struct|struct
block|{
comment|/* Bitreading state saved across MCUs */
DECL|member|get_buffer
name|bit_buf_type
name|get_buffer
decl_stmt|;
comment|/* current bit-extraction buffer */
DECL|member|bits_left
name|int
name|bits_left
decl_stmt|;
comment|/* # of unused bits in it */
block|}
DECL|typedef|bitread_perm_state
name|bitread_perm_state
typedef|;
end_typedef
begin_typedef
typedef|typedef
struct|struct
block|{
comment|/* Bitreading working state within an MCU */
comment|/* Current data source location */
comment|/* We need a copy, rather than munging the original, in case of suspension */
DECL|member|next_input_byte
specifier|const
name|JOCTET
modifier|*
name|next_input_byte
decl_stmt|;
comment|/* => next byte to read from source */
DECL|member|bytes_in_buffer
name|size_t
name|bytes_in_buffer
decl_stmt|;
comment|/* # of bytes remaining in source buffer */
comment|/* Bit input buffer --- note these values are kept in register variables,    * not in this struct, inside the inner loops.    */
DECL|member|get_buffer
name|bit_buf_type
name|get_buffer
decl_stmt|;
comment|/* current bit-extraction buffer */
DECL|member|bits_left
name|int
name|bits_left
decl_stmt|;
comment|/* # of unused bits in it */
comment|/* Pointer needed by jpeg_fill_bit_buffer. */
DECL|member|cinfo
name|j_decompress_ptr
name|cinfo
decl_stmt|;
comment|/* back link to decompress master record */
block|}
DECL|typedef|bitread_working_state
name|bitread_working_state
typedef|;
end_typedef
begin_comment
comment|/* Macros to declare and load/save bitread local variables. */
end_comment
begin_define
DECL|macro|BITREAD_STATE_VARS
define|#
directive|define
name|BITREAD_STATE_VARS
define|\
value|register bit_buf_type get_buffer;  \ 	register int bits_left;  \ 	bitread_working_state br_state
end_define
begin_define
DECL|macro|BITREAD_LOAD_STATE
define|#
directive|define
name|BITREAD_LOAD_STATE
parameter_list|(
name|cinfop
parameter_list|,
name|permstate
parameter_list|)
define|\
value|br_state.cinfo = cinfop; \ 	br_state.next_input_byte = cinfop->src->next_input_byte; \ 	br_state.bytes_in_buffer = cinfop->src->bytes_in_buffer; \ 	get_buffer = permstate.get_buffer; \ 	bits_left = permstate.bits_left;
end_define
begin_define
DECL|macro|BITREAD_SAVE_STATE
define|#
directive|define
name|BITREAD_SAVE_STATE
parameter_list|(
name|cinfop
parameter_list|,
name|permstate
parameter_list|)
define|\
value|cinfop->src->next_input_byte = br_state.next_input_byte; \ 	cinfop->src->bytes_in_buffer = br_state.bytes_in_buffer; \ 	permstate.get_buffer = get_buffer; \ 	permstate.bits_left = bits_left
end_define
begin_comment
comment|/*  * These macros provide the in-line portion of bit fetching.  * Use CHECK_BIT_BUFFER to ensure there are N bits in get_buffer  * before using GET_BITS, PEEK_BITS, or DROP_BITS.  * The variables get_buffer and bits_left are assumed to be locals,  * but the state struct might not be (jpeg_huff_decode needs this).  *	CHECK_BIT_BUFFER(state,n,action);  *		Ensure there are N bits in get_buffer; if suspend, take action.  *      val = GET_BITS(n);  *		Fetch next N bits.  *      val = PEEK_BITS(n);  *		Fetch next N bits without removing them from the buffer.  *	DROP_BITS(n);  *		Discard next N bits.  * The value N should be a simple variable, not an expression, because it  * is evaluated multiple times.  */
end_comment
begin_define
DECL|macro|CHECK_BIT_BUFFER
define|#
directive|define
name|CHECK_BIT_BUFFER
parameter_list|(
name|state
parameter_list|,
name|nbits
parameter_list|,
name|action
parameter_list|)
define|\
value|{ if (bits_left< (nbits)) {  \ 	    if (! jpeg_fill_bit_buffer(&(state),get_buffer,bits_left,nbits))  \ 	      { action; }  \ 	    get_buffer = (state).get_buffer; bits_left = (state).bits_left; } }
end_define
begin_define
DECL|macro|GET_BITS
define|#
directive|define
name|GET_BITS
parameter_list|(
name|nbits
parameter_list|)
define|\
value|(((int) (get_buffer>> (bits_left -= (nbits))))& BIT_MASK(nbits))
end_define
begin_define
DECL|macro|PEEK_BITS
define|#
directive|define
name|PEEK_BITS
parameter_list|(
name|nbits
parameter_list|)
define|\
value|(((int) (get_buffer>> (bits_left -  (nbits))))& BIT_MASK(nbits))
end_define
begin_define
DECL|macro|DROP_BITS
define|#
directive|define
name|DROP_BITS
parameter_list|(
name|nbits
parameter_list|)
define|\
value|(bits_left -= (nbits))
end_define
begin_comment
comment|/*  * Code for extracting next Huffman-coded symbol from input bit stream.  * Again, this is time-critical and we make the main paths be macros.  *  * We use a lookahead table to process codes of up to HUFF_LOOKAHEAD bits  * without looping.  Usually, more than 95% of the Huffman codes will be 8  * or fewer bits long.  The few overlength codes are handled with a loop,  * which need not be inline code.  *  * Notes about the HUFF_DECODE macro:  * 1. Near the end of the data segment, we may fail to get enough bits  *    for a lookahead.  In that case, we do it the hard way.  * 2. If the lookahead table contains no entry, the next code must be  *    more than HUFF_LOOKAHEAD bits long.  * 3. jpeg_huff_decode returns -1 if forced to suspend.  */
end_comment
begin_define
DECL|macro|HUFF_DECODE
define|#
directive|define
name|HUFF_DECODE
parameter_list|(
name|result
parameter_list|,
name|state
parameter_list|,
name|htbl
parameter_list|,
name|failaction
parameter_list|,
name|slowlabel
parameter_list|)
define|\
value|{ register int nb, look; \   if (bits_left< HUFF_LOOKAHEAD) { \     if (! jpeg_fill_bit_buffer(&state,get_buffer,bits_left, 0)) {failaction;} \     get_buffer = state.get_buffer; bits_left = state.bits_left; \     if (bits_left< HUFF_LOOKAHEAD) { \       nb = 1; goto slowlabel; \     } \   } \   look = PEEK_BITS(HUFF_LOOKAHEAD); \   if ((nb = htbl->look_nbits[look]) != 0) { \     DROP_BITS(nb); \     result = htbl->look_sym[look]; \   } else { \     nb = HUFF_LOOKAHEAD+1; \ slowlabel: \     if ((result=jpeg_huff_decode(&state,get_buffer,bits_left,htbl,nb))< 0) \ 	{ failaction; } \     get_buffer = state.get_buffer; bits_left = state.bits_left; \   } \ }
end_define
begin_comment
comment|/*  * Expanded entropy decoder object for Huffman decoding.  *  * The savable_state subrecord contains fields that change within an MCU,  * but must not be updated permanently until we complete the MCU.  */
end_comment
begin_typedef
typedef|typedef
struct|struct
block|{
DECL|member|EOBRUN
name|unsigned
name|int
name|EOBRUN
decl_stmt|;
comment|/* remaining EOBs in EOBRUN */
DECL|member|last_dc_val
name|int
name|last_dc_val
index|[
name|MAX_COMPS_IN_SCAN
index|]
decl_stmt|;
comment|/* last DC coef for each component */
block|}
DECL|typedef|savable_state
name|savable_state
typedef|;
end_typedef
begin_comment
comment|/* This macro is to work around compilers with missing or broken  * structure assignment.  You'll need to fix this code if you have  * such a compiler and you change MAX_COMPS_IN_SCAN.  */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|NO_STRUCT_ASSIGN
end_ifndef
begin_define
DECL|macro|ASSIGN_STATE
define|#
directive|define
name|ASSIGN_STATE
parameter_list|(
name|dest
parameter_list|,
name|src
parameter_list|)
value|((dest) = (src))
end_define
begin_else
else|#
directive|else
end_else
begin_if
if|#
directive|if
name|MAX_COMPS_IN_SCAN
operator|==
literal|4
end_if
begin_define
DECL|macro|ASSIGN_STATE
define|#
directive|define
name|ASSIGN_STATE
parameter_list|(
name|dest
parameter_list|,
name|src
parameter_list|)
define|\
value|((dest).EOBRUN = (src).EOBRUN, \ 	 (dest).last_dc_val[0] = (src).last_dc_val[0], \ 	 (dest).last_dc_val[1] = (src).last_dc_val[1], \ 	 (dest).last_dc_val[2] = (src).last_dc_val[2], \ 	 (dest).last_dc_val[3] = (src).last_dc_val[3])
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_typedef
typedef|typedef
struct|struct
block|{
DECL|member|pub
name|struct
name|jpeg_entropy_decoder
name|pub
decl_stmt|;
comment|/* public fields */
comment|/* These fields are loaded into local variables at start of each MCU.    * In case of suspension, we exit WITHOUT updating them.    */
DECL|member|bitstate
name|bitread_perm_state
name|bitstate
decl_stmt|;
comment|/* Bit buffer at start of MCU */
DECL|member|saved
name|savable_state
name|saved
decl_stmt|;
comment|/* Other state at start of MCU */
comment|/* These fields are NOT loaded into local working state. */
DECL|member|insufficient_data
name|boolean
name|insufficient_data
decl_stmt|;
comment|/* set TRUE after emitting warning */
DECL|member|restarts_to_go
name|unsigned
name|int
name|restarts_to_go
decl_stmt|;
comment|/* MCUs left in this restart interval */
comment|/* Following two fields used only in progressive mode */
comment|/* Pointers to derived tables (these workspaces have image lifespan) */
DECL|member|derived_tbls
name|d_derived_tbl
modifier|*
name|derived_tbls
index|[
name|NUM_HUFF_TBLS
index|]
decl_stmt|;
DECL|member|ac_derived_tbl
name|d_derived_tbl
modifier|*
name|ac_derived_tbl
decl_stmt|;
comment|/* active table during an AC scan */
comment|/* Following fields used only in sequential mode */
comment|/* Pointers to derived tables (these workspaces have image lifespan) */
DECL|member|dc_derived_tbls
name|d_derived_tbl
modifier|*
name|dc_derived_tbls
index|[
name|NUM_HUFF_TBLS
index|]
decl_stmt|;
DECL|member|ac_derived_tbls
name|d_derived_tbl
modifier|*
name|ac_derived_tbls
index|[
name|NUM_HUFF_TBLS
index|]
decl_stmt|;
comment|/* Precalculated info set up by start_pass for use in decode_mcu: */
comment|/* Pointers to derived tables to be used for each block within an MCU */
DECL|member|dc_cur_tbls
name|d_derived_tbl
modifier|*
name|dc_cur_tbls
index|[
name|D_MAX_BLOCKS_IN_MCU
index|]
decl_stmt|;
DECL|member|ac_cur_tbls
name|d_derived_tbl
modifier|*
name|ac_cur_tbls
index|[
name|D_MAX_BLOCKS_IN_MCU
index|]
decl_stmt|;
comment|/* Whether we care about the DC and AC coefficient values for each block */
DECL|member|coef_limit
name|int
name|coef_limit
index|[
name|D_MAX_BLOCKS_IN_MCU
index|]
decl_stmt|;
block|}
DECL|typedef|huff_entropy_decoder
name|huff_entropy_decoder
typedef|;
end_typedef
begin_typedef
DECL|typedef|huff_entropy_ptr
typedef|typedef
name|huff_entropy_decoder
modifier|*
name|huff_entropy_ptr
typedef|;
end_typedef
begin_decl_stmt
DECL|variable|jpeg_zigzag_order
specifier|static
specifier|const
name|int
name|jpeg_zigzag_order
index|[
literal|8
index|]
index|[
literal|8
index|]
init|=
block|{
block|{
literal|0
block|,
literal|1
block|,
literal|5
block|,
literal|6
block|,
literal|14
block|,
literal|15
block|,
literal|27
block|,
literal|28
block|}
block|,
block|{
literal|2
block|,
literal|4
block|,
literal|7
block|,
literal|13
block|,
literal|16
block|,
literal|26
block|,
literal|29
block|,
literal|42
block|}
block|,
block|{
literal|3
block|,
literal|8
block|,
literal|12
block|,
literal|17
block|,
literal|25
block|,
literal|30
block|,
literal|41
block|,
literal|43
block|}
block|,
block|{
literal|9
block|,
literal|11
block|,
literal|18
block|,
literal|24
block|,
literal|31
block|,
literal|40
block|,
literal|44
block|,
literal|53
block|}
block|,
block|{
literal|10
block|,
literal|19
block|,
literal|23
block|,
literal|32
block|,
literal|39
block|,
literal|45
block|,
literal|52
block|,
literal|54
block|}
block|,
block|{
literal|20
block|,
literal|22
block|,
literal|33
block|,
literal|38
block|,
literal|46
block|,
literal|51
block|,
literal|55
block|,
literal|60
block|}
block|,
block|{
literal|21
block|,
literal|34
block|,
literal|37
block|,
literal|47
block|,
literal|50
block|,
literal|56
block|,
literal|59
block|,
literal|61
block|}
block|,
block|{
literal|35
block|,
literal|36
block|,
literal|48
block|,
literal|49
block|,
literal|57
block|,
literal|58
block|,
literal|62
block|,
literal|63
block|}
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|jpeg_zigzag_order7
specifier|static
specifier|const
name|int
name|jpeg_zigzag_order7
index|[
literal|7
index|]
index|[
literal|7
index|]
init|=
block|{
block|{
literal|0
block|,
literal|1
block|,
literal|5
block|,
literal|6
block|,
literal|14
block|,
literal|15
block|,
literal|27
block|}
block|,
block|{
literal|2
block|,
literal|4
block|,
literal|7
block|,
literal|13
block|,
literal|16
block|,
literal|26
block|,
literal|28
block|}
block|,
block|{
literal|3
block|,
literal|8
block|,
literal|12
block|,
literal|17
block|,
literal|25
block|,
literal|29
block|,
literal|38
block|}
block|,
block|{
literal|9
block|,
literal|11
block|,
literal|18
block|,
literal|24
block|,
literal|30
block|,
literal|37
block|,
literal|39
block|}
block|,
block|{
literal|10
block|,
literal|19
block|,
literal|23
block|,
literal|31
block|,
literal|36
block|,
literal|40
block|,
literal|45
block|}
block|,
block|{
literal|20
block|,
literal|22
block|,
literal|32
block|,
literal|35
block|,
literal|41
block|,
literal|44
block|,
literal|46
block|}
block|,
block|{
literal|21
block|,
literal|33
block|,
literal|34
block|,
literal|42
block|,
literal|43
block|,
literal|47
block|,
literal|48
block|}
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|jpeg_zigzag_order6
specifier|static
specifier|const
name|int
name|jpeg_zigzag_order6
index|[
literal|6
index|]
index|[
literal|6
index|]
init|=
block|{
block|{
literal|0
block|,
literal|1
block|,
literal|5
block|,
literal|6
block|,
literal|14
block|,
literal|15
block|}
block|,
block|{
literal|2
block|,
literal|4
block|,
literal|7
block|,
literal|13
block|,
literal|16
block|,
literal|25
block|}
block|,
block|{
literal|3
block|,
literal|8
block|,
literal|12
block|,
literal|17
block|,
literal|24
block|,
literal|26
block|}
block|,
block|{
literal|9
block|,
literal|11
block|,
literal|18
block|,
literal|23
block|,
literal|27
block|,
literal|32
block|}
block|,
block|{
literal|10
block|,
literal|19
block|,
literal|22
block|,
literal|28
block|,
literal|31
block|,
literal|33
block|}
block|,
block|{
literal|20
block|,
literal|21
block|,
literal|29
block|,
literal|30
block|,
literal|34
block|,
literal|35
block|}
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|jpeg_zigzag_order5
specifier|static
specifier|const
name|int
name|jpeg_zigzag_order5
index|[
literal|5
index|]
index|[
literal|5
index|]
init|=
block|{
block|{
literal|0
block|,
literal|1
block|,
literal|5
block|,
literal|6
block|,
literal|14
block|}
block|,
block|{
literal|2
block|,
literal|4
block|,
literal|7
block|,
literal|13
block|,
literal|15
block|}
block|,
block|{
literal|3
block|,
literal|8
block|,
literal|12
block|,
literal|16
block|,
literal|21
block|}
block|,
block|{
literal|9
block|,
literal|11
block|,
literal|17
block|,
literal|20
block|,
literal|22
block|}
block|,
block|{
literal|10
block|,
literal|18
block|,
literal|19
block|,
literal|23
block|,
literal|24
block|}
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|jpeg_zigzag_order4
specifier|static
specifier|const
name|int
name|jpeg_zigzag_order4
index|[
literal|4
index|]
index|[
literal|4
index|]
init|=
block|{
block|{
literal|0
block|,
literal|1
block|,
literal|5
block|,
literal|6
block|}
block|,
block|{
literal|2
block|,
literal|4
block|,
literal|7
block|,
literal|12
block|}
block|,
block|{
literal|3
block|,
literal|8
block|,
literal|11
block|,
literal|13
block|}
block|,
block|{
literal|9
block|,
literal|10
block|,
literal|14
block|,
literal|15
block|}
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|jpeg_zigzag_order3
specifier|static
specifier|const
name|int
name|jpeg_zigzag_order3
index|[
literal|3
index|]
index|[
literal|3
index|]
init|=
block|{
block|{
literal|0
block|,
literal|1
block|,
literal|5
block|}
block|,
block|{
literal|2
block|,
literal|4
block|,
literal|6
block|}
block|,
block|{
literal|3
block|,
literal|7
block|,
literal|8
block|}
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|jpeg_zigzag_order2
specifier|static
specifier|const
name|int
name|jpeg_zigzag_order2
index|[
literal|2
index|]
index|[
literal|2
index|]
init|=
block|{
block|{
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|2
block|,
literal|3
block|}
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*  * Compute the derived values for a Huffman table.  * This routine also performs some validation checks on the table.  */
end_comment
begin_macro
name|LOCAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|jpeg_make_d_derived_tbl
name|jpeg_make_d_derived_tbl
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|,
argument|boolean isDC
argument_list|,
argument|int tblno
argument_list|,
argument|d_derived_tbl ** pdtbl
argument_list|)
end_macro
begin_block
block|{
name|JHUFF_TBL
modifier|*
name|htbl
decl_stmt|;
name|d_derived_tbl
modifier|*
name|dtbl
decl_stmt|;
name|int
name|p
decl_stmt|,
name|i
decl_stmt|,
name|l
decl_stmt|,
name|si
decl_stmt|,
name|numsymbols
decl_stmt|;
name|int
name|lookbits
decl_stmt|,
name|ctr
decl_stmt|;
name|char
name|huffsize
index|[
literal|257
index|]
decl_stmt|;
name|unsigned
name|int
name|huffcode
index|[
literal|257
index|]
decl_stmt|;
name|unsigned
name|int
name|code
decl_stmt|;
comment|/* Note that huffsize[] and huffcode[] are filled in code-length order,    * paralleling the order of the symbols themselves in htbl->huffval[].    */
comment|/* Find the input Huffman table */
if|if
condition|(
name|tblno
operator|<
literal|0
operator|||
name|tblno
operator|>=
name|NUM_HUFF_TBLS
condition|)
name|ERREXIT1
argument_list|(
name|cinfo
argument_list|,
name|JERR_NO_HUFF_TABLE
argument_list|,
name|tblno
argument_list|)
expr_stmt|;
name|htbl
operator|=
name|isDC
condition|?
name|cinfo
operator|->
name|dc_huff_tbl_ptrs
index|[
name|tblno
index|]
else|:
name|cinfo
operator|->
name|ac_huff_tbl_ptrs
index|[
name|tblno
index|]
expr_stmt|;
if|if
condition|(
name|htbl
operator|==
name|NULL
condition|)
name|ERREXIT1
argument_list|(
name|cinfo
argument_list|,
name|JERR_NO_HUFF_TABLE
argument_list|,
name|tblno
argument_list|)
expr_stmt|;
comment|/* Allocate a workspace if we haven't already done so. */
if|if
condition|(
operator|*
name|pdtbl
operator|==
name|NULL
condition|)
operator|*
name|pdtbl
operator|=
operator|(
name|d_derived_tbl
operator|*
operator|)
call|(
modifier|*
name|cinfo
operator|->
name|mem
operator|->
name|alloc_small
call|)
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|,
name|JPOOL_IMAGE
argument_list|,
name|SIZEOF
argument_list|(
name|d_derived_tbl
argument_list|)
argument_list|)
expr_stmt|;
name|dtbl
operator|=
operator|*
name|pdtbl
expr_stmt|;
name|dtbl
operator|->
name|pub
operator|=
name|htbl
expr_stmt|;
comment|/* fill in back link */
comment|/* Figure C.1: make table of Huffman code length for each symbol */
name|p
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|l
operator|=
literal|1
init|;
name|l
operator|<=
literal|16
condition|;
name|l
operator|++
control|)
block|{
name|i
operator|=
operator|(
name|int
operator|)
name|htbl
operator|->
name|bits
index|[
name|l
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|p
operator|+
name|i
operator|>
literal|256
condition|)
comment|/* protect against table overrun */
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_HUFF_TABLE
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|--
condition|)
name|huffsize
index|[
name|p
operator|++
index|]
operator|=
operator|(
name|char
operator|)
name|l
expr_stmt|;
block|}
name|huffsize
index|[
name|p
index|]
operator|=
literal|0
expr_stmt|;
name|numsymbols
operator|=
name|p
expr_stmt|;
comment|/* Figure C.2: generate the codes themselves */
comment|/* We also validate that the counts represent a legal Huffman code tree. */
name|code
operator|=
literal|0
expr_stmt|;
name|si
operator|=
name|huffsize
index|[
literal|0
index|]
expr_stmt|;
name|p
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|huffsize
index|[
name|p
index|]
condition|)
block|{
while|while
condition|(
operator|(
operator|(
name|int
operator|)
name|huffsize
index|[
name|p
index|]
operator|)
operator|==
name|si
condition|)
block|{
name|huffcode
index|[
name|p
operator|++
index|]
operator|=
name|code
expr_stmt|;
name|code
operator|++
expr_stmt|;
block|}
comment|/* code is now 1 more than the last code used for codelength si; but      * it must still fit in si bits, since no code is allowed to be all ones.      */
if|if
condition|(
operator|(
operator|(
name|INT32
operator|)
name|code
operator|)
operator|>=
operator|(
operator|(
operator|(
name|INT32
operator|)
literal|1
operator|)
operator|<<
name|si
operator|)
condition|)
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_HUFF_TABLE
argument_list|)
expr_stmt|;
name|code
operator|<<=
literal|1
expr_stmt|;
name|si
operator|++
expr_stmt|;
block|}
comment|/* Figure F.15: generate decoding tables for bit-sequential decoding */
name|p
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|l
operator|=
literal|1
init|;
name|l
operator|<=
literal|16
condition|;
name|l
operator|++
control|)
block|{
if|if
condition|(
name|htbl
operator|->
name|bits
index|[
name|l
index|]
condition|)
block|{
comment|/* valoffset[l] = huffval[] index of 1st symbol of code length l,        * minus the minimum code of length l        */
name|dtbl
operator|->
name|valoffset
index|[
name|l
index|]
operator|=
operator|(
name|INT32
operator|)
name|p
operator|-
operator|(
name|INT32
operator|)
name|huffcode
index|[
name|p
index|]
expr_stmt|;
name|p
operator|+=
name|htbl
operator|->
name|bits
index|[
name|l
index|]
expr_stmt|;
name|dtbl
operator|->
name|maxcode
index|[
name|l
index|]
operator|=
name|huffcode
index|[
name|p
operator|-
literal|1
index|]
expr_stmt|;
comment|/* maximum code of length l */
block|}
else|else
block|{
name|dtbl
operator|->
name|maxcode
index|[
name|l
index|]
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* -1 if no codes of this length */
block|}
block|}
name|dtbl
operator|->
name|maxcode
index|[
literal|17
index|]
operator|=
literal|0xFFFFFL
expr_stmt|;
comment|/* ensures jpeg_huff_decode terminates */
comment|/* Compute lookahead tables to speed up decoding.    * First we set all the table entries to 0, indicating "too long";    * then we iterate through the Huffman codes that are short enough and    * fill in all the entries that correspond to bit sequences starting    * with that code.    */
name|MEMZERO
argument_list|(
name|dtbl
operator|->
name|look_nbits
argument_list|,
name|SIZEOF
argument_list|(
name|dtbl
operator|->
name|look_nbits
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|l
operator|=
literal|1
init|;
name|l
operator|<=
name|HUFF_LOOKAHEAD
condition|;
name|l
operator|++
control|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
operator|(
name|int
operator|)
name|htbl
operator|->
name|bits
index|[
name|l
index|]
condition|;
name|i
operator|++
operator|,
name|p
operator|++
control|)
block|{
comment|/* l = current code's length, p = its index in huffcode[]& huffval[]. */
comment|/* Generate left-justified code followed by all possible bit sequences */
name|lookbits
operator|=
name|huffcode
index|[
name|p
index|]
operator|<<
operator|(
name|HUFF_LOOKAHEAD
operator|-
name|l
operator|)
expr_stmt|;
for|for
control|(
name|ctr
operator|=
literal|1
operator|<<
operator|(
name|HUFF_LOOKAHEAD
operator|-
name|l
operator|)
init|;
name|ctr
operator|>
literal|0
condition|;
name|ctr
operator|--
control|)
block|{
name|dtbl
operator|->
name|look_nbits
index|[
name|lookbits
index|]
operator|=
name|l
expr_stmt|;
name|dtbl
operator|->
name|look_sym
index|[
name|lookbits
index|]
operator|=
name|htbl
operator|->
name|huffval
index|[
name|p
index|]
expr_stmt|;
name|lookbits
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|/* Validate symbols as being reasonable.    * For AC tables, we make no check, but accept all byte values 0..255.    * For DC tables, we require the symbols to be in range 0..15.    * (Tighter bounds could be applied depending on the data depth and mode,    * but this is sufficient to ensure safe decoding.)    */
if|if
condition|(
name|isDC
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numsymbols
condition|;
name|i
operator|++
control|)
block|{
name|int
name|sym
init|=
name|htbl
operator|->
name|huffval
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|sym
operator|<
literal|0
operator|||
name|sym
operator|>
literal|15
condition|)
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_HUFF_TABLE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block
begin_comment
comment|/*  * Out-of-line code for bit fetching.  * Note: current values of get_buffer and bits_left are passed as parameters,  * but are returned in the corresponding fields of the state struct.  *  * On most machines MIN_GET_BITS should be 25 to allow the full 32-bit width  * of get_buffer to be used.  (On machines with wider words, an even larger  * buffer could be used.)  However, on some machines 32-bit shifts are  * quite slow and take time proportional to the number of places shifted.  * (This is true with most PC compilers, for instance.)  In this case it may  * be a win to set MIN_GET_BITS to the minimum value of 15.  This reduces the  * average shift distance at the cost of more calls to jpeg_fill_bit_buffer.  */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|SLOW_SHIFT_32
end_ifdef
begin_define
DECL|macro|MIN_GET_BITS
define|#
directive|define
name|MIN_GET_BITS
value|15
end_define
begin_comment
DECL|macro|MIN_GET_BITS
comment|/* minimum allowable value */
end_comment
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|MIN_GET_BITS
define|#
directive|define
name|MIN_GET_BITS
value|(BIT_BUF_SIZE-7)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_macro
DECL|function|LOCAL
name|LOCAL
argument_list|(
argument|boolean
argument_list|)
end_macro
begin_macro
name|jpeg_fill_bit_buffer
argument_list|(
argument|bitread_working_state * state
argument_list|,
argument|register bit_buf_type get_buffer
argument_list|,
argument|register int bits_left
argument_list|,
argument|int nbits
argument_list|)
end_macro
begin_comment
comment|/* Load up the bit buffer to a depth of at least nbits */
end_comment
begin_block
block|{
comment|/* Copy heavily used state fields into locals (hopefully registers) */
specifier|register
specifier|const
name|JOCTET
modifier|*
name|next_input_byte
init|=
name|state
operator|->
name|next_input_byte
decl_stmt|;
specifier|register
name|size_t
name|bytes_in_buffer
init|=
name|state
operator|->
name|bytes_in_buffer
decl_stmt|;
name|j_decompress_ptr
name|cinfo
init|=
name|state
operator|->
name|cinfo
decl_stmt|;
comment|/* Attempt to load at least MIN_GET_BITS bits into get_buffer. */
comment|/* (It is assumed that no request will be for more than that many bits.) */
comment|/* We fail to do so only if we hit a marker or are forced to suspend. */
if|if
condition|(
name|cinfo
operator|->
name|unread_marker
operator|==
literal|0
condition|)
block|{
comment|/* cannot advance past a marker */
while|while
condition|(
name|bits_left
operator|<
name|MIN_GET_BITS
condition|)
block|{
specifier|register
name|int
name|c
decl_stmt|;
comment|/* Attempt to read a byte */
if|if
condition|(
name|bytes_in_buffer
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
call|(
modifier|*
name|cinfo
operator|->
name|src
operator|->
name|fill_input_buffer
call|)
argument_list|(
name|cinfo
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|next_input_byte
operator|=
name|cinfo
operator|->
name|src
operator|->
name|next_input_byte
expr_stmt|;
name|bytes_in_buffer
operator|=
name|cinfo
operator|->
name|src
operator|->
name|bytes_in_buffer
expr_stmt|;
block|}
name|bytes_in_buffer
operator|--
expr_stmt|;
name|c
operator|=
name|GETJOCTET
argument_list|(
operator|*
name|next_input_byte
operator|++
argument_list|)
expr_stmt|;
comment|/* If it's 0xFF, check and discard stuffed zero byte */
if|if
condition|(
name|c
operator|==
literal|0xFF
condition|)
block|{
comment|/* Loop here to discard any padding FF's on terminating marker, 	 * so that we can save a valid unread_marker value.  NOTE: we will 	 * accept multiple FF's followed by a 0 as meaning a single FF data 	 * byte.  This data pattern is not valid according to the standard. 	 */
do|do
block|{
if|if
condition|(
name|bytes_in_buffer
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
call|(
modifier|*
name|cinfo
operator|->
name|src
operator|->
name|fill_input_buffer
call|)
argument_list|(
name|cinfo
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|next_input_byte
operator|=
name|cinfo
operator|->
name|src
operator|->
name|next_input_byte
expr_stmt|;
name|bytes_in_buffer
operator|=
name|cinfo
operator|->
name|src
operator|->
name|bytes_in_buffer
expr_stmt|;
block|}
name|bytes_in_buffer
operator|--
expr_stmt|;
name|c
operator|=
name|GETJOCTET
argument_list|(
operator|*
name|next_input_byte
operator|++
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|==
literal|0xFF
condition|)
do|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
comment|/* Found FF/00, which represents an FF data byte */
name|c
operator|=
literal|0xFF
expr_stmt|;
block|}
else|else
block|{
comment|/* Oops, it's actually a marker indicating end of compressed data. 	   * Save the marker code for later use. 	   * Fine point: it might appear that we should save the marker into 	   * bitread working state, not straight into permanent state.  But 	   * once we have hit a marker, we cannot need to suspend within the 	   * current MCU, because we will read no more bytes from the data 	   * source.  So it is OK to update permanent state right away. 	   */
name|cinfo
operator|->
name|unread_marker
operator|=
name|c
expr_stmt|;
comment|/* See if we need to insert some fake zero bits. */
goto|goto
name|no_more_bytes
goto|;
block|}
block|}
comment|/* OK, load c into get_buffer */
name|get_buffer
operator|=
operator|(
name|get_buffer
operator|<<
literal|8
operator|)
operator||
name|c
expr_stmt|;
name|bits_left
operator|+=
literal|8
expr_stmt|;
block|}
comment|/* end while */
block|}
else|else
block|{
name|no_more_bytes
label|:
comment|/* We get here if we've read the marker that terminates the compressed      * data segment.  There should be enough bits in the buffer register      * to satisfy the request; if so, no problem.      */
if|if
condition|(
name|nbits
operator|>
name|bits_left
condition|)
block|{
comment|/* Uh-oh.  Report corrupted data to user and stuff zeroes into        * the data stream, so that we can produce some kind of image.        * We use a nonvolatile flag to ensure that only one warning message        * appears per data segment.        */
if|if
condition|(
operator|!
operator|(
operator|(
name|huff_entropy_ptr
operator|)
name|cinfo
operator|->
name|entropy
operator|)
operator|->
name|insufficient_data
condition|)
block|{
name|WARNMS
argument_list|(
name|cinfo
argument_list|,
name|JWRN_HIT_MARKER
argument_list|)
expr_stmt|;
operator|(
operator|(
name|huff_entropy_ptr
operator|)
name|cinfo
operator|->
name|entropy
operator|)
operator|->
name|insufficient_data
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* Fill the buffer with zero bits */
name|get_buffer
operator|<<=
name|MIN_GET_BITS
operator|-
name|bits_left
expr_stmt|;
name|bits_left
operator|=
name|MIN_GET_BITS
expr_stmt|;
block|}
block|}
comment|/* Unload the local registers */
name|state
operator|->
name|next_input_byte
operator|=
name|next_input_byte
expr_stmt|;
name|state
operator|->
name|bytes_in_buffer
operator|=
name|bytes_in_buffer
expr_stmt|;
name|state
operator|->
name|get_buffer
operator|=
name|get_buffer
expr_stmt|;
name|state
operator|->
name|bits_left
operator|=
name|bits_left
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_block
begin_comment
comment|/*  * Figure F.12: extend sign bit.  * On some machines, a shift and sub will be faster than a table lookup.  */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|AVOID_TABLES
end_ifdef
begin_define
DECL|macro|BIT_MASK
define|#
directive|define
name|BIT_MASK
parameter_list|(
name|nbits
parameter_list|)
value|((1<<(nbits))-1)
end_define
begin_define
DECL|macro|HUFF_EXTEND
define|#
directive|define
name|HUFF_EXTEND
parameter_list|(
name|x
parameter_list|,
name|s
parameter_list|)
value|((x)< (1<<((s)-1)) ? (x) - ((1<<(s))-1) : (x))
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|BIT_MASK
define|#
directive|define
name|BIT_MASK
parameter_list|(
name|nbits
parameter_list|)
value|bmask[nbits]
end_define
begin_define
DECL|macro|HUFF_EXTEND
define|#
directive|define
name|HUFF_EXTEND
parameter_list|(
name|x
parameter_list|,
name|s
parameter_list|)
value|((x)<= bmask[(s) - 1] ? (x) - bmask[s] : (x))
end_define
begin_decl_stmt
DECL|variable|bmask
specifier|static
specifier|const
name|int
name|bmask
index|[
literal|16
index|]
init|=
comment|/* bmask[n] is mask for n rightmost bits */
block|{
literal|0
block|,
literal|0x0001
block|,
literal|0x0003
block|,
literal|0x0007
block|,
literal|0x000F
block|,
literal|0x001F
block|,
literal|0x003F
block|,
literal|0x007F
block|,
literal|0x00FF
block|,
literal|0x01FF
block|,
literal|0x03FF
block|,
literal|0x07FF
block|,
literal|0x0FFF
block|,
literal|0x1FFF
block|,
literal|0x3FFF
block|,
literal|0x7FFF
block|}
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* AVOID_TABLES */
end_comment
begin_comment
comment|/*  * Out-of-line code for Huffman code decoding.  */
end_comment
begin_macro
name|LOCAL
argument_list|(
argument|int
argument_list|)
end_macro
begin_macro
DECL|function|jpeg_huff_decode
name|jpeg_huff_decode
argument_list|(
argument|bitread_working_state * state
argument_list|,
argument|register bit_buf_type get_buffer
argument_list|,
argument|register int bits_left
argument_list|,
argument|d_derived_tbl * htbl
argument_list|,
argument|int min_bits
argument_list|)
end_macro
begin_block
block|{
specifier|register
name|int
name|l
init|=
name|min_bits
decl_stmt|;
specifier|register
name|INT32
name|code
decl_stmt|;
comment|/* HUFF_DECODE has determined that the code is at least min_bits */
comment|/* bits long, so fetch that many bits in one swoop. */
name|CHECK_BIT_BUFFER
argument_list|(
argument|*state
argument_list|,
argument|l
argument_list|,
argument|return -
literal|1
argument_list|)
empty_stmt|;
name|code
operator|=
name|GET_BITS
argument_list|(
name|l
argument_list|)
expr_stmt|;
comment|/* Collect the rest of the Huffman code one bit at a time. */
comment|/* This is per Figure F.16 in the JPEG spec. */
while|while
condition|(
name|code
operator|>
name|htbl
operator|->
name|maxcode
index|[
name|l
index|]
condition|)
block|{
name|code
operator|<<=
literal|1
expr_stmt|;
name|CHECK_BIT_BUFFER
argument_list|(
argument|*state
argument_list|,
literal|1
argument_list|,
argument|return -
literal|1
argument_list|)
empty_stmt|;
name|code
operator||=
name|GET_BITS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|l
operator|++
expr_stmt|;
block|}
comment|/* Unload the local registers */
name|state
operator|->
name|get_buffer
operator|=
name|get_buffer
expr_stmt|;
name|state
operator|->
name|bits_left
operator|=
name|bits_left
expr_stmt|;
comment|/* With garbage input we may reach the sentinel value l = 17. */
if|if
condition|(
name|l
operator|>
literal|16
condition|)
block|{
name|WARNMS
argument_list|(
name|state
operator|->
name|cinfo
argument_list|,
name|JWRN_HUFF_BAD_CODE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* fake a zero as the safest result */
block|}
return|return
name|htbl
operator|->
name|pub
operator|->
name|huffval
index|[
call|(
name|int
call|)
argument_list|(
name|code
operator|+
name|htbl
operator|->
name|valoffset
index|[
name|l
index|]
argument_list|)
index|]
return|;
block|}
end_block
begin_comment
comment|/*  * Check for a restart marker& resynchronize decoder.  * Returns FALSE if must suspend.  */
end_comment
begin_macro
DECL|function|LOCAL
name|LOCAL
argument_list|(
argument|boolean
argument_list|)
end_macro
begin_macro
name|process_restart
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|)
end_macro
begin_block
block|{
name|huff_entropy_ptr
name|entropy
init|=
operator|(
name|huff_entropy_ptr
operator|)
name|cinfo
operator|->
name|entropy
decl_stmt|;
name|int
name|ci
decl_stmt|;
comment|/* Throw away any unused bits remaining in bit buffer; */
comment|/* include any full bytes in next_marker's count of discarded bytes */
name|cinfo
operator|->
name|marker
operator|->
name|discarded_bytes
operator|+=
name|entropy
operator|->
name|bitstate
operator|.
name|bits_left
operator|/
literal|8
expr_stmt|;
name|entropy
operator|->
name|bitstate
operator|.
name|bits_left
operator|=
literal|0
expr_stmt|;
comment|/* Advance past the RSTn marker */
if|if
condition|(
operator|!
call|(
modifier|*
name|cinfo
operator|->
name|marker
operator|->
name|read_restart_marker
call|)
argument_list|(
name|cinfo
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Re-initialize DC predictions to 0 */
for|for
control|(
name|ci
operator|=
literal|0
init|;
name|ci
operator|<
name|cinfo
operator|->
name|comps_in_scan
condition|;
name|ci
operator|++
control|)
name|entropy
operator|->
name|saved
operator|.
name|last_dc_val
index|[
name|ci
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Re-init EOB run count, too */
name|entropy
operator|->
name|saved
operator|.
name|EOBRUN
operator|=
literal|0
expr_stmt|;
comment|/* Reset restart counter */
name|entropy
operator|->
name|restarts_to_go
operator|=
name|cinfo
operator|->
name|restart_interval
expr_stmt|;
comment|/* Reset out-of-data flag, unless read_restart_marker left us smack up    * against a marker.  In that case we will end up treating the next data    * segment as empty, and we can avoid producing bogus output pixels by    * leaving the flag set.    */
if|if
condition|(
name|cinfo
operator|->
name|unread_marker
operator|==
literal|0
condition|)
name|entropy
operator|->
name|insufficient_data
operator|=
name|FALSE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_block
begin_comment
comment|/*  * Huffman MCU decoding.  * Each of these routines decodes and returns one MCU's worth of  * Huffman-compressed coefficients.   * The coefficients are reordered from zigzag order into natural array order,  * but are not dequantized.  *  * The i'th block of the MCU is stored into the block pointed to by  * MCU_data[i].  WE ASSUME THIS AREA IS INITIALLY ZEROED BY THE CALLER.  * (Wholesale zeroing is usually a little faster than retail...)  *  * We return FALSE if data source requested suspension.  In that case no  * changes have been made to permanent state.  (Exception: some output  * coefficients may already have been assigned.  This is harmless for  * spectral selection, since we'll just re-assign them on the next call.  * Successive approximation AC refinement has to be more careful, however.)  */
end_comment
begin_comment
comment|/*  * MCU decoding for DC initial scan (either spectral selection,  * or first pass of successive approximation).  */
end_comment
begin_macro
DECL|function|METHODDEF
name|METHODDEF
argument_list|(
argument|boolean
argument_list|)
end_macro
begin_macro
name|decode_mcu_DC_first
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|,
argument|JBLOCKROW *MCU_data
argument_list|)
end_macro
begin_block
block|{
name|huff_entropy_ptr
name|entropy
init|=
operator|(
name|huff_entropy_ptr
operator|)
name|cinfo
operator|->
name|entropy
decl_stmt|;
name|int
name|Al
init|=
name|cinfo
operator|->
name|Al
decl_stmt|;
specifier|register
name|int
name|s
decl_stmt|,
name|r
decl_stmt|;
name|int
name|blkn
decl_stmt|,
name|ci
decl_stmt|;
name|JBLOCKROW
name|block
decl_stmt|;
name|BITREAD_STATE_VARS
expr_stmt|;
name|savable_state
name|state
decl_stmt|;
name|d_derived_tbl
modifier|*
name|tbl
decl_stmt|;
name|jpeg_component_info
modifier|*
name|compptr
decl_stmt|;
comment|/* Process restart marker if needed; may have to suspend */
if|if
condition|(
name|cinfo
operator|->
name|restart_interval
condition|)
block|{
if|if
condition|(
name|entropy
operator|->
name|restarts_to_go
operator|==
literal|0
condition|)
if|if
condition|(
operator|!
name|process_restart
argument_list|(
name|cinfo
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* If we've run out of data, just leave the MCU set to zeroes.    * This way, we return uniform gray for the remainder of the segment.    */
if|if
condition|(
operator|!
name|entropy
operator|->
name|insufficient_data
condition|)
block|{
comment|/* Load up working state */
name|BITREAD_LOAD_STATE
argument_list|(
name|cinfo
argument_list|,
name|entropy
operator|->
name|bitstate
argument_list|)
expr_stmt|;
name|ASSIGN_STATE
argument_list|(
name|state
argument_list|,
name|entropy
operator|->
name|saved
argument_list|)
expr_stmt|;
comment|/* Outer loop handles each block in the MCU */
for|for
control|(
name|blkn
operator|=
literal|0
init|;
name|blkn
operator|<
name|cinfo
operator|->
name|blocks_in_MCU
condition|;
name|blkn
operator|++
control|)
block|{
name|block
operator|=
name|MCU_data
index|[
name|blkn
index|]
expr_stmt|;
name|ci
operator|=
name|cinfo
operator|->
name|MCU_membership
index|[
name|blkn
index|]
expr_stmt|;
name|compptr
operator|=
name|cinfo
operator|->
name|cur_comp_info
index|[
name|ci
index|]
expr_stmt|;
name|tbl
operator|=
name|entropy
operator|->
name|derived_tbls
index|[
name|compptr
operator|->
name|dc_tbl_no
index|]
expr_stmt|;
comment|/* Decode a single block's worth of coefficients */
comment|/* Section F.2.2.1: decode the DC coefficient difference */
name|HUFF_DECODE
argument_list|(
argument|s
argument_list|,
argument|br_state
argument_list|,
argument|tbl
argument_list|,
argument|return FALSE
argument_list|,
argument|label1
argument_list|)
empty_stmt|;
if|if
condition|(
name|s
condition|)
block|{
name|CHECK_BIT_BUFFER
argument_list|(
argument|br_state
argument_list|,
argument|s
argument_list|,
argument|return FALSE
argument_list|)
empty_stmt|;
name|r
operator|=
name|GET_BITS
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|HUFF_EXTEND
argument_list|(
name|r
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
comment|/* Convert DC difference to actual value, update last_dc_val */
name|s
operator|+=
name|state
operator|.
name|last_dc_val
index|[
name|ci
index|]
expr_stmt|;
name|state
operator|.
name|last_dc_val
index|[
name|ci
index|]
operator|=
name|s
expr_stmt|;
comment|/* Scale and output the coefficient (assumes jpeg_natural_order[0]=0) */
operator|(
operator|*
name|block
operator|)
index|[
literal|0
index|]
operator|=
call|(
name|JCOEF
call|)
argument_list|(
name|s
operator|<<
name|Al
argument_list|)
expr_stmt|;
block|}
comment|/* Completed MCU, so update state */
name|BITREAD_SAVE_STATE
argument_list|(
name|cinfo
argument_list|,
name|entropy
operator|->
name|bitstate
argument_list|)
expr_stmt|;
name|ASSIGN_STATE
argument_list|(
name|entropy
operator|->
name|saved
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
comment|/* Account for restart interval (no-op if not using restarts) */
name|entropy
operator|->
name|restarts_to_go
operator|--
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_block
begin_comment
comment|/*  * MCU decoding for AC initial scan (either spectral selection,  * or first pass of successive approximation).  */
end_comment
begin_macro
DECL|function|METHODDEF
name|METHODDEF
argument_list|(
argument|boolean
argument_list|)
end_macro
begin_macro
name|decode_mcu_AC_first
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|,
argument|JBLOCKROW *MCU_data
argument_list|)
end_macro
begin_block
block|{
name|huff_entropy_ptr
name|entropy
init|=
operator|(
name|huff_entropy_ptr
operator|)
name|cinfo
operator|->
name|entropy
decl_stmt|;
specifier|register
name|int
name|s
decl_stmt|,
name|k
decl_stmt|,
name|r
decl_stmt|;
name|unsigned
name|int
name|EOBRUN
decl_stmt|;
name|int
name|Se
decl_stmt|,
name|Al
decl_stmt|;
specifier|const
name|int
modifier|*
name|natural_order
decl_stmt|;
name|JBLOCKROW
name|block
decl_stmt|;
name|BITREAD_STATE_VARS
expr_stmt|;
name|d_derived_tbl
modifier|*
name|tbl
decl_stmt|;
comment|/* Process restart marker if needed; may have to suspend */
if|if
condition|(
name|cinfo
operator|->
name|restart_interval
condition|)
block|{
if|if
condition|(
name|entropy
operator|->
name|restarts_to_go
operator|==
literal|0
condition|)
if|if
condition|(
operator|!
name|process_restart
argument_list|(
name|cinfo
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* If we've run out of data, just leave the MCU set to zeroes.    * This way, we return uniform gray for the remainder of the segment.    */
if|if
condition|(
operator|!
name|entropy
operator|->
name|insufficient_data
condition|)
block|{
name|Se
operator|=
name|cinfo
operator|->
name|Se
expr_stmt|;
name|Al
operator|=
name|cinfo
operator|->
name|Al
expr_stmt|;
name|natural_order
operator|=
name|cinfo
operator|->
name|natural_order
expr_stmt|;
comment|/* Load up working state.      * We can avoid loading/saving bitread state if in an EOB run.      */
name|EOBRUN
operator|=
name|entropy
operator|->
name|saved
operator|.
name|EOBRUN
expr_stmt|;
comment|/* only part of saved state we need */
comment|/* There is always only one block per MCU */
if|if
condition|(
name|EOBRUN
operator|>
literal|0
condition|)
comment|/* if it's a band of zeroes... */
name|EOBRUN
operator|--
expr_stmt|;
comment|/* ...process it now (we do nothing) */
else|else
block|{
name|BITREAD_LOAD_STATE
argument_list|(
name|cinfo
argument_list|,
name|entropy
operator|->
name|bitstate
argument_list|)
expr_stmt|;
name|block
operator|=
name|MCU_data
index|[
literal|0
index|]
expr_stmt|;
name|tbl
operator|=
name|entropy
operator|->
name|ac_derived_tbl
expr_stmt|;
for|for
control|(
name|k
operator|=
name|cinfo
operator|->
name|Ss
init|;
name|k
operator|<=
name|Se
condition|;
name|k
operator|++
control|)
block|{
name|HUFF_DECODE
argument_list|(
argument|s
argument_list|,
argument|br_state
argument_list|,
argument|tbl
argument_list|,
argument|return FALSE
argument_list|,
argument|label2
argument_list|)
empty_stmt|;
name|r
operator|=
name|s
operator|>>
literal|4
expr_stmt|;
name|s
operator|&=
literal|15
expr_stmt|;
if|if
condition|(
name|s
condition|)
block|{
name|k
operator|+=
name|r
expr_stmt|;
name|CHECK_BIT_BUFFER
argument_list|(
argument|br_state
argument_list|,
argument|s
argument_list|,
argument|return FALSE
argument_list|)
empty_stmt|;
name|r
operator|=
name|GET_BITS
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|HUFF_EXTEND
argument_list|(
name|r
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* Scale and output coefficient in natural (dezigzagged) order */
operator|(
operator|*
name|block
operator|)
index|[
name|natural_order
index|[
name|k
index|]
index|]
operator|=
call|(
name|JCOEF
call|)
argument_list|(
name|s
operator|<<
name|Al
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|r
operator|==
literal|15
condition|)
block|{
comment|/* ZRL */
name|k
operator|+=
literal|15
expr_stmt|;
comment|/* skip 15 zeroes in band */
block|}
else|else
block|{
comment|/* EOBr, run length is 2^r + appended bits */
name|EOBRUN
operator|=
literal|1
operator|<<
name|r
expr_stmt|;
if|if
condition|(
name|r
condition|)
block|{
comment|/* EOBr, r> 0 */
name|CHECK_BIT_BUFFER
argument_list|(
argument|br_state
argument_list|,
argument|r
argument_list|,
argument|return FALSE
argument_list|)
empty_stmt|;
name|r
operator|=
name|GET_BITS
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|EOBRUN
operator|+=
name|r
expr_stmt|;
block|}
name|EOBRUN
operator|--
expr_stmt|;
comment|/* this band is processed at this moment */
break|break;
comment|/* force end-of-band */
block|}
block|}
block|}
name|BITREAD_SAVE_STATE
argument_list|(
name|cinfo
argument_list|,
name|entropy
operator|->
name|bitstate
argument_list|)
expr_stmt|;
block|}
comment|/* Completed MCU, so update state */
name|entropy
operator|->
name|saved
operator|.
name|EOBRUN
operator|=
name|EOBRUN
expr_stmt|;
comment|/* only part of saved state we need */
block|}
comment|/* Account for restart interval (no-op if not using restarts) */
name|entropy
operator|->
name|restarts_to_go
operator|--
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_block
begin_comment
comment|/*  * MCU decoding for DC successive approximation refinement scan.  * Note: we assume such scans can be multi-component, although the spec  * is not very clear on the point.  */
end_comment
begin_macro
DECL|function|METHODDEF
name|METHODDEF
argument_list|(
argument|boolean
argument_list|)
end_macro
begin_macro
name|decode_mcu_DC_refine
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|,
argument|JBLOCKROW *MCU_data
argument_list|)
end_macro
begin_block
block|{
name|huff_entropy_ptr
name|entropy
init|=
operator|(
name|huff_entropy_ptr
operator|)
name|cinfo
operator|->
name|entropy
decl_stmt|;
name|int
name|p1
init|=
literal|1
operator|<<
name|cinfo
operator|->
name|Al
decl_stmt|;
comment|/* 1 in the bit position being coded */
name|int
name|blkn
decl_stmt|;
name|JBLOCKROW
name|block
decl_stmt|;
name|BITREAD_STATE_VARS
expr_stmt|;
comment|/* Process restart marker if needed; may have to suspend */
if|if
condition|(
name|cinfo
operator|->
name|restart_interval
condition|)
block|{
if|if
condition|(
name|entropy
operator|->
name|restarts_to_go
operator|==
literal|0
condition|)
if|if
condition|(
operator|!
name|process_restart
argument_list|(
name|cinfo
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* Not worth the cycles to check insufficient_data here,    * since we will not change the data anyway if we read zeroes.    */
comment|/* Load up working state */
name|BITREAD_LOAD_STATE
argument_list|(
name|cinfo
argument_list|,
name|entropy
operator|->
name|bitstate
argument_list|)
expr_stmt|;
comment|/* Outer loop handles each block in the MCU */
for|for
control|(
name|blkn
operator|=
literal|0
init|;
name|blkn
operator|<
name|cinfo
operator|->
name|blocks_in_MCU
condition|;
name|blkn
operator|++
control|)
block|{
name|block
operator|=
name|MCU_data
index|[
name|blkn
index|]
expr_stmt|;
comment|/* Encoded data is simply the next bit of the two's-complement DC value */
name|CHECK_BIT_BUFFER
argument_list|(
argument|br_state
argument_list|,
literal|1
argument_list|,
argument|return FALSE
argument_list|)
empty_stmt|;
if|if
condition|(
name|GET_BITS
argument_list|(
literal|1
argument_list|)
condition|)
operator|(
operator|*
name|block
operator|)
index|[
literal|0
index|]
operator||=
name|p1
expr_stmt|;
comment|/* Note: since we use |=, repeating the assignment later is safe */
block|}
comment|/* Completed MCU, so update state */
name|BITREAD_SAVE_STATE
argument_list|(
name|cinfo
argument_list|,
name|entropy
operator|->
name|bitstate
argument_list|)
expr_stmt|;
comment|/* Account for restart interval (no-op if not using restarts) */
name|entropy
operator|->
name|restarts_to_go
operator|--
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_block
begin_comment
comment|/*  * MCU decoding for AC successive approximation refinement scan.  */
end_comment
begin_macro
DECL|function|METHODDEF
name|METHODDEF
argument_list|(
argument|boolean
argument_list|)
end_macro
begin_macro
name|decode_mcu_AC_refine
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|,
argument|JBLOCKROW *MCU_data
argument_list|)
end_macro
begin_block
block|{
name|huff_entropy_ptr
name|entropy
init|=
operator|(
name|huff_entropy_ptr
operator|)
name|cinfo
operator|->
name|entropy
decl_stmt|;
specifier|register
name|int
name|s
decl_stmt|,
name|k
decl_stmt|,
name|r
decl_stmt|;
name|unsigned
name|int
name|EOBRUN
decl_stmt|;
name|int
name|Se
decl_stmt|,
name|p1
decl_stmt|,
name|m1
decl_stmt|;
specifier|const
name|int
modifier|*
name|natural_order
decl_stmt|;
name|JBLOCKROW
name|block
decl_stmt|;
name|JCOEFPTR
name|thiscoef
decl_stmt|;
name|BITREAD_STATE_VARS
expr_stmt|;
name|d_derived_tbl
modifier|*
name|tbl
decl_stmt|;
name|int
name|num_newnz
decl_stmt|;
name|int
name|newnz_pos
index|[
name|DCTSIZE2
index|]
decl_stmt|;
comment|/* Process restart marker if needed; may have to suspend */
if|if
condition|(
name|cinfo
operator|->
name|restart_interval
condition|)
block|{
if|if
condition|(
name|entropy
operator|->
name|restarts_to_go
operator|==
literal|0
condition|)
if|if
condition|(
operator|!
name|process_restart
argument_list|(
name|cinfo
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* If we've run out of data, don't modify the MCU.    */
if|if
condition|(
operator|!
name|entropy
operator|->
name|insufficient_data
condition|)
block|{
name|Se
operator|=
name|cinfo
operator|->
name|Se
expr_stmt|;
name|p1
operator|=
literal|1
operator|<<
name|cinfo
operator|->
name|Al
expr_stmt|;
comment|/* 1 in the bit position being coded */
name|m1
operator|=
operator|(
operator|-
literal|1
operator|)
operator|<<
name|cinfo
operator|->
name|Al
expr_stmt|;
comment|/* -1 in the bit position being coded */
name|natural_order
operator|=
name|cinfo
operator|->
name|natural_order
expr_stmt|;
comment|/* Load up working state */
name|BITREAD_LOAD_STATE
argument_list|(
name|cinfo
argument_list|,
name|entropy
operator|->
name|bitstate
argument_list|)
expr_stmt|;
name|EOBRUN
operator|=
name|entropy
operator|->
name|saved
operator|.
name|EOBRUN
expr_stmt|;
comment|/* only part of saved state we need */
comment|/* There is always only one block per MCU */
name|block
operator|=
name|MCU_data
index|[
literal|0
index|]
expr_stmt|;
name|tbl
operator|=
name|entropy
operator|->
name|ac_derived_tbl
expr_stmt|;
comment|/* If we are forced to suspend, we must undo the assignments to any newly      * nonzero coefficients in the block, because otherwise we'd get confused      * next time about which coefficients were already nonzero.      * But we need not undo addition of bits to already-nonzero coefficients;      * instead, we can test the current bit to see if we already did it.      */
name|num_newnz
operator|=
literal|0
expr_stmt|;
comment|/* initialize coefficient loop counter to start of band */
name|k
operator|=
name|cinfo
operator|->
name|Ss
expr_stmt|;
if|if
condition|(
name|EOBRUN
operator|==
literal|0
condition|)
block|{
for|for
control|(
init|;
name|k
operator|<=
name|Se
condition|;
name|k
operator|++
control|)
block|{
name|HUFF_DECODE
argument_list|(
argument|s
argument_list|,
argument|br_state
argument_list|,
argument|tbl
argument_list|,
argument|goto undoit
argument_list|,
argument|label3
argument_list|)
empty_stmt|;
name|r
operator|=
name|s
operator|>>
literal|4
expr_stmt|;
name|s
operator|&=
literal|15
expr_stmt|;
if|if
condition|(
name|s
condition|)
block|{
if|if
condition|(
name|s
operator|!=
literal|1
condition|)
comment|/* size of new coef should always be 1 */
name|WARNMS
argument_list|(
name|cinfo
argument_list|,
name|JWRN_HUFF_BAD_CODE
argument_list|)
expr_stmt|;
name|CHECK_BIT_BUFFER
argument_list|(
argument|br_state
argument_list|,
literal|1
argument_list|,
argument|goto undoit
argument_list|)
empty_stmt|;
if|if
condition|(
name|GET_BITS
argument_list|(
literal|1
argument_list|)
condition|)
name|s
operator|=
name|p1
expr_stmt|;
comment|/* newly nonzero coef is positive */
else|else
name|s
operator|=
name|m1
expr_stmt|;
comment|/* newly nonzero coef is negative */
block|}
else|else
block|{
if|if
condition|(
name|r
operator|!=
literal|15
condition|)
block|{
name|EOBRUN
operator|=
literal|1
operator|<<
name|r
expr_stmt|;
comment|/* EOBr, run length is 2^r + appended bits */
if|if
condition|(
name|r
condition|)
block|{
name|CHECK_BIT_BUFFER
argument_list|(
argument|br_state
argument_list|,
argument|r
argument_list|,
argument|goto undoit
argument_list|)
empty_stmt|;
name|r
operator|=
name|GET_BITS
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|EOBRUN
operator|+=
name|r
expr_stmt|;
block|}
break|break;
comment|/* rest of block is handled by EOB logic */
block|}
comment|/* note s = 0 for processing ZRL */
block|}
comment|/* Advance over already-nonzero coefs and r still-zero coefs, 	 * appending correction bits to the nonzeroes.  A correction bit is 1 	 * if the absolute value of the coefficient must be increased. 	 */
do|do
block|{
name|thiscoef
operator|=
operator|*
name|block
operator|+
name|natural_order
index|[
name|k
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|thiscoef
operator|!=
literal|0
condition|)
block|{
name|CHECK_BIT_BUFFER
argument_list|(
argument|br_state
argument_list|,
literal|1
argument_list|,
argument|goto undoit
argument_list|)
empty_stmt|;
if|if
condition|(
name|GET_BITS
argument_list|(
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|thiscoef
operator|&
name|p1
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* do nothing if already set it */
if|if
condition|(
operator|*
name|thiscoef
operator|>=
literal|0
condition|)
operator|*
name|thiscoef
operator|+=
name|p1
expr_stmt|;
else|else
operator|*
name|thiscoef
operator|+=
name|m1
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
operator|--
name|r
operator|<
literal|0
condition|)
break|break;
comment|/* reached target zero coefficient */
block|}
name|k
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|k
operator|<=
name|Se
condition|)
do|;
if|if
condition|(
name|s
condition|)
block|{
name|int
name|pos
init|=
name|natural_order
index|[
name|k
index|]
decl_stmt|;
comment|/* Output newly nonzero coefficient */
operator|(
operator|*
name|block
operator|)
index|[
name|pos
index|]
operator|=
operator|(
name|JCOEF
operator|)
name|s
expr_stmt|;
comment|/* Remember its position in case we have to suspend */
name|newnz_pos
index|[
name|num_newnz
operator|++
index|]
operator|=
name|pos
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|EOBRUN
operator|>
literal|0
condition|)
block|{
comment|/* Scan any remaining coefficient positions after the end-of-band        * (the last newly nonzero coefficient, if any).  Append a correction        * bit to each already-nonzero coefficient.  A correction bit is 1        * if the absolute value of the coefficient must be increased.        */
for|for
control|(
init|;
name|k
operator|<=
name|Se
condition|;
name|k
operator|++
control|)
block|{
name|thiscoef
operator|=
operator|*
name|block
operator|+
name|natural_order
index|[
name|k
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|thiscoef
operator|!=
literal|0
condition|)
block|{
name|CHECK_BIT_BUFFER
argument_list|(
argument|br_state
argument_list|,
literal|1
argument_list|,
argument|goto undoit
argument_list|)
empty_stmt|;
if|if
condition|(
name|GET_BITS
argument_list|(
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|thiscoef
operator|&
name|p1
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* do nothing if already changed it */
if|if
condition|(
operator|*
name|thiscoef
operator|>=
literal|0
condition|)
operator|*
name|thiscoef
operator|+=
name|p1
expr_stmt|;
else|else
operator|*
name|thiscoef
operator|+=
name|m1
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Count one block completed in EOB run */
name|EOBRUN
operator|--
expr_stmt|;
block|}
comment|/* Completed MCU, so update state */
name|BITREAD_SAVE_STATE
argument_list|(
name|cinfo
argument_list|,
name|entropy
operator|->
name|bitstate
argument_list|)
expr_stmt|;
name|entropy
operator|->
name|saved
operator|.
name|EOBRUN
operator|=
name|EOBRUN
expr_stmt|;
comment|/* only part of saved state we need */
block|}
comment|/* Account for restart interval (no-op if not using restarts) */
name|entropy
operator|->
name|restarts_to_go
operator|--
expr_stmt|;
return|return
name|TRUE
return|;
name|undoit
label|:
comment|/* Re-zero any output coefficients that we made newly nonzero */
while|while
condition|(
name|num_newnz
operator|>
literal|0
condition|)
operator|(
operator|*
name|block
operator|)
index|[
name|newnz_pos
index|[
operator|--
name|num_newnz
index|]
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_block
begin_comment
comment|/*  * Decode one MCU's worth of Huffman-compressed coefficients,  * partial blocks.  */
end_comment
begin_macro
DECL|function|METHODDEF
name|METHODDEF
argument_list|(
argument|boolean
argument_list|)
end_macro
begin_macro
name|decode_mcu_sub
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|,
argument|JBLOCKROW *MCU_data
argument_list|)
end_macro
begin_block
block|{
name|huff_entropy_ptr
name|entropy
init|=
operator|(
name|huff_entropy_ptr
operator|)
name|cinfo
operator|->
name|entropy
decl_stmt|;
specifier|const
name|int
modifier|*
name|natural_order
decl_stmt|;
name|int
name|Se
decl_stmt|,
name|blkn
decl_stmt|;
name|BITREAD_STATE_VARS
expr_stmt|;
name|savable_state
name|state
decl_stmt|;
comment|/* Process restart marker if needed; may have to suspend */
if|if
condition|(
name|cinfo
operator|->
name|restart_interval
condition|)
block|{
if|if
condition|(
name|entropy
operator|->
name|restarts_to_go
operator|==
literal|0
condition|)
if|if
condition|(
operator|!
name|process_restart
argument_list|(
name|cinfo
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* If we've run out of data, just leave the MCU set to zeroes.    * This way, we return uniform gray for the remainder of the segment.    */
if|if
condition|(
operator|!
name|entropy
operator|->
name|insufficient_data
condition|)
block|{
name|natural_order
operator|=
name|cinfo
operator|->
name|natural_order
expr_stmt|;
name|Se
operator|=
name|cinfo
operator|->
name|lim_Se
expr_stmt|;
comment|/* Load up working state */
name|BITREAD_LOAD_STATE
argument_list|(
name|cinfo
argument_list|,
name|entropy
operator|->
name|bitstate
argument_list|)
expr_stmt|;
name|ASSIGN_STATE
argument_list|(
name|state
argument_list|,
name|entropy
operator|->
name|saved
argument_list|)
expr_stmt|;
comment|/* Outer loop handles each block in the MCU */
for|for
control|(
name|blkn
operator|=
literal|0
init|;
name|blkn
operator|<
name|cinfo
operator|->
name|blocks_in_MCU
condition|;
name|blkn
operator|++
control|)
block|{
name|JBLOCKROW
name|block
init|=
name|MCU_data
index|[
name|blkn
index|]
decl_stmt|;
name|d_derived_tbl
modifier|*
name|htbl
decl_stmt|;
specifier|register
name|int
name|s
decl_stmt|,
name|k
decl_stmt|,
name|r
decl_stmt|;
name|int
name|coef_limit
decl_stmt|,
name|ci
decl_stmt|;
comment|/* Decode a single block's worth of coefficients */
comment|/* Section F.2.2.1: decode the DC coefficient difference */
name|htbl
operator|=
name|entropy
operator|->
name|dc_cur_tbls
index|[
name|blkn
index|]
expr_stmt|;
name|HUFF_DECODE
argument_list|(
argument|s
argument_list|,
argument|br_state
argument_list|,
argument|htbl
argument_list|,
argument|return FALSE
argument_list|,
argument|label1
argument_list|)
empty_stmt|;
name|htbl
operator|=
name|entropy
operator|->
name|ac_cur_tbls
index|[
name|blkn
index|]
expr_stmt|;
name|k
operator|=
literal|1
expr_stmt|;
name|coef_limit
operator|=
name|entropy
operator|->
name|coef_limit
index|[
name|blkn
index|]
expr_stmt|;
if|if
condition|(
name|coef_limit
condition|)
block|{
comment|/* Convert DC difference to actual value, update last_dc_val */
if|if
condition|(
name|s
condition|)
block|{
name|CHECK_BIT_BUFFER
argument_list|(
argument|br_state
argument_list|,
argument|s
argument_list|,
argument|return FALSE
argument_list|)
empty_stmt|;
name|r
operator|=
name|GET_BITS
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|HUFF_EXTEND
argument_list|(
name|r
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
name|ci
operator|=
name|cinfo
operator|->
name|MCU_membership
index|[
name|blkn
index|]
expr_stmt|;
name|s
operator|+=
name|state
operator|.
name|last_dc_val
index|[
name|ci
index|]
expr_stmt|;
name|state
operator|.
name|last_dc_val
index|[
name|ci
index|]
operator|=
name|s
expr_stmt|;
comment|/* Output the DC coefficient */
operator|(
operator|*
name|block
operator|)
index|[
literal|0
index|]
operator|=
operator|(
name|JCOEF
operator|)
name|s
expr_stmt|;
comment|/* Section F.2.2.2: decode the AC coefficients */
comment|/* Since zeroes are skipped, output area must be cleared beforehand */
for|for
control|(
init|;
name|k
operator|<
name|coef_limit
condition|;
name|k
operator|++
control|)
block|{
name|HUFF_DECODE
argument_list|(
argument|s
argument_list|,
argument|br_state
argument_list|,
argument|htbl
argument_list|,
argument|return FALSE
argument_list|,
argument|label2
argument_list|)
empty_stmt|;
name|r
operator|=
name|s
operator|>>
literal|4
expr_stmt|;
name|s
operator|&=
literal|15
expr_stmt|;
if|if
condition|(
name|s
condition|)
block|{
name|k
operator|+=
name|r
expr_stmt|;
name|CHECK_BIT_BUFFER
argument_list|(
argument|br_state
argument_list|,
argument|s
argument_list|,
argument|return FALSE
argument_list|)
empty_stmt|;
name|r
operator|=
name|GET_BITS
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|HUFF_EXTEND
argument_list|(
name|r
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* Output coefficient in natural (dezigzagged) order. 	     * Note: the extra entries in natural_order[] will save us 	     * if k> Se, which could happen if the data is corrupted. 	     */
operator|(
operator|*
name|block
operator|)
index|[
name|natural_order
index|[
name|k
index|]
index|]
operator|=
operator|(
name|JCOEF
operator|)
name|s
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|r
operator|!=
literal|15
condition|)
goto|goto
name|EndOfBlock
goto|;
name|k
operator|+=
literal|15
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|s
condition|)
block|{
name|CHECK_BIT_BUFFER
argument_list|(
argument|br_state
argument_list|,
argument|s
argument_list|,
argument|return FALSE
argument_list|)
empty_stmt|;
name|DROP_BITS
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Section F.2.2.2: decode the AC coefficients */
comment|/* In this path we just discard the values */
for|for
control|(
init|;
name|k
operator|<=
name|Se
condition|;
name|k
operator|++
control|)
block|{
name|HUFF_DECODE
argument_list|(
argument|s
argument_list|,
argument|br_state
argument_list|,
argument|htbl
argument_list|,
argument|return FALSE
argument_list|,
argument|label3
argument_list|)
empty_stmt|;
name|r
operator|=
name|s
operator|>>
literal|4
expr_stmt|;
name|s
operator|&=
literal|15
expr_stmt|;
if|if
condition|(
name|s
condition|)
block|{
name|k
operator|+=
name|r
expr_stmt|;
name|CHECK_BIT_BUFFER
argument_list|(
argument|br_state
argument_list|,
argument|s
argument_list|,
argument|return FALSE
argument_list|)
empty_stmt|;
name|DROP_BITS
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|r
operator|!=
literal|15
condition|)
break|break;
name|k
operator|+=
literal|15
expr_stmt|;
block|}
block|}
name|EndOfBlock
label|:
empty_stmt|;
block|}
comment|/* Completed MCU, so update state */
name|BITREAD_SAVE_STATE
argument_list|(
name|cinfo
argument_list|,
name|entropy
operator|->
name|bitstate
argument_list|)
expr_stmt|;
name|ASSIGN_STATE
argument_list|(
name|entropy
operator|->
name|saved
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
comment|/* Account for restart interval (no-op if not using restarts) */
name|entropy
operator|->
name|restarts_to_go
operator|--
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_block
begin_comment
comment|/*  * Decode one MCU's worth of Huffman-compressed coefficients,  * full-size blocks.  */
end_comment
begin_macro
DECL|function|METHODDEF
name|METHODDEF
argument_list|(
argument|boolean
argument_list|)
end_macro
begin_macro
name|decode_mcu
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|,
argument|JBLOCKROW *MCU_data
argument_list|)
end_macro
begin_block
block|{
name|huff_entropy_ptr
name|entropy
init|=
operator|(
name|huff_entropy_ptr
operator|)
name|cinfo
operator|->
name|entropy
decl_stmt|;
name|int
name|blkn
decl_stmt|;
name|BITREAD_STATE_VARS
expr_stmt|;
name|savable_state
name|state
decl_stmt|;
comment|/* Process restart marker if needed; may have to suspend */
if|if
condition|(
name|cinfo
operator|->
name|restart_interval
condition|)
block|{
if|if
condition|(
name|entropy
operator|->
name|restarts_to_go
operator|==
literal|0
condition|)
if|if
condition|(
operator|!
name|process_restart
argument_list|(
name|cinfo
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* If we've run out of data, just leave the MCU set to zeroes.    * This way, we return uniform gray for the remainder of the segment.    */
if|if
condition|(
operator|!
name|entropy
operator|->
name|insufficient_data
condition|)
block|{
comment|/* Load up working state */
name|BITREAD_LOAD_STATE
argument_list|(
name|cinfo
argument_list|,
name|entropy
operator|->
name|bitstate
argument_list|)
expr_stmt|;
name|ASSIGN_STATE
argument_list|(
name|state
argument_list|,
name|entropy
operator|->
name|saved
argument_list|)
expr_stmt|;
comment|/* Outer loop handles each block in the MCU */
for|for
control|(
name|blkn
operator|=
literal|0
init|;
name|blkn
operator|<
name|cinfo
operator|->
name|blocks_in_MCU
condition|;
name|blkn
operator|++
control|)
block|{
name|JBLOCKROW
name|block
init|=
name|MCU_data
index|[
name|blkn
index|]
decl_stmt|;
name|d_derived_tbl
modifier|*
name|htbl
decl_stmt|;
specifier|register
name|int
name|s
decl_stmt|,
name|k
decl_stmt|,
name|r
decl_stmt|;
name|int
name|coef_limit
decl_stmt|,
name|ci
decl_stmt|;
comment|/* Decode a single block's worth of coefficients */
comment|/* Section F.2.2.1: decode the DC coefficient difference */
name|htbl
operator|=
name|entropy
operator|->
name|dc_cur_tbls
index|[
name|blkn
index|]
expr_stmt|;
name|HUFF_DECODE
argument_list|(
argument|s
argument_list|,
argument|br_state
argument_list|,
argument|htbl
argument_list|,
argument|return FALSE
argument_list|,
argument|label1
argument_list|)
empty_stmt|;
name|htbl
operator|=
name|entropy
operator|->
name|ac_cur_tbls
index|[
name|blkn
index|]
expr_stmt|;
name|k
operator|=
literal|1
expr_stmt|;
name|coef_limit
operator|=
name|entropy
operator|->
name|coef_limit
index|[
name|blkn
index|]
expr_stmt|;
if|if
condition|(
name|coef_limit
condition|)
block|{
comment|/* Convert DC difference to actual value, update last_dc_val */
if|if
condition|(
name|s
condition|)
block|{
name|CHECK_BIT_BUFFER
argument_list|(
argument|br_state
argument_list|,
argument|s
argument_list|,
argument|return FALSE
argument_list|)
empty_stmt|;
name|r
operator|=
name|GET_BITS
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|HUFF_EXTEND
argument_list|(
name|r
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
name|ci
operator|=
name|cinfo
operator|->
name|MCU_membership
index|[
name|blkn
index|]
expr_stmt|;
name|s
operator|+=
name|state
operator|.
name|last_dc_val
index|[
name|ci
index|]
expr_stmt|;
name|state
operator|.
name|last_dc_val
index|[
name|ci
index|]
operator|=
name|s
expr_stmt|;
comment|/* Output the DC coefficient */
operator|(
operator|*
name|block
operator|)
index|[
literal|0
index|]
operator|=
operator|(
name|JCOEF
operator|)
name|s
expr_stmt|;
comment|/* Section F.2.2.2: decode the AC coefficients */
comment|/* Since zeroes are skipped, output area must be cleared beforehand */
for|for
control|(
init|;
name|k
operator|<
name|coef_limit
condition|;
name|k
operator|++
control|)
block|{
name|HUFF_DECODE
argument_list|(
argument|s
argument_list|,
argument|br_state
argument_list|,
argument|htbl
argument_list|,
argument|return FALSE
argument_list|,
argument|label2
argument_list|)
empty_stmt|;
name|r
operator|=
name|s
operator|>>
literal|4
expr_stmt|;
name|s
operator|&=
literal|15
expr_stmt|;
if|if
condition|(
name|s
condition|)
block|{
name|k
operator|+=
name|r
expr_stmt|;
name|CHECK_BIT_BUFFER
argument_list|(
argument|br_state
argument_list|,
argument|s
argument_list|,
argument|return FALSE
argument_list|)
empty_stmt|;
name|r
operator|=
name|GET_BITS
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|HUFF_EXTEND
argument_list|(
name|r
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* Output coefficient in natural (dezigzagged) order. 	     * Note: the extra entries in jpeg_natural_order[] will save us 	     * if k>= DCTSIZE2, which could happen if the data is corrupted. 	     */
operator|(
operator|*
name|block
operator|)
index|[
name|jpeg_natural_order
index|[
name|k
index|]
index|]
operator|=
operator|(
name|JCOEF
operator|)
name|s
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|r
operator|!=
literal|15
condition|)
goto|goto
name|EndOfBlock
goto|;
name|k
operator|+=
literal|15
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|s
condition|)
block|{
name|CHECK_BIT_BUFFER
argument_list|(
argument|br_state
argument_list|,
argument|s
argument_list|,
argument|return FALSE
argument_list|)
empty_stmt|;
name|DROP_BITS
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Section F.2.2.2: decode the AC coefficients */
comment|/* In this path we just discard the values */
for|for
control|(
init|;
name|k
operator|<
name|DCTSIZE2
condition|;
name|k
operator|++
control|)
block|{
name|HUFF_DECODE
argument_list|(
argument|s
argument_list|,
argument|br_state
argument_list|,
argument|htbl
argument_list|,
argument|return FALSE
argument_list|,
argument|label3
argument_list|)
empty_stmt|;
name|r
operator|=
name|s
operator|>>
literal|4
expr_stmt|;
name|s
operator|&=
literal|15
expr_stmt|;
if|if
condition|(
name|s
condition|)
block|{
name|k
operator|+=
name|r
expr_stmt|;
name|CHECK_BIT_BUFFER
argument_list|(
argument|br_state
argument_list|,
argument|s
argument_list|,
argument|return FALSE
argument_list|)
empty_stmt|;
name|DROP_BITS
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|r
operator|!=
literal|15
condition|)
break|break;
name|k
operator|+=
literal|15
expr_stmt|;
block|}
block|}
name|EndOfBlock
label|:
empty_stmt|;
block|}
comment|/* Completed MCU, so update state */
name|BITREAD_SAVE_STATE
argument_list|(
name|cinfo
argument_list|,
name|entropy
operator|->
name|bitstate
argument_list|)
expr_stmt|;
name|ASSIGN_STATE
argument_list|(
name|entropy
operator|->
name|saved
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
comment|/* Account for restart interval (no-op if not using restarts) */
name|entropy
operator|->
name|restarts_to_go
operator|--
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_block
begin_comment
comment|/*  * Initialize for a Huffman-compressed scan.  */
end_comment
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|start_pass_huff_decoder
name|start_pass_huff_decoder
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|)
end_macro
begin_block
block|{
name|huff_entropy_ptr
name|entropy
init|=
operator|(
name|huff_entropy_ptr
operator|)
name|cinfo
operator|->
name|entropy
decl_stmt|;
name|int
name|ci
decl_stmt|,
name|blkn
decl_stmt|,
name|tbl
decl_stmt|,
name|i
decl_stmt|;
name|jpeg_component_info
modifier|*
name|compptr
decl_stmt|;
if|if
condition|(
name|cinfo
operator|->
name|progressive_mode
condition|)
block|{
comment|/* Validate progressive scan parameters */
if|if
condition|(
name|cinfo
operator|->
name|Ss
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|cinfo
operator|->
name|Se
operator|!=
literal|0
condition|)
goto|goto
name|bad
goto|;
block|}
else|else
block|{
comment|/* need not check Ss/Se< 0 since they came from unsigned bytes */
if|if
condition|(
name|cinfo
operator|->
name|Se
operator|<
name|cinfo
operator|->
name|Ss
operator|||
name|cinfo
operator|->
name|Se
operator|>
name|cinfo
operator|->
name|lim_Se
condition|)
goto|goto
name|bad
goto|;
comment|/* AC scans may have only one component */
if|if
condition|(
name|cinfo
operator|->
name|comps_in_scan
operator|!=
literal|1
condition|)
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|cinfo
operator|->
name|Ah
operator|!=
literal|0
condition|)
block|{
comment|/* Successive approximation refinement scan: must have Al = Ah-1. */
if|if
condition|(
name|cinfo
operator|->
name|Ah
operator|-
literal|1
operator|!=
name|cinfo
operator|->
name|Al
condition|)
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|cinfo
operator|->
name|Al
operator|>
literal|13
condition|)
block|{
comment|/* need not check for< 0 */
comment|/* Arguably the maximum Al value should be less than 13 for 8-bit precision,        * but the spec doesn't say so, and we try to be liberal about what we        * accept.  Note: large Al values could result in out-of-range DC        * coefficients during early scans, leading to bizarre displays due to        * overflows in the IDCT math.  But we won't crash.        */
name|bad
label|:
name|ERREXIT4
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_PROGRESSION
argument_list|,
name|cinfo
operator|->
name|Ss
argument_list|,
name|cinfo
operator|->
name|Se
argument_list|,
name|cinfo
operator|->
name|Ah
argument_list|,
name|cinfo
operator|->
name|Al
argument_list|)
expr_stmt|;
block|}
comment|/* Update progression status, and verify that scan order is legal.      * Note that inter-scan inconsistencies are treated as warnings      * not fatal errors ... not clear if this is right way to behave.      */
for|for
control|(
name|ci
operator|=
literal|0
init|;
name|ci
operator|<
name|cinfo
operator|->
name|comps_in_scan
condition|;
name|ci
operator|++
control|)
block|{
name|int
name|coefi
decl_stmt|,
name|cindex
init|=
name|cinfo
operator|->
name|cur_comp_info
index|[
name|ci
index|]
operator|->
name|component_index
decl_stmt|;
name|int
modifier|*
name|coef_bit_ptr
init|=
operator|&
name|cinfo
operator|->
name|coef_bits
index|[
name|cindex
index|]
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
name|cinfo
operator|->
name|Ss
operator|&&
name|coef_bit_ptr
index|[
literal|0
index|]
operator|<
literal|0
condition|)
comment|/* AC without prior DC scan */
name|WARNMS2
argument_list|(
name|cinfo
argument_list|,
name|JWRN_BOGUS_PROGRESSION
argument_list|,
name|cindex
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|coefi
operator|=
name|cinfo
operator|->
name|Ss
init|;
name|coefi
operator|<=
name|cinfo
operator|->
name|Se
condition|;
name|coefi
operator|++
control|)
block|{
name|int
name|expected
init|=
operator|(
name|coef_bit_ptr
index|[
name|coefi
index|]
operator|<
literal|0
operator|)
condition|?
literal|0
else|:
name|coef_bit_ptr
index|[
name|coefi
index|]
decl_stmt|;
if|if
condition|(
name|cinfo
operator|->
name|Ah
operator|!=
name|expected
condition|)
name|WARNMS2
argument_list|(
name|cinfo
argument_list|,
name|JWRN_BOGUS_PROGRESSION
argument_list|,
name|cindex
argument_list|,
name|coefi
argument_list|)
expr_stmt|;
name|coef_bit_ptr
index|[
name|coefi
index|]
operator|=
name|cinfo
operator|->
name|Al
expr_stmt|;
block|}
block|}
comment|/* Select MCU decoding routine */
if|if
condition|(
name|cinfo
operator|->
name|Ah
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|cinfo
operator|->
name|Ss
operator|==
literal|0
condition|)
name|entropy
operator|->
name|pub
operator|.
name|decode_mcu
operator|=
name|decode_mcu_DC_first
expr_stmt|;
else|else
name|entropy
operator|->
name|pub
operator|.
name|decode_mcu
operator|=
name|decode_mcu_AC_first
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|cinfo
operator|->
name|Ss
operator|==
literal|0
condition|)
name|entropy
operator|->
name|pub
operator|.
name|decode_mcu
operator|=
name|decode_mcu_DC_refine
expr_stmt|;
else|else
name|entropy
operator|->
name|pub
operator|.
name|decode_mcu
operator|=
name|decode_mcu_AC_refine
expr_stmt|;
block|}
for|for
control|(
name|ci
operator|=
literal|0
init|;
name|ci
operator|<
name|cinfo
operator|->
name|comps_in_scan
condition|;
name|ci
operator|++
control|)
block|{
name|compptr
operator|=
name|cinfo
operator|->
name|cur_comp_info
index|[
name|ci
index|]
expr_stmt|;
comment|/* Make sure requested tables are present, and compute derived tables.        * We may build same derived table more than once, but it's not expensive.        */
if|if
condition|(
name|cinfo
operator|->
name|Ss
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|cinfo
operator|->
name|Ah
operator|==
literal|0
condition|)
block|{
comment|/* DC refinement needs no table */
name|tbl
operator|=
name|compptr
operator|->
name|dc_tbl_no
expr_stmt|;
name|jpeg_make_d_derived_tbl
argument_list|(
name|cinfo
argument_list|,
name|TRUE
argument_list|,
name|tbl
argument_list|,
operator|&
name|entropy
operator|->
name|derived_tbls
index|[
name|tbl
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|tbl
operator|=
name|compptr
operator|->
name|ac_tbl_no
expr_stmt|;
name|jpeg_make_d_derived_tbl
argument_list|(
name|cinfo
argument_list|,
name|FALSE
argument_list|,
name|tbl
argument_list|,
operator|&
name|entropy
operator|->
name|derived_tbls
index|[
name|tbl
index|]
argument_list|)
expr_stmt|;
comment|/* remember the single active table */
name|entropy
operator|->
name|ac_derived_tbl
operator|=
name|entropy
operator|->
name|derived_tbls
index|[
name|tbl
index|]
expr_stmt|;
block|}
comment|/* Initialize DC predictions to 0 */
name|entropy
operator|->
name|saved
operator|.
name|last_dc_val
index|[
name|ci
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Initialize private state variables */
name|entropy
operator|->
name|saved
operator|.
name|EOBRUN
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Check that the scan parameters Ss, Se, Ah/Al are OK for sequential JPEG.      * This ought to be an error condition, but we make it a warning because      * there are some baseline files out there with all zeroes in these bytes.      */
if|if
condition|(
name|cinfo
operator|->
name|Ss
operator|!=
literal|0
operator|||
name|cinfo
operator|->
name|Ah
operator|!=
literal|0
operator|||
name|cinfo
operator|->
name|Al
operator|!=
literal|0
operator|||
operator|(
operator|(
name|cinfo
operator|->
name|is_baseline
operator|||
name|cinfo
operator|->
name|Se
operator|<
name|DCTSIZE2
operator|)
operator|&&
name|cinfo
operator|->
name|Se
operator|!=
name|cinfo
operator|->
name|lim_Se
operator|)
condition|)
name|WARNMS
argument_list|(
name|cinfo
argument_list|,
name|JWRN_NOT_SEQUENTIAL
argument_list|)
expr_stmt|;
comment|/* Select MCU decoding routine */
comment|/* We retain the hard-coded case for full-size blocks.      * This is not necessary, but it appears that this version is slightly      * more performant in the given implementation.      * With an improved implementation we would prefer a single optimized      * function.      */
if|if
condition|(
name|cinfo
operator|->
name|lim_Se
operator|!=
name|DCTSIZE2
operator|-
literal|1
condition|)
name|entropy
operator|->
name|pub
operator|.
name|decode_mcu
operator|=
name|decode_mcu_sub
expr_stmt|;
else|else
name|entropy
operator|->
name|pub
operator|.
name|decode_mcu
operator|=
name|decode_mcu
expr_stmt|;
for|for
control|(
name|ci
operator|=
literal|0
init|;
name|ci
operator|<
name|cinfo
operator|->
name|comps_in_scan
condition|;
name|ci
operator|++
control|)
block|{
name|compptr
operator|=
name|cinfo
operator|->
name|cur_comp_info
index|[
name|ci
index|]
expr_stmt|;
comment|/* Compute derived values for Huffman tables */
comment|/* We may do this more than once for a table, but it's not expensive */
name|tbl
operator|=
name|compptr
operator|->
name|dc_tbl_no
expr_stmt|;
name|jpeg_make_d_derived_tbl
argument_list|(
name|cinfo
argument_list|,
name|TRUE
argument_list|,
name|tbl
argument_list|,
operator|&
name|entropy
operator|->
name|dc_derived_tbls
index|[
name|tbl
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|cinfo
operator|->
name|lim_Se
condition|)
block|{
comment|/* AC needs no table when not present */
name|tbl
operator|=
name|compptr
operator|->
name|ac_tbl_no
expr_stmt|;
name|jpeg_make_d_derived_tbl
argument_list|(
name|cinfo
argument_list|,
name|FALSE
argument_list|,
name|tbl
argument_list|,
operator|&
name|entropy
operator|->
name|ac_derived_tbls
index|[
name|tbl
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize DC predictions to 0 */
name|entropy
operator|->
name|saved
operator|.
name|last_dc_val
index|[
name|ci
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Precalculate decoding info for each block in an MCU of this scan */
for|for
control|(
name|blkn
operator|=
literal|0
init|;
name|blkn
operator|<
name|cinfo
operator|->
name|blocks_in_MCU
condition|;
name|blkn
operator|++
control|)
block|{
name|ci
operator|=
name|cinfo
operator|->
name|MCU_membership
index|[
name|blkn
index|]
expr_stmt|;
name|compptr
operator|=
name|cinfo
operator|->
name|cur_comp_info
index|[
name|ci
index|]
expr_stmt|;
comment|/* Precalculate which table to use for each block */
name|entropy
operator|->
name|dc_cur_tbls
index|[
name|blkn
index|]
operator|=
name|entropy
operator|->
name|dc_derived_tbls
index|[
name|compptr
operator|->
name|dc_tbl_no
index|]
expr_stmt|;
name|entropy
operator|->
name|ac_cur_tbls
index|[
name|blkn
index|]
operator|=
name|entropy
operator|->
name|ac_derived_tbls
index|[
name|compptr
operator|->
name|ac_tbl_no
index|]
expr_stmt|;
comment|/* Decide whether we really care about the coefficient values */
if|if
condition|(
name|compptr
operator|->
name|component_needed
condition|)
block|{
name|ci
operator|=
name|compptr
operator|->
name|DCT_v_scaled_size
expr_stmt|;
name|i
operator|=
name|compptr
operator|->
name|DCT_h_scaled_size
expr_stmt|;
switch|switch
condition|(
name|cinfo
operator|->
name|lim_Se
condition|)
block|{
case|case
operator|(
literal|1
operator|*
literal|1
operator|-
literal|1
operator|)
case|:
name|entropy
operator|->
name|coef_limit
index|[
name|blkn
index|]
operator|=
literal|1
expr_stmt|;
break|break;
case|case
operator|(
literal|2
operator|*
literal|2
operator|-
literal|1
operator|)
case|:
if|if
condition|(
name|ci
operator|<=
literal|0
operator|||
name|ci
operator|>
literal|2
condition|)
name|ci
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
operator|||
name|i
operator|>
literal|2
condition|)
name|i
operator|=
literal|2
expr_stmt|;
name|entropy
operator|->
name|coef_limit
index|[
name|blkn
index|]
operator|=
literal|1
operator|+
name|jpeg_zigzag_order2
index|[
name|ci
operator|-
literal|1
index|]
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
break|break;
case|case
operator|(
literal|3
operator|*
literal|3
operator|-
literal|1
operator|)
case|:
if|if
condition|(
name|ci
operator|<=
literal|0
operator|||
name|ci
operator|>
literal|3
condition|)
name|ci
operator|=
literal|3
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
operator|||
name|i
operator|>
literal|3
condition|)
name|i
operator|=
literal|3
expr_stmt|;
name|entropy
operator|->
name|coef_limit
index|[
name|blkn
index|]
operator|=
literal|1
operator|+
name|jpeg_zigzag_order3
index|[
name|ci
operator|-
literal|1
index|]
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
break|break;
case|case
operator|(
literal|4
operator|*
literal|4
operator|-
literal|1
operator|)
case|:
if|if
condition|(
name|ci
operator|<=
literal|0
operator|||
name|ci
operator|>
literal|4
condition|)
name|ci
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
operator|||
name|i
operator|>
literal|4
condition|)
name|i
operator|=
literal|4
expr_stmt|;
name|entropy
operator|->
name|coef_limit
index|[
name|blkn
index|]
operator|=
literal|1
operator|+
name|jpeg_zigzag_order4
index|[
name|ci
operator|-
literal|1
index|]
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
break|break;
case|case
operator|(
literal|5
operator|*
literal|5
operator|-
literal|1
operator|)
case|:
if|if
condition|(
name|ci
operator|<=
literal|0
operator|||
name|ci
operator|>
literal|5
condition|)
name|ci
operator|=
literal|5
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
operator|||
name|i
operator|>
literal|5
condition|)
name|i
operator|=
literal|5
expr_stmt|;
name|entropy
operator|->
name|coef_limit
index|[
name|blkn
index|]
operator|=
literal|1
operator|+
name|jpeg_zigzag_order5
index|[
name|ci
operator|-
literal|1
index|]
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
break|break;
case|case
operator|(
literal|6
operator|*
literal|6
operator|-
literal|1
operator|)
case|:
if|if
condition|(
name|ci
operator|<=
literal|0
operator|||
name|ci
operator|>
literal|6
condition|)
name|ci
operator|=
literal|6
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
operator|||
name|i
operator|>
literal|6
condition|)
name|i
operator|=
literal|6
expr_stmt|;
name|entropy
operator|->
name|coef_limit
index|[
name|blkn
index|]
operator|=
literal|1
operator|+
name|jpeg_zigzag_order6
index|[
name|ci
operator|-
literal|1
index|]
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
break|break;
case|case
operator|(
literal|7
operator|*
literal|7
operator|-
literal|1
operator|)
case|:
if|if
condition|(
name|ci
operator|<=
literal|0
operator|||
name|ci
operator|>
literal|7
condition|)
name|ci
operator|=
literal|7
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
operator|||
name|i
operator|>
literal|7
condition|)
name|i
operator|=
literal|7
expr_stmt|;
name|entropy
operator|->
name|coef_limit
index|[
name|blkn
index|]
operator|=
literal|1
operator|+
name|jpeg_zigzag_order7
index|[
name|ci
operator|-
literal|1
index|]
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|ci
operator|<=
literal|0
operator|||
name|ci
operator|>
literal|8
condition|)
name|ci
operator|=
literal|8
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
operator|||
name|i
operator|>
literal|8
condition|)
name|i
operator|=
literal|8
expr_stmt|;
name|entropy
operator|->
name|coef_limit
index|[
name|blkn
index|]
operator|=
literal|1
operator|+
name|jpeg_zigzag_order
index|[
name|ci
operator|-
literal|1
index|]
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|entropy
operator|->
name|coef_limit
index|[
name|blkn
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
comment|/* Initialize bitread state variables */
name|entropy
operator|->
name|bitstate
operator|.
name|bits_left
operator|=
literal|0
expr_stmt|;
name|entropy
operator|->
name|bitstate
operator|.
name|get_buffer
operator|=
literal|0
expr_stmt|;
comment|/* unnecessary, but keeps Purify quiet */
name|entropy
operator|->
name|insufficient_data
operator|=
name|FALSE
expr_stmt|;
comment|/* Initialize restart counter */
name|entropy
operator|->
name|restarts_to_go
operator|=
name|cinfo
operator|->
name|restart_interval
expr_stmt|;
block|}
end_block
begin_comment
comment|/*  * Module initialization routine for Huffman entropy decoding.  */
end_comment
begin_macro
name|GLOBAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|jinit_huff_decoder
name|jinit_huff_decoder
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|)
end_macro
begin_block
block|{
name|huff_entropy_ptr
name|entropy
decl_stmt|;
name|int
name|i
decl_stmt|;
name|entropy
operator|=
call|(
name|huff_entropy_ptr
call|)
argument_list|(
operator|*
name|cinfo
operator|->
name|mem
operator|->
name|alloc_small
argument_list|)
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|,
name|JPOOL_IMAGE
argument_list|,
name|SIZEOF
argument_list|(
name|huff_entropy_decoder
argument_list|)
argument_list|)
expr_stmt|;
name|cinfo
operator|->
name|entropy
operator|=
operator|(
expr|struct
name|jpeg_entropy_decoder
operator|*
operator|)
name|entropy
expr_stmt|;
name|entropy
operator|->
name|pub
operator|.
name|start_pass
operator|=
name|start_pass_huff_decoder
expr_stmt|;
if|if
condition|(
name|cinfo
operator|->
name|progressive_mode
condition|)
block|{
comment|/* Create progression status table */
name|int
modifier|*
name|coef_bit_ptr
decl_stmt|,
name|ci
decl_stmt|;
name|cinfo
operator|->
name|coef_bits
operator|=
operator|(
name|int
argument_list|(
operator|*
argument_list|)
index|[
name|DCTSIZE2
index|]
operator|)
call|(
modifier|*
name|cinfo
operator|->
name|mem
operator|->
name|alloc_small
call|)
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|,
name|JPOOL_IMAGE
argument_list|,
name|cinfo
operator|->
name|num_components
operator|*
name|DCTSIZE2
operator|*
name|SIZEOF
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|coef_bit_ptr
operator|=
operator|&
name|cinfo
operator|->
name|coef_bits
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|ci
operator|=
literal|0
init|;
name|ci
operator|<
name|cinfo
operator|->
name|num_components
condition|;
name|ci
operator|++
control|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DCTSIZE2
condition|;
name|i
operator|++
control|)
operator|*
name|coef_bit_ptr
operator|++
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Mark derived tables unallocated */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_HUFF_TBLS
condition|;
name|i
operator|++
control|)
block|{
name|entropy
operator|->
name|derived_tbls
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Mark tables unallocated */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_HUFF_TBLS
condition|;
name|i
operator|++
control|)
block|{
name|entropy
operator|->
name|dc_derived_tbls
index|[
name|i
index|]
operator|=
name|entropy
operator|->
name|ac_derived_tbls
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
end_block
end_unit
