begin_unit
begin_comment
comment|/*  * jquant2.c  *  * Copyright (C) 1991-1996, Thomas G. Lane.  * This file is part of the Independent JPEG Group's software.  * For conditions of distribution and use, see the accompanying README file.  *  * This file contains 2-pass color quantization (color mapping) routines.  * These routines provide selection of a custom color map for an image,  * followed by mapping of the image to that color map, with optional  * Floyd-Steinberg dithering.  * It is also possible to use just the second pass to map to an arbitrary  * externally-given color map.  *  * Note: ordered dithering is not supported, since there isn't any fast  * way to compute intercolor distances; it's unclear that ordered dither's  * fundamental assumptions even hold with an irregularly spaced color map.  */
end_comment
begin_define
DECL|macro|JPEG_INTERNALS
define|#
directive|define
name|JPEG_INTERNALS
end_define
begin_include
include|#
directive|include
file|"jinclude.h"
end_include
begin_include
include|#
directive|include
file|"jpeglib.h"
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|QUANT_2PASS_SUPPORTED
end_ifdef
begin_comment
comment|/*  * This module implements the well-known Heckbert paradigm for color  * quantization.  Most of the ideas used here can be traced back to  * Heckbert's seminal paper  *   Heckbert, Paul.  "Color Image Quantization for Frame Buffer Display",  *   Proc. SIGGRAPH '82, Computer Graphics v.16 #3 (July 1982), pp 297-304.  *  * In the first pass over the image, we accumulate a histogram showing the  * usage count of each possible color.  To keep the histogram to a reasonable  * size, we reduce the precision of the input; typical practice is to retain  * 5 or 6 bits per color, so that 8 or 4 different input values are counted  * in the same histogram cell.  *  * Next, the color-selection step begins with a box representing the whole  * color space, and repeatedly splits the "largest" remaining box until we  * have as many boxes as desired colors.  Then the mean color in each  * remaining box becomes one of the possible output colors.  *   * The second pass over the image maps each input pixel to the closest output  * color (optionally after applying a Floyd-Steinberg dithering correction).  * This mapping is logically trivial, but making it go fast enough requires  * considerable care.  *  * Heckbert-style quantizers vary a good deal in their policies for choosing  * the "largest" box and deciding where to cut it.  The particular policies  * used here have proved out well in experimental comparisons, but better ones  * may yet be found.  *  * In earlier versions of the IJG code, this module quantized in YCbCr color  * space, processing the raw upsampled data without a color conversion step.  * This allowed the color conversion math to be done only once per colormap  * entry, not once per pixel.  However, that optimization precluded other  * useful optimizations (such as merging color conversion with upsampling)  * and it also interfered with desired capabilities such as quantizing to an  * externally-supplied colormap.  We have therefore abandoned that approach.  * The present code works in the post-conversion color space, typically RGB.  *  * To improve the visual quality of the results, we actually work in scaled  * RGB space, giving G distances more weight than R, and R in turn more than  * B.  To do everything in integer math, we must use integer scale factors.  * The 2/3/1 scale factors used here correspond loosely to the relative  * weights of the colors in the NTSC grayscale equation.  * If you want to use this code to quantize a non-RGB color space, you'll  * probably need to change these scale factors.  */
end_comment
begin_define
DECL|macro|R_SCALE
define|#
directive|define
name|R_SCALE
value|2
end_define
begin_comment
DECL|macro|R_SCALE
comment|/* scale R distances by this much */
end_comment
begin_define
DECL|macro|G_SCALE
define|#
directive|define
name|G_SCALE
value|3
end_define
begin_comment
DECL|macro|G_SCALE
comment|/* scale G distances by this much */
end_comment
begin_define
DECL|macro|B_SCALE
define|#
directive|define
name|B_SCALE
value|1
end_define
begin_comment
DECL|macro|B_SCALE
comment|/* and B by this much */
end_comment
begin_comment
comment|/* Relabel R/G/B as components 0/1/2, respecting the RGB ordering defined  * in jmorecfg.h.  As the code stands, it will do the right thing for R,G,B  * and B,G,R orders.  If you define some other weird order in jmorecfg.h,  * you'll get compile errors until you extend this logic.  In that case  * you'll probably want to tweak the histogram sizes too.  */
end_comment
begin_if
if|#
directive|if
name|RGB_RED
operator|==
literal|0
end_if
begin_define
DECL|macro|C0_SCALE
define|#
directive|define
name|C0_SCALE
value|R_SCALE
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|RGB_BLUE
operator|==
literal|0
end_if
begin_define
DECL|macro|C0_SCALE
define|#
directive|define
name|C0_SCALE
value|B_SCALE
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|RGB_GREEN
operator|==
literal|1
end_if
begin_define
DECL|macro|C1_SCALE
define|#
directive|define
name|C1_SCALE
value|G_SCALE
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|RGB_RED
operator|==
literal|2
end_if
begin_define
DECL|macro|C2_SCALE
define|#
directive|define
name|C2_SCALE
value|R_SCALE
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|RGB_BLUE
operator|==
literal|2
end_if
begin_define
DECL|macro|C2_SCALE
define|#
directive|define
name|C2_SCALE
value|B_SCALE
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*  * First we have the histogram data structure and routines for creating it.  *  * The number of bits of precision can be adjusted by changing these symbols.  * We recommend keeping 6 bits for G and 5 each for R and B.  * If you have plenty of memory and cycles, 6 bits all around gives marginally  * better results; if you are short of memory, 5 bits all around will save  * some space but degrade the results.  * To maintain a fully accurate histogram, we'd need to allocate a "long"  * (preferably unsigned long) for each cell.  In practice this is overkill;  * we can get by with 16 bits per cell.  Few of the cell counts will overflow,  * and clamping those that do overflow to the maximum value will give close-  * enough results.  This reduces the recommended histogram size from 256Kb  * to 128Kb, which is a useful savings on PC-class machines.  * (In the second pass the histogram space is re-used for pixel mapping data;  * in that capacity, each cell must be able to store zero to the number of  * desired colors.  16 bits/cell is plenty for that too.)  * Since the JPEG code is intended to run in small memory model on 80x86  * machines, we can't just allocate the histogram in one chunk.  Instead  * of a true 3-D array, we use a row of pointers to 2-D arrays.  Each  * pointer corresponds to a C0 value (typically 2^5 = 32 pointers) and  * each 2-D array has 2^6*2^5 = 2048 or 2^6*2^6 = 4096 entries.  Note that  * on 80x86 machines, the pointer row is in near memory but the actual  * arrays are in far memory (same arrangement as we use for image arrays).  */
end_comment
begin_define
DECL|macro|MAXNUMCOLORS
define|#
directive|define
name|MAXNUMCOLORS
value|(MAXJSAMPLE+1)
end_define
begin_comment
DECL|macro|MAXNUMCOLORS
comment|/* maximum size of colormap */
end_comment
begin_comment
comment|/* These will do the right thing for either R,G,B or B,G,R color order,  * but you may not like the results for other color orders.  */
end_comment
begin_define
DECL|macro|HIST_C0_BITS
define|#
directive|define
name|HIST_C0_BITS
value|5
end_define
begin_comment
DECL|macro|HIST_C0_BITS
comment|/* bits of precision in R/B histogram */
end_comment
begin_define
DECL|macro|HIST_C1_BITS
define|#
directive|define
name|HIST_C1_BITS
value|6
end_define
begin_comment
DECL|macro|HIST_C1_BITS
comment|/* bits of precision in G histogram */
end_comment
begin_define
DECL|macro|HIST_C2_BITS
define|#
directive|define
name|HIST_C2_BITS
value|5
end_define
begin_comment
DECL|macro|HIST_C2_BITS
comment|/* bits of precision in B/R histogram */
end_comment
begin_comment
comment|/* Number of elements along histogram axes. */
end_comment
begin_define
DECL|macro|HIST_C0_ELEMS
define|#
directive|define
name|HIST_C0_ELEMS
value|(1<<HIST_C0_BITS)
end_define
begin_define
DECL|macro|HIST_C1_ELEMS
define|#
directive|define
name|HIST_C1_ELEMS
value|(1<<HIST_C1_BITS)
end_define
begin_define
DECL|macro|HIST_C2_ELEMS
define|#
directive|define
name|HIST_C2_ELEMS
value|(1<<HIST_C2_BITS)
end_define
begin_comment
comment|/* These are the amounts to shift an input value to get a histogram index. */
end_comment
begin_define
DECL|macro|C0_SHIFT
define|#
directive|define
name|C0_SHIFT
value|(BITS_IN_JSAMPLE-HIST_C0_BITS)
end_define
begin_define
DECL|macro|C1_SHIFT
define|#
directive|define
name|C1_SHIFT
value|(BITS_IN_JSAMPLE-HIST_C1_BITS)
end_define
begin_define
DECL|macro|C2_SHIFT
define|#
directive|define
name|C2_SHIFT
value|(BITS_IN_JSAMPLE-HIST_C2_BITS)
end_define
begin_typedef
DECL|typedef|histcell
typedef|typedef
name|UINT16
name|histcell
typedef|;
end_typedef
begin_comment
DECL|typedef|histcell
comment|/* histogram cell; prefer an unsigned type */
end_comment
begin_typedef
DECL|typedef|histptr
typedef|typedef
name|histcell
name|FAR
modifier|*
name|histptr
typedef|;
end_typedef
begin_comment
DECL|typedef|histptr
comment|/* for pointers to histogram cells */
end_comment
begin_typedef
DECL|typedef|hist1d
typedef|typedef
name|histcell
name|hist1d
index|[
name|HIST_C2_ELEMS
index|]
typedef|;
end_typedef
begin_comment
DECL|typedef|hist1d
comment|/* typedefs for the array */
end_comment
begin_typedef
DECL|typedef|hist2d
typedef|typedef
name|hist1d
name|FAR
modifier|*
name|hist2d
typedef|;
end_typedef
begin_comment
DECL|typedef|hist2d
comment|/* type for the 2nd-level pointers */
end_comment
begin_typedef
DECL|typedef|hist3d
typedef|typedef
name|hist2d
modifier|*
name|hist3d
typedef|;
end_typedef
begin_comment
DECL|typedef|hist3d
comment|/* type for top-level pointer */
end_comment
begin_comment
comment|/* Declarations for Floyd-Steinberg dithering.  *  * Errors are accumulated into the array fserrors[], at a resolution of  * 1/16th of a pixel count.  The error at a given pixel is propagated  * to its not-yet-processed neighbors using the standard F-S fractions,  *		...	(here)	7/16  *		3/16	5/16	1/16  * We work left-to-right on even rows, right-to-left on odd rows.  *  * We can get away with a single array (holding one row's worth of errors)  * by using it to store the current row's errors at pixel columns not yet  * processed, but the next row's errors at columns already processed.  We  * need only a few extra variables to hold the errors immediately around the  * current column.  (If we are lucky, those variables are in registers, but  * even if not, they're probably cheaper to access than array elements are.)  *  * The fserrors[] array has (#columns + 2) entries; the extra entry at  * each end saves us from special-casing the first and last pixels.  * Each entry is three values long, one value for each color component.  *  * Note: on a wide image, we might not have enough room in a PC's near data  * segment to hold the error array; so it is allocated with alloc_large.  */
end_comment
begin_if
if|#
directive|if
name|BITS_IN_JSAMPLE
operator|==
literal|8
end_if
begin_typedef
DECL|typedef|FSERROR
typedef|typedef
name|INT16
name|FSERROR
typedef|;
end_typedef
begin_comment
DECL|typedef|FSERROR
comment|/* 16 bits should be enough */
end_comment
begin_typedef
DECL|typedef|LOCFSERROR
typedef|typedef
name|int
name|LOCFSERROR
typedef|;
end_typedef
begin_comment
DECL|typedef|LOCFSERROR
comment|/* use 'int' for calculation temps */
end_comment
begin_else
else|#
directive|else
end_else
begin_typedef
DECL|typedef|FSERROR
typedef|typedef
name|INT32
name|FSERROR
typedef|;
end_typedef
begin_comment
DECL|typedef|FSERROR
comment|/* may need more than 16 bits */
end_comment
begin_typedef
DECL|typedef|LOCFSERROR
typedef|typedef
name|INT32
name|LOCFSERROR
typedef|;
end_typedef
begin_comment
DECL|typedef|LOCFSERROR
comment|/* be sure calculation temps are big enough */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_typedef
DECL|typedef|FSERRPTR
typedef|typedef
name|FSERROR
name|FAR
modifier|*
name|FSERRPTR
typedef|;
end_typedef
begin_comment
DECL|typedef|FSERRPTR
comment|/* pointer to error array (in FAR storage!) */
end_comment
begin_comment
comment|/* Private subobject */
end_comment
begin_typedef
typedef|typedef
struct|struct
block|{
DECL|member|pub
name|struct
name|jpeg_color_quantizer
name|pub
decl_stmt|;
comment|/* public fields */
comment|/* Space for the eventually created colormap is stashed here */
DECL|member|sv_colormap
name|JSAMPARRAY
name|sv_colormap
decl_stmt|;
comment|/* colormap allocated at init time */
DECL|member|desired
name|int
name|desired
decl_stmt|;
comment|/* desired # of colors = size of colormap */
comment|/* Variables for accumulating image statistics */
DECL|member|histogram
name|hist3d
name|histogram
decl_stmt|;
comment|/* pointer to the histogram */
DECL|member|needs_zeroed
name|boolean
name|needs_zeroed
decl_stmt|;
comment|/* TRUE if next pass must zero histogram */
comment|/* Variables for Floyd-Steinberg dithering */
DECL|member|fserrors
name|FSERRPTR
name|fserrors
decl_stmt|;
comment|/* accumulated errors */
DECL|member|on_odd_row
name|boolean
name|on_odd_row
decl_stmt|;
comment|/* flag to remember which row we are on */
DECL|member|error_limiter
name|int
modifier|*
name|error_limiter
decl_stmt|;
comment|/* table for clamping the applied error */
block|}
DECL|typedef|my_cquantizer
name|my_cquantizer
typedef|;
end_typedef
begin_typedef
DECL|typedef|my_cquantize_ptr
typedef|typedef
name|my_cquantizer
modifier|*
name|my_cquantize_ptr
typedef|;
end_typedef
begin_comment
comment|/*  * Prescan some rows of pixels.  * In this module the prescan simply updates the histogram, which has been  * initialized to zeroes by start_pass.  * An output_buf parameter is required by the method signature, but no data  * is actually output (in fact the buffer controller is probably passing a  * NULL pointer).  */
end_comment
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|prescan_quantize
name|prescan_quantize
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|,
argument|JSAMPARRAY input_buf
argument_list|,
argument|JSAMPARRAY output_buf
argument_list|,
argument|int num_rows
argument_list|)
end_macro
begin_block
block|{
name|my_cquantize_ptr
name|cquantize
init|=
operator|(
name|my_cquantize_ptr
operator|)
name|cinfo
operator|->
name|cquantize
decl_stmt|;
specifier|register
name|JSAMPROW
name|ptr
decl_stmt|;
specifier|register
name|histptr
name|histp
decl_stmt|;
specifier|register
name|hist3d
name|histogram
init|=
name|cquantize
operator|->
name|histogram
decl_stmt|;
name|int
name|row
decl_stmt|;
name|JDIMENSION
name|col
decl_stmt|;
name|JDIMENSION
name|width
init|=
name|cinfo
operator|->
name|output_width
decl_stmt|;
for|for
control|(
name|row
operator|=
literal|0
init|;
name|row
operator|<
name|num_rows
condition|;
name|row
operator|++
control|)
block|{
name|ptr
operator|=
name|input_buf
index|[
name|row
index|]
expr_stmt|;
for|for
control|(
name|col
operator|=
name|width
init|;
name|col
operator|>
literal|0
condition|;
name|col
operator|--
control|)
block|{
comment|/* get pixel value and index into the histogram */
name|histp
operator|=
operator|&
name|histogram
index|[
name|GETJSAMPLE
argument_list|(
name|ptr
index|[
literal|0
index|]
argument_list|)
operator|>>
name|C0_SHIFT
index|]
index|[
name|GETJSAMPLE
argument_list|(
name|ptr
index|[
literal|1
index|]
argument_list|)
operator|>>
name|C1_SHIFT
index|]
index|[
name|GETJSAMPLE
argument_list|(
name|ptr
index|[
literal|2
index|]
argument_list|)
operator|>>
name|C2_SHIFT
index|]
expr_stmt|;
comment|/* increment, check for overflow and undo increment if so. */
if|if
condition|(
operator|++
operator|(
operator|*
name|histp
operator|)
operator|<=
literal|0
condition|)
operator|(
operator|*
name|histp
operator|)
operator|--
expr_stmt|;
name|ptr
operator|+=
literal|3
expr_stmt|;
block|}
block|}
block|}
end_block
begin_comment
comment|/*  * Next we have the really interesting routines: selection of a colormap  * given the completed histogram.  * These routines work with a list of "boxes", each representing a rectangular  * subset of the input color space (to histogram precision).  */
end_comment
begin_typedef
typedef|typedef
struct|struct
block|{
comment|/* The bounds of the box (inclusive); expressed as histogram indexes */
DECL|member|c0min
DECL|member|c0max
name|int
name|c0min
decl_stmt|,
name|c0max
decl_stmt|;
DECL|member|c1min
DECL|member|c1max
name|int
name|c1min
decl_stmt|,
name|c1max
decl_stmt|;
DECL|member|c2min
DECL|member|c2max
name|int
name|c2min
decl_stmt|,
name|c2max
decl_stmt|;
comment|/* The volume (actually 2-norm) of the box */
DECL|member|volume
name|INT32
name|volume
decl_stmt|;
comment|/* The number of nonzero histogram cells within this box */
DECL|member|colorcount
name|long
name|colorcount
decl_stmt|;
block|}
DECL|typedef|box
name|box
typedef|;
end_typedef
begin_typedef
DECL|typedef|boxptr
typedef|typedef
name|box
modifier|*
name|boxptr
typedef|;
end_typedef
begin_macro
DECL|function|LOCAL
name|LOCAL
argument_list|(
argument|boxptr
argument_list|)
end_macro
begin_macro
name|find_biggest_color_pop
argument_list|(
argument|boxptr boxlist
argument_list|,
argument|int numboxes
argument_list|)
end_macro
begin_comment
comment|/* Find the splittable box with the largest color population */
end_comment
begin_comment
comment|/* Returns NULL if no splittable boxes remain */
end_comment
begin_block
block|{
specifier|register
name|boxptr
name|boxp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|long
name|maxc
init|=
literal|0
decl_stmt|;
name|boxptr
name|which
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|boxp
operator|=
name|boxlist
init|;
name|i
operator|<
name|numboxes
condition|;
name|i
operator|++
operator|,
name|boxp
operator|++
control|)
block|{
if|if
condition|(
name|boxp
operator|->
name|colorcount
operator|>
name|maxc
operator|&&
name|boxp
operator|->
name|volume
operator|>
literal|0
condition|)
block|{
name|which
operator|=
name|boxp
expr_stmt|;
name|maxc
operator|=
name|boxp
operator|->
name|colorcount
expr_stmt|;
block|}
block|}
return|return
name|which
return|;
block|}
end_block
begin_macro
DECL|function|LOCAL
name|LOCAL
argument_list|(
argument|boxptr
argument_list|)
end_macro
begin_macro
name|find_biggest_volume
argument_list|(
argument|boxptr boxlist
argument_list|,
argument|int numboxes
argument_list|)
end_macro
begin_comment
comment|/* Find the splittable box with the largest (scaled) volume */
end_comment
begin_comment
comment|/* Returns NULL if no splittable boxes remain */
end_comment
begin_block
block|{
specifier|register
name|boxptr
name|boxp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|INT32
name|maxv
init|=
literal|0
decl_stmt|;
name|boxptr
name|which
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|boxp
operator|=
name|boxlist
init|;
name|i
operator|<
name|numboxes
condition|;
name|i
operator|++
operator|,
name|boxp
operator|++
control|)
block|{
if|if
condition|(
name|boxp
operator|->
name|volume
operator|>
name|maxv
condition|)
block|{
name|which
operator|=
name|boxp
expr_stmt|;
name|maxv
operator|=
name|boxp
operator|->
name|volume
expr_stmt|;
block|}
block|}
return|return
name|which
return|;
block|}
end_block
begin_macro
name|LOCAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|update_box
name|update_box
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|,
argument|boxptr boxp
argument_list|)
end_macro
begin_comment
comment|/* Shrink the min/max bounds of a box to enclose only nonzero elements, */
end_comment
begin_comment
comment|/* and recompute its volume and population */
end_comment
begin_block
block|{
name|my_cquantize_ptr
name|cquantize
init|=
operator|(
name|my_cquantize_ptr
operator|)
name|cinfo
operator|->
name|cquantize
decl_stmt|;
name|hist3d
name|histogram
init|=
name|cquantize
operator|->
name|histogram
decl_stmt|;
name|histptr
name|histp
decl_stmt|;
name|int
name|c0
decl_stmt|,
name|c1
decl_stmt|,
name|c2
decl_stmt|;
name|int
name|c0min
decl_stmt|,
name|c0max
decl_stmt|,
name|c1min
decl_stmt|,
name|c1max
decl_stmt|,
name|c2min
decl_stmt|,
name|c2max
decl_stmt|;
name|INT32
name|dist0
decl_stmt|,
name|dist1
decl_stmt|,
name|dist2
decl_stmt|;
name|long
name|ccount
decl_stmt|;
name|c0min
operator|=
name|boxp
operator|->
name|c0min
expr_stmt|;
name|c0max
operator|=
name|boxp
operator|->
name|c0max
expr_stmt|;
name|c1min
operator|=
name|boxp
operator|->
name|c1min
expr_stmt|;
name|c1max
operator|=
name|boxp
operator|->
name|c1max
expr_stmt|;
name|c2min
operator|=
name|boxp
operator|->
name|c2min
expr_stmt|;
name|c2max
operator|=
name|boxp
operator|->
name|c2max
expr_stmt|;
if|if
condition|(
name|c0max
operator|>
name|c0min
condition|)
for|for
control|(
name|c0
operator|=
name|c0min
init|;
name|c0
operator|<=
name|c0max
condition|;
name|c0
operator|++
control|)
for|for
control|(
name|c1
operator|=
name|c1min
init|;
name|c1
operator|<=
name|c1max
condition|;
name|c1
operator|++
control|)
block|{
name|histp
operator|=
operator|&
name|histogram
index|[
name|c0
index|]
index|[
name|c1
index|]
index|[
name|c2min
index|]
expr_stmt|;
for|for
control|(
name|c2
operator|=
name|c2min
init|;
name|c2
operator|<=
name|c2max
condition|;
name|c2
operator|++
control|)
if|if
condition|(
operator|*
name|histp
operator|++
operator|!=
literal|0
condition|)
block|{
name|boxp
operator|->
name|c0min
operator|=
name|c0min
operator|=
name|c0
expr_stmt|;
goto|goto
name|have_c0min
goto|;
block|}
block|}
name|have_c0min
label|:
if|if
condition|(
name|c0max
operator|>
name|c0min
condition|)
for|for
control|(
name|c0
operator|=
name|c0max
init|;
name|c0
operator|>=
name|c0min
condition|;
name|c0
operator|--
control|)
for|for
control|(
name|c1
operator|=
name|c1min
init|;
name|c1
operator|<=
name|c1max
condition|;
name|c1
operator|++
control|)
block|{
name|histp
operator|=
operator|&
name|histogram
index|[
name|c0
index|]
index|[
name|c1
index|]
index|[
name|c2min
index|]
expr_stmt|;
for|for
control|(
name|c2
operator|=
name|c2min
init|;
name|c2
operator|<=
name|c2max
condition|;
name|c2
operator|++
control|)
if|if
condition|(
operator|*
name|histp
operator|++
operator|!=
literal|0
condition|)
block|{
name|boxp
operator|->
name|c0max
operator|=
name|c0max
operator|=
name|c0
expr_stmt|;
goto|goto
name|have_c0max
goto|;
block|}
block|}
name|have_c0max
label|:
if|if
condition|(
name|c1max
operator|>
name|c1min
condition|)
for|for
control|(
name|c1
operator|=
name|c1min
init|;
name|c1
operator|<=
name|c1max
condition|;
name|c1
operator|++
control|)
for|for
control|(
name|c0
operator|=
name|c0min
init|;
name|c0
operator|<=
name|c0max
condition|;
name|c0
operator|++
control|)
block|{
name|histp
operator|=
operator|&
name|histogram
index|[
name|c0
index|]
index|[
name|c1
index|]
index|[
name|c2min
index|]
expr_stmt|;
for|for
control|(
name|c2
operator|=
name|c2min
init|;
name|c2
operator|<=
name|c2max
condition|;
name|c2
operator|++
control|)
if|if
condition|(
operator|*
name|histp
operator|++
operator|!=
literal|0
condition|)
block|{
name|boxp
operator|->
name|c1min
operator|=
name|c1min
operator|=
name|c1
expr_stmt|;
goto|goto
name|have_c1min
goto|;
block|}
block|}
name|have_c1min
label|:
if|if
condition|(
name|c1max
operator|>
name|c1min
condition|)
for|for
control|(
name|c1
operator|=
name|c1max
init|;
name|c1
operator|>=
name|c1min
condition|;
name|c1
operator|--
control|)
for|for
control|(
name|c0
operator|=
name|c0min
init|;
name|c0
operator|<=
name|c0max
condition|;
name|c0
operator|++
control|)
block|{
name|histp
operator|=
operator|&
name|histogram
index|[
name|c0
index|]
index|[
name|c1
index|]
index|[
name|c2min
index|]
expr_stmt|;
for|for
control|(
name|c2
operator|=
name|c2min
init|;
name|c2
operator|<=
name|c2max
condition|;
name|c2
operator|++
control|)
if|if
condition|(
operator|*
name|histp
operator|++
operator|!=
literal|0
condition|)
block|{
name|boxp
operator|->
name|c1max
operator|=
name|c1max
operator|=
name|c1
expr_stmt|;
goto|goto
name|have_c1max
goto|;
block|}
block|}
name|have_c1max
label|:
if|if
condition|(
name|c2max
operator|>
name|c2min
condition|)
for|for
control|(
name|c2
operator|=
name|c2min
init|;
name|c2
operator|<=
name|c2max
condition|;
name|c2
operator|++
control|)
for|for
control|(
name|c0
operator|=
name|c0min
init|;
name|c0
operator|<=
name|c0max
condition|;
name|c0
operator|++
control|)
block|{
name|histp
operator|=
operator|&
name|histogram
index|[
name|c0
index|]
index|[
name|c1min
index|]
index|[
name|c2
index|]
expr_stmt|;
for|for
control|(
name|c1
operator|=
name|c1min
init|;
name|c1
operator|<=
name|c1max
condition|;
name|c1
operator|++
operator|,
name|histp
operator|+=
name|HIST_C2_ELEMS
control|)
if|if
condition|(
operator|*
name|histp
operator|!=
literal|0
condition|)
block|{
name|boxp
operator|->
name|c2min
operator|=
name|c2min
operator|=
name|c2
expr_stmt|;
goto|goto
name|have_c2min
goto|;
block|}
block|}
name|have_c2min
label|:
if|if
condition|(
name|c2max
operator|>
name|c2min
condition|)
for|for
control|(
name|c2
operator|=
name|c2max
init|;
name|c2
operator|>=
name|c2min
condition|;
name|c2
operator|--
control|)
for|for
control|(
name|c0
operator|=
name|c0min
init|;
name|c0
operator|<=
name|c0max
condition|;
name|c0
operator|++
control|)
block|{
name|histp
operator|=
operator|&
name|histogram
index|[
name|c0
index|]
index|[
name|c1min
index|]
index|[
name|c2
index|]
expr_stmt|;
for|for
control|(
name|c1
operator|=
name|c1min
init|;
name|c1
operator|<=
name|c1max
condition|;
name|c1
operator|++
operator|,
name|histp
operator|+=
name|HIST_C2_ELEMS
control|)
if|if
condition|(
operator|*
name|histp
operator|!=
literal|0
condition|)
block|{
name|boxp
operator|->
name|c2max
operator|=
name|c2max
operator|=
name|c2
expr_stmt|;
goto|goto
name|have_c2max
goto|;
block|}
block|}
name|have_c2max
label|:
comment|/* Update box volume.    * We use 2-norm rather than real volume here; this biases the method    * against making long narrow boxes, and it has the side benefit that    * a box is splittable iff norm> 0.    * Since the differences are expressed in histogram-cell units,    * we have to shift back to JSAMPLE units to get consistent distances;    * after which, we scale according to the selected distance scale factors.    */
name|dist0
operator|=
operator|(
operator|(
name|c0max
operator|-
name|c0min
operator|)
operator|<<
name|C0_SHIFT
operator|)
operator|*
name|C0_SCALE
expr_stmt|;
name|dist1
operator|=
operator|(
operator|(
name|c1max
operator|-
name|c1min
operator|)
operator|<<
name|C1_SHIFT
operator|)
operator|*
name|C1_SCALE
expr_stmt|;
name|dist2
operator|=
operator|(
operator|(
name|c2max
operator|-
name|c2min
operator|)
operator|<<
name|C2_SHIFT
operator|)
operator|*
name|C2_SCALE
expr_stmt|;
name|boxp
operator|->
name|volume
operator|=
name|dist0
operator|*
name|dist0
operator|+
name|dist1
operator|*
name|dist1
operator|+
name|dist2
operator|*
name|dist2
expr_stmt|;
comment|/* Now scan remaining volume of box and compute population */
name|ccount
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|c0
operator|=
name|c0min
init|;
name|c0
operator|<=
name|c0max
condition|;
name|c0
operator|++
control|)
for|for
control|(
name|c1
operator|=
name|c1min
init|;
name|c1
operator|<=
name|c1max
condition|;
name|c1
operator|++
control|)
block|{
name|histp
operator|=
operator|&
name|histogram
index|[
name|c0
index|]
index|[
name|c1
index|]
index|[
name|c2min
index|]
expr_stmt|;
for|for
control|(
name|c2
operator|=
name|c2min
init|;
name|c2
operator|<=
name|c2max
condition|;
name|c2
operator|++
operator|,
name|histp
operator|++
control|)
if|if
condition|(
operator|*
name|histp
operator|!=
literal|0
condition|)
block|{
name|ccount
operator|++
expr_stmt|;
block|}
block|}
name|boxp
operator|->
name|colorcount
operator|=
name|ccount
expr_stmt|;
block|}
end_block
begin_macro
name|LOCAL
argument_list|(
argument|int
argument_list|)
end_macro
begin_macro
DECL|function|median_cut
name|median_cut
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|,
argument|boxptr boxlist
argument_list|,
argument|int numboxes
argument_list|,
argument|int desired_colors
argument_list|)
end_macro
begin_comment
comment|/* Repeatedly select and split the largest box until we have enough boxes */
end_comment
begin_block
block|{
name|int
name|n
decl_stmt|,
name|lb
decl_stmt|;
name|int
name|c0
decl_stmt|,
name|c1
decl_stmt|,
name|c2
decl_stmt|,
name|cmax
decl_stmt|;
specifier|register
name|boxptr
name|b1
decl_stmt|,
name|b2
decl_stmt|;
while|while
condition|(
name|numboxes
operator|<
name|desired_colors
condition|)
block|{
comment|/* Select box to split.      * Current algorithm: by population for first half, then by volume.      */
if|if
condition|(
name|numboxes
operator|*
literal|2
operator|<=
name|desired_colors
condition|)
block|{
name|b1
operator|=
name|find_biggest_color_pop
argument_list|(
name|boxlist
argument_list|,
name|numboxes
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|b1
operator|=
name|find_biggest_volume
argument_list|(
name|boxlist
argument_list|,
name|numboxes
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|b1
operator|==
name|NULL
condition|)
comment|/* no splittable boxes left! */
break|break;
name|b2
operator|=
operator|&
name|boxlist
index|[
name|numboxes
index|]
expr_stmt|;
comment|/* where new box will go */
comment|/* Copy the color bounds to the new box. */
name|b2
operator|->
name|c0max
operator|=
name|b1
operator|->
name|c0max
expr_stmt|;
name|b2
operator|->
name|c1max
operator|=
name|b1
operator|->
name|c1max
expr_stmt|;
name|b2
operator|->
name|c2max
operator|=
name|b1
operator|->
name|c2max
expr_stmt|;
name|b2
operator|->
name|c0min
operator|=
name|b1
operator|->
name|c0min
expr_stmt|;
name|b2
operator|->
name|c1min
operator|=
name|b1
operator|->
name|c1min
expr_stmt|;
name|b2
operator|->
name|c2min
operator|=
name|b1
operator|->
name|c2min
expr_stmt|;
comment|/* Choose which axis to split the box on.      * Current algorithm: longest scaled axis.      * See notes in update_box about scaling distances.      */
name|c0
operator|=
operator|(
operator|(
name|b1
operator|->
name|c0max
operator|-
name|b1
operator|->
name|c0min
operator|)
operator|<<
name|C0_SHIFT
operator|)
operator|*
name|C0_SCALE
expr_stmt|;
name|c1
operator|=
operator|(
operator|(
name|b1
operator|->
name|c1max
operator|-
name|b1
operator|->
name|c1min
operator|)
operator|<<
name|C1_SHIFT
operator|)
operator|*
name|C1_SCALE
expr_stmt|;
name|c2
operator|=
operator|(
operator|(
name|b1
operator|->
name|c2max
operator|-
name|b1
operator|->
name|c2min
operator|)
operator|<<
name|C2_SHIFT
operator|)
operator|*
name|C2_SCALE
expr_stmt|;
comment|/* We want to break any ties in favor of green, then red, blue last.      * This code does the right thing for R,G,B or B,G,R color orders only.      */
if|#
directive|if
name|RGB_RED
operator|==
literal|0
name|cmax
operator|=
name|c1
expr_stmt|;
name|n
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|c0
operator|>
name|cmax
condition|)
block|{
name|cmax
operator|=
name|c0
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|c2
operator|>
name|cmax
condition|)
block|{
name|n
operator|=
literal|2
expr_stmt|;
block|}
else|#
directive|else
name|cmax
operator|=
name|c1
expr_stmt|;
name|n
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|c2
operator|>
name|cmax
condition|)
block|{
name|cmax
operator|=
name|c2
expr_stmt|;
name|n
operator|=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|c0
operator|>
name|cmax
condition|)
block|{
name|n
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Choose split point along selected axis, and update box bounds.      * Current algorithm: split at halfway point.      * (Since the box has been shrunk to minimum volume,      * any split will produce two nonempty subboxes.)      * Note that lb value is max for lower box, so must be< old max.      */
switch|switch
condition|(
name|n
condition|)
block|{
case|case
literal|0
case|:
name|lb
operator|=
operator|(
name|b1
operator|->
name|c0max
operator|+
name|b1
operator|->
name|c0min
operator|)
operator|/
literal|2
expr_stmt|;
name|b1
operator|->
name|c0max
operator|=
name|lb
expr_stmt|;
name|b2
operator|->
name|c0min
operator|=
name|lb
operator|+
literal|1
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|lb
operator|=
operator|(
name|b1
operator|->
name|c1max
operator|+
name|b1
operator|->
name|c1min
operator|)
operator|/
literal|2
expr_stmt|;
name|b1
operator|->
name|c1max
operator|=
name|lb
expr_stmt|;
name|b2
operator|->
name|c1min
operator|=
name|lb
operator|+
literal|1
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|lb
operator|=
operator|(
name|b1
operator|->
name|c2max
operator|+
name|b1
operator|->
name|c2min
operator|)
operator|/
literal|2
expr_stmt|;
name|b1
operator|->
name|c2max
operator|=
name|lb
expr_stmt|;
name|b2
operator|->
name|c2min
operator|=
name|lb
operator|+
literal|1
expr_stmt|;
break|break;
block|}
comment|/* Update stats for boxes */
name|update_box
argument_list|(
name|cinfo
argument_list|,
name|b1
argument_list|)
expr_stmt|;
name|update_box
argument_list|(
name|cinfo
argument_list|,
name|b2
argument_list|)
expr_stmt|;
name|numboxes
operator|++
expr_stmt|;
block|}
return|return
name|numboxes
return|;
block|}
end_block
begin_macro
name|LOCAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|compute_color
name|compute_color
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|,
argument|boxptr boxp
argument_list|,
argument|int icolor
argument_list|)
end_macro
begin_comment
comment|/* Compute representative color for a box, put it in colormap[icolor] */
end_comment
begin_block
block|{
comment|/* Current algorithm: mean weighted by pixels (not colors) */
comment|/* Note it is important to get the rounding correct! */
name|my_cquantize_ptr
name|cquantize
init|=
operator|(
name|my_cquantize_ptr
operator|)
name|cinfo
operator|->
name|cquantize
decl_stmt|;
name|hist3d
name|histogram
init|=
name|cquantize
operator|->
name|histogram
decl_stmt|;
name|histptr
name|histp
decl_stmt|;
name|int
name|c0
decl_stmt|,
name|c1
decl_stmt|,
name|c2
decl_stmt|;
name|int
name|c0min
decl_stmt|,
name|c0max
decl_stmt|,
name|c1min
decl_stmt|,
name|c1max
decl_stmt|,
name|c2min
decl_stmt|,
name|c2max
decl_stmt|;
name|long
name|count
decl_stmt|;
name|long
name|total
init|=
literal|0
decl_stmt|;
name|long
name|c0total
init|=
literal|0
decl_stmt|;
name|long
name|c1total
init|=
literal|0
decl_stmt|;
name|long
name|c2total
init|=
literal|0
decl_stmt|;
name|c0min
operator|=
name|boxp
operator|->
name|c0min
expr_stmt|;
name|c0max
operator|=
name|boxp
operator|->
name|c0max
expr_stmt|;
name|c1min
operator|=
name|boxp
operator|->
name|c1min
expr_stmt|;
name|c1max
operator|=
name|boxp
operator|->
name|c1max
expr_stmt|;
name|c2min
operator|=
name|boxp
operator|->
name|c2min
expr_stmt|;
name|c2max
operator|=
name|boxp
operator|->
name|c2max
expr_stmt|;
for|for
control|(
name|c0
operator|=
name|c0min
init|;
name|c0
operator|<=
name|c0max
condition|;
name|c0
operator|++
control|)
for|for
control|(
name|c1
operator|=
name|c1min
init|;
name|c1
operator|<=
name|c1max
condition|;
name|c1
operator|++
control|)
block|{
name|histp
operator|=
operator|&
name|histogram
index|[
name|c0
index|]
index|[
name|c1
index|]
index|[
name|c2min
index|]
expr_stmt|;
for|for
control|(
name|c2
operator|=
name|c2min
init|;
name|c2
operator|<=
name|c2max
condition|;
name|c2
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|count
operator|=
operator|*
name|histp
operator|++
operator|)
operator|!=
literal|0
condition|)
block|{
name|total
operator|+=
name|count
expr_stmt|;
name|c0total
operator|+=
operator|(
operator|(
name|c0
operator|<<
name|C0_SHIFT
operator|)
operator|+
operator|(
operator|(
literal|1
operator|<<
name|C0_SHIFT
operator|)
operator|>>
literal|1
operator|)
operator|)
operator|*
name|count
expr_stmt|;
name|c1total
operator|+=
operator|(
operator|(
name|c1
operator|<<
name|C1_SHIFT
operator|)
operator|+
operator|(
operator|(
literal|1
operator|<<
name|C1_SHIFT
operator|)
operator|>>
literal|1
operator|)
operator|)
operator|*
name|count
expr_stmt|;
name|c2total
operator|+=
operator|(
operator|(
name|c2
operator|<<
name|C2_SHIFT
operator|)
operator|+
operator|(
operator|(
literal|1
operator|<<
name|C2_SHIFT
operator|)
operator|>>
literal|1
operator|)
operator|)
operator|*
name|count
expr_stmt|;
block|}
block|}
block|}
name|cinfo
operator|->
name|colormap
index|[
literal|0
index|]
index|[
name|icolor
index|]
operator|=
call|(
name|JSAMPLE
call|)
argument_list|(
operator|(
name|c0total
operator|+
operator|(
name|total
operator|>>
literal|1
operator|)
operator|)
operator|/
name|total
argument_list|)
expr_stmt|;
name|cinfo
operator|->
name|colormap
index|[
literal|1
index|]
index|[
name|icolor
index|]
operator|=
call|(
name|JSAMPLE
call|)
argument_list|(
operator|(
name|c1total
operator|+
operator|(
name|total
operator|>>
literal|1
operator|)
operator|)
operator|/
name|total
argument_list|)
expr_stmt|;
name|cinfo
operator|->
name|colormap
index|[
literal|2
index|]
index|[
name|icolor
index|]
operator|=
call|(
name|JSAMPLE
call|)
argument_list|(
operator|(
name|c2total
operator|+
operator|(
name|total
operator|>>
literal|1
operator|)
operator|)
operator|/
name|total
argument_list|)
expr_stmt|;
block|}
end_block
begin_macro
name|LOCAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|select_colors
name|select_colors
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|,
argument|int desired_colors
argument_list|)
end_macro
begin_comment
comment|/* Master routine for color selection */
end_comment
begin_block
block|{
name|boxptr
name|boxlist
decl_stmt|;
name|int
name|numboxes
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Allocate workspace for box list */
name|boxlist
operator|=
call|(
name|boxptr
call|)
argument_list|(
operator|*
name|cinfo
operator|->
name|mem
operator|->
name|alloc_small
argument_list|)
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|,
name|JPOOL_IMAGE
argument_list|,
name|desired_colors
operator|*
name|SIZEOF
argument_list|(
name|box
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialize one box containing whole space */
name|numboxes
operator|=
literal|1
expr_stmt|;
name|boxlist
index|[
literal|0
index|]
operator|.
name|c0min
operator|=
literal|0
expr_stmt|;
name|boxlist
index|[
literal|0
index|]
operator|.
name|c0max
operator|=
name|MAXJSAMPLE
operator|>>
name|C0_SHIFT
expr_stmt|;
name|boxlist
index|[
literal|0
index|]
operator|.
name|c1min
operator|=
literal|0
expr_stmt|;
name|boxlist
index|[
literal|0
index|]
operator|.
name|c1max
operator|=
name|MAXJSAMPLE
operator|>>
name|C1_SHIFT
expr_stmt|;
name|boxlist
index|[
literal|0
index|]
operator|.
name|c2min
operator|=
literal|0
expr_stmt|;
name|boxlist
index|[
literal|0
index|]
operator|.
name|c2max
operator|=
name|MAXJSAMPLE
operator|>>
name|C2_SHIFT
expr_stmt|;
comment|/* Shrink it to actually-used volume and set its statistics */
name|update_box
argument_list|(
name|cinfo
argument_list|,
operator|&
name|boxlist
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* Perform median-cut to produce final box list */
name|numboxes
operator|=
name|median_cut
argument_list|(
name|cinfo
argument_list|,
name|boxlist
argument_list|,
name|numboxes
argument_list|,
name|desired_colors
argument_list|)
expr_stmt|;
comment|/* Compute the representative color for each box, fill colormap */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numboxes
condition|;
name|i
operator|++
control|)
name|compute_color
argument_list|(
name|cinfo
argument_list|,
operator|&
name|boxlist
index|[
name|i
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|cinfo
operator|->
name|actual_number_of_colors
operator|=
name|numboxes
expr_stmt|;
name|TRACEMS1
argument_list|(
name|cinfo
argument_list|,
literal|1
argument_list|,
name|JTRC_QUANT_SELECTED
argument_list|,
name|numboxes
argument_list|)
expr_stmt|;
block|}
end_block
begin_comment
comment|/*  * These routines are concerned with the time-critical task of mapping input  * colors to the nearest color in the selected colormap.  *  * We re-use the histogram space as an "inverse color map", essentially a  * cache for the results of nearest-color searches.  All colors within a  * histogram cell will be mapped to the same colormap entry, namely the one  * closest to the cell's center.  This may not be quite the closest entry to  * the actual input color, but it's almost as good.  A zero in the cache  * indicates we haven't found the nearest color for that cell yet; the array  * is cleared to zeroes before starting the mapping pass.  When we find the  * nearest color for a cell, its colormap index plus one is recorded in the  * cache for future use.  The pass2 scanning routines call fill_inverse_cmap  * when they need to use an unfilled entry in the cache.  *  * Our method of efficiently finding nearest colors is based on the "locally  * sorted search" idea described by Heckbert and on the incremental distance  * calculation described by Spencer W. Thomas in chapter III.1 of Graphics  * Gems II (James Arvo, ed.  Academic Press, 1991).  Thomas points out that  * the distances from a given colormap entry to each cell of the histogram can  * be computed quickly using an incremental method: the differences between  * distances to adjacent cells themselves differ by a constant.  This allows a  * fairly fast implementation of the "brute force" approach of computing the  * distance from every colormap entry to every histogram cell.  Unfortunately,  * it needs a work array to hold the best-distance-so-far for each histogram  * cell (because the inner loop has to be over cells, not colormap entries).  * The work array elements have to be INT32s, so the work array would need  * 256Kb at our recommended precision.  This is not feasible in DOS machines.  *  * To get around these problems, we apply Thomas' method to compute the  * nearest colors for only the cells within a small subbox of the histogram.  * The work array need be only as big as the subbox, so the memory usage  * problem is solved.  Furthermore, we need not fill subboxes that are never  * referenced in pass2; many images use only part of the color gamut, so a  * fair amount of work is saved.  An additional advantage of this  * approach is that we can apply Heckbert's locality criterion to quickly  * eliminate colormap entries that are far away from the subbox; typically  * three-fourths of the colormap entries are rejected by Heckbert's criterion,  * and we need not compute their distances to individual cells in the subbox.  * The speed of this approach is heavily influenced by the subbox size: too  * small means too much overhead, too big loses because Heckbert's criterion  * can't eliminate as many colormap entries.  Empirically the best subbox  * size seems to be about 1/512th of the histogram (1/8th in each direction).  *  * Thomas' article also describes a refined method which is asymptotically  * faster than the brute-force method, but it is also far more complex and  * cannot efficiently be applied to small subboxes.  It is therefore not  * useful for programs intended to be portable to DOS machines.  On machines  * with plenty of memory, filling the whole histogram in one shot with Thomas'  * refined method might be faster than the present code --- but then again,  * it might not be any faster, and it's certainly more complicated.  */
end_comment
begin_comment
comment|/* log2(histogram cells in update box) for each axis; this can be adjusted */
end_comment
begin_define
DECL|macro|BOX_C0_LOG
define|#
directive|define
name|BOX_C0_LOG
value|(HIST_C0_BITS-3)
end_define
begin_define
DECL|macro|BOX_C1_LOG
define|#
directive|define
name|BOX_C1_LOG
value|(HIST_C1_BITS-3)
end_define
begin_define
DECL|macro|BOX_C2_LOG
define|#
directive|define
name|BOX_C2_LOG
value|(HIST_C2_BITS-3)
end_define
begin_define
DECL|macro|BOX_C0_ELEMS
define|#
directive|define
name|BOX_C0_ELEMS
value|(1<<BOX_C0_LOG)
end_define
begin_comment
DECL|macro|BOX_C0_ELEMS
comment|/* # of hist cells in update box */
end_comment
begin_define
DECL|macro|BOX_C1_ELEMS
define|#
directive|define
name|BOX_C1_ELEMS
value|(1<<BOX_C1_LOG)
end_define
begin_define
DECL|macro|BOX_C2_ELEMS
define|#
directive|define
name|BOX_C2_ELEMS
value|(1<<BOX_C2_LOG)
end_define
begin_define
DECL|macro|BOX_C0_SHIFT
define|#
directive|define
name|BOX_C0_SHIFT
value|(C0_SHIFT + BOX_C0_LOG)
end_define
begin_define
DECL|macro|BOX_C1_SHIFT
define|#
directive|define
name|BOX_C1_SHIFT
value|(C1_SHIFT + BOX_C1_LOG)
end_define
begin_define
DECL|macro|BOX_C2_SHIFT
define|#
directive|define
name|BOX_C2_SHIFT
value|(C2_SHIFT + BOX_C2_LOG)
end_define
begin_comment
comment|/*  * The next three routines implement inverse colormap filling.  They could  * all be folded into one big routine, but splitting them up this way saves  * some stack space (the mindist[] and bestdist[] arrays need not coexist)  * and may allow some compilers to produce better code by registerizing more  * inner-loop variables.  */
end_comment
begin_macro
name|LOCAL
argument_list|(
argument|int
argument_list|)
end_macro
begin_macro
DECL|function|find_nearby_colors
name|find_nearby_colors
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|,
argument|int minc0
argument_list|,
argument|int minc1
argument_list|,
argument|int minc2
argument_list|,
argument|JSAMPLE colorlist[]
argument_list|)
end_macro
begin_comment
comment|/* Locate the colormap entries close enough to an update box to be candidates  * for the nearest entry to some cell(s) in the update box.  The update box  * is specified by the center coordinates of its first cell.  The number of  * candidate colormap entries is returned, and their colormap indexes are  * placed in colorlist[].  * This routine uses Heckbert's "locally sorted search" criterion to select  * the colors that need further consideration.  */
end_comment
begin_block
block|{
name|int
name|numcolors
init|=
name|cinfo
operator|->
name|actual_number_of_colors
decl_stmt|;
name|int
name|maxc0
decl_stmt|,
name|maxc1
decl_stmt|,
name|maxc2
decl_stmt|;
name|int
name|centerc0
decl_stmt|,
name|centerc1
decl_stmt|,
name|centerc2
decl_stmt|;
name|int
name|i
decl_stmt|,
name|x
decl_stmt|,
name|ncolors
decl_stmt|;
name|INT32
name|minmaxdist
decl_stmt|,
name|min_dist
decl_stmt|,
name|max_dist
decl_stmt|,
name|tdist
decl_stmt|;
name|INT32
name|mindist
index|[
name|MAXNUMCOLORS
index|]
decl_stmt|;
comment|/* min distance to colormap entry i */
comment|/* Compute true coordinates of update box's upper corner and center.    * Actually we compute the coordinates of the center of the upper-corner    * histogram cell, which are the upper bounds of the volume we care about.    * Note that since ">>" rounds down, the "center" values may be closer to    * min than to max; hence comparisons to them must be "<=", not "<".    */
name|maxc0
operator|=
name|minc0
operator|+
operator|(
operator|(
literal|1
operator|<<
name|BOX_C0_SHIFT
operator|)
operator|-
operator|(
literal|1
operator|<<
name|C0_SHIFT
operator|)
operator|)
expr_stmt|;
name|centerc0
operator|=
operator|(
name|minc0
operator|+
name|maxc0
operator|)
operator|>>
literal|1
expr_stmt|;
name|maxc1
operator|=
name|minc1
operator|+
operator|(
operator|(
literal|1
operator|<<
name|BOX_C1_SHIFT
operator|)
operator|-
operator|(
literal|1
operator|<<
name|C1_SHIFT
operator|)
operator|)
expr_stmt|;
name|centerc1
operator|=
operator|(
name|minc1
operator|+
name|maxc1
operator|)
operator|>>
literal|1
expr_stmt|;
name|maxc2
operator|=
name|minc2
operator|+
operator|(
operator|(
literal|1
operator|<<
name|BOX_C2_SHIFT
operator|)
operator|-
operator|(
literal|1
operator|<<
name|C2_SHIFT
operator|)
operator|)
expr_stmt|;
name|centerc2
operator|=
operator|(
name|minc2
operator|+
name|maxc2
operator|)
operator|>>
literal|1
expr_stmt|;
comment|/* For each color in colormap, find:    *  1. its minimum squared-distance to any point in the update box    *     (zero if color is within update box);    *  2. its maximum squared-distance to any point in the update box.    * Both of these can be found by considering only the corners of the box.    * We save the minimum distance for each color in mindist[];    * only the smallest maximum distance is of interest.    */
name|minmaxdist
operator|=
literal|0x7FFFFFFFL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numcolors
condition|;
name|i
operator|++
control|)
block|{
comment|/* We compute the squared-c0-distance term, then add in the other two. */
name|x
operator|=
name|GETJSAMPLE
argument_list|(
name|cinfo
operator|->
name|colormap
index|[
literal|0
index|]
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|<
name|minc0
condition|)
block|{
name|tdist
operator|=
operator|(
name|x
operator|-
name|minc0
operator|)
operator|*
name|C0_SCALE
expr_stmt|;
name|min_dist
operator|=
name|tdist
operator|*
name|tdist
expr_stmt|;
name|tdist
operator|=
operator|(
name|x
operator|-
name|maxc0
operator|)
operator|*
name|C0_SCALE
expr_stmt|;
name|max_dist
operator|=
name|tdist
operator|*
name|tdist
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|>
name|maxc0
condition|)
block|{
name|tdist
operator|=
operator|(
name|x
operator|-
name|maxc0
operator|)
operator|*
name|C0_SCALE
expr_stmt|;
name|min_dist
operator|=
name|tdist
operator|*
name|tdist
expr_stmt|;
name|tdist
operator|=
operator|(
name|x
operator|-
name|minc0
operator|)
operator|*
name|C0_SCALE
expr_stmt|;
name|max_dist
operator|=
name|tdist
operator|*
name|tdist
expr_stmt|;
block|}
else|else
block|{
comment|/* within cell range so no contribution to min_dist */
name|min_dist
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|x
operator|<=
name|centerc0
condition|)
block|{
name|tdist
operator|=
operator|(
name|x
operator|-
name|maxc0
operator|)
operator|*
name|C0_SCALE
expr_stmt|;
name|max_dist
operator|=
name|tdist
operator|*
name|tdist
expr_stmt|;
block|}
else|else
block|{
name|tdist
operator|=
operator|(
name|x
operator|-
name|minc0
operator|)
operator|*
name|C0_SCALE
expr_stmt|;
name|max_dist
operator|=
name|tdist
operator|*
name|tdist
expr_stmt|;
block|}
block|}
name|x
operator|=
name|GETJSAMPLE
argument_list|(
name|cinfo
operator|->
name|colormap
index|[
literal|1
index|]
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|<
name|minc1
condition|)
block|{
name|tdist
operator|=
operator|(
name|x
operator|-
name|minc1
operator|)
operator|*
name|C1_SCALE
expr_stmt|;
name|min_dist
operator|+=
name|tdist
operator|*
name|tdist
expr_stmt|;
name|tdist
operator|=
operator|(
name|x
operator|-
name|maxc1
operator|)
operator|*
name|C1_SCALE
expr_stmt|;
name|max_dist
operator|+=
name|tdist
operator|*
name|tdist
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|>
name|maxc1
condition|)
block|{
name|tdist
operator|=
operator|(
name|x
operator|-
name|maxc1
operator|)
operator|*
name|C1_SCALE
expr_stmt|;
name|min_dist
operator|+=
name|tdist
operator|*
name|tdist
expr_stmt|;
name|tdist
operator|=
operator|(
name|x
operator|-
name|minc1
operator|)
operator|*
name|C1_SCALE
expr_stmt|;
name|max_dist
operator|+=
name|tdist
operator|*
name|tdist
expr_stmt|;
block|}
else|else
block|{
comment|/* within cell range so no contribution to min_dist */
if|if
condition|(
name|x
operator|<=
name|centerc1
condition|)
block|{
name|tdist
operator|=
operator|(
name|x
operator|-
name|maxc1
operator|)
operator|*
name|C1_SCALE
expr_stmt|;
name|max_dist
operator|+=
name|tdist
operator|*
name|tdist
expr_stmt|;
block|}
else|else
block|{
name|tdist
operator|=
operator|(
name|x
operator|-
name|minc1
operator|)
operator|*
name|C1_SCALE
expr_stmt|;
name|max_dist
operator|+=
name|tdist
operator|*
name|tdist
expr_stmt|;
block|}
block|}
name|x
operator|=
name|GETJSAMPLE
argument_list|(
name|cinfo
operator|->
name|colormap
index|[
literal|2
index|]
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|<
name|minc2
condition|)
block|{
name|tdist
operator|=
operator|(
name|x
operator|-
name|minc2
operator|)
operator|*
name|C2_SCALE
expr_stmt|;
name|min_dist
operator|+=
name|tdist
operator|*
name|tdist
expr_stmt|;
name|tdist
operator|=
operator|(
name|x
operator|-
name|maxc2
operator|)
operator|*
name|C2_SCALE
expr_stmt|;
name|max_dist
operator|+=
name|tdist
operator|*
name|tdist
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|>
name|maxc2
condition|)
block|{
name|tdist
operator|=
operator|(
name|x
operator|-
name|maxc2
operator|)
operator|*
name|C2_SCALE
expr_stmt|;
name|min_dist
operator|+=
name|tdist
operator|*
name|tdist
expr_stmt|;
name|tdist
operator|=
operator|(
name|x
operator|-
name|minc2
operator|)
operator|*
name|C2_SCALE
expr_stmt|;
name|max_dist
operator|+=
name|tdist
operator|*
name|tdist
expr_stmt|;
block|}
else|else
block|{
comment|/* within cell range so no contribution to min_dist */
if|if
condition|(
name|x
operator|<=
name|centerc2
condition|)
block|{
name|tdist
operator|=
operator|(
name|x
operator|-
name|maxc2
operator|)
operator|*
name|C2_SCALE
expr_stmt|;
name|max_dist
operator|+=
name|tdist
operator|*
name|tdist
expr_stmt|;
block|}
else|else
block|{
name|tdist
operator|=
operator|(
name|x
operator|-
name|minc2
operator|)
operator|*
name|C2_SCALE
expr_stmt|;
name|max_dist
operator|+=
name|tdist
operator|*
name|tdist
expr_stmt|;
block|}
block|}
name|mindist
index|[
name|i
index|]
operator|=
name|min_dist
expr_stmt|;
comment|/* save away the results */
if|if
condition|(
name|max_dist
operator|<
name|minmaxdist
condition|)
name|minmaxdist
operator|=
name|max_dist
expr_stmt|;
block|}
comment|/* Now we know that no cell in the update box is more than minmaxdist    * away from some colormap entry.  Therefore, only colors that are    * within minmaxdist of some part of the box need be considered.    */
name|ncolors
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numcolors
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mindist
index|[
name|i
index|]
operator|<=
name|minmaxdist
condition|)
name|colorlist
index|[
name|ncolors
operator|++
index|]
operator|=
operator|(
name|JSAMPLE
operator|)
name|i
expr_stmt|;
block|}
return|return
name|ncolors
return|;
block|}
end_block
begin_macro
name|LOCAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|find_best_colors
name|find_best_colors
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|,
argument|int minc0
argument_list|,
argument|int minc1
argument_list|,
argument|int minc2
argument_list|,
argument|int numcolors
argument_list|,
argument|JSAMPLE colorlist[]
argument_list|,
argument|JSAMPLE bestcolor[]
argument_list|)
end_macro
begin_comment
comment|/* Find the closest colormap entry for each cell in the update box,  * given the list of candidate colors prepared by find_nearby_colors.  * Return the indexes of the closest entries in the bestcolor[] array.  * This routine uses Thomas' incremental distance calculation method to  * find the distance from a colormap entry to successive cells in the box.  */
end_comment
begin_block
block|{
name|int
name|ic0
decl_stmt|,
name|ic1
decl_stmt|,
name|ic2
decl_stmt|;
name|int
name|i
decl_stmt|,
name|icolor
decl_stmt|;
specifier|register
name|INT32
modifier|*
name|bptr
decl_stmt|;
comment|/* pointer into bestdist[] array */
name|JSAMPLE
modifier|*
name|cptr
decl_stmt|;
comment|/* pointer into bestcolor[] array */
name|INT32
name|dist0
decl_stmt|,
name|dist1
decl_stmt|;
comment|/* initial distance values */
specifier|register
name|INT32
name|dist2
decl_stmt|;
comment|/* current distance in inner loop */
name|INT32
name|xx0
decl_stmt|,
name|xx1
decl_stmt|;
comment|/* distance increments */
specifier|register
name|INT32
name|xx2
decl_stmt|;
name|INT32
name|inc0
decl_stmt|,
name|inc1
decl_stmt|,
name|inc2
decl_stmt|;
comment|/* initial values for increments */
comment|/* This array holds the distance to the nearest-so-far color for each cell */
name|INT32
name|bestdist
index|[
name|BOX_C0_ELEMS
operator|*
name|BOX_C1_ELEMS
operator|*
name|BOX_C2_ELEMS
index|]
decl_stmt|;
comment|/* Initialize best-distance for each cell of the update box */
name|bptr
operator|=
name|bestdist
expr_stmt|;
for|for
control|(
name|i
operator|=
name|BOX_C0_ELEMS
operator|*
name|BOX_C1_ELEMS
operator|*
name|BOX_C2_ELEMS
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
operator|*
name|bptr
operator|++
operator|=
literal|0x7FFFFFFFL
expr_stmt|;
comment|/* For each color selected by find_nearby_colors,    * compute its distance to the center of each cell in the box.    * If that's less than best-so-far, update best distance and color number.    */
comment|/* Nominal steps between cell centers ("x" in Thomas article) */
DECL|macro|STEP_C0
define|#
directive|define
name|STEP_C0
value|((1<< C0_SHIFT) * C0_SCALE)
DECL|macro|STEP_C1
define|#
directive|define
name|STEP_C1
value|((1<< C1_SHIFT) * C1_SCALE)
DECL|macro|STEP_C2
define|#
directive|define
name|STEP_C2
value|((1<< C2_SHIFT) * C2_SCALE)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numcolors
condition|;
name|i
operator|++
control|)
block|{
name|icolor
operator|=
name|GETJSAMPLE
argument_list|(
name|colorlist
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Compute (square of) distance from minc0/c1/c2 to this color */
name|inc0
operator|=
operator|(
name|minc0
operator|-
name|GETJSAMPLE
argument_list|(
name|cinfo
operator|->
name|colormap
index|[
literal|0
index|]
index|[
name|icolor
index|]
argument_list|)
operator|)
operator|*
name|C0_SCALE
expr_stmt|;
name|dist0
operator|=
name|inc0
operator|*
name|inc0
expr_stmt|;
name|inc1
operator|=
operator|(
name|minc1
operator|-
name|GETJSAMPLE
argument_list|(
name|cinfo
operator|->
name|colormap
index|[
literal|1
index|]
index|[
name|icolor
index|]
argument_list|)
operator|)
operator|*
name|C1_SCALE
expr_stmt|;
name|dist0
operator|+=
name|inc1
operator|*
name|inc1
expr_stmt|;
name|inc2
operator|=
operator|(
name|minc2
operator|-
name|GETJSAMPLE
argument_list|(
name|cinfo
operator|->
name|colormap
index|[
literal|2
index|]
index|[
name|icolor
index|]
argument_list|)
operator|)
operator|*
name|C2_SCALE
expr_stmt|;
name|dist0
operator|+=
name|inc2
operator|*
name|inc2
expr_stmt|;
comment|/* Form the initial difference increments */
name|inc0
operator|=
name|inc0
operator|*
operator|(
literal|2
operator|*
name|STEP_C0
operator|)
operator|+
name|STEP_C0
operator|*
name|STEP_C0
expr_stmt|;
name|inc1
operator|=
name|inc1
operator|*
operator|(
literal|2
operator|*
name|STEP_C1
operator|)
operator|+
name|STEP_C1
operator|*
name|STEP_C1
expr_stmt|;
name|inc2
operator|=
name|inc2
operator|*
operator|(
literal|2
operator|*
name|STEP_C2
operator|)
operator|+
name|STEP_C2
operator|*
name|STEP_C2
expr_stmt|;
comment|/* Now loop over all cells in box, updating distance per Thomas method */
name|bptr
operator|=
name|bestdist
expr_stmt|;
name|cptr
operator|=
name|bestcolor
expr_stmt|;
name|xx0
operator|=
name|inc0
expr_stmt|;
for|for
control|(
name|ic0
operator|=
name|BOX_C0_ELEMS
operator|-
literal|1
init|;
name|ic0
operator|>=
literal|0
condition|;
name|ic0
operator|--
control|)
block|{
name|dist1
operator|=
name|dist0
expr_stmt|;
name|xx1
operator|=
name|inc1
expr_stmt|;
for|for
control|(
name|ic1
operator|=
name|BOX_C1_ELEMS
operator|-
literal|1
init|;
name|ic1
operator|>=
literal|0
condition|;
name|ic1
operator|--
control|)
block|{
name|dist2
operator|=
name|dist1
expr_stmt|;
name|xx2
operator|=
name|inc2
expr_stmt|;
for|for
control|(
name|ic2
operator|=
name|BOX_C2_ELEMS
operator|-
literal|1
init|;
name|ic2
operator|>=
literal|0
condition|;
name|ic2
operator|--
control|)
block|{
if|if
condition|(
name|dist2
operator|<
operator|*
name|bptr
condition|)
block|{
operator|*
name|bptr
operator|=
name|dist2
expr_stmt|;
operator|*
name|cptr
operator|=
operator|(
name|JSAMPLE
operator|)
name|icolor
expr_stmt|;
block|}
name|dist2
operator|+=
name|xx2
expr_stmt|;
name|xx2
operator|+=
literal|2
operator|*
name|STEP_C2
operator|*
name|STEP_C2
expr_stmt|;
name|bptr
operator|++
expr_stmt|;
name|cptr
operator|++
expr_stmt|;
block|}
name|dist1
operator|+=
name|xx1
expr_stmt|;
name|xx1
operator|+=
literal|2
operator|*
name|STEP_C1
operator|*
name|STEP_C1
expr_stmt|;
block|}
name|dist0
operator|+=
name|xx0
expr_stmt|;
name|xx0
operator|+=
literal|2
operator|*
name|STEP_C0
operator|*
name|STEP_C0
expr_stmt|;
block|}
block|}
block|}
end_block
begin_macro
name|LOCAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|fill_inverse_cmap
name|fill_inverse_cmap
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|,
argument|int c0
argument_list|,
argument|int c1
argument_list|,
argument|int c2
argument_list|)
end_macro
begin_comment
comment|/* Fill the inverse-colormap entries in the update box that contains */
end_comment
begin_comment
comment|/* histogram cell c0/c1/c2.  (Only that one cell MUST be filled, but */
end_comment
begin_comment
comment|/* we can fill as many others as we wish.) */
end_comment
begin_block
block|{
name|my_cquantize_ptr
name|cquantize
init|=
operator|(
name|my_cquantize_ptr
operator|)
name|cinfo
operator|->
name|cquantize
decl_stmt|;
name|hist3d
name|histogram
init|=
name|cquantize
operator|->
name|histogram
decl_stmt|;
name|int
name|minc0
decl_stmt|,
name|minc1
decl_stmt|,
name|minc2
decl_stmt|;
comment|/* lower left corner of update box */
name|int
name|ic0
decl_stmt|,
name|ic1
decl_stmt|,
name|ic2
decl_stmt|;
specifier|register
name|JSAMPLE
modifier|*
name|cptr
decl_stmt|;
comment|/* pointer into bestcolor[] array */
specifier|register
name|histptr
name|cachep
decl_stmt|;
comment|/* pointer into main cache array */
comment|/* This array lists the candidate colormap indexes. */
name|JSAMPLE
name|colorlist
index|[
name|MAXNUMCOLORS
index|]
decl_stmt|;
name|int
name|numcolors
decl_stmt|;
comment|/* number of candidate colors */
comment|/* This array holds the actually closest colormap index for each cell. */
name|JSAMPLE
name|bestcolor
index|[
name|BOX_C0_ELEMS
operator|*
name|BOX_C1_ELEMS
operator|*
name|BOX_C2_ELEMS
index|]
decl_stmt|;
comment|/* Convert cell coordinates to update box ID */
name|c0
operator|>>=
name|BOX_C0_LOG
expr_stmt|;
name|c1
operator|>>=
name|BOX_C1_LOG
expr_stmt|;
name|c2
operator|>>=
name|BOX_C2_LOG
expr_stmt|;
comment|/* Compute true coordinates of update box's origin corner.    * Actually we compute the coordinates of the center of the corner    * histogram cell, which are the lower bounds of the volume we care about.    */
name|minc0
operator|=
operator|(
name|c0
operator|<<
name|BOX_C0_SHIFT
operator|)
operator|+
operator|(
operator|(
literal|1
operator|<<
name|C0_SHIFT
operator|)
operator|>>
literal|1
operator|)
expr_stmt|;
name|minc1
operator|=
operator|(
name|c1
operator|<<
name|BOX_C1_SHIFT
operator|)
operator|+
operator|(
operator|(
literal|1
operator|<<
name|C1_SHIFT
operator|)
operator|>>
literal|1
operator|)
expr_stmt|;
name|minc2
operator|=
operator|(
name|c2
operator|<<
name|BOX_C2_SHIFT
operator|)
operator|+
operator|(
operator|(
literal|1
operator|<<
name|C2_SHIFT
operator|)
operator|>>
literal|1
operator|)
expr_stmt|;
comment|/* Determine which colormap entries are close enough to be candidates    * for the nearest entry to some cell in the update box.    */
name|numcolors
operator|=
name|find_nearby_colors
argument_list|(
name|cinfo
argument_list|,
name|minc0
argument_list|,
name|minc1
argument_list|,
name|minc2
argument_list|,
name|colorlist
argument_list|)
expr_stmt|;
comment|/* Determine the actually nearest colors. */
name|find_best_colors
argument_list|(
name|cinfo
argument_list|,
name|minc0
argument_list|,
name|minc1
argument_list|,
name|minc2
argument_list|,
name|numcolors
argument_list|,
name|colorlist
argument_list|,
name|bestcolor
argument_list|)
expr_stmt|;
comment|/* Save the best color numbers (plus 1) in the main cache array */
name|c0
operator|<<=
name|BOX_C0_LOG
expr_stmt|;
comment|/* convert ID back to base cell indexes */
name|c1
operator|<<=
name|BOX_C1_LOG
expr_stmt|;
name|c2
operator|<<=
name|BOX_C2_LOG
expr_stmt|;
name|cptr
operator|=
name|bestcolor
expr_stmt|;
for|for
control|(
name|ic0
operator|=
literal|0
init|;
name|ic0
operator|<
name|BOX_C0_ELEMS
condition|;
name|ic0
operator|++
control|)
block|{
for|for
control|(
name|ic1
operator|=
literal|0
init|;
name|ic1
operator|<
name|BOX_C1_ELEMS
condition|;
name|ic1
operator|++
control|)
block|{
name|cachep
operator|=
operator|&
name|histogram
index|[
name|c0
operator|+
name|ic0
index|]
index|[
name|c1
operator|+
name|ic1
index|]
index|[
name|c2
index|]
expr_stmt|;
for|for
control|(
name|ic2
operator|=
literal|0
init|;
name|ic2
operator|<
name|BOX_C2_ELEMS
condition|;
name|ic2
operator|++
control|)
block|{
operator|*
name|cachep
operator|++
operator|=
call|(
name|histcell
call|)
argument_list|(
name|GETJSAMPLE
argument_list|(
operator|*
name|cptr
operator|++
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_block
begin_comment
comment|/*  * Map some rows of pixels to the output colormapped representation.  */
end_comment
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|pass2_no_dither
name|pass2_no_dither
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|,
argument|JSAMPARRAY input_buf
argument_list|,
argument|JSAMPARRAY output_buf
argument_list|,
argument|int num_rows
argument_list|)
end_macro
begin_comment
comment|/* This version performs no dithering */
end_comment
begin_block
block|{
name|my_cquantize_ptr
name|cquantize
init|=
operator|(
name|my_cquantize_ptr
operator|)
name|cinfo
operator|->
name|cquantize
decl_stmt|;
name|hist3d
name|histogram
init|=
name|cquantize
operator|->
name|histogram
decl_stmt|;
specifier|register
name|JSAMPROW
name|inptr
decl_stmt|,
name|outptr
decl_stmt|;
specifier|register
name|histptr
name|cachep
decl_stmt|;
specifier|register
name|int
name|c0
decl_stmt|,
name|c1
decl_stmt|,
name|c2
decl_stmt|;
name|int
name|row
decl_stmt|;
name|JDIMENSION
name|col
decl_stmt|;
name|JDIMENSION
name|width
init|=
name|cinfo
operator|->
name|output_width
decl_stmt|;
for|for
control|(
name|row
operator|=
literal|0
init|;
name|row
operator|<
name|num_rows
condition|;
name|row
operator|++
control|)
block|{
name|inptr
operator|=
name|input_buf
index|[
name|row
index|]
expr_stmt|;
name|outptr
operator|=
name|output_buf
index|[
name|row
index|]
expr_stmt|;
for|for
control|(
name|col
operator|=
name|width
init|;
name|col
operator|>
literal|0
condition|;
name|col
operator|--
control|)
block|{
comment|/* get pixel value and index into the cache */
name|c0
operator|=
name|GETJSAMPLE
argument_list|(
operator|*
name|inptr
operator|++
argument_list|)
operator|>>
name|C0_SHIFT
expr_stmt|;
name|c1
operator|=
name|GETJSAMPLE
argument_list|(
operator|*
name|inptr
operator|++
argument_list|)
operator|>>
name|C1_SHIFT
expr_stmt|;
name|c2
operator|=
name|GETJSAMPLE
argument_list|(
operator|*
name|inptr
operator|++
argument_list|)
operator|>>
name|C2_SHIFT
expr_stmt|;
name|cachep
operator|=
operator|&
name|histogram
index|[
name|c0
index|]
index|[
name|c1
index|]
index|[
name|c2
index|]
expr_stmt|;
comment|/* If we have not seen this color before, find nearest colormap entry */
comment|/* and update the cache */
if|if
condition|(
operator|*
name|cachep
operator|==
literal|0
condition|)
name|fill_inverse_cmap
argument_list|(
name|cinfo
argument_list|,
name|c0
argument_list|,
name|c1
argument_list|,
name|c2
argument_list|)
expr_stmt|;
comment|/* Now emit the colormap index for this cell */
operator|*
name|outptr
operator|++
operator|=
call|(
name|JSAMPLE
call|)
argument_list|(
operator|*
name|cachep
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|pass2_fs_dither
name|pass2_fs_dither
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|,
argument|JSAMPARRAY input_buf
argument_list|,
argument|JSAMPARRAY output_buf
argument_list|,
argument|int num_rows
argument_list|)
end_macro
begin_comment
comment|/* This version performs Floyd-Steinberg dithering */
end_comment
begin_block
block|{
name|my_cquantize_ptr
name|cquantize
init|=
operator|(
name|my_cquantize_ptr
operator|)
name|cinfo
operator|->
name|cquantize
decl_stmt|;
name|hist3d
name|histogram
init|=
name|cquantize
operator|->
name|histogram
decl_stmt|;
specifier|register
name|LOCFSERROR
name|cur0
decl_stmt|,
name|cur1
decl_stmt|,
name|cur2
decl_stmt|;
comment|/* current error or pixel value */
name|LOCFSERROR
name|belowerr0
decl_stmt|,
name|belowerr1
decl_stmt|,
name|belowerr2
decl_stmt|;
comment|/* error for pixel below cur */
name|LOCFSERROR
name|bpreverr0
decl_stmt|,
name|bpreverr1
decl_stmt|,
name|bpreverr2
decl_stmt|;
comment|/* error for below/prev col */
specifier|register
name|FSERRPTR
name|errorptr
decl_stmt|;
comment|/* => fserrors[] at column before current */
name|JSAMPROW
name|inptr
decl_stmt|;
comment|/* => current input pixel */
name|JSAMPROW
name|outptr
decl_stmt|;
comment|/* => current output pixel */
name|histptr
name|cachep
decl_stmt|;
name|int
name|dir
decl_stmt|;
comment|/* +1 or -1 depending on direction */
name|int
name|dir3
decl_stmt|;
comment|/* 3*dir, for advancing inptr& errorptr */
name|int
name|row
decl_stmt|;
name|JDIMENSION
name|col
decl_stmt|;
name|JDIMENSION
name|width
init|=
name|cinfo
operator|->
name|output_width
decl_stmt|;
name|JSAMPLE
modifier|*
name|range_limit
init|=
name|cinfo
operator|->
name|sample_range_limit
decl_stmt|;
name|int
modifier|*
name|error_limit
init|=
name|cquantize
operator|->
name|error_limiter
decl_stmt|;
name|JSAMPROW
name|colormap0
init|=
name|cinfo
operator|->
name|colormap
index|[
literal|0
index|]
decl_stmt|;
name|JSAMPROW
name|colormap1
init|=
name|cinfo
operator|->
name|colormap
index|[
literal|1
index|]
decl_stmt|;
name|JSAMPROW
name|colormap2
init|=
name|cinfo
operator|->
name|colormap
index|[
literal|2
index|]
decl_stmt|;
name|SHIFT_TEMPS
for|for
control|(
name|row
operator|=
literal|0
init|;
name|row
operator|<
name|num_rows
condition|;
name|row
operator|++
control|)
block|{
name|inptr
operator|=
name|input_buf
index|[
name|row
index|]
expr_stmt|;
name|outptr
operator|=
name|output_buf
index|[
name|row
index|]
expr_stmt|;
if|if
condition|(
name|cquantize
operator|->
name|on_odd_row
condition|)
block|{
comment|/* work right to left in this row */
name|inptr
operator|+=
operator|(
name|width
operator|-
literal|1
operator|)
operator|*
literal|3
expr_stmt|;
comment|/* so point to rightmost pixel */
name|outptr
operator|+=
name|width
operator|-
literal|1
expr_stmt|;
name|dir
operator|=
operator|-
literal|1
expr_stmt|;
name|dir3
operator|=
operator|-
literal|3
expr_stmt|;
name|errorptr
operator|=
name|cquantize
operator|->
name|fserrors
operator|+
operator|(
name|width
operator|+
literal|1
operator|)
operator|*
literal|3
expr_stmt|;
comment|/* => entry after last column */
name|cquantize
operator|->
name|on_odd_row
operator|=
name|FALSE
expr_stmt|;
comment|/* flip for next time */
block|}
else|else
block|{
comment|/* work left to right in this row */
name|dir
operator|=
literal|1
expr_stmt|;
name|dir3
operator|=
literal|3
expr_stmt|;
name|errorptr
operator|=
name|cquantize
operator|->
name|fserrors
expr_stmt|;
comment|/* => entry before first real column */
name|cquantize
operator|->
name|on_odd_row
operator|=
name|TRUE
expr_stmt|;
comment|/* flip for next time */
block|}
comment|/* Preset error values: no error propagated to first pixel from left */
name|cur0
operator|=
name|cur1
operator|=
name|cur2
operator|=
literal|0
expr_stmt|;
comment|/* and no error propagated to row below yet */
name|belowerr0
operator|=
name|belowerr1
operator|=
name|belowerr2
operator|=
literal|0
expr_stmt|;
name|bpreverr0
operator|=
name|bpreverr1
operator|=
name|bpreverr2
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|col
operator|=
name|width
init|;
name|col
operator|>
literal|0
condition|;
name|col
operator|--
control|)
block|{
comment|/* curN holds the error propagated from the previous pixel on the        * current line.  Add the error propagated from the previous line        * to form the complete error correction term for this pixel, and        * round the error term (which is expressed * 16) to an integer.        * RIGHT_SHIFT rounds towards minus infinity, so adding 8 is correct        * for either sign of the error value.        * Note: errorptr points to *previous* column's array entry.        */
name|cur0
operator|=
name|RIGHT_SHIFT
argument_list|(
name|cur0
operator|+
name|errorptr
index|[
name|dir3
operator|+
literal|0
index|]
operator|+
literal|8
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|cur1
operator|=
name|RIGHT_SHIFT
argument_list|(
name|cur1
operator|+
name|errorptr
index|[
name|dir3
operator|+
literal|1
index|]
operator|+
literal|8
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|cur2
operator|=
name|RIGHT_SHIFT
argument_list|(
name|cur2
operator|+
name|errorptr
index|[
name|dir3
operator|+
literal|2
index|]
operator|+
literal|8
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Limit the error using transfer function set by init_error_limit.        * See comments with init_error_limit for rationale.        */
name|cur0
operator|=
name|error_limit
index|[
name|cur0
index|]
expr_stmt|;
name|cur1
operator|=
name|error_limit
index|[
name|cur1
index|]
expr_stmt|;
name|cur2
operator|=
name|error_limit
index|[
name|cur2
index|]
expr_stmt|;
comment|/* Form pixel value + error, and range-limit to 0..MAXJSAMPLE.        * The maximum error is +- MAXJSAMPLE (or less with error limiting);        * this sets the required size of the range_limit array.        */
name|cur0
operator|+=
name|GETJSAMPLE
argument_list|(
name|inptr
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|cur1
operator|+=
name|GETJSAMPLE
argument_list|(
name|inptr
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|cur2
operator|+=
name|GETJSAMPLE
argument_list|(
name|inptr
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|cur0
operator|=
name|GETJSAMPLE
argument_list|(
name|range_limit
index|[
name|cur0
index|]
argument_list|)
expr_stmt|;
name|cur1
operator|=
name|GETJSAMPLE
argument_list|(
name|range_limit
index|[
name|cur1
index|]
argument_list|)
expr_stmt|;
name|cur2
operator|=
name|GETJSAMPLE
argument_list|(
name|range_limit
index|[
name|cur2
index|]
argument_list|)
expr_stmt|;
comment|/* Index into the cache with adjusted pixel value */
name|cachep
operator|=
operator|&
name|histogram
index|[
name|cur0
operator|>>
name|C0_SHIFT
index|]
index|[
name|cur1
operator|>>
name|C1_SHIFT
index|]
index|[
name|cur2
operator|>>
name|C2_SHIFT
index|]
expr_stmt|;
comment|/* If we have not seen this color before, find nearest colormap */
comment|/* entry and update the cache */
if|if
condition|(
operator|*
name|cachep
operator|==
literal|0
condition|)
name|fill_inverse_cmap
argument_list|(
name|cinfo
argument_list|,
name|cur0
operator|>>
name|C0_SHIFT
argument_list|,
name|cur1
operator|>>
name|C1_SHIFT
argument_list|,
name|cur2
operator|>>
name|C2_SHIFT
argument_list|)
expr_stmt|;
comment|/* Now emit the colormap index for this cell */
block|{
specifier|register
name|int
name|pixcode
init|=
operator|*
name|cachep
operator|-
literal|1
decl_stmt|;
operator|*
name|outptr
operator|=
operator|(
name|JSAMPLE
operator|)
name|pixcode
expr_stmt|;
comment|/* Compute representation error for this pixel */
name|cur0
operator|-=
name|GETJSAMPLE
argument_list|(
name|colormap0
index|[
name|pixcode
index|]
argument_list|)
expr_stmt|;
name|cur1
operator|-=
name|GETJSAMPLE
argument_list|(
name|colormap1
index|[
name|pixcode
index|]
argument_list|)
expr_stmt|;
name|cur2
operator|-=
name|GETJSAMPLE
argument_list|(
name|colormap2
index|[
name|pixcode
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Compute error fractions to be propagated to adjacent pixels.        * Add these into the running sums, and simultaneously shift the        * next-line error sums left by 1 column.        */
block|{
specifier|register
name|LOCFSERROR
name|bnexterr
decl_stmt|,
name|delta
decl_stmt|;
name|bnexterr
operator|=
name|cur0
expr_stmt|;
comment|/* Process component 0 */
name|delta
operator|=
name|cur0
operator|*
literal|2
expr_stmt|;
name|cur0
operator|+=
name|delta
expr_stmt|;
comment|/* form error * 3 */
name|errorptr
index|[
literal|0
index|]
operator|=
call|(
name|FSERROR
call|)
argument_list|(
name|bpreverr0
operator|+
name|cur0
argument_list|)
expr_stmt|;
name|cur0
operator|+=
name|delta
expr_stmt|;
comment|/* form error * 5 */
name|bpreverr0
operator|=
name|belowerr0
operator|+
name|cur0
expr_stmt|;
name|belowerr0
operator|=
name|bnexterr
expr_stmt|;
name|cur0
operator|+=
name|delta
expr_stmt|;
comment|/* form error * 7 */
name|bnexterr
operator|=
name|cur1
expr_stmt|;
comment|/* Process component 1 */
name|delta
operator|=
name|cur1
operator|*
literal|2
expr_stmt|;
name|cur1
operator|+=
name|delta
expr_stmt|;
comment|/* form error * 3 */
name|errorptr
index|[
literal|1
index|]
operator|=
call|(
name|FSERROR
call|)
argument_list|(
name|bpreverr1
operator|+
name|cur1
argument_list|)
expr_stmt|;
name|cur1
operator|+=
name|delta
expr_stmt|;
comment|/* form error * 5 */
name|bpreverr1
operator|=
name|belowerr1
operator|+
name|cur1
expr_stmt|;
name|belowerr1
operator|=
name|bnexterr
expr_stmt|;
name|cur1
operator|+=
name|delta
expr_stmt|;
comment|/* form error * 7 */
name|bnexterr
operator|=
name|cur2
expr_stmt|;
comment|/* Process component 2 */
name|delta
operator|=
name|cur2
operator|*
literal|2
expr_stmt|;
name|cur2
operator|+=
name|delta
expr_stmt|;
comment|/* form error * 3 */
name|errorptr
index|[
literal|2
index|]
operator|=
call|(
name|FSERROR
call|)
argument_list|(
name|bpreverr2
operator|+
name|cur2
argument_list|)
expr_stmt|;
name|cur2
operator|+=
name|delta
expr_stmt|;
comment|/* form error * 5 */
name|bpreverr2
operator|=
name|belowerr2
operator|+
name|cur2
expr_stmt|;
name|belowerr2
operator|=
name|bnexterr
expr_stmt|;
name|cur2
operator|+=
name|delta
expr_stmt|;
comment|/* form error * 7 */
block|}
comment|/* At this point curN contains the 7/16 error value to be propagated        * to the next pixel on the current line, and all the errors for the        * next line have been shifted over.  We are therefore ready to move on.        */
name|inptr
operator|+=
name|dir3
expr_stmt|;
comment|/* Advance pixel pointers to next column */
name|outptr
operator|+=
name|dir
expr_stmt|;
name|errorptr
operator|+=
name|dir3
expr_stmt|;
comment|/* advance errorptr to current column */
block|}
comment|/* Post-loop cleanup: we must unload the final error values into the      * final fserrors[] entry.  Note we need not unload belowerrN because      * it is for the dummy column before or after the actual array.      */
name|errorptr
index|[
literal|0
index|]
operator|=
operator|(
name|FSERROR
operator|)
name|bpreverr0
expr_stmt|;
comment|/* unload prev errs into array */
name|errorptr
index|[
literal|1
index|]
operator|=
operator|(
name|FSERROR
operator|)
name|bpreverr1
expr_stmt|;
name|errorptr
index|[
literal|2
index|]
operator|=
operator|(
name|FSERROR
operator|)
name|bpreverr2
expr_stmt|;
block|}
block|}
end_block
begin_comment
comment|/*  * Initialize the error-limiting transfer function (lookup table).  * The raw F-S error computation can potentially compute error values of up to  * +- MAXJSAMPLE.  But we want the maximum correction applied to a pixel to be  * much less, otherwise obviously wrong pixels will be created.  (Typical  * effects include weird fringes at color-area boundaries, isolated bright  * pixels in a dark area, etc.)  The standard advice for avoiding this problem  * is to ensure that the "corners" of the color cube are allocated as output  * colors; then repeated errors in the same direction cannot cause cascading  * error buildup.  However, that only prevents the error from getting  * completely out of hand; Aaron Giles reports that error limiting improves  * the results even with corner colors allocated.  * A simple clamping of the error values to about +- MAXJSAMPLE/8 works pretty  * well, but the smoother transfer function used below is even better.  Thanks  * to Aaron Giles for this idea.  */
end_comment
begin_macro
name|LOCAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|init_error_limit
name|init_error_limit
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|)
end_macro
begin_comment
comment|/* Allocate and fill in the error_limiter table */
end_comment
begin_block
block|{
name|my_cquantize_ptr
name|cquantize
init|=
operator|(
name|my_cquantize_ptr
operator|)
name|cinfo
operator|->
name|cquantize
decl_stmt|;
name|int
modifier|*
name|table
decl_stmt|;
name|int
name|in
decl_stmt|,
name|out
decl_stmt|;
name|table
operator|=
operator|(
name|int
operator|*
operator|)
call|(
modifier|*
name|cinfo
operator|->
name|mem
operator|->
name|alloc_small
call|)
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|,
name|JPOOL_IMAGE
argument_list|,
operator|(
name|MAXJSAMPLE
operator|*
literal|2
operator|+
literal|1
operator|)
operator|*
name|SIZEOF
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|table
operator|+=
name|MAXJSAMPLE
expr_stmt|;
comment|/* so can index -MAXJSAMPLE .. +MAXJSAMPLE */
name|cquantize
operator|->
name|error_limiter
operator|=
name|table
expr_stmt|;
DECL|macro|STEPSIZE
define|#
directive|define
name|STEPSIZE
value|((MAXJSAMPLE+1)/16)
comment|/* Map errors 1:1 up to +- MAXJSAMPLE/16 */
name|out
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|in
operator|=
literal|0
init|;
name|in
operator|<
name|STEPSIZE
condition|;
name|in
operator|++
operator|,
name|out
operator|++
control|)
block|{
name|table
index|[
name|in
index|]
operator|=
name|out
expr_stmt|;
name|table
index|[
operator|-
name|in
index|]
operator|=
operator|-
name|out
expr_stmt|;
block|}
comment|/* Map errors 1:2 up to +- 3*MAXJSAMPLE/16 */
for|for
control|(
init|;
name|in
operator|<
name|STEPSIZE
operator|*
literal|3
condition|;
name|in
operator|++
operator|,
name|out
operator|+=
operator|(
name|in
operator|&
literal|1
operator|)
condition|?
literal|0
else|:
literal|1
control|)
block|{
name|table
index|[
name|in
index|]
operator|=
name|out
expr_stmt|;
name|table
index|[
operator|-
name|in
index|]
operator|=
operator|-
name|out
expr_stmt|;
block|}
comment|/* Clamp the rest to final out value (which is (MAXJSAMPLE+1)/8) */
for|for
control|(
init|;
name|in
operator|<=
name|MAXJSAMPLE
condition|;
name|in
operator|++
control|)
block|{
name|table
index|[
name|in
index|]
operator|=
name|out
expr_stmt|;
name|table
index|[
operator|-
name|in
index|]
operator|=
operator|-
name|out
expr_stmt|;
block|}
DECL|macro|STEPSIZE
undef|#
directive|undef
name|STEPSIZE
block|}
end_block
begin_comment
comment|/*  * Finish up at the end of each pass.  */
end_comment
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|finish_pass1
name|finish_pass1
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|)
end_macro
begin_block
block|{
name|my_cquantize_ptr
name|cquantize
init|=
operator|(
name|my_cquantize_ptr
operator|)
name|cinfo
operator|->
name|cquantize
decl_stmt|;
comment|/* Select the representative colors and fill in cinfo->colormap */
name|cinfo
operator|->
name|colormap
operator|=
name|cquantize
operator|->
name|sv_colormap
expr_stmt|;
name|select_colors
argument_list|(
name|cinfo
argument_list|,
name|cquantize
operator|->
name|desired
argument_list|)
expr_stmt|;
comment|/* Force next pass to zero the color index table */
name|cquantize
operator|->
name|needs_zeroed
operator|=
name|TRUE
expr_stmt|;
block|}
end_block
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|finish_pass2
name|finish_pass2
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|)
end_macro
begin_block
block|{
comment|/* no work */
block|}
end_block
begin_comment
comment|/*  * Initialize for each processing pass.  */
end_comment
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|start_pass_2_quant
name|start_pass_2_quant
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|,
argument|boolean is_pre_scan
argument_list|)
end_macro
begin_block
block|{
name|my_cquantize_ptr
name|cquantize
init|=
operator|(
name|my_cquantize_ptr
operator|)
name|cinfo
operator|->
name|cquantize
decl_stmt|;
name|hist3d
name|histogram
init|=
name|cquantize
operator|->
name|histogram
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Only F-S dithering or no dithering is supported. */
comment|/* If user asks for ordered dither, give him F-S. */
if|if
condition|(
name|cinfo
operator|->
name|dither_mode
operator|!=
name|JDITHER_NONE
condition|)
name|cinfo
operator|->
name|dither_mode
operator|=
name|JDITHER_FS
expr_stmt|;
if|if
condition|(
name|is_pre_scan
condition|)
block|{
comment|/* Set up method pointers */
name|cquantize
operator|->
name|pub
operator|.
name|color_quantize
operator|=
name|prescan_quantize
expr_stmt|;
name|cquantize
operator|->
name|pub
operator|.
name|finish_pass
operator|=
name|finish_pass1
expr_stmt|;
name|cquantize
operator|->
name|needs_zeroed
operator|=
name|TRUE
expr_stmt|;
comment|/* Always zero histogram */
block|}
else|else
block|{
comment|/* Set up method pointers */
if|if
condition|(
name|cinfo
operator|->
name|dither_mode
operator|==
name|JDITHER_FS
condition|)
name|cquantize
operator|->
name|pub
operator|.
name|color_quantize
operator|=
name|pass2_fs_dither
expr_stmt|;
else|else
name|cquantize
operator|->
name|pub
operator|.
name|color_quantize
operator|=
name|pass2_no_dither
expr_stmt|;
name|cquantize
operator|->
name|pub
operator|.
name|finish_pass
operator|=
name|finish_pass2
expr_stmt|;
comment|/* Make sure color count is acceptable */
name|i
operator|=
name|cinfo
operator|->
name|actual_number_of_colors
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|1
condition|)
name|ERREXIT1
argument_list|(
name|cinfo
argument_list|,
name|JERR_QUANT_FEW_COLORS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|MAXNUMCOLORS
condition|)
name|ERREXIT1
argument_list|(
name|cinfo
argument_list|,
name|JERR_QUANT_MANY_COLORS
argument_list|,
name|MAXNUMCOLORS
argument_list|)
expr_stmt|;
if|if
condition|(
name|cinfo
operator|->
name|dither_mode
operator|==
name|JDITHER_FS
condition|)
block|{
name|size_t
name|arraysize
init|=
call|(
name|size_t
call|)
argument_list|(
operator|(
name|cinfo
operator|->
name|output_width
operator|+
literal|2
operator|)
operator|*
operator|(
literal|3
operator|*
name|SIZEOF
argument_list|(
name|FSERROR
argument_list|)
operator|)
argument_list|)
decl_stmt|;
comment|/* Allocate Floyd-Steinberg workspace if we didn't already. */
if|if
condition|(
name|cquantize
operator|->
name|fserrors
operator|==
name|NULL
condition|)
name|cquantize
operator|->
name|fserrors
operator|=
call|(
name|FSERRPTR
call|)
argument_list|(
operator|*
name|cinfo
operator|->
name|mem
operator|->
name|alloc_large
argument_list|)
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|,
name|JPOOL_IMAGE
argument_list|,
name|arraysize
argument_list|)
expr_stmt|;
comment|/* Initialize the propagated errors to zero. */
name|jzero_far
argument_list|(
operator|(
name|void
name|FAR
operator|*
operator|)
name|cquantize
operator|->
name|fserrors
argument_list|,
name|arraysize
argument_list|)
expr_stmt|;
comment|/* Make the error-limit table if we didn't already. */
if|if
condition|(
name|cquantize
operator|->
name|error_limiter
operator|==
name|NULL
condition|)
name|init_error_limit
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
name|cquantize
operator|->
name|on_odd_row
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
comment|/* Zero the histogram or inverse color map, if necessary */
if|if
condition|(
name|cquantize
operator|->
name|needs_zeroed
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HIST_C0_ELEMS
condition|;
name|i
operator|++
control|)
block|{
name|jzero_far
argument_list|(
operator|(
name|void
name|FAR
operator|*
operator|)
name|histogram
index|[
name|i
index|]
argument_list|,
name|HIST_C1_ELEMS
operator|*
name|HIST_C2_ELEMS
operator|*
name|SIZEOF
argument_list|(
name|histcell
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|cquantize
operator|->
name|needs_zeroed
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
end_block
begin_comment
comment|/*  * Switch to a new external colormap between output passes.  */
end_comment
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|new_color_map_2_quant
name|new_color_map_2_quant
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|)
end_macro
begin_block
block|{
name|my_cquantize_ptr
name|cquantize
init|=
operator|(
name|my_cquantize_ptr
operator|)
name|cinfo
operator|->
name|cquantize
decl_stmt|;
comment|/* Reset the inverse color map */
name|cquantize
operator|->
name|needs_zeroed
operator|=
name|TRUE
expr_stmt|;
block|}
end_block
begin_comment
comment|/*  * Module initialization routine for 2-pass color quantization.  */
end_comment
begin_macro
name|GLOBAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|jinit_2pass_quantizer
name|jinit_2pass_quantizer
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|)
end_macro
begin_block
block|{
name|my_cquantize_ptr
name|cquantize
decl_stmt|;
name|int
name|i
decl_stmt|;
name|cquantize
operator|=
call|(
name|my_cquantize_ptr
call|)
argument_list|(
operator|*
name|cinfo
operator|->
name|mem
operator|->
name|alloc_small
argument_list|)
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|,
name|JPOOL_IMAGE
argument_list|,
name|SIZEOF
argument_list|(
name|my_cquantizer
argument_list|)
argument_list|)
expr_stmt|;
name|cinfo
operator|->
name|cquantize
operator|=
operator|(
expr|struct
name|jpeg_color_quantizer
operator|*
operator|)
name|cquantize
expr_stmt|;
name|cquantize
operator|->
name|pub
operator|.
name|start_pass
operator|=
name|start_pass_2_quant
expr_stmt|;
name|cquantize
operator|->
name|pub
operator|.
name|new_color_map
operator|=
name|new_color_map_2_quant
expr_stmt|;
name|cquantize
operator|->
name|fserrors
operator|=
name|NULL
expr_stmt|;
comment|/* flag optional arrays not allocated */
name|cquantize
operator|->
name|error_limiter
operator|=
name|NULL
expr_stmt|;
comment|/* Make sure jdmaster didn't give me a case I can't handle */
if|if
condition|(
name|cinfo
operator|->
name|out_color_components
operator|!=
literal|3
condition|)
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_NOTIMPL
argument_list|)
expr_stmt|;
comment|/* Allocate the histogram/inverse colormap storage */
name|cquantize
operator|->
name|histogram
operator|=
call|(
name|hist3d
call|)
argument_list|(
operator|*
name|cinfo
operator|->
name|mem
operator|->
name|alloc_small
argument_list|)
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|,
name|JPOOL_IMAGE
argument_list|,
name|HIST_C0_ELEMS
operator|*
name|SIZEOF
argument_list|(
name|hist2d
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HIST_C0_ELEMS
condition|;
name|i
operator|++
control|)
block|{
name|cquantize
operator|->
name|histogram
index|[
name|i
index|]
operator|=
call|(
name|hist2d
call|)
argument_list|(
operator|*
name|cinfo
operator|->
name|mem
operator|->
name|alloc_large
argument_list|)
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|,
name|JPOOL_IMAGE
argument_list|,
name|HIST_C1_ELEMS
operator|*
name|HIST_C2_ELEMS
operator|*
name|SIZEOF
argument_list|(
name|histcell
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|cquantize
operator|->
name|needs_zeroed
operator|=
name|TRUE
expr_stmt|;
comment|/* histogram is garbage now */
comment|/* Allocate storage for the completed colormap, if required.    * We do this now since it is FAR storage and may affect    * the memory manager's space calculations.    */
if|if
condition|(
name|cinfo
operator|->
name|enable_2pass_quant
condition|)
block|{
comment|/* Make sure color count is acceptable */
name|int
name|desired
init|=
name|cinfo
operator|->
name|desired_number_of_colors
decl_stmt|;
comment|/* Lower bound on # of colors ... somewhat arbitrary as long as> 0 */
if|if
condition|(
name|desired
operator|<
literal|8
condition|)
name|ERREXIT1
argument_list|(
name|cinfo
argument_list|,
name|JERR_QUANT_FEW_COLORS
argument_list|,
literal|8
argument_list|)
expr_stmt|;
comment|/* Make sure colormap indexes can be represented by JSAMPLEs */
if|if
condition|(
name|desired
operator|>
name|MAXNUMCOLORS
condition|)
name|ERREXIT1
argument_list|(
name|cinfo
argument_list|,
name|JERR_QUANT_MANY_COLORS
argument_list|,
name|MAXNUMCOLORS
argument_list|)
expr_stmt|;
name|cquantize
operator|->
name|sv_colormap
operator|=
call|(
modifier|*
name|cinfo
operator|->
name|mem
operator|->
name|alloc_sarray
call|)
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|,
name|JPOOL_IMAGE
argument_list|,
operator|(
name|JDIMENSION
operator|)
name|desired
argument_list|,
operator|(
name|JDIMENSION
operator|)
literal|3
argument_list|)
expr_stmt|;
name|cquantize
operator|->
name|desired
operator|=
name|desired
expr_stmt|;
block|}
else|else
name|cquantize
operator|->
name|sv_colormap
operator|=
name|NULL
expr_stmt|;
comment|/* Only F-S dithering or no dithering is supported. */
comment|/* If user asks for ordered dither, give him F-S. */
if|if
condition|(
name|cinfo
operator|->
name|dither_mode
operator|!=
name|JDITHER_NONE
condition|)
name|cinfo
operator|->
name|dither_mode
operator|=
name|JDITHER_FS
expr_stmt|;
comment|/* Allocate Floyd-Steinberg workspace if necessary.    * This isn't really needed until pass 2, but again it is FAR storage.    * Although we will cope with a later change in dither_mode,    * we do not promise to honor max_memory_to_use if dither_mode changes.    */
if|if
condition|(
name|cinfo
operator|->
name|dither_mode
operator|==
name|JDITHER_FS
condition|)
block|{
name|cquantize
operator|->
name|fserrors
operator|=
call|(
name|FSERRPTR
call|)
argument_list|(
operator|*
name|cinfo
operator|->
name|mem
operator|->
name|alloc_large
argument_list|)
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|,
name|JPOOL_IMAGE
argument_list|,
call|(
name|size_t
call|)
argument_list|(
operator|(
name|cinfo
operator|->
name|output_width
operator|+
literal|2
operator|)
operator|*
operator|(
literal|3
operator|*
name|SIZEOF
argument_list|(
name|FSERROR
argument_list|)
operator|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Might as well create the error-limiting table too. */
name|init_error_limit
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
block|}
block|}
end_block
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* QUANT_2PASS_SUPPORTED */
end_comment
end_unit
