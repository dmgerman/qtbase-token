begin_unit
begin_comment
comment|/*  * jinclude.h  *  * Copyright (C) 1991-1994, Thomas G. Lane.  * This file is part of the Independent JPEG Group's software.  * For conditions of distribution and use, see the accompanying README file.  *  * This file exists to provide a single place to fix any problems with  * including the wrong system include files.  (Common problems are taken  * care of by the standard jconfig symbols, but on really weird systems  * you may have to edit this file.)  *  * NOTE: this file is NOT intended to be included by applications using the  * JPEG library.  Most applications need only include jpeglib.h.  */
end_comment
begin_comment
comment|/* Include auto-config file to find out which system include files we need. */
end_comment
begin_include
include|#
directive|include
file|"jconfig.h"
end_include
begin_comment
comment|/* auto configuration options */
end_comment
begin_define
DECL|macro|JCONFIG_INCLUDED
define|#
directive|define
name|JCONFIG_INCLUDED
end_define
begin_comment
DECL|macro|JCONFIG_INCLUDED
comment|/* so that jpeglib.h doesn't do it again */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|_MSC_VER
end_ifdef
begin_define
DECL|macro|_CRT_SECURE_NO_DEPRECATE
define|#
directive|define
name|_CRT_SECURE_NO_DEPRECATE
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*  * We need the NULL macro and size_t typedef.  * On an ANSI-conforming system it is sufficient to include<stddef.h>.  * Otherwise, we get them from<stdlib.h> or<stdio.h>; we may have to  * pull in<sys/types.h> as well.  * Note that the core JPEG library does not require<stdio.h>;  * only the default error handler and data source/destination modules do.  * But we must pull it in because of the references to FILE in jpeglib.h.  * You can remove those references if you want to compile without<stdio.h>.  */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STDDEF_H
end_ifdef
begin_include
include|#
directive|include
file|<stddef.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STDLIB_H
end_ifdef
begin_include
include|#
directive|include
file|<stdlib.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|NEED_SYS_TYPES_H
end_ifdef
begin_include
include|#
directive|include
file|<sys/types.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|<stdio.h>
end_include
begin_comment
comment|/*  * We need memory copying and zeroing functions, plus strncpy().  * ANSI and System V implementations declare these in<string.h>.  * BSD doesn't have the mem() functions, but it does have bcopy()/bzero().  * Some systems may declare memset and memcpy in<memory.h>.  *  * NOTE: we assume the size parameters to these functions are of type size_t.  * Change the casts in these macros if not!  */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|NEED_BSD_STRINGS
end_ifdef
begin_include
include|#
directive|include
file|<strings.h>
end_include
begin_define
DECL|macro|MEMZERO
define|#
directive|define
name|MEMZERO
parameter_list|(
name|target
parameter_list|,
name|size
parameter_list|)
value|bzero((void *)(target), (size_t)(size))
end_define
begin_define
DECL|macro|MEMCOPY
define|#
directive|define
name|MEMCOPY
parameter_list|(
name|dest
parameter_list|,
name|src
parameter_list|,
name|size
parameter_list|)
value|bcopy((const void *)(src), (void *)(dest), (size_t)(size))
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* not BSD, assume ANSI/SysV string lib */
end_comment
begin_include
include|#
directive|include
file|<string.h>
end_include
begin_define
DECL|macro|MEMZERO
define|#
directive|define
name|MEMZERO
parameter_list|(
name|target
parameter_list|,
name|size
parameter_list|)
value|memset((void *)(target), 0, (size_t)(size))
end_define
begin_define
DECL|macro|MEMCOPY
define|#
directive|define
name|MEMCOPY
parameter_list|(
name|dest
parameter_list|,
name|src
parameter_list|,
name|size
parameter_list|)
value|memcpy((void *)(dest), (const void *)(src), (size_t)(size))
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*  * In ANSI C, and indeed any rational implementation, size_t is also the  * type returned by sizeof().  However, it seems there are some irrational  * implementations out there, in which sizeof() returns an int even though  * size_t is defined as long or unsigned long.  To ensure consistent results  * we always use this SIZEOF() macro in place of using sizeof() directly.  */
end_comment
begin_define
DECL|macro|SIZEOF
define|#
directive|define
name|SIZEOF
parameter_list|(
name|object
parameter_list|)
value|((size_t) sizeof(object))
end_define
begin_comment
comment|/*  * The modules that use fread() and fwrite() always invoke them through  * these macros.  On some systems you may need to twiddle the argument casts.  * CAUTION: argument order is different from underlying functions!  */
end_comment
begin_define
DECL|macro|JFREAD
define|#
directive|define
name|JFREAD
parameter_list|(
name|file
parameter_list|,
name|buf
parameter_list|,
name|sizeofbuf
parameter_list|)
define|\
value|((size_t) fread((void *) (buf), (size_t) 1, (size_t) (sizeofbuf), (file)))
end_define
begin_define
DECL|macro|JFWRITE
define|#
directive|define
name|JFWRITE
parameter_list|(
name|file
parameter_list|,
name|buf
parameter_list|,
name|sizeofbuf
parameter_list|)
define|\
value|((size_t) fwrite((const void *) (buf), (size_t) 1, (size_t) (sizeofbuf), (file)))
end_define
end_unit
