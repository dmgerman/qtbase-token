begin_unit
begin_comment
comment|/*  * jcarith.c  *  * Developed 1997-2009 by Guido Vollbeding.  * This file is part of the Independent JPEG Group's software.  * For conditions of distribution and use, see the accompanying README file.  *  * This file contains portable arithmetic entropy encoding routines for JPEG  * (implementing the ISO/IEC IS 10918-1 and CCITT Recommendation ITU-T T.81).  *  * Both sequential and progressive modes are supported in this single module.  *  * Suspension is not currently supported in this module.  */
end_comment
begin_define
DECL|macro|JPEG_INTERNALS
define|#
directive|define
name|JPEG_INTERNALS
end_define
begin_include
include|#
directive|include
file|"jinclude.h"
end_include
begin_include
include|#
directive|include
file|"jpeglib.h"
end_include
begin_comment
comment|/* Expanded entropy encoder object for arithmetic encoding. */
end_comment
begin_typedef
typedef|typedef
struct|struct
block|{
DECL|member|pub
name|struct
name|jpeg_entropy_encoder
name|pub
decl_stmt|;
comment|/* public fields */
DECL|member|c
name|INT32
name|c
decl_stmt|;
comment|/* C register, base of coding interval, layout as in sec. D.1.3 */
DECL|member|a
name|INT32
name|a
decl_stmt|;
comment|/* A register, normalized size of coding interval */
DECL|member|sc
name|INT32
name|sc
decl_stmt|;
comment|/* counter for stacked 0xFF values which might overflow */
DECL|member|zc
name|INT32
name|zc
decl_stmt|;
comment|/* counter for pending 0x00 output values which might *                           * be discarded at the end ("Pacman" termination) */
DECL|member|ct
name|int
name|ct
decl_stmt|;
comment|/* bit shift counter, determines when next byte will be written */
DECL|member|buffer
name|int
name|buffer
decl_stmt|;
comment|/* buffer for most recent output byte != 0xFF */
DECL|member|last_dc_val
name|int
name|last_dc_val
index|[
name|MAX_COMPS_IN_SCAN
index|]
decl_stmt|;
comment|/* last DC coef for each component */
DECL|member|dc_context
name|int
name|dc_context
index|[
name|MAX_COMPS_IN_SCAN
index|]
decl_stmt|;
comment|/* context index for DC conditioning */
DECL|member|restarts_to_go
name|unsigned
name|int
name|restarts_to_go
decl_stmt|;
comment|/* MCUs left in this restart interval */
DECL|member|next_restart_num
name|int
name|next_restart_num
decl_stmt|;
comment|/* next restart number to write (0-7) */
comment|/* Pointers to statistics areas (these workspaces have image lifespan) */
DECL|member|dc_stats
name|unsigned
name|char
modifier|*
name|dc_stats
index|[
name|NUM_ARITH_TBLS
index|]
decl_stmt|;
DECL|member|ac_stats
name|unsigned
name|char
modifier|*
name|ac_stats
index|[
name|NUM_ARITH_TBLS
index|]
decl_stmt|;
comment|/* Statistics bin for coding with fixed probability 0.5 */
DECL|member|fixed_bin
name|unsigned
name|char
name|fixed_bin
index|[
literal|4
index|]
decl_stmt|;
block|}
DECL|typedef|arith_entropy_encoder
name|arith_entropy_encoder
typedef|;
end_typedef
begin_typedef
DECL|typedef|arith_entropy_ptr
typedef|typedef
name|arith_entropy_encoder
modifier|*
name|arith_entropy_ptr
typedef|;
end_typedef
begin_comment
comment|/* The following two definitions specify the allocation chunk size  * for the statistics area.  * According to sections F.1.4.4.1.3 and F.1.4.4.2, we need at least  * 49 statistics bins for DC, and 245 statistics bins for AC coding.  *  * We use a compact representation with 1 byte per statistics bin,  * thus the numbers directly represent byte sizes.  * This 1 byte per statistics bin contains the meaning of the MPS  * (more probable symbol) in the highest bit (mask 0x80), and the  * index into the probability estimation state machine table  * in the lower bits (mask 0x7F).  */
end_comment
begin_define
DECL|macro|DC_STAT_BINS
define|#
directive|define
name|DC_STAT_BINS
value|64
end_define
begin_define
DECL|macro|AC_STAT_BINS
define|#
directive|define
name|AC_STAT_BINS
value|256
end_define
begin_comment
comment|/* NOTE: Uncomment the following #define if you want to use the  * given formula for calculating the AC conditioning parameter Kx  * for spectral selection progressive coding in section G.1.3.2  * of the spec (Kx = Kmin + SRL (8 + Se - Kmin) 4).  * Although the spec and P&M authors claim that this "has proven  * to give good results for 8 bit precision samples", I'm not  * convinced yet that this is really beneficial.  * Early tests gave only very marginal compression enhancements  * (a few - around 5 or so - bytes even for very large files),  * which would turn out rather negative if we'd suppress the  * DAC (Define Arithmetic Conditioning) marker segments for  * the default parameters in the future.  * Note that currently the marker writing module emits 12-byte  * DAC segments for a full-component scan in a color image.  * This is not worth worrying about IMHO. However, since the  * spec defines the default values to be used if the tables  * are omitted (unlike Huffman tables, which are required  * anyway), one might optimize this behaviour in the future,  * and then it would be disadvantageous to use custom tables if  * they don't provide sufficient gain to exceed the DAC size.  *  * On the other hand, I'd consider it as a reasonable result  * that the conditioning has no significant influence on the  * compression performance. This means that the basic  * statistical model is already rather stable.  *  * Thus, at the moment, we use the default conditioning values  * anyway, and do not use the custom formula.  * #define CALCULATE_SPECTRAL_CONDITIONING  */
end_comment
begin_comment
comment|/* IRIGHT_SHIFT is like RIGHT_SHIFT, but works on int rather than INT32.  * We assume that int right shift is unsigned if INT32 right shift is,  * which should be safe.  */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|RIGHT_SHIFT_IS_UNSIGNED
end_ifdef
begin_define
DECL|macro|ISHIFT_TEMPS
define|#
directive|define
name|ISHIFT_TEMPS
value|int ishift_temp;
end_define
begin_define
DECL|macro|IRIGHT_SHIFT
define|#
directive|define
name|IRIGHT_SHIFT
parameter_list|(
name|x
parameter_list|,
name|shft
parameter_list|)
define|\
value|((ishift_temp = (x))< 0 ? \ 	 (ishift_temp>> (shft)) | ((~0)<< (16-(shft))) : \ 	 (ishift_temp>> (shft)))
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|ISHIFT_TEMPS
define|#
directive|define
name|ISHIFT_TEMPS
end_define
begin_define
DECL|macro|IRIGHT_SHIFT
define|#
directive|define
name|IRIGHT_SHIFT
parameter_list|(
name|x
parameter_list|,
name|shft
parameter_list|)
value|((x)>> (shft))
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_macro
name|LOCAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|emit_byte
name|emit_byte
argument_list|(
argument|int val
argument_list|,
argument|j_compress_ptr cinfo
argument_list|)
end_macro
begin_comment
comment|/* Write next output byte; we do not support suspension in this module. */
end_comment
begin_block
block|{
name|struct
name|jpeg_destination_mgr
modifier|*
name|dest
init|=
name|cinfo
operator|->
name|dest
decl_stmt|;
operator|*
name|dest
operator|->
name|next_output_byte
operator|++
operator|=
operator|(
name|JOCTET
operator|)
name|val
expr_stmt|;
if|if
condition|(
operator|--
name|dest
operator|->
name|free_in_buffer
operator|==
literal|0
condition|)
if|if
condition|(
operator|!
call|(
modifier|*
name|dest
operator|->
name|empty_output_buffer
call|)
argument_list|(
name|cinfo
argument_list|)
condition|)
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_CANT_SUSPEND
argument_list|)
expr_stmt|;
block|}
end_block
begin_comment
comment|/*  * Finish up at the end of an arithmetic-compressed scan.  */
end_comment
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|finish_pass
name|finish_pass
argument_list|(
argument|j_compress_ptr cinfo
argument_list|)
end_macro
begin_block
block|{
name|arith_entropy_ptr
name|e
init|=
operator|(
name|arith_entropy_ptr
operator|)
name|cinfo
operator|->
name|entropy
decl_stmt|;
name|INT32
name|temp
decl_stmt|;
comment|/* Section D.1.8: Termination of encoding */
comment|/* Find the e->c in the coding interval with the largest    * number of trailing zero bits */
if|if
condition|(
operator|(
name|temp
operator|=
operator|(
name|e
operator|->
name|a
operator|-
literal|1
operator|+
name|e
operator|->
name|c
operator|)
operator|&
literal|0xFFFF0000L
operator|)
operator|<
name|e
operator|->
name|c
condition|)
name|e
operator|->
name|c
operator|=
name|temp
operator|+
literal|0x8000L
expr_stmt|;
else|else
name|e
operator|->
name|c
operator|=
name|temp
expr_stmt|;
comment|/* Send remaining bytes to output */
name|e
operator|->
name|c
operator|<<=
name|e
operator|->
name|ct
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|c
operator|&
literal|0xF8000000L
condition|)
block|{
comment|/* One final overflow has to be handled */
if|if
condition|(
name|e
operator|->
name|buffer
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|e
operator|->
name|zc
condition|)
do|do
name|emit_byte
argument_list|(
literal|0x00
argument_list|,
name|cinfo
argument_list|)
expr_stmt|;
do|while
condition|(
operator|--
name|e
operator|->
name|zc
condition|)
do|;
name|emit_byte
argument_list|(
name|e
operator|->
name|buffer
operator|+
literal|1
argument_list|,
name|cinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|buffer
operator|+
literal|1
operator|==
literal|0xFF
condition|)
name|emit_byte
argument_list|(
literal|0x00
argument_list|,
name|cinfo
argument_list|)
expr_stmt|;
block|}
name|e
operator|->
name|zc
operator|+=
name|e
operator|->
name|sc
expr_stmt|;
comment|/* carry-over converts stacked 0xFF bytes to 0x00 */
name|e
operator|->
name|sc
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|e
operator|->
name|buffer
operator|==
literal|0
condition|)
operator|++
name|e
operator|->
name|zc
expr_stmt|;
elseif|else
if|if
condition|(
name|e
operator|->
name|buffer
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|e
operator|->
name|zc
condition|)
do|do
name|emit_byte
argument_list|(
literal|0x00
argument_list|,
name|cinfo
argument_list|)
expr_stmt|;
do|while
condition|(
operator|--
name|e
operator|->
name|zc
condition|)
do|;
name|emit_byte
argument_list|(
name|e
operator|->
name|buffer
argument_list|,
name|cinfo
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|->
name|sc
condition|)
block|{
if|if
condition|(
name|e
operator|->
name|zc
condition|)
do|do
name|emit_byte
argument_list|(
literal|0x00
argument_list|,
name|cinfo
argument_list|)
expr_stmt|;
do|while
condition|(
operator|--
name|e
operator|->
name|zc
condition|)
do|;
do|do
block|{
name|emit_byte
argument_list|(
literal|0xFF
argument_list|,
name|cinfo
argument_list|)
expr_stmt|;
name|emit_byte
argument_list|(
literal|0x00
argument_list|,
name|cinfo
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|e
operator|->
name|sc
condition|)
do|;
block|}
block|}
comment|/* Output final bytes only if they are not 0x00 */
if|if
condition|(
name|e
operator|->
name|c
operator|&
literal|0x7FFF800L
condition|)
block|{
if|if
condition|(
name|e
operator|->
name|zc
condition|)
comment|/* output final pending zero bytes */
do|do
name|emit_byte
argument_list|(
literal|0x00
argument_list|,
name|cinfo
argument_list|)
expr_stmt|;
do|while
condition|(
operator|--
name|e
operator|->
name|zc
condition|)
do|;
name|emit_byte
argument_list|(
operator|(
name|e
operator|->
name|c
operator|>>
literal|19
operator|)
operator|&
literal|0xFF
argument_list|,
name|cinfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|e
operator|->
name|c
operator|>>
literal|19
operator|)
operator|&
literal|0xFF
operator|)
operator|==
literal|0xFF
condition|)
name|emit_byte
argument_list|(
literal|0x00
argument_list|,
name|cinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|c
operator|&
literal|0x7F800L
condition|)
block|{
name|emit_byte
argument_list|(
operator|(
name|e
operator|->
name|c
operator|>>
literal|11
operator|)
operator|&
literal|0xFF
argument_list|,
name|cinfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|e
operator|->
name|c
operator|>>
literal|11
operator|)
operator|&
literal|0xFF
operator|)
operator|==
literal|0xFF
condition|)
name|emit_byte
argument_list|(
literal|0x00
argument_list|,
name|cinfo
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block
begin_comment
comment|/*  * The core arithmetic encoding routine (common in JPEG and JBIG).  * This needs to go as fast as possible.  * Machine-dependent optimization facilities  * are not utilized in this portable implementation.  * However, this code should be fairly efficient and  * may be a good base for further optimizations anyway.  *  * Parameter 'val' to be encoded may be 0 or 1 (binary decision).  *  * Note: I've added full "Pacman" termination support to the  * byte output routines, which is equivalent to the optional  * Discard_final_zeros procedure (Figure D.15) in the spec.  * Thus, we always produce the shortest possible output  * stream compliant to the spec (no trailing zero bytes,  * except for FF stuffing).  *  * I've also introduced a new scheme for accessing  * the probability estimation state machine table,  * derived from Markus Kuhn's JBIG implementation.  */
end_comment
begin_macro
name|LOCAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|arith_encode
name|arith_encode
argument_list|(
argument|j_compress_ptr cinfo
argument_list|,
argument|unsigned char *st
argument_list|,
argument|int val
argument_list|)
end_macro
begin_block
block|{
specifier|register
name|arith_entropy_ptr
name|e
init|=
operator|(
name|arith_entropy_ptr
operator|)
name|cinfo
operator|->
name|entropy
decl_stmt|;
specifier|register
name|unsigned
name|char
name|nl
decl_stmt|,
name|nm
decl_stmt|;
specifier|register
name|INT32
name|qe
decl_stmt|,
name|temp
decl_stmt|;
specifier|register
name|int
name|sv
decl_stmt|;
comment|/* Fetch values from our compact representation of Table D.2:    * Qe values and probability estimation state machine    */
name|sv
operator|=
operator|*
name|st
expr_stmt|;
name|qe
operator|=
name|jpeg_aritab
index|[
name|sv
operator|&
literal|0x7F
index|]
expr_stmt|;
comment|/* => Qe_Value */
name|nl
operator|=
name|qe
operator|&
literal|0xFF
expr_stmt|;
name|qe
operator|>>=
literal|8
expr_stmt|;
comment|/* Next_Index_LPS + Switch_MPS */
name|nm
operator|=
name|qe
operator|&
literal|0xFF
expr_stmt|;
name|qe
operator|>>=
literal|8
expr_stmt|;
comment|/* Next_Index_MPS */
comment|/* Encode& estimation procedures per sections D.1.4& D.1.5 */
name|e
operator|->
name|a
operator|-=
name|qe
expr_stmt|;
if|if
condition|(
name|val
operator|!=
operator|(
name|sv
operator|>>
literal|7
operator|)
condition|)
block|{
comment|/* Encode the less probable symbol */
if|if
condition|(
name|e
operator|->
name|a
operator|>=
name|qe
condition|)
block|{
comment|/* If the interval size (qe) for the less probable symbol (LPS)        * is larger than the interval size for the MPS, then exchange        * the two symbols for coding efficiency, otherwise code the LPS        * as usual: */
name|e
operator|->
name|c
operator|+=
name|e
operator|->
name|a
expr_stmt|;
name|e
operator|->
name|a
operator|=
name|qe
expr_stmt|;
block|}
operator|*
name|st
operator|=
operator|(
name|sv
operator|&
literal|0x80
operator|)
operator|^
name|nl
expr_stmt|;
comment|/* Estimate_after_LPS */
block|}
else|else
block|{
comment|/* Encode the more probable symbol */
if|if
condition|(
name|e
operator|->
name|a
operator|>=
literal|0x8000L
condition|)
return|return;
comment|/* A>= 0x8000 -> ready, no renormalization required */
if|if
condition|(
name|e
operator|->
name|a
operator|<
name|qe
condition|)
block|{
comment|/* If the interval size (qe) for the less probable symbol (LPS)        * is larger than the interval size for the MPS, then exchange        * the two symbols for coding efficiency: */
name|e
operator|->
name|c
operator|+=
name|e
operator|->
name|a
expr_stmt|;
name|e
operator|->
name|a
operator|=
name|qe
expr_stmt|;
block|}
operator|*
name|st
operator|=
operator|(
name|sv
operator|&
literal|0x80
operator|)
operator|^
name|nm
expr_stmt|;
comment|/* Estimate_after_MPS */
block|}
comment|/* Renormalization& data output per section D.1.6 */
do|do
block|{
name|e
operator|->
name|a
operator|<<=
literal|1
expr_stmt|;
name|e
operator|->
name|c
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
operator|--
name|e
operator|->
name|ct
operator|==
literal|0
condition|)
block|{
comment|/* Another byte is ready for output */
name|temp
operator|=
name|e
operator|->
name|c
operator|>>
literal|19
expr_stmt|;
if|if
condition|(
name|temp
operator|>
literal|0xFF
condition|)
block|{
comment|/* Handle overflow over all stacked 0xFF bytes */
if|if
condition|(
name|e
operator|->
name|buffer
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|e
operator|->
name|zc
condition|)
do|do
name|emit_byte
argument_list|(
literal|0x00
argument_list|,
name|cinfo
argument_list|)
expr_stmt|;
do|while
condition|(
operator|--
name|e
operator|->
name|zc
condition|)
do|;
name|emit_byte
argument_list|(
name|e
operator|->
name|buffer
operator|+
literal|1
argument_list|,
name|cinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|buffer
operator|+
literal|1
operator|==
literal|0xFF
condition|)
name|emit_byte
argument_list|(
literal|0x00
argument_list|,
name|cinfo
argument_list|)
expr_stmt|;
block|}
name|e
operator|->
name|zc
operator|+=
name|e
operator|->
name|sc
expr_stmt|;
comment|/* carry-over converts stacked 0xFF bytes to 0x00 */
name|e
operator|->
name|sc
operator|=
literal|0
expr_stmt|;
comment|/* Note: The 3 spacer bits in the C register guarantee 	 * that the new buffer byte can't be 0xFF here 	 * (see page 160 in the P&M JPEG book). */
name|e
operator|->
name|buffer
operator|=
name|temp
operator|&
literal|0xFF
expr_stmt|;
comment|/* new output byte, might overflow later */
block|}
elseif|else
if|if
condition|(
name|temp
operator|==
literal|0xFF
condition|)
block|{
operator|++
name|e
operator|->
name|sc
expr_stmt|;
comment|/* stack 0xFF byte (which might overflow later) */
block|}
else|else
block|{
comment|/* Output all stacked 0xFF bytes, they will not overflow any more */
if|if
condition|(
name|e
operator|->
name|buffer
operator|==
literal|0
condition|)
operator|++
name|e
operator|->
name|zc
expr_stmt|;
elseif|else
if|if
condition|(
name|e
operator|->
name|buffer
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|e
operator|->
name|zc
condition|)
do|do
name|emit_byte
argument_list|(
literal|0x00
argument_list|,
name|cinfo
argument_list|)
expr_stmt|;
do|while
condition|(
operator|--
name|e
operator|->
name|zc
condition|)
do|;
name|emit_byte
argument_list|(
name|e
operator|->
name|buffer
argument_list|,
name|cinfo
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|->
name|sc
condition|)
block|{
if|if
condition|(
name|e
operator|->
name|zc
condition|)
do|do
name|emit_byte
argument_list|(
literal|0x00
argument_list|,
name|cinfo
argument_list|)
expr_stmt|;
do|while
condition|(
operator|--
name|e
operator|->
name|zc
condition|)
do|;
do|do
block|{
name|emit_byte
argument_list|(
literal|0xFF
argument_list|,
name|cinfo
argument_list|)
expr_stmt|;
name|emit_byte
argument_list|(
literal|0x00
argument_list|,
name|cinfo
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|e
operator|->
name|sc
condition|)
do|;
block|}
name|e
operator|->
name|buffer
operator|=
name|temp
operator|&
literal|0xFF
expr_stmt|;
comment|/* new output byte (can still overflow) */
block|}
name|e
operator|->
name|c
operator|&=
literal|0x7FFFFL
expr_stmt|;
name|e
operator|->
name|ct
operator|+=
literal|8
expr_stmt|;
block|}
block|}
do|while
condition|(
name|e
operator|->
name|a
operator|<
literal|0x8000L
condition|)
do|;
block|}
end_block
begin_comment
comment|/*  * Emit a restart marker& resynchronize predictions.  */
end_comment
begin_macro
name|LOCAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|emit_restart
name|emit_restart
argument_list|(
argument|j_compress_ptr cinfo
argument_list|,
argument|int restart_num
argument_list|)
end_macro
begin_block
block|{
name|arith_entropy_ptr
name|entropy
init|=
operator|(
name|arith_entropy_ptr
operator|)
name|cinfo
operator|->
name|entropy
decl_stmt|;
name|int
name|ci
decl_stmt|;
name|jpeg_component_info
modifier|*
name|compptr
decl_stmt|;
name|finish_pass
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
name|emit_byte
argument_list|(
literal|0xFF
argument_list|,
name|cinfo
argument_list|)
expr_stmt|;
name|emit_byte
argument_list|(
name|JPEG_RST0
operator|+
name|restart_num
argument_list|,
name|cinfo
argument_list|)
expr_stmt|;
comment|/* Re-initialize statistics areas */
for|for
control|(
name|ci
operator|=
literal|0
init|;
name|ci
operator|<
name|cinfo
operator|->
name|comps_in_scan
condition|;
name|ci
operator|++
control|)
block|{
name|compptr
operator|=
name|cinfo
operator|->
name|cur_comp_info
index|[
name|ci
index|]
expr_stmt|;
comment|/* DC needs no table for refinement scan */
if|if
condition|(
name|cinfo
operator|->
name|Ss
operator|==
literal|0
operator|&&
name|cinfo
operator|->
name|Ah
operator|==
literal|0
condition|)
block|{
name|MEMZERO
argument_list|(
name|entropy
operator|->
name|dc_stats
index|[
name|compptr
operator|->
name|dc_tbl_no
index|]
argument_list|,
name|DC_STAT_BINS
argument_list|)
expr_stmt|;
comment|/* Reset DC predictions to 0 */
name|entropy
operator|->
name|last_dc_val
index|[
name|ci
index|]
operator|=
literal|0
expr_stmt|;
name|entropy
operator|->
name|dc_context
index|[
name|ci
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* AC needs no table when not present */
if|if
condition|(
name|cinfo
operator|->
name|Se
condition|)
block|{
name|MEMZERO
argument_list|(
name|entropy
operator|->
name|ac_stats
index|[
name|compptr
operator|->
name|ac_tbl_no
index|]
argument_list|,
name|AC_STAT_BINS
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Reset arithmetic encoding variables */
name|entropy
operator|->
name|c
operator|=
literal|0
expr_stmt|;
name|entropy
operator|->
name|a
operator|=
literal|0x10000L
expr_stmt|;
name|entropy
operator|->
name|sc
operator|=
literal|0
expr_stmt|;
name|entropy
operator|->
name|zc
operator|=
literal|0
expr_stmt|;
name|entropy
operator|->
name|ct
operator|=
literal|11
expr_stmt|;
name|entropy
operator|->
name|buffer
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* empty */
block|}
end_block
begin_comment
comment|/*  * MCU encoding for DC initial scan (either spectral selection,  * or first pass of successive approximation).  */
end_comment
begin_macro
DECL|function|METHODDEF
name|METHODDEF
argument_list|(
argument|boolean
argument_list|)
end_macro
begin_macro
name|encode_mcu_DC_first
argument_list|(
argument|j_compress_ptr cinfo
argument_list|,
argument|JBLOCKROW *MCU_data
argument_list|)
end_macro
begin_block
block|{
name|arith_entropy_ptr
name|entropy
init|=
operator|(
name|arith_entropy_ptr
operator|)
name|cinfo
operator|->
name|entropy
decl_stmt|;
name|JBLOCKROW
name|block
decl_stmt|;
name|unsigned
name|char
modifier|*
name|st
decl_stmt|;
name|int
name|blkn
decl_stmt|,
name|ci
decl_stmt|,
name|tbl
decl_stmt|;
name|int
name|v
decl_stmt|,
name|v2
decl_stmt|,
name|m
decl_stmt|;
name|ISHIFT_TEMPS
comment|/* Emit restart marker if needed */
if|if
condition|(
name|cinfo
operator|->
name|restart_interval
condition|)
block|{
if|if
condition|(
name|entropy
operator|->
name|restarts_to_go
operator|==
literal|0
condition|)
block|{
name|emit_restart
argument_list|(
name|cinfo
argument_list|,
name|entropy
operator|->
name|next_restart_num
argument_list|)
expr_stmt|;
name|entropy
operator|->
name|restarts_to_go
operator|=
name|cinfo
operator|->
name|restart_interval
expr_stmt|;
name|entropy
operator|->
name|next_restart_num
operator|++
expr_stmt|;
name|entropy
operator|->
name|next_restart_num
operator|&=
literal|7
expr_stmt|;
block|}
name|entropy
operator|->
name|restarts_to_go
operator|--
expr_stmt|;
block|}
comment|/* Encode the MCU data blocks */
for|for
control|(
name|blkn
operator|=
literal|0
init|;
name|blkn
operator|<
name|cinfo
operator|->
name|blocks_in_MCU
condition|;
name|blkn
operator|++
control|)
block|{
name|block
operator|=
name|MCU_data
index|[
name|blkn
index|]
expr_stmt|;
name|ci
operator|=
name|cinfo
operator|->
name|MCU_membership
index|[
name|blkn
index|]
expr_stmt|;
name|tbl
operator|=
name|cinfo
operator|->
name|cur_comp_info
index|[
name|ci
index|]
operator|->
name|dc_tbl_no
expr_stmt|;
comment|/* Compute the DC value after the required point transform by Al.      * This is simply an arithmetic right shift.      */
name|m
operator|=
name|IRIGHT_SHIFT
argument_list|(
call|(
name|int
call|)
argument_list|(
operator|(
operator|*
name|block
operator|)
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|cinfo
operator|->
name|Al
argument_list|)
expr_stmt|;
comment|/* Sections F.1.4.1& F.1.4.4.1: Encoding of DC coefficients */
comment|/* Table F.4: Point to statistics bin S0 for DC coefficient coding */
name|st
operator|=
name|entropy
operator|->
name|dc_stats
index|[
name|tbl
index|]
operator|+
name|entropy
operator|->
name|dc_context
index|[
name|ci
index|]
expr_stmt|;
comment|/* Figure F.4: Encode_DC_DIFF */
if|if
condition|(
operator|(
name|v
operator|=
name|m
operator|-
name|entropy
operator|->
name|last_dc_val
index|[
name|ci
index|]
operator|)
operator|==
literal|0
condition|)
block|{
name|arith_encode
argument_list|(
name|cinfo
argument_list|,
name|st
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|entropy
operator|->
name|dc_context
index|[
name|ci
index|]
operator|=
literal|0
expr_stmt|;
comment|/* zero diff category */
block|}
else|else
block|{
name|entropy
operator|->
name|last_dc_val
index|[
name|ci
index|]
operator|=
name|m
expr_stmt|;
name|arith_encode
argument_list|(
name|cinfo
argument_list|,
name|st
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Figure F.6: Encoding nonzero value v */
comment|/* Figure F.7: Encoding the sign of v */
if|if
condition|(
name|v
operator|>
literal|0
condition|)
block|{
name|arith_encode
argument_list|(
name|cinfo
argument_list|,
name|st
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Table F.4: SS = S0 + 1 */
name|st
operator|+=
literal|2
expr_stmt|;
comment|/* Table F.4: SP = S0 + 2 */
name|entropy
operator|->
name|dc_context
index|[
name|ci
index|]
operator|=
literal|4
expr_stmt|;
comment|/* small positive diff category */
block|}
else|else
block|{
name|v
operator|=
operator|-
name|v
expr_stmt|;
name|arith_encode
argument_list|(
name|cinfo
argument_list|,
name|st
operator|+
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Table F.4: SS = S0 + 1 */
name|st
operator|+=
literal|3
expr_stmt|;
comment|/* Table F.4: SN = S0 + 3 */
name|entropy
operator|->
name|dc_context
index|[
name|ci
index|]
operator|=
literal|8
expr_stmt|;
comment|/* small negative diff category */
block|}
comment|/* Figure F.8: Encoding the magnitude category of v */
name|m
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|v
operator|-=
literal|1
condition|)
block|{
name|arith_encode
argument_list|(
name|cinfo
argument_list|,
name|st
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|m
operator|=
literal|1
expr_stmt|;
name|v2
operator|=
name|v
expr_stmt|;
name|st
operator|=
name|entropy
operator|->
name|dc_stats
index|[
name|tbl
index|]
operator|+
literal|20
expr_stmt|;
comment|/* Table F.4: X1 = 20 */
while|while
condition|(
name|v2
operator|>>=
literal|1
condition|)
block|{
name|arith_encode
argument_list|(
name|cinfo
argument_list|,
name|st
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|m
operator|<<=
literal|1
expr_stmt|;
name|st
operator|+=
literal|1
expr_stmt|;
block|}
block|}
name|arith_encode
argument_list|(
name|cinfo
argument_list|,
name|st
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Section F.1.4.4.1.2: Establish dc_context conditioning category */
if|if
condition|(
name|m
operator|<
call|(
name|int
call|)
argument_list|(
operator|(
literal|1L
operator|<<
name|cinfo
operator|->
name|arith_dc_L
index|[
name|tbl
index|]
operator|)
operator|>>
literal|1
argument_list|)
condition|)
name|entropy
operator|->
name|dc_context
index|[
name|ci
index|]
operator|=
literal|0
expr_stmt|;
comment|/* zero diff category */
elseif|else
if|if
condition|(
name|m
operator|>
call|(
name|int
call|)
argument_list|(
operator|(
literal|1L
operator|<<
name|cinfo
operator|->
name|arith_dc_U
index|[
name|tbl
index|]
operator|)
operator|>>
literal|1
argument_list|)
condition|)
name|entropy
operator|->
name|dc_context
index|[
name|ci
index|]
operator|+=
literal|8
expr_stmt|;
comment|/* large diff category */
comment|/* Figure F.9: Encoding the magnitude bit pattern of v */
name|st
operator|+=
literal|14
expr_stmt|;
while|while
condition|(
name|m
operator|>>=
literal|1
condition|)
name|arith_encode
argument_list|(
name|cinfo
argument_list|,
name|st
argument_list|,
operator|(
name|m
operator|&
name|v
operator|)
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_block
begin_comment
comment|/*  * MCU encoding for AC initial scan (either spectral selection,  * or first pass of successive approximation).  */
end_comment
begin_macro
DECL|function|METHODDEF
name|METHODDEF
argument_list|(
argument|boolean
argument_list|)
end_macro
begin_macro
name|encode_mcu_AC_first
argument_list|(
argument|j_compress_ptr cinfo
argument_list|,
argument|JBLOCKROW *MCU_data
argument_list|)
end_macro
begin_block
block|{
name|arith_entropy_ptr
name|entropy
init|=
operator|(
name|arith_entropy_ptr
operator|)
name|cinfo
operator|->
name|entropy
decl_stmt|;
name|JBLOCKROW
name|block
decl_stmt|;
name|unsigned
name|char
modifier|*
name|st
decl_stmt|;
name|int
name|tbl
decl_stmt|,
name|k
decl_stmt|,
name|ke
decl_stmt|;
name|int
name|v
decl_stmt|,
name|v2
decl_stmt|,
name|m
decl_stmt|;
specifier|const
name|int
modifier|*
name|natural_order
decl_stmt|;
comment|/* Emit restart marker if needed */
if|if
condition|(
name|cinfo
operator|->
name|restart_interval
condition|)
block|{
if|if
condition|(
name|entropy
operator|->
name|restarts_to_go
operator|==
literal|0
condition|)
block|{
name|emit_restart
argument_list|(
name|cinfo
argument_list|,
name|entropy
operator|->
name|next_restart_num
argument_list|)
expr_stmt|;
name|entropy
operator|->
name|restarts_to_go
operator|=
name|cinfo
operator|->
name|restart_interval
expr_stmt|;
name|entropy
operator|->
name|next_restart_num
operator|++
expr_stmt|;
name|entropy
operator|->
name|next_restart_num
operator|&=
literal|7
expr_stmt|;
block|}
name|entropy
operator|->
name|restarts_to_go
operator|--
expr_stmt|;
block|}
name|natural_order
operator|=
name|cinfo
operator|->
name|natural_order
expr_stmt|;
comment|/* Encode the MCU data block */
name|block
operator|=
name|MCU_data
index|[
literal|0
index|]
expr_stmt|;
name|tbl
operator|=
name|cinfo
operator|->
name|cur_comp_info
index|[
literal|0
index|]
operator|->
name|ac_tbl_no
expr_stmt|;
comment|/* Sections F.1.4.2& F.1.4.4.2: Encoding of AC coefficients */
comment|/* Establish EOB (end-of-block) index */
for|for
control|(
name|ke
operator|=
name|cinfo
operator|->
name|Se
init|;
name|ke
operator|>
literal|0
condition|;
name|ke
operator|--
control|)
comment|/* We must apply the point transform by Al.  For AC coefficients this      * is an integer division with rounding towards 0.  To do this portably      * in C, we shift after obtaining the absolute value.      */
if|if
condition|(
operator|(
name|v
operator|=
operator|(
operator|*
name|block
operator|)
index|[
name|natural_order
index|[
name|ke
index|]
index|]
operator|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|v
operator|>>=
name|cinfo
operator|->
name|Al
condition|)
break|break;
block|}
else|else
block|{
name|v
operator|=
operator|-
name|v
expr_stmt|;
if|if
condition|(
name|v
operator|>>=
name|cinfo
operator|->
name|Al
condition|)
break|break;
block|}
comment|/* Figure F.5: Encode_AC_Coefficients */
for|for
control|(
name|k
operator|=
name|cinfo
operator|->
name|Ss
init|;
name|k
operator|<=
name|ke
condition|;
name|k
operator|++
control|)
block|{
name|st
operator|=
name|entropy
operator|->
name|ac_stats
index|[
name|tbl
index|]
operator|+
literal|3
operator|*
operator|(
name|k
operator|-
literal|1
operator|)
expr_stmt|;
name|arith_encode
argument_list|(
name|cinfo
argument_list|,
name|st
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* EOB decision */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|v
operator|=
operator|(
operator|*
name|block
operator|)
index|[
name|natural_order
index|[
name|k
index|]
index|]
operator|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|v
operator|>>=
name|cinfo
operator|->
name|Al
condition|)
block|{
name|arith_encode
argument_list|(
name|cinfo
argument_list|,
name|st
operator|+
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|arith_encode
argument_list|(
name|cinfo
argument_list|,
name|entropy
operator|->
name|fixed_bin
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|v
operator|=
operator|-
name|v
expr_stmt|;
if|if
condition|(
name|v
operator|>>=
name|cinfo
operator|->
name|Al
condition|)
block|{
name|arith_encode
argument_list|(
name|cinfo
argument_list|,
name|st
operator|+
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|arith_encode
argument_list|(
name|cinfo
argument_list|,
name|entropy
operator|->
name|fixed_bin
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|arith_encode
argument_list|(
name|cinfo
argument_list|,
name|st
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|st
operator|+=
literal|3
expr_stmt|;
name|k
operator|++
expr_stmt|;
block|}
name|st
operator|+=
literal|2
expr_stmt|;
comment|/* Figure F.8: Encoding the magnitude category of v */
name|m
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|v
operator|-=
literal|1
condition|)
block|{
name|arith_encode
argument_list|(
name|cinfo
argument_list|,
name|st
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|m
operator|=
literal|1
expr_stmt|;
name|v2
operator|=
name|v
expr_stmt|;
if|if
condition|(
name|v2
operator|>>=
literal|1
condition|)
block|{
name|arith_encode
argument_list|(
name|cinfo
argument_list|,
name|st
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|m
operator|<<=
literal|1
expr_stmt|;
name|st
operator|=
name|entropy
operator|->
name|ac_stats
index|[
name|tbl
index|]
operator|+
operator|(
name|k
operator|<=
name|cinfo
operator|->
name|arith_ac_K
index|[
name|tbl
index|]
condition|?
literal|189
else|:
literal|217
operator|)
expr_stmt|;
while|while
condition|(
name|v2
operator|>>=
literal|1
condition|)
block|{
name|arith_encode
argument_list|(
name|cinfo
argument_list|,
name|st
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|m
operator|<<=
literal|1
expr_stmt|;
name|st
operator|+=
literal|1
expr_stmt|;
block|}
block|}
block|}
name|arith_encode
argument_list|(
name|cinfo
argument_list|,
name|st
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Figure F.9: Encoding the magnitude bit pattern of v */
name|st
operator|+=
literal|14
expr_stmt|;
while|while
condition|(
name|m
operator|>>=
literal|1
condition|)
name|arith_encode
argument_list|(
name|cinfo
argument_list|,
name|st
argument_list|,
operator|(
name|m
operator|&
name|v
operator|)
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Encode EOB decision only if k<= cinfo->Se */
if|if
condition|(
name|k
operator|<=
name|cinfo
operator|->
name|Se
condition|)
block|{
name|st
operator|=
name|entropy
operator|->
name|ac_stats
index|[
name|tbl
index|]
operator|+
literal|3
operator|*
operator|(
name|k
operator|-
literal|1
operator|)
expr_stmt|;
name|arith_encode
argument_list|(
name|cinfo
argument_list|,
name|st
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_block
begin_comment
comment|/*  * MCU encoding for DC successive approximation refinement scan.  */
end_comment
begin_macro
DECL|function|METHODDEF
name|METHODDEF
argument_list|(
argument|boolean
argument_list|)
end_macro
begin_macro
name|encode_mcu_DC_refine
argument_list|(
argument|j_compress_ptr cinfo
argument_list|,
argument|JBLOCKROW *MCU_data
argument_list|)
end_macro
begin_block
block|{
name|arith_entropy_ptr
name|entropy
init|=
operator|(
name|arith_entropy_ptr
operator|)
name|cinfo
operator|->
name|entropy
decl_stmt|;
name|unsigned
name|char
modifier|*
name|st
decl_stmt|;
name|int
name|Al
decl_stmt|,
name|blkn
decl_stmt|;
comment|/* Emit restart marker if needed */
if|if
condition|(
name|cinfo
operator|->
name|restart_interval
condition|)
block|{
if|if
condition|(
name|entropy
operator|->
name|restarts_to_go
operator|==
literal|0
condition|)
block|{
name|emit_restart
argument_list|(
name|cinfo
argument_list|,
name|entropy
operator|->
name|next_restart_num
argument_list|)
expr_stmt|;
name|entropy
operator|->
name|restarts_to_go
operator|=
name|cinfo
operator|->
name|restart_interval
expr_stmt|;
name|entropy
operator|->
name|next_restart_num
operator|++
expr_stmt|;
name|entropy
operator|->
name|next_restart_num
operator|&=
literal|7
expr_stmt|;
block|}
name|entropy
operator|->
name|restarts_to_go
operator|--
expr_stmt|;
block|}
name|st
operator|=
name|entropy
operator|->
name|fixed_bin
expr_stmt|;
comment|/* use fixed probability estimation */
name|Al
operator|=
name|cinfo
operator|->
name|Al
expr_stmt|;
comment|/* Encode the MCU data blocks */
for|for
control|(
name|blkn
operator|=
literal|0
init|;
name|blkn
operator|<
name|cinfo
operator|->
name|blocks_in_MCU
condition|;
name|blkn
operator|++
control|)
block|{
comment|/* We simply emit the Al'th bit of the DC coefficient value. */
name|arith_encode
argument_list|(
name|cinfo
argument_list|,
name|st
argument_list|,
operator|(
name|MCU_data
index|[
name|blkn
index|]
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|>>
name|Al
operator|)
operator|&
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_block
begin_comment
comment|/*  * MCU encoding for AC successive approximation refinement scan.  */
end_comment
begin_macro
DECL|function|METHODDEF
name|METHODDEF
argument_list|(
argument|boolean
argument_list|)
end_macro
begin_macro
name|encode_mcu_AC_refine
argument_list|(
argument|j_compress_ptr cinfo
argument_list|,
argument|JBLOCKROW *MCU_data
argument_list|)
end_macro
begin_block
block|{
name|arith_entropy_ptr
name|entropy
init|=
operator|(
name|arith_entropy_ptr
operator|)
name|cinfo
operator|->
name|entropy
decl_stmt|;
name|JBLOCKROW
name|block
decl_stmt|;
name|unsigned
name|char
modifier|*
name|st
decl_stmt|;
name|int
name|tbl
decl_stmt|,
name|k
decl_stmt|,
name|ke
decl_stmt|,
name|kex
decl_stmt|;
name|int
name|v
decl_stmt|;
specifier|const
name|int
modifier|*
name|natural_order
decl_stmt|;
comment|/* Emit restart marker if needed */
if|if
condition|(
name|cinfo
operator|->
name|restart_interval
condition|)
block|{
if|if
condition|(
name|entropy
operator|->
name|restarts_to_go
operator|==
literal|0
condition|)
block|{
name|emit_restart
argument_list|(
name|cinfo
argument_list|,
name|entropy
operator|->
name|next_restart_num
argument_list|)
expr_stmt|;
name|entropy
operator|->
name|restarts_to_go
operator|=
name|cinfo
operator|->
name|restart_interval
expr_stmt|;
name|entropy
operator|->
name|next_restart_num
operator|++
expr_stmt|;
name|entropy
operator|->
name|next_restart_num
operator|&=
literal|7
expr_stmt|;
block|}
name|entropy
operator|->
name|restarts_to_go
operator|--
expr_stmt|;
block|}
name|natural_order
operator|=
name|cinfo
operator|->
name|natural_order
expr_stmt|;
comment|/* Encode the MCU data block */
name|block
operator|=
name|MCU_data
index|[
literal|0
index|]
expr_stmt|;
name|tbl
operator|=
name|cinfo
operator|->
name|cur_comp_info
index|[
literal|0
index|]
operator|->
name|ac_tbl_no
expr_stmt|;
comment|/* Section G.1.3.3: Encoding of AC coefficients */
comment|/* Establish EOB (end-of-block) index */
for|for
control|(
name|ke
operator|=
name|cinfo
operator|->
name|Se
init|;
name|ke
operator|>
literal|0
condition|;
name|ke
operator|--
control|)
comment|/* We must apply the point transform by Al.  For AC coefficients this      * is an integer division with rounding towards 0.  To do this portably      * in C, we shift after obtaining the absolute value.      */
if|if
condition|(
operator|(
name|v
operator|=
operator|(
operator|*
name|block
operator|)
index|[
name|natural_order
index|[
name|ke
index|]
index|]
operator|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|v
operator|>>=
name|cinfo
operator|->
name|Al
condition|)
break|break;
block|}
else|else
block|{
name|v
operator|=
operator|-
name|v
expr_stmt|;
if|if
condition|(
name|v
operator|>>=
name|cinfo
operator|->
name|Al
condition|)
break|break;
block|}
comment|/* Establish EOBx (previous stage end-of-block) index */
for|for
control|(
name|kex
operator|=
name|ke
init|;
name|kex
operator|>
literal|0
condition|;
name|kex
operator|--
control|)
if|if
condition|(
operator|(
name|v
operator|=
operator|(
operator|*
name|block
operator|)
index|[
name|natural_order
index|[
name|kex
index|]
index|]
operator|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|v
operator|>>=
name|cinfo
operator|->
name|Ah
condition|)
break|break;
block|}
else|else
block|{
name|v
operator|=
operator|-
name|v
expr_stmt|;
if|if
condition|(
name|v
operator|>>=
name|cinfo
operator|->
name|Ah
condition|)
break|break;
block|}
comment|/* Figure G.10: Encode_AC_Coefficients_SA */
for|for
control|(
name|k
operator|=
name|cinfo
operator|->
name|Ss
init|;
name|k
operator|<=
name|ke
condition|;
name|k
operator|++
control|)
block|{
name|st
operator|=
name|entropy
operator|->
name|ac_stats
index|[
name|tbl
index|]
operator|+
literal|3
operator|*
operator|(
name|k
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|k
operator|>
name|kex
condition|)
name|arith_encode
argument_list|(
name|cinfo
argument_list|,
name|st
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* EOB decision */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|v
operator|=
operator|(
operator|*
name|block
operator|)
index|[
name|natural_order
index|[
name|k
index|]
index|]
operator|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|v
operator|>>=
name|cinfo
operator|->
name|Al
condition|)
block|{
if|if
condition|(
name|v
operator|>>
literal|1
condition|)
comment|/* previously nonzero coef */
name|arith_encode
argument_list|(
name|cinfo
argument_list|,
name|st
operator|+
literal|2
argument_list|,
operator|(
name|v
operator|&
literal|1
operator|)
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* newly nonzero coef */
name|arith_encode
argument_list|(
name|cinfo
argument_list|,
name|st
operator|+
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|arith_encode
argument_list|(
name|cinfo
argument_list|,
name|entropy
operator|->
name|fixed_bin
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
else|else
block|{
name|v
operator|=
operator|-
name|v
expr_stmt|;
if|if
condition|(
name|v
operator|>>=
name|cinfo
operator|->
name|Al
condition|)
block|{
if|if
condition|(
name|v
operator|>>
literal|1
condition|)
comment|/* previously nonzero coef */
name|arith_encode
argument_list|(
name|cinfo
argument_list|,
name|st
operator|+
literal|2
argument_list|,
operator|(
name|v
operator|&
literal|1
operator|)
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* newly nonzero coef */
name|arith_encode
argument_list|(
name|cinfo
argument_list|,
name|st
operator|+
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|arith_encode
argument_list|(
name|cinfo
argument_list|,
name|entropy
operator|->
name|fixed_bin
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
name|arith_encode
argument_list|(
name|cinfo
argument_list|,
name|st
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|st
operator|+=
literal|3
expr_stmt|;
name|k
operator|++
expr_stmt|;
block|}
block|}
comment|/* Encode EOB decision only if k<= cinfo->Se */
if|if
condition|(
name|k
operator|<=
name|cinfo
operator|->
name|Se
condition|)
block|{
name|st
operator|=
name|entropy
operator|->
name|ac_stats
index|[
name|tbl
index|]
operator|+
literal|3
operator|*
operator|(
name|k
operator|-
literal|1
operator|)
expr_stmt|;
name|arith_encode
argument_list|(
name|cinfo
argument_list|,
name|st
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_block
begin_comment
comment|/*  * Encode and output one MCU's worth of arithmetic-compressed coefficients.  */
end_comment
begin_macro
DECL|function|METHODDEF
name|METHODDEF
argument_list|(
argument|boolean
argument_list|)
end_macro
begin_macro
name|encode_mcu
argument_list|(
argument|j_compress_ptr cinfo
argument_list|,
argument|JBLOCKROW *MCU_data
argument_list|)
end_macro
begin_block
block|{
name|arith_entropy_ptr
name|entropy
init|=
operator|(
name|arith_entropy_ptr
operator|)
name|cinfo
operator|->
name|entropy
decl_stmt|;
name|jpeg_component_info
modifier|*
name|compptr
decl_stmt|;
name|JBLOCKROW
name|block
decl_stmt|;
name|unsigned
name|char
modifier|*
name|st
decl_stmt|;
name|int
name|blkn
decl_stmt|,
name|ci
decl_stmt|,
name|tbl
decl_stmt|,
name|k
decl_stmt|,
name|ke
decl_stmt|;
name|int
name|v
decl_stmt|,
name|v2
decl_stmt|,
name|m
decl_stmt|;
specifier|const
name|int
modifier|*
name|natural_order
decl_stmt|;
comment|/* Emit restart marker if needed */
if|if
condition|(
name|cinfo
operator|->
name|restart_interval
condition|)
block|{
if|if
condition|(
name|entropy
operator|->
name|restarts_to_go
operator|==
literal|0
condition|)
block|{
name|emit_restart
argument_list|(
name|cinfo
argument_list|,
name|entropy
operator|->
name|next_restart_num
argument_list|)
expr_stmt|;
name|entropy
operator|->
name|restarts_to_go
operator|=
name|cinfo
operator|->
name|restart_interval
expr_stmt|;
name|entropy
operator|->
name|next_restart_num
operator|++
expr_stmt|;
name|entropy
operator|->
name|next_restart_num
operator|&=
literal|7
expr_stmt|;
block|}
name|entropy
operator|->
name|restarts_to_go
operator|--
expr_stmt|;
block|}
name|natural_order
operator|=
name|cinfo
operator|->
name|natural_order
expr_stmt|;
comment|/* Encode the MCU data blocks */
for|for
control|(
name|blkn
operator|=
literal|0
init|;
name|blkn
operator|<
name|cinfo
operator|->
name|blocks_in_MCU
condition|;
name|blkn
operator|++
control|)
block|{
name|block
operator|=
name|MCU_data
index|[
name|blkn
index|]
expr_stmt|;
name|ci
operator|=
name|cinfo
operator|->
name|MCU_membership
index|[
name|blkn
index|]
expr_stmt|;
name|compptr
operator|=
name|cinfo
operator|->
name|cur_comp_info
index|[
name|ci
index|]
expr_stmt|;
comment|/* Sections F.1.4.1& F.1.4.4.1: Encoding of DC coefficients */
name|tbl
operator|=
name|compptr
operator|->
name|dc_tbl_no
expr_stmt|;
comment|/* Table F.4: Point to statistics bin S0 for DC coefficient coding */
name|st
operator|=
name|entropy
operator|->
name|dc_stats
index|[
name|tbl
index|]
operator|+
name|entropy
operator|->
name|dc_context
index|[
name|ci
index|]
expr_stmt|;
comment|/* Figure F.4: Encode_DC_DIFF */
if|if
condition|(
operator|(
name|v
operator|=
operator|(
operator|*
name|block
operator|)
index|[
literal|0
index|]
operator|-
name|entropy
operator|->
name|last_dc_val
index|[
name|ci
index|]
operator|)
operator|==
literal|0
condition|)
block|{
name|arith_encode
argument_list|(
name|cinfo
argument_list|,
name|st
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|entropy
operator|->
name|dc_context
index|[
name|ci
index|]
operator|=
literal|0
expr_stmt|;
comment|/* zero diff category */
block|}
else|else
block|{
name|entropy
operator|->
name|last_dc_val
index|[
name|ci
index|]
operator|=
operator|(
operator|*
name|block
operator|)
index|[
literal|0
index|]
expr_stmt|;
name|arith_encode
argument_list|(
name|cinfo
argument_list|,
name|st
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Figure F.6: Encoding nonzero value v */
comment|/* Figure F.7: Encoding the sign of v */
if|if
condition|(
name|v
operator|>
literal|0
condition|)
block|{
name|arith_encode
argument_list|(
name|cinfo
argument_list|,
name|st
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Table F.4: SS = S0 + 1 */
name|st
operator|+=
literal|2
expr_stmt|;
comment|/* Table F.4: SP = S0 + 2 */
name|entropy
operator|->
name|dc_context
index|[
name|ci
index|]
operator|=
literal|4
expr_stmt|;
comment|/* small positive diff category */
block|}
else|else
block|{
name|v
operator|=
operator|-
name|v
expr_stmt|;
name|arith_encode
argument_list|(
name|cinfo
argument_list|,
name|st
operator|+
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Table F.4: SS = S0 + 1 */
name|st
operator|+=
literal|3
expr_stmt|;
comment|/* Table F.4: SN = S0 + 3 */
name|entropy
operator|->
name|dc_context
index|[
name|ci
index|]
operator|=
literal|8
expr_stmt|;
comment|/* small negative diff category */
block|}
comment|/* Figure F.8: Encoding the magnitude category of v */
name|m
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|v
operator|-=
literal|1
condition|)
block|{
name|arith_encode
argument_list|(
name|cinfo
argument_list|,
name|st
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|m
operator|=
literal|1
expr_stmt|;
name|v2
operator|=
name|v
expr_stmt|;
name|st
operator|=
name|entropy
operator|->
name|dc_stats
index|[
name|tbl
index|]
operator|+
literal|20
expr_stmt|;
comment|/* Table F.4: X1 = 20 */
while|while
condition|(
name|v2
operator|>>=
literal|1
condition|)
block|{
name|arith_encode
argument_list|(
name|cinfo
argument_list|,
name|st
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|m
operator|<<=
literal|1
expr_stmt|;
name|st
operator|+=
literal|1
expr_stmt|;
block|}
block|}
name|arith_encode
argument_list|(
name|cinfo
argument_list|,
name|st
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Section F.1.4.4.1.2: Establish dc_context conditioning category */
if|if
condition|(
name|m
operator|<
call|(
name|int
call|)
argument_list|(
operator|(
literal|1L
operator|<<
name|cinfo
operator|->
name|arith_dc_L
index|[
name|tbl
index|]
operator|)
operator|>>
literal|1
argument_list|)
condition|)
name|entropy
operator|->
name|dc_context
index|[
name|ci
index|]
operator|=
literal|0
expr_stmt|;
comment|/* zero diff category */
elseif|else
if|if
condition|(
name|m
operator|>
call|(
name|int
call|)
argument_list|(
operator|(
literal|1L
operator|<<
name|cinfo
operator|->
name|arith_dc_U
index|[
name|tbl
index|]
operator|)
operator|>>
literal|1
argument_list|)
condition|)
name|entropy
operator|->
name|dc_context
index|[
name|ci
index|]
operator|+=
literal|8
expr_stmt|;
comment|/* large diff category */
comment|/* Figure F.9: Encoding the magnitude bit pattern of v */
name|st
operator|+=
literal|14
expr_stmt|;
while|while
condition|(
name|m
operator|>>=
literal|1
condition|)
name|arith_encode
argument_list|(
name|cinfo
argument_list|,
name|st
argument_list|,
operator|(
name|m
operator|&
name|v
operator|)
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Sections F.1.4.2& F.1.4.4.2: Encoding of AC coefficients */
name|tbl
operator|=
name|compptr
operator|->
name|ac_tbl_no
expr_stmt|;
comment|/* Establish EOB (end-of-block) index */
for|for
control|(
name|ke
operator|=
name|cinfo
operator|->
name|lim_Se
init|;
name|ke
operator|>
literal|0
condition|;
name|ke
operator|--
control|)
if|if
condition|(
operator|(
operator|*
name|block
operator|)
index|[
name|natural_order
index|[
name|ke
index|]
index|]
condition|)
break|break;
comment|/* Figure F.5: Encode_AC_Coefficients */
for|for
control|(
name|k
operator|=
literal|1
init|;
name|k
operator|<=
name|ke
condition|;
name|k
operator|++
control|)
block|{
name|st
operator|=
name|entropy
operator|->
name|ac_stats
index|[
name|tbl
index|]
operator|+
literal|3
operator|*
operator|(
name|k
operator|-
literal|1
operator|)
expr_stmt|;
name|arith_encode
argument_list|(
name|cinfo
argument_list|,
name|st
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* EOB decision */
while|while
condition|(
operator|(
name|v
operator|=
operator|(
operator|*
name|block
operator|)
index|[
name|natural_order
index|[
name|k
index|]
index|]
operator|)
operator|==
literal|0
condition|)
block|{
name|arith_encode
argument_list|(
name|cinfo
argument_list|,
name|st
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|st
operator|+=
literal|3
expr_stmt|;
name|k
operator|++
expr_stmt|;
block|}
name|arith_encode
argument_list|(
name|cinfo
argument_list|,
name|st
operator|+
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Figure F.6: Encoding nonzero value v */
comment|/* Figure F.7: Encoding the sign of v */
if|if
condition|(
name|v
operator|>
literal|0
condition|)
block|{
name|arith_encode
argument_list|(
name|cinfo
argument_list|,
name|entropy
operator|->
name|fixed_bin
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|v
operator|=
operator|-
name|v
expr_stmt|;
name|arith_encode
argument_list|(
name|cinfo
argument_list|,
name|entropy
operator|->
name|fixed_bin
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|st
operator|+=
literal|2
expr_stmt|;
comment|/* Figure F.8: Encoding the magnitude category of v */
name|m
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|v
operator|-=
literal|1
condition|)
block|{
name|arith_encode
argument_list|(
name|cinfo
argument_list|,
name|st
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|m
operator|=
literal|1
expr_stmt|;
name|v2
operator|=
name|v
expr_stmt|;
if|if
condition|(
name|v2
operator|>>=
literal|1
condition|)
block|{
name|arith_encode
argument_list|(
name|cinfo
argument_list|,
name|st
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|m
operator|<<=
literal|1
expr_stmt|;
name|st
operator|=
name|entropy
operator|->
name|ac_stats
index|[
name|tbl
index|]
operator|+
operator|(
name|k
operator|<=
name|cinfo
operator|->
name|arith_ac_K
index|[
name|tbl
index|]
condition|?
literal|189
else|:
literal|217
operator|)
expr_stmt|;
while|while
condition|(
name|v2
operator|>>=
literal|1
condition|)
block|{
name|arith_encode
argument_list|(
name|cinfo
argument_list|,
name|st
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|m
operator|<<=
literal|1
expr_stmt|;
name|st
operator|+=
literal|1
expr_stmt|;
block|}
block|}
block|}
name|arith_encode
argument_list|(
name|cinfo
argument_list|,
name|st
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Figure F.9: Encoding the magnitude bit pattern of v */
name|st
operator|+=
literal|14
expr_stmt|;
while|while
condition|(
name|m
operator|>>=
literal|1
condition|)
name|arith_encode
argument_list|(
name|cinfo
argument_list|,
name|st
argument_list|,
operator|(
name|m
operator|&
name|v
operator|)
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Encode EOB decision only if k<= cinfo->lim_Se */
if|if
condition|(
name|k
operator|<=
name|cinfo
operator|->
name|lim_Se
condition|)
block|{
name|st
operator|=
name|entropy
operator|->
name|ac_stats
index|[
name|tbl
index|]
operator|+
literal|3
operator|*
operator|(
name|k
operator|-
literal|1
operator|)
expr_stmt|;
name|arith_encode
argument_list|(
name|cinfo
argument_list|,
name|st
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_block
begin_comment
comment|/*  * Initialize for an arithmetic-compressed scan.  */
end_comment
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|start_pass
name|start_pass
argument_list|(
argument|j_compress_ptr cinfo
argument_list|,
argument|boolean gather_statistics
argument_list|)
end_macro
begin_block
block|{
name|arith_entropy_ptr
name|entropy
init|=
operator|(
name|arith_entropy_ptr
operator|)
name|cinfo
operator|->
name|entropy
decl_stmt|;
name|int
name|ci
decl_stmt|,
name|tbl
decl_stmt|;
name|jpeg_component_info
modifier|*
name|compptr
decl_stmt|;
if|if
condition|(
name|gather_statistics
condition|)
comment|/* Make sure to avoid that in the master control logic!      * We are fully adaptive here and need no extra      * statistics gathering pass!      */
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_NOT_COMPILED
argument_list|)
expr_stmt|;
comment|/* We assume jcmaster.c already validated the progressive scan parameters. */
comment|/* Select execution routines */
if|if
condition|(
name|cinfo
operator|->
name|progressive_mode
condition|)
block|{
if|if
condition|(
name|cinfo
operator|->
name|Ah
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|cinfo
operator|->
name|Ss
operator|==
literal|0
condition|)
name|entropy
operator|->
name|pub
operator|.
name|encode_mcu
operator|=
name|encode_mcu_DC_first
expr_stmt|;
else|else
name|entropy
operator|->
name|pub
operator|.
name|encode_mcu
operator|=
name|encode_mcu_AC_first
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|cinfo
operator|->
name|Ss
operator|==
literal|0
condition|)
name|entropy
operator|->
name|pub
operator|.
name|encode_mcu
operator|=
name|encode_mcu_DC_refine
expr_stmt|;
else|else
name|entropy
operator|->
name|pub
operator|.
name|encode_mcu
operator|=
name|encode_mcu_AC_refine
expr_stmt|;
block|}
block|}
else|else
name|entropy
operator|->
name|pub
operator|.
name|encode_mcu
operator|=
name|encode_mcu
expr_stmt|;
comment|/* Allocate& initialize requested statistics areas */
for|for
control|(
name|ci
operator|=
literal|0
init|;
name|ci
operator|<
name|cinfo
operator|->
name|comps_in_scan
condition|;
name|ci
operator|++
control|)
block|{
name|compptr
operator|=
name|cinfo
operator|->
name|cur_comp_info
index|[
name|ci
index|]
expr_stmt|;
comment|/* DC needs no table for refinement scan */
if|if
condition|(
name|cinfo
operator|->
name|Ss
operator|==
literal|0
operator|&&
name|cinfo
operator|->
name|Ah
operator|==
literal|0
condition|)
block|{
name|tbl
operator|=
name|compptr
operator|->
name|dc_tbl_no
expr_stmt|;
if|if
condition|(
name|tbl
operator|<
literal|0
operator|||
name|tbl
operator|>=
name|NUM_ARITH_TBLS
condition|)
name|ERREXIT1
argument_list|(
name|cinfo
argument_list|,
name|JERR_NO_ARITH_TABLE
argument_list|,
name|tbl
argument_list|)
expr_stmt|;
if|if
condition|(
name|entropy
operator|->
name|dc_stats
index|[
name|tbl
index|]
operator|==
name|NULL
condition|)
name|entropy
operator|->
name|dc_stats
index|[
name|tbl
index|]
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
call|(
modifier|*
name|cinfo
operator|->
name|mem
operator|->
name|alloc_small
call|)
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|,
name|JPOOL_IMAGE
argument_list|,
name|DC_STAT_BINS
argument_list|)
expr_stmt|;
name|MEMZERO
argument_list|(
name|entropy
operator|->
name|dc_stats
index|[
name|tbl
index|]
argument_list|,
name|DC_STAT_BINS
argument_list|)
expr_stmt|;
comment|/* Initialize DC predictions to 0 */
name|entropy
operator|->
name|last_dc_val
index|[
name|ci
index|]
operator|=
literal|0
expr_stmt|;
name|entropy
operator|->
name|dc_context
index|[
name|ci
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* AC needs no table when not present */
if|if
condition|(
name|cinfo
operator|->
name|Se
condition|)
block|{
name|tbl
operator|=
name|compptr
operator|->
name|ac_tbl_no
expr_stmt|;
if|if
condition|(
name|tbl
operator|<
literal|0
operator|||
name|tbl
operator|>=
name|NUM_ARITH_TBLS
condition|)
name|ERREXIT1
argument_list|(
name|cinfo
argument_list|,
name|JERR_NO_ARITH_TABLE
argument_list|,
name|tbl
argument_list|)
expr_stmt|;
if|if
condition|(
name|entropy
operator|->
name|ac_stats
index|[
name|tbl
index|]
operator|==
name|NULL
condition|)
name|entropy
operator|->
name|ac_stats
index|[
name|tbl
index|]
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
call|(
modifier|*
name|cinfo
operator|->
name|mem
operator|->
name|alloc_small
call|)
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|,
name|JPOOL_IMAGE
argument_list|,
name|AC_STAT_BINS
argument_list|)
expr_stmt|;
name|MEMZERO
argument_list|(
name|entropy
operator|->
name|ac_stats
index|[
name|tbl
index|]
argument_list|,
name|AC_STAT_BINS
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CALCULATE_SPECTRAL_CONDITIONING
if|if
condition|(
name|cinfo
operator|->
name|progressive_mode
condition|)
comment|/* Section G.1.3.2: Set appropriate arithmetic conditioning value Kx */
name|cinfo
operator|->
name|arith_ac_K
index|[
name|tbl
index|]
operator|=
name|cinfo
operator|->
name|Ss
operator|+
operator|(
operator|(
literal|8
operator|+
name|cinfo
operator|->
name|Se
operator|-
name|cinfo
operator|->
name|Ss
operator|)
operator|>>
literal|4
operator|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
comment|/* Initialize arithmetic encoding variables */
name|entropy
operator|->
name|c
operator|=
literal|0
expr_stmt|;
name|entropy
operator|->
name|a
operator|=
literal|0x10000L
expr_stmt|;
name|entropy
operator|->
name|sc
operator|=
literal|0
expr_stmt|;
name|entropy
operator|->
name|zc
operator|=
literal|0
expr_stmt|;
name|entropy
operator|->
name|ct
operator|=
literal|11
expr_stmt|;
name|entropy
operator|->
name|buffer
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* empty */
comment|/* Initialize restart stuff */
name|entropy
operator|->
name|restarts_to_go
operator|=
name|cinfo
operator|->
name|restart_interval
expr_stmt|;
name|entropy
operator|->
name|next_restart_num
operator|=
literal|0
expr_stmt|;
block|}
end_block
begin_comment
comment|/*  * Module initialization routine for arithmetic entropy encoding.  */
end_comment
begin_macro
name|GLOBAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|jinit_arith_encoder
name|jinit_arith_encoder
argument_list|(
argument|j_compress_ptr cinfo
argument_list|)
end_macro
begin_block
block|{
name|arith_entropy_ptr
name|entropy
decl_stmt|;
name|int
name|i
decl_stmt|;
name|entropy
operator|=
call|(
name|arith_entropy_ptr
call|)
argument_list|(
operator|*
name|cinfo
operator|->
name|mem
operator|->
name|alloc_small
argument_list|)
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|,
name|JPOOL_IMAGE
argument_list|,
name|SIZEOF
argument_list|(
name|arith_entropy_encoder
argument_list|)
argument_list|)
expr_stmt|;
name|cinfo
operator|->
name|entropy
operator|=
operator|(
expr|struct
name|jpeg_entropy_encoder
operator|*
operator|)
name|entropy
expr_stmt|;
name|entropy
operator|->
name|pub
operator|.
name|start_pass
operator|=
name|start_pass
expr_stmt|;
name|entropy
operator|->
name|pub
operator|.
name|finish_pass
operator|=
name|finish_pass
expr_stmt|;
comment|/* Mark tables unallocated */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_ARITH_TBLS
condition|;
name|i
operator|++
control|)
block|{
name|entropy
operator|->
name|dc_stats
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|entropy
operator|->
name|ac_stats
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Initialize index for fixed probability estimation */
name|entropy
operator|->
name|fixed_bin
index|[
literal|0
index|]
operator|=
literal|113
expr_stmt|;
block|}
end_block
end_unit
