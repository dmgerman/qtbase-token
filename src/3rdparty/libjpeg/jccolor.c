begin_unit
begin_comment
comment|/*  * jccolor.c  *  * Copyright (C) 1991-1996, Thomas G. Lane.  * This file is part of the Independent JPEG Group's software.  * For conditions of distribution and use, see the accompanying README file.  *  * This file contains input colorspace conversion routines.  */
end_comment
begin_define
DECL|macro|JPEG_INTERNALS
define|#
directive|define
name|JPEG_INTERNALS
end_define
begin_include
include|#
directive|include
file|"jinclude.h"
end_include
begin_include
include|#
directive|include
file|"jpeglib.h"
end_include
begin_comment
comment|/* Private subobject */
end_comment
begin_typedef
typedef|typedef
struct|struct
block|{
DECL|member|pub
name|struct
name|jpeg_color_converter
name|pub
decl_stmt|;
comment|/* public fields */
comment|/* Private state for RGB->YCC conversion */
DECL|member|rgb_ycc_tab
name|INT32
modifier|*
name|rgb_ycc_tab
decl_stmt|;
comment|/* => table for RGB to YCbCr conversion */
block|}
DECL|typedef|my_color_converter
name|my_color_converter
typedef|;
end_typedef
begin_typedef
DECL|typedef|my_cconvert_ptr
typedef|typedef
name|my_color_converter
modifier|*
name|my_cconvert_ptr
typedef|;
end_typedef
begin_comment
comment|/**************** RGB -> YCbCr conversion: most common case **************/
end_comment
begin_comment
comment|/*  * YCbCr is defined per CCIR 601-1, except that Cb and Cr are  * normalized to the range 0..MAXJSAMPLE rather than -0.5 .. 0.5.  * The conversion equations to be implemented are therefore  *	Y  =  0.29900 * R + 0.58700 * G + 0.11400 * B  *	Cb = -0.16874 * R - 0.33126 * G + 0.50000 * B  + CENTERJSAMPLE  *	Cr =  0.50000 * R - 0.41869 * G - 0.08131 * B  + CENTERJSAMPLE  * (These numbers are derived from TIFF 6.0 section 21, dated 3-June-92.)  * Note: older versions of the IJG code used a zero offset of MAXJSAMPLE/2,  * rather than CENTERJSAMPLE, for Cb and Cr.  This gave equal positive and  * negative swings for Cb/Cr, but meant that grayscale values (Cb=Cr=0)  * were not represented exactly.  Now we sacrifice exact representation of  * maximum red and maximum blue in order to get exact grayscales.  *  * To avoid floating-point arithmetic, we represent the fractional constants  * as integers scaled up by 2^16 (about 4 digits precision); we have to divide  * the products by 2^16, with appropriate rounding, to get the correct answer.  *  * For even more speed, we avoid doing any multiplications in the inner loop  * by precalculating the constants times R,G,B for all possible values.  * For 8-bit JSAMPLEs this is very reasonable (only 256 entries per table);  * for 12-bit samples it is still acceptable.  It's not very reasonable for  * 16-bit samples, but if you want lossless storage you shouldn't be changing  * colorspace anyway.  * The CENTERJSAMPLE offsets and the rounding fudge-factor of 0.5 are included  * in the tables to save adding them separately in the inner loop.  */
end_comment
begin_define
DECL|macro|SCALEBITS
define|#
directive|define
name|SCALEBITS
value|16
end_define
begin_comment
DECL|macro|SCALEBITS
comment|/* speediest right-shift on some machines */
end_comment
begin_define
DECL|macro|CBCR_OFFSET
define|#
directive|define
name|CBCR_OFFSET
value|((INT32) CENTERJSAMPLE<< SCALEBITS)
end_define
begin_define
DECL|macro|ONE_HALF
define|#
directive|define
name|ONE_HALF
value|((INT32) 1<< (SCALEBITS-1))
end_define
begin_define
DECL|macro|FIX
define|#
directive|define
name|FIX
parameter_list|(
name|x
parameter_list|)
value|((INT32) ((x) * (1L<<SCALEBITS) + 0.5))
end_define
begin_comment
comment|/* We allocate one big table and divide it up into eight parts, instead of  * doing eight alloc_small requests.  This lets us use a single table base  * address, which can be held in a register in the inner loops on many  * machines (more than can hold all eight addresses, anyway).  */
end_comment
begin_define
DECL|macro|R_Y_OFF
define|#
directive|define
name|R_Y_OFF
value|0
end_define
begin_comment
DECL|macro|R_Y_OFF
comment|/* offset to R => Y section */
end_comment
begin_define
DECL|macro|G_Y_OFF
define|#
directive|define
name|G_Y_OFF
value|(1*(MAXJSAMPLE+1))
end_define
begin_comment
DECL|macro|G_Y_OFF
comment|/* offset to G => Y section */
end_comment
begin_define
DECL|macro|B_Y_OFF
define|#
directive|define
name|B_Y_OFF
value|(2*(MAXJSAMPLE+1))
end_define
begin_comment
DECL|macro|B_Y_OFF
comment|/* etc. */
end_comment
begin_define
DECL|macro|R_CB_OFF
define|#
directive|define
name|R_CB_OFF
value|(3*(MAXJSAMPLE+1))
end_define
begin_define
DECL|macro|G_CB_OFF
define|#
directive|define
name|G_CB_OFF
value|(4*(MAXJSAMPLE+1))
end_define
begin_define
DECL|macro|B_CB_OFF
define|#
directive|define
name|B_CB_OFF
value|(5*(MAXJSAMPLE+1))
end_define
begin_define
DECL|macro|R_CR_OFF
define|#
directive|define
name|R_CR_OFF
value|B_CB_OFF
end_define
begin_comment
DECL|macro|R_CR_OFF
comment|/* B=>Cb, R=>Cr are the same */
end_comment
begin_define
DECL|macro|G_CR_OFF
define|#
directive|define
name|G_CR_OFF
value|(6*(MAXJSAMPLE+1))
end_define
begin_define
DECL|macro|B_CR_OFF
define|#
directive|define
name|B_CR_OFF
value|(7*(MAXJSAMPLE+1))
end_define
begin_define
DECL|macro|TABLE_SIZE
define|#
directive|define
name|TABLE_SIZE
value|(8*(MAXJSAMPLE+1))
end_define
begin_comment
comment|/*  * Initialize for RGB->YCC colorspace conversion.  */
end_comment
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|rgb_ycc_start
name|rgb_ycc_start
argument_list|(
argument|j_compress_ptr cinfo
argument_list|)
end_macro
begin_block
block|{
name|my_cconvert_ptr
name|cconvert
init|=
operator|(
name|my_cconvert_ptr
operator|)
name|cinfo
operator|->
name|cconvert
decl_stmt|;
name|INT32
modifier|*
name|rgb_ycc_tab
decl_stmt|;
name|INT32
name|i
decl_stmt|;
comment|/* Allocate and fill in the conversion tables. */
name|cconvert
operator|->
name|rgb_ycc_tab
operator|=
name|rgb_ycc_tab
operator|=
operator|(
name|INT32
operator|*
operator|)
call|(
modifier|*
name|cinfo
operator|->
name|mem
operator|->
name|alloc_small
call|)
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|,
name|JPOOL_IMAGE
argument_list|,
operator|(
name|TABLE_SIZE
operator|*
name|SIZEOF
argument_list|(
name|INT32
argument_list|)
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|MAXJSAMPLE
condition|;
name|i
operator|++
control|)
block|{
name|rgb_ycc_tab
index|[
name|i
operator|+
name|R_Y_OFF
index|]
operator|=
name|FIX
argument_list|(
literal|0.29900
argument_list|)
operator|*
name|i
expr_stmt|;
name|rgb_ycc_tab
index|[
name|i
operator|+
name|G_Y_OFF
index|]
operator|=
name|FIX
argument_list|(
literal|0.58700
argument_list|)
operator|*
name|i
expr_stmt|;
name|rgb_ycc_tab
index|[
name|i
operator|+
name|B_Y_OFF
index|]
operator|=
name|FIX
argument_list|(
literal|0.11400
argument_list|)
operator|*
name|i
operator|+
name|ONE_HALF
expr_stmt|;
name|rgb_ycc_tab
index|[
name|i
operator|+
name|R_CB_OFF
index|]
operator|=
operator|(
operator|-
name|FIX
argument_list|(
literal|0.16874
argument_list|)
operator|)
operator|*
name|i
expr_stmt|;
name|rgb_ycc_tab
index|[
name|i
operator|+
name|G_CB_OFF
index|]
operator|=
operator|(
operator|-
name|FIX
argument_list|(
literal|0.33126
argument_list|)
operator|)
operator|*
name|i
expr_stmt|;
comment|/* We use a rounding fudge-factor of 0.5-epsilon for Cb and Cr.      * This ensures that the maximum output will round to MAXJSAMPLE      * not MAXJSAMPLE+1, and thus that we don't have to range-limit.      */
name|rgb_ycc_tab
index|[
name|i
operator|+
name|B_CB_OFF
index|]
operator|=
name|FIX
argument_list|(
literal|0.50000
argument_list|)
operator|*
name|i
operator|+
name|CBCR_OFFSET
operator|+
name|ONE_HALF
operator|-
literal|1
expr_stmt|;
comment|/*  B=>Cb and R=>Cr tables are the same     rgb_ycc_tab[i+R_CR_OFF] = FIX(0.50000) * i    + CBCR_OFFSET + ONE_HALF-1; */
name|rgb_ycc_tab
index|[
name|i
operator|+
name|G_CR_OFF
index|]
operator|=
operator|(
operator|-
name|FIX
argument_list|(
literal|0.41869
argument_list|)
operator|)
operator|*
name|i
expr_stmt|;
name|rgb_ycc_tab
index|[
name|i
operator|+
name|B_CR_OFF
index|]
operator|=
operator|(
operator|-
name|FIX
argument_list|(
literal|0.08131
argument_list|)
operator|)
operator|*
name|i
expr_stmt|;
block|}
block|}
end_block
begin_comment
comment|/*  * Convert some rows of samples to the JPEG colorspace.  *  * Note that we change from the application's interleaved-pixel format  * to our internal noninterleaved, one-plane-per-component format.  * The input buffer is therefore three times as wide as the output buffer.  *  * A starting row offset is provided only for the output buffer.  The caller  * can easily adjust the passed input_buf value to accommodate any row  * offset required on that side.  */
end_comment
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|rgb_ycc_convert
name|rgb_ycc_convert
argument_list|(
argument|j_compress_ptr cinfo
argument_list|,
argument|JSAMPARRAY input_buf
argument_list|,
argument|JSAMPIMAGE output_buf
argument_list|,
argument|JDIMENSION output_row
argument_list|,
argument|int num_rows
argument_list|)
end_macro
begin_block
block|{
name|my_cconvert_ptr
name|cconvert
init|=
operator|(
name|my_cconvert_ptr
operator|)
name|cinfo
operator|->
name|cconvert
decl_stmt|;
specifier|register
name|int
name|r
decl_stmt|,
name|g
decl_stmt|,
name|b
decl_stmt|;
specifier|register
name|INT32
modifier|*
name|ctab
init|=
name|cconvert
operator|->
name|rgb_ycc_tab
decl_stmt|;
specifier|register
name|JSAMPROW
name|inptr
decl_stmt|;
specifier|register
name|JSAMPROW
name|outptr0
decl_stmt|,
name|outptr1
decl_stmt|,
name|outptr2
decl_stmt|;
specifier|register
name|JDIMENSION
name|col
decl_stmt|;
name|JDIMENSION
name|num_cols
init|=
name|cinfo
operator|->
name|image_width
decl_stmt|;
while|while
condition|(
operator|--
name|num_rows
operator|>=
literal|0
condition|)
block|{
name|inptr
operator|=
operator|*
name|input_buf
operator|++
expr_stmt|;
name|outptr0
operator|=
name|output_buf
index|[
literal|0
index|]
index|[
name|output_row
index|]
expr_stmt|;
name|outptr1
operator|=
name|output_buf
index|[
literal|1
index|]
index|[
name|output_row
index|]
expr_stmt|;
name|outptr2
operator|=
name|output_buf
index|[
literal|2
index|]
index|[
name|output_row
index|]
expr_stmt|;
name|output_row
operator|++
expr_stmt|;
for|for
control|(
name|col
operator|=
literal|0
init|;
name|col
operator|<
name|num_cols
condition|;
name|col
operator|++
control|)
block|{
name|r
operator|=
name|GETJSAMPLE
argument_list|(
name|inptr
index|[
name|RGB_RED
index|]
argument_list|)
expr_stmt|;
name|g
operator|=
name|GETJSAMPLE
argument_list|(
name|inptr
index|[
name|RGB_GREEN
index|]
argument_list|)
expr_stmt|;
name|b
operator|=
name|GETJSAMPLE
argument_list|(
name|inptr
index|[
name|RGB_BLUE
index|]
argument_list|)
expr_stmt|;
name|inptr
operator|+=
name|RGB_PIXELSIZE
expr_stmt|;
comment|/* If the inputs are 0..MAXJSAMPLE, the outputs of these equations        * must be too; we do not need an explicit range-limiting operation.        * Hence the value being shifted is never negative, and we don't        * need the general RIGHT_SHIFT macro.        */
comment|/* Y */
name|outptr0
index|[
name|col
index|]
operator|=
call|(
name|JSAMPLE
call|)
argument_list|(
operator|(
name|ctab
index|[
name|r
operator|+
name|R_Y_OFF
index|]
operator|+
name|ctab
index|[
name|g
operator|+
name|G_Y_OFF
index|]
operator|+
name|ctab
index|[
name|b
operator|+
name|B_Y_OFF
index|]
operator|)
operator|>>
name|SCALEBITS
argument_list|)
expr_stmt|;
comment|/* Cb */
name|outptr1
index|[
name|col
index|]
operator|=
call|(
name|JSAMPLE
call|)
argument_list|(
operator|(
name|ctab
index|[
name|r
operator|+
name|R_CB_OFF
index|]
operator|+
name|ctab
index|[
name|g
operator|+
name|G_CB_OFF
index|]
operator|+
name|ctab
index|[
name|b
operator|+
name|B_CB_OFF
index|]
operator|)
operator|>>
name|SCALEBITS
argument_list|)
expr_stmt|;
comment|/* Cr */
name|outptr2
index|[
name|col
index|]
operator|=
call|(
name|JSAMPLE
call|)
argument_list|(
operator|(
name|ctab
index|[
name|r
operator|+
name|R_CR_OFF
index|]
operator|+
name|ctab
index|[
name|g
operator|+
name|G_CR_OFF
index|]
operator|+
name|ctab
index|[
name|b
operator|+
name|B_CR_OFF
index|]
operator|)
operator|>>
name|SCALEBITS
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block
begin_comment
comment|/**************** Cases other than RGB -> YCbCr **************/
end_comment
begin_comment
comment|/*  * Convert some rows of samples to the JPEG colorspace.  * This version handles RGB->grayscale conversion, which is the same  * as the RGB->Y portion of RGB->YCbCr.  * We assume rgb_ycc_start has been called (we only use the Y tables).  */
end_comment
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|rgb_gray_convert
name|rgb_gray_convert
argument_list|(
argument|j_compress_ptr cinfo
argument_list|,
argument|JSAMPARRAY input_buf
argument_list|,
argument|JSAMPIMAGE output_buf
argument_list|,
argument|JDIMENSION output_row
argument_list|,
argument|int num_rows
argument_list|)
end_macro
begin_block
block|{
name|my_cconvert_ptr
name|cconvert
init|=
operator|(
name|my_cconvert_ptr
operator|)
name|cinfo
operator|->
name|cconvert
decl_stmt|;
specifier|register
name|int
name|r
decl_stmt|,
name|g
decl_stmt|,
name|b
decl_stmt|;
specifier|register
name|INT32
modifier|*
name|ctab
init|=
name|cconvert
operator|->
name|rgb_ycc_tab
decl_stmt|;
specifier|register
name|JSAMPROW
name|inptr
decl_stmt|;
specifier|register
name|JSAMPROW
name|outptr
decl_stmt|;
specifier|register
name|JDIMENSION
name|col
decl_stmt|;
name|JDIMENSION
name|num_cols
init|=
name|cinfo
operator|->
name|image_width
decl_stmt|;
while|while
condition|(
operator|--
name|num_rows
operator|>=
literal|0
condition|)
block|{
name|inptr
operator|=
operator|*
name|input_buf
operator|++
expr_stmt|;
name|outptr
operator|=
name|output_buf
index|[
literal|0
index|]
index|[
name|output_row
index|]
expr_stmt|;
name|output_row
operator|++
expr_stmt|;
for|for
control|(
name|col
operator|=
literal|0
init|;
name|col
operator|<
name|num_cols
condition|;
name|col
operator|++
control|)
block|{
name|r
operator|=
name|GETJSAMPLE
argument_list|(
name|inptr
index|[
name|RGB_RED
index|]
argument_list|)
expr_stmt|;
name|g
operator|=
name|GETJSAMPLE
argument_list|(
name|inptr
index|[
name|RGB_GREEN
index|]
argument_list|)
expr_stmt|;
name|b
operator|=
name|GETJSAMPLE
argument_list|(
name|inptr
index|[
name|RGB_BLUE
index|]
argument_list|)
expr_stmt|;
name|inptr
operator|+=
name|RGB_PIXELSIZE
expr_stmt|;
comment|/* Y */
name|outptr
index|[
name|col
index|]
operator|=
call|(
name|JSAMPLE
call|)
argument_list|(
operator|(
name|ctab
index|[
name|r
operator|+
name|R_Y_OFF
index|]
operator|+
name|ctab
index|[
name|g
operator|+
name|G_Y_OFF
index|]
operator|+
name|ctab
index|[
name|b
operator|+
name|B_Y_OFF
index|]
operator|)
operator|>>
name|SCALEBITS
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block
begin_comment
comment|/*  * Convert some rows of samples to the JPEG colorspace.  * This version handles Adobe-style CMYK->YCCK conversion,  * where we convert R=1-C, G=1-M, and B=1-Y to YCbCr using the same  * conversion as above, while passing K (black) unchanged.  * We assume rgb_ycc_start has been called.  */
end_comment
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|cmyk_ycck_convert
name|cmyk_ycck_convert
argument_list|(
argument|j_compress_ptr cinfo
argument_list|,
argument|JSAMPARRAY input_buf
argument_list|,
argument|JSAMPIMAGE output_buf
argument_list|,
argument|JDIMENSION output_row
argument_list|,
argument|int num_rows
argument_list|)
end_macro
begin_block
block|{
name|my_cconvert_ptr
name|cconvert
init|=
operator|(
name|my_cconvert_ptr
operator|)
name|cinfo
operator|->
name|cconvert
decl_stmt|;
specifier|register
name|int
name|r
decl_stmt|,
name|g
decl_stmt|,
name|b
decl_stmt|;
specifier|register
name|INT32
modifier|*
name|ctab
init|=
name|cconvert
operator|->
name|rgb_ycc_tab
decl_stmt|;
specifier|register
name|JSAMPROW
name|inptr
decl_stmt|;
specifier|register
name|JSAMPROW
name|outptr0
decl_stmt|,
name|outptr1
decl_stmt|,
name|outptr2
decl_stmt|,
name|outptr3
decl_stmt|;
specifier|register
name|JDIMENSION
name|col
decl_stmt|;
name|JDIMENSION
name|num_cols
init|=
name|cinfo
operator|->
name|image_width
decl_stmt|;
while|while
condition|(
operator|--
name|num_rows
operator|>=
literal|0
condition|)
block|{
name|inptr
operator|=
operator|*
name|input_buf
operator|++
expr_stmt|;
name|outptr0
operator|=
name|output_buf
index|[
literal|0
index|]
index|[
name|output_row
index|]
expr_stmt|;
name|outptr1
operator|=
name|output_buf
index|[
literal|1
index|]
index|[
name|output_row
index|]
expr_stmt|;
name|outptr2
operator|=
name|output_buf
index|[
literal|2
index|]
index|[
name|output_row
index|]
expr_stmt|;
name|outptr3
operator|=
name|output_buf
index|[
literal|3
index|]
index|[
name|output_row
index|]
expr_stmt|;
name|output_row
operator|++
expr_stmt|;
for|for
control|(
name|col
operator|=
literal|0
init|;
name|col
operator|<
name|num_cols
condition|;
name|col
operator|++
control|)
block|{
name|r
operator|=
name|MAXJSAMPLE
operator|-
name|GETJSAMPLE
argument_list|(
name|inptr
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|g
operator|=
name|MAXJSAMPLE
operator|-
name|GETJSAMPLE
argument_list|(
name|inptr
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|b
operator|=
name|MAXJSAMPLE
operator|-
name|GETJSAMPLE
argument_list|(
name|inptr
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* K passes through as-is */
name|outptr3
index|[
name|col
index|]
operator|=
name|inptr
index|[
literal|3
index|]
expr_stmt|;
comment|/* don't need GETJSAMPLE here */
name|inptr
operator|+=
literal|4
expr_stmt|;
comment|/* If the inputs are 0..MAXJSAMPLE, the outputs of these equations        * must be too; we do not need an explicit range-limiting operation.        * Hence the value being shifted is never negative, and we don't        * need the general RIGHT_SHIFT macro.        */
comment|/* Y */
name|outptr0
index|[
name|col
index|]
operator|=
call|(
name|JSAMPLE
call|)
argument_list|(
operator|(
name|ctab
index|[
name|r
operator|+
name|R_Y_OFF
index|]
operator|+
name|ctab
index|[
name|g
operator|+
name|G_Y_OFF
index|]
operator|+
name|ctab
index|[
name|b
operator|+
name|B_Y_OFF
index|]
operator|)
operator|>>
name|SCALEBITS
argument_list|)
expr_stmt|;
comment|/* Cb */
name|outptr1
index|[
name|col
index|]
operator|=
call|(
name|JSAMPLE
call|)
argument_list|(
operator|(
name|ctab
index|[
name|r
operator|+
name|R_CB_OFF
index|]
operator|+
name|ctab
index|[
name|g
operator|+
name|G_CB_OFF
index|]
operator|+
name|ctab
index|[
name|b
operator|+
name|B_CB_OFF
index|]
operator|)
operator|>>
name|SCALEBITS
argument_list|)
expr_stmt|;
comment|/* Cr */
name|outptr2
index|[
name|col
index|]
operator|=
call|(
name|JSAMPLE
call|)
argument_list|(
operator|(
name|ctab
index|[
name|r
operator|+
name|R_CR_OFF
index|]
operator|+
name|ctab
index|[
name|g
operator|+
name|G_CR_OFF
index|]
operator|+
name|ctab
index|[
name|b
operator|+
name|B_CR_OFF
index|]
operator|)
operator|>>
name|SCALEBITS
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block
begin_comment
comment|/*  * Convert some rows of samples to the JPEG colorspace.  * This version handles grayscale output with no conversion.  * The source can be either plain grayscale or YCbCr (since Y == gray).  */
end_comment
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|grayscale_convert
name|grayscale_convert
argument_list|(
argument|j_compress_ptr cinfo
argument_list|,
argument|JSAMPARRAY input_buf
argument_list|,
argument|JSAMPIMAGE output_buf
argument_list|,
argument|JDIMENSION output_row
argument_list|,
argument|int num_rows
argument_list|)
end_macro
begin_block
block|{
specifier|register
name|JSAMPROW
name|inptr
decl_stmt|;
specifier|register
name|JSAMPROW
name|outptr
decl_stmt|;
specifier|register
name|JDIMENSION
name|col
decl_stmt|;
name|JDIMENSION
name|num_cols
init|=
name|cinfo
operator|->
name|image_width
decl_stmt|;
name|int
name|instride
init|=
name|cinfo
operator|->
name|input_components
decl_stmt|;
while|while
condition|(
operator|--
name|num_rows
operator|>=
literal|0
condition|)
block|{
name|inptr
operator|=
operator|*
name|input_buf
operator|++
expr_stmt|;
name|outptr
operator|=
name|output_buf
index|[
literal|0
index|]
index|[
name|output_row
index|]
expr_stmt|;
name|output_row
operator|++
expr_stmt|;
for|for
control|(
name|col
operator|=
literal|0
init|;
name|col
operator|<
name|num_cols
condition|;
name|col
operator|++
control|)
block|{
name|outptr
index|[
name|col
index|]
operator|=
name|inptr
index|[
literal|0
index|]
expr_stmt|;
comment|/* don't need GETJSAMPLE() here */
name|inptr
operator|+=
name|instride
expr_stmt|;
block|}
block|}
block|}
end_block
begin_comment
comment|/*  * Convert some rows of samples to the JPEG colorspace.  * This version handles multi-component colorspaces without conversion.  * We assume input_components == num_components.  */
end_comment
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|null_convert
name|null_convert
argument_list|(
argument|j_compress_ptr cinfo
argument_list|,
argument|JSAMPARRAY input_buf
argument_list|,
argument|JSAMPIMAGE output_buf
argument_list|,
argument|JDIMENSION output_row
argument_list|,
argument|int num_rows
argument_list|)
end_macro
begin_block
block|{
specifier|register
name|JSAMPROW
name|inptr
decl_stmt|;
specifier|register
name|JSAMPROW
name|outptr
decl_stmt|;
specifier|register
name|JDIMENSION
name|col
decl_stmt|;
specifier|register
name|int
name|ci
decl_stmt|;
name|int
name|nc
init|=
name|cinfo
operator|->
name|num_components
decl_stmt|;
name|JDIMENSION
name|num_cols
init|=
name|cinfo
operator|->
name|image_width
decl_stmt|;
while|while
condition|(
operator|--
name|num_rows
operator|>=
literal|0
condition|)
block|{
comment|/* It seems fastest to make a separate pass for each component. */
for|for
control|(
name|ci
operator|=
literal|0
init|;
name|ci
operator|<
name|nc
condition|;
name|ci
operator|++
control|)
block|{
name|inptr
operator|=
operator|*
name|input_buf
expr_stmt|;
name|outptr
operator|=
name|output_buf
index|[
name|ci
index|]
index|[
name|output_row
index|]
expr_stmt|;
for|for
control|(
name|col
operator|=
literal|0
init|;
name|col
operator|<
name|num_cols
condition|;
name|col
operator|++
control|)
block|{
name|outptr
index|[
name|col
index|]
operator|=
name|inptr
index|[
name|ci
index|]
expr_stmt|;
comment|/* don't need GETJSAMPLE() here */
name|inptr
operator|+=
name|nc
expr_stmt|;
block|}
block|}
name|input_buf
operator|++
expr_stmt|;
name|output_row
operator|++
expr_stmt|;
block|}
block|}
end_block
begin_comment
comment|/*  * Empty method for start_pass.  */
end_comment
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|null_method
name|null_method
argument_list|(
argument|j_compress_ptr cinfo
argument_list|)
end_macro
begin_block
block|{
comment|/* no work needed */
block|}
end_block
begin_comment
comment|/*  * Module initialization routine for input colorspace conversion.  */
end_comment
begin_macro
name|GLOBAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|jinit_color_converter
name|jinit_color_converter
argument_list|(
argument|j_compress_ptr cinfo
argument_list|)
end_macro
begin_block
block|{
name|my_cconvert_ptr
name|cconvert
decl_stmt|;
name|cconvert
operator|=
call|(
name|my_cconvert_ptr
call|)
argument_list|(
operator|*
name|cinfo
operator|->
name|mem
operator|->
name|alloc_small
argument_list|)
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|,
name|JPOOL_IMAGE
argument_list|,
name|SIZEOF
argument_list|(
name|my_color_converter
argument_list|)
argument_list|)
expr_stmt|;
name|cinfo
operator|->
name|cconvert
operator|=
operator|(
expr|struct
name|jpeg_color_converter
operator|*
operator|)
name|cconvert
expr_stmt|;
comment|/* set start_pass to null method until we find out differently */
name|cconvert
operator|->
name|pub
operator|.
name|start_pass
operator|=
name|null_method
expr_stmt|;
comment|/* Make sure input_components agrees with in_color_space */
switch|switch
condition|(
name|cinfo
operator|->
name|in_color_space
condition|)
block|{
case|case
name|JCS_GRAYSCALE
case|:
if|if
condition|(
name|cinfo
operator|->
name|input_components
operator|!=
literal|1
condition|)
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_IN_COLORSPACE
argument_list|)
expr_stmt|;
break|break;
case|case
name|JCS_RGB
case|:
if|#
directive|if
name|RGB_PIXELSIZE
operator|!=
literal|3
if|if
condition|(
name|cinfo
operator|->
name|input_components
operator|!=
name|RGB_PIXELSIZE
condition|)
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_IN_COLORSPACE
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* else share code with YCbCr */
case|case
name|JCS_YCbCr
case|:
if|if
condition|(
name|cinfo
operator|->
name|input_components
operator|!=
literal|3
condition|)
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_IN_COLORSPACE
argument_list|)
expr_stmt|;
break|break;
case|case
name|JCS_CMYK
case|:
case|case
name|JCS_YCCK
case|:
if|if
condition|(
name|cinfo
operator|->
name|input_components
operator|!=
literal|4
condition|)
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_IN_COLORSPACE
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* JCS_UNKNOWN can be anything */
if|if
condition|(
name|cinfo
operator|->
name|input_components
operator|<
literal|1
condition|)
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_IN_COLORSPACE
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Check num_components, set conversion method based on requested space */
switch|switch
condition|(
name|cinfo
operator|->
name|jpeg_color_space
condition|)
block|{
case|case
name|JCS_GRAYSCALE
case|:
if|if
condition|(
name|cinfo
operator|->
name|num_components
operator|!=
literal|1
condition|)
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_J_COLORSPACE
argument_list|)
expr_stmt|;
if|if
condition|(
name|cinfo
operator|->
name|in_color_space
operator|==
name|JCS_GRAYSCALE
condition|)
name|cconvert
operator|->
name|pub
operator|.
name|color_convert
operator|=
name|grayscale_convert
expr_stmt|;
elseif|else
if|if
condition|(
name|cinfo
operator|->
name|in_color_space
operator|==
name|JCS_RGB
condition|)
block|{
name|cconvert
operator|->
name|pub
operator|.
name|start_pass
operator|=
name|rgb_ycc_start
expr_stmt|;
name|cconvert
operator|->
name|pub
operator|.
name|color_convert
operator|=
name|rgb_gray_convert
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cinfo
operator|->
name|in_color_space
operator|==
name|JCS_YCbCr
condition|)
name|cconvert
operator|->
name|pub
operator|.
name|color_convert
operator|=
name|grayscale_convert
expr_stmt|;
else|else
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_CONVERSION_NOTIMPL
argument_list|)
expr_stmt|;
break|break;
case|case
name|JCS_RGB
case|:
if|if
condition|(
name|cinfo
operator|->
name|num_components
operator|!=
literal|3
condition|)
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_J_COLORSPACE
argument_list|)
expr_stmt|;
if|if
condition|(
name|cinfo
operator|->
name|in_color_space
operator|==
name|JCS_RGB
operator|&&
name|RGB_PIXELSIZE
operator|==
literal|3
condition|)
name|cconvert
operator|->
name|pub
operator|.
name|color_convert
operator|=
name|null_convert
expr_stmt|;
else|else
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_CONVERSION_NOTIMPL
argument_list|)
expr_stmt|;
break|break;
case|case
name|JCS_YCbCr
case|:
if|if
condition|(
name|cinfo
operator|->
name|num_components
operator|!=
literal|3
condition|)
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_J_COLORSPACE
argument_list|)
expr_stmt|;
if|if
condition|(
name|cinfo
operator|->
name|in_color_space
operator|==
name|JCS_RGB
condition|)
block|{
name|cconvert
operator|->
name|pub
operator|.
name|start_pass
operator|=
name|rgb_ycc_start
expr_stmt|;
name|cconvert
operator|->
name|pub
operator|.
name|color_convert
operator|=
name|rgb_ycc_convert
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cinfo
operator|->
name|in_color_space
operator|==
name|JCS_YCbCr
condition|)
name|cconvert
operator|->
name|pub
operator|.
name|color_convert
operator|=
name|null_convert
expr_stmt|;
else|else
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_CONVERSION_NOTIMPL
argument_list|)
expr_stmt|;
break|break;
case|case
name|JCS_CMYK
case|:
if|if
condition|(
name|cinfo
operator|->
name|num_components
operator|!=
literal|4
condition|)
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_J_COLORSPACE
argument_list|)
expr_stmt|;
if|if
condition|(
name|cinfo
operator|->
name|in_color_space
operator|==
name|JCS_CMYK
condition|)
name|cconvert
operator|->
name|pub
operator|.
name|color_convert
operator|=
name|null_convert
expr_stmt|;
else|else
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_CONVERSION_NOTIMPL
argument_list|)
expr_stmt|;
break|break;
case|case
name|JCS_YCCK
case|:
if|if
condition|(
name|cinfo
operator|->
name|num_components
operator|!=
literal|4
condition|)
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_J_COLORSPACE
argument_list|)
expr_stmt|;
if|if
condition|(
name|cinfo
operator|->
name|in_color_space
operator|==
name|JCS_CMYK
condition|)
block|{
name|cconvert
operator|->
name|pub
operator|.
name|start_pass
operator|=
name|rgb_ycc_start
expr_stmt|;
name|cconvert
operator|->
name|pub
operator|.
name|color_convert
operator|=
name|cmyk_ycck_convert
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cinfo
operator|->
name|in_color_space
operator|==
name|JCS_YCCK
condition|)
name|cconvert
operator|->
name|pub
operator|.
name|color_convert
operator|=
name|null_convert
expr_stmt|;
else|else
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_CONVERSION_NOTIMPL
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* allow null conversion of JCS_UNKNOWN */
if|if
condition|(
name|cinfo
operator|->
name|jpeg_color_space
operator|!=
name|cinfo
operator|->
name|in_color_space
operator|||
name|cinfo
operator|->
name|num_components
operator|!=
name|cinfo
operator|->
name|input_components
condition|)
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_CONVERSION_NOTIMPL
argument_list|)
expr_stmt|;
name|cconvert
operator|->
name|pub
operator|.
name|color_convert
operator|=
name|null_convert
expr_stmt|;
break|break;
block|}
block|}
end_block
end_unit
