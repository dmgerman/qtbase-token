begin_unit
begin_comment
comment|/*  * jdapimin.c  *  * Copyright (C) 1994-1998, Thomas G. Lane.  * Modified 2009 by Guido Vollbeding.  * This file is part of the Independent JPEG Group's software.  * For conditions of distribution and use, see the accompanying README file.  *  * This file contains application interface code for the decompression half  * of the JPEG library.  These are the "minimum" API routines that may be  * needed in either the normal full-decompression case or the  * transcoding-only case.  *  * Most of the routines intended to be called directly by an application  * are in this file or in jdapistd.c.  But also see jcomapi.c for routines  * shared by compression and decompression, and jdtrans.c for the transcoding  * case.  */
end_comment
begin_define
DECL|macro|JPEG_INTERNALS
define|#
directive|define
name|JPEG_INTERNALS
end_define
begin_include
include|#
directive|include
file|"jinclude.h"
end_include
begin_include
include|#
directive|include
file|"jpeglib.h"
end_include
begin_comment
comment|/*  * Initialization of a JPEG decompression object.  * The error manager must already be set up (in case memory manager fails).  */
end_comment
begin_macro
name|GLOBAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|jpeg_CreateDecompress
name|jpeg_CreateDecompress
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|,
argument|int version
argument_list|,
argument|size_t structsize
argument_list|)
end_macro
begin_block
block|{
name|int
name|i
decl_stmt|;
comment|/* Guard against version mismatches between library and caller. */
name|cinfo
operator|->
name|mem
operator|=
name|NULL
expr_stmt|;
comment|/* so jpeg_destroy knows mem mgr not called */
if|if
condition|(
name|version
operator|!=
name|JPEG_LIB_VERSION
condition|)
name|ERREXIT2
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_LIB_VERSION
argument_list|,
name|JPEG_LIB_VERSION
argument_list|,
name|version
argument_list|)
expr_stmt|;
if|if
condition|(
name|structsize
operator|!=
name|SIZEOF
argument_list|(
expr|struct
name|jpeg_decompress_struct
argument_list|)
condition|)
name|ERREXIT2
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_STRUCT_SIZE
argument_list|,
operator|(
name|int
operator|)
name|SIZEOF
argument_list|(
expr|struct
name|jpeg_decompress_struct
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|structsize
argument_list|)
expr_stmt|;
comment|/* For debugging purposes, we zero the whole master structure.    * But the application has already set the err pointer, and may have set    * client_data, so we have to save and restore those fields.    * Note: if application hasn't set client_data, tools like Purify may    * complain here.    */
block|{
name|struct
name|jpeg_error_mgr
modifier|*
name|err
init|=
name|cinfo
operator|->
name|err
decl_stmt|;
name|void
modifier|*
name|client_data
init|=
name|cinfo
operator|->
name|client_data
decl_stmt|;
comment|/* ignore Purify complaint here */
name|MEMZERO
argument_list|(
name|cinfo
argument_list|,
name|SIZEOF
argument_list|(
expr|struct
name|jpeg_decompress_struct
argument_list|)
argument_list|)
expr_stmt|;
name|cinfo
operator|->
name|err
operator|=
name|err
expr_stmt|;
name|cinfo
operator|->
name|client_data
operator|=
name|client_data
expr_stmt|;
block|}
name|cinfo
operator|->
name|is_decompressor
operator|=
name|TRUE
expr_stmt|;
comment|/* Initialize a memory manager instance for this object */
name|jinit_memory_mgr
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|)
expr_stmt|;
comment|/* Zero out pointers to permanent structures. */
name|cinfo
operator|->
name|progress
operator|=
name|NULL
expr_stmt|;
name|cinfo
operator|->
name|src
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_QUANT_TBLS
condition|;
name|i
operator|++
control|)
name|cinfo
operator|->
name|quant_tbl_ptrs
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_HUFF_TBLS
condition|;
name|i
operator|++
control|)
block|{
name|cinfo
operator|->
name|dc_huff_tbl_ptrs
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|cinfo
operator|->
name|ac_huff_tbl_ptrs
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Initialize marker processor so application can override methods    * for COM, APPn markers before calling jpeg_read_header.    */
name|cinfo
operator|->
name|marker_list
operator|=
name|NULL
expr_stmt|;
name|jinit_marker_reader
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
comment|/* And initialize the overall input controller. */
name|jinit_input_controller
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
comment|/* OK, I'm ready */
name|cinfo
operator|->
name|global_state
operator|=
name|DSTATE_START
expr_stmt|;
block|}
end_block
begin_comment
comment|/*  * Destruction of a JPEG decompression object  */
end_comment
begin_macro
name|GLOBAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|jpeg_destroy_decompress
name|jpeg_destroy_decompress
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|)
end_macro
begin_block
block|{
name|jpeg_destroy
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|)
expr_stmt|;
comment|/* use common routine */
block|}
end_block
begin_comment
comment|/*  * Abort processing of a JPEG decompression operation,  * but don't destroy the object itself.  */
end_comment
begin_macro
name|GLOBAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|jpeg_abort_decompress
name|jpeg_abort_decompress
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|)
end_macro
begin_block
block|{
name|jpeg_abort
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|)
expr_stmt|;
comment|/* use common routine */
block|}
end_block
begin_comment
comment|/*  * Set default decompression parameters.  */
end_comment
begin_macro
name|LOCAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|default_decompress_parms
name|default_decompress_parms
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|)
end_macro
begin_block
block|{
comment|/* Guess the input colorspace, and set output colorspace accordingly. */
comment|/* (Wish JPEG committee had provided a real way to specify this...) */
comment|/* Note application may override our guesses. */
switch|switch
condition|(
name|cinfo
operator|->
name|num_components
condition|)
block|{
case|case
literal|1
case|:
name|cinfo
operator|->
name|jpeg_color_space
operator|=
name|JCS_GRAYSCALE
expr_stmt|;
name|cinfo
operator|->
name|out_color_space
operator|=
name|JCS_GRAYSCALE
expr_stmt|;
break|break;
case|case
literal|3
case|:
if|if
condition|(
name|cinfo
operator|->
name|saw_JFIF_marker
condition|)
block|{
name|cinfo
operator|->
name|jpeg_color_space
operator|=
name|JCS_YCbCr
expr_stmt|;
comment|/* JFIF implies YCbCr */
block|}
elseif|else
if|if
condition|(
name|cinfo
operator|->
name|saw_Adobe_marker
condition|)
block|{
switch|switch
condition|(
name|cinfo
operator|->
name|Adobe_transform
condition|)
block|{
case|case
literal|0
case|:
name|cinfo
operator|->
name|jpeg_color_space
operator|=
name|JCS_RGB
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|cinfo
operator|->
name|jpeg_color_space
operator|=
name|JCS_YCbCr
expr_stmt|;
break|break;
default|default:
name|WARNMS1
argument_list|(
name|cinfo
argument_list|,
name|JWRN_ADOBE_XFORM
argument_list|,
name|cinfo
operator|->
name|Adobe_transform
argument_list|)
expr_stmt|;
name|cinfo
operator|->
name|jpeg_color_space
operator|=
name|JCS_YCbCr
expr_stmt|;
comment|/* assume it's YCbCr */
break|break;
block|}
block|}
else|else
block|{
comment|/* Saw no special markers, try to guess from the component IDs */
name|int
name|cid0
init|=
name|cinfo
operator|->
name|comp_info
index|[
literal|0
index|]
operator|.
name|component_id
decl_stmt|;
name|int
name|cid1
init|=
name|cinfo
operator|->
name|comp_info
index|[
literal|1
index|]
operator|.
name|component_id
decl_stmt|;
name|int
name|cid2
init|=
name|cinfo
operator|->
name|comp_info
index|[
literal|2
index|]
operator|.
name|component_id
decl_stmt|;
if|if
condition|(
name|cid0
operator|==
literal|1
operator|&&
name|cid1
operator|==
literal|2
operator|&&
name|cid2
operator|==
literal|3
condition|)
name|cinfo
operator|->
name|jpeg_color_space
operator|=
name|JCS_YCbCr
expr_stmt|;
comment|/* assume JFIF w/out marker */
elseif|else
if|if
condition|(
name|cid0
operator|==
literal|82
operator|&&
name|cid1
operator|==
literal|71
operator|&&
name|cid2
operator|==
literal|66
condition|)
name|cinfo
operator|->
name|jpeg_color_space
operator|=
name|JCS_RGB
expr_stmt|;
comment|/* ASCII 'R', 'G', 'B' */
else|else
block|{
name|TRACEMS3
argument_list|(
name|cinfo
argument_list|,
literal|1
argument_list|,
name|JTRC_UNKNOWN_IDS
argument_list|,
name|cid0
argument_list|,
name|cid1
argument_list|,
name|cid2
argument_list|)
expr_stmt|;
name|cinfo
operator|->
name|jpeg_color_space
operator|=
name|JCS_YCbCr
expr_stmt|;
comment|/* assume it's YCbCr */
block|}
block|}
comment|/* Always guess RGB is proper output colorspace. */
name|cinfo
operator|->
name|out_color_space
operator|=
name|JCS_RGB
expr_stmt|;
break|break;
case|case
literal|4
case|:
if|if
condition|(
name|cinfo
operator|->
name|saw_Adobe_marker
condition|)
block|{
switch|switch
condition|(
name|cinfo
operator|->
name|Adobe_transform
condition|)
block|{
case|case
literal|0
case|:
name|cinfo
operator|->
name|jpeg_color_space
operator|=
name|JCS_CMYK
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|cinfo
operator|->
name|jpeg_color_space
operator|=
name|JCS_YCCK
expr_stmt|;
break|break;
default|default:
name|WARNMS1
argument_list|(
name|cinfo
argument_list|,
name|JWRN_ADOBE_XFORM
argument_list|,
name|cinfo
operator|->
name|Adobe_transform
argument_list|)
expr_stmt|;
name|cinfo
operator|->
name|jpeg_color_space
operator|=
name|JCS_YCCK
expr_stmt|;
comment|/* assume it's YCCK */
break|break;
block|}
block|}
else|else
block|{
comment|/* No special markers, assume straight CMYK. */
name|cinfo
operator|->
name|jpeg_color_space
operator|=
name|JCS_CMYK
expr_stmt|;
block|}
name|cinfo
operator|->
name|out_color_space
operator|=
name|JCS_CMYK
expr_stmt|;
break|break;
default|default:
name|cinfo
operator|->
name|jpeg_color_space
operator|=
name|JCS_UNKNOWN
expr_stmt|;
name|cinfo
operator|->
name|out_color_space
operator|=
name|JCS_UNKNOWN
expr_stmt|;
break|break;
block|}
comment|/* Set defaults for other decompression parameters. */
name|cinfo
operator|->
name|scale_num
operator|=
name|cinfo
operator|->
name|block_size
expr_stmt|;
comment|/* 1:1 scaling */
name|cinfo
operator|->
name|scale_denom
operator|=
name|cinfo
operator|->
name|block_size
expr_stmt|;
name|cinfo
operator|->
name|output_gamma
operator|=
literal|1.0
expr_stmt|;
name|cinfo
operator|->
name|buffered_image
operator|=
name|FALSE
expr_stmt|;
name|cinfo
operator|->
name|raw_data_out
operator|=
name|FALSE
expr_stmt|;
name|cinfo
operator|->
name|dct_method
operator|=
name|JDCT_DEFAULT
expr_stmt|;
name|cinfo
operator|->
name|do_fancy_upsampling
operator|=
name|TRUE
expr_stmt|;
name|cinfo
operator|->
name|do_block_smoothing
operator|=
name|TRUE
expr_stmt|;
name|cinfo
operator|->
name|quantize_colors
operator|=
name|FALSE
expr_stmt|;
comment|/* We set these in case application only sets quantize_colors. */
name|cinfo
operator|->
name|dither_mode
operator|=
name|JDITHER_FS
expr_stmt|;
ifdef|#
directive|ifdef
name|QUANT_2PASS_SUPPORTED
name|cinfo
operator|->
name|two_pass_quantize
operator|=
name|TRUE
expr_stmt|;
else|#
directive|else
name|cinfo
operator|->
name|two_pass_quantize
operator|=
name|FALSE
expr_stmt|;
endif|#
directive|endif
name|cinfo
operator|->
name|desired_number_of_colors
operator|=
literal|256
expr_stmt|;
name|cinfo
operator|->
name|colormap
operator|=
name|NULL
expr_stmt|;
comment|/* Initialize for no mode change in buffered-image mode. */
name|cinfo
operator|->
name|enable_1pass_quant
operator|=
name|FALSE
expr_stmt|;
name|cinfo
operator|->
name|enable_external_quant
operator|=
name|FALSE
expr_stmt|;
name|cinfo
operator|->
name|enable_2pass_quant
operator|=
name|FALSE
expr_stmt|;
block|}
end_block
begin_comment
comment|/*  * Decompression startup: read start of JPEG datastream to see what's there.  * Need only initialize JPEG object and supply a data source before calling.  *  * This routine will read as far as the first SOS marker (ie, actual start of  * compressed data), and will save all tables and parameters in the JPEG  * object.  It will also initialize the decompression parameters to default  * values, and finally return JPEG_HEADER_OK.  On return, the application may  * adjust the decompression parameters and then call jpeg_start_decompress.  * (Or, if the application only wanted to determine the image parameters,  * the data need not be decompressed.  In that case, call jpeg_abort or  * jpeg_destroy to release any temporary space.)  * If an abbreviated (tables only) datastream is presented, the routine will  * return JPEG_HEADER_TABLES_ONLY upon reaching EOI.  The application may then  * re-use the JPEG object to read the abbreviated image datastream(s).  * It is unnecessary (but OK) to call jpeg_abort in this case.  * The JPEG_SUSPENDED return code only occurs if the data source module  * requests suspension of the decompressor.  In this case the application  * should load more source data and then re-call jpeg_read_header to resume  * processing.  * If a non-suspending data source is used and require_image is TRUE, then the  * return code need not be inspected since only JPEG_HEADER_OK is possible.  *  * This routine is now just a front end to jpeg_consume_input, with some  * extra error checking.  */
end_comment
begin_macro
name|GLOBAL
argument_list|(
argument|int
argument_list|)
end_macro
begin_macro
DECL|function|jpeg_read_header
name|jpeg_read_header
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|,
argument|boolean require_image
argument_list|)
end_macro
begin_block
block|{
name|int
name|retcode
decl_stmt|;
if|if
condition|(
name|cinfo
operator|->
name|global_state
operator|!=
name|DSTATE_START
operator|&&
name|cinfo
operator|->
name|global_state
operator|!=
name|DSTATE_INHEADER
condition|)
name|ERREXIT1
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_STATE
argument_list|,
name|cinfo
operator|->
name|global_state
argument_list|)
expr_stmt|;
name|retcode
operator|=
name|jpeg_consume_input
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|retcode
condition|)
block|{
case|case
name|JPEG_REACHED_SOS
case|:
name|retcode
operator|=
name|JPEG_HEADER_OK
expr_stmt|;
break|break;
case|case
name|JPEG_REACHED_EOI
case|:
if|if
condition|(
name|require_image
condition|)
comment|/* Complain if application wanted an image */
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_NO_IMAGE
argument_list|)
expr_stmt|;
comment|/* Reset to start state; it would be safer to require the application to      * call jpeg_abort, but we can't change it now for compatibility reasons.      * A side effect is to free any temporary memory (there shouldn't be any).      */
name|jpeg_abort
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|)
expr_stmt|;
comment|/* sets state = DSTATE_START */
name|retcode
operator|=
name|JPEG_HEADER_TABLES_ONLY
expr_stmt|;
break|break;
case|case
name|JPEG_SUSPENDED
case|:
comment|/* no work */
break|break;
block|}
return|return
name|retcode
return|;
block|}
end_block
begin_comment
comment|/*  * Consume data in advance of what the decompressor requires.  * This can be called at any time once the decompressor object has  * been created and a data source has been set up.  *  * This routine is essentially a state machine that handles a couple  * of critical state-transition actions, namely initial setup and  * transition from header scanning to ready-for-start_decompress.  * All the actual input is done via the input controller's consume_input  * method.  */
end_comment
begin_macro
name|GLOBAL
argument_list|(
argument|int
argument_list|)
end_macro
begin_macro
DECL|function|jpeg_consume_input
name|jpeg_consume_input
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|)
end_macro
begin_block
block|{
name|int
name|retcode
init|=
name|JPEG_SUSPENDED
decl_stmt|;
comment|/* NB: every possible DSTATE value should be listed in this switch */
switch|switch
condition|(
name|cinfo
operator|->
name|global_state
condition|)
block|{
case|case
name|DSTATE_START
case|:
comment|/* Start-of-datastream actions: reset appropriate modules */
call|(
modifier|*
name|cinfo
operator|->
name|inputctl
operator|->
name|reset_input_controller
call|)
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
comment|/* Initialize application's data source module */
call|(
modifier|*
name|cinfo
operator|->
name|src
operator|->
name|init_source
call|)
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
name|cinfo
operator|->
name|global_state
operator|=
name|DSTATE_INHEADER
expr_stmt|;
comment|/*FALLTHROUGH*/
case|case
name|DSTATE_INHEADER
case|:
name|retcode
operator|=
call|(
modifier|*
name|cinfo
operator|->
name|inputctl
operator|->
name|consume_input
call|)
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|retcode
operator|==
name|JPEG_REACHED_SOS
condition|)
block|{
comment|/* Found SOS, prepare to decompress */
comment|/* Set up default parameters based on header data */
name|default_decompress_parms
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
comment|/* Set global state: ready for start_decompress */
name|cinfo
operator|->
name|global_state
operator|=
name|DSTATE_READY
expr_stmt|;
block|}
break|break;
case|case
name|DSTATE_READY
case|:
comment|/* Can't advance past first SOS until start_decompress is called */
name|retcode
operator|=
name|JPEG_REACHED_SOS
expr_stmt|;
break|break;
case|case
name|DSTATE_PRELOAD
case|:
case|case
name|DSTATE_PRESCAN
case|:
case|case
name|DSTATE_SCANNING
case|:
case|case
name|DSTATE_RAW_OK
case|:
case|case
name|DSTATE_BUFIMAGE
case|:
case|case
name|DSTATE_BUFPOST
case|:
case|case
name|DSTATE_STOPPING
case|:
name|retcode
operator|=
call|(
modifier|*
name|cinfo
operator|->
name|inputctl
operator|->
name|consume_input
call|)
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ERREXIT1
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_STATE
argument_list|,
name|cinfo
operator|->
name|global_state
argument_list|)
expr_stmt|;
block|}
return|return
name|retcode
return|;
block|}
end_block
begin_comment
comment|/*  * Have we finished reading the input file?  */
end_comment
begin_macro
DECL|function|GLOBAL
name|GLOBAL
argument_list|(
argument|boolean
argument_list|)
end_macro
begin_macro
name|jpeg_input_complete
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|)
end_macro
begin_block
block|{
comment|/* Check for valid jpeg object */
if|if
condition|(
name|cinfo
operator|->
name|global_state
operator|<
name|DSTATE_START
operator|||
name|cinfo
operator|->
name|global_state
operator|>
name|DSTATE_STOPPING
condition|)
name|ERREXIT1
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_STATE
argument_list|,
name|cinfo
operator|->
name|global_state
argument_list|)
expr_stmt|;
return|return
name|cinfo
operator|->
name|inputctl
operator|->
name|eoi_reached
return|;
block|}
end_block
begin_comment
comment|/*  * Is there more than one scan?  */
end_comment
begin_macro
DECL|function|GLOBAL
name|GLOBAL
argument_list|(
argument|boolean
argument_list|)
end_macro
begin_macro
name|jpeg_has_multiple_scans
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|)
end_macro
begin_block
block|{
comment|/* Only valid after jpeg_read_header completes */
if|if
condition|(
name|cinfo
operator|->
name|global_state
operator|<
name|DSTATE_READY
operator|||
name|cinfo
operator|->
name|global_state
operator|>
name|DSTATE_STOPPING
condition|)
name|ERREXIT1
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_STATE
argument_list|,
name|cinfo
operator|->
name|global_state
argument_list|)
expr_stmt|;
return|return
name|cinfo
operator|->
name|inputctl
operator|->
name|has_multiple_scans
return|;
block|}
end_block
begin_comment
comment|/*  * Finish JPEG decompression.  *  * This will normally just verify the file trailer and release temp storage.  *  * Returns FALSE if suspended.  The return value need be inspected only if  * a suspending data source is used.  */
end_comment
begin_macro
DECL|function|GLOBAL
name|GLOBAL
argument_list|(
argument|boolean
argument_list|)
end_macro
begin_macro
name|jpeg_finish_decompress
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|)
end_macro
begin_block
block|{
if|if
condition|(
operator|(
name|cinfo
operator|->
name|global_state
operator|==
name|DSTATE_SCANNING
operator|||
name|cinfo
operator|->
name|global_state
operator|==
name|DSTATE_RAW_OK
operator|)
operator|&&
operator|!
name|cinfo
operator|->
name|buffered_image
condition|)
block|{
comment|/* Terminate final pass of non-buffered mode */
if|if
condition|(
name|cinfo
operator|->
name|output_scanline
operator|<
name|cinfo
operator|->
name|output_height
condition|)
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_TOO_LITTLE_DATA
argument_list|)
expr_stmt|;
call|(
modifier|*
name|cinfo
operator|->
name|master
operator|->
name|finish_output_pass
call|)
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
name|cinfo
operator|->
name|global_state
operator|=
name|DSTATE_STOPPING
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cinfo
operator|->
name|global_state
operator|==
name|DSTATE_BUFIMAGE
condition|)
block|{
comment|/* Finishing after a buffered-image operation */
name|cinfo
operator|->
name|global_state
operator|=
name|DSTATE_STOPPING
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cinfo
operator|->
name|global_state
operator|!=
name|DSTATE_STOPPING
condition|)
block|{
comment|/* STOPPING = repeat call after a suspension, anything else is error */
name|ERREXIT1
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_STATE
argument_list|,
name|cinfo
operator|->
name|global_state
argument_list|)
expr_stmt|;
block|}
comment|/* Read until EOI */
while|while
condition|(
operator|!
name|cinfo
operator|->
name|inputctl
operator|->
name|eoi_reached
condition|)
block|{
if|if
condition|(
call|(
modifier|*
name|cinfo
operator|->
name|inputctl
operator|->
name|consume_input
call|)
argument_list|(
name|cinfo
argument_list|)
operator|==
name|JPEG_SUSPENDED
condition|)
return|return
name|FALSE
return|;
comment|/* Suspend, come back later */
block|}
comment|/* Do final cleanup */
call|(
modifier|*
name|cinfo
operator|->
name|src
operator|->
name|term_source
call|)
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
comment|/* We can use jpeg_abort to release memory and reset global_state */
name|jpeg_abort
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_block
end_unit
