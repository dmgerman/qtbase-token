begin_unit
begin_comment
comment|/*  * ckconfig.c  *  * Copyright (C) 1991-1994, Thomas G. Lane.  * This file is part of the Independent JPEG Group's software.  * For conditions of distribution and use, see the accompanying README file.  */
end_comment
begin_comment
comment|/*  * This program is intended to help you determine how to configure the JPEG  * software for installation on a particular system.  The idea is to try to  * compile and execute this program.  If your compiler fails to compile the  * program, make changes as indicated in the comments below.  Once you can  * compile the program, run it, and it will produce a "jconfig.h" file for  * your system.  *  * As a general rule, each time you try to compile this program,  * pay attention only to the *first* error message you get from the compiler.  * Many C compilers will issue lots of spurious error messages once they  * have gotten confused.  Go to the line indicated in the first error message,  * and read the comments preceding that line to see what to change.  *  * Almost all of the edits you may need to make to this program consist of  * changing a line that reads "#define SOME_SYMBOL" to "#undef SOME_SYMBOL",  * or vice versa.  This is called defining or undefining that symbol.  */
end_comment
begin_comment
comment|/* First we must see if your system has the include files we need.  * We start out with the assumption that your system has all the ANSI-standard  * include files.  If you get any error trying to include one of these files,  * undefine the corresponding HAVE_xxx symbol.  */
end_comment
begin_define
DECL|macro|HAVE_STDDEF_H
define|#
directive|define
name|HAVE_STDDEF_H
end_define
begin_comment
DECL|macro|HAVE_STDDEF_H
comment|/* replace 'define' by 'undef' if error here */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STDDEF_H
end_ifdef
begin_comment
comment|/* next line will be skipped if you undef... */
end_comment
begin_include
include|#
directive|include
file|<stddef.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|HAVE_STDLIB_H
define|#
directive|define
name|HAVE_STDLIB_H
end_define
begin_comment
DECL|macro|HAVE_STDLIB_H
comment|/* same thing for stdlib.h */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STDLIB_H
end_ifdef
begin_include
include|#
directive|include
file|<stdlib.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|<stdio.h>
end_include
begin_comment
comment|/* If you ain't got this, you ain't got C. */
end_comment
begin_comment
comment|/* We have to see if your string functions are defined by  * strings.h (old BSD convention) or string.h (everybody else).  * We try the non-BSD convention first; define NEED_BSD_STRINGS  * if the compiler says it can't find string.h.  */
end_comment
begin_undef
DECL|macro|NEED_BSD_STRINGS
undef|#
directive|undef
name|NEED_BSD_STRINGS
end_undef
begin_ifdef
ifdef|#
directive|ifdef
name|NEED_BSD_STRINGS
end_ifdef
begin_include
include|#
directive|include
file|<strings.h>
end_include
begin_else
else|#
directive|else
end_else
begin_include
include|#
directive|include
file|<string.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* On some systems (especially older Unix machines), type size_t is  * defined only in the include file<sys/types.h>.  If you get a failure  * on the size_t test below, try defining NEED_SYS_TYPES_H.  */
end_comment
begin_undef
DECL|macro|NEED_SYS_TYPES_H
undef|#
directive|undef
name|NEED_SYS_TYPES_H
end_undef
begin_comment
DECL|macro|NEED_SYS_TYPES_H
comment|/* start by assuming we don't need it */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|NEED_SYS_TYPES_H
end_ifdef
begin_include
include|#
directive|include
file|<sys/types.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* Usually type size_t is defined in one of the include files we've included  * above.  If not, you'll get an error on the "typedef size_t my_size_t;" line.  * In that case, first try defining NEED_SYS_TYPES_H just above.  * If that doesn't work, you'll have to search through your system library  * to figure out which include file defines "size_t".  Look for a line that  * says "typedef something-or-other size_t;".  Then, change the line below  * that says "#include<someincludefile.h>" to instead include the file  * you found size_t in, and define NEED_SPECIAL_INCLUDE.  If you can't find  * type size_t anywhere, try replacing "#include<someincludefile.h>" with  * "typedef unsigned int size_t;".  */
end_comment
begin_undef
DECL|macro|NEED_SPECIAL_INCLUDE
undef|#
directive|undef
name|NEED_SPECIAL_INCLUDE
end_undef
begin_comment
DECL|macro|NEED_SPECIAL_INCLUDE
comment|/* assume we DON'T need it, for starters */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|NEED_SPECIAL_INCLUDE
end_ifdef
begin_include
include|#
directive|include
file|<someincludefile.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_typedef
DECL|typedef|my_size_t
typedef|typedef
name|size_t
name|my_size_t
typedef|;
end_typedef
begin_comment
DECL|typedef|my_size_t
comment|/* The payoff: do we have size_t now? */
end_comment
begin_comment
comment|/* The next question is whether your compiler supports ANSI-style function  * prototypes.  You need to know this in order to choose between using  * makefile.ansi and using makefile.unix.  * The #define line below is set to assume you have ANSI function prototypes.  * If you get an error in this group of lines, undefine HAVE_PROTOTYPES.  */
end_comment
begin_define
DECL|macro|HAVE_PROTOTYPES
define|#
directive|define
name|HAVE_PROTOTYPES
end_define
begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PROTOTYPES
end_ifdef
begin_function_decl
name|int
name|testfunction
parameter_list|(
name|int
name|arg1
parameter_list|,
name|int
modifier|*
name|arg2
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/* check prototypes */
end_comment
begin_struct
DECL|struct|methods_struct
struct|struct
name|methods_struct
block|{
comment|/* check method-pointer declarations */
DECL|member|error_exit
name|int
function_decl|(
modifier|*
name|error_exit
function_decl|)
parameter_list|(
name|char
modifier|*
name|msgtext
parameter_list|)
function_decl|;
DECL|member|trace_message
name|int
function_decl|(
modifier|*
name|trace_message
function_decl|)
parameter_list|(
name|char
modifier|*
name|msgtext
parameter_list|)
function_decl|;
DECL|member|another_method
name|int
function_decl|(
modifier|*
name|another_method
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
block|}
struct|;
end_struct
begin_function
DECL|function|testfunction
name|int
name|testfunction
parameter_list|(
name|int
name|arg1
parameter_list|,
name|int
modifier|*
name|arg2
parameter_list|)
comment|/* check definitions */
block|{
return|return
name|arg2
index|[
name|arg1
index|]
return|;
block|}
end_function
begin_function
DECL|function|test2function
name|int
name|test2function
parameter_list|(
name|void
parameter_list|)
comment|/* check void arg list */
block|{
return|return
literal|0
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* Now we want to find out if your compiler knows what "unsigned char" means.  * If you get an error on the "unsigned char un_char;" line,  * then undefine HAVE_UNSIGNED_CHAR.  */
end_comment
begin_define
DECL|macro|HAVE_UNSIGNED_CHAR
define|#
directive|define
name|HAVE_UNSIGNED_CHAR
end_define
begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UNSIGNED_CHAR
end_ifdef
begin_decl_stmt
DECL|variable|un_char
name|unsigned
name|char
name|un_char
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* Now we want to find out if your compiler knows what "unsigned short" means.  * If you get an error on the "unsigned short un_short;" line,  * then undefine HAVE_UNSIGNED_SHORT.  */
end_comment
begin_define
DECL|macro|HAVE_UNSIGNED_SHORT
define|#
directive|define
name|HAVE_UNSIGNED_SHORT
end_define
begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UNSIGNED_SHORT
end_ifdef
begin_decl_stmt
DECL|variable|un_short
name|unsigned
name|short
name|un_short
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* Now we want to find out if your compiler understands type "void".  * If you get an error anywhere in here, undefine HAVE_VOID.  */
end_comment
begin_define
DECL|macro|HAVE_VOID
define|#
directive|define
name|HAVE_VOID
end_define
begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_VOID
end_ifdef
begin_comment
comment|/* Caution: a C++ compiler will insist on complete prototypes */
end_comment
begin_typedef
DECL|typedef|void_ptr
typedef|typedef
name|void
modifier|*
name|void_ptr
typedef|;
end_typedef
begin_comment
DECL|typedef|void_ptr
comment|/* check void * */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PROTOTYPES
end_ifdef
begin_comment
comment|/* check ptr to function returning void */
end_comment
begin_typedef
DECL|typedef|void_func
typedef|typedef
name|void
function_decl|(
modifier|*
name|void_func
function_decl|)
parameter_list|(
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
function_decl|;
end_typedef
begin_else
else|#
directive|else
end_else
begin_typedef
DECL|typedef|void_func
typedef|typedef
name|void
function_decl|(
modifier|*
name|void_func
function_decl|)
parameter_list|()
function_decl|;
end_typedef
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PROTOTYPES
end_ifdef
begin_comment
comment|/* check void function result */
end_comment
begin_function
DECL|function|test3function
name|void
name|test3function
parameter_list|(
name|void_ptr
name|arg1
parameter_list|,
name|void_func
name|arg2
parameter_list|)
else|#
directive|else
function|void test3function
parameter_list|(
name|arg1
parameter_list|,
name|arg2
parameter_list|)
name|void_ptr
name|arg1
decl_stmt|;
name|void_func
name|arg2
decl_stmt|;
endif|#
directive|endif
block|{
name|char
modifier|*
name|locptr
init|=
operator|(
name|char
operator|*
operator|)
name|arg1
decl_stmt|;
comment|/* check casting to and from void * */
name|arg1
operator|=
operator|(
name|void
operator|*
operator|)
name|locptr
expr_stmt|;
call|(
modifier|*
name|arg2
call|)
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* check call of fcn returning void */
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* Now we want to find out if your compiler knows what "const" means.  * If you get an error here, undefine HAVE_CONST.  */
end_comment
begin_define
DECL|macro|HAVE_CONST
define|#
directive|define
name|HAVE_CONST
end_define
begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONST
end_ifdef
begin_decl_stmt
DECL|variable|carray
specifier|static
specifier|const
name|int
name|carray
index|[
literal|3
index|]
init|=
block|{
literal|1
block|,
literal|2
block|,
literal|3
block|}
decl_stmt|;
end_decl_stmt
begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PROTOTYPES
end_ifdef
begin_decl_stmt
DECL|function|test4function
name|int
name|test4function
argument_list|(
specifier|const
name|int
name|arg1
argument_list|)
else|#
directive|else
name|int
name|test4function
argument_list|(
name|arg1
argument_list|)
decl|const
name|int
name|arg1
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_block
block|{
return|return
name|carray
index|[
name|arg1
index|]
return|;
block|}
end_block
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* If you get an error or warning about this structure definition,  * define INCOMPLETE_TYPES_BROKEN.  */
end_comment
begin_undef
DECL|macro|INCOMPLETE_TYPES_BROKEN
undef|#
directive|undef
name|INCOMPLETE_TYPES_BROKEN
end_undef
begin_ifndef
ifndef|#
directive|ifndef
name|INCOMPLETE_TYPES_BROKEN
end_ifndef
begin_typedef
DECL|typedef|undef_struct_ptr
typedef|typedef
name|struct
name|undefined_structure
modifier|*
name|undef_struct_ptr
typedef|;
end_typedef
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* If you get an error about duplicate names,  * define NEED_SHORT_EXTERNAL_NAMES.  */
end_comment
begin_undef
DECL|macro|NEED_SHORT_EXTERNAL_NAMES
undef|#
directive|undef
name|NEED_SHORT_EXTERNAL_NAMES
end_undef
begin_ifndef
ifndef|#
directive|ifndef
name|NEED_SHORT_EXTERNAL_NAMES
end_ifndef
begin_function
DECL|function|possibly_duplicate_function
name|int
name|possibly_duplicate_function
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|possibly_dupli_function
name|int
name|possibly_dupli_function
parameter_list|()
block|{
return|return
literal|1
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/************************************************************************  *  OK, that's it.  You should not have to change anything beyond this  *  point in order to compile and execute this program.  (You might get  *  some warnings, but you can ignore them.)  *  When you run the program, it will make a couple more tests that it  *  can do automatically, and then it will create jconfig.h and print out  *  any additional suggestions it has.  ************************************************************************  */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PROTOTYPES
end_ifdef
begin_function
DECL|function|is_char_signed
name|int
name|is_char_signed
parameter_list|(
name|int
name|arg
parameter_list|)
else|#
directive|else
function|int is_char_signed
parameter_list|(
name|arg
parameter_list|)
name|int
name|arg
decl_stmt|;
endif|#
directive|endif
block|{
if|if
condition|(
name|arg
operator|==
literal|189
condition|)
block|{
comment|/* expected result for unsigned char */
return|return
literal|0
return|;
comment|/* type char is unsigned */
block|}
elseif|else
if|if
condition|(
name|arg
operator|!=
operator|-
literal|67
condition|)
block|{
comment|/* expected result for signed char */
name|printf
argument_list|(
literal|"Hmm, it seems 'char' is not eight bits wide on your machine.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"I fear the JPEG software will not work at all.\n\n"
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
comment|/* assume char is signed otherwise */
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PROTOTYPES
end_ifdef
begin_function
DECL|function|is_shifting_signed
name|int
name|is_shifting_signed
parameter_list|(
name|long
name|arg
parameter_list|)
else|#
directive|else
function|int is_shifting_signed
parameter_list|(
name|arg
parameter_list|)
name|long
name|arg
decl_stmt|;
endif|#
directive|endif
comment|/* See whether right-shift on a long is signed or not. */
block|{
name|long
name|res
init|=
name|arg
operator|>>
literal|4
decl_stmt|;
if|if
condition|(
name|res
operator|==
operator|-
literal|0x7F7E80CL
condition|)
block|{
comment|/* expected result for signed shift */
return|return
literal|1
return|;
comment|/* right shift is signed */
block|}
comment|/* see if unsigned-shift hack will fix it. */
comment|/* we can't just test exact value since it depends on width of long... */
name|res
operator||=
operator|(
operator|~
literal|0L
operator|)
operator|<<
operator|(
literal|32
operator|-
literal|4
operator|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
operator|-
literal|0x7F7E80CL
condition|)
block|{
comment|/* expected result now? */
return|return
literal|0
return|;
comment|/* right shift is unsigned */
block|}
name|printf
argument_list|(
literal|"Right shift isn't acting as I expect it to.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"I fear the JPEG software will not work at all.\n\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* try it with unsigned anyway */
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PROTOTYPES
end_ifdef
begin_function
DECL|function|main
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
else|#
directive|else
function|int main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
endif|#
directive|endif
block|{
name|char
name|signed_char_check
init|=
call|(
name|char
call|)
argument_list|(
operator|-
literal|67
argument_list|)
decl_stmt|;
name|FILE
modifier|*
name|outfile
decl_stmt|;
comment|/* Attempt to write jconfig.h */
if|if
condition|(
operator|(
name|outfile
operator|=
name|fopen
argument_list|(
literal|"jconfig.h"
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"Failed to write jconfig.h\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Write out all the info */
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"/* jconfig.h --- generated by ckconfig.c */\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"/* see jconfig.txt for explanations */\n\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_PROTOTYPES
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"#define HAVE_PROTOTYPES\n"
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"#undef HAVE_PROTOTYPES\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_UNSIGNED_CHAR
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"#define HAVE_UNSIGNED_CHAR\n"
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"#undef HAVE_UNSIGNED_CHAR\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_UNSIGNED_SHORT
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"#define HAVE_UNSIGNED_SHORT\n"
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"#undef HAVE_UNSIGNED_SHORT\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_VOID
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"/* #define void char */\n"
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"#define void char\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_CONST
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"/* #define const */\n"
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"#define const\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|is_char_signed
argument_list|(
operator|(
name|int
operator|)
name|signed_char_check
argument_list|)
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"#undef CHAR_IS_UNSIGNED\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"#define CHAR_IS_UNSIGNED\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_STDDEF_H
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"#define HAVE_STDDEF_H\n"
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"#undef HAVE_STDDEF_H\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_STDLIB_H
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"#define HAVE_STDLIB_H\n"
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"#undef HAVE_STDLIB_H\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NEED_BSD_STRINGS
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"#define NEED_BSD_STRINGS\n"
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"#undef NEED_BSD_STRINGS\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NEED_SYS_TYPES_H
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"#define NEED_SYS_TYPES_H\n"
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"#undef NEED_SYS_TYPES_H\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"#undef NEED_FAR_POINTERS\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NEED_SHORT_EXTERNAL_NAMES
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"#define NEED_SHORT_EXTERNAL_NAMES\n"
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"#undef NEED_SHORT_EXTERNAL_NAMES\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INCOMPLETE_TYPES_BROKEN
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"#define INCOMPLETE_TYPES_BROKEN\n"
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"#undef INCOMPLETE_TYPES_BROKEN\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\n#ifdef JPEG_INTERNALS\n\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_shifting_signed
argument_list|(
operator|-
literal|0x7F7E80B1L
argument_list|)
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"#undef RIGHT_SHIFT_IS_UNSIGNED\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"#define RIGHT_SHIFT_IS_UNSIGNED\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\n#endif /* JPEG_INTERNALS */\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\n#ifdef JPEG_CJPEG_DJPEG\n\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"#define BMP_SUPPORTED		/* BMP image file format */\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"#define GIF_SUPPORTED		/* GIF image file format */\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"#define PPM_SUPPORTED		/* PBMPLUS PPM/PGM image file format */\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"#undef RLE_SUPPORTED		/* Utah RLE image file format */\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"#define TARGA_SUPPORTED		/* Targa image file format */\n\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"#undef TWO_FILE_COMMANDLINE	/* You may need this on non-Unix systems */\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"#undef NEED_SIGNAL_CATCHER	/* Define this if you use jmemname.c */\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"#undef DONT_USE_B_MODE\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"/* #define PROGRESS_REPORT */	/* optional */\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\n#endif /* JPEG_CJPEG_DJPEG */\n"
argument_list|)
expr_stmt|;
comment|/* Close the jconfig.h file */
name|fclose
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
comment|/* User report */
name|printf
argument_list|(
literal|"Configuration check for Independent JPEG Group's software done.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nI have written the jconfig.h file for you.\n\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_PROTOTYPES
name|printf
argument_list|(
literal|"You should use makefile.ansi as the starting point for your Makefile.\n"
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"You should use makefile.unix as the starting point for your Makefile.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NEED_SPECIAL_INCLUDE
name|printf
argument_list|(
literal|"\nYou'll need to change jconfig.h to include the system include file\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"that you found type size_t in, or add a direct definition of type\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"size_t if that's what you used.  Just add it to the end.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function
end_unit
