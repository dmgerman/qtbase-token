begin_unit
begin_comment
comment|/*  * jmemmgr.c  *  * Copyright (C) 1991-1997, Thomas G. Lane.  * This file is part of the Independent JPEG Group's software.  * For conditions of distribution and use, see the accompanying README file.  *  * This file contains the JPEG system-independent memory management  * routines.  This code is usable across a wide variety of machines; most  * of the system dependencies have been isolated in a separate file.  * The major functions provided here are:  *   * pool-based allocation and freeing of memory;  *   * policy decisions about how to divide available memory among the  *     virtual arrays;  *   * control logic for swapping virtual arrays between main memory and  *     backing storage.  * The separate system-dependent file provides the actual backing-storage  * access code, and it contains the policy decision about how much total  * main memory to use.  * This file is system-dependent in the sense that some of its functions  * are unnecessary in some systems.  For example, if there is enough virtual  * memory so that backing storage will never be used, much of the virtual  * array control logic could be removed.  (Of course, if you have that much  * memory then you shouldn't care about a little bit of unused code...)  */
end_comment
begin_define
DECL|macro|JPEG_INTERNALS
define|#
directive|define
name|JPEG_INTERNALS
end_define
begin_define
DECL|macro|AM_MEMORY_MANAGER
define|#
directive|define
name|AM_MEMORY_MANAGER
end_define
begin_comment
DECL|macro|AM_MEMORY_MANAGER
comment|/* we define jvirt_Xarray_control structs */
end_comment
begin_include
include|#
directive|include
file|"jinclude.h"
end_include
begin_include
include|#
directive|include
file|"jpeglib.h"
end_include
begin_include
include|#
directive|include
file|"jmemsys.h"
end_include
begin_comment
comment|/* import the system-dependent declarations */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|NO_GETENV
end_ifndef
begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_STDLIB_H
end_ifndef
begin_comment
comment|/*<stdlib.h> should declare getenv() */
end_comment
begin_decl_stmt
specifier|extern
name|char
modifier|*
name|getenv
name|JPP
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|name
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*  * Some important notes:  *   The allocation routines provided here must never return NULL.  *   They should exit to error_exit if unsuccessful.  *  *   It's not a good idea to try to merge the sarray and barray routines,  *   even though they are textually almost the same, because samples are  *   usually stored as bytes while coefficients are shorts or ints.  Thus,  *   in machines where byte pointers have a different representation from  *   word pointers, the resulting machine code could not be the same.  */
end_comment
begin_comment
comment|/*  * Many machines require storage alignment: longs must start on 4-byte  * boundaries, doubles on 8-byte boundaries, etc.  On such machines, malloc()  * always returns pointers that are multiples of the worst-case alignment  * requirement, and we had better do so too.  * There isn't any really portable way to determine the worst-case alignment  * requirement.  This module assumes that the alignment requirement is  * multiples of sizeof(ALIGN_TYPE).  * By default, we define ALIGN_TYPE as double.  This is necessary on some  * workstations (where doubles really do need 8-byte alignment) and will work  * fine on nearly everything.  If your machine has lesser alignment needs,  * you can save a few bytes by making ALIGN_TYPE smaller.  * The only place I know of where this will NOT work is certain Macintosh  * 680x0 compilers that define double as a 10-byte IEEE extended float.  * Doing 10-byte alignment is counterproductive because longwords won't be  * aligned well.  Put "#define ALIGN_TYPE long" in jconfig.h if you have  * such a compiler.  */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|ALIGN_TYPE
end_ifndef
begin_comment
comment|/* so can override from jconfig.h */
end_comment
begin_define
DECL|macro|ALIGN_TYPE
define|#
directive|define
name|ALIGN_TYPE
value|double
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*  * We allocate objects from "pools", where each pool is gotten with a single  * request to jpeg_get_small() or jpeg_get_large().  There is no per-object  * overhead within a pool, except for alignment padding.  Each pool has a  * header with a link to the next pool of the same class.  * Small and large pool headers are identical except that the latter's  * link pointer must be FAR on 80x86 machines.  * Notice that the "real" header fields are union'ed with a dummy ALIGN_TYPE  * field.  This forces the compiler to make SIZEOF(small_pool_hdr) a multiple  * of the alignment requirement of ALIGN_TYPE.  */
end_comment
begin_typedef
DECL|typedef|small_pool_ptr
typedef|typedef
name|union
name|small_pool_struct
modifier|*
name|small_pool_ptr
typedef|;
end_typedef
begin_typedef
DECL|union|small_pool_struct
typedef|typedef
union|union
name|small_pool_struct
block|{
struct|struct
block|{
DECL|member|next
name|small_pool_ptr
name|next
decl_stmt|;
comment|/* next in list of pools */
DECL|member|bytes_used
name|size_t
name|bytes_used
decl_stmt|;
comment|/* how many bytes already used within pool */
DECL|member|bytes_left
name|size_t
name|bytes_left
decl_stmt|;
comment|/* bytes still available in this pool */
block|}
DECL|member|hdr
name|hdr
struct|;
DECL|member|dummy
name|ALIGN_TYPE
name|dummy
decl_stmt|;
comment|/* included in union to ensure alignment */
block|}
DECL|typedef|small_pool_hdr
name|small_pool_hdr
typedef|;
end_typedef
begin_typedef
DECL|typedef|large_pool_ptr
typedef|typedef
name|union
name|large_pool_struct
name|FAR
modifier|*
name|large_pool_ptr
typedef|;
end_typedef
begin_typedef
DECL|union|large_pool_struct
typedef|typedef
union|union
name|large_pool_struct
block|{
struct|struct
block|{
DECL|member|next
name|large_pool_ptr
name|next
decl_stmt|;
comment|/* next in list of pools */
DECL|member|bytes_used
name|size_t
name|bytes_used
decl_stmt|;
comment|/* how many bytes already used within pool */
DECL|member|bytes_left
name|size_t
name|bytes_left
decl_stmt|;
comment|/* bytes still available in this pool */
block|}
DECL|member|hdr
name|hdr
struct|;
DECL|member|dummy
name|ALIGN_TYPE
name|dummy
decl_stmt|;
comment|/* included in union to ensure alignment */
block|}
DECL|typedef|large_pool_hdr
name|large_pool_hdr
typedef|;
end_typedef
begin_comment
comment|/*  * Here is the full definition of a memory manager object.  */
end_comment
begin_typedef
typedef|typedef
struct|struct
block|{
DECL|member|pub
name|struct
name|jpeg_memory_mgr
name|pub
decl_stmt|;
comment|/* public fields */
comment|/* Each pool identifier (lifetime class) names a linked list of pools. */
DECL|member|small_list
name|small_pool_ptr
name|small_list
index|[
name|JPOOL_NUMPOOLS
index|]
decl_stmt|;
DECL|member|large_list
name|large_pool_ptr
name|large_list
index|[
name|JPOOL_NUMPOOLS
index|]
decl_stmt|;
comment|/* Since we only have one lifetime class of virtual arrays, only one    * linked list is necessary (for each datatype).  Note that the virtual    * array control blocks being linked together are actually stored somewhere    * in the small-pool list.    */
DECL|member|virt_sarray_list
name|jvirt_sarray_ptr
name|virt_sarray_list
decl_stmt|;
DECL|member|virt_barray_list
name|jvirt_barray_ptr
name|virt_barray_list
decl_stmt|;
comment|/* This counts total space obtained from jpeg_get_small/large */
DECL|member|total_space_allocated
name|long
name|total_space_allocated
decl_stmt|;
comment|/* alloc_sarray and alloc_barray set this value for use by virtual    * array routines.    */
DECL|member|last_rowsperchunk
name|JDIMENSION
name|last_rowsperchunk
decl_stmt|;
comment|/* from most recent alloc_sarray/barray */
block|}
DECL|typedef|my_memory_mgr
name|my_memory_mgr
typedef|;
end_typedef
begin_typedef
DECL|typedef|my_mem_ptr
typedef|typedef
name|my_memory_mgr
modifier|*
name|my_mem_ptr
typedef|;
end_typedef
begin_comment
comment|/*  * The control blocks for virtual arrays.  * Note that these blocks are allocated in the "small" pool area.  * System-dependent info for the associated backing store (if any) is hidden  * inside the backing_store_info struct.  */
end_comment
begin_struct
DECL|struct|jvirt_sarray_control
struct|struct
name|jvirt_sarray_control
block|{
DECL|member|mem_buffer
name|JSAMPARRAY
name|mem_buffer
decl_stmt|;
comment|/* => the in-memory buffer */
DECL|member|rows_in_array
name|JDIMENSION
name|rows_in_array
decl_stmt|;
comment|/* total virtual array height */
DECL|member|samplesperrow
name|JDIMENSION
name|samplesperrow
decl_stmt|;
comment|/* width of array (and of memory buffer) */
DECL|member|maxaccess
name|JDIMENSION
name|maxaccess
decl_stmt|;
comment|/* max rows accessed by access_virt_sarray */
DECL|member|rows_in_mem
name|JDIMENSION
name|rows_in_mem
decl_stmt|;
comment|/* height of memory buffer */
DECL|member|rowsperchunk
name|JDIMENSION
name|rowsperchunk
decl_stmt|;
comment|/* allocation chunk size in mem_buffer */
DECL|member|cur_start_row
name|JDIMENSION
name|cur_start_row
decl_stmt|;
comment|/* first logical row # in the buffer */
DECL|member|first_undef_row
name|JDIMENSION
name|first_undef_row
decl_stmt|;
comment|/* row # of first uninitialized row */
DECL|member|pre_zero
name|boolean
name|pre_zero
decl_stmt|;
comment|/* pre-zero mode requested? */
DECL|member|dirty
name|boolean
name|dirty
decl_stmt|;
comment|/* do current buffer contents need written? */
DECL|member|b_s_open
name|boolean
name|b_s_open
decl_stmt|;
comment|/* is backing-store data valid? */
DECL|member|next
name|jvirt_sarray_ptr
name|next
decl_stmt|;
comment|/* link to next virtual sarray control block */
DECL|member|b_s_info
name|backing_store_info
name|b_s_info
decl_stmt|;
comment|/* System-dependent control info */
block|}
struct|;
end_struct
begin_struct
DECL|struct|jvirt_barray_control
struct|struct
name|jvirt_barray_control
block|{
DECL|member|mem_buffer
name|JBLOCKARRAY
name|mem_buffer
decl_stmt|;
comment|/* => the in-memory buffer */
DECL|member|rows_in_array
name|JDIMENSION
name|rows_in_array
decl_stmt|;
comment|/* total virtual array height */
DECL|member|blocksperrow
name|JDIMENSION
name|blocksperrow
decl_stmt|;
comment|/* width of array (and of memory buffer) */
DECL|member|maxaccess
name|JDIMENSION
name|maxaccess
decl_stmt|;
comment|/* max rows accessed by access_virt_barray */
DECL|member|rows_in_mem
name|JDIMENSION
name|rows_in_mem
decl_stmt|;
comment|/* height of memory buffer */
DECL|member|rowsperchunk
name|JDIMENSION
name|rowsperchunk
decl_stmt|;
comment|/* allocation chunk size in mem_buffer */
DECL|member|cur_start_row
name|JDIMENSION
name|cur_start_row
decl_stmt|;
comment|/* first logical row # in the buffer */
DECL|member|first_undef_row
name|JDIMENSION
name|first_undef_row
decl_stmt|;
comment|/* row # of first uninitialized row */
DECL|member|pre_zero
name|boolean
name|pre_zero
decl_stmt|;
comment|/* pre-zero mode requested? */
DECL|member|dirty
name|boolean
name|dirty
decl_stmt|;
comment|/* do current buffer contents need written? */
DECL|member|b_s_open
name|boolean
name|b_s_open
decl_stmt|;
comment|/* is backing-store data valid? */
DECL|member|next
name|jvirt_barray_ptr
name|next
decl_stmt|;
comment|/* link to next virtual barray control block */
DECL|member|b_s_info
name|backing_store_info
name|b_s_info
decl_stmt|;
comment|/* System-dependent control info */
block|}
struct|;
end_struct
begin_ifdef
ifdef|#
directive|ifdef
name|MEM_STATS
end_ifdef
begin_comment
comment|/* optional extra stuff for statistics */
end_comment
begin_macro
name|LOCAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|print_mem_stats
name|print_mem_stats
argument_list|(
argument|j_common_ptr cinfo
argument_list|,
argument|int pool_id
argument_list|)
end_macro
begin_block
block|{
name|my_mem_ptr
name|mem
init|=
operator|(
name|my_mem_ptr
operator|)
name|cinfo
operator|->
name|mem
decl_stmt|;
name|small_pool_ptr
name|shdr_ptr
decl_stmt|;
name|large_pool_ptr
name|lhdr_ptr
decl_stmt|;
comment|/* Since this is only a debugging stub, we can cheat a little by using    * fprintf directly rather than going through the trace message code.    * This is helpful because message parm array can't handle longs.    */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Freeing pool %d, total space = %ld\n"
argument_list|,
name|pool_id
argument_list|,
name|mem
operator|->
name|total_space_allocated
argument_list|)
expr_stmt|;
for|for
control|(
name|lhdr_ptr
operator|=
name|mem
operator|->
name|large_list
index|[
name|pool_id
index|]
init|;
name|lhdr_ptr
operator|!=
name|NULL
condition|;
name|lhdr_ptr
operator|=
name|lhdr_ptr
operator|->
name|hdr
operator|.
name|next
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  Large chunk used %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|lhdr_ptr
operator|->
name|hdr
operator|.
name|bytes_used
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|shdr_ptr
operator|=
name|mem
operator|->
name|small_list
index|[
name|pool_id
index|]
init|;
name|shdr_ptr
operator|!=
name|NULL
condition|;
name|shdr_ptr
operator|=
name|shdr_ptr
operator|->
name|hdr
operator|.
name|next
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  Small chunk used %ld free %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|shdr_ptr
operator|->
name|hdr
operator|.
name|bytes_used
argument_list|,
operator|(
name|long
operator|)
name|shdr_ptr
operator|->
name|hdr
operator|.
name|bytes_left
argument_list|)
expr_stmt|;
block|}
block|}
end_block
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* MEM_STATS */
end_comment
begin_macro
name|LOCAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|out_of_memory
name|out_of_memory
argument_list|(
argument|j_common_ptr cinfo
argument_list|,
argument|int which
argument_list|)
end_macro
begin_comment
comment|/* Report an out-of-memory error and stop execution */
end_comment
begin_comment
comment|/* If we compiled MEM_STATS support, report alloc requests before dying */
end_comment
begin_block
block|{
ifdef|#
directive|ifdef
name|MEM_STATS
name|cinfo
operator|->
name|err
operator|->
name|trace_level
operator|=
literal|2
expr_stmt|;
comment|/* force self_destruct to report stats */
endif|#
directive|endif
name|ERREXIT1
argument_list|(
name|cinfo
argument_list|,
name|JERR_OUT_OF_MEMORY
argument_list|,
name|which
argument_list|)
expr_stmt|;
block|}
end_block
begin_comment
comment|/*  * Allocation of "small" objects.  *  * For these, we use pooled storage.  When a new pool must be created,  * we try to get enough space for the current request plus a "slop" factor,  * where the slop will be the amount of leftover space in the new pool.  * The speed vs. space tradeoff is largely determined by the slop values.  * A different slop value is provided for each pool class (lifetime),  * and we also distinguish the first pool of a class from later ones.  * NOTE: the values given work fairly well on both 16- and 32-bit-int  * machines, but may be too small if longs are 64 bits or more.  */
end_comment
begin_decl_stmt
DECL|variable|first_pool_slop
specifier|static
specifier|const
name|size_t
name|first_pool_slop
index|[
name|JPOOL_NUMPOOLS
index|]
init|=
block|{
literal|1600
block|,
comment|/* first PERMANENT pool */
literal|16000
comment|/* first IMAGE pool */
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|extra_pool_slop
specifier|static
specifier|const
name|size_t
name|extra_pool_slop
index|[
name|JPOOL_NUMPOOLS
index|]
init|=
block|{
literal|0
block|,
comment|/* additional PERMANENT pools */
literal|5000
comment|/* additional IMAGE pools */
block|}
decl_stmt|;
end_decl_stmt
begin_define
DECL|macro|MIN_SLOP
define|#
directive|define
name|MIN_SLOP
value|50
end_define
begin_comment
DECL|macro|MIN_SLOP
comment|/* greater than 0 to avoid futile looping */
end_comment
begin_macro
name|METHODDEF
argument_list|(
argument|void *
argument_list|)
end_macro
begin_macro
DECL|function|alloc_small
name|alloc_small
argument_list|(
argument|j_common_ptr cinfo
argument_list|,
argument|int pool_id
argument_list|,
argument|size_t sizeofobject
argument_list|)
end_macro
begin_comment
comment|/* Allocate a "small" object */
end_comment
begin_block
block|{
name|my_mem_ptr
name|mem
init|=
operator|(
name|my_mem_ptr
operator|)
name|cinfo
operator|->
name|mem
decl_stmt|;
name|small_pool_ptr
name|hdr_ptr
decl_stmt|,
name|prev_hdr_ptr
decl_stmt|;
name|char
modifier|*
name|data_ptr
decl_stmt|;
name|size_t
name|odd_bytes
decl_stmt|,
name|min_request
decl_stmt|,
name|slop
decl_stmt|;
comment|/* Check for unsatisfiable request (do now to ensure no overflow below) */
if|if
condition|(
name|sizeofobject
operator|>
call|(
name|size_t
call|)
argument_list|(
name|MAX_ALLOC_CHUNK
operator|-
name|SIZEOF
argument_list|(
name|small_pool_hdr
argument_list|)
argument_list|)
condition|)
name|out_of_memory
argument_list|(
name|cinfo
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* request exceeds malloc's ability */
comment|/* Round up the requested size to a multiple of SIZEOF(ALIGN_TYPE) */
name|odd_bytes
operator|=
name|sizeofobject
operator|%
name|SIZEOF
argument_list|(
name|ALIGN_TYPE
argument_list|)
expr_stmt|;
if|if
condition|(
name|odd_bytes
operator|>
literal|0
condition|)
name|sizeofobject
operator|+=
name|SIZEOF
argument_list|(
name|ALIGN_TYPE
argument_list|)
operator|-
name|odd_bytes
expr_stmt|;
comment|/* See if space is available in any existing pool */
if|if
condition|(
name|pool_id
operator|<
literal|0
operator|||
name|pool_id
operator|>=
name|JPOOL_NUMPOOLS
condition|)
name|ERREXIT1
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_POOL_ID
argument_list|,
name|pool_id
argument_list|)
expr_stmt|;
comment|/* safety check */
name|prev_hdr_ptr
operator|=
name|NULL
expr_stmt|;
name|hdr_ptr
operator|=
name|mem
operator|->
name|small_list
index|[
name|pool_id
index|]
expr_stmt|;
while|while
condition|(
name|hdr_ptr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|hdr_ptr
operator|->
name|hdr
operator|.
name|bytes_left
operator|>=
name|sizeofobject
condition|)
break|break;
comment|/* found pool with enough space */
name|prev_hdr_ptr
operator|=
name|hdr_ptr
expr_stmt|;
name|hdr_ptr
operator|=
name|hdr_ptr
operator|->
name|hdr
operator|.
name|next
expr_stmt|;
block|}
comment|/* Time to make a new pool? */
if|if
condition|(
name|hdr_ptr
operator|==
name|NULL
condition|)
block|{
comment|/* min_request is what we need now, slop is what will be leftover */
name|min_request
operator|=
name|sizeofobject
operator|+
name|SIZEOF
argument_list|(
name|small_pool_hdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev_hdr_ptr
operator|==
name|NULL
condition|)
comment|/* first pool in class? */
name|slop
operator|=
name|first_pool_slop
index|[
name|pool_id
index|]
expr_stmt|;
else|else
name|slop
operator|=
name|extra_pool_slop
index|[
name|pool_id
index|]
expr_stmt|;
comment|/* Don't ask for more than MAX_ALLOC_CHUNK */
if|if
condition|(
name|slop
operator|>
call|(
name|size_t
call|)
argument_list|(
name|MAX_ALLOC_CHUNK
operator|-
name|min_request
argument_list|)
condition|)
name|slop
operator|=
call|(
name|size_t
call|)
argument_list|(
name|MAX_ALLOC_CHUNK
operator|-
name|min_request
argument_list|)
expr_stmt|;
comment|/* Try to get space, if fail reduce slop and try again */
for|for
control|(
init|;
condition|;
control|)
block|{
name|hdr_ptr
operator|=
operator|(
name|small_pool_ptr
operator|)
name|jpeg_get_small
argument_list|(
name|cinfo
argument_list|,
name|min_request
operator|+
name|slop
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr_ptr
operator|!=
name|NULL
condition|)
break|break;
name|slop
operator|/=
literal|2
expr_stmt|;
if|if
condition|(
name|slop
operator|<
name|MIN_SLOP
condition|)
comment|/* give up when it gets real small */
name|out_of_memory
argument_list|(
name|cinfo
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* jpeg_get_small failed */
block|}
name|mem
operator|->
name|total_space_allocated
operator|+=
name|min_request
operator|+
name|slop
expr_stmt|;
comment|/* Success, initialize the new pool header and add to end of list */
name|hdr_ptr
operator|->
name|hdr
operator|.
name|next
operator|=
name|NULL
expr_stmt|;
name|hdr_ptr
operator|->
name|hdr
operator|.
name|bytes_used
operator|=
literal|0
expr_stmt|;
name|hdr_ptr
operator|->
name|hdr
operator|.
name|bytes_left
operator|=
name|sizeofobject
operator|+
name|slop
expr_stmt|;
if|if
condition|(
name|prev_hdr_ptr
operator|==
name|NULL
condition|)
comment|/* first pool in class? */
name|mem
operator|->
name|small_list
index|[
name|pool_id
index|]
operator|=
name|hdr_ptr
expr_stmt|;
else|else
name|prev_hdr_ptr
operator|->
name|hdr
operator|.
name|next
operator|=
name|hdr_ptr
expr_stmt|;
block|}
comment|/* OK, allocate the object from the current pool */
name|data_ptr
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|hdr_ptr
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* point to first data byte in pool */
name|data_ptr
operator|+=
name|hdr_ptr
operator|->
name|hdr
operator|.
name|bytes_used
expr_stmt|;
comment|/* point to place for object */
name|hdr_ptr
operator|->
name|hdr
operator|.
name|bytes_used
operator|+=
name|sizeofobject
expr_stmt|;
name|hdr_ptr
operator|->
name|hdr
operator|.
name|bytes_left
operator|-=
name|sizeofobject
expr_stmt|;
return|return
operator|(
name|void
operator|*
operator|)
name|data_ptr
return|;
block|}
end_block
begin_comment
comment|/*  * Allocation of "large" objects.  *  * The external semantics of these are the same as "small" objects,  * except that FAR pointers are used on 80x86.  However the pool  * management heuristics are quite different.  We assume that each  * request is large enough that it may as well be passed directly to  * jpeg_get_large; the pool management just links everything together  * so that we can free it all on demand.  * Note: the major use of "large" objects is in JSAMPARRAY and JBLOCKARRAY  * structures.  The routines that create these structures (see below)  * deliberately bunch rows together to ensure a large request size.  */
end_comment
begin_macro
name|METHODDEF
argument_list|(
argument|void FAR *
argument_list|)
end_macro
begin_macro
DECL|function|alloc_large
name|alloc_large
argument_list|(
argument|j_common_ptr cinfo
argument_list|,
argument|int pool_id
argument_list|,
argument|size_t sizeofobject
argument_list|)
end_macro
begin_comment
comment|/* Allocate a "large" object */
end_comment
begin_block
block|{
name|my_mem_ptr
name|mem
init|=
operator|(
name|my_mem_ptr
operator|)
name|cinfo
operator|->
name|mem
decl_stmt|;
name|large_pool_ptr
name|hdr_ptr
decl_stmt|;
name|size_t
name|odd_bytes
decl_stmt|;
comment|/* Check for unsatisfiable request (do now to ensure no overflow below) */
if|if
condition|(
name|sizeofobject
operator|>
call|(
name|size_t
call|)
argument_list|(
name|MAX_ALLOC_CHUNK
operator|-
name|SIZEOF
argument_list|(
name|large_pool_hdr
argument_list|)
argument_list|)
condition|)
name|out_of_memory
argument_list|(
name|cinfo
argument_list|,
literal|3
argument_list|)
expr_stmt|;
comment|/* request exceeds malloc's ability */
comment|/* Round up the requested size to a multiple of SIZEOF(ALIGN_TYPE) */
name|odd_bytes
operator|=
name|sizeofobject
operator|%
name|SIZEOF
argument_list|(
name|ALIGN_TYPE
argument_list|)
expr_stmt|;
if|if
condition|(
name|odd_bytes
operator|>
literal|0
condition|)
name|sizeofobject
operator|+=
name|SIZEOF
argument_list|(
name|ALIGN_TYPE
argument_list|)
operator|-
name|odd_bytes
expr_stmt|;
comment|/* Always make a new pool */
if|if
condition|(
name|pool_id
operator|<
literal|0
operator|||
name|pool_id
operator|>=
name|JPOOL_NUMPOOLS
condition|)
name|ERREXIT1
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_POOL_ID
argument_list|,
name|pool_id
argument_list|)
expr_stmt|;
comment|/* safety check */
name|hdr_ptr
operator|=
operator|(
name|large_pool_ptr
operator|)
name|jpeg_get_large
argument_list|(
name|cinfo
argument_list|,
name|sizeofobject
operator|+
name|SIZEOF
argument_list|(
name|large_pool_hdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr_ptr
operator|==
name|NULL
condition|)
name|out_of_memory
argument_list|(
name|cinfo
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* jpeg_get_large failed */
name|mem
operator|->
name|total_space_allocated
operator|+=
name|sizeofobject
operator|+
name|SIZEOF
argument_list|(
name|large_pool_hdr
argument_list|)
expr_stmt|;
comment|/* Success, initialize the new pool header and add to list */
name|hdr_ptr
operator|->
name|hdr
operator|.
name|next
operator|=
name|mem
operator|->
name|large_list
index|[
name|pool_id
index|]
expr_stmt|;
comment|/* We maintain space counts in each pool header for statistical purposes,    * even though they are not needed for allocation.    */
name|hdr_ptr
operator|->
name|hdr
operator|.
name|bytes_used
operator|=
name|sizeofobject
expr_stmt|;
name|hdr_ptr
operator|->
name|hdr
operator|.
name|bytes_left
operator|=
literal|0
expr_stmt|;
name|mem
operator|->
name|large_list
index|[
name|pool_id
index|]
operator|=
name|hdr_ptr
expr_stmt|;
return|return
operator|(
name|void
name|FAR
operator|*
operator|)
operator|(
name|hdr_ptr
operator|+
literal|1
operator|)
return|;
comment|/* point to first data byte in pool */
block|}
end_block
begin_comment
comment|/*  * Creation of 2-D sample arrays.  * The pointers are in near heap, the samples themselves in FAR heap.  *  * To minimize allocation overhead and to allow I/O of large contiguous  * blocks, we allocate the sample rows in groups of as many rows as possible  * without exceeding MAX_ALLOC_CHUNK total bytes per allocation request.  * NB: the virtual array control routines, later in this file, know about  * this chunking of rows.  The rowsperchunk value is left in the mem manager  * object so that it can be saved away if this sarray is the workspace for  * a virtual array.  */
end_comment
begin_macro
DECL|function|METHODDEF
name|METHODDEF
argument_list|(
argument|JSAMPARRAY
argument_list|)
end_macro
begin_macro
name|alloc_sarray
argument_list|(
argument|j_common_ptr cinfo
argument_list|,
argument|int pool_id
argument_list|,
argument|JDIMENSION samplesperrow
argument_list|,
argument|JDIMENSION numrows
argument_list|)
end_macro
begin_comment
comment|/* Allocate a 2-D sample array */
end_comment
begin_block
block|{
name|my_mem_ptr
name|mem
init|=
operator|(
name|my_mem_ptr
operator|)
name|cinfo
operator|->
name|mem
decl_stmt|;
name|JSAMPARRAY
name|result
decl_stmt|;
name|JSAMPROW
name|workspace
decl_stmt|;
name|JDIMENSION
name|rowsperchunk
decl_stmt|,
name|currow
decl_stmt|,
name|i
decl_stmt|;
name|long
name|ltemp
decl_stmt|;
comment|/* Calculate max # of rows allowed in one allocation chunk */
name|ltemp
operator|=
operator|(
name|MAX_ALLOC_CHUNK
operator|-
name|SIZEOF
argument_list|(
name|large_pool_hdr
argument_list|)
operator|)
operator|/
operator|(
operator|(
name|long
operator|)
name|samplesperrow
operator|*
name|SIZEOF
argument_list|(
name|JSAMPLE
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ltemp
operator|<=
literal|0
condition|)
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_WIDTH_OVERFLOW
argument_list|)
expr_stmt|;
if|if
condition|(
name|ltemp
operator|<
operator|(
name|long
operator|)
name|numrows
condition|)
name|rowsperchunk
operator|=
operator|(
name|JDIMENSION
operator|)
name|ltemp
expr_stmt|;
else|else
name|rowsperchunk
operator|=
name|numrows
expr_stmt|;
name|mem
operator|->
name|last_rowsperchunk
operator|=
name|rowsperchunk
expr_stmt|;
comment|/* Get space for row pointers (small object) */
name|result
operator|=
operator|(
name|JSAMPARRAY
operator|)
name|alloc_small
argument_list|(
name|cinfo
argument_list|,
name|pool_id
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|numrows
operator|*
name|SIZEOF
argument_list|(
name|JSAMPROW
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get the rows themselves (large objects) */
name|currow
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|currow
operator|<
name|numrows
condition|)
block|{
name|rowsperchunk
operator|=
name|MIN
argument_list|(
name|rowsperchunk
argument_list|,
name|numrows
operator|-
name|currow
argument_list|)
expr_stmt|;
name|workspace
operator|=
operator|(
name|JSAMPROW
operator|)
name|alloc_large
argument_list|(
name|cinfo
argument_list|,
name|pool_id
argument_list|,
call|(
name|size_t
call|)
argument_list|(
operator|(
name|size_t
operator|)
name|rowsperchunk
operator|*
operator|(
name|size_t
operator|)
name|samplesperrow
operator|*
name|SIZEOF
argument_list|(
name|JSAMPLE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|rowsperchunk
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|result
index|[
name|currow
operator|++
index|]
operator|=
name|workspace
expr_stmt|;
name|workspace
operator|+=
name|samplesperrow
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_block
begin_comment
comment|/*  * Creation of 2-D coefficient-block arrays.  * This is essentially the same as the code for sample arrays, above.  */
end_comment
begin_macro
DECL|function|METHODDEF
name|METHODDEF
argument_list|(
argument|JBLOCKARRAY
argument_list|)
end_macro
begin_macro
name|alloc_barray
argument_list|(
argument|j_common_ptr cinfo
argument_list|,
argument|int pool_id
argument_list|,
argument|JDIMENSION blocksperrow
argument_list|,
argument|JDIMENSION numrows
argument_list|)
end_macro
begin_comment
comment|/* Allocate a 2-D coefficient-block array */
end_comment
begin_block
block|{
name|my_mem_ptr
name|mem
init|=
operator|(
name|my_mem_ptr
operator|)
name|cinfo
operator|->
name|mem
decl_stmt|;
name|JBLOCKARRAY
name|result
decl_stmt|;
name|JBLOCKROW
name|workspace
decl_stmt|;
name|JDIMENSION
name|rowsperchunk
decl_stmt|,
name|currow
decl_stmt|,
name|i
decl_stmt|;
name|long
name|ltemp
decl_stmt|;
comment|/* Calculate max # of rows allowed in one allocation chunk */
name|ltemp
operator|=
operator|(
name|MAX_ALLOC_CHUNK
operator|-
name|SIZEOF
argument_list|(
name|large_pool_hdr
argument_list|)
operator|)
operator|/
operator|(
operator|(
name|long
operator|)
name|blocksperrow
operator|*
name|SIZEOF
argument_list|(
name|JBLOCK
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ltemp
operator|<=
literal|0
condition|)
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_WIDTH_OVERFLOW
argument_list|)
expr_stmt|;
if|if
condition|(
name|ltemp
operator|<
operator|(
name|long
operator|)
name|numrows
condition|)
name|rowsperchunk
operator|=
operator|(
name|JDIMENSION
operator|)
name|ltemp
expr_stmt|;
else|else
name|rowsperchunk
operator|=
name|numrows
expr_stmt|;
name|mem
operator|->
name|last_rowsperchunk
operator|=
name|rowsperchunk
expr_stmt|;
comment|/* Get space for row pointers (small object) */
name|result
operator|=
operator|(
name|JBLOCKARRAY
operator|)
name|alloc_small
argument_list|(
name|cinfo
argument_list|,
name|pool_id
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|numrows
operator|*
name|SIZEOF
argument_list|(
name|JBLOCKROW
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get the rows themselves (large objects) */
name|currow
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|currow
operator|<
name|numrows
condition|)
block|{
name|rowsperchunk
operator|=
name|MIN
argument_list|(
name|rowsperchunk
argument_list|,
name|numrows
operator|-
name|currow
argument_list|)
expr_stmt|;
name|workspace
operator|=
operator|(
name|JBLOCKROW
operator|)
name|alloc_large
argument_list|(
name|cinfo
argument_list|,
name|pool_id
argument_list|,
call|(
name|size_t
call|)
argument_list|(
operator|(
name|size_t
operator|)
name|rowsperchunk
operator|*
operator|(
name|size_t
operator|)
name|blocksperrow
operator|*
name|SIZEOF
argument_list|(
name|JBLOCK
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|rowsperchunk
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|result
index|[
name|currow
operator|++
index|]
operator|=
name|workspace
expr_stmt|;
name|workspace
operator|+=
name|blocksperrow
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_block
begin_comment
comment|/*  * About virtual array management:  *  * The above "normal" array routines are only used to allocate strip buffers  * (as wide as the image, but just a few rows high).  Full-image-sized buffers  * are handled as "virtual" arrays.  The array is still accessed a strip at a  * time, but the memory manager must save the whole array for repeated  * accesses.  The intended implementation is that there is a strip buffer in  * memory (as high as is possible given the desired memory limit), plus a  * backing file that holds the rest of the array.  *  * The request_virt_array routines are told the total size of the image and  * the maximum number of rows that will be accessed at once.  The in-memory  * buffer must be at least as large as the maxaccess value.  *  * The request routines create control blocks but not the in-memory buffers.  * That is postponed until realize_virt_arrays is called.  At that time the  * total amount of space needed is known (approximately, anyway), so free  * memory can be divided up fairly.  *  * The access_virt_array routines are responsible for making a specific strip  * area accessible (after reading or writing the backing file, if necessary).  * Note that the access routines are told whether the caller intends to modify  * the accessed strip; during a read-only pass this saves having to rewrite  * data to disk.  The access routines are also responsible for pre-zeroing  * any newly accessed rows, if pre-zeroing was requested.  *  * In current usage, the access requests are usually for nonoverlapping  * strips; that is, successive access start_row numbers differ by exactly  * num_rows = maxaccess.  This means we can get good performance with simple  * buffer dump/reload logic, by making the in-memory buffer be a multiple  * of the access height; then there will never be accesses across bufferload  * boundaries.  The code will still work with overlapping access requests,  * but it doesn't handle bufferload overlaps very efficiently.  */
end_comment
begin_macro
DECL|function|METHODDEF
name|METHODDEF
argument_list|(
argument|jvirt_sarray_ptr
argument_list|)
end_macro
begin_macro
name|request_virt_sarray
argument_list|(
argument|j_common_ptr cinfo
argument_list|,
argument|int pool_id
argument_list|,
argument|boolean pre_zero
argument_list|,
argument|JDIMENSION samplesperrow
argument_list|,
argument|JDIMENSION numrows
argument_list|,
argument|JDIMENSION maxaccess
argument_list|)
end_macro
begin_comment
comment|/* Request a virtual 2-D sample array */
end_comment
begin_block
block|{
name|my_mem_ptr
name|mem
init|=
operator|(
name|my_mem_ptr
operator|)
name|cinfo
operator|->
name|mem
decl_stmt|;
name|jvirt_sarray_ptr
name|result
decl_stmt|;
comment|/* Only IMAGE-lifetime virtual arrays are currently supported */
if|if
condition|(
name|pool_id
operator|!=
name|JPOOL_IMAGE
condition|)
name|ERREXIT1
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_POOL_ID
argument_list|,
name|pool_id
argument_list|)
expr_stmt|;
comment|/* safety check */
comment|/* get control block */
name|result
operator|=
operator|(
name|jvirt_sarray_ptr
operator|)
name|alloc_small
argument_list|(
name|cinfo
argument_list|,
name|pool_id
argument_list|,
name|SIZEOF
argument_list|(
expr|struct
name|jvirt_sarray_control
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|->
name|mem_buffer
operator|=
name|NULL
expr_stmt|;
comment|/* marks array not yet realized */
name|result
operator|->
name|rows_in_array
operator|=
name|numrows
expr_stmt|;
name|result
operator|->
name|samplesperrow
operator|=
name|samplesperrow
expr_stmt|;
name|result
operator|->
name|maxaccess
operator|=
name|maxaccess
expr_stmt|;
name|result
operator|->
name|pre_zero
operator|=
name|pre_zero
expr_stmt|;
name|result
operator|->
name|b_s_open
operator|=
name|FALSE
expr_stmt|;
comment|/* no associated backing-store object */
name|result
operator|->
name|next
operator|=
name|mem
operator|->
name|virt_sarray_list
expr_stmt|;
comment|/* add to list of virtual arrays */
name|mem
operator|->
name|virt_sarray_list
operator|=
name|result
expr_stmt|;
return|return
name|result
return|;
block|}
end_block
begin_macro
DECL|function|METHODDEF
name|METHODDEF
argument_list|(
argument|jvirt_barray_ptr
argument_list|)
end_macro
begin_macro
name|request_virt_barray
argument_list|(
argument|j_common_ptr cinfo
argument_list|,
argument|int pool_id
argument_list|,
argument|boolean pre_zero
argument_list|,
argument|JDIMENSION blocksperrow
argument_list|,
argument|JDIMENSION numrows
argument_list|,
argument|JDIMENSION maxaccess
argument_list|)
end_macro
begin_comment
comment|/* Request a virtual 2-D coefficient-block array */
end_comment
begin_block
block|{
name|my_mem_ptr
name|mem
init|=
operator|(
name|my_mem_ptr
operator|)
name|cinfo
operator|->
name|mem
decl_stmt|;
name|jvirt_barray_ptr
name|result
decl_stmt|;
comment|/* Only IMAGE-lifetime virtual arrays are currently supported */
if|if
condition|(
name|pool_id
operator|!=
name|JPOOL_IMAGE
condition|)
name|ERREXIT1
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_POOL_ID
argument_list|,
name|pool_id
argument_list|)
expr_stmt|;
comment|/* safety check */
comment|/* get control block */
name|result
operator|=
operator|(
name|jvirt_barray_ptr
operator|)
name|alloc_small
argument_list|(
name|cinfo
argument_list|,
name|pool_id
argument_list|,
name|SIZEOF
argument_list|(
expr|struct
name|jvirt_barray_control
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|->
name|mem_buffer
operator|=
name|NULL
expr_stmt|;
comment|/* marks array not yet realized */
name|result
operator|->
name|rows_in_array
operator|=
name|numrows
expr_stmt|;
name|result
operator|->
name|blocksperrow
operator|=
name|blocksperrow
expr_stmt|;
name|result
operator|->
name|maxaccess
operator|=
name|maxaccess
expr_stmt|;
name|result
operator|->
name|pre_zero
operator|=
name|pre_zero
expr_stmt|;
name|result
operator|->
name|b_s_open
operator|=
name|FALSE
expr_stmt|;
comment|/* no associated backing-store object */
name|result
operator|->
name|next
operator|=
name|mem
operator|->
name|virt_barray_list
expr_stmt|;
comment|/* add to list of virtual arrays */
name|mem
operator|->
name|virt_barray_list
operator|=
name|result
expr_stmt|;
return|return
name|result
return|;
block|}
end_block
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|realize_virt_arrays
name|realize_virt_arrays
argument_list|(
argument|j_common_ptr cinfo
argument_list|)
end_macro
begin_comment
comment|/* Allocate the in-memory buffers for any unrealized virtual arrays */
end_comment
begin_block
block|{
name|my_mem_ptr
name|mem
init|=
operator|(
name|my_mem_ptr
operator|)
name|cinfo
operator|->
name|mem
decl_stmt|;
name|long
name|space_per_minheight
decl_stmt|,
name|maximum_space
decl_stmt|,
name|avail_mem
decl_stmt|;
name|long
name|minheights
decl_stmt|,
name|max_minheights
decl_stmt|;
name|jvirt_sarray_ptr
name|sptr
decl_stmt|;
name|jvirt_barray_ptr
name|bptr
decl_stmt|;
comment|/* Compute the minimum space needed (maxaccess rows in each buffer)    * and the maximum space needed (full image height in each buffer).    * These may be of use to the system-dependent jpeg_mem_available routine.    */
name|space_per_minheight
operator|=
literal|0
expr_stmt|;
name|maximum_space
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|sptr
operator|=
name|mem
operator|->
name|virt_sarray_list
init|;
name|sptr
operator|!=
name|NULL
condition|;
name|sptr
operator|=
name|sptr
operator|->
name|next
control|)
block|{
if|if
condition|(
name|sptr
operator|->
name|mem_buffer
operator|==
name|NULL
condition|)
block|{
comment|/* if not realized yet */
name|space_per_minheight
operator|+=
operator|(
name|long
operator|)
name|sptr
operator|->
name|maxaccess
operator|*
operator|(
name|long
operator|)
name|sptr
operator|->
name|samplesperrow
operator|*
name|SIZEOF
argument_list|(
name|JSAMPLE
argument_list|)
expr_stmt|;
name|maximum_space
operator|+=
operator|(
name|long
operator|)
name|sptr
operator|->
name|rows_in_array
operator|*
operator|(
name|long
operator|)
name|sptr
operator|->
name|samplesperrow
operator|*
name|SIZEOF
argument_list|(
name|JSAMPLE
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|bptr
operator|=
name|mem
operator|->
name|virt_barray_list
init|;
name|bptr
operator|!=
name|NULL
condition|;
name|bptr
operator|=
name|bptr
operator|->
name|next
control|)
block|{
if|if
condition|(
name|bptr
operator|->
name|mem_buffer
operator|==
name|NULL
condition|)
block|{
comment|/* if not realized yet */
name|space_per_minheight
operator|+=
operator|(
name|long
operator|)
name|bptr
operator|->
name|maxaccess
operator|*
operator|(
name|long
operator|)
name|bptr
operator|->
name|blocksperrow
operator|*
name|SIZEOF
argument_list|(
name|JBLOCK
argument_list|)
expr_stmt|;
name|maximum_space
operator|+=
operator|(
name|long
operator|)
name|bptr
operator|->
name|rows_in_array
operator|*
operator|(
name|long
operator|)
name|bptr
operator|->
name|blocksperrow
operator|*
name|SIZEOF
argument_list|(
name|JBLOCK
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|space_per_minheight
operator|<=
literal|0
condition|)
return|return;
comment|/* no unrealized arrays, no work */
comment|/* Determine amount of memory to actually use; this is system-dependent. */
name|avail_mem
operator|=
name|jpeg_mem_available
argument_list|(
name|cinfo
argument_list|,
name|space_per_minheight
argument_list|,
name|maximum_space
argument_list|,
name|mem
operator|->
name|total_space_allocated
argument_list|)
expr_stmt|;
comment|/* If the maximum space needed is available, make all the buffers full    * height; otherwise parcel it out with the same number of minheights    * in each buffer.    */
if|if
condition|(
name|avail_mem
operator|>=
name|maximum_space
condition|)
name|max_minheights
operator|=
literal|1000000000L
expr_stmt|;
else|else
block|{
name|max_minheights
operator|=
name|avail_mem
operator|/
name|space_per_minheight
expr_stmt|;
comment|/* If there doesn't seem to be enough space, try to get the minimum      * anyway.  This allows a "stub" implementation of jpeg_mem_available().      */
if|if
condition|(
name|max_minheights
operator|<=
literal|0
condition|)
name|max_minheights
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Allocate the in-memory buffers and initialize backing store as needed. */
for|for
control|(
name|sptr
operator|=
name|mem
operator|->
name|virt_sarray_list
init|;
name|sptr
operator|!=
name|NULL
condition|;
name|sptr
operator|=
name|sptr
operator|->
name|next
control|)
block|{
if|if
condition|(
name|sptr
operator|->
name|mem_buffer
operator|==
name|NULL
condition|)
block|{
comment|/* if not realized yet */
name|minheights
operator|=
operator|(
operator|(
name|long
operator|)
name|sptr
operator|->
name|rows_in_array
operator|-
literal|1L
operator|)
operator|/
name|sptr
operator|->
name|maxaccess
operator|+
literal|1L
expr_stmt|;
if|if
condition|(
name|minheights
operator|<=
name|max_minheights
condition|)
block|{
comment|/* This buffer fits in memory */
name|sptr
operator|->
name|rows_in_mem
operator|=
name|sptr
operator|->
name|rows_in_array
expr_stmt|;
block|}
else|else
block|{
comment|/* It doesn't fit in memory, create backing store. */
name|sptr
operator|->
name|rows_in_mem
operator|=
call|(
name|JDIMENSION
call|)
argument_list|(
name|max_minheights
operator|*
name|sptr
operator|->
name|maxaccess
argument_list|)
expr_stmt|;
name|jpeg_open_backing_store
argument_list|(
name|cinfo
argument_list|,
operator|&
name|sptr
operator|->
name|b_s_info
argument_list|,
operator|(
name|long
operator|)
name|sptr
operator|->
name|rows_in_array
operator|*
operator|(
name|long
operator|)
name|sptr
operator|->
name|samplesperrow
operator|*
operator|(
name|long
operator|)
name|SIZEOF
argument_list|(
name|JSAMPLE
argument_list|)
argument_list|)
expr_stmt|;
name|sptr
operator|->
name|b_s_open
operator|=
name|TRUE
expr_stmt|;
block|}
name|sptr
operator|->
name|mem_buffer
operator|=
name|alloc_sarray
argument_list|(
name|cinfo
argument_list|,
name|JPOOL_IMAGE
argument_list|,
name|sptr
operator|->
name|samplesperrow
argument_list|,
name|sptr
operator|->
name|rows_in_mem
argument_list|)
expr_stmt|;
name|sptr
operator|->
name|rowsperchunk
operator|=
name|mem
operator|->
name|last_rowsperchunk
expr_stmt|;
name|sptr
operator|->
name|cur_start_row
operator|=
literal|0
expr_stmt|;
name|sptr
operator|->
name|first_undef_row
operator|=
literal|0
expr_stmt|;
name|sptr
operator|->
name|dirty
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
for|for
control|(
name|bptr
operator|=
name|mem
operator|->
name|virt_barray_list
init|;
name|bptr
operator|!=
name|NULL
condition|;
name|bptr
operator|=
name|bptr
operator|->
name|next
control|)
block|{
if|if
condition|(
name|bptr
operator|->
name|mem_buffer
operator|==
name|NULL
condition|)
block|{
comment|/* if not realized yet */
name|minheights
operator|=
operator|(
operator|(
name|long
operator|)
name|bptr
operator|->
name|rows_in_array
operator|-
literal|1L
operator|)
operator|/
name|bptr
operator|->
name|maxaccess
operator|+
literal|1L
expr_stmt|;
if|if
condition|(
name|minheights
operator|<=
name|max_minheights
condition|)
block|{
comment|/* This buffer fits in memory */
name|bptr
operator|->
name|rows_in_mem
operator|=
name|bptr
operator|->
name|rows_in_array
expr_stmt|;
block|}
else|else
block|{
comment|/* It doesn't fit in memory, create backing store. */
name|bptr
operator|->
name|rows_in_mem
operator|=
call|(
name|JDIMENSION
call|)
argument_list|(
name|max_minheights
operator|*
name|bptr
operator|->
name|maxaccess
argument_list|)
expr_stmt|;
name|jpeg_open_backing_store
argument_list|(
name|cinfo
argument_list|,
operator|&
name|bptr
operator|->
name|b_s_info
argument_list|,
operator|(
name|long
operator|)
name|bptr
operator|->
name|rows_in_array
operator|*
operator|(
name|long
operator|)
name|bptr
operator|->
name|blocksperrow
operator|*
operator|(
name|long
operator|)
name|SIZEOF
argument_list|(
name|JBLOCK
argument_list|)
argument_list|)
expr_stmt|;
name|bptr
operator|->
name|b_s_open
operator|=
name|TRUE
expr_stmt|;
block|}
name|bptr
operator|->
name|mem_buffer
operator|=
name|alloc_barray
argument_list|(
name|cinfo
argument_list|,
name|JPOOL_IMAGE
argument_list|,
name|bptr
operator|->
name|blocksperrow
argument_list|,
name|bptr
operator|->
name|rows_in_mem
argument_list|)
expr_stmt|;
name|bptr
operator|->
name|rowsperchunk
operator|=
name|mem
operator|->
name|last_rowsperchunk
expr_stmt|;
name|bptr
operator|->
name|cur_start_row
operator|=
literal|0
expr_stmt|;
name|bptr
operator|->
name|first_undef_row
operator|=
literal|0
expr_stmt|;
name|bptr
operator|->
name|dirty
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
block|}
end_block
begin_macro
name|LOCAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|do_sarray_io
name|do_sarray_io
argument_list|(
argument|j_common_ptr cinfo
argument_list|,
argument|jvirt_sarray_ptr ptr
argument_list|,
argument|boolean writing
argument_list|)
end_macro
begin_comment
comment|/* Do backing store read or write of a virtual sample array */
end_comment
begin_block
block|{
name|long
name|bytesperrow
decl_stmt|,
name|file_offset
decl_stmt|,
name|byte_count
decl_stmt|,
name|rows
decl_stmt|,
name|thisrow
decl_stmt|,
name|i
decl_stmt|;
name|bytesperrow
operator|=
operator|(
name|long
operator|)
name|ptr
operator|->
name|samplesperrow
operator|*
name|SIZEOF
argument_list|(
name|JSAMPLE
argument_list|)
expr_stmt|;
name|file_offset
operator|=
name|ptr
operator|->
name|cur_start_row
operator|*
name|bytesperrow
expr_stmt|;
comment|/* Loop to read or write each allocation chunk in mem_buffer */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|long
operator|)
name|ptr
operator|->
name|rows_in_mem
condition|;
name|i
operator|+=
name|ptr
operator|->
name|rowsperchunk
control|)
block|{
comment|/* One chunk, but check for short chunk at end of buffer */
name|rows
operator|=
name|MIN
argument_list|(
operator|(
name|long
operator|)
name|ptr
operator|->
name|rowsperchunk
argument_list|,
operator|(
name|long
operator|)
name|ptr
operator|->
name|rows_in_mem
operator|-
name|i
argument_list|)
expr_stmt|;
comment|/* Transfer no more than is currently defined */
name|thisrow
operator|=
operator|(
name|long
operator|)
name|ptr
operator|->
name|cur_start_row
operator|+
name|i
expr_stmt|;
name|rows
operator|=
name|MIN
argument_list|(
name|rows
argument_list|,
operator|(
name|long
operator|)
name|ptr
operator|->
name|first_undef_row
operator|-
name|thisrow
argument_list|)
expr_stmt|;
comment|/* Transfer no more than fits in file */
name|rows
operator|=
name|MIN
argument_list|(
name|rows
argument_list|,
operator|(
name|long
operator|)
name|ptr
operator|->
name|rows_in_array
operator|-
name|thisrow
argument_list|)
expr_stmt|;
if|if
condition|(
name|rows
operator|<=
literal|0
condition|)
comment|/* this chunk might be past end of file! */
break|break;
name|byte_count
operator|=
name|rows
operator|*
name|bytesperrow
expr_stmt|;
if|if
condition|(
name|writing
condition|)
call|(
modifier|*
name|ptr
operator|->
name|b_s_info
operator|.
name|write_backing_store
call|)
argument_list|(
name|cinfo
argument_list|,
operator|&
name|ptr
operator|->
name|b_s_info
argument_list|,
operator|(
name|void
name|FAR
operator|*
operator|)
name|ptr
operator|->
name|mem_buffer
index|[
name|i
index|]
argument_list|,
name|file_offset
argument_list|,
name|byte_count
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|ptr
operator|->
name|b_s_info
operator|.
name|read_backing_store
call|)
argument_list|(
name|cinfo
argument_list|,
operator|&
name|ptr
operator|->
name|b_s_info
argument_list|,
operator|(
name|void
name|FAR
operator|*
operator|)
name|ptr
operator|->
name|mem_buffer
index|[
name|i
index|]
argument_list|,
name|file_offset
argument_list|,
name|byte_count
argument_list|)
expr_stmt|;
name|file_offset
operator|+=
name|byte_count
expr_stmt|;
block|}
block|}
end_block
begin_macro
name|LOCAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|do_barray_io
name|do_barray_io
argument_list|(
argument|j_common_ptr cinfo
argument_list|,
argument|jvirt_barray_ptr ptr
argument_list|,
argument|boolean writing
argument_list|)
end_macro
begin_comment
comment|/* Do backing store read or write of a virtual coefficient-block array */
end_comment
begin_block
block|{
name|long
name|bytesperrow
decl_stmt|,
name|file_offset
decl_stmt|,
name|byte_count
decl_stmt|,
name|rows
decl_stmt|,
name|thisrow
decl_stmt|,
name|i
decl_stmt|;
name|bytesperrow
operator|=
operator|(
name|long
operator|)
name|ptr
operator|->
name|blocksperrow
operator|*
name|SIZEOF
argument_list|(
name|JBLOCK
argument_list|)
expr_stmt|;
name|file_offset
operator|=
name|ptr
operator|->
name|cur_start_row
operator|*
name|bytesperrow
expr_stmt|;
comment|/* Loop to read or write each allocation chunk in mem_buffer */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|long
operator|)
name|ptr
operator|->
name|rows_in_mem
condition|;
name|i
operator|+=
name|ptr
operator|->
name|rowsperchunk
control|)
block|{
comment|/* One chunk, but check for short chunk at end of buffer */
name|rows
operator|=
name|MIN
argument_list|(
operator|(
name|long
operator|)
name|ptr
operator|->
name|rowsperchunk
argument_list|,
operator|(
name|long
operator|)
name|ptr
operator|->
name|rows_in_mem
operator|-
name|i
argument_list|)
expr_stmt|;
comment|/* Transfer no more than is currently defined */
name|thisrow
operator|=
operator|(
name|long
operator|)
name|ptr
operator|->
name|cur_start_row
operator|+
name|i
expr_stmt|;
name|rows
operator|=
name|MIN
argument_list|(
name|rows
argument_list|,
operator|(
name|long
operator|)
name|ptr
operator|->
name|first_undef_row
operator|-
name|thisrow
argument_list|)
expr_stmt|;
comment|/* Transfer no more than fits in file */
name|rows
operator|=
name|MIN
argument_list|(
name|rows
argument_list|,
operator|(
name|long
operator|)
name|ptr
operator|->
name|rows_in_array
operator|-
name|thisrow
argument_list|)
expr_stmt|;
if|if
condition|(
name|rows
operator|<=
literal|0
condition|)
comment|/* this chunk might be past end of file! */
break|break;
name|byte_count
operator|=
name|rows
operator|*
name|bytesperrow
expr_stmt|;
if|if
condition|(
name|writing
condition|)
call|(
modifier|*
name|ptr
operator|->
name|b_s_info
operator|.
name|write_backing_store
call|)
argument_list|(
name|cinfo
argument_list|,
operator|&
name|ptr
operator|->
name|b_s_info
argument_list|,
operator|(
name|void
name|FAR
operator|*
operator|)
name|ptr
operator|->
name|mem_buffer
index|[
name|i
index|]
argument_list|,
name|file_offset
argument_list|,
name|byte_count
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|ptr
operator|->
name|b_s_info
operator|.
name|read_backing_store
call|)
argument_list|(
name|cinfo
argument_list|,
operator|&
name|ptr
operator|->
name|b_s_info
argument_list|,
operator|(
name|void
name|FAR
operator|*
operator|)
name|ptr
operator|->
name|mem_buffer
index|[
name|i
index|]
argument_list|,
name|file_offset
argument_list|,
name|byte_count
argument_list|)
expr_stmt|;
name|file_offset
operator|+=
name|byte_count
expr_stmt|;
block|}
block|}
end_block
begin_macro
DECL|function|METHODDEF
name|METHODDEF
argument_list|(
argument|JSAMPARRAY
argument_list|)
end_macro
begin_macro
name|access_virt_sarray
argument_list|(
argument|j_common_ptr cinfo
argument_list|,
argument|jvirt_sarray_ptr ptr
argument_list|,
argument|JDIMENSION start_row
argument_list|,
argument|JDIMENSION num_rows
argument_list|,
argument|boolean writable
argument_list|)
end_macro
begin_comment
comment|/* Access the part of a virtual sample array starting at start_row */
end_comment
begin_comment
comment|/* and extending for num_rows rows.  writable is true if  */
end_comment
begin_comment
comment|/* caller intends to modify the accessed area. */
end_comment
begin_block
block|{
name|JDIMENSION
name|end_row
init|=
name|start_row
operator|+
name|num_rows
decl_stmt|;
name|JDIMENSION
name|undef_row
decl_stmt|;
comment|/* debugging check */
if|if
condition|(
name|end_row
operator|>
name|ptr
operator|->
name|rows_in_array
operator|||
name|num_rows
operator|>
name|ptr
operator|->
name|maxaccess
operator|||
name|ptr
operator|->
name|mem_buffer
operator|==
name|NULL
condition|)
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_VIRTUAL_ACCESS
argument_list|)
expr_stmt|;
comment|/* Make the desired part of the virtual array accessible */
if|if
condition|(
name|start_row
operator|<
name|ptr
operator|->
name|cur_start_row
operator|||
name|end_row
operator|>
name|ptr
operator|->
name|cur_start_row
operator|+
name|ptr
operator|->
name|rows_in_mem
condition|)
block|{
if|if
condition|(
operator|!
name|ptr
operator|->
name|b_s_open
condition|)
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_VIRTUAL_BUG
argument_list|)
expr_stmt|;
comment|/* Flush old buffer contents if necessary */
if|if
condition|(
name|ptr
operator|->
name|dirty
condition|)
block|{
name|do_sarray_io
argument_list|(
name|cinfo
argument_list|,
name|ptr
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|dirty
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/* Decide what part of virtual array to access.      * Algorithm: if target address> current window, assume forward scan,      * load starting at target address.  If target address< current window,      * assume backward scan, load so that target area is top of window.      * Note that when switching from forward write to forward read, will have      * start_row = 0, so the limiting case applies and we load from 0 anyway.      */
if|if
condition|(
name|start_row
operator|>
name|ptr
operator|->
name|cur_start_row
condition|)
block|{
name|ptr
operator|->
name|cur_start_row
operator|=
name|start_row
expr_stmt|;
block|}
else|else
block|{
comment|/* use long arithmetic here to avoid overflow& unsigned problems */
name|long
name|ltemp
decl_stmt|;
name|ltemp
operator|=
operator|(
name|long
operator|)
name|end_row
operator|-
operator|(
name|long
operator|)
name|ptr
operator|->
name|rows_in_mem
expr_stmt|;
if|if
condition|(
name|ltemp
operator|<
literal|0
condition|)
name|ltemp
operator|=
literal|0
expr_stmt|;
comment|/* don't fall off front end of file */
name|ptr
operator|->
name|cur_start_row
operator|=
operator|(
name|JDIMENSION
operator|)
name|ltemp
expr_stmt|;
block|}
comment|/* Read in the selected part of the array.      * During the initial write pass, we will do no actual read      * because the selected part is all undefined.      */
name|do_sarray_io
argument_list|(
name|cinfo
argument_list|,
name|ptr
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* Ensure the accessed part of the array is defined; prezero if needed.    * To improve locality of access, we only prezero the part of the array    * that the caller is about to access, not the entire in-memory array.    */
if|if
condition|(
name|ptr
operator|->
name|first_undef_row
operator|<
name|end_row
condition|)
block|{
if|if
condition|(
name|ptr
operator|->
name|first_undef_row
operator|<
name|start_row
condition|)
block|{
if|if
condition|(
name|writable
condition|)
comment|/* writer skipped over a section of array */
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_VIRTUAL_ACCESS
argument_list|)
expr_stmt|;
name|undef_row
operator|=
name|start_row
expr_stmt|;
comment|/* but reader is allowed to read ahead */
block|}
else|else
block|{
name|undef_row
operator|=
name|ptr
operator|->
name|first_undef_row
expr_stmt|;
block|}
if|if
condition|(
name|writable
condition|)
name|ptr
operator|->
name|first_undef_row
operator|=
name|end_row
expr_stmt|;
if|if
condition|(
name|ptr
operator|->
name|pre_zero
condition|)
block|{
name|size_t
name|bytesperrow
init|=
operator|(
name|size_t
operator|)
name|ptr
operator|->
name|samplesperrow
operator|*
name|SIZEOF
argument_list|(
name|JSAMPLE
argument_list|)
decl_stmt|;
name|undef_row
operator|-=
name|ptr
operator|->
name|cur_start_row
expr_stmt|;
comment|/* make indexes relative to buffer */
name|end_row
operator|-=
name|ptr
operator|->
name|cur_start_row
expr_stmt|;
while|while
condition|(
name|undef_row
operator|<
name|end_row
condition|)
block|{
name|jzero_far
argument_list|(
operator|(
name|void
name|FAR
operator|*
operator|)
name|ptr
operator|->
name|mem_buffer
index|[
name|undef_row
index|]
argument_list|,
name|bytesperrow
argument_list|)
expr_stmt|;
name|undef_row
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|writable
condition|)
comment|/* reader looking at undefined data */
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_VIRTUAL_ACCESS
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Flag the buffer dirty if caller will write in it */
if|if
condition|(
name|writable
condition|)
name|ptr
operator|->
name|dirty
operator|=
name|TRUE
expr_stmt|;
comment|/* Return address of proper part of the buffer */
return|return
name|ptr
operator|->
name|mem_buffer
operator|+
operator|(
name|start_row
operator|-
name|ptr
operator|->
name|cur_start_row
operator|)
return|;
block|}
end_block
begin_macro
DECL|function|METHODDEF
name|METHODDEF
argument_list|(
argument|JBLOCKARRAY
argument_list|)
end_macro
begin_macro
name|access_virt_barray
argument_list|(
argument|j_common_ptr cinfo
argument_list|,
argument|jvirt_barray_ptr ptr
argument_list|,
argument|JDIMENSION start_row
argument_list|,
argument|JDIMENSION num_rows
argument_list|,
argument|boolean writable
argument_list|)
end_macro
begin_comment
comment|/* Access the part of a virtual block array starting at start_row */
end_comment
begin_comment
comment|/* and extending for num_rows rows.  writable is true if  */
end_comment
begin_comment
comment|/* caller intends to modify the accessed area. */
end_comment
begin_block
block|{
name|JDIMENSION
name|end_row
init|=
name|start_row
operator|+
name|num_rows
decl_stmt|;
name|JDIMENSION
name|undef_row
decl_stmt|;
comment|/* debugging check */
if|if
condition|(
name|end_row
operator|>
name|ptr
operator|->
name|rows_in_array
operator|||
name|num_rows
operator|>
name|ptr
operator|->
name|maxaccess
operator|||
name|ptr
operator|->
name|mem_buffer
operator|==
name|NULL
condition|)
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_VIRTUAL_ACCESS
argument_list|)
expr_stmt|;
comment|/* Make the desired part of the virtual array accessible */
if|if
condition|(
name|start_row
operator|<
name|ptr
operator|->
name|cur_start_row
operator|||
name|end_row
operator|>
name|ptr
operator|->
name|cur_start_row
operator|+
name|ptr
operator|->
name|rows_in_mem
condition|)
block|{
if|if
condition|(
operator|!
name|ptr
operator|->
name|b_s_open
condition|)
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_VIRTUAL_BUG
argument_list|)
expr_stmt|;
comment|/* Flush old buffer contents if necessary */
if|if
condition|(
name|ptr
operator|->
name|dirty
condition|)
block|{
name|do_barray_io
argument_list|(
name|cinfo
argument_list|,
name|ptr
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|dirty
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/* Decide what part of virtual array to access.      * Algorithm: if target address> current window, assume forward scan,      * load starting at target address.  If target address< current window,      * assume backward scan, load so that target area is top of window.      * Note that when switching from forward write to forward read, will have      * start_row = 0, so the limiting case applies and we load from 0 anyway.      */
if|if
condition|(
name|start_row
operator|>
name|ptr
operator|->
name|cur_start_row
condition|)
block|{
name|ptr
operator|->
name|cur_start_row
operator|=
name|start_row
expr_stmt|;
block|}
else|else
block|{
comment|/* use long arithmetic here to avoid overflow& unsigned problems */
name|long
name|ltemp
decl_stmt|;
name|ltemp
operator|=
operator|(
name|long
operator|)
name|end_row
operator|-
operator|(
name|long
operator|)
name|ptr
operator|->
name|rows_in_mem
expr_stmt|;
if|if
condition|(
name|ltemp
operator|<
literal|0
condition|)
name|ltemp
operator|=
literal|0
expr_stmt|;
comment|/* don't fall off front end of file */
name|ptr
operator|->
name|cur_start_row
operator|=
operator|(
name|JDIMENSION
operator|)
name|ltemp
expr_stmt|;
block|}
comment|/* Read in the selected part of the array.      * During the initial write pass, we will do no actual read      * because the selected part is all undefined.      */
name|do_barray_io
argument_list|(
name|cinfo
argument_list|,
name|ptr
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* Ensure the accessed part of the array is defined; prezero if needed.    * To improve locality of access, we only prezero the part of the array    * that the caller is about to access, not the entire in-memory array.    */
if|if
condition|(
name|ptr
operator|->
name|first_undef_row
operator|<
name|end_row
condition|)
block|{
if|if
condition|(
name|ptr
operator|->
name|first_undef_row
operator|<
name|start_row
condition|)
block|{
if|if
condition|(
name|writable
condition|)
comment|/* writer skipped over a section of array */
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_VIRTUAL_ACCESS
argument_list|)
expr_stmt|;
name|undef_row
operator|=
name|start_row
expr_stmt|;
comment|/* but reader is allowed to read ahead */
block|}
else|else
block|{
name|undef_row
operator|=
name|ptr
operator|->
name|first_undef_row
expr_stmt|;
block|}
if|if
condition|(
name|writable
condition|)
name|ptr
operator|->
name|first_undef_row
operator|=
name|end_row
expr_stmt|;
if|if
condition|(
name|ptr
operator|->
name|pre_zero
condition|)
block|{
name|size_t
name|bytesperrow
init|=
operator|(
name|size_t
operator|)
name|ptr
operator|->
name|blocksperrow
operator|*
name|SIZEOF
argument_list|(
name|JBLOCK
argument_list|)
decl_stmt|;
name|undef_row
operator|-=
name|ptr
operator|->
name|cur_start_row
expr_stmt|;
comment|/* make indexes relative to buffer */
name|end_row
operator|-=
name|ptr
operator|->
name|cur_start_row
expr_stmt|;
while|while
condition|(
name|undef_row
operator|<
name|end_row
condition|)
block|{
name|jzero_far
argument_list|(
operator|(
name|void
name|FAR
operator|*
operator|)
name|ptr
operator|->
name|mem_buffer
index|[
name|undef_row
index|]
argument_list|,
name|bytesperrow
argument_list|)
expr_stmt|;
name|undef_row
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|writable
condition|)
comment|/* reader looking at undefined data */
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_VIRTUAL_ACCESS
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Flag the buffer dirty if caller will write in it */
if|if
condition|(
name|writable
condition|)
name|ptr
operator|->
name|dirty
operator|=
name|TRUE
expr_stmt|;
comment|/* Return address of proper part of the buffer */
return|return
name|ptr
operator|->
name|mem_buffer
operator|+
operator|(
name|start_row
operator|-
name|ptr
operator|->
name|cur_start_row
operator|)
return|;
block|}
end_block
begin_comment
comment|/*  * Release all objects belonging to a specified pool.  */
end_comment
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|free_pool
name|free_pool
argument_list|(
argument|j_common_ptr cinfo
argument_list|,
argument|int pool_id
argument_list|)
end_macro
begin_block
block|{
name|my_mem_ptr
name|mem
init|=
operator|(
name|my_mem_ptr
operator|)
name|cinfo
operator|->
name|mem
decl_stmt|;
name|small_pool_ptr
name|shdr_ptr
decl_stmt|;
name|large_pool_ptr
name|lhdr_ptr
decl_stmt|;
name|size_t
name|space_freed
decl_stmt|;
if|if
condition|(
name|pool_id
operator|<
literal|0
operator|||
name|pool_id
operator|>=
name|JPOOL_NUMPOOLS
condition|)
name|ERREXIT1
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_POOL_ID
argument_list|,
name|pool_id
argument_list|)
expr_stmt|;
comment|/* safety check */
ifdef|#
directive|ifdef
name|MEM_STATS
if|if
condition|(
name|cinfo
operator|->
name|err
operator|->
name|trace_level
operator|>
literal|1
condition|)
name|print_mem_stats
argument_list|(
name|cinfo
argument_list|,
name|pool_id
argument_list|)
expr_stmt|;
comment|/* print pool's memory usage statistics */
endif|#
directive|endif
comment|/* If freeing IMAGE pool, close any virtual arrays first */
if|if
condition|(
name|pool_id
operator|==
name|JPOOL_IMAGE
condition|)
block|{
name|jvirt_sarray_ptr
name|sptr
decl_stmt|;
name|jvirt_barray_ptr
name|bptr
decl_stmt|;
for|for
control|(
name|sptr
operator|=
name|mem
operator|->
name|virt_sarray_list
init|;
name|sptr
operator|!=
name|NULL
condition|;
name|sptr
operator|=
name|sptr
operator|->
name|next
control|)
block|{
if|if
condition|(
name|sptr
operator|->
name|b_s_open
condition|)
block|{
comment|/* there may be no backing store */
name|sptr
operator|->
name|b_s_open
operator|=
name|FALSE
expr_stmt|;
comment|/* prevent recursive close if error */
call|(
modifier|*
name|sptr
operator|->
name|b_s_info
operator|.
name|close_backing_store
call|)
argument_list|(
name|cinfo
argument_list|,
operator|&
name|sptr
operator|->
name|b_s_info
argument_list|)
expr_stmt|;
block|}
block|}
name|mem
operator|->
name|virt_sarray_list
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|bptr
operator|=
name|mem
operator|->
name|virt_barray_list
init|;
name|bptr
operator|!=
name|NULL
condition|;
name|bptr
operator|=
name|bptr
operator|->
name|next
control|)
block|{
if|if
condition|(
name|bptr
operator|->
name|b_s_open
condition|)
block|{
comment|/* there may be no backing store */
name|bptr
operator|->
name|b_s_open
operator|=
name|FALSE
expr_stmt|;
comment|/* prevent recursive close if error */
call|(
modifier|*
name|bptr
operator|->
name|b_s_info
operator|.
name|close_backing_store
call|)
argument_list|(
name|cinfo
argument_list|,
operator|&
name|bptr
operator|->
name|b_s_info
argument_list|)
expr_stmt|;
block|}
block|}
name|mem
operator|->
name|virt_barray_list
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Release large objects */
name|lhdr_ptr
operator|=
name|mem
operator|->
name|large_list
index|[
name|pool_id
index|]
expr_stmt|;
name|mem
operator|->
name|large_list
index|[
name|pool_id
index|]
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|lhdr_ptr
operator|!=
name|NULL
condition|)
block|{
name|large_pool_ptr
name|next_lhdr_ptr
init|=
name|lhdr_ptr
operator|->
name|hdr
operator|.
name|next
decl_stmt|;
name|space_freed
operator|=
name|lhdr_ptr
operator|->
name|hdr
operator|.
name|bytes_used
operator|+
name|lhdr_ptr
operator|->
name|hdr
operator|.
name|bytes_left
operator|+
name|SIZEOF
argument_list|(
name|large_pool_hdr
argument_list|)
expr_stmt|;
name|jpeg_free_large
argument_list|(
name|cinfo
argument_list|,
operator|(
name|void
name|FAR
operator|*
operator|)
name|lhdr_ptr
argument_list|,
name|space_freed
argument_list|)
expr_stmt|;
name|mem
operator|->
name|total_space_allocated
operator|-=
name|space_freed
expr_stmt|;
name|lhdr_ptr
operator|=
name|next_lhdr_ptr
expr_stmt|;
block|}
comment|/* Release small objects */
name|shdr_ptr
operator|=
name|mem
operator|->
name|small_list
index|[
name|pool_id
index|]
expr_stmt|;
name|mem
operator|->
name|small_list
index|[
name|pool_id
index|]
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|shdr_ptr
operator|!=
name|NULL
condition|)
block|{
name|small_pool_ptr
name|next_shdr_ptr
init|=
name|shdr_ptr
operator|->
name|hdr
operator|.
name|next
decl_stmt|;
name|space_freed
operator|=
name|shdr_ptr
operator|->
name|hdr
operator|.
name|bytes_used
operator|+
name|shdr_ptr
operator|->
name|hdr
operator|.
name|bytes_left
operator|+
name|SIZEOF
argument_list|(
name|small_pool_hdr
argument_list|)
expr_stmt|;
name|jpeg_free_small
argument_list|(
name|cinfo
argument_list|,
operator|(
name|void
operator|*
operator|)
name|shdr_ptr
argument_list|,
name|space_freed
argument_list|)
expr_stmt|;
name|mem
operator|->
name|total_space_allocated
operator|-=
name|space_freed
expr_stmt|;
name|shdr_ptr
operator|=
name|next_shdr_ptr
expr_stmt|;
block|}
block|}
end_block
begin_comment
comment|/*  * Close up shop entirely.  * Note that this cannot be called unless cinfo->mem is non-NULL.  */
end_comment
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|self_destruct
name|self_destruct
argument_list|(
argument|j_common_ptr cinfo
argument_list|)
end_macro
begin_block
block|{
name|int
name|pool
decl_stmt|;
comment|/* Close all backing store, release all memory.    * Releasing pools in reverse order might help avoid fragmentation    * with some (brain-damaged) malloc libraries.    */
for|for
control|(
name|pool
operator|=
name|JPOOL_NUMPOOLS
operator|-
literal|1
init|;
name|pool
operator|>=
name|JPOOL_PERMANENT
condition|;
name|pool
operator|--
control|)
block|{
name|free_pool
argument_list|(
name|cinfo
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
comment|/* Release the memory manager control block too. */
name|jpeg_free_small
argument_list|(
name|cinfo
argument_list|,
operator|(
name|void
operator|*
operator|)
name|cinfo
operator|->
name|mem
argument_list|,
name|SIZEOF
argument_list|(
name|my_memory_mgr
argument_list|)
argument_list|)
expr_stmt|;
name|cinfo
operator|->
name|mem
operator|=
name|NULL
expr_stmt|;
comment|/* ensures I will be called only once */
name|jpeg_mem_term
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
comment|/* system-dependent cleanup */
block|}
end_block
begin_comment
comment|/*  * Memory manager initialization.  * When this is called, only the error manager pointer is valid in cinfo!  */
end_comment
begin_macro
name|GLOBAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|jinit_memory_mgr
name|jinit_memory_mgr
argument_list|(
argument|j_common_ptr cinfo
argument_list|)
end_macro
begin_block
block|{
name|my_mem_ptr
name|mem
decl_stmt|;
name|long
name|max_to_use
decl_stmt|;
name|int
name|pool
decl_stmt|;
name|size_t
name|test_mac
decl_stmt|;
name|cinfo
operator|->
name|mem
operator|=
name|NULL
expr_stmt|;
comment|/* for safety if init fails */
comment|/* Check for configuration errors.    * SIZEOF(ALIGN_TYPE) should be a power of 2; otherwise, it probably    * doesn't reflect any real hardware alignment requirement.    * The test is a little tricky: for X>0, X and X-1 have no one-bits    * in common if and only if X is a power of 2, ie has only one one-bit.    * Some compilers may give an "unreachable code" warning here; ignore it.    */
if|if
condition|(
operator|(
name|SIZEOF
argument_list|(
name|ALIGN_TYPE
argument_list|)
operator|&
operator|(
name|SIZEOF
argument_list|(
name|ALIGN_TYPE
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_ALIGN_TYPE
argument_list|)
expr_stmt|;
comment|/* MAX_ALLOC_CHUNK must be representable as type size_t, and must be    * a multiple of SIZEOF(ALIGN_TYPE).    * Again, an "unreachable code" warning may be ignored here.    * But a "constant too large" warning means you need to fix MAX_ALLOC_CHUNK.    */
name|test_mac
operator|=
operator|(
name|size_t
operator|)
name|MAX_ALLOC_CHUNK
expr_stmt|;
if|if
condition|(
operator|(
name|long
operator|)
name|test_mac
operator|!=
name|MAX_ALLOC_CHUNK
operator|||
operator|(
name|MAX_ALLOC_CHUNK
operator|%
name|SIZEOF
argument_list|(
name|ALIGN_TYPE
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_ALLOC_CHUNK
argument_list|)
expr_stmt|;
name|max_to_use
operator|=
name|jpeg_mem_init
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
comment|/* system-dependent initialization */
comment|/* Attempt to allocate memory manager's control block */
name|mem
operator|=
operator|(
name|my_mem_ptr
operator|)
name|jpeg_get_small
argument_list|(
name|cinfo
argument_list|,
name|SIZEOF
argument_list|(
name|my_memory_mgr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mem
operator|==
name|NULL
condition|)
block|{
name|jpeg_mem_term
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
comment|/* system-dependent cleanup */
name|ERREXIT1
argument_list|(
name|cinfo
argument_list|,
name|JERR_OUT_OF_MEMORY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* OK, fill in the method pointers */
name|mem
operator|->
name|pub
operator|.
name|alloc_small
operator|=
name|alloc_small
expr_stmt|;
name|mem
operator|->
name|pub
operator|.
name|alloc_large
operator|=
name|alloc_large
expr_stmt|;
name|mem
operator|->
name|pub
operator|.
name|alloc_sarray
operator|=
name|alloc_sarray
expr_stmt|;
name|mem
operator|->
name|pub
operator|.
name|alloc_barray
operator|=
name|alloc_barray
expr_stmt|;
name|mem
operator|->
name|pub
operator|.
name|request_virt_sarray
operator|=
name|request_virt_sarray
expr_stmt|;
name|mem
operator|->
name|pub
operator|.
name|request_virt_barray
operator|=
name|request_virt_barray
expr_stmt|;
name|mem
operator|->
name|pub
operator|.
name|realize_virt_arrays
operator|=
name|realize_virt_arrays
expr_stmt|;
name|mem
operator|->
name|pub
operator|.
name|access_virt_sarray
operator|=
name|access_virt_sarray
expr_stmt|;
name|mem
operator|->
name|pub
operator|.
name|access_virt_barray
operator|=
name|access_virt_barray
expr_stmt|;
name|mem
operator|->
name|pub
operator|.
name|free_pool
operator|=
name|free_pool
expr_stmt|;
name|mem
operator|->
name|pub
operator|.
name|self_destruct
operator|=
name|self_destruct
expr_stmt|;
comment|/* Make MAX_ALLOC_CHUNK accessible to other modules */
name|mem
operator|->
name|pub
operator|.
name|max_alloc_chunk
operator|=
name|MAX_ALLOC_CHUNK
expr_stmt|;
comment|/* Initialize working state */
name|mem
operator|->
name|pub
operator|.
name|max_memory_to_use
operator|=
name|max_to_use
expr_stmt|;
for|for
control|(
name|pool
operator|=
name|JPOOL_NUMPOOLS
operator|-
literal|1
init|;
name|pool
operator|>=
name|JPOOL_PERMANENT
condition|;
name|pool
operator|--
control|)
block|{
name|mem
operator|->
name|small_list
index|[
name|pool
index|]
operator|=
name|NULL
expr_stmt|;
name|mem
operator|->
name|large_list
index|[
name|pool
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|mem
operator|->
name|virt_sarray_list
operator|=
name|NULL
expr_stmt|;
name|mem
operator|->
name|virt_barray_list
operator|=
name|NULL
expr_stmt|;
name|mem
operator|->
name|total_space_allocated
operator|=
name|SIZEOF
argument_list|(
name|my_memory_mgr
argument_list|)
expr_stmt|;
comment|/* Declare ourselves open for business */
name|cinfo
operator|->
name|mem
operator|=
operator|&
name|mem
operator|->
name|pub
expr_stmt|;
comment|/* Check for an environment variable JPEGMEM; if found, override the    * default max_memory setting from jpeg_mem_init.  Note that the    * surrounding application may again override this value.    * If your system doesn't support getenv(), define NO_GETENV to disable    * this feature.    */
ifndef|#
directive|ifndef
name|NO_GETENV
block|{
name|char
modifier|*
name|memenv
decl_stmt|;
if|if
condition|(
operator|(
name|memenv
operator|=
name|getenv
argument_list|(
literal|"JPEGMEM"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|char
name|ch
init|=
literal|'x'
decl_stmt|;
if|if
condition|(
name|sscanf
argument_list|(
name|memenv
argument_list|,
literal|"%ld%c"
argument_list|,
operator|&
name|max_to_use
argument_list|,
operator|&
name|ch
argument_list|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|ch
operator|==
literal|'m'
operator|||
name|ch
operator|==
literal|'M'
condition|)
name|max_to_use
operator|*=
literal|1000L
expr_stmt|;
name|mem
operator|->
name|pub
operator|.
name|max_memory_to_use
operator|=
name|max_to_use
operator|*
literal|1000L
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
block|}
end_block
end_unit
