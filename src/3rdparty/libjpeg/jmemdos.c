begin_unit
begin_comment
comment|/*  * jmemdos.c  *  * Copyright (C) 1992-1997, Thomas G. Lane.  * This file is part of the Independent JPEG Group's software.  * For conditions of distribution and use, see the accompanying README file.  *  * This file provides an MS-DOS-compatible implementation of the system-  * dependent portion of the JPEG memory manager.  Temporary data can be  * stored in extended or expanded memory as well as in regular DOS files.  *  * If you use this file, you must be sure that NEED_FAR_POINTERS is defined  * if you compile in a small-data memory model; it should NOT be defined if  * you use a large-data memory model.  This file is not recommended if you  * are using a flat-memory-space 386 environment such as DJGCC or Watcom C.  * Also, this code will NOT work if struct fields are aligned on greater than  * 2-byte boundaries.  *  * Based on code contributed by Ge' Weijers.  */
end_comment
begin_comment
comment|/*  * If you have both extended and expanded memory, you may want to change the  * order in which they are tried in jopen_backing_store.  On a 286 machine  * expanded memory is usually faster, since extended memory access involves  * an expensive protected-mode-and-back switch.  On 386 and better, extended  * memory is usually faster.  As distributed, the code tries extended memory  * first (what? not everyone has a 386? :-).  *  * You can disable use of extended/expanded memory entirely by altering these  * definitions or overriding them from the Makefile (eg, -DEMS_SUPPORTED=0).  */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|XMS_SUPPORTED
end_ifndef
begin_define
DECL|macro|XMS_SUPPORTED
define|#
directive|define
name|XMS_SUPPORTED
value|1
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|EMS_SUPPORTED
end_ifndef
begin_define
DECL|macro|EMS_SUPPORTED
define|#
directive|define
name|EMS_SUPPORTED
value|1
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|JPEG_INTERNALS
define|#
directive|define
name|JPEG_INTERNALS
end_define
begin_include
include|#
directive|include
file|"jinclude.h"
end_include
begin_include
include|#
directive|include
file|"jpeglib.h"
end_include
begin_include
include|#
directive|include
file|"jmemsys.h"
end_include
begin_comment
comment|/* import the system-dependent declarations */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_STDLIB_H
end_ifndef
begin_comment
comment|/*<stdlib.h> should declare these */
end_comment
begin_decl_stmt
specifier|extern
name|void
modifier|*
name|malloc
name|JPP
argument_list|(
operator|(
name|size_t
name|size
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt
begin_decl_stmt
specifier|extern
name|void
name|free
name|JPP
argument_list|(
operator|(
name|void
operator|*
name|ptr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt
begin_decl_stmt
specifier|extern
name|char
modifier|*
name|getenv
name|JPP
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|name
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|NEED_FAR_POINTERS
end_ifdef
begin_ifdef
ifdef|#
directive|ifdef
name|__TURBOC__
end_ifdef
begin_comment
comment|/* These definitions work for Borland C (Turbo C) */
end_comment
begin_include
include|#
directive|include
file|<alloc.h>
end_include
begin_comment
comment|/* need farmalloc(), farfree() */
end_comment
begin_define
DECL|macro|far_malloc
define|#
directive|define
name|far_malloc
parameter_list|(
name|x
parameter_list|)
value|farmalloc(x)
end_define
begin_define
DECL|macro|far_free
define|#
directive|define
name|far_free
parameter_list|(
name|x
parameter_list|)
value|farfree(x)
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* These definitions work for Microsoft C and compatible compilers */
end_comment
begin_include
include|#
directive|include
file|<malloc.h>
end_include
begin_comment
comment|/* need _fmalloc(), _ffree() */
end_comment
begin_define
DECL|macro|far_malloc
define|#
directive|define
name|far_malloc
parameter_list|(
name|x
parameter_list|)
value|_fmalloc(x)
end_define
begin_define
DECL|macro|far_free
define|#
directive|define
name|far_free
parameter_list|(
name|x
parameter_list|)
value|_ffree(x)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* not NEED_FAR_POINTERS */
end_comment
begin_define
DECL|macro|far_malloc
define|#
directive|define
name|far_malloc
parameter_list|(
name|x
parameter_list|)
value|malloc(x)
end_define
begin_define
DECL|macro|far_free
define|#
directive|define
name|far_free
parameter_list|(
name|x
parameter_list|)
value|free(x)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* NEED_FAR_POINTERS */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|DONT_USE_B_MODE
end_ifdef
begin_comment
comment|/* define mode parameters for fopen() */
end_comment
begin_define
DECL|macro|READ_BINARY
define|#
directive|define
name|READ_BINARY
value|"r"
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|READ_BINARY
define|#
directive|define
name|READ_BINARY
value|"rb"
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|USE_MSDOS_MEMMGR
end_ifndef
begin_comment
comment|/* make sure user got configuration right */
end_comment
begin_expr_stmt
name|You
name|forgot
name|to
name|define
name|USE_MSDOS_MEMMGR
name|in
name|jconfig
operator|.
name|h
operator|.
comment|/* deliberate syntax error */
endif|#
directive|endif
if|#
directive|if
name|MAX_ALLOC_CHUNK
operator|>=
literal|65535L
comment|/* make sure jconfig.h got this right */
name|MAX_ALLOC_CHUNK
name|should
name|be
name|less
name|than
literal|64K
operator|.
end_expr_stmt
begin_comment
comment|/* deliberate syntax error */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*  * Declarations for assembly-language support routines (see jmemdosa.asm).  *  * The functions are declared "far" as are all their pointer arguments;  * this ensures the assembly source code will work regardless of the  * compiler memory model.  We assume "short" is 16 bits, "long" is 32.  */
end_comment
begin_typedef
DECL|typedef|XMSDRIVER
typedef|typedef
name|void
name|far
modifier|*
name|XMSDRIVER
typedef|;
end_typedef
begin_comment
DECL|typedef|XMSDRIVER
comment|/* actually a pointer to code */
end_comment
begin_typedef
typedef|typedef
struct|struct
block|{
comment|/* registers for calling XMS driver */
DECL|member|ax
DECL|member|dx
DECL|member|bx
name|unsigned
name|short
name|ax
decl_stmt|,
name|dx
decl_stmt|,
name|bx
decl_stmt|;
DECL|member|ds_si
name|void
name|far
modifier|*
name|ds_si
decl_stmt|;
block|}
DECL|typedef|XMScontext
name|XMScontext
typedef|;
end_typedef
begin_typedef
typedef|typedef
struct|struct
block|{
comment|/* registers for calling EMS driver */
DECL|member|ax
DECL|member|dx
DECL|member|bx
name|unsigned
name|short
name|ax
decl_stmt|,
name|dx
decl_stmt|,
name|bx
decl_stmt|;
DECL|member|ds_si
name|void
name|far
modifier|*
name|ds_si
decl_stmt|;
block|}
DECL|typedef|EMScontext
name|EMScontext
typedef|;
end_typedef
begin_decl_stmt
specifier|extern
name|short
name|far
name|jdos_open
name|JPP
argument_list|(
operator|(
name|short
name|far
operator|*
name|handle
operator|,
name|char
name|far
operator|*
name|filename
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt
begin_decl_stmt
specifier|extern
name|short
name|far
name|jdos_close
name|JPP
argument_list|(
operator|(
name|short
name|handle
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt
begin_decl_stmt
specifier|extern
name|short
name|far
name|jdos_seek
name|JPP
argument_list|(
operator|(
name|short
name|handle
operator|,
name|long
name|offset
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt
begin_decl_stmt
specifier|extern
name|short
name|far
name|jdos_read
name|JPP
argument_list|(
operator|(
name|short
name|handle
operator|,
name|void
name|far
operator|*
name|buffer
operator|,
name|unsigned
name|short
name|count
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt
begin_decl_stmt
specifier|extern
name|short
name|far
name|jdos_write
name|JPP
argument_list|(
operator|(
name|short
name|handle
operator|,
name|void
name|far
operator|*
name|buffer
operator|,
name|unsigned
name|short
name|count
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt
begin_decl_stmt
specifier|extern
name|void
name|far
name|jxms_getdriver
name|JPP
argument_list|(
operator|(
name|XMSDRIVER
name|far
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt
begin_decl_stmt
specifier|extern
name|void
name|far
name|jxms_calldriver
name|JPP
argument_list|(
operator|(
name|XMSDRIVER
operator|,
name|XMScontext
name|far
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt
begin_decl_stmt
specifier|extern
name|short
name|far
name|jems_available
name|JPP
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt
begin_decl_stmt
specifier|extern
name|void
name|far
name|jems_calldriver
name|JPP
argument_list|(
operator|(
name|EMScontext
name|far
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*  * Selection of a file name for a temporary file.  * This is highly system-dependent, and you may want to customize it.  */
end_comment
begin_decl_stmt
DECL|variable|next_file_num
specifier|static
name|int
name|next_file_num
decl_stmt|;
end_decl_stmt
begin_comment
DECL|variable|next_file_num
comment|/* to distinguish among several temp files */
end_comment
begin_macro
name|LOCAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|select_file_name
name|select_file_name
argument_list|(
argument|char * fname
argument_list|)
end_macro
begin_block
block|{
specifier|const
name|char
modifier|*
name|env
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|FILE
modifier|*
name|tfile
decl_stmt|;
comment|/* Keep generating file names till we find one that's not in use */
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Get temp directory name from environment TMP or TEMP variable;      * if none, use "."      */
if|if
condition|(
operator|(
name|env
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|getenv
argument_list|(
literal|"TMP"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
if|if
condition|(
operator|(
name|env
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|getenv
argument_list|(
literal|"TEMP"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|env
operator|=
literal|"."
expr_stmt|;
if|if
condition|(
operator|*
name|env
operator|==
literal|'\0'
condition|)
comment|/* null string means "." */
name|env
operator|=
literal|"."
expr_stmt|;
name|ptr
operator|=
name|fname
expr_stmt|;
comment|/* copy name to fname */
while|while
condition|(
operator|*
name|env
operator|!=
literal|'\0'
condition|)
operator|*
name|ptr
operator|++
operator|=
operator|*
name|env
operator|++
expr_stmt|;
if|if
condition|(
name|ptr
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\\'
operator|&&
name|ptr
index|[
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
operator|*
name|ptr
operator|++
operator|=
literal|'\\'
expr_stmt|;
comment|/* append backslash if not in env variable */
comment|/* Append a suitable file name */
name|next_file_num
operator|++
expr_stmt|;
comment|/* advance counter */
name|sprintf
argument_list|(
name|ptr
argument_list|,
literal|"JPG%03d.TMP"
argument_list|,
name|next_file_num
argument_list|)
expr_stmt|;
comment|/* Probe to see if file name is already in use */
if|if
condition|(
operator|(
name|tfile
operator|=
name|fopen
argument_list|(
name|fname
argument_list|,
name|READ_BINARY
argument_list|)
operator|)
operator|==
name|NULL
condition|)
break|break;
name|fclose
argument_list|(
name|tfile
argument_list|)
expr_stmt|;
comment|/* oops, it's there; close tfile& try again */
block|}
block|}
end_block
begin_comment
comment|/*  * Near-memory allocation and freeing are controlled by the regular library  * routines malloc() and free().  */
end_comment
begin_macro
name|GLOBAL
argument_list|(
argument|void *
argument_list|)
end_macro
begin_macro
DECL|function|jpeg_get_small
name|jpeg_get_small
argument_list|(
argument|j_common_ptr cinfo
argument_list|,
argument|size_t sizeofobject
argument_list|)
end_macro
begin_block
block|{
return|return
operator|(
name|void
operator|*
operator|)
name|malloc
argument_list|(
name|sizeofobject
argument_list|)
return|;
block|}
end_block
begin_macro
name|GLOBAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|jpeg_free_small
name|jpeg_free_small
argument_list|(
argument|j_common_ptr cinfo
argument_list|,
argument|void * object
argument_list|,
argument|size_t sizeofobject
argument_list|)
end_macro
begin_block
block|{
name|free
argument_list|(
name|object
argument_list|)
expr_stmt|;
block|}
end_block
begin_comment
comment|/*  * "Large" objects are allocated in far memory, if possible  */
end_comment
begin_macro
name|GLOBAL
argument_list|(
argument|void FAR *
argument_list|)
end_macro
begin_macro
DECL|function|jpeg_get_large
name|jpeg_get_large
argument_list|(
argument|j_common_ptr cinfo
argument_list|,
argument|size_t sizeofobject
argument_list|)
end_macro
begin_block
block|{
return|return
operator|(
name|void
name|FAR
operator|*
operator|)
name|far_malloc
argument_list|(
name|sizeofobject
argument_list|)
return|;
block|}
end_block
begin_macro
name|GLOBAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|jpeg_free_large
name|jpeg_free_large
argument_list|(
argument|j_common_ptr cinfo
argument_list|,
argument|void FAR * object
argument_list|,
argument|size_t sizeofobject
argument_list|)
end_macro
begin_block
block|{
name|far_free
argument_list|(
name|object
argument_list|)
expr_stmt|;
block|}
end_block
begin_comment
comment|/*  * This routine computes the total memory space available for allocation.  * It's impossible to do this in a portable way; our current solution is  * to make the user tell us (with a default value set at compile time).  * If you can actually get the available space, it's a good idea to subtract  * a slop factor of 5% or so.  */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|DEFAULT_MAX_MEM
end_ifndef
begin_comment
comment|/* so can override from makefile */
end_comment
begin_define
DECL|macro|DEFAULT_MAX_MEM
define|#
directive|define
name|DEFAULT_MAX_MEM
value|300000L
end_define
begin_comment
DECL|macro|DEFAULT_MAX_MEM
comment|/* for total usage about 450K */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_macro
name|GLOBAL
argument_list|(
argument|long
argument_list|)
end_macro
begin_macro
DECL|function|jpeg_mem_available
name|jpeg_mem_available
argument_list|(
argument|j_common_ptr cinfo
argument_list|,
argument|long min_bytes_needed
argument_list|,
argument|long max_bytes_needed
argument_list|,
argument|long already_allocated
argument_list|)
end_macro
begin_block
block|{
return|return
name|cinfo
operator|->
name|mem
operator|->
name|max_memory_to_use
operator|-
name|already_allocated
return|;
block|}
end_block
begin_comment
comment|/*  * Backing store (temporary file) management.  * Backing store objects are only used when the value returned by  * jpeg_mem_available is less than the total space needed.  You can dispense  * with these routines if you have plenty of virtual memory; see jmemnobs.c.  */
end_comment
begin_comment
comment|/*  * For MS-DOS we support three types of backing storage:  *   1. Conventional DOS files.  We access these by direct DOS calls rather  *      than via the stdio package.  This provides a bit better performance,  *      but the real reason is that the buffers to be read or written are FAR.  *      The stdio library for small-data memory models can't cope with that.  *   2. Extended memory, accessed per the XMS V2.0 specification.  *   3. Expanded memory, accessed per the LIM/EMS 4.0 specification.  * You'll need copies of those specs to make sense of the related code.  * The specs are available by Internet FTP from the SIMTEL archives   * (oak.oakland.edu and its various mirror sites).  See files  * pub/msdos/microsoft/xms20.arc and pub/msdos/info/limems41.zip.  */
end_comment
begin_comment
comment|/*  * Access methods for a DOS file.  */
end_comment
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|read_file_store
name|read_file_store
argument_list|(
argument|j_common_ptr cinfo
argument_list|,
argument|backing_store_ptr info
argument_list|,
argument|void FAR * buffer_address
argument_list|,
argument|long file_offset
argument_list|,
argument|long byte_count
argument_list|)
end_macro
begin_block
block|{
if|if
condition|(
name|jdos_seek
argument_list|(
name|info
operator|->
name|handle
operator|.
name|file_handle
argument_list|,
name|file_offset
argument_list|)
condition|)
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_TFILE_SEEK
argument_list|)
expr_stmt|;
comment|/* Since MAX_ALLOC_CHUNK is less than 64K, byte_count will be too. */
if|if
condition|(
name|byte_count
operator|>
literal|65535L
condition|)
comment|/* safety check */
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_ALLOC_CHUNK
argument_list|)
expr_stmt|;
if|if
condition|(
name|jdos_read
argument_list|(
name|info
operator|->
name|handle
operator|.
name|file_handle
argument_list|,
name|buffer_address
argument_list|,
operator|(
name|unsigned
name|short
operator|)
name|byte_count
argument_list|)
condition|)
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_TFILE_READ
argument_list|)
expr_stmt|;
block|}
end_block
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|write_file_store
name|write_file_store
argument_list|(
argument|j_common_ptr cinfo
argument_list|,
argument|backing_store_ptr info
argument_list|,
argument|void FAR * buffer_address
argument_list|,
argument|long file_offset
argument_list|,
argument|long byte_count
argument_list|)
end_macro
begin_block
block|{
if|if
condition|(
name|jdos_seek
argument_list|(
name|info
operator|->
name|handle
operator|.
name|file_handle
argument_list|,
name|file_offset
argument_list|)
condition|)
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_TFILE_SEEK
argument_list|)
expr_stmt|;
comment|/* Since MAX_ALLOC_CHUNK is less than 64K, byte_count will be too. */
if|if
condition|(
name|byte_count
operator|>
literal|65535L
condition|)
comment|/* safety check */
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_ALLOC_CHUNK
argument_list|)
expr_stmt|;
if|if
condition|(
name|jdos_write
argument_list|(
name|info
operator|->
name|handle
operator|.
name|file_handle
argument_list|,
name|buffer_address
argument_list|,
operator|(
name|unsigned
name|short
operator|)
name|byte_count
argument_list|)
condition|)
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_TFILE_WRITE
argument_list|)
expr_stmt|;
block|}
end_block
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|close_file_store
name|close_file_store
argument_list|(
argument|j_common_ptr cinfo
argument_list|,
argument|backing_store_ptr info
argument_list|)
end_macro
begin_block
block|{
name|jdos_close
argument_list|(
name|info
operator|->
name|handle
operator|.
name|file_handle
argument_list|)
expr_stmt|;
comment|/* close the file */
name|remove
argument_list|(
name|info
operator|->
name|temp_name
argument_list|)
expr_stmt|;
comment|/* delete the file */
comment|/* If your system doesn't have remove(), try unlink() instead.  * remove() is the ANSI-standard name for this function, but  * unlink() was more common in pre-ANSI systems.  */
name|TRACEMSS
argument_list|(
name|cinfo
argument_list|,
literal|1
argument_list|,
name|JTRC_TFILE_CLOSE
argument_list|,
name|info
operator|->
name|temp_name
argument_list|)
expr_stmt|;
block|}
end_block
begin_macro
DECL|function|LOCAL
name|LOCAL
argument_list|(
argument|boolean
argument_list|)
end_macro
begin_macro
name|open_file_store
argument_list|(
argument|j_common_ptr cinfo
argument_list|,
argument|backing_store_ptr info
argument_list|,
argument|long total_bytes_needed
argument_list|)
end_macro
begin_block
block|{
name|short
name|handle
decl_stmt|;
name|select_file_name
argument_list|(
name|info
operator|->
name|temp_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|jdos_open
argument_list|(
operator|(
name|short
name|far
operator|*
operator|)
operator|&
name|handle
argument_list|,
operator|(
name|char
name|far
operator|*
operator|)
name|info
operator|->
name|temp_name
argument_list|)
condition|)
block|{
comment|/* might as well exit since jpeg_open_backing_store will fail anyway */
name|ERREXITS
argument_list|(
name|cinfo
argument_list|,
name|JERR_TFILE_CREATE
argument_list|,
name|info
operator|->
name|temp_name
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|info
operator|->
name|handle
operator|.
name|file_handle
operator|=
name|handle
expr_stmt|;
name|info
operator|->
name|read_backing_store
operator|=
name|read_file_store
expr_stmt|;
name|info
operator|->
name|write_backing_store
operator|=
name|write_file_store
expr_stmt|;
name|info
operator|->
name|close_backing_store
operator|=
name|close_file_store
expr_stmt|;
name|TRACEMSS
argument_list|(
name|cinfo
argument_list|,
literal|1
argument_list|,
name|JTRC_TFILE_OPEN
argument_list|,
name|info
operator|->
name|temp_name
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
comment|/* succeeded */
block|}
end_block
begin_comment
comment|/*  * Access methods for extended memory.  */
end_comment
begin_if
if|#
directive|if
name|XMS_SUPPORTED
end_if
begin_decl_stmt
DECL|variable|xms_driver
specifier|static
name|XMSDRIVER
name|xms_driver
decl_stmt|;
end_decl_stmt
begin_comment
DECL|variable|xms_driver
comment|/* saved address of XMS driver */
end_comment
begin_typedef
typedef|typedef
union|union
block|{
comment|/* either long offset or real-mode pointer */
DECL|member|offset
name|long
name|offset
decl_stmt|;
DECL|member|ptr
name|void
name|far
modifier|*
name|ptr
decl_stmt|;
block|}
DECL|typedef|XMSPTR
name|XMSPTR
typedef|;
end_typedef
begin_typedef
typedef|typedef
struct|struct
block|{
comment|/* XMS move specification structure */
DECL|member|length
name|long
name|length
decl_stmt|;
DECL|member|src_handle
name|XMSH
name|src_handle
decl_stmt|;
DECL|member|src
name|XMSPTR
name|src
decl_stmt|;
DECL|member|dst_handle
name|XMSH
name|dst_handle
decl_stmt|;
DECL|member|dst
name|XMSPTR
name|dst
decl_stmt|;
block|}
DECL|typedef|XMSspec
name|XMSspec
typedef|;
end_typedef
begin_define
DECL|macro|ODD
define|#
directive|define
name|ODD
parameter_list|(
name|X
parameter_list|)
value|(((X)& 1L) != 0)
end_define
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|read_xms_store
name|read_xms_store
argument_list|(
argument|j_common_ptr cinfo
argument_list|,
argument|backing_store_ptr info
argument_list|,
argument|void FAR * buffer_address
argument_list|,
argument|long file_offset
argument_list|,
argument|long byte_count
argument_list|)
end_macro
begin_block
block|{
name|XMScontext
name|ctx
decl_stmt|;
name|XMSspec
name|spec
decl_stmt|;
name|char
name|endbuffer
index|[
literal|2
index|]
decl_stmt|;
comment|/* The XMS driver can't cope with an odd length, so handle the last byte    * specially if byte_count is odd.  We don't expect this to be common.    */
name|spec
operator|.
name|length
operator|=
name|byte_count
operator|&
operator|(
operator|~
literal|1L
operator|)
expr_stmt|;
name|spec
operator|.
name|src_handle
operator|=
name|info
operator|->
name|handle
operator|.
name|xms_handle
expr_stmt|;
name|spec
operator|.
name|src
operator|.
name|offset
operator|=
name|file_offset
expr_stmt|;
name|spec
operator|.
name|dst_handle
operator|=
literal|0
expr_stmt|;
name|spec
operator|.
name|dst
operator|.
name|ptr
operator|=
name|buffer_address
expr_stmt|;
name|ctx
operator|.
name|ds_si
operator|=
operator|(
name|void
name|far
operator|*
operator|)
operator|&
name|spec
expr_stmt|;
name|ctx
operator|.
name|ax
operator|=
literal|0x0b00
expr_stmt|;
comment|/* EMB move */
name|jxms_calldriver
argument_list|(
name|xms_driver
argument_list|,
operator|(
name|XMScontext
name|far
operator|*
operator|)
operator|&
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|.
name|ax
operator|!=
literal|1
condition|)
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_XMS_READ
argument_list|)
expr_stmt|;
if|if
condition|(
name|ODD
argument_list|(
name|byte_count
argument_list|)
condition|)
block|{
name|read_xms_store
argument_list|(
name|cinfo
argument_list|,
name|info
argument_list|,
operator|(
name|void
name|FAR
operator|*
operator|)
name|endbuffer
argument_list|,
name|file_offset
operator|+
name|byte_count
operator|-
literal|1L
argument_list|,
literal|2L
argument_list|)
expr_stmt|;
operator|(
operator|(
name|char
name|FAR
operator|*
operator|)
name|buffer_address
operator|)
index|[
name|byte_count
operator|-
literal|1L
index|]
operator|=
name|endbuffer
index|[
literal|0
index|]
expr_stmt|;
block|}
block|}
end_block
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|write_xms_store
name|write_xms_store
argument_list|(
argument|j_common_ptr cinfo
argument_list|,
argument|backing_store_ptr info
argument_list|,
argument|void FAR * buffer_address
argument_list|,
argument|long file_offset
argument_list|,
argument|long byte_count
argument_list|)
end_macro
begin_block
block|{
name|XMScontext
name|ctx
decl_stmt|;
name|XMSspec
name|spec
decl_stmt|;
name|char
name|endbuffer
index|[
literal|2
index|]
decl_stmt|;
comment|/* The XMS driver can't cope with an odd length, so handle the last byte    * specially if byte_count is odd.  We don't expect this to be common.    */
name|spec
operator|.
name|length
operator|=
name|byte_count
operator|&
operator|(
operator|~
literal|1L
operator|)
expr_stmt|;
name|spec
operator|.
name|src_handle
operator|=
literal|0
expr_stmt|;
name|spec
operator|.
name|src
operator|.
name|ptr
operator|=
name|buffer_address
expr_stmt|;
name|spec
operator|.
name|dst_handle
operator|=
name|info
operator|->
name|handle
operator|.
name|xms_handle
expr_stmt|;
name|spec
operator|.
name|dst
operator|.
name|offset
operator|=
name|file_offset
expr_stmt|;
name|ctx
operator|.
name|ds_si
operator|=
operator|(
name|void
name|far
operator|*
operator|)
operator|&
name|spec
expr_stmt|;
name|ctx
operator|.
name|ax
operator|=
literal|0x0b00
expr_stmt|;
comment|/* EMB move */
name|jxms_calldriver
argument_list|(
name|xms_driver
argument_list|,
operator|(
name|XMScontext
name|far
operator|*
operator|)
operator|&
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|.
name|ax
operator|!=
literal|1
condition|)
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_XMS_WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ODD
argument_list|(
name|byte_count
argument_list|)
condition|)
block|{
name|read_xms_store
argument_list|(
name|cinfo
argument_list|,
name|info
argument_list|,
operator|(
name|void
name|FAR
operator|*
operator|)
name|endbuffer
argument_list|,
name|file_offset
operator|+
name|byte_count
operator|-
literal|1L
argument_list|,
literal|2L
argument_list|)
expr_stmt|;
name|endbuffer
index|[
literal|0
index|]
operator|=
operator|(
operator|(
name|char
name|FAR
operator|*
operator|)
name|buffer_address
operator|)
index|[
name|byte_count
operator|-
literal|1L
index|]
expr_stmt|;
name|write_xms_store
argument_list|(
name|cinfo
argument_list|,
name|info
argument_list|,
operator|(
name|void
name|FAR
operator|*
operator|)
name|endbuffer
argument_list|,
name|file_offset
operator|+
name|byte_count
operator|-
literal|1L
argument_list|,
literal|2L
argument_list|)
expr_stmt|;
block|}
block|}
end_block
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|close_xms_store
name|close_xms_store
argument_list|(
argument|j_common_ptr cinfo
argument_list|,
argument|backing_store_ptr info
argument_list|)
end_macro
begin_block
block|{
name|XMScontext
name|ctx
decl_stmt|;
name|ctx
operator|.
name|dx
operator|=
name|info
operator|->
name|handle
operator|.
name|xms_handle
expr_stmt|;
name|ctx
operator|.
name|ax
operator|=
literal|0x0a00
expr_stmt|;
name|jxms_calldriver
argument_list|(
name|xms_driver
argument_list|,
operator|(
name|XMScontext
name|far
operator|*
operator|)
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|TRACEMS1
argument_list|(
name|cinfo
argument_list|,
literal|1
argument_list|,
name|JTRC_XMS_CLOSE
argument_list|,
name|info
operator|->
name|handle
operator|.
name|xms_handle
argument_list|)
expr_stmt|;
comment|/* we ignore any error return from the driver */
block|}
end_block
begin_macro
DECL|function|LOCAL
name|LOCAL
argument_list|(
argument|boolean
argument_list|)
end_macro
begin_macro
name|open_xms_store
argument_list|(
argument|j_common_ptr cinfo
argument_list|,
argument|backing_store_ptr info
argument_list|,
argument|long total_bytes_needed
argument_list|)
end_macro
begin_block
block|{
name|XMScontext
name|ctx
decl_stmt|;
comment|/* Get address of XMS driver */
name|jxms_getdriver
argument_list|(
operator|(
name|XMSDRIVER
name|far
operator|*
operator|)
operator|&
name|xms_driver
argument_list|)
expr_stmt|;
if|if
condition|(
name|xms_driver
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
comment|/* no driver to be had */
comment|/* Get version number, must be>= 2.00 */
name|ctx
operator|.
name|ax
operator|=
literal|0x0000
expr_stmt|;
name|jxms_calldriver
argument_list|(
name|xms_driver
argument_list|,
operator|(
name|XMScontext
name|far
operator|*
operator|)
operator|&
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|.
name|ax
operator|<
operator|(
name|unsigned
name|short
operator|)
literal|0x0200
condition|)
return|return
name|FALSE
return|;
comment|/* Try to get space (expressed in kilobytes) */
name|ctx
operator|.
name|dx
operator|=
call|(
name|unsigned
name|short
call|)
argument_list|(
operator|(
name|total_bytes_needed
operator|+
literal|1023L
operator|)
operator|>>
literal|10
argument_list|)
expr_stmt|;
name|ctx
operator|.
name|ax
operator|=
literal|0x0900
expr_stmt|;
name|jxms_calldriver
argument_list|(
name|xms_driver
argument_list|,
operator|(
name|XMScontext
name|far
operator|*
operator|)
operator|&
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|.
name|ax
operator|!=
literal|1
condition|)
return|return
name|FALSE
return|;
comment|/* Succeeded, save the handle and away we go */
name|info
operator|->
name|handle
operator|.
name|xms_handle
operator|=
name|ctx
operator|.
name|dx
expr_stmt|;
name|info
operator|->
name|read_backing_store
operator|=
name|read_xms_store
expr_stmt|;
name|info
operator|->
name|write_backing_store
operator|=
name|write_xms_store
expr_stmt|;
name|info
operator|->
name|close_backing_store
operator|=
name|close_xms_store
expr_stmt|;
name|TRACEMS1
argument_list|(
name|cinfo
argument_list|,
literal|1
argument_list|,
name|JTRC_XMS_OPEN
argument_list|,
name|ctx
operator|.
name|dx
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
comment|/* succeeded */
block|}
end_block
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* XMS_SUPPORTED */
end_comment
begin_comment
comment|/*  * Access methods for expanded memory.  */
end_comment
begin_if
if|#
directive|if
name|EMS_SUPPORTED
end_if
begin_comment
comment|/* The EMS move specification structure requires word and long fields aligned  * at odd byte boundaries.  Some compilers will align struct fields at even  * byte boundaries.  While it's usually possible to force byte alignment,  * that causes an overall performance penalty and may pose problems in merging  * JPEG into a larger application.  Instead we accept some rather dirty code  * here.  Note this code would fail if the hardware did not allow odd-byte  * word& long accesses, but all 80x86 CPUs do.  */
end_comment
begin_typedef
DECL|typedef|EMSPTR
typedef|typedef
name|void
name|far
modifier|*
name|EMSPTR
typedef|;
end_typedef
begin_typedef
typedef|typedef
union|union
block|{
comment|/* EMS move specification structure */
DECL|member|length
name|long
name|length
decl_stmt|;
comment|/* It's easy to access first 4 bytes */
DECL|member|bytes
name|char
name|bytes
index|[
literal|18
index|]
decl_stmt|;
comment|/* Misaligned fields in here! */
block|}
DECL|typedef|EMSspec
name|EMSspec
typedef|;
end_typedef
begin_comment
comment|/* Macros for accessing misaligned fields */
end_comment
begin_define
DECL|macro|FIELD_AT
define|#
directive|define
name|FIELD_AT
parameter_list|(
name|spec
parameter_list|,
name|offset
parameter_list|,
name|type
parameter_list|)
value|(*((type *)&(spec.bytes[offset])))
end_define
begin_define
DECL|macro|SRC_TYPE
define|#
directive|define
name|SRC_TYPE
parameter_list|(
name|spec
parameter_list|)
value|FIELD_AT(spec,4,char)
end_define
begin_define
DECL|macro|SRC_HANDLE
define|#
directive|define
name|SRC_HANDLE
parameter_list|(
name|spec
parameter_list|)
value|FIELD_AT(spec,5,EMSH)
end_define
begin_define
DECL|macro|SRC_OFFSET
define|#
directive|define
name|SRC_OFFSET
parameter_list|(
name|spec
parameter_list|)
value|FIELD_AT(spec,7,unsigned short)
end_define
begin_define
DECL|macro|SRC_PAGE
define|#
directive|define
name|SRC_PAGE
parameter_list|(
name|spec
parameter_list|)
value|FIELD_AT(spec,9,unsigned short)
end_define
begin_define
DECL|macro|SRC_PTR
define|#
directive|define
name|SRC_PTR
parameter_list|(
name|spec
parameter_list|)
value|FIELD_AT(spec,7,EMSPTR)
end_define
begin_define
DECL|macro|DST_TYPE
define|#
directive|define
name|DST_TYPE
parameter_list|(
name|spec
parameter_list|)
value|FIELD_AT(spec,11,char)
end_define
begin_define
DECL|macro|DST_HANDLE
define|#
directive|define
name|DST_HANDLE
parameter_list|(
name|spec
parameter_list|)
value|FIELD_AT(spec,12,EMSH)
end_define
begin_define
DECL|macro|DST_OFFSET
define|#
directive|define
name|DST_OFFSET
parameter_list|(
name|spec
parameter_list|)
value|FIELD_AT(spec,14,unsigned short)
end_define
begin_define
DECL|macro|DST_PAGE
define|#
directive|define
name|DST_PAGE
parameter_list|(
name|spec
parameter_list|)
value|FIELD_AT(spec,16,unsigned short)
end_define
begin_define
DECL|macro|DST_PTR
define|#
directive|define
name|DST_PTR
parameter_list|(
name|spec
parameter_list|)
value|FIELD_AT(spec,14,EMSPTR)
end_define
begin_define
DECL|macro|EMSPAGESIZE
define|#
directive|define
name|EMSPAGESIZE
value|16384L
end_define
begin_comment
DECL|macro|EMSPAGESIZE
comment|/* gospel, see the EMS specs */
end_comment
begin_define
DECL|macro|HIBYTE
define|#
directive|define
name|HIBYTE
parameter_list|(
name|W
parameter_list|)
value|(((W)>> 8)& 0xFF)
end_define
begin_define
DECL|macro|LOBYTE
define|#
directive|define
name|LOBYTE
parameter_list|(
name|W
parameter_list|)
value|((W)& 0xFF)
end_define
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|read_ems_store
name|read_ems_store
argument_list|(
argument|j_common_ptr cinfo
argument_list|,
argument|backing_store_ptr info
argument_list|,
argument|void FAR * buffer_address
argument_list|,
argument|long file_offset
argument_list|,
argument|long byte_count
argument_list|)
end_macro
begin_block
block|{
name|EMScontext
name|ctx
decl_stmt|;
name|EMSspec
name|spec
decl_stmt|;
name|spec
operator|.
name|length
operator|=
name|byte_count
expr_stmt|;
name|SRC_TYPE
argument_list|(
name|spec
argument_list|)
operator|=
literal|1
expr_stmt|;
name|SRC_HANDLE
argument_list|(
name|spec
argument_list|)
operator|=
name|info
operator|->
name|handle
operator|.
name|ems_handle
expr_stmt|;
name|SRC_PAGE
argument_list|(
name|spec
argument_list|)
operator|=
call|(
name|unsigned
name|short
call|)
argument_list|(
name|file_offset
operator|/
name|EMSPAGESIZE
argument_list|)
expr_stmt|;
name|SRC_OFFSET
argument_list|(
name|spec
argument_list|)
operator|=
call|(
name|unsigned
name|short
call|)
argument_list|(
name|file_offset
operator|%
name|EMSPAGESIZE
argument_list|)
expr_stmt|;
name|DST_TYPE
argument_list|(
name|spec
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DST_HANDLE
argument_list|(
name|spec
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DST_PTR
argument_list|(
name|spec
argument_list|)
operator|=
name|buffer_address
expr_stmt|;
name|ctx
operator|.
name|ds_si
operator|=
operator|(
name|void
name|far
operator|*
operator|)
operator|&
name|spec
expr_stmt|;
name|ctx
operator|.
name|ax
operator|=
literal|0x5700
expr_stmt|;
comment|/* move memory region */
name|jems_calldriver
argument_list|(
operator|(
name|EMScontext
name|far
operator|*
operator|)
operator|&
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|HIBYTE
argument_list|(
name|ctx
operator|.
name|ax
argument_list|)
operator|!=
literal|0
condition|)
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_EMS_READ
argument_list|)
expr_stmt|;
block|}
end_block
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|write_ems_store
name|write_ems_store
argument_list|(
argument|j_common_ptr cinfo
argument_list|,
argument|backing_store_ptr info
argument_list|,
argument|void FAR * buffer_address
argument_list|,
argument|long file_offset
argument_list|,
argument|long byte_count
argument_list|)
end_macro
begin_block
block|{
name|EMScontext
name|ctx
decl_stmt|;
name|EMSspec
name|spec
decl_stmt|;
name|spec
operator|.
name|length
operator|=
name|byte_count
expr_stmt|;
name|SRC_TYPE
argument_list|(
name|spec
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SRC_HANDLE
argument_list|(
name|spec
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SRC_PTR
argument_list|(
name|spec
argument_list|)
operator|=
name|buffer_address
expr_stmt|;
name|DST_TYPE
argument_list|(
name|spec
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DST_HANDLE
argument_list|(
name|spec
argument_list|)
operator|=
name|info
operator|->
name|handle
operator|.
name|ems_handle
expr_stmt|;
name|DST_PAGE
argument_list|(
name|spec
argument_list|)
operator|=
call|(
name|unsigned
name|short
call|)
argument_list|(
name|file_offset
operator|/
name|EMSPAGESIZE
argument_list|)
expr_stmt|;
name|DST_OFFSET
argument_list|(
name|spec
argument_list|)
operator|=
call|(
name|unsigned
name|short
call|)
argument_list|(
name|file_offset
operator|%
name|EMSPAGESIZE
argument_list|)
expr_stmt|;
name|ctx
operator|.
name|ds_si
operator|=
operator|(
name|void
name|far
operator|*
operator|)
operator|&
name|spec
expr_stmt|;
name|ctx
operator|.
name|ax
operator|=
literal|0x5700
expr_stmt|;
comment|/* move memory region */
name|jems_calldriver
argument_list|(
operator|(
name|EMScontext
name|far
operator|*
operator|)
operator|&
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|HIBYTE
argument_list|(
name|ctx
operator|.
name|ax
argument_list|)
operator|!=
literal|0
condition|)
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_EMS_WRITE
argument_list|)
expr_stmt|;
block|}
end_block
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|close_ems_store
name|close_ems_store
argument_list|(
argument|j_common_ptr cinfo
argument_list|,
argument|backing_store_ptr info
argument_list|)
end_macro
begin_block
block|{
name|EMScontext
name|ctx
decl_stmt|;
name|ctx
operator|.
name|ax
operator|=
literal|0x4500
expr_stmt|;
name|ctx
operator|.
name|dx
operator|=
name|info
operator|->
name|handle
operator|.
name|ems_handle
expr_stmt|;
name|jems_calldriver
argument_list|(
operator|(
name|EMScontext
name|far
operator|*
operator|)
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|TRACEMS1
argument_list|(
name|cinfo
argument_list|,
literal|1
argument_list|,
name|JTRC_EMS_CLOSE
argument_list|,
name|info
operator|->
name|handle
operator|.
name|ems_handle
argument_list|)
expr_stmt|;
comment|/* we ignore any error return from the driver */
block|}
end_block
begin_macro
DECL|function|LOCAL
name|LOCAL
argument_list|(
argument|boolean
argument_list|)
end_macro
begin_macro
name|open_ems_store
argument_list|(
argument|j_common_ptr cinfo
argument_list|,
argument|backing_store_ptr info
argument_list|,
argument|long total_bytes_needed
argument_list|)
end_macro
begin_block
block|{
name|EMScontext
name|ctx
decl_stmt|;
comment|/* Is EMS driver there? */
if|if
condition|(
operator|!
name|jems_available
argument_list|()
condition|)
return|return
name|FALSE
return|;
comment|/* Get status, make sure EMS is OK */
name|ctx
operator|.
name|ax
operator|=
literal|0x4000
expr_stmt|;
name|jems_calldriver
argument_list|(
operator|(
name|EMScontext
name|far
operator|*
operator|)
operator|&
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|HIBYTE
argument_list|(
name|ctx
operator|.
name|ax
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
comment|/* Get version, must be>= 4.0 */
name|ctx
operator|.
name|ax
operator|=
literal|0x4600
expr_stmt|;
name|jems_calldriver
argument_list|(
operator|(
name|EMScontext
name|far
operator|*
operator|)
operator|&
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|HIBYTE
argument_list|(
name|ctx
operator|.
name|ax
argument_list|)
operator|!=
literal|0
operator|||
name|LOBYTE
argument_list|(
name|ctx
operator|.
name|ax
argument_list|)
operator|<
literal|0x40
condition|)
return|return
name|FALSE
return|;
comment|/* Try to allocate requested space */
name|ctx
operator|.
name|ax
operator|=
literal|0x4300
expr_stmt|;
name|ctx
operator|.
name|bx
operator|=
call|(
name|unsigned
name|short
call|)
argument_list|(
operator|(
name|total_bytes_needed
operator|+
name|EMSPAGESIZE
operator|-
literal|1L
operator|)
operator|/
name|EMSPAGESIZE
argument_list|)
expr_stmt|;
name|jems_calldriver
argument_list|(
operator|(
name|EMScontext
name|far
operator|*
operator|)
operator|&
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|HIBYTE
argument_list|(
name|ctx
operator|.
name|ax
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
comment|/* Succeeded, save the handle and away we go */
name|info
operator|->
name|handle
operator|.
name|ems_handle
operator|=
name|ctx
operator|.
name|dx
expr_stmt|;
name|info
operator|->
name|read_backing_store
operator|=
name|read_ems_store
expr_stmt|;
name|info
operator|->
name|write_backing_store
operator|=
name|write_ems_store
expr_stmt|;
name|info
operator|->
name|close_backing_store
operator|=
name|close_ems_store
expr_stmt|;
name|TRACEMS1
argument_list|(
name|cinfo
argument_list|,
literal|1
argument_list|,
name|JTRC_EMS_OPEN
argument_list|,
name|ctx
operator|.
name|dx
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
comment|/* succeeded */
block|}
end_block
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* EMS_SUPPORTED */
end_comment
begin_comment
comment|/*  * Initial opening of a backing-store object.  */
end_comment
begin_macro
name|GLOBAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|jpeg_open_backing_store
name|jpeg_open_backing_store
argument_list|(
argument|j_common_ptr cinfo
argument_list|,
argument|backing_store_ptr info
argument_list|,
argument|long total_bytes_needed
argument_list|)
end_macro
begin_block
block|{
comment|/* Try extended memory, then expanded memory, then regular file. */
if|#
directive|if
name|XMS_SUPPORTED
if|if
condition|(
name|open_xms_store
argument_list|(
name|cinfo
argument_list|,
name|info
argument_list|,
name|total_bytes_needed
argument_list|)
condition|)
return|return;
endif|#
directive|endif
if|#
directive|if
name|EMS_SUPPORTED
if|if
condition|(
name|open_ems_store
argument_list|(
name|cinfo
argument_list|,
name|info
argument_list|,
name|total_bytes_needed
argument_list|)
condition|)
return|return;
endif|#
directive|endif
if|if
condition|(
name|open_file_store
argument_list|(
name|cinfo
argument_list|,
name|info
argument_list|,
name|total_bytes_needed
argument_list|)
condition|)
return|return;
name|ERREXITS
argument_list|(
name|cinfo
argument_list|,
name|JERR_TFILE_CREATE
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_block
begin_comment
comment|/*  * These routines take care of any system-dependent initialization and  * cleanup required.  */
end_comment
begin_macro
name|GLOBAL
argument_list|(
argument|long
argument_list|)
end_macro
begin_macro
DECL|function|jpeg_mem_init
name|jpeg_mem_init
argument_list|(
argument|j_common_ptr cinfo
argument_list|)
end_macro
begin_block
block|{
name|next_file_num
operator|=
literal|0
expr_stmt|;
comment|/* initialize temp file name generator */
return|return
name|DEFAULT_MAX_MEM
return|;
comment|/* default for max_memory_to_use */
block|}
end_block
begin_macro
name|GLOBAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|jpeg_mem_term
name|jpeg_mem_term
argument_list|(
argument|j_common_ptr cinfo
argument_list|)
end_macro
begin_block
block|{
comment|/* Microsoft C, at least in v6.00A, will not successfully reclaim freed    * blocks of size> 32Kbytes unless we give it a kick in the rear, like so:    */
ifdef|#
directive|ifdef
name|NEED_FHEAPMIN
name|_fheapmin
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_block
end_unit
