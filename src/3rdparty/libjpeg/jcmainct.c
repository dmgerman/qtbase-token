begin_unit
begin_comment
comment|/*  * jcmainct.c  *  * Copyright (C) 1994-1996, Thomas G. Lane.  * This file is part of the Independent JPEG Group's software.  * For conditions of distribution and use, see the accompanying README file.  *  * This file contains the main buffer controller for compression.  * The main buffer lies between the pre-processor and the JPEG  * compressor proper; it holds downsampled data in the JPEG colorspace.  */
end_comment
begin_define
DECL|macro|JPEG_INTERNALS
define|#
directive|define
name|JPEG_INTERNALS
end_define
begin_include
include|#
directive|include
file|"jinclude.h"
end_include
begin_include
include|#
directive|include
file|"jpeglib.h"
end_include
begin_comment
comment|/* Note: currently, there is no operating mode in which a full-image buffer  * is needed at this step.  If there were, that mode could not be used with  * "raw data" input, since this module is bypassed in that case.  However,  * we've left the code here for possible use in special applications.  */
end_comment
begin_undef
DECL|macro|FULL_MAIN_BUFFER_SUPPORTED
undef|#
directive|undef
name|FULL_MAIN_BUFFER_SUPPORTED
end_undef
begin_comment
comment|/* Private buffer controller object */
end_comment
begin_typedef
typedef|typedef
struct|struct
block|{
DECL|member|pub
name|struct
name|jpeg_c_main_controller
name|pub
decl_stmt|;
comment|/* public fields */
DECL|member|cur_iMCU_row
name|JDIMENSION
name|cur_iMCU_row
decl_stmt|;
comment|/* number of current iMCU row */
DECL|member|rowgroup_ctr
name|JDIMENSION
name|rowgroup_ctr
decl_stmt|;
comment|/* counts row groups received in iMCU row */
DECL|member|suspended
name|boolean
name|suspended
decl_stmt|;
comment|/* remember if we suspended output */
DECL|member|pass_mode
name|J_BUF_MODE
name|pass_mode
decl_stmt|;
comment|/* current operating mode */
comment|/* If using just a strip buffer, this points to the entire set of buffers    * (we allocate one for each component).  In the full-image case, this    * points to the currently accessible strips of the virtual arrays.    */
DECL|member|buffer
name|JSAMPARRAY
name|buffer
index|[
name|MAX_COMPONENTS
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|FULL_MAIN_BUFFER_SUPPORTED
comment|/* If using full-image storage, this array holds pointers to virtual-array    * control blocks for each component.  Unused if not full-image storage.    */
DECL|member|whole_image
name|jvirt_sarray_ptr
name|whole_image
index|[
name|MAX_COMPONENTS
index|]
decl_stmt|;
endif|#
directive|endif
block|}
DECL|typedef|my_main_controller
name|my_main_controller
typedef|;
end_typedef
begin_typedef
DECL|typedef|my_main_ptr
typedef|typedef
name|my_main_controller
modifier|*
name|my_main_ptr
typedef|;
end_typedef
begin_comment
comment|/* Forward declarations */
end_comment
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_decl_stmt
name|process_data_simple_main
name|JPP
argument_list|(
operator|(
name|j_compress_ptr
name|cinfo
operator|,
name|JSAMPARRAY
name|input_buf
operator|,
name|JDIMENSION
operator|*
name|in_row_ctr
operator|,
name|JDIMENSION
name|in_rows_avail
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt
begin_ifdef
ifdef|#
directive|ifdef
name|FULL_MAIN_BUFFER_SUPPORTED
end_ifdef
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_decl_stmt
name|process_data_buffer_main
name|JPP
argument_list|(
operator|(
name|j_compress_ptr
name|cinfo
operator|,
name|JSAMPARRAY
name|input_buf
operator|,
name|JDIMENSION
operator|*
name|in_row_ctr
operator|,
name|JDIMENSION
name|in_rows_avail
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*  * Initialize for a processing pass.  */
end_comment
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|start_pass_main
name|start_pass_main
argument_list|(
argument|j_compress_ptr cinfo
argument_list|,
argument|J_BUF_MODE pass_mode
argument_list|)
end_macro
begin_block
block|{
name|my_main_ptr
decl|main
init|=
operator|(
name|my_main_ptr
operator|)
name|cinfo
operator|->
expr|main
decl_stmt|;
comment|/* Do nothing in raw-data mode. */
if|if
condition|(
name|cinfo
operator|->
name|raw_data_in
condition|)
return|return;
expr|main
operator|->
name|cur_iMCU_row
operator|=
literal|0
expr_stmt|;
comment|/* initialize counters */
expr|main
operator|->
name|rowgroup_ctr
operator|=
literal|0
expr_stmt|;
expr|main
operator|->
name|suspended
operator|=
name|FALSE
expr_stmt|;
expr|main
operator|->
name|pass_mode
operator|=
name|pass_mode
expr_stmt|;
comment|/* save mode for use by process_data */
switch|switch
condition|(
name|pass_mode
condition|)
block|{
case|case
name|JBUF_PASS_THRU
case|:
ifdef|#
directive|ifdef
name|FULL_MAIN_BUFFER_SUPPORTED
if|if
condition|(
expr|main
operator|->
name|whole_image
index|[
literal|0
index|]
operator|!=
name|NULL
condition|)
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_BUFFER_MODE
argument_list|)
expr_stmt|;
endif|#
directive|endif
expr|main
operator|->
name|pub
operator|.
name|process_data
operator|=
name|process_data_simple_main
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|FULL_MAIN_BUFFER_SUPPORTED
case|case
name|JBUF_SAVE_SOURCE
case|:
case|case
name|JBUF_CRANK_DEST
case|:
case|case
name|JBUF_SAVE_AND_PASS
case|:
if|if
condition|(
expr|main
operator|->
name|whole_image
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_BUFFER_MODE
argument_list|)
expr_stmt|;
expr|main
operator|->
name|pub
operator|.
name|process_data
operator|=
name|process_data_buffer_main
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_BUFFER_MODE
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_block
begin_comment
comment|/*  * Process some data.  * This routine handles the simple pass-through mode,  * where we have only a strip buffer.  */
end_comment
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|process_data_simple_main
name|process_data_simple_main
argument_list|(
argument|j_compress_ptr cinfo
argument_list|,
argument|JSAMPARRAY input_buf
argument_list|,
argument|JDIMENSION *in_row_ctr
argument_list|,
argument|JDIMENSION in_rows_avail
argument_list|)
end_macro
begin_block
block|{
name|my_main_ptr
decl|main
init|=
operator|(
name|my_main_ptr
operator|)
name|cinfo
operator|->
expr|main
decl_stmt|;
while|while
condition|(
expr|main
operator|->
name|cur_iMCU_row
operator|<
name|cinfo
operator|->
name|total_iMCU_rows
condition|)
block|{
comment|/* Read input data if we haven't filled the main buffer yet */
if|if
condition|(
expr|main
operator|->
name|rowgroup_ctr
operator|<
operator|(
name|JDIMENSION
operator|)
name|cinfo
operator|->
name|min_DCT_v_scaled_size
condition|)
call|(
modifier|*
name|cinfo
operator|->
name|prep
operator|->
name|pre_process_data
call|)
argument_list|(
name|cinfo
argument_list|,
name|input_buf
argument_list|,
name|in_row_ctr
argument_list|,
name|in_rows_avail
argument_list|,
expr|main
operator|->
name|buffer
argument_list|,
operator|&
expr|main
operator|->
name|rowgroup_ctr
argument_list|,
operator|(
name|JDIMENSION
operator|)
name|cinfo
operator|->
name|min_DCT_v_scaled_size
argument_list|)
expr_stmt|;
comment|/* If we don't have a full iMCU row buffered, return to application for      * more data.  Note that preprocessor will always pad to fill the iMCU row      * at the bottom of the image.      */
if|if
condition|(
expr|main
operator|->
name|rowgroup_ctr
operator|!=
operator|(
name|JDIMENSION
operator|)
name|cinfo
operator|->
name|min_DCT_v_scaled_size
condition|)
return|return;
comment|/* Send the completed row to the compressor */
if|if
condition|(
operator|!
call|(
modifier|*
name|cinfo
operator|->
name|coef
operator|->
name|compress_data
call|)
argument_list|(
name|cinfo
argument_list|,
expr|main
operator|->
name|buffer
argument_list|)
condition|)
block|{
comment|/* If compressor did not consume the whole row, then we must need to        * suspend processing and return to the application.  In this situation        * we pretend we didn't yet consume the last input row; otherwise, if        * it happened to be the last row of the image, the application would        * think we were done.        */
if|if
condition|(
operator|!
expr|main
operator|->
name|suspended
condition|)
block|{
operator|(
operator|*
name|in_row_ctr
operator|)
operator|--
expr_stmt|;
expr|main
operator|->
name|suspended
operator|=
name|TRUE
expr_stmt|;
block|}
return|return;
block|}
comment|/* We did finish the row.  Undo our little suspension hack if a previous      * call suspended; then mark the main buffer empty.      */
if|if
condition|(
expr|main
operator|->
name|suspended
condition|)
block|{
operator|(
operator|*
name|in_row_ctr
operator|)
operator|++
expr_stmt|;
expr|main
operator|->
name|suspended
operator|=
name|FALSE
expr_stmt|;
block|}
expr|main
operator|->
name|rowgroup_ctr
operator|=
literal|0
expr_stmt|;
expr|main
operator|->
name|cur_iMCU_row
operator|++
expr_stmt|;
block|}
block|}
end_block
begin_ifdef
ifdef|#
directive|ifdef
name|FULL_MAIN_BUFFER_SUPPORTED
end_ifdef
begin_comment
comment|/*  * Process some data.  * This routine handles all of the modes that use a full-size buffer.  */
end_comment
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|process_data_buffer_main
name|process_data_buffer_main
argument_list|(
argument|j_compress_ptr cinfo
argument_list|,
argument|JSAMPARRAY input_buf
argument_list|,
argument|JDIMENSION *in_row_ctr
argument_list|,
argument|JDIMENSION in_rows_avail
argument_list|)
end_macro
begin_block
block|{
name|my_main_ptr
decl|main
init|=
operator|(
name|my_main_ptr
operator|)
name|cinfo
operator|->
expr|main
decl_stmt|;
name|int
name|ci
decl_stmt|;
name|jpeg_component_info
modifier|*
name|compptr
decl_stmt|;
name|boolean
name|writing
init|=
operator|(
expr|main
operator|->
name|pass_mode
operator|!=
name|JBUF_CRANK_DEST
operator|)
decl_stmt|;
while|while
condition|(
expr|main
operator|->
name|cur_iMCU_row
operator|<
name|cinfo
operator|->
name|total_iMCU_rows
condition|)
block|{
comment|/* Realign the virtual buffers if at the start of an iMCU row. */
if|if
condition|(
expr|main
operator|->
name|rowgroup_ctr
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|ci
operator|=
literal|0
operator|,
name|compptr
operator|=
name|cinfo
operator|->
name|comp_info
init|;
name|ci
operator|<
name|cinfo
operator|->
name|num_components
condition|;
name|ci
operator|++
operator|,
name|compptr
operator|++
control|)
block|{
expr|main
operator|->
name|buffer
index|[
name|ci
index|]
operator|=
call|(
modifier|*
name|cinfo
operator|->
name|mem
operator|->
name|access_virt_sarray
call|)
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|,
expr|main
operator|->
name|whole_image
index|[
name|ci
index|]
argument_list|,
expr|main
operator|->
name|cur_iMCU_row
operator|*
operator|(
name|compptr
operator|->
name|v_samp_factor
operator|*
name|DCTSIZE
operator|)
argument_list|,
call|(
name|JDIMENSION
call|)
argument_list|(
name|compptr
operator|->
name|v_samp_factor
operator|*
name|DCTSIZE
argument_list|)
argument_list|,
name|writing
argument_list|)
expr_stmt|;
block|}
comment|/* In a read pass, pretend we just read some source data. */
if|if
condition|(
operator|!
name|writing
condition|)
block|{
operator|*
name|in_row_ctr
operator|+=
name|cinfo
operator|->
name|max_v_samp_factor
operator|*
name|DCTSIZE
expr_stmt|;
expr|main
operator|->
name|rowgroup_ctr
operator|=
name|DCTSIZE
expr_stmt|;
block|}
block|}
comment|/* If a write pass, read input data until the current iMCU row is full. */
comment|/* Note: preprocessor will pad if necessary to fill the last iMCU row. */
if|if
condition|(
name|writing
condition|)
block|{
call|(
modifier|*
name|cinfo
operator|->
name|prep
operator|->
name|pre_process_data
call|)
argument_list|(
name|cinfo
argument_list|,
name|input_buf
argument_list|,
name|in_row_ctr
argument_list|,
name|in_rows_avail
argument_list|,
expr|main
operator|->
name|buffer
argument_list|,
operator|&
expr|main
operator|->
name|rowgroup_ctr
argument_list|,
operator|(
name|JDIMENSION
operator|)
name|DCTSIZE
argument_list|)
expr_stmt|;
comment|/* Return to application if we need more data to fill the iMCU row. */
if|if
condition|(
expr|main
operator|->
name|rowgroup_ctr
operator|<
name|DCTSIZE
condition|)
return|return;
block|}
comment|/* Emit data, unless this is a sink-only pass. */
if|if
condition|(
expr|main
operator|->
name|pass_mode
operator|!=
name|JBUF_SAVE_SOURCE
condition|)
block|{
if|if
condition|(
operator|!
call|(
modifier|*
name|cinfo
operator|->
name|coef
operator|->
name|compress_data
call|)
argument_list|(
name|cinfo
argument_list|,
expr|main
operator|->
name|buffer
argument_list|)
condition|)
block|{
comment|/* If compressor did not consume the whole row, then we must need to 	 * suspend processing and return to the application.  In this situation 	 * we pretend we didn't yet consume the last input row; otherwise, if 	 * it happened to be the last row of the image, the application would 	 * think we were done. 	 */
if|if
condition|(
operator|!
expr|main
operator|->
name|suspended
condition|)
block|{
operator|(
operator|*
name|in_row_ctr
operator|)
operator|--
expr_stmt|;
expr|main
operator|->
name|suspended
operator|=
name|TRUE
expr_stmt|;
block|}
return|return;
block|}
comment|/* We did finish the row.  Undo our little suspension hack if a previous        * call suspended; then mark the main buffer empty.        */
if|if
condition|(
expr|main
operator|->
name|suspended
condition|)
block|{
operator|(
operator|*
name|in_row_ctr
operator|)
operator|++
expr_stmt|;
expr|main
operator|->
name|suspended
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
comment|/* If get here, we are done with this iMCU row.  Mark buffer empty. */
expr|main
operator|->
name|rowgroup_ctr
operator|=
literal|0
expr_stmt|;
expr|main
operator|->
name|cur_iMCU_row
operator|++
expr_stmt|;
block|}
block|}
end_block
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* FULL_MAIN_BUFFER_SUPPORTED */
end_comment
begin_comment
comment|/*  * Initialize main buffer controller.  */
end_comment
begin_macro
name|GLOBAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|jinit_c_main_controller
name|jinit_c_main_controller
argument_list|(
argument|j_compress_ptr cinfo
argument_list|,
argument|boolean need_full_buffer
argument_list|)
end_macro
begin_block
block|{
name|my_main_ptr
decl|main
decl_stmt|;
name|int
name|ci
decl_stmt|;
name|jpeg_component_info
modifier|*
name|compptr
decl_stmt|;
expr|main
operator|=
call|(
name|my_main_ptr
call|)
argument_list|(
operator|*
name|cinfo
operator|->
name|mem
operator|->
name|alloc_small
argument_list|)
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|,
name|JPOOL_IMAGE
argument_list|,
name|SIZEOF
argument_list|(
name|my_main_controller
argument_list|)
argument_list|)
expr_stmt|;
name|cinfo
operator|->
expr|main
operator|=
operator|(
expr|struct
name|jpeg_c_main_controller
operator|*
operator|)
expr|main
expr_stmt|;
expr|main
operator|->
name|pub
operator|.
name|start_pass
operator|=
name|start_pass_main
expr_stmt|;
comment|/* We don't need to create a buffer in raw-data mode. */
if|if
condition|(
name|cinfo
operator|->
name|raw_data_in
condition|)
return|return;
comment|/* Create the buffer.  It holds downsampled data, so each component    * may be of a different size.    */
if|if
condition|(
name|need_full_buffer
condition|)
block|{
ifdef|#
directive|ifdef
name|FULL_MAIN_BUFFER_SUPPORTED
comment|/* Allocate a full-image virtual array for each component */
comment|/* Note we pad the bottom to a multiple of the iMCU height */
for|for
control|(
name|ci
operator|=
literal|0
operator|,
name|compptr
operator|=
name|cinfo
operator|->
name|comp_info
init|;
name|ci
operator|<
name|cinfo
operator|->
name|num_components
condition|;
name|ci
operator|++
operator|,
name|compptr
operator|++
control|)
block|{
expr|main
operator|->
name|whole_image
index|[
name|ci
index|]
operator|=
call|(
modifier|*
name|cinfo
operator|->
name|mem
operator|->
name|request_virt_sarray
call|)
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|,
name|JPOOL_IMAGE
argument_list|,
name|FALSE
argument_list|,
name|compptr
operator|->
name|width_in_blocks
operator|*
name|compptr
operator|->
name|DCT_h_scaled_size
argument_list|,
operator|(
name|JDIMENSION
operator|)
name|jround_up
argument_list|(
operator|(
name|long
operator|)
name|compptr
operator|->
name|height_in_blocks
argument_list|,
operator|(
name|long
operator|)
name|compptr
operator|->
name|v_samp_factor
argument_list|)
operator|*
name|DCTSIZE
argument_list|,
call|(
name|JDIMENSION
call|)
argument_list|(
name|compptr
operator|->
name|v_samp_factor
operator|*
name|compptr
operator|->
name|DCT_v_scaled_size
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_BUFFER_MODE
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|FULL_MAIN_BUFFER_SUPPORTED
expr|main
operator|->
name|whole_image
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* flag for no virtual arrays */
endif|#
directive|endif
comment|/* Allocate a strip buffer for each component */
for|for
control|(
name|ci
operator|=
literal|0
operator|,
name|compptr
operator|=
name|cinfo
operator|->
name|comp_info
init|;
name|ci
operator|<
name|cinfo
operator|->
name|num_components
condition|;
name|ci
operator|++
operator|,
name|compptr
operator|++
control|)
block|{
expr|main
operator|->
name|buffer
index|[
name|ci
index|]
operator|=
call|(
modifier|*
name|cinfo
operator|->
name|mem
operator|->
name|alloc_sarray
call|)
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|,
name|JPOOL_IMAGE
argument_list|,
name|compptr
operator|->
name|width_in_blocks
operator|*
name|compptr
operator|->
name|DCT_h_scaled_size
argument_list|,
call|(
name|JDIMENSION
call|)
argument_list|(
name|compptr
operator|->
name|v_samp_factor
operator|*
name|compptr
operator|->
name|DCT_v_scaled_size
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block
end_unit
