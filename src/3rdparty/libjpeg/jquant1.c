begin_unit
begin_comment
comment|/*  * jquant1.c  *  * Copyright (C) 1991-1996, Thomas G. Lane.  * This file is part of the Independent JPEG Group's software.  * For conditions of distribution and use, see the accompanying README file.  *  * This file contains 1-pass color quantization (color mapping) routines.  * These routines provide mapping to a fixed color map using equally spaced  * color values.  Optional Floyd-Steinberg or ordered dithering is available.  */
end_comment
begin_define
DECL|macro|JPEG_INTERNALS
define|#
directive|define
name|JPEG_INTERNALS
end_define
begin_include
include|#
directive|include
file|"jinclude.h"
end_include
begin_include
include|#
directive|include
file|"jpeglib.h"
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|QUANT_1PASS_SUPPORTED
end_ifdef
begin_comment
comment|/*  * The main purpose of 1-pass quantization is to provide a fast, if not very  * high quality, colormapped output capability.  A 2-pass quantizer usually  * gives better visual quality; however, for quantized grayscale output this  * quantizer is perfectly adequate.  Dithering is highly recommended with this  * quantizer, though you can turn it off if you really want to.  *  * In 1-pass quantization the colormap must be chosen in advance of seeing the  * image.  We use a map consisting of all combinations of Ncolors[i] color  * values for the i'th component.  The Ncolors[] values are chosen so that  * their product, the total number of colors, is no more than that requested.  * (In most cases, the product will be somewhat less.)  *  * Since the colormap is orthogonal, the representative value for each color  * component can be determined without considering the other components;  * then these indexes can be combined into a colormap index by a standard  * N-dimensional-array-subscript calculation.  Most of the arithmetic involved  * can be precalculated and stored in the lookup table colorindex[].  * colorindex[i][j] maps pixel value j in component i to the nearest  * representative value (grid plane) for that component; this index is  * multiplied by the array stride for component i, so that the  * index of the colormap entry closest to a given pixel value is just  *    sum( colorindex[component-number][pixel-component-value] )  * Aside from being fast, this scheme allows for variable spacing between  * representative values with no additional lookup cost.  *  * If gamma correction has been applied in color conversion, it might be wise  * to adjust the color grid spacing so that the representative colors are  * equidistant in linear space.  At this writing, gamma correction is not  * implemented by jdcolor, so nothing is done here.  */
end_comment
begin_comment
comment|/* Declarations for ordered dithering.  *  * We use a standard 16x16 ordered dither array.  The basic concept of ordered  * dithering is described in many references, for instance Dale Schumacher's  * chapter II.2 of Graphics Gems II (James Arvo, ed. Academic Press, 1991).  * In place of Schumacher's comparisons against a "threshold" value, we add a  * "dither" value to the input pixel and then round the result to the nearest  * output value.  The dither value is equivalent to (0.5 - threshold) times  * the distance between output values.  For ordered dithering, we assume that  * the output colors are equally spaced; if not, results will probably be  * worse, since the dither may be too much or too little at a given point.  *  * The normal calculation would be to form pixel value + dither, range-limit  * this to 0..MAXJSAMPLE, and then index into the colorindex table as usual.  * We can skip the separate range-limiting step by extending the colorindex  * table in both directions.  */
end_comment
begin_define
DECL|macro|ODITHER_SIZE
define|#
directive|define
name|ODITHER_SIZE
value|16
end_define
begin_comment
DECL|macro|ODITHER_SIZE
comment|/* dimension of dither matrix */
end_comment
begin_comment
comment|/* NB: if ODITHER_SIZE is not a power of 2, ODITHER_MASK uses will break */
end_comment
begin_define
DECL|macro|ODITHER_CELLS
define|#
directive|define
name|ODITHER_CELLS
value|(ODITHER_SIZE*ODITHER_SIZE)
end_define
begin_comment
DECL|macro|ODITHER_CELLS
comment|/* # cells in matrix */
end_comment
begin_define
DECL|macro|ODITHER_MASK
define|#
directive|define
name|ODITHER_MASK
value|(ODITHER_SIZE-1)
end_define
begin_comment
DECL|macro|ODITHER_MASK
comment|/* mask for wrapping around counters */
end_comment
begin_typedef
DECL|typedef|ODITHER_MATRIX
typedef|typedef
name|int
name|ODITHER_MATRIX
index|[
name|ODITHER_SIZE
index|]
index|[
name|ODITHER_SIZE
index|]
typedef|;
end_typedef
begin_typedef
DECL|typedef|ODITHER_MATRIX_PTR
typedef|typedef
name|int
argument_list|(
operator|*
name|ODITHER_MATRIX_PTR
argument_list|)
index|[
name|ODITHER_SIZE
index|]
expr_stmt|;
end_typedef
begin_decl_stmt
DECL|variable|base_dither_matrix
specifier|static
specifier|const
name|UINT8
name|base_dither_matrix
index|[
name|ODITHER_SIZE
index|]
index|[
name|ODITHER_SIZE
index|]
init|=
block|{
comment|/* Bayer's order-4 dither array.  Generated by the code given in    * Stephen Hawley's article "Ordered Dithering" in Graphics Gems I.    * The values in this array must range from 0 to ODITHER_CELLS-1.    */
block|{
literal|0
block|,
literal|192
block|,
literal|48
block|,
literal|240
block|,
literal|12
block|,
literal|204
block|,
literal|60
block|,
literal|252
block|,
literal|3
block|,
literal|195
block|,
literal|51
block|,
literal|243
block|,
literal|15
block|,
literal|207
block|,
literal|63
block|,
literal|255
block|}
block|,
block|{
literal|128
block|,
literal|64
block|,
literal|176
block|,
literal|112
block|,
literal|140
block|,
literal|76
block|,
literal|188
block|,
literal|124
block|,
literal|131
block|,
literal|67
block|,
literal|179
block|,
literal|115
block|,
literal|143
block|,
literal|79
block|,
literal|191
block|,
literal|127
block|}
block|,
block|{
literal|32
block|,
literal|224
block|,
literal|16
block|,
literal|208
block|,
literal|44
block|,
literal|236
block|,
literal|28
block|,
literal|220
block|,
literal|35
block|,
literal|227
block|,
literal|19
block|,
literal|211
block|,
literal|47
block|,
literal|239
block|,
literal|31
block|,
literal|223
block|}
block|,
block|{
literal|160
block|,
literal|96
block|,
literal|144
block|,
literal|80
block|,
literal|172
block|,
literal|108
block|,
literal|156
block|,
literal|92
block|,
literal|163
block|,
literal|99
block|,
literal|147
block|,
literal|83
block|,
literal|175
block|,
literal|111
block|,
literal|159
block|,
literal|95
block|}
block|,
block|{
literal|8
block|,
literal|200
block|,
literal|56
block|,
literal|248
block|,
literal|4
block|,
literal|196
block|,
literal|52
block|,
literal|244
block|,
literal|11
block|,
literal|203
block|,
literal|59
block|,
literal|251
block|,
literal|7
block|,
literal|199
block|,
literal|55
block|,
literal|247
block|}
block|,
block|{
literal|136
block|,
literal|72
block|,
literal|184
block|,
literal|120
block|,
literal|132
block|,
literal|68
block|,
literal|180
block|,
literal|116
block|,
literal|139
block|,
literal|75
block|,
literal|187
block|,
literal|123
block|,
literal|135
block|,
literal|71
block|,
literal|183
block|,
literal|119
block|}
block|,
block|{
literal|40
block|,
literal|232
block|,
literal|24
block|,
literal|216
block|,
literal|36
block|,
literal|228
block|,
literal|20
block|,
literal|212
block|,
literal|43
block|,
literal|235
block|,
literal|27
block|,
literal|219
block|,
literal|39
block|,
literal|231
block|,
literal|23
block|,
literal|215
block|}
block|,
block|{
literal|168
block|,
literal|104
block|,
literal|152
block|,
literal|88
block|,
literal|164
block|,
literal|100
block|,
literal|148
block|,
literal|84
block|,
literal|171
block|,
literal|107
block|,
literal|155
block|,
literal|91
block|,
literal|167
block|,
literal|103
block|,
literal|151
block|,
literal|87
block|}
block|,
block|{
literal|2
block|,
literal|194
block|,
literal|50
block|,
literal|242
block|,
literal|14
block|,
literal|206
block|,
literal|62
block|,
literal|254
block|,
literal|1
block|,
literal|193
block|,
literal|49
block|,
literal|241
block|,
literal|13
block|,
literal|205
block|,
literal|61
block|,
literal|253
block|}
block|,
block|{
literal|130
block|,
literal|66
block|,
literal|178
block|,
literal|114
block|,
literal|142
block|,
literal|78
block|,
literal|190
block|,
literal|126
block|,
literal|129
block|,
literal|65
block|,
literal|177
block|,
literal|113
block|,
literal|141
block|,
literal|77
block|,
literal|189
block|,
literal|125
block|}
block|,
block|{
literal|34
block|,
literal|226
block|,
literal|18
block|,
literal|210
block|,
literal|46
block|,
literal|238
block|,
literal|30
block|,
literal|222
block|,
literal|33
block|,
literal|225
block|,
literal|17
block|,
literal|209
block|,
literal|45
block|,
literal|237
block|,
literal|29
block|,
literal|221
block|}
block|,
block|{
literal|162
block|,
literal|98
block|,
literal|146
block|,
literal|82
block|,
literal|174
block|,
literal|110
block|,
literal|158
block|,
literal|94
block|,
literal|161
block|,
literal|97
block|,
literal|145
block|,
literal|81
block|,
literal|173
block|,
literal|109
block|,
literal|157
block|,
literal|93
block|}
block|,
block|{
literal|10
block|,
literal|202
block|,
literal|58
block|,
literal|250
block|,
literal|6
block|,
literal|198
block|,
literal|54
block|,
literal|246
block|,
literal|9
block|,
literal|201
block|,
literal|57
block|,
literal|249
block|,
literal|5
block|,
literal|197
block|,
literal|53
block|,
literal|245
block|}
block|,
block|{
literal|138
block|,
literal|74
block|,
literal|186
block|,
literal|122
block|,
literal|134
block|,
literal|70
block|,
literal|182
block|,
literal|118
block|,
literal|137
block|,
literal|73
block|,
literal|185
block|,
literal|121
block|,
literal|133
block|,
literal|69
block|,
literal|181
block|,
literal|117
block|}
block|,
block|{
literal|42
block|,
literal|234
block|,
literal|26
block|,
literal|218
block|,
literal|38
block|,
literal|230
block|,
literal|22
block|,
literal|214
block|,
literal|41
block|,
literal|233
block|,
literal|25
block|,
literal|217
block|,
literal|37
block|,
literal|229
block|,
literal|21
block|,
literal|213
block|}
block|,
block|{
literal|170
block|,
literal|106
block|,
literal|154
block|,
literal|90
block|,
literal|166
block|,
literal|102
block|,
literal|150
block|,
literal|86
block|,
literal|169
block|,
literal|105
block|,
literal|153
block|,
literal|89
block|,
literal|165
block|,
literal|101
block|,
literal|149
block|,
literal|85
block|}
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* Declarations for Floyd-Steinberg dithering.  *  * Errors are accumulated into the array fserrors[], at a resolution of  * 1/16th of a pixel count.  The error at a given pixel is propagated  * to its not-yet-processed neighbors using the standard F-S fractions,  *		...	(here)	7/16  *		3/16	5/16	1/16  * We work left-to-right on even rows, right-to-left on odd rows.  *  * We can get away with a single array (holding one row's worth of errors)  * by using it to store the current row's errors at pixel columns not yet  * processed, but the next row's errors at columns already processed.  We  * need only a few extra variables to hold the errors immediately around the  * current column.  (If we are lucky, those variables are in registers, but  * even if not, they're probably cheaper to access than array elements are.)  *  * The fserrors[] array is indexed [component#][position].  * We provide (#columns + 2) entries per component; the extra entry at each  * end saves us from special-casing the first and last pixels.  *  * Note: on a wide image, we might not have enough room in a PC's near data  * segment to hold the error array; so it is allocated with alloc_large.  */
end_comment
begin_if
if|#
directive|if
name|BITS_IN_JSAMPLE
operator|==
literal|8
end_if
begin_typedef
DECL|typedef|FSERROR
typedef|typedef
name|INT16
name|FSERROR
typedef|;
end_typedef
begin_comment
DECL|typedef|FSERROR
comment|/* 16 bits should be enough */
end_comment
begin_typedef
DECL|typedef|LOCFSERROR
typedef|typedef
name|int
name|LOCFSERROR
typedef|;
end_typedef
begin_comment
DECL|typedef|LOCFSERROR
comment|/* use 'int' for calculation temps */
end_comment
begin_else
else|#
directive|else
end_else
begin_typedef
DECL|typedef|FSERROR
typedef|typedef
name|INT32
name|FSERROR
typedef|;
end_typedef
begin_comment
DECL|typedef|FSERROR
comment|/* may need more than 16 bits */
end_comment
begin_typedef
DECL|typedef|LOCFSERROR
typedef|typedef
name|INT32
name|LOCFSERROR
typedef|;
end_typedef
begin_comment
DECL|typedef|LOCFSERROR
comment|/* be sure calculation temps are big enough */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_typedef
DECL|typedef|FSERRPTR
typedef|typedef
name|FSERROR
name|FAR
modifier|*
name|FSERRPTR
typedef|;
end_typedef
begin_comment
DECL|typedef|FSERRPTR
comment|/* pointer to error array (in FAR storage!) */
end_comment
begin_comment
comment|/* Private subobject */
end_comment
begin_define
DECL|macro|MAX_Q_COMPS
define|#
directive|define
name|MAX_Q_COMPS
value|4
end_define
begin_comment
DECL|macro|MAX_Q_COMPS
comment|/* max components I can handle */
end_comment
begin_typedef
typedef|typedef
struct|struct
block|{
DECL|member|pub
name|struct
name|jpeg_color_quantizer
name|pub
decl_stmt|;
comment|/* public fields */
comment|/* Initially allocated colormap is saved here */
DECL|member|sv_colormap
name|JSAMPARRAY
name|sv_colormap
decl_stmt|;
comment|/* The color map as a 2-D pixel array */
DECL|member|sv_actual
name|int
name|sv_actual
decl_stmt|;
comment|/* number of entries in use */
DECL|member|colorindex
name|JSAMPARRAY
name|colorindex
decl_stmt|;
comment|/* Precomputed mapping for speed */
comment|/* colorindex[i][j] = index of color closest to pixel value j in component i,    * premultiplied as described above.  Since colormap indexes must fit into    * JSAMPLEs, the entries of this array will too.    */
DECL|member|is_padded
name|boolean
name|is_padded
decl_stmt|;
comment|/* is the colorindex padded for odither? */
DECL|member|Ncolors
name|int
name|Ncolors
index|[
name|MAX_Q_COMPS
index|]
decl_stmt|;
comment|/* # of values alloced to each component */
comment|/* Variables for ordered dithering */
DECL|member|row_index
name|int
name|row_index
decl_stmt|;
comment|/* cur row's vertical index in dither matrix */
DECL|member|odither
name|ODITHER_MATRIX_PTR
name|odither
index|[
name|MAX_Q_COMPS
index|]
decl_stmt|;
comment|/* one dither array per component */
comment|/* Variables for Floyd-Steinberg dithering */
DECL|member|fserrors
name|FSERRPTR
name|fserrors
index|[
name|MAX_Q_COMPS
index|]
decl_stmt|;
comment|/* accumulated errors */
DECL|member|on_odd_row
name|boolean
name|on_odd_row
decl_stmt|;
comment|/* flag to remember which row we are on */
block|}
DECL|typedef|my_cquantizer
name|my_cquantizer
typedef|;
end_typedef
begin_typedef
DECL|typedef|my_cquantize_ptr
typedef|typedef
name|my_cquantizer
modifier|*
name|my_cquantize_ptr
typedef|;
end_typedef
begin_comment
comment|/*  * Policy-making subroutines for create_colormap and create_colorindex.  * These routines determine the colormap to be used.  The rest of the module  * only assumes that the colormap is orthogonal.  *  *  * select_ncolors decides how to divvy up the available colors  *    among the components.  *  * output_value defines the set of representative values for a component.  *  * largest_input_value defines the mapping from input values to  *    representative values for a component.  * Note that the latter two routines may impose different policies for  * different components, though this is not currently done.  */
end_comment
begin_macro
name|LOCAL
argument_list|(
argument|int
argument_list|)
end_macro
begin_macro
DECL|function|select_ncolors
name|select_ncolors
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|,
argument|int Ncolors[]
argument_list|)
end_macro
begin_comment
comment|/* Determine allocation of desired colors to components, */
end_comment
begin_comment
comment|/* and fill in Ncolors[] array to indicate choice. */
end_comment
begin_comment
comment|/* Return value is total number of colors (product of Ncolors[] values). */
end_comment
begin_block
block|{
name|int
name|nc
init|=
name|cinfo
operator|->
name|out_color_components
decl_stmt|;
comment|/* number of color components */
name|int
name|max_colors
init|=
name|cinfo
operator|->
name|desired_number_of_colors
decl_stmt|;
name|int
name|total_colors
decl_stmt|,
name|iroot
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|boolean
name|changed
decl_stmt|;
name|long
name|temp
decl_stmt|;
specifier|static
specifier|const
name|int
name|RGB_order
index|[
literal|3
index|]
init|=
block|{
name|RGB_GREEN
block|,
name|RGB_RED
block|,
name|RGB_BLUE
block|}
decl_stmt|;
comment|/* We can allocate at least the nc'th root of max_colors per component. */
comment|/* Compute floor(nc'th root of max_colors). */
name|iroot
operator|=
literal|1
expr_stmt|;
do|do
block|{
name|iroot
operator|++
expr_stmt|;
name|temp
operator|=
name|iroot
expr_stmt|;
comment|/* set temp = iroot ** nc */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nc
condition|;
name|i
operator|++
control|)
name|temp
operator|*=
name|iroot
expr_stmt|;
block|}
do|while
condition|(
name|temp
operator|<=
operator|(
name|long
operator|)
name|max_colors
condition|)
do|;
comment|/* repeat till iroot exceeds root */
name|iroot
operator|--
expr_stmt|;
comment|/* now iroot = floor(root) */
comment|/* Must have at least 2 color values per component */
if|if
condition|(
name|iroot
operator|<
literal|2
condition|)
name|ERREXIT1
argument_list|(
name|cinfo
argument_list|,
name|JERR_QUANT_FEW_COLORS
argument_list|,
operator|(
name|int
operator|)
name|temp
argument_list|)
expr_stmt|;
comment|/* Initialize to iroot color values for each component */
name|total_colors
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nc
condition|;
name|i
operator|++
control|)
block|{
name|Ncolors
index|[
name|i
index|]
operator|=
name|iroot
expr_stmt|;
name|total_colors
operator|*=
name|iroot
expr_stmt|;
block|}
comment|/* We may be able to increment the count for one or more components without    * exceeding max_colors, though we know not all can be incremented.    * Sometimes, the first component can be incremented more than once!    * (Example: for 16 colors, we start at 2*2*2, go to 3*2*2, then 4*2*2.)    * In RGB colorspace, try to increment G first, then R, then B.    */
do|do
block|{
name|changed
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nc
condition|;
name|i
operator|++
control|)
block|{
name|j
operator|=
operator|(
name|cinfo
operator|->
name|out_color_space
operator|==
name|JCS_RGB
condition|?
name|RGB_order
index|[
name|i
index|]
else|:
name|i
operator|)
expr_stmt|;
comment|/* calculate new total_colors if Ncolors[j] is incremented */
name|temp
operator|=
name|total_colors
operator|/
name|Ncolors
index|[
name|j
index|]
expr_stmt|;
name|temp
operator|*=
name|Ncolors
index|[
name|j
index|]
operator|+
literal|1
expr_stmt|;
comment|/* done in long arith to avoid oflo */
if|if
condition|(
name|temp
operator|>
operator|(
name|long
operator|)
name|max_colors
condition|)
break|break;
comment|/* won't fit, done with this pass */
name|Ncolors
index|[
name|j
index|]
operator|++
expr_stmt|;
comment|/* OK, apply the increment */
name|total_colors
operator|=
operator|(
name|int
operator|)
name|temp
expr_stmt|;
name|changed
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
do|while
condition|(
name|changed
condition|)
do|;
return|return
name|total_colors
return|;
block|}
end_block
begin_macro
name|LOCAL
argument_list|(
argument|int
argument_list|)
end_macro
begin_macro
DECL|function|output_value
name|output_value
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|,
argument|int ci
argument_list|,
argument|int j
argument_list|,
argument|int maxj
argument_list|)
end_macro
begin_comment
comment|/* Return j'th output value, where j will range from 0 to maxj */
end_comment
begin_comment
comment|/* The output values must fall in 0..MAXJSAMPLE in increasing order */
end_comment
begin_block
block|{
comment|/* We always provide values 0 and MAXJSAMPLE for each component;    * any additional values are equally spaced between these limits.    * (Forcing the upper and lower values to the limits ensures that    * dithering can't produce a color outside the selected gamut.)    */
return|return
call|(
name|int
call|)
argument_list|(
operator|(
operator|(
name|INT32
operator|)
name|j
operator|*
name|MAXJSAMPLE
operator|+
name|maxj
operator|/
literal|2
operator|)
operator|/
name|maxj
argument_list|)
return|;
block|}
end_block
begin_macro
name|LOCAL
argument_list|(
argument|int
argument_list|)
end_macro
begin_macro
DECL|function|largest_input_value
name|largest_input_value
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|,
argument|int ci
argument_list|,
argument|int j
argument_list|,
argument|int maxj
argument_list|)
end_macro
begin_comment
comment|/* Return largest input value that should map to j'th output value */
end_comment
begin_comment
comment|/* Must have largest(j=0)>= 0, and largest(j=maxj)>= MAXJSAMPLE */
end_comment
begin_block
block|{
comment|/* Breakpoints are halfway between values returned by output_value */
return|return
call|(
name|int
call|)
argument_list|(
operator|(
call|(
name|INT32
call|)
argument_list|(
literal|2
operator|*
name|j
operator|+
literal|1
argument_list|)
operator|*
name|MAXJSAMPLE
operator|+
name|maxj
operator|)
operator|/
operator|(
literal|2
operator|*
name|maxj
operator|)
argument_list|)
return|;
block|}
end_block
begin_comment
comment|/*  * Create the colormap.  */
end_comment
begin_macro
name|LOCAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|create_colormap
name|create_colormap
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|)
end_macro
begin_block
block|{
name|my_cquantize_ptr
name|cquantize
init|=
operator|(
name|my_cquantize_ptr
operator|)
name|cinfo
operator|->
name|cquantize
decl_stmt|;
name|JSAMPARRAY
name|colormap
decl_stmt|;
comment|/* Created colormap */
name|int
name|total_colors
decl_stmt|;
comment|/* Number of distinct output colors */
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|nci
decl_stmt|,
name|blksize
decl_stmt|,
name|blkdist
decl_stmt|,
name|ptr
decl_stmt|,
name|val
decl_stmt|;
comment|/* Select number of colors for each component */
name|total_colors
operator|=
name|select_ncolors
argument_list|(
name|cinfo
argument_list|,
name|cquantize
operator|->
name|Ncolors
argument_list|)
expr_stmt|;
comment|/* Report selected color counts */
if|if
condition|(
name|cinfo
operator|->
name|out_color_components
operator|==
literal|3
condition|)
name|TRACEMS4
argument_list|(
name|cinfo
argument_list|,
literal|1
argument_list|,
name|JTRC_QUANT_3_NCOLORS
argument_list|,
name|total_colors
argument_list|,
name|cquantize
operator|->
name|Ncolors
index|[
literal|0
index|]
argument_list|,
name|cquantize
operator|->
name|Ncolors
index|[
literal|1
index|]
argument_list|,
name|cquantize
operator|->
name|Ncolors
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
else|else
name|TRACEMS1
argument_list|(
name|cinfo
argument_list|,
literal|1
argument_list|,
name|JTRC_QUANT_NCOLORS
argument_list|,
name|total_colors
argument_list|)
expr_stmt|;
comment|/* Allocate and fill in the colormap. */
comment|/* The colors are ordered in the map in standard row-major order, */
comment|/* i.e. rightmost (highest-indexed) color changes most rapidly. */
name|colormap
operator|=
call|(
modifier|*
name|cinfo
operator|->
name|mem
operator|->
name|alloc_sarray
call|)
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|,
name|JPOOL_IMAGE
argument_list|,
operator|(
name|JDIMENSION
operator|)
name|total_colors
argument_list|,
operator|(
name|JDIMENSION
operator|)
name|cinfo
operator|->
name|out_color_components
argument_list|)
expr_stmt|;
comment|/* blksize is number of adjacent repeated entries for a component */
comment|/* blkdist is distance between groups of identical entries for a component */
name|blkdist
operator|=
name|total_colors
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cinfo
operator|->
name|out_color_components
condition|;
name|i
operator|++
control|)
block|{
comment|/* fill in colormap entries for i'th color component */
name|nci
operator|=
name|cquantize
operator|->
name|Ncolors
index|[
name|i
index|]
expr_stmt|;
comment|/* # of distinct values for this color */
name|blksize
operator|=
name|blkdist
operator|/
name|nci
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nci
condition|;
name|j
operator|++
control|)
block|{
comment|/* Compute j'th output value (out of nci) for component */
name|val
operator|=
name|output_value
argument_list|(
name|cinfo
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|nci
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Fill in all colormap entries that have this value of this component */
for|for
control|(
name|ptr
operator|=
name|j
operator|*
name|blksize
init|;
name|ptr
operator|<
name|total_colors
condition|;
name|ptr
operator|+=
name|blkdist
control|)
block|{
comment|/* fill in blksize entries beginning at ptr */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|blksize
condition|;
name|k
operator|++
control|)
name|colormap
index|[
name|i
index|]
index|[
name|ptr
operator|+
name|k
index|]
operator|=
operator|(
name|JSAMPLE
operator|)
name|val
expr_stmt|;
block|}
block|}
name|blkdist
operator|=
name|blksize
expr_stmt|;
comment|/* blksize of this color is blkdist of next */
block|}
comment|/* Save the colormap in private storage,    * where it will survive color quantization mode changes.    */
name|cquantize
operator|->
name|sv_colormap
operator|=
name|colormap
expr_stmt|;
name|cquantize
operator|->
name|sv_actual
operator|=
name|total_colors
expr_stmt|;
block|}
end_block
begin_comment
comment|/*  * Create the color index table.  */
end_comment
begin_macro
name|LOCAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|create_colorindex
name|create_colorindex
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|)
end_macro
begin_block
block|{
name|my_cquantize_ptr
name|cquantize
init|=
operator|(
name|my_cquantize_ptr
operator|)
name|cinfo
operator|->
name|cquantize
decl_stmt|;
name|JSAMPROW
name|indexptr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|nci
decl_stmt|,
name|blksize
decl_stmt|,
name|val
decl_stmt|,
name|pad
decl_stmt|;
comment|/* For ordered dither, we pad the color index tables by MAXJSAMPLE in    * each direction (input index values can be -MAXJSAMPLE .. 2*MAXJSAMPLE).    * This is not necessary in the other dithering modes.  However, we    * flag whether it was done in case user changes dithering mode.    */
if|if
condition|(
name|cinfo
operator|->
name|dither_mode
operator|==
name|JDITHER_ORDERED
condition|)
block|{
name|pad
operator|=
name|MAXJSAMPLE
operator|*
literal|2
expr_stmt|;
name|cquantize
operator|->
name|is_padded
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|pad
operator|=
literal|0
expr_stmt|;
name|cquantize
operator|->
name|is_padded
operator|=
name|FALSE
expr_stmt|;
block|}
name|cquantize
operator|->
name|colorindex
operator|=
call|(
modifier|*
name|cinfo
operator|->
name|mem
operator|->
name|alloc_sarray
call|)
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|,
name|JPOOL_IMAGE
argument_list|,
call|(
name|JDIMENSION
call|)
argument_list|(
name|MAXJSAMPLE
operator|+
literal|1
operator|+
name|pad
argument_list|)
argument_list|,
operator|(
name|JDIMENSION
operator|)
name|cinfo
operator|->
name|out_color_components
argument_list|)
expr_stmt|;
comment|/* blksize is number of adjacent repeated entries for a component */
name|blksize
operator|=
name|cquantize
operator|->
name|sv_actual
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cinfo
operator|->
name|out_color_components
condition|;
name|i
operator|++
control|)
block|{
comment|/* fill in colorindex entries for i'th color component */
name|nci
operator|=
name|cquantize
operator|->
name|Ncolors
index|[
name|i
index|]
expr_stmt|;
comment|/* # of distinct values for this color */
name|blksize
operator|=
name|blksize
operator|/
name|nci
expr_stmt|;
comment|/* adjust colorindex pointers to provide padding at negative indexes. */
if|if
condition|(
name|pad
condition|)
name|cquantize
operator|->
name|colorindex
index|[
name|i
index|]
operator|+=
name|MAXJSAMPLE
expr_stmt|;
comment|/* in loop, val = index of current output value, */
comment|/* and k = largest j that maps to current val */
name|indexptr
operator|=
name|cquantize
operator|->
name|colorindex
index|[
name|i
index|]
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
name|k
operator|=
name|largest_input_value
argument_list|(
name|cinfo
argument_list|,
name|i
argument_list|,
literal|0
argument_list|,
name|nci
operator|-
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|MAXJSAMPLE
condition|;
name|j
operator|++
control|)
block|{
while|while
condition|(
name|j
operator|>
name|k
condition|)
comment|/* advance val if past boundary */
name|k
operator|=
name|largest_input_value
argument_list|(
name|cinfo
argument_list|,
name|i
argument_list|,
operator|++
name|val
argument_list|,
name|nci
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* premultiply so that no multiplication needed in main processing */
name|indexptr
index|[
name|j
index|]
operator|=
call|(
name|JSAMPLE
call|)
argument_list|(
name|val
operator|*
name|blksize
argument_list|)
expr_stmt|;
block|}
comment|/* Pad at both ends if necessary */
if|if
condition|(
name|pad
condition|)
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|MAXJSAMPLE
condition|;
name|j
operator|++
control|)
block|{
name|indexptr
index|[
operator|-
name|j
index|]
operator|=
name|indexptr
index|[
literal|0
index|]
expr_stmt|;
name|indexptr
index|[
name|MAXJSAMPLE
operator|+
name|j
index|]
operator|=
name|indexptr
index|[
name|MAXJSAMPLE
index|]
expr_stmt|;
block|}
block|}
block|}
end_block
begin_comment
comment|/*  * Create an ordered-dither array for a component having ncolors  * distinct output values.  */
end_comment
begin_macro
DECL|function|LOCAL
name|LOCAL
argument_list|(
argument|ODITHER_MATRIX_PTR
argument_list|)
end_macro
begin_macro
name|make_odither_array
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|,
argument|int ncolors
argument_list|)
end_macro
begin_block
block|{
name|ODITHER_MATRIX_PTR
name|odither
decl_stmt|;
name|int
name|j
decl_stmt|,
name|k
decl_stmt|;
name|INT32
name|num
decl_stmt|,
name|den
decl_stmt|;
name|odither
operator|=
call|(
name|ODITHER_MATRIX_PTR
call|)
argument_list|(
operator|*
name|cinfo
operator|->
name|mem
operator|->
name|alloc_small
argument_list|)
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|,
name|JPOOL_IMAGE
argument_list|,
name|SIZEOF
argument_list|(
name|ODITHER_MATRIX
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The inter-value distance for this color is MAXJSAMPLE/(ncolors-1).    * Hence the dither value for the matrix cell with fill order f    * (f=0..N-1) should be (N-1-2*f)/(2*N) * MAXJSAMPLE/(ncolors-1).    * On 16-bit-int machine, be careful to avoid overflow.    */
name|den
operator|=
literal|2
operator|*
name|ODITHER_CELLS
operator|*
operator|(
call|(
name|INT32
call|)
argument_list|(
name|ncolors
operator|-
literal|1
argument_list|)
operator|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ODITHER_SIZE
condition|;
name|j
operator|++
control|)
block|{
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|ODITHER_SIZE
condition|;
name|k
operator|++
control|)
block|{
name|num
operator|=
operator|(
call|(
name|INT32
call|)
argument_list|(
name|ODITHER_CELLS
operator|-
literal|1
operator|-
literal|2
operator|*
operator|(
operator|(
name|int
operator|)
name|base_dither_matrix
index|[
name|j
index|]
index|[
name|k
index|]
operator|)
argument_list|)
operator|)
operator|*
name|MAXJSAMPLE
expr_stmt|;
comment|/* Ensure round towards zero despite C's lack of consistency        * about rounding negative values in integer division...        */
name|odither
index|[
name|j
index|]
index|[
name|k
index|]
operator|=
call|(
name|int
call|)
argument_list|(
name|num
operator|<
literal|0
condition|?
operator|-
operator|(
operator|(
operator|-
name|num
operator|)
operator|/
name|den
operator|)
else|:
name|num
operator|/
name|den
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|odither
return|;
block|}
end_block
begin_comment
comment|/*  * Create the ordered-dither tables.  * Components having the same number of representative colors may   * share a dither table.  */
end_comment
begin_macro
name|LOCAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|create_odither_tables
name|create_odither_tables
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|)
end_macro
begin_block
block|{
name|my_cquantize_ptr
name|cquantize
init|=
operator|(
name|my_cquantize_ptr
operator|)
name|cinfo
operator|->
name|cquantize
decl_stmt|;
name|ODITHER_MATRIX_PTR
name|odither
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|nci
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cinfo
operator|->
name|out_color_components
condition|;
name|i
operator|++
control|)
block|{
name|nci
operator|=
name|cquantize
operator|->
name|Ncolors
index|[
name|i
index|]
expr_stmt|;
comment|/* # of distinct values for this color */
name|odither
operator|=
name|NULL
expr_stmt|;
comment|/* search for matching prior component */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|nci
operator|==
name|cquantize
operator|->
name|Ncolors
index|[
name|j
index|]
condition|)
block|{
name|odither
operator|=
name|cquantize
operator|->
name|odither
index|[
name|j
index|]
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|odither
operator|==
name|NULL
condition|)
comment|/* need a new table? */
name|odither
operator|=
name|make_odither_array
argument_list|(
name|cinfo
argument_list|,
name|nci
argument_list|)
expr_stmt|;
name|cquantize
operator|->
name|odither
index|[
name|i
index|]
operator|=
name|odither
expr_stmt|;
block|}
block|}
end_block
begin_comment
comment|/*  * Map some rows of pixels to the output colormapped representation.  */
end_comment
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|color_quantize
name|color_quantize
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|,
argument|JSAMPARRAY input_buf
argument_list|,
argument|JSAMPARRAY output_buf
argument_list|,
argument|int num_rows
argument_list|)
end_macro
begin_comment
comment|/* General case, no dithering */
end_comment
begin_block
block|{
name|my_cquantize_ptr
name|cquantize
init|=
operator|(
name|my_cquantize_ptr
operator|)
name|cinfo
operator|->
name|cquantize
decl_stmt|;
name|JSAMPARRAY
name|colorindex
init|=
name|cquantize
operator|->
name|colorindex
decl_stmt|;
specifier|register
name|int
name|pixcode
decl_stmt|,
name|ci
decl_stmt|;
specifier|register
name|JSAMPROW
name|ptrin
decl_stmt|,
name|ptrout
decl_stmt|;
name|int
name|row
decl_stmt|;
name|JDIMENSION
name|col
decl_stmt|;
name|JDIMENSION
name|width
init|=
name|cinfo
operator|->
name|output_width
decl_stmt|;
specifier|register
name|int
name|nc
init|=
name|cinfo
operator|->
name|out_color_components
decl_stmt|;
for|for
control|(
name|row
operator|=
literal|0
init|;
name|row
operator|<
name|num_rows
condition|;
name|row
operator|++
control|)
block|{
name|ptrin
operator|=
name|input_buf
index|[
name|row
index|]
expr_stmt|;
name|ptrout
operator|=
name|output_buf
index|[
name|row
index|]
expr_stmt|;
for|for
control|(
name|col
operator|=
name|width
init|;
name|col
operator|>
literal|0
condition|;
name|col
operator|--
control|)
block|{
name|pixcode
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ci
operator|=
literal|0
init|;
name|ci
operator|<
name|nc
condition|;
name|ci
operator|++
control|)
block|{
name|pixcode
operator|+=
name|GETJSAMPLE
argument_list|(
name|colorindex
index|[
name|ci
index|]
index|[
name|GETJSAMPLE
argument_list|(
operator|*
name|ptrin
operator|++
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
operator|*
name|ptrout
operator|++
operator|=
operator|(
name|JSAMPLE
operator|)
name|pixcode
expr_stmt|;
block|}
block|}
block|}
end_block
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|color_quantize3
name|color_quantize3
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|,
argument|JSAMPARRAY input_buf
argument_list|,
argument|JSAMPARRAY output_buf
argument_list|,
argument|int num_rows
argument_list|)
end_macro
begin_comment
comment|/* Fast path for out_color_components==3, no dithering */
end_comment
begin_block
block|{
name|my_cquantize_ptr
name|cquantize
init|=
operator|(
name|my_cquantize_ptr
operator|)
name|cinfo
operator|->
name|cquantize
decl_stmt|;
specifier|register
name|int
name|pixcode
decl_stmt|;
specifier|register
name|JSAMPROW
name|ptrin
decl_stmt|,
name|ptrout
decl_stmt|;
name|JSAMPROW
name|colorindex0
init|=
name|cquantize
operator|->
name|colorindex
index|[
literal|0
index|]
decl_stmt|;
name|JSAMPROW
name|colorindex1
init|=
name|cquantize
operator|->
name|colorindex
index|[
literal|1
index|]
decl_stmt|;
name|JSAMPROW
name|colorindex2
init|=
name|cquantize
operator|->
name|colorindex
index|[
literal|2
index|]
decl_stmt|;
name|int
name|row
decl_stmt|;
name|JDIMENSION
name|col
decl_stmt|;
name|JDIMENSION
name|width
init|=
name|cinfo
operator|->
name|output_width
decl_stmt|;
for|for
control|(
name|row
operator|=
literal|0
init|;
name|row
operator|<
name|num_rows
condition|;
name|row
operator|++
control|)
block|{
name|ptrin
operator|=
name|input_buf
index|[
name|row
index|]
expr_stmt|;
name|ptrout
operator|=
name|output_buf
index|[
name|row
index|]
expr_stmt|;
for|for
control|(
name|col
operator|=
name|width
init|;
name|col
operator|>
literal|0
condition|;
name|col
operator|--
control|)
block|{
name|pixcode
operator|=
name|GETJSAMPLE
argument_list|(
name|colorindex0
index|[
name|GETJSAMPLE
argument_list|(
operator|*
name|ptrin
operator|++
argument_list|)
index|]
argument_list|)
expr_stmt|;
name|pixcode
operator|+=
name|GETJSAMPLE
argument_list|(
name|colorindex1
index|[
name|GETJSAMPLE
argument_list|(
operator|*
name|ptrin
operator|++
argument_list|)
index|]
argument_list|)
expr_stmt|;
name|pixcode
operator|+=
name|GETJSAMPLE
argument_list|(
name|colorindex2
index|[
name|GETJSAMPLE
argument_list|(
operator|*
name|ptrin
operator|++
argument_list|)
index|]
argument_list|)
expr_stmt|;
operator|*
name|ptrout
operator|++
operator|=
operator|(
name|JSAMPLE
operator|)
name|pixcode
expr_stmt|;
block|}
block|}
block|}
end_block
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|quantize_ord_dither
name|quantize_ord_dither
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|,
argument|JSAMPARRAY input_buf
argument_list|,
argument|JSAMPARRAY output_buf
argument_list|,
argument|int num_rows
argument_list|)
end_macro
begin_comment
comment|/* General case, with ordered dithering */
end_comment
begin_block
block|{
name|my_cquantize_ptr
name|cquantize
init|=
operator|(
name|my_cquantize_ptr
operator|)
name|cinfo
operator|->
name|cquantize
decl_stmt|;
specifier|register
name|JSAMPROW
name|input_ptr
decl_stmt|;
specifier|register
name|JSAMPROW
name|output_ptr
decl_stmt|;
name|JSAMPROW
name|colorindex_ci
decl_stmt|;
name|int
modifier|*
name|dither
decl_stmt|;
comment|/* points to active row of dither matrix */
name|int
name|row_index
decl_stmt|,
name|col_index
decl_stmt|;
comment|/* current indexes into dither matrix */
name|int
name|nc
init|=
name|cinfo
operator|->
name|out_color_components
decl_stmt|;
name|int
name|ci
decl_stmt|;
name|int
name|row
decl_stmt|;
name|JDIMENSION
name|col
decl_stmt|;
name|JDIMENSION
name|width
init|=
name|cinfo
operator|->
name|output_width
decl_stmt|;
for|for
control|(
name|row
operator|=
literal|0
init|;
name|row
operator|<
name|num_rows
condition|;
name|row
operator|++
control|)
block|{
comment|/* Initialize output values to 0 so can process components separately */
name|jzero_far
argument_list|(
operator|(
name|void
name|FAR
operator|*
operator|)
name|output_buf
index|[
name|row
index|]
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|width
operator|*
name|SIZEOF
argument_list|(
name|JSAMPLE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|row_index
operator|=
name|cquantize
operator|->
name|row_index
expr_stmt|;
for|for
control|(
name|ci
operator|=
literal|0
init|;
name|ci
operator|<
name|nc
condition|;
name|ci
operator|++
control|)
block|{
name|input_ptr
operator|=
name|input_buf
index|[
name|row
index|]
operator|+
name|ci
expr_stmt|;
name|output_ptr
operator|=
name|output_buf
index|[
name|row
index|]
expr_stmt|;
name|colorindex_ci
operator|=
name|cquantize
operator|->
name|colorindex
index|[
name|ci
index|]
expr_stmt|;
name|dither
operator|=
name|cquantize
operator|->
name|odither
index|[
name|ci
index|]
index|[
name|row_index
index|]
expr_stmt|;
name|col_index
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|col
operator|=
name|width
init|;
name|col
operator|>
literal|0
condition|;
name|col
operator|--
control|)
block|{
comment|/* Form pixel value + dither, range-limit to 0..MAXJSAMPLE, 	 * select output value, accumulate into output code for this pixel. 	 * Range-limiting need not be done explicitly, as we have extended 	 * the colorindex table to produce the right answers for out-of-range 	 * inputs.  The maximum dither is +- MAXJSAMPLE; this sets the 	 * required amount of padding. 	 */
operator|*
name|output_ptr
operator|+=
name|colorindex_ci
index|[
name|GETJSAMPLE
argument_list|(
operator|*
name|input_ptr
argument_list|)
operator|+
name|dither
index|[
name|col_index
index|]
index|]
expr_stmt|;
name|input_ptr
operator|+=
name|nc
expr_stmt|;
name|output_ptr
operator|++
expr_stmt|;
name|col_index
operator|=
operator|(
name|col_index
operator|+
literal|1
operator|)
operator|&
name|ODITHER_MASK
expr_stmt|;
block|}
block|}
comment|/* Advance row index for next row */
name|row_index
operator|=
operator|(
name|row_index
operator|+
literal|1
operator|)
operator|&
name|ODITHER_MASK
expr_stmt|;
name|cquantize
operator|->
name|row_index
operator|=
name|row_index
expr_stmt|;
block|}
block|}
end_block
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|quantize3_ord_dither
name|quantize3_ord_dither
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|,
argument|JSAMPARRAY input_buf
argument_list|,
argument|JSAMPARRAY output_buf
argument_list|,
argument|int num_rows
argument_list|)
end_macro
begin_comment
comment|/* Fast path for out_color_components==3, with ordered dithering */
end_comment
begin_block
block|{
name|my_cquantize_ptr
name|cquantize
init|=
operator|(
name|my_cquantize_ptr
operator|)
name|cinfo
operator|->
name|cquantize
decl_stmt|;
specifier|register
name|int
name|pixcode
decl_stmt|;
specifier|register
name|JSAMPROW
name|input_ptr
decl_stmt|;
specifier|register
name|JSAMPROW
name|output_ptr
decl_stmt|;
name|JSAMPROW
name|colorindex0
init|=
name|cquantize
operator|->
name|colorindex
index|[
literal|0
index|]
decl_stmt|;
name|JSAMPROW
name|colorindex1
init|=
name|cquantize
operator|->
name|colorindex
index|[
literal|1
index|]
decl_stmt|;
name|JSAMPROW
name|colorindex2
init|=
name|cquantize
operator|->
name|colorindex
index|[
literal|2
index|]
decl_stmt|;
name|int
modifier|*
name|dither0
decl_stmt|;
comment|/* points to active row of dither matrix */
name|int
modifier|*
name|dither1
decl_stmt|;
name|int
modifier|*
name|dither2
decl_stmt|;
name|int
name|row_index
decl_stmt|,
name|col_index
decl_stmt|;
comment|/* current indexes into dither matrix */
name|int
name|row
decl_stmt|;
name|JDIMENSION
name|col
decl_stmt|;
name|JDIMENSION
name|width
init|=
name|cinfo
operator|->
name|output_width
decl_stmt|;
for|for
control|(
name|row
operator|=
literal|0
init|;
name|row
operator|<
name|num_rows
condition|;
name|row
operator|++
control|)
block|{
name|row_index
operator|=
name|cquantize
operator|->
name|row_index
expr_stmt|;
name|input_ptr
operator|=
name|input_buf
index|[
name|row
index|]
expr_stmt|;
name|output_ptr
operator|=
name|output_buf
index|[
name|row
index|]
expr_stmt|;
name|dither0
operator|=
name|cquantize
operator|->
name|odither
index|[
literal|0
index|]
index|[
name|row_index
index|]
expr_stmt|;
name|dither1
operator|=
name|cquantize
operator|->
name|odither
index|[
literal|1
index|]
index|[
name|row_index
index|]
expr_stmt|;
name|dither2
operator|=
name|cquantize
operator|->
name|odither
index|[
literal|2
index|]
index|[
name|row_index
index|]
expr_stmt|;
name|col_index
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|col
operator|=
name|width
init|;
name|col
operator|>
literal|0
condition|;
name|col
operator|--
control|)
block|{
name|pixcode
operator|=
name|GETJSAMPLE
argument_list|(
name|colorindex0
index|[
name|GETJSAMPLE
argument_list|(
operator|*
name|input_ptr
operator|++
argument_list|)
operator|+
name|dither0
index|[
name|col_index
index|]
index|]
argument_list|)
expr_stmt|;
name|pixcode
operator|+=
name|GETJSAMPLE
argument_list|(
name|colorindex1
index|[
name|GETJSAMPLE
argument_list|(
operator|*
name|input_ptr
operator|++
argument_list|)
operator|+
name|dither1
index|[
name|col_index
index|]
index|]
argument_list|)
expr_stmt|;
name|pixcode
operator|+=
name|GETJSAMPLE
argument_list|(
name|colorindex2
index|[
name|GETJSAMPLE
argument_list|(
operator|*
name|input_ptr
operator|++
argument_list|)
operator|+
name|dither2
index|[
name|col_index
index|]
index|]
argument_list|)
expr_stmt|;
operator|*
name|output_ptr
operator|++
operator|=
operator|(
name|JSAMPLE
operator|)
name|pixcode
expr_stmt|;
name|col_index
operator|=
operator|(
name|col_index
operator|+
literal|1
operator|)
operator|&
name|ODITHER_MASK
expr_stmt|;
block|}
name|row_index
operator|=
operator|(
name|row_index
operator|+
literal|1
operator|)
operator|&
name|ODITHER_MASK
expr_stmt|;
name|cquantize
operator|->
name|row_index
operator|=
name|row_index
expr_stmt|;
block|}
block|}
end_block
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|quantize_fs_dither
name|quantize_fs_dither
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|,
argument|JSAMPARRAY input_buf
argument_list|,
argument|JSAMPARRAY output_buf
argument_list|,
argument|int num_rows
argument_list|)
end_macro
begin_comment
comment|/* General case, with Floyd-Steinberg dithering */
end_comment
begin_block
block|{
name|my_cquantize_ptr
name|cquantize
init|=
operator|(
name|my_cquantize_ptr
operator|)
name|cinfo
operator|->
name|cquantize
decl_stmt|;
specifier|register
name|LOCFSERROR
name|cur
decl_stmt|;
comment|/* current error or pixel value */
name|LOCFSERROR
name|belowerr
decl_stmt|;
comment|/* error for pixel below cur */
name|LOCFSERROR
name|bpreverr
decl_stmt|;
comment|/* error for below/prev col */
name|LOCFSERROR
name|bnexterr
decl_stmt|;
comment|/* error for below/next col */
name|LOCFSERROR
name|delta
decl_stmt|;
specifier|register
name|FSERRPTR
name|errorptr
decl_stmt|;
comment|/* => fserrors[] at column before current */
specifier|register
name|JSAMPROW
name|input_ptr
decl_stmt|;
specifier|register
name|JSAMPROW
name|output_ptr
decl_stmt|;
name|JSAMPROW
name|colorindex_ci
decl_stmt|;
name|JSAMPROW
name|colormap_ci
decl_stmt|;
name|int
name|pixcode
decl_stmt|;
name|int
name|nc
init|=
name|cinfo
operator|->
name|out_color_components
decl_stmt|;
name|int
name|dir
decl_stmt|;
comment|/* 1 for left-to-right, -1 for right-to-left */
name|int
name|dirnc
decl_stmt|;
comment|/* dir * nc */
name|int
name|ci
decl_stmt|;
name|int
name|row
decl_stmt|;
name|JDIMENSION
name|col
decl_stmt|;
name|JDIMENSION
name|width
init|=
name|cinfo
operator|->
name|output_width
decl_stmt|;
name|JSAMPLE
modifier|*
name|range_limit
init|=
name|cinfo
operator|->
name|sample_range_limit
decl_stmt|;
name|SHIFT_TEMPS
for|for
control|(
name|row
operator|=
literal|0
init|;
name|row
operator|<
name|num_rows
condition|;
name|row
operator|++
control|)
block|{
comment|/* Initialize output values to 0 so can process components separately */
name|jzero_far
argument_list|(
operator|(
name|void
name|FAR
operator|*
operator|)
name|output_buf
index|[
name|row
index|]
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|width
operator|*
name|SIZEOF
argument_list|(
name|JSAMPLE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|ci
operator|=
literal|0
init|;
name|ci
operator|<
name|nc
condition|;
name|ci
operator|++
control|)
block|{
name|input_ptr
operator|=
name|input_buf
index|[
name|row
index|]
operator|+
name|ci
expr_stmt|;
name|output_ptr
operator|=
name|output_buf
index|[
name|row
index|]
expr_stmt|;
if|if
condition|(
name|cquantize
operator|->
name|on_odd_row
condition|)
block|{
comment|/* work right to left in this row */
name|input_ptr
operator|+=
operator|(
name|width
operator|-
literal|1
operator|)
operator|*
name|nc
expr_stmt|;
comment|/* so point to rightmost pixel */
name|output_ptr
operator|+=
name|width
operator|-
literal|1
expr_stmt|;
name|dir
operator|=
operator|-
literal|1
expr_stmt|;
name|dirnc
operator|=
operator|-
name|nc
expr_stmt|;
name|errorptr
operator|=
name|cquantize
operator|->
name|fserrors
index|[
name|ci
index|]
operator|+
operator|(
name|width
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* => entry after last column */
block|}
else|else
block|{
comment|/* work left to right in this row */
name|dir
operator|=
literal|1
expr_stmt|;
name|dirnc
operator|=
name|nc
expr_stmt|;
name|errorptr
operator|=
name|cquantize
operator|->
name|fserrors
index|[
name|ci
index|]
expr_stmt|;
comment|/* => entry before first column */
block|}
name|colorindex_ci
operator|=
name|cquantize
operator|->
name|colorindex
index|[
name|ci
index|]
expr_stmt|;
name|colormap_ci
operator|=
name|cquantize
operator|->
name|sv_colormap
index|[
name|ci
index|]
expr_stmt|;
comment|/* Preset error values: no error propagated to first pixel from left */
name|cur
operator|=
literal|0
expr_stmt|;
comment|/* and no error propagated to row below yet */
name|belowerr
operator|=
name|bpreverr
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|col
operator|=
name|width
init|;
name|col
operator|>
literal|0
condition|;
name|col
operator|--
control|)
block|{
comment|/* cur holds the error propagated from the previous pixel on the 	 * current line.  Add the error propagated from the previous line 	 * to form the complete error correction term for this pixel, and 	 * round the error term (which is expressed * 16) to an integer. 	 * RIGHT_SHIFT rounds towards minus infinity, so adding 8 is correct 	 * for either sign of the error value. 	 * Note: errorptr points to *previous* column's array entry. 	 */
name|cur
operator|=
name|RIGHT_SHIFT
argument_list|(
name|cur
operator|+
name|errorptr
index|[
name|dir
index|]
operator|+
literal|8
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Form pixel value + error, and range-limit to 0..MAXJSAMPLE. 	 * The maximum error is +- MAXJSAMPLE; this sets the required size 	 * of the range_limit array. 	 */
name|cur
operator|+=
name|GETJSAMPLE
argument_list|(
operator|*
name|input_ptr
argument_list|)
expr_stmt|;
name|cur
operator|=
name|GETJSAMPLE
argument_list|(
name|range_limit
index|[
name|cur
index|]
argument_list|)
expr_stmt|;
comment|/* Select output value, accumulate into output code for this pixel */
name|pixcode
operator|=
name|GETJSAMPLE
argument_list|(
name|colorindex_ci
index|[
name|cur
index|]
argument_list|)
expr_stmt|;
operator|*
name|output_ptr
operator|+=
operator|(
name|JSAMPLE
operator|)
name|pixcode
expr_stmt|;
comment|/* Compute actual representation error at this pixel */
comment|/* Note: we can do this even though we don't have the final */
comment|/* pixel code, because the colormap is orthogonal. */
name|cur
operator|-=
name|GETJSAMPLE
argument_list|(
name|colormap_ci
index|[
name|pixcode
index|]
argument_list|)
expr_stmt|;
comment|/* Compute error fractions to be propagated to adjacent pixels. 	 * Add these into the running sums, and simultaneously shift the 	 * next-line error sums left by 1 column. 	 */
name|bnexterr
operator|=
name|cur
expr_stmt|;
name|delta
operator|=
name|cur
operator|*
literal|2
expr_stmt|;
name|cur
operator|+=
name|delta
expr_stmt|;
comment|/* form error * 3 */
name|errorptr
index|[
literal|0
index|]
operator|=
call|(
name|FSERROR
call|)
argument_list|(
name|bpreverr
operator|+
name|cur
argument_list|)
expr_stmt|;
name|cur
operator|+=
name|delta
expr_stmt|;
comment|/* form error * 5 */
name|bpreverr
operator|=
name|belowerr
operator|+
name|cur
expr_stmt|;
name|belowerr
operator|=
name|bnexterr
expr_stmt|;
name|cur
operator|+=
name|delta
expr_stmt|;
comment|/* form error * 7 */
comment|/* At this point cur contains the 7/16 error value to be propagated 	 * to the next pixel on the current line, and all the errors for the 	 * next line have been shifted over. We are therefore ready to move on. 	 */
name|input_ptr
operator|+=
name|dirnc
expr_stmt|;
comment|/* advance input ptr to next column */
name|output_ptr
operator|+=
name|dir
expr_stmt|;
comment|/* advance output ptr to next column */
name|errorptr
operator|+=
name|dir
expr_stmt|;
comment|/* advance errorptr to current column */
block|}
comment|/* Post-loop cleanup: we must unload the final error value into the        * final fserrors[] entry.  Note we need not unload belowerr because        * it is for the dummy column before or after the actual array.        */
name|errorptr
index|[
literal|0
index|]
operator|=
operator|(
name|FSERROR
operator|)
name|bpreverr
expr_stmt|;
comment|/* unload prev err into array */
block|}
name|cquantize
operator|->
name|on_odd_row
operator|=
operator|(
name|cquantize
operator|->
name|on_odd_row
condition|?
name|FALSE
else|:
name|TRUE
operator|)
expr_stmt|;
block|}
block|}
end_block
begin_comment
comment|/*  * Allocate workspace for Floyd-Steinberg errors.  */
end_comment
begin_macro
name|LOCAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|alloc_fs_workspace
name|alloc_fs_workspace
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|)
end_macro
begin_block
block|{
name|my_cquantize_ptr
name|cquantize
init|=
operator|(
name|my_cquantize_ptr
operator|)
name|cinfo
operator|->
name|cquantize
decl_stmt|;
name|size_t
name|arraysize
decl_stmt|;
name|int
name|i
decl_stmt|;
name|arraysize
operator|=
call|(
name|size_t
call|)
argument_list|(
operator|(
name|cinfo
operator|->
name|output_width
operator|+
literal|2
operator|)
operator|*
name|SIZEOF
argument_list|(
name|FSERROR
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cinfo
operator|->
name|out_color_components
condition|;
name|i
operator|++
control|)
block|{
name|cquantize
operator|->
name|fserrors
index|[
name|i
index|]
operator|=
call|(
name|FSERRPTR
call|)
argument_list|(
operator|*
name|cinfo
operator|->
name|mem
operator|->
name|alloc_large
argument_list|)
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|,
name|JPOOL_IMAGE
argument_list|,
name|arraysize
argument_list|)
expr_stmt|;
block|}
block|}
end_block
begin_comment
comment|/*  * Initialize for one-pass color quantization.  */
end_comment
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|start_pass_1_quant
name|start_pass_1_quant
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|,
argument|boolean is_pre_scan
argument_list|)
end_macro
begin_block
block|{
name|my_cquantize_ptr
name|cquantize
init|=
operator|(
name|my_cquantize_ptr
operator|)
name|cinfo
operator|->
name|cquantize
decl_stmt|;
name|size_t
name|arraysize
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Install my colormap. */
name|cinfo
operator|->
name|colormap
operator|=
name|cquantize
operator|->
name|sv_colormap
expr_stmt|;
name|cinfo
operator|->
name|actual_number_of_colors
operator|=
name|cquantize
operator|->
name|sv_actual
expr_stmt|;
comment|/* Initialize for desired dithering mode. */
switch|switch
condition|(
name|cinfo
operator|->
name|dither_mode
condition|)
block|{
case|case
name|JDITHER_NONE
case|:
if|if
condition|(
name|cinfo
operator|->
name|out_color_components
operator|==
literal|3
condition|)
name|cquantize
operator|->
name|pub
operator|.
name|color_quantize
operator|=
name|color_quantize3
expr_stmt|;
else|else
name|cquantize
operator|->
name|pub
operator|.
name|color_quantize
operator|=
name|color_quantize
expr_stmt|;
break|break;
case|case
name|JDITHER_ORDERED
case|:
if|if
condition|(
name|cinfo
operator|->
name|out_color_components
operator|==
literal|3
condition|)
name|cquantize
operator|->
name|pub
operator|.
name|color_quantize
operator|=
name|quantize3_ord_dither
expr_stmt|;
else|else
name|cquantize
operator|->
name|pub
operator|.
name|color_quantize
operator|=
name|quantize_ord_dither
expr_stmt|;
name|cquantize
operator|->
name|row_index
operator|=
literal|0
expr_stmt|;
comment|/* initialize state for ordered dither */
comment|/* If user changed to ordered dither from another mode,      * we must recreate the color index table with padding.      * This will cost extra space, but probably isn't very likely.      */
if|if
condition|(
operator|!
name|cquantize
operator|->
name|is_padded
condition|)
name|create_colorindex
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
comment|/* Create ordered-dither tables if we didn't already. */
if|if
condition|(
name|cquantize
operator|->
name|odither
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
name|create_odither_tables
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
break|break;
case|case
name|JDITHER_FS
case|:
name|cquantize
operator|->
name|pub
operator|.
name|color_quantize
operator|=
name|quantize_fs_dither
expr_stmt|;
name|cquantize
operator|->
name|on_odd_row
operator|=
name|FALSE
expr_stmt|;
comment|/* initialize state for F-S dither */
comment|/* Allocate Floyd-Steinberg workspace if didn't already. */
if|if
condition|(
name|cquantize
operator|->
name|fserrors
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
name|alloc_fs_workspace
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
comment|/* Initialize the propagated errors to zero. */
name|arraysize
operator|=
call|(
name|size_t
call|)
argument_list|(
operator|(
name|cinfo
operator|->
name|output_width
operator|+
literal|2
operator|)
operator|*
name|SIZEOF
argument_list|(
name|FSERROR
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cinfo
operator|->
name|out_color_components
condition|;
name|i
operator|++
control|)
name|jzero_far
argument_list|(
operator|(
name|void
name|FAR
operator|*
operator|)
name|cquantize
operator|->
name|fserrors
index|[
name|i
index|]
argument_list|,
name|arraysize
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_NOT_COMPILED
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_block
begin_comment
comment|/*  * Finish up at the end of the pass.  */
end_comment
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|finish_pass_1_quant
name|finish_pass_1_quant
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|)
end_macro
begin_block
block|{
comment|/* no work in 1-pass case */
block|}
end_block
begin_comment
comment|/*  * Switch to a new external colormap between output passes.  * Shouldn't get to this module!  */
end_comment
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|new_color_map_1_quant
name|new_color_map_1_quant
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|)
end_macro
begin_block
block|{
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_MODE_CHANGE
argument_list|)
expr_stmt|;
block|}
end_block
begin_comment
comment|/*  * Module initialization routine for 1-pass color quantization.  */
end_comment
begin_macro
name|GLOBAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|jinit_1pass_quantizer
name|jinit_1pass_quantizer
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|)
end_macro
begin_block
block|{
name|my_cquantize_ptr
name|cquantize
decl_stmt|;
name|cquantize
operator|=
call|(
name|my_cquantize_ptr
call|)
argument_list|(
operator|*
name|cinfo
operator|->
name|mem
operator|->
name|alloc_small
argument_list|)
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|,
name|JPOOL_IMAGE
argument_list|,
name|SIZEOF
argument_list|(
name|my_cquantizer
argument_list|)
argument_list|)
expr_stmt|;
name|cinfo
operator|->
name|cquantize
operator|=
operator|(
expr|struct
name|jpeg_color_quantizer
operator|*
operator|)
name|cquantize
expr_stmt|;
name|cquantize
operator|->
name|pub
operator|.
name|start_pass
operator|=
name|start_pass_1_quant
expr_stmt|;
name|cquantize
operator|->
name|pub
operator|.
name|finish_pass
operator|=
name|finish_pass_1_quant
expr_stmt|;
name|cquantize
operator|->
name|pub
operator|.
name|new_color_map
operator|=
name|new_color_map_1_quant
expr_stmt|;
name|cquantize
operator|->
name|fserrors
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* Flag FS workspace not allocated */
name|cquantize
operator|->
name|odither
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* Also flag odither arrays not allocated */
comment|/* Make sure my internal arrays won't overflow */
if|if
condition|(
name|cinfo
operator|->
name|out_color_components
operator|>
name|MAX_Q_COMPS
condition|)
name|ERREXIT1
argument_list|(
name|cinfo
argument_list|,
name|JERR_QUANT_COMPONENTS
argument_list|,
name|MAX_Q_COMPS
argument_list|)
expr_stmt|;
comment|/* Make sure colormap indexes can be represented by JSAMPLEs */
if|if
condition|(
name|cinfo
operator|->
name|desired_number_of_colors
operator|>
operator|(
name|MAXJSAMPLE
operator|+
literal|1
operator|)
condition|)
name|ERREXIT1
argument_list|(
name|cinfo
argument_list|,
name|JERR_QUANT_MANY_COLORS
argument_list|,
name|MAXJSAMPLE
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Create the colormap and color index table. */
name|create_colormap
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
name|create_colorindex
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
comment|/* Allocate Floyd-Steinberg workspace now if requested.    * We do this now since it is FAR storage and may affect the memory    * manager's space calculations.  If the user changes to FS dither    * mode in a later pass, we will allocate the space then, and will    * possibly overrun the max_memory_to_use setting.    */
if|if
condition|(
name|cinfo
operator|->
name|dither_mode
operator|==
name|JDITHER_FS
condition|)
name|alloc_fs_workspace
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
block|}
end_block
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* QUANT_1PASS_SUPPORTED */
end_comment
end_unit
