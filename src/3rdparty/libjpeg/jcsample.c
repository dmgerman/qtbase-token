begin_unit
begin_comment
comment|/*  * jcsample.c  *  * Copyright (C) 1991-1996, Thomas G. Lane.  * This file is part of the Independent JPEG Group's software.  * For conditions of distribution and use, see the accompanying README file.  *  * This file contains downsampling routines.  *  * Downsampling input data is counted in "row groups".  A row group  * is defined to be max_v_samp_factor pixel rows of each component,  * from which the downsampler produces v_samp_factor sample rows.  * A single row group is processed in each call to the downsampler module.  *  * The downsampler is responsible for edge-expansion of its output data  * to fill an integral number of DCT blocks horizontally.  The source buffer  * may be modified if it is helpful for this purpose (the source buffer is  * allocated wide enough to correspond to the desired output width).  * The caller (the prep controller) is responsible for vertical padding.  *  * The downsampler may request "context rows" by setting need_context_rows  * during startup.  In this case, the input arrays will contain at least  * one row group's worth of pixels above and below the passed-in data;  * the caller will create dummy rows at image top and bottom by replicating  * the first or last real pixel row.  *  * An excellent reference for image resampling is  *   Digital Image Warping, George Wolberg, 1990.  *   Pub. by IEEE Computer Society Press, Los Alamitos, CA. ISBN 0-8186-8944-7.  *  * The downsampling algorithm used here is a simple average of the source  * pixels covered by the output pixel.  The hi-falutin sampling literature  * refers to this as a "box filter".  In general the characteristics of a box  * filter are not very good, but for the specific cases we normally use (1:1  * and 2:1 ratios) the box is equivalent to a "triangle filter" which is not  * nearly so bad.  If you intend to use other sampling ratios, you'd be well  * advised to improve this code.  *  * A simple input-smoothing capability is provided.  This is mainly intended  * for cleaning up color-dithered GIF input files (if you find it inadequate,  * we suggest using an external filtering program such as pnmconvol).  When  * enabled, each input pixel P is replaced by a weighted sum of itself and its  * eight neighbors.  P's weight is 1-8*SF and each neighbor's weight is SF,  * where SF = (smoothing_factor / 1024).  * Currently, smoothing is only supported for 2h2v sampling factors.  */
end_comment
begin_define
DECL|macro|JPEG_INTERNALS
define|#
directive|define
name|JPEG_INTERNALS
end_define
begin_include
include|#
directive|include
file|"jinclude.h"
end_include
begin_include
include|#
directive|include
file|"jpeglib.h"
end_include
begin_comment
comment|/* Pointer to routine to downsample a single component */
end_comment
begin_typedef
DECL|typedef|JMETHOD
typedef|typedef
name|JMETHOD
argument_list|(
name|void
argument_list|,
name|downsample1_ptr
argument_list|,
operator|(
name|j_compress_ptr
name|cinfo
operator|,
name|jpeg_component_info
operator|*
name|compptr
operator|,
name|JSAMPARRAY
name|input_data
operator|,
name|JSAMPARRAY
name|output_data
operator|)
argument_list|)
expr_stmt|;
end_typedef
begin_comment
comment|/* Private subobject */
end_comment
begin_typedef
typedef|typedef
struct|struct
block|{
DECL|member|pub
name|struct
name|jpeg_downsampler
name|pub
decl_stmt|;
comment|/* public fields */
comment|/* Downsampling method pointers, one per component */
DECL|member|methods
name|downsample1_ptr
name|methods
index|[
name|MAX_COMPONENTS
index|]
decl_stmt|;
comment|/* Height of an output row group for each component. */
DECL|member|rowgroup_height
name|int
name|rowgroup_height
index|[
name|MAX_COMPONENTS
index|]
decl_stmt|;
comment|/* These arrays save pixel expansion factors so that int_downsample need not    * recompute them each time.  They are unused for other downsampling methods.    */
DECL|member|h_expand
name|UINT8
name|h_expand
index|[
name|MAX_COMPONENTS
index|]
decl_stmt|;
DECL|member|v_expand
name|UINT8
name|v_expand
index|[
name|MAX_COMPONENTS
index|]
decl_stmt|;
block|}
DECL|typedef|my_downsampler
name|my_downsampler
typedef|;
end_typedef
begin_typedef
DECL|typedef|my_downsample_ptr
typedef|typedef
name|my_downsampler
modifier|*
name|my_downsample_ptr
typedef|;
end_typedef
begin_comment
comment|/*  * Initialize for a downsampling pass.  */
end_comment
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|start_pass_downsample
name|start_pass_downsample
argument_list|(
argument|j_compress_ptr cinfo
argument_list|)
end_macro
begin_block
block|{
comment|/* no work for now */
block|}
end_block
begin_comment
comment|/*  * Expand a component horizontally from width input_cols to width output_cols,  * by duplicating the rightmost samples.  */
end_comment
begin_macro
name|LOCAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|expand_right_edge
name|expand_right_edge
argument_list|(
argument|JSAMPARRAY image_data
argument_list|,
argument|int num_rows
argument_list|,
argument|JDIMENSION input_cols
argument_list|,
argument|JDIMENSION output_cols
argument_list|)
end_macro
begin_block
block|{
specifier|register
name|JSAMPROW
name|ptr
decl_stmt|;
specifier|register
name|JSAMPLE
name|pixval
decl_stmt|;
specifier|register
name|int
name|count
decl_stmt|;
name|int
name|row
decl_stmt|;
name|int
name|numcols
init|=
call|(
name|int
call|)
argument_list|(
name|output_cols
operator|-
name|input_cols
argument_list|)
decl_stmt|;
if|if
condition|(
name|numcols
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|row
operator|=
literal|0
init|;
name|row
operator|<
name|num_rows
condition|;
name|row
operator|++
control|)
block|{
name|ptr
operator|=
name|image_data
index|[
name|row
index|]
operator|+
name|input_cols
expr_stmt|;
name|pixval
operator|=
name|ptr
index|[
operator|-
literal|1
index|]
expr_stmt|;
comment|/* don't need GETJSAMPLE() here */
for|for
control|(
name|count
operator|=
name|numcols
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
control|)
operator|*
name|ptr
operator|++
operator|=
name|pixval
expr_stmt|;
block|}
block|}
block|}
end_block
begin_comment
comment|/*  * Do downsampling for a whole row group (all components).  *  * In this version we simply downsample each component independently.  */
end_comment
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|sep_downsample
name|sep_downsample
argument_list|(
argument|j_compress_ptr cinfo
argument_list|,
argument|JSAMPIMAGE input_buf
argument_list|,
argument|JDIMENSION in_row_index
argument_list|,
argument|JSAMPIMAGE output_buf
argument_list|,
argument|JDIMENSION out_row_group_index
argument_list|)
end_macro
begin_block
block|{
name|my_downsample_ptr
name|downsample
init|=
operator|(
name|my_downsample_ptr
operator|)
name|cinfo
operator|->
name|downsample
decl_stmt|;
name|int
name|ci
decl_stmt|;
name|jpeg_component_info
modifier|*
name|compptr
decl_stmt|;
name|JSAMPARRAY
name|in_ptr
decl_stmt|,
name|out_ptr
decl_stmt|;
for|for
control|(
name|ci
operator|=
literal|0
operator|,
name|compptr
operator|=
name|cinfo
operator|->
name|comp_info
init|;
name|ci
operator|<
name|cinfo
operator|->
name|num_components
condition|;
name|ci
operator|++
operator|,
name|compptr
operator|++
control|)
block|{
name|in_ptr
operator|=
name|input_buf
index|[
name|ci
index|]
operator|+
name|in_row_index
expr_stmt|;
name|out_ptr
operator|=
name|output_buf
index|[
name|ci
index|]
operator|+
operator|(
name|out_row_group_index
operator|*
name|downsample
operator|->
name|rowgroup_height
index|[
name|ci
index|]
operator|)
expr_stmt|;
call|(
modifier|*
name|downsample
operator|->
name|methods
index|[
name|ci
index|]
call|)
argument_list|(
name|cinfo
argument_list|,
name|compptr
argument_list|,
name|in_ptr
argument_list|,
name|out_ptr
argument_list|)
expr_stmt|;
block|}
block|}
end_block
begin_comment
comment|/*  * Downsample pixel values of a single component.  * One row group is processed per call.  * This version handles arbitrary integral sampling ratios, without smoothing.  * Note that this version is not actually used for customary sampling ratios.  */
end_comment
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|int_downsample
name|int_downsample
argument_list|(
argument|j_compress_ptr cinfo
argument_list|,
argument|jpeg_component_info * compptr
argument_list|,
argument|JSAMPARRAY input_data
argument_list|,
argument|JSAMPARRAY output_data
argument_list|)
end_macro
begin_block
block|{
name|my_downsample_ptr
name|downsample
init|=
operator|(
name|my_downsample_ptr
operator|)
name|cinfo
operator|->
name|downsample
decl_stmt|;
name|int
name|inrow
decl_stmt|,
name|outrow
decl_stmt|,
name|h_expand
decl_stmt|,
name|v_expand
decl_stmt|,
name|numpix
decl_stmt|,
name|numpix2
decl_stmt|,
name|h
decl_stmt|,
name|v
decl_stmt|;
name|JDIMENSION
name|outcol
decl_stmt|,
name|outcol_h
decl_stmt|;
comment|/* outcol_h == outcol*h_expand */
name|JDIMENSION
name|output_cols
init|=
name|compptr
operator|->
name|width_in_blocks
operator|*
name|compptr
operator|->
name|DCT_h_scaled_size
decl_stmt|;
name|JSAMPROW
name|inptr
decl_stmt|,
name|outptr
decl_stmt|;
name|INT32
name|outvalue
decl_stmt|;
name|h_expand
operator|=
name|downsample
operator|->
name|h_expand
index|[
name|compptr
operator|->
name|component_index
index|]
expr_stmt|;
name|v_expand
operator|=
name|downsample
operator|->
name|v_expand
index|[
name|compptr
operator|->
name|component_index
index|]
expr_stmt|;
name|numpix
operator|=
name|h_expand
operator|*
name|v_expand
expr_stmt|;
name|numpix2
operator|=
name|numpix
operator|/
literal|2
expr_stmt|;
comment|/* Expand input data enough to let all the output samples be generated    * by the standard loop.  Special-casing padded output would be more    * efficient.    */
name|expand_right_edge
argument_list|(
name|input_data
argument_list|,
name|cinfo
operator|->
name|max_v_samp_factor
argument_list|,
name|cinfo
operator|->
name|image_width
argument_list|,
name|output_cols
operator|*
name|h_expand
argument_list|)
expr_stmt|;
name|inrow
operator|=
name|outrow
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|inrow
operator|<
name|cinfo
operator|->
name|max_v_samp_factor
condition|)
block|{
name|outptr
operator|=
name|output_data
index|[
name|outrow
index|]
expr_stmt|;
for|for
control|(
name|outcol
operator|=
literal|0
operator|,
name|outcol_h
operator|=
literal|0
init|;
name|outcol
operator|<
name|output_cols
condition|;
name|outcol
operator|++
operator|,
name|outcol_h
operator|+=
name|h_expand
control|)
block|{
name|outvalue
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|v
operator|=
literal|0
init|;
name|v
operator|<
name|v_expand
condition|;
name|v
operator|++
control|)
block|{
name|inptr
operator|=
name|input_data
index|[
name|inrow
operator|+
name|v
index|]
operator|+
name|outcol_h
expr_stmt|;
for|for
control|(
name|h
operator|=
literal|0
init|;
name|h
operator|<
name|h_expand
condition|;
name|h
operator|++
control|)
block|{
name|outvalue
operator|+=
operator|(
name|INT32
operator|)
name|GETJSAMPLE
argument_list|(
operator|*
name|inptr
operator|++
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|outptr
operator|++
operator|=
call|(
name|JSAMPLE
call|)
argument_list|(
operator|(
name|outvalue
operator|+
name|numpix2
operator|)
operator|/
name|numpix
argument_list|)
expr_stmt|;
block|}
name|inrow
operator|+=
name|v_expand
expr_stmt|;
name|outrow
operator|++
expr_stmt|;
block|}
block|}
end_block
begin_comment
comment|/*  * Downsample pixel values of a single component.  * This version handles the special case of a full-size component,  * without smoothing.  */
end_comment
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|fullsize_downsample
name|fullsize_downsample
argument_list|(
argument|j_compress_ptr cinfo
argument_list|,
argument|jpeg_component_info * compptr
argument_list|,
argument|JSAMPARRAY input_data
argument_list|,
argument|JSAMPARRAY output_data
argument_list|)
end_macro
begin_block
block|{
comment|/* Copy the data */
name|jcopy_sample_rows
argument_list|(
name|input_data
argument_list|,
literal|0
argument_list|,
name|output_data
argument_list|,
literal|0
argument_list|,
name|cinfo
operator|->
name|max_v_samp_factor
argument_list|,
name|cinfo
operator|->
name|image_width
argument_list|)
expr_stmt|;
comment|/* Edge-expand */
name|expand_right_edge
argument_list|(
name|output_data
argument_list|,
name|cinfo
operator|->
name|max_v_samp_factor
argument_list|,
name|cinfo
operator|->
name|image_width
argument_list|,
name|compptr
operator|->
name|width_in_blocks
operator|*
name|compptr
operator|->
name|DCT_h_scaled_size
argument_list|)
expr_stmt|;
block|}
end_block
begin_comment
comment|/*  * Downsample pixel values of a single component.  * This version handles the common case of 2:1 horizontal and 1:1 vertical,  * without smoothing.  *  * A note about the "bias" calculations: when rounding fractional values to  * integer, we do not want to always round 0.5 up to the next integer.  * If we did that, we'd introduce a noticeable bias towards larger values.  * Instead, this code is arranged so that 0.5 will be rounded up or down at  * alternate pixel locations (a simple ordered dither pattern).  */
end_comment
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|h2v1_downsample
name|h2v1_downsample
argument_list|(
argument|j_compress_ptr cinfo
argument_list|,
argument|jpeg_component_info * compptr
argument_list|,
argument|JSAMPARRAY input_data
argument_list|,
argument|JSAMPARRAY output_data
argument_list|)
end_macro
begin_block
block|{
name|int
name|inrow
decl_stmt|;
name|JDIMENSION
name|outcol
decl_stmt|;
name|JDIMENSION
name|output_cols
init|=
name|compptr
operator|->
name|width_in_blocks
operator|*
name|compptr
operator|->
name|DCT_h_scaled_size
decl_stmt|;
specifier|register
name|JSAMPROW
name|inptr
decl_stmt|,
name|outptr
decl_stmt|;
specifier|register
name|int
name|bias
decl_stmt|;
comment|/* Expand input data enough to let all the output samples be generated    * by the standard loop.  Special-casing padded output would be more    * efficient.    */
name|expand_right_edge
argument_list|(
name|input_data
argument_list|,
name|cinfo
operator|->
name|max_v_samp_factor
argument_list|,
name|cinfo
operator|->
name|image_width
argument_list|,
name|output_cols
operator|*
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|inrow
operator|=
literal|0
init|;
name|inrow
operator|<
name|cinfo
operator|->
name|max_v_samp_factor
condition|;
name|inrow
operator|++
control|)
block|{
name|outptr
operator|=
name|output_data
index|[
name|inrow
index|]
expr_stmt|;
name|inptr
operator|=
name|input_data
index|[
name|inrow
index|]
expr_stmt|;
name|bias
operator|=
literal|0
expr_stmt|;
comment|/* bias = 0,1,0,1,... for successive samples */
for|for
control|(
name|outcol
operator|=
literal|0
init|;
name|outcol
operator|<
name|output_cols
condition|;
name|outcol
operator|++
control|)
block|{
operator|*
name|outptr
operator|++
operator|=
call|(
name|JSAMPLE
call|)
argument_list|(
operator|(
name|GETJSAMPLE
argument_list|(
operator|*
name|inptr
argument_list|)
operator|+
name|GETJSAMPLE
argument_list|(
name|inptr
index|[
literal|1
index|]
argument_list|)
operator|+
name|bias
operator|)
operator|>>
literal|1
argument_list|)
expr_stmt|;
name|bias
operator|^=
literal|1
expr_stmt|;
comment|/* 0=>1, 1=>0 */
name|inptr
operator|+=
literal|2
expr_stmt|;
block|}
block|}
block|}
end_block
begin_comment
comment|/*  * Downsample pixel values of a single component.  * This version handles the standard case of 2:1 horizontal and 2:1 vertical,  * without smoothing.  */
end_comment
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|h2v2_downsample
name|h2v2_downsample
argument_list|(
argument|j_compress_ptr cinfo
argument_list|,
argument|jpeg_component_info * compptr
argument_list|,
argument|JSAMPARRAY input_data
argument_list|,
argument|JSAMPARRAY output_data
argument_list|)
end_macro
begin_block
block|{
name|int
name|inrow
decl_stmt|,
name|outrow
decl_stmt|;
name|JDIMENSION
name|outcol
decl_stmt|;
name|JDIMENSION
name|output_cols
init|=
name|compptr
operator|->
name|width_in_blocks
operator|*
name|compptr
operator|->
name|DCT_h_scaled_size
decl_stmt|;
specifier|register
name|JSAMPROW
name|inptr0
decl_stmt|,
name|inptr1
decl_stmt|,
name|outptr
decl_stmt|;
specifier|register
name|int
name|bias
decl_stmt|;
comment|/* Expand input data enough to let all the output samples be generated    * by the standard loop.  Special-casing padded output would be more    * efficient.    */
name|expand_right_edge
argument_list|(
name|input_data
argument_list|,
name|cinfo
operator|->
name|max_v_samp_factor
argument_list|,
name|cinfo
operator|->
name|image_width
argument_list|,
name|output_cols
operator|*
literal|2
argument_list|)
expr_stmt|;
name|inrow
operator|=
name|outrow
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|inrow
operator|<
name|cinfo
operator|->
name|max_v_samp_factor
condition|)
block|{
name|outptr
operator|=
name|output_data
index|[
name|outrow
index|]
expr_stmt|;
name|inptr0
operator|=
name|input_data
index|[
name|inrow
index|]
expr_stmt|;
name|inptr1
operator|=
name|input_data
index|[
name|inrow
operator|+
literal|1
index|]
expr_stmt|;
name|bias
operator|=
literal|1
expr_stmt|;
comment|/* bias = 1,2,1,2,... for successive samples */
for|for
control|(
name|outcol
operator|=
literal|0
init|;
name|outcol
operator|<
name|output_cols
condition|;
name|outcol
operator|++
control|)
block|{
operator|*
name|outptr
operator|++
operator|=
call|(
name|JSAMPLE
call|)
argument_list|(
operator|(
name|GETJSAMPLE
argument_list|(
operator|*
name|inptr0
argument_list|)
operator|+
name|GETJSAMPLE
argument_list|(
name|inptr0
index|[
literal|1
index|]
argument_list|)
operator|+
name|GETJSAMPLE
argument_list|(
operator|*
name|inptr1
argument_list|)
operator|+
name|GETJSAMPLE
argument_list|(
name|inptr1
index|[
literal|1
index|]
argument_list|)
operator|+
name|bias
operator|)
operator|>>
literal|2
argument_list|)
expr_stmt|;
name|bias
operator|^=
literal|3
expr_stmt|;
comment|/* 1=>2, 2=>1 */
name|inptr0
operator|+=
literal|2
expr_stmt|;
name|inptr1
operator|+=
literal|2
expr_stmt|;
block|}
name|inrow
operator|+=
literal|2
expr_stmt|;
name|outrow
operator|++
expr_stmt|;
block|}
block|}
end_block
begin_ifdef
ifdef|#
directive|ifdef
name|INPUT_SMOOTHING_SUPPORTED
end_ifdef
begin_comment
comment|/*  * Downsample pixel values of a single component.  * This version handles the standard case of 2:1 horizontal and 2:1 vertical,  * with smoothing.  One row of context is required.  */
end_comment
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|h2v2_smooth_downsample
name|h2v2_smooth_downsample
argument_list|(
argument|j_compress_ptr cinfo
argument_list|,
argument|jpeg_component_info * compptr
argument_list|,
argument|JSAMPARRAY input_data
argument_list|,
argument|JSAMPARRAY output_data
argument_list|)
end_macro
begin_block
block|{
name|int
name|inrow
decl_stmt|,
name|outrow
decl_stmt|;
name|JDIMENSION
name|colctr
decl_stmt|;
name|JDIMENSION
name|output_cols
init|=
name|compptr
operator|->
name|width_in_blocks
operator|*
name|compptr
operator|->
name|DCT_h_scaled_size
decl_stmt|;
specifier|register
name|JSAMPROW
name|inptr0
decl_stmt|,
name|inptr1
decl_stmt|,
name|above_ptr
decl_stmt|,
name|below_ptr
decl_stmt|,
name|outptr
decl_stmt|;
name|INT32
name|membersum
decl_stmt|,
name|neighsum
decl_stmt|,
name|memberscale
decl_stmt|,
name|neighscale
decl_stmt|;
comment|/* Expand input data enough to let all the output samples be generated    * by the standard loop.  Special-casing padded output would be more    * efficient.    */
name|expand_right_edge
argument_list|(
name|input_data
operator|-
literal|1
argument_list|,
name|cinfo
operator|->
name|max_v_samp_factor
operator|+
literal|2
argument_list|,
name|cinfo
operator|->
name|image_width
argument_list|,
name|output_cols
operator|*
literal|2
argument_list|)
expr_stmt|;
comment|/* We don't bother to form the individual "smoothed" input pixel values;    * we can directly compute the output which is the average of the four    * smoothed values.  Each of the four member pixels contributes a fraction    * (1-8*SF) to its own smoothed image and a fraction SF to each of the three    * other smoothed pixels, therefore a total fraction (1-5*SF)/4 to the final    * output.  The four corner-adjacent neighbor pixels contribute a fraction    * SF to just one smoothed pixel, or SF/4 to the final output; while the    * eight edge-adjacent neighbors contribute SF to each of two smoothed    * pixels, or SF/2 overall.  In order to use integer arithmetic, these    * factors are scaled by 2^16 = 65536.    * Also recall that SF = smoothing_factor / 1024.    */
name|memberscale
operator|=
literal|16384
operator|-
name|cinfo
operator|->
name|smoothing_factor
operator|*
literal|80
expr_stmt|;
comment|/* scaled (1-5*SF)/4 */
name|neighscale
operator|=
name|cinfo
operator|->
name|smoothing_factor
operator|*
literal|16
expr_stmt|;
comment|/* scaled SF/4 */
name|inrow
operator|=
name|outrow
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|inrow
operator|<
name|cinfo
operator|->
name|max_v_samp_factor
condition|)
block|{
name|outptr
operator|=
name|output_data
index|[
name|outrow
index|]
expr_stmt|;
name|inptr0
operator|=
name|input_data
index|[
name|inrow
index|]
expr_stmt|;
name|inptr1
operator|=
name|input_data
index|[
name|inrow
operator|+
literal|1
index|]
expr_stmt|;
name|above_ptr
operator|=
name|input_data
index|[
name|inrow
operator|-
literal|1
index|]
expr_stmt|;
name|below_ptr
operator|=
name|input_data
index|[
name|inrow
operator|+
literal|2
index|]
expr_stmt|;
comment|/* Special case for first column: pretend column -1 is same as column 0 */
name|membersum
operator|=
name|GETJSAMPLE
argument_list|(
operator|*
name|inptr0
argument_list|)
operator|+
name|GETJSAMPLE
argument_list|(
name|inptr0
index|[
literal|1
index|]
argument_list|)
operator|+
name|GETJSAMPLE
argument_list|(
operator|*
name|inptr1
argument_list|)
operator|+
name|GETJSAMPLE
argument_list|(
name|inptr1
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|neighsum
operator|=
name|GETJSAMPLE
argument_list|(
operator|*
name|above_ptr
argument_list|)
operator|+
name|GETJSAMPLE
argument_list|(
name|above_ptr
index|[
literal|1
index|]
argument_list|)
operator|+
name|GETJSAMPLE
argument_list|(
operator|*
name|below_ptr
argument_list|)
operator|+
name|GETJSAMPLE
argument_list|(
name|below_ptr
index|[
literal|1
index|]
argument_list|)
operator|+
name|GETJSAMPLE
argument_list|(
operator|*
name|inptr0
argument_list|)
operator|+
name|GETJSAMPLE
argument_list|(
name|inptr0
index|[
literal|2
index|]
argument_list|)
operator|+
name|GETJSAMPLE
argument_list|(
operator|*
name|inptr1
argument_list|)
operator|+
name|GETJSAMPLE
argument_list|(
name|inptr1
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|neighsum
operator|+=
name|neighsum
expr_stmt|;
name|neighsum
operator|+=
name|GETJSAMPLE
argument_list|(
operator|*
name|above_ptr
argument_list|)
operator|+
name|GETJSAMPLE
argument_list|(
name|above_ptr
index|[
literal|2
index|]
argument_list|)
operator|+
name|GETJSAMPLE
argument_list|(
operator|*
name|below_ptr
argument_list|)
operator|+
name|GETJSAMPLE
argument_list|(
name|below_ptr
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|membersum
operator|=
name|membersum
operator|*
name|memberscale
operator|+
name|neighsum
operator|*
name|neighscale
expr_stmt|;
operator|*
name|outptr
operator|++
operator|=
call|(
name|JSAMPLE
call|)
argument_list|(
operator|(
name|membersum
operator|+
literal|32768
operator|)
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|inptr0
operator|+=
literal|2
expr_stmt|;
name|inptr1
operator|+=
literal|2
expr_stmt|;
name|above_ptr
operator|+=
literal|2
expr_stmt|;
name|below_ptr
operator|+=
literal|2
expr_stmt|;
for|for
control|(
name|colctr
operator|=
name|output_cols
operator|-
literal|2
init|;
name|colctr
operator|>
literal|0
condition|;
name|colctr
operator|--
control|)
block|{
comment|/* sum of pixels directly mapped to this output element */
name|membersum
operator|=
name|GETJSAMPLE
argument_list|(
operator|*
name|inptr0
argument_list|)
operator|+
name|GETJSAMPLE
argument_list|(
name|inptr0
index|[
literal|1
index|]
argument_list|)
operator|+
name|GETJSAMPLE
argument_list|(
operator|*
name|inptr1
argument_list|)
operator|+
name|GETJSAMPLE
argument_list|(
name|inptr1
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* sum of edge-neighbor pixels */
name|neighsum
operator|=
name|GETJSAMPLE
argument_list|(
operator|*
name|above_ptr
argument_list|)
operator|+
name|GETJSAMPLE
argument_list|(
name|above_ptr
index|[
literal|1
index|]
argument_list|)
operator|+
name|GETJSAMPLE
argument_list|(
operator|*
name|below_ptr
argument_list|)
operator|+
name|GETJSAMPLE
argument_list|(
name|below_ptr
index|[
literal|1
index|]
argument_list|)
operator|+
name|GETJSAMPLE
argument_list|(
name|inptr0
index|[
operator|-
literal|1
index|]
argument_list|)
operator|+
name|GETJSAMPLE
argument_list|(
name|inptr0
index|[
literal|2
index|]
argument_list|)
operator|+
name|GETJSAMPLE
argument_list|(
name|inptr1
index|[
operator|-
literal|1
index|]
argument_list|)
operator|+
name|GETJSAMPLE
argument_list|(
name|inptr1
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* The edge-neighbors count twice as much as corner-neighbors */
name|neighsum
operator|+=
name|neighsum
expr_stmt|;
comment|/* Add in the corner-neighbors */
name|neighsum
operator|+=
name|GETJSAMPLE
argument_list|(
name|above_ptr
index|[
operator|-
literal|1
index|]
argument_list|)
operator|+
name|GETJSAMPLE
argument_list|(
name|above_ptr
index|[
literal|2
index|]
argument_list|)
operator|+
name|GETJSAMPLE
argument_list|(
name|below_ptr
index|[
operator|-
literal|1
index|]
argument_list|)
operator|+
name|GETJSAMPLE
argument_list|(
name|below_ptr
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* form final output scaled up by 2^16 */
name|membersum
operator|=
name|membersum
operator|*
name|memberscale
operator|+
name|neighsum
operator|*
name|neighscale
expr_stmt|;
comment|/* round, descale and output it */
operator|*
name|outptr
operator|++
operator|=
call|(
name|JSAMPLE
call|)
argument_list|(
operator|(
name|membersum
operator|+
literal|32768
operator|)
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|inptr0
operator|+=
literal|2
expr_stmt|;
name|inptr1
operator|+=
literal|2
expr_stmt|;
name|above_ptr
operator|+=
literal|2
expr_stmt|;
name|below_ptr
operator|+=
literal|2
expr_stmt|;
block|}
comment|/* Special case for last column */
name|membersum
operator|=
name|GETJSAMPLE
argument_list|(
operator|*
name|inptr0
argument_list|)
operator|+
name|GETJSAMPLE
argument_list|(
name|inptr0
index|[
literal|1
index|]
argument_list|)
operator|+
name|GETJSAMPLE
argument_list|(
operator|*
name|inptr1
argument_list|)
operator|+
name|GETJSAMPLE
argument_list|(
name|inptr1
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|neighsum
operator|=
name|GETJSAMPLE
argument_list|(
operator|*
name|above_ptr
argument_list|)
operator|+
name|GETJSAMPLE
argument_list|(
name|above_ptr
index|[
literal|1
index|]
argument_list|)
operator|+
name|GETJSAMPLE
argument_list|(
operator|*
name|below_ptr
argument_list|)
operator|+
name|GETJSAMPLE
argument_list|(
name|below_ptr
index|[
literal|1
index|]
argument_list|)
operator|+
name|GETJSAMPLE
argument_list|(
name|inptr0
index|[
operator|-
literal|1
index|]
argument_list|)
operator|+
name|GETJSAMPLE
argument_list|(
name|inptr0
index|[
literal|1
index|]
argument_list|)
operator|+
name|GETJSAMPLE
argument_list|(
name|inptr1
index|[
operator|-
literal|1
index|]
argument_list|)
operator|+
name|GETJSAMPLE
argument_list|(
name|inptr1
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|neighsum
operator|+=
name|neighsum
expr_stmt|;
name|neighsum
operator|+=
name|GETJSAMPLE
argument_list|(
name|above_ptr
index|[
operator|-
literal|1
index|]
argument_list|)
operator|+
name|GETJSAMPLE
argument_list|(
name|above_ptr
index|[
literal|1
index|]
argument_list|)
operator|+
name|GETJSAMPLE
argument_list|(
name|below_ptr
index|[
operator|-
literal|1
index|]
argument_list|)
operator|+
name|GETJSAMPLE
argument_list|(
name|below_ptr
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|membersum
operator|=
name|membersum
operator|*
name|memberscale
operator|+
name|neighsum
operator|*
name|neighscale
expr_stmt|;
operator|*
name|outptr
operator|=
call|(
name|JSAMPLE
call|)
argument_list|(
operator|(
name|membersum
operator|+
literal|32768
operator|)
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|inrow
operator|+=
literal|2
expr_stmt|;
name|outrow
operator|++
expr_stmt|;
block|}
block|}
end_block
begin_comment
comment|/*  * Downsample pixel values of a single component.  * This version handles the special case of a full-size component,  * with smoothing.  One row of context is required.  */
end_comment
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|fullsize_smooth_downsample
name|fullsize_smooth_downsample
argument_list|(
argument|j_compress_ptr cinfo
argument_list|,
argument|jpeg_component_info *compptr
argument_list|,
argument|JSAMPARRAY input_data
argument_list|,
argument|JSAMPARRAY output_data
argument_list|)
end_macro
begin_block
block|{
name|int
name|inrow
decl_stmt|;
name|JDIMENSION
name|colctr
decl_stmt|;
name|JDIMENSION
name|output_cols
init|=
name|compptr
operator|->
name|width_in_blocks
operator|*
name|compptr
operator|->
name|DCT_h_scaled_size
decl_stmt|;
specifier|register
name|JSAMPROW
name|inptr
decl_stmt|,
name|above_ptr
decl_stmt|,
name|below_ptr
decl_stmt|,
name|outptr
decl_stmt|;
name|INT32
name|membersum
decl_stmt|,
name|neighsum
decl_stmt|,
name|memberscale
decl_stmt|,
name|neighscale
decl_stmt|;
name|int
name|colsum
decl_stmt|,
name|lastcolsum
decl_stmt|,
name|nextcolsum
decl_stmt|;
comment|/* Expand input data enough to let all the output samples be generated    * by the standard loop.  Special-casing padded output would be more    * efficient.    */
name|expand_right_edge
argument_list|(
name|input_data
operator|-
literal|1
argument_list|,
name|cinfo
operator|->
name|max_v_samp_factor
operator|+
literal|2
argument_list|,
name|cinfo
operator|->
name|image_width
argument_list|,
name|output_cols
argument_list|)
expr_stmt|;
comment|/* Each of the eight neighbor pixels contributes a fraction SF to the    * smoothed pixel, while the main pixel contributes (1-8*SF).  In order    * to use integer arithmetic, these factors are multiplied by 2^16 = 65536.    * Also recall that SF = smoothing_factor / 1024.    */
name|memberscale
operator|=
literal|65536L
operator|-
name|cinfo
operator|->
name|smoothing_factor
operator|*
literal|512L
expr_stmt|;
comment|/* scaled 1-8*SF */
name|neighscale
operator|=
name|cinfo
operator|->
name|smoothing_factor
operator|*
literal|64
expr_stmt|;
comment|/* scaled SF */
for|for
control|(
name|inrow
operator|=
literal|0
init|;
name|inrow
operator|<
name|cinfo
operator|->
name|max_v_samp_factor
condition|;
name|inrow
operator|++
control|)
block|{
name|outptr
operator|=
name|output_data
index|[
name|inrow
index|]
expr_stmt|;
name|inptr
operator|=
name|input_data
index|[
name|inrow
index|]
expr_stmt|;
name|above_ptr
operator|=
name|input_data
index|[
name|inrow
operator|-
literal|1
index|]
expr_stmt|;
name|below_ptr
operator|=
name|input_data
index|[
name|inrow
operator|+
literal|1
index|]
expr_stmt|;
comment|/* Special case for first column */
name|colsum
operator|=
name|GETJSAMPLE
argument_list|(
operator|*
name|above_ptr
operator|++
argument_list|)
operator|+
name|GETJSAMPLE
argument_list|(
operator|*
name|below_ptr
operator|++
argument_list|)
operator|+
name|GETJSAMPLE
argument_list|(
operator|*
name|inptr
argument_list|)
expr_stmt|;
name|membersum
operator|=
name|GETJSAMPLE
argument_list|(
operator|*
name|inptr
operator|++
argument_list|)
expr_stmt|;
name|nextcolsum
operator|=
name|GETJSAMPLE
argument_list|(
operator|*
name|above_ptr
argument_list|)
operator|+
name|GETJSAMPLE
argument_list|(
operator|*
name|below_ptr
argument_list|)
operator|+
name|GETJSAMPLE
argument_list|(
operator|*
name|inptr
argument_list|)
expr_stmt|;
name|neighsum
operator|=
name|colsum
operator|+
operator|(
name|colsum
operator|-
name|membersum
operator|)
operator|+
name|nextcolsum
expr_stmt|;
name|membersum
operator|=
name|membersum
operator|*
name|memberscale
operator|+
name|neighsum
operator|*
name|neighscale
expr_stmt|;
operator|*
name|outptr
operator|++
operator|=
call|(
name|JSAMPLE
call|)
argument_list|(
operator|(
name|membersum
operator|+
literal|32768
operator|)
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|lastcolsum
operator|=
name|colsum
expr_stmt|;
name|colsum
operator|=
name|nextcolsum
expr_stmt|;
for|for
control|(
name|colctr
operator|=
name|output_cols
operator|-
literal|2
init|;
name|colctr
operator|>
literal|0
condition|;
name|colctr
operator|--
control|)
block|{
name|membersum
operator|=
name|GETJSAMPLE
argument_list|(
operator|*
name|inptr
operator|++
argument_list|)
expr_stmt|;
name|above_ptr
operator|++
expr_stmt|;
name|below_ptr
operator|++
expr_stmt|;
name|nextcolsum
operator|=
name|GETJSAMPLE
argument_list|(
operator|*
name|above_ptr
argument_list|)
operator|+
name|GETJSAMPLE
argument_list|(
operator|*
name|below_ptr
argument_list|)
operator|+
name|GETJSAMPLE
argument_list|(
operator|*
name|inptr
argument_list|)
expr_stmt|;
name|neighsum
operator|=
name|lastcolsum
operator|+
operator|(
name|colsum
operator|-
name|membersum
operator|)
operator|+
name|nextcolsum
expr_stmt|;
name|membersum
operator|=
name|membersum
operator|*
name|memberscale
operator|+
name|neighsum
operator|*
name|neighscale
expr_stmt|;
operator|*
name|outptr
operator|++
operator|=
call|(
name|JSAMPLE
call|)
argument_list|(
operator|(
name|membersum
operator|+
literal|32768
operator|)
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|lastcolsum
operator|=
name|colsum
expr_stmt|;
name|colsum
operator|=
name|nextcolsum
expr_stmt|;
block|}
comment|/* Special case for last column */
name|membersum
operator|=
name|GETJSAMPLE
argument_list|(
operator|*
name|inptr
argument_list|)
expr_stmt|;
name|neighsum
operator|=
name|lastcolsum
operator|+
operator|(
name|colsum
operator|-
name|membersum
operator|)
operator|+
name|colsum
expr_stmt|;
name|membersum
operator|=
name|membersum
operator|*
name|memberscale
operator|+
name|neighsum
operator|*
name|neighscale
expr_stmt|;
operator|*
name|outptr
operator|=
call|(
name|JSAMPLE
call|)
argument_list|(
operator|(
name|membersum
operator|+
literal|32768
operator|)
operator|>>
literal|16
argument_list|)
expr_stmt|;
block|}
block|}
end_block
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* INPUT_SMOOTHING_SUPPORTED */
end_comment
begin_comment
comment|/*  * Module initialization routine for downsampling.  * Note that we must select a routine for each component.  */
end_comment
begin_macro
name|GLOBAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|jinit_downsampler
name|jinit_downsampler
argument_list|(
argument|j_compress_ptr cinfo
argument_list|)
end_macro
begin_block
block|{
name|my_downsample_ptr
name|downsample
decl_stmt|;
name|int
name|ci
decl_stmt|;
name|jpeg_component_info
modifier|*
name|compptr
decl_stmt|;
name|boolean
name|smoothok
init|=
name|TRUE
decl_stmt|;
name|int
name|h_in_group
decl_stmt|,
name|v_in_group
decl_stmt|,
name|h_out_group
decl_stmt|,
name|v_out_group
decl_stmt|;
name|downsample
operator|=
call|(
name|my_downsample_ptr
call|)
argument_list|(
operator|*
name|cinfo
operator|->
name|mem
operator|->
name|alloc_small
argument_list|)
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|,
name|JPOOL_IMAGE
argument_list|,
name|SIZEOF
argument_list|(
name|my_downsampler
argument_list|)
argument_list|)
expr_stmt|;
name|cinfo
operator|->
name|downsample
operator|=
operator|(
expr|struct
name|jpeg_downsampler
operator|*
operator|)
name|downsample
expr_stmt|;
name|downsample
operator|->
name|pub
operator|.
name|start_pass
operator|=
name|start_pass_downsample
expr_stmt|;
name|downsample
operator|->
name|pub
operator|.
name|downsample
operator|=
name|sep_downsample
expr_stmt|;
name|downsample
operator|->
name|pub
operator|.
name|need_context_rows
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|cinfo
operator|->
name|CCIR601_sampling
condition|)
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_CCIR601_NOTIMPL
argument_list|)
expr_stmt|;
comment|/* Verify we can handle the sampling factors, and set up method pointers */
for|for
control|(
name|ci
operator|=
literal|0
operator|,
name|compptr
operator|=
name|cinfo
operator|->
name|comp_info
init|;
name|ci
operator|<
name|cinfo
operator|->
name|num_components
condition|;
name|ci
operator|++
operator|,
name|compptr
operator|++
control|)
block|{
comment|/* Compute size of an "output group" for DCT scaling.  This many samples      * are to be converted from max_h_samp_factor * max_v_samp_factor pixels.      */
name|h_out_group
operator|=
operator|(
name|compptr
operator|->
name|h_samp_factor
operator|*
name|compptr
operator|->
name|DCT_h_scaled_size
operator|)
operator|/
name|cinfo
operator|->
name|min_DCT_h_scaled_size
expr_stmt|;
name|v_out_group
operator|=
operator|(
name|compptr
operator|->
name|v_samp_factor
operator|*
name|compptr
operator|->
name|DCT_v_scaled_size
operator|)
operator|/
name|cinfo
operator|->
name|min_DCT_v_scaled_size
expr_stmt|;
name|h_in_group
operator|=
name|cinfo
operator|->
name|max_h_samp_factor
expr_stmt|;
name|v_in_group
operator|=
name|cinfo
operator|->
name|max_v_samp_factor
expr_stmt|;
name|downsample
operator|->
name|rowgroup_height
index|[
name|ci
index|]
operator|=
name|v_out_group
expr_stmt|;
comment|/* save for use later */
if|if
condition|(
name|h_in_group
operator|==
name|h_out_group
operator|&&
name|v_in_group
operator|==
name|v_out_group
condition|)
block|{
ifdef|#
directive|ifdef
name|INPUT_SMOOTHING_SUPPORTED
if|if
condition|(
name|cinfo
operator|->
name|smoothing_factor
condition|)
block|{
name|downsample
operator|->
name|methods
index|[
name|ci
index|]
operator|=
name|fullsize_smooth_downsample
expr_stmt|;
name|downsample
operator|->
name|pub
operator|.
name|need_context_rows
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|downsample
operator|->
name|methods
index|[
name|ci
index|]
operator|=
name|fullsize_downsample
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|h_in_group
operator|==
name|h_out_group
operator|*
literal|2
operator|&&
name|v_in_group
operator|==
name|v_out_group
condition|)
block|{
name|smoothok
operator|=
name|FALSE
expr_stmt|;
name|downsample
operator|->
name|methods
index|[
name|ci
index|]
operator|=
name|h2v1_downsample
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|h_in_group
operator|==
name|h_out_group
operator|*
literal|2
operator|&&
name|v_in_group
operator|==
name|v_out_group
operator|*
literal|2
condition|)
block|{
ifdef|#
directive|ifdef
name|INPUT_SMOOTHING_SUPPORTED
if|if
condition|(
name|cinfo
operator|->
name|smoothing_factor
condition|)
block|{
name|downsample
operator|->
name|methods
index|[
name|ci
index|]
operator|=
name|h2v2_smooth_downsample
expr_stmt|;
name|downsample
operator|->
name|pub
operator|.
name|need_context_rows
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|downsample
operator|->
name|methods
index|[
name|ci
index|]
operator|=
name|h2v2_downsample
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|h_in_group
operator|%
name|h_out_group
operator|)
operator|==
literal|0
operator|&&
operator|(
name|v_in_group
operator|%
name|v_out_group
operator|)
operator|==
literal|0
condition|)
block|{
name|smoothok
operator|=
name|FALSE
expr_stmt|;
name|downsample
operator|->
name|methods
index|[
name|ci
index|]
operator|=
name|int_downsample
expr_stmt|;
name|downsample
operator|->
name|h_expand
index|[
name|ci
index|]
operator|=
call|(
name|UINT8
call|)
argument_list|(
name|h_in_group
operator|/
name|h_out_group
argument_list|)
expr_stmt|;
name|downsample
operator|->
name|v_expand
index|[
name|ci
index|]
operator|=
call|(
name|UINT8
call|)
argument_list|(
name|v_in_group
operator|/
name|v_out_group
argument_list|)
expr_stmt|;
block|}
else|else
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_FRACT_SAMPLE_NOTIMPL
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|INPUT_SMOOTHING_SUPPORTED
if|if
condition|(
name|cinfo
operator|->
name|smoothing_factor
operator|&&
operator|!
name|smoothok
condition|)
name|TRACEMS
argument_list|(
name|cinfo
argument_list|,
literal|0
argument_list|,
name|JTRC_SMOOTH_NOTIMPL
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block
end_unit
