begin_unit
begin_comment
comment|/*  * jdtrans.c  *  * Copyright (C) 1995-1997, Thomas G. Lane.  * Modified 2000-2009 by Guido Vollbeding.  * This file is part of the Independent JPEG Group's software.  * For conditions of distribution and use, see the accompanying README file.  *  * This file contains library routines for transcoding decompression,  * that is, reading raw DCT coefficient arrays from an input JPEG file.  * The routines in jdapimin.c will also be needed by a transcoder.  */
end_comment
begin_define
DECL|macro|JPEG_INTERNALS
define|#
directive|define
name|JPEG_INTERNALS
end_define
begin_include
include|#
directive|include
file|"jinclude.h"
end_include
begin_include
include|#
directive|include
file|"jpeglib.h"
end_include
begin_comment
comment|/* Forward declarations */
end_comment
begin_macro
name|LOCAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_decl_stmt
name|transdecode_master_selection
name|JPP
argument_list|(
operator|(
name|j_decompress_ptr
name|cinfo
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*  * Read the coefficient arrays from a JPEG file.  * jpeg_read_header must be completed before calling this.  *  * The entire image is read into a set of virtual coefficient-block arrays,  * one per component.  The return value is a pointer to the array of  * virtual-array descriptors.  These can be manipulated directly via the  * JPEG memory manager, or handed off to jpeg_write_coefficients().  * To release the memory occupied by the virtual arrays, call  * jpeg_finish_decompress() when done with the data.  *  * An alternative usage is to simply obtain access to the coefficient arrays  * during a buffered-image-mode decompression operation.  This is allowed  * after any jpeg_finish_output() call.  The arrays can be accessed until  * jpeg_finish_decompress() is called.  (Note that any call to the library  * may reposition the arrays, so don't rely on access_virt_barray() results  * to stay valid across library calls.)  *  * Returns NULL if suspended.  This case need be checked only if  * a suspending data source is used.  */
end_comment
begin_macro
name|GLOBAL
argument_list|(
argument|jvirt_barray_ptr *
argument_list|)
end_macro
begin_macro
DECL|function|jpeg_read_coefficients
name|jpeg_read_coefficients
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|)
end_macro
begin_block
block|{
if|if
condition|(
name|cinfo
operator|->
name|global_state
operator|==
name|DSTATE_READY
condition|)
block|{
comment|/* First call: initialize active modules */
name|transdecode_master_selection
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
name|cinfo
operator|->
name|global_state
operator|=
name|DSTATE_RDCOEFS
expr_stmt|;
block|}
if|if
condition|(
name|cinfo
operator|->
name|global_state
operator|==
name|DSTATE_RDCOEFS
condition|)
block|{
comment|/* Absorb whole file into the coef buffer */
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|retcode
decl_stmt|;
comment|/* Call progress monitor hook if present */
if|if
condition|(
name|cinfo
operator|->
name|progress
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|cinfo
operator|->
name|progress
operator|->
name|progress_monitor
call|)
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|)
expr_stmt|;
comment|/* Absorb some more input */
name|retcode
operator|=
call|(
modifier|*
name|cinfo
operator|->
name|inputctl
operator|->
name|consume_input
call|)
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|retcode
operator|==
name|JPEG_SUSPENDED
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|retcode
operator|==
name|JPEG_REACHED_EOI
condition|)
break|break;
comment|/* Advance progress counter if appropriate */
if|if
condition|(
name|cinfo
operator|->
name|progress
operator|!=
name|NULL
operator|&&
operator|(
name|retcode
operator|==
name|JPEG_ROW_COMPLETED
operator|||
name|retcode
operator|==
name|JPEG_REACHED_SOS
operator|)
condition|)
block|{
if|if
condition|(
operator|++
name|cinfo
operator|->
name|progress
operator|->
name|pass_counter
operator|>=
name|cinfo
operator|->
name|progress
operator|->
name|pass_limit
condition|)
block|{
comment|/* startup underestimated number of scans; ratchet up one scan */
name|cinfo
operator|->
name|progress
operator|->
name|pass_limit
operator|+=
operator|(
name|long
operator|)
name|cinfo
operator|->
name|total_iMCU_rows
expr_stmt|;
block|}
block|}
block|}
comment|/* Set state so that jpeg_finish_decompress does the right thing */
name|cinfo
operator|->
name|global_state
operator|=
name|DSTATE_STOPPING
expr_stmt|;
block|}
comment|/* At this point we should be in state DSTATE_STOPPING if being used    * standalone, or in state DSTATE_BUFIMAGE if being invoked to get access    * to the coefficients during a full buffered-image-mode decompression.    */
if|if
condition|(
operator|(
name|cinfo
operator|->
name|global_state
operator|==
name|DSTATE_STOPPING
operator|||
name|cinfo
operator|->
name|global_state
operator|==
name|DSTATE_BUFIMAGE
operator|)
operator|&&
name|cinfo
operator|->
name|buffered_image
condition|)
block|{
return|return
name|cinfo
operator|->
name|coef
operator|->
name|coef_arrays
return|;
block|}
comment|/* Oops, improper usage */
name|ERREXIT1
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_STATE
argument_list|,
name|cinfo
operator|->
name|global_state
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
comment|/* keep compiler happy */
block|}
end_block
begin_comment
comment|/*  * Master selection of decompression modules for transcoding.  * This substitutes for jdmaster.c's initialization of the full decompressor.  */
end_comment
begin_macro
name|LOCAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|transdecode_master_selection
name|transdecode_master_selection
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|)
end_macro
begin_block
block|{
comment|/* This is effectively a buffered-image operation. */
name|cinfo
operator|->
name|buffered_image
operator|=
name|TRUE
expr_stmt|;
comment|/* Compute output image dimensions and related values. */
name|jpeg_core_output_dimensions
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
comment|/* Entropy decoding: either Huffman or arithmetic coding. */
if|if
condition|(
name|cinfo
operator|->
name|arith_code
condition|)
name|jinit_arith_decoder
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
else|else
block|{
name|jinit_huff_decoder
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
block|}
comment|/* Always get a full-image coefficient buffer. */
name|jinit_d_coef_controller
argument_list|(
name|cinfo
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* We can now tell the memory manager to allocate virtual arrays. */
call|(
modifier|*
name|cinfo
operator|->
name|mem
operator|->
name|realize_virt_arrays
call|)
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|)
expr_stmt|;
comment|/* Initialize input side of decompressor to consume first scan. */
call|(
modifier|*
name|cinfo
operator|->
name|inputctl
operator|->
name|start_input_pass
call|)
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
comment|/* Initialize progress monitoring. */
if|if
condition|(
name|cinfo
operator|->
name|progress
operator|!=
name|NULL
condition|)
block|{
name|int
name|nscans
decl_stmt|;
comment|/* Estimate number of scans to set pass_limit. */
if|if
condition|(
name|cinfo
operator|->
name|progressive_mode
condition|)
block|{
comment|/* Arbitrarily estimate 2 interleaved DC scans + 3 AC scans/component. */
name|nscans
operator|=
literal|2
operator|+
literal|3
operator|*
name|cinfo
operator|->
name|num_components
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cinfo
operator|->
name|inputctl
operator|->
name|has_multiple_scans
condition|)
block|{
comment|/* For a nonprogressive multiscan file, estimate 1 scan per component. */
name|nscans
operator|=
name|cinfo
operator|->
name|num_components
expr_stmt|;
block|}
else|else
block|{
name|nscans
operator|=
literal|1
expr_stmt|;
block|}
name|cinfo
operator|->
name|progress
operator|->
name|pass_counter
operator|=
literal|0L
expr_stmt|;
name|cinfo
operator|->
name|progress
operator|->
name|pass_limit
operator|=
operator|(
name|long
operator|)
name|cinfo
operator|->
name|total_iMCU_rows
operator|*
name|nscans
expr_stmt|;
name|cinfo
operator|->
name|progress
operator|->
name|completed_passes
operator|=
literal|0
expr_stmt|;
name|cinfo
operator|->
name|progress
operator|->
name|total_passes
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_block
end_unit
