begin_unit
begin_comment
comment|/*  * jdmarker.c  *  * Copyright (C) 1991-1998, Thomas G. Lane.  * Modified 2009 by Guido Vollbeding.  * This file is part of the Independent JPEG Group's software.  * For conditions of distribution and use, see the accompanying README file.  *  * This file contains routines to decode JPEG datastream markers.  * Most of the complexity arises from our desire to support input  * suspension: if not all of the data for a marker is available,  * we must exit back to the application.  On resumption, we reprocess  * the marker.  */
end_comment
begin_define
DECL|macro|JPEG_INTERNALS
define|#
directive|define
name|JPEG_INTERNALS
end_define
begin_include
include|#
directive|include
file|"jinclude.h"
end_include
begin_include
include|#
directive|include
file|"jpeglib.h"
end_include
begin_typedef
typedef|typedef
enum|enum
block|{
comment|/* JPEG marker codes */
DECL|enumerator|M_SOF0
name|M_SOF0
init|=
literal|0xc0
block|,
DECL|enumerator|M_SOF1
name|M_SOF1
init|=
literal|0xc1
block|,
DECL|enumerator|M_SOF2
name|M_SOF2
init|=
literal|0xc2
block|,
DECL|enumerator|M_SOF3
name|M_SOF3
init|=
literal|0xc3
block|,
DECL|enumerator|M_SOF5
name|M_SOF5
init|=
literal|0xc5
block|,
DECL|enumerator|M_SOF6
name|M_SOF6
init|=
literal|0xc6
block|,
DECL|enumerator|M_SOF7
name|M_SOF7
init|=
literal|0xc7
block|,
DECL|enumerator|M_JPG
name|M_JPG
init|=
literal|0xc8
block|,
DECL|enumerator|M_SOF9
name|M_SOF9
init|=
literal|0xc9
block|,
DECL|enumerator|M_SOF10
name|M_SOF10
init|=
literal|0xca
block|,
DECL|enumerator|M_SOF11
name|M_SOF11
init|=
literal|0xcb
block|,
DECL|enumerator|M_SOF13
name|M_SOF13
init|=
literal|0xcd
block|,
DECL|enumerator|M_SOF14
name|M_SOF14
init|=
literal|0xce
block|,
DECL|enumerator|M_SOF15
name|M_SOF15
init|=
literal|0xcf
block|,
DECL|enumerator|M_DHT
name|M_DHT
init|=
literal|0xc4
block|,
DECL|enumerator|M_DAC
name|M_DAC
init|=
literal|0xcc
block|,
DECL|enumerator|M_RST0
name|M_RST0
init|=
literal|0xd0
block|,
DECL|enumerator|M_RST1
name|M_RST1
init|=
literal|0xd1
block|,
DECL|enumerator|M_RST2
name|M_RST2
init|=
literal|0xd2
block|,
DECL|enumerator|M_RST3
name|M_RST3
init|=
literal|0xd3
block|,
DECL|enumerator|M_RST4
name|M_RST4
init|=
literal|0xd4
block|,
DECL|enumerator|M_RST5
name|M_RST5
init|=
literal|0xd5
block|,
DECL|enumerator|M_RST6
name|M_RST6
init|=
literal|0xd6
block|,
DECL|enumerator|M_RST7
name|M_RST7
init|=
literal|0xd7
block|,
DECL|enumerator|M_SOI
name|M_SOI
init|=
literal|0xd8
block|,
DECL|enumerator|M_EOI
name|M_EOI
init|=
literal|0xd9
block|,
DECL|enumerator|M_SOS
name|M_SOS
init|=
literal|0xda
block|,
DECL|enumerator|M_DQT
name|M_DQT
init|=
literal|0xdb
block|,
DECL|enumerator|M_DNL
name|M_DNL
init|=
literal|0xdc
block|,
DECL|enumerator|M_DRI
name|M_DRI
init|=
literal|0xdd
block|,
DECL|enumerator|M_DHP
name|M_DHP
init|=
literal|0xde
block|,
DECL|enumerator|M_EXP
name|M_EXP
init|=
literal|0xdf
block|,
DECL|enumerator|M_APP0
name|M_APP0
init|=
literal|0xe0
block|,
DECL|enumerator|M_APP1
name|M_APP1
init|=
literal|0xe1
block|,
DECL|enumerator|M_APP2
name|M_APP2
init|=
literal|0xe2
block|,
DECL|enumerator|M_APP3
name|M_APP3
init|=
literal|0xe3
block|,
DECL|enumerator|M_APP4
name|M_APP4
init|=
literal|0xe4
block|,
DECL|enumerator|M_APP5
name|M_APP5
init|=
literal|0xe5
block|,
DECL|enumerator|M_APP6
name|M_APP6
init|=
literal|0xe6
block|,
DECL|enumerator|M_APP7
name|M_APP7
init|=
literal|0xe7
block|,
DECL|enumerator|M_APP8
name|M_APP8
init|=
literal|0xe8
block|,
DECL|enumerator|M_APP9
name|M_APP9
init|=
literal|0xe9
block|,
DECL|enumerator|M_APP10
name|M_APP10
init|=
literal|0xea
block|,
DECL|enumerator|M_APP11
name|M_APP11
init|=
literal|0xeb
block|,
DECL|enumerator|M_APP12
name|M_APP12
init|=
literal|0xec
block|,
DECL|enumerator|M_APP13
name|M_APP13
init|=
literal|0xed
block|,
DECL|enumerator|M_APP14
name|M_APP14
init|=
literal|0xee
block|,
DECL|enumerator|M_APP15
name|M_APP15
init|=
literal|0xef
block|,
DECL|enumerator|M_JPG0
name|M_JPG0
init|=
literal|0xf0
block|,
DECL|enumerator|M_JPG13
name|M_JPG13
init|=
literal|0xfd
block|,
DECL|enumerator|M_COM
name|M_COM
init|=
literal|0xfe
block|,
DECL|enumerator|M_TEM
name|M_TEM
init|=
literal|0x01
block|,
DECL|enumerator|M_ERROR
name|M_ERROR
init|=
literal|0x100
block|}
DECL|typedef|JPEG_MARKER
name|JPEG_MARKER
typedef|;
end_typedef
begin_comment
comment|/* Private state */
end_comment
begin_typedef
typedef|typedef
struct|struct
block|{
DECL|member|pub
name|struct
name|jpeg_marker_reader
name|pub
decl_stmt|;
comment|/* public fields */
comment|/* Application-overridable marker processing methods */
DECL|member|process_COM
name|jpeg_marker_parser_method
name|process_COM
decl_stmt|;
DECL|member|process_APPn
name|jpeg_marker_parser_method
name|process_APPn
index|[
literal|16
index|]
decl_stmt|;
comment|/* Limit on marker data length to save for each marker type */
DECL|member|length_limit_COM
name|unsigned
name|int
name|length_limit_COM
decl_stmt|;
DECL|member|length_limit_APPn
name|unsigned
name|int
name|length_limit_APPn
index|[
literal|16
index|]
decl_stmt|;
comment|/* Status of COM/APPn marker saving */
DECL|member|cur_marker
name|jpeg_saved_marker_ptr
name|cur_marker
decl_stmt|;
comment|/* NULL if not processing a marker */
DECL|member|bytes_read
name|unsigned
name|int
name|bytes_read
decl_stmt|;
comment|/* data bytes read so far in marker */
comment|/* Note: cur_marker is not linked into marker_list until it's all read. */
block|}
DECL|typedef|my_marker_reader
name|my_marker_reader
typedef|;
end_typedef
begin_typedef
DECL|typedef|my_marker_ptr
typedef|typedef
name|my_marker_reader
modifier|*
name|my_marker_ptr
typedef|;
end_typedef
begin_comment
comment|/*  * Macros for fetching data from the data source module.  *  * At all times, cinfo->src->next_input_byte and ->bytes_in_buffer reflect  * the current restart point; we update them only when we have reached a  * suitable place to restart if a suspension occurs.  */
end_comment
begin_comment
comment|/* Declare and initialize local copies of input pointer/count */
end_comment
begin_define
DECL|macro|INPUT_VARS
define|#
directive|define
name|INPUT_VARS
parameter_list|(
name|cinfo
parameter_list|)
define|\
value|struct jpeg_source_mgr * datasrc = (cinfo)->src;  \ 	const JOCTET * next_input_byte = datasrc->next_input_byte;  \ 	size_t bytes_in_buffer = datasrc->bytes_in_buffer
end_define
begin_comment
comment|/* Unload the local copies --- do this only at a restart boundary */
end_comment
begin_define
DECL|macro|INPUT_SYNC
define|#
directive|define
name|INPUT_SYNC
parameter_list|(
name|cinfo
parameter_list|)
define|\
value|( datasrc->next_input_byte = next_input_byte,  \ 	  datasrc->bytes_in_buffer = bytes_in_buffer )
end_define
begin_comment
comment|/* Reload the local copies --- used only in MAKE_BYTE_AVAIL */
end_comment
begin_define
DECL|macro|INPUT_RELOAD
define|#
directive|define
name|INPUT_RELOAD
parameter_list|(
name|cinfo
parameter_list|)
define|\
value|( next_input_byte = datasrc->next_input_byte,  \ 	  bytes_in_buffer = datasrc->bytes_in_buffer )
end_define
begin_comment
comment|/* Internal macro for INPUT_BYTE and INPUT_2BYTES: make a byte available.  * Note we do *not* do INPUT_SYNC before calling fill_input_buffer,  * but we must reload the local copies after a successful fill.  */
end_comment
begin_define
DECL|macro|MAKE_BYTE_AVAIL
define|#
directive|define
name|MAKE_BYTE_AVAIL
parameter_list|(
name|cinfo
parameter_list|,
name|action
parameter_list|)
define|\
value|if (bytes_in_buffer == 0) {  \ 	  if (! (*datasrc->fill_input_buffer) (cinfo))  \ 	    { action; }  \ 	  INPUT_RELOAD(cinfo);  \ 	}
end_define
begin_comment
comment|/* Read a byte into variable V.  * If must suspend, take the specified action (typically "return FALSE").  */
end_comment
begin_define
DECL|macro|INPUT_BYTE
define|#
directive|define
name|INPUT_BYTE
parameter_list|(
name|cinfo
parameter_list|,
name|V
parameter_list|,
name|action
parameter_list|)
define|\
value|MAKESTMT( MAKE_BYTE_AVAIL(cinfo,action); \ 		  bytes_in_buffer--; \ 		  V = GETJOCTET(*next_input_byte++); )
end_define
begin_comment
comment|/* As above, but read two bytes interpreted as an unsigned 16-bit integer.  * V should be declared unsigned int or perhaps INT32.  */
end_comment
begin_define
DECL|macro|INPUT_2BYTES
define|#
directive|define
name|INPUT_2BYTES
parameter_list|(
name|cinfo
parameter_list|,
name|V
parameter_list|,
name|action
parameter_list|)
define|\
value|MAKESTMT( MAKE_BYTE_AVAIL(cinfo,action); \ 		  bytes_in_buffer--; \ 		  V = ((unsigned int) GETJOCTET(*next_input_byte++))<< 8; \ 		  MAKE_BYTE_AVAIL(cinfo,action); \ 		  bytes_in_buffer--; \ 		  V += GETJOCTET(*next_input_byte++); )
end_define
begin_comment
comment|/*  * Routines to process JPEG markers.  *  * Entry condition: JPEG marker itself has been read and its code saved  *   in cinfo->unread_marker; input restart point is just after the marker.  *  * Exit: if return TRUE, have read and processed any parameters, and have  *   updated the restart point to point after the parameters.  *   If return FALSE, was forced to suspend before reaching end of  *   marker parameters; restart point has not been moved.  Same routine  *   will be called again after application supplies more input data.  *  * This approach to suspension assumes that all of a marker's parameters  * can fit into a single input bufferload.  This should hold for "normal"  * markers.  Some COM/APPn markers might have large parameter segments  * that might not fit.  If we are simply dropping such a marker, we use  * skip_input_data to get past it, and thereby put the problem on the  * source manager's shoulders.  If we are saving the marker's contents  * into memory, we use a slightly different convention: when forced to  * suspend, the marker processor updates the restart point to the end of  * what it's consumed (ie, the end of the buffer) before returning FALSE.  * On resumption, cinfo->unread_marker still contains the marker code,  * but the data source will point to the next chunk of marker data.  * The marker processor must retain internal state to deal with this.  *  * Note that we don't bother to avoid duplicate trace messages if a  * suspension occurs within marker parameters.  Other side effects  * require more care.  */
end_comment
begin_macro
DECL|function|LOCAL
name|LOCAL
argument_list|(
argument|boolean
argument_list|)
end_macro
begin_macro
name|get_soi
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|)
end_macro
begin_comment
comment|/* Process an SOI marker */
end_comment
begin_block
block|{
name|int
name|i
decl_stmt|;
name|TRACEMS
argument_list|(
name|cinfo
argument_list|,
literal|1
argument_list|,
name|JTRC_SOI
argument_list|)
expr_stmt|;
if|if
condition|(
name|cinfo
operator|->
name|marker
operator|->
name|saw_SOI
condition|)
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_SOI_DUPLICATE
argument_list|)
expr_stmt|;
comment|/* Reset all parameters that are defined to be reset by SOI */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_ARITH_TBLS
condition|;
name|i
operator|++
control|)
block|{
name|cinfo
operator|->
name|arith_dc_L
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|cinfo
operator|->
name|arith_dc_U
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|cinfo
operator|->
name|arith_ac_K
index|[
name|i
index|]
operator|=
literal|5
expr_stmt|;
block|}
name|cinfo
operator|->
name|restart_interval
operator|=
literal|0
expr_stmt|;
comment|/* Set initial assumptions for colorspace etc */
name|cinfo
operator|->
name|jpeg_color_space
operator|=
name|JCS_UNKNOWN
expr_stmt|;
name|cinfo
operator|->
name|CCIR601_sampling
operator|=
name|FALSE
expr_stmt|;
comment|/* Assume non-CCIR sampling??? */
name|cinfo
operator|->
name|saw_JFIF_marker
operator|=
name|FALSE
expr_stmt|;
name|cinfo
operator|->
name|JFIF_major_version
operator|=
literal|1
expr_stmt|;
comment|/* set default JFIF APP0 values */
name|cinfo
operator|->
name|JFIF_minor_version
operator|=
literal|1
expr_stmt|;
name|cinfo
operator|->
name|density_unit
operator|=
literal|0
expr_stmt|;
name|cinfo
operator|->
name|X_density
operator|=
literal|1
expr_stmt|;
name|cinfo
operator|->
name|Y_density
operator|=
literal|1
expr_stmt|;
name|cinfo
operator|->
name|saw_Adobe_marker
operator|=
name|FALSE
expr_stmt|;
name|cinfo
operator|->
name|Adobe_transform
operator|=
literal|0
expr_stmt|;
name|cinfo
operator|->
name|marker
operator|->
name|saw_SOI
operator|=
name|TRUE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_block
begin_macro
DECL|function|LOCAL
name|LOCAL
argument_list|(
argument|boolean
argument_list|)
end_macro
begin_macro
name|get_sof
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|,
argument|boolean is_baseline
argument_list|,
argument|boolean is_prog
argument_list|,
argument|boolean is_arith
argument_list|)
end_macro
begin_comment
comment|/* Process a SOFn marker */
end_comment
begin_block
block|{
name|INT32
name|length
decl_stmt|;
name|int
name|c
decl_stmt|,
name|ci
decl_stmt|;
name|jpeg_component_info
modifier|*
name|compptr
decl_stmt|;
name|INPUT_VARS
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
name|cinfo
operator|->
name|is_baseline
operator|=
name|is_baseline
expr_stmt|;
name|cinfo
operator|->
name|progressive_mode
operator|=
name|is_prog
expr_stmt|;
name|cinfo
operator|->
name|arith_code
operator|=
name|is_arith
expr_stmt|;
name|INPUT_2BYTES
argument_list|(
argument|cinfo
argument_list|,
argument|length
argument_list|,
argument|return FALSE
argument_list|)
empty_stmt|;
name|INPUT_BYTE
argument_list|(
argument|cinfo
argument_list|,
argument|cinfo->data_precision
argument_list|,
argument|return FALSE
argument_list|)
empty_stmt|;
name|INPUT_2BYTES
argument_list|(
argument|cinfo
argument_list|,
argument|cinfo->image_height
argument_list|,
argument|return FALSE
argument_list|)
empty_stmt|;
name|INPUT_2BYTES
argument_list|(
argument|cinfo
argument_list|,
argument|cinfo->image_width
argument_list|,
argument|return FALSE
argument_list|)
empty_stmt|;
name|INPUT_BYTE
argument_list|(
argument|cinfo
argument_list|,
argument|cinfo->num_components
argument_list|,
argument|return FALSE
argument_list|)
empty_stmt|;
name|length
operator|-=
literal|8
expr_stmt|;
name|TRACEMS4
argument_list|(
name|cinfo
argument_list|,
literal|1
argument_list|,
name|JTRC_SOF
argument_list|,
name|cinfo
operator|->
name|unread_marker
argument_list|,
operator|(
name|int
operator|)
name|cinfo
operator|->
name|image_width
argument_list|,
operator|(
name|int
operator|)
name|cinfo
operator|->
name|image_height
argument_list|,
name|cinfo
operator|->
name|num_components
argument_list|)
expr_stmt|;
if|if
condition|(
name|cinfo
operator|->
name|marker
operator|->
name|saw_SOF
condition|)
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_SOF_DUPLICATE
argument_list|)
expr_stmt|;
comment|/* We don't support files in which the image height is initially specified */
comment|/* as 0 and is later redefined by DNL.  As long as we have to check that,  */
comment|/* might as well have a general sanity check. */
if|if
condition|(
name|cinfo
operator|->
name|image_height
operator|<=
literal|0
operator|||
name|cinfo
operator|->
name|image_width
operator|<=
literal|0
operator|||
name|cinfo
operator|->
name|num_components
operator|<=
literal|0
condition|)
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_EMPTY_IMAGE
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|!=
operator|(
name|cinfo
operator|->
name|num_components
operator|*
literal|3
operator|)
condition|)
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_LENGTH
argument_list|)
expr_stmt|;
if|if
condition|(
name|cinfo
operator|->
name|comp_info
operator|==
name|NULL
condition|)
comment|/* do only once, even if suspend */
name|cinfo
operator|->
name|comp_info
operator|=
operator|(
name|jpeg_component_info
operator|*
operator|)
call|(
modifier|*
name|cinfo
operator|->
name|mem
operator|->
name|alloc_small
call|)
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|,
name|JPOOL_IMAGE
argument_list|,
name|cinfo
operator|->
name|num_components
operator|*
name|SIZEOF
argument_list|(
name|jpeg_component_info
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|ci
operator|=
literal|0
operator|,
name|compptr
operator|=
name|cinfo
operator|->
name|comp_info
init|;
name|ci
operator|<
name|cinfo
operator|->
name|num_components
condition|;
name|ci
operator|++
operator|,
name|compptr
operator|++
control|)
block|{
name|compptr
operator|->
name|component_index
operator|=
name|ci
expr_stmt|;
name|INPUT_BYTE
argument_list|(
argument|cinfo
argument_list|,
argument|compptr->component_id
argument_list|,
argument|return FALSE
argument_list|)
empty_stmt|;
name|INPUT_BYTE
argument_list|(
argument|cinfo
argument_list|,
argument|c
argument_list|,
argument|return FALSE
argument_list|)
empty_stmt|;
name|compptr
operator|->
name|h_samp_factor
operator|=
operator|(
name|c
operator|>>
literal|4
operator|)
operator|&
literal|15
expr_stmt|;
name|compptr
operator|->
name|v_samp_factor
operator|=
operator|(
name|c
operator|)
operator|&
literal|15
expr_stmt|;
name|INPUT_BYTE
argument_list|(
argument|cinfo
argument_list|,
argument|compptr->quant_tbl_no
argument_list|,
argument|return FALSE
argument_list|)
empty_stmt|;
name|TRACEMS4
argument_list|(
name|cinfo
argument_list|,
literal|1
argument_list|,
name|JTRC_SOF_COMPONENT
argument_list|,
name|compptr
operator|->
name|component_id
argument_list|,
name|compptr
operator|->
name|h_samp_factor
argument_list|,
name|compptr
operator|->
name|v_samp_factor
argument_list|,
name|compptr
operator|->
name|quant_tbl_no
argument_list|)
expr_stmt|;
block|}
name|cinfo
operator|->
name|marker
operator|->
name|saw_SOF
operator|=
name|TRUE
expr_stmt|;
name|INPUT_SYNC
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_block
begin_macro
DECL|function|LOCAL
name|LOCAL
argument_list|(
argument|boolean
argument_list|)
end_macro
begin_macro
name|get_sos
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|)
end_macro
begin_comment
comment|/* Process a SOS marker */
end_comment
begin_block
block|{
name|INT32
name|length
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ci
decl_stmt|,
name|n
decl_stmt|,
name|c
decl_stmt|,
name|cc
decl_stmt|;
name|jpeg_component_info
modifier|*
name|compptr
decl_stmt|;
name|INPUT_VARS
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cinfo
operator|->
name|marker
operator|->
name|saw_SOF
condition|)
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_SOS_NO_SOF
argument_list|)
expr_stmt|;
name|INPUT_2BYTES
argument_list|(
argument|cinfo
argument_list|,
argument|length
argument_list|,
argument|return FALSE
argument_list|)
empty_stmt|;
name|INPUT_BYTE
argument_list|(
argument|cinfo
argument_list|,
argument|n
argument_list|,
argument|return FALSE
argument_list|)
empty_stmt|;
comment|/* Number of components */
name|TRACEMS1
argument_list|(
name|cinfo
argument_list|,
literal|1
argument_list|,
name|JTRC_SOS
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|!=
operator|(
name|n
operator|*
literal|2
operator|+
literal|6
operator|)
operator|||
name|n
operator|>
name|MAX_COMPS_IN_SCAN
operator|||
operator|(
name|n
operator|==
literal|0
operator|&&
operator|!
name|cinfo
operator|->
name|progressive_mode
operator|)
condition|)
comment|/* pseudo SOS marker only allowed in progressive mode */
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_LENGTH
argument_list|)
expr_stmt|;
name|cinfo
operator|->
name|comps_in_scan
operator|=
name|n
expr_stmt|;
comment|/* Collect the component-spec parameters */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|INPUT_BYTE
argument_list|(
argument|cinfo
argument_list|,
argument|cc
argument_list|,
argument|return FALSE
argument_list|)
empty_stmt|;
name|INPUT_BYTE
argument_list|(
argument|cinfo
argument_list|,
argument|c
argument_list|,
argument|return FALSE
argument_list|)
empty_stmt|;
for|for
control|(
name|ci
operator|=
literal|0
operator|,
name|compptr
operator|=
name|cinfo
operator|->
name|comp_info
init|;
name|ci
operator|<
name|cinfo
operator|->
name|num_components
condition|;
name|ci
operator|++
operator|,
name|compptr
operator|++
control|)
block|{
if|if
condition|(
name|cc
operator|==
name|compptr
operator|->
name|component_id
condition|)
goto|goto
name|id_found
goto|;
block|}
name|ERREXIT1
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_COMPONENT_ID
argument_list|,
name|cc
argument_list|)
expr_stmt|;
name|id_found
label|:
name|cinfo
operator|->
name|cur_comp_info
index|[
name|i
index|]
operator|=
name|compptr
expr_stmt|;
name|compptr
operator|->
name|dc_tbl_no
operator|=
operator|(
name|c
operator|>>
literal|4
operator|)
operator|&
literal|15
expr_stmt|;
name|compptr
operator|->
name|ac_tbl_no
operator|=
operator|(
name|c
operator|)
operator|&
literal|15
expr_stmt|;
name|TRACEMS3
argument_list|(
name|cinfo
argument_list|,
literal|1
argument_list|,
name|JTRC_SOS_COMPONENT
argument_list|,
name|cc
argument_list|,
name|compptr
operator|->
name|dc_tbl_no
argument_list|,
name|compptr
operator|->
name|ac_tbl_no
argument_list|)
expr_stmt|;
block|}
comment|/* Collect the additional scan parameters Ss, Se, Ah/Al. */
name|INPUT_BYTE
argument_list|(
argument|cinfo
argument_list|,
argument|c
argument_list|,
argument|return FALSE
argument_list|)
empty_stmt|;
name|cinfo
operator|->
name|Ss
operator|=
name|c
expr_stmt|;
name|INPUT_BYTE
argument_list|(
argument|cinfo
argument_list|,
argument|c
argument_list|,
argument|return FALSE
argument_list|)
empty_stmt|;
name|cinfo
operator|->
name|Se
operator|=
name|c
expr_stmt|;
name|INPUT_BYTE
argument_list|(
argument|cinfo
argument_list|,
argument|c
argument_list|,
argument|return FALSE
argument_list|)
empty_stmt|;
name|cinfo
operator|->
name|Ah
operator|=
operator|(
name|c
operator|>>
literal|4
operator|)
operator|&
literal|15
expr_stmt|;
name|cinfo
operator|->
name|Al
operator|=
operator|(
name|c
operator|)
operator|&
literal|15
expr_stmt|;
name|TRACEMS4
argument_list|(
name|cinfo
argument_list|,
literal|1
argument_list|,
name|JTRC_SOS_PARAMS
argument_list|,
name|cinfo
operator|->
name|Ss
argument_list|,
name|cinfo
operator|->
name|Se
argument_list|,
name|cinfo
operator|->
name|Ah
argument_list|,
name|cinfo
operator|->
name|Al
argument_list|)
expr_stmt|;
comment|/* Prepare to scan data& restart markers */
name|cinfo
operator|->
name|marker
operator|->
name|next_restart_num
operator|=
literal|0
expr_stmt|;
comment|/* Count another (non-pseudo) SOS marker */
if|if
condition|(
name|n
condition|)
name|cinfo
operator|->
name|input_scan_number
operator|++
expr_stmt|;
name|INPUT_SYNC
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_block
begin_ifdef
ifdef|#
directive|ifdef
name|D_ARITH_CODING_SUPPORTED
end_ifdef
begin_macro
DECL|function|LOCAL
name|LOCAL
argument_list|(
argument|boolean
argument_list|)
end_macro
begin_macro
name|get_dac
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|)
end_macro
begin_comment
comment|/* Process a DAC marker */
end_comment
begin_block
block|{
name|INT32
name|length
decl_stmt|;
name|int
name|index
decl_stmt|,
name|val
decl_stmt|;
name|INPUT_VARS
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
name|INPUT_2BYTES
argument_list|(
argument|cinfo
argument_list|,
argument|length
argument_list|,
argument|return FALSE
argument_list|)
empty_stmt|;
name|length
operator|-=
literal|2
expr_stmt|;
while|while
condition|(
name|length
operator|>
literal|0
condition|)
block|{
name|INPUT_BYTE
argument_list|(
argument|cinfo
argument_list|,
argument|index
argument_list|,
argument|return FALSE
argument_list|)
empty_stmt|;
name|INPUT_BYTE
argument_list|(
argument|cinfo
argument_list|,
argument|val
argument_list|,
argument|return FALSE
argument_list|)
empty_stmt|;
name|length
operator|-=
literal|2
expr_stmt|;
name|TRACEMS2
argument_list|(
name|cinfo
argument_list|,
literal|1
argument_list|,
name|JTRC_DAC
argument_list|,
name|index
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|<
literal|0
operator|||
name|index
operator|>=
operator|(
literal|2
operator|*
name|NUM_ARITH_TBLS
operator|)
condition|)
name|ERREXIT1
argument_list|(
name|cinfo
argument_list|,
name|JERR_DAC_INDEX
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|>=
name|NUM_ARITH_TBLS
condition|)
block|{
comment|/* define AC table */
name|cinfo
operator|->
name|arith_ac_K
index|[
name|index
operator|-
name|NUM_ARITH_TBLS
index|]
operator|=
operator|(
name|UINT8
operator|)
name|val
expr_stmt|;
block|}
else|else
block|{
comment|/* define DC table */
name|cinfo
operator|->
name|arith_dc_L
index|[
name|index
index|]
operator|=
call|(
name|UINT8
call|)
argument_list|(
name|val
operator|&
literal|0x0F
argument_list|)
expr_stmt|;
name|cinfo
operator|->
name|arith_dc_U
index|[
name|index
index|]
operator|=
call|(
name|UINT8
call|)
argument_list|(
name|val
operator|>>
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|cinfo
operator|->
name|arith_dc_L
index|[
name|index
index|]
operator|>
name|cinfo
operator|->
name|arith_dc_U
index|[
name|index
index|]
condition|)
name|ERREXIT1
argument_list|(
name|cinfo
argument_list|,
name|JERR_DAC_VALUE
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|length
operator|!=
literal|0
condition|)
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_LENGTH
argument_list|)
expr_stmt|;
name|INPUT_SYNC
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_block
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* ! D_ARITH_CODING_SUPPORTED */
end_comment
begin_define
DECL|macro|get_dac
define|#
directive|define
name|get_dac
parameter_list|(
name|cinfo
parameter_list|)
value|skip_variable(cinfo)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* D_ARITH_CODING_SUPPORTED */
end_comment
begin_macro
DECL|function|LOCAL
name|LOCAL
argument_list|(
argument|boolean
argument_list|)
end_macro
begin_macro
name|get_dht
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|)
end_macro
begin_comment
comment|/* Process a DHT marker */
end_comment
begin_block
block|{
name|INT32
name|length
decl_stmt|;
name|UINT8
name|bits
index|[
literal|17
index|]
decl_stmt|;
name|UINT8
name|huffval
index|[
literal|256
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|index
decl_stmt|,
name|count
decl_stmt|;
name|JHUFF_TBL
modifier|*
modifier|*
name|htblptr
decl_stmt|;
name|INPUT_VARS
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
name|INPUT_2BYTES
argument_list|(
argument|cinfo
argument_list|,
argument|length
argument_list|,
argument|return FALSE
argument_list|)
empty_stmt|;
name|length
operator|-=
literal|2
expr_stmt|;
while|while
condition|(
name|length
operator|>
literal|16
condition|)
block|{
name|INPUT_BYTE
argument_list|(
argument|cinfo
argument_list|,
argument|index
argument_list|,
argument|return FALSE
argument_list|)
empty_stmt|;
name|TRACEMS1
argument_list|(
name|cinfo
argument_list|,
literal|1
argument_list|,
name|JTRC_DHT
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|bits
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|INPUT_BYTE
argument_list|(
argument|cinfo
argument_list|,
argument|bits[i]
argument_list|,
argument|return FALSE
argument_list|)
empty_stmt|;
name|count
operator|+=
name|bits
index|[
name|i
index|]
expr_stmt|;
block|}
name|length
operator|-=
literal|1
operator|+
literal|16
expr_stmt|;
name|TRACEMS8
argument_list|(
name|cinfo
argument_list|,
literal|2
argument_list|,
name|JTRC_HUFFBITS
argument_list|,
name|bits
index|[
literal|1
index|]
argument_list|,
name|bits
index|[
literal|2
index|]
argument_list|,
name|bits
index|[
literal|3
index|]
argument_list|,
name|bits
index|[
literal|4
index|]
argument_list|,
name|bits
index|[
literal|5
index|]
argument_list|,
name|bits
index|[
literal|6
index|]
argument_list|,
name|bits
index|[
literal|7
index|]
argument_list|,
name|bits
index|[
literal|8
index|]
argument_list|)
expr_stmt|;
name|TRACEMS8
argument_list|(
name|cinfo
argument_list|,
literal|2
argument_list|,
name|JTRC_HUFFBITS
argument_list|,
name|bits
index|[
literal|9
index|]
argument_list|,
name|bits
index|[
literal|10
index|]
argument_list|,
name|bits
index|[
literal|11
index|]
argument_list|,
name|bits
index|[
literal|12
index|]
argument_list|,
name|bits
index|[
literal|13
index|]
argument_list|,
name|bits
index|[
literal|14
index|]
argument_list|,
name|bits
index|[
literal|15
index|]
argument_list|,
name|bits
index|[
literal|16
index|]
argument_list|)
expr_stmt|;
comment|/* Here we just do minimal validation of the counts to avoid walking      * off the end of our table space.  jdhuff.c will check more carefully.      */
if|if
condition|(
name|count
operator|>
literal|256
operator|||
operator|(
operator|(
name|INT32
operator|)
name|count
operator|)
operator|>
name|length
condition|)
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_HUFF_TABLE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
name|INPUT_BYTE
argument_list|(
argument|cinfo
argument_list|,
argument|huffval[i]
argument_list|,
argument|return FALSE
argument_list|)
empty_stmt|;
name|length
operator|-=
name|count
expr_stmt|;
if|if
condition|(
name|index
operator|&
literal|0x10
condition|)
block|{
comment|/* AC table definition */
name|index
operator|-=
literal|0x10
expr_stmt|;
name|htblptr
operator|=
operator|&
name|cinfo
operator|->
name|ac_huff_tbl_ptrs
index|[
name|index
index|]
expr_stmt|;
block|}
else|else
block|{
comment|/* DC table definition */
name|htblptr
operator|=
operator|&
name|cinfo
operator|->
name|dc_huff_tbl_ptrs
index|[
name|index
index|]
expr_stmt|;
block|}
if|if
condition|(
name|index
operator|<
literal|0
operator|||
name|index
operator|>=
name|NUM_HUFF_TBLS
condition|)
name|ERREXIT1
argument_list|(
name|cinfo
argument_list|,
name|JERR_DHT_INDEX
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|htblptr
operator|==
name|NULL
condition|)
operator|*
name|htblptr
operator|=
name|jpeg_alloc_huff_table
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|)
expr_stmt|;
name|MEMCOPY
argument_list|(
operator|(
operator|*
name|htblptr
operator|)
operator|->
name|bits
argument_list|,
name|bits
argument_list|,
name|SIZEOF
argument_list|(
operator|(
operator|*
name|htblptr
operator|)
operator|->
name|bits
argument_list|)
argument_list|)
expr_stmt|;
name|MEMCOPY
argument_list|(
operator|(
operator|*
name|htblptr
operator|)
operator|->
name|huffval
argument_list|,
name|huffval
argument_list|,
name|SIZEOF
argument_list|(
operator|(
operator|*
name|htblptr
operator|)
operator|->
name|huffval
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|length
operator|!=
literal|0
condition|)
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_LENGTH
argument_list|)
expr_stmt|;
name|INPUT_SYNC
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_block
begin_macro
DECL|function|LOCAL
name|LOCAL
argument_list|(
argument|boolean
argument_list|)
end_macro
begin_macro
name|get_dqt
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|)
end_macro
begin_comment
comment|/* Process a DQT marker */
end_comment
begin_block
block|{
name|INT32
name|length
decl_stmt|,
name|count
decl_stmt|,
name|i
decl_stmt|;
name|int
name|n
decl_stmt|,
name|prec
decl_stmt|;
name|unsigned
name|int
name|tmp
decl_stmt|;
name|JQUANT_TBL
modifier|*
name|quant_ptr
decl_stmt|;
specifier|const
name|int
modifier|*
name|natural_order
decl_stmt|;
name|INPUT_VARS
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
name|INPUT_2BYTES
argument_list|(
argument|cinfo
argument_list|,
argument|length
argument_list|,
argument|return FALSE
argument_list|)
empty_stmt|;
name|length
operator|-=
literal|2
expr_stmt|;
while|while
condition|(
name|length
operator|>
literal|0
condition|)
block|{
name|length
operator|--
expr_stmt|;
name|INPUT_BYTE
argument_list|(
argument|cinfo
argument_list|,
argument|n
argument_list|,
argument|return FALSE
argument_list|)
empty_stmt|;
name|prec
operator|=
name|n
operator|>>
literal|4
expr_stmt|;
name|n
operator|&=
literal|0x0F
expr_stmt|;
name|TRACEMS2
argument_list|(
name|cinfo
argument_list|,
literal|1
argument_list|,
name|JTRC_DQT
argument_list|,
name|n
argument_list|,
name|prec
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>=
name|NUM_QUANT_TBLS
condition|)
name|ERREXIT1
argument_list|(
name|cinfo
argument_list|,
name|JERR_DQT_INDEX
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|cinfo
operator|->
name|quant_tbl_ptrs
index|[
name|n
index|]
operator|==
name|NULL
condition|)
name|cinfo
operator|->
name|quant_tbl_ptrs
index|[
name|n
index|]
operator|=
name|jpeg_alloc_quant_table
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|)
expr_stmt|;
name|quant_ptr
operator|=
name|cinfo
operator|->
name|quant_tbl_ptrs
index|[
name|n
index|]
expr_stmt|;
if|if
condition|(
name|prec
condition|)
block|{
if|if
condition|(
name|length
operator|<
name|DCTSIZE2
operator|*
literal|2
condition|)
block|{
comment|/* Initialize full table for safety. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DCTSIZE2
condition|;
name|i
operator|++
control|)
block|{
name|quant_ptr
operator|->
name|quantval
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
block|}
name|count
operator|=
name|length
operator|>>
literal|1
expr_stmt|;
block|}
else|else
name|count
operator|=
name|DCTSIZE2
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|length
operator|<
name|DCTSIZE2
condition|)
block|{
comment|/* Initialize full table for safety. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DCTSIZE2
condition|;
name|i
operator|++
control|)
block|{
name|quant_ptr
operator|->
name|quantval
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
block|}
name|count
operator|=
name|length
expr_stmt|;
block|}
else|else
name|count
operator|=
name|DCTSIZE2
expr_stmt|;
block|}
switch|switch
condition|(
name|count
condition|)
block|{
case|case
operator|(
literal|2
operator|*
literal|2
operator|)
case|:
name|natural_order
operator|=
name|jpeg_natural_order2
expr_stmt|;
break|break;
case|case
operator|(
literal|3
operator|*
literal|3
operator|)
case|:
name|natural_order
operator|=
name|jpeg_natural_order3
expr_stmt|;
break|break;
case|case
operator|(
literal|4
operator|*
literal|4
operator|)
case|:
name|natural_order
operator|=
name|jpeg_natural_order4
expr_stmt|;
break|break;
case|case
operator|(
literal|5
operator|*
literal|5
operator|)
case|:
name|natural_order
operator|=
name|jpeg_natural_order5
expr_stmt|;
break|break;
case|case
operator|(
literal|6
operator|*
literal|6
operator|)
case|:
name|natural_order
operator|=
name|jpeg_natural_order6
expr_stmt|;
break|break;
case|case
operator|(
literal|7
operator|*
literal|7
operator|)
case|:
name|natural_order
operator|=
name|jpeg_natural_order7
expr_stmt|;
break|break;
default|default:
name|natural_order
operator|=
name|jpeg_natural_order
expr_stmt|;
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|prec
condition|)
name|INPUT_2BYTES
argument_list|(
argument|cinfo
argument_list|,
argument|tmp
argument_list|,
argument|return FALSE
argument_list|)
empty_stmt|;
else|else
name|INPUT_BYTE
argument_list|(
argument|cinfo
argument_list|,
argument|tmp
argument_list|,
argument|return FALSE
argument_list|)
empty_stmt|;
comment|/* We convert the zigzag-order table to natural array order. */
name|quant_ptr
operator|->
name|quantval
index|[
name|natural_order
index|[
name|i
index|]
index|]
operator|=
operator|(
name|UINT16
operator|)
name|tmp
expr_stmt|;
block|}
if|if
condition|(
name|cinfo
operator|->
name|err
operator|->
name|trace_level
operator|>=
literal|2
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DCTSIZE2
condition|;
name|i
operator|+=
literal|8
control|)
block|{
name|TRACEMS8
argument_list|(
name|cinfo
argument_list|,
literal|2
argument_list|,
name|JTRC_QUANTVALS
argument_list|,
name|quant_ptr
operator|->
name|quantval
index|[
name|i
index|]
argument_list|,
name|quant_ptr
operator|->
name|quantval
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
name|quant_ptr
operator|->
name|quantval
index|[
name|i
operator|+
literal|2
index|]
argument_list|,
name|quant_ptr
operator|->
name|quantval
index|[
name|i
operator|+
literal|3
index|]
argument_list|,
name|quant_ptr
operator|->
name|quantval
index|[
name|i
operator|+
literal|4
index|]
argument_list|,
name|quant_ptr
operator|->
name|quantval
index|[
name|i
operator|+
literal|5
index|]
argument_list|,
name|quant_ptr
operator|->
name|quantval
index|[
name|i
operator|+
literal|6
index|]
argument_list|,
name|quant_ptr
operator|->
name|quantval
index|[
name|i
operator|+
literal|7
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|length
operator|-=
name|count
expr_stmt|;
if|if
condition|(
name|prec
condition|)
name|length
operator|-=
name|count
expr_stmt|;
block|}
if|if
condition|(
name|length
operator|!=
literal|0
condition|)
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_LENGTH
argument_list|)
expr_stmt|;
name|INPUT_SYNC
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_block
begin_macro
DECL|function|LOCAL
name|LOCAL
argument_list|(
argument|boolean
argument_list|)
end_macro
begin_macro
name|get_dri
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|)
end_macro
begin_comment
comment|/* Process a DRI marker */
end_comment
begin_block
block|{
name|INT32
name|length
decl_stmt|;
name|unsigned
name|int
name|tmp
decl_stmt|;
name|INPUT_VARS
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
name|INPUT_2BYTES
argument_list|(
argument|cinfo
argument_list|,
argument|length
argument_list|,
argument|return FALSE
argument_list|)
empty_stmt|;
if|if
condition|(
name|length
operator|!=
literal|4
condition|)
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_LENGTH
argument_list|)
expr_stmt|;
name|INPUT_2BYTES
argument_list|(
argument|cinfo
argument_list|,
argument|tmp
argument_list|,
argument|return FALSE
argument_list|)
empty_stmt|;
name|TRACEMS1
argument_list|(
name|cinfo
argument_list|,
literal|1
argument_list|,
name|JTRC_DRI
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|cinfo
operator|->
name|restart_interval
operator|=
name|tmp
expr_stmt|;
name|INPUT_SYNC
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_block
begin_comment
comment|/*  * Routines for processing APPn and COM markers.  * These are either saved in memory or discarded, per application request.  * APP0 and APP14 are specially checked to see if they are  * JFIF and Adobe markers, respectively.  */
end_comment
begin_define
DECL|macro|APP0_DATA_LEN
define|#
directive|define
name|APP0_DATA_LEN
value|14
end_define
begin_comment
DECL|macro|APP0_DATA_LEN
comment|/* Length of interesting data in APP0 */
end_comment
begin_define
DECL|macro|APP14_DATA_LEN
define|#
directive|define
name|APP14_DATA_LEN
value|12
end_define
begin_comment
DECL|macro|APP14_DATA_LEN
comment|/* Length of interesting data in APP14 */
end_comment
begin_define
DECL|macro|APPN_DATA_LEN
define|#
directive|define
name|APPN_DATA_LEN
value|14
end_define
begin_comment
DECL|macro|APPN_DATA_LEN
comment|/* Must be the largest of the above!! */
end_comment
begin_macro
name|LOCAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|examine_app0
name|examine_app0
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|,
argument|JOCTET FAR * data
argument_list|,
argument|unsigned int datalen
argument_list|,
argument|INT32 remaining
argument_list|)
end_macro
begin_comment
comment|/* Examine first few bytes from an APP0.  * Take appropriate action if it is a JFIF marker.  * datalen is # of bytes at data[], remaining is length of rest of marker data.  */
end_comment
begin_block
block|{
name|INT32
name|totallen
init|=
operator|(
name|INT32
operator|)
name|datalen
operator|+
name|remaining
decl_stmt|;
if|if
condition|(
name|datalen
operator|>=
name|APP0_DATA_LEN
operator|&&
name|GETJOCTET
argument_list|(
name|data
index|[
literal|0
index|]
argument_list|)
operator|==
literal|0x4A
operator|&&
name|GETJOCTET
argument_list|(
name|data
index|[
literal|1
index|]
argument_list|)
operator|==
literal|0x46
operator|&&
name|GETJOCTET
argument_list|(
name|data
index|[
literal|2
index|]
argument_list|)
operator|==
literal|0x49
operator|&&
name|GETJOCTET
argument_list|(
name|data
index|[
literal|3
index|]
argument_list|)
operator|==
literal|0x46
operator|&&
name|GETJOCTET
argument_list|(
name|data
index|[
literal|4
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Found JFIF APP0 marker: save info */
name|cinfo
operator|->
name|saw_JFIF_marker
operator|=
name|TRUE
expr_stmt|;
name|cinfo
operator|->
name|JFIF_major_version
operator|=
name|GETJOCTET
argument_list|(
name|data
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|cinfo
operator|->
name|JFIF_minor_version
operator|=
name|GETJOCTET
argument_list|(
name|data
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
name|cinfo
operator|->
name|density_unit
operator|=
name|GETJOCTET
argument_list|(
name|data
index|[
literal|7
index|]
argument_list|)
expr_stmt|;
name|cinfo
operator|->
name|X_density
operator|=
operator|(
name|GETJOCTET
argument_list|(
name|data
index|[
literal|8
index|]
argument_list|)
operator|<<
literal|8
operator|)
operator|+
name|GETJOCTET
argument_list|(
name|data
index|[
literal|9
index|]
argument_list|)
expr_stmt|;
name|cinfo
operator|->
name|Y_density
operator|=
operator|(
name|GETJOCTET
argument_list|(
name|data
index|[
literal|10
index|]
argument_list|)
operator|<<
literal|8
operator|)
operator|+
name|GETJOCTET
argument_list|(
name|data
index|[
literal|11
index|]
argument_list|)
expr_stmt|;
comment|/* Check version.      * Major version must be 1, anything else signals an incompatible change.      * (We used to treat this as an error, but now it's a nonfatal warning,      * because some bozo at Hijaak couldn't read the spec.)      * Minor version should be 0..2, but process anyway if newer.      */
if|if
condition|(
name|cinfo
operator|->
name|JFIF_major_version
operator|!=
literal|1
condition|)
name|WARNMS2
argument_list|(
name|cinfo
argument_list|,
name|JWRN_JFIF_MAJOR
argument_list|,
name|cinfo
operator|->
name|JFIF_major_version
argument_list|,
name|cinfo
operator|->
name|JFIF_minor_version
argument_list|)
expr_stmt|;
comment|/* Generate trace messages */
name|TRACEMS5
argument_list|(
name|cinfo
argument_list|,
literal|1
argument_list|,
name|JTRC_JFIF
argument_list|,
name|cinfo
operator|->
name|JFIF_major_version
argument_list|,
name|cinfo
operator|->
name|JFIF_minor_version
argument_list|,
name|cinfo
operator|->
name|X_density
argument_list|,
name|cinfo
operator|->
name|Y_density
argument_list|,
name|cinfo
operator|->
name|density_unit
argument_list|)
expr_stmt|;
comment|/* Validate thumbnail dimensions and issue appropriate messages */
if|if
condition|(
name|GETJOCTET
argument_list|(
name|data
index|[
literal|12
index|]
argument_list|)
operator||
name|GETJOCTET
argument_list|(
name|data
index|[
literal|13
index|]
argument_list|)
condition|)
name|TRACEMS2
argument_list|(
name|cinfo
argument_list|,
literal|1
argument_list|,
name|JTRC_JFIF_THUMBNAIL
argument_list|,
name|GETJOCTET
argument_list|(
name|data
index|[
literal|12
index|]
argument_list|)
argument_list|,
name|GETJOCTET
argument_list|(
name|data
index|[
literal|13
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|totallen
operator|-=
name|APP0_DATA_LEN
expr_stmt|;
if|if
condition|(
name|totallen
operator|!=
operator|(
operator|(
name|INT32
operator|)
name|GETJOCTET
argument_list|(
name|data
index|[
literal|12
index|]
argument_list|)
operator|*
operator|(
name|INT32
operator|)
name|GETJOCTET
argument_list|(
name|data
index|[
literal|13
index|]
argument_list|)
operator|*
operator|(
name|INT32
operator|)
literal|3
operator|)
condition|)
name|TRACEMS1
argument_list|(
name|cinfo
argument_list|,
literal|1
argument_list|,
name|JTRC_JFIF_BADTHUMBNAILSIZE
argument_list|,
operator|(
name|int
operator|)
name|totallen
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|datalen
operator|>=
literal|6
operator|&&
name|GETJOCTET
argument_list|(
name|data
index|[
literal|0
index|]
argument_list|)
operator|==
literal|0x4A
operator|&&
name|GETJOCTET
argument_list|(
name|data
index|[
literal|1
index|]
argument_list|)
operator|==
literal|0x46
operator|&&
name|GETJOCTET
argument_list|(
name|data
index|[
literal|2
index|]
argument_list|)
operator|==
literal|0x58
operator|&&
name|GETJOCTET
argument_list|(
name|data
index|[
literal|3
index|]
argument_list|)
operator|==
literal|0x58
operator|&&
name|GETJOCTET
argument_list|(
name|data
index|[
literal|4
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Found JFIF "JFXX" extension APP0 marker */
comment|/* The library doesn't actually do anything with these,      * but we try to produce a helpful trace message.      */
switch|switch
condition|(
name|GETJOCTET
argument_list|(
name|data
index|[
literal|5
index|]
argument_list|)
condition|)
block|{
case|case
literal|0x10
case|:
name|TRACEMS1
argument_list|(
name|cinfo
argument_list|,
literal|1
argument_list|,
name|JTRC_THUMB_JPEG
argument_list|,
operator|(
name|int
operator|)
name|totallen
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x11
case|:
name|TRACEMS1
argument_list|(
name|cinfo
argument_list|,
literal|1
argument_list|,
name|JTRC_THUMB_PALETTE
argument_list|,
operator|(
name|int
operator|)
name|totallen
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x13
case|:
name|TRACEMS1
argument_list|(
name|cinfo
argument_list|,
literal|1
argument_list|,
name|JTRC_THUMB_RGB
argument_list|,
operator|(
name|int
operator|)
name|totallen
argument_list|)
expr_stmt|;
break|break;
default|default:
name|TRACEMS2
argument_list|(
name|cinfo
argument_list|,
literal|1
argument_list|,
name|JTRC_JFIF_EXTENSION
argument_list|,
name|GETJOCTET
argument_list|(
name|data
index|[
literal|5
index|]
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|totallen
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* Start of APP0 does not match "JFIF" or "JFXX", or too short */
name|TRACEMS1
argument_list|(
name|cinfo
argument_list|,
literal|1
argument_list|,
name|JTRC_APP0
argument_list|,
operator|(
name|int
operator|)
name|totallen
argument_list|)
expr_stmt|;
block|}
block|}
end_block
begin_macro
name|LOCAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|examine_app14
name|examine_app14
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|,
argument|JOCTET FAR * data
argument_list|,
argument|unsigned int datalen
argument_list|,
argument|INT32 remaining
argument_list|)
end_macro
begin_comment
comment|/* Examine first few bytes from an APP14.  * Take appropriate action if it is an Adobe marker.  * datalen is # of bytes at data[], remaining is length of rest of marker data.  */
end_comment
begin_block
block|{
name|unsigned
name|int
name|version
decl_stmt|,
name|flags0
decl_stmt|,
name|flags1
decl_stmt|,
name|transform
decl_stmt|;
if|if
condition|(
name|datalen
operator|>=
name|APP14_DATA_LEN
operator|&&
name|GETJOCTET
argument_list|(
name|data
index|[
literal|0
index|]
argument_list|)
operator|==
literal|0x41
operator|&&
name|GETJOCTET
argument_list|(
name|data
index|[
literal|1
index|]
argument_list|)
operator|==
literal|0x64
operator|&&
name|GETJOCTET
argument_list|(
name|data
index|[
literal|2
index|]
argument_list|)
operator|==
literal|0x6F
operator|&&
name|GETJOCTET
argument_list|(
name|data
index|[
literal|3
index|]
argument_list|)
operator|==
literal|0x62
operator|&&
name|GETJOCTET
argument_list|(
name|data
index|[
literal|4
index|]
argument_list|)
operator|==
literal|0x65
condition|)
block|{
comment|/* Found Adobe APP14 marker */
name|version
operator|=
operator|(
name|GETJOCTET
argument_list|(
name|data
index|[
literal|5
index|]
argument_list|)
operator|<<
literal|8
operator|)
operator|+
name|GETJOCTET
argument_list|(
name|data
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
name|flags0
operator|=
operator|(
name|GETJOCTET
argument_list|(
name|data
index|[
literal|7
index|]
argument_list|)
operator|<<
literal|8
operator|)
operator|+
name|GETJOCTET
argument_list|(
name|data
index|[
literal|8
index|]
argument_list|)
expr_stmt|;
name|flags1
operator|=
operator|(
name|GETJOCTET
argument_list|(
name|data
index|[
literal|9
index|]
argument_list|)
operator|<<
literal|8
operator|)
operator|+
name|GETJOCTET
argument_list|(
name|data
index|[
literal|10
index|]
argument_list|)
expr_stmt|;
name|transform
operator|=
name|GETJOCTET
argument_list|(
name|data
index|[
literal|11
index|]
argument_list|)
expr_stmt|;
name|TRACEMS4
argument_list|(
name|cinfo
argument_list|,
literal|1
argument_list|,
name|JTRC_ADOBE
argument_list|,
name|version
argument_list|,
name|flags0
argument_list|,
name|flags1
argument_list|,
name|transform
argument_list|)
expr_stmt|;
name|cinfo
operator|->
name|saw_Adobe_marker
operator|=
name|TRUE
expr_stmt|;
name|cinfo
operator|->
name|Adobe_transform
operator|=
operator|(
name|UINT8
operator|)
name|transform
expr_stmt|;
block|}
else|else
block|{
comment|/* Start of APP14 does not match "Adobe", or too short */
name|TRACEMS1
argument_list|(
name|cinfo
argument_list|,
literal|1
argument_list|,
name|JTRC_APP14
argument_list|,
call|(
name|int
call|)
argument_list|(
name|datalen
operator|+
name|remaining
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_block
begin_macro
DECL|function|METHODDEF
name|METHODDEF
argument_list|(
argument|boolean
argument_list|)
end_macro
begin_macro
name|get_interesting_appn
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|)
end_macro
begin_comment
comment|/* Process an APP0 or APP14 marker without saving it */
end_comment
begin_block
block|{
name|INT32
name|length
decl_stmt|;
name|JOCTET
name|b
index|[
name|APPN_DATA_LEN
index|]
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|numtoread
decl_stmt|;
name|INPUT_VARS
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
name|INPUT_2BYTES
argument_list|(
argument|cinfo
argument_list|,
argument|length
argument_list|,
argument|return FALSE
argument_list|)
empty_stmt|;
name|length
operator|-=
literal|2
expr_stmt|;
comment|/* get the interesting part of the marker data */
if|if
condition|(
name|length
operator|>=
name|APPN_DATA_LEN
condition|)
name|numtoread
operator|=
name|APPN_DATA_LEN
expr_stmt|;
elseif|else
if|if
condition|(
name|length
operator|>
literal|0
condition|)
name|numtoread
operator|=
operator|(
name|unsigned
name|int
operator|)
name|length
expr_stmt|;
else|else
name|numtoread
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numtoread
condition|;
name|i
operator|++
control|)
name|INPUT_BYTE
argument_list|(
argument|cinfo
argument_list|,
argument|b[i]
argument_list|,
argument|return FALSE
argument_list|)
empty_stmt|;
name|length
operator|-=
name|numtoread
expr_stmt|;
comment|/* process it */
switch|switch
condition|(
name|cinfo
operator|->
name|unread_marker
condition|)
block|{
case|case
name|M_APP0
case|:
name|examine_app0
argument_list|(
name|cinfo
argument_list|,
operator|(
name|JOCTET
name|FAR
operator|*
operator|)
name|b
argument_list|,
name|numtoread
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_APP14
case|:
name|examine_app14
argument_list|(
name|cinfo
argument_list|,
operator|(
name|JOCTET
name|FAR
operator|*
operator|)
name|b
argument_list|,
name|numtoread
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* can't get here unless jpeg_save_markers chooses wrong processor */
name|ERREXIT1
argument_list|(
name|cinfo
argument_list|,
name|JERR_UNKNOWN_MARKER
argument_list|,
name|cinfo
operator|->
name|unread_marker
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* skip any remaining data -- could be lots */
name|INPUT_SYNC
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|>
literal|0
condition|)
call|(
modifier|*
name|cinfo
operator|->
name|src
operator|->
name|skip_input_data
call|)
argument_list|(
name|cinfo
argument_list|,
operator|(
name|long
operator|)
name|length
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_block
begin_ifdef
ifdef|#
directive|ifdef
name|SAVE_MARKERS_SUPPORTED
end_ifdef
begin_macro
DECL|function|METHODDEF
name|METHODDEF
argument_list|(
argument|boolean
argument_list|)
end_macro
begin_macro
name|save_marker
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|)
end_macro
begin_comment
comment|/* Save an APPn or COM marker into the marker list */
end_comment
begin_block
block|{
name|my_marker_ptr
name|marker
init|=
operator|(
name|my_marker_ptr
operator|)
name|cinfo
operator|->
name|marker
decl_stmt|;
name|jpeg_saved_marker_ptr
name|cur_marker
init|=
name|marker
operator|->
name|cur_marker
decl_stmt|;
name|unsigned
name|int
name|bytes_read
decl_stmt|,
name|data_length
decl_stmt|;
name|JOCTET
name|FAR
modifier|*
name|data
decl_stmt|;
name|INT32
name|length
init|=
literal|0
decl_stmt|;
name|INPUT_VARS
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur_marker
operator|==
name|NULL
condition|)
block|{
comment|/* begin reading a marker */
name|INPUT_2BYTES
argument_list|(
argument|cinfo
argument_list|,
argument|length
argument_list|,
argument|return FALSE
argument_list|)
empty_stmt|;
name|length
operator|-=
literal|2
expr_stmt|;
if|if
condition|(
name|length
operator|>=
literal|0
condition|)
block|{
comment|/* watch out for bogus length word */
comment|/* figure out how much we want to save */
name|unsigned
name|int
name|limit
decl_stmt|;
if|if
condition|(
name|cinfo
operator|->
name|unread_marker
operator|==
operator|(
name|int
operator|)
name|M_COM
condition|)
name|limit
operator|=
name|marker
operator|->
name|length_limit_COM
expr_stmt|;
else|else
name|limit
operator|=
name|marker
operator|->
name|length_limit_APPn
index|[
name|cinfo
operator|->
name|unread_marker
operator|-
operator|(
name|int
operator|)
name|M_APP0
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|int
operator|)
name|length
operator|<
name|limit
condition|)
name|limit
operator|=
operator|(
name|unsigned
name|int
operator|)
name|length
expr_stmt|;
comment|/* allocate and initialize the marker item */
name|cur_marker
operator|=
call|(
name|jpeg_saved_marker_ptr
call|)
argument_list|(
operator|*
name|cinfo
operator|->
name|mem
operator|->
name|alloc_large
argument_list|)
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|,
name|JPOOL_IMAGE
argument_list|,
name|SIZEOF
argument_list|(
expr|struct
name|jpeg_marker_struct
argument_list|)
operator|+
name|limit
argument_list|)
expr_stmt|;
name|cur_marker
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|cur_marker
operator|->
name|marker
operator|=
operator|(
name|UINT8
operator|)
name|cinfo
operator|->
name|unread_marker
expr_stmt|;
name|cur_marker
operator|->
name|original_length
operator|=
operator|(
name|unsigned
name|int
operator|)
name|length
expr_stmt|;
name|cur_marker
operator|->
name|data_length
operator|=
name|limit
expr_stmt|;
comment|/* data area is just beyond the jpeg_marker_struct */
name|data
operator|=
name|cur_marker
operator|->
name|data
operator|=
operator|(
name|JOCTET
name|FAR
operator|*
operator|)
operator|(
name|cur_marker
operator|+
literal|1
operator|)
expr_stmt|;
name|marker
operator|->
name|cur_marker
operator|=
name|cur_marker
expr_stmt|;
name|marker
operator|->
name|bytes_read
operator|=
literal|0
expr_stmt|;
name|bytes_read
operator|=
literal|0
expr_stmt|;
name|data_length
operator|=
name|limit
expr_stmt|;
block|}
else|else
block|{
comment|/* deal with bogus length word */
name|bytes_read
operator|=
name|data_length
operator|=
literal|0
expr_stmt|;
name|data
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* resume reading a marker */
name|bytes_read
operator|=
name|marker
operator|->
name|bytes_read
expr_stmt|;
name|data_length
operator|=
name|cur_marker
operator|->
name|data_length
expr_stmt|;
name|data
operator|=
name|cur_marker
operator|->
name|data
operator|+
name|bytes_read
expr_stmt|;
block|}
while|while
condition|(
name|bytes_read
operator|<
name|data_length
condition|)
block|{
name|INPUT_SYNC
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
comment|/* move the restart point to here */
name|marker
operator|->
name|bytes_read
operator|=
name|bytes_read
expr_stmt|;
comment|/* If there's not at least one byte in buffer, suspend */
name|MAKE_BYTE_AVAIL
argument_list|(
argument|cinfo
argument_list|,
argument|return FALSE
argument_list|)
empty_stmt|;
comment|/* Copy bytes with reasonable rapidity */
while|while
condition|(
name|bytes_read
operator|<
name|data_length
operator|&&
name|bytes_in_buffer
operator|>
literal|0
condition|)
block|{
operator|*
name|data
operator|++
operator|=
operator|*
name|next_input_byte
operator|++
expr_stmt|;
name|bytes_in_buffer
operator|--
expr_stmt|;
name|bytes_read
operator|++
expr_stmt|;
block|}
block|}
comment|/* Done reading what we want to read */
if|if
condition|(
name|cur_marker
operator|!=
name|NULL
condition|)
block|{
comment|/* will be NULL if bogus length word */
comment|/* Add new marker to end of list */
if|if
condition|(
name|cinfo
operator|->
name|marker_list
operator|==
name|NULL
condition|)
block|{
name|cinfo
operator|->
name|marker_list
operator|=
name|cur_marker
expr_stmt|;
block|}
else|else
block|{
name|jpeg_saved_marker_ptr
name|prev
init|=
name|cinfo
operator|->
name|marker_list
decl_stmt|;
while|while
condition|(
name|prev
operator|->
name|next
operator|!=
name|NULL
condition|)
name|prev
operator|=
name|prev
operator|->
name|next
expr_stmt|;
name|prev
operator|->
name|next
operator|=
name|cur_marker
expr_stmt|;
block|}
comment|/* Reset pointer& calc remaining data length */
name|data
operator|=
name|cur_marker
operator|->
name|data
expr_stmt|;
name|length
operator|=
name|cur_marker
operator|->
name|original_length
operator|-
name|data_length
expr_stmt|;
block|}
comment|/* Reset to initial state for next marker */
name|marker
operator|->
name|cur_marker
operator|=
name|NULL
expr_stmt|;
comment|/* Process the marker if interesting; else just make a generic trace msg */
switch|switch
condition|(
name|cinfo
operator|->
name|unread_marker
condition|)
block|{
case|case
name|M_APP0
case|:
name|examine_app0
argument_list|(
name|cinfo
argument_list|,
name|data
argument_list|,
name|data_length
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_APP14
case|:
name|examine_app14
argument_list|(
name|cinfo
argument_list|,
name|data
argument_list|,
name|data_length
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
default|default:
name|TRACEMS2
argument_list|(
name|cinfo
argument_list|,
literal|1
argument_list|,
name|JTRC_MISC_MARKER
argument_list|,
name|cinfo
operator|->
name|unread_marker
argument_list|,
call|(
name|int
call|)
argument_list|(
name|data_length
operator|+
name|length
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* skip any remaining data -- could be lots */
name|INPUT_SYNC
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
comment|/* do before skip_input_data */
if|if
condition|(
name|length
operator|>
literal|0
condition|)
call|(
modifier|*
name|cinfo
operator|->
name|src
operator|->
name|skip_input_data
call|)
argument_list|(
name|cinfo
argument_list|,
operator|(
name|long
operator|)
name|length
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_block
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* SAVE_MARKERS_SUPPORTED */
end_comment
begin_macro
DECL|function|METHODDEF
name|METHODDEF
argument_list|(
argument|boolean
argument_list|)
end_macro
begin_macro
name|skip_variable
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|)
end_macro
begin_comment
comment|/* Skip over an unknown or uninteresting variable-length marker */
end_comment
begin_block
block|{
name|INT32
name|length
decl_stmt|;
name|INPUT_VARS
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
name|INPUT_2BYTES
argument_list|(
argument|cinfo
argument_list|,
argument|length
argument_list|,
argument|return FALSE
argument_list|)
empty_stmt|;
name|length
operator|-=
literal|2
expr_stmt|;
name|TRACEMS2
argument_list|(
name|cinfo
argument_list|,
literal|1
argument_list|,
name|JTRC_MISC_MARKER
argument_list|,
name|cinfo
operator|->
name|unread_marker
argument_list|,
operator|(
name|int
operator|)
name|length
argument_list|)
expr_stmt|;
name|INPUT_SYNC
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
comment|/* do before skip_input_data */
if|if
condition|(
name|length
operator|>
literal|0
condition|)
call|(
modifier|*
name|cinfo
operator|->
name|src
operator|->
name|skip_input_data
call|)
argument_list|(
name|cinfo
argument_list|,
operator|(
name|long
operator|)
name|length
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_block
begin_comment
comment|/*  * Find the next JPEG marker, save it in cinfo->unread_marker.  * Returns FALSE if had to suspend before reaching a marker;  * in that case cinfo->unread_marker is unchanged.  *  * Note that the result might not be a valid marker code,  * but it will never be 0 or FF.  */
end_comment
begin_macro
DECL|function|LOCAL
name|LOCAL
argument_list|(
argument|boolean
argument_list|)
end_macro
begin_macro
name|next_marker
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|)
end_macro
begin_block
block|{
name|int
name|c
decl_stmt|;
name|INPUT_VARS
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|INPUT_BYTE
argument_list|(
argument|cinfo
argument_list|,
argument|c
argument_list|,
argument|return FALSE
argument_list|)
empty_stmt|;
comment|/* Skip any non-FF bytes.      * This may look a bit inefficient, but it will not occur in a valid file.      * We sync after each discarded byte so that a suspending data source      * can discard the byte from its buffer.      */
while|while
condition|(
name|c
operator|!=
literal|0xFF
condition|)
block|{
name|cinfo
operator|->
name|marker
operator|->
name|discarded_bytes
operator|++
expr_stmt|;
name|INPUT_SYNC
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
name|INPUT_BYTE
argument_list|(
argument|cinfo
argument_list|,
argument|c
argument_list|,
argument|return FALSE
argument_list|)
empty_stmt|;
block|}
comment|/* This loop swallows any duplicate FF bytes.  Extra FFs are legal as      * pad bytes, so don't count them in discarded_bytes.  We assume there      * will not be so many consecutive FF bytes as to overflow a suspending      * data source's input buffer.      */
do|do
block|{
name|INPUT_BYTE
argument_list|(
argument|cinfo
argument_list|,
argument|c
argument_list|,
argument|return FALSE
argument_list|)
empty_stmt|;
block|}
do|while
condition|(
name|c
operator|==
literal|0xFF
condition|)
do|;
if|if
condition|(
name|c
operator|!=
literal|0
condition|)
break|break;
comment|/* found a valid marker, exit loop */
comment|/* Reach here if we found a stuffed-zero data sequence (FF/00).      * Discard it and loop back to try again.      */
name|cinfo
operator|->
name|marker
operator|->
name|discarded_bytes
operator|+=
literal|2
expr_stmt|;
name|INPUT_SYNC
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cinfo
operator|->
name|marker
operator|->
name|discarded_bytes
operator|!=
literal|0
condition|)
block|{
name|WARNMS2
argument_list|(
name|cinfo
argument_list|,
name|JWRN_EXTRANEOUS_DATA
argument_list|,
name|cinfo
operator|->
name|marker
operator|->
name|discarded_bytes
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|cinfo
operator|->
name|marker
operator|->
name|discarded_bytes
operator|=
literal|0
expr_stmt|;
block|}
name|cinfo
operator|->
name|unread_marker
operator|=
name|c
expr_stmt|;
name|INPUT_SYNC
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_block
begin_macro
DECL|function|LOCAL
name|LOCAL
argument_list|(
argument|boolean
argument_list|)
end_macro
begin_macro
name|first_marker
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|)
end_macro
begin_comment
comment|/* Like next_marker, but used to obtain the initial SOI marker. */
end_comment
begin_comment
comment|/* For this marker, we do not allow preceding garbage or fill; otherwise,  * we might well scan an entire input file before realizing it ain't JPEG.  * If an application wants to process non-JFIF files, it must seek to the  * SOI before calling the JPEG library.  */
end_comment
begin_block
block|{
name|int
name|c
decl_stmt|,
name|c2
decl_stmt|;
name|INPUT_VARS
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
name|INPUT_BYTE
argument_list|(
argument|cinfo
argument_list|,
argument|c
argument_list|,
argument|return FALSE
argument_list|)
empty_stmt|;
name|INPUT_BYTE
argument_list|(
argument|cinfo
argument_list|,
argument|c2
argument_list|,
argument|return FALSE
argument_list|)
empty_stmt|;
if|if
condition|(
name|c
operator|!=
literal|0xFF
operator|||
name|c2
operator|!=
operator|(
name|int
operator|)
name|M_SOI
condition|)
name|ERREXIT2
argument_list|(
name|cinfo
argument_list|,
name|JERR_NO_SOI
argument_list|,
name|c
argument_list|,
name|c2
argument_list|)
expr_stmt|;
name|cinfo
operator|->
name|unread_marker
operator|=
name|c2
expr_stmt|;
name|INPUT_SYNC
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_block
begin_comment
comment|/*  * Read markers until SOS or EOI.  *  * Returns same codes as are defined for jpeg_consume_input:  * JPEG_SUSPENDED, JPEG_REACHED_SOS, or JPEG_REACHED_EOI.  *  * Note: This function may return a pseudo SOS marker (with zero  * component number) for treat by input controller's consume_input.  * consume_input itself should filter out (skip) the pseudo marker  * after processing for the caller.  */
end_comment
begin_macro
name|METHODDEF
argument_list|(
argument|int
argument_list|)
end_macro
begin_macro
DECL|function|read_markers
name|read_markers
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|)
end_macro
begin_block
block|{
comment|/* Outer loop repeats once for each marker. */
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Collect the marker proper, unless we already did. */
comment|/* NB: first_marker() enforces the requirement that SOI appear first. */
if|if
condition|(
name|cinfo
operator|->
name|unread_marker
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|cinfo
operator|->
name|marker
operator|->
name|saw_SOI
condition|)
block|{
if|if
condition|(
operator|!
name|first_marker
argument_list|(
name|cinfo
argument_list|)
condition|)
return|return
name|JPEG_SUSPENDED
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|next_marker
argument_list|(
name|cinfo
argument_list|)
condition|)
return|return
name|JPEG_SUSPENDED
return|;
block|}
block|}
comment|/* At this point cinfo->unread_marker contains the marker code and the      * input point is just past the marker proper, but before any parameters.      * A suspension will cause us to return with this state still true.      */
switch|switch
condition|(
name|cinfo
operator|->
name|unread_marker
condition|)
block|{
case|case
name|M_SOI
case|:
if|if
condition|(
operator|!
name|get_soi
argument_list|(
name|cinfo
argument_list|)
condition|)
return|return
name|JPEG_SUSPENDED
return|;
break|break;
case|case
name|M_SOF0
case|:
comment|/* Baseline */
if|if
condition|(
operator|!
name|get_sof
argument_list|(
name|cinfo
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
condition|)
return|return
name|JPEG_SUSPENDED
return|;
break|break;
case|case
name|M_SOF1
case|:
comment|/* Extended sequential, Huffman */
if|if
condition|(
operator|!
name|get_sof
argument_list|(
name|cinfo
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
condition|)
return|return
name|JPEG_SUSPENDED
return|;
break|break;
case|case
name|M_SOF2
case|:
comment|/* Progressive, Huffman */
if|if
condition|(
operator|!
name|get_sof
argument_list|(
name|cinfo
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
condition|)
return|return
name|JPEG_SUSPENDED
return|;
break|break;
case|case
name|M_SOF9
case|:
comment|/* Extended sequential, arithmetic */
if|if
condition|(
operator|!
name|get_sof
argument_list|(
name|cinfo
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return
name|JPEG_SUSPENDED
return|;
break|break;
case|case
name|M_SOF10
case|:
comment|/* Progressive, arithmetic */
if|if
condition|(
operator|!
name|get_sof
argument_list|(
name|cinfo
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return
name|JPEG_SUSPENDED
return|;
break|break;
comment|/* Currently unsupported SOFn types */
case|case
name|M_SOF3
case|:
comment|/* Lossless, Huffman */
case|case
name|M_SOF5
case|:
comment|/* Differential sequential, Huffman */
case|case
name|M_SOF6
case|:
comment|/* Differential progressive, Huffman */
case|case
name|M_SOF7
case|:
comment|/* Differential lossless, Huffman */
case|case
name|M_JPG
case|:
comment|/* Reserved for JPEG extensions */
case|case
name|M_SOF11
case|:
comment|/* Lossless, arithmetic */
case|case
name|M_SOF13
case|:
comment|/* Differential sequential, arithmetic */
case|case
name|M_SOF14
case|:
comment|/* Differential progressive, arithmetic */
case|case
name|M_SOF15
case|:
comment|/* Differential lossless, arithmetic */
name|ERREXIT1
argument_list|(
name|cinfo
argument_list|,
name|JERR_SOF_UNSUPPORTED
argument_list|,
name|cinfo
operator|->
name|unread_marker
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_SOS
case|:
if|if
condition|(
operator|!
name|get_sos
argument_list|(
name|cinfo
argument_list|)
condition|)
return|return
name|JPEG_SUSPENDED
return|;
name|cinfo
operator|->
name|unread_marker
operator|=
literal|0
expr_stmt|;
comment|/* processed the marker */
return|return
name|JPEG_REACHED_SOS
return|;
case|case
name|M_EOI
case|:
name|TRACEMS
argument_list|(
name|cinfo
argument_list|,
literal|1
argument_list|,
name|JTRC_EOI
argument_list|)
expr_stmt|;
name|cinfo
operator|->
name|unread_marker
operator|=
literal|0
expr_stmt|;
comment|/* processed the marker */
return|return
name|JPEG_REACHED_EOI
return|;
case|case
name|M_DAC
case|:
if|if
condition|(
operator|!
name|get_dac
argument_list|(
name|cinfo
argument_list|)
condition|)
return|return
name|JPEG_SUSPENDED
return|;
break|break;
case|case
name|M_DHT
case|:
if|if
condition|(
operator|!
name|get_dht
argument_list|(
name|cinfo
argument_list|)
condition|)
return|return
name|JPEG_SUSPENDED
return|;
break|break;
case|case
name|M_DQT
case|:
if|if
condition|(
operator|!
name|get_dqt
argument_list|(
name|cinfo
argument_list|)
condition|)
return|return
name|JPEG_SUSPENDED
return|;
break|break;
case|case
name|M_DRI
case|:
if|if
condition|(
operator|!
name|get_dri
argument_list|(
name|cinfo
argument_list|)
condition|)
return|return
name|JPEG_SUSPENDED
return|;
break|break;
case|case
name|M_APP0
case|:
case|case
name|M_APP1
case|:
case|case
name|M_APP2
case|:
case|case
name|M_APP3
case|:
case|case
name|M_APP4
case|:
case|case
name|M_APP5
case|:
case|case
name|M_APP6
case|:
case|case
name|M_APP7
case|:
case|case
name|M_APP8
case|:
case|case
name|M_APP9
case|:
case|case
name|M_APP10
case|:
case|case
name|M_APP11
case|:
case|case
name|M_APP12
case|:
case|case
name|M_APP13
case|:
case|case
name|M_APP14
case|:
case|case
name|M_APP15
case|:
if|if
condition|(
operator|!
operator|(
operator|*
operator|(
operator|(
name|my_marker_ptr
operator|)
name|cinfo
operator|->
name|marker
operator|)
operator|->
name|process_APPn
index|[
name|cinfo
operator|->
name|unread_marker
operator|-
operator|(
name|int
operator|)
name|M_APP0
index|]
operator|)
operator|(
name|cinfo
operator|)
condition|)
return|return
name|JPEG_SUSPENDED
return|;
break|break;
case|case
name|M_COM
case|:
if|if
condition|(
operator|!
operator|(
operator|*
operator|(
operator|(
name|my_marker_ptr
operator|)
name|cinfo
operator|->
name|marker
operator|)
operator|->
name|process_COM
operator|)
operator|(
name|cinfo
operator|)
condition|)
return|return
name|JPEG_SUSPENDED
return|;
break|break;
case|case
name|M_RST0
case|:
comment|/* these are all parameterless */
case|case
name|M_RST1
case|:
case|case
name|M_RST2
case|:
case|case
name|M_RST3
case|:
case|case
name|M_RST4
case|:
case|case
name|M_RST5
case|:
case|case
name|M_RST6
case|:
case|case
name|M_RST7
case|:
case|case
name|M_TEM
case|:
name|TRACEMS1
argument_list|(
name|cinfo
argument_list|,
literal|1
argument_list|,
name|JTRC_PARMLESS_MARKER
argument_list|,
name|cinfo
operator|->
name|unread_marker
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_DNL
case|:
comment|/* Ignore DNL ... perhaps the wrong thing */
if|if
condition|(
operator|!
name|skip_variable
argument_list|(
name|cinfo
argument_list|)
condition|)
return|return
name|JPEG_SUSPENDED
return|;
break|break;
default|default:
comment|/* must be DHP, EXP, JPGn, or RESn */
comment|/* For now, we treat the reserved markers as fatal errors since they are        * likely to be used to signal incompatible JPEG Part 3 extensions.        * Once the JPEG 3 version-number marker is well defined, this code        * ought to change!        */
name|ERREXIT1
argument_list|(
name|cinfo
argument_list|,
name|JERR_UNKNOWN_MARKER
argument_list|,
name|cinfo
operator|->
name|unread_marker
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Successfully processed marker, so reset state variable */
name|cinfo
operator|->
name|unread_marker
operator|=
literal|0
expr_stmt|;
block|}
comment|/* end loop */
block|}
end_block
begin_comment
comment|/*  * Read a restart marker, which is expected to appear next in the datastream;  * if the marker is not there, take appropriate recovery action.  * Returns FALSE if suspension is required.  *  * This is called by the entropy decoder after it has read an appropriate  * number of MCUs.  cinfo->unread_marker may be nonzero if the entropy decoder  * has already read a marker from the data source.  Under normal conditions  * cinfo->unread_marker will be reset to 0 before returning; if not reset,  * it holds a marker which the decoder will be unable to read past.  */
end_comment
begin_macro
DECL|function|METHODDEF
name|METHODDEF
argument_list|(
argument|boolean
argument_list|)
end_macro
begin_macro
name|read_restart_marker
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|)
end_macro
begin_block
block|{
comment|/* Obtain a marker unless we already did. */
comment|/* Note that next_marker will complain if it skips any data. */
if|if
condition|(
name|cinfo
operator|->
name|unread_marker
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|next_marker
argument_list|(
name|cinfo
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|cinfo
operator|->
name|unread_marker
operator|==
operator|(
operator|(
name|int
operator|)
name|M_RST0
operator|+
name|cinfo
operator|->
name|marker
operator|->
name|next_restart_num
operator|)
condition|)
block|{
comment|/* Normal case --- swallow the marker and let entropy decoder continue */
name|TRACEMS1
argument_list|(
name|cinfo
argument_list|,
literal|3
argument_list|,
name|JTRC_RST
argument_list|,
name|cinfo
operator|->
name|marker
operator|->
name|next_restart_num
argument_list|)
expr_stmt|;
name|cinfo
operator|->
name|unread_marker
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Uh-oh, the restart markers have been messed up. */
comment|/* Let the data source manager determine how to resync. */
if|if
condition|(
operator|!
call|(
modifier|*
name|cinfo
operator|->
name|src
operator|->
name|resync_to_restart
call|)
argument_list|(
name|cinfo
argument_list|,
name|cinfo
operator|->
name|marker
operator|->
name|next_restart_num
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* Update next-restart state */
name|cinfo
operator|->
name|marker
operator|->
name|next_restart_num
operator|=
operator|(
name|cinfo
operator|->
name|marker
operator|->
name|next_restart_num
operator|+
literal|1
operator|)
operator|&
literal|7
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_block
begin_comment
comment|/*  * This is the default resync_to_restart method for data source managers  * to use if they don't have any better approach.  Some data source managers  * may be able to back up, or may have additional knowledge about the data  * which permits a more intelligent recovery strategy; such managers would  * presumably supply their own resync method.  *  * read_restart_marker calls resync_to_restart if it finds a marker other than  * the restart marker it was expecting.  (This code is *not* used unless  * a nonzero restart interval has been declared.)  cinfo->unread_marker is  * the marker code actually found (might be anything, except 0 or FF).  * The desired restart marker number (0..7) is passed as a parameter.  * This routine is supposed to apply whatever error recovery strategy seems  * appropriate in order to position the input stream to the next data segment.  * Note that cinfo->unread_marker is treated as a marker appearing before  * the current data-source input point; usually it should be reset to zero  * before returning.  * Returns FALSE if suspension is required.  *  * This implementation is substantially constrained by wanting to treat the  * input as a data stream; this means we can't back up.  Therefore, we have  * only the following actions to work with:  *   1. Simply discard the marker and let the entropy decoder resume at next  *      byte of file.  *   2. Read forward until we find another marker, discarding intervening  *      data.  (In theory we could look ahead within the current bufferload,  *      without having to discard data if we don't find the desired marker.  *      This idea is not implemented here, in part because it makes behavior  *      dependent on buffer size and chance buffer-boundary positions.)  *   3. Leave the marker unread (by failing to zero cinfo->unread_marker).  *      This will cause the entropy decoder to process an empty data segment,  *      inserting dummy zeroes, and then we will reprocess the marker.  *  * #2 is appropriate if we think the desired marker lies ahead, while #3 is  * appropriate if the found marker is a future restart marker (indicating  * that we have missed the desired restart marker, probably because it got  * corrupted).  * We apply #2 or #3 if the found marker is a restart marker no more than  * two counts behind or ahead of the expected one.  We also apply #2 if the  * found marker is not a legal JPEG marker code (it's certainly bogus data).  * If the found marker is a restart marker more than 2 counts away, we do #1  * (too much risk that the marker is erroneous; with luck we will be able to  * resync at some future point).  * For any valid non-restart JPEG marker, we apply #3.  This keeps us from  * overrunning the end of a scan.  An implementation limited to single-scan  * files might find it better to apply #2 for markers other than EOI, since  * any other marker would have to be bogus data in that case.  */
end_comment
begin_macro
DECL|function|GLOBAL
name|GLOBAL
argument_list|(
argument|boolean
argument_list|)
end_macro
begin_macro
name|jpeg_resync_to_restart
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|,
argument|int desired
argument_list|)
end_macro
begin_block
block|{
name|int
name|marker
init|=
name|cinfo
operator|->
name|unread_marker
decl_stmt|;
name|int
name|action
init|=
literal|1
decl_stmt|;
comment|/* Always put up a warning. */
name|WARNMS2
argument_list|(
name|cinfo
argument_list|,
name|JWRN_MUST_RESYNC
argument_list|,
name|marker
argument_list|,
name|desired
argument_list|)
expr_stmt|;
comment|/* Outer loop handles repeated decision after scanning forward. */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|marker
operator|<
operator|(
name|int
operator|)
name|M_SOF0
condition|)
name|action
operator|=
literal|2
expr_stmt|;
comment|/* invalid marker */
elseif|else
if|if
condition|(
name|marker
operator|<
operator|(
name|int
operator|)
name|M_RST0
operator|||
name|marker
operator|>
operator|(
name|int
operator|)
name|M_RST7
condition|)
name|action
operator|=
literal|3
expr_stmt|;
comment|/* valid non-restart marker */
else|else
block|{
if|if
condition|(
name|marker
operator|==
operator|(
operator|(
name|int
operator|)
name|M_RST0
operator|+
operator|(
operator|(
name|desired
operator|+
literal|1
operator|)
operator|&
literal|7
operator|)
operator|)
operator|||
name|marker
operator|==
operator|(
operator|(
name|int
operator|)
name|M_RST0
operator|+
operator|(
operator|(
name|desired
operator|+
literal|2
operator|)
operator|&
literal|7
operator|)
operator|)
condition|)
name|action
operator|=
literal|3
expr_stmt|;
comment|/* one of the next two expected restarts */
elseif|else
if|if
condition|(
name|marker
operator|==
operator|(
operator|(
name|int
operator|)
name|M_RST0
operator|+
operator|(
operator|(
name|desired
operator|-
literal|1
operator|)
operator|&
literal|7
operator|)
operator|)
operator|||
name|marker
operator|==
operator|(
operator|(
name|int
operator|)
name|M_RST0
operator|+
operator|(
operator|(
name|desired
operator|-
literal|2
operator|)
operator|&
literal|7
operator|)
operator|)
condition|)
name|action
operator|=
literal|2
expr_stmt|;
comment|/* a prior restart, so advance */
else|else
name|action
operator|=
literal|1
expr_stmt|;
comment|/* desired restart or too far away */
block|}
name|TRACEMS2
argument_list|(
name|cinfo
argument_list|,
literal|4
argument_list|,
name|JTRC_RECOVERY_ACTION
argument_list|,
name|marker
argument_list|,
name|action
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|action
condition|)
block|{
case|case
literal|1
case|:
comment|/* Discard marker and let entropy decoder resume processing. */
name|cinfo
operator|->
name|unread_marker
operator|=
literal|0
expr_stmt|;
return|return
name|TRUE
return|;
case|case
literal|2
case|:
comment|/* Scan to the next marker, and repeat the decision loop. */
if|if
condition|(
operator|!
name|next_marker
argument_list|(
name|cinfo
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|marker
operator|=
name|cinfo
operator|->
name|unread_marker
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* Return without advancing past this marker. */
comment|/* Entropy decoder will be forced to process an empty segment. */
return|return
name|TRUE
return|;
block|}
block|}
comment|/* end loop */
block|}
end_block
begin_comment
comment|/*  * Reset marker processing state to begin a fresh datastream.  */
end_comment
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|reset_marker_reader
name|reset_marker_reader
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|)
end_macro
begin_block
block|{
name|my_marker_ptr
name|marker
init|=
operator|(
name|my_marker_ptr
operator|)
name|cinfo
operator|->
name|marker
decl_stmt|;
name|cinfo
operator|->
name|comp_info
operator|=
name|NULL
expr_stmt|;
comment|/* until allocated by get_sof */
name|cinfo
operator|->
name|input_scan_number
operator|=
literal|0
expr_stmt|;
comment|/* no SOS seen yet */
name|cinfo
operator|->
name|unread_marker
operator|=
literal|0
expr_stmt|;
comment|/* no pending marker */
name|marker
operator|->
name|pub
operator|.
name|saw_SOI
operator|=
name|FALSE
expr_stmt|;
comment|/* set internal state too */
name|marker
operator|->
name|pub
operator|.
name|saw_SOF
operator|=
name|FALSE
expr_stmt|;
name|marker
operator|->
name|pub
operator|.
name|discarded_bytes
operator|=
literal|0
expr_stmt|;
name|marker
operator|->
name|cur_marker
operator|=
name|NULL
expr_stmt|;
block|}
end_block
begin_comment
comment|/*  * Initialize the marker reader module.  * This is called only once, when the decompression object is created.  */
end_comment
begin_macro
name|GLOBAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|jinit_marker_reader
name|jinit_marker_reader
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|)
end_macro
begin_block
block|{
name|my_marker_ptr
name|marker
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Create subobject in permanent pool */
name|marker
operator|=
call|(
name|my_marker_ptr
call|)
argument_list|(
operator|*
name|cinfo
operator|->
name|mem
operator|->
name|alloc_small
argument_list|)
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|,
name|JPOOL_PERMANENT
argument_list|,
name|SIZEOF
argument_list|(
name|my_marker_reader
argument_list|)
argument_list|)
expr_stmt|;
name|cinfo
operator|->
name|marker
operator|=
operator|(
expr|struct
name|jpeg_marker_reader
operator|*
operator|)
name|marker
expr_stmt|;
comment|/* Initialize public method pointers */
name|marker
operator|->
name|pub
operator|.
name|reset_marker_reader
operator|=
name|reset_marker_reader
expr_stmt|;
name|marker
operator|->
name|pub
operator|.
name|read_markers
operator|=
name|read_markers
expr_stmt|;
name|marker
operator|->
name|pub
operator|.
name|read_restart_marker
operator|=
name|read_restart_marker
expr_stmt|;
comment|/* Initialize COM/APPn processing.    * By default, we examine and then discard APP0 and APP14,    * but simply discard COM and all other APPn.    */
name|marker
operator|->
name|process_COM
operator|=
name|skip_variable
expr_stmt|;
name|marker
operator|->
name|length_limit_COM
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|marker
operator|->
name|process_APPn
index|[
name|i
index|]
operator|=
name|skip_variable
expr_stmt|;
name|marker
operator|->
name|length_limit_APPn
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|marker
operator|->
name|process_APPn
index|[
literal|0
index|]
operator|=
name|get_interesting_appn
expr_stmt|;
name|marker
operator|->
name|process_APPn
index|[
literal|14
index|]
operator|=
name|get_interesting_appn
expr_stmt|;
comment|/* Reset marker processing state */
name|reset_marker_reader
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
block|}
end_block
begin_comment
comment|/*  * Control saving of COM and APPn markers into marker_list.  */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|SAVE_MARKERS_SUPPORTED
end_ifdef
begin_macro
name|GLOBAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|jpeg_save_markers
name|jpeg_save_markers
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|,
argument|int marker_code
argument_list|,
argument|unsigned int length_limit
argument_list|)
end_macro
begin_block
block|{
name|my_marker_ptr
name|marker
init|=
operator|(
name|my_marker_ptr
operator|)
name|cinfo
operator|->
name|marker
decl_stmt|;
name|long
name|maxlength
decl_stmt|;
name|jpeg_marker_parser_method
name|processor
decl_stmt|;
comment|/* Length limit mustn't be larger than what we can allocate    * (should only be a concern in a 16-bit environment).    */
name|maxlength
operator|=
name|cinfo
operator|->
name|mem
operator|->
name|max_alloc_chunk
operator|-
name|SIZEOF
argument_list|(
expr|struct
name|jpeg_marker_struct
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|long
operator|)
name|length_limit
operator|)
operator|>
name|maxlength
condition|)
name|length_limit
operator|=
operator|(
name|unsigned
name|int
operator|)
name|maxlength
expr_stmt|;
comment|/* Choose processor routine to use.    * APP0/APP14 have special requirements.    */
if|if
condition|(
name|length_limit
condition|)
block|{
name|processor
operator|=
name|save_marker
expr_stmt|;
comment|/* If saving APP0/APP14, save at least enough for our internal use. */
if|if
condition|(
name|marker_code
operator|==
operator|(
name|int
operator|)
name|M_APP0
operator|&&
name|length_limit
operator|<
name|APP0_DATA_LEN
condition|)
name|length_limit
operator|=
name|APP0_DATA_LEN
expr_stmt|;
elseif|else
if|if
condition|(
name|marker_code
operator|==
operator|(
name|int
operator|)
name|M_APP14
operator|&&
name|length_limit
operator|<
name|APP14_DATA_LEN
condition|)
name|length_limit
operator|=
name|APP14_DATA_LEN
expr_stmt|;
block|}
else|else
block|{
name|processor
operator|=
name|skip_variable
expr_stmt|;
comment|/* If discarding APP0/APP14, use our regular on-the-fly processor. */
if|if
condition|(
name|marker_code
operator|==
operator|(
name|int
operator|)
name|M_APP0
operator|||
name|marker_code
operator|==
operator|(
name|int
operator|)
name|M_APP14
condition|)
name|processor
operator|=
name|get_interesting_appn
expr_stmt|;
block|}
if|if
condition|(
name|marker_code
operator|==
operator|(
name|int
operator|)
name|M_COM
condition|)
block|{
name|marker
operator|->
name|process_COM
operator|=
name|processor
expr_stmt|;
name|marker
operator|->
name|length_limit_COM
operator|=
name|length_limit
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|marker_code
operator|>=
operator|(
name|int
operator|)
name|M_APP0
operator|&&
name|marker_code
operator|<=
operator|(
name|int
operator|)
name|M_APP15
condition|)
block|{
name|marker
operator|->
name|process_APPn
index|[
name|marker_code
operator|-
operator|(
name|int
operator|)
name|M_APP0
index|]
operator|=
name|processor
expr_stmt|;
name|marker
operator|->
name|length_limit_APPn
index|[
name|marker_code
operator|-
operator|(
name|int
operator|)
name|M_APP0
index|]
operator|=
name|length_limit
expr_stmt|;
block|}
else|else
name|ERREXIT1
argument_list|(
name|cinfo
argument_list|,
name|JERR_UNKNOWN_MARKER
argument_list|,
name|marker_code
argument_list|)
expr_stmt|;
block|}
end_block
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* SAVE_MARKERS_SUPPORTED */
end_comment
begin_comment
comment|/*  * Install a special processing method for COM or APPn markers.  */
end_comment
begin_macro
name|GLOBAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|jpeg_set_marker_processor
name|jpeg_set_marker_processor
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|,
argument|int marker_code
argument_list|,
argument|jpeg_marker_parser_method routine
argument_list|)
end_macro
begin_block
block|{
name|my_marker_ptr
name|marker
init|=
operator|(
name|my_marker_ptr
operator|)
name|cinfo
operator|->
name|marker
decl_stmt|;
if|if
condition|(
name|marker_code
operator|==
operator|(
name|int
operator|)
name|M_COM
condition|)
name|marker
operator|->
name|process_COM
operator|=
name|routine
expr_stmt|;
elseif|else
if|if
condition|(
name|marker_code
operator|>=
operator|(
name|int
operator|)
name|M_APP0
operator|&&
name|marker_code
operator|<=
operator|(
name|int
operator|)
name|M_APP15
condition|)
name|marker
operator|->
name|process_APPn
index|[
name|marker_code
operator|-
operator|(
name|int
operator|)
name|M_APP0
index|]
operator|=
name|routine
expr_stmt|;
else|else
name|ERREXIT1
argument_list|(
name|cinfo
argument_list|,
name|JERR_UNKNOWN_MARKER
argument_list|,
name|marker_code
argument_list|)
expr_stmt|;
block|}
end_block
end_unit
