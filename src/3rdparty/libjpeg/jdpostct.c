begin_unit
begin_comment
comment|/*  * jdpostct.c  *  * Copyright (C) 1994-1996, Thomas G. Lane.  * This file is part of the Independent JPEG Group's software.  * For conditions of distribution and use, see the accompanying README file.  *  * This file contains the decompression postprocessing controller.  * This controller manages the upsampling, color conversion, and color  * quantization/reduction steps; specifically, it controls the buffering  * between upsample/color conversion and color quantization/reduction.  *  * If no color quantization/reduction is required, then this module has no  * work to do, and it just hands off to the upsample/color conversion code.  * An integrated upsample/convert/quantize process would replace this module  * entirely.  */
end_comment
begin_define
DECL|macro|JPEG_INTERNALS
define|#
directive|define
name|JPEG_INTERNALS
end_define
begin_include
include|#
directive|include
file|"jinclude.h"
end_include
begin_include
include|#
directive|include
file|"jpeglib.h"
end_include
begin_comment
comment|/* Private buffer controller object */
end_comment
begin_typedef
typedef|typedef
struct|struct
block|{
DECL|member|pub
name|struct
name|jpeg_d_post_controller
name|pub
decl_stmt|;
comment|/* public fields */
comment|/* Color quantization source buffer: this holds output data from    * the upsample/color conversion step to be passed to the quantizer.    * For two-pass color quantization, we need a full-image buffer;    * for one-pass operation, a strip buffer is sufficient.    */
DECL|member|whole_image
name|jvirt_sarray_ptr
name|whole_image
decl_stmt|;
comment|/* virtual array, or NULL if one-pass */
DECL|member|buffer
name|JSAMPARRAY
name|buffer
decl_stmt|;
comment|/* strip buffer, or current strip of virtual */
DECL|member|strip_height
name|JDIMENSION
name|strip_height
decl_stmt|;
comment|/* buffer size in rows */
comment|/* for two-pass mode only: */
DECL|member|starting_row
name|JDIMENSION
name|starting_row
decl_stmt|;
comment|/* row # of first row in current strip */
DECL|member|next_row
name|JDIMENSION
name|next_row
decl_stmt|;
comment|/* index of next row to fill/empty in strip */
block|}
DECL|typedef|my_post_controller
name|my_post_controller
typedef|;
end_typedef
begin_typedef
DECL|typedef|my_post_ptr
typedef|typedef
name|my_post_controller
modifier|*
name|my_post_ptr
typedef|;
end_typedef
begin_comment
comment|/* Forward declarations */
end_comment
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_decl_stmt
name|post_process_1pass
name|JPP
argument_list|(
operator|(
name|j_decompress_ptr
name|cinfo
operator|,
name|JSAMPIMAGE
name|input_buf
operator|,
name|JDIMENSION
operator|*
name|in_row_group_ctr
operator|,
name|JDIMENSION
name|in_row_groups_avail
operator|,
name|JSAMPARRAY
name|output_buf
operator|,
name|JDIMENSION
operator|*
name|out_row_ctr
operator|,
name|JDIMENSION
name|out_rows_avail
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt
begin_ifdef
ifdef|#
directive|ifdef
name|QUANT_2PASS_SUPPORTED
end_ifdef
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_decl_stmt
name|post_process_prepass
name|JPP
argument_list|(
operator|(
name|j_decompress_ptr
name|cinfo
operator|,
name|JSAMPIMAGE
name|input_buf
operator|,
name|JDIMENSION
operator|*
name|in_row_group_ctr
operator|,
name|JDIMENSION
name|in_row_groups_avail
operator|,
name|JSAMPARRAY
name|output_buf
operator|,
name|JDIMENSION
operator|*
name|out_row_ctr
operator|,
name|JDIMENSION
name|out_rows_avail
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_decl_stmt
name|post_process_2pass
name|JPP
argument_list|(
operator|(
name|j_decompress_ptr
name|cinfo
operator|,
name|JSAMPIMAGE
name|input_buf
operator|,
name|JDIMENSION
operator|*
name|in_row_group_ctr
operator|,
name|JDIMENSION
name|in_row_groups_avail
operator|,
name|JSAMPARRAY
name|output_buf
operator|,
name|JDIMENSION
operator|*
name|out_row_ctr
operator|,
name|JDIMENSION
name|out_rows_avail
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*  * Initialize for a processing pass.  */
end_comment
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|start_pass_dpost
name|start_pass_dpost
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|,
argument|J_BUF_MODE pass_mode
argument_list|)
end_macro
begin_block
block|{
name|my_post_ptr
name|post
init|=
operator|(
name|my_post_ptr
operator|)
name|cinfo
operator|->
name|post
decl_stmt|;
switch|switch
condition|(
name|pass_mode
condition|)
block|{
case|case
name|JBUF_PASS_THRU
case|:
if|if
condition|(
name|cinfo
operator|->
name|quantize_colors
condition|)
block|{
comment|/* Single-pass processing with color quantization. */
name|post
operator|->
name|pub
operator|.
name|post_process_data
operator|=
name|post_process_1pass
expr_stmt|;
comment|/* We could be doing buffered-image output before starting a 2-pass        * color quantization; in that case, jinit_d_post_controller did not        * allocate a strip buffer.  Use the virtual-array buffer as workspace.        */
if|if
condition|(
name|post
operator|->
name|buffer
operator|==
name|NULL
condition|)
block|{
name|post
operator|->
name|buffer
operator|=
call|(
modifier|*
name|cinfo
operator|->
name|mem
operator|->
name|access_virt_sarray
call|)
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|,
name|post
operator|->
name|whole_image
argument_list|,
operator|(
name|JDIMENSION
operator|)
literal|0
argument_list|,
name|post
operator|->
name|strip_height
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* For single-pass processing without color quantization,        * I have no work to do; just call the upsampler directly.        */
name|post
operator|->
name|pub
operator|.
name|post_process_data
operator|=
name|cinfo
operator|->
name|upsample
operator|->
name|upsample
expr_stmt|;
block|}
break|break;
ifdef|#
directive|ifdef
name|QUANT_2PASS_SUPPORTED
case|case
name|JBUF_SAVE_AND_PASS
case|:
comment|/* First pass of 2-pass quantization */
if|if
condition|(
name|post
operator|->
name|whole_image
operator|==
name|NULL
condition|)
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_BUFFER_MODE
argument_list|)
expr_stmt|;
name|post
operator|->
name|pub
operator|.
name|post_process_data
operator|=
name|post_process_prepass
expr_stmt|;
break|break;
case|case
name|JBUF_CRANK_DEST
case|:
comment|/* Second pass of 2-pass quantization */
if|if
condition|(
name|post
operator|->
name|whole_image
operator|==
name|NULL
condition|)
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_BUFFER_MODE
argument_list|)
expr_stmt|;
name|post
operator|->
name|pub
operator|.
name|post_process_data
operator|=
name|post_process_2pass
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* QUANT_2PASS_SUPPORTED */
default|default:
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_BUFFER_MODE
argument_list|)
expr_stmt|;
break|break;
block|}
name|post
operator|->
name|starting_row
operator|=
name|post
operator|->
name|next_row
operator|=
literal|0
expr_stmt|;
block|}
end_block
begin_comment
comment|/*  * Process some data in the one-pass (strip buffer) case.  * This is used for color precision reduction as well as one-pass quantization.  */
end_comment
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|post_process_1pass
name|post_process_1pass
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|,
argument|JSAMPIMAGE input_buf
argument_list|,
argument|JDIMENSION *in_row_group_ctr
argument_list|,
argument|JDIMENSION in_row_groups_avail
argument_list|,
argument|JSAMPARRAY output_buf
argument_list|,
argument|JDIMENSION *out_row_ctr
argument_list|,
argument|JDIMENSION out_rows_avail
argument_list|)
end_macro
begin_block
block|{
name|my_post_ptr
name|post
init|=
operator|(
name|my_post_ptr
operator|)
name|cinfo
operator|->
name|post
decl_stmt|;
name|JDIMENSION
name|num_rows
decl_stmt|,
name|max_rows
decl_stmt|;
comment|/* Fill the buffer, but not more than what we can dump out in one go. */
comment|/* Note we rely on the upsampler to detect bottom of image. */
name|max_rows
operator|=
name|out_rows_avail
operator|-
operator|*
name|out_row_ctr
expr_stmt|;
if|if
condition|(
name|max_rows
operator|>
name|post
operator|->
name|strip_height
condition|)
name|max_rows
operator|=
name|post
operator|->
name|strip_height
expr_stmt|;
name|num_rows
operator|=
literal|0
expr_stmt|;
call|(
modifier|*
name|cinfo
operator|->
name|upsample
operator|->
name|upsample
call|)
argument_list|(
name|cinfo
argument_list|,
name|input_buf
argument_list|,
name|in_row_group_ctr
argument_list|,
name|in_row_groups_avail
argument_list|,
name|post
operator|->
name|buffer
argument_list|,
operator|&
name|num_rows
argument_list|,
name|max_rows
argument_list|)
expr_stmt|;
comment|/* Quantize and emit data. */
call|(
modifier|*
name|cinfo
operator|->
name|cquantize
operator|->
name|color_quantize
call|)
argument_list|(
name|cinfo
argument_list|,
name|post
operator|->
name|buffer
argument_list|,
name|output_buf
operator|+
operator|*
name|out_row_ctr
argument_list|,
operator|(
name|int
operator|)
name|num_rows
argument_list|)
expr_stmt|;
operator|*
name|out_row_ctr
operator|+=
name|num_rows
expr_stmt|;
block|}
end_block
begin_ifdef
ifdef|#
directive|ifdef
name|QUANT_2PASS_SUPPORTED
end_ifdef
begin_comment
comment|/*  * Process some data in the first pass of 2-pass quantization.  */
end_comment
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|post_process_prepass
name|post_process_prepass
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|,
argument|JSAMPIMAGE input_buf
argument_list|,
argument|JDIMENSION *in_row_group_ctr
argument_list|,
argument|JDIMENSION in_row_groups_avail
argument_list|,
argument|JSAMPARRAY output_buf
argument_list|,
argument|JDIMENSION *out_row_ctr
argument_list|,
argument|JDIMENSION out_rows_avail
argument_list|)
end_macro
begin_block
block|{
name|my_post_ptr
name|post
init|=
operator|(
name|my_post_ptr
operator|)
name|cinfo
operator|->
name|post
decl_stmt|;
name|JDIMENSION
name|old_next_row
decl_stmt|,
name|num_rows
decl_stmt|;
comment|/* Reposition virtual buffer if at start of strip. */
if|if
condition|(
name|post
operator|->
name|next_row
operator|==
literal|0
condition|)
block|{
name|post
operator|->
name|buffer
operator|=
call|(
modifier|*
name|cinfo
operator|->
name|mem
operator|->
name|access_virt_sarray
call|)
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|,
name|post
operator|->
name|whole_image
argument_list|,
name|post
operator|->
name|starting_row
argument_list|,
name|post
operator|->
name|strip_height
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
comment|/* Upsample some data (up to a strip height's worth). */
name|old_next_row
operator|=
name|post
operator|->
name|next_row
expr_stmt|;
call|(
modifier|*
name|cinfo
operator|->
name|upsample
operator|->
name|upsample
call|)
argument_list|(
name|cinfo
argument_list|,
name|input_buf
argument_list|,
name|in_row_group_ctr
argument_list|,
name|in_row_groups_avail
argument_list|,
name|post
operator|->
name|buffer
argument_list|,
operator|&
name|post
operator|->
name|next_row
argument_list|,
name|post
operator|->
name|strip_height
argument_list|)
expr_stmt|;
comment|/* Allow quantizer to scan new data.  No data is emitted, */
comment|/* but we advance out_row_ctr so outer loop can tell when we're done. */
if|if
condition|(
name|post
operator|->
name|next_row
operator|>
name|old_next_row
condition|)
block|{
name|num_rows
operator|=
name|post
operator|->
name|next_row
operator|-
name|old_next_row
expr_stmt|;
call|(
modifier|*
name|cinfo
operator|->
name|cquantize
operator|->
name|color_quantize
call|)
argument_list|(
name|cinfo
argument_list|,
name|post
operator|->
name|buffer
operator|+
name|old_next_row
argument_list|,
operator|(
name|JSAMPARRAY
operator|)
name|NULL
argument_list|,
operator|(
name|int
operator|)
name|num_rows
argument_list|)
expr_stmt|;
operator|*
name|out_row_ctr
operator|+=
name|num_rows
expr_stmt|;
block|}
comment|/* Advance if we filled the strip. */
if|if
condition|(
name|post
operator|->
name|next_row
operator|>=
name|post
operator|->
name|strip_height
condition|)
block|{
name|post
operator|->
name|starting_row
operator|+=
name|post
operator|->
name|strip_height
expr_stmt|;
name|post
operator|->
name|next_row
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block
begin_comment
comment|/*  * Process some data in the second pass of 2-pass quantization.  */
end_comment
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|post_process_2pass
name|post_process_2pass
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|,
argument|JSAMPIMAGE input_buf
argument_list|,
argument|JDIMENSION *in_row_group_ctr
argument_list|,
argument|JDIMENSION in_row_groups_avail
argument_list|,
argument|JSAMPARRAY output_buf
argument_list|,
argument|JDIMENSION *out_row_ctr
argument_list|,
argument|JDIMENSION out_rows_avail
argument_list|)
end_macro
begin_block
block|{
name|my_post_ptr
name|post
init|=
operator|(
name|my_post_ptr
operator|)
name|cinfo
operator|->
name|post
decl_stmt|;
name|JDIMENSION
name|num_rows
decl_stmt|,
name|max_rows
decl_stmt|;
comment|/* Reposition virtual buffer if at start of strip. */
if|if
condition|(
name|post
operator|->
name|next_row
operator|==
literal|0
condition|)
block|{
name|post
operator|->
name|buffer
operator|=
call|(
modifier|*
name|cinfo
operator|->
name|mem
operator|->
name|access_virt_sarray
call|)
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|,
name|post
operator|->
name|whole_image
argument_list|,
name|post
operator|->
name|starting_row
argument_list|,
name|post
operator|->
name|strip_height
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* Determine number of rows to emit. */
name|num_rows
operator|=
name|post
operator|->
name|strip_height
operator|-
name|post
operator|->
name|next_row
expr_stmt|;
comment|/* available in strip */
name|max_rows
operator|=
name|out_rows_avail
operator|-
operator|*
name|out_row_ctr
expr_stmt|;
comment|/* available in output area */
if|if
condition|(
name|num_rows
operator|>
name|max_rows
condition|)
name|num_rows
operator|=
name|max_rows
expr_stmt|;
comment|/* We have to check bottom of image here, can't depend on upsampler. */
name|max_rows
operator|=
name|cinfo
operator|->
name|output_height
operator|-
name|post
operator|->
name|starting_row
expr_stmt|;
if|if
condition|(
name|num_rows
operator|>
name|max_rows
condition|)
name|num_rows
operator|=
name|max_rows
expr_stmt|;
comment|/* Quantize and emit data. */
call|(
modifier|*
name|cinfo
operator|->
name|cquantize
operator|->
name|color_quantize
call|)
argument_list|(
name|cinfo
argument_list|,
name|post
operator|->
name|buffer
operator|+
name|post
operator|->
name|next_row
argument_list|,
name|output_buf
operator|+
operator|*
name|out_row_ctr
argument_list|,
operator|(
name|int
operator|)
name|num_rows
argument_list|)
expr_stmt|;
operator|*
name|out_row_ctr
operator|+=
name|num_rows
expr_stmt|;
comment|/* Advance if we filled the strip. */
name|post
operator|->
name|next_row
operator|+=
name|num_rows
expr_stmt|;
if|if
condition|(
name|post
operator|->
name|next_row
operator|>=
name|post
operator|->
name|strip_height
condition|)
block|{
name|post
operator|->
name|starting_row
operator|+=
name|post
operator|->
name|strip_height
expr_stmt|;
name|post
operator|->
name|next_row
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* QUANT_2PASS_SUPPORTED */
end_comment
begin_comment
comment|/*  * Initialize postprocessing controller.  */
end_comment
begin_macro
name|GLOBAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|jinit_d_post_controller
name|jinit_d_post_controller
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|,
argument|boolean need_full_buffer
argument_list|)
end_macro
begin_block
block|{
name|my_post_ptr
name|post
decl_stmt|;
name|post
operator|=
call|(
name|my_post_ptr
call|)
argument_list|(
operator|*
name|cinfo
operator|->
name|mem
operator|->
name|alloc_small
argument_list|)
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|,
name|JPOOL_IMAGE
argument_list|,
name|SIZEOF
argument_list|(
name|my_post_controller
argument_list|)
argument_list|)
expr_stmt|;
name|cinfo
operator|->
name|post
operator|=
operator|(
expr|struct
name|jpeg_d_post_controller
operator|*
operator|)
name|post
expr_stmt|;
name|post
operator|->
name|pub
operator|.
name|start_pass
operator|=
name|start_pass_dpost
expr_stmt|;
name|post
operator|->
name|whole_image
operator|=
name|NULL
expr_stmt|;
comment|/* flag for no virtual arrays */
name|post
operator|->
name|buffer
operator|=
name|NULL
expr_stmt|;
comment|/* flag for no strip buffer */
comment|/* Create the quantization buffer, if needed */
if|if
condition|(
name|cinfo
operator|->
name|quantize_colors
condition|)
block|{
comment|/* The buffer strip height is max_v_samp_factor, which is typically      * an efficient number of rows for upsampling to return.      * (In the presence of output rescaling, we might want to be smarter?)      */
name|post
operator|->
name|strip_height
operator|=
operator|(
name|JDIMENSION
operator|)
name|cinfo
operator|->
name|max_v_samp_factor
expr_stmt|;
if|if
condition|(
name|need_full_buffer
condition|)
block|{
comment|/* Two-pass color quantization: need full-image storage. */
comment|/* We round up the number of rows to a multiple of the strip height. */
ifdef|#
directive|ifdef
name|QUANT_2PASS_SUPPORTED
name|post
operator|->
name|whole_image
operator|=
call|(
modifier|*
name|cinfo
operator|->
name|mem
operator|->
name|request_virt_sarray
call|)
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|,
name|JPOOL_IMAGE
argument_list|,
name|FALSE
argument_list|,
name|cinfo
operator|->
name|output_width
operator|*
name|cinfo
operator|->
name|out_color_components
argument_list|,
operator|(
name|JDIMENSION
operator|)
name|jround_up
argument_list|(
operator|(
name|long
operator|)
name|cinfo
operator|->
name|output_height
argument_list|,
operator|(
name|long
operator|)
name|post
operator|->
name|strip_height
argument_list|)
argument_list|,
name|post
operator|->
name|strip_height
argument_list|)
expr_stmt|;
else|#
directive|else
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_BUFFER_MODE
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* QUANT_2PASS_SUPPORTED */
block|}
else|else
block|{
comment|/* One-pass color quantization: just make a strip buffer. */
name|post
operator|->
name|buffer
operator|=
call|(
modifier|*
name|cinfo
operator|->
name|mem
operator|->
name|alloc_sarray
call|)
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|,
name|JPOOL_IMAGE
argument_list|,
name|cinfo
operator|->
name|output_width
operator|*
name|cinfo
operator|->
name|out_color_components
argument_list|,
name|post
operator|->
name|strip_height
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block
end_unit
