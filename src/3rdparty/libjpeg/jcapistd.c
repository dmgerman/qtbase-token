begin_unit
begin_comment
comment|/*  * jcapistd.c  *  * Copyright (C) 1994-1996, Thomas G. Lane.  * This file is part of the Independent JPEG Group's software.  * For conditions of distribution and use, see the accompanying README file.  *  * This file contains application interface code for the compression half  * of the JPEG library.  These are the "standard" API routines that are  * used in the normal full-compression case.  They are not used by a  * transcoding-only application.  Note that if an application links in  * jpeg_start_compress, it will end up linking in the entire compressor.  * We thus must separate this file from jcapimin.c to avoid linking the  * whole compression library into a transcoder.  */
end_comment
begin_define
DECL|macro|JPEG_INTERNALS
define|#
directive|define
name|JPEG_INTERNALS
end_define
begin_include
include|#
directive|include
file|"jinclude.h"
end_include
begin_include
include|#
directive|include
file|"jpeglib.h"
end_include
begin_comment
comment|/*  * Compression initialization.  * Before calling this, all parameters and a data destination must be set up.  *  * We require a write_all_tables parameter as a failsafe check when writing  * multiple datastreams from the same compression object.  Since prior runs  * will have left all the tables marked sent_table=TRUE, a subsequent run  * would emit an abbreviated stream (no tables) by default.  This may be what  * is wanted, but for safety's sake it should not be the default behavior:  * programmers should have to make a deliberate choice to emit abbreviated  * images.  Therefore the documentation and examples should encourage people  * to pass write_all_tables=TRUE; then it will take active thought to do the  * wrong thing.  */
end_comment
begin_macro
name|GLOBAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|jpeg_start_compress
name|jpeg_start_compress
argument_list|(
argument|j_compress_ptr cinfo
argument_list|,
argument|boolean write_all_tables
argument_list|)
end_macro
begin_block
block|{
if|if
condition|(
name|cinfo
operator|->
name|global_state
operator|!=
name|CSTATE_START
condition|)
name|ERREXIT1
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_STATE
argument_list|,
name|cinfo
operator|->
name|global_state
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_all_tables
condition|)
name|jpeg_suppress_tables
argument_list|(
name|cinfo
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* mark all tables to be written */
comment|/* (Re)initialize error mgr and destination modules */
call|(
modifier|*
name|cinfo
operator|->
name|err
operator|->
name|reset_error_mgr
call|)
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|)
expr_stmt|;
call|(
modifier|*
name|cinfo
operator|->
name|dest
operator|->
name|init_destination
call|)
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
comment|/* Perform master selection of active modules */
name|jinit_compress_master
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
comment|/* Set up for the first pass */
call|(
modifier|*
name|cinfo
operator|->
name|master
operator|->
name|prepare_for_pass
call|)
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
comment|/* Ready for application to drive first pass through jpeg_write_scanlines    * or jpeg_write_raw_data.    */
name|cinfo
operator|->
name|next_scanline
operator|=
literal|0
expr_stmt|;
name|cinfo
operator|->
name|global_state
operator|=
operator|(
name|cinfo
operator|->
name|raw_data_in
condition|?
name|CSTATE_RAW_OK
else|:
name|CSTATE_SCANNING
operator|)
expr_stmt|;
block|}
end_block
begin_comment
comment|/*  * Write some scanlines of data to the JPEG compressor.  *  * The return value will be the number of lines actually written.  * This should be less than the supplied num_lines only in case that  * the data destination module has requested suspension of the compressor,  * or if more than image_height scanlines are passed in.  *  * Note: we warn about excess calls to jpeg_write_scanlines() since  * this likely signals an application programmer error.  However,  * excess scanlines passed in the last valid call are *silently* ignored,  * so that the application need not adjust num_lines for end-of-image  * when using a multiple-scanline buffer.  */
end_comment
begin_macro
DECL|function|GLOBAL
name|GLOBAL
argument_list|(
argument|JDIMENSION
argument_list|)
end_macro
begin_macro
name|jpeg_write_scanlines
argument_list|(
argument|j_compress_ptr cinfo
argument_list|,
argument|JSAMPARRAY scanlines
argument_list|,
argument|JDIMENSION num_lines
argument_list|)
end_macro
begin_block
block|{
name|JDIMENSION
name|row_ctr
decl_stmt|,
name|rows_left
decl_stmt|;
if|if
condition|(
name|cinfo
operator|->
name|global_state
operator|!=
name|CSTATE_SCANNING
condition|)
name|ERREXIT1
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_STATE
argument_list|,
name|cinfo
operator|->
name|global_state
argument_list|)
expr_stmt|;
if|if
condition|(
name|cinfo
operator|->
name|next_scanline
operator|>=
name|cinfo
operator|->
name|image_height
condition|)
name|WARNMS
argument_list|(
name|cinfo
argument_list|,
name|JWRN_TOO_MUCH_DATA
argument_list|)
expr_stmt|;
comment|/* Call progress monitor hook if present */
if|if
condition|(
name|cinfo
operator|->
name|progress
operator|!=
name|NULL
condition|)
block|{
name|cinfo
operator|->
name|progress
operator|->
name|pass_counter
operator|=
operator|(
name|long
operator|)
name|cinfo
operator|->
name|next_scanline
expr_stmt|;
name|cinfo
operator|->
name|progress
operator|->
name|pass_limit
operator|=
operator|(
name|long
operator|)
name|cinfo
operator|->
name|image_height
expr_stmt|;
call|(
modifier|*
name|cinfo
operator|->
name|progress
operator|->
name|progress_monitor
call|)
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|)
expr_stmt|;
block|}
comment|/* Give master control module another chance if this is first call to    * jpeg_write_scanlines.  This lets output of the frame/scan headers be    * delayed so that application can write COM, etc, markers between    * jpeg_start_compress and jpeg_write_scanlines.    */
if|if
condition|(
name|cinfo
operator|->
name|master
operator|->
name|call_pass_startup
condition|)
call|(
modifier|*
name|cinfo
operator|->
name|master
operator|->
name|pass_startup
call|)
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
comment|/* Ignore any extra scanlines at bottom of image. */
name|rows_left
operator|=
name|cinfo
operator|->
name|image_height
operator|-
name|cinfo
operator|->
name|next_scanline
expr_stmt|;
if|if
condition|(
name|num_lines
operator|>
name|rows_left
condition|)
name|num_lines
operator|=
name|rows_left
expr_stmt|;
name|row_ctr
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|cinfo
operator|->
expr|main
operator|->
name|process_data
operator|)
operator|(
name|cinfo
operator|,
name|scanlines
operator|,
operator|&
name|row_ctr
operator|,
name|num_lines
operator|)
expr_stmt|;
name|cinfo
operator|->
name|next_scanline
operator|+=
name|row_ctr
expr_stmt|;
return|return
name|row_ctr
return|;
block|}
end_block
begin_comment
comment|/*  * Alternate entry point to write raw data.  * Processes exactly one iMCU row per call, unless suspended.  */
end_comment
begin_macro
DECL|function|GLOBAL
name|GLOBAL
argument_list|(
argument|JDIMENSION
argument_list|)
end_macro
begin_macro
name|jpeg_write_raw_data
argument_list|(
argument|j_compress_ptr cinfo
argument_list|,
argument|JSAMPIMAGE data
argument_list|,
argument|JDIMENSION num_lines
argument_list|)
end_macro
begin_block
block|{
name|JDIMENSION
name|lines_per_iMCU_row
decl_stmt|;
if|if
condition|(
name|cinfo
operator|->
name|global_state
operator|!=
name|CSTATE_RAW_OK
condition|)
name|ERREXIT1
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_STATE
argument_list|,
name|cinfo
operator|->
name|global_state
argument_list|)
expr_stmt|;
if|if
condition|(
name|cinfo
operator|->
name|next_scanline
operator|>=
name|cinfo
operator|->
name|image_height
condition|)
block|{
name|WARNMS
argument_list|(
name|cinfo
argument_list|,
name|JWRN_TOO_MUCH_DATA
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Call progress monitor hook if present */
if|if
condition|(
name|cinfo
operator|->
name|progress
operator|!=
name|NULL
condition|)
block|{
name|cinfo
operator|->
name|progress
operator|->
name|pass_counter
operator|=
operator|(
name|long
operator|)
name|cinfo
operator|->
name|next_scanline
expr_stmt|;
name|cinfo
operator|->
name|progress
operator|->
name|pass_limit
operator|=
operator|(
name|long
operator|)
name|cinfo
operator|->
name|image_height
expr_stmt|;
call|(
modifier|*
name|cinfo
operator|->
name|progress
operator|->
name|progress_monitor
call|)
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|)
expr_stmt|;
block|}
comment|/* Give master control module another chance if this is first call to    * jpeg_write_raw_data.  This lets output of the frame/scan headers be    * delayed so that application can write COM, etc, markers between    * jpeg_start_compress and jpeg_write_raw_data.    */
if|if
condition|(
name|cinfo
operator|->
name|master
operator|->
name|call_pass_startup
condition|)
call|(
modifier|*
name|cinfo
operator|->
name|master
operator|->
name|pass_startup
call|)
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
comment|/* Verify that at least one iMCU row has been passed. */
name|lines_per_iMCU_row
operator|=
name|cinfo
operator|->
name|max_v_samp_factor
operator|*
name|DCTSIZE
expr_stmt|;
if|if
condition|(
name|num_lines
operator|<
name|lines_per_iMCU_row
condition|)
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_BUFFER_SIZE
argument_list|)
expr_stmt|;
comment|/* Directly compress the row. */
if|if
condition|(
operator|!
call|(
modifier|*
name|cinfo
operator|->
name|coef
operator|->
name|compress_data
call|)
argument_list|(
name|cinfo
argument_list|,
name|data
argument_list|)
condition|)
block|{
comment|/* If compressor did not consume the whole row, suspend processing. */
return|return
literal|0
return|;
block|}
comment|/* OK, we processed one iMCU row. */
name|cinfo
operator|->
name|next_scanline
operator|+=
name|lines_per_iMCU_row
expr_stmt|;
return|return
name|lines_per_iMCU_row
return|;
block|}
end_block
end_unit
