begin_unit
begin_comment
comment|/*  * jerror.c  *  * Copyright (C) 1991-1998, Thomas G. Lane.  * This file is part of the Independent JPEG Group's software.  * For conditions of distribution and use, see the accompanying README file.  *  * This file contains simple error-reporting and trace-message routines.  * These are suitable for Unix-like systems and others where writing to  * stderr is the right thing to do.  Many applications will want to replace  * some or all of these routines.  *  * If you define USE_WINDOWS_MESSAGEBOX in jconfig.h or in the makefile,  * you get a Windows-specific hack to display error messages in a dialog box.  * It ain't much, but it beats dropping error messages into the bit bucket,  * which is what happens to output to stderr under most Windows C compilers.  *  * These routines are used by both the compression and decompression code.  */
end_comment
begin_comment
comment|/* this is not a core library module, so it doesn't define JPEG_INTERNALS */
end_comment
begin_include
include|#
directive|include
file|"jinclude.h"
end_include
begin_include
include|#
directive|include
file|"jpeglib.h"
end_include
begin_include
include|#
directive|include
file|"jversion.h"
end_include
begin_include
include|#
directive|include
file|"jerror.h"
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|USE_WINDOWS_MESSAGEBOX
end_ifdef
begin_include
include|#
directive|include
file|<windows.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|EXIT_FAILURE
end_ifndef
begin_comment
comment|/* define exit() codes if not provided */
end_comment
begin_define
DECL|macro|EXIT_FAILURE
define|#
directive|define
name|EXIT_FAILURE
value|1
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*  * Create the message string table.  * We do this from the master message list in jerror.h by re-reading  * jerror.h with a suitable definition for macro JMESSAGE.  * The message table is made an external symbol just in case any applications  * want to refer to it directly.  */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|NEED_SHORT_EXTERNAL_NAMES
end_ifdef
begin_define
DECL|macro|jpeg_std_message_table
define|#
directive|define
name|jpeg_std_message_table
value|jMsgTable
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|JMESSAGE
define|#
directive|define
name|JMESSAGE
parameter_list|(
name|code
parameter_list|,
name|string
parameter_list|)
value|string ,
end_define
begin_decl_stmt
DECL|variable|jpeg_std_message_table
specifier|const
name|char
modifier|*
specifier|const
name|jpeg_std_message_table
index|[]
init|=
block|{
include|#
directive|include
file|"jerror.h"
name|NULL
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*  * Error exit handler: must not return to caller.  *  * Applications may override this if they want to get control back after  * an error.  Typically one would longjmp somewhere instead of exiting.  * The setjmp buffer can be made a private field within an expanded error  * handler object.  Note that the info needed to generate an error message  * is stored in the error object, so you can generate the message now or  * later, at your convenience.  * You should make sure that the JPEG object is cleaned up (with jpeg_abort  * or jpeg_destroy) at some point.  */
end_comment
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|error_exit
name|error_exit
argument_list|(
argument|j_common_ptr cinfo
argument_list|)
end_macro
begin_block
block|{
comment|/* Always display the message */
call|(
modifier|*
name|cinfo
operator|->
name|err
operator|->
name|output_message
call|)
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
comment|/* Let the memory manager delete any temp files before we die */
name|jpeg_destroy
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
end_block
begin_comment
comment|/*  * Actual output of an error or trace message.  * Applications may override this method to send JPEG messages somewhere  * other than stderr.  *  * On Windows, printing to stderr is generally completely useless,  * so we provide optional code to produce an error-dialog popup.  * Most Windows applications will still prefer to override this routine,  * but if they don't, it'll do something at least marginally useful.  *  * NOTE: to use the library in an environment that doesn't support the  * C stdio library, you may have to delete the call to fprintf() entirely,  * not just not use this routine.  */
end_comment
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|output_message
name|output_message
argument_list|(
argument|j_common_ptr cinfo
argument_list|)
end_macro
begin_block
block|{
name|char
name|buffer
index|[
name|JMSG_LENGTH_MAX
index|]
decl_stmt|;
comment|/* Create the message */
call|(
modifier|*
name|cinfo
operator|->
name|err
operator|->
name|format_message
call|)
argument_list|(
name|cinfo
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_WINDOWS_MESSAGEBOX
comment|/* Display it in a message dialog box */
name|MessageBox
argument_list|(
name|GetActiveWindow
argument_list|()
argument_list|,
name|buffer
argument_list|,
literal|"JPEG Library Error"
argument_list|,
name|MB_OK
operator||
name|MB_ICONERROR
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Send it to stderr, adding a newline */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block
begin_comment
comment|/*  * Decide whether to emit a trace or warning message.  * msg_level is one of:  *   -1: recoverable corrupt-data warning, may want to abort.  *    0: important advisory messages (always display to user).  *    1: first level of tracing detail.  *    2,3,...: successively more detailed tracing messages.  * An application might override this method if it wanted to abort on warnings  * or change the policy about which messages to display.  */
end_comment
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|emit_message
name|emit_message
argument_list|(
argument|j_common_ptr cinfo
argument_list|,
argument|int msg_level
argument_list|)
end_macro
begin_block
block|{
name|struct
name|jpeg_error_mgr
modifier|*
name|err
init|=
name|cinfo
operator|->
name|err
decl_stmt|;
if|if
condition|(
name|msg_level
operator|<
literal|0
condition|)
block|{
comment|/* It's a warning message.  Since corrupt files may generate many warnings,      * the policy implemented here is to show only the first warning,      * unless trace_level>= 3.      */
if|if
condition|(
name|err
operator|->
name|num_warnings
operator|==
literal|0
operator|||
name|err
operator|->
name|trace_level
operator|>=
literal|3
condition|)
call|(
modifier|*
name|err
operator|->
name|output_message
call|)
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
comment|/* Always count warnings in num_warnings. */
name|err
operator|->
name|num_warnings
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* It's a trace message.  Show it if trace_level>= msg_level. */
if|if
condition|(
name|err
operator|->
name|trace_level
operator|>=
name|msg_level
condition|)
call|(
modifier|*
name|err
operator|->
name|output_message
call|)
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
block|}
block|}
end_block
begin_comment
comment|/*  * Format a message string for the most recent JPEG error or message.  * The message is stored into buffer, which should be at least JMSG_LENGTH_MAX  * characters.  Note that no '\n' character is added to the string.  * Few applications should need to override this method.  */
end_comment
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|format_message
name|format_message
argument_list|(
argument|j_common_ptr cinfo
argument_list|,
argument|char * buffer
argument_list|)
end_macro
begin_block
block|{
name|struct
name|jpeg_error_mgr
modifier|*
name|err
init|=
name|cinfo
operator|->
name|err
decl_stmt|;
name|int
name|msg_code
init|=
name|err
operator|->
name|msg_code
decl_stmt|;
specifier|const
name|char
modifier|*
name|msgtext
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|msgptr
decl_stmt|;
name|char
name|ch
decl_stmt|;
name|boolean
name|isstring
decl_stmt|;
comment|/* Look up message string in proper table */
if|if
condition|(
name|msg_code
operator|>
literal|0
operator|&&
name|msg_code
operator|<=
name|err
operator|->
name|last_jpeg_message
condition|)
block|{
name|msgtext
operator|=
name|err
operator|->
name|jpeg_message_table
index|[
name|msg_code
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|err
operator|->
name|addon_message_table
operator|!=
name|NULL
operator|&&
name|msg_code
operator|>=
name|err
operator|->
name|first_addon_message
operator|&&
name|msg_code
operator|<=
name|err
operator|->
name|last_addon_message
condition|)
block|{
name|msgtext
operator|=
name|err
operator|->
name|addon_message_table
index|[
name|msg_code
operator|-
name|err
operator|->
name|first_addon_message
index|]
expr_stmt|;
block|}
comment|/* Defend against bogus message number */
if|if
condition|(
name|msgtext
operator|==
name|NULL
condition|)
block|{
name|err
operator|->
name|msg_parm
operator|.
name|i
index|[
literal|0
index|]
operator|=
name|msg_code
expr_stmt|;
name|msgtext
operator|=
name|err
operator|->
name|jpeg_message_table
index|[
literal|0
index|]
expr_stmt|;
block|}
comment|/* Check for string parameter, as indicated by %s in the message text */
name|isstring
operator|=
name|FALSE
expr_stmt|;
name|msgptr
operator|=
name|msgtext
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
operator|*
name|msgptr
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|ch
operator|==
literal|'%'
condition|)
block|{
if|if
condition|(
operator|*
name|msgptr
operator|==
literal|'s'
condition|)
name|isstring
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
comment|/* Format the message into the passed buffer */
if|if
condition|(
name|isstring
condition|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
name|msgtext
argument_list|,
name|err
operator|->
name|msg_parm
operator|.
name|s
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buffer
argument_list|,
name|msgtext
argument_list|,
name|err
operator|->
name|msg_parm
operator|.
name|i
index|[
literal|0
index|]
argument_list|,
name|err
operator|->
name|msg_parm
operator|.
name|i
index|[
literal|1
index|]
argument_list|,
name|err
operator|->
name|msg_parm
operator|.
name|i
index|[
literal|2
index|]
argument_list|,
name|err
operator|->
name|msg_parm
operator|.
name|i
index|[
literal|3
index|]
argument_list|,
name|err
operator|->
name|msg_parm
operator|.
name|i
index|[
literal|4
index|]
argument_list|,
name|err
operator|->
name|msg_parm
operator|.
name|i
index|[
literal|5
index|]
argument_list|,
name|err
operator|->
name|msg_parm
operator|.
name|i
index|[
literal|6
index|]
argument_list|,
name|err
operator|->
name|msg_parm
operator|.
name|i
index|[
literal|7
index|]
argument_list|)
expr_stmt|;
block|}
end_block
begin_comment
comment|/*  * Reset error state variables at start of a new image.  * This is called during compression startup to reset trace/error  * processing to default state, without losing any application-specific  * method pointers.  An application might possibly want to override  * this method if it has additional error processing state.  */
end_comment
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|reset_error_mgr
name|reset_error_mgr
argument_list|(
argument|j_common_ptr cinfo
argument_list|)
end_macro
begin_block
block|{
name|cinfo
operator|->
name|err
operator|->
name|num_warnings
operator|=
literal|0
expr_stmt|;
comment|/* trace_level is not reset since it is an application-supplied parameter */
name|cinfo
operator|->
name|err
operator|->
name|msg_code
operator|=
literal|0
expr_stmt|;
comment|/* may be useful as a flag for "no error" */
block|}
end_block
begin_comment
comment|/*  * Fill in the standard error-handling methods in a jpeg_error_mgr object.  * Typical call is:  *	struct jpeg_compress_struct cinfo;  *	struct jpeg_error_mgr err;  *  *	cinfo.err = jpeg_std_error(&err);  * after which the application may override some of the methods.  */
end_comment
begin_macro
name|GLOBAL
argument_list|(
argument|struct jpeg_error_mgr *
argument_list|)
end_macro
begin_macro
DECL|function|jpeg_std_error
name|jpeg_std_error
argument_list|(
argument|struct jpeg_error_mgr * err
argument_list|)
end_macro
begin_block
block|{
name|err
operator|->
name|error_exit
operator|=
name|error_exit
expr_stmt|;
name|err
operator|->
name|emit_message
operator|=
name|emit_message
expr_stmt|;
name|err
operator|->
name|output_message
operator|=
name|output_message
expr_stmt|;
name|err
operator|->
name|format_message
operator|=
name|format_message
expr_stmt|;
name|err
operator|->
name|reset_error_mgr
operator|=
name|reset_error_mgr
expr_stmt|;
name|err
operator|->
name|trace_level
operator|=
literal|0
expr_stmt|;
comment|/* default = no tracing */
name|err
operator|->
name|num_warnings
operator|=
literal|0
expr_stmt|;
comment|/* no warnings emitted yet */
name|err
operator|->
name|msg_code
operator|=
literal|0
expr_stmt|;
comment|/* may be useful as a flag for "no error" */
comment|/* Initialize message table pointers */
name|err
operator|->
name|jpeg_message_table
operator|=
name|jpeg_std_message_table
expr_stmt|;
name|err
operator|->
name|last_jpeg_message
operator|=
operator|(
name|int
operator|)
name|JMSG_LASTMSGCODE
operator|-
literal|1
expr_stmt|;
name|err
operator|->
name|addon_message_table
operator|=
name|NULL
expr_stmt|;
name|err
operator|->
name|first_addon_message
operator|=
literal|0
expr_stmt|;
comment|/* for safety */
name|err
operator|->
name|last_addon_message
operator|=
literal|0
expr_stmt|;
return|return
name|err
return|;
block|}
end_block
end_unit
