begin_unit
begin_comment
comment|/*  * jdmaster.c  *  * Copyright (C) 1991-1997, Thomas G. Lane.  * Modified 2002-2009 by Guido Vollbeding.  * This file is part of the Independent JPEG Group's software.  * For conditions of distribution and use, see the accompanying README file.  *  * This file contains master control logic for the JPEG decompressor.  * These routines are concerned with selecting the modules to be executed  * and with determining the number of passes and the work to be done in each  * pass.  */
end_comment
begin_define
DECL|macro|JPEG_INTERNALS
define|#
directive|define
name|JPEG_INTERNALS
end_define
begin_include
include|#
directive|include
file|"jinclude.h"
end_include
begin_include
include|#
directive|include
file|"jpeglib.h"
end_include
begin_comment
comment|/* Private state */
end_comment
begin_typedef
typedef|typedef
struct|struct
block|{
DECL|member|pub
name|struct
name|jpeg_decomp_master
name|pub
decl_stmt|;
comment|/* public fields */
DECL|member|pass_number
name|int
name|pass_number
decl_stmt|;
comment|/* # of passes completed */
DECL|member|using_merged_upsample
name|boolean
name|using_merged_upsample
decl_stmt|;
comment|/* TRUE if using merged upsample/cconvert */
comment|/* Saved references to initialized quantizer modules,    * in case we need to switch modes.    */
DECL|member|quantizer_1pass
name|struct
name|jpeg_color_quantizer
modifier|*
name|quantizer_1pass
decl_stmt|;
DECL|member|quantizer_2pass
name|struct
name|jpeg_color_quantizer
modifier|*
name|quantizer_2pass
decl_stmt|;
block|}
DECL|typedef|my_decomp_master
name|my_decomp_master
typedef|;
end_typedef
begin_typedef
DECL|typedef|my_master_ptr
typedef|typedef
name|my_decomp_master
modifier|*
name|my_master_ptr
typedef|;
end_typedef
begin_comment
comment|/*  * Determine whether merged upsample/color conversion should be used.  * CRUCIAL: this must match the actual capabilities of jdmerge.c!  */
end_comment
begin_macro
DECL|function|LOCAL
name|LOCAL
argument_list|(
argument|boolean
argument_list|)
end_macro
begin_macro
name|use_merged_upsample
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|)
end_macro
begin_block
block|{
ifdef|#
directive|ifdef
name|UPSAMPLE_MERGING_SUPPORTED
comment|/* Merging is the equivalent of plain box-filter upsampling */
if|if
condition|(
name|cinfo
operator|->
name|do_fancy_upsampling
operator|||
name|cinfo
operator|->
name|CCIR601_sampling
condition|)
return|return
name|FALSE
return|;
comment|/* jdmerge.c only supports YCC=>RGB color conversion */
if|if
condition|(
name|cinfo
operator|->
name|jpeg_color_space
operator|!=
name|JCS_YCbCr
operator|||
name|cinfo
operator|->
name|num_components
operator|!=
literal|3
operator|||
name|cinfo
operator|->
name|out_color_space
operator|!=
name|JCS_RGB
operator|||
name|cinfo
operator|->
name|out_color_components
operator|!=
name|RGB_PIXELSIZE
condition|)
return|return
name|FALSE
return|;
comment|/* and it only handles 2h1v or 2h2v sampling ratios */
if|if
condition|(
name|cinfo
operator|->
name|comp_info
index|[
literal|0
index|]
operator|.
name|h_samp_factor
operator|!=
literal|2
operator|||
name|cinfo
operator|->
name|comp_info
index|[
literal|1
index|]
operator|.
name|h_samp_factor
operator|!=
literal|1
operator|||
name|cinfo
operator|->
name|comp_info
index|[
literal|2
index|]
operator|.
name|h_samp_factor
operator|!=
literal|1
operator|||
name|cinfo
operator|->
name|comp_info
index|[
literal|0
index|]
operator|.
name|v_samp_factor
operator|>
literal|2
operator|||
name|cinfo
operator|->
name|comp_info
index|[
literal|1
index|]
operator|.
name|v_samp_factor
operator|!=
literal|1
operator|||
name|cinfo
operator|->
name|comp_info
index|[
literal|2
index|]
operator|.
name|v_samp_factor
operator|!=
literal|1
condition|)
return|return
name|FALSE
return|;
comment|/* furthermore, it doesn't work if we've scaled the IDCTs differently */
if|if
condition|(
name|cinfo
operator|->
name|comp_info
index|[
literal|0
index|]
operator|.
name|DCT_h_scaled_size
operator|!=
name|cinfo
operator|->
name|min_DCT_h_scaled_size
operator|||
name|cinfo
operator|->
name|comp_info
index|[
literal|1
index|]
operator|.
name|DCT_h_scaled_size
operator|!=
name|cinfo
operator|->
name|min_DCT_h_scaled_size
operator|||
name|cinfo
operator|->
name|comp_info
index|[
literal|2
index|]
operator|.
name|DCT_h_scaled_size
operator|!=
name|cinfo
operator|->
name|min_DCT_h_scaled_size
operator|||
name|cinfo
operator|->
name|comp_info
index|[
literal|0
index|]
operator|.
name|DCT_v_scaled_size
operator|!=
name|cinfo
operator|->
name|min_DCT_v_scaled_size
operator|||
name|cinfo
operator|->
name|comp_info
index|[
literal|1
index|]
operator|.
name|DCT_v_scaled_size
operator|!=
name|cinfo
operator|->
name|min_DCT_v_scaled_size
operator|||
name|cinfo
operator|->
name|comp_info
index|[
literal|2
index|]
operator|.
name|DCT_v_scaled_size
operator|!=
name|cinfo
operator|->
name|min_DCT_v_scaled_size
condition|)
return|return
name|FALSE
return|;
comment|/* ??? also need to test for upsample-time rescaling, when& if supported */
return|return
name|TRUE
return|;
comment|/* by golly, it'll work... */
else|#
directive|else
return|return
name|FALSE
return|;
endif|#
directive|endif
block|}
end_block
begin_comment
comment|/*  * Compute output image dimensions and related values.  * NOTE: this is exported for possible use by application.  * Hence it mustn't do anything that can't be done twice.  * Also note that it may be called before the master module is initialized!  */
end_comment
begin_macro
name|GLOBAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|jpeg_calc_output_dimensions
name|jpeg_calc_output_dimensions
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|)
end_macro
begin_comment
comment|/* Do computations that are needed before master selection phase.  * This function is used for full decompression.  */
end_comment
begin_block
block|{
ifdef|#
directive|ifdef
name|IDCT_SCALING_SUPPORTED
name|int
name|ci
decl_stmt|;
name|jpeg_component_info
modifier|*
name|compptr
decl_stmt|;
endif|#
directive|endif
comment|/* Prevent application from calling me at wrong times */
if|if
condition|(
name|cinfo
operator|->
name|global_state
operator|!=
name|DSTATE_READY
condition|)
name|ERREXIT1
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_STATE
argument_list|,
name|cinfo
operator|->
name|global_state
argument_list|)
expr_stmt|;
comment|/* Compute core output image dimensions and DCT scaling choices. */
name|jpeg_core_output_dimensions
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IDCT_SCALING_SUPPORTED
comment|/* In selecting the actual DCT scaling for each component, we try to    * scale up the chroma components via IDCT scaling rather than upsampling.    * This saves time if the upsampler gets to use 1:1 scaling.    * Note this code adapts subsampling ratios which are powers of 2.    */
for|for
control|(
name|ci
operator|=
literal|0
operator|,
name|compptr
operator|=
name|cinfo
operator|->
name|comp_info
init|;
name|ci
operator|<
name|cinfo
operator|->
name|num_components
condition|;
name|ci
operator|++
operator|,
name|compptr
operator|++
control|)
block|{
name|int
name|ssize
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|cinfo
operator|->
name|min_DCT_h_scaled_size
operator|*
name|ssize
operator|<=
operator|(
name|cinfo
operator|->
name|do_fancy_upsampling
condition|?
name|DCTSIZE
else|:
name|DCTSIZE
operator|/
literal|2
operator|)
operator|&&
operator|(
name|cinfo
operator|->
name|max_h_samp_factor
operator|%
operator|(
name|compptr
operator|->
name|h_samp_factor
operator|*
name|ssize
operator|*
literal|2
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|ssize
operator|=
name|ssize
operator|*
literal|2
expr_stmt|;
block|}
name|compptr
operator|->
name|DCT_h_scaled_size
operator|=
name|cinfo
operator|->
name|min_DCT_h_scaled_size
operator|*
name|ssize
expr_stmt|;
name|ssize
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|cinfo
operator|->
name|min_DCT_v_scaled_size
operator|*
name|ssize
operator|<=
operator|(
name|cinfo
operator|->
name|do_fancy_upsampling
condition|?
name|DCTSIZE
else|:
name|DCTSIZE
operator|/
literal|2
operator|)
operator|&&
operator|(
name|cinfo
operator|->
name|max_v_samp_factor
operator|%
operator|(
name|compptr
operator|->
name|v_samp_factor
operator|*
name|ssize
operator|*
literal|2
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|ssize
operator|=
name|ssize
operator|*
literal|2
expr_stmt|;
block|}
name|compptr
operator|->
name|DCT_v_scaled_size
operator|=
name|cinfo
operator|->
name|min_DCT_v_scaled_size
operator|*
name|ssize
expr_stmt|;
comment|/* We don't support IDCT ratios larger than 2. */
if|if
condition|(
name|compptr
operator|->
name|DCT_h_scaled_size
operator|>
name|compptr
operator|->
name|DCT_v_scaled_size
operator|*
literal|2
condition|)
name|compptr
operator|->
name|DCT_h_scaled_size
operator|=
name|compptr
operator|->
name|DCT_v_scaled_size
operator|*
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|compptr
operator|->
name|DCT_v_scaled_size
operator|>
name|compptr
operator|->
name|DCT_h_scaled_size
operator|*
literal|2
condition|)
name|compptr
operator|->
name|DCT_v_scaled_size
operator|=
name|compptr
operator|->
name|DCT_h_scaled_size
operator|*
literal|2
expr_stmt|;
block|}
comment|/* Recompute downsampled dimensions of components;    * application needs to know these if using raw downsampled data.    */
for|for
control|(
name|ci
operator|=
literal|0
operator|,
name|compptr
operator|=
name|cinfo
operator|->
name|comp_info
init|;
name|ci
operator|<
name|cinfo
operator|->
name|num_components
condition|;
name|ci
operator|++
operator|,
name|compptr
operator|++
control|)
block|{
comment|/* Size in samples, after IDCT scaling */
name|compptr
operator|->
name|downsampled_width
operator|=
operator|(
name|JDIMENSION
operator|)
name|jdiv_round_up
argument_list|(
operator|(
name|long
operator|)
name|cinfo
operator|->
name|image_width
operator|*
call|(
name|long
call|)
argument_list|(
name|compptr
operator|->
name|h_samp_factor
operator|*
name|compptr
operator|->
name|DCT_h_scaled_size
argument_list|)
argument_list|,
call|(
name|long
call|)
argument_list|(
name|cinfo
operator|->
name|max_h_samp_factor
operator|*
name|cinfo
operator|->
name|block_size
argument_list|)
argument_list|)
expr_stmt|;
name|compptr
operator|->
name|downsampled_height
operator|=
operator|(
name|JDIMENSION
operator|)
name|jdiv_round_up
argument_list|(
operator|(
name|long
operator|)
name|cinfo
operator|->
name|image_height
operator|*
call|(
name|long
call|)
argument_list|(
name|compptr
operator|->
name|v_samp_factor
operator|*
name|compptr
operator|->
name|DCT_v_scaled_size
argument_list|)
argument_list|,
call|(
name|long
call|)
argument_list|(
name|cinfo
operator|->
name|max_v_samp_factor
operator|*
name|cinfo
operator|->
name|block_size
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* IDCT_SCALING_SUPPORTED */
comment|/* Report number of components in selected colorspace. */
comment|/* Probably this should be in the color conversion module... */
switch|switch
condition|(
name|cinfo
operator|->
name|out_color_space
condition|)
block|{
case|case
name|JCS_GRAYSCALE
case|:
name|cinfo
operator|->
name|out_color_components
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|JCS_RGB
case|:
if|#
directive|if
name|RGB_PIXELSIZE
operator|!=
literal|3
name|cinfo
operator|->
name|out_color_components
operator|=
name|RGB_PIXELSIZE
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* else share code with YCbCr */
case|case
name|JCS_YCbCr
case|:
name|cinfo
operator|->
name|out_color_components
operator|=
literal|3
expr_stmt|;
break|break;
case|case
name|JCS_CMYK
case|:
case|case
name|JCS_YCCK
case|:
name|cinfo
operator|->
name|out_color_components
operator|=
literal|4
expr_stmt|;
break|break;
default|default:
comment|/* else must be same colorspace as in file */
name|cinfo
operator|->
name|out_color_components
operator|=
name|cinfo
operator|->
name|num_components
expr_stmt|;
break|break;
block|}
name|cinfo
operator|->
name|output_components
operator|=
operator|(
name|cinfo
operator|->
name|quantize_colors
condition|?
literal|1
else|:
name|cinfo
operator|->
name|out_color_components
operator|)
expr_stmt|;
comment|/* See if upsampler will want to emit more than one row at a time */
if|if
condition|(
name|use_merged_upsample
argument_list|(
name|cinfo
argument_list|)
condition|)
name|cinfo
operator|->
name|rec_outbuf_height
operator|=
name|cinfo
operator|->
name|max_v_samp_factor
expr_stmt|;
else|else
name|cinfo
operator|->
name|rec_outbuf_height
operator|=
literal|1
expr_stmt|;
block|}
end_block
begin_comment
comment|/*  * Several decompression processes need to range-limit values to the range  * 0..MAXJSAMPLE; the input value may fall somewhat outside this range  * due to noise introduced by quantization, roundoff error, etc.  These  * processes are inner loops and need to be as fast as possible.  On most  * machines, particularly CPUs with pipelines or instruction prefetch,  * a (subscript-check-less) C table lookup  *		x = sample_range_limit[x];  * is faster than explicit tests  *		if (x< 0)  x = 0;  *		else if (x> MAXJSAMPLE)  x = MAXJSAMPLE;  * These processes all use a common table prepared by the routine below.  *  * For most steps we can mathematically guarantee that the initial value  * of x is within MAXJSAMPLE+1 of the legal range, so a table running from  * -(MAXJSAMPLE+1) to 2*MAXJSAMPLE+1 is sufficient.  But for the initial  * limiting step (just after the IDCT), a wildly out-of-range value is   * possible if the input data is corrupt.  To avoid any chance of indexing  * off the end of memory and getting a bad-pointer trap, we perform the  * post-IDCT limiting thus:  *		x = range_limit[x& MASK];  * where MASK is 2 bits wider than legal sample data, ie 10 bits for 8-bit  * samples.  Under normal circumstances this is more than enough range and  * a correct output will be generated; with bogus input data the mask will  * cause wraparound, and we will safely generate a bogus-but-in-range output.  * For the post-IDCT step, we want to convert the data from signed to unsigned  * representation by adding CENTERJSAMPLE at the same time that we limit it.  * So the post-IDCT limiting table ends up looking like this:  *   CENTERJSAMPLE,CENTERJSAMPLE+1,...,MAXJSAMPLE,  *   MAXJSAMPLE (repeat 2*(MAXJSAMPLE+1)-CENTERJSAMPLE times),  *   0          (repeat 2*(MAXJSAMPLE+1)-CENTERJSAMPLE times),  *   0,1,...,CENTERJSAMPLE-1  * Negative inputs select values from the upper half of the table after  * masking.  *  * We can save some space by overlapping the start of the post-IDCT table  * with the simpler range limiting table.  The post-IDCT table begins at  * sample_range_limit + CENTERJSAMPLE.  *  * Note that the table is allocated in near data space on PCs; it's small  * enough and used often enough to justify this.  */
end_comment
begin_macro
name|LOCAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|prepare_range_limit_table
name|prepare_range_limit_table
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|)
end_macro
begin_comment
comment|/* Allocate and fill in the sample_range_limit table */
end_comment
begin_block
block|{
name|JSAMPLE
modifier|*
name|table
decl_stmt|;
name|int
name|i
decl_stmt|;
name|table
operator|=
operator|(
name|JSAMPLE
operator|*
operator|)
call|(
modifier|*
name|cinfo
operator|->
name|mem
operator|->
name|alloc_small
call|)
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|,
name|JPOOL_IMAGE
argument_list|,
operator|(
literal|5
operator|*
operator|(
name|MAXJSAMPLE
operator|+
literal|1
operator|)
operator|+
name|CENTERJSAMPLE
operator|)
operator|*
name|SIZEOF
argument_list|(
name|JSAMPLE
argument_list|)
argument_list|)
expr_stmt|;
name|table
operator|+=
operator|(
name|MAXJSAMPLE
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* allow negative subscripts of simple table */
name|cinfo
operator|->
name|sample_range_limit
operator|=
name|table
expr_stmt|;
comment|/* First segment of "simple" table: limit[x] = 0 for x< 0 */
name|MEMZERO
argument_list|(
name|table
operator|-
operator|(
name|MAXJSAMPLE
operator|+
literal|1
operator|)
argument_list|,
operator|(
name|MAXJSAMPLE
operator|+
literal|1
operator|)
operator|*
name|SIZEOF
argument_list|(
name|JSAMPLE
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Main part of "simple" table: limit[x] = x */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|MAXJSAMPLE
condition|;
name|i
operator|++
control|)
name|table
index|[
name|i
index|]
operator|=
operator|(
name|JSAMPLE
operator|)
name|i
expr_stmt|;
name|table
operator|+=
name|CENTERJSAMPLE
expr_stmt|;
comment|/* Point to where post-IDCT table starts */
comment|/* End of simple table, rest of first half of post-IDCT table */
for|for
control|(
name|i
operator|=
name|CENTERJSAMPLE
init|;
name|i
operator|<
literal|2
operator|*
operator|(
name|MAXJSAMPLE
operator|+
literal|1
operator|)
condition|;
name|i
operator|++
control|)
name|table
index|[
name|i
index|]
operator|=
name|MAXJSAMPLE
expr_stmt|;
comment|/* Second half of post-IDCT table */
name|MEMZERO
argument_list|(
name|table
operator|+
operator|(
literal|2
operator|*
operator|(
name|MAXJSAMPLE
operator|+
literal|1
operator|)
operator|)
argument_list|,
operator|(
literal|2
operator|*
operator|(
name|MAXJSAMPLE
operator|+
literal|1
operator|)
operator|-
name|CENTERJSAMPLE
operator|)
operator|*
name|SIZEOF
argument_list|(
name|JSAMPLE
argument_list|)
argument_list|)
expr_stmt|;
name|MEMCOPY
argument_list|(
name|table
operator|+
operator|(
literal|4
operator|*
operator|(
name|MAXJSAMPLE
operator|+
literal|1
operator|)
operator|-
name|CENTERJSAMPLE
operator|)
argument_list|,
name|cinfo
operator|->
name|sample_range_limit
argument_list|,
name|CENTERJSAMPLE
operator|*
name|SIZEOF
argument_list|(
name|JSAMPLE
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block
begin_comment
comment|/*  * Master selection of decompression modules.  * This is done once at jpeg_start_decompress time.  We determine  * which modules will be used and give them appropriate initialization calls.  * We also initialize the decompressor input side to begin consuming data.  *  * Since jpeg_read_header has finished, we know what is in the SOF  * and (first) SOS markers.  We also have all the application parameter  * settings.  */
end_comment
begin_macro
name|LOCAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|master_selection
name|master_selection
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|)
end_macro
begin_block
block|{
name|my_master_ptr
name|master
init|=
operator|(
name|my_master_ptr
operator|)
name|cinfo
operator|->
name|master
decl_stmt|;
name|boolean
name|use_c_buffer
decl_stmt|;
name|long
name|samplesperrow
decl_stmt|;
name|JDIMENSION
name|jd_samplesperrow
decl_stmt|;
comment|/* Initialize dimensions and other stuff */
name|jpeg_calc_output_dimensions
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
name|prepare_range_limit_table
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
comment|/* Width of an output scanline must be representable as JDIMENSION. */
name|samplesperrow
operator|=
operator|(
name|long
operator|)
name|cinfo
operator|->
name|output_width
operator|*
operator|(
name|long
operator|)
name|cinfo
operator|->
name|out_color_components
expr_stmt|;
name|jd_samplesperrow
operator|=
operator|(
name|JDIMENSION
operator|)
name|samplesperrow
expr_stmt|;
if|if
condition|(
operator|(
name|long
operator|)
name|jd_samplesperrow
operator|!=
name|samplesperrow
condition|)
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_WIDTH_OVERFLOW
argument_list|)
expr_stmt|;
comment|/* Initialize my private state */
name|master
operator|->
name|pass_number
operator|=
literal|0
expr_stmt|;
name|master
operator|->
name|using_merged_upsample
operator|=
name|use_merged_upsample
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
comment|/* Color quantizer selection */
name|master
operator|->
name|quantizer_1pass
operator|=
name|NULL
expr_stmt|;
name|master
operator|->
name|quantizer_2pass
operator|=
name|NULL
expr_stmt|;
comment|/* No mode changes if not using buffered-image mode. */
if|if
condition|(
operator|!
name|cinfo
operator|->
name|quantize_colors
operator|||
operator|!
name|cinfo
operator|->
name|buffered_image
condition|)
block|{
name|cinfo
operator|->
name|enable_1pass_quant
operator|=
name|FALSE
expr_stmt|;
name|cinfo
operator|->
name|enable_external_quant
operator|=
name|FALSE
expr_stmt|;
name|cinfo
operator|->
name|enable_2pass_quant
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|cinfo
operator|->
name|quantize_colors
condition|)
block|{
if|if
condition|(
name|cinfo
operator|->
name|raw_data_out
condition|)
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_NOTIMPL
argument_list|)
expr_stmt|;
comment|/* 2-pass quantizer only works in 3-component color space. */
if|if
condition|(
name|cinfo
operator|->
name|out_color_components
operator|!=
literal|3
condition|)
block|{
name|cinfo
operator|->
name|enable_1pass_quant
operator|=
name|TRUE
expr_stmt|;
name|cinfo
operator|->
name|enable_external_quant
operator|=
name|FALSE
expr_stmt|;
name|cinfo
operator|->
name|enable_2pass_quant
operator|=
name|FALSE
expr_stmt|;
name|cinfo
operator|->
name|colormap
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cinfo
operator|->
name|colormap
operator|!=
name|NULL
condition|)
block|{
name|cinfo
operator|->
name|enable_external_quant
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cinfo
operator|->
name|two_pass_quantize
condition|)
block|{
name|cinfo
operator|->
name|enable_2pass_quant
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|cinfo
operator|->
name|enable_1pass_quant
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|cinfo
operator|->
name|enable_1pass_quant
condition|)
block|{
ifdef|#
directive|ifdef
name|QUANT_1PASS_SUPPORTED
name|jinit_1pass_quantizer
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
name|master
operator|->
name|quantizer_1pass
operator|=
name|cinfo
operator|->
name|cquantize
expr_stmt|;
else|#
directive|else
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_NOT_COMPILED
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* We use the 2-pass code to map to external colormaps. */
if|if
condition|(
name|cinfo
operator|->
name|enable_2pass_quant
operator|||
name|cinfo
operator|->
name|enable_external_quant
condition|)
block|{
ifdef|#
directive|ifdef
name|QUANT_2PASS_SUPPORTED
name|jinit_2pass_quantizer
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
name|master
operator|->
name|quantizer_2pass
operator|=
name|cinfo
operator|->
name|cquantize
expr_stmt|;
else|#
directive|else
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_NOT_COMPILED
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* If both quantizers are initialized, the 2-pass one is left active;      * this is necessary for starting with quantization to an external map.      */
block|}
comment|/* Post-processing: in particular, color conversion first */
if|if
condition|(
operator|!
name|cinfo
operator|->
name|raw_data_out
condition|)
block|{
if|if
condition|(
name|master
operator|->
name|using_merged_upsample
condition|)
block|{
ifdef|#
directive|ifdef
name|UPSAMPLE_MERGING_SUPPORTED
name|jinit_merged_upsampler
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
comment|/* does color conversion too */
else|#
directive|else
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_NOT_COMPILED
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|jinit_color_deconverter
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
name|jinit_upsampler
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
block|}
name|jinit_d_post_controller
argument_list|(
name|cinfo
argument_list|,
name|cinfo
operator|->
name|enable_2pass_quant
argument_list|)
expr_stmt|;
block|}
comment|/* Inverse DCT */
name|jinit_inverse_dct
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
comment|/* Entropy decoding: either Huffman or arithmetic coding. */
if|if
condition|(
name|cinfo
operator|->
name|arith_code
condition|)
name|jinit_arith_decoder
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
else|else
block|{
name|jinit_huff_decoder
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize principal buffer controllers. */
name|use_c_buffer
operator|=
name|cinfo
operator|->
name|inputctl
operator|->
name|has_multiple_scans
operator|||
name|cinfo
operator|->
name|buffered_image
expr_stmt|;
name|jinit_d_coef_controller
argument_list|(
name|cinfo
argument_list|,
name|use_c_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cinfo
operator|->
name|raw_data_out
condition|)
name|jinit_d_main_controller
argument_list|(
name|cinfo
argument_list|,
name|FALSE
comment|/* never need full buffer here */
argument_list|)
expr_stmt|;
comment|/* We can now tell the memory manager to allocate virtual arrays. */
call|(
modifier|*
name|cinfo
operator|->
name|mem
operator|->
name|realize_virt_arrays
call|)
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|)
expr_stmt|;
comment|/* Initialize input side of decompressor to consume first scan. */
call|(
modifier|*
name|cinfo
operator|->
name|inputctl
operator|->
name|start_input_pass
call|)
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|D_MULTISCAN_FILES_SUPPORTED
comment|/* If jpeg_start_decompress will read the whole file, initialize    * progress monitoring appropriately.  The input step is counted    * as one pass.    */
if|if
condition|(
name|cinfo
operator|->
name|progress
operator|!=
name|NULL
operator|&&
operator|!
name|cinfo
operator|->
name|buffered_image
operator|&&
name|cinfo
operator|->
name|inputctl
operator|->
name|has_multiple_scans
condition|)
block|{
name|int
name|nscans
decl_stmt|;
comment|/* Estimate number of scans to set pass_limit. */
if|if
condition|(
name|cinfo
operator|->
name|progressive_mode
condition|)
block|{
comment|/* Arbitrarily estimate 2 interleaved DC scans + 3 AC scans/component. */
name|nscans
operator|=
literal|2
operator|+
literal|3
operator|*
name|cinfo
operator|->
name|num_components
expr_stmt|;
block|}
else|else
block|{
comment|/* For a nonprogressive multiscan file, estimate 1 scan per component. */
name|nscans
operator|=
name|cinfo
operator|->
name|num_components
expr_stmt|;
block|}
name|cinfo
operator|->
name|progress
operator|->
name|pass_counter
operator|=
literal|0L
expr_stmt|;
name|cinfo
operator|->
name|progress
operator|->
name|pass_limit
operator|=
operator|(
name|long
operator|)
name|cinfo
operator|->
name|total_iMCU_rows
operator|*
name|nscans
expr_stmt|;
name|cinfo
operator|->
name|progress
operator|->
name|completed_passes
operator|=
literal|0
expr_stmt|;
name|cinfo
operator|->
name|progress
operator|->
name|total_passes
operator|=
operator|(
name|cinfo
operator|->
name|enable_2pass_quant
condition|?
literal|3
else|:
literal|2
operator|)
expr_stmt|;
comment|/* Count the input pass as done */
name|master
operator|->
name|pass_number
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* D_MULTISCAN_FILES_SUPPORTED */
block|}
end_block
begin_comment
comment|/*  * Per-pass setup.  * This is called at the beginning of each output pass.  We determine which  * modules will be active during this pass and give them appropriate  * start_pass calls.  We also set is_dummy_pass to indicate whether this  * is a "real" output pass or a dummy pass for color quantization.  * (In the latter case, jdapistd.c will crank the pass to completion.)  */
end_comment
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|prepare_for_output_pass
name|prepare_for_output_pass
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|)
end_macro
begin_block
block|{
name|my_master_ptr
name|master
init|=
operator|(
name|my_master_ptr
operator|)
name|cinfo
operator|->
name|master
decl_stmt|;
if|if
condition|(
name|master
operator|->
name|pub
operator|.
name|is_dummy_pass
condition|)
block|{
ifdef|#
directive|ifdef
name|QUANT_2PASS_SUPPORTED
comment|/* Final pass of 2-pass quantization */
name|master
operator|->
name|pub
operator|.
name|is_dummy_pass
operator|=
name|FALSE
expr_stmt|;
call|(
modifier|*
name|cinfo
operator|->
name|cquantize
operator|->
name|start_pass
call|)
argument_list|(
name|cinfo
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
call|(
modifier|*
name|cinfo
operator|->
name|post
operator|->
name|start_pass
call|)
argument_list|(
name|cinfo
argument_list|,
name|JBUF_CRANK_DEST
argument_list|)
expr_stmt|;
operator|(
operator|*
name|cinfo
operator|->
expr|main
operator|->
name|start_pass
operator|)
operator|(
name|cinfo
operator|,
name|JBUF_CRANK_DEST
operator|)
expr_stmt|;
else|#
directive|else
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_NOT_COMPILED
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* QUANT_2PASS_SUPPORTED */
block|}
else|else
block|{
if|if
condition|(
name|cinfo
operator|->
name|quantize_colors
operator|&&
name|cinfo
operator|->
name|colormap
operator|==
name|NULL
condition|)
block|{
comment|/* Select new quantization method */
if|if
condition|(
name|cinfo
operator|->
name|two_pass_quantize
operator|&&
name|cinfo
operator|->
name|enable_2pass_quant
condition|)
block|{
name|cinfo
operator|->
name|cquantize
operator|=
name|master
operator|->
name|quantizer_2pass
expr_stmt|;
name|master
operator|->
name|pub
operator|.
name|is_dummy_pass
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cinfo
operator|->
name|enable_1pass_quant
condition|)
block|{
name|cinfo
operator|->
name|cquantize
operator|=
name|master
operator|->
name|quantizer_1pass
expr_stmt|;
block|}
else|else
block|{
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_MODE_CHANGE
argument_list|)
expr_stmt|;
block|}
block|}
call|(
modifier|*
name|cinfo
operator|->
name|idct
operator|->
name|start_pass
call|)
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
call|(
modifier|*
name|cinfo
operator|->
name|coef
operator|->
name|start_output_pass
call|)
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cinfo
operator|->
name|raw_data_out
condition|)
block|{
if|if
condition|(
operator|!
name|master
operator|->
name|using_merged_upsample
condition|)
call|(
modifier|*
name|cinfo
operator|->
name|cconvert
operator|->
name|start_pass
call|)
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
call|(
modifier|*
name|cinfo
operator|->
name|upsample
operator|->
name|start_pass
call|)
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|cinfo
operator|->
name|quantize_colors
condition|)
call|(
modifier|*
name|cinfo
operator|->
name|cquantize
operator|->
name|start_pass
call|)
argument_list|(
name|cinfo
argument_list|,
name|master
operator|->
name|pub
operator|.
name|is_dummy_pass
argument_list|)
expr_stmt|;
call|(
modifier|*
name|cinfo
operator|->
name|post
operator|->
name|start_pass
call|)
argument_list|(
name|cinfo
argument_list|,
operator|(
name|master
operator|->
name|pub
operator|.
name|is_dummy_pass
condition|?
name|JBUF_SAVE_AND_PASS
else|:
name|JBUF_PASS_THRU
operator|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|cinfo
operator|->
expr|main
operator|->
name|start_pass
operator|)
operator|(
name|cinfo
operator|,
name|JBUF_PASS_THRU
operator|)
expr_stmt|;
block|}
block|}
comment|/* Set up progress monitor's pass info if present */
if|if
condition|(
name|cinfo
operator|->
name|progress
operator|!=
name|NULL
condition|)
block|{
name|cinfo
operator|->
name|progress
operator|->
name|completed_passes
operator|=
name|master
operator|->
name|pass_number
expr_stmt|;
name|cinfo
operator|->
name|progress
operator|->
name|total_passes
operator|=
name|master
operator|->
name|pass_number
operator|+
operator|(
name|master
operator|->
name|pub
operator|.
name|is_dummy_pass
condition|?
literal|2
else|:
literal|1
operator|)
expr_stmt|;
comment|/* In buffered-image mode, we assume one more output pass if EOI not      * yet reached, but no more passes if EOI has been reached.      */
if|if
condition|(
name|cinfo
operator|->
name|buffered_image
operator|&&
operator|!
name|cinfo
operator|->
name|inputctl
operator|->
name|eoi_reached
condition|)
block|{
name|cinfo
operator|->
name|progress
operator|->
name|total_passes
operator|+=
operator|(
name|cinfo
operator|->
name|enable_2pass_quant
condition|?
literal|2
else|:
literal|1
operator|)
expr_stmt|;
block|}
block|}
block|}
end_block
begin_comment
comment|/*  * Finish up at end of an output pass.  */
end_comment
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|finish_output_pass
name|finish_output_pass
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|)
end_macro
begin_block
block|{
name|my_master_ptr
name|master
init|=
operator|(
name|my_master_ptr
operator|)
name|cinfo
operator|->
name|master
decl_stmt|;
if|if
condition|(
name|cinfo
operator|->
name|quantize_colors
condition|)
call|(
modifier|*
name|cinfo
operator|->
name|cquantize
operator|->
name|finish_pass
call|)
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
name|master
operator|->
name|pass_number
operator|++
expr_stmt|;
block|}
end_block
begin_ifdef
ifdef|#
directive|ifdef
name|D_MULTISCAN_FILES_SUPPORTED
end_ifdef
begin_comment
comment|/*  * Switch to a new external colormap between output passes.  */
end_comment
begin_macro
name|GLOBAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|jpeg_new_colormap
name|jpeg_new_colormap
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|)
end_macro
begin_block
block|{
name|my_master_ptr
name|master
init|=
operator|(
name|my_master_ptr
operator|)
name|cinfo
operator|->
name|master
decl_stmt|;
comment|/* Prevent application from calling me at wrong times */
if|if
condition|(
name|cinfo
operator|->
name|global_state
operator|!=
name|DSTATE_BUFIMAGE
condition|)
name|ERREXIT1
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_STATE
argument_list|,
name|cinfo
operator|->
name|global_state
argument_list|)
expr_stmt|;
if|if
condition|(
name|cinfo
operator|->
name|quantize_colors
operator|&&
name|cinfo
operator|->
name|enable_external_quant
operator|&&
name|cinfo
operator|->
name|colormap
operator|!=
name|NULL
condition|)
block|{
comment|/* Select 2-pass quantizer for external colormap use */
name|cinfo
operator|->
name|cquantize
operator|=
name|master
operator|->
name|quantizer_2pass
expr_stmt|;
comment|/* Notify quantizer of colormap change */
call|(
modifier|*
name|cinfo
operator|->
name|cquantize
operator|->
name|new_color_map
call|)
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
name|master
operator|->
name|pub
operator|.
name|is_dummy_pass
operator|=
name|FALSE
expr_stmt|;
comment|/* just in case */
block|}
else|else
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_MODE_CHANGE
argument_list|)
expr_stmt|;
block|}
end_block
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* D_MULTISCAN_FILES_SUPPORTED */
end_comment
begin_comment
comment|/*  * Initialize master decompression control and select active modules.  * This is performed at the start of jpeg_start_decompress.  */
end_comment
begin_macro
name|GLOBAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|jinit_master_decompress
name|jinit_master_decompress
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|)
end_macro
begin_block
block|{
name|my_master_ptr
name|master
decl_stmt|;
name|master
operator|=
call|(
name|my_master_ptr
call|)
argument_list|(
operator|*
name|cinfo
operator|->
name|mem
operator|->
name|alloc_small
argument_list|)
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|,
name|JPOOL_IMAGE
argument_list|,
name|SIZEOF
argument_list|(
name|my_decomp_master
argument_list|)
argument_list|)
expr_stmt|;
name|cinfo
operator|->
name|master
operator|=
operator|(
expr|struct
name|jpeg_decomp_master
operator|*
operator|)
name|master
expr_stmt|;
name|master
operator|->
name|pub
operator|.
name|prepare_for_output_pass
operator|=
name|prepare_for_output_pass
expr_stmt|;
name|master
operator|->
name|pub
operator|.
name|finish_output_pass
operator|=
name|finish_output_pass
expr_stmt|;
name|master
operator|->
name|pub
operator|.
name|is_dummy_pass
operator|=
name|FALSE
expr_stmt|;
name|master_selection
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
block|}
end_block
end_unit
