begin_unit
begin_comment
comment|/*  * jcmaster.c  *  * Copyright (C) 1991-1997, Thomas G. Lane.  * Modified 2003-2011 by Guido Vollbeding.  * This file is part of the Independent JPEG Group's software.  * For conditions of distribution and use, see the accompanying README file.  *  * This file contains master control logic for the JPEG compressor.  * These routines are concerned with parameter validation, initial setup,  * and inter-pass control (determining the number of passes and the work   * to be done in each pass).  */
end_comment
begin_define
DECL|macro|JPEG_INTERNALS
define|#
directive|define
name|JPEG_INTERNALS
end_define
begin_include
include|#
directive|include
file|"jinclude.h"
end_include
begin_include
include|#
directive|include
file|"jpeglib.h"
end_include
begin_comment
comment|/* Private state */
end_comment
begin_typedef
typedef|typedef
enum|enum
block|{
DECL|enumerator|main_pass
name|main_pass
block|,
comment|/* input data, also do first output step */
DECL|enumerator|huff_opt_pass
name|huff_opt_pass
block|,
comment|/* Huffman code optimization pass */
DECL|enumerator|output_pass
name|output_pass
comment|/* data output pass */
block|}
DECL|typedef|c_pass_type
name|c_pass_type
typedef|;
end_typedef
begin_typedef
typedef|typedef
struct|struct
block|{
DECL|member|pub
name|struct
name|jpeg_comp_master
name|pub
decl_stmt|;
comment|/* public fields */
DECL|member|pass_type
name|c_pass_type
name|pass_type
decl_stmt|;
comment|/* the type of the current pass */
DECL|member|pass_number
name|int
name|pass_number
decl_stmt|;
comment|/* # of passes completed */
DECL|member|total_passes
name|int
name|total_passes
decl_stmt|;
comment|/* total # of passes needed */
DECL|member|scan_number
name|int
name|scan_number
decl_stmt|;
comment|/* current index in scan_info[] */
block|}
DECL|typedef|my_comp_master
name|my_comp_master
typedef|;
end_typedef
begin_typedef
DECL|typedef|my_master_ptr
typedef|typedef
name|my_comp_master
modifier|*
name|my_master_ptr
typedef|;
end_typedef
begin_comment
comment|/*  * Support routines that do various essential calculations.  */
end_comment
begin_comment
comment|/*  * Compute JPEG image dimensions and related values.  * NOTE: this is exported for possible use by application.  * Hence it mustn't do anything that can't be done twice.  */
end_comment
begin_macro
name|GLOBAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|jpeg_calc_jpeg_dimensions
name|jpeg_calc_jpeg_dimensions
argument_list|(
argument|j_compress_ptr cinfo
argument_list|)
end_macro
begin_comment
comment|/* Do computations that are needed before master selection phase */
end_comment
begin_block
block|{
ifdef|#
directive|ifdef
name|DCT_SCALING_SUPPORTED
comment|/* Sanity check on input image dimensions to prevent overflow in    * following calculation.    * We do check jpeg_width and jpeg_height in initial_setup below,    * but image_width and image_height can come from arbitrary data,    * and we need some space for multiplication by block_size.    */
if|if
condition|(
operator|(
operator|(
name|long
operator|)
name|cinfo
operator|->
name|image_width
operator|>>
literal|24
operator|)
operator|||
operator|(
operator|(
name|long
operator|)
name|cinfo
operator|->
name|image_height
operator|>>
literal|24
operator|)
condition|)
name|ERREXIT1
argument_list|(
name|cinfo
argument_list|,
name|JERR_IMAGE_TOO_BIG
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|JPEG_MAX_DIMENSION
argument_list|)
expr_stmt|;
comment|/* Compute actual JPEG image dimensions and DCT scaling choices. */
if|if
condition|(
name|cinfo
operator|->
name|scale_num
operator|>=
name|cinfo
operator|->
name|scale_denom
operator|*
name|cinfo
operator|->
name|block_size
condition|)
block|{
comment|/* Provide block_size/1 scaling */
name|cinfo
operator|->
name|jpeg_width
operator|=
name|cinfo
operator|->
name|image_width
operator|*
name|cinfo
operator|->
name|block_size
expr_stmt|;
name|cinfo
operator|->
name|jpeg_height
operator|=
name|cinfo
operator|->
name|image_height
operator|*
name|cinfo
operator|->
name|block_size
expr_stmt|;
name|cinfo
operator|->
name|min_DCT_h_scaled_size
operator|=
literal|1
expr_stmt|;
name|cinfo
operator|->
name|min_DCT_v_scaled_size
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cinfo
operator|->
name|scale_num
operator|*
literal|2
operator|>=
name|cinfo
operator|->
name|scale_denom
operator|*
name|cinfo
operator|->
name|block_size
condition|)
block|{
comment|/* Provide block_size/2 scaling */
name|cinfo
operator|->
name|jpeg_width
operator|=
operator|(
name|JDIMENSION
operator|)
name|jdiv_round_up
argument_list|(
operator|(
name|long
operator|)
name|cinfo
operator|->
name|image_width
operator|*
name|cinfo
operator|->
name|block_size
argument_list|,
literal|2L
argument_list|)
expr_stmt|;
name|cinfo
operator|->
name|jpeg_height
operator|=
operator|(
name|JDIMENSION
operator|)
name|jdiv_round_up
argument_list|(
operator|(
name|long
operator|)
name|cinfo
operator|->
name|image_height
operator|*
name|cinfo
operator|->
name|block_size
argument_list|,
literal|2L
argument_list|)
expr_stmt|;
name|cinfo
operator|->
name|min_DCT_h_scaled_size
operator|=
literal|2
expr_stmt|;
name|cinfo
operator|->
name|min_DCT_v_scaled_size
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cinfo
operator|->
name|scale_num
operator|*
literal|3
operator|>=
name|cinfo
operator|->
name|scale_denom
operator|*
name|cinfo
operator|->
name|block_size
condition|)
block|{
comment|/* Provide block_size/3 scaling */
name|cinfo
operator|->
name|jpeg_width
operator|=
operator|(
name|JDIMENSION
operator|)
name|jdiv_round_up
argument_list|(
operator|(
name|long
operator|)
name|cinfo
operator|->
name|image_width
operator|*
name|cinfo
operator|->
name|block_size
argument_list|,
literal|3L
argument_list|)
expr_stmt|;
name|cinfo
operator|->
name|jpeg_height
operator|=
operator|(
name|JDIMENSION
operator|)
name|jdiv_round_up
argument_list|(
operator|(
name|long
operator|)
name|cinfo
operator|->
name|image_height
operator|*
name|cinfo
operator|->
name|block_size
argument_list|,
literal|3L
argument_list|)
expr_stmt|;
name|cinfo
operator|->
name|min_DCT_h_scaled_size
operator|=
literal|3
expr_stmt|;
name|cinfo
operator|->
name|min_DCT_v_scaled_size
operator|=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cinfo
operator|->
name|scale_num
operator|*
literal|4
operator|>=
name|cinfo
operator|->
name|scale_denom
operator|*
name|cinfo
operator|->
name|block_size
condition|)
block|{
comment|/* Provide block_size/4 scaling */
name|cinfo
operator|->
name|jpeg_width
operator|=
operator|(
name|JDIMENSION
operator|)
name|jdiv_round_up
argument_list|(
operator|(
name|long
operator|)
name|cinfo
operator|->
name|image_width
operator|*
name|cinfo
operator|->
name|block_size
argument_list|,
literal|4L
argument_list|)
expr_stmt|;
name|cinfo
operator|->
name|jpeg_height
operator|=
operator|(
name|JDIMENSION
operator|)
name|jdiv_round_up
argument_list|(
operator|(
name|long
operator|)
name|cinfo
operator|->
name|image_height
operator|*
name|cinfo
operator|->
name|block_size
argument_list|,
literal|4L
argument_list|)
expr_stmt|;
name|cinfo
operator|->
name|min_DCT_h_scaled_size
operator|=
literal|4
expr_stmt|;
name|cinfo
operator|->
name|min_DCT_v_scaled_size
operator|=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cinfo
operator|->
name|scale_num
operator|*
literal|5
operator|>=
name|cinfo
operator|->
name|scale_denom
operator|*
name|cinfo
operator|->
name|block_size
condition|)
block|{
comment|/* Provide block_size/5 scaling */
name|cinfo
operator|->
name|jpeg_width
operator|=
operator|(
name|JDIMENSION
operator|)
name|jdiv_round_up
argument_list|(
operator|(
name|long
operator|)
name|cinfo
operator|->
name|image_width
operator|*
name|cinfo
operator|->
name|block_size
argument_list|,
literal|5L
argument_list|)
expr_stmt|;
name|cinfo
operator|->
name|jpeg_height
operator|=
operator|(
name|JDIMENSION
operator|)
name|jdiv_round_up
argument_list|(
operator|(
name|long
operator|)
name|cinfo
operator|->
name|image_height
operator|*
name|cinfo
operator|->
name|block_size
argument_list|,
literal|5L
argument_list|)
expr_stmt|;
name|cinfo
operator|->
name|min_DCT_h_scaled_size
operator|=
literal|5
expr_stmt|;
name|cinfo
operator|->
name|min_DCT_v_scaled_size
operator|=
literal|5
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cinfo
operator|->
name|scale_num
operator|*
literal|6
operator|>=
name|cinfo
operator|->
name|scale_denom
operator|*
name|cinfo
operator|->
name|block_size
condition|)
block|{
comment|/* Provide block_size/6 scaling */
name|cinfo
operator|->
name|jpeg_width
operator|=
operator|(
name|JDIMENSION
operator|)
name|jdiv_round_up
argument_list|(
operator|(
name|long
operator|)
name|cinfo
operator|->
name|image_width
operator|*
name|cinfo
operator|->
name|block_size
argument_list|,
literal|6L
argument_list|)
expr_stmt|;
name|cinfo
operator|->
name|jpeg_height
operator|=
operator|(
name|JDIMENSION
operator|)
name|jdiv_round_up
argument_list|(
operator|(
name|long
operator|)
name|cinfo
operator|->
name|image_height
operator|*
name|cinfo
operator|->
name|block_size
argument_list|,
literal|6L
argument_list|)
expr_stmt|;
name|cinfo
operator|->
name|min_DCT_h_scaled_size
operator|=
literal|6
expr_stmt|;
name|cinfo
operator|->
name|min_DCT_v_scaled_size
operator|=
literal|6
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cinfo
operator|->
name|scale_num
operator|*
literal|7
operator|>=
name|cinfo
operator|->
name|scale_denom
operator|*
name|cinfo
operator|->
name|block_size
condition|)
block|{
comment|/* Provide block_size/7 scaling */
name|cinfo
operator|->
name|jpeg_width
operator|=
operator|(
name|JDIMENSION
operator|)
name|jdiv_round_up
argument_list|(
operator|(
name|long
operator|)
name|cinfo
operator|->
name|image_width
operator|*
name|cinfo
operator|->
name|block_size
argument_list|,
literal|7L
argument_list|)
expr_stmt|;
name|cinfo
operator|->
name|jpeg_height
operator|=
operator|(
name|JDIMENSION
operator|)
name|jdiv_round_up
argument_list|(
operator|(
name|long
operator|)
name|cinfo
operator|->
name|image_height
operator|*
name|cinfo
operator|->
name|block_size
argument_list|,
literal|7L
argument_list|)
expr_stmt|;
name|cinfo
operator|->
name|min_DCT_h_scaled_size
operator|=
literal|7
expr_stmt|;
name|cinfo
operator|->
name|min_DCT_v_scaled_size
operator|=
literal|7
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cinfo
operator|->
name|scale_num
operator|*
literal|8
operator|>=
name|cinfo
operator|->
name|scale_denom
operator|*
name|cinfo
operator|->
name|block_size
condition|)
block|{
comment|/* Provide block_size/8 scaling */
name|cinfo
operator|->
name|jpeg_width
operator|=
operator|(
name|JDIMENSION
operator|)
name|jdiv_round_up
argument_list|(
operator|(
name|long
operator|)
name|cinfo
operator|->
name|image_width
operator|*
name|cinfo
operator|->
name|block_size
argument_list|,
literal|8L
argument_list|)
expr_stmt|;
name|cinfo
operator|->
name|jpeg_height
operator|=
operator|(
name|JDIMENSION
operator|)
name|jdiv_round_up
argument_list|(
operator|(
name|long
operator|)
name|cinfo
operator|->
name|image_height
operator|*
name|cinfo
operator|->
name|block_size
argument_list|,
literal|8L
argument_list|)
expr_stmt|;
name|cinfo
operator|->
name|min_DCT_h_scaled_size
operator|=
literal|8
expr_stmt|;
name|cinfo
operator|->
name|min_DCT_v_scaled_size
operator|=
literal|8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cinfo
operator|->
name|scale_num
operator|*
literal|9
operator|>=
name|cinfo
operator|->
name|scale_denom
operator|*
name|cinfo
operator|->
name|block_size
condition|)
block|{
comment|/* Provide block_size/9 scaling */
name|cinfo
operator|->
name|jpeg_width
operator|=
operator|(
name|JDIMENSION
operator|)
name|jdiv_round_up
argument_list|(
operator|(
name|long
operator|)
name|cinfo
operator|->
name|image_width
operator|*
name|cinfo
operator|->
name|block_size
argument_list|,
literal|9L
argument_list|)
expr_stmt|;
name|cinfo
operator|->
name|jpeg_height
operator|=
operator|(
name|JDIMENSION
operator|)
name|jdiv_round_up
argument_list|(
operator|(
name|long
operator|)
name|cinfo
operator|->
name|image_height
operator|*
name|cinfo
operator|->
name|block_size
argument_list|,
literal|9L
argument_list|)
expr_stmt|;
name|cinfo
operator|->
name|min_DCT_h_scaled_size
operator|=
literal|9
expr_stmt|;
name|cinfo
operator|->
name|min_DCT_v_scaled_size
operator|=
literal|9
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cinfo
operator|->
name|scale_num
operator|*
literal|10
operator|>=
name|cinfo
operator|->
name|scale_denom
operator|*
name|cinfo
operator|->
name|block_size
condition|)
block|{
comment|/* Provide block_size/10 scaling */
name|cinfo
operator|->
name|jpeg_width
operator|=
operator|(
name|JDIMENSION
operator|)
name|jdiv_round_up
argument_list|(
operator|(
name|long
operator|)
name|cinfo
operator|->
name|image_width
operator|*
name|cinfo
operator|->
name|block_size
argument_list|,
literal|10L
argument_list|)
expr_stmt|;
name|cinfo
operator|->
name|jpeg_height
operator|=
operator|(
name|JDIMENSION
operator|)
name|jdiv_round_up
argument_list|(
operator|(
name|long
operator|)
name|cinfo
operator|->
name|image_height
operator|*
name|cinfo
operator|->
name|block_size
argument_list|,
literal|10L
argument_list|)
expr_stmt|;
name|cinfo
operator|->
name|min_DCT_h_scaled_size
operator|=
literal|10
expr_stmt|;
name|cinfo
operator|->
name|min_DCT_v_scaled_size
operator|=
literal|10
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cinfo
operator|->
name|scale_num
operator|*
literal|11
operator|>=
name|cinfo
operator|->
name|scale_denom
operator|*
name|cinfo
operator|->
name|block_size
condition|)
block|{
comment|/* Provide block_size/11 scaling */
name|cinfo
operator|->
name|jpeg_width
operator|=
operator|(
name|JDIMENSION
operator|)
name|jdiv_round_up
argument_list|(
operator|(
name|long
operator|)
name|cinfo
operator|->
name|image_width
operator|*
name|cinfo
operator|->
name|block_size
argument_list|,
literal|11L
argument_list|)
expr_stmt|;
name|cinfo
operator|->
name|jpeg_height
operator|=
operator|(
name|JDIMENSION
operator|)
name|jdiv_round_up
argument_list|(
operator|(
name|long
operator|)
name|cinfo
operator|->
name|image_height
operator|*
name|cinfo
operator|->
name|block_size
argument_list|,
literal|11L
argument_list|)
expr_stmt|;
name|cinfo
operator|->
name|min_DCT_h_scaled_size
operator|=
literal|11
expr_stmt|;
name|cinfo
operator|->
name|min_DCT_v_scaled_size
operator|=
literal|11
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cinfo
operator|->
name|scale_num
operator|*
literal|12
operator|>=
name|cinfo
operator|->
name|scale_denom
operator|*
name|cinfo
operator|->
name|block_size
condition|)
block|{
comment|/* Provide block_size/12 scaling */
name|cinfo
operator|->
name|jpeg_width
operator|=
operator|(
name|JDIMENSION
operator|)
name|jdiv_round_up
argument_list|(
operator|(
name|long
operator|)
name|cinfo
operator|->
name|image_width
operator|*
name|cinfo
operator|->
name|block_size
argument_list|,
literal|12L
argument_list|)
expr_stmt|;
name|cinfo
operator|->
name|jpeg_height
operator|=
operator|(
name|JDIMENSION
operator|)
name|jdiv_round_up
argument_list|(
operator|(
name|long
operator|)
name|cinfo
operator|->
name|image_height
operator|*
name|cinfo
operator|->
name|block_size
argument_list|,
literal|12L
argument_list|)
expr_stmt|;
name|cinfo
operator|->
name|min_DCT_h_scaled_size
operator|=
literal|12
expr_stmt|;
name|cinfo
operator|->
name|min_DCT_v_scaled_size
operator|=
literal|12
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cinfo
operator|->
name|scale_num
operator|*
literal|13
operator|>=
name|cinfo
operator|->
name|scale_denom
operator|*
name|cinfo
operator|->
name|block_size
condition|)
block|{
comment|/* Provide block_size/13 scaling */
name|cinfo
operator|->
name|jpeg_width
operator|=
operator|(
name|JDIMENSION
operator|)
name|jdiv_round_up
argument_list|(
operator|(
name|long
operator|)
name|cinfo
operator|->
name|image_width
operator|*
name|cinfo
operator|->
name|block_size
argument_list|,
literal|13L
argument_list|)
expr_stmt|;
name|cinfo
operator|->
name|jpeg_height
operator|=
operator|(
name|JDIMENSION
operator|)
name|jdiv_round_up
argument_list|(
operator|(
name|long
operator|)
name|cinfo
operator|->
name|image_height
operator|*
name|cinfo
operator|->
name|block_size
argument_list|,
literal|13L
argument_list|)
expr_stmt|;
name|cinfo
operator|->
name|min_DCT_h_scaled_size
operator|=
literal|13
expr_stmt|;
name|cinfo
operator|->
name|min_DCT_v_scaled_size
operator|=
literal|13
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cinfo
operator|->
name|scale_num
operator|*
literal|14
operator|>=
name|cinfo
operator|->
name|scale_denom
operator|*
name|cinfo
operator|->
name|block_size
condition|)
block|{
comment|/* Provide block_size/14 scaling */
name|cinfo
operator|->
name|jpeg_width
operator|=
operator|(
name|JDIMENSION
operator|)
name|jdiv_round_up
argument_list|(
operator|(
name|long
operator|)
name|cinfo
operator|->
name|image_width
operator|*
name|cinfo
operator|->
name|block_size
argument_list|,
literal|14L
argument_list|)
expr_stmt|;
name|cinfo
operator|->
name|jpeg_height
operator|=
operator|(
name|JDIMENSION
operator|)
name|jdiv_round_up
argument_list|(
operator|(
name|long
operator|)
name|cinfo
operator|->
name|image_height
operator|*
name|cinfo
operator|->
name|block_size
argument_list|,
literal|14L
argument_list|)
expr_stmt|;
name|cinfo
operator|->
name|min_DCT_h_scaled_size
operator|=
literal|14
expr_stmt|;
name|cinfo
operator|->
name|min_DCT_v_scaled_size
operator|=
literal|14
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cinfo
operator|->
name|scale_num
operator|*
literal|15
operator|>=
name|cinfo
operator|->
name|scale_denom
operator|*
name|cinfo
operator|->
name|block_size
condition|)
block|{
comment|/* Provide block_size/15 scaling */
name|cinfo
operator|->
name|jpeg_width
operator|=
operator|(
name|JDIMENSION
operator|)
name|jdiv_round_up
argument_list|(
operator|(
name|long
operator|)
name|cinfo
operator|->
name|image_width
operator|*
name|cinfo
operator|->
name|block_size
argument_list|,
literal|15L
argument_list|)
expr_stmt|;
name|cinfo
operator|->
name|jpeg_height
operator|=
operator|(
name|JDIMENSION
operator|)
name|jdiv_round_up
argument_list|(
operator|(
name|long
operator|)
name|cinfo
operator|->
name|image_height
operator|*
name|cinfo
operator|->
name|block_size
argument_list|,
literal|15L
argument_list|)
expr_stmt|;
name|cinfo
operator|->
name|min_DCT_h_scaled_size
operator|=
literal|15
expr_stmt|;
name|cinfo
operator|->
name|min_DCT_v_scaled_size
operator|=
literal|15
expr_stmt|;
block|}
else|else
block|{
comment|/* Provide block_size/16 scaling */
name|cinfo
operator|->
name|jpeg_width
operator|=
operator|(
name|JDIMENSION
operator|)
name|jdiv_round_up
argument_list|(
operator|(
name|long
operator|)
name|cinfo
operator|->
name|image_width
operator|*
name|cinfo
operator|->
name|block_size
argument_list|,
literal|16L
argument_list|)
expr_stmt|;
name|cinfo
operator|->
name|jpeg_height
operator|=
operator|(
name|JDIMENSION
operator|)
name|jdiv_round_up
argument_list|(
operator|(
name|long
operator|)
name|cinfo
operator|->
name|image_height
operator|*
name|cinfo
operator|->
name|block_size
argument_list|,
literal|16L
argument_list|)
expr_stmt|;
name|cinfo
operator|->
name|min_DCT_h_scaled_size
operator|=
literal|16
expr_stmt|;
name|cinfo
operator|->
name|min_DCT_v_scaled_size
operator|=
literal|16
expr_stmt|;
block|}
else|#
directive|else
comment|/* !DCT_SCALING_SUPPORTED */
comment|/* Hardwire it to "no scaling" */
name|cinfo
operator|->
name|jpeg_width
operator|=
name|cinfo
operator|->
name|image_width
expr_stmt|;
name|cinfo
operator|->
name|jpeg_height
operator|=
name|cinfo
operator|->
name|image_height
expr_stmt|;
name|cinfo
operator|->
name|min_DCT_h_scaled_size
operator|=
name|DCTSIZE
expr_stmt|;
name|cinfo
operator|->
name|min_DCT_v_scaled_size
operator|=
name|DCTSIZE
expr_stmt|;
endif|#
directive|endif
comment|/* DCT_SCALING_SUPPORTED */
block|}
end_block
begin_macro
name|LOCAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|jpeg_calc_trans_dimensions
name|jpeg_calc_trans_dimensions
argument_list|(
argument|j_compress_ptr cinfo
argument_list|)
end_macro
begin_block
block|{
if|if
condition|(
name|cinfo
operator|->
name|min_DCT_h_scaled_size
operator|!=
name|cinfo
operator|->
name|min_DCT_v_scaled_size
condition|)
name|ERREXIT2
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_DCTSIZE
argument_list|,
name|cinfo
operator|->
name|min_DCT_h_scaled_size
argument_list|,
name|cinfo
operator|->
name|min_DCT_v_scaled_size
argument_list|)
expr_stmt|;
name|cinfo
operator|->
name|block_size
operator|=
name|cinfo
operator|->
name|min_DCT_h_scaled_size
expr_stmt|;
block|}
end_block
begin_macro
name|LOCAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|initial_setup
name|initial_setup
argument_list|(
argument|j_compress_ptr cinfo
argument_list|,
argument|boolean transcode_only
argument_list|)
end_macro
begin_comment
comment|/* Do computations that are needed before master selection phase */
end_comment
begin_block
block|{
name|int
name|ci
decl_stmt|,
name|ssize
decl_stmt|;
name|jpeg_component_info
modifier|*
name|compptr
decl_stmt|;
name|long
name|samplesperrow
decl_stmt|;
name|JDIMENSION
name|jd_samplesperrow
decl_stmt|;
if|if
condition|(
name|transcode_only
condition|)
name|jpeg_calc_trans_dimensions
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
else|else
name|jpeg_calc_jpeg_dimensions
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
comment|/* Sanity check on block_size */
if|if
condition|(
name|cinfo
operator|->
name|block_size
operator|<
literal|1
operator|||
name|cinfo
operator|->
name|block_size
operator|>
literal|16
condition|)
name|ERREXIT2
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_DCTSIZE
argument_list|,
name|cinfo
operator|->
name|block_size
argument_list|,
name|cinfo
operator|->
name|block_size
argument_list|)
expr_stmt|;
comment|/* Derive natural_order from block_size */
switch|switch
condition|(
name|cinfo
operator|->
name|block_size
condition|)
block|{
case|case
literal|2
case|:
name|cinfo
operator|->
name|natural_order
operator|=
name|jpeg_natural_order2
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|cinfo
operator|->
name|natural_order
operator|=
name|jpeg_natural_order3
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|cinfo
operator|->
name|natural_order
operator|=
name|jpeg_natural_order4
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|cinfo
operator|->
name|natural_order
operator|=
name|jpeg_natural_order5
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|cinfo
operator|->
name|natural_order
operator|=
name|jpeg_natural_order6
expr_stmt|;
break|break;
case|case
literal|7
case|:
name|cinfo
operator|->
name|natural_order
operator|=
name|jpeg_natural_order7
expr_stmt|;
break|break;
default|default:
name|cinfo
operator|->
name|natural_order
operator|=
name|jpeg_natural_order
expr_stmt|;
break|break;
block|}
comment|/* Derive lim_Se from block_size */
name|cinfo
operator|->
name|lim_Se
operator|=
name|cinfo
operator|->
name|block_size
operator|<
name|DCTSIZE
condition|?
name|cinfo
operator|->
name|block_size
operator|*
name|cinfo
operator|->
name|block_size
operator|-
literal|1
else|:
name|DCTSIZE2
operator|-
literal|1
expr_stmt|;
comment|/* Sanity check on image dimensions */
if|if
condition|(
name|cinfo
operator|->
name|jpeg_height
operator|<=
literal|0
operator|||
name|cinfo
operator|->
name|jpeg_width
operator|<=
literal|0
operator|||
name|cinfo
operator|->
name|num_components
operator|<=
literal|0
operator|||
name|cinfo
operator|->
name|input_components
operator|<=
literal|0
condition|)
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_EMPTY_IMAGE
argument_list|)
expr_stmt|;
comment|/* Make sure image isn't bigger than I can handle */
if|if
condition|(
operator|(
name|long
operator|)
name|cinfo
operator|->
name|jpeg_height
operator|>
operator|(
name|long
operator|)
name|JPEG_MAX_DIMENSION
operator|||
operator|(
name|long
operator|)
name|cinfo
operator|->
name|jpeg_width
operator|>
operator|(
name|long
operator|)
name|JPEG_MAX_DIMENSION
condition|)
name|ERREXIT1
argument_list|(
name|cinfo
argument_list|,
name|JERR_IMAGE_TOO_BIG
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|JPEG_MAX_DIMENSION
argument_list|)
expr_stmt|;
comment|/* Width of an input scanline must be representable as JDIMENSION. */
name|samplesperrow
operator|=
operator|(
name|long
operator|)
name|cinfo
operator|->
name|image_width
operator|*
operator|(
name|long
operator|)
name|cinfo
operator|->
name|input_components
expr_stmt|;
name|jd_samplesperrow
operator|=
operator|(
name|JDIMENSION
operator|)
name|samplesperrow
expr_stmt|;
if|if
condition|(
operator|(
name|long
operator|)
name|jd_samplesperrow
operator|!=
name|samplesperrow
condition|)
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_WIDTH_OVERFLOW
argument_list|)
expr_stmt|;
comment|/* For now, precision must match compiled-in value... */
if|if
condition|(
name|cinfo
operator|->
name|data_precision
operator|!=
name|BITS_IN_JSAMPLE
condition|)
name|ERREXIT1
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_PRECISION
argument_list|,
name|cinfo
operator|->
name|data_precision
argument_list|)
expr_stmt|;
comment|/* Check that number of components won't exceed internal array sizes */
if|if
condition|(
name|cinfo
operator|->
name|num_components
operator|>
name|MAX_COMPONENTS
condition|)
name|ERREXIT2
argument_list|(
name|cinfo
argument_list|,
name|JERR_COMPONENT_COUNT
argument_list|,
name|cinfo
operator|->
name|num_components
argument_list|,
name|MAX_COMPONENTS
argument_list|)
expr_stmt|;
comment|/* Compute maximum sampling factors; check factor validity */
name|cinfo
operator|->
name|max_h_samp_factor
operator|=
literal|1
expr_stmt|;
name|cinfo
operator|->
name|max_v_samp_factor
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|ci
operator|=
literal|0
operator|,
name|compptr
operator|=
name|cinfo
operator|->
name|comp_info
init|;
name|ci
operator|<
name|cinfo
operator|->
name|num_components
condition|;
name|ci
operator|++
operator|,
name|compptr
operator|++
control|)
block|{
if|if
condition|(
name|compptr
operator|->
name|h_samp_factor
operator|<=
literal|0
operator|||
name|compptr
operator|->
name|h_samp_factor
operator|>
name|MAX_SAMP_FACTOR
operator|||
name|compptr
operator|->
name|v_samp_factor
operator|<=
literal|0
operator|||
name|compptr
operator|->
name|v_samp_factor
operator|>
name|MAX_SAMP_FACTOR
condition|)
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_SAMPLING
argument_list|)
expr_stmt|;
name|cinfo
operator|->
name|max_h_samp_factor
operator|=
name|MAX
argument_list|(
name|cinfo
operator|->
name|max_h_samp_factor
argument_list|,
name|compptr
operator|->
name|h_samp_factor
argument_list|)
expr_stmt|;
name|cinfo
operator|->
name|max_v_samp_factor
operator|=
name|MAX
argument_list|(
name|cinfo
operator|->
name|max_v_samp_factor
argument_list|,
name|compptr
operator|->
name|v_samp_factor
argument_list|)
expr_stmt|;
block|}
comment|/* Compute dimensions of components */
for|for
control|(
name|ci
operator|=
literal|0
operator|,
name|compptr
operator|=
name|cinfo
operator|->
name|comp_info
init|;
name|ci
operator|<
name|cinfo
operator|->
name|num_components
condition|;
name|ci
operator|++
operator|,
name|compptr
operator|++
control|)
block|{
comment|/* Fill in the correct component_index value; don't rely on application */
name|compptr
operator|->
name|component_index
operator|=
name|ci
expr_stmt|;
comment|/* In selecting the actual DCT scaling for each component, we try to      * scale down the chroma components via DCT scaling rather than downsampling.      * This saves time if the downsampler gets to use 1:1 scaling.      * Note this code adapts subsampling ratios which are powers of 2.      */
name|ssize
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|DCT_SCALING_SUPPORTED
while|while
condition|(
name|cinfo
operator|->
name|min_DCT_h_scaled_size
operator|*
name|ssize
operator|<=
operator|(
name|cinfo
operator|->
name|do_fancy_downsampling
condition|?
name|DCTSIZE
else|:
name|DCTSIZE
operator|/
literal|2
operator|)
operator|&&
operator|(
name|cinfo
operator|->
name|max_h_samp_factor
operator|%
operator|(
name|compptr
operator|->
name|h_samp_factor
operator|*
name|ssize
operator|*
literal|2
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|ssize
operator|=
name|ssize
operator|*
literal|2
expr_stmt|;
block|}
endif|#
directive|endif
name|compptr
operator|->
name|DCT_h_scaled_size
operator|=
name|cinfo
operator|->
name|min_DCT_h_scaled_size
operator|*
name|ssize
expr_stmt|;
name|ssize
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|DCT_SCALING_SUPPORTED
while|while
condition|(
name|cinfo
operator|->
name|min_DCT_v_scaled_size
operator|*
name|ssize
operator|<=
operator|(
name|cinfo
operator|->
name|do_fancy_downsampling
condition|?
name|DCTSIZE
else|:
name|DCTSIZE
operator|/
literal|2
operator|)
operator|&&
operator|(
name|cinfo
operator|->
name|max_v_samp_factor
operator|%
operator|(
name|compptr
operator|->
name|v_samp_factor
operator|*
name|ssize
operator|*
literal|2
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|ssize
operator|=
name|ssize
operator|*
literal|2
expr_stmt|;
block|}
endif|#
directive|endif
name|compptr
operator|->
name|DCT_v_scaled_size
operator|=
name|cinfo
operator|->
name|min_DCT_v_scaled_size
operator|*
name|ssize
expr_stmt|;
comment|/* We don't support DCT ratios larger than 2. */
if|if
condition|(
name|compptr
operator|->
name|DCT_h_scaled_size
operator|>
name|compptr
operator|->
name|DCT_v_scaled_size
operator|*
literal|2
condition|)
name|compptr
operator|->
name|DCT_h_scaled_size
operator|=
name|compptr
operator|->
name|DCT_v_scaled_size
operator|*
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|compptr
operator|->
name|DCT_v_scaled_size
operator|>
name|compptr
operator|->
name|DCT_h_scaled_size
operator|*
literal|2
condition|)
name|compptr
operator|->
name|DCT_v_scaled_size
operator|=
name|compptr
operator|->
name|DCT_h_scaled_size
operator|*
literal|2
expr_stmt|;
comment|/* Size in DCT blocks */
name|compptr
operator|->
name|width_in_blocks
operator|=
operator|(
name|JDIMENSION
operator|)
name|jdiv_round_up
argument_list|(
operator|(
name|long
operator|)
name|cinfo
operator|->
name|jpeg_width
operator|*
operator|(
name|long
operator|)
name|compptr
operator|->
name|h_samp_factor
argument_list|,
call|(
name|long
call|)
argument_list|(
name|cinfo
operator|->
name|max_h_samp_factor
operator|*
name|cinfo
operator|->
name|block_size
argument_list|)
argument_list|)
expr_stmt|;
name|compptr
operator|->
name|height_in_blocks
operator|=
operator|(
name|JDIMENSION
operator|)
name|jdiv_round_up
argument_list|(
operator|(
name|long
operator|)
name|cinfo
operator|->
name|jpeg_height
operator|*
operator|(
name|long
operator|)
name|compptr
operator|->
name|v_samp_factor
argument_list|,
call|(
name|long
call|)
argument_list|(
name|cinfo
operator|->
name|max_v_samp_factor
operator|*
name|cinfo
operator|->
name|block_size
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Size in samples */
name|compptr
operator|->
name|downsampled_width
operator|=
operator|(
name|JDIMENSION
operator|)
name|jdiv_round_up
argument_list|(
operator|(
name|long
operator|)
name|cinfo
operator|->
name|jpeg_width
operator|*
call|(
name|long
call|)
argument_list|(
name|compptr
operator|->
name|h_samp_factor
operator|*
name|compptr
operator|->
name|DCT_h_scaled_size
argument_list|)
argument_list|,
call|(
name|long
call|)
argument_list|(
name|cinfo
operator|->
name|max_h_samp_factor
operator|*
name|cinfo
operator|->
name|block_size
argument_list|)
argument_list|)
expr_stmt|;
name|compptr
operator|->
name|downsampled_height
operator|=
operator|(
name|JDIMENSION
operator|)
name|jdiv_round_up
argument_list|(
operator|(
name|long
operator|)
name|cinfo
operator|->
name|jpeg_height
operator|*
call|(
name|long
call|)
argument_list|(
name|compptr
operator|->
name|v_samp_factor
operator|*
name|compptr
operator|->
name|DCT_v_scaled_size
argument_list|)
argument_list|,
call|(
name|long
call|)
argument_list|(
name|cinfo
operator|->
name|max_v_samp_factor
operator|*
name|cinfo
operator|->
name|block_size
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Mark component needed (this flag isn't actually used for compression) */
name|compptr
operator|->
name|component_needed
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* Compute number of fully interleaved MCU rows (number of times that    * main controller will call coefficient controller).    */
name|cinfo
operator|->
name|total_iMCU_rows
operator|=
operator|(
name|JDIMENSION
operator|)
name|jdiv_round_up
argument_list|(
operator|(
name|long
operator|)
name|cinfo
operator|->
name|jpeg_height
argument_list|,
call|(
name|long
call|)
argument_list|(
name|cinfo
operator|->
name|max_v_samp_factor
operator|*
name|cinfo
operator|->
name|block_size
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block
begin_ifdef
ifdef|#
directive|ifdef
name|C_MULTISCAN_FILES_SUPPORTED
end_ifdef
begin_macro
name|LOCAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|validate_script
name|validate_script
argument_list|(
argument|j_compress_ptr cinfo
argument_list|)
end_macro
begin_comment
comment|/* Verify that the scan script in cinfo->scan_info[] is valid; also  * determine whether it uses progressive JPEG, and set cinfo->progressive_mode.  */
end_comment
begin_block
block|{
specifier|const
name|jpeg_scan_info
modifier|*
name|scanptr
decl_stmt|;
name|int
name|scanno
decl_stmt|,
name|ncomps
decl_stmt|,
name|ci
decl_stmt|,
name|coefi
decl_stmt|,
name|thisi
decl_stmt|;
name|int
name|Ss
decl_stmt|,
name|Se
decl_stmt|,
name|Ah
decl_stmt|,
name|Al
decl_stmt|;
name|boolean
name|component_sent
index|[
name|MAX_COMPONENTS
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|C_PROGRESSIVE_SUPPORTED
name|int
modifier|*
name|last_bitpos_ptr
decl_stmt|;
name|int
name|last_bitpos
index|[
name|MAX_COMPONENTS
index|]
index|[
name|DCTSIZE2
index|]
decl_stmt|;
comment|/* -1 until that coefficient has been seen; then last Al for it */
endif|#
directive|endif
if|if
condition|(
name|cinfo
operator|->
name|num_scans
operator|<=
literal|0
condition|)
name|ERREXIT1
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_SCAN_SCRIPT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* For sequential JPEG, all scans must have Ss=0, Se=DCTSIZE2-1;    * for progressive JPEG, no scan can have this.    */
name|scanptr
operator|=
name|cinfo
operator|->
name|scan_info
expr_stmt|;
if|if
condition|(
name|scanptr
operator|->
name|Ss
operator|!=
literal|0
operator|||
name|scanptr
operator|->
name|Se
operator|!=
name|DCTSIZE2
operator|-
literal|1
condition|)
block|{
ifdef|#
directive|ifdef
name|C_PROGRESSIVE_SUPPORTED
name|cinfo
operator|->
name|progressive_mode
operator|=
name|TRUE
expr_stmt|;
name|last_bitpos_ptr
operator|=
operator|&
name|last_bitpos
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|ci
operator|=
literal|0
init|;
name|ci
operator|<
name|cinfo
operator|->
name|num_components
condition|;
name|ci
operator|++
control|)
for|for
control|(
name|coefi
operator|=
literal|0
init|;
name|coefi
operator|<
name|DCTSIZE2
condition|;
name|coefi
operator|++
control|)
operator|*
name|last_bitpos_ptr
operator|++
operator|=
operator|-
literal|1
expr_stmt|;
else|#
directive|else
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_NOT_COMPILED
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|cinfo
operator|->
name|progressive_mode
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|ci
operator|=
literal|0
init|;
name|ci
operator|<
name|cinfo
operator|->
name|num_components
condition|;
name|ci
operator|++
control|)
name|component_sent
index|[
name|ci
index|]
operator|=
name|FALSE
expr_stmt|;
block|}
for|for
control|(
name|scanno
operator|=
literal|1
init|;
name|scanno
operator|<=
name|cinfo
operator|->
name|num_scans
condition|;
name|scanptr
operator|++
operator|,
name|scanno
operator|++
control|)
block|{
comment|/* Validate component indexes */
name|ncomps
operator|=
name|scanptr
operator|->
name|comps_in_scan
expr_stmt|;
if|if
condition|(
name|ncomps
operator|<=
literal|0
operator|||
name|ncomps
operator|>
name|MAX_COMPS_IN_SCAN
condition|)
name|ERREXIT2
argument_list|(
name|cinfo
argument_list|,
name|JERR_COMPONENT_COUNT
argument_list|,
name|ncomps
argument_list|,
name|MAX_COMPS_IN_SCAN
argument_list|)
expr_stmt|;
for|for
control|(
name|ci
operator|=
literal|0
init|;
name|ci
operator|<
name|ncomps
condition|;
name|ci
operator|++
control|)
block|{
name|thisi
operator|=
name|scanptr
operator|->
name|component_index
index|[
name|ci
index|]
expr_stmt|;
if|if
condition|(
name|thisi
operator|<
literal|0
operator|||
name|thisi
operator|>=
name|cinfo
operator|->
name|num_components
condition|)
name|ERREXIT1
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_SCAN_SCRIPT
argument_list|,
name|scanno
argument_list|)
expr_stmt|;
comment|/* Components must appear in SOF order within each scan */
if|if
condition|(
name|ci
operator|>
literal|0
operator|&&
name|thisi
operator|<=
name|scanptr
operator|->
name|component_index
index|[
name|ci
operator|-
literal|1
index|]
condition|)
name|ERREXIT1
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_SCAN_SCRIPT
argument_list|,
name|scanno
argument_list|)
expr_stmt|;
block|}
comment|/* Validate progression parameters */
name|Ss
operator|=
name|scanptr
operator|->
name|Ss
expr_stmt|;
name|Se
operator|=
name|scanptr
operator|->
name|Se
expr_stmt|;
name|Ah
operator|=
name|scanptr
operator|->
name|Ah
expr_stmt|;
name|Al
operator|=
name|scanptr
operator|->
name|Al
expr_stmt|;
if|if
condition|(
name|cinfo
operator|->
name|progressive_mode
condition|)
block|{
ifdef|#
directive|ifdef
name|C_PROGRESSIVE_SUPPORTED
comment|/* The JPEG spec simply gives the ranges 0..13 for Ah and Al, but that        * seems wrong: the upper bound ought to depend on data precision.        * Perhaps they really meant 0..N+1 for N-bit precision.        * Here we allow 0..10 for 8-bit data; Al larger than 10 results in        * out-of-range reconstructed DC values during the first DC scan,        * which might cause problems for some decoders.        */
if|#
directive|if
name|BITS_IN_JSAMPLE
operator|==
literal|8
DECL|macro|MAX_AH_AL
define|#
directive|define
name|MAX_AH_AL
value|10
else|#
directive|else
define|#
directive|define
name|MAX_AH_AL
value|13
endif|#
directive|endif
if|if
condition|(
name|Ss
operator|<
literal|0
operator|||
name|Ss
operator|>=
name|DCTSIZE2
operator|||
name|Se
operator|<
name|Ss
operator|||
name|Se
operator|>=
name|DCTSIZE2
operator|||
name|Ah
operator|<
literal|0
operator|||
name|Ah
operator|>
name|MAX_AH_AL
operator|||
name|Al
operator|<
literal|0
operator|||
name|Al
operator|>
name|MAX_AH_AL
condition|)
name|ERREXIT1
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_PROG_SCRIPT
argument_list|,
name|scanno
argument_list|)
expr_stmt|;
if|if
condition|(
name|Ss
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|Se
operator|!=
literal|0
condition|)
comment|/* DC and AC together not OK */
name|ERREXIT1
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_PROG_SCRIPT
argument_list|,
name|scanno
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ncomps
operator|!=
literal|1
condition|)
comment|/* AC scans must be for only one component */
name|ERREXIT1
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_PROG_SCRIPT
argument_list|,
name|scanno
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|ci
operator|=
literal|0
init|;
name|ci
operator|<
name|ncomps
condition|;
name|ci
operator|++
control|)
block|{
name|last_bitpos_ptr
operator|=
operator|&
name|last_bitpos
index|[
name|scanptr
operator|->
name|component_index
index|[
name|ci
index|]
index|]
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|Ss
operator|!=
literal|0
operator|&&
name|last_bitpos_ptr
index|[
literal|0
index|]
operator|<
literal|0
condition|)
comment|/* AC without prior DC scan */
name|ERREXIT1
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_PROG_SCRIPT
argument_list|,
name|scanno
argument_list|)
expr_stmt|;
for|for
control|(
name|coefi
operator|=
name|Ss
init|;
name|coefi
operator|<=
name|Se
condition|;
name|coefi
operator|++
control|)
block|{
if|if
condition|(
name|last_bitpos_ptr
index|[
name|coefi
index|]
operator|<
literal|0
condition|)
block|{
comment|/* first scan of this coefficient */
if|if
condition|(
name|Ah
operator|!=
literal|0
condition|)
name|ERREXIT1
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_PROG_SCRIPT
argument_list|,
name|scanno
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* not first scan */
if|if
condition|(
name|Ah
operator|!=
name|last_bitpos_ptr
index|[
name|coefi
index|]
operator|||
name|Al
operator|!=
name|Ah
operator|-
literal|1
condition|)
name|ERREXIT1
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_PROG_SCRIPT
argument_list|,
name|scanno
argument_list|)
expr_stmt|;
block|}
name|last_bitpos_ptr
index|[
name|coefi
index|]
operator|=
name|Al
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
else|else
block|{
comment|/* For sequential JPEG, all progression parameters must be these: */
if|if
condition|(
name|Ss
operator|!=
literal|0
operator|||
name|Se
operator|!=
name|DCTSIZE2
operator|-
literal|1
operator|||
name|Ah
operator|!=
literal|0
operator|||
name|Al
operator|!=
literal|0
condition|)
name|ERREXIT1
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_PROG_SCRIPT
argument_list|,
name|scanno
argument_list|)
expr_stmt|;
comment|/* Make sure components are not sent twice */
for|for
control|(
name|ci
operator|=
literal|0
init|;
name|ci
operator|<
name|ncomps
condition|;
name|ci
operator|++
control|)
block|{
name|thisi
operator|=
name|scanptr
operator|->
name|component_index
index|[
name|ci
index|]
expr_stmt|;
if|if
condition|(
name|component_sent
index|[
name|thisi
index|]
condition|)
name|ERREXIT1
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_SCAN_SCRIPT
argument_list|,
name|scanno
argument_list|)
expr_stmt|;
name|component_sent
index|[
name|thisi
index|]
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
comment|/* Now verify that everything got sent. */
if|if
condition|(
name|cinfo
operator|->
name|progressive_mode
condition|)
block|{
ifdef|#
directive|ifdef
name|C_PROGRESSIVE_SUPPORTED
comment|/* For progressive mode, we only check that at least some DC data      * got sent for each component; the spec does not require that all bits      * of all coefficients be transmitted.  Would it be wiser to enforce      * transmission of all coefficient bits??      */
for|for
control|(
name|ci
operator|=
literal|0
init|;
name|ci
operator|<
name|cinfo
operator|->
name|num_components
condition|;
name|ci
operator|++
control|)
block|{
if|if
condition|(
name|last_bitpos
index|[
name|ci
index|]
index|[
literal|0
index|]
operator|<
literal|0
condition|)
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_MISSING_DATA
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
else|else
block|{
for|for
control|(
name|ci
operator|=
literal|0
init|;
name|ci
operator|<
name|cinfo
operator|->
name|num_components
condition|;
name|ci
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|component_sent
index|[
name|ci
index|]
condition|)
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_MISSING_DATA
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block
begin_macro
name|LOCAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|reduce_script
name|reduce_script
argument_list|(
argument|j_compress_ptr cinfo
argument_list|)
end_macro
begin_comment
comment|/* Adapt scan script for use with reduced block size;  * assume that script has been validated before.  */
end_comment
begin_block
block|{
name|jpeg_scan_info
modifier|*
name|scanptr
decl_stmt|;
name|int
name|idxout
decl_stmt|,
name|idxin
decl_stmt|;
comment|/* Circumvent const declaration for this function */
name|scanptr
operator|=
operator|(
name|jpeg_scan_info
operator|*
operator|)
name|cinfo
operator|->
name|scan_info
expr_stmt|;
name|idxout
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|idxin
operator|=
literal|0
init|;
name|idxin
operator|<
name|cinfo
operator|->
name|num_scans
condition|;
name|idxin
operator|++
control|)
block|{
comment|/* After skipping, idxout becomes smaller than idxin */
if|if
condition|(
name|idxin
operator|!=
name|idxout
condition|)
comment|/* Copy rest of data;        * note we stay in given chunk of allocated memory.        */
name|scanptr
index|[
name|idxout
index|]
operator|=
name|scanptr
index|[
name|idxin
index|]
expr_stmt|;
if|if
condition|(
name|scanptr
index|[
name|idxout
index|]
operator|.
name|Ss
operator|>
name|cinfo
operator|->
name|lim_Se
condition|)
comment|/* Entire scan out of range - skip this entry */
continue|continue;
if|if
condition|(
name|scanptr
index|[
name|idxout
index|]
operator|.
name|Se
operator|>
name|cinfo
operator|->
name|lim_Se
condition|)
comment|/* Limit scan to end of block */
name|scanptr
index|[
name|idxout
index|]
operator|.
name|Se
operator|=
name|cinfo
operator|->
name|lim_Se
expr_stmt|;
name|idxout
operator|++
expr_stmt|;
block|}
name|cinfo
operator|->
name|num_scans
operator|=
name|idxout
expr_stmt|;
block|}
end_block
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* C_MULTISCAN_FILES_SUPPORTED */
end_comment
begin_macro
name|LOCAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|select_scan_parameters
name|select_scan_parameters
argument_list|(
argument|j_compress_ptr cinfo
argument_list|)
end_macro
begin_comment
comment|/* Set up the scan parameters for the current scan */
end_comment
begin_block
block|{
name|int
name|ci
decl_stmt|;
ifdef|#
directive|ifdef
name|C_MULTISCAN_FILES_SUPPORTED
if|if
condition|(
name|cinfo
operator|->
name|scan_info
operator|!=
name|NULL
condition|)
block|{
comment|/* Prepare for current scan --- the script is already validated */
name|my_master_ptr
name|master
init|=
operator|(
name|my_master_ptr
operator|)
name|cinfo
operator|->
name|master
decl_stmt|;
specifier|const
name|jpeg_scan_info
modifier|*
name|scanptr
init|=
name|cinfo
operator|->
name|scan_info
operator|+
name|master
operator|->
name|scan_number
decl_stmt|;
name|cinfo
operator|->
name|comps_in_scan
operator|=
name|scanptr
operator|->
name|comps_in_scan
expr_stmt|;
for|for
control|(
name|ci
operator|=
literal|0
init|;
name|ci
operator|<
name|scanptr
operator|->
name|comps_in_scan
condition|;
name|ci
operator|++
control|)
block|{
name|cinfo
operator|->
name|cur_comp_info
index|[
name|ci
index|]
operator|=
operator|&
name|cinfo
operator|->
name|comp_info
index|[
name|scanptr
operator|->
name|component_index
index|[
name|ci
index|]
index|]
expr_stmt|;
block|}
if|if
condition|(
name|cinfo
operator|->
name|progressive_mode
condition|)
block|{
name|cinfo
operator|->
name|Ss
operator|=
name|scanptr
operator|->
name|Ss
expr_stmt|;
name|cinfo
operator|->
name|Se
operator|=
name|scanptr
operator|->
name|Se
expr_stmt|;
name|cinfo
operator|->
name|Ah
operator|=
name|scanptr
operator|->
name|Ah
expr_stmt|;
name|cinfo
operator|->
name|Al
operator|=
name|scanptr
operator|->
name|Al
expr_stmt|;
return|return;
block|}
block|}
else|else
endif|#
directive|endif
block|{
comment|/* Prepare for single sequential-JPEG scan containing all components */
if|if
condition|(
name|cinfo
operator|->
name|num_components
operator|>
name|MAX_COMPS_IN_SCAN
condition|)
name|ERREXIT2
argument_list|(
name|cinfo
argument_list|,
name|JERR_COMPONENT_COUNT
argument_list|,
name|cinfo
operator|->
name|num_components
argument_list|,
name|MAX_COMPS_IN_SCAN
argument_list|)
expr_stmt|;
name|cinfo
operator|->
name|comps_in_scan
operator|=
name|cinfo
operator|->
name|num_components
expr_stmt|;
for|for
control|(
name|ci
operator|=
literal|0
init|;
name|ci
operator|<
name|cinfo
operator|->
name|num_components
condition|;
name|ci
operator|++
control|)
block|{
name|cinfo
operator|->
name|cur_comp_info
index|[
name|ci
index|]
operator|=
operator|&
name|cinfo
operator|->
name|comp_info
index|[
name|ci
index|]
expr_stmt|;
block|}
block|}
name|cinfo
operator|->
name|Ss
operator|=
literal|0
expr_stmt|;
name|cinfo
operator|->
name|Se
operator|=
name|cinfo
operator|->
name|block_size
operator|*
name|cinfo
operator|->
name|block_size
operator|-
literal|1
expr_stmt|;
name|cinfo
operator|->
name|Ah
operator|=
literal|0
expr_stmt|;
name|cinfo
operator|->
name|Al
operator|=
literal|0
expr_stmt|;
block|}
end_block
begin_macro
name|LOCAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|per_scan_setup
name|per_scan_setup
argument_list|(
argument|j_compress_ptr cinfo
argument_list|)
end_macro
begin_comment
comment|/* Do computations that are needed before processing a JPEG scan */
end_comment
begin_comment
comment|/* cinfo->comps_in_scan and cinfo->cur_comp_info[] are already set */
end_comment
begin_block
block|{
name|int
name|ci
decl_stmt|,
name|mcublks
decl_stmt|,
name|tmp
decl_stmt|;
name|jpeg_component_info
modifier|*
name|compptr
decl_stmt|;
if|if
condition|(
name|cinfo
operator|->
name|comps_in_scan
operator|==
literal|1
condition|)
block|{
comment|/* Noninterleaved (single-component) scan */
name|compptr
operator|=
name|cinfo
operator|->
name|cur_comp_info
index|[
literal|0
index|]
expr_stmt|;
comment|/* Overall image size in MCUs */
name|cinfo
operator|->
name|MCUs_per_row
operator|=
name|compptr
operator|->
name|width_in_blocks
expr_stmt|;
name|cinfo
operator|->
name|MCU_rows_in_scan
operator|=
name|compptr
operator|->
name|height_in_blocks
expr_stmt|;
comment|/* For noninterleaved scan, always one block per MCU */
name|compptr
operator|->
name|MCU_width
operator|=
literal|1
expr_stmt|;
name|compptr
operator|->
name|MCU_height
operator|=
literal|1
expr_stmt|;
name|compptr
operator|->
name|MCU_blocks
operator|=
literal|1
expr_stmt|;
name|compptr
operator|->
name|MCU_sample_width
operator|=
name|compptr
operator|->
name|DCT_h_scaled_size
expr_stmt|;
name|compptr
operator|->
name|last_col_width
operator|=
literal|1
expr_stmt|;
comment|/* For noninterleaved scans, it is convenient to define last_row_height      * as the number of block rows present in the last iMCU row.      */
name|tmp
operator|=
call|(
name|int
call|)
argument_list|(
name|compptr
operator|->
name|height_in_blocks
operator|%
name|compptr
operator|->
name|v_samp_factor
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
literal|0
condition|)
name|tmp
operator|=
name|compptr
operator|->
name|v_samp_factor
expr_stmt|;
name|compptr
operator|->
name|last_row_height
operator|=
name|tmp
expr_stmt|;
comment|/* Prepare array describing MCU composition */
name|cinfo
operator|->
name|blocks_in_MCU
operator|=
literal|1
expr_stmt|;
name|cinfo
operator|->
name|MCU_membership
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Interleaved (multi-component) scan */
if|if
condition|(
name|cinfo
operator|->
name|comps_in_scan
operator|<=
literal|0
operator|||
name|cinfo
operator|->
name|comps_in_scan
operator|>
name|MAX_COMPS_IN_SCAN
condition|)
name|ERREXIT2
argument_list|(
name|cinfo
argument_list|,
name|JERR_COMPONENT_COUNT
argument_list|,
name|cinfo
operator|->
name|comps_in_scan
argument_list|,
name|MAX_COMPS_IN_SCAN
argument_list|)
expr_stmt|;
comment|/* Overall image size in MCUs */
name|cinfo
operator|->
name|MCUs_per_row
operator|=
operator|(
name|JDIMENSION
operator|)
name|jdiv_round_up
argument_list|(
operator|(
name|long
operator|)
name|cinfo
operator|->
name|jpeg_width
argument_list|,
call|(
name|long
call|)
argument_list|(
name|cinfo
operator|->
name|max_h_samp_factor
operator|*
name|cinfo
operator|->
name|block_size
argument_list|)
argument_list|)
expr_stmt|;
name|cinfo
operator|->
name|MCU_rows_in_scan
operator|=
operator|(
name|JDIMENSION
operator|)
name|jdiv_round_up
argument_list|(
operator|(
name|long
operator|)
name|cinfo
operator|->
name|jpeg_height
argument_list|,
call|(
name|long
call|)
argument_list|(
name|cinfo
operator|->
name|max_v_samp_factor
operator|*
name|cinfo
operator|->
name|block_size
argument_list|)
argument_list|)
expr_stmt|;
name|cinfo
operator|->
name|blocks_in_MCU
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ci
operator|=
literal|0
init|;
name|ci
operator|<
name|cinfo
operator|->
name|comps_in_scan
condition|;
name|ci
operator|++
control|)
block|{
name|compptr
operator|=
name|cinfo
operator|->
name|cur_comp_info
index|[
name|ci
index|]
expr_stmt|;
comment|/* Sampling factors give # of blocks of component in each MCU */
name|compptr
operator|->
name|MCU_width
operator|=
name|compptr
operator|->
name|h_samp_factor
expr_stmt|;
name|compptr
operator|->
name|MCU_height
operator|=
name|compptr
operator|->
name|v_samp_factor
expr_stmt|;
name|compptr
operator|->
name|MCU_blocks
operator|=
name|compptr
operator|->
name|MCU_width
operator|*
name|compptr
operator|->
name|MCU_height
expr_stmt|;
name|compptr
operator|->
name|MCU_sample_width
operator|=
name|compptr
operator|->
name|MCU_width
operator|*
name|compptr
operator|->
name|DCT_h_scaled_size
expr_stmt|;
comment|/* Figure number of non-dummy blocks in last MCU column& row */
name|tmp
operator|=
call|(
name|int
call|)
argument_list|(
name|compptr
operator|->
name|width_in_blocks
operator|%
name|compptr
operator|->
name|MCU_width
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
literal|0
condition|)
name|tmp
operator|=
name|compptr
operator|->
name|MCU_width
expr_stmt|;
name|compptr
operator|->
name|last_col_width
operator|=
name|tmp
expr_stmt|;
name|tmp
operator|=
call|(
name|int
call|)
argument_list|(
name|compptr
operator|->
name|height_in_blocks
operator|%
name|compptr
operator|->
name|MCU_height
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
literal|0
condition|)
name|tmp
operator|=
name|compptr
operator|->
name|MCU_height
expr_stmt|;
name|compptr
operator|->
name|last_row_height
operator|=
name|tmp
expr_stmt|;
comment|/* Prepare array describing MCU composition */
name|mcublks
operator|=
name|compptr
operator|->
name|MCU_blocks
expr_stmt|;
if|if
condition|(
name|cinfo
operator|->
name|blocks_in_MCU
operator|+
name|mcublks
operator|>
name|C_MAX_BLOCKS_IN_MCU
condition|)
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_MCU_SIZE
argument_list|)
expr_stmt|;
while|while
condition|(
name|mcublks
operator|--
operator|>
literal|0
condition|)
block|{
name|cinfo
operator|->
name|MCU_membership
index|[
name|cinfo
operator|->
name|blocks_in_MCU
operator|++
index|]
operator|=
name|ci
expr_stmt|;
block|}
block|}
block|}
comment|/* Convert restart specified in rows to actual MCU count. */
comment|/* Note that count must fit in 16 bits, so we provide limiting. */
if|if
condition|(
name|cinfo
operator|->
name|restart_in_rows
operator|>
literal|0
condition|)
block|{
name|long
name|nominal
init|=
operator|(
name|long
operator|)
name|cinfo
operator|->
name|restart_in_rows
operator|*
operator|(
name|long
operator|)
name|cinfo
operator|->
name|MCUs_per_row
decl_stmt|;
name|cinfo
operator|->
name|restart_interval
operator|=
operator|(
name|unsigned
name|int
operator|)
name|MIN
argument_list|(
name|nominal
argument_list|,
literal|65535L
argument_list|)
expr_stmt|;
block|}
block|}
end_block
begin_comment
comment|/*  * Per-pass setup.  * This is called at the beginning of each pass.  We determine which modules  * will be active during this pass and give them appropriate start_pass calls.  * We also set is_last_pass to indicate whether any more passes will be  * required.  */
end_comment
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|prepare_for_pass
name|prepare_for_pass
argument_list|(
argument|j_compress_ptr cinfo
argument_list|)
end_macro
begin_block
block|{
name|my_master_ptr
name|master
init|=
operator|(
name|my_master_ptr
operator|)
name|cinfo
operator|->
name|master
decl_stmt|;
switch|switch
condition|(
name|master
operator|->
name|pass_type
condition|)
block|{
case|case
name|main_pass
case|:
comment|/* Initial pass: will collect input data, and do either Huffman      * optimization or data output for the first scan.      */
name|select_scan_parameters
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
name|per_scan_setup
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cinfo
operator|->
name|raw_data_in
condition|)
block|{
call|(
modifier|*
name|cinfo
operator|->
name|cconvert
operator|->
name|start_pass
call|)
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
call|(
modifier|*
name|cinfo
operator|->
name|downsample
operator|->
name|start_pass
call|)
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
call|(
modifier|*
name|cinfo
operator|->
name|prep
operator|->
name|start_pass
call|)
argument_list|(
name|cinfo
argument_list|,
name|JBUF_PASS_THRU
argument_list|)
expr_stmt|;
block|}
call|(
modifier|*
name|cinfo
operator|->
name|fdct
operator|->
name|start_pass
call|)
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
call|(
modifier|*
name|cinfo
operator|->
name|entropy
operator|->
name|start_pass
call|)
argument_list|(
name|cinfo
argument_list|,
name|cinfo
operator|->
name|optimize_coding
argument_list|)
expr_stmt|;
call|(
modifier|*
name|cinfo
operator|->
name|coef
operator|->
name|start_pass
call|)
argument_list|(
name|cinfo
argument_list|,
operator|(
name|master
operator|->
name|total_passes
operator|>
literal|1
condition|?
name|JBUF_SAVE_AND_PASS
else|:
name|JBUF_PASS_THRU
operator|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|cinfo
operator|->
expr|main
operator|->
name|start_pass
operator|)
operator|(
name|cinfo
operator|,
name|JBUF_PASS_THRU
operator|)
expr_stmt|;
if|if
condition|(
name|cinfo
operator|->
name|optimize_coding
condition|)
block|{
comment|/* No immediate data output; postpone writing frame/scan headers */
name|master
operator|->
name|pub
operator|.
name|call_pass_startup
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
comment|/* Will write frame/scan headers at first jpeg_write_scanlines call */
name|master
operator|->
name|pub
operator|.
name|call_pass_startup
operator|=
name|TRUE
expr_stmt|;
block|}
break|break;
ifdef|#
directive|ifdef
name|ENTROPY_OPT_SUPPORTED
case|case
name|huff_opt_pass
case|:
comment|/* Do Huffman optimization for a scan after the first one. */
name|select_scan_parameters
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
name|per_scan_setup
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|cinfo
operator|->
name|Ss
operator|!=
literal|0
operator|||
name|cinfo
operator|->
name|Ah
operator|==
literal|0
condition|)
block|{
call|(
modifier|*
name|cinfo
operator|->
name|entropy
operator|->
name|start_pass
call|)
argument_list|(
name|cinfo
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
call|(
modifier|*
name|cinfo
operator|->
name|coef
operator|->
name|start_pass
call|)
argument_list|(
name|cinfo
argument_list|,
name|JBUF_CRANK_DEST
argument_list|)
expr_stmt|;
name|master
operator|->
name|pub
operator|.
name|call_pass_startup
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
comment|/* Special case: Huffman DC refinement scans need no Huffman table      * and therefore we can skip the optimization pass for them.      */
name|master
operator|->
name|pass_type
operator|=
name|output_pass
expr_stmt|;
name|master
operator|->
name|pass_number
operator|++
expr_stmt|;
comment|/*FALLTHROUGH*/
endif|#
directive|endif
case|case
name|output_pass
case|:
comment|/* Do a data-output pass. */
comment|/* We need not repeat per-scan setup if prior optimization pass did it. */
if|if
condition|(
operator|!
name|cinfo
operator|->
name|optimize_coding
condition|)
block|{
name|select_scan_parameters
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
name|per_scan_setup
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
block|}
call|(
modifier|*
name|cinfo
operator|->
name|entropy
operator|->
name|start_pass
call|)
argument_list|(
name|cinfo
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
call|(
modifier|*
name|cinfo
operator|->
name|coef
operator|->
name|start_pass
call|)
argument_list|(
name|cinfo
argument_list|,
name|JBUF_CRANK_DEST
argument_list|)
expr_stmt|;
comment|/* We emit frame/scan headers now */
if|if
condition|(
name|master
operator|->
name|scan_number
operator|==
literal|0
condition|)
call|(
modifier|*
name|cinfo
operator|->
name|marker
operator|->
name|write_frame_header
call|)
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
call|(
modifier|*
name|cinfo
operator|->
name|marker
operator|->
name|write_scan_header
call|)
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
name|master
operator|->
name|pub
operator|.
name|call_pass_startup
operator|=
name|FALSE
expr_stmt|;
break|break;
default|default:
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_NOT_COMPILED
argument_list|)
expr_stmt|;
block|}
name|master
operator|->
name|pub
operator|.
name|is_last_pass
operator|=
operator|(
name|master
operator|->
name|pass_number
operator|==
name|master
operator|->
name|total_passes
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* Set up progress monitor's pass info if present */
if|if
condition|(
name|cinfo
operator|->
name|progress
operator|!=
name|NULL
condition|)
block|{
name|cinfo
operator|->
name|progress
operator|->
name|completed_passes
operator|=
name|master
operator|->
name|pass_number
expr_stmt|;
name|cinfo
operator|->
name|progress
operator|->
name|total_passes
operator|=
name|master
operator|->
name|total_passes
expr_stmt|;
block|}
block|}
end_block
begin_comment
comment|/*  * Special start-of-pass hook.  * This is called by jpeg_write_scanlines if call_pass_startup is TRUE.  * In single-pass processing, we need this hook because we don't want to  * write frame/scan headers during jpeg_start_compress; we want to let the  * application write COM markers etc. between jpeg_start_compress and the  * jpeg_write_scanlines loop.  * In multi-pass processing, this routine is not used.  */
end_comment
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|pass_startup
name|pass_startup
argument_list|(
argument|j_compress_ptr cinfo
argument_list|)
end_macro
begin_block
block|{
name|cinfo
operator|->
name|master
operator|->
name|call_pass_startup
operator|=
name|FALSE
expr_stmt|;
comment|/* reset flag so call only once */
call|(
modifier|*
name|cinfo
operator|->
name|marker
operator|->
name|write_frame_header
call|)
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
call|(
modifier|*
name|cinfo
operator|->
name|marker
operator|->
name|write_scan_header
call|)
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
block|}
end_block
begin_comment
comment|/*  * Finish up at end of pass.  */
end_comment
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|finish_pass_master
name|finish_pass_master
argument_list|(
argument|j_compress_ptr cinfo
argument_list|)
end_macro
begin_block
block|{
name|my_master_ptr
name|master
init|=
operator|(
name|my_master_ptr
operator|)
name|cinfo
operator|->
name|master
decl_stmt|;
comment|/* The entropy coder always needs an end-of-pass call,    * either to analyze statistics or to flush its output buffer.    */
call|(
modifier|*
name|cinfo
operator|->
name|entropy
operator|->
name|finish_pass
call|)
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
comment|/* Update state for next pass */
switch|switch
condition|(
name|master
operator|->
name|pass_type
condition|)
block|{
case|case
name|main_pass
case|:
comment|/* next pass is either output of scan 0 (after optimization)      * or output of scan 1 (if no optimization).      */
name|master
operator|->
name|pass_type
operator|=
name|output_pass
expr_stmt|;
if|if
condition|(
operator|!
name|cinfo
operator|->
name|optimize_coding
condition|)
name|master
operator|->
name|scan_number
operator|++
expr_stmt|;
break|break;
case|case
name|huff_opt_pass
case|:
comment|/* next pass is always output of current scan */
name|master
operator|->
name|pass_type
operator|=
name|output_pass
expr_stmt|;
break|break;
case|case
name|output_pass
case|:
comment|/* next pass is either optimization or output of next scan */
if|if
condition|(
name|cinfo
operator|->
name|optimize_coding
condition|)
name|master
operator|->
name|pass_type
operator|=
name|huff_opt_pass
expr_stmt|;
name|master
operator|->
name|scan_number
operator|++
expr_stmt|;
break|break;
block|}
name|master
operator|->
name|pass_number
operator|++
expr_stmt|;
block|}
end_block
begin_comment
comment|/*  * Initialize master compression control.  */
end_comment
begin_macro
name|GLOBAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|jinit_c_master_control
name|jinit_c_master_control
argument_list|(
argument|j_compress_ptr cinfo
argument_list|,
argument|boolean transcode_only
argument_list|)
end_macro
begin_block
block|{
name|my_master_ptr
name|master
decl_stmt|;
name|master
operator|=
call|(
name|my_master_ptr
call|)
argument_list|(
operator|*
name|cinfo
operator|->
name|mem
operator|->
name|alloc_small
argument_list|)
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|,
name|JPOOL_IMAGE
argument_list|,
name|SIZEOF
argument_list|(
name|my_comp_master
argument_list|)
argument_list|)
expr_stmt|;
name|cinfo
operator|->
name|master
operator|=
operator|(
expr|struct
name|jpeg_comp_master
operator|*
operator|)
name|master
expr_stmt|;
name|master
operator|->
name|pub
operator|.
name|prepare_for_pass
operator|=
name|prepare_for_pass
expr_stmt|;
name|master
operator|->
name|pub
operator|.
name|pass_startup
operator|=
name|pass_startup
expr_stmt|;
name|master
operator|->
name|pub
operator|.
name|finish_pass
operator|=
name|finish_pass_master
expr_stmt|;
name|master
operator|->
name|pub
operator|.
name|is_last_pass
operator|=
name|FALSE
expr_stmt|;
comment|/* Validate parameters, determine derived values */
name|initial_setup
argument_list|(
name|cinfo
argument_list|,
name|transcode_only
argument_list|)
expr_stmt|;
if|if
condition|(
name|cinfo
operator|->
name|scan_info
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|C_MULTISCAN_FILES_SUPPORTED
name|validate_script
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|cinfo
operator|->
name|block_size
operator|<
name|DCTSIZE
condition|)
name|reduce_script
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
else|#
directive|else
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_NOT_COMPILED
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|cinfo
operator|->
name|progressive_mode
operator|=
name|FALSE
expr_stmt|;
name|cinfo
operator|->
name|num_scans
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|cinfo
operator|->
name|progressive_mode
operator|||
name|cinfo
operator|->
name|block_size
operator|<
name|DCTSIZE
operator|)
operator|&&
operator|!
name|cinfo
operator|->
name|arith_code
condition|)
comment|/*  TEMPORARY HACK ??? */
comment|/* assume default tables no good for progressive or downscale mode */
name|cinfo
operator|->
name|optimize_coding
operator|=
name|TRUE
expr_stmt|;
comment|/* Initialize my private state */
if|if
condition|(
name|transcode_only
condition|)
block|{
comment|/* no main pass in transcoding */
if|if
condition|(
name|cinfo
operator|->
name|optimize_coding
condition|)
name|master
operator|->
name|pass_type
operator|=
name|huff_opt_pass
expr_stmt|;
else|else
name|master
operator|->
name|pass_type
operator|=
name|output_pass
expr_stmt|;
block|}
else|else
block|{
comment|/* for normal compression, first pass is always this type: */
name|master
operator|->
name|pass_type
operator|=
name|main_pass
expr_stmt|;
block|}
name|master
operator|->
name|scan_number
operator|=
literal|0
expr_stmt|;
name|master
operator|->
name|pass_number
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cinfo
operator|->
name|optimize_coding
condition|)
name|master
operator|->
name|total_passes
operator|=
name|cinfo
operator|->
name|num_scans
operator|*
literal|2
expr_stmt|;
else|else
name|master
operator|->
name|total_passes
operator|=
name|cinfo
operator|->
name|num_scans
expr_stmt|;
block|}
end_block
end_unit
