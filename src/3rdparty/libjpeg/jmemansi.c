begin_unit
begin_comment
comment|/*  * jmemansi.c  *  * Copyright (C) 1992-1996, Thomas G. Lane.  * This file is part of the Independent JPEG Group's software.  * For conditions of distribution and use, see the accompanying README file.  *  * This file provides a simple generic implementation of the system-  * dependent portion of the JPEG memory manager.  This implementation  * assumes that you have the ANSI-standard library routine tmpfile().  * Also, the problem of determining the amount of memory available  * is shoved onto the user.  */
end_comment
begin_define
DECL|macro|JPEG_INTERNALS
define|#
directive|define
name|JPEG_INTERNALS
end_define
begin_include
include|#
directive|include
file|"jinclude.h"
end_include
begin_include
include|#
directive|include
file|"jpeglib.h"
end_include
begin_include
include|#
directive|include
file|"jmemsys.h"
end_include
begin_comment
comment|/* import the system-dependent declarations */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_STDLIB_H
end_ifndef
begin_comment
comment|/*<stdlib.h> should declare malloc(),free() */
end_comment
begin_decl_stmt
specifier|extern
name|void
modifier|*
name|malloc
name|JPP
argument_list|(
operator|(
name|size_t
name|size
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt
begin_decl_stmt
specifier|extern
name|void
name|free
name|JPP
argument_list|(
operator|(
name|void
operator|*
name|ptr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|SEEK_SET
end_ifndef
begin_comment
comment|/* pre-ANSI systems may not define this; */
end_comment
begin_define
DECL|macro|SEEK_SET
define|#
directive|define
name|SEEK_SET
value|0
end_define
begin_comment
DECL|macro|SEEK_SET
comment|/* if not, assume 0 is correct */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*  * Memory allocation and freeing are controlled by the regular library  * routines malloc() and free().  */
end_comment
begin_macro
name|GLOBAL
argument_list|(
argument|void *
argument_list|)
end_macro
begin_macro
DECL|function|jpeg_get_small
name|jpeg_get_small
argument_list|(
argument|j_common_ptr cinfo
argument_list|,
argument|size_t sizeofobject
argument_list|)
end_macro
begin_block
block|{
return|return
operator|(
name|void
operator|*
operator|)
name|malloc
argument_list|(
name|sizeofobject
argument_list|)
return|;
block|}
end_block
begin_macro
name|GLOBAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|jpeg_free_small
name|jpeg_free_small
argument_list|(
argument|j_common_ptr cinfo
argument_list|,
argument|void * object
argument_list|,
argument|size_t sizeofobject
argument_list|)
end_macro
begin_block
block|{
name|free
argument_list|(
name|object
argument_list|)
expr_stmt|;
block|}
end_block
begin_comment
comment|/*  * "Large" objects are treated the same as "small" ones.  * NB: although we include FAR keywords in the routine declarations,  * this file won't actually work in 80x86 small/medium model; at least,  * you probably won't be able to process useful-size images in only 64KB.  */
end_comment
begin_macro
name|GLOBAL
argument_list|(
argument|void FAR *
argument_list|)
end_macro
begin_macro
DECL|function|jpeg_get_large
name|jpeg_get_large
argument_list|(
argument|j_common_ptr cinfo
argument_list|,
argument|size_t sizeofobject
argument_list|)
end_macro
begin_block
block|{
return|return
operator|(
name|void
name|FAR
operator|*
operator|)
name|malloc
argument_list|(
name|sizeofobject
argument_list|)
return|;
block|}
end_block
begin_macro
name|GLOBAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|jpeg_free_large
name|jpeg_free_large
argument_list|(
argument|j_common_ptr cinfo
argument_list|,
argument|void FAR * object
argument_list|,
argument|size_t sizeofobject
argument_list|)
end_macro
begin_block
block|{
name|free
argument_list|(
name|object
argument_list|)
expr_stmt|;
block|}
end_block
begin_comment
comment|/*  * This routine computes the total memory space available for allocation.  * It's impossible to do this in a portable way; our current solution is  * to make the user tell us (with a default value set at compile time).  * If you can actually get the available space, it's a good idea to subtract  * a slop factor of 5% or so.  */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|DEFAULT_MAX_MEM
end_ifndef
begin_comment
comment|/* so can override from makefile */
end_comment
begin_define
DECL|macro|DEFAULT_MAX_MEM
define|#
directive|define
name|DEFAULT_MAX_MEM
value|1000000L
end_define
begin_comment
DECL|macro|DEFAULT_MAX_MEM
comment|/* default: one megabyte */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_macro
name|GLOBAL
argument_list|(
argument|long
argument_list|)
end_macro
begin_macro
DECL|function|jpeg_mem_available
name|jpeg_mem_available
argument_list|(
argument|j_common_ptr cinfo
argument_list|,
argument|long min_bytes_needed
argument_list|,
argument|long max_bytes_needed
argument_list|,
argument|long already_allocated
argument_list|)
end_macro
begin_block
block|{
return|return
name|cinfo
operator|->
name|mem
operator|->
name|max_memory_to_use
operator|-
name|already_allocated
return|;
block|}
end_block
begin_comment
comment|/*  * Backing store (temporary file) management.  * Backing store objects are only used when the value returned by  * jpeg_mem_available is less than the total space needed.  You can dispense  * with these routines if you have plenty of virtual memory; see jmemnobs.c.  */
end_comment
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|read_backing_store
name|read_backing_store
argument_list|(
argument|j_common_ptr cinfo
argument_list|,
argument|backing_store_ptr info
argument_list|,
argument|void FAR * buffer_address
argument_list|,
argument|long file_offset
argument_list|,
argument|long byte_count
argument_list|)
end_macro
begin_block
block|{
if|if
condition|(
name|fseek
argument_list|(
name|info
operator|->
name|temp_file
argument_list|,
name|file_offset
argument_list|,
name|SEEK_SET
argument_list|)
condition|)
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_TFILE_SEEK
argument_list|)
expr_stmt|;
if|if
condition|(
name|JFREAD
argument_list|(
name|info
operator|->
name|temp_file
argument_list|,
name|buffer_address
argument_list|,
name|byte_count
argument_list|)
operator|!=
operator|(
name|size_t
operator|)
name|byte_count
condition|)
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_TFILE_READ
argument_list|)
expr_stmt|;
block|}
end_block
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|write_backing_store
name|write_backing_store
argument_list|(
argument|j_common_ptr cinfo
argument_list|,
argument|backing_store_ptr info
argument_list|,
argument|void FAR * buffer_address
argument_list|,
argument|long file_offset
argument_list|,
argument|long byte_count
argument_list|)
end_macro
begin_block
block|{
if|if
condition|(
name|fseek
argument_list|(
name|info
operator|->
name|temp_file
argument_list|,
name|file_offset
argument_list|,
name|SEEK_SET
argument_list|)
condition|)
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_TFILE_SEEK
argument_list|)
expr_stmt|;
if|if
condition|(
name|JFWRITE
argument_list|(
name|info
operator|->
name|temp_file
argument_list|,
name|buffer_address
argument_list|,
name|byte_count
argument_list|)
operator|!=
operator|(
name|size_t
operator|)
name|byte_count
condition|)
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_TFILE_WRITE
argument_list|)
expr_stmt|;
block|}
end_block
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|close_backing_store
name|close_backing_store
argument_list|(
argument|j_common_ptr cinfo
argument_list|,
argument|backing_store_ptr info
argument_list|)
end_macro
begin_block
block|{
name|fclose
argument_list|(
name|info
operator|->
name|temp_file
argument_list|)
expr_stmt|;
comment|/* Since this implementation uses tmpfile() to create the file,    * no explicit file deletion is needed.    */
block|}
end_block
begin_comment
comment|/*  * Initial opening of a backing-store object.  *  * This version uses tmpfile(), which constructs a suitable file name  * behind the scenes.  We don't have to use info->temp_name[] at all;  * indeed, we can't even find out the actual name of the temp file.  */
end_comment
begin_macro
name|GLOBAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|jpeg_open_backing_store
name|jpeg_open_backing_store
argument_list|(
argument|j_common_ptr cinfo
argument_list|,
argument|backing_store_ptr info
argument_list|,
argument|long total_bytes_needed
argument_list|)
end_macro
begin_block
block|{
if|if
condition|(
operator|(
name|info
operator|->
name|temp_file
operator|=
name|tmpfile
argument_list|()
operator|)
operator|==
name|NULL
condition|)
name|ERREXITS
argument_list|(
name|cinfo
argument_list|,
name|JERR_TFILE_CREATE
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|info
operator|->
name|read_backing_store
operator|=
name|read_backing_store
expr_stmt|;
name|info
operator|->
name|write_backing_store
operator|=
name|write_backing_store
expr_stmt|;
name|info
operator|->
name|close_backing_store
operator|=
name|close_backing_store
expr_stmt|;
block|}
end_block
begin_comment
comment|/*  * These routines take care of any system-dependent initialization and  * cleanup required.  */
end_comment
begin_macro
name|GLOBAL
argument_list|(
argument|long
argument_list|)
end_macro
begin_macro
DECL|function|jpeg_mem_init
name|jpeg_mem_init
argument_list|(
argument|j_common_ptr cinfo
argument_list|)
end_macro
begin_block
block|{
return|return
name|DEFAULT_MAX_MEM
return|;
comment|/* default for max_memory_to_use */
block|}
end_block
begin_macro
name|GLOBAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|jpeg_mem_term
name|jpeg_mem_term
argument_list|(
argument|j_common_ptr cinfo
argument_list|)
end_macro
begin_block
block|{
comment|/* no work */
block|}
end_block
end_unit
