begin_unit
begin_comment
comment|/*  * jcprepct.c  *  * Copyright (C) 1994-1996, Thomas G. Lane.  * This file is part of the Independent JPEG Group's software.  * For conditions of distribution and use, see the accompanying README file.  *  * This file contains the compression preprocessing controller.  * This controller manages the color conversion, downsampling,  * and edge expansion steps.  *  * Most of the complexity here is associated with buffering input rows  * as required by the downsampler.  See the comments at the head of  * jcsample.c for the downsampler's needs.  */
end_comment
begin_define
DECL|macro|JPEG_INTERNALS
define|#
directive|define
name|JPEG_INTERNALS
end_define
begin_include
include|#
directive|include
file|"jinclude.h"
end_include
begin_include
include|#
directive|include
file|"jpeglib.h"
end_include
begin_comment
comment|/* At present, jcsample.c can request context rows only for smoothing.  * In the future, we might also need context rows for CCIR601 sampling  * or other more-complex downsampling procedures.  The code to support  * context rows should be compiled only if needed.  */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|INPUT_SMOOTHING_SUPPORTED
end_ifdef
begin_define
DECL|macro|CONTEXT_ROWS_SUPPORTED
define|#
directive|define
name|CONTEXT_ROWS_SUPPORTED
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*  * For the simple (no-context-row) case, we just need to buffer one  * row group's worth of pixels for the downsampling step.  At the bottom of  * the image, we pad to a full row group by replicating the last pixel row.  * The downsampler's last output row is then replicated if needed to pad  * out to a full iMCU row.  *  * When providing context rows, we must buffer three row groups' worth of  * pixels.  Three row groups are physically allocated, but the row pointer  * arrays are made five row groups high, with the extra pointers above and  * below "wrapping around" to point to the last and first real row groups.  * This allows the downsampler to access the proper context rows.  * At the top and bottom of the image, we create dummy context rows by  * copying the first or last real pixel row.  This copying could be avoided  * by pointer hacking as is done in jdmainct.c, but it doesn't seem worth the  * trouble on the compression side.  */
end_comment
begin_comment
comment|/* Private buffer controller object */
end_comment
begin_typedef
typedef|typedef
struct|struct
block|{
DECL|member|pub
name|struct
name|jpeg_c_prep_controller
name|pub
decl_stmt|;
comment|/* public fields */
comment|/* Downsampling input buffer.  This buffer holds color-converted data    * until we have enough to do a downsample step.    */
DECL|member|color_buf
name|JSAMPARRAY
name|color_buf
index|[
name|MAX_COMPONENTS
index|]
decl_stmt|;
DECL|member|rows_to_go
name|JDIMENSION
name|rows_to_go
decl_stmt|;
comment|/* counts rows remaining in source image */
DECL|member|next_buf_row
name|int
name|next_buf_row
decl_stmt|;
comment|/* index of next row to store in color_buf */
ifdef|#
directive|ifdef
name|CONTEXT_ROWS_SUPPORTED
comment|/* only needed for context case */
DECL|member|this_row_group
name|int
name|this_row_group
decl_stmt|;
comment|/* starting row index of group to process */
DECL|member|next_buf_stop
name|int
name|next_buf_stop
decl_stmt|;
comment|/* downsample when we reach this index */
endif|#
directive|endif
block|}
DECL|typedef|my_prep_controller
name|my_prep_controller
typedef|;
end_typedef
begin_typedef
DECL|typedef|my_prep_ptr
typedef|typedef
name|my_prep_controller
modifier|*
name|my_prep_ptr
typedef|;
end_typedef
begin_comment
comment|/*  * Initialize for a processing pass.  */
end_comment
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|start_pass_prep
name|start_pass_prep
argument_list|(
argument|j_compress_ptr cinfo
argument_list|,
argument|J_BUF_MODE pass_mode
argument_list|)
end_macro
begin_block
block|{
name|my_prep_ptr
name|prep
init|=
operator|(
name|my_prep_ptr
operator|)
name|cinfo
operator|->
name|prep
decl_stmt|;
if|if
condition|(
name|pass_mode
operator|!=
name|JBUF_PASS_THRU
condition|)
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_BUFFER_MODE
argument_list|)
expr_stmt|;
comment|/* Initialize total-height counter for detecting bottom of image */
name|prep
operator|->
name|rows_to_go
operator|=
name|cinfo
operator|->
name|image_height
expr_stmt|;
comment|/* Mark the conversion buffer empty */
name|prep
operator|->
name|next_buf_row
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|CONTEXT_ROWS_SUPPORTED
comment|/* Preset additional state variables for context mode.    * These aren't used in non-context mode, so we needn't test which mode.    */
name|prep
operator|->
name|this_row_group
operator|=
literal|0
expr_stmt|;
comment|/* Set next_buf_stop to stop after two row groups have been read in. */
name|prep
operator|->
name|next_buf_stop
operator|=
literal|2
operator|*
name|cinfo
operator|->
name|max_v_samp_factor
expr_stmt|;
endif|#
directive|endif
block|}
end_block
begin_comment
comment|/*  * Expand an image vertically from height input_rows to height output_rows,  * by duplicating the bottom row.  */
end_comment
begin_macro
name|LOCAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|expand_bottom_edge
name|expand_bottom_edge
argument_list|(
argument|JSAMPARRAY image_data
argument_list|,
argument|JDIMENSION num_cols
argument_list|,
argument|int input_rows
argument_list|,
argument|int output_rows
argument_list|)
end_macro
begin_block
block|{
specifier|register
name|int
name|row
decl_stmt|;
for|for
control|(
name|row
operator|=
name|input_rows
init|;
name|row
operator|<
name|output_rows
condition|;
name|row
operator|++
control|)
block|{
name|jcopy_sample_rows
argument_list|(
name|image_data
argument_list|,
name|input_rows
operator|-
literal|1
argument_list|,
name|image_data
argument_list|,
name|row
argument_list|,
literal|1
argument_list|,
name|num_cols
argument_list|)
expr_stmt|;
block|}
block|}
end_block
begin_comment
comment|/*  * Process some data in the simple no-context case.  *  * Preprocessor output data is counted in "row groups".  A row group  * is defined to be v_samp_factor sample rows of each component.  * Downsampling will produce this much data from each max_v_samp_factor  * input rows.  */
end_comment
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|pre_process_data
name|pre_process_data
argument_list|(
argument|j_compress_ptr cinfo
argument_list|,
argument|JSAMPARRAY input_buf
argument_list|,
argument|JDIMENSION *in_row_ctr
argument_list|,
argument|JDIMENSION in_rows_avail
argument_list|,
argument|JSAMPIMAGE output_buf
argument_list|,
argument|JDIMENSION *out_row_group_ctr
argument_list|,
argument|JDIMENSION out_row_groups_avail
argument_list|)
end_macro
begin_block
block|{
name|my_prep_ptr
name|prep
init|=
operator|(
name|my_prep_ptr
operator|)
name|cinfo
operator|->
name|prep
decl_stmt|;
name|int
name|numrows
decl_stmt|,
name|ci
decl_stmt|;
name|JDIMENSION
name|inrows
decl_stmt|;
name|jpeg_component_info
modifier|*
name|compptr
decl_stmt|;
while|while
condition|(
operator|*
name|in_row_ctr
operator|<
name|in_rows_avail
operator|&&
operator|*
name|out_row_group_ctr
operator|<
name|out_row_groups_avail
condition|)
block|{
comment|/* Do color conversion to fill the conversion buffer. */
name|inrows
operator|=
name|in_rows_avail
operator|-
operator|*
name|in_row_ctr
expr_stmt|;
name|numrows
operator|=
name|cinfo
operator|->
name|max_v_samp_factor
operator|-
name|prep
operator|->
name|next_buf_row
expr_stmt|;
name|numrows
operator|=
operator|(
name|int
operator|)
name|MIN
argument_list|(
operator|(
name|JDIMENSION
operator|)
name|numrows
argument_list|,
name|inrows
argument_list|)
expr_stmt|;
call|(
modifier|*
name|cinfo
operator|->
name|cconvert
operator|->
name|color_convert
call|)
argument_list|(
name|cinfo
argument_list|,
name|input_buf
operator|+
operator|*
name|in_row_ctr
argument_list|,
name|prep
operator|->
name|color_buf
argument_list|,
operator|(
name|JDIMENSION
operator|)
name|prep
operator|->
name|next_buf_row
argument_list|,
name|numrows
argument_list|)
expr_stmt|;
operator|*
name|in_row_ctr
operator|+=
name|numrows
expr_stmt|;
name|prep
operator|->
name|next_buf_row
operator|+=
name|numrows
expr_stmt|;
name|prep
operator|->
name|rows_to_go
operator|-=
name|numrows
expr_stmt|;
comment|/* If at bottom of image, pad to fill the conversion buffer. */
if|if
condition|(
name|prep
operator|->
name|rows_to_go
operator|==
literal|0
operator|&&
name|prep
operator|->
name|next_buf_row
operator|<
name|cinfo
operator|->
name|max_v_samp_factor
condition|)
block|{
for|for
control|(
name|ci
operator|=
literal|0
init|;
name|ci
operator|<
name|cinfo
operator|->
name|num_components
condition|;
name|ci
operator|++
control|)
block|{
name|expand_bottom_edge
argument_list|(
name|prep
operator|->
name|color_buf
index|[
name|ci
index|]
argument_list|,
name|cinfo
operator|->
name|image_width
argument_list|,
name|prep
operator|->
name|next_buf_row
argument_list|,
name|cinfo
operator|->
name|max_v_samp_factor
argument_list|)
expr_stmt|;
block|}
name|prep
operator|->
name|next_buf_row
operator|=
name|cinfo
operator|->
name|max_v_samp_factor
expr_stmt|;
block|}
comment|/* If we've filled the conversion buffer, empty it. */
if|if
condition|(
name|prep
operator|->
name|next_buf_row
operator|==
name|cinfo
operator|->
name|max_v_samp_factor
condition|)
block|{
call|(
modifier|*
name|cinfo
operator|->
name|downsample
operator|->
name|downsample
call|)
argument_list|(
name|cinfo
argument_list|,
name|prep
operator|->
name|color_buf
argument_list|,
operator|(
name|JDIMENSION
operator|)
literal|0
argument_list|,
name|output_buf
argument_list|,
operator|*
name|out_row_group_ctr
argument_list|)
expr_stmt|;
name|prep
operator|->
name|next_buf_row
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|out_row_group_ctr
operator|)
operator|++
expr_stmt|;
block|}
comment|/* If at bottom of image, pad the output to a full iMCU height.      * Note we assume the caller is providing a one-iMCU-height output buffer!      */
if|if
condition|(
name|prep
operator|->
name|rows_to_go
operator|==
literal|0
operator|&&
operator|*
name|out_row_group_ctr
operator|<
name|out_row_groups_avail
condition|)
block|{
for|for
control|(
name|ci
operator|=
literal|0
operator|,
name|compptr
operator|=
name|cinfo
operator|->
name|comp_info
init|;
name|ci
operator|<
name|cinfo
operator|->
name|num_components
condition|;
name|ci
operator|++
operator|,
name|compptr
operator|++
control|)
block|{
name|numrows
operator|=
operator|(
name|compptr
operator|->
name|v_samp_factor
operator|*
name|compptr
operator|->
name|DCT_v_scaled_size
operator|)
operator|/
name|cinfo
operator|->
name|min_DCT_v_scaled_size
expr_stmt|;
name|expand_bottom_edge
argument_list|(
name|output_buf
index|[
name|ci
index|]
argument_list|,
name|compptr
operator|->
name|width_in_blocks
operator|*
name|compptr
operator|->
name|DCT_h_scaled_size
argument_list|,
call|(
name|int
call|)
argument_list|(
operator|*
name|out_row_group_ctr
operator|*
name|numrows
argument_list|)
argument_list|,
call|(
name|int
call|)
argument_list|(
name|out_row_groups_avail
operator|*
name|numrows
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|*
name|out_row_group_ctr
operator|=
name|out_row_groups_avail
expr_stmt|;
break|break;
comment|/* can exit outer loop without test */
block|}
block|}
block|}
end_block
begin_ifdef
ifdef|#
directive|ifdef
name|CONTEXT_ROWS_SUPPORTED
end_ifdef
begin_comment
comment|/*  * Process some data in the context case.  */
end_comment
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|pre_process_context
name|pre_process_context
argument_list|(
argument|j_compress_ptr cinfo
argument_list|,
argument|JSAMPARRAY input_buf
argument_list|,
argument|JDIMENSION *in_row_ctr
argument_list|,
argument|JDIMENSION in_rows_avail
argument_list|,
argument|JSAMPIMAGE output_buf
argument_list|,
argument|JDIMENSION *out_row_group_ctr
argument_list|,
argument|JDIMENSION out_row_groups_avail
argument_list|)
end_macro
begin_block
block|{
name|my_prep_ptr
name|prep
init|=
operator|(
name|my_prep_ptr
operator|)
name|cinfo
operator|->
name|prep
decl_stmt|;
name|int
name|numrows
decl_stmt|,
name|ci
decl_stmt|;
name|int
name|buf_height
init|=
name|cinfo
operator|->
name|max_v_samp_factor
operator|*
literal|3
decl_stmt|;
name|JDIMENSION
name|inrows
decl_stmt|;
while|while
condition|(
operator|*
name|out_row_group_ctr
operator|<
name|out_row_groups_avail
condition|)
block|{
if|if
condition|(
operator|*
name|in_row_ctr
operator|<
name|in_rows_avail
condition|)
block|{
comment|/* Do color conversion to fill the conversion buffer. */
name|inrows
operator|=
name|in_rows_avail
operator|-
operator|*
name|in_row_ctr
expr_stmt|;
name|numrows
operator|=
name|prep
operator|->
name|next_buf_stop
operator|-
name|prep
operator|->
name|next_buf_row
expr_stmt|;
name|numrows
operator|=
operator|(
name|int
operator|)
name|MIN
argument_list|(
operator|(
name|JDIMENSION
operator|)
name|numrows
argument_list|,
name|inrows
argument_list|)
expr_stmt|;
call|(
modifier|*
name|cinfo
operator|->
name|cconvert
operator|->
name|color_convert
call|)
argument_list|(
name|cinfo
argument_list|,
name|input_buf
operator|+
operator|*
name|in_row_ctr
argument_list|,
name|prep
operator|->
name|color_buf
argument_list|,
operator|(
name|JDIMENSION
operator|)
name|prep
operator|->
name|next_buf_row
argument_list|,
name|numrows
argument_list|)
expr_stmt|;
comment|/* Pad at top of image, if first time through */
if|if
condition|(
name|prep
operator|->
name|rows_to_go
operator|==
name|cinfo
operator|->
name|image_height
condition|)
block|{
for|for
control|(
name|ci
operator|=
literal|0
init|;
name|ci
operator|<
name|cinfo
operator|->
name|num_components
condition|;
name|ci
operator|++
control|)
block|{
name|int
name|row
decl_stmt|;
for|for
control|(
name|row
operator|=
literal|1
init|;
name|row
operator|<=
name|cinfo
operator|->
name|max_v_samp_factor
condition|;
name|row
operator|++
control|)
block|{
name|jcopy_sample_rows
argument_list|(
name|prep
operator|->
name|color_buf
index|[
name|ci
index|]
argument_list|,
literal|0
argument_list|,
name|prep
operator|->
name|color_buf
index|[
name|ci
index|]
argument_list|,
operator|-
name|row
argument_list|,
literal|1
argument_list|,
name|cinfo
operator|->
name|image_width
argument_list|)
expr_stmt|;
block|}
block|}
block|}
operator|*
name|in_row_ctr
operator|+=
name|numrows
expr_stmt|;
name|prep
operator|->
name|next_buf_row
operator|+=
name|numrows
expr_stmt|;
name|prep
operator|->
name|rows_to_go
operator|-=
name|numrows
expr_stmt|;
block|}
else|else
block|{
comment|/* Return for more data, unless we are at the bottom of the image. */
if|if
condition|(
name|prep
operator|->
name|rows_to_go
operator|!=
literal|0
condition|)
break|break;
comment|/* When at bottom of image, pad to fill the conversion buffer. */
if|if
condition|(
name|prep
operator|->
name|next_buf_row
operator|<
name|prep
operator|->
name|next_buf_stop
condition|)
block|{
for|for
control|(
name|ci
operator|=
literal|0
init|;
name|ci
operator|<
name|cinfo
operator|->
name|num_components
condition|;
name|ci
operator|++
control|)
block|{
name|expand_bottom_edge
argument_list|(
name|prep
operator|->
name|color_buf
index|[
name|ci
index|]
argument_list|,
name|cinfo
operator|->
name|image_width
argument_list|,
name|prep
operator|->
name|next_buf_row
argument_list|,
name|prep
operator|->
name|next_buf_stop
argument_list|)
expr_stmt|;
block|}
name|prep
operator|->
name|next_buf_row
operator|=
name|prep
operator|->
name|next_buf_stop
expr_stmt|;
block|}
block|}
comment|/* If we've gotten enough data, downsample a row group. */
if|if
condition|(
name|prep
operator|->
name|next_buf_row
operator|==
name|prep
operator|->
name|next_buf_stop
condition|)
block|{
call|(
modifier|*
name|cinfo
operator|->
name|downsample
operator|->
name|downsample
call|)
argument_list|(
name|cinfo
argument_list|,
name|prep
operator|->
name|color_buf
argument_list|,
operator|(
name|JDIMENSION
operator|)
name|prep
operator|->
name|this_row_group
argument_list|,
name|output_buf
argument_list|,
operator|*
name|out_row_group_ctr
argument_list|)
expr_stmt|;
operator|(
operator|*
name|out_row_group_ctr
operator|)
operator|++
expr_stmt|;
comment|/* Advance pointers with wraparound as necessary. */
name|prep
operator|->
name|this_row_group
operator|+=
name|cinfo
operator|->
name|max_v_samp_factor
expr_stmt|;
if|if
condition|(
name|prep
operator|->
name|this_row_group
operator|>=
name|buf_height
condition|)
name|prep
operator|->
name|this_row_group
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|prep
operator|->
name|next_buf_row
operator|>=
name|buf_height
condition|)
name|prep
operator|->
name|next_buf_row
operator|=
literal|0
expr_stmt|;
name|prep
operator|->
name|next_buf_stop
operator|=
name|prep
operator|->
name|next_buf_row
operator|+
name|cinfo
operator|->
name|max_v_samp_factor
expr_stmt|;
block|}
block|}
block|}
end_block
begin_comment
comment|/*  * Create the wrapped-around downsampling input buffer needed for context mode.  */
end_comment
begin_macro
name|LOCAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|create_context_buffer
name|create_context_buffer
argument_list|(
argument|j_compress_ptr cinfo
argument_list|)
end_macro
begin_block
block|{
name|my_prep_ptr
name|prep
init|=
operator|(
name|my_prep_ptr
operator|)
name|cinfo
operator|->
name|prep
decl_stmt|;
name|int
name|rgroup_height
init|=
name|cinfo
operator|->
name|max_v_samp_factor
decl_stmt|;
name|int
name|ci
decl_stmt|,
name|i
decl_stmt|;
name|jpeg_component_info
modifier|*
name|compptr
decl_stmt|;
name|JSAMPARRAY
name|true_buffer
decl_stmt|,
name|fake_buffer
decl_stmt|;
comment|/* Grab enough space for fake row pointers for all the components;    * we need five row groups' worth of pointers for each component.    */
name|fake_buffer
operator|=
call|(
name|JSAMPARRAY
call|)
argument_list|(
operator|*
name|cinfo
operator|->
name|mem
operator|->
name|alloc_small
argument_list|)
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|,
name|JPOOL_IMAGE
argument_list|,
operator|(
name|cinfo
operator|->
name|num_components
operator|*
literal|5
operator|*
name|rgroup_height
operator|)
operator|*
name|SIZEOF
argument_list|(
name|JSAMPROW
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|ci
operator|=
literal|0
operator|,
name|compptr
operator|=
name|cinfo
operator|->
name|comp_info
init|;
name|ci
operator|<
name|cinfo
operator|->
name|num_components
condition|;
name|ci
operator|++
operator|,
name|compptr
operator|++
control|)
block|{
comment|/* Allocate the actual buffer space (3 row groups) for this component.      * We make the buffer wide enough to allow the downsampler to edge-expand      * horizontally within the buffer, if it so chooses.      */
name|true_buffer
operator|=
call|(
modifier|*
name|cinfo
operator|->
name|mem
operator|->
name|alloc_sarray
call|)
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|,
name|JPOOL_IMAGE
argument_list|,
call|(
name|JDIMENSION
call|)
argument_list|(
operator|(
operator|(
name|long
operator|)
name|compptr
operator|->
name|width_in_blocks
operator|*
name|cinfo
operator|->
name|min_DCT_h_scaled_size
operator|*
name|cinfo
operator|->
name|max_h_samp_factor
operator|)
operator|/
name|compptr
operator|->
name|h_samp_factor
argument_list|)
argument_list|,
call|(
name|JDIMENSION
call|)
argument_list|(
literal|3
operator|*
name|rgroup_height
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Copy true buffer row pointers into the middle of the fake row array */
name|MEMCOPY
argument_list|(
name|fake_buffer
operator|+
name|rgroup_height
argument_list|,
name|true_buffer
argument_list|,
literal|3
operator|*
name|rgroup_height
operator|*
name|SIZEOF
argument_list|(
name|JSAMPROW
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fill in the above and below wraparound pointers */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rgroup_height
condition|;
name|i
operator|++
control|)
block|{
name|fake_buffer
index|[
name|i
index|]
operator|=
name|true_buffer
index|[
literal|2
operator|*
name|rgroup_height
operator|+
name|i
index|]
expr_stmt|;
name|fake_buffer
index|[
literal|4
operator|*
name|rgroup_height
operator|+
name|i
index|]
operator|=
name|true_buffer
index|[
name|i
index|]
expr_stmt|;
block|}
name|prep
operator|->
name|color_buf
index|[
name|ci
index|]
operator|=
name|fake_buffer
operator|+
name|rgroup_height
expr_stmt|;
name|fake_buffer
operator|+=
literal|5
operator|*
name|rgroup_height
expr_stmt|;
comment|/* point to space for next component */
block|}
block|}
end_block
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* CONTEXT_ROWS_SUPPORTED */
end_comment
begin_comment
comment|/*  * Initialize preprocessing controller.  */
end_comment
begin_macro
name|GLOBAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|jinit_c_prep_controller
name|jinit_c_prep_controller
argument_list|(
argument|j_compress_ptr cinfo
argument_list|,
argument|boolean need_full_buffer
argument_list|)
end_macro
begin_block
block|{
name|my_prep_ptr
name|prep
decl_stmt|;
name|int
name|ci
decl_stmt|;
name|jpeg_component_info
modifier|*
name|compptr
decl_stmt|;
if|if
condition|(
name|need_full_buffer
condition|)
comment|/* safety check */
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_BUFFER_MODE
argument_list|)
expr_stmt|;
name|prep
operator|=
call|(
name|my_prep_ptr
call|)
argument_list|(
operator|*
name|cinfo
operator|->
name|mem
operator|->
name|alloc_small
argument_list|)
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|,
name|JPOOL_IMAGE
argument_list|,
name|SIZEOF
argument_list|(
name|my_prep_controller
argument_list|)
argument_list|)
expr_stmt|;
name|cinfo
operator|->
name|prep
operator|=
operator|(
expr|struct
name|jpeg_c_prep_controller
operator|*
operator|)
name|prep
expr_stmt|;
name|prep
operator|->
name|pub
operator|.
name|start_pass
operator|=
name|start_pass_prep
expr_stmt|;
comment|/* Allocate the color conversion buffer.    * We make the buffer wide enough to allow the downsampler to edge-expand    * horizontally within the buffer, if it so chooses.    */
if|if
condition|(
name|cinfo
operator|->
name|downsample
operator|->
name|need_context_rows
condition|)
block|{
comment|/* Set up to provide context rows */
ifdef|#
directive|ifdef
name|CONTEXT_ROWS_SUPPORTED
name|prep
operator|->
name|pub
operator|.
name|pre_process_data
operator|=
name|pre_process_context
expr_stmt|;
name|create_context_buffer
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
else|#
directive|else
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_NOT_COMPILED
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
comment|/* No context, just make it tall enough for one row group */
name|prep
operator|->
name|pub
operator|.
name|pre_process_data
operator|=
name|pre_process_data
expr_stmt|;
for|for
control|(
name|ci
operator|=
literal|0
operator|,
name|compptr
operator|=
name|cinfo
operator|->
name|comp_info
init|;
name|ci
operator|<
name|cinfo
operator|->
name|num_components
condition|;
name|ci
operator|++
operator|,
name|compptr
operator|++
control|)
block|{
name|prep
operator|->
name|color_buf
index|[
name|ci
index|]
operator|=
call|(
modifier|*
name|cinfo
operator|->
name|mem
operator|->
name|alloc_sarray
call|)
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|,
name|JPOOL_IMAGE
argument_list|,
call|(
name|JDIMENSION
call|)
argument_list|(
operator|(
operator|(
name|long
operator|)
name|compptr
operator|->
name|width_in_blocks
operator|*
name|cinfo
operator|->
name|min_DCT_h_scaled_size
operator|*
name|cinfo
operator|->
name|max_h_samp_factor
operator|)
operator|/
name|compptr
operator|->
name|h_samp_factor
argument_list|)
argument_list|,
operator|(
name|JDIMENSION
operator|)
name|cinfo
operator|->
name|max_v_samp_factor
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block
end_unit
