begin_unit
begin_comment
comment|/*  * jmorecfg.h  *  * Copyright (C) 1991-1997, Thomas G. Lane.  * Modified 1997-2009 by Guido Vollbeding.  * This file is part of the Independent JPEG Group's software.  * For conditions of distribution and use, see the accompanying README file.  *  * This file contains additional configuration options that customize the  * JPEG software for special applications or support machine-dependent  * optimizations.  Most users will not need to touch this file.  */
end_comment
begin_comment
comment|/*  * Define BITS_IN_JSAMPLE as either  *   8   for 8-bit sample values (the usual setting)  *   12  for 12-bit sample values  * Only 8 and 12 are legal data precisions for lossy JPEG according to the  * JPEG standard, and the IJG code does not support anything else!  * We do not support run-time selection of data precision, sorry.  */
end_comment
begin_define
DECL|macro|BITS_IN_JSAMPLE
define|#
directive|define
name|BITS_IN_JSAMPLE
value|8
end_define
begin_comment
DECL|macro|BITS_IN_JSAMPLE
comment|/* use 8 or 12 */
end_comment
begin_comment
comment|/*  * Maximum number of components (color channels) allowed in JPEG image.  * To meet the letter of the JPEG spec, set this to 255.  However, darn  * few applications need more than 4 channels (maybe 5 for CMYK + alpha  * mask).  We recommend 10 as a reasonable compromise; use 4 if you are  * really short on memory.  (Each allowed component costs a hundred or so  * bytes of storage, whether actually used in an image or not.)  */
end_comment
begin_define
DECL|macro|MAX_COMPONENTS
define|#
directive|define
name|MAX_COMPONENTS
value|10
end_define
begin_comment
DECL|macro|MAX_COMPONENTS
comment|/* maximum number of image components */
end_comment
begin_comment
comment|/*  * Basic data types.  * You may need to change these if you have a machine with unusual data  * type sizes; for example, "char" not 8 bits, "short" not 16 bits,  * or "long" not 32 bits.  We don't care whether "int" is 16 or 32 bits,  * but it had better be at least 16.  */
end_comment
begin_comment
comment|/* Representation of a single sample (pixel element value).  * We frequently allocate large arrays of these, so it's important to keep  * them small.  But if you have memory to burn and access to char or short  * arrays is very slow on your hardware, you might want to change these.  */
end_comment
begin_if
if|#
directive|if
name|BITS_IN_JSAMPLE
operator|==
literal|8
end_if
begin_comment
comment|/* JSAMPLE should be the smallest type that will hold the values 0..255.  * You can use a signed char by having GETJSAMPLE mask it with 0xFF.  */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UNSIGNED_CHAR
end_ifdef
begin_typedef
DECL|typedef|JSAMPLE
typedef|typedef
name|unsigned
name|char
name|JSAMPLE
typedef|;
end_typedef
begin_define
DECL|macro|GETJSAMPLE
define|#
directive|define
name|GETJSAMPLE
parameter_list|(
name|value
parameter_list|)
value|((int) (value))
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* not HAVE_UNSIGNED_CHAR */
end_comment
begin_typedef
DECL|typedef|JSAMPLE
typedef|typedef
name|char
name|JSAMPLE
typedef|;
end_typedef
begin_ifdef
ifdef|#
directive|ifdef
name|CHAR_IS_UNSIGNED
end_ifdef
begin_define
DECL|macro|GETJSAMPLE
define|#
directive|define
name|GETJSAMPLE
parameter_list|(
name|value
parameter_list|)
value|((int) (value))
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|GETJSAMPLE
define|#
directive|define
name|GETJSAMPLE
parameter_list|(
name|value
parameter_list|)
value|((int) (value)& 0xFF)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* CHAR_IS_UNSIGNED */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* HAVE_UNSIGNED_CHAR */
end_comment
begin_define
DECL|macro|MAXJSAMPLE
define|#
directive|define
name|MAXJSAMPLE
value|255
end_define
begin_define
DECL|macro|CENTERJSAMPLE
define|#
directive|define
name|CENTERJSAMPLE
value|128
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* BITS_IN_JSAMPLE == 8 */
end_comment
begin_if
if|#
directive|if
name|BITS_IN_JSAMPLE
operator|==
literal|12
end_if
begin_comment
comment|/* JSAMPLE should be the smallest type that will hold the values 0..4095.  * On nearly all machines "short" will do nicely.  */
end_comment
begin_typedef
DECL|typedef|JSAMPLE
typedef|typedef
name|short
name|JSAMPLE
typedef|;
end_typedef
begin_define
DECL|macro|GETJSAMPLE
define|#
directive|define
name|GETJSAMPLE
parameter_list|(
name|value
parameter_list|)
value|((int) (value))
end_define
begin_define
DECL|macro|MAXJSAMPLE
define|#
directive|define
name|MAXJSAMPLE
value|4095
end_define
begin_define
DECL|macro|CENTERJSAMPLE
define|#
directive|define
name|CENTERJSAMPLE
value|2048
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* BITS_IN_JSAMPLE == 12 */
end_comment
begin_comment
comment|/* Representation of a DCT frequency coefficient.  * This should be a signed value of at least 16 bits; "short" is usually OK.  * Again, we allocate large arrays of these, but you can change to int  * if you have memory to burn and "short" is really slow.  */
end_comment
begin_typedef
DECL|typedef|JCOEF
typedef|typedef
name|short
name|JCOEF
typedef|;
end_typedef
begin_comment
comment|/* Compressed datastreams are represented as arrays of JOCTET.  * These must be EXACTLY 8 bits wide, at least once they are written to  * external storage.  Note that when using the stdio data source/destination  * managers, this is also the data type passed to fread/fwrite.  */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UNSIGNED_CHAR
end_ifdef
begin_typedef
DECL|typedef|JOCTET
typedef|typedef
name|unsigned
name|char
name|JOCTET
typedef|;
end_typedef
begin_define
DECL|macro|GETJOCTET
define|#
directive|define
name|GETJOCTET
parameter_list|(
name|value
parameter_list|)
value|(value)
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* not HAVE_UNSIGNED_CHAR */
end_comment
begin_typedef
DECL|typedef|JOCTET
typedef|typedef
name|char
name|JOCTET
typedef|;
end_typedef
begin_ifdef
ifdef|#
directive|ifdef
name|CHAR_IS_UNSIGNED
end_ifdef
begin_define
DECL|macro|GETJOCTET
define|#
directive|define
name|GETJOCTET
parameter_list|(
name|value
parameter_list|)
value|(value)
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|GETJOCTET
define|#
directive|define
name|GETJOCTET
parameter_list|(
name|value
parameter_list|)
value|((value)& 0xFF)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* CHAR_IS_UNSIGNED */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* HAVE_UNSIGNED_CHAR */
end_comment
begin_comment
comment|/* These typedefs are used for various table entries and so forth.  * They must be at least as wide as specified; but making them too big  * won't cost a huge amount of memory, so we don't provide special  * extraction code like we did for JSAMPLE.  (In other words, these  * typedefs live at a different point on the speed/space tradeoff curve.)  */
end_comment
begin_comment
comment|/* UINT8 must hold at least the values 0..255. */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UNSIGNED_CHAR
end_ifdef
begin_typedef
DECL|typedef|UINT8
typedef|typedef
name|unsigned
name|char
name|UINT8
typedef|;
end_typedef
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* not HAVE_UNSIGNED_CHAR */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|CHAR_IS_UNSIGNED
end_ifdef
begin_typedef
DECL|typedef|UINT8
typedef|typedef
name|char
name|UINT8
typedef|;
end_typedef
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* not CHAR_IS_UNSIGNED */
end_comment
begin_typedef
DECL|typedef|UINT8
typedef|typedef
name|short
name|UINT8
typedef|;
end_typedef
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* CHAR_IS_UNSIGNED */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* HAVE_UNSIGNED_CHAR */
end_comment
begin_comment
comment|/* UINT16 must hold at least the values 0..65535. */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UNSIGNED_SHORT
end_ifdef
begin_typedef
DECL|typedef|UINT16
typedef|typedef
name|unsigned
name|short
name|UINT16
typedef|;
end_typedef
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* not HAVE_UNSIGNED_SHORT */
end_comment
begin_typedef
DECL|typedef|UINT16
typedef|typedef
name|unsigned
name|int
name|UINT16
typedef|;
end_typedef
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* HAVE_UNSIGNED_SHORT */
end_comment
begin_comment
comment|/* INT16 must hold at least the values -32768..32767. */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|XMD_H
end_ifndef
begin_comment
comment|/* X11/xmd.h correctly defines INT16 */
end_comment
begin_typedef
DECL|typedef|INT16
typedef|typedef
name|short
name|INT16
typedef|;
end_typedef
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* INT32 must hold at least signed 32-bit values. */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|XMD_H
end_ifndef
begin_comment
comment|/* X11/xmd.h correctly defines INT32 */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|_BASETSD_H_
end_ifndef
begin_comment
comment|/* Microsoft defines it in basetsd.h */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|_BASETSD_H
end_ifndef
begin_comment
comment|/* MinGW is slightly different */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QGLOBAL_H
end_ifndef
begin_comment
comment|/* Qt defines it in qglobal.h */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|VXWORKS
end_ifndef
begin_typedef
DECL|typedef|INT32
typedef|typedef
name|long
name|INT32
typedef|;
end_typedef
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* Datatype used for image dimensions.  The JPEG standard only supports  * images up to 64K*64K due to 16-bit fields in SOF markers.  Therefore  * "unsigned int" is sufficient on all machines.  However, if you need to  * handle larger images and you don't mind deviating from the spec, you  * can change this datatype.  */
end_comment
begin_typedef
DECL|typedef|JDIMENSION
typedef|typedef
name|unsigned
name|int
name|JDIMENSION
typedef|;
end_typedef
begin_define
DECL|macro|JPEG_MAX_DIMENSION
define|#
directive|define
name|JPEG_MAX_DIMENSION
value|65500L
end_define
begin_comment
DECL|macro|JPEG_MAX_DIMENSION
comment|/* a tad under 64K to prevent overflows */
end_comment
begin_comment
comment|/* These macros are used in all function definitions and extern declarations.  * You could modify them if you need to change function linkage conventions;  * in particular, you'll need to do that to make the library a Windows DLL.  * Another application is to make all functions global for use with debuggers  * or code profilers that require it.  */
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|VXWORKS
argument_list|)
operator|&&
name|defined
argument_list|(
name|LOCAL
argument_list|)
end_if
begin_undef
DECL|macro|LOCAL
undef|#
directive|undef
name|LOCAL
end_undef
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* a function called through method pointers: */
end_comment
begin_define
DECL|macro|METHODDEF
define|#
directive|define
name|METHODDEF
parameter_list|(
name|type
parameter_list|)
value|static type
end_define
begin_comment
comment|/* a function used only in its module: */
end_comment
begin_define
DECL|macro|LOCAL
define|#
directive|define
name|LOCAL
parameter_list|(
name|type
parameter_list|)
value|static type
end_define
begin_comment
comment|/* a function referenced thru EXTERNs: */
end_comment
begin_define
DECL|macro|GLOBAL
define|#
directive|define
name|GLOBAL
parameter_list|(
name|type
parameter_list|)
value|type
end_define
begin_comment
comment|/* a reference to a GLOBAL function: */
end_comment
begin_define
DECL|macro|EXTERN
define|#
directive|define
name|EXTERN
parameter_list|(
name|type
parameter_list|)
value|extern type
end_define
begin_comment
comment|/* This macro is used to declare a "method", that is, a function pointer.  * We want to supply prototype parameters if the compiler can cope.  * Note that the arglist parameter must be parenthesized!  * Again, you can customize this if you need special linkage keywords.  */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PROTOTYPES
end_ifdef
begin_define
DECL|macro|JMETHOD
define|#
directive|define
name|JMETHOD
parameter_list|(
name|type
parameter_list|,
name|methodname
parameter_list|,
name|arglist
parameter_list|)
value|type (*methodname) arglist
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|JMETHOD
define|#
directive|define
name|JMETHOD
parameter_list|(
name|type
parameter_list|,
name|methodname
parameter_list|,
name|arglist
parameter_list|)
value|type (*methodname) ()
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* Here is the pseudo-keyword for declaring pointers that must be "far"  * on 80x86 machines.  Most of the specialized coding for 80x86 is handled  * by just saying "FAR *" where such a pointer is needed.  In a few places  * explicit coding is needed; see uses of the NEED_FAR_POINTERS symbol.  */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|FAR
end_ifndef
begin_ifdef
ifdef|#
directive|ifdef
name|NEED_FAR_POINTERS
end_ifdef
begin_define
DECL|macro|FAR
define|#
directive|define
name|FAR
value|far
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|FAR
define|#
directive|define
name|FAR
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*  * On a few systems, type boolean and/or its values FALSE, TRUE may appear  * in standard header files.  Or you may have conflicts with application-  * specific header files that you want to include together with these files.  * Defining HAVE_BOOLEAN before including jpeglib.h should make it work.  */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_BOOLEAN
end_ifndef
begin_typedef
DECL|typedef|boolean
typedef|typedef
name|int
name|boolean
typedef|;
end_typedef
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|FALSE
end_ifndef
begin_comment
comment|/* in case these macros already exist */
end_comment
begin_define
DECL|macro|FALSE
define|#
directive|define
name|FALSE
value|0
end_define
begin_comment
DECL|macro|FALSE
comment|/* values of boolean */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|TRUE
end_ifndef
begin_define
DECL|macro|TRUE
define|#
directive|define
name|TRUE
value|1
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*  * The remaining options affect code selection within the JPEG library,  * but they don't need to be visible to most applications using the library.  * To minimize application namespace pollution, the symbols won't be  * defined unless JPEG_INTERNALS or JPEG_INTERNAL_OPTIONS has been defined.  */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|JPEG_INTERNALS
end_ifdef
begin_define
DECL|macro|JPEG_INTERNAL_OPTIONS
define|#
directive|define
name|JPEG_INTERNAL_OPTIONS
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|JPEG_INTERNAL_OPTIONS
end_ifdef
begin_comment
comment|/*  * These defines indicate whether to include various optional functions.  * Undefining some of these symbols will produce a smaller but less capable  * library.  Note that you can leave certain source files out of the  * compilation/linking process if you've #undef'd the corresponding symbols.  * (You may HAVE to do that if your compiler doesn't like null source files.)  */
end_comment
begin_comment
comment|/* Capability options common to encoder and decoder: */
end_comment
begin_define
DECL|macro|DCT_ISLOW_SUPPORTED
define|#
directive|define
name|DCT_ISLOW_SUPPORTED
end_define
begin_comment
DECL|macro|DCT_ISLOW_SUPPORTED
comment|/* slow but accurate integer algorithm */
end_comment
begin_define
DECL|macro|DCT_IFAST_SUPPORTED
define|#
directive|define
name|DCT_IFAST_SUPPORTED
end_define
begin_comment
DECL|macro|DCT_IFAST_SUPPORTED
comment|/* faster, less accurate integer method */
end_comment
begin_define
DECL|macro|DCT_FLOAT_SUPPORTED
define|#
directive|define
name|DCT_FLOAT_SUPPORTED
end_define
begin_comment
DECL|macro|DCT_FLOAT_SUPPORTED
comment|/* floating-point: accurate, fast on fast HW */
end_comment
begin_comment
comment|/* Encoder capability options: */
end_comment
begin_define
DECL|macro|C_ARITH_CODING_SUPPORTED
define|#
directive|define
name|C_ARITH_CODING_SUPPORTED
end_define
begin_comment
DECL|macro|C_ARITH_CODING_SUPPORTED
comment|/* Arithmetic coding back end? */
end_comment
begin_define
DECL|macro|C_MULTISCAN_FILES_SUPPORTED
define|#
directive|define
name|C_MULTISCAN_FILES_SUPPORTED
end_define
begin_comment
DECL|macro|C_MULTISCAN_FILES_SUPPORTED
comment|/* Multiple-scan JPEG files? */
end_comment
begin_define
DECL|macro|C_PROGRESSIVE_SUPPORTED
define|#
directive|define
name|C_PROGRESSIVE_SUPPORTED
end_define
begin_comment
DECL|macro|C_PROGRESSIVE_SUPPORTED
comment|/* Progressive JPEG? (Requires MULTISCAN)*/
end_comment
begin_define
DECL|macro|DCT_SCALING_SUPPORTED
define|#
directive|define
name|DCT_SCALING_SUPPORTED
end_define
begin_comment
DECL|macro|DCT_SCALING_SUPPORTED
comment|/* Input rescaling via DCT? (Requires DCT_ISLOW)*/
end_comment
begin_define
DECL|macro|ENTROPY_OPT_SUPPORTED
define|#
directive|define
name|ENTROPY_OPT_SUPPORTED
end_define
begin_comment
DECL|macro|ENTROPY_OPT_SUPPORTED
comment|/* Optimization of entropy coding parms? */
end_comment
begin_comment
comment|/* Note: if you selected 12-bit data precision, it is dangerous to turn off  * ENTROPY_OPT_SUPPORTED.  The standard Huffman tables are only good for 8-bit  * precision, so jchuff.c normally uses entropy optimization to compute  * usable tables for higher precision.  If you don't want to do optimization,  * you'll have to supply different default Huffman tables.  * The exact same statements apply for progressive JPEG: the default tables  * don't work for progressive mode.  (This may get fixed, however.)  */
end_comment
begin_define
DECL|macro|INPUT_SMOOTHING_SUPPORTED
define|#
directive|define
name|INPUT_SMOOTHING_SUPPORTED
end_define
begin_comment
DECL|macro|INPUT_SMOOTHING_SUPPORTED
comment|/* Input image smoothing option? */
end_comment
begin_comment
comment|/* Decoder capability options: */
end_comment
begin_define
DECL|macro|D_ARITH_CODING_SUPPORTED
define|#
directive|define
name|D_ARITH_CODING_SUPPORTED
end_define
begin_comment
DECL|macro|D_ARITH_CODING_SUPPORTED
comment|/* Arithmetic coding back end? */
end_comment
begin_define
DECL|macro|D_MULTISCAN_FILES_SUPPORTED
define|#
directive|define
name|D_MULTISCAN_FILES_SUPPORTED
end_define
begin_comment
DECL|macro|D_MULTISCAN_FILES_SUPPORTED
comment|/* Multiple-scan JPEG files? */
end_comment
begin_define
DECL|macro|D_PROGRESSIVE_SUPPORTED
define|#
directive|define
name|D_PROGRESSIVE_SUPPORTED
end_define
begin_comment
DECL|macro|D_PROGRESSIVE_SUPPORTED
comment|/* Progressive JPEG? (Requires MULTISCAN)*/
end_comment
begin_define
DECL|macro|IDCT_SCALING_SUPPORTED
define|#
directive|define
name|IDCT_SCALING_SUPPORTED
end_define
begin_comment
DECL|macro|IDCT_SCALING_SUPPORTED
comment|/* Output rescaling via IDCT? */
end_comment
begin_define
DECL|macro|SAVE_MARKERS_SUPPORTED
define|#
directive|define
name|SAVE_MARKERS_SUPPORTED
end_define
begin_comment
DECL|macro|SAVE_MARKERS_SUPPORTED
comment|/* jpeg_save_markers() needed? */
end_comment
begin_define
DECL|macro|BLOCK_SMOOTHING_SUPPORTED
define|#
directive|define
name|BLOCK_SMOOTHING_SUPPORTED
end_define
begin_comment
DECL|macro|BLOCK_SMOOTHING_SUPPORTED
comment|/* Block smoothing? (Progressive only) */
end_comment
begin_undef
DECL|macro|UPSAMPLE_SCALING_SUPPORTED
undef|#
directive|undef
name|UPSAMPLE_SCALING_SUPPORTED
end_undef
begin_comment
DECL|macro|UPSAMPLE_SCALING_SUPPORTED
comment|/* Output rescaling at upsample stage? */
end_comment
begin_define
DECL|macro|UPSAMPLE_MERGING_SUPPORTED
define|#
directive|define
name|UPSAMPLE_MERGING_SUPPORTED
end_define
begin_comment
DECL|macro|UPSAMPLE_MERGING_SUPPORTED
comment|/* Fast path for sloppy upsampling? */
end_comment
begin_define
DECL|macro|QUANT_1PASS_SUPPORTED
define|#
directive|define
name|QUANT_1PASS_SUPPORTED
end_define
begin_comment
DECL|macro|QUANT_1PASS_SUPPORTED
comment|/* 1-pass color quantization? */
end_comment
begin_define
DECL|macro|QUANT_2PASS_SUPPORTED
define|#
directive|define
name|QUANT_2PASS_SUPPORTED
end_define
begin_comment
DECL|macro|QUANT_2PASS_SUPPORTED
comment|/* 2-pass color quantization? */
end_comment
begin_comment
comment|/* more capability options later, no doubt */
end_comment
begin_comment
comment|/*  * Ordering of RGB data in scanlines passed to or from the application.  * If your application wants to deal with data in the order B,G,R, just  * change these macros.  You can also deal with formats such as R,G,B,X  * (one extra byte per pixel) by changing RGB_PIXELSIZE.  Note that changing  * the offsets will also change the order in which colormap data is organized.  * RESTRICTIONS:  * 1. The sample applications cjpeg,djpeg do NOT support modified RGB formats.  * 2. These macros only affect RGB<=>YCbCr color conversion, so they are not  *    useful if you are using JPEG color spaces other than YCbCr or grayscale.  * 3. The color quantizer modules will not behave desirably if RGB_PIXELSIZE  *    is not 3 (they don't understand about dummy color components!).  So you  *    can't use color quantization if you change that value.  */
end_comment
begin_define
DECL|macro|RGB_RED
define|#
directive|define
name|RGB_RED
value|0
end_define
begin_comment
DECL|macro|RGB_RED
comment|/* Offset of Red in an RGB scanline element */
end_comment
begin_define
DECL|macro|RGB_GREEN
define|#
directive|define
name|RGB_GREEN
value|1
end_define
begin_comment
DECL|macro|RGB_GREEN
comment|/* Offset of Green */
end_comment
begin_define
DECL|macro|RGB_BLUE
define|#
directive|define
name|RGB_BLUE
value|2
end_define
begin_comment
DECL|macro|RGB_BLUE
comment|/* Offset of Blue */
end_comment
begin_define
DECL|macro|RGB_PIXELSIZE
define|#
directive|define
name|RGB_PIXELSIZE
value|3
end_define
begin_comment
DECL|macro|RGB_PIXELSIZE
comment|/* JSAMPLEs per RGB scanline element */
end_comment
begin_comment
comment|/* Definitions for speed-related optimizations. */
end_comment
begin_comment
comment|/* If your compiler supports inline functions, define INLINE  * as the inline keyword; otherwise define it as empty.  */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|INLINE
end_ifndef
begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef
begin_comment
comment|/* for instance, GNU C knows about inline */
end_comment
begin_define
DECL|macro|INLINE
define|#
directive|define
name|INLINE
value|__inline__
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|INLINE
end_ifndef
begin_define
DECL|macro|INLINE
define|#
directive|define
name|INLINE
end_define
begin_comment
DECL|macro|INLINE
comment|/* default is to define it as empty */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* On some machines (notably 68000 series) "int" is 32 bits, but multiplying  * two 16-bit shorts is faster than multiplying two ints.  Define MULTIPLIER  * as short on such a machine.  MULTIPLIER must be at least 16 bits wide.  */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|MULTIPLIER
end_ifndef
begin_define
DECL|macro|MULTIPLIER
define|#
directive|define
name|MULTIPLIER
value|int
end_define
begin_comment
DECL|macro|MULTIPLIER
comment|/* type for fastest integer multiply */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* FAST_FLOAT should be either float or double, whichever is done faster  * by your compiler.  (Note that this type is only used in the floating point  * DCT routines, so it only matters if you've defined DCT_FLOAT_SUPPORTED.)  * Typically, float is faster in ANSI C compilers, while double is faster in  * pre-ANSI compilers (because they insist on converting to double anyway).  * The code below therefore chooses float if we have ANSI-style prototypes.  */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|FAST_FLOAT
end_ifndef
begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PROTOTYPES
end_ifdef
begin_define
DECL|macro|FAST_FLOAT
define|#
directive|define
name|FAST_FLOAT
value|float
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|FAST_FLOAT
define|#
directive|define
name|FAST_FLOAT
value|double
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* JPEG_INTERNAL_OPTIONS */
end_comment
end_unit
