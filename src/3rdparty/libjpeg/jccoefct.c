begin_unit
begin_comment
comment|/*  * jccoefct.c  *  * Copyright (C) 1994-1997, Thomas G. Lane.  * This file is part of the Independent JPEG Group's software.  * For conditions of distribution and use, see the accompanying README file.  *  * This file contains the coefficient buffer controller for compression.  * This controller is the top level of the JPEG compressor proper.  * The coefficient buffer lies between forward-DCT and entropy encoding steps.  */
end_comment
begin_define
DECL|macro|JPEG_INTERNALS
define|#
directive|define
name|JPEG_INTERNALS
end_define
begin_include
include|#
directive|include
file|"jinclude.h"
end_include
begin_include
include|#
directive|include
file|"jpeglib.h"
end_include
begin_comment
comment|/* We use a full-image coefficient buffer when doing Huffman optimization,  * and also for writing multiple-scan JPEG files.  In all cases, the DCT  * step is run during the first pass, and subsequent passes need only read  * the buffered coefficients.  */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|ENTROPY_OPT_SUPPORTED
end_ifdef
begin_define
DECL|macro|FULL_COEF_BUFFER_SUPPORTED
define|#
directive|define
name|FULL_COEF_BUFFER_SUPPORTED
end_define
begin_else
else|#
directive|else
end_else
begin_ifdef
ifdef|#
directive|ifdef
name|C_MULTISCAN_FILES_SUPPORTED
end_ifdef
begin_define
DECL|macro|FULL_COEF_BUFFER_SUPPORTED
define|#
directive|define
name|FULL_COEF_BUFFER_SUPPORTED
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* Private buffer controller object */
end_comment
begin_typedef
typedef|typedef
struct|struct
block|{
DECL|member|pub
name|struct
name|jpeg_c_coef_controller
name|pub
decl_stmt|;
comment|/* public fields */
DECL|member|iMCU_row_num
name|JDIMENSION
name|iMCU_row_num
decl_stmt|;
comment|/* iMCU row # within image */
DECL|member|mcu_ctr
name|JDIMENSION
name|mcu_ctr
decl_stmt|;
comment|/* counts MCUs processed in current row */
DECL|member|MCU_vert_offset
name|int
name|MCU_vert_offset
decl_stmt|;
comment|/* counts MCU rows within iMCU row */
DECL|member|MCU_rows_per_iMCU_row
name|int
name|MCU_rows_per_iMCU_row
decl_stmt|;
comment|/* number of such rows needed */
comment|/* For single-pass compression, it's sufficient to buffer just one MCU    * (although this may prove a bit slow in practice).  We allocate a    * workspace of C_MAX_BLOCKS_IN_MCU coefficient blocks, and reuse it for each    * MCU constructed and sent.  (On 80x86, the workspace is FAR even though    * it's not really very big; this is to keep the module interfaces unchanged    * when a large coefficient buffer is necessary.)    * In multi-pass modes, this array points to the current MCU's blocks    * within the virtual arrays.    */
DECL|member|MCU_buffer
name|JBLOCKROW
name|MCU_buffer
index|[
name|C_MAX_BLOCKS_IN_MCU
index|]
decl_stmt|;
comment|/* In multi-pass modes, we need a virtual block array for each component. */
DECL|member|whole_image
name|jvirt_barray_ptr
name|whole_image
index|[
name|MAX_COMPONENTS
index|]
decl_stmt|;
block|}
DECL|typedef|my_coef_controller
name|my_coef_controller
typedef|;
end_typedef
begin_typedef
DECL|typedef|my_coef_ptr
typedef|typedef
name|my_coef_controller
modifier|*
name|my_coef_ptr
typedef|;
end_typedef
begin_comment
comment|/* Forward declarations */
end_comment
begin_macro
name|METHODDEF
argument_list|(
argument|boolean
argument_list|)
end_macro
begin_decl_stmt
name|compress_data
name|JPP
argument_list|(
operator|(
name|j_compress_ptr
name|cinfo
operator|,
name|JSAMPIMAGE
name|input_buf
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt
begin_ifdef
ifdef|#
directive|ifdef
name|FULL_COEF_BUFFER_SUPPORTED
end_ifdef
begin_macro
DECL|variable|compress_first_pass
name|METHODDEF
argument_list|(
argument|boolean
argument_list|)
end_macro
begin_decl_stmt
DECL|variable|compress_first_pass
name|compress_first_pass
name|JPP
argument_list|(
operator|(
name|j_compress_ptr
name|cinfo
operator|,
name|JSAMPIMAGE
name|input_buf
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt
begin_macro
name|METHODDEF
argument_list|(
argument|boolean
argument_list|)
end_macro
begin_decl_stmt
name|compress_output
name|JPP
argument_list|(
operator|(
name|j_compress_ptr
name|cinfo
operator|,
name|JSAMPIMAGE
name|input_buf
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_macro
name|LOCAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
name|start_iMCU_row
argument_list|(
argument|j_compress_ptr cinfo
argument_list|)
end_macro
begin_comment
comment|/* Reset within-iMCU-row counters for a new row */
end_comment
begin_block
block|{
name|my_coef_ptr
name|coef
init|=
operator|(
name|my_coef_ptr
operator|)
name|cinfo
operator|->
name|coef
decl_stmt|;
comment|/* In an interleaved scan, an MCU row is the same as an iMCU row.    * In a noninterleaved scan, an iMCU row has v_samp_factor MCU rows.    * But at the bottom of the image, process only what's left.    */
if|if
condition|(
name|cinfo
operator|->
name|comps_in_scan
operator|>
literal|1
condition|)
block|{
name|coef
operator|->
name|MCU_rows_per_iMCU_row
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|coef
operator|->
name|iMCU_row_num
operator|<
operator|(
name|cinfo
operator|->
name|total_iMCU_rows
operator|-
literal|1
operator|)
condition|)
name|coef
operator|->
name|MCU_rows_per_iMCU_row
operator|=
name|cinfo
operator|->
name|cur_comp_info
index|[
literal|0
index|]
operator|->
name|v_samp_factor
expr_stmt|;
else|else
name|coef
operator|->
name|MCU_rows_per_iMCU_row
operator|=
name|cinfo
operator|->
name|cur_comp_info
index|[
literal|0
index|]
operator|->
name|last_row_height
expr_stmt|;
block|}
name|coef
operator|->
name|mcu_ctr
operator|=
literal|0
expr_stmt|;
name|coef
operator|->
name|MCU_vert_offset
operator|=
literal|0
expr_stmt|;
block|}
end_block
begin_comment
comment|/*  * Initialize for a processing pass.  */
end_comment
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|start_pass_coef
name|start_pass_coef
argument_list|(
argument|j_compress_ptr cinfo
argument_list|,
argument|J_BUF_MODE pass_mode
argument_list|)
end_macro
begin_block
block|{
name|my_coef_ptr
name|coef
init|=
operator|(
name|my_coef_ptr
operator|)
name|cinfo
operator|->
name|coef
decl_stmt|;
name|coef
operator|->
name|iMCU_row_num
operator|=
literal|0
expr_stmt|;
name|start_iMCU_row
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pass_mode
condition|)
block|{
case|case
name|JBUF_PASS_THRU
case|:
if|if
condition|(
name|coef
operator|->
name|whole_image
index|[
literal|0
index|]
operator|!=
name|NULL
condition|)
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_BUFFER_MODE
argument_list|)
expr_stmt|;
name|coef
operator|->
name|pub
operator|.
name|compress_data
operator|=
name|compress_data
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|FULL_COEF_BUFFER_SUPPORTED
case|case
name|JBUF_SAVE_AND_PASS
case|:
if|if
condition|(
name|coef
operator|->
name|whole_image
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_BUFFER_MODE
argument_list|)
expr_stmt|;
name|coef
operator|->
name|pub
operator|.
name|compress_data
operator|=
name|compress_first_pass
expr_stmt|;
break|break;
case|case
name|JBUF_CRANK_DEST
case|:
if|if
condition|(
name|coef
operator|->
name|whole_image
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_BUFFER_MODE
argument_list|)
expr_stmt|;
name|coef
operator|->
name|pub
operator|.
name|compress_data
operator|=
name|compress_output
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_BUFFER_MODE
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_block
begin_comment
comment|/*  * Process some data in the single-pass case.  * We process the equivalent of one fully interleaved MCU row ("iMCU" row)  * per call, ie, v_samp_factor block rows for each component in the image.  * Returns TRUE if the iMCU row is completed, FALSE if suspended.  *  * NB: input_buf contains a plane for each component in image,  * which we index according to the component's SOF position.  */
end_comment
begin_macro
DECL|function|METHODDEF
name|METHODDEF
argument_list|(
argument|boolean
argument_list|)
end_macro
begin_macro
name|compress_data
argument_list|(
argument|j_compress_ptr cinfo
argument_list|,
argument|JSAMPIMAGE input_buf
argument_list|)
end_macro
begin_block
block|{
name|my_coef_ptr
name|coef
init|=
operator|(
name|my_coef_ptr
operator|)
name|cinfo
operator|->
name|coef
decl_stmt|;
name|JDIMENSION
name|MCU_col_num
decl_stmt|;
comment|/* index of current MCU within row */
name|JDIMENSION
name|last_MCU_col
init|=
name|cinfo
operator|->
name|MCUs_per_row
operator|-
literal|1
decl_stmt|;
name|JDIMENSION
name|last_iMCU_row
init|=
name|cinfo
operator|->
name|total_iMCU_rows
operator|-
literal|1
decl_stmt|;
name|int
name|blkn
decl_stmt|,
name|bi
decl_stmt|,
name|ci
decl_stmt|,
name|yindex
decl_stmt|,
name|yoffset
decl_stmt|,
name|blockcnt
decl_stmt|;
name|JDIMENSION
name|ypos
decl_stmt|,
name|xpos
decl_stmt|;
name|jpeg_component_info
modifier|*
name|compptr
decl_stmt|;
name|forward_DCT_ptr
name|forward_DCT
decl_stmt|;
comment|/* Loop to write as much as one whole iMCU row */
for|for
control|(
name|yoffset
operator|=
name|coef
operator|->
name|MCU_vert_offset
init|;
name|yoffset
operator|<
name|coef
operator|->
name|MCU_rows_per_iMCU_row
condition|;
name|yoffset
operator|++
control|)
block|{
for|for
control|(
name|MCU_col_num
operator|=
name|coef
operator|->
name|mcu_ctr
init|;
name|MCU_col_num
operator|<=
name|last_MCU_col
condition|;
name|MCU_col_num
operator|++
control|)
block|{
comment|/* Determine where data comes from in input_buf and do the DCT thing.        * Each call on forward_DCT processes a horizontal row of DCT blocks        * as wide as an MCU; we rely on having allocated the MCU_buffer[] blocks        * sequentially.  Dummy blocks at the right or bottom edge are filled in        * specially.  The data in them does not matter for image reconstruction,        * so we fill them with values that will encode to the smallest amount of        * data, viz: all zeroes in the AC entries, DC entries equal to previous        * block's DC value.  (Thanks to Thomas Kinsman for this idea.)        */
name|blkn
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ci
operator|=
literal|0
init|;
name|ci
operator|<
name|cinfo
operator|->
name|comps_in_scan
condition|;
name|ci
operator|++
control|)
block|{
name|compptr
operator|=
name|cinfo
operator|->
name|cur_comp_info
index|[
name|ci
index|]
expr_stmt|;
name|forward_DCT
operator|=
name|cinfo
operator|->
name|fdct
operator|->
name|forward_DCT
index|[
name|compptr
operator|->
name|component_index
index|]
expr_stmt|;
name|blockcnt
operator|=
operator|(
name|MCU_col_num
operator|<
name|last_MCU_col
operator|)
condition|?
name|compptr
operator|->
name|MCU_width
else|:
name|compptr
operator|->
name|last_col_width
expr_stmt|;
name|xpos
operator|=
name|MCU_col_num
operator|*
name|compptr
operator|->
name|MCU_sample_width
expr_stmt|;
name|ypos
operator|=
name|yoffset
operator|*
name|compptr
operator|->
name|DCT_v_scaled_size
expr_stmt|;
comment|/* ypos == (yoffset+yindex) * DCTSIZE */
for|for
control|(
name|yindex
operator|=
literal|0
init|;
name|yindex
operator|<
name|compptr
operator|->
name|MCU_height
condition|;
name|yindex
operator|++
control|)
block|{
if|if
condition|(
name|coef
operator|->
name|iMCU_row_num
operator|<
name|last_iMCU_row
operator|||
name|yoffset
operator|+
name|yindex
operator|<
name|compptr
operator|->
name|last_row_height
condition|)
block|{
call|(
modifier|*
name|forward_DCT
call|)
argument_list|(
name|cinfo
argument_list|,
name|compptr
argument_list|,
name|input_buf
index|[
name|compptr
operator|->
name|component_index
index|]
argument_list|,
name|coef
operator|->
name|MCU_buffer
index|[
name|blkn
index|]
argument_list|,
name|ypos
argument_list|,
name|xpos
argument_list|,
operator|(
name|JDIMENSION
operator|)
name|blockcnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|blockcnt
operator|<
name|compptr
operator|->
name|MCU_width
condition|)
block|{
comment|/* Create some dummy blocks at the right edge of the image. */
name|jzero_far
argument_list|(
operator|(
name|void
name|FAR
operator|*
operator|)
name|coef
operator|->
name|MCU_buffer
index|[
name|blkn
operator|+
name|blockcnt
index|]
argument_list|,
operator|(
name|compptr
operator|->
name|MCU_width
operator|-
name|blockcnt
operator|)
operator|*
name|SIZEOF
argument_list|(
name|JBLOCK
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|bi
operator|=
name|blockcnt
init|;
name|bi
operator|<
name|compptr
operator|->
name|MCU_width
condition|;
name|bi
operator|++
control|)
block|{
name|coef
operator|->
name|MCU_buffer
index|[
name|blkn
operator|+
name|bi
index|]
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
name|coef
operator|->
name|MCU_buffer
index|[
name|blkn
operator|+
name|bi
operator|-
literal|1
index|]
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* Create a row of dummy blocks at the bottom of the image. */
name|jzero_far
argument_list|(
operator|(
name|void
name|FAR
operator|*
operator|)
name|coef
operator|->
name|MCU_buffer
index|[
name|blkn
index|]
argument_list|,
name|compptr
operator|->
name|MCU_width
operator|*
name|SIZEOF
argument_list|(
name|JBLOCK
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|bi
operator|=
literal|0
init|;
name|bi
operator|<
name|compptr
operator|->
name|MCU_width
condition|;
name|bi
operator|++
control|)
block|{
name|coef
operator|->
name|MCU_buffer
index|[
name|blkn
operator|+
name|bi
index|]
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
name|coef
operator|->
name|MCU_buffer
index|[
name|blkn
operator|-
literal|1
index|]
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
block|}
block|}
name|blkn
operator|+=
name|compptr
operator|->
name|MCU_width
expr_stmt|;
name|ypos
operator|+=
name|compptr
operator|->
name|DCT_v_scaled_size
expr_stmt|;
block|}
block|}
comment|/* Try to write the MCU.  In event of a suspension failure, we will        * re-DCT the MCU on restart (a bit inefficient, could be fixed...)        */
if|if
condition|(
operator|!
call|(
modifier|*
name|cinfo
operator|->
name|entropy
operator|->
name|encode_mcu
call|)
argument_list|(
name|cinfo
argument_list|,
name|coef
operator|->
name|MCU_buffer
argument_list|)
condition|)
block|{
comment|/* Suspension forced; update state counters and exit */
name|coef
operator|->
name|MCU_vert_offset
operator|=
name|yoffset
expr_stmt|;
name|coef
operator|->
name|mcu_ctr
operator|=
name|MCU_col_num
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
comment|/* Completed an MCU row, but perhaps not an iMCU row */
name|coef
operator|->
name|mcu_ctr
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Completed the iMCU row, advance counters for next one */
name|coef
operator|->
name|iMCU_row_num
operator|++
expr_stmt|;
name|start_iMCU_row
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_block
begin_ifdef
ifdef|#
directive|ifdef
name|FULL_COEF_BUFFER_SUPPORTED
end_ifdef
begin_comment
comment|/*  * Process some data in the first pass of a multi-pass case.  * We process the equivalent of one fully interleaved MCU row ("iMCU" row)  * per call, ie, v_samp_factor block rows for each component in the image.  * This amount of data is read from the source buffer, DCT'd and quantized,  * and saved into the virtual arrays.  We also generate suitable dummy blocks  * as needed at the right and lower edges.  (The dummy blocks are constructed  * in the virtual arrays, which have been padded appropriately.)  This makes  * it possible for subsequent passes not to worry about real vs. dummy blocks.  *  * We must also emit the data to the entropy encoder.  This is conveniently  * done by calling compress_output() after we've loaded the current strip  * of the virtual arrays.  *  * NB: input_buf contains a plane for each component in image.  All  * components are DCT'd and loaded into the virtual arrays in this pass.  * However, it may be that only a subset of the components are emitted to  * the entropy encoder during this first pass; be careful about looking  * at the scan-dependent variables (MCU dimensions, etc).  */
end_comment
begin_macro
DECL|function|METHODDEF
name|METHODDEF
argument_list|(
argument|boolean
argument_list|)
end_macro
begin_macro
name|compress_first_pass
argument_list|(
argument|j_compress_ptr cinfo
argument_list|,
argument|JSAMPIMAGE input_buf
argument_list|)
end_macro
begin_block
block|{
name|my_coef_ptr
name|coef
init|=
operator|(
name|my_coef_ptr
operator|)
name|cinfo
operator|->
name|coef
decl_stmt|;
name|JDIMENSION
name|last_iMCU_row
init|=
name|cinfo
operator|->
name|total_iMCU_rows
operator|-
literal|1
decl_stmt|;
name|JDIMENSION
name|blocks_across
decl_stmt|,
name|MCUs_across
decl_stmt|,
name|MCUindex
decl_stmt|;
name|int
name|bi
decl_stmt|,
name|ci
decl_stmt|,
name|h_samp_factor
decl_stmt|,
name|block_row
decl_stmt|,
name|block_rows
decl_stmt|,
name|ndummy
decl_stmt|;
name|JCOEF
name|lastDC
decl_stmt|;
name|jpeg_component_info
modifier|*
name|compptr
decl_stmt|;
name|JBLOCKARRAY
name|buffer
decl_stmt|;
name|JBLOCKROW
name|thisblockrow
decl_stmt|,
name|lastblockrow
decl_stmt|;
name|forward_DCT_ptr
name|forward_DCT
decl_stmt|;
for|for
control|(
name|ci
operator|=
literal|0
operator|,
name|compptr
operator|=
name|cinfo
operator|->
name|comp_info
init|;
name|ci
operator|<
name|cinfo
operator|->
name|num_components
condition|;
name|ci
operator|++
operator|,
name|compptr
operator|++
control|)
block|{
comment|/* Align the virtual buffer for this component. */
name|buffer
operator|=
call|(
modifier|*
name|cinfo
operator|->
name|mem
operator|->
name|access_virt_barray
call|)
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|,
name|coef
operator|->
name|whole_image
index|[
name|ci
index|]
argument_list|,
name|coef
operator|->
name|iMCU_row_num
operator|*
name|compptr
operator|->
name|v_samp_factor
argument_list|,
operator|(
name|JDIMENSION
operator|)
name|compptr
operator|->
name|v_samp_factor
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* Count non-dummy DCT block rows in this iMCU row. */
if|if
condition|(
name|coef
operator|->
name|iMCU_row_num
operator|<
name|last_iMCU_row
condition|)
name|block_rows
operator|=
name|compptr
operator|->
name|v_samp_factor
expr_stmt|;
else|else
block|{
comment|/* NB: can't use last_row_height here, since may not be set! */
name|block_rows
operator|=
call|(
name|int
call|)
argument_list|(
name|compptr
operator|->
name|height_in_blocks
operator|%
name|compptr
operator|->
name|v_samp_factor
argument_list|)
expr_stmt|;
if|if
condition|(
name|block_rows
operator|==
literal|0
condition|)
name|block_rows
operator|=
name|compptr
operator|->
name|v_samp_factor
expr_stmt|;
block|}
name|blocks_across
operator|=
name|compptr
operator|->
name|width_in_blocks
expr_stmt|;
name|h_samp_factor
operator|=
name|compptr
operator|->
name|h_samp_factor
expr_stmt|;
comment|/* Count number of dummy blocks to be added at the right margin. */
name|ndummy
operator|=
call|(
name|int
call|)
argument_list|(
name|blocks_across
operator|%
name|h_samp_factor
argument_list|)
expr_stmt|;
if|if
condition|(
name|ndummy
operator|>
literal|0
condition|)
name|ndummy
operator|=
name|h_samp_factor
operator|-
name|ndummy
expr_stmt|;
name|forward_DCT
operator|=
name|cinfo
operator|->
name|fdct
operator|->
name|forward_DCT
index|[
name|ci
index|]
expr_stmt|;
comment|/* Perform DCT for all non-dummy blocks in this iMCU row.  Each call      * on forward_DCT processes a complete horizontal row of DCT blocks.      */
for|for
control|(
name|block_row
operator|=
literal|0
init|;
name|block_row
operator|<
name|block_rows
condition|;
name|block_row
operator|++
control|)
block|{
name|thisblockrow
operator|=
name|buffer
index|[
name|block_row
index|]
expr_stmt|;
call|(
modifier|*
name|forward_DCT
call|)
argument_list|(
name|cinfo
argument_list|,
name|compptr
argument_list|,
name|input_buf
index|[
name|ci
index|]
argument_list|,
name|thisblockrow
argument_list|,
call|(
name|JDIMENSION
call|)
argument_list|(
name|block_row
operator|*
name|compptr
operator|->
name|DCT_v_scaled_size
argument_list|)
argument_list|,
operator|(
name|JDIMENSION
operator|)
literal|0
argument_list|,
name|blocks_across
argument_list|)
expr_stmt|;
if|if
condition|(
name|ndummy
operator|>
literal|0
condition|)
block|{
comment|/* Create dummy blocks at the right edge of the image. */
name|thisblockrow
operator|+=
name|blocks_across
expr_stmt|;
comment|/* => first dummy block */
name|jzero_far
argument_list|(
operator|(
name|void
name|FAR
operator|*
operator|)
name|thisblockrow
argument_list|,
name|ndummy
operator|*
name|SIZEOF
argument_list|(
name|JBLOCK
argument_list|)
argument_list|)
expr_stmt|;
name|lastDC
operator|=
name|thisblockrow
index|[
operator|-
literal|1
index|]
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|bi
operator|=
literal|0
init|;
name|bi
operator|<
name|ndummy
condition|;
name|bi
operator|++
control|)
block|{
name|thisblockrow
index|[
name|bi
index|]
index|[
literal|0
index|]
operator|=
name|lastDC
expr_stmt|;
block|}
block|}
block|}
comment|/* If at end of image, create dummy block rows as needed.      * The tricky part here is that within each MCU, we want the DC values      * of the dummy blocks to match the last real block's DC value.      * This squeezes a few more bytes out of the resulting file...      */
if|if
condition|(
name|coef
operator|->
name|iMCU_row_num
operator|==
name|last_iMCU_row
condition|)
block|{
name|blocks_across
operator|+=
name|ndummy
expr_stmt|;
comment|/* include lower right corner */
name|MCUs_across
operator|=
name|blocks_across
operator|/
name|h_samp_factor
expr_stmt|;
for|for
control|(
name|block_row
operator|=
name|block_rows
init|;
name|block_row
operator|<
name|compptr
operator|->
name|v_samp_factor
condition|;
name|block_row
operator|++
control|)
block|{
name|thisblockrow
operator|=
name|buffer
index|[
name|block_row
index|]
expr_stmt|;
name|lastblockrow
operator|=
name|buffer
index|[
name|block_row
operator|-
literal|1
index|]
expr_stmt|;
name|jzero_far
argument_list|(
operator|(
name|void
name|FAR
operator|*
operator|)
name|thisblockrow
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|blocks_across
operator|*
name|SIZEOF
argument_list|(
name|JBLOCK
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|MCUindex
operator|=
literal|0
init|;
name|MCUindex
operator|<
name|MCUs_across
condition|;
name|MCUindex
operator|++
control|)
block|{
name|lastDC
operator|=
name|lastblockrow
index|[
name|h_samp_factor
operator|-
literal|1
index|]
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|bi
operator|=
literal|0
init|;
name|bi
operator|<
name|h_samp_factor
condition|;
name|bi
operator|++
control|)
block|{
name|thisblockrow
index|[
name|bi
index|]
index|[
literal|0
index|]
operator|=
name|lastDC
expr_stmt|;
block|}
name|thisblockrow
operator|+=
name|h_samp_factor
expr_stmt|;
comment|/* advance to next MCU in row */
name|lastblockrow
operator|+=
name|h_samp_factor
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* NB: compress_output will increment iMCU_row_num if successful.    * A suspension return will result in redoing all the work above next time.    */
comment|/* Emit data to the entropy encoder, sharing code with subsequent passes */
return|return
name|compress_output
argument_list|(
name|cinfo
argument_list|,
name|input_buf
argument_list|)
return|;
block|}
end_block
begin_comment
comment|/*  * Process some data in subsequent passes of a multi-pass case.  * We process the equivalent of one fully interleaved MCU row ("iMCU" row)  * per call, ie, v_samp_factor block rows for each component in the scan.  * The data is obtained from the virtual arrays and fed to the entropy coder.  * Returns TRUE if the iMCU row is completed, FALSE if suspended.  *  * NB: input_buf is ignored; it is likely to be a NULL pointer.  */
end_comment
begin_macro
DECL|function|METHODDEF
name|METHODDEF
argument_list|(
argument|boolean
argument_list|)
end_macro
begin_macro
name|compress_output
argument_list|(
argument|j_compress_ptr cinfo
argument_list|,
argument|JSAMPIMAGE input_buf
argument_list|)
end_macro
begin_block
block|{
name|my_coef_ptr
name|coef
init|=
operator|(
name|my_coef_ptr
operator|)
name|cinfo
operator|->
name|coef
decl_stmt|;
name|JDIMENSION
name|MCU_col_num
decl_stmt|;
comment|/* index of current MCU within row */
name|int
name|blkn
decl_stmt|,
name|ci
decl_stmt|,
name|xindex
decl_stmt|,
name|yindex
decl_stmt|,
name|yoffset
decl_stmt|;
name|JDIMENSION
name|start_col
decl_stmt|;
name|JBLOCKARRAY
name|buffer
index|[
name|MAX_COMPS_IN_SCAN
index|]
decl_stmt|;
name|JBLOCKROW
name|buffer_ptr
decl_stmt|;
name|jpeg_component_info
modifier|*
name|compptr
decl_stmt|;
comment|/* Align the virtual buffers for the components used in this scan.    * NB: during first pass, this is safe only because the buffers will    * already be aligned properly, so jmemmgr.c won't need to do any I/O.    */
for|for
control|(
name|ci
operator|=
literal|0
init|;
name|ci
operator|<
name|cinfo
operator|->
name|comps_in_scan
condition|;
name|ci
operator|++
control|)
block|{
name|compptr
operator|=
name|cinfo
operator|->
name|cur_comp_info
index|[
name|ci
index|]
expr_stmt|;
name|buffer
index|[
name|ci
index|]
operator|=
call|(
modifier|*
name|cinfo
operator|->
name|mem
operator|->
name|access_virt_barray
call|)
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|,
name|coef
operator|->
name|whole_image
index|[
name|compptr
operator|->
name|component_index
index|]
argument_list|,
name|coef
operator|->
name|iMCU_row_num
operator|*
name|compptr
operator|->
name|v_samp_factor
argument_list|,
operator|(
name|JDIMENSION
operator|)
name|compptr
operator|->
name|v_samp_factor
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* Loop to process one whole iMCU row */
for|for
control|(
name|yoffset
operator|=
name|coef
operator|->
name|MCU_vert_offset
init|;
name|yoffset
operator|<
name|coef
operator|->
name|MCU_rows_per_iMCU_row
condition|;
name|yoffset
operator|++
control|)
block|{
for|for
control|(
name|MCU_col_num
operator|=
name|coef
operator|->
name|mcu_ctr
init|;
name|MCU_col_num
operator|<
name|cinfo
operator|->
name|MCUs_per_row
condition|;
name|MCU_col_num
operator|++
control|)
block|{
comment|/* Construct list of pointers to DCT blocks belonging to this MCU */
name|blkn
operator|=
literal|0
expr_stmt|;
comment|/* index of current DCT block within MCU */
for|for
control|(
name|ci
operator|=
literal|0
init|;
name|ci
operator|<
name|cinfo
operator|->
name|comps_in_scan
condition|;
name|ci
operator|++
control|)
block|{
name|compptr
operator|=
name|cinfo
operator|->
name|cur_comp_info
index|[
name|ci
index|]
expr_stmt|;
name|start_col
operator|=
name|MCU_col_num
operator|*
name|compptr
operator|->
name|MCU_width
expr_stmt|;
for|for
control|(
name|yindex
operator|=
literal|0
init|;
name|yindex
operator|<
name|compptr
operator|->
name|MCU_height
condition|;
name|yindex
operator|++
control|)
block|{
name|buffer_ptr
operator|=
name|buffer
index|[
name|ci
index|]
index|[
name|yindex
operator|+
name|yoffset
index|]
operator|+
name|start_col
expr_stmt|;
for|for
control|(
name|xindex
operator|=
literal|0
init|;
name|xindex
operator|<
name|compptr
operator|->
name|MCU_width
condition|;
name|xindex
operator|++
control|)
block|{
name|coef
operator|->
name|MCU_buffer
index|[
name|blkn
operator|++
index|]
operator|=
name|buffer_ptr
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|/* Try to write the MCU. */
if|if
condition|(
operator|!
call|(
modifier|*
name|cinfo
operator|->
name|entropy
operator|->
name|encode_mcu
call|)
argument_list|(
name|cinfo
argument_list|,
name|coef
operator|->
name|MCU_buffer
argument_list|)
condition|)
block|{
comment|/* Suspension forced; update state counters and exit */
name|coef
operator|->
name|MCU_vert_offset
operator|=
name|yoffset
expr_stmt|;
name|coef
operator|->
name|mcu_ctr
operator|=
name|MCU_col_num
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
comment|/* Completed an MCU row, but perhaps not an iMCU row */
name|coef
operator|->
name|mcu_ctr
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Completed the iMCU row, advance counters for next one */
name|coef
operator|->
name|iMCU_row_num
operator|++
expr_stmt|;
name|start_iMCU_row
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_block
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* FULL_COEF_BUFFER_SUPPORTED */
end_comment
begin_comment
comment|/*  * Initialize coefficient buffer controller.  */
end_comment
begin_macro
name|GLOBAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|jinit_c_coef_controller
name|jinit_c_coef_controller
argument_list|(
argument|j_compress_ptr cinfo
argument_list|,
argument|boolean need_full_buffer
argument_list|)
end_macro
begin_block
block|{
name|my_coef_ptr
name|coef
decl_stmt|;
name|coef
operator|=
call|(
name|my_coef_ptr
call|)
argument_list|(
operator|*
name|cinfo
operator|->
name|mem
operator|->
name|alloc_small
argument_list|)
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|,
name|JPOOL_IMAGE
argument_list|,
name|SIZEOF
argument_list|(
name|my_coef_controller
argument_list|)
argument_list|)
expr_stmt|;
name|cinfo
operator|->
name|coef
operator|=
operator|(
expr|struct
name|jpeg_c_coef_controller
operator|*
operator|)
name|coef
expr_stmt|;
name|coef
operator|->
name|pub
operator|.
name|start_pass
operator|=
name|start_pass_coef
expr_stmt|;
comment|/* Create the coefficient buffer. */
if|if
condition|(
name|need_full_buffer
condition|)
block|{
ifdef|#
directive|ifdef
name|FULL_COEF_BUFFER_SUPPORTED
comment|/* Allocate a full-image virtual array for each component, */
comment|/* padded to a multiple of samp_factor DCT blocks in each direction. */
name|int
name|ci
decl_stmt|;
name|jpeg_component_info
modifier|*
name|compptr
decl_stmt|;
for|for
control|(
name|ci
operator|=
literal|0
operator|,
name|compptr
operator|=
name|cinfo
operator|->
name|comp_info
init|;
name|ci
operator|<
name|cinfo
operator|->
name|num_components
condition|;
name|ci
operator|++
operator|,
name|compptr
operator|++
control|)
block|{
name|coef
operator|->
name|whole_image
index|[
name|ci
index|]
operator|=
call|(
modifier|*
name|cinfo
operator|->
name|mem
operator|->
name|request_virt_barray
call|)
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|,
name|JPOOL_IMAGE
argument_list|,
name|FALSE
argument_list|,
operator|(
name|JDIMENSION
operator|)
name|jround_up
argument_list|(
operator|(
name|long
operator|)
name|compptr
operator|->
name|width_in_blocks
argument_list|,
operator|(
name|long
operator|)
name|compptr
operator|->
name|h_samp_factor
argument_list|)
argument_list|,
operator|(
name|JDIMENSION
operator|)
name|jround_up
argument_list|(
operator|(
name|long
operator|)
name|compptr
operator|->
name|height_in_blocks
argument_list|,
operator|(
name|long
operator|)
name|compptr
operator|->
name|v_samp_factor
argument_list|)
argument_list|,
operator|(
name|JDIMENSION
operator|)
name|compptr
operator|->
name|v_samp_factor
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_BUFFER_MODE
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
comment|/* We only need a single-MCU buffer. */
name|JBLOCKROW
name|buffer
decl_stmt|;
name|int
name|i
decl_stmt|;
name|buffer
operator|=
call|(
name|JBLOCKROW
call|)
argument_list|(
operator|*
name|cinfo
operator|->
name|mem
operator|->
name|alloc_large
argument_list|)
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|,
name|JPOOL_IMAGE
argument_list|,
name|C_MAX_BLOCKS_IN_MCU
operator|*
name|SIZEOF
argument_list|(
name|JBLOCK
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|C_MAX_BLOCKS_IN_MCU
condition|;
name|i
operator|++
control|)
block|{
name|coef
operator|->
name|MCU_buffer
index|[
name|i
index|]
operator|=
name|buffer
operator|+
name|i
expr_stmt|;
block|}
name|coef
operator|->
name|whole_image
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* flag for no virtual arrays */
block|}
block|}
end_block
end_unit
