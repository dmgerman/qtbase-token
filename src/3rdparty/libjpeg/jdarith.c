begin_unit
begin_comment
comment|/*  * jdarith.c  *  * Developed 1997-2009 by Guido Vollbeding.  * This file is part of the Independent JPEG Group's software.  * For conditions of distribution and use, see the accompanying README file.  *  * This file contains portable arithmetic entropy decoding routines for JPEG  * (implementing the ISO/IEC IS 10918-1 and CCITT Recommendation ITU-T T.81).  *  * Both sequential and progressive modes are supported in this single module.  *  * Suspension is not currently supported in this module.  */
end_comment
begin_define
DECL|macro|JPEG_INTERNALS
define|#
directive|define
name|JPEG_INTERNALS
end_define
begin_include
include|#
directive|include
file|"jinclude.h"
end_include
begin_include
include|#
directive|include
file|"jpeglib.h"
end_include
begin_comment
comment|/* Expanded entropy decoder object for arithmetic decoding. */
end_comment
begin_typedef
typedef|typedef
struct|struct
block|{
DECL|member|pub
name|struct
name|jpeg_entropy_decoder
name|pub
decl_stmt|;
comment|/* public fields */
DECL|member|c
name|INT32
name|c
decl_stmt|;
comment|/* C register, base of coding interval + input bit buffer */
DECL|member|a
name|INT32
name|a
decl_stmt|;
comment|/* A register, normalized size of coding interval */
DECL|member|ct
name|int
name|ct
decl_stmt|;
comment|/* bit shift counter, # of bits left in bit buffer part of C */
comment|/* init: ct = -16 */
comment|/* run: ct = 0..7 */
comment|/* error: ct = -1 */
DECL|member|last_dc_val
name|int
name|last_dc_val
index|[
name|MAX_COMPS_IN_SCAN
index|]
decl_stmt|;
comment|/* last DC coef for each component */
DECL|member|dc_context
name|int
name|dc_context
index|[
name|MAX_COMPS_IN_SCAN
index|]
decl_stmt|;
comment|/* context index for DC conditioning */
DECL|member|restarts_to_go
name|unsigned
name|int
name|restarts_to_go
decl_stmt|;
comment|/* MCUs left in this restart interval */
comment|/* Pointers to statistics areas (these workspaces have image lifespan) */
DECL|member|dc_stats
name|unsigned
name|char
modifier|*
name|dc_stats
index|[
name|NUM_ARITH_TBLS
index|]
decl_stmt|;
DECL|member|ac_stats
name|unsigned
name|char
modifier|*
name|ac_stats
index|[
name|NUM_ARITH_TBLS
index|]
decl_stmt|;
comment|/* Statistics bin for coding with fixed probability 0.5 */
DECL|member|fixed_bin
name|unsigned
name|char
name|fixed_bin
index|[
literal|4
index|]
decl_stmt|;
block|}
DECL|typedef|arith_entropy_decoder
name|arith_entropy_decoder
typedef|;
end_typedef
begin_typedef
DECL|typedef|arith_entropy_ptr
typedef|typedef
name|arith_entropy_decoder
modifier|*
name|arith_entropy_ptr
typedef|;
end_typedef
begin_comment
comment|/* The following two definitions specify the allocation chunk size  * for the statistics area.  * According to sections F.1.4.4.1.3 and F.1.4.4.2, we need at least  * 49 statistics bins for DC, and 245 statistics bins for AC coding.  *  * We use a compact representation with 1 byte per statistics bin,  * thus the numbers directly represent byte sizes.  * This 1 byte per statistics bin contains the meaning of the MPS  * (more probable symbol) in the highest bit (mask 0x80), and the  * index into the probability estimation state machine table  * in the lower bits (mask 0x7F).  */
end_comment
begin_define
DECL|macro|DC_STAT_BINS
define|#
directive|define
name|DC_STAT_BINS
value|64
end_define
begin_define
DECL|macro|AC_STAT_BINS
define|#
directive|define
name|AC_STAT_BINS
value|256
end_define
begin_macro
name|LOCAL
argument_list|(
argument|int
argument_list|)
end_macro
begin_macro
DECL|function|get_byte
name|get_byte
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|)
end_macro
begin_comment
comment|/* Read next input byte; we do not support suspension in this module. */
end_comment
begin_block
block|{
name|struct
name|jpeg_source_mgr
modifier|*
name|src
init|=
name|cinfo
operator|->
name|src
decl_stmt|;
if|if
condition|(
name|src
operator|->
name|bytes_in_buffer
operator|==
literal|0
condition|)
if|if
condition|(
operator|!
call|(
modifier|*
name|src
operator|->
name|fill_input_buffer
call|)
argument_list|(
name|cinfo
argument_list|)
condition|)
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_CANT_SUSPEND
argument_list|)
expr_stmt|;
name|src
operator|->
name|bytes_in_buffer
operator|--
expr_stmt|;
return|return
name|GETJOCTET
argument_list|(
operator|*
name|src
operator|->
name|next_input_byte
operator|++
argument_list|)
return|;
block|}
end_block
begin_comment
comment|/*  * The core arithmetic decoding routine (common in JPEG and JBIG).  * This needs to go as fast as possible.  * Machine-dependent optimization facilities  * are not utilized in this portable implementation.  * However, this code should be fairly efficient and  * may be a good base for further optimizations anyway.  *  * Return value is 0 or 1 (binary decision).  *  * Note: I've changed the handling of the code base& bit  * buffer register C compared to other implementations  * based on the standards layout& procedures.  * While it also contains both the actual base of the  * coding interval (16 bits) and the next-bits buffer,  * the cut-point between these two parts is floating  * (instead of fixed) with the bit shift counter CT.  * Thus, we also need only one (variable instead of  * fixed size) shift for the LPS/MPS decision, and  * we can get away with any renormalization update  * of C (except for new data insertion, of course).  *  * I've also introduced a new scheme for accessing  * the probability estimation state machine table,  * derived from Markus Kuhn's JBIG implementation.  */
end_comment
begin_macro
name|LOCAL
argument_list|(
argument|int
argument_list|)
end_macro
begin_macro
DECL|function|arith_decode
name|arith_decode
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|,
argument|unsigned char *st
argument_list|)
end_macro
begin_block
block|{
specifier|register
name|arith_entropy_ptr
name|e
init|=
operator|(
name|arith_entropy_ptr
operator|)
name|cinfo
operator|->
name|entropy
decl_stmt|;
specifier|register
name|unsigned
name|char
name|nl
decl_stmt|,
name|nm
decl_stmt|;
specifier|register
name|INT32
name|qe
decl_stmt|,
name|temp
decl_stmt|;
specifier|register
name|int
name|sv
decl_stmt|,
name|data
decl_stmt|;
comment|/* Renormalization& data input per section D.2.6 */
while|while
condition|(
name|e
operator|->
name|a
operator|<
literal|0x8000L
condition|)
block|{
if|if
condition|(
operator|--
name|e
operator|->
name|ct
operator|<
literal|0
condition|)
block|{
comment|/* Need to fetch next data byte */
if|if
condition|(
name|cinfo
operator|->
name|unread_marker
condition|)
name|data
operator|=
literal|0
expr_stmt|;
comment|/* stuff zero data */
else|else
block|{
name|data
operator|=
name|get_byte
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
comment|/* read next input byte */
if|if
condition|(
name|data
operator|==
literal|0xFF
condition|)
block|{
comment|/* zero stuff or marker code */
do|do
name|data
operator|=
name|get_byte
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
do|while
condition|(
name|data
operator|==
literal|0xFF
condition|)
do|;
comment|/* swallow extra 0xFF bytes */
if|if
condition|(
name|data
operator|==
literal|0
condition|)
name|data
operator|=
literal|0xFF
expr_stmt|;
comment|/* discard stuffed zero byte */
else|else
block|{
comment|/* Note: Different from the Huffman decoder, hitting 	     * a marker while processing the compressed data 	     * segment is legal in arithmetic coding. 	     * The convention is to supply zero data 	     * then until decoding is complete. 	     */
name|cinfo
operator|->
name|unread_marker
operator|=
name|data
expr_stmt|;
name|data
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
name|e
operator|->
name|c
operator|=
operator|(
name|e
operator|->
name|c
operator|<<
literal|8
operator|)
operator||
name|data
expr_stmt|;
comment|/* insert data into C register */
if|if
condition|(
operator|(
name|e
operator|->
name|ct
operator|+=
literal|8
operator|)
operator|<
literal|0
condition|)
comment|/* update bit shift counter */
comment|/* Need more initial bytes */
if|if
condition|(
operator|++
name|e
operator|->
name|ct
operator|==
literal|0
condition|)
comment|/* Got 2 initial bytes -> re-init A and exit loop */
name|e
operator|->
name|a
operator|=
literal|0x8000L
expr_stmt|;
comment|/* => e->a = 0x10000L after loop exit */
block|}
name|e
operator|->
name|a
operator|<<=
literal|1
expr_stmt|;
block|}
comment|/* Fetch values from our compact representation of Table D.2:    * Qe values and probability estimation state machine    */
name|sv
operator|=
operator|*
name|st
expr_stmt|;
name|qe
operator|=
name|jpeg_aritab
index|[
name|sv
operator|&
literal|0x7F
index|]
expr_stmt|;
comment|/* => Qe_Value */
name|nl
operator|=
name|qe
operator|&
literal|0xFF
expr_stmt|;
name|qe
operator|>>=
literal|8
expr_stmt|;
comment|/* Next_Index_LPS + Switch_MPS */
name|nm
operator|=
name|qe
operator|&
literal|0xFF
expr_stmt|;
name|qe
operator|>>=
literal|8
expr_stmt|;
comment|/* Next_Index_MPS */
comment|/* Decode& estimation procedures per sections D.2.4& D.2.5 */
name|temp
operator|=
name|e
operator|->
name|a
operator|-
name|qe
expr_stmt|;
name|e
operator|->
name|a
operator|=
name|temp
expr_stmt|;
name|temp
operator|<<=
name|e
operator|->
name|ct
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|c
operator|>=
name|temp
condition|)
block|{
name|e
operator|->
name|c
operator|-=
name|temp
expr_stmt|;
comment|/* Conditional LPS (less probable symbol) exchange */
if|if
condition|(
name|e
operator|->
name|a
operator|<
name|qe
condition|)
block|{
name|e
operator|->
name|a
operator|=
name|qe
expr_stmt|;
operator|*
name|st
operator|=
operator|(
name|sv
operator|&
literal|0x80
operator|)
operator|^
name|nm
expr_stmt|;
comment|/* Estimate_after_MPS */
block|}
else|else
block|{
name|e
operator|->
name|a
operator|=
name|qe
expr_stmt|;
operator|*
name|st
operator|=
operator|(
name|sv
operator|&
literal|0x80
operator|)
operator|^
name|nl
expr_stmt|;
comment|/* Estimate_after_LPS */
name|sv
operator|^=
literal|0x80
expr_stmt|;
comment|/* Exchange LPS/MPS */
block|}
block|}
elseif|else
if|if
condition|(
name|e
operator|->
name|a
operator|<
literal|0x8000L
condition|)
block|{
comment|/* Conditional MPS (more probable symbol) exchange */
if|if
condition|(
name|e
operator|->
name|a
operator|<
name|qe
condition|)
block|{
operator|*
name|st
operator|=
operator|(
name|sv
operator|&
literal|0x80
operator|)
operator|^
name|nl
expr_stmt|;
comment|/* Estimate_after_LPS */
name|sv
operator|^=
literal|0x80
expr_stmt|;
comment|/* Exchange LPS/MPS */
block|}
else|else
block|{
operator|*
name|st
operator|=
operator|(
name|sv
operator|&
literal|0x80
operator|)
operator|^
name|nm
expr_stmt|;
comment|/* Estimate_after_MPS */
block|}
block|}
return|return
name|sv
operator|>>
literal|7
return|;
block|}
end_block
begin_comment
comment|/*  * Check for a restart marker& resynchronize decoder.  */
end_comment
begin_macro
name|LOCAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|process_restart
name|process_restart
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|)
end_macro
begin_block
block|{
name|arith_entropy_ptr
name|entropy
init|=
operator|(
name|arith_entropy_ptr
operator|)
name|cinfo
operator|->
name|entropy
decl_stmt|;
name|int
name|ci
decl_stmt|;
name|jpeg_component_info
modifier|*
name|compptr
decl_stmt|;
comment|/* Advance past the RSTn marker */
if|if
condition|(
operator|!
call|(
modifier|*
name|cinfo
operator|->
name|marker
operator|->
name|read_restart_marker
call|)
argument_list|(
name|cinfo
argument_list|)
condition|)
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_CANT_SUSPEND
argument_list|)
expr_stmt|;
comment|/* Re-initialize statistics areas */
for|for
control|(
name|ci
operator|=
literal|0
init|;
name|ci
operator|<
name|cinfo
operator|->
name|comps_in_scan
condition|;
name|ci
operator|++
control|)
block|{
name|compptr
operator|=
name|cinfo
operator|->
name|cur_comp_info
index|[
name|ci
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|cinfo
operator|->
name|progressive_mode
operator|||
operator|(
name|cinfo
operator|->
name|Ss
operator|==
literal|0
operator|&&
name|cinfo
operator|->
name|Ah
operator|==
literal|0
operator|)
condition|)
block|{
name|MEMZERO
argument_list|(
name|entropy
operator|->
name|dc_stats
index|[
name|compptr
operator|->
name|dc_tbl_no
index|]
argument_list|,
name|DC_STAT_BINS
argument_list|)
expr_stmt|;
comment|/* Reset DC predictions to 0 */
name|entropy
operator|->
name|last_dc_val
index|[
name|ci
index|]
operator|=
literal|0
expr_stmt|;
name|entropy
operator|->
name|dc_context
index|[
name|ci
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|!
name|cinfo
operator|->
name|progressive_mode
operator|&&
name|cinfo
operator|->
name|lim_Se
operator|)
operator|||
operator|(
name|cinfo
operator|->
name|progressive_mode
operator|&&
name|cinfo
operator|->
name|Ss
operator|)
condition|)
block|{
name|MEMZERO
argument_list|(
name|entropy
operator|->
name|ac_stats
index|[
name|compptr
operator|->
name|ac_tbl_no
index|]
argument_list|,
name|AC_STAT_BINS
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Reset arithmetic decoding variables */
name|entropy
operator|->
name|c
operator|=
literal|0
expr_stmt|;
name|entropy
operator|->
name|a
operator|=
literal|0
expr_stmt|;
name|entropy
operator|->
name|ct
operator|=
operator|-
literal|16
expr_stmt|;
comment|/* force reading 2 initial bytes to fill C */
comment|/* Reset restart counter */
name|entropy
operator|->
name|restarts_to_go
operator|=
name|cinfo
operator|->
name|restart_interval
expr_stmt|;
block|}
end_block
begin_comment
comment|/*  * Arithmetic MCU decoding.  * Each of these routines decodes and returns one MCU's worth of  * arithmetic-compressed coefficients.  * The coefficients are reordered from zigzag order into natural array order,  * but are not dequantized.  *  * The i'th block of the MCU is stored into the block pointed to by  * MCU_data[i].  WE ASSUME THIS AREA IS INITIALLY ZEROED BY THE CALLER.  */
end_comment
begin_comment
comment|/*  * MCU decoding for DC initial scan (either spectral selection,  * or first pass of successive approximation).  */
end_comment
begin_macro
DECL|function|METHODDEF
name|METHODDEF
argument_list|(
argument|boolean
argument_list|)
end_macro
begin_macro
name|decode_mcu_DC_first
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|,
argument|JBLOCKROW *MCU_data
argument_list|)
end_macro
begin_block
block|{
name|arith_entropy_ptr
name|entropy
init|=
operator|(
name|arith_entropy_ptr
operator|)
name|cinfo
operator|->
name|entropy
decl_stmt|;
name|JBLOCKROW
name|block
decl_stmt|;
name|unsigned
name|char
modifier|*
name|st
decl_stmt|;
name|int
name|blkn
decl_stmt|,
name|ci
decl_stmt|,
name|tbl
decl_stmt|,
name|sign
decl_stmt|;
name|int
name|v
decl_stmt|,
name|m
decl_stmt|;
comment|/* Process restart marker if needed */
if|if
condition|(
name|cinfo
operator|->
name|restart_interval
condition|)
block|{
if|if
condition|(
name|entropy
operator|->
name|restarts_to_go
operator|==
literal|0
condition|)
name|process_restart
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
name|entropy
operator|->
name|restarts_to_go
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|entropy
operator|->
name|ct
operator|==
operator|-
literal|1
condition|)
return|return
name|TRUE
return|;
comment|/* if error do nothing */
comment|/* Outer loop handles each block in the MCU */
for|for
control|(
name|blkn
operator|=
literal|0
init|;
name|blkn
operator|<
name|cinfo
operator|->
name|blocks_in_MCU
condition|;
name|blkn
operator|++
control|)
block|{
name|block
operator|=
name|MCU_data
index|[
name|blkn
index|]
expr_stmt|;
name|ci
operator|=
name|cinfo
operator|->
name|MCU_membership
index|[
name|blkn
index|]
expr_stmt|;
name|tbl
operator|=
name|cinfo
operator|->
name|cur_comp_info
index|[
name|ci
index|]
operator|->
name|dc_tbl_no
expr_stmt|;
comment|/* Sections F.2.4.1& F.1.4.4.1: Decoding of DC coefficients */
comment|/* Table F.4: Point to statistics bin S0 for DC coefficient coding */
name|st
operator|=
name|entropy
operator|->
name|dc_stats
index|[
name|tbl
index|]
operator|+
name|entropy
operator|->
name|dc_context
index|[
name|ci
index|]
expr_stmt|;
comment|/* Figure F.19: Decode_DC_DIFF */
if|if
condition|(
name|arith_decode
argument_list|(
name|cinfo
argument_list|,
name|st
argument_list|)
operator|==
literal|0
condition|)
name|entropy
operator|->
name|dc_context
index|[
name|ci
index|]
operator|=
literal|0
expr_stmt|;
else|else
block|{
comment|/* Figure F.21: Decoding nonzero value v */
comment|/* Figure F.22: Decoding the sign of v */
name|sign
operator|=
name|arith_decode
argument_list|(
name|cinfo
argument_list|,
name|st
operator|+
literal|1
argument_list|)
expr_stmt|;
name|st
operator|+=
literal|2
expr_stmt|;
name|st
operator|+=
name|sign
expr_stmt|;
comment|/* Figure F.23: Decoding the magnitude category of v */
if|if
condition|(
operator|(
name|m
operator|=
name|arith_decode
argument_list|(
name|cinfo
argument_list|,
name|st
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|st
operator|=
name|entropy
operator|->
name|dc_stats
index|[
name|tbl
index|]
operator|+
literal|20
expr_stmt|;
comment|/* Table F.4: X1 = 20 */
while|while
condition|(
name|arith_decode
argument_list|(
name|cinfo
argument_list|,
name|st
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|m
operator|<<=
literal|1
operator|)
operator|==
literal|0x8000
condition|)
block|{
name|WARNMS
argument_list|(
name|cinfo
argument_list|,
name|JWRN_ARITH_BAD_CODE
argument_list|)
expr_stmt|;
name|entropy
operator|->
name|ct
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* magnitude overflow */
return|return
name|TRUE
return|;
block|}
name|st
operator|+=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Section F.1.4.4.1.2: Establish dc_context conditioning category */
if|if
condition|(
name|m
operator|<
call|(
name|int
call|)
argument_list|(
operator|(
literal|1L
operator|<<
name|cinfo
operator|->
name|arith_dc_L
index|[
name|tbl
index|]
operator|)
operator|>>
literal|1
argument_list|)
condition|)
name|entropy
operator|->
name|dc_context
index|[
name|ci
index|]
operator|=
literal|0
expr_stmt|;
comment|/* zero diff category */
elseif|else
if|if
condition|(
name|m
operator|>
call|(
name|int
call|)
argument_list|(
operator|(
literal|1L
operator|<<
name|cinfo
operator|->
name|arith_dc_U
index|[
name|tbl
index|]
operator|)
operator|>>
literal|1
argument_list|)
condition|)
name|entropy
operator|->
name|dc_context
index|[
name|ci
index|]
operator|=
literal|12
operator|+
operator|(
name|sign
operator|*
literal|4
operator|)
expr_stmt|;
comment|/* large diff category */
else|else
name|entropy
operator|->
name|dc_context
index|[
name|ci
index|]
operator|=
literal|4
operator|+
operator|(
name|sign
operator|*
literal|4
operator|)
expr_stmt|;
comment|/* small diff category */
name|v
operator|=
name|m
expr_stmt|;
comment|/* Figure F.24: Decoding the magnitude bit pattern of v */
name|st
operator|+=
literal|14
expr_stmt|;
while|while
condition|(
name|m
operator|>>=
literal|1
condition|)
if|if
condition|(
name|arith_decode
argument_list|(
name|cinfo
argument_list|,
name|st
argument_list|)
condition|)
name|v
operator||=
name|m
expr_stmt|;
name|v
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|sign
condition|)
name|v
operator|=
operator|-
name|v
expr_stmt|;
name|entropy
operator|->
name|last_dc_val
index|[
name|ci
index|]
operator|+=
name|v
expr_stmt|;
block|}
comment|/* Scale and output the DC coefficient (assumes jpeg_natural_order[0]=0) */
operator|(
operator|*
name|block
operator|)
index|[
literal|0
index|]
operator|=
call|(
name|JCOEF
call|)
argument_list|(
name|entropy
operator|->
name|last_dc_val
index|[
name|ci
index|]
operator|<<
name|cinfo
operator|->
name|Al
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_block
begin_comment
comment|/*  * MCU decoding for AC initial scan (either spectral selection,  * or first pass of successive approximation).  */
end_comment
begin_macro
DECL|function|METHODDEF
name|METHODDEF
argument_list|(
argument|boolean
argument_list|)
end_macro
begin_macro
name|decode_mcu_AC_first
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|,
argument|JBLOCKROW *MCU_data
argument_list|)
end_macro
begin_block
block|{
name|arith_entropy_ptr
name|entropy
init|=
operator|(
name|arith_entropy_ptr
operator|)
name|cinfo
operator|->
name|entropy
decl_stmt|;
name|JBLOCKROW
name|block
decl_stmt|;
name|unsigned
name|char
modifier|*
name|st
decl_stmt|;
name|int
name|tbl
decl_stmt|,
name|sign
decl_stmt|,
name|k
decl_stmt|;
name|int
name|v
decl_stmt|,
name|m
decl_stmt|;
specifier|const
name|int
modifier|*
name|natural_order
decl_stmt|;
comment|/* Process restart marker if needed */
if|if
condition|(
name|cinfo
operator|->
name|restart_interval
condition|)
block|{
if|if
condition|(
name|entropy
operator|->
name|restarts_to_go
operator|==
literal|0
condition|)
name|process_restart
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
name|entropy
operator|->
name|restarts_to_go
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|entropy
operator|->
name|ct
operator|==
operator|-
literal|1
condition|)
return|return
name|TRUE
return|;
comment|/* if error do nothing */
name|natural_order
operator|=
name|cinfo
operator|->
name|natural_order
expr_stmt|;
comment|/* There is always only one block per MCU */
name|block
operator|=
name|MCU_data
index|[
literal|0
index|]
expr_stmt|;
name|tbl
operator|=
name|cinfo
operator|->
name|cur_comp_info
index|[
literal|0
index|]
operator|->
name|ac_tbl_no
expr_stmt|;
comment|/* Sections F.2.4.2& F.1.4.4.2: Decoding of AC coefficients */
comment|/* Figure F.20: Decode_AC_coefficients */
for|for
control|(
name|k
operator|=
name|cinfo
operator|->
name|Ss
init|;
name|k
operator|<=
name|cinfo
operator|->
name|Se
condition|;
name|k
operator|++
control|)
block|{
name|st
operator|=
name|entropy
operator|->
name|ac_stats
index|[
name|tbl
index|]
operator|+
literal|3
operator|*
operator|(
name|k
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|arith_decode
argument_list|(
name|cinfo
argument_list|,
name|st
argument_list|)
condition|)
break|break;
comment|/* EOB flag */
while|while
condition|(
name|arith_decode
argument_list|(
name|cinfo
argument_list|,
name|st
operator|+
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|st
operator|+=
literal|3
expr_stmt|;
name|k
operator|++
expr_stmt|;
if|if
condition|(
name|k
operator|>
name|cinfo
operator|->
name|Se
condition|)
block|{
name|WARNMS
argument_list|(
name|cinfo
argument_list|,
name|JWRN_ARITH_BAD_CODE
argument_list|)
expr_stmt|;
name|entropy
operator|->
name|ct
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* spectral overflow */
return|return
name|TRUE
return|;
block|}
block|}
comment|/* Figure F.21: Decoding nonzero value v */
comment|/* Figure F.22: Decoding the sign of v */
name|sign
operator|=
name|arith_decode
argument_list|(
name|cinfo
argument_list|,
name|entropy
operator|->
name|fixed_bin
argument_list|)
expr_stmt|;
name|st
operator|+=
literal|2
expr_stmt|;
comment|/* Figure F.23: Decoding the magnitude category of v */
if|if
condition|(
operator|(
name|m
operator|=
name|arith_decode
argument_list|(
name|cinfo
argument_list|,
name|st
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|arith_decode
argument_list|(
name|cinfo
argument_list|,
name|st
argument_list|)
condition|)
block|{
name|m
operator|<<=
literal|1
expr_stmt|;
name|st
operator|=
name|entropy
operator|->
name|ac_stats
index|[
name|tbl
index|]
operator|+
operator|(
name|k
operator|<=
name|cinfo
operator|->
name|arith_ac_K
index|[
name|tbl
index|]
condition|?
literal|189
else|:
literal|217
operator|)
expr_stmt|;
while|while
condition|(
name|arith_decode
argument_list|(
name|cinfo
argument_list|,
name|st
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|m
operator|<<=
literal|1
operator|)
operator|==
literal|0x8000
condition|)
block|{
name|WARNMS
argument_list|(
name|cinfo
argument_list|,
name|JWRN_ARITH_BAD_CODE
argument_list|)
expr_stmt|;
name|entropy
operator|->
name|ct
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* magnitude overflow */
return|return
name|TRUE
return|;
block|}
name|st
operator|+=
literal|1
expr_stmt|;
block|}
block|}
block|}
name|v
operator|=
name|m
expr_stmt|;
comment|/* Figure F.24: Decoding the magnitude bit pattern of v */
name|st
operator|+=
literal|14
expr_stmt|;
while|while
condition|(
name|m
operator|>>=
literal|1
condition|)
if|if
condition|(
name|arith_decode
argument_list|(
name|cinfo
argument_list|,
name|st
argument_list|)
condition|)
name|v
operator||=
name|m
expr_stmt|;
name|v
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|sign
condition|)
name|v
operator|=
operator|-
name|v
expr_stmt|;
comment|/* Scale and output coefficient in natural (dezigzagged) order */
operator|(
operator|*
name|block
operator|)
index|[
name|natural_order
index|[
name|k
index|]
index|]
operator|=
call|(
name|JCOEF
call|)
argument_list|(
name|v
operator|<<
name|cinfo
operator|->
name|Al
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_block
begin_comment
comment|/*  * MCU decoding for DC successive approximation refinement scan.  */
end_comment
begin_macro
DECL|function|METHODDEF
name|METHODDEF
argument_list|(
argument|boolean
argument_list|)
end_macro
begin_macro
name|decode_mcu_DC_refine
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|,
argument|JBLOCKROW *MCU_data
argument_list|)
end_macro
begin_block
block|{
name|arith_entropy_ptr
name|entropy
init|=
operator|(
name|arith_entropy_ptr
operator|)
name|cinfo
operator|->
name|entropy
decl_stmt|;
name|unsigned
name|char
modifier|*
name|st
decl_stmt|;
name|int
name|p1
decl_stmt|,
name|blkn
decl_stmt|;
comment|/* Process restart marker if needed */
if|if
condition|(
name|cinfo
operator|->
name|restart_interval
condition|)
block|{
if|if
condition|(
name|entropy
operator|->
name|restarts_to_go
operator|==
literal|0
condition|)
name|process_restart
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
name|entropy
operator|->
name|restarts_to_go
operator|--
expr_stmt|;
block|}
name|st
operator|=
name|entropy
operator|->
name|fixed_bin
expr_stmt|;
comment|/* use fixed probability estimation */
name|p1
operator|=
literal|1
operator|<<
name|cinfo
operator|->
name|Al
expr_stmt|;
comment|/* 1 in the bit position being coded */
comment|/* Outer loop handles each block in the MCU */
for|for
control|(
name|blkn
operator|=
literal|0
init|;
name|blkn
operator|<
name|cinfo
operator|->
name|blocks_in_MCU
condition|;
name|blkn
operator|++
control|)
block|{
comment|/* Encoded data is simply the next bit of the two's-complement DC value */
if|if
condition|(
name|arith_decode
argument_list|(
name|cinfo
argument_list|,
name|st
argument_list|)
condition|)
name|MCU_data
index|[
name|blkn
index|]
index|[
literal|0
index|]
index|[
literal|0
index|]
operator||=
name|p1
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_block
begin_comment
comment|/*  * MCU decoding for AC successive approximation refinement scan.  */
end_comment
begin_macro
DECL|function|METHODDEF
name|METHODDEF
argument_list|(
argument|boolean
argument_list|)
end_macro
begin_macro
name|decode_mcu_AC_refine
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|,
argument|JBLOCKROW *MCU_data
argument_list|)
end_macro
begin_block
block|{
name|arith_entropy_ptr
name|entropy
init|=
operator|(
name|arith_entropy_ptr
operator|)
name|cinfo
operator|->
name|entropy
decl_stmt|;
name|JBLOCKROW
name|block
decl_stmt|;
name|JCOEFPTR
name|thiscoef
decl_stmt|;
name|unsigned
name|char
modifier|*
name|st
decl_stmt|;
name|int
name|tbl
decl_stmt|,
name|k
decl_stmt|,
name|kex
decl_stmt|;
name|int
name|p1
decl_stmt|,
name|m1
decl_stmt|;
specifier|const
name|int
modifier|*
name|natural_order
decl_stmt|;
comment|/* Process restart marker if needed */
if|if
condition|(
name|cinfo
operator|->
name|restart_interval
condition|)
block|{
if|if
condition|(
name|entropy
operator|->
name|restarts_to_go
operator|==
literal|0
condition|)
name|process_restart
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
name|entropy
operator|->
name|restarts_to_go
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|entropy
operator|->
name|ct
operator|==
operator|-
literal|1
condition|)
return|return
name|TRUE
return|;
comment|/* if error do nothing */
name|natural_order
operator|=
name|cinfo
operator|->
name|natural_order
expr_stmt|;
comment|/* There is always only one block per MCU */
name|block
operator|=
name|MCU_data
index|[
literal|0
index|]
expr_stmt|;
name|tbl
operator|=
name|cinfo
operator|->
name|cur_comp_info
index|[
literal|0
index|]
operator|->
name|ac_tbl_no
expr_stmt|;
name|p1
operator|=
literal|1
operator|<<
name|cinfo
operator|->
name|Al
expr_stmt|;
comment|/* 1 in the bit position being coded */
name|m1
operator|=
operator|(
operator|-
literal|1
operator|)
operator|<<
name|cinfo
operator|->
name|Al
expr_stmt|;
comment|/* -1 in the bit position being coded */
comment|/* Establish EOBx (previous stage end-of-block) index */
for|for
control|(
name|kex
operator|=
name|cinfo
operator|->
name|Se
init|;
name|kex
operator|>
literal|0
condition|;
name|kex
operator|--
control|)
if|if
condition|(
operator|(
operator|*
name|block
operator|)
index|[
name|natural_order
index|[
name|kex
index|]
index|]
condition|)
break|break;
for|for
control|(
name|k
operator|=
name|cinfo
operator|->
name|Ss
init|;
name|k
operator|<=
name|cinfo
operator|->
name|Se
condition|;
name|k
operator|++
control|)
block|{
name|st
operator|=
name|entropy
operator|->
name|ac_stats
index|[
name|tbl
index|]
operator|+
literal|3
operator|*
operator|(
name|k
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|k
operator|>
name|kex
condition|)
if|if
condition|(
name|arith_decode
argument_list|(
name|cinfo
argument_list|,
name|st
argument_list|)
condition|)
break|break;
comment|/* EOB flag */
for|for
control|(
init|;
condition|;
control|)
block|{
name|thiscoef
operator|=
operator|*
name|block
operator|+
name|natural_order
index|[
name|k
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|thiscoef
condition|)
block|{
comment|/* previously nonzero coef */
if|if
condition|(
name|arith_decode
argument_list|(
name|cinfo
argument_list|,
name|st
operator|+
literal|2
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|thiscoef
operator|<
literal|0
condition|)
operator|*
name|thiscoef
operator|+=
name|m1
expr_stmt|;
else|else
operator|*
name|thiscoef
operator|+=
name|p1
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|arith_decode
argument_list|(
name|cinfo
argument_list|,
name|st
operator|+
literal|1
argument_list|)
condition|)
block|{
comment|/* newly nonzero coef */
if|if
condition|(
name|arith_decode
argument_list|(
name|cinfo
argument_list|,
name|entropy
operator|->
name|fixed_bin
argument_list|)
condition|)
operator|*
name|thiscoef
operator|=
name|m1
expr_stmt|;
else|else
operator|*
name|thiscoef
operator|=
name|p1
expr_stmt|;
break|break;
block|}
name|st
operator|+=
literal|3
expr_stmt|;
name|k
operator|++
expr_stmt|;
if|if
condition|(
name|k
operator|>
name|cinfo
operator|->
name|Se
condition|)
block|{
name|WARNMS
argument_list|(
name|cinfo
argument_list|,
name|JWRN_ARITH_BAD_CODE
argument_list|)
expr_stmt|;
name|entropy
operator|->
name|ct
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* spectral overflow */
return|return
name|TRUE
return|;
block|}
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_block
begin_comment
comment|/*  * Decode one MCU's worth of arithmetic-compressed coefficients.  */
end_comment
begin_macro
DECL|function|METHODDEF
name|METHODDEF
argument_list|(
argument|boolean
argument_list|)
end_macro
begin_macro
name|decode_mcu
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|,
argument|JBLOCKROW *MCU_data
argument_list|)
end_macro
begin_block
block|{
name|arith_entropy_ptr
name|entropy
init|=
operator|(
name|arith_entropy_ptr
operator|)
name|cinfo
operator|->
name|entropy
decl_stmt|;
name|jpeg_component_info
modifier|*
name|compptr
decl_stmt|;
name|JBLOCKROW
name|block
decl_stmt|;
name|unsigned
name|char
modifier|*
name|st
decl_stmt|;
name|int
name|blkn
decl_stmt|,
name|ci
decl_stmt|,
name|tbl
decl_stmt|,
name|sign
decl_stmt|,
name|k
decl_stmt|;
name|int
name|v
decl_stmt|,
name|m
decl_stmt|;
specifier|const
name|int
modifier|*
name|natural_order
decl_stmt|;
comment|/* Process restart marker if needed */
if|if
condition|(
name|cinfo
operator|->
name|restart_interval
condition|)
block|{
if|if
condition|(
name|entropy
operator|->
name|restarts_to_go
operator|==
literal|0
condition|)
name|process_restart
argument_list|(
name|cinfo
argument_list|)
expr_stmt|;
name|entropy
operator|->
name|restarts_to_go
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|entropy
operator|->
name|ct
operator|==
operator|-
literal|1
condition|)
return|return
name|TRUE
return|;
comment|/* if error do nothing */
name|natural_order
operator|=
name|cinfo
operator|->
name|natural_order
expr_stmt|;
comment|/* Outer loop handles each block in the MCU */
for|for
control|(
name|blkn
operator|=
literal|0
init|;
name|blkn
operator|<
name|cinfo
operator|->
name|blocks_in_MCU
condition|;
name|blkn
operator|++
control|)
block|{
name|block
operator|=
name|MCU_data
index|[
name|blkn
index|]
expr_stmt|;
name|ci
operator|=
name|cinfo
operator|->
name|MCU_membership
index|[
name|blkn
index|]
expr_stmt|;
name|compptr
operator|=
name|cinfo
operator|->
name|cur_comp_info
index|[
name|ci
index|]
expr_stmt|;
comment|/* Sections F.2.4.1& F.1.4.4.1: Decoding of DC coefficients */
name|tbl
operator|=
name|compptr
operator|->
name|dc_tbl_no
expr_stmt|;
comment|/* Table F.4: Point to statistics bin S0 for DC coefficient coding */
name|st
operator|=
name|entropy
operator|->
name|dc_stats
index|[
name|tbl
index|]
operator|+
name|entropy
operator|->
name|dc_context
index|[
name|ci
index|]
expr_stmt|;
comment|/* Figure F.19: Decode_DC_DIFF */
if|if
condition|(
name|arith_decode
argument_list|(
name|cinfo
argument_list|,
name|st
argument_list|)
operator|==
literal|0
condition|)
name|entropy
operator|->
name|dc_context
index|[
name|ci
index|]
operator|=
literal|0
expr_stmt|;
else|else
block|{
comment|/* Figure F.21: Decoding nonzero value v */
comment|/* Figure F.22: Decoding the sign of v */
name|sign
operator|=
name|arith_decode
argument_list|(
name|cinfo
argument_list|,
name|st
operator|+
literal|1
argument_list|)
expr_stmt|;
name|st
operator|+=
literal|2
expr_stmt|;
name|st
operator|+=
name|sign
expr_stmt|;
comment|/* Figure F.23: Decoding the magnitude category of v */
if|if
condition|(
operator|(
name|m
operator|=
name|arith_decode
argument_list|(
name|cinfo
argument_list|,
name|st
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|st
operator|=
name|entropy
operator|->
name|dc_stats
index|[
name|tbl
index|]
operator|+
literal|20
expr_stmt|;
comment|/* Table F.4: X1 = 20 */
while|while
condition|(
name|arith_decode
argument_list|(
name|cinfo
argument_list|,
name|st
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|m
operator|<<=
literal|1
operator|)
operator|==
literal|0x8000
condition|)
block|{
name|WARNMS
argument_list|(
name|cinfo
argument_list|,
name|JWRN_ARITH_BAD_CODE
argument_list|)
expr_stmt|;
name|entropy
operator|->
name|ct
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* magnitude overflow */
return|return
name|TRUE
return|;
block|}
name|st
operator|+=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Section F.1.4.4.1.2: Establish dc_context conditioning category */
if|if
condition|(
name|m
operator|<
call|(
name|int
call|)
argument_list|(
operator|(
literal|1L
operator|<<
name|cinfo
operator|->
name|arith_dc_L
index|[
name|tbl
index|]
operator|)
operator|>>
literal|1
argument_list|)
condition|)
name|entropy
operator|->
name|dc_context
index|[
name|ci
index|]
operator|=
literal|0
expr_stmt|;
comment|/* zero diff category */
elseif|else
if|if
condition|(
name|m
operator|>
call|(
name|int
call|)
argument_list|(
operator|(
literal|1L
operator|<<
name|cinfo
operator|->
name|arith_dc_U
index|[
name|tbl
index|]
operator|)
operator|>>
literal|1
argument_list|)
condition|)
name|entropy
operator|->
name|dc_context
index|[
name|ci
index|]
operator|=
literal|12
operator|+
operator|(
name|sign
operator|*
literal|4
operator|)
expr_stmt|;
comment|/* large diff category */
else|else
name|entropy
operator|->
name|dc_context
index|[
name|ci
index|]
operator|=
literal|4
operator|+
operator|(
name|sign
operator|*
literal|4
operator|)
expr_stmt|;
comment|/* small diff category */
name|v
operator|=
name|m
expr_stmt|;
comment|/* Figure F.24: Decoding the magnitude bit pattern of v */
name|st
operator|+=
literal|14
expr_stmt|;
while|while
condition|(
name|m
operator|>>=
literal|1
condition|)
if|if
condition|(
name|arith_decode
argument_list|(
name|cinfo
argument_list|,
name|st
argument_list|)
condition|)
name|v
operator||=
name|m
expr_stmt|;
name|v
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|sign
condition|)
name|v
operator|=
operator|-
name|v
expr_stmt|;
name|entropy
operator|->
name|last_dc_val
index|[
name|ci
index|]
operator|+=
name|v
expr_stmt|;
block|}
operator|(
operator|*
name|block
operator|)
index|[
literal|0
index|]
operator|=
operator|(
name|JCOEF
operator|)
name|entropy
operator|->
name|last_dc_val
index|[
name|ci
index|]
expr_stmt|;
comment|/* Sections F.2.4.2& F.1.4.4.2: Decoding of AC coefficients */
name|tbl
operator|=
name|compptr
operator|->
name|ac_tbl_no
expr_stmt|;
comment|/* Figure F.20: Decode_AC_coefficients */
for|for
control|(
name|k
operator|=
literal|1
init|;
name|k
operator|<=
name|cinfo
operator|->
name|lim_Se
condition|;
name|k
operator|++
control|)
block|{
name|st
operator|=
name|entropy
operator|->
name|ac_stats
index|[
name|tbl
index|]
operator|+
literal|3
operator|*
operator|(
name|k
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|arith_decode
argument_list|(
name|cinfo
argument_list|,
name|st
argument_list|)
condition|)
break|break;
comment|/* EOB flag */
while|while
condition|(
name|arith_decode
argument_list|(
name|cinfo
argument_list|,
name|st
operator|+
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|st
operator|+=
literal|3
expr_stmt|;
name|k
operator|++
expr_stmt|;
if|if
condition|(
name|k
operator|>
name|cinfo
operator|->
name|lim_Se
condition|)
block|{
name|WARNMS
argument_list|(
name|cinfo
argument_list|,
name|JWRN_ARITH_BAD_CODE
argument_list|)
expr_stmt|;
name|entropy
operator|->
name|ct
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* spectral overflow */
return|return
name|TRUE
return|;
block|}
block|}
comment|/* Figure F.21: Decoding nonzero value v */
comment|/* Figure F.22: Decoding the sign of v */
name|sign
operator|=
name|arith_decode
argument_list|(
name|cinfo
argument_list|,
name|entropy
operator|->
name|fixed_bin
argument_list|)
expr_stmt|;
name|st
operator|+=
literal|2
expr_stmt|;
comment|/* Figure F.23: Decoding the magnitude category of v */
if|if
condition|(
operator|(
name|m
operator|=
name|arith_decode
argument_list|(
name|cinfo
argument_list|,
name|st
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|arith_decode
argument_list|(
name|cinfo
argument_list|,
name|st
argument_list|)
condition|)
block|{
name|m
operator|<<=
literal|1
expr_stmt|;
name|st
operator|=
name|entropy
operator|->
name|ac_stats
index|[
name|tbl
index|]
operator|+
operator|(
name|k
operator|<=
name|cinfo
operator|->
name|arith_ac_K
index|[
name|tbl
index|]
condition|?
literal|189
else|:
literal|217
operator|)
expr_stmt|;
while|while
condition|(
name|arith_decode
argument_list|(
name|cinfo
argument_list|,
name|st
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|m
operator|<<=
literal|1
operator|)
operator|==
literal|0x8000
condition|)
block|{
name|WARNMS
argument_list|(
name|cinfo
argument_list|,
name|JWRN_ARITH_BAD_CODE
argument_list|)
expr_stmt|;
name|entropy
operator|->
name|ct
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* magnitude overflow */
return|return
name|TRUE
return|;
block|}
name|st
operator|+=
literal|1
expr_stmt|;
block|}
block|}
block|}
name|v
operator|=
name|m
expr_stmt|;
comment|/* Figure F.24: Decoding the magnitude bit pattern of v */
name|st
operator|+=
literal|14
expr_stmt|;
while|while
condition|(
name|m
operator|>>=
literal|1
condition|)
if|if
condition|(
name|arith_decode
argument_list|(
name|cinfo
argument_list|,
name|st
argument_list|)
condition|)
name|v
operator||=
name|m
expr_stmt|;
name|v
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|sign
condition|)
name|v
operator|=
operator|-
name|v
expr_stmt|;
operator|(
operator|*
name|block
operator|)
index|[
name|natural_order
index|[
name|k
index|]
index|]
operator|=
operator|(
name|JCOEF
operator|)
name|v
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_block
begin_comment
comment|/*  * Initialize for an arithmetic-compressed scan.  */
end_comment
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|start_pass
name|start_pass
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|)
end_macro
begin_block
block|{
name|arith_entropy_ptr
name|entropy
init|=
operator|(
name|arith_entropy_ptr
operator|)
name|cinfo
operator|->
name|entropy
decl_stmt|;
name|int
name|ci
decl_stmt|,
name|tbl
decl_stmt|;
name|jpeg_component_info
modifier|*
name|compptr
decl_stmt|;
if|if
condition|(
name|cinfo
operator|->
name|progressive_mode
condition|)
block|{
comment|/* Validate progressive scan parameters */
if|if
condition|(
name|cinfo
operator|->
name|Ss
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|cinfo
operator|->
name|Se
operator|!=
literal|0
condition|)
goto|goto
name|bad
goto|;
block|}
else|else
block|{
comment|/* need not check Ss/Se< 0 since they came from unsigned bytes */
if|if
condition|(
name|cinfo
operator|->
name|Se
operator|<
name|cinfo
operator|->
name|Ss
operator|||
name|cinfo
operator|->
name|Se
operator|>
name|cinfo
operator|->
name|lim_Se
condition|)
goto|goto
name|bad
goto|;
comment|/* AC scans may have only one component */
if|if
condition|(
name|cinfo
operator|->
name|comps_in_scan
operator|!=
literal|1
condition|)
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|cinfo
operator|->
name|Ah
operator|!=
literal|0
condition|)
block|{
comment|/* Successive approximation refinement scan: must have Al = Ah-1. */
if|if
condition|(
name|cinfo
operator|->
name|Ah
operator|-
literal|1
operator|!=
name|cinfo
operator|->
name|Al
condition|)
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|cinfo
operator|->
name|Al
operator|>
literal|13
condition|)
block|{
comment|/* need not check for< 0 */
name|bad
label|:
name|ERREXIT4
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_PROGRESSION
argument_list|,
name|cinfo
operator|->
name|Ss
argument_list|,
name|cinfo
operator|->
name|Se
argument_list|,
name|cinfo
operator|->
name|Ah
argument_list|,
name|cinfo
operator|->
name|Al
argument_list|)
expr_stmt|;
block|}
comment|/* Update progression status, and verify that scan order is legal.      * Note that inter-scan inconsistencies are treated as warnings      * not fatal errors ... not clear if this is right way to behave.      */
for|for
control|(
name|ci
operator|=
literal|0
init|;
name|ci
operator|<
name|cinfo
operator|->
name|comps_in_scan
condition|;
name|ci
operator|++
control|)
block|{
name|int
name|coefi
decl_stmt|,
name|cindex
init|=
name|cinfo
operator|->
name|cur_comp_info
index|[
name|ci
index|]
operator|->
name|component_index
decl_stmt|;
name|int
modifier|*
name|coef_bit_ptr
init|=
operator|&
name|cinfo
operator|->
name|coef_bits
index|[
name|cindex
index|]
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
name|cinfo
operator|->
name|Ss
operator|&&
name|coef_bit_ptr
index|[
literal|0
index|]
operator|<
literal|0
condition|)
comment|/* AC without prior DC scan */
name|WARNMS2
argument_list|(
name|cinfo
argument_list|,
name|JWRN_BOGUS_PROGRESSION
argument_list|,
name|cindex
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|coefi
operator|=
name|cinfo
operator|->
name|Ss
init|;
name|coefi
operator|<=
name|cinfo
operator|->
name|Se
condition|;
name|coefi
operator|++
control|)
block|{
name|int
name|expected
init|=
operator|(
name|coef_bit_ptr
index|[
name|coefi
index|]
operator|<
literal|0
operator|)
condition|?
literal|0
else|:
name|coef_bit_ptr
index|[
name|coefi
index|]
decl_stmt|;
if|if
condition|(
name|cinfo
operator|->
name|Ah
operator|!=
name|expected
condition|)
name|WARNMS2
argument_list|(
name|cinfo
argument_list|,
name|JWRN_BOGUS_PROGRESSION
argument_list|,
name|cindex
argument_list|,
name|coefi
argument_list|)
expr_stmt|;
name|coef_bit_ptr
index|[
name|coefi
index|]
operator|=
name|cinfo
operator|->
name|Al
expr_stmt|;
block|}
block|}
comment|/* Select MCU decoding routine */
if|if
condition|(
name|cinfo
operator|->
name|Ah
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|cinfo
operator|->
name|Ss
operator|==
literal|0
condition|)
name|entropy
operator|->
name|pub
operator|.
name|decode_mcu
operator|=
name|decode_mcu_DC_first
expr_stmt|;
else|else
name|entropy
operator|->
name|pub
operator|.
name|decode_mcu
operator|=
name|decode_mcu_AC_first
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|cinfo
operator|->
name|Ss
operator|==
literal|0
condition|)
name|entropy
operator|->
name|pub
operator|.
name|decode_mcu
operator|=
name|decode_mcu_DC_refine
expr_stmt|;
else|else
name|entropy
operator|->
name|pub
operator|.
name|decode_mcu
operator|=
name|decode_mcu_AC_refine
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Check that the scan parameters Ss, Se, Ah/Al are OK for sequential JPEG.      * This ought to be an error condition, but we make it a warning.      */
if|if
condition|(
name|cinfo
operator|->
name|Ss
operator|!=
literal|0
operator|||
name|cinfo
operator|->
name|Ah
operator|!=
literal|0
operator|||
name|cinfo
operator|->
name|Al
operator|!=
literal|0
operator|||
operator|(
name|cinfo
operator|->
name|Se
operator|<
name|DCTSIZE2
operator|&&
name|cinfo
operator|->
name|Se
operator|!=
name|cinfo
operator|->
name|lim_Se
operator|)
condition|)
name|WARNMS
argument_list|(
name|cinfo
argument_list|,
name|JWRN_NOT_SEQUENTIAL
argument_list|)
expr_stmt|;
comment|/* Select MCU decoding routine */
name|entropy
operator|->
name|pub
operator|.
name|decode_mcu
operator|=
name|decode_mcu
expr_stmt|;
block|}
comment|/* Allocate& initialize requested statistics areas */
for|for
control|(
name|ci
operator|=
literal|0
init|;
name|ci
operator|<
name|cinfo
operator|->
name|comps_in_scan
condition|;
name|ci
operator|++
control|)
block|{
name|compptr
operator|=
name|cinfo
operator|->
name|cur_comp_info
index|[
name|ci
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|cinfo
operator|->
name|progressive_mode
operator|||
operator|(
name|cinfo
operator|->
name|Ss
operator|==
literal|0
operator|&&
name|cinfo
operator|->
name|Ah
operator|==
literal|0
operator|)
condition|)
block|{
name|tbl
operator|=
name|compptr
operator|->
name|dc_tbl_no
expr_stmt|;
if|if
condition|(
name|tbl
operator|<
literal|0
operator|||
name|tbl
operator|>=
name|NUM_ARITH_TBLS
condition|)
name|ERREXIT1
argument_list|(
name|cinfo
argument_list|,
name|JERR_NO_ARITH_TABLE
argument_list|,
name|tbl
argument_list|)
expr_stmt|;
if|if
condition|(
name|entropy
operator|->
name|dc_stats
index|[
name|tbl
index|]
operator|==
name|NULL
condition|)
name|entropy
operator|->
name|dc_stats
index|[
name|tbl
index|]
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
call|(
modifier|*
name|cinfo
operator|->
name|mem
operator|->
name|alloc_small
call|)
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|,
name|JPOOL_IMAGE
argument_list|,
name|DC_STAT_BINS
argument_list|)
expr_stmt|;
name|MEMZERO
argument_list|(
name|entropy
operator|->
name|dc_stats
index|[
name|tbl
index|]
argument_list|,
name|DC_STAT_BINS
argument_list|)
expr_stmt|;
comment|/* Initialize DC predictions to 0 */
name|entropy
operator|->
name|last_dc_val
index|[
name|ci
index|]
operator|=
literal|0
expr_stmt|;
name|entropy
operator|->
name|dc_context
index|[
name|ci
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|!
name|cinfo
operator|->
name|progressive_mode
operator|&&
name|cinfo
operator|->
name|lim_Se
operator|)
operator|||
operator|(
name|cinfo
operator|->
name|progressive_mode
operator|&&
name|cinfo
operator|->
name|Ss
operator|)
condition|)
block|{
name|tbl
operator|=
name|compptr
operator|->
name|ac_tbl_no
expr_stmt|;
if|if
condition|(
name|tbl
operator|<
literal|0
operator|||
name|tbl
operator|>=
name|NUM_ARITH_TBLS
condition|)
name|ERREXIT1
argument_list|(
name|cinfo
argument_list|,
name|JERR_NO_ARITH_TABLE
argument_list|,
name|tbl
argument_list|)
expr_stmt|;
if|if
condition|(
name|entropy
operator|->
name|ac_stats
index|[
name|tbl
index|]
operator|==
name|NULL
condition|)
name|entropy
operator|->
name|ac_stats
index|[
name|tbl
index|]
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
call|(
modifier|*
name|cinfo
operator|->
name|mem
operator|->
name|alloc_small
call|)
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|,
name|JPOOL_IMAGE
argument_list|,
name|AC_STAT_BINS
argument_list|)
expr_stmt|;
name|MEMZERO
argument_list|(
name|entropy
operator|->
name|ac_stats
index|[
name|tbl
index|]
argument_list|,
name|AC_STAT_BINS
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Initialize arithmetic decoding variables */
name|entropy
operator|->
name|c
operator|=
literal|0
expr_stmt|;
name|entropy
operator|->
name|a
operator|=
literal|0
expr_stmt|;
name|entropy
operator|->
name|ct
operator|=
operator|-
literal|16
expr_stmt|;
comment|/* force reading 2 initial bytes to fill C */
comment|/* Initialize restart counter */
name|entropy
operator|->
name|restarts_to_go
operator|=
name|cinfo
operator|->
name|restart_interval
expr_stmt|;
block|}
end_block
begin_comment
comment|/*  * Module initialization routine for arithmetic entropy decoding.  */
end_comment
begin_macro
name|GLOBAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|jinit_arith_decoder
name|jinit_arith_decoder
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|)
end_macro
begin_block
block|{
name|arith_entropy_ptr
name|entropy
decl_stmt|;
name|int
name|i
decl_stmt|;
name|entropy
operator|=
call|(
name|arith_entropy_ptr
call|)
argument_list|(
operator|*
name|cinfo
operator|->
name|mem
operator|->
name|alloc_small
argument_list|)
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|,
name|JPOOL_IMAGE
argument_list|,
name|SIZEOF
argument_list|(
name|arith_entropy_decoder
argument_list|)
argument_list|)
expr_stmt|;
name|cinfo
operator|->
name|entropy
operator|=
operator|(
expr|struct
name|jpeg_entropy_decoder
operator|*
operator|)
name|entropy
expr_stmt|;
name|entropy
operator|->
name|pub
operator|.
name|start_pass
operator|=
name|start_pass
expr_stmt|;
comment|/* Mark tables unallocated */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_ARITH_TBLS
condition|;
name|i
operator|++
control|)
block|{
name|entropy
operator|->
name|dc_stats
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|entropy
operator|->
name|ac_stats
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Initialize index for fixed probability estimation */
name|entropy
operator|->
name|fixed_bin
index|[
literal|0
index|]
operator|=
literal|113
expr_stmt|;
if|if
condition|(
name|cinfo
operator|->
name|progressive_mode
condition|)
block|{
comment|/* Create progression status table */
name|int
modifier|*
name|coef_bit_ptr
decl_stmt|,
name|ci
decl_stmt|;
name|cinfo
operator|->
name|coef_bits
operator|=
operator|(
name|int
argument_list|(
operator|*
argument_list|)
index|[
name|DCTSIZE2
index|]
operator|)
call|(
modifier|*
name|cinfo
operator|->
name|mem
operator|->
name|alloc_small
call|)
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|,
name|JPOOL_IMAGE
argument_list|,
name|cinfo
operator|->
name|num_components
operator|*
name|DCTSIZE2
operator|*
name|SIZEOF
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|coef_bit_ptr
operator|=
operator|&
name|cinfo
operator|->
name|coef_bits
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|ci
operator|=
literal|0
init|;
name|ci
operator|<
name|cinfo
operator|->
name|num_components
condition|;
name|ci
operator|++
control|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DCTSIZE2
condition|;
name|i
operator|++
control|)
operator|*
name|coef_bit_ptr
operator|++
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
end_block
end_unit
