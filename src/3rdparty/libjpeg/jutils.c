begin_unit
begin_comment
comment|/*  * jutils.c  *  * Copyright (C) 1991-1996, Thomas G. Lane.  * Modified 2009 by Guido Vollbeding.  * This file is part of the Independent JPEG Group's software.  * For conditions of distribution and use, see the accompanying README file.  *  * This file contains tables and miscellaneous utility routines needed  * for both compression and decompression.  * Note we prefix all global names with "j" to minimize conflicts with  * a surrounding application.  */
end_comment
begin_define
DECL|macro|JPEG_INTERNALS
define|#
directive|define
name|JPEG_INTERNALS
end_define
begin_include
include|#
directive|include
file|"jinclude.h"
end_include
begin_include
include|#
directive|include
file|"jpeglib.h"
end_include
begin_comment
comment|/*  * jpeg_zigzag_order[i] is the zigzag-order position of the i'th element  * of a DCT block read in natural order (left to right, top to bottom).  */
end_comment
begin_if
if|#
directive|if
literal|0
end_if
begin_comment
comment|/* This table is not actually needed in v6a */
end_comment
begin_endif
unit|const int jpeg_zigzag_order[DCTSIZE2] = {    0,  1,  5,  6, 14, 15, 27, 28,    2,  4,  7, 13, 16, 26, 29, 42,    3,  8, 12, 17, 25, 30, 41, 43,    9, 11, 18, 24, 31, 40, 44, 53,   10, 19, 23, 32, 39, 45, 52, 54,   20, 22, 33, 38, 46, 51, 55, 60,   21, 34, 37, 47, 50, 56, 59, 61,   35, 36, 48, 49, 57, 58, 62, 63 };
endif|#
directive|endif
end_endif
begin_comment
comment|/*  * jpeg_natural_order[i] is the natural-order position of the i'th element  * of zigzag order.  *  * When reading corrupted data, the Huffman decoders could attempt  * to reference an entry beyond the end of this array (if the decoded  * zero run length reaches past the end of the block).  To prevent  * wild stores without adding an inner-loop test, we put some extra  * "63"s after the real entries.  This will cause the extra coefficient  * to be stored in location 63 of the block, not somewhere random.  * The worst case would be a run-length of 15, which means we need 16  * fake entries.  */
end_comment
begin_decl_stmt
DECL|variable|jpeg_natural_order
specifier|const
name|int
name|jpeg_natural_order
index|[
name|DCTSIZE2
operator|+
literal|16
index|]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|8
block|,
literal|16
block|,
literal|9
block|,
literal|2
block|,
literal|3
block|,
literal|10
block|,
literal|17
block|,
literal|24
block|,
literal|32
block|,
literal|25
block|,
literal|18
block|,
literal|11
block|,
literal|4
block|,
literal|5
block|,
literal|12
block|,
literal|19
block|,
literal|26
block|,
literal|33
block|,
literal|40
block|,
literal|48
block|,
literal|41
block|,
literal|34
block|,
literal|27
block|,
literal|20
block|,
literal|13
block|,
literal|6
block|,
literal|7
block|,
literal|14
block|,
literal|21
block|,
literal|28
block|,
literal|35
block|,
literal|42
block|,
literal|49
block|,
literal|56
block|,
literal|57
block|,
literal|50
block|,
literal|43
block|,
literal|36
block|,
literal|29
block|,
literal|22
block|,
literal|15
block|,
literal|23
block|,
literal|30
block|,
literal|37
block|,
literal|44
block|,
literal|51
block|,
literal|58
block|,
literal|59
block|,
literal|52
block|,
literal|45
block|,
literal|38
block|,
literal|31
block|,
literal|39
block|,
literal|46
block|,
literal|53
block|,
literal|60
block|,
literal|61
block|,
literal|54
block|,
literal|47
block|,
literal|55
block|,
literal|62
block|,
literal|63
block|,
literal|63
block|,
literal|63
block|,
literal|63
block|,
literal|63
block|,
literal|63
block|,
literal|63
block|,
literal|63
block|,
literal|63
block|,
comment|/* extra entries for safety in decoder */
literal|63
block|,
literal|63
block|,
literal|63
block|,
literal|63
block|,
literal|63
block|,
literal|63
block|,
literal|63
block|,
literal|63
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|jpeg_natural_order7
specifier|const
name|int
name|jpeg_natural_order7
index|[
literal|7
operator|*
literal|7
operator|+
literal|16
index|]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|8
block|,
literal|16
block|,
literal|9
block|,
literal|2
block|,
literal|3
block|,
literal|10
block|,
literal|17
block|,
literal|24
block|,
literal|32
block|,
literal|25
block|,
literal|18
block|,
literal|11
block|,
literal|4
block|,
literal|5
block|,
literal|12
block|,
literal|19
block|,
literal|26
block|,
literal|33
block|,
literal|40
block|,
literal|48
block|,
literal|41
block|,
literal|34
block|,
literal|27
block|,
literal|20
block|,
literal|13
block|,
literal|6
block|,
literal|14
block|,
literal|21
block|,
literal|28
block|,
literal|35
block|,
literal|42
block|,
literal|49
block|,
literal|50
block|,
literal|43
block|,
literal|36
block|,
literal|29
block|,
literal|22
block|,
literal|30
block|,
literal|37
block|,
literal|44
block|,
literal|51
block|,
literal|52
block|,
literal|45
block|,
literal|38
block|,
literal|46
block|,
literal|53
block|,
literal|54
block|,
literal|63
block|,
literal|63
block|,
literal|63
block|,
literal|63
block|,
literal|63
block|,
literal|63
block|,
literal|63
block|,
literal|63
block|,
comment|/* extra entries for safety in decoder */
literal|63
block|,
literal|63
block|,
literal|63
block|,
literal|63
block|,
literal|63
block|,
literal|63
block|,
literal|63
block|,
literal|63
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|jpeg_natural_order6
specifier|const
name|int
name|jpeg_natural_order6
index|[
literal|6
operator|*
literal|6
operator|+
literal|16
index|]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|8
block|,
literal|16
block|,
literal|9
block|,
literal|2
block|,
literal|3
block|,
literal|10
block|,
literal|17
block|,
literal|24
block|,
literal|32
block|,
literal|25
block|,
literal|18
block|,
literal|11
block|,
literal|4
block|,
literal|5
block|,
literal|12
block|,
literal|19
block|,
literal|26
block|,
literal|33
block|,
literal|40
block|,
literal|41
block|,
literal|34
block|,
literal|27
block|,
literal|20
block|,
literal|13
block|,
literal|21
block|,
literal|28
block|,
literal|35
block|,
literal|42
block|,
literal|43
block|,
literal|36
block|,
literal|29
block|,
literal|37
block|,
literal|44
block|,
literal|45
block|,
literal|63
block|,
literal|63
block|,
literal|63
block|,
literal|63
block|,
literal|63
block|,
literal|63
block|,
literal|63
block|,
literal|63
block|,
comment|/* extra entries for safety in decoder */
literal|63
block|,
literal|63
block|,
literal|63
block|,
literal|63
block|,
literal|63
block|,
literal|63
block|,
literal|63
block|,
literal|63
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|jpeg_natural_order5
specifier|const
name|int
name|jpeg_natural_order5
index|[
literal|5
operator|*
literal|5
operator|+
literal|16
index|]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|8
block|,
literal|16
block|,
literal|9
block|,
literal|2
block|,
literal|3
block|,
literal|10
block|,
literal|17
block|,
literal|24
block|,
literal|32
block|,
literal|25
block|,
literal|18
block|,
literal|11
block|,
literal|4
block|,
literal|12
block|,
literal|19
block|,
literal|26
block|,
literal|33
block|,
literal|34
block|,
literal|27
block|,
literal|20
block|,
literal|28
block|,
literal|35
block|,
literal|36
block|,
literal|63
block|,
literal|63
block|,
literal|63
block|,
literal|63
block|,
literal|63
block|,
literal|63
block|,
literal|63
block|,
literal|63
block|,
comment|/* extra entries for safety in decoder */
literal|63
block|,
literal|63
block|,
literal|63
block|,
literal|63
block|,
literal|63
block|,
literal|63
block|,
literal|63
block|,
literal|63
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|jpeg_natural_order4
specifier|const
name|int
name|jpeg_natural_order4
index|[
literal|4
operator|*
literal|4
operator|+
literal|16
index|]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|8
block|,
literal|16
block|,
literal|9
block|,
literal|2
block|,
literal|3
block|,
literal|10
block|,
literal|17
block|,
literal|24
block|,
literal|25
block|,
literal|18
block|,
literal|11
block|,
literal|19
block|,
literal|26
block|,
literal|27
block|,
literal|63
block|,
literal|63
block|,
literal|63
block|,
literal|63
block|,
literal|63
block|,
literal|63
block|,
literal|63
block|,
literal|63
block|,
comment|/* extra entries for safety in decoder */
literal|63
block|,
literal|63
block|,
literal|63
block|,
literal|63
block|,
literal|63
block|,
literal|63
block|,
literal|63
block|,
literal|63
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|jpeg_natural_order3
specifier|const
name|int
name|jpeg_natural_order3
index|[
literal|3
operator|*
literal|3
operator|+
literal|16
index|]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|8
block|,
literal|16
block|,
literal|9
block|,
literal|2
block|,
literal|10
block|,
literal|17
block|,
literal|18
block|,
literal|63
block|,
literal|63
block|,
literal|63
block|,
literal|63
block|,
literal|63
block|,
literal|63
block|,
literal|63
block|,
literal|63
block|,
comment|/* extra entries for safety in decoder */
literal|63
block|,
literal|63
block|,
literal|63
block|,
literal|63
block|,
literal|63
block|,
literal|63
block|,
literal|63
block|,
literal|63
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|jpeg_natural_order2
specifier|const
name|int
name|jpeg_natural_order2
index|[
literal|2
operator|*
literal|2
operator|+
literal|16
index|]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|8
block|,
literal|9
block|,
literal|63
block|,
literal|63
block|,
literal|63
block|,
literal|63
block|,
literal|63
block|,
literal|63
block|,
literal|63
block|,
literal|63
block|,
comment|/* extra entries for safety in decoder */
literal|63
block|,
literal|63
block|,
literal|63
block|,
literal|63
block|,
literal|63
block|,
literal|63
block|,
literal|63
block|,
literal|63
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*  * Arithmetic utilities  */
end_comment
begin_macro
name|GLOBAL
argument_list|(
argument|long
argument_list|)
end_macro
begin_macro
DECL|function|jdiv_round_up
name|jdiv_round_up
argument_list|(
argument|long a
argument_list|,
argument|long b
argument_list|)
end_macro
begin_comment
comment|/* Compute a/b rounded up to next integer, ie, ceil(a/b) */
end_comment
begin_comment
comment|/* Assumes a>= 0, b> 0 */
end_comment
begin_block
block|{
return|return
operator|(
name|a
operator|+
name|b
operator|-
literal|1L
operator|)
operator|/
name|b
return|;
block|}
end_block
begin_macro
name|GLOBAL
argument_list|(
argument|long
argument_list|)
end_macro
begin_macro
DECL|function|jround_up
name|jround_up
argument_list|(
argument|long a
argument_list|,
argument|long b
argument_list|)
end_macro
begin_comment
comment|/* Compute a rounded up to next multiple of b, ie, ceil(a/b)*b */
end_comment
begin_comment
comment|/* Assumes a>= 0, b> 0 */
end_comment
begin_block
block|{
name|a
operator|+=
name|b
operator|-
literal|1L
expr_stmt|;
return|return
name|a
operator|-
operator|(
name|a
operator|%
name|b
operator|)
return|;
block|}
end_block
begin_comment
comment|/* On normal machines we can apply MEMCOPY() and MEMZERO() to sample arrays  * and coefficient-block arrays.  This won't work on 80x86 because the arrays  * are FAR and we're assuming a small-pointer memory model.  However, some  * DOS compilers provide far-pointer versions of memcpy() and memset() even  * in the small-model libraries.  These will be used if USE_FMEM is defined.  * Otherwise, the routines below do it the hard way.  (The performance cost  * is not all that great, because these routines aren't very heavily used.)  */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|NEED_FAR_POINTERS
end_ifndef
begin_comment
comment|/* normal case, same as regular macros */
end_comment
begin_define
DECL|macro|FMEMCOPY
define|#
directive|define
name|FMEMCOPY
parameter_list|(
name|dest
parameter_list|,
name|src
parameter_list|,
name|size
parameter_list|)
value|MEMCOPY(dest,src,size)
end_define
begin_define
DECL|macro|FMEMZERO
define|#
directive|define
name|FMEMZERO
parameter_list|(
name|target
parameter_list|,
name|size
parameter_list|)
value|MEMZERO(target,size)
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* 80x86 case, define if we can */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|USE_FMEM
end_ifdef
begin_define
DECL|macro|FMEMCOPY
define|#
directive|define
name|FMEMCOPY
parameter_list|(
name|dest
parameter_list|,
name|src
parameter_list|,
name|size
parameter_list|)
value|_fmemcpy((void FAR *)(dest), (const void FAR *)(src), (size_t)(size))
end_define
begin_define
DECL|macro|FMEMZERO
define|#
directive|define
name|FMEMZERO
parameter_list|(
name|target
parameter_list|,
name|size
parameter_list|)
value|_fmemset((void FAR *)(target), 0, (size_t)(size))
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_macro
name|GLOBAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|jcopy_sample_rows
name|jcopy_sample_rows
argument_list|(
argument|JSAMPARRAY input_array
argument_list|,
argument|int source_row
argument_list|,
argument|JSAMPARRAY output_array
argument_list|,
argument|int dest_row
argument_list|,
argument|int num_rows
argument_list|,
argument|JDIMENSION num_cols
argument_list|)
end_macro
begin_comment
comment|/* Copy some rows of samples from one place to another.  * num_rows rows are copied from input_array[source_row++]  * to output_array[dest_row++]; these areas may overlap for duplication.  * The source and destination arrays must be at least as wide as num_cols.  */
end_comment
begin_block
block|{
specifier|register
name|JSAMPROW
name|inptr
decl_stmt|,
name|outptr
decl_stmt|;
ifdef|#
directive|ifdef
name|FMEMCOPY
specifier|register
name|size_t
name|count
init|=
call|(
name|size_t
call|)
argument_list|(
name|num_cols
operator|*
name|SIZEOF
argument_list|(
name|JSAMPLE
argument_list|)
argument_list|)
decl_stmt|;
else|#
directive|else
specifier|register
name|JDIMENSION
name|count
decl_stmt|;
endif|#
directive|endif
specifier|register
name|int
name|row
decl_stmt|;
name|input_array
operator|+=
name|source_row
expr_stmt|;
name|output_array
operator|+=
name|dest_row
expr_stmt|;
for|for
control|(
name|row
operator|=
name|num_rows
init|;
name|row
operator|>
literal|0
condition|;
name|row
operator|--
control|)
block|{
name|inptr
operator|=
operator|*
name|input_array
operator|++
expr_stmt|;
name|outptr
operator|=
operator|*
name|output_array
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|FMEMCOPY
name|FMEMCOPY
argument_list|(
name|outptr
argument_list|,
name|inptr
argument_list|,
name|count
argument_list|)
expr_stmt|;
else|#
directive|else
for|for
control|(
name|count
operator|=
name|num_cols
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
control|)
operator|*
name|outptr
operator|++
operator|=
operator|*
name|inptr
operator|++
expr_stmt|;
comment|/* needn't bother with GETJSAMPLE() here */
endif|#
directive|endif
block|}
block|}
end_block
begin_macro
name|GLOBAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|jcopy_block_row
name|jcopy_block_row
argument_list|(
argument|JBLOCKROW input_row
argument_list|,
argument|JBLOCKROW output_row
argument_list|,
argument|JDIMENSION num_blocks
argument_list|)
end_macro
begin_comment
comment|/* Copy a row of coefficient blocks from one place to another. */
end_comment
begin_block
block|{
ifdef|#
directive|ifdef
name|FMEMCOPY
name|FMEMCOPY
argument_list|(
name|output_row
argument_list|,
name|input_row
argument_list|,
name|num_blocks
operator|*
operator|(
name|DCTSIZE2
operator|*
name|SIZEOF
argument_list|(
name|JCOEF
argument_list|)
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
specifier|register
name|JCOEFPTR
name|inptr
decl_stmt|,
name|outptr
decl_stmt|;
specifier|register
name|long
name|count
decl_stmt|;
name|inptr
operator|=
operator|(
name|JCOEFPTR
operator|)
name|input_row
expr_stmt|;
name|outptr
operator|=
operator|(
name|JCOEFPTR
operator|)
name|output_row
expr_stmt|;
for|for
control|(
name|count
operator|=
operator|(
name|long
operator|)
name|num_blocks
operator|*
name|DCTSIZE2
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
control|)
block|{
operator|*
name|outptr
operator|++
operator|=
operator|*
name|inptr
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_block
begin_macro
name|GLOBAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|jzero_far
name|jzero_far
argument_list|(
argument|void FAR * target
argument_list|,
argument|size_t bytestozero
argument_list|)
end_macro
begin_comment
comment|/* Zero out a chunk of FAR memory. */
end_comment
begin_comment
comment|/* This might be sample-array data, block-array data, or alloc_large data. */
end_comment
begin_block
block|{
ifdef|#
directive|ifdef
name|FMEMZERO
name|FMEMZERO
argument_list|(
name|target
argument_list|,
name|bytestozero
argument_list|)
expr_stmt|;
else|#
directive|else
specifier|register
name|char
name|FAR
modifier|*
name|ptr
init|=
operator|(
name|char
name|FAR
operator|*
operator|)
name|target
decl_stmt|;
specifier|register
name|size_t
name|count
decl_stmt|;
for|for
control|(
name|count
operator|=
name|bytestozero
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
control|)
block|{
operator|*
name|ptr
operator|++
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_block
end_unit
