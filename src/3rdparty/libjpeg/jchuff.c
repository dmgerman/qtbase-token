begin_unit
begin_comment
comment|/*  * jchuff.c  *  * Copyright (C) 1991-1997, Thomas G. Lane.  * Modified 2006-2009 by Guido Vollbeding.  * This file is part of the Independent JPEG Group's software.  * For conditions of distribution and use, see the accompanying README file.  *  * This file contains Huffman entropy encoding routines.  * Both sequential and progressive modes are supported in this single module.  *  * Much of the complexity here has to do with supporting output suspension.  * If the data destination module demands suspension, we want to be able to  * back up to the start of the current MCU.  To do this, we copy state  * variables into local working storage, and update them back to the  * permanent JPEG objects only upon successful completion of an MCU.  *  * We do not support output suspension for the progressive JPEG mode, since  * the library currently does not allow multiple-scan files to be written  * with output suspension.  */
end_comment
begin_define
DECL|macro|JPEG_INTERNALS
define|#
directive|define
name|JPEG_INTERNALS
end_define
begin_include
include|#
directive|include
file|"jinclude.h"
end_include
begin_include
include|#
directive|include
file|"jpeglib.h"
end_include
begin_comment
comment|/* The legal range of a DCT coefficient is  *  -1024 .. +1023  for 8-bit data;  * -16384 .. +16383 for 12-bit data.  * Hence the magnitude should always fit in 10 or 14 bits respectively.  */
end_comment
begin_if
if|#
directive|if
name|BITS_IN_JSAMPLE
operator|==
literal|8
end_if
begin_define
DECL|macro|MAX_COEF_BITS
define|#
directive|define
name|MAX_COEF_BITS
value|10
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|MAX_COEF_BITS
define|#
directive|define
name|MAX_COEF_BITS
value|14
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* Derived data constructed for each Huffman table */
end_comment
begin_typedef
typedef|typedef
struct|struct
block|{
DECL|member|ehufco
name|unsigned
name|int
name|ehufco
index|[
literal|256
index|]
decl_stmt|;
comment|/* code for each symbol */
DECL|member|ehufsi
name|char
name|ehufsi
index|[
literal|256
index|]
decl_stmt|;
comment|/* length of code for each symbol */
comment|/* If no code has been allocated for a symbol S, ehufsi[S] contains 0 */
block|}
DECL|typedef|c_derived_tbl
name|c_derived_tbl
typedef|;
end_typedef
begin_comment
comment|/* Expanded entropy encoder object for Huffman encoding.  *  * The savable_state subrecord contains fields that change within an MCU,  * but must not be updated permanently until we complete the MCU.  */
end_comment
begin_typedef
typedef|typedef
struct|struct
block|{
DECL|member|put_buffer
name|INT32
name|put_buffer
decl_stmt|;
comment|/* current bit-accumulation buffer */
DECL|member|put_bits
name|int
name|put_bits
decl_stmt|;
comment|/* # of bits now in it */
DECL|member|last_dc_val
name|int
name|last_dc_val
index|[
name|MAX_COMPS_IN_SCAN
index|]
decl_stmt|;
comment|/* last DC coef for each component */
block|}
DECL|typedef|savable_state
name|savable_state
typedef|;
end_typedef
begin_comment
comment|/* This macro is to work around compilers with missing or broken  * structure assignment.  You'll need to fix this code if you have  * such a compiler and you change MAX_COMPS_IN_SCAN.  */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|NO_STRUCT_ASSIGN
end_ifndef
begin_define
DECL|macro|ASSIGN_STATE
define|#
directive|define
name|ASSIGN_STATE
parameter_list|(
name|dest
parameter_list|,
name|src
parameter_list|)
value|((dest) = (src))
end_define
begin_else
else|#
directive|else
end_else
begin_if
if|#
directive|if
name|MAX_COMPS_IN_SCAN
operator|==
literal|4
end_if
begin_define
DECL|macro|ASSIGN_STATE
define|#
directive|define
name|ASSIGN_STATE
parameter_list|(
name|dest
parameter_list|,
name|src
parameter_list|)
define|\
value|((dest).put_buffer = (src).put_buffer, \ 	 (dest).put_bits = (src).put_bits, \ 	 (dest).last_dc_val[0] = (src).last_dc_val[0], \ 	 (dest).last_dc_val[1] = (src).last_dc_val[1], \ 	 (dest).last_dc_val[2] = (src).last_dc_val[2], \ 	 (dest).last_dc_val[3] = (src).last_dc_val[3])
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_typedef
typedef|typedef
struct|struct
block|{
DECL|member|pub
name|struct
name|jpeg_entropy_encoder
name|pub
decl_stmt|;
comment|/* public fields */
DECL|member|saved
name|savable_state
name|saved
decl_stmt|;
comment|/* Bit buffer& DC state at start of MCU */
comment|/* These fields are NOT loaded into local working state. */
DECL|member|restarts_to_go
name|unsigned
name|int
name|restarts_to_go
decl_stmt|;
comment|/* MCUs left in this restart interval */
DECL|member|next_restart_num
name|int
name|next_restart_num
decl_stmt|;
comment|/* next restart number to write (0-7) */
comment|/* Pointers to derived tables (these workspaces have image lifespan) */
DECL|member|dc_derived_tbls
name|c_derived_tbl
modifier|*
name|dc_derived_tbls
index|[
name|NUM_HUFF_TBLS
index|]
decl_stmt|;
DECL|member|ac_derived_tbls
name|c_derived_tbl
modifier|*
name|ac_derived_tbls
index|[
name|NUM_HUFF_TBLS
index|]
decl_stmt|;
comment|/* Statistics tables for optimization */
DECL|member|dc_count_ptrs
name|long
modifier|*
name|dc_count_ptrs
index|[
name|NUM_HUFF_TBLS
index|]
decl_stmt|;
DECL|member|ac_count_ptrs
name|long
modifier|*
name|ac_count_ptrs
index|[
name|NUM_HUFF_TBLS
index|]
decl_stmt|;
comment|/* Following fields used only in progressive mode */
comment|/* Mode flag: TRUE for optimization, FALSE for actual data output */
DECL|member|gather_statistics
name|boolean
name|gather_statistics
decl_stmt|;
comment|/* next_output_byte/free_in_buffer are local copies of cinfo->dest fields.    */
DECL|member|next_output_byte
name|JOCTET
modifier|*
name|next_output_byte
decl_stmt|;
comment|/* => next byte to write in buffer */
DECL|member|free_in_buffer
name|size_t
name|free_in_buffer
decl_stmt|;
comment|/* # of byte spaces remaining in buffer */
DECL|member|cinfo
name|j_compress_ptr
name|cinfo
decl_stmt|;
comment|/* link to cinfo (needed for dump_buffer) */
comment|/* Coding status for AC components */
DECL|member|ac_tbl_no
name|int
name|ac_tbl_no
decl_stmt|;
comment|/* the table number of the single component */
DECL|member|EOBRUN
name|unsigned
name|int
name|EOBRUN
decl_stmt|;
comment|/* run length of EOBs */
DECL|member|BE
name|unsigned
name|int
name|BE
decl_stmt|;
comment|/* # of buffered correction bits before MCU */
DECL|member|bit_buffer
name|char
modifier|*
name|bit_buffer
decl_stmt|;
comment|/* buffer for correction bits (1 per char) */
comment|/* packing correction bits tightly would save some space but cost time... */
block|}
DECL|typedef|huff_entropy_encoder
name|huff_entropy_encoder
typedef|;
end_typedef
begin_typedef
DECL|typedef|huff_entropy_ptr
typedef|typedef
name|huff_entropy_encoder
modifier|*
name|huff_entropy_ptr
typedef|;
end_typedef
begin_comment
comment|/* Working state while writing an MCU (sequential mode).  * This struct contains all the fields that are needed by subroutines.  */
end_comment
begin_typedef
typedef|typedef
struct|struct
block|{
DECL|member|next_output_byte
name|JOCTET
modifier|*
name|next_output_byte
decl_stmt|;
comment|/* => next byte to write in buffer */
DECL|member|free_in_buffer
name|size_t
name|free_in_buffer
decl_stmt|;
comment|/* # of byte spaces remaining in buffer */
DECL|member|cur
name|savable_state
name|cur
decl_stmt|;
comment|/* Current bit buffer& DC state */
DECL|member|cinfo
name|j_compress_ptr
name|cinfo
decl_stmt|;
comment|/* dump_buffer needs access to this */
block|}
DECL|typedef|working_state
name|working_state
typedef|;
end_typedef
begin_comment
comment|/* MAX_CORR_BITS is the number of bits the AC refinement correction-bit  * buffer can hold.  Larger sizes may slightly improve compression, but  * 1000 is already well into the realm of overkill.  * The minimum safe size is 64 bits.  */
end_comment
begin_define
DECL|macro|MAX_CORR_BITS
define|#
directive|define
name|MAX_CORR_BITS
value|1000
end_define
begin_comment
DECL|macro|MAX_CORR_BITS
comment|/* Max # of correction bits I can buffer */
end_comment
begin_comment
comment|/* IRIGHT_SHIFT is like RIGHT_SHIFT, but works on int rather than INT32.  * We assume that int right shift is unsigned if INT32 right shift is,  * which should be safe.  */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|RIGHT_SHIFT_IS_UNSIGNED
end_ifdef
begin_define
DECL|macro|ISHIFT_TEMPS
define|#
directive|define
name|ISHIFT_TEMPS
value|int ishift_temp;
end_define
begin_define
DECL|macro|IRIGHT_SHIFT
define|#
directive|define
name|IRIGHT_SHIFT
parameter_list|(
name|x
parameter_list|,
name|shft
parameter_list|)
define|\
value|((ishift_temp = (x))< 0 ? \ 	 (ishift_temp>> (shft)) | ((~0)<< (16-(shft))) : \ 	 (ishift_temp>> (shft)))
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|ISHIFT_TEMPS
define|#
directive|define
name|ISHIFT_TEMPS
end_define
begin_define
DECL|macro|IRIGHT_SHIFT
define|#
directive|define
name|IRIGHT_SHIFT
parameter_list|(
name|x
parameter_list|,
name|shft
parameter_list|)
value|((x)>> (shft))
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*  * Compute the derived values for a Huffman table.  * This routine also performs some validation checks on the table.  */
end_comment
begin_macro
name|LOCAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|jpeg_make_c_derived_tbl
name|jpeg_make_c_derived_tbl
argument_list|(
argument|j_compress_ptr cinfo
argument_list|,
argument|boolean isDC
argument_list|,
argument|int tblno
argument_list|,
argument|c_derived_tbl ** pdtbl
argument_list|)
end_macro
begin_block
block|{
name|JHUFF_TBL
modifier|*
name|htbl
decl_stmt|;
name|c_derived_tbl
modifier|*
name|dtbl
decl_stmt|;
name|int
name|p
decl_stmt|,
name|i
decl_stmt|,
name|l
decl_stmt|,
name|lastp
decl_stmt|,
name|si
decl_stmt|,
name|maxsymbol
decl_stmt|;
name|char
name|huffsize
index|[
literal|257
index|]
decl_stmt|;
name|unsigned
name|int
name|huffcode
index|[
literal|257
index|]
decl_stmt|;
name|unsigned
name|int
name|code
decl_stmt|;
comment|/* Note that huffsize[] and huffcode[] are filled in code-length order,    * paralleling the order of the symbols themselves in htbl->huffval[].    */
comment|/* Find the input Huffman table */
if|if
condition|(
name|tblno
operator|<
literal|0
operator|||
name|tblno
operator|>=
name|NUM_HUFF_TBLS
condition|)
name|ERREXIT1
argument_list|(
name|cinfo
argument_list|,
name|JERR_NO_HUFF_TABLE
argument_list|,
name|tblno
argument_list|)
expr_stmt|;
name|htbl
operator|=
name|isDC
condition|?
name|cinfo
operator|->
name|dc_huff_tbl_ptrs
index|[
name|tblno
index|]
else|:
name|cinfo
operator|->
name|ac_huff_tbl_ptrs
index|[
name|tblno
index|]
expr_stmt|;
if|if
condition|(
name|htbl
operator|==
name|NULL
condition|)
name|ERREXIT1
argument_list|(
name|cinfo
argument_list|,
name|JERR_NO_HUFF_TABLE
argument_list|,
name|tblno
argument_list|)
expr_stmt|;
comment|/* Allocate a workspace if we haven't already done so. */
if|if
condition|(
operator|*
name|pdtbl
operator|==
name|NULL
condition|)
operator|*
name|pdtbl
operator|=
operator|(
name|c_derived_tbl
operator|*
operator|)
call|(
modifier|*
name|cinfo
operator|->
name|mem
operator|->
name|alloc_small
call|)
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|,
name|JPOOL_IMAGE
argument_list|,
name|SIZEOF
argument_list|(
name|c_derived_tbl
argument_list|)
argument_list|)
expr_stmt|;
name|dtbl
operator|=
operator|*
name|pdtbl
expr_stmt|;
comment|/* Figure C.1: make table of Huffman code length for each symbol */
name|p
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|l
operator|=
literal|1
init|;
name|l
operator|<=
literal|16
condition|;
name|l
operator|++
control|)
block|{
name|i
operator|=
operator|(
name|int
operator|)
name|htbl
operator|->
name|bits
index|[
name|l
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|p
operator|+
name|i
operator|>
literal|256
condition|)
comment|/* protect against table overrun */
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_HUFF_TABLE
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|--
condition|)
name|huffsize
index|[
name|p
operator|++
index|]
operator|=
operator|(
name|char
operator|)
name|l
expr_stmt|;
block|}
name|huffsize
index|[
name|p
index|]
operator|=
literal|0
expr_stmt|;
name|lastp
operator|=
name|p
expr_stmt|;
comment|/* Figure C.2: generate the codes themselves */
comment|/* We also validate that the counts represent a legal Huffman code tree. */
name|code
operator|=
literal|0
expr_stmt|;
name|si
operator|=
name|huffsize
index|[
literal|0
index|]
expr_stmt|;
name|p
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|huffsize
index|[
name|p
index|]
condition|)
block|{
while|while
condition|(
operator|(
operator|(
name|int
operator|)
name|huffsize
index|[
name|p
index|]
operator|)
operator|==
name|si
condition|)
block|{
name|huffcode
index|[
name|p
operator|++
index|]
operator|=
name|code
expr_stmt|;
name|code
operator|++
expr_stmt|;
block|}
comment|/* code is now 1 more than the last code used for codelength si; but      * it must still fit in si bits, since no code is allowed to be all ones.      */
if|if
condition|(
operator|(
operator|(
name|INT32
operator|)
name|code
operator|)
operator|>=
operator|(
operator|(
operator|(
name|INT32
operator|)
literal|1
operator|)
operator|<<
name|si
operator|)
condition|)
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_HUFF_TABLE
argument_list|)
expr_stmt|;
name|code
operator|<<=
literal|1
expr_stmt|;
name|si
operator|++
expr_stmt|;
block|}
comment|/* Figure C.3: generate encoding tables */
comment|/* These are code and size indexed by symbol value */
comment|/* Set all codeless symbols to have code length 0;    * this lets us detect duplicate VAL entries here, and later    * allows emit_bits to detect any attempt to emit such symbols.    */
name|MEMZERO
argument_list|(
name|dtbl
operator|->
name|ehufsi
argument_list|,
name|SIZEOF
argument_list|(
name|dtbl
operator|->
name|ehufsi
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This is also a convenient place to check for out-of-range    * and duplicated VAL entries.  We allow 0..255 for AC symbols    * but only 0..15 for DC.  (We could constrain them further    * based on data depth and mode, but this seems enough.)    */
name|maxsymbol
operator|=
name|isDC
condition|?
literal|15
else|:
literal|255
expr_stmt|;
for|for
control|(
name|p
operator|=
literal|0
init|;
name|p
operator|<
name|lastp
condition|;
name|p
operator|++
control|)
block|{
name|i
operator|=
name|htbl
operator|->
name|huffval
index|[
name|p
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|i
operator|>
name|maxsymbol
operator|||
name|dtbl
operator|->
name|ehufsi
index|[
name|i
index|]
condition|)
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_HUFF_TABLE
argument_list|)
expr_stmt|;
name|dtbl
operator|->
name|ehufco
index|[
name|i
index|]
operator|=
name|huffcode
index|[
name|p
index|]
expr_stmt|;
name|dtbl
operator|->
name|ehufsi
index|[
name|i
index|]
operator|=
name|huffsize
index|[
name|p
index|]
expr_stmt|;
block|}
block|}
end_block
begin_comment
comment|/* Outputting bytes to the file.  * NB: these must be called only when actually outputting,  * that is, entropy->gather_statistics == FALSE.  */
end_comment
begin_comment
comment|/* Emit a byte, taking 'action' if must suspend. */
end_comment
begin_define
DECL|macro|emit_byte_s
define|#
directive|define
name|emit_byte_s
parameter_list|(
name|state
parameter_list|,
name|val
parameter_list|,
name|action
parameter_list|)
define|\
value|{ *(state)->next_output_byte++ = (JOCTET) (val);  \ 	  if (--(state)->free_in_buffer == 0)  \ 	    if (! dump_buffer_s(state))  \ 	      { action; } }
end_define
begin_comment
comment|/* Emit a byte */
end_comment
begin_define
DECL|macro|emit_byte_e
define|#
directive|define
name|emit_byte_e
parameter_list|(
name|entropy
parameter_list|,
name|val
parameter_list|)
define|\
value|{ *(entropy)->next_output_byte++ = (JOCTET) (val);  \ 	  if (--(entropy)->free_in_buffer == 0)  \ 	    dump_buffer_e(entropy); }
end_define
begin_macro
DECL|function|LOCAL
name|LOCAL
argument_list|(
argument|boolean
argument_list|)
end_macro
begin_macro
name|dump_buffer_s
argument_list|(
argument|working_state * state
argument_list|)
end_macro
begin_comment
comment|/* Empty the output buffer; return TRUE if successful, FALSE if must suspend */
end_comment
begin_block
block|{
name|struct
name|jpeg_destination_mgr
modifier|*
name|dest
init|=
name|state
operator|->
name|cinfo
operator|->
name|dest
decl_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|dest
operator|->
name|empty_output_buffer
call|)
argument_list|(
name|state
operator|->
name|cinfo
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* After a successful buffer dump, must reset buffer pointers */
name|state
operator|->
name|next_output_byte
operator|=
name|dest
operator|->
name|next_output_byte
expr_stmt|;
name|state
operator|->
name|free_in_buffer
operator|=
name|dest
operator|->
name|free_in_buffer
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_block
begin_macro
name|LOCAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|dump_buffer_e
name|dump_buffer_e
argument_list|(
argument|huff_entropy_ptr entropy
argument_list|)
end_macro
begin_comment
comment|/* Empty the output buffer; we do not support suspension in this case. */
end_comment
begin_block
block|{
name|struct
name|jpeg_destination_mgr
modifier|*
name|dest
init|=
name|entropy
operator|->
name|cinfo
operator|->
name|dest
decl_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|dest
operator|->
name|empty_output_buffer
call|)
argument_list|(
name|entropy
operator|->
name|cinfo
argument_list|)
condition|)
name|ERREXIT
argument_list|(
name|entropy
operator|->
name|cinfo
argument_list|,
name|JERR_CANT_SUSPEND
argument_list|)
expr_stmt|;
comment|/* After a successful buffer dump, must reset buffer pointers */
name|entropy
operator|->
name|next_output_byte
operator|=
name|dest
operator|->
name|next_output_byte
expr_stmt|;
name|entropy
operator|->
name|free_in_buffer
operator|=
name|dest
operator|->
name|free_in_buffer
expr_stmt|;
block|}
end_block
begin_comment
comment|/* Outputting bits to the file */
end_comment
begin_comment
comment|/* Only the right 24 bits of put_buffer are used; the valid bits are  * left-justified in this part.  At most 16 bits can be passed to emit_bits  * in one call, and we never retain more than 7 bits in put_buffer  * between calls, so 24 bits are sufficient.  */
end_comment
begin_function
name|INLINE
DECL|function|LOCAL
name|LOCAL
parameter_list|(
name|boolean
parameter_list|)
function|emit_bits_s
parameter_list|(
name|working_state
modifier|*
name|state
parameter_list|,
name|unsigned
name|int
name|code
parameter_list|,
name|int
name|size
parameter_list|)
comment|/* Emit some bits; return TRUE if successful, FALSE if must suspend */
block|{
comment|/* This routine is heavily used, so it's worth coding tightly. */
specifier|register
name|INT32
name|put_buffer
init|=
operator|(
name|INT32
operator|)
name|code
decl_stmt|;
specifier|register
name|int
name|put_bits
init|=
name|state
operator|->
name|cur
operator|.
name|put_bits
decl_stmt|;
comment|/* if size is 0, caller used an invalid Huffman table entry */
if|if
condition|(
name|size
operator|==
literal|0
condition|)
name|ERREXIT
argument_list|(
name|state
operator|->
name|cinfo
argument_list|,
name|JERR_HUFF_MISSING_CODE
argument_list|)
expr_stmt|;
name|put_buffer
operator|&=
operator|(
operator|(
operator|(
name|INT32
operator|)
literal|1
operator|)
operator|<<
name|size
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* mask off any extra bits in code */
name|put_bits
operator|+=
name|size
expr_stmt|;
comment|/* new number of bits in buffer */
name|put_buffer
operator|<<=
literal|24
operator|-
name|put_bits
expr_stmt|;
comment|/* align incoming bits */
name|put_buffer
operator||=
name|state
operator|->
name|cur
operator|.
name|put_buffer
expr_stmt|;
comment|/* and merge with old buffer contents */
while|while
condition|(
name|put_bits
operator|>=
literal|8
condition|)
block|{
name|int
name|c
init|=
call|(
name|int
call|)
argument_list|(
operator|(
name|put_buffer
operator|>>
literal|16
operator|)
operator|&
literal|0xFF
argument_list|)
decl_stmt|;
name|emit_byte_s
argument_list|(
argument|state
argument_list|,
argument|c
argument_list|,
argument|return FALSE
argument_list|)
empty_stmt|;
if|if
condition|(
name|c
operator|==
literal|0xFF
condition|)
block|{
comment|/* need to stuff a zero byte? */
name|emit_byte_s
argument_list|(
argument|state
argument_list|,
literal|0
argument_list|,
argument|return FALSE
argument_list|)
empty_stmt|;
block|}
name|put_buffer
operator|<<=
literal|8
expr_stmt|;
name|put_bits
operator|-=
literal|8
expr_stmt|;
block|}
name|state
operator|->
name|cur
operator|.
name|put_buffer
operator|=
name|put_buffer
expr_stmt|;
comment|/* update state variables */
name|state
operator|->
name|cur
operator|.
name|put_bits
operator|=
name|put_bits
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function
begin_function
name|INLINE
name|LOCAL
parameter_list|(
name|void
parameter_list|)
function|emit_bits_e
DECL|function|emit_bits_e
parameter_list|(
name|huff_entropy_ptr
name|entropy
parameter_list|,
name|unsigned
name|int
name|code
parameter_list|,
name|int
name|size
parameter_list|)
comment|/* Emit some bits, unless we are in gather mode */
block|{
comment|/* This routine is heavily used, so it's worth coding tightly. */
specifier|register
name|INT32
name|put_buffer
init|=
operator|(
name|INT32
operator|)
name|code
decl_stmt|;
specifier|register
name|int
name|put_bits
init|=
name|entropy
operator|->
name|saved
operator|.
name|put_bits
decl_stmt|;
comment|/* if size is 0, caller used an invalid Huffman table entry */
if|if
condition|(
name|size
operator|==
literal|0
condition|)
name|ERREXIT
argument_list|(
name|entropy
operator|->
name|cinfo
argument_list|,
name|JERR_HUFF_MISSING_CODE
argument_list|)
expr_stmt|;
if|if
condition|(
name|entropy
operator|->
name|gather_statistics
condition|)
return|return;
comment|/* do nothing if we're only getting stats */
name|put_buffer
operator|&=
operator|(
operator|(
operator|(
name|INT32
operator|)
literal|1
operator|)
operator|<<
name|size
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* mask off any extra bits in code */
name|put_bits
operator|+=
name|size
expr_stmt|;
comment|/* new number of bits in buffer */
name|put_buffer
operator|<<=
literal|24
operator|-
name|put_bits
expr_stmt|;
comment|/* align incoming bits */
comment|/* and merge with old buffer contents */
name|put_buffer
operator||=
name|entropy
operator|->
name|saved
operator|.
name|put_buffer
expr_stmt|;
while|while
condition|(
name|put_bits
operator|>=
literal|8
condition|)
block|{
name|int
name|c
init|=
call|(
name|int
call|)
argument_list|(
operator|(
name|put_buffer
operator|>>
literal|16
operator|)
operator|&
literal|0xFF
argument_list|)
decl_stmt|;
name|emit_byte_e
argument_list|(
name|entropy
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0xFF
condition|)
block|{
comment|/* need to stuff a zero byte? */
name|emit_byte_e
argument_list|(
name|entropy
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|put_buffer
operator|<<=
literal|8
expr_stmt|;
name|put_bits
operator|-=
literal|8
expr_stmt|;
block|}
name|entropy
operator|->
name|saved
operator|.
name|put_buffer
operator|=
name|put_buffer
expr_stmt|;
comment|/* update variables */
name|entropy
operator|->
name|saved
operator|.
name|put_bits
operator|=
name|put_bits
expr_stmt|;
block|}
end_function
begin_macro
DECL|function|LOCAL
name|LOCAL
argument_list|(
argument|boolean
argument_list|)
end_macro
begin_macro
name|flush_bits_s
argument_list|(
argument|working_state * state
argument_list|)
end_macro
begin_block
block|{
if|if
condition|(
operator|!
name|emit_bits_s
argument_list|(
name|state
argument_list|,
literal|0x7F
argument_list|,
literal|7
argument_list|)
condition|)
comment|/* fill any partial byte with ones */
return|return
name|FALSE
return|;
name|state
operator|->
name|cur
operator|.
name|put_buffer
operator|=
literal|0
expr_stmt|;
comment|/* and reset bit-buffer to empty */
name|state
operator|->
name|cur
operator|.
name|put_bits
operator|=
literal|0
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_block
begin_macro
name|LOCAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|flush_bits_e
name|flush_bits_e
argument_list|(
argument|huff_entropy_ptr entropy
argument_list|)
end_macro
begin_block
block|{
name|emit_bits_e
argument_list|(
name|entropy
argument_list|,
literal|0x7F
argument_list|,
literal|7
argument_list|)
expr_stmt|;
comment|/* fill any partial byte with ones */
name|entropy
operator|->
name|saved
operator|.
name|put_buffer
operator|=
literal|0
expr_stmt|;
comment|/* and reset bit-buffer to empty */
name|entropy
operator|->
name|saved
operator|.
name|put_bits
operator|=
literal|0
expr_stmt|;
block|}
end_block
begin_comment
comment|/*  * Emit (or just count) a Huffman symbol.  */
end_comment
begin_function
name|INLINE
name|LOCAL
parameter_list|(
name|void
parameter_list|)
function|emit_dc_symbol
DECL|function|emit_dc_symbol
parameter_list|(
name|huff_entropy_ptr
name|entropy
parameter_list|,
name|int
name|tbl_no
parameter_list|,
name|int
name|symbol
parameter_list|)
block|{
if|if
condition|(
name|entropy
operator|->
name|gather_statistics
condition|)
name|entropy
operator|->
name|dc_count_ptrs
index|[
name|tbl_no
index|]
index|[
name|symbol
index|]
operator|++
expr_stmt|;
else|else
block|{
name|c_derived_tbl
modifier|*
name|tbl
init|=
name|entropy
operator|->
name|dc_derived_tbls
index|[
name|tbl_no
index|]
decl_stmt|;
name|emit_bits_e
argument_list|(
name|entropy
argument_list|,
name|tbl
operator|->
name|ehufco
index|[
name|symbol
index|]
argument_list|,
name|tbl
operator|->
name|ehufsi
index|[
name|symbol
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
name|INLINE
name|LOCAL
parameter_list|(
name|void
parameter_list|)
function|emit_ac_symbol
DECL|function|emit_ac_symbol
parameter_list|(
name|huff_entropy_ptr
name|entropy
parameter_list|,
name|int
name|tbl_no
parameter_list|,
name|int
name|symbol
parameter_list|)
block|{
if|if
condition|(
name|entropy
operator|->
name|gather_statistics
condition|)
name|entropy
operator|->
name|ac_count_ptrs
index|[
name|tbl_no
index|]
index|[
name|symbol
index|]
operator|++
expr_stmt|;
else|else
block|{
name|c_derived_tbl
modifier|*
name|tbl
init|=
name|entropy
operator|->
name|ac_derived_tbls
index|[
name|tbl_no
index|]
decl_stmt|;
name|emit_bits_e
argument_list|(
name|entropy
argument_list|,
name|tbl
operator|->
name|ehufco
index|[
name|symbol
index|]
argument_list|,
name|tbl
operator|->
name|ehufsi
index|[
name|symbol
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*  * Emit bits from a correction bit buffer.  */
end_comment
begin_macro
name|LOCAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|emit_buffered_bits
name|emit_buffered_bits
argument_list|(
argument|huff_entropy_ptr entropy
argument_list|,
argument|char * bufstart
argument_list|,
argument|unsigned int nbits
argument_list|)
end_macro
begin_block
block|{
if|if
condition|(
name|entropy
operator|->
name|gather_statistics
condition|)
return|return;
comment|/* no real work */
while|while
condition|(
name|nbits
operator|>
literal|0
condition|)
block|{
name|emit_bits_e
argument_list|(
name|entropy
argument_list|,
call|(
name|unsigned
name|int
call|)
argument_list|(
operator|*
name|bufstart
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|bufstart
operator|++
expr_stmt|;
name|nbits
operator|--
expr_stmt|;
block|}
block|}
end_block
begin_comment
comment|/*  * Emit any pending EOBRUN symbol.  */
end_comment
begin_macro
name|LOCAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|emit_eobrun
name|emit_eobrun
argument_list|(
argument|huff_entropy_ptr entropy
argument_list|)
end_macro
begin_block
block|{
specifier|register
name|int
name|temp
decl_stmt|,
name|nbits
decl_stmt|;
if|if
condition|(
name|entropy
operator|->
name|EOBRUN
operator|>
literal|0
condition|)
block|{
comment|/* if there is any pending EOBRUN */
name|temp
operator|=
name|entropy
operator|->
name|EOBRUN
expr_stmt|;
name|nbits
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|temp
operator|>>=
literal|1
operator|)
condition|)
name|nbits
operator|++
expr_stmt|;
comment|/* safety check: shouldn't happen given limited correction-bit buffer */
if|if
condition|(
name|nbits
operator|>
literal|14
condition|)
name|ERREXIT
argument_list|(
name|entropy
operator|->
name|cinfo
argument_list|,
name|JERR_HUFF_MISSING_CODE
argument_list|)
expr_stmt|;
name|emit_ac_symbol
argument_list|(
name|entropy
argument_list|,
name|entropy
operator|->
name|ac_tbl_no
argument_list|,
name|nbits
operator|<<
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbits
condition|)
name|emit_bits_e
argument_list|(
name|entropy
argument_list|,
name|entropy
operator|->
name|EOBRUN
argument_list|,
name|nbits
argument_list|)
expr_stmt|;
name|entropy
operator|->
name|EOBRUN
operator|=
literal|0
expr_stmt|;
comment|/* Emit any buffered correction bits */
name|emit_buffered_bits
argument_list|(
name|entropy
argument_list|,
name|entropy
operator|->
name|bit_buffer
argument_list|,
name|entropy
operator|->
name|BE
argument_list|)
expr_stmt|;
name|entropy
operator|->
name|BE
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block
begin_comment
comment|/*  * Emit a restart marker& resynchronize predictions.  */
end_comment
begin_macro
DECL|function|LOCAL
name|LOCAL
argument_list|(
argument|boolean
argument_list|)
end_macro
begin_macro
name|emit_restart_s
argument_list|(
argument|working_state * state
argument_list|,
argument|int restart_num
argument_list|)
end_macro
begin_block
block|{
name|int
name|ci
decl_stmt|;
if|if
condition|(
operator|!
name|flush_bits_s
argument_list|(
name|state
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|emit_byte_s
argument_list|(
argument|state
argument_list|,
literal|0xFF
argument_list|,
argument|return FALSE
argument_list|)
empty_stmt|;
name|emit_byte_s
argument_list|(
argument|state
argument_list|,
argument|JPEG_RST0 + restart_num
argument_list|,
argument|return FALSE
argument_list|)
empty_stmt|;
comment|/* Re-initialize DC predictions to 0 */
for|for
control|(
name|ci
operator|=
literal|0
init|;
name|ci
operator|<
name|state
operator|->
name|cinfo
operator|->
name|comps_in_scan
condition|;
name|ci
operator|++
control|)
name|state
operator|->
name|cur
operator|.
name|last_dc_val
index|[
name|ci
index|]
operator|=
literal|0
expr_stmt|;
comment|/* The restart counter is not updated until we successfully write the MCU. */
return|return
name|TRUE
return|;
block|}
end_block
begin_macro
name|LOCAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|emit_restart_e
name|emit_restart_e
argument_list|(
argument|huff_entropy_ptr entropy
argument_list|,
argument|int restart_num
argument_list|)
end_macro
begin_block
block|{
name|int
name|ci
decl_stmt|;
name|emit_eobrun
argument_list|(
name|entropy
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|entropy
operator|->
name|gather_statistics
condition|)
block|{
name|flush_bits_e
argument_list|(
name|entropy
argument_list|)
expr_stmt|;
name|emit_byte_e
argument_list|(
name|entropy
argument_list|,
literal|0xFF
argument_list|)
expr_stmt|;
name|emit_byte_e
argument_list|(
name|entropy
argument_list|,
name|JPEG_RST0
operator|+
name|restart_num
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|entropy
operator|->
name|cinfo
operator|->
name|Ss
operator|==
literal|0
condition|)
block|{
comment|/* Re-initialize DC predictions to 0 */
for|for
control|(
name|ci
operator|=
literal|0
init|;
name|ci
operator|<
name|entropy
operator|->
name|cinfo
operator|->
name|comps_in_scan
condition|;
name|ci
operator|++
control|)
name|entropy
operator|->
name|saved
operator|.
name|last_dc_val
index|[
name|ci
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Re-initialize all AC-related fields to 0 */
name|entropy
operator|->
name|EOBRUN
operator|=
literal|0
expr_stmt|;
name|entropy
operator|->
name|BE
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block
begin_comment
comment|/*  * MCU encoding for DC initial scan (either spectral selection,  * or first pass of successive approximation).  */
end_comment
begin_macro
DECL|function|METHODDEF
name|METHODDEF
argument_list|(
argument|boolean
argument_list|)
end_macro
begin_macro
name|encode_mcu_DC_first
argument_list|(
argument|j_compress_ptr cinfo
argument_list|,
argument|JBLOCKROW *MCU_data
argument_list|)
end_macro
begin_block
block|{
name|huff_entropy_ptr
name|entropy
init|=
operator|(
name|huff_entropy_ptr
operator|)
name|cinfo
operator|->
name|entropy
decl_stmt|;
specifier|register
name|int
name|temp
decl_stmt|,
name|temp2
decl_stmt|;
specifier|register
name|int
name|nbits
decl_stmt|;
name|int
name|blkn
decl_stmt|,
name|ci
decl_stmt|;
name|int
name|Al
init|=
name|cinfo
operator|->
name|Al
decl_stmt|;
name|JBLOCKROW
name|block
decl_stmt|;
name|jpeg_component_info
modifier|*
name|compptr
decl_stmt|;
name|ISHIFT_TEMPS
name|entropy
operator|->
name|next_output_byte
init|=
name|cinfo
operator|->
name|dest
operator|->
name|next_output_byte
decl_stmt|;
name|entropy
operator|->
name|free_in_buffer
operator|=
name|cinfo
operator|->
name|dest
operator|->
name|free_in_buffer
expr_stmt|;
comment|/* Emit restart marker if needed */
if|if
condition|(
name|cinfo
operator|->
name|restart_interval
condition|)
if|if
condition|(
name|entropy
operator|->
name|restarts_to_go
operator|==
literal|0
condition|)
name|emit_restart_e
argument_list|(
name|entropy
argument_list|,
name|entropy
operator|->
name|next_restart_num
argument_list|)
expr_stmt|;
comment|/* Encode the MCU data blocks */
for|for
control|(
name|blkn
operator|=
literal|0
init|;
name|blkn
operator|<
name|cinfo
operator|->
name|blocks_in_MCU
condition|;
name|blkn
operator|++
control|)
block|{
name|block
operator|=
name|MCU_data
index|[
name|blkn
index|]
expr_stmt|;
name|ci
operator|=
name|cinfo
operator|->
name|MCU_membership
index|[
name|blkn
index|]
expr_stmt|;
name|compptr
operator|=
name|cinfo
operator|->
name|cur_comp_info
index|[
name|ci
index|]
expr_stmt|;
comment|/* Compute the DC value after the required point transform by Al.      * This is simply an arithmetic right shift.      */
name|temp2
operator|=
name|IRIGHT_SHIFT
argument_list|(
call|(
name|int
call|)
argument_list|(
operator|(
operator|*
name|block
operator|)
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|Al
argument_list|)
expr_stmt|;
comment|/* DC differences are figured on the point-transformed values. */
name|temp
operator|=
name|temp2
operator|-
name|entropy
operator|->
name|saved
operator|.
name|last_dc_val
index|[
name|ci
index|]
expr_stmt|;
name|entropy
operator|->
name|saved
operator|.
name|last_dc_val
index|[
name|ci
index|]
operator|=
name|temp2
expr_stmt|;
comment|/* Encode the DC coefficient difference per section G.1.2.1 */
name|temp2
operator|=
name|temp
expr_stmt|;
if|if
condition|(
name|temp
operator|<
literal|0
condition|)
block|{
name|temp
operator|=
operator|-
name|temp
expr_stmt|;
comment|/* temp is abs value of input */
comment|/* For a negative input, want temp2 = bitwise complement of abs(input) */
comment|/* This code assumes we are on a two's complement machine */
name|temp2
operator|--
expr_stmt|;
block|}
comment|/* Find the number of bits needed for the magnitude of the coefficient */
name|nbits
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|temp
condition|)
block|{
name|nbits
operator|++
expr_stmt|;
name|temp
operator|>>=
literal|1
expr_stmt|;
block|}
comment|/* Check for out-of-range coefficient values.      * Since we're encoding a difference, the range limit is twice as much.      */
if|if
condition|(
name|nbits
operator|>
name|MAX_COEF_BITS
operator|+
literal|1
condition|)
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_DCT_COEF
argument_list|)
expr_stmt|;
comment|/* Count/emit the Huffman-coded symbol for the number of bits */
name|emit_dc_symbol
argument_list|(
name|entropy
argument_list|,
name|compptr
operator|->
name|dc_tbl_no
argument_list|,
name|nbits
argument_list|)
expr_stmt|;
comment|/* Emit that number of bits of the value, if positive, */
comment|/* or the complement of its magnitude, if negative. */
if|if
condition|(
name|nbits
condition|)
comment|/* emit_bits rejects calls with size 0 */
name|emit_bits_e
argument_list|(
name|entropy
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|temp2
argument_list|,
name|nbits
argument_list|)
expr_stmt|;
block|}
name|cinfo
operator|->
name|dest
operator|->
name|next_output_byte
operator|=
name|entropy
operator|->
name|next_output_byte
expr_stmt|;
name|cinfo
operator|->
name|dest
operator|->
name|free_in_buffer
operator|=
name|entropy
operator|->
name|free_in_buffer
expr_stmt|;
comment|/* Update restart-interval state too */
if|if
condition|(
name|cinfo
operator|->
name|restart_interval
condition|)
block|{
if|if
condition|(
name|entropy
operator|->
name|restarts_to_go
operator|==
literal|0
condition|)
block|{
name|entropy
operator|->
name|restarts_to_go
operator|=
name|cinfo
operator|->
name|restart_interval
expr_stmt|;
name|entropy
operator|->
name|next_restart_num
operator|++
expr_stmt|;
name|entropy
operator|->
name|next_restart_num
operator|&=
literal|7
expr_stmt|;
block|}
name|entropy
operator|->
name|restarts_to_go
operator|--
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_block
begin_comment
comment|/*  * MCU encoding for AC initial scan (either spectral selection,  * or first pass of successive approximation).  */
end_comment
begin_macro
DECL|function|METHODDEF
name|METHODDEF
argument_list|(
argument|boolean
argument_list|)
end_macro
begin_macro
name|encode_mcu_AC_first
argument_list|(
argument|j_compress_ptr cinfo
argument_list|,
argument|JBLOCKROW *MCU_data
argument_list|)
end_macro
begin_block
block|{
name|huff_entropy_ptr
name|entropy
init|=
operator|(
name|huff_entropy_ptr
operator|)
name|cinfo
operator|->
name|entropy
decl_stmt|;
specifier|register
name|int
name|temp
decl_stmt|,
name|temp2
decl_stmt|;
specifier|register
name|int
name|nbits
decl_stmt|;
specifier|register
name|int
name|r
decl_stmt|,
name|k
decl_stmt|;
name|int
name|Se
decl_stmt|,
name|Al
decl_stmt|;
specifier|const
name|int
modifier|*
name|natural_order
decl_stmt|;
name|JBLOCKROW
name|block
decl_stmt|;
name|entropy
operator|->
name|next_output_byte
operator|=
name|cinfo
operator|->
name|dest
operator|->
name|next_output_byte
expr_stmt|;
name|entropy
operator|->
name|free_in_buffer
operator|=
name|cinfo
operator|->
name|dest
operator|->
name|free_in_buffer
expr_stmt|;
comment|/* Emit restart marker if needed */
if|if
condition|(
name|cinfo
operator|->
name|restart_interval
condition|)
if|if
condition|(
name|entropy
operator|->
name|restarts_to_go
operator|==
literal|0
condition|)
name|emit_restart_e
argument_list|(
name|entropy
argument_list|,
name|entropy
operator|->
name|next_restart_num
argument_list|)
expr_stmt|;
name|Se
operator|=
name|cinfo
operator|->
name|Se
expr_stmt|;
name|Al
operator|=
name|cinfo
operator|->
name|Al
expr_stmt|;
name|natural_order
operator|=
name|cinfo
operator|->
name|natural_order
expr_stmt|;
comment|/* Encode the MCU data block */
name|block
operator|=
name|MCU_data
index|[
literal|0
index|]
expr_stmt|;
comment|/* Encode the AC coefficients per section G.1.2.2, fig. G.3 */
name|r
operator|=
literal|0
expr_stmt|;
comment|/* r = run length of zeros */
for|for
control|(
name|k
operator|=
name|cinfo
operator|->
name|Ss
init|;
name|k
operator|<=
name|Se
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|temp
operator|=
operator|(
operator|*
name|block
operator|)
index|[
name|natural_order
index|[
name|k
index|]
index|]
operator|)
operator|==
literal|0
condition|)
block|{
name|r
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* We must apply the point transform by Al.  For AC coefficients this      * is an integer division with rounding towards 0.  To do this portably      * in C, we shift after obtaining the absolute value; so the code is      * interwoven with finding the abs value (temp) and output bits (temp2).      */
if|if
condition|(
name|temp
operator|<
literal|0
condition|)
block|{
name|temp
operator|=
operator|-
name|temp
expr_stmt|;
comment|/* temp is abs value of input */
name|temp
operator|>>=
name|Al
expr_stmt|;
comment|/* apply the point transform */
comment|/* For a negative coef, want temp2 = bitwise complement of abs(coef) */
name|temp2
operator|=
operator|~
name|temp
expr_stmt|;
block|}
else|else
block|{
name|temp
operator|>>=
name|Al
expr_stmt|;
comment|/* apply the point transform */
name|temp2
operator|=
name|temp
expr_stmt|;
block|}
comment|/* Watch out for case that nonzero coef is zero after point transform */
if|if
condition|(
name|temp
operator|==
literal|0
condition|)
block|{
name|r
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* Emit any pending EOBRUN */
if|if
condition|(
name|entropy
operator|->
name|EOBRUN
operator|>
literal|0
condition|)
name|emit_eobrun
argument_list|(
name|entropy
argument_list|)
expr_stmt|;
comment|/* if run length> 15, must emit special run-length-16 codes (0xF0) */
while|while
condition|(
name|r
operator|>
literal|15
condition|)
block|{
name|emit_ac_symbol
argument_list|(
name|entropy
argument_list|,
name|entropy
operator|->
name|ac_tbl_no
argument_list|,
literal|0xF0
argument_list|)
expr_stmt|;
name|r
operator|-=
literal|16
expr_stmt|;
block|}
comment|/* Find the number of bits needed for the magnitude of the coefficient */
name|nbits
operator|=
literal|1
expr_stmt|;
comment|/* there must be at least one 1 bit */
while|while
condition|(
operator|(
name|temp
operator|>>=
literal|1
operator|)
condition|)
name|nbits
operator|++
expr_stmt|;
comment|/* Check for out-of-range coefficient values */
if|if
condition|(
name|nbits
operator|>
name|MAX_COEF_BITS
condition|)
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_DCT_COEF
argument_list|)
expr_stmt|;
comment|/* Count/emit Huffman symbol for run length / number of bits */
name|emit_ac_symbol
argument_list|(
name|entropy
argument_list|,
name|entropy
operator|->
name|ac_tbl_no
argument_list|,
operator|(
name|r
operator|<<
literal|4
operator|)
operator|+
name|nbits
argument_list|)
expr_stmt|;
comment|/* Emit that number of bits of the value, if positive, */
comment|/* or the complement of its magnitude, if negative. */
name|emit_bits_e
argument_list|(
name|entropy
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|temp2
argument_list|,
name|nbits
argument_list|)
expr_stmt|;
name|r
operator|=
literal|0
expr_stmt|;
comment|/* reset zero run length */
block|}
if|if
condition|(
name|r
operator|>
literal|0
condition|)
block|{
comment|/* If there are trailing zeroes, */
name|entropy
operator|->
name|EOBRUN
operator|++
expr_stmt|;
comment|/* count an EOB */
if|if
condition|(
name|entropy
operator|->
name|EOBRUN
operator|==
literal|0x7FFF
condition|)
name|emit_eobrun
argument_list|(
name|entropy
argument_list|)
expr_stmt|;
comment|/* force it out to avoid overflow */
block|}
name|cinfo
operator|->
name|dest
operator|->
name|next_output_byte
operator|=
name|entropy
operator|->
name|next_output_byte
expr_stmt|;
name|cinfo
operator|->
name|dest
operator|->
name|free_in_buffer
operator|=
name|entropy
operator|->
name|free_in_buffer
expr_stmt|;
comment|/* Update restart-interval state too */
if|if
condition|(
name|cinfo
operator|->
name|restart_interval
condition|)
block|{
if|if
condition|(
name|entropy
operator|->
name|restarts_to_go
operator|==
literal|0
condition|)
block|{
name|entropy
operator|->
name|restarts_to_go
operator|=
name|cinfo
operator|->
name|restart_interval
expr_stmt|;
name|entropy
operator|->
name|next_restart_num
operator|++
expr_stmt|;
name|entropy
operator|->
name|next_restart_num
operator|&=
literal|7
expr_stmt|;
block|}
name|entropy
operator|->
name|restarts_to_go
operator|--
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_block
begin_comment
comment|/*  * MCU encoding for DC successive approximation refinement scan.  * Note: we assume such scans can be multi-component, although the spec  * is not very clear on the point.  */
end_comment
begin_macro
DECL|function|METHODDEF
name|METHODDEF
argument_list|(
argument|boolean
argument_list|)
end_macro
begin_macro
name|encode_mcu_DC_refine
argument_list|(
argument|j_compress_ptr cinfo
argument_list|,
argument|JBLOCKROW *MCU_data
argument_list|)
end_macro
begin_block
block|{
name|huff_entropy_ptr
name|entropy
init|=
operator|(
name|huff_entropy_ptr
operator|)
name|cinfo
operator|->
name|entropy
decl_stmt|;
specifier|register
name|int
name|temp
decl_stmt|;
name|int
name|blkn
decl_stmt|;
name|int
name|Al
init|=
name|cinfo
operator|->
name|Al
decl_stmt|;
name|JBLOCKROW
name|block
decl_stmt|;
name|entropy
operator|->
name|next_output_byte
operator|=
name|cinfo
operator|->
name|dest
operator|->
name|next_output_byte
expr_stmt|;
name|entropy
operator|->
name|free_in_buffer
operator|=
name|cinfo
operator|->
name|dest
operator|->
name|free_in_buffer
expr_stmt|;
comment|/* Emit restart marker if needed */
if|if
condition|(
name|cinfo
operator|->
name|restart_interval
condition|)
if|if
condition|(
name|entropy
operator|->
name|restarts_to_go
operator|==
literal|0
condition|)
name|emit_restart_e
argument_list|(
name|entropy
argument_list|,
name|entropy
operator|->
name|next_restart_num
argument_list|)
expr_stmt|;
comment|/* Encode the MCU data blocks */
for|for
control|(
name|blkn
operator|=
literal|0
init|;
name|blkn
operator|<
name|cinfo
operator|->
name|blocks_in_MCU
condition|;
name|blkn
operator|++
control|)
block|{
name|block
operator|=
name|MCU_data
index|[
name|blkn
index|]
expr_stmt|;
comment|/* We simply emit the Al'th bit of the DC coefficient value. */
name|temp
operator|=
operator|(
operator|*
name|block
operator|)
index|[
literal|0
index|]
expr_stmt|;
name|emit_bits_e
argument_list|(
name|entropy
argument_list|,
call|(
name|unsigned
name|int
call|)
argument_list|(
name|temp
operator|>>
name|Al
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|cinfo
operator|->
name|dest
operator|->
name|next_output_byte
operator|=
name|entropy
operator|->
name|next_output_byte
expr_stmt|;
name|cinfo
operator|->
name|dest
operator|->
name|free_in_buffer
operator|=
name|entropy
operator|->
name|free_in_buffer
expr_stmt|;
comment|/* Update restart-interval state too */
if|if
condition|(
name|cinfo
operator|->
name|restart_interval
condition|)
block|{
if|if
condition|(
name|entropy
operator|->
name|restarts_to_go
operator|==
literal|0
condition|)
block|{
name|entropy
operator|->
name|restarts_to_go
operator|=
name|cinfo
operator|->
name|restart_interval
expr_stmt|;
name|entropy
operator|->
name|next_restart_num
operator|++
expr_stmt|;
name|entropy
operator|->
name|next_restart_num
operator|&=
literal|7
expr_stmt|;
block|}
name|entropy
operator|->
name|restarts_to_go
operator|--
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_block
begin_comment
comment|/*  * MCU encoding for AC successive approximation refinement scan.  */
end_comment
begin_macro
DECL|function|METHODDEF
name|METHODDEF
argument_list|(
argument|boolean
argument_list|)
end_macro
begin_macro
name|encode_mcu_AC_refine
argument_list|(
argument|j_compress_ptr cinfo
argument_list|,
argument|JBLOCKROW *MCU_data
argument_list|)
end_macro
begin_block
block|{
name|huff_entropy_ptr
name|entropy
init|=
operator|(
name|huff_entropy_ptr
operator|)
name|cinfo
operator|->
name|entropy
decl_stmt|;
specifier|register
name|int
name|temp
decl_stmt|;
specifier|register
name|int
name|r
decl_stmt|,
name|k
decl_stmt|;
name|int
name|EOB
decl_stmt|;
name|char
modifier|*
name|BR_buffer
decl_stmt|;
name|unsigned
name|int
name|BR
decl_stmt|;
name|int
name|Se
decl_stmt|,
name|Al
decl_stmt|;
specifier|const
name|int
modifier|*
name|natural_order
decl_stmt|;
name|JBLOCKROW
name|block
decl_stmt|;
name|int
name|absvalues
index|[
name|DCTSIZE2
index|]
decl_stmt|;
name|entropy
operator|->
name|next_output_byte
operator|=
name|cinfo
operator|->
name|dest
operator|->
name|next_output_byte
expr_stmt|;
name|entropy
operator|->
name|free_in_buffer
operator|=
name|cinfo
operator|->
name|dest
operator|->
name|free_in_buffer
expr_stmt|;
comment|/* Emit restart marker if needed */
if|if
condition|(
name|cinfo
operator|->
name|restart_interval
condition|)
if|if
condition|(
name|entropy
operator|->
name|restarts_to_go
operator|==
literal|0
condition|)
name|emit_restart_e
argument_list|(
name|entropy
argument_list|,
name|entropy
operator|->
name|next_restart_num
argument_list|)
expr_stmt|;
name|Se
operator|=
name|cinfo
operator|->
name|Se
expr_stmt|;
name|Al
operator|=
name|cinfo
operator|->
name|Al
expr_stmt|;
name|natural_order
operator|=
name|cinfo
operator|->
name|natural_order
expr_stmt|;
comment|/* Encode the MCU data block */
name|block
operator|=
name|MCU_data
index|[
literal|0
index|]
expr_stmt|;
comment|/* It is convenient to make a pre-pass to determine the transformed    * coefficients' absolute values and the EOB position.    */
name|EOB
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|k
operator|=
name|cinfo
operator|->
name|Ss
init|;
name|k
operator|<=
name|Se
condition|;
name|k
operator|++
control|)
block|{
name|temp
operator|=
operator|(
operator|*
name|block
operator|)
index|[
name|natural_order
index|[
name|k
index|]
index|]
expr_stmt|;
comment|/* We must apply the point transform by Al.  For AC coefficients this      * is an integer division with rounding towards 0.  To do this portably      * in C, we shift after obtaining the absolute value.      */
if|if
condition|(
name|temp
operator|<
literal|0
condition|)
name|temp
operator|=
operator|-
name|temp
expr_stmt|;
comment|/* temp is abs value of input */
name|temp
operator|>>=
name|Al
expr_stmt|;
comment|/* apply the point transform */
name|absvalues
index|[
name|k
index|]
operator|=
name|temp
expr_stmt|;
comment|/* save abs value for main pass */
if|if
condition|(
name|temp
operator|==
literal|1
condition|)
name|EOB
operator|=
name|k
expr_stmt|;
comment|/* EOB = index of last newly-nonzero coef */
block|}
comment|/* Encode the AC coefficients per section G.1.2.3, fig. G.7 */
name|r
operator|=
literal|0
expr_stmt|;
comment|/* r = run length of zeros */
name|BR
operator|=
literal|0
expr_stmt|;
comment|/* BR = count of buffered bits added now */
name|BR_buffer
operator|=
name|entropy
operator|->
name|bit_buffer
operator|+
name|entropy
operator|->
name|BE
expr_stmt|;
comment|/* Append bits to buffer */
for|for
control|(
name|k
operator|=
name|cinfo
operator|->
name|Ss
init|;
name|k
operator|<=
name|Se
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|temp
operator|=
name|absvalues
index|[
name|k
index|]
operator|)
operator|==
literal|0
condition|)
block|{
name|r
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* Emit any required ZRLs, but not if they can be folded into EOB */
while|while
condition|(
name|r
operator|>
literal|15
operator|&&
name|k
operator|<=
name|EOB
condition|)
block|{
comment|/* emit any pending EOBRUN and the BE correction bits */
name|emit_eobrun
argument_list|(
name|entropy
argument_list|)
expr_stmt|;
comment|/* Emit ZRL */
name|emit_ac_symbol
argument_list|(
name|entropy
argument_list|,
name|entropy
operator|->
name|ac_tbl_no
argument_list|,
literal|0xF0
argument_list|)
expr_stmt|;
name|r
operator|-=
literal|16
expr_stmt|;
comment|/* Emit buffered correction bits that must be associated with ZRL */
name|emit_buffered_bits
argument_list|(
name|entropy
argument_list|,
name|BR_buffer
argument_list|,
name|BR
argument_list|)
expr_stmt|;
name|BR_buffer
operator|=
name|entropy
operator|->
name|bit_buffer
expr_stmt|;
comment|/* BE bits are gone now */
name|BR
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If the coef was previously nonzero, it only needs a correction bit.      * NOTE: a straight translation of the spec's figure G.7 would suggest      * that we also need to test r> 15.  But if r> 15, we can only get here      * if k> EOB, which implies that this coefficient is not 1.      */
if|if
condition|(
name|temp
operator|>
literal|1
condition|)
block|{
comment|/* The correction bit is the next bit of the absolute value. */
name|BR_buffer
index|[
name|BR
operator|++
index|]
operator|=
call|(
name|char
call|)
argument_list|(
name|temp
operator|&
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Emit any pending EOBRUN and the BE correction bits */
name|emit_eobrun
argument_list|(
name|entropy
argument_list|)
expr_stmt|;
comment|/* Count/emit Huffman symbol for run length / number of bits */
name|emit_ac_symbol
argument_list|(
name|entropy
argument_list|,
name|entropy
operator|->
name|ac_tbl_no
argument_list|,
operator|(
name|r
operator|<<
literal|4
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Emit output bit for newly-nonzero coef */
name|temp
operator|=
operator|(
operator|(
operator|*
name|block
operator|)
index|[
name|natural_order
index|[
name|k
index|]
index|]
operator|<
literal|0
operator|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
name|emit_bits_e
argument_list|(
name|entropy
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|temp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Emit buffered correction bits that must be associated with this code */
name|emit_buffered_bits
argument_list|(
name|entropy
argument_list|,
name|BR_buffer
argument_list|,
name|BR
argument_list|)
expr_stmt|;
name|BR_buffer
operator|=
name|entropy
operator|->
name|bit_buffer
expr_stmt|;
comment|/* BE bits are gone now */
name|BR
operator|=
literal|0
expr_stmt|;
name|r
operator|=
literal|0
expr_stmt|;
comment|/* reset zero run length */
block|}
if|if
condition|(
name|r
operator|>
literal|0
operator|||
name|BR
operator|>
literal|0
condition|)
block|{
comment|/* If there are trailing zeroes, */
name|entropy
operator|->
name|EOBRUN
operator|++
expr_stmt|;
comment|/* count an EOB */
name|entropy
operator|->
name|BE
operator|+=
name|BR
expr_stmt|;
comment|/* concat my correction bits to older ones */
comment|/* We force out the EOB if we risk either:      * 1. overflow of the EOB counter;      * 2. overflow of the correction bit buffer during the next MCU.      */
if|if
condition|(
name|entropy
operator|->
name|EOBRUN
operator|==
literal|0x7FFF
operator|||
name|entropy
operator|->
name|BE
operator|>
operator|(
name|MAX_CORR_BITS
operator|-
name|DCTSIZE2
operator|+
literal|1
operator|)
condition|)
name|emit_eobrun
argument_list|(
name|entropy
argument_list|)
expr_stmt|;
block|}
name|cinfo
operator|->
name|dest
operator|->
name|next_output_byte
operator|=
name|entropy
operator|->
name|next_output_byte
expr_stmt|;
name|cinfo
operator|->
name|dest
operator|->
name|free_in_buffer
operator|=
name|entropy
operator|->
name|free_in_buffer
expr_stmt|;
comment|/* Update restart-interval state too */
if|if
condition|(
name|cinfo
operator|->
name|restart_interval
condition|)
block|{
if|if
condition|(
name|entropy
operator|->
name|restarts_to_go
operator|==
literal|0
condition|)
block|{
name|entropy
operator|->
name|restarts_to_go
operator|=
name|cinfo
operator|->
name|restart_interval
expr_stmt|;
name|entropy
operator|->
name|next_restart_num
operator|++
expr_stmt|;
name|entropy
operator|->
name|next_restart_num
operator|&=
literal|7
expr_stmt|;
block|}
name|entropy
operator|->
name|restarts_to_go
operator|--
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_block
begin_comment
comment|/* Encode a single block's worth of coefficients */
end_comment
begin_macro
DECL|function|LOCAL
name|LOCAL
argument_list|(
argument|boolean
argument_list|)
end_macro
begin_macro
name|encode_one_block
argument_list|(
argument|working_state * state
argument_list|,
argument|JCOEFPTR block
argument_list|,
argument|int last_dc_val
argument_list|,
argument|c_derived_tbl *dctbl
argument_list|,
argument|c_derived_tbl *actbl
argument_list|)
end_macro
begin_block
block|{
specifier|register
name|int
name|temp
decl_stmt|,
name|temp2
decl_stmt|;
specifier|register
name|int
name|nbits
decl_stmt|;
specifier|register
name|int
name|k
decl_stmt|,
name|r
decl_stmt|,
name|i
decl_stmt|;
name|int
name|Se
init|=
name|state
operator|->
name|cinfo
operator|->
name|lim_Se
decl_stmt|;
specifier|const
name|int
modifier|*
name|natural_order
init|=
name|state
operator|->
name|cinfo
operator|->
name|natural_order
decl_stmt|;
comment|/* Encode the DC coefficient difference per section F.1.2.1 */
name|temp
operator|=
name|temp2
operator|=
name|block
index|[
literal|0
index|]
operator|-
name|last_dc_val
expr_stmt|;
if|if
condition|(
name|temp
operator|<
literal|0
condition|)
block|{
name|temp
operator|=
operator|-
name|temp
expr_stmt|;
comment|/* temp is abs value of input */
comment|/* For a negative input, want temp2 = bitwise complement of abs(input) */
comment|/* This code assumes we are on a two's complement machine */
name|temp2
operator|--
expr_stmt|;
block|}
comment|/* Find the number of bits needed for the magnitude of the coefficient */
name|nbits
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|temp
condition|)
block|{
name|nbits
operator|++
expr_stmt|;
name|temp
operator|>>=
literal|1
expr_stmt|;
block|}
comment|/* Check for out-of-range coefficient values.    * Since we're encoding a difference, the range limit is twice as much.    */
if|if
condition|(
name|nbits
operator|>
name|MAX_COEF_BITS
operator|+
literal|1
condition|)
name|ERREXIT
argument_list|(
name|state
operator|->
name|cinfo
argument_list|,
name|JERR_BAD_DCT_COEF
argument_list|)
expr_stmt|;
comment|/* Emit the Huffman-coded symbol for the number of bits */
if|if
condition|(
operator|!
name|emit_bits_s
argument_list|(
name|state
argument_list|,
name|dctbl
operator|->
name|ehufco
index|[
name|nbits
index|]
argument_list|,
name|dctbl
operator|->
name|ehufsi
index|[
name|nbits
index|]
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Emit that number of bits of the value, if positive, */
comment|/* or the complement of its magnitude, if negative. */
if|if
condition|(
name|nbits
condition|)
comment|/* emit_bits rejects calls with size 0 */
if|if
condition|(
operator|!
name|emit_bits_s
argument_list|(
name|state
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|temp2
argument_list|,
name|nbits
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Encode the AC coefficients per section F.1.2.2 */
name|r
operator|=
literal|0
expr_stmt|;
comment|/* r = run length of zeros */
for|for
control|(
name|k
operator|=
literal|1
init|;
name|k
operator|<=
name|Se
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|temp
operator|=
name|block
index|[
name|natural_order
index|[
name|k
index|]
index|]
operator|)
operator|==
literal|0
condition|)
block|{
name|r
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* if run length> 15, must emit special run-length-16 codes (0xF0) */
while|while
condition|(
name|r
operator|>
literal|15
condition|)
block|{
if|if
condition|(
operator|!
name|emit_bits_s
argument_list|(
name|state
argument_list|,
name|actbl
operator|->
name|ehufco
index|[
literal|0xF0
index|]
argument_list|,
name|actbl
operator|->
name|ehufsi
index|[
literal|0xF0
index|]
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|r
operator|-=
literal|16
expr_stmt|;
block|}
name|temp2
operator|=
name|temp
expr_stmt|;
if|if
condition|(
name|temp
operator|<
literal|0
condition|)
block|{
name|temp
operator|=
operator|-
name|temp
expr_stmt|;
comment|/* temp is abs value of input */
comment|/* This code assumes we are on a two's complement machine */
name|temp2
operator|--
expr_stmt|;
block|}
comment|/* Find the number of bits needed for the magnitude of the coefficient */
name|nbits
operator|=
literal|1
expr_stmt|;
comment|/* there must be at least one 1 bit */
while|while
condition|(
operator|(
name|temp
operator|>>=
literal|1
operator|)
condition|)
name|nbits
operator|++
expr_stmt|;
comment|/* Check for out-of-range coefficient values */
if|if
condition|(
name|nbits
operator|>
name|MAX_COEF_BITS
condition|)
name|ERREXIT
argument_list|(
name|state
operator|->
name|cinfo
argument_list|,
name|JERR_BAD_DCT_COEF
argument_list|)
expr_stmt|;
comment|/* Emit Huffman symbol for run length / number of bits */
name|i
operator|=
operator|(
name|r
operator|<<
literal|4
operator|)
operator|+
name|nbits
expr_stmt|;
if|if
condition|(
operator|!
name|emit_bits_s
argument_list|(
name|state
argument_list|,
name|actbl
operator|->
name|ehufco
index|[
name|i
index|]
argument_list|,
name|actbl
operator|->
name|ehufsi
index|[
name|i
index|]
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Emit that number of bits of the value, if positive, */
comment|/* or the complement of its magnitude, if negative. */
if|if
condition|(
operator|!
name|emit_bits_s
argument_list|(
name|state
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|temp2
argument_list|,
name|nbits
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|r
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* If the last coef(s) were zero, emit an end-of-block code */
if|if
condition|(
name|r
operator|>
literal|0
condition|)
if|if
condition|(
operator|!
name|emit_bits_s
argument_list|(
name|state
argument_list|,
name|actbl
operator|->
name|ehufco
index|[
literal|0
index|]
argument_list|,
name|actbl
operator|->
name|ehufsi
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_block
begin_comment
comment|/*  * Encode and output one MCU's worth of Huffman-compressed coefficients.  */
end_comment
begin_macro
DECL|function|METHODDEF
name|METHODDEF
argument_list|(
argument|boolean
argument_list|)
end_macro
begin_macro
name|encode_mcu_huff
argument_list|(
argument|j_compress_ptr cinfo
argument_list|,
argument|JBLOCKROW *MCU_data
argument_list|)
end_macro
begin_block
block|{
name|huff_entropy_ptr
name|entropy
init|=
operator|(
name|huff_entropy_ptr
operator|)
name|cinfo
operator|->
name|entropy
decl_stmt|;
name|working_state
name|state
decl_stmt|;
name|int
name|blkn
decl_stmt|,
name|ci
decl_stmt|;
name|jpeg_component_info
modifier|*
name|compptr
decl_stmt|;
comment|/* Load up working state */
name|state
operator|.
name|next_output_byte
operator|=
name|cinfo
operator|->
name|dest
operator|->
name|next_output_byte
expr_stmt|;
name|state
operator|.
name|free_in_buffer
operator|=
name|cinfo
operator|->
name|dest
operator|->
name|free_in_buffer
expr_stmt|;
name|ASSIGN_STATE
argument_list|(
name|state
operator|.
name|cur
argument_list|,
name|entropy
operator|->
name|saved
argument_list|)
expr_stmt|;
name|state
operator|.
name|cinfo
operator|=
name|cinfo
expr_stmt|;
comment|/* Emit restart marker if needed */
if|if
condition|(
name|cinfo
operator|->
name|restart_interval
condition|)
block|{
if|if
condition|(
name|entropy
operator|->
name|restarts_to_go
operator|==
literal|0
condition|)
if|if
condition|(
operator|!
name|emit_restart_s
argument_list|(
operator|&
name|state
argument_list|,
name|entropy
operator|->
name|next_restart_num
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* Encode the MCU data blocks */
for|for
control|(
name|blkn
operator|=
literal|0
init|;
name|blkn
operator|<
name|cinfo
operator|->
name|blocks_in_MCU
condition|;
name|blkn
operator|++
control|)
block|{
name|ci
operator|=
name|cinfo
operator|->
name|MCU_membership
index|[
name|blkn
index|]
expr_stmt|;
name|compptr
operator|=
name|cinfo
operator|->
name|cur_comp_info
index|[
name|ci
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|encode_one_block
argument_list|(
operator|&
name|state
argument_list|,
name|MCU_data
index|[
name|blkn
index|]
index|[
literal|0
index|]
argument_list|,
name|state
operator|.
name|cur
operator|.
name|last_dc_val
index|[
name|ci
index|]
argument_list|,
name|entropy
operator|->
name|dc_derived_tbls
index|[
name|compptr
operator|->
name|dc_tbl_no
index|]
argument_list|,
name|entropy
operator|->
name|ac_derived_tbls
index|[
name|compptr
operator|->
name|ac_tbl_no
index|]
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Update last_dc_val */
name|state
operator|.
name|cur
operator|.
name|last_dc_val
index|[
name|ci
index|]
operator|=
name|MCU_data
index|[
name|blkn
index|]
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
block|}
comment|/* Completed MCU, so update state */
name|cinfo
operator|->
name|dest
operator|->
name|next_output_byte
operator|=
name|state
operator|.
name|next_output_byte
expr_stmt|;
name|cinfo
operator|->
name|dest
operator|->
name|free_in_buffer
operator|=
name|state
operator|.
name|free_in_buffer
expr_stmt|;
name|ASSIGN_STATE
argument_list|(
name|entropy
operator|->
name|saved
argument_list|,
name|state
operator|.
name|cur
argument_list|)
expr_stmt|;
comment|/* Update restart-interval state too */
if|if
condition|(
name|cinfo
operator|->
name|restart_interval
condition|)
block|{
if|if
condition|(
name|entropy
operator|->
name|restarts_to_go
operator|==
literal|0
condition|)
block|{
name|entropy
operator|->
name|restarts_to_go
operator|=
name|cinfo
operator|->
name|restart_interval
expr_stmt|;
name|entropy
operator|->
name|next_restart_num
operator|++
expr_stmt|;
name|entropy
operator|->
name|next_restart_num
operator|&=
literal|7
expr_stmt|;
block|}
name|entropy
operator|->
name|restarts_to_go
operator|--
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_block
begin_comment
comment|/*  * Finish up at the end of a Huffman-compressed scan.  */
end_comment
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|finish_pass_huff
name|finish_pass_huff
argument_list|(
argument|j_compress_ptr cinfo
argument_list|)
end_macro
begin_block
block|{
name|huff_entropy_ptr
name|entropy
init|=
operator|(
name|huff_entropy_ptr
operator|)
name|cinfo
operator|->
name|entropy
decl_stmt|;
name|working_state
name|state
decl_stmt|;
if|if
condition|(
name|cinfo
operator|->
name|progressive_mode
condition|)
block|{
name|entropy
operator|->
name|next_output_byte
operator|=
name|cinfo
operator|->
name|dest
operator|->
name|next_output_byte
expr_stmt|;
name|entropy
operator|->
name|free_in_buffer
operator|=
name|cinfo
operator|->
name|dest
operator|->
name|free_in_buffer
expr_stmt|;
comment|/* Flush out any buffered data */
name|emit_eobrun
argument_list|(
name|entropy
argument_list|)
expr_stmt|;
name|flush_bits_e
argument_list|(
name|entropy
argument_list|)
expr_stmt|;
name|cinfo
operator|->
name|dest
operator|->
name|next_output_byte
operator|=
name|entropy
operator|->
name|next_output_byte
expr_stmt|;
name|cinfo
operator|->
name|dest
operator|->
name|free_in_buffer
operator|=
name|entropy
operator|->
name|free_in_buffer
expr_stmt|;
block|}
else|else
block|{
comment|/* Load up working state ... flush_bits needs it */
name|state
operator|.
name|next_output_byte
operator|=
name|cinfo
operator|->
name|dest
operator|->
name|next_output_byte
expr_stmt|;
name|state
operator|.
name|free_in_buffer
operator|=
name|cinfo
operator|->
name|dest
operator|->
name|free_in_buffer
expr_stmt|;
name|ASSIGN_STATE
argument_list|(
name|state
operator|.
name|cur
argument_list|,
name|entropy
operator|->
name|saved
argument_list|)
expr_stmt|;
name|state
operator|.
name|cinfo
operator|=
name|cinfo
expr_stmt|;
comment|/* Flush out the last data */
if|if
condition|(
operator|!
name|flush_bits_s
argument_list|(
operator|&
name|state
argument_list|)
condition|)
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_CANT_SUSPEND
argument_list|)
expr_stmt|;
comment|/* Update state */
name|cinfo
operator|->
name|dest
operator|->
name|next_output_byte
operator|=
name|state
operator|.
name|next_output_byte
expr_stmt|;
name|cinfo
operator|->
name|dest
operator|->
name|free_in_buffer
operator|=
name|state
operator|.
name|free_in_buffer
expr_stmt|;
name|ASSIGN_STATE
argument_list|(
name|entropy
operator|->
name|saved
argument_list|,
name|state
operator|.
name|cur
argument_list|)
expr_stmt|;
block|}
block|}
end_block
begin_comment
comment|/*  * Huffman coding optimization.  *  * We first scan the supplied data and count the number of uses of each symbol  * that is to be Huffman-coded. (This process MUST agree with the code above.)  * Then we build a Huffman coding tree for the observed counts.  * Symbols which are not needed at all for the particular image are not  * assigned any code, which saves space in the DHT marker as well as in  * the compressed data.  */
end_comment
begin_comment
comment|/* Process a single block's worth of coefficients */
end_comment
begin_macro
name|LOCAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|htest_one_block
name|htest_one_block
argument_list|(
argument|j_compress_ptr cinfo
argument_list|,
argument|JCOEFPTR block
argument_list|,
argument|int last_dc_val
argument_list|,
argument|long dc_counts[]
argument_list|,
argument|long ac_counts[]
argument_list|)
end_macro
begin_block
block|{
specifier|register
name|int
name|temp
decl_stmt|;
specifier|register
name|int
name|nbits
decl_stmt|;
specifier|register
name|int
name|k
decl_stmt|,
name|r
decl_stmt|;
name|int
name|Se
init|=
name|cinfo
operator|->
name|lim_Se
decl_stmt|;
specifier|const
name|int
modifier|*
name|natural_order
init|=
name|cinfo
operator|->
name|natural_order
decl_stmt|;
comment|/* Encode the DC coefficient difference per section F.1.2.1 */
name|temp
operator|=
name|block
index|[
literal|0
index|]
operator|-
name|last_dc_val
expr_stmt|;
if|if
condition|(
name|temp
operator|<
literal|0
condition|)
name|temp
operator|=
operator|-
name|temp
expr_stmt|;
comment|/* Find the number of bits needed for the magnitude of the coefficient */
name|nbits
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|temp
condition|)
block|{
name|nbits
operator|++
expr_stmt|;
name|temp
operator|>>=
literal|1
expr_stmt|;
block|}
comment|/* Check for out-of-range coefficient values.    * Since we're encoding a difference, the range limit is twice as much.    */
if|if
condition|(
name|nbits
operator|>
name|MAX_COEF_BITS
operator|+
literal|1
condition|)
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_DCT_COEF
argument_list|)
expr_stmt|;
comment|/* Count the Huffman symbol for the number of bits */
name|dc_counts
index|[
name|nbits
index|]
operator|++
expr_stmt|;
comment|/* Encode the AC coefficients per section F.1.2.2 */
name|r
operator|=
literal|0
expr_stmt|;
comment|/* r = run length of zeros */
for|for
control|(
name|k
operator|=
literal|1
init|;
name|k
operator|<=
name|Se
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|temp
operator|=
name|block
index|[
name|natural_order
index|[
name|k
index|]
index|]
operator|)
operator|==
literal|0
condition|)
block|{
name|r
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* if run length> 15, must emit special run-length-16 codes (0xF0) */
while|while
condition|(
name|r
operator|>
literal|15
condition|)
block|{
name|ac_counts
index|[
literal|0xF0
index|]
operator|++
expr_stmt|;
name|r
operator|-=
literal|16
expr_stmt|;
block|}
comment|/* Find the number of bits needed for the magnitude of the coefficient */
if|if
condition|(
name|temp
operator|<
literal|0
condition|)
name|temp
operator|=
operator|-
name|temp
expr_stmt|;
comment|/* Find the number of bits needed for the magnitude of the coefficient */
name|nbits
operator|=
literal|1
expr_stmt|;
comment|/* there must be at least one 1 bit */
while|while
condition|(
operator|(
name|temp
operator|>>=
literal|1
operator|)
condition|)
name|nbits
operator|++
expr_stmt|;
comment|/* Check for out-of-range coefficient values */
if|if
condition|(
name|nbits
operator|>
name|MAX_COEF_BITS
condition|)
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_BAD_DCT_COEF
argument_list|)
expr_stmt|;
comment|/* Count Huffman symbol for run length / number of bits */
name|ac_counts
index|[
operator|(
name|r
operator|<<
literal|4
operator|)
operator|+
name|nbits
index|]
operator|++
expr_stmt|;
name|r
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* If the last coef(s) were zero, emit an end-of-block code */
if|if
condition|(
name|r
operator|>
literal|0
condition|)
name|ac_counts
index|[
literal|0
index|]
operator|++
expr_stmt|;
block|}
end_block
begin_comment
comment|/*  * Trial-encode one MCU's worth of Huffman-compressed coefficients.  * No data is actually output, so no suspension return is possible.  */
end_comment
begin_macro
DECL|function|METHODDEF
name|METHODDEF
argument_list|(
argument|boolean
argument_list|)
end_macro
begin_macro
name|encode_mcu_gather
argument_list|(
argument|j_compress_ptr cinfo
argument_list|,
argument|JBLOCKROW *MCU_data
argument_list|)
end_macro
begin_block
block|{
name|huff_entropy_ptr
name|entropy
init|=
operator|(
name|huff_entropy_ptr
operator|)
name|cinfo
operator|->
name|entropy
decl_stmt|;
name|int
name|blkn
decl_stmt|,
name|ci
decl_stmt|;
name|jpeg_component_info
modifier|*
name|compptr
decl_stmt|;
comment|/* Take care of restart intervals if needed */
if|if
condition|(
name|cinfo
operator|->
name|restart_interval
condition|)
block|{
if|if
condition|(
name|entropy
operator|->
name|restarts_to_go
operator|==
literal|0
condition|)
block|{
comment|/* Re-initialize DC predictions to 0 */
for|for
control|(
name|ci
operator|=
literal|0
init|;
name|ci
operator|<
name|cinfo
operator|->
name|comps_in_scan
condition|;
name|ci
operator|++
control|)
name|entropy
operator|->
name|saved
operator|.
name|last_dc_val
index|[
name|ci
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Update restart state */
name|entropy
operator|->
name|restarts_to_go
operator|=
name|cinfo
operator|->
name|restart_interval
expr_stmt|;
block|}
name|entropy
operator|->
name|restarts_to_go
operator|--
expr_stmt|;
block|}
for|for
control|(
name|blkn
operator|=
literal|0
init|;
name|blkn
operator|<
name|cinfo
operator|->
name|blocks_in_MCU
condition|;
name|blkn
operator|++
control|)
block|{
name|ci
operator|=
name|cinfo
operator|->
name|MCU_membership
index|[
name|blkn
index|]
expr_stmt|;
name|compptr
operator|=
name|cinfo
operator|->
name|cur_comp_info
index|[
name|ci
index|]
expr_stmt|;
name|htest_one_block
argument_list|(
name|cinfo
argument_list|,
name|MCU_data
index|[
name|blkn
index|]
index|[
literal|0
index|]
argument_list|,
name|entropy
operator|->
name|saved
operator|.
name|last_dc_val
index|[
name|ci
index|]
argument_list|,
name|entropy
operator|->
name|dc_count_ptrs
index|[
name|compptr
operator|->
name|dc_tbl_no
index|]
argument_list|,
name|entropy
operator|->
name|ac_count_ptrs
index|[
name|compptr
operator|->
name|ac_tbl_no
index|]
argument_list|)
expr_stmt|;
name|entropy
operator|->
name|saved
operator|.
name|last_dc_val
index|[
name|ci
index|]
operator|=
name|MCU_data
index|[
name|blkn
index|]
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_block
begin_comment
comment|/*  * Generate the best Huffman code table for the given counts, fill htbl.  *  * The JPEG standard requires that no symbol be assigned a codeword of all  * one bits (so that padding bits added at the end of a compressed segment  * can't look like a valid code).  Because of the canonical ordering of  * codewords, this just means that there must be an unused slot in the  * longest codeword length category.  Section K.2 of the JPEG spec suggests  * reserving such a slot by pretending that symbol 256 is a valid symbol  * with count 1.  In theory that's not optimal; giving it count zero but  * including it in the symbol set anyway should give a better Huffman code.  * But the theoretically better code actually seems to come out worse in  * practice, because it produces more all-ones bytes (which incur stuffed  * zero bytes in the final file).  In any case the difference is tiny.  *  * The JPEG standard requires Huffman codes to be no more than 16 bits long.  * If some symbols have a very small but nonzero probability, the Huffman tree  * must be adjusted to meet the code length restriction.  We currently use  * the adjustment method suggested in JPEG section K.2.  This method is *not*  * optimal; it may not choose the best possible limited-length code.  But  * typically only very-low-frequency symbols will be given less-than-optimal  * lengths, so the code is almost optimal.  Experimental comparisons against  * an optimal limited-length-code algorithm indicate that the difference is  * microscopic --- usually less than a hundredth of a percent of total size.  * So the extra complexity of an optimal algorithm doesn't seem worthwhile.  */
end_comment
begin_macro
name|LOCAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|jpeg_gen_optimal_table
name|jpeg_gen_optimal_table
argument_list|(
argument|j_compress_ptr cinfo
argument_list|,
argument|JHUFF_TBL * htbl
argument_list|,
argument|long freq[]
argument_list|)
end_macro
begin_block
block|{
DECL|macro|MAX_CLEN
define|#
directive|define
name|MAX_CLEN
value|32
comment|/* assumed maximum initial code length */
name|UINT8
name|bits
index|[
name|MAX_CLEN
operator|+
literal|1
index|]
decl_stmt|;
comment|/* bits[k] = # of symbols with code length k */
name|int
name|codesize
index|[
literal|257
index|]
decl_stmt|;
comment|/* codesize[k] = code length of symbol k */
name|int
name|others
index|[
literal|257
index|]
decl_stmt|;
comment|/* next symbol in current branch of tree */
name|int
name|c1
decl_stmt|,
name|c2
decl_stmt|;
name|int
name|p
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|long
name|v
decl_stmt|;
comment|/* This algorithm is explained in section K.2 of the JPEG standard */
name|MEMZERO
argument_list|(
name|bits
argument_list|,
name|SIZEOF
argument_list|(
name|bits
argument_list|)
argument_list|)
expr_stmt|;
name|MEMZERO
argument_list|(
name|codesize
argument_list|,
name|SIZEOF
argument_list|(
name|codesize
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|257
condition|;
name|i
operator|++
control|)
name|others
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* init links to empty */
name|freq
index|[
literal|256
index|]
operator|=
literal|1
expr_stmt|;
comment|/* make sure 256 has a nonzero count */
comment|/* Including the pseudo-symbol 256 in the Huffman procedure guarantees    * that no real symbol is given code-value of all ones, because 256    * will be placed last in the largest codeword category.    */
comment|/* Huffman's basic algorithm to assign optimal code lengths to symbols */
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Find the smallest nonzero frequency, set c1 = its symbol */
comment|/* In case of ties, take the larger symbol number */
name|c1
operator|=
operator|-
literal|1
expr_stmt|;
name|v
operator|=
literal|1000000000L
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
literal|256
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|freq
index|[
name|i
index|]
operator|&&
name|freq
index|[
name|i
index|]
operator|<=
name|v
condition|)
block|{
name|v
operator|=
name|freq
index|[
name|i
index|]
expr_stmt|;
name|c1
operator|=
name|i
expr_stmt|;
block|}
block|}
comment|/* Find the next smallest nonzero frequency, set c2 = its symbol */
comment|/* In case of ties, take the larger symbol number */
name|c2
operator|=
operator|-
literal|1
expr_stmt|;
name|v
operator|=
literal|1000000000L
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
literal|256
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|freq
index|[
name|i
index|]
operator|&&
name|freq
index|[
name|i
index|]
operator|<=
name|v
operator|&&
name|i
operator|!=
name|c1
condition|)
block|{
name|v
operator|=
name|freq
index|[
name|i
index|]
expr_stmt|;
name|c2
operator|=
name|i
expr_stmt|;
block|}
block|}
comment|/* Done if we've merged everything into one frequency */
if|if
condition|(
name|c2
operator|<
literal|0
condition|)
break|break;
comment|/* Else merge the two counts/trees */
name|freq
index|[
name|c1
index|]
operator|+=
name|freq
index|[
name|c2
index|]
expr_stmt|;
name|freq
index|[
name|c2
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Increment the codesize of everything in c1's tree branch */
name|codesize
index|[
name|c1
index|]
operator|++
expr_stmt|;
while|while
condition|(
name|others
index|[
name|c1
index|]
operator|>=
literal|0
condition|)
block|{
name|c1
operator|=
name|others
index|[
name|c1
index|]
expr_stmt|;
name|codesize
index|[
name|c1
index|]
operator|++
expr_stmt|;
block|}
name|others
index|[
name|c1
index|]
operator|=
name|c2
expr_stmt|;
comment|/* chain c2 onto c1's tree branch */
comment|/* Increment the codesize of everything in c2's tree branch */
name|codesize
index|[
name|c2
index|]
operator|++
expr_stmt|;
while|while
condition|(
name|others
index|[
name|c2
index|]
operator|>=
literal|0
condition|)
block|{
name|c2
operator|=
name|others
index|[
name|c2
index|]
expr_stmt|;
name|codesize
index|[
name|c2
index|]
operator|++
expr_stmt|;
block|}
block|}
comment|/* Now count the number of symbols of each code length */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
literal|256
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|codesize
index|[
name|i
index|]
condition|)
block|{
comment|/* The JPEG standard seems to think that this can't happen, */
comment|/* but I'm paranoid... */
if|if
condition|(
name|codesize
index|[
name|i
index|]
operator|>
name|MAX_CLEN
condition|)
name|ERREXIT
argument_list|(
name|cinfo
argument_list|,
name|JERR_HUFF_CLEN_OVERFLOW
argument_list|)
expr_stmt|;
name|bits
index|[
name|codesize
index|[
name|i
index|]
index|]
operator|++
expr_stmt|;
block|}
block|}
comment|/* JPEG doesn't allow symbols with code lengths over 16 bits, so if the pure    * Huffman procedure assigned any such lengths, we must adjust the coding.    * Here is what the JPEG spec says about how this next bit works:    * Since symbols are paired for the longest Huffman code, the symbols are    * removed from this length category two at a time.  The prefix for the pair    * (which is one bit shorter) is allocated to one of the pair; then,    * skipping the BITS entry for that prefix length, a code word from the next    * shortest nonzero BITS entry is converted into a prefix for two code words    * one bit longer.    */
for|for
control|(
name|i
operator|=
name|MAX_CLEN
init|;
name|i
operator|>
literal|16
condition|;
name|i
operator|--
control|)
block|{
while|while
condition|(
name|bits
index|[
name|i
index|]
operator|>
literal|0
condition|)
block|{
name|j
operator|=
name|i
operator|-
literal|2
expr_stmt|;
comment|/* find length of new prefix to be used */
while|while
condition|(
name|bits
index|[
name|j
index|]
operator|==
literal|0
condition|)
name|j
operator|--
expr_stmt|;
name|bits
index|[
name|i
index|]
operator|-=
literal|2
expr_stmt|;
comment|/* remove two symbols */
name|bits
index|[
name|i
operator|-
literal|1
index|]
operator|++
expr_stmt|;
comment|/* one goes in this length */
name|bits
index|[
name|j
operator|+
literal|1
index|]
operator|+=
literal|2
expr_stmt|;
comment|/* two new symbols in this length */
name|bits
index|[
name|j
index|]
operator|--
expr_stmt|;
comment|/* symbol of this length is now a prefix */
block|}
block|}
comment|/* Remove the count for the pseudo-symbol 256 from the largest codelength */
while|while
condition|(
name|bits
index|[
name|i
index|]
operator|==
literal|0
condition|)
comment|/* find largest codelength still in use */
name|i
operator|--
expr_stmt|;
name|bits
index|[
name|i
index|]
operator|--
expr_stmt|;
comment|/* Return final symbol counts (only for lengths 0..16) */
name|MEMCOPY
argument_list|(
name|htbl
operator|->
name|bits
argument_list|,
name|bits
argument_list|,
name|SIZEOF
argument_list|(
name|htbl
operator|->
name|bits
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Return a list of the symbols sorted by code length */
comment|/* It's not real clear to me why we don't need to consider the codelength    * changes made above, but the JPEG spec seems to think this works.    */
name|p
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|MAX_CLEN
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
literal|255
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|codesize
index|[
name|j
index|]
operator|==
name|i
condition|)
block|{
name|htbl
operator|->
name|huffval
index|[
name|p
index|]
operator|=
operator|(
name|UINT8
operator|)
name|j
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|/* Set sent_table FALSE so updated table will be written to JPEG file. */
name|htbl
operator|->
name|sent_table
operator|=
name|FALSE
expr_stmt|;
block|}
end_block
begin_comment
comment|/*  * Finish up a statistics-gathering pass and create the new Huffman tables.  */
end_comment
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|finish_pass_gather
name|finish_pass_gather
argument_list|(
argument|j_compress_ptr cinfo
argument_list|)
end_macro
begin_block
block|{
name|huff_entropy_ptr
name|entropy
init|=
operator|(
name|huff_entropy_ptr
operator|)
name|cinfo
operator|->
name|entropy
decl_stmt|;
name|int
name|ci
decl_stmt|,
name|tbl
decl_stmt|;
name|jpeg_component_info
modifier|*
name|compptr
decl_stmt|;
name|JHUFF_TBL
modifier|*
modifier|*
name|htblptr
decl_stmt|;
name|boolean
name|did_dc
index|[
name|NUM_HUFF_TBLS
index|]
decl_stmt|;
name|boolean
name|did_ac
index|[
name|NUM_HUFF_TBLS
index|]
decl_stmt|;
comment|/* It's important not to apply jpeg_gen_optimal_table more than once    * per table, because it clobbers the input frequency counts!    */
if|if
condition|(
name|cinfo
operator|->
name|progressive_mode
condition|)
comment|/* Flush out buffered data (all we care about is counting the EOB symbol) */
name|emit_eobrun
argument_list|(
name|entropy
argument_list|)
expr_stmt|;
name|MEMZERO
argument_list|(
name|did_dc
argument_list|,
name|SIZEOF
argument_list|(
name|did_dc
argument_list|)
argument_list|)
expr_stmt|;
name|MEMZERO
argument_list|(
name|did_ac
argument_list|,
name|SIZEOF
argument_list|(
name|did_ac
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|ci
operator|=
literal|0
init|;
name|ci
operator|<
name|cinfo
operator|->
name|comps_in_scan
condition|;
name|ci
operator|++
control|)
block|{
name|compptr
operator|=
name|cinfo
operator|->
name|cur_comp_info
index|[
name|ci
index|]
expr_stmt|;
comment|/* DC needs no table for refinement scan */
if|if
condition|(
name|cinfo
operator|->
name|Ss
operator|==
literal|0
operator|&&
name|cinfo
operator|->
name|Ah
operator|==
literal|0
condition|)
block|{
name|tbl
operator|=
name|compptr
operator|->
name|dc_tbl_no
expr_stmt|;
if|if
condition|(
operator|!
name|did_dc
index|[
name|tbl
index|]
condition|)
block|{
name|htblptr
operator|=
operator|&
name|cinfo
operator|->
name|dc_huff_tbl_ptrs
index|[
name|tbl
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|htblptr
operator|==
name|NULL
condition|)
operator|*
name|htblptr
operator|=
name|jpeg_alloc_huff_table
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|)
expr_stmt|;
name|jpeg_gen_optimal_table
argument_list|(
name|cinfo
argument_list|,
operator|*
name|htblptr
argument_list|,
name|entropy
operator|->
name|dc_count_ptrs
index|[
name|tbl
index|]
argument_list|)
expr_stmt|;
name|did_dc
index|[
name|tbl
index|]
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
comment|/* AC needs no table when not present */
if|if
condition|(
name|cinfo
operator|->
name|Se
condition|)
block|{
name|tbl
operator|=
name|compptr
operator|->
name|ac_tbl_no
expr_stmt|;
if|if
condition|(
operator|!
name|did_ac
index|[
name|tbl
index|]
condition|)
block|{
name|htblptr
operator|=
operator|&
name|cinfo
operator|->
name|ac_huff_tbl_ptrs
index|[
name|tbl
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|htblptr
operator|==
name|NULL
condition|)
operator|*
name|htblptr
operator|=
name|jpeg_alloc_huff_table
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|)
expr_stmt|;
name|jpeg_gen_optimal_table
argument_list|(
name|cinfo
argument_list|,
operator|*
name|htblptr
argument_list|,
name|entropy
operator|->
name|ac_count_ptrs
index|[
name|tbl
index|]
argument_list|)
expr_stmt|;
name|did_ac
index|[
name|tbl
index|]
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
block|}
end_block
begin_comment
comment|/*  * Initialize for a Huffman-compressed scan.  * If gather_statistics is TRUE, we do not output anything during the scan,  * just count the Huffman symbols used and generate Huffman code tables.  */
end_comment
begin_macro
name|METHODDEF
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|start_pass_huff
name|start_pass_huff
argument_list|(
argument|j_compress_ptr cinfo
argument_list|,
argument|boolean gather_statistics
argument_list|)
end_macro
begin_block
block|{
name|huff_entropy_ptr
name|entropy
init|=
operator|(
name|huff_entropy_ptr
operator|)
name|cinfo
operator|->
name|entropy
decl_stmt|;
name|int
name|ci
decl_stmt|,
name|tbl
decl_stmt|;
name|jpeg_component_info
modifier|*
name|compptr
decl_stmt|;
if|if
condition|(
name|gather_statistics
condition|)
name|entropy
operator|->
name|pub
operator|.
name|finish_pass
operator|=
name|finish_pass_gather
expr_stmt|;
else|else
name|entropy
operator|->
name|pub
operator|.
name|finish_pass
operator|=
name|finish_pass_huff
expr_stmt|;
if|if
condition|(
name|cinfo
operator|->
name|progressive_mode
condition|)
block|{
name|entropy
operator|->
name|cinfo
operator|=
name|cinfo
expr_stmt|;
name|entropy
operator|->
name|gather_statistics
operator|=
name|gather_statistics
expr_stmt|;
comment|/* We assume jcmaster.c already validated the scan parameters. */
comment|/* Select execution routine */
if|if
condition|(
name|cinfo
operator|->
name|Ah
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|cinfo
operator|->
name|Ss
operator|==
literal|0
condition|)
name|entropy
operator|->
name|pub
operator|.
name|encode_mcu
operator|=
name|encode_mcu_DC_first
expr_stmt|;
else|else
name|entropy
operator|->
name|pub
operator|.
name|encode_mcu
operator|=
name|encode_mcu_AC_first
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|cinfo
operator|->
name|Ss
operator|==
literal|0
condition|)
name|entropy
operator|->
name|pub
operator|.
name|encode_mcu
operator|=
name|encode_mcu_DC_refine
expr_stmt|;
else|else
block|{
name|entropy
operator|->
name|pub
operator|.
name|encode_mcu
operator|=
name|encode_mcu_AC_refine
expr_stmt|;
comment|/* AC refinement needs a correction bit buffer */
if|if
condition|(
name|entropy
operator|->
name|bit_buffer
operator|==
name|NULL
condition|)
name|entropy
operator|->
name|bit_buffer
operator|=
operator|(
name|char
operator|*
operator|)
call|(
modifier|*
name|cinfo
operator|->
name|mem
operator|->
name|alloc_small
call|)
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|,
name|JPOOL_IMAGE
argument_list|,
name|MAX_CORR_BITS
operator|*
name|SIZEOF
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Initialize AC stuff */
name|entropy
operator|->
name|ac_tbl_no
operator|=
name|cinfo
operator|->
name|cur_comp_info
index|[
literal|0
index|]
operator|->
name|ac_tbl_no
expr_stmt|;
name|entropy
operator|->
name|EOBRUN
operator|=
literal|0
expr_stmt|;
name|entropy
operator|->
name|BE
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|gather_statistics
condition|)
name|entropy
operator|->
name|pub
operator|.
name|encode_mcu
operator|=
name|encode_mcu_gather
expr_stmt|;
else|else
name|entropy
operator|->
name|pub
operator|.
name|encode_mcu
operator|=
name|encode_mcu_huff
expr_stmt|;
block|}
for|for
control|(
name|ci
operator|=
literal|0
init|;
name|ci
operator|<
name|cinfo
operator|->
name|comps_in_scan
condition|;
name|ci
operator|++
control|)
block|{
name|compptr
operator|=
name|cinfo
operator|->
name|cur_comp_info
index|[
name|ci
index|]
expr_stmt|;
comment|/* DC needs no table for refinement scan */
if|if
condition|(
name|cinfo
operator|->
name|Ss
operator|==
literal|0
operator|&&
name|cinfo
operator|->
name|Ah
operator|==
literal|0
condition|)
block|{
name|tbl
operator|=
name|compptr
operator|->
name|dc_tbl_no
expr_stmt|;
if|if
condition|(
name|gather_statistics
condition|)
block|{
comment|/* Check for invalid table index */
comment|/* (make_c_derived_tbl does this in the other path) */
if|if
condition|(
name|tbl
operator|<
literal|0
operator|||
name|tbl
operator|>=
name|NUM_HUFF_TBLS
condition|)
name|ERREXIT1
argument_list|(
name|cinfo
argument_list|,
name|JERR_NO_HUFF_TABLE
argument_list|,
name|tbl
argument_list|)
expr_stmt|;
comment|/* Allocate and zero the statistics tables */
comment|/* Note that jpeg_gen_optimal_table expects 257 entries in each table! */
if|if
condition|(
name|entropy
operator|->
name|dc_count_ptrs
index|[
name|tbl
index|]
operator|==
name|NULL
condition|)
name|entropy
operator|->
name|dc_count_ptrs
index|[
name|tbl
index|]
operator|=
operator|(
name|long
operator|*
operator|)
call|(
modifier|*
name|cinfo
operator|->
name|mem
operator|->
name|alloc_small
call|)
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|,
name|JPOOL_IMAGE
argument_list|,
literal|257
operator|*
name|SIZEOF
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
name|MEMZERO
argument_list|(
name|entropy
operator|->
name|dc_count_ptrs
index|[
name|tbl
index|]
argument_list|,
literal|257
operator|*
name|SIZEOF
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Compute derived values for Huffman tables */
comment|/* We may do this more than once for a table, but it's not expensive */
name|jpeg_make_c_derived_tbl
argument_list|(
name|cinfo
argument_list|,
name|TRUE
argument_list|,
name|tbl
argument_list|,
operator|&
name|entropy
operator|->
name|dc_derived_tbls
index|[
name|tbl
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize DC predictions to 0 */
name|entropy
operator|->
name|saved
operator|.
name|last_dc_val
index|[
name|ci
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* AC needs no table when not present */
if|if
condition|(
name|cinfo
operator|->
name|Se
condition|)
block|{
name|tbl
operator|=
name|compptr
operator|->
name|ac_tbl_no
expr_stmt|;
if|if
condition|(
name|gather_statistics
condition|)
block|{
if|if
condition|(
name|tbl
operator|<
literal|0
operator|||
name|tbl
operator|>=
name|NUM_HUFF_TBLS
condition|)
name|ERREXIT1
argument_list|(
name|cinfo
argument_list|,
name|JERR_NO_HUFF_TABLE
argument_list|,
name|tbl
argument_list|)
expr_stmt|;
if|if
condition|(
name|entropy
operator|->
name|ac_count_ptrs
index|[
name|tbl
index|]
operator|==
name|NULL
condition|)
name|entropy
operator|->
name|ac_count_ptrs
index|[
name|tbl
index|]
operator|=
operator|(
name|long
operator|*
operator|)
call|(
modifier|*
name|cinfo
operator|->
name|mem
operator|->
name|alloc_small
call|)
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|,
name|JPOOL_IMAGE
argument_list|,
literal|257
operator|*
name|SIZEOF
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
name|MEMZERO
argument_list|(
name|entropy
operator|->
name|ac_count_ptrs
index|[
name|tbl
index|]
argument_list|,
literal|257
operator|*
name|SIZEOF
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|jpeg_make_c_derived_tbl
argument_list|(
name|cinfo
argument_list|,
name|FALSE
argument_list|,
name|tbl
argument_list|,
operator|&
name|entropy
operator|->
name|ac_derived_tbls
index|[
name|tbl
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Initialize bit buffer to empty */
name|entropy
operator|->
name|saved
operator|.
name|put_buffer
operator|=
literal|0
expr_stmt|;
name|entropy
operator|->
name|saved
operator|.
name|put_bits
operator|=
literal|0
expr_stmt|;
comment|/* Initialize restart stuff */
name|entropy
operator|->
name|restarts_to_go
operator|=
name|cinfo
operator|->
name|restart_interval
expr_stmt|;
name|entropy
operator|->
name|next_restart_num
operator|=
literal|0
expr_stmt|;
block|}
end_block
begin_comment
comment|/*  * Module initialization routine for Huffman entropy encoding.  */
end_comment
begin_macro
name|GLOBAL
argument_list|(
argument|void
argument_list|)
end_macro
begin_macro
DECL|function|jinit_huff_encoder
name|jinit_huff_encoder
argument_list|(
argument|j_compress_ptr cinfo
argument_list|)
end_macro
begin_block
block|{
name|huff_entropy_ptr
name|entropy
decl_stmt|;
name|int
name|i
decl_stmt|;
name|entropy
operator|=
call|(
name|huff_entropy_ptr
call|)
argument_list|(
operator|*
name|cinfo
operator|->
name|mem
operator|->
name|alloc_small
argument_list|)
argument_list|(
operator|(
name|j_common_ptr
operator|)
name|cinfo
argument_list|,
name|JPOOL_IMAGE
argument_list|,
name|SIZEOF
argument_list|(
name|huff_entropy_encoder
argument_list|)
argument_list|)
expr_stmt|;
name|cinfo
operator|->
name|entropy
operator|=
operator|(
expr|struct
name|jpeg_entropy_encoder
operator|*
operator|)
name|entropy
expr_stmt|;
name|entropy
operator|->
name|pub
operator|.
name|start_pass
operator|=
name|start_pass_huff
expr_stmt|;
comment|/* Mark tables unallocated */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_HUFF_TBLS
condition|;
name|i
operator|++
control|)
block|{
name|entropy
operator|->
name|dc_derived_tbls
index|[
name|i
index|]
operator|=
name|entropy
operator|->
name|ac_derived_tbls
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|entropy
operator|->
name|dc_count_ptrs
index|[
name|i
index|]
operator|=
name|entropy
operator|->
name|ac_count_ptrs
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|cinfo
operator|->
name|progressive_mode
condition|)
name|entropy
operator|->
name|bit_buffer
operator|=
name|NULL
expr_stmt|;
comment|/* needed only in AC refinement scan */
block|}
end_block
end_unit
