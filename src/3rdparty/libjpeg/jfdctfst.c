begin_unit
begin_comment
comment|/*  * jfdctfst.c  *  * Copyright (C) 1994-1996, Thomas G. Lane.  * Modified 2003-2009 by Guido Vollbeding.  * This file is part of the Independent JPEG Group's software.  * For conditions of distribution and use, see the accompanying README file.  *  * This file contains a fast, not so accurate integer implementation of the  * forward DCT (Discrete Cosine Transform).  *  * A 2-D DCT can be done by 1-D DCT on each row followed by 1-D DCT  * on each column.  Direct algorithms are also available, but they are  * much more complex and seem not to be any faster when reduced to code.  *  * This implementation is based on Arai, Agui, and Nakajima's algorithm for  * scaled DCT.  Their original paper (Trans. IEICE E-71(11):1095) is in  * Japanese, but the algorithm is described in the Pennebaker& Mitchell  * JPEG textbook (see REFERENCES section in file README).  The following code  * is based directly on figure 4-8 in P&M.  * While an 8-point DCT cannot be done in less than 11 multiplies, it is  * possible to arrange the computation so that many of the multiplies are  * simple scalings of the final outputs.  These multiplies can then be  * folded into the multiplications or divisions by the JPEG quantization  * table entries.  The AA&N method leaves only 5 multiplies and 29 adds  * to be done in the DCT itself.  * The primary disadvantage of this method is that with fixed-point math,  * accuracy is lost due to imprecise representation of the scaled  * quantization values.  The smaller the quantization table entry, the less  * precise the scaled value, so this implementation does worse with high-  * quality-setting files than with low-quality ones.  */
end_comment
begin_define
DECL|macro|JPEG_INTERNALS
define|#
directive|define
name|JPEG_INTERNALS
end_define
begin_include
include|#
directive|include
file|"jinclude.h"
end_include
begin_include
include|#
directive|include
file|"jpeglib.h"
end_include
begin_include
include|#
directive|include
file|"jdct.h"
end_include
begin_comment
comment|/* Private declarations for DCT subsystem */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|DCT_IFAST_SUPPORTED
end_ifdef
begin_comment
comment|/*  * This module is specialized to the case DCTSIZE = 8.  */
end_comment
begin_if
if|#
directive|if
name|DCTSIZE
operator|!=
literal|8
end_if
begin_expr_stmt
name|Sorry
operator|,
name|this
name|code
name|only
name|copes
name|with
literal|8x8
name|DCTs
operator|.
comment|/* deliberate syntax err */
endif|#
directive|endif
comment|/* Scaling decisions are generally the same as in the LL&M algorithm;  * see jfdctint.c for more details.  However, we choose to descale  * (right shift) multiplication products as soon as they are formed,  * rather than carrying additional fractional bits into subsequent additions.  * This compromises accuracy slightly, but it lets us save a few shifts.  * More importantly, 16-bit arithmetic is then adequate (for 8-bit samples)  * everywhere except in the multiplications proper; this saves a good deal  * of work on 16-bit-int machines.  *  * Again to save a few shifts, the intermediate results between pass 1 and  * pass 2 are not upscaled, but are represented only to integral precision.  *  * A final compromise is to represent the multiplicative constants to only  * 8 fractional bits, rather than 13.  This saves some shifting work on some  * machines, and may also reduce the cost of multiplication (since there  * are fewer one-bits in the constants).  */
DECL|macro|CONST_BITS
define|#
directive|define
name|CONST_BITS
value|8
comment|/* Some C compilers fail to reduce "FIX(constant)" at compile time, thus  * causing a lot of useless floating-point operations at run time.  * To get around this we use the following pre-calculated constants.  * If you change CONST_BITS you may want to add appropriate values.  * (With a reasonable C compiler, you can just rely on the FIX() macro...)  */
if|#
directive|if
name|CONST_BITS
operator|==
literal|8
DECL|macro|FIX_0_382683433
define|#
directive|define
name|FIX_0_382683433
value|((INT32)   98)
comment|/* FIX(0.382683433) */
DECL|macro|FIX_0_541196100
define|#
directive|define
name|FIX_0_541196100
value|((INT32)  139)
comment|/* FIX(0.541196100) */
DECL|macro|FIX_0_707106781
define|#
directive|define
name|FIX_0_707106781
value|((INT32)  181)
comment|/* FIX(0.707106781) */
DECL|macro|FIX_1_306562965
define|#
directive|define
name|FIX_1_306562965
value|((INT32)  334)
comment|/* FIX(1.306562965) */
else|#
directive|else
define|#
directive|define
name|FIX_0_382683433
value|FIX(0.382683433)
define|#
directive|define
name|FIX_0_541196100
value|FIX(0.541196100)
define|#
directive|define
name|FIX_0_707106781
value|FIX(0.707106781)
define|#
directive|define
name|FIX_1_306562965
value|FIX(1.306562965)
endif|#
directive|endif
comment|/* We can gain a little more speed, with a further compromise in accuracy,  * by omitting the addition in a descaling shift.  This yields an incorrectly  * rounded result half the time...  */
ifndef|#
directive|ifndef
name|USE_ACCURATE_ROUNDING
DECL|macro|DESCALE
undef|#
directive|undef
name|DESCALE
DECL|macro|DESCALE
define|#
directive|define
name|DESCALE
parameter_list|(
name|x
parameter_list|,
name|n
parameter_list|)
value|RIGHT_SHIFT(x, n)
endif|#
directive|endif
comment|/* Multiply a DCTELEM variable by an INT32 constant, and immediately  * descale to yield a DCTELEM result.  */
DECL|macro|MULTIPLY
define|#
directive|define
name|MULTIPLY
parameter_list|(
name|var
parameter_list|,
specifier|const
parameter_list|)
value|((DCTELEM) DESCALE((var) * (const), CONST_BITS))
comment|/*  * Perform the forward DCT on one block of samples.  */
name|GLOBAL
argument_list|(
argument|void
argument_list|)
DECL|function|jpeg_fdct_ifast
name|jpeg_fdct_ifast
argument_list|(
argument|DCTELEM * data
argument_list|,
argument|JSAMPARRAY sample_data
argument_list|,
argument|JDIMENSION start_col
argument_list|)
block|{
name|DCTELEM
name|tmp0
block|,
name|tmp1
block|,
name|tmp2
block|,
name|tmp3
block|,
name|tmp4
block|,
name|tmp5
block|,
name|tmp6
block|,
name|tmp7
block|;
name|DCTELEM
name|tmp10
block|,
name|tmp11
block|,
name|tmp12
block|,
name|tmp13
block|;
name|DCTELEM
name|z1
block|,
name|z2
block|,
name|z3
block|,
name|z4
block|,
name|z5
block|,
name|z11
block|,
name|z13
block|;
name|DCTELEM
operator|*
name|dataptr
block|;
name|JSAMPROW
name|elemptr
block|;
name|int
name|ctr
block|;
name|SHIFT_TEMPS
comment|/* Pass 1: process rows. */
name|dataptr
operator|=
name|data
block|;
for|for
control|(
name|ctr
operator|=
literal|0
init|;
name|ctr
operator|<
name|DCTSIZE
condition|;
name|ctr
operator|++
control|)
block|{
name|elemptr
operator|=
name|sample_data
index|[
name|ctr
index|]
operator|+
name|start_col
expr_stmt|;
comment|/* Load data into workspace */
name|tmp0
operator|=
name|GETJSAMPLE
argument_list|(
name|elemptr
index|[
literal|0
index|]
argument_list|)
operator|+
name|GETJSAMPLE
argument_list|(
name|elemptr
index|[
literal|7
index|]
argument_list|)
expr_stmt|;
name|tmp7
operator|=
name|GETJSAMPLE
argument_list|(
name|elemptr
index|[
literal|0
index|]
argument_list|)
operator|-
name|GETJSAMPLE
argument_list|(
name|elemptr
index|[
literal|7
index|]
argument_list|)
expr_stmt|;
name|tmp1
operator|=
name|GETJSAMPLE
argument_list|(
name|elemptr
index|[
literal|1
index|]
argument_list|)
operator|+
name|GETJSAMPLE
argument_list|(
name|elemptr
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
name|tmp6
operator|=
name|GETJSAMPLE
argument_list|(
name|elemptr
index|[
literal|1
index|]
argument_list|)
operator|-
name|GETJSAMPLE
argument_list|(
name|elemptr
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
name|tmp2
operator|=
name|GETJSAMPLE
argument_list|(
name|elemptr
index|[
literal|2
index|]
argument_list|)
operator|+
name|GETJSAMPLE
argument_list|(
name|elemptr
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|tmp5
operator|=
name|GETJSAMPLE
argument_list|(
name|elemptr
index|[
literal|2
index|]
argument_list|)
operator|-
name|GETJSAMPLE
argument_list|(
name|elemptr
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|tmp3
operator|=
name|GETJSAMPLE
argument_list|(
name|elemptr
index|[
literal|3
index|]
argument_list|)
operator|+
name|GETJSAMPLE
argument_list|(
name|elemptr
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|tmp4
operator|=
name|GETJSAMPLE
argument_list|(
name|elemptr
index|[
literal|3
index|]
argument_list|)
operator|-
name|GETJSAMPLE
argument_list|(
name|elemptr
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
comment|/* Even part */
name|tmp10
operator|=
name|tmp0
operator|+
name|tmp3
expr_stmt|;
comment|/* phase 2 */
name|tmp13
operator|=
name|tmp0
operator|-
name|tmp3
expr_stmt|;
name|tmp11
operator|=
name|tmp1
operator|+
name|tmp2
expr_stmt|;
name|tmp12
operator|=
name|tmp1
operator|-
name|tmp2
expr_stmt|;
comment|/* Apply unsigned->signed conversion */
name|dataptr
index|[
literal|0
index|]
operator|=
name|tmp10
operator|+
name|tmp11
operator|-
literal|8
operator|*
name|CENTERJSAMPLE
expr_stmt|;
comment|/* phase 3 */
name|dataptr
index|[
literal|4
index|]
operator|=
name|tmp10
operator|-
name|tmp11
expr_stmt|;
name|z1
operator|=
name|MULTIPLY
argument_list|(
name|tmp12
operator|+
name|tmp13
argument_list|,
name|FIX_0_707106781
argument_list|)
expr_stmt|;
comment|/* c4 */
name|dataptr
index|[
literal|2
index|]
operator|=
name|tmp13
operator|+
name|z1
expr_stmt|;
comment|/* phase 5 */
name|dataptr
index|[
literal|6
index|]
operator|=
name|tmp13
operator|-
name|z1
expr_stmt|;
comment|/* Odd part */
name|tmp10
operator|=
name|tmp4
operator|+
name|tmp5
expr_stmt|;
comment|/* phase 2 */
name|tmp11
operator|=
name|tmp5
operator|+
name|tmp6
expr_stmt|;
name|tmp12
operator|=
name|tmp6
operator|+
name|tmp7
expr_stmt|;
comment|/* The rotator is modified from fig 4-8 to avoid extra negations. */
name|z5
operator|=
name|MULTIPLY
argument_list|(
name|tmp10
operator|-
name|tmp12
argument_list|,
name|FIX_0_382683433
argument_list|)
expr_stmt|;
comment|/* c6 */
name|z2
operator|=
name|MULTIPLY
argument_list|(
name|tmp10
argument_list|,
name|FIX_0_541196100
argument_list|)
operator|+
name|z5
expr_stmt|;
comment|/* c2-c6 */
name|z4
operator|=
name|MULTIPLY
argument_list|(
name|tmp12
argument_list|,
name|FIX_1_306562965
argument_list|)
operator|+
name|z5
expr_stmt|;
comment|/* c2+c6 */
name|z3
operator|=
name|MULTIPLY
argument_list|(
name|tmp11
argument_list|,
name|FIX_0_707106781
argument_list|)
expr_stmt|;
comment|/* c4 */
name|z11
operator|=
name|tmp7
operator|+
name|z3
expr_stmt|;
comment|/* phase 5 */
name|z13
operator|=
name|tmp7
operator|-
name|z3
expr_stmt|;
name|dataptr
index|[
literal|5
index|]
operator|=
name|z13
operator|+
name|z2
expr_stmt|;
comment|/* phase 6 */
name|dataptr
index|[
literal|3
index|]
operator|=
name|z13
operator|-
name|z2
expr_stmt|;
name|dataptr
index|[
literal|1
index|]
operator|=
name|z11
operator|+
name|z4
expr_stmt|;
name|dataptr
index|[
literal|7
index|]
operator|=
name|z11
operator|-
name|z4
expr_stmt|;
name|dataptr
operator|+=
name|DCTSIZE
expr_stmt|;
comment|/* advance pointer to next row */
block|}
comment|/* Pass 2: process columns. */
name|dataptr
operator|=
name|data
expr_stmt|;
end_expr_stmt
begin_for
for|for
control|(
name|ctr
operator|=
name|DCTSIZE
operator|-
literal|1
init|;
name|ctr
operator|>=
literal|0
condition|;
name|ctr
operator|--
control|)
block|{
name|tmp0
operator|=
name|dataptr
index|[
name|DCTSIZE
operator|*
literal|0
index|]
operator|+
name|dataptr
index|[
name|DCTSIZE
operator|*
literal|7
index|]
expr_stmt|;
name|tmp7
operator|=
name|dataptr
index|[
name|DCTSIZE
operator|*
literal|0
index|]
operator|-
name|dataptr
index|[
name|DCTSIZE
operator|*
literal|7
index|]
expr_stmt|;
name|tmp1
operator|=
name|dataptr
index|[
name|DCTSIZE
operator|*
literal|1
index|]
operator|+
name|dataptr
index|[
name|DCTSIZE
operator|*
literal|6
index|]
expr_stmt|;
name|tmp6
operator|=
name|dataptr
index|[
name|DCTSIZE
operator|*
literal|1
index|]
operator|-
name|dataptr
index|[
name|DCTSIZE
operator|*
literal|6
index|]
expr_stmt|;
name|tmp2
operator|=
name|dataptr
index|[
name|DCTSIZE
operator|*
literal|2
index|]
operator|+
name|dataptr
index|[
name|DCTSIZE
operator|*
literal|5
index|]
expr_stmt|;
name|tmp5
operator|=
name|dataptr
index|[
name|DCTSIZE
operator|*
literal|2
index|]
operator|-
name|dataptr
index|[
name|DCTSIZE
operator|*
literal|5
index|]
expr_stmt|;
name|tmp3
operator|=
name|dataptr
index|[
name|DCTSIZE
operator|*
literal|3
index|]
operator|+
name|dataptr
index|[
name|DCTSIZE
operator|*
literal|4
index|]
expr_stmt|;
name|tmp4
operator|=
name|dataptr
index|[
name|DCTSIZE
operator|*
literal|3
index|]
operator|-
name|dataptr
index|[
name|DCTSIZE
operator|*
literal|4
index|]
expr_stmt|;
comment|/* Even part */
name|tmp10
operator|=
name|tmp0
operator|+
name|tmp3
expr_stmt|;
comment|/* phase 2 */
name|tmp13
operator|=
name|tmp0
operator|-
name|tmp3
expr_stmt|;
name|tmp11
operator|=
name|tmp1
operator|+
name|tmp2
expr_stmt|;
name|tmp12
operator|=
name|tmp1
operator|-
name|tmp2
expr_stmt|;
name|dataptr
index|[
name|DCTSIZE
operator|*
literal|0
index|]
operator|=
name|tmp10
operator|+
name|tmp11
expr_stmt|;
comment|/* phase 3 */
name|dataptr
index|[
name|DCTSIZE
operator|*
literal|4
index|]
operator|=
name|tmp10
operator|-
name|tmp11
expr_stmt|;
name|z1
operator|=
name|MULTIPLY
argument_list|(
name|tmp12
operator|+
name|tmp13
argument_list|,
name|FIX_0_707106781
argument_list|)
expr_stmt|;
comment|/* c4 */
name|dataptr
index|[
name|DCTSIZE
operator|*
literal|2
index|]
operator|=
name|tmp13
operator|+
name|z1
expr_stmt|;
comment|/* phase 5 */
name|dataptr
index|[
name|DCTSIZE
operator|*
literal|6
index|]
operator|=
name|tmp13
operator|-
name|z1
expr_stmt|;
comment|/* Odd part */
name|tmp10
operator|=
name|tmp4
operator|+
name|tmp5
expr_stmt|;
comment|/* phase 2 */
name|tmp11
operator|=
name|tmp5
operator|+
name|tmp6
expr_stmt|;
name|tmp12
operator|=
name|tmp6
operator|+
name|tmp7
expr_stmt|;
comment|/* The rotator is modified from fig 4-8 to avoid extra negations. */
name|z5
operator|=
name|MULTIPLY
argument_list|(
name|tmp10
operator|-
name|tmp12
argument_list|,
name|FIX_0_382683433
argument_list|)
expr_stmt|;
comment|/* c6 */
name|z2
operator|=
name|MULTIPLY
argument_list|(
name|tmp10
argument_list|,
name|FIX_0_541196100
argument_list|)
operator|+
name|z5
expr_stmt|;
comment|/* c2-c6 */
name|z4
operator|=
name|MULTIPLY
argument_list|(
name|tmp12
argument_list|,
name|FIX_1_306562965
argument_list|)
operator|+
name|z5
expr_stmt|;
comment|/* c2+c6 */
name|z3
operator|=
name|MULTIPLY
argument_list|(
name|tmp11
argument_list|,
name|FIX_0_707106781
argument_list|)
expr_stmt|;
comment|/* c4 */
name|z11
operator|=
name|tmp7
operator|+
name|z3
expr_stmt|;
comment|/* phase 5 */
name|z13
operator|=
name|tmp7
operator|-
name|z3
expr_stmt|;
name|dataptr
index|[
name|DCTSIZE
operator|*
literal|5
index|]
operator|=
name|z13
operator|+
name|z2
expr_stmt|;
comment|/* phase 6 */
name|dataptr
index|[
name|DCTSIZE
operator|*
literal|3
index|]
operator|=
name|z13
operator|-
name|z2
expr_stmt|;
name|dataptr
index|[
name|DCTSIZE
operator|*
literal|1
index|]
operator|=
name|z11
operator|+
name|z4
expr_stmt|;
name|dataptr
index|[
name|DCTSIZE
operator|*
literal|7
index|]
operator|=
name|z11
operator|-
name|z4
expr_stmt|;
name|dataptr
operator|++
expr_stmt|;
comment|/* advance pointer to next column */
block|}
end_for
begin_endif
unit|}
endif|#
directive|endif
end_endif
begin_comment
comment|/* DCT_IFAST_SUPPORTED */
end_comment
end_unit
