begin_unit
begin_comment
comment|/*  * jidctfst.c  *  * Copyright (C) 1994-1998, Thomas G. Lane.  * This file is part of the Independent JPEG Group's software.  * For conditions of distribution and use, see the accompanying README file.  *  * This file contains a fast, not so accurate integer implementation of the  * inverse DCT (Discrete Cosine Transform).  In the IJG code, this routine  * must also perform dequantization of the input coefficients.  *  * A 2-D IDCT can be done by 1-D IDCT on each column followed by 1-D IDCT  * on each row (or vice versa, but it's more convenient to emit a row at  * a time).  Direct algorithms are also available, but they are much more  * complex and seem not to be any faster when reduced to code.  *  * This implementation is based on Arai, Agui, and Nakajima's algorithm for  * scaled DCT.  Their original paper (Trans. IEICE E-71(11):1095) is in  * Japanese, but the algorithm is described in the Pennebaker& Mitchell  * JPEG textbook (see REFERENCES section in file README).  The following code  * is based directly on figure 4-8 in P&M.  * While an 8-point DCT cannot be done in less than 11 multiplies, it is  * possible to arrange the computation so that many of the multiplies are  * simple scalings of the final outputs.  These multiplies can then be  * folded into the multiplications or divisions by the JPEG quantization  * table entries.  The AA&N method leaves only 5 multiplies and 29 adds  * to be done in the DCT itself.  * The primary disadvantage of this method is that with fixed-point math,  * accuracy is lost due to imprecise representation of the scaled  * quantization values.  The smaller the quantization table entry, the less  * precise the scaled value, so this implementation does worse with high-  * quality-setting files than with low-quality ones.  */
end_comment
begin_define
DECL|macro|JPEG_INTERNALS
define|#
directive|define
name|JPEG_INTERNALS
end_define
begin_include
include|#
directive|include
file|"jinclude.h"
end_include
begin_include
include|#
directive|include
file|"jpeglib.h"
end_include
begin_include
include|#
directive|include
file|"jdct.h"
end_include
begin_comment
comment|/* Private declarations for DCT subsystem */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|DCT_IFAST_SUPPORTED
end_ifdef
begin_comment
comment|/*  * This module is specialized to the case DCTSIZE = 8.  */
end_comment
begin_if
if|#
directive|if
name|DCTSIZE
operator|!=
literal|8
end_if
begin_expr_stmt
name|Sorry
operator|,
name|this
name|code
name|only
name|copes
name|with
literal|8x8
name|DCTs
operator|.
comment|/* deliberate syntax err */
endif|#
directive|endif
comment|/* Scaling decisions are generally the same as in the LL&M algorithm;  * see jidctint.c for more details.  However, we choose to descale  * (right shift) multiplication products as soon as they are formed,  * rather than carrying additional fractional bits into subsequent additions.  * This compromises accuracy slightly, but it lets us save a few shifts.  * More importantly, 16-bit arithmetic is then adequate (for 8-bit samples)  * everywhere except in the multiplications proper; this saves a good deal  * of work on 16-bit-int machines.  *  * The dequantized coefficients are not integers because the AA&N scaling  * factors have been incorporated.  We represent them scaled up by PASS1_BITS,  * so that the first and second IDCT rounds have the same input scaling.  * For 8-bit JSAMPLEs, we choose IFAST_SCALE_BITS = PASS1_BITS so as to  * avoid a descaling shift; this compromises accuracy rather drastically  * for small quantization table entries, but it saves a lot of shifts.  * For 12-bit JSAMPLEs, there's no hope of using 16x16 multiplies anyway,  * so we use a much larger scaling factor to preserve accuracy.  *  * A final compromise is to represent the multiplicative constants to only  * 8 fractional bits, rather than 13.  This saves some shifting work on some  * machines, and may also reduce the cost of multiplication (since there  * are fewer one-bits in the constants).  */
if|#
directive|if
name|BITS_IN_JSAMPLE
operator|==
literal|8
DECL|macro|CONST_BITS
define|#
directive|define
name|CONST_BITS
value|8
DECL|macro|PASS1_BITS
define|#
directive|define
name|PASS1_BITS
value|2
else|#
directive|else
define|#
directive|define
name|CONST_BITS
value|8
define|#
directive|define
name|PASS1_BITS
value|1
comment|/* lose a little precision to avoid overflow */
endif|#
directive|endif
comment|/* Some C compilers fail to reduce "FIX(constant)" at compile time, thus  * causing a lot of useless floating-point operations at run time.  * To get around this we use the following pre-calculated constants.  * If you change CONST_BITS you may want to add appropriate values.  * (With a reasonable C compiler, you can just rely on the FIX() macro...)  */
if|#
directive|if
name|CONST_BITS
operator|==
literal|8
DECL|macro|FIX_1_082392200
define|#
directive|define
name|FIX_1_082392200
value|((INT32)  277)
comment|/* FIX(1.082392200) */
DECL|macro|FIX_1_414213562
define|#
directive|define
name|FIX_1_414213562
value|((INT32)  362)
comment|/* FIX(1.414213562) */
DECL|macro|FIX_1_847759065
define|#
directive|define
name|FIX_1_847759065
value|((INT32)  473)
comment|/* FIX(1.847759065) */
DECL|macro|FIX_2_613125930
define|#
directive|define
name|FIX_2_613125930
value|((INT32)  669)
comment|/* FIX(2.613125930) */
else|#
directive|else
define|#
directive|define
name|FIX_1_082392200
value|FIX(1.082392200)
define|#
directive|define
name|FIX_1_414213562
value|FIX(1.414213562)
define|#
directive|define
name|FIX_1_847759065
value|FIX(1.847759065)
define|#
directive|define
name|FIX_2_613125930
value|FIX(2.613125930)
endif|#
directive|endif
comment|/* We can gain a little more speed, with a further compromise in accuracy,  * by omitting the addition in a descaling shift.  This yields an incorrectly  * rounded result half the time...  */
ifndef|#
directive|ifndef
name|USE_ACCURATE_ROUNDING
DECL|macro|DESCALE
undef|#
directive|undef
name|DESCALE
DECL|macro|DESCALE
define|#
directive|define
name|DESCALE
parameter_list|(
name|x
parameter_list|,
name|n
parameter_list|)
value|RIGHT_SHIFT(x, n)
endif|#
directive|endif
comment|/* Multiply a DCTELEM variable by an INT32 constant, and immediately  * descale to yield a DCTELEM result.  */
DECL|macro|MULTIPLY
define|#
directive|define
name|MULTIPLY
parameter_list|(
name|var
parameter_list|,
specifier|const
parameter_list|)
value|((DCTELEM) DESCALE((var) * (const), CONST_BITS))
comment|/* Dequantize a coefficient by multiplying it by the multiplier-table  * entry; produce a DCTELEM result.  For 8-bit data a 16x16->16  * multiplication will do.  For 12-bit data, the multiplier table is  * declared INT32, so a 32-bit multiply will be used.  */
if|#
directive|if
name|BITS_IN_JSAMPLE
operator|==
literal|8
DECL|macro|DEQUANTIZE
define|#
directive|define
name|DEQUANTIZE
parameter_list|(
name|coef
parameter_list|,
name|quantval
parameter_list|)
value|(((IFAST_MULT_TYPE) (coef)) * (quantval))
else|#
directive|else
define|#
directive|define
name|DEQUANTIZE
parameter_list|(
name|coef
parameter_list|,
name|quantval
parameter_list|)
define|\
value|DESCALE((coef)*(quantval), IFAST_SCALE_BITS-PASS1_BITS)
endif|#
directive|endif
comment|/* Like DESCALE, but applies to a DCTELEM and produces an int.  * We assume that int right shift is unsigned if INT32 right shift is.  */
ifdef|#
directive|ifdef
name|RIGHT_SHIFT_IS_UNSIGNED
DECL|macro|ISHIFT_TEMPS
define|#
directive|define
name|ISHIFT_TEMPS
value|DCTELEM ishift_temp;
if|#
directive|if
name|BITS_IN_JSAMPLE
operator|==
literal|8
DECL|macro|DCTELEMBITS
define|#
directive|define
name|DCTELEMBITS
value|16
comment|/* DCTELEM may be 16 or 32 bits */
else|#
directive|else
define|#
directive|define
name|DCTELEMBITS
value|32
comment|/* DCTELEM must be 32 bits */
endif|#
directive|endif
DECL|macro|IRIGHT_SHIFT
define|#
directive|define
name|IRIGHT_SHIFT
parameter_list|(
name|x
parameter_list|,
name|shft
parameter_list|)
define|\
value|((ishift_temp = (x))< 0 ? \      (ishift_temp>> (shft)) | ((~((DCTELEM) 0))<< (DCTELEMBITS-(shft))) : \      (ishift_temp>> (shft)))
else|#
directive|else
define|#
directive|define
name|ISHIFT_TEMPS
define|#
directive|define
name|IRIGHT_SHIFT
parameter_list|(
name|x
parameter_list|,
name|shft
parameter_list|)
value|((x)>> (shft))
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_ACCURATE_ROUNDING
DECL|macro|IDESCALE
define|#
directive|define
name|IDESCALE
parameter_list|(
name|x
parameter_list|,
name|n
parameter_list|)
value|((int) IRIGHT_SHIFT((x) + (1<< ((n)-1)), n))
else|#
directive|else
define|#
directive|define
name|IDESCALE
parameter_list|(
name|x
parameter_list|,
name|n
parameter_list|)
value|((int) IRIGHT_SHIFT(x, n))
endif|#
directive|endif
comment|/*  * Perform dequantization and inverse DCT on one block of coefficients.  */
name|GLOBAL
argument_list|(
argument|void
argument_list|)
DECL|function|jpeg_idct_ifast
name|jpeg_idct_ifast
argument_list|(
argument|j_decompress_ptr cinfo
argument_list|,
argument|jpeg_component_info * compptr
argument_list|,
argument|JCOEFPTR coef_block
argument_list|,
argument|JSAMPARRAY output_buf
argument_list|,
argument|JDIMENSION output_col
argument_list|)
block|{
name|DCTELEM
name|tmp0
block|,
name|tmp1
block|,
name|tmp2
block|,
name|tmp3
block|,
name|tmp4
block|,
name|tmp5
block|,
name|tmp6
block|,
name|tmp7
block|;
name|DCTELEM
name|tmp10
block|,
name|tmp11
block|,
name|tmp12
block|,
name|tmp13
block|;
name|DCTELEM
name|z5
block|,
name|z10
block|,
name|z11
block|,
name|z12
block|,
name|z13
block|;
name|JCOEFPTR
name|inptr
block|;
name|IFAST_MULT_TYPE
operator|*
name|quantptr
block|;
name|int
operator|*
name|wsptr
block|;
name|JSAMPROW
name|outptr
block|;
name|JSAMPLE
operator|*
name|range_limit
operator|=
name|IDCT_range_limit
argument_list|(
name|cinfo
argument_list|)
block|;
name|int
name|ctr
block|;
name|int
name|workspace
index|[
name|DCTSIZE2
index|]
block|;
comment|/* buffers data between passes */
name|SHIFT_TEMPS
comment|/* for DESCALE */
name|ISHIFT_TEMPS
comment|/* for IDESCALE */
comment|/* Pass 1: process columns from input, store into work array. */
name|inptr
operator|=
name|coef_block
block|;
name|quantptr
operator|=
operator|(
name|IFAST_MULT_TYPE
operator|*
operator|)
name|compptr
operator|->
name|dct_table
block|;
name|wsptr
operator|=
name|workspace
block|;
for|for
control|(
name|ctr
operator|=
name|DCTSIZE
init|;
name|ctr
operator|>
literal|0
condition|;
name|ctr
operator|--
control|)
block|{
comment|/* Due to quantization, we will usually find that many of the input      * coefficients are zero, especially the AC terms.  We can exploit this      * by short-circuiting the IDCT calculation for any column in which all      * the AC terms are zero.  In that case each output is equal to the      * DC coefficient (with scale factor as needed).      * With typical images and quantization tables, half or more of the      * column DCT calculations can be simplified this way.      */
if|if
condition|(
name|inptr
index|[
name|DCTSIZE
operator|*
literal|1
index|]
operator|==
literal|0
operator|&&
name|inptr
index|[
name|DCTSIZE
operator|*
literal|2
index|]
operator|==
literal|0
operator|&&
name|inptr
index|[
name|DCTSIZE
operator|*
literal|3
index|]
operator|==
literal|0
operator|&&
name|inptr
index|[
name|DCTSIZE
operator|*
literal|4
index|]
operator|==
literal|0
operator|&&
name|inptr
index|[
name|DCTSIZE
operator|*
literal|5
index|]
operator|==
literal|0
operator|&&
name|inptr
index|[
name|DCTSIZE
operator|*
literal|6
index|]
operator|==
literal|0
operator|&&
name|inptr
index|[
name|DCTSIZE
operator|*
literal|7
index|]
operator|==
literal|0
condition|)
block|{
comment|/* AC terms all zero */
name|int
name|dcval
init|=
operator|(
name|int
operator|)
name|DEQUANTIZE
argument_list|(
name|inptr
index|[
name|DCTSIZE
operator|*
literal|0
index|]
argument_list|,
name|quantptr
index|[
name|DCTSIZE
operator|*
literal|0
index|]
argument_list|)
decl_stmt|;
name|wsptr
index|[
name|DCTSIZE
operator|*
literal|0
index|]
operator|=
name|dcval
expr_stmt|;
name|wsptr
index|[
name|DCTSIZE
operator|*
literal|1
index|]
operator|=
name|dcval
expr_stmt|;
name|wsptr
index|[
name|DCTSIZE
operator|*
literal|2
index|]
operator|=
name|dcval
expr_stmt|;
name|wsptr
index|[
name|DCTSIZE
operator|*
literal|3
index|]
operator|=
name|dcval
expr_stmt|;
name|wsptr
index|[
name|DCTSIZE
operator|*
literal|4
index|]
operator|=
name|dcval
expr_stmt|;
name|wsptr
index|[
name|DCTSIZE
operator|*
literal|5
index|]
operator|=
name|dcval
expr_stmt|;
name|wsptr
index|[
name|DCTSIZE
operator|*
literal|6
index|]
operator|=
name|dcval
expr_stmt|;
name|wsptr
index|[
name|DCTSIZE
operator|*
literal|7
index|]
operator|=
name|dcval
expr_stmt|;
name|inptr
operator|++
expr_stmt|;
comment|/* advance pointers to next column */
name|quantptr
operator|++
expr_stmt|;
name|wsptr
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* Even part */
name|tmp0
operator|=
name|DEQUANTIZE
argument_list|(
name|inptr
index|[
name|DCTSIZE
operator|*
literal|0
index|]
argument_list|,
name|quantptr
index|[
name|DCTSIZE
operator|*
literal|0
index|]
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|tmp1
operator|=
name|DEQUANTIZE
argument_list|(
name|inptr
index|[
name|DCTSIZE
operator|*
literal|2
index|]
argument_list|,
name|quantptr
index|[
name|DCTSIZE
operator|*
literal|2
index|]
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|tmp2
operator|=
name|DEQUANTIZE
argument_list|(
name|inptr
index|[
name|DCTSIZE
operator|*
literal|4
index|]
argument_list|,
name|quantptr
index|[
name|DCTSIZE
operator|*
literal|4
index|]
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|tmp3
operator|=
name|DEQUANTIZE
argument_list|(
name|inptr
index|[
name|DCTSIZE
operator|*
literal|6
index|]
argument_list|,
name|quantptr
index|[
name|DCTSIZE
operator|*
literal|6
index|]
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|tmp10
operator|=
name|tmp0
operator|+
name|tmp2
expr_stmt|;
end_expr_stmt
begin_comment
comment|/* phase 3 */
end_comment
begin_expr_stmt
name|tmp11
operator|=
name|tmp0
operator|-
name|tmp2
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|tmp13
operator|=
name|tmp1
operator|+
name|tmp3
expr_stmt|;
end_expr_stmt
begin_comment
comment|/* phases 5-3 */
end_comment
begin_expr_stmt
name|tmp12
operator|=
name|MULTIPLY
argument_list|(
name|tmp1
operator|-
name|tmp3
argument_list|,
name|FIX_1_414213562
argument_list|)
operator|-
name|tmp13
expr_stmt|;
end_expr_stmt
begin_comment
comment|/* 2*c4 */
end_comment
begin_expr_stmt
name|tmp0
operator|=
name|tmp10
operator|+
name|tmp13
expr_stmt|;
end_expr_stmt
begin_comment
comment|/* phase 2 */
end_comment
begin_expr_stmt
name|tmp3
operator|=
name|tmp10
operator|-
name|tmp13
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|tmp1
operator|=
name|tmp11
operator|+
name|tmp12
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|tmp2
operator|=
name|tmp11
operator|-
name|tmp12
expr_stmt|;
end_expr_stmt
begin_comment
comment|/* Odd part */
end_comment
begin_expr_stmt
name|tmp4
operator|=
name|DEQUANTIZE
argument_list|(
name|inptr
index|[
name|DCTSIZE
operator|*
literal|1
index|]
argument_list|,
name|quantptr
index|[
name|DCTSIZE
operator|*
literal|1
index|]
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|tmp5
operator|=
name|DEQUANTIZE
argument_list|(
name|inptr
index|[
name|DCTSIZE
operator|*
literal|3
index|]
argument_list|,
name|quantptr
index|[
name|DCTSIZE
operator|*
literal|3
index|]
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|tmp6
operator|=
name|DEQUANTIZE
argument_list|(
name|inptr
index|[
name|DCTSIZE
operator|*
literal|5
index|]
argument_list|,
name|quantptr
index|[
name|DCTSIZE
operator|*
literal|5
index|]
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|tmp7
operator|=
name|DEQUANTIZE
argument_list|(
name|inptr
index|[
name|DCTSIZE
operator|*
literal|7
index|]
argument_list|,
name|quantptr
index|[
name|DCTSIZE
operator|*
literal|7
index|]
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|z13
operator|=
name|tmp6
operator|+
name|tmp5
expr_stmt|;
end_expr_stmt
begin_comment
comment|/* phase 6 */
end_comment
begin_expr_stmt
name|z10
operator|=
name|tmp6
operator|-
name|tmp5
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|z11
operator|=
name|tmp4
operator|+
name|tmp7
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|z12
operator|=
name|tmp4
operator|-
name|tmp7
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|tmp7
operator|=
name|z11
operator|+
name|z13
expr_stmt|;
end_expr_stmt
begin_comment
comment|/* phase 5 */
end_comment
begin_expr_stmt
name|tmp11
operator|=
name|MULTIPLY
argument_list|(
name|z11
operator|-
name|z13
argument_list|,
name|FIX_1_414213562
argument_list|)
expr_stmt|;
end_expr_stmt
begin_comment
comment|/* 2*c4 */
end_comment
begin_expr_stmt
name|z5
operator|=
name|MULTIPLY
argument_list|(
name|z10
operator|+
name|z12
argument_list|,
name|FIX_1_847759065
argument_list|)
expr_stmt|;
end_expr_stmt
begin_comment
comment|/* 2*c2 */
end_comment
begin_expr_stmt
name|tmp10
operator|=
name|MULTIPLY
argument_list|(
name|z12
argument_list|,
name|FIX_1_082392200
argument_list|)
operator|-
name|z5
expr_stmt|;
end_expr_stmt
begin_comment
comment|/* 2*(c2-c6) */
end_comment
begin_expr_stmt
name|tmp12
operator|=
name|MULTIPLY
argument_list|(
name|z10
argument_list|,
operator|-
name|FIX_2_613125930
argument_list|)
operator|+
name|z5
expr_stmt|;
end_expr_stmt
begin_comment
comment|/* -2*(c2+c6) */
end_comment
begin_expr_stmt
name|tmp6
operator|=
name|tmp12
operator|-
name|tmp7
expr_stmt|;
end_expr_stmt
begin_comment
comment|/* phase 2 */
end_comment
begin_expr_stmt
name|tmp5
operator|=
name|tmp11
operator|-
name|tmp6
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|tmp4
operator|=
name|tmp10
operator|+
name|tmp5
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|wsptr
index|[
name|DCTSIZE
operator|*
literal|0
index|]
operator|=
call|(
name|int
call|)
argument_list|(
name|tmp0
operator|+
name|tmp7
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|wsptr
index|[
name|DCTSIZE
operator|*
literal|7
index|]
operator|=
call|(
name|int
call|)
argument_list|(
name|tmp0
operator|-
name|tmp7
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|wsptr
index|[
name|DCTSIZE
operator|*
literal|1
index|]
operator|=
call|(
name|int
call|)
argument_list|(
name|tmp1
operator|+
name|tmp6
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|wsptr
index|[
name|DCTSIZE
operator|*
literal|6
index|]
operator|=
call|(
name|int
call|)
argument_list|(
name|tmp1
operator|-
name|tmp6
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|wsptr
index|[
name|DCTSIZE
operator|*
literal|2
index|]
operator|=
call|(
name|int
call|)
argument_list|(
name|tmp2
operator|+
name|tmp5
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|wsptr
index|[
name|DCTSIZE
operator|*
literal|5
index|]
operator|=
call|(
name|int
call|)
argument_list|(
name|tmp2
operator|-
name|tmp5
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|wsptr
index|[
name|DCTSIZE
operator|*
literal|4
index|]
operator|=
call|(
name|int
call|)
argument_list|(
name|tmp3
operator|+
name|tmp4
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|wsptr
index|[
name|DCTSIZE
operator|*
literal|3
index|]
operator|=
call|(
name|int
call|)
argument_list|(
name|tmp3
operator|-
name|tmp4
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|inptr
operator|++
expr_stmt|;
end_expr_stmt
begin_comment
comment|/* advance pointers to next column */
end_comment
begin_expr_stmt
name|quantptr
operator|++
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|wsptr
operator|++
expr_stmt|;
end_expr_stmt
begin_comment
unit|}
comment|/* Pass 2: process rows from work array, store into output array. */
end_comment
begin_comment
comment|/* Note that we must descale the results by a factor of 8 == 2**3, */
end_comment
begin_comment
comment|/* and also undo the PASS1_BITS scaling. */
end_comment
begin_expr_stmt
unit|wsptr
operator|=
name|workspace
expr_stmt|;
end_expr_stmt
begin_for
for|for
control|(
name|ctr
operator|=
literal|0
init|;
name|ctr
operator|<
name|DCTSIZE
condition|;
name|ctr
operator|++
control|)
block|{
name|outptr
operator|=
name|output_buf
index|[
name|ctr
index|]
operator|+
name|output_col
expr_stmt|;
comment|/* Rows of zeroes can be exploited in the same way as we did with columns.      * However, the column calculation has created many nonzero AC terms, so      * the simplification applies less often (typically 5% to 10% of the time).      * On machines with very fast multiplication, it's possible that the      * test takes more time than it's worth.  In that case this section      * may be commented out.      */
ifndef|#
directive|ifndef
name|NO_ZERO_ROW_TEST
if|if
condition|(
name|wsptr
index|[
literal|1
index|]
operator|==
literal|0
operator|&&
name|wsptr
index|[
literal|2
index|]
operator|==
literal|0
operator|&&
name|wsptr
index|[
literal|3
index|]
operator|==
literal|0
operator|&&
name|wsptr
index|[
literal|4
index|]
operator|==
literal|0
operator|&&
name|wsptr
index|[
literal|5
index|]
operator|==
literal|0
operator|&&
name|wsptr
index|[
literal|6
index|]
operator|==
literal|0
operator|&&
name|wsptr
index|[
literal|7
index|]
operator|==
literal|0
condition|)
block|{
comment|/* AC terms all zero */
name|JSAMPLE
name|dcval
init|=
name|range_limit
index|[
name|IDESCALE
argument_list|(
name|wsptr
index|[
literal|0
index|]
argument_list|,
name|PASS1_BITS
operator|+
literal|3
argument_list|)
operator|&
name|RANGE_MASK
index|]
decl_stmt|;
name|outptr
index|[
literal|0
index|]
operator|=
name|dcval
expr_stmt|;
name|outptr
index|[
literal|1
index|]
operator|=
name|dcval
expr_stmt|;
name|outptr
index|[
literal|2
index|]
operator|=
name|dcval
expr_stmt|;
name|outptr
index|[
literal|3
index|]
operator|=
name|dcval
expr_stmt|;
name|outptr
index|[
literal|4
index|]
operator|=
name|dcval
expr_stmt|;
name|outptr
index|[
literal|5
index|]
operator|=
name|dcval
expr_stmt|;
name|outptr
index|[
literal|6
index|]
operator|=
name|dcval
expr_stmt|;
name|outptr
index|[
literal|7
index|]
operator|=
name|dcval
expr_stmt|;
name|wsptr
operator|+=
name|DCTSIZE
expr_stmt|;
comment|/* advance pointer to next row */
continue|continue;
block|}
endif|#
directive|endif
comment|/* Even part */
name|tmp10
operator|=
operator|(
operator|(
name|DCTELEM
operator|)
name|wsptr
index|[
literal|0
index|]
operator|+
operator|(
name|DCTELEM
operator|)
name|wsptr
index|[
literal|4
index|]
operator|)
expr_stmt|;
name|tmp11
operator|=
operator|(
operator|(
name|DCTELEM
operator|)
name|wsptr
index|[
literal|0
index|]
operator|-
operator|(
name|DCTELEM
operator|)
name|wsptr
index|[
literal|4
index|]
operator|)
expr_stmt|;
name|tmp13
operator|=
operator|(
operator|(
name|DCTELEM
operator|)
name|wsptr
index|[
literal|2
index|]
operator|+
operator|(
name|DCTELEM
operator|)
name|wsptr
index|[
literal|6
index|]
operator|)
expr_stmt|;
name|tmp12
operator|=
name|MULTIPLY
argument_list|(
operator|(
name|DCTELEM
operator|)
name|wsptr
index|[
literal|2
index|]
operator|-
operator|(
name|DCTELEM
operator|)
name|wsptr
index|[
literal|6
index|]
argument_list|,
name|FIX_1_414213562
argument_list|)
operator|-
name|tmp13
expr_stmt|;
name|tmp0
operator|=
name|tmp10
operator|+
name|tmp13
expr_stmt|;
name|tmp3
operator|=
name|tmp10
operator|-
name|tmp13
expr_stmt|;
name|tmp1
operator|=
name|tmp11
operator|+
name|tmp12
expr_stmt|;
name|tmp2
operator|=
name|tmp11
operator|-
name|tmp12
expr_stmt|;
comment|/* Odd part */
name|z13
operator|=
operator|(
name|DCTELEM
operator|)
name|wsptr
index|[
literal|5
index|]
operator|+
operator|(
name|DCTELEM
operator|)
name|wsptr
index|[
literal|3
index|]
expr_stmt|;
name|z10
operator|=
operator|(
name|DCTELEM
operator|)
name|wsptr
index|[
literal|5
index|]
operator|-
operator|(
name|DCTELEM
operator|)
name|wsptr
index|[
literal|3
index|]
expr_stmt|;
name|z11
operator|=
operator|(
name|DCTELEM
operator|)
name|wsptr
index|[
literal|1
index|]
operator|+
operator|(
name|DCTELEM
operator|)
name|wsptr
index|[
literal|7
index|]
expr_stmt|;
name|z12
operator|=
operator|(
name|DCTELEM
operator|)
name|wsptr
index|[
literal|1
index|]
operator|-
operator|(
name|DCTELEM
operator|)
name|wsptr
index|[
literal|7
index|]
expr_stmt|;
name|tmp7
operator|=
name|z11
operator|+
name|z13
expr_stmt|;
comment|/* phase 5 */
name|tmp11
operator|=
name|MULTIPLY
argument_list|(
name|z11
operator|-
name|z13
argument_list|,
name|FIX_1_414213562
argument_list|)
expr_stmt|;
comment|/* 2*c4 */
name|z5
operator|=
name|MULTIPLY
argument_list|(
name|z10
operator|+
name|z12
argument_list|,
name|FIX_1_847759065
argument_list|)
expr_stmt|;
comment|/* 2*c2 */
name|tmp10
operator|=
name|MULTIPLY
argument_list|(
name|z12
argument_list|,
name|FIX_1_082392200
argument_list|)
operator|-
name|z5
expr_stmt|;
comment|/* 2*(c2-c6) */
name|tmp12
operator|=
name|MULTIPLY
argument_list|(
name|z10
argument_list|,
operator|-
name|FIX_2_613125930
argument_list|)
operator|+
name|z5
expr_stmt|;
comment|/* -2*(c2+c6) */
name|tmp6
operator|=
name|tmp12
operator|-
name|tmp7
expr_stmt|;
comment|/* phase 2 */
name|tmp5
operator|=
name|tmp11
operator|-
name|tmp6
expr_stmt|;
name|tmp4
operator|=
name|tmp10
operator|+
name|tmp5
expr_stmt|;
comment|/* Final output stage: scale down by a factor of 8 and range-limit */
name|outptr
index|[
literal|0
index|]
operator|=
name|range_limit
index|[
name|IDESCALE
argument_list|(
name|tmp0
operator|+
name|tmp7
argument_list|,
name|PASS1_BITS
operator|+
literal|3
argument_list|)
operator|&
name|RANGE_MASK
index|]
expr_stmt|;
name|outptr
index|[
literal|7
index|]
operator|=
name|range_limit
index|[
name|IDESCALE
argument_list|(
name|tmp0
operator|-
name|tmp7
argument_list|,
name|PASS1_BITS
operator|+
literal|3
argument_list|)
operator|&
name|RANGE_MASK
index|]
expr_stmt|;
name|outptr
index|[
literal|1
index|]
operator|=
name|range_limit
index|[
name|IDESCALE
argument_list|(
name|tmp1
operator|+
name|tmp6
argument_list|,
name|PASS1_BITS
operator|+
literal|3
argument_list|)
operator|&
name|RANGE_MASK
index|]
expr_stmt|;
name|outptr
index|[
literal|6
index|]
operator|=
name|range_limit
index|[
name|IDESCALE
argument_list|(
name|tmp1
operator|-
name|tmp6
argument_list|,
name|PASS1_BITS
operator|+
literal|3
argument_list|)
operator|&
name|RANGE_MASK
index|]
expr_stmt|;
name|outptr
index|[
literal|2
index|]
operator|=
name|range_limit
index|[
name|IDESCALE
argument_list|(
name|tmp2
operator|+
name|tmp5
argument_list|,
name|PASS1_BITS
operator|+
literal|3
argument_list|)
operator|&
name|RANGE_MASK
index|]
expr_stmt|;
name|outptr
index|[
literal|5
index|]
operator|=
name|range_limit
index|[
name|IDESCALE
argument_list|(
name|tmp2
operator|-
name|tmp5
argument_list|,
name|PASS1_BITS
operator|+
literal|3
argument_list|)
operator|&
name|RANGE_MASK
index|]
expr_stmt|;
name|outptr
index|[
literal|4
index|]
operator|=
name|range_limit
index|[
name|IDESCALE
argument_list|(
name|tmp3
operator|+
name|tmp4
argument_list|,
name|PASS1_BITS
operator|+
literal|3
argument_list|)
operator|&
name|RANGE_MASK
index|]
expr_stmt|;
name|outptr
index|[
literal|3
index|]
operator|=
name|range_limit
index|[
name|IDESCALE
argument_list|(
name|tmp3
operator|-
name|tmp4
argument_list|,
name|PASS1_BITS
operator|+
literal|3
argument_list|)
operator|&
name|RANGE_MASK
index|]
expr_stmt|;
name|wsptr
operator|+=
name|DCTSIZE
expr_stmt|;
comment|/* advance pointer to next row */
block|}
end_for
begin_endif
unit|}
endif|#
directive|endif
end_endif
begin_comment
comment|/* DCT_IFAST_SUPPORTED */
end_comment
end_unit
