begin_unit
begin_comment
comment|/*  * Copyright Â© 2009 Nokia Corporation  *  * Permission is hereby granted, free of charge, to any person obtaining a  * copy of this software and associated documentation files (the "Software"),  * to deal in the Software without restriction, including without limitation  * the rights to use, copy, modify, merge, publish, distribute, sublicense,  * and/or sell copies of the Software, and to permit persons to whom the  * Software is furnished to do so, subject to the following conditions:  *  * The above copyright notice and this permission notice (including the next  * paragraph) shall be included in all copies or substantial portions of the  * Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL  * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER  * DEALINGS IN THE SOFTWARE.  *  * Author:  Siarhei Siamashka (siarhei.siamashka@nokia.com)  */
end_comment
begin_comment
comment|/*  * This file contains a macro ('generate_composite_function') which can  * construct 2D image processing functions, based on a common template.  * Any combinations of source, destination and mask images with 8bpp,  * 16bpp, 24bpp, 32bpp color formats are supported.  *  * This macro takes care of:  *  - handling of leading and trailing unaligned pixels  *  - doing most of the work related to L2 cache preload  *  - encourages the use of software pipelining for better instructions  *    scheduling  *  * The user of this macro has to provide some configuration parameters  * (bit depths for the images, prefetch distance, etc.) and a set of  * macros, which should implement basic code chunks responsible for  * pixels processing. See 'pixman-arm-neon-asm.S' file for the usage  * examples.  *  * TODO:  *  - try overlapped pixel method (from Ian Rickards) when processing  *    exactly two blocks of pixels  *  - maybe add an option to do reverse scanline processing  */
end_comment
begin_comment
comment|/*  * Bit flags for 'generate_composite_function' macro which are used  * to tune generated functions behavior.  */
end_comment
begin_expr_stmt
operator|.
name|set
name|FLAG_DST_WRITEONLY
operator|,
literal|0
operator|.
name|set
name|FLAG_DST_READWRITE
operator|,
literal|1
operator|.
name|set
name|FLAG_DEINTERLEAVE_32BPP
operator|,
literal|2
comment|/*  * Offset in stack where mask and source pointer/stride can be accessed  * from 'init' macro. This is useful for doing special handling for solid mask.  */
operator|.
name|set
name|ARGS_STACK_OFFSET
operator|,
literal|40
comment|/*  * Constants for selecting preferable prefetch type.  */
operator|.
name|set
name|PREFETCH_TYPE_NONE
operator|,
literal|0
comment|/* No prefetch at all */
operator|.
name|set
name|PREFETCH_TYPE_SIMPLE
operator|,
literal|1
comment|/* A simple, fixed-distance-ahead prefetch */
operator|.
name|set
name|PREFETCH_TYPE_ADVANCED
operator|,
literal|2
comment|/* Advanced fine-grained prefetch */
comment|/*  * Definitions of supplementary pixld/pixst macros (for partial load/store of  * pixel data).  */
DECL|variable|elem_size
DECL|variable|reg1
DECL|variable|mem_operand
operator|.
name|macro
name|pixldst1
name|op
operator|,
name|elem_size
operator|,
name|reg1
operator|,
name|mem_operand
operator|,
name|abits
operator|.
expr|if
name|abits
operator|>
literal|0
name|op
operator|&
operator|.
operator|&
name|elem_size
block|{
name|d
operator|&
name|reg1
block|}
operator|,
index|[
operator|&
name|mem_operand
operator|&
operator|,
operator|:
operator|&
name|abits
operator|&
index|]
operator|!
operator|.
end_expr_stmt
begin_else
else|else
name|op
operator|&
operator|.
operator|&
name|elem_size
block|{
name|d
operator|&
name|reg1
block|}
operator|,
index|[
operator|&
name|mem_operand
operator|&
index|]
operator|!
operator|.
name|endif
operator|.
name|endm
DECL|variable|elem_size
DECL|variable|reg1
DECL|variable|reg2
DECL|variable|mem_operand
operator|.
name|macro
name|pixldst2
name|op
operator|,
name|elem_size
operator|,
name|reg1
operator|,
name|reg2
operator|,
name|mem_operand
operator|,
name|abits
operator|.
expr|if
name|abits
operator|>
literal|0
name|op
operator|&
operator|.
operator|&
name|elem_size
block|{
name|d
operator|&
name|reg1
block|,
name|d
operator|&
name|reg2
block|}
operator|,
index|[
operator|&
name|mem_operand
operator|&
operator|,
operator|:
operator|&
name|abits
operator|&
index|]
operator|!
operator|.
end_else
begin_else
else|else
name|op
operator|&
operator|.
operator|&
name|elem_size
block|{
name|d
operator|&
name|reg1
block|,
name|d
operator|&
name|reg2
block|}
operator|,
index|[
operator|&
name|mem_operand
operator|&
index|]
operator|!
operator|.
name|endif
operator|.
name|endm
DECL|variable|elem_size
DECL|variable|reg1
DECL|variable|reg2
DECL|variable|reg3
DECL|variable|reg4
DECL|variable|mem_operand
operator|.
name|macro
name|pixldst4
name|op
operator|,
name|elem_size
operator|,
name|reg1
operator|,
name|reg2
operator|,
name|reg3
operator|,
name|reg4
operator|,
name|mem_operand
operator|,
name|abits
operator|.
expr|if
name|abits
operator|>
literal|0
name|op
operator|&
operator|.
operator|&
name|elem_size
block|{
name|d
operator|&
name|reg1
block|,
name|d
operator|&
name|reg2
block|,
name|d
operator|&
name|reg3
block|,
name|d
operator|&
name|reg4
block|}
operator|,
index|[
operator|&
name|mem_operand
operator|&
operator|,
operator|:
operator|&
name|abits
operator|&
index|]
operator|!
operator|.
end_else
begin_else
else|else
name|op
operator|&
operator|.
operator|&
name|elem_size
block|{
name|d
operator|&
name|reg1
block|,
name|d
operator|&
name|reg2
block|,
name|d
operator|&
name|reg3
block|,
name|d
operator|&
name|reg4
block|}
operator|,
index|[
operator|&
name|mem_operand
operator|&
index|]
operator|!
operator|.
name|endif
operator|.
name|endm
DECL|variable|elem_size
DECL|variable|reg1
DECL|variable|idx
DECL|variable|mem_operand
operator|.
name|macro
name|pixldst0
name|op
operator|,
name|elem_size
operator|,
name|reg1
operator|,
name|idx
operator|,
name|mem_operand
operator|,
name|abits
name|op
operator|&
operator|.
operator|&
name|elem_size
block|{
name|d
operator|&
name|reg1
index|[
name|idx
index|]
block|}
operator|,
index|[
operator|&
name|mem_operand
operator|&
index|]
operator|!
operator|.
name|endm
DECL|variable|elem_size
DECL|variable|reg1
DECL|variable|reg2
DECL|variable|reg3
operator|.
name|macro
name|pixldst3
name|op
operator|,
name|elem_size
operator|,
name|reg1
operator|,
name|reg2
operator|,
name|reg3
operator|,
name|mem_operand
name|op
operator|&
operator|.
operator|&
name|elem_size
block|{
name|d
operator|&
name|reg1
block|,
name|d
operator|&
name|reg2
block|,
name|d
operator|&
name|reg3
block|}
operator|,
index|[
operator|&
name|mem_operand
operator|&
index|]
operator|!
operator|.
name|endm
DECL|variable|elem_size
DECL|variable|reg1
DECL|variable|reg2
DECL|variable|reg3
DECL|variable|idx
operator|.
name|macro
name|pixldst30
name|op
operator|,
name|elem_size
operator|,
name|reg1
operator|,
name|reg2
operator|,
name|reg3
operator|,
name|idx
operator|,
name|mem_operand
name|op
operator|&
operator|.
operator|&
name|elem_size
block|{
name|d
operator|&
name|reg1
index|[
name|idx
index|]
block|,
name|d
operator|&
name|reg2
index|[
name|idx
index|]
block|,
name|d
operator|&
name|reg3
index|[
name|idx
index|]
block|}
operator|,
index|[
operator|&
name|mem_operand
operator|&
index|]
operator|!
operator|.
name|endm
DECL|variable|op
DECL|variable|elem_size
DECL|variable|basereg
DECL|variable|mem_operand
operator|.
name|macro
name|pixldst
name|numbytes
operator|,
name|op
operator|,
name|elem_size
operator|,
name|basereg
operator|,
name|mem_operand
operator|,
name|abits
operator|.
expr|if
name|numbytes
operator|==
literal|32
DECL|variable|elem_size
DECL|variable|basereg
DECL|variable|basereg
name|pixldst4
name|op
operator|,
name|elem_size
operator|,
operator|%
operator|(
name|basereg
operator|+
literal|4
operator|)
operator|,
operator|%
operator|(
name|basereg
operator|+
literal|5
operator|)
operator|,
expr_stmt|\
DECL|variable|basereg
DECL|variable|basereg
DECL|variable|mem_operand
operator|%
operator|(
name|basereg
operator|+
literal|6
operator|)
operator|,
operator|%
operator|(
name|basereg
operator|+
literal|7
operator|)
operator|,
name|mem_operand
operator|,
name|abits
operator|.
name|elseif
name|numbytes
operator|==
literal|16
DECL|variable|elem_size
DECL|variable|basereg
DECL|variable|basereg
DECL|variable|mem_operand
name|pixldst2
name|op
operator|,
name|elem_size
operator|,
operator|%
operator|(
name|basereg
operator|+
literal|2
operator|)
operator|,
operator|%
operator|(
name|basereg
operator|+
literal|3
operator|)
operator|,
name|mem_operand
operator|,
name|abits
operator|.
name|elseif
name|numbytes
operator|==
literal|8
DECL|variable|elem_size
DECL|variable|basereg
DECL|variable|mem_operand
name|pixldst1
name|op
operator|,
name|elem_size
operator|,
operator|%
operator|(
name|basereg
operator|+
literal|1
operator|)
operator|,
name|mem_operand
operator|,
name|abits
operator|.
name|elseif
name|numbytes
operator|==
literal|4
operator|.
end_else
begin_if
if|if !RESPECT_STRICT_ALIGNMENT ||
condition|(
name|elem_size
operator|==
literal|32
condition|)
DECL|variable|op
DECL|variable|basereg
DECL|variable|mem_operand
name|pixldst0
name|op
decl_stmt|, 32, %
argument_list|(
name|basereg
operator|+
literal|0
argument_list|)
decl_stmt|, 1,
name|mem_operand
decl_stmt|,
name|abits
operator|.
name|elseif
name|elem_size
decl|== 16
DECL|variable|basereg
DECL|variable|mem_operand
name|pixldst0
name|op
decl_stmt|, 16, %
argument_list|(
name|basereg
operator|+
literal|0
argument_list|)
decl_stmt|, 2,
name|mem_operand
decl_stmt|,
name|abits
DECL|variable|op
DECL|variable|basereg
DECL|variable|mem_operand
name|pixldst0
name|op
decl_stmt|, 16, %
argument_list|(
name|basereg
operator|+
literal|0
argument_list|)
decl_stmt|, 3,
name|mem_operand
decl_stmt|,
name|abits
operator|.
decl|else
DECL|variable|basereg
DECL|variable|mem_operand
name|pixldst0
name|op
decl_stmt|, 8, %
argument_list|(
name|basereg
operator|+
literal|0
argument_list|)
decl_stmt|, 4,
name|mem_operand
decl_stmt|,
name|abits
DECL|variable|op
DECL|variable|basereg
DECL|variable|mem_operand
name|pixldst0
name|op
decl_stmt|, 8, %
argument_list|(
name|basereg
operator|+
literal|0
argument_list|)
decl_stmt|, 5,
name|mem_operand
decl_stmt|,
name|abits
DECL|variable|op
DECL|variable|basereg
DECL|variable|mem_operand
name|pixldst0
name|op
decl_stmt|, 8, %
argument_list|(
name|basereg
operator|+
literal|0
argument_list|)
decl_stmt|, 6,
name|mem_operand
decl_stmt|,
name|abits
DECL|variable|op
DECL|variable|basereg
DECL|variable|mem_operand
name|pixldst0
name|op
decl_stmt|, 8, %
argument_list|(
name|basereg
operator|+
literal|0
argument_list|)
decl_stmt|, 7,
name|mem_operand
decl_stmt|,
name|abits
operator|.
name|endif
operator|.
name|elseif
name|numbytes
decl|== 2     .if !
name|RESPECT_STRICT_ALIGNMENT
decl|||
argument_list|(
name|elem_size
operator|==
literal|16
argument_list|)
DECL|variable|op
DECL|variable|basereg
DECL|variable|mem_operand
name|pixldst0
name|op
decl_stmt|, 16, %
argument_list|(
name|basereg
operator|+
literal|0
argument_list|)
decl_stmt|, 1,
name|mem_operand
decl_stmt|,
name|abits
operator|.
decl|else
DECL|variable|basereg
DECL|variable|mem_operand
name|pixldst0
name|op
decl_stmt|, 8, %
argument_list|(
name|basereg
operator|+
literal|0
argument_list|)
decl_stmt|, 2,
name|mem_operand
decl_stmt|,
name|abits
DECL|variable|op
DECL|variable|basereg
DECL|variable|mem_operand
name|pixldst0
name|op
decl_stmt|, 8, %
argument_list|(
name|basereg
operator|+
literal|0
argument_list|)
decl_stmt|, 3,
name|mem_operand
decl_stmt|,
name|abits
operator|.
name|endif
operator|.
name|elseif
name|numbytes
decl|== 1
DECL|variable|basereg
DECL|variable|mem_operand
name|pixldst0
name|op
decl_stmt|, 8, %
argument_list|(
name|basereg
operator|+
literal|0
argument_list|)
decl_stmt|, 1,
name|mem_operand
decl_stmt|,
name|abits
operator|.
decl|else     .
name|error
decl|"unsupported size: numbytes" .
name|endif
operator|.
name|endm
DECL|variable|bpp
DECL|variable|basereg
DECL|variable|mem_operand
DECL|variable|abits
operator|.
name|macro
name|pixld
name|numpix
decl_stmt|,
name|bpp
decl_stmt|,
name|basereg
decl_stmt|,
name|mem_operand
decl_stmt|,
name|abits
init|=
literal|0
operator|.
end_if
begin_if
if|if bpp> 0 .if
condition|(
name|bpp
operator|==
literal|32
condition|)
operator|&&
operator|(
name|numpix
operator|==
literal|8
operator|)
operator|&&
operator|(
name|DEINTERLEAVE_32BPP_ENABLED
operator|!=
literal|0
operator|)
DECL|variable|basereg
DECL|variable|basereg
name|pixldst4
name|vld4
operator|,
literal|8
operator|,
operator|%
operator|(
name|basereg
operator|+
literal|4
operator|)
operator|,
operator|%
operator|(
name|basereg
operator|+
literal|5
operator|)
operator|,
expr_stmt|\
DECL|variable|basereg
DECL|variable|basereg
DECL|variable|mem_operand
operator|%
operator|(
name|basereg
operator|+
literal|6
operator|)
operator|,
operator|%
operator|(
name|basereg
operator|+
literal|7
operator|)
operator|,
name|mem_operand
operator|,
name|abits
operator|.
name|elseif
argument_list|(
name|bpp
operator|==
literal|24
argument_list|)
operator|&&
operator|(
name|numpix
operator|==
literal|8
operator|)
DECL|variable|vld3
DECL|variable|basereg
DECL|variable|basereg
DECL|variable|basereg
name|pixldst3
name|vld3
operator|,
literal|8
operator|,
operator|%
operator|(
name|basereg
operator|+
literal|3
operator|)
operator|,
operator|%
operator|(
name|basereg
operator|+
literal|4
operator|)
operator|,
operator|%
operator|(
name|basereg
operator|+
literal|5
operator|)
operator|,
name|mem_operand
operator|.
name|elseif
argument_list|(
name|bpp
operator|==
literal|24
argument_list|)
operator|&&
operator|(
name|numpix
operator|==
literal|4
operator|)
DECL|variable|vld3
DECL|variable|basereg
DECL|variable|basereg
DECL|variable|basereg
name|pixldst30
name|vld3
operator|,
literal|8
operator|,
operator|%
operator|(
name|basereg
operator|+
literal|0
operator|)
operator|,
operator|%
operator|(
name|basereg
operator|+
literal|1
operator|)
operator|,
operator|%
operator|(
name|basereg
operator|+
literal|2
operator|)
operator|,
literal|4
operator|,
name|mem_operand
DECL|variable|vld3
DECL|variable|basereg
DECL|variable|basereg
DECL|variable|basereg
name|pixldst30
name|vld3
operator|,
literal|8
operator|,
operator|%
operator|(
name|basereg
operator|+
literal|0
operator|)
operator|,
operator|%
operator|(
name|basereg
operator|+
literal|1
operator|)
operator|,
operator|%
operator|(
name|basereg
operator|+
literal|2
operator|)
operator|,
literal|5
operator|,
name|mem_operand
DECL|variable|vld3
DECL|variable|basereg
DECL|variable|basereg
DECL|variable|basereg
name|pixldst30
name|vld3
operator|,
literal|8
operator|,
operator|%
operator|(
name|basereg
operator|+
literal|0
operator|)
operator|,
operator|%
operator|(
name|basereg
operator|+
literal|1
operator|)
operator|,
operator|%
operator|(
name|basereg
operator|+
literal|2
operator|)
operator|,
literal|6
operator|,
name|mem_operand
DECL|variable|vld3
DECL|variable|basereg
DECL|variable|basereg
DECL|variable|basereg
name|pixldst30
name|vld3
operator|,
literal|8
operator|,
operator|%
operator|(
name|basereg
operator|+
literal|0
operator|)
operator|,
operator|%
operator|(
name|basereg
operator|+
literal|1
operator|)
operator|,
operator|%
operator|(
name|basereg
operator|+
literal|2
operator|)
operator|,
literal|7
operator|,
name|mem_operand
operator|.
name|elseif
argument_list|(
name|bpp
operator|==
literal|24
argument_list|)
operator|&&
operator|(
name|numpix
operator|==
literal|2
operator|)
DECL|variable|vld3
DECL|variable|basereg
DECL|variable|basereg
DECL|variable|basereg
name|pixldst30
name|vld3
operator|,
literal|8
operator|,
operator|%
operator|(
name|basereg
operator|+
literal|0
operator|)
operator|,
operator|%
operator|(
name|basereg
operator|+
literal|1
operator|)
operator|,
operator|%
operator|(
name|basereg
operator|+
literal|2
operator|)
operator|,
literal|2
operator|,
name|mem_operand
DECL|variable|vld3
DECL|variable|basereg
DECL|variable|basereg
DECL|variable|basereg
name|pixldst30
name|vld3
operator|,
literal|8
operator|,
operator|%
operator|(
name|basereg
operator|+
literal|0
operator|)
operator|,
operator|%
operator|(
name|basereg
operator|+
literal|1
operator|)
operator|,
operator|%
operator|(
name|basereg
operator|+
literal|2
operator|)
operator|,
literal|3
operator|,
name|mem_operand
operator|.
name|elseif
argument_list|(
name|bpp
operator|==
literal|24
argument_list|)
operator|&&
operator|(
name|numpix
operator|==
literal|1
operator|)
DECL|variable|vld3
DECL|variable|basereg
DECL|variable|basereg
DECL|variable|basereg
name|pixldst30
name|vld3
operator|,
literal|8
operator|,
operator|%
operator|(
name|basereg
operator|+
literal|0
operator|)
operator|,
operator|%
operator|(
name|basereg
operator|+
literal|1
operator|)
operator|,
operator|%
operator|(
name|basereg
operator|+
literal|2
operator|)
operator|,
literal|1
operator|,
name|mem_operand
operator|.
expr|else
name|pixldst
operator|%
operator|(
name|numpix
operator|*
name|bpp
operator|/
literal|8
operator|)
operator|,
name|vld1
operator|,
operator|%
operator|(
name|bpp
operator|)
operator|,
name|basereg
operator|,
name|mem_operand
operator|,
name|abits
operator|.
name|endif
operator|.
name|endif
operator|.
name|endm
DECL|variable|bpp
DECL|variable|basereg
DECL|variable|mem_operand
DECL|variable|abits
operator|.
name|macro
name|pixst
name|numpix
operator|,
name|bpp
operator|,
name|basereg
operator|,
name|mem_operand
operator|,
name|abits
operator|=
literal|0
operator|.
end_if
begin_if
if|if bpp> 0 .if
condition|(
name|bpp
operator|==
literal|32
condition|)
operator|&&
operator|(
name|numpix
operator|==
literal|8
operator|)
operator|&&
operator|(
name|DEINTERLEAVE_32BPP_ENABLED
operator|!=
literal|0
operator|)
DECL|variable|basereg
DECL|variable|basereg
name|pixldst4
name|vst4
operator|,
literal|8
operator|,
operator|%
operator|(
name|basereg
operator|+
literal|4
operator|)
operator|,
operator|%
operator|(
name|basereg
operator|+
literal|5
operator|)
operator|,
expr_stmt|\
DECL|variable|basereg
DECL|variable|basereg
DECL|variable|mem_operand
operator|%
operator|(
name|basereg
operator|+
literal|6
operator|)
operator|,
operator|%
operator|(
name|basereg
operator|+
literal|7
operator|)
operator|,
name|mem_operand
operator|,
name|abits
operator|.
name|elseif
argument_list|(
name|bpp
operator|==
literal|24
argument_list|)
operator|&&
operator|(
name|numpix
operator|==
literal|8
operator|)
DECL|variable|vst3
DECL|variable|basereg
DECL|variable|basereg
DECL|variable|basereg
name|pixldst3
name|vst3
operator|,
literal|8
operator|,
operator|%
operator|(
name|basereg
operator|+
literal|3
operator|)
operator|,
operator|%
operator|(
name|basereg
operator|+
literal|4
operator|)
operator|,
operator|%
operator|(
name|basereg
operator|+
literal|5
operator|)
operator|,
name|mem_operand
operator|.
name|elseif
argument_list|(
name|bpp
operator|==
literal|24
argument_list|)
operator|&&
operator|(
name|numpix
operator|==
literal|4
operator|)
DECL|variable|vst3
DECL|variable|basereg
DECL|variable|basereg
DECL|variable|basereg
name|pixldst30
name|vst3
operator|,
literal|8
operator|,
operator|%
operator|(
name|basereg
operator|+
literal|0
operator|)
operator|,
operator|%
operator|(
name|basereg
operator|+
literal|1
operator|)
operator|,
operator|%
operator|(
name|basereg
operator|+
literal|2
operator|)
operator|,
literal|4
operator|,
name|mem_operand
DECL|variable|vst3
DECL|variable|basereg
DECL|variable|basereg
DECL|variable|basereg
name|pixldst30
name|vst3
operator|,
literal|8
operator|,
operator|%
operator|(
name|basereg
operator|+
literal|0
operator|)
operator|,
operator|%
operator|(
name|basereg
operator|+
literal|1
operator|)
operator|,
operator|%
operator|(
name|basereg
operator|+
literal|2
operator|)
operator|,
literal|5
operator|,
name|mem_operand
DECL|variable|vst3
DECL|variable|basereg
DECL|variable|basereg
DECL|variable|basereg
name|pixldst30
name|vst3
operator|,
literal|8
operator|,
operator|%
operator|(
name|basereg
operator|+
literal|0
operator|)
operator|,
operator|%
operator|(
name|basereg
operator|+
literal|1
operator|)
operator|,
operator|%
operator|(
name|basereg
operator|+
literal|2
operator|)
operator|,
literal|6
operator|,
name|mem_operand
DECL|variable|vst3
DECL|variable|basereg
DECL|variable|basereg
DECL|variable|basereg
name|pixldst30
name|vst3
operator|,
literal|8
operator|,
operator|%
operator|(
name|basereg
operator|+
literal|0
operator|)
operator|,
operator|%
operator|(
name|basereg
operator|+
literal|1
operator|)
operator|,
operator|%
operator|(
name|basereg
operator|+
literal|2
operator|)
operator|,
literal|7
operator|,
name|mem_operand
operator|.
name|elseif
argument_list|(
name|bpp
operator|==
literal|24
argument_list|)
operator|&&
operator|(
name|numpix
operator|==
literal|2
operator|)
DECL|variable|vst3
DECL|variable|basereg
DECL|variable|basereg
DECL|variable|basereg
name|pixldst30
name|vst3
operator|,
literal|8
operator|,
operator|%
operator|(
name|basereg
operator|+
literal|0
operator|)
operator|,
operator|%
operator|(
name|basereg
operator|+
literal|1
operator|)
operator|,
operator|%
operator|(
name|basereg
operator|+
literal|2
operator|)
operator|,
literal|2
operator|,
name|mem_operand
DECL|variable|vst3
DECL|variable|basereg
DECL|variable|basereg
DECL|variable|basereg
name|pixldst30
name|vst3
operator|,
literal|8
operator|,
operator|%
operator|(
name|basereg
operator|+
literal|0
operator|)
operator|,
operator|%
operator|(
name|basereg
operator|+
literal|1
operator|)
operator|,
operator|%
operator|(
name|basereg
operator|+
literal|2
operator|)
operator|,
literal|3
operator|,
name|mem_operand
operator|.
name|elseif
argument_list|(
name|bpp
operator|==
literal|24
argument_list|)
operator|&&
operator|(
name|numpix
operator|==
literal|1
operator|)
DECL|variable|vst3
DECL|variable|basereg
DECL|variable|basereg
DECL|variable|basereg
name|pixldst30
name|vst3
operator|,
literal|8
operator|,
operator|%
operator|(
name|basereg
operator|+
literal|0
operator|)
operator|,
operator|%
operator|(
name|basereg
operator|+
literal|1
operator|)
operator|,
operator|%
operator|(
name|basereg
operator|+
literal|2
operator|)
operator|,
literal|1
operator|,
name|mem_operand
operator|.
expr|else
name|pixldst
operator|%
operator|(
name|numpix
operator|*
name|bpp
operator|/
literal|8
operator|)
operator|,
name|vst1
operator|,
operator|%
operator|(
name|bpp
operator|)
operator|,
name|basereg
operator|,
name|mem_operand
operator|,
name|abits
operator|.
name|endif
operator|.
name|endif
operator|.
name|endm
DECL|variable|bpp
DECL|variable|basereg
operator|.
name|macro
name|pixld_a
name|numpix
operator|,
name|bpp
operator|,
name|basereg
operator|,
name|mem_operand
operator|.
expr|if
operator|(
name|bpp
operator|*
name|numpix
operator|)
operator|<=
literal|128
DECL|variable|bpp
DECL|variable|basereg
DECL|variable|mem_operand
name|pixld
name|numpix
operator|,
name|bpp
operator|,
name|basereg
operator|,
name|mem_operand
operator|,
operator|%
operator|(
name|bpp
operator|*
name|numpix
operator|)
operator|.
else|else
DECL|variable|bpp
DECL|variable|basereg
DECL|variable|mem_operand
name|pixld
name|numpix
decl_stmt|,
name|bpp
decl_stmt|,
name|basereg
decl_stmt|,
name|mem_operand
decl_stmt|, 128 .
name|endif
operator|.
name|endm
DECL|variable|bpp
DECL|variable|basereg
operator|.
name|macro
name|pixst_a
name|numpix
decl_stmt|,
name|bpp
decl_stmt|,
name|basereg
decl_stmt|,
name|mem_operand
operator|.
decl|if
argument_list|(
name|bpp
operator|*
name|numpix
argument_list|)
decl|<= 128
DECL|variable|bpp
DECL|variable|basereg
DECL|variable|mem_operand
name|pixst
name|numpix
decl_stmt|,
name|bpp
decl_stmt|,
name|basereg
decl_stmt|,
name|mem_operand
decl_stmt|, %
argument_list|(
name|bpp
operator|*
name|numpix
argument_list|)
decl_stmt|.else
DECL|variable|bpp
DECL|variable|basereg
DECL|variable|mem_operand
name|pixst
name|numpix
decl_stmt|,
name|bpp
decl_stmt|,
name|basereg
decl_stmt|,
name|mem_operand
decl_stmt|, 128 .
name|endif
operator|.
name|endm
operator|.
name|macro
name|vuzp8
name|reg1
decl_stmt|,
name|reg2
name|vuzp
decl|.8
name|d
modifier|&
name|reg1
decl_stmt|,
name|d
modifier|&
name|reg2
operator|.
name|endm
operator|.
name|macro
name|vzip8
name|reg1
decl_stmt|,
name|reg2
name|vzip
decl|.8
name|d
modifier|&
name|reg1
decl_stmt|,
name|d
modifier|&
name|reg2
operator|.
name|endm
comment|/* deinterleave B, G, R, A channels for eight 32bpp pixels in 4 registers */
operator|.
name|macro
name|pixdeinterleave
name|bpp
decl_stmt|,
name|basereg
operator|.
decl|if
argument_list|(
name|bpp
operator|==
literal|32
argument_list|)
decl|&&
argument_list|(
name|DEINTERLEAVE_32BPP_ENABLED
operator|!=
literal|0
argument_list|)
name|vuzp8
decl|%
argument_list|(
name|basereg
operator|+
literal|0
argument_list|)
decl_stmt|, %
argument_list|(
name|basereg
operator|+
literal|1
argument_list|)
name|vuzp8
decl|%
argument_list|(
name|basereg
operator|+
literal|2
argument_list|)
decl_stmt|, %
argument_list|(
name|basereg
operator|+
literal|3
argument_list|)
name|vuzp8
decl|%
argument_list|(
name|basereg
operator|+
literal|1
argument_list|)
decl_stmt|, %
argument_list|(
name|basereg
operator|+
literal|3
argument_list|)
name|vuzp8
decl|%
argument_list|(
name|basereg
operator|+
literal|0
argument_list|)
decl_stmt|, %
argument_list|(
name|basereg
operator|+
literal|2
argument_list|)
decl_stmt|.
name|endif
operator|.
name|endm
comment|/* interleave B, G, R, A channels for eight 32bpp pixels in 4 registers */
operator|.
name|macro
name|pixinterleave
name|bpp
decl_stmt|,
name|basereg
operator|.
decl|if
argument_list|(
name|bpp
operator|==
literal|32
argument_list|)
decl|&&
argument_list|(
name|DEINTERLEAVE_32BPP_ENABLED
operator|!=
literal|0
argument_list|)
name|vzip8
decl|%
argument_list|(
name|basereg
operator|+
literal|0
argument_list|)
decl_stmt|, %
argument_list|(
name|basereg
operator|+
literal|2
argument_list|)
name|vzip8
decl|%
argument_list|(
name|basereg
operator|+
literal|1
argument_list|)
decl_stmt|, %
argument_list|(
name|basereg
operator|+
literal|3
argument_list|)
name|vzip8
decl|%
argument_list|(
name|basereg
operator|+
literal|2
argument_list|)
decl_stmt|, %
argument_list|(
name|basereg
operator|+
literal|3
argument_list|)
name|vzip8
decl|%
argument_list|(
name|basereg
operator|+
literal|0
argument_list|)
decl_stmt|, %
argument_list|(
name|basereg
operator|+
literal|1
argument_list|)
decl_stmt|.
name|endif
operator|.
name|endm
comment|/*  * This is a macro for implementing cache preload. The main idea is that  * cache preload logic is mostly independent from the rest of pixels  * processing code. It starts at the top left pixel and moves forward  * across pixels and can jump across scanlines. Prefetch distance is  * handled in an 'incremental' way: it starts from 0 and advances to the  * optimal distance over time. After reaching optimal prefetch distance,  * it is kept constant. There are some checks which prevent prefetching  * unneeded pixel lines below the image (but it still can prefetch a bit  * more data on the right side of the image - not a big issue and may  * be actually helpful when rendering text glyphs). Additional trick is  * the use of LDR instruction for prefetch instead of PLD when moving to  * the next line, the point is that we have a high chance of getting TLB  * miss in this case, and PLD would be useless.  *  * This sounds like it may introduce a noticeable overhead (when working with  * fully cached data). But in reality, due to having a separate pipeline and  * instruction queue for NEON unit in ARM Cortex-A8, normal ARM code can  * execute simultaneously with NEON and be completely shadowed by it. Thus  * we get no performance overhead at all (*). This looks like a very nice  * feature of Cortex-A8, if used wisely. We don't have a hardware prefetcher,  * but still can implement some rather advanced prefetch logic in sofware  * for almost zero cost!  *  * (*) The overhead of the prefetcher is visible when running some trivial  * pixels processing like simple copy. Anyway, having prefetch is a must  * when working with the graphics data.  */
operator|.
name|macro
name|PF
name|a
decl_stmt|,
name|x
range|:
name|vararg
operator|.
expr|if
operator|(
name|PREFETCH_TYPE_CURRENT
operator|==
name|PREFETCH_TYPE_ADVANCED
operator|)
name|a
name|x
operator|.
name|endif
operator|.
name|endm
operator|.
name|macro
name|cache_preload
name|std_increment
decl_stmt|,
name|boost_increment
operator|.
decl|if
argument_list|(
name|src_bpp_shift
operator|>=
literal|0
argument_list|)
decl|||
argument_list|(
name|dst_r_bpp
operator|!=
literal|0
argument_list|)
decl|||
argument_list|(
name|mask_bpp_shift
operator|>=
literal|0
argument_list|)
decl|.if
name|regs_shortage
name|PF
name|ldr
name|ORIG_W
decl_stmt|, [
name|sp
decl|]
comment|/* If we are short on regs, ORIG_W is kept on stack */
decl|.
name|endif
operator|.
decl|if
name|std_increment
decl|!= 0
DECL|variable|PF_X
name|PF
name|add
name|PF_X
decl_stmt|,
name|PF_X
decl_stmt|, #
name|std_increment
operator|.
name|endif
name|PF
name|tst
name|PF_CTL
decl_stmt|, #0xF
DECL|variable|PF_X
DECL|variable|PF_X
name|PF
name|addne
name|PF_X
decl_stmt|,
name|PF_X
decl_stmt|, #
name|boost_increment
DECL|variable|PF_CTL
DECL|variable|PF_CTL
name|PF
name|subne
name|PF_CTL
decl_stmt|,
name|PF_CTL
decl_stmt|, #1
DECL|variable|PF_X
name|PF
name|cmp
name|PF_X
decl_stmt|,
name|ORIG_W
operator|.
decl|if
name|src_bpp_shift
decl|>= 0
name|PF
name|pld
decl_stmt|, [
name|PF_SRC
decl_stmt|,
name|PF_X
decl_stmt|,
name|lsl
decl|#
name|src_bpp_shift
decl|] .
name|endif
operator|.
decl|if
name|dst_r_bpp
decl|!= 0
name|PF
name|pld
decl_stmt|, [
name|PF_DST
decl_stmt|,
name|PF_X
decl_stmt|,
name|lsl
decl|#
name|dst_bpp_shift
decl|] .
name|endif
operator|.
decl|if
name|mask_bpp_shift
decl|>= 0
name|PF
name|pld
decl_stmt|, [
name|PF_MASK
decl_stmt|,
name|PF_X
decl_stmt|,
name|lsl
decl|#
name|mask_bpp_shift
decl|] .
name|endif
DECL|variable|PF_X
name|PF
name|subge
name|PF_X
decl_stmt|,
name|PF_X
decl_stmt|,
name|ORIG_W
DECL|variable|PF_CTL
DECL|variable|PF_CTL
name|PF
name|subges
name|PF_CTL
decl_stmt|,
name|PF_CTL
decl_stmt|, #0x10 .if
name|src_bpp_shift
decl|>= 0
name|PF
name|ldrgeb
name|DUMMY
decl_stmt|, [
name|PF_SRC
decl_stmt|,
name|SRC_STRIDE
decl_stmt|,
name|lsl
decl|#
name|src_bpp_shift
decl|]! .
name|endif
operator|.
decl|if
name|dst_r_bpp
decl|!= 0
name|PF
name|ldrgeb
name|DUMMY
decl_stmt|, [
name|PF_DST
decl_stmt|,
name|DST_STRIDE
decl_stmt|,
name|lsl
decl|#
name|dst_bpp_shift
decl|]! .
name|endif
operator|.
decl|if
name|mask_bpp_shift
decl|>= 0
name|PF
name|ldrgeb
name|DUMMY
decl_stmt|, [
name|PF_MASK
decl_stmt|,
name|MASK_STRIDE
decl_stmt|,
name|lsl
decl|#
name|mask_bpp_shift
decl|]! .
name|endif
operator|.
name|endif
operator|.
name|endm
operator|.
name|macro
name|cache_preload_simple
operator|.
decl|if
argument_list|(
name|PREFETCH_TYPE_CURRENT
operator|==
name|PREFETCH_TYPE_SIMPLE
argument_list|)
decl|.if
name|src_bpp
decl|> 0
name|pld
index|[
name|SRC
operator|,
operator|#
operator|(
name|PREFETCH_DISTANCE_SIMPLE
operator|*
name|src_bpp
operator|/
literal|8
operator|)
index|]
decl|.
name|endif
operator|.
decl|if
name|dst_r_bpp
decl|> 0
name|pld
index|[
name|DST_R
operator|,
operator|#
operator|(
name|PREFETCH_DISTANCE_SIMPLE
operator|*
name|dst_r_bpp
operator|/
literal|8
operator|)
index|]
decl|.
name|endif
operator|.
decl|if
name|mask_bpp
decl|> 0
name|pld
index|[
name|MASK
operator|,
operator|#
operator|(
name|PREFETCH_DISTANCE_SIMPLE
operator|*
name|mask_bpp
operator|/
literal|8
operator|)
index|]
decl|.
name|endif
operator|.
name|endif
operator|.
name|endm
comment|/*  * Macro which is used to process leading pixels until destination  * pointer is properly aligned (at 16 bytes boundary). When destination  * buffer uses 16bpp format, this is unnecessary, or even pointless.  */
operator|.
name|macro
name|ensure_destination_ptr_alignment
name|process_pixblock_head
decl_stmt|, \
DECL|variable|process_pixblock_tail
name|process_pixblock_tail
decl_stmt|, \
name|process_pixblock_tail_head
operator|.
decl|if
name|dst_w_bpp
decl|!= 24
name|tst
name|DST_R
decl_stmt|, #0xF
name|beq
decl|2f  .
name|irp
name|lowbit
decl_stmt|, 1, 2, 4, 8, 16
name|local
name|skip1
operator|.
decl|if
argument_list|(
name|dst_w_bpp
operator|<=
operator|(
name|lowbit
operator|*
literal|8
operator|)
argument_list|)
decl|&&
argument_list|(
operator|(
name|lowbit
operator|*
literal|8
operator|)
operator|<
operator|(
name|pixblock_size
operator|*
name|dst_w_bpp
operator|)
argument_list|)
decl|.if
name|lowbit
decl|< 16
comment|/* we don't need more than 16-byte alignment */
DECL|variable|DST_R
name|tst
name|DST_R
decl_stmt|, #
name|lowbit
name|beq
decl|1f .
name|endif
name|pixld
argument_list|(
name|lowbit
operator|*
literal|8
operator|/
name|dst_w_bpp
argument_list|)
decl_stmt|,
name|src_bpp
decl_stmt|,
name|src_basereg
decl_stmt|,
name|SRC
name|pixld
argument_list|(
name|lowbit
operator|*
literal|8
operator|/
name|dst_w_bpp
argument_list|)
decl_stmt|,
name|mask_bpp
decl_stmt|,
name|mask_basereg
decl_stmt|,
name|MASK
operator|.
decl|if
name|dst_r_bpp
decl|> 0
name|pixld_a
argument_list|(
name|lowbit
operator|*
literal|8
operator|/
name|dst_r_bpp
argument_list|)
decl_stmt|,
name|dst_r_bpp
decl_stmt|,
name|dst_r_basereg
decl_stmt|,
name|DST_R
operator|.
decl|else
DECL|variable|DST_R
name|add
name|DST_R
decl_stmt|,
name|DST_R
decl_stmt|, #
name|lowbit
operator|.
name|endif
DECL|variable|PF_X
name|PF
name|add
name|PF_X
decl_stmt|,
name|PF_X
decl_stmt|, #
argument_list|(
name|lowbit
operator|*
literal|8
operator|/
name|dst_w_bpp
argument_list|)
DECL|variable|W
DECL|variable|W
name|sub
name|W
decl_stmt|,
name|W
decl_stmt|, #
argument_list|(
name|lowbit
operator|*
literal|8
operator|/
name|dst_w_bpp
argument_list|)
decl_stmt|1
range|:
operator|.
name|endif
operator|.
name|endr
name|pixdeinterleave
name|src_bpp
decl_stmt|,
name|src_basereg
DECL|variable|mask_bpp
name|pixdeinterleave
name|mask_bpp
decl_stmt|,
name|mask_basereg
DECL|variable|dst_r_bpp
name|pixdeinterleave
name|dst_r_bpp
decl_stmt|,
name|dst_r_basereg
name|process_pixblock_head
DECL|variable|cache_preload
name|cache_preload
decl|0
decl_stmt|,
name|pixblock_size
name|cache_preload_simple
name|process_pixblock_tail
DECL|variable|dst_w_bpp
name|pixinterleave
name|dst_w_bpp
decl_stmt|,
name|dst_w_basereg
operator|.
name|irp
name|lowbit
decl_stmt|, 1, 2, 4, 8, 16 .if
argument_list|(
name|dst_w_bpp
operator|<=
operator|(
name|lowbit
operator|*
literal|8
operator|)
argument_list|)
decl_stmt|&&
argument_list|(
operator|(
name|lowbit
operator|*
literal|8
operator|)
operator|<
operator|(
name|pixblock_size
operator|*
name|dst_w_bpp
operator|)
argument_list|)
decl_stmt|.if
name|lowbit
decl|< 16
comment|/* we don't need more than 16-byte alignment */
DECL|variable|DST_W
name|tst
name|DST_W
decl_stmt|, #
name|lowbit
name|beq
decl|1f .
name|endif
name|pixst_a
argument_list|(
name|lowbit
operator|*
literal|8
operator|/
name|dst_w_bpp
argument_list|)
decl_stmt|,
name|dst_w_bpp
decl_stmt|,
name|dst_w_basereg
decl_stmt|,
name|DST_W
decl|1
range|:
operator|.
name|endif
operator|.
name|endr
operator|.
name|endif
literal|2
operator|:
operator|.
name|endm
comment|/*  * Special code for processing up to (pixblock_size - 1) remaining  * trailing pixels. As SIMD processing performs operation on  * pixblock_size pixels, anything smaller than this has to be loaded  * and stored in a special way. Loading and storing of pixel data is  * performed in such a way that we fill some 'slots' in the NEON  * registers (some slots naturally are unused), then perform compositing  * operation as usual. In the end, the data is taken from these 'slots'  * and saved to memory.  *  * cache_preload_flag - allows to suppress prefetch if  *                      set to 0  * dst_aligned_flag   - selects whether destination buffer  *                      is aligned  */
operator|.
name|macro
name|process_trailing_pixels
name|cache_preload_flag
decl_stmt|, \
DECL|variable|dst_aligned_flag
name|dst_aligned_flag
decl_stmt|, \
DECL|variable|process_pixblock_head
name|process_pixblock_head
decl_stmt|, \
DECL|variable|process_pixblock_tail
name|process_pixblock_tail
decl_stmt|, \
name|process_pixblock_tail_head
DECL|variable|W
name|tst
name|W
decl_stmt|, #
argument_list|(
name|pixblock_size
operator|-
literal|1
argument_list|)
name|beq
decl|2f .
name|irp
name|chunk_size
decl_stmt|, 16, 8, 4, 2, 1 .if
name|pixblock_size
decl|>
name|chunk_size
name|tst
name|W
decl_stmt|, #
name|chunk_size
name|beq
decl|1f
DECL|variable|chunk_size
DECL|variable|src_bpp
DECL|variable|src_basereg
name|pixld
name|chunk_size
decl_stmt|,
name|src_bpp
decl_stmt|,
name|src_basereg
decl_stmt|,
name|SRC
DECL|variable|chunk_size
DECL|variable|mask_bpp
DECL|variable|mask_basereg
name|pixld
name|chunk_size
decl_stmt|,
name|mask_bpp
decl_stmt|,
name|mask_basereg
decl_stmt|,
name|MASK
operator|.
decl|if
name|dst_aligned_flag
decl|!= 0
DECL|variable|dst_r_bpp
DECL|variable|dst_r_basereg
name|pixld_a
name|chunk_size
decl_stmt|,
name|dst_r_bpp
decl_stmt|,
name|dst_r_basereg
decl_stmt|,
name|DST_R
operator|.
decl|else
DECL|variable|dst_r_bpp
DECL|variable|dst_r_basereg
name|pixld
name|chunk_size
decl_stmt|,
name|dst_r_bpp
decl_stmt|,
name|dst_r_basereg
decl_stmt|,
name|DST_R
operator|.
name|endif
operator|.
decl|if
name|cache_preload_flag
decl|!= 0
DECL|variable|PF_X
name|PF
name|add
name|PF_X
decl_stmt|,
name|PF_X
decl_stmt|, #
name|chunk_size
operator|.
name|endif
decl|1
range|:
operator|.
name|endif
operator|.
name|endr
name|pixdeinterleave
name|src_bpp
decl_stmt|,
name|src_basereg
DECL|variable|mask_bpp
name|pixdeinterleave
name|mask_bpp
decl_stmt|,
name|mask_basereg
DECL|variable|dst_r_bpp
name|pixdeinterleave
name|dst_r_bpp
decl_stmt|,
name|dst_r_basereg
name|process_pixblock_head
operator|.
decl|if
name|cache_preload_flag
decl|!= 0
name|cache_preload
decl|0
decl_stmt|,
name|pixblock_size
name|cache_preload_simple
operator|.
name|endif
name|process_pixblock_tail
name|pixinterleave
name|dst_w_bpp
decl_stmt|,
name|dst_w_basereg
operator|.
name|irp
name|chunk_size
decl_stmt|, 16, 8, 4, 2, 1 .if
name|pixblock_size
decl|>
name|chunk_size
name|tst
name|W
decl_stmt|, #
name|chunk_size
name|beq
decl|1f .if
name|dst_aligned_flag
decl|!= 0
DECL|variable|dst_w_bpp
DECL|variable|dst_w_basereg
name|pixst_a
name|chunk_size
decl_stmt|,
name|dst_w_bpp
decl_stmt|,
name|dst_w_basereg
decl_stmt|,
name|DST_W
operator|.
decl|else
DECL|variable|dst_w_bpp
DECL|variable|dst_w_basereg
name|pixst
name|chunk_size
decl_stmt|,
name|dst_w_bpp
decl_stmt|,
name|dst_w_basereg
decl_stmt|,
name|DST_W
operator|.
name|endif
decl|1
range|:
operator|.
name|endif
operator|.
name|endr
literal|2
operator|:
operator|.
name|endm
comment|/*  * Macro, which performs all the needed operations to switch to the next  * scanline and start the next loop iteration unless all the scanlines  * are already processed.  */
operator|.
name|macro
name|advance_to_next_scanline
name|start_of_loop_label
operator|.
expr|if
name|regs_shortage
name|ldrd
name|W
decl_stmt|, [
name|sp
decl|]
comment|/* load W and H (width and height) from stack */
decl|.else
name|mov
name|W
decl_stmt|,
name|ORIG_W
operator|.
name|endif
DECL|variable|DST_W
DECL|variable|DST_STRIDE
name|add
name|DST_W
decl_stmt|,
name|DST_W
decl_stmt|,
name|DST_STRIDE
decl_stmt|,
name|lsl
decl|#
name|dst_bpp_shift
operator|.
decl|if
name|src_bpp
decl|!= 0
DECL|variable|SRC
DECL|variable|SRC_STRIDE
name|add
name|SRC
decl_stmt|,
name|SRC
decl_stmt|,
name|SRC_STRIDE
decl_stmt|,
name|lsl
decl|#
name|src_bpp_shift
operator|.
name|endif
operator|.
decl|if
name|mask_bpp
decl|!= 0
DECL|variable|MASK
DECL|variable|MASK_STRIDE
name|add
name|MASK
decl_stmt|,
name|MASK
decl_stmt|,
name|MASK_STRIDE
decl_stmt|,
name|lsl
decl|#
name|mask_bpp_shift
operator|.
name|endif
operator|.
decl|if
argument_list|(
name|dst_w_bpp
operator|!=
literal|24
argument_list|)
DECL|variable|DST_W
DECL|variable|W
name|sub
name|DST_W
decl_stmt|,
name|DST_W
decl_stmt|,
name|W
decl_stmt|,
name|lsl
decl|#
name|dst_bpp_shift
operator|.
name|endif
operator|.
decl|if
argument_list|(
name|src_bpp
operator|!=
literal|24
argument_list|)
decl|&&
argument_list|(
name|src_bpp
operator|!=
literal|0
argument_list|)
DECL|variable|SRC
DECL|variable|SRC
DECL|variable|W
name|sub
name|SRC
decl_stmt|,
name|SRC
decl_stmt|,
name|W
decl_stmt|,
name|lsl
decl|#
name|src_bpp_shift
operator|.
name|endif
operator|.
decl|if
argument_list|(
name|mask_bpp
operator|!=
literal|24
argument_list|)
decl|&&
argument_list|(
name|mask_bpp
operator|!=
literal|0
argument_list|)
DECL|variable|MASK
DECL|variable|MASK
DECL|variable|W
name|sub
name|MASK
decl_stmt|,
name|MASK
decl_stmt|,
name|W
decl_stmt|,
name|lsl
decl|#
name|mask_bpp_shift
operator|.
name|endif
DECL|variable|H
name|subs
name|H
decl_stmt|,
name|H
decl_stmt|, #1
DECL|variable|DST_R
name|mov
name|DST_R
decl_stmt|,
name|DST_W
operator|.
decl|if
name|regs_shortage
name|str
name|H
decl_stmt|, [
name|sp
decl_stmt|, #4]
comment|/* save updated height to stack */
decl_stmt|.
name|endif
name|bge
name|start_of_loop_label
operator|.
name|endm
comment|/*  * Registers are allocated in the following way by default:  * d0, d1, d2, d3     - reserved for loading source pixel data  * d4, d5, d6, d7     - reserved for loading destination pixel data  * d24, d25, d26, d27 - reserved for loading mask pixel data  * d28, d29, d30, d31 - final destination pixel data for writeback to memory  */
operator|.
name|macro
name|generate_composite_function
name|fname
decl_stmt|, \
DECL|variable|src_bpp_
name|src_bpp_
decl_stmt|, \
DECL|variable|mask_bpp_
name|mask_bpp_
decl_stmt|, \
DECL|variable|dst_w_bpp_
name|dst_w_bpp_
decl_stmt|, \
DECL|variable|flags
name|flags
decl_stmt|, \
DECL|variable|pixblock_size_
name|pixblock_size_
decl_stmt|, \
DECL|variable|prefetch_distance
name|prefetch_distance
decl_stmt|, \
DECL|variable|init
name|init
decl_stmt|, \
DECL|variable|cleanup
name|cleanup
decl_stmt|, \
DECL|variable|process_pixblock_head
name|process_pixblock_head
decl_stmt|, \
DECL|variable|process_pixblock_tail
name|process_pixblock_tail
decl_stmt|, \
DECL|variable|process_pixblock_tail_head
name|process_pixblock_tail_head
decl_stmt|, \
DECL|variable|dst_w_basereg_
name|dst_w_basereg_
init|=
literal|28
decl_stmt|, \
DECL|variable|dst_r_basereg_
name|dst_r_basereg_
init|=
literal|4
decl_stmt|, \
DECL|variable|src_basereg_
name|src_basereg_
init|=
literal|0
decl_stmt|, \
DECL|variable|mask_basereg_
name|mask_basereg_
init|=
literal|24
operator|.
name|func
name|fname
operator|.
name|global
name|fname
comment|/* For ELF format also set function visibility to hidden */
ifdef|#
directive|ifdef
name|__ELF__
operator|.
name|hidden
name|fname
operator|.
name|type
name|fname
decl_stmt|, %
name|function
endif|#
directive|endif
name|fname
range|:
name|push
block|{
name|r4
operator|-
name|r12
block|,
name|lr
block|}
comment|/* save all registers */
comment|/*  * Select prefetch type for this function. If prefetch distance is  * set to 0 or one of the color formats is 24bpp, SIMPLE prefetch  * has to be used instead of ADVANCED.  */
operator|.
name|set
name|PREFETCH_TYPE_CURRENT
decl_stmt|,
name|PREFETCH_TYPE_DEFAULT
operator|.
decl|if
name|prefetch_distance
decl|== 0     .
name|set
name|PREFETCH_TYPE_CURRENT
decl_stmt|,
name|PREFETCH_TYPE_NONE
operator|.
name|elseif
argument_list|(
name|PREFETCH_TYPE_CURRENT
operator|>
name|PREFETCH_TYPE_SIMPLE
argument_list|)
decl|&& \
argument_list|(
operator|(
name|src_bpp_
operator|==
literal|24
operator|)
operator|||
operator|(
name|mask_bpp_
operator|==
literal|24
operator|)
operator|||
operator|(
name|dst_w_bpp_
operator|==
literal|24
operator|)
argument_list|)
decl|.
DECL|variable|PREFETCH_TYPE_CURRENT
name|set
name|PREFETCH_TYPE_CURRENT
decl_stmt|,
name|PREFETCH_TYPE_SIMPLE
operator|.
name|endif
comment|/*  * Make some macro arguments globally visible and accessible  * from other macros  */
operator|.
name|set
name|src_bpp
decl_stmt|,
name|src_bpp_
operator|.
name|set
name|mask_bpp
decl_stmt|,
name|mask_bpp_
operator|.
name|set
name|dst_w_bpp
decl_stmt|,
name|dst_w_bpp_
operator|.
name|set
name|pixblock_size
decl_stmt|,
name|pixblock_size_
operator|.
name|set
name|dst_w_basereg
decl_stmt|,
name|dst_w_basereg_
operator|.
name|set
name|dst_r_basereg
decl_stmt|,
name|dst_r_basereg_
operator|.
name|set
name|src_basereg
decl_stmt|,
name|src_basereg_
operator|.
name|set
name|mask_basereg
decl_stmt|,
name|mask_basereg_
comment|/*  * Assign symbolic names to registers  */
name|W
operator|.
name|req
name|r0
comment|/* width (is updated during processing) */
name|H
operator|.
name|req
name|r1
comment|/* height (is updated during processing) */
name|DST_W
operator|.
name|req
name|r2
comment|/* destination buffer pointer for writes */
name|DST_STRIDE
operator|.
name|req
name|r3
comment|/* destination image stride */
name|SRC
operator|.
name|req
name|r4
comment|/* source buffer pointer */
name|SRC_STRIDE
operator|.
name|req
name|r5
comment|/* source image stride */
name|DST_R
operator|.
name|req
name|r6
comment|/* destination buffer pointer for reads */
name|MASK
operator|.
name|req
name|r7
comment|/* mask pointer */
name|MASK_STRIDE
operator|.
name|req
name|r8
comment|/* mask stride */
name|PF_CTL
operator|.
name|req
name|r9
comment|/* combined lines counter and prefetch */
comment|/* distance increment counter */
name|PF_X
operator|.
name|req
name|r10
comment|/* pixel index in a scanline for current */
comment|/* pretetch position */
name|PF_SRC
operator|.
name|req
name|r11
comment|/* pointer to source scanline start */
comment|/* for prefetch purposes */
name|PF_DST
operator|.
name|req
name|r12
comment|/* pointer to destination scanline start */
comment|/* for prefetch purposes */
name|PF_MASK
operator|.
name|req
name|r14
comment|/* pointer to mask scanline start */
comment|/* for prefetch purposes */
comment|/*  * Check whether we have enough registers for all the local variables.  * If we don't have enough registers, original width and height are  * kept on top of stack (and 'regs_shortage' variable is set to indicate  * this for the rest of code). Even if there are enough registers, the  * allocation scheme may be a bit different depending on whether source  * or mask is not used.  */
operator|.
decl|if
argument_list|(
name|PREFETCH_TYPE_CURRENT
operator|<
name|PREFETCH_TYPE_ADVANCED
argument_list|)
name|ORIG_W
operator|.
name|req
name|r10
comment|/* saved original width */
name|DUMMY
operator|.
name|req
name|r12
comment|/* temporary register */
operator|.
name|set
name|regs_shortage
decl_stmt|, 0 .
name|elseif
name|mask_bpp
decl|== 0
name|ORIG_W
operator|.
name|req
name|r7
comment|/* saved original width */
name|DUMMY
operator|.
name|req
name|r8
comment|/* temporary register */
operator|.
name|set
name|regs_shortage
decl_stmt|, 0 .
name|elseif
name|src_bpp
decl|== 0
name|ORIG_W
operator|.
name|req
name|r4
comment|/* saved original width */
name|DUMMY
operator|.
name|req
name|r5
comment|/* temporary register */
operator|.
name|set
name|regs_shortage
decl_stmt|, 0 .else
name|ORIG_W
operator|.
name|req
name|r1
comment|/* saved original width */
name|DUMMY
operator|.
name|req
name|r1
comment|/* temporary register */
operator|.
name|set
name|regs_shortage
decl_stmt|, 1 .
name|endif
operator|.
name|set
name|mask_bpp_shift
decl_stmt|, -1 .if
name|src_bpp
decl|== 32     .
name|set
name|src_bpp_shift
decl_stmt|, 2 .
name|elseif
name|src_bpp
decl|== 24     .
name|set
name|src_bpp_shift
decl_stmt|, 0 .
name|elseif
name|src_bpp
decl|== 16     .
name|set
name|src_bpp_shift
decl_stmt|, 1 .
name|elseif
name|src_bpp
decl|== 8     .
name|set
name|src_bpp_shift
decl_stmt|, 0 .
name|elseif
name|src_bpp
decl|== 0     .
name|set
name|src_bpp_shift
decl_stmt|, -1 .else     .
name|error
decl|"requested src bpp (src_bpp) is not supported" .
name|endif
operator|.
decl|if
name|mask_bpp
decl|== 32     .
name|set
name|mask_bpp_shift
decl_stmt|, 2 .
name|elseif
name|mask_bpp
decl|== 24     .
name|set
name|mask_bpp_shift
decl_stmt|, 0 .
name|elseif
name|mask_bpp
decl|== 8     .
name|set
name|mask_bpp_shift
decl_stmt|, 0 .
name|elseif
name|mask_bpp
decl|== 0     .
name|set
name|mask_bpp_shift
decl_stmt|, -1 .else     .
name|error
decl|"requested mask bpp (mask_bpp) is not supported" .
name|endif
operator|.
decl|if
name|dst_w_bpp
decl|== 32     .
name|set
name|dst_bpp_shift
decl_stmt|, 2 .
name|elseif
name|dst_w_bpp
decl|== 24     .
name|set
name|dst_bpp_shift
decl_stmt|, 0 .
name|elseif
name|dst_w_bpp
decl|== 16     .
name|set
name|dst_bpp_shift
decl_stmt|, 1 .
name|elseif
name|dst_w_bpp
decl|== 8     .
name|set
name|dst_bpp_shift
decl_stmt|, 0 .else     .
name|error
decl|"requested dst bpp (dst_w_bpp) is not supported" .
name|endif
operator|.
decl|if
argument_list|(
operator|(
operator|(
name|flags
operator|)
operator|&
name|FLAG_DST_READWRITE
operator|)
operator|!=
literal|0
argument_list|)
decl|.
name|set
name|dst_r_bpp
decl_stmt|,
name|dst_w_bpp
operator|.
decl|else     .
name|set
name|dst_r_bpp
decl_stmt|, 0 .
name|endif
operator|.
decl|if
argument_list|(
operator|(
operator|(
name|flags
operator|)
operator|&
name|FLAG_DEINTERLEAVE_32BPP
operator|)
operator|!=
literal|0
argument_list|)
decl|.
name|set
name|DEINTERLEAVE_32BPP_ENABLED
decl_stmt|, 1 .else     .
name|set
name|DEINTERLEAVE_32BPP_ENABLED
decl_stmt|, 0 .
name|endif
operator|.
decl|if
name|prefetch_distance
decl|< 0 ||
name|prefetch_distance
decl|> 15     .
name|error
decl|"invalid prefetch distance (prefetch_distance)" .
name|endif
operator|.
decl|if
name|src_bpp
decl|> 0
name|ldr
name|SRC
decl_stmt|, [
name|sp
decl_stmt|, #40] .
name|endif
operator|.
decl|if
name|mask_bpp
decl|> 0
name|ldr
name|MASK
decl_stmt|, [
name|sp
decl_stmt|, #48] .
name|endif
name|PF
name|mov
name|PF_X
decl_stmt|, #0 .if
name|src_bpp
decl|> 0
name|ldr
name|SRC_STRIDE
decl_stmt|, [
name|sp
decl_stmt|, #44] .
name|endif
operator|.
decl|if
name|mask_bpp
decl|> 0
name|ldr
name|MASK_STRIDE
decl_stmt|, [
name|sp
decl_stmt|, #52] .
name|endif
name|mov
name|DST_R
decl_stmt|,
name|DST_W
operator|.
decl|if
name|src_bpp
decl|== 24
DECL|variable|SRC_STRIDE
name|sub
name|SRC_STRIDE
decl_stmt|,
name|SRC_STRIDE
decl_stmt|,
name|W
DECL|variable|SRC_STRIDE
DECL|variable|SRC_STRIDE
DECL|variable|W
name|sub
name|SRC_STRIDE
decl_stmt|,
name|SRC_STRIDE
decl_stmt|,
name|W
decl_stmt|,
name|lsl
decl|#1 .
name|endif
operator|.
decl|if
name|mask_bpp
decl|== 24
DECL|variable|MASK_STRIDE
name|sub
name|MASK_STRIDE
decl_stmt|,
name|MASK_STRIDE
decl_stmt|,
name|W
DECL|variable|MASK_STRIDE
DECL|variable|MASK_STRIDE
DECL|variable|W
name|sub
name|MASK_STRIDE
decl_stmt|,
name|MASK_STRIDE
decl_stmt|,
name|W
decl_stmt|,
name|lsl
decl|#1 .
name|endif
operator|.
decl|if
name|dst_w_bpp
decl|== 24
DECL|variable|DST_STRIDE
name|sub
name|DST_STRIDE
decl_stmt|,
name|DST_STRIDE
decl_stmt|,
name|W
DECL|variable|DST_STRIDE
DECL|variable|DST_STRIDE
DECL|variable|W
name|sub
name|DST_STRIDE
decl_stmt|,
name|DST_STRIDE
decl_stmt|,
name|W
decl_stmt|,
name|lsl
decl|#1 .
name|endif
comment|/*  * Setup advanced prefetcher initial state  */
name|PF
name|mov
name|PF_SRC
decl_stmt|,
name|SRC
DECL|variable|PF_DST
name|PF
name|mov
name|PF_DST
decl_stmt|,
name|DST_R
DECL|variable|PF_MASK
name|PF
name|mov
name|PF_MASK
decl_stmt|,
name|MASK
comment|/* PF_CTL = prefetch_distance | ((h - 1)<< 4) */
DECL|variable|PF_CTL
DECL|variable|H
name|PF
name|mov
name|PF_CTL
decl_stmt|,
name|H
decl_stmt|,
name|lsl
decl|#4
DECL|variable|PF_CTL
name|PF
name|add
name|PF_CTL
decl_stmt|, #
argument_list|(
name|prefetch_distance
operator|-
literal|0x10
argument_list|)
name|init
operator|.
decl|if
name|regs_shortage
name|push
block|{
name|r0
operator|,
name|r1
block|}
end_if
begin_expr_stmt
operator|.
name|endif
DECL|variable|H
name|subs
name|H
operator|,
name|H
operator|,
operator|#
literal|1
operator|.
end_expr_stmt
begin_if
if|if regs_shortage     str         H
operator|,
index|[
name|sp
operator|,
operator|#
literal|4
index|]
comment|/* save updated height to stack */
operator|.
else|else
name|mov
name|ORIG_W
decl_stmt|,
name|W
operator|.
name|endif
name|blt
decl|9f
name|cmp
name|W
decl_stmt|, #
argument_list|(
name|pixblock_size
operator|*
literal|2
argument_list|)
name|blt
decl|8f
comment|/*  * This is the start of the pipelined loop, which if optimized for  * long scanlines  */
decl|0
range|:
DECL|variable|process_pixblock_head
name|ensure_destination_ptr_alignment
name|process_pixblock_head
decl_stmt|, \
DECL|variable|process_pixblock_tail
name|process_pixblock_tail
decl_stmt|, \
name|process_pixblock_tail_head
comment|/* Implement "head (tail_head) ... (tail_head) tail" loop pattern */
DECL|variable|pixblock_size
DECL|variable|dst_r_bpp
name|pixld_a
name|pixblock_size
decl_stmt|,
name|dst_r_bpp
decl_stmt|, \
argument_list|(
name|dst_r_basereg
operator|-
name|pixblock_size
operator|*
name|dst_r_bpp
operator|/
literal|64
argument_list|)
decl_stmt|,
name|DST_R
DECL|variable|pixblock_size
DECL|variable|src_bpp
name|pixld
name|pixblock_size
decl_stmt|,
name|src_bpp
decl_stmt|, \
argument_list|(
name|src_basereg
operator|-
name|pixblock_size
operator|*
name|src_bpp
operator|/
literal|64
argument_list|)
decl_stmt|,
name|SRC
DECL|variable|pixblock_size
DECL|variable|mask_bpp
name|pixld
name|pixblock_size
decl_stmt|,
name|mask_bpp
decl_stmt|, \
argument_list|(
name|mask_basereg
operator|-
name|pixblock_size
operator|*
name|mask_bpp
operator|/
literal|64
argument_list|)
decl_stmt|,
name|MASK
DECL|variable|PF_X
DECL|variable|PF_X
name|PF
name|add
name|PF_X
decl_stmt|,
name|PF_X
decl_stmt|, #
name|pixblock_size
name|process_pixblock_head
DECL|variable|cache_preload
name|cache_preload
decl|0
decl_stmt|,
name|pixblock_size
name|cache_preload_simple
DECL|variable|W
DECL|variable|W
name|subs
name|W
decl_stmt|,
name|W
decl_stmt|, #
argument_list|(
name|pixblock_size
operator|*
literal|2
argument_list|)
name|blt
decl|2f 1
range|:
name|process_pixblock_tail_head
name|cache_preload_simple
DECL|variable|W
DECL|variable|W
name|subs
name|W
decl_stmt|,
name|W
decl_stmt|, #
name|pixblock_size
name|bge
decl|1b 2
range|:
name|process_pixblock_tail
DECL|variable|pixblock_size
DECL|variable|dst_w_bpp
name|pixst_a
name|pixblock_size
decl_stmt|,
name|dst_w_bpp
decl_stmt|, \
argument_list|(
name|dst_w_basereg
operator|-
name|pixblock_size
operator|*
name|dst_w_bpp
operator|/
literal|64
argument_list|)
decl_stmt|,
name|DST_W
comment|/* Process the remaining trailing pixels in the scanline */
DECL|variable|process_trailing_pixels
name|process_trailing_pixels
decl|1
decl_stmt|, 1, \
DECL|variable|process_pixblock_head
name|process_pixblock_head
decl_stmt|, \
DECL|variable|process_pixblock_tail
name|process_pixblock_tail
decl_stmt|, \
name|process_pixblock_tail_head
name|advance_to_next_scanline
decl|0b  .if
name|regs_shortage
name|pop
block|{
name|r0
operator|,
name|r1
block|}
end_if
begin_expr_stmt
operator|.
name|endif
name|cleanup
name|pop
block|{
name|r4
operator|-
name|r12
block|,
name|pc
block|}
comment|/* exit */
comment|/*  * This is the start of the loop, designed to process images with small width  * (less than pixblock_size * 2 pixels). In this case neither pipelining  * nor prefetch are used.  */
literal|8
operator|:
comment|/* Process exactly pixblock_size pixels if needed */
DECL|variable|W
name|tst
name|W
operator|,
operator|#
name|pixblock_size
name|beq
literal|1f
DECL|variable|pixblock_size
DECL|variable|dst_r_bpp
name|pixld
name|pixblock_size
operator|,
name|dst_r_bpp
operator|,
expr_stmt|\
operator|(
name|dst_r_basereg
operator|-
name|pixblock_size
operator|*
name|dst_r_bpp
operator|/
literal|64
operator|)
operator|,
name|DST_R
DECL|variable|pixblock_size
DECL|variable|src_bpp
name|pixld
name|pixblock_size
operator|,
name|src_bpp
operator|,
expr_stmt|\
operator|(
name|src_basereg
operator|-
name|pixblock_size
operator|*
name|src_bpp
operator|/
literal|64
operator|)
operator|,
name|SRC
DECL|variable|pixblock_size
DECL|variable|mask_bpp
name|pixld
name|pixblock_size
operator|,
name|mask_bpp
operator|,
expr_stmt|\
operator|(
name|mask_basereg
operator|-
name|pixblock_size
operator|*
name|mask_bpp
operator|/
literal|64
operator|)
operator|,
name|MASK
name|process_pixblock_head
name|process_pixblock_tail
DECL|variable|pixblock_size
DECL|variable|dst_w_bpp
name|pixst
name|pixblock_size
operator|,
name|dst_w_bpp
operator|,
expr_stmt|\
operator|(
name|dst_w_basereg
operator|-
name|pixblock_size
operator|*
name|dst_w_bpp
operator|/
literal|64
operator|)
operator|,
name|DST_W
literal|1
operator|:
comment|/* Process the remaining trailing pixels in the scanline */
DECL|variable|process_trailing_pixels
name|process_trailing_pixels
literal|0
operator|,
literal|0
operator|,
expr_stmt|\
DECL|variable|process_pixblock_head
name|process_pixblock_head
operator|,
expr_stmt|\
DECL|variable|process_pixblock_tail
name|process_pixblock_tail
operator|,
expr_stmt|\
name|process_pixblock_tail_head
name|advance_to_next_scanline
literal|8b
literal|9
operator|:
operator|.
end_expr_stmt
begin_if
if|if regs_shortage     pop
block|{
name|r0
operator|,
name|r1
block|}
end_if
begin_expr_stmt
operator|.
name|endif
name|cleanup
name|pop
block|{
name|r4
operator|-
name|r12
block|,
name|pc
block|}
comment|/* exit */
operator|.
name|unreq
name|SRC
operator|.
name|unreq
name|MASK
operator|.
name|unreq
name|DST_R
operator|.
name|unreq
name|DST_W
operator|.
name|unreq
name|ORIG_W
operator|.
name|unreq
name|W
operator|.
name|unreq
name|H
operator|.
name|unreq
name|SRC_STRIDE
operator|.
name|unreq
name|DST_STRIDE
operator|.
name|unreq
name|MASK_STRIDE
operator|.
name|unreq
name|PF_CTL
operator|.
name|unreq
name|PF_X
operator|.
name|unreq
name|PF_SRC
operator|.
name|unreq
name|PF_DST
operator|.
name|unreq
name|PF_MASK
operator|.
name|unreq
name|DUMMY
operator|.
name|endfunc
operator|.
name|endm
comment|/*  * A simplified variant of function generation template for a single  * scanline processing (for implementing pixman combine functions)  */
operator|.
name|macro
name|generate_composite_function_single_scanline
name|fname
operator|,
expr_stmt|\
DECL|variable|src_bpp_
name|src_bpp_
operator|,
expr_stmt|\
DECL|variable|mask_bpp_
name|mask_bpp_
operator|,
expr_stmt|\
DECL|variable|dst_w_bpp_
name|dst_w_bpp_
operator|,
expr_stmt|\
DECL|variable|flags
name|flags
operator|,
expr_stmt|\
DECL|variable|pixblock_size_
name|pixblock_size_
operator|,
expr_stmt|\
DECL|variable|init
name|init
operator|,
expr_stmt|\
DECL|variable|cleanup
name|cleanup
operator|,
expr_stmt|\
DECL|variable|process_pixblock_head
name|process_pixblock_head
operator|,
expr_stmt|\
DECL|variable|process_pixblock_tail
name|process_pixblock_tail
operator|,
expr_stmt|\
DECL|variable|process_pixblock_tail_head
name|process_pixblock_tail_head
operator|,
expr_stmt|\
DECL|variable|dst_w_basereg_
name|dst_w_basereg_
operator|=
literal|28
operator|,
expr_stmt|\
DECL|variable|dst_r_basereg_
name|dst_r_basereg_
operator|=
literal|4
operator|,
expr_stmt|\
DECL|variable|src_basereg_
name|src_basereg_
operator|=
literal|0
operator|,
expr_stmt|\
DECL|variable|mask_basereg_
name|mask_basereg_
operator|=
literal|24
operator|.
name|func
name|fname
operator|.
name|global
name|fname
comment|/* For ELF format also set function visibility to hidden */
ifdef|#
directive|ifdef
name|__ELF__
operator|.
name|hidden
name|fname
operator|.
name|type
name|fname
operator|,
operator|%
name|function
endif|#
directive|endif
name|fname
operator|:
operator|.
name|set
name|PREFETCH_TYPE_CURRENT
operator|,
name|PREFETCH_TYPE_NONE
comment|/*  * Make some macro arguments globally visible and accessible  * from other macros  */
operator|.
name|set
name|src_bpp
operator|,
name|src_bpp_
operator|.
name|set
name|mask_bpp
operator|,
name|mask_bpp_
operator|.
name|set
name|dst_w_bpp
operator|,
name|dst_w_bpp_
operator|.
name|set
name|pixblock_size
operator|,
name|pixblock_size_
operator|.
name|set
name|dst_w_basereg
operator|,
name|dst_w_basereg_
operator|.
name|set
name|dst_r_basereg
operator|,
name|dst_r_basereg_
operator|.
name|set
name|src_basereg
operator|,
name|src_basereg_
operator|.
name|set
name|mask_basereg
operator|,
name|mask_basereg_
comment|/*  * Assign symbolic names to registers  */
name|W
operator|.
name|req
name|r0
comment|/* width (is updated during processing) */
name|DST_W
operator|.
name|req
name|r1
comment|/* destination buffer pointer for writes */
name|SRC
operator|.
name|req
name|r2
comment|/* source buffer pointer */
name|DST_R
operator|.
name|req
name|ip
comment|/* destination buffer pointer for reads */
name|MASK
operator|.
name|req
name|r3
comment|/* mask pointer */
operator|.
expr|if
operator|(
operator|(
operator|(
name|flags
operator|)
operator|&
name|FLAG_DST_READWRITE
operator|)
operator|!=
literal|0
operator|)
operator|.
name|set
name|dst_r_bpp
operator|,
name|dst_w_bpp
operator|.
expr|else
operator|.
name|set
name|dst_r_bpp
operator|,
literal|0
operator|.
name|endif
operator|.
expr|if
operator|(
operator|(
operator|(
name|flags
operator|)
operator|&
name|FLAG_DEINTERLEAVE_32BPP
operator|)
operator|!=
literal|0
operator|)
operator|.
name|set
name|DEINTERLEAVE_32BPP_ENABLED
operator|,
literal|1
operator|.
end_expr_stmt
begin_else
else|else
operator|.
name|set
name|DEINTERLEAVE_32BPP_ENABLED
operator|,
literal|0
operator|.
name|endif
name|init
name|mov
name|DST_R
operator|,
name|DST_W
DECL|variable|W
name|cmp
name|W
operator|,
operator|#
name|pixblock_size
name|blt
literal|8f
DECL|variable|process_pixblock_head
name|ensure_destination_ptr_alignment
name|process_pixblock_head
operator|,
expr_stmt|\
DECL|variable|process_pixblock_tail
name|process_pixblock_tail
operator|,
expr_stmt|\
name|process_pixblock_tail_head
DECL|variable|W
DECL|variable|W
name|subs
name|W
operator|,
name|W
operator|,
operator|#
name|pixblock_size
name|blt
literal|7f
comment|/* Implement "head (tail_head) ... (tail_head) tail" loop pattern */
DECL|variable|pixblock_size
DECL|variable|dst_r_bpp
name|pixld_a
name|pixblock_size
operator|,
name|dst_r_bpp
operator|,
expr_stmt|\
operator|(
name|dst_r_basereg
operator|-
name|pixblock_size
operator|*
name|dst_r_bpp
operator|/
literal|64
operator|)
operator|,
name|DST_R
DECL|variable|pixblock_size
DECL|variable|src_bpp
name|pixld
name|pixblock_size
operator|,
name|src_bpp
operator|,
expr_stmt|\
operator|(
name|src_basereg
operator|-
name|pixblock_size
operator|*
name|src_bpp
operator|/
literal|64
operator|)
operator|,
name|SRC
DECL|variable|pixblock_size
DECL|variable|mask_bpp
name|pixld
name|pixblock_size
operator|,
name|mask_bpp
operator|,
expr_stmt|\
operator|(
name|mask_basereg
operator|-
name|pixblock_size
operator|*
name|mask_bpp
operator|/
literal|64
operator|)
operator|,
name|MASK
name|process_pixblock_head
DECL|variable|W
DECL|variable|W
name|subs
name|W
operator|,
name|W
operator|,
operator|#
name|pixblock_size
name|blt
literal|2f
literal|1
operator|:
name|process_pixblock_tail_head
DECL|variable|W
DECL|variable|W
name|subs
name|W
operator|,
name|W
operator|,
operator|#
name|pixblock_size
name|bge
literal|1b
literal|2
operator|:
name|process_pixblock_tail
DECL|variable|pixblock_size
DECL|variable|dst_w_bpp
name|pixst_a
name|pixblock_size
operator|,
name|dst_w_bpp
operator|,
expr_stmt|\
operator|(
name|dst_w_basereg
operator|-
name|pixblock_size
operator|*
name|dst_w_bpp
operator|/
literal|64
operator|)
operator|,
name|DST_W
literal|7
operator|:
comment|/* Process the remaining trailing pixels in the scanline (dst aligned) */
DECL|variable|process_trailing_pixels
name|process_trailing_pixels
literal|0
operator|,
literal|1
operator|,
expr_stmt|\
DECL|variable|process_pixblock_head
name|process_pixblock_head
operator|,
expr_stmt|\
DECL|variable|process_pixblock_tail
name|process_pixblock_tail
operator|,
expr_stmt|\
name|process_pixblock_tail_head
name|cleanup
name|bx
name|lr
comment|/* exit */
literal|8
operator|:
comment|/* Process the remaining trailing pixels in the scanline (dst unaligned) */
DECL|variable|process_trailing_pixels
name|process_trailing_pixels
literal|0
operator|,
literal|0
operator|,
expr_stmt|\
DECL|variable|process_pixblock_head
name|process_pixblock_head
operator|,
expr_stmt|\
DECL|variable|process_pixblock_tail
name|process_pixblock_tail
operator|,
expr_stmt|\
name|process_pixblock_tail_head
name|cleanup
name|bx
name|lr
comment|/* exit */
operator|.
name|unreq
name|SRC
operator|.
name|unreq
name|MASK
operator|.
name|unreq
name|DST_R
operator|.
name|unreq
name|DST_W
operator|.
name|unreq
name|W
operator|.
name|endfunc
operator|.
name|endm
operator|.
name|macro
name|default_init
operator|.
name|endm
operator|.
name|macro
name|default_cleanup
operator|.
name|endm
end_else
end_unit
