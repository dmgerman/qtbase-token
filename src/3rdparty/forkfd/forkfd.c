begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2014 Intel Corporation ** ** $QT_BEGIN_LICENSE:BSD$ ** You may use this file under the terms of the BSD license as follows: ** ** "Redistribution and use in source and binary forms, with or without ** modification, are permitted provided that the following conditions are ** met: **   * Redistributions of source code must retain the above copyright **     notice, this list of conditions and the following disclaimer. **   * Redistributions in binary form must reproduce the above copyright **     notice, this list of conditions and the following disclaimer in **     the documentation and/or other materials provided with the **     distribution. **   * Neither the name of Nokia Corporation and its Subsidiary(-ies) nor **     the names of its contributors may be used to endorse or promote **     products derived from this software without specific prior written **     permission. ** ** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ** "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR ** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT ** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, ** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, ** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE ** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE." ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|_GNU_SOURCE
end_ifndef
begin_define
DECL|macro|_GNU_SOURCE
define|#
directive|define
name|_GNU_SOURCE
end_define
begin_define
DECL|macro|_POSIX_C_SOURCE
define|#
directive|define
name|_POSIX_C_SOURCE
value|200809L
end_define
begin_define
DECL|macro|_XOPEN_SOURCE
define|#
directive|define
name|_XOPEN_SOURCE
value|500
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|"forkfd.h"
end_include
begin_include
include|#
directive|include
file|<sys/types.h>
end_include
begin_include
include|#
directive|include
file|<sys/wait.h>
end_include
begin_include
include|#
directive|include
file|<assert.h>
end_include
begin_include
include|#
directive|include
file|<errno.h>
end_include
begin_include
include|#
directive|include
file|<pthread.h>
end_include
begin_include
include|#
directive|include
file|<signal.h>
end_include
begin_include
include|#
directive|include
file|<stdlib.h>
end_include
begin_include
include|#
directive|include
file|<string.h>
end_include
begin_include
include|#
directive|include
file|<unistd.h>
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|__linux__
end_ifdef
begin_define
DECL|macro|HAVE_PIPE2
define|#
directive|define
name|HAVE_PIPE2
value|1
end_define
begin_define
DECL|macro|HAVE_EVENTFD
define|#
directive|define
name|HAVE_EVENTFD
value|1
end_define
begin_include
include|#
directive|include
file|<sys/eventfd.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|_POSIX_VERSION
operator|-
literal|0
operator|>=
literal|200809L
operator|||
name|_XOPEN_VERSION
operator|-
literal|0
operator|>=
literal|500
end_if
begin_define
DECL|macro|HAVE_WAITID
define|#
directive|define
name|HAVE_WAITID
value|1
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|FFD_ATOMIC_RELAXED
end_ifndef
begin_include
include|#
directive|include
file|"forkfd_gcc.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|CHILDREN_IN_SMALL_ARRAY
define|#
directive|define
name|CHILDREN_IN_SMALL_ARRAY
value|16
end_define
begin_define
DECL|macro|CHILDREN_IN_BIG_ARRAY
define|#
directive|define
name|CHILDREN_IN_BIG_ARRAY
value|256
end_define
begin_define
DECL|macro|sizeofarray
define|#
directive|define
name|sizeofarray
parameter_list|(
name|array
parameter_list|)
value|(sizeof(array)/sizeof(array[0]))
end_define
begin_define
DECL|macro|EINTR_LOOP
define|#
directive|define
name|EINTR_LOOP
parameter_list|(
name|ret
parameter_list|,
name|call
parameter_list|)
define|\
value|do {                      \         ret = call;           \     } while (ret == -1&& errno == EINTR)
end_define
begin_typedef
DECL|struct|process_info
typedef|typedef
struct|struct
name|process_info
block|{
DECL|member|pid
name|ffd_atomic_int
name|pid
decl_stmt|;
DECL|member|deathPipe
name|int
name|deathPipe
decl_stmt|;
block|}
DECL|typedef|ProcessInfo
name|ProcessInfo
typedef|;
end_typedef
begin_struct_decl
struct_decl|struct
name|BigArray
struct_decl|;
end_struct_decl
begin_typedef
DECL|struct|Header
typedef|typedef
struct|struct
name|Header
block|{
DECL|member|nextArray
name|ffd_atomic_pointer
argument_list|(
argument|struct BigArray
argument_list|)
name|nextArray
expr_stmt|;
DECL|member|busyCount
name|ffd_atomic_int
name|busyCount
decl_stmt|;
block|}
DECL|typedef|Header
name|Header
typedef|;
end_typedef
begin_typedef
DECL|struct|BigArray
typedef|typedef
struct|struct
name|BigArray
block|{
DECL|member|header
name|Header
name|header
decl_stmt|;
DECL|member|entries
name|ProcessInfo
name|entries
index|[
name|CHILDREN_IN_BIG_ARRAY
index|]
decl_stmt|;
block|}
DECL|typedef|BigArray
name|BigArray
typedef|;
end_typedef
begin_typedef
DECL|struct|SmallArray
typedef|typedef
struct|struct
name|SmallArray
block|{
DECL|member|header
name|Header
name|header
decl_stmt|;
DECL|member|entries
name|ProcessInfo
name|entries
index|[
name|CHILDREN_IN_SMALL_ARRAY
index|]
decl_stmt|;
block|}
DECL|typedef|SmallArray
name|SmallArray
typedef|;
end_typedef
begin_decl_stmt
DECL|variable|children
specifier|static
name|SmallArray
name|children
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|old_sigaction
specifier|static
name|struct
name|sigaction
name|old_sigaction
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|forkfd_initialization
specifier|static
name|pthread_once_t
name|forkfd_initialization
init|=
name|PTHREAD_ONCE_INIT
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|forkfd_status
specifier|static
name|ffd_atomic_int
name|forkfd_status
init|=
name|FFD_ATOMIC_INIT
argument_list|(
literal|0
argument_list|)
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|tryAllocateInSection
specifier|static
name|ProcessInfo
modifier|*
name|tryAllocateInSection
parameter_list|(
name|Header
modifier|*
name|header
parameter_list|,
name|ProcessInfo
name|entries
index|[]
parameter_list|,
name|int
name|maxCount
parameter_list|)
block|{
comment|/* we use ACQUIRE here because the signal handler might have released the PID */
name|int
name|busyCount
init|=
name|ffd_atomic_add_fetch
argument_list|(
operator|&
name|header
operator|->
name|busyCount
argument_list|,
literal|1
argument_list|,
name|FFD_ATOMIC_ACQUIRE
argument_list|)
decl_stmt|;
if|if
condition|(
name|busyCount
operator|<=
name|maxCount
condition|)
block|{
comment|/* there's an available entry in this section, find it and take it */
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|maxCount
condition|;
operator|++
name|i
control|)
block|{
comment|/* if the PID is 0, it's free; mark it as used by swapping it with -1 */
name|int
name|expected_pid
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ffd_atomic_compare_exchange
argument_list|(
operator|&
name|entries
index|[
name|i
index|]
operator|.
name|pid
argument_list|,
operator|&
name|expected_pid
argument_list|,
operator|-
literal|1
argument_list|,
name|FFD_ATOMIC_RELAXED
argument_list|,
name|FFD_ATOMIC_RELAXED
argument_list|)
condition|)
return|return
operator|&
name|entries
index|[
name|i
index|]
return|;
block|}
block|}
comment|/* there isn't an available entry, undo our increment */
name|ffd_atomic_add_fetch
argument_list|(
operator|&
name|header
operator|->
name|busyCount
argument_list|,
operator|-
literal|1
argument_list|,
name|FFD_ATOMIC_RELAXED
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function
begin_function
DECL|function|allocateInfo
specifier|static
name|ProcessInfo
modifier|*
name|allocateInfo
parameter_list|(
name|Header
modifier|*
modifier|*
name|header
parameter_list|)
block|{
name|Header
modifier|*
name|currentHeader
init|=
operator|&
name|children
operator|.
name|header
decl_stmt|;
comment|/* try to find an available entry in the small array first */
name|ProcessInfo
modifier|*
name|info
init|=
name|tryAllocateInSection
argument_list|(
name|currentHeader
argument_list|,
name|children
operator|.
name|entries
argument_list|,
name|sizeofarray
argument_list|(
name|children
operator|.
name|entries
argument_list|)
argument_list|)
decl_stmt|;
comment|/* go on to the next arrays */
while|while
condition|(
name|info
operator|==
name|NULL
condition|)
block|{
name|BigArray
modifier|*
name|array
init|=
name|ffd_atomic_load
argument_list|(
operator|&
name|currentHeader
operator|->
name|nextArray
argument_list|,
name|FFD_ATOMIC_ACQUIRE
argument_list|)
decl_stmt|;
if|if
condition|(
name|array
operator|==
name|NULL
condition|)
block|{
comment|/* allocate an array and try to use it */
name|BigArray
modifier|*
name|allocatedArray
init|=
operator|(
name|BigArray
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|BigArray
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|allocatedArray
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|ffd_atomic_compare_exchange
argument_list|(
operator|&
name|currentHeader
operator|->
name|nextArray
argument_list|,
operator|&
name|array
argument_list|,
name|allocatedArray
argument_list|,
name|FFD_ATOMIC_RELEASE
argument_list|,
name|FFD_ATOMIC_ACQUIRE
argument_list|)
condition|)
block|{
comment|/* success */
name|array
operator|=
name|allocatedArray
expr_stmt|;
block|}
else|else
block|{
comment|/* failed, the atomic updated 'array' */
name|free
argument_list|(
name|allocatedArray
argument_list|)
expr_stmt|;
block|}
block|}
name|currentHeader
operator|=
operator|&
name|array
operator|->
name|header
expr_stmt|;
name|info
operator|=
name|tryAllocateInSection
argument_list|(
name|currentHeader
argument_list|,
name|array
operator|->
name|entries
argument_list|,
name|sizeofarray
argument_list|(
name|array
operator|->
name|entries
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|*
name|header
operator|=
name|currentHeader
expr_stmt|;
return|return
name|info
return|;
block|}
end_function
begin_function
DECL|function|tryReaping
specifier|static
name|int
name|tryReaping
parameter_list|(
name|pid_t
name|pid
parameter_list|,
name|siginfo_t
modifier|*
name|info
parameter_list|)
block|{
comment|/* reap the child */
ifdef|#
directive|ifdef
name|HAVE_WAITID
comment|// we have waitid(2), which fills in siginfo_t for us
name|info
operator|->
name|si_pid
operator|=
literal|0
expr_stmt|;
return|return
name|waitid
argument_list|(
name|P_PID
argument_list|,
name|pid
argument_list|,
name|info
argument_list|,
name|WEXITED
operator||
name|WNOHANG
argument_list|)
operator|==
literal|0
operator|&&
name|info
operator|->
name|si_pid
operator|==
name|pid
return|;
else|#
directive|else
name|int
name|status
decl_stmt|;
if|if
condition|(
name|waitpid
argument_list|(
name|pid
argument_list|,
operator|&
name|status
argument_list|,
name|WNOHANG
argument_list|)
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
comment|// child did not change state
name|info
operator|->
name|si_signo
operator|=
name|SIGCHLD
expr_stmt|;
name|info
operator|->
name|si_utime
operator|=
literal|0
expr_stmt|;
name|info
operator|->
name|si_stime
operator|=
literal|0
expr_stmt|;
name|info
operator|->
name|si_pid
operator|=
name|pid
expr_stmt|;
if|if
condition|(
name|WIFEXITED
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|info
operator|->
name|si_code
operator|=
name|CLD_EXITED
expr_stmt|;
name|info
operator|->
name|si_status
operator|=
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|WIFSIGNALED
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|info
operator|->
name|si_code
operator|=
name|CLD_KILLED
expr_stmt|;
ifdef|#
directive|ifdef
name|WCOREDUMP
if|if
condition|(
name|WCOREDUMP
argument_list|(
name|status
argument_list|)
condition|)
name|info
operator|->
name|si_code
operator|=
name|CLD_DUMPED
expr_stmt|;
endif|#
directive|endif
name|info
operator|->
name|si_status
operator|=
name|WTERMSIG
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|freeInfo
specifier|static
name|void
name|freeInfo
parameter_list|(
name|Header
modifier|*
name|header
parameter_list|,
name|ProcessInfo
modifier|*
name|entry
parameter_list|)
block|{
name|entry
operator|->
name|deathPipe
operator|=
operator|-
literal|1
expr_stmt|;
name|entry
operator|->
name|pid
operator|=
literal|0
expr_stmt|;
name|ffd_atomic_add_fetch
argument_list|(
operator|&
name|header
operator|->
name|busyCount
argument_list|,
operator|-
literal|1
argument_list|,
name|FFD_ATOMIC_RELEASE
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|header
operator|->
name|busyCount
operator|>=
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|notifyAndFreeInfo
specifier|static
name|void
name|notifyAndFreeInfo
parameter_list|(
name|Header
modifier|*
name|header
parameter_list|,
name|ProcessInfo
modifier|*
name|entry
parameter_list|,
name|siginfo_t
modifier|*
name|info
parameter_list|)
block|{
name|ssize_t
name|ret
decl_stmt|;
name|EINTR_LOOP
argument_list|(
name|ret
argument_list|,
name|write
argument_list|(
name|entry
operator|->
name|deathPipe
argument_list|,
name|info
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|info
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|EINTR_LOOP
argument_list|(
name|ret
argument_list|,
name|close
argument_list|(
name|entry
operator|->
name|deathPipe
argument_list|)
argument_list|)
expr_stmt|;
name|freeInfo
argument_list|(
name|header
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|sigchld_handler
specifier|static
name|void
name|sigchld_handler
parameter_list|(
name|int
name|signum
parameter_list|)
block|{
comment|/*      * This is a signal handler, so we need to be careful about which functions      * we can call. See the full, official listing in the POSIX.1-2008      * specification at:      *   http://pubs.opengroup.org/onlinepubs/9699919799/functions/V2_chap02.html#tag_15_04_03      *      */
if|if
condition|(
name|ffd_atomic_load
argument_list|(
operator|&
name|forkfd_status
argument_list|,
name|FFD_ATOMIC_RELAXED
argument_list|)
operator|==
literal|1
condition|)
block|{
comment|/* is this one of our children? */
name|BigArray
modifier|*
name|array
decl_stmt|;
name|siginfo_t
name|info
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|sizeofarray
argument_list|(
name|children
operator|.
name|entries
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|int
name|pid
init|=
name|ffd_atomic_load
argument_list|(
operator|&
name|children
operator|.
name|entries
index|[
name|i
index|]
operator|.
name|pid
argument_list|,
name|FFD_ATOMIC_ACQUIRE
argument_list|)
decl_stmt|;
if|if
condition|(
name|pid
operator|>
literal|0
operator|&&
name|tryReaping
argument_list|(
name|pid
argument_list|,
operator|&
name|info
argument_list|)
condition|)
block|{
comment|/* this is our child, send notification and free up this entry */
name|notifyAndFreeInfo
argument_list|(
operator|&
name|children
operator|.
name|header
argument_list|,
operator|&
name|children
operator|.
name|entries
index|[
name|i
index|]
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* try the arrays */
name|array
operator|=
name|ffd_atomic_load
argument_list|(
operator|&
name|children
operator|.
name|header
operator|.
name|nextArray
argument_list|,
name|FFD_ATOMIC_ACQUIRE
argument_list|)
expr_stmt|;
while|while
condition|(
name|array
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|sizeofarray
argument_list|(
name|array
operator|->
name|entries
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|int
name|pid
init|=
name|ffd_atomic_load
argument_list|(
operator|&
name|array
operator|->
name|entries
index|[
name|i
index|]
operator|.
name|pid
argument_list|,
name|FFD_ATOMIC_ACQUIRE
argument_list|)
decl_stmt|;
if|if
condition|(
name|pid
operator|>
literal|0
operator|&&
name|tryReaping
argument_list|(
name|pid
argument_list|,
operator|&
name|info
argument_list|)
condition|)
block|{
comment|/* this is our child, send notification and free up this entry */
name|notifyAndFreeInfo
argument_list|(
operator|&
name|array
operator|->
name|header
argument_list|,
operator|&
name|array
operator|->
name|entries
index|[
name|i
index|]
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
block|}
block|}
name|array
operator|=
name|ffd_atomic_load
argument_list|(
operator|&
name|array
operator|->
name|header
operator|.
name|nextArray
argument_list|,
name|FFD_ATOMIC_ACQUIRE
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|old_sigaction
operator|.
name|sa_handler
operator|!=
name|SIG_IGN
operator|&&
name|old_sigaction
operator|.
name|sa_handler
operator|!=
name|SIG_DFL
condition|)
name|old_sigaction
operator|.
name|sa_handler
argument_list|(
name|signum
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|forkfd_initialize
specifier|static
name|void
name|forkfd_initialize
parameter_list|()
block|{
comment|/* install our signal handler */
name|struct
name|sigaction
name|action
decl_stmt|;
name|memset
argument_list|(
operator|&
name|action
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|action
argument_list|)
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|action
operator|.
name|sa_mask
argument_list|)
expr_stmt|;
name|action
operator|.
name|sa_flags
operator|=
name|SA_NOCLDSTOP
expr_stmt|;
name|action
operator|.
name|sa_handler
operator|=
name|sigchld_handler
expr_stmt|;
comment|/* ### RACE CONDITION      * The sigaction function does a memcpy from an internal buffer      * to old_sigaction, which we use in the SIGCHLD handler. If a      * SIGCHLD is delivered before or during that memcpy, the handler will      * see an inconsistent state.      *      * There is no solution. pthread_sigmask doesn't work here because the      * signal could be delivered to another thread.      */
name|sigaction
argument_list|(
name|SIGCHLD
argument_list|,
operator|&
name|action
argument_list|,
operator|&
name|old_sigaction
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|__GNUC__
name|atexit
argument_list|(
name|cleanup
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ffd_atomic_store
argument_list|(
operator|&
name|forkfd_status
argument_list|,
literal|1
argument_list|,
name|FFD_ATOMIC_RELAXED
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef
begin_macro
name|__attribute
argument_list|(
argument|(destructor, unused)
argument_list|)
end_macro
begin_function_decl
specifier|static
name|void
name|cleanup
parameter_list|()
function_decl|;
end_function_decl
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|cleanup
specifier|static
name|void
name|cleanup
parameter_list|()
block|{
name|BigArray
modifier|*
name|array
decl_stmt|;
comment|/* This function is not thread-safe!      * It must only be called when the process is shutting down.      * At shutdown, we expect no one to be calling forkfd(), so we don't      * need to be thread-safe with what is done there.      *      * But SIGCHLD might be delivered to any thread, including this one.      * There's no way to prevent that. The correct solution would be to      * cooperatively delete. We don't do that.      */
if|if
condition|(
name|ffd_atomic_load
argument_list|(
operator|&
name|forkfd_status
argument_list|,
name|FFD_ATOMIC_RELAXED
argument_list|)
operator|==
literal|0
condition|)
return|return;
comment|/* notify the handler that we're no longer in operation */
name|ffd_atomic_store
argument_list|(
operator|&
name|forkfd_status
argument_list|,
literal|0
argument_list|,
name|FFD_ATOMIC_RELAXED
argument_list|)
expr_stmt|;
comment|/* free any arrays we might have */
name|array
operator|=
name|children
operator|.
name|header
operator|.
name|nextArray
expr_stmt|;
while|while
condition|(
name|array
operator|!=
name|NULL
condition|)
block|{
name|BigArray
modifier|*
name|next
init|=
name|array
operator|->
name|header
operator|.
name|nextArray
decl_stmt|;
name|free
argument_list|(
name|array
argument_list|)
expr_stmt|;
name|array
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|create_pipe
specifier|static
name|int
name|create_pipe
parameter_list|(
name|int
name|filedes
index|[]
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_PIPE2
comment|/* use pipe2(2) whenever possible, since it can thread-safely create a      * cloexec pair of pipes. Without it, we have a race condition setting      * FD_CLOEXEC      */
name|ret
operator|=
name|pipe2
argument_list|(
name|filedes
argument_list|,
name|O_CLOEXEC
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
return|return
name|ret
return|;
if|if
condition|(
operator|(
name|flags
operator|&
name|FFD_CLOEXEC
operator|)
operator|==
literal|0
condition|)
name|fcntl
argument_list|(
name|filedes
index|[
literal|0
index|]
argument_list|,
name|F_SETFD
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|ret
operator|=
name|pipe
argument_list|(
name|filedes
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
return|return
name|ret
return|;
name|fcntl
argument_list|(
name|filedes
index|[
literal|1
index|]
argument_list|,
name|F_SETFD
argument_list|,
name|FD_CLOEXEC
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|FFD_CLOEXEC
condition|)
name|fcntl
argument_list|(
name|filedes
index|[
literal|0
index|]
argument_list|,
name|F_SETFD
argument_list|,
name|FD_CLOEXEC
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|flags
operator|&
name|FFD_NONBLOCK
condition|)
name|fcntl
argument_list|(
name|filedes
index|[
literal|0
index|]
argument_list|,
name|F_SETFL
argument_list|,
name|fcntl
argument_list|(
name|filedes
index|[
literal|0
index|]
argument_list|,
name|F_GETFL
argument_list|)
operator||
name|O_NONBLOCK
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_comment
comment|/**  * @brief forkfd returns a file descriptor representing a child process  * @return a file descriptor, or -1 in case of failure  *  * forkfd() creates a file descriptor that can be used to be notified of when a  * child process exits. This file descriptor can be monitored using select(2),  * poll(2) or similar mechanisms.  *  * The @a flags parameter can contain the following values ORed to change the  * behaviour of forkfd():  *  * @li @c FFD_NONBLOCK Set the O_NONBLOCK file status flag on the new open file  * descriptor. Using this flag saves extra calls to fnctl(2) to achieve the same  * result.  *  * @li @c FFD_CLOEXEC Set the close-on-exec (FD_CLOEXEC) flag on the new file  * descriptor. You probably want to set this flag, since forkfd() does not work  * if the original parent process dies.  *  * The file descriptor returned by forkfd() supports the following operations:  *  * @li read(2) When the child process exits, then the buffer supplied to  * read(2) is used to return information about the status of the child in the  * form of one @c siginfo_t structure. The buffer must be at least  * sizeof(siginfo_t) bytes. The return value of read(2) is the total number of  * bytes read.  *  * @li poll(2), select(2) (and similar) The file descriptor is readable (the  * select(2) readfds argument; the poll(2) POLLIN flag) if the child has exited  * or signalled via SIGCHLD.  *  * @li close(2) When the file descriptor is no longer required it should be closed.  */
end_comment
begin_function
DECL|function|forkfd
name|int
name|forkfd
parameter_list|(
name|int
name|flags
parameter_list|,
name|pid_t
modifier|*
name|ppid
parameter_list|)
block|{
name|Header
modifier|*
name|header
decl_stmt|;
name|ProcessInfo
modifier|*
name|info
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
name|int
name|fd
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|death_pipe
index|[
literal|2
index|]
decl_stmt|;
name|int
name|sync_pipe
index|[
literal|2
index|]
decl_stmt|;
name|int
name|ret
decl_stmt|;
ifdef|#
directive|ifdef
name|__linux__
name|int
name|efd
decl_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|pthread_once
argument_list|(
operator|&
name|forkfd_initialization
argument_list|,
name|forkfd_initialize
argument_list|)
expr_stmt|;
name|info
operator|=
name|allocateInfo
argument_list|(
operator|&
name|header
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|ENOMEM
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* create the pipes before we fork */
if|if
condition|(
name|create_pipe
argument_list|(
name|death_pipe
argument_list|,
name|flags
argument_list|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|err_free
goto|;
comment|/* failed to create the pipes, pass errno */
ifdef|#
directive|ifdef
name|HAVE_EVENTFD
comment|/* try using an eventfd, which consumes less resources */
name|efd
operator|=
name|eventfd
argument_list|(
literal|0
argument_list|,
name|EFD_CLOEXEC
argument_list|)
expr_stmt|;
if|if
condition|(
name|efd
operator|==
operator|-
literal|1
condition|)
endif|#
directive|endif
block|{
comment|/* try a pipe */
if|if
condition|(
name|create_pipe
argument_list|(
name|sync_pipe
argument_list|,
name|O_CLOEXEC
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* failed both at eventfd and pipe; fail and pass errno */
goto|goto
name|err_close
goto|;
block|}
block|}
comment|/* now fork */
name|pid
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
goto|goto
name|err_close2
goto|;
comment|/* failed to fork, pass errno */
if|if
condition|(
name|ppid
condition|)
operator|*
name|ppid
operator|=
name|pid
expr_stmt|;
comment|/*      * We need to store the child's PID in the info structure, so      * the SIGCHLD handler knows that this child is present and it      * knows the writing end of the pipe to pass information on.      * However, the child process could exit before we stored the      * information (or the handler could run for other children exiting).      * We prevent that from happening by blocking the child process in      * a read(2) until we're finished storing the information.      */
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
comment|/* this is the child process */
comment|/* first, wait for the all clear */
ifdef|#
directive|ifdef
name|HAVE_EVENTFD
if|if
condition|(
name|efd
operator|!=
operator|-
literal|1
condition|)
block|{
name|eventfd_t
name|val64
decl_stmt|;
name|EINTR_LOOP
argument_list|(
name|ret
argument_list|,
name|eventfd_read
argument_list|(
name|efd
argument_list|,
operator|&
name|val64
argument_list|)
argument_list|)
expr_stmt|;
name|EINTR_LOOP
argument_list|(
name|ret
argument_list|,
name|close
argument_list|(
name|efd
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|char
name|c
decl_stmt|;
name|EINTR_LOOP
argument_list|(
name|ret
argument_list|,
name|close
argument_list|(
name|sync_pipe
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|EINTR_LOOP
argument_list|(
name|ret
argument_list|,
name|read
argument_list|(
name|sync_pipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|EINTR_LOOP
argument_list|(
name|ret
argument_list|,
name|close
argument_list|(
name|sync_pipe
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* now close the pipes and return to the caller */
name|EINTR_LOOP
argument_list|(
name|ret
argument_list|,
name|close
argument_list|(
name|death_pipe
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|EINTR_LOOP
argument_list|(
name|ret
argument_list|,
name|close
argument_list|(
name|death_pipe
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|fd
operator|=
name|FFD_CHILD_PROCESS
expr_stmt|;
block|}
else|else
block|{
comment|/* parent process */
name|info
operator|->
name|deathPipe
operator|=
name|death_pipe
index|[
literal|1
index|]
expr_stmt|;
name|fd
operator|=
name|death_pipe
index|[
literal|0
index|]
expr_stmt|;
name|ffd_atomic_store
argument_list|(
operator|&
name|info
operator|->
name|pid
argument_list|,
name|pid
argument_list|,
name|FFD_ATOMIC_RELEASE
argument_list|)
expr_stmt|;
comment|/* release the child */
ifdef|#
directive|ifdef
name|HAVE_EVENTFD
if|if
condition|(
name|efd
operator|!=
operator|-
literal|1
condition|)
block|{
name|eventfd_t
name|val64
init|=
literal|42
decl_stmt|;
name|EINTR_LOOP
argument_list|(
name|ret
argument_list|,
name|eventfd_write
argument_list|(
name|efd
argument_list|,
name|val64
argument_list|)
argument_list|)
expr_stmt|;
name|EINTR_LOOP
argument_list|(
name|ret
argument_list|,
name|close
argument_list|(
name|efd
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
comment|/*              * Usually, closing would be enough to make read(2) return and the child process              * continue. We need to write here: another thread could be calling forkfd at the              * same time, which means auxpipe[1] might be open in another child process.              */
name|EINTR_LOOP
argument_list|(
name|ret
argument_list|,
name|close
argument_list|(
name|sync_pipe
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|EINTR_LOOP
argument_list|(
name|ret
argument_list|,
name|write
argument_list|(
name|sync_pipe
index|[
literal|1
index|]
argument_list|,
literal|""
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|EINTR_LOOP
argument_list|(
name|ret
argument_list|,
name|close
argument_list|(
name|sync_pipe
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|fd
return|;
name|err_close2
label|:
ifdef|#
directive|ifdef
name|HAVE_EVENTFD
if|if
condition|(
name|efd
operator|!=
operator|-
literal|1
condition|)
block|{
name|EINTR_LOOP
argument_list|(
name|ret
argument_list|,
name|close
argument_list|(
name|efd
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|EINTR_LOOP
argument_list|(
name|ret
argument_list|,
name|close
argument_list|(
name|sync_pipe
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|EINTR_LOOP
argument_list|(
name|ret
argument_list|,
name|close
argument_list|(
name|sync_pipe
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|err_close
label|:
name|EINTR_LOOP
argument_list|(
name|ret
argument_list|,
name|close
argument_list|(
name|death_pipe
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|EINTR_LOOP
argument_list|(
name|ret
argument_list|,
name|close
argument_list|(
name|death_pipe
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|err_free
label|:
comment|/* free the info pointer */
name|freeInfo
argument_list|(
name|header
argument_list|,
name|info
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function
end_unit
