begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2015 Intel Corporation ** Copyright (C) 2015 KlarÃ¤lvdalens Datakonsult AB, a KDAB Group company, info@kdab.com ** ** Permission is hereby granted, free of charge, to any person obtaining a copy ** of this software and associated documentation files (the "Software"), to deal ** in the Software without restriction, including without limitation the rights ** to use, copy, modify, merge, publish, distribute, sublicense, and/or sell ** copies of the Software, and to permit persons to whom the Software is ** furnished to do so, subject to the following conditions: ** ** The above copyright notice and this permission notice shall be included in ** all copies or substantial portions of the Software. ** ** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR ** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, ** FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE ** AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER ** LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, ** OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN ** THE SOFTWARE. ** ****************************************************************************/
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|_GNU_SOURCE
end_ifndef
begin_define
DECL|macro|_GNU_SOURCE
define|#
directive|define
name|_GNU_SOURCE
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|"forkfd.h"
end_include
begin_include
include|#
directive|include
file|<sys/types.h>
end_include
begin_include
include|#
directive|include
file|<sys/time.h>
end_include
begin_include
include|#
directive|include
file|<sys/resource.h>
end_include
begin_include
include|#
directive|include
file|<sys/wait.h>
end_include
begin_include
include|#
directive|include
file|<assert.h>
end_include
begin_include
include|#
directive|include
file|<errno.h>
end_include
begin_include
include|#
directive|include
file|<pthread.h>
end_include
begin_include
include|#
directive|include
file|<signal.h>
end_include
begin_include
include|#
directive|include
file|<stdlib.h>
end_include
begin_include
include|#
directive|include
file|<string.h>
end_include
begin_include
include|#
directive|include
file|<time.h>
end_include
begin_include
include|#
directive|include
file|<unistd.h>
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|__linux__
end_ifdef
begin_define
DECL|macro|HAVE_WAIT4
define|#
directive|define
name|HAVE_WAIT4
value|1
end_define
begin_if
if|#
directive|if
name|defined
argument_list|(
name|__BIONIC__
argument_list|)
operator|||
operator|(
name|defined
argument_list|(
name|__GLIBC__
argument_list|)
operator|&&
operator|(
name|__GLIBC__
operator|<<
literal|8
operator|)
operator|+
name|__GLIBC_MINOR__
operator|>=
literal|0x207
operator|&&
expr|\
operator|(
operator|!
name|defined
argument_list|(
name|__UCLIBC__
argument_list|)
operator|||
operator|(
operator|(
name|__UCLIBC_MAJOR__
operator|<<
literal|16
operator|)
operator|+
operator|(
name|__UCLIBC_MINOR__
operator|<<
literal|8
operator|)
operator|+
name|__UCLIBC_SUBLEVEL__
operator|>
literal|0x921
operator|)
operator|)
operator|)
end_if
begin_include
include|#
directive|include
file|<sys/eventfd.h>
end_include
begin_define
DECL|macro|HAVE_EVENTFD
define|#
directive|define
name|HAVE_EVENTFD
value|1
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|__BIONIC__
argument_list|)
operator|||
operator|(
name|defined
argument_list|(
name|__GLIBC__
argument_list|)
operator|&&
operator|(
name|__GLIBC__
operator|<<
literal|8
operator|)
operator|+
name|__GLIBC_MINOR__
operator|>=
literal|0x209
operator|&&
expr|\
operator|(
operator|!
name|defined
argument_list|(
name|__UCLIBC__
argument_list|)
operator|||
operator|(
operator|(
name|__UCLIBC_MAJOR__
operator|<<
literal|16
operator|)
operator|+
operator|(
name|__UCLIBC_MINOR__
operator|<<
literal|8
operator|)
operator|+
name|__UCLIBC_SUBLEVEL__
operator|>
literal|0x921
operator|)
operator|)
operator|)
end_if
begin_define
DECL|macro|HAVE_PIPE2
define|#
directive|define
name|HAVE_PIPE2
value|1
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|_POSIX_VERSION
operator|-
literal|0
operator|>=
literal|200809L
operator|||
name|_XOPEN_VERSION
operator|-
literal|0
operator|>=
literal|500
end_if
begin_define
DECL|macro|HAVE_WAITID
define|#
directive|define
name|HAVE_WAITID
value|1
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if
begin_define
DECL|macro|HAVE_PIPE2
define|#
directive|define
name|HAVE_PIPE2
value|1
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__DragonFly__
argument_list|)
operator|||
name|defined
argument_list|(
name|__FreeBSD_kernel__
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__APPLE__
argument_list|)
end_if
begin_define
DECL|macro|HAVE_WAIT4
define|#
directive|define
name|HAVE_WAIT4
value|1
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
end_if
begin_comment
comment|/* Up until OS X 10.7, waitid(P_ALL, ...) will return success, but will not  * fill in the details of the dead child. That means waitid is not useful to us.  * Therefore, we only enable waitid() support if we're targetting OS X 10.8 or  * later.  */
end_comment
begin_include
include|#
directive|include
file|<Availability.h>
end_include
begin_include
include|#
directive|include
file|<AvailabilityMacros.h>
end_include
begin_if
if|#
directive|if
name|MAC_OS_X_VERSION_MIN_REQUIRED
operator|<=
literal|1070
end_if
begin_define
DECL|macro|HAVE_BROKEN_WAITID
define|#
directive|define
name|HAVE_BROKEN_WAITID
value|1
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|FFD_ATOMIC_RELAXED
end_ifndef
begin_include
include|#
directive|include
file|"forkfd_gcc.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|CHILDREN_IN_SMALL_ARRAY
define|#
directive|define
name|CHILDREN_IN_SMALL_ARRAY
value|16
end_define
begin_define
DECL|macro|CHILDREN_IN_BIG_ARRAY
define|#
directive|define
name|CHILDREN_IN_BIG_ARRAY
value|256
end_define
begin_define
DECL|macro|sizeofarray
define|#
directive|define
name|sizeofarray
parameter_list|(
name|array
parameter_list|)
value|(sizeof(array)/sizeof(array[0]))
end_define
begin_define
DECL|macro|EINTR_LOOP
define|#
directive|define
name|EINTR_LOOP
parameter_list|(
name|ret
parameter_list|,
name|call
parameter_list|)
define|\
value|do {                      \         ret = call;           \     } while (ret == -1&& errno == EINTR)
end_define
begin_struct
DECL|struct|pipe_payload
struct|struct
name|pipe_payload
block|{
DECL|member|info
name|struct
name|forkfd_info
name|info
decl_stmt|;
DECL|member|rusage
name|struct
name|rusage
name|rusage
decl_stmt|;
block|}
struct|;
end_struct
begin_typedef
DECL|struct|process_info
typedef|typedef
struct|struct
name|process_info
block|{
DECL|member|pid
name|ffd_atomic_int
name|pid
decl_stmt|;
DECL|member|deathPipe
name|int
name|deathPipe
decl_stmt|;
block|}
DECL|typedef|ProcessInfo
name|ProcessInfo
typedef|;
end_typedef
begin_struct_decl
struct_decl|struct
name|BigArray
struct_decl|;
end_struct_decl
begin_typedef
DECL|struct|Header
typedef|typedef
struct|struct
name|Header
block|{
DECL|member|nextArray
name|ffd_atomic_pointer
argument_list|(
argument|struct BigArray
argument_list|)
name|nextArray
expr_stmt|;
DECL|member|busyCount
name|ffd_atomic_int
name|busyCount
decl_stmt|;
block|}
DECL|typedef|Header
name|Header
typedef|;
end_typedef
begin_typedef
DECL|struct|BigArray
typedef|typedef
struct|struct
name|BigArray
block|{
DECL|member|header
name|Header
name|header
decl_stmt|;
DECL|member|entries
name|ProcessInfo
name|entries
index|[
name|CHILDREN_IN_BIG_ARRAY
index|]
decl_stmt|;
block|}
DECL|typedef|BigArray
name|BigArray
typedef|;
end_typedef
begin_typedef
DECL|struct|SmallArray
typedef|typedef
struct|struct
name|SmallArray
block|{
DECL|member|header
name|Header
name|header
decl_stmt|;
DECL|member|entries
name|ProcessInfo
name|entries
index|[
name|CHILDREN_IN_SMALL_ARRAY
index|]
decl_stmt|;
block|}
DECL|typedef|SmallArray
name|SmallArray
typedef|;
end_typedef
begin_decl_stmt
DECL|variable|children
specifier|static
name|SmallArray
name|children
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|old_sigaction
specifier|static
name|struct
name|sigaction
name|old_sigaction
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|forkfd_initialization
specifier|static
name|pthread_once_t
name|forkfd_initialization
init|=
name|PTHREAD_ONCE_INIT
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|forkfd_status
specifier|static
name|ffd_atomic_int
name|forkfd_status
init|=
name|FFD_ATOMIC_INIT
argument_list|(
literal|0
argument_list|)
decl_stmt|;
end_decl_stmt
begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_BROKEN_WAITID
end_ifdef
begin_decl_stmt
DECL|variable|waitid_works
specifier|static
name|int
name|waitid_works
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_else
else|#
directive|else
end_else
begin_decl_stmt
DECL|variable|waitid_works
specifier|static
specifier|const
name|int
name|waitid_works
init|=
literal|1
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|tryAllocateInSection
specifier|static
name|ProcessInfo
modifier|*
name|tryAllocateInSection
parameter_list|(
name|Header
modifier|*
name|header
parameter_list|,
name|ProcessInfo
name|entries
index|[]
parameter_list|,
name|int
name|maxCount
parameter_list|)
block|{
comment|/* we use ACQUIRE here because the signal handler might have released the PID */
name|int
name|busyCount
init|=
name|ffd_atomic_add_fetch
argument_list|(
operator|&
name|header
operator|->
name|busyCount
argument_list|,
literal|1
argument_list|,
name|FFD_ATOMIC_ACQUIRE
argument_list|)
decl_stmt|;
if|if
condition|(
name|busyCount
operator|<=
name|maxCount
condition|)
block|{
comment|/* there's an available entry in this section, find it and take it */
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|maxCount
condition|;
operator|++
name|i
control|)
block|{
comment|/* if the PID is 0, it's free; mark it as used by swapping it with -1 */
name|int
name|expected_pid
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ffd_atomic_compare_exchange
argument_list|(
operator|&
name|entries
index|[
name|i
index|]
operator|.
name|pid
argument_list|,
operator|&
name|expected_pid
argument_list|,
operator|-
literal|1
argument_list|,
name|FFD_ATOMIC_RELAXED
argument_list|,
name|FFD_ATOMIC_RELAXED
argument_list|)
condition|)
return|return
operator|&
name|entries
index|[
name|i
index|]
return|;
block|}
block|}
comment|/* there isn't an available entry, undo our increment */
name|ffd_atomic_add_fetch
argument_list|(
operator|&
name|header
operator|->
name|busyCount
argument_list|,
operator|-
literal|1
argument_list|,
name|FFD_ATOMIC_RELAXED
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function
begin_function
DECL|function|allocateInfo
specifier|static
name|ProcessInfo
modifier|*
name|allocateInfo
parameter_list|(
name|Header
modifier|*
modifier|*
name|header
parameter_list|)
block|{
name|Header
modifier|*
name|currentHeader
init|=
operator|&
name|children
operator|.
name|header
decl_stmt|;
comment|/* try to find an available entry in the small array first */
name|ProcessInfo
modifier|*
name|info
init|=
name|tryAllocateInSection
argument_list|(
name|currentHeader
argument_list|,
name|children
operator|.
name|entries
argument_list|,
name|sizeofarray
argument_list|(
name|children
operator|.
name|entries
argument_list|)
argument_list|)
decl_stmt|;
comment|/* go on to the next arrays */
while|while
condition|(
name|info
operator|==
name|NULL
condition|)
block|{
name|BigArray
modifier|*
name|array
init|=
name|ffd_atomic_load
argument_list|(
operator|&
name|currentHeader
operator|->
name|nextArray
argument_list|,
name|FFD_ATOMIC_ACQUIRE
argument_list|)
decl_stmt|;
if|if
condition|(
name|array
operator|==
name|NULL
condition|)
block|{
comment|/* allocate an array and try to use it */
name|BigArray
modifier|*
name|allocatedArray
init|=
operator|(
name|BigArray
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|BigArray
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|allocatedArray
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|ffd_atomic_compare_exchange
argument_list|(
operator|&
name|currentHeader
operator|->
name|nextArray
argument_list|,
operator|&
name|array
argument_list|,
name|allocatedArray
argument_list|,
name|FFD_ATOMIC_RELEASE
argument_list|,
name|FFD_ATOMIC_ACQUIRE
argument_list|)
condition|)
block|{
comment|/* success */
name|array
operator|=
name|allocatedArray
expr_stmt|;
block|}
else|else
block|{
comment|/* failed, the atomic updated 'array' */
name|free
argument_list|(
name|allocatedArray
argument_list|)
expr_stmt|;
block|}
block|}
name|currentHeader
operator|=
operator|&
name|array
operator|->
name|header
expr_stmt|;
name|info
operator|=
name|tryAllocateInSection
argument_list|(
name|currentHeader
argument_list|,
name|array
operator|->
name|entries
argument_list|,
name|sizeofarray
argument_list|(
name|array
operator|->
name|entries
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|*
name|header
operator|=
name|currentHeader
expr_stmt|;
return|return
name|info
return|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_WAITID
end_ifdef
begin_function
DECL|function|isChildReady
specifier|static
name|int
name|isChildReady
parameter_list|(
name|pid_t
name|pid
parameter_list|,
name|siginfo_t
modifier|*
name|info
parameter_list|)
block|{
name|info
operator|->
name|si_pid
operator|=
literal|0
expr_stmt|;
return|return
name|waitid
argument_list|(
name|P_PID
argument_list|,
name|pid
argument_list|,
name|info
argument_list|,
name|WEXITED
operator||
name|WNOHANG
operator||
name|WNOWAIT
argument_list|)
operator|==
literal|0
operator|&&
name|info
operator|->
name|si_pid
operator|==
name|pid
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|convertStatusToForkfdInfo
specifier|static
name|void
name|convertStatusToForkfdInfo
parameter_list|(
name|int
name|status
parameter_list|,
name|struct
name|forkfd_info
modifier|*
name|info
parameter_list|)
block|{
if|if
condition|(
name|WIFEXITED
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|info
operator|->
name|code
operator|=
name|CLD_EXITED
expr_stmt|;
name|info
operator|->
name|status
operator|=
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|WIFSIGNALED
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|info
operator|->
name|code
operator|=
name|CLD_KILLED
expr_stmt|;
ifdef|#
directive|ifdef
name|WCOREDUMP
if|if
condition|(
name|WCOREDUMP
argument_list|(
name|status
argument_list|)
condition|)
name|info
operator|->
name|code
operator|=
name|CLD_DUMPED
expr_stmt|;
endif|#
directive|endif
name|info
operator|->
name|status
operator|=
name|WTERMSIG
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|tryReaping
specifier|static
name|int
name|tryReaping
parameter_list|(
name|pid_t
name|pid
parameter_list|,
name|struct
name|pipe_payload
modifier|*
name|payload
parameter_list|)
block|{
comment|/* reap the child */
if|#
directive|if
name|defined
argument_list|(
name|HAVE_WAIT4
argument_list|)
name|int
name|status
decl_stmt|;
if|if
condition|(
name|wait4
argument_list|(
name|pid
argument_list|,
operator|&
name|status
argument_list|,
name|WNOHANG
argument_list|,
operator|&
name|payload
operator|->
name|rusage
argument_list|)
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
name|convertStatusToForkfdInfo
argument_list|(
name|status
argument_list|,
operator|&
name|payload
operator|->
name|info
argument_list|)
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|HAVE_WAITID
argument_list|)
if|if
condition|(
name|waitid_works
condition|)
block|{
comment|/* we have waitid(2), which gets us some payload values on some systems */
name|siginfo_t
name|info
decl_stmt|;
name|info
operator|.
name|si_pid
operator|=
literal|0
expr_stmt|;
name|int
name|ret
init|=
name|waitid
argument_list|(
name|P_PID
argument_list|,
name|pid
argument_list|,
operator|&
name|info
argument_list|,
name|WEXITED
operator||
name|WNOHANG
argument_list|)
operator|==
literal|0
operator|&&
name|info
operator|.
name|si_pid
operator|==
name|pid
decl_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
return|return
name|ret
return|;
name|payload
operator|->
name|info
operator|.
name|code
operator|=
name|info
operator|.
name|si_code
expr_stmt|;
name|payload
operator|->
name|info
operator|.
name|status
operator|=
name|info
operator|.
name|si_status
expr_stmt|;
ifdef|#
directive|ifdef
name|__linux__
name|payload
operator|->
name|rusage
operator|.
name|ru_utime
operator|.
name|tv_sec
operator|=
name|info
operator|.
name|si_utime
operator|/
name|CLOCKS_PER_SEC
expr_stmt|;
name|payload
operator|->
name|rusage
operator|.
name|ru_utime
operator|.
name|tv_usec
operator|=
name|info
operator|.
name|si_utime
operator|%
name|CLOCKS_PER_SEC
expr_stmt|;
name|payload
operator|->
name|rusage
operator|.
name|ru_stime
operator|.
name|tv_sec
operator|=
name|info
operator|.
name|si_stime
operator|/
name|CLOCKS_PER_SEC
expr_stmt|;
name|payload
operator|->
name|rusage
operator|.
name|ru_stime
operator|.
name|tv_usec
operator|=
name|info
operator|.
name|si_stime
operator|%
name|CLOCKS_PER_SEC
expr_stmt|;
endif|#
directive|endif
return|return
literal|1
return|;
block|}
endif|#
directive|endif
comment|// HAVE_WAITID
name|int
name|status
decl_stmt|;
if|if
condition|(
name|waitpid
argument_list|(
name|pid
argument_list|,
operator|&
name|status
argument_list|,
name|WNOHANG
argument_list|)
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
comment|// child did not change state
name|convertStatusToForkfdInfo
argument_list|(
name|status
argument_list|,
operator|&
name|payload
operator|->
name|info
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// !HAVE_WAIT4
return|return
literal|1
return|;
block|}
end_function
begin_function
DECL|function|freeInfo
specifier|static
name|void
name|freeInfo
parameter_list|(
name|Header
modifier|*
name|header
parameter_list|,
name|ProcessInfo
modifier|*
name|entry
parameter_list|)
block|{
name|entry
operator|->
name|deathPipe
operator|=
operator|-
literal|1
expr_stmt|;
name|entry
operator|->
name|pid
operator|=
literal|0
expr_stmt|;
name|ffd_atomic_add_fetch
argument_list|(
operator|&
name|header
operator|->
name|busyCount
argument_list|,
operator|-
literal|1
argument_list|,
name|FFD_ATOMIC_RELEASE
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|header
operator|->
name|busyCount
operator|>=
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|notifyAndFreeInfo
specifier|static
name|void
name|notifyAndFreeInfo
parameter_list|(
name|Header
modifier|*
name|header
parameter_list|,
name|ProcessInfo
modifier|*
name|entry
parameter_list|,
specifier|const
name|struct
name|pipe_payload
modifier|*
name|payload
parameter_list|)
block|{
name|ssize_t
name|ret
decl_stmt|;
name|EINTR_LOOP
argument_list|(
name|ret
argument_list|,
name|write
argument_list|(
name|entry
operator|->
name|deathPipe
argument_list|,
name|payload
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|payload
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|EINTR_LOOP
argument_list|(
name|ret
argument_list|,
name|close
argument_list|(
name|entry
operator|->
name|deathPipe
argument_list|)
argument_list|)
expr_stmt|;
name|freeInfo
argument_list|(
name|header
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|sigchld_handler
specifier|static
name|void
name|sigchld_handler
parameter_list|(
name|int
name|signum
parameter_list|)
block|{
comment|/*      * This is a signal handler, so we need to be careful about which functions      * we can call. See the full, official listing in the POSIX.1-2008      * specification at:      *   http://pubs.opengroup.org/onlinepubs/9699919799/functions/V2_chap02.html#tag_15_04_03      *      */
if|if
condition|(
name|ffd_atomic_load
argument_list|(
operator|&
name|forkfd_status
argument_list|,
name|FFD_ATOMIC_RELAXED
argument_list|)
operator|==
literal|1
condition|)
block|{
comment|/* is this one of our children? */
name|BigArray
modifier|*
name|array
decl_stmt|;
name|siginfo_t
name|info
decl_stmt|;
name|struct
name|pipe_payload
name|payload
decl_stmt|;
name|int
name|i
decl_stmt|;
name|memset
argument_list|(
operator|&
name|info
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|info
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|payload
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_WAITID
if|if
condition|(
operator|!
name|waitid_works
condition|)
goto|goto
name|search_arrays
goto|;
comment|/* be optimistic: try to see if we can get the child that exited */
name|search_next_child
label|:
comment|/* waitid returns -1 ECHILD if there are no further children at all;          * it returns 0 and sets si_pid to 0 if there are children but they are not ready          * to be waited (we're passing WNOHANG). We should not get EINTR because          * we're passing WNOHANG and we should definitely not get EINVAL or anything else.          * That means we can actually ignore the return code and only inspect si_pid.          */
name|info
operator|.
name|si_pid
operator|=
literal|0
expr_stmt|;
name|waitid
argument_list|(
name|P_ALL
argument_list|,
literal|0
argument_list|,
operator|&
name|info
argument_list|,
name|WNOHANG
operator||
name|WNOWAIT
operator||
name|WEXITED
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|si_pid
operator|==
literal|0
condition|)
block|{
comment|/* there are no further un-waited-for children, so we can just exit.              * But before, transfer control to the chained SIGCHLD handler.              */
goto|goto
name|chain_handler
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|sizeofarray
argument_list|(
name|children
operator|.
name|entries
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
comment|/* acquire the child first: swap the PID with -1 to indicate it's busy */
name|int
name|pid
init|=
name|info
operator|.
name|si_pid
decl_stmt|;
if|if
condition|(
name|ffd_atomic_compare_exchange
argument_list|(
operator|&
name|children
operator|.
name|entries
index|[
name|i
index|]
operator|.
name|pid
argument_list|,
operator|&
name|pid
argument_list|,
operator|-
literal|1
argument_list|,
name|FFD_ATOMIC_ACQUIRE
argument_list|,
name|FFD_ATOMIC_RELAXED
argument_list|)
condition|)
block|{
comment|/* this is our child, send notification and free up this entry */
comment|/* ### FIXME: what if tryReaping returns false? */
if|if
condition|(
name|tryReaping
argument_list|(
name|pid
argument_list|,
operator|&
name|payload
argument_list|)
condition|)
name|notifyAndFreeInfo
argument_list|(
operator|&
name|children
operator|.
name|header
argument_list|,
operator|&
name|children
operator|.
name|entries
index|[
name|i
index|]
argument_list|,
operator|&
name|payload
argument_list|)
expr_stmt|;
goto|goto
name|search_next_child
goto|;
block|}
block|}
comment|/* try the arrays */
name|array
operator|=
name|ffd_atomic_load
argument_list|(
operator|&
name|children
operator|.
name|header
operator|.
name|nextArray
argument_list|,
name|FFD_ATOMIC_ACQUIRE
argument_list|)
expr_stmt|;
while|while
condition|(
name|array
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|sizeofarray
argument_list|(
name|array
operator|->
name|entries
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|int
name|pid
init|=
name|info
operator|.
name|si_pid
decl_stmt|;
if|if
condition|(
name|ffd_atomic_compare_exchange
argument_list|(
operator|&
name|array
operator|->
name|entries
index|[
name|i
index|]
operator|.
name|pid
argument_list|,
operator|&
name|pid
argument_list|,
operator|-
literal|1
argument_list|,
name|FFD_ATOMIC_ACQUIRE
argument_list|,
name|FFD_ATOMIC_RELAXED
argument_list|)
condition|)
block|{
comment|/* this is our child, send notification and free up this entry */
comment|/* ### FIXME: what if tryReaping returns false? */
if|if
condition|(
name|tryReaping
argument_list|(
name|pid
argument_list|,
operator|&
name|payload
argument_list|)
condition|)
name|notifyAndFreeInfo
argument_list|(
operator|&
name|array
operator|->
name|header
argument_list|,
operator|&
name|array
operator|->
name|entries
index|[
name|i
index|]
argument_list|,
operator|&
name|payload
argument_list|)
expr_stmt|;
goto|goto
name|search_next_child
goto|;
block|}
block|}
name|array
operator|=
name|ffd_atomic_load
argument_list|(
operator|&
name|array
operator|->
name|header
operator|.
name|nextArray
argument_list|,
name|FFD_ATOMIC_ACQUIRE
argument_list|)
expr_stmt|;
block|}
comment|/* if we got here, we couldn't find this child in our list. That means this child          * belongs to one of the chained SIGCHLD handlers. However, there might be another          * child that exited and does belong to us, so we need to check each one individually.          */
name|search_arrays
label|:
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|sizeofarray
argument_list|(
name|children
operator|.
name|entries
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|int
name|pid
init|=
name|ffd_atomic_load
argument_list|(
operator|&
name|children
operator|.
name|entries
index|[
name|i
index|]
operator|.
name|pid
argument_list|,
name|FFD_ATOMIC_ACQUIRE
argument_list|)
decl_stmt|;
if|if
condition|(
name|pid
operator|<=
literal|0
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|HAVE_WAITID
if|if
condition|(
name|waitid_works
condition|)
block|{
comment|/* The child might have been reaped by the block above in another thread,                  * so first check if it's ready and, if it is, lock it */
if|if
condition|(
operator|!
name|isChildReady
argument_list|(
name|pid
argument_list|,
operator|&
name|info
argument_list|)
operator|||
operator|!
name|ffd_atomic_compare_exchange
argument_list|(
operator|&
name|children
operator|.
name|entries
index|[
name|i
index|]
operator|.
name|pid
argument_list|,
operator|&
name|pid
argument_list|,
operator|-
literal|1
argument_list|,
name|FFD_ATOMIC_RELAXED
argument_list|,
name|FFD_ATOMIC_RELAXED
argument_list|)
condition|)
continue|continue;
block|}
endif|#
directive|endif
if|if
condition|(
name|tryReaping
argument_list|(
name|pid
argument_list|,
operator|&
name|payload
argument_list|)
condition|)
block|{
comment|/* this is our child, send notification and free up this entry */
name|notifyAndFreeInfo
argument_list|(
operator|&
name|children
operator|.
name|header
argument_list|,
operator|&
name|children
operator|.
name|entries
index|[
name|i
index|]
argument_list|,
operator|&
name|payload
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* try the arrays */
name|array
operator|=
name|ffd_atomic_load
argument_list|(
operator|&
name|children
operator|.
name|header
operator|.
name|nextArray
argument_list|,
name|FFD_ATOMIC_ACQUIRE
argument_list|)
expr_stmt|;
while|while
condition|(
name|array
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|sizeofarray
argument_list|(
name|array
operator|->
name|entries
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|int
name|pid
init|=
name|ffd_atomic_load
argument_list|(
operator|&
name|array
operator|->
name|entries
index|[
name|i
index|]
operator|.
name|pid
argument_list|,
name|FFD_ATOMIC_ACQUIRE
argument_list|)
decl_stmt|;
if|if
condition|(
name|pid
operator|<=
literal|0
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|HAVE_WAITID
if|if
condition|(
name|waitid_works
condition|)
block|{
comment|/* The child might have been reaped by the block above in another thread,                      * so first check if it's ready and, if it is, lock it */
if|if
condition|(
operator|!
name|isChildReady
argument_list|(
name|pid
argument_list|,
operator|&
name|info
argument_list|)
operator|||
operator|!
name|ffd_atomic_compare_exchange
argument_list|(
operator|&
name|array
operator|->
name|entries
index|[
name|i
index|]
operator|.
name|pid
argument_list|,
operator|&
name|pid
argument_list|,
operator|-
literal|1
argument_list|,
name|FFD_ATOMIC_RELAXED
argument_list|,
name|FFD_ATOMIC_RELAXED
argument_list|)
condition|)
continue|continue;
block|}
endif|#
directive|endif
if|if
condition|(
name|tryReaping
argument_list|(
name|pid
argument_list|,
operator|&
name|payload
argument_list|)
condition|)
block|{
comment|/* this is our child, send notification and free up this entry */
name|notifyAndFreeInfo
argument_list|(
operator|&
name|array
operator|->
name|header
argument_list|,
operator|&
name|array
operator|->
name|entries
index|[
name|i
index|]
argument_list|,
operator|&
name|payload
argument_list|)
expr_stmt|;
block|}
block|}
name|array
operator|=
name|ffd_atomic_load
argument_list|(
operator|&
name|array
operator|->
name|header
operator|.
name|nextArray
argument_list|,
name|FFD_ATOMIC_ACQUIRE
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|HAVE_WAITID
name|chain_handler
label|:
endif|#
directive|endif
if|if
condition|(
name|old_sigaction
operator|.
name|sa_handler
operator|!=
name|SIG_IGN
operator|&&
name|old_sigaction
operator|.
name|sa_handler
operator|!=
name|SIG_DFL
condition|)
name|old_sigaction
operator|.
name|sa_handler
argument_list|(
name|signum
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|forkfd_initialize
specifier|static
name|void
name|forkfd_initialize
parameter_list|()
block|{
if|#
directive|if
name|defined
argument_list|(
name|HAVE_BROKEN_WAITID
argument_list|)
name|pid_t
name|pid
init|=
name|fork
argument_list|()
decl_stmt|;
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
name|_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pid
operator|>
literal|0
condition|)
block|{
name|siginfo_t
name|info
decl_stmt|;
name|waitid
argument_list|(
name|P_ALL
argument_list|,
literal|0
argument_list|,
operator|&
name|info
argument_list|,
name|WNOWAIT
operator||
name|WEXITED
argument_list|)
expr_stmt|;
name|waitid_works
operator|=
operator|(
name|info
operator|.
name|si_pid
operator|!=
literal|0
operator|)
expr_stmt|;
name|info
operator|.
name|si_pid
operator|=
literal|0
expr_stmt|;
comment|// now really reap the child
name|waitid
argument_list|(
name|P_PID
argument_list|,
name|pid
argument_list|,
operator|&
name|info
argument_list|,
name|WEXITED
argument_list|)
expr_stmt|;
name|waitid_works
operator|=
name|waitid_works
operator|&&
operator|(
name|info
operator|.
name|si_pid
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* install our signal handler */
name|struct
name|sigaction
name|action
decl_stmt|;
name|memset
argument_list|(
operator|&
name|action
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|action
argument_list|)
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|action
operator|.
name|sa_mask
argument_list|)
expr_stmt|;
name|action
operator|.
name|sa_flags
operator|=
name|SA_NOCLDSTOP
expr_stmt|;
name|action
operator|.
name|sa_handler
operator|=
name|sigchld_handler
expr_stmt|;
comment|/* ### RACE CONDITION      * The sigaction function does a memcpy from an internal buffer      * to old_sigaction, which we use in the SIGCHLD handler. If a      * SIGCHLD is delivered before or during that memcpy, the handler will      * see an inconsistent state.      *      * There is no solution. pthread_sigmask doesn't work here because the      * signal could be delivered to another thread.      */
name|sigaction
argument_list|(
name|SIGCHLD
argument_list|,
operator|&
name|action
argument_list|,
operator|&
name|old_sigaction
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|__GNUC__
name|atexit
argument_list|(
name|cleanup
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ffd_atomic_store
argument_list|(
operator|&
name|forkfd_status
argument_list|,
literal|1
argument_list|,
name|FFD_ATOMIC_RELAXED
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef
begin_macro
name|__attribute
argument_list|(
argument|(destructor, unused)
argument_list|)
end_macro
begin_function_decl
specifier|static
name|void
name|cleanup
parameter_list|()
function_decl|;
end_function_decl
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|cleanup
specifier|static
name|void
name|cleanup
parameter_list|()
block|{
name|BigArray
modifier|*
name|array
decl_stmt|;
comment|/* This function is not thread-safe!      * It must only be called when the process is shutting down.      * At shutdown, we expect no one to be calling forkfd(), so we don't      * need to be thread-safe with what is done there.      *      * But SIGCHLD might be delivered to any thread, including this one.      * There's no way to prevent that. The correct solution would be to      * cooperatively delete. We don't do that.      */
if|if
condition|(
name|ffd_atomic_load
argument_list|(
operator|&
name|forkfd_status
argument_list|,
name|FFD_ATOMIC_RELAXED
argument_list|)
operator|==
literal|0
condition|)
return|return;
comment|/* notify the handler that we're no longer in operation */
name|ffd_atomic_store
argument_list|(
operator|&
name|forkfd_status
argument_list|,
literal|0
argument_list|,
name|FFD_ATOMIC_RELAXED
argument_list|)
expr_stmt|;
comment|/* free any arrays we might have */
name|array
operator|=
name|children
operator|.
name|header
operator|.
name|nextArray
expr_stmt|;
while|while
condition|(
name|array
operator|!=
name|NULL
condition|)
block|{
name|BigArray
modifier|*
name|next
init|=
name|array
operator|->
name|header
operator|.
name|nextArray
decl_stmt|;
name|free
argument_list|(
name|array
argument_list|)
expr_stmt|;
name|array
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|create_pipe
specifier|static
name|int
name|create_pipe
parameter_list|(
name|int
name|filedes
index|[]
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_PIPE2
comment|/* use pipe2(2) whenever possible, since it can thread-safely create a      * cloexec pair of pipes. Without it, we have a race condition setting      * FD_CLOEXEC      */
name|ret
operator|=
name|pipe2
argument_list|(
name|filedes
argument_list|,
name|O_CLOEXEC
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
return|return
name|ret
return|;
if|if
condition|(
operator|(
name|flags
operator|&
name|FFD_CLOEXEC
operator|)
operator|==
literal|0
condition|)
name|fcntl
argument_list|(
name|filedes
index|[
literal|0
index|]
argument_list|,
name|F_SETFD
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|ret
operator|=
name|pipe
argument_list|(
name|filedes
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
return|return
name|ret
return|;
name|fcntl
argument_list|(
name|filedes
index|[
literal|1
index|]
argument_list|,
name|F_SETFD
argument_list|,
name|FD_CLOEXEC
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|FFD_CLOEXEC
condition|)
name|fcntl
argument_list|(
name|filedes
index|[
literal|0
index|]
argument_list|,
name|F_SETFD
argument_list|,
name|FD_CLOEXEC
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|flags
operator|&
name|FFD_NONBLOCK
condition|)
name|fcntl
argument_list|(
name|filedes
index|[
literal|0
index|]
argument_list|,
name|F_SETFL
argument_list|,
name|fcntl
argument_list|(
name|filedes
index|[
literal|0
index|]
argument_list|,
name|F_GETFL
argument_list|)
operator||
name|O_NONBLOCK
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|system_has_forkfd
specifier|static
specifier|const
name|int
name|system_has_forkfd
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|system_forkfd
specifier|static
name|int
name|system_forkfd
parameter_list|(
name|int
name|flags
parameter_list|,
name|pid_t
modifier|*
name|ppid
parameter_list|)
block|{
operator|(
name|void
operator|)
name|flags
expr_stmt|;
operator|(
name|void
operator|)
name|ppid
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|FORKFD_NO_FORKFD
end_ifndef
begin_comment
comment|/**  * @brief forkfd returns a file descriptor representing a child process  * @return a file descriptor, or -1 in case of failure  *  * forkfd() creates a file descriptor that can be used to be notified of when a  * child process exits. This file descriptor can be monitored using select(2),  * poll(2) or similar mechanisms.  *  * The @a flags parameter can contain the following values ORed to change the  * behaviour of forkfd():  *  * @li @c FFD_NONBLOCK Set the O_NONBLOCK file status flag on the new open file  * descriptor. Using this flag saves extra calls to fnctl(2) to achieve the same  * result.  *  * @li @c FFD_CLOEXEC Set the close-on-exec (FD_CLOEXEC) flag on the new file  * descriptor. You probably want to set this flag, since forkfd() does not work  * if the original parent process dies.  *  * The file descriptor returned by forkfd() supports the following operations:  *  * @li read(2) When the child process exits, then the buffer supplied to  * read(2) is used to return information about the status of the child in the  * form of one @c siginfo_t structure. The buffer must be at least  * sizeof(siginfo_t) bytes. The return value of read(2) is the total number of  * bytes read.  *  * @li poll(2), select(2) (and similar) The file descriptor is readable (the  * select(2) readfds argument; the poll(2) POLLIN flag) if the child has exited  * or signalled via SIGCHLD.  *  * @li close(2) When the file descriptor is no longer required it should be closed.  */
end_comment
begin_function
DECL|function|forkfd
name|int
name|forkfd
parameter_list|(
name|int
name|flags
parameter_list|,
name|pid_t
modifier|*
name|ppid
parameter_list|)
block|{
name|Header
modifier|*
name|header
decl_stmt|;
name|ProcessInfo
modifier|*
name|info
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
name|int
name|fd
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|death_pipe
index|[
literal|2
index|]
decl_stmt|;
name|int
name|sync_pipe
index|[
literal|2
index|]
decl_stmt|;
name|int
name|ret
decl_stmt|;
ifdef|#
directive|ifdef
name|__linux__
name|int
name|efd
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|system_has_forkfd
condition|)
block|{
name|ret
operator|=
name|system_forkfd
argument_list|(
name|flags
argument_list|,
name|ppid
argument_list|)
expr_stmt|;
if|if
condition|(
name|system_has_forkfd
condition|)
return|return
name|ret
return|;
block|}
operator|(
name|void
operator|)
name|pthread_once
argument_list|(
operator|&
name|forkfd_initialization
argument_list|,
name|forkfd_initialize
argument_list|)
expr_stmt|;
name|info
operator|=
name|allocateInfo
argument_list|(
operator|&
name|header
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|ENOMEM
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* create the pipes before we fork */
if|if
condition|(
name|create_pipe
argument_list|(
name|death_pipe
argument_list|,
name|flags
argument_list|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|err_free
goto|;
comment|/* failed to create the pipes, pass errno */
ifdef|#
directive|ifdef
name|HAVE_EVENTFD
comment|/* try using an eventfd, which consumes less resources */
name|efd
operator|=
name|eventfd
argument_list|(
literal|0
argument_list|,
name|EFD_CLOEXEC
argument_list|)
expr_stmt|;
if|if
condition|(
name|efd
operator|==
operator|-
literal|1
condition|)
endif|#
directive|endif
block|{
comment|/* try a pipe */
if|if
condition|(
name|create_pipe
argument_list|(
name|sync_pipe
argument_list|,
name|FFD_CLOEXEC
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* failed both at eventfd and pipe; fail and pass errno */
goto|goto
name|err_close
goto|;
block|}
block|}
comment|/* now fork */
name|pid
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
goto|goto
name|err_close2
goto|;
comment|/* failed to fork, pass errno */
if|if
condition|(
name|ppid
condition|)
operator|*
name|ppid
operator|=
name|pid
expr_stmt|;
comment|/*      * We need to store the child's PID in the info structure, so      * the SIGCHLD handler knows that this child is present and it      * knows the writing end of the pipe to pass information on.      * However, the child process could exit before we stored the      * information (or the handler could run for other children exiting).      * We prevent that from happening by blocking the child process in      * a read(2) until we're finished storing the information.      */
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
comment|/* this is the child process */
comment|/* first, wait for the all clear */
ifdef|#
directive|ifdef
name|HAVE_EVENTFD
if|if
condition|(
name|efd
operator|!=
operator|-
literal|1
condition|)
block|{
name|eventfd_t
name|val64
decl_stmt|;
name|EINTR_LOOP
argument_list|(
name|ret
argument_list|,
name|eventfd_read
argument_list|(
name|efd
argument_list|,
operator|&
name|val64
argument_list|)
argument_list|)
expr_stmt|;
name|EINTR_LOOP
argument_list|(
name|ret
argument_list|,
name|close
argument_list|(
name|efd
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|char
name|c
decl_stmt|;
name|EINTR_LOOP
argument_list|(
name|ret
argument_list|,
name|close
argument_list|(
name|sync_pipe
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|EINTR_LOOP
argument_list|(
name|ret
argument_list|,
name|read
argument_list|(
name|sync_pipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|EINTR_LOOP
argument_list|(
name|ret
argument_list|,
name|close
argument_list|(
name|sync_pipe
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* now close the pipes and return to the caller */
name|EINTR_LOOP
argument_list|(
name|ret
argument_list|,
name|close
argument_list|(
name|death_pipe
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|EINTR_LOOP
argument_list|(
name|ret
argument_list|,
name|close
argument_list|(
name|death_pipe
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|fd
operator|=
name|FFD_CHILD_PROCESS
expr_stmt|;
block|}
else|else
block|{
comment|/* parent process */
name|info
operator|->
name|deathPipe
operator|=
name|death_pipe
index|[
literal|1
index|]
expr_stmt|;
name|fd
operator|=
name|death_pipe
index|[
literal|0
index|]
expr_stmt|;
name|ffd_atomic_store
argument_list|(
operator|&
name|info
operator|->
name|pid
argument_list|,
name|pid
argument_list|,
name|FFD_ATOMIC_RELEASE
argument_list|)
expr_stmt|;
comment|/* release the child */
ifdef|#
directive|ifdef
name|HAVE_EVENTFD
if|if
condition|(
name|efd
operator|!=
operator|-
literal|1
condition|)
block|{
name|eventfd_t
name|val64
init|=
literal|42
decl_stmt|;
name|EINTR_LOOP
argument_list|(
name|ret
argument_list|,
name|eventfd_write
argument_list|(
name|efd
argument_list|,
name|val64
argument_list|)
argument_list|)
expr_stmt|;
name|EINTR_LOOP
argument_list|(
name|ret
argument_list|,
name|close
argument_list|(
name|efd
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
comment|/*              * Usually, closing would be enough to make read(2) return and the child process              * continue. We need to write here: another thread could be calling forkfd at the              * same time, which means auxpipe[1] might be open in another child process.              */
name|EINTR_LOOP
argument_list|(
name|ret
argument_list|,
name|close
argument_list|(
name|sync_pipe
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|EINTR_LOOP
argument_list|(
name|ret
argument_list|,
name|write
argument_list|(
name|sync_pipe
index|[
literal|1
index|]
argument_list|,
literal|""
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|EINTR_LOOP
argument_list|(
name|ret
argument_list|,
name|close
argument_list|(
name|sync_pipe
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|fd
return|;
name|err_close2
label|:
ifdef|#
directive|ifdef
name|HAVE_EVENTFD
if|if
condition|(
name|efd
operator|!=
operator|-
literal|1
condition|)
block|{
name|EINTR_LOOP
argument_list|(
name|ret
argument_list|,
name|close
argument_list|(
name|efd
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|EINTR_LOOP
argument_list|(
name|ret
argument_list|,
name|close
argument_list|(
name|sync_pipe
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|EINTR_LOOP
argument_list|(
name|ret
argument_list|,
name|close
argument_list|(
name|sync_pipe
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|err_close
label|:
name|EINTR_LOOP
argument_list|(
name|ret
argument_list|,
name|close
argument_list|(
name|death_pipe
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|EINTR_LOOP
argument_list|(
name|ret
argument_list|,
name|close
argument_list|(
name|death_pipe
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|err_free
label|:
comment|/* free the info pointer */
name|freeInfo
argument_list|(
name|header
argument_list|,
name|info
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// FORKFD_NO_FORKFD
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|_POSIX_SPAWN
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|FORKFD_NO_SPAWNFD
argument_list|)
end_if
begin_function
DECL|function|spawnfd
name|int
name|spawnfd
parameter_list|(
name|int
name|flags
parameter_list|,
name|pid_t
modifier|*
name|ppid
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|posix_spawn_file_actions_t
modifier|*
name|file_actions
parameter_list|,
name|posix_spawnattr_t
modifier|*
name|attrp
parameter_list|,
name|char
modifier|*
specifier|const
name|argv
index|[]
parameter_list|,
name|char
modifier|*
specifier|const
name|envp
index|[]
parameter_list|)
block|{
name|Header
modifier|*
name|header
decl_stmt|;
name|ProcessInfo
modifier|*
name|info
decl_stmt|;
name|struct
name|pipe_payload
name|payload
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
name|int
name|death_pipe
index|[
literal|2
index|]
decl_stmt|;
name|int
name|ret
init|=
operator|-
literal|1
decl_stmt|;
comment|/* we can only do work if we have a way to start the child in stopped mode;      * otherwise, we have a major race condition. */
name|assert
argument_list|(
operator|!
name|system_has_forkfd
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|pthread_once
argument_list|(
operator|&
name|forkfd_initialization
argument_list|,
name|forkfd_initialize
argument_list|)
expr_stmt|;
name|info
operator|=
name|allocateInfo
argument_list|(
operator|&
name|header
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* create the pipe before we spawn */
if|if
condition|(
name|create_pipe
argument_list|(
name|death_pipe
argument_list|,
name|flags
argument_list|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|err_free
goto|;
comment|/* failed to create the pipes, pass errno */
comment|/* start the process */
if|if
condition|(
name|flags
operator|&
name|FFD_SPAWN_SEARCH_PATH
condition|)
block|{
comment|/* use posix_spawnp */
if|if
condition|(
name|posix_spawnp
argument_list|(
operator|&
name|pid
argument_list|,
name|path
argument_list|,
name|file_actions
argument_list|,
name|attrp
argument_list|,
name|argv
argument_list|,
name|envp
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|err_close
goto|;
block|}
else|else
block|{
if|if
condition|(
name|posix_spawn
argument_list|(
operator|&
name|pid
argument_list|,
name|path
argument_list|,
name|file_actions
argument_list|,
name|attrp
argument_list|,
name|argv
argument_list|,
name|envp
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|err_close
goto|;
block|}
if|if
condition|(
name|ppid
condition|)
operator|*
name|ppid
operator|=
name|pid
expr_stmt|;
comment|/* Store the child's PID in the info structure.      */
name|info
operator|->
name|deathPipe
operator|=
name|death_pipe
index|[
literal|1
index|]
expr_stmt|;
name|ffd_atomic_store
argument_list|(
operator|&
name|info
operator|->
name|pid
argument_list|,
name|pid
argument_list|,
name|FFD_ATOMIC_RELEASE
argument_list|)
expr_stmt|;
comment|/* check if the child has already exited */
if|if
condition|(
name|tryReaping
argument_list|(
name|pid
argument_list|,
operator|&
name|payload
argument_list|)
condition|)
name|notifyAndFreeInfo
argument_list|(
name|header
argument_list|,
name|info
argument_list|,
operator|&
name|payload
argument_list|)
expr_stmt|;
name|ret
operator|=
name|death_pipe
index|[
literal|0
index|]
expr_stmt|;
return|return
name|ret
return|;
name|err_close
label|:
name|EINTR_LOOP
argument_list|(
name|ret
argument_list|,
name|close
argument_list|(
name|death_pipe
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|EINTR_LOOP
argument_list|(
name|ret
argument_list|,
name|close
argument_list|(
name|death_pipe
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|err_free
label|:
comment|/* free the info pointer */
name|freeInfo
argument_list|(
name|header
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|out
label|:
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// _POSIX_SPAWN&& !FORKFD_NO_SPAWNFD
end_comment
begin_function
DECL|function|forkfd_wait
name|int
name|forkfd_wait
parameter_list|(
name|int
name|ffd
parameter_list|,
name|forkfd_info
modifier|*
name|info
parameter_list|,
name|struct
name|rusage
modifier|*
name|rusage
parameter_list|)
block|{
name|struct
name|pipe_payload
name|payload
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|read
argument_list|(
name|ffd
argument_list|,
operator|&
name|payload
argument_list|,
sizeof|sizeof
argument_list|(
name|payload
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
return|return
name|ret
return|;
comment|/* pass errno, probably EINTR, EBADF or EWOULDBLOCK */
name|assert
argument_list|(
name|ret
operator|==
sizeof|sizeof
argument_list|(
name|payload
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
condition|)
operator|*
name|info
operator|=
name|payload
operator|.
name|info
expr_stmt|;
if|if
condition|(
name|rusage
condition|)
operator|*
name|rusage
operator|=
name|payload
operator|.
name|rusage
expr_stmt|;
return|return
literal|0
return|;
comment|/* success */
block|}
end_function
begin_function
DECL|function|forkfd_close
name|int
name|forkfd_close
parameter_list|(
name|int
name|ffd
parameter_list|)
block|{
return|return
name|close
argument_list|(
name|ffd
argument_list|)
return|;
block|}
end_function
end_unit
