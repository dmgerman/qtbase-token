begin_unit
begin_comment
comment|// Copyright 2010 the V8 project authors. All rights reserved.
end_comment
begin_comment
comment|// Redistribution and use in source and binary forms, with or without
end_comment
begin_comment
comment|// modification, are permitted provided that the following conditions are
end_comment
begin_comment
comment|// met:
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|//     * Redistributions of source code must retain the above copyright
end_comment
begin_comment
comment|//       notice, this list of conditions and the following disclaimer.
end_comment
begin_comment
comment|//     * Redistributions in binary form must reproduce the above
end_comment
begin_comment
comment|//       copyright notice, this list of conditions and the following
end_comment
begin_comment
comment|//       disclaimer in the documentation and/or other materials provided
end_comment
begin_comment
comment|//       with the distribution.
end_comment
begin_comment
comment|//     * Neither the name of Google Inc. nor the names of its
end_comment
begin_comment
comment|//       contributors may be used to endorse or promote products derived
end_comment
begin_comment
comment|//       from this software without specific prior written permission.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
end_comment
begin_comment
comment|// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
end_comment
begin_comment
comment|// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
end_comment
begin_comment
comment|// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
end_comment
begin_comment
comment|// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
end_comment
begin_comment
comment|// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
end_comment
begin_comment
comment|// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
end_comment
begin_comment
comment|// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
end_comment
begin_comment
comment|// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
end_comment
begin_comment
comment|// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
end_comment
begin_comment
comment|// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|DOUBLE_CONVERSION_UTILS_H_
end_ifndef
begin_define
DECL|macro|DOUBLE_CONVERSION_UTILS_H_
define|#
directive|define
name|DOUBLE_CONVERSION_UTILS_H_
end_define
begin_include
include|#
directive|include
file|<stdlib.h>
end_include
begin_include
include|#
directive|include
file|<string.h>
end_include
begin_include
include|#
directive|include
file|<assert.h>
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|ASSERT
end_ifndef
begin_if
if|#
directive|if
name|defined
argument_list|(
name|WINCE
argument_list|)
operator|||
name|defined
argument_list|(
name|_WIN32_WCE
argument_list|)
end_if
begin_define
DECL|macro|ASSERT
define|#
directive|define
name|ASSERT
parameter_list|(
name|condition
parameter_list|)
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|ASSERT
define|#
directive|define
name|ASSERT
parameter_list|(
name|condition
parameter_list|)
define|\
value|assert(condition);
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|UNIMPLEMENTED
end_ifndef
begin_define
DECL|macro|UNIMPLEMENTED
define|#
directive|define
name|UNIMPLEMENTED
parameter_list|()
value|(exit(-1))
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|UNREACHABLE
end_ifndef
begin_define
DECL|macro|UNREACHABLE
define|#
directive|define
name|UNREACHABLE
parameter_list|()
value|(exit(-1))
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// Double operations detection based on target architecture.
end_comment
begin_comment
comment|// Linux uses a 80bit wide floating point stack on x86. This induces double
end_comment
begin_comment
comment|// rounding, which in turn leads to wrong results.
end_comment
begin_comment
comment|// An easy way to test if the floating-point operations are correct is to
end_comment
begin_comment
comment|// evaluate: 89255.0/1e22. If the floating-point stack is 64 bits wide then
end_comment
begin_comment
comment|// the result is equal to 89255e-22.
end_comment
begin_comment
comment|// The best way to test this, is to create a division-function and to compare
end_comment
begin_comment
comment|// the output of the division with the expected result. (Inlining must be
end_comment
begin_comment
comment|// disabled.)
end_comment
begin_comment
comment|// On Linux,x86 89255e-22 != Div_double(89255.0/1e22)
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|_M_X64
argument_list|)
operator|||
name|defined
argument_list|(
name|__x86_64__
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|__ARMEL__
argument_list|)
operator|||
name|defined
argument_list|(
name|__avr32__
argument_list|)
operator|||
name|_M_ARM_FP
operator|||
expr|\
name|defined
argument_list|(
name|__hppa__
argument_list|)
operator|||
name|defined
argument_list|(
name|__ia64__
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|__mips__
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|__powerpc__
argument_list|)
operator|||
name|defined
argument_list|(
name|__ppc__
argument_list|)
operator|||
name|defined
argument_list|(
name|__ppc64__
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|__sparc__
argument_list|)
operator|||
name|defined
argument_list|(
name|__sparc
argument_list|)
operator|||
name|defined
argument_list|(
name|__s390__
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|__SH4__
argument_list|)
operator|||
name|defined
argument_list|(
name|__alpha__
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|_MIPS_ARCH_MIPS32R2
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|__AARCH64EL__
argument_list|)
end_if
begin_define
DECL|macro|DOUBLE_CONVERSION_CORRECT_DOUBLE_OPERATIONS
define|#
directive|define
name|DOUBLE_CONVERSION_CORRECT_DOUBLE_OPERATIONS
value|1
end_define
begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|_M_IX86
argument_list|)
operator|||
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
name|defined
argument_list|(
name|__i386
argument_list|)
end_elif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
end_if
begin_comment
comment|// Windows uses a 64bit wide floating point stack.
end_comment
begin_define
DECL|macro|DOUBLE_CONVERSION_CORRECT_DOUBLE_OPERATIONS
define|#
directive|define
name|DOUBLE_CONVERSION_CORRECT_DOUBLE_OPERATIONS
value|1
end_define
begin_else
else|#
directive|else
end_else
begin_undef
DECL|macro|DOUBLE_CONVERSION_CORRECT_DOUBLE_OPERATIONS
undef|#
directive|undef
name|DOUBLE_CONVERSION_CORRECT_DOUBLE_OPERATIONS
end_undef
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// _WIN32
end_comment
begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|WINCE
argument_list|)
operator|||
name|defined
argument_list|(
name|_WIN32_WCE
argument_list|)
end_elif
begin_define
DECL|macro|DOUBLE_CONVERSION_CORRECT_DOUBLE_OPERATIONS
define|#
directive|define
name|DOUBLE_CONVERSION_CORRECT_DOUBLE_OPERATIONS
value|1
end_define
begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__ghs
argument_list|)
end_elif
begin_comment
comment|// Green Hills toolchain uses a 64bit wide floating point stack
end_comment
begin_define
DECL|macro|DOUBLE_CONVERSION_CORRECT_DOUBLE_OPERATIONS
define|#
directive|define
name|DOUBLE_CONVERSION_CORRECT_DOUBLE_OPERATIONS
value|1
end_define
begin_else
else|#
directive|else
end_else
begin_error
error|#
directive|error
error|Target architecture was not detected as supported by Double-Conversion.
end_error
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
end_if
begin_define
DECL|macro|DOUBLE_CONVERSION_UNUSED
define|#
directive|define
name|DOUBLE_CONVERSION_UNUSED
value|__attribute__((unused))
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|DOUBLE_CONVERSION_UNUSED
define|#
directive|define
name|DOUBLE_CONVERSION_UNUSED
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__MINGW32__
argument_list|)
end_if
begin_typedef
DECL|typedef|int8_t
typedef|typedef
name|signed
name|char
name|int8_t
typedef|;
end_typedef
begin_typedef
DECL|typedef|uint8_t
typedef|typedef
name|unsigned
name|char
name|uint8_t
typedef|;
end_typedef
begin_typedef
DECL|typedef|int16_t
typedef|typedef
name|short
name|int16_t
typedef|;
end_typedef
begin_comment
DECL|typedef|int16_t
comment|// NOLINT
end_comment
begin_typedef
DECL|typedef|uint16_t
typedef|typedef
name|unsigned
name|short
name|uint16_t
typedef|;
end_typedef
begin_comment
DECL|typedef|uint16_t
comment|// NOLINT
end_comment
begin_typedef
DECL|typedef|int32_t
typedef|typedef
name|int
name|int32_t
typedef|;
end_typedef
begin_typedef
DECL|typedef|uint32_t
typedef|typedef
name|unsigned
name|int
name|uint32_t
typedef|;
end_typedef
begin_typedef
DECL|typedef|int64_t
typedef|typedef
name|__int64
name|int64_t
typedef|;
end_typedef
begin_typedef
DECL|typedef|uint64_t
typedef|typedef
name|unsigned
name|__int64
name|uint64_t
typedef|;
end_typedef
begin_comment
comment|// intptr_t and friends are defined in crtdefs.h through stdio.h.
end_comment
begin_else
else|#
directive|else
end_else
begin_include
include|#
directive|include
file|<stdint.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_typedef
DECL|typedef|uc16
typedef|typedef
name|uint16_t
name|uc16
typedef|;
end_typedef
begin_comment
comment|// The following macro works on both 32 and 64-bit platforms.
end_comment
begin_comment
comment|// Usage: instead of writing 0x1234567890123456
end_comment
begin_comment
comment|//      write UINT64_2PART_C(0x12345678,90123456);
end_comment
begin_define
DECL|macro|UINT64_2PART_C
define|#
directive|define
name|UINT64_2PART_C
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(((static_cast<uint64_t>(a)<< 32) + 0x##b##u))
end_define
begin_comment
comment|// The expression ARRAY_SIZE(a) is a compile-time constant of type
end_comment
begin_comment
comment|// size_t which represents the number of elements of the given
end_comment
begin_comment
comment|// array. You should only use ARRAY_SIZE on statically allocated
end_comment
begin_comment
comment|// arrays.
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|ARRAY_SIZE
end_ifndef
begin_define
DECL|macro|ARRAY_SIZE
define|#
directive|define
name|ARRAY_SIZE
parameter_list|(
name|a
parameter_list|)
define|\
value|((sizeof(a) / sizeof(*(a))) /                         \   static_cast<size_t>(!(sizeof(a) % sizeof(*(a)))))
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// A macro to disallow the evil copy constructor and operator= functions
end_comment
begin_comment
comment|// This should be used in the private: declarations for a class
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|DISALLOW_COPY_AND_ASSIGN
end_ifndef
begin_define
DECL|macro|DISALLOW_COPY_AND_ASSIGN
define|#
directive|define
name|DISALLOW_COPY_AND_ASSIGN
parameter_list|(
name|TypeName
parameter_list|)
define|\
value|TypeName(const TypeName&);                    \   void operator=(const TypeName&)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// A macro to disallow all the implicit constructors, namely the
end_comment
begin_comment
comment|// default constructor, copy constructor and operator= functions.
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// This should be used in the private: declarations for a class
end_comment
begin_comment
comment|// that wants to prevent anyone from instantiating it. This is
end_comment
begin_comment
comment|// especially useful for classes containing only static methods.
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|DISALLOW_IMPLICIT_CONSTRUCTORS
end_ifndef
begin_define
DECL|macro|DISALLOW_IMPLICIT_CONSTRUCTORS
define|#
directive|define
name|DISALLOW_IMPLICIT_CONSTRUCTORS
parameter_list|(
name|TypeName
parameter_list|)
define|\
value|TypeName();                                    \   DISALLOW_COPY_AND_ASSIGN(TypeName)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_decl_stmt
name|namespace
name|double_conversion
block|{
specifier|static
specifier|const
name|int
name|kCharSize
init|=
sizeof|sizeof
argument_list|(
name|char
argument_list|)
decl_stmt|;
comment|// Returns the maximum of the two parameters.
name|template
operator|<
name|typename
name|T
operator|>
specifier|static
name|T
name|Max
argument_list|(
argument|T a
argument_list|,
argument|T b
argument_list|)
block|{
return|return
name|a
operator|<
name|b
operator|?
name|b
operator|:
name|a
return|;
block|}
comment|// Returns the minimum of the two parameters.
name|template
operator|<
name|typename
name|T
operator|>
specifier|static
name|T
name|Min
argument_list|(
argument|T a
argument_list|,
argument|T b
argument_list|)
block|{
return|return
name|a
operator|<
name|b
operator|?
name|a
operator|:
name|b
return|;
block|}
specifier|inline
name|int
name|StrLength
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
name|size_t
name|length
init|=
name|strlen
argument_list|(
name|string
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|length
operator|==
name|static_cast
operator|<
name|size_t
operator|>
operator|(
name|static_cast
operator|<
name|int
operator|>
operator|(
name|length
operator|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|static_cast
operator|<
name|int
operator|>
operator|(
name|length
operator|)
return|;
block|}
comment|// This is a simplified version of V8's Vector class.
name|template
operator|<
name|typename
name|T
operator|>
name|class
name|Vector
block|{
name|public
operator|:
name|Vector
argument_list|()
operator|:
name|start_
argument_list|(
name|NULL
argument_list|)
block|,
name|length_
argument_list|(
literal|0
argument_list|)
block|{}
name|Vector
argument_list|(
argument|T* data
argument_list|,
argument|int length
argument_list|)
operator|:
name|start_
argument_list|(
name|data
argument_list|)
block|,
name|length_
argument_list|(
argument|length
argument_list|)
block|{
name|ASSERT
argument_list|(
name|length
operator|==
literal|0
operator|||
operator|(
name|length
operator|>
literal|0
operator|&&
name|data
operator|!=
name|NULL
operator|)
argument_list|)
block|;   }
comment|// Returns a vector using the same backing storage as this one,
comment|// spanning from and including 'from', to but not including 'to'.
name|Vector
operator|<
name|T
operator|>
name|SubVector
argument_list|(
argument|int from
argument_list|,
argument|int to
argument_list|)
block|{
name|ASSERT
argument_list|(
name|to
operator|<=
name|length_
argument_list|)
block|;
name|ASSERT
argument_list|(
name|from
operator|<
name|to
argument_list|)
block|;
name|ASSERT
argument_list|(
literal|0
operator|<=
name|from
argument_list|)
block|;
return|return
name|Vector
operator|<
name|T
operator|>
operator|(
name|start
argument_list|()
operator|+
name|from
operator|,
name|to
operator|-
name|from
operator|)
return|;
block|}
comment|// Returns the length of the vector.
name|int
name|length
argument_list|()
specifier|const
block|{
return|return
name|length_
return|;
block|}
comment|// Returns whether or not the vector is empty.
name|bool
name|is_empty
argument_list|()
specifier|const
block|{
return|return
name|length_
operator|==
literal|0
return|;
block|}
comment|// Returns the pointer to the start of the data in the vector.
name|T
operator|*
name|start
argument_list|()
specifier|const
block|{
return|return
name|start_
return|;
block|}
comment|// Access individual vector elements - checks bounds in debug mode.
name|T
operator|&
name|operator
index|[]
operator|(
name|int
name|index
operator|)
specifier|const
block|{
name|ASSERT
argument_list|(
literal|0
operator|<=
name|index
operator|&&
name|index
operator|<
name|length_
argument_list|)
block|;
return|return
name|start_
index|[
name|index
index|]
return|;
block|}
name|T
operator|&
name|first
argument_list|()
block|{
return|return
name|start_
index|[
literal|0
index|]
return|;
block|}
name|T
operator|&
name|last
argument_list|()
block|{
return|return
name|start_
index|[
name|length_
operator|-
literal|1
index|]
return|;
block|}
name|private
operator|:
name|T
operator|*
name|start_
block|;
name|int
name|length_
block|; }
expr_stmt|;
comment|// Helper class for building result strings in a character buffer. The
comment|// purpose of the class is to use safe operations that checks the
comment|// buffer bounds on all operations in debug mode.
name|class
name|StringBuilder
block|{
name|public
label|:
name|StringBuilder
argument_list|(
argument|char* buffer
argument_list|,
argument|int size
argument_list|)
block|:
name|buffer_
argument_list|(
name|buffer
argument_list|,
name|size
argument_list|)
operator|,
name|position_
argument_list|(
literal|0
argument_list|)
block|{ }
operator|~
name|StringBuilder
argument_list|()
block|{
if|if
condition|(
operator|!
name|is_finalized
argument_list|()
condition|)
name|Finalize
argument_list|()
expr_stmt|;
block|}
name|int
name|size
argument_list|()
specifier|const
block|{
return|return
name|buffer_
operator|.
name|length
argument_list|()
return|;
block|}
comment|// Get the current position in the builder.
name|int
name|position
argument_list|()
specifier|const
block|{
name|ASSERT
argument_list|(
operator|!
name|is_finalized
argument_list|()
argument_list|)
block|;
return|return
name|position_
return|;
block|}
comment|// Reset the position.
name|void
name|Reset
parameter_list|()
block|{
name|position_
operator|=
literal|0
expr_stmt|;
block|}
comment|// Add a single character to the builder. It is not allowed to add
comment|// 0-characters; use the Finalize() method to terminate the string
comment|// instead.
name|void
name|AddCharacter
parameter_list|(
name|char
name|c
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|c
operator|!=
literal|'\0'
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|is_finalized
argument_list|()
operator|&&
name|position_
operator|<
name|buffer_
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|buffer_
index|[
name|position_
operator|++
index|]
operator|=
name|c
expr_stmt|;
block|}
comment|// Add an entire string to the builder. Uses strlen() internally to
comment|// compute the length of the input string.
name|void
name|AddString
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|AddSubstring
argument_list|(
name|s
argument_list|,
name|StrLength
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Add the first 'n' characters of the given string 's' to the
comment|// builder. The input string must have enough characters.
name|void
name|AddSubstring
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|ASSERT
argument_list|(
operator|!
name|is_finalized
argument_list|()
operator|&&
name|position_
operator|+
name|n
operator|<
name|buffer_
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|static_cast
operator|<
name|size_t
operator|>
operator|(
name|n
operator|)
operator|<=
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
operator|&
name|buffer_
index|[
name|position_
index|]
argument_list|,
name|s
argument_list|,
name|n
operator|*
name|kCharSize
argument_list|)
expr_stmt|;
name|position_
operator|+=
name|n
expr_stmt|;
block|}
comment|// Add character padding to the builder. If count is non-positive,
comment|// nothing is added to the builder.
name|void
name|AddPadding
parameter_list|(
name|char
name|c
parameter_list|,
name|int
name|count
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|AddCharacter
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Finalize the string by 0-terminating it and returning the buffer.
name|char
modifier|*
name|Finalize
parameter_list|()
block|{
name|ASSERT
argument_list|(
operator|!
name|is_finalized
argument_list|()
operator|&&
name|position_
operator|<
name|buffer_
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|buffer_
index|[
name|position_
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|// Make sure nobody managed to add a 0-character to the
comment|// buffer while building the string.
name|ASSERT
argument_list|(
name|strlen
argument_list|(
name|buffer_
operator|.
name|start
argument_list|()
argument_list|)
operator|==
name|static_cast
operator|<
name|size_t
operator|>
operator|(
name|position_
operator|)
argument_list|)
expr_stmt|;
name|position_
operator|=
operator|-
literal|1
expr_stmt|;
name|ASSERT
argument_list|(
name|is_finalized
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|buffer_
operator|.
name|start
argument_list|()
return|;
block|}
name|private
label|:
name|Vector
operator|<
name|char
operator|>
name|buffer_
expr_stmt|;
name|int
name|position_
decl_stmt|;
name|bool
name|is_finalized
argument_list|()
specifier|const
block|{
return|return
name|position_
operator|<
literal|0
return|;
block|}
name|DISALLOW_IMPLICIT_CONSTRUCTORS
argument_list|(
name|StringBuilder
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
comment|// The type-based aliasing rule allows the compiler to assume that pointers of
comment|// different types (for some definition of different) never alias each other.
comment|// Thus the following code does not work:
comment|//
comment|// float f = foo();
comment|// int fbits = *(int*)(&f);
comment|//
comment|// The compiler 'knows' that the int pointer can't refer to f since the types
comment|// don't match, so the compiler may cache f in a register, leaving random data
comment|// in fbits.  Using C++ style casts makes no difference, however a pointer to
comment|// char data is assumed to alias any other pointer.  This is the 'memcpy
comment|// exception'.
comment|//
comment|// Bit_cast uses the memcpy exception to move the bits from a variable of one
comment|// type of a variable of another type.  Of course the end result is likely to
comment|// be implementation dependent.  Most compilers (gcc-4.2 and MSVC 2005)
comment|// will completely optimize BitCast away.
comment|//
comment|// There is an additional use for BitCast.
comment|// Recent gccs will warn when they see casts that may result in breakage due to
comment|// the type-based aliasing rule.  If you have checked that there is no breakage
comment|// you can use BitCast to cast one pointer type to another.  This confuses gcc
comment|// enough that it can no longer see that you have cast one pointer type to
comment|// another thus avoiding the warning.
name|template
operator|<
name|class
name|Dest
operator|,
name|class
name|Source
operator|>
specifier|inline
name|Dest
name|BitCast
argument_list|(
argument|const Source& source
argument_list|)
block|{
comment|// Compile time assertion: sizeof(Dest) == sizeof(Source)
comment|// A compile error here means your Dest and Source have different sizes.
name|DOUBLE_CONVERSION_UNUSED
typedef|typedef
name|char
name|VerifySizesAreEqual
index|[
sizeof|sizeof
argument_list|(
name|Dest
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|Source
argument_list|)
operator|?
literal|1
operator|:
operator|-
literal|1
index|]
typedef|;
name|Dest
name|dest
expr_stmt|;
name|memmove
argument_list|(
operator|&
name|dest
argument_list|,
operator|&
name|source
argument_list|,
sizeof|sizeof
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|dest
return|;
block|}
end_decl_stmt
begin_expr_stmt
name|template
operator|<
name|class
name|Dest
operator|,
name|class
name|Source
operator|>
specifier|inline
name|Dest
name|BitCast
argument_list|(
argument|Source* source
argument_list|)
block|{
return|return
name|BitCast
operator|<
name|Dest
operator|>
operator|(
name|reinterpret_cast
operator|<
name|uintptr_t
operator|>
operator|(
name|source
operator|)
operator|)
return|;
block|}
end_expr_stmt
begin_comment
unit|}
comment|// namespace double_conversion
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// DOUBLE_CONVERSION_UTILS_H_
end_comment
end_unit
