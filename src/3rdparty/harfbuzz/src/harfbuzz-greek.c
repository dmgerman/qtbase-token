begin_unit
begin_comment
comment|/*  * Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies)  *  * This is part of HarfBuzz, an OpenType Layout engine library.  *  * Permission is hereby granted, without written agreement and without  * license or royalty fees, to use, copy, modify, and distribute this  * software and its documentation for any purpose, provided that the  * above copyright notice and the following two paragraphs appear in  * all copies of this software.  *  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH  * DAMAGE.  *  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS  * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.  */
end_comment
begin_include
include|#
directive|include
file|"harfbuzz-shaper.h"
end_include
begin_include
include|#
directive|include
file|"harfbuzz-shaper-private.h"
end_include
begin_include
include|#
directive|include
file|<assert.h>
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|NO_OPENTYPE
end_ifndef
begin_decl_stmt
DECL|variable|greek_features
specifier|static
specifier|const
name|HB_OpenTypeFeature
name|greek_features
index|[]
init|=
block|{
block|{
name|HB_MAKE_TAG
argument_list|(
literal|'c'
argument_list|,
literal|'c'
argument_list|,
literal|'m'
argument_list|,
literal|'p'
argument_list|)
block|,
name|CcmpProperty
block|}
block|,
block|{
name|HB_MAKE_TAG
argument_list|(
literal|'l'
argument_list|,
literal|'i'
argument_list|,
literal|'g'
argument_list|,
literal|'a'
argument_list|)
block|,
name|CcmpProperty
block|}
block|,
block|{
name|HB_MAKE_TAG
argument_list|(
literal|'c'
argument_list|,
literal|'l'
argument_list|,
literal|'i'
argument_list|,
literal|'g'
argument_list|)
block|,
name|CcmpProperty
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*   Greek decompositions */
end_comment
begin_typedef
DECL|struct|_hb_greek_decomposition
typedef|typedef
struct|struct
name|_hb_greek_decomposition
block|{
DECL|member|composed
name|HB_UChar16
name|composed
decl_stmt|;
DECL|member|base
name|HB_UChar16
name|base
decl_stmt|;
block|}
DECL|typedef|hb_greek_decomposition
name|hb_greek_decomposition
typedef|;
end_typedef
begin_decl_stmt
DECL|variable|decompose_0x300
specifier|static
specifier|const
name|hb_greek_decomposition
name|decompose_0x300
index|[]
init|=
block|{
block|{
literal|0x1FBA
block|,
literal|0x0391
block|}
block|,
block|{
literal|0x1FC8
block|,
literal|0x0395
block|}
block|,
block|{
literal|0x1FCA
block|,
literal|0x0397
block|}
block|,
block|{
literal|0x1FDA
block|,
literal|0x0399
block|}
block|,
block|{
literal|0x1FF8
block|,
literal|0x039F
block|}
block|,
block|{
literal|0x1FEA
block|,
literal|0x03A5
block|}
block|,
block|{
literal|0x1FFA
block|,
literal|0x03A9
block|}
block|,
block|{
literal|0x1F70
block|,
literal|0x03B1
block|}
block|,
block|{
literal|0x1F72
block|,
literal|0x03B5
block|}
block|,
block|{
literal|0x1F74
block|,
literal|0x03B7
block|}
block|,
block|{
literal|0x1F76
block|,
literal|0x03B9
block|}
block|,
block|{
literal|0x1F78
block|,
literal|0x03BF
block|}
block|,
block|{
literal|0x1F7A
block|,
literal|0x03C5
block|}
block|,
block|{
literal|0x1F7C
block|,
literal|0x03C9
block|}
block|,
block|{
literal|0x1FD2
block|,
literal|0x03CA
block|}
block|,
block|{
literal|0x1FE2
block|,
literal|0x03CB
block|}
block|,
block|{
literal|0x1F02
block|,
literal|0x1F00
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|compose_0x300
specifier|static
name|HB_UChar16
name|compose_0x300
parameter_list|(
name|HB_UChar16
name|base
parameter_list|)
block|{
if|if
condition|(
operator|(
name|base
operator|^
literal|0x1f00
operator|)
operator|<
literal|0x100
condition|)
block|{
if|if
condition|(
name|base
operator|<=
literal|0x1f69
operator|&&
operator|!
operator|(
name|base
operator|&
literal|0x6
operator|)
condition|)
return|return
name|base
operator|+
literal|2
return|;
if|if
condition|(
name|base
operator|==
literal|0x1fbf
condition|)
return|return
literal|0x1fcd
return|;
if|if
condition|(
name|base
operator|==
literal|0x1ffe
condition|)
return|return
literal|0x1fdd
return|;
return|return
literal|0
return|;
block|}
block|{
specifier|const
name|hb_greek_decomposition
modifier|*
name|d
init|=
name|decompose_0x300
decl_stmt|;
while|while
condition|(
name|d
operator|->
name|base
operator|&&
name|d
operator|->
name|base
operator|!=
name|base
condition|)
operator|++
name|d
expr_stmt|;
return|return
name|d
operator|->
name|composed
return|;
block|}
block|}
end_function
begin_decl_stmt
DECL|variable|decompose_0x301
specifier|static
specifier|const
name|hb_greek_decomposition
name|decompose_0x301
index|[]
init|=
block|{
block|{
literal|0x0386
block|,
literal|0x0391
block|}
block|,
block|{
literal|0x0388
block|,
literal|0x0395
block|}
block|,
block|{
literal|0x0389
block|,
literal|0x0397
block|}
block|,
block|{
literal|0x038A
block|,
literal|0x0399
block|}
block|,
block|{
literal|0x038C
block|,
literal|0x039F
block|}
block|,
block|{
literal|0x038E
block|,
literal|0x03A5
block|}
block|,
block|{
literal|0x038F
block|,
literal|0x03A9
block|}
block|,
block|{
literal|0x03AC
block|,
literal|0x03B1
block|}
block|,
block|{
literal|0x03AD
block|,
literal|0x03B5
block|}
block|,
block|{
literal|0x03AE
block|,
literal|0x03B7
block|}
block|,
block|{
literal|0x03AF
block|,
literal|0x03B9
block|}
block|,
block|{
literal|0x03CC
block|,
literal|0x03BF
block|}
block|,
block|{
literal|0x03CD
block|,
literal|0x03C5
block|}
block|,
block|{
literal|0x03CE
block|,
literal|0x03C9
block|}
block|,
block|{
literal|0x0390
block|,
literal|0x03CA
block|}
block|,
block|{
literal|0x03B0
block|,
literal|0x03CB
block|}
block|,
block|{
literal|0x03D3
block|,
literal|0x03D2
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|compose_0x301
specifier|static
name|HB_UChar16
name|compose_0x301
parameter_list|(
name|HB_UChar16
name|base
parameter_list|)
block|{
if|if
condition|(
operator|(
name|base
operator|^
literal|0x1f00
operator|)
operator|<
literal|0x100
condition|)
block|{
if|if
condition|(
name|base
operator|<=
literal|0x1f69
operator|&&
operator|!
operator|(
name|base
operator|&
literal|0x6
operator|)
condition|)
return|return
name|base
operator|+
literal|4
return|;
if|if
condition|(
name|base
operator|==
literal|0x1fbf
condition|)
return|return
literal|0x1fce
return|;
if|if
condition|(
name|base
operator|==
literal|0x1ffe
condition|)
return|return
literal|0x1fde
return|;
block|}
block|{
specifier|const
name|hb_greek_decomposition
modifier|*
name|d
init|=
name|decompose_0x301
decl_stmt|;
while|while
condition|(
name|d
operator|->
name|base
operator|&&
name|d
operator|->
name|base
operator|!=
name|base
condition|)
operator|++
name|d
expr_stmt|;
return|return
name|d
operator|->
name|composed
return|;
block|}
block|}
end_function
begin_decl_stmt
DECL|variable|decompose_0x304
specifier|static
specifier|const
name|hb_greek_decomposition
name|decompose_0x304
index|[]
init|=
block|{
block|{
literal|0x1FB9
block|,
literal|0x0391
block|}
block|,
block|{
literal|0x1FD9
block|,
literal|0x0399
block|}
block|,
block|{
literal|0x1FE9
block|,
literal|0x03A5
block|}
block|,
block|{
literal|0x1FB1
block|,
literal|0x03B1
block|}
block|,
block|{
literal|0x1FD1
block|,
literal|0x03B9
block|}
block|,
block|{
literal|0x1FE1
block|,
literal|0x03C5
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|compose_0x304
specifier|static
name|HB_UChar16
name|compose_0x304
parameter_list|(
name|HB_UChar16
name|base
parameter_list|)
block|{
specifier|const
name|hb_greek_decomposition
modifier|*
name|d
init|=
name|decompose_0x304
decl_stmt|;
while|while
condition|(
name|d
operator|->
name|base
operator|&&
name|d
operator|->
name|base
operator|!=
name|base
condition|)
operator|++
name|d
expr_stmt|;
return|return
name|d
operator|->
name|composed
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|decompose_0x306
specifier|static
specifier|const
name|hb_greek_decomposition
name|decompose_0x306
index|[]
init|=
block|{
block|{
literal|0x1FB8
block|,
literal|0x0391
block|}
block|,
block|{
literal|0x1FD8
block|,
literal|0x0399
block|}
block|,
block|{
literal|0x1FE8
block|,
literal|0x03A5
block|}
block|,
block|{
literal|0x1FB0
block|,
literal|0x03B1
block|}
block|,
block|{
literal|0x1FD0
block|,
literal|0x03B9
block|}
block|,
block|{
literal|0x1FE0
block|,
literal|0x03C5
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|compose_0x306
specifier|static
name|HB_UChar16
name|compose_0x306
parameter_list|(
name|HB_UChar16
name|base
parameter_list|)
block|{
specifier|const
name|hb_greek_decomposition
modifier|*
name|d
init|=
name|decompose_0x306
decl_stmt|;
while|while
condition|(
name|d
operator|->
name|base
operator|&&
name|d
operator|->
name|base
operator|!=
name|base
condition|)
operator|++
name|d
expr_stmt|;
return|return
name|d
operator|->
name|composed
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|decompose_0x308
specifier|static
specifier|const
name|hb_greek_decomposition
name|decompose_0x308
index|[]
init|=
block|{
block|{
literal|0x03AA
block|,
literal|0x0399
block|}
block|,
block|{
literal|0x03AB
block|,
literal|0x03A5
block|}
block|,
block|{
literal|0x03CA
block|,
literal|0x03B9
block|}
block|,
block|{
literal|0x03CB
block|,
literal|0x03C5
block|}
block|,
block|{
literal|0x03D4
block|,
literal|0x03D2
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|compose_0x308
specifier|static
name|HB_UChar16
name|compose_0x308
parameter_list|(
name|HB_UChar16
name|base
parameter_list|)
block|{
specifier|const
name|hb_greek_decomposition
modifier|*
name|d
init|=
name|decompose_0x308
decl_stmt|;
while|while
condition|(
name|d
operator|->
name|base
operator|&&
name|d
operator|->
name|base
operator|!=
name|base
condition|)
operator|++
name|d
expr_stmt|;
return|return
name|d
operator|->
name|composed
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|decompose_0x313
specifier|static
specifier|const
name|hb_greek_decomposition
name|decompose_0x313
index|[]
init|=
block|{
block|{
literal|0x1F08
block|,
literal|0x0391
block|}
block|,
block|{
literal|0x1F18
block|,
literal|0x0395
block|}
block|,
block|{
literal|0x1F28
block|,
literal|0x0397
block|}
block|,
block|{
literal|0x1F38
block|,
literal|0x0399
block|}
block|,
block|{
literal|0x1F48
block|,
literal|0x039F
block|}
block|,
block|{
literal|0x1F68
block|,
literal|0x03A9
block|}
block|,
block|{
literal|0x1F00
block|,
literal|0x03B1
block|}
block|,
block|{
literal|0x1F10
block|,
literal|0x03B5
block|}
block|,
block|{
literal|0x1F20
block|,
literal|0x03B7
block|}
block|,
block|{
literal|0x1F30
block|,
literal|0x03B9
block|}
block|,
block|{
literal|0x1F40
block|,
literal|0x03BF
block|}
block|,
block|{
literal|0x1FE4
block|,
literal|0x03C1
block|}
block|,
block|{
literal|0x1F50
block|,
literal|0x03C5
block|}
block|,
block|{
literal|0x1F60
block|,
literal|0x03C9
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|compose_0x313
specifier|static
name|HB_UChar16
name|compose_0x313
parameter_list|(
name|HB_UChar16
name|base
parameter_list|)
block|{
specifier|const
name|hb_greek_decomposition
modifier|*
name|d
init|=
name|decompose_0x313
decl_stmt|;
while|while
condition|(
name|d
operator|->
name|base
operator|&&
name|d
operator|->
name|base
operator|!=
name|base
condition|)
operator|++
name|d
expr_stmt|;
return|return
name|d
operator|->
name|composed
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|decompose_0x314
specifier|static
specifier|const
name|hb_greek_decomposition
name|decompose_0x314
index|[]
init|=
block|{
block|{
literal|0x1F09
block|,
literal|0x0391
block|}
block|,
block|{
literal|0x1F19
block|,
literal|0x0395
block|}
block|,
block|{
literal|0x1F29
block|,
literal|0x0397
block|}
block|,
block|{
literal|0x1F39
block|,
literal|0x0399
block|}
block|,
block|{
literal|0x1F49
block|,
literal|0x039F
block|}
block|,
block|{
literal|0x1FEC
block|,
literal|0x03A1
block|}
block|,
block|{
literal|0x1F59
block|,
literal|0x03A5
block|}
block|,
block|{
literal|0x1F69
block|,
literal|0x03A9
block|}
block|,
block|{
literal|0x1F01
block|,
literal|0x03B1
block|}
block|,
block|{
literal|0x1F11
block|,
literal|0x03B5
block|}
block|,
block|{
literal|0x1F21
block|,
literal|0x03B7
block|}
block|,
block|{
literal|0x1F31
block|,
literal|0x03B9
block|}
block|,
block|{
literal|0x1F41
block|,
literal|0x03BF
block|}
block|,
block|{
literal|0x1FE5
block|,
literal|0x03C1
block|}
block|,
block|{
literal|0x1F51
block|,
literal|0x03C5
block|}
block|,
block|{
literal|0x1F61
block|,
literal|0x03C9
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|compose_0x314
specifier|static
name|HB_UChar16
name|compose_0x314
parameter_list|(
name|HB_UChar16
name|base
parameter_list|)
block|{
specifier|const
name|hb_greek_decomposition
modifier|*
name|d
init|=
name|decompose_0x314
decl_stmt|;
while|while
condition|(
name|d
operator|->
name|base
operator|&&
name|d
operator|->
name|base
operator|!=
name|base
condition|)
operator|++
name|d
expr_stmt|;
return|return
name|d
operator|->
name|composed
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|decompose_0x342
specifier|static
specifier|const
name|hb_greek_decomposition
name|decompose_0x342
index|[]
init|=
block|{
block|{
literal|0x1FB6
block|,
literal|0x03B1
block|}
block|,
block|{
literal|0x1FC6
block|,
literal|0x03B7
block|}
block|,
block|{
literal|0x1FD6
block|,
literal|0x03B9
block|}
block|,
block|{
literal|0x1FE6
block|,
literal|0x03C5
block|}
block|,
block|{
literal|0x1FF6
block|,
literal|0x03C9
block|}
block|,
block|{
literal|0x1FD7
block|,
literal|0x03CA
block|}
block|,
block|{
literal|0x1FE7
block|,
literal|0x03CB
block|}
block|,
block|{
literal|0x1F06
block|,
literal|0x1F00
block|}
block|,
block|{
literal|0x1F07
block|,
literal|0x1F01
block|}
block|,
block|{
literal|0x1F0E
block|,
literal|0x1F08
block|}
block|,
block|{
literal|0x1F0F
block|,
literal|0x1F09
block|}
block|,
block|{
literal|0x1F26
block|,
literal|0x1F20
block|}
block|,
block|{
literal|0x1F27
block|,
literal|0x1F21
block|}
block|,
block|{
literal|0x1F2E
block|,
literal|0x1F28
block|}
block|,
block|{
literal|0x1F2F
block|,
literal|0x1F29
block|}
block|,
block|{
literal|0x1F36
block|,
literal|0x1F30
block|}
block|,
block|{
literal|0x1F37
block|,
literal|0x1F31
block|}
block|,
block|{
literal|0x1F3E
block|,
literal|0x1F38
block|}
block|,
block|{
literal|0x1F3F
block|,
literal|0x1F39
block|}
block|,
block|{
literal|0x1F56
block|,
literal|0x1F50
block|}
block|,
block|{
literal|0x1F57
block|,
literal|0x1F51
block|}
block|,
block|{
literal|0x1F5F
block|,
literal|0x1F59
block|}
block|,
block|{
literal|0x1F66
block|,
literal|0x1F60
block|}
block|,
block|{
literal|0x1F67
block|,
literal|0x1F61
block|}
block|,
block|{
literal|0x1F6E
block|,
literal|0x1F68
block|}
block|,
block|{
literal|0x1F6F
block|,
literal|0x1F69
block|}
block|,
block|{
literal|0x1FCF
block|,
literal|0x1FBF
block|}
block|,
block|{
literal|0x1FDF
block|,
literal|0x1FFE
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|compose_0x342
specifier|static
name|HB_UChar16
name|compose_0x342
parameter_list|(
name|HB_UChar16
name|base
parameter_list|)
block|{
specifier|const
name|hb_greek_decomposition
modifier|*
name|d
init|=
name|decompose_0x342
decl_stmt|;
while|while
condition|(
name|d
operator|->
name|base
operator|&&
name|d
operator|->
name|base
operator|!=
name|base
condition|)
operator|++
name|d
expr_stmt|;
return|return
name|d
operator|->
name|composed
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|decompose_0x345
specifier|static
specifier|const
name|hb_greek_decomposition
name|decompose_0x345
index|[]
init|=
block|{
block|{
literal|0x1FBC
block|,
literal|0x0391
block|}
block|,
block|{
literal|0x1FCC
block|,
literal|0x0397
block|}
block|,
block|{
literal|0x1FFC
block|,
literal|0x03A9
block|}
block|,
block|{
literal|0x1FB4
block|,
literal|0x03AC
block|}
block|,
block|{
literal|0x1FC4
block|,
literal|0x03AE
block|}
block|,
block|{
literal|0x1FB3
block|,
literal|0x03B1
block|}
block|,
block|{
literal|0x1FC3
block|,
literal|0x03B7
block|}
block|,
block|{
literal|0x1FF3
block|,
literal|0x03C9
block|}
block|,
block|{
literal|0x1FF4
block|,
literal|0x03CE
block|}
block|,
block|{
literal|0x1F80
block|,
literal|0x1F00
block|}
block|,
block|{
literal|0x1F81
block|,
literal|0x1F01
block|}
block|,
block|{
literal|0x1F82
block|,
literal|0x1F02
block|}
block|,
block|{
literal|0x1F83
block|,
literal|0x1F03
block|}
block|,
block|{
literal|0x1F84
block|,
literal|0x1F04
block|}
block|,
block|{
literal|0x1F85
block|,
literal|0x1F05
block|}
block|,
block|{
literal|0x1F86
block|,
literal|0x1F06
block|}
block|,
block|{
literal|0x1F87
block|,
literal|0x1F07
block|}
block|,
block|{
literal|0x1F88
block|,
literal|0x1F08
block|}
block|,
block|{
literal|0x1F89
block|,
literal|0x1F09
block|}
block|,
block|{
literal|0x1F8A
block|,
literal|0x1F0A
block|}
block|,
block|{
literal|0x1F8B
block|,
literal|0x1F0B
block|}
block|,
block|{
literal|0x1F8C
block|,
literal|0x1F0C
block|}
block|,
block|{
literal|0x1F8D
block|,
literal|0x1F0D
block|}
block|,
block|{
literal|0x1F8E
block|,
literal|0x1F0E
block|}
block|,
block|{
literal|0x1F8F
block|,
literal|0x1F0F
block|}
block|,
block|{
literal|0x1F90
block|,
literal|0x1F20
block|}
block|,
block|{
literal|0x1F91
block|,
literal|0x1F21
block|}
block|,
block|{
literal|0x1F92
block|,
literal|0x1F22
block|}
block|,
block|{
literal|0x1F93
block|,
literal|0x1F23
block|}
block|,
block|{
literal|0x1F94
block|,
literal|0x1F24
block|}
block|,
block|{
literal|0x1F95
block|,
literal|0x1F25
block|}
block|,
block|{
literal|0x1F96
block|,
literal|0x1F26
block|}
block|,
block|{
literal|0x1F97
block|,
literal|0x1F27
block|}
block|,
block|{
literal|0x1F98
block|,
literal|0x1F28
block|}
block|,
block|{
literal|0x1F99
block|,
literal|0x1F29
block|}
block|,
block|{
literal|0x1F9A
block|,
literal|0x1F2A
block|}
block|,
block|{
literal|0x1F9B
block|,
literal|0x1F2B
block|}
block|,
block|{
literal|0x1F9C
block|,
literal|0x1F2C
block|}
block|,
block|{
literal|0x1F9D
block|,
literal|0x1F2D
block|}
block|,
block|{
literal|0x1F9E
block|,
literal|0x1F2E
block|}
block|,
block|{
literal|0x1F9F
block|,
literal|0x1F2F
block|}
block|,
block|{
literal|0x1FA0
block|,
literal|0x1F60
block|}
block|,
block|{
literal|0x1FA1
block|,
literal|0x1F61
block|}
block|,
block|{
literal|0x1FA2
block|,
literal|0x1F62
block|}
block|,
block|{
literal|0x1FA3
block|,
literal|0x1F63
block|}
block|,
block|{
literal|0x1FA4
block|,
literal|0x1F64
block|}
block|,
block|{
literal|0x1FA5
block|,
literal|0x1F65
block|}
block|,
block|{
literal|0x1FA6
block|,
literal|0x1F66
block|}
block|,
block|{
literal|0x1FA7
block|,
literal|0x1F67
block|}
block|,
block|{
literal|0x1FA8
block|,
literal|0x1F68
block|}
block|,
block|{
literal|0x1FA9
block|,
literal|0x1F69
block|}
block|,
block|{
literal|0x1FAA
block|,
literal|0x1F6A
block|}
block|,
block|{
literal|0x1FAB
block|,
literal|0x1F6B
block|}
block|,
block|{
literal|0x1FAC
block|,
literal|0x1F6C
block|}
block|,
block|{
literal|0x1FAD
block|,
literal|0x1F6D
block|}
block|,
block|{
literal|0x1FAE
block|,
literal|0x1F6E
block|}
block|,
block|{
literal|0x1FAF
block|,
literal|0x1F6F
block|}
block|,
block|{
literal|0x1FB2
block|,
literal|0x1F70
block|}
block|,
block|{
literal|0x1FC2
block|,
literal|0x1F74
block|}
block|,
block|{
literal|0x1FF2
block|,
literal|0x1F7C
block|}
block|,
block|{
literal|0x1FB7
block|,
literal|0x1FB6
block|}
block|,
block|{
literal|0x1FC7
block|,
literal|0x1FC6
block|}
block|,
block|{
literal|0x1FF7
block|,
literal|0x1FF6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|compose_0x345
specifier|static
name|HB_UChar16
name|compose_0x345
parameter_list|(
name|HB_UChar16
name|base
parameter_list|)
block|{
specifier|const
name|hb_greek_decomposition
modifier|*
name|d
init|=
name|decompose_0x345
decl_stmt|;
while|while
condition|(
name|d
operator|->
name|base
operator|&&
name|d
operator|->
name|base
operator|!=
name|base
condition|)
operator|++
name|d
expr_stmt|;
return|return
name|d
operator|->
name|composed
return|;
block|}
end_function
begin_comment
comment|/*   Greek shaping. Heuristic positioning can't render polytonic greek correctly. We're a lot   better off mapping greek chars with diacritics to the characters in the extended greek   region in Unicode if possible. */
end_comment
begin_function
DECL|function|HB_GreekShape
name|HB_Bool
name|HB_GreekShape
parameter_list|(
name|HB_ShaperItem
modifier|*
name|shaper_item
parameter_list|)
block|{
specifier|const
name|int
name|availableGlyphs
init|=
name|shaper_item
operator|->
name|num_glyphs
decl_stmt|;
specifier|const
name|HB_UChar16
modifier|*
name|uc
init|=
name|shaper_item
operator|->
name|string
operator|+
name|shaper_item
operator|->
name|item
operator|.
name|pos
decl_stmt|;
name|unsigned
name|short
modifier|*
name|logClusters
init|=
name|shaper_item
operator|->
name|log_clusters
decl_stmt|;
name|HB_GlyphAttributes
modifier|*
name|attributes
init|=
name|shaper_item
operator|->
name|attributes
decl_stmt|;
name|HB_Bool
name|haveGlyphs
decl_stmt|;
name|int
name|slen
init|=
literal|1
decl_stmt|;
name|int
name|cluster_start
init|=
literal|0
decl_stmt|;
name|hb_uint32
name|i
decl_stmt|;
name|HB_STACKARRAY
argument_list|(
name|HB_UChar16
argument_list|,
name|shapedChars
argument_list|,
literal|2
operator|*
name|shaper_item
operator|->
name|item
operator|.
name|length
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|shaper_item
operator|->
name|item
operator|.
name|script
operator|==
name|HB_Script_Greek
argument_list|)
expr_stmt|;
operator|*
name|shapedChars
operator|=
operator|*
name|uc
expr_stmt|;
name|logClusters
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|attributes
index|[
literal|0
index|]
operator|.
name|mark
operator|=
name|false
expr_stmt|;
name|attributes
index|[
literal|0
index|]
operator|.
name|clusterStart
operator|=
name|true
expr_stmt|;
name|attributes
index|[
literal|0
index|]
operator|.
name|dontPrint
operator|=
name|false
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|shaper_item
operator|->
name|item
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|hb_uint16
name|base
init|=
name|shapedChars
index|[
name|slen
operator|-
literal|1
index|]
decl_stmt|;
name|hb_uint16
name|shaped
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|uc
index|[
name|i
index|]
operator|==
literal|0x300
condition|)
name|shaped
operator|=
name|compose_0x300
argument_list|(
name|base
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|uc
index|[
name|i
index|]
operator|==
literal|0x301
condition|)
name|shaped
operator|=
name|compose_0x301
argument_list|(
name|base
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|uc
index|[
name|i
index|]
operator|==
literal|0x304
condition|)
name|shaped
operator|=
name|compose_0x304
argument_list|(
name|base
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|uc
index|[
name|i
index|]
operator|==
literal|0x306
condition|)
name|shaped
operator|=
name|compose_0x306
argument_list|(
name|base
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|uc
index|[
name|i
index|]
operator|==
literal|0x308
condition|)
name|shaped
operator|=
name|compose_0x308
argument_list|(
name|base
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|uc
index|[
name|i
index|]
operator|==
literal|0x313
condition|)
name|shaped
operator|=
name|compose_0x313
argument_list|(
name|base
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|uc
index|[
name|i
index|]
operator|==
literal|0x314
condition|)
name|shaped
operator|=
name|compose_0x314
argument_list|(
name|base
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|uc
index|[
name|i
index|]
operator|==
literal|0x342
condition|)
name|shaped
operator|=
name|compose_0x342
argument_list|(
name|base
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|uc
index|[
name|i
index|]
operator|==
literal|0x345
condition|)
name|shaped
operator|=
name|compose_0x345
argument_list|(
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|shaped
condition|)
block|{
if|if
condition|(
name|shaper_item
operator|->
name|font
operator|->
name|klass
operator|->
name|canRender
argument_list|(
name|shaper_item
operator|->
name|font
argument_list|,
operator|(
name|HB_UChar16
operator|*
operator|)
operator|&
name|shaped
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|shapedChars
index|[
name|slen
operator|-
literal|1
index|]
operator|=
name|shaped
expr_stmt|;
block|}
else|else
block|{
name|shaped
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|shaped
condition|)
block|{
name|HB_CharCategory
name|category
decl_stmt|;
name|int
name|cmb
decl_stmt|;
name|shapedChars
index|[
name|slen
index|]
operator|=
name|uc
index|[
name|i
index|]
expr_stmt|;
name|HB_GetUnicodeCharProperties
argument_list|(
name|uc
index|[
name|i
index|]
argument_list|,
operator|&
name|category
argument_list|,
operator|&
name|cmb
argument_list|)
expr_stmt|;
if|if
condition|(
name|category
operator|!=
name|HB_Mark_NonSpacing
condition|)
block|{
name|attributes
index|[
name|slen
index|]
operator|.
name|clusterStart
operator|=
name|TRUE
expr_stmt|;
name|attributes
index|[
name|slen
index|]
operator|.
name|mark
operator|=
name|FALSE
expr_stmt|;
name|attributes
index|[
name|slen
index|]
operator|.
name|combiningClass
operator|=
literal|0
expr_stmt|;
name|attributes
index|[
name|slen
index|]
operator|.
name|dontPrint
operator|=
name|HB_IsControlChar
argument_list|(
name|uc
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|cluster_start
operator|=
name|slen
expr_stmt|;
block|}
else|else
block|{
name|attributes
index|[
name|slen
index|]
operator|.
name|clusterStart
operator|=
name|FALSE
expr_stmt|;
name|attributes
index|[
name|slen
index|]
operator|.
name|mark
operator|=
name|TRUE
expr_stmt|;
name|attributes
index|[
name|slen
index|]
operator|.
name|combiningClass
operator|=
name|cmb
expr_stmt|;
block|}
operator|++
name|slen
expr_stmt|;
block|}
name|logClusters
index|[
name|i
index|]
operator|=
name|cluster_start
expr_stmt|;
block|}
name|haveGlyphs
operator|=
name|shaper_item
operator|->
name|font
operator|->
name|klass
operator|->
name|convertStringToGlyphIndices
argument_list|(
name|shaper_item
operator|->
name|font
argument_list|,
name|shapedChars
argument_list|,
name|slen
argument_list|,
name|shaper_item
operator|->
name|glyphs
argument_list|,
operator|&
name|shaper_item
operator|->
name|num_glyphs
argument_list|,
name|shaper_item
operator|->
name|item
operator|.
name|bidiLevel
operator|%
literal|2
argument_list|)
expr_stmt|;
name|HB_FREE_STACKARRAY
argument_list|(
name|shapedChars
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|haveGlyphs
condition|)
return|return
name|FALSE
return|;
ifndef|#
directive|ifndef
name|NO_OPENTYPE
if|if
condition|(
name|HB_SelectScript
argument_list|(
name|shaper_item
argument_list|,
name|greek_features
argument_list|)
condition|)
block|{
name|HB_OpenTypeShape
argument_list|(
name|shaper_item
argument_list|,
comment|/*properties*/
literal|0
argument_list|)
expr_stmt|;
return|return
name|HB_OpenTypePosition
argument_list|(
name|shaper_item
argument_list|,
name|availableGlyphs
argument_list|,
comment|/*doLogClusters*/
name|TRUE
argument_list|)
return|;
block|}
endif|#
directive|endif
name|HB_HeuristicPosition
argument_list|(
name|shaper_item
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function
end_unit
