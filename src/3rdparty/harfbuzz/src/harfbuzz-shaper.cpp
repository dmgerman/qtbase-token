begin_unit
begin_comment
comment|/*  * Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies)  *  * This is part of HarfBuzz, an OpenType Layout engine library.  *  * Permission is hereby granted, without written agreement and without  * license or royalty fees, to use, copy, modify, and distribute this  * software and its documentation for any purpose, provided that the  * above copyright notice and the following two paragraphs appear in  * all copies of this software.  *  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH  * DAMAGE.  *  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS  * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.  */
end_comment
begin_include
include|#
directive|include
file|"harfbuzz-shaper.h"
end_include
begin_include
include|#
directive|include
file|"harfbuzz-shaper-private.h"
end_include
begin_include
include|#
directive|include
file|"harfbuzz-stream-private.h"
end_include
begin_include
include|#
directive|include
file|<assert.h>
end_include
begin_include
include|#
directive|include
file|<stdio.h>
end_include
begin_define
DECL|macro|HB_MIN
define|#
directive|define
name|HB_MIN
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)< (b) ? (a) : (b))
end_define
begin_define
DECL|macro|HB_MAX
define|#
directive|define
name|HB_MAX
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)> (b) ? (a) : (b))
end_define
begin_comment
comment|// --------------------------------------------------------------------------------------------------------------------------------------------
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// Basic processing
end_comment
begin_comment
comment|//
end_comment
begin_comment
comment|// --------------------------------------------------------------------------------------------------------------------------------------------
end_comment
begin_function
DECL|function|positionCluster
specifier|static
specifier|inline
name|void
name|positionCluster
parameter_list|(
name|HB_ShaperItem
modifier|*
name|item
parameter_list|,
name|int
name|gfrom
parameter_list|,
name|int
name|glast
parameter_list|)
block|{
name|int
name|nmarks
init|=
name|glast
operator|-
name|gfrom
decl_stmt|;
name|assert
argument_list|(
name|nmarks
operator|>
literal|0
argument_list|)
expr_stmt|;
name|HB_Glyph
modifier|*
name|glyphs
init|=
name|item
operator|->
name|glyphs
decl_stmt|;
name|HB_GlyphAttributes
modifier|*
name|attributes
init|=
name|item
operator|->
name|attributes
decl_stmt|;
name|HB_GlyphMetrics
name|baseMetrics
decl_stmt|;
name|item
operator|->
name|font
operator|->
name|klass
operator|->
name|getGlyphMetrics
argument_list|(
name|item
operator|->
name|font
argument_list|,
name|glyphs
index|[
name|gfrom
index|]
argument_list|,
operator|&
name|baseMetrics
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|->
name|item
operator|.
name|script
operator|==
name|HB_Script_Hebrew
operator|&&
operator|(
operator|-
name|baseMetrics
operator|.
name|y
operator|)
operator|>
name|baseMetrics
operator|.
name|height
condition|)
comment|// we need to attach below the baseline, because of the hebrew iud.
name|baseMetrics
operator|.
name|height
operator|=
operator|-
name|baseMetrics
operator|.
name|y
expr_stmt|;
comment|//     qDebug("---> positionCluster: cluster from %d to %d", gfrom, glast);
comment|//     qDebug("baseInfo: %f/%f (%f/%f) off=%f/%f", baseInfo.x, baseInfo.y, baseInfo.width, baseInfo.height, baseInfo.xoff, baseInfo.yoff);
name|HB_Fixed
name|size
init|=
name|item
operator|->
name|font
operator|->
name|klass
operator|->
name|getFontMetric
argument_list|(
name|item
operator|->
name|font
argument_list|,
name|HB_FontAscent
argument_list|)
operator|/
literal|10
decl_stmt|;
name|HB_Fixed
name|offsetBase
init|=
name|HB_FIXED_CONSTANT
argument_list|(
literal|1
argument_list|)
operator|+
operator|(
name|size
operator|-
name|HB_FIXED_CONSTANT
argument_list|(
literal|4
argument_list|)
operator|)
operator|/
literal|4
decl_stmt|;
if|if
condition|(
name|size
operator|>
name|HB_FIXED_CONSTANT
argument_list|(
literal|4
argument_list|)
condition|)
name|offsetBase
operator|+=
name|HB_FIXED_CONSTANT
argument_list|(
literal|4
argument_list|)
expr_stmt|;
else|else
name|offsetBase
operator|+=
name|size
expr_stmt|;
comment|//qreal offsetBase = (size - 4) / 4 + qMin<qreal>(size, 4) + 1;
comment|//     qDebug("offset = %f", offsetBase);
comment|// To fix some Thai character heights check for two above glyphs
if|if
condition|(
name|nmarks
operator|==
literal|2
operator|&&
operator|(
name|attributes
index|[
name|gfrom
operator|+
literal|1
index|]
operator|.
name|combiningClass
operator|==
name|HB_Combining_AboveRight
operator|||
name|attributes
index|[
name|gfrom
operator|+
literal|1
index|]
operator|.
name|combiningClass
operator|==
name|HB_Combining_AboveLeft
operator|||
name|attributes
index|[
name|gfrom
operator|+
literal|1
index|]
operator|.
name|combiningClass
operator|==
name|HB_Combining_Above
operator|)
condition|)
if|if
condition|(
name|attributes
index|[
name|gfrom
operator|+
literal|2
index|]
operator|.
name|combiningClass
operator|==
literal|23
operator|||
name|attributes
index|[
name|gfrom
operator|+
literal|2
index|]
operator|.
name|combiningClass
operator|==
literal|24
operator|||
name|attributes
index|[
name|gfrom
operator|+
literal|2
index|]
operator|.
name|combiningClass
operator|==
literal|25
operator|||
name|attributes
index|[
name|gfrom
operator|+
literal|2
index|]
operator|.
name|combiningClass
operator|==
literal|27
operator|||
name|attributes
index|[
name|gfrom
operator|+
literal|2
index|]
operator|.
name|combiningClass
operator|==
literal|28
operator|||
name|attributes
index|[
name|gfrom
operator|+
literal|2
index|]
operator|.
name|combiningClass
operator|==
literal|30
operator|||
name|attributes
index|[
name|gfrom
operator|+
literal|2
index|]
operator|.
name|combiningClass
operator|==
literal|31
operator|||
name|attributes
index|[
name|gfrom
operator|+
literal|2
index|]
operator|.
name|combiningClass
operator|==
literal|33
operator|||
name|attributes
index|[
name|gfrom
operator|+
literal|2
index|]
operator|.
name|combiningClass
operator|==
literal|34
operator|||
name|attributes
index|[
name|gfrom
operator|+
literal|2
index|]
operator|.
name|combiningClass
operator|==
literal|35
operator|||
name|attributes
index|[
name|gfrom
operator|+
literal|2
index|]
operator|.
name|combiningClass
operator|==
literal|36
operator|||
name|attributes
index|[
name|gfrom
operator|+
literal|2
index|]
operator|.
name|combiningClass
operator|==
literal|107
operator|||
name|attributes
index|[
name|gfrom
operator|+
literal|2
index|]
operator|.
name|combiningClass
operator|==
literal|122
condition|)
block|{
comment|// Two above glyphs, check total height
name|int
name|markTotalHeight
init|=
name|baseMetrics
operator|.
name|height
decl_stmt|;
name|HB_GlyphMetrics
name|markMetrics
decl_stmt|;
name|item
operator|->
name|font
operator|->
name|klass
operator|->
name|getGlyphMetrics
argument_list|(
name|item
operator|->
name|font
argument_list|,
name|glyphs
index|[
name|gfrom
operator|+
literal|1
index|]
argument_list|,
operator|&
name|markMetrics
argument_list|)
expr_stmt|;
name|markTotalHeight
operator|+=
name|markMetrics
operator|.
name|height
expr_stmt|;
name|item
operator|->
name|font
operator|->
name|klass
operator|->
name|getGlyphMetrics
argument_list|(
name|item
operator|->
name|font
argument_list|,
name|glyphs
index|[
name|gfrom
operator|+
literal|2
index|]
argument_list|,
operator|&
name|markMetrics
argument_list|)
expr_stmt|;
name|markTotalHeight
operator|+=
name|markMetrics
operator|.
name|height
expr_stmt|;
if|if
condition|(
operator|(
name|markTotalHeight
operator|+
literal|2
operator|*
name|offsetBase
operator|)
operator|>
operator|(
name|size
operator|*
literal|10
operator|)
condition|)
name|offsetBase
operator|=
operator|(
operator|(
name|size
operator|*
literal|10
operator|)
operator|-
name|markTotalHeight
operator|)
operator|/
literal|2
expr_stmt|;
comment|// Use offset that just fits
block|}
name|bool
name|rightToLeft
init|=
name|item
operator|->
name|item
operator|.
name|bidiLevel
operator|%
literal|2
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unsigned
name|char
name|lastCmb
init|=
literal|0
decl_stmt|;
name|HB_GlyphMetrics
name|attachmentRect
decl_stmt|;
name|memset
argument_list|(
operator|&
name|attachmentRect
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|attachmentRect
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|nmarks
condition|;
name|i
operator|++
control|)
block|{
name|HB_Glyph
name|mark
init|=
name|glyphs
index|[
name|gfrom
operator|+
name|i
index|]
decl_stmt|;
name|HB_GlyphMetrics
name|markMetrics
decl_stmt|;
name|item
operator|->
name|font
operator|->
name|klass
operator|->
name|getGlyphMetrics
argument_list|(
name|item
operator|->
name|font
argument_list|,
name|mark
argument_list|,
operator|&
name|markMetrics
argument_list|)
expr_stmt|;
name|HB_FixedPoint
name|p
decl_stmt|;
name|p
operator|.
name|x
operator|=
name|p
operator|.
name|y
operator|=
literal|0
expr_stmt|;
comment|//          qDebug("markInfo: %f/%f (%f/%f) off=%f/%f", markInfo.x, markInfo.y, markInfo.width, markInfo.height, markInfo.xoff, markInfo.yoff);
name|HB_Fixed
name|offset
init|=
name|offsetBase
decl_stmt|;
name|unsigned
name|char
name|cmb
init|=
name|attributes
index|[
name|gfrom
operator|+
name|i
index|]
operator|.
name|combiningClass
decl_stmt|;
comment|// ### maybe the whole position determination should move down to heuristicSetGlyphAttributes. Would save some
comment|// bits  in the glyphAttributes structure.
if|if
condition|(
name|cmb
operator|<
literal|200
condition|)
block|{
comment|// fixed position classes. We approximate by mapping to one of the others.
comment|// currently I added only the ones for arabic, hebrew, lao and thai.
comment|// for Lao and Thai marks with class 0, see below (heuristicSetGlyphAttributes)
comment|// add a bit more offset to arabic, a bit hacky
if|if
condition|(
name|cmb
operator|>=
literal|27
operator|&&
name|cmb
operator|<=
literal|36
operator|&&
name|offset
operator|<
literal|3
condition|)
name|offset
operator|+=
literal|1
expr_stmt|;
comment|// below
if|if
condition|(
operator|(
name|cmb
operator|>=
literal|10
operator|&&
name|cmb
operator|<=
literal|18
operator|)
operator|||
name|cmb
operator|==
literal|20
operator|||
name|cmb
operator|==
literal|22
operator|||
name|cmb
operator|==
literal|29
operator|||
name|cmb
operator|==
literal|32
condition|)
name|cmb
operator|=
name|HB_Combining_Below
expr_stmt|;
comment|// above
elseif|else
if|if
condition|(
name|cmb
operator|==
literal|23
operator|||
name|cmb
operator|==
literal|27
operator|||
name|cmb
operator|==
literal|28
operator|||
name|cmb
operator|==
literal|30
operator|||
name|cmb
operator|==
literal|31
operator|||
operator|(
name|cmb
operator|>=
literal|33
operator|&&
name|cmb
operator|<=
literal|36
operator|)
condition|)
name|cmb
operator|=
name|HB_Combining_Above
expr_stmt|;
comment|//below-right
elseif|else
if|if
condition|(
name|cmb
operator|==
literal|9
operator|||
name|cmb
operator|==
literal|103
operator|||
name|cmb
operator|==
literal|118
condition|)
name|cmb
operator|=
name|HB_Combining_BelowRight
expr_stmt|;
comment|// above-right
elseif|else
if|if
condition|(
name|cmb
operator|==
literal|24
operator|||
name|cmb
operator|==
literal|107
operator|||
name|cmb
operator|==
literal|122
condition|)
name|cmb
operator|=
name|HB_Combining_AboveRight
expr_stmt|;
elseif|else
if|if
condition|(
name|cmb
operator|==
literal|25
condition|)
name|cmb
operator|=
name|HB_Combining_AboveLeft
expr_stmt|;
comment|// fixed:
comment|//  19 21
block|}
comment|// combining marks of different class don't interact. Reset the rectangle.
if|if
condition|(
name|cmb
operator|!=
name|lastCmb
condition|)
block|{
comment|//qDebug("resetting rect");
name|attachmentRect
operator|=
name|baseMetrics
expr_stmt|;
block|}
switch|switch
condition|(
name|cmb
condition|)
block|{
case|case
name|HB_Combining_DoubleBelow
case|:
comment|// ### wrong in rtl context!
case|case
name|HB_Combining_BelowLeft
case|:
name|p
operator|.
name|y
operator|+=
name|offset
expr_stmt|;
case|case
name|HB_Combining_BelowLeftAttached
case|:
name|p
operator|.
name|x
operator|+=
name|attachmentRect
operator|.
name|x
operator|-
name|markMetrics
operator|.
name|x
expr_stmt|;
name|p
operator|.
name|y
operator|+=
operator|(
name|attachmentRect
operator|.
name|y
operator|+
name|attachmentRect
operator|.
name|height
operator|)
operator|-
name|markMetrics
operator|.
name|y
expr_stmt|;
break|break;
case|case
name|HB_Combining_Below
case|:
name|p
operator|.
name|y
operator|+=
name|offset
expr_stmt|;
case|case
name|HB_Combining_BelowAttached
case|:
name|p
operator|.
name|x
operator|+=
name|attachmentRect
operator|.
name|x
operator|-
name|markMetrics
operator|.
name|x
expr_stmt|;
name|p
operator|.
name|y
operator|+=
operator|(
name|attachmentRect
operator|.
name|y
operator|+
name|attachmentRect
operator|.
name|height
operator|)
operator|-
name|markMetrics
operator|.
name|y
expr_stmt|;
name|p
operator|.
name|x
operator|+=
operator|(
name|attachmentRect
operator|.
name|width
operator|-
name|markMetrics
operator|.
name|width
operator|)
operator|/
literal|2
expr_stmt|;
break|break;
case|case
name|HB_Combining_BelowRight
case|:
name|p
operator|.
name|y
operator|+=
name|offset
expr_stmt|;
case|case
name|HB_Combining_BelowRightAttached
case|:
name|p
operator|.
name|x
operator|+=
name|attachmentRect
operator|.
name|x
operator|+
name|attachmentRect
operator|.
name|width
operator|-
name|markMetrics
operator|.
name|width
operator|-
name|markMetrics
operator|.
name|x
expr_stmt|;
name|p
operator|.
name|y
operator|+=
name|attachmentRect
operator|.
name|y
operator|+
name|attachmentRect
operator|.
name|height
operator|-
name|markMetrics
operator|.
name|y
expr_stmt|;
break|break;
case|case
name|HB_Combining_Left
case|:
name|p
operator|.
name|x
operator|-=
name|offset
expr_stmt|;
case|case
name|HB_Combining_LeftAttached
case|:
break|break;
case|case
name|HB_Combining_Right
case|:
name|p
operator|.
name|x
operator|+=
name|offset
expr_stmt|;
case|case
name|HB_Combining_RightAttached
case|:
break|break;
case|case
name|HB_Combining_DoubleAbove
case|:
comment|// ### wrong in RTL context!
case|case
name|HB_Combining_AboveLeft
case|:
name|p
operator|.
name|y
operator|-=
name|offset
expr_stmt|;
case|case
name|HB_Combining_AboveLeftAttached
case|:
name|p
operator|.
name|x
operator|+=
name|attachmentRect
operator|.
name|x
operator|-
name|markMetrics
operator|.
name|x
expr_stmt|;
name|p
operator|.
name|y
operator|+=
name|attachmentRect
operator|.
name|y
operator|-
name|markMetrics
operator|.
name|y
operator|-
name|markMetrics
operator|.
name|height
expr_stmt|;
break|break;
case|case
name|HB_Combining_Above
case|:
name|p
operator|.
name|y
operator|-=
name|offset
expr_stmt|;
case|case
name|HB_Combining_AboveAttached
case|:
name|p
operator|.
name|x
operator|+=
name|attachmentRect
operator|.
name|x
operator|-
name|markMetrics
operator|.
name|x
expr_stmt|;
name|p
operator|.
name|y
operator|+=
name|attachmentRect
operator|.
name|y
operator|-
name|markMetrics
operator|.
name|y
operator|-
name|markMetrics
operator|.
name|height
expr_stmt|;
name|p
operator|.
name|x
operator|+=
operator|(
name|attachmentRect
operator|.
name|width
operator|-
name|markMetrics
operator|.
name|width
operator|)
operator|/
literal|2
expr_stmt|;
break|break;
case|case
name|HB_Combining_AboveRight
case|:
name|p
operator|.
name|y
operator|-=
name|offset
expr_stmt|;
case|case
name|HB_Combining_AboveRightAttached
case|:
name|p
operator|.
name|x
operator|+=
name|attachmentRect
operator|.
name|x
operator|+
name|attachmentRect
operator|.
name|width
operator|-
name|markMetrics
operator|.
name|x
operator|-
name|markMetrics
operator|.
name|width
expr_stmt|;
name|p
operator|.
name|y
operator|+=
name|attachmentRect
operator|.
name|y
operator|-
name|markMetrics
operator|.
name|y
operator|-
name|markMetrics
operator|.
name|height
expr_stmt|;
break|break;
case|case
name|HB_Combining_IotaSubscript
case|:
default|default:
break|break;
block|}
comment|//          qDebug("char=%x combiningClass = %d offset=%f/%f", mark, cmb, p.x(), p.y());
name|markMetrics
operator|.
name|x
operator|+=
name|p
operator|.
name|x
expr_stmt|;
name|markMetrics
operator|.
name|y
operator|+=
name|p
operator|.
name|y
expr_stmt|;
name|HB_GlyphMetrics
name|unitedAttachmentRect
init|=
name|attachmentRect
decl_stmt|;
name|unitedAttachmentRect
operator|.
name|x
operator|=
name|HB_MIN
argument_list|(
name|attachmentRect
operator|.
name|x
argument_list|,
name|markMetrics
operator|.
name|x
argument_list|)
expr_stmt|;
name|unitedAttachmentRect
operator|.
name|y
operator|=
name|HB_MIN
argument_list|(
name|attachmentRect
operator|.
name|y
argument_list|,
name|markMetrics
operator|.
name|y
argument_list|)
expr_stmt|;
name|unitedAttachmentRect
operator|.
name|width
operator|=
name|HB_MAX
argument_list|(
name|attachmentRect
operator|.
name|x
operator|+
name|attachmentRect
operator|.
name|width
argument_list|,
name|markMetrics
operator|.
name|x
operator|+
name|markMetrics
operator|.
name|width
argument_list|)
operator|-
name|unitedAttachmentRect
operator|.
name|x
expr_stmt|;
name|unitedAttachmentRect
operator|.
name|height
operator|=
name|HB_MAX
argument_list|(
name|attachmentRect
operator|.
name|y
operator|+
name|attachmentRect
operator|.
name|height
argument_list|,
name|markMetrics
operator|.
name|y
operator|+
name|markMetrics
operator|.
name|height
argument_list|)
operator|-
name|unitedAttachmentRect
operator|.
name|y
expr_stmt|;
name|attachmentRect
operator|=
name|unitedAttachmentRect
expr_stmt|;
name|lastCmb
operator|=
name|cmb
expr_stmt|;
if|if
condition|(
name|rightToLeft
condition|)
block|{
name|item
operator|->
name|offsets
index|[
name|gfrom
operator|+
name|i
index|]
operator|.
name|x
operator|=
name|p
operator|.
name|x
expr_stmt|;
name|item
operator|->
name|offsets
index|[
name|gfrom
operator|+
name|i
index|]
operator|.
name|y
operator|=
name|p
operator|.
name|y
expr_stmt|;
block|}
else|else
block|{
name|item
operator|->
name|offsets
index|[
name|gfrom
operator|+
name|i
index|]
operator|.
name|x
operator|=
name|p
operator|.
name|x
operator|-
name|baseMetrics
operator|.
name|xOffset
expr_stmt|;
name|item
operator|->
name|offsets
index|[
name|gfrom
operator|+
name|i
index|]
operator|.
name|y
operator|=
name|p
operator|.
name|y
operator|-
name|baseMetrics
operator|.
name|yOffset
expr_stmt|;
block|}
name|item
operator|->
name|advances
index|[
name|gfrom
operator|+
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|HB_HeuristicPosition
name|void
name|HB_HeuristicPosition
parameter_list|(
name|HB_ShaperItem
modifier|*
name|item
parameter_list|)
block|{
name|HB_GetGlyphAdvances
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|HB_GlyphAttributes
modifier|*
name|attributes
init|=
name|item
operator|->
name|attributes
decl_stmt|;
name|int
name|cEnd
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|i
init|=
name|item
operator|->
name|num_glyphs
decl_stmt|;
while|while
condition|(
name|i
operator|--
condition|)
block|{
if|if
condition|(
name|cEnd
operator|==
operator|-
literal|1
operator|&&
name|attributes
index|[
name|i
index|]
operator|.
name|mark
condition|)
block|{
name|cEnd
operator|=
name|i
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cEnd
operator|!=
operator|-
literal|1
operator|&&
operator|!
name|attributes
index|[
name|i
index|]
operator|.
name|mark
condition|)
block|{
name|positionCluster
argument_list|(
name|item
argument_list|,
name|i
argument_list|,
name|cEnd
argument_list|)
expr_stmt|;
name|cEnd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|// set the glyph attributes heuristically. Assumes a 1 to 1 relationship between chars and glyphs
end_comment
begin_comment
comment|// and no reordering.
end_comment
begin_comment
comment|// also computes logClusters heuristically
end_comment
begin_function
DECL|function|HB_HeuristicSetGlyphAttributes
name|void
name|HB_HeuristicSetGlyphAttributes
parameter_list|(
name|HB_ShaperItem
modifier|*
name|item
parameter_list|)
block|{
specifier|const
name|HB_UChar16
modifier|*
name|uc
init|=
name|item
operator|->
name|string
operator|+
name|item
operator|->
name|item
operator|.
name|pos
decl_stmt|;
name|hb_uint32
name|length
init|=
name|item
operator|->
name|item
operator|.
name|length
decl_stmt|;
comment|// ### zeroWidth and justification are missing here!!!!!
name|assert
argument_list|(
name|item
operator|->
name|num_glyphs
operator|<=
name|length
argument_list|)
expr_stmt|;
comment|//     qDebug("QScriptEngine::heuristicSetGlyphAttributes, num_glyphs=%d", item->num_glyphs);
name|HB_GlyphAttributes
modifier|*
name|attributes
init|=
name|item
operator|->
name|attributes
decl_stmt|;
name|unsigned
name|short
modifier|*
name|logClusters
init|=
name|item
operator|->
name|log_clusters
decl_stmt|;
name|hb_uint32
name|glyph_pos
init|=
literal|0
decl_stmt|;
name|hb_uint32
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|HB_IsHighSurrogate
argument_list|(
name|uc
index|[
name|i
index|]
argument_list|)
operator|&&
name|i
operator|<
name|length
operator|-
literal|1
operator|&&
name|HB_IsLowSurrogate
argument_list|(
name|uc
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
condition|)
block|{
name|logClusters
index|[
name|i
index|]
operator|=
name|glyph_pos
expr_stmt|;
name|logClusters
index|[
operator|++
name|i
index|]
operator|=
name|glyph_pos
expr_stmt|;
block|}
else|else
block|{
name|logClusters
index|[
name|i
index|]
operator|=
name|glyph_pos
expr_stmt|;
block|}
operator|++
name|glyph_pos
expr_stmt|;
block|}
name|assert
argument_list|(
name|glyph_pos
operator|==
name|item
operator|->
name|num_glyphs
argument_list|)
expr_stmt|;
comment|// first char in a run is never (treated as) a mark
name|int
name|cStart
init|=
literal|0
decl_stmt|;
specifier|const
name|bool
name|symbolFont
init|=
name|item
operator|->
name|face
operator|->
name|isSymbolFont
decl_stmt|;
name|attributes
index|[
literal|0
index|]
operator|.
name|mark
operator|=
literal|false
expr_stmt|;
name|attributes
index|[
literal|0
index|]
operator|.
name|clusterStart
operator|=
literal|true
expr_stmt|;
name|attributes
index|[
literal|0
index|]
operator|.
name|dontPrint
operator|=
operator|(
operator|!
name|symbolFont
operator|&&
name|uc
index|[
literal|0
index|]
operator|==
literal|0x00ad
operator|)
operator|||
name|HB_IsControlChar
argument_list|(
name|uc
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|int
name|pos
init|=
literal|0
decl_stmt|;
name|HB_CharCategory
name|lastCat
decl_stmt|;
name|int
name|dummy
decl_stmt|;
name|HB_GetUnicodeCharProperties
argument_list|(
name|uc
index|[
literal|0
index|]
argument_list|,
operator|&
name|lastCat
argument_list|,
operator|&
name|dummy
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|length
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|logClusters
index|[
name|i
index|]
operator|==
name|pos
condition|)
comment|// same glyph
continue|continue;
operator|++
name|pos
expr_stmt|;
while|while
condition|(
name|pos
operator|<
name|logClusters
index|[
name|i
index|]
condition|)
block|{
name|attributes
index|[
name|pos
index|]
operator|=
name|attributes
index|[
name|pos
operator|-
literal|1
index|]
expr_stmt|;
operator|++
name|pos
expr_stmt|;
block|}
comment|// hide soft-hyphens by default
if|if
condition|(
operator|(
operator|!
name|symbolFont
operator|&&
name|uc
index|[
name|i
index|]
operator|==
literal|0x00ad
operator|)
operator|||
name|HB_IsControlChar
argument_list|(
name|uc
index|[
name|i
index|]
argument_list|)
condition|)
name|attributes
index|[
name|pos
index|]
operator|.
name|dontPrint
operator|=
literal|true
expr_stmt|;
name|HB_CharCategory
name|cat
decl_stmt|;
name|int
name|cmb
decl_stmt|;
name|HB_GetUnicodeCharProperties
argument_list|(
name|uc
index|[
name|i
index|]
argument_list|,
operator|&
name|cat
argument_list|,
operator|&
name|cmb
argument_list|)
expr_stmt|;
if|if
condition|(
name|cat
operator|!=
name|HB_Mark_NonSpacing
condition|)
block|{
name|attributes
index|[
name|pos
index|]
operator|.
name|mark
operator|=
literal|false
expr_stmt|;
name|attributes
index|[
name|pos
index|]
operator|.
name|clusterStart
operator|=
literal|true
expr_stmt|;
name|attributes
index|[
name|pos
index|]
operator|.
name|combiningClass
operator|=
literal|0
expr_stmt|;
name|cStart
operator|=
name|logClusters
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|cmb
operator|==
literal|0
condition|)
block|{
comment|// Fix 0 combining classes
if|if
condition|(
operator|(
name|uc
index|[
name|pos
index|]
operator|&
literal|0xff00
operator|)
operator|==
literal|0x0e00
condition|)
block|{
comment|// thai or lao
if|if
condition|(
name|uc
index|[
name|pos
index|]
operator|==
literal|0xe31
operator|||
name|uc
index|[
name|pos
index|]
operator|==
literal|0xe34
operator|||
name|uc
index|[
name|pos
index|]
operator|==
literal|0xe35
operator|||
name|uc
index|[
name|pos
index|]
operator|==
literal|0xe36
operator|||
name|uc
index|[
name|pos
index|]
operator|==
literal|0xe37
operator|||
name|uc
index|[
name|pos
index|]
operator|==
literal|0xe47
operator|||
name|uc
index|[
name|pos
index|]
operator|==
literal|0xe4c
operator|||
name|uc
index|[
name|pos
index|]
operator|==
literal|0xe4d
operator|||
name|uc
index|[
name|pos
index|]
operator|==
literal|0xe4e
condition|)
block|{
name|cmb
operator|=
name|HB_Combining_AboveRight
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|uc
index|[
name|pos
index|]
operator|==
literal|0xeb1
operator|||
name|uc
index|[
name|pos
index|]
operator|==
literal|0xeb4
operator|||
name|uc
index|[
name|pos
index|]
operator|==
literal|0xeb5
operator|||
name|uc
index|[
name|pos
index|]
operator|==
literal|0xeb6
operator|||
name|uc
index|[
name|pos
index|]
operator|==
literal|0xeb7
operator|||
name|uc
index|[
name|pos
index|]
operator|==
literal|0xebb
operator|||
name|uc
index|[
name|pos
index|]
operator|==
literal|0xecc
operator|||
name|uc
index|[
name|pos
index|]
operator|==
literal|0xecd
condition|)
block|{
name|cmb
operator|=
name|HB_Combining_Above
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|uc
index|[
name|pos
index|]
operator|==
literal|0xebc
condition|)
block|{
name|cmb
operator|=
name|HB_Combining_Below
expr_stmt|;
block|}
block|}
block|}
name|attributes
index|[
name|pos
index|]
operator|.
name|mark
operator|=
literal|true
expr_stmt|;
name|attributes
index|[
name|pos
index|]
operator|.
name|clusterStart
operator|=
literal|false
expr_stmt|;
name|attributes
index|[
name|pos
index|]
operator|.
name|combiningClass
operator|=
name|cmb
expr_stmt|;
name|logClusters
index|[
name|i
index|]
operator|=
name|cStart
expr_stmt|;
block|}
comment|// one gets an inter character justification point if the current char is not a non spacing mark.
comment|// as then the current char belongs to the last one and one gets a space justification point
comment|// after the space char.
if|if
condition|(
name|lastCat
operator|==
name|HB_Separator_Space
condition|)
name|attributes
index|[
name|pos
operator|-
literal|1
index|]
operator|.
name|justification
operator|=
name|HB_Space
expr_stmt|;
elseif|else
if|if
condition|(
name|cat
operator|!=
name|HB_Mark_NonSpacing
condition|)
name|attributes
index|[
name|pos
operator|-
literal|1
index|]
operator|.
name|justification
operator|=
name|HB_Character
expr_stmt|;
else|else
name|attributes
index|[
name|pos
operator|-
literal|1
index|]
operator|.
name|justification
operator|=
name|HB_NoJustification
expr_stmt|;
name|lastCat
operator|=
name|cat
expr_stmt|;
block|}
name|pos
operator|=
name|logClusters
index|[
name|length
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|lastCat
operator|==
name|HB_Separator_Space
condition|)
name|attributes
index|[
name|pos
index|]
operator|.
name|justification
operator|=
name|HB_Space
expr_stmt|;
else|else
name|attributes
index|[
name|pos
index|]
operator|.
name|justification
operator|=
name|HB_Character
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|NO_OPENTYPE
end_ifndef
begin_decl_stmt
DECL|variable|basic_features
specifier|static
specifier|const
name|HB_OpenTypeFeature
name|basic_features
index|[]
init|=
block|{
block|{
name|HB_MAKE_TAG
argument_list|(
literal|'c'
argument_list|,
literal|'c'
argument_list|,
literal|'m'
argument_list|,
literal|'p'
argument_list|)
block|,
name|CcmpProperty
block|}
block|,
block|{
name|HB_MAKE_TAG
argument_list|(
literal|'l'
argument_list|,
literal|'i'
argument_list|,
literal|'g'
argument_list|,
literal|'a'
argument_list|)
block|,
name|LigaProperty
block|}
block|,
block|{
name|HB_MAKE_TAG
argument_list|(
literal|'c'
argument_list|,
literal|'l'
argument_list|,
literal|'i'
argument_list|,
literal|'g'
argument_list|)
block|,
name|CligProperty
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|disabled_features
specifier|static
specifier|const
name|HB_OpenTypeFeature
name|disabled_features
index|[]
init|=
block|{
block|{
name|HB_MAKE_TAG
argument_list|(
literal|'c'
argument_list|,
literal|'p'
argument_list|,
literal|'c'
argument_list|,
literal|'t'
argument_list|)
block|,
name|PositioningProperties
block|}
block|,
block|{
name|HB_MAKE_TAG
argument_list|(
literal|'h'
argument_list|,
literal|'a'
argument_list|,
literal|'l'
argument_list|,
literal|'t'
argument_list|)
block|,
name|PositioningProperties
block|}
block|,
comment|// TODO: we need to add certain HB_ShaperFlag for vertical
comment|// writing mode to enable these vertical writing features:
block|{
name|HB_MAKE_TAG
argument_list|(
literal|'v'
argument_list|,
literal|'a'
argument_list|,
literal|'l'
argument_list|,
literal|'t'
argument_list|)
block|,
name|PositioningProperties
block|}
block|,
block|{
name|HB_MAKE_TAG
argument_list|(
literal|'v'
argument_list|,
literal|'h'
argument_list|,
literal|'a'
argument_list|,
literal|'l'
argument_list|)
block|,
name|PositioningProperties
block|}
block|,
block|{
name|HB_MAKE_TAG
argument_list|(
literal|'v'
argument_list|,
literal|'k'
argument_list|,
literal|'r'
argument_list|,
literal|'n'
argument_list|)
block|,
name|PositioningProperties
block|}
block|,
block|{
name|HB_MAKE_TAG
argument_list|(
literal|'v'
argument_list|,
literal|'p'
argument_list|,
literal|'a'
argument_list|,
literal|'l'
argument_list|)
block|,
name|PositioningProperties
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|HB_ConvertStringToGlyphIndices
name|HB_Bool
name|HB_ConvertStringToGlyphIndices
parameter_list|(
name|HB_ShaperItem
modifier|*
name|shaper_item
parameter_list|)
block|{
if|if
condition|(
name|shaper_item
operator|->
name|glyphIndicesPresent
condition|)
block|{
name|shaper_item
operator|->
name|num_glyphs
operator|=
name|shaper_item
operator|->
name|initialGlyphCount
expr_stmt|;
name|shaper_item
operator|->
name|glyphIndicesPresent
operator|=
literal|false
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
name|shaper_item
operator|->
name|font
operator|->
name|klass
operator|->
name|convertStringToGlyphIndices
argument_list|(
name|shaper_item
operator|->
name|font
argument_list|,
name|shaper_item
operator|->
name|string
operator|+
name|shaper_item
operator|->
name|item
operator|.
name|pos
argument_list|,
name|shaper_item
operator|->
name|item
operator|.
name|length
argument_list|,
name|shaper_item
operator|->
name|glyphs
argument_list|,
operator|&
name|shaper_item
operator|->
name|num_glyphs
argument_list|,
name|shaper_item
operator|->
name|item
operator|.
name|bidiLevel
operator|%
literal|2
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|HB_BasicShape
name|HB_Bool
name|HB_BasicShape
parameter_list|(
name|HB_ShaperItem
modifier|*
name|shaper_item
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|NO_OPENTYPE
specifier|const
name|int
name|availableGlyphs
init|=
name|shaper_item
operator|->
name|num_glyphs
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|HB_ConvertStringToGlyphIndices
argument_list|(
name|shaper_item
argument_list|)
condition|)
return|return
literal|false
return|;
name|HB_HeuristicSetGlyphAttributes
argument_list|(
name|shaper_item
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_OPENTYPE
if|if
condition|(
name|HB_SelectScript
argument_list|(
name|shaper_item
argument_list|,
name|basic_features
argument_list|)
condition|)
block|{
name|HB_OpenTypeShape
argument_list|(
name|shaper_item
argument_list|,
comment|/*properties*/
literal|0
argument_list|)
expr_stmt|;
return|return
name|HB_OpenTypePosition
argument_list|(
name|shaper_item
argument_list|,
name|availableGlyphs
argument_list|,
comment|/*doLogClusters*/
literal|true
argument_list|)
return|;
block|}
endif|#
directive|endif
name|HB_HeuristicPosition
argument_list|(
name|shaper_item
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|HB_ScriptEngines
specifier|const
name|HB_ScriptEngine
name|HB_ScriptEngines
index|[]
init|=
block|{
comment|// Common
block|{
name|HB_BasicShape
block|,
literal|0
block|}
block|,
comment|// Greek
block|{
name|HB_GreekShape
block|,
literal|0
block|}
block|,
comment|// Cyrillic
block|{
name|HB_BasicShape
block|,
literal|0
block|}
block|,
comment|// Armenian
block|{
name|HB_BasicShape
block|,
literal|0
block|}
block|,
comment|// Hebrew
block|{
name|HB_HebrewShape
block|,
literal|0
block|}
block|,
comment|// Arabic
block|{
name|HB_ArabicShape
block|,
literal|0
block|}
block|,
comment|// Syriac
block|{
name|HB_ArabicShape
block|,
literal|0
block|}
block|,
comment|// Thaana
block|{
name|HB_BasicShape
block|,
literal|0
block|}
block|,
comment|// Devanagari
block|{
name|HB_IndicShape
block|,
name|HB_IndicAttributes
block|}
block|,
comment|// Bengali
block|{
name|HB_IndicShape
block|,
name|HB_IndicAttributes
block|}
block|,
comment|// Gurmukhi
block|{
name|HB_IndicShape
block|,
name|HB_IndicAttributes
block|}
block|,
comment|// Gujarati
block|{
name|HB_IndicShape
block|,
name|HB_IndicAttributes
block|}
block|,
comment|// Oriya
block|{
name|HB_IndicShape
block|,
name|HB_IndicAttributes
block|}
block|,
comment|// Tamil
block|{
name|HB_IndicShape
block|,
name|HB_IndicAttributes
block|}
block|,
comment|// Telugu
block|{
name|HB_IndicShape
block|,
name|HB_IndicAttributes
block|}
block|,
comment|// Kannada
block|{
name|HB_IndicShape
block|,
name|HB_IndicAttributes
block|}
block|,
comment|// Malayalam
block|{
name|HB_IndicShape
block|,
name|HB_IndicAttributes
block|}
block|,
comment|// Sinhala
block|{
name|HB_IndicShape
block|,
name|HB_IndicAttributes
block|}
block|,
comment|// Thai
block|{
name|HB_ThaiShape
block|,
name|HB_ThaiAttributes
block|}
block|,
comment|// Lao
block|{
name|HB_BasicShape
block|,
literal|0
block|}
block|,
comment|// Tibetan
block|{
name|HB_TibetanShape
block|,
name|HB_TibetanAttributes
block|}
block|,
comment|// Myanmar
block|{
name|HB_MyanmarShape
block|,
name|HB_MyanmarAttributes
block|}
block|,
comment|// Georgian
block|{
name|HB_BasicShape
block|,
literal|0
block|}
block|,
comment|// Hangul
block|{
name|HB_HangulShape
block|,
literal|0
block|}
block|,
comment|// Ogham
block|{
name|HB_BasicShape
block|,
literal|0
block|}
block|,
comment|// Runic
block|{
name|HB_BasicShape
block|,
literal|0
block|}
block|,
comment|// Khmer
block|{
name|HB_KhmerShape
block|,
name|HB_KhmerAttributes
block|}
block|,
comment|// N'Ko
block|{
name|HB_ArabicShape
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|HB_GetTailoredCharAttributes
name|void
name|HB_GetTailoredCharAttributes
parameter_list|(
specifier|const
name|HB_UChar16
modifier|*
name|string
parameter_list|,
name|hb_uint32
name|stringLength
parameter_list|,
specifier|const
name|HB_ScriptItem
modifier|*
name|items
parameter_list|,
name|hb_uint32
name|numItems
parameter_list|,
name|HB_CharAttributes
modifier|*
name|attributes
parameter_list|)
block|{
if|if
condition|(
name|stringLength
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|hb_uint32
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numItems
condition|;
operator|++
name|i
control|)
block|{
name|HB_Script
name|script
init|=
name|items
index|[
name|i
index|]
operator|.
name|script
decl_stmt|;
if|if
condition|(
name|script
operator|==
name|HB_Script_Inherited
condition|)
name|script
operator|=
name|HB_Script_Common
expr_stmt|;
name|HB_AttributeFunction
name|attributeFunction
init|=
name|HB_ScriptEngines
index|[
name|script
index|]
operator|.
name|charAttributes
decl_stmt|;
if|if
condition|(
operator|!
name|attributeFunction
condition|)
continue|continue;
name|attributeFunction
argument_list|(
name|script
argument_list|,
name|string
argument_list|,
name|items
index|[
name|i
index|]
operator|.
name|pos
argument_list|,
name|items
index|[
name|i
index|]
operator|.
name|length
argument_list|,
name|attributes
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|tag_to_string
specifier|static
specifier|inline
name|char
modifier|*
name|tag_to_string
parameter_list|(
name|HB_UInt
name|tag
parameter_list|)
block|{
specifier|static
name|char
name|string
index|[
literal|5
index|]
decl_stmt|;
name|string
index|[
literal|0
index|]
operator|=
operator|(
name|tag
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
name|string
index|[
literal|1
index|]
operator|=
operator|(
name|tag
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|string
index|[
literal|2
index|]
operator|=
operator|(
name|tag
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|string
index|[
literal|3
index|]
operator|=
name|tag
operator|&
literal|0xff
expr_stmt|;
name|string
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|string
return|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|OT_DEBUG
end_ifdef
begin_function
DECL|function|dump_string
specifier|static
name|void
name|dump_string
parameter_list|(
name|HB_Buffer
name|buffer
parameter_list|)
block|{
for|for
control|(
name|uint
name|i
init|=
literal|0
init|;
name|i
operator|<
name|buffer
operator|->
name|in_length
condition|;
operator|++
name|i
control|)
block|{
name|qDebug
argument_list|(
literal|"    %x: cluster=%d"
argument_list|,
name|buffer
operator|->
name|in_string
index|[
name|i
index|]
operator|.
name|gindex
argument_list|,
name|buffer
operator|->
name|in_string
index|[
name|i
index|]
operator|.
name|cluster
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_define
DECL|macro|DEBUG
define|#
directive|define
name|DEBUG
value|printf
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|DEBUG
define|#
directive|define
name|DEBUG
value|if (1) ; else printf
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|DefaultLangSys
define|#
directive|define
name|DefaultLangSys
value|0xffff
end_define
begin_define
DECL|macro|DefaultScript
define|#
directive|define
name|DefaultScript
value|HB_MAKE_TAG('D', 'F', 'L', 'T')
end_define
begin_enum
enum|enum
block|{
DECL|enumerator|RequiresGsub
name|RequiresGsub
init|=
literal|1
block|,
DECL|enumerator|RequiresGpos
name|RequiresGpos
init|=
literal|2
block|}
enum|;
end_enum
begin_struct
DECL|struct|OTScripts
struct|struct
name|OTScripts
block|{
DECL|member|tag
name|unsigned
name|int
name|tag
decl_stmt|;
DECL|member|flags
name|int
name|flags
decl_stmt|;
block|}
struct|;
end_struct
begin_decl_stmt
DECL|variable|ot_scripts
specifier|static
specifier|const
name|OTScripts
name|ot_scripts
index|[]
init|=
block|{
comment|// Common
block|{
name|HB_MAKE_TAG
argument_list|(
literal|'l'
argument_list|,
literal|'a'
argument_list|,
literal|'t'
argument_list|,
literal|'n'
argument_list|)
block|,
literal|0
block|}
block|,
comment|// Greek
block|{
name|HB_MAKE_TAG
argument_list|(
literal|'g'
argument_list|,
literal|'r'
argument_list|,
literal|'e'
argument_list|,
literal|'k'
argument_list|)
block|,
literal|0
block|}
block|,
comment|// Cyrillic
block|{
name|HB_MAKE_TAG
argument_list|(
literal|'c'
argument_list|,
literal|'y'
argument_list|,
literal|'r'
argument_list|,
literal|'l'
argument_list|)
block|,
literal|0
block|}
block|,
comment|// Armenian
block|{
name|HB_MAKE_TAG
argument_list|(
literal|'a'
argument_list|,
literal|'r'
argument_list|,
literal|'m'
argument_list|,
literal|'n'
argument_list|)
block|,
literal|0
block|}
block|,
comment|// Hebrew
block|{
name|HB_MAKE_TAG
argument_list|(
literal|'h'
argument_list|,
literal|'e'
argument_list|,
literal|'b'
argument_list|,
literal|'r'
argument_list|)
block|,
literal|1
block|}
block|,
comment|// Arabic
block|{
name|HB_MAKE_TAG
argument_list|(
literal|'a'
argument_list|,
literal|'r'
argument_list|,
literal|'a'
argument_list|,
literal|'b'
argument_list|)
block|,
literal|1
block|}
block|,
comment|// Syriac
block|{
name|HB_MAKE_TAG
argument_list|(
literal|'s'
argument_list|,
literal|'y'
argument_list|,
literal|'r'
argument_list|,
literal|'c'
argument_list|)
block|,
literal|1
block|}
block|,
comment|// Thaana
block|{
name|HB_MAKE_TAG
argument_list|(
literal|'t'
argument_list|,
literal|'h'
argument_list|,
literal|'a'
argument_list|,
literal|'a'
argument_list|)
block|,
literal|1
block|}
block|,
comment|// Devanagari
block|{
name|HB_MAKE_TAG
argument_list|(
literal|'d'
argument_list|,
literal|'e'
argument_list|,
literal|'v'
argument_list|,
literal|'a'
argument_list|)
block|,
literal|1
block|}
block|,
comment|// Bengali
block|{
name|HB_MAKE_TAG
argument_list|(
literal|'b'
argument_list|,
literal|'e'
argument_list|,
literal|'n'
argument_list|,
literal|'g'
argument_list|)
block|,
literal|1
block|}
block|,
comment|// Gurmukhi
block|{
name|HB_MAKE_TAG
argument_list|(
literal|'g'
argument_list|,
literal|'u'
argument_list|,
literal|'r'
argument_list|,
literal|'u'
argument_list|)
block|,
literal|1
block|}
block|,
comment|// Gujarati
block|{
name|HB_MAKE_TAG
argument_list|(
literal|'g'
argument_list|,
literal|'u'
argument_list|,
literal|'j'
argument_list|,
literal|'r'
argument_list|)
block|,
literal|1
block|}
block|,
comment|// Oriya
block|{
name|HB_MAKE_TAG
argument_list|(
literal|'o'
argument_list|,
literal|'r'
argument_list|,
literal|'y'
argument_list|,
literal|'a'
argument_list|)
block|,
literal|1
block|}
block|,
comment|// Tamil
block|{
name|HB_MAKE_TAG
argument_list|(
literal|'t'
argument_list|,
literal|'a'
argument_list|,
literal|'m'
argument_list|,
literal|'l'
argument_list|)
block|,
literal|1
block|}
block|,
comment|// Telugu
block|{
name|HB_MAKE_TAG
argument_list|(
literal|'t'
argument_list|,
literal|'e'
argument_list|,
literal|'l'
argument_list|,
literal|'u'
argument_list|)
block|,
literal|1
block|}
block|,
comment|// Kannada
block|{
name|HB_MAKE_TAG
argument_list|(
literal|'k'
argument_list|,
literal|'n'
argument_list|,
literal|'d'
argument_list|,
literal|'a'
argument_list|)
block|,
literal|1
block|}
block|,
comment|// Malayalam
block|{
name|HB_MAKE_TAG
argument_list|(
literal|'m'
argument_list|,
literal|'l'
argument_list|,
literal|'y'
argument_list|,
literal|'m'
argument_list|)
block|,
literal|1
block|}
block|,
comment|// Sinhala
block|{
name|HB_MAKE_TAG
argument_list|(
literal|'s'
argument_list|,
literal|'i'
argument_list|,
literal|'n'
argument_list|,
literal|'h'
argument_list|)
block|,
literal|1
block|}
block|,
comment|// Thai
block|{
name|HB_MAKE_TAG
argument_list|(
literal|'t'
argument_list|,
literal|'h'
argument_list|,
literal|'a'
argument_list|,
literal|'i'
argument_list|)
block|,
literal|1
block|}
block|,
comment|// Lao
block|{
name|HB_MAKE_TAG
argument_list|(
literal|'l'
argument_list|,
literal|'a'
argument_list|,
literal|'o'
argument_list|,
literal|' '
argument_list|)
block|,
literal|1
block|}
block|,
comment|// Tibetan
block|{
name|HB_MAKE_TAG
argument_list|(
literal|'t'
argument_list|,
literal|'i'
argument_list|,
literal|'b'
argument_list|,
literal|'t'
argument_list|)
block|,
literal|1
block|}
block|,
comment|// Myanmar
block|{
name|HB_MAKE_TAG
argument_list|(
literal|'m'
argument_list|,
literal|'y'
argument_list|,
literal|'m'
argument_list|,
literal|'r'
argument_list|)
block|,
literal|1
block|}
block|,
comment|// Georgian
block|{
name|HB_MAKE_TAG
argument_list|(
literal|'g'
argument_list|,
literal|'e'
argument_list|,
literal|'o'
argument_list|,
literal|'r'
argument_list|)
block|,
literal|0
block|}
block|,
comment|// Hangul
block|{
name|HB_MAKE_TAG
argument_list|(
literal|'h'
argument_list|,
literal|'a'
argument_list|,
literal|'n'
argument_list|,
literal|'g'
argument_list|)
block|,
literal|1
block|}
block|,
comment|// Ogham
block|{
name|HB_MAKE_TAG
argument_list|(
literal|'o'
argument_list|,
literal|'g'
argument_list|,
literal|'a'
argument_list|,
literal|'m'
argument_list|)
block|,
literal|0
block|}
block|,
comment|// Runic
block|{
name|HB_MAKE_TAG
argument_list|(
literal|'r'
argument_list|,
literal|'u'
argument_list|,
literal|'n'
argument_list|,
literal|'r'
argument_list|)
block|,
literal|0
block|}
block|,
comment|// Khmer
block|{
name|HB_MAKE_TAG
argument_list|(
literal|'k'
argument_list|,
literal|'h'
argument_list|,
literal|'m'
argument_list|,
literal|'r'
argument_list|)
block|,
literal|1
block|}
block|,
comment|// N'Ko
block|{
name|HB_MAKE_TAG
argument_list|(
literal|'n'
argument_list|,
literal|'k'
argument_list|,
literal|'o'
argument_list|,
literal|' '
argument_list|)
block|,
literal|1
block|}
block|}
decl_stmt|;
end_decl_stmt
begin_enum
DECL|enumerator|NumOTScripts
enum|enum
block|{
name|NumOTScripts
init|=
sizeof|sizeof
argument_list|(
name|ot_scripts
argument_list|)
operator|/
expr|sizeof
operator|(
name|OTScripts
operator|)
block|}
enum|;
end_enum
begin_function
DECL|function|checkScript
specifier|static
name|HB_Bool
name|checkScript
parameter_list|(
name|HB_Face
name|face
parameter_list|,
name|int
name|script
parameter_list|)
block|{
name|assert
argument_list|(
name|script
operator|<
name|HB_ScriptCount
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|face
operator|->
name|gsub
operator|&&
operator|!
name|face
operator|->
name|gpos
condition|)
return|return
literal|false
return|;
name|unsigned
name|int
name|tag
init|=
name|ot_scripts
index|[
name|script
index|]
operator|.
name|tag
decl_stmt|;
name|int
name|requirements
init|=
name|ot_scripts
index|[
name|script
index|]
operator|.
name|flags
decl_stmt|;
if|if
condition|(
name|requirements
operator|&
name|RequiresGsub
condition|)
block|{
if|if
condition|(
operator|!
name|face
operator|->
name|gsub
condition|)
return|return
literal|false
return|;
name|HB_UShort
name|script_index
decl_stmt|;
name|HB_Error
name|error
init|=
name|HB_GSUB_Select_Script
argument_list|(
name|face
operator|->
name|gsub
argument_list|,
name|tag
argument_list|,
operator|&
name|script_index
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|DEBUG
argument_list|(
literal|"could not select script %d in GSub table: %d"
argument_list|,
operator|(
name|int
operator|)
name|script
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|error
operator|=
name|HB_GSUB_Select_Script
argument_list|(
name|face
operator|->
name|gsub
argument_list|,
name|HB_MAKE_TAG
argument_list|(
literal|'D'
argument_list|,
literal|'F'
argument_list|,
literal|'L'
argument_list|,
literal|'T'
argument_list|)
argument_list|,
operator|&
name|script_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
literal|false
return|;
block|}
block|}
if|if
condition|(
name|requirements
operator|&
name|RequiresGpos
condition|)
block|{
if|if
condition|(
operator|!
name|face
operator|->
name|gpos
condition|)
return|return
literal|false
return|;
name|HB_UShort
name|script_index
decl_stmt|;
name|HB_Error
name|error
init|=
name|HB_GPOS_Select_Script
argument_list|(
name|face
operator|->
name|gpos
argument_list|,
name|script
argument_list|,
operator|&
name|script_index
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|DEBUG
argument_list|(
literal|"could not select script in gpos table: %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|error
operator|=
name|HB_GPOS_Select_Script
argument_list|(
name|face
operator|->
name|gpos
argument_list|,
name|HB_MAKE_TAG
argument_list|(
literal|'D'
argument_list|,
literal|'F'
argument_list|,
literal|'L'
argument_list|,
literal|'T'
argument_list|)
argument_list|,
operator|&
name|script_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|getTableStream
specifier|static
name|HB_Stream
name|getTableStream
parameter_list|(
name|void
modifier|*
name|font
parameter_list|,
name|HB_GetFontTableFunc
name|tableFunc
parameter_list|,
name|HB_Tag
name|tag
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_UInt
name|length
init|=
literal|0
decl_stmt|;
name|HB_Stream
name|stream
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|font
condition|)
return|return
literal|0
return|;
name|error
operator|=
name|tableFunc
argument_list|(
name|font
argument_list|,
name|tag
argument_list|,
literal|0
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
literal|0
return|;
name|stream
operator|=
operator|(
name|HB_Stream
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|HB_StreamRec
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stream
condition|)
return|return
literal|0
return|;
name|stream
operator|->
name|base
operator|=
operator|(
name|HB_Byte
operator|*
operator|)
name|malloc
argument_list|(
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stream
operator|->
name|base
condition|)
block|{
name|free
argument_list|(
name|stream
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|error
operator|=
name|tableFunc
argument_list|(
name|font
argument_list|,
name|tag
argument_list|,
name|stream
operator|->
name|base
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|_hb_close_stream
argument_list|(
name|stream
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|stream
operator|->
name|size
operator|=
name|length
expr_stmt|;
name|stream
operator|->
name|pos
operator|=
literal|0
expr_stmt|;
name|stream
operator|->
name|cursor
operator|=
name|NULL
expr_stmt|;
return|return
name|stream
return|;
block|}
end_function
begin_function
DECL|function|HB_AllocFace
name|HB_Face
name|HB_AllocFace
parameter_list|(
name|void
modifier|*
name|font
parameter_list|,
name|HB_GetFontTableFunc
name|tableFunc
parameter_list|)
block|{
name|HB_Face
name|face
init|=
operator|(
name|HB_Face
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|HB_FaceRec
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|face
condition|)
return|return
literal|0
return|;
name|face
operator|->
name|isSymbolFont
operator|=
literal|false
expr_stmt|;
name|face
operator|->
name|gdef
operator|=
literal|0
expr_stmt|;
name|face
operator|->
name|gpos
operator|=
literal|0
expr_stmt|;
name|face
operator|->
name|gsub
operator|=
literal|0
expr_stmt|;
name|face
operator|->
name|current_script
operator|=
name|HB_ScriptCount
expr_stmt|;
name|face
operator|->
name|current_flags
operator|=
name|HB_ShaperFlag_Default
expr_stmt|;
name|face
operator|->
name|has_opentype_kerning
operator|=
literal|false
expr_stmt|;
name|face
operator|->
name|tmpAttributes
operator|=
literal|0
expr_stmt|;
name|face
operator|->
name|tmpLogClusters
operator|=
literal|0
expr_stmt|;
name|face
operator|->
name|glyphs_substituted
operator|=
literal|false
expr_stmt|;
name|face
operator|->
name|buffer
operator|=
literal|0
expr_stmt|;
name|face
operator|->
name|font_for_init
operator|=
name|font
expr_stmt|;
name|face
operator|->
name|get_font_table_func
operator|=
name|tableFunc
expr_stmt|;
return|return
name|face
return|;
block|}
end_function
begin_function
DECL|function|HB_NewFace
name|HB_Face
name|HB_NewFace
parameter_list|(
name|void
modifier|*
name|font
parameter_list|,
name|HB_GetFontTableFunc
name|tableFunc
parameter_list|)
block|{
name|HB_Face
name|face
init|=
name|HB_AllocFace
argument_list|(
name|font
argument_list|,
name|tableFunc
argument_list|)
decl_stmt|;
if|if
condition|(
name|face
condition|)
name|face
operator|=
name|HB_LoadFace
argument_list|(
name|face
argument_list|)
expr_stmt|;
return|return
name|face
return|;
block|}
end_function
begin_function
DECL|function|HB_LoadFace
name|HB_Face
name|HB_LoadFace
parameter_list|(
name|HB_Face
name|face
parameter_list|)
block|{
name|void
modifier|*
name|font
init|=
name|face
operator|->
name|font_for_init
decl_stmt|;
if|if
condition|(
operator|!
name|font
condition|)
return|return
name|face
return|;
name|HB_GetFontTableFunc
name|tableFunc
init|=
name|face
operator|->
name|get_font_table_func
decl_stmt|;
name|face
operator|->
name|get_font_table_func
operator|=
literal|0
expr_stmt|;
name|face
operator|->
name|font_for_init
operator|=
literal|0
expr_stmt|;
name|HB_Error
name|error
init|=
name|HB_Err_Ok
decl_stmt|;
name|HB_Stream
name|stream
decl_stmt|;
name|HB_Stream
name|gdefStream
decl_stmt|;
name|gdefStream
operator|=
name|getTableStream
argument_list|(
name|font
argument_list|,
name|tableFunc
argument_list|,
name|TTAG_GDEF
argument_list|)
expr_stmt|;
name|error
operator|=
name|HB_Err_Not_Covered
expr_stmt|;
if|if
condition|(
operator|!
name|gdefStream
operator|||
operator|(
name|error
operator|=
name|HB_Load_GDEF_Table
argument_list|(
name|gdefStream
argument_list|,
operator|&
name|face
operator|->
name|gdef
argument_list|)
operator|)
condition|)
block|{
comment|//DEBUG("error loading gdef table: %d", error);
name|face
operator|->
name|gdef
operator|=
literal|0
expr_stmt|;
block|}
comment|//DEBUG()<< "trying to load gsub table";
name|stream
operator|=
name|getTableStream
argument_list|(
name|font
argument_list|,
name|tableFunc
argument_list|,
name|TTAG_GSUB
argument_list|)
expr_stmt|;
name|error
operator|=
name|HB_Err_Not_Covered
expr_stmt|;
if|if
condition|(
operator|!
name|stream
operator|||
operator|(
name|error
operator|=
name|HB_Load_GSUB_Table
argument_list|(
name|stream
argument_list|,
operator|&
name|face
operator|->
name|gsub
argument_list|,
name|face
operator|->
name|gdef
argument_list|,
name|gdefStream
argument_list|)
operator|)
condition|)
block|{
name|face
operator|->
name|gsub
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|HB_Err_Not_Covered
condition|)
block|{
comment|//DEBUG("error loading gsub table: %d", error);
block|}
else|else
block|{
comment|//DEBUG("face doesn't have a gsub table");
block|}
block|}
name|_hb_close_stream
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|stream
operator|=
name|getTableStream
argument_list|(
name|font
argument_list|,
name|tableFunc
argument_list|,
name|TTAG_GPOS
argument_list|)
expr_stmt|;
name|error
operator|=
name|HB_Err_Not_Covered
expr_stmt|;
if|if
condition|(
operator|!
name|stream
operator|||
operator|(
name|error
operator|=
name|HB_Load_GPOS_Table
argument_list|(
name|stream
argument_list|,
operator|&
name|face
operator|->
name|gpos
argument_list|,
name|face
operator|->
name|gdef
argument_list|,
name|gdefStream
argument_list|)
operator|)
condition|)
block|{
name|face
operator|->
name|gpos
operator|=
literal|0
expr_stmt|;
name|DEBUG
argument_list|(
literal|"error loading gpos table: %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
name|_hb_close_stream
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|_hb_close_stream
argument_list|(
name|gdefStream
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|HB_ScriptCount
condition|;
operator|++
name|i
control|)
name|face
operator|->
name|supported_scripts
index|[
name|i
index|]
operator|=
name|checkScript
argument_list|(
name|face
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|hb_buffer_new
argument_list|(
operator|&
name|face
operator|->
name|buffer
argument_list|)
operator|!=
name|HB_Err_Ok
condition|)
block|{
name|HB_FreeFace
argument_list|(
name|face
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|face
return|;
block|}
end_function
begin_function
DECL|function|HB_FreeFace
name|void
name|HB_FreeFace
parameter_list|(
name|HB_Face
name|face
parameter_list|)
block|{
if|if
condition|(
operator|!
name|face
condition|)
return|return;
if|if
condition|(
name|face
operator|->
name|gpos
condition|)
name|HB_Done_GPOS_Table
argument_list|(
name|face
operator|->
name|gpos
argument_list|)
expr_stmt|;
if|if
condition|(
name|face
operator|->
name|gsub
condition|)
name|HB_Done_GSUB_Table
argument_list|(
name|face
operator|->
name|gsub
argument_list|)
expr_stmt|;
if|if
condition|(
name|face
operator|->
name|gdef
condition|)
name|HB_Done_GDEF_Table
argument_list|(
name|face
operator|->
name|gdef
argument_list|)
expr_stmt|;
if|if
condition|(
name|face
operator|->
name|buffer
condition|)
name|hb_buffer_free
argument_list|(
name|face
operator|->
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|face
operator|->
name|tmpAttributes
condition|)
name|free
argument_list|(
name|face
operator|->
name|tmpAttributes
argument_list|)
expr_stmt|;
if|if
condition|(
name|face
operator|->
name|tmpLogClusters
condition|)
name|free
argument_list|(
name|face
operator|->
name|tmpLogClusters
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|face
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|NO_OPENTYPE
end_ifndef
begin_function
DECL|function|HB_SelectScript
name|HB_Bool
name|HB_SelectScript
parameter_list|(
name|HB_ShaperItem
modifier|*
name|shaper_item
parameter_list|,
specifier|const
name|HB_OpenTypeFeature
modifier|*
name|features
parameter_list|)
block|{
name|HB_Script
name|script
init|=
name|shaper_item
operator|->
name|item
operator|.
name|script
decl_stmt|;
name|HB_Face
name|face
init|=
name|shaper_item
operator|->
name|face
decl_stmt|;
if|if
condition|(
name|face
operator|->
name|current_script
operator|==
name|script
operator|&&
name|face
operator|->
name|current_flags
operator|==
name|shaper_item
operator|->
name|shaperFlags
condition|)
return|return
name|shaper_item
operator|->
name|face
operator|->
name|supported_scripts
index|[
name|script
index|]
condition|?
literal|true
else|:
literal|false
return|;
name|face
operator|->
name|current_script
operator|=
name|script
expr_stmt|;
name|face
operator|->
name|current_flags
operator|=
name|shaper_item
operator|->
name|shaperFlags
expr_stmt|;
if|if
condition|(
operator|!
name|shaper_item
operator|->
name|face
operator|->
name|supported_scripts
index|[
name|script
index|]
condition|)
return|return
literal|false
return|;
name|assert
argument_list|(
name|script
operator|<
name|HB_ScriptCount
argument_list|)
expr_stmt|;
comment|// find script in our list of supported scripts.
name|unsigned
name|int
name|tag
init|=
name|ot_scripts
index|[
name|script
index|]
operator|.
name|tag
decl_stmt|;
if|if
condition|(
name|face
operator|->
name|gsub
operator|&&
name|features
condition|)
block|{
ifdef|#
directive|ifdef
name|OT_DEBUG
block|{
name|HB_FeatureList
name|featurelist
init|=
name|face
operator|->
name|gsub
operator|->
name|FeatureList
decl_stmt|;
name|int
name|numfeatures
init|=
name|featurelist
operator|.
name|FeatureCount
decl_stmt|;
name|DEBUG
argument_list|(
literal|"gsub table has %d features"
argument_list|,
name|numfeatures
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numfeatures
condition|;
name|i
operator|++
control|)
block|{
name|HB_FeatureRecord
modifier|*
name|r
init|=
name|featurelist
operator|.
name|FeatureRecord
operator|+
name|i
decl_stmt|;
name|DEBUG
argument_list|(
literal|"   feature '%s'"
argument_list|,
name|tag_to_string
argument_list|(
name|r
operator|->
name|FeatureTag
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|HB_GSUB_Clear_Features
argument_list|(
name|face
operator|->
name|gsub
argument_list|)
expr_stmt|;
name|HB_UShort
name|script_index
decl_stmt|;
name|HB_Error
name|error
init|=
name|HB_GSUB_Select_Script
argument_list|(
name|face
operator|->
name|gsub
argument_list|,
name|tag
argument_list|,
operator|&
name|script_index
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|DEBUG
argument_list|(
literal|"script %s has script index %d"
argument_list|,
name|tag_to_string
argument_list|(
name|script
argument_list|)
argument_list|,
name|script_index
argument_list|)
expr_stmt|;
while|while
condition|(
name|features
operator|->
name|tag
condition|)
block|{
name|HB_UShort
name|feature_index
decl_stmt|;
name|error
operator|=
name|HB_GSUB_Select_Feature
argument_list|(
name|face
operator|->
name|gsub
argument_list|,
name|features
operator|->
name|tag
argument_list|,
name|script_index
argument_list|,
literal|0xffff
argument_list|,
operator|&
name|feature_index
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|DEBUG
argument_list|(
literal|"  adding feature %s"
argument_list|,
name|tag_to_string
argument_list|(
name|features
operator|->
name|tag
argument_list|)
argument_list|)
expr_stmt|;
name|HB_GSUB_Add_Feature
argument_list|(
name|face
operator|->
name|gsub
argument_list|,
name|feature_index
argument_list|,
name|features
operator|->
name|property
argument_list|)
expr_stmt|;
block|}
operator|++
name|features
expr_stmt|;
block|}
block|}
block|}
comment|// reset
name|face
operator|->
name|has_opentype_kerning
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|face
operator|->
name|gpos
condition|)
block|{
name|HB_GPOS_Clear_Features
argument_list|(
name|face
operator|->
name|gpos
argument_list|)
expr_stmt|;
name|HB_UShort
name|script_index
decl_stmt|;
name|HB_Error
name|error
init|=
name|HB_GPOS_Select_Script
argument_list|(
name|face
operator|->
name|gpos
argument_list|,
name|tag
argument_list|,
operator|&
name|script_index
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
ifdef|#
directive|ifdef
name|OT_DEBUG
block|{
name|HB_FeatureList
name|featurelist
init|=
name|face
operator|->
name|gpos
operator|->
name|FeatureList
decl_stmt|;
name|int
name|numfeatures
init|=
name|featurelist
operator|.
name|FeatureCount
decl_stmt|;
name|DEBUG
argument_list|(
literal|"gpos table has %d features"
argument_list|,
name|numfeatures
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numfeatures
condition|;
name|i
operator|++
control|)
block|{
name|HB_FeatureRecord
modifier|*
name|r
init|=
name|featurelist
operator|.
name|FeatureRecord
operator|+
name|i
decl_stmt|;
name|HB_UShort
name|feature_index
decl_stmt|;
name|HB_GPOS_Select_Feature
argument_list|(
name|face
operator|->
name|gpos
argument_list|,
name|r
operator|->
name|FeatureTag
argument_list|,
name|script_index
argument_list|,
literal|0xffff
argument_list|,
operator|&
name|feature_index
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|"   feature '%s'"
argument_list|,
name|tag_to_string
argument_list|(
name|r
operator|->
name|FeatureTag
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|HB_UInt
modifier|*
name|feature_tag_list_buffer
decl_stmt|;
name|error
operator|=
name|HB_GPOS_Query_Features
argument_list|(
name|face
operator|->
name|gpos
argument_list|,
name|script_index
argument_list|,
literal|0xffff
argument_list|,
operator|&
name|feature_tag_list_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|HB_UInt
modifier|*
name|feature_tag_list
init|=
name|feature_tag_list_buffer
decl_stmt|;
while|while
condition|(
operator|*
name|feature_tag_list
condition|)
block|{
name|HB_UShort
name|feature_index
decl_stmt|;
name|bool
name|skip
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|*
name|feature_tag_list
operator|==
name|HB_MAKE_TAG
argument_list|(
literal|'k'
argument_list|,
literal|'e'
argument_list|,
literal|'r'
argument_list|,
literal|'n'
argument_list|)
condition|)
block|{
if|if
condition|(
name|face
operator|->
name|current_flags
operator|&
name|HB_ShaperFlag_NoKerning
condition|)
name|skip
operator|=
literal|true
expr_stmt|;
else|else
name|face
operator|->
name|has_opentype_kerning
operator|=
literal|true
expr_stmt|;
block|}
name|features
operator|=
name|disabled_features
expr_stmt|;
while|while
condition|(
name|features
operator|->
name|tag
condition|)
block|{
if|if
condition|(
operator|*
name|feature_tag_list
operator|==
name|features
operator|->
name|tag
condition|)
block|{
name|skip
operator|=
literal|true
expr_stmt|;
break|break;
block|}
operator|++
name|features
expr_stmt|;
block|}
comment|// 'palt' should be turned off by default unless 'kern' is on
if|if
condition|(
operator|!
name|face
operator|->
name|has_opentype_kerning
operator|&&
operator|*
name|feature_tag_list
operator|==
name|HB_MAKE_TAG
argument_list|(
literal|'p'
argument_list|,
literal|'a'
argument_list|,
literal|'l'
argument_list|,
literal|'t'
argument_list|)
condition|)
name|skip
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|skip
condition|)
block|{
operator|++
name|feature_tag_list
expr_stmt|;
continue|continue;
block|}
name|error
operator|=
name|HB_GPOS_Select_Feature
argument_list|(
name|face
operator|->
name|gpos
argument_list|,
operator|*
name|feature_tag_list
argument_list|,
name|script_index
argument_list|,
literal|0xffff
argument_list|,
operator|&
name|feature_index
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|HB_GPOS_Add_Feature
argument_list|(
name|face
operator|->
name|gpos
argument_list|,
name|feature_index
argument_list|,
name|PositioningProperties
argument_list|)
expr_stmt|;
operator|++
name|feature_tag_list
expr_stmt|;
block|}
name|FREE
argument_list|(
name|feature_tag_list_buffer
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|containsSurrogates
specifier|static
name|HB_Bool
name|containsSurrogates
parameter_list|(
name|HB_ShaperItem
modifier|*
name|item
parameter_list|)
block|{
for|for
control|(
name|hb_uint32
name|i
init|=
name|item
operator|->
name|item
operator|.
name|pos
init|;
name|i
operator|<
name|item
operator|->
name|item
operator|.
name|pos
operator|+
name|item
operator|->
name|item
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|HB_UChar16
name|ucs
init|=
name|item
operator|->
name|string
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|HB_IsHighSurrogate
argument_list|(
name|ucs
argument_list|)
operator|||
name|HB_IsLowSurrogate
argument_list|(
name|ucs
argument_list|)
condition|)
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|HB_OpenTypeShape
name|HB_Bool
name|HB_OpenTypeShape
parameter_list|(
name|HB_ShaperItem
modifier|*
name|item
parameter_list|,
specifier|const
name|hb_uint32
modifier|*
name|properties
parameter_list|)
block|{
name|HB_GlyphAttributes
modifier|*
name|tmpAttributes
decl_stmt|;
name|unsigned
name|int
modifier|*
name|tmpLogClusters
decl_stmt|;
name|HB_Face
name|face
init|=
name|item
operator|->
name|face
decl_stmt|;
name|face
operator|->
name|length
operator|=
name|item
operator|->
name|num_glyphs
expr_stmt|;
name|hb_buffer_clear
argument_list|(
name|face
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|tmpAttributes
operator|=
operator|(
name|HB_GlyphAttributes
operator|*
operator|)
name|realloc
argument_list|(
name|face
operator|->
name|tmpAttributes
argument_list|,
name|face
operator|->
name|length
operator|*
sizeof|sizeof
argument_list|(
name|HB_GlyphAttributes
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tmpAttributes
condition|)
return|return
literal|false
return|;
name|face
operator|->
name|tmpAttributes
operator|=
name|tmpAttributes
expr_stmt|;
name|tmpLogClusters
operator|=
operator|(
name|unsigned
name|int
operator|*
operator|)
name|realloc
argument_list|(
name|face
operator|->
name|tmpLogClusters
argument_list|,
name|face
operator|->
name|length
operator|*
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tmpLogClusters
condition|)
return|return
literal|false
return|;
name|face
operator|->
name|tmpLogClusters
operator|=
name|tmpLogClusters
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|face
operator|->
name|length
condition|;
operator|++
name|i
control|)
block|{
name|hb_buffer_add_glyph
argument_list|(
name|face
operator|->
name|buffer
argument_list|,
name|item
operator|->
name|glyphs
index|[
name|i
index|]
argument_list|,
name|properties
condition|?
name|properties
index|[
name|i
index|]
else|:
literal|0
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|face
operator|->
name|tmpAttributes
index|[
name|i
index|]
operator|=
name|item
operator|->
name|attributes
index|[
name|i
index|]
expr_stmt|;
name|face
operator|->
name|tmpLogClusters
index|[
name|i
index|]
operator|=
name|item
operator|->
name|log_clusters
index|[
name|i
index|]
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|OT_DEBUG
name|DEBUG
argument_list|(
literal|"-----------------------------------------"
argument_list|)
expr_stmt|;
comment|//     DEBUG("log clusters before shaping:");
comment|//     for (int j = 0; j< length; j++)
comment|//         DEBUG("    log[%d] = %d", j, item->log_clusters[j]);
name|DEBUG
argument_list|(
literal|"original glyphs: %p"
argument_list|,
name|item
operator|->
name|glyphs
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
operator|++
name|i
control|)
name|DEBUG
argument_list|(
literal|"   glyph=%4x"
argument_list|,
name|hb_buffer
operator|->
name|in_string
index|[
name|i
index|]
operator|.
name|gindex
argument_list|)
expr_stmt|;
comment|//     dump_string(hb_buffer);
endif|#
directive|endif
name|face
operator|->
name|glyphs_substituted
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|face
operator|->
name|gsub
operator|&&
operator|!
name|containsSurrogates
argument_list|(
name|item
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|error
init|=
name|HB_GSUB_Apply_String
argument_list|(
name|face
operator|->
name|gsub
argument_list|,
name|face
operator|->
name|buffer
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|HB_Err_Not_Covered
condition|)
return|return
literal|false
return|;
name|face
operator|->
name|glyphs_substituted
operator|=
operator|(
name|error
operator|!=
name|HB_Err_Not_Covered
operator|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|OT_DEBUG
comment|//     DEBUG("log clusters before shaping:");
comment|//     for (int j = 0; j< length; j++)
comment|//         DEBUG("    log[%d] = %d", j, item->log_clusters[j]);
name|DEBUG
argument_list|(
literal|"shaped glyphs:"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
operator|++
name|i
control|)
name|DEBUG
argument_list|(
literal|"   glyph=%4x"
argument_list|,
name|hb_buffer
operator|->
name|in_string
index|[
name|i
index|]
operator|.
name|gindex
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|"-----------------------------------------"
argument_list|)
expr_stmt|;
comment|//     dump_string(hb_buffer);
endif|#
directive|endif
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|HB_OpenTypePosition
name|HB_Bool
name|HB_OpenTypePosition
parameter_list|(
name|HB_ShaperItem
modifier|*
name|item
parameter_list|,
name|int
name|availableGlyphs
parameter_list|,
name|HB_Bool
name|doLogClusters
parameter_list|)
block|{
name|HB_Face
name|face
init|=
name|item
operator|->
name|face
decl_stmt|;
name|bool
name|glyphs_positioned
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|face
operator|->
name|gpos
condition|)
block|{
if|if
condition|(
name|face
operator|->
name|buffer
operator|->
name|positions
condition|)
name|memset
argument_list|(
name|face
operator|->
name|buffer
operator|->
name|positions
argument_list|,
literal|0
argument_list|,
name|face
operator|->
name|buffer
operator|->
name|in_length
operator|*
sizeof|sizeof
argument_list|(
name|HB_PositionRec
argument_list|)
argument_list|)
expr_stmt|;
comment|// #### check that passing "false,false" is correct
name|glyphs_positioned
operator|=
name|HB_GPOS_Apply_String
argument_list|(
name|item
operator|->
name|font
argument_list|,
name|face
operator|->
name|gpos
argument_list|,
name|face
operator|->
name|current_flags
argument_list|,
name|face
operator|->
name|buffer
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
operator|!=
name|HB_Err_Not_Covered
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|face
operator|->
name|glyphs_substituted
operator|&&
operator|!
name|glyphs_positioned
condition|)
block|{
name|HB_HeuristicPosition
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
comment|// nothing to do for us
block|}
comment|// make sure we have enough space to write everything back
if|if
condition|(
name|availableGlyphs
operator|<
operator|(
name|int
operator|)
name|face
operator|->
name|buffer
operator|->
name|in_length
condition|)
block|{
name|item
operator|->
name|num_glyphs
operator|=
name|face
operator|->
name|buffer
operator|->
name|in_length
expr_stmt|;
return|return
literal|false
return|;
block|}
name|HB_Glyph
modifier|*
name|glyphs
init|=
name|item
operator|->
name|glyphs
decl_stmt|;
name|HB_GlyphAttributes
modifier|*
name|attributes
init|=
name|item
operator|->
name|attributes
decl_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|face
operator|->
name|buffer
operator|->
name|in_length
condition|;
operator|++
name|i
control|)
block|{
name|glyphs
index|[
name|i
index|]
operator|=
name|face
operator|->
name|buffer
operator|->
name|in_string
index|[
name|i
index|]
operator|.
name|gindex
expr_stmt|;
name|attributes
index|[
name|i
index|]
operator|=
name|face
operator|->
name|tmpAttributes
index|[
name|face
operator|->
name|buffer
operator|->
name|in_string
index|[
name|i
index|]
operator|.
name|cluster
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|&&
name|face
operator|->
name|buffer
operator|->
name|in_string
index|[
name|i
index|]
operator|.
name|cluster
operator|==
name|face
operator|->
name|buffer
operator|->
name|in_string
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|cluster
condition|)
name|attributes
index|[
name|i
index|]
operator|.
name|clusterStart
operator|=
literal|false
expr_stmt|;
block|}
name|item
operator|->
name|num_glyphs
operator|=
name|face
operator|->
name|buffer
operator|->
name|in_length
expr_stmt|;
if|if
condition|(
name|doLogClusters
operator|&&
name|face
operator|->
name|glyphs_substituted
condition|)
block|{
comment|// we can't do this for indic, as we pass the stuf in syllables and it's easier to do it in the shaper.
name|unsigned
name|short
modifier|*
name|logClusters
init|=
name|item
operator|->
name|log_clusters
decl_stmt|;
name|int
name|clusterStart
init|=
literal|0
decl_stmt|;
name|int
name|oldCi
init|=
literal|0
decl_stmt|;
comment|// #### the reconstruction of the logclusters currently does not work if the original string
comment|// contains surrogate pairs
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|face
operator|->
name|buffer
operator|->
name|in_length
condition|;
operator|++
name|i
control|)
block|{
name|int
name|ci
init|=
name|face
operator|->
name|buffer
operator|->
name|in_string
index|[
name|i
index|]
operator|.
name|cluster
decl_stmt|;
comment|//         DEBUG("   ci[%d] = %d mark=%d, cmb=%d, cs=%d",
comment|//                i, ci, glyphAttributes[i].mark, glyphAttributes[i].combiningClass, glyphAttributes[i].clusterStart);
if|if
condition|(
operator|!
name|attributes
index|[
name|i
index|]
operator|.
name|mark
operator|&&
name|attributes
index|[
name|i
index|]
operator|.
name|clusterStart
operator|&&
name|ci
operator|!=
name|oldCi
condition|)
block|{
for|for
control|(
name|int
name|j
init|=
name|oldCi
init|;
name|j
operator|<
name|ci
condition|;
name|j
operator|++
control|)
name|logClusters
index|[
name|j
index|]
operator|=
name|clusterStart
expr_stmt|;
name|clusterStart
operator|=
name|i
expr_stmt|;
name|oldCi
operator|=
name|ci
expr_stmt|;
block|}
block|}
for|for
control|(
name|int
name|j
init|=
name|oldCi
init|;
name|j
operator|<
name|face
operator|->
name|length
condition|;
name|j
operator|++
control|)
name|logClusters
index|[
name|j
index|]
operator|=
name|clusterStart
expr_stmt|;
block|}
comment|// calulate the advances for the shaped glyphs
comment|//     DEBUG("unpositioned: ");
comment|// positioning code:
if|if
condition|(
name|glyphs_positioned
condition|)
block|{
name|HB_GetGlyphAdvances
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|HB_Position
name|positions
init|=
name|face
operator|->
name|buffer
operator|->
name|positions
decl_stmt|;
name|HB_Fixed
modifier|*
name|advances
init|=
name|item
operator|->
name|advances
decl_stmt|;
comment|//         DEBUG("positioned glyphs:");
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|face
operator|->
name|buffer
operator|->
name|in_length
condition|;
name|i
operator|++
control|)
block|{
comment|//             DEBUG("    %d:\t orig advance: (%d/%d)\tadv=(%d/%d)\tpos=(%d/%d)\tback=%d\tnew_advance=%d", i,
comment|//                    glyphs[i].advance.x.toInt(), glyphs[i].advance.y.toInt(),
comment|//                    (int)(positions[i].x_advance>> 6), (int)(positions[i].y_advance>> 6),
comment|//                    (int)(positions[i].x_pos>> 6), (int)(positions[i].y_pos>> 6),
comment|//                    positions[i].back, positions[i].new_advance);
name|HB_Fixed
name|adjustment
init|=
name|positions
index|[
name|i
index|]
operator|.
name|x_advance
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|face
operator|->
name|current_flags
operator|&
name|HB_ShaperFlag_UseDesignMetrics
operator|)
condition|)
name|adjustment
operator|=
name|HB_FIXED_ROUND
argument_list|(
name|adjustment
argument_list|)
expr_stmt|;
if|if
condition|(
name|positions
index|[
name|i
index|]
operator|.
name|new_advance
condition|)
block|{
empty_stmt|;
comment|//advances[i] = adjustment;
block|}
else|else
block|{
name|advances
index|[
name|i
index|]
operator|+=
name|adjustment
expr_stmt|;
block|}
name|int
name|back
init|=
literal|0
decl_stmt|;
name|HB_FixedPoint
modifier|*
name|offsets
init|=
name|item
operator|->
name|offsets
decl_stmt|;
name|offsets
index|[
name|i
index|]
operator|.
name|x
operator|=
name|positions
index|[
name|i
index|]
operator|.
name|x_pos
expr_stmt|;
name|offsets
index|[
name|i
index|]
operator|.
name|y
operator|=
name|positions
index|[
name|i
index|]
operator|.
name|y_pos
expr_stmt|;
while|while
condition|(
name|positions
index|[
name|i
operator|-
name|back
index|]
operator|.
name|back
condition|)
block|{
name|back
operator|+=
name|positions
index|[
name|i
operator|-
name|back
index|]
operator|.
name|back
expr_stmt|;
name|offsets
index|[
name|i
index|]
operator|.
name|x
operator|+=
name|positions
index|[
name|i
operator|-
name|back
index|]
operator|.
name|x_pos
expr_stmt|;
name|offsets
index|[
name|i
index|]
operator|.
name|y
operator|+=
name|positions
index|[
name|i
operator|-
name|back
index|]
operator|.
name|y_pos
expr_stmt|;
block|}
name|offsets
index|[
name|i
index|]
operator|.
name|y
operator|=
operator|-
name|offsets
index|[
name|i
index|]
operator|.
name|y
expr_stmt|;
if|if
condition|(
name|item
operator|->
name|item
operator|.
name|bidiLevel
operator|%
literal|2
condition|)
block|{
comment|// ### may need to go back multiple glyphs like in ltr
name|back
operator|=
name|positions
index|[
name|i
index|]
operator|.
name|back
expr_stmt|;
while|while
condition|(
name|back
operator|--
condition|)
name|offsets
index|[
name|i
index|]
operator|.
name|x
operator|-=
name|advances
index|[
name|i
operator|-
name|back
index|]
expr_stmt|;
block|}
else|else
block|{
name|back
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|positions
index|[
name|i
operator|-
name|back
index|]
operator|.
name|back
condition|)
block|{
name|back
operator|+=
name|positions
index|[
name|i
operator|-
name|back
index|]
operator|.
name|back
expr_stmt|;
name|offsets
index|[
name|i
index|]
operator|.
name|x
operator|-=
name|advances
index|[
name|i
operator|-
name|back
index|]
expr_stmt|;
block|}
block|}
comment|//             DEBUG("   ->\tadv=%d\tpos=(%d/%d)",
comment|//                    glyphs[i].advance.x.toInt(), glyphs[i].offset.x.toInt(), glyphs[i].offset.y.toInt());
block|}
name|item
operator|->
name|kerning_applied
operator|=
name|face
operator|->
name|has_opentype_kerning
expr_stmt|;
block|}
else|else
block|{
name|HB_HeuristicPosition
argument_list|(
name|item
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|OT_DEBUG
if|if
condition|(
name|doLogClusters
condition|)
block|{
name|DEBUG
argument_list|(
literal|"log clusters after shaping:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|item
operator|->
name|item
operator|.
name|length
condition|;
name|j
operator|++
control|)
name|DEBUG
argument_list|(
literal|"    log[%d] = %d\n"
argument_list|,
name|j
argument_list|,
name|item
operator|->
name|log_clusters
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
name|DEBUG
argument_list|(
literal|"final glyphs:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|item
operator|->
name|num_glyphs
condition|;
operator|++
name|i
control|)
name|DEBUG
argument_list|(
literal|"   glyph=%4x char_index=%d mark: %d cmp: %d, clusterStart: %d advance=%d offset=%d/%d\n"
argument_list|,
name|glyphs
index|[
name|i
index|]
argument_list|,
name|face
operator|->
name|buffer
operator|->
name|in_string
index|[
name|i
index|]
operator|.
name|cluster
argument_list|,
name|attributes
index|[
name|i
index|]
operator|.
name|mark
argument_list|,
name|attributes
index|[
name|i
index|]
operator|.
name|combiningClass
argument_list|,
name|attributes
index|[
name|i
index|]
operator|.
name|clusterStart
argument_list|,
name|item
operator|->
name|advances
index|[
name|i
index|]
operator|>>
literal|6
argument_list|,
name|item
operator|->
name|offsets
index|[
name|i
index|]
operator|.
name|x
operator|>>
literal|6
argument_list|,
name|item
operator|->
name|offsets
index|[
name|i
index|]
operator|.
name|y
operator|>>
literal|6
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|"-----------------------------------------\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|true
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// NO_OPENTYPE
end_comment
begin_function
DECL|function|HB_ShapeItem
name|HB_Bool
name|HB_ShapeItem
parameter_list|(
name|HB_ShaperItem
modifier|*
name|shaper_item
parameter_list|)
block|{
name|HB_Bool
name|result
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|shaper_item
operator|->
name|num_glyphs
operator|<
name|shaper_item
operator|->
name|item
operator|.
name|length
condition|)
block|{
name|shaper_item
operator|->
name|num_glyphs
operator|=
name|shaper_item
operator|->
name|item
operator|.
name|length
expr_stmt|;
return|return
literal|false
return|;
block|}
name|assert
argument_list|(
name|shaper_item
operator|->
name|item
operator|.
name|script
operator|<
name|HB_ScriptCount
argument_list|)
expr_stmt|;
name|result
operator|=
name|HB_ScriptEngines
index|[
name|shaper_item
operator|->
name|item
operator|.
name|script
index|]
operator|.
name|shape
argument_list|(
name|shaper_item
argument_list|)
expr_stmt|;
name|shaper_item
operator|->
name|glyphIndicesPresent
operator|=
literal|false
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
end_unit
