begin_unit
begin_comment
comment|/*  * Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies)  *  * This is part of HarfBuzz, an OpenType Layout engine library.  *  * Permission is hereby granted, without written agreement and without  * license or royalty fees, to use, copy, modify, and distribute this  * software and its documentation for any purpose, provided that the  * above copyright notice and the following two paragraphs appear in  * all copies of this software.  *  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH  * DAMAGE.  *  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS  * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.  */
end_comment
begin_include
include|#
directive|include
file|"harfbuzz-shaper.h"
end_include
begin_include
include|#
directive|include
file|"harfbuzz-shaper-private.h"
end_include
begin_include
include|#
directive|include
file|<assert.h>
end_include
begin_include
include|#
directive|include
file|<stdio.h>
end_include
begin_comment
comment|/* //  Vocabulary //      Base ->         A consonant or an independent vowel in its full (not subscript) form. It is the //                      center of the syllable, it can be surrounded by coeng (subscript) consonants, vowels, //                      split vowels, signs... but there is only one base in a syllable, it has to be coded as //                      the first character of the syllable. //      split vowel --> vowel that has two parts placed separately (e.g. Before and after the consonant). //                      Khmer language has five of them. Khmer split vowels either have one part before the //                      base and one after the base or they have a part before the base and a part above the base. //                      The first part of all Khmer split vowels is the same character, identical to //                      the glyph of Khmer dependent vowel SRA EI //      coeng -->  modifier used in Khmer to construct coeng (subscript) consonants //                 Differently than indian languages, the coeng modifies the consonant that follows it, //                 not the one preceding it  Each consonant has two forms, the base form and the subscript form //                 the base form is the normal one (using the consonants code-point), the subscript form is //                 displayed when the combination coeng + consonant is encountered. //      Consonant of type 1 -> A consonant which has subscript for that only occupies space under a base consonant //      Consonant of type 2.-> Its subscript form occupies space under and before the base (only one, RO) //      Consonant of Type 3 -> Its subscript form occupies space under and after the base (KHO, CHHO, THHO, BA, YO, SA) //      Consonant shifter -> Khmer has to series of consonants. The same dependent vowel has different sounds //                           if it is attached to a consonant of the first series or a consonant of the second series //                           Most consonants have an equivalent in the other series, but some of theme exist only in //                           one series (for example SA). If we want to use the consonant SA with a vowel sound that //                           can only be done with a vowel sound that corresponds to a vowel accompanying a consonant //                           of the other series, then we need to use a consonant shifter: TRIISAP or MUSIKATOAN //                           x17C9 y x17CA. TRIISAP changes a first series consonant to second series sound and //                           MUSIKATOAN a second series consonant to have a first series vowel sound. //                           Consonant shifter are both normally supercript marks, but, when they are followed by a //                           superscript, they change shape and take the form of subscript dependent vowel SRA U. //                           If they are in the same syllable as a coeng consonant, Unicode 3.0 says that they //                           should be typed before the coeng. Unicode 4.0 breaks the standard and says that it should //                           be placed after the coeng consonant. //      Dependent vowel ->   In khmer dependent vowels can be placed above, below, before or after the base //                           Each vowel has its own position. Only one vowel per syllable is allowed. //      Signs            ->  Khmer has above signs and post signs. Only one above sign and/or one post sign are //                           Allowed in a syllable. // // //   order is important here! This order must be the same that is found in each horizontal //   line in the statetable for Khmer (see khmerStateTable) . */
end_comment
begin_enum
DECL|enum|KhmerCharClassValues
enum|enum
name|KhmerCharClassValues
block|{
DECL|enumerator|CC_RESERVED
name|CC_RESERVED
init|=
literal|0
block|,
DECL|enumerator|CC_CONSONANT
name|CC_CONSONANT
init|=
literal|1
block|,
comment|/* Consonant of type 1 or independent vowel */
DECL|enumerator|CC_CONSONANT2
name|CC_CONSONANT2
init|=
literal|2
block|,
comment|/* Consonant of type 2 */
DECL|enumerator|CC_CONSONANT3
name|CC_CONSONANT3
init|=
literal|3
block|,
comment|/* Consonant of type 3 */
DECL|enumerator|CC_ZERO_WIDTH_NJ_MARK
name|CC_ZERO_WIDTH_NJ_MARK
init|=
literal|4
block|,
comment|/* Zero Width non joiner character (0x200C) */
DECL|enumerator|CC_CONSONANT_SHIFTER
name|CC_CONSONANT_SHIFTER
init|=
literal|5
block|,
DECL|enumerator|CC_ROBAT
name|CC_ROBAT
init|=
literal|6
block|,
comment|/* Khmer special diacritic accent -treated differently in state table */
DECL|enumerator|CC_COENG
name|CC_COENG
init|=
literal|7
block|,
comment|/* Subscript consonant combining character */
DECL|enumerator|CC_DEPENDENT_VOWEL
name|CC_DEPENDENT_VOWEL
init|=
literal|8
block|,
DECL|enumerator|CC_SIGN_ABOVE
name|CC_SIGN_ABOVE
init|=
literal|9
block|,
DECL|enumerator|CC_SIGN_AFTER
name|CC_SIGN_AFTER
init|=
literal|10
block|,
DECL|enumerator|CC_ZERO_WIDTH_J_MARK
name|CC_ZERO_WIDTH_J_MARK
init|=
literal|11
block|,
comment|/* Zero width joiner character */
DECL|enumerator|CC_COUNT
name|CC_COUNT
init|=
literal|12
comment|/* This is the number of character classes */
block|}
enum|;
end_enum
begin_enum
DECL|enum|KhmerCharClassFlags
enum|enum
name|KhmerCharClassFlags
block|{
DECL|enumerator|CF_CLASS_MASK
name|CF_CLASS_MASK
init|=
literal|0x0000FFFF
block|,
DECL|enumerator|CF_CONSONANT
name|CF_CONSONANT
init|=
literal|0x01000000
block|,
comment|/* flag to speed up comparing */
DECL|enumerator|CF_SPLIT_VOWEL
name|CF_SPLIT_VOWEL
init|=
literal|0x02000000
block|,
comment|/* flag for a split vowel -> the first part is added in front of the syllable */
DECL|enumerator|CF_DOTTED_CIRCLE
name|CF_DOTTED_CIRCLE
init|=
literal|0x04000000
block|,
comment|/* add a dotted circle if a character with this flag is the first in a syllable */
DECL|enumerator|CF_COENG
name|CF_COENG
init|=
literal|0x08000000
block|,
comment|/* flag to speed up comparing */
DECL|enumerator|CF_SHIFTER
name|CF_SHIFTER
init|=
literal|0x10000000
block|,
comment|/* flag to speed up comparing */
DECL|enumerator|CF_ABOVE_VOWEL
name|CF_ABOVE_VOWEL
init|=
literal|0x20000000
block|,
comment|/* flag to speed up comparing */
comment|/* position flags */
DECL|enumerator|CF_POS_BEFORE
name|CF_POS_BEFORE
init|=
literal|0x00080000
block|,
DECL|enumerator|CF_POS_BELOW
name|CF_POS_BELOW
init|=
literal|0x00040000
block|,
DECL|enumerator|CF_POS_ABOVE
name|CF_POS_ABOVE
init|=
literal|0x00020000
block|,
DECL|enumerator|CF_POS_AFTER
name|CF_POS_AFTER
init|=
literal|0x00010000
block|,
DECL|enumerator|CF_POS_MASK
name|CF_POS_MASK
init|=
literal|0x000f0000
block|}
enum|;
end_enum
begin_comment
comment|/* Characters that get referred to by name */
end_comment
begin_enum
DECL|enum|KhmerChar
enum|enum
name|KhmerChar
block|{
DECL|enumerator|C_SIGN_ZWNJ
name|C_SIGN_ZWNJ
init|=
literal|0x200C
block|,
DECL|enumerator|C_SIGN_ZWJ
name|C_SIGN_ZWJ
init|=
literal|0x200D
block|,
DECL|enumerator|C_RO
name|C_RO
init|=
literal|0x179A
block|,
DECL|enumerator|C_VOWEL_AA
name|C_VOWEL_AA
init|=
literal|0x17B6
block|,
DECL|enumerator|C_SIGN_NIKAHIT
name|C_SIGN_NIKAHIT
init|=
literal|0x17C6
block|,
DECL|enumerator|C_VOWEL_E
name|C_VOWEL_E
init|=
literal|0x17C1
block|,
DECL|enumerator|C_COENG
name|C_COENG
init|=
literal|0x17D2
block|}
enum|;
end_enum
begin_comment
comment|/* //  simple classes, they are used in the statetable (in this file) to control the length of a syllable //  they are also used to know where a character should be placed (location in reference to the base character) //  and also to know if a character, when independently displayed, should be displayed with a dotted-circle to //  indicate error in syllable construction */
end_comment
begin_enum
enum|enum
block|{
DECL|enumerator|_xx
name|_xx
init|=
name|CC_RESERVED
block|,
DECL|enumerator|_sa
name|_sa
init|=
name|CC_SIGN_ABOVE
operator||
name|CF_DOTTED_CIRCLE
operator||
name|CF_POS_ABOVE
block|,
DECL|enumerator|_sp
name|_sp
init|=
name|CC_SIGN_AFTER
operator||
name|CF_DOTTED_CIRCLE
operator||
name|CF_POS_AFTER
block|,
DECL|enumerator|_c1
name|_c1
init|=
name|CC_CONSONANT
operator||
name|CF_CONSONANT
block|,
DECL|enumerator|_c2
name|_c2
init|=
name|CC_CONSONANT2
operator||
name|CF_CONSONANT
block|,
DECL|enumerator|_c3
name|_c3
init|=
name|CC_CONSONANT3
operator||
name|CF_CONSONANT
block|,
DECL|enumerator|_rb
name|_rb
init|=
name|CC_ROBAT
operator||
name|CF_POS_ABOVE
operator||
name|CF_DOTTED_CIRCLE
block|,
DECL|enumerator|_cs
name|_cs
init|=
name|CC_CONSONANT_SHIFTER
operator||
name|CF_DOTTED_CIRCLE
operator||
name|CF_SHIFTER
block|,
DECL|enumerator|_dl
name|_dl
init|=
name|CC_DEPENDENT_VOWEL
operator||
name|CF_POS_BEFORE
operator||
name|CF_DOTTED_CIRCLE
block|,
DECL|enumerator|_db
name|_db
init|=
name|CC_DEPENDENT_VOWEL
operator||
name|CF_POS_BELOW
operator||
name|CF_DOTTED_CIRCLE
block|,
DECL|enumerator|_da
name|_da
init|=
name|CC_DEPENDENT_VOWEL
operator||
name|CF_POS_ABOVE
operator||
name|CF_DOTTED_CIRCLE
operator||
name|CF_ABOVE_VOWEL
block|,
DECL|enumerator|_dr
name|_dr
init|=
name|CC_DEPENDENT_VOWEL
operator||
name|CF_POS_AFTER
operator||
name|CF_DOTTED_CIRCLE
block|,
DECL|enumerator|_co
name|_co
init|=
name|CC_COENG
operator||
name|CF_COENG
operator||
name|CF_DOTTED_CIRCLE
block|,
comment|/* split vowel */
DECL|enumerator|_va
name|_va
init|=
name|_da
operator||
name|CF_SPLIT_VOWEL
block|,
DECL|enumerator|_vr
name|_vr
init|=
name|_dr
operator||
name|CF_SPLIT_VOWEL
block|}
enum|;
end_enum
begin_comment
comment|/* //   Character class: a character class value //   ORed with character class flags. */
end_comment
begin_typedef
DECL|typedef|KhmerCharClass
typedef|typedef
name|unsigned
name|long
name|KhmerCharClass
typedef|;
end_typedef
begin_comment
comment|/* //  Character class tables //  _xx character does not combine into syllable, such as numbers, puntuation marks, non-Khmer signs... //  _sa Sign placed above the base //  _sp Sign placed after the base //  _c1 Consonant of type 1 or independent vowel (independent vowels behave as type 1 consonants) //  _c2 Consonant of type 2 (only RO) //  _c3 Consonant of type 3 //  _rb Khmer sign robat u17CC. combining mark for subscript consonants //  _cd Consonant-shifter //  _dl Dependent vowel placed before the base (left of the base) //  _db Dependent vowel placed below the base //  _da Dependent vowel placed above the base //  _dr Dependent vowel placed behind the base (right of the base) //  _co Khmer combining mark COENG u17D2, combines with the consonant or independent vowel following //      it to create a subscript consonant or independent vowel //  _va Khmer split vowel in which the first part is before the base and the second one above the base //  _vr Khmer split vowel in which the first part is before the base and the second one behind (right of) the base */
end_comment
begin_decl_stmt
DECL|variable|khmerCharClasses
specifier|static
specifier|const
name|KhmerCharClass
name|khmerCharClasses
index|[]
init|=
block|{
name|_c1
block|,
name|_c1
block|,
name|_c1
block|,
name|_c3
block|,
name|_c1
block|,
name|_c1
block|,
name|_c1
block|,
name|_c1
block|,
name|_c3
block|,
name|_c1
block|,
name|_c1
block|,
name|_c1
block|,
name|_c1
block|,
name|_c3
block|,
name|_c1
block|,
name|_c1
block|,
comment|/* 1780 - 178F */
name|_c1
block|,
name|_c1
block|,
name|_c1
block|,
name|_c1
block|,
name|_c3
block|,
name|_c1
block|,
name|_c1
block|,
name|_c1
block|,
name|_c1
block|,
name|_c3
block|,
name|_c2
block|,
name|_c1
block|,
name|_c1
block|,
name|_c1
block|,
name|_c3
block|,
name|_c3
block|,
comment|/* 1790 - 179F */
name|_c1
block|,
name|_c3
block|,
name|_c1
block|,
name|_c1
block|,
name|_c1
block|,
name|_c1
block|,
name|_c1
block|,
name|_c1
block|,
name|_c1
block|,
name|_c1
block|,
name|_c1
block|,
name|_c1
block|,
name|_c1
block|,
name|_c1
block|,
name|_c1
block|,
name|_c1
block|,
comment|/* 17A0 - 17AF */
name|_c1
block|,
name|_c1
block|,
name|_c1
block|,
name|_c1
block|,
name|_dr
block|,
name|_dr
block|,
name|_dr
block|,
name|_da
block|,
name|_da
block|,
name|_da
block|,
name|_da
block|,
name|_db
block|,
name|_db
block|,
name|_db
block|,
name|_va
block|,
name|_vr
block|,
comment|/* 17B0 - 17BF */
name|_vr
block|,
name|_dl
block|,
name|_dl
block|,
name|_dl
block|,
name|_vr
block|,
name|_vr
block|,
name|_sa
block|,
name|_sp
block|,
name|_sp
block|,
name|_cs
block|,
name|_cs
block|,
name|_sa
block|,
name|_rb
block|,
name|_sa
block|,
name|_sa
block|,
name|_sa
block|,
comment|/* 17C0 - 17CF */
name|_sa
block|,
name|_sa
block|,
name|_co
block|,
name|_sa
block|,
name|_xx
block|,
name|_xx
block|,
name|_xx
block|,
name|_xx
block|,
name|_xx
block|,
name|_xx
block|,
name|_xx
block|,
name|_xx
block|,
name|_xx
block|,
name|_sa
block|,
name|_xx
block|,
name|_xx
comment|/* 17D0 - 17DF */
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* this enum must reflect the range of khmerCharClasses */
end_comment
begin_enum
DECL|enum|KhmerCharClassesRange
enum|enum
name|KhmerCharClassesRange
block|{
DECL|enumerator|KhmerFirstChar
name|KhmerFirstChar
init|=
literal|0x1780
block|,
DECL|enumerator|KhmerLastChar
name|KhmerLastChar
init|=
literal|0x17df
block|}
enum|;
end_enum
begin_comment
comment|/* //  Below we define how a character in the input string is either in the khmerCharClasses table //  (in which case we get its type back), a ZWJ or ZWNJ (two characters that may appear //  within the syllable, but are not in the table) we also get their type back, or an unknown object //  in which case we get _xx (CC_RESERVED) back */
end_comment
begin_function
DECL|function|getKhmerCharClass
specifier|static
name|KhmerCharClass
name|getKhmerCharClass
parameter_list|(
name|HB_UChar16
name|uc
parameter_list|)
block|{
if|if
condition|(
name|uc
operator|==
name|C_SIGN_ZWJ
condition|)
block|{
return|return
name|CC_ZERO_WIDTH_J_MARK
return|;
block|}
if|if
condition|(
name|uc
operator|==
name|C_SIGN_ZWNJ
condition|)
block|{
return|return
name|CC_ZERO_WIDTH_NJ_MARK
return|;
block|}
if|if
condition|(
name|uc
operator|<
name|KhmerFirstChar
operator|||
name|uc
operator|>
name|KhmerLastChar
condition|)
block|{
return|return
name|CC_RESERVED
return|;
block|}
return|return
name|khmerCharClasses
index|[
name|uc
operator|-
name|KhmerFirstChar
index|]
return|;
block|}
end_function
begin_comment
comment|/* //  The stateTable is used to calculate the end (the length) of a well //  formed Khmer Syllable. // //  Each horizontal line is ordered exactly the same way as the values in KhmerClassTable //  CharClassValues. This coincidence of values allows the follow up of the table. // //  Each line corresponds to a state, which does not necessarily need to be a type //  of component... for example, state 2 is a base, with is always a first character //  in the syllable, but the state could be produced a consonant of any type when //  it is the first character that is analysed (in ground state). // //  Differentiating 3 types of consonants is necessary in order to //  forbid the use of certain combinations, such as having a second //  coeng after a coeng RO, //  The inexistent possibility of having a type 3 after another type 3 is permitted, //  eliminating it would very much complicate the table, and it does not create typing //  problems, as the case above. // //  The table is quite complex, in order to limit the number of coeng consonants //  to 2 (by means of the table). // //  There a peculiarity, as far as Unicode is concerned: //  - The consonant-shifter is considered in two possible different //    locations, the one considered in Unicode 3.0 and the one considered in //    Unicode 4.0. (there is a backwards compatibility problem in this standard). // // //  xx    independent character, such as a number, punctuation sign or non-khmer char // //  c1    Khmer consonant of type 1 or an independent vowel //        that is, a letter in which the subscript for is only under the //        base, not taking any space to the right or to the left // //  c2    Khmer consonant of type 2, the coeng form takes space under //        and to the left of the base (only RO is of this type) // //  c3    Khmer consonant of type 3. Its subscript form takes space under //        and to the right of the base. // //  cs    Khmer consonant shifter // //  rb    Khmer robat // //  co    coeng character (u17D2) // //  dv    dependent vowel (including split vowels, they are treated in the same way). //        even if dv is not defined above, the component that is really tested for is //        KhmerClassTable::CC_DEPENDENT_VOWEL, which is common to all dependent vowels // //  zwj   Zero Width joiner // //  zwnj  Zero width non joiner // //  sa    above sign // //  sp    post sign // //  there are lines with equal content but for an easier understanding //  (and maybe change in the future) we did not join them */
end_comment
begin_decl_stmt
DECL|variable|khmerStateTable
specifier|static
specifier|const
name|signed
name|char
name|khmerStateTable
index|[]
index|[
name|CC_COUNT
index|]
init|=
block|{
comment|/* xx  c1  c2  c3 zwnj cs  rb  co  dv  sa  sp zwj */
block|{
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|6
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|}
block|,
comment|/*  0 - ground state */
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|/*  1 - exit state (or sign to the right of the syllable) */
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|16
block|,
literal|17
block|,
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|/*  2 - Base consonant */
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|4
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|16
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|/*  3 - First ZWNJ before a register shifter It can only be followed by a shifter or a vowel */
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|15
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|6
block|,
literal|16
block|,
literal|17
block|,
literal|1
block|,
literal|14
block|}
block|,
comment|/*  4 - First register shifter */
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|20
block|,
operator|-
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|/*  5 - Robat */
block|{
operator|-
literal|1
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|/*  6 - First Coeng */
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|12
block|,
literal|13
block|,
operator|-
literal|1
block|,
literal|10
block|,
literal|16
block|,
literal|17
block|,
literal|1
block|,
literal|14
block|}
block|,
comment|/*  7 - First consonant of type 1 after coeng */
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|12
block|,
literal|13
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|16
block|,
literal|17
block|,
literal|1
block|,
literal|14
block|}
block|,
comment|/*  8 - First consonant of type 2 after coeng */
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|12
block|,
literal|13
block|,
operator|-
literal|1
block|,
literal|10
block|,
literal|16
block|,
literal|17
block|,
literal|1
block|,
literal|14
block|}
block|,
comment|/*  9 - First consonant or type 3 after ceong */
block|{
operator|-
literal|1
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|/* 10 - Second Coeng (no register shifter before) */
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|15
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|16
block|,
literal|17
block|,
literal|1
block|,
literal|14
block|}
block|,
comment|/* 11 - Second coeng consonant (or ind. vowel) no register shifter before */
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|13
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|16
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|/* 12 - Second ZWNJ before a register shifter */
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|15
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|16
block|,
literal|17
block|,
literal|1
block|,
literal|14
block|}
block|,
comment|/* 13 - Second register shifter */
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|16
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|/* 14 - ZWJ before vowel */
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|16
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|/* 15 - ZWNJ before vowel */
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|17
block|,
literal|1
block|,
literal|18
block|}
block|,
comment|/* 16 - dependent vowel */
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|1
block|,
literal|18
block|}
block|,
comment|/* 17 - sign above */
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|19
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|/* 18 - ZWJ after vowel */
block|{
operator|-
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|/* 19 - Third coeng */
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|/* 20 - dependent vowel after a Robat */
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*  #define KHMER_DEBUG */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|KHMER_DEBUG
end_ifdef
begin_define
DECL|macro|KHDEBUG
define|#
directive|define
name|KHDEBUG
value|qDebug
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|KHDEBUG
define|#
directive|define
name|KHDEBUG
value|if(0) printf
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* //  Given an input string of characters and a location in which to start looking //  calculate, using the state table, which one is the last character of the syllable //  that starts in the starting position. */
end_comment
begin_function
DECL|function|khmer_nextSyllableBoundary
specifier|static
name|int
name|khmer_nextSyllableBoundary
parameter_list|(
specifier|const
name|HB_UChar16
modifier|*
name|s
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|,
name|HB_Bool
modifier|*
name|invalid
parameter_list|)
block|{
specifier|const
name|HB_UChar16
modifier|*
name|uc
init|=
name|s
operator|+
name|start
decl_stmt|;
name|int
name|state
init|=
literal|0
decl_stmt|;
name|int
name|pos
init|=
name|start
decl_stmt|;
operator|*
name|invalid
operator|=
name|FALSE
expr_stmt|;
while|while
condition|(
name|pos
operator|<
name|end
condition|)
block|{
name|KhmerCharClass
name|charClass
init|=
name|getKhmerCharClass
argument_list|(
operator|*
name|uc
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|==
name|start
condition|)
block|{
operator|*
name|invalid
operator|=
operator|(
name|charClass
operator|>
literal|0
operator|)
operator|&&
operator|!
operator|(
name|charClass
operator|&
name|CF_CONSONANT
operator|)
expr_stmt|;
block|}
name|state
operator|=
name|khmerStateTable
index|[
name|state
index|]
index|[
name|charClass
operator|&
name|CF_CLASS_MASK
index|]
expr_stmt|;
name|KHDEBUG
argument_list|(
literal|"state[%d]=%d class=%8lx (uc=%4x)"
argument_list|,
name|pos
operator|-
name|start
argument_list|,
name|state
argument_list|,
name|charClass
argument_list|,
operator|*
name|uc
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|<
literal|0
condition|)
block|{
break|break;
block|}
operator|++
name|uc
expr_stmt|;
operator|++
name|pos
expr_stmt|;
block|}
return|return
name|pos
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|NO_OPENTYPE
end_ifndef
begin_decl_stmt
DECL|variable|khmer_features
specifier|static
specifier|const
name|HB_OpenTypeFeature
name|khmer_features
index|[]
init|=
block|{
block|{
name|HB_MAKE_TAG
argument_list|(
literal|'p'
argument_list|,
literal|'r'
argument_list|,
literal|'e'
argument_list|,
literal|'f'
argument_list|)
block|,
name|PreFormProperty
block|}
block|,
block|{
name|HB_MAKE_TAG
argument_list|(
literal|'b'
argument_list|,
literal|'l'
argument_list|,
literal|'w'
argument_list|,
literal|'f'
argument_list|)
block|,
name|BelowFormProperty
block|}
block|,
block|{
name|HB_MAKE_TAG
argument_list|(
literal|'a'
argument_list|,
literal|'b'
argument_list|,
literal|'v'
argument_list|,
literal|'f'
argument_list|)
block|,
name|AboveFormProperty
block|}
block|,
block|{
name|HB_MAKE_TAG
argument_list|(
literal|'p'
argument_list|,
literal|'s'
argument_list|,
literal|'t'
argument_list|,
literal|'f'
argument_list|)
block|,
name|PostFormProperty
block|}
block|,
block|{
name|HB_MAKE_TAG
argument_list|(
literal|'p'
argument_list|,
literal|'r'
argument_list|,
literal|'e'
argument_list|,
literal|'s'
argument_list|)
block|,
name|PreSubstProperty
block|}
block|,
block|{
name|HB_MAKE_TAG
argument_list|(
literal|'b'
argument_list|,
literal|'l'
argument_list|,
literal|'w'
argument_list|,
literal|'s'
argument_list|)
block|,
name|BelowSubstProperty
block|}
block|,
block|{
name|HB_MAKE_TAG
argument_list|(
literal|'a'
argument_list|,
literal|'b'
argument_list|,
literal|'v'
argument_list|,
literal|'s'
argument_list|)
block|,
name|AboveSubstProperty
block|}
block|,
block|{
name|HB_MAKE_TAG
argument_list|(
literal|'p'
argument_list|,
literal|'s'
argument_list|,
literal|'t'
argument_list|,
literal|'s'
argument_list|)
block|,
name|PostSubstProperty
block|}
block|,
block|{
name|HB_MAKE_TAG
argument_list|(
literal|'c'
argument_list|,
literal|'l'
argument_list|,
literal|'i'
argument_list|,
literal|'g'
argument_list|)
block|,
name|CligProperty
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|khmer_shape_syllable
specifier|static
name|HB_Bool
name|khmer_shape_syllable
parameter_list|(
name|HB_Bool
name|openType
parameter_list|,
name|HB_ShaperItem
modifier|*
name|item
parameter_list|)
block|{
comment|/*    KHDEBUG("syllable from %d len %d, str='%s'", item->from, item->length,   	    item->string->mid(item->from, item->length).toUtf8().data()); */
name|int
name|len
init|=
literal|0
decl_stmt|;
name|int
name|syllableEnd
init|=
name|item
operator|->
name|item
operator|.
name|pos
operator|+
name|item
operator|->
name|item
operator|.
name|length
decl_stmt|;
name|unsigned
name|short
name|reordered
index|[
literal|16
index|]
decl_stmt|;
name|unsigned
name|char
name|properties
index|[
literal|16
index|]
decl_stmt|;
enum|enum
block|{
name|AboveForm
init|=
literal|0x01
block|,
name|PreForm
init|=
literal|0x02
block|,
name|PostForm
init|=
literal|0x04
block|,
name|BelowForm
init|=
literal|0x08
block|}
enum|;
ifndef|#
directive|ifndef
name|NO_OPENTYPE
specifier|const
name|int
name|availableGlyphs
init|=
name|item
operator|->
name|num_glyphs
decl_stmt|;
endif|#
directive|endif
name|int
name|coengRo
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* according to the specs this is the max length one can get        ### the real value should be smaller */
name|assert
argument_list|(
name|item
operator|->
name|item
operator|.
name|length
operator|<
literal|13
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|properties
argument_list|,
literal|0
argument_list|,
literal|16
operator|*
expr|sizeof
operator|(
name|unsigned
name|char
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KHMER_DEBUG
name|qDebug
argument_list|(
literal|"original:"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|from
init|;
name|i
operator|<
name|syllableEnd
condition|;
name|i
operator|++
control|)
block|{
name|qDebug
argument_list|(
literal|"    %d: %4x"
argument_list|,
name|i
argument_list|,
name|string
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*     // write a pre vowel or the pre part of a split vowel first     // and look out for coeng + ro. RO is the only vowel of type 2, and     // therefore the only one that requires saving space before the base.     */
name|coengRo
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* There is no Coeng Ro, if found this value will change */
for|for
control|(
name|i
operator|=
name|item
operator|->
name|item
operator|.
name|pos
init|;
name|i
operator|<
name|syllableEnd
condition|;
name|i
operator|+=
literal|1
control|)
block|{
name|KhmerCharClass
name|charClass
init|=
name|getKhmerCharClass
argument_list|(
name|item
operator|->
name|string
index|[
name|i
index|]
argument_list|)
decl_stmt|;
comment|/* if a split vowel, write the pre part. In Khmer the pre part            is the same for all split vowels, same glyph as pre vowel C_VOWEL_E */
if|if
condition|(
name|charClass
operator|&
name|CF_SPLIT_VOWEL
condition|)
block|{
name|reordered
index|[
name|len
index|]
operator|=
name|C_VOWEL_E
expr_stmt|;
name|properties
index|[
name|len
index|]
operator|=
name|PreForm
expr_stmt|;
operator|++
name|len
expr_stmt|;
break|break;
comment|/* there can be only one vowel */
block|}
comment|/* if a vowel with pos before write it out */
if|if
condition|(
name|charClass
operator|&
name|CF_POS_BEFORE
condition|)
block|{
name|reordered
index|[
name|len
index|]
operator|=
name|item
operator|->
name|string
index|[
name|i
index|]
expr_stmt|;
name|properties
index|[
name|len
index|]
operator|=
name|PreForm
expr_stmt|;
operator|++
name|len
expr_stmt|;
break|break;
comment|/* there can be only one vowel */
block|}
comment|/* look for coeng + ro and remember position            works because coeng + ro is always in front of a vowel (if there is a vowel)            and because CC_CONSONANT2 is enough to identify it, as it is the only consonant            with this flag */
if|if
condition|(
operator|(
name|charClass
operator|&
name|CF_COENG
operator|)
operator|&&
operator|(
name|i
operator|+
literal|1
operator|<
name|syllableEnd
operator|)
operator|&&
operator|(
operator|(
name|getKhmerCharClass
argument_list|(
name|item
operator|->
name|string
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
operator|&
name|CF_CLASS_MASK
operator|)
operator|==
name|CC_CONSONANT2
operator|)
condition|)
block|{
name|coengRo
operator|=
name|i
expr_stmt|;
block|}
block|}
comment|/* write coeng + ro if found */
if|if
condition|(
name|coengRo
operator|>
operator|-
literal|1
condition|)
block|{
name|reordered
index|[
name|len
index|]
operator|=
name|C_COENG
expr_stmt|;
name|properties
index|[
name|len
index|]
operator|=
name|PreForm
expr_stmt|;
operator|++
name|len
expr_stmt|;
name|reordered
index|[
name|len
index|]
operator|=
name|C_RO
expr_stmt|;
name|properties
index|[
name|len
index|]
operator|=
name|PreForm
expr_stmt|;
operator|++
name|len
expr_stmt|;
block|}
comment|/*        shall we add a dotted circle?        If in the position in which the base should be (first char in the string) there is        a character that has the Dotted circle flag (a character that cannot be a base)        then write a dotted circle */
if|if
condition|(
name|getKhmerCharClass
argument_list|(
name|item
operator|->
name|string
index|[
name|item
operator|->
name|item
operator|.
name|pos
index|]
argument_list|)
operator|&
name|CF_DOTTED_CIRCLE
condition|)
block|{
name|reordered
index|[
name|len
index|]
operator|=
name|C_DOTTED_CIRCLE
expr_stmt|;
operator|++
name|len
expr_stmt|;
block|}
comment|/* copy what is left to the output, skipping before vowels and        coeng Ro if they are present */
for|for
control|(
name|i
operator|=
name|item
operator|->
name|item
operator|.
name|pos
init|;
name|i
operator|<
name|syllableEnd
condition|;
name|i
operator|+=
literal|1
control|)
block|{
name|HB_UChar16
name|uc
init|=
name|item
operator|->
name|string
index|[
name|i
index|]
decl_stmt|;
name|KhmerCharClass
name|charClass
init|=
name|getKhmerCharClass
argument_list|(
name|uc
argument_list|)
decl_stmt|;
comment|/* skip a before vowel, it was already processed */
if|if
condition|(
name|charClass
operator|&
name|CF_POS_BEFORE
condition|)
block|{
continue|continue;
block|}
comment|/* skip coeng + ro, it was already processed */
if|if
condition|(
name|i
operator|==
name|coengRo
condition|)
block|{
name|i
operator|+=
literal|1
expr_stmt|;
continue|continue;
block|}
switch|switch
condition|(
name|charClass
operator|&
name|CF_POS_MASK
condition|)
block|{
case|case
name|CF_POS_ABOVE
case|:
name|reordered
index|[
name|len
index|]
operator|=
name|uc
expr_stmt|;
name|properties
index|[
name|len
index|]
operator|=
name|AboveForm
expr_stmt|;
operator|++
name|len
expr_stmt|;
break|break;
case|case
name|CF_POS_AFTER
case|:
name|reordered
index|[
name|len
index|]
operator|=
name|uc
expr_stmt|;
name|properties
index|[
name|len
index|]
operator|=
name|PostForm
expr_stmt|;
operator|++
name|len
expr_stmt|;
break|break;
case|case
name|CF_POS_BELOW
case|:
name|reordered
index|[
name|len
index|]
operator|=
name|uc
expr_stmt|;
name|properties
index|[
name|len
index|]
operator|=
name|BelowForm
expr_stmt|;
operator|++
name|len
expr_stmt|;
break|break;
default|default:
comment|/* assign the correct flags to a coeng consonant                    Consonants of type 3 are taged as Post forms and those type 1 as below forms */
if|if
condition|(
operator|(
name|charClass
operator|&
name|CF_COENG
operator|)
operator|&&
name|i
operator|+
literal|1
operator|<
name|syllableEnd
condition|)
block|{
name|unsigned
name|char
name|property
init|=
operator|(
name|getKhmerCharClass
argument_list|(
name|item
operator|->
name|string
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
operator|&
name|CF_CLASS_MASK
operator|)
operator|==
name|CC_CONSONANT3
condition|?
name|PostForm
else|:
name|BelowForm
decl_stmt|;
name|reordered
index|[
name|len
index|]
operator|=
name|uc
expr_stmt|;
name|properties
index|[
name|len
index|]
operator|=
name|property
expr_stmt|;
operator|++
name|len
expr_stmt|;
name|i
operator|+=
literal|1
expr_stmt|;
name|reordered
index|[
name|len
index|]
operator|=
name|item
operator|->
name|string
index|[
name|i
index|]
expr_stmt|;
name|properties
index|[
name|len
index|]
operator|=
name|property
expr_stmt|;
operator|++
name|len
expr_stmt|;
break|break;
block|}
comment|/* if a shifter is followed by an above vowel change the shifter to below form,                    an above vowel can have two possible positions i + 1 or i + 3                    (position i+1 corresponds to unicode 3, position i+3 to Unicode 4)                    and there is an extra rule for C_VOWEL_AA + C_SIGN_NIKAHIT also for two                    different positions, right after the shifter or after a vowel (Unicode 4) */
if|if
condition|(
operator|(
name|charClass
operator|&
name|CF_SHIFTER
operator|)
operator|&&
operator|(
name|i
operator|+
literal|1
operator|<
name|syllableEnd
operator|)
condition|)
block|{
if|if
condition|(
name|getKhmerCharClass
argument_list|(
name|item
operator|->
name|string
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
operator|&
name|CF_ABOVE_VOWEL
condition|)
block|{
name|reordered
index|[
name|len
index|]
operator|=
name|uc
expr_stmt|;
name|properties
index|[
name|len
index|]
operator|=
name|BelowForm
expr_stmt|;
operator|++
name|len
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|+
literal|2
operator|<
name|syllableEnd
operator|&&
operator|(
name|item
operator|->
name|string
index|[
name|i
operator|+
literal|1
index|]
operator|==
name|C_VOWEL_AA
operator|)
operator|&&
operator|(
name|item
operator|->
name|string
index|[
name|i
operator|+
literal|2
index|]
operator|==
name|C_SIGN_NIKAHIT
operator|)
condition|)
block|{
name|reordered
index|[
name|len
index|]
operator|=
name|uc
expr_stmt|;
name|properties
index|[
name|len
index|]
operator|=
name|BelowForm
expr_stmt|;
operator|++
name|len
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|+
literal|3
operator|<
name|syllableEnd
operator|&&
operator|(
name|getKhmerCharClass
argument_list|(
name|item
operator|->
name|string
index|[
name|i
operator|+
literal|3
index|]
argument_list|)
operator|&
name|CF_ABOVE_VOWEL
operator|)
condition|)
block|{
name|reordered
index|[
name|len
index|]
operator|=
name|uc
expr_stmt|;
name|properties
index|[
name|len
index|]
operator|=
name|BelowForm
expr_stmt|;
operator|++
name|len
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|+
literal|4
operator|<
name|syllableEnd
operator|&&
operator|(
name|item
operator|->
name|string
index|[
name|i
operator|+
literal|3
index|]
operator|==
name|C_VOWEL_AA
operator|)
operator|&&
operator|(
name|item
operator|->
name|string
index|[
name|i
operator|+
literal|4
index|]
operator|==
name|C_SIGN_NIKAHIT
operator|)
condition|)
block|{
name|reordered
index|[
name|len
index|]
operator|=
name|uc
expr_stmt|;
name|properties
index|[
name|len
index|]
operator|=
name|BelowForm
expr_stmt|;
operator|++
name|len
expr_stmt|;
break|break;
block|}
block|}
comment|/* default - any other characters */
name|reordered
index|[
name|len
index|]
operator|=
name|uc
expr_stmt|;
operator|++
name|len
expr_stmt|;
break|break;
block|}
comment|/* switch */
block|}
comment|/* for */
if|if
condition|(
operator|!
name|item
operator|->
name|font
operator|->
name|klass
operator|->
name|convertStringToGlyphIndices
argument_list|(
name|item
operator|->
name|font
argument_list|,
name|reordered
argument_list|,
name|len
argument_list|,
name|item
operator|->
name|glyphs
argument_list|,
operator|&
name|item
operator|->
name|num_glyphs
argument_list|,
name|item
operator|->
name|item
operator|.
name|bidiLevel
operator|%
literal|2
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|KHDEBUG
argument_list|(
literal|"after shaping: len=%d"
argument_list|,
name|len
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|item
operator|->
name|attributes
index|[
name|i
index|]
operator|.
name|mark
operator|=
name|FALSE
expr_stmt|;
name|item
operator|->
name|attributes
index|[
name|i
index|]
operator|.
name|clusterStart
operator|=
name|FALSE
expr_stmt|;
name|item
operator|->
name|attributes
index|[
name|i
index|]
operator|.
name|justification
operator|=
literal|0
expr_stmt|;
name|item
operator|->
name|attributes
index|[
name|i
index|]
operator|.
name|zeroWidth
operator|=
name|FALSE
expr_stmt|;
name|KHDEBUG
argument_list|(
literal|"    %d: %4x property=%x"
argument_list|,
name|i
argument_list|,
name|reordered
index|[
name|i
index|]
argument_list|,
name|properties
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* now we have the syllable in the right order, and can start running it through open type. */
ifndef|#
directive|ifndef
name|NO_OPENTYPE
if|if
condition|(
name|openType
condition|)
block|{
name|hb_uint32
name|where
index|[
literal|16
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
name|where
index|[
name|i
index|]
operator|=
operator|~
operator|(
name|PreSubstProperty
operator||
name|BelowSubstProperty
operator||
name|AboveSubstProperty
operator||
name|PostSubstProperty
operator||
name|CligProperty
operator||
name|PositioningProperties
operator|)
expr_stmt|;
if|if
condition|(
name|properties
index|[
name|i
index|]
operator|==
name|PreForm
condition|)
name|where
index|[
name|i
index|]
operator|&=
operator|~
name|PreFormProperty
expr_stmt|;
elseif|else
if|if
condition|(
name|properties
index|[
name|i
index|]
operator|==
name|BelowForm
condition|)
name|where
index|[
name|i
index|]
operator|&=
operator|~
name|BelowFormProperty
expr_stmt|;
elseif|else
if|if
condition|(
name|properties
index|[
name|i
index|]
operator|==
name|AboveForm
condition|)
name|where
index|[
name|i
index|]
operator|&=
operator|~
name|AboveFormProperty
expr_stmt|;
elseif|else
if|if
condition|(
name|properties
index|[
name|i
index|]
operator|==
name|PostForm
condition|)
name|where
index|[
name|i
index|]
operator|&=
operator|~
name|PostFormProperty
expr_stmt|;
block|}
name|HB_OpenTypeShape
argument_list|(
name|item
argument_list|,
name|where
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|HB_OpenTypePosition
argument_list|(
name|item
argument_list|,
name|availableGlyphs
argument_list|,
comment|/*doLogClusters*/
name|FALSE
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
else|else
endif|#
directive|endif
block|{
name|KHDEBUG
argument_list|(
literal|"Not using openType"
argument_list|)
expr_stmt|;
name|HB_HeuristicPosition
argument_list|(
name|item
argument_list|)
expr_stmt|;
block|}
name|item
operator|->
name|attributes
index|[
literal|0
index|]
operator|.
name|clusterStart
operator|=
name|TRUE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function
begin_function
DECL|function|HB_KhmerShape
name|HB_Bool
name|HB_KhmerShape
parameter_list|(
name|HB_ShaperItem
modifier|*
name|item
parameter_list|)
block|{
name|HB_Bool
name|openType
init|=
name|FALSE
decl_stmt|;
name|unsigned
name|short
modifier|*
name|logClusters
init|=
name|item
operator|->
name|log_clusters
decl_stmt|;
name|int
name|i
decl_stmt|;
name|HB_ShaperItem
name|syllable
init|=
operator|*
name|item
decl_stmt|;
name|int
name|first_glyph
init|=
literal|0
decl_stmt|;
name|int
name|sstart
init|=
name|item
operator|->
name|item
operator|.
name|pos
decl_stmt|;
name|int
name|end
init|=
name|sstart
operator|+
name|item
operator|->
name|item
operator|.
name|length
decl_stmt|;
name|assert
argument_list|(
name|item
operator|->
name|item
operator|.
name|script
operator|==
name|HB_Script_Khmer
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_OPENTYPE
name|openType
operator|=
name|HB_SelectScript
argument_list|(
name|item
argument_list|,
name|khmer_features
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|KHDEBUG
argument_list|(
literal|"khmer_shape: from %d length %d"
argument_list|,
name|item
operator|->
name|item
operator|.
name|pos
argument_list|,
name|item
operator|->
name|item
operator|.
name|length
argument_list|)
expr_stmt|;
while|while
condition|(
name|sstart
operator|<
name|end
condition|)
block|{
name|HB_Bool
name|invalid
decl_stmt|;
name|int
name|send
init|=
name|khmer_nextSyllableBoundary
argument_list|(
name|item
operator|->
name|string
argument_list|,
name|sstart
argument_list|,
name|end
argument_list|,
operator|&
name|invalid
argument_list|)
decl_stmt|;
name|KHDEBUG
argument_list|(
literal|"syllable from %d, length %d, invalid=%s"
argument_list|,
name|sstart
argument_list|,
name|send
operator|-
name|sstart
argument_list|,
name|invalid
condition|?
literal|"TRUE"
else|:
literal|"FALSE"
argument_list|)
expr_stmt|;
name|syllable
operator|.
name|item
operator|.
name|pos
operator|=
name|sstart
expr_stmt|;
name|syllable
operator|.
name|item
operator|.
name|length
operator|=
name|send
operator|-
name|sstart
expr_stmt|;
name|syllable
operator|.
name|glyphs
operator|=
name|item
operator|->
name|glyphs
operator|+
name|first_glyph
expr_stmt|;
name|syllable
operator|.
name|attributes
operator|=
name|item
operator|->
name|attributes
operator|+
name|first_glyph
expr_stmt|;
name|syllable
operator|.
name|offsets
operator|=
name|item
operator|->
name|offsets
operator|+
name|first_glyph
expr_stmt|;
name|syllable
operator|.
name|advances
operator|=
name|item
operator|->
name|advances
operator|+
name|first_glyph
expr_stmt|;
name|syllable
operator|.
name|num_glyphs
operator|=
name|item
operator|->
name|num_glyphs
operator|-
name|first_glyph
expr_stmt|;
if|if
condition|(
operator|!
name|khmer_shape_syllable
argument_list|(
name|openType
argument_list|,
operator|&
name|syllable
argument_list|)
condition|)
block|{
name|KHDEBUG
argument_list|(
literal|"syllable shaping failed, syllable requests %d glyphs"
argument_list|,
name|syllable
operator|.
name|num_glyphs
argument_list|)
expr_stmt|;
name|item
operator|->
name|num_glyphs
operator|+=
name|syllable
operator|.
name|num_glyphs
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* fix logcluster array */
name|KHDEBUG
argument_list|(
literal|"syllable:"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|first_glyph
init|;
name|i
operator|<
name|first_glyph
operator|+
operator|(
name|int
operator|)
name|syllable
operator|.
name|num_glyphs
condition|;
operator|++
name|i
control|)
name|KHDEBUG
argument_list|(
literal|"        %d -> glyph %x"
argument_list|,
name|i
argument_list|,
name|item
operator|->
name|glyphs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|KHDEBUG
argument_list|(
literal|"    logclusters:"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|sstart
init|;
name|i
operator|<
name|send
condition|;
operator|++
name|i
control|)
block|{
name|KHDEBUG
argument_list|(
literal|"        %d -> glyph %d"
argument_list|,
name|i
argument_list|,
name|first_glyph
argument_list|)
expr_stmt|;
name|logClusters
index|[
name|i
operator|-
name|item
operator|->
name|item
operator|.
name|pos
index|]
operator|=
name|first_glyph
expr_stmt|;
block|}
name|sstart
operator|=
name|send
expr_stmt|;
name|first_glyph
operator|+=
name|syllable
operator|.
name|num_glyphs
expr_stmt|;
block|}
name|item
operator|->
name|num_glyphs
operator|=
name|first_glyph
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function
begin_function
DECL|function|HB_KhmerAttributes
name|void
name|HB_KhmerAttributes
parameter_list|(
name|HB_Script
name|script
parameter_list|,
specifier|const
name|HB_UChar16
modifier|*
name|text
parameter_list|,
name|hb_uint32
name|from
parameter_list|,
name|hb_uint32
name|len
parameter_list|,
name|HB_CharAttributes
modifier|*
name|attributes
parameter_list|)
block|{
name|int
name|end
init|=
name|from
operator|+
name|len
decl_stmt|;
specifier|const
name|HB_UChar16
modifier|*
name|uc
init|=
name|text
operator|+
name|from
decl_stmt|;
name|hb_uint32
name|i
init|=
literal|0
decl_stmt|;
name|HB_UNUSED
argument_list|(
name|script
argument_list|)
expr_stmt|;
name|attributes
operator|+=
name|from
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|len
condition|)
block|{
name|HB_Bool
name|invalid
decl_stmt|;
name|hb_uint32
name|boundary
init|=
name|khmer_nextSyllableBoundary
argument_list|(
name|text
argument_list|,
name|from
operator|+
name|i
argument_list|,
name|end
argument_list|,
operator|&
name|invalid
argument_list|)
operator|-
name|from
decl_stmt|;
name|attributes
index|[
name|i
index|]
operator|.
name|graphemeBoundary
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|boundary
operator|>
name|len
operator|-
literal|1
condition|)
name|boundary
operator|=
name|len
expr_stmt|;
name|i
operator|++
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|boundary
condition|)
block|{
name|attributes
index|[
name|i
index|]
operator|.
name|graphemeBoundary
operator|=
name|FALSE
expr_stmt|;
operator|++
name|uc
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
name|assert
argument_list|(
name|i
operator|==
name|boundary
argument_list|)
expr_stmt|;
block|}
block|}
end_function
end_unit
