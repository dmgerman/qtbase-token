begin_unit
begin_comment
comment|/*  * Copyright (C) 2006  Red Hat, Inc.  *  * This is part of HarfBuzz, an OpenType Layout engine library.  *  * Permission is hereby granted, without written agreement and without  * license or royalty fees, to use, copy, modify, and distribute this  * software and its documentation for any purpose, provided that the  * above copyright notice and the following two paragraphs appear in  * all copies of this software.  *  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH  * DAMAGE.  *  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS  * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.  *  * Red Hat Author(s): Owen Taylor  */
end_comment
begin_include
include|#
directive|include
file|<stdint.h>
end_include
begin_comment
comment|/* Base Types */
end_comment
begin_typedef
DECL|typedef|HB_CodePoint
typedef|typedef
name|hb_uint16
name|HB_CodePoint
typedef|;
end_typedef
begin_comment
DECL|typedef|HB_CodePoint
comment|/* UTF-16 codepoint (not character ) */
end_comment
begin_typedef
DECL|typedef|HB_Boolean
typedef|typedef
name|char
name|HB_Boolean
typedef|;
end_typedef
begin_typedef
DECL|typedef|HB_Fixed
typedef|typedef
name|hb_uint32
name|HB_Fixed
typedef|;
end_typedef
begin_comment
DECL|typedef|HB_Fixed
comment|/* 26.6 */
end_comment
begin_typedef
DECL|typedef|HB_Glyph
typedef|typedef
name|hb_uint32
name|HB_Glyph
typedef|;
end_typedef
begin_typedef
DECL|typedef|HB_Unichar
typedef|typedef
name|hb_uint32
name|HB_Unichar
typedef|;
end_typedef
begin_comment
comment|/* Metrics reported by the font backend for use of the shaper */
end_comment
begin_typedef
DECL|typedef|HB_GlyphMetrics
typedef|typedef
name|struct
name|_HB_GlyphMetrics
name|HB_GlyphMetrics
typedef|;
end_typedef
begin_struct
DECL|struct|_HB_GlyphMetrics
struct|struct
name|_HB_GlyphMetrics
block|{
DECL|member|advance
name|HB_Fixed
name|advance
decl_stmt|;
comment|/* Do we need ink/logical extents for the glyph here? */
block|}
struct|;
end_struct
begin_comment
comment|/*  * HB_Font: Abstract font interface.  *  First pass of this might just have FT_Face *getFace();  */
end_comment
begin_typedef
DECL|typedef|HB_Font
typedef|typedef
name|struct
name|_HB_Font
name|HB_Font
typedef|;
end_typedef
begin_typedef
DECL|typedef|HB_FontClass
typedef|typedef
name|struct
name|_HB_FontClass
name|HB_FontClass
typedef|;
end_typedef
begin_struct
DECL|struct|HB_FontClass
struct|struct
name|HB_FontClass
block|{
DECL|member|charToGlyph
name|HB_Glyph
function_decl|(
modifier|*
name|charToGlyph
function_decl|)
parameter_list|(
name|HB_Font
modifier|*
name|font
parameter_list|,
name|HB_Unichar
name|chr
parameter_list|)
function_decl|;
DECL|member|getMetrics
name|void
function_decl|(
modifier|*
name|getMetrics
function_decl|)
parameter_list|(
name|HB_Font
modifier|*
name|font
parameter_list|,
name|HB_Glyph
name|glyph
parameter_list|,
name|HB_GlyphMetrics
modifier|*
name|metrics
parameter_list|)
function_decl|;
DECL|member|getSFontTable
name|HB_Boolean
function_decl|(
modifier|*
name|getSFontTable
function_decl|)
parameter_list|(
name|HB_Font
modifier|*
name|font
parameter_list|,
name|void
modifier|*
modifier|*
name|cookie
parameter_list|,
name|char
modifier|*
modifier|*
name|start
parameter_list|,
name|int
modifier|*
name|len
parameter_list|)
function_decl|;
DECL|member|freeSFontTable
name|HB_Boolean
function_decl|(
modifier|*
name|freeSFontTable
function_decl|)
parameter_list|(
name|void
modifier|*
modifier|*
name|cookie
parameter_list|)
function_decl|;
block|}
struct|;
end_struct
begin_struct
DECL|struct|_HB_Font
struct|struct
name|_HB_Font
block|{
DECL|member|clazz
name|HB_FontClass
modifier|*
name|clazz
decl_stmt|;
block|}
struct|;
end_struct
begin_comment
comment|/*  * Language tags, of the form en-us; represented as interned, canonicalized  * strings. hb_language_from_string("en_US"), hb_language_from_string("en-us")  * both return the same (pointer-comparable) HB_Language).  */
end_comment
begin_typedef
DECL|typedef|HB_Language
typedef|typedef
name|struct
name|HB_Language_
modifier|*
name|HB_Language
typedef|;
end_typedef
begin_function_decl
name|HB_Language
name|hb_language_from_string
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|const
name|char
modifier|*
name|hb_language_to_string
parameter_list|(
name|HB_Language
name|language
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/* Special treatment for the edges of runs.  */
end_comment
begin_typedef
typedef|typedef
enum|enum
block|{
DECL|enumerator|HB_RUN_EDGE_LINE_VISUAL_EDGE
name|HB_RUN_EDGE_LINE_VISUAL_EDGE
init|=
literal|1
operator|<<
literal|0
block|,
DECL|enumerator|HB_RUN_EDGE_LINE_LOGICAL_EDGE
name|HB_RUN_EDGE_LINE_LOGICAL_EDGE
init|=
literal|1
operator|<<
literal|1
block|,
DECL|enumerator|HB_RUN_EDGE_LINE_ADD_HYPHEN
name|HB_RUN_EDGE_LINE_ADD_HYPHEN
init|=
literal|1
operator|<<
literal|2
comment|/* ???? */
block|}
DECL|typedef|HB_RunEdge
name|HB_RunEdge
typedef|;
end_typedef
begin_comment
comment|/* Defines optional informaiton in HB_ShapeInput; this allows extension  * of HB_ShapeInput while keeping binary compatibility  */
end_comment
begin_typedef
typedef|typedef
enum|enum
block|{
DECL|enumerator|HB_SHAPE_START_TYPE
name|HB_SHAPE_START_TYPE
init|=
literal|1
operator|<<
literal|0
block|,
DECL|enumerator|HB_SHAPE_END_TYPE
name|HB_SHAPE_END_TYPE
init|=
literal|1
operator|<<
literal|1
block|}
DECL|typedef|HB_ShapeFlags
name|HB_ShapeFlags
typedef|;
end_typedef
begin_comment
comment|/* Attributes types are described by "interned strings"; this is a little  * annoying if you want to write a switch statement, but keeps things  * simple.  */
end_comment
begin_typedef
DECL|typedef|HB_AttributeType
typedef|typedef
name|struct
name|_HB_AttributeType
modifier|*
name|HB_AttributeType
typedef|;
end_typedef
begin_function_decl
name|HB_AttributeType
name|hb_attribute_type_from_string
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|const
name|char
modifier|*
name|hb_attribute_type_to_string
parameter_list|(
name|HB_AttributeType
name|attribute_type
parameter_list|)
function_decl|;
end_function_decl
begin_struct
DECL|struct|HB_Attribute
struct|struct
name|HB_Attribute
block|{
DECL|member|type
name|HB_AttributeType
name|type
decl_stmt|;
DECL|member|start
name|int
name|start
decl_stmt|;
DECL|member|end
name|int
name|end
decl_stmt|;
block|}
struct|;
end_struct
begin_comment
comment|/**  * You could handle this like HB_Language, but an enum seems a little nicer;  * another approach would be to use OpenType script tags.  */
end_comment
begin_typedef
typedef|typedef
enum|enum
block|{
DECL|enumerator|HB_SCRIPT_LATIN
name|HB_SCRIPT_LATIN
comment|/* ... */
block|}
DECL|typedef|HB_ShapeScript
name|HB_ShapeScript
typedef|;
end_typedef
begin_comment
comment|/* This is just the subset of direction information needed by the shaper */
end_comment
begin_typedef
typedef|typedef
enum|enum
block|{
DECL|enumerator|HB_DIRECTION_LTR
name|HB_DIRECTION_LTR
block|,
DECL|enumerator|HB_DIRECTION_RTL
name|HB_DIRECTION_RTL
block|,
DECL|enumerator|HB_DIRECTION_TTB
name|HB_DIRECTION_TTB
block|}
DECL|typedef|HB_Direction
name|HB_Direction
typedef|;
end_typedef
begin_typedef
DECL|typedef|HB_ShapeInput
typedef|typedef
name|struct
name|_HB_ShapeInput
name|HB_ShapeInput
typedef|;
end_typedef
begin_struct
DECL|struct|_HB_ShapeInput
struct|struct
name|_HB_ShapeInput
block|{
comment|/* Defines what fields the caller has initialized - fields not in      * the enum are mandatory.      */
DECL|member|flags
name|HB_ShapeFlags
name|flags
decl_stmt|;
DECL|member|text
name|HB_CodePoint
modifier|*
name|text
decl_stmt|;
DECL|member|length
name|int
name|length
decl_stmt|;
comment|/* total length of text to shape */
DECL|member|shape_offset
name|int
name|shape_offset
decl_stmt|;
comment|/* start of section to shape */
DECL|member|shape_length
name|int
name|shape_length
decl_stmt|;
comment|/* number of code points to shape */
DECL|member|direction
name|HB_Direction
name|direction
decl_stmt|;
DECL|member|script
name|HB_ShapeScript
name|script
decl_stmt|;
DECL|member|language
name|HB_Language
name|language
decl_stmt|;
DECL|member|attributes
name|HB_AttributeType
modifier|*
name|attributes
decl_stmt|;
DECL|member|n_attributes
name|int
name|n_attributes
decl_stmt|;
DECL|member|start_type
name|HB_RunEdge
name|start_type
decl_stmt|;
DECL|member|end_type
name|HB_RunEdge
name|end_type
decl_stmt|;
block|}
struct|;
end_struct
begin_struct
DECL|struct|HB_GlyphItem
struct|struct
name|HB_GlyphItem
block|{
DECL|member|glyph
name|HB_Glyph
name|glyph
decl_stmt|;
DECL|member|x_offset
name|HB_Fixed
name|x_offset
decl_stmt|;
DECL|member|y_offset
name|HB_Fixed
name|y_offset
decl_stmt|;
DECL|member|advance
name|HB_Fixed
name|advance
decl_stmt|;
comment|/* Add kashida information, etc, here */
block|}
struct|;
end_struct
begin_typedef
typedef|typedef
enum|enum
block|{
DECL|enumerator|HB_RESULT_SUCCESS
name|HB_RESULT_SUCCESS
block|,
DECL|enumerator|HB_RESULT_NO_MEMORY
name|HB_RESULT_NO_MEMORY
block|,
DECL|enumerator|HB_SHAPE_RESULT_FAILED
name|HB_SHAPE_RESULT_FAILED
block|}
DECL|typedef|HB_Result
name|HB_Result
typedef|;
end_typedef
begin_comment
comment|/*  * Buffer for output   */
end_comment
begin_typedef
DECL|typedef|HB_GlyphBuffer
typedef|typedef
name|struct
name|_HB_GlyphBuffer
name|HB_GlyphBuffer
typedef|;
end_typedef
begin_struct
DECL|struct|_HB_GlyphBuffer
struct|struct
name|_HB_GlyphBuffer
block|{
DECL|member|glyph_item_size
name|int
name|glyph_item_size
decl_stmt|;
DECL|member|total_glyphs
name|int
name|total_glyphs
decl_stmt|;
DECL|member|log_clusters
name|int
modifier|*
name|log_clusters
decl_stmt|;
comment|/* Uniscribe style */
DECL|member|cluster_space
name|int
name|cluster_space
decl_stmt|;
DECL|member|glyph_space
name|int
name|glyph_space
decl_stmt|;
DECL|member|glyph_buffer
name|void
modifier|*
name|glyph_buffer
decl_stmt|;
block|}
struct|;
end_struct
begin_comment
comment|/* Making this self-allocating simplifies writing shapers and  * also keeps things easier for caller. item_size passed in  * must be at least sizeof(HB_GlyphItem) but can be bigger,  * to accomodate application structures that extend HB_GlyphItem.  * The allocated items will be zero-initialized.  *  * (Hack: Harfbuzz could choose to use even a *bigger* item size  * and stick internal information before the public item structure.  * This hack could possibly be used to unify this with HB_Buffer)  */
end_comment
begin_function_decl
name|HB_GlyphBuffer
modifier|*
name|hb_glyph_buffer_new
parameter_list|(
name|size_t
name|item_size
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|void
name|hb_glyph_buffer_clear
parameter_list|(
name|HB_GlyphBuffer
modifier|*
name|buf
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|HB_Result
name|hb_glyph_buffer_extend_glyphs
parameter_list|(
name|HB_GlyphBuffer
modifier|*
name|buf
parameter_list|,
name|int
name|n_items
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|HB_Result
name|hb_glyph_buffer_extend_clusters
parameter_list|(
name|HB_GlyphBuffer
modifier|*
name|buf
parameter_list|,
name|int
name|n_clusters
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|void
name|hb_glyph_buffer_free
parameter_list|(
name|HB_GlyphBuffer
modifier|*
name|buf
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/* Accessor for a particular glyph */
end_comment
begin_define
DECL|macro|HB_GLYPH_BUFFER_ITEM
define|#
directive|define
name|HB_GLYPH_BUFFER_ITEM
parameter_list|(
name|buffer
parameter_list|,
name|index
parameter_list|)
end_define
begin_comment
comment|/*  * Main shaping function  */
end_comment
begin_function_decl
name|HB_Result
name|hb_shape
parameter_list|(
name|HB_ShapeInput
modifier|*
name|input
parameter_list|,
name|HB_GlyphBuffer
modifier|*
name|output
parameter_list|)
function_decl|;
end_function_decl
end_unit
