begin_unit
begin_comment
comment|/*  * Copyright (C) 2000, 2007  Red Hat, Inc.  *  * This is part of HarfBuzz, an OpenType Layout engine library.  *  * Permission is hereby granted, without written agreement and without  * license or royalty fees, to use, copy, modify, and distribute this  * software and its documentation for any purpose, provided that the  * above copyright notice and the following two paragraphs appear in  * all copies of this software.  *  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH  * DAMAGE.  *  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS  * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.  *  * Red Hat Author(s): Owen Taylor, Behdad Esfahbod  */
end_comment
begin_include
include|#
directive|include
file|"harfbuzz-impl.h"
end_include
begin_include
include|#
directive|include
file|"harfbuzz-dump.h"
end_include
begin_include
include|#
directive|include
file|"harfbuzz-gdef-private.h"
end_include
begin_include
include|#
directive|include
file|"harfbuzz-gsub-private.h"
end_include
begin_include
include|#
directive|include
file|"harfbuzz-gpos-private.h"
end_include
begin_include
include|#
directive|include
file|"harfbuzz-open-private.h"
end_include
begin_include
include|#
directive|include
file|<stdarg.h>
end_include
begin_define
DECL|macro|DUMP
define|#
directive|define
name|DUMP
parameter_list|(
name|format
parameter_list|)
value|dump (stream, indent, format)
end_define
begin_define
DECL|macro|DUMP1
define|#
directive|define
name|DUMP1
parameter_list|(
name|format
parameter_list|,
name|arg1
parameter_list|)
value|dump (stream, indent, format, arg1)
end_define
begin_define
DECL|macro|DUMP2
define|#
directive|define
name|DUMP2
parameter_list|(
name|format
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|)
value|dump (stream, indent, format, arg1, arg2)
end_define
begin_define
DECL|macro|DUMP3
define|#
directive|define
name|DUMP3
parameter_list|(
name|format
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|,
name|arg3
parameter_list|)
value|dump (stream, indent, format, arg1, arg2, arg3)
end_define
begin_define
DECL|macro|DUMP_FINT
define|#
directive|define
name|DUMP_FINT
parameter_list|(
name|strct
parameter_list|,
name|fld
parameter_list|)
value|dump (stream, indent, "<" #fld ">%d</" #fld ">\n", (strct)->fld)
end_define
begin_define
DECL|macro|DUMP_FUINT
define|#
directive|define
name|DUMP_FUINT
parameter_list|(
name|strct
parameter_list|,
name|fld
parameter_list|)
value|dump (stream, indent, "<" #fld ">%u</" #fld ">\n", (strct)->fld)
end_define
begin_define
DECL|macro|DUMP_FGLYPH
define|#
directive|define
name|DUMP_FGLYPH
parameter_list|(
name|strct
parameter_list|,
name|fld
parameter_list|)
value|dump (stream, indent, "<" #fld ">%#06x</" #fld ">\n", (strct)->fld)
end_define
begin_define
DECL|macro|DUMP_FGLYPH
define|#
directive|define
name|DUMP_FGLYPH
parameter_list|(
name|strct
parameter_list|,
name|fld
parameter_list|)
value|dump (stream, indent, "<" #fld ">%#06x</" #fld ">\n", (strct)->fld)
end_define
begin_define
DECL|macro|DUMP_USHORT_ARRAY
define|#
directive|define
name|DUMP_USHORT_ARRAY
parameter_list|(
name|strct
parameter_list|,
name|fld
parameter_list|,
name|cnt
parameter_list|)
value|Dump_UShort_Array ((strct)->fld, cnt, #fld, stream, indent);
end_define
begin_define
DECL|macro|DEF_DUMP
define|#
directive|define
name|DEF_DUMP
parameter_list|(
name|type
parameter_list|)
value|static void Dump_ ## type (HB_ ## type *type, FILE *stream, int indent, HB_Type hb_type)
end_define
begin_define
DECL|macro|RECURSE
define|#
directive|define
name|RECURSE
parameter_list|(
name|name
parameter_list|,
name|type
parameter_list|,
name|val
parameter_list|)
value|do {  DUMP ("<" #name ">\n"); Dump_ ## type (val, stream, indent + 1, hb_type); DUMP ("</" #name ">\n"); } while (0)
end_define
begin_define
DECL|macro|RECURSE_NUM
define|#
directive|define
name|RECURSE_NUM
parameter_list|(
name|name
parameter_list|,
name|i
parameter_list|,
name|type
parameter_list|,
name|val
parameter_list|)
value|do {  DUMP1 ("<" #name "><!-- %d -->\n", i); Dump_ ## type (val, stream, indent + 1, hb_type); DUMP ("</" #name ">\n"); } while (0)
end_define
begin_define
DECL|macro|DUMP_VALUE_RECORD
define|#
directive|define
name|DUMP_VALUE_RECORD
parameter_list|(
name|val
parameter_list|,
name|frmt
parameter_list|)
value|do {  DUMP ("<ValueRecord>\n"); Dump_ValueRecord (val, stream, indent + 1, hb_type, frmt); DUMP ("</ValueRecord>\n"); } while (0)
end_define
begin_function
specifier|static
name|void
DECL|function|do_indent
name|do_indent
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
name|int
name|indent
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%*s"
argument_list|,
name|indent
operator|*
literal|3
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|dump
name|dump
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
name|int
name|indent
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|list
decl_stmt|;
name|do_indent
argument_list|(
name|stream
argument_list|,
name|indent
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|list
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stream
argument_list|,
name|format
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|Dump_UShort_Array
name|Dump_UShort_Array
parameter_list|(
name|HB_UShort
modifier|*
name|array
parameter_list|,
name|int
name|count
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|FILE
modifier|*
name|stream
parameter_list|,
name|int
name|indent
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|do_indent
argument_list|(
name|stream
argument_list|,
name|indent
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"<%s>"
argument_list|,
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%d%s"
argument_list|,
name|array
index|[
name|i
index|]
argument_list|,
name|i
operator|==
literal|0
condition|?
literal|""
else|:
literal|" "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"</%s>\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|Print_Tag
name|Print_Tag
parameter_list|(
name|HB_UInt
name|tag
parameter_list|,
name|FILE
modifier|*
name|stream
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%c%c%c%c"
argument_list|,
call|(
name|unsigned
name|char
call|)
argument_list|(
name|tag
operator|>>
literal|24
argument_list|)
argument_list|,
call|(
name|unsigned
name|char
call|)
argument_list|(
operator|(
name|tag
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|)
argument_list|,
call|(
name|unsigned
name|char
call|)
argument_list|(
operator|(
name|tag
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
argument_list|,
call|(
name|unsigned
name|char
call|)
argument_list|(
name|tag
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_macro
DECL|function|DEF_DUMP
name|DEF_DUMP
argument_list|(
argument|LangSys
argument_list|)
end_macro
begin_block
block|{
name|int
name|i
decl_stmt|;
name|HB_UNUSED
argument_list|(
name|hb_type
argument_list|)
expr_stmt|;
name|DUMP_FUINT
argument_list|(
name|LangSys
argument_list|,
name|LookupOrderOffset
argument_list|)
expr_stmt|;
name|DUMP_FUINT
argument_list|(
name|LangSys
argument_list|,
name|ReqFeatureIndex
argument_list|)
expr_stmt|;
name|DUMP_FUINT
argument_list|(
name|LangSys
argument_list|,
name|FeatureCount
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LangSys
operator|->
name|FeatureCount
condition|;
name|i
operator|++
control|)
name|DUMP1
argument_list|(
literal|"<FeatureIndex>%d</FeatureIndex>\n"
argument_list|,
name|LangSys
operator|->
name|FeatureIndex
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_block
begin_macro
DECL|function|DEF_DUMP
name|DEF_DUMP
argument_list|(
argument|ScriptTable
argument_list|)
end_macro
begin_block
block|{
name|int
name|i
decl_stmt|;
name|RECURSE
argument_list|(
name|DefaultLangSys
argument_list|,
name|LangSys
argument_list|,
operator|&
name|ScriptTable
operator|->
name|DefaultLangSys
argument_list|)
expr_stmt|;
name|DUMP_FUINT
argument_list|(
name|ScriptTable
argument_list|,
name|LangSysCount
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ScriptTable
operator|->
name|LangSysCount
condition|;
name|i
operator|++
control|)
block|{
name|do_indent
argument_list|(
name|stream
argument_list|,
name|indent
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"<LangSysTag>"
argument_list|)
expr_stmt|;
name|Print_Tag
argument_list|(
name|ScriptTable
operator|->
name|LangSysRecord
index|[
name|i
index|]
operator|.
name|LangSysTag
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"</LangSysTag>\n"
argument_list|)
expr_stmt|;
name|RECURSE_NUM
argument_list|(
name|LangSys
argument_list|,
name|i
argument_list|,
name|LangSys
argument_list|,
operator|&
name|ScriptTable
operator|->
name|LangSysRecord
index|[
name|i
index|]
operator|.
name|LangSys
argument_list|)
expr_stmt|;
block|}
block|}
end_block
begin_macro
DECL|function|DEF_DUMP
name|DEF_DUMP
argument_list|(
argument|ScriptList
argument_list|)
end_macro
begin_block
block|{
name|int
name|i
decl_stmt|;
name|DUMP_FUINT
argument_list|(
name|ScriptList
argument_list|,
name|ScriptCount
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ScriptList
operator|->
name|ScriptCount
condition|;
name|i
operator|++
control|)
block|{
name|do_indent
argument_list|(
name|stream
argument_list|,
name|indent
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"<ScriptTag>"
argument_list|)
expr_stmt|;
name|Print_Tag
argument_list|(
name|ScriptList
operator|->
name|ScriptRecord
index|[
name|i
index|]
operator|.
name|ScriptTag
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"</ScriptTag>\n"
argument_list|)
expr_stmt|;
name|RECURSE_NUM
argument_list|(
name|Script
argument_list|,
name|i
argument_list|,
name|ScriptTable
argument_list|,
operator|&
name|ScriptList
operator|->
name|ScriptRecord
index|[
name|i
index|]
operator|.
name|Script
argument_list|)
expr_stmt|;
block|}
block|}
end_block
begin_macro
DECL|function|DEF_DUMP
name|DEF_DUMP
argument_list|(
argument|Feature
argument_list|)
end_macro
begin_block
block|{
name|int
name|i
decl_stmt|;
name|HB_UNUSED
argument_list|(
name|hb_type
argument_list|)
expr_stmt|;
name|DUMP_FUINT
argument_list|(
name|Feature
argument_list|,
name|FeatureParams
argument_list|)
expr_stmt|;
name|DUMP_FUINT
argument_list|(
name|Feature
argument_list|,
name|LookupListCount
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|Feature
operator|->
name|LookupListCount
condition|;
name|i
operator|++
control|)
name|DUMP1
argument_list|(
literal|"<LookupIndex>%d</LookupIndex>\n"
argument_list|,
name|Feature
operator|->
name|LookupListIndex
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_block
begin_macro
DECL|function|DEF_DUMP
name|DEF_DUMP
argument_list|(
argument|MarkRecord
argument_list|)
end_macro
begin_block
block|{
name|HB_UNUSED
argument_list|(
name|hb_type
argument_list|)
expr_stmt|;
name|DUMP_FUINT
argument_list|(
name|MarkRecord
argument_list|,
name|Class
argument_list|)
expr_stmt|;
name|DUMP1
argument_list|(
literal|"<Anchor>%d</Anchor>\n"
argument_list|,
name|MarkRecord
operator|->
name|MarkAnchor
operator|.
name|PosFormat
argument_list|)
expr_stmt|;
block|}
end_block
begin_macro
DECL|function|DEF_DUMP
name|DEF_DUMP
argument_list|(
argument|MarkArray
argument_list|)
end_macro
begin_block
block|{
name|int
name|i
decl_stmt|;
name|DUMP_FUINT
argument_list|(
name|MarkArray
argument_list|,
name|MarkCount
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MarkArray
operator|->
name|MarkCount
condition|;
name|i
operator|++
control|)
name|RECURSE_NUM
argument_list|(
name|MarkRecord
argument_list|,
name|i
argument_list|,
name|MarkRecord
argument_list|,
operator|&
name|MarkArray
operator|->
name|MarkRecord
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_block
begin_macro
DECL|function|DEF_DUMP
name|DEF_DUMP
argument_list|(
argument|FeatureList
argument_list|)
end_macro
begin_block
block|{
name|int
name|i
decl_stmt|;
name|DUMP_FUINT
argument_list|(
name|FeatureList
argument_list|,
name|FeatureCount
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FeatureList
operator|->
name|FeatureCount
condition|;
name|i
operator|++
control|)
block|{
name|do_indent
argument_list|(
name|stream
argument_list|,
name|indent
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"<FeatureTag>"
argument_list|)
expr_stmt|;
name|Print_Tag
argument_list|(
name|FeatureList
operator|->
name|FeatureRecord
index|[
name|i
index|]
operator|.
name|FeatureTag
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"</FeatureTag><!-- %d -->\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|RECURSE_NUM
argument_list|(
name|Feature
argument_list|,
name|i
argument_list|,
name|Feature
argument_list|,
operator|&
name|FeatureList
operator|->
name|FeatureRecord
index|[
name|i
index|]
operator|.
name|Feature
argument_list|)
expr_stmt|;
block|}
block|}
end_block
begin_macro
DECL|function|DEF_DUMP
name|DEF_DUMP
argument_list|(
argument|Coverage
argument_list|)
end_macro
begin_block
block|{
name|HB_UNUSED
argument_list|(
name|hb_type
argument_list|)
expr_stmt|;
name|DUMP_FUINT
argument_list|(
name|Coverage
argument_list|,
name|CoverageFormat
argument_list|)
expr_stmt|;
if|if
condition|(
name|Coverage
operator|->
name|CoverageFormat
operator|==
literal|1
condition|)
block|{
name|int
name|i
decl_stmt|;
name|DUMP_FUINT
argument_list|(
operator|&
name|Coverage
operator|->
name|cf
operator|.
name|cf1
argument_list|,
name|GlyphCount
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|Coverage
operator|->
name|cf
operator|.
name|cf1
operator|.
name|GlyphCount
condition|;
name|i
operator|++
control|)
name|DUMP2
argument_list|(
literal|"<Glyph>%#06x</Glyph><!-- %d -->\n"
argument_list|,
name|Coverage
operator|->
name|cf
operator|.
name|cf1
operator|.
name|GlyphArray
index|[
name|i
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
name|DUMP_FUINT
argument_list|(
operator|&
name|Coverage
operator|->
name|cf
operator|.
name|cf2
argument_list|,
name|RangeCount
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|Coverage
operator|->
name|cf
operator|.
name|cf2
operator|.
name|RangeCount
condition|;
name|i
operator|++
control|)
name|DUMP3
argument_list|(
literal|"<Glyph>%#06x - %#06x</Glyph><!-- %d -->\n"
argument_list|,
name|Coverage
operator|->
name|cf
operator|.
name|cf2
operator|.
name|RangeRecord
index|[
name|i
index|]
operator|.
name|Start
argument_list|,
name|Coverage
operator|->
name|cf
operator|.
name|cf2
operator|.
name|RangeRecord
index|[
name|i
index|]
operator|.
name|End
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_block
begin_macro
DECL|function|DEF_DUMP
name|DEF_DUMP
argument_list|(
argument|ClassRangeRecord
argument_list|)
end_macro
begin_block
block|{
name|HB_UNUSED
argument_list|(
name|hb_type
argument_list|)
expr_stmt|;
name|DUMP_FGLYPH
argument_list|(
name|ClassRangeRecord
argument_list|,
name|Start
argument_list|)
expr_stmt|;
name|DUMP_FGLYPH
argument_list|(
name|ClassRangeRecord
argument_list|,
name|End
argument_list|)
expr_stmt|;
name|DUMP_FUINT
argument_list|(
name|ClassRangeRecord
argument_list|,
name|Class
argument_list|)
expr_stmt|;
block|}
end_block
begin_macro
DECL|function|DEF_DUMP
name|DEF_DUMP
argument_list|(
argument|ClassDefinition
argument_list|)
end_macro
begin_block
block|{
name|HB_UNUSED
argument_list|(
name|hb_type
argument_list|)
expr_stmt|;
name|DUMP_FUINT
argument_list|(
name|ClassDefinition
argument_list|,
name|ClassFormat
argument_list|)
expr_stmt|;
name|DUMP_FUINT
argument_list|(
name|ClassDefinition
argument_list|,
name|loaded
argument_list|)
expr_stmt|;
if|if
condition|(
name|ClassDefinition
operator|->
name|ClassFormat
operator|==
literal|1
condition|)
block|{
name|int
name|i
decl_stmt|;
name|HB_ClassDefFormat1
modifier|*
name|ClassDefFormat1
init|=
operator|&
name|ClassDefinition
operator|->
name|cd
operator|.
name|cd1
decl_stmt|;
name|DUMP
argument_list|(
literal|"<ClassDefinition>\n"
argument_list|)
expr_stmt|;
name|DUMP_FUINT
argument_list|(
name|ClassDefFormat1
argument_list|,
name|StartGlyph
argument_list|)
expr_stmt|;
name|DUMP_FUINT
argument_list|(
name|ClassDefFormat1
argument_list|,
name|GlyphCount
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ClassDefFormat1
operator|->
name|GlyphCount
condition|;
name|i
operator|++
control|)
name|DUMP2
argument_list|(
literal|"<Class>%d</Class><!-- %#06x -->"
argument_list|,
name|ClassDefFormat1
operator|->
name|ClassValueArray
index|[
name|i
index|]
argument_list|,
name|ClassDefFormat1
operator|->
name|StartGlyph
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ClassDefinition
operator|->
name|ClassFormat
operator|==
literal|2
condition|)
block|{
name|int
name|i
decl_stmt|;
name|HB_ClassDefFormat2
modifier|*
name|ClassDefFormat2
init|=
operator|&
name|ClassDefinition
operator|->
name|cd
operator|.
name|cd2
decl_stmt|;
name|DUMP_FUINT
argument_list|(
name|ClassDefFormat2
argument_list|,
name|ClassRangeCount
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ClassDefFormat2
operator|->
name|ClassRangeCount
condition|;
name|i
operator|++
control|)
name|RECURSE_NUM
argument_list|(
name|ClassRangeRecord
argument_list|,
name|i
argument_list|,
name|ClassRangeRecord
argument_list|,
operator|&
name|ClassDefFormat2
operator|->
name|ClassRangeRecord
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"invalid class def table!!!\n"
argument_list|)
expr_stmt|;
block|}
end_block
begin_macro
DECL|function|DEF_DUMP
name|DEF_DUMP
argument_list|(
argument|SubstLookupRecord
argument_list|)
end_macro
begin_block
block|{
name|HB_UNUSED
argument_list|(
name|hb_type
argument_list|)
expr_stmt|;
name|DUMP_FUINT
argument_list|(
name|SubstLookupRecord
argument_list|,
name|SequenceIndex
argument_list|)
expr_stmt|;
name|DUMP_FUINT
argument_list|(
name|SubstLookupRecord
argument_list|,
name|LookupListIndex
argument_list|)
expr_stmt|;
block|}
end_block
begin_macro
DECL|function|DEF_DUMP
name|DEF_DUMP
argument_list|(
argument|ChainSubClassRule
argument_list|)
end_macro
begin_block
block|{
name|int
name|i
decl_stmt|;
name|DUMP_USHORT_ARRAY
argument_list|(
name|ChainSubClassRule
argument_list|,
name|Backtrack
argument_list|,
name|ChainSubClassRule
operator|->
name|BacktrackGlyphCount
argument_list|)
expr_stmt|;
name|DUMP_USHORT_ARRAY
argument_list|(
name|ChainSubClassRule
argument_list|,
name|Input
argument_list|,
name|ChainSubClassRule
operator|->
name|InputGlyphCount
operator|-
literal|1
argument_list|)
expr_stmt|;
name|DUMP_USHORT_ARRAY
argument_list|(
name|ChainSubClassRule
argument_list|,
name|Lookahead
argument_list|,
name|ChainSubClassRule
operator|->
name|LookaheadGlyphCount
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ChainSubClassRule
operator|->
name|SubstCount
condition|;
name|i
operator|++
control|)
name|RECURSE_NUM
argument_list|(
name|SubstLookupRecord
argument_list|,
name|i
argument_list|,
name|SubstLookupRecord
argument_list|,
operator|&
name|ChainSubClassRule
operator|->
name|SubstLookupRecord
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|indent
operator|--
expr_stmt|;
block|}
end_block
begin_macro
DECL|function|DEF_DUMP
name|DEF_DUMP
argument_list|(
argument|ChainSubClassSet
argument_list|)
end_macro
begin_block
block|{
name|int
name|i
decl_stmt|;
name|DUMP_FUINT
argument_list|(
name|ChainSubClassSet
argument_list|,
name|ChainSubClassRuleCount
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ChainSubClassSet
operator|->
name|ChainSubClassRuleCount
condition|;
name|i
operator|++
control|)
name|RECURSE_NUM
argument_list|(
name|ChainSubClassRule
argument_list|,
name|i
argument_list|,
name|ChainSubClassRule
argument_list|,
operator|&
name|ChainSubClassSet
operator|->
name|ChainSubClassRule
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_block
begin_function
specifier|static
name|void
DECL|function|Dump_GSUB_Lookup_Single
name|Dump_GSUB_Lookup_Single
parameter_list|(
name|HB_SubTable
modifier|*
name|subtable
parameter_list|,
name|FILE
modifier|*
name|stream
parameter_list|,
name|int
name|indent
parameter_list|,
name|HB_Type
name|hb_type
parameter_list|)
block|{
name|HB_SingleSubst
modifier|*
name|SingleSubst
init|=
operator|&
name|subtable
operator|->
name|st
operator|.
name|gsub
operator|.
name|single
decl_stmt|;
name|DUMP_FUINT
argument_list|(
name|SingleSubst
argument_list|,
name|SubstFormat
argument_list|)
expr_stmt|;
name|RECURSE
argument_list|(
name|Coverage
argument_list|,
name|Coverage
argument_list|,
operator|&
name|SingleSubst
operator|->
name|Coverage
argument_list|)
expr_stmt|;
if|if
condition|(
name|SingleSubst
operator|->
name|SubstFormat
operator|==
literal|1
condition|)
block|{
name|DUMP_FINT
argument_list|(
operator|&
name|SingleSubst
operator|->
name|ssf
operator|.
name|ssf1
argument_list|,
name|DeltaGlyphID
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
name|DUMP_FINT
argument_list|(
operator|&
name|SingleSubst
operator|->
name|ssf
operator|.
name|ssf2
argument_list|,
name|GlyphCount
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SingleSubst
operator|->
name|ssf
operator|.
name|ssf2
operator|.
name|GlyphCount
condition|;
name|i
operator|++
control|)
name|DUMP2
argument_list|(
literal|"<Substitute>%#06x</Substitute><!-- %d -->\n"
argument_list|,
name|SingleSubst
operator|->
name|ssf
operator|.
name|ssf2
operator|.
name|Substitute
index|[
name|i
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_macro
DECL|function|DEF_DUMP
name|DEF_DUMP
argument_list|(
argument|Ligature
argument_list|)
end_macro
begin_block
block|{
name|int
name|i
decl_stmt|;
name|HB_UNUSED
argument_list|(
name|hb_type
argument_list|)
expr_stmt|;
name|DUMP_FGLYPH
argument_list|(
name|Ligature
argument_list|,
name|LigGlyph
argument_list|)
expr_stmt|;
name|DUMP_FUINT
argument_list|(
name|Ligature
argument_list|,
name|ComponentCount
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|Ligature
operator|->
name|ComponentCount
operator|-
literal|1
condition|;
name|i
operator|++
control|)
name|DUMP1
argument_list|(
literal|"<Component>%#06x</Component>\n"
argument_list|,
name|Ligature
operator|->
name|Component
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_block
begin_macro
DECL|function|DEF_DUMP
name|DEF_DUMP
argument_list|(
argument|LigatureSet
argument_list|)
end_macro
begin_block
block|{
name|int
name|i
decl_stmt|;
name|DUMP_FUINT
argument_list|(
name|LigatureSet
argument_list|,
name|LigatureCount
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LigatureSet
operator|->
name|LigatureCount
condition|;
name|i
operator|++
control|)
name|RECURSE_NUM
argument_list|(
name|Ligature
argument_list|,
name|i
argument_list|,
name|Ligature
argument_list|,
operator|&
name|LigatureSet
operator|->
name|Ligature
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_block
begin_function
specifier|static
name|void
DECL|function|Dump_GSUB_Lookup_Ligature
name|Dump_GSUB_Lookup_Ligature
parameter_list|(
name|HB_SubTable
modifier|*
name|subtable
parameter_list|,
name|FILE
modifier|*
name|stream
parameter_list|,
name|int
name|indent
parameter_list|,
name|HB_Type
name|hb_type
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|HB_LigatureSubst
modifier|*
name|LigatureSubst
init|=
operator|&
name|subtable
operator|->
name|st
operator|.
name|gsub
operator|.
name|ligature
decl_stmt|;
name|DUMP_FUINT
argument_list|(
name|LigatureSubst
argument_list|,
name|SubstFormat
argument_list|)
expr_stmt|;
name|RECURSE
argument_list|(
name|Coverage
argument_list|,
name|Coverage
argument_list|,
operator|&
name|LigatureSubst
operator|->
name|Coverage
argument_list|)
expr_stmt|;
name|DUMP_FUINT
argument_list|(
name|LigatureSubst
argument_list|,
name|LigatureSetCount
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LigatureSubst
operator|->
name|LigatureSetCount
condition|;
name|i
operator|++
control|)
name|RECURSE_NUM
argument_list|(
name|LigatureSet
argument_list|,
name|i
argument_list|,
name|LigatureSet
argument_list|,
operator|&
name|LigatureSubst
operator|->
name|LigatureSet
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function
begin_macro
DECL|function|DEF_DUMP
name|DEF_DUMP
argument_list|(
argument|ContextSubstFormat1
argument_list|)
end_macro
begin_block
block|{
name|HB_UNUSED
argument_list|(
name|hb_type
argument_list|)
expr_stmt|;
name|HB_UNUSED
argument_list|(
name|ContextSubstFormat1
argument_list|)
expr_stmt|;
name|DUMP
argument_list|(
literal|"<!-- Not implemented!!! -->\n"
argument_list|)
expr_stmt|;
block|}
end_block
begin_macro
DECL|function|DEF_DUMP
name|DEF_DUMP
argument_list|(
argument|ContextSubstFormat2
argument_list|)
end_macro
begin_block
block|{
name|DUMP_FUINT
argument_list|(
name|ContextSubstFormat2
argument_list|,
name|MaxContextLength
argument_list|)
expr_stmt|;
name|RECURSE
argument_list|(
name|Coverage
argument_list|,
name|Coverage
argument_list|,
operator|&
name|ContextSubstFormat2
operator|->
name|Coverage
argument_list|)
expr_stmt|;
name|RECURSE
argument_list|(
name|ClassDefinition
argument_list|,
name|ClassDefinition
argument_list|,
operator|&
name|ContextSubstFormat2
operator|->
name|ClassDef
argument_list|)
expr_stmt|;
block|}
end_block
begin_macro
DECL|function|DEF_DUMP
name|DEF_DUMP
argument_list|(
argument|ContextSubstFormat3
argument_list|)
end_macro
begin_block
block|{
name|HB_UNUSED
argument_list|(
name|hb_type
argument_list|)
expr_stmt|;
name|HB_UNUSED
argument_list|(
name|ContextSubstFormat3
argument_list|)
expr_stmt|;
name|DUMP
argument_list|(
literal|"<!-- Not implemented!!! -->\n"
argument_list|)
expr_stmt|;
block|}
end_block
begin_function
specifier|static
name|void
DECL|function|Dump_GSUB_Lookup_Context
name|Dump_GSUB_Lookup_Context
parameter_list|(
name|HB_SubTable
modifier|*
name|subtable
parameter_list|,
name|FILE
modifier|*
name|stream
parameter_list|,
name|int
name|indent
parameter_list|,
name|HB_Type
name|hb_type
parameter_list|)
block|{
name|HB_ContextSubst
modifier|*
name|ContextSubst
init|=
operator|&
name|subtable
operator|->
name|st
operator|.
name|gsub
operator|.
name|context
decl_stmt|;
name|DUMP_FUINT
argument_list|(
name|ContextSubst
argument_list|,
name|SubstFormat
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ContextSubst
operator|->
name|SubstFormat
condition|)
block|{
case|case
literal|1
case|:
name|Dump_ContextSubstFormat1
argument_list|(
operator|&
name|ContextSubst
operator|->
name|csf
operator|.
name|csf1
argument_list|,
name|stream
argument_list|,
name|indent
operator|+
literal|2
argument_list|,
name|hb_type
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|Dump_ContextSubstFormat2
argument_list|(
operator|&
name|ContextSubst
operator|->
name|csf
operator|.
name|csf2
argument_list|,
name|stream
argument_list|,
name|indent
operator|+
literal|2
argument_list|,
name|hb_type
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|Dump_ContextSubstFormat3
argument_list|(
operator|&
name|ContextSubst
operator|->
name|csf
operator|.
name|csf3
argument_list|,
name|stream
argument_list|,
name|indent
operator|+
literal|2
argument_list|,
name|hb_type
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"invalid subformat!!!!!\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_macro
DECL|function|DEF_DUMP
name|DEF_DUMP
argument_list|(
argument|ChainContextSubstFormat1
argument_list|)
end_macro
begin_block
block|{
name|HB_UNUSED
argument_list|(
name|hb_type
argument_list|)
expr_stmt|;
name|HB_UNUSED
argument_list|(
name|ChainContextSubstFormat1
argument_list|)
expr_stmt|;
name|DUMP
argument_list|(
literal|"<!-- Not implemented!!! -->\n"
argument_list|)
expr_stmt|;
block|}
end_block
begin_macro
DECL|function|DEF_DUMP
name|DEF_DUMP
argument_list|(
argument|ChainContextSubstFormat2
argument_list|)
end_macro
begin_block
block|{
name|int
name|i
decl_stmt|;
name|RECURSE
argument_list|(
name|Coverage
argument_list|,
name|Coverage
argument_list|,
operator|&
name|ChainContextSubstFormat2
operator|->
name|Coverage
argument_list|)
expr_stmt|;
name|DUMP_FUINT
argument_list|(
name|ChainContextSubstFormat2
argument_list|,
name|MaxBacktrackLength
argument_list|)
expr_stmt|;
name|RECURSE
argument_list|(
name|ClassDefinition
argument_list|,
name|ClassDefinition
argument_list|,
operator|&
name|ChainContextSubstFormat2
operator|->
name|BacktrackClassDef
argument_list|)
expr_stmt|;
name|DUMP_FUINT
argument_list|(
name|ChainContextSubstFormat2
argument_list|,
name|MaxInputLength
argument_list|)
expr_stmt|;
name|RECURSE
argument_list|(
name|ClassDefinition
argument_list|,
name|ClassDefinition
argument_list|,
operator|&
name|ChainContextSubstFormat2
operator|->
name|InputClassDef
argument_list|)
expr_stmt|;
name|DUMP_FUINT
argument_list|(
name|ChainContextSubstFormat2
argument_list|,
name|MaxLookaheadLength
argument_list|)
expr_stmt|;
name|RECURSE
argument_list|(
name|ClassDefinition
argument_list|,
name|ClassDefinition
argument_list|,
operator|&
name|ChainContextSubstFormat2
operator|->
name|LookaheadClassDef
argument_list|)
expr_stmt|;
name|DUMP_FUINT
argument_list|(
name|ChainContextSubstFormat2
argument_list|,
name|ChainSubClassSetCount
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ChainContextSubstFormat2
operator|->
name|ChainSubClassSetCount
condition|;
name|i
operator|++
control|)
name|RECURSE
argument_list|(
name|ChainSubClassSet
argument_list|,
name|ChainSubClassSet
argument_list|,
operator|&
name|ChainContextSubstFormat2
operator|->
name|ChainSubClassSet
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_block
begin_macro
DECL|function|DEF_DUMP
name|DEF_DUMP
argument_list|(
argument|ChainContextSubstFormat3
argument_list|)
end_macro
begin_block
block|{
name|int
name|i
decl_stmt|;
name|DUMP_FUINT
argument_list|(
name|ChainContextSubstFormat3
argument_list|,
name|BacktrackGlyphCount
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ChainContextSubstFormat3
operator|->
name|BacktrackGlyphCount
condition|;
name|i
operator|++
control|)
name|RECURSE
argument_list|(
name|BacktrackCoverage
argument_list|,
name|Coverage
argument_list|,
operator|&
name|ChainContextSubstFormat3
operator|->
name|BacktrackCoverage
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|DUMP_FUINT
argument_list|(
name|ChainContextSubstFormat3
argument_list|,
name|InputGlyphCount
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ChainContextSubstFormat3
operator|->
name|InputGlyphCount
condition|;
name|i
operator|++
control|)
name|RECURSE
argument_list|(
name|InputCoverage
argument_list|,
name|Coverage
argument_list|,
operator|&
name|ChainContextSubstFormat3
operator|->
name|InputCoverage
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|DUMP_FUINT
argument_list|(
name|ChainContextSubstFormat3
argument_list|,
name|LookaheadGlyphCount
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ChainContextSubstFormat3
operator|->
name|LookaheadGlyphCount
condition|;
name|i
operator|++
control|)
name|RECURSE
argument_list|(
name|LookaheadCoverage
argument_list|,
name|Coverage
argument_list|,
operator|&
name|ChainContextSubstFormat3
operator|->
name|LookaheadCoverage
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ChainContextSubstFormat3
operator|->
name|SubstCount
condition|;
name|i
operator|++
control|)
name|RECURSE_NUM
argument_list|(
name|SubstLookupRecord
argument_list|,
name|i
argument_list|,
name|SubstLookupRecord
argument_list|,
operator|&
name|ChainContextSubstFormat3
operator|->
name|SubstLookupRecord
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_block
begin_function
specifier|static
name|void
DECL|function|Dump_GSUB_Lookup_Chain
name|Dump_GSUB_Lookup_Chain
parameter_list|(
name|HB_SubTable
modifier|*
name|subtable
parameter_list|,
name|FILE
modifier|*
name|stream
parameter_list|,
name|int
name|indent
parameter_list|,
name|HB_Type
name|hb_type
parameter_list|)
block|{
name|HB_ChainContextSubst
modifier|*
name|chain
init|=
operator|&
name|subtable
operator|->
name|st
operator|.
name|gsub
operator|.
name|chain
decl_stmt|;
name|DUMP_FUINT
argument_list|(
name|chain
argument_list|,
name|SubstFormat
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|chain
operator|->
name|SubstFormat
condition|)
block|{
case|case
literal|1
case|:
name|Dump_ChainContextSubstFormat1
argument_list|(
operator|&
name|chain
operator|->
name|ccsf
operator|.
name|ccsf1
argument_list|,
name|stream
argument_list|,
name|indent
operator|+
literal|2
argument_list|,
name|hb_type
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|Dump_ChainContextSubstFormat2
argument_list|(
operator|&
name|chain
operator|->
name|ccsf
operator|.
name|ccsf2
argument_list|,
name|stream
argument_list|,
name|indent
operator|+
literal|2
argument_list|,
name|hb_type
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|Dump_ChainContextSubstFormat3
argument_list|(
operator|&
name|chain
operator|->
name|ccsf
operator|.
name|ccsf3
argument_list|,
name|stream
argument_list|,
name|indent
operator|+
literal|2
argument_list|,
name|hb_type
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"invalid subformat!!!!!\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|Dump_Device
name|Dump_Device
parameter_list|(
name|HB_Device
modifier|*
name|Device
parameter_list|,
name|FILE
modifier|*
name|stream
parameter_list|,
name|int
name|indent
parameter_list|,
name|HB_Type
name|hb_type
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|bits
decl_stmt|;
name|int
name|n_per
decl_stmt|;
name|unsigned
name|int
name|mask
decl_stmt|;
name|HB_UNUSED
argument_list|(
name|hb_type
argument_list|)
expr_stmt|;
name|DUMP_FUINT
argument_list|(
name|Device
argument_list|,
name|StartSize
argument_list|)
expr_stmt|;
name|DUMP_FUINT
argument_list|(
name|Device
argument_list|,
name|EndSize
argument_list|)
expr_stmt|;
name|DUMP_FUINT
argument_list|(
name|Device
argument_list|,
name|DeltaFormat
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|Device
operator|->
name|DeltaFormat
condition|)
block|{
case|case
literal|1
case|:
name|bits
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|bits
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|bits
operator|=
literal|8
expr_stmt|;
break|break;
default|default:
name|bits
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|DUMP
argument_list|(
literal|"<DeltaValue>"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bits
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"invalid DeltaFormat!!!!!\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|n_per
operator|=
literal|16
operator|/
name|bits
expr_stmt|;
name|mask
operator|=
operator|(
literal|1
operator|<<
name|bits
operator|)
operator|-
literal|1
expr_stmt|;
name|mask
operator|=
name|mask
operator|<<
operator|(
literal|16
operator|-
name|bits
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|Device
operator|->
name|StartSize
init|;
name|i
operator|<=
name|Device
operator|->
name|EndSize
condition|;
name|i
operator|++
control|)
block|{
name|HB_UShort
name|val
init|=
name|Device
operator|->
name|DeltaValue
index|[
name|i
operator|/
name|n_per
index|]
decl_stmt|;
name|HB_Short
name|signed_val
init|=
operator|(
operator|(
name|val
operator|<<
operator|(
operator|(
name|i
operator|%
name|n_per
operator|)
operator|*
name|bits
operator|)
operator|)
operator|&
name|mask
operator|)
decl_stmt|;
name|dump
argument_list|(
name|stream
argument_list|,
name|indent
argument_list|,
literal|"%d"
argument_list|,
name|signed_val
operator|>>
operator|(
literal|16
operator|-
name|bits
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|Device
operator|->
name|EndSize
condition|)
name|DUMP
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
block|}
name|DUMP
argument_list|(
literal|"</DeltaValue>\n"
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|Dump_ValueRecord
name|Dump_ValueRecord
parameter_list|(
name|HB_ValueRecord
modifier|*
name|ValueRecord
parameter_list|,
name|FILE
modifier|*
name|stream
parameter_list|,
name|int
name|indent
parameter_list|,
name|HB_Type
name|hb_type
parameter_list|,
name|HB_UShort
name|value_format
parameter_list|)
block|{
if|if
condition|(
name|value_format
operator|&
name|HB_GPOS_FORMAT_HAVE_X_PLACEMENT
condition|)
name|DUMP_FINT
argument_list|(
name|ValueRecord
argument_list|,
name|XPlacement
argument_list|)
expr_stmt|;
if|if
condition|(
name|value_format
operator|&
name|HB_GPOS_FORMAT_HAVE_Y_PLACEMENT
condition|)
name|DUMP_FINT
argument_list|(
name|ValueRecord
argument_list|,
name|YPlacement
argument_list|)
expr_stmt|;
if|if
condition|(
name|value_format
operator|&
name|HB_GPOS_FORMAT_HAVE_X_ADVANCE
condition|)
name|DUMP_FINT
argument_list|(
name|ValueRecord
argument_list|,
name|XAdvance
argument_list|)
expr_stmt|;
if|if
condition|(
name|value_format
operator|&
name|HB_GPOS_FORMAT_HAVE_Y_ADVANCE
condition|)
name|DUMP_FINT
argument_list|(
name|ValueRecord
argument_list|,
name|XAdvance
argument_list|)
expr_stmt|;
if|if
condition|(
name|value_format
operator|&
name|HB_GPOS_FORMAT_HAVE_X_PLACEMENT_DEVICE
condition|)
name|RECURSE
argument_list|(
name|Device
argument_list|,
name|Device
argument_list|,
operator|&
operator|*
name|ValueRecord
operator|->
name|DeviceTables
index|[
name|VR_X_PLACEMENT_DEVICE
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|value_format
operator|&
name|HB_GPOS_FORMAT_HAVE_Y_PLACEMENT_DEVICE
condition|)
name|RECURSE
argument_list|(
name|Device
argument_list|,
name|Device
argument_list|,
operator|&
operator|*
name|ValueRecord
operator|->
name|DeviceTables
index|[
name|VR_Y_PLACEMENT_DEVICE
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|value_format
operator|&
name|HB_GPOS_FORMAT_HAVE_X_ADVANCE_DEVICE
condition|)
name|RECURSE
argument_list|(
name|Device
argument_list|,
name|Device
argument_list|,
operator|&
operator|*
name|ValueRecord
operator|->
name|DeviceTables
index|[
name|VR_X_ADVANCE_DEVICE
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|value_format
operator|&
name|HB_GPOS_FORMAT_HAVE_Y_ADVANCE_DEVICE
condition|)
name|RECURSE
argument_list|(
name|Device
argument_list|,
name|Device
argument_list|,
operator|&
operator|*
name|ValueRecord
operator|->
name|DeviceTables
index|[
name|VR_Y_ADVANCE_DEVICE
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HB_SUPPORT_MULTIPLE_MASTER
if|if
condition|(
name|value_format
operator|&
name|HB_GPOS_FORMAT_HAVE_X_ID_PLACEMENT
condition|)
name|DUMP_FUINT
argument_list|(
name|ValueRecord
argument_list|,
name|XIdPlacement
argument_list|)
expr_stmt|;
if|if
condition|(
name|value_format
operator|&
name|HB_GPOS_FORMAT_HAVE_Y_ID_PLACEMENT
condition|)
name|DUMP_FUINT
argument_list|(
name|ValueRecord
argument_list|,
name|YIdPlacement
argument_list|)
expr_stmt|;
if|if
condition|(
name|value_format
operator|&
name|HB_GPOS_FORMAT_HAVE_X_ID_ADVANCE
condition|)
name|DUMP_FUINT
argument_list|(
name|ValueRecord
argument_list|,
name|XIdAdvance
argument_list|)
expr_stmt|;
if|if
condition|(
name|value_format
operator|&
name|HB_GPOS_FORMAT_HAVE_Y_ID_ADVANCE
condition|)
name|DUMP_FUINT
argument_list|(
name|ValueRecord
argument_list|,
name|XIdAdvance
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|Dump_GPOS_Lookup_Single
name|Dump_GPOS_Lookup_Single
parameter_list|(
name|HB_SubTable
modifier|*
name|subtable
parameter_list|,
name|FILE
modifier|*
name|stream
parameter_list|,
name|int
name|indent
parameter_list|,
name|HB_Type
name|hb_type
parameter_list|)
block|{
name|HB_SinglePos
modifier|*
name|SinglePos
init|=
operator|&
name|subtable
operator|->
name|st
operator|.
name|gpos
operator|.
name|single
decl_stmt|;
name|DUMP_FUINT
argument_list|(
name|SinglePos
argument_list|,
name|PosFormat
argument_list|)
expr_stmt|;
name|RECURSE
argument_list|(
name|Coverage
argument_list|,
name|Coverage
argument_list|,
operator|&
name|SinglePos
operator|->
name|Coverage
argument_list|)
expr_stmt|;
name|DUMP_FUINT
argument_list|(
name|SinglePos
argument_list|,
name|ValueFormat
argument_list|)
expr_stmt|;
if|if
condition|(
name|SinglePos
operator|->
name|PosFormat
operator|==
literal|1
condition|)
block|{
name|DUMP_VALUE_RECORD
argument_list|(
operator|&
name|SinglePos
operator|->
name|spf
operator|.
name|spf1
operator|.
name|Value
argument_list|,
name|SinglePos
operator|->
name|ValueFormat
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
name|DUMP_FUINT
argument_list|(
operator|&
name|SinglePos
operator|->
name|spf
operator|.
name|spf2
argument_list|,
name|ValueCount
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SinglePos
operator|->
name|spf
operator|.
name|spf2
operator|.
name|ValueCount
condition|;
name|i
operator|++
control|)
name|DUMP_VALUE_RECORD
argument_list|(
operator|&
name|SinglePos
operator|->
name|spf
operator|.
name|spf2
operator|.
name|Value
index|[
name|i
index|]
argument_list|,
name|SinglePos
operator|->
name|ValueFormat
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|Dump_PairValueRecord
name|Dump_PairValueRecord
parameter_list|(
name|HB_PairValueRecord
modifier|*
name|PairValueRecord
parameter_list|,
name|FILE
modifier|*
name|stream
parameter_list|,
name|int
name|indent
parameter_list|,
name|HB_Type
name|hb_type
parameter_list|,
name|HB_UShort
name|ValueFormat1
parameter_list|,
name|HB_UShort
name|ValueFormat2
parameter_list|)
block|{
name|DUMP_FUINT
argument_list|(
name|PairValueRecord
argument_list|,
name|SecondGlyph
argument_list|)
expr_stmt|;
name|DUMP_VALUE_RECORD
argument_list|(
operator|&
name|PairValueRecord
operator|->
name|Value1
argument_list|,
name|ValueFormat1
argument_list|)
expr_stmt|;
name|DUMP_VALUE_RECORD
argument_list|(
operator|&
name|PairValueRecord
operator|->
name|Value2
argument_list|,
name|ValueFormat2
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|Dump_PairSet
name|Dump_PairSet
parameter_list|(
name|HB_PairSet
modifier|*
name|PairSet
parameter_list|,
name|FILE
modifier|*
name|stream
parameter_list|,
name|int
name|indent
parameter_list|,
name|HB_Type
name|hb_type
parameter_list|,
name|HB_UShort
name|ValueFormat1
parameter_list|,
name|HB_UShort
name|ValueFormat2
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|DUMP_FUINT
argument_list|(
name|PairSet
argument_list|,
name|PairValueCount
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PairSet
operator|->
name|PairValueCount
condition|;
name|i
operator|++
control|)
block|{
name|DUMP
argument_list|(
literal|"<PairValueRecord>\n"
argument_list|)
expr_stmt|;
name|Dump_PairValueRecord
argument_list|(
operator|&
name|PairSet
operator|->
name|PairValueRecord
index|[
name|i
index|]
argument_list|,
name|stream
argument_list|,
name|indent
operator|+
literal|1
argument_list|,
name|hb_type
argument_list|,
name|ValueFormat1
argument_list|,
name|ValueFormat2
argument_list|)
expr_stmt|;
name|DUMP
argument_list|(
literal|"</PairValueRecord>\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|Dump_GPOS_Lookup_Pair
name|Dump_GPOS_Lookup_Pair
parameter_list|(
name|HB_SubTable
modifier|*
name|subtable
parameter_list|,
name|FILE
modifier|*
name|stream
parameter_list|,
name|int
name|indent
parameter_list|,
name|HB_Type
name|hb_type
parameter_list|)
block|{
name|HB_PairPos
modifier|*
name|PairPos
init|=
operator|&
name|subtable
operator|->
name|st
operator|.
name|gpos
operator|.
name|pair
decl_stmt|;
name|DUMP_FUINT
argument_list|(
name|PairPos
argument_list|,
name|PosFormat
argument_list|)
expr_stmt|;
name|RECURSE
argument_list|(
name|Coverage
argument_list|,
name|Coverage
argument_list|,
operator|&
name|PairPos
operator|->
name|Coverage
argument_list|)
expr_stmt|;
name|DUMP_FUINT
argument_list|(
name|PairPos
argument_list|,
name|ValueFormat1
argument_list|)
expr_stmt|;
name|DUMP_FUINT
argument_list|(
name|PairPos
argument_list|,
name|ValueFormat2
argument_list|)
expr_stmt|;
if|if
condition|(
name|PairPos
operator|->
name|PosFormat
operator|==
literal|1
condition|)
block|{
name|int
name|i
decl_stmt|;
name|DUMP_FUINT
argument_list|(
operator|&
name|PairPos
operator|->
name|ppf
operator|.
name|ppf1
argument_list|,
name|PairSetCount
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PairPos
operator|->
name|ppf
operator|.
name|ppf1
operator|.
name|PairSetCount
condition|;
name|i
operator|++
control|)
block|{
name|DUMP
argument_list|(
literal|"<PairSet>\n"
argument_list|)
expr_stmt|;
name|Dump_PairSet
argument_list|(
operator|&
name|PairPos
operator|->
name|ppf
operator|.
name|ppf1
operator|.
name|PairSet
index|[
name|i
index|]
argument_list|,
name|stream
argument_list|,
name|indent
operator|+
literal|1
argument_list|,
name|hb_type
argument_list|,
name|PairPos
operator|->
name|ValueFormat1
argument_list|,
name|PairPos
operator|->
name|ValueFormat2
argument_list|)
expr_stmt|;
name|DUMP
argument_list|(
literal|"</PairSet>\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{     }
block|}
end_function
begin_function
specifier|static
name|void
DECL|function|Dump_GPOS_Lookup_Markbase
name|Dump_GPOS_Lookup_Markbase
parameter_list|(
name|HB_SubTable
modifier|*
name|subtable
parameter_list|,
name|FILE
modifier|*
name|stream
parameter_list|,
name|int
name|indent
parameter_list|,
name|HB_Type
name|hb_type
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|HB_MarkBasePos
modifier|*
name|markbase
init|=
operator|&
name|subtable
operator|->
name|st
operator|.
name|gpos
operator|.
name|markbase
decl_stmt|;
name|DUMP_FUINT
argument_list|(
name|markbase
argument_list|,
name|PosFormat
argument_list|)
expr_stmt|;
name|RECURSE
argument_list|(
name|Coverage
argument_list|,
name|Coverage
argument_list|,
operator|&
name|markbase
operator|->
name|MarkCoverage
argument_list|)
expr_stmt|;
name|RECURSE
argument_list|(
name|Coverage
argument_list|,
name|Coverage
argument_list|,
operator|&
name|markbase
operator|->
name|BaseCoverage
argument_list|)
expr_stmt|;
name|DUMP_FUINT
argument_list|(
name|markbase
argument_list|,
name|ClassCount
argument_list|)
expr_stmt|;
name|RECURSE
argument_list|(
name|MarkArray
argument_list|,
name|MarkArray
argument_list|,
operator|&
name|markbase
operator|->
name|MarkArray
argument_list|)
expr_stmt|;
name|DUMP
argument_list|(
literal|"<BaseArray>\n"
argument_list|)
expr_stmt|;
name|indent
operator|++
expr_stmt|;
name|DUMP_FUINT
argument_list|(
operator|&
name|markbase
operator|->
name|BaseArray
argument_list|,
name|BaseCount
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|markbase
operator|->
name|BaseArray
operator|.
name|BaseCount
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
decl_stmt|;
name|HB_BaseRecord
modifier|*
name|r
init|=
operator|&
name|markbase
operator|->
name|BaseArray
operator|.
name|BaseRecord
index|[
name|i
index|]
decl_stmt|;
name|DUMP1
argument_list|(
literal|"<BaseRecord><!-- %d -->\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|markbase
operator|->
name|ClassCount
condition|;
name|j
operator|++
control|)
name|DUMP1
argument_list|(
literal|"<Anchor>%d</Anchor>\n"
argument_list|,
name|r
operator|->
name|BaseAnchor
operator|->
name|PosFormat
argument_list|)
expr_stmt|;
name|DUMP
argument_list|(
literal|"<BaseRecord>\n"
argument_list|)
expr_stmt|;
block|}
name|indent
operator|--
expr_stmt|;
name|DUMP
argument_list|(
literal|"</BaseArray>\n"
argument_list|)
expr_stmt|;
block|}
end_function
begin_macro
DECL|function|DEF_DUMP
name|DEF_DUMP
argument_list|(
argument|Lookup
argument_list|)
end_macro
begin_block
block|{
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|lookup_name
decl_stmt|;
name|void
function_decl|(
modifier|*
name|lookup_func
function_decl|)
parameter_list|(
name|HB_SubTable
modifier|*
name|subtable
parameter_list|,
name|FILE
modifier|*
name|stream
parameter_list|,
name|int
name|indent
parameter_list|,
name|HB_Type
name|hb_type
parameter_list|)
init|=
name|NULL
function_decl|;
if|if
condition|(
name|hb_type
operator|==
name|HB_Type_GSUB
condition|)
block|{
switch|switch
condition|(
name|Lookup
operator|->
name|LookupType
condition|)
block|{
case|case
name|HB_GSUB_LOOKUP_SINGLE
case|:
name|lookup_name
operator|=
literal|"SINGLE"
expr_stmt|;
name|lookup_func
operator|=
name|Dump_GSUB_Lookup_Single
expr_stmt|;
break|break;
case|case
name|HB_GSUB_LOOKUP_MULTIPLE
case|:
name|lookup_name
operator|=
literal|"MULTIPLE"
expr_stmt|;
break|break;
case|case
name|HB_GSUB_LOOKUP_ALTERNATE
case|:
name|lookup_name
operator|=
literal|"ALTERNATE"
expr_stmt|;
break|break;
case|case
name|HB_GSUB_LOOKUP_LIGATURE
case|:
name|lookup_name
operator|=
literal|"LIGATURE"
expr_stmt|;
name|lookup_func
operator|=
name|Dump_GSUB_Lookup_Ligature
expr_stmt|;
break|break;
case|case
name|HB_GSUB_LOOKUP_CONTEXT
case|:
name|lookup_name
operator|=
literal|"CONTEXT"
expr_stmt|;
name|lookup_func
operator|=
name|Dump_GSUB_Lookup_Context
expr_stmt|;
break|break;
case|case
name|HB_GSUB_LOOKUP_CHAIN
case|:
name|lookup_name
operator|=
literal|"CHAIN"
expr_stmt|;
name|lookup_func
operator|=
name|Dump_GSUB_Lookup_Chain
expr_stmt|;
break|break;
default|default:
name|lookup_name
operator|=
literal|"(unknown)"
expr_stmt|;
name|lookup_func
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|Lookup
operator|->
name|LookupType
condition|)
block|{
case|case
name|HB_GPOS_LOOKUP_SINGLE
case|:
name|lookup_name
operator|=
literal|"SINGLE"
expr_stmt|;
name|lookup_func
operator|=
name|Dump_GPOS_Lookup_Single
expr_stmt|;
break|break;
case|case
name|HB_GPOS_LOOKUP_PAIR
case|:
name|lookup_name
operator|=
literal|"PAIR"
expr_stmt|;
name|lookup_func
operator|=
name|Dump_GPOS_Lookup_Pair
expr_stmt|;
break|break;
case|case
name|HB_GPOS_LOOKUP_CURSIVE
case|:
name|lookup_name
operator|=
literal|"CURSIVE"
expr_stmt|;
break|break;
case|case
name|HB_GPOS_LOOKUP_MARKBASE
case|:
name|lookup_name
operator|=
literal|"MARKBASE"
expr_stmt|;
name|lookup_func
operator|=
name|Dump_GPOS_Lookup_Markbase
expr_stmt|;
break|break;
case|case
name|HB_GPOS_LOOKUP_MARKLIG
case|:
name|lookup_name
operator|=
literal|"MARKLIG"
expr_stmt|;
break|break;
case|case
name|HB_GPOS_LOOKUP_MARKMARK
case|:
name|lookup_name
operator|=
literal|"MARKMARK"
expr_stmt|;
break|break;
case|case
name|HB_GPOS_LOOKUP_CONTEXT
case|:
name|lookup_name
operator|=
literal|"CONTEXT"
expr_stmt|;
break|break;
case|case
name|HB_GPOS_LOOKUP_CHAIN
case|:
name|lookup_name
operator|=
literal|"CHAIN"
expr_stmt|;
break|break;
default|default:
name|lookup_name
operator|=
literal|"(unknown)"
expr_stmt|;
name|lookup_func
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
block|}
name|DUMP2
argument_list|(
literal|"<LookupType>%s</LookupType><!-- %d -->\n"
argument_list|,
name|lookup_name
argument_list|,
name|Lookup
operator|->
name|LookupType
argument_list|)
expr_stmt|;
name|DUMP1
argument_list|(
literal|"<LookupFlag>%#06x</LookupFlag>\n"
argument_list|,
name|Lookup
operator|->
name|LookupFlag
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|Lookup
operator|->
name|SubTableCount
condition|;
name|i
operator|++
control|)
block|{
name|DUMP
argument_list|(
literal|"<Subtable>\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lookup_func
condition|)
call|(
modifier|*
name|lookup_func
call|)
argument_list|(
operator|&
name|Lookup
operator|->
name|SubTable
index|[
name|i
index|]
argument_list|,
name|stream
argument_list|,
name|indent
operator|+
literal|1
argument_list|,
name|hb_type
argument_list|)
expr_stmt|;
name|DUMP
argument_list|(
literal|"</Subtable>\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_block
begin_macro
DECL|function|DEF_DUMP
name|DEF_DUMP
argument_list|(
argument|LookupList
argument_list|)
end_macro
begin_block
block|{
name|int
name|i
decl_stmt|;
name|DUMP_FUINT
argument_list|(
name|LookupList
argument_list|,
name|LookupCount
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LookupList
operator|->
name|LookupCount
condition|;
name|i
operator|++
control|)
name|RECURSE_NUM
argument_list|(
name|Lookup
argument_list|,
name|i
argument_list|,
name|Lookup
argument_list|,
operator|&
name|LookupList
operator|->
name|Lookup
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_block
begin_function
name|void
DECL|function|HB_Dump_GSUB_Table
name|HB_Dump_GSUB_Table
parameter_list|(
name|HB_GSUB
name|gsub
parameter_list|,
name|FILE
modifier|*
name|stream
parameter_list|)
block|{
name|int
name|indent
init|=
literal|1
decl_stmt|;
name|HB_Type
name|hb_type
init|=
name|HB_Type_GSUB
decl_stmt|;
name|do_indent
argument_list|(
name|stream
argument_list|,
name|indent
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"<!-- GSUB -->\n"
argument_list|)
expr_stmt|;
name|RECURSE
argument_list|(
name|ScriptList
argument_list|,
name|ScriptList
argument_list|,
operator|&
name|gsub
operator|->
name|ScriptList
argument_list|)
expr_stmt|;
name|RECURSE
argument_list|(
name|FeatureList
argument_list|,
name|FeatureList
argument_list|,
operator|&
name|gsub
operator|->
name|FeatureList
argument_list|)
expr_stmt|;
name|RECURSE
argument_list|(
name|LookupList
argument_list|,
name|LookupList
argument_list|,
operator|&
name|gsub
operator|->
name|LookupList
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
name|void
DECL|function|HB_Dump_GPOS_Table
name|HB_Dump_GPOS_Table
parameter_list|(
name|HB_GPOS
name|gpos
parameter_list|,
name|FILE
modifier|*
name|stream
parameter_list|)
block|{
name|int
name|indent
init|=
literal|1
decl_stmt|;
name|HB_Type
name|hb_type
init|=
name|HB_Type_GPOS
decl_stmt|;
name|do_indent
argument_list|(
name|stream
argument_list|,
name|indent
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"<!-- GPOS -->\n"
argument_list|)
expr_stmt|;
name|RECURSE
argument_list|(
name|ScriptList
argument_list|,
name|ScriptList
argument_list|,
operator|&
name|gpos
operator|->
name|ScriptList
argument_list|)
expr_stmt|;
name|RECURSE
argument_list|(
name|FeatureList
argument_list|,
name|FeatureList
argument_list|,
operator|&
name|gpos
operator|->
name|FeatureList
argument_list|)
expr_stmt|;
name|RECURSE
argument_list|(
name|LookupList
argument_list|,
name|LookupList
argument_list|,
operator|&
name|gpos
operator|->
name|LookupList
argument_list|)
expr_stmt|;
block|}
end_function
end_unit
