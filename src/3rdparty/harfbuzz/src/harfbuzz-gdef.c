begin_unit
begin_comment
comment|/*  * Copyright (C) 1998-2004  David Turner and Werner Lemberg  * Copyright (C) 2006  Behdad Esfahbod  *  * This is part of HarfBuzz, an OpenType Layout engine library.  *  * Permission is hereby granted, without written agreement and without  * license or royalty fees, to use, copy, modify, and distribute this  * software and its documentation for any purpose, provided that the  * above copyright notice and the following two paragraphs appear in  * all copies of this software.  *  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH  * DAMAGE.  *  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS  * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.  */
end_comment
begin_include
include|#
directive|include
file|"harfbuzz-impl.h"
end_include
begin_include
include|#
directive|include
file|"harfbuzz-gdef-private.h"
end_include
begin_include
include|#
directive|include
file|"harfbuzz-open-private.h"
end_include
begin_function_decl
specifier|static
name|HB_Error
name|Load_AttachList
parameter_list|(
name|HB_AttachList
modifier|*
name|al
parameter_list|,
name|HB_Stream
name|stream
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|HB_Error
name|Load_LigCaretList
parameter_list|(
name|HB_LigCaretList
modifier|*
name|lcl
parameter_list|,
name|HB_Stream
name|stream
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|void
name|Free_AttachList
parameter_list|(
name|HB_AttachList
modifier|*
name|al
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|void
name|Free_LigCaretList
parameter_list|(
name|HB_LigCaretList
modifier|*
name|lcl
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|void
name|Free_NewGlyphClasses
parameter_list|(
name|HB_GDEFHeader
modifier|*
name|gdef
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/* GDEF glyph classes */
end_comment
begin_define
DECL|macro|UNCLASSIFIED_GLYPH
define|#
directive|define
name|UNCLASSIFIED_GLYPH
value|0
end_define
begin_define
DECL|macro|SIMPLE_GLYPH
define|#
directive|define
name|SIMPLE_GLYPH
value|1
end_define
begin_define
DECL|macro|LIGATURE_GLYPH
define|#
directive|define
name|LIGATURE_GLYPH
value|2
end_define
begin_define
DECL|macro|MARK_GLYPH
define|#
directive|define
name|MARK_GLYPH
value|3
end_define
begin_define
DECL|macro|COMPONENT_GLYPH
define|#
directive|define
name|COMPONENT_GLYPH
value|4
end_define
begin_function
DECL|function|HB_New_GDEF_Table
name|HB_Error
name|HB_New_GDEF_Table
parameter_list|(
name|HB_GDEFHeader
modifier|*
modifier|*
name|retptr
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_GDEFHeader
modifier|*
name|gdef
decl_stmt|;
if|if
condition|(
operator|!
name|retptr
condition|)
return|return
name|ERR
argument_list|(
name|HB_Err_Invalid_Argument
argument_list|)
return|;
if|if
condition|(
name|ALLOC
argument_list|(
name|gdef
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|gdef
argument_list|)
argument_list|)
condition|)
return|return
name|error
return|;
name|gdef
operator|->
name|GlyphClassDef
operator|.
name|loaded
operator|=
name|FALSE
expr_stmt|;
name|gdef
operator|->
name|AttachList
operator|.
name|loaded
operator|=
name|FALSE
expr_stmt|;
name|gdef
operator|->
name|LigCaretList
operator|.
name|loaded
operator|=
name|FALSE
expr_stmt|;
name|gdef
operator|->
name|MarkAttachClassDef_offset
operator|=
literal|0
expr_stmt|;
name|gdef
operator|->
name|MarkAttachClassDef
operator|.
name|loaded
operator|=
name|FALSE
expr_stmt|;
name|gdef
operator|->
name|LastGlyph
operator|=
literal|0
expr_stmt|;
name|gdef
operator|->
name|NewGlyphClasses
operator|=
name|NULL
expr_stmt|;
operator|*
name|retptr
operator|=
name|gdef
expr_stmt|;
return|return
name|HB_Err_Ok
return|;
block|}
end_function
begin_function
DECL|function|HB_Load_GDEF_Table
name|HB_Error
name|HB_Load_GDEF_Table
parameter_list|(
name|HB_Stream
name|stream
parameter_list|,
name|HB_GDEFHeader
modifier|*
modifier|*
name|retptr
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_UInt
name|cur_offset
decl_stmt|,
name|new_offset
decl_stmt|,
name|base_offset
decl_stmt|;
name|HB_GDEFHeader
modifier|*
name|gdef
decl_stmt|;
if|if
condition|(
operator|!
name|retptr
condition|)
return|return
name|ERR
argument_list|(
name|HB_Err_Invalid_Argument
argument_list|)
return|;
if|if
condition|(
name|GOTO_Table
argument_list|(
name|TTAG_GDEF
argument_list|)
condition|)
return|return
name|error
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|HB_New_GDEF_Table
argument_list|(
operator|&
name|gdef
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
name|base_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
comment|/* skip version */
if|if
condition|(
name|FILE_Seek
argument_list|(
name|base_offset
operator|+
literal|4L
argument_list|)
operator|||
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail0
goto|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
comment|/* all GDEF subtables are optional */
if|if
condition|(
name|new_offset
condition|)
block|{
name|new_offset
operator|+=
name|base_offset
expr_stmt|;
comment|/* only classes 1-4 are allowed here */
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|_HB_OPEN_Load_ClassDefinition
argument_list|(
operator|&
name|gdef
operator|->
name|GlyphClassDef
argument_list|,
literal|5
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
goto|goto
name|Fail0
goto|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail1
goto|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
if|if
condition|(
name|new_offset
condition|)
block|{
name|new_offset
operator|+=
name|base_offset
expr_stmt|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|Load_AttachList
argument_list|(
operator|&
name|gdef
operator|->
name|AttachList
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
goto|goto
name|Fail1
goto|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail2
goto|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
if|if
condition|(
name|new_offset
condition|)
block|{
name|new_offset
operator|+=
name|base_offset
expr_stmt|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|Load_LigCaretList
argument_list|(
operator|&
name|gdef
operator|->
name|LigCaretList
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
goto|goto
name|Fail2
goto|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
block|}
comment|/* OpenType 1.2 has introduced the `MarkAttachClassDef' field.  We      first have to scan the LookupFlag values to find out whether we      must load it or not.  Here we only store the offset of the table. */
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail3
goto|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
if|if
condition|(
name|new_offset
condition|)
name|gdef
operator|->
name|MarkAttachClassDef_offset
operator|=
name|new_offset
operator|+
name|base_offset
expr_stmt|;
else|else
name|gdef
operator|->
name|MarkAttachClassDef_offset
operator|=
literal|0
expr_stmt|;
operator|*
name|retptr
operator|=
name|gdef
expr_stmt|;
return|return
name|HB_Err_Ok
return|;
name|Fail3
label|:
name|Free_LigCaretList
argument_list|(
operator|&
name|gdef
operator|->
name|LigCaretList
argument_list|)
expr_stmt|;
name|Fail2
label|:
name|Free_AttachList
argument_list|(
operator|&
name|gdef
operator|->
name|AttachList
argument_list|)
expr_stmt|;
name|Fail1
label|:
name|_HB_OPEN_Free_ClassDefinition
argument_list|(
operator|&
name|gdef
operator|->
name|GlyphClassDef
argument_list|)
expr_stmt|;
name|Fail0
label|:
name|FREE
argument_list|(
name|gdef
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_function
DECL|function|HB_Done_GDEF_Table
name|HB_Error
name|HB_Done_GDEF_Table
parameter_list|(
name|HB_GDEFHeader
modifier|*
name|gdef
parameter_list|)
block|{
name|Free_LigCaretList
argument_list|(
operator|&
name|gdef
operator|->
name|LigCaretList
argument_list|)
expr_stmt|;
name|Free_AttachList
argument_list|(
operator|&
name|gdef
operator|->
name|AttachList
argument_list|)
expr_stmt|;
name|_HB_OPEN_Free_ClassDefinition
argument_list|(
operator|&
name|gdef
operator|->
name|GlyphClassDef
argument_list|)
expr_stmt|;
name|_HB_OPEN_Free_ClassDefinition
argument_list|(
operator|&
name|gdef
operator|->
name|MarkAttachClassDef
argument_list|)
expr_stmt|;
name|Free_NewGlyphClasses
argument_list|(
name|gdef
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|gdef
argument_list|)
expr_stmt|;
return|return
name|HB_Err_Ok
return|;
block|}
end_function
begin_comment
comment|/*******************************  * AttachList related functions  *******************************/
end_comment
begin_comment
comment|/* AttachPoint */
end_comment
begin_function
DECL|function|Load_AttachPoint
specifier|static
name|HB_Error
name|Load_AttachPoint
parameter_list|(
name|HB_AttachPoint
modifier|*
name|ap
parameter_list|,
name|HB_Stream
name|stream
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_UShort
name|n
decl_stmt|,
name|count
decl_stmt|;
name|HB_UShort
modifier|*
name|pi
decl_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
return|return
name|error
return|;
name|count
operator|=
name|ap
operator|->
name|PointCount
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|ap
operator|->
name|PointIndex
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|count
condition|)
block|{
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|ap
operator|->
name|PointIndex
argument_list|,
name|count
argument_list|,
name|HB_UShort
argument_list|)
condition|)
return|return
name|error
return|;
name|pi
operator|=
name|ap
operator|->
name|PointIndex
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
name|count
operator|*
literal|2L
argument_list|)
condition|)
block|{
name|FREE
argument_list|(
name|pi
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
name|pi
index|[
name|n
index|]
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
block|}
return|return
name|HB_Err_Ok
return|;
block|}
end_function
begin_function
DECL|function|Free_AttachPoint
specifier|static
name|void
name|Free_AttachPoint
parameter_list|(
name|HB_AttachPoint
modifier|*
name|ap
parameter_list|)
block|{
name|FREE
argument_list|(
name|ap
operator|->
name|PointIndex
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* AttachList */
end_comment
begin_function
DECL|function|Load_AttachList
specifier|static
name|HB_Error
name|Load_AttachList
parameter_list|(
name|HB_AttachList
modifier|*
name|al
parameter_list|,
name|HB_Stream
name|stream
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_UShort
name|n
decl_stmt|,
name|m
decl_stmt|,
name|count
decl_stmt|;
name|HB_UInt
name|cur_offset
decl_stmt|,
name|new_offset
decl_stmt|,
name|base_offset
decl_stmt|;
name|HB_AttachPoint
modifier|*
name|ap
decl_stmt|;
name|base_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
return|return
name|error
return|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
operator|+
name|base_offset
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|_HB_OPEN_Load_Coverage
argument_list|(
operator|&
name|al
operator|->
name|Coverage
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
return|return
name|error
return|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail2
goto|;
name|count
operator|=
name|al
operator|->
name|GlyphCount
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|al
operator|->
name|AttachPoint
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|al
operator|->
name|AttachPoint
argument_list|,
name|count
argument_list|,
name|HB_AttachPoint
argument_list|)
condition|)
goto|goto
name|Fail2
goto|;
name|ap
operator|=
name|al
operator|->
name|AttachPoint
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail1
goto|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
operator|+
name|base_offset
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|Load_AttachPoint
argument_list|(
operator|&
name|ap
index|[
name|n
index|]
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
goto|goto
name|Fail1
goto|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
block|}
name|al
operator|->
name|loaded
operator|=
name|TRUE
expr_stmt|;
return|return
name|HB_Err_Ok
return|;
name|Fail1
label|:
for|for
control|(
name|m
operator|=
literal|0
init|;
name|m
operator|<
name|n
condition|;
name|m
operator|++
control|)
name|Free_AttachPoint
argument_list|(
operator|&
name|ap
index|[
name|m
index|]
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|Fail2
label|:
name|_HB_OPEN_Free_Coverage
argument_list|(
operator|&
name|al
operator|->
name|Coverage
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_function
DECL|function|Free_AttachList
specifier|static
name|void
name|Free_AttachList
parameter_list|(
name|HB_AttachList
modifier|*
name|al
parameter_list|)
block|{
name|HB_UShort
name|n
decl_stmt|,
name|count
decl_stmt|;
name|HB_AttachPoint
modifier|*
name|ap
decl_stmt|;
if|if
condition|(
operator|!
name|al
operator|->
name|loaded
condition|)
return|return;
if|if
condition|(
name|al
operator|->
name|AttachPoint
condition|)
block|{
name|count
operator|=
name|al
operator|->
name|GlyphCount
expr_stmt|;
name|ap
operator|=
name|al
operator|->
name|AttachPoint
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
name|Free_AttachPoint
argument_list|(
operator|&
name|ap
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
name|_HB_OPEN_Free_Coverage
argument_list|(
operator|&
name|al
operator|->
name|Coverage
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*********************************  * LigCaretList related functions  *********************************/
end_comment
begin_comment
comment|/* CaretValueFormat1 */
end_comment
begin_comment
comment|/* CaretValueFormat2 */
end_comment
begin_comment
comment|/* CaretValueFormat3 */
end_comment
begin_comment
comment|/* CaretValueFormat4 */
end_comment
begin_function
DECL|function|Load_CaretValue
specifier|static
name|HB_Error
name|Load_CaretValue
parameter_list|(
name|HB_CaretValue
modifier|*
name|cv
parameter_list|,
name|HB_Stream
name|stream
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_UInt
name|cur_offset
decl_stmt|,
name|new_offset
decl_stmt|,
name|base_offset
decl_stmt|;
name|base_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
return|return
name|error
return|;
name|cv
operator|->
name|CaretValueFormat
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|cv
operator|->
name|CaretValueFormat
condition|)
block|{
case|case
literal|1
case|:
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
return|return
name|error
return|;
name|cv
operator|->
name|cvf
operator|.
name|cvf1
operator|.
name|Coordinate
operator|=
name|GET_Short
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
break|break;
case|case
literal|2
case|:
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
return|return
name|error
return|;
name|cv
operator|->
name|cvf
operator|.
name|cvf2
operator|.
name|CaretValuePoint
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
break|break;
case|case
literal|3
case|:
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|4L
argument_list|)
condition|)
return|return
name|error
return|;
name|cv
operator|->
name|cvf
operator|.
name|cvf3
operator|.
name|Coordinate
operator|=
name|GET_Short
argument_list|()
expr_stmt|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
operator|+
name|base_offset
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|_HB_OPEN_Load_Device
argument_list|(
operator|&
name|cv
operator|->
name|cvf
operator|.
name|cvf3
operator|.
name|Device
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
return|return
name|error
return|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
return|return
name|error
return|;
ifdef|#
directive|ifdef
name|HB_SUPPORT_MULTIPLE_MASTER
name|cv
operator|->
name|cvf
operator|.
name|cvf4
operator|.
name|IdCaretValue
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|GET_UShort
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|FORGET_Frame
argument_list|()
expr_stmt|;
break|break;
default|default:
return|return
name|ERR
argument_list|(
name|HB_Err_Invalid_SubTable_Format
argument_list|)
return|;
block|}
return|return
name|HB_Err_Ok
return|;
block|}
end_function
begin_function
DECL|function|Free_CaretValue
specifier|static
name|void
name|Free_CaretValue
parameter_list|(
name|HB_CaretValue
modifier|*
name|cv
parameter_list|)
block|{
if|if
condition|(
name|cv
operator|->
name|CaretValueFormat
operator|==
literal|3
condition|)
name|_HB_OPEN_Free_Device
argument_list|(
name|cv
operator|->
name|cvf
operator|.
name|cvf3
operator|.
name|Device
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* LigGlyph */
end_comment
begin_function
DECL|function|Load_LigGlyph
specifier|static
name|HB_Error
name|Load_LigGlyph
parameter_list|(
name|HB_LigGlyph
modifier|*
name|lg
parameter_list|,
name|HB_Stream
name|stream
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_UShort
name|n
decl_stmt|,
name|m
decl_stmt|,
name|count
decl_stmt|;
name|HB_UInt
name|cur_offset
decl_stmt|,
name|new_offset
decl_stmt|,
name|base_offset
decl_stmt|;
name|HB_CaretValue
modifier|*
name|cv
decl_stmt|;
name|base_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
return|return
name|error
return|;
name|count
operator|=
name|lg
operator|->
name|CaretCount
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|lg
operator|->
name|CaretValue
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|lg
operator|->
name|CaretValue
argument_list|,
name|count
argument_list|,
name|HB_CaretValue
argument_list|)
condition|)
return|return
name|error
return|;
name|cv
operator|=
name|lg
operator|->
name|CaretValue
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
operator|+
name|base_offset
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|Load_CaretValue
argument_list|(
operator|&
name|cv
index|[
name|n
index|]
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
goto|goto
name|Fail
goto|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
block|}
return|return
name|HB_Err_Ok
return|;
name|Fail
label|:
for|for
control|(
name|m
operator|=
literal|0
init|;
name|m
operator|<
name|n
condition|;
name|m
operator|++
control|)
name|Free_CaretValue
argument_list|(
operator|&
name|cv
index|[
name|m
index|]
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|cv
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_function
DECL|function|Free_LigGlyph
specifier|static
name|void
name|Free_LigGlyph
parameter_list|(
name|HB_LigGlyph
modifier|*
name|lg
parameter_list|)
block|{
name|HB_UShort
name|n
decl_stmt|,
name|count
decl_stmt|;
name|HB_CaretValue
modifier|*
name|cv
decl_stmt|;
if|if
condition|(
name|lg
operator|->
name|CaretValue
condition|)
block|{
name|count
operator|=
name|lg
operator|->
name|CaretCount
expr_stmt|;
name|cv
operator|=
name|lg
operator|->
name|CaretValue
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
name|Free_CaretValue
argument_list|(
operator|&
name|cv
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|cv
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/* LigCaretList */
end_comment
begin_function
DECL|function|Load_LigCaretList
specifier|static
name|HB_Error
name|Load_LigCaretList
parameter_list|(
name|HB_LigCaretList
modifier|*
name|lcl
parameter_list|,
name|HB_Stream
name|stream
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_UShort
name|m
decl_stmt|,
name|n
decl_stmt|,
name|count
decl_stmt|;
name|HB_UInt
name|cur_offset
decl_stmt|,
name|new_offset
decl_stmt|,
name|base_offset
decl_stmt|;
name|HB_LigGlyph
modifier|*
name|lg
decl_stmt|;
name|base_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
return|return
name|error
return|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
operator|+
name|base_offset
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|_HB_OPEN_Load_Coverage
argument_list|(
operator|&
name|lcl
operator|->
name|Coverage
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
return|return
name|error
return|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail2
goto|;
name|count
operator|=
name|lcl
operator|->
name|LigGlyphCount
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|lcl
operator|->
name|LigGlyph
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|lcl
operator|->
name|LigGlyph
argument_list|,
name|count
argument_list|,
name|HB_LigGlyph
argument_list|)
condition|)
goto|goto
name|Fail2
goto|;
name|lg
operator|=
name|lcl
operator|->
name|LigGlyph
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail1
goto|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
operator|+
name|base_offset
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|Load_LigGlyph
argument_list|(
operator|&
name|lg
index|[
name|n
index|]
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
goto|goto
name|Fail1
goto|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
block|}
name|lcl
operator|->
name|loaded
operator|=
name|TRUE
expr_stmt|;
return|return
name|HB_Err_Ok
return|;
name|Fail1
label|:
for|for
control|(
name|m
operator|=
literal|0
init|;
name|m
operator|<
name|n
condition|;
name|m
operator|++
control|)
name|Free_LigGlyph
argument_list|(
operator|&
name|lg
index|[
name|m
index|]
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|lg
argument_list|)
expr_stmt|;
name|Fail2
label|:
name|_HB_OPEN_Free_Coverage
argument_list|(
operator|&
name|lcl
operator|->
name|Coverage
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_function
DECL|function|Free_LigCaretList
specifier|static
name|void
name|Free_LigCaretList
parameter_list|(
name|HB_LigCaretList
modifier|*
name|lcl
parameter_list|)
block|{
name|HB_UShort
name|n
decl_stmt|,
name|count
decl_stmt|;
name|HB_LigGlyph
modifier|*
name|lg
decl_stmt|;
if|if
condition|(
operator|!
name|lcl
operator|->
name|loaded
condition|)
return|return;
if|if
condition|(
name|lcl
operator|->
name|LigGlyph
condition|)
block|{
name|count
operator|=
name|lcl
operator|->
name|LigGlyphCount
expr_stmt|;
name|lg
operator|=
name|lcl
operator|->
name|LigGlyph
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
name|Free_LigGlyph
argument_list|(
operator|&
name|lg
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|lg
argument_list|)
expr_stmt|;
block|}
name|_HB_OPEN_Free_Coverage
argument_list|(
operator|&
name|lcl
operator|->
name|Coverage
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/***********  * GDEF API  ***********/
end_comment
begin_function
DECL|function|Get_New_Class
specifier|static
name|HB_UShort
name|Get_New_Class
parameter_list|(
name|HB_GDEFHeader
modifier|*
name|gdef
parameter_list|,
name|HB_UShort
name|glyphID
parameter_list|,
name|HB_UShort
name|index
parameter_list|)
block|{
name|HB_UShort
name|glyph_index
decl_stmt|,
name|array_index
decl_stmt|,
name|count
decl_stmt|;
name|HB_UShort
name|byte
decl_stmt|,
name|bits
decl_stmt|;
name|HB_ClassRangeRecord
modifier|*
name|gcrr
decl_stmt|;
name|HB_UShort
modifier|*
modifier|*
name|ngc
decl_stmt|;
if|if
condition|(
name|glyphID
operator|>=
name|gdef
operator|->
name|LastGlyph
condition|)
return|return
literal|0
return|;
name|count
operator|=
name|gdef
operator|->
name|GlyphClassDef
operator|.
name|cd
operator|.
name|cd2
operator|.
name|ClassRangeCount
expr_stmt|;
name|gcrr
operator|=
name|gdef
operator|->
name|GlyphClassDef
operator|.
name|cd
operator|.
name|cd2
operator|.
name|ClassRangeRecord
expr_stmt|;
name|ngc
operator|=
name|gdef
operator|->
name|NewGlyphClasses
expr_stmt|;
if|if
condition|(
name|index
operator|<
name|count
operator|&&
name|glyphID
operator|<
name|gcrr
index|[
name|index
index|]
operator|.
name|Start
condition|)
block|{
name|array_index
operator|=
name|index
expr_stmt|;
if|if
condition|(
name|index
operator|==
literal|0
condition|)
name|glyph_index
operator|=
name|glyphID
expr_stmt|;
else|else
name|glyph_index
operator|=
name|glyphID
operator|-
name|gcrr
index|[
name|index
operator|-
literal|1
index|]
operator|.
name|End
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|array_index
operator|=
name|index
operator|+
literal|1
expr_stmt|;
name|glyph_index
operator|=
name|glyphID
operator|-
name|gcrr
index|[
name|index
index|]
operator|.
name|End
operator|-
literal|1
expr_stmt|;
block|}
name|byte
operator|=
name|ngc
index|[
name|array_index
index|]
index|[
name|glyph_index
operator|/
literal|4
index|]
expr_stmt|;
name|bits
operator|=
name|byte
operator|>>
operator|(
literal|16
operator|-
operator|(
name|glyph_index
operator|%
literal|4
operator|+
literal|1
operator|)
operator|*
literal|4
operator|)
expr_stmt|;
return|return
name|bits
operator|&
literal|0x000F
return|;
block|}
end_function
begin_function
DECL|function|HB_GDEF_Get_Glyph_Property
name|HB_Error
name|HB_GDEF_Get_Glyph_Property
parameter_list|(
name|HB_GDEFHeader
modifier|*
name|gdef
parameter_list|,
name|HB_UShort
name|glyphID
parameter_list|,
name|HB_UShort
modifier|*
name|property
parameter_list|)
block|{
name|HB_UShort
name|class
init|=
literal|0
decl_stmt|,
name|index
init|=
literal|0
decl_stmt|;
comment|/* shut compiler up */
name|HB_Error
name|error
decl_stmt|;
if|if
condition|(
operator|!
name|gdef
operator|||
operator|!
name|property
condition|)
return|return
name|ERR
argument_list|(
name|HB_Err_Invalid_Argument
argument_list|)
return|;
comment|/* first, we check for mark attach classes */
if|if
condition|(
name|gdef
operator|->
name|MarkAttachClassDef
operator|.
name|loaded
condition|)
block|{
name|error
operator|=
name|_HB_OPEN_Get_Class
argument_list|(
operator|&
name|gdef
operator|->
name|MarkAttachClassDef
argument_list|,
name|glyphID
argument_list|,
operator|&
name|class
argument_list|,
operator|&
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|HB_Err_Not_Covered
condition|)
return|return
name|error
return|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
operator|*
name|property
operator|=
name|class
operator|<<
literal|8
expr_stmt|;
return|return
name|HB_Err_Ok
return|;
block|}
block|}
name|error
operator|=
name|_HB_OPEN_Get_Class
argument_list|(
operator|&
name|gdef
operator|->
name|GlyphClassDef
argument_list|,
name|glyphID
argument_list|,
operator|&
name|class
argument_list|,
operator|&
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|HB_Err_Not_Covered
condition|)
return|return
name|error
return|;
comment|/* if we have a constructed class table, check whether additional      values have been assigned                                      */
if|if
condition|(
name|error
operator|==
name|HB_Err_Not_Covered
operator|&&
name|gdef
operator|->
name|NewGlyphClasses
condition|)
name|class
operator|=
name|Get_New_Class
argument_list|(
name|gdef
argument_list|,
name|glyphID
argument_list|,
name|index
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|class
condition|)
block|{
default|default:
case|case
name|UNCLASSIFIED_GLYPH
case|:
operator|*
name|property
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SIMPLE_GLYPH
case|:
operator|*
name|property
operator|=
name|HB_GDEF_BASE_GLYPH
expr_stmt|;
break|break;
case|case
name|LIGATURE_GLYPH
case|:
operator|*
name|property
operator|=
name|HB_GDEF_LIGATURE
expr_stmt|;
break|break;
case|case
name|MARK_GLYPH
case|:
operator|*
name|property
operator|=
name|HB_GDEF_MARK
expr_stmt|;
break|break;
case|case
name|COMPONENT_GLYPH
case|:
operator|*
name|property
operator|=
name|HB_GDEF_COMPONENT
expr_stmt|;
break|break;
block|}
return|return
name|HB_Err_Ok
return|;
block|}
end_function
begin_function
DECL|function|Make_ClassRange
specifier|static
name|HB_Error
name|Make_ClassRange
parameter_list|(
name|HB_ClassDefinition
modifier|*
name|cd
parameter_list|,
name|HB_UShort
name|start
parameter_list|,
name|HB_UShort
name|end
parameter_list|,
name|HB_UShort
name|class
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_UShort
name|index
decl_stmt|;
name|HB_ClassDefFormat2
modifier|*
name|cdf2
decl_stmt|;
name|HB_ClassRangeRecord
modifier|*
name|crr
decl_stmt|;
name|cdf2
operator|=
operator|&
name|cd
operator|->
name|cd
operator|.
name|cd2
expr_stmt|;
if|if
condition|(
name|REALLOC_ARRAY
argument_list|(
name|cdf2
operator|->
name|ClassRangeRecord
argument_list|,
name|cdf2
operator|->
name|ClassRangeCount
operator|+
literal|1
argument_list|,
name|HB_ClassRangeRecord
argument_list|)
condition|)
return|return
name|error
return|;
name|cdf2
operator|->
name|ClassRangeCount
operator|++
expr_stmt|;
name|crr
operator|=
name|cdf2
operator|->
name|ClassRangeRecord
expr_stmt|;
name|index
operator|=
name|cdf2
operator|->
name|ClassRangeCount
operator|-
literal|1
expr_stmt|;
name|crr
index|[
name|index
index|]
operator|.
name|Start
operator|=
name|start
expr_stmt|;
name|crr
index|[
name|index
index|]
operator|.
name|End
operator|=
name|end
expr_stmt|;
name|crr
index|[
name|index
index|]
operator|.
name|Class
operator|=
name|class
expr_stmt|;
return|return
name|HB_Err_Ok
return|;
block|}
end_function
begin_function
DECL|function|HB_GDEF_Build_ClassDefinition
name|HB_Error
name|HB_GDEF_Build_ClassDefinition
parameter_list|(
name|HB_GDEFHeader
modifier|*
name|gdef
parameter_list|,
name|HB_UShort
name|num_glyphs
parameter_list|,
name|HB_UShort
name|glyph_count
parameter_list|,
name|HB_UShort
modifier|*
name|glyph_array
parameter_list|,
name|HB_UShort
modifier|*
name|class_array
parameter_list|)
block|{
name|HB_UShort
name|start
decl_stmt|,
name|curr_glyph
decl_stmt|,
name|curr_class
decl_stmt|;
name|HB_UShort
name|n
decl_stmt|,
name|m
decl_stmt|,
name|count
decl_stmt|;
name|HB_Error
name|error
decl_stmt|;
name|HB_ClassDefinition
modifier|*
name|gcd
decl_stmt|;
name|HB_ClassRangeRecord
modifier|*
name|gcrr
decl_stmt|;
name|HB_UShort
modifier|*
modifier|*
name|ngc
decl_stmt|;
if|if
condition|(
operator|!
name|gdef
operator|||
operator|!
name|glyph_array
operator|||
operator|!
name|class_array
condition|)
return|return
name|ERR
argument_list|(
name|HB_Err_Invalid_Argument
argument_list|)
return|;
name|gcd
operator|=
operator|&
name|gdef
operator|->
name|GlyphClassDef
expr_stmt|;
comment|/* We build a format 2 table */
name|gcd
operator|->
name|ClassFormat
operator|=
literal|2
expr_stmt|;
name|gcd
operator|->
name|cd
operator|.
name|cd2
operator|.
name|ClassRangeCount
operator|=
literal|0
expr_stmt|;
name|gcd
operator|->
name|cd
operator|.
name|cd2
operator|.
name|ClassRangeRecord
operator|=
name|NULL
expr_stmt|;
name|start
operator|=
name|glyph_array
index|[
literal|0
index|]
expr_stmt|;
name|curr_class
operator|=
name|class_array
index|[
literal|0
index|]
expr_stmt|;
name|curr_glyph
operator|=
name|start
expr_stmt|;
if|if
condition|(
name|curr_class
operator|>=
literal|5
condition|)
block|{
name|error
operator|=
name|ERR
argument_list|(
name|HB_Err_Invalid_Argument
argument_list|)
expr_stmt|;
goto|goto
name|Fail4
goto|;
block|}
name|glyph_count
operator|--
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|glyph_count
operator|+
literal|1
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|curr_glyph
operator|==
name|glyph_array
index|[
name|n
index|]
operator|&&
name|curr_class
operator|==
name|class_array
index|[
name|n
index|]
condition|)
block|{
if|if
condition|(
name|n
operator|==
name|glyph_count
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|Make_ClassRange
argument_list|(
name|gcd
argument_list|,
name|start
argument_list|,
name|curr_glyph
argument_list|,
name|curr_class
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
goto|goto
name|Fail3
goto|;
block|}
else|else
block|{
if|if
condition|(
name|curr_glyph
operator|==
literal|0xFFFF
condition|)
block|{
name|error
operator|=
name|ERR
argument_list|(
name|HB_Err_Invalid_Argument
argument_list|)
expr_stmt|;
goto|goto
name|Fail3
goto|;
block|}
else|else
name|curr_glyph
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|Make_ClassRange
argument_list|(
name|gcd
argument_list|,
name|start
argument_list|,
name|curr_glyph
operator|-
literal|1
argument_list|,
name|curr_class
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
goto|goto
name|Fail3
goto|;
if|if
condition|(
name|curr_glyph
operator|>
name|glyph_array
index|[
name|n
index|]
condition|)
block|{
name|error
operator|=
name|ERR
argument_list|(
name|HB_Err_Invalid_Argument
argument_list|)
expr_stmt|;
goto|goto
name|Fail3
goto|;
block|}
name|start
operator|=
name|glyph_array
index|[
name|n
index|]
expr_stmt|;
name|curr_class
operator|=
name|class_array
index|[
name|n
index|]
expr_stmt|;
name|curr_glyph
operator|=
name|start
expr_stmt|;
if|if
condition|(
name|curr_class
operator|>=
literal|5
condition|)
block|{
name|error
operator|=
name|ERR
argument_list|(
name|HB_Err_Invalid_Argument
argument_list|)
expr_stmt|;
goto|goto
name|Fail3
goto|;
block|}
if|if
condition|(
name|n
operator|==
name|glyph_count
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|Make_ClassRange
argument_list|(
name|gcd
argument_list|,
name|start
argument_list|,
name|curr_glyph
argument_list|,
name|curr_class
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
goto|goto
name|Fail3
goto|;
block|}
else|else
block|{
if|if
condition|(
name|curr_glyph
operator|==
literal|0xFFFF
condition|)
block|{
name|error
operator|=
name|ERR
argument_list|(
name|HB_Err_Invalid_Argument
argument_list|)
expr_stmt|;
goto|goto
name|Fail3
goto|;
block|}
else|else
name|curr_glyph
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|/* now prepare the arrays for class values assigned during the lookup      process                                                            */
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|gdef
operator|->
name|NewGlyphClasses
argument_list|,
name|gcd
operator|->
name|cd
operator|.
name|cd2
operator|.
name|ClassRangeCount
operator|+
literal|1
argument_list|,
name|HB_UShort
operator|*
argument_list|)
condition|)
goto|goto
name|Fail3
goto|;
name|count
operator|=
name|gcd
operator|->
name|cd
operator|.
name|cd2
operator|.
name|ClassRangeCount
expr_stmt|;
name|gcrr
operator|=
name|gcd
operator|->
name|cd
operator|.
name|cd2
operator|.
name|ClassRangeRecord
expr_stmt|;
name|ngc
operator|=
name|gdef
operator|->
name|NewGlyphClasses
expr_stmt|;
comment|/* We allocate arrays for all glyphs not covered by the class range      records.  Each element holds four class values.                  */
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|gcrr
index|[
literal|0
index|]
operator|.
name|Start
condition|)
block|{
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|ngc
index|[
literal|0
index|]
argument_list|,
operator|(
name|gcrr
index|[
literal|0
index|]
operator|.
name|Start
operator|+
literal|3
operator|)
operator|/
literal|4
argument_list|,
name|HB_UShort
argument_list|)
condition|)
goto|goto
name|Fail2
goto|;
block|}
for|for
control|(
name|n
operator|=
literal|1
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|gcrr
index|[
name|n
index|]
operator|.
name|Start
operator|-
name|gcrr
index|[
name|n
operator|-
literal|1
index|]
operator|.
name|End
operator|>
literal|1
condition|)
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|ngc
index|[
name|n
index|]
argument_list|,
operator|(
name|gcrr
index|[
name|n
index|]
operator|.
name|Start
operator|-
name|gcrr
index|[
name|n
operator|-
literal|1
index|]
operator|.
name|End
operator|+
literal|2
operator|)
operator|/
literal|4
argument_list|,
name|HB_UShort
argument_list|)
condition|)
goto|goto
name|Fail1
goto|;
block|}
if|if
condition|(
name|gcrr
index|[
name|count
operator|-
literal|1
index|]
operator|.
name|End
operator|!=
name|num_glyphs
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|ngc
index|[
name|count
index|]
argument_list|,
operator|(
name|num_glyphs
operator|-
name|gcrr
index|[
name|count
operator|-
literal|1
index|]
operator|.
name|End
operator|+
literal|2
operator|)
operator|/
literal|4
argument_list|,
name|HB_UShort
argument_list|)
condition|)
goto|goto
name|Fail1
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|num_glyphs
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|ngc
index|[
name|count
index|]
argument_list|,
operator|(
name|num_glyphs
operator|+
literal|3
operator|)
operator|/
literal|4
argument_list|,
name|HB_UShort
argument_list|)
condition|)
goto|goto
name|Fail2
goto|;
block|}
name|gdef
operator|->
name|LastGlyph
operator|=
name|num_glyphs
operator|-
literal|1
expr_stmt|;
name|gdef
operator|->
name|MarkAttachClassDef_offset
operator|=
literal|0L
expr_stmt|;
name|gdef
operator|->
name|MarkAttachClassDef
operator|.
name|loaded
operator|=
name|FALSE
expr_stmt|;
name|gcd
operator|->
name|loaded
operator|=
name|TRUE
expr_stmt|;
return|return
name|HB_Err_Ok
return|;
name|Fail1
label|:
for|for
control|(
name|m
operator|=
literal|0
init|;
name|m
operator|<
name|n
condition|;
name|m
operator|++
control|)
name|FREE
argument_list|(
name|ngc
index|[
name|m
index|]
argument_list|)
expr_stmt|;
name|Fail2
label|:
name|FREE
argument_list|(
name|gdef
operator|->
name|NewGlyphClasses
argument_list|)
expr_stmt|;
name|Fail3
label|:
name|FREE
argument_list|(
name|gcd
operator|->
name|cd
operator|.
name|cd2
operator|.
name|ClassRangeRecord
argument_list|)
expr_stmt|;
name|Fail4
label|:
return|return
name|error
return|;
block|}
end_function
begin_function
DECL|function|Free_NewGlyphClasses
specifier|static
name|void
name|Free_NewGlyphClasses
parameter_list|(
name|HB_GDEFHeader
modifier|*
name|gdef
parameter_list|)
block|{
name|HB_UShort
modifier|*
modifier|*
name|ngc
decl_stmt|;
name|HB_UShort
name|n
decl_stmt|,
name|count
decl_stmt|;
if|if
condition|(
name|gdef
operator|->
name|NewGlyphClasses
condition|)
block|{
name|count
operator|=
name|gdef
operator|->
name|GlyphClassDef
operator|.
name|cd
operator|.
name|cd2
operator|.
name|ClassRangeCount
operator|+
literal|1
expr_stmt|;
name|ngc
operator|=
name|gdef
operator|->
name|NewGlyphClasses
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
name|FREE
argument_list|(
name|ngc
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|ngc
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
name|HB_INTERNAL
name|HB_Error
DECL|function|_HB_GDEF_Add_Glyph_Property
name|_HB_GDEF_Add_Glyph_Property
parameter_list|(
name|HB_GDEFHeader
modifier|*
name|gdef
parameter_list|,
name|HB_UShort
name|glyphID
parameter_list|,
name|HB_UShort
name|property
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_UShort
name|class
decl_stmt|,
name|new_class
decl_stmt|,
name|index
init|=
literal|0
decl_stmt|;
comment|/* shut compiler up */
name|HB_UShort
name|byte
decl_stmt|,
name|bits
decl_stmt|,
name|mask
decl_stmt|;
name|HB_UShort
name|array_index
decl_stmt|,
name|glyph_index
decl_stmt|,
name|count
decl_stmt|;
name|HB_ClassRangeRecord
modifier|*
name|gcrr
decl_stmt|;
name|HB_UShort
modifier|*
modifier|*
name|ngc
decl_stmt|;
name|error
operator|=
name|_HB_OPEN_Get_Class
argument_list|(
operator|&
name|gdef
operator|->
name|GlyphClassDef
argument_list|,
name|glyphID
argument_list|,
operator|&
name|class
argument_list|,
operator|&
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|HB_Err_Not_Covered
condition|)
return|return
name|error
return|;
comment|/* we don't accept glyphs covered in `GlyphClassDef' */
if|if
condition|(
operator|!
name|error
condition|)
return|return
name|HB_Err_Not_Covered
return|;
switch|switch
condition|(
name|property
condition|)
block|{
case|case
literal|0
case|:
name|new_class
operator|=
name|UNCLASSIFIED_GLYPH
expr_stmt|;
break|break;
case|case
name|HB_GDEF_BASE_GLYPH
case|:
name|new_class
operator|=
name|SIMPLE_GLYPH
expr_stmt|;
break|break;
case|case
name|HB_GDEF_LIGATURE
case|:
name|new_class
operator|=
name|LIGATURE_GLYPH
expr_stmt|;
break|break;
case|case
name|HB_GDEF_MARK
case|:
name|new_class
operator|=
name|MARK_GLYPH
expr_stmt|;
break|break;
case|case
name|HB_GDEF_COMPONENT
case|:
name|new_class
operator|=
name|COMPONENT_GLYPH
expr_stmt|;
break|break;
default|default:
return|return
name|ERR
argument_list|(
name|HB_Err_Invalid_Argument
argument_list|)
return|;
block|}
name|count
operator|=
name|gdef
operator|->
name|GlyphClassDef
operator|.
name|cd
operator|.
name|cd2
operator|.
name|ClassRangeCount
expr_stmt|;
name|gcrr
operator|=
name|gdef
operator|->
name|GlyphClassDef
operator|.
name|cd
operator|.
name|cd2
operator|.
name|ClassRangeRecord
expr_stmt|;
name|ngc
operator|=
name|gdef
operator|->
name|NewGlyphClasses
expr_stmt|;
if|if
condition|(
name|index
operator|<
name|count
operator|&&
name|glyphID
operator|<
name|gcrr
index|[
name|index
index|]
operator|.
name|Start
condition|)
block|{
name|array_index
operator|=
name|index
expr_stmt|;
if|if
condition|(
name|index
operator|==
literal|0
condition|)
name|glyph_index
operator|=
name|glyphID
expr_stmt|;
else|else
name|glyph_index
operator|=
name|glyphID
operator|-
name|gcrr
index|[
name|index
operator|-
literal|1
index|]
operator|.
name|End
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|array_index
operator|=
name|index
operator|+
literal|1
expr_stmt|;
name|glyph_index
operator|=
name|glyphID
operator|-
name|gcrr
index|[
name|index
index|]
operator|.
name|End
operator|-
literal|1
expr_stmt|;
block|}
name|byte
operator|=
name|ngc
index|[
name|array_index
index|]
index|[
name|glyph_index
operator|/
literal|4
index|]
expr_stmt|;
name|bits
operator|=
name|byte
operator|>>
operator|(
literal|16
operator|-
operator|(
name|glyph_index
operator|%
literal|4
operator|+
literal|1
operator|)
operator|*
literal|4
operator|)
expr_stmt|;
name|class
operator|=
name|bits
operator|&
literal|0x000F
expr_stmt|;
comment|/* we don't overwrite existing entries */
if|if
condition|(
operator|!
name|class
condition|)
block|{
name|bits
operator|=
name|new_class
operator|<<
operator|(
literal|16
operator|-
operator|(
name|glyph_index
operator|%
literal|4
operator|+
literal|1
operator|)
operator|*
literal|4
operator|)
expr_stmt|;
name|mask
operator|=
operator|~
operator|(
literal|0x000F
operator|<<
operator|(
literal|16
operator|-
operator|(
name|glyph_index
operator|%
literal|4
operator|+
literal|1
operator|)
operator|*
literal|4
operator|)
operator|)
expr_stmt|;
name|ngc
index|[
name|array_index
index|]
index|[
name|glyph_index
operator|/
literal|4
index|]
operator|&=
name|mask
expr_stmt|;
name|ngc
index|[
name|array_index
index|]
index|[
name|glyph_index
operator|/
literal|4
index|]
operator||=
name|bits
expr_stmt|;
block|}
return|return
name|HB_Err_Ok
return|;
block|}
end_function
begin_function
name|HB_INTERNAL
name|HB_Error
DECL|function|_HB_GDEF_Check_Property
name|_HB_GDEF_Check_Property
parameter_list|(
name|HB_GDEFHeader
modifier|*
name|gdef
parameter_list|,
name|HB_GlyphItem
name|gitem
parameter_list|,
name|HB_UShort
name|flags
parameter_list|,
name|HB_UShort
modifier|*
name|property
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
if|if
condition|(
name|gdef
condition|)
block|{
name|HB_UShort
name|basic_glyph_class
decl_stmt|;
name|HB_UShort
name|desired_attachment_class
decl_stmt|;
if|if
condition|(
name|gitem
operator|->
name|gproperties
operator|==
name|HB_GLYPH_PROPERTIES_UNKNOWN
condition|)
block|{
name|error
operator|=
name|HB_GDEF_Get_Glyph_Property
argument_list|(
name|gdef
argument_list|,
name|gitem
operator|->
name|gindex
argument_list|,
operator|&
name|gitem
operator|->
name|gproperties
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
block|}
operator|*
name|property
operator|=
name|gitem
operator|->
name|gproperties
expr_stmt|;
comment|/* If the glyph was found in the MarkAttachmentClass table,      * then that class value is the high byte of the result,      * otherwise the low byte contains the basic type of the glyph      * as defined by the GlyphClassDef table.      */
if|if
condition|(
operator|*
name|property
operator|&
name|HB_LOOKUP_FLAG_IGNORE_SPECIAL_MARKS
condition|)
name|basic_glyph_class
operator|=
name|HB_GDEF_MARK
expr_stmt|;
else|else
name|basic_glyph_class
operator|=
operator|*
name|property
expr_stmt|;
comment|/* Return Not_Covered, if, for example, basic_glyph_class      * is HB_GDEF_LIGATURE and LookFlags includes HB_LOOKUP_FLAG_IGNORE_LIGATURES      */
if|if
condition|(
name|flags
operator|&
name|basic_glyph_class
condition|)
return|return
name|HB_Err_Not_Covered
return|;
comment|/* The high byte of LookupFlags has the meaning      * "ignore marks of attachment type different than      * the attachment type specified."      */
name|desired_attachment_class
operator|=
name|flags
operator|&
name|HB_LOOKUP_FLAG_IGNORE_SPECIAL_MARKS
expr_stmt|;
if|if
condition|(
name|desired_attachment_class
condition|)
block|{
if|if
condition|(
name|basic_glyph_class
operator|==
name|HB_GDEF_MARK
operator|&&
operator|*
name|property
operator|!=
name|desired_attachment_class
condition|)
return|return
name|HB_Err_Not_Covered
return|;
block|}
block|}
else|else
block|{
operator|*
name|property
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|HB_Err_Ok
return|;
block|}
end_function
begin_function
name|HB_INTERNAL
name|HB_Error
DECL|function|_HB_GDEF_LoadMarkAttachClassDef_From_LookupFlags
name|_HB_GDEF_LoadMarkAttachClassDef_From_LookupFlags
parameter_list|(
name|HB_GDEFHeader
modifier|*
name|gdef
parameter_list|,
name|HB_Stream
name|stream
parameter_list|,
name|HB_Lookup
modifier|*
name|lo
parameter_list|,
name|HB_UShort
name|num_lookups
parameter_list|)
block|{
name|HB_Error
name|error
init|=
name|HB_Err_Ok
decl_stmt|;
name|HB_UShort
name|i
decl_stmt|;
comment|/* We now check the LookupFlags for values larger than 0xFF to find      out whether we need to load the `MarkAttachClassDef' field of the      GDEF table -- this hack is necessary for OpenType 1.2 tables since      the version field of the GDEF table hasn't been incremented.       For constructed GDEF tables, we only load it if      `MarkAttachClassDef_offset' is not zero (nevertheless, a build of      a constructed mark attach table is not supported currently).       */
if|if
condition|(
name|gdef
operator|&&
name|gdef
operator|->
name|MarkAttachClassDef_offset
operator|&&
operator|!
name|gdef
operator|->
name|MarkAttachClassDef
operator|.
name|loaded
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_lookups
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|lo
index|[
name|i
index|]
operator|.
name|LookupFlag
operator|&
name|HB_LOOKUP_FLAG_IGNORE_SPECIAL_MARKS
condition|)
block|{
if|if
condition|(
name|FILE_Seek
argument_list|(
name|gdef
operator|->
name|MarkAttachClassDef_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|_HB_OPEN_Load_ClassDefinition
argument_list|(
operator|&
name|gdef
operator|->
name|MarkAttachClassDef
argument_list|,
literal|256
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
goto|goto
name|Done
goto|;
break|break;
block|}
block|}
block|}
name|Done
label|:
return|return
name|error
return|;
block|}
end_function
begin_comment
comment|/* END */
end_comment
end_unit
