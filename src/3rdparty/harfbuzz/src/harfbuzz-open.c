begin_unit
begin_comment
comment|/*  * Copyright (C) 1998-2004  David Turner and Werner Lemberg  * Copyright (C) 2006  Behdad Esfahbod  *  * This is part of HarfBuzz, an OpenType Layout engine library.  *  * Permission is hereby granted, without written agreement and without  * license or royalty fees, to use, copy, modify, and distribute this  * software and its documentation for any purpose, provided that the  * above copyright notice and the following two paragraphs appear in  * all copies of this software.  *  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH  * DAMAGE.  *  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS  * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.  */
end_comment
begin_include
include|#
directive|include
file|"harfbuzz-impl.h"
end_include
begin_include
include|#
directive|include
file|"harfbuzz-open-private.h"
end_include
begin_comment
comment|/***************************  * Script related functions  ***************************/
end_comment
begin_comment
comment|/* LangSys */
end_comment
begin_function
DECL|function|Load_LangSys
specifier|static
name|HB_Error
name|Load_LangSys
parameter_list|(
name|HB_LangSys
modifier|*
name|ls
parameter_list|,
name|HB_Stream
name|stream
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_UShort
name|n
decl_stmt|,
name|count
decl_stmt|;
name|HB_UShort
modifier|*
name|fi
decl_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|6L
argument_list|)
condition|)
return|return
name|error
return|;
name|ls
operator|->
name|LookupOrderOffset
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
comment|/* should be 0 */
name|ls
operator|->
name|ReqFeatureIndex
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|count
operator|=
name|ls
operator|->
name|FeatureCount
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|ls
operator|->
name|FeatureIndex
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|ls
operator|->
name|FeatureIndex
argument_list|,
name|count
argument_list|,
name|HB_UShort
argument_list|)
condition|)
return|return
name|error
return|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
name|count
operator|*
literal|2L
argument_list|)
condition|)
block|{
name|FREE
argument_list|(
name|ls
operator|->
name|FeatureIndex
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|fi
operator|=
name|ls
operator|->
name|FeatureIndex
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
name|fi
index|[
name|n
index|]
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
return|return
name|HB_Err_Ok
return|;
block|}
end_function
begin_function
DECL|function|Free_LangSys
specifier|static
name|void
name|Free_LangSys
parameter_list|(
name|HB_LangSys
modifier|*
name|ls
parameter_list|)
block|{
name|FREE
argument_list|(
name|ls
operator|->
name|FeatureIndex
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* Script */
end_comment
begin_function
DECL|function|Load_Script
specifier|static
name|HB_Error
name|Load_Script
parameter_list|(
name|HB_ScriptTable
modifier|*
name|s
parameter_list|,
name|HB_Stream
name|stream
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_UShort
name|n
decl_stmt|,
name|m
decl_stmt|,
name|count
decl_stmt|;
name|HB_UInt
name|cur_offset
decl_stmt|,
name|new_offset
decl_stmt|,
name|base_offset
decl_stmt|;
name|HB_LangSysRecord
modifier|*
name|lsr
decl_stmt|;
name|base_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
return|return
name|error
return|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
operator|+
name|base_offset
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
if|if
condition|(
name|new_offset
operator|!=
name|base_offset
condition|)
comment|/* not a NULL offset */
block|{
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|Load_LangSys
argument_list|(
operator|&
name|s
operator|->
name|DefaultLangSys
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
return|return
name|error
return|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* we create a DefaultLangSys table with no entries */
name|s
operator|->
name|DefaultLangSys
operator|.
name|LookupOrderOffset
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|DefaultLangSys
operator|.
name|ReqFeatureIndex
operator|=
literal|0xFFFF
expr_stmt|;
name|s
operator|->
name|DefaultLangSys
operator|.
name|FeatureCount
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|DefaultLangSys
operator|.
name|FeatureIndex
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail2
goto|;
name|count
operator|=
name|s
operator|->
name|LangSysCount
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
comment|/* safety check; otherwise the official handling of TrueType Open      fonts won't work */
if|if
condition|(
name|s
operator|->
name|LangSysCount
operator|==
literal|0
operator|&&
name|s
operator|->
name|DefaultLangSys
operator|.
name|FeatureCount
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|HB_Err_Not_Covered
expr_stmt|;
goto|goto
name|Fail2
goto|;
block|}
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|s
operator|->
name|LangSysRecord
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|s
operator|->
name|LangSysRecord
argument_list|,
name|count
argument_list|,
name|HB_LangSysRecord
argument_list|)
condition|)
goto|goto
name|Fail2
goto|;
name|lsr
operator|=
name|s
operator|->
name|LangSysRecord
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|6L
argument_list|)
condition|)
goto|goto
name|Fail1
goto|;
name|lsr
index|[
name|n
index|]
operator|.
name|LangSysTag
operator|=
name|GET_ULong
argument_list|()
expr_stmt|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
operator|+
name|base_offset
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|Load_LangSys
argument_list|(
operator|&
name|lsr
index|[
name|n
index|]
operator|.
name|LangSys
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
goto|goto
name|Fail1
goto|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
block|}
return|return
name|HB_Err_Ok
return|;
name|Fail1
label|:
for|for
control|(
name|m
operator|=
literal|0
init|;
name|m
operator|<
name|n
condition|;
name|m
operator|++
control|)
name|Free_LangSys
argument_list|(
operator|&
name|lsr
index|[
name|m
index|]
operator|.
name|LangSys
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|s
operator|->
name|LangSysRecord
argument_list|)
expr_stmt|;
name|Fail2
label|:
name|Free_LangSys
argument_list|(
operator|&
name|s
operator|->
name|DefaultLangSys
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_function
DECL|function|Free_Script
specifier|static
name|void
name|Free_Script
parameter_list|(
name|HB_ScriptTable
modifier|*
name|s
parameter_list|)
block|{
name|HB_UShort
name|n
decl_stmt|,
name|count
decl_stmt|;
name|HB_LangSysRecord
modifier|*
name|lsr
decl_stmt|;
name|Free_LangSys
argument_list|(
operator|&
name|s
operator|->
name|DefaultLangSys
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|LangSysRecord
condition|)
block|{
name|count
operator|=
name|s
operator|->
name|LangSysCount
expr_stmt|;
name|lsr
operator|=
name|s
operator|->
name|LangSysRecord
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
name|Free_LangSys
argument_list|(
operator|&
name|lsr
index|[
name|n
index|]
operator|.
name|LangSys
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|lsr
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/* ScriptList */
end_comment
begin_function
name|HB_INTERNAL
name|HB_Error
DECL|function|_HB_OPEN_Load_ScriptList
name|_HB_OPEN_Load_ScriptList
parameter_list|(
name|HB_ScriptList
modifier|*
name|sl
parameter_list|,
name|HB_Stream
name|stream
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_UShort
name|n
decl_stmt|,
name|script_count
decl_stmt|;
name|HB_UInt
name|cur_offset
decl_stmt|,
name|new_offset
decl_stmt|,
name|base_offset
decl_stmt|;
name|HB_ScriptRecord
modifier|*
name|sr
decl_stmt|;
name|base_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
return|return
name|error
return|;
name|script_count
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|sl
operator|->
name|ScriptRecord
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|sl
operator|->
name|ScriptRecord
argument_list|,
name|script_count
argument_list|,
name|HB_ScriptRecord
argument_list|)
condition|)
return|return
name|error
return|;
name|sr
operator|=
name|sl
operator|->
name|ScriptRecord
expr_stmt|;
name|sl
operator|->
name|ScriptCount
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|script_count
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|6L
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
name|sr
index|[
name|sl
operator|->
name|ScriptCount
index|]
operator|.
name|ScriptTag
operator|=
name|GET_ULong
argument_list|()
expr_stmt|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
operator|+
name|base_offset
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
name|error
operator|=
name|Load_Script
argument_list|(
operator|&
name|sr
index|[
name|sl
operator|->
name|ScriptCount
index|]
operator|.
name|Script
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|HB_Err_Ok
condition|)
name|sl
operator|->
name|ScriptCount
operator|+=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|error
operator|!=
name|HB_Err_Not_Covered
condition|)
goto|goto
name|Fail
goto|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
block|}
comment|/* Empty tables are harmless and generated by fontforge.    * See http://bugzilla.gnome.org/show_bug.cgi?id=347073    */
if|#
directive|if
literal|0
block|if ( sl->ScriptCount == 0 )   {     error = ERR(HB_Err_Invalid_SubTable);     goto Fail;   }
endif|#
directive|endif
return|return
name|HB_Err_Ok
return|;
name|Fail
label|:
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|sl
operator|->
name|ScriptCount
condition|;
name|n
operator|++
control|)
name|Free_Script
argument_list|(
operator|&
name|sr
index|[
name|n
index|]
operator|.
name|Script
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|sl
operator|->
name|ScriptRecord
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_function
name|HB_INTERNAL
name|void
DECL|function|_HB_OPEN_Free_ScriptList
name|_HB_OPEN_Free_ScriptList
parameter_list|(
name|HB_ScriptList
modifier|*
name|sl
parameter_list|)
block|{
name|HB_UShort
name|n
decl_stmt|,
name|count
decl_stmt|;
name|HB_ScriptRecord
modifier|*
name|sr
decl_stmt|;
if|if
condition|(
name|sl
operator|->
name|ScriptRecord
condition|)
block|{
name|count
operator|=
name|sl
operator|->
name|ScriptCount
expr_stmt|;
name|sr
operator|=
name|sl
operator|->
name|ScriptRecord
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
name|Free_Script
argument_list|(
operator|&
name|sr
index|[
name|n
index|]
operator|.
name|Script
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|sr
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*********************************  * Feature List related functions  *********************************/
end_comment
begin_comment
comment|/* Feature */
end_comment
begin_function
DECL|function|Load_Feature
specifier|static
name|HB_Error
name|Load_Feature
parameter_list|(
name|HB_Feature
modifier|*
name|f
parameter_list|,
name|HB_Stream
name|stream
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_UShort
name|n
decl_stmt|,
name|count
decl_stmt|;
name|HB_UShort
modifier|*
name|lli
decl_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|4L
argument_list|)
condition|)
return|return
name|error
return|;
name|f
operator|->
name|FeatureParams
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
comment|/* should be 0 */
name|count
operator|=
name|f
operator|->
name|LookupListCount
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|f
operator|->
name|LookupListIndex
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|f
operator|->
name|LookupListIndex
argument_list|,
name|count
argument_list|,
name|HB_UShort
argument_list|)
condition|)
return|return
name|error
return|;
name|lli
operator|=
name|f
operator|->
name|LookupListIndex
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
name|count
operator|*
literal|2L
argument_list|)
condition|)
block|{
name|FREE
argument_list|(
name|f
operator|->
name|LookupListIndex
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
name|lli
index|[
name|n
index|]
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
return|return
name|HB_Err_Ok
return|;
block|}
end_function
begin_function
DECL|function|Free_Feature
specifier|static
name|void
name|Free_Feature
parameter_list|(
name|HB_Feature
modifier|*
name|f
parameter_list|)
block|{
name|FREE
argument_list|(
name|f
operator|->
name|LookupListIndex
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* FeatureList */
end_comment
begin_function
name|HB_INTERNAL
name|HB_Error
DECL|function|_HB_OPEN_Load_FeatureList
name|_HB_OPEN_Load_FeatureList
parameter_list|(
name|HB_FeatureList
modifier|*
name|fl
parameter_list|,
name|HB_Stream
name|stream
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_UShort
name|n
decl_stmt|,
name|m
decl_stmt|,
name|count
decl_stmt|;
name|HB_UInt
name|cur_offset
decl_stmt|,
name|new_offset
decl_stmt|,
name|base_offset
decl_stmt|;
name|HB_FeatureRecord
modifier|*
name|fr
decl_stmt|;
name|base_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
return|return
name|error
return|;
name|count
operator|=
name|fl
operator|->
name|FeatureCount
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|fl
operator|->
name|FeatureRecord
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|fl
operator|->
name|FeatureRecord
argument_list|,
name|count
argument_list|,
name|HB_FeatureRecord
argument_list|)
condition|)
return|return
name|error
return|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|fl
operator|->
name|ApplyOrder
argument_list|,
name|count
argument_list|,
name|HB_UShort
argument_list|)
condition|)
goto|goto
name|Fail2
goto|;
name|fl
operator|->
name|ApplyCount
operator|=
literal|0
expr_stmt|;
name|fr
operator|=
name|fl
operator|->
name|FeatureRecord
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|6L
argument_list|)
condition|)
goto|goto
name|Fail1
goto|;
name|fr
index|[
name|n
index|]
operator|.
name|FeatureTag
operator|=
name|GET_ULong
argument_list|()
expr_stmt|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
operator|+
name|base_offset
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|Load_Feature
argument_list|(
operator|&
name|fr
index|[
name|n
index|]
operator|.
name|Feature
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
goto|goto
name|Fail1
goto|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
block|}
return|return
name|HB_Err_Ok
return|;
name|Fail1
label|:
for|for
control|(
name|m
operator|=
literal|0
init|;
name|m
operator|<
name|n
condition|;
name|m
operator|++
control|)
name|Free_Feature
argument_list|(
operator|&
name|fr
index|[
name|m
index|]
operator|.
name|Feature
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|fl
operator|->
name|ApplyOrder
argument_list|)
expr_stmt|;
name|Fail2
label|:
name|FREE
argument_list|(
name|fl
operator|->
name|FeatureRecord
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_function
name|HB_INTERNAL
name|void
DECL|function|_HB_OPEN_Free_FeatureList
name|_HB_OPEN_Free_FeatureList
parameter_list|(
name|HB_FeatureList
modifier|*
name|fl
parameter_list|)
block|{
name|HB_UShort
name|n
decl_stmt|,
name|count
decl_stmt|;
name|HB_FeatureRecord
modifier|*
name|fr
decl_stmt|;
if|if
condition|(
name|fl
operator|->
name|FeatureRecord
condition|)
block|{
name|count
operator|=
name|fl
operator|->
name|FeatureCount
expr_stmt|;
name|fr
operator|=
name|fl
operator|->
name|FeatureRecord
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
name|Free_Feature
argument_list|(
operator|&
name|fr
index|[
name|n
index|]
operator|.
name|Feature
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|fr
argument_list|)
expr_stmt|;
block|}
name|FREE
argument_list|(
name|fl
operator|->
name|ApplyOrder
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/********************************  * Lookup List related functions  ********************************/
end_comment
begin_comment
comment|/* the subroutines of the following two functions are defined in    ftxgsub.c and ftxgpos.c respectively                          */
end_comment
begin_comment
comment|/* SubTable */
end_comment
begin_function
DECL|function|Load_SubTable
specifier|static
name|HB_Error
name|Load_SubTable
parameter_list|(
name|HB_SubTable
modifier|*
name|st
parameter_list|,
name|HB_Stream
name|stream
parameter_list|,
name|HB_Type
name|table_type
parameter_list|,
name|HB_UShort
name|lookup_type
parameter_list|)
block|{
if|if
condition|(
name|table_type
operator|==
name|HB_Type_GSUB
condition|)
return|return
name|_HB_GSUB_Load_SubTable
argument_list|(
operator|&
name|st
operator|->
name|st
operator|.
name|gsub
argument_list|,
name|stream
argument_list|,
name|lookup_type
argument_list|)
return|;
else|else
return|return
name|_HB_GPOS_Load_SubTable
argument_list|(
operator|&
name|st
operator|->
name|st
operator|.
name|gpos
argument_list|,
name|stream
argument_list|,
name|lookup_type
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|Free_SubTable
specifier|static
name|void
name|Free_SubTable
parameter_list|(
name|HB_SubTable
modifier|*
name|st
parameter_list|,
name|HB_Type
name|table_type
parameter_list|,
name|HB_UShort
name|lookup_type
parameter_list|)
block|{
if|if
condition|(
name|table_type
operator|==
name|HB_Type_GSUB
condition|)
name|_HB_GSUB_Free_SubTable
argument_list|(
operator|&
name|st
operator|->
name|st
operator|.
name|gsub
argument_list|,
name|lookup_type
argument_list|)
expr_stmt|;
else|else
name|_HB_GPOS_Free_SubTable
argument_list|(
operator|&
name|st
operator|->
name|st
operator|.
name|gpos
argument_list|,
name|lookup_type
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* Lookup */
end_comment
begin_function
DECL|function|Load_Lookup
specifier|static
name|HB_Error
name|Load_Lookup
parameter_list|(
name|HB_Lookup
modifier|*
name|l
parameter_list|,
name|HB_Stream
name|stream
parameter_list|,
name|HB_Type
name|type
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_UShort
name|n
decl_stmt|,
name|m
decl_stmt|,
name|count
decl_stmt|;
name|HB_UInt
name|cur_offset
decl_stmt|,
name|new_offset
decl_stmt|,
name|base_offset
decl_stmt|;
name|HB_SubTable
modifier|*
name|st
decl_stmt|;
name|HB_Bool
name|is_extension
init|=
name|FALSE
decl_stmt|;
name|base_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|6L
argument_list|)
condition|)
return|return
name|error
return|;
name|l
operator|->
name|LookupType
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|l
operator|->
name|LookupFlag
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|count
operator|=
name|l
operator|->
name|SubTableCount
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|l
operator|->
name|SubTable
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|l
operator|->
name|SubTable
argument_list|,
name|count
argument_list|,
name|HB_SubTable
argument_list|)
condition|)
return|return
name|error
return|;
name|st
operator|=
name|l
operator|->
name|SubTable
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|==
name|HB_Type_GSUB
operator|&&
name|l
operator|->
name|LookupType
operator|==
name|HB_GSUB_LOOKUP_EXTENSION
operator|)
operator|||
operator|(
name|type
operator|==
name|HB_Type_GPOS
operator|&&
name|l
operator|->
name|LookupType
operator|==
name|HB_GPOS_LOOKUP_EXTENSION
operator|)
condition|)
name|is_extension
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
operator|+
name|base_offset
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|is_extension
condition|)
block|{
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
name|ACCESS_Frame
argument_list|(
literal|8L
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
if|if
condition|(
name|GET_UShort
argument_list|()
operator|!=
literal|1
condition|)
comment|/* format should be 1 */
goto|goto
name|Fail
goto|;
name|l
operator|->
name|LookupType
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|new_offset
operator|+=
name|GET_ULong
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|Load_SubTable
argument_list|(
operator|&
name|st
index|[
name|n
index|]
argument_list|,
name|stream
argument_list|,
name|type
argument_list|,
name|l
operator|->
name|LookupType
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
goto|goto
name|Fail
goto|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
block|}
return|return
name|HB_Err_Ok
return|;
name|Fail
label|:
for|for
control|(
name|m
operator|=
literal|0
init|;
name|m
operator|<
name|n
condition|;
name|m
operator|++
control|)
name|Free_SubTable
argument_list|(
operator|&
name|st
index|[
name|m
index|]
argument_list|,
name|type
argument_list|,
name|l
operator|->
name|LookupType
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|l
operator|->
name|SubTable
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_function
DECL|function|Free_Lookup
specifier|static
name|void
name|Free_Lookup
parameter_list|(
name|HB_Lookup
modifier|*
name|l
parameter_list|,
name|HB_Type
name|type
parameter_list|)
block|{
name|HB_UShort
name|n
decl_stmt|,
name|count
decl_stmt|;
name|HB_SubTable
modifier|*
name|st
decl_stmt|;
if|if
condition|(
name|l
operator|->
name|SubTable
condition|)
block|{
name|count
operator|=
name|l
operator|->
name|SubTableCount
expr_stmt|;
name|st
operator|=
name|l
operator|->
name|SubTable
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
name|Free_SubTable
argument_list|(
operator|&
name|st
index|[
name|n
index|]
argument_list|,
name|type
argument_list|,
name|l
operator|->
name|LookupType
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|st
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/* LookupList */
end_comment
begin_function
name|HB_INTERNAL
name|HB_Error
DECL|function|_HB_OPEN_Load_LookupList
name|_HB_OPEN_Load_LookupList
parameter_list|(
name|HB_LookupList
modifier|*
name|ll
parameter_list|,
name|HB_Stream
name|stream
parameter_list|,
name|HB_Type
name|type
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_UShort
name|n
decl_stmt|,
name|m
decl_stmt|,
name|count
decl_stmt|;
name|HB_UInt
name|cur_offset
decl_stmt|,
name|new_offset
decl_stmt|,
name|base_offset
decl_stmt|;
name|HB_Lookup
modifier|*
name|l
decl_stmt|;
name|base_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
return|return
name|error
return|;
name|count
operator|=
name|ll
operator|->
name|LookupCount
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|ll
operator|->
name|Lookup
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|ll
operator|->
name|Lookup
argument_list|,
name|count
argument_list|,
name|HB_Lookup
argument_list|)
condition|)
return|return
name|error
return|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|ll
operator|->
name|Properties
argument_list|,
name|count
argument_list|,
name|HB_UInt
argument_list|)
condition|)
goto|goto
name|Fail2
goto|;
name|l
operator|=
name|ll
operator|->
name|Lookup
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail1
goto|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
operator|+
name|base_offset
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|Load_Lookup
argument_list|(
operator|&
name|l
index|[
name|n
index|]
argument_list|,
name|stream
argument_list|,
name|type
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
goto|goto
name|Fail1
goto|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
block|}
return|return
name|HB_Err_Ok
return|;
name|Fail1
label|:
name|FREE
argument_list|(
name|ll
operator|->
name|Properties
argument_list|)
expr_stmt|;
for|for
control|(
name|m
operator|=
literal|0
init|;
name|m
operator|<
name|n
condition|;
name|m
operator|++
control|)
name|Free_Lookup
argument_list|(
operator|&
name|l
index|[
name|m
index|]
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|Fail2
label|:
name|FREE
argument_list|(
name|ll
operator|->
name|Lookup
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_function
name|HB_INTERNAL
name|void
DECL|function|_HB_OPEN_Free_LookupList
name|_HB_OPEN_Free_LookupList
parameter_list|(
name|HB_LookupList
modifier|*
name|ll
parameter_list|,
name|HB_Type
name|type
parameter_list|)
block|{
name|HB_UShort
name|n
decl_stmt|,
name|count
decl_stmt|;
name|HB_Lookup
modifier|*
name|l
decl_stmt|;
name|FREE
argument_list|(
name|ll
operator|->
name|Properties
argument_list|)
expr_stmt|;
if|if
condition|(
name|ll
operator|->
name|Lookup
condition|)
block|{
name|count
operator|=
name|ll
operator|->
name|LookupCount
expr_stmt|;
name|l
operator|=
name|ll
operator|->
name|Lookup
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
name|Free_Lookup
argument_list|(
operator|&
name|l
index|[
name|n
index|]
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*****************************  * Coverage related functions  *****************************/
end_comment
begin_comment
comment|/* CoverageFormat1 */
end_comment
begin_function
DECL|function|Load_Coverage1
specifier|static
name|HB_Error
name|Load_Coverage1
parameter_list|(
name|HB_CoverageFormat1
modifier|*
name|cf1
parameter_list|,
name|HB_Stream
name|stream
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_UShort
name|n
decl_stmt|,
name|count
decl_stmt|;
name|HB_UShort
modifier|*
name|ga
decl_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
return|return
name|error
return|;
name|count
operator|=
name|cf1
operator|->
name|GlyphCount
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cf1
operator|->
name|GlyphArray
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|cf1
operator|->
name|GlyphArray
argument_list|,
name|count
argument_list|,
name|HB_UShort
argument_list|)
condition|)
return|return
name|error
return|;
name|ga
operator|=
name|cf1
operator|->
name|GlyphArray
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
name|count
operator|*
literal|2L
argument_list|)
condition|)
block|{
name|FREE
argument_list|(
name|cf1
operator|->
name|GlyphArray
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
name|ga
index|[
name|n
index|]
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
return|return
name|HB_Err_Ok
return|;
block|}
end_function
begin_function
DECL|function|Free_Coverage1
specifier|static
name|void
name|Free_Coverage1
parameter_list|(
name|HB_CoverageFormat1
modifier|*
name|cf1
parameter_list|)
block|{
name|FREE
argument_list|(
name|cf1
operator|->
name|GlyphArray
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* CoverageFormat2 */
end_comment
begin_function
DECL|function|Load_Coverage2
specifier|static
name|HB_Error
name|Load_Coverage2
parameter_list|(
name|HB_CoverageFormat2
modifier|*
name|cf2
parameter_list|,
name|HB_Stream
name|stream
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_UShort
name|n
decl_stmt|,
name|count
decl_stmt|;
name|HB_RangeRecord
modifier|*
name|rr
decl_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
return|return
name|error
return|;
name|count
operator|=
name|cf2
operator|->
name|RangeCount
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cf2
operator|->
name|RangeRecord
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|cf2
operator|->
name|RangeRecord
argument_list|,
name|count
argument_list|,
name|HB_RangeRecord
argument_list|)
condition|)
return|return
name|error
return|;
name|rr
operator|=
name|cf2
operator|->
name|RangeRecord
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
name|count
operator|*
literal|6L
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
block|{
name|rr
index|[
name|n
index|]
operator|.
name|Start
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|rr
index|[
name|n
index|]
operator|.
name|End
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|rr
index|[
name|n
index|]
operator|.
name|StartCoverageIndex
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
comment|/* sanity check; we are limited to 16bit integers */
if|if
condition|(
name|rr
index|[
name|n
index|]
operator|.
name|Start
operator|>
name|rr
index|[
name|n
index|]
operator|.
name|End
operator|||
operator|(
name|rr
index|[
name|n
index|]
operator|.
name|End
operator|-
name|rr
index|[
name|n
index|]
operator|.
name|Start
operator|+
operator|(
name|long
operator|)
name|rr
index|[
name|n
index|]
operator|.
name|StartCoverageIndex
operator|)
operator|>=
literal|0x10000L
condition|)
block|{
name|error
operator|=
name|ERR
argument_list|(
name|HB_Err_Invalid_SubTable
argument_list|)
expr_stmt|;
goto|goto
name|Fail
goto|;
block|}
block|}
name|FORGET_Frame
argument_list|()
expr_stmt|;
return|return
name|HB_Err_Ok
return|;
name|Fail
label|:
name|FREE
argument_list|(
name|cf2
operator|->
name|RangeRecord
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_function
DECL|function|Free_Coverage2
specifier|static
name|void
name|Free_Coverage2
parameter_list|(
name|HB_CoverageFormat2
modifier|*
name|cf2
parameter_list|)
block|{
name|FREE
argument_list|(
name|cf2
operator|->
name|RangeRecord
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
name|HB_INTERNAL
name|HB_Error
DECL|function|_HB_OPEN_Load_Coverage
name|_HB_OPEN_Load_Coverage
parameter_list|(
name|HB_Coverage
modifier|*
name|c
parameter_list|,
name|HB_Stream
name|stream
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
return|return
name|error
return|;
name|c
operator|->
name|CoverageFormat
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|c
operator|->
name|CoverageFormat
condition|)
block|{
case|case
literal|1
case|:
return|return
name|Load_Coverage1
argument_list|(
operator|&
name|c
operator|->
name|cf
operator|.
name|cf1
argument_list|,
name|stream
argument_list|)
return|;
case|case
literal|2
case|:
return|return
name|Load_Coverage2
argument_list|(
operator|&
name|c
operator|->
name|cf
operator|.
name|cf2
argument_list|,
name|stream
argument_list|)
return|;
default|default:
return|return
name|ERR
argument_list|(
name|HB_Err_Invalid_SubTable_Format
argument_list|)
return|;
block|}
return|return
name|HB_Err_Ok
return|;
comment|/* never reached */
block|}
end_function
begin_function
name|HB_INTERNAL
name|void
DECL|function|_HB_OPEN_Free_Coverage
name|_HB_OPEN_Free_Coverage
parameter_list|(
name|HB_Coverage
modifier|*
name|c
parameter_list|)
block|{
switch|switch
condition|(
name|c
operator|->
name|CoverageFormat
condition|)
block|{
case|case
literal|1
case|:
name|Free_Coverage1
argument_list|(
operator|&
name|c
operator|->
name|cf
operator|.
name|cf1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|Free_Coverage2
argument_list|(
operator|&
name|c
operator|->
name|cf
operator|.
name|cf2
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function
begin_function
DECL|function|Coverage_Index1
specifier|static
name|HB_Error
name|Coverage_Index1
parameter_list|(
name|HB_CoverageFormat1
modifier|*
name|cf1
parameter_list|,
name|HB_UShort
name|glyphID
parameter_list|,
name|HB_UShort
modifier|*
name|index
parameter_list|)
block|{
name|HB_UShort
name|min
decl_stmt|,
name|max
decl_stmt|,
name|new_min
decl_stmt|,
name|new_max
decl_stmt|,
name|middle
decl_stmt|;
name|HB_UShort
modifier|*
name|array
init|=
name|cf1
operator|->
name|GlyphArray
decl_stmt|;
comment|/* binary search */
if|if
condition|(
name|cf1
operator|->
name|GlyphCount
operator|==
literal|0
condition|)
return|return
name|HB_Err_Not_Covered
return|;
name|new_min
operator|=
literal|0
expr_stmt|;
name|new_max
operator|=
name|cf1
operator|->
name|GlyphCount
operator|-
literal|1
expr_stmt|;
do|do
block|{
name|min
operator|=
name|new_min
expr_stmt|;
name|max
operator|=
name|new_max
expr_stmt|;
comment|/* we use (min + max) / 2 = max - (max - min) / 2  to avoid        overflow and rounding errors                             */
name|middle
operator|=
name|max
operator|-
operator|(
operator|(
name|max
operator|-
name|min
operator|)
operator|>>
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|glyphID
operator|==
name|array
index|[
name|middle
index|]
condition|)
block|{
operator|*
name|index
operator|=
name|middle
expr_stmt|;
return|return
name|HB_Err_Ok
return|;
block|}
elseif|else
if|if
condition|(
name|glyphID
operator|<
name|array
index|[
name|middle
index|]
condition|)
block|{
if|if
condition|(
name|middle
operator|==
name|min
condition|)
break|break;
name|new_max
operator|=
name|middle
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|middle
operator|==
name|max
condition|)
break|break;
name|new_min
operator|=
name|middle
operator|+
literal|1
expr_stmt|;
block|}
block|}
do|while
condition|(
name|min
operator|<
name|max
condition|)
do|;
return|return
name|HB_Err_Not_Covered
return|;
block|}
end_function
begin_function
DECL|function|Coverage_Index2
specifier|static
name|HB_Error
name|Coverage_Index2
parameter_list|(
name|HB_CoverageFormat2
modifier|*
name|cf2
parameter_list|,
name|HB_UShort
name|glyphID
parameter_list|,
name|HB_UShort
modifier|*
name|index
parameter_list|)
block|{
name|HB_UShort
name|min
decl_stmt|,
name|max
decl_stmt|,
name|new_min
decl_stmt|,
name|new_max
decl_stmt|,
name|middle
decl_stmt|;
name|HB_RangeRecord
modifier|*
name|rr
init|=
name|cf2
operator|->
name|RangeRecord
decl_stmt|;
comment|/* binary search */
if|if
condition|(
name|cf2
operator|->
name|RangeCount
operator|==
literal|0
condition|)
return|return
name|HB_Err_Not_Covered
return|;
name|new_min
operator|=
literal|0
expr_stmt|;
name|new_max
operator|=
name|cf2
operator|->
name|RangeCount
operator|-
literal|1
expr_stmt|;
do|do
block|{
name|min
operator|=
name|new_min
expr_stmt|;
name|max
operator|=
name|new_max
expr_stmt|;
comment|/* we use (min + max) / 2 = max - (max - min) / 2  to avoid        overflow and rounding errors                             */
name|middle
operator|=
name|max
operator|-
operator|(
operator|(
name|max
operator|-
name|min
operator|)
operator|>>
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|glyphID
operator|>=
name|rr
index|[
name|middle
index|]
operator|.
name|Start
operator|&&
name|glyphID
operator|<=
name|rr
index|[
name|middle
index|]
operator|.
name|End
condition|)
block|{
operator|*
name|index
operator|=
name|rr
index|[
name|middle
index|]
operator|.
name|StartCoverageIndex
operator|+
name|glyphID
operator|-
name|rr
index|[
name|middle
index|]
operator|.
name|Start
expr_stmt|;
return|return
name|HB_Err_Ok
return|;
block|}
elseif|else
if|if
condition|(
name|glyphID
operator|<
name|rr
index|[
name|middle
index|]
operator|.
name|Start
condition|)
block|{
if|if
condition|(
name|middle
operator|==
name|min
condition|)
break|break;
name|new_max
operator|=
name|middle
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|middle
operator|==
name|max
condition|)
break|break;
name|new_min
operator|=
name|middle
operator|+
literal|1
expr_stmt|;
block|}
block|}
do|while
condition|(
name|min
operator|<
name|max
condition|)
do|;
return|return
name|HB_Err_Not_Covered
return|;
block|}
end_function
begin_function
name|HB_INTERNAL
name|HB_Error
DECL|function|_HB_OPEN_Coverage_Index
name|_HB_OPEN_Coverage_Index
parameter_list|(
name|HB_Coverage
modifier|*
name|c
parameter_list|,
name|HB_UShort
name|glyphID
parameter_list|,
name|HB_UShort
modifier|*
name|index
parameter_list|)
block|{
switch|switch
condition|(
name|c
operator|->
name|CoverageFormat
condition|)
block|{
case|case
literal|1
case|:
return|return
name|Coverage_Index1
argument_list|(
operator|&
name|c
operator|->
name|cf
operator|.
name|cf1
argument_list|,
name|glyphID
argument_list|,
name|index
argument_list|)
return|;
case|case
literal|2
case|:
return|return
name|Coverage_Index2
argument_list|(
operator|&
name|c
operator|->
name|cf
operator|.
name|cf2
argument_list|,
name|glyphID
argument_list|,
name|index
argument_list|)
return|;
default|default:
return|return
name|ERR
argument_list|(
name|HB_Err_Invalid_SubTable_Format
argument_list|)
return|;
block|}
return|return
name|HB_Err_Ok
return|;
comment|/* never reached */
block|}
end_function
begin_comment
comment|/*************************************  * Class Definition related functions  *************************************/
end_comment
begin_comment
comment|/* ClassDefFormat1 */
end_comment
begin_function
DECL|function|Load_ClassDef1
specifier|static
name|HB_Error
name|Load_ClassDef1
parameter_list|(
name|HB_ClassDefinition
modifier|*
name|cd
parameter_list|,
name|HB_UShort
name|limit
parameter_list|,
name|HB_Stream
name|stream
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_UShort
name|n
decl_stmt|,
name|count
decl_stmt|;
name|HB_UShort
modifier|*
name|cva
decl_stmt|;
name|HB_ClassDefFormat1
modifier|*
name|cdf1
decl_stmt|;
name|cdf1
operator|=
operator|&
name|cd
operator|->
name|cd
operator|.
name|cd1
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|4L
argument_list|)
condition|)
return|return
name|error
return|;
name|cdf1
operator|->
name|StartGlyph
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|count
operator|=
name|cdf1
operator|->
name|GlyphCount
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
comment|/* sanity check; we are limited to 16bit integers */
if|if
condition|(
name|cdf1
operator|->
name|StartGlyph
operator|+
operator|(
name|long
operator|)
name|count
operator|>=
literal|0x10000L
condition|)
return|return
name|ERR
argument_list|(
name|HB_Err_Invalid_SubTable
argument_list|)
return|;
name|cdf1
operator|->
name|ClassValueArray
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|cdf1
operator|->
name|ClassValueArray
argument_list|,
name|count
argument_list|,
name|HB_UShort
argument_list|)
condition|)
return|return
name|error
return|;
name|cva
operator|=
name|cdf1
operator|->
name|ClassValueArray
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
name|count
operator|*
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
block|{
name|cva
index|[
name|n
index|]
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
if|if
condition|(
name|cva
index|[
name|n
index|]
operator|>=
name|limit
condition|)
block|{
name|error
operator|=
name|ERR
argument_list|(
name|HB_Err_Invalid_SubTable
argument_list|)
expr_stmt|;
goto|goto
name|Fail
goto|;
block|}
block|}
name|FORGET_Frame
argument_list|()
expr_stmt|;
return|return
name|HB_Err_Ok
return|;
name|Fail
label|:
name|FREE
argument_list|(
name|cva
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_function
DECL|function|Free_ClassDef1
specifier|static
name|void
name|Free_ClassDef1
parameter_list|(
name|HB_ClassDefFormat1
modifier|*
name|cdf1
parameter_list|)
block|{
name|FREE
argument_list|(
name|cdf1
operator|->
name|ClassValueArray
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* ClassDefFormat2 */
end_comment
begin_function
DECL|function|Load_ClassDef2
specifier|static
name|HB_Error
name|Load_ClassDef2
parameter_list|(
name|HB_ClassDefinition
modifier|*
name|cd
parameter_list|,
name|HB_UShort
name|limit
parameter_list|,
name|HB_Stream
name|stream
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_UShort
name|n
decl_stmt|,
name|count
decl_stmt|;
name|HB_ClassRangeRecord
modifier|*
name|crr
decl_stmt|;
name|HB_ClassDefFormat2
modifier|*
name|cdf2
decl_stmt|;
name|cdf2
operator|=
operator|&
name|cd
operator|->
name|cd
operator|.
name|cd2
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
return|return
name|error
return|;
name|count
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|cdf2
operator|->
name|ClassRangeCount
operator|=
literal|0
expr_stmt|;
comment|/* zero for now.  we fill with the number of good entries later */
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cdf2
operator|->
name|ClassRangeRecord
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|cdf2
operator|->
name|ClassRangeRecord
argument_list|,
name|count
argument_list|,
name|HB_ClassRangeRecord
argument_list|)
condition|)
return|return
name|error
return|;
name|crr
operator|=
name|cdf2
operator|->
name|ClassRangeRecord
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
name|count
operator|*
literal|6L
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
block|{
name|crr
index|[
name|n
index|]
operator|.
name|Start
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|crr
index|[
name|n
index|]
operator|.
name|End
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|crr
index|[
name|n
index|]
operator|.
name|Class
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
comment|/* sanity check */
if|if
condition|(
name|crr
index|[
name|n
index|]
operator|.
name|Start
operator|>
name|crr
index|[
name|n
index|]
operator|.
name|End
operator|||
name|crr
index|[
name|n
index|]
operator|.
name|Class
operator|>=
name|limit
condition|)
block|{
comment|/* XXX        * Corrupt entry.  Skip it.        * This is hit by Nafees Nastaliq font for example        */
name|n
operator|--
expr_stmt|;
name|count
operator|--
expr_stmt|;
block|}
block|}
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cdf2
operator|->
name|ClassRangeCount
operator|=
name|count
expr_stmt|;
return|return
name|HB_Err_Ok
return|;
name|Fail
label|:
name|FREE
argument_list|(
name|crr
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_function
DECL|function|Free_ClassDef2
specifier|static
name|void
name|Free_ClassDef2
parameter_list|(
name|HB_ClassDefFormat2
modifier|*
name|cdf2
parameter_list|)
block|{
name|FREE
argument_list|(
name|cdf2
operator|->
name|ClassRangeRecord
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* ClassDefinition */
end_comment
begin_function
name|HB_INTERNAL
name|HB_Error
DECL|function|_HB_OPEN_Load_ClassDefinition
name|_HB_OPEN_Load_ClassDefinition
parameter_list|(
name|HB_ClassDefinition
modifier|*
name|cd
parameter_list|,
name|HB_UShort
name|limit
parameter_list|,
name|HB_Stream
name|stream
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
return|return
name|error
return|;
name|cd
operator|->
name|ClassFormat
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|cd
operator|->
name|ClassFormat
condition|)
block|{
case|case
literal|1
case|:
name|error
operator|=
name|Load_ClassDef1
argument_list|(
name|cd
argument_list|,
name|limit
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|error
operator|=
name|Load_ClassDef2
argument_list|(
name|cd
argument_list|,
name|limit
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|ERR
argument_list|(
name|HB_Err_Invalid_SubTable_Format
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|cd
operator|->
name|loaded
operator|=
name|TRUE
expr_stmt|;
return|return
name|HB_Err_Ok
return|;
block|}
end_function
begin_function
specifier|static
name|HB_Error
DECL|function|_HB_OPEN_Load_EmptyClassDefinition
name|_HB_OPEN_Load_EmptyClassDefinition
parameter_list|(
name|HB_ClassDefinition
modifier|*
name|cd
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|cd
operator|->
name|ClassFormat
operator|=
literal|1
expr_stmt|;
comment|/* Meaningless */
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|cd
operator|->
name|cd
operator|.
name|cd1
operator|.
name|ClassValueArray
argument_list|,
literal|1
argument_list|,
name|HB_UShort
argument_list|)
condition|)
return|return
name|error
return|;
name|cd
operator|->
name|loaded
operator|=
name|TRUE
expr_stmt|;
return|return
name|HB_Err_Ok
return|;
block|}
end_function
begin_function
name|HB_INTERNAL
name|HB_Error
DECL|function|_HB_OPEN_Load_EmptyOrClassDefinition
name|_HB_OPEN_Load_EmptyOrClassDefinition
parameter_list|(
name|HB_ClassDefinition
modifier|*
name|cd
parameter_list|,
name|HB_UShort
name|limit
parameter_list|,
name|HB_UInt
name|class_offset
parameter_list|,
name|HB_UInt
name|base_offset
parameter_list|,
name|HB_Stream
name|stream
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_UInt
name|cur_offset
decl_stmt|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|class_offset
condition|)
block|{
if|if
condition|(
operator|!
name|FILE_Seek
argument_list|(
name|class_offset
operator|+
name|base_offset
argument_list|)
condition|)
name|error
operator|=
name|_HB_OPEN_Load_ClassDefinition
argument_list|(
name|cd
argument_list|,
name|limit
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
else|else
name|error
operator|=
name|_HB_OPEN_Load_EmptyClassDefinition
argument_list|(
name|cd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|HB_Err_Ok
condition|)
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
comment|/* Changes error as a side-effect */
return|return
name|error
return|;
block|}
end_function
begin_function
name|HB_INTERNAL
name|void
DECL|function|_HB_OPEN_Free_ClassDefinition
name|_HB_OPEN_Free_ClassDefinition
parameter_list|(
name|HB_ClassDefinition
modifier|*
name|cd
parameter_list|)
block|{
if|if
condition|(
operator|!
name|cd
operator|->
name|loaded
condition|)
return|return;
switch|switch
condition|(
name|cd
operator|->
name|ClassFormat
condition|)
block|{
case|case
literal|1
case|:
name|Free_ClassDef1
argument_list|(
operator|&
name|cd
operator|->
name|cd
operator|.
name|cd1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|Free_ClassDef2
argument_list|(
operator|&
name|cd
operator|->
name|cd
operator|.
name|cd2
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function
begin_function
DECL|function|Get_Class1
specifier|static
name|HB_Error
name|Get_Class1
parameter_list|(
name|HB_ClassDefFormat1
modifier|*
name|cdf1
parameter_list|,
name|HB_UShort
name|glyphID
parameter_list|,
name|HB_UShort
modifier|*
name|klass
parameter_list|,
name|HB_UShort
modifier|*
name|index
parameter_list|)
block|{
name|HB_UShort
modifier|*
name|cva
init|=
name|cdf1
operator|->
name|ClassValueArray
decl_stmt|;
if|if
condition|(
name|index
condition|)
operator|*
name|index
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|glyphID
operator|>=
name|cdf1
operator|->
name|StartGlyph
operator|&&
name|glyphID
operator|<
name|cdf1
operator|->
name|StartGlyph
operator|+
name|cdf1
operator|->
name|GlyphCount
condition|)
block|{
operator|*
name|klass
operator|=
name|cva
index|[
name|glyphID
operator|-
name|cdf1
operator|->
name|StartGlyph
index|]
expr_stmt|;
return|return
name|HB_Err_Ok
return|;
block|}
else|else
block|{
operator|*
name|klass
operator|=
literal|0
expr_stmt|;
return|return
name|HB_Err_Not_Covered
return|;
block|}
block|}
end_function
begin_comment
comment|/* we need the index value of the last searched class range record    in case of failure for constructed GDEF tables                  */
end_comment
begin_function
DECL|function|Get_Class2
specifier|static
name|HB_Error
name|Get_Class2
parameter_list|(
name|HB_ClassDefFormat2
modifier|*
name|cdf2
parameter_list|,
name|HB_UShort
name|glyphID
parameter_list|,
name|HB_UShort
modifier|*
name|klass
parameter_list|,
name|HB_UShort
modifier|*
name|index
parameter_list|)
block|{
name|HB_Error
name|error
init|=
name|HB_Err_Ok
decl_stmt|;
name|HB_UShort
name|min
decl_stmt|,
name|max
decl_stmt|,
name|new_min
decl_stmt|,
name|new_max
decl_stmt|,
name|middle
decl_stmt|;
name|HB_ClassRangeRecord
modifier|*
name|crr
init|=
name|cdf2
operator|->
name|ClassRangeRecord
decl_stmt|;
comment|/* binary search */
if|if
condition|(
name|cdf2
operator|->
name|ClassRangeCount
operator|==
literal|0
condition|)
block|{
operator|*
name|klass
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|index
condition|)
operator|*
name|index
operator|=
literal|0
expr_stmt|;
return|return
name|HB_Err_Not_Covered
return|;
block|}
name|new_min
operator|=
literal|0
expr_stmt|;
name|new_max
operator|=
name|cdf2
operator|->
name|ClassRangeCount
operator|-
literal|1
expr_stmt|;
do|do
block|{
name|min
operator|=
name|new_min
expr_stmt|;
name|max
operator|=
name|new_max
expr_stmt|;
comment|/* we use (min + max) / 2 = max - (max - min) / 2  to avoid        overflow and rounding errors                             */
name|middle
operator|=
name|max
operator|-
operator|(
operator|(
name|max
operator|-
name|min
operator|)
operator|>>
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|glyphID
operator|>=
name|crr
index|[
name|middle
index|]
operator|.
name|Start
operator|&&
name|glyphID
operator|<=
name|crr
index|[
name|middle
index|]
operator|.
name|End
condition|)
block|{
operator|*
name|klass
operator|=
name|crr
index|[
name|middle
index|]
operator|.
name|Class
expr_stmt|;
name|error
operator|=
name|HB_Err_Ok
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|glyphID
operator|<
name|crr
index|[
name|middle
index|]
operator|.
name|Start
condition|)
block|{
if|if
condition|(
name|middle
operator|==
name|min
condition|)
block|{
operator|*
name|klass
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|HB_Err_Not_Covered
expr_stmt|;
break|break;
block|}
name|new_max
operator|=
name|middle
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|middle
operator|==
name|max
condition|)
block|{
operator|*
name|klass
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|HB_Err_Not_Covered
expr_stmt|;
break|break;
block|}
name|new_min
operator|=
name|middle
operator|+
literal|1
expr_stmt|;
block|}
block|}
do|while
condition|(
name|min
operator|<
name|max
condition|)
do|;
if|if
condition|(
name|index
condition|)
operator|*
name|index
operator|=
name|middle
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_function
name|HB_INTERNAL
name|HB_Error
DECL|function|_HB_OPEN_Get_Class
name|_HB_OPEN_Get_Class
parameter_list|(
name|HB_ClassDefinition
modifier|*
name|cd
parameter_list|,
name|HB_UShort
name|glyphID
parameter_list|,
name|HB_UShort
modifier|*
name|klass
parameter_list|,
name|HB_UShort
modifier|*
name|index
parameter_list|)
block|{
switch|switch
condition|(
name|cd
operator|->
name|ClassFormat
condition|)
block|{
case|case
literal|1
case|:
return|return
name|Get_Class1
argument_list|(
operator|&
name|cd
operator|->
name|cd
operator|.
name|cd1
argument_list|,
name|glyphID
argument_list|,
name|klass
argument_list|,
name|index
argument_list|)
return|;
case|case
literal|2
case|:
return|return
name|Get_Class2
argument_list|(
operator|&
name|cd
operator|->
name|cd
operator|.
name|cd2
argument_list|,
name|glyphID
argument_list|,
name|klass
argument_list|,
name|index
argument_list|)
return|;
default|default:
return|return
name|ERR
argument_list|(
name|HB_Err_Invalid_SubTable_Format
argument_list|)
return|;
block|}
return|return
name|HB_Err_Ok
return|;
comment|/* never reached */
block|}
end_function
begin_comment
comment|/***************************  * Device related functions  ***************************/
end_comment
begin_function
name|HB_INTERNAL
name|HB_Error
DECL|function|_HB_OPEN_Load_Device
name|_HB_OPEN_Load_Device
parameter_list|(
name|HB_Device
modifier|*
modifier|*
name|device
parameter_list|,
name|HB_Stream
name|stream
parameter_list|)
block|{
name|HB_Device
modifier|*
name|d
decl_stmt|;
name|HB_Error
name|error
decl_stmt|;
name|HB_UShort
name|n
decl_stmt|,
name|count
decl_stmt|;
name|HB_UShort
modifier|*
name|dv
decl_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|6L
argument_list|)
condition|)
return|return
name|error
return|;
if|if
condition|(
name|ALLOC
argument_list|(
operator|*
name|device
argument_list|,
sizeof|sizeof
argument_list|(
name|HB_Device
argument_list|)
argument_list|)
condition|)
block|{
operator|*
name|device
operator|=
literal|0
expr_stmt|;
return|return
name|error
return|;
block|}
name|d
operator|=
operator|*
name|device
expr_stmt|;
name|d
operator|->
name|StartSize
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|d
operator|->
name|EndSize
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|d
operator|->
name|DeltaFormat
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|d
operator|->
name|DeltaValue
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|StartSize
operator|>
name|d
operator|->
name|EndSize
operator|||
name|d
operator|->
name|DeltaFormat
operator|==
literal|0
operator|||
name|d
operator|->
name|DeltaFormat
operator|>
literal|3
condition|)
block|{
comment|/* XXX        * I've seen fontforge generate DeltaFormat == 0.        * Just return Ok and let the NULL DeltaValue disable        * this table.        */
return|return
name|HB_Err_Ok
return|;
block|}
name|count
operator|=
operator|(
operator|(
name|d
operator|->
name|EndSize
operator|-
name|d
operator|->
name|StartSize
operator|+
literal|1
operator|)
operator|>>
operator|(
literal|4
operator|-
name|d
operator|->
name|DeltaFormat
operator|)
operator|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|d
operator|->
name|DeltaValue
argument_list|,
name|count
argument_list|,
name|HB_UShort
argument_list|)
condition|)
block|{
name|FREE
argument_list|(
operator|*
name|device
argument_list|)
expr_stmt|;
operator|*
name|device
operator|=
literal|0
expr_stmt|;
return|return
name|error
return|;
block|}
if|if
condition|(
name|ACCESS_Frame
argument_list|(
name|count
operator|*
literal|2L
argument_list|)
condition|)
block|{
name|FREE
argument_list|(
name|d
operator|->
name|DeltaValue
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
operator|*
name|device
argument_list|)
expr_stmt|;
operator|*
name|device
operator|=
literal|0
expr_stmt|;
return|return
name|error
return|;
block|}
name|dv
operator|=
name|d
operator|->
name|DeltaValue
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
name|dv
index|[
name|n
index|]
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
return|return
name|HB_Err_Ok
return|;
block|}
end_function
begin_function
name|HB_INTERNAL
name|void
DECL|function|_HB_OPEN_Free_Device
name|_HB_OPEN_Free_Device
parameter_list|(
name|HB_Device
modifier|*
name|d
parameter_list|)
block|{
if|if
condition|(
name|d
condition|)
block|{
name|FREE
argument_list|(
name|d
operator|->
name|DeltaValue
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/* Since we have the delta values stored in compressed form, we must    uncompress it now.  To simplify the interface, the function always    returns a meaningful value in `value'; the error is just for    information. 			       |                |    format = 1: 0011223344556677|8899101112131415|... 			       |                | 		    byte 1           byte 2       00: (byte>> 14)& mask      11: (byte>> 12)& mask      ...       mask = 0x0003 			       |                |    format = 2: 0000111122223333|4444555566667777|... 			       |                | 		    byte 1           byte 2       0000: (byte>> 12)& mask      1111: (byte>>  8)& mask      ...       mask = 0x000F 			       |                |    format = 3: 0000000011111111|2222222233333333|... 			       |                | 		    byte 1           byte 2       00000000: (byte>> 8)& mask      11111111: (byte>> 0)& mask      ....       mask = 0x00FF                                    */
end_comment
begin_function
name|HB_INTERNAL
name|HB_Error
DECL|function|_HB_OPEN_Get_Device
name|_HB_OPEN_Get_Device
parameter_list|(
name|HB_Device
modifier|*
name|d
parameter_list|,
name|HB_UShort
name|size
parameter_list|,
name|HB_Short
modifier|*
name|value
parameter_list|)
block|{
name|HB_UShort
name|byte
decl_stmt|,
name|bits
decl_stmt|,
name|mask
decl_stmt|,
name|s
decl_stmt|;
if|if
condition|(
name|d
operator|&&
name|d
operator|->
name|DeltaValue
operator|&&
name|size
operator|>=
name|d
operator|->
name|StartSize
operator|&&
name|size
operator|<=
name|d
operator|->
name|EndSize
condition|)
block|{
name|HB_UShort
name|f
init|=
name|d
operator|->
name|DeltaFormat
decl_stmt|;
name|s
operator|=
name|size
operator|-
name|d
operator|->
name|StartSize
expr_stmt|;
name|byte
operator|=
name|d
operator|->
name|DeltaValue
index|[
name|s
operator|>>
operator|(
literal|4
operator|-
name|f
operator|)
index|]
expr_stmt|;
name|bits
operator|=
name|byte
operator|>>
operator|(
literal|16
operator|-
operator|(
operator|(
name|s
operator|%
operator|(
literal|1
operator|<<
operator|(
literal|4
operator|-
name|f
operator|)
operator|)
operator|+
literal|1
operator|)
operator|<<
name|f
operator|)
operator|)
expr_stmt|;
name|mask
operator|=
literal|0xFFFF
operator|>>
operator|(
literal|16
operator|-
operator|(
literal|1
operator|<<
name|f
operator|)
operator|)
expr_stmt|;
operator|*
name|value
operator|=
call|(
name|HB_Short
call|)
argument_list|(
name|bits
operator|&
name|mask
argument_list|)
expr_stmt|;
comment|/* conversion to a signed value */
if|if
condition|(
operator|*
name|value
operator|>=
operator|(
operator|(
name|mask
operator|+
literal|1
operator|)
operator|>>
literal|1
operator|)
condition|)
operator|*
name|value
operator|-=
name|mask
operator|+
literal|1
expr_stmt|;
return|return
name|HB_Err_Ok
return|;
block|}
else|else
block|{
operator|*
name|value
operator|=
literal|0
expr_stmt|;
return|return
name|HB_Err_Not_Covered
return|;
block|}
block|}
end_function
begin_comment
comment|/* END */
end_comment
end_unit
