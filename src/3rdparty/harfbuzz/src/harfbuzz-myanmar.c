begin_unit
begin_comment
comment|/*  * Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies)  *  * This is part of HarfBuzz, an OpenType Layout engine library.  *  * Permission is hereby granted, without written agreement and without  * license or royalty fees, to use, copy, modify, and distribute this  * software and its documentation for any purpose, provided that the  * above copyright notice and the following two paragraphs appear in  * all copies of this software.  *  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH  * DAMAGE.  *  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS  * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.  */
end_comment
begin_include
include|#
directive|include
file|"harfbuzz-shaper.h"
end_include
begin_include
include|#
directive|include
file|"harfbuzz-shaper-private.h"
end_include
begin_include
include|#
directive|include
file|<assert.h>
end_include
begin_include
include|#
directive|include
file|<stdio.h>
end_include
begin_enum
DECL|enum|MymrCharClassValues
enum|enum
name|MymrCharClassValues
block|{
DECL|enumerator|Mymr_CC_RESERVED
name|Mymr_CC_RESERVED
init|=
literal|0
block|,
DECL|enumerator|Mymr_CC_CONSONANT
name|Mymr_CC_CONSONANT
init|=
literal|1
block|,
comment|/* Consonant of type 1, that has subscript form */
DECL|enumerator|Mymr_CC_CONSONANT2
name|Mymr_CC_CONSONANT2
init|=
literal|2
block|,
comment|/* Consonant of type 2, that has no subscript form */
DECL|enumerator|Mymr_CC_NGA
name|Mymr_CC_NGA
init|=
literal|3
block|,
comment|/* Consonant NGA */
DECL|enumerator|Mymr_CC_YA
name|Mymr_CC_YA
init|=
literal|4
block|,
comment|/* Consonant YA */
DECL|enumerator|Mymr_CC_RA
name|Mymr_CC_RA
init|=
literal|5
block|,
comment|/* Consonant RA */
DECL|enumerator|Mymr_CC_WA
name|Mymr_CC_WA
init|=
literal|6
block|,
comment|/* Consonant WA */
DECL|enumerator|Mymr_CC_HA
name|Mymr_CC_HA
init|=
literal|7
block|,
comment|/* Consonant HA */
DECL|enumerator|Mymr_CC_IND_VOWEL
name|Mymr_CC_IND_VOWEL
init|=
literal|8
block|,
comment|/* Independent vowel */
DECL|enumerator|Mymr_CC_ZERO_WIDTH_NJ_MARK
name|Mymr_CC_ZERO_WIDTH_NJ_MARK
init|=
literal|9
block|,
comment|/* Zero Width non joiner character (0x200C) */
DECL|enumerator|Mymr_CC_VIRAMA
name|Mymr_CC_VIRAMA
init|=
literal|10
block|,
comment|/* Subscript consonant combining character */
DECL|enumerator|Mymr_CC_PRE_VOWEL
name|Mymr_CC_PRE_VOWEL
init|=
literal|11
block|,
comment|/* Dependent vowel, prebase (Vowel e) */
DECL|enumerator|Mymr_CC_BELOW_VOWEL
name|Mymr_CC_BELOW_VOWEL
init|=
literal|12
block|,
comment|/* Dependent vowel, prebase (Vowel u, uu) */
DECL|enumerator|Mymr_CC_ABOVE_VOWEL
name|Mymr_CC_ABOVE_VOWEL
init|=
literal|13
block|,
comment|/* Dependent vowel, prebase (Vowel i, ii, ai) */
DECL|enumerator|Mymr_CC_POST_VOWEL
name|Mymr_CC_POST_VOWEL
init|=
literal|14
block|,
comment|/* Dependent vowel, prebase (Vowel aa) */
DECL|enumerator|Mymr_CC_SIGN_ABOVE
name|Mymr_CC_SIGN_ABOVE
init|=
literal|15
block|,
DECL|enumerator|Mymr_CC_SIGN_BELOW
name|Mymr_CC_SIGN_BELOW
init|=
literal|16
block|,
DECL|enumerator|Mymr_CC_SIGN_AFTER
name|Mymr_CC_SIGN_AFTER
init|=
literal|17
block|,
DECL|enumerator|Mymr_CC_ZERO_WIDTH_J_MARK
name|Mymr_CC_ZERO_WIDTH_J_MARK
init|=
literal|18
block|,
comment|/* Zero width joiner character */
DECL|enumerator|Mymr_CC_COUNT
name|Mymr_CC_COUNT
init|=
literal|19
comment|/* This is the number of character classes */
block|}
enum|;
end_enum
begin_enum
DECL|enum|MymrCharClassFlags
enum|enum
name|MymrCharClassFlags
block|{
DECL|enumerator|Mymr_CF_CLASS_MASK
name|Mymr_CF_CLASS_MASK
init|=
literal|0x0000FFFF
block|,
DECL|enumerator|Mymr_CF_CONSONANT
name|Mymr_CF_CONSONANT
init|=
literal|0x01000000
block|,
comment|/* flag to speed up comparing */
DECL|enumerator|Mymr_CF_MEDIAL
name|Mymr_CF_MEDIAL
init|=
literal|0x02000000
block|,
comment|/* flag to speed up comparing */
DECL|enumerator|Mymr_CF_IND_VOWEL
name|Mymr_CF_IND_VOWEL
init|=
literal|0x04000000
block|,
comment|/* flag to speed up comparing */
DECL|enumerator|Mymr_CF_DEP_VOWEL
name|Mymr_CF_DEP_VOWEL
init|=
literal|0x08000000
block|,
comment|/* flag to speed up comparing */
DECL|enumerator|Mymr_CF_DOTTED_CIRCLE
name|Mymr_CF_DOTTED_CIRCLE
init|=
literal|0x10000000
block|,
comment|/* add a dotted circle if a character with this flag is the first in a syllable */
DECL|enumerator|Mymr_CF_VIRAMA
name|Mymr_CF_VIRAMA
init|=
literal|0x20000000
block|,
comment|/* flag to speed up comparing */
comment|/* position flags */
DECL|enumerator|Mymr_CF_POS_BEFORE
name|Mymr_CF_POS_BEFORE
init|=
literal|0x00080000
block|,
DECL|enumerator|Mymr_CF_POS_BELOW
name|Mymr_CF_POS_BELOW
init|=
literal|0x00040000
block|,
DECL|enumerator|Mymr_CF_POS_ABOVE
name|Mymr_CF_POS_ABOVE
init|=
literal|0x00020000
block|,
DECL|enumerator|Mymr_CF_POS_AFTER
name|Mymr_CF_POS_AFTER
init|=
literal|0x00010000
block|,
DECL|enumerator|Mymr_CF_POS_MASK
name|Mymr_CF_POS_MASK
init|=
literal|0x000f0000
block|,
DECL|enumerator|Mymr_CF_AFTER_KINZI
name|Mymr_CF_AFTER_KINZI
init|=
literal|0x00100000
block|}
enum|;
end_enum
begin_comment
comment|/* Characters that get refrered to by name */
end_comment
begin_enum
DECL|enum|MymrChar
enum|enum
name|MymrChar
block|{
DECL|enumerator|Mymr_C_SIGN_ZWNJ
name|Mymr_C_SIGN_ZWNJ
init|=
literal|0x200C
block|,
DECL|enumerator|Mymr_C_SIGN_ZWJ
name|Mymr_C_SIGN_ZWJ
init|=
literal|0x200D
block|,
DECL|enumerator|Mymr_C_DOTTED_CIRCLE
name|Mymr_C_DOTTED_CIRCLE
init|=
literal|0x25CC
block|,
DECL|enumerator|Mymr_C_RA
name|Mymr_C_RA
init|=
literal|0x101B
block|,
DECL|enumerator|Mymr_C_YA
name|Mymr_C_YA
init|=
literal|0x101A
block|,
DECL|enumerator|Mymr_C_NGA
name|Mymr_C_NGA
init|=
literal|0x1004
block|,
DECL|enumerator|Mymr_C_VOWEL_E
name|Mymr_C_VOWEL_E
init|=
literal|0x1031
block|,
DECL|enumerator|Mymr_C_VIRAMA
name|Mymr_C_VIRAMA
init|=
literal|0x1039
block|}
enum|;
end_enum
begin_enum
enum|enum
block|{
DECL|enumerator|Mymr_xx
name|Mymr_xx
init|=
name|Mymr_CC_RESERVED
block|,
DECL|enumerator|Mymr_c1
name|Mymr_c1
init|=
name|Mymr_CC_CONSONANT
operator||
name|Mymr_CF_CONSONANT
operator||
name|Mymr_CF_POS_BELOW
block|,
DECL|enumerator|Mymr_c2
name|Mymr_c2
init|=
name|Mymr_CC_CONSONANT2
operator||
name|Mymr_CF_CONSONANT
block|,
DECL|enumerator|Mymr_ng
name|Mymr_ng
init|=
name|Mymr_CC_NGA
operator||
name|Mymr_CF_CONSONANT
operator||
name|Mymr_CF_POS_ABOVE
block|,
DECL|enumerator|Mymr_ya
name|Mymr_ya
init|=
name|Mymr_CC_YA
operator||
name|Mymr_CF_CONSONANT
operator||
name|Mymr_CF_MEDIAL
operator||
name|Mymr_CF_POS_AFTER
operator||
name|Mymr_CF_AFTER_KINZI
block|,
DECL|enumerator|Mymr_ra
name|Mymr_ra
init|=
name|Mymr_CC_RA
operator||
name|Mymr_CF_CONSONANT
operator||
name|Mymr_CF_MEDIAL
operator||
name|Mymr_CF_POS_BEFORE
block|,
DECL|enumerator|Mymr_wa
name|Mymr_wa
init|=
name|Mymr_CC_WA
operator||
name|Mymr_CF_CONSONANT
operator||
name|Mymr_CF_MEDIAL
operator||
name|Mymr_CF_POS_BELOW
block|,
DECL|enumerator|Mymr_ha
name|Mymr_ha
init|=
name|Mymr_CC_HA
operator||
name|Mymr_CF_CONSONANT
operator||
name|Mymr_CF_MEDIAL
operator||
name|Mymr_CF_POS_BELOW
block|,
DECL|enumerator|Mymr_id
name|Mymr_id
init|=
name|Mymr_CC_IND_VOWEL
operator||
name|Mymr_CF_IND_VOWEL
block|,
DECL|enumerator|Mymr_vi
name|Mymr_vi
init|=
name|Mymr_CC_VIRAMA
operator||
name|Mymr_CF_VIRAMA
operator||
name|Mymr_CF_POS_ABOVE
operator||
name|Mymr_CF_DOTTED_CIRCLE
block|,
DECL|enumerator|Mymr_dl
name|Mymr_dl
init|=
name|Mymr_CC_PRE_VOWEL
operator||
name|Mymr_CF_DEP_VOWEL
operator||
name|Mymr_CF_POS_BEFORE
operator||
name|Mymr_CF_DOTTED_CIRCLE
operator||
name|Mymr_CF_AFTER_KINZI
block|,
DECL|enumerator|Mymr_db
name|Mymr_db
init|=
name|Mymr_CC_BELOW_VOWEL
operator||
name|Mymr_CF_DEP_VOWEL
operator||
name|Mymr_CF_POS_BELOW
operator||
name|Mymr_CF_DOTTED_CIRCLE
operator||
name|Mymr_CF_AFTER_KINZI
block|,
DECL|enumerator|Mymr_da
name|Mymr_da
init|=
name|Mymr_CC_ABOVE_VOWEL
operator||
name|Mymr_CF_DEP_VOWEL
operator||
name|Mymr_CF_POS_ABOVE
operator||
name|Mymr_CF_DOTTED_CIRCLE
operator||
name|Mymr_CF_AFTER_KINZI
block|,
DECL|enumerator|Mymr_dr
name|Mymr_dr
init|=
name|Mymr_CC_POST_VOWEL
operator||
name|Mymr_CF_DEP_VOWEL
operator||
name|Mymr_CF_POS_AFTER
operator||
name|Mymr_CF_DOTTED_CIRCLE
operator||
name|Mymr_CF_AFTER_KINZI
block|,
DECL|enumerator|Mymr_sa
name|Mymr_sa
init|=
name|Mymr_CC_SIGN_ABOVE
operator||
name|Mymr_CF_DOTTED_CIRCLE
operator||
name|Mymr_CF_POS_ABOVE
operator||
name|Mymr_CF_AFTER_KINZI
block|,
DECL|enumerator|Mymr_sb
name|Mymr_sb
init|=
name|Mymr_CC_SIGN_BELOW
operator||
name|Mymr_CF_DOTTED_CIRCLE
operator||
name|Mymr_CF_POS_BELOW
operator||
name|Mymr_CF_AFTER_KINZI
block|,
DECL|enumerator|Mymr_sp
name|Mymr_sp
init|=
name|Mymr_CC_SIGN_AFTER
operator||
name|Mymr_CF_DOTTED_CIRCLE
operator||
name|Mymr_CF_AFTER_KINZI
block|}
enum|;
end_enum
begin_typedef
DECL|typedef|MymrCharClass
typedef|typedef
name|int
name|MymrCharClass
typedef|;
end_typedef
begin_decl_stmt
DECL|variable|mymrCharClasses
specifier|static
specifier|const
name|MymrCharClass
name|mymrCharClasses
index|[]
init|=
block|{
name|Mymr_c1
block|,
name|Mymr_c1
block|,
name|Mymr_c1
block|,
name|Mymr_c1
block|,
name|Mymr_ng
block|,
name|Mymr_c1
block|,
name|Mymr_c1
block|,
name|Mymr_c1
block|,
name|Mymr_c1
block|,
name|Mymr_c1
block|,
name|Mymr_c2
block|,
name|Mymr_c1
block|,
name|Mymr_c1
block|,
name|Mymr_c1
block|,
name|Mymr_c1
block|,
name|Mymr_c1
block|,
comment|/* 1000 - 100F */
name|Mymr_c1
block|,
name|Mymr_c1
block|,
name|Mymr_c1
block|,
name|Mymr_c1
block|,
name|Mymr_c1
block|,
name|Mymr_c1
block|,
name|Mymr_c1
block|,
name|Mymr_c1
block|,
name|Mymr_c1
block|,
name|Mymr_c1
block|,
name|Mymr_ya
block|,
name|Mymr_ra
block|,
name|Mymr_c1
block|,
name|Mymr_wa
block|,
name|Mymr_c1
block|,
name|Mymr_ha
block|,
comment|/* 1010 - 101F */
name|Mymr_c2
block|,
name|Mymr_c2
block|,
name|Mymr_xx
block|,
name|Mymr_id
block|,
name|Mymr_id
block|,
name|Mymr_id
block|,
name|Mymr_id
block|,
name|Mymr_id
block|,
name|Mymr_xx
block|,
name|Mymr_id
block|,
name|Mymr_id
block|,
name|Mymr_xx
block|,
name|Mymr_dr
block|,
name|Mymr_da
block|,
name|Mymr_da
block|,
name|Mymr_db
block|,
comment|/* 1020 - 102F */
name|Mymr_db
block|,
name|Mymr_dl
block|,
name|Mymr_da
block|,
name|Mymr_xx
block|,
name|Mymr_xx
block|,
name|Mymr_xx
block|,
name|Mymr_sa
block|,
name|Mymr_sb
block|,
name|Mymr_sp
block|,
name|Mymr_vi
block|,
name|Mymr_xx
block|,
name|Mymr_xx
block|,
name|Mymr_xx
block|,
name|Mymr_xx
block|,
name|Mymr_xx
block|,
name|Mymr_xx
block|,
comment|/* 1030 - 103F */
name|Mymr_xx
block|,
name|Mymr_xx
block|,
name|Mymr_xx
block|,
name|Mymr_xx
block|,
name|Mymr_xx
block|,
name|Mymr_xx
block|,
name|Mymr_xx
block|,
name|Mymr_xx
block|,
name|Mymr_xx
block|,
name|Mymr_xx
block|,
name|Mymr_xx
block|,
name|Mymr_xx
block|,
name|Mymr_xx
block|,
name|Mymr_xx
block|,
name|Mymr_xx
block|,
name|Mymr_xx
block|,
comment|/* 1040 - 104F */
name|Mymr_xx
block|,
name|Mymr_xx
block|,
name|Mymr_xx
block|,
name|Mymr_xx
block|,
name|Mymr_xx
block|,
name|Mymr_xx
block|,
name|Mymr_xx
block|,
name|Mymr_xx
block|,
name|Mymr_xx
block|,
name|Mymr_xx
block|,
name|Mymr_xx
block|,
name|Mymr_xx
block|,
name|Mymr_xx
block|,
name|Mymr_xx
block|,
name|Mymr_xx
block|,
name|Mymr_xx
block|,
comment|/* 1050 - 105F */
block|}
decl_stmt|;
end_decl_stmt
begin_function
specifier|static
name|MymrCharClass
DECL|function|getMyanmarCharClass
name|getMyanmarCharClass
parameter_list|(
name|HB_UChar16
name|ch
parameter_list|)
block|{
if|if
condition|(
name|ch
operator|==
name|Mymr_C_SIGN_ZWJ
condition|)
return|return
name|Mymr_CC_ZERO_WIDTH_J_MARK
return|;
if|if
condition|(
name|ch
operator|==
name|Mymr_C_SIGN_ZWNJ
condition|)
return|return
name|Mymr_CC_ZERO_WIDTH_NJ_MARK
return|;
if|if
condition|(
name|ch
operator|<
literal|0x1000
operator|||
name|ch
operator|>
literal|0x105f
condition|)
return|return
name|Mymr_CC_RESERVED
return|;
return|return
name|mymrCharClasses
index|[
name|ch
operator|-
literal|0x1000
index|]
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|mymrStateTable
specifier|static
specifier|const
name|signed
name|char
name|mymrStateTable
index|[]
index|[
name|Mymr_CC_COUNT
index|]
init|=
block|{
comment|/*   xx  c1, c2  ng  ya  ra  wa  ha  id zwnj vi  dl  db  da  dr  sa  sb  sp zwj */
block|{
literal|1
block|,
literal|4
block|,
literal|4
block|,
literal|2
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|24
block|,
literal|1
block|,
literal|27
block|,
literal|17
block|,
literal|18
block|,
literal|19
block|,
literal|20
block|,
literal|21
block|,
literal|1
block|,
literal|1
block|,
literal|4
block|}
block|,
comment|/*  0 - ground state */
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|/*  1 - exit state (or sp to the right of the syllable) */
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|3
block|,
literal|17
block|,
literal|18
block|,
literal|19
block|,
literal|20
block|,
literal|21
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|4
block|}
block|,
comment|/*  2 - NGA */
block|{
operator|-
literal|1
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
operator|-
literal|1
block|,
literal|23
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|/*  3 - Virama after NGA */
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|5
block|,
literal|17
block|,
literal|18
block|,
literal|19
block|,
literal|20
block|,
literal|21
block|,
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|/*  4 - Base consonant */
block|{
operator|-
literal|2
block|,
literal|6
block|,
operator|-
literal|2
block|,
operator|-
literal|2
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
operator|-
literal|2
block|,
literal|23
block|,
operator|-
literal|2
block|,
operator|-
literal|2
block|,
operator|-
literal|2
block|,
operator|-
literal|2
block|,
operator|-
literal|2
block|,
operator|-
literal|2
block|,
operator|-
literal|2
block|,
operator|-
literal|2
block|,
operator|-
literal|2
block|}
block|,
comment|/*  5 - First virama */
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|25
block|,
literal|17
block|,
literal|18
block|,
literal|19
block|,
literal|20
block|,
literal|21
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|/*  6 - c1 after virama */
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|12
block|,
literal|17
block|,
literal|18
block|,
literal|19
block|,
literal|20
block|,
literal|21
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|/*  7 - ya after virama */
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|12
block|,
literal|17
block|,
literal|18
block|,
literal|19
block|,
literal|20
block|,
literal|21
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|/*  8 - ra after virama */
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|12
block|,
literal|17
block|,
literal|18
block|,
literal|19
block|,
literal|20
block|,
literal|21
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|/*  9 - wa after virama */
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|17
block|,
literal|18
block|,
literal|19
block|,
literal|20
block|,
literal|21
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|/* 10 - ha after virama */
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|/* 11 - Virama after NGA+zwj */
block|{
operator|-
literal|2
block|,
operator|-
literal|2
block|,
operator|-
literal|2
block|,
operator|-
literal|2
block|,
operator|-
literal|2
block|,
operator|-
literal|2
block|,
literal|13
block|,
literal|14
block|,
operator|-
literal|2
block|,
operator|-
literal|2
block|,
operator|-
literal|2
block|,
operator|-
literal|2
block|,
operator|-
literal|2
block|,
operator|-
literal|2
block|,
operator|-
literal|2
block|,
operator|-
literal|2
block|,
operator|-
literal|2
block|,
operator|-
literal|2
block|,
operator|-
literal|2
block|}
block|,
comment|/* 12 - Second virama */
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|15
block|,
literal|17
block|,
literal|18
block|,
literal|19
block|,
literal|20
block|,
literal|21
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|/* 13 - wa after virama */
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|17
block|,
literal|18
block|,
literal|19
block|,
literal|20
block|,
literal|21
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|/* 14 - ha after virama */
block|{
operator|-
literal|2
block|,
operator|-
literal|2
block|,
operator|-
literal|2
block|,
operator|-
literal|2
block|,
operator|-
literal|2
block|,
operator|-
literal|2
block|,
operator|-
literal|2
block|,
literal|16
block|,
operator|-
literal|2
block|,
operator|-
literal|2
block|,
operator|-
literal|2
block|,
operator|-
literal|2
block|,
operator|-
literal|2
block|,
operator|-
literal|2
block|,
operator|-
literal|2
block|,
operator|-
literal|2
block|,
operator|-
literal|2
block|,
operator|-
literal|2
block|,
operator|-
literal|2
block|}
block|,
comment|/* 15 - Third virama */
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|17
block|,
literal|18
block|,
literal|19
block|,
literal|20
block|,
literal|21
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|/* 16 - ha after virama */
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|20
block|,
literal|21
block|,
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|/* 17 - dl, Dependent vowel e */
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|19
block|,
operator|-
literal|1
block|,
literal|21
block|,
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|/* 18 - db, Dependent vowel u,uu */
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|/* 19 - da, Dependent vowel i,ii,ai */
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|22
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|/* 20 - dr, Dependent vowel aa */
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|/* 21 - sa, Sign anusvara */
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|23
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|/* 22 - atha */
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|/* 23 - zwnj for atha */
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|/* 24 - Independent vowel */
block|{
operator|-
literal|2
block|,
operator|-
literal|2
block|,
operator|-
literal|2
block|,
operator|-
literal|2
block|,
literal|26
block|,
literal|26
block|,
operator|-
literal|2
block|,
operator|-
literal|2
block|,
operator|-
literal|2
block|,
operator|-
literal|2
block|,
operator|-
literal|2
block|,
operator|-
literal|2
block|,
operator|-
literal|2
block|,
operator|-
literal|2
block|,
operator|-
literal|2
block|,
operator|-
literal|2
block|,
operator|-
literal|2
block|,
operator|-
literal|2
block|,
operator|-
literal|2
block|}
block|,
comment|/* 25 - Virama after subscript consonant */
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|12
block|,
literal|17
block|,
literal|18
block|,
literal|19
block|,
literal|20
block|,
literal|21
block|,
operator|-
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|/* 26 - ra/ya after subscript consonant + virama */
block|{
operator|-
literal|1
block|,
literal|6
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
operator|-
literal|1
block|,
literal|23
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|/* 27 - Virama after ground state */
comment|/* exit state -2 is for invalid order of medials and combination of invalids    with virama where virama should treat as start of next syllable  */
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|/*#define MYANMAR_DEBUG */
end_comment
begin_ifdef
ifdef|#
directive|ifdef
name|MYANMAR_DEBUG
end_ifdef
begin_define
DECL|macro|MMDEBUG
define|#
directive|define
name|MMDEBUG
value|qDebug
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|MMDEBUG
define|#
directive|define
name|MMDEBUG
value|if(0) printf
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* //  Given an input string of characters and a location in which to start looking //  calculate, using the state table, which one is the last character of the syllable //  that starts in the starting position. */
end_comment
begin_function
DECL|function|myanmar_nextSyllableBoundary
specifier|static
name|int
name|myanmar_nextSyllableBoundary
parameter_list|(
specifier|const
name|HB_UChar16
modifier|*
name|s
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|,
name|HB_Bool
modifier|*
name|invalid
parameter_list|)
block|{
specifier|const
name|HB_UChar16
modifier|*
name|uc
init|=
name|s
operator|+
name|start
decl_stmt|;
name|int
name|state
init|=
literal|0
decl_stmt|;
name|int
name|pos
init|=
name|start
decl_stmt|;
operator|*
name|invalid
operator|=
name|FALSE
expr_stmt|;
while|while
condition|(
name|pos
operator|<
name|end
condition|)
block|{
name|MymrCharClass
name|charClass
init|=
name|getMyanmarCharClass
argument_list|(
operator|*
name|uc
argument_list|)
decl_stmt|;
name|state
operator|=
name|mymrStateTable
index|[
name|state
index|]
index|[
name|charClass
operator|&
name|Mymr_CF_CLASS_MASK
index|]
expr_stmt|;
if|if
condition|(
name|pos
operator|==
name|start
condition|)
operator|*
name|invalid
operator|=
call|(
name|HB_Bool
call|)
argument_list|(
name|charClass
operator|&
name|Mymr_CF_DOTTED_CIRCLE
argument_list|)
expr_stmt|;
name|MMDEBUG
argument_list|(
literal|"state[%d]=%d class=%8x (uc=%4x)"
argument_list|,
name|pos
operator|-
name|start
argument_list|,
name|state
argument_list|,
name|charClass
argument_list|,
operator|*
name|uc
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|state
operator|<
operator|-
literal|1
condition|)
operator|--
name|pos
expr_stmt|;
break|break;
block|}
operator|++
name|uc
expr_stmt|;
operator|++
name|pos
expr_stmt|;
block|}
return|return
name|pos
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|NO_OPENTYPE
end_ifndef
begin_comment
comment|/* ###### might have to change order of above and below forms and substitutions,    but according to Unicode below comes before above */
end_comment
begin_decl_stmt
DECL|variable|myanmar_features
specifier|static
specifier|const
name|HB_OpenTypeFeature
name|myanmar_features
index|[]
init|=
block|{
block|{
name|HB_MAKE_TAG
argument_list|(
literal|'p'
argument_list|,
literal|'r'
argument_list|,
literal|'e'
argument_list|,
literal|'f'
argument_list|)
block|,
name|PreFormProperty
block|}
block|,
block|{
name|HB_MAKE_TAG
argument_list|(
literal|'b'
argument_list|,
literal|'l'
argument_list|,
literal|'w'
argument_list|,
literal|'f'
argument_list|)
block|,
name|BelowFormProperty
block|}
block|,
block|{
name|HB_MAKE_TAG
argument_list|(
literal|'a'
argument_list|,
literal|'b'
argument_list|,
literal|'v'
argument_list|,
literal|'f'
argument_list|)
block|,
name|AboveFormProperty
block|}
block|,
block|{
name|HB_MAKE_TAG
argument_list|(
literal|'p'
argument_list|,
literal|'s'
argument_list|,
literal|'t'
argument_list|,
literal|'f'
argument_list|)
block|,
name|PostFormProperty
block|}
block|,
block|{
name|HB_MAKE_TAG
argument_list|(
literal|'p'
argument_list|,
literal|'r'
argument_list|,
literal|'e'
argument_list|,
literal|'s'
argument_list|)
block|,
name|PreSubstProperty
block|}
block|,
block|{
name|HB_MAKE_TAG
argument_list|(
literal|'b'
argument_list|,
literal|'l'
argument_list|,
literal|'w'
argument_list|,
literal|'s'
argument_list|)
block|,
name|BelowSubstProperty
block|}
block|,
block|{
name|HB_MAKE_TAG
argument_list|(
literal|'a'
argument_list|,
literal|'b'
argument_list|,
literal|'v'
argument_list|,
literal|'s'
argument_list|)
block|,
name|AboveSubstProperty
block|}
block|,
block|{
name|HB_MAKE_TAG
argument_list|(
literal|'p'
argument_list|,
literal|'s'
argument_list|,
literal|'t'
argument_list|,
literal|'s'
argument_list|)
block|,
name|PostSubstProperty
block|}
block|,
block|{
name|HB_MAKE_TAG
argument_list|(
literal|'r'
argument_list|,
literal|'l'
argument_list|,
literal|'i'
argument_list|,
literal|'g'
argument_list|)
block|,
name|CligProperty
block|}
block|,
comment|/* Myanmar1 uses this instead of the other features */
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* // Visual order before shaping should be: // //    [Vowel Mark E] //    [Virama + Medial Ra] //    [Base] //    [Virama + Consonant] //    [Nga + Virama] (Kinzi) ### should probably come before post forms (medial ya) //    [Vowels] //    [Marks] // // This means that we can keep the logical order apart from having to // move the pre vowel, medial ra and kinzi */
end_comment
begin_function
DECL|function|myanmar_shape_syllable
specifier|static
name|HB_Bool
name|myanmar_shape_syllable
parameter_list|(
name|HB_Bool
name|openType
parameter_list|,
name|HB_ShaperItem
modifier|*
name|item
parameter_list|,
name|HB_Bool
name|invalid
parameter_list|)
block|{
comment|/* //    MMDEBUG("\nsyllable from %d len %d, str='%s'", item->item.pos, item->item.length, //	    item->string->mid(item->from, item->length).toUtf8().data());     */
ifndef|#
directive|ifndef
name|NO_OPENTYPE
specifier|const
name|int
name|availableGlyphs
init|=
name|item
operator|->
name|num_glyphs
decl_stmt|;
endif|#
directive|endif
specifier|const
name|HB_UChar16
modifier|*
name|uc
init|=
name|item
operator|->
name|string
operator|+
name|item
operator|->
name|item
operator|.
name|pos
decl_stmt|;
name|int
name|vowel_e
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|kinzi
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|medial_ra
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|base
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|len
init|=
literal|0
decl_stmt|;
name|unsigned
name|short
name|reordered
index|[
literal|32
index|]
decl_stmt|;
name|unsigned
name|char
name|properties
index|[
literal|32
index|]
decl_stmt|;
enum|enum
block|{
name|AboveForm
init|=
literal|0x01
block|,
name|PreForm
init|=
literal|0x02
block|,
name|PostForm
init|=
literal|0x04
block|,
name|BelowForm
init|=
literal|0x08
block|}
enum|;
name|HB_Bool
name|lastWasVirama
init|=
name|FALSE
decl_stmt|;
name|int
name|basePos
init|=
operator|-
literal|1
decl_stmt|;
name|memset
argument_list|(
name|properties
argument_list|,
literal|0
argument_list|,
literal|32
operator|*
expr|sizeof
operator|(
name|unsigned
name|char
operator|)
argument_list|)
expr_stmt|;
comment|/* according to the table the max length of a syllable should be around 14 chars */
name|assert
argument_list|(
name|item
operator|->
name|item
operator|.
name|length
operator|<
literal|32
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MYANMAR_DEBUG
name|printf
argument_list|(
literal|"original:"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|item
operator|->
name|item
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"    %d: %4x"
argument_list|,
name|i
argument_list|,
name|uc
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|item
operator|->
name|item
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|HB_UChar16
name|chr
init|=
name|uc
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|chr
operator|==
name|Mymr_C_VOWEL_E
condition|)
block|{
name|vowel_e
operator|=
name|i
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|i
operator|==
literal|0
operator|&&
name|chr
operator|==
name|Mymr_C_NGA
operator|&&
name|i
operator|+
literal|2
operator|<
operator|(
name|int
operator|)
name|item
operator|->
name|item
operator|.
name|length
operator|&&
name|uc
index|[
name|i
operator|+
literal|1
index|]
operator|==
name|Mymr_C_VIRAMA
condition|)
block|{
name|int
name|mc
init|=
name|getMyanmarCharClass
argument_list|(
name|uc
index|[
name|i
operator|+
literal|2
index|]
argument_list|)
decl_stmt|;
comment|/*MMDEBUG("maybe kinzi: mc=%x", mc);*/
if|if
condition|(
operator|(
name|mc
operator|&
name|Mymr_CF_CONSONANT
operator|)
operator|==
name|Mymr_CF_CONSONANT
condition|)
block|{
name|kinzi
operator|=
name|i
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|base
operator|>=
literal|0
operator|&&
name|chr
operator|==
name|Mymr_C_VIRAMA
operator|&&
name|i
operator|+
literal|1
operator|<
operator|(
name|int
operator|)
name|item
operator|->
name|item
operator|.
name|length
operator|&&
name|uc
index|[
name|i
operator|+
literal|1
index|]
operator|==
name|Mymr_C_RA
condition|)
block|{
name|medial_ra
operator|=
name|i
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|base
operator|<
literal|0
condition|)
name|base
operator|=
name|i
expr_stmt|;
block|}
name|MMDEBUG
argument_list|(
literal|"\n  base=%d, vowel_e=%d, kinzi=%d, medial_ra=%d"
argument_list|,
name|base
argument_list|,
name|vowel_e
argument_list|,
name|kinzi
argument_list|,
name|medial_ra
argument_list|)
expr_stmt|;
comment|/* write vowel_e if found */
if|if
condition|(
name|vowel_e
operator|>=
literal|0
condition|)
block|{
name|reordered
index|[
literal|0
index|]
operator|=
name|Mymr_C_VOWEL_E
expr_stmt|;
name|len
operator|=
literal|1
expr_stmt|;
block|}
comment|/* write medial_ra */
if|if
condition|(
name|medial_ra
operator|>=
literal|0
condition|)
block|{
name|reordered
index|[
name|len
index|]
operator|=
name|Mymr_C_VIRAMA
expr_stmt|;
name|reordered
index|[
name|len
operator|+
literal|1
index|]
operator|=
name|Mymr_C_RA
expr_stmt|;
name|properties
index|[
name|len
index|]
operator|=
name|PreForm
expr_stmt|;
name|properties
index|[
name|len
operator|+
literal|1
index|]
operator|=
name|PreForm
expr_stmt|;
name|len
operator|+=
literal|2
expr_stmt|;
block|}
comment|/* shall we add a dotted circle?        If in the position in which the base should be (first char in the string) there is        a character that has the Dotted circle flag (a character that cannot be a base)        then write a dotted circle */
if|if
condition|(
name|invalid
condition|)
block|{
name|reordered
index|[
name|len
index|]
operator|=
name|C_DOTTED_CIRCLE
expr_stmt|;
operator|++
name|len
expr_stmt|;
block|}
comment|/* copy the rest of the syllable to the output, inserting the kinzi        at the correct place */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|item
operator|->
name|item
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|hb_uint16
name|chr
init|=
name|uc
index|[
name|i
index|]
decl_stmt|;
name|MymrCharClass
name|cc
decl_stmt|;
if|if
condition|(
name|i
operator|==
name|vowel_e
condition|)
continue|continue;
if|if
condition|(
name|i
operator|==
name|medial_ra
operator|||
name|i
operator|==
name|kinzi
condition|)
block|{
operator|++
name|i
expr_stmt|;
continue|continue;
block|}
name|cc
operator|=
name|getMyanmarCharClass
argument_list|(
name|uc
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|kinzi
operator|>=
literal|0
operator|&&
name|i
operator|>
name|base
operator|&&
operator|(
name|cc
operator|&
name|Mymr_CF_AFTER_KINZI
operator|)
condition|)
block|{
name|reordered
index|[
name|len
index|]
operator|=
name|Mymr_C_NGA
expr_stmt|;
name|reordered
index|[
name|len
operator|+
literal|1
index|]
operator|=
name|Mymr_C_VIRAMA
expr_stmt|;
name|properties
index|[
name|len
operator|-
literal|1
index|]
operator|=
name|AboveForm
expr_stmt|;
name|properties
index|[
name|len
index|]
operator|=
name|AboveForm
expr_stmt|;
name|len
operator|+=
literal|2
expr_stmt|;
name|kinzi
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|lastWasVirama
condition|)
block|{
name|int
name|prop
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cc
operator|&
name|Mymr_CF_POS_MASK
condition|)
block|{
case|case
name|Mymr_CF_POS_BEFORE
case|:
name|prop
operator|=
name|PreForm
expr_stmt|;
break|break;
case|case
name|Mymr_CF_POS_BELOW
case|:
name|prop
operator|=
name|BelowForm
expr_stmt|;
break|break;
case|case
name|Mymr_CF_POS_ABOVE
case|:
name|prop
operator|=
name|AboveForm
expr_stmt|;
break|break;
case|case
name|Mymr_CF_POS_AFTER
case|:
name|prop
operator|=
name|PostForm
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|properties
index|[
name|len
operator|-
literal|1
index|]
operator|=
name|prop
expr_stmt|;
name|properties
index|[
name|len
index|]
operator|=
name|prop
expr_stmt|;
if|if
condition|(
name|basePos
operator|>=
literal|0
operator|&&
name|basePos
operator|==
name|len
operator|-
literal|2
condition|)
name|properties
index|[
name|len
operator|-
literal|2
index|]
operator|=
name|prop
expr_stmt|;
block|}
name|lastWasVirama
operator|=
operator|(
name|chr
operator|==
name|Mymr_C_VIRAMA
operator|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|base
condition|)
name|basePos
operator|=
name|len
expr_stmt|;
if|if
condition|(
operator|(
name|chr
operator|!=
name|Mymr_C_SIGN_ZWNJ
operator|&&
name|chr
operator|!=
name|Mymr_C_SIGN_ZWJ
operator|)
operator|||
operator|!
name|len
condition|)
block|{
name|reordered
index|[
name|len
index|]
operator|=
name|chr
expr_stmt|;
operator|++
name|len
expr_stmt|;
block|}
block|}
if|if
condition|(
name|kinzi
operator|>=
literal|0
condition|)
block|{
name|reordered
index|[
name|len
index|]
operator|=
name|Mymr_C_NGA
expr_stmt|;
name|reordered
index|[
name|len
operator|+
literal|1
index|]
operator|=
name|Mymr_C_VIRAMA
expr_stmt|;
name|properties
index|[
name|len
index|]
operator|=
name|AboveForm
expr_stmt|;
name|properties
index|[
name|len
operator|+
literal|1
index|]
operator|=
name|AboveForm
expr_stmt|;
name|len
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|item
operator|->
name|font
operator|->
name|klass
operator|->
name|convertStringToGlyphIndices
argument_list|(
name|item
operator|->
name|font
argument_list|,
name|reordered
argument_list|,
name|len
argument_list|,
name|item
operator|->
name|glyphs
argument_list|,
operator|&
name|item
operator|->
name|num_glyphs
argument_list|,
name|item
operator|->
name|item
operator|.
name|bidiLevel
operator|%
literal|2
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|MMDEBUG
argument_list|(
literal|"after shaping: len=%d"
argument_list|,
name|len
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|item
operator|->
name|attributes
index|[
name|i
index|]
operator|.
name|mark
operator|=
name|FALSE
expr_stmt|;
name|item
operator|->
name|attributes
index|[
name|i
index|]
operator|.
name|clusterStart
operator|=
name|FALSE
expr_stmt|;
name|item
operator|->
name|attributes
index|[
name|i
index|]
operator|.
name|justification
operator|=
literal|0
expr_stmt|;
name|item
operator|->
name|attributes
index|[
name|i
index|]
operator|.
name|zeroWidth
operator|=
name|FALSE
expr_stmt|;
name|MMDEBUG
argument_list|(
literal|"    %d: %4x property=%x"
argument_list|,
name|i
argument_list|,
name|reordered
index|[
name|i
index|]
argument_list|,
name|properties
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* now we have the syllable in the right order, and can start running it through open type. */
ifndef|#
directive|ifndef
name|NO_OPENTYPE
if|if
condition|(
name|openType
condition|)
block|{
name|hb_uint32
name|where
index|[
literal|32
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
name|where
index|[
name|i
index|]
operator|=
operator|~
operator|(
name|PreSubstProperty
operator||
name|BelowSubstProperty
operator||
name|AboveSubstProperty
operator||
name|PostSubstProperty
operator||
name|CligProperty
operator||
name|PositioningProperties
operator|)
expr_stmt|;
if|if
condition|(
name|properties
index|[
name|i
index|]
operator|&
name|PreForm
condition|)
name|where
index|[
name|i
index|]
operator|&=
operator|~
name|PreFormProperty
expr_stmt|;
if|if
condition|(
name|properties
index|[
name|i
index|]
operator|&
name|BelowForm
condition|)
name|where
index|[
name|i
index|]
operator|&=
operator|~
name|BelowFormProperty
expr_stmt|;
if|if
condition|(
name|properties
index|[
name|i
index|]
operator|&
name|AboveForm
condition|)
name|where
index|[
name|i
index|]
operator|&=
operator|~
name|AboveFormProperty
expr_stmt|;
if|if
condition|(
name|properties
index|[
name|i
index|]
operator|&
name|PostForm
condition|)
name|where
index|[
name|i
index|]
operator|&=
operator|~
name|PostFormProperty
expr_stmt|;
block|}
name|HB_OpenTypeShape
argument_list|(
name|item
argument_list|,
name|where
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|HB_OpenTypePosition
argument_list|(
name|item
argument_list|,
name|availableGlyphs
argument_list|,
comment|/*doLogClusters*/
name|FALSE
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
else|else
endif|#
directive|endif
block|{
name|MMDEBUG
argument_list|(
literal|"Not using openType"
argument_list|)
expr_stmt|;
name|HB_HeuristicPosition
argument_list|(
name|item
argument_list|)
expr_stmt|;
block|}
name|item
operator|->
name|attributes
index|[
literal|0
index|]
operator|.
name|clusterStart
operator|=
name|TRUE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function
begin_function
DECL|function|HB_MyanmarShape
name|HB_Bool
name|HB_MyanmarShape
parameter_list|(
name|HB_ShaperItem
modifier|*
name|item
parameter_list|)
block|{
name|HB_Bool
name|openType
init|=
name|FALSE
decl_stmt|;
name|unsigned
name|short
modifier|*
name|logClusters
init|=
name|item
operator|->
name|log_clusters
decl_stmt|;
name|HB_ShaperItem
name|syllable
init|=
operator|*
name|item
decl_stmt|;
name|int
name|first_glyph
init|=
literal|0
decl_stmt|;
name|int
name|sstart
init|=
name|item
operator|->
name|item
operator|.
name|pos
decl_stmt|;
name|int
name|end
init|=
name|sstart
operator|+
name|item
operator|->
name|item
operator|.
name|length
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|assert
argument_list|(
name|item
operator|->
name|item
operator|.
name|script
operator|==
name|HB_Script_Myanmar
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_OPENTYPE
name|openType
operator|=
name|HB_SelectScript
argument_list|(
name|item
argument_list|,
name|myanmar_features
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|MMDEBUG
argument_list|(
literal|"myanmar_shape: from %d length %d"
argument_list|,
name|item
operator|->
name|item
operator|.
name|pos
argument_list|,
name|item
operator|->
name|item
operator|.
name|length
argument_list|)
expr_stmt|;
while|while
condition|(
name|sstart
operator|<
name|end
condition|)
block|{
name|HB_Bool
name|invalid
decl_stmt|;
name|int
name|send
init|=
name|myanmar_nextSyllableBoundary
argument_list|(
name|item
operator|->
name|string
argument_list|,
name|sstart
argument_list|,
name|end
argument_list|,
operator|&
name|invalid
argument_list|)
decl_stmt|;
name|MMDEBUG
argument_list|(
literal|"syllable from %d, length %d, invalid=%s"
argument_list|,
name|sstart
argument_list|,
name|send
operator|-
name|sstart
argument_list|,
name|invalid
condition|?
literal|"TRUE"
else|:
literal|"FALSE"
argument_list|)
expr_stmt|;
name|syllable
operator|.
name|item
operator|.
name|pos
operator|=
name|sstart
expr_stmt|;
name|syllable
operator|.
name|item
operator|.
name|length
operator|=
name|send
operator|-
name|sstart
expr_stmt|;
name|syllable
operator|.
name|glyphs
operator|=
name|item
operator|->
name|glyphs
operator|+
name|first_glyph
expr_stmt|;
name|syllable
operator|.
name|attributes
operator|=
name|item
operator|->
name|attributes
operator|+
name|first_glyph
expr_stmt|;
name|syllable
operator|.
name|advances
operator|=
name|item
operator|->
name|advances
operator|+
name|first_glyph
expr_stmt|;
name|syllable
operator|.
name|offsets
operator|=
name|item
operator|->
name|offsets
operator|+
name|first_glyph
expr_stmt|;
name|syllable
operator|.
name|num_glyphs
operator|=
name|item
operator|->
name|num_glyphs
operator|-
name|first_glyph
expr_stmt|;
if|if
condition|(
operator|!
name|myanmar_shape_syllable
argument_list|(
name|openType
argument_list|,
operator|&
name|syllable
argument_list|,
name|invalid
argument_list|)
condition|)
block|{
name|MMDEBUG
argument_list|(
literal|"syllable shaping failed, syllable requests %d glyphs"
argument_list|,
name|syllable
operator|.
name|num_glyphs
argument_list|)
expr_stmt|;
name|item
operator|->
name|num_glyphs
operator|+=
name|syllable
operator|.
name|num_glyphs
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* fix logcluster array */
name|MMDEBUG
argument_list|(
literal|"syllable:"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|first_glyph
init|;
name|i
operator|<
name|first_glyph
operator|+
operator|(
name|int
operator|)
name|syllable
operator|.
name|num_glyphs
condition|;
operator|++
name|i
control|)
name|MMDEBUG
argument_list|(
literal|"        %d -> glyph %x"
argument_list|,
name|i
argument_list|,
name|item
operator|->
name|glyphs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|MMDEBUG
argument_list|(
literal|"    logclusters:"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|sstart
init|;
name|i
operator|<
name|send
condition|;
operator|++
name|i
control|)
block|{
name|MMDEBUG
argument_list|(
literal|"        %d -> glyph %d"
argument_list|,
name|i
argument_list|,
name|first_glyph
argument_list|)
expr_stmt|;
name|logClusters
index|[
name|i
operator|-
name|item
operator|->
name|item
operator|.
name|pos
index|]
operator|=
name|first_glyph
expr_stmt|;
block|}
name|sstart
operator|=
name|send
expr_stmt|;
name|first_glyph
operator|+=
name|syllable
operator|.
name|num_glyphs
expr_stmt|;
block|}
name|item
operator|->
name|num_glyphs
operator|=
name|first_glyph
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function
begin_function
DECL|function|HB_MyanmarAttributes
name|void
name|HB_MyanmarAttributes
parameter_list|(
name|HB_Script
name|script
parameter_list|,
specifier|const
name|HB_UChar16
modifier|*
name|text
parameter_list|,
name|hb_uint32
name|from
parameter_list|,
name|hb_uint32
name|len
parameter_list|,
name|HB_CharAttributes
modifier|*
name|attributes
parameter_list|)
block|{
name|int
name|end
init|=
name|from
operator|+
name|len
decl_stmt|;
specifier|const
name|HB_UChar16
modifier|*
name|uc
init|=
name|text
operator|+
name|from
decl_stmt|;
name|hb_uint32
name|i
init|=
literal|0
decl_stmt|;
name|HB_UNUSED
argument_list|(
name|script
argument_list|)
expr_stmt|;
name|attributes
operator|+=
name|from
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|len
condition|)
block|{
name|HB_Bool
name|invalid
decl_stmt|;
name|hb_uint32
name|boundary
init|=
name|myanmar_nextSyllableBoundary
argument_list|(
name|text
argument_list|,
name|from
operator|+
name|i
argument_list|,
name|end
argument_list|,
operator|&
name|invalid
argument_list|)
operator|-
name|from
decl_stmt|;
name|attributes
index|[
name|i
index|]
operator|.
name|charStop
operator|=
name|TRUE
expr_stmt|;
name|attributes
index|[
name|i
index|]
operator|.
name|lineBreakType
operator|=
name|HB_Break
expr_stmt|;
if|if
condition|(
name|boundary
operator|>
name|len
operator|-
literal|1
condition|)
name|boundary
operator|=
name|len
expr_stmt|;
name|i
operator|++
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|boundary
condition|)
block|{
name|attributes
index|[
name|i
index|]
operator|.
name|charStop
operator|=
name|FALSE
expr_stmt|;
operator|++
name|uc
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
name|assert
argument_list|(
name|i
operator|==
name|boundary
argument_list|)
expr_stmt|;
block|}
block|}
end_function
end_unit
