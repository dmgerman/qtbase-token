begin_unit
begin_comment
comment|/*  * Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies)  *  * This is part of HarfBuzz, an OpenType Layout engine library.  *  * Permission is hereby granted, without written agreement and without  * license or royalty fees, to use, copy, modify, and distribute this  * software and its documentation for any purpose, provided that the  * above copyright notice and the following two paragraphs appear in  * all copies of this software.  *  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH  * DAMAGE.  *  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS  * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.  */
end_comment
begin_include
include|#
directive|include
file|"harfbuzz-shaper.h"
end_include
begin_include
include|#
directive|include
file|"harfbuzz-shaper-private.h"
end_include
begin_include
include|#
directive|include
file|<assert.h>
end_include
begin_decl_stmt
DECL|variable|ReplacementCharacter
specifier|static
specifier|const
name|HB_UChar16
name|ReplacementCharacter
init|=
literal|0xfffd
decl_stmt|;
end_decl_stmt
begin_typedef
typedef|typedef
struct|struct
block|{
DECL|member|shape
name|unsigned
name|char
name|shape
decl_stmt|;
DECL|member|justification
name|unsigned
name|char
name|justification
decl_stmt|;
block|}
DECL|typedef|HB_ArabicProperties
name|HB_ArabicProperties
typedef|;
end_typedef
begin_typedef
typedef|typedef
enum|enum
block|{
DECL|enumerator|XIsolated
name|XIsolated
block|,
DECL|enumerator|XFinal
name|XFinal
block|,
DECL|enumerator|XInitial
name|XInitial
block|,
DECL|enumerator|XMedial
name|XMedial
block|,
comment|/* intermediate state */
DECL|enumerator|XCausing
name|XCausing
block|}
DECL|typedef|ArabicShape
name|ArabicShape
typedef|;
end_typedef
begin_comment
comment|/* // these groups correspond to the groups defined in the Unicode standard. // Some of these groups are equal with regards to both joining and line breaking behaviour, // and thus have the same enum value // // I'm not sure the mapping of syriac to arabic enums is correct with regards to justification, but as // I couldn't find any better document I'll hope for the best. */
end_comment
begin_typedef
typedef|typedef
enum|enum
block|{
comment|/* NonJoining */
DECL|enumerator|ArabicNone
name|ArabicNone
block|,
DECL|enumerator|ArabicSpace
name|ArabicSpace
block|,
comment|/* Transparent */
DECL|enumerator|Transparent
name|Transparent
block|,
comment|/* Causing */
DECL|enumerator|Center
name|Center
block|,
DECL|enumerator|Kashida
name|Kashida
block|,
comment|/* Arabic */
comment|/* Dual */
DECL|enumerator|Beh
name|Beh
block|,
DECL|enumerator|Noon
name|Noon
block|,
DECL|enumerator|Nya
name|Nya
init|=
name|Noon
block|,
DECL|enumerator|Meem
name|Meem
init|=
name|Noon
block|,
DECL|enumerator|Heh
name|Heh
init|=
name|Noon
block|,
DECL|enumerator|KnottedHeh
name|KnottedHeh
init|=
name|Noon
block|,
DECL|enumerator|HehGoal
name|HehGoal
init|=
name|Noon
block|,
DECL|enumerator|SwashKaf
name|SwashKaf
init|=
name|Noon
block|,
DECL|enumerator|Yeh
name|Yeh
block|,
DECL|enumerator|FarsiYeh
name|FarsiYeh
init|=
name|Yeh
block|,
DECL|enumerator|Hah
name|Hah
block|,
DECL|enumerator|Seen
name|Seen
block|,
DECL|enumerator|Sad
name|Sad
init|=
name|Seen
block|,
DECL|enumerator|Tah
name|Tah
block|,
DECL|enumerator|Kaf
name|Kaf
init|=
name|Tah
block|,
DECL|enumerator|Gaf
name|Gaf
init|=
name|Tah
block|,
DECL|enumerator|Lam
name|Lam
init|=
name|Tah
block|,
DECL|enumerator|Ain
name|Ain
block|,
DECL|enumerator|Feh
name|Feh
init|=
name|Ain
block|,
DECL|enumerator|Qaf
name|Qaf
init|=
name|Ain
block|,
comment|/* Right */
DECL|enumerator|Alef
name|Alef
block|,
DECL|enumerator|Waw
name|Waw
block|,
DECL|enumerator|Dal
name|Dal
block|,
DECL|enumerator|TehMarbuta
name|TehMarbuta
init|=
name|Dal
block|,
DECL|enumerator|Reh
name|Reh
block|,
DECL|enumerator|TehMarbutaGoal
name|TehMarbutaGoal
block|,
DECL|enumerator|HamzaOnHehGoal
name|HamzaOnHehGoal
init|=
name|TehMarbutaGoal
block|,
comment|/* has been retained as a property value alias */
DECL|enumerator|YehWithTail
name|YehWithTail
init|=
name|TehMarbutaGoal
block|,
DECL|enumerator|YehBarree
name|YehBarree
init|=
name|TehMarbutaGoal
block|,
comment|/* Syriac */
comment|/* Dual */
DECL|enumerator|Beth
name|Beth
init|=
name|Beh
block|,
DECL|enumerator|Gamal
name|Gamal
init|=
name|Ain
block|,
DECL|enumerator|Heth
name|Heth
init|=
name|Noon
block|,
DECL|enumerator|Teth
name|Teth
init|=
name|Hah
block|,
DECL|enumerator|Yudh
name|Yudh
init|=
name|Noon
block|,
DECL|enumerator|Khaph
name|Khaph
init|=
name|Noon
block|,
DECL|enumerator|Lamadh
name|Lamadh
init|=
name|Lam
block|,
DECL|enumerator|Mim
name|Mim
init|=
name|Noon
block|,
DECL|enumerator|Nun
name|Nun
init|=
name|Noon
block|,
DECL|enumerator|Semkath
name|Semkath
init|=
name|Noon
block|,
DECL|enumerator|FinalSemkath
name|FinalSemkath
init|=
name|Noon
block|,
DECL|enumerator|SyriacE
name|SyriacE
init|=
name|Ain
block|,
DECL|enumerator|Pe
name|Pe
init|=
name|Ain
block|,
DECL|enumerator|ReversedPe
name|ReversedPe
init|=
name|Hah
block|,
DECL|enumerator|Qaph
name|Qaph
init|=
name|Noon
block|,
DECL|enumerator|Shin
name|Shin
init|=
name|Noon
block|,
DECL|enumerator|Fe
name|Fe
init|=
name|Ain
block|,
comment|/* Right */
DECL|enumerator|Alaph
name|Alaph
init|=
name|Alef
block|,
DECL|enumerator|DalathRish
name|DalathRish
init|=
name|Dal
block|,
DECL|enumerator|He
name|He
init|=
name|Dal
block|,
DECL|enumerator|SyriacWaw
name|SyriacWaw
init|=
name|Waw
block|,
DECL|enumerator|Zhain
name|Zhain
init|=
name|Alef
block|,
DECL|enumerator|YudhHe
name|YudhHe
init|=
name|Waw
block|,
DECL|enumerator|Sadhe
name|Sadhe
init|=
name|TehMarbutaGoal
block|,
DECL|enumerator|Taw
name|Taw
init|=
name|Dal
block|,
comment|/* Compiler bug? Otherwise ArabicGroupsEnd would be equal to Dal + 1. */
DECL|enumerator|Dummy
name|Dummy
init|=
name|TehMarbutaGoal
block|,
DECL|enumerator|ArabicGroupsEnd
name|ArabicGroupsEnd
block|}
DECL|typedef|ArabicGroup
name|ArabicGroup
typedef|;
end_typedef
begin_decl_stmt
DECL|variable|arabic_group
specifier|static
specifier|const
name|unsigned
name|char
name|arabic_group
index|[
literal|0x150
index|]
init|=
block|{
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|Yeh
block|,
name|ArabicNone
block|,
name|Alef
block|,
name|Alef
block|,
name|Waw
block|,
name|Alef
block|,
name|Yeh
block|,
name|Alef
block|,
name|Beh
block|,
name|TehMarbuta
block|,
name|Beh
block|,
name|Beh
block|,
name|Hah
block|,
name|Hah
block|,
name|Hah
block|,
name|Dal
block|,
name|Dal
block|,
name|Reh
block|,
name|Reh
block|,
name|Seen
block|,
name|Seen
block|,
name|Sad
block|,
name|Sad
block|,
name|Tah
block|,
name|Tah
block|,
name|Ain
block|,
name|Ain
block|,
name|Gaf
block|,
name|Gaf
block|,
name|FarsiYeh
block|,
name|FarsiYeh
block|,
name|FarsiYeh
block|,
comment|/* 0x640 */
name|Kashida
block|,
name|Feh
block|,
name|Qaf
block|,
name|Kaf
block|,
name|Lam
block|,
name|Meem
block|,
name|Noon
block|,
name|Heh
block|,
name|Waw
block|,
name|Yeh
block|,
name|Yeh
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|Beh
block|,
name|Qaf
block|,
name|Transparent
block|,
name|Alef
block|,
name|Alef
block|,
name|Alef
block|,
name|ArabicNone
block|,
name|Alef
block|,
name|Waw
block|,
name|Waw
block|,
name|Yeh
block|,
name|Beh
block|,
name|Beh
block|,
name|Beh
block|,
name|Beh
block|,
name|Beh
block|,
name|Beh
block|,
name|Beh
block|,
comment|/* 0x680 */
name|Beh
block|,
name|Hah
block|,
name|Hah
block|,
name|Hah
block|,
name|Hah
block|,
name|Hah
block|,
name|Hah
block|,
name|Hah
block|,
name|Dal
block|,
name|Dal
block|,
name|Dal
block|,
name|Dal
block|,
name|Dal
block|,
name|Dal
block|,
name|Dal
block|,
name|Dal
block|,
name|Dal
block|,
name|Reh
block|,
name|Reh
block|,
name|Reh
block|,
name|Reh
block|,
name|Reh
block|,
name|Reh
block|,
name|Reh
block|,
name|Reh
block|,
name|Reh
block|,
name|Seen
block|,
name|Seen
block|,
name|Seen
block|,
name|Sad
block|,
name|Sad
block|,
name|Tah
block|,
name|Ain
block|,
name|Feh
block|,
name|Feh
block|,
name|Feh
block|,
name|Feh
block|,
name|Feh
block|,
name|Feh
block|,
name|Qaf
block|,
name|Qaf
block|,
name|Gaf
block|,
name|SwashKaf
block|,
name|Gaf
block|,
name|Kaf
block|,
name|Kaf
block|,
name|Kaf
block|,
name|Gaf
block|,
name|Gaf
block|,
name|Gaf
block|,
name|Gaf
block|,
name|Gaf
block|,
name|Gaf
block|,
name|Lam
block|,
name|Lam
block|,
name|Lam
block|,
name|Lam
block|,
name|Noon
block|,
name|Noon
block|,
name|Noon
block|,
name|Noon
block|,
name|Nya
block|,
name|KnottedHeh
block|,
name|Hah
block|,
comment|/* 0x6c0 */
name|TehMarbuta
block|,
name|HehGoal
block|,
name|HehGoal
block|,
name|TehMarbutaGoal
block|,
name|Waw
block|,
name|Waw
block|,
name|Waw
block|,
name|Waw
block|,
name|Waw
block|,
name|Waw
block|,
name|Waw
block|,
name|Waw
block|,
name|FarsiYeh
block|,
name|YehWithTail
block|,
name|FarsiYeh
block|,
name|Waw
block|,
name|Yeh
block|,
name|Yeh
block|,
name|YehBarree
block|,
name|YehBarree
block|,
name|ArabicNone
block|,
name|TehMarbuta
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|Transparent
block|,
name|Transparent
block|,
name|ArabicNone
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Dal
block|,
name|Reh
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|Seen
block|,
name|Sad
block|,
name|Ain
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|KnottedHeh
block|,
comment|/* 0x700 */
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|Transparent
block|,
name|Alaph
block|,
name|Transparent
block|,
name|Beth
block|,
name|Gamal
block|,
name|Gamal
block|,
name|DalathRish
block|,
name|DalathRish
block|,
name|He
block|,
name|SyriacWaw
block|,
name|Zhain
block|,
name|Heth
block|,
name|Teth
block|,
name|Teth
block|,
name|Yudh
block|,
name|YudhHe
block|,
name|Khaph
block|,
name|Lamadh
block|,
name|Mim
block|,
name|Nun
block|,
name|Semkath
block|,
name|FinalSemkath
block|,
name|SyriacE
block|,
name|Pe
block|,
name|ReversedPe
block|,
name|Sadhe
block|,
name|Qaph
block|,
name|DalathRish
block|,
name|Shin
block|,
name|Taw
block|,
name|Beth
block|,
name|Gamal
block|,
name|DalathRish
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|Transparent
block|,
name|ArabicNone
block|,
name|ArabicNone
block|,
name|Zhain
block|,
name|Khaph
block|,
name|Fe
block|, }
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|arabicGroup
specifier|static
name|ArabicGroup
name|arabicGroup
parameter_list|(
name|unsigned
name|short
name|uc
parameter_list|)
block|{
if|if
condition|(
name|uc
operator|>=
literal|0x0600
operator|&&
name|uc
operator|<
literal|0x750
condition|)
return|return
operator|(
name|ArabicGroup
operator|)
name|arabic_group
index|[
name|uc
operator|-
literal|0x600
index|]
return|;
elseif|else
if|if
condition|(
name|uc
operator|==
literal|0x200d
condition|)
return|return
name|Center
return|;
elseif|else
if|if
condition|(
name|HB_GetUnicodeCharCategory
argument_list|(
name|uc
argument_list|)
operator|==
name|HB_Separator_Space
condition|)
return|return
name|ArabicSpace
return|;
else|else
return|return
name|ArabicNone
return|;
block|}
end_function
begin_comment
comment|/*    Arabic shaping obeys a number of rules according to the joining classes (see Unicode book, section on    arabic).     Each unicode char has a joining class (right, dual (left&right), center (joincausing) or transparent).    transparent joining is not encoded in HB_UChar16::joining(), but applies to all combining marks and format marks.     Right join-causing: dual + center    Left join-causing: dual + right + center     Rules are as follows (for a string already in visual order, as we have it here):     R1 Transparent characters do not affect joining behaviour.    R2 A right joining character, that has a right join-causing char on the right will get form XRight    (R3 A left joining character, that has a left join-causing char on the left will get form XLeft)    Note: the above rule is meaningless, as there are no pure left joining characters defined in Unicode    R4 A dual joining character, that has a left join-causing char on the left and a right join-causing char on              the right will get form XMedial    R5  A dual joining character, that has a right join causing char on the right, and no left join causing char on the left          will get form XRight    R6 A dual joining character, that has a  left join causing char on the left, and no right join causing char on the right          will get form XLeft    R7 Otherwise the character will get form XIsolated     Additionally we have to do the minimal ligature support for lam-alef ligatures:     L1 Transparent characters do not affect ligature behaviour.    L2 Any sequence of Alef(XRight) + Lam(XMedial) will form the ligature Alef.Lam(XLeft)    L3 Any sequence of Alef(XRight) + Lam(XLeft) will form the ligature Alef.Lam(XIsolated)     The state table below handles rules R1-R7. */
end_comment
begin_typedef
typedef|typedef
enum|enum
block|{
DECL|enumerator|JNone
name|JNone
block|,
DECL|enumerator|JCausing
name|JCausing
block|,
DECL|enumerator|JDual
name|JDual
block|,
DECL|enumerator|JRight
name|JRight
block|,
DECL|enumerator|JTransparent
name|JTransparent
block|}
DECL|typedef|Joining
name|Joining
typedef|;
end_typedef
begin_decl_stmt
DECL|variable|joining_for_group
specifier|static
specifier|const
name|Joining
name|joining_for_group
index|[
name|ArabicGroupsEnd
index|]
init|=
block|{
comment|/* NonJoining */
name|JNone
block|,
comment|/* ArabicNone */
name|JNone
block|,
comment|/* ArabicSpace */
comment|/* Transparent */
name|JTransparent
block|,
comment|/* Transparent */
comment|/* Causing */
name|JCausing
block|,
comment|/* Center */
name|JCausing
block|,
comment|/* Kashida */
comment|/* Dual */
name|JDual
block|,
comment|/* Beh */
name|JDual
block|,
comment|/* Noon */
name|JDual
block|,
comment|/* Yeh */
name|JDual
block|,
comment|/* Hah */
name|JDual
block|,
comment|/* Seen */
name|JDual
block|,
comment|/* Tah */
name|JDual
block|,
comment|/* Ain */
comment|/* Right */
name|JRight
block|,
comment|/* Alef */
name|JRight
block|,
comment|/* Waw */
name|JRight
block|,
comment|/* Dal */
name|JRight
block|,
comment|/* Reh */
name|JRight
comment|/* TehMarbutaGoal */
block|}
decl_stmt|;
end_decl_stmt
begin_typedef
typedef|typedef
struct|struct
block|{
DECL|member|form1
name|ArabicShape
name|form1
decl_stmt|;
DECL|member|form2
name|ArabicShape
name|form2
decl_stmt|;
block|}
DECL|typedef|JoiningPair
name|JoiningPair
typedef|;
end_typedef
begin_decl_stmt
DECL|variable|joining_table
specifier|static
specifier|const
name|JoiningPair
name|joining_table
index|[
literal|5
index|]
index|[
literal|4
index|]
init|=
comment|/* None, Causing, Dual, Right */
block|{
block|{
block|{
name|XIsolated
block|,
name|XIsolated
block|}
block|,
block|{
name|XIsolated
block|,
name|XCausing
block|}
block|,
block|{
name|XIsolated
block|,
name|XInitial
block|}
block|,
block|{
name|XIsolated
block|,
name|XIsolated
block|}
block|}
block|,
comment|/* XIsolated */
block|{
block|{
name|XFinal
block|,
name|XIsolated
block|}
block|,
block|{
name|XFinal
block|,
name|XCausing
block|}
block|,
block|{
name|XFinal
block|,
name|XInitial
block|}
block|,
block|{
name|XFinal
block|,
name|XIsolated
block|}
block|}
block|,
comment|/* XFinal */
block|{
block|{
name|XIsolated
block|,
name|XIsolated
block|}
block|,
block|{
name|XInitial
block|,
name|XCausing
block|}
block|,
block|{
name|XInitial
block|,
name|XMedial
block|}
block|,
block|{
name|XInitial
block|,
name|XFinal
block|}
block|}
block|,
comment|/* XInitial */
block|{
block|{
name|XFinal
block|,
name|XIsolated
block|}
block|,
block|{
name|XMedial
block|,
name|XCausing
block|}
block|,
block|{
name|XMedial
block|,
name|XMedial
block|}
block|,
block|{
name|XMedial
block|,
name|XFinal
block|}
block|}
block|,
comment|/* XMedial */
block|{
block|{
name|XIsolated
block|,
name|XIsolated
block|}
block|,
block|{
name|XIsolated
block|,
name|XCausing
block|}
block|,
block|{
name|XIsolated
block|,
name|XMedial
block|}
block|,
block|{
name|XIsolated
block|,
name|XFinal
block|}
block|}
block|,
comment|/* XCausing */
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* According to http://www.microsoft.com/middleeast/Arabicdev/IE6/KBase.asp  1. Find the priority of the connecting opportunities in each word 2. Add expansion at the highest priority connection opportunity 3. If more than one connection opportunity have the same highest value,    use the opportunity closest to the end of the word.  Following is a chart that provides the priority for connection opportunities and where expansion occurs. The character group names are those in table 6.6 of the UNICODE 2.0 book.   PrioritY        Glyph                   Condition                                       Kashida Location  Arabic_Kashida        User inserted Kashida   The user entered a Kashida in a position.       After the user                 (Shift+j or Shift+[E with hat])    Thus, it is the highest priority to insert an   inserted kashida                                         automatic kashida.  Arabic_Seen        Seen, Sad               Connecting to the next character.               After the character.                                         (Initial or medial form).  Arabic_HaaDal        Teh Marbutah, Haa, Dal  Connecting to previous character.               Before the final form                                                                                         of these characters.  Arabic_Alef     Alef, Tah, Lam,         Connecting to previous character.               Before the final form                 Kaf and Gaf                                                             of these characters.  Arabic_BaRa     Reh, Yeh                Connected to medial Beh                         Before preceding medial Baa  Arabic_Waw        Waw, Ain, Qaf, Feh      Connecting to previous character.               Before the final form of                                                                                         these characters.  Arabic_Normal   Other connecting        Connecting to previous character.               Before the final form                 characters                                                              of these characters.    This seems to imply that we have at most one kashida point per arabic word.  */
end_comment
begin_function
DECL|function|getArabicProperties
specifier|static
name|void
name|getArabicProperties
parameter_list|(
specifier|const
name|unsigned
name|short
modifier|*
name|chars
parameter_list|,
name|int
name|len
parameter_list|,
name|HB_ArabicProperties
modifier|*
name|properties
parameter_list|)
block|{
comment|/*     qDebug("arabicSyriacOpenTypeShape: properties:"); */
name|int
name|lastPos
init|=
literal|0
decl_stmt|;
name|int
name|lastGroup
init|=
name|ArabicNone
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|ArabicGroup
name|group
init|=
name|arabicGroup
argument_list|(
name|chars
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|Joining
name|j
init|=
name|joining_for_group
index|[
name|group
index|]
decl_stmt|;
name|ArabicShape
name|shape
init|=
name|joining_table
index|[
name|XIsolated
index|]
index|[
name|j
index|]
operator|.
name|form2
decl_stmt|;
name|properties
index|[
literal|0
index|]
operator|.
name|justification
operator|=
name|HB_NoJustification
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
comment|/* #### fix handling for spaces and punktuation */
name|properties
index|[
name|i
index|]
operator|.
name|justification
operator|=
name|HB_NoJustification
expr_stmt|;
name|group
operator|=
name|arabicGroup
argument_list|(
name|chars
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|j
operator|=
name|joining_for_group
index|[
name|group
index|]
expr_stmt|;
if|if
condition|(
name|j
operator|==
name|JTransparent
condition|)
block|{
name|properties
index|[
name|i
index|]
operator|.
name|shape
operator|=
name|XIsolated
expr_stmt|;
continue|continue;
block|}
name|properties
index|[
name|lastPos
index|]
operator|.
name|shape
operator|=
name|joining_table
index|[
name|shape
index|]
index|[
name|j
index|]
operator|.
name|form1
expr_stmt|;
name|shape
operator|=
name|joining_table
index|[
name|shape
index|]
index|[
name|j
index|]
operator|.
name|form2
expr_stmt|;
switch|switch
condition|(
name|lastGroup
condition|)
block|{
case|case
name|Seen
case|:
if|if
condition|(
name|properties
index|[
name|lastPos
index|]
operator|.
name|shape
operator|==
name|XInitial
operator|||
name|properties
index|[
name|lastPos
index|]
operator|.
name|shape
operator|==
name|XMedial
condition|)
name|properties
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|justification
operator|=
name|HB_Arabic_Seen
expr_stmt|;
break|break;
case|case
name|Hah
case|:
if|if
condition|(
name|properties
index|[
name|lastPos
index|]
operator|.
name|shape
operator|==
name|XFinal
condition|)
name|properties
index|[
name|lastPos
operator|-
literal|1
index|]
operator|.
name|justification
operator|=
name|HB_Arabic_HaaDal
expr_stmt|;
break|break;
case|case
name|Alef
case|:
if|if
condition|(
name|properties
index|[
name|lastPos
index|]
operator|.
name|shape
operator|==
name|XFinal
condition|)
name|properties
index|[
name|lastPos
operator|-
literal|1
index|]
operator|.
name|justification
operator|=
name|HB_Arabic_Alef
expr_stmt|;
break|break;
case|case
name|Ain
case|:
if|if
condition|(
name|properties
index|[
name|lastPos
index|]
operator|.
name|shape
operator|==
name|XFinal
condition|)
name|properties
index|[
name|lastPos
operator|-
literal|1
index|]
operator|.
name|justification
operator|=
name|HB_Arabic_Waw
expr_stmt|;
break|break;
case|case
name|Noon
case|:
if|if
condition|(
name|properties
index|[
name|lastPos
index|]
operator|.
name|shape
operator|==
name|XFinal
condition|)
name|properties
index|[
name|lastPos
operator|-
literal|1
index|]
operator|.
name|justification
operator|=
name|HB_Arabic_Normal
expr_stmt|;
break|break;
case|case
name|ArabicNone
case|:
break|break;
default|default:
name|assert
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|lastGroup
operator|=
name|ArabicNone
expr_stmt|;
switch|switch
condition|(
name|group
condition|)
block|{
case|case
name|ArabicNone
case|:
case|case
name|Transparent
case|:
comment|/* ### Center should probably be treated as transparent when it comes to justification. */
case|case
name|Center
case|:
break|break;
case|case
name|ArabicSpace
case|:
name|properties
index|[
name|i
index|]
operator|.
name|justification
operator|=
name|HB_Arabic_Space
expr_stmt|;
break|break;
case|case
name|Kashida
case|:
name|properties
index|[
name|i
index|]
operator|.
name|justification
operator|=
name|HB_Arabic_Kashida
expr_stmt|;
break|break;
case|case
name|Seen
case|:
name|lastGroup
operator|=
name|Seen
expr_stmt|;
break|break;
case|case
name|Hah
case|:
case|case
name|Dal
case|:
name|lastGroup
operator|=
name|Hah
expr_stmt|;
break|break;
case|case
name|Alef
case|:
case|case
name|Tah
case|:
name|lastGroup
operator|=
name|Alef
expr_stmt|;
break|break;
case|case
name|Yeh
case|:
case|case
name|Reh
case|:
if|if
condition|(
name|properties
index|[
name|lastPos
index|]
operator|.
name|shape
operator|==
name|XMedial
operator|&&
name|arabicGroup
argument_list|(
name|chars
index|[
name|lastPos
index|]
argument_list|)
operator|==
name|Beh
condition|)
name|properties
index|[
name|lastPos
operator|-
literal|1
index|]
operator|.
name|justification
operator|=
name|HB_Arabic_BaRa
expr_stmt|;
break|break;
case|case
name|Ain
case|:
case|case
name|Waw
case|:
name|lastGroup
operator|=
name|Ain
expr_stmt|;
break|break;
case|case
name|Noon
case|:
case|case
name|Beh
case|:
case|case
name|TehMarbutaGoal
case|:
name|lastGroup
operator|=
name|Noon
expr_stmt|;
break|break;
case|case
name|ArabicGroupsEnd
case|:
name|assert
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|lastPos
operator|=
name|i
expr_stmt|;
block|}
name|properties
index|[
name|lastPos
index|]
operator|.
name|shape
operator|=
name|joining_table
index|[
name|shape
index|]
index|[
name|JNone
index|]
operator|.
name|form1
expr_stmt|;
comment|/*      for (int i = 0; i< len; ++i)          qDebug("arabic properties(%d): uc=%x shape=%d, justification=%d", i, chars[i], properties[i].shape, properties[i].justification);     */
block|}
end_function
begin_function
DECL|function|getNkoJoining
specifier|static
name|Joining
name|getNkoJoining
parameter_list|(
name|unsigned
name|short
name|uc
parameter_list|)
block|{
if|if
condition|(
name|uc
operator|<
literal|0x7ca
condition|)
return|return
name|JNone
return|;
if|if
condition|(
name|uc
operator|<=
literal|0x7ea
condition|)
return|return
name|JDual
return|;
if|if
condition|(
name|uc
operator|<=
literal|0x7f3
condition|)
return|return
name|JTransparent
return|;
if|if
condition|(
name|uc
operator|<=
literal|0x7f9
condition|)
return|return
name|JNone
return|;
if|if
condition|(
name|uc
operator|==
literal|0x7fa
condition|)
return|return
name|JCausing
return|;
return|return
name|JNone
return|;
block|}
end_function
begin_function
DECL|function|getNkoProperties
specifier|static
name|void
name|getNkoProperties
parameter_list|(
specifier|const
name|unsigned
name|short
modifier|*
name|chars
parameter_list|,
name|int
name|len
parameter_list|,
name|HB_ArabicProperties
modifier|*
name|properties
parameter_list|)
block|{
name|int
name|lastPos
init|=
literal|0
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|Joining
name|j
init|=
name|getNkoJoining
argument_list|(
name|chars
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|ArabicShape
name|shape
init|=
name|joining_table
index|[
name|XIsolated
index|]
index|[
name|j
index|]
operator|.
name|form2
decl_stmt|;
name|properties
index|[
literal|0
index|]
operator|.
name|justification
operator|=
name|HB_NoJustification
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
name|properties
index|[
name|i
index|]
operator|.
name|justification
operator|=
operator|(
name|HB_GetUnicodeCharCategory
argument_list|(
name|chars
index|[
name|i
index|]
argument_list|)
operator|==
name|HB_Separator_Space
operator|)
condition|?
name|ArabicSpace
else|:
name|ArabicNone
expr_stmt|;
name|j
operator|=
name|getNkoJoining
argument_list|(
name|chars
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|==
name|JTransparent
condition|)
block|{
name|properties
index|[
name|i
index|]
operator|.
name|shape
operator|=
name|XIsolated
expr_stmt|;
continue|continue;
block|}
name|properties
index|[
name|lastPos
index|]
operator|.
name|shape
operator|=
name|joining_table
index|[
name|shape
index|]
index|[
name|j
index|]
operator|.
name|form1
expr_stmt|;
name|shape
operator|=
name|joining_table
index|[
name|shape
index|]
index|[
name|j
index|]
operator|.
name|form2
expr_stmt|;
name|lastPos
operator|=
name|i
expr_stmt|;
block|}
name|properties
index|[
name|lastPos
index|]
operator|.
name|shape
operator|=
name|joining_table
index|[
name|shape
index|]
index|[
name|JNone
index|]
operator|.
name|form1
expr_stmt|;
comment|/*      for (int i = 0; i< len; ++i)          qDebug("nko properties(%d): uc=%x shape=%d, justification=%d", i, chars[i], properties[i].shape, properties[i].justification);     */
block|}
end_function
begin_comment
comment|/* // The unicode to unicode shaping codec. // does only presentation forms B at the moment, but that should be enough for // simple display */
end_comment
begin_decl_stmt
DECL|variable|arabicUnicodeMapping
specifier|static
specifier|const
name|hb_uint16
name|arabicUnicodeMapping
index|[
literal|256
index|]
index|[
literal|2
index|]
init|=
block|{
comment|/* base of shaped forms, and number-1 of them (0 for non shaping,        1 for right binding and 3 for dual binding */
comment|/* These are just the glyphs available in Unicode,        some characters are in R class, but have no glyphs in Unicode. */
block|{
literal|0x0600
block|,
literal|0
block|}
block|,
comment|/* 0x0600 */
block|{
literal|0x0601
block|,
literal|0
block|}
block|,
comment|/* 0x0601 */
block|{
literal|0x0602
block|,
literal|0
block|}
block|,
comment|/* 0x0602 */
block|{
literal|0x0603
block|,
literal|0
block|}
block|,
comment|/* 0x0603 */
block|{
literal|0x0604
block|,
literal|0
block|}
block|,
comment|/* 0x0604 */
block|{
literal|0x0605
block|,
literal|0
block|}
block|,
comment|/* 0x0605 */
block|{
literal|0x0606
block|,
literal|0
block|}
block|,
comment|/* 0x0606 */
block|{
literal|0x0607
block|,
literal|0
block|}
block|,
comment|/* 0x0607 */
block|{
literal|0x0608
block|,
literal|0
block|}
block|,
comment|/* 0x0608 */
block|{
literal|0x0609
block|,
literal|0
block|}
block|,
comment|/* 0x0609 */
block|{
literal|0x060A
block|,
literal|0
block|}
block|,
comment|/* 0x060A */
block|{
literal|0x060B
block|,
literal|0
block|}
block|,
comment|/* 0x060B */
block|{
literal|0x060C
block|,
literal|0
block|}
block|,
comment|/* 0x060C */
block|{
literal|0x060D
block|,
literal|0
block|}
block|,
comment|/* 0x060D */
block|{
literal|0x060E
block|,
literal|0
block|}
block|,
comment|/* 0x060E */
block|{
literal|0x060F
block|,
literal|0
block|}
block|,
comment|/* 0x060F */
block|{
literal|0x0610
block|,
literal|0
block|}
block|,
comment|/* 0x0610 */
block|{
literal|0x0611
block|,
literal|0
block|}
block|,
comment|/* 0x0611 */
block|{
literal|0x0612
block|,
literal|0
block|}
block|,
comment|/* 0x0612 */
block|{
literal|0x0613
block|,
literal|0
block|}
block|,
comment|/* 0x0613 */
block|{
literal|0x0614
block|,
literal|0
block|}
block|,
comment|/* 0x0614 */
block|{
literal|0x0615
block|,
literal|0
block|}
block|,
comment|/* 0x0615 */
block|{
literal|0x0616
block|,
literal|0
block|}
block|,
comment|/* 0x0616 */
block|{
literal|0x0617
block|,
literal|0
block|}
block|,
comment|/* 0x0617 */
block|{
literal|0x0618
block|,
literal|0
block|}
block|,
comment|/* 0x0618 */
block|{
literal|0x0619
block|,
literal|0
block|}
block|,
comment|/* 0x0619 */
block|{
literal|0x061A
block|,
literal|0
block|}
block|,
comment|/* 0x061A */
block|{
literal|0x061B
block|,
literal|0
block|}
block|,
comment|/* 0x061B */
block|{
literal|0x061C
block|,
literal|0
block|}
block|,
comment|/* 0x061C */
block|{
literal|0x061D
block|,
literal|0
block|}
block|,
comment|/* 0x061D */
block|{
literal|0x061E
block|,
literal|0
block|}
block|,
comment|/* 0x061E */
block|{
literal|0x061F
block|,
literal|0
block|}
block|,
comment|/* 0x061F */
block|{
literal|0x0620
block|,
literal|0
block|}
block|,
comment|/* 0x0620 */
block|{
literal|0xFE80
block|,
literal|0
block|}
block|,
comment|/* 0x0621            HAMZA */
block|{
literal|0xFE81
block|,
literal|1
block|}
block|,
comment|/* 0x0622    R       ALEF WITH MADDA ABOVE */
block|{
literal|0xFE83
block|,
literal|1
block|}
block|,
comment|/* 0x0623    R       ALEF WITH HAMZA ABOVE */
block|{
literal|0xFE85
block|,
literal|1
block|}
block|,
comment|/* 0x0624    R       WAW WITH HAMZA ABOVE */
block|{
literal|0xFE87
block|,
literal|1
block|}
block|,
comment|/* 0x0625    R       ALEF WITH HAMZA BELOW */
block|{
literal|0xFE89
block|,
literal|3
block|}
block|,
comment|/* 0x0626    D       YEH WITH HAMZA ABOVE */
block|{
literal|0xFE8D
block|,
literal|1
block|}
block|,
comment|/* 0x0627    R       ALEF */
block|{
literal|0xFE8F
block|,
literal|3
block|}
block|,
comment|/* 0x0628    D       BEH */
block|{
literal|0xFE93
block|,
literal|1
block|}
block|,
comment|/* 0x0629    R       TEH MARBUTA */
block|{
literal|0xFE95
block|,
literal|3
block|}
block|,
comment|/* 0x062A    D       TEH */
block|{
literal|0xFE99
block|,
literal|3
block|}
block|,
comment|/* 0x062B    D       THEH */
block|{
literal|0xFE9D
block|,
literal|3
block|}
block|,
comment|/* 0x062C    D       JEEM */
block|{
literal|0xFEA1
block|,
literal|3
block|}
block|,
comment|/* 0x062D    D       HAH */
block|{
literal|0xFEA5
block|,
literal|3
block|}
block|,
comment|/* 0x062E    D       KHAH */
block|{
literal|0xFEA9
block|,
literal|1
block|}
block|,
comment|/* 0x062F    R       DAL */
block|{
literal|0xFEAB
block|,
literal|1
block|}
block|,
comment|/* 0x0630    R       THAL */
block|{
literal|0xFEAD
block|,
literal|1
block|}
block|,
comment|/* 0x0631    R       REH */
block|{
literal|0xFEAF
block|,
literal|1
block|}
block|,
comment|/* 0x0632    R       ZHAIN */
block|{
literal|0xFEB1
block|,
literal|3
block|}
block|,
comment|/* 0x0633    D       SEEN */
block|{
literal|0xFEB5
block|,
literal|3
block|}
block|,
comment|/* 0x0634    D       SHEEN */
block|{
literal|0xFEB9
block|,
literal|3
block|}
block|,
comment|/* 0x0635    D       SAD */
block|{
literal|0xFEBD
block|,
literal|3
block|}
block|,
comment|/* 0x0636    D       DAD */
block|{
literal|0xFEC1
block|,
literal|3
block|}
block|,
comment|/* 0x0637    D       TAH */
block|{
literal|0xFEC5
block|,
literal|3
block|}
block|,
comment|/* 0x0638    D       ZAH */
block|{
literal|0xFEC9
block|,
literal|3
block|}
block|,
comment|/* 0x0639    D       AIN */
block|{
literal|0xFECD
block|,
literal|3
block|}
block|,
comment|/* 0x063A    D       GHAIN */
block|{
literal|0x063B
block|,
literal|0
block|}
block|,
comment|/* 0x063B */
block|{
literal|0x063C
block|,
literal|0
block|}
block|,
comment|/* 0x063C */
block|{
literal|0x063D
block|,
literal|0
block|}
block|,
comment|/* 0x063D */
block|{
literal|0x063E
block|,
literal|0
block|}
block|,
comment|/* 0x063E */
block|{
literal|0x063F
block|,
literal|0
block|}
block|,
comment|/* 0x063F */
block|{
literal|0x0640
block|,
literal|0
block|}
block|,
comment|/* 0x0640    C       TATWEEL // ### Join Causing, only one glyph */
block|{
literal|0xFED1
block|,
literal|3
block|}
block|,
comment|/* 0x0641    D       FEH */
block|{
literal|0xFED5
block|,
literal|3
block|}
block|,
comment|/* 0x0642    D       QAF */
block|{
literal|0xFED9
block|,
literal|3
block|}
block|,
comment|/* 0x0643    D       KAF */
block|{
literal|0xFEDD
block|,
literal|3
block|}
block|,
comment|/* 0x0644    D       LAM */
block|{
literal|0xFEE1
block|,
literal|3
block|}
block|,
comment|/* 0x0645    D       MEEM */
block|{
literal|0xFEE5
block|,
literal|3
block|}
block|,
comment|/* 0x0646    D       NOON */
block|{
literal|0xFEE9
block|,
literal|3
block|}
block|,
comment|/* 0x0647    D       HEH */
block|{
literal|0xFEED
block|,
literal|1
block|}
block|,
comment|/* 0x0648    R       WAW */
block|{
literal|0x0649
block|,
literal|3
block|}
block|,
comment|/* 0x0649            ALEF MAKSURA // ### Dual, glyphs not consecutive, handle in code. */
block|{
literal|0xFEF1
block|,
literal|3
block|}
block|,
comment|/* 0x064A    D       YEH */
block|{
literal|0x064B
block|,
literal|0
block|}
block|,
comment|/* 0x064B */
block|{
literal|0x064C
block|,
literal|0
block|}
block|,
comment|/* 0x064C */
block|{
literal|0x064D
block|,
literal|0
block|}
block|,
comment|/* 0x064D */
block|{
literal|0x064E
block|,
literal|0
block|}
block|,
comment|/* 0x064E */
block|{
literal|0x064F
block|,
literal|0
block|}
block|,
comment|/* 0x064F */
block|{
literal|0x0650
block|,
literal|0
block|}
block|,
comment|/* 0x0650 */
block|{
literal|0x0651
block|,
literal|0
block|}
block|,
comment|/* 0x0651 */
block|{
literal|0x0652
block|,
literal|0
block|}
block|,
comment|/* 0x0652 */
block|{
literal|0x0653
block|,
literal|0
block|}
block|,
comment|/* 0x0653 */
block|{
literal|0x0654
block|,
literal|0
block|}
block|,
comment|/* 0x0654 */
block|{
literal|0x0655
block|,
literal|0
block|}
block|,
comment|/* 0x0655 */
block|{
literal|0x0656
block|,
literal|0
block|}
block|,
comment|/* 0x0656 */
block|{
literal|0x0657
block|,
literal|0
block|}
block|,
comment|/* 0x0657 */
block|{
literal|0x0658
block|,
literal|0
block|}
block|,
comment|/* 0x0658 */
block|{
literal|0x0659
block|,
literal|0
block|}
block|,
comment|/* 0x0659 */
block|{
literal|0x065A
block|,
literal|0
block|}
block|,
comment|/* 0x065A */
block|{
literal|0x065B
block|,
literal|0
block|}
block|,
comment|/* 0x065B */
block|{
literal|0x065C
block|,
literal|0
block|}
block|,
comment|/* 0x065C */
block|{
literal|0x065D
block|,
literal|0
block|}
block|,
comment|/* 0x065D */
block|{
literal|0x065E
block|,
literal|0
block|}
block|,
comment|/* 0x065E */
block|{
literal|0x065F
block|,
literal|0
block|}
block|,
comment|/* 0x065F */
block|{
literal|0x0660
block|,
literal|0
block|}
block|,
comment|/* 0x0660 */
block|{
literal|0x0661
block|,
literal|0
block|}
block|,
comment|/* 0x0661 */
block|{
literal|0x0662
block|,
literal|0
block|}
block|,
comment|/* 0x0662 */
block|{
literal|0x0663
block|,
literal|0
block|}
block|,
comment|/* 0x0663 */
block|{
literal|0x0664
block|,
literal|0
block|}
block|,
comment|/* 0x0664 */
block|{
literal|0x0665
block|,
literal|0
block|}
block|,
comment|/* 0x0665 */
block|{
literal|0x0666
block|,
literal|0
block|}
block|,
comment|/* 0x0666 */
block|{
literal|0x0667
block|,
literal|0
block|}
block|,
comment|/* 0x0667 */
block|{
literal|0x0668
block|,
literal|0
block|}
block|,
comment|/* 0x0668 */
block|{
literal|0x0669
block|,
literal|0
block|}
block|,
comment|/* 0x0669 */
block|{
literal|0x066A
block|,
literal|0
block|}
block|,
comment|/* 0x066A */
block|{
literal|0x066B
block|,
literal|0
block|}
block|,
comment|/* 0x066B */
block|{
literal|0x066C
block|,
literal|0
block|}
block|,
comment|/* 0x066C */
block|{
literal|0x066D
block|,
literal|0
block|}
block|,
comment|/* 0x066D */
block|{
literal|0x066E
block|,
literal|0
block|}
block|,
comment|/* 0x066E */
block|{
literal|0x066F
block|,
literal|0
block|}
block|,
comment|/* 0x066F */
block|{
literal|0x0670
block|,
literal|0
block|}
block|,
comment|/* 0x0670 */
block|{
literal|0xFB50
block|,
literal|1
block|}
block|,
comment|/* 0x0671    R       ALEF WASLA */
block|{
literal|0x0672
block|,
literal|0
block|}
block|,
comment|/* 0x0672 */
block|{
literal|0x0673
block|,
literal|0
block|}
block|,
comment|/* 0x0673 */
block|{
literal|0x0674
block|,
literal|0
block|}
block|,
comment|/* 0x0674 */
block|{
literal|0x0675
block|,
literal|0
block|}
block|,
comment|/* 0x0675 */
block|{
literal|0x0676
block|,
literal|0
block|}
block|,
comment|/* 0x0676 */
block|{
literal|0x0677
block|,
literal|0
block|}
block|,
comment|/* 0x0677 */
block|{
literal|0x0678
block|,
literal|0
block|}
block|,
comment|/* 0x0678 */
block|{
literal|0xFB66
block|,
literal|3
block|}
block|,
comment|/* 0x0679    D       TTEH */
block|{
literal|0xFB5E
block|,
literal|3
block|}
block|,
comment|/* 0x067A    D       TTEHEH */
block|{
literal|0xFB52
block|,
literal|3
block|}
block|,
comment|/* 0x067B    D       BEEH */
block|{
literal|0x067C
block|,
literal|0
block|}
block|,
comment|/* 0x067C */
block|{
literal|0x067D
block|,
literal|0
block|}
block|,
comment|/* 0x067D */
block|{
literal|0xFB56
block|,
literal|3
block|}
block|,
comment|/* 0x067E    D       PEH */
block|{
literal|0xFB62
block|,
literal|3
block|}
block|,
comment|/* 0x067F    D       TEHEH */
block|{
literal|0xFB5A
block|,
literal|3
block|}
block|,
comment|/* 0x0680    D       BEHEH */
block|{
literal|0x0681
block|,
literal|0
block|}
block|,
comment|/* 0x0681 */
block|{
literal|0x0682
block|,
literal|0
block|}
block|,
comment|/* 0x0682 */
block|{
literal|0xFB76
block|,
literal|3
block|}
block|,
comment|/* 0x0683    D       NYEH */
block|{
literal|0xFB72
block|,
literal|3
block|}
block|,
comment|/* 0x0684    D       DYEH */
block|{
literal|0x0685
block|,
literal|0
block|}
block|,
comment|/* 0x0685 */
block|{
literal|0xFB7A
block|,
literal|3
block|}
block|,
comment|/* 0x0686    D       TCHEH */
block|{
literal|0xFB7E
block|,
literal|3
block|}
block|,
comment|/* 0x0687    D       TCHEHEH */
block|{
literal|0xFB88
block|,
literal|1
block|}
block|,
comment|/* 0x0688    R       DDAL */
block|{
literal|0x0689
block|,
literal|0
block|}
block|,
comment|/* 0x0689 */
block|{
literal|0x068A
block|,
literal|0
block|}
block|,
comment|/* 0x068A */
block|{
literal|0x068B
block|,
literal|0
block|}
block|,
comment|/* 0x068B */
block|{
literal|0xFB84
block|,
literal|1
block|}
block|,
comment|/* 0x068C    R       DAHAL */
block|{
literal|0xFB82
block|,
literal|1
block|}
block|,
comment|/* 0x068D    R       DDAHAL */
block|{
literal|0xFB86
block|,
literal|1
block|}
block|,
comment|/* 0x068E    R       DUL */
block|{
literal|0x068F
block|,
literal|0
block|}
block|,
comment|/* 0x068F */
block|{
literal|0x0690
block|,
literal|0
block|}
block|,
comment|/* 0x0690 */
block|{
literal|0xFB8C
block|,
literal|1
block|}
block|,
comment|/* 0x0691    R       RREH */
block|{
literal|0x0692
block|,
literal|0
block|}
block|,
comment|/* 0x0692 */
block|{
literal|0x0693
block|,
literal|0
block|}
block|,
comment|/* 0x0693 */
block|{
literal|0x0694
block|,
literal|0
block|}
block|,
comment|/* 0x0694 */
block|{
literal|0x0695
block|,
literal|0
block|}
block|,
comment|/* 0x0695 */
block|{
literal|0x0696
block|,
literal|0
block|}
block|,
comment|/* 0x0696 */
block|{
literal|0x0697
block|,
literal|0
block|}
block|,
comment|/* 0x0697 */
block|{
literal|0xFB8A
block|,
literal|1
block|}
block|,
comment|/* 0x0698    R       JEH */
block|{
literal|0x0699
block|,
literal|0
block|}
block|,
comment|/* 0x0699 */
block|{
literal|0x069A
block|,
literal|0
block|}
block|,
comment|/* 0x069A */
block|{
literal|0x069B
block|,
literal|0
block|}
block|,
comment|/* 0x069B */
block|{
literal|0x069C
block|,
literal|0
block|}
block|,
comment|/* 0x069C */
block|{
literal|0x069D
block|,
literal|0
block|}
block|,
comment|/* 0x069D */
block|{
literal|0x069E
block|,
literal|0
block|}
block|,
comment|/* 0x069E */
block|{
literal|0x069F
block|,
literal|0
block|}
block|,
comment|/* 0x069F */
block|{
literal|0x06A0
block|,
literal|0
block|}
block|,
comment|/* 0x06A0 */
block|{
literal|0x06A1
block|,
literal|0
block|}
block|,
comment|/* 0x06A1 */
block|{
literal|0x06A2
block|,
literal|0
block|}
block|,
comment|/* 0x06A2 */
block|{
literal|0x06A3
block|,
literal|0
block|}
block|,
comment|/* 0x06A3 */
block|{
literal|0xFB6A
block|,
literal|3
block|}
block|,
comment|/* 0x06A4    D       VEH */
block|{
literal|0x06A5
block|,
literal|0
block|}
block|,
comment|/* 0x06A5 */
block|{
literal|0xFB6E
block|,
literal|3
block|}
block|,
comment|/* 0x06A6    D       PEHEH */
block|{
literal|0x06A7
block|,
literal|0
block|}
block|,
comment|/* 0x06A7 */
block|{
literal|0x06A8
block|,
literal|0
block|}
block|,
comment|/* 0x06A8 */
block|{
literal|0xFB8E
block|,
literal|3
block|}
block|,
comment|/* 0x06A9    D       KEHEH */
block|{
literal|0x06AA
block|,
literal|0
block|}
block|,
comment|/* 0x06AA */
block|{
literal|0x06AB
block|,
literal|0
block|}
block|,
comment|/* 0x06AB */
block|{
literal|0x06AC
block|,
literal|0
block|}
block|,
comment|/* 0x06AC */
block|{
literal|0xFBD3
block|,
literal|3
block|}
block|,
comment|/* 0x06AD    D       NG */
block|{
literal|0x06AE
block|,
literal|0
block|}
block|,
comment|/* 0x06AE */
block|{
literal|0xFB92
block|,
literal|3
block|}
block|,
comment|/* 0x06AF    D       GAF */
block|{
literal|0x06B0
block|,
literal|0
block|}
block|,
comment|/* 0x06B0 */
block|{
literal|0xFB9A
block|,
literal|3
block|}
block|,
comment|/* 0x06B1    D       NGOEH */
block|{
literal|0x06B2
block|,
literal|0
block|}
block|,
comment|/* 0x06B2 */
block|{
literal|0xFB96
block|,
literal|3
block|}
block|,
comment|/* 0x06B3    D       GUEH */
block|{
literal|0x06B4
block|,
literal|0
block|}
block|,
comment|/* 0x06B4 */
block|{
literal|0x06B5
block|,
literal|0
block|}
block|,
comment|/* 0x06B5 */
block|{
literal|0x06B6
block|,
literal|0
block|}
block|,
comment|/* 0x06B6 */
block|{
literal|0x06B7
block|,
literal|0
block|}
block|,
comment|/* 0x06B7 */
block|{
literal|0x06B8
block|,
literal|0
block|}
block|,
comment|/* 0x06B8 */
block|{
literal|0x06B9
block|,
literal|0
block|}
block|,
comment|/* 0x06B9 */
block|{
literal|0xFB9E
block|,
literal|1
block|}
block|,
comment|/* 0x06BA    R       NOON GHUNNA */
block|{
literal|0xFBA0
block|,
literal|3
block|}
block|,
comment|/* 0x06BB    D       RNOON */
block|{
literal|0x06BC
block|,
literal|0
block|}
block|,
comment|/* 0x06BC */
block|{
literal|0x06BD
block|,
literal|0
block|}
block|,
comment|/* 0x06BD */
block|{
literal|0xFBAA
block|,
literal|3
block|}
block|,
comment|/* 0x06BE    D       HEH DOACHASHMEE */
block|{
literal|0x06BF
block|,
literal|0
block|}
block|,
comment|/* 0x06BF */
block|{
literal|0xFBA4
block|,
literal|1
block|}
block|,
comment|/* 0x06C0    R       HEH WITH YEH ABOVE */
block|{
literal|0xFBA6
block|,
literal|3
block|}
block|,
comment|/* 0x06C1    D       HEH GOAL */
block|{
literal|0x06C2
block|,
literal|0
block|}
block|,
comment|/* 0x06C2 */
block|{
literal|0x06C3
block|,
literal|0
block|}
block|,
comment|/* 0x06C3 */
block|{
literal|0x06C4
block|,
literal|0
block|}
block|,
comment|/* 0x06C4 */
block|{
literal|0xFBE0
block|,
literal|1
block|}
block|,
comment|/* 0x06C5    R       KIRGHIZ OE */
block|{
literal|0xFBD9
block|,
literal|1
block|}
block|,
comment|/* 0x06C6    R       OE */
block|{
literal|0xFBD7
block|,
literal|1
block|}
block|,
comment|/* 0x06C7    R       U */
block|{
literal|0xFBDB
block|,
literal|1
block|}
block|,
comment|/* 0x06C8    R       YU */
block|{
literal|0xFBE2
block|,
literal|1
block|}
block|,
comment|/* 0x06C9    R       KIRGHIZ YU */
block|{
literal|0x06CA
block|,
literal|0
block|}
block|,
comment|/* 0x06CA */
block|{
literal|0xFBDE
block|,
literal|1
block|}
block|,
comment|/* 0x06CB    R       VE */
block|{
literal|0xFBFC
block|,
literal|3
block|}
block|,
comment|/* 0x06CC    D       FARSI YEH */
block|{
literal|0x06CD
block|,
literal|0
block|}
block|,
comment|/* 0x06CD */
block|{
literal|0x06CE
block|,
literal|0
block|}
block|,
comment|/* 0x06CE */
block|{
literal|0x06CF
block|,
literal|0
block|}
block|,
comment|/* 0x06CF */
block|{
literal|0xFBE4
block|,
literal|3
block|}
block|,
comment|/* 0x06D0    D       E */
block|{
literal|0x06D1
block|,
literal|0
block|}
block|,
comment|/* 0x06D1 */
block|{
literal|0xFBAE
block|,
literal|1
block|}
block|,
comment|/* 0x06D2    R       YEH BARREE */
block|{
literal|0xFBB0
block|,
literal|1
block|}
block|,
comment|/* 0x06D3    R       YEH BARREE WITH HAMZA ABOVE */
block|{
literal|0x06D4
block|,
literal|0
block|}
block|,
comment|/* 0x06D4 */
block|{
literal|0x06D5
block|,
literal|0
block|}
block|,
comment|/* 0x06D5 */
block|{
literal|0x06D6
block|,
literal|0
block|}
block|,
comment|/* 0x06D6 */
block|{
literal|0x06D7
block|,
literal|0
block|}
block|,
comment|/* 0x06D7 */
block|{
literal|0x06D8
block|,
literal|0
block|}
block|,
comment|/* 0x06D8 */
block|{
literal|0x06D9
block|,
literal|0
block|}
block|,
comment|/* 0x06D9 */
block|{
literal|0x06DA
block|,
literal|0
block|}
block|,
comment|/* 0x06DA */
block|{
literal|0x06DB
block|,
literal|0
block|}
block|,
comment|/* 0x06DB */
block|{
literal|0x06DC
block|,
literal|0
block|}
block|,
comment|/* 0x06DC */
block|{
literal|0x06DD
block|,
literal|0
block|}
block|,
comment|/* 0x06DD */
block|{
literal|0x06DE
block|,
literal|0
block|}
block|,
comment|/* 0x06DE */
block|{
literal|0x06DF
block|,
literal|0
block|}
block|,
comment|/* 0x06DF */
block|{
literal|0x06E0
block|,
literal|0
block|}
block|,
comment|/* 0x06E0 */
block|{
literal|0x06E1
block|,
literal|0
block|}
block|,
comment|/* 0x06E1 */
block|{
literal|0x06E2
block|,
literal|0
block|}
block|,
comment|/* 0x06E2 */
block|{
literal|0x06E3
block|,
literal|0
block|}
block|,
comment|/* 0x06E3 */
block|{
literal|0x06E4
block|,
literal|0
block|}
block|,
comment|/* 0x06E4 */
block|{
literal|0x06E5
block|,
literal|0
block|}
block|,
comment|/* 0x06E5 */
block|{
literal|0x06E6
block|,
literal|0
block|}
block|,
comment|/* 0x06E6 */
block|{
literal|0x06E7
block|,
literal|0
block|}
block|,
comment|/* 0x06E7 */
block|{
literal|0x06E8
block|,
literal|0
block|}
block|,
comment|/* 0x06E8 */
block|{
literal|0x06E9
block|,
literal|0
block|}
block|,
comment|/* 0x06E9 */
block|{
literal|0x06EA
block|,
literal|0
block|}
block|,
comment|/* 0x06EA */
block|{
literal|0x06EB
block|,
literal|0
block|}
block|,
comment|/* 0x06EB */
block|{
literal|0x06EC
block|,
literal|0
block|}
block|,
comment|/* 0x06EC */
block|{
literal|0x06ED
block|,
literal|0
block|}
block|,
comment|/* 0x06ED */
block|{
literal|0x06EE
block|,
literal|0
block|}
block|,
comment|/* 0x06EE */
block|{
literal|0x06EF
block|,
literal|0
block|}
block|,
comment|/* 0x06EF */
block|{
literal|0x06F0
block|,
literal|0
block|}
block|,
comment|/* 0x06F0 */
block|{
literal|0x06F1
block|,
literal|0
block|}
block|,
comment|/* 0x06F1 */
block|{
literal|0x06F2
block|,
literal|0
block|}
block|,
comment|/* 0x06F2 */
block|{
literal|0x06F3
block|,
literal|0
block|}
block|,
comment|/* 0x06F3 */
block|{
literal|0x06F4
block|,
literal|0
block|}
block|,
comment|/* 0x06F4 */
block|{
literal|0x06F5
block|,
literal|0
block|}
block|,
comment|/* 0x06F5 */
block|{
literal|0x06F6
block|,
literal|0
block|}
block|,
comment|/* 0x06F6 */
block|{
literal|0x06F7
block|,
literal|0
block|}
block|,
comment|/* 0x06F7 */
block|{
literal|0x06F8
block|,
literal|0
block|}
block|,
comment|/* 0x06F8 */
block|{
literal|0x06F9
block|,
literal|0
block|}
block|,
comment|/* 0x06F9 */
block|{
literal|0x06FA
block|,
literal|0
block|}
block|,
comment|/* 0x06FA */
block|{
literal|0x06FB
block|,
literal|0
block|}
block|,
comment|/* 0x06FB */
block|{
literal|0x06FC
block|,
literal|0
block|}
block|,
comment|/* 0x06FC */
block|{
literal|0x06FD
block|,
literal|0
block|}
block|,
comment|/* 0x06FD */
block|{
literal|0x06FE
block|,
literal|0
block|}
block|,
comment|/* 0x06FE */
block|{
literal|0x06FF
block|,
literal|0
block|}
comment|/* 0x06FF */
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* the arabicUnicodeMapping does not work for U+0649 ALEF MAKSURA, this table does */
end_comment
begin_decl_stmt
DECL|variable|alefMaksura
specifier|static
specifier|const
name|hb_uint16
name|alefMaksura
index|[
literal|4
index|]
init|=
block|{
literal|0xFEEF
block|,
literal|0xFEF0
block|,
literal|0xFBE8
block|,
literal|0xFBE9
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* // this is a bit tricky. Alef always binds to the right, so the second parameter descibing the shape // of the lam can be either initial of medial. So initial maps to the isolated form of the ligature, // medial to the final form */
end_comment
begin_decl_stmt
DECL|variable|arabicUnicodeLamAlefMapping
specifier|static
specifier|const
name|hb_uint16
name|arabicUnicodeLamAlefMapping
index|[
literal|6
index|]
index|[
literal|4
index|]
init|=
block|{
block|{
literal|0xfffd
block|,
literal|0xfffd
block|,
literal|0xfef5
block|,
literal|0xfef6
block|}
block|,
comment|/* 0x622        R       Alef with Madda above */
block|{
literal|0xfffd
block|,
literal|0xfffd
block|,
literal|0xfef7
block|,
literal|0xfef8
block|}
block|,
comment|/* 0x623        R       Alef with Hamza above */
block|{
literal|0xfffd
block|,
literal|0xfffd
block|,
literal|0xfffd
block|,
literal|0xfffd
block|}
block|,
comment|/* 0x624        // Just to fill the table ;-) */
block|{
literal|0xfffd
block|,
literal|0xfffd
block|,
literal|0xfef9
block|,
literal|0xfefa
block|}
block|,
comment|/* 0x625        R       Alef with Hamza below */
block|{
literal|0xfffd
block|,
literal|0xfffd
block|,
literal|0xfffd
block|,
literal|0xfffd
block|}
block|,
comment|/* 0x626        // Just to fill the table ;-) */
block|{
literal|0xfffd
block|,
literal|0xfffd
block|,
literal|0xfefb
block|,
literal|0xfefc
block|}
comment|/* 0x627        R       Alef */
block|}
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|getShape
specifier|static
name|int
name|getShape
parameter_list|(
name|hb_uint8
name|cell
parameter_list|,
name|int
name|shape
parameter_list|)
block|{
comment|/* the arabicUnicodeMapping does not work for U+0649 ALEF MAKSURA, handle this here */
name|int
name|ch
init|=
operator|(
name|cell
operator|!=
literal|0x49
operator|)
condition|?
operator|(
name|shape
condition|?
name|arabicUnicodeMapping
index|[
name|cell
index|]
index|[
literal|0
index|]
operator|+
name|shape
else|:
literal|0x600
operator|+
name|cell
operator|)
else|:
name|alefMaksura
index|[
name|shape
index|]
decl_stmt|;
return|return
name|ch
return|;
block|}
end_function
begin_comment
comment|/*   Two small helper functions for arabic shaping. */
end_comment
begin_function
DECL|function|prevChar
specifier|static
name|HB_UChar16
name|prevChar
parameter_list|(
specifier|const
name|HB_UChar16
modifier|*
name|str
parameter_list|,
name|int
name|pos
parameter_list|)
block|{
comment|/*qDebug("leftChar: pos=%d", pos); */
specifier|const
name|HB_UChar16
modifier|*
name|ch
init|=
name|str
operator|+
name|pos
operator|-
literal|1
decl_stmt|;
name|pos
operator|--
expr_stmt|;
while|while
condition|(
name|pos
operator|>
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|HB_GetUnicodeCharCategory
argument_list|(
operator|*
name|ch
argument_list|)
operator|!=
name|HB_Mark_NonSpacing
condition|)
return|return
operator|*
name|ch
return|;
name|pos
operator|--
expr_stmt|;
name|ch
operator|--
expr_stmt|;
block|}
return|return
name|ReplacementCharacter
return|;
block|}
end_function
begin_function
DECL|function|nextChar
specifier|static
name|HB_UChar16
name|nextChar
parameter_list|(
specifier|const
name|HB_UChar16
modifier|*
name|str
parameter_list|,
name|hb_uint32
name|len
parameter_list|,
name|hb_uint32
name|pos
parameter_list|)
block|{
specifier|const
name|HB_UChar16
modifier|*
name|ch
init|=
name|str
operator|+
name|pos
operator|+
literal|1
decl_stmt|;
name|pos
operator|++
expr_stmt|;
while|while
condition|(
name|pos
operator|<
name|len
condition|)
block|{
comment|/*qDebug("rightChar: %d isLetter=%d, joining=%d", pos, ch.isLetter(), ch.joining()); */
if|if
condition|(
name|HB_GetUnicodeCharCategory
argument_list|(
operator|*
name|ch
argument_list|)
operator|!=
name|HB_Mark_NonSpacing
condition|)
return|return
operator|*
name|ch
return|;
comment|/* assume it's a transparent char, this might not be 100% correct */
name|pos
operator|++
expr_stmt|;
name|ch
operator|++
expr_stmt|;
block|}
return|return
name|ReplacementCharacter
return|;
block|}
end_function
begin_function
DECL|function|shapedString
specifier|static
name|void
name|shapedString
parameter_list|(
specifier|const
name|HB_UChar16
modifier|*
name|uc
parameter_list|,
name|hb_uint32
name|stringLength
parameter_list|,
name|hb_uint32
name|from
parameter_list|,
name|hb_uint32
name|len
parameter_list|,
name|HB_UChar16
modifier|*
name|shapeBuffer
parameter_list|,
name|int
modifier|*
name|shapedLength
parameter_list|,
name|HB_Bool
name|reverse
parameter_list|,
name|HB_GlyphAttributes
modifier|*
name|attributes
parameter_list|,
name|unsigned
name|short
modifier|*
name|logClusters
parameter_list|)
block|{
name|HB_ArabicProperties
modifier|*
name|properties
decl_stmt|;
name|hb_int32
name|f
init|=
name|from
decl_stmt|;
name|hb_uint32
name|l
init|=
name|len
decl_stmt|;
specifier|const
name|HB_UChar16
modifier|*
name|ch
decl_stmt|;
name|HB_UChar16
modifier|*
name|data
decl_stmt|;
name|int
name|clusterStart
decl_stmt|;
name|hb_uint32
name|i
decl_stmt|;
name|HB_STACKARRAY
argument_list|(
name|HB_ArabicProperties
argument_list|,
name|props
argument_list|,
name|len
operator|+
literal|2
argument_list|)
expr_stmt|;
name|properties
operator|=
name|props
expr_stmt|;
name|assert
argument_list|(
name|stringLength
operator|>=
name|from
operator|+
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
operator|*
name|shapedLength
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|from
operator|>
literal|0
condition|)
block|{
operator|--
name|f
expr_stmt|;
operator|++
name|l
expr_stmt|;
operator|++
name|properties
expr_stmt|;
block|}
if|if
condition|(
name|f
operator|+
name|l
operator|<
name|stringLength
condition|)
operator|++
name|l
expr_stmt|;
name|getArabicProperties
argument_list|(
name|uc
operator|+
name|f
argument_list|,
name|l
argument_list|,
name|props
argument_list|)
expr_stmt|;
name|ch
operator|=
name|uc
operator|+
name|from
expr_stmt|;
name|data
operator|=
name|shapeBuffer
expr_stmt|;
name|clusterStart
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|hb_uint8
name|r
init|=
operator|*
name|ch
operator|>>
literal|8
decl_stmt|;
name|int
name|gpos
init|=
name|data
operator|-
name|shapeBuffer
decl_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0x06
condition|)
block|{
if|if
condition|(
name|r
operator|==
literal|0x20
condition|)
block|{
if|if
condition|(
operator|*
name|ch
operator|==
literal|0x200c
operator|||
operator|*
name|ch
operator|==
literal|0x200d
condition|)
comment|/* remove ZWJ and ZWNJ */
goto|goto
name|skip
goto|;
block|}
if|if
condition|(
name|reverse
condition|)
operator|*
name|data
operator|=
name|HB_GetMirroredChar
argument_list|(
operator|*
name|ch
argument_list|)
expr_stmt|;
else|else
operator|*
name|data
operator|=
operator|*
name|ch
expr_stmt|;
block|}
else|else
block|{
name|hb_uint8
name|c
init|=
operator|*
name|ch
operator|&
literal|0xff
decl_stmt|;
name|int
name|pos
init|=
name|i
operator|+
name|from
decl_stmt|;
name|int
name|shape
init|=
name|properties
index|[
name|i
index|]
operator|.
name|shape
decl_stmt|;
comment|/*            qDebug("mapping U+%x to shape %d glyph=0x%x", ch->unicode(), shape, getShape(c, shape)); */
comment|/* take care of lam-alef ligatures (lam right of alef) */
name|hb_uint16
name|map
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|0x44
case|:
block|{
comment|/* lam */
specifier|const
name|HB_UChar16
name|pch
init|=
name|nextChar
argument_list|(
name|uc
argument_list|,
name|stringLength
argument_list|,
name|pos
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|pch
operator|>>
literal|8
operator|)
operator|==
literal|0x06
condition|)
block|{
switch|switch
condition|(
name|pch
operator|&
literal|0xff
condition|)
block|{
case|case
literal|0x22
case|:
case|case
literal|0x23
case|:
case|case
literal|0x25
case|:
case|case
literal|0x27
case|:
comment|/*                                 qDebug(" lam of lam-alef ligature"); */
name|map
operator|=
name|arabicUnicodeLamAlefMapping
index|[
operator|(
name|pch
operator|&
literal|0xff
operator|)
operator|-
literal|0x22
index|]
index|[
name|shape
index|]
expr_stmt|;
goto|goto
name|next
goto|;
default|default:
break|break;
block|}
block|}
break|break;
block|}
case|case
literal|0x22
case|:
comment|/* alef with madda */
case|case
literal|0x23
case|:
comment|/* alef with hamza above */
case|case
literal|0x25
case|:
comment|/* alef with hamza below */
case|case
literal|0x27
case|:
comment|/* alef */
if|if
condition|(
name|prevChar
argument_list|(
name|uc
argument_list|,
name|pos
argument_list|)
operator|==
literal|0x0644
condition|)
block|{
comment|/* have a lam alef ligature */
comment|/*qDebug(" alef of lam-alef ligature"); */
goto|goto
name|skip
goto|;
block|}
default|default:
break|break;
block|}
name|map
operator|=
name|getShape
argument_list|(
name|c
argument_list|,
name|shape
argument_list|)
expr_stmt|;
name|next
label|:
operator|*
name|data
operator|=
name|map
expr_stmt|;
block|}
comment|/* ##### Fixme */
comment|/*glyphs[gpos].attributes.zeroWidth = zeroWidth; */
if|if
condition|(
name|HB_GetUnicodeCharCategory
argument_list|(
operator|*
name|ch
argument_list|)
operator|==
name|HB_Mark_NonSpacing
condition|)
block|{
name|attributes
index|[
name|gpos
index|]
operator|.
name|mark
operator|=
name|TRUE
expr_stmt|;
comment|/*             qDebug("glyph %d (char %d) is mark!", gpos, i); */
block|}
else|else
block|{
name|attributes
index|[
name|gpos
index|]
operator|.
name|mark
operator|=
name|FALSE
expr_stmt|;
name|clusterStart
operator|=
name|data
operator|-
name|shapeBuffer
expr_stmt|;
block|}
name|attributes
index|[
name|gpos
index|]
operator|.
name|clusterStart
operator|=
operator|!
name|attributes
index|[
name|gpos
index|]
operator|.
name|mark
expr_stmt|;
name|attributes
index|[
name|gpos
index|]
operator|.
name|combiningClass
operator|=
name|HB_GetUnicodeCharCombiningClass
argument_list|(
operator|*
name|ch
argument_list|)
expr_stmt|;
name|attributes
index|[
name|gpos
index|]
operator|.
name|justification
operator|=
name|properties
index|[
name|i
index|]
operator|.
name|justification
expr_stmt|;
comment|/*         qDebug("data[%d] = %x (from %x)", gpos, (uint)data->unicode(), ch->unicode());*/
name|data
operator|++
expr_stmt|;
name|skip
label|:
name|ch
operator|++
expr_stmt|;
name|logClusters
index|[
name|i
index|]
operator|=
name|clusterStart
expr_stmt|;
block|}
operator|*
name|shapedLength
operator|=
name|data
operator|-
name|shapeBuffer
expr_stmt|;
name|HB_FREE_STACKARRAY
argument_list|(
name|props
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|NO_OPENTYPE
end_ifndef
begin_decl_stmt
DECL|variable|arabic_features
specifier|static
specifier|const
name|HB_OpenTypeFeature
name|arabic_features
index|[]
init|=
block|{
block|{
name|HB_MAKE_TAG
argument_list|(
literal|'c'
argument_list|,
literal|'c'
argument_list|,
literal|'m'
argument_list|,
literal|'p'
argument_list|)
block|,
name|CcmpProperty
block|}
block|,
block|{
name|HB_MAKE_TAG
argument_list|(
literal|'i'
argument_list|,
literal|'s'
argument_list|,
literal|'o'
argument_list|,
literal|'l'
argument_list|)
block|,
name|IsolProperty
block|}
block|,
block|{
name|HB_MAKE_TAG
argument_list|(
literal|'f'
argument_list|,
literal|'i'
argument_list|,
literal|'n'
argument_list|,
literal|'a'
argument_list|)
block|,
name|FinaProperty
block|}
block|,
block|{
name|HB_MAKE_TAG
argument_list|(
literal|'m'
argument_list|,
literal|'e'
argument_list|,
literal|'d'
argument_list|,
literal|'i'
argument_list|)
block|,
name|MediProperty
block|}
block|,
block|{
name|HB_MAKE_TAG
argument_list|(
literal|'i'
argument_list|,
literal|'n'
argument_list|,
literal|'i'
argument_list|,
literal|'t'
argument_list|)
block|,
name|InitProperty
block|}
block|,
block|{
name|HB_MAKE_TAG
argument_list|(
literal|'r'
argument_list|,
literal|'l'
argument_list|,
literal|'i'
argument_list|,
literal|'g'
argument_list|)
block|,
name|RligProperty
block|}
block|,
block|{
name|HB_MAKE_TAG
argument_list|(
literal|'c'
argument_list|,
literal|'a'
argument_list|,
literal|'l'
argument_list|,
literal|'t'
argument_list|)
block|,
name|CaltProperty
block|}
block|,
block|{
name|HB_MAKE_TAG
argument_list|(
literal|'l'
argument_list|,
literal|'i'
argument_list|,
literal|'g'
argument_list|,
literal|'a'
argument_list|)
block|,
name|LigaProperty
block|}
block|,
block|{
name|HB_MAKE_TAG
argument_list|(
literal|'d'
argument_list|,
literal|'l'
argument_list|,
literal|'i'
argument_list|,
literal|'g'
argument_list|)
block|,
name|DligProperty
block|}
block|,
block|{
name|HB_MAKE_TAG
argument_list|(
literal|'c'
argument_list|,
literal|'s'
argument_list|,
literal|'w'
argument_list|,
literal|'h'
argument_list|)
block|,
name|CswhProperty
block|}
block|,
comment|/* mset is used in old Win95 fonts that don't have a 'mark' positioning table. */
block|{
name|HB_MAKE_TAG
argument_list|(
literal|'m'
argument_list|,
literal|'s'
argument_list|,
literal|'e'
argument_list|,
literal|'t'
argument_list|)
block|,
name|MsetProperty
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|syriac_features
specifier|static
specifier|const
name|HB_OpenTypeFeature
name|syriac_features
index|[]
init|=
block|{
block|{
name|HB_MAKE_TAG
argument_list|(
literal|'c'
argument_list|,
literal|'c'
argument_list|,
literal|'m'
argument_list|,
literal|'p'
argument_list|)
block|,
name|CcmpProperty
block|}
block|,
block|{
name|HB_MAKE_TAG
argument_list|(
literal|'i'
argument_list|,
literal|'s'
argument_list|,
literal|'o'
argument_list|,
literal|'l'
argument_list|)
block|,
name|IsolProperty
block|}
block|,
block|{
name|HB_MAKE_TAG
argument_list|(
literal|'f'
argument_list|,
literal|'i'
argument_list|,
literal|'n'
argument_list|,
literal|'a'
argument_list|)
block|,
name|FinaProperty
block|}
block|,
block|{
name|HB_MAKE_TAG
argument_list|(
literal|'f'
argument_list|,
literal|'i'
argument_list|,
literal|'n'
argument_list|,
literal|'2'
argument_list|)
block|,
name|FinaProperty
block|}
block|,
block|{
name|HB_MAKE_TAG
argument_list|(
literal|'f'
argument_list|,
literal|'i'
argument_list|,
literal|'n'
argument_list|,
literal|'3'
argument_list|)
block|,
name|FinaProperty
block|}
block|,
block|{
name|HB_MAKE_TAG
argument_list|(
literal|'m'
argument_list|,
literal|'e'
argument_list|,
literal|'d'
argument_list|,
literal|'i'
argument_list|)
block|,
name|MediProperty
block|}
block|,
block|{
name|HB_MAKE_TAG
argument_list|(
literal|'m'
argument_list|,
literal|'e'
argument_list|,
literal|'d'
argument_list|,
literal|'2'
argument_list|)
block|,
name|MediProperty
block|}
block|,
block|{
name|HB_MAKE_TAG
argument_list|(
literal|'i'
argument_list|,
literal|'n'
argument_list|,
literal|'i'
argument_list|,
literal|'t'
argument_list|)
block|,
name|InitProperty
block|}
block|,
block|{
name|HB_MAKE_TAG
argument_list|(
literal|'r'
argument_list|,
literal|'l'
argument_list|,
literal|'i'
argument_list|,
literal|'g'
argument_list|)
block|,
name|RligProperty
block|}
block|,
block|{
name|HB_MAKE_TAG
argument_list|(
literal|'c'
argument_list|,
literal|'a'
argument_list|,
literal|'l'
argument_list|,
literal|'t'
argument_list|)
block|,
name|CaltProperty
block|}
block|,
block|{
name|HB_MAKE_TAG
argument_list|(
literal|'l'
argument_list|,
literal|'i'
argument_list|,
literal|'g'
argument_list|,
literal|'a'
argument_list|)
block|,
name|LigaProperty
block|}
block|,
block|{
name|HB_MAKE_TAG
argument_list|(
literal|'d'
argument_list|,
literal|'l'
argument_list|,
literal|'i'
argument_list|,
literal|'g'
argument_list|)
block|,
name|DligProperty
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|arabicSyriacOpenTypeShape
specifier|static
name|HB_Bool
name|arabicSyriacOpenTypeShape
parameter_list|(
name|HB_ShaperItem
modifier|*
name|item
parameter_list|,
name|HB_Bool
modifier|*
name|ot_ok
parameter_list|)
block|{
specifier|const
name|HB_UChar16
modifier|*
name|uc
decl_stmt|;
specifier|const
name|int
name|nglyphs
init|=
name|item
operator|->
name|num_glyphs
decl_stmt|;
name|hb_int32
name|f
decl_stmt|;
name|hb_uint32
name|l
decl_stmt|;
name|HB_ArabicProperties
modifier|*
name|properties
decl_stmt|;
name|HB_DECLARE_STACKARRAY
argument_list|(
argument|HB_ArabicProperties
argument_list|,
argument|props
argument_list|)
name|HB_DECLARE_STACKARRAY
argument_list|(
argument|hb_uint32
argument_list|,
argument|apply
argument_list|)
name|HB_Bool
name|shaped
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
operator|*
name|ot_ok
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|HB_ConvertStringToGlyphIndices
argument_list|(
name|item
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|HB_HeuristicSetGlyphAttributes
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|HB_INIT_STACKARRAY
argument_list|(
name|HB_ArabicProperties
argument_list|,
name|props
argument_list|,
name|item
operator|->
name|item
operator|.
name|length
operator|+
literal|2
argument_list|)
expr_stmt|;
name|HB_INIT_STACKARRAY
argument_list|(
name|hb_uint32
argument_list|,
name|apply
argument_list|,
name|item
operator|->
name|num_glyphs
argument_list|)
expr_stmt|;
name|uc
operator|=
name|item
operator|->
name|string
operator|+
name|item
operator|->
name|item
operator|.
name|pos
expr_stmt|;
name|properties
operator|=
name|props
expr_stmt|;
name|f
operator|=
literal|0
expr_stmt|;
name|l
operator|=
name|item
operator|->
name|item
operator|.
name|length
expr_stmt|;
if|if
condition|(
name|item
operator|->
name|item
operator|.
name|pos
operator|>
literal|0
condition|)
block|{
operator|--
name|f
expr_stmt|;
operator|++
name|l
expr_stmt|;
operator|++
name|properties
expr_stmt|;
block|}
if|if
condition|(
name|f
operator|+
name|l
operator|+
name|item
operator|->
name|item
operator|.
name|pos
operator|<
name|item
operator|->
name|stringLength
condition|)
block|{
operator|++
name|l
expr_stmt|;
block|}
if|if
condition|(
name|item
operator|->
name|item
operator|.
name|script
operator|==
name|HB_Script_Nko
condition|)
name|getNkoProperties
argument_list|(
name|uc
operator|+
name|f
argument_list|,
name|l
argument_list|,
name|props
argument_list|)
expr_stmt|;
else|else
name|getArabicProperties
argument_list|(
name|uc
operator|+
name|f
argument_list|,
name|l
argument_list|,
name|props
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|item
operator|->
name|num_glyphs
condition|;
name|i
operator|++
control|)
block|{
name|apply
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|properties
index|[
name|i
index|]
operator|.
name|shape
operator|==
name|XIsolated
condition|)
name|apply
index|[
name|i
index|]
operator||=
name|MediProperty
operator||
name|FinaProperty
operator||
name|InitProperty
expr_stmt|;
elseif|else
if|if
condition|(
name|properties
index|[
name|i
index|]
operator|.
name|shape
operator|==
name|XMedial
condition|)
name|apply
index|[
name|i
index|]
operator||=
name|IsolProperty
operator||
name|FinaProperty
operator||
name|InitProperty
expr_stmt|;
elseif|else
if|if
condition|(
name|properties
index|[
name|i
index|]
operator|.
name|shape
operator|==
name|XFinal
condition|)
name|apply
index|[
name|i
index|]
operator||=
name|IsolProperty
operator||
name|MediProperty
operator||
name|InitProperty
expr_stmt|;
elseif|else
if|if
condition|(
name|properties
index|[
name|i
index|]
operator|.
name|shape
operator|==
name|XInitial
condition|)
name|apply
index|[
name|i
index|]
operator||=
name|IsolProperty
operator||
name|MediProperty
operator||
name|FinaProperty
expr_stmt|;
name|item
operator|->
name|attributes
index|[
name|i
index|]
operator|.
name|justification
operator|=
name|properties
index|[
name|i
index|]
operator|.
name|justification
expr_stmt|;
block|}
name|HB_FREE_STACKARRAY
argument_list|(
name|props
argument_list|)
expr_stmt|;
name|shaped
operator|=
name|HB_OpenTypeShape
argument_list|(
name|item
argument_list|,
name|apply
argument_list|)
expr_stmt|;
name|HB_FREE_STACKARRAY
argument_list|(
name|apply
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|shaped
condition|)
block|{
operator|*
name|ot_ok
operator|=
name|FALSE
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|HB_OpenTypePosition
argument_list|(
name|item
argument_list|,
name|nglyphs
argument_list|,
comment|/*doLogClusters*/
name|TRUE
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* #### stil missing: identify invalid character combinations */
end_comment
begin_function
DECL|function|HB_ArabicShape
name|HB_Bool
name|HB_ArabicShape
parameter_list|(
name|HB_ShaperItem
modifier|*
name|item
parameter_list|)
block|{
name|int
name|slen
decl_stmt|;
name|HB_Bool
name|haveGlyphs
decl_stmt|;
name|HB_STACKARRAY
argument_list|(
name|HB_UChar16
argument_list|,
name|shapedChars
argument_list|,
name|item
operator|->
name|item
operator|.
name|length
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|item
operator|->
name|item
operator|.
name|script
operator|==
name|HB_Script_Arabic
operator|||
name|item
operator|->
name|item
operator|.
name|script
operator|==
name|HB_Script_Syriac
operator|||
name|item
operator|->
name|item
operator|.
name|script
operator|==
name|HB_Script_Nko
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_OPENTYPE
if|if
condition|(
name|HB_SelectScript
argument_list|(
name|item
argument_list|,
name|item
operator|->
name|item
operator|.
name|script
operator|==
name|HB_Script_Arabic
condition|?
name|arabic_features
else|:
name|syriac_features
argument_list|)
condition|)
block|{
name|HB_Bool
name|ot_ok
decl_stmt|;
if|if
condition|(
name|arabicSyriacOpenTypeShape
argument_list|(
name|item
argument_list|,
operator|&
name|ot_ok
argument_list|)
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|ot_ok
condition|)
return|return
name|FALSE
return|;
comment|/* fall through to the non OT code*/
block|}
endif|#
directive|endif
if|if
condition|(
name|item
operator|->
name|item
operator|.
name|script
operator|!=
name|HB_Script_Arabic
condition|)
return|return
name|HB_BasicShape
argument_list|(
name|item
argument_list|)
return|;
name|shapedString
argument_list|(
name|item
operator|->
name|string
argument_list|,
name|item
operator|->
name|stringLength
argument_list|,
name|item
operator|->
name|item
operator|.
name|pos
argument_list|,
name|item
operator|->
name|item
operator|.
name|length
argument_list|,
name|shapedChars
argument_list|,
operator|&
name|slen
argument_list|,
name|item
operator|->
name|item
operator|.
name|bidiLevel
operator|%
literal|2
argument_list|,
name|item
operator|->
name|attributes
argument_list|,
name|item
operator|->
name|log_clusters
argument_list|)
expr_stmt|;
name|haveGlyphs
operator|=
name|item
operator|->
name|font
operator|->
name|klass
operator|->
name|convertStringToGlyphIndices
argument_list|(
name|item
operator|->
name|font
argument_list|,
name|shapedChars
argument_list|,
name|slen
argument_list|,
name|item
operator|->
name|glyphs
argument_list|,
operator|&
name|item
operator|->
name|num_glyphs
argument_list|,
name|item
operator|->
name|item
operator|.
name|bidiLevel
operator|%
literal|2
argument_list|)
expr_stmt|;
name|HB_FREE_STACKARRAY
argument_list|(
name|shapedChars
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|haveGlyphs
condition|)
return|return
name|FALSE
return|;
name|HB_HeuristicPosition
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function
end_unit
