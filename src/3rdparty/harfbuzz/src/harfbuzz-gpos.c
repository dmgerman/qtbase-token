begin_unit
begin_comment
comment|/*  * Copyright (C) 1998-2004  David Turner and Werner Lemberg  * Copyright (C) 2006  Behdad Esfahbod  * Copyright (C) 2007  Red Hat, Inc.  *  * This is part of HarfBuzz, an OpenType Layout engine library.  *  * Permission is hereby granted, without written agreement and without  * license or royalty fees, to use, copy, modify, and distribute this  * software and its documentation for any purpose, provided that the  * above copyright notice and the following two paragraphs appear in  * all copies of this software.  *  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH  * DAMAGE.  *  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS  * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.  *  * Red Hat Author(s): Behdad Esfahbod  */
end_comment
begin_include
include|#
directive|include
file|"harfbuzz-impl.h"
end_include
begin_include
include|#
directive|include
file|"harfbuzz-gpos-private.h"
end_include
begin_include
include|#
directive|include
file|"harfbuzz-open-private.h"
end_include
begin_include
include|#
directive|include
file|"harfbuzz-gdef-private.h"
end_include
begin_include
include|#
directive|include
file|"harfbuzz-shaper.h"
end_include
begin_struct
DECL|struct|GPOS_Instance_
struct|struct
name|GPOS_Instance_
block|{
DECL|member|gpos
name|HB_GPOSHeader
modifier|*
name|gpos
decl_stmt|;
DECL|member|font
name|HB_Font
name|font
decl_stmt|;
DECL|member|dvi
name|HB_Bool
name|dvi
decl_stmt|;
DECL|member|load_flags
name|HB_UShort
name|load_flags
decl_stmt|;
comment|/* how the glyph should be loaded */
DECL|member|r2l
name|HB_Bool
name|r2l
decl_stmt|;
DECL|member|last
name|HB_UShort
name|last
decl_stmt|;
comment|/* the last valid glyph -- used 				   with cursive positioning     */
DECL|member|anchor_x
name|HB_Fixed
name|anchor_x
decl_stmt|;
comment|/* the coordinates of the anchor point */
DECL|member|anchor_y
name|HB_Fixed
name|anchor_y
decl_stmt|;
comment|/* of the last valid glyph             */
block|}
struct|;
end_struct
begin_typedef
DECL|typedef|GPOS_Instance
typedef|typedef
name|struct
name|GPOS_Instance_
name|GPOS_Instance
typedef|;
end_typedef
begin_function_decl
specifier|static
name|HB_Error
name|GPOS_Do_Glyph_Lookup
parameter_list|(
name|GPOS_Instance
modifier|*
name|gpi
parameter_list|,
name|HB_UShort
name|lookup_index
parameter_list|,
name|HB_Buffer
name|buffer
parameter_list|,
name|HB_UShort
name|context_length
parameter_list|,
name|int
name|nesting_level
parameter_list|)
function_decl|;
end_function_decl
begin_ifdef
ifdef|#
directive|ifdef
name|HB_SUPPORT_MULTIPLE_MASTER
end_ifdef
begin_comment
comment|/* the client application must replace this with something more    meaningful if multiple master fonts are to be supported.     */
end_comment
begin_function
DECL|function|default_mmfunc
specifier|static
name|HB_Error
name|default_mmfunc
parameter_list|(
name|HB_Font
name|font
parameter_list|,
name|HB_UShort
name|metric_id
parameter_list|,
name|HB_Fixed
modifier|*
name|metric_value
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|HB_UNUSED
argument_list|(
name|font
argument_list|)
expr_stmt|;
name|HB_UNUSED
argument_list|(
name|metric_id
argument_list|)
expr_stmt|;
name|HB_UNUSED
argument_list|(
name|metric_value
argument_list|)
expr_stmt|;
name|HB_UNUSED
argument_list|(
name|data
argument_list|)
expr_stmt|;
return|return
name|ERR
argument_list|(
name|HB_Err_Not_Covered
argument_list|)
return|;
comment|/* ERR() call intended */
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|HB_Load_GPOS_Table
name|HB_Error
name|HB_Load_GPOS_Table
parameter_list|(
name|HB_Stream
name|stream
parameter_list|,
name|HB_GPOSHeader
modifier|*
modifier|*
name|retptr
parameter_list|,
name|HB_GDEFHeader
modifier|*
name|gdef
parameter_list|,
name|HB_Stream
name|gdefStream
parameter_list|)
block|{
name|HB_UInt
name|cur_offset
decl_stmt|,
name|new_offset
decl_stmt|,
name|base_offset
decl_stmt|;
name|HB_GPOSHeader
modifier|*
name|gpos
decl_stmt|;
name|HB_Error
name|error
decl_stmt|;
if|if
condition|(
operator|!
name|retptr
condition|)
return|return
name|ERR
argument_list|(
name|HB_Err_Invalid_Argument
argument_list|)
return|;
if|if
condition|(
name|GOTO_Table
argument_list|(
name|TTAG_GPOS
argument_list|)
condition|)
return|return
name|error
return|;
name|base_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|ALLOC
argument_list|(
name|gpos
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|gpos
argument_list|)
argument_list|)
condition|)
return|return
name|error
return|;
ifdef|#
directive|ifdef
name|HB_SUPPORT_MULTIPLE_MASTER
name|gpos
operator|->
name|mmfunc
operator|=
name|default_mmfunc
expr_stmt|;
endif|#
directive|endif
comment|/* skip version */
if|if
condition|(
name|FILE_Seek
argument_list|(
name|base_offset
operator|+
literal|4L
argument_list|)
operator|||
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail4
goto|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
operator|+
name|base_offset
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|_HB_OPEN_Load_ScriptList
argument_list|(
operator|&
name|gpos
operator|->
name|ScriptList
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
goto|goto
name|Fail4
goto|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail3
goto|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
operator|+
name|base_offset
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|_HB_OPEN_Load_FeatureList
argument_list|(
operator|&
name|gpos
operator|->
name|FeatureList
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
goto|goto
name|Fail3
goto|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail2
goto|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
operator|+
name|base_offset
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|_HB_OPEN_Load_LookupList
argument_list|(
operator|&
name|gpos
operator|->
name|LookupList
argument_list|,
name|stream
argument_list|,
name|HB_Type_GPOS
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
goto|goto
name|Fail2
goto|;
name|gpos
operator|->
name|gdef
operator|=
name|gdef
expr_stmt|;
comment|/* can be NULL */
if|if
condition|(
operator|(
name|error
operator|=
name|_HB_GDEF_LoadMarkAttachClassDef_From_LookupFlags
argument_list|(
name|gdef
argument_list|,
name|gdefStream
argument_list|,
name|gpos
operator|->
name|LookupList
operator|.
name|Lookup
argument_list|,
name|gpos
operator|->
name|LookupList
operator|.
name|LookupCount
argument_list|)
operator|)
condition|)
goto|goto
name|Fail1
goto|;
operator|*
name|retptr
operator|=
name|gpos
expr_stmt|;
return|return
name|HB_Err_Ok
return|;
name|Fail1
label|:
name|_HB_OPEN_Free_LookupList
argument_list|(
operator|&
name|gpos
operator|->
name|LookupList
argument_list|,
name|HB_Type_GPOS
argument_list|)
expr_stmt|;
name|Fail2
label|:
name|_HB_OPEN_Free_FeatureList
argument_list|(
operator|&
name|gpos
operator|->
name|FeatureList
argument_list|)
expr_stmt|;
name|Fail3
label|:
name|_HB_OPEN_Free_ScriptList
argument_list|(
operator|&
name|gpos
operator|->
name|ScriptList
argument_list|)
expr_stmt|;
name|Fail4
label|:
name|FREE
argument_list|(
name|gpos
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_function
DECL|function|HB_Done_GPOS_Table
name|HB_Error
name|HB_Done_GPOS_Table
parameter_list|(
name|HB_GPOSHeader
modifier|*
name|gpos
parameter_list|)
block|{
name|_HB_OPEN_Free_LookupList
argument_list|(
operator|&
name|gpos
operator|->
name|LookupList
argument_list|,
name|HB_Type_GPOS
argument_list|)
expr_stmt|;
name|_HB_OPEN_Free_FeatureList
argument_list|(
operator|&
name|gpos
operator|->
name|FeatureList
argument_list|)
expr_stmt|;
name|_HB_OPEN_Free_ScriptList
argument_list|(
operator|&
name|gpos
operator|->
name|ScriptList
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|gpos
argument_list|)
expr_stmt|;
return|return
name|HB_Err_Ok
return|;
block|}
end_function
begin_comment
comment|/*****************************  * SubTable related functions  *****************************/
end_comment
begin_comment
comment|/* shared tables */
end_comment
begin_comment
comment|/* ValueRecord */
end_comment
begin_comment
comment|/* There is a subtle difference in the specs between a `table' and a    `record' -- offsets for device tables in ValueRecords are taken from    the parent table and not the parent record.                          */
end_comment
begin_function
DECL|function|Load_ValueRecord
specifier|static
name|HB_Error
name|Load_ValueRecord
parameter_list|(
name|HB_ValueRecord
modifier|*
name|vr
parameter_list|,
name|HB_UShort
name|format
parameter_list|,
name|HB_UInt
name|base_offset
parameter_list|,
name|HB_Stream
name|stream
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_UInt
name|cur_offset
decl_stmt|,
name|new_offset
decl_stmt|;
if|if
condition|(
name|format
operator|&
name|HB_GPOS_FORMAT_HAVE_X_PLACEMENT
condition|)
block|{
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
return|return
name|error
return|;
name|vr
operator|->
name|XPlacement
operator|=
name|GET_Short
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
block|}
else|else
name|vr
operator|->
name|XPlacement
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|format
operator|&
name|HB_GPOS_FORMAT_HAVE_Y_PLACEMENT
condition|)
block|{
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
return|return
name|error
return|;
name|vr
operator|->
name|YPlacement
operator|=
name|GET_Short
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
block|}
else|else
name|vr
operator|->
name|YPlacement
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|format
operator|&
name|HB_GPOS_FORMAT_HAVE_X_ADVANCE
condition|)
block|{
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
return|return
name|error
return|;
name|vr
operator|->
name|XAdvance
operator|=
name|GET_Short
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
block|}
else|else
name|vr
operator|->
name|XAdvance
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|format
operator|&
name|HB_GPOS_FORMAT_HAVE_Y_ADVANCE
condition|)
block|{
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
return|return
name|error
return|;
name|vr
operator|->
name|YAdvance
operator|=
name|GET_Short
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
block|}
else|else
name|vr
operator|->
name|YAdvance
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|format
operator|&
name|HB_GPOS_FORMAT_HAVE_DEVICE_TABLES
condition|)
block|{
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|vr
operator|->
name|DeviceTables
argument_list|,
literal|4
argument_list|,
name|HB_Device
argument_list|)
condition|)
return|return
name|error
return|;
name|vr
operator|->
name|DeviceTables
index|[
name|VR_X_ADVANCE_DEVICE
index|]
operator|=
literal|0
expr_stmt|;
name|vr
operator|->
name|DeviceTables
index|[
name|VR_Y_ADVANCE_DEVICE
index|]
operator|=
literal|0
expr_stmt|;
name|vr
operator|->
name|DeviceTables
index|[
name|VR_X_PLACEMENT_DEVICE
index|]
operator|=
literal|0
expr_stmt|;
name|vr
operator|->
name|DeviceTables
index|[
name|VR_Y_PLACEMENT_DEVICE
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|vr
operator|->
name|DeviceTables
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|format
operator|&
name|HB_GPOS_FORMAT_HAVE_X_PLACEMENT_DEVICE
condition|)
block|{
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail4
goto|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
if|if
condition|(
name|new_offset
condition|)
block|{
name|new_offset
operator|+=
name|base_offset
expr_stmt|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|_HB_OPEN_Load_Device
argument_list|(
operator|&
name|vr
operator|->
name|DeviceTables
index|[
name|VR_X_PLACEMENT_DEVICE
index|]
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
goto|goto
name|Fail4
goto|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|format
operator|&
name|HB_GPOS_FORMAT_HAVE_Y_PLACEMENT_DEVICE
condition|)
block|{
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail3
goto|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
if|if
condition|(
name|new_offset
condition|)
block|{
name|new_offset
operator|+=
name|base_offset
expr_stmt|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|_HB_OPEN_Load_Device
argument_list|(
operator|&
name|vr
operator|->
name|DeviceTables
index|[
name|VR_Y_PLACEMENT_DEVICE
index|]
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
goto|goto
name|Fail3
goto|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|format
operator|&
name|HB_GPOS_FORMAT_HAVE_X_ADVANCE_DEVICE
condition|)
block|{
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail2
goto|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
if|if
condition|(
name|new_offset
condition|)
block|{
name|new_offset
operator|+=
name|base_offset
expr_stmt|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|_HB_OPEN_Load_Device
argument_list|(
operator|&
name|vr
operator|->
name|DeviceTables
index|[
name|VR_X_ADVANCE_DEVICE
index|]
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
goto|goto
name|Fail2
goto|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|format
operator|&
name|HB_GPOS_FORMAT_HAVE_Y_ADVANCE_DEVICE
condition|)
block|{
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail1
goto|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
if|if
condition|(
name|new_offset
condition|)
block|{
name|new_offset
operator|+=
name|base_offset
expr_stmt|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|_HB_OPEN_Load_Device
argument_list|(
operator|&
name|vr
operator|->
name|DeviceTables
index|[
name|VR_Y_ADVANCE_DEVICE
index|]
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
goto|goto
name|Fail1
goto|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|format
operator|&
name|HB_GPOS_FORMAT_HAVE_X_ID_PLACEMENT
condition|)
block|{
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail1
goto|;
ifdef|#
directive|ifdef
name|HB_SUPPORT_MULTIPLE_MASTER
name|vr
operator|->
name|XIdPlacement
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|GET_UShort
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|FORGET_Frame
argument_list|()
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HB_SUPPORT_MULTIPLE_MASTER
else|else
name|vr
operator|->
name|XIdPlacement
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|format
operator|&
name|HB_GPOS_FORMAT_HAVE_Y_ID_PLACEMENT
condition|)
block|{
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail1
goto|;
ifdef|#
directive|ifdef
name|HB_SUPPORT_MULTIPLE_MASTER
name|vr
operator|->
name|YIdPlacement
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|GET_UShort
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|FORGET_Frame
argument_list|()
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HB_SUPPORT_MULTIPLE_MASTER
else|else
name|vr
operator|->
name|YIdPlacement
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|format
operator|&
name|HB_GPOS_FORMAT_HAVE_X_ID_ADVANCE
condition|)
block|{
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail1
goto|;
ifdef|#
directive|ifdef
name|HB_SUPPORT_MULTIPLE_MASTER
name|vr
operator|->
name|XIdAdvance
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|GET_UShort
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|FORGET_Frame
argument_list|()
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HB_SUPPORT_MULTIPLE_MASTER
else|else
name|vr
operator|->
name|XIdAdvance
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|format
operator|&
name|HB_GPOS_FORMAT_HAVE_Y_ID_ADVANCE
condition|)
block|{
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail1
goto|;
ifdef|#
directive|ifdef
name|HB_SUPPORT_MULTIPLE_MASTER
name|vr
operator|->
name|YIdAdvance
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|GET_UShort
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|FORGET_Frame
argument_list|()
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HB_SUPPORT_MULTIPLE_MASTER
else|else
name|vr
operator|->
name|YIdAdvance
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
return|return
name|HB_Err_Ok
return|;
name|Fail1
label|:
if|if
condition|(
name|vr
operator|->
name|DeviceTables
condition|)
name|_HB_OPEN_Free_Device
argument_list|(
name|vr
operator|->
name|DeviceTables
index|[
name|VR_Y_ADVANCE_DEVICE
index|]
argument_list|)
expr_stmt|;
name|Fail2
label|:
if|if
condition|(
name|vr
operator|->
name|DeviceTables
condition|)
name|_HB_OPEN_Free_Device
argument_list|(
name|vr
operator|->
name|DeviceTables
index|[
name|VR_X_ADVANCE_DEVICE
index|]
argument_list|)
expr_stmt|;
name|Fail3
label|:
if|if
condition|(
name|vr
operator|->
name|DeviceTables
condition|)
name|_HB_OPEN_Free_Device
argument_list|(
name|vr
operator|->
name|DeviceTables
index|[
name|VR_Y_PLACEMENT_DEVICE
index|]
argument_list|)
expr_stmt|;
name|Fail4
label|:
name|FREE
argument_list|(
name|vr
operator|->
name|DeviceTables
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_function
DECL|function|Free_ValueRecord
specifier|static
name|void
name|Free_ValueRecord
parameter_list|(
name|HB_ValueRecord
modifier|*
name|vr
parameter_list|,
name|HB_UShort
name|format
parameter_list|)
block|{
if|if
condition|(
name|format
operator|&
name|HB_GPOS_FORMAT_HAVE_Y_ADVANCE_DEVICE
condition|)
name|_HB_OPEN_Free_Device
argument_list|(
name|vr
operator|->
name|DeviceTables
index|[
name|VR_Y_ADVANCE_DEVICE
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|format
operator|&
name|HB_GPOS_FORMAT_HAVE_X_ADVANCE_DEVICE
condition|)
name|_HB_OPEN_Free_Device
argument_list|(
name|vr
operator|->
name|DeviceTables
index|[
name|VR_X_ADVANCE_DEVICE
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|format
operator|&
name|HB_GPOS_FORMAT_HAVE_Y_PLACEMENT_DEVICE
condition|)
name|_HB_OPEN_Free_Device
argument_list|(
name|vr
operator|->
name|DeviceTables
index|[
name|VR_Y_PLACEMENT_DEVICE
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|format
operator|&
name|HB_GPOS_FORMAT_HAVE_X_PLACEMENT_DEVICE
condition|)
name|_HB_OPEN_Free_Device
argument_list|(
name|vr
operator|->
name|DeviceTables
index|[
name|VR_X_PLACEMENT_DEVICE
index|]
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|vr
operator|->
name|DeviceTables
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|Get_ValueRecord
specifier|static
name|HB_Error
name|Get_ValueRecord
parameter_list|(
name|GPOS_Instance
modifier|*
name|gpi
parameter_list|,
name|HB_ValueRecord
modifier|*
name|vr
parameter_list|,
name|HB_UShort
name|format
parameter_list|,
name|HB_Position
name|gd
parameter_list|)
block|{
name|HB_Short
name|pixel_value
decl_stmt|;
name|HB_Error
name|error
init|=
name|HB_Err_Ok
decl_stmt|;
ifdef|#
directive|ifdef
name|HB_SUPPORT_MULTIPLE_MASTER
name|HB_GPOSHeader
modifier|*
name|gpos
init|=
name|gpi
operator|->
name|gpos
decl_stmt|;
name|HB_Fixed
name|value
decl_stmt|;
endif|#
directive|endif
name|HB_UShort
name|x_ppem
decl_stmt|,
name|y_ppem
decl_stmt|;
name|HB_16Dot16
name|x_scale
decl_stmt|,
name|y_scale
decl_stmt|;
if|if
condition|(
operator|!
name|format
condition|)
return|return
name|HB_Err_Ok
return|;
name|x_ppem
operator|=
name|gpi
operator|->
name|font
operator|->
name|x_ppem
expr_stmt|;
name|y_ppem
operator|=
name|gpi
operator|->
name|font
operator|->
name|y_ppem
expr_stmt|;
name|x_scale
operator|=
name|gpi
operator|->
name|font
operator|->
name|x_scale
expr_stmt|;
name|y_scale
operator|=
name|gpi
operator|->
name|font
operator|->
name|y_scale
expr_stmt|;
comment|/* design units -> fractional pixel */
if|if
condition|(
name|format
operator|&
name|HB_GPOS_FORMAT_HAVE_X_PLACEMENT
condition|)
name|gd
operator|->
name|x_pos
operator|+=
name|x_scale
operator|*
name|vr
operator|->
name|XPlacement
operator|/
literal|0x10000
expr_stmt|;
if|if
condition|(
name|format
operator|&
name|HB_GPOS_FORMAT_HAVE_Y_PLACEMENT
condition|)
name|gd
operator|->
name|y_pos
operator|+=
name|y_scale
operator|*
name|vr
operator|->
name|YPlacement
operator|/
literal|0x10000
expr_stmt|;
if|if
condition|(
name|format
operator|&
name|HB_GPOS_FORMAT_HAVE_X_ADVANCE
condition|)
name|gd
operator|->
name|x_advance
operator|+=
name|x_scale
operator|*
name|vr
operator|->
name|XAdvance
operator|/
literal|0x10000
expr_stmt|;
if|if
condition|(
name|format
operator|&
name|HB_GPOS_FORMAT_HAVE_Y_ADVANCE
condition|)
name|gd
operator|->
name|y_advance
operator|+=
name|y_scale
operator|*
name|vr
operator|->
name|YAdvance
operator|/
literal|0x10000
expr_stmt|;
if|if
condition|(
operator|!
name|gpi
operator|->
name|dvi
condition|)
block|{
comment|/* pixel -> fractional pixel */
if|if
condition|(
name|format
operator|&
name|HB_GPOS_FORMAT_HAVE_X_PLACEMENT_DEVICE
condition|)
block|{
name|_HB_OPEN_Get_Device
argument_list|(
name|vr
operator|->
name|DeviceTables
index|[
name|VR_X_PLACEMENT_DEVICE
index|]
argument_list|,
name|x_ppem
argument_list|,
operator|&
name|pixel_value
argument_list|)
expr_stmt|;
name|gd
operator|->
name|x_pos
operator|+=
name|pixel_value
operator|<<
literal|6
expr_stmt|;
block|}
if|if
condition|(
name|format
operator|&
name|HB_GPOS_FORMAT_HAVE_Y_PLACEMENT_DEVICE
condition|)
block|{
name|_HB_OPEN_Get_Device
argument_list|(
name|vr
operator|->
name|DeviceTables
index|[
name|VR_Y_PLACEMENT_DEVICE
index|]
argument_list|,
name|y_ppem
argument_list|,
operator|&
name|pixel_value
argument_list|)
expr_stmt|;
name|gd
operator|->
name|y_pos
operator|+=
name|pixel_value
operator|<<
literal|6
expr_stmt|;
block|}
if|if
condition|(
name|format
operator|&
name|HB_GPOS_FORMAT_HAVE_X_ADVANCE_DEVICE
condition|)
block|{
name|_HB_OPEN_Get_Device
argument_list|(
name|vr
operator|->
name|DeviceTables
index|[
name|VR_X_ADVANCE_DEVICE
index|]
argument_list|,
name|x_ppem
argument_list|,
operator|&
name|pixel_value
argument_list|)
expr_stmt|;
name|gd
operator|->
name|x_advance
operator|+=
name|pixel_value
operator|<<
literal|6
expr_stmt|;
block|}
if|if
condition|(
name|format
operator|&
name|HB_GPOS_FORMAT_HAVE_Y_ADVANCE_DEVICE
condition|)
block|{
name|_HB_OPEN_Get_Device
argument_list|(
name|vr
operator|->
name|DeviceTables
index|[
name|VR_Y_ADVANCE_DEVICE
index|]
argument_list|,
name|y_ppem
argument_list|,
operator|&
name|pixel_value
argument_list|)
expr_stmt|;
name|gd
operator|->
name|y_advance
operator|+=
name|pixel_value
operator|<<
literal|6
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|HB_SUPPORT_MULTIPLE_MASTER
comment|/* values returned from mmfunc() are already in fractional pixels */
if|if
condition|(
name|format
operator|&
name|HB_GPOS_FORMAT_HAVE_X_ID_PLACEMENT
condition|)
block|{
name|error
operator|=
call|(
name|gpos
operator|->
name|mmfunc
call|)
argument_list|(
name|gpi
operator|->
name|font
argument_list|,
name|vr
operator|->
name|XIdPlacement
argument_list|,
operator|&
name|value
argument_list|,
name|gpos
operator|->
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|gd
operator|->
name|x_pos
operator|+=
name|value
expr_stmt|;
block|}
if|if
condition|(
name|format
operator|&
name|HB_GPOS_FORMAT_HAVE_Y_ID_PLACEMENT
condition|)
block|{
name|error
operator|=
call|(
name|gpos
operator|->
name|mmfunc
call|)
argument_list|(
name|gpi
operator|->
name|font
argument_list|,
name|vr
operator|->
name|YIdPlacement
argument_list|,
operator|&
name|value
argument_list|,
name|gpos
operator|->
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|gd
operator|->
name|y_pos
operator|+=
name|value
expr_stmt|;
block|}
if|if
condition|(
name|format
operator|&
name|HB_GPOS_FORMAT_HAVE_X_ID_ADVANCE
condition|)
block|{
name|error
operator|=
call|(
name|gpos
operator|->
name|mmfunc
call|)
argument_list|(
name|gpi
operator|->
name|font
argument_list|,
name|vr
operator|->
name|XIdAdvance
argument_list|,
operator|&
name|value
argument_list|,
name|gpos
operator|->
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|gd
operator|->
name|x_advance
operator|+=
name|value
expr_stmt|;
block|}
if|if
condition|(
name|format
operator|&
name|HB_GPOS_FORMAT_HAVE_Y_ID_ADVANCE
condition|)
block|{
name|error
operator|=
call|(
name|gpos
operator|->
name|mmfunc
call|)
argument_list|(
name|gpi
operator|->
name|font
argument_list|,
name|vr
operator|->
name|YIdAdvance
argument_list|,
operator|&
name|value
argument_list|,
name|gpos
operator|->
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|gd
operator|->
name|y_advance
operator|+=
name|value
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|error
return|;
block|}
end_function
begin_comment
comment|/* AnchorFormat1 */
end_comment
begin_comment
comment|/* AnchorFormat2 */
end_comment
begin_comment
comment|/* AnchorFormat3 */
end_comment
begin_comment
comment|/* AnchorFormat4 */
end_comment
begin_function
DECL|function|Load_Anchor
specifier|static
name|HB_Error
name|Load_Anchor
parameter_list|(
name|HB_Anchor
modifier|*
name|an
parameter_list|,
name|HB_Stream
name|stream
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_UInt
name|cur_offset
decl_stmt|,
name|new_offset
decl_stmt|,
name|base_offset
decl_stmt|;
name|base_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
return|return
name|error
return|;
name|an
operator|->
name|PosFormat
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|an
operator|->
name|PosFormat
condition|)
block|{
case|case
literal|1
case|:
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|4L
argument_list|)
condition|)
return|return
name|error
return|;
name|an
operator|->
name|af
operator|.
name|af1
operator|.
name|XCoordinate
operator|=
name|GET_Short
argument_list|()
expr_stmt|;
name|an
operator|->
name|af
operator|.
name|af1
operator|.
name|YCoordinate
operator|=
name|GET_Short
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
break|break;
case|case
literal|2
case|:
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|6L
argument_list|)
condition|)
return|return
name|error
return|;
name|an
operator|->
name|af
operator|.
name|af2
operator|.
name|XCoordinate
operator|=
name|GET_Short
argument_list|()
expr_stmt|;
name|an
operator|->
name|af
operator|.
name|af2
operator|.
name|YCoordinate
operator|=
name|GET_Short
argument_list|()
expr_stmt|;
name|an
operator|->
name|af
operator|.
name|af2
operator|.
name|AnchorPoint
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
break|break;
case|case
literal|3
case|:
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|6L
argument_list|)
condition|)
return|return
name|error
return|;
name|an
operator|->
name|af
operator|.
name|af3
operator|.
name|XCoordinate
operator|=
name|GET_Short
argument_list|()
expr_stmt|;
name|an
operator|->
name|af
operator|.
name|af3
operator|.
name|YCoordinate
operator|=
name|GET_Short
argument_list|()
expr_stmt|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
if|if
condition|(
name|new_offset
condition|)
block|{
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|an
operator|->
name|af
operator|.
name|af3
operator|.
name|DeviceTables
argument_list|,
literal|2
argument_list|,
name|HB_Device
argument_list|)
condition|)
return|return
name|error
return|;
name|an
operator|->
name|af
operator|.
name|af3
operator|.
name|DeviceTables
index|[
name|AF3_X_DEVICE_TABLE
index|]
operator|=
literal|0
expr_stmt|;
name|an
operator|->
name|af
operator|.
name|af3
operator|.
name|DeviceTables
index|[
name|AF3_Y_DEVICE_TABLE
index|]
operator|=
literal|0
expr_stmt|;
name|new_offset
operator|+=
name|base_offset
expr_stmt|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|_HB_OPEN_Load_Device
argument_list|(
operator|&
name|an
operator|->
name|af
operator|.
name|af3
operator|.
name|DeviceTables
index|[
name|AF3_X_DEVICE_TABLE
index|]
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
goto|goto
name|Fail2
goto|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
if|if
condition|(
name|new_offset
condition|)
block|{
if|if
condition|(
operator|!
name|an
operator|->
name|af
operator|.
name|af3
operator|.
name|DeviceTables
condition|)
block|{
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|an
operator|->
name|af
operator|.
name|af3
operator|.
name|DeviceTables
argument_list|,
literal|2
argument_list|,
name|HB_Device
argument_list|)
condition|)
return|return
name|error
return|;
name|an
operator|->
name|af
operator|.
name|af3
operator|.
name|DeviceTables
index|[
name|AF3_X_DEVICE_TABLE
index|]
operator|=
literal|0
expr_stmt|;
name|an
operator|->
name|af
operator|.
name|af3
operator|.
name|DeviceTables
index|[
name|AF3_Y_DEVICE_TABLE
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|new_offset
operator|+=
name|base_offset
expr_stmt|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|_HB_OPEN_Load_Device
argument_list|(
operator|&
name|an
operator|->
name|af
operator|.
name|af3
operator|.
name|DeviceTables
index|[
name|AF3_Y_DEVICE_TABLE
index|]
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
goto|goto
name|Fail
goto|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|4
case|:
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|4L
argument_list|)
condition|)
return|return
name|error
return|;
ifdef|#
directive|ifdef
name|HB_SUPPORT_MULTIPLE_MASTER
name|an
operator|->
name|af
operator|.
name|af4
operator|.
name|XIdAnchor
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|an
operator|->
name|af
operator|.
name|af4
operator|.
name|YIdAnchor
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|GET_UShort
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|GET_UShort
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|FORGET_Frame
argument_list|()
expr_stmt|;
break|break;
default|default:
return|return
name|ERR
argument_list|(
name|HB_Err_Invalid_SubTable_Format
argument_list|)
return|;
block|}
return|return
name|HB_Err_Ok
return|;
name|Fail
label|:
if|if
condition|(
name|an
operator|->
name|af
operator|.
name|af3
operator|.
name|DeviceTables
condition|)
name|_HB_OPEN_Free_Device
argument_list|(
name|an
operator|->
name|af
operator|.
name|af3
operator|.
name|DeviceTables
index|[
name|AF3_X_DEVICE_TABLE
index|]
argument_list|)
expr_stmt|;
name|Fail2
label|:
name|FREE
argument_list|(
name|an
operator|->
name|af
operator|.
name|af3
operator|.
name|DeviceTables
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_function
DECL|function|Free_Anchor
specifier|static
name|void
name|Free_Anchor
parameter_list|(
name|HB_Anchor
modifier|*
name|an
parameter_list|)
block|{
if|if
condition|(
name|an
operator|->
name|PosFormat
operator|==
literal|3
operator|&&
name|an
operator|->
name|af
operator|.
name|af3
operator|.
name|DeviceTables
condition|)
block|{
name|_HB_OPEN_Free_Device
argument_list|(
name|an
operator|->
name|af
operator|.
name|af3
operator|.
name|DeviceTables
index|[
name|AF3_X_DEVICE_TABLE
index|]
argument_list|)
expr_stmt|;
name|_HB_OPEN_Free_Device
argument_list|(
name|an
operator|->
name|af
operator|.
name|af3
operator|.
name|DeviceTables
index|[
name|AF3_Y_DEVICE_TABLE
index|]
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|an
operator|->
name|af
operator|.
name|af3
operator|.
name|DeviceTables
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|Get_Anchor
specifier|static
name|HB_Error
name|Get_Anchor
parameter_list|(
name|GPOS_Instance
modifier|*
name|gpi
parameter_list|,
name|HB_Anchor
modifier|*
name|an
parameter_list|,
name|HB_UShort
name|glyph_index
parameter_list|,
name|HB_Fixed
modifier|*
name|x_value
parameter_list|,
name|HB_Fixed
modifier|*
name|y_value
parameter_list|)
block|{
name|HB_Error
name|error
init|=
name|HB_Err_Ok
decl_stmt|;
ifdef|#
directive|ifdef
name|HB_SUPPORT_MULTIPLE_MASTER
name|HB_GPOSHeader
modifier|*
name|gpos
init|=
name|gpi
operator|->
name|gpos
decl_stmt|;
endif|#
directive|endif
name|HB_UShort
name|ap
decl_stmt|;
name|HB_Short
name|pixel_value
decl_stmt|;
name|HB_UShort
name|x_ppem
decl_stmt|,
name|y_ppem
decl_stmt|;
name|HB_16Dot16
name|x_scale
decl_stmt|,
name|y_scale
decl_stmt|;
name|x_ppem
operator|=
name|gpi
operator|->
name|font
operator|->
name|x_ppem
expr_stmt|;
name|y_ppem
operator|=
name|gpi
operator|->
name|font
operator|->
name|y_ppem
expr_stmt|;
name|x_scale
operator|=
name|gpi
operator|->
name|font
operator|->
name|x_scale
expr_stmt|;
name|y_scale
operator|=
name|gpi
operator|->
name|font
operator|->
name|y_scale
expr_stmt|;
switch|switch
condition|(
name|an
operator|->
name|PosFormat
condition|)
block|{
case|case
literal|0
case|:
comment|/* The special case of an empty AnchorTable */
default|default:
return|return
name|HB_Err_Not_Covered
return|;
case|case
literal|1
case|:
operator|*
name|x_value
operator|=
name|x_scale
operator|*
name|an
operator|->
name|af
operator|.
name|af1
operator|.
name|XCoordinate
operator|/
literal|0x10000
expr_stmt|;
operator|*
name|y_value
operator|=
name|y_scale
operator|*
name|an
operator|->
name|af
operator|.
name|af1
operator|.
name|YCoordinate
operator|/
literal|0x10000
expr_stmt|;
break|break;
case|case
literal|2
case|:
if|if
condition|(
operator|!
name|gpi
operator|->
name|dvi
condition|)
block|{
name|hb_uint32
name|n_points
init|=
literal|0
decl_stmt|;
name|ap
operator|=
name|an
operator|->
name|af
operator|.
name|af2
operator|.
name|AnchorPoint
expr_stmt|;
if|if
condition|(
operator|!
name|gpi
operator|->
name|font
operator|->
name|klass
operator|->
name|getPointInOutline
condition|)
goto|goto
name|no_contour_point
goto|;
name|error
operator|=
name|gpi
operator|->
name|font
operator|->
name|klass
operator|->
name|getPointInOutline
argument_list|(
name|gpi
operator|->
name|font
argument_list|,
name|glyph_index
argument_list|,
name|gpi
operator|->
name|load_flags
argument_list|,
name|ap
argument_list|,
name|x_value
argument_list|,
name|y_value
argument_list|,
operator|&
name|n_points
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
comment|/* if n_points is set to zero, we use the design coordinate value pair.        * This can happen e.g. for sbit glyphs. */
if|if
condition|(
operator|!
name|n_points
condition|)
goto|goto
name|no_contour_point
goto|;
block|}
else|else
block|{
name|no_contour_point
label|:
operator|*
name|x_value
operator|=
name|x_scale
operator|*
name|an
operator|->
name|af
operator|.
name|af3
operator|.
name|XCoordinate
operator|/
literal|0x10000
expr_stmt|;
operator|*
name|y_value
operator|=
name|y_scale
operator|*
name|an
operator|->
name|af
operator|.
name|af3
operator|.
name|YCoordinate
operator|/
literal|0x10000
expr_stmt|;
block|}
break|break;
case|case
literal|3
case|:
if|if
condition|(
operator|!
name|gpi
operator|->
name|dvi
condition|)
block|{
name|_HB_OPEN_Get_Device
argument_list|(
name|an
operator|->
name|af
operator|.
name|af3
operator|.
name|DeviceTables
index|[
name|AF3_X_DEVICE_TABLE
index|]
argument_list|,
name|x_ppem
argument_list|,
operator|&
name|pixel_value
argument_list|)
expr_stmt|;
operator|*
name|x_value
operator|=
name|pixel_value
operator|<<
literal|6
expr_stmt|;
name|_HB_OPEN_Get_Device
argument_list|(
name|an
operator|->
name|af
operator|.
name|af3
operator|.
name|DeviceTables
index|[
name|AF3_Y_DEVICE_TABLE
index|]
argument_list|,
name|y_ppem
argument_list|,
operator|&
name|pixel_value
argument_list|)
expr_stmt|;
operator|*
name|y_value
operator|=
name|pixel_value
operator|<<
literal|6
expr_stmt|;
block|}
else|else
operator|*
name|x_value
operator|=
operator|*
name|y_value
operator|=
literal|0
expr_stmt|;
operator|*
name|x_value
operator|+=
name|x_scale
operator|*
name|an
operator|->
name|af
operator|.
name|af3
operator|.
name|XCoordinate
operator|/
literal|0x10000
expr_stmt|;
operator|*
name|y_value
operator|+=
name|y_scale
operator|*
name|an
operator|->
name|af
operator|.
name|af3
operator|.
name|YCoordinate
operator|/
literal|0x10000
expr_stmt|;
break|break;
case|case
literal|4
case|:
ifdef|#
directive|ifdef
name|HB_SUPPORT_MULTIPLE_MASTER
name|error
operator|=
call|(
name|gpos
operator|->
name|mmfunc
call|)
argument_list|(
name|gpi
operator|->
name|font
argument_list|,
name|an
operator|->
name|af
operator|.
name|af4
operator|.
name|XIdAnchor
argument_list|,
name|x_value
argument_list|,
name|gpos
operator|->
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|error
operator|=
call|(
name|gpos
operator|->
name|mmfunc
call|)
argument_list|(
name|gpi
operator|->
name|font
argument_list|,
name|an
operator|->
name|af
operator|.
name|af4
operator|.
name|YIdAnchor
argument_list|,
name|y_value
argument_list|,
name|gpos
operator|->
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
break|break;
else|#
directive|else
return|return
name|ERR
argument_list|(
name|HB_Err_Not_Covered
argument_list|)
return|;
endif|#
directive|endif
block|}
return|return
name|error
return|;
block|}
end_function
begin_comment
comment|/* MarkArray */
end_comment
begin_function
DECL|function|Load_MarkArray
specifier|static
name|HB_Error
name|Load_MarkArray
parameter_list|(
name|HB_MarkArray
modifier|*
name|ma
parameter_list|,
name|HB_Stream
name|stream
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_UShort
name|n
decl_stmt|,
name|m
decl_stmt|,
name|count
decl_stmt|;
name|HB_UInt
name|cur_offset
decl_stmt|,
name|new_offset
decl_stmt|,
name|base_offset
decl_stmt|;
name|HB_MarkRecord
modifier|*
name|mr
decl_stmt|;
name|base_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
return|return
name|error
return|;
name|count
operator|=
name|ma
operator|->
name|MarkCount
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|ma
operator|->
name|MarkRecord
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|ma
operator|->
name|MarkRecord
argument_list|,
name|count
argument_list|,
name|HB_MarkRecord
argument_list|)
condition|)
return|return
name|error
return|;
name|mr
operator|=
name|ma
operator|->
name|MarkRecord
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|4L
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
name|mr
index|[
name|n
index|]
operator|.
name|Class
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
operator|+
name|base_offset
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|Load_Anchor
argument_list|(
operator|&
name|mr
index|[
name|n
index|]
operator|.
name|MarkAnchor
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
goto|goto
name|Fail
goto|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
block|}
return|return
name|HB_Err_Ok
return|;
name|Fail
label|:
for|for
control|(
name|m
operator|=
literal|0
init|;
name|m
operator|<
name|n
condition|;
name|m
operator|++
control|)
name|Free_Anchor
argument_list|(
operator|&
name|mr
index|[
name|m
index|]
operator|.
name|MarkAnchor
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|mr
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_function
DECL|function|Free_MarkArray
specifier|static
name|void
name|Free_MarkArray
parameter_list|(
name|HB_MarkArray
modifier|*
name|ma
parameter_list|)
block|{
name|HB_UShort
name|n
decl_stmt|,
name|count
decl_stmt|;
name|HB_MarkRecord
modifier|*
name|mr
decl_stmt|;
if|if
condition|(
name|ma
operator|->
name|MarkRecord
condition|)
block|{
name|count
operator|=
name|ma
operator|->
name|MarkCount
expr_stmt|;
name|mr
operator|=
name|ma
operator|->
name|MarkRecord
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
name|Free_Anchor
argument_list|(
operator|&
name|mr
index|[
name|n
index|]
operator|.
name|MarkAnchor
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|mr
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/* LookupType 1 */
end_comment
begin_comment
comment|/* SinglePosFormat1 */
end_comment
begin_comment
comment|/* SinglePosFormat2 */
end_comment
begin_function
DECL|function|Load_SinglePos
specifier|static
name|HB_Error
name|Load_SinglePos
parameter_list|(
name|HB_GPOS_SubTable
modifier|*
name|st
parameter_list|,
name|HB_Stream
name|stream
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_SinglePos
modifier|*
name|sp
init|=
operator|&
name|st
operator|->
name|single
decl_stmt|;
name|HB_UShort
name|n
decl_stmt|,
name|m
decl_stmt|,
name|count
decl_stmt|,
name|format
decl_stmt|;
name|HB_UInt
name|cur_offset
decl_stmt|,
name|new_offset
decl_stmt|,
name|base_offset
decl_stmt|;
name|HB_ValueRecord
modifier|*
name|vr
decl_stmt|;
name|base_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|6L
argument_list|)
condition|)
return|return
name|error
return|;
name|sp
operator|->
name|PosFormat
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
operator|+
name|base_offset
expr_stmt|;
name|format
operator|=
name|sp
operator|->
name|ValueFormat
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|format
condition|)
return|return
name|ERR
argument_list|(
name|HB_Err_Invalid_SubTable
argument_list|)
return|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|_HB_OPEN_Load_Coverage
argument_list|(
operator|&
name|sp
operator|->
name|Coverage
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
return|return
name|error
return|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sp
operator|->
name|PosFormat
condition|)
block|{
case|case
literal|1
case|:
name|error
operator|=
name|Load_ValueRecord
argument_list|(
operator|&
name|sp
operator|->
name|spf
operator|.
name|spf1
operator|.
name|Value
argument_list|,
name|format
argument_list|,
name|base_offset
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Fail2
goto|;
break|break;
case|case
literal|2
case|:
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail2
goto|;
name|count
operator|=
name|sp
operator|->
name|spf
operator|.
name|spf2
operator|.
name|ValueCount
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|sp
operator|->
name|spf
operator|.
name|spf2
operator|.
name|Value
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|sp
operator|->
name|spf
operator|.
name|spf2
operator|.
name|Value
argument_list|,
name|count
argument_list|,
name|HB_ValueRecord
argument_list|)
condition|)
goto|goto
name|Fail2
goto|;
name|vr
operator|=
name|sp
operator|->
name|spf
operator|.
name|spf2
operator|.
name|Value
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
block|{
name|error
operator|=
name|Load_ValueRecord
argument_list|(
operator|&
name|vr
index|[
name|n
index|]
argument_list|,
name|format
argument_list|,
name|base_offset
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Fail1
goto|;
block|}
break|break;
default|default:
return|return
name|ERR
argument_list|(
name|HB_Err_Invalid_SubTable_Format
argument_list|)
return|;
block|}
return|return
name|HB_Err_Ok
return|;
name|Fail1
label|:
for|for
control|(
name|m
operator|=
literal|0
init|;
name|m
operator|<
name|n
condition|;
name|m
operator|++
control|)
name|Free_ValueRecord
argument_list|(
operator|&
name|vr
index|[
name|m
index|]
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|vr
argument_list|)
expr_stmt|;
name|Fail2
label|:
name|_HB_OPEN_Free_Coverage
argument_list|(
operator|&
name|sp
operator|->
name|Coverage
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_function
DECL|function|Free_SinglePos
specifier|static
name|void
name|Free_SinglePos
parameter_list|(
name|HB_GPOS_SubTable
modifier|*
name|st
parameter_list|)
block|{
name|HB_UShort
name|n
decl_stmt|,
name|count
decl_stmt|,
name|format
decl_stmt|;
name|HB_SinglePos
modifier|*
name|sp
init|=
operator|&
name|st
operator|->
name|single
decl_stmt|;
name|HB_ValueRecord
modifier|*
name|v
decl_stmt|;
name|format
operator|=
name|sp
operator|->
name|ValueFormat
expr_stmt|;
switch|switch
condition|(
name|sp
operator|->
name|PosFormat
condition|)
block|{
case|case
literal|1
case|:
name|Free_ValueRecord
argument_list|(
operator|&
name|sp
operator|->
name|spf
operator|.
name|spf1
operator|.
name|Value
argument_list|,
name|format
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
if|if
condition|(
name|sp
operator|->
name|spf
operator|.
name|spf2
operator|.
name|Value
condition|)
block|{
name|count
operator|=
name|sp
operator|->
name|spf
operator|.
name|spf2
operator|.
name|ValueCount
expr_stmt|;
name|v
operator|=
name|sp
operator|->
name|spf
operator|.
name|spf2
operator|.
name|Value
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
name|Free_ValueRecord
argument_list|(
operator|&
name|v
index|[
name|n
index|]
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
name|_HB_OPEN_Free_Coverage
argument_list|(
operator|&
name|sp
operator|->
name|Coverage
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|Lookup_SinglePos
specifier|static
name|HB_Error
name|Lookup_SinglePos
parameter_list|(
name|GPOS_Instance
modifier|*
name|gpi
parameter_list|,
name|HB_GPOS_SubTable
modifier|*
name|st
parameter_list|,
name|HB_Buffer
name|buffer
parameter_list|,
name|HB_UShort
name|flags
parameter_list|,
name|HB_UShort
name|context_length
parameter_list|,
name|int
name|nesting_level
parameter_list|)
block|{
name|HB_UShort
name|index
decl_stmt|,
name|property
decl_stmt|;
name|HB_Error
name|error
decl_stmt|;
name|HB_GPOSHeader
modifier|*
name|gpos
init|=
name|gpi
operator|->
name|gpos
decl_stmt|;
name|HB_SinglePos
modifier|*
name|sp
init|=
operator|&
name|st
operator|->
name|single
decl_stmt|;
name|HB_UNUSED
argument_list|(
name|nesting_level
argument_list|)
expr_stmt|;
if|if
condition|(
name|context_length
operator|!=
literal|0xFFFF
operator|&&
name|context_length
operator|<
literal|1
condition|)
return|return
name|HB_Err_Not_Covered
return|;
if|if
condition|(
name|CHECK_Property
argument_list|(
name|gpos
operator|->
name|gdef
argument_list|,
name|IN_CURITEM
argument_list|()
argument_list|,
name|flags
argument_list|,
operator|&
name|property
argument_list|)
condition|)
return|return
name|error
return|;
name|error
operator|=
name|_HB_OPEN_Coverage_Index
argument_list|(
operator|&
name|sp
operator|->
name|Coverage
argument_list|,
name|IN_CURGLYPH
argument_list|()
argument_list|,
operator|&
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
switch|switch
condition|(
name|sp
operator|->
name|PosFormat
condition|)
block|{
case|case
literal|1
case|:
name|error
operator|=
name|Get_ValueRecord
argument_list|(
name|gpi
argument_list|,
operator|&
name|sp
operator|->
name|spf
operator|.
name|spf1
operator|.
name|Value
argument_list|,
name|sp
operator|->
name|ValueFormat
argument_list|,
name|POSITION
argument_list|(
name|buffer
operator|->
name|in_pos
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
break|break;
case|case
literal|2
case|:
if|if
condition|(
name|index
operator|>=
name|sp
operator|->
name|spf
operator|.
name|spf2
operator|.
name|ValueCount
condition|)
return|return
name|ERR
argument_list|(
name|HB_Err_Invalid_SubTable
argument_list|)
return|;
name|error
operator|=
name|Get_ValueRecord
argument_list|(
name|gpi
argument_list|,
operator|&
name|sp
operator|->
name|spf
operator|.
name|spf2
operator|.
name|Value
index|[
name|index
index|]
argument_list|,
name|sp
operator|->
name|ValueFormat
argument_list|,
name|POSITION
argument_list|(
name|buffer
operator|->
name|in_pos
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
break|break;
default|default:
return|return
name|ERR
argument_list|(
name|HB_Err_Invalid_SubTable
argument_list|)
return|;
block|}
operator|(
name|buffer
operator|->
name|in_pos
operator|)
operator|++
expr_stmt|;
return|return
name|HB_Err_Ok
return|;
block|}
end_function
begin_comment
comment|/* LookupType 2 */
end_comment
begin_comment
comment|/* PairSet */
end_comment
begin_function
DECL|function|Load_PairSet
specifier|static
name|HB_Error
name|Load_PairSet
parameter_list|(
name|HB_PairSet
modifier|*
name|ps
parameter_list|,
name|HB_UShort
name|format1
parameter_list|,
name|HB_UShort
name|format2
parameter_list|,
name|HB_Stream
name|stream
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_UShort
name|n
decl_stmt|,
name|m
decl_stmt|,
name|count
decl_stmt|;
name|HB_UInt
name|base_offset
decl_stmt|;
name|HB_PairValueRecord
modifier|*
name|pvr
decl_stmt|;
name|base_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
return|return
name|error
return|;
name|count
operator|=
name|ps
operator|->
name|PairValueCount
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|ps
operator|->
name|PairValueRecord
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|ps
operator|->
name|PairValueRecord
argument_list|,
name|count
argument_list|,
name|HB_PairValueRecord
argument_list|)
condition|)
return|return
name|error
return|;
name|pvr
operator|=
name|ps
operator|->
name|PairValueRecord
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
name|pvr
index|[
name|n
index|]
operator|.
name|SecondGlyph
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
if|if
condition|(
name|format1
condition|)
block|{
name|error
operator|=
name|Load_ValueRecord
argument_list|(
operator|&
name|pvr
index|[
name|n
index|]
operator|.
name|Value1
argument_list|,
name|format1
argument_list|,
name|base_offset
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Fail
goto|;
block|}
if|if
condition|(
name|format2
condition|)
block|{
name|error
operator|=
name|Load_ValueRecord
argument_list|(
operator|&
name|pvr
index|[
name|n
index|]
operator|.
name|Value2
argument_list|,
name|format2
argument_list|,
name|base_offset
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|format1
condition|)
name|Free_ValueRecord
argument_list|(
operator|&
name|pvr
index|[
name|n
index|]
operator|.
name|Value1
argument_list|,
name|format1
argument_list|)
expr_stmt|;
goto|goto
name|Fail
goto|;
block|}
block|}
block|}
return|return
name|HB_Err_Ok
return|;
name|Fail
label|:
for|for
control|(
name|m
operator|=
literal|0
init|;
name|m
operator|<
name|n
condition|;
name|m
operator|++
control|)
block|{
if|if
condition|(
name|format1
condition|)
name|Free_ValueRecord
argument_list|(
operator|&
name|pvr
index|[
name|m
index|]
operator|.
name|Value1
argument_list|,
name|format1
argument_list|)
expr_stmt|;
if|if
condition|(
name|format2
condition|)
name|Free_ValueRecord
argument_list|(
operator|&
name|pvr
index|[
name|m
index|]
operator|.
name|Value2
argument_list|,
name|format2
argument_list|)
expr_stmt|;
block|}
name|FREE
argument_list|(
name|pvr
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_function
DECL|function|Free_PairSet
specifier|static
name|void
name|Free_PairSet
parameter_list|(
name|HB_PairSet
modifier|*
name|ps
parameter_list|,
name|HB_UShort
name|format1
parameter_list|,
name|HB_UShort
name|format2
parameter_list|)
block|{
name|HB_UShort
name|n
decl_stmt|,
name|count
decl_stmt|;
name|HB_PairValueRecord
modifier|*
name|pvr
decl_stmt|;
if|if
condition|(
name|ps
operator|->
name|PairValueRecord
condition|)
block|{
name|count
operator|=
name|ps
operator|->
name|PairValueCount
expr_stmt|;
name|pvr
operator|=
name|ps
operator|->
name|PairValueRecord
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|format1
condition|)
name|Free_ValueRecord
argument_list|(
operator|&
name|pvr
index|[
name|n
index|]
operator|.
name|Value1
argument_list|,
name|format1
argument_list|)
expr_stmt|;
if|if
condition|(
name|format2
condition|)
name|Free_ValueRecord
argument_list|(
operator|&
name|pvr
index|[
name|n
index|]
operator|.
name|Value2
argument_list|,
name|format2
argument_list|)
expr_stmt|;
block|}
name|FREE
argument_list|(
name|pvr
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/* PairPosFormat1 */
end_comment
begin_function
DECL|function|Load_PairPos1
specifier|static
name|HB_Error
name|Load_PairPos1
parameter_list|(
name|HB_PairPosFormat1
modifier|*
name|ppf1
parameter_list|,
name|HB_UShort
name|format1
parameter_list|,
name|HB_UShort
name|format2
parameter_list|,
name|HB_Stream
name|stream
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_UShort
name|n
decl_stmt|,
name|m
decl_stmt|,
name|count
decl_stmt|;
name|HB_UInt
name|cur_offset
decl_stmt|,
name|new_offset
decl_stmt|,
name|base_offset
decl_stmt|;
name|HB_PairSet
modifier|*
name|ps
decl_stmt|;
name|base_offset
operator|=
name|FILE_Pos
argument_list|()
operator|-
literal|8L
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
return|return
name|error
return|;
name|count
operator|=
name|ppf1
operator|->
name|PairSetCount
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|ppf1
operator|->
name|PairSet
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|ppf1
operator|->
name|PairSet
argument_list|,
name|count
argument_list|,
name|HB_PairSet
argument_list|)
condition|)
return|return
name|error
return|;
name|ps
operator|=
name|ppf1
operator|->
name|PairSet
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
operator|+
name|base_offset
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|Load_PairSet
argument_list|(
operator|&
name|ps
index|[
name|n
index|]
argument_list|,
name|format1
argument_list|,
name|format2
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
goto|goto
name|Fail
goto|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
block|}
return|return
name|HB_Err_Ok
return|;
name|Fail
label|:
for|for
control|(
name|m
operator|=
literal|0
init|;
name|m
operator|<
name|n
condition|;
name|m
operator|++
control|)
name|Free_PairSet
argument_list|(
operator|&
name|ps
index|[
name|m
index|]
argument_list|,
name|format1
argument_list|,
name|format2
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|ps
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_function
DECL|function|Free_PairPos1
specifier|static
name|void
name|Free_PairPos1
parameter_list|(
name|HB_PairPosFormat1
modifier|*
name|ppf1
parameter_list|,
name|HB_UShort
name|format1
parameter_list|,
name|HB_UShort
name|format2
parameter_list|)
block|{
name|HB_UShort
name|n
decl_stmt|,
name|count
decl_stmt|;
name|HB_PairSet
modifier|*
name|ps
decl_stmt|;
if|if
condition|(
name|ppf1
operator|->
name|PairSet
condition|)
block|{
name|count
operator|=
name|ppf1
operator|->
name|PairSetCount
expr_stmt|;
name|ps
operator|=
name|ppf1
operator|->
name|PairSet
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
name|Free_PairSet
argument_list|(
operator|&
name|ps
index|[
name|n
index|]
argument_list|,
name|format1
argument_list|,
name|format2
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|ps
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/* PairPosFormat2 */
end_comment
begin_function
DECL|function|Load_PairPos2
specifier|static
name|HB_Error
name|Load_PairPos2
parameter_list|(
name|HB_PairPosFormat2
modifier|*
name|ppf2
parameter_list|,
name|HB_UShort
name|format1
parameter_list|,
name|HB_UShort
name|format2
parameter_list|,
name|HB_Stream
name|stream
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_UShort
name|m
decl_stmt|,
name|n
decl_stmt|,
name|k
decl_stmt|,
name|count1
decl_stmt|,
name|count2
decl_stmt|;
name|HB_UInt
name|cur_offset
decl_stmt|,
name|new_offset1
decl_stmt|,
name|new_offset2
decl_stmt|,
name|base_offset
decl_stmt|;
name|HB_Class1Record
modifier|*
name|c1r
decl_stmt|;
name|HB_Class2Record
modifier|*
name|c2r
decl_stmt|;
name|base_offset
operator|=
name|FILE_Pos
argument_list|()
operator|-
literal|8L
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|8L
argument_list|)
condition|)
return|return
name|error
return|;
name|new_offset1
operator|=
name|GET_UShort
argument_list|()
operator|+
name|base_offset
expr_stmt|;
name|new_offset2
operator|=
name|GET_UShort
argument_list|()
operator|+
name|base_offset
expr_stmt|;
comment|/* `Class1Count' and `Class2Count' are the upper limits for class      values, thus we read it now to make additional safety checks.  */
name|count1
operator|=
name|ppf2
operator|->
name|Class1Count
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|count2
operator|=
name|ppf2
operator|->
name|Class2Count
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset1
argument_list|)
operator|||
operator|(
name|error
operator|=
name|_HB_OPEN_Load_ClassDefinition
argument_list|(
operator|&
name|ppf2
operator|->
name|ClassDef1
argument_list|,
name|count1
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
return|return
name|error
return|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset2
argument_list|)
operator|||
operator|(
name|error
operator|=
name|_HB_OPEN_Load_ClassDefinition
argument_list|(
operator|&
name|ppf2
operator|->
name|ClassDef2
argument_list|,
name|count2
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
goto|goto
name|Fail3
goto|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
name|ppf2
operator|->
name|Class1Record
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|ppf2
operator|->
name|Class1Record
argument_list|,
name|count1
argument_list|,
name|HB_Class1Record
argument_list|)
condition|)
goto|goto
name|Fail2
goto|;
name|c1r
operator|=
name|ppf2
operator|->
name|Class1Record
expr_stmt|;
for|for
control|(
name|m
operator|=
literal|0
init|;
name|m
operator|<
name|count1
condition|;
name|m
operator|++
control|)
block|{
name|c1r
index|[
name|m
index|]
operator|.
name|Class2Record
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|c1r
index|[
name|m
index|]
operator|.
name|Class2Record
argument_list|,
name|count2
argument_list|,
name|HB_Class2Record
argument_list|)
condition|)
goto|goto
name|Fail1
goto|;
name|c2r
operator|=
name|c1r
index|[
name|m
index|]
operator|.
name|Class2Record
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count2
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|format1
condition|)
block|{
name|error
operator|=
name|Load_ValueRecord
argument_list|(
operator|&
name|c2r
index|[
name|n
index|]
operator|.
name|Value1
argument_list|,
name|format1
argument_list|,
name|base_offset
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Fail0
goto|;
block|}
if|if
condition|(
name|format2
condition|)
block|{
name|error
operator|=
name|Load_ValueRecord
argument_list|(
operator|&
name|c2r
index|[
name|n
index|]
operator|.
name|Value2
argument_list|,
name|format2
argument_list|,
name|base_offset
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|format1
condition|)
name|Free_ValueRecord
argument_list|(
operator|&
name|c2r
index|[
name|n
index|]
operator|.
name|Value1
argument_list|,
name|format1
argument_list|)
expr_stmt|;
goto|goto
name|Fail0
goto|;
block|}
block|}
block|}
continue|continue;
name|Fail0
label|:
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|n
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|format1
condition|)
name|Free_ValueRecord
argument_list|(
operator|&
name|c2r
index|[
name|k
index|]
operator|.
name|Value1
argument_list|,
name|format1
argument_list|)
expr_stmt|;
if|if
condition|(
name|format2
condition|)
name|Free_ValueRecord
argument_list|(
operator|&
name|c2r
index|[
name|k
index|]
operator|.
name|Value2
argument_list|,
name|format2
argument_list|)
expr_stmt|;
block|}
goto|goto
name|Fail1
goto|;
block|}
return|return
name|HB_Err_Ok
return|;
name|Fail1
label|:
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|m
condition|;
name|k
operator|++
control|)
block|{
name|c2r
operator|=
name|c1r
index|[
name|k
index|]
operator|.
name|Class2Record
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count2
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|format1
condition|)
name|Free_ValueRecord
argument_list|(
operator|&
name|c2r
index|[
name|n
index|]
operator|.
name|Value1
argument_list|,
name|format1
argument_list|)
expr_stmt|;
if|if
condition|(
name|format2
condition|)
name|Free_ValueRecord
argument_list|(
operator|&
name|c2r
index|[
name|n
index|]
operator|.
name|Value2
argument_list|,
name|format2
argument_list|)
expr_stmt|;
block|}
name|FREE
argument_list|(
name|c2r
argument_list|)
expr_stmt|;
block|}
name|FREE
argument_list|(
name|c1r
argument_list|)
expr_stmt|;
name|Fail2
label|:
name|_HB_OPEN_Free_ClassDefinition
argument_list|(
operator|&
name|ppf2
operator|->
name|ClassDef2
argument_list|)
expr_stmt|;
name|Fail3
label|:
name|_HB_OPEN_Free_ClassDefinition
argument_list|(
operator|&
name|ppf2
operator|->
name|ClassDef1
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_function
DECL|function|Free_PairPos2
specifier|static
name|void
name|Free_PairPos2
parameter_list|(
name|HB_PairPosFormat2
modifier|*
name|ppf2
parameter_list|,
name|HB_UShort
name|format1
parameter_list|,
name|HB_UShort
name|format2
parameter_list|)
block|{
name|HB_UShort
name|m
decl_stmt|,
name|n
decl_stmt|,
name|count1
decl_stmt|,
name|count2
decl_stmt|;
name|HB_Class1Record
modifier|*
name|c1r
decl_stmt|;
name|HB_Class2Record
modifier|*
name|c2r
decl_stmt|;
if|if
condition|(
name|ppf2
operator|->
name|Class1Record
condition|)
block|{
name|c1r
operator|=
name|ppf2
operator|->
name|Class1Record
expr_stmt|;
name|count1
operator|=
name|ppf2
operator|->
name|Class1Count
expr_stmt|;
name|count2
operator|=
name|ppf2
operator|->
name|Class2Count
expr_stmt|;
for|for
control|(
name|m
operator|=
literal|0
init|;
name|m
operator|<
name|count1
condition|;
name|m
operator|++
control|)
block|{
name|c2r
operator|=
name|c1r
index|[
name|m
index|]
operator|.
name|Class2Record
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count2
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|format1
condition|)
name|Free_ValueRecord
argument_list|(
operator|&
name|c2r
index|[
name|n
index|]
operator|.
name|Value1
argument_list|,
name|format1
argument_list|)
expr_stmt|;
if|if
condition|(
name|format2
condition|)
name|Free_ValueRecord
argument_list|(
operator|&
name|c2r
index|[
name|n
index|]
operator|.
name|Value2
argument_list|,
name|format2
argument_list|)
expr_stmt|;
block|}
name|FREE
argument_list|(
name|c2r
argument_list|)
expr_stmt|;
block|}
name|FREE
argument_list|(
name|c1r
argument_list|)
expr_stmt|;
name|_HB_OPEN_Free_ClassDefinition
argument_list|(
operator|&
name|ppf2
operator|->
name|ClassDef2
argument_list|)
expr_stmt|;
name|_HB_OPEN_Free_ClassDefinition
argument_list|(
operator|&
name|ppf2
operator|->
name|ClassDef1
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|Load_PairPos
specifier|static
name|HB_Error
name|Load_PairPos
parameter_list|(
name|HB_GPOS_SubTable
modifier|*
name|st
parameter_list|,
name|HB_Stream
name|stream
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_PairPos
modifier|*
name|pp
init|=
operator|&
name|st
operator|->
name|pair
decl_stmt|;
name|HB_UShort
name|format1
decl_stmt|,
name|format2
decl_stmt|;
name|HB_UInt
name|cur_offset
decl_stmt|,
name|new_offset
decl_stmt|,
name|base_offset
decl_stmt|;
name|base_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|8L
argument_list|)
condition|)
return|return
name|error
return|;
name|pp
operator|->
name|PosFormat
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
operator|+
name|base_offset
expr_stmt|;
name|format1
operator|=
name|pp
operator|->
name|ValueFormat1
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|format2
operator|=
name|pp
operator|->
name|ValueFormat2
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|_HB_OPEN_Load_Coverage
argument_list|(
operator|&
name|pp
operator|->
name|Coverage
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
return|return
name|error
return|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pp
operator|->
name|PosFormat
condition|)
block|{
case|case
literal|1
case|:
name|error
operator|=
name|Load_PairPos1
argument_list|(
operator|&
name|pp
operator|->
name|ppf
operator|.
name|ppf1
argument_list|,
name|format1
argument_list|,
name|format2
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Fail
goto|;
break|break;
case|case
literal|2
case|:
name|error
operator|=
name|Load_PairPos2
argument_list|(
operator|&
name|pp
operator|->
name|ppf
operator|.
name|ppf2
argument_list|,
name|format1
argument_list|,
name|format2
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|Fail
goto|;
break|break;
default|default:
return|return
name|ERR
argument_list|(
name|HB_Err_Invalid_SubTable_Format
argument_list|)
return|;
block|}
return|return
name|HB_Err_Ok
return|;
name|Fail
label|:
name|_HB_OPEN_Free_Coverage
argument_list|(
operator|&
name|pp
operator|->
name|Coverage
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_function
DECL|function|Free_PairPos
specifier|static
name|void
name|Free_PairPos
parameter_list|(
name|HB_GPOS_SubTable
modifier|*
name|st
parameter_list|)
block|{
name|HB_UShort
name|format1
decl_stmt|,
name|format2
decl_stmt|;
name|HB_PairPos
modifier|*
name|pp
init|=
operator|&
name|st
operator|->
name|pair
decl_stmt|;
name|format1
operator|=
name|pp
operator|->
name|ValueFormat1
expr_stmt|;
name|format2
operator|=
name|pp
operator|->
name|ValueFormat2
expr_stmt|;
switch|switch
condition|(
name|pp
operator|->
name|PosFormat
condition|)
block|{
case|case
literal|1
case|:
name|Free_PairPos1
argument_list|(
operator|&
name|pp
operator|->
name|ppf
operator|.
name|ppf1
argument_list|,
name|format1
argument_list|,
name|format2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|Free_PairPos2
argument_list|(
operator|&
name|pp
operator|->
name|ppf
operator|.
name|ppf2
argument_list|,
name|format1
argument_list|,
name|format2
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|_HB_OPEN_Free_Coverage
argument_list|(
operator|&
name|pp
operator|->
name|Coverage
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|Lookup_PairPos1
specifier|static
name|HB_Error
name|Lookup_PairPos1
parameter_list|(
name|GPOS_Instance
modifier|*
name|gpi
parameter_list|,
name|HB_PairPosFormat1
modifier|*
name|ppf1
parameter_list|,
name|HB_Buffer
name|buffer
parameter_list|,
name|HB_UInt
name|first_pos
parameter_list|,
name|HB_UShort
name|index
parameter_list|,
name|HB_UShort
name|format1
parameter_list|,
name|HB_UShort
name|format2
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_UShort
name|numpvr
decl_stmt|,
name|glyph2
decl_stmt|;
name|HB_PairValueRecord
modifier|*
name|pvr
decl_stmt|;
if|if
condition|(
name|index
operator|>=
name|ppf1
operator|->
name|PairSetCount
condition|)
return|return
name|ERR
argument_list|(
name|HB_Err_Invalid_SubTable
argument_list|)
return|;
name|pvr
operator|=
name|ppf1
operator|->
name|PairSet
index|[
name|index
index|]
operator|.
name|PairValueRecord
expr_stmt|;
if|if
condition|(
operator|!
name|pvr
condition|)
return|return
name|ERR
argument_list|(
name|HB_Err_Invalid_SubTable
argument_list|)
return|;
name|glyph2
operator|=
name|IN_CURGLYPH
argument_list|()
expr_stmt|;
for|for
control|(
name|numpvr
operator|=
name|ppf1
operator|->
name|PairSet
index|[
name|index
index|]
operator|.
name|PairValueCount
init|;
name|numpvr
condition|;
name|numpvr
operator|--
operator|,
name|pvr
operator|++
control|)
block|{
if|if
condition|(
name|glyph2
operator|==
name|pvr
operator|->
name|SecondGlyph
condition|)
block|{
name|error
operator|=
name|Get_ValueRecord
argument_list|(
name|gpi
argument_list|,
operator|&
name|pvr
operator|->
name|Value1
argument_list|,
name|format1
argument_list|,
name|POSITION
argument_list|(
name|first_pos
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
return|return
name|Get_ValueRecord
argument_list|(
name|gpi
argument_list|,
operator|&
name|pvr
operator|->
name|Value2
argument_list|,
name|format2
argument_list|,
name|POSITION
argument_list|(
name|buffer
operator|->
name|in_pos
argument_list|)
argument_list|)
return|;
block|}
block|}
return|return
name|HB_Err_Not_Covered
return|;
block|}
end_function
begin_function
DECL|function|Lookup_PairPos2
specifier|static
name|HB_Error
name|Lookup_PairPos2
parameter_list|(
name|GPOS_Instance
modifier|*
name|gpi
parameter_list|,
name|HB_PairPosFormat2
modifier|*
name|ppf2
parameter_list|,
name|HB_Buffer
name|buffer
parameter_list|,
name|HB_UInt
name|first_pos
parameter_list|,
name|HB_UShort
name|format1
parameter_list|,
name|HB_UShort
name|format2
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_UShort
name|cl1
init|=
literal|0
decl_stmt|,
name|cl2
init|=
literal|0
decl_stmt|;
comment|/* shut compiler up */
name|HB_Class1Record
modifier|*
name|c1r
decl_stmt|;
name|HB_Class2Record
modifier|*
name|c2r
decl_stmt|;
name|error
operator|=
name|_HB_OPEN_Get_Class
argument_list|(
operator|&
name|ppf2
operator|->
name|ClassDef1
argument_list|,
name|IN_GLYPH
argument_list|(
name|first_pos
argument_list|)
argument_list|,
operator|&
name|cl1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|HB_Err_Not_Covered
condition|)
return|return
name|error
return|;
name|error
operator|=
name|_HB_OPEN_Get_Class
argument_list|(
operator|&
name|ppf2
operator|->
name|ClassDef2
argument_list|,
name|IN_CURGLYPH
argument_list|()
argument_list|,
operator|&
name|cl2
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|HB_Err_Not_Covered
condition|)
return|return
name|error
return|;
name|c1r
operator|=
operator|&
name|ppf2
operator|->
name|Class1Record
index|[
name|cl1
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|c1r
condition|)
return|return
name|ERR
argument_list|(
name|HB_Err_Invalid_SubTable
argument_list|)
return|;
name|c2r
operator|=
operator|&
name|c1r
operator|->
name|Class2Record
index|[
name|cl2
index|]
expr_stmt|;
name|error
operator|=
name|Get_ValueRecord
argument_list|(
name|gpi
argument_list|,
operator|&
name|c2r
operator|->
name|Value1
argument_list|,
name|format1
argument_list|,
name|POSITION
argument_list|(
name|first_pos
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
return|return
name|Get_ValueRecord
argument_list|(
name|gpi
argument_list|,
operator|&
name|c2r
operator|->
name|Value2
argument_list|,
name|format2
argument_list|,
name|POSITION
argument_list|(
name|buffer
operator|->
name|in_pos
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|Lookup_PairPos
specifier|static
name|HB_Error
name|Lookup_PairPos
parameter_list|(
name|GPOS_Instance
modifier|*
name|gpi
parameter_list|,
name|HB_GPOS_SubTable
modifier|*
name|st
parameter_list|,
name|HB_Buffer
name|buffer
parameter_list|,
name|HB_UShort
name|flags
parameter_list|,
name|HB_UShort
name|context_length
parameter_list|,
name|int
name|nesting_level
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_UShort
name|index
decl_stmt|,
name|property
decl_stmt|;
name|HB_UInt
name|first_pos
decl_stmt|;
name|HB_GPOSHeader
modifier|*
name|gpos
init|=
name|gpi
operator|->
name|gpos
decl_stmt|;
name|HB_PairPos
modifier|*
name|pp
init|=
operator|&
name|st
operator|->
name|pair
decl_stmt|;
name|HB_UNUSED
argument_list|(
name|nesting_level
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
operator|->
name|in_pos
operator|>=
name|buffer
operator|->
name|in_length
operator|-
literal|1
condition|)
return|return
name|HB_Err_Not_Covered
return|;
comment|/* Not enough glyphs in stream */
if|if
condition|(
name|context_length
operator|!=
literal|0xFFFF
operator|&&
name|context_length
operator|<
literal|2
condition|)
return|return
name|HB_Err_Not_Covered
return|;
if|if
condition|(
name|CHECK_Property
argument_list|(
name|gpos
operator|->
name|gdef
argument_list|,
name|IN_CURITEM
argument_list|()
argument_list|,
name|flags
argument_list|,
operator|&
name|property
argument_list|)
condition|)
return|return
name|error
return|;
name|error
operator|=
name|_HB_OPEN_Coverage_Index
argument_list|(
operator|&
name|pp
operator|->
name|Coverage
argument_list|,
name|IN_CURGLYPH
argument_list|()
argument_list|,
operator|&
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
comment|/* second glyph */
name|first_pos
operator|=
name|buffer
operator|->
name|in_pos
expr_stmt|;
operator|(
name|buffer
operator|->
name|in_pos
operator|)
operator|++
expr_stmt|;
while|while
condition|(
name|CHECK_Property
argument_list|(
name|gpos
operator|->
name|gdef
argument_list|,
name|IN_CURITEM
argument_list|()
argument_list|,
name|flags
argument_list|,
operator|&
name|property
argument_list|)
condition|)
block|{
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|HB_Err_Not_Covered
condition|)
return|return
name|error
return|;
if|if
condition|(
name|buffer
operator|->
name|in_pos
operator|==
name|buffer
operator|->
name|in_length
condition|)
block|{
name|buffer
operator|->
name|in_pos
operator|=
name|first_pos
expr_stmt|;
return|return
name|HB_Err_Not_Covered
return|;
block|}
operator|(
name|buffer
operator|->
name|in_pos
operator|)
operator|++
expr_stmt|;
block|}
switch|switch
condition|(
name|pp
operator|->
name|PosFormat
condition|)
block|{
case|case
literal|1
case|:
name|error
operator|=
name|Lookup_PairPos1
argument_list|(
name|gpi
argument_list|,
operator|&
name|pp
operator|->
name|ppf
operator|.
name|ppf1
argument_list|,
name|buffer
argument_list|,
name|first_pos
argument_list|,
name|index
argument_list|,
name|pp
operator|->
name|ValueFormat1
argument_list|,
name|pp
operator|->
name|ValueFormat2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|error
operator|=
name|Lookup_PairPos2
argument_list|(
name|gpi
argument_list|,
operator|&
name|pp
operator|->
name|ppf
operator|.
name|ppf2
argument_list|,
name|buffer
argument_list|,
name|first_pos
argument_list|,
name|pp
operator|->
name|ValueFormat1
argument_list|,
name|pp
operator|->
name|ValueFormat2
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
name|ERR
argument_list|(
name|HB_Err_Invalid_SubTable_Format
argument_list|)
return|;
block|}
comment|/* if we don't have coverage for the second glyph don't skip it for      further lookups but reset in_pos back to the first_glyph and let      the caller in Do_String_Lookup increment in_pos */
if|if
condition|(
name|error
operator|==
name|HB_Err_Not_Covered
condition|)
name|buffer
operator|->
name|in_pos
operator|=
name|first_pos
expr_stmt|;
comment|/* adjusting the `next' glyph */
if|if
condition|(
name|pp
operator|->
name|ValueFormat2
condition|)
operator|(
name|buffer
operator|->
name|in_pos
operator|)
operator|++
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_comment
comment|/* LookupType 3 */
end_comment
begin_comment
comment|/* CursivePosFormat1 */
end_comment
begin_function
DECL|function|Load_CursivePos
specifier|static
name|HB_Error
name|Load_CursivePos
parameter_list|(
name|HB_GPOS_SubTable
modifier|*
name|st
parameter_list|,
name|HB_Stream
name|stream
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_CursivePos
modifier|*
name|cp
init|=
operator|&
name|st
operator|->
name|cursive
decl_stmt|;
name|HB_UShort
name|n
decl_stmt|,
name|m
decl_stmt|,
name|count
decl_stmt|;
name|HB_UInt
name|cur_offset
decl_stmt|,
name|new_offset
decl_stmt|,
name|base_offset
decl_stmt|;
name|HB_EntryExitRecord
modifier|*
name|eer
decl_stmt|;
name|base_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|4L
argument_list|)
condition|)
return|return
name|error
return|;
name|cp
operator|->
name|PosFormat
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
operator|+
name|base_offset
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|_HB_OPEN_Load_Coverage
argument_list|(
operator|&
name|cp
operator|->
name|Coverage
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
return|return
name|error
return|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail2
goto|;
name|count
operator|=
name|cp
operator|->
name|EntryExitCount
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cp
operator|->
name|EntryExitRecord
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|cp
operator|->
name|EntryExitRecord
argument_list|,
name|count
argument_list|,
name|HB_EntryExitRecord
argument_list|)
condition|)
goto|goto
name|Fail2
goto|;
name|eer
operator|=
name|cp
operator|->
name|EntryExitRecord
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
block|{
name|HB_UInt
name|entry_offset
decl_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
return|return
name|error
return|;
name|entry_offset
operator|=
name|new_offset
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
if|if
condition|(
name|new_offset
condition|)
block|{
name|new_offset
operator|+=
name|base_offset
expr_stmt|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|Load_Anchor
argument_list|(
operator|&
name|eer
index|[
name|n
index|]
operator|.
name|EntryAnchor
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
goto|goto
name|Fail1
goto|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
block|}
else|else
name|eer
index|[
name|n
index|]
operator|.
name|EntryAnchor
operator|.
name|PosFormat
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
return|return
name|error
return|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
if|if
condition|(
name|new_offset
condition|)
block|{
name|new_offset
operator|+=
name|base_offset
expr_stmt|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|Load_Anchor
argument_list|(
operator|&
name|eer
index|[
name|n
index|]
operator|.
name|ExitAnchor
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
block|{
if|if
condition|(
name|entry_offset
condition|)
name|Free_Anchor
argument_list|(
operator|&
name|eer
index|[
name|n
index|]
operator|.
name|EntryAnchor
argument_list|)
expr_stmt|;
goto|goto
name|Fail1
goto|;
block|}
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
block|}
else|else
name|eer
index|[
name|n
index|]
operator|.
name|ExitAnchor
operator|.
name|PosFormat
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|HB_Err_Ok
return|;
name|Fail1
label|:
for|for
control|(
name|m
operator|=
literal|0
init|;
name|m
operator|<
name|n
condition|;
name|m
operator|++
control|)
block|{
name|Free_Anchor
argument_list|(
operator|&
name|eer
index|[
name|m
index|]
operator|.
name|EntryAnchor
argument_list|)
expr_stmt|;
name|Free_Anchor
argument_list|(
operator|&
name|eer
index|[
name|m
index|]
operator|.
name|ExitAnchor
argument_list|)
expr_stmt|;
block|}
name|FREE
argument_list|(
name|eer
argument_list|)
expr_stmt|;
name|Fail2
label|:
name|_HB_OPEN_Free_Coverage
argument_list|(
operator|&
name|cp
operator|->
name|Coverage
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_function
DECL|function|Free_CursivePos
specifier|static
name|void
name|Free_CursivePos
parameter_list|(
name|HB_GPOS_SubTable
modifier|*
name|st
parameter_list|)
block|{
name|HB_UShort
name|n
decl_stmt|,
name|count
decl_stmt|;
name|HB_CursivePos
modifier|*
name|cp
init|=
operator|&
name|st
operator|->
name|cursive
decl_stmt|;
name|HB_EntryExitRecord
modifier|*
name|eer
decl_stmt|;
if|if
condition|(
name|cp
operator|->
name|EntryExitRecord
condition|)
block|{
name|count
operator|=
name|cp
operator|->
name|EntryExitCount
expr_stmt|;
name|eer
operator|=
name|cp
operator|->
name|EntryExitRecord
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
block|{
name|Free_Anchor
argument_list|(
operator|&
name|eer
index|[
name|n
index|]
operator|.
name|EntryAnchor
argument_list|)
expr_stmt|;
name|Free_Anchor
argument_list|(
operator|&
name|eer
index|[
name|n
index|]
operator|.
name|ExitAnchor
argument_list|)
expr_stmt|;
block|}
name|FREE
argument_list|(
name|eer
argument_list|)
expr_stmt|;
block|}
name|_HB_OPEN_Free_Coverage
argument_list|(
operator|&
name|cp
operator|->
name|Coverage
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|Lookup_CursivePos
specifier|static
name|HB_Error
name|Lookup_CursivePos
parameter_list|(
name|GPOS_Instance
modifier|*
name|gpi
parameter_list|,
name|HB_GPOS_SubTable
modifier|*
name|st
parameter_list|,
name|HB_Buffer
name|buffer
parameter_list|,
name|HB_UShort
name|flags
parameter_list|,
name|HB_UShort
name|context_length
parameter_list|,
name|int
name|nesting_level
parameter_list|)
block|{
name|HB_UShort
name|index
decl_stmt|,
name|property
decl_stmt|;
name|HB_Error
name|error
decl_stmt|;
name|HB_GPOSHeader
modifier|*
name|gpos
init|=
name|gpi
operator|->
name|gpos
decl_stmt|;
name|HB_CursivePos
modifier|*
name|cp
init|=
operator|&
name|st
operator|->
name|cursive
decl_stmt|;
name|HB_EntryExitRecord
modifier|*
name|eer
decl_stmt|;
name|HB_Fixed
name|entry_x
decl_stmt|,
name|entry_y
decl_stmt|;
name|HB_Fixed
name|exit_x
decl_stmt|,
name|exit_y
decl_stmt|;
name|HB_UNUSED
argument_list|(
name|nesting_level
argument_list|)
expr_stmt|;
if|if
condition|(
name|context_length
operator|!=
literal|0xFFFF
operator|&&
name|context_length
operator|<
literal|1
condition|)
block|{
name|gpi
operator|->
name|last
operator|=
literal|0xFFFF
expr_stmt|;
return|return
name|HB_Err_Not_Covered
return|;
block|}
comment|/* Glyphs not having the right GDEF properties will be ignored, i.e.,      gpi->last won't be reset (contrary to user defined properties). */
if|if
condition|(
name|CHECK_Property
argument_list|(
name|gpos
operator|->
name|gdef
argument_list|,
name|IN_CURITEM
argument_list|()
argument_list|,
name|flags
argument_list|,
operator|&
name|property
argument_list|)
condition|)
return|return
name|error
return|;
comment|/* We don't handle mark glyphs here.  According to Andrei, this isn't      possible, but who knows...                                         */
if|if
condition|(
name|property
operator|==
name|HB_GDEF_MARK
condition|)
block|{
name|gpi
operator|->
name|last
operator|=
literal|0xFFFF
expr_stmt|;
return|return
name|HB_Err_Not_Covered
return|;
block|}
name|error
operator|=
name|_HB_OPEN_Coverage_Index
argument_list|(
operator|&
name|cp
operator|->
name|Coverage
argument_list|,
name|IN_CURGLYPH
argument_list|()
argument_list|,
operator|&
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|gpi
operator|->
name|last
operator|=
literal|0xFFFF
expr_stmt|;
return|return
name|error
return|;
block|}
if|if
condition|(
name|index
operator|>=
name|cp
operator|->
name|EntryExitCount
condition|)
return|return
name|ERR
argument_list|(
name|HB_Err_Invalid_SubTable
argument_list|)
return|;
name|eer
operator|=
operator|&
name|cp
operator|->
name|EntryExitRecord
index|[
name|index
index|]
expr_stmt|;
comment|/* Now comes the messiest part of the whole OpenType      specification.  At first glance, cursive connections seem easy      to understand, but there are pitfalls!  The reason is that      the specs don't mention how to compute the advance values      resp. glyph offsets.  I was told it would be an omission, to      be fixed in the next OpenType version...  Again many thanks to      Andrei Burago<andreib@microsoft.com> for clarifications.       Consider the following example:  		      |  xadv1    | 		       +---------+ 		       |         | 		 +-----+--+ 1    | 		 |     | .|      | 		 |    0+--+------+ 		 |   2    | 		 |        | 		0+--------+ 		|  xadv2   |         glyph1: advance width = 12 	       anchor point = (3,1)         glyph2: advance width = 11 	       anchor point = (9,4)         LSB is 1 for both glyphs (so the boxes drawn above are glyph        bboxes).  Writing direction is R2L; `0' denotes the glyph's        coordinate origin.       Now the surprising part: The advance width of the *left* glyph      (resp. of the *bottom* glyph) will be modified, no matter      whether the writing direction is L2R or R2L (resp. T2B or      B2T)!  This assymetry is caused by the fact that the glyph's      coordinate origin is always the lower left corner for all      writing directions.       Continuing the above example, we can compute the new      (horizontal) advance width of glyph2 as         9 - 3 = 6  ,       and the new vertical offset of glyph2 as         1 - 4 = -3  .        Vertical writing direction is far more complicated:       a) Assuming that we recompute the advance height of the lower glyph:  				  -- 		       +---------+ 	      --       |         | 		 +-----+--+ 1    | yadv1 		 |     | .|      | 	   yadv2 |    0+--+------+        -- BSB1  -- 		 |   2    |       --      --        y_offset 		 |        |    BSB2 --      0+--------+                        -- 	--    --         glyph1: advance height = 6 	       anchor point = (3,1)         glyph2: advance height = 7 	       anchor point = (9,4)         TSB is 1 for both glyphs; writing direction is T2B.   	 BSB1     = yadv1 - (TSB1 + ymax1) 	 BSB2     = yadv2 - (TSB2 + ymax2) 	 y_offset = y2 - y1         vertical advance width of glyph2 	 = y_offset + BSB2 - BSB1 	 = (y2 - y1) + (yadv2 - (TSB2 + ymax2)) - (yadv1 - (TSB1 + ymax1)) 	 = y2 - y1 + yadv2 - TSB2 - ymax2 - (yadv1 - TSB1 - ymax1) 	 = y2 - y1 + yadv2 - TSB2 - ymax2 - yadv1 + TSB1 + ymax1        b) Assuming that we recompute the advance height of the upper glyph:  				  --      -- 		       +---------+        -- TSB1 	--    --       |         |    TSB2 --       +-----+--+ 1    | yadv1   ymax1 		 |     | .|      | 	   yadv2 |    0+--+------+        --       --     ymax2        |   2    |       --                y_offset 		 |        | 	--      0+--------+                        -- 	      --         glyph1: advance height = 6 	       anchor point = (3,1)         glyph2: advance height = 7 	       anchor point = (9,4)         TSB is 1 for both glyphs; writing direction is T2B.         y_offset = y2 - y1         vertical advance width of glyph2 	 = TSB1 + ymax1 + y_offset - (TSB2 + ymax2) 	 = TSB1 + ymax1 + y2 - y1 - TSB2 - ymax2        Comparing a) with b) shows that b) is easier to compute.  I'll wait      for a reply from Andrei to see what should really be implemented...       Since horizontal advance widths or vertical advance heights      can be used alone but not together, no ambiguity occurs.        */
if|if
condition|(
name|gpi
operator|->
name|last
operator|==
literal|0xFFFF
condition|)
goto|goto
name|end
goto|;
comment|/* Get_Anchor() returns HB_Err_Not_Covered if there is no anchor      table.                                                         */
name|error
operator|=
name|Get_Anchor
argument_list|(
name|gpi
argument_list|,
operator|&
name|eer
operator|->
name|EntryAnchor
argument_list|,
name|IN_CURGLYPH
argument_list|()
argument_list|,
operator|&
name|entry_x
argument_list|,
operator|&
name|entry_y
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|HB_Err_Not_Covered
condition|)
goto|goto
name|end
goto|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
name|gpi
operator|->
name|r2l
condition|)
block|{
name|POSITION
argument_list|(
name|buffer
operator|->
name|in_pos
argument_list|)
operator|->
name|x_advance
operator|=
name|entry_x
operator|-
name|gpi
operator|->
name|anchor_x
expr_stmt|;
name|POSITION
argument_list|(
name|buffer
operator|->
name|in_pos
argument_list|)
operator|->
name|new_advance
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|POSITION
argument_list|(
name|gpi
operator|->
name|last
argument_list|)
operator|->
name|x_advance
operator|=
name|gpi
operator|->
name|anchor_x
operator|-
name|entry_x
expr_stmt|;
name|POSITION
argument_list|(
name|gpi
operator|->
name|last
argument_list|)
operator|->
name|new_advance
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|HB_LOOKUP_FLAG_RIGHT_TO_LEFT
condition|)
block|{
name|POSITION
argument_list|(
name|gpi
operator|->
name|last
argument_list|)
operator|->
name|cursive_chain
operator|=
name|gpi
operator|->
name|last
operator|-
name|buffer
operator|->
name|in_pos
expr_stmt|;
name|POSITION
argument_list|(
name|gpi
operator|->
name|last
argument_list|)
operator|->
name|y_pos
operator|=
name|entry_y
operator|-
name|gpi
operator|->
name|anchor_y
expr_stmt|;
block|}
else|else
block|{
name|POSITION
argument_list|(
name|buffer
operator|->
name|in_pos
argument_list|)
operator|->
name|cursive_chain
operator|=
name|buffer
operator|->
name|in_pos
operator|-
name|gpi
operator|->
name|last
expr_stmt|;
name|POSITION
argument_list|(
name|buffer
operator|->
name|in_pos
argument_list|)
operator|->
name|y_pos
operator|=
name|gpi
operator|->
name|anchor_y
operator|-
name|entry_y
expr_stmt|;
block|}
name|end
label|:
name|error
operator|=
name|Get_Anchor
argument_list|(
name|gpi
argument_list|,
operator|&
name|eer
operator|->
name|ExitAnchor
argument_list|,
name|IN_CURGLYPH
argument_list|()
argument_list|,
operator|&
name|exit_x
argument_list|,
operator|&
name|exit_y
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|HB_Err_Not_Covered
condition|)
name|gpi
operator|->
name|last
operator|=
literal|0xFFFF
expr_stmt|;
else|else
block|{
name|gpi
operator|->
name|last
operator|=
name|buffer
operator|->
name|in_pos
expr_stmt|;
name|gpi
operator|->
name|anchor_x
operator|=
name|exit_x
expr_stmt|;
name|gpi
operator|->
name|anchor_y
operator|=
name|exit_y
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
operator|(
name|buffer
operator|->
name|in_pos
operator|)
operator|++
expr_stmt|;
return|return
name|HB_Err_Ok
return|;
block|}
end_function
begin_comment
comment|/* LookupType 4 */
end_comment
begin_comment
comment|/* BaseArray */
end_comment
begin_function
DECL|function|Load_BaseArray
specifier|static
name|HB_Error
name|Load_BaseArray
parameter_list|(
name|HB_BaseArray
modifier|*
name|ba
parameter_list|,
name|HB_UShort
name|num_classes
parameter_list|,
name|HB_Stream
name|stream
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_UShort
name|m
decl_stmt|,
name|n
decl_stmt|,
name|count
decl_stmt|;
name|HB_UInt
name|cur_offset
decl_stmt|,
name|new_offset
decl_stmt|,
name|base_offset
decl_stmt|;
name|HB_BaseRecord
modifier|*
name|br
decl_stmt|;
name|HB_Anchor
modifier|*
name|ban
decl_stmt|,
modifier|*
name|bans
decl_stmt|;
name|base_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
return|return
name|error
return|;
name|count
operator|=
name|ba
operator|->
name|BaseCount
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|ba
operator|->
name|BaseRecord
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|ba
operator|->
name|BaseRecord
argument_list|,
name|count
argument_list|,
name|HB_BaseRecord
argument_list|)
condition|)
return|return
name|error
return|;
name|br
operator|=
name|ba
operator|->
name|BaseRecord
expr_stmt|;
name|bans
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|bans
argument_list|,
name|count
operator|*
name|num_classes
argument_list|,
name|HB_Anchor
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
for|for
control|(
name|m
operator|=
literal|0
init|;
name|m
operator|<
name|count
condition|;
name|m
operator|++
control|)
block|{
name|br
index|[
name|m
index|]
operator|.
name|BaseAnchor
operator|=
name|NULL
expr_stmt|;
name|ban
operator|=
name|br
index|[
name|m
index|]
operator|.
name|BaseAnchor
operator|=
name|bans
operator|+
name|m
operator|*
name|num_classes
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|num_classes
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
operator|+
name|base_offset
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
if|if
condition|(
name|new_offset
operator|==
name|base_offset
condition|)
block|{
comment|/* XXX 	 * Doulos SIL Regular is buggy and has zero offsets here. 	 * Skip it 	 */
name|ban
index|[
name|n
index|]
operator|.
name|PosFormat
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|Load_Anchor
argument_list|(
operator|&
name|ban
index|[
name|n
index|]
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
goto|goto
name|Fail
goto|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|HB_Err_Ok
return|;
name|Fail
label|:
name|FREE
argument_list|(
name|bans
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|br
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_function
DECL|function|Free_BaseArray
specifier|static
name|void
name|Free_BaseArray
parameter_list|(
name|HB_BaseArray
modifier|*
name|ba
parameter_list|,
name|HB_UShort
name|num_classes
parameter_list|)
block|{
name|HB_BaseRecord
modifier|*
name|br
decl_stmt|;
name|HB_Anchor
modifier|*
name|bans
decl_stmt|;
if|if
condition|(
name|ba
operator|->
name|BaseRecord
condition|)
block|{
name|br
operator|=
name|ba
operator|->
name|BaseRecord
expr_stmt|;
if|if
condition|(
name|ba
operator|->
name|BaseCount
condition|)
block|{
name|HB_UShort
name|i
decl_stmt|,
name|count
decl_stmt|;
name|count
operator|=
name|num_classes
operator|*
name|ba
operator|->
name|BaseCount
expr_stmt|;
name|bans
operator|=
name|br
index|[
literal|0
index|]
operator|.
name|BaseAnchor
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
name|Free_Anchor
argument_list|(
operator|&
name|bans
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|bans
argument_list|)
expr_stmt|;
block|}
name|FREE
argument_list|(
name|br
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/* MarkBasePosFormat1 */
end_comment
begin_function
DECL|function|Load_MarkBasePos
specifier|static
name|HB_Error
name|Load_MarkBasePos
parameter_list|(
name|HB_GPOS_SubTable
modifier|*
name|st
parameter_list|,
name|HB_Stream
name|stream
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_MarkBasePos
modifier|*
name|mbp
init|=
operator|&
name|st
operator|->
name|markbase
decl_stmt|;
name|HB_UInt
name|cur_offset
decl_stmt|,
name|new_offset
decl_stmt|,
name|base_offset
decl_stmt|;
name|base_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|4L
argument_list|)
condition|)
return|return
name|error
return|;
name|mbp
operator|->
name|PosFormat
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
operator|+
name|base_offset
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
if|if
condition|(
name|mbp
operator|->
name|PosFormat
operator|!=
literal|1
condition|)
return|return
name|ERR
argument_list|(
name|HB_Err_Invalid_SubTable_Format
argument_list|)
return|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|_HB_OPEN_Load_Coverage
argument_list|(
operator|&
name|mbp
operator|->
name|MarkCoverage
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
return|return
name|error
return|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail3
goto|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
operator|+
name|base_offset
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|_HB_OPEN_Load_Coverage
argument_list|(
operator|&
name|mbp
operator|->
name|BaseCoverage
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
goto|goto
name|Fail3
goto|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|4L
argument_list|)
condition|)
goto|goto
name|Fail2
goto|;
name|mbp
operator|->
name|ClassCount
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
operator|+
name|base_offset
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|Load_MarkArray
argument_list|(
operator|&
name|mbp
operator|->
name|MarkArray
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
goto|goto
name|Fail2
goto|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail1
goto|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
operator|+
name|base_offset
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|Load_BaseArray
argument_list|(
operator|&
name|mbp
operator|->
name|BaseArray
argument_list|,
name|mbp
operator|->
name|ClassCount
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
goto|goto
name|Fail1
goto|;
return|return
name|HB_Err_Ok
return|;
name|Fail1
label|:
name|Free_MarkArray
argument_list|(
operator|&
name|mbp
operator|->
name|MarkArray
argument_list|)
expr_stmt|;
name|Fail2
label|:
name|_HB_OPEN_Free_Coverage
argument_list|(
operator|&
name|mbp
operator|->
name|BaseCoverage
argument_list|)
expr_stmt|;
name|Fail3
label|:
name|_HB_OPEN_Free_Coverage
argument_list|(
operator|&
name|mbp
operator|->
name|MarkCoverage
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_function
DECL|function|Free_MarkBasePos
specifier|static
name|void
name|Free_MarkBasePos
parameter_list|(
name|HB_GPOS_SubTable
modifier|*
name|st
parameter_list|)
block|{
name|HB_MarkBasePos
modifier|*
name|mbp
init|=
operator|&
name|st
operator|->
name|markbase
decl_stmt|;
name|Free_BaseArray
argument_list|(
operator|&
name|mbp
operator|->
name|BaseArray
argument_list|,
name|mbp
operator|->
name|ClassCount
argument_list|)
expr_stmt|;
name|Free_MarkArray
argument_list|(
operator|&
name|mbp
operator|->
name|MarkArray
argument_list|)
expr_stmt|;
name|_HB_OPEN_Free_Coverage
argument_list|(
operator|&
name|mbp
operator|->
name|BaseCoverage
argument_list|)
expr_stmt|;
name|_HB_OPEN_Free_Coverage
argument_list|(
operator|&
name|mbp
operator|->
name|MarkCoverage
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|Lookup_MarkBasePos
specifier|static
name|HB_Error
name|Lookup_MarkBasePos
parameter_list|(
name|GPOS_Instance
modifier|*
name|gpi
parameter_list|,
name|HB_GPOS_SubTable
modifier|*
name|st
parameter_list|,
name|HB_Buffer
name|buffer
parameter_list|,
name|HB_UShort
name|flags
parameter_list|,
name|HB_UShort
name|context_length
parameter_list|,
name|int
name|nesting_level
parameter_list|)
block|{
name|HB_UShort
name|i
decl_stmt|,
name|j
decl_stmt|,
name|mark_index
decl_stmt|,
name|base_index
decl_stmt|,
name|property
decl_stmt|,
name|class
decl_stmt|;
name|HB_Fixed
name|x_mark_value
decl_stmt|,
name|y_mark_value
decl_stmt|,
name|x_base_value
decl_stmt|,
name|y_base_value
decl_stmt|;
name|HB_Error
name|error
decl_stmt|;
name|HB_GPOSHeader
modifier|*
name|gpos
init|=
name|gpi
operator|->
name|gpos
decl_stmt|;
name|HB_MarkBasePos
modifier|*
name|mbp
init|=
operator|&
name|st
operator|->
name|markbase
decl_stmt|;
name|HB_MarkArray
modifier|*
name|ma
decl_stmt|;
name|HB_BaseArray
modifier|*
name|ba
decl_stmt|;
name|HB_BaseRecord
modifier|*
name|br
decl_stmt|;
name|HB_Anchor
modifier|*
name|mark_anchor
decl_stmt|;
name|HB_Anchor
modifier|*
name|base_anchor
decl_stmt|;
name|HB_Position
name|o
decl_stmt|;
name|HB_UNUSED
argument_list|(
name|nesting_level
argument_list|)
expr_stmt|;
if|if
condition|(
name|context_length
operator|!=
literal|0xFFFF
operator|&&
name|context_length
operator|<
literal|1
condition|)
return|return
name|HB_Err_Not_Covered
return|;
if|if
condition|(
name|flags
operator|&
name|HB_LOOKUP_FLAG_IGNORE_BASE_GLYPHS
condition|)
return|return
name|HB_Err_Not_Covered
return|;
if|if
condition|(
name|CHECK_Property
argument_list|(
name|gpos
operator|->
name|gdef
argument_list|,
name|IN_CURITEM
argument_list|()
argument_list|,
name|flags
argument_list|,
operator|&
name|property
argument_list|)
condition|)
return|return
name|error
return|;
name|error
operator|=
name|_HB_OPEN_Coverage_Index
argument_list|(
operator|&
name|mbp
operator|->
name|MarkCoverage
argument_list|,
name|IN_CURGLYPH
argument_list|()
argument_list|,
operator|&
name|mark_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
comment|/* now we search backwards for a non-mark glyph */
name|i
operator|=
literal|1
expr_stmt|;
name|j
operator|=
name|buffer
operator|->
name|in_pos
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|i
operator|<=
name|buffer
operator|->
name|in_pos
condition|)
block|{
name|error
operator|=
name|HB_GDEF_Get_Glyph_Property
argument_list|(
name|gpos
operator|->
name|gdef
argument_list|,
name|IN_GLYPH
argument_list|(
name|j
argument_list|)
argument_list|,
operator|&
name|property
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
operator|!
operator|(
name|property
operator|==
name|HB_GDEF_MARK
operator|||
name|property
operator|&
name|HB_LOOKUP_FLAG_IGNORE_SPECIAL_MARKS
operator|)
condition|)
break|break;
name|i
operator|++
expr_stmt|;
name|j
operator|--
expr_stmt|;
block|}
comment|/* The following assertion is too strong -- at least for mangal.ttf. */
if|#
directive|if
literal|0
block|if ( property != HB_GDEF_BASE_GLYPH )     return HB_Err_Not_Covered;
endif|#
directive|endif
if|if
condition|(
name|i
operator|>
name|buffer
operator|->
name|in_pos
condition|)
return|return
name|HB_Err_Not_Covered
return|;
name|error
operator|=
name|_HB_OPEN_Coverage_Index
argument_list|(
operator|&
name|mbp
operator|->
name|BaseCoverage
argument_list|,
name|IN_GLYPH
argument_list|(
name|j
argument_list|)
argument_list|,
operator|&
name|base_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|ma
operator|=
operator|&
name|mbp
operator|->
name|MarkArray
expr_stmt|;
if|if
condition|(
name|mark_index
operator|>=
name|ma
operator|->
name|MarkCount
condition|)
return|return
name|ERR
argument_list|(
name|HB_Err_Invalid_SubTable
argument_list|)
return|;
name|class
operator|=
name|ma
operator|->
name|MarkRecord
index|[
name|mark_index
index|]
operator|.
name|Class
expr_stmt|;
name|mark_anchor
operator|=
operator|&
name|ma
operator|->
name|MarkRecord
index|[
name|mark_index
index|]
operator|.
name|MarkAnchor
expr_stmt|;
if|if
condition|(
name|class
operator|>=
name|mbp
operator|->
name|ClassCount
condition|)
return|return
name|ERR
argument_list|(
name|HB_Err_Invalid_SubTable
argument_list|)
return|;
name|ba
operator|=
operator|&
name|mbp
operator|->
name|BaseArray
expr_stmt|;
if|if
condition|(
name|base_index
operator|>=
name|ba
operator|->
name|BaseCount
condition|)
return|return
name|ERR
argument_list|(
name|HB_Err_Invalid_SubTable
argument_list|)
return|;
name|br
operator|=
operator|&
name|ba
operator|->
name|BaseRecord
index|[
name|base_index
index|]
expr_stmt|;
name|base_anchor
operator|=
operator|&
name|br
operator|->
name|BaseAnchor
index|[
name|class
index|]
expr_stmt|;
name|error
operator|=
name|Get_Anchor
argument_list|(
name|gpi
argument_list|,
name|mark_anchor
argument_list|,
name|IN_CURGLYPH
argument_list|()
argument_list|,
operator|&
name|x_mark_value
argument_list|,
operator|&
name|y_mark_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|error
operator|=
name|Get_Anchor
argument_list|(
name|gpi
argument_list|,
name|base_anchor
argument_list|,
name|IN_GLYPH
argument_list|(
name|j
argument_list|)
argument_list|,
operator|&
name|x_base_value
argument_list|,
operator|&
name|y_base_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
comment|/* anchor points are not cumulative */
name|o
operator|=
name|POSITION
argument_list|(
name|buffer
operator|->
name|in_pos
argument_list|)
expr_stmt|;
name|o
operator|->
name|x_pos
operator|=
name|x_base_value
operator|-
name|x_mark_value
expr_stmt|;
name|o
operator|->
name|y_pos
operator|=
name|y_base_value
operator|-
name|y_mark_value
expr_stmt|;
name|o
operator|->
name|x_advance
operator|=
literal|0
expr_stmt|;
name|o
operator|->
name|y_advance
operator|=
literal|0
expr_stmt|;
name|o
operator|->
name|back
operator|=
name|i
expr_stmt|;
operator|(
name|buffer
operator|->
name|in_pos
operator|)
operator|++
expr_stmt|;
return|return
name|HB_Err_Ok
return|;
block|}
end_function
begin_comment
comment|/* LookupType 5 */
end_comment
begin_comment
comment|/* LigatureAttach */
end_comment
begin_function
DECL|function|Load_LigatureAttach
specifier|static
name|HB_Error
name|Load_LigatureAttach
parameter_list|(
name|HB_LigatureAttach
modifier|*
name|lat
parameter_list|,
name|HB_UShort
name|num_classes
parameter_list|,
name|HB_Stream
name|stream
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_UShort
name|m
decl_stmt|,
name|n
decl_stmt|,
name|k
decl_stmt|,
name|count
decl_stmt|;
name|HB_UInt
name|cur_offset
decl_stmt|,
name|new_offset
decl_stmt|,
name|base_offset
decl_stmt|;
name|HB_ComponentRecord
modifier|*
name|cr
decl_stmt|;
name|HB_Anchor
modifier|*
name|lan
decl_stmt|;
name|base_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
return|return
name|error
return|;
name|count
operator|=
name|lat
operator|->
name|ComponentCount
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|lat
operator|->
name|ComponentRecord
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|lat
operator|->
name|ComponentRecord
argument_list|,
name|count
argument_list|,
name|HB_ComponentRecord
argument_list|)
condition|)
return|return
name|error
return|;
name|cr
operator|=
name|lat
operator|->
name|ComponentRecord
expr_stmt|;
for|for
control|(
name|m
operator|=
literal|0
init|;
name|m
operator|<
name|count
condition|;
name|m
operator|++
control|)
block|{
name|cr
index|[
name|m
index|]
operator|.
name|LigatureAnchor
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|cr
index|[
name|m
index|]
operator|.
name|LigatureAnchor
argument_list|,
name|num_classes
argument_list|,
name|HB_Anchor
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
name|lan
operator|=
name|cr
index|[
name|m
index|]
operator|.
name|LigatureAnchor
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|num_classes
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail0
goto|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
if|if
condition|(
name|new_offset
condition|)
block|{
name|new_offset
operator|+=
name|base_offset
expr_stmt|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|Load_Anchor
argument_list|(
operator|&
name|lan
index|[
name|n
index|]
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
goto|goto
name|Fail0
goto|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
block|}
else|else
name|lan
index|[
name|n
index|]
operator|.
name|PosFormat
operator|=
literal|0
expr_stmt|;
block|}
continue|continue;
name|Fail0
label|:
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|n
condition|;
name|k
operator|++
control|)
name|Free_Anchor
argument_list|(
operator|&
name|lan
index|[
name|k
index|]
argument_list|)
expr_stmt|;
goto|goto
name|Fail
goto|;
block|}
return|return
name|HB_Err_Ok
return|;
name|Fail
label|:
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|m
condition|;
name|k
operator|++
control|)
block|{
name|lan
operator|=
name|cr
index|[
name|k
index|]
operator|.
name|LigatureAnchor
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|num_classes
condition|;
name|n
operator|++
control|)
name|Free_Anchor
argument_list|(
operator|&
name|lan
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|lan
argument_list|)
expr_stmt|;
block|}
name|FREE
argument_list|(
name|cr
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_function
DECL|function|Free_LigatureAttach
specifier|static
name|void
name|Free_LigatureAttach
parameter_list|(
name|HB_LigatureAttach
modifier|*
name|lat
parameter_list|,
name|HB_UShort
name|num_classes
parameter_list|)
block|{
name|HB_UShort
name|m
decl_stmt|,
name|n
decl_stmt|,
name|count
decl_stmt|;
name|HB_ComponentRecord
modifier|*
name|cr
decl_stmt|;
name|HB_Anchor
modifier|*
name|lan
decl_stmt|;
if|if
condition|(
name|lat
operator|->
name|ComponentRecord
condition|)
block|{
name|count
operator|=
name|lat
operator|->
name|ComponentCount
expr_stmt|;
name|cr
operator|=
name|lat
operator|->
name|ComponentRecord
expr_stmt|;
for|for
control|(
name|m
operator|=
literal|0
init|;
name|m
operator|<
name|count
condition|;
name|m
operator|++
control|)
block|{
name|lan
operator|=
name|cr
index|[
name|m
index|]
operator|.
name|LigatureAnchor
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|num_classes
condition|;
name|n
operator|++
control|)
name|Free_Anchor
argument_list|(
operator|&
name|lan
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|lan
argument_list|)
expr_stmt|;
block|}
name|FREE
argument_list|(
name|cr
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/* LigatureArray */
end_comment
begin_function
DECL|function|Load_LigatureArray
specifier|static
name|HB_Error
name|Load_LigatureArray
parameter_list|(
name|HB_LigatureArray
modifier|*
name|la
parameter_list|,
name|HB_UShort
name|num_classes
parameter_list|,
name|HB_Stream
name|stream
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_UShort
name|n
decl_stmt|,
name|m
decl_stmt|,
name|count
decl_stmt|;
name|HB_UInt
name|cur_offset
decl_stmt|,
name|new_offset
decl_stmt|,
name|base_offset
decl_stmt|;
name|HB_LigatureAttach
modifier|*
name|lat
decl_stmt|;
name|base_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
return|return
name|error
return|;
name|count
operator|=
name|la
operator|->
name|LigatureCount
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|la
operator|->
name|LigatureAttach
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|la
operator|->
name|LigatureAttach
argument_list|,
name|count
argument_list|,
name|HB_LigatureAttach
argument_list|)
condition|)
return|return
name|error
return|;
name|lat
operator|=
name|la
operator|->
name|LigatureAttach
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
operator|+
name|base_offset
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|Load_LigatureAttach
argument_list|(
operator|&
name|lat
index|[
name|n
index|]
argument_list|,
name|num_classes
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
goto|goto
name|Fail
goto|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
block|}
return|return
name|HB_Err_Ok
return|;
name|Fail
label|:
for|for
control|(
name|m
operator|=
literal|0
init|;
name|m
operator|<
name|n
condition|;
name|m
operator|++
control|)
name|Free_LigatureAttach
argument_list|(
operator|&
name|lat
index|[
name|m
index|]
argument_list|,
name|num_classes
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|lat
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_function
DECL|function|Free_LigatureArray
specifier|static
name|void
name|Free_LigatureArray
parameter_list|(
name|HB_LigatureArray
modifier|*
name|la
parameter_list|,
name|HB_UShort
name|num_classes
parameter_list|)
block|{
name|HB_UShort
name|n
decl_stmt|,
name|count
decl_stmt|;
name|HB_LigatureAttach
modifier|*
name|lat
decl_stmt|;
if|if
condition|(
name|la
operator|->
name|LigatureAttach
condition|)
block|{
name|count
operator|=
name|la
operator|->
name|LigatureCount
expr_stmt|;
name|lat
operator|=
name|la
operator|->
name|LigatureAttach
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
name|Free_LigatureAttach
argument_list|(
operator|&
name|lat
index|[
name|n
index|]
argument_list|,
name|num_classes
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|lat
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/* MarkLigPosFormat1 */
end_comment
begin_function
DECL|function|Load_MarkLigPos
specifier|static
name|HB_Error
name|Load_MarkLigPos
parameter_list|(
name|HB_GPOS_SubTable
modifier|*
name|st
parameter_list|,
name|HB_Stream
name|stream
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_MarkLigPos
modifier|*
name|mlp
init|=
operator|&
name|st
operator|->
name|marklig
decl_stmt|;
name|HB_UInt
name|cur_offset
decl_stmt|,
name|new_offset
decl_stmt|,
name|base_offset
decl_stmt|;
name|base_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|4L
argument_list|)
condition|)
return|return
name|error
return|;
name|mlp
operator|->
name|PosFormat
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
operator|+
name|base_offset
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|_HB_OPEN_Load_Coverage
argument_list|(
operator|&
name|mlp
operator|->
name|MarkCoverage
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
return|return
name|error
return|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail3
goto|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
operator|+
name|base_offset
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|_HB_OPEN_Load_Coverage
argument_list|(
operator|&
name|mlp
operator|->
name|LigatureCoverage
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
goto|goto
name|Fail3
goto|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|4L
argument_list|)
condition|)
goto|goto
name|Fail2
goto|;
name|mlp
operator|->
name|ClassCount
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
operator|+
name|base_offset
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|Load_MarkArray
argument_list|(
operator|&
name|mlp
operator|->
name|MarkArray
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
goto|goto
name|Fail2
goto|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail1
goto|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
operator|+
name|base_offset
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|Load_LigatureArray
argument_list|(
operator|&
name|mlp
operator|->
name|LigatureArray
argument_list|,
name|mlp
operator|->
name|ClassCount
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
goto|goto
name|Fail1
goto|;
return|return
name|HB_Err_Ok
return|;
name|Fail1
label|:
name|Free_MarkArray
argument_list|(
operator|&
name|mlp
operator|->
name|MarkArray
argument_list|)
expr_stmt|;
name|Fail2
label|:
name|_HB_OPEN_Free_Coverage
argument_list|(
operator|&
name|mlp
operator|->
name|LigatureCoverage
argument_list|)
expr_stmt|;
name|Fail3
label|:
name|_HB_OPEN_Free_Coverage
argument_list|(
operator|&
name|mlp
operator|->
name|MarkCoverage
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_function
DECL|function|Free_MarkLigPos
specifier|static
name|void
name|Free_MarkLigPos
parameter_list|(
name|HB_GPOS_SubTable
modifier|*
name|st
parameter_list|)
block|{
name|HB_MarkLigPos
modifier|*
name|mlp
init|=
operator|&
name|st
operator|->
name|marklig
decl_stmt|;
name|Free_LigatureArray
argument_list|(
operator|&
name|mlp
operator|->
name|LigatureArray
argument_list|,
name|mlp
operator|->
name|ClassCount
argument_list|)
expr_stmt|;
name|Free_MarkArray
argument_list|(
operator|&
name|mlp
operator|->
name|MarkArray
argument_list|)
expr_stmt|;
name|_HB_OPEN_Free_Coverage
argument_list|(
operator|&
name|mlp
operator|->
name|LigatureCoverage
argument_list|)
expr_stmt|;
name|_HB_OPEN_Free_Coverage
argument_list|(
operator|&
name|mlp
operator|->
name|MarkCoverage
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|Lookup_MarkLigPos
specifier|static
name|HB_Error
name|Lookup_MarkLigPos
parameter_list|(
name|GPOS_Instance
modifier|*
name|gpi
parameter_list|,
name|HB_GPOS_SubTable
modifier|*
name|st
parameter_list|,
name|HB_Buffer
name|buffer
parameter_list|,
name|HB_UShort
name|flags
parameter_list|,
name|HB_UShort
name|context_length
parameter_list|,
name|int
name|nesting_level
parameter_list|)
block|{
name|HB_UShort
name|i
decl_stmt|,
name|j
decl_stmt|,
name|mark_index
decl_stmt|,
name|lig_index
decl_stmt|,
name|property
decl_stmt|,
name|class
decl_stmt|;
name|HB_UShort
name|mark_glyph
decl_stmt|;
name|HB_Fixed
name|x_mark_value
decl_stmt|,
name|y_mark_value
decl_stmt|,
name|x_lig_value
decl_stmt|,
name|y_lig_value
decl_stmt|;
name|HB_Error
name|error
decl_stmt|;
name|HB_GPOSHeader
modifier|*
name|gpos
init|=
name|gpi
operator|->
name|gpos
decl_stmt|;
name|HB_MarkLigPos
modifier|*
name|mlp
init|=
operator|&
name|st
operator|->
name|marklig
decl_stmt|;
name|HB_MarkArray
modifier|*
name|ma
decl_stmt|;
name|HB_LigatureArray
modifier|*
name|la
decl_stmt|;
name|HB_LigatureAttach
modifier|*
name|lat
decl_stmt|;
name|HB_ComponentRecord
modifier|*
name|cr
decl_stmt|;
name|HB_UShort
name|comp_index
decl_stmt|;
name|HB_Anchor
modifier|*
name|mark_anchor
decl_stmt|;
name|HB_Anchor
modifier|*
name|lig_anchor
decl_stmt|;
name|HB_Position
name|o
decl_stmt|;
name|HB_UNUSED
argument_list|(
name|nesting_level
argument_list|)
expr_stmt|;
if|if
condition|(
name|context_length
operator|!=
literal|0xFFFF
operator|&&
name|context_length
operator|<
literal|1
condition|)
return|return
name|HB_Err_Not_Covered
return|;
if|if
condition|(
name|flags
operator|&
name|HB_LOOKUP_FLAG_IGNORE_LIGATURES
condition|)
return|return
name|HB_Err_Not_Covered
return|;
name|mark_glyph
operator|=
name|IN_CURGLYPH
argument_list|()
expr_stmt|;
if|if
condition|(
name|CHECK_Property
argument_list|(
name|gpos
operator|->
name|gdef
argument_list|,
name|IN_CURITEM
argument_list|()
argument_list|,
name|flags
argument_list|,
operator|&
name|property
argument_list|)
condition|)
return|return
name|error
return|;
name|error
operator|=
name|_HB_OPEN_Coverage_Index
argument_list|(
operator|&
name|mlp
operator|->
name|MarkCoverage
argument_list|,
name|mark_glyph
argument_list|,
operator|&
name|mark_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
comment|/* now we search backwards for a non-mark glyph */
name|i
operator|=
literal|1
expr_stmt|;
name|j
operator|=
name|buffer
operator|->
name|in_pos
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|i
operator|<=
name|buffer
operator|->
name|in_pos
condition|)
block|{
name|error
operator|=
name|HB_GDEF_Get_Glyph_Property
argument_list|(
name|gpos
operator|->
name|gdef
argument_list|,
name|IN_GLYPH
argument_list|(
name|j
argument_list|)
argument_list|,
operator|&
name|property
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
operator|!
operator|(
name|property
operator|==
name|HB_GDEF_MARK
operator|||
name|property
operator|&
name|HB_LOOKUP_FLAG_IGNORE_SPECIAL_MARKS
operator|)
condition|)
break|break;
name|i
operator|++
expr_stmt|;
name|j
operator|--
expr_stmt|;
block|}
comment|/* Similar to Lookup_MarkBasePos(), I suspect that this assertion is      too strong, thus it is commented out.                             */
if|#
directive|if
literal|0
block|if ( property != HB_GDEF_LIGATURE )     return HB_Err_Not_Covered;
endif|#
directive|endif
if|if
condition|(
name|i
operator|>
name|buffer
operator|->
name|in_pos
condition|)
return|return
name|HB_Err_Not_Covered
return|;
name|error
operator|=
name|_HB_OPEN_Coverage_Index
argument_list|(
operator|&
name|mlp
operator|->
name|LigatureCoverage
argument_list|,
name|IN_GLYPH
argument_list|(
name|j
argument_list|)
argument_list|,
operator|&
name|lig_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|ma
operator|=
operator|&
name|mlp
operator|->
name|MarkArray
expr_stmt|;
if|if
condition|(
name|mark_index
operator|>=
name|ma
operator|->
name|MarkCount
condition|)
return|return
name|ERR
argument_list|(
name|HB_Err_Invalid_SubTable
argument_list|)
return|;
name|class
operator|=
name|ma
operator|->
name|MarkRecord
index|[
name|mark_index
index|]
operator|.
name|Class
expr_stmt|;
name|mark_anchor
operator|=
operator|&
name|ma
operator|->
name|MarkRecord
index|[
name|mark_index
index|]
operator|.
name|MarkAnchor
expr_stmt|;
if|if
condition|(
name|class
operator|>=
name|mlp
operator|->
name|ClassCount
condition|)
return|return
name|ERR
argument_list|(
name|HB_Err_Invalid_SubTable
argument_list|)
return|;
name|la
operator|=
operator|&
name|mlp
operator|->
name|LigatureArray
expr_stmt|;
if|if
condition|(
name|lig_index
operator|>=
name|la
operator|->
name|LigatureCount
condition|)
return|return
name|ERR
argument_list|(
name|HB_Err_Invalid_SubTable
argument_list|)
return|;
name|lat
operator|=
operator|&
name|la
operator|->
name|LigatureAttach
index|[
name|lig_index
index|]
expr_stmt|;
comment|/* We must now check whether the ligature ID of the current mark glyph      is identical to the ligature ID of the found ligature.  If yes, we      can directly use the component index.  If not, we attach the mark      glyph to the last component of the ligature.                        */
if|if
condition|(
name|IN_LIGID
argument_list|(
name|j
argument_list|)
operator|==
name|IN_LIGID
argument_list|(
name|buffer
operator|->
name|in_pos
argument_list|)
condition|)
block|{
name|comp_index
operator|=
name|IN_COMPONENT
argument_list|(
name|buffer
operator|->
name|in_pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|comp_index
operator|>=
name|lat
operator|->
name|ComponentCount
condition|)
return|return
name|HB_Err_Not_Covered
return|;
block|}
else|else
name|comp_index
operator|=
name|lat
operator|->
name|ComponentCount
operator|-
literal|1
expr_stmt|;
name|cr
operator|=
operator|&
name|lat
operator|->
name|ComponentRecord
index|[
name|comp_index
index|]
expr_stmt|;
name|lig_anchor
operator|=
operator|&
name|cr
operator|->
name|LigatureAnchor
index|[
name|class
index|]
expr_stmt|;
name|error
operator|=
name|Get_Anchor
argument_list|(
name|gpi
argument_list|,
name|mark_anchor
argument_list|,
name|IN_CURGLYPH
argument_list|()
argument_list|,
operator|&
name|x_mark_value
argument_list|,
operator|&
name|y_mark_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|error
operator|=
name|Get_Anchor
argument_list|(
name|gpi
argument_list|,
name|lig_anchor
argument_list|,
name|IN_GLYPH
argument_list|(
name|j
argument_list|)
argument_list|,
operator|&
name|x_lig_value
argument_list|,
operator|&
name|y_lig_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
comment|/* anchor points are not cumulative */
name|o
operator|=
name|POSITION
argument_list|(
name|buffer
operator|->
name|in_pos
argument_list|)
expr_stmt|;
name|o
operator|->
name|x_pos
operator|=
name|x_lig_value
operator|-
name|x_mark_value
expr_stmt|;
name|o
operator|->
name|y_pos
operator|=
name|y_lig_value
operator|-
name|y_mark_value
expr_stmt|;
name|o
operator|->
name|x_advance
operator|=
literal|0
expr_stmt|;
name|o
operator|->
name|y_advance
operator|=
literal|0
expr_stmt|;
name|o
operator|->
name|back
operator|=
name|i
expr_stmt|;
operator|(
name|buffer
operator|->
name|in_pos
operator|)
operator|++
expr_stmt|;
return|return
name|HB_Err_Ok
return|;
block|}
end_function
begin_comment
comment|/* LookupType 6 */
end_comment
begin_comment
comment|/* Mark2Array */
end_comment
begin_function
DECL|function|Load_Mark2Array
specifier|static
name|HB_Error
name|Load_Mark2Array
parameter_list|(
name|HB_Mark2Array
modifier|*
name|m2a
parameter_list|,
name|HB_UShort
name|num_classes
parameter_list|,
name|HB_Stream
name|stream
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_UShort
name|m
decl_stmt|,
name|n
decl_stmt|,
name|count
decl_stmt|;
name|HB_UInt
name|cur_offset
decl_stmt|,
name|new_offset
decl_stmt|,
name|base_offset
decl_stmt|;
name|HB_Mark2Record
modifier|*
name|m2r
decl_stmt|;
name|HB_Anchor
modifier|*
name|m2an
decl_stmt|,
modifier|*
name|m2ans
decl_stmt|;
name|base_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
return|return
name|error
return|;
name|count
operator|=
name|m2a
operator|->
name|Mark2Count
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|m2a
operator|->
name|Mark2Record
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|m2a
operator|->
name|Mark2Record
argument_list|,
name|count
argument_list|,
name|HB_Mark2Record
argument_list|)
condition|)
return|return
name|error
return|;
name|m2r
operator|=
name|m2a
operator|->
name|Mark2Record
expr_stmt|;
name|m2ans
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|m2ans
argument_list|,
name|count
operator|*
name|num_classes
argument_list|,
name|HB_Anchor
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
for|for
control|(
name|m
operator|=
literal|0
init|;
name|m
operator|<
name|count
condition|;
name|m
operator|++
control|)
block|{
name|m2an
operator|=
name|m2r
index|[
name|m
index|]
operator|.
name|Mark2Anchor
operator|=
name|m2ans
operator|+
name|m
operator|*
name|num_classes
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|num_classes
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
operator|+
name|base_offset
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
if|if
condition|(
name|new_offset
operator|==
name|base_offset
condition|)
block|{
comment|/* Anchor table not provided.  Skip loading. 	 * Some versions of FreeSans hit this. */
name|m2an
index|[
name|n
index|]
operator|.
name|PosFormat
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|Load_Anchor
argument_list|(
operator|&
name|m2an
index|[
name|n
index|]
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
goto|goto
name|Fail
goto|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|HB_Err_Ok
return|;
name|Fail
label|:
name|FREE
argument_list|(
name|m2ans
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|m2r
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_function
DECL|function|Free_Mark2Array
specifier|static
name|void
name|Free_Mark2Array
parameter_list|(
name|HB_Mark2Array
modifier|*
name|m2a
parameter_list|,
name|HB_UShort
name|num_classes
parameter_list|)
block|{
name|HB_Mark2Record
modifier|*
name|m2r
decl_stmt|;
name|HB_Anchor
modifier|*
name|m2ans
decl_stmt|;
name|HB_UNUSED
argument_list|(
name|num_classes
argument_list|)
expr_stmt|;
if|if
condition|(
name|m2a
operator|->
name|Mark2Record
condition|)
block|{
name|m2r
operator|=
name|m2a
operator|->
name|Mark2Record
expr_stmt|;
if|if
condition|(
name|m2a
operator|->
name|Mark2Count
condition|)
block|{
name|m2ans
operator|=
name|m2r
index|[
literal|0
index|]
operator|.
name|Mark2Anchor
expr_stmt|;
name|FREE
argument_list|(
name|m2ans
argument_list|)
expr_stmt|;
block|}
name|FREE
argument_list|(
name|m2r
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/* MarkMarkPosFormat1 */
end_comment
begin_function
DECL|function|Load_MarkMarkPos
specifier|static
name|HB_Error
name|Load_MarkMarkPos
parameter_list|(
name|HB_GPOS_SubTable
modifier|*
name|st
parameter_list|,
name|HB_Stream
name|stream
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_MarkMarkPos
modifier|*
name|mmp
init|=
operator|&
name|st
operator|->
name|markmark
decl_stmt|;
name|HB_UInt
name|cur_offset
decl_stmt|,
name|new_offset
decl_stmt|,
name|base_offset
decl_stmt|;
name|base_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|4L
argument_list|)
condition|)
return|return
name|error
return|;
name|mmp
operator|->
name|PosFormat
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
operator|+
name|base_offset
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|_HB_OPEN_Load_Coverage
argument_list|(
operator|&
name|mmp
operator|->
name|Mark1Coverage
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
return|return
name|error
return|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail3
goto|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
operator|+
name|base_offset
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|_HB_OPEN_Load_Coverage
argument_list|(
operator|&
name|mmp
operator|->
name|Mark2Coverage
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
goto|goto
name|Fail3
goto|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|4L
argument_list|)
condition|)
goto|goto
name|Fail2
goto|;
name|mmp
operator|->
name|ClassCount
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
operator|+
name|base_offset
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|Load_MarkArray
argument_list|(
operator|&
name|mmp
operator|->
name|Mark1Array
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
goto|goto
name|Fail2
goto|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail1
goto|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
operator|+
name|base_offset
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|Load_Mark2Array
argument_list|(
operator|&
name|mmp
operator|->
name|Mark2Array
argument_list|,
name|mmp
operator|->
name|ClassCount
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
goto|goto
name|Fail1
goto|;
return|return
name|HB_Err_Ok
return|;
name|Fail1
label|:
name|Free_MarkArray
argument_list|(
operator|&
name|mmp
operator|->
name|Mark1Array
argument_list|)
expr_stmt|;
name|Fail2
label|:
name|_HB_OPEN_Free_Coverage
argument_list|(
operator|&
name|mmp
operator|->
name|Mark2Coverage
argument_list|)
expr_stmt|;
name|Fail3
label|:
name|_HB_OPEN_Free_Coverage
argument_list|(
operator|&
name|mmp
operator|->
name|Mark1Coverage
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_function
DECL|function|Free_MarkMarkPos
specifier|static
name|void
name|Free_MarkMarkPos
parameter_list|(
name|HB_GPOS_SubTable
modifier|*
name|st
parameter_list|)
block|{
name|HB_MarkMarkPos
modifier|*
name|mmp
init|=
operator|&
name|st
operator|->
name|markmark
decl_stmt|;
name|Free_Mark2Array
argument_list|(
operator|&
name|mmp
operator|->
name|Mark2Array
argument_list|,
name|mmp
operator|->
name|ClassCount
argument_list|)
expr_stmt|;
name|Free_MarkArray
argument_list|(
operator|&
name|mmp
operator|->
name|Mark1Array
argument_list|)
expr_stmt|;
name|_HB_OPEN_Free_Coverage
argument_list|(
operator|&
name|mmp
operator|->
name|Mark2Coverage
argument_list|)
expr_stmt|;
name|_HB_OPEN_Free_Coverage
argument_list|(
operator|&
name|mmp
operator|->
name|Mark1Coverage
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|Lookup_MarkMarkPos
specifier|static
name|HB_Error
name|Lookup_MarkMarkPos
parameter_list|(
name|GPOS_Instance
modifier|*
name|gpi
parameter_list|,
name|HB_GPOS_SubTable
modifier|*
name|st
parameter_list|,
name|HB_Buffer
name|buffer
parameter_list|,
name|HB_UShort
name|flags
parameter_list|,
name|HB_UShort
name|context_length
parameter_list|,
name|int
name|nesting_level
parameter_list|)
block|{
name|HB_UShort
name|i
decl_stmt|,
name|j
decl_stmt|,
name|mark1_index
decl_stmt|,
name|mark2_index
decl_stmt|,
name|property
decl_stmt|,
name|class
decl_stmt|;
name|HB_Fixed
name|x_mark1_value
decl_stmt|,
name|y_mark1_value
decl_stmt|,
name|x_mark2_value
decl_stmt|,
name|y_mark2_value
decl_stmt|;
name|HB_Error
name|error
decl_stmt|;
name|HB_GPOSHeader
modifier|*
name|gpos
init|=
name|gpi
operator|->
name|gpos
decl_stmt|;
name|HB_MarkMarkPos
modifier|*
name|mmp
init|=
operator|&
name|st
operator|->
name|markmark
decl_stmt|;
name|HB_MarkArray
modifier|*
name|ma1
decl_stmt|;
name|HB_Mark2Array
modifier|*
name|ma2
decl_stmt|;
name|HB_Mark2Record
modifier|*
name|m2r
decl_stmt|;
name|HB_Anchor
modifier|*
name|mark1_anchor
decl_stmt|;
name|HB_Anchor
modifier|*
name|mark2_anchor
decl_stmt|;
name|HB_Position
name|o
decl_stmt|;
name|HB_UNUSED
argument_list|(
name|nesting_level
argument_list|)
expr_stmt|;
if|if
condition|(
name|context_length
operator|!=
literal|0xFFFF
operator|&&
name|context_length
operator|<
literal|1
condition|)
return|return
name|HB_Err_Not_Covered
return|;
if|if
condition|(
name|flags
operator|&
name|HB_LOOKUP_FLAG_IGNORE_MARKS
condition|)
return|return
name|HB_Err_Not_Covered
return|;
if|if
condition|(
name|CHECK_Property
argument_list|(
name|gpos
operator|->
name|gdef
argument_list|,
name|IN_CURITEM
argument_list|()
argument_list|,
name|flags
argument_list|,
operator|&
name|property
argument_list|)
condition|)
return|return
name|error
return|;
name|error
operator|=
name|_HB_OPEN_Coverage_Index
argument_list|(
operator|&
name|mmp
operator|->
name|Mark1Coverage
argument_list|,
name|IN_CURGLYPH
argument_list|()
argument_list|,
operator|&
name|mark1_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
comment|/* now we search backwards for a suitable mark glyph until a non-mark      glyph                                                */
if|if
condition|(
name|buffer
operator|->
name|in_pos
operator|==
literal|0
condition|)
return|return
name|HB_Err_Not_Covered
return|;
name|i
operator|=
literal|1
expr_stmt|;
name|j
operator|=
name|buffer
operator|->
name|in_pos
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|i
operator|<=
name|buffer
operator|->
name|in_pos
condition|)
block|{
name|error
operator|=
name|HB_GDEF_Get_Glyph_Property
argument_list|(
name|gpos
operator|->
name|gdef
argument_list|,
name|IN_GLYPH
argument_list|(
name|j
argument_list|)
argument_list|,
operator|&
name|property
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
operator|!
operator|(
name|property
operator|==
name|HB_GDEF_MARK
operator|||
name|property
operator|&
name|HB_LOOKUP_FLAG_IGNORE_SPECIAL_MARKS
operator|)
condition|)
return|return
name|HB_Err_Not_Covered
return|;
if|if
condition|(
name|flags
operator|&
name|HB_LOOKUP_FLAG_IGNORE_SPECIAL_MARKS
condition|)
block|{
if|if
condition|(
name|property
operator|==
operator|(
name|flags
operator|&
literal|0xFF00
operator|)
condition|)
break|break;
block|}
else|else
break|break;
name|i
operator|++
expr_stmt|;
name|j
operator|--
expr_stmt|;
block|}
name|error
operator|=
name|_HB_OPEN_Coverage_Index
argument_list|(
operator|&
name|mmp
operator|->
name|Mark2Coverage
argument_list|,
name|IN_GLYPH
argument_list|(
name|j
argument_list|)
argument_list|,
operator|&
name|mark2_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|ma1
operator|=
operator|&
name|mmp
operator|->
name|Mark1Array
expr_stmt|;
if|if
condition|(
name|mark1_index
operator|>=
name|ma1
operator|->
name|MarkCount
condition|)
return|return
name|ERR
argument_list|(
name|HB_Err_Invalid_SubTable
argument_list|)
return|;
name|class
operator|=
name|ma1
operator|->
name|MarkRecord
index|[
name|mark1_index
index|]
operator|.
name|Class
expr_stmt|;
name|mark1_anchor
operator|=
operator|&
name|ma1
operator|->
name|MarkRecord
index|[
name|mark1_index
index|]
operator|.
name|MarkAnchor
expr_stmt|;
if|if
condition|(
name|class
operator|>=
name|mmp
operator|->
name|ClassCount
condition|)
return|return
name|ERR
argument_list|(
name|HB_Err_Invalid_SubTable
argument_list|)
return|;
name|ma2
operator|=
operator|&
name|mmp
operator|->
name|Mark2Array
expr_stmt|;
if|if
condition|(
name|mark2_index
operator|>=
name|ma2
operator|->
name|Mark2Count
condition|)
return|return
name|ERR
argument_list|(
name|HB_Err_Invalid_SubTable
argument_list|)
return|;
name|m2r
operator|=
operator|&
name|ma2
operator|->
name|Mark2Record
index|[
name|mark2_index
index|]
expr_stmt|;
name|mark2_anchor
operator|=
operator|&
name|m2r
operator|->
name|Mark2Anchor
index|[
name|class
index|]
expr_stmt|;
name|error
operator|=
name|Get_Anchor
argument_list|(
name|gpi
argument_list|,
name|mark1_anchor
argument_list|,
name|IN_CURGLYPH
argument_list|()
argument_list|,
operator|&
name|x_mark1_value
argument_list|,
operator|&
name|y_mark1_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|error
operator|=
name|Get_Anchor
argument_list|(
name|gpi
argument_list|,
name|mark2_anchor
argument_list|,
name|IN_GLYPH
argument_list|(
name|j
argument_list|)
argument_list|,
operator|&
name|x_mark2_value
argument_list|,
operator|&
name|y_mark2_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
comment|/* anchor points are not cumulative */
name|o
operator|=
name|POSITION
argument_list|(
name|buffer
operator|->
name|in_pos
argument_list|)
expr_stmt|;
name|o
operator|->
name|x_pos
operator|=
name|x_mark2_value
operator|-
name|x_mark1_value
expr_stmt|;
name|o
operator|->
name|y_pos
operator|=
name|y_mark2_value
operator|-
name|y_mark1_value
expr_stmt|;
name|o
operator|->
name|x_advance
operator|=
literal|0
expr_stmt|;
name|o
operator|->
name|y_advance
operator|=
literal|0
expr_stmt|;
name|o
operator|->
name|back
operator|=
literal|1
expr_stmt|;
operator|(
name|buffer
operator|->
name|in_pos
operator|)
operator|++
expr_stmt|;
return|return
name|HB_Err_Ok
return|;
block|}
end_function
begin_comment
comment|/* Do the actual positioning for a context positioning (either format    7 or 8).  This is only called after we've determined that the stream    matches the subrule.                                                 */
end_comment
begin_function
DECL|function|Do_ContextPos
specifier|static
name|HB_Error
name|Do_ContextPos
parameter_list|(
name|GPOS_Instance
modifier|*
name|gpi
parameter_list|,
name|HB_UShort
name|GlyphCount
parameter_list|,
name|HB_UShort
name|PosCount
parameter_list|,
name|HB_PosLookupRecord
modifier|*
name|pos
parameter_list|,
name|HB_Buffer
name|buffer
parameter_list|,
name|int
name|nesting_level
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_UInt
name|i
decl_stmt|,
name|old_pos
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|GlyphCount
condition|)
block|{
if|if
condition|(
name|PosCount
operator|&&
name|i
operator|==
name|pos
operator|->
name|SequenceIndex
condition|)
block|{
name|old_pos
operator|=
name|buffer
operator|->
name|in_pos
expr_stmt|;
comment|/* Do a positioning */
name|error
operator|=
name|GPOS_Do_Glyph_Lookup
argument_list|(
name|gpi
argument_list|,
name|pos
operator|->
name|LookupListIndex
argument_list|,
name|buffer
argument_list|,
name|GlyphCount
argument_list|,
name|nesting_level
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|pos
operator|++
expr_stmt|;
name|PosCount
operator|--
expr_stmt|;
name|i
operator|+=
name|buffer
operator|->
name|in_pos
operator|-
name|old_pos
expr_stmt|;
block|}
else|else
block|{
name|i
operator|++
expr_stmt|;
operator|(
name|buffer
operator|->
name|in_pos
operator|)
operator|++
expr_stmt|;
block|}
block|}
return|return
name|HB_Err_Ok
return|;
block|}
end_function
begin_comment
comment|/* LookupType 7 */
end_comment
begin_comment
comment|/* PosRule */
end_comment
begin_function
DECL|function|Load_PosRule
specifier|static
name|HB_Error
name|Load_PosRule
parameter_list|(
name|HB_PosRule
modifier|*
name|pr
parameter_list|,
name|HB_Stream
name|stream
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_UShort
name|n
decl_stmt|,
name|count
decl_stmt|;
name|HB_UShort
modifier|*
name|i
decl_stmt|;
name|HB_PosLookupRecord
modifier|*
name|plr
decl_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|4L
argument_list|)
condition|)
return|return
name|error
return|;
name|pr
operator|->
name|GlyphCount
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|pr
operator|->
name|PosCount
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|pr
operator|->
name|Input
operator|=
name|NULL
expr_stmt|;
name|count
operator|=
name|pr
operator|->
name|GlyphCount
operator|-
literal|1
expr_stmt|;
comment|/* only GlyphCount - 1 elements */
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|pr
operator|->
name|Input
argument_list|,
name|count
argument_list|,
name|HB_UShort
argument_list|)
condition|)
return|return
name|error
return|;
name|i
operator|=
name|pr
operator|->
name|Input
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
name|count
operator|*
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail2
goto|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
name|i
index|[
name|n
index|]
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|pr
operator|->
name|PosLookupRecord
operator|=
name|NULL
expr_stmt|;
name|count
operator|=
name|pr
operator|->
name|PosCount
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|pr
operator|->
name|PosLookupRecord
argument_list|,
name|count
argument_list|,
name|HB_PosLookupRecord
argument_list|)
condition|)
goto|goto
name|Fail2
goto|;
name|plr
operator|=
name|pr
operator|->
name|PosLookupRecord
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
name|count
operator|*
literal|4L
argument_list|)
condition|)
goto|goto
name|Fail1
goto|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
block|{
name|plr
index|[
name|n
index|]
operator|.
name|SequenceIndex
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|plr
index|[
name|n
index|]
operator|.
name|LookupListIndex
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
block|}
name|FORGET_Frame
argument_list|()
expr_stmt|;
return|return
name|HB_Err_Ok
return|;
name|Fail1
label|:
name|FREE
argument_list|(
name|plr
argument_list|)
expr_stmt|;
name|Fail2
label|:
name|FREE
argument_list|(
name|i
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_function
DECL|function|Free_PosRule
specifier|static
name|void
name|Free_PosRule
parameter_list|(
name|HB_PosRule
modifier|*
name|pr
parameter_list|)
block|{
name|FREE
argument_list|(
name|pr
operator|->
name|PosLookupRecord
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|pr
operator|->
name|Input
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* PosRuleSet */
end_comment
begin_function
DECL|function|Load_PosRuleSet
specifier|static
name|HB_Error
name|Load_PosRuleSet
parameter_list|(
name|HB_PosRuleSet
modifier|*
name|prs
parameter_list|,
name|HB_Stream
name|stream
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_UShort
name|n
decl_stmt|,
name|m
decl_stmt|,
name|count
decl_stmt|;
name|HB_UInt
name|cur_offset
decl_stmt|,
name|new_offset
decl_stmt|,
name|base_offset
decl_stmt|;
name|HB_PosRule
modifier|*
name|pr
decl_stmt|;
name|base_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
return|return
name|error
return|;
name|count
operator|=
name|prs
operator|->
name|PosRuleCount
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|prs
operator|->
name|PosRule
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|prs
operator|->
name|PosRule
argument_list|,
name|count
argument_list|,
name|HB_PosRule
argument_list|)
condition|)
return|return
name|error
return|;
name|pr
operator|=
name|prs
operator|->
name|PosRule
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
operator|+
name|base_offset
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|Load_PosRule
argument_list|(
operator|&
name|pr
index|[
name|n
index|]
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
goto|goto
name|Fail
goto|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
block|}
return|return
name|HB_Err_Ok
return|;
name|Fail
label|:
for|for
control|(
name|m
operator|=
literal|0
init|;
name|m
operator|<
name|n
condition|;
name|m
operator|++
control|)
name|Free_PosRule
argument_list|(
operator|&
name|pr
index|[
name|m
index|]
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|pr
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_function
DECL|function|Free_PosRuleSet
specifier|static
name|void
name|Free_PosRuleSet
parameter_list|(
name|HB_PosRuleSet
modifier|*
name|prs
parameter_list|)
block|{
name|HB_UShort
name|n
decl_stmt|,
name|count
decl_stmt|;
name|HB_PosRule
modifier|*
name|pr
decl_stmt|;
if|if
condition|(
name|prs
operator|->
name|PosRule
condition|)
block|{
name|count
operator|=
name|prs
operator|->
name|PosRuleCount
expr_stmt|;
name|pr
operator|=
name|prs
operator|->
name|PosRule
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
name|Free_PosRule
argument_list|(
operator|&
name|pr
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|pr
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/* ContextPosFormat1 */
end_comment
begin_function
DECL|function|Load_ContextPos1
specifier|static
name|HB_Error
name|Load_ContextPos1
parameter_list|(
name|HB_ContextPosFormat1
modifier|*
name|cpf1
parameter_list|,
name|HB_Stream
name|stream
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_UShort
name|n
decl_stmt|,
name|m
decl_stmt|,
name|count
decl_stmt|;
name|HB_UInt
name|cur_offset
decl_stmt|,
name|new_offset
decl_stmt|,
name|base_offset
decl_stmt|;
name|HB_PosRuleSet
modifier|*
name|prs
decl_stmt|;
name|base_offset
operator|=
name|FILE_Pos
argument_list|()
operator|-
literal|2L
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
return|return
name|error
return|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
operator|+
name|base_offset
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|_HB_OPEN_Load_Coverage
argument_list|(
operator|&
name|cpf1
operator|->
name|Coverage
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
return|return
name|error
return|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail2
goto|;
name|count
operator|=
name|cpf1
operator|->
name|PosRuleSetCount
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cpf1
operator|->
name|PosRuleSet
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|cpf1
operator|->
name|PosRuleSet
argument_list|,
name|count
argument_list|,
name|HB_PosRuleSet
argument_list|)
condition|)
goto|goto
name|Fail2
goto|;
name|prs
operator|=
name|cpf1
operator|->
name|PosRuleSet
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail1
goto|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
operator|+
name|base_offset
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|Load_PosRuleSet
argument_list|(
operator|&
name|prs
index|[
name|n
index|]
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
goto|goto
name|Fail1
goto|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
block|}
return|return
name|HB_Err_Ok
return|;
name|Fail1
label|:
for|for
control|(
name|m
operator|=
literal|0
init|;
name|m
operator|<
name|n
condition|;
name|m
operator|++
control|)
name|Free_PosRuleSet
argument_list|(
operator|&
name|prs
index|[
name|m
index|]
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|prs
argument_list|)
expr_stmt|;
name|Fail2
label|:
name|_HB_OPEN_Free_Coverage
argument_list|(
operator|&
name|cpf1
operator|->
name|Coverage
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_function
DECL|function|Free_ContextPos1
specifier|static
name|void
name|Free_ContextPos1
parameter_list|(
name|HB_ContextPosFormat1
modifier|*
name|cpf1
parameter_list|)
block|{
name|HB_UShort
name|n
decl_stmt|,
name|count
decl_stmt|;
name|HB_PosRuleSet
modifier|*
name|prs
decl_stmt|;
if|if
condition|(
name|cpf1
operator|->
name|PosRuleSet
condition|)
block|{
name|count
operator|=
name|cpf1
operator|->
name|PosRuleSetCount
expr_stmt|;
name|prs
operator|=
name|cpf1
operator|->
name|PosRuleSet
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
name|Free_PosRuleSet
argument_list|(
operator|&
name|prs
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|prs
argument_list|)
expr_stmt|;
block|}
name|_HB_OPEN_Free_Coverage
argument_list|(
operator|&
name|cpf1
operator|->
name|Coverage
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* PosClassRule */
end_comment
begin_function
DECL|function|Load_PosClassRule
specifier|static
name|HB_Error
name|Load_PosClassRule
parameter_list|(
name|HB_ContextPosFormat2
modifier|*
name|cpf2
parameter_list|,
name|HB_PosClassRule
modifier|*
name|pcr
parameter_list|,
name|HB_Stream
name|stream
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_UShort
name|n
decl_stmt|,
name|count
decl_stmt|;
name|HB_UShort
modifier|*
name|c
decl_stmt|;
name|HB_PosLookupRecord
modifier|*
name|plr
decl_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|4L
argument_list|)
condition|)
return|return
name|error
return|;
name|pcr
operator|->
name|GlyphCount
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|pcr
operator|->
name|PosCount
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
if|if
condition|(
name|pcr
operator|->
name|GlyphCount
operator|>
name|cpf2
operator|->
name|MaxContextLength
condition|)
name|cpf2
operator|->
name|MaxContextLength
operator|=
name|pcr
operator|->
name|GlyphCount
expr_stmt|;
name|pcr
operator|->
name|Class
operator|=
name|NULL
expr_stmt|;
name|count
operator|=
name|pcr
operator|->
name|GlyphCount
operator|-
literal|1
expr_stmt|;
comment|/* only GlyphCount - 1 elements */
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|pcr
operator|->
name|Class
argument_list|,
name|count
argument_list|,
name|HB_UShort
argument_list|)
condition|)
return|return
name|error
return|;
name|c
operator|=
name|pcr
operator|->
name|Class
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
name|count
operator|*
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail2
goto|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
name|c
index|[
name|n
index|]
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|pcr
operator|->
name|PosLookupRecord
operator|=
name|NULL
expr_stmt|;
name|count
operator|=
name|pcr
operator|->
name|PosCount
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|pcr
operator|->
name|PosLookupRecord
argument_list|,
name|count
argument_list|,
name|HB_PosLookupRecord
argument_list|)
condition|)
goto|goto
name|Fail2
goto|;
name|plr
operator|=
name|pcr
operator|->
name|PosLookupRecord
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
name|count
operator|*
literal|4L
argument_list|)
condition|)
goto|goto
name|Fail1
goto|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
block|{
name|plr
index|[
name|n
index|]
operator|.
name|SequenceIndex
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|plr
index|[
name|n
index|]
operator|.
name|LookupListIndex
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
block|}
name|FORGET_Frame
argument_list|()
expr_stmt|;
return|return
name|HB_Err_Ok
return|;
name|Fail1
label|:
name|FREE
argument_list|(
name|plr
argument_list|)
expr_stmt|;
name|Fail2
label|:
name|FREE
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_function
DECL|function|Free_PosClassRule
specifier|static
name|void
name|Free_PosClassRule
parameter_list|(
name|HB_PosClassRule
modifier|*
name|pcr
parameter_list|)
block|{
name|FREE
argument_list|(
name|pcr
operator|->
name|PosLookupRecord
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|pcr
operator|->
name|Class
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* PosClassSet */
end_comment
begin_function
DECL|function|Load_PosClassSet
specifier|static
name|HB_Error
name|Load_PosClassSet
parameter_list|(
name|HB_ContextPosFormat2
modifier|*
name|cpf2
parameter_list|,
name|HB_PosClassSet
modifier|*
name|pcs
parameter_list|,
name|HB_Stream
name|stream
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_UShort
name|n
decl_stmt|,
name|m
decl_stmt|,
name|count
decl_stmt|;
name|HB_UInt
name|cur_offset
decl_stmt|,
name|new_offset
decl_stmt|,
name|base_offset
decl_stmt|;
name|HB_PosClassRule
modifier|*
name|pcr
decl_stmt|;
name|base_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
return|return
name|error
return|;
name|count
operator|=
name|pcs
operator|->
name|PosClassRuleCount
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|pcs
operator|->
name|PosClassRule
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|pcs
operator|->
name|PosClassRule
argument_list|,
name|count
argument_list|,
name|HB_PosClassRule
argument_list|)
condition|)
return|return
name|error
return|;
name|pcr
operator|=
name|pcs
operator|->
name|PosClassRule
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
operator|+
name|base_offset
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|Load_PosClassRule
argument_list|(
name|cpf2
argument_list|,
operator|&
name|pcr
index|[
name|n
index|]
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
goto|goto
name|Fail
goto|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
block|}
return|return
name|HB_Err_Ok
return|;
name|Fail
label|:
for|for
control|(
name|m
operator|=
literal|0
init|;
name|m
operator|<
name|n
condition|;
name|m
operator|++
control|)
name|Free_PosClassRule
argument_list|(
operator|&
name|pcr
index|[
name|m
index|]
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|pcr
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_function
DECL|function|Free_PosClassSet
specifier|static
name|void
name|Free_PosClassSet
parameter_list|(
name|HB_PosClassSet
modifier|*
name|pcs
parameter_list|)
block|{
name|HB_UShort
name|n
decl_stmt|,
name|count
decl_stmt|;
name|HB_PosClassRule
modifier|*
name|pcr
decl_stmt|;
if|if
condition|(
name|pcs
operator|->
name|PosClassRule
condition|)
block|{
name|count
operator|=
name|pcs
operator|->
name|PosClassRuleCount
expr_stmt|;
name|pcr
operator|=
name|pcs
operator|->
name|PosClassRule
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
name|Free_PosClassRule
argument_list|(
operator|&
name|pcr
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|pcr
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/* ContextPosFormat2 */
end_comment
begin_function
DECL|function|Load_ContextPos2
specifier|static
name|HB_Error
name|Load_ContextPos2
parameter_list|(
name|HB_ContextPosFormat2
modifier|*
name|cpf2
parameter_list|,
name|HB_Stream
name|stream
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_UShort
name|n
decl_stmt|,
name|m
decl_stmt|,
name|count
decl_stmt|;
name|HB_UInt
name|cur_offset
decl_stmt|,
name|new_offset
decl_stmt|,
name|base_offset
decl_stmt|;
name|HB_PosClassSet
modifier|*
name|pcs
decl_stmt|;
name|base_offset
operator|=
name|FILE_Pos
argument_list|()
operator|-
literal|2
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
return|return
name|error
return|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
operator|+
name|base_offset
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|_HB_OPEN_Load_Coverage
argument_list|(
operator|&
name|cpf2
operator|->
name|Coverage
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
return|return
name|error
return|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|4L
argument_list|)
condition|)
goto|goto
name|Fail3
goto|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
operator|+
name|base_offset
expr_stmt|;
comment|/* `PosClassSetCount' is the upper limit for class values, thus we      read it now to make an additional safety check.                 */
name|count
operator|=
name|cpf2
operator|->
name|PosClassSetCount
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|_HB_OPEN_Load_ClassDefinition
argument_list|(
operator|&
name|cpf2
operator|->
name|ClassDef
argument_list|,
name|count
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
goto|goto
name|Fail3
goto|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
name|cpf2
operator|->
name|PosClassSet
operator|=
name|NULL
expr_stmt|;
name|cpf2
operator|->
name|MaxContextLength
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|cpf2
operator|->
name|PosClassSet
argument_list|,
name|count
argument_list|,
name|HB_PosClassSet
argument_list|)
condition|)
goto|goto
name|Fail2
goto|;
name|pcs
operator|=
name|cpf2
operator|->
name|PosClassSet
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail1
goto|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
operator|+
name|base_offset
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
if|if
condition|(
name|new_offset
operator|!=
name|base_offset
condition|)
comment|/* not a NULL offset */
block|{
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|Load_PosClassSet
argument_list|(
name|cpf2
argument_list|,
operator|&
name|pcs
index|[
name|n
index|]
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
goto|goto
name|Fail1
goto|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* we create a PosClassSet table with no entries */
name|cpf2
operator|->
name|PosClassSet
index|[
name|n
index|]
operator|.
name|PosClassRuleCount
operator|=
literal|0
expr_stmt|;
name|cpf2
operator|->
name|PosClassSet
index|[
name|n
index|]
operator|.
name|PosClassRule
operator|=
name|NULL
expr_stmt|;
block|}
block|}
return|return
name|HB_Err_Ok
return|;
name|Fail1
label|:
for|for
control|(
name|m
operator|=
literal|0
init|;
name|m
operator|<
name|n
condition|;
name|n
operator|++
control|)
name|Free_PosClassSet
argument_list|(
operator|&
name|pcs
index|[
name|m
index|]
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|pcs
argument_list|)
expr_stmt|;
name|Fail2
label|:
name|_HB_OPEN_Free_ClassDefinition
argument_list|(
operator|&
name|cpf2
operator|->
name|ClassDef
argument_list|)
expr_stmt|;
name|Fail3
label|:
name|_HB_OPEN_Free_Coverage
argument_list|(
operator|&
name|cpf2
operator|->
name|Coverage
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_function
DECL|function|Free_ContextPos2
specifier|static
name|void
name|Free_ContextPos2
parameter_list|(
name|HB_ContextPosFormat2
modifier|*
name|cpf2
parameter_list|)
block|{
name|HB_UShort
name|n
decl_stmt|,
name|count
decl_stmt|;
name|HB_PosClassSet
modifier|*
name|pcs
decl_stmt|;
if|if
condition|(
name|cpf2
operator|->
name|PosClassSet
condition|)
block|{
name|count
operator|=
name|cpf2
operator|->
name|PosClassSetCount
expr_stmt|;
name|pcs
operator|=
name|cpf2
operator|->
name|PosClassSet
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
name|Free_PosClassSet
argument_list|(
operator|&
name|pcs
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|pcs
argument_list|)
expr_stmt|;
block|}
name|_HB_OPEN_Free_ClassDefinition
argument_list|(
operator|&
name|cpf2
operator|->
name|ClassDef
argument_list|)
expr_stmt|;
name|_HB_OPEN_Free_Coverage
argument_list|(
operator|&
name|cpf2
operator|->
name|Coverage
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* ContextPosFormat3 */
end_comment
begin_function
DECL|function|Load_ContextPos3
specifier|static
name|HB_Error
name|Load_ContextPos3
parameter_list|(
name|HB_ContextPosFormat3
modifier|*
name|cpf3
parameter_list|,
name|HB_Stream
name|stream
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_UShort
name|n
decl_stmt|,
name|count
decl_stmt|;
name|HB_UInt
name|cur_offset
decl_stmt|,
name|new_offset
decl_stmt|,
name|base_offset
decl_stmt|;
name|HB_Coverage
modifier|*
name|c
decl_stmt|;
name|HB_PosLookupRecord
modifier|*
name|plr
decl_stmt|;
name|base_offset
operator|=
name|FILE_Pos
argument_list|()
operator|-
literal|2L
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|4L
argument_list|)
condition|)
return|return
name|error
return|;
name|cpf3
operator|->
name|GlyphCount
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|cpf3
operator|->
name|PosCount
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cpf3
operator|->
name|Coverage
operator|=
name|NULL
expr_stmt|;
name|count
operator|=
name|cpf3
operator|->
name|GlyphCount
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|cpf3
operator|->
name|Coverage
argument_list|,
name|count
argument_list|,
name|HB_Coverage
argument_list|)
condition|)
return|return
name|error
return|;
name|c
operator|=
name|cpf3
operator|->
name|Coverage
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail2
goto|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
operator|+
name|base_offset
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|_HB_OPEN_Load_Coverage
argument_list|(
operator|&
name|c
index|[
name|n
index|]
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
goto|goto
name|Fail2
goto|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
block|}
name|cpf3
operator|->
name|PosLookupRecord
operator|=
name|NULL
expr_stmt|;
name|count
operator|=
name|cpf3
operator|->
name|PosCount
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|cpf3
operator|->
name|PosLookupRecord
argument_list|,
name|count
argument_list|,
name|HB_PosLookupRecord
argument_list|)
condition|)
goto|goto
name|Fail2
goto|;
name|plr
operator|=
name|cpf3
operator|->
name|PosLookupRecord
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
name|count
operator|*
literal|4L
argument_list|)
condition|)
goto|goto
name|Fail1
goto|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
block|{
name|plr
index|[
name|n
index|]
operator|.
name|SequenceIndex
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|plr
index|[
name|n
index|]
operator|.
name|LookupListIndex
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
block|}
name|FORGET_Frame
argument_list|()
expr_stmt|;
return|return
name|HB_Err_Ok
return|;
name|Fail1
label|:
name|FREE
argument_list|(
name|plr
argument_list|)
expr_stmt|;
name|Fail2
label|:
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
name|_HB_OPEN_Free_Coverage
argument_list|(
operator|&
name|c
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_function
DECL|function|Free_ContextPos3
specifier|static
name|void
name|Free_ContextPos3
parameter_list|(
name|HB_ContextPosFormat3
modifier|*
name|cpf3
parameter_list|)
block|{
name|HB_UShort
name|n
decl_stmt|,
name|count
decl_stmt|;
name|HB_Coverage
modifier|*
name|c
decl_stmt|;
name|FREE
argument_list|(
name|cpf3
operator|->
name|PosLookupRecord
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpf3
operator|->
name|Coverage
condition|)
block|{
name|count
operator|=
name|cpf3
operator|->
name|GlyphCount
expr_stmt|;
name|c
operator|=
name|cpf3
operator|->
name|Coverage
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
name|_HB_OPEN_Free_Coverage
argument_list|(
operator|&
name|c
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/* ContextPos */
end_comment
begin_function
DECL|function|Load_ContextPos
specifier|static
name|HB_Error
name|Load_ContextPos
parameter_list|(
name|HB_GPOS_SubTable
modifier|*
name|st
parameter_list|,
name|HB_Stream
name|stream
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_ContextPos
modifier|*
name|cp
init|=
operator|&
name|st
operator|->
name|context
decl_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
return|return
name|error
return|;
name|cp
operator|->
name|PosFormat
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|cp
operator|->
name|PosFormat
condition|)
block|{
case|case
literal|1
case|:
return|return
name|Load_ContextPos1
argument_list|(
operator|&
name|cp
operator|->
name|cpf
operator|.
name|cpf1
argument_list|,
name|stream
argument_list|)
return|;
case|case
literal|2
case|:
return|return
name|Load_ContextPos2
argument_list|(
operator|&
name|cp
operator|->
name|cpf
operator|.
name|cpf2
argument_list|,
name|stream
argument_list|)
return|;
case|case
literal|3
case|:
return|return
name|Load_ContextPos3
argument_list|(
operator|&
name|cp
operator|->
name|cpf
operator|.
name|cpf3
argument_list|,
name|stream
argument_list|)
return|;
default|default:
return|return
name|ERR
argument_list|(
name|HB_Err_Invalid_SubTable_Format
argument_list|)
return|;
block|}
return|return
name|HB_Err_Ok
return|;
comment|/* never reached */
block|}
end_function
begin_function
DECL|function|Free_ContextPos
specifier|static
name|void
name|Free_ContextPos
parameter_list|(
name|HB_GPOS_SubTable
modifier|*
name|st
parameter_list|)
block|{
name|HB_ContextPos
modifier|*
name|cp
init|=
operator|&
name|st
operator|->
name|context
decl_stmt|;
switch|switch
condition|(
name|cp
operator|->
name|PosFormat
condition|)
block|{
case|case
literal|1
case|:
name|Free_ContextPos1
argument_list|(
operator|&
name|cp
operator|->
name|cpf
operator|.
name|cpf1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|Free_ContextPos2
argument_list|(
operator|&
name|cp
operator|->
name|cpf
operator|.
name|cpf2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|Free_ContextPos3
argument_list|(
operator|&
name|cp
operator|->
name|cpf
operator|.
name|cpf3
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function
begin_function
DECL|function|Lookup_ContextPos1
specifier|static
name|HB_Error
name|Lookup_ContextPos1
parameter_list|(
name|GPOS_Instance
modifier|*
name|gpi
parameter_list|,
name|HB_ContextPosFormat1
modifier|*
name|cpf1
parameter_list|,
name|HB_Buffer
name|buffer
parameter_list|,
name|HB_UShort
name|flags
parameter_list|,
name|HB_UShort
name|context_length
parameter_list|,
name|int
name|nesting_level
parameter_list|)
block|{
name|HB_UShort
name|index
decl_stmt|,
name|property
decl_stmt|;
name|HB_UShort
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|numpr
decl_stmt|;
name|HB_Error
name|error
decl_stmt|;
name|HB_GPOSHeader
modifier|*
name|gpos
init|=
name|gpi
operator|->
name|gpos
decl_stmt|;
name|HB_PosRule
modifier|*
name|pr
decl_stmt|;
name|HB_GDEFHeader
modifier|*
name|gdef
decl_stmt|;
name|gdef
operator|=
name|gpos
operator|->
name|gdef
expr_stmt|;
if|if
condition|(
name|CHECK_Property
argument_list|(
name|gdef
argument_list|,
name|IN_CURITEM
argument_list|()
argument_list|,
name|flags
argument_list|,
operator|&
name|property
argument_list|)
condition|)
return|return
name|error
return|;
name|error
operator|=
name|_HB_OPEN_Coverage_Index
argument_list|(
operator|&
name|cpf1
operator|->
name|Coverage
argument_list|,
name|IN_CURGLYPH
argument_list|()
argument_list|,
operator|&
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|pr
operator|=
name|cpf1
operator|->
name|PosRuleSet
index|[
name|index
index|]
operator|.
name|PosRule
expr_stmt|;
name|numpr
operator|=
name|cpf1
operator|->
name|PosRuleSet
index|[
name|index
index|]
operator|.
name|PosRuleCount
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|numpr
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|context_length
operator|!=
literal|0xFFFF
operator|&&
name|context_length
operator|<
name|pr
index|[
name|k
index|]
operator|.
name|GlyphCount
condition|)
goto|goto
name|next_posrule
goto|;
if|if
condition|(
name|buffer
operator|->
name|in_pos
operator|+
name|pr
index|[
name|k
index|]
operator|.
name|GlyphCount
operator|>
name|buffer
operator|->
name|in_length
condition|)
goto|goto
name|next_posrule
goto|;
comment|/* context is too long */
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|j
operator|=
name|buffer
operator|->
name|in_pos
operator|+
literal|1
init|;
name|i
operator|<
name|pr
index|[
name|k
index|]
operator|.
name|GlyphCount
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
while|while
condition|(
name|CHECK_Property
argument_list|(
name|gdef
argument_list|,
name|IN_ITEM
argument_list|(
name|j
argument_list|)
argument_list|,
name|flags
argument_list|,
operator|&
name|property
argument_list|)
condition|)
block|{
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|HB_Err_Not_Covered
condition|)
return|return
name|error
return|;
if|if
condition|(
name|j
operator|+
name|pr
index|[
name|k
index|]
operator|.
name|GlyphCount
operator|-
name|i
operator|==
operator|(
name|HB_Int
operator|)
name|buffer
operator|->
name|in_length
condition|)
goto|goto
name|next_posrule
goto|;
name|j
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|IN_GLYPH
argument_list|(
name|j
argument_list|)
operator|!=
name|pr
index|[
name|k
index|]
operator|.
name|Input
index|[
name|i
operator|-
literal|1
index|]
condition|)
goto|goto
name|next_posrule
goto|;
block|}
return|return
name|Do_ContextPos
argument_list|(
name|gpi
argument_list|,
name|pr
index|[
name|k
index|]
operator|.
name|GlyphCount
argument_list|,
name|pr
index|[
name|k
index|]
operator|.
name|PosCount
argument_list|,
name|pr
index|[
name|k
index|]
operator|.
name|PosLookupRecord
argument_list|,
name|buffer
argument_list|,
name|nesting_level
argument_list|)
return|;
name|next_posrule
label|:
empty_stmt|;
block|}
return|return
name|HB_Err_Not_Covered
return|;
block|}
end_function
begin_function
DECL|function|Lookup_ContextPos2
specifier|static
name|HB_Error
name|Lookup_ContextPos2
parameter_list|(
name|GPOS_Instance
modifier|*
name|gpi
parameter_list|,
name|HB_ContextPosFormat2
modifier|*
name|cpf2
parameter_list|,
name|HB_Buffer
name|buffer
parameter_list|,
name|HB_UShort
name|flags
parameter_list|,
name|HB_UShort
name|context_length
parameter_list|,
name|int
name|nesting_level
parameter_list|)
block|{
name|HB_UShort
name|index
decl_stmt|,
name|property
decl_stmt|;
name|HB_Error
name|error
decl_stmt|;
name|HB_UShort
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|known_classes
decl_stmt|;
name|HB_UShort
modifier|*
name|classes
decl_stmt|;
name|HB_UShort
modifier|*
name|cl
decl_stmt|;
name|HB_GPOSHeader
modifier|*
name|gpos
init|=
name|gpi
operator|->
name|gpos
decl_stmt|;
name|HB_PosClassSet
modifier|*
name|pcs
decl_stmt|;
name|HB_PosClassRule
modifier|*
name|pr
decl_stmt|;
name|HB_GDEFHeader
modifier|*
name|gdef
decl_stmt|;
name|gdef
operator|=
name|gpos
operator|->
name|gdef
expr_stmt|;
if|if
condition|(
name|CHECK_Property
argument_list|(
name|gdef
argument_list|,
name|IN_CURITEM
argument_list|()
argument_list|,
name|flags
argument_list|,
operator|&
name|property
argument_list|)
condition|)
return|return
name|error
return|;
comment|/* Note: The coverage table in format 2 doesn't give an index into 	   anything.  It just lets us know whether or not we need to 	   do any lookup at all.                                     */
name|error
operator|=
name|_HB_OPEN_Coverage_Index
argument_list|(
operator|&
name|cpf2
operator|->
name|Coverage
argument_list|,
name|IN_CURGLYPH
argument_list|()
argument_list|,
operator|&
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
name|cpf2
operator|->
name|MaxContextLength
operator|<
literal|1
condition|)
return|return
name|HB_Err_Not_Covered
return|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|classes
argument_list|,
name|cpf2
operator|->
name|MaxContextLength
argument_list|,
name|HB_UShort
argument_list|)
condition|)
return|return
name|error
return|;
name|error
operator|=
name|_HB_OPEN_Get_Class
argument_list|(
operator|&
name|cpf2
operator|->
name|ClassDef
argument_list|,
name|IN_CURGLYPH
argument_list|()
argument_list|,
operator|&
name|classes
index|[
literal|0
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|HB_Err_Not_Covered
condition|)
goto|goto
name|End
goto|;
name|known_classes
operator|=
literal|0
expr_stmt|;
name|pcs
operator|=
operator|&
name|cpf2
operator|->
name|PosClassSet
index|[
name|classes
index|[
literal|0
index|]
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|pcs
condition|)
block|{
name|error
operator|=
name|ERR
argument_list|(
name|HB_Err_Invalid_SubTable
argument_list|)
expr_stmt|;
goto|goto
name|End
goto|;
block|}
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|pcs
operator|->
name|PosClassRuleCount
condition|;
name|k
operator|++
control|)
block|{
name|pr
operator|=
operator|&
name|pcs
operator|->
name|PosClassRule
index|[
name|k
index|]
expr_stmt|;
if|if
condition|(
name|context_length
operator|!=
literal|0xFFFF
operator|&&
name|context_length
operator|<
name|pr
operator|->
name|GlyphCount
condition|)
goto|goto
name|next_posclassrule
goto|;
if|if
condition|(
name|buffer
operator|->
name|in_pos
operator|+
name|pr
operator|->
name|GlyphCount
operator|>
name|buffer
operator|->
name|in_length
condition|)
goto|goto
name|next_posclassrule
goto|;
comment|/* context is too long */
name|cl
operator|=
name|pr
operator|->
name|Class
expr_stmt|;
comment|/* Start at 1 because [0] is implied */
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|j
operator|=
name|buffer
operator|->
name|in_pos
operator|+
literal|1
init|;
name|i
operator|<
name|pr
operator|->
name|GlyphCount
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
while|while
condition|(
name|CHECK_Property
argument_list|(
name|gdef
argument_list|,
name|IN_ITEM
argument_list|(
name|j
argument_list|)
argument_list|,
name|flags
argument_list|,
operator|&
name|property
argument_list|)
condition|)
block|{
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|HB_Err_Not_Covered
condition|)
goto|goto
name|End
goto|;
if|if
condition|(
name|j
operator|+
name|pr
operator|->
name|GlyphCount
operator|-
name|i
operator|==
operator|(
name|HB_Int
operator|)
name|buffer
operator|->
name|in_length
condition|)
goto|goto
name|next_posclassrule
goto|;
name|j
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>
name|known_classes
condition|)
block|{
comment|/* Keeps us from having to do this for each rule */
name|error
operator|=
name|_HB_OPEN_Get_Class
argument_list|(
operator|&
name|cpf2
operator|->
name|ClassDef
argument_list|,
name|IN_GLYPH
argument_list|(
name|j
argument_list|)
argument_list|,
operator|&
name|classes
index|[
name|i
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|HB_Err_Not_Covered
condition|)
goto|goto
name|End
goto|;
name|known_classes
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|cl
index|[
name|i
operator|-
literal|1
index|]
operator|!=
name|classes
index|[
name|i
index|]
condition|)
goto|goto
name|next_posclassrule
goto|;
block|}
name|error
operator|=
name|Do_ContextPos
argument_list|(
name|gpi
argument_list|,
name|pr
operator|->
name|GlyphCount
argument_list|,
name|pr
operator|->
name|PosCount
argument_list|,
name|pr
operator|->
name|PosLookupRecord
argument_list|,
name|buffer
argument_list|,
name|nesting_level
argument_list|)
expr_stmt|;
goto|goto
name|End
goto|;
name|next_posclassrule
label|:
empty_stmt|;
block|}
name|error
operator|=
name|HB_Err_Not_Covered
expr_stmt|;
name|End
label|:
name|FREE
argument_list|(
name|classes
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_function
DECL|function|Lookup_ContextPos3
specifier|static
name|HB_Error
name|Lookup_ContextPos3
parameter_list|(
name|GPOS_Instance
modifier|*
name|gpi
parameter_list|,
name|HB_ContextPosFormat3
modifier|*
name|cpf3
parameter_list|,
name|HB_Buffer
name|buffer
parameter_list|,
name|HB_UShort
name|flags
parameter_list|,
name|HB_UShort
name|context_length
parameter_list|,
name|int
name|nesting_level
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_UShort
name|index
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|property
decl_stmt|;
name|HB_GPOSHeader
modifier|*
name|gpos
init|=
name|gpi
operator|->
name|gpos
decl_stmt|;
name|HB_Coverage
modifier|*
name|c
decl_stmt|;
name|HB_GDEFHeader
modifier|*
name|gdef
decl_stmt|;
name|gdef
operator|=
name|gpos
operator|->
name|gdef
expr_stmt|;
if|if
condition|(
name|CHECK_Property
argument_list|(
name|gdef
argument_list|,
name|IN_CURITEM
argument_list|()
argument_list|,
name|flags
argument_list|,
operator|&
name|property
argument_list|)
condition|)
return|return
name|error
return|;
if|if
condition|(
name|context_length
operator|!=
literal|0xFFFF
operator|&&
name|context_length
operator|<
name|cpf3
operator|->
name|GlyphCount
condition|)
return|return
name|HB_Err_Not_Covered
return|;
if|if
condition|(
name|buffer
operator|->
name|in_pos
operator|+
name|cpf3
operator|->
name|GlyphCount
operator|>
name|buffer
operator|->
name|in_length
condition|)
return|return
name|HB_Err_Not_Covered
return|;
comment|/* context is too long */
name|c
operator|=
name|cpf3
operator|->
name|Coverage
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|j
operator|=
literal|1
init|;
name|i
operator|<
name|cpf3
operator|->
name|GlyphCount
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
while|while
condition|(
name|CHECK_Property
argument_list|(
name|gdef
argument_list|,
name|IN_ITEM
argument_list|(
name|j
argument_list|)
argument_list|,
name|flags
argument_list|,
operator|&
name|property
argument_list|)
condition|)
block|{
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|HB_Err_Not_Covered
condition|)
return|return
name|error
return|;
if|if
condition|(
name|j
operator|+
name|cpf3
operator|->
name|GlyphCount
operator|-
name|i
operator|==
operator|(
name|HB_Int
operator|)
name|buffer
operator|->
name|in_length
condition|)
return|return
name|HB_Err_Not_Covered
return|;
name|j
operator|++
expr_stmt|;
block|}
name|error
operator|=
name|_HB_OPEN_Coverage_Index
argument_list|(
operator|&
name|c
index|[
name|i
index|]
argument_list|,
name|IN_GLYPH
argument_list|(
name|j
argument_list|)
argument_list|,
operator|&
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
block|}
return|return
name|Do_ContextPos
argument_list|(
name|gpi
argument_list|,
name|cpf3
operator|->
name|GlyphCount
argument_list|,
name|cpf3
operator|->
name|PosCount
argument_list|,
name|cpf3
operator|->
name|PosLookupRecord
argument_list|,
name|buffer
argument_list|,
name|nesting_level
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|Lookup_ContextPos
specifier|static
name|HB_Error
name|Lookup_ContextPos
parameter_list|(
name|GPOS_Instance
modifier|*
name|gpi
parameter_list|,
name|HB_GPOS_SubTable
modifier|*
name|st
parameter_list|,
name|HB_Buffer
name|buffer
parameter_list|,
name|HB_UShort
name|flags
parameter_list|,
name|HB_UShort
name|context_length
parameter_list|,
name|int
name|nesting_level
parameter_list|)
block|{
name|HB_ContextPos
modifier|*
name|cp
init|=
operator|&
name|st
operator|->
name|context
decl_stmt|;
switch|switch
condition|(
name|cp
operator|->
name|PosFormat
condition|)
block|{
case|case
literal|1
case|:
return|return
name|Lookup_ContextPos1
argument_list|(
name|gpi
argument_list|,
operator|&
name|cp
operator|->
name|cpf
operator|.
name|cpf1
argument_list|,
name|buffer
argument_list|,
name|flags
argument_list|,
name|context_length
argument_list|,
name|nesting_level
argument_list|)
return|;
case|case
literal|2
case|:
return|return
name|Lookup_ContextPos2
argument_list|(
name|gpi
argument_list|,
operator|&
name|cp
operator|->
name|cpf
operator|.
name|cpf2
argument_list|,
name|buffer
argument_list|,
name|flags
argument_list|,
name|context_length
argument_list|,
name|nesting_level
argument_list|)
return|;
case|case
literal|3
case|:
return|return
name|Lookup_ContextPos3
argument_list|(
name|gpi
argument_list|,
operator|&
name|cp
operator|->
name|cpf
operator|.
name|cpf3
argument_list|,
name|buffer
argument_list|,
name|flags
argument_list|,
name|context_length
argument_list|,
name|nesting_level
argument_list|)
return|;
default|default:
return|return
name|ERR
argument_list|(
name|HB_Err_Invalid_SubTable_Format
argument_list|)
return|;
block|}
return|return
name|HB_Err_Ok
return|;
comment|/* never reached */
block|}
end_function
begin_comment
comment|/* LookupType 8 */
end_comment
begin_comment
comment|/* ChainPosRule */
end_comment
begin_function
DECL|function|Load_ChainPosRule
specifier|static
name|HB_Error
name|Load_ChainPosRule
parameter_list|(
name|HB_ChainPosRule
modifier|*
name|cpr
parameter_list|,
name|HB_Stream
name|stream
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_UShort
name|n
decl_stmt|,
name|count
decl_stmt|;
name|HB_UShort
modifier|*
name|b
decl_stmt|;
name|HB_UShort
modifier|*
name|i
decl_stmt|;
name|HB_UShort
modifier|*
name|l
decl_stmt|;
name|HB_PosLookupRecord
modifier|*
name|plr
decl_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
return|return
name|error
return|;
name|cpr
operator|->
name|BacktrackGlyphCount
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cpr
operator|->
name|Backtrack
operator|=
name|NULL
expr_stmt|;
name|count
operator|=
name|cpr
operator|->
name|BacktrackGlyphCount
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|cpr
operator|->
name|Backtrack
argument_list|,
name|count
argument_list|,
name|HB_UShort
argument_list|)
condition|)
return|return
name|error
return|;
name|b
operator|=
name|cpr
operator|->
name|Backtrack
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
name|count
operator|*
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail4
goto|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
name|b
index|[
name|n
index|]
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail4
goto|;
name|cpr
operator|->
name|InputGlyphCount
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cpr
operator|->
name|Input
operator|=
name|NULL
expr_stmt|;
name|count
operator|=
name|cpr
operator|->
name|InputGlyphCount
operator|-
literal|1
expr_stmt|;
comment|/* only InputGlyphCount - 1 elements */
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|cpr
operator|->
name|Input
argument_list|,
name|count
argument_list|,
name|HB_UShort
argument_list|)
condition|)
goto|goto
name|Fail4
goto|;
name|i
operator|=
name|cpr
operator|->
name|Input
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
name|count
operator|*
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail3
goto|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
name|i
index|[
name|n
index|]
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail3
goto|;
name|cpr
operator|->
name|LookaheadGlyphCount
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cpr
operator|->
name|Lookahead
operator|=
name|NULL
expr_stmt|;
name|count
operator|=
name|cpr
operator|->
name|LookaheadGlyphCount
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|cpr
operator|->
name|Lookahead
argument_list|,
name|count
argument_list|,
name|HB_UShort
argument_list|)
condition|)
goto|goto
name|Fail3
goto|;
name|l
operator|=
name|cpr
operator|->
name|Lookahead
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
name|count
operator|*
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail2
goto|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
name|l
index|[
name|n
index|]
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail2
goto|;
name|cpr
operator|->
name|PosCount
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cpr
operator|->
name|PosLookupRecord
operator|=
name|NULL
expr_stmt|;
name|count
operator|=
name|cpr
operator|->
name|PosCount
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|cpr
operator|->
name|PosLookupRecord
argument_list|,
name|count
argument_list|,
name|HB_PosLookupRecord
argument_list|)
condition|)
goto|goto
name|Fail2
goto|;
name|plr
operator|=
name|cpr
operator|->
name|PosLookupRecord
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
name|count
operator|*
literal|4L
argument_list|)
condition|)
goto|goto
name|Fail1
goto|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
block|{
name|plr
index|[
name|n
index|]
operator|.
name|SequenceIndex
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|plr
index|[
name|n
index|]
operator|.
name|LookupListIndex
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
block|}
name|FORGET_Frame
argument_list|()
expr_stmt|;
return|return
name|HB_Err_Ok
return|;
name|Fail1
label|:
name|FREE
argument_list|(
name|plr
argument_list|)
expr_stmt|;
name|Fail2
label|:
name|FREE
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|Fail3
label|:
name|FREE
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|Fail4
label|:
name|FREE
argument_list|(
name|b
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_function
DECL|function|Free_ChainPosRule
specifier|static
name|void
name|Free_ChainPosRule
parameter_list|(
name|HB_ChainPosRule
modifier|*
name|cpr
parameter_list|)
block|{
name|FREE
argument_list|(
name|cpr
operator|->
name|PosLookupRecord
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|cpr
operator|->
name|Lookahead
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|cpr
operator|->
name|Input
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|cpr
operator|->
name|Backtrack
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* ChainPosRuleSet */
end_comment
begin_function
DECL|function|Load_ChainPosRuleSet
specifier|static
name|HB_Error
name|Load_ChainPosRuleSet
parameter_list|(
name|HB_ChainPosRuleSet
modifier|*
name|cprs
parameter_list|,
name|HB_Stream
name|stream
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_UShort
name|n
decl_stmt|,
name|m
decl_stmt|,
name|count
decl_stmt|;
name|HB_UInt
name|cur_offset
decl_stmt|,
name|new_offset
decl_stmt|,
name|base_offset
decl_stmt|;
name|HB_ChainPosRule
modifier|*
name|cpr
decl_stmt|;
name|base_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
return|return
name|error
return|;
name|count
operator|=
name|cprs
operator|->
name|ChainPosRuleCount
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cprs
operator|->
name|ChainPosRule
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|cprs
operator|->
name|ChainPosRule
argument_list|,
name|count
argument_list|,
name|HB_ChainPosRule
argument_list|)
condition|)
return|return
name|error
return|;
name|cpr
operator|=
name|cprs
operator|->
name|ChainPosRule
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
operator|+
name|base_offset
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|Load_ChainPosRule
argument_list|(
operator|&
name|cpr
index|[
name|n
index|]
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
goto|goto
name|Fail
goto|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
block|}
return|return
name|HB_Err_Ok
return|;
name|Fail
label|:
for|for
control|(
name|m
operator|=
literal|0
init|;
name|m
operator|<
name|n
condition|;
name|m
operator|++
control|)
name|Free_ChainPosRule
argument_list|(
operator|&
name|cpr
index|[
name|m
index|]
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|cpr
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_function
DECL|function|Free_ChainPosRuleSet
specifier|static
name|void
name|Free_ChainPosRuleSet
parameter_list|(
name|HB_ChainPosRuleSet
modifier|*
name|cprs
parameter_list|)
block|{
name|HB_UShort
name|n
decl_stmt|,
name|count
decl_stmt|;
name|HB_ChainPosRule
modifier|*
name|cpr
decl_stmt|;
if|if
condition|(
name|cprs
operator|->
name|ChainPosRule
condition|)
block|{
name|count
operator|=
name|cprs
operator|->
name|ChainPosRuleCount
expr_stmt|;
name|cpr
operator|=
name|cprs
operator|->
name|ChainPosRule
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
name|Free_ChainPosRule
argument_list|(
operator|&
name|cpr
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|cpr
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/* ChainContextPosFormat1 */
end_comment
begin_function
DECL|function|Load_ChainContextPos1
specifier|static
name|HB_Error
name|Load_ChainContextPos1
parameter_list|(
name|HB_ChainContextPosFormat1
modifier|*
name|ccpf1
parameter_list|,
name|HB_Stream
name|stream
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_UShort
name|n
decl_stmt|,
name|m
decl_stmt|,
name|count
decl_stmt|;
name|HB_UInt
name|cur_offset
decl_stmt|,
name|new_offset
decl_stmt|,
name|base_offset
decl_stmt|;
name|HB_ChainPosRuleSet
modifier|*
name|cprs
decl_stmt|;
name|base_offset
operator|=
name|FILE_Pos
argument_list|()
operator|-
literal|2L
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
return|return
name|error
return|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
operator|+
name|base_offset
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|_HB_OPEN_Load_Coverage
argument_list|(
operator|&
name|ccpf1
operator|->
name|Coverage
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
return|return
name|error
return|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail2
goto|;
name|count
operator|=
name|ccpf1
operator|->
name|ChainPosRuleSetCount
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|ccpf1
operator|->
name|ChainPosRuleSet
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|ccpf1
operator|->
name|ChainPosRuleSet
argument_list|,
name|count
argument_list|,
name|HB_ChainPosRuleSet
argument_list|)
condition|)
goto|goto
name|Fail2
goto|;
name|cprs
operator|=
name|ccpf1
operator|->
name|ChainPosRuleSet
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail1
goto|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
operator|+
name|base_offset
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|Load_ChainPosRuleSet
argument_list|(
operator|&
name|cprs
index|[
name|n
index|]
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
goto|goto
name|Fail1
goto|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
block|}
return|return
name|HB_Err_Ok
return|;
name|Fail1
label|:
for|for
control|(
name|m
operator|=
literal|0
init|;
name|m
operator|<
name|n
condition|;
name|m
operator|++
control|)
name|Free_ChainPosRuleSet
argument_list|(
operator|&
name|cprs
index|[
name|m
index|]
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|cprs
argument_list|)
expr_stmt|;
name|Fail2
label|:
name|_HB_OPEN_Free_Coverage
argument_list|(
operator|&
name|ccpf1
operator|->
name|Coverage
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_function
DECL|function|Free_ChainContextPos1
specifier|static
name|void
name|Free_ChainContextPos1
parameter_list|(
name|HB_ChainContextPosFormat1
modifier|*
name|ccpf1
parameter_list|)
block|{
name|HB_UShort
name|n
decl_stmt|,
name|count
decl_stmt|;
name|HB_ChainPosRuleSet
modifier|*
name|cprs
decl_stmt|;
if|if
condition|(
name|ccpf1
operator|->
name|ChainPosRuleSet
condition|)
block|{
name|count
operator|=
name|ccpf1
operator|->
name|ChainPosRuleSetCount
expr_stmt|;
name|cprs
operator|=
name|ccpf1
operator|->
name|ChainPosRuleSet
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
name|Free_ChainPosRuleSet
argument_list|(
operator|&
name|cprs
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|cprs
argument_list|)
expr_stmt|;
block|}
name|_HB_OPEN_Free_Coverage
argument_list|(
operator|&
name|ccpf1
operator|->
name|Coverage
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* ChainPosClassRule */
end_comment
begin_function
DECL|function|Load_ChainPosClassRule
specifier|static
name|HB_Error
name|Load_ChainPosClassRule
parameter_list|(
name|HB_ChainContextPosFormat2
modifier|*
name|ccpf2
parameter_list|,
name|HB_ChainPosClassRule
modifier|*
name|cpcr
parameter_list|,
name|HB_Stream
name|stream
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_UShort
name|n
decl_stmt|,
name|count
decl_stmt|;
name|HB_UShort
modifier|*
name|b
decl_stmt|;
name|HB_UShort
modifier|*
name|i
decl_stmt|;
name|HB_UShort
modifier|*
name|l
decl_stmt|;
name|HB_PosLookupRecord
modifier|*
name|plr
decl_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
return|return
name|error
return|;
name|cpcr
operator|->
name|BacktrackGlyphCount
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
if|if
condition|(
name|cpcr
operator|->
name|BacktrackGlyphCount
operator|>
name|ccpf2
operator|->
name|MaxBacktrackLength
condition|)
name|ccpf2
operator|->
name|MaxBacktrackLength
operator|=
name|cpcr
operator|->
name|BacktrackGlyphCount
expr_stmt|;
name|cpcr
operator|->
name|Backtrack
operator|=
name|NULL
expr_stmt|;
name|count
operator|=
name|cpcr
operator|->
name|BacktrackGlyphCount
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|cpcr
operator|->
name|Backtrack
argument_list|,
name|count
argument_list|,
name|HB_UShort
argument_list|)
condition|)
return|return
name|error
return|;
name|b
operator|=
name|cpcr
operator|->
name|Backtrack
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
name|count
operator|*
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail4
goto|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
name|b
index|[
name|n
index|]
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail4
goto|;
name|cpcr
operator|->
name|InputGlyphCount
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
if|if
condition|(
name|cpcr
operator|->
name|InputGlyphCount
operator|>
name|ccpf2
operator|->
name|MaxInputLength
condition|)
name|ccpf2
operator|->
name|MaxInputLength
operator|=
name|cpcr
operator|->
name|InputGlyphCount
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cpcr
operator|->
name|Input
operator|=
name|NULL
expr_stmt|;
name|count
operator|=
name|cpcr
operator|->
name|InputGlyphCount
operator|-
literal|1
expr_stmt|;
comment|/* only InputGlyphCount - 1 elements */
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|cpcr
operator|->
name|Input
argument_list|,
name|count
argument_list|,
name|HB_UShort
argument_list|)
condition|)
goto|goto
name|Fail4
goto|;
name|i
operator|=
name|cpcr
operator|->
name|Input
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
name|count
operator|*
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail3
goto|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
name|i
index|[
name|n
index|]
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail3
goto|;
name|cpcr
operator|->
name|LookaheadGlyphCount
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
if|if
condition|(
name|cpcr
operator|->
name|LookaheadGlyphCount
operator|>
name|ccpf2
operator|->
name|MaxLookaheadLength
condition|)
name|ccpf2
operator|->
name|MaxLookaheadLength
operator|=
name|cpcr
operator|->
name|LookaheadGlyphCount
expr_stmt|;
name|cpcr
operator|->
name|Lookahead
operator|=
name|NULL
expr_stmt|;
name|count
operator|=
name|cpcr
operator|->
name|LookaheadGlyphCount
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|cpcr
operator|->
name|Lookahead
argument_list|,
name|count
argument_list|,
name|HB_UShort
argument_list|)
condition|)
goto|goto
name|Fail3
goto|;
name|l
operator|=
name|cpcr
operator|->
name|Lookahead
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
name|count
operator|*
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail2
goto|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
name|l
index|[
name|n
index|]
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail2
goto|;
name|cpcr
operator|->
name|PosCount
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cpcr
operator|->
name|PosLookupRecord
operator|=
name|NULL
expr_stmt|;
name|count
operator|=
name|cpcr
operator|->
name|PosCount
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|cpcr
operator|->
name|PosLookupRecord
argument_list|,
name|count
argument_list|,
name|HB_PosLookupRecord
argument_list|)
condition|)
goto|goto
name|Fail2
goto|;
name|plr
operator|=
name|cpcr
operator|->
name|PosLookupRecord
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
name|count
operator|*
literal|4L
argument_list|)
condition|)
goto|goto
name|Fail1
goto|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
block|{
name|plr
index|[
name|n
index|]
operator|.
name|SequenceIndex
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|plr
index|[
name|n
index|]
operator|.
name|LookupListIndex
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
block|}
name|FORGET_Frame
argument_list|()
expr_stmt|;
return|return
name|HB_Err_Ok
return|;
name|Fail1
label|:
name|FREE
argument_list|(
name|plr
argument_list|)
expr_stmt|;
name|Fail2
label|:
name|FREE
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|Fail3
label|:
name|FREE
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|Fail4
label|:
name|FREE
argument_list|(
name|b
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_function
DECL|function|Free_ChainPosClassRule
specifier|static
name|void
name|Free_ChainPosClassRule
parameter_list|(
name|HB_ChainPosClassRule
modifier|*
name|cpcr
parameter_list|)
block|{
name|FREE
argument_list|(
name|cpcr
operator|->
name|PosLookupRecord
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|cpcr
operator|->
name|Lookahead
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|cpcr
operator|->
name|Input
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|cpcr
operator|->
name|Backtrack
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* PosClassSet */
end_comment
begin_function
DECL|function|Load_ChainPosClassSet
specifier|static
name|HB_Error
name|Load_ChainPosClassSet
parameter_list|(
name|HB_ChainContextPosFormat2
modifier|*
name|ccpf2
parameter_list|,
name|HB_ChainPosClassSet
modifier|*
name|cpcs
parameter_list|,
name|HB_Stream
name|stream
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_UShort
name|n
decl_stmt|,
name|m
decl_stmt|,
name|count
decl_stmt|;
name|HB_UInt
name|cur_offset
decl_stmt|,
name|new_offset
decl_stmt|,
name|base_offset
decl_stmt|;
name|HB_ChainPosClassRule
modifier|*
name|cpcr
decl_stmt|;
name|base_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
return|return
name|error
return|;
name|count
operator|=
name|cpcs
operator|->
name|ChainPosClassRuleCount
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cpcs
operator|->
name|ChainPosClassRule
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|cpcs
operator|->
name|ChainPosClassRule
argument_list|,
name|count
argument_list|,
name|HB_ChainPosClassRule
argument_list|)
condition|)
return|return
name|error
return|;
name|cpcr
operator|=
name|cpcs
operator|->
name|ChainPosClassRule
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
operator|+
name|base_offset
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|Load_ChainPosClassRule
argument_list|(
name|ccpf2
argument_list|,
operator|&
name|cpcr
index|[
name|n
index|]
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
goto|goto
name|Fail
goto|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
block|}
return|return
name|HB_Err_Ok
return|;
name|Fail
label|:
for|for
control|(
name|m
operator|=
literal|0
init|;
name|m
operator|<
name|n
condition|;
name|m
operator|++
control|)
name|Free_ChainPosClassRule
argument_list|(
operator|&
name|cpcr
index|[
name|m
index|]
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|cpcr
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_function
DECL|function|Free_ChainPosClassSet
specifier|static
name|void
name|Free_ChainPosClassSet
parameter_list|(
name|HB_ChainPosClassSet
modifier|*
name|cpcs
parameter_list|)
block|{
name|HB_UShort
name|n
decl_stmt|,
name|count
decl_stmt|;
name|HB_ChainPosClassRule
modifier|*
name|cpcr
decl_stmt|;
if|if
condition|(
name|cpcs
operator|->
name|ChainPosClassRule
condition|)
block|{
name|count
operator|=
name|cpcs
operator|->
name|ChainPosClassRuleCount
expr_stmt|;
name|cpcr
operator|=
name|cpcs
operator|->
name|ChainPosClassRule
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
name|Free_ChainPosClassRule
argument_list|(
operator|&
name|cpcr
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|cpcr
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/* ChainContextPosFormat2 */
end_comment
begin_function
DECL|function|Load_ChainContextPos2
specifier|static
name|HB_Error
name|Load_ChainContextPos2
parameter_list|(
name|HB_ChainContextPosFormat2
modifier|*
name|ccpf2
parameter_list|,
name|HB_Stream
name|stream
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_UShort
name|n
decl_stmt|,
name|m
decl_stmt|,
name|count
decl_stmt|;
name|HB_UInt
name|cur_offset
decl_stmt|,
name|new_offset
decl_stmt|,
name|base_offset
decl_stmt|;
name|HB_UInt
name|backtrack_offset
decl_stmt|,
name|input_offset
decl_stmt|,
name|lookahead_offset
decl_stmt|;
name|HB_ChainPosClassSet
modifier|*
name|cpcs
decl_stmt|;
name|base_offset
operator|=
name|FILE_Pos
argument_list|()
operator|-
literal|2
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
return|return
name|error
return|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
operator|+
name|base_offset
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|_HB_OPEN_Load_Coverage
argument_list|(
operator|&
name|ccpf2
operator|->
name|Coverage
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
return|return
name|error
return|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|8L
argument_list|)
condition|)
goto|goto
name|Fail5
goto|;
name|backtrack_offset
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|input_offset
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|lookahead_offset
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
comment|/* `ChainPosClassSetCount' is the upper limit for input class values,      thus we read it now to make an additional safety check. No limit      is known or needed for the other two class definitions          */
name|count
operator|=
name|ccpf2
operator|->
name|ChainPosClassSetCount
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|_HB_OPEN_Load_EmptyOrClassDefinition
argument_list|(
operator|&
name|ccpf2
operator|->
name|BacktrackClassDef
argument_list|,
literal|65535
argument_list|,
name|backtrack_offset
argument_list|,
name|base_offset
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
goto|goto
name|Fail5
goto|;
if|if
condition|(
operator|(
name|error
operator|=
name|_HB_OPEN_Load_EmptyOrClassDefinition
argument_list|(
operator|&
name|ccpf2
operator|->
name|InputClassDef
argument_list|,
name|count
argument_list|,
name|input_offset
argument_list|,
name|base_offset
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
goto|goto
name|Fail4
goto|;
if|if
condition|(
operator|(
name|error
operator|=
name|_HB_OPEN_Load_EmptyOrClassDefinition
argument_list|(
operator|&
name|ccpf2
operator|->
name|LookaheadClassDef
argument_list|,
literal|65535
argument_list|,
name|lookahead_offset
argument_list|,
name|base_offset
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
goto|goto
name|Fail3
goto|;
name|ccpf2
operator|->
name|ChainPosClassSet
operator|=
name|NULL
expr_stmt|;
name|ccpf2
operator|->
name|MaxBacktrackLength
operator|=
literal|0
expr_stmt|;
name|ccpf2
operator|->
name|MaxInputLength
operator|=
literal|0
expr_stmt|;
name|ccpf2
operator|->
name|MaxLookaheadLength
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|ccpf2
operator|->
name|ChainPosClassSet
argument_list|,
name|count
argument_list|,
name|HB_ChainPosClassSet
argument_list|)
condition|)
goto|goto
name|Fail2
goto|;
name|cpcs
operator|=
name|ccpf2
operator|->
name|ChainPosClassSet
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail1
goto|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
operator|+
name|base_offset
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
if|if
condition|(
name|new_offset
operator|!=
name|base_offset
condition|)
comment|/* not a NULL offset */
block|{
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|Load_ChainPosClassSet
argument_list|(
name|ccpf2
argument_list|,
operator|&
name|cpcs
index|[
name|n
index|]
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
goto|goto
name|Fail1
goto|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* we create a ChainPosClassSet table with no entries */
name|ccpf2
operator|->
name|ChainPosClassSet
index|[
name|n
index|]
operator|.
name|ChainPosClassRuleCount
operator|=
literal|0
expr_stmt|;
name|ccpf2
operator|->
name|ChainPosClassSet
index|[
name|n
index|]
operator|.
name|ChainPosClassRule
operator|=
name|NULL
expr_stmt|;
block|}
block|}
return|return
name|HB_Err_Ok
return|;
name|Fail1
label|:
for|for
control|(
name|m
operator|=
literal|0
init|;
name|m
operator|<
name|n
condition|;
name|m
operator|++
control|)
name|Free_ChainPosClassSet
argument_list|(
operator|&
name|cpcs
index|[
name|m
index|]
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|cpcs
argument_list|)
expr_stmt|;
name|Fail2
label|:
name|_HB_OPEN_Free_ClassDefinition
argument_list|(
operator|&
name|ccpf2
operator|->
name|LookaheadClassDef
argument_list|)
expr_stmt|;
name|Fail3
label|:
name|_HB_OPEN_Free_ClassDefinition
argument_list|(
operator|&
name|ccpf2
operator|->
name|InputClassDef
argument_list|)
expr_stmt|;
name|Fail4
label|:
name|_HB_OPEN_Free_ClassDefinition
argument_list|(
operator|&
name|ccpf2
operator|->
name|BacktrackClassDef
argument_list|)
expr_stmt|;
name|Fail5
label|:
name|_HB_OPEN_Free_Coverage
argument_list|(
operator|&
name|ccpf2
operator|->
name|Coverage
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_function
DECL|function|Free_ChainContextPos2
specifier|static
name|void
name|Free_ChainContextPos2
parameter_list|(
name|HB_ChainContextPosFormat2
modifier|*
name|ccpf2
parameter_list|)
block|{
name|HB_UShort
name|n
decl_stmt|,
name|count
decl_stmt|;
name|HB_ChainPosClassSet
modifier|*
name|cpcs
decl_stmt|;
if|if
condition|(
name|ccpf2
operator|->
name|ChainPosClassSet
condition|)
block|{
name|count
operator|=
name|ccpf2
operator|->
name|ChainPosClassSetCount
expr_stmt|;
name|cpcs
operator|=
name|ccpf2
operator|->
name|ChainPosClassSet
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
name|Free_ChainPosClassSet
argument_list|(
operator|&
name|cpcs
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|cpcs
argument_list|)
expr_stmt|;
block|}
name|_HB_OPEN_Free_ClassDefinition
argument_list|(
operator|&
name|ccpf2
operator|->
name|LookaheadClassDef
argument_list|)
expr_stmt|;
name|_HB_OPEN_Free_ClassDefinition
argument_list|(
operator|&
name|ccpf2
operator|->
name|InputClassDef
argument_list|)
expr_stmt|;
name|_HB_OPEN_Free_ClassDefinition
argument_list|(
operator|&
name|ccpf2
operator|->
name|BacktrackClassDef
argument_list|)
expr_stmt|;
name|_HB_OPEN_Free_Coverage
argument_list|(
operator|&
name|ccpf2
operator|->
name|Coverage
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* ChainContextPosFormat3 */
end_comment
begin_function
DECL|function|Load_ChainContextPos3
specifier|static
name|HB_Error
name|Load_ChainContextPos3
parameter_list|(
name|HB_ChainContextPosFormat3
modifier|*
name|ccpf3
parameter_list|,
name|HB_Stream
name|stream
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_UShort
name|n
decl_stmt|,
name|nb
decl_stmt|,
name|ni
decl_stmt|,
name|nl
decl_stmt|,
name|m
decl_stmt|,
name|count
decl_stmt|;
name|HB_UShort
name|backtrack_count
decl_stmt|,
name|input_count
decl_stmt|,
name|lookahead_count
decl_stmt|;
name|HB_UInt
name|cur_offset
decl_stmt|,
name|new_offset
decl_stmt|,
name|base_offset
decl_stmt|;
name|HB_Coverage
modifier|*
name|b
decl_stmt|;
name|HB_Coverage
modifier|*
name|i
decl_stmt|;
name|HB_Coverage
modifier|*
name|l
decl_stmt|;
name|HB_PosLookupRecord
modifier|*
name|plr
decl_stmt|;
name|base_offset
operator|=
name|FILE_Pos
argument_list|()
operator|-
literal|2L
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
return|return
name|error
return|;
name|ccpf3
operator|->
name|BacktrackGlyphCount
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|ccpf3
operator|->
name|BacktrackCoverage
operator|=
name|NULL
expr_stmt|;
name|backtrack_count
operator|=
name|ccpf3
operator|->
name|BacktrackGlyphCount
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|ccpf3
operator|->
name|BacktrackCoverage
argument_list|,
name|backtrack_count
argument_list|,
name|HB_Coverage
argument_list|)
condition|)
return|return
name|error
return|;
name|b
operator|=
name|ccpf3
operator|->
name|BacktrackCoverage
expr_stmt|;
for|for
control|(
name|nb
operator|=
literal|0
init|;
name|nb
operator|<
name|backtrack_count
condition|;
name|nb
operator|++
control|)
block|{
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail4
goto|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
operator|+
name|base_offset
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|_HB_OPEN_Load_Coverage
argument_list|(
operator|&
name|b
index|[
name|nb
index|]
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
goto|goto
name|Fail4
goto|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail4
goto|;
name|ccpf3
operator|->
name|InputGlyphCount
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|ccpf3
operator|->
name|InputCoverage
operator|=
name|NULL
expr_stmt|;
name|input_count
operator|=
name|ccpf3
operator|->
name|InputGlyphCount
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|ccpf3
operator|->
name|InputCoverage
argument_list|,
name|input_count
argument_list|,
name|HB_Coverage
argument_list|)
condition|)
goto|goto
name|Fail4
goto|;
name|i
operator|=
name|ccpf3
operator|->
name|InputCoverage
expr_stmt|;
for|for
control|(
name|ni
operator|=
literal|0
init|;
name|ni
operator|<
name|input_count
condition|;
name|ni
operator|++
control|)
block|{
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail3
goto|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
operator|+
name|base_offset
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|_HB_OPEN_Load_Coverage
argument_list|(
operator|&
name|i
index|[
name|ni
index|]
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
goto|goto
name|Fail3
goto|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail3
goto|;
name|ccpf3
operator|->
name|LookaheadGlyphCount
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|ccpf3
operator|->
name|LookaheadCoverage
operator|=
name|NULL
expr_stmt|;
name|lookahead_count
operator|=
name|ccpf3
operator|->
name|LookaheadGlyphCount
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|ccpf3
operator|->
name|LookaheadCoverage
argument_list|,
name|lookahead_count
argument_list|,
name|HB_Coverage
argument_list|)
condition|)
goto|goto
name|Fail3
goto|;
name|l
operator|=
name|ccpf3
operator|->
name|LookaheadCoverage
expr_stmt|;
for|for
control|(
name|nl
operator|=
literal|0
init|;
name|nl
operator|<
name|lookahead_count
condition|;
name|nl
operator|++
control|)
block|{
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail2
goto|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
operator|+
name|base_offset
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|_HB_OPEN_Load_Coverage
argument_list|(
operator|&
name|l
index|[
name|nl
index|]
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
goto|goto
name|Fail2
goto|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail2
goto|;
name|ccpf3
operator|->
name|PosCount
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|ccpf3
operator|->
name|PosLookupRecord
operator|=
name|NULL
expr_stmt|;
name|count
operator|=
name|ccpf3
operator|->
name|PosCount
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|ccpf3
operator|->
name|PosLookupRecord
argument_list|,
name|count
argument_list|,
name|HB_PosLookupRecord
argument_list|)
condition|)
goto|goto
name|Fail2
goto|;
name|plr
operator|=
name|ccpf3
operator|->
name|PosLookupRecord
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
name|count
operator|*
literal|4L
argument_list|)
condition|)
goto|goto
name|Fail1
goto|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
block|{
name|plr
index|[
name|n
index|]
operator|.
name|SequenceIndex
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|plr
index|[
name|n
index|]
operator|.
name|LookupListIndex
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
block|}
name|FORGET_Frame
argument_list|()
expr_stmt|;
return|return
name|HB_Err_Ok
return|;
name|Fail1
label|:
name|FREE
argument_list|(
name|plr
argument_list|)
expr_stmt|;
name|Fail2
label|:
for|for
control|(
name|m
operator|=
literal|0
init|;
name|m
operator|<
name|nl
condition|;
name|m
operator|++
control|)
name|_HB_OPEN_Free_Coverage
argument_list|(
operator|&
name|l
index|[
name|m
index|]
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|Fail3
label|:
for|for
control|(
name|m
operator|=
literal|0
init|;
name|m
operator|<
name|ni
condition|;
name|m
operator|++
control|)
name|_HB_OPEN_Free_Coverage
argument_list|(
operator|&
name|i
index|[
name|m
index|]
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|Fail4
label|:
for|for
control|(
name|m
operator|=
literal|0
init|;
name|m
operator|<
name|nb
condition|;
name|m
operator|++
control|)
name|_HB_OPEN_Free_Coverage
argument_list|(
operator|&
name|b
index|[
name|m
index|]
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|b
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_function
DECL|function|Free_ChainContextPos3
specifier|static
name|void
name|Free_ChainContextPos3
parameter_list|(
name|HB_ChainContextPosFormat3
modifier|*
name|ccpf3
parameter_list|)
block|{
name|HB_UShort
name|n
decl_stmt|,
name|count
decl_stmt|;
name|HB_Coverage
modifier|*
name|c
decl_stmt|;
name|FREE
argument_list|(
name|ccpf3
operator|->
name|PosLookupRecord
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccpf3
operator|->
name|LookaheadCoverage
condition|)
block|{
name|count
operator|=
name|ccpf3
operator|->
name|LookaheadGlyphCount
expr_stmt|;
name|c
operator|=
name|ccpf3
operator|->
name|LookaheadCoverage
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
name|_HB_OPEN_Free_Coverage
argument_list|(
operator|&
name|c
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ccpf3
operator|->
name|InputCoverage
condition|)
block|{
name|count
operator|=
name|ccpf3
operator|->
name|InputGlyphCount
expr_stmt|;
name|c
operator|=
name|ccpf3
operator|->
name|InputCoverage
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
name|_HB_OPEN_Free_Coverage
argument_list|(
operator|&
name|c
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ccpf3
operator|->
name|BacktrackCoverage
condition|)
block|{
name|count
operator|=
name|ccpf3
operator|->
name|BacktrackGlyphCount
expr_stmt|;
name|c
operator|=
name|ccpf3
operator|->
name|BacktrackCoverage
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
name|_HB_OPEN_Free_Coverage
argument_list|(
operator|&
name|c
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/* ChainContextPos */
end_comment
begin_function
DECL|function|Load_ChainContextPos
specifier|static
name|HB_Error
name|Load_ChainContextPos
parameter_list|(
name|HB_GPOS_SubTable
modifier|*
name|st
parameter_list|,
name|HB_Stream
name|stream
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_ChainContextPos
modifier|*
name|ccp
init|=
operator|&
name|st
operator|->
name|chain
decl_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
return|return
name|error
return|;
name|ccp
operator|->
name|PosFormat
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|ccp
operator|->
name|PosFormat
condition|)
block|{
case|case
literal|1
case|:
return|return
name|Load_ChainContextPos1
argument_list|(
operator|&
name|ccp
operator|->
name|ccpf
operator|.
name|ccpf1
argument_list|,
name|stream
argument_list|)
return|;
case|case
literal|2
case|:
return|return
name|Load_ChainContextPos2
argument_list|(
operator|&
name|ccp
operator|->
name|ccpf
operator|.
name|ccpf2
argument_list|,
name|stream
argument_list|)
return|;
case|case
literal|3
case|:
return|return
name|Load_ChainContextPos3
argument_list|(
operator|&
name|ccp
operator|->
name|ccpf
operator|.
name|ccpf3
argument_list|,
name|stream
argument_list|)
return|;
default|default:
return|return
name|ERR
argument_list|(
name|HB_Err_Invalid_SubTable_Format
argument_list|)
return|;
block|}
return|return
name|HB_Err_Ok
return|;
comment|/* never reached */
block|}
end_function
begin_function
DECL|function|Free_ChainContextPos
specifier|static
name|void
name|Free_ChainContextPos
parameter_list|(
name|HB_GPOS_SubTable
modifier|*
name|st
parameter_list|)
block|{
name|HB_ChainContextPos
modifier|*
name|ccp
init|=
operator|&
name|st
operator|->
name|chain
decl_stmt|;
switch|switch
condition|(
name|ccp
operator|->
name|PosFormat
condition|)
block|{
case|case
literal|1
case|:
name|Free_ChainContextPos1
argument_list|(
operator|&
name|ccp
operator|->
name|ccpf
operator|.
name|ccpf1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|Free_ChainContextPos2
argument_list|(
operator|&
name|ccp
operator|->
name|ccpf
operator|.
name|ccpf2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|Free_ChainContextPos3
argument_list|(
operator|&
name|ccp
operator|->
name|ccpf
operator|.
name|ccpf3
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function
begin_function
DECL|function|Lookup_ChainContextPos1
specifier|static
name|HB_Error
name|Lookup_ChainContextPos1
parameter_list|(
name|GPOS_Instance
modifier|*
name|gpi
parameter_list|,
name|HB_ChainContextPosFormat1
modifier|*
name|ccpf1
parameter_list|,
name|HB_Buffer
name|buffer
parameter_list|,
name|HB_UShort
name|flags
parameter_list|,
name|HB_UShort
name|context_length
parameter_list|,
name|int
name|nesting_level
parameter_list|)
block|{
name|HB_UShort
name|index
decl_stmt|,
name|property
decl_stmt|;
name|HB_UShort
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|num_cpr
decl_stmt|;
name|HB_UShort
name|bgc
decl_stmt|,
name|igc
decl_stmt|,
name|lgc
decl_stmt|;
name|HB_Error
name|error
decl_stmt|;
name|HB_GPOSHeader
modifier|*
name|gpos
init|=
name|gpi
operator|->
name|gpos
decl_stmt|;
name|HB_ChainPosRule
modifier|*
name|cpr
decl_stmt|;
name|HB_ChainPosRule
name|curr_cpr
decl_stmt|;
name|HB_GDEFHeader
modifier|*
name|gdef
decl_stmt|;
name|gdef
operator|=
name|gpos
operator|->
name|gdef
expr_stmt|;
if|if
condition|(
name|CHECK_Property
argument_list|(
name|gdef
argument_list|,
name|IN_CURITEM
argument_list|()
argument_list|,
name|flags
argument_list|,
operator|&
name|property
argument_list|)
condition|)
return|return
name|error
return|;
name|error
operator|=
name|_HB_OPEN_Coverage_Index
argument_list|(
operator|&
name|ccpf1
operator|->
name|Coverage
argument_list|,
name|IN_CURGLYPH
argument_list|()
argument_list|,
operator|&
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|cpr
operator|=
name|ccpf1
operator|->
name|ChainPosRuleSet
index|[
name|index
index|]
operator|.
name|ChainPosRule
expr_stmt|;
name|num_cpr
operator|=
name|ccpf1
operator|->
name|ChainPosRuleSet
index|[
name|index
index|]
operator|.
name|ChainPosRuleCount
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|num_cpr
condition|;
name|k
operator|++
control|)
block|{
name|curr_cpr
operator|=
name|cpr
index|[
name|k
index|]
expr_stmt|;
name|bgc
operator|=
name|curr_cpr
operator|.
name|BacktrackGlyphCount
expr_stmt|;
name|igc
operator|=
name|curr_cpr
operator|.
name|InputGlyphCount
expr_stmt|;
name|lgc
operator|=
name|curr_cpr
operator|.
name|LookaheadGlyphCount
expr_stmt|;
if|if
condition|(
name|context_length
operator|!=
literal|0xFFFF
operator|&&
name|context_length
operator|<
name|igc
condition|)
goto|goto
name|next_chainposrule
goto|;
comment|/* check whether context is too long; it is a first guess only */
if|if
condition|(
name|bgc
operator|>
name|buffer
operator|->
name|in_pos
operator|||
name|buffer
operator|->
name|in_pos
operator|+
name|igc
operator|+
name|lgc
operator|>
name|buffer
operator|->
name|in_length
condition|)
goto|goto
name|next_chainposrule
goto|;
if|if
condition|(
name|bgc
condition|)
block|{
comment|/* Since we don't know in advance the number of glyphs to inspect, 	 we search backwards for matches in the backtrack glyph array    */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
name|buffer
operator|->
name|in_pos
operator|-
literal|1
init|;
name|i
operator|<
name|bgc
condition|;
name|i
operator|++
operator|,
name|j
operator|--
control|)
block|{
while|while
condition|(
name|CHECK_Property
argument_list|(
name|gdef
argument_list|,
name|IN_ITEM
argument_list|(
name|j
argument_list|)
argument_list|,
name|flags
argument_list|,
operator|&
name|property
argument_list|)
condition|)
block|{
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|HB_Err_Not_Covered
condition|)
return|return
name|error
return|;
if|if
condition|(
name|j
operator|+
literal|1
operator|==
name|bgc
operator|-
name|i
condition|)
goto|goto
name|next_chainposrule
goto|;
name|j
operator|--
expr_stmt|;
block|}
comment|/* In OpenType 1.3, it is undefined whether the offsets of 	   backtrack glyphs is in logical order or not.  Version 1.4 	   will clarify this:  	     Logical order -      a  b  c  d  e  f  g  h  i  j 					      i 	     Input offsets -                  0  1 	     Backtrack offsets -  3  2  1  0 	     Lookahead offsets -                    0  1  2  3           */
if|if
condition|(
name|IN_GLYPH
argument_list|(
name|j
argument_list|)
operator|!=
name|curr_cpr
operator|.
name|Backtrack
index|[
name|i
index|]
condition|)
goto|goto
name|next_chainposrule
goto|;
block|}
block|}
comment|/* Start at 1 because [0] is implied */
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|j
operator|=
name|buffer
operator|->
name|in_pos
operator|+
literal|1
init|;
name|i
operator|<
name|igc
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
while|while
condition|(
name|CHECK_Property
argument_list|(
name|gdef
argument_list|,
name|IN_ITEM
argument_list|(
name|j
argument_list|)
argument_list|,
name|flags
argument_list|,
operator|&
name|property
argument_list|)
condition|)
block|{
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|HB_Err_Not_Covered
condition|)
return|return
name|error
return|;
if|if
condition|(
name|j
operator|+
name|igc
operator|-
name|i
operator|+
name|lgc
operator|==
operator|(
name|HB_Int
operator|)
name|buffer
operator|->
name|in_length
condition|)
goto|goto
name|next_chainposrule
goto|;
name|j
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|IN_GLYPH
argument_list|(
name|j
argument_list|)
operator|!=
name|curr_cpr
operator|.
name|Input
index|[
name|i
operator|-
literal|1
index|]
condition|)
goto|goto
name|next_chainposrule
goto|;
block|}
comment|/* we are starting to check for lookahead glyphs right after the        last context glyph                                            */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lgc
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
while|while
condition|(
name|CHECK_Property
argument_list|(
name|gdef
argument_list|,
name|IN_ITEM
argument_list|(
name|j
argument_list|)
argument_list|,
name|flags
argument_list|,
operator|&
name|property
argument_list|)
condition|)
block|{
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|HB_Err_Not_Covered
condition|)
return|return
name|error
return|;
if|if
condition|(
name|j
operator|+
name|lgc
operator|-
name|i
operator|==
operator|(
name|HB_Int
operator|)
name|buffer
operator|->
name|in_length
condition|)
goto|goto
name|next_chainposrule
goto|;
name|j
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|IN_GLYPH
argument_list|(
name|j
argument_list|)
operator|!=
name|curr_cpr
operator|.
name|Lookahead
index|[
name|i
index|]
condition|)
goto|goto
name|next_chainposrule
goto|;
block|}
return|return
name|Do_ContextPos
argument_list|(
name|gpi
argument_list|,
name|igc
argument_list|,
name|curr_cpr
operator|.
name|PosCount
argument_list|,
name|curr_cpr
operator|.
name|PosLookupRecord
argument_list|,
name|buffer
argument_list|,
name|nesting_level
argument_list|)
return|;
name|next_chainposrule
label|:
empty_stmt|;
block|}
return|return
name|HB_Err_Not_Covered
return|;
block|}
end_function
begin_function
DECL|function|Lookup_ChainContextPos2
specifier|static
name|HB_Error
name|Lookup_ChainContextPos2
parameter_list|(
name|GPOS_Instance
modifier|*
name|gpi
parameter_list|,
name|HB_ChainContextPosFormat2
modifier|*
name|ccpf2
parameter_list|,
name|HB_Buffer
name|buffer
parameter_list|,
name|HB_UShort
name|flags
parameter_list|,
name|HB_UShort
name|context_length
parameter_list|,
name|int
name|nesting_level
parameter_list|)
block|{
name|HB_UShort
name|index
decl_stmt|,
name|property
decl_stmt|;
name|HB_Error
name|error
decl_stmt|;
name|HB_UShort
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|HB_UShort
name|bgc
decl_stmt|,
name|igc
decl_stmt|,
name|lgc
decl_stmt|;
name|HB_UShort
name|known_backtrack_classes
decl_stmt|,
name|known_input_classes
decl_stmt|,
name|known_lookahead_classes
decl_stmt|;
name|HB_UShort
modifier|*
name|backtrack_classes
decl_stmt|;
name|HB_UShort
modifier|*
name|input_classes
decl_stmt|;
name|HB_UShort
modifier|*
name|lookahead_classes
decl_stmt|;
name|HB_UShort
modifier|*
name|bc
decl_stmt|;
name|HB_UShort
modifier|*
name|ic
decl_stmt|;
name|HB_UShort
modifier|*
name|lc
decl_stmt|;
name|HB_GPOSHeader
modifier|*
name|gpos
init|=
name|gpi
operator|->
name|gpos
decl_stmt|;
name|HB_ChainPosClassSet
modifier|*
name|cpcs
decl_stmt|;
name|HB_ChainPosClassRule
name|cpcr
decl_stmt|;
name|HB_GDEFHeader
modifier|*
name|gdef
decl_stmt|;
name|gdef
operator|=
name|gpos
operator|->
name|gdef
expr_stmt|;
if|if
condition|(
name|CHECK_Property
argument_list|(
name|gdef
argument_list|,
name|IN_CURITEM
argument_list|()
argument_list|,
name|flags
argument_list|,
operator|&
name|property
argument_list|)
condition|)
return|return
name|error
return|;
comment|/* Note: The coverage table in format 2 doesn't give an index into 	   anything.  It just lets us know whether or not we need to 	   do any lookup at all.                                     */
name|error
operator|=
name|_HB_OPEN_Coverage_Index
argument_list|(
operator|&
name|ccpf2
operator|->
name|Coverage
argument_list|,
name|IN_CURGLYPH
argument_list|()
argument_list|,
operator|&
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|backtrack_classes
argument_list|,
name|ccpf2
operator|->
name|MaxBacktrackLength
argument_list|,
name|HB_UShort
argument_list|)
condition|)
return|return
name|error
return|;
name|known_backtrack_classes
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ccpf2
operator|->
name|MaxInputLength
operator|<
literal|1
condition|)
return|return
name|HB_Err_Not_Covered
return|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|input_classes
argument_list|,
name|ccpf2
operator|->
name|MaxInputLength
argument_list|,
name|HB_UShort
argument_list|)
condition|)
goto|goto
name|End3
goto|;
name|known_input_classes
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|lookahead_classes
argument_list|,
name|ccpf2
operator|->
name|MaxLookaheadLength
argument_list|,
name|HB_UShort
argument_list|)
condition|)
goto|goto
name|End2
goto|;
name|known_lookahead_classes
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|_HB_OPEN_Get_Class
argument_list|(
operator|&
name|ccpf2
operator|->
name|InputClassDef
argument_list|,
name|IN_CURGLYPH
argument_list|()
argument_list|,
operator|&
name|input_classes
index|[
literal|0
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|HB_Err_Not_Covered
condition|)
goto|goto
name|End1
goto|;
name|cpcs
operator|=
operator|&
name|ccpf2
operator|->
name|ChainPosClassSet
index|[
name|input_classes
index|[
literal|0
index|]
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|cpcs
condition|)
block|{
name|error
operator|=
name|ERR
argument_list|(
name|HB_Err_Invalid_SubTable
argument_list|)
expr_stmt|;
goto|goto
name|End1
goto|;
block|}
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|cpcs
operator|->
name|ChainPosClassRuleCount
condition|;
name|k
operator|++
control|)
block|{
name|cpcr
operator|=
name|cpcs
operator|->
name|ChainPosClassRule
index|[
name|k
index|]
expr_stmt|;
name|bgc
operator|=
name|cpcr
operator|.
name|BacktrackGlyphCount
expr_stmt|;
name|igc
operator|=
name|cpcr
operator|.
name|InputGlyphCount
expr_stmt|;
name|lgc
operator|=
name|cpcr
operator|.
name|LookaheadGlyphCount
expr_stmt|;
if|if
condition|(
name|context_length
operator|!=
literal|0xFFFF
operator|&&
name|context_length
operator|<
name|igc
condition|)
goto|goto
name|next_chainposclassrule
goto|;
comment|/* check whether context is too long; it is a first guess only */
if|if
condition|(
name|bgc
operator|>
name|buffer
operator|->
name|in_pos
operator|||
name|buffer
operator|->
name|in_pos
operator|+
name|igc
operator|+
name|lgc
operator|>
name|buffer
operator|->
name|in_length
condition|)
goto|goto
name|next_chainposclassrule
goto|;
if|if
condition|(
name|bgc
condition|)
block|{
comment|/* Since we don't know in advance the number of glyphs to inspect, 	 we search backwards for matches in the backtrack glyph array. 	 Note that `known_backtrack_classes' starts at index 0.         */
name|bc
operator|=
name|cpcr
operator|.
name|Backtrack
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
name|buffer
operator|->
name|in_pos
operator|-
literal|1
init|;
name|i
operator|<
name|bgc
condition|;
name|i
operator|++
operator|,
name|j
operator|--
control|)
block|{
while|while
condition|(
name|CHECK_Property
argument_list|(
name|gdef
argument_list|,
name|IN_ITEM
argument_list|(
name|j
argument_list|)
argument_list|,
name|flags
argument_list|,
operator|&
name|property
argument_list|)
condition|)
block|{
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|HB_Err_Not_Covered
condition|)
goto|goto
name|End1
goto|;
if|if
condition|(
name|j
operator|+
literal|1
operator|==
name|bgc
operator|-
name|i
condition|)
goto|goto
name|next_chainposclassrule
goto|;
name|j
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>=
name|known_backtrack_classes
condition|)
block|{
comment|/* Keeps us from having to do this for each rule */
name|error
operator|=
name|_HB_OPEN_Get_Class
argument_list|(
operator|&
name|ccpf2
operator|->
name|BacktrackClassDef
argument_list|,
name|IN_GLYPH
argument_list|(
name|j
argument_list|)
argument_list|,
operator|&
name|backtrack_classes
index|[
name|i
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|HB_Err_Not_Covered
condition|)
goto|goto
name|End1
goto|;
name|known_backtrack_classes
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|bc
index|[
name|i
index|]
operator|!=
name|backtrack_classes
index|[
name|i
index|]
condition|)
goto|goto
name|next_chainposclassrule
goto|;
block|}
block|}
name|ic
operator|=
name|cpcr
operator|.
name|Input
expr_stmt|;
comment|/* Start at 1 because [0] is implied */
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|j
operator|=
name|buffer
operator|->
name|in_pos
operator|+
literal|1
init|;
name|i
operator|<
name|igc
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
while|while
condition|(
name|CHECK_Property
argument_list|(
name|gdef
argument_list|,
name|IN_ITEM
argument_list|(
name|j
argument_list|)
argument_list|,
name|flags
argument_list|,
operator|&
name|property
argument_list|)
condition|)
block|{
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|HB_Err_Not_Covered
condition|)
goto|goto
name|End1
goto|;
if|if
condition|(
name|j
operator|+
name|igc
operator|-
name|i
operator|+
name|lgc
operator|==
operator|(
name|HB_Int
operator|)
name|buffer
operator|->
name|in_length
condition|)
goto|goto
name|next_chainposclassrule
goto|;
name|j
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>=
name|known_input_classes
condition|)
block|{
name|error
operator|=
name|_HB_OPEN_Get_Class
argument_list|(
operator|&
name|ccpf2
operator|->
name|InputClassDef
argument_list|,
name|IN_GLYPH
argument_list|(
name|j
argument_list|)
argument_list|,
operator|&
name|input_classes
index|[
name|i
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|HB_Err_Not_Covered
condition|)
goto|goto
name|End1
goto|;
name|known_input_classes
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|ic
index|[
name|i
operator|-
literal|1
index|]
operator|!=
name|input_classes
index|[
name|i
index|]
condition|)
goto|goto
name|next_chainposclassrule
goto|;
block|}
comment|/* we are starting to check for lookahead glyphs right after the        last context glyph                                            */
name|lc
operator|=
name|cpcr
operator|.
name|Lookahead
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lgc
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
while|while
condition|(
name|CHECK_Property
argument_list|(
name|gdef
argument_list|,
name|IN_ITEM
argument_list|(
name|j
argument_list|)
argument_list|,
name|flags
argument_list|,
operator|&
name|property
argument_list|)
condition|)
block|{
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|HB_Err_Not_Covered
condition|)
goto|goto
name|End1
goto|;
if|if
condition|(
name|j
operator|+
name|lgc
operator|-
name|i
operator|==
operator|(
name|HB_Int
operator|)
name|buffer
operator|->
name|in_length
condition|)
goto|goto
name|next_chainposclassrule
goto|;
name|j
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>=
name|known_lookahead_classes
condition|)
block|{
name|error
operator|=
name|_HB_OPEN_Get_Class
argument_list|(
operator|&
name|ccpf2
operator|->
name|LookaheadClassDef
argument_list|,
name|IN_GLYPH
argument_list|(
name|j
argument_list|)
argument_list|,
operator|&
name|lookahead_classes
index|[
name|i
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|HB_Err_Not_Covered
condition|)
goto|goto
name|End1
goto|;
name|known_lookahead_classes
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|lc
index|[
name|i
index|]
operator|!=
name|lookahead_classes
index|[
name|i
index|]
condition|)
goto|goto
name|next_chainposclassrule
goto|;
block|}
name|error
operator|=
name|Do_ContextPos
argument_list|(
name|gpi
argument_list|,
name|igc
argument_list|,
name|cpcr
operator|.
name|PosCount
argument_list|,
name|cpcr
operator|.
name|PosLookupRecord
argument_list|,
name|buffer
argument_list|,
name|nesting_level
argument_list|)
expr_stmt|;
goto|goto
name|End1
goto|;
name|next_chainposclassrule
label|:
empty_stmt|;
block|}
name|error
operator|=
name|HB_Err_Not_Covered
expr_stmt|;
name|End1
label|:
name|FREE
argument_list|(
name|lookahead_classes
argument_list|)
expr_stmt|;
name|End2
label|:
name|FREE
argument_list|(
name|input_classes
argument_list|)
expr_stmt|;
name|End3
label|:
name|FREE
argument_list|(
name|backtrack_classes
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_function
DECL|function|Lookup_ChainContextPos3
specifier|static
name|HB_Error
name|Lookup_ChainContextPos3
parameter_list|(
name|GPOS_Instance
modifier|*
name|gpi
parameter_list|,
name|HB_ChainContextPosFormat3
modifier|*
name|ccpf3
parameter_list|,
name|HB_Buffer
name|buffer
parameter_list|,
name|HB_UShort
name|flags
parameter_list|,
name|HB_UShort
name|context_length
parameter_list|,
name|int
name|nesting_level
parameter_list|)
block|{
name|HB_UShort
name|index
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|property
decl_stmt|;
name|HB_UShort
name|bgc
decl_stmt|,
name|igc
decl_stmt|,
name|lgc
decl_stmt|;
name|HB_Error
name|error
decl_stmt|;
name|HB_GPOSHeader
modifier|*
name|gpos
init|=
name|gpi
operator|->
name|gpos
decl_stmt|;
name|HB_Coverage
modifier|*
name|bc
decl_stmt|;
name|HB_Coverage
modifier|*
name|ic
decl_stmt|;
name|HB_Coverage
modifier|*
name|lc
decl_stmt|;
name|HB_GDEFHeader
modifier|*
name|gdef
decl_stmt|;
name|gdef
operator|=
name|gpos
operator|->
name|gdef
expr_stmt|;
if|if
condition|(
name|CHECK_Property
argument_list|(
name|gdef
argument_list|,
name|IN_CURITEM
argument_list|()
argument_list|,
name|flags
argument_list|,
operator|&
name|property
argument_list|)
condition|)
return|return
name|error
return|;
name|bgc
operator|=
name|ccpf3
operator|->
name|BacktrackGlyphCount
expr_stmt|;
name|igc
operator|=
name|ccpf3
operator|->
name|InputGlyphCount
expr_stmt|;
name|lgc
operator|=
name|ccpf3
operator|->
name|LookaheadGlyphCount
expr_stmt|;
if|if
condition|(
name|context_length
operator|!=
literal|0xFFFF
operator|&&
name|context_length
operator|<
name|igc
condition|)
return|return
name|HB_Err_Not_Covered
return|;
comment|/* check whether context is too long; it is a first guess only */
if|if
condition|(
name|bgc
operator|>
name|buffer
operator|->
name|in_pos
operator|||
name|buffer
operator|->
name|in_pos
operator|+
name|igc
operator|+
name|lgc
operator|>
name|buffer
operator|->
name|in_length
condition|)
return|return
name|HB_Err_Not_Covered
return|;
if|if
condition|(
name|bgc
condition|)
block|{
comment|/* Since we don't know in advance the number of glyphs to inspect,        we search backwards for matches in the backtrack glyph array    */
name|bc
operator|=
name|ccpf3
operator|->
name|BacktrackCoverage
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
name|buffer
operator|->
name|in_pos
operator|-
literal|1
init|;
name|i
operator|<
name|bgc
condition|;
name|i
operator|++
operator|,
name|j
operator|--
control|)
block|{
while|while
condition|(
name|CHECK_Property
argument_list|(
name|gdef
argument_list|,
name|IN_ITEM
argument_list|(
name|j
argument_list|)
argument_list|,
name|flags
argument_list|,
operator|&
name|property
argument_list|)
condition|)
block|{
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|HB_Err_Not_Covered
condition|)
return|return
name|error
return|;
if|if
condition|(
name|j
operator|+
literal|1
operator|==
name|bgc
operator|-
name|i
condition|)
return|return
name|HB_Err_Not_Covered
return|;
name|j
operator|--
expr_stmt|;
block|}
name|error
operator|=
name|_HB_OPEN_Coverage_Index
argument_list|(
operator|&
name|bc
index|[
name|i
index|]
argument_list|,
name|IN_GLYPH
argument_list|(
name|j
argument_list|)
argument_list|,
operator|&
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
block|}
block|}
name|ic
operator|=
name|ccpf3
operator|->
name|InputCoverage
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
name|buffer
operator|->
name|in_pos
init|;
name|i
operator|<
name|igc
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
comment|/* We already called CHECK_Property for IN_GLYPH ( buffer->in_pos ) */
while|while
condition|(
name|j
operator|>
name|buffer
operator|->
name|in_pos
operator|&&
name|CHECK_Property
argument_list|(
name|gdef
argument_list|,
name|IN_ITEM
argument_list|(
name|j
argument_list|)
argument_list|,
name|flags
argument_list|,
operator|&
name|property
argument_list|)
condition|)
block|{
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|HB_Err_Not_Covered
condition|)
return|return
name|error
return|;
if|if
condition|(
name|j
operator|+
name|igc
operator|-
name|i
operator|+
name|lgc
operator|==
operator|(
name|HB_Int
operator|)
name|buffer
operator|->
name|in_length
condition|)
return|return
name|HB_Err_Not_Covered
return|;
name|j
operator|++
expr_stmt|;
block|}
name|error
operator|=
name|_HB_OPEN_Coverage_Index
argument_list|(
operator|&
name|ic
index|[
name|i
index|]
argument_list|,
name|IN_GLYPH
argument_list|(
name|j
argument_list|)
argument_list|,
operator|&
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
block|}
comment|/* we are starting to check for lookahead glyphs right after the      last context glyph                                            */
name|lc
operator|=
name|ccpf3
operator|->
name|LookaheadCoverage
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lgc
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
while|while
condition|(
name|CHECK_Property
argument_list|(
name|gdef
argument_list|,
name|IN_ITEM
argument_list|(
name|j
argument_list|)
argument_list|,
name|flags
argument_list|,
operator|&
name|property
argument_list|)
condition|)
block|{
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|HB_Err_Not_Covered
condition|)
return|return
name|error
return|;
if|if
condition|(
name|j
operator|+
name|lgc
operator|-
name|i
operator|==
operator|(
name|HB_Int
operator|)
name|buffer
operator|->
name|in_length
condition|)
return|return
name|HB_Err_Not_Covered
return|;
name|j
operator|++
expr_stmt|;
block|}
name|error
operator|=
name|_HB_OPEN_Coverage_Index
argument_list|(
operator|&
name|lc
index|[
name|i
index|]
argument_list|,
name|IN_GLYPH
argument_list|(
name|j
argument_list|)
argument_list|,
operator|&
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
block|}
return|return
name|Do_ContextPos
argument_list|(
name|gpi
argument_list|,
name|igc
argument_list|,
name|ccpf3
operator|->
name|PosCount
argument_list|,
name|ccpf3
operator|->
name|PosLookupRecord
argument_list|,
name|buffer
argument_list|,
name|nesting_level
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|Lookup_ChainContextPos
specifier|static
name|HB_Error
name|Lookup_ChainContextPos
parameter_list|(
name|GPOS_Instance
modifier|*
name|gpi
parameter_list|,
name|HB_GPOS_SubTable
modifier|*
name|st
parameter_list|,
name|HB_Buffer
name|buffer
parameter_list|,
name|HB_UShort
name|flags
parameter_list|,
name|HB_UShort
name|context_length
parameter_list|,
name|int
name|nesting_level
parameter_list|)
block|{
name|HB_ChainContextPos
modifier|*
name|ccp
init|=
operator|&
name|st
operator|->
name|chain
decl_stmt|;
switch|switch
condition|(
name|ccp
operator|->
name|PosFormat
condition|)
block|{
case|case
literal|1
case|:
return|return
name|Lookup_ChainContextPos1
argument_list|(
name|gpi
argument_list|,
operator|&
name|ccp
operator|->
name|ccpf
operator|.
name|ccpf1
argument_list|,
name|buffer
argument_list|,
name|flags
argument_list|,
name|context_length
argument_list|,
name|nesting_level
argument_list|)
return|;
case|case
literal|2
case|:
return|return
name|Lookup_ChainContextPos2
argument_list|(
name|gpi
argument_list|,
operator|&
name|ccp
operator|->
name|ccpf
operator|.
name|ccpf2
argument_list|,
name|buffer
argument_list|,
name|flags
argument_list|,
name|context_length
argument_list|,
name|nesting_level
argument_list|)
return|;
case|case
literal|3
case|:
return|return
name|Lookup_ChainContextPos3
argument_list|(
name|gpi
argument_list|,
operator|&
name|ccp
operator|->
name|ccpf
operator|.
name|ccpf3
argument_list|,
name|buffer
argument_list|,
name|flags
argument_list|,
name|context_length
argument_list|,
name|nesting_level
argument_list|)
return|;
default|default:
return|return
name|ERR
argument_list|(
name|HB_Err_Invalid_SubTable_Format
argument_list|)
return|;
block|}
return|return
name|HB_Err_Ok
return|;
comment|/* never reached */
block|}
end_function
begin_comment
comment|/***********  * GPOS API  ***********/
end_comment
begin_function
DECL|function|HB_GPOS_Select_Script
name|HB_Error
name|HB_GPOS_Select_Script
parameter_list|(
name|HB_GPOSHeader
modifier|*
name|gpos
parameter_list|,
name|HB_UInt
name|script_tag
parameter_list|,
name|HB_UShort
modifier|*
name|script_index
parameter_list|)
block|{
name|HB_UShort
name|n
decl_stmt|;
name|HB_ScriptList
modifier|*
name|sl
decl_stmt|;
name|HB_ScriptRecord
modifier|*
name|sr
decl_stmt|;
if|if
condition|(
operator|!
name|gpos
operator|||
operator|!
name|script_index
condition|)
return|return
name|ERR
argument_list|(
name|HB_Err_Invalid_Argument
argument_list|)
return|;
name|sl
operator|=
operator|&
name|gpos
operator|->
name|ScriptList
expr_stmt|;
name|sr
operator|=
name|sl
operator|->
name|ScriptRecord
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|sl
operator|->
name|ScriptCount
condition|;
name|n
operator|++
control|)
if|if
condition|(
name|script_tag
operator|==
name|sr
index|[
name|n
index|]
operator|.
name|ScriptTag
condition|)
block|{
operator|*
name|script_index
operator|=
name|n
expr_stmt|;
return|return
name|HB_Err_Ok
return|;
block|}
return|return
name|HB_Err_Not_Covered
return|;
block|}
end_function
begin_function
DECL|function|HB_GPOS_Select_Language
name|HB_Error
name|HB_GPOS_Select_Language
parameter_list|(
name|HB_GPOSHeader
modifier|*
name|gpos
parameter_list|,
name|HB_UInt
name|language_tag
parameter_list|,
name|HB_UShort
name|script_index
parameter_list|,
name|HB_UShort
modifier|*
name|language_index
parameter_list|,
name|HB_UShort
modifier|*
name|req_feature_index
parameter_list|)
block|{
name|HB_UShort
name|n
decl_stmt|;
name|HB_ScriptList
modifier|*
name|sl
decl_stmt|;
name|HB_ScriptRecord
modifier|*
name|sr
decl_stmt|;
name|HB_ScriptTable
modifier|*
name|s
decl_stmt|;
name|HB_LangSysRecord
modifier|*
name|lsr
decl_stmt|;
if|if
condition|(
operator|!
name|gpos
operator|||
operator|!
name|language_index
operator|||
operator|!
name|req_feature_index
condition|)
return|return
name|ERR
argument_list|(
name|HB_Err_Invalid_Argument
argument_list|)
return|;
name|sl
operator|=
operator|&
name|gpos
operator|->
name|ScriptList
expr_stmt|;
name|sr
operator|=
name|sl
operator|->
name|ScriptRecord
expr_stmt|;
if|if
condition|(
name|script_index
operator|>=
name|sl
operator|->
name|ScriptCount
condition|)
return|return
name|ERR
argument_list|(
name|HB_Err_Invalid_Argument
argument_list|)
return|;
name|s
operator|=
operator|&
name|sr
index|[
name|script_index
index|]
operator|.
name|Script
expr_stmt|;
name|lsr
operator|=
name|s
operator|->
name|LangSysRecord
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|s
operator|->
name|LangSysCount
condition|;
name|n
operator|++
control|)
if|if
condition|(
name|language_tag
operator|==
name|lsr
index|[
name|n
index|]
operator|.
name|LangSysTag
condition|)
block|{
operator|*
name|language_index
operator|=
name|n
expr_stmt|;
operator|*
name|req_feature_index
operator|=
name|lsr
index|[
name|n
index|]
operator|.
name|LangSys
operator|.
name|ReqFeatureIndex
expr_stmt|;
return|return
name|HB_Err_Ok
return|;
block|}
return|return
name|HB_Err_Not_Covered
return|;
block|}
end_function
begin_comment
comment|/* selecting 0xFFFF for language_index asks for the values of the    default language (DefaultLangSys)                              */
end_comment
begin_function
DECL|function|HB_GPOS_Select_Feature
name|HB_Error
name|HB_GPOS_Select_Feature
parameter_list|(
name|HB_GPOSHeader
modifier|*
name|gpos
parameter_list|,
name|HB_UInt
name|feature_tag
parameter_list|,
name|HB_UShort
name|script_index
parameter_list|,
name|HB_UShort
name|language_index
parameter_list|,
name|HB_UShort
modifier|*
name|feature_index
parameter_list|)
block|{
name|HB_UShort
name|n
decl_stmt|;
name|HB_ScriptList
modifier|*
name|sl
decl_stmt|;
name|HB_ScriptRecord
modifier|*
name|sr
decl_stmt|;
name|HB_ScriptTable
modifier|*
name|s
decl_stmt|;
name|HB_LangSysRecord
modifier|*
name|lsr
decl_stmt|;
name|HB_LangSys
modifier|*
name|ls
decl_stmt|;
name|HB_UShort
modifier|*
name|fi
decl_stmt|;
name|HB_FeatureList
modifier|*
name|fl
decl_stmt|;
name|HB_FeatureRecord
modifier|*
name|fr
decl_stmt|;
if|if
condition|(
operator|!
name|gpos
operator|||
operator|!
name|feature_index
condition|)
return|return
name|ERR
argument_list|(
name|HB_Err_Invalid_Argument
argument_list|)
return|;
name|sl
operator|=
operator|&
name|gpos
operator|->
name|ScriptList
expr_stmt|;
name|sr
operator|=
name|sl
operator|->
name|ScriptRecord
expr_stmt|;
name|fl
operator|=
operator|&
name|gpos
operator|->
name|FeatureList
expr_stmt|;
name|fr
operator|=
name|fl
operator|->
name|FeatureRecord
expr_stmt|;
if|if
condition|(
name|script_index
operator|>=
name|sl
operator|->
name|ScriptCount
condition|)
return|return
name|ERR
argument_list|(
name|HB_Err_Invalid_Argument
argument_list|)
return|;
name|s
operator|=
operator|&
name|sr
index|[
name|script_index
index|]
operator|.
name|Script
expr_stmt|;
name|lsr
operator|=
name|s
operator|->
name|LangSysRecord
expr_stmt|;
if|if
condition|(
name|language_index
operator|==
literal|0xFFFF
condition|)
name|ls
operator|=
operator|&
name|s
operator|->
name|DefaultLangSys
expr_stmt|;
else|else
block|{
if|if
condition|(
name|language_index
operator|>=
name|s
operator|->
name|LangSysCount
condition|)
return|return
name|ERR
argument_list|(
name|HB_Err_Invalid_Argument
argument_list|)
return|;
name|ls
operator|=
operator|&
name|lsr
index|[
name|language_index
index|]
operator|.
name|LangSys
expr_stmt|;
block|}
name|fi
operator|=
name|ls
operator|->
name|FeatureIndex
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|ls
operator|->
name|FeatureCount
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|fi
index|[
name|n
index|]
operator|>=
name|fl
operator|->
name|FeatureCount
condition|)
return|return
name|ERR
argument_list|(
name|HB_Err_Invalid_SubTable_Format
argument_list|)
return|;
if|if
condition|(
name|feature_tag
operator|==
name|fr
index|[
name|fi
index|[
name|n
index|]
index|]
operator|.
name|FeatureTag
condition|)
block|{
operator|*
name|feature_index
operator|=
name|fi
index|[
name|n
index|]
expr_stmt|;
return|return
name|HB_Err_Ok
return|;
block|}
block|}
return|return
name|HB_Err_Not_Covered
return|;
block|}
end_function
begin_comment
comment|/* The next three functions return a null-terminated list */
end_comment
begin_function
DECL|function|HB_GPOS_Query_Scripts
name|HB_Error
name|HB_GPOS_Query_Scripts
parameter_list|(
name|HB_GPOSHeader
modifier|*
name|gpos
parameter_list|,
name|HB_UInt
modifier|*
modifier|*
name|script_tag_list
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_UShort
name|n
decl_stmt|;
name|HB_UInt
modifier|*
name|stl
decl_stmt|;
name|HB_ScriptList
modifier|*
name|sl
decl_stmt|;
name|HB_ScriptRecord
modifier|*
name|sr
decl_stmt|;
if|if
condition|(
operator|!
name|gpos
operator|||
operator|!
name|script_tag_list
condition|)
return|return
name|ERR
argument_list|(
name|HB_Err_Invalid_Argument
argument_list|)
return|;
name|sl
operator|=
operator|&
name|gpos
operator|->
name|ScriptList
expr_stmt|;
name|sr
operator|=
name|sl
operator|->
name|ScriptRecord
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|stl
argument_list|,
name|sl
operator|->
name|ScriptCount
operator|+
literal|1
argument_list|,
name|HB_UInt
argument_list|)
condition|)
return|return
name|error
return|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|sl
operator|->
name|ScriptCount
condition|;
name|n
operator|++
control|)
name|stl
index|[
name|n
index|]
operator|=
name|sr
index|[
name|n
index|]
operator|.
name|ScriptTag
expr_stmt|;
name|stl
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
operator|*
name|script_tag_list
operator|=
name|stl
expr_stmt|;
return|return
name|HB_Err_Ok
return|;
block|}
end_function
begin_function
DECL|function|HB_GPOS_Query_Languages
name|HB_Error
name|HB_GPOS_Query_Languages
parameter_list|(
name|HB_GPOSHeader
modifier|*
name|gpos
parameter_list|,
name|HB_UShort
name|script_index
parameter_list|,
name|HB_UInt
modifier|*
modifier|*
name|language_tag_list
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_UShort
name|n
decl_stmt|;
name|HB_UInt
modifier|*
name|ltl
decl_stmt|;
name|HB_ScriptList
modifier|*
name|sl
decl_stmt|;
name|HB_ScriptRecord
modifier|*
name|sr
decl_stmt|;
name|HB_ScriptTable
modifier|*
name|s
decl_stmt|;
name|HB_LangSysRecord
modifier|*
name|lsr
decl_stmt|;
if|if
condition|(
operator|!
name|gpos
operator|||
operator|!
name|language_tag_list
condition|)
return|return
name|ERR
argument_list|(
name|HB_Err_Invalid_Argument
argument_list|)
return|;
name|sl
operator|=
operator|&
name|gpos
operator|->
name|ScriptList
expr_stmt|;
name|sr
operator|=
name|sl
operator|->
name|ScriptRecord
expr_stmt|;
if|if
condition|(
name|script_index
operator|>=
name|sl
operator|->
name|ScriptCount
condition|)
return|return
name|ERR
argument_list|(
name|HB_Err_Invalid_Argument
argument_list|)
return|;
name|s
operator|=
operator|&
name|sr
index|[
name|script_index
index|]
operator|.
name|Script
expr_stmt|;
name|lsr
operator|=
name|s
operator|->
name|LangSysRecord
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|ltl
argument_list|,
name|s
operator|->
name|LangSysCount
operator|+
literal|1
argument_list|,
name|HB_UInt
argument_list|)
condition|)
return|return
name|error
return|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|s
operator|->
name|LangSysCount
condition|;
name|n
operator|++
control|)
name|ltl
index|[
name|n
index|]
operator|=
name|lsr
index|[
name|n
index|]
operator|.
name|LangSysTag
expr_stmt|;
name|ltl
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
operator|*
name|language_tag_list
operator|=
name|ltl
expr_stmt|;
return|return
name|HB_Err_Ok
return|;
block|}
end_function
begin_comment
comment|/* selecting 0xFFFF for language_index asks for the values of the    default language (DefaultLangSys)                              */
end_comment
begin_function
DECL|function|HB_GPOS_Query_Features
name|HB_Error
name|HB_GPOS_Query_Features
parameter_list|(
name|HB_GPOSHeader
modifier|*
name|gpos
parameter_list|,
name|HB_UShort
name|script_index
parameter_list|,
name|HB_UShort
name|language_index
parameter_list|,
name|HB_UInt
modifier|*
modifier|*
name|feature_tag_list
parameter_list|)
block|{
name|HB_UShort
name|n
decl_stmt|;
name|HB_Error
name|error
decl_stmt|;
name|HB_UInt
modifier|*
name|ftl
decl_stmt|;
name|HB_ScriptList
modifier|*
name|sl
decl_stmt|;
name|HB_ScriptRecord
modifier|*
name|sr
decl_stmt|;
name|HB_ScriptTable
modifier|*
name|s
decl_stmt|;
name|HB_LangSysRecord
modifier|*
name|lsr
decl_stmt|;
name|HB_LangSys
modifier|*
name|ls
decl_stmt|;
name|HB_UShort
modifier|*
name|fi
decl_stmt|;
name|HB_FeatureList
modifier|*
name|fl
decl_stmt|;
name|HB_FeatureRecord
modifier|*
name|fr
decl_stmt|;
if|if
condition|(
operator|!
name|gpos
operator|||
operator|!
name|feature_tag_list
condition|)
return|return
name|ERR
argument_list|(
name|HB_Err_Invalid_Argument
argument_list|)
return|;
name|sl
operator|=
operator|&
name|gpos
operator|->
name|ScriptList
expr_stmt|;
name|sr
operator|=
name|sl
operator|->
name|ScriptRecord
expr_stmt|;
name|fl
operator|=
operator|&
name|gpos
operator|->
name|FeatureList
expr_stmt|;
name|fr
operator|=
name|fl
operator|->
name|FeatureRecord
expr_stmt|;
if|if
condition|(
name|script_index
operator|>=
name|sl
operator|->
name|ScriptCount
condition|)
return|return
name|ERR
argument_list|(
name|HB_Err_Invalid_Argument
argument_list|)
return|;
name|s
operator|=
operator|&
name|sr
index|[
name|script_index
index|]
operator|.
name|Script
expr_stmt|;
name|lsr
operator|=
name|s
operator|->
name|LangSysRecord
expr_stmt|;
if|if
condition|(
name|language_index
operator|==
literal|0xFFFF
condition|)
name|ls
operator|=
operator|&
name|s
operator|->
name|DefaultLangSys
expr_stmt|;
else|else
block|{
if|if
condition|(
name|language_index
operator|>=
name|s
operator|->
name|LangSysCount
condition|)
return|return
name|ERR
argument_list|(
name|HB_Err_Invalid_Argument
argument_list|)
return|;
name|ls
operator|=
operator|&
name|lsr
index|[
name|language_index
index|]
operator|.
name|LangSys
expr_stmt|;
block|}
name|fi
operator|=
name|ls
operator|->
name|FeatureIndex
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|ftl
argument_list|,
name|ls
operator|->
name|FeatureCount
operator|+
literal|1
argument_list|,
name|HB_UInt
argument_list|)
condition|)
return|return
name|error
return|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|ls
operator|->
name|FeatureCount
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|fi
index|[
name|n
index|]
operator|>=
name|fl
operator|->
name|FeatureCount
condition|)
block|{
name|FREE
argument_list|(
name|ftl
argument_list|)
expr_stmt|;
return|return
name|ERR
argument_list|(
name|HB_Err_Invalid_SubTable_Format
argument_list|)
return|;
block|}
name|ftl
index|[
name|n
index|]
operator|=
name|fr
index|[
name|fi
index|[
name|n
index|]
index|]
operator|.
name|FeatureTag
expr_stmt|;
block|}
name|ftl
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
operator|*
name|feature_tag_list
operator|=
name|ftl
expr_stmt|;
return|return
name|HB_Err_Ok
return|;
block|}
end_function
begin_comment
comment|/* Do an individual subtable lookup.  Returns HB_Err_Ok if positioning    has been done, or HB_Err_Not_Covered if not.                        */
end_comment
begin_function
DECL|function|GPOS_Do_Glyph_Lookup
specifier|static
name|HB_Error
name|GPOS_Do_Glyph_Lookup
parameter_list|(
name|GPOS_Instance
modifier|*
name|gpi
parameter_list|,
name|HB_UShort
name|lookup_index
parameter_list|,
name|HB_Buffer
name|buffer
parameter_list|,
name|HB_UShort
name|context_length
parameter_list|,
name|int
name|nesting_level
parameter_list|)
block|{
name|HB_Error
name|error
init|=
name|HB_Err_Not_Covered
decl_stmt|;
name|HB_UShort
name|i
decl_stmt|,
name|flags
decl_stmt|,
name|lookup_count
decl_stmt|;
name|HB_GPOSHeader
modifier|*
name|gpos
init|=
name|gpi
operator|->
name|gpos
decl_stmt|;
name|HB_Lookup
modifier|*
name|lo
decl_stmt|;
name|int
name|lookup_type
decl_stmt|;
name|nesting_level
operator|++
expr_stmt|;
if|if
condition|(
name|nesting_level
operator|>
name|HB_MAX_NESTING_LEVEL
condition|)
return|return
name|ERR
argument_list|(
name|HB_Err_Not_Covered
argument_list|)
return|;
comment|/* ERR() call intended */
name|lookup_count
operator|=
name|gpos
operator|->
name|LookupList
operator|.
name|LookupCount
expr_stmt|;
if|if
condition|(
name|lookup_index
operator|>=
name|lookup_count
condition|)
return|return
name|error
return|;
name|lo
operator|=
operator|&
name|gpos
operator|->
name|LookupList
operator|.
name|Lookup
index|[
name|lookup_index
index|]
expr_stmt|;
name|flags
operator|=
name|lo
operator|->
name|LookupFlag
expr_stmt|;
name|lookup_type
operator|=
name|lo
operator|->
name|LookupType
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lo
operator|->
name|SubTableCount
condition|;
name|i
operator|++
control|)
block|{
name|HB_GPOS_SubTable
modifier|*
name|st
init|=
operator|&
name|lo
operator|->
name|SubTable
index|[
name|i
index|]
operator|.
name|st
operator|.
name|gpos
decl_stmt|;
switch|switch
condition|(
name|lookup_type
condition|)
block|{
case|case
name|HB_GPOS_LOOKUP_SINGLE
case|:
name|error
operator|=
name|Lookup_SinglePos
argument_list|(
name|gpi
argument_list|,
name|st
argument_list|,
name|buffer
argument_list|,
name|flags
argument_list|,
name|context_length
argument_list|,
name|nesting_level
argument_list|)
expr_stmt|;
break|break;
case|case
name|HB_GPOS_LOOKUP_PAIR
case|:
name|error
operator|=
name|Lookup_PairPos
argument_list|(
name|gpi
argument_list|,
name|st
argument_list|,
name|buffer
argument_list|,
name|flags
argument_list|,
name|context_length
argument_list|,
name|nesting_level
argument_list|)
expr_stmt|;
break|break;
case|case
name|HB_GPOS_LOOKUP_CURSIVE
case|:
name|error
operator|=
name|Lookup_CursivePos
argument_list|(
name|gpi
argument_list|,
name|st
argument_list|,
name|buffer
argument_list|,
name|flags
argument_list|,
name|context_length
argument_list|,
name|nesting_level
argument_list|)
expr_stmt|;
break|break;
case|case
name|HB_GPOS_LOOKUP_MARKBASE
case|:
name|error
operator|=
name|Lookup_MarkBasePos
argument_list|(
name|gpi
argument_list|,
name|st
argument_list|,
name|buffer
argument_list|,
name|flags
argument_list|,
name|context_length
argument_list|,
name|nesting_level
argument_list|)
expr_stmt|;
break|break;
case|case
name|HB_GPOS_LOOKUP_MARKLIG
case|:
name|error
operator|=
name|Lookup_MarkLigPos
argument_list|(
name|gpi
argument_list|,
name|st
argument_list|,
name|buffer
argument_list|,
name|flags
argument_list|,
name|context_length
argument_list|,
name|nesting_level
argument_list|)
expr_stmt|;
break|break;
case|case
name|HB_GPOS_LOOKUP_MARKMARK
case|:
name|error
operator|=
name|Lookup_MarkMarkPos
argument_list|(
name|gpi
argument_list|,
name|st
argument_list|,
name|buffer
argument_list|,
name|flags
argument_list|,
name|context_length
argument_list|,
name|nesting_level
argument_list|)
expr_stmt|;
break|break;
case|case
name|HB_GPOS_LOOKUP_CONTEXT
case|:
name|error
operator|=
name|Lookup_ContextPos
argument_list|(
name|gpi
argument_list|,
name|st
argument_list|,
name|buffer
argument_list|,
name|flags
argument_list|,
name|context_length
argument_list|,
name|nesting_level
argument_list|)
expr_stmt|;
break|break;
case|case
name|HB_GPOS_LOOKUP_CHAIN
case|:
name|error
operator|=
name|Lookup_ChainContextPos
argument_list|(
name|gpi
argument_list|,
name|st
argument_list|,
name|buffer
argument_list|,
name|flags
argument_list|,
name|context_length
argument_list|,
name|nesting_level
argument_list|)
expr_stmt|;
break|break;
comment|/*case HB_GPOS_LOOKUP_EXTENSION: 	error = Lookup_ExtensionPos	( gpi, st, buffer, flags, context_length, nesting_level ); break;*/
default|default:
name|error
operator|=
name|HB_Err_Not_Covered
expr_stmt|;
block|}
comment|/* Check whether we have a successful positioning or an error other        than HB_Err_Not_Covered                                         */
if|if
condition|(
name|error
operator|!=
name|HB_Err_Not_Covered
condition|)
return|return
name|error
return|;
block|}
return|return
name|HB_Err_Not_Covered
return|;
block|}
end_function
begin_function
name|HB_INTERNAL
name|HB_Error
DECL|function|_HB_GPOS_Load_SubTable
name|_HB_GPOS_Load_SubTable
parameter_list|(
name|HB_GPOS_SubTable
modifier|*
name|st
parameter_list|,
name|HB_Stream
name|stream
parameter_list|,
name|HB_UShort
name|lookup_type
parameter_list|)
block|{
switch|switch
condition|(
name|lookup_type
condition|)
block|{
case|case
name|HB_GPOS_LOOKUP_SINGLE
case|:
return|return
name|Load_SinglePos
argument_list|(
name|st
argument_list|,
name|stream
argument_list|)
return|;
case|case
name|HB_GPOS_LOOKUP_PAIR
case|:
return|return
name|Load_PairPos
argument_list|(
name|st
argument_list|,
name|stream
argument_list|)
return|;
case|case
name|HB_GPOS_LOOKUP_CURSIVE
case|:
return|return
name|Load_CursivePos
argument_list|(
name|st
argument_list|,
name|stream
argument_list|)
return|;
case|case
name|HB_GPOS_LOOKUP_MARKBASE
case|:
return|return
name|Load_MarkBasePos
argument_list|(
name|st
argument_list|,
name|stream
argument_list|)
return|;
case|case
name|HB_GPOS_LOOKUP_MARKLIG
case|:
return|return
name|Load_MarkLigPos
argument_list|(
name|st
argument_list|,
name|stream
argument_list|)
return|;
case|case
name|HB_GPOS_LOOKUP_MARKMARK
case|:
return|return
name|Load_MarkMarkPos
argument_list|(
name|st
argument_list|,
name|stream
argument_list|)
return|;
case|case
name|HB_GPOS_LOOKUP_CONTEXT
case|:
return|return
name|Load_ContextPos
argument_list|(
name|st
argument_list|,
name|stream
argument_list|)
return|;
case|case
name|HB_GPOS_LOOKUP_CHAIN
case|:
return|return
name|Load_ChainContextPos
argument_list|(
name|st
argument_list|,
name|stream
argument_list|)
return|;
comment|/*case HB_GPOS_LOOKUP_EXTENSION:	return Load_ExtensionPos	( st, stream );*/
default|default:
return|return
name|ERR
argument_list|(
name|HB_Err_Invalid_SubTable_Format
argument_list|)
return|;
block|}
block|}
end_function
begin_function
name|HB_INTERNAL
name|void
DECL|function|_HB_GPOS_Free_SubTable
name|_HB_GPOS_Free_SubTable
parameter_list|(
name|HB_GPOS_SubTable
modifier|*
name|st
parameter_list|,
name|HB_UShort
name|lookup_type
parameter_list|)
block|{
switch|switch
condition|(
name|lookup_type
condition|)
block|{
case|case
name|HB_GPOS_LOOKUP_SINGLE
case|:
name|Free_SinglePos
argument_list|(
name|st
argument_list|)
expr_stmt|;
return|return;
case|case
name|HB_GPOS_LOOKUP_PAIR
case|:
name|Free_PairPos
argument_list|(
name|st
argument_list|)
expr_stmt|;
return|return;
case|case
name|HB_GPOS_LOOKUP_CURSIVE
case|:
name|Free_CursivePos
argument_list|(
name|st
argument_list|)
expr_stmt|;
return|return;
case|case
name|HB_GPOS_LOOKUP_MARKBASE
case|:
name|Free_MarkBasePos
argument_list|(
name|st
argument_list|)
expr_stmt|;
return|return;
case|case
name|HB_GPOS_LOOKUP_MARKLIG
case|:
name|Free_MarkLigPos
argument_list|(
name|st
argument_list|)
expr_stmt|;
return|return;
case|case
name|HB_GPOS_LOOKUP_MARKMARK
case|:
name|Free_MarkMarkPos
argument_list|(
name|st
argument_list|)
expr_stmt|;
return|return;
case|case
name|HB_GPOS_LOOKUP_CONTEXT
case|:
name|Free_ContextPos
argument_list|(
name|st
argument_list|)
expr_stmt|;
return|return;
case|case
name|HB_GPOS_LOOKUP_CHAIN
case|:
name|Free_ChainContextPos
argument_list|(
name|st
argument_list|)
expr_stmt|;
return|return;
comment|/*case HB_GPOS_LOOKUP_EXTENSION:	Free_ExtensionPos	( st ); return;*/
default|default:
return|return;
block|}
block|}
end_function
begin_comment
comment|/* apply one lookup to the input string object */
end_comment
begin_function
DECL|function|GPOS_Do_String_Lookup
specifier|static
name|HB_Error
name|GPOS_Do_String_Lookup
parameter_list|(
name|GPOS_Instance
modifier|*
name|gpi
parameter_list|,
name|HB_UShort
name|lookup_index
parameter_list|,
name|HB_Buffer
name|buffer
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|,
name|retError
init|=
name|HB_Err_Not_Covered
decl_stmt|;
name|HB_GPOSHeader
modifier|*
name|gpos
init|=
name|gpi
operator|->
name|gpos
decl_stmt|;
name|HB_UInt
modifier|*
name|properties
init|=
name|gpos
operator|->
name|LookupList
operator|.
name|Properties
decl_stmt|;
specifier|const
name|int
name|nesting_level
init|=
literal|0
decl_stmt|;
comment|/* 0xFFFF indicates that we don't have a context length yet */
specifier|const
name|HB_UShort
name|context_length
init|=
literal|0xFFFF
decl_stmt|;
name|gpi
operator|->
name|last
operator|=
literal|0xFFFF
expr_stmt|;
comment|/* no last valid glyph for cursive pos. */
name|buffer
operator|->
name|in_pos
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|buffer
operator|->
name|in_pos
operator|<
name|buffer
operator|->
name|in_length
condition|)
block|{
if|if
condition|(
operator|~
name|IN_PROPERTIES
argument_list|(
name|buffer
operator|->
name|in_pos
argument_list|)
operator|&
name|properties
index|[
name|lookup_index
index|]
condition|)
block|{
comment|/* Note that the connection between mark and base glyphs hold 	 exactly one (string) lookup.  For example, it would be possible 	 that in the first lookup, mark glyph X is attached to base 	 glyph A, and in the next lookup it is attached to base glyph B. 	 It is up to the font designer to provide meaningful lookups and 	 lookup order.                                                   */
name|error
operator|=
name|GPOS_Do_Glyph_Lookup
argument_list|(
name|gpi
argument_list|,
name|lookup_index
argument_list|,
name|buffer
argument_list|,
name|context_length
argument_list|,
name|nesting_level
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|HB_Err_Not_Covered
condition|)
return|return
name|error
return|;
block|}
else|else
block|{
comment|/* Contrary to properties defined in GDEF, user-defined properties 	 will always stop a possible cursive positioning.                */
name|gpi
operator|->
name|last
operator|=
literal|0xFFFF
expr_stmt|;
name|error
operator|=
name|HB_Err_Not_Covered
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
name|HB_Err_Not_Covered
condition|)
operator|(
name|buffer
operator|->
name|in_pos
operator|)
operator|++
expr_stmt|;
else|else
name|retError
operator|=
name|error
expr_stmt|;
block|}
return|return
name|retError
return|;
block|}
end_function
begin_function
DECL|function|Position_CursiveChain
specifier|static
name|HB_Error
name|Position_CursiveChain
parameter_list|(
name|HB_Buffer
name|buffer
parameter_list|)
block|{
name|HB_UInt
name|i
decl_stmt|,
name|j
decl_stmt|;
name|HB_Position
name|positions
init|=
name|buffer
operator|->
name|positions
decl_stmt|;
comment|/* First handle all left-to-right connections */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|buffer
operator|->
name|in_length
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|positions
index|[
name|j
index|]
operator|.
name|cursive_chain
operator|>
literal|0
condition|)
name|positions
index|[
name|j
index|]
operator|.
name|y_pos
operator|+=
name|positions
index|[
name|j
operator|-
name|positions
index|[
name|j
index|]
operator|.
name|cursive_chain
index|]
operator|.
name|y_pos
expr_stmt|;
block|}
comment|/* Then handle all right-to-left connections */
for|for
control|(
name|i
operator|=
name|buffer
operator|->
name|in_length
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|j
operator|=
name|i
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|positions
index|[
name|j
index|]
operator|.
name|cursive_chain
operator|<
literal|0
condition|)
name|positions
index|[
name|j
index|]
operator|.
name|y_pos
operator|+=
name|positions
index|[
name|j
operator|-
name|positions
index|[
name|j
index|]
operator|.
name|cursive_chain
index|]
operator|.
name|y_pos
expr_stmt|;
block|}
return|return
name|HB_Err_Ok
return|;
block|}
end_function
begin_function
DECL|function|HB_GPOS_Add_Feature
name|HB_Error
name|HB_GPOS_Add_Feature
parameter_list|(
name|HB_GPOSHeader
modifier|*
name|gpos
parameter_list|,
name|HB_UShort
name|feature_index
parameter_list|,
name|HB_UInt
name|property
parameter_list|)
block|{
name|HB_UShort
name|i
decl_stmt|;
name|HB_Feature
name|feature
decl_stmt|;
name|HB_UInt
modifier|*
name|properties
decl_stmt|;
name|HB_UShort
modifier|*
name|index
decl_stmt|;
name|HB_UShort
name|lookup_count
decl_stmt|;
comment|/* Each feature can only be added once */
if|if
condition|(
operator|!
name|gpos
operator|||
name|feature_index
operator|>=
name|gpos
operator|->
name|FeatureList
operator|.
name|FeatureCount
operator|||
name|gpos
operator|->
name|FeatureList
operator|.
name|ApplyCount
operator|==
name|gpos
operator|->
name|FeatureList
operator|.
name|FeatureCount
condition|)
return|return
name|ERR
argument_list|(
name|HB_Err_Invalid_Argument
argument_list|)
return|;
name|gpos
operator|->
name|FeatureList
operator|.
name|ApplyOrder
index|[
name|gpos
operator|->
name|FeatureList
operator|.
name|ApplyCount
operator|++
index|]
operator|=
name|feature_index
expr_stmt|;
name|properties
operator|=
name|gpos
operator|->
name|LookupList
operator|.
name|Properties
expr_stmt|;
name|feature
operator|=
name|gpos
operator|->
name|FeatureList
operator|.
name|FeatureRecord
index|[
name|feature_index
index|]
operator|.
name|Feature
expr_stmt|;
name|index
operator|=
name|feature
operator|.
name|LookupListIndex
expr_stmt|;
name|lookup_count
operator|=
name|gpos
operator|->
name|LookupList
operator|.
name|LookupCount
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|feature
operator|.
name|LookupListCount
condition|;
name|i
operator|++
control|)
block|{
name|HB_UShort
name|lookup_index
init|=
name|index
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|lookup_index
operator|<
name|lookup_count
condition|)
name|properties
index|[
name|lookup_index
index|]
operator||=
name|property
expr_stmt|;
block|}
return|return
name|HB_Err_Ok
return|;
block|}
end_function
begin_function
DECL|function|HB_GPOS_Clear_Features
name|HB_Error
name|HB_GPOS_Clear_Features
parameter_list|(
name|HB_GPOSHeader
modifier|*
name|gpos
parameter_list|)
block|{
name|HB_UShort
name|i
decl_stmt|;
name|HB_UInt
modifier|*
name|properties
decl_stmt|;
if|if
condition|(
operator|!
name|gpos
condition|)
return|return
name|ERR
argument_list|(
name|HB_Err_Invalid_Argument
argument_list|)
return|;
name|gpos
operator|->
name|FeatureList
operator|.
name|ApplyCount
operator|=
literal|0
expr_stmt|;
name|properties
operator|=
name|gpos
operator|->
name|LookupList
operator|.
name|Properties
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|gpos
operator|->
name|LookupList
operator|.
name|LookupCount
condition|;
name|i
operator|++
control|)
name|properties
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|HB_Err_Ok
return|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|HB_SUPPORT_MULTIPLE_MASTER
end_ifdef
begin_function
DECL|function|HB_GPOS_Register_MM_Function
name|HB_Error
name|HB_GPOS_Register_MM_Function
parameter_list|(
name|HB_GPOSHeader
modifier|*
name|gpos
parameter_list|,
name|HB_MMFunction
name|mmfunc
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
if|if
condition|(
operator|!
name|gpos
condition|)
return|return
name|ERR
argument_list|(
name|HB_Err_Invalid_Argument
argument_list|)
return|;
name|gpos
operator|->
name|mmfunc
operator|=
name|mmfunc
expr_stmt|;
name|gpos
operator|->
name|data
operator|=
name|data
expr_stmt|;
return|return
name|HB_Err_Ok
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* If `dvi' is TRUE, glyph contour points for anchor points and device    tables are ignored -- you will get device independent values.         */
end_comment
begin_function
DECL|function|HB_GPOS_Apply_String
name|HB_Error
name|HB_GPOS_Apply_String
parameter_list|(
name|HB_Font
name|font
parameter_list|,
name|HB_GPOSHeader
modifier|*
name|gpos
parameter_list|,
name|HB_UShort
name|load_flags
parameter_list|,
name|HB_Buffer
name|buffer
parameter_list|,
name|HB_Bool
name|dvi
parameter_list|,
name|HB_Bool
name|r2l
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|,
name|retError
init|=
name|HB_Err_Not_Covered
decl_stmt|;
name|GPOS_Instance
name|gpi
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|lookup_count
decl_stmt|,
name|num_features
decl_stmt|;
if|if
condition|(
operator|!
name|font
operator|||
operator|!
name|gpos
operator|||
operator|!
name|buffer
condition|)
return|return
name|ERR
argument_list|(
name|HB_Err_Invalid_Argument
argument_list|)
return|;
if|if
condition|(
name|buffer
operator|->
name|in_length
operator|==
literal|0
condition|)
return|return
name|HB_Err_Not_Covered
return|;
name|gpi
operator|.
name|font
operator|=
name|font
expr_stmt|;
name|gpi
operator|.
name|gpos
operator|=
name|gpos
expr_stmt|;
name|gpi
operator|.
name|load_flags
operator|=
name|load_flags
expr_stmt|;
name|gpi
operator|.
name|r2l
operator|=
name|r2l
expr_stmt|;
name|gpi
operator|.
name|dvi
operator|=
name|dvi
expr_stmt|;
name|lookup_count
operator|=
name|gpos
operator|->
name|LookupList
operator|.
name|LookupCount
expr_stmt|;
name|num_features
operator|=
name|gpos
operator|->
name|FeatureList
operator|.
name|ApplyCount
expr_stmt|;
if|if
condition|(
name|num_features
condition|)
block|{
name|error
operator|=
name|_hb_buffer_clear_positions
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_features
condition|;
name|i
operator|++
control|)
block|{
name|HB_UShort
name|feature_index
init|=
name|gpos
operator|->
name|FeatureList
operator|.
name|ApplyOrder
index|[
name|i
index|]
decl_stmt|;
name|HB_Feature
name|feature
init|=
name|gpos
operator|->
name|FeatureList
operator|.
name|FeatureRecord
index|[
name|feature_index
index|]
operator|.
name|Feature
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|feature
operator|.
name|LookupListCount
condition|;
name|j
operator|++
control|)
block|{
name|HB_UShort
name|lookup_index
init|=
name|feature
operator|.
name|LookupListIndex
index|[
name|j
index|]
decl_stmt|;
comment|/* Skip nonexistant lookups */
if|if
condition|(
name|lookup_index
operator|>=
name|lookup_count
condition|)
continue|continue;
name|error
operator|=
name|GPOS_Do_String_Lookup
argument_list|(
operator|&
name|gpi
argument_list|,
name|lookup_index
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|error
operator|!=
name|HB_Err_Not_Covered
condition|)
return|return
name|error
return|;
block|}
else|else
name|retError
operator|=
name|error
expr_stmt|;
block|}
block|}
if|if
condition|(
name|num_features
condition|)
block|{
name|error
operator|=
name|Position_CursiveChain
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
block|}
return|return
name|retError
return|;
block|}
end_function
begin_comment
comment|/* END */
end_comment
end_unit
