begin_unit
begin_comment
comment|/*  * Copyright (C) 2012 Digia Plc and/or its subsidiary(-ies)  *  * This is part of HarfBuzz, an OpenType Layout engine library.  *  * Permission is hereby granted, without written agreement and without  * license or royalty fees, to use, copy, modify, and distribute this  * software and its documentation for any purpose, provided that the  * above copyright notice and the following two paragraphs appear in  * all copies of this software.  *  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH  * DAMAGE.  *  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS  * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.  */
end_comment
begin_include
include|#
directive|include
file|"harfbuzz-shaper.h"
end_include
begin_include
include|#
directive|include
file|"harfbuzz-shaper-private.h"
end_include
begin_include
include|#
directive|include
file|<assert.h>
end_include
begin_comment
comment|/* // Hangul is a syllable based script. Unicode reserves a large range // for precomposed hangul, where syllables are already precomposed to // their final glyph shape. In addition, a so called jamo range is // defined, that can be used to express old Hangul. Modern hangul // syllables can also be expressed as jamo, and should be composed // into syllables. The operation is rather simple and mathematical.  // Every hangul jamo is classified as being either a Leading consonant // (L), and intermediat Vowel (V) or a trailing consonant (T). Modern // hangul syllables (the ones in the precomposed area can be of type // LV or LVT. // // Syllable breaks do _not_ occur between: // // L              L, V or precomposed // V, LV          V, T // LVT, T         T // // A standard syllable is of the form L+V+T*. The above rules allow // nonstandard syllables L*V*T*. To transform them into standard // syllables fill characters L_f and V_f can be inserted. */
end_comment
begin_enum
enum|enum
block|{
DECL|enumerator|Hangul_SBase
name|Hangul_SBase
init|=
literal|0xac00
block|,
DECL|enumerator|Hangul_LBase
name|Hangul_LBase
init|=
literal|0x1100
block|,
DECL|enumerator|Hangul_VBase
name|Hangul_VBase
init|=
literal|0x1161
block|,
DECL|enumerator|Hangul_TBase
name|Hangul_TBase
init|=
literal|0x11a7
block|,
DECL|enumerator|Hangul_SCount
name|Hangul_SCount
init|=
literal|11172
block|,
DECL|enumerator|Hangul_LCount
name|Hangul_LCount
init|=
literal|19
block|,
DECL|enumerator|Hangul_VCount
name|Hangul_VCount
init|=
literal|21
block|,
DECL|enumerator|Hangul_TCount
name|Hangul_TCount
init|=
literal|28
block|,
DECL|enumerator|Hangul_NCount
name|Hangul_NCount
init|=
literal|21
operator|*
literal|28
block|}
enum|;
end_enum
begin_define
DECL|macro|hangul_isPrecomposed
define|#
directive|define
name|hangul_isPrecomposed
parameter_list|(
name|uc
parameter_list|)
define|\
value|(uc>= Hangul_SBase&& uc< Hangul_SBase + Hangul_SCount)
end_define
begin_define
DECL|macro|hangul_isLV
define|#
directive|define
name|hangul_isLV
parameter_list|(
name|uc
parameter_list|)
define|\
value|((uc - Hangul_SBase) % Hangul_TCount == 0)
end_define
begin_typedef
typedef|typedef
enum|enum
block|{
DECL|enumerator|L
name|L
block|,
DECL|enumerator|V
name|V
block|,
DECL|enumerator|T
name|T
block|,
DECL|enumerator|LV
name|LV
block|,
DECL|enumerator|LVT
name|LVT
block|,
DECL|enumerator|X
name|X
block|}
DECL|typedef|HangulType
name|HangulType
typedef|;
end_typedef
begin_function
DECL|function|hangul_type
specifier|static
name|HangulType
name|hangul_type
parameter_list|(
name|unsigned
name|short
name|uc
parameter_list|)
block|{
if|if
condition|(
name|uc
operator|>
name|Hangul_SBase
operator|&&
name|uc
operator|<
name|Hangul_SBase
operator|+
name|Hangul_SCount
condition|)
return|return
name|hangul_isLV
argument_list|(
name|uc
argument_list|)
condition|?
name|LV
else|:
name|LVT
return|;
if|if
condition|(
name|uc
operator|<
name|Hangul_LBase
operator|||
name|uc
operator|>
literal|0x11ff
condition|)
return|return
name|X
return|;
if|if
condition|(
name|uc
operator|<
name|Hangul_VBase
condition|)
return|return
name|L
return|;
if|if
condition|(
name|uc
operator|<
name|Hangul_TBase
condition|)
return|return
name|V
return|;
return|return
name|T
return|;
block|}
end_function
begin_function
DECL|function|hangul_nextSyllableBoundary
specifier|static
name|int
name|hangul_nextSyllableBoundary
parameter_list|(
specifier|const
name|HB_UChar16
modifier|*
name|s
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|)
block|{
specifier|const
name|HB_UChar16
modifier|*
name|uc
init|=
name|s
operator|+
name|start
decl_stmt|;
name|HangulType
name|state
init|=
name|hangul_type
argument_list|(
operator|*
name|uc
argument_list|)
decl_stmt|;
name|int
name|pos
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|pos
operator|<
name|end
operator|-
name|start
condition|)
block|{
name|HangulType
name|newState
init|=
name|hangul_type
argument_list|(
name|uc
index|[
name|pos
index|]
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|newState
condition|)
block|{
case|case
name|X
case|:
goto|goto
name|finish
goto|;
case|case
name|L
case|:
case|case
name|V
case|:
case|case
name|T
case|:
if|if
condition|(
name|state
operator|>
name|newState
condition|)
goto|goto
name|finish
goto|;
name|state
operator|=
name|newState
expr_stmt|;
break|break;
case|case
name|LV
case|:
if|if
condition|(
name|state
operator|>
name|L
condition|)
goto|goto
name|finish
goto|;
name|state
operator|=
name|V
expr_stmt|;
break|break;
case|case
name|LVT
case|:
if|if
condition|(
name|state
operator|>
name|L
condition|)
goto|goto
name|finish
goto|;
name|state
operator|=
name|T
expr_stmt|;
block|}
operator|++
name|pos
expr_stmt|;
block|}
name|finish
label|:
return|return
name|start
operator|+
name|pos
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|NO_OPENTYPE
end_ifndef
begin_decl_stmt
DECL|variable|hangul_features
specifier|static
specifier|const
name|HB_OpenTypeFeature
name|hangul_features
index|[]
init|=
block|{
block|{
name|HB_MAKE_TAG
argument_list|(
literal|'c'
argument_list|,
literal|'c'
argument_list|,
literal|'m'
argument_list|,
literal|'p'
argument_list|)
block|,
name|CcmpProperty
block|}
block|,
block|{
name|HB_MAKE_TAG
argument_list|(
literal|'l'
argument_list|,
literal|'j'
argument_list|,
literal|'m'
argument_list|,
literal|'o'
argument_list|)
block|,
name|CcmpProperty
block|}
block|,
block|{
name|HB_MAKE_TAG
argument_list|(
literal|'v'
argument_list|,
literal|'j'
argument_list|,
literal|'m'
argument_list|,
literal|'o'
argument_list|)
block|,
name|CcmpProperty
block|}
block|,
block|{
name|HB_MAKE_TAG
argument_list|(
literal|'t'
argument_list|,
literal|'j'
argument_list|,
literal|'m'
argument_list|,
literal|'o'
argument_list|)
block|,
name|CcmpProperty
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|hangul_shape_syllable
specifier|static
name|HB_Bool
name|hangul_shape_syllable
parameter_list|(
name|HB_ShaperItem
modifier|*
name|item
parameter_list|,
name|HB_Bool
name|openType
parameter_list|)
block|{
specifier|const
name|HB_UChar16
modifier|*
name|ch
init|=
name|item
operator|->
name|string
operator|+
name|item
operator|->
name|item
operator|.
name|pos
decl_stmt|;
name|int
name|len
init|=
name|item
operator|->
name|item
operator|.
name|length
decl_stmt|;
ifndef|#
directive|ifndef
name|NO_OPENTYPE
specifier|const
name|int
name|availableGlyphs
init|=
name|item
operator|->
name|num_glyphs
decl_stmt|;
endif|#
directive|endif
name|int
name|i
decl_stmt|;
name|HB_UChar16
name|composed
init|=
literal|0
decl_stmt|;
comment|/* see if we can compose the syllable into a modern hangul */
if|if
condition|(
name|item
operator|->
name|item
operator|.
name|length
operator|==
literal|2
condition|)
block|{
name|int
name|LIndex
init|=
name|ch
index|[
literal|0
index|]
operator|-
name|Hangul_LBase
decl_stmt|;
name|int
name|VIndex
init|=
name|ch
index|[
literal|1
index|]
operator|-
name|Hangul_VBase
decl_stmt|;
if|if
condition|(
name|LIndex
operator|>=
literal|0
operator|&&
name|LIndex
operator|<
name|Hangul_LCount
operator|&&
name|VIndex
operator|>=
literal|0
operator|&&
name|VIndex
operator|<
name|Hangul_VCount
condition|)
name|composed
operator|=
operator|(
name|LIndex
operator|*
name|Hangul_VCount
operator|+
name|VIndex
operator|)
operator|*
name|Hangul_TCount
operator|+
name|Hangul_SBase
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|item
operator|->
name|item
operator|.
name|length
operator|==
literal|3
condition|)
block|{
name|int
name|LIndex
init|=
name|ch
index|[
literal|0
index|]
operator|-
name|Hangul_LBase
decl_stmt|;
name|int
name|VIndex
init|=
name|ch
index|[
literal|1
index|]
operator|-
name|Hangul_VBase
decl_stmt|;
name|int
name|TIndex
init|=
name|ch
index|[
literal|2
index|]
operator|-
name|Hangul_TBase
decl_stmt|;
if|if
condition|(
name|LIndex
operator|>=
literal|0
operator|&&
name|LIndex
operator|<
name|Hangul_LCount
operator|&&
name|VIndex
operator|>=
literal|0
operator|&&
name|VIndex
operator|<
name|Hangul_VCount
operator|&&
name|TIndex
operator|>=
literal|0
operator|&&
name|TIndex
operator|<
name|Hangul_TCount
condition|)
name|composed
operator|=
operator|(
name|LIndex
operator|*
name|Hangul_VCount
operator|+
name|VIndex
operator|)
operator|*
name|Hangul_TCount
operator|+
name|TIndex
operator|+
name|Hangul_SBase
expr_stmt|;
block|}
comment|/* if we have a modern hangul use the composed form */
if|if
condition|(
name|composed
condition|)
block|{
name|ch
operator|=
operator|&
name|composed
expr_stmt|;
name|len
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|item
operator|->
name|font
operator|->
name|klass
operator|->
name|convertStringToGlyphIndices
argument_list|(
name|item
operator|->
name|font
argument_list|,
name|ch
argument_list|,
name|len
argument_list|,
name|item
operator|->
name|glyphs
argument_list|,
operator|&
name|item
operator|->
name|num_glyphs
argument_list|,
name|item
operator|->
name|item
operator|.
name|bidiLevel
operator|%
literal|2
argument_list|)
condition|)
return|return
name|FALSE
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|item
operator|->
name|attributes
index|[
name|i
index|]
operator|.
name|mark
operator|=
name|FALSE
expr_stmt|;
name|item
operator|->
name|attributes
index|[
name|i
index|]
operator|.
name|clusterStart
operator|=
name|FALSE
expr_stmt|;
name|item
operator|->
name|attributes
index|[
name|i
index|]
operator|.
name|justification
operator|=
literal|0
expr_stmt|;
name|item
operator|->
name|attributes
index|[
name|i
index|]
operator|.
name|zeroWidth
operator|=
name|FALSE
expr_stmt|;
comment|/*IDEBUG("    %d: %4x", i, ch[i].unicode()); */
block|}
ifndef|#
directive|ifndef
name|NO_OPENTYPE
if|if
condition|(
operator|!
name|composed
operator|&&
name|openType
condition|)
block|{
name|HB_Bool
name|positioned
decl_stmt|;
name|HB_STACKARRAY
argument_list|(
argument|unsigned short
argument_list|,
argument|logClusters
argument_list|,
argument|len
argument_list|)
empty_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
name|logClusters
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
name|item
operator|->
name|log_clusters
operator|=
name|logClusters
expr_stmt|;
name|HB_OpenTypeShape
argument_list|(
name|item
argument_list|,
comment|/*properties*/
literal|0
argument_list|)
expr_stmt|;
name|positioned
operator|=
name|HB_OpenTypePosition
argument_list|(
name|item
argument_list|,
name|availableGlyphs
argument_list|,
comment|/*doLogClusters*/
name|FALSE
argument_list|)
expr_stmt|;
name|HB_FREE_STACKARRAY
argument_list|(
name|logClusters
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|positioned
condition|)
return|return
name|FALSE
return|;
block|}
else|else
block|{
name|HB_HeuristicPosition
argument_list|(
name|item
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|item
operator|->
name|attributes
index|[
literal|0
index|]
operator|.
name|clusterStart
operator|=
name|TRUE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function
begin_function
DECL|function|HB_HangulShape
name|HB_Bool
name|HB_HangulShape
parameter_list|(
name|HB_ShaperItem
modifier|*
name|item
parameter_list|)
block|{
specifier|const
name|HB_UChar16
modifier|*
name|uc
init|=
name|item
operator|->
name|string
operator|+
name|item
operator|->
name|item
operator|.
name|pos
decl_stmt|;
name|HB_Bool
name|allPrecomposed
init|=
name|TRUE
decl_stmt|;
name|int
name|i
decl_stmt|;
name|assert
argument_list|(
name|item
operator|->
name|item
operator|.
name|script
operator|==
name|HB_Script_Hangul
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|item
operator|->
name|item
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|hangul_isPrecomposed
argument_list|(
name|uc
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|allPrecomposed
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|allPrecomposed
condition|)
block|{
name|HB_Bool
name|openType
init|=
name|FALSE
decl_stmt|;
name|unsigned
name|short
modifier|*
name|logClusters
init|=
name|item
operator|->
name|log_clusters
decl_stmt|;
name|HB_ShaperItem
name|syllable
decl_stmt|;
name|int
name|first_glyph
init|=
literal|0
decl_stmt|;
name|int
name|sstart
init|=
name|item
operator|->
name|item
operator|.
name|pos
decl_stmt|;
name|int
name|end
init|=
name|sstart
operator|+
name|item
operator|->
name|item
operator|.
name|length
decl_stmt|;
ifndef|#
directive|ifndef
name|NO_OPENTYPE
name|openType
operator|=
name|HB_SelectScript
argument_list|(
name|item
argument_list|,
name|hangul_features
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|syllable
operator|=
operator|*
name|item
expr_stmt|;
while|while
condition|(
name|sstart
operator|<
name|end
condition|)
block|{
name|int
name|send
init|=
name|hangul_nextSyllableBoundary
argument_list|(
name|item
operator|->
name|string
argument_list|,
name|sstart
argument_list|,
name|end
argument_list|)
decl_stmt|;
name|syllable
operator|.
name|item
operator|.
name|pos
operator|=
name|sstart
expr_stmt|;
name|syllable
operator|.
name|item
operator|.
name|length
operator|=
name|send
operator|-
name|sstart
expr_stmt|;
name|syllable
operator|.
name|glyphs
operator|=
name|item
operator|->
name|glyphs
operator|+
name|first_glyph
expr_stmt|;
name|syllable
operator|.
name|attributes
operator|=
name|item
operator|->
name|attributes
operator|+
name|first_glyph
expr_stmt|;
name|syllable
operator|.
name|offsets
operator|=
name|item
operator|->
name|offsets
operator|+
name|first_glyph
expr_stmt|;
name|syllable
operator|.
name|advances
operator|=
name|item
operator|->
name|advances
operator|+
name|first_glyph
expr_stmt|;
name|syllable
operator|.
name|num_glyphs
operator|=
name|item
operator|->
name|num_glyphs
operator|-
name|first_glyph
expr_stmt|;
if|if
condition|(
operator|!
name|hangul_shape_syllable
argument_list|(
operator|&
name|syllable
argument_list|,
name|openType
argument_list|)
condition|)
block|{
name|item
operator|->
name|num_glyphs
operator|+=
name|syllable
operator|.
name|num_glyphs
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* fix logcluster array */
for|for
control|(
name|i
operator|=
name|sstart
init|;
name|i
operator|<
name|send
condition|;
operator|++
name|i
control|)
name|logClusters
index|[
name|i
operator|-
name|item
operator|->
name|item
operator|.
name|pos
index|]
operator|=
name|first_glyph
expr_stmt|;
name|sstart
operator|=
name|send
expr_stmt|;
name|first_glyph
operator|+=
name|syllable
operator|.
name|num_glyphs
expr_stmt|;
block|}
name|item
operator|->
name|num_glyphs
operator|=
name|first_glyph
expr_stmt|;
return|return
name|TRUE
return|;
block|}
return|return
name|HB_BasicShape
argument_list|(
name|item
argument_list|)
return|;
block|}
end_function
end_unit
