begin_unit
begin_comment
comment|/*  * Copyright (C) 1998-2004  David Turner and Werner Lemberg  * Copyright (C) 2006  Behdad Esfahbod  *  * This is part of HarfBuzz, an OpenType Layout engine library.  *  * Permission is hereby granted, without written agreement and without  * license or royalty fees, to use, copy, modify, and distribute this  * software and its documentation for any purpose, provided that the  * above copyright notice and the following two paragraphs appear in  * all copies of this software.  *  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH  * DAMAGE.  *  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS  * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.  */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|HARFBUZZ_OPEN_H
end_ifndef
begin_define
DECL|macro|HARFBUZZ_OPEN_H
define|#
directive|define
name|HARFBUZZ_OPEN_H
end_define
begin_include
include|#
directive|include
file|"harfbuzz-global.h"
end_include
begin_macro
name|HB_BEGIN_HEADER
end_macro
begin_comment
comment|/* Use this if a feature applies to all glyphs */
end_comment
begin_define
DECL|macro|HB_ALL_GLYPHS
define|#
directive|define
name|HB_ALL_GLYPHS
value|0xFFFF
end_define
begin_define
DECL|macro|HB_DEFAULT_LANGUAGE
define|#
directive|define
name|HB_DEFAULT_LANGUAGE
value|0xFFFF
end_define
begin_define
DECL|macro|HB_MAX_NESTING_LEVEL
define|#
directive|define
name|HB_MAX_NESTING_LEVEL
value|100
end_define
begin_comment
comment|/* Script list related structures */
end_comment
begin_struct
DECL|struct|HB_LangSys_
struct|struct
name|HB_LangSys_
block|{
DECL|member|FeatureIndex
name|HB_UShort
modifier|*
name|FeatureIndex
decl_stmt|;
comment|/* array of Feature indices  */
DECL|member|LookupOrderOffset
name|HB_UShort
name|LookupOrderOffset
decl_stmt|;
comment|/* always 0 for TT Open 1.0  */
DECL|member|ReqFeatureIndex
name|HB_UShort
name|ReqFeatureIndex
decl_stmt|;
comment|/* required FeatureIndex     */
DECL|member|FeatureCount
name|HB_UShort
name|FeatureCount
decl_stmt|;
comment|/* number of Feature indices */
block|}
struct|;
end_struct
begin_typedef
DECL|typedef|HB_LangSys
typedef|typedef
name|struct
name|HB_LangSys_
name|HB_LangSys
typedef|;
end_typedef
begin_struct
DECL|struct|HB_LangSysRecord_
struct|struct
name|HB_LangSysRecord_
block|{
DECL|member|LangSys
name|HB_LangSys
name|LangSys
decl_stmt|;
comment|/* LangSys table         */
DECL|member|LangSysTag
name|HB_UInt
name|LangSysTag
decl_stmt|;
comment|/* LangSysTag identifier */
block|}
struct|;
end_struct
begin_typedef
DECL|typedef|HB_LangSysRecord
typedef|typedef
name|struct
name|HB_LangSysRecord_
name|HB_LangSysRecord
typedef|;
end_typedef
begin_struct
DECL|struct|HB_ScriptTable_
struct|struct
name|HB_ScriptTable_
block|{
DECL|member|LangSysRecord
name|HB_LangSysRecord
modifier|*
name|LangSysRecord
decl_stmt|;
comment|/* array of LangSysRecords  */
DECL|member|DefaultLangSys
name|HB_LangSys
name|DefaultLangSys
decl_stmt|;
comment|/* DefaultLangSys table     */
DECL|member|LangSysCount
name|HB_UShort
name|LangSysCount
decl_stmt|;
comment|/* number of LangSysRecords */
block|}
struct|;
end_struct
begin_typedef
DECL|typedef|HB_ScriptTable
typedef|typedef
name|struct
name|HB_ScriptTable_
name|HB_ScriptTable
typedef|;
end_typedef
begin_struct
DECL|struct|HB_ScriptRecord_
struct|struct
name|HB_ScriptRecord_
block|{
DECL|member|ScriptTag
name|HB_UInt
name|ScriptTag
decl_stmt|;
comment|/* ScriptTag identifier */
DECL|member|Script
name|HB_ScriptTable
name|Script
decl_stmt|;
comment|/* Script table         */
block|}
struct|;
end_struct
begin_typedef
DECL|typedef|HB_ScriptRecord
typedef|typedef
name|struct
name|HB_ScriptRecord_
name|HB_ScriptRecord
typedef|;
end_typedef
begin_struct
DECL|struct|HB_ScriptList_
struct|struct
name|HB_ScriptList_
block|{
DECL|member|ScriptRecord
name|HB_ScriptRecord
modifier|*
name|ScriptRecord
decl_stmt|;
comment|/* array of ScriptRecords  */
DECL|member|ScriptCount
name|HB_UShort
name|ScriptCount
decl_stmt|;
comment|/* number of ScriptRecords */
block|}
struct|;
end_struct
begin_typedef
DECL|typedef|HB_ScriptList
typedef|typedef
name|struct
name|HB_ScriptList_
name|HB_ScriptList
typedef|;
end_typedef
begin_comment
comment|/* Feature list related structures */
end_comment
begin_struct
DECL|struct|HB_Feature_
struct|struct
name|HB_Feature_
block|{
DECL|member|LookupListIndex
name|HB_UShort
modifier|*
name|LookupListIndex
decl_stmt|;
comment|/* array of LookupList indices  */
DECL|member|FeatureParams
name|HB_UShort
name|FeatureParams
decl_stmt|;
comment|/* always 0 for TT Open 1.0     */
DECL|member|LookupListCount
name|HB_UShort
name|LookupListCount
decl_stmt|;
comment|/* number of LookupList indices */
block|}
struct|;
end_struct
begin_typedef
DECL|typedef|HB_Feature
typedef|typedef
name|struct
name|HB_Feature_
name|HB_Feature
typedef|;
end_typedef
begin_struct
DECL|struct|HB_FeatureRecord_
struct|struct
name|HB_FeatureRecord_
block|{
DECL|member|FeatureTag
name|HB_UInt
name|FeatureTag
decl_stmt|;
comment|/* FeatureTag identifier */
DECL|member|Feature
name|HB_Feature
name|Feature
decl_stmt|;
comment|/* Feature table         */
block|}
struct|;
end_struct
begin_typedef
DECL|typedef|HB_FeatureRecord
typedef|typedef
name|struct
name|HB_FeatureRecord_
name|HB_FeatureRecord
typedef|;
end_typedef
begin_struct
DECL|struct|HB_FeatureList_
struct|struct
name|HB_FeatureList_
block|{
DECL|member|ApplyOrder
name|HB_UShort
modifier|*
name|ApplyOrder
decl_stmt|;
comment|/* order to apply features */
DECL|member|FeatureRecord
name|HB_FeatureRecord
modifier|*
name|FeatureRecord
decl_stmt|;
comment|/* array of FeatureRecords  */
DECL|member|FeatureCount
name|HB_UShort
name|FeatureCount
decl_stmt|;
comment|/* number of FeatureRecords */
DECL|member|ApplyCount
name|HB_UShort
name|ApplyCount
decl_stmt|;
comment|/* number of elements in ApplyOrder */
block|}
struct|;
end_struct
begin_typedef
DECL|typedef|HB_FeatureList
typedef|typedef
name|struct
name|HB_FeatureList_
name|HB_FeatureList
typedef|;
end_typedef
begin_comment
comment|/* Lookup list related structures */
end_comment
begin_typedef
DECL|typedef|HB_SubTable
typedef|typedef
name|struct
name|HB_SubTable_
name|HB_SubTable
typedef|;
end_typedef
begin_struct
DECL|struct|HB_Lookup_
struct|struct
name|HB_Lookup_
block|{
DECL|member|SubTable
name|HB_SubTable
modifier|*
name|SubTable
decl_stmt|;
comment|/* array of SubTables  */
DECL|member|LookupType
name|HB_UShort
name|LookupType
decl_stmt|;
comment|/* Lookup type         */
DECL|member|LookupFlag
name|HB_UShort
name|LookupFlag
decl_stmt|;
comment|/* Lookup qualifiers   */
DECL|member|SubTableCount
name|HB_UShort
name|SubTableCount
decl_stmt|;
comment|/* number of SubTables */
block|}
struct|;
end_struct
begin_typedef
DECL|typedef|HB_Lookup
typedef|typedef
name|struct
name|HB_Lookup_
name|HB_Lookup
typedef|;
end_typedef
begin_comment
comment|/* The `Properties' field is not defined in the OpenType specification but    is needed for processing lookups.  If properties[n] is> 0, the    functions HB_GSUB_Apply_String() resp. HB_GPOS_Apply_String() will    process Lookup[n] for glyphs which have the specific bit not set in    the `properties' field of the input string object.                  */
end_comment
begin_struct
DECL|struct|HB_LookupList_
struct|struct
name|HB_LookupList_
block|{
DECL|member|Lookup
name|HB_Lookup
modifier|*
name|Lookup
decl_stmt|;
comment|/* array of Lookup records */
DECL|member|Properties
name|HB_UInt
modifier|*
name|Properties
decl_stmt|;
comment|/* array of flags          */
DECL|member|LookupCount
name|HB_UShort
name|LookupCount
decl_stmt|;
comment|/* number of Lookups       */
block|}
struct|;
end_struct
begin_typedef
DECL|typedef|HB_LookupList
typedef|typedef
name|struct
name|HB_LookupList_
name|HB_LookupList
typedef|;
end_typedef
begin_comment
comment|/* Possible LookupFlag bit masks.  `HB_LOOKUP_FLAG_IGNORE_SPECIAL_MARKS' comes from the    OpenType 1.2 specification; HB_LOOKUP_FLAG_RIGHT_TO_LEFT has been (re)introduced in    OpenType 1.3 -- if set, the last glyph in a cursive attachment    sequence has to be positioned on the baseline -- regardless of the    writing direction.                                                    */
end_comment
begin_define
DECL|macro|HB_LOOKUP_FLAG_RIGHT_TO_LEFT
define|#
directive|define
name|HB_LOOKUP_FLAG_RIGHT_TO_LEFT
value|0x0001
end_define
begin_define
DECL|macro|HB_LOOKUP_FLAG_IGNORE_BASE_GLYPHS
define|#
directive|define
name|HB_LOOKUP_FLAG_IGNORE_BASE_GLYPHS
value|0x0002
end_define
begin_define
DECL|macro|HB_LOOKUP_FLAG_IGNORE_LIGATURES
define|#
directive|define
name|HB_LOOKUP_FLAG_IGNORE_LIGATURES
value|0x0004
end_define
begin_define
DECL|macro|HB_LOOKUP_FLAG_IGNORE_MARKS
define|#
directive|define
name|HB_LOOKUP_FLAG_IGNORE_MARKS
value|0x0008
end_define
begin_define
DECL|macro|HB_LOOKUP_FLAG_IGNORE_SPECIAL_MARKS
define|#
directive|define
name|HB_LOOKUP_FLAG_IGNORE_SPECIAL_MARKS
value|0xFF00
end_define
begin_struct
DECL|struct|HB_CoverageFormat1_
struct|struct
name|HB_CoverageFormat1_
block|{
DECL|member|GlyphArray
name|HB_UShort
modifier|*
name|GlyphArray
decl_stmt|;
comment|/* array of glyph IDs             */
DECL|member|GlyphCount
name|HB_UShort
name|GlyphCount
decl_stmt|;
comment|/* number of glyphs in GlyphArray */
block|}
struct|;
end_struct
begin_typedef
DECL|typedef|HB_CoverageFormat1
typedef|typedef
name|struct
name|HB_CoverageFormat1_
name|HB_CoverageFormat1
typedef|;
end_typedef
begin_struct
DECL|struct|HB_RangeRecord_
struct|struct
name|HB_RangeRecord_
block|{
DECL|member|Start
name|HB_UShort
name|Start
decl_stmt|;
comment|/* first glyph ID in the range */
DECL|member|End
name|HB_UShort
name|End
decl_stmt|;
comment|/* last glyph ID in the range  */
DECL|member|StartCoverageIndex
name|HB_UShort
name|StartCoverageIndex
decl_stmt|;
comment|/* coverage index of first 					 glyph ID in the range       */
block|}
struct|;
end_struct
begin_typedef
DECL|typedef|HB_RangeRecord
typedef|typedef
name|struct
name|HB_RangeRecord_
name|HB_RangeRecord
typedef|;
end_typedef
begin_struct
DECL|struct|HB_CoverageFormat2_
struct|struct
name|HB_CoverageFormat2_
block|{
DECL|member|RangeRecord
name|HB_RangeRecord
modifier|*
name|RangeRecord
decl_stmt|;
comment|/* array of RangeRecords  */
DECL|member|RangeCount
name|HB_UShort
name|RangeCount
decl_stmt|;
comment|/* number of RangeRecords */
block|}
struct|;
end_struct
begin_typedef
DECL|typedef|HB_CoverageFormat2
typedef|typedef
name|struct
name|HB_CoverageFormat2_
name|HB_CoverageFormat2
typedef|;
end_typedef
begin_struct
DECL|struct|HB_Coverage_
struct|struct
name|HB_Coverage_
block|{
DECL|member|CoverageFormat
name|HB_Byte
name|CoverageFormat
decl_stmt|;
comment|/* 1 or 2 */
union|union
block|{
DECL|member|cf1
name|HB_CoverageFormat1
name|cf1
decl_stmt|;
DECL|member|cf2
name|HB_CoverageFormat2
name|cf2
decl_stmt|;
block|}
DECL|member|cf
name|cf
union|;
block|}
struct|;
end_struct
begin_typedef
DECL|typedef|HB_Coverage
typedef|typedef
name|struct
name|HB_Coverage_
name|HB_Coverage
typedef|;
end_typedef
begin_struct
DECL|struct|HB_ClassDefFormat1_
struct|struct
name|HB_ClassDefFormat1_
block|{
DECL|member|ClassValueArray
name|HB_UShort
modifier|*
name|ClassValueArray
decl_stmt|;
comment|/* array of class values       */
DECL|member|StartGlyph
name|HB_UShort
name|StartGlyph
decl_stmt|;
comment|/* first glyph ID of the 					 ClassValueArray             */
DECL|member|GlyphCount
name|HB_UShort
name|GlyphCount
decl_stmt|;
comment|/* size of the ClassValueArray */
block|}
struct|;
end_struct
begin_typedef
DECL|typedef|HB_ClassDefFormat1
typedef|typedef
name|struct
name|HB_ClassDefFormat1_
name|HB_ClassDefFormat1
typedef|;
end_typedef
begin_struct
DECL|struct|HB_ClassRangeRecord_
struct|struct
name|HB_ClassRangeRecord_
block|{
DECL|member|Start
name|HB_UShort
name|Start
decl_stmt|;
comment|/* first glyph ID in the range    */
DECL|member|End
name|HB_UShort
name|End
decl_stmt|;
comment|/* last glyph ID in the range     */
DECL|member|Class
name|HB_UShort
name|Class
decl_stmt|;
comment|/* applied to all glyphs in range */
block|}
struct|;
end_struct
begin_typedef
DECL|typedef|HB_ClassRangeRecord
typedef|typedef
name|struct
name|HB_ClassRangeRecord_
name|HB_ClassRangeRecord
typedef|;
end_typedef
begin_struct
DECL|struct|HB_ClassDefFormat2_
struct|struct
name|HB_ClassDefFormat2_
block|{
DECL|member|ClassRangeRecord
name|HB_ClassRangeRecord
modifier|*
name|ClassRangeRecord
decl_stmt|;
comment|/* array of ClassRangeRecords  */
DECL|member|ClassRangeCount
name|HB_UShort
name|ClassRangeCount
decl_stmt|;
comment|/* number of ClassRangeRecords */
block|}
struct|;
end_struct
begin_typedef
DECL|typedef|HB_ClassDefFormat2
typedef|typedef
name|struct
name|HB_ClassDefFormat2_
name|HB_ClassDefFormat2
typedef|;
end_typedef
begin_struct
DECL|struct|HB_ClassDefinition_
struct|struct
name|HB_ClassDefinition_
block|{
union|union
block|{
DECL|member|cd1
name|HB_ClassDefFormat1
name|cd1
decl_stmt|;
DECL|member|cd2
name|HB_ClassDefFormat2
name|cd2
decl_stmt|;
block|}
DECL|member|cd
name|cd
union|;
DECL|member|ClassFormat
name|HB_Byte
name|ClassFormat
decl_stmt|;
comment|/* 1 or 2                      */
DECL|member|loaded
name|HB_Bool
name|loaded
decl_stmt|;
block|}
struct|;
end_struct
begin_typedef
DECL|typedef|HB_ClassDefinition
typedef|typedef
name|struct
name|HB_ClassDefinition_
name|HB_ClassDefinition
typedef|;
end_typedef
begin_struct
DECL|struct|HB_Device_
struct|struct
name|HB_Device_
block|{
DECL|member|DeltaValue
name|HB_UShort
modifier|*
name|DeltaValue
decl_stmt|;
comment|/* array of compressed data      */
DECL|member|StartSize
name|HB_UShort
name|StartSize
decl_stmt|;
comment|/* smallest size to correct      */
DECL|member|EndSize
name|HB_UShort
name|EndSize
decl_stmt|;
comment|/* largest size to correct       */
DECL|member|DeltaFormat
name|HB_Byte
name|DeltaFormat
decl_stmt|;
comment|/* DeltaValue array data format: 					 1, 2, or 3                    */
block|}
struct|;
end_struct
begin_typedef
DECL|typedef|HB_Device
typedef|typedef
name|struct
name|HB_Device_
name|HB_Device
typedef|;
end_typedef
begin_enum
DECL|enum|HB_Type_
enum|enum
name|HB_Type_
block|{
DECL|enumerator|HB_Type_GSUB
name|HB_Type_GSUB
block|,
DECL|enumerator|HB_Type_GPOS
name|HB_Type_GPOS
block|}
enum|;
end_enum
begin_typedef
DECL|typedef|HB_Type
typedef|typedef
name|enum
name|HB_Type_
name|HB_Type
typedef|;
end_typedef
begin_macro
name|HB_END_HEADER
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* HARFBUZZ_OPEN_H */
end_comment
end_unit
