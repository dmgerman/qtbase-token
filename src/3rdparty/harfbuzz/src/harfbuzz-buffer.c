begin_unit
begin_comment
comment|/*  * Copyright (C) 1998-2004  David Turner and Werner Lemberg  * Copyright (C) 2004,2007  Red Hat, Inc.  *  * This is part of HarfBuzz, an OpenType Layout engine library.  *  * Permission is hereby granted, without written agreement and without  * license or royalty fees, to use, copy, modify, and distribute this  * software and its documentation for any purpose, provided that the  * above copyright notice and the following two paragraphs appear in  * all copies of this software.  *  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH  * DAMAGE.  *  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS  * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.  *  * Red Hat Author(s): Owen Taylor, Behdad Esfahbod  */
end_comment
begin_include
include|#
directive|include
file|"harfbuzz-impl.h"
end_include
begin_include
include|#
directive|include
file|"harfbuzz-buffer-private.h"
end_include
begin_include
include|#
directive|include
file|"harfbuzz-gsub-private.h"
end_include
begin_include
include|#
directive|include
file|"harfbuzz-gpos-private.h"
end_include
begin_comment
comment|/* Here is how the buffer works internally:  *  * There are two string pointers: in_string and out_string.  They  * always have same allocated size, but different length and positions.  *  * As an optimization, both in_string and out_string may point to the  * same piece of memory, which is owned by in_string.  This remains the  * case as long as:  *  *   - copy_glyph() is called  *   - replace_glyph() is called with inplace=TRUE  *   - add_output_glyph() and add_output_glyphs() are not called  *  * In that case swap(), and copy_glyph(), and replace_glyph() are all  * mostly no-op.  *  * As soon an add_output_glyph[s]() or replace_glyph() with inplace=FALSE is  * called, out_string is moved over to an alternate buffer (alt_string), and  * its current contents (out_length entries) are copied to the alt buffer.  * This should all remain transparent to the user.  swap() then switches  * in_string and alt_string.  alt_string is not allocated until its needed,  * but after that it's grown with in_string unconditionally.  *  * The buffer->separate_out boolean keeps status of whether out_string points  * to in_string (FALSE) or alt_string (TRUE).  */
end_comment
begin_comment
comment|/* Internal API */
end_comment
begin_function
specifier|static
name|HB_Error
DECL|function|hb_buffer_ensure
name|hb_buffer_ensure
parameter_list|(
name|HB_Buffer
name|buffer
parameter_list|,
name|HB_UInt
name|size
parameter_list|)
block|{
name|HB_UInt
name|new_allocated
init|=
name|buffer
operator|->
name|allocated
decl_stmt|;
if|if
condition|(
name|size
operator|>
name|new_allocated
condition|)
block|{
name|HB_Error
name|error
decl_stmt|;
while|while
condition|(
name|size
operator|>
name|new_allocated
condition|)
name|new_allocated
operator|+=
operator|(
name|new_allocated
operator|>>
literal|1
operator|)
operator|+
literal|8
expr_stmt|;
if|if
condition|(
name|buffer
operator|->
name|positions
condition|)
block|{
if|if
condition|(
name|REALLOC_ARRAY
argument_list|(
name|buffer
operator|->
name|positions
argument_list|,
name|new_allocated
argument_list|,
name|HB_PositionRec
argument_list|)
condition|)
return|return
name|error
return|;
block|}
if|if
condition|(
name|REALLOC_ARRAY
argument_list|(
name|buffer
operator|->
name|in_string
argument_list|,
name|new_allocated
argument_list|,
name|HB_GlyphItemRec
argument_list|)
condition|)
return|return
name|error
return|;
if|if
condition|(
name|buffer
operator|->
name|separate_out
condition|)
block|{
if|if
condition|(
name|REALLOC_ARRAY
argument_list|(
name|buffer
operator|->
name|alt_string
argument_list|,
name|new_allocated
argument_list|,
name|HB_GlyphItemRec
argument_list|)
condition|)
return|return
name|error
return|;
name|buffer
operator|->
name|out_string
operator|=
name|buffer
operator|->
name|alt_string
expr_stmt|;
block|}
else|else
block|{
name|buffer
operator|->
name|out_string
operator|=
name|buffer
operator|->
name|in_string
expr_stmt|;
if|if
condition|(
name|buffer
operator|->
name|alt_string
condition|)
block|{
if|if
condition|(
name|REALLOC_ARRAY
argument_list|(
name|buffer
operator|->
name|alt_string
argument_list|,
name|new_allocated
argument_list|,
name|HB_GlyphItemRec
argument_list|)
condition|)
return|return
name|error
return|;
block|}
block|}
name|buffer
operator|->
name|allocated
operator|=
name|new_allocated
expr_stmt|;
block|}
return|return
name|HB_Err_Ok
return|;
block|}
end_function
begin_function
specifier|static
name|HB_Error
DECL|function|hb_buffer_duplicate_out_buffer
name|hb_buffer_duplicate_out_buffer
parameter_list|(
name|HB_Buffer
name|buffer
parameter_list|)
block|{
if|if
condition|(
operator|!
name|buffer
operator|->
name|alt_string
condition|)
block|{
name|HB_Error
name|error
decl_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|buffer
operator|->
name|alt_string
argument_list|,
name|buffer
operator|->
name|allocated
argument_list|,
name|HB_GlyphItemRec
argument_list|)
condition|)
return|return
name|error
return|;
block|}
name|buffer
operator|->
name|out_string
operator|=
name|buffer
operator|->
name|alt_string
expr_stmt|;
name|memcpy
argument_list|(
name|buffer
operator|->
name|out_string
argument_list|,
name|buffer
operator|->
name|in_string
argument_list|,
name|buffer
operator|->
name|out_length
operator|*
sizeof|sizeof
argument_list|(
name|buffer
operator|->
name|out_string
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|buffer
operator|->
name|separate_out
operator|=
name|TRUE
expr_stmt|;
return|return
name|HB_Err_Ok
return|;
block|}
end_function
begin_comment
comment|/* Public API */
end_comment
begin_function
name|HB_Error
DECL|function|hb_buffer_new
name|hb_buffer_new
parameter_list|(
name|HB_Buffer
modifier|*
name|pbuffer
parameter_list|)
block|{
name|HB_Buffer
name|buffer
decl_stmt|;
name|HB_Error
name|error
decl_stmt|;
if|if
condition|(
name|ALLOC
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|HB_BufferRec
argument_list|)
argument_list|)
condition|)
return|return
name|error
return|;
name|buffer
operator|->
name|allocated
operator|=
literal|0
expr_stmt|;
name|buffer
operator|->
name|in_string
operator|=
name|NULL
expr_stmt|;
name|buffer
operator|->
name|alt_string
operator|=
name|NULL
expr_stmt|;
name|buffer
operator|->
name|positions
operator|=
name|NULL
expr_stmt|;
name|hb_buffer_clear
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
operator|*
name|pbuffer
operator|=
name|buffer
expr_stmt|;
return|return
name|HB_Err_Ok
return|;
block|}
end_function
begin_function
name|void
DECL|function|hb_buffer_free
name|hb_buffer_free
parameter_list|(
name|HB_Buffer
name|buffer
parameter_list|)
block|{
name|FREE
argument_list|(
name|buffer
operator|->
name|in_string
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|buffer
operator|->
name|alt_string
argument_list|)
expr_stmt|;
name|buffer
operator|->
name|out_string
operator|=
name|NULL
expr_stmt|;
name|FREE
argument_list|(
name|buffer
operator|->
name|positions
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
name|void
DECL|function|hb_buffer_clear
name|hb_buffer_clear
parameter_list|(
name|HB_Buffer
name|buffer
parameter_list|)
block|{
name|buffer
operator|->
name|in_length
operator|=
literal|0
expr_stmt|;
name|buffer
operator|->
name|out_length
operator|=
literal|0
expr_stmt|;
name|buffer
operator|->
name|in_pos
operator|=
literal|0
expr_stmt|;
name|buffer
operator|->
name|out_pos
operator|=
literal|0
expr_stmt|;
name|buffer
operator|->
name|out_string
operator|=
name|buffer
operator|->
name|in_string
expr_stmt|;
name|buffer
operator|->
name|separate_out
operator|=
name|FALSE
expr_stmt|;
name|buffer
operator|->
name|max_ligID
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_function
name|HB_Error
DECL|function|hb_buffer_add_glyph
name|hb_buffer_add_glyph
parameter_list|(
name|HB_Buffer
name|buffer
parameter_list|,
name|HB_UInt
name|glyph_index
parameter_list|,
name|HB_UInt
name|properties
parameter_list|,
name|HB_UInt
name|cluster
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_GlyphItem
name|glyph
decl_stmt|;
name|error
operator|=
name|hb_buffer_ensure
argument_list|(
name|buffer
argument_list|,
name|buffer
operator|->
name|in_length
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|glyph
operator|=
operator|&
name|buffer
operator|->
name|in_string
index|[
name|buffer
operator|->
name|in_length
index|]
expr_stmt|;
name|glyph
operator|->
name|gindex
operator|=
name|glyph_index
expr_stmt|;
name|glyph
operator|->
name|properties
operator|=
name|properties
expr_stmt|;
name|glyph
operator|->
name|cluster
operator|=
name|cluster
expr_stmt|;
name|glyph
operator|->
name|component
operator|=
literal|0
expr_stmt|;
name|glyph
operator|->
name|ligID
operator|=
literal|0
expr_stmt|;
name|glyph
operator|->
name|gproperties
operator|=
name|HB_GLYPH_PROPERTIES_UNKNOWN
expr_stmt|;
name|buffer
operator|->
name|in_length
operator|++
expr_stmt|;
return|return
name|HB_Err_Ok
return|;
block|}
end_function
begin_comment
comment|/* HarfBuzz-Internal API */
end_comment
begin_function
name|HB_INTERNAL
name|void
DECL|function|_hb_buffer_clear_output
name|_hb_buffer_clear_output
parameter_list|(
name|HB_Buffer
name|buffer
parameter_list|)
block|{
name|buffer
operator|->
name|out_length
operator|=
literal|0
expr_stmt|;
name|buffer
operator|->
name|out_pos
operator|=
literal|0
expr_stmt|;
name|buffer
operator|->
name|out_string
operator|=
name|buffer
operator|->
name|in_string
expr_stmt|;
name|buffer
operator|->
name|separate_out
operator|=
name|FALSE
expr_stmt|;
block|}
end_function
begin_function
name|HB_INTERNAL
name|HB_Error
DECL|function|_hb_buffer_clear_positions
name|_hb_buffer_clear_positions
parameter_list|(
name|HB_Buffer
name|buffer
parameter_list|)
block|{
if|if
condition|(
operator|!
name|buffer
operator|->
name|positions
condition|)
block|{
name|HB_Error
name|error
decl_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|buffer
operator|->
name|positions
argument_list|,
name|buffer
operator|->
name|allocated
argument_list|,
name|HB_PositionRec
argument_list|)
condition|)
return|return
name|error
return|;
block|}
name|memset
argument_list|(
name|buffer
operator|->
name|positions
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
operator|->
name|positions
index|[
literal|0
index|]
argument_list|)
operator|*
name|buffer
operator|->
name|in_length
argument_list|)
expr_stmt|;
return|return
name|HB_Err_Ok
return|;
block|}
end_function
begin_function
name|HB_INTERNAL
name|void
DECL|function|_hb_buffer_swap
name|_hb_buffer_swap
parameter_list|(
name|HB_Buffer
name|buffer
parameter_list|)
block|{
name|HB_GlyphItem
name|tmp_string
decl_stmt|;
name|int
name|tmp_length
decl_stmt|;
name|int
name|tmp_pos
decl_stmt|;
if|if
condition|(
name|buffer
operator|->
name|separate_out
condition|)
block|{
name|tmp_string
operator|=
name|buffer
operator|->
name|in_string
expr_stmt|;
name|buffer
operator|->
name|in_string
operator|=
name|buffer
operator|->
name|out_string
expr_stmt|;
name|buffer
operator|->
name|out_string
operator|=
name|tmp_string
expr_stmt|;
name|buffer
operator|->
name|alt_string
operator|=
name|buffer
operator|->
name|out_string
expr_stmt|;
block|}
name|tmp_length
operator|=
name|buffer
operator|->
name|in_length
expr_stmt|;
name|buffer
operator|->
name|in_length
operator|=
name|buffer
operator|->
name|out_length
expr_stmt|;
name|buffer
operator|->
name|out_length
operator|=
name|tmp_length
expr_stmt|;
name|tmp_pos
operator|=
name|buffer
operator|->
name|in_pos
expr_stmt|;
name|buffer
operator|->
name|in_pos
operator|=
name|buffer
operator|->
name|out_pos
expr_stmt|;
name|buffer
operator|->
name|out_pos
operator|=
name|tmp_pos
expr_stmt|;
block|}
end_function
begin_comment
comment|/* The following function copies `num_out' elements from `glyph_data'    to `buffer->out_string', advancing the in array pointer in the structure    by `num_in' elements, and the out array pointer by `num_out' elements.    Finally, it sets the `length' field of `out' equal to    `pos' of the `out' structure.     If `component' is 0xFFFF, the component value from buffer->in_pos    will copied `num_out' times, otherwise `component' itself will    be used to fill the `component' fields.     If `ligID' is 0xFFFF, the ligID value from buffer->in_pos    will copied `num_out' times, otherwise `ligID' itself will    be used to fill the `ligID' fields.     The properties for all replacement glyphs are taken    from the glyph at position `buffer->in_pos'.     The cluster value for the glyph at position buffer->in_pos is used    for all replacement glyphs */
end_comment
begin_function
name|HB_INTERNAL
name|HB_Error
DECL|function|_hb_buffer_add_output_glyphs
name|_hb_buffer_add_output_glyphs
parameter_list|(
name|HB_Buffer
name|buffer
parameter_list|,
name|HB_UShort
name|num_in
parameter_list|,
name|HB_UShort
name|num_out
parameter_list|,
name|HB_UShort
modifier|*
name|glyph_data
parameter_list|,
name|HB_UShort
name|component
parameter_list|,
name|HB_UShort
name|ligID
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_UShort
name|i
decl_stmt|;
name|HB_UInt
name|properties
decl_stmt|;
name|HB_UInt
name|cluster
decl_stmt|;
name|error
operator|=
name|hb_buffer_ensure
argument_list|(
name|buffer
argument_list|,
name|buffer
operator|->
name|out_pos
operator|+
name|num_out
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
operator|!
name|buffer
operator|->
name|separate_out
condition|)
block|{
name|error
operator|=
name|hb_buffer_duplicate_out_buffer
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
block|}
name|properties
operator|=
name|buffer
operator|->
name|in_string
index|[
name|buffer
operator|->
name|in_pos
index|]
operator|.
name|properties
expr_stmt|;
name|cluster
operator|=
name|buffer
operator|->
name|in_string
index|[
name|buffer
operator|->
name|in_pos
index|]
operator|.
name|cluster
expr_stmt|;
if|if
condition|(
name|component
operator|==
literal|0xFFFF
condition|)
name|component
operator|=
name|buffer
operator|->
name|in_string
index|[
name|buffer
operator|->
name|in_pos
index|]
operator|.
name|component
expr_stmt|;
if|if
condition|(
name|ligID
operator|==
literal|0xFFFF
condition|)
name|ligID
operator|=
name|buffer
operator|->
name|in_string
index|[
name|buffer
operator|->
name|in_pos
index|]
operator|.
name|ligID
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_out
condition|;
name|i
operator|++
control|)
block|{
name|HB_GlyphItem
name|item
init|=
operator|&
name|buffer
operator|->
name|out_string
index|[
name|buffer
operator|->
name|out_pos
operator|+
name|i
index|]
decl_stmt|;
name|item
operator|->
name|gindex
operator|=
name|glyph_data
index|[
name|i
index|]
expr_stmt|;
name|item
operator|->
name|properties
operator|=
name|properties
expr_stmt|;
name|item
operator|->
name|cluster
operator|=
name|cluster
expr_stmt|;
name|item
operator|->
name|component
operator|=
name|component
expr_stmt|;
name|item
operator|->
name|ligID
operator|=
name|ligID
expr_stmt|;
name|item
operator|->
name|gproperties
operator|=
name|HB_GLYPH_PROPERTIES_UNKNOWN
expr_stmt|;
block|}
name|buffer
operator|->
name|in_pos
operator|+=
name|num_in
expr_stmt|;
name|buffer
operator|->
name|out_pos
operator|+=
name|num_out
expr_stmt|;
name|buffer
operator|->
name|out_length
operator|=
name|buffer
operator|->
name|out_pos
expr_stmt|;
return|return
name|HB_Err_Ok
return|;
block|}
end_function
begin_function
name|HB_INTERNAL
name|HB_Error
DECL|function|_hb_buffer_add_output_glyph
name|_hb_buffer_add_output_glyph
parameter_list|(
name|HB_Buffer
name|buffer
parameter_list|,
name|HB_UInt
name|glyph_index
parameter_list|,
name|HB_UShort
name|component
parameter_list|,
name|HB_UShort
name|ligID
parameter_list|)
block|{
name|HB_UShort
name|glyph_data
init|=
name|glyph_index
decl_stmt|;
return|return
name|_hb_buffer_add_output_glyphs
argument_list|(
name|buffer
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
operator|&
name|glyph_data
argument_list|,
name|component
argument_list|,
name|ligID
argument_list|)
return|;
block|}
end_function
begin_function
name|HB_INTERNAL
name|HB_Error
DECL|function|_hb_buffer_copy_output_glyph
name|_hb_buffer_copy_output_glyph
parameter_list|(
name|HB_Buffer
name|buffer
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|error
operator|=
name|hb_buffer_ensure
argument_list|(
name|buffer
argument_list|,
name|buffer
operator|->
name|out_pos
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
name|buffer
operator|->
name|separate_out
condition|)
block|{
name|buffer
operator|->
name|out_string
index|[
name|buffer
operator|->
name|out_pos
index|]
operator|=
name|buffer
operator|->
name|in_string
index|[
name|buffer
operator|->
name|in_pos
index|]
expr_stmt|;
block|}
name|buffer
operator|->
name|in_pos
operator|++
expr_stmt|;
name|buffer
operator|->
name|out_pos
operator|++
expr_stmt|;
name|buffer
operator|->
name|out_length
operator|=
name|buffer
operator|->
name|out_pos
expr_stmt|;
return|return
name|HB_Err_Ok
return|;
block|}
end_function
begin_function
name|HB_INTERNAL
name|HB_Error
DECL|function|_hb_buffer_replace_output_glyph
name|_hb_buffer_replace_output_glyph
parameter_list|(
name|HB_Buffer
name|buffer
parameter_list|,
name|HB_UInt
name|glyph_index
parameter_list|,
name|HB_Bool
name|inplace
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
if|if
condition|(
name|inplace
condition|)
block|{
name|error
operator|=
name|_hb_buffer_copy_output_glyph
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|buffer
operator|->
name|out_string
index|[
name|buffer
operator|->
name|out_pos
operator|-
literal|1
index|]
operator|.
name|gindex
operator|=
name|glyph_index
expr_stmt|;
block|}
else|else
block|{
return|return
name|_hb_buffer_add_output_glyph
argument_list|(
name|buffer
argument_list|,
name|glyph_index
argument_list|,
literal|0xFFFF
argument_list|,
literal|0xFFFF
argument_list|)
return|;
block|}
return|return
name|HB_Err_Ok
return|;
block|}
end_function
begin_function
name|HB_INTERNAL
name|HB_UShort
DECL|function|_hb_buffer_allocate_ligid
name|_hb_buffer_allocate_ligid
parameter_list|(
name|HB_Buffer
name|buffer
parameter_list|)
block|{
name|buffer
operator|->
name|max_ligID
operator|++
expr_stmt|;
if|if
condition|(
name|HB_UNLIKELY
argument_list|(
name|buffer
operator|->
name|max_ligID
operator|==
literal|0
argument_list|)
condition|)
name|buffer
operator|->
name|max_ligID
operator|++
expr_stmt|;
return|return
name|buffer
operator|->
name|max_ligID
return|;
block|}
end_function
end_unit
