begin_unit
begin_comment
comment|/*  * Copyright (C) 1998-2004  David Turner and Werner Lemberg  * Copyright (C) 2006  Behdad Esfahbod  * Copyright (C) 2007  Red Hat, Inc.  *  * This is part of HarfBuzz, an OpenType Layout engine library.  *  * Permission is hereby granted, without written agreement and without  * license or royalty fees, to use, copy, modify, and distribute this  * software and its documentation for any purpose, provided that the  * above copyright notice and the following two paragraphs appear in  * all copies of this software.  *  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH  * DAMAGE.  *  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS  * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.  *  * Red Hat Author(s): Behdad Esfahbod  */
end_comment
begin_include
include|#
directive|include
file|"harfbuzz-impl.h"
end_include
begin_include
include|#
directive|include
file|"harfbuzz-gsub-private.h"
end_include
begin_include
include|#
directive|include
file|"harfbuzz-open-private.h"
end_include
begin_include
include|#
directive|include
file|"harfbuzz-gdef-private.h"
end_include
begin_function_decl
specifier|static
name|HB_Error
name|GSUB_Do_Glyph_Lookup
parameter_list|(
name|HB_GSUBHeader
modifier|*
name|gsub
parameter_list|,
name|HB_UShort
name|lookup_index
parameter_list|,
name|HB_Buffer
name|buffer
parameter_list|,
name|HB_UShort
name|context_length
parameter_list|,
name|int
name|nesting_level
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/**********************  * Auxiliary functions  **********************/
end_comment
begin_function
DECL|function|HB_Load_GSUB_Table
name|HB_Error
name|HB_Load_GSUB_Table
parameter_list|(
name|HB_Stream
name|stream
parameter_list|,
name|HB_GSUBHeader
modifier|*
modifier|*
name|retptr
parameter_list|,
name|HB_GDEFHeader
modifier|*
name|gdef
parameter_list|,
name|HB_Stream
name|gdefStream
parameter_list|)
block|{
name|HB_Error
name|error
init|=
name|HB_Err_Ok
decl_stmt|;
name|HB_UInt
name|cur_offset
decl_stmt|,
name|new_offset
decl_stmt|,
name|base_offset
decl_stmt|;
name|HB_GSUBHeader
modifier|*
name|gsub
decl_stmt|;
if|if
condition|(
operator|!
name|retptr
condition|)
return|return
name|ERR
argument_list|(
name|HB_Err_Invalid_Argument
argument_list|)
return|;
if|if
condition|(
name|GOTO_Table
argument_list|(
name|TTAG_GSUB
argument_list|)
condition|)
return|return
name|error
return|;
name|base_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|ALLOC
argument_list|(
name|gsub
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|gsub
argument_list|)
argument_list|)
condition|)
return|return
name|error
return|;
comment|/* skip version */
if|if
condition|(
name|FILE_Seek
argument_list|(
name|base_offset
operator|+
literal|4L
argument_list|)
operator|||
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail4
goto|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
operator|+
name|base_offset
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|_HB_OPEN_Load_ScriptList
argument_list|(
operator|&
name|gsub
operator|->
name|ScriptList
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
goto|goto
name|Fail4
goto|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail3
goto|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
operator|+
name|base_offset
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|_HB_OPEN_Load_FeatureList
argument_list|(
operator|&
name|gsub
operator|->
name|FeatureList
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
goto|goto
name|Fail3
goto|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail2
goto|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
operator|+
name|base_offset
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|_HB_OPEN_Load_LookupList
argument_list|(
operator|&
name|gsub
operator|->
name|LookupList
argument_list|,
name|stream
argument_list|,
name|HB_Type_GSUB
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
goto|goto
name|Fail2
goto|;
name|gsub
operator|->
name|gdef
operator|=
name|gdef
expr_stmt|;
comment|/* can be NULL */
if|if
condition|(
operator|(
name|error
operator|=
name|_HB_GDEF_LoadMarkAttachClassDef_From_LookupFlags
argument_list|(
name|gdef
argument_list|,
name|gdefStream
argument_list|,
name|gsub
operator|->
name|LookupList
operator|.
name|Lookup
argument_list|,
name|gsub
operator|->
name|LookupList
operator|.
name|LookupCount
argument_list|)
operator|)
condition|)
goto|goto
name|Fail1
goto|;
operator|*
name|retptr
operator|=
name|gsub
expr_stmt|;
return|return
name|HB_Err_Ok
return|;
name|Fail1
label|:
name|_HB_OPEN_Free_LookupList
argument_list|(
operator|&
name|gsub
operator|->
name|LookupList
argument_list|,
name|HB_Type_GSUB
argument_list|)
expr_stmt|;
name|Fail2
label|:
name|_HB_OPEN_Free_FeatureList
argument_list|(
operator|&
name|gsub
operator|->
name|FeatureList
argument_list|)
expr_stmt|;
name|Fail3
label|:
name|_HB_OPEN_Free_ScriptList
argument_list|(
operator|&
name|gsub
operator|->
name|ScriptList
argument_list|)
expr_stmt|;
name|Fail4
label|:
name|FREE
argument_list|(
name|gsub
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_function
DECL|function|HB_Done_GSUB_Table
name|HB_Error
name|HB_Done_GSUB_Table
parameter_list|(
name|HB_GSUBHeader
modifier|*
name|gsub
parameter_list|)
block|{
name|_HB_OPEN_Free_LookupList
argument_list|(
operator|&
name|gsub
operator|->
name|LookupList
argument_list|,
name|HB_Type_GSUB
argument_list|)
expr_stmt|;
name|_HB_OPEN_Free_FeatureList
argument_list|(
operator|&
name|gsub
operator|->
name|FeatureList
argument_list|)
expr_stmt|;
name|_HB_OPEN_Free_ScriptList
argument_list|(
operator|&
name|gsub
operator|->
name|ScriptList
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|gsub
argument_list|)
expr_stmt|;
return|return
name|HB_Err_Ok
return|;
block|}
end_function
begin_comment
comment|/*****************************  * SubTable related functions  *****************************/
end_comment
begin_comment
comment|/* LookupType 1 */
end_comment
begin_comment
comment|/* SingleSubstFormat1 */
end_comment
begin_comment
comment|/* SingleSubstFormat2 */
end_comment
begin_function
DECL|function|Load_SingleSubst
specifier|static
name|HB_Error
name|Load_SingleSubst
parameter_list|(
name|HB_GSUB_SubTable
modifier|*
name|st
parameter_list|,
name|HB_Stream
name|stream
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_SingleSubst
modifier|*
name|ss
init|=
operator|&
name|st
operator|->
name|single
decl_stmt|;
name|HB_UShort
name|n
decl_stmt|,
name|count
decl_stmt|;
name|HB_UInt
name|cur_offset
decl_stmt|,
name|new_offset
decl_stmt|,
name|base_offset
decl_stmt|;
name|HB_UShort
modifier|*
name|s
decl_stmt|;
name|base_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|4L
argument_list|)
condition|)
return|return
name|error
return|;
name|ss
operator|->
name|SubstFormat
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
operator|+
name|base_offset
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|_HB_OPEN_Load_Coverage
argument_list|(
operator|&
name|ss
operator|->
name|Coverage
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
return|return
name|error
return|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ss
operator|->
name|SubstFormat
condition|)
block|{
case|case
literal|1
case|:
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail2
goto|;
name|ss
operator|->
name|ssf
operator|.
name|ssf1
operator|.
name|DeltaGlyphID
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
break|break;
case|case
literal|2
case|:
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail2
goto|;
name|count
operator|=
name|ss
operator|->
name|ssf
operator|.
name|ssf2
operator|.
name|GlyphCount
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|ss
operator|->
name|ssf
operator|.
name|ssf2
operator|.
name|Substitute
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|ss
operator|->
name|ssf
operator|.
name|ssf2
operator|.
name|Substitute
argument_list|,
name|count
argument_list|,
name|HB_UShort
argument_list|)
condition|)
goto|goto
name|Fail2
goto|;
name|s
operator|=
name|ss
operator|->
name|ssf
operator|.
name|ssf2
operator|.
name|Substitute
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
name|count
operator|*
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail1
goto|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
name|s
index|[
name|n
index|]
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
break|break;
default|default:
return|return
name|ERR
argument_list|(
name|HB_Err_Invalid_SubTable_Format
argument_list|)
return|;
block|}
return|return
name|HB_Err_Ok
return|;
name|Fail1
label|:
name|FREE
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|Fail2
label|:
name|_HB_OPEN_Free_Coverage
argument_list|(
operator|&
name|ss
operator|->
name|Coverage
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_function
DECL|function|Free_SingleSubst
specifier|static
name|void
name|Free_SingleSubst
parameter_list|(
name|HB_GSUB_SubTable
modifier|*
name|st
parameter_list|)
block|{
name|HB_SingleSubst
modifier|*
name|ss
init|=
operator|&
name|st
operator|->
name|single
decl_stmt|;
switch|switch
condition|(
name|ss
operator|->
name|SubstFormat
condition|)
block|{
case|case
literal|1
case|:
break|break;
case|case
literal|2
case|:
name|FREE
argument_list|(
name|ss
operator|->
name|ssf
operator|.
name|ssf2
operator|.
name|Substitute
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|_HB_OPEN_Free_Coverage
argument_list|(
operator|&
name|ss
operator|->
name|Coverage
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|Lookup_SingleSubst
specifier|static
name|HB_Error
name|Lookup_SingleSubst
parameter_list|(
name|HB_GSUBHeader
modifier|*
name|gsub
parameter_list|,
name|HB_GSUB_SubTable
modifier|*
name|st
parameter_list|,
name|HB_Buffer
name|buffer
parameter_list|,
name|HB_UShort
name|flags
parameter_list|,
name|HB_UShort
name|context_length
parameter_list|,
name|int
name|nesting_level
parameter_list|)
block|{
name|HB_UShort
name|index
decl_stmt|,
name|value
decl_stmt|,
name|property
decl_stmt|;
name|HB_Error
name|error
decl_stmt|;
name|HB_SingleSubst
modifier|*
name|ss
init|=
operator|&
name|st
operator|->
name|single
decl_stmt|;
name|HB_GDEFHeader
modifier|*
name|gdef
init|=
name|gsub
operator|->
name|gdef
decl_stmt|;
name|HB_UNUSED
argument_list|(
name|nesting_level
argument_list|)
expr_stmt|;
if|if
condition|(
name|context_length
operator|!=
literal|0xFFFF
operator|&&
name|context_length
operator|<
literal|1
condition|)
return|return
name|HB_Err_Not_Covered
return|;
if|if
condition|(
name|CHECK_Property
argument_list|(
name|gdef
argument_list|,
name|IN_CURITEM
argument_list|()
argument_list|,
name|flags
argument_list|,
operator|&
name|property
argument_list|)
condition|)
return|return
name|error
return|;
name|error
operator|=
name|_HB_OPEN_Coverage_Index
argument_list|(
operator|&
name|ss
operator|->
name|Coverage
argument_list|,
name|IN_CURGLYPH
argument_list|()
argument_list|,
operator|&
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
switch|switch
condition|(
name|ss
operator|->
name|SubstFormat
condition|)
block|{
case|case
literal|1
case|:
name|value
operator|=
operator|(
name|IN_CURGLYPH
argument_list|()
operator|+
name|ss
operator|->
name|ssf
operator|.
name|ssf1
operator|.
name|DeltaGlyphID
operator|)
operator|&
literal|0xFFFF
expr_stmt|;
if|if
condition|(
name|REPLACE_Glyph
argument_list|(
name|buffer
argument_list|,
name|value
argument_list|,
name|nesting_level
argument_list|)
condition|)
return|return
name|error
return|;
break|break;
case|case
literal|2
case|:
if|if
condition|(
name|index
operator|>=
name|ss
operator|->
name|ssf
operator|.
name|ssf2
operator|.
name|GlyphCount
condition|)
return|return
name|ERR
argument_list|(
name|HB_Err_Invalid_SubTable
argument_list|)
return|;
name|value
operator|=
name|ss
operator|->
name|ssf
operator|.
name|ssf2
operator|.
name|Substitute
index|[
name|index
index|]
expr_stmt|;
if|if
condition|(
name|REPLACE_Glyph
argument_list|(
name|buffer
argument_list|,
name|value
argument_list|,
name|nesting_level
argument_list|)
condition|)
return|return
name|error
return|;
break|break;
default|default:
return|return
name|ERR
argument_list|(
name|HB_Err_Invalid_SubTable
argument_list|)
return|;
block|}
if|if
condition|(
name|gdef
operator|&&
name|gdef
operator|->
name|NewGlyphClasses
condition|)
block|{
comment|/* we inherit the old glyph class to the substituted glyph */
name|error
operator|=
name|_HB_GDEF_Add_Glyph_Property
argument_list|(
name|gdef
argument_list|,
name|value
argument_list|,
name|property
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|HB_Err_Not_Covered
condition|)
return|return
name|error
return|;
block|}
return|return
name|HB_Err_Ok
return|;
block|}
end_function
begin_comment
comment|/* LookupType 2 */
end_comment
begin_comment
comment|/* Sequence */
end_comment
begin_function
DECL|function|Load_Sequence
specifier|static
name|HB_Error
name|Load_Sequence
parameter_list|(
name|HB_Sequence
modifier|*
name|s
parameter_list|,
name|HB_Stream
name|stream
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_UShort
name|n
decl_stmt|,
name|count
decl_stmt|;
name|HB_UShort
modifier|*
name|sub
decl_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
return|return
name|error
return|;
name|count
operator|=
name|s
operator|->
name|GlyphCount
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|s
operator|->
name|Substitute
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|count
condition|)
block|{
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|s
operator|->
name|Substitute
argument_list|,
name|count
argument_list|,
name|HB_UShort
argument_list|)
condition|)
return|return
name|error
return|;
name|sub
operator|=
name|s
operator|->
name|Substitute
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
name|count
operator|*
literal|2L
argument_list|)
condition|)
block|{
name|FREE
argument_list|(
name|sub
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
name|sub
index|[
name|n
index|]
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
block|}
return|return
name|HB_Err_Ok
return|;
block|}
end_function
begin_function
DECL|function|Free_Sequence
specifier|static
name|void
name|Free_Sequence
parameter_list|(
name|HB_Sequence
modifier|*
name|s
parameter_list|)
block|{
name|FREE
argument_list|(
name|s
operator|->
name|Substitute
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* MultipleSubstFormat1 */
end_comment
begin_function
DECL|function|Load_MultipleSubst
specifier|static
name|HB_Error
name|Load_MultipleSubst
parameter_list|(
name|HB_GSUB_SubTable
modifier|*
name|st
parameter_list|,
name|HB_Stream
name|stream
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_MultipleSubst
modifier|*
name|ms
init|=
operator|&
name|st
operator|->
name|multiple
decl_stmt|;
name|HB_UShort
name|n
init|=
literal|0
decl_stmt|,
name|m
decl_stmt|,
name|count
decl_stmt|;
name|HB_UInt
name|cur_offset
decl_stmt|,
name|new_offset
decl_stmt|,
name|base_offset
decl_stmt|;
name|HB_Sequence
modifier|*
name|s
decl_stmt|;
name|base_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|4L
argument_list|)
condition|)
return|return
name|error
return|;
name|ms
operator|->
name|SubstFormat
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
comment|/* should be 1 */
name|new_offset
operator|=
name|GET_UShort
argument_list|()
operator|+
name|base_offset
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|_HB_OPEN_Load_Coverage
argument_list|(
operator|&
name|ms
operator|->
name|Coverage
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
return|return
name|error
return|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail2
goto|;
name|count
operator|=
name|ms
operator|->
name|SequenceCount
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|ms
operator|->
name|Sequence
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|ms
operator|->
name|Sequence
argument_list|,
name|count
argument_list|,
name|HB_Sequence
argument_list|)
condition|)
goto|goto
name|Fail2
goto|;
name|s
operator|=
name|ms
operator|->
name|Sequence
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail1
goto|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
operator|+
name|base_offset
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|Load_Sequence
argument_list|(
operator|&
name|s
index|[
name|n
index|]
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
goto|goto
name|Fail1
goto|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
block|}
return|return
name|HB_Err_Ok
return|;
name|Fail1
label|:
for|for
control|(
name|m
operator|=
literal|0
init|;
name|m
operator|<
name|n
condition|;
name|m
operator|++
control|)
name|Free_Sequence
argument_list|(
operator|&
name|s
index|[
name|m
index|]
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|Fail2
label|:
name|_HB_OPEN_Free_Coverage
argument_list|(
operator|&
name|ms
operator|->
name|Coverage
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_function
DECL|function|Free_MultipleSubst
specifier|static
name|void
name|Free_MultipleSubst
parameter_list|(
name|HB_GSUB_SubTable
modifier|*
name|st
parameter_list|)
block|{
name|HB_UShort
name|n
decl_stmt|,
name|count
decl_stmt|;
name|HB_MultipleSubst
modifier|*
name|ms
init|=
operator|&
name|st
operator|->
name|multiple
decl_stmt|;
name|HB_Sequence
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|ms
operator|->
name|Sequence
condition|)
block|{
name|count
operator|=
name|ms
operator|->
name|SequenceCount
expr_stmt|;
name|s
operator|=
name|ms
operator|->
name|Sequence
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
name|Free_Sequence
argument_list|(
operator|&
name|s
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|_HB_OPEN_Free_Coverage
argument_list|(
operator|&
name|ms
operator|->
name|Coverage
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|Lookup_MultipleSubst
specifier|static
name|HB_Error
name|Lookup_MultipleSubst
parameter_list|(
name|HB_GSUBHeader
modifier|*
name|gsub
parameter_list|,
name|HB_GSUB_SubTable
modifier|*
name|st
parameter_list|,
name|HB_Buffer
name|buffer
parameter_list|,
name|HB_UShort
name|flags
parameter_list|,
name|HB_UShort
name|context_length
parameter_list|,
name|int
name|nesting_level
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_UShort
name|index
decl_stmt|,
name|property
decl_stmt|,
name|n
decl_stmt|,
name|count
decl_stmt|;
name|HB_UShort
modifier|*
name|s
decl_stmt|;
name|HB_MultipleSubst
modifier|*
name|ms
init|=
operator|&
name|st
operator|->
name|multiple
decl_stmt|;
name|HB_GDEFHeader
modifier|*
name|gdef
init|=
name|gsub
operator|->
name|gdef
decl_stmt|;
name|HB_UNUSED
argument_list|(
name|nesting_level
argument_list|)
expr_stmt|;
if|if
condition|(
name|context_length
operator|!=
literal|0xFFFF
operator|&&
name|context_length
operator|<
literal|1
condition|)
return|return
name|HB_Err_Not_Covered
return|;
if|if
condition|(
name|CHECK_Property
argument_list|(
name|gdef
argument_list|,
name|IN_CURITEM
argument_list|()
argument_list|,
name|flags
argument_list|,
operator|&
name|property
argument_list|)
condition|)
return|return
name|error
return|;
name|error
operator|=
name|_HB_OPEN_Coverage_Index
argument_list|(
operator|&
name|ms
operator|->
name|Coverage
argument_list|,
name|IN_CURGLYPH
argument_list|()
argument_list|,
operator|&
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
name|index
operator|>=
name|ms
operator|->
name|SequenceCount
condition|)
return|return
name|ERR
argument_list|(
name|HB_Err_Invalid_SubTable
argument_list|)
return|;
name|count
operator|=
name|ms
operator|->
name|Sequence
index|[
name|index
index|]
operator|.
name|GlyphCount
expr_stmt|;
name|s
operator|=
name|ms
operator|->
name|Sequence
index|[
name|index
index|]
operator|.
name|Substitute
expr_stmt|;
if|if
condition|(
name|ADD_String
argument_list|(
name|buffer
argument_list|,
literal|1
argument_list|,
name|count
argument_list|,
name|s
argument_list|,
literal|0xFFFF
argument_list|,
literal|0xFFFF
argument_list|)
condition|)
return|return
name|error
return|;
if|if
condition|(
name|gdef
operator|&&
name|gdef
operator|->
name|NewGlyphClasses
condition|)
block|{
comment|/* this is a guess only ... */
if|if
condition|(
name|property
operator|==
name|HB_GDEF_LIGATURE
condition|)
name|property
operator|=
name|HB_GDEF_BASE_GLYPH
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
block|{
name|error
operator|=
name|_HB_GDEF_Add_Glyph_Property
argument_list|(
name|gdef
argument_list|,
name|s
index|[
name|n
index|]
argument_list|,
name|property
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|HB_Err_Not_Covered
condition|)
return|return
name|error
return|;
block|}
block|}
return|return
name|HB_Err_Ok
return|;
block|}
end_function
begin_comment
comment|/* LookupType 3 */
end_comment
begin_comment
comment|/* AlternateSet */
end_comment
begin_function
DECL|function|Load_AlternateSet
specifier|static
name|HB_Error
name|Load_AlternateSet
parameter_list|(
name|HB_AlternateSet
modifier|*
name|as
parameter_list|,
name|HB_Stream
name|stream
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_UShort
name|n
decl_stmt|,
name|count
decl_stmt|;
name|HB_UShort
modifier|*
name|a
decl_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
return|return
name|error
return|;
name|count
operator|=
name|as
operator|->
name|GlyphCount
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|as
operator|->
name|Alternate
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|as
operator|->
name|Alternate
argument_list|,
name|count
argument_list|,
name|HB_UShort
argument_list|)
condition|)
return|return
name|error
return|;
name|a
operator|=
name|as
operator|->
name|Alternate
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
name|count
operator|*
literal|2L
argument_list|)
condition|)
block|{
name|FREE
argument_list|(
name|a
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
name|a
index|[
name|n
index|]
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
return|return
name|HB_Err_Ok
return|;
block|}
end_function
begin_function
DECL|function|Free_AlternateSet
specifier|static
name|void
name|Free_AlternateSet
parameter_list|(
name|HB_AlternateSet
modifier|*
name|as
parameter_list|)
block|{
name|FREE
argument_list|(
name|as
operator|->
name|Alternate
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* AlternateSubstFormat1 */
end_comment
begin_function
DECL|function|Load_AlternateSubst
specifier|static
name|HB_Error
name|Load_AlternateSubst
parameter_list|(
name|HB_GSUB_SubTable
modifier|*
name|st
parameter_list|,
name|HB_Stream
name|stream
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_AlternateSubst
modifier|*
name|as
init|=
operator|&
name|st
operator|->
name|alternate
decl_stmt|;
name|HB_UShort
name|n
init|=
literal|0
decl_stmt|,
name|m
decl_stmt|,
name|count
decl_stmt|;
name|HB_UInt
name|cur_offset
decl_stmt|,
name|new_offset
decl_stmt|,
name|base_offset
decl_stmt|;
name|HB_AlternateSet
modifier|*
name|aset
decl_stmt|;
name|base_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|4L
argument_list|)
condition|)
return|return
name|error
return|;
name|as
operator|->
name|SubstFormat
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
comment|/* should be 1 */
name|new_offset
operator|=
name|GET_UShort
argument_list|()
operator|+
name|base_offset
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|_HB_OPEN_Load_Coverage
argument_list|(
operator|&
name|as
operator|->
name|Coverage
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
return|return
name|error
return|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail2
goto|;
name|count
operator|=
name|as
operator|->
name|AlternateSetCount
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|as
operator|->
name|AlternateSet
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|as
operator|->
name|AlternateSet
argument_list|,
name|count
argument_list|,
name|HB_AlternateSet
argument_list|)
condition|)
goto|goto
name|Fail2
goto|;
name|aset
operator|=
name|as
operator|->
name|AlternateSet
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail1
goto|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
operator|+
name|base_offset
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|Load_AlternateSet
argument_list|(
operator|&
name|aset
index|[
name|n
index|]
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
goto|goto
name|Fail1
goto|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
block|}
return|return
name|HB_Err_Ok
return|;
name|Fail1
label|:
for|for
control|(
name|m
operator|=
literal|0
init|;
name|m
operator|<
name|n
condition|;
name|m
operator|++
control|)
name|Free_AlternateSet
argument_list|(
operator|&
name|aset
index|[
name|m
index|]
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|aset
argument_list|)
expr_stmt|;
name|Fail2
label|:
name|_HB_OPEN_Free_Coverage
argument_list|(
operator|&
name|as
operator|->
name|Coverage
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_function
DECL|function|Free_AlternateSubst
specifier|static
name|void
name|Free_AlternateSubst
parameter_list|(
name|HB_GSUB_SubTable
modifier|*
name|st
parameter_list|)
block|{
name|HB_UShort
name|n
decl_stmt|,
name|count
decl_stmt|;
name|HB_AlternateSubst
modifier|*
name|as
init|=
operator|&
name|st
operator|->
name|alternate
decl_stmt|;
name|HB_AlternateSet
modifier|*
name|aset
decl_stmt|;
if|if
condition|(
name|as
operator|->
name|AlternateSet
condition|)
block|{
name|count
operator|=
name|as
operator|->
name|AlternateSetCount
expr_stmt|;
name|aset
operator|=
name|as
operator|->
name|AlternateSet
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
name|Free_AlternateSet
argument_list|(
operator|&
name|aset
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|aset
argument_list|)
expr_stmt|;
block|}
name|_HB_OPEN_Free_Coverage
argument_list|(
operator|&
name|as
operator|->
name|Coverage
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|Lookup_AlternateSubst
specifier|static
name|HB_Error
name|Lookup_AlternateSubst
parameter_list|(
name|HB_GSUBHeader
modifier|*
name|gsub
parameter_list|,
name|HB_GSUB_SubTable
modifier|*
name|st
parameter_list|,
name|HB_Buffer
name|buffer
parameter_list|,
name|HB_UShort
name|flags
parameter_list|,
name|HB_UShort
name|context_length
parameter_list|,
name|int
name|nesting_level
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_UShort
name|index
decl_stmt|,
name|value
decl_stmt|,
name|alt_index
decl_stmt|,
name|property
decl_stmt|;
name|HB_AlternateSubst
modifier|*
name|as
init|=
operator|&
name|st
operator|->
name|alternate
decl_stmt|;
name|HB_GDEFHeader
modifier|*
name|gdef
init|=
name|gsub
operator|->
name|gdef
decl_stmt|;
name|HB_AlternateSet
name|aset
decl_stmt|;
name|HB_UNUSED
argument_list|(
name|nesting_level
argument_list|)
expr_stmt|;
if|if
condition|(
name|context_length
operator|!=
literal|0xFFFF
operator|&&
name|context_length
operator|<
literal|1
condition|)
return|return
name|HB_Err_Not_Covered
return|;
if|if
condition|(
name|CHECK_Property
argument_list|(
name|gdef
argument_list|,
name|IN_CURITEM
argument_list|()
argument_list|,
name|flags
argument_list|,
operator|&
name|property
argument_list|)
condition|)
return|return
name|error
return|;
name|error
operator|=
name|_HB_OPEN_Coverage_Index
argument_list|(
operator|&
name|as
operator|->
name|Coverage
argument_list|,
name|IN_CURGLYPH
argument_list|()
argument_list|,
operator|&
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|aset
operator|=
name|as
operator|->
name|AlternateSet
index|[
name|index
index|]
expr_stmt|;
comment|/* we use a user-defined callback function to get the alternate index */
if|if
condition|(
name|gsub
operator|->
name|altfunc
condition|)
name|alt_index
operator|=
call|(
name|gsub
operator|->
name|altfunc
call|)
argument_list|(
name|buffer
operator|->
name|out_pos
argument_list|,
name|IN_CURGLYPH
argument_list|()
argument_list|,
name|aset
operator|.
name|GlyphCount
argument_list|,
name|aset
operator|.
name|Alternate
argument_list|,
name|gsub
operator|->
name|data
argument_list|)
expr_stmt|;
else|else
name|alt_index
operator|=
literal|0
expr_stmt|;
name|value
operator|=
name|aset
operator|.
name|Alternate
index|[
name|alt_index
index|]
expr_stmt|;
if|if
condition|(
name|REPLACE_Glyph
argument_list|(
name|buffer
argument_list|,
name|value
argument_list|,
name|nesting_level
argument_list|)
condition|)
return|return
name|error
return|;
if|if
condition|(
name|gdef
operator|&&
name|gdef
operator|->
name|NewGlyphClasses
condition|)
block|{
comment|/* we inherit the old glyph class to the substituted glyph */
name|error
operator|=
name|_HB_GDEF_Add_Glyph_Property
argument_list|(
name|gdef
argument_list|,
name|value
argument_list|,
name|property
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|HB_Err_Not_Covered
condition|)
return|return
name|error
return|;
block|}
return|return
name|HB_Err_Ok
return|;
block|}
end_function
begin_comment
comment|/* LookupType 4 */
end_comment
begin_comment
comment|/* Ligature */
end_comment
begin_function
DECL|function|Load_Ligature
specifier|static
name|HB_Error
name|Load_Ligature
parameter_list|(
name|HB_Ligature
modifier|*
name|l
parameter_list|,
name|HB_Stream
name|stream
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_UShort
name|n
decl_stmt|,
name|count
decl_stmt|;
name|HB_UShort
modifier|*
name|c
decl_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|4L
argument_list|)
condition|)
return|return
name|error
return|;
name|l
operator|->
name|LigGlyph
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|l
operator|->
name|ComponentCount
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|l
operator|->
name|Component
operator|=
name|NULL
expr_stmt|;
name|count
operator|=
name|l
operator|->
name|ComponentCount
operator|-
literal|1
expr_stmt|;
comment|/* only ComponentCount - 1 elements */
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|l
operator|->
name|Component
argument_list|,
name|count
argument_list|,
name|HB_UShort
argument_list|)
condition|)
return|return
name|error
return|;
name|c
operator|=
name|l
operator|->
name|Component
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
name|count
operator|*
literal|2L
argument_list|)
condition|)
block|{
name|FREE
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
name|c
index|[
name|n
index|]
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
return|return
name|HB_Err_Ok
return|;
block|}
end_function
begin_function
DECL|function|Free_Ligature
specifier|static
name|void
name|Free_Ligature
parameter_list|(
name|HB_Ligature
modifier|*
name|l
parameter_list|)
block|{
name|FREE
argument_list|(
name|l
operator|->
name|Component
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* LigatureSet */
end_comment
begin_function
DECL|function|Load_LigatureSet
specifier|static
name|HB_Error
name|Load_LigatureSet
parameter_list|(
name|HB_LigatureSet
modifier|*
name|ls
parameter_list|,
name|HB_Stream
name|stream
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_UShort
name|n
init|=
literal|0
decl_stmt|,
name|m
decl_stmt|,
name|count
decl_stmt|;
name|HB_UInt
name|cur_offset
decl_stmt|,
name|new_offset
decl_stmt|,
name|base_offset
decl_stmt|;
name|HB_Ligature
modifier|*
name|l
decl_stmt|;
name|base_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
return|return
name|error
return|;
name|count
operator|=
name|ls
operator|->
name|LigatureCount
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|ls
operator|->
name|Ligature
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|ls
operator|->
name|Ligature
argument_list|,
name|count
argument_list|,
name|HB_Ligature
argument_list|)
condition|)
return|return
name|error
return|;
name|l
operator|=
name|ls
operator|->
name|Ligature
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
operator|+
name|base_offset
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|Load_Ligature
argument_list|(
operator|&
name|l
index|[
name|n
index|]
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
goto|goto
name|Fail
goto|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
block|}
return|return
name|HB_Err_Ok
return|;
name|Fail
label|:
for|for
control|(
name|m
operator|=
literal|0
init|;
name|m
operator|<
name|n
condition|;
name|m
operator|++
control|)
name|Free_Ligature
argument_list|(
operator|&
name|l
index|[
name|m
index|]
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|l
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_function
DECL|function|Free_LigatureSet
specifier|static
name|void
name|Free_LigatureSet
parameter_list|(
name|HB_LigatureSet
modifier|*
name|ls
parameter_list|)
block|{
name|HB_UShort
name|n
decl_stmt|,
name|count
decl_stmt|;
name|HB_Ligature
modifier|*
name|l
decl_stmt|;
if|if
condition|(
name|ls
operator|->
name|Ligature
condition|)
block|{
name|count
operator|=
name|ls
operator|->
name|LigatureCount
expr_stmt|;
name|l
operator|=
name|ls
operator|->
name|Ligature
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
name|Free_Ligature
argument_list|(
operator|&
name|l
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/* LigatureSubstFormat1 */
end_comment
begin_function
DECL|function|Load_LigatureSubst
specifier|static
name|HB_Error
name|Load_LigatureSubst
parameter_list|(
name|HB_GSUB_SubTable
modifier|*
name|st
parameter_list|,
name|HB_Stream
name|stream
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_LigatureSubst
modifier|*
name|ls
init|=
operator|&
name|st
operator|->
name|ligature
decl_stmt|;
name|HB_UShort
name|n
init|=
literal|0
decl_stmt|,
name|m
decl_stmt|,
name|count
decl_stmt|;
name|HB_UInt
name|cur_offset
decl_stmt|,
name|new_offset
decl_stmt|,
name|base_offset
decl_stmt|;
name|HB_LigatureSet
modifier|*
name|lset
decl_stmt|;
name|base_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|4L
argument_list|)
condition|)
return|return
name|error
return|;
name|ls
operator|->
name|SubstFormat
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
comment|/* should be 1 */
name|new_offset
operator|=
name|GET_UShort
argument_list|()
operator|+
name|base_offset
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|_HB_OPEN_Load_Coverage
argument_list|(
operator|&
name|ls
operator|->
name|Coverage
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
return|return
name|error
return|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail2
goto|;
name|count
operator|=
name|ls
operator|->
name|LigatureSetCount
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|ls
operator|->
name|LigatureSet
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|ls
operator|->
name|LigatureSet
argument_list|,
name|count
argument_list|,
name|HB_LigatureSet
argument_list|)
condition|)
goto|goto
name|Fail2
goto|;
name|lset
operator|=
name|ls
operator|->
name|LigatureSet
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail1
goto|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
operator|+
name|base_offset
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|Load_LigatureSet
argument_list|(
operator|&
name|lset
index|[
name|n
index|]
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
goto|goto
name|Fail1
goto|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
block|}
return|return
name|HB_Err_Ok
return|;
name|Fail1
label|:
for|for
control|(
name|m
operator|=
literal|0
init|;
name|m
operator|<
name|n
condition|;
name|m
operator|++
control|)
name|Free_LigatureSet
argument_list|(
operator|&
name|lset
index|[
name|m
index|]
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|lset
argument_list|)
expr_stmt|;
name|Fail2
label|:
name|_HB_OPEN_Free_Coverage
argument_list|(
operator|&
name|ls
operator|->
name|Coverage
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_function
DECL|function|Free_LigatureSubst
specifier|static
name|void
name|Free_LigatureSubst
parameter_list|(
name|HB_GSUB_SubTable
modifier|*
name|st
parameter_list|)
block|{
name|HB_UShort
name|n
decl_stmt|,
name|count
decl_stmt|;
name|HB_LigatureSubst
modifier|*
name|ls
init|=
operator|&
name|st
operator|->
name|ligature
decl_stmt|;
name|HB_LigatureSet
modifier|*
name|lset
decl_stmt|;
if|if
condition|(
name|ls
operator|->
name|LigatureSet
condition|)
block|{
name|count
operator|=
name|ls
operator|->
name|LigatureSetCount
expr_stmt|;
name|lset
operator|=
name|ls
operator|->
name|LigatureSet
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
name|Free_LigatureSet
argument_list|(
operator|&
name|lset
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|lset
argument_list|)
expr_stmt|;
block|}
name|_HB_OPEN_Free_Coverage
argument_list|(
operator|&
name|ls
operator|->
name|Coverage
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|Lookup_LigatureSubst
specifier|static
name|HB_Error
name|Lookup_LigatureSubst
parameter_list|(
name|HB_GSUBHeader
modifier|*
name|gsub
parameter_list|,
name|HB_GSUB_SubTable
modifier|*
name|st
parameter_list|,
name|HB_Buffer
name|buffer
parameter_list|,
name|HB_UShort
name|flags
parameter_list|,
name|HB_UShort
name|context_length
parameter_list|,
name|int
name|nesting_level
parameter_list|)
block|{
name|HB_UShort
name|index
decl_stmt|,
name|property
decl_stmt|;
name|HB_Error
name|error
decl_stmt|;
name|HB_UShort
name|numlig
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|is_mark
decl_stmt|,
name|first_is_mark
init|=
name|FALSE
decl_stmt|;
name|HB_UShort
modifier|*
name|c
decl_stmt|;
name|HB_LigatureSubst
modifier|*
name|ls
init|=
operator|&
name|st
operator|->
name|ligature
decl_stmt|;
name|HB_GDEFHeader
modifier|*
name|gdef
init|=
name|gsub
operator|->
name|gdef
decl_stmt|;
name|HB_Ligature
modifier|*
name|lig
decl_stmt|;
name|HB_UNUSED
argument_list|(
name|nesting_level
argument_list|)
expr_stmt|;
if|if
condition|(
name|CHECK_Property
argument_list|(
name|gdef
argument_list|,
name|IN_CURITEM
argument_list|()
argument_list|,
name|flags
argument_list|,
operator|&
name|property
argument_list|)
condition|)
return|return
name|error
return|;
if|if
condition|(
name|property
operator|==
name|HB_GDEF_MARK
operator|||
name|property
operator|&
name|HB_LOOKUP_FLAG_IGNORE_SPECIAL_MARKS
condition|)
name|first_is_mark
operator|=
name|TRUE
expr_stmt|;
name|error
operator|=
name|_HB_OPEN_Coverage_Index
argument_list|(
operator|&
name|ls
operator|->
name|Coverage
argument_list|,
name|IN_CURGLYPH
argument_list|()
argument_list|,
operator|&
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
name|index
operator|>=
name|ls
operator|->
name|LigatureSetCount
condition|)
return|return
name|ERR
argument_list|(
name|HB_Err_Invalid_SubTable
argument_list|)
return|;
name|lig
operator|=
name|ls
operator|->
name|LigatureSet
index|[
name|index
index|]
operator|.
name|Ligature
expr_stmt|;
for|for
control|(
name|numlig
operator|=
name|ls
operator|->
name|LigatureSet
index|[
name|index
index|]
operator|.
name|LigatureCount
init|;
name|numlig
condition|;
name|numlig
operator|--
operator|,
name|lig
operator|++
control|)
block|{
if|if
condition|(
name|buffer
operator|->
name|in_pos
operator|+
name|lig
operator|->
name|ComponentCount
operator|>
name|buffer
operator|->
name|in_length
condition|)
goto|goto
name|next_ligature
goto|;
comment|/* Not enough glyphs in input */
name|c
operator|=
name|lig
operator|->
name|Component
expr_stmt|;
name|is_mark
operator|=
name|first_is_mark
expr_stmt|;
if|if
condition|(
name|context_length
operator|!=
literal|0xFFFF
operator|&&
name|context_length
operator|<
name|lig
operator|->
name|ComponentCount
condition|)
break|break;
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|j
operator|=
name|buffer
operator|->
name|in_pos
operator|+
literal|1
init|;
name|i
operator|<
name|lig
operator|->
name|ComponentCount
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
while|while
condition|(
name|CHECK_Property
argument_list|(
name|gdef
argument_list|,
name|IN_ITEM
argument_list|(
name|j
argument_list|)
argument_list|,
name|flags
argument_list|,
operator|&
name|property
argument_list|)
condition|)
block|{
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|HB_Err_Not_Covered
condition|)
return|return
name|error
return|;
if|if
condition|(
name|j
operator|+
name|lig
operator|->
name|ComponentCount
operator|-
name|i
operator|==
operator|(
name|HB_Int
operator|)
name|buffer
operator|->
name|in_length
condition|)
goto|goto
name|next_ligature
goto|;
name|j
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|property
operator|==
name|HB_GDEF_MARK
operator|||
name|property
operator|&
name|HB_LOOKUP_FLAG_IGNORE_SPECIAL_MARKS
operator|)
condition|)
name|is_mark
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|IN_GLYPH
argument_list|(
name|j
argument_list|)
operator|!=
name|c
index|[
name|i
operator|-
literal|1
index|]
condition|)
goto|goto
name|next_ligature
goto|;
block|}
if|if
condition|(
name|gdef
operator|&&
name|gdef
operator|->
name|NewGlyphClasses
condition|)
block|{
comment|/* this is just a guess ... */
name|error
operator|=
name|_HB_GDEF_Add_Glyph_Property
argument_list|(
name|gdef
argument_list|,
name|lig
operator|->
name|LigGlyph
argument_list|,
name|is_mark
condition|?
name|HB_GDEF_MARK
else|:
name|HB_GDEF_LIGATURE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|HB_Err_Not_Covered
condition|)
return|return
name|error
return|;
block|}
if|if
condition|(
name|j
operator|==
name|buffer
operator|->
name|in_pos
operator|+
name|i
condition|)
comment|/* No input glyphs skipped */
block|{
comment|/* We don't use a new ligature ID if there are no skipped 	 glyphs and the ligature already has an ID.             */
if|if
condition|(
name|IN_LIGID
argument_list|(
name|buffer
operator|->
name|in_pos
argument_list|)
condition|)
block|{
if|if
condition|(
name|ADD_String
argument_list|(
name|buffer
argument_list|,
name|i
argument_list|,
literal|1
argument_list|,
operator|&
name|lig
operator|->
name|LigGlyph
argument_list|,
literal|0xFFFF
argument_list|,
literal|0xFFFF
argument_list|)
condition|)
return|return
name|error
return|;
block|}
else|else
block|{
name|HB_UShort
name|ligID
init|=
name|_hb_buffer_allocate_ligid
argument_list|(
name|buffer
argument_list|)
decl_stmt|;
if|if
condition|(
name|ADD_String
argument_list|(
name|buffer
argument_list|,
name|i
argument_list|,
literal|1
argument_list|,
operator|&
name|lig
operator|->
name|LigGlyph
argument_list|,
literal|0xFFFF
argument_list|,
name|ligID
argument_list|)
condition|)
return|return
name|error
return|;
block|}
block|}
else|else
block|{
name|HB_UShort
name|ligID
init|=
name|_hb_buffer_allocate_ligid
argument_list|(
name|buffer
argument_list|)
decl_stmt|;
if|if
condition|(
name|ADD_Glyph
argument_list|(
name|buffer
argument_list|,
name|lig
operator|->
name|LigGlyph
argument_list|,
literal|0xFFFF
argument_list|,
name|ligID
argument_list|)
condition|)
return|return
name|error
return|;
comment|/* Now we must do a second loop to copy the skipped glyphs to 	 `out' and assign component values to it.  We start with the 	 glyph after the first component.  Glyphs between component 	 i and i+1 belong to component i.  Together with the ligID 	 value it is later possible to check whether a specific 	 component value really belongs to a given ligature.         */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lig
operator|->
name|ComponentCount
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
while|while
condition|(
name|CHECK_Property
argument_list|(
name|gdef
argument_list|,
name|IN_CURITEM
argument_list|()
argument_list|,
name|flags
argument_list|,
operator|&
name|property
argument_list|)
condition|)
if|if
condition|(
name|ADD_Glyph
argument_list|(
name|buffer
argument_list|,
name|IN_CURGLYPH
argument_list|()
argument_list|,
name|i
argument_list|,
name|ligID
argument_list|)
condition|)
return|return
name|error
return|;
operator|(
name|buffer
operator|->
name|in_pos
operator|)
operator|++
expr_stmt|;
block|}
block|}
return|return
name|HB_Err_Ok
return|;
name|next_ligature
label|:
empty_stmt|;
block|}
return|return
name|HB_Err_Not_Covered
return|;
block|}
end_function
begin_comment
comment|/* Do the actual substitution for a context substitution (either format    5 or 6).  This is only called after we've determined that the input    matches the subrule.                                                 */
end_comment
begin_function
DECL|function|Do_ContextSubst
specifier|static
name|HB_Error
name|Do_ContextSubst
parameter_list|(
name|HB_GSUBHeader
modifier|*
name|gsub
parameter_list|,
name|HB_UShort
name|GlyphCount
parameter_list|,
name|HB_UShort
name|SubstCount
parameter_list|,
name|HB_SubstLookupRecord
modifier|*
name|subst
parameter_list|,
name|HB_Buffer
name|buffer
parameter_list|,
name|int
name|nesting_level
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_UInt
name|i
decl_stmt|,
name|old_pos
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|GlyphCount
condition|)
block|{
if|if
condition|(
name|SubstCount
operator|&&
name|i
operator|==
name|subst
operator|->
name|SequenceIndex
condition|)
block|{
name|old_pos
operator|=
name|buffer
operator|->
name|in_pos
expr_stmt|;
comment|/* Do a substitution */
name|error
operator|=
name|GSUB_Do_Glyph_Lookup
argument_list|(
name|gsub
argument_list|,
name|subst
operator|->
name|LookupListIndex
argument_list|,
name|buffer
argument_list|,
name|GlyphCount
argument_list|,
name|nesting_level
argument_list|)
expr_stmt|;
name|subst
operator|++
expr_stmt|;
name|SubstCount
operator|--
expr_stmt|;
name|i
operator|+=
name|buffer
operator|->
name|in_pos
operator|-
name|old_pos
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|HB_Err_Not_Covered
condition|)
block|{
if|if
condition|(
name|COPY_Glyph
argument_list|(
name|buffer
argument_list|)
condition|)
return|return
name|error
return|;
name|i
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
block|}
else|else
block|{
comment|/* No substitution for this index */
if|if
condition|(
name|COPY_Glyph
argument_list|(
name|buffer
argument_list|)
condition|)
return|return
name|error
return|;
name|i
operator|++
expr_stmt|;
block|}
block|}
return|return
name|HB_Err_Ok
return|;
block|}
end_function
begin_comment
comment|/* LookupType 5 */
end_comment
begin_comment
comment|/* SubRule */
end_comment
begin_function
DECL|function|Load_SubRule
specifier|static
name|HB_Error
name|Load_SubRule
parameter_list|(
name|HB_SubRule
modifier|*
name|sr
parameter_list|,
name|HB_Stream
name|stream
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_UShort
name|n
decl_stmt|,
name|count
decl_stmt|;
name|HB_UShort
modifier|*
name|i
decl_stmt|;
name|HB_SubstLookupRecord
modifier|*
name|slr
decl_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|4L
argument_list|)
condition|)
return|return
name|error
return|;
name|sr
operator|->
name|GlyphCount
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|sr
operator|->
name|SubstCount
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|sr
operator|->
name|Input
operator|=
name|NULL
expr_stmt|;
name|count
operator|=
name|sr
operator|->
name|GlyphCount
operator|-
literal|1
expr_stmt|;
comment|/* only GlyphCount - 1 elements */
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|sr
operator|->
name|Input
argument_list|,
name|count
argument_list|,
name|HB_UShort
argument_list|)
condition|)
return|return
name|error
return|;
name|i
operator|=
name|sr
operator|->
name|Input
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
name|count
operator|*
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail2
goto|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
name|i
index|[
name|n
index|]
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|sr
operator|->
name|SubstLookupRecord
operator|=
name|NULL
expr_stmt|;
name|count
operator|=
name|sr
operator|->
name|SubstCount
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|sr
operator|->
name|SubstLookupRecord
argument_list|,
name|count
argument_list|,
name|HB_SubstLookupRecord
argument_list|)
condition|)
goto|goto
name|Fail2
goto|;
name|slr
operator|=
name|sr
operator|->
name|SubstLookupRecord
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
name|count
operator|*
literal|4L
argument_list|)
condition|)
goto|goto
name|Fail1
goto|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
block|{
name|slr
index|[
name|n
index|]
operator|.
name|SequenceIndex
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|slr
index|[
name|n
index|]
operator|.
name|LookupListIndex
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
block|}
name|FORGET_Frame
argument_list|()
expr_stmt|;
return|return
name|HB_Err_Ok
return|;
name|Fail1
label|:
name|FREE
argument_list|(
name|slr
argument_list|)
expr_stmt|;
name|Fail2
label|:
name|FREE
argument_list|(
name|i
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_function
DECL|function|Free_SubRule
specifier|static
name|void
name|Free_SubRule
parameter_list|(
name|HB_SubRule
modifier|*
name|sr
parameter_list|)
block|{
name|FREE
argument_list|(
name|sr
operator|->
name|SubstLookupRecord
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|sr
operator|->
name|Input
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* SubRuleSet */
end_comment
begin_function
DECL|function|Load_SubRuleSet
specifier|static
name|HB_Error
name|Load_SubRuleSet
parameter_list|(
name|HB_SubRuleSet
modifier|*
name|srs
parameter_list|,
name|HB_Stream
name|stream
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_UShort
name|n
init|=
literal|0
decl_stmt|,
name|m
decl_stmt|,
name|count
decl_stmt|;
name|HB_UInt
name|cur_offset
decl_stmt|,
name|new_offset
decl_stmt|,
name|base_offset
decl_stmt|;
name|HB_SubRule
modifier|*
name|sr
decl_stmt|;
name|base_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
return|return
name|error
return|;
name|count
operator|=
name|srs
operator|->
name|SubRuleCount
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|srs
operator|->
name|SubRule
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|srs
operator|->
name|SubRule
argument_list|,
name|count
argument_list|,
name|HB_SubRule
argument_list|)
condition|)
return|return
name|error
return|;
name|sr
operator|=
name|srs
operator|->
name|SubRule
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
operator|+
name|base_offset
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|Load_SubRule
argument_list|(
operator|&
name|sr
index|[
name|n
index|]
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
goto|goto
name|Fail
goto|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
block|}
return|return
name|HB_Err_Ok
return|;
name|Fail
label|:
for|for
control|(
name|m
operator|=
literal|0
init|;
name|m
operator|<
name|n
condition|;
name|m
operator|++
control|)
name|Free_SubRule
argument_list|(
operator|&
name|sr
index|[
name|m
index|]
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|sr
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_function
DECL|function|Free_SubRuleSet
specifier|static
name|void
name|Free_SubRuleSet
parameter_list|(
name|HB_SubRuleSet
modifier|*
name|srs
parameter_list|)
block|{
name|HB_UShort
name|n
decl_stmt|,
name|count
decl_stmt|;
name|HB_SubRule
modifier|*
name|sr
decl_stmt|;
if|if
condition|(
name|srs
operator|->
name|SubRule
condition|)
block|{
name|count
operator|=
name|srs
operator|->
name|SubRuleCount
expr_stmt|;
name|sr
operator|=
name|srs
operator|->
name|SubRule
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
name|Free_SubRule
argument_list|(
operator|&
name|sr
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|sr
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/* ContextSubstFormat1 */
end_comment
begin_function
DECL|function|Load_ContextSubst1
specifier|static
name|HB_Error
name|Load_ContextSubst1
parameter_list|(
name|HB_ContextSubstFormat1
modifier|*
name|csf1
parameter_list|,
name|HB_Stream
name|stream
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_UShort
name|n
init|=
literal|0
decl_stmt|,
name|m
decl_stmt|,
name|count
decl_stmt|;
name|HB_UInt
name|cur_offset
decl_stmt|,
name|new_offset
decl_stmt|,
name|base_offset
decl_stmt|;
name|HB_SubRuleSet
modifier|*
name|srs
decl_stmt|;
name|base_offset
operator|=
name|FILE_Pos
argument_list|()
operator|-
literal|2L
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
return|return
name|error
return|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
operator|+
name|base_offset
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|_HB_OPEN_Load_Coverage
argument_list|(
operator|&
name|csf1
operator|->
name|Coverage
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
return|return
name|error
return|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail2
goto|;
name|count
operator|=
name|csf1
operator|->
name|SubRuleSetCount
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|csf1
operator|->
name|SubRuleSet
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|csf1
operator|->
name|SubRuleSet
argument_list|,
name|count
argument_list|,
name|HB_SubRuleSet
argument_list|)
condition|)
goto|goto
name|Fail2
goto|;
name|srs
operator|=
name|csf1
operator|->
name|SubRuleSet
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail1
goto|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
operator|+
name|base_offset
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|Load_SubRuleSet
argument_list|(
operator|&
name|srs
index|[
name|n
index|]
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
goto|goto
name|Fail1
goto|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
block|}
return|return
name|HB_Err_Ok
return|;
name|Fail1
label|:
for|for
control|(
name|m
operator|=
literal|0
init|;
name|m
operator|<
name|n
condition|;
name|m
operator|++
control|)
name|Free_SubRuleSet
argument_list|(
operator|&
name|srs
index|[
name|m
index|]
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|srs
argument_list|)
expr_stmt|;
name|Fail2
label|:
name|_HB_OPEN_Free_Coverage
argument_list|(
operator|&
name|csf1
operator|->
name|Coverage
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_function
DECL|function|Free_ContextSubst1
specifier|static
name|void
name|Free_ContextSubst1
parameter_list|(
name|HB_ContextSubstFormat1
modifier|*
name|csf1
parameter_list|)
block|{
name|HB_UShort
name|n
decl_stmt|,
name|count
decl_stmt|;
name|HB_SubRuleSet
modifier|*
name|srs
decl_stmt|;
if|if
condition|(
name|csf1
operator|->
name|SubRuleSet
condition|)
block|{
name|count
operator|=
name|csf1
operator|->
name|SubRuleSetCount
expr_stmt|;
name|srs
operator|=
name|csf1
operator|->
name|SubRuleSet
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
name|Free_SubRuleSet
argument_list|(
operator|&
name|srs
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|srs
argument_list|)
expr_stmt|;
block|}
name|_HB_OPEN_Free_Coverage
argument_list|(
operator|&
name|csf1
operator|->
name|Coverage
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* SubClassRule */
end_comment
begin_function
DECL|function|Load_SubClassRule
specifier|static
name|HB_Error
name|Load_SubClassRule
parameter_list|(
name|HB_ContextSubstFormat2
modifier|*
name|csf2
parameter_list|,
name|HB_SubClassRule
modifier|*
name|scr
parameter_list|,
name|HB_Stream
name|stream
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_UShort
name|n
decl_stmt|,
name|count
decl_stmt|;
name|HB_UShort
modifier|*
name|c
decl_stmt|;
name|HB_SubstLookupRecord
modifier|*
name|slr
decl_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|4L
argument_list|)
condition|)
return|return
name|error
return|;
name|scr
operator|->
name|GlyphCount
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|scr
operator|->
name|SubstCount
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
if|if
condition|(
name|scr
operator|->
name|GlyphCount
operator|>
name|csf2
operator|->
name|MaxContextLength
condition|)
name|csf2
operator|->
name|MaxContextLength
operator|=
name|scr
operator|->
name|GlyphCount
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|scr
operator|->
name|Class
operator|=
name|NULL
expr_stmt|;
name|count
operator|=
name|scr
operator|->
name|GlyphCount
operator|-
literal|1
expr_stmt|;
comment|/* only GlyphCount - 1 elements */
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|scr
operator|->
name|Class
argument_list|,
name|count
argument_list|,
name|HB_UShort
argument_list|)
condition|)
return|return
name|error
return|;
name|c
operator|=
name|scr
operator|->
name|Class
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
name|count
operator|*
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail2
goto|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
name|c
index|[
name|n
index|]
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|scr
operator|->
name|SubstLookupRecord
operator|=
name|NULL
expr_stmt|;
name|count
operator|=
name|scr
operator|->
name|SubstCount
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|scr
operator|->
name|SubstLookupRecord
argument_list|,
name|count
argument_list|,
name|HB_SubstLookupRecord
argument_list|)
condition|)
goto|goto
name|Fail2
goto|;
name|slr
operator|=
name|scr
operator|->
name|SubstLookupRecord
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
name|count
operator|*
literal|4L
argument_list|)
condition|)
goto|goto
name|Fail1
goto|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
block|{
name|slr
index|[
name|n
index|]
operator|.
name|SequenceIndex
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|slr
index|[
name|n
index|]
operator|.
name|LookupListIndex
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
block|}
name|FORGET_Frame
argument_list|()
expr_stmt|;
return|return
name|HB_Err_Ok
return|;
name|Fail1
label|:
name|FREE
argument_list|(
name|slr
argument_list|)
expr_stmt|;
name|Fail2
label|:
name|FREE
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_function
DECL|function|Free_SubClassRule
specifier|static
name|void
name|Free_SubClassRule
parameter_list|(
name|HB_SubClassRule
modifier|*
name|scr
parameter_list|)
block|{
name|FREE
argument_list|(
name|scr
operator|->
name|SubstLookupRecord
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|scr
operator|->
name|Class
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* SubClassSet */
end_comment
begin_function
DECL|function|Load_SubClassSet
specifier|static
name|HB_Error
name|Load_SubClassSet
parameter_list|(
name|HB_ContextSubstFormat2
modifier|*
name|csf2
parameter_list|,
name|HB_SubClassSet
modifier|*
name|scs
parameter_list|,
name|HB_Stream
name|stream
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_UShort
name|n
init|=
literal|0
decl_stmt|,
name|m
decl_stmt|,
name|count
decl_stmt|;
name|HB_UInt
name|cur_offset
decl_stmt|,
name|new_offset
decl_stmt|,
name|base_offset
decl_stmt|;
name|HB_SubClassRule
modifier|*
name|scr
decl_stmt|;
name|base_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
return|return
name|error
return|;
name|count
operator|=
name|scs
operator|->
name|SubClassRuleCount
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|scs
operator|->
name|SubClassRule
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|scs
operator|->
name|SubClassRule
argument_list|,
name|count
argument_list|,
name|HB_SubClassRule
argument_list|)
condition|)
return|return
name|error
return|;
name|scr
operator|=
name|scs
operator|->
name|SubClassRule
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
operator|+
name|base_offset
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|Load_SubClassRule
argument_list|(
name|csf2
argument_list|,
operator|&
name|scr
index|[
name|n
index|]
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
goto|goto
name|Fail
goto|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
block|}
return|return
name|HB_Err_Ok
return|;
name|Fail
label|:
for|for
control|(
name|m
operator|=
literal|0
init|;
name|m
operator|<
name|n
condition|;
name|m
operator|++
control|)
name|Free_SubClassRule
argument_list|(
operator|&
name|scr
index|[
name|m
index|]
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|scr
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_function
DECL|function|Free_SubClassSet
specifier|static
name|void
name|Free_SubClassSet
parameter_list|(
name|HB_SubClassSet
modifier|*
name|scs
parameter_list|)
block|{
name|HB_UShort
name|n
decl_stmt|,
name|count
decl_stmt|;
name|HB_SubClassRule
modifier|*
name|scr
decl_stmt|;
if|if
condition|(
name|scs
operator|->
name|SubClassRule
condition|)
block|{
name|count
operator|=
name|scs
operator|->
name|SubClassRuleCount
expr_stmt|;
name|scr
operator|=
name|scs
operator|->
name|SubClassRule
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
name|Free_SubClassRule
argument_list|(
operator|&
name|scr
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|scr
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/* ContextSubstFormat2 */
end_comment
begin_function
DECL|function|Load_ContextSubst2
specifier|static
name|HB_Error
name|Load_ContextSubst2
parameter_list|(
name|HB_ContextSubstFormat2
modifier|*
name|csf2
parameter_list|,
name|HB_Stream
name|stream
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_UShort
name|n
init|=
literal|0
decl_stmt|,
name|m
decl_stmt|,
name|count
decl_stmt|;
name|HB_UInt
name|cur_offset
decl_stmt|,
name|new_offset
decl_stmt|,
name|base_offset
decl_stmt|;
name|HB_SubClassSet
modifier|*
name|scs
decl_stmt|;
name|base_offset
operator|=
name|FILE_Pos
argument_list|()
operator|-
literal|2
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
return|return
name|error
return|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
operator|+
name|base_offset
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|_HB_OPEN_Load_Coverage
argument_list|(
operator|&
name|csf2
operator|->
name|Coverage
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
return|return
name|error
return|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|4L
argument_list|)
condition|)
goto|goto
name|Fail3
goto|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
operator|+
name|base_offset
expr_stmt|;
comment|/* `SubClassSetCount' is the upper limit for class values, thus we      read it now to make an additional safety check.                 */
name|count
operator|=
name|csf2
operator|->
name|SubClassSetCount
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|_HB_OPEN_Load_ClassDefinition
argument_list|(
operator|&
name|csf2
operator|->
name|ClassDef
argument_list|,
name|count
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
goto|goto
name|Fail3
goto|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
name|csf2
operator|->
name|SubClassSet
operator|=
name|NULL
expr_stmt|;
name|csf2
operator|->
name|MaxContextLength
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|csf2
operator|->
name|SubClassSet
argument_list|,
name|count
argument_list|,
name|HB_SubClassSet
argument_list|)
condition|)
goto|goto
name|Fail2
goto|;
name|scs
operator|=
name|csf2
operator|->
name|SubClassSet
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail1
goto|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
operator|+
name|base_offset
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
if|if
condition|(
name|new_offset
operator|!=
name|base_offset
condition|)
comment|/* not a NULL offset */
block|{
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|Load_SubClassSet
argument_list|(
name|csf2
argument_list|,
operator|&
name|scs
index|[
name|n
index|]
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
goto|goto
name|Fail1
goto|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* we create a SubClassSet table with no entries */
name|csf2
operator|->
name|SubClassSet
index|[
name|n
index|]
operator|.
name|SubClassRuleCount
operator|=
literal|0
expr_stmt|;
name|csf2
operator|->
name|SubClassSet
index|[
name|n
index|]
operator|.
name|SubClassRule
operator|=
name|NULL
expr_stmt|;
block|}
block|}
return|return
name|HB_Err_Ok
return|;
name|Fail1
label|:
for|for
control|(
name|m
operator|=
literal|0
init|;
name|m
operator|<
name|n
condition|;
name|m
operator|++
control|)
name|Free_SubClassSet
argument_list|(
operator|&
name|scs
index|[
name|m
index|]
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|scs
argument_list|)
expr_stmt|;
name|Fail2
label|:
name|_HB_OPEN_Free_ClassDefinition
argument_list|(
operator|&
name|csf2
operator|->
name|ClassDef
argument_list|)
expr_stmt|;
name|Fail3
label|:
name|_HB_OPEN_Free_Coverage
argument_list|(
operator|&
name|csf2
operator|->
name|Coverage
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_function
DECL|function|Free_ContextSubst2
specifier|static
name|void
name|Free_ContextSubst2
parameter_list|(
name|HB_ContextSubstFormat2
modifier|*
name|csf2
parameter_list|)
block|{
name|HB_UShort
name|n
decl_stmt|,
name|count
decl_stmt|;
name|HB_SubClassSet
modifier|*
name|scs
decl_stmt|;
if|if
condition|(
name|csf2
operator|->
name|SubClassSet
condition|)
block|{
name|count
operator|=
name|csf2
operator|->
name|SubClassSetCount
expr_stmt|;
name|scs
operator|=
name|csf2
operator|->
name|SubClassSet
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
name|Free_SubClassSet
argument_list|(
operator|&
name|scs
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|scs
argument_list|)
expr_stmt|;
block|}
name|_HB_OPEN_Free_ClassDefinition
argument_list|(
operator|&
name|csf2
operator|->
name|ClassDef
argument_list|)
expr_stmt|;
name|_HB_OPEN_Free_Coverage
argument_list|(
operator|&
name|csf2
operator|->
name|Coverage
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* ContextSubstFormat3 */
end_comment
begin_function
DECL|function|Load_ContextSubst3
specifier|static
name|HB_Error
name|Load_ContextSubst3
parameter_list|(
name|HB_ContextSubstFormat3
modifier|*
name|csf3
parameter_list|,
name|HB_Stream
name|stream
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_UShort
name|n
init|=
literal|0
decl_stmt|,
name|m
decl_stmt|,
name|count
decl_stmt|;
name|HB_UInt
name|cur_offset
decl_stmt|,
name|new_offset
decl_stmt|,
name|base_offset
decl_stmt|;
name|HB_Coverage
modifier|*
name|c
decl_stmt|;
name|HB_SubstLookupRecord
modifier|*
name|slr
decl_stmt|;
name|base_offset
operator|=
name|FILE_Pos
argument_list|()
operator|-
literal|2L
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|4L
argument_list|)
condition|)
return|return
name|error
return|;
name|csf3
operator|->
name|GlyphCount
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|csf3
operator|->
name|SubstCount
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|csf3
operator|->
name|Coverage
operator|=
name|NULL
expr_stmt|;
name|count
operator|=
name|csf3
operator|->
name|GlyphCount
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|csf3
operator|->
name|Coverage
argument_list|,
name|count
argument_list|,
name|HB_Coverage
argument_list|)
condition|)
return|return
name|error
return|;
name|c
operator|=
name|csf3
operator|->
name|Coverage
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail2
goto|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
operator|+
name|base_offset
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|_HB_OPEN_Load_Coverage
argument_list|(
operator|&
name|c
index|[
name|n
index|]
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
goto|goto
name|Fail2
goto|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
block|}
name|csf3
operator|->
name|SubstLookupRecord
operator|=
name|NULL
expr_stmt|;
name|count
operator|=
name|csf3
operator|->
name|SubstCount
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|csf3
operator|->
name|SubstLookupRecord
argument_list|,
name|count
argument_list|,
name|HB_SubstLookupRecord
argument_list|)
condition|)
goto|goto
name|Fail2
goto|;
name|slr
operator|=
name|csf3
operator|->
name|SubstLookupRecord
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
name|count
operator|*
literal|4L
argument_list|)
condition|)
goto|goto
name|Fail1
goto|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
block|{
name|slr
index|[
name|n
index|]
operator|.
name|SequenceIndex
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|slr
index|[
name|n
index|]
operator|.
name|LookupListIndex
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
block|}
name|FORGET_Frame
argument_list|()
expr_stmt|;
return|return
name|HB_Err_Ok
return|;
name|Fail1
label|:
name|FREE
argument_list|(
name|slr
argument_list|)
expr_stmt|;
name|Fail2
label|:
for|for
control|(
name|m
operator|=
literal|0
init|;
name|m
operator|<
name|n
condition|;
name|m
operator|++
control|)
name|_HB_OPEN_Free_Coverage
argument_list|(
operator|&
name|c
index|[
name|m
index|]
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_function
DECL|function|Free_ContextSubst3
specifier|static
name|void
name|Free_ContextSubst3
parameter_list|(
name|HB_ContextSubstFormat3
modifier|*
name|csf3
parameter_list|)
block|{
name|HB_UShort
name|n
decl_stmt|,
name|count
decl_stmt|;
name|HB_Coverage
modifier|*
name|c
decl_stmt|;
name|FREE
argument_list|(
name|csf3
operator|->
name|SubstLookupRecord
argument_list|)
expr_stmt|;
if|if
condition|(
name|csf3
operator|->
name|Coverage
condition|)
block|{
name|count
operator|=
name|csf3
operator|->
name|GlyphCount
expr_stmt|;
name|c
operator|=
name|csf3
operator|->
name|Coverage
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
name|_HB_OPEN_Free_Coverage
argument_list|(
operator|&
name|c
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/* ContextSubst */
end_comment
begin_function
DECL|function|Load_ContextSubst
specifier|static
name|HB_Error
name|Load_ContextSubst
parameter_list|(
name|HB_GSUB_SubTable
modifier|*
name|st
parameter_list|,
name|HB_Stream
name|stream
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_ContextSubst
modifier|*
name|cs
init|=
operator|&
name|st
operator|->
name|context
decl_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
return|return
name|error
return|;
name|cs
operator|->
name|SubstFormat
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|cs
operator|->
name|SubstFormat
condition|)
block|{
case|case
literal|1
case|:
return|return
name|Load_ContextSubst1
argument_list|(
operator|&
name|cs
operator|->
name|csf
operator|.
name|csf1
argument_list|,
name|stream
argument_list|)
return|;
case|case
literal|2
case|:
return|return
name|Load_ContextSubst2
argument_list|(
operator|&
name|cs
operator|->
name|csf
operator|.
name|csf2
argument_list|,
name|stream
argument_list|)
return|;
case|case
literal|3
case|:
return|return
name|Load_ContextSubst3
argument_list|(
operator|&
name|cs
operator|->
name|csf
operator|.
name|csf3
argument_list|,
name|stream
argument_list|)
return|;
default|default:
return|return
name|ERR
argument_list|(
name|HB_Err_Invalid_SubTable_Format
argument_list|)
return|;
block|}
return|return
name|HB_Err_Ok
return|;
comment|/* never reached */
block|}
end_function
begin_function
DECL|function|Free_ContextSubst
specifier|static
name|void
name|Free_ContextSubst
parameter_list|(
name|HB_GSUB_SubTable
modifier|*
name|st
parameter_list|)
block|{
name|HB_ContextSubst
modifier|*
name|cs
init|=
operator|&
name|st
operator|->
name|context
decl_stmt|;
switch|switch
condition|(
name|cs
operator|->
name|SubstFormat
condition|)
block|{
case|case
literal|1
case|:
name|Free_ContextSubst1
argument_list|(
operator|&
name|cs
operator|->
name|csf
operator|.
name|csf1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|Free_ContextSubst2
argument_list|(
operator|&
name|cs
operator|->
name|csf
operator|.
name|csf2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|Free_ContextSubst3
argument_list|(
operator|&
name|cs
operator|->
name|csf
operator|.
name|csf3
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function
begin_function
DECL|function|Lookup_ContextSubst1
specifier|static
name|HB_Error
name|Lookup_ContextSubst1
parameter_list|(
name|HB_GSUBHeader
modifier|*
name|gsub
parameter_list|,
name|HB_ContextSubstFormat1
modifier|*
name|csf1
parameter_list|,
name|HB_Buffer
name|buffer
parameter_list|,
name|HB_UShort
name|flags
parameter_list|,
name|HB_UShort
name|context_length
parameter_list|,
name|int
name|nesting_level
parameter_list|)
block|{
name|HB_UShort
name|index
decl_stmt|,
name|property
decl_stmt|;
name|HB_UShort
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|numsr
decl_stmt|;
name|HB_Error
name|error
decl_stmt|;
name|HB_SubRule
modifier|*
name|sr
decl_stmt|;
name|HB_GDEFHeader
modifier|*
name|gdef
decl_stmt|;
name|gdef
operator|=
name|gsub
operator|->
name|gdef
expr_stmt|;
if|if
condition|(
name|CHECK_Property
argument_list|(
name|gdef
argument_list|,
name|IN_CURITEM
argument_list|()
argument_list|,
name|flags
argument_list|,
operator|&
name|property
argument_list|)
condition|)
return|return
name|error
return|;
name|error
operator|=
name|_HB_OPEN_Coverage_Index
argument_list|(
operator|&
name|csf1
operator|->
name|Coverage
argument_list|,
name|IN_CURGLYPH
argument_list|()
argument_list|,
operator|&
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|sr
operator|=
name|csf1
operator|->
name|SubRuleSet
index|[
name|index
index|]
operator|.
name|SubRule
expr_stmt|;
name|numsr
operator|=
name|csf1
operator|->
name|SubRuleSet
index|[
name|index
index|]
operator|.
name|SubRuleCount
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|numsr
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|context_length
operator|!=
literal|0xFFFF
operator|&&
name|context_length
operator|<
name|sr
index|[
name|k
index|]
operator|.
name|GlyphCount
condition|)
goto|goto
name|next_subrule
goto|;
if|if
condition|(
name|buffer
operator|->
name|in_pos
operator|+
name|sr
index|[
name|k
index|]
operator|.
name|GlyphCount
operator|>
name|buffer
operator|->
name|in_length
condition|)
goto|goto
name|next_subrule
goto|;
comment|/* context is too long */
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|j
operator|=
name|buffer
operator|->
name|in_pos
operator|+
literal|1
init|;
name|i
operator|<
name|sr
index|[
name|k
index|]
operator|.
name|GlyphCount
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
while|while
condition|(
name|CHECK_Property
argument_list|(
name|gdef
argument_list|,
name|IN_ITEM
argument_list|(
name|j
argument_list|)
argument_list|,
name|flags
argument_list|,
operator|&
name|property
argument_list|)
condition|)
block|{
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|HB_Err_Not_Covered
condition|)
return|return
name|error
return|;
if|if
condition|(
name|j
operator|+
name|sr
index|[
name|k
index|]
operator|.
name|GlyphCount
operator|-
name|i
operator|==
operator|(
name|HB_Int
operator|)
name|buffer
operator|->
name|in_length
condition|)
goto|goto
name|next_subrule
goto|;
name|j
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|IN_GLYPH
argument_list|(
name|j
argument_list|)
operator|!=
name|sr
index|[
name|k
index|]
operator|.
name|Input
index|[
name|i
operator|-
literal|1
index|]
condition|)
goto|goto
name|next_subrule
goto|;
block|}
return|return
name|Do_ContextSubst
argument_list|(
name|gsub
argument_list|,
name|sr
index|[
name|k
index|]
operator|.
name|GlyphCount
argument_list|,
name|sr
index|[
name|k
index|]
operator|.
name|SubstCount
argument_list|,
name|sr
index|[
name|k
index|]
operator|.
name|SubstLookupRecord
argument_list|,
name|buffer
argument_list|,
name|nesting_level
argument_list|)
return|;
name|next_subrule
label|:
empty_stmt|;
block|}
return|return
name|HB_Err_Not_Covered
return|;
block|}
end_function
begin_function
DECL|function|Lookup_ContextSubst2
specifier|static
name|HB_Error
name|Lookup_ContextSubst2
parameter_list|(
name|HB_GSUBHeader
modifier|*
name|gsub
parameter_list|,
name|HB_ContextSubstFormat2
modifier|*
name|csf2
parameter_list|,
name|HB_Buffer
name|buffer
parameter_list|,
name|HB_UShort
name|flags
parameter_list|,
name|HB_UShort
name|context_length
parameter_list|,
name|int
name|nesting_level
parameter_list|)
block|{
name|HB_UShort
name|index
decl_stmt|,
name|property
decl_stmt|;
name|HB_Error
name|error
decl_stmt|;
name|HB_UShort
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|known_classes
decl_stmt|;
name|HB_UShort
modifier|*
name|classes
decl_stmt|;
name|HB_UShort
modifier|*
name|cl
decl_stmt|;
name|HB_SubClassSet
modifier|*
name|scs
decl_stmt|;
name|HB_SubClassRule
modifier|*
name|sr
decl_stmt|;
name|HB_GDEFHeader
modifier|*
name|gdef
decl_stmt|;
name|gdef
operator|=
name|gsub
operator|->
name|gdef
expr_stmt|;
if|if
condition|(
name|CHECK_Property
argument_list|(
name|gdef
argument_list|,
name|IN_CURITEM
argument_list|()
argument_list|,
name|flags
argument_list|,
operator|&
name|property
argument_list|)
condition|)
return|return
name|error
return|;
comment|/* Note: The coverage table in format 2 doesn't give an index into 	   anything.  It just lets us know whether or not we need to 	   do any lookup at all.                                     */
name|error
operator|=
name|_HB_OPEN_Coverage_Index
argument_list|(
operator|&
name|csf2
operator|->
name|Coverage
argument_list|,
name|IN_CURGLYPH
argument_list|()
argument_list|,
operator|&
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
name|csf2
operator|->
name|MaxContextLength
operator|<
literal|1
condition|)
return|return
name|HB_Err_Not_Covered
return|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|classes
argument_list|,
name|csf2
operator|->
name|MaxContextLength
argument_list|,
name|HB_UShort
argument_list|)
condition|)
return|return
name|error
return|;
name|error
operator|=
name|_HB_OPEN_Get_Class
argument_list|(
operator|&
name|csf2
operator|->
name|ClassDef
argument_list|,
name|IN_CURGLYPH
argument_list|()
argument_list|,
operator|&
name|classes
index|[
literal|0
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|HB_Err_Not_Covered
condition|)
goto|goto
name|End
goto|;
name|known_classes
operator|=
literal|0
expr_stmt|;
name|scs
operator|=
operator|&
name|csf2
operator|->
name|SubClassSet
index|[
name|classes
index|[
literal|0
index|]
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|scs
condition|)
block|{
name|error
operator|=
name|ERR
argument_list|(
name|HB_Err_Invalid_SubTable
argument_list|)
expr_stmt|;
goto|goto
name|End
goto|;
block|}
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|scs
operator|->
name|SubClassRuleCount
condition|;
name|k
operator|++
control|)
block|{
name|sr
operator|=
operator|&
name|scs
operator|->
name|SubClassRule
index|[
name|k
index|]
expr_stmt|;
if|if
condition|(
name|context_length
operator|!=
literal|0xFFFF
operator|&&
name|context_length
operator|<
name|sr
operator|->
name|GlyphCount
condition|)
goto|goto
name|next_subclassrule
goto|;
if|if
condition|(
name|buffer
operator|->
name|in_pos
operator|+
name|sr
operator|->
name|GlyphCount
operator|>
name|buffer
operator|->
name|in_length
condition|)
goto|goto
name|next_subclassrule
goto|;
comment|/* context is too long */
name|cl
operator|=
name|sr
operator|->
name|Class
expr_stmt|;
comment|/* Start at 1 because [0] is implied */
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|j
operator|=
name|buffer
operator|->
name|in_pos
operator|+
literal|1
init|;
name|i
operator|<
name|sr
operator|->
name|GlyphCount
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
while|while
condition|(
name|CHECK_Property
argument_list|(
name|gdef
argument_list|,
name|IN_ITEM
argument_list|(
name|j
argument_list|)
argument_list|,
name|flags
argument_list|,
operator|&
name|property
argument_list|)
condition|)
block|{
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|HB_Err_Not_Covered
condition|)
goto|goto
name|End
goto|;
if|if
condition|(
name|j
operator|+
name|sr
operator|->
name|GlyphCount
operator|-
name|i
operator|<
operator|(
name|HB_Int
operator|)
name|buffer
operator|->
name|in_length
condition|)
goto|goto
name|next_subclassrule
goto|;
name|j
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>
name|known_classes
condition|)
block|{
comment|/* Keeps us from having to do this for each rule */
name|error
operator|=
name|_HB_OPEN_Get_Class
argument_list|(
operator|&
name|csf2
operator|->
name|ClassDef
argument_list|,
name|IN_GLYPH
argument_list|(
name|j
argument_list|)
argument_list|,
operator|&
name|classes
index|[
name|i
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|HB_Err_Not_Covered
condition|)
goto|goto
name|End
goto|;
name|known_classes
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|cl
index|[
name|i
operator|-
literal|1
index|]
operator|!=
name|classes
index|[
name|i
index|]
condition|)
goto|goto
name|next_subclassrule
goto|;
block|}
name|error
operator|=
name|Do_ContextSubst
argument_list|(
name|gsub
argument_list|,
name|sr
operator|->
name|GlyphCount
argument_list|,
name|sr
operator|->
name|SubstCount
argument_list|,
name|sr
operator|->
name|SubstLookupRecord
argument_list|,
name|buffer
argument_list|,
name|nesting_level
argument_list|)
expr_stmt|;
goto|goto
name|End
goto|;
name|next_subclassrule
label|:
empty_stmt|;
block|}
name|error
operator|=
name|HB_Err_Not_Covered
expr_stmt|;
name|End
label|:
name|FREE
argument_list|(
name|classes
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_function
DECL|function|Lookup_ContextSubst3
specifier|static
name|HB_Error
name|Lookup_ContextSubst3
parameter_list|(
name|HB_GSUBHeader
modifier|*
name|gsub
parameter_list|,
name|HB_ContextSubstFormat3
modifier|*
name|csf3
parameter_list|,
name|HB_Buffer
name|buffer
parameter_list|,
name|HB_UShort
name|flags
parameter_list|,
name|HB_UShort
name|context_length
parameter_list|,
name|int
name|nesting_level
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_UShort
name|index
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|property
decl_stmt|;
name|HB_Coverage
modifier|*
name|c
decl_stmt|;
name|HB_GDEFHeader
modifier|*
name|gdef
decl_stmt|;
name|gdef
operator|=
name|gsub
operator|->
name|gdef
expr_stmt|;
if|if
condition|(
name|CHECK_Property
argument_list|(
name|gdef
argument_list|,
name|IN_CURITEM
argument_list|()
argument_list|,
name|flags
argument_list|,
operator|&
name|property
argument_list|)
condition|)
return|return
name|error
return|;
if|if
condition|(
name|context_length
operator|!=
literal|0xFFFF
operator|&&
name|context_length
operator|<
name|csf3
operator|->
name|GlyphCount
condition|)
return|return
name|HB_Err_Not_Covered
return|;
if|if
condition|(
name|buffer
operator|->
name|in_pos
operator|+
name|csf3
operator|->
name|GlyphCount
operator|>
name|buffer
operator|->
name|in_length
condition|)
return|return
name|HB_Err_Not_Covered
return|;
comment|/* context is too long */
name|c
operator|=
name|csf3
operator|->
name|Coverage
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|j
operator|=
name|buffer
operator|->
name|in_pos
operator|+
literal|1
init|;
name|i
operator|<
name|csf3
operator|->
name|GlyphCount
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
while|while
condition|(
name|CHECK_Property
argument_list|(
name|gdef
argument_list|,
name|IN_ITEM
argument_list|(
name|j
argument_list|)
argument_list|,
name|flags
argument_list|,
operator|&
name|property
argument_list|)
condition|)
block|{
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|HB_Err_Not_Covered
condition|)
return|return
name|error
return|;
if|if
condition|(
name|j
operator|+
name|csf3
operator|->
name|GlyphCount
operator|-
name|i
operator|==
operator|(
name|HB_Int
operator|)
name|buffer
operator|->
name|in_length
condition|)
return|return
name|HB_Err_Not_Covered
return|;
name|j
operator|++
expr_stmt|;
block|}
name|error
operator|=
name|_HB_OPEN_Coverage_Index
argument_list|(
operator|&
name|c
index|[
name|i
index|]
argument_list|,
name|IN_GLYPH
argument_list|(
name|j
argument_list|)
argument_list|,
operator|&
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
block|}
return|return
name|Do_ContextSubst
argument_list|(
name|gsub
argument_list|,
name|csf3
operator|->
name|GlyphCount
argument_list|,
name|csf3
operator|->
name|SubstCount
argument_list|,
name|csf3
operator|->
name|SubstLookupRecord
argument_list|,
name|buffer
argument_list|,
name|nesting_level
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|Lookup_ContextSubst
specifier|static
name|HB_Error
name|Lookup_ContextSubst
parameter_list|(
name|HB_GSUBHeader
modifier|*
name|gsub
parameter_list|,
name|HB_GSUB_SubTable
modifier|*
name|st
parameter_list|,
name|HB_Buffer
name|buffer
parameter_list|,
name|HB_UShort
name|flags
parameter_list|,
name|HB_UShort
name|context_length
parameter_list|,
name|int
name|nesting_level
parameter_list|)
block|{
name|HB_ContextSubst
modifier|*
name|cs
init|=
operator|&
name|st
operator|->
name|context
decl_stmt|;
switch|switch
condition|(
name|cs
operator|->
name|SubstFormat
condition|)
block|{
case|case
literal|1
case|:
return|return
name|Lookup_ContextSubst1
argument_list|(
name|gsub
argument_list|,
operator|&
name|cs
operator|->
name|csf
operator|.
name|csf1
argument_list|,
name|buffer
argument_list|,
name|flags
argument_list|,
name|context_length
argument_list|,
name|nesting_level
argument_list|)
return|;
case|case
literal|2
case|:
return|return
name|Lookup_ContextSubst2
argument_list|(
name|gsub
argument_list|,
operator|&
name|cs
operator|->
name|csf
operator|.
name|csf2
argument_list|,
name|buffer
argument_list|,
name|flags
argument_list|,
name|context_length
argument_list|,
name|nesting_level
argument_list|)
return|;
case|case
literal|3
case|:
return|return
name|Lookup_ContextSubst3
argument_list|(
name|gsub
argument_list|,
operator|&
name|cs
operator|->
name|csf
operator|.
name|csf3
argument_list|,
name|buffer
argument_list|,
name|flags
argument_list|,
name|context_length
argument_list|,
name|nesting_level
argument_list|)
return|;
default|default:
return|return
name|ERR
argument_list|(
name|HB_Err_Invalid_SubTable_Format
argument_list|)
return|;
block|}
return|return
name|HB_Err_Ok
return|;
comment|/* never reached */
block|}
end_function
begin_comment
comment|/* LookupType 6 */
end_comment
begin_comment
comment|/* ChainSubRule */
end_comment
begin_function
DECL|function|Load_ChainSubRule
specifier|static
name|HB_Error
name|Load_ChainSubRule
parameter_list|(
name|HB_ChainSubRule
modifier|*
name|csr
parameter_list|,
name|HB_Stream
name|stream
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_UShort
name|n
decl_stmt|,
name|count
decl_stmt|;
name|HB_UShort
modifier|*
name|b
decl_stmt|;
name|HB_UShort
modifier|*
name|i
decl_stmt|;
name|HB_UShort
modifier|*
name|l
decl_stmt|;
name|HB_SubstLookupRecord
modifier|*
name|slr
decl_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
return|return
name|error
return|;
name|csr
operator|->
name|BacktrackGlyphCount
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|csr
operator|->
name|Backtrack
operator|=
name|NULL
expr_stmt|;
name|count
operator|=
name|csr
operator|->
name|BacktrackGlyphCount
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|csr
operator|->
name|Backtrack
argument_list|,
name|count
argument_list|,
name|HB_UShort
argument_list|)
condition|)
return|return
name|error
return|;
name|b
operator|=
name|csr
operator|->
name|Backtrack
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
name|count
operator|*
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail4
goto|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
name|b
index|[
name|n
index|]
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail4
goto|;
name|csr
operator|->
name|InputGlyphCount
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|csr
operator|->
name|Input
operator|=
name|NULL
expr_stmt|;
name|count
operator|=
name|csr
operator|->
name|InputGlyphCount
operator|-
literal|1
expr_stmt|;
comment|/* only InputGlyphCount - 1 elements */
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|csr
operator|->
name|Input
argument_list|,
name|count
argument_list|,
name|HB_UShort
argument_list|)
condition|)
goto|goto
name|Fail4
goto|;
name|i
operator|=
name|csr
operator|->
name|Input
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
name|count
operator|*
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail3
goto|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
name|i
index|[
name|n
index|]
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail3
goto|;
name|csr
operator|->
name|LookaheadGlyphCount
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|csr
operator|->
name|Lookahead
operator|=
name|NULL
expr_stmt|;
name|count
operator|=
name|csr
operator|->
name|LookaheadGlyphCount
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|csr
operator|->
name|Lookahead
argument_list|,
name|count
argument_list|,
name|HB_UShort
argument_list|)
condition|)
goto|goto
name|Fail3
goto|;
name|l
operator|=
name|csr
operator|->
name|Lookahead
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
name|count
operator|*
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail2
goto|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
name|l
index|[
name|n
index|]
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail2
goto|;
name|csr
operator|->
name|SubstCount
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|csr
operator|->
name|SubstLookupRecord
operator|=
name|NULL
expr_stmt|;
name|count
operator|=
name|csr
operator|->
name|SubstCount
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|csr
operator|->
name|SubstLookupRecord
argument_list|,
name|count
argument_list|,
name|HB_SubstLookupRecord
argument_list|)
condition|)
goto|goto
name|Fail2
goto|;
name|slr
operator|=
name|csr
operator|->
name|SubstLookupRecord
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
name|count
operator|*
literal|4L
argument_list|)
condition|)
goto|goto
name|Fail1
goto|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
block|{
name|slr
index|[
name|n
index|]
operator|.
name|SequenceIndex
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|slr
index|[
name|n
index|]
operator|.
name|LookupListIndex
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
block|}
name|FORGET_Frame
argument_list|()
expr_stmt|;
return|return
name|HB_Err_Ok
return|;
name|Fail1
label|:
name|FREE
argument_list|(
name|slr
argument_list|)
expr_stmt|;
name|Fail2
label|:
name|FREE
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|Fail3
label|:
name|FREE
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|Fail4
label|:
name|FREE
argument_list|(
name|b
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_function
DECL|function|Free_ChainSubRule
specifier|static
name|void
name|Free_ChainSubRule
parameter_list|(
name|HB_ChainSubRule
modifier|*
name|csr
parameter_list|)
block|{
name|FREE
argument_list|(
name|csr
operator|->
name|SubstLookupRecord
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|csr
operator|->
name|Lookahead
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|csr
operator|->
name|Input
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|csr
operator|->
name|Backtrack
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* ChainSubRuleSet */
end_comment
begin_function
DECL|function|Load_ChainSubRuleSet
specifier|static
name|HB_Error
name|Load_ChainSubRuleSet
parameter_list|(
name|HB_ChainSubRuleSet
modifier|*
name|csrs
parameter_list|,
name|HB_Stream
name|stream
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_UShort
name|n
init|=
literal|0
decl_stmt|,
name|m
decl_stmt|,
name|count
decl_stmt|;
name|HB_UInt
name|cur_offset
decl_stmt|,
name|new_offset
decl_stmt|,
name|base_offset
decl_stmt|;
name|HB_ChainSubRule
modifier|*
name|csr
decl_stmt|;
name|base_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
return|return
name|error
return|;
name|count
operator|=
name|csrs
operator|->
name|ChainSubRuleCount
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|csrs
operator|->
name|ChainSubRule
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|csrs
operator|->
name|ChainSubRule
argument_list|,
name|count
argument_list|,
name|HB_ChainSubRule
argument_list|)
condition|)
return|return
name|error
return|;
name|csr
operator|=
name|csrs
operator|->
name|ChainSubRule
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
operator|+
name|base_offset
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|Load_ChainSubRule
argument_list|(
operator|&
name|csr
index|[
name|n
index|]
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
goto|goto
name|Fail
goto|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
block|}
return|return
name|HB_Err_Ok
return|;
name|Fail
label|:
for|for
control|(
name|m
operator|=
literal|0
init|;
name|m
operator|<
name|n
condition|;
name|m
operator|++
control|)
name|Free_ChainSubRule
argument_list|(
operator|&
name|csr
index|[
name|m
index|]
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|csr
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_function
DECL|function|Free_ChainSubRuleSet
specifier|static
name|void
name|Free_ChainSubRuleSet
parameter_list|(
name|HB_ChainSubRuleSet
modifier|*
name|csrs
parameter_list|)
block|{
name|HB_UShort
name|n
decl_stmt|,
name|count
decl_stmt|;
name|HB_ChainSubRule
modifier|*
name|csr
decl_stmt|;
if|if
condition|(
name|csrs
operator|->
name|ChainSubRule
condition|)
block|{
name|count
operator|=
name|csrs
operator|->
name|ChainSubRuleCount
expr_stmt|;
name|csr
operator|=
name|csrs
operator|->
name|ChainSubRule
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
name|Free_ChainSubRule
argument_list|(
operator|&
name|csr
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|csr
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/* ChainContextSubstFormat1 */
end_comment
begin_function
DECL|function|Load_ChainContextSubst1
specifier|static
name|HB_Error
name|Load_ChainContextSubst1
parameter_list|(
name|HB_ChainContextSubstFormat1
modifier|*
name|ccsf1
parameter_list|,
name|HB_Stream
name|stream
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_UShort
name|n
init|=
literal|0
decl_stmt|,
name|m
decl_stmt|,
name|count
decl_stmt|;
name|HB_UInt
name|cur_offset
decl_stmt|,
name|new_offset
decl_stmt|,
name|base_offset
decl_stmt|;
name|HB_ChainSubRuleSet
modifier|*
name|csrs
decl_stmt|;
name|base_offset
operator|=
name|FILE_Pos
argument_list|()
operator|-
literal|2L
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
return|return
name|error
return|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
operator|+
name|base_offset
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|_HB_OPEN_Load_Coverage
argument_list|(
operator|&
name|ccsf1
operator|->
name|Coverage
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
return|return
name|error
return|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail2
goto|;
name|count
operator|=
name|ccsf1
operator|->
name|ChainSubRuleSetCount
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|ccsf1
operator|->
name|ChainSubRuleSet
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|ccsf1
operator|->
name|ChainSubRuleSet
argument_list|,
name|count
argument_list|,
name|HB_ChainSubRuleSet
argument_list|)
condition|)
goto|goto
name|Fail2
goto|;
name|csrs
operator|=
name|ccsf1
operator|->
name|ChainSubRuleSet
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail1
goto|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
operator|+
name|base_offset
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|Load_ChainSubRuleSet
argument_list|(
operator|&
name|csrs
index|[
name|n
index|]
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
goto|goto
name|Fail1
goto|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
block|}
return|return
name|HB_Err_Ok
return|;
name|Fail1
label|:
for|for
control|(
name|m
operator|=
literal|0
init|;
name|m
operator|<
name|n
condition|;
name|m
operator|++
control|)
name|Free_ChainSubRuleSet
argument_list|(
operator|&
name|csrs
index|[
name|m
index|]
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|csrs
argument_list|)
expr_stmt|;
name|Fail2
label|:
name|_HB_OPEN_Free_Coverage
argument_list|(
operator|&
name|ccsf1
operator|->
name|Coverage
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_function
DECL|function|Free_ChainContextSubst1
specifier|static
name|void
name|Free_ChainContextSubst1
parameter_list|(
name|HB_ChainContextSubstFormat1
modifier|*
name|ccsf1
parameter_list|)
block|{
name|HB_UShort
name|n
decl_stmt|,
name|count
decl_stmt|;
name|HB_ChainSubRuleSet
modifier|*
name|csrs
decl_stmt|;
if|if
condition|(
name|ccsf1
operator|->
name|ChainSubRuleSet
condition|)
block|{
name|count
operator|=
name|ccsf1
operator|->
name|ChainSubRuleSetCount
expr_stmt|;
name|csrs
operator|=
name|ccsf1
operator|->
name|ChainSubRuleSet
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
name|Free_ChainSubRuleSet
argument_list|(
operator|&
name|csrs
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|csrs
argument_list|)
expr_stmt|;
block|}
name|_HB_OPEN_Free_Coverage
argument_list|(
operator|&
name|ccsf1
operator|->
name|Coverage
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* ChainSubClassRule */
end_comment
begin_function
DECL|function|Load_ChainSubClassRule
specifier|static
name|HB_Error
name|Load_ChainSubClassRule
parameter_list|(
name|HB_ChainContextSubstFormat2
modifier|*
name|ccsf2
parameter_list|,
name|HB_ChainSubClassRule
modifier|*
name|cscr
parameter_list|,
name|HB_Stream
name|stream
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_UShort
name|n
decl_stmt|,
name|count
decl_stmt|;
name|HB_UShort
modifier|*
name|b
decl_stmt|;
name|HB_UShort
modifier|*
name|i
decl_stmt|;
name|HB_UShort
modifier|*
name|l
decl_stmt|;
name|HB_SubstLookupRecord
modifier|*
name|slr
decl_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
return|return
name|error
return|;
name|cscr
operator|->
name|BacktrackGlyphCount
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
if|if
condition|(
name|cscr
operator|->
name|BacktrackGlyphCount
operator|>
name|ccsf2
operator|->
name|MaxBacktrackLength
condition|)
name|ccsf2
operator|->
name|MaxBacktrackLength
operator|=
name|cscr
operator|->
name|BacktrackGlyphCount
expr_stmt|;
name|cscr
operator|->
name|Backtrack
operator|=
name|NULL
expr_stmt|;
name|count
operator|=
name|cscr
operator|->
name|BacktrackGlyphCount
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|cscr
operator|->
name|Backtrack
argument_list|,
name|count
argument_list|,
name|HB_UShort
argument_list|)
condition|)
return|return
name|error
return|;
name|b
operator|=
name|cscr
operator|->
name|Backtrack
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
name|count
operator|*
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail4
goto|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
name|b
index|[
name|n
index|]
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail4
goto|;
name|cscr
operator|->
name|InputGlyphCount
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
if|if
condition|(
name|cscr
operator|->
name|InputGlyphCount
operator|>
name|ccsf2
operator|->
name|MaxInputLength
condition|)
name|ccsf2
operator|->
name|MaxInputLength
operator|=
name|cscr
operator|->
name|InputGlyphCount
expr_stmt|;
name|cscr
operator|->
name|Input
operator|=
name|NULL
expr_stmt|;
name|count
operator|=
name|cscr
operator|->
name|InputGlyphCount
operator|-
literal|1
expr_stmt|;
comment|/* only InputGlyphCount - 1 elements */
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|cscr
operator|->
name|Input
argument_list|,
name|count
argument_list|,
name|HB_UShort
argument_list|)
condition|)
goto|goto
name|Fail4
goto|;
name|i
operator|=
name|cscr
operator|->
name|Input
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
name|count
operator|*
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail3
goto|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
name|i
index|[
name|n
index|]
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail3
goto|;
name|cscr
operator|->
name|LookaheadGlyphCount
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
if|if
condition|(
name|cscr
operator|->
name|LookaheadGlyphCount
operator|>
name|ccsf2
operator|->
name|MaxLookaheadLength
condition|)
name|ccsf2
operator|->
name|MaxLookaheadLength
operator|=
name|cscr
operator|->
name|LookaheadGlyphCount
expr_stmt|;
name|cscr
operator|->
name|Lookahead
operator|=
name|NULL
expr_stmt|;
name|count
operator|=
name|cscr
operator|->
name|LookaheadGlyphCount
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|cscr
operator|->
name|Lookahead
argument_list|,
name|count
argument_list|,
name|HB_UShort
argument_list|)
condition|)
goto|goto
name|Fail3
goto|;
name|l
operator|=
name|cscr
operator|->
name|Lookahead
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
name|count
operator|*
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail2
goto|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
name|l
index|[
name|n
index|]
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail2
goto|;
name|cscr
operator|->
name|SubstCount
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cscr
operator|->
name|SubstLookupRecord
operator|=
name|NULL
expr_stmt|;
name|count
operator|=
name|cscr
operator|->
name|SubstCount
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|cscr
operator|->
name|SubstLookupRecord
argument_list|,
name|count
argument_list|,
name|HB_SubstLookupRecord
argument_list|)
condition|)
goto|goto
name|Fail2
goto|;
name|slr
operator|=
name|cscr
operator|->
name|SubstLookupRecord
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
name|count
operator|*
literal|4L
argument_list|)
condition|)
goto|goto
name|Fail1
goto|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
block|{
name|slr
index|[
name|n
index|]
operator|.
name|SequenceIndex
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|slr
index|[
name|n
index|]
operator|.
name|LookupListIndex
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
block|}
name|FORGET_Frame
argument_list|()
expr_stmt|;
return|return
name|HB_Err_Ok
return|;
name|Fail1
label|:
name|FREE
argument_list|(
name|slr
argument_list|)
expr_stmt|;
name|Fail2
label|:
name|FREE
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|Fail3
label|:
name|FREE
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|Fail4
label|:
name|FREE
argument_list|(
name|b
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_function
DECL|function|Free_ChainSubClassRule
specifier|static
name|void
name|Free_ChainSubClassRule
parameter_list|(
name|HB_ChainSubClassRule
modifier|*
name|cscr
parameter_list|)
block|{
name|FREE
argument_list|(
name|cscr
operator|->
name|SubstLookupRecord
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|cscr
operator|->
name|Lookahead
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|cscr
operator|->
name|Input
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|cscr
operator|->
name|Backtrack
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* SubClassSet */
end_comment
begin_function
DECL|function|Load_ChainSubClassSet
specifier|static
name|HB_Error
name|Load_ChainSubClassSet
parameter_list|(
name|HB_ChainContextSubstFormat2
modifier|*
name|ccsf2
parameter_list|,
name|HB_ChainSubClassSet
modifier|*
name|cscs
parameter_list|,
name|HB_Stream
name|stream
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_UShort
name|n
init|=
literal|0
decl_stmt|,
name|m
decl_stmt|,
name|count
decl_stmt|;
name|HB_UInt
name|cur_offset
decl_stmt|,
name|new_offset
decl_stmt|,
name|base_offset
decl_stmt|;
name|HB_ChainSubClassRule
modifier|*
name|cscr
decl_stmt|;
name|base_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
return|return
name|error
return|;
name|count
operator|=
name|cscs
operator|->
name|ChainSubClassRuleCount
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cscs
operator|->
name|ChainSubClassRule
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|cscs
operator|->
name|ChainSubClassRule
argument_list|,
name|count
argument_list|,
name|HB_ChainSubClassRule
argument_list|)
condition|)
return|return
name|error
return|;
name|cscr
operator|=
name|cscs
operator|->
name|ChainSubClassRule
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail
goto|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
operator|+
name|base_offset
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|Load_ChainSubClassRule
argument_list|(
name|ccsf2
argument_list|,
operator|&
name|cscr
index|[
name|n
index|]
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
goto|goto
name|Fail
goto|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
block|}
return|return
name|HB_Err_Ok
return|;
name|Fail
label|:
for|for
control|(
name|m
operator|=
literal|0
init|;
name|m
operator|<
name|n
condition|;
name|m
operator|++
control|)
name|Free_ChainSubClassRule
argument_list|(
operator|&
name|cscr
index|[
name|m
index|]
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|cscr
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_function
DECL|function|Free_ChainSubClassSet
specifier|static
name|void
name|Free_ChainSubClassSet
parameter_list|(
name|HB_ChainSubClassSet
modifier|*
name|cscs
parameter_list|)
block|{
name|HB_UShort
name|n
decl_stmt|,
name|count
decl_stmt|;
name|HB_ChainSubClassRule
modifier|*
name|cscr
decl_stmt|;
if|if
condition|(
name|cscs
operator|->
name|ChainSubClassRule
condition|)
block|{
name|count
operator|=
name|cscs
operator|->
name|ChainSubClassRuleCount
expr_stmt|;
name|cscr
operator|=
name|cscs
operator|->
name|ChainSubClassRule
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
name|Free_ChainSubClassRule
argument_list|(
operator|&
name|cscr
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|cscr
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/* ChainContextSubstFormat2 */
end_comment
begin_function
DECL|function|Load_ChainContextSubst2
specifier|static
name|HB_Error
name|Load_ChainContextSubst2
parameter_list|(
name|HB_ChainContextSubstFormat2
modifier|*
name|ccsf2
parameter_list|,
name|HB_Stream
name|stream
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_UShort
name|n
init|=
literal|0
decl_stmt|,
name|m
decl_stmt|,
name|count
decl_stmt|;
name|HB_UInt
name|cur_offset
decl_stmt|,
name|new_offset
decl_stmt|,
name|base_offset
decl_stmt|;
name|HB_UInt
name|backtrack_offset
decl_stmt|,
name|input_offset
decl_stmt|,
name|lookahead_offset
decl_stmt|;
name|HB_ChainSubClassSet
modifier|*
name|cscs
decl_stmt|;
name|base_offset
operator|=
name|FILE_Pos
argument_list|()
operator|-
literal|2
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
return|return
name|error
return|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
operator|+
name|base_offset
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|_HB_OPEN_Load_Coverage
argument_list|(
operator|&
name|ccsf2
operator|->
name|Coverage
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
return|return
name|error
return|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|8L
argument_list|)
condition|)
goto|goto
name|Fail5
goto|;
name|backtrack_offset
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|input_offset
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|lookahead_offset
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
comment|/* `ChainSubClassSetCount' is the upper limit for input class values,      thus we read it now to make an additional safety check. No limit      is known or needed for the other two class definitions          */
name|count
operator|=
name|ccsf2
operator|->
name|ChainSubClassSetCount
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|_HB_OPEN_Load_EmptyOrClassDefinition
argument_list|(
operator|&
name|ccsf2
operator|->
name|BacktrackClassDef
argument_list|,
literal|65535
argument_list|,
name|backtrack_offset
argument_list|,
name|base_offset
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
goto|goto
name|Fail5
goto|;
if|if
condition|(
operator|(
name|error
operator|=
name|_HB_OPEN_Load_EmptyOrClassDefinition
argument_list|(
operator|&
name|ccsf2
operator|->
name|InputClassDef
argument_list|,
name|count
argument_list|,
name|input_offset
argument_list|,
name|base_offset
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
goto|goto
name|Fail4
goto|;
if|if
condition|(
operator|(
name|error
operator|=
name|_HB_OPEN_Load_EmptyOrClassDefinition
argument_list|(
operator|&
name|ccsf2
operator|->
name|LookaheadClassDef
argument_list|,
literal|65535
argument_list|,
name|lookahead_offset
argument_list|,
name|base_offset
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
goto|goto
name|Fail3
goto|;
name|ccsf2
operator|->
name|ChainSubClassSet
operator|=
name|NULL
expr_stmt|;
name|ccsf2
operator|->
name|MaxBacktrackLength
operator|=
literal|0
expr_stmt|;
name|ccsf2
operator|->
name|MaxInputLength
operator|=
literal|0
expr_stmt|;
name|ccsf2
operator|->
name|MaxLookaheadLength
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|ccsf2
operator|->
name|ChainSubClassSet
argument_list|,
name|count
argument_list|,
name|HB_ChainSubClassSet
argument_list|)
condition|)
goto|goto
name|Fail2
goto|;
name|cscs
operator|=
name|ccsf2
operator|->
name|ChainSubClassSet
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail1
goto|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
operator|+
name|base_offset
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
if|if
condition|(
name|new_offset
operator|!=
name|base_offset
condition|)
comment|/* not a NULL offset */
block|{
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|Load_ChainSubClassSet
argument_list|(
name|ccsf2
argument_list|,
operator|&
name|cscs
index|[
name|n
index|]
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
goto|goto
name|Fail1
goto|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* we create a ChainSubClassSet table with no entries */
name|ccsf2
operator|->
name|ChainSubClassSet
index|[
name|n
index|]
operator|.
name|ChainSubClassRuleCount
operator|=
literal|0
expr_stmt|;
name|ccsf2
operator|->
name|ChainSubClassSet
index|[
name|n
index|]
operator|.
name|ChainSubClassRule
operator|=
name|NULL
expr_stmt|;
block|}
block|}
return|return
name|HB_Err_Ok
return|;
name|Fail1
label|:
for|for
control|(
name|m
operator|=
literal|0
init|;
name|m
operator|<
name|n
condition|;
name|m
operator|++
control|)
name|Free_ChainSubClassSet
argument_list|(
operator|&
name|cscs
index|[
name|m
index|]
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|cscs
argument_list|)
expr_stmt|;
name|Fail2
label|:
name|_HB_OPEN_Free_ClassDefinition
argument_list|(
operator|&
name|ccsf2
operator|->
name|LookaheadClassDef
argument_list|)
expr_stmt|;
name|Fail3
label|:
name|_HB_OPEN_Free_ClassDefinition
argument_list|(
operator|&
name|ccsf2
operator|->
name|InputClassDef
argument_list|)
expr_stmt|;
name|Fail4
label|:
name|_HB_OPEN_Free_ClassDefinition
argument_list|(
operator|&
name|ccsf2
operator|->
name|BacktrackClassDef
argument_list|)
expr_stmt|;
name|Fail5
label|:
name|_HB_OPEN_Free_Coverage
argument_list|(
operator|&
name|ccsf2
operator|->
name|Coverage
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_function
DECL|function|Free_ChainContextSubst2
specifier|static
name|void
name|Free_ChainContextSubst2
parameter_list|(
name|HB_ChainContextSubstFormat2
modifier|*
name|ccsf2
parameter_list|)
block|{
name|HB_UShort
name|n
decl_stmt|,
name|count
decl_stmt|;
name|HB_ChainSubClassSet
modifier|*
name|cscs
decl_stmt|;
if|if
condition|(
name|ccsf2
operator|->
name|ChainSubClassSet
condition|)
block|{
name|count
operator|=
name|ccsf2
operator|->
name|ChainSubClassSetCount
expr_stmt|;
name|cscs
operator|=
name|ccsf2
operator|->
name|ChainSubClassSet
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
name|Free_ChainSubClassSet
argument_list|(
operator|&
name|cscs
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|cscs
argument_list|)
expr_stmt|;
block|}
name|_HB_OPEN_Free_ClassDefinition
argument_list|(
operator|&
name|ccsf2
operator|->
name|LookaheadClassDef
argument_list|)
expr_stmt|;
name|_HB_OPEN_Free_ClassDefinition
argument_list|(
operator|&
name|ccsf2
operator|->
name|InputClassDef
argument_list|)
expr_stmt|;
name|_HB_OPEN_Free_ClassDefinition
argument_list|(
operator|&
name|ccsf2
operator|->
name|BacktrackClassDef
argument_list|)
expr_stmt|;
name|_HB_OPEN_Free_Coverage
argument_list|(
operator|&
name|ccsf2
operator|->
name|Coverage
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/* ChainContextSubstFormat3 */
end_comment
begin_function
DECL|function|Load_ChainContextSubst3
specifier|static
name|HB_Error
name|Load_ChainContextSubst3
parameter_list|(
name|HB_ChainContextSubstFormat3
modifier|*
name|ccsf3
parameter_list|,
name|HB_Stream
name|stream
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_UShort
name|n
decl_stmt|,
name|nb
init|=
literal|0
decl_stmt|,
name|ni
init|=
literal|0
decl_stmt|,
name|nl
init|=
literal|0
decl_stmt|,
name|m
decl_stmt|,
name|count
decl_stmt|;
name|HB_UShort
name|backtrack_count
decl_stmt|,
name|input_count
decl_stmt|,
name|lookahead_count
decl_stmt|;
name|HB_UInt
name|cur_offset
decl_stmt|,
name|new_offset
decl_stmt|,
name|base_offset
decl_stmt|;
name|HB_Coverage
modifier|*
name|b
decl_stmt|;
name|HB_Coverage
modifier|*
name|i
decl_stmt|;
name|HB_Coverage
modifier|*
name|l
decl_stmt|;
name|HB_SubstLookupRecord
modifier|*
name|slr
decl_stmt|;
name|base_offset
operator|=
name|FILE_Pos
argument_list|()
operator|-
literal|2L
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
return|return
name|error
return|;
name|ccsf3
operator|->
name|BacktrackGlyphCount
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|ccsf3
operator|->
name|BacktrackCoverage
operator|=
name|NULL
expr_stmt|;
name|backtrack_count
operator|=
name|ccsf3
operator|->
name|BacktrackGlyphCount
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|ccsf3
operator|->
name|BacktrackCoverage
argument_list|,
name|backtrack_count
argument_list|,
name|HB_Coverage
argument_list|)
condition|)
return|return
name|error
return|;
name|b
operator|=
name|ccsf3
operator|->
name|BacktrackCoverage
expr_stmt|;
for|for
control|(
name|nb
operator|=
literal|0
init|;
name|nb
operator|<
name|backtrack_count
condition|;
name|nb
operator|++
control|)
block|{
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail4
goto|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
operator|+
name|base_offset
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|_HB_OPEN_Load_Coverage
argument_list|(
operator|&
name|b
index|[
name|nb
index|]
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
goto|goto
name|Fail4
goto|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail4
goto|;
name|ccsf3
operator|->
name|InputGlyphCount
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|ccsf3
operator|->
name|InputCoverage
operator|=
name|NULL
expr_stmt|;
name|input_count
operator|=
name|ccsf3
operator|->
name|InputGlyphCount
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|ccsf3
operator|->
name|InputCoverage
argument_list|,
name|input_count
argument_list|,
name|HB_Coverage
argument_list|)
condition|)
goto|goto
name|Fail4
goto|;
name|i
operator|=
name|ccsf3
operator|->
name|InputCoverage
expr_stmt|;
for|for
control|(
name|ni
operator|=
literal|0
init|;
name|ni
operator|<
name|input_count
condition|;
name|ni
operator|++
control|)
block|{
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail3
goto|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
operator|+
name|base_offset
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|_HB_OPEN_Load_Coverage
argument_list|(
operator|&
name|i
index|[
name|ni
index|]
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
goto|goto
name|Fail3
goto|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail3
goto|;
name|ccsf3
operator|->
name|LookaheadGlyphCount
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|ccsf3
operator|->
name|LookaheadCoverage
operator|=
name|NULL
expr_stmt|;
name|lookahead_count
operator|=
name|ccsf3
operator|->
name|LookaheadGlyphCount
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|ccsf3
operator|->
name|LookaheadCoverage
argument_list|,
name|lookahead_count
argument_list|,
name|HB_Coverage
argument_list|)
condition|)
goto|goto
name|Fail3
goto|;
name|l
operator|=
name|ccsf3
operator|->
name|LookaheadCoverage
expr_stmt|;
for|for
control|(
name|nl
operator|=
literal|0
init|;
name|nl
operator|<
name|lookahead_count
condition|;
name|nl
operator|++
control|)
block|{
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail2
goto|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
operator|+
name|base_offset
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|_HB_OPEN_Load_Coverage
argument_list|(
operator|&
name|l
index|[
name|nl
index|]
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
goto|goto
name|Fail2
goto|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail2
goto|;
name|ccsf3
operator|->
name|SubstCount
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|ccsf3
operator|->
name|SubstLookupRecord
operator|=
name|NULL
expr_stmt|;
name|count
operator|=
name|ccsf3
operator|->
name|SubstCount
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|ccsf3
operator|->
name|SubstLookupRecord
argument_list|,
name|count
argument_list|,
name|HB_SubstLookupRecord
argument_list|)
condition|)
goto|goto
name|Fail2
goto|;
name|slr
operator|=
name|ccsf3
operator|->
name|SubstLookupRecord
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
name|count
operator|*
literal|4L
argument_list|)
condition|)
goto|goto
name|Fail1
goto|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
block|{
name|slr
index|[
name|n
index|]
operator|.
name|SequenceIndex
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|slr
index|[
name|n
index|]
operator|.
name|LookupListIndex
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
block|}
name|FORGET_Frame
argument_list|()
expr_stmt|;
return|return
name|HB_Err_Ok
return|;
name|Fail1
label|:
name|FREE
argument_list|(
name|slr
argument_list|)
expr_stmt|;
name|Fail2
label|:
for|for
control|(
name|m
operator|=
literal|0
init|;
name|m
operator|<
name|nl
condition|;
name|m
operator|++
control|)
name|_HB_OPEN_Free_Coverage
argument_list|(
operator|&
name|l
index|[
name|m
index|]
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|Fail3
label|:
for|for
control|(
name|m
operator|=
literal|0
init|;
name|m
operator|<
name|ni
condition|;
name|m
operator|++
control|)
name|_HB_OPEN_Free_Coverage
argument_list|(
operator|&
name|i
index|[
name|m
index|]
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|Fail4
label|:
for|for
control|(
name|m
operator|=
literal|0
init|;
name|m
operator|<
name|nb
condition|;
name|m
operator|++
control|)
name|_HB_OPEN_Free_Coverage
argument_list|(
operator|&
name|b
index|[
name|m
index|]
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|b
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_function
DECL|function|Free_ChainContextSubst3
specifier|static
name|void
name|Free_ChainContextSubst3
parameter_list|(
name|HB_ChainContextSubstFormat3
modifier|*
name|ccsf3
parameter_list|)
block|{
name|HB_UShort
name|n
decl_stmt|,
name|count
decl_stmt|;
name|HB_Coverage
modifier|*
name|c
decl_stmt|;
name|FREE
argument_list|(
name|ccsf3
operator|->
name|SubstLookupRecord
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccsf3
operator|->
name|LookaheadCoverage
condition|)
block|{
name|count
operator|=
name|ccsf3
operator|->
name|LookaheadGlyphCount
expr_stmt|;
name|c
operator|=
name|ccsf3
operator|->
name|LookaheadCoverage
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
name|_HB_OPEN_Free_Coverage
argument_list|(
operator|&
name|c
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ccsf3
operator|->
name|InputCoverage
condition|)
block|{
name|count
operator|=
name|ccsf3
operator|->
name|InputGlyphCount
expr_stmt|;
name|c
operator|=
name|ccsf3
operator|->
name|InputCoverage
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
name|_HB_OPEN_Free_Coverage
argument_list|(
operator|&
name|c
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ccsf3
operator|->
name|BacktrackCoverage
condition|)
block|{
name|count
operator|=
name|ccsf3
operator|->
name|BacktrackGlyphCount
expr_stmt|;
name|c
operator|=
name|ccsf3
operator|->
name|BacktrackCoverage
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
name|_HB_OPEN_Free_Coverage
argument_list|(
operator|&
name|c
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/* ChainContextSubst */
end_comment
begin_function
DECL|function|Load_ChainContextSubst
specifier|static
name|HB_Error
name|Load_ChainContextSubst
parameter_list|(
name|HB_GSUB_SubTable
modifier|*
name|st
parameter_list|,
name|HB_Stream
name|stream
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_ChainContextSubst
modifier|*
name|ccs
init|=
operator|&
name|st
operator|->
name|chain
decl_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
return|return
name|error
return|;
name|ccs
operator|->
name|SubstFormat
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|ccs
operator|->
name|SubstFormat
condition|)
block|{
case|case
literal|1
case|:
return|return
name|Load_ChainContextSubst1
argument_list|(
operator|&
name|ccs
operator|->
name|ccsf
operator|.
name|ccsf1
argument_list|,
name|stream
argument_list|)
return|;
case|case
literal|2
case|:
return|return
name|Load_ChainContextSubst2
argument_list|(
operator|&
name|ccs
operator|->
name|ccsf
operator|.
name|ccsf2
argument_list|,
name|stream
argument_list|)
return|;
case|case
literal|3
case|:
return|return
name|Load_ChainContextSubst3
argument_list|(
operator|&
name|ccs
operator|->
name|ccsf
operator|.
name|ccsf3
argument_list|,
name|stream
argument_list|)
return|;
default|default:
return|return
name|ERR
argument_list|(
name|HB_Err_Invalid_SubTable_Format
argument_list|)
return|;
block|}
return|return
name|HB_Err_Ok
return|;
comment|/* never reached */
block|}
end_function
begin_function
DECL|function|Free_ChainContextSubst
specifier|static
name|void
name|Free_ChainContextSubst
parameter_list|(
name|HB_GSUB_SubTable
modifier|*
name|st
parameter_list|)
block|{
name|HB_ChainContextSubst
modifier|*
name|ccs
init|=
operator|&
name|st
operator|->
name|chain
decl_stmt|;
switch|switch
condition|(
name|ccs
operator|->
name|SubstFormat
condition|)
block|{
case|case
literal|1
case|:
name|Free_ChainContextSubst1
argument_list|(
operator|&
name|ccs
operator|->
name|ccsf
operator|.
name|ccsf1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|Free_ChainContextSubst2
argument_list|(
operator|&
name|ccs
operator|->
name|ccsf
operator|.
name|ccsf2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|Free_ChainContextSubst3
argument_list|(
operator|&
name|ccs
operator|->
name|ccsf
operator|.
name|ccsf3
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function
begin_function
DECL|function|Lookup_ChainContextSubst1
specifier|static
name|HB_Error
name|Lookup_ChainContextSubst1
parameter_list|(
name|HB_GSUBHeader
modifier|*
name|gsub
parameter_list|,
name|HB_ChainContextSubstFormat1
modifier|*
name|ccsf1
parameter_list|,
name|HB_Buffer
name|buffer
parameter_list|,
name|HB_UShort
name|flags
parameter_list|,
name|HB_UShort
name|context_length
parameter_list|,
name|int
name|nesting_level
parameter_list|)
block|{
name|HB_UShort
name|index
decl_stmt|,
name|property
decl_stmt|;
name|HB_UShort
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|num_csr
decl_stmt|;
name|HB_UShort
name|bgc
decl_stmt|,
name|igc
decl_stmt|,
name|lgc
decl_stmt|;
name|HB_Error
name|error
decl_stmt|;
name|HB_ChainSubRule
modifier|*
name|csr
decl_stmt|;
name|HB_ChainSubRule
name|curr_csr
decl_stmt|;
name|HB_GDEFHeader
modifier|*
name|gdef
decl_stmt|;
name|gdef
operator|=
name|gsub
operator|->
name|gdef
expr_stmt|;
if|if
condition|(
name|CHECK_Property
argument_list|(
name|gdef
argument_list|,
name|IN_CURITEM
argument_list|()
argument_list|,
name|flags
argument_list|,
operator|&
name|property
argument_list|)
condition|)
return|return
name|error
return|;
name|error
operator|=
name|_HB_OPEN_Coverage_Index
argument_list|(
operator|&
name|ccsf1
operator|->
name|Coverage
argument_list|,
name|IN_CURGLYPH
argument_list|()
argument_list|,
operator|&
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|csr
operator|=
name|ccsf1
operator|->
name|ChainSubRuleSet
index|[
name|index
index|]
operator|.
name|ChainSubRule
expr_stmt|;
name|num_csr
operator|=
name|ccsf1
operator|->
name|ChainSubRuleSet
index|[
name|index
index|]
operator|.
name|ChainSubRuleCount
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|num_csr
condition|;
name|k
operator|++
control|)
block|{
name|curr_csr
operator|=
name|csr
index|[
name|k
index|]
expr_stmt|;
name|bgc
operator|=
name|curr_csr
operator|.
name|BacktrackGlyphCount
expr_stmt|;
name|igc
operator|=
name|curr_csr
operator|.
name|InputGlyphCount
expr_stmt|;
name|lgc
operator|=
name|curr_csr
operator|.
name|LookaheadGlyphCount
expr_stmt|;
if|if
condition|(
name|context_length
operator|!=
literal|0xFFFF
operator|&&
name|context_length
operator|<
name|igc
condition|)
goto|goto
name|next_chainsubrule
goto|;
comment|/* check whether context is too long; it is a first guess only */
if|if
condition|(
name|bgc
operator|>
name|buffer
operator|->
name|out_pos
operator|||
name|buffer
operator|->
name|in_pos
operator|+
name|igc
operator|+
name|lgc
operator|>
name|buffer
operator|->
name|in_length
condition|)
goto|goto
name|next_chainsubrule
goto|;
if|if
condition|(
name|bgc
condition|)
block|{
comment|/* since we don't know in advance the number of glyphs to inspect, 	 we search backwards for matches in the backtrack glyph array    */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
name|buffer
operator|->
name|out_pos
operator|-
literal|1
init|;
name|i
operator|<
name|bgc
condition|;
name|i
operator|++
operator|,
name|j
operator|--
control|)
block|{
while|while
condition|(
name|CHECK_Property
argument_list|(
name|gdef
argument_list|,
name|OUT_ITEM
argument_list|(
name|j
argument_list|)
argument_list|,
name|flags
argument_list|,
operator|&
name|property
argument_list|)
condition|)
block|{
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|HB_Err_Not_Covered
condition|)
return|return
name|error
return|;
if|if
condition|(
name|j
operator|+
literal|1
operator|==
name|bgc
operator|-
name|i
condition|)
goto|goto
name|next_chainsubrule
goto|;
name|j
operator|--
expr_stmt|;
block|}
comment|/* In OpenType 1.3, it is undefined whether the offsets of 	   backtrack glyphs is in logical order or not.  Version 1.4 	   will clarify this:  	     Logical order -      a  b  c  d  e  f  g  h  i  j 					      i 	     Input offsets -                  0  1 	     Backtrack offsets -  3  2  1  0 	     Lookahead offsets -                    0  1  2  3           */
if|if
condition|(
name|OUT_GLYPH
argument_list|(
name|j
argument_list|)
operator|!=
name|curr_csr
operator|.
name|Backtrack
index|[
name|i
index|]
condition|)
goto|goto
name|next_chainsubrule
goto|;
block|}
block|}
comment|/* Start at 1 because [0] is implied */
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|j
operator|=
name|buffer
operator|->
name|in_pos
operator|+
literal|1
init|;
name|i
operator|<
name|igc
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
while|while
condition|(
name|CHECK_Property
argument_list|(
name|gdef
argument_list|,
name|IN_ITEM
argument_list|(
name|j
argument_list|)
argument_list|,
name|flags
argument_list|,
operator|&
name|property
argument_list|)
condition|)
block|{
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|HB_Err_Not_Covered
condition|)
return|return
name|error
return|;
if|if
condition|(
name|j
operator|+
name|igc
operator|-
name|i
operator|+
name|lgc
operator|==
operator|(
name|HB_Int
operator|)
name|buffer
operator|->
name|in_length
condition|)
goto|goto
name|next_chainsubrule
goto|;
name|j
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|IN_GLYPH
argument_list|(
name|j
argument_list|)
operator|!=
name|curr_csr
operator|.
name|Input
index|[
name|i
operator|-
literal|1
index|]
condition|)
goto|goto
name|next_chainsubrule
goto|;
block|}
comment|/* we are starting to check for lookahead glyphs right after the        last context glyph                                            */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lgc
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
while|while
condition|(
name|CHECK_Property
argument_list|(
name|gdef
argument_list|,
name|IN_ITEM
argument_list|(
name|j
argument_list|)
argument_list|,
name|flags
argument_list|,
operator|&
name|property
argument_list|)
condition|)
block|{
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|HB_Err_Not_Covered
condition|)
return|return
name|error
return|;
if|if
condition|(
name|j
operator|+
name|lgc
operator|-
name|i
operator|==
operator|(
name|HB_Int
operator|)
name|buffer
operator|->
name|in_length
condition|)
goto|goto
name|next_chainsubrule
goto|;
name|j
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|IN_GLYPH
argument_list|(
name|j
argument_list|)
operator|!=
name|curr_csr
operator|.
name|Lookahead
index|[
name|i
index|]
condition|)
goto|goto
name|next_chainsubrule
goto|;
block|}
return|return
name|Do_ContextSubst
argument_list|(
name|gsub
argument_list|,
name|igc
argument_list|,
name|curr_csr
operator|.
name|SubstCount
argument_list|,
name|curr_csr
operator|.
name|SubstLookupRecord
argument_list|,
name|buffer
argument_list|,
name|nesting_level
argument_list|)
return|;
name|next_chainsubrule
label|:
empty_stmt|;
block|}
return|return
name|HB_Err_Not_Covered
return|;
block|}
end_function
begin_function
DECL|function|Lookup_ChainContextSubst2
specifier|static
name|HB_Error
name|Lookup_ChainContextSubst2
parameter_list|(
name|HB_GSUBHeader
modifier|*
name|gsub
parameter_list|,
name|HB_ChainContextSubstFormat2
modifier|*
name|ccsf2
parameter_list|,
name|HB_Buffer
name|buffer
parameter_list|,
name|HB_UShort
name|flags
parameter_list|,
name|HB_UShort
name|context_length
parameter_list|,
name|int
name|nesting_level
parameter_list|)
block|{
name|HB_UShort
name|index
decl_stmt|,
name|property
decl_stmt|;
name|HB_Error
name|error
decl_stmt|;
name|HB_UShort
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|HB_UShort
name|bgc
decl_stmt|,
name|igc
decl_stmt|,
name|lgc
decl_stmt|;
name|HB_UShort
name|known_backtrack_classes
decl_stmt|,
name|known_input_classes
decl_stmt|,
name|known_lookahead_classes
decl_stmt|;
name|HB_UShort
modifier|*
name|backtrack_classes
decl_stmt|;
name|HB_UShort
modifier|*
name|input_classes
decl_stmt|;
name|HB_UShort
modifier|*
name|lookahead_classes
decl_stmt|;
name|HB_UShort
modifier|*
name|bc
decl_stmt|;
name|HB_UShort
modifier|*
name|ic
decl_stmt|;
name|HB_UShort
modifier|*
name|lc
decl_stmt|;
name|HB_ChainSubClassSet
modifier|*
name|cscs
decl_stmt|;
name|HB_ChainSubClassRule
name|ccsr
decl_stmt|;
name|HB_GDEFHeader
modifier|*
name|gdef
decl_stmt|;
name|gdef
operator|=
name|gsub
operator|->
name|gdef
expr_stmt|;
if|if
condition|(
name|CHECK_Property
argument_list|(
name|gdef
argument_list|,
name|IN_CURITEM
argument_list|()
argument_list|,
name|flags
argument_list|,
operator|&
name|property
argument_list|)
condition|)
return|return
name|error
return|;
comment|/* Note: The coverage table in format 2 doesn't give an index into 	   anything.  It just lets us know whether or not we need to 	   do any lookup at all.                                     */
name|error
operator|=
name|_HB_OPEN_Coverage_Index
argument_list|(
operator|&
name|ccsf2
operator|->
name|Coverage
argument_list|,
name|IN_CURGLYPH
argument_list|()
argument_list|,
operator|&
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|backtrack_classes
argument_list|,
name|ccsf2
operator|->
name|MaxBacktrackLength
argument_list|,
name|HB_UShort
argument_list|)
condition|)
return|return
name|error
return|;
name|known_backtrack_classes
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ccsf2
operator|->
name|MaxInputLength
operator|<
literal|1
condition|)
return|return
name|HB_Err_Not_Covered
return|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|input_classes
argument_list|,
name|ccsf2
operator|->
name|MaxInputLength
argument_list|,
name|HB_UShort
argument_list|)
condition|)
goto|goto
name|End3
goto|;
name|known_input_classes
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|lookahead_classes
argument_list|,
name|ccsf2
operator|->
name|MaxLookaheadLength
argument_list|,
name|HB_UShort
argument_list|)
condition|)
goto|goto
name|End2
goto|;
name|known_lookahead_classes
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|_HB_OPEN_Get_Class
argument_list|(
operator|&
name|ccsf2
operator|->
name|InputClassDef
argument_list|,
name|IN_CURGLYPH
argument_list|()
argument_list|,
operator|&
name|input_classes
index|[
literal|0
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|HB_Err_Not_Covered
condition|)
goto|goto
name|End1
goto|;
name|cscs
operator|=
operator|&
name|ccsf2
operator|->
name|ChainSubClassSet
index|[
name|input_classes
index|[
literal|0
index|]
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|cscs
condition|)
block|{
name|error
operator|=
name|ERR
argument_list|(
name|HB_Err_Invalid_SubTable
argument_list|)
expr_stmt|;
goto|goto
name|End1
goto|;
block|}
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|cscs
operator|->
name|ChainSubClassRuleCount
condition|;
name|k
operator|++
control|)
block|{
name|ccsr
operator|=
name|cscs
operator|->
name|ChainSubClassRule
index|[
name|k
index|]
expr_stmt|;
name|bgc
operator|=
name|ccsr
operator|.
name|BacktrackGlyphCount
expr_stmt|;
name|igc
operator|=
name|ccsr
operator|.
name|InputGlyphCount
expr_stmt|;
name|lgc
operator|=
name|ccsr
operator|.
name|LookaheadGlyphCount
expr_stmt|;
if|if
condition|(
name|context_length
operator|!=
literal|0xFFFF
operator|&&
name|context_length
operator|<
name|igc
condition|)
goto|goto
name|next_chainsubclassrule
goto|;
comment|/* check whether context is too long; it is a first guess only */
if|if
condition|(
name|bgc
operator|>
name|buffer
operator|->
name|out_pos
operator|||
name|buffer
operator|->
name|in_pos
operator|+
name|igc
operator|+
name|lgc
operator|>
name|buffer
operator|->
name|in_length
condition|)
goto|goto
name|next_chainsubclassrule
goto|;
if|if
condition|(
name|bgc
condition|)
block|{
comment|/* Since we don't know in advance the number of glyphs to inspect, 	 we search backwards for matches in the backtrack glyph array. 	 Note that `known_backtrack_classes' starts at index 0.         */
name|bc
operator|=
name|ccsr
operator|.
name|Backtrack
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
name|buffer
operator|->
name|out_pos
operator|-
literal|1
init|;
name|i
operator|<
name|bgc
condition|;
name|i
operator|++
operator|,
name|j
operator|--
control|)
block|{
while|while
condition|(
name|CHECK_Property
argument_list|(
name|gdef
argument_list|,
name|OUT_ITEM
argument_list|(
name|j
argument_list|)
argument_list|,
name|flags
argument_list|,
operator|&
name|property
argument_list|)
condition|)
block|{
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|HB_Err_Not_Covered
condition|)
goto|goto
name|End1
goto|;
if|if
condition|(
name|j
operator|+
literal|1
operator|==
name|bgc
operator|-
name|i
condition|)
goto|goto
name|next_chainsubclassrule
goto|;
name|j
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>=
name|known_backtrack_classes
condition|)
block|{
comment|/* Keeps us from having to do this for each rule */
name|error
operator|=
name|_HB_OPEN_Get_Class
argument_list|(
operator|&
name|ccsf2
operator|->
name|BacktrackClassDef
argument_list|,
name|OUT_GLYPH
argument_list|(
name|j
argument_list|)
argument_list|,
operator|&
name|backtrack_classes
index|[
name|i
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|HB_Err_Not_Covered
condition|)
goto|goto
name|End1
goto|;
name|known_backtrack_classes
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|bc
index|[
name|i
index|]
operator|!=
name|backtrack_classes
index|[
name|i
index|]
condition|)
goto|goto
name|next_chainsubclassrule
goto|;
block|}
block|}
name|ic
operator|=
name|ccsr
operator|.
name|Input
expr_stmt|;
comment|/* Start at 1 because [0] is implied */
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|j
operator|=
name|buffer
operator|->
name|in_pos
operator|+
literal|1
init|;
name|i
operator|<
name|igc
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
while|while
condition|(
name|CHECK_Property
argument_list|(
name|gdef
argument_list|,
name|IN_ITEM
argument_list|(
name|j
argument_list|)
argument_list|,
name|flags
argument_list|,
operator|&
name|property
argument_list|)
condition|)
block|{
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|HB_Err_Not_Covered
condition|)
goto|goto
name|End1
goto|;
if|if
condition|(
name|j
operator|+
name|igc
operator|-
name|i
operator|+
name|lgc
operator|==
operator|(
name|HB_Int
operator|)
name|buffer
operator|->
name|in_length
condition|)
goto|goto
name|next_chainsubclassrule
goto|;
name|j
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>=
name|known_input_classes
condition|)
block|{
name|error
operator|=
name|_HB_OPEN_Get_Class
argument_list|(
operator|&
name|ccsf2
operator|->
name|InputClassDef
argument_list|,
name|IN_GLYPH
argument_list|(
name|j
argument_list|)
argument_list|,
operator|&
name|input_classes
index|[
name|i
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|HB_Err_Not_Covered
condition|)
goto|goto
name|End1
goto|;
name|known_input_classes
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|ic
index|[
name|i
operator|-
literal|1
index|]
operator|!=
name|input_classes
index|[
name|i
index|]
condition|)
goto|goto
name|next_chainsubclassrule
goto|;
block|}
comment|/* we are starting to check for lookahead glyphs right after the        last context glyph                                            */
name|lc
operator|=
name|ccsr
operator|.
name|Lookahead
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lgc
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
while|while
condition|(
name|CHECK_Property
argument_list|(
name|gdef
argument_list|,
name|IN_ITEM
argument_list|(
name|j
argument_list|)
argument_list|,
name|flags
argument_list|,
operator|&
name|property
argument_list|)
condition|)
block|{
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|HB_Err_Not_Covered
condition|)
goto|goto
name|End1
goto|;
if|if
condition|(
name|j
operator|+
name|lgc
operator|-
name|i
operator|==
operator|(
name|HB_Int
operator|)
name|buffer
operator|->
name|in_length
condition|)
goto|goto
name|next_chainsubclassrule
goto|;
name|j
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>=
name|known_lookahead_classes
condition|)
block|{
name|error
operator|=
name|_HB_OPEN_Get_Class
argument_list|(
operator|&
name|ccsf2
operator|->
name|LookaheadClassDef
argument_list|,
name|IN_GLYPH
argument_list|(
name|j
argument_list|)
argument_list|,
operator|&
name|lookahead_classes
index|[
name|i
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|HB_Err_Not_Covered
condition|)
goto|goto
name|End1
goto|;
name|known_lookahead_classes
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|lc
index|[
name|i
index|]
operator|!=
name|lookahead_classes
index|[
name|i
index|]
condition|)
goto|goto
name|next_chainsubclassrule
goto|;
block|}
name|error
operator|=
name|Do_ContextSubst
argument_list|(
name|gsub
argument_list|,
name|igc
argument_list|,
name|ccsr
operator|.
name|SubstCount
argument_list|,
name|ccsr
operator|.
name|SubstLookupRecord
argument_list|,
name|buffer
argument_list|,
name|nesting_level
argument_list|)
expr_stmt|;
goto|goto
name|End1
goto|;
name|next_chainsubclassrule
label|:
empty_stmt|;
block|}
name|error
operator|=
name|HB_Err_Not_Covered
expr_stmt|;
name|End1
label|:
name|FREE
argument_list|(
name|lookahead_classes
argument_list|)
expr_stmt|;
name|End2
label|:
name|FREE
argument_list|(
name|input_classes
argument_list|)
expr_stmt|;
name|End3
label|:
name|FREE
argument_list|(
name|backtrack_classes
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_function
DECL|function|Lookup_ChainContextSubst3
specifier|static
name|HB_Error
name|Lookup_ChainContextSubst3
parameter_list|(
name|HB_GSUBHeader
modifier|*
name|gsub
parameter_list|,
name|HB_ChainContextSubstFormat3
modifier|*
name|ccsf3
parameter_list|,
name|HB_Buffer
name|buffer
parameter_list|,
name|HB_UShort
name|flags
parameter_list|,
name|HB_UShort
name|context_length
parameter_list|,
name|int
name|nesting_level
parameter_list|)
block|{
name|HB_UShort
name|index
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|property
decl_stmt|;
name|HB_UShort
name|bgc
decl_stmt|,
name|igc
decl_stmt|,
name|lgc
decl_stmt|;
name|HB_Error
name|error
decl_stmt|;
name|HB_Coverage
modifier|*
name|bc
decl_stmt|;
name|HB_Coverage
modifier|*
name|ic
decl_stmt|;
name|HB_Coverage
modifier|*
name|lc
decl_stmt|;
name|HB_GDEFHeader
modifier|*
name|gdef
decl_stmt|;
name|gdef
operator|=
name|gsub
operator|->
name|gdef
expr_stmt|;
if|if
condition|(
name|CHECK_Property
argument_list|(
name|gdef
argument_list|,
name|IN_CURITEM
argument_list|()
argument_list|,
name|flags
argument_list|,
operator|&
name|property
argument_list|)
condition|)
return|return
name|error
return|;
name|bgc
operator|=
name|ccsf3
operator|->
name|BacktrackGlyphCount
expr_stmt|;
name|igc
operator|=
name|ccsf3
operator|->
name|InputGlyphCount
expr_stmt|;
name|lgc
operator|=
name|ccsf3
operator|->
name|LookaheadGlyphCount
expr_stmt|;
if|if
condition|(
name|context_length
operator|!=
literal|0xFFFF
operator|&&
name|context_length
operator|<
name|igc
condition|)
return|return
name|HB_Err_Not_Covered
return|;
comment|/* check whether context is too long; it is a first guess only */
if|if
condition|(
name|bgc
operator|>
name|buffer
operator|->
name|out_pos
operator|||
name|buffer
operator|->
name|in_pos
operator|+
name|igc
operator|+
name|lgc
operator|>
name|buffer
operator|->
name|in_length
condition|)
return|return
name|HB_Err_Not_Covered
return|;
if|if
condition|(
name|bgc
condition|)
block|{
comment|/* Since we don't know in advance the number of glyphs to inspect,        we search backwards for matches in the backtrack glyph array    */
name|bc
operator|=
name|ccsf3
operator|->
name|BacktrackCoverage
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
name|buffer
operator|->
name|out_pos
operator|-
literal|1
init|;
name|i
operator|<
name|bgc
condition|;
name|i
operator|++
operator|,
name|j
operator|--
control|)
block|{
while|while
condition|(
name|CHECK_Property
argument_list|(
name|gdef
argument_list|,
name|OUT_ITEM
argument_list|(
name|j
argument_list|)
argument_list|,
name|flags
argument_list|,
operator|&
name|property
argument_list|)
condition|)
block|{
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|HB_Err_Not_Covered
condition|)
return|return
name|error
return|;
if|if
condition|(
name|j
operator|+
literal|1
operator|==
name|bgc
operator|-
name|i
condition|)
return|return
name|HB_Err_Not_Covered
return|;
name|j
operator|--
expr_stmt|;
block|}
name|error
operator|=
name|_HB_OPEN_Coverage_Index
argument_list|(
operator|&
name|bc
index|[
name|i
index|]
argument_list|,
name|OUT_GLYPH
argument_list|(
name|j
argument_list|)
argument_list|,
operator|&
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
block|}
block|}
name|ic
operator|=
name|ccsf3
operator|->
name|InputCoverage
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
name|buffer
operator|->
name|in_pos
init|;
name|i
operator|<
name|igc
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
comment|/* We already called CHECK_Property for IN_GLYPH( buffer->in_pos ) */
while|while
condition|(
name|j
operator|>
name|buffer
operator|->
name|in_pos
operator|&&
name|CHECK_Property
argument_list|(
name|gdef
argument_list|,
name|IN_ITEM
argument_list|(
name|j
argument_list|)
argument_list|,
name|flags
argument_list|,
operator|&
name|property
argument_list|)
condition|)
block|{
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|HB_Err_Not_Covered
condition|)
return|return
name|error
return|;
if|if
condition|(
name|j
operator|+
name|igc
operator|-
name|i
operator|+
name|lgc
operator|==
operator|(
name|HB_Int
operator|)
name|buffer
operator|->
name|in_length
condition|)
return|return
name|HB_Err_Not_Covered
return|;
name|j
operator|++
expr_stmt|;
block|}
name|error
operator|=
name|_HB_OPEN_Coverage_Index
argument_list|(
operator|&
name|ic
index|[
name|i
index|]
argument_list|,
name|IN_GLYPH
argument_list|(
name|j
argument_list|)
argument_list|,
operator|&
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
block|}
comment|/* we are starting for lookahead glyphs right after the last context      glyph                                                             */
name|lc
operator|=
name|ccsf3
operator|->
name|LookaheadCoverage
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lgc
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
while|while
condition|(
name|CHECK_Property
argument_list|(
name|gdef
argument_list|,
name|IN_ITEM
argument_list|(
name|j
argument_list|)
argument_list|,
name|flags
argument_list|,
operator|&
name|property
argument_list|)
condition|)
block|{
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|HB_Err_Not_Covered
condition|)
return|return
name|error
return|;
if|if
condition|(
name|j
operator|+
name|lgc
operator|-
name|i
operator|==
operator|(
name|HB_Int
operator|)
name|buffer
operator|->
name|in_length
condition|)
return|return
name|HB_Err_Not_Covered
return|;
name|j
operator|++
expr_stmt|;
block|}
name|error
operator|=
name|_HB_OPEN_Coverage_Index
argument_list|(
operator|&
name|lc
index|[
name|i
index|]
argument_list|,
name|IN_GLYPH
argument_list|(
name|j
argument_list|)
argument_list|,
operator|&
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
block|}
return|return
name|Do_ContextSubst
argument_list|(
name|gsub
argument_list|,
name|igc
argument_list|,
name|ccsf3
operator|->
name|SubstCount
argument_list|,
name|ccsf3
operator|->
name|SubstLookupRecord
argument_list|,
name|buffer
argument_list|,
name|nesting_level
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|Lookup_ChainContextSubst
specifier|static
name|HB_Error
name|Lookup_ChainContextSubst
parameter_list|(
name|HB_GSUBHeader
modifier|*
name|gsub
parameter_list|,
name|HB_GSUB_SubTable
modifier|*
name|st
parameter_list|,
name|HB_Buffer
name|buffer
parameter_list|,
name|HB_UShort
name|flags
parameter_list|,
name|HB_UShort
name|context_length
parameter_list|,
name|int
name|nesting_level
parameter_list|)
block|{
name|HB_ChainContextSubst
modifier|*
name|ccs
init|=
operator|&
name|st
operator|->
name|chain
decl_stmt|;
switch|switch
condition|(
name|ccs
operator|->
name|SubstFormat
condition|)
block|{
case|case
literal|1
case|:
return|return
name|Lookup_ChainContextSubst1
argument_list|(
name|gsub
argument_list|,
operator|&
name|ccs
operator|->
name|ccsf
operator|.
name|ccsf1
argument_list|,
name|buffer
argument_list|,
name|flags
argument_list|,
name|context_length
argument_list|,
name|nesting_level
argument_list|)
return|;
case|case
literal|2
case|:
return|return
name|Lookup_ChainContextSubst2
argument_list|(
name|gsub
argument_list|,
operator|&
name|ccs
operator|->
name|ccsf
operator|.
name|ccsf2
argument_list|,
name|buffer
argument_list|,
name|flags
argument_list|,
name|context_length
argument_list|,
name|nesting_level
argument_list|)
return|;
case|case
literal|3
case|:
return|return
name|Lookup_ChainContextSubst3
argument_list|(
name|gsub
argument_list|,
operator|&
name|ccs
operator|->
name|ccsf
operator|.
name|ccsf3
argument_list|,
name|buffer
argument_list|,
name|flags
argument_list|,
name|context_length
argument_list|,
name|nesting_level
argument_list|)
return|;
default|default:
return|return
name|ERR
argument_list|(
name|HB_Err_Invalid_SubTable_Format
argument_list|)
return|;
block|}
block|}
end_function
begin_function
DECL|function|Load_ReverseChainContextSubst
specifier|static
name|HB_Error
name|Load_ReverseChainContextSubst
parameter_list|(
name|HB_GSUB_SubTable
modifier|*
name|st
parameter_list|,
name|HB_Stream
name|stream
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|;
name|HB_ReverseChainContextSubst
modifier|*
name|rccs
init|=
operator|&
name|st
operator|->
name|reverse
decl_stmt|;
name|HB_UShort
name|m
decl_stmt|,
name|count
decl_stmt|;
name|HB_UShort
name|nb
init|=
literal|0
decl_stmt|,
name|nl
init|=
literal|0
decl_stmt|,
name|n
decl_stmt|;
name|HB_UShort
name|backtrack_count
decl_stmt|,
name|lookahead_count
decl_stmt|;
name|HB_UInt
name|cur_offset
decl_stmt|,
name|new_offset
decl_stmt|,
name|base_offset
decl_stmt|;
name|HB_Coverage
modifier|*
name|b
decl_stmt|;
name|HB_Coverage
modifier|*
name|l
decl_stmt|;
name|HB_UShort
modifier|*
name|sub
decl_stmt|;
name|base_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
return|return
name|error
return|;
name|rccs
operator|->
name|SubstFormat
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
if|if
condition|(
name|rccs
operator|->
name|SubstFormat
operator|!=
literal|1
condition|)
return|return
name|ERR
argument_list|(
name|HB_Err_Invalid_SubTable_Format
argument_list|)
return|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
return|return
name|error
return|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
operator|+
name|base_offset
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|_HB_OPEN_Load_Coverage
argument_list|(
operator|&
name|rccs
operator|->
name|Coverage
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
return|return
name|error
return|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail4
goto|;
name|rccs
operator|->
name|BacktrackGlyphCount
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|rccs
operator|->
name|BacktrackCoverage
operator|=
name|NULL
expr_stmt|;
name|backtrack_count
operator|=
name|rccs
operator|->
name|BacktrackGlyphCount
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|rccs
operator|->
name|BacktrackCoverage
argument_list|,
name|backtrack_count
argument_list|,
name|HB_Coverage
argument_list|)
condition|)
goto|goto
name|Fail4
goto|;
name|b
operator|=
name|rccs
operator|->
name|BacktrackCoverage
expr_stmt|;
for|for
control|(
name|nb
operator|=
literal|0
init|;
name|nb
operator|<
name|backtrack_count
condition|;
name|nb
operator|++
control|)
block|{
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail3
goto|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
operator|+
name|base_offset
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|_HB_OPEN_Load_Coverage
argument_list|(
operator|&
name|b
index|[
name|nb
index|]
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
goto|goto
name|Fail3
goto|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail3
goto|;
name|rccs
operator|->
name|LookaheadGlyphCount
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|rccs
operator|->
name|LookaheadCoverage
operator|=
name|NULL
expr_stmt|;
name|lookahead_count
operator|=
name|rccs
operator|->
name|LookaheadGlyphCount
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|rccs
operator|->
name|LookaheadCoverage
argument_list|,
name|lookahead_count
argument_list|,
name|HB_Coverage
argument_list|)
condition|)
goto|goto
name|Fail3
goto|;
name|l
operator|=
name|rccs
operator|->
name|LookaheadCoverage
expr_stmt|;
for|for
control|(
name|nl
operator|=
literal|0
init|;
name|nl
operator|<
name|lookahead_count
condition|;
name|nl
operator|++
control|)
block|{
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail2
goto|;
name|new_offset
operator|=
name|GET_UShort
argument_list|()
operator|+
name|base_offset
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|cur_offset
operator|=
name|FILE_Pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|FILE_Seek
argument_list|(
name|new_offset
argument_list|)
operator|||
operator|(
name|error
operator|=
name|_HB_OPEN_Load_Coverage
argument_list|(
operator|&
name|l
index|[
name|nl
index|]
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
name|HB_Err_Ok
condition|)
goto|goto
name|Fail2
goto|;
operator|(
name|void
operator|)
name|FILE_Seek
argument_list|(
name|cur_offset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ACCESS_Frame
argument_list|(
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail2
goto|;
name|rccs
operator|->
name|GlyphCount
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
name|rccs
operator|->
name|Substitute
operator|=
name|NULL
expr_stmt|;
name|count
operator|=
name|rccs
operator|->
name|GlyphCount
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|rccs
operator|->
name|Substitute
argument_list|,
name|count
argument_list|,
name|HB_UShort
argument_list|)
condition|)
goto|goto
name|Fail2
goto|;
name|sub
operator|=
name|rccs
operator|->
name|Substitute
expr_stmt|;
if|if
condition|(
name|ACCESS_Frame
argument_list|(
name|count
operator|*
literal|2L
argument_list|)
condition|)
goto|goto
name|Fail1
goto|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
name|sub
index|[
name|n
index|]
operator|=
name|GET_UShort
argument_list|()
expr_stmt|;
name|FORGET_Frame
argument_list|()
expr_stmt|;
return|return
name|HB_Err_Ok
return|;
name|Fail1
label|:
name|FREE
argument_list|(
name|sub
argument_list|)
expr_stmt|;
name|Fail2
label|:
for|for
control|(
name|m
operator|=
literal|0
init|;
name|m
operator|<
name|nl
condition|;
name|m
operator|++
control|)
name|_HB_OPEN_Free_Coverage
argument_list|(
operator|&
name|l
index|[
name|m
index|]
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|Fail3
label|:
for|for
control|(
name|m
operator|=
literal|0
init|;
name|m
operator|<
name|nb
condition|;
name|m
operator|++
control|)
name|_HB_OPEN_Free_Coverage
argument_list|(
operator|&
name|b
index|[
name|m
index|]
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|Fail4
label|:
name|_HB_OPEN_Free_Coverage
argument_list|(
operator|&
name|rccs
operator|->
name|Coverage
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_function
DECL|function|Free_ReverseChainContextSubst
specifier|static
name|void
name|Free_ReverseChainContextSubst
parameter_list|(
name|HB_GSUB_SubTable
modifier|*
name|st
parameter_list|)
block|{
name|HB_UShort
name|n
decl_stmt|,
name|count
decl_stmt|;
name|HB_ReverseChainContextSubst
modifier|*
name|rccs
init|=
operator|&
name|st
operator|->
name|reverse
decl_stmt|;
name|HB_Coverage
modifier|*
name|c
decl_stmt|;
name|_HB_OPEN_Free_Coverage
argument_list|(
operator|&
name|rccs
operator|->
name|Coverage
argument_list|)
expr_stmt|;
if|if
condition|(
name|rccs
operator|->
name|LookaheadCoverage
condition|)
block|{
name|count
operator|=
name|rccs
operator|->
name|LookaheadGlyphCount
expr_stmt|;
name|c
operator|=
name|rccs
operator|->
name|LookaheadCoverage
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
name|_HB_OPEN_Free_Coverage
argument_list|(
operator|&
name|c
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rccs
operator|->
name|BacktrackCoverage
condition|)
block|{
name|count
operator|=
name|rccs
operator|->
name|BacktrackGlyphCount
expr_stmt|;
name|c
operator|=
name|rccs
operator|->
name|BacktrackCoverage
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
name|_HB_OPEN_Free_Coverage
argument_list|(
operator|&
name|c
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|FREE
argument_list|(
name|rccs
operator|->
name|Substitute
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|Lookup_ReverseChainContextSubst
specifier|static
name|HB_Error
name|Lookup_ReverseChainContextSubst
parameter_list|(
name|HB_GSUBHeader
modifier|*
name|gsub
parameter_list|,
name|HB_GSUB_SubTable
modifier|*
name|st
parameter_list|,
name|HB_Buffer
name|buffer
parameter_list|,
name|HB_UShort
name|flags
parameter_list|,
name|HB_UShort
name|context_length
parameter_list|,
name|int
name|nesting_level
parameter_list|)
block|{
name|HB_UShort
name|index
decl_stmt|,
name|input_index
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|property
decl_stmt|;
name|HB_UShort
name|bgc
decl_stmt|,
name|lgc
decl_stmt|;
name|HB_Error
name|error
decl_stmt|;
name|HB_ReverseChainContextSubst
modifier|*
name|rccs
init|=
operator|&
name|st
operator|->
name|reverse
decl_stmt|;
name|HB_Coverage
modifier|*
name|bc
decl_stmt|;
name|HB_Coverage
modifier|*
name|lc
decl_stmt|;
name|HB_GDEFHeader
modifier|*
name|gdef
decl_stmt|;
if|if
condition|(
name|nesting_level
operator|!=
literal|1
operator|||
name|context_length
operator|!=
literal|0xFFFF
condition|)
return|return
name|HB_Err_Not_Covered
return|;
name|gdef
operator|=
name|gsub
operator|->
name|gdef
expr_stmt|;
if|if
condition|(
name|CHECK_Property
argument_list|(
name|gdef
argument_list|,
name|IN_CURITEM
argument_list|()
argument_list|,
name|flags
argument_list|,
operator|&
name|property
argument_list|)
condition|)
return|return
name|error
return|;
name|bgc
operator|=
name|rccs
operator|->
name|BacktrackGlyphCount
expr_stmt|;
name|lgc
operator|=
name|rccs
operator|->
name|LookaheadGlyphCount
expr_stmt|;
comment|/* check whether context is too long; it is a first guess only */
if|if
condition|(
name|bgc
operator|>
name|buffer
operator|->
name|in_pos
operator|||
name|buffer
operator|->
name|in_pos
operator|+
literal|1
operator|+
name|lgc
operator|>
name|buffer
operator|->
name|in_length
condition|)
return|return
name|HB_Err_Not_Covered
return|;
if|if
condition|(
name|bgc
condition|)
block|{
comment|/* Since we don't know in advance the number of glyphs to inspect,        we search backwards for matches in the backtrack glyph array    */
name|bc
operator|=
name|rccs
operator|->
name|BacktrackCoverage
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
name|buffer
operator|->
name|in_pos
operator|-
literal|1
init|;
name|i
operator|<
name|bgc
condition|;
name|i
operator|++
operator|,
name|j
operator|--
control|)
block|{
while|while
condition|(
name|CHECK_Property
argument_list|(
name|gdef
argument_list|,
name|IN_ITEM
argument_list|(
name|j
argument_list|)
argument_list|,
name|flags
argument_list|,
operator|&
name|property
argument_list|)
condition|)
block|{
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|HB_Err_Not_Covered
condition|)
return|return
name|error
return|;
if|if
condition|(
name|j
operator|+
literal|1
operator|==
name|bgc
operator|-
name|i
condition|)
return|return
name|HB_Err_Not_Covered
return|;
name|j
operator|--
expr_stmt|;
block|}
name|error
operator|=
name|_HB_OPEN_Coverage_Index
argument_list|(
operator|&
name|bc
index|[
name|i
index|]
argument_list|,
name|IN_GLYPH
argument_list|(
name|j
argument_list|)
argument_list|,
operator|&
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
block|}
block|}
name|j
operator|=
name|buffer
operator|->
name|in_pos
expr_stmt|;
name|error
operator|=
name|_HB_OPEN_Coverage_Index
argument_list|(
operator|&
name|rccs
operator|->
name|Coverage
argument_list|,
name|IN_GLYPH
argument_list|(
name|j
argument_list|)
argument_list|,
operator|&
name|input_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|lc
operator|=
name|rccs
operator|->
name|LookaheadCoverage
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
name|buffer
operator|->
name|in_pos
operator|+
literal|1
init|;
name|i
operator|<
name|lgc
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
while|while
condition|(
name|CHECK_Property
argument_list|(
name|gdef
argument_list|,
name|IN_ITEM
argument_list|(
name|j
argument_list|)
argument_list|,
name|flags
argument_list|,
operator|&
name|property
argument_list|)
condition|)
block|{
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|HB_Err_Not_Covered
condition|)
return|return
name|error
return|;
if|if
condition|(
name|j
operator|+
name|lgc
operator|-
name|i
operator|==
operator|(
name|HB_Int
operator|)
name|buffer
operator|->
name|in_length
condition|)
return|return
name|HB_Err_Not_Covered
return|;
name|j
operator|++
expr_stmt|;
block|}
name|error
operator|=
name|_HB_OPEN_Coverage_Index
argument_list|(
operator|&
name|lc
index|[
name|i
index|]
argument_list|,
name|IN_GLYPH
argument_list|(
name|j
argument_list|)
argument_list|,
operator|&
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
block|}
name|IN_CURGLYPH
argument_list|()
operator|=
name|rccs
operator|->
name|Substitute
index|[
name|input_index
index|]
expr_stmt|;
name|buffer
operator|->
name|in_pos
operator|--
expr_stmt|;
comment|/* Reverse! */
return|return
name|error
return|;
block|}
end_function
begin_comment
comment|/***********  * GSUB API  ***********/
end_comment
begin_function
DECL|function|HB_GSUB_Select_Script
name|HB_Error
name|HB_GSUB_Select_Script
parameter_list|(
name|HB_GSUBHeader
modifier|*
name|gsub
parameter_list|,
name|HB_UInt
name|script_tag
parameter_list|,
name|HB_UShort
modifier|*
name|script_index
parameter_list|)
block|{
name|HB_UShort
name|n
decl_stmt|;
name|HB_ScriptList
modifier|*
name|sl
decl_stmt|;
name|HB_ScriptRecord
modifier|*
name|sr
decl_stmt|;
if|if
condition|(
operator|!
name|gsub
operator|||
operator|!
name|script_index
condition|)
return|return
name|ERR
argument_list|(
name|HB_Err_Invalid_Argument
argument_list|)
return|;
name|sl
operator|=
operator|&
name|gsub
operator|->
name|ScriptList
expr_stmt|;
name|sr
operator|=
name|sl
operator|->
name|ScriptRecord
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|sl
operator|->
name|ScriptCount
condition|;
name|n
operator|++
control|)
if|if
condition|(
name|script_tag
operator|==
name|sr
index|[
name|n
index|]
operator|.
name|ScriptTag
condition|)
block|{
operator|*
name|script_index
operator|=
name|n
expr_stmt|;
return|return
name|HB_Err_Ok
return|;
block|}
return|return
name|HB_Err_Not_Covered
return|;
block|}
end_function
begin_function
DECL|function|HB_GSUB_Select_Language
name|HB_Error
name|HB_GSUB_Select_Language
parameter_list|(
name|HB_GSUBHeader
modifier|*
name|gsub
parameter_list|,
name|HB_UInt
name|language_tag
parameter_list|,
name|HB_UShort
name|script_index
parameter_list|,
name|HB_UShort
modifier|*
name|language_index
parameter_list|,
name|HB_UShort
modifier|*
name|req_feature_index
parameter_list|)
block|{
name|HB_UShort
name|n
decl_stmt|;
name|HB_ScriptList
modifier|*
name|sl
decl_stmt|;
name|HB_ScriptRecord
modifier|*
name|sr
decl_stmt|;
name|HB_ScriptTable
modifier|*
name|s
decl_stmt|;
name|HB_LangSysRecord
modifier|*
name|lsr
decl_stmt|;
if|if
condition|(
operator|!
name|gsub
operator|||
operator|!
name|language_index
operator|||
operator|!
name|req_feature_index
condition|)
return|return
name|ERR
argument_list|(
name|HB_Err_Invalid_Argument
argument_list|)
return|;
name|sl
operator|=
operator|&
name|gsub
operator|->
name|ScriptList
expr_stmt|;
name|sr
operator|=
name|sl
operator|->
name|ScriptRecord
expr_stmt|;
if|if
condition|(
name|script_index
operator|>=
name|sl
operator|->
name|ScriptCount
condition|)
return|return
name|ERR
argument_list|(
name|HB_Err_Invalid_Argument
argument_list|)
return|;
name|s
operator|=
operator|&
name|sr
index|[
name|script_index
index|]
operator|.
name|Script
expr_stmt|;
name|lsr
operator|=
name|s
operator|->
name|LangSysRecord
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|s
operator|->
name|LangSysCount
condition|;
name|n
operator|++
control|)
if|if
condition|(
name|language_tag
operator|==
name|lsr
index|[
name|n
index|]
operator|.
name|LangSysTag
condition|)
block|{
operator|*
name|language_index
operator|=
name|n
expr_stmt|;
operator|*
name|req_feature_index
operator|=
name|lsr
index|[
name|n
index|]
operator|.
name|LangSys
operator|.
name|ReqFeatureIndex
expr_stmt|;
return|return
name|HB_Err_Ok
return|;
block|}
return|return
name|HB_Err_Not_Covered
return|;
block|}
end_function
begin_comment
comment|/* selecting 0xFFFF for language_index asks for the values of the    default language (DefaultLangSys)                              */
end_comment
begin_function
DECL|function|HB_GSUB_Select_Feature
name|HB_Error
name|HB_GSUB_Select_Feature
parameter_list|(
name|HB_GSUBHeader
modifier|*
name|gsub
parameter_list|,
name|HB_UInt
name|feature_tag
parameter_list|,
name|HB_UShort
name|script_index
parameter_list|,
name|HB_UShort
name|language_index
parameter_list|,
name|HB_UShort
modifier|*
name|feature_index
parameter_list|)
block|{
name|HB_UShort
name|n
decl_stmt|;
name|HB_ScriptList
modifier|*
name|sl
decl_stmt|;
name|HB_ScriptRecord
modifier|*
name|sr
decl_stmt|;
name|HB_ScriptTable
modifier|*
name|s
decl_stmt|;
name|HB_LangSysRecord
modifier|*
name|lsr
decl_stmt|;
name|HB_LangSys
modifier|*
name|ls
decl_stmt|;
name|HB_UShort
modifier|*
name|fi
decl_stmt|;
name|HB_FeatureList
modifier|*
name|fl
decl_stmt|;
name|HB_FeatureRecord
modifier|*
name|fr
decl_stmt|;
if|if
condition|(
operator|!
name|gsub
operator|||
operator|!
name|feature_index
condition|)
return|return
name|ERR
argument_list|(
name|HB_Err_Invalid_Argument
argument_list|)
return|;
name|sl
operator|=
operator|&
name|gsub
operator|->
name|ScriptList
expr_stmt|;
name|sr
operator|=
name|sl
operator|->
name|ScriptRecord
expr_stmt|;
name|fl
operator|=
operator|&
name|gsub
operator|->
name|FeatureList
expr_stmt|;
name|fr
operator|=
name|fl
operator|->
name|FeatureRecord
expr_stmt|;
if|if
condition|(
name|script_index
operator|>=
name|sl
operator|->
name|ScriptCount
condition|)
return|return
name|ERR
argument_list|(
name|HB_Err_Invalid_Argument
argument_list|)
return|;
name|s
operator|=
operator|&
name|sr
index|[
name|script_index
index|]
operator|.
name|Script
expr_stmt|;
name|lsr
operator|=
name|s
operator|->
name|LangSysRecord
expr_stmt|;
if|if
condition|(
name|language_index
operator|==
literal|0xFFFF
condition|)
name|ls
operator|=
operator|&
name|s
operator|->
name|DefaultLangSys
expr_stmt|;
else|else
block|{
if|if
condition|(
name|language_index
operator|>=
name|s
operator|->
name|LangSysCount
condition|)
return|return
name|ERR
argument_list|(
name|HB_Err_Invalid_Argument
argument_list|)
return|;
name|ls
operator|=
operator|&
name|lsr
index|[
name|language_index
index|]
operator|.
name|LangSys
expr_stmt|;
block|}
name|fi
operator|=
name|ls
operator|->
name|FeatureIndex
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|ls
operator|->
name|FeatureCount
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|fi
index|[
name|n
index|]
operator|>=
name|fl
operator|->
name|FeatureCount
condition|)
return|return
name|ERR
argument_list|(
name|HB_Err_Invalid_SubTable_Format
argument_list|)
return|;
if|if
condition|(
name|feature_tag
operator|==
name|fr
index|[
name|fi
index|[
name|n
index|]
index|]
operator|.
name|FeatureTag
condition|)
block|{
operator|*
name|feature_index
operator|=
name|fi
index|[
name|n
index|]
expr_stmt|;
return|return
name|HB_Err_Ok
return|;
block|}
block|}
return|return
name|HB_Err_Not_Covered
return|;
block|}
end_function
begin_comment
comment|/* The next three functions return a null-terminated list */
end_comment
begin_function
DECL|function|HB_GSUB_Query_Scripts
name|HB_Error
name|HB_GSUB_Query_Scripts
parameter_list|(
name|HB_GSUBHeader
modifier|*
name|gsub
parameter_list|,
name|HB_UInt
modifier|*
modifier|*
name|script_tag_list
parameter_list|)
block|{
name|HB_UShort
name|n
decl_stmt|;
name|HB_Error
name|error
decl_stmt|;
name|HB_UInt
modifier|*
name|stl
decl_stmt|;
name|HB_ScriptList
modifier|*
name|sl
decl_stmt|;
name|HB_ScriptRecord
modifier|*
name|sr
decl_stmt|;
if|if
condition|(
operator|!
name|gsub
operator|||
operator|!
name|script_tag_list
condition|)
return|return
name|ERR
argument_list|(
name|HB_Err_Invalid_Argument
argument_list|)
return|;
name|sl
operator|=
operator|&
name|gsub
operator|->
name|ScriptList
expr_stmt|;
name|sr
operator|=
name|sl
operator|->
name|ScriptRecord
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|stl
argument_list|,
name|sl
operator|->
name|ScriptCount
operator|+
literal|1
argument_list|,
name|HB_UInt
argument_list|)
condition|)
return|return
name|error
return|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|sl
operator|->
name|ScriptCount
condition|;
name|n
operator|++
control|)
name|stl
index|[
name|n
index|]
operator|=
name|sr
index|[
name|n
index|]
operator|.
name|ScriptTag
expr_stmt|;
name|stl
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
operator|*
name|script_tag_list
operator|=
name|stl
expr_stmt|;
return|return
name|HB_Err_Ok
return|;
block|}
end_function
begin_function
DECL|function|HB_GSUB_Query_Languages
name|HB_Error
name|HB_GSUB_Query_Languages
parameter_list|(
name|HB_GSUBHeader
modifier|*
name|gsub
parameter_list|,
name|HB_UShort
name|script_index
parameter_list|,
name|HB_UInt
modifier|*
modifier|*
name|language_tag_list
parameter_list|)
block|{
name|HB_UShort
name|n
decl_stmt|;
name|HB_Error
name|error
decl_stmt|;
name|HB_UInt
modifier|*
name|ltl
decl_stmt|;
name|HB_ScriptList
modifier|*
name|sl
decl_stmt|;
name|HB_ScriptRecord
modifier|*
name|sr
decl_stmt|;
name|HB_ScriptTable
modifier|*
name|s
decl_stmt|;
name|HB_LangSysRecord
modifier|*
name|lsr
decl_stmt|;
if|if
condition|(
operator|!
name|gsub
operator|||
operator|!
name|language_tag_list
condition|)
return|return
name|ERR
argument_list|(
name|HB_Err_Invalid_Argument
argument_list|)
return|;
name|sl
operator|=
operator|&
name|gsub
operator|->
name|ScriptList
expr_stmt|;
name|sr
operator|=
name|sl
operator|->
name|ScriptRecord
expr_stmt|;
if|if
condition|(
name|script_index
operator|>=
name|sl
operator|->
name|ScriptCount
condition|)
return|return
name|ERR
argument_list|(
name|HB_Err_Invalid_Argument
argument_list|)
return|;
name|s
operator|=
operator|&
name|sr
index|[
name|script_index
index|]
operator|.
name|Script
expr_stmt|;
name|lsr
operator|=
name|s
operator|->
name|LangSysRecord
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|ltl
argument_list|,
name|s
operator|->
name|LangSysCount
operator|+
literal|1
argument_list|,
name|HB_UInt
argument_list|)
condition|)
return|return
name|error
return|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|s
operator|->
name|LangSysCount
condition|;
name|n
operator|++
control|)
name|ltl
index|[
name|n
index|]
operator|=
name|lsr
index|[
name|n
index|]
operator|.
name|LangSysTag
expr_stmt|;
name|ltl
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
operator|*
name|language_tag_list
operator|=
name|ltl
expr_stmt|;
return|return
name|HB_Err_Ok
return|;
block|}
end_function
begin_comment
comment|/* selecting 0xFFFF for language_index asks for the values of the    default language (DefaultLangSys)                              */
end_comment
begin_function
DECL|function|HB_GSUB_Query_Features
name|HB_Error
name|HB_GSUB_Query_Features
parameter_list|(
name|HB_GSUBHeader
modifier|*
name|gsub
parameter_list|,
name|HB_UShort
name|script_index
parameter_list|,
name|HB_UShort
name|language_index
parameter_list|,
name|HB_UInt
modifier|*
modifier|*
name|feature_tag_list
parameter_list|)
block|{
name|HB_UShort
name|n
decl_stmt|;
name|HB_Error
name|error
decl_stmt|;
name|HB_UInt
modifier|*
name|ftl
decl_stmt|;
name|HB_ScriptList
modifier|*
name|sl
decl_stmt|;
name|HB_ScriptRecord
modifier|*
name|sr
decl_stmt|;
name|HB_ScriptTable
modifier|*
name|s
decl_stmt|;
name|HB_LangSysRecord
modifier|*
name|lsr
decl_stmt|;
name|HB_LangSys
modifier|*
name|ls
decl_stmt|;
name|HB_UShort
modifier|*
name|fi
decl_stmt|;
name|HB_FeatureList
modifier|*
name|fl
decl_stmt|;
name|HB_FeatureRecord
modifier|*
name|fr
decl_stmt|;
if|if
condition|(
operator|!
name|gsub
operator|||
operator|!
name|feature_tag_list
condition|)
return|return
name|ERR
argument_list|(
name|HB_Err_Invalid_Argument
argument_list|)
return|;
name|sl
operator|=
operator|&
name|gsub
operator|->
name|ScriptList
expr_stmt|;
name|sr
operator|=
name|sl
operator|->
name|ScriptRecord
expr_stmt|;
name|fl
operator|=
operator|&
name|gsub
operator|->
name|FeatureList
expr_stmt|;
name|fr
operator|=
name|fl
operator|->
name|FeatureRecord
expr_stmt|;
if|if
condition|(
name|script_index
operator|>=
name|sl
operator|->
name|ScriptCount
condition|)
return|return
name|ERR
argument_list|(
name|HB_Err_Invalid_Argument
argument_list|)
return|;
name|s
operator|=
operator|&
name|sr
index|[
name|script_index
index|]
operator|.
name|Script
expr_stmt|;
name|lsr
operator|=
name|s
operator|->
name|LangSysRecord
expr_stmt|;
if|if
condition|(
name|language_index
operator|==
literal|0xFFFF
condition|)
name|ls
operator|=
operator|&
name|s
operator|->
name|DefaultLangSys
expr_stmt|;
else|else
block|{
if|if
condition|(
name|language_index
operator|>=
name|s
operator|->
name|LangSysCount
condition|)
return|return
name|ERR
argument_list|(
name|HB_Err_Invalid_Argument
argument_list|)
return|;
name|ls
operator|=
operator|&
name|lsr
index|[
name|language_index
index|]
operator|.
name|LangSys
expr_stmt|;
block|}
name|fi
operator|=
name|ls
operator|->
name|FeatureIndex
expr_stmt|;
if|if
condition|(
name|ALLOC_ARRAY
argument_list|(
name|ftl
argument_list|,
name|ls
operator|->
name|FeatureCount
operator|+
literal|1
argument_list|,
name|HB_UInt
argument_list|)
condition|)
return|return
name|error
return|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|ls
operator|->
name|FeatureCount
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|fi
index|[
name|n
index|]
operator|>=
name|fl
operator|->
name|FeatureCount
condition|)
block|{
name|FREE
argument_list|(
name|ftl
argument_list|)
expr_stmt|;
return|return
name|ERR
argument_list|(
name|HB_Err_Invalid_SubTable_Format
argument_list|)
return|;
block|}
name|ftl
index|[
name|n
index|]
operator|=
name|fr
index|[
name|fi
index|[
name|n
index|]
index|]
operator|.
name|FeatureTag
expr_stmt|;
block|}
name|ftl
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
operator|*
name|feature_tag_list
operator|=
name|ftl
expr_stmt|;
return|return
name|HB_Err_Ok
return|;
block|}
end_function
begin_comment
comment|/* Do an individual subtable lookup.  Returns HB_Err_Ok if substitution    has been done, or HB_Err_Not_Covered if not.                        */
end_comment
begin_function
DECL|function|GSUB_Do_Glyph_Lookup
specifier|static
name|HB_Error
name|GSUB_Do_Glyph_Lookup
parameter_list|(
name|HB_GSUBHeader
modifier|*
name|gsub
parameter_list|,
name|HB_UShort
name|lookup_index
parameter_list|,
name|HB_Buffer
name|buffer
parameter_list|,
name|HB_UShort
name|context_length
parameter_list|,
name|int
name|nesting_level
parameter_list|)
block|{
name|HB_Error
name|error
init|=
name|HB_Err_Not_Covered
decl_stmt|;
name|HB_UShort
name|i
decl_stmt|,
name|flags
decl_stmt|,
name|lookup_count
decl_stmt|;
name|HB_Lookup
modifier|*
name|lo
decl_stmt|;
name|int
name|lookup_type
decl_stmt|;
name|nesting_level
operator|++
expr_stmt|;
if|if
condition|(
name|nesting_level
operator|>
name|HB_MAX_NESTING_LEVEL
condition|)
return|return
name|ERR
argument_list|(
name|HB_Err_Not_Covered
argument_list|)
return|;
comment|/* ERR() call intended */
name|lookup_count
operator|=
name|gsub
operator|->
name|LookupList
operator|.
name|LookupCount
expr_stmt|;
if|if
condition|(
name|lookup_index
operator|>=
name|lookup_count
condition|)
return|return
name|error
return|;
name|lo
operator|=
operator|&
name|gsub
operator|->
name|LookupList
operator|.
name|Lookup
index|[
name|lookup_index
index|]
expr_stmt|;
name|flags
operator|=
name|lo
operator|->
name|LookupFlag
expr_stmt|;
name|lookup_type
operator|=
name|lo
operator|->
name|LookupType
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lo
operator|->
name|SubTableCount
condition|;
name|i
operator|++
control|)
block|{
name|HB_GSUB_SubTable
modifier|*
name|st
init|=
operator|&
name|lo
operator|->
name|SubTable
index|[
name|i
index|]
operator|.
name|st
operator|.
name|gsub
decl_stmt|;
switch|switch
condition|(
name|lookup_type
condition|)
block|{
case|case
name|HB_GSUB_LOOKUP_SINGLE
case|:
name|error
operator|=
name|Lookup_SingleSubst
argument_list|(
name|gsub
argument_list|,
name|st
argument_list|,
name|buffer
argument_list|,
name|flags
argument_list|,
name|context_length
argument_list|,
name|nesting_level
argument_list|)
expr_stmt|;
break|break;
case|case
name|HB_GSUB_LOOKUP_MULTIPLE
case|:
name|error
operator|=
name|Lookup_MultipleSubst
argument_list|(
name|gsub
argument_list|,
name|st
argument_list|,
name|buffer
argument_list|,
name|flags
argument_list|,
name|context_length
argument_list|,
name|nesting_level
argument_list|)
expr_stmt|;
break|break;
case|case
name|HB_GSUB_LOOKUP_ALTERNATE
case|:
name|error
operator|=
name|Lookup_AlternateSubst
argument_list|(
name|gsub
argument_list|,
name|st
argument_list|,
name|buffer
argument_list|,
name|flags
argument_list|,
name|context_length
argument_list|,
name|nesting_level
argument_list|)
expr_stmt|;
break|break;
case|case
name|HB_GSUB_LOOKUP_LIGATURE
case|:
name|error
operator|=
name|Lookup_LigatureSubst
argument_list|(
name|gsub
argument_list|,
name|st
argument_list|,
name|buffer
argument_list|,
name|flags
argument_list|,
name|context_length
argument_list|,
name|nesting_level
argument_list|)
expr_stmt|;
break|break;
case|case
name|HB_GSUB_LOOKUP_CONTEXT
case|:
name|error
operator|=
name|Lookup_ContextSubst
argument_list|(
name|gsub
argument_list|,
name|st
argument_list|,
name|buffer
argument_list|,
name|flags
argument_list|,
name|context_length
argument_list|,
name|nesting_level
argument_list|)
expr_stmt|;
break|break;
case|case
name|HB_GSUB_LOOKUP_CHAIN
case|:
name|error
operator|=
name|Lookup_ChainContextSubst
argument_list|(
name|gsub
argument_list|,
name|st
argument_list|,
name|buffer
argument_list|,
name|flags
argument_list|,
name|context_length
argument_list|,
name|nesting_level
argument_list|)
expr_stmt|;
break|break;
comment|/*case HB_GSUB_LOOKUP_EXTENSION: 	error = Lookup_ExtensionSubst		( gsub, st, buffer, flags, context_length, nesting_level ); break;*/
case|case
name|HB_GSUB_LOOKUP_REVERSE_CHAIN
case|:
name|error
operator|=
name|Lookup_ReverseChainContextSubst
argument_list|(
name|gsub
argument_list|,
name|st
argument_list|,
name|buffer
argument_list|,
name|flags
argument_list|,
name|context_length
argument_list|,
name|nesting_level
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|HB_Err_Not_Covered
expr_stmt|;
block|}
empty_stmt|;
comment|/* Check whether we have a successful substitution or an error other        than HB_Err_Not_Covered                                          */
if|if
condition|(
name|error
operator|!=
name|HB_Err_Not_Covered
condition|)
return|return
name|error
return|;
block|}
return|return
name|HB_Err_Not_Covered
return|;
block|}
end_function
begin_function
name|HB_INTERNAL
name|HB_Error
DECL|function|_HB_GSUB_Load_SubTable
name|_HB_GSUB_Load_SubTable
parameter_list|(
name|HB_GSUB_SubTable
modifier|*
name|st
parameter_list|,
name|HB_Stream
name|stream
parameter_list|,
name|HB_UShort
name|lookup_type
parameter_list|)
block|{
switch|switch
condition|(
name|lookup_type
condition|)
block|{
case|case
name|HB_GSUB_LOOKUP_SINGLE
case|:
return|return
name|Load_SingleSubst
argument_list|(
name|st
argument_list|,
name|stream
argument_list|)
return|;
case|case
name|HB_GSUB_LOOKUP_MULTIPLE
case|:
return|return
name|Load_MultipleSubst
argument_list|(
name|st
argument_list|,
name|stream
argument_list|)
return|;
case|case
name|HB_GSUB_LOOKUP_ALTERNATE
case|:
return|return
name|Load_AlternateSubst
argument_list|(
name|st
argument_list|,
name|stream
argument_list|)
return|;
case|case
name|HB_GSUB_LOOKUP_LIGATURE
case|:
return|return
name|Load_LigatureSubst
argument_list|(
name|st
argument_list|,
name|stream
argument_list|)
return|;
case|case
name|HB_GSUB_LOOKUP_CONTEXT
case|:
return|return
name|Load_ContextSubst
argument_list|(
name|st
argument_list|,
name|stream
argument_list|)
return|;
case|case
name|HB_GSUB_LOOKUP_CHAIN
case|:
return|return
name|Load_ChainContextSubst
argument_list|(
name|st
argument_list|,
name|stream
argument_list|)
return|;
comment|/*case HB_GSUB_LOOKUP_EXTENSION:	return Load_ExtensionSubst		( st, stream );*/
case|case
name|HB_GSUB_LOOKUP_REVERSE_CHAIN
case|:
return|return
name|Load_ReverseChainContextSubst
argument_list|(
name|st
argument_list|,
name|stream
argument_list|)
return|;
default|default:
return|return
name|ERR
argument_list|(
name|HB_Err_Invalid_SubTable_Format
argument_list|)
return|;
block|}
empty_stmt|;
block|}
end_function
begin_function
name|HB_INTERNAL
name|void
DECL|function|_HB_GSUB_Free_SubTable
name|_HB_GSUB_Free_SubTable
parameter_list|(
name|HB_GSUB_SubTable
modifier|*
name|st
parameter_list|,
name|HB_UShort
name|lookup_type
parameter_list|)
block|{
switch|switch
condition|(
name|lookup_type
condition|)
block|{
case|case
name|HB_GSUB_LOOKUP_SINGLE
case|:
name|Free_SingleSubst
argument_list|(
name|st
argument_list|)
expr_stmt|;
return|return;
case|case
name|HB_GSUB_LOOKUP_MULTIPLE
case|:
name|Free_MultipleSubst
argument_list|(
name|st
argument_list|)
expr_stmt|;
return|return;
case|case
name|HB_GSUB_LOOKUP_ALTERNATE
case|:
name|Free_AlternateSubst
argument_list|(
name|st
argument_list|)
expr_stmt|;
return|return;
case|case
name|HB_GSUB_LOOKUP_LIGATURE
case|:
name|Free_LigatureSubst
argument_list|(
name|st
argument_list|)
expr_stmt|;
return|return;
case|case
name|HB_GSUB_LOOKUP_CONTEXT
case|:
name|Free_ContextSubst
argument_list|(
name|st
argument_list|)
expr_stmt|;
return|return;
case|case
name|HB_GSUB_LOOKUP_CHAIN
case|:
name|Free_ChainContextSubst
argument_list|(
name|st
argument_list|)
expr_stmt|;
return|return;
comment|/*case HB_GSUB_LOOKUP_EXTENSION:	Free_ExtensionSubst		( st ); return;*/
case|case
name|HB_GSUB_LOOKUP_REVERSE_CHAIN
case|:
name|Free_ReverseChainContextSubst
argument_list|(
name|st
argument_list|)
expr_stmt|;
return|return;
default|default:
return|return;
block|}
empty_stmt|;
block|}
end_function
begin_comment
comment|/* apply one lookup to the input string object */
end_comment
begin_function
DECL|function|GSUB_Do_String_Lookup
specifier|static
name|HB_Error
name|GSUB_Do_String_Lookup
parameter_list|(
name|HB_GSUBHeader
modifier|*
name|gsub
parameter_list|,
name|HB_UShort
name|lookup_index
parameter_list|,
name|HB_Buffer
name|buffer
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|,
name|retError
init|=
name|HB_Err_Not_Covered
decl_stmt|;
name|HB_UInt
modifier|*
name|properties
init|=
name|gsub
operator|->
name|LookupList
operator|.
name|Properties
decl_stmt|;
name|int
name|lookup_type
init|=
name|gsub
operator|->
name|LookupList
operator|.
name|Lookup
index|[
name|lookup_index
index|]
operator|.
name|LookupType
decl_stmt|;
specifier|const
name|int
name|nesting_level
init|=
literal|0
decl_stmt|;
comment|/* 0xFFFF indicates that we don't have a context length yet */
specifier|const
name|HB_UShort
name|context_length
init|=
literal|0xFFFF
decl_stmt|;
switch|switch
condition|(
name|lookup_type
condition|)
block|{
case|case
name|HB_GSUB_LOOKUP_SINGLE
case|:
case|case
name|HB_GSUB_LOOKUP_MULTIPLE
case|:
case|case
name|HB_GSUB_LOOKUP_ALTERNATE
case|:
case|case
name|HB_GSUB_LOOKUP_LIGATURE
case|:
case|case
name|HB_GSUB_LOOKUP_CONTEXT
case|:
case|case
name|HB_GSUB_LOOKUP_CHAIN
case|:
comment|/* in/out forward substitution (implemented lazy) */
name|_hb_buffer_clear_output
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|buffer
operator|->
name|in_pos
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|buffer
operator|->
name|in_pos
operator|<
name|buffer
operator|->
name|in_length
condition|)
block|{
if|if
condition|(
operator|~
name|IN_PROPERTIES
argument_list|(
name|buffer
operator|->
name|in_pos
argument_list|)
operator|&
name|properties
index|[
name|lookup_index
index|]
condition|)
block|{
name|error
operator|=
name|GSUB_Do_Glyph_Lookup
argument_list|(
name|gsub
argument_list|,
name|lookup_index
argument_list|,
name|buffer
argument_list|,
name|context_length
argument_list|,
name|nesting_level
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|error
operator|!=
name|HB_Err_Not_Covered
condition|)
return|return
name|error
return|;
block|}
else|else
name|retError
operator|=
name|error
expr_stmt|;
block|}
else|else
name|error
operator|=
name|HB_Err_Not_Covered
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|HB_Err_Not_Covered
condition|)
if|if
condition|(
name|COPY_Glyph
argument_list|(
name|buffer
argument_list|)
condition|)
return|return
name|error
return|;
block|}
comment|/* we shouldn't swap if error occurred.        *        * also don't swap if nothing changed (ie HB_Err_Not_Covered).        * shouldn't matter in that case though.        */
if|if
condition|(
name|retError
operator|==
name|HB_Err_Ok
condition|)
name|_hb_buffer_swap
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
return|return
name|retError
return|;
case|case
name|HB_GSUB_LOOKUP_REVERSE_CHAIN
case|:
comment|/* in-place backward substitution */
name|buffer
operator|->
name|in_pos
operator|=
name|buffer
operator|->
name|in_length
operator|-
literal|1
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|~
name|IN_PROPERTIES
argument_list|(
name|buffer
operator|->
name|in_pos
argument_list|)
operator|&
name|properties
index|[
name|lookup_index
index|]
condition|)
block|{
name|error
operator|=
name|GSUB_Do_Glyph_Lookup
argument_list|(
name|gsub
argument_list|,
name|lookup_index
argument_list|,
name|buffer
argument_list|,
name|context_length
argument_list|,
name|nesting_level
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|error
operator|!=
name|HB_Err_Not_Covered
condition|)
return|return
name|error
return|;
block|}
else|else
name|retError
operator|=
name|error
expr_stmt|;
block|}
else|else
name|error
operator|=
name|HB_Err_Not_Covered
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|HB_Err_Not_Covered
condition|)
name|buffer
operator|->
name|in_pos
operator|--
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|HB_Int
operator|)
name|buffer
operator|->
name|in_pos
operator|>=
literal|0
condition|)
do|;
return|return
name|retError
return|;
comment|/*case HB_GSUB_LOOKUP_EXTENSION:*/
default|default:
return|return
name|retError
return|;
block|}
empty_stmt|;
block|}
end_function
begin_function
DECL|function|HB_GSUB_Add_Feature
name|HB_Error
name|HB_GSUB_Add_Feature
parameter_list|(
name|HB_GSUBHeader
modifier|*
name|gsub
parameter_list|,
name|HB_UShort
name|feature_index
parameter_list|,
name|HB_UInt
name|property
parameter_list|)
block|{
name|HB_UShort
name|i
decl_stmt|;
name|HB_Feature
name|feature
decl_stmt|;
name|HB_UInt
modifier|*
name|properties
decl_stmt|;
name|HB_UShort
modifier|*
name|index
decl_stmt|;
name|HB_UShort
name|lookup_count
decl_stmt|;
comment|/* Each feature can only be added once */
if|if
condition|(
operator|!
name|gsub
operator|||
name|feature_index
operator|>=
name|gsub
operator|->
name|FeatureList
operator|.
name|FeatureCount
operator|||
name|gsub
operator|->
name|FeatureList
operator|.
name|ApplyCount
operator|==
name|gsub
operator|->
name|FeatureList
operator|.
name|FeatureCount
condition|)
return|return
name|ERR
argument_list|(
name|HB_Err_Invalid_Argument
argument_list|)
return|;
name|gsub
operator|->
name|FeatureList
operator|.
name|ApplyOrder
index|[
name|gsub
operator|->
name|FeatureList
operator|.
name|ApplyCount
operator|++
index|]
operator|=
name|feature_index
expr_stmt|;
name|properties
operator|=
name|gsub
operator|->
name|LookupList
operator|.
name|Properties
expr_stmt|;
name|feature
operator|=
name|gsub
operator|->
name|FeatureList
operator|.
name|FeatureRecord
index|[
name|feature_index
index|]
operator|.
name|Feature
expr_stmt|;
name|index
operator|=
name|feature
operator|.
name|LookupListIndex
expr_stmt|;
name|lookup_count
operator|=
name|gsub
operator|->
name|LookupList
operator|.
name|LookupCount
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|feature
operator|.
name|LookupListCount
condition|;
name|i
operator|++
control|)
block|{
name|HB_UShort
name|lookup_index
init|=
name|index
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|lookup_index
operator|<
name|lookup_count
condition|)
name|properties
index|[
name|lookup_index
index|]
operator||=
name|property
expr_stmt|;
block|}
return|return
name|HB_Err_Ok
return|;
block|}
end_function
begin_function
DECL|function|HB_GSUB_Clear_Features
name|HB_Error
name|HB_GSUB_Clear_Features
parameter_list|(
name|HB_GSUBHeader
modifier|*
name|gsub
parameter_list|)
block|{
name|HB_UShort
name|i
decl_stmt|;
name|HB_UInt
modifier|*
name|properties
decl_stmt|;
if|if
condition|(
operator|!
name|gsub
condition|)
return|return
name|ERR
argument_list|(
name|HB_Err_Invalid_Argument
argument_list|)
return|;
name|gsub
operator|->
name|FeatureList
operator|.
name|ApplyCount
operator|=
literal|0
expr_stmt|;
name|properties
operator|=
name|gsub
operator|->
name|LookupList
operator|.
name|Properties
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|gsub
operator|->
name|LookupList
operator|.
name|LookupCount
condition|;
name|i
operator|++
control|)
name|properties
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|HB_Err_Ok
return|;
block|}
end_function
begin_function
DECL|function|HB_GSUB_Register_Alternate_Function
name|HB_Error
name|HB_GSUB_Register_Alternate_Function
parameter_list|(
name|HB_GSUBHeader
modifier|*
name|gsub
parameter_list|,
name|HB_AltFunction
name|altfunc
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
if|if
condition|(
operator|!
name|gsub
condition|)
return|return
name|ERR
argument_list|(
name|HB_Err_Invalid_Argument
argument_list|)
return|;
name|gsub
operator|->
name|altfunc
operator|=
name|altfunc
expr_stmt|;
name|gsub
operator|->
name|data
operator|=
name|data
expr_stmt|;
return|return
name|HB_Err_Ok
return|;
block|}
end_function
begin_comment
comment|/* returns error if one happened, otherwise returns HB_Err_Not_Covered if no  * feature were applied, or HB_Err_Ok otherwise.  */
end_comment
begin_function
DECL|function|HB_GSUB_Apply_String
name|HB_Error
name|HB_GSUB_Apply_String
parameter_list|(
name|HB_GSUBHeader
modifier|*
name|gsub
parameter_list|,
name|HB_Buffer
name|buffer
parameter_list|)
block|{
name|HB_Error
name|error
decl_stmt|,
name|retError
init|=
name|HB_Err_Not_Covered
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|lookup_count
decl_stmt|,
name|num_features
decl_stmt|;
if|if
condition|(
operator|!
name|gsub
operator|||
operator|!
name|buffer
condition|)
return|return
name|ERR
argument_list|(
name|HB_Err_Invalid_Argument
argument_list|)
return|;
if|if
condition|(
name|buffer
operator|->
name|in_length
operator|==
literal|0
condition|)
return|return
name|retError
return|;
name|lookup_count
operator|=
name|gsub
operator|->
name|LookupList
operator|.
name|LookupCount
expr_stmt|;
name|num_features
operator|=
name|gsub
operator|->
name|FeatureList
operator|.
name|ApplyCount
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_features
condition|;
name|i
operator|++
control|)
block|{
name|HB_UShort
name|feature_index
init|=
name|gsub
operator|->
name|FeatureList
operator|.
name|ApplyOrder
index|[
name|i
index|]
decl_stmt|;
name|HB_Feature
name|feature
init|=
name|gsub
operator|->
name|FeatureList
operator|.
name|FeatureRecord
index|[
name|feature_index
index|]
operator|.
name|Feature
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|feature
operator|.
name|LookupListCount
condition|;
name|j
operator|++
control|)
block|{
name|HB_UShort
name|lookup_index
init|=
name|feature
operator|.
name|LookupListIndex
index|[
name|j
index|]
decl_stmt|;
comment|/* Skip nonexistant lookups */
if|if
condition|(
name|lookup_index
operator|>=
name|lookup_count
condition|)
continue|continue;
name|error
operator|=
name|GSUB_Do_String_Lookup
argument_list|(
name|gsub
argument_list|,
name|lookup_index
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|error
operator|!=
name|HB_Err_Not_Covered
condition|)
return|return
name|error
return|;
block|}
else|else
name|retError
operator|=
name|error
expr_stmt|;
block|}
block|}
name|error
operator|=
name|retError
expr_stmt|;
return|return
name|error
return|;
block|}
end_function
begin_comment
comment|/* END */
end_comment
end_unit
