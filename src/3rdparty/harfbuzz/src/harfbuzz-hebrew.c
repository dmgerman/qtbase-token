begin_unit
begin_comment
comment|/*  * Copyright (C) 2012 Digia Plc and/or its subsidiary(-ies)  *  * This is part of HarfBuzz, an OpenType Layout engine library.  *  * Permission is hereby granted, without written agreement and without  * license or royalty fees, to use, copy, modify, and distribute this  * software and its documentation for any purpose, provided that the  * above copyright notice and the following two paragraphs appear in  * all copies of this software.  *  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH  * DAMAGE.  *  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS  * ON AN "AS IS" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.  */
end_comment
begin_include
include|#
directive|include
file|"harfbuzz-shaper.h"
end_include
begin_include
include|#
directive|include
file|"harfbuzz-shaper-private.h"
end_include
begin_include
include|#
directive|include
file|<assert.h>
end_include
begin_comment
comment|/* // Uniscribe also defines dlig for Hebrew, but we leave this out for now, as it's mostly // ligatures one does not want in modern Hebrew (as lam-alef ligatures). */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|NO_OPENTYPE
end_ifndef
begin_decl_stmt
DECL|variable|hebrew_features
specifier|static
specifier|const
name|HB_OpenTypeFeature
name|hebrew_features
index|[]
init|=
block|{
block|{
name|HB_MAKE_TAG
argument_list|(
literal|'c'
argument_list|,
literal|'c'
argument_list|,
literal|'m'
argument_list|,
literal|'p'
argument_list|)
block|,
name|CcmpProperty
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* Hebrew shaping. In the non opentype case we try to use the    presentation forms specified for Hebrew. Especially for the    ligatures with Dagesh this gives much better results than we could    achieve manually. */
end_comment
begin_function
DECL|function|HB_HebrewShape
name|HB_Bool
name|HB_HebrewShape
parameter_list|(
name|HB_ShaperItem
modifier|*
name|shaper_item
parameter_list|)
block|{
enum|enum
block|{
name|Dagesh
init|=
literal|0x5bc
block|,
name|ShinDot
init|=
literal|0x5c1
block|,
name|SinDot
init|=
literal|0x5c2
block|,
name|Patah
init|=
literal|0x5b7
block|,
name|Qamats
init|=
literal|0x5b8
block|,
name|Holam
init|=
literal|0x5b9
block|,
name|Rafe
init|=
literal|0x5bf
block|}
enum|;
name|assert
argument_list|(
name|shaper_item
operator|->
name|item
operator|.
name|script
operator|==
name|HB_Script_Hebrew
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_OPENTYPE
if|if
condition|(
name|HB_SelectScript
argument_list|(
name|shaper_item
argument_list|,
name|hebrew_features
argument_list|)
condition|)
block|{
specifier|const
name|int
name|availableGlyphs
init|=
name|shaper_item
operator|->
name|num_glyphs
decl_stmt|;
if|if
condition|(
operator|!
name|HB_ConvertStringToGlyphIndices
argument_list|(
name|shaper_item
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|HB_HeuristicSetGlyphAttributes
argument_list|(
name|shaper_item
argument_list|)
expr_stmt|;
name|HB_OpenTypeShape
argument_list|(
name|shaper_item
argument_list|,
comment|/*properties*/
literal|0
argument_list|)
expr_stmt|;
return|return
name|HB_OpenTypePosition
argument_list|(
name|shaper_item
argument_list|,
name|availableGlyphs
argument_list|,
comment|/*doLogClusters*/
name|TRUE
argument_list|)
return|;
block|}
endif|#
directive|endif
block|{
specifier|const
name|HB_UChar16
modifier|*
name|uc
init|=
name|shaper_item
operator|->
name|string
operator|+
name|shaper_item
operator|->
name|item
operator|.
name|pos
decl_stmt|;
name|unsigned
name|short
modifier|*
name|logClusters
init|=
name|shaper_item
operator|->
name|log_clusters
decl_stmt|;
name|HB_GlyphAttributes
modifier|*
name|attributes
init|=
name|shaper_item
operator|->
name|attributes
decl_stmt|;
name|HB_Bool
name|haveGlyphs
decl_stmt|;
name|int
name|slen
init|=
literal|1
decl_stmt|;
name|int
name|cluster_start
init|=
literal|0
decl_stmt|;
name|hb_uint32
name|i
decl_stmt|;
name|HB_STACKARRAY
argument_list|(
name|HB_UChar16
argument_list|,
name|shapedChars
argument_list|,
literal|2
operator|*
name|shaper_item
operator|->
name|item
operator|.
name|length
argument_list|)
expr_stmt|;
operator|*
name|shapedChars
operator|=
operator|*
name|uc
expr_stmt|;
name|logClusters
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|shaper_item
operator|->
name|item
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|hb_uint16
name|base
init|=
name|shapedChars
index|[
name|cluster_start
index|]
decl_stmt|;
name|hb_uint16
name|shaped
init|=
literal|0
decl_stmt|;
name|HB_Bool
name|invalid
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|uc
index|[
name|i
index|]
operator|==
name|Dagesh
condition|)
block|{
if|if
condition|(
name|base
operator|>=
literal|0x5d0
operator|&&
name|base
operator|<=
literal|0x5ea
operator|&&
name|base
operator|!=
literal|0x5d7
operator|&&
name|base
operator|!=
literal|0x5dd
operator|&&
name|base
operator|!=
literal|0x5df
operator|&&
name|base
operator|!=
literal|0x5e2
operator|&&
name|base
operator|!=
literal|0x5e5
condition|)
block|{
name|shaped
operator|=
name|base
operator|-
literal|0x5d0
operator|+
literal|0xfb30
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|base
operator|==
literal|0xfb2a
operator|||
name|base
operator|==
literal|0xfb2b
comment|/* Shin with Shin or Sin dot */
condition|)
block|{
name|shaped
operator|=
name|base
operator|+
literal|2
expr_stmt|;
block|}
else|else
block|{
name|invalid
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|uc
index|[
name|i
index|]
operator|==
name|ShinDot
condition|)
block|{
if|if
condition|(
name|base
operator|==
literal|0x05e9
condition|)
name|shaped
operator|=
literal|0xfb2a
expr_stmt|;
elseif|else
if|if
condition|(
name|base
operator|==
literal|0xfb49
condition|)
name|shaped
operator|=
literal|0xfb2c
expr_stmt|;
else|else
name|invalid
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|uc
index|[
name|i
index|]
operator|==
name|SinDot
condition|)
block|{
if|if
condition|(
name|base
operator|==
literal|0x05e9
condition|)
name|shaped
operator|=
literal|0xfb2b
expr_stmt|;
elseif|else
if|if
condition|(
name|base
operator|==
literal|0xfb49
condition|)
name|shaped
operator|=
literal|0xfb2d
expr_stmt|;
else|else
name|invalid
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|uc
index|[
name|i
index|]
operator|==
name|Patah
condition|)
block|{
if|if
condition|(
name|base
operator|==
literal|0x5d0
condition|)
name|shaped
operator|=
literal|0xfb2e
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|uc
index|[
name|i
index|]
operator|==
name|Qamats
condition|)
block|{
if|if
condition|(
name|base
operator|==
literal|0x5d0
condition|)
name|shaped
operator|=
literal|0xfb2f
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|uc
index|[
name|i
index|]
operator|==
name|Holam
condition|)
block|{
if|if
condition|(
name|base
operator|==
literal|0x5d5
condition|)
name|shaped
operator|=
literal|0xfb4b
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|uc
index|[
name|i
index|]
operator|==
name|Rafe
condition|)
block|{
if|if
condition|(
name|base
operator|==
literal|0x5d1
condition|)
name|shaped
operator|=
literal|0xfb4c
expr_stmt|;
elseif|else
if|if
condition|(
name|base
operator|==
literal|0x5db
condition|)
name|shaped
operator|=
literal|0xfb4d
expr_stmt|;
elseif|else
if|if
condition|(
name|base
operator|==
literal|0x5e4
condition|)
name|shaped
operator|=
literal|0xfb4e
expr_stmt|;
block|}
if|if
condition|(
name|invalid
condition|)
block|{
name|shapedChars
index|[
name|slen
index|]
operator|=
literal|0x25cc
expr_stmt|;
name|attributes
index|[
name|slen
index|]
operator|.
name|clusterStart
operator|=
name|TRUE
expr_stmt|;
name|attributes
index|[
name|slen
index|]
operator|.
name|mark
operator|=
name|FALSE
expr_stmt|;
name|attributes
index|[
name|slen
index|]
operator|.
name|combiningClass
operator|=
literal|0
expr_stmt|;
name|cluster_start
operator|=
name|slen
expr_stmt|;
operator|++
name|slen
expr_stmt|;
block|}
if|if
condition|(
name|shaped
condition|)
block|{
if|if
condition|(
name|shaper_item
operator|->
name|font
operator|->
name|klass
operator|->
name|canRender
argument_list|(
name|shaper_item
operator|->
name|font
argument_list|,
operator|(
name|HB_UChar16
operator|*
operator|)
operator|&
name|shaped
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|shapedChars
index|[
name|cluster_start
index|]
operator|=
name|shaped
expr_stmt|;
block|}
else|else
name|shaped
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|shaped
condition|)
block|{
name|HB_CharCategory
name|category
decl_stmt|;
name|int
name|cmb
decl_stmt|;
name|shapedChars
index|[
name|slen
index|]
operator|=
name|uc
index|[
name|i
index|]
expr_stmt|;
name|HB_GetUnicodeCharProperties
argument_list|(
name|uc
index|[
name|i
index|]
argument_list|,
operator|&
name|category
argument_list|,
operator|&
name|cmb
argument_list|)
expr_stmt|;
if|if
condition|(
name|category
operator|!=
name|HB_Mark_NonSpacing
condition|)
block|{
name|attributes
index|[
name|slen
index|]
operator|.
name|clusterStart
operator|=
name|TRUE
expr_stmt|;
name|attributes
index|[
name|slen
index|]
operator|.
name|mark
operator|=
name|FALSE
expr_stmt|;
name|attributes
index|[
name|slen
index|]
operator|.
name|combiningClass
operator|=
literal|0
expr_stmt|;
name|attributes
index|[
name|slen
index|]
operator|.
name|dontPrint
operator|=
name|HB_IsControlChar
argument_list|(
name|uc
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|cluster_start
operator|=
name|slen
expr_stmt|;
block|}
else|else
block|{
name|attributes
index|[
name|slen
index|]
operator|.
name|clusterStart
operator|=
name|FALSE
expr_stmt|;
name|attributes
index|[
name|slen
index|]
operator|.
name|mark
operator|=
name|TRUE
expr_stmt|;
name|attributes
index|[
name|slen
index|]
operator|.
name|combiningClass
operator|=
name|cmb
expr_stmt|;
block|}
operator|++
name|slen
expr_stmt|;
block|}
name|logClusters
index|[
name|i
index|]
operator|=
name|cluster_start
expr_stmt|;
block|}
name|haveGlyphs
operator|=
name|shaper_item
operator|->
name|font
operator|->
name|klass
operator|->
name|convertStringToGlyphIndices
argument_list|(
name|shaper_item
operator|->
name|font
argument_list|,
name|shapedChars
argument_list|,
name|slen
argument_list|,
name|shaper_item
operator|->
name|glyphs
argument_list|,
operator|&
name|shaper_item
operator|->
name|num_glyphs
argument_list|,
name|shaper_item
operator|->
name|item
operator|.
name|bidiLevel
operator|%
literal|2
argument_list|)
expr_stmt|;
name|HB_FREE_STACKARRAY
argument_list|(
name|shapedChars
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|haveGlyphs
condition|)
return|return
name|FALSE
return|;
name|HB_HeuristicPosition
argument_list|(
name|shaper_item
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function
end_unit
