begin_unit
begin_comment
comment|/*  *    Stack-less Just-In-Time compiler  *  *    Copyright 2009-2012 Zoltan Herczeg (hzmester@freemail.hu). All rights reserved.  *  * Redistribution and use in source and binary forms, with or without modification, are  * permitted provided that the following conditions are met:  *  *   1. Redistributions of source code must retain the above copyright notice, this list of  *      conditions and the following disclaimer.  *  *   2. Redistributions in binary form must reproduce the above copyright notice, this list  *      of conditions and the following disclaimer in the documentation and/or other materials  *      provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER(S) AND CONTRIBUTORS ``AS IS'' AND ANY  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT  * SHALL THE COPYRIGHT HOLDER(S) OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED  * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR  * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment
begin_comment
comment|/* mips 32-bit arch dependent functions. */
end_comment
begin_function
DECL|function|load_immediate
specifier|static
name|int
name|load_immediate
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|int
name|dst_ar
parameter_list|,
name|sljit_w
name|imm
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|imm
operator|&
operator|~
literal|0xffff
operator|)
condition|)
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|ORI
operator||
name|SA
argument_list|(
literal|0
argument_list|)
operator||
name|TA
argument_list|(
name|dst_ar
argument_list|)
operator||
name|IMM
argument_list|(
name|imm
argument_list|)
argument_list|,
name|dst_ar
argument_list|)
return|;
if|if
condition|(
name|imm
operator|<
literal|0
operator|&&
name|imm
operator|>=
name|SIMM_MIN
condition|)
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|ADDIU
operator||
name|SA
argument_list|(
literal|0
argument_list|)
operator||
name|TA
argument_list|(
name|dst_ar
argument_list|)
operator||
name|IMM
argument_list|(
name|imm
argument_list|)
argument_list|,
name|dst_ar
argument_list|)
return|;
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|LUI
operator||
name|TA
argument_list|(
name|dst_ar
argument_list|)
operator||
name|IMM
argument_list|(
name|imm
operator|>>
literal|16
argument_list|)
argument_list|,
name|dst_ar
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|imm
operator|&
literal|0xffff
operator|)
condition|?
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|ORI
operator||
name|SA
argument_list|(
name|dst_ar
argument_list|)
operator||
name|TA
argument_list|(
name|dst_ar
argument_list|)
operator||
name|IMM
argument_list|(
name|imm
argument_list|)
argument_list|,
name|dst_ar
argument_list|)
else|:
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_define
DECL|macro|EMIT_LOGICAL
define|#
directive|define
name|EMIT_LOGICAL
parameter_list|(
name|op_imm
parameter_list|,
name|op_norm
parameter_list|)
define|\
value|if (flags& SRC2_IMM) { \ 		if (op& SLJIT_SET_E) \ 			FAIL_IF(push_inst(compiler, op_imm | S(src1) | TA(EQUAL_FLAG) | IMM(src2), EQUAL_FLAG)); \ 		if (CHECK_FLAGS(SLJIT_SET_E)) \ 			FAIL_IF(push_inst(compiler, op_imm | S(src1) | T(dst) | IMM(src2), DR(dst))); \ 	} \ 	else { \ 		if (op& SLJIT_SET_E) \ 			FAIL_IF(push_inst(compiler, op_norm | S(src1) | T(src2) | DA(EQUAL_FLAG), EQUAL_FLAG)); \ 		if (CHECK_FLAGS(SLJIT_SET_E)) \ 			FAIL_IF(push_inst(compiler, op_norm | S(src1) | T(src2) | D(dst), DR(dst))); \ 	}
end_define
begin_define
DECL|macro|EMIT_SHIFT
define|#
directive|define
name|EMIT_SHIFT
parameter_list|(
name|op_imm
parameter_list|,
name|op_norm
parameter_list|)
define|\
value|if (flags& SRC2_IMM) { \ 		if (op& SLJIT_SET_E) \ 			FAIL_IF(push_inst(compiler, op_imm | T(src1) | DA(EQUAL_FLAG) | SH_IMM(src2), EQUAL_FLAG)); \ 		if (CHECK_FLAGS(SLJIT_SET_E)) \ 			FAIL_IF(push_inst(compiler, op_imm | T(src1) | D(dst) | SH_IMM(src2), DR(dst))); \ 	} \ 	else { \ 		if (op& SLJIT_SET_E) \ 			FAIL_IF(push_inst(compiler, op_norm | S(src2) | T(src1) | DA(EQUAL_FLAG), EQUAL_FLAG)); \ 		if (CHECK_FLAGS(SLJIT_SET_E)) \ 			FAIL_IF(push_inst(compiler, op_norm | S(src2) | T(src1) | D(dst), DR(dst))); \ 	}
end_define
begin_function
DECL|function|emit_single_op
specifier|static
name|SLJIT_INLINE
name|int
name|emit_single_op
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|int
name|op
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|dst
parameter_list|,
name|int
name|src1
parameter_list|,
name|sljit_w
name|src2
parameter_list|)
block|{
name|int
name|overflow_ra
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|SLJIT_ADD
case|:
if|if
condition|(
name|flags
operator|&
name|SRC2_IMM
condition|)
block|{
if|if
condition|(
name|op
operator|&
name|SLJIT_SET_O
condition|)
block|{
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|SRL
operator||
name|T
argument_list|(
name|src1
argument_list|)
operator||
name|DA
argument_list|(
name|TMP_EREG1
argument_list|)
operator||
name|SH_IMM
argument_list|(
literal|31
argument_list|)
argument_list|,
name|TMP_EREG1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|src2
operator|<
literal|0
condition|)
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|XORI
operator||
name|SA
argument_list|(
name|TMP_EREG1
argument_list|)
operator||
name|TA
argument_list|(
name|TMP_EREG1
argument_list|)
operator||
name|IMM
argument_list|(
literal|1
argument_list|)
argument_list|,
name|TMP_EREG1
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|op
operator|&
name|SLJIT_SET_E
condition|)
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|ADDIU
operator||
name|S
argument_list|(
name|src1
argument_list|)
operator||
name|TA
argument_list|(
name|EQUAL_FLAG
argument_list|)
operator||
name|IMM
argument_list|(
name|src2
argument_list|)
argument_list|,
name|EQUAL_FLAG
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|&
name|SLJIT_SET_C
condition|)
block|{
if|if
condition|(
name|src2
operator|>=
literal|0
condition|)
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|ORI
operator||
name|S
argument_list|(
name|src1
argument_list|)
operator||
name|TA
argument_list|(
name|ULESS_FLAG
argument_list|)
operator||
name|IMM
argument_list|(
name|src2
argument_list|)
argument_list|,
name|ULESS_FLAG
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|ADDIU
operator||
name|SA
argument_list|(
literal|0
argument_list|)
operator||
name|TA
argument_list|(
name|ULESS_FLAG
argument_list|)
operator||
name|IMM
argument_list|(
name|src2
argument_list|)
argument_list|,
name|ULESS_FLAG
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|OR
operator||
name|S
argument_list|(
name|src1
argument_list|)
operator||
name|TA
argument_list|(
name|ULESS_FLAG
argument_list|)
operator||
name|DA
argument_list|(
name|ULESS_FLAG
argument_list|)
argument_list|,
name|ULESS_FLAG
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* dst may be the same as src1 or src2. */
if|if
condition|(
name|CHECK_FLAGS
argument_list|(
name|SLJIT_SET_E
argument_list|)
condition|)
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|ADDIU
operator||
name|S
argument_list|(
name|src1
argument_list|)
operator||
name|T
argument_list|(
name|dst
argument_list|)
operator||
name|IMM
argument_list|(
name|src2
argument_list|)
argument_list|,
name|DR
argument_list|(
name|dst
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|&
name|SLJIT_SET_O
condition|)
block|{
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|SRL
operator||
name|T
argument_list|(
name|dst
argument_list|)
operator||
name|DA
argument_list|(
name|OVERFLOW_FLAG
argument_list|)
operator||
name|SH_IMM
argument_list|(
literal|31
argument_list|)
argument_list|,
name|OVERFLOW_FLAG
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|src2
operator|<
literal|0
condition|)
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|XORI
operator||
name|SA
argument_list|(
name|OVERFLOW_FLAG
argument_list|)
operator||
name|TA
argument_list|(
name|OVERFLOW_FLAG
argument_list|)
operator||
name|IMM
argument_list|(
literal|1
argument_list|)
argument_list|,
name|OVERFLOW_FLAG
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|op
operator|&
name|SLJIT_SET_O
condition|)
block|{
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|XOR
operator||
name|S
argument_list|(
name|src1
argument_list|)
operator||
name|T
argument_list|(
name|src2
argument_list|)
operator||
name|DA
argument_list|(
name|TMP_EREG1
argument_list|)
argument_list|,
name|TMP_EREG1
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|SRL
operator||
name|TA
argument_list|(
name|TMP_EREG1
argument_list|)
operator||
name|DA
argument_list|(
name|TMP_EREG1
argument_list|)
operator||
name|SH_IMM
argument_list|(
literal|31
argument_list|)
argument_list|,
name|TMP_EREG1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|src1
operator|!=
name|dst
condition|)
name|overflow_ra
operator|=
name|DR
argument_list|(
name|src1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|src2
operator|!=
name|dst
condition|)
name|overflow_ra
operator|=
name|DR
argument_list|(
name|src2
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Rare ocasion. */
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|ADDU
operator||
name|S
argument_list|(
name|src1
argument_list|)
operator||
name|TA
argument_list|(
literal|0
argument_list|)
operator||
name|DA
argument_list|(
name|TMP_EREG2
argument_list|)
argument_list|,
name|TMP_EREG2
argument_list|)
argument_list|)
expr_stmt|;
name|overflow_ra
operator|=
name|TMP_EREG2
expr_stmt|;
block|}
block|}
if|if
condition|(
name|op
operator|&
name|SLJIT_SET_E
condition|)
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|ADDU
operator||
name|S
argument_list|(
name|src1
argument_list|)
operator||
name|T
argument_list|(
name|src2
argument_list|)
operator||
name|DA
argument_list|(
name|EQUAL_FLAG
argument_list|)
argument_list|,
name|EQUAL_FLAG
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|&
name|SLJIT_SET_C
condition|)
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|OR
operator||
name|S
argument_list|(
name|src1
argument_list|)
operator||
name|T
argument_list|(
name|src2
argument_list|)
operator||
name|DA
argument_list|(
name|ULESS_FLAG
argument_list|)
argument_list|,
name|ULESS_FLAG
argument_list|)
argument_list|)
expr_stmt|;
comment|/* dst may be the same as src1 or src2. */
if|if
condition|(
name|CHECK_FLAGS
argument_list|(
name|SLJIT_SET_E
argument_list|)
condition|)
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|ADDU
operator||
name|S
argument_list|(
name|src1
argument_list|)
operator||
name|T
argument_list|(
name|src2
argument_list|)
operator||
name|D
argument_list|(
name|dst
argument_list|)
argument_list|,
name|DR
argument_list|(
name|dst
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|&
name|SLJIT_SET_O
condition|)
block|{
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|XOR
operator||
name|S
argument_list|(
name|dst
argument_list|)
operator||
name|TA
argument_list|(
name|overflow_ra
argument_list|)
operator||
name|DA
argument_list|(
name|OVERFLOW_FLAG
argument_list|)
argument_list|,
name|OVERFLOW_FLAG
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|SRL
operator||
name|TA
argument_list|(
name|OVERFLOW_FLAG
argument_list|)
operator||
name|DA
argument_list|(
name|OVERFLOW_FLAG
argument_list|)
operator||
name|SH_IMM
argument_list|(
literal|31
argument_list|)
argument_list|,
name|OVERFLOW_FLAG
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* a + b>= a | b (otherwise, the carry should be set to 1). */
if|if
condition|(
name|op
operator|&
name|SLJIT_SET_C
condition|)
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|SLTU
operator||
name|S
argument_list|(
name|dst
argument_list|)
operator||
name|TA
argument_list|(
name|ULESS_FLAG
argument_list|)
operator||
name|DA
argument_list|(
name|ULESS_FLAG
argument_list|)
argument_list|,
name|ULESS_FLAG
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|&
name|SLJIT_SET_O
condition|)
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|MOVN
operator||
name|SA
argument_list|(
literal|0
argument_list|)
operator||
name|TA
argument_list|(
name|TMP_EREG1
argument_list|)
operator||
name|DA
argument_list|(
name|OVERFLOW_FLAG
argument_list|)
argument_list|,
name|OVERFLOW_FLAG
argument_list|)
return|;
return|return
name|SLJIT_SUCCESS
return|;
case|case
name|SLJIT_ADDC
case|:
if|if
condition|(
name|flags
operator|&
name|SRC2_IMM
condition|)
block|{
if|if
condition|(
name|op
operator|&
name|SLJIT_SET_C
condition|)
block|{
if|if
condition|(
name|src2
operator|>=
literal|0
condition|)
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|ORI
operator||
name|S
argument_list|(
name|src1
argument_list|)
operator||
name|TA
argument_list|(
name|TMP_EREG1
argument_list|)
operator||
name|IMM
argument_list|(
name|src2
argument_list|)
argument_list|,
name|TMP_EREG1
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|ADDIU
operator||
name|SA
argument_list|(
literal|0
argument_list|)
operator||
name|TA
argument_list|(
name|TMP_EREG1
argument_list|)
operator||
name|IMM
argument_list|(
name|src2
argument_list|)
argument_list|,
name|TMP_EREG1
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|OR
operator||
name|S
argument_list|(
name|src1
argument_list|)
operator||
name|TA
argument_list|(
name|TMP_EREG1
argument_list|)
operator||
name|DA
argument_list|(
name|TMP_EREG1
argument_list|)
argument_list|,
name|TMP_EREG1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|ADDIU
operator||
name|S
argument_list|(
name|src1
argument_list|)
operator||
name|T
argument_list|(
name|dst
argument_list|)
operator||
name|IMM
argument_list|(
name|src2
argument_list|)
argument_list|,
name|DR
argument_list|(
name|dst
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|op
operator|&
name|SLJIT_SET_C
condition|)
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|OR
operator||
name|S
argument_list|(
name|src1
argument_list|)
operator||
name|T
argument_list|(
name|src2
argument_list|)
operator||
name|DA
argument_list|(
name|TMP_EREG1
argument_list|)
argument_list|,
name|TMP_EREG1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* dst may be the same as src1 or src2. */
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|ADDU
operator||
name|S
argument_list|(
name|src1
argument_list|)
operator||
name|T
argument_list|(
name|src2
argument_list|)
operator||
name|D
argument_list|(
name|dst
argument_list|)
argument_list|,
name|DR
argument_list|(
name|dst
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|op
operator|&
name|SLJIT_SET_C
condition|)
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|SLTU
operator||
name|S
argument_list|(
name|dst
argument_list|)
operator||
name|TA
argument_list|(
name|TMP_EREG1
argument_list|)
operator||
name|DA
argument_list|(
name|TMP_EREG1
argument_list|)
argument_list|,
name|TMP_EREG1
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|ADDU
operator||
name|S
argument_list|(
name|dst
argument_list|)
operator||
name|TA
argument_list|(
name|ULESS_FLAG
argument_list|)
operator||
name|D
argument_list|(
name|dst
argument_list|)
argument_list|,
name|DR
argument_list|(
name|dst
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|op
operator|&
name|SLJIT_SET_C
operator|)
condition|)
return|return
name|SLJIT_SUCCESS
return|;
comment|/* Set TMP_EREG2 (dst == 0)&& (ULESS_FLAG == 1). */
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|SLTIU
operator||
name|S
argument_list|(
name|dst
argument_list|)
operator||
name|TA
argument_list|(
name|TMP_EREG2
argument_list|)
operator||
name|IMM
argument_list|(
literal|1
argument_list|)
argument_list|,
name|TMP_EREG2
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|AND
operator||
name|SA
argument_list|(
name|TMP_EREG2
argument_list|)
operator||
name|TA
argument_list|(
name|ULESS_FLAG
argument_list|)
operator||
name|DA
argument_list|(
name|TMP_EREG2
argument_list|)
argument_list|,
name|TMP_EREG2
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set carry flag. */
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|OR
operator||
name|SA
argument_list|(
name|TMP_EREG2
argument_list|)
operator||
name|TA
argument_list|(
name|TMP_EREG1
argument_list|)
operator||
name|DA
argument_list|(
name|ULESS_FLAG
argument_list|)
argument_list|,
name|ULESS_FLAG
argument_list|)
return|;
case|case
name|SLJIT_SUB
case|:
if|if
condition|(
operator|(
name|flags
operator|&
name|SRC2_IMM
operator|)
operator|&&
operator|(
operator|(
name|op
operator|&
operator|(
name|SLJIT_SET_S
operator||
name|SLJIT_SET_U
operator|)
operator|)
operator|||
name|src2
operator|==
name|SIMM_MIN
operator|)
condition|)
block|{
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|ADDIU
operator||
name|SA
argument_list|(
literal|0
argument_list|)
operator||
name|T
argument_list|(
name|TMP_REG2
argument_list|)
operator||
name|IMM
argument_list|(
name|src2
argument_list|)
argument_list|,
name|DR
argument_list|(
name|TMP_REG2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|src2
operator|=
name|TMP_REG2
expr_stmt|;
name|flags
operator|&=
operator|~
name|SRC2_IMM
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|SRC2_IMM
condition|)
block|{
if|if
condition|(
name|op
operator|&
name|SLJIT_SET_O
condition|)
block|{
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|SRL
operator||
name|T
argument_list|(
name|src1
argument_list|)
operator||
name|DA
argument_list|(
name|TMP_EREG1
argument_list|)
operator||
name|SH_IMM
argument_list|(
literal|31
argument_list|)
argument_list|,
name|TMP_EREG1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|src2
operator|<
literal|0
condition|)
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|XORI
operator||
name|SA
argument_list|(
name|TMP_EREG1
argument_list|)
operator||
name|TA
argument_list|(
name|TMP_EREG1
argument_list|)
operator||
name|IMM
argument_list|(
literal|1
argument_list|)
argument_list|,
name|TMP_EREG1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|src1
operator|!=
name|dst
condition|)
name|overflow_ra
operator|=
name|DR
argument_list|(
name|src1
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Rare ocasion. */
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|ADDU
operator||
name|S
argument_list|(
name|src1
argument_list|)
operator||
name|TA
argument_list|(
literal|0
argument_list|)
operator||
name|DA
argument_list|(
name|TMP_EREG2
argument_list|)
argument_list|,
name|TMP_EREG2
argument_list|)
argument_list|)
expr_stmt|;
name|overflow_ra
operator|=
name|TMP_EREG2
expr_stmt|;
block|}
block|}
if|if
condition|(
name|op
operator|&
name|SLJIT_SET_E
condition|)
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|ADDIU
operator||
name|S
argument_list|(
name|src1
argument_list|)
operator||
name|TA
argument_list|(
name|EQUAL_FLAG
argument_list|)
operator||
name|IMM
argument_list|(
operator|-
name|src2
argument_list|)
argument_list|,
name|EQUAL_FLAG
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|&
name|SLJIT_SET_C
condition|)
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|SLTIU
operator||
name|S
argument_list|(
name|src1
argument_list|)
operator||
name|TA
argument_list|(
name|ULESS_FLAG
argument_list|)
operator||
name|IMM
argument_list|(
name|src2
argument_list|)
argument_list|,
name|ULESS_FLAG
argument_list|)
argument_list|)
expr_stmt|;
comment|/* dst may be the same as src1 or src2. */
if|if
condition|(
name|CHECK_FLAGS
argument_list|(
name|SLJIT_SET_E
argument_list|)
condition|)
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|ADDIU
operator||
name|S
argument_list|(
name|src1
argument_list|)
operator||
name|T
argument_list|(
name|dst
argument_list|)
operator||
name|IMM
argument_list|(
operator|-
name|src2
argument_list|)
argument_list|,
name|DR
argument_list|(
name|dst
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|op
operator|&
name|SLJIT_SET_O
condition|)
block|{
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|XOR
operator||
name|S
argument_list|(
name|src1
argument_list|)
operator||
name|T
argument_list|(
name|src2
argument_list|)
operator||
name|DA
argument_list|(
name|TMP_EREG1
argument_list|)
argument_list|,
name|TMP_EREG1
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|SRL
operator||
name|TA
argument_list|(
name|TMP_EREG1
argument_list|)
operator||
name|DA
argument_list|(
name|TMP_EREG1
argument_list|)
operator||
name|SH_IMM
argument_list|(
literal|31
argument_list|)
argument_list|,
name|TMP_EREG1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|src1
operator|!=
name|dst
condition|)
name|overflow_ra
operator|=
name|DR
argument_list|(
name|src1
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Rare ocasion. */
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|ADDU
operator||
name|S
argument_list|(
name|src1
argument_list|)
operator||
name|TA
argument_list|(
literal|0
argument_list|)
operator||
name|DA
argument_list|(
name|TMP_EREG2
argument_list|)
argument_list|,
name|TMP_EREG2
argument_list|)
argument_list|)
expr_stmt|;
name|overflow_ra
operator|=
name|TMP_EREG2
expr_stmt|;
block|}
block|}
if|if
condition|(
name|op
operator|&
name|SLJIT_SET_E
condition|)
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|SUBU
operator||
name|S
argument_list|(
name|src1
argument_list|)
operator||
name|T
argument_list|(
name|src2
argument_list|)
operator||
name|DA
argument_list|(
name|EQUAL_FLAG
argument_list|)
argument_list|,
name|EQUAL_FLAG
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|&
operator|(
name|SLJIT_SET_U
operator||
name|SLJIT_SET_C
operator|)
condition|)
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|SLTU
operator||
name|S
argument_list|(
name|src1
argument_list|)
operator||
name|T
argument_list|(
name|src2
argument_list|)
operator||
name|DA
argument_list|(
name|ULESS_FLAG
argument_list|)
argument_list|,
name|ULESS_FLAG
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|&
name|SLJIT_SET_U
condition|)
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|SLTU
operator||
name|S
argument_list|(
name|src2
argument_list|)
operator||
name|T
argument_list|(
name|src1
argument_list|)
operator||
name|DA
argument_list|(
name|UGREATER_FLAG
argument_list|)
argument_list|,
name|UGREATER_FLAG
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|&
name|SLJIT_SET_S
condition|)
block|{
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|SLT
operator||
name|S
argument_list|(
name|src1
argument_list|)
operator||
name|T
argument_list|(
name|src2
argument_list|)
operator||
name|DA
argument_list|(
name|LESS_FLAG
argument_list|)
argument_list|,
name|LESS_FLAG
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|SLT
operator||
name|S
argument_list|(
name|src2
argument_list|)
operator||
name|T
argument_list|(
name|src1
argument_list|)
operator||
name|DA
argument_list|(
name|GREATER_FLAG
argument_list|)
argument_list|,
name|GREATER_FLAG
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* dst may be the same as src1 or src2. */
if|if
condition|(
name|CHECK_FLAGS
argument_list|(
name|SLJIT_SET_E
operator||
name|SLJIT_SET_S
operator||
name|SLJIT_SET_U
operator||
name|SLJIT_SET_C
argument_list|)
condition|)
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|SUBU
operator||
name|S
argument_list|(
name|src1
argument_list|)
operator||
name|T
argument_list|(
name|src2
argument_list|)
operator||
name|D
argument_list|(
name|dst
argument_list|)
argument_list|,
name|DR
argument_list|(
name|dst
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|op
operator|&
name|SLJIT_SET_O
condition|)
block|{
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|XOR
operator||
name|S
argument_list|(
name|dst
argument_list|)
operator||
name|TA
argument_list|(
name|overflow_ra
argument_list|)
operator||
name|DA
argument_list|(
name|OVERFLOW_FLAG
argument_list|)
argument_list|,
name|OVERFLOW_FLAG
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|SRL
operator||
name|TA
argument_list|(
name|OVERFLOW_FLAG
argument_list|)
operator||
name|DA
argument_list|(
name|OVERFLOW_FLAG
argument_list|)
operator||
name|SH_IMM
argument_list|(
literal|31
argument_list|)
argument_list|,
name|OVERFLOW_FLAG
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|MOVZ
operator||
name|SA
argument_list|(
literal|0
argument_list|)
operator||
name|TA
argument_list|(
name|TMP_EREG1
argument_list|)
operator||
name|DA
argument_list|(
name|OVERFLOW_FLAG
argument_list|)
argument_list|,
name|OVERFLOW_FLAG
argument_list|)
return|;
block|}
return|return
name|SLJIT_SUCCESS
return|;
case|case
name|SLJIT_SUBC
case|:
if|if
condition|(
operator|(
name|flags
operator|&
name|SRC2_IMM
operator|)
operator|&&
name|src2
operator|==
name|SIMM_MIN
condition|)
block|{
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|ADDIU
operator||
name|SA
argument_list|(
literal|0
argument_list|)
operator||
name|T
argument_list|(
name|TMP_REG2
argument_list|)
operator||
name|IMM
argument_list|(
name|src2
argument_list|)
argument_list|,
name|DR
argument_list|(
name|TMP_REG2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|src2
operator|=
name|TMP_REG2
expr_stmt|;
name|flags
operator|&=
operator|~
name|SRC2_IMM
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|SRC2_IMM
condition|)
block|{
if|if
condition|(
name|op
operator|&
name|SLJIT_SET_C
condition|)
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|SLTIU
operator||
name|S
argument_list|(
name|src1
argument_list|)
operator||
name|TA
argument_list|(
name|TMP_EREG1
argument_list|)
operator||
name|IMM
argument_list|(
operator|-
name|src2
argument_list|)
argument_list|,
name|TMP_EREG1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* dst may be the same as src1 or src2. */
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|ADDIU
operator||
name|S
argument_list|(
name|src1
argument_list|)
operator||
name|T
argument_list|(
name|dst
argument_list|)
operator||
name|IMM
argument_list|(
operator|-
name|src2
argument_list|)
argument_list|,
name|DR
argument_list|(
name|dst
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|op
operator|&
name|SLJIT_SET_C
condition|)
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|SLTU
operator||
name|S
argument_list|(
name|src1
argument_list|)
operator||
name|T
argument_list|(
name|src2
argument_list|)
operator||
name|DA
argument_list|(
name|TMP_EREG1
argument_list|)
argument_list|,
name|TMP_EREG1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* dst may be the same as src1 or src2. */
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|SUBU
operator||
name|S
argument_list|(
name|src1
argument_list|)
operator||
name|T
argument_list|(
name|src2
argument_list|)
operator||
name|D
argument_list|(
name|dst
argument_list|)
argument_list|,
name|DR
argument_list|(
name|dst
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|op
operator|&
name|SLJIT_SET_C
condition|)
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|MOVZ
operator||
name|SA
argument_list|(
name|ULESS_FLAG
argument_list|)
operator||
name|T
argument_list|(
name|dst
argument_list|)
operator||
name|DA
argument_list|(
name|TMP_EREG1
argument_list|)
argument_list|,
name|TMP_EREG1
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|SUBU
operator||
name|S
argument_list|(
name|dst
argument_list|)
operator||
name|TA
argument_list|(
name|ULESS_FLAG
argument_list|)
operator||
name|D
argument_list|(
name|dst
argument_list|)
argument_list|,
name|DR
argument_list|(
name|dst
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|&
name|SLJIT_SET_C
condition|)
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|ADDU
operator||
name|SA
argument_list|(
name|TMP_EREG1
argument_list|)
operator||
name|TA
argument_list|(
literal|0
argument_list|)
operator||
name|DA
argument_list|(
name|ULESS_FLAG
argument_list|)
argument_list|,
name|ULESS_FLAG
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
case|case
name|SLJIT_MUL
case|:
name|SLJIT_ASSERT
argument_list|(
operator|!
operator|(
name|flags
operator|&
name|SRC2_IMM
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|op
operator|&
name|SLJIT_SET_O
operator|)
condition|)
block|{
if|#
directive|if
operator|(
name|defined
name|SLJIT_MIPS_32_64
operator|&&
name|SLJIT_MIPS_32_64
operator|)
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|MUL
operator||
name|S
argument_list|(
name|src1
argument_list|)
operator||
name|T
argument_list|(
name|src2
argument_list|)
operator||
name|D
argument_list|(
name|dst
argument_list|)
argument_list|,
name|DR
argument_list|(
name|dst
argument_list|)
argument_list|)
return|;
else|#
directive|else
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|MULT
operator||
name|S
argument_list|(
name|src1
argument_list|)
operator||
name|T
argument_list|(
name|src2
argument_list|)
argument_list|,
name|MOVABLE_INS
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|MFLO
operator||
name|D
argument_list|(
name|dst
argument_list|)
argument_list|,
name|DR
argument_list|(
name|dst
argument_list|)
argument_list|)
return|;
endif|#
directive|endif
block|}
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|MULT
operator||
name|S
argument_list|(
name|src1
argument_list|)
operator||
name|T
argument_list|(
name|src2
argument_list|)
argument_list|,
name|MOVABLE_INS
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|MFHI
operator||
name|DA
argument_list|(
name|TMP_EREG1
argument_list|)
argument_list|,
name|TMP_EREG1
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|MFLO
operator||
name|D
argument_list|(
name|dst
argument_list|)
argument_list|,
name|DR
argument_list|(
name|dst
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|SRA
operator||
name|T
argument_list|(
name|dst
argument_list|)
operator||
name|DA
argument_list|(
name|TMP_EREG2
argument_list|)
operator||
name|SH_IMM
argument_list|(
literal|31
argument_list|)
argument_list|,
name|TMP_EREG2
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|SUBU
operator||
name|SA
argument_list|(
name|TMP_EREG1
argument_list|)
operator||
name|TA
argument_list|(
name|TMP_EREG2
argument_list|)
operator||
name|DA
argument_list|(
name|OVERFLOW_FLAG
argument_list|)
argument_list|,
name|OVERFLOW_FLAG
argument_list|)
return|;
case|case
name|SLJIT_AND
case|:
name|EMIT_LOGICAL
argument_list|(
name|ANDI
argument_list|,
name|AND
argument_list|)
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
case|case
name|SLJIT_OR
case|:
name|EMIT_LOGICAL
argument_list|(
name|ORI
argument_list|,
name|OR
argument_list|)
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
case|case
name|SLJIT_XOR
case|:
name|EMIT_LOGICAL
argument_list|(
name|XORI
argument_list|,
name|XOR
argument_list|)
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
case|case
name|SLJIT_SHL
case|:
name|EMIT_SHIFT
argument_list|(
name|SLL
argument_list|,
name|SLLV
argument_list|)
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
case|case
name|SLJIT_LSHR
case|:
name|EMIT_SHIFT
argument_list|(
name|SRL
argument_list|,
name|SRLV
argument_list|)
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
case|case
name|SLJIT_ASHR
case|:
name|EMIT_SHIFT
argument_list|(
name|SRA
argument_list|,
name|SRAV
argument_list|)
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
case|case
name|SLJIT_MOV
case|:
case|case
name|SLJIT_MOV_UI
case|:
case|case
name|SLJIT_MOV_SI
case|:
name|SLJIT_ASSERT
argument_list|(
name|src1
operator|==
name|TMP_REG1
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|!=
name|src2
condition|)
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|ADDU
operator||
name|S
argument_list|(
name|src2
argument_list|)
operator||
name|TA
argument_list|(
literal|0
argument_list|)
operator||
name|D
argument_list|(
name|dst
argument_list|)
argument_list|,
name|DR
argument_list|(
name|dst
argument_list|)
argument_list|)
return|;
return|return
name|SLJIT_SUCCESS
return|;
case|case
name|SLJIT_MOV_UB
case|:
case|case
name|SLJIT_MOV_SB
case|:
name|SLJIT_ASSERT
argument_list|(
name|src1
operator|==
name|TMP_REG1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|REG_DEST
operator||
name|REG2_SOURCE
operator|)
operator|)
operator|==
operator|(
name|REG_DEST
operator||
name|REG2_SOURCE
operator|)
condition|)
block|{
if|if
condition|(
name|op
operator|==
name|SLJIT_MOV_SB
condition|)
block|{
if|#
directive|if
operator|(
name|defined
name|SLJIT_MIPS_32_64
operator|&&
name|SLJIT_MIPS_32_64
operator|)
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|SEB
operator||
name|T
argument_list|(
name|src2
argument_list|)
operator||
name|D
argument_list|(
name|dst
argument_list|)
argument_list|,
name|DR
argument_list|(
name|dst
argument_list|)
argument_list|)
return|;
else|#
directive|else
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|SLL
operator||
name|T
argument_list|(
name|src2
argument_list|)
operator||
name|D
argument_list|(
name|dst
argument_list|)
operator||
name|SH_IMM
argument_list|(
literal|24
argument_list|)
argument_list|,
name|DR
argument_list|(
name|dst
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|SRA
operator||
name|T
argument_list|(
name|dst
argument_list|)
operator||
name|D
argument_list|(
name|dst
argument_list|)
operator||
name|SH_IMM
argument_list|(
literal|24
argument_list|)
argument_list|,
name|DR
argument_list|(
name|dst
argument_list|)
argument_list|)
return|;
endif|#
directive|endif
block|}
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|ANDI
operator||
name|S
argument_list|(
name|src2
argument_list|)
operator||
name|T
argument_list|(
name|dst
argument_list|)
operator||
name|IMM
argument_list|(
literal|0xff
argument_list|)
argument_list|,
name|DR
argument_list|(
name|dst
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|dst
operator|!=
name|src2
condition|)
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
case|case
name|SLJIT_MOV_UH
case|:
case|case
name|SLJIT_MOV_SH
case|:
name|SLJIT_ASSERT
argument_list|(
name|src1
operator|==
name|TMP_REG1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|REG_DEST
operator||
name|REG2_SOURCE
operator|)
operator|)
operator|==
operator|(
name|REG_DEST
operator||
name|REG2_SOURCE
operator|)
condition|)
block|{
if|if
condition|(
name|op
operator|==
name|SLJIT_MOV_SH
condition|)
block|{
if|#
directive|if
operator|(
name|defined
name|SLJIT_MIPS_32_64
operator|&&
name|SLJIT_MIPS_32_64
operator|)
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|SEH
operator||
name|T
argument_list|(
name|src2
argument_list|)
operator||
name|D
argument_list|(
name|dst
argument_list|)
argument_list|,
name|DR
argument_list|(
name|dst
argument_list|)
argument_list|)
return|;
else|#
directive|else
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|SLL
operator||
name|T
argument_list|(
name|src2
argument_list|)
operator||
name|D
argument_list|(
name|dst
argument_list|)
operator||
name|SH_IMM
argument_list|(
literal|16
argument_list|)
argument_list|,
name|DR
argument_list|(
name|dst
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|SRA
operator||
name|T
argument_list|(
name|dst
argument_list|)
operator||
name|D
argument_list|(
name|dst
argument_list|)
operator||
name|SH_IMM
argument_list|(
literal|16
argument_list|)
argument_list|,
name|DR
argument_list|(
name|dst
argument_list|)
argument_list|)
return|;
endif|#
directive|endif
block|}
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|ANDI
operator||
name|S
argument_list|(
name|src2
argument_list|)
operator||
name|T
argument_list|(
name|dst
argument_list|)
operator||
name|IMM
argument_list|(
literal|0xffff
argument_list|)
argument_list|,
name|DR
argument_list|(
name|dst
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|dst
operator|!=
name|src2
condition|)
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
case|case
name|SLJIT_NOT
case|:
name|SLJIT_ASSERT
argument_list|(
name|src1
operator|==
name|TMP_REG1
operator|&&
operator|!
operator|(
name|flags
operator|&
name|SRC2_IMM
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|&
name|SLJIT_SET_E
condition|)
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|NOR
operator||
name|S
argument_list|(
name|src2
argument_list|)
operator||
name|T
argument_list|(
name|src2
argument_list|)
operator||
name|DA
argument_list|(
name|EQUAL_FLAG
argument_list|)
argument_list|,
name|EQUAL_FLAG
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|CHECK_FLAGS
argument_list|(
name|SLJIT_SET_E
argument_list|)
condition|)
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|NOR
operator||
name|S
argument_list|(
name|src2
argument_list|)
operator||
name|T
argument_list|(
name|src2
argument_list|)
operator||
name|D
argument_list|(
name|dst
argument_list|)
argument_list|,
name|DR
argument_list|(
name|dst
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
case|case
name|SLJIT_CLZ
case|:
name|SLJIT_ASSERT
argument_list|(
name|src1
operator|==
name|TMP_REG1
operator|&&
operator|!
operator|(
name|flags
operator|&
name|SRC2_IMM
operator|)
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_MIPS_32_64
operator|&&
name|SLJIT_MIPS_32_64
operator|)
if|if
condition|(
name|op
operator|&
name|SLJIT_SET_E
condition|)
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|CLZ
operator||
name|S
argument_list|(
name|src2
argument_list|)
operator||
name|TA
argument_list|(
name|EQUAL_FLAG
argument_list|)
operator||
name|DA
argument_list|(
name|EQUAL_FLAG
argument_list|)
argument_list|,
name|EQUAL_FLAG
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|CHECK_FLAGS
argument_list|(
name|SLJIT_SET_E
argument_list|)
condition|)
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|CLZ
operator||
name|S
argument_list|(
name|src2
argument_list|)
operator||
name|T
argument_list|(
name|dst
argument_list|)
operator||
name|D
argument_list|(
name|dst
argument_list|)
argument_list|,
name|DR
argument_list|(
name|dst
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|flags
operator|&
name|UNUSED_DEST
argument_list|)
condition|)
block|{
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|SRL
operator||
name|T
argument_list|(
name|src2
argument_list|)
operator||
name|DA
argument_list|(
name|EQUAL_FLAG
argument_list|)
operator||
name|SH_IMM
argument_list|(
literal|31
argument_list|)
argument_list|,
name|EQUAL_FLAG
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|XORI
operator||
name|SA
argument_list|(
name|EQUAL_FLAG
argument_list|)
operator||
name|TA
argument_list|(
name|EQUAL_FLAG
argument_list|)
operator||
name|IMM
argument_list|(
literal|1
argument_list|)
argument_list|,
name|EQUAL_FLAG
argument_list|)
return|;
block|}
comment|/* Nearly all instructions are unmovable in the following sequence. */
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|ADDU_W
operator||
name|S
argument_list|(
name|src2
argument_list|)
operator||
name|TA
argument_list|(
literal|0
argument_list|)
operator||
name|D
argument_list|(
name|TMP_REG1
argument_list|)
argument_list|,
name|DR
argument_list|(
name|TMP_REG1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check zero. */
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|BEQ
operator||
name|S
argument_list|(
name|TMP_REG1
argument_list|)
operator||
name|TA
argument_list|(
literal|0
argument_list|)
operator||
name|IMM
argument_list|(
literal|6
argument_list|)
argument_list|,
name|UNMOVABLE_INS
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|ORI
operator||
name|SA
argument_list|(
literal|0
argument_list|)
operator||
name|T
argument_list|(
name|dst
argument_list|)
operator||
name|IMM
argument_list|(
literal|32
argument_list|)
argument_list|,
name|UNMOVABLE_INS
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check sign bit. */
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|BLTZ
operator||
name|S
argument_list|(
name|TMP_REG1
argument_list|)
operator||
name|IMM
argument_list|(
literal|4
argument_list|)
argument_list|,
name|UNMOVABLE_INS
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|ORI
operator||
name|SA
argument_list|(
literal|0
argument_list|)
operator||
name|T
argument_list|(
name|dst
argument_list|)
operator||
name|IMM
argument_list|(
literal|0
argument_list|)
argument_list|,
name|UNMOVABLE_INS
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Loop for searching the highest bit. */
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|SLL
operator||
name|T
argument_list|(
name|TMP_REG1
argument_list|)
operator||
name|D
argument_list|(
name|TMP_REG1
argument_list|)
operator||
name|SH_IMM
argument_list|(
literal|1
argument_list|)
argument_list|,
name|DR
argument_list|(
name|TMP_REG1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|BGEZ
operator||
name|S
argument_list|(
name|TMP_REG1
argument_list|)
operator||
name|IMM
argument_list|(
operator|-
literal|2
argument_list|)
argument_list|,
name|UNMOVABLE_INS
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|ADDIU_W
operator||
name|S
argument_list|(
name|dst
argument_list|)
operator||
name|T
argument_list|(
name|dst
argument_list|)
operator||
name|IMM
argument_list|(
literal|1
argument_list|)
argument_list|,
name|UNMOVABLE_INS
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|&
name|SLJIT_SET_E
condition|)
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|ADDU_W
operator||
name|S
argument_list|(
name|dst
argument_list|)
operator||
name|TA
argument_list|(
literal|0
argument_list|)
operator||
name|DA
argument_list|(
name|EQUAL_FLAG
argument_list|)
argument_list|,
name|EQUAL_FLAG
argument_list|)
return|;
endif|#
directive|endif
return|return
name|SLJIT_SUCCESS
return|;
block|}
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_function
DECL|function|emit_const
specifier|static
name|SLJIT_INLINE
name|int
name|emit_const
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|int
name|reg
parameter_list|,
name|sljit_w
name|init_value
parameter_list|)
block|{
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|LUI
operator||
name|T
argument_list|(
name|reg
argument_list|)
operator||
name|IMM
argument_list|(
name|init_value
operator|>>
literal|16
argument_list|)
argument_list|,
name|DR
argument_list|(
name|reg
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|ORI
operator||
name|S
argument_list|(
name|reg
argument_list|)
operator||
name|T
argument_list|(
name|reg
argument_list|)
operator||
name|IMM
argument_list|(
name|init_value
argument_list|)
argument_list|,
name|DR
argument_list|(
name|reg
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|sljit_set_jump_addr
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
name|sljit_set_jump_addr
parameter_list|(
name|sljit_uw
name|addr
parameter_list|,
name|sljit_uw
name|new_addr
parameter_list|)
block|{
name|sljit_ins
modifier|*
name|inst
init|=
operator|(
name|sljit_ins
operator|*
operator|)
name|addr
decl_stmt|;
name|inst
index|[
literal|0
index|]
operator|=
operator|(
name|inst
index|[
literal|0
index|]
operator|&
literal|0xffff0000
operator|)
operator||
operator|(
operator|(
name|new_addr
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|inst
index|[
literal|1
index|]
operator|=
operator|(
name|inst
index|[
literal|1
index|]
operator|&
literal|0xffff0000
operator|)
operator||
operator|(
name|new_addr
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|SLJIT_CACHE_FLUSH
argument_list|(
name|inst
argument_list|,
name|inst
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|sljit_set_const
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
name|sljit_set_const
parameter_list|(
name|sljit_uw
name|addr
parameter_list|,
name|sljit_w
name|new_constant
parameter_list|)
block|{
name|sljit_ins
modifier|*
name|inst
init|=
operator|(
name|sljit_ins
operator|*
operator|)
name|addr
decl_stmt|;
name|inst
index|[
literal|0
index|]
operator|=
operator|(
name|inst
index|[
literal|0
index|]
operator|&
literal|0xffff0000
operator|)
operator||
operator|(
operator|(
name|new_constant
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|inst
index|[
literal|1
index|]
operator|=
operator|(
name|inst
index|[
literal|1
index|]
operator|&
literal|0xffff0000
operator|)
operator||
operator|(
name|new_constant
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|SLJIT_CACHE_FLUSH
argument_list|(
name|inst
argument_list|,
name|inst
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
end_function
end_unit
