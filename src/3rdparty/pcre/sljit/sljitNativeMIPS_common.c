begin_unit
begin_comment
comment|/*  *    Stack-less Just-In-Time compiler  *  *    Copyright 2009-2012 Zoltan Herczeg (hzmester@freemail.hu). All rights reserved.  *  * Redistribution and use in source and binary forms, with or without modification, are  * permitted provided that the following conditions are met:  *  *   1. Redistributions of source code must retain the above copyright notice, this list of  *      conditions and the following disclaimer.  *  *   2. Redistributions in binary form must reproduce the above copyright notice, this list  *      of conditions and the following disclaimer in the documentation and/or other materials  *      provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER(S) AND CONTRIBUTORS ``AS IS'' AND ANY  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT  * SHALL THE COPYRIGHT HOLDER(S) OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED  * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR  * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment
begin_comment
comment|/* Latest MIPS architecture. */
end_comment
begin_comment
comment|/* Automatically detect SLJIT_MIPS_32_64 */
end_comment
begin_function
DECL|function|sljit_get_platform_name
name|SLJIT_API_FUNC_ATTRIBUTE
name|SLJIT_CONST
name|char
modifier|*
name|sljit_get_platform_name
parameter_list|(
name|void
parameter_list|)
block|{
if|#
directive|if
operator|(
name|defined
name|SLJIT_MIPS_32_64
operator|&&
name|SLJIT_MIPS_32_64
operator|)
return|return
literal|"MIPS V"
name|SLJIT_CPUINFO
return|;
else|#
directive|else
return|return
literal|"MIPS III"
name|SLJIT_CPUINFO
return|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/* Length of an instruction word    Both for mips-32 and mips-64 */
end_comment
begin_typedef
DECL|typedef|sljit_ins
typedef|typedef
name|sljit_ui
name|sljit_ins
typedef|;
end_typedef
begin_define
DECL|macro|TMP_REG1
define|#
directive|define
name|TMP_REG1
value|(SLJIT_NO_REGISTERS + 1)
end_define
begin_define
DECL|macro|TMP_REG2
define|#
directive|define
name|TMP_REG2
value|(SLJIT_NO_REGISTERS + 2)
end_define
begin_define
DECL|macro|TMP_REG3
define|#
directive|define
name|TMP_REG3
value|(SLJIT_NO_REGISTERS + 3)
end_define
begin_comment
comment|/* For position independent code, t9 must contain the function address. */
end_comment
begin_define
DECL|macro|PIC_ADDR_REG
define|#
directive|define
name|PIC_ADDR_REG
value|TMP_REG2
end_define
begin_comment
comment|/* TMP_EREGs are used mainly for arithmetic operations. */
end_comment
begin_define
DECL|macro|TMP_EREG1
define|#
directive|define
name|TMP_EREG1
value|15
end_define
begin_define
DECL|macro|TMP_EREG2
define|#
directive|define
name|TMP_EREG2
value|24
end_define
begin_comment
comment|/* Floating point status register. */
end_comment
begin_define
DECL|macro|FCSR_REG
define|#
directive|define
name|FCSR_REG
value|31
end_define
begin_comment
comment|/* Return address register. */
end_comment
begin_define
DECL|macro|RETURN_ADDR_REG
define|#
directive|define
name|RETURN_ADDR_REG
value|31
end_define
begin_comment
comment|/* Flags are keept in volatile registers. */
end_comment
begin_define
DECL|macro|EQUAL_FLAG
define|#
directive|define
name|EQUAL_FLAG
value|7
end_define
begin_comment
comment|/* And carry flag as well. */
end_comment
begin_define
DECL|macro|ULESS_FLAG
define|#
directive|define
name|ULESS_FLAG
value|10
end_define
begin_define
DECL|macro|UGREATER_FLAG
define|#
directive|define
name|UGREATER_FLAG
value|11
end_define
begin_define
DECL|macro|LESS_FLAG
define|#
directive|define
name|LESS_FLAG
value|12
end_define
begin_define
DECL|macro|GREATER_FLAG
define|#
directive|define
name|GREATER_FLAG
value|13
end_define
begin_define
DECL|macro|OVERFLOW_FLAG
define|#
directive|define
name|OVERFLOW_FLAG
value|14
end_define
begin_define
DECL|macro|TMP_FREG1
define|#
directive|define
name|TMP_FREG1
value|(0)
end_define
begin_define
DECL|macro|TMP_FREG2
define|#
directive|define
name|TMP_FREG2
value|((SLJIT_FLOAT_REG6 + 1)<< 1)
end_define
begin_decl_stmt
DECL|variable|reg_map
specifier|static
name|SLJIT_CONST
name|sljit_ub
name|reg_map
index|[
name|SLJIT_NO_REGISTERS
operator|+
literal|4
index|]
init|=
block|{
literal|0
block|,
literal|2
block|,
literal|5
block|,
literal|6
block|,
literal|3
block|,
literal|8
block|,
literal|16
block|,
literal|17
block|,
literal|18
block|,
literal|19
block|,
literal|20
block|,
literal|29
block|,
literal|4
block|,
literal|25
block|,
literal|9
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_comment
comment|/*  Instrucion forms                                                     */
end_comment
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_define
DECL|macro|S
define|#
directive|define
name|S
parameter_list|(
name|s
parameter_list|)
value|(reg_map[s]<< 21)
end_define
begin_define
DECL|macro|T
define|#
directive|define
name|T
parameter_list|(
name|t
parameter_list|)
value|(reg_map[t]<< 16)
end_define
begin_define
DECL|macro|D
define|#
directive|define
name|D
parameter_list|(
name|d
parameter_list|)
value|(reg_map[d]<< 11)
end_define
begin_comment
comment|/* Absolute registers. */
end_comment
begin_define
DECL|macro|SA
define|#
directive|define
name|SA
parameter_list|(
name|s
parameter_list|)
value|((s)<< 21)
end_define
begin_define
DECL|macro|TA
define|#
directive|define
name|TA
parameter_list|(
name|t
parameter_list|)
value|((t)<< 16)
end_define
begin_define
DECL|macro|DA
define|#
directive|define
name|DA
parameter_list|(
name|d
parameter_list|)
value|((d)<< 11)
end_define
begin_define
DECL|macro|FT
define|#
directive|define
name|FT
parameter_list|(
name|t
parameter_list|)
value|((t)<< 16)
end_define
begin_define
DECL|macro|FS
define|#
directive|define
name|FS
parameter_list|(
name|s
parameter_list|)
value|((s)<< 11)
end_define
begin_define
DECL|macro|FD
define|#
directive|define
name|FD
parameter_list|(
name|d
parameter_list|)
value|((d)<< 6)
end_define
begin_define
DECL|macro|IMM
define|#
directive|define
name|IMM
parameter_list|(
name|imm
parameter_list|)
value|((imm)& 0xffff)
end_define
begin_define
DECL|macro|SH_IMM
define|#
directive|define
name|SH_IMM
parameter_list|(
name|imm
parameter_list|)
value|((imm)<< 6)
end_define
begin_define
DECL|macro|DR
define|#
directive|define
name|DR
parameter_list|(
name|dr
parameter_list|)
value|(reg_map[dr])
end_define
begin_define
DECL|macro|HI
define|#
directive|define
name|HI
parameter_list|(
name|opcode
parameter_list|)
value|((opcode)<< 26)
end_define
begin_define
DECL|macro|LO
define|#
directive|define
name|LO
parameter_list|(
name|opcode
parameter_list|)
value|(opcode)
end_define
begin_comment
comment|/* S = (16<< 21) D = (17<< 21) */
end_comment
begin_define
DECL|macro|FMT_SD
define|#
directive|define
name|FMT_SD
value|(16<< 21)
end_define
begin_define
DECL|macro|ABS_fmt
define|#
directive|define
name|ABS_fmt
value|(HI(17) | FMT_SD | LO(5))
end_define
begin_define
DECL|macro|ADD_fmt
define|#
directive|define
name|ADD_fmt
value|(HI(17) | FMT_SD | LO(0))
end_define
begin_define
DECL|macro|ADDIU
define|#
directive|define
name|ADDIU
value|(HI(9))
end_define
begin_define
DECL|macro|ADDU
define|#
directive|define
name|ADDU
value|(HI(0) | LO(33))
end_define
begin_define
DECL|macro|AND
define|#
directive|define
name|AND
value|(HI(0) | LO(36))
end_define
begin_define
DECL|macro|ANDI
define|#
directive|define
name|ANDI
value|(HI(12))
end_define
begin_define
DECL|macro|B
define|#
directive|define
name|B
value|(HI(4))
end_define
begin_define
DECL|macro|BAL
define|#
directive|define
name|BAL
value|(HI(1) | (17<< 16))
end_define
begin_define
DECL|macro|BC1F
define|#
directive|define
name|BC1F
value|(HI(17) | (8<< 21))
end_define
begin_define
DECL|macro|BC1T
define|#
directive|define
name|BC1T
value|(HI(17) | (8<< 21) | (1<< 16))
end_define
begin_define
DECL|macro|BEQ
define|#
directive|define
name|BEQ
value|(HI(4))
end_define
begin_define
DECL|macro|BGEZ
define|#
directive|define
name|BGEZ
value|(HI(1) | (1<< 16))
end_define
begin_define
DECL|macro|BGTZ
define|#
directive|define
name|BGTZ
value|(HI(7))
end_define
begin_define
DECL|macro|BLEZ
define|#
directive|define
name|BLEZ
value|(HI(6))
end_define
begin_define
DECL|macro|BLTZ
define|#
directive|define
name|BLTZ
value|(HI(1) | (0<< 16))
end_define
begin_define
DECL|macro|BNE
define|#
directive|define
name|BNE
value|(HI(5))
end_define
begin_define
DECL|macro|BREAK
define|#
directive|define
name|BREAK
value|(HI(0) | LO(13))
end_define
begin_define
DECL|macro|CFC1
define|#
directive|define
name|CFC1
value|(HI(17) | (2<< 21))
end_define
begin_define
DECL|macro|C_UN_fmt
define|#
directive|define
name|C_UN_fmt
value|(HI(17) | FMT_SD | LO(49))
end_define
begin_define
DECL|macro|C_UEQ_fmt
define|#
directive|define
name|C_UEQ_fmt
value|(HI(17) | FMT_SD | LO(51))
end_define
begin_define
DECL|macro|C_ULE_fmt
define|#
directive|define
name|C_ULE_fmt
value|(HI(17) | FMT_SD | LO(55))
end_define
begin_define
DECL|macro|C_ULT_fmt
define|#
directive|define
name|C_ULT_fmt
value|(HI(17) | FMT_SD | LO(53))
end_define
begin_define
DECL|macro|DADDIU
define|#
directive|define
name|DADDIU
value|(HI(25))
end_define
begin_define
DECL|macro|DADDU
define|#
directive|define
name|DADDU
value|(HI(0) | LO(45))
end_define
begin_define
DECL|macro|DDIV
define|#
directive|define
name|DDIV
value|(HI(0) | LO(30))
end_define
begin_define
DECL|macro|DDIVU
define|#
directive|define
name|DDIVU
value|(HI(0) | LO(31))
end_define
begin_define
DECL|macro|DIV
define|#
directive|define
name|DIV
value|(HI(0) | LO(26))
end_define
begin_define
DECL|macro|DIVU
define|#
directive|define
name|DIVU
value|(HI(0) | LO(27))
end_define
begin_define
DECL|macro|DIV_fmt
define|#
directive|define
name|DIV_fmt
value|(HI(17) | FMT_SD | LO(3))
end_define
begin_define
DECL|macro|DMULT
define|#
directive|define
name|DMULT
value|(HI(0) | LO(28))
end_define
begin_define
DECL|macro|DMULTU
define|#
directive|define
name|DMULTU
value|(HI(0) | LO(29))
end_define
begin_define
DECL|macro|DSLL
define|#
directive|define
name|DSLL
value|(HI(0) | LO(56))
end_define
begin_define
DECL|macro|DSLL32
define|#
directive|define
name|DSLL32
value|(HI(0) | LO(60))
end_define
begin_define
DECL|macro|DSLLV
define|#
directive|define
name|DSLLV
value|(HI(0) | LO(20))
end_define
begin_define
DECL|macro|DSRA
define|#
directive|define
name|DSRA
value|(HI(0) | LO(59))
end_define
begin_define
DECL|macro|DSRA32
define|#
directive|define
name|DSRA32
value|(HI(0) | LO(63))
end_define
begin_define
DECL|macro|DSRAV
define|#
directive|define
name|DSRAV
value|(HI(0) | LO(23))
end_define
begin_define
DECL|macro|DSRL
define|#
directive|define
name|DSRL
value|(HI(0) | LO(58))
end_define
begin_define
DECL|macro|DSRL32
define|#
directive|define
name|DSRL32
value|(HI(0) | LO(62))
end_define
begin_define
DECL|macro|DSRLV
define|#
directive|define
name|DSRLV
value|(HI(0) | LO(22))
end_define
begin_define
DECL|macro|DSUBU
define|#
directive|define
name|DSUBU
value|(HI(0) | LO(47))
end_define
begin_define
DECL|macro|J
define|#
directive|define
name|J
value|(HI(2))
end_define
begin_define
DECL|macro|JAL
define|#
directive|define
name|JAL
value|(HI(3))
end_define
begin_define
DECL|macro|JALR
define|#
directive|define
name|JALR
value|(HI(0) | LO(9))
end_define
begin_define
DECL|macro|JR
define|#
directive|define
name|JR
value|(HI(0) | LO(8))
end_define
begin_define
DECL|macro|LD
define|#
directive|define
name|LD
value|(HI(55))
end_define
begin_define
DECL|macro|LUI
define|#
directive|define
name|LUI
value|(HI(15))
end_define
begin_define
DECL|macro|LW
define|#
directive|define
name|LW
value|(HI(35))
end_define
begin_define
DECL|macro|MFHI
define|#
directive|define
name|MFHI
value|(HI(0) | LO(16))
end_define
begin_define
DECL|macro|MFLO
define|#
directive|define
name|MFLO
value|(HI(0) | LO(18))
end_define
begin_define
DECL|macro|MOV_fmt
define|#
directive|define
name|MOV_fmt
value|(HI(17) | FMT_SD | LO(6))
end_define
begin_define
DECL|macro|MUL_fmt
define|#
directive|define
name|MUL_fmt
value|(HI(17) | FMT_SD | LO(2))
end_define
begin_define
DECL|macro|MULT
define|#
directive|define
name|MULT
value|(HI(0) | LO(24))
end_define
begin_define
DECL|macro|MULTU
define|#
directive|define
name|MULTU
value|(HI(0) | LO(25))
end_define
begin_define
DECL|macro|NEG_fmt
define|#
directive|define
name|NEG_fmt
value|(HI(17) | FMT_SD | LO(7))
end_define
begin_define
DECL|macro|NOP
define|#
directive|define
name|NOP
value|(HI(0) | LO(0))
end_define
begin_define
DECL|macro|NOR
define|#
directive|define
name|NOR
value|(HI(0) | LO(39))
end_define
begin_define
DECL|macro|OR
define|#
directive|define
name|OR
value|(HI(0) | LO(37))
end_define
begin_define
DECL|macro|ORI
define|#
directive|define
name|ORI
value|(HI(13))
end_define
begin_define
DECL|macro|SD
define|#
directive|define
name|SD
value|(HI(63))
end_define
begin_define
DECL|macro|SLT
define|#
directive|define
name|SLT
value|(HI(0) | LO(42))
end_define
begin_define
DECL|macro|SLTI
define|#
directive|define
name|SLTI
value|(HI(10))
end_define
begin_define
DECL|macro|SLTIU
define|#
directive|define
name|SLTIU
value|(HI(11))
end_define
begin_define
DECL|macro|SLTU
define|#
directive|define
name|SLTU
value|(HI(0) | LO(43))
end_define
begin_define
DECL|macro|SLL
define|#
directive|define
name|SLL
value|(HI(0) | LO(0))
end_define
begin_define
DECL|macro|SLLV
define|#
directive|define
name|SLLV
value|(HI(0) | LO(4))
end_define
begin_define
DECL|macro|SRL
define|#
directive|define
name|SRL
value|(HI(0) | LO(2))
end_define
begin_define
DECL|macro|SRLV
define|#
directive|define
name|SRLV
value|(HI(0) | LO(6))
end_define
begin_define
DECL|macro|SRA
define|#
directive|define
name|SRA
value|(HI(0) | LO(3))
end_define
begin_define
DECL|macro|SRAV
define|#
directive|define
name|SRAV
value|(HI(0) | LO(7))
end_define
begin_define
DECL|macro|SUB_fmt
define|#
directive|define
name|SUB_fmt
value|(HI(17) | FMT_SD | LO(1))
end_define
begin_define
DECL|macro|SUBU
define|#
directive|define
name|SUBU
value|(HI(0) | LO(35))
end_define
begin_define
DECL|macro|SW
define|#
directive|define
name|SW
value|(HI(43))
end_define
begin_define
DECL|macro|XOR
define|#
directive|define
name|XOR
value|(HI(0) | LO(38))
end_define
begin_define
DECL|macro|XORI
define|#
directive|define
name|XORI
value|(HI(14))
end_define
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_MIPS_32_64
operator|&&
name|SLJIT_MIPS_32_64
operator|)
end_if
begin_define
DECL|macro|CLZ
define|#
directive|define
name|CLZ
value|(HI(28) | LO(32))
end_define
begin_define
DECL|macro|DCLZ
define|#
directive|define
name|DCLZ
value|(HI(28) | LO(36))
end_define
begin_define
DECL|macro|MUL
define|#
directive|define
name|MUL
value|(HI(28) | LO(2))
end_define
begin_define
DECL|macro|SEB
define|#
directive|define
name|SEB
value|(HI(31) | (16<< 6) | LO(32))
end_define
begin_define
DECL|macro|SEH
define|#
directive|define
name|SEH
value|(HI(31) | (24<< 6) | LO(32))
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_MIPS_32
operator|&&
name|SLJIT_CONFIG_MIPS_32
operator|)
end_if
begin_define
DECL|macro|ADDU_W
define|#
directive|define
name|ADDU_W
value|ADDU
end_define
begin_define
DECL|macro|ADDIU_W
define|#
directive|define
name|ADDIU_W
value|ADDIU
end_define
begin_define
DECL|macro|SLL_W
define|#
directive|define
name|SLL_W
value|SLL
end_define
begin_define
DECL|macro|SUBU_W
define|#
directive|define
name|SUBU_W
value|SUBU
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|ADDU_W
define|#
directive|define
name|ADDU_W
value|DADDU
end_define
begin_define
DECL|macro|ADDIU_W
define|#
directive|define
name|ADDIU_W
value|DADDIU
end_define
begin_define
DECL|macro|SLL_W
define|#
directive|define
name|SLL_W
value|DSLL
end_define
begin_define
DECL|macro|SUBU_W
define|#
directive|define
name|SUBU_W
value|DSUBU
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|SIMM_MAX
define|#
directive|define
name|SIMM_MAX
value|(0x7fff)
end_define
begin_define
DECL|macro|SIMM_MIN
define|#
directive|define
name|SIMM_MIN
value|(-0x8000)
end_define
begin_define
DECL|macro|UIMM_MAX
define|#
directive|define
name|UIMM_MAX
value|(0xffff)
end_define
begin_comment
comment|/* dest_reg is the absolute name of the register    Useful for reordering instructions in the delay slot. */
end_comment
begin_function
DECL|function|push_inst
specifier|static
name|sljit_si
name|push_inst
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_ins
name|ins
parameter_list|,
name|sljit_si
name|delay_slot
parameter_list|)
block|{
name|SLJIT_ASSERT
argument_list|(
name|delay_slot
operator|==
name|MOVABLE_INS
operator|||
name|delay_slot
operator|>=
name|UNMOVABLE_INS
operator|||
name|delay_slot
operator|==
operator|(
operator|(
name|ins
operator|>>
literal|11
operator|)
operator|&
literal|0x1f
operator|)
operator|||
name|delay_slot
operator|==
operator|(
operator|(
name|ins
operator|>>
literal|16
operator|)
operator|&
literal|0x1f
operator|)
argument_list|)
expr_stmt|;
name|sljit_ins
modifier|*
name|ptr
init|=
operator|(
name|sljit_ins
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
sizeof|sizeof
argument_list|(
name|sljit_ins
argument_list|)
argument_list|)
decl_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|ptr
argument_list|)
expr_stmt|;
operator|*
name|ptr
operator|=
name|ins
expr_stmt|;
name|compiler
operator|->
name|size
operator|++
expr_stmt|;
name|compiler
operator|->
name|delay_slot
operator|=
name|delay_slot
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_function
DECL|function|invert_branch
specifier|static
name|SLJIT_INLINE
name|sljit_ins
name|invert_branch
parameter_list|(
name|sljit_si
name|flags
parameter_list|)
block|{
return|return
operator|(
name|flags
operator|&
name|IS_BIT26_COND
operator|)
condition|?
operator|(
literal|1
operator|<<
literal|26
operator|)
else|:
operator|(
literal|1
operator|<<
literal|16
operator|)
return|;
block|}
end_function
begin_function
DECL|function|detect_jump_type
specifier|static
name|SLJIT_INLINE
name|sljit_ins
modifier|*
name|detect_jump_type
parameter_list|(
name|struct
name|sljit_jump
modifier|*
name|jump
parameter_list|,
name|sljit_ins
modifier|*
name|code_ptr
parameter_list|,
name|sljit_ins
modifier|*
name|code
parameter_list|)
block|{
name|sljit_sw
name|diff
decl_stmt|;
name|sljit_uw
name|target_addr
decl_stmt|;
name|sljit_ins
modifier|*
name|inst
decl_stmt|;
name|sljit_ins
name|saved_inst
decl_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_MIPS_32
operator|&&
name|SLJIT_CONFIG_MIPS_32
operator|)
if|if
condition|(
name|jump
operator|->
name|flags
operator|&
operator|(
name|SLJIT_REWRITABLE_JUMP
operator||
name|IS_CALL
operator|)
condition|)
return|return
name|code_ptr
return|;
else|#
directive|else
if|if
condition|(
name|jump
operator|->
name|flags
operator|&
name|SLJIT_REWRITABLE_JUMP
condition|)
return|return
name|code_ptr
return|;
endif|#
directive|endif
if|if
condition|(
name|jump
operator|->
name|flags
operator|&
name|JUMP_ADDR
condition|)
name|target_addr
operator|=
name|jump
operator|->
name|u
operator|.
name|target
expr_stmt|;
else|else
block|{
name|SLJIT_ASSERT
argument_list|(
name|jump
operator|->
name|flags
operator|&
name|JUMP_LABEL
argument_list|)
expr_stmt|;
name|target_addr
operator|=
call|(
name|sljit_uw
call|)
argument_list|(
name|code
operator|+
name|jump
operator|->
name|u
operator|.
name|label
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
name|inst
operator|=
operator|(
name|sljit_ins
operator|*
operator|)
name|jump
operator|->
name|addr
expr_stmt|;
if|if
condition|(
name|jump
operator|->
name|flags
operator|&
name|IS_COND
condition|)
name|inst
operator|--
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_MIPS_64
operator|&&
name|SLJIT_CONFIG_MIPS_64
operator|)
if|if
condition|(
name|jump
operator|->
name|flags
operator|&
name|IS_CALL
condition|)
goto|goto
name|keep_address
goto|;
endif|#
directive|endif
comment|/* B instructions. */
if|if
condition|(
name|jump
operator|->
name|flags
operator|&
name|IS_MOVABLE
condition|)
block|{
name|diff
operator|=
operator|(
operator|(
name|sljit_sw
operator|)
name|target_addr
operator|-
call|(
name|sljit_sw
call|)
argument_list|(
name|inst
argument_list|)
operator|)
operator|>>
literal|2
expr_stmt|;
if|if
condition|(
name|diff
operator|<=
name|SIMM_MAX
operator|&&
name|diff
operator|>=
name|SIMM_MIN
condition|)
block|{
name|jump
operator|->
name|flags
operator||=
name|PATCH_B
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|jump
operator|->
name|flags
operator|&
name|IS_COND
operator|)
condition|)
block|{
name|inst
index|[
literal|0
index|]
operator|=
name|inst
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|inst
index|[
operator|-
literal|1
index|]
operator|=
operator|(
name|jump
operator|->
name|flags
operator|&
name|IS_JAL
operator|)
condition|?
name|BAL
else|:
name|B
expr_stmt|;
name|jump
operator|->
name|addr
operator|-=
sizeof|sizeof
argument_list|(
name|sljit_ins
argument_list|)
expr_stmt|;
return|return
name|inst
return|;
block|}
name|saved_inst
operator|=
name|inst
index|[
literal|0
index|]
expr_stmt|;
name|inst
index|[
literal|0
index|]
operator|=
name|inst
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|inst
index|[
operator|-
literal|1
index|]
operator|=
name|saved_inst
operator|^
name|invert_branch
argument_list|(
name|jump
operator|->
name|flags
argument_list|)
expr_stmt|;
name|jump
operator|->
name|addr
operator|-=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|sljit_ins
argument_list|)
expr_stmt|;
return|return
name|inst
return|;
block|}
block|}
else|else
block|{
name|diff
operator|=
operator|(
operator|(
name|sljit_sw
operator|)
name|target_addr
operator|-
call|(
name|sljit_sw
call|)
argument_list|(
name|inst
operator|+
literal|1
argument_list|)
operator|)
operator|>>
literal|2
expr_stmt|;
if|if
condition|(
name|diff
operator|<=
name|SIMM_MAX
operator|&&
name|diff
operator|>=
name|SIMM_MIN
condition|)
block|{
name|jump
operator|->
name|flags
operator||=
name|PATCH_B
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|jump
operator|->
name|flags
operator|&
name|IS_COND
operator|)
condition|)
block|{
name|inst
index|[
literal|0
index|]
operator|=
operator|(
name|jump
operator|->
name|flags
operator|&
name|IS_JAL
operator|)
condition|?
name|BAL
else|:
name|B
expr_stmt|;
name|inst
index|[
literal|1
index|]
operator|=
name|NOP
expr_stmt|;
return|return
name|inst
operator|+
literal|1
return|;
block|}
name|inst
index|[
literal|0
index|]
operator|=
name|inst
index|[
literal|0
index|]
operator|^
name|invert_branch
argument_list|(
name|jump
operator|->
name|flags
argument_list|)
expr_stmt|;
name|inst
index|[
literal|1
index|]
operator|=
name|NOP
expr_stmt|;
name|jump
operator|->
name|addr
operator|-=
sizeof|sizeof
argument_list|(
name|sljit_ins
argument_list|)
expr_stmt|;
return|return
name|inst
operator|+
literal|1
return|;
block|}
block|}
if|if
condition|(
name|jump
operator|->
name|flags
operator|&
name|IS_COND
condition|)
block|{
if|if
condition|(
operator|(
name|jump
operator|->
name|flags
operator|&
name|IS_MOVABLE
operator|)
operator|&&
operator|(
name|target_addr
operator|&
operator|~
literal|0xfffffff
operator|)
operator|==
operator|(
operator|(
name|jump
operator|->
name|addr
operator|+
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|sljit_ins
argument_list|)
operator|)
operator|&
operator|~
literal|0xfffffff
operator|)
condition|)
block|{
name|jump
operator|->
name|flags
operator||=
name|PATCH_J
expr_stmt|;
name|saved_inst
operator|=
name|inst
index|[
literal|0
index|]
expr_stmt|;
name|inst
index|[
literal|0
index|]
operator|=
name|inst
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|inst
index|[
operator|-
literal|1
index|]
operator|=
operator|(
name|saved_inst
operator|&
literal|0xffff0000
operator|)
operator||
literal|3
expr_stmt|;
name|inst
index|[
literal|1
index|]
operator|=
name|J
expr_stmt|;
name|inst
index|[
literal|2
index|]
operator|=
name|NOP
expr_stmt|;
return|return
name|inst
operator|+
literal|2
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|target_addr
operator|&
operator|~
literal|0xfffffff
operator|)
operator|==
operator|(
operator|(
name|jump
operator|->
name|addr
operator|+
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|sljit_ins
argument_list|)
operator|)
operator|&
operator|~
literal|0xfffffff
operator|)
condition|)
block|{
name|jump
operator|->
name|flags
operator||=
name|PATCH_J
expr_stmt|;
name|inst
index|[
literal|0
index|]
operator|=
operator|(
name|inst
index|[
literal|0
index|]
operator|&
literal|0xffff0000
operator|)
operator||
literal|3
expr_stmt|;
name|inst
index|[
literal|1
index|]
operator|=
name|NOP
expr_stmt|;
name|inst
index|[
literal|2
index|]
operator|=
name|J
expr_stmt|;
name|inst
index|[
literal|3
index|]
operator|=
name|NOP
expr_stmt|;
name|jump
operator|->
name|addr
operator|+=
sizeof|sizeof
argument_list|(
name|sljit_ins
argument_list|)
expr_stmt|;
return|return
name|inst
operator|+
literal|3
return|;
block|}
block|}
else|else
block|{
comment|/* J instuctions. */
if|if
condition|(
operator|(
name|jump
operator|->
name|flags
operator|&
name|IS_MOVABLE
operator|)
operator|&&
operator|(
name|target_addr
operator|&
operator|~
literal|0xfffffff
operator|)
operator|==
operator|(
name|jump
operator|->
name|addr
operator|&
operator|~
literal|0xfffffff
operator|)
condition|)
block|{
name|jump
operator|->
name|flags
operator||=
name|PATCH_J
expr_stmt|;
name|inst
index|[
literal|0
index|]
operator|=
name|inst
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|inst
index|[
operator|-
literal|1
index|]
operator|=
operator|(
name|jump
operator|->
name|flags
operator|&
name|IS_JAL
operator|)
condition|?
name|JAL
else|:
name|J
expr_stmt|;
name|jump
operator|->
name|addr
operator|-=
sizeof|sizeof
argument_list|(
name|sljit_ins
argument_list|)
expr_stmt|;
return|return
name|inst
return|;
block|}
if|if
condition|(
operator|(
name|target_addr
operator|&
operator|~
literal|0xfffffff
operator|)
operator|==
operator|(
operator|(
name|jump
operator|->
name|addr
operator|+
sizeof|sizeof
argument_list|(
name|sljit_ins
argument_list|)
operator|)
operator|&
operator|~
literal|0xfffffff
operator|)
condition|)
block|{
name|jump
operator|->
name|flags
operator||=
name|PATCH_J
expr_stmt|;
name|inst
index|[
literal|0
index|]
operator|=
operator|(
name|jump
operator|->
name|flags
operator|&
name|IS_JAL
operator|)
condition|?
name|JAL
else|:
name|J
expr_stmt|;
name|inst
index|[
literal|1
index|]
operator|=
name|NOP
expr_stmt|;
return|return
name|inst
operator|+
literal|1
return|;
block|}
block|}
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_MIPS_64
operator|&&
name|SLJIT_CONFIG_MIPS_64
operator|)
name|keep_address
label|:
if|if
condition|(
name|target_addr
operator|<=
literal|0x7fffffff
condition|)
block|{
name|jump
operator|->
name|flags
operator||=
name|PATCH_ABS32
expr_stmt|;
if|if
condition|(
name|jump
operator|->
name|flags
operator|&
name|IS_COND
condition|)
block|{
name|inst
index|[
literal|0
index|]
operator|-=
literal|4
expr_stmt|;
name|inst
operator|++
expr_stmt|;
block|}
name|inst
index|[
literal|2
index|]
operator|=
name|inst
index|[
literal|6
index|]
expr_stmt|;
name|inst
index|[
literal|3
index|]
operator|=
name|inst
index|[
literal|7
index|]
expr_stmt|;
return|return
name|inst
operator|+
literal|3
return|;
block|}
if|if
condition|(
name|target_addr
operator|<=
literal|0x7fffffffffffl
condition|)
block|{
name|jump
operator|->
name|flags
operator||=
name|PATCH_ABS48
expr_stmt|;
if|if
condition|(
name|jump
operator|->
name|flags
operator|&
name|IS_COND
condition|)
block|{
name|inst
index|[
literal|0
index|]
operator|-=
literal|2
expr_stmt|;
name|inst
operator|++
expr_stmt|;
block|}
name|inst
index|[
literal|4
index|]
operator|=
name|inst
index|[
literal|6
index|]
expr_stmt|;
name|inst
index|[
literal|5
index|]
operator|=
name|inst
index|[
literal|7
index|]
expr_stmt|;
return|return
name|inst
operator|+
literal|5
return|;
block|}
endif|#
directive|endif
return|return
name|code_ptr
return|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef
begin_expr_stmt
DECL|function|sljit_cache_flush
specifier|static
name|__attribute__
argument_list|(
argument|(noinline)
argument_list|)
name|void
name|sljit_cache_flush
argument_list|(
argument|void* code
argument_list|,
argument|void* code_ptr
argument_list|)
block|{
name|SLJIT_CACHE_FLUSH
argument_list|(
name|code
argument_list|,
name|code_ptr
argument_list|)
block|; }
endif|#
directive|endif
DECL|function|sljit_generate_code
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
operator|*
name|sljit_generate_code
argument_list|(
argument|struct sljit_compiler *compiler
argument_list|)
block|{ 	struct
name|sljit_memory_fragment
operator|*
name|buf
block|;
name|sljit_ins
operator|*
name|code
block|;
name|sljit_ins
operator|*
name|code_ptr
block|;
name|sljit_ins
operator|*
name|buf_ptr
block|;
name|sljit_ins
operator|*
name|buf_end
block|;
name|sljit_uw
name|word_count
block|;
name|sljit_uw
name|addr
block|;  	struct
name|sljit_label
operator|*
name|label
block|; 	struct
name|sljit_jump
operator|*
name|jump
block|; 	struct
name|sljit_const
operator|*
name|const_
block|;
name|CHECK_ERROR_PTR
argument_list|()
block|;
name|check_sljit_generate_code
argument_list|(
name|compiler
argument_list|)
block|;
name|reverse_buf
argument_list|(
name|compiler
argument_list|)
block|;
name|code
operator|=
operator|(
name|sljit_ins
operator|*
operator|)
name|SLJIT_MALLOC_EXEC
argument_list|(
name|compiler
operator|->
name|size
operator|*
sizeof|sizeof
argument_list|(
name|sljit_ins
argument_list|)
argument_list|)
block|;
name|PTR_FAIL_WITH_EXEC_IF
argument_list|(
name|code
argument_list|)
block|;
name|buf
operator|=
name|compiler
operator|->
name|buf
block|;
name|code_ptr
operator|=
name|code
block|;
name|word_count
operator|=
literal|0
block|;
name|label
operator|=
name|compiler
operator|->
name|labels
block|;
name|jump
operator|=
name|compiler
operator|->
name|jumps
block|;
name|const_
operator|=
name|compiler
operator|->
name|consts
block|;
do|do
block|{
name|buf_ptr
operator|=
operator|(
name|sljit_ins
operator|*
operator|)
name|buf
operator|->
name|memory
expr_stmt|;
name|buf_end
operator|=
name|buf_ptr
operator|+
operator|(
name|buf
operator|->
name|used_size
operator|>>
literal|2
operator|)
expr_stmt|;
do|do
block|{
operator|*
name|code_ptr
operator|=
operator|*
name|buf_ptr
operator|++
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
operator|!
name|label
operator|||
name|label
operator|->
name|size
operator|>=
name|word_count
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
operator|!
name|jump
operator|||
name|jump
operator|->
name|addr
operator|>=
name|word_count
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
operator|!
name|const_
operator|||
name|const_
operator|->
name|addr
operator|>=
name|word_count
argument_list|)
expr_stmt|;
comment|/* These structures are ordered by their address. */
if|if
condition|(
name|label
operator|&&
name|label
operator|->
name|size
operator|==
name|word_count
condition|)
block|{
comment|/* Just recording the address. */
name|label
operator|->
name|addr
operator|=
operator|(
name|sljit_uw
operator|)
name|code_ptr
expr_stmt|;
name|label
operator|->
name|size
operator|=
name|code_ptr
operator|-
name|code
expr_stmt|;
name|label
operator|=
name|label
operator|->
name|next
expr_stmt|;
block|}
end_expr_stmt
begin_if
if|if
condition|(
name|jump
operator|&&
name|jump
operator|->
name|addr
operator|==
name|word_count
condition|)
block|{
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_MIPS_32
operator|&&
name|SLJIT_CONFIG_MIPS_32
operator|)
name|jump
operator|->
name|addr
operator|=
call|(
name|sljit_uw
call|)
argument_list|(
name|code_ptr
operator|-
literal|3
argument_list|)
expr_stmt|;
else|#
directive|else
name|jump
operator|->
name|addr
operator|=
call|(
name|sljit_uw
call|)
argument_list|(
name|code_ptr
operator|-
literal|7
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|code_ptr
operator|=
name|detect_jump_type
argument_list|(
name|jump
argument_list|,
name|code_ptr
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|jump
operator|=
name|jump
operator|->
name|next
expr_stmt|;
block|}
end_if
begin_if
if|if
condition|(
name|const_
operator|&&
name|const_
operator|->
name|addr
operator|==
name|word_count
condition|)
block|{
comment|/* Just recording the address. */
name|const_
operator|->
name|addr
operator|=
operator|(
name|sljit_uw
operator|)
name|code_ptr
expr_stmt|;
name|const_
operator|=
name|const_
operator|->
name|next
expr_stmt|;
block|}
end_if
begin_expr_stmt
name|code_ptr
operator|++
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|word_count
operator|++
expr_stmt|;
end_expr_stmt
begin_expr_stmt
unit|} while
operator|(
name|buf_ptr
operator|<
name|buf_end
operator|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|buf
operator|=
name|buf
operator|->
name|next
expr_stmt|;
end_expr_stmt
begin_expr_stmt
unit|} while
operator|(
name|buf
operator|)
expr_stmt|;
end_expr_stmt
begin_if
if|if
condition|(
name|label
operator|&&
name|label
operator|->
name|size
operator|==
name|word_count
condition|)
block|{
name|label
operator|->
name|addr
operator|=
operator|(
name|sljit_uw
operator|)
name|code_ptr
expr_stmt|;
name|label
operator|->
name|size
operator|=
name|code_ptr
operator|-
name|code
expr_stmt|;
name|label
operator|=
name|label
operator|->
name|next
expr_stmt|;
block|}
end_if
begin_expr_stmt
name|SLJIT_ASSERT
argument_list|(
operator|!
name|label
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|SLJIT_ASSERT
argument_list|(
operator|!
name|jump
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|SLJIT_ASSERT
argument_list|(
operator|!
name|const_
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|SLJIT_ASSERT
argument_list|(
name|code_ptr
operator|-
name|code
operator|<=
operator|(
name|sljit_sw
operator|)
name|compiler
operator|->
name|size
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|jump
operator|=
name|compiler
operator|->
name|jumps
expr_stmt|;
end_expr_stmt
begin_while
while|while
condition|(
name|jump
condition|)
block|{
do|do
block|{
name|addr
operator|=
operator|(
name|jump
operator|->
name|flags
operator|&
name|JUMP_LABEL
operator|)
condition|?
name|jump
operator|->
name|u
operator|.
name|label
operator|->
name|addr
else|:
name|jump
operator|->
name|u
operator|.
name|target
expr_stmt|;
name|buf_ptr
operator|=
operator|(
name|sljit_ins
operator|*
operator|)
name|jump
operator|->
name|addr
expr_stmt|;
if|if
condition|(
name|jump
operator|->
name|flags
operator|&
name|PATCH_B
condition|)
block|{
name|addr
operator|=
call|(
name|sljit_sw
call|)
argument_list|(
name|addr
operator|-
operator|(
name|jump
operator|->
name|addr
operator|+
sizeof|sizeof
argument_list|(
name|sljit_ins
argument_list|)
operator|)
argument_list|)
operator|>>
literal|2
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
operator|(
name|sljit_sw
operator|)
name|addr
operator|<=
name|SIMM_MAX
operator|&&
operator|(
name|sljit_sw
operator|)
name|addr
operator|>=
name|SIMM_MIN
argument_list|)
expr_stmt|;
name|buf_ptr
index|[
literal|0
index|]
operator|=
operator|(
name|buf_ptr
index|[
literal|0
index|]
operator|&
literal|0xffff0000
operator|)
operator||
operator|(
name|addr
operator|&
literal|0xffff
operator|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|jump
operator|->
name|flags
operator|&
name|PATCH_J
condition|)
block|{
name|SLJIT_ASSERT
argument_list|(
operator|(
name|addr
operator|&
operator|~
literal|0xfffffff
operator|)
operator|==
operator|(
operator|(
name|jump
operator|->
name|addr
operator|+
sizeof|sizeof
argument_list|(
name|sljit_ins
argument_list|)
operator|)
operator|&
operator|~
literal|0xfffffff
operator|)
argument_list|)
expr_stmt|;
name|buf_ptr
index|[
literal|0
index|]
operator||=
operator|(
name|addr
operator|>>
literal|2
operator|)
operator|&
literal|0x03ffffff
expr_stmt|;
break|break;
block|}
comment|/* Set the fields of immediate loads. */
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_MIPS_32
operator|&&
name|SLJIT_CONFIG_MIPS_32
operator|)
name|buf_ptr
index|[
literal|0
index|]
operator|=
operator|(
name|buf_ptr
index|[
literal|0
index|]
operator|&
literal|0xffff0000
operator|)
operator||
operator|(
operator|(
name|addr
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|buf_ptr
index|[
literal|1
index|]
operator|=
operator|(
name|buf_ptr
index|[
literal|1
index|]
operator|&
literal|0xffff0000
operator|)
operator||
operator|(
name|addr
operator|&
literal|0xffff
operator|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|jump
operator|->
name|flags
operator|&
name|PATCH_ABS32
condition|)
block|{
name|SLJIT_ASSERT
argument_list|(
name|addr
operator|<=
literal|0x7fffffff
argument_list|)
expr_stmt|;
name|buf_ptr
index|[
literal|0
index|]
operator|=
operator|(
name|buf_ptr
index|[
literal|0
index|]
operator|&
literal|0xffff0000
operator|)
operator||
operator|(
operator|(
name|addr
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|buf_ptr
index|[
literal|1
index|]
operator|=
operator|(
name|buf_ptr
index|[
literal|1
index|]
operator|&
literal|0xffff0000
operator|)
operator||
operator|(
name|addr
operator|&
literal|0xffff
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|jump
operator|->
name|flags
operator|&
name|PATCH_ABS48
condition|)
block|{
name|SLJIT_ASSERT
argument_list|(
name|addr
operator|<=
literal|0x7fffffffffffl
argument_list|)
expr_stmt|;
name|buf_ptr
index|[
literal|0
index|]
operator|=
operator|(
name|buf_ptr
index|[
literal|0
index|]
operator|&
literal|0xffff0000
operator|)
operator||
operator|(
operator|(
name|addr
operator|>>
literal|32
operator|)
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|buf_ptr
index|[
literal|1
index|]
operator|=
operator|(
name|buf_ptr
index|[
literal|1
index|]
operator|&
literal|0xffff0000
operator|)
operator||
operator|(
operator|(
name|addr
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|buf_ptr
index|[
literal|3
index|]
operator|=
operator|(
name|buf_ptr
index|[
literal|3
index|]
operator|&
literal|0xffff0000
operator|)
operator||
operator|(
name|addr
operator|&
literal|0xffff
operator|)
expr_stmt|;
block|}
else|else
block|{
name|buf_ptr
index|[
literal|0
index|]
operator|=
operator|(
name|buf_ptr
index|[
literal|0
index|]
operator|&
literal|0xffff0000
operator|)
operator||
operator|(
operator|(
name|addr
operator|>>
literal|48
operator|)
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|buf_ptr
index|[
literal|1
index|]
operator|=
operator|(
name|buf_ptr
index|[
literal|1
index|]
operator|&
literal|0xffff0000
operator|)
operator||
operator|(
operator|(
name|addr
operator|>>
literal|32
operator|)
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|buf_ptr
index|[
literal|3
index|]
operator|=
operator|(
name|buf_ptr
index|[
literal|3
index|]
operator|&
literal|0xffff0000
operator|)
operator||
operator|(
operator|(
name|addr
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|buf_ptr
index|[
literal|5
index|]
operator|=
operator|(
name|buf_ptr
index|[
literal|5
index|]
operator|&
literal|0xffff0000
operator|)
operator||
operator|(
name|addr
operator|&
literal|0xffff
operator|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
do|while
condition|(
literal|0
condition|)
do|;
name|jump
operator|=
name|jump
operator|->
name|next
expr_stmt|;
block|}
end_while
begin_expr_stmt
name|compiler
operator|->
name|error
operator|=
name|SLJIT_ERR_COMPILED
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|compiler
operator|->
name|executable_size
operator|=
operator|(
name|code_ptr
operator|-
name|code
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|sljit_ins
argument_list|)
expr_stmt|;
end_expr_stmt
begin_ifndef
ifndef|#
directive|ifndef
name|__GNUC__
end_ifndef
begin_expr_stmt
name|SLJIT_CACHE_FLUSH
argument_list|(
name|code
argument_list|,
name|code_ptr
argument_list|)
expr_stmt|;
end_expr_stmt
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* GCC workaround for invalid code generation with -O2. */
end_comment
begin_expr_stmt
name|sljit_cache_flush
argument_list|(
name|code
argument_list|,
name|code_ptr
argument_list|)
expr_stmt|;
end_expr_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_return
return|return
name|code
return|;
end_return
begin_comment
unit|}
comment|/* --------------------------------------------------------------------- */
end_comment
begin_comment
comment|/*  Entry, exit                                                          */
end_comment
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_comment
comment|/* Creates an index in data_transfer_insts array. */
end_comment
begin_define
DECL|macro|LOAD_DATA
define|#
directive|define
name|LOAD_DATA
value|0x01
end_define
begin_define
DECL|macro|WORD_DATA
define|#
directive|define
name|WORD_DATA
value|0x00
end_define
begin_define
DECL|macro|BYTE_DATA
define|#
directive|define
name|BYTE_DATA
value|0x02
end_define
begin_define
DECL|macro|HALF_DATA
define|#
directive|define
name|HALF_DATA
value|0x04
end_define
begin_define
DECL|macro|INT_DATA
define|#
directive|define
name|INT_DATA
value|0x06
end_define
begin_define
DECL|macro|SIGNED_DATA
define|#
directive|define
name|SIGNED_DATA
value|0x08
end_define
begin_comment
comment|/* Separates integer and floating point registers */
end_comment
begin_define
DECL|macro|GPR_REG
define|#
directive|define
name|GPR_REG
value|0x0f
end_define
begin_define
DECL|macro|DOUBLE_DATA
define|#
directive|define
name|DOUBLE_DATA
value|0x10
end_define
begin_define
DECL|macro|MEM_MASK
define|#
directive|define
name|MEM_MASK
value|0x1f
end_define
begin_define
DECL|macro|WRITE_BACK
define|#
directive|define
name|WRITE_BACK
value|0x00020
end_define
begin_define
DECL|macro|ARG_TEST
define|#
directive|define
name|ARG_TEST
value|0x00040
end_define
begin_define
DECL|macro|ALT_KEEP_CACHE
define|#
directive|define
name|ALT_KEEP_CACHE
value|0x00080
end_define
begin_define
DECL|macro|CUMULATIVE_OP
define|#
directive|define
name|CUMULATIVE_OP
value|0x00100
end_define
begin_define
DECL|macro|LOGICAL_OP
define|#
directive|define
name|LOGICAL_OP
value|0x00200
end_define
begin_define
DECL|macro|IMM_OP
define|#
directive|define
name|IMM_OP
value|0x00400
end_define
begin_define
DECL|macro|SRC2_IMM
define|#
directive|define
name|SRC2_IMM
value|0x00800
end_define
begin_define
DECL|macro|UNUSED_DEST
define|#
directive|define
name|UNUSED_DEST
value|0x01000
end_define
begin_define
DECL|macro|REG_DEST
define|#
directive|define
name|REG_DEST
value|0x02000
end_define
begin_define
DECL|macro|REG1_SOURCE
define|#
directive|define
name|REG1_SOURCE
value|0x04000
end_define
begin_define
DECL|macro|REG2_SOURCE
define|#
directive|define
name|REG2_SOURCE
value|0x08000
end_define
begin_define
DECL|macro|SLOW_SRC1
define|#
directive|define
name|SLOW_SRC1
value|0x10000
end_define
begin_define
DECL|macro|SLOW_SRC2
define|#
directive|define
name|SLOW_SRC2
value|0x20000
end_define
begin_define
DECL|macro|SLOW_DEST
define|#
directive|define
name|SLOW_DEST
value|0x40000
end_define
begin_comment
comment|/* Only these flags are set. UNUSED_DEST is not set when no flags should be set. */
end_comment
begin_define
DECL|macro|CHECK_FLAGS
define|#
directive|define
name|CHECK_FLAGS
parameter_list|(
name|list
parameter_list|)
define|\
value|(!(flags& UNUSED_DEST) || (op& GET_FLAGS(~(list))))
end_define
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_MIPS_32
operator|&&
name|SLJIT_CONFIG_MIPS_32
operator|)
end_if
begin_define
DECL|macro|STACK_STORE
define|#
directive|define
name|STACK_STORE
value|SW
end_define
begin_define
DECL|macro|STACK_LOAD
define|#
directive|define
name|STACK_LOAD
value|LW
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|STACK_STORE
define|#
directive|define
name|STACK_STORE
value|SD
end_define
begin_define
DECL|macro|STACK_LOAD
define|#
directive|define
name|STACK_LOAD
value|LD
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_MIPS_32
operator|&&
name|SLJIT_CONFIG_MIPS_32
operator|)
end_if
begin_include
include|#
directive|include
file|"sljitNativeMIPS_32.c"
end_include
begin_else
else|#
directive|else
end_else
begin_include
include|#
directive|include
file|"sljitNativeMIPS_64.c"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_function
unit|SLJIT_API_FUNC_ATTRIBUTE
DECL|function|sljit_emit_enter
name|sljit_si
name|sljit_emit_enter
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|args
parameter_list|,
name|sljit_si
name|scratches
parameter_list|,
name|sljit_si
name|saveds
parameter_list|,
name|sljit_si
name|local_size
parameter_list|)
block|{
name|sljit_ins
name|base
decl_stmt|;
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|check_sljit_emit_enter
argument_list|(
name|compiler
argument_list|,
name|args
argument_list|,
name|scratches
argument_list|,
name|saveds
argument_list|,
name|local_size
argument_list|)
expr_stmt|;
name|compiler
operator|->
name|scratches
operator|=
name|scratches
expr_stmt|;
name|compiler
operator|->
name|saveds
operator|=
name|saveds
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_DEBUG
operator|&&
name|SLJIT_DEBUG
operator|)
name|compiler
operator|->
name|logical_local_size
operator|=
name|local_size
expr_stmt|;
endif|#
directive|endif
name|local_size
operator|+=
operator|(
name|saveds
operator|+
literal|1
operator|+
literal|4
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_MIPS_32
operator|&&
name|SLJIT_CONFIG_MIPS_32
operator|)
name|local_size
operator|=
operator|(
name|local_size
operator|+
literal|15
operator|)
operator|&
operator|~
literal|0xf
expr_stmt|;
else|#
directive|else
name|local_size
operator|=
operator|(
name|local_size
operator|+
literal|31
operator|)
operator|&
operator|~
literal|0x1f
expr_stmt|;
endif|#
directive|endif
name|compiler
operator|->
name|local_size
operator|=
name|local_size
expr_stmt|;
if|if
condition|(
name|local_size
operator|<=
name|SIMM_MAX
condition|)
block|{
comment|/* Frequent case. */
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|ADDIU_W
operator||
name|S
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
operator||
name|T
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
operator||
name|IMM
argument_list|(
operator|-
name|local_size
argument_list|)
argument_list|,
name|DR
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|base
operator|=
name|S
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|FAIL_IF
argument_list|(
name|load_immediate
argument_list|(
name|compiler
argument_list|,
name|DR
argument_list|(
name|TMP_REG1
argument_list|)
argument_list|,
name|local_size
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|ADDU_W
operator||
name|S
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
operator||
name|TA
argument_list|(
literal|0
argument_list|)
operator||
name|D
argument_list|(
name|TMP_REG2
argument_list|)
argument_list|,
name|DR
argument_list|(
name|TMP_REG2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|SUBU_W
operator||
name|S
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
operator||
name|T
argument_list|(
name|TMP_REG1
argument_list|)
operator||
name|D
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|DR
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|base
operator|=
name|S
argument_list|(
name|TMP_REG2
argument_list|)
expr_stmt|;
name|local_size
operator|=
literal|0
expr_stmt|;
block|}
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|STACK_STORE
operator||
name|base
operator||
name|TA
argument_list|(
name|RETURN_ADDR_REG
argument_list|)
operator||
name|IMM
argument_list|(
name|local_size
operator|-
literal|1
operator|*
operator|(
name|sljit_si
operator|)
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
argument_list|)
argument_list|,
name|MOVABLE_INS
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|saveds
operator|>=
literal|1
condition|)
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|STACK_STORE
operator||
name|base
operator||
name|T
argument_list|(
name|SLJIT_SAVED_REG1
argument_list|)
operator||
name|IMM
argument_list|(
name|local_size
operator|-
literal|2
operator|*
operator|(
name|sljit_si
operator|)
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
argument_list|)
argument_list|,
name|MOVABLE_INS
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|saveds
operator|>=
literal|2
condition|)
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|STACK_STORE
operator||
name|base
operator||
name|T
argument_list|(
name|SLJIT_SAVED_REG2
argument_list|)
operator||
name|IMM
argument_list|(
name|local_size
operator|-
literal|3
operator|*
operator|(
name|sljit_si
operator|)
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
argument_list|)
argument_list|,
name|MOVABLE_INS
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|saveds
operator|>=
literal|3
condition|)
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|STACK_STORE
operator||
name|base
operator||
name|T
argument_list|(
name|SLJIT_SAVED_REG3
argument_list|)
operator||
name|IMM
argument_list|(
name|local_size
operator|-
literal|4
operator|*
operator|(
name|sljit_si
operator|)
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
argument_list|)
argument_list|,
name|MOVABLE_INS
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|saveds
operator|>=
literal|4
condition|)
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|STACK_STORE
operator||
name|base
operator||
name|T
argument_list|(
name|SLJIT_SAVED_EREG1
argument_list|)
operator||
name|IMM
argument_list|(
name|local_size
operator|-
literal|5
operator|*
operator|(
name|sljit_si
operator|)
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
argument_list|)
argument_list|,
name|MOVABLE_INS
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|saveds
operator|>=
literal|5
condition|)
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|STACK_STORE
operator||
name|base
operator||
name|T
argument_list|(
name|SLJIT_SAVED_EREG2
argument_list|)
operator||
name|IMM
argument_list|(
name|local_size
operator|-
literal|6
operator|*
operator|(
name|sljit_si
operator|)
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
argument_list|)
argument_list|,
name|MOVABLE_INS
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|>=
literal|1
condition|)
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|ADDU_W
operator||
name|SA
argument_list|(
literal|4
argument_list|)
operator||
name|TA
argument_list|(
literal|0
argument_list|)
operator||
name|D
argument_list|(
name|SLJIT_SAVED_REG1
argument_list|)
argument_list|,
name|DR
argument_list|(
name|SLJIT_SAVED_REG1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|>=
literal|2
condition|)
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|ADDU_W
operator||
name|SA
argument_list|(
literal|5
argument_list|)
operator||
name|TA
argument_list|(
literal|0
argument_list|)
operator||
name|D
argument_list|(
name|SLJIT_SAVED_REG2
argument_list|)
argument_list|,
name|DR
argument_list|(
name|SLJIT_SAVED_REG2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|>=
literal|3
condition|)
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|ADDU_W
operator||
name|SA
argument_list|(
literal|6
argument_list|)
operator||
name|TA
argument_list|(
literal|0
argument_list|)
operator||
name|D
argument_list|(
name|SLJIT_SAVED_REG3
argument_list|)
argument_list|,
name|DR
argument_list|(
name|SLJIT_SAVED_REG3
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_function
DECL|function|sljit_set_context
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
name|sljit_set_context
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|args
parameter_list|,
name|sljit_si
name|scratches
parameter_list|,
name|sljit_si
name|saveds
parameter_list|,
name|sljit_si
name|local_size
parameter_list|)
block|{
name|CHECK_ERROR_VOID
argument_list|()
expr_stmt|;
name|check_sljit_set_context
argument_list|(
name|compiler
argument_list|,
name|args
argument_list|,
name|scratches
argument_list|,
name|saveds
argument_list|,
name|local_size
argument_list|)
expr_stmt|;
name|compiler
operator|->
name|scratches
operator|=
name|scratches
expr_stmt|;
name|compiler
operator|->
name|saveds
operator|=
name|saveds
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_DEBUG
operator|&&
name|SLJIT_DEBUG
operator|)
name|compiler
operator|->
name|logical_local_size
operator|=
name|local_size
expr_stmt|;
endif|#
directive|endif
name|local_size
operator|+=
operator|(
name|saveds
operator|+
literal|1
operator|+
literal|4
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_MIPS_32
operator|&&
name|SLJIT_CONFIG_MIPS_32
operator|)
name|compiler
operator|->
name|local_size
operator|=
operator|(
name|local_size
operator|+
literal|15
operator|)
operator|&
operator|~
literal|0xf
expr_stmt|;
else|#
directive|else
name|compiler
operator|->
name|local_size
operator|=
operator|(
name|local_size
operator|+
literal|31
operator|)
operator|&
operator|~
literal|0x1f
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|sljit_emit_return
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_return
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|)
block|{
name|sljit_si
name|local_size
decl_stmt|;
name|sljit_ins
name|base
decl_stmt|;
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|check_sljit_emit_return
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|emit_mov_before_return
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
argument_list|)
expr_stmt|;
name|local_size
operator|=
name|compiler
operator|->
name|local_size
expr_stmt|;
if|if
condition|(
name|local_size
operator|<=
name|SIMM_MAX
condition|)
name|base
operator|=
name|S
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
expr_stmt|;
else|else
block|{
name|FAIL_IF
argument_list|(
name|load_immediate
argument_list|(
name|compiler
argument_list|,
name|DR
argument_list|(
name|TMP_REG1
argument_list|)
argument_list|,
name|local_size
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|ADDU_W
operator||
name|S
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
operator||
name|T
argument_list|(
name|TMP_REG1
argument_list|)
operator||
name|D
argument_list|(
name|TMP_REG1
argument_list|)
argument_list|,
name|DR
argument_list|(
name|TMP_REG1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|base
operator|=
name|S
argument_list|(
name|TMP_REG1
argument_list|)
expr_stmt|;
name|local_size
operator|=
literal|0
expr_stmt|;
block|}
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|STACK_LOAD
operator||
name|base
operator||
name|TA
argument_list|(
name|RETURN_ADDR_REG
argument_list|)
operator||
name|IMM
argument_list|(
name|local_size
operator|-
literal|1
operator|*
operator|(
name|sljit_si
operator|)
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
argument_list|)
argument_list|,
name|RETURN_ADDR_REG
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|compiler
operator|->
name|saveds
operator|>=
literal|5
condition|)
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|STACK_LOAD
operator||
name|base
operator||
name|T
argument_list|(
name|SLJIT_SAVED_EREG2
argument_list|)
operator||
name|IMM
argument_list|(
name|local_size
operator|-
literal|6
operator|*
operator|(
name|sljit_si
operator|)
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
argument_list|)
argument_list|,
name|DR
argument_list|(
name|SLJIT_SAVED_EREG2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|compiler
operator|->
name|saveds
operator|>=
literal|4
condition|)
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|STACK_LOAD
operator||
name|base
operator||
name|T
argument_list|(
name|SLJIT_SAVED_EREG1
argument_list|)
operator||
name|IMM
argument_list|(
name|local_size
operator|-
literal|5
operator|*
operator|(
name|sljit_si
operator|)
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
argument_list|)
argument_list|,
name|DR
argument_list|(
name|SLJIT_SAVED_EREG1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|compiler
operator|->
name|saveds
operator|>=
literal|3
condition|)
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|STACK_LOAD
operator||
name|base
operator||
name|T
argument_list|(
name|SLJIT_SAVED_REG3
argument_list|)
operator||
name|IMM
argument_list|(
name|local_size
operator|-
literal|4
operator|*
operator|(
name|sljit_si
operator|)
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
argument_list|)
argument_list|,
name|DR
argument_list|(
name|SLJIT_SAVED_REG3
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|compiler
operator|->
name|saveds
operator|>=
literal|2
condition|)
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|STACK_LOAD
operator||
name|base
operator||
name|T
argument_list|(
name|SLJIT_SAVED_REG2
argument_list|)
operator||
name|IMM
argument_list|(
name|local_size
operator|-
literal|3
operator|*
operator|(
name|sljit_si
operator|)
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
argument_list|)
argument_list|,
name|DR
argument_list|(
name|SLJIT_SAVED_REG2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|compiler
operator|->
name|saveds
operator|>=
literal|1
condition|)
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|STACK_LOAD
operator||
name|base
operator||
name|T
argument_list|(
name|SLJIT_SAVED_REG1
argument_list|)
operator||
name|IMM
argument_list|(
name|local_size
operator|-
literal|2
operator|*
operator|(
name|sljit_si
operator|)
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
argument_list|)
argument_list|,
name|DR
argument_list|(
name|SLJIT_SAVED_REG1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|JR
operator||
name|SA
argument_list|(
name|RETURN_ADDR_REG
argument_list|)
argument_list|,
name|UNMOVABLE_INS
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|compiler
operator|->
name|local_size
operator|<=
name|SIMM_MAX
condition|)
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|ADDIU_W
operator||
name|S
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
operator||
name|T
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
operator||
name|IMM
argument_list|(
name|compiler
operator|->
name|local_size
argument_list|)
argument_list|,
name|UNMOVABLE_INS
argument_list|)
return|;
else|else
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|ADDU_W
operator||
name|S
argument_list|(
name|TMP_REG1
argument_list|)
operator||
name|TA
argument_list|(
literal|0
argument_list|)
operator||
name|D
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
argument_list|,
name|UNMOVABLE_INS
argument_list|)
return|;
block|}
end_function
begin_undef
DECL|macro|STACK_STORE
undef|#
directive|undef
name|STACK_STORE
end_undef
begin_undef
DECL|macro|STACK_LOAD
undef|#
directive|undef
name|STACK_LOAD
end_undef
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_comment
comment|/*  Operators                                                            */
end_comment
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_MIPS_32
operator|&&
name|SLJIT_CONFIG_MIPS_32
operator|)
end_if
begin_define
DECL|macro|ARCH_32_64
define|#
directive|define
name|ARCH_32_64
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|a
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|ARCH_32_64
define|#
directive|define
name|ARCH_32_64
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|b
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_decl_stmt
DECL|variable|data_transfer_insts
specifier|static
name|SLJIT_CONST
name|sljit_ins
name|data_transfer_insts
index|[
literal|16
operator|+
literal|4
index|]
init|=
block|{
comment|/* u w s */
name|ARCH_32_64
argument_list|(
name|HI
argument_list|(
literal|43
argument_list|)
comment|/* sw */
argument_list|,
name|HI
argument_list|(
literal|63
argument_list|)
comment|/* sd */
argument_list|)
block|,
comment|/* u w l */
name|ARCH_32_64
argument_list|(
name|HI
argument_list|(
literal|35
argument_list|)
comment|/* lw */
argument_list|,
name|HI
argument_list|(
literal|55
argument_list|)
comment|/* ld */
argument_list|)
block|,
comment|/* u b s */
name|HI
argument_list|(
literal|40
argument_list|)
comment|/* sb */
block|,
comment|/* u b l */
name|HI
argument_list|(
literal|36
argument_list|)
comment|/* lbu */
block|,
comment|/* u h s */
name|HI
argument_list|(
literal|41
argument_list|)
comment|/* sh */
block|,
comment|/* u h l */
name|HI
argument_list|(
literal|37
argument_list|)
comment|/* lhu */
block|,
comment|/* u i s */
name|HI
argument_list|(
literal|43
argument_list|)
comment|/* sw */
block|,
comment|/* u i l */
name|ARCH_32_64
argument_list|(
name|HI
argument_list|(
literal|35
argument_list|)
comment|/* lw */
argument_list|,
name|HI
argument_list|(
literal|39
argument_list|)
comment|/* lwu */
argument_list|)
block|,
comment|/* s w s */
name|ARCH_32_64
argument_list|(
name|HI
argument_list|(
literal|43
argument_list|)
comment|/* sw */
argument_list|,
name|HI
argument_list|(
literal|63
argument_list|)
comment|/* sd */
argument_list|)
block|,
comment|/* s w l */
name|ARCH_32_64
argument_list|(
name|HI
argument_list|(
literal|35
argument_list|)
comment|/* lw */
argument_list|,
name|HI
argument_list|(
literal|55
argument_list|)
comment|/* ld */
argument_list|)
block|,
comment|/* s b s */
name|HI
argument_list|(
literal|40
argument_list|)
comment|/* sb */
block|,
comment|/* s b l */
name|HI
argument_list|(
literal|32
argument_list|)
comment|/* lb */
block|,
comment|/* s h s */
name|HI
argument_list|(
literal|41
argument_list|)
comment|/* sh */
block|,
comment|/* s h l */
name|HI
argument_list|(
literal|33
argument_list|)
comment|/* lh */
block|,
comment|/* s i s */
name|HI
argument_list|(
literal|43
argument_list|)
comment|/* sw */
block|,
comment|/* s i l */
name|HI
argument_list|(
literal|35
argument_list|)
comment|/* lw */
block|,
comment|/* d   s */
name|HI
argument_list|(
literal|61
argument_list|)
comment|/* sdc1 */
block|,
comment|/* d   l */
name|HI
argument_list|(
literal|53
argument_list|)
comment|/* ldc1 */
block|,
comment|/* s   s */
name|HI
argument_list|(
literal|57
argument_list|)
comment|/* swc1 */
block|,
comment|/* s   l */
name|HI
argument_list|(
literal|49
argument_list|)
comment|/* lwc1 */
block|, }
decl_stmt|;
end_decl_stmt
begin_undef
DECL|macro|ARCH_32_64
undef|#
directive|undef
name|ARCH_32_64
end_undef
begin_comment
comment|/* reg_ar is an absoulute register! */
end_comment
begin_comment
comment|/* Can perform an operation using at most 1 instruction. */
end_comment
begin_function
DECL|function|getput_arg_fast
specifier|static
name|sljit_si
name|getput_arg_fast
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|flags
parameter_list|,
name|sljit_si
name|reg_ar
parameter_list|,
name|sljit_si
name|arg
parameter_list|,
name|sljit_sw
name|argw
parameter_list|)
block|{
name|SLJIT_ASSERT
argument_list|(
name|arg
operator|&
name|SLJIT_MEM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
operator|(
name|flags
operator|&
name|WRITE_BACK
operator|)
operator|||
operator|!
operator|(
name|arg
operator|&
name|REG_MASK
operator|)
operator|)
operator|&&
operator|!
operator|(
name|arg
operator|&
name|OFFS_REG_MASK
operator|)
operator|&&
name|argw
operator|<=
name|SIMM_MAX
operator|&&
name|argw
operator|>=
name|SIMM_MIN
condition|)
block|{
comment|/* Works for both absoulte and relative addresses. */
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|flags
operator|&
name|ARG_TEST
argument_list|)
condition|)
return|return
literal|1
return|;
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|data_transfer_insts
index|[
name|flags
operator|&
name|MEM_MASK
index|]
operator||
name|S
argument_list|(
name|arg
operator|&
name|REG_MASK
argument_list|)
operator||
name|TA
argument_list|(
name|reg_ar
argument_list|)
operator||
name|IMM
argument_list|(
name|argw
argument_list|)
argument_list|,
operator|(
operator|(
name|flags
operator|&
name|MEM_MASK
operator|)
operator|<=
name|GPR_REG
operator|&&
operator|(
name|flags
operator|&
name|LOAD_DATA
operator|)
operator|)
condition|?
name|reg_ar
else|:
name|MOVABLE_INS
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/* See getput_arg below.    Note: can_cache is called only for binary operators. Those    operators always uses word arguments without write back. */
end_comment
begin_function
DECL|function|can_cache
specifier|static
name|sljit_si
name|can_cache
parameter_list|(
name|sljit_si
name|arg
parameter_list|,
name|sljit_sw
name|argw
parameter_list|,
name|sljit_si
name|next_arg
parameter_list|,
name|sljit_sw
name|next_argw
parameter_list|)
block|{
name|SLJIT_ASSERT
argument_list|(
operator|(
name|arg
operator|&
name|SLJIT_MEM
operator|)
operator|&&
operator|(
name|next_arg
operator|&
name|SLJIT_MEM
operator|)
argument_list|)
expr_stmt|;
comment|/* Simple operation except for updates. */
if|if
condition|(
name|arg
operator|&
name|OFFS_REG_MASK
condition|)
block|{
name|argw
operator|&=
literal|0x3
expr_stmt|;
name|next_argw
operator|&=
literal|0x3
expr_stmt|;
if|if
condition|(
name|argw
operator|&&
name|argw
operator|==
name|next_argw
operator|&&
operator|(
name|arg
operator|==
name|next_arg
operator|||
operator|(
name|arg
operator|&
name|OFFS_REG_MASK
operator|)
operator|==
operator|(
name|next_arg
operator|&
name|OFFS_REG_MASK
operator|)
operator|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|arg
operator|==
name|next_arg
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|next_argw
operator|-
name|argw
operator|)
operator|<=
name|SIMM_MAX
operator|&&
operator|(
name|next_argw
operator|-
name|argw
operator|)
operator|>=
name|SIMM_MIN
operator|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/* Emit the necessary instructions. See can_cache above. */
end_comment
begin_function
DECL|function|getput_arg
specifier|static
name|sljit_si
name|getput_arg
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|flags
parameter_list|,
name|sljit_si
name|reg_ar
parameter_list|,
name|sljit_si
name|arg
parameter_list|,
name|sljit_sw
name|argw
parameter_list|,
name|sljit_si
name|next_arg
parameter_list|,
name|sljit_sw
name|next_argw
parameter_list|)
block|{
name|sljit_si
name|tmp_ar
decl_stmt|,
name|base
decl_stmt|,
name|delay_slot
decl_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|arg
operator|&
name|SLJIT_MEM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|next_arg
operator|&
name|SLJIT_MEM
operator|)
condition|)
block|{
name|next_arg
operator|=
literal|0
expr_stmt|;
name|next_argw
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|MEM_MASK
operator|)
operator|<=
name|GPR_REG
operator|&&
operator|(
name|flags
operator|&
name|LOAD_DATA
operator|)
condition|)
block|{
name|tmp_ar
operator|=
name|reg_ar
expr_stmt|;
name|delay_slot
operator|=
name|reg_ar
expr_stmt|;
block|}
else|else
block|{
name|tmp_ar
operator|=
name|DR
argument_list|(
name|TMP_REG1
argument_list|)
expr_stmt|;
name|delay_slot
operator|=
name|MOVABLE_INS
expr_stmt|;
block|}
name|base
operator|=
name|arg
operator|&
name|REG_MASK
expr_stmt|;
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|arg
operator|&
name|OFFS_REG_MASK
argument_list|)
condition|)
block|{
name|argw
operator|&=
literal|0x3
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|WRITE_BACK
operator|)
operator|&&
name|reg_ar
operator|==
name|DR
argument_list|(
name|base
argument_list|)
condition|)
block|{
name|SLJIT_ASSERT
argument_list|(
operator|!
operator|(
name|flags
operator|&
name|LOAD_DATA
operator|)
operator|&&
name|DR
argument_list|(
name|TMP_REG1
argument_list|)
operator|!=
name|reg_ar
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|ADDU_W
operator||
name|SA
argument_list|(
name|reg_ar
argument_list|)
operator||
name|TA
argument_list|(
literal|0
argument_list|)
operator||
name|D
argument_list|(
name|TMP_REG1
argument_list|)
argument_list|,
name|DR
argument_list|(
name|TMP_REG1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|reg_ar
operator|=
name|DR
argument_list|(
name|TMP_REG1
argument_list|)
expr_stmt|;
block|}
comment|/* Using the cache. */
if|if
condition|(
name|argw
operator|==
name|compiler
operator|->
name|cache_argw
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|WRITE_BACK
operator|)
condition|)
block|{
if|if
condition|(
name|arg
operator|==
name|compiler
operator|->
name|cache_arg
condition|)
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|data_transfer_insts
index|[
name|flags
operator|&
name|MEM_MASK
index|]
operator||
name|S
argument_list|(
name|TMP_REG3
argument_list|)
operator||
name|TA
argument_list|(
name|reg_ar
argument_list|)
argument_list|,
name|delay_slot
argument_list|)
return|;
if|if
condition|(
operator|(
name|SLJIT_MEM
operator||
operator|(
name|arg
operator|&
name|OFFS_REG_MASK
operator|)
operator|)
operator|==
name|compiler
operator|->
name|cache_arg
condition|)
block|{
if|if
condition|(
name|arg
operator|==
name|next_arg
operator|&&
name|argw
operator|==
operator|(
name|next_argw
operator|&
literal|0x3
operator|)
condition|)
block|{
name|compiler
operator|->
name|cache_arg
operator|=
name|arg
expr_stmt|;
name|compiler
operator|->
name|cache_argw
operator|=
name|argw
expr_stmt|;
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|ADDU_W
operator||
name|S
argument_list|(
name|base
argument_list|)
operator||
name|T
argument_list|(
name|TMP_REG3
argument_list|)
operator||
name|D
argument_list|(
name|TMP_REG3
argument_list|)
argument_list|,
name|DR
argument_list|(
name|TMP_REG3
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|data_transfer_insts
index|[
name|flags
operator|&
name|MEM_MASK
index|]
operator||
name|S
argument_list|(
name|TMP_REG3
argument_list|)
operator||
name|TA
argument_list|(
name|reg_ar
argument_list|)
argument_list|,
name|delay_slot
argument_list|)
return|;
block|}
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|ADDU_W
operator||
name|S
argument_list|(
name|base
argument_list|)
operator||
name|T
argument_list|(
name|TMP_REG3
argument_list|)
operator||
name|DA
argument_list|(
name|tmp_ar
argument_list|)
argument_list|,
name|tmp_ar
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|data_transfer_insts
index|[
name|flags
operator|&
name|MEM_MASK
index|]
operator||
name|SA
argument_list|(
name|tmp_ar
argument_list|)
operator||
name|TA
argument_list|(
name|reg_ar
argument_list|)
argument_list|,
name|delay_slot
argument_list|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|SLJIT_MEM
operator||
operator|(
name|arg
operator|&
name|OFFS_REG_MASK
operator|)
operator|)
operator|==
name|compiler
operator|->
name|cache_arg
condition|)
block|{
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|ADDU_W
operator||
name|S
argument_list|(
name|base
argument_list|)
operator||
name|T
argument_list|(
name|TMP_REG3
argument_list|)
operator||
name|D
argument_list|(
name|base
argument_list|)
argument_list|,
name|DR
argument_list|(
name|base
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|data_transfer_insts
index|[
name|flags
operator|&
name|MEM_MASK
index|]
operator||
name|S
argument_list|(
name|base
argument_list|)
operator||
name|TA
argument_list|(
name|reg_ar
argument_list|)
argument_list|,
name|delay_slot
argument_list|)
return|;
block|}
block|}
block|}
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|argw
argument_list|)
condition|)
block|{
name|compiler
operator|->
name|cache_arg
operator|=
name|SLJIT_MEM
operator||
operator|(
name|arg
operator|&
name|OFFS_REG_MASK
operator|)
expr_stmt|;
name|compiler
operator|->
name|cache_argw
operator|=
name|argw
expr_stmt|;
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|SLL_W
operator||
name|T
argument_list|(
name|OFFS_REG
argument_list|(
name|arg
argument_list|)
argument_list|)
operator||
name|D
argument_list|(
name|TMP_REG3
argument_list|)
operator||
name|SH_IMM
argument_list|(
name|argw
argument_list|)
argument_list|,
name|DR
argument_list|(
name|TMP_REG3
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|WRITE_BACK
operator|)
condition|)
block|{
if|if
condition|(
name|arg
operator|==
name|next_arg
operator|&&
name|argw
operator|==
operator|(
name|next_argw
operator|&
literal|0x3
operator|)
condition|)
block|{
name|compiler
operator|->
name|cache_arg
operator|=
name|arg
expr_stmt|;
name|compiler
operator|->
name|cache_argw
operator|=
name|argw
expr_stmt|;
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|ADDU_W
operator||
name|S
argument_list|(
name|base
argument_list|)
operator||
name|T
argument_list|(
operator|!
name|argw
condition|?
name|OFFS_REG
argument_list|(
name|arg
argument_list|)
else|:
name|TMP_REG3
argument_list|)
operator||
name|D
argument_list|(
name|TMP_REG3
argument_list|)
argument_list|,
name|DR
argument_list|(
name|TMP_REG3
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|tmp_ar
operator|=
name|DR
argument_list|(
name|TMP_REG3
argument_list|)
expr_stmt|;
block|}
else|else
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|ADDU_W
operator||
name|S
argument_list|(
name|base
argument_list|)
operator||
name|T
argument_list|(
operator|!
name|argw
condition|?
name|OFFS_REG
argument_list|(
name|arg
argument_list|)
else|:
name|TMP_REG3
argument_list|)
operator||
name|DA
argument_list|(
name|tmp_ar
argument_list|)
argument_list|,
name|tmp_ar
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|data_transfer_insts
index|[
name|flags
operator|&
name|MEM_MASK
index|]
operator||
name|SA
argument_list|(
name|tmp_ar
argument_list|)
operator||
name|TA
argument_list|(
name|reg_ar
argument_list|)
argument_list|,
name|delay_slot
argument_list|)
return|;
block|}
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|ADDU_W
operator||
name|S
argument_list|(
name|base
argument_list|)
operator||
name|T
argument_list|(
operator|!
name|argw
condition|?
name|OFFS_REG
argument_list|(
name|arg
argument_list|)
else|:
name|TMP_REG3
argument_list|)
operator||
name|D
argument_list|(
name|base
argument_list|)
argument_list|,
name|DR
argument_list|(
name|base
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|data_transfer_insts
index|[
name|flags
operator|&
name|MEM_MASK
index|]
operator||
name|S
argument_list|(
name|base
argument_list|)
operator||
name|TA
argument_list|(
name|reg_ar
argument_list|)
argument_list|,
name|delay_slot
argument_list|)
return|;
block|}
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|flags
operator|&
name|WRITE_BACK
argument_list|)
operator|&&
name|base
condition|)
block|{
comment|/* Update only applies if a base register exists. */
if|if
condition|(
name|reg_ar
operator|==
name|DR
argument_list|(
name|base
argument_list|)
condition|)
block|{
name|SLJIT_ASSERT
argument_list|(
operator|!
operator|(
name|flags
operator|&
name|LOAD_DATA
operator|)
operator|&&
name|DR
argument_list|(
name|TMP_REG1
argument_list|)
operator|!=
name|reg_ar
argument_list|)
expr_stmt|;
if|if
condition|(
name|argw
operator|<=
name|SIMM_MAX
operator|&&
name|argw
operator|>=
name|SIMM_MIN
condition|)
block|{
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|data_transfer_insts
index|[
name|flags
operator|&
name|MEM_MASK
index|]
operator||
name|S
argument_list|(
name|base
argument_list|)
operator||
name|TA
argument_list|(
name|reg_ar
argument_list|)
operator||
name|IMM
argument_list|(
name|argw
argument_list|)
argument_list|,
name|MOVABLE_INS
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|argw
condition|)
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|ADDIU_W
operator||
name|S
argument_list|(
name|base
argument_list|)
operator||
name|T
argument_list|(
name|base
argument_list|)
operator||
name|IMM
argument_list|(
name|argw
argument_list|)
argument_list|,
name|DR
argument_list|(
name|base
argument_list|)
argument_list|)
return|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|ADDU_W
operator||
name|SA
argument_list|(
name|reg_ar
argument_list|)
operator||
name|TA
argument_list|(
literal|0
argument_list|)
operator||
name|D
argument_list|(
name|TMP_REG1
argument_list|)
argument_list|,
name|DR
argument_list|(
name|TMP_REG1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|reg_ar
operator|=
name|DR
argument_list|(
name|TMP_REG1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argw
operator|<=
name|SIMM_MAX
operator|&&
name|argw
operator|>=
name|SIMM_MIN
condition|)
block|{
if|if
condition|(
name|argw
condition|)
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|ADDIU_W
operator||
name|S
argument_list|(
name|base
argument_list|)
operator||
name|T
argument_list|(
name|base
argument_list|)
operator||
name|IMM
argument_list|(
name|argw
argument_list|)
argument_list|,
name|DR
argument_list|(
name|base
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|compiler
operator|->
name|cache_arg
operator|==
name|SLJIT_MEM
operator|&&
name|argw
operator|-
name|compiler
operator|->
name|cache_argw
operator|<=
name|SIMM_MAX
operator|&&
name|argw
operator|-
name|compiler
operator|->
name|cache_argw
operator|>=
name|SIMM_MIN
condition|)
block|{
if|if
condition|(
name|argw
operator|!=
name|compiler
operator|->
name|cache_argw
condition|)
block|{
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|ADDIU_W
operator||
name|S
argument_list|(
name|TMP_REG3
argument_list|)
operator||
name|T
argument_list|(
name|TMP_REG3
argument_list|)
operator||
name|IMM
argument_list|(
name|argw
operator|-
name|compiler
operator|->
name|cache_argw
argument_list|)
argument_list|,
name|DR
argument_list|(
name|TMP_REG3
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|compiler
operator|->
name|cache_argw
operator|=
name|argw
expr_stmt|;
block|}
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|ADDU_W
operator||
name|S
argument_list|(
name|base
argument_list|)
operator||
name|T
argument_list|(
name|TMP_REG3
argument_list|)
operator||
name|D
argument_list|(
name|base
argument_list|)
argument_list|,
name|DR
argument_list|(
name|base
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|compiler
operator|->
name|cache_arg
operator|=
name|SLJIT_MEM
expr_stmt|;
name|compiler
operator|->
name|cache_argw
operator|=
name|argw
expr_stmt|;
name|FAIL_IF
argument_list|(
name|load_immediate
argument_list|(
name|compiler
argument_list|,
name|DR
argument_list|(
name|TMP_REG3
argument_list|)
argument_list|,
name|argw
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|ADDU_W
operator||
name|S
argument_list|(
name|base
argument_list|)
operator||
name|T
argument_list|(
name|TMP_REG3
argument_list|)
operator||
name|D
argument_list|(
name|base
argument_list|)
argument_list|,
name|DR
argument_list|(
name|base
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|data_transfer_insts
index|[
name|flags
operator|&
name|MEM_MASK
index|]
operator||
name|S
argument_list|(
name|base
argument_list|)
operator||
name|TA
argument_list|(
name|reg_ar
argument_list|)
argument_list|,
name|delay_slot
argument_list|)
return|;
block|}
if|if
condition|(
name|compiler
operator|->
name|cache_arg
operator|==
name|arg
operator|&&
name|argw
operator|-
name|compiler
operator|->
name|cache_argw
operator|<=
name|SIMM_MAX
operator|&&
name|argw
operator|-
name|compiler
operator|->
name|cache_argw
operator|>=
name|SIMM_MIN
condition|)
block|{
if|if
condition|(
name|argw
operator|!=
name|compiler
operator|->
name|cache_argw
condition|)
block|{
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|ADDIU_W
operator||
name|S
argument_list|(
name|TMP_REG3
argument_list|)
operator||
name|T
argument_list|(
name|TMP_REG3
argument_list|)
operator||
name|IMM
argument_list|(
name|argw
operator|-
name|compiler
operator|->
name|cache_argw
argument_list|)
argument_list|,
name|DR
argument_list|(
name|TMP_REG3
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|compiler
operator|->
name|cache_argw
operator|=
name|argw
expr_stmt|;
block|}
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|data_transfer_insts
index|[
name|flags
operator|&
name|MEM_MASK
index|]
operator||
name|S
argument_list|(
name|TMP_REG3
argument_list|)
operator||
name|TA
argument_list|(
name|reg_ar
argument_list|)
argument_list|,
name|delay_slot
argument_list|)
return|;
block|}
if|if
condition|(
name|compiler
operator|->
name|cache_arg
operator|==
name|SLJIT_MEM
operator|&&
name|argw
operator|-
name|compiler
operator|->
name|cache_argw
operator|<=
name|SIMM_MAX
operator|&&
name|argw
operator|-
name|compiler
operator|->
name|cache_argw
operator|>=
name|SIMM_MIN
condition|)
block|{
if|if
condition|(
name|argw
operator|!=
name|compiler
operator|->
name|cache_argw
condition|)
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|ADDIU_W
operator||
name|S
argument_list|(
name|TMP_REG3
argument_list|)
operator||
name|T
argument_list|(
name|TMP_REG3
argument_list|)
operator||
name|IMM
argument_list|(
name|argw
operator|-
name|compiler
operator|->
name|cache_argw
argument_list|)
argument_list|,
name|DR
argument_list|(
name|TMP_REG3
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|compiler
operator|->
name|cache_arg
operator|=
name|SLJIT_MEM
expr_stmt|;
name|FAIL_IF
argument_list|(
name|load_immediate
argument_list|(
name|compiler
argument_list|,
name|DR
argument_list|(
name|TMP_REG3
argument_list|)
argument_list|,
name|argw
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|compiler
operator|->
name|cache_argw
operator|=
name|argw
expr_stmt|;
if|if
condition|(
operator|!
name|base
condition|)
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|data_transfer_insts
index|[
name|flags
operator|&
name|MEM_MASK
index|]
operator||
name|S
argument_list|(
name|TMP_REG3
argument_list|)
operator||
name|TA
argument_list|(
name|reg_ar
argument_list|)
argument_list|,
name|delay_slot
argument_list|)
return|;
if|if
condition|(
name|arg
operator|==
name|next_arg
operator|&&
name|next_argw
operator|-
name|argw
operator|<=
name|SIMM_MAX
operator|&&
name|next_argw
operator|-
name|argw
operator|>=
name|SIMM_MIN
condition|)
block|{
name|compiler
operator|->
name|cache_arg
operator|=
name|arg
expr_stmt|;
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|ADDU_W
operator||
name|S
argument_list|(
name|TMP_REG3
argument_list|)
operator||
name|T
argument_list|(
name|base
argument_list|)
operator||
name|D
argument_list|(
name|TMP_REG3
argument_list|)
argument_list|,
name|DR
argument_list|(
name|TMP_REG3
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|data_transfer_insts
index|[
name|flags
operator|&
name|MEM_MASK
index|]
operator||
name|S
argument_list|(
name|TMP_REG3
argument_list|)
operator||
name|TA
argument_list|(
name|reg_ar
argument_list|)
argument_list|,
name|delay_slot
argument_list|)
return|;
block|}
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|ADDU_W
operator||
name|S
argument_list|(
name|TMP_REG3
argument_list|)
operator||
name|T
argument_list|(
name|base
argument_list|)
operator||
name|DA
argument_list|(
name|tmp_ar
argument_list|)
argument_list|,
name|tmp_ar
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|data_transfer_insts
index|[
name|flags
operator|&
name|MEM_MASK
index|]
operator||
name|SA
argument_list|(
name|tmp_ar
argument_list|)
operator||
name|TA
argument_list|(
name|reg_ar
argument_list|)
argument_list|,
name|delay_slot
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|emit_op_mem
specifier|static
name|SLJIT_INLINE
name|sljit_si
name|emit_op_mem
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|flags
parameter_list|,
name|sljit_si
name|reg_ar
parameter_list|,
name|sljit_si
name|arg
parameter_list|,
name|sljit_sw
name|argw
parameter_list|)
block|{
if|if
condition|(
name|getput_arg_fast
argument_list|(
name|compiler
argument_list|,
name|flags
argument_list|,
name|reg_ar
argument_list|,
name|arg
argument_list|,
name|argw
argument_list|)
condition|)
return|return
name|compiler
operator|->
name|error
return|;
name|compiler
operator|->
name|cache_arg
operator|=
literal|0
expr_stmt|;
name|compiler
operator|->
name|cache_argw
operator|=
literal|0
expr_stmt|;
return|return
name|getput_arg
argument_list|(
name|compiler
argument_list|,
name|flags
argument_list|,
name|reg_ar
argument_list|,
name|arg
argument_list|,
name|argw
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|emit_op_mem2
specifier|static
name|SLJIT_INLINE
name|sljit_si
name|emit_op_mem2
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|flags
parameter_list|,
name|sljit_si
name|reg
parameter_list|,
name|sljit_si
name|arg1
parameter_list|,
name|sljit_sw
name|arg1w
parameter_list|,
name|sljit_si
name|arg2
parameter_list|,
name|sljit_sw
name|arg2w
parameter_list|)
block|{
if|if
condition|(
name|getput_arg_fast
argument_list|(
name|compiler
argument_list|,
name|flags
argument_list|,
name|reg
argument_list|,
name|arg1
argument_list|,
name|arg1w
argument_list|)
condition|)
return|return
name|compiler
operator|->
name|error
return|;
return|return
name|getput_arg
argument_list|(
name|compiler
argument_list|,
name|flags
argument_list|,
name|reg
argument_list|,
name|arg1
argument_list|,
name|arg1w
argument_list|,
name|arg2
argument_list|,
name|arg2w
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|emit_op
specifier|static
name|sljit_si
name|emit_op
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|flags
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src1
parameter_list|,
name|sljit_sw
name|src1w
parameter_list|,
name|sljit_si
name|src2
parameter_list|,
name|sljit_sw
name|src2w
parameter_list|)
block|{
comment|/* arg1 goes to TMP_REG1 or src reg 	   arg2 goes to TMP_REG2, imm or src reg 	   TMP_REG3 can be used for caching 	   result goes to TMP_REG2, so put result can use TMP_REG1 and TMP_REG3. */
name|sljit_si
name|dst_r
init|=
name|TMP_REG2
decl_stmt|;
name|sljit_si
name|src1_r
decl_stmt|;
name|sljit_sw
name|src2_r
init|=
literal|0
decl_stmt|;
name|sljit_si
name|sugg_src2_r
init|=
name|TMP_REG2
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|ALT_KEEP_CACHE
operator|)
condition|)
block|{
name|compiler
operator|->
name|cache_arg
operator|=
literal|0
expr_stmt|;
name|compiler
operator|->
name|cache_argw
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|dst
operator|==
name|SLJIT_UNUSED
argument_list|)
condition|)
block|{
if|if
condition|(
name|op
operator|>=
name|SLJIT_MOV
operator|&&
name|op
operator|<=
name|SLJIT_MOVU_SI
operator|&&
operator|!
operator|(
name|src2
operator|&
name|SLJIT_MEM
operator|)
condition|)
return|return
name|SLJIT_SUCCESS
return|;
if|if
condition|(
name|GET_FLAGS
argument_list|(
name|op
argument_list|)
condition|)
name|flags
operator||=
name|UNUSED_DEST
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|FAST_IS_REG
argument_list|(
name|dst
argument_list|)
condition|)
block|{
name|dst_r
operator|=
name|dst
expr_stmt|;
name|flags
operator||=
name|REG_DEST
expr_stmt|;
if|if
condition|(
name|op
operator|>=
name|SLJIT_MOV
operator|&&
name|op
operator|<=
name|SLJIT_MOVU_SI
condition|)
name|sugg_src2_r
operator|=
name|dst_r
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|dst
operator|&
name|SLJIT_MEM
operator|)
operator|&&
operator|!
name|getput_arg_fast
argument_list|(
name|compiler
argument_list|,
name|flags
operator||
name|ARG_TEST
argument_list|,
name|DR
argument_list|(
name|TMP_REG1
argument_list|)
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
condition|)
name|flags
operator||=
name|SLOW_DEST
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|IMM_OP
condition|)
block|{
if|if
condition|(
operator|(
name|src2
operator|&
name|SLJIT_IMM
operator|)
operator|&&
name|src2w
condition|)
block|{
if|if
condition|(
operator|(
operator|!
operator|(
name|flags
operator|&
name|LOGICAL_OP
operator|)
operator|&&
operator|(
name|src2w
operator|<=
name|SIMM_MAX
operator|&&
name|src2w
operator|>=
name|SIMM_MIN
operator|)
operator|)
operator|||
operator|(
operator|(
name|flags
operator|&
name|LOGICAL_OP
operator|)
operator|&&
operator|!
operator|(
name|src2w
operator|&
operator|~
name|UIMM_MAX
operator|)
operator|)
condition|)
block|{
name|flags
operator||=
name|SRC2_IMM
expr_stmt|;
name|src2_r
operator|=
name|src2w
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SRC2_IMM
operator|)
operator|&&
operator|(
name|flags
operator|&
name|CUMULATIVE_OP
operator|)
operator|&&
operator|(
name|src1
operator|&
name|SLJIT_IMM
operator|)
operator|&&
name|src1w
condition|)
block|{
if|if
condition|(
operator|(
operator|!
operator|(
name|flags
operator|&
name|LOGICAL_OP
operator|)
operator|&&
operator|(
name|src1w
operator|<=
name|SIMM_MAX
operator|&&
name|src1w
operator|>=
name|SIMM_MIN
operator|)
operator|)
operator|||
operator|(
operator|(
name|flags
operator|&
name|LOGICAL_OP
operator|)
operator|&&
operator|!
operator|(
name|src1w
operator|&
operator|~
name|UIMM_MAX
operator|)
operator|)
condition|)
block|{
name|flags
operator||=
name|SRC2_IMM
expr_stmt|;
name|src2_r
operator|=
name|src1w
expr_stmt|;
comment|/* And swap arguments. */
name|src1
operator|=
name|src2
expr_stmt|;
name|src1w
operator|=
name|src2w
expr_stmt|;
name|src2
operator|=
name|SLJIT_IMM
expr_stmt|;
comment|/* src2w = src2_r unneeded. */
block|}
block|}
block|}
comment|/* Source 1. */
if|if
condition|(
name|FAST_IS_REG
argument_list|(
name|src1
argument_list|)
condition|)
block|{
name|src1_r
operator|=
name|src1
expr_stmt|;
name|flags
operator||=
name|REG1_SOURCE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|src1
operator|&
name|SLJIT_IMM
condition|)
block|{
if|if
condition|(
name|src1w
condition|)
block|{
name|FAIL_IF
argument_list|(
name|load_immediate
argument_list|(
name|compiler
argument_list|,
name|DR
argument_list|(
name|TMP_REG1
argument_list|)
argument_list|,
name|src1w
argument_list|)
argument_list|)
expr_stmt|;
name|src1_r
operator|=
name|TMP_REG1
expr_stmt|;
block|}
else|else
name|src1_r
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|getput_arg_fast
argument_list|(
name|compiler
argument_list|,
name|flags
operator||
name|LOAD_DATA
argument_list|,
name|DR
argument_list|(
name|TMP_REG1
argument_list|)
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
condition|)
name|FAIL_IF
argument_list|(
name|compiler
operator|->
name|error
argument_list|)
expr_stmt|;
else|else
name|flags
operator||=
name|SLOW_SRC1
expr_stmt|;
name|src1_r
operator|=
name|TMP_REG1
expr_stmt|;
block|}
comment|/* Source 2. */
if|if
condition|(
name|FAST_IS_REG
argument_list|(
name|src2
argument_list|)
condition|)
block|{
name|src2_r
operator|=
name|src2
expr_stmt|;
name|flags
operator||=
name|REG2_SOURCE
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|REG_DEST
operator|)
operator|&&
name|op
operator|>=
name|SLJIT_MOV
operator|&&
name|op
operator|<=
name|SLJIT_MOVU_SI
condition|)
name|dst_r
operator|=
name|src2_r
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|src2
operator|&
name|SLJIT_IMM
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SRC2_IMM
operator|)
condition|)
block|{
if|if
condition|(
name|src2w
condition|)
block|{
name|FAIL_IF
argument_list|(
name|load_immediate
argument_list|(
name|compiler
argument_list|,
name|DR
argument_list|(
name|sugg_src2_r
argument_list|)
argument_list|,
name|src2w
argument_list|)
argument_list|)
expr_stmt|;
name|src2_r
operator|=
name|sugg_src2_r
expr_stmt|;
block|}
else|else
block|{
name|src2_r
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|op
operator|>=
name|SLJIT_MOV
operator|&&
name|op
operator|<=
name|SLJIT_MOVU_SI
operator|)
operator|&&
operator|(
name|dst
operator|&
name|SLJIT_MEM
operator|)
condition|)
name|dst_r
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|getput_arg_fast
argument_list|(
name|compiler
argument_list|,
name|flags
operator||
name|LOAD_DATA
argument_list|,
name|DR
argument_list|(
name|sugg_src2_r
argument_list|)
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
condition|)
name|FAIL_IF
argument_list|(
name|compiler
operator|->
name|error
argument_list|)
expr_stmt|;
else|else
name|flags
operator||=
name|SLOW_SRC2
expr_stmt|;
name|src2_r
operator|=
name|sugg_src2_r
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|SLOW_SRC1
operator||
name|SLOW_SRC2
operator|)
operator|)
operator|==
operator|(
name|SLOW_SRC1
operator||
name|SLOW_SRC2
operator|)
condition|)
block|{
name|SLJIT_ASSERT
argument_list|(
name|src2_r
operator|==
name|TMP_REG2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|can_cache
argument_list|(
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
operator|&&
name|can_cache
argument_list|(
name|src1
argument_list|,
name|src1w
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
condition|)
block|{
name|FAIL_IF
argument_list|(
name|getput_arg
argument_list|(
name|compiler
argument_list|,
name|flags
operator||
name|LOAD_DATA
argument_list|,
name|DR
argument_list|(
name|TMP_REG2
argument_list|)
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|getput_arg
argument_list|(
name|compiler
argument_list|,
name|flags
operator||
name|LOAD_DATA
argument_list|,
name|DR
argument_list|(
name|TMP_REG1
argument_list|)
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|FAIL_IF
argument_list|(
name|getput_arg
argument_list|(
name|compiler
argument_list|,
name|flags
operator||
name|LOAD_DATA
argument_list|,
name|DR
argument_list|(
name|TMP_REG1
argument_list|)
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|getput_arg
argument_list|(
name|compiler
argument_list|,
name|flags
operator||
name|LOAD_DATA
argument_list|,
name|DR
argument_list|(
name|TMP_REG2
argument_list|)
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|SLOW_SRC1
condition|)
name|FAIL_IF
argument_list|(
name|getput_arg
argument_list|(
name|compiler
argument_list|,
name|flags
operator||
name|LOAD_DATA
argument_list|,
name|DR
argument_list|(
name|TMP_REG1
argument_list|)
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|SLOW_SRC2
condition|)
name|FAIL_IF
argument_list|(
name|getput_arg
argument_list|(
name|compiler
argument_list|,
name|flags
operator||
name|LOAD_DATA
argument_list|,
name|DR
argument_list|(
name|sugg_src2_r
argument_list|)
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|emit_single_op
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|flags
argument_list|,
name|dst_r
argument_list|,
name|src1_r
argument_list|,
name|src2_r
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|&
name|SLJIT_MEM
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SLOW_DEST
operator|)
condition|)
block|{
name|getput_arg_fast
argument_list|(
name|compiler
argument_list|,
name|flags
argument_list|,
name|DR
argument_list|(
name|dst_r
argument_list|)
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
return|return
name|compiler
operator|->
name|error
return|;
block|}
return|return
name|getput_arg
argument_list|(
name|compiler
argument_list|,
name|flags
argument_list|,
name|DR
argument_list|(
name|dst_r
argument_list|)
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_op0
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_op0
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|)
block|{
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_MIPS_64
operator|&&
name|SLJIT_CONFIG_MIPS_64
operator|)
name|sljit_si
name|int_op
init|=
name|op
operator|&
name|SLJIT_INT_OP
decl_stmt|;
endif|#
directive|endif
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|check_sljit_emit_op0
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|op
operator|=
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|SLJIT_BREAKPOINT
case|:
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|BREAK
argument_list|,
name|UNMOVABLE_INS
argument_list|)
return|;
case|case
name|SLJIT_NOP
case|:
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|NOP
argument_list|,
name|UNMOVABLE_INS
argument_list|)
return|;
case|case
name|SLJIT_UMUL
case|:
case|case
name|SLJIT_SMUL
case|:
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_MIPS_64
operator|&&
name|SLJIT_CONFIG_MIPS_64
operator|)
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
operator|(
name|op
operator|==
name|SLJIT_UMUL
condition|?
name|DMULTU
else|:
name|DMULT
operator|)
operator||
name|S
argument_list|(
name|SLJIT_SCRATCH_REG1
argument_list|)
operator||
name|T
argument_list|(
name|SLJIT_SCRATCH_REG2
argument_list|)
argument_list|,
name|MOVABLE_INS
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
operator|(
name|op
operator|==
name|SLJIT_UMUL
condition|?
name|MULTU
else|:
name|MULT
operator|)
operator||
name|S
argument_list|(
name|SLJIT_SCRATCH_REG1
argument_list|)
operator||
name|T
argument_list|(
name|SLJIT_SCRATCH_REG2
argument_list|)
argument_list|,
name|MOVABLE_INS
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|MFLO
operator||
name|D
argument_list|(
name|SLJIT_SCRATCH_REG1
argument_list|)
argument_list|,
name|DR
argument_list|(
name|SLJIT_SCRATCH_REG1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|MFHI
operator||
name|D
argument_list|(
name|SLJIT_SCRATCH_REG2
argument_list|)
argument_list|,
name|DR
argument_list|(
name|SLJIT_SCRATCH_REG2
argument_list|)
argument_list|)
return|;
case|case
name|SLJIT_UDIV
case|:
case|case
name|SLJIT_SDIV
case|:
if|#
directive|if
operator|!
operator|(
name|defined
name|SLJIT_MIPS_32_64
operator|&&
name|SLJIT_MIPS_32_64
operator|)
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|NOP
argument_list|,
name|UNMOVABLE_INS
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|NOP
argument_list|,
name|UNMOVABLE_INS
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_MIPS_64
operator|&&
name|SLJIT_CONFIG_MIPS_64
operator|)
if|if
condition|(
name|int_op
condition|)
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
operator|(
name|op
operator|==
name|SLJIT_UDIV
condition|?
name|DIVU
else|:
name|DIV
operator|)
operator||
name|S
argument_list|(
name|SLJIT_SCRATCH_REG1
argument_list|)
operator||
name|T
argument_list|(
name|SLJIT_SCRATCH_REG2
argument_list|)
argument_list|,
name|MOVABLE_INS
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
operator|(
name|op
operator|==
name|SLJIT_UDIV
condition|?
name|DDIVU
else|:
name|DDIV
operator|)
operator||
name|S
argument_list|(
name|SLJIT_SCRATCH_REG1
argument_list|)
operator||
name|T
argument_list|(
name|SLJIT_SCRATCH_REG2
argument_list|)
argument_list|,
name|MOVABLE_INS
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
operator|(
name|op
operator|==
name|SLJIT_UDIV
condition|?
name|DIVU
else|:
name|DIV
operator|)
operator||
name|S
argument_list|(
name|SLJIT_SCRATCH_REG1
argument_list|)
operator||
name|T
argument_list|(
name|SLJIT_SCRATCH_REG2
argument_list|)
argument_list|,
name|MOVABLE_INS
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|MFLO
operator||
name|D
argument_list|(
name|SLJIT_SCRATCH_REG1
argument_list|)
argument_list|,
name|DR
argument_list|(
name|SLJIT_SCRATCH_REG1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|MFHI
operator||
name|D
argument_list|(
name|SLJIT_SCRATCH_REG2
argument_list|)
argument_list|,
name|DR
argument_list|(
name|SLJIT_SCRATCH_REG2
argument_list|)
argument_list|)
return|;
block|}
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_op1
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_op1
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|)
block|{
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_MIPS_32
operator|&&
name|SLJIT_CONFIG_MIPS_32
operator|)
DECL|macro|flags
define|#
directive|define
name|flags
value|0
else|#
directive|else
name|sljit_si
name|flags
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|check_sljit_emit_op1
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|ADJUST_LOCAL_OFFSET
argument_list|(
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|ADJUST_LOCAL_OFFSET
argument_list|(
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_MIPS_64
operator|&&
name|SLJIT_CONFIG_MIPS_64
operator|)
if|if
condition|(
operator|(
name|op
operator|&
name|SLJIT_INT_OP
operator|)
operator|&&
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
operator|>=
name|SLJIT_NOT
condition|)
block|{
name|flags
operator||=
name|INT_DATA
operator||
name|SIGNED_DATA
expr_stmt|;
if|if
condition|(
name|src
operator|&
name|SLJIT_IMM
condition|)
name|srcw
operator|=
operator|(
name|sljit_si
operator|)
name|srcw
expr_stmt|;
block|}
endif|#
directive|endif
switch|switch
condition|(
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|SLJIT_MOV
case|:
case|case
name|SLJIT_MOV_P
case|:
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MOV
argument_list|,
name|WORD_DATA
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REG1
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
return|;
case|case
name|SLJIT_MOV_UI
case|:
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_MIPS_32
operator|&&
name|SLJIT_CONFIG_MIPS_32
operator|)
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MOV_UI
argument_list|,
name|INT_DATA
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REG1
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
return|;
else|#
directive|else
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MOV_UI
argument_list|,
name|INT_DATA
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REG1
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
operator|(
name|src
operator|&
name|SLJIT_IMM
operator|)
condition|?
operator|(
name|sljit_ui
operator|)
name|srcw
else|:
name|srcw
argument_list|)
return|;
endif|#
directive|endif
case|case
name|SLJIT_MOV_SI
case|:
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_MIPS_32
operator|&&
name|SLJIT_CONFIG_MIPS_32
operator|)
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MOV_SI
argument_list|,
name|INT_DATA
operator||
name|SIGNED_DATA
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REG1
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
return|;
else|#
directive|else
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MOV_SI
argument_list|,
name|INT_DATA
operator||
name|SIGNED_DATA
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REG1
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
operator|(
name|src
operator|&
name|SLJIT_IMM
operator|)
condition|?
operator|(
name|sljit_si
operator|)
name|srcw
else|:
name|srcw
argument_list|)
return|;
endif|#
directive|endif
case|case
name|SLJIT_MOV_UB
case|:
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MOV_UB
argument_list|,
name|BYTE_DATA
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REG1
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
operator|(
name|src
operator|&
name|SLJIT_IMM
operator|)
condition|?
operator|(
name|sljit_ub
operator|)
name|srcw
else|:
name|srcw
argument_list|)
return|;
case|case
name|SLJIT_MOV_SB
case|:
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MOV_SB
argument_list|,
name|BYTE_DATA
operator||
name|SIGNED_DATA
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REG1
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
operator|(
name|src
operator|&
name|SLJIT_IMM
operator|)
condition|?
operator|(
name|sljit_sb
operator|)
name|srcw
else|:
name|srcw
argument_list|)
return|;
case|case
name|SLJIT_MOV_UH
case|:
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MOV_UH
argument_list|,
name|HALF_DATA
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REG1
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
operator|(
name|src
operator|&
name|SLJIT_IMM
operator|)
condition|?
operator|(
name|sljit_uh
operator|)
name|srcw
else|:
name|srcw
argument_list|)
return|;
case|case
name|SLJIT_MOV_SH
case|:
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MOV_SH
argument_list|,
name|HALF_DATA
operator||
name|SIGNED_DATA
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REG1
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
operator|(
name|src
operator|&
name|SLJIT_IMM
operator|)
condition|?
operator|(
name|sljit_sh
operator|)
name|srcw
else|:
name|srcw
argument_list|)
return|;
case|case
name|SLJIT_MOVU
case|:
case|case
name|SLJIT_MOVU_P
case|:
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MOV
argument_list|,
name|WORD_DATA
operator||
name|WRITE_BACK
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REG1
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
return|;
case|case
name|SLJIT_MOVU_UI
case|:
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_MIPS_32
operator|&&
name|SLJIT_CONFIG_MIPS_32
operator|)
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MOV_UI
argument_list|,
name|INT_DATA
operator||
name|WRITE_BACK
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REG1
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
return|;
else|#
directive|else
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MOV_UI
argument_list|,
name|INT_DATA
operator||
name|WRITE_BACK
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REG1
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
operator|(
name|src
operator|&
name|SLJIT_IMM
operator|)
condition|?
operator|(
name|sljit_ui
operator|)
name|srcw
else|:
name|srcw
argument_list|)
return|;
endif|#
directive|endif
case|case
name|SLJIT_MOVU_SI
case|:
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_MIPS_32
operator|&&
name|SLJIT_CONFIG_MIPS_32
operator|)
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MOV_SI
argument_list|,
name|INT_DATA
operator||
name|SIGNED_DATA
operator||
name|WRITE_BACK
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REG1
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
return|;
else|#
directive|else
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MOV_SI
argument_list|,
name|INT_DATA
operator||
name|SIGNED_DATA
operator||
name|WRITE_BACK
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REG1
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
operator|(
name|src
operator|&
name|SLJIT_IMM
operator|)
condition|?
operator|(
name|sljit_si
operator|)
name|srcw
else|:
name|srcw
argument_list|)
return|;
endif|#
directive|endif
case|case
name|SLJIT_MOVU_UB
case|:
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MOV_UB
argument_list|,
name|BYTE_DATA
operator||
name|WRITE_BACK
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REG1
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
operator|(
name|src
operator|&
name|SLJIT_IMM
operator|)
condition|?
operator|(
name|sljit_ub
operator|)
name|srcw
else|:
name|srcw
argument_list|)
return|;
case|case
name|SLJIT_MOVU_SB
case|:
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MOV_SB
argument_list|,
name|BYTE_DATA
operator||
name|SIGNED_DATA
operator||
name|WRITE_BACK
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REG1
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
operator|(
name|src
operator|&
name|SLJIT_IMM
operator|)
condition|?
operator|(
name|sljit_sb
operator|)
name|srcw
else|:
name|srcw
argument_list|)
return|;
case|case
name|SLJIT_MOVU_UH
case|:
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MOV_UH
argument_list|,
name|HALF_DATA
operator||
name|WRITE_BACK
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REG1
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
operator|(
name|src
operator|&
name|SLJIT_IMM
operator|)
condition|?
operator|(
name|sljit_uh
operator|)
name|srcw
else|:
name|srcw
argument_list|)
return|;
case|case
name|SLJIT_MOVU_SH
case|:
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MOV_SH
argument_list|,
name|HALF_DATA
operator||
name|SIGNED_DATA
operator||
name|WRITE_BACK
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REG1
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
operator|(
name|src
operator|&
name|SLJIT_IMM
operator|)
condition|?
operator|(
name|sljit_sh
operator|)
name|srcw
else|:
name|srcw
argument_list|)
return|;
case|case
name|SLJIT_NOT
case|:
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|flags
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REG1
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
return|;
case|case
name|SLJIT_NEG
case|:
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_SUB
operator||
name|GET_ALL_FLAGS
argument_list|(
name|op
argument_list|)
argument_list|,
name|flags
operator||
name|IMM_OP
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
return|;
case|case
name|SLJIT_CLZ
case|:
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|flags
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REG1
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
return|;
block|}
return|return
name|SLJIT_SUCCESS
return|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_MIPS_32
operator|&&
name|SLJIT_CONFIG_MIPS_32
operator|)
DECL|macro|flags
undef|#
directive|undef
name|flags
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|sljit_emit_op2
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_op2
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src1
parameter_list|,
name|sljit_sw
name|src1w
parameter_list|,
name|sljit_si
name|src2
parameter_list|,
name|sljit_sw
name|src2w
parameter_list|)
block|{
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_MIPS_32
operator|&&
name|SLJIT_CONFIG_MIPS_32
operator|)
DECL|macro|flags
define|#
directive|define
name|flags
value|0
else|#
directive|else
name|sljit_si
name|flags
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|check_sljit_emit_op2
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
name|ADJUST_LOCAL_OFFSET
argument_list|(
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|ADJUST_LOCAL_OFFSET
argument_list|(
name|src1
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
name|ADJUST_LOCAL_OFFSET
argument_list|(
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_MIPS_64
operator|&&
name|SLJIT_CONFIG_MIPS_64
operator|)
if|if
condition|(
name|op
operator|&
name|SLJIT_INT_OP
condition|)
block|{
name|flags
operator||=
name|INT_DATA
operator||
name|SIGNED_DATA
expr_stmt|;
if|if
condition|(
name|src1
operator|&
name|SLJIT_IMM
condition|)
name|src1w
operator|=
operator|(
name|sljit_si
operator|)
name|src1w
expr_stmt|;
if|if
condition|(
name|src2
operator|&
name|SLJIT_IMM
condition|)
name|src2w
operator|=
operator|(
name|sljit_si
operator|)
name|src2w
expr_stmt|;
block|}
endif|#
directive|endif
switch|switch
condition|(
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|SLJIT_ADD
case|:
case|case
name|SLJIT_ADDC
case|:
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|flags
operator||
name|CUMULATIVE_OP
operator||
name|IMM_OP
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
return|;
case|case
name|SLJIT_SUB
case|:
case|case
name|SLJIT_SUBC
case|:
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|flags
operator||
name|IMM_OP
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
return|;
case|case
name|SLJIT_MUL
case|:
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|flags
operator||
name|CUMULATIVE_OP
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
return|;
case|case
name|SLJIT_AND
case|:
case|case
name|SLJIT_OR
case|:
case|case
name|SLJIT_XOR
case|:
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|flags
operator||
name|CUMULATIVE_OP
operator||
name|LOGICAL_OP
operator||
name|IMM_OP
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
return|;
case|case
name|SLJIT_SHL
case|:
case|case
name|SLJIT_LSHR
case|:
case|case
name|SLJIT_ASHR
case|:
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_MIPS_32
operator|&&
name|SLJIT_CONFIG_MIPS_32
operator|)
if|if
condition|(
name|src2
operator|&
name|SLJIT_IMM
condition|)
name|src2w
operator|&=
literal|0x1f
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|src2
operator|&
name|SLJIT_IMM
condition|)
block|{
if|if
condition|(
name|op
operator|&
name|SLJIT_INT_OP
condition|)
name|src2w
operator|&=
literal|0x1f
expr_stmt|;
else|else
name|src2w
operator|&=
literal|0x3f
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|flags
operator||
name|IMM_OP
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
return|;
block|}
return|return
name|SLJIT_SUCCESS
return|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_MIPS_32
operator|&&
name|SLJIT_CONFIG_MIPS_32
operator|)
DECL|macro|flags
undef|#
directive|undef
name|flags
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|sljit_get_register_index
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_get_register_index
parameter_list|(
name|sljit_si
name|reg
parameter_list|)
block|{
name|check_sljit_get_register_index
argument_list|(
name|reg
argument_list|)
expr_stmt|;
return|return
name|reg_map
index|[
name|reg
index|]
return|;
block|}
end_function
begin_function
DECL|function|sljit_get_float_register_index
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_get_float_register_index
parameter_list|(
name|sljit_si
name|reg
parameter_list|)
block|{
name|check_sljit_get_float_register_index
argument_list|(
name|reg
argument_list|)
expr_stmt|;
return|return
name|reg
operator|<<
literal|1
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_op_custom
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_op_custom
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|void
modifier|*
name|instruction
parameter_list|,
name|sljit_si
name|size
parameter_list|)
block|{
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|check_sljit_emit_op_custom
argument_list|(
name|compiler
argument_list|,
name|instruction
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|size
operator|==
literal|4
argument_list|)
expr_stmt|;
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
operator|*
operator|(
name|sljit_ins
operator|*
operator|)
name|instruction
argument_list|,
name|UNMOVABLE_INS
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_comment
comment|/*  Floating point operators                                             */
end_comment
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_function
DECL|function|sljit_is_fpu_available
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_is_fpu_available
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SLJIT_IS_FPU_AVAILABLE
return|return
name|SLJIT_IS_FPU_AVAILABLE
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|__GNUC__
argument_list|)
name|sljit_sw
name|fir
decl_stmt|;
asm|asm ("cfc1 %0, $0" : "=r"(fir));
return|return
operator|(
name|fir
operator|>>
literal|22
operator|)
operator|&
literal|0x1
return|;
else|#
directive|else
error|#
directive|error
literal|"FIR check is not implemented for this architecture"
endif|#
directive|endif
block|}
end_function
begin_define
DECL|macro|FLOAT_DATA
define|#
directive|define
name|FLOAT_DATA
parameter_list|(
name|op
parameter_list|)
value|(DOUBLE_DATA | ((op& SLJIT_SINGLE_OP)>> 7))
end_define
begin_define
DECL|macro|FMT
define|#
directive|define
name|FMT
parameter_list|(
name|op
parameter_list|)
value|(((op& SLJIT_SINGLE_OP) ^ SLJIT_SINGLE_OP)<< (21 - 8))
end_define
begin_function
DECL|function|sljit_emit_fop1
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_fop1
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|)
block|{
name|sljit_si
name|dst_fr
decl_stmt|;
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|check_sljit_emit_fop1
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|SLJIT_COMPILE_ASSERT
argument_list|(
operator|(
name|SLJIT_SINGLE_OP
operator|==
literal|0x100
operator|)
operator|&&
operator|!
operator|(
name|DOUBLE_DATA
operator|&
literal|0x2
operator|)
argument_list|,
name|float_transfer_bit_error
argument_list|)
expr_stmt|;
name|compiler
operator|->
name|cache_arg
operator|=
literal|0
expr_stmt|;
name|compiler
operator|->
name|cache_argw
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
operator|==
name|SLJIT_CMPD
condition|)
block|{
if|if
condition|(
name|dst
operator|&
name|SLJIT_MEM
condition|)
block|{
name|FAIL_IF
argument_list|(
name|emit_op_mem2
argument_list|(
name|compiler
argument_list|,
name|FLOAT_DATA
argument_list|(
name|op
argument_list|)
operator||
name|LOAD_DATA
argument_list|,
name|TMP_FREG1
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
argument_list|)
expr_stmt|;
name|dst
operator|=
name|TMP_FREG1
expr_stmt|;
block|}
else|else
name|dst
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|src
operator|&
name|SLJIT_MEM
condition|)
block|{
name|FAIL_IF
argument_list|(
name|emit_op_mem2
argument_list|(
name|compiler
argument_list|,
name|FLOAT_DATA
argument_list|(
name|op
argument_list|)
operator||
name|LOAD_DATA
argument_list|,
name|TMP_FREG2
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|src
operator|=
name|TMP_FREG2
expr_stmt|;
block|}
else|else
name|src
operator|<<=
literal|1
expr_stmt|;
comment|/* src and dst are swapped. */
if|if
condition|(
name|op
operator|&
name|SLJIT_SET_E
condition|)
block|{
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|C_UEQ_fmt
operator||
name|FMT
argument_list|(
name|op
argument_list|)
operator||
name|FT
argument_list|(
name|src
argument_list|)
operator||
name|FS
argument_list|(
name|dst
argument_list|)
argument_list|,
name|UNMOVABLE_INS
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|CFC1
operator||
name|TA
argument_list|(
name|EQUAL_FLAG
argument_list|)
operator||
name|DA
argument_list|(
name|FCSR_REG
argument_list|)
argument_list|,
name|EQUAL_FLAG
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|SRL
operator||
name|TA
argument_list|(
name|EQUAL_FLAG
argument_list|)
operator||
name|DA
argument_list|(
name|EQUAL_FLAG
argument_list|)
operator||
name|SH_IMM
argument_list|(
literal|23
argument_list|)
argument_list|,
name|EQUAL_FLAG
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|ANDI
operator||
name|SA
argument_list|(
name|EQUAL_FLAG
argument_list|)
operator||
name|TA
argument_list|(
name|EQUAL_FLAG
argument_list|)
operator||
name|IMM
argument_list|(
literal|1
argument_list|)
argument_list|,
name|EQUAL_FLAG
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|op
operator|&
name|SLJIT_SET_S
condition|)
block|{
comment|/* Mixing the instructions for the two checks. */
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|C_ULT_fmt
operator||
name|FMT
argument_list|(
name|op
argument_list|)
operator||
name|FT
argument_list|(
name|src
argument_list|)
operator||
name|FS
argument_list|(
name|dst
argument_list|)
argument_list|,
name|UNMOVABLE_INS
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|CFC1
operator||
name|TA
argument_list|(
name|ULESS_FLAG
argument_list|)
operator||
name|DA
argument_list|(
name|FCSR_REG
argument_list|)
argument_list|,
name|ULESS_FLAG
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|C_ULT_fmt
operator||
name|FMT
argument_list|(
name|op
argument_list|)
operator||
name|FT
argument_list|(
name|dst
argument_list|)
operator||
name|FS
argument_list|(
name|src
argument_list|)
argument_list|,
name|UNMOVABLE_INS
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|SRL
operator||
name|TA
argument_list|(
name|ULESS_FLAG
argument_list|)
operator||
name|DA
argument_list|(
name|ULESS_FLAG
argument_list|)
operator||
name|SH_IMM
argument_list|(
literal|23
argument_list|)
argument_list|,
name|ULESS_FLAG
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|ANDI
operator||
name|SA
argument_list|(
name|ULESS_FLAG
argument_list|)
operator||
name|TA
argument_list|(
name|ULESS_FLAG
argument_list|)
operator||
name|IMM
argument_list|(
literal|1
argument_list|)
argument_list|,
name|ULESS_FLAG
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|CFC1
operator||
name|TA
argument_list|(
name|UGREATER_FLAG
argument_list|)
operator||
name|DA
argument_list|(
name|FCSR_REG
argument_list|)
argument_list|,
name|UGREATER_FLAG
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|SRL
operator||
name|TA
argument_list|(
name|UGREATER_FLAG
argument_list|)
operator||
name|DA
argument_list|(
name|UGREATER_FLAG
argument_list|)
operator||
name|SH_IMM
argument_list|(
literal|23
argument_list|)
argument_list|,
name|UGREATER_FLAG
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|ANDI
operator||
name|SA
argument_list|(
name|UGREATER_FLAG
argument_list|)
operator||
name|TA
argument_list|(
name|UGREATER_FLAG
argument_list|)
operator||
name|IMM
argument_list|(
literal|1
argument_list|)
argument_list|,
name|UGREATER_FLAG
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|C_UN_fmt
operator||
name|FMT
argument_list|(
name|op
argument_list|)
operator||
name|FT
argument_list|(
name|src
argument_list|)
operator||
name|FS
argument_list|(
name|dst
argument_list|)
argument_list|,
name|FCSR_FCC
argument_list|)
return|;
block|}
name|dst_fr
operator|=
name|FAST_IS_REG
argument_list|(
name|dst
argument_list|)
condition|?
operator|(
name|dst
operator|<<
literal|1
operator|)
else|:
name|TMP_FREG1
expr_stmt|;
if|if
condition|(
name|src
operator|&
name|SLJIT_MEM
condition|)
block|{
name|FAIL_IF
argument_list|(
name|emit_op_mem2
argument_list|(
name|compiler
argument_list|,
name|FLOAT_DATA
argument_list|(
name|op
argument_list|)
operator||
name|LOAD_DATA
argument_list|,
name|dst_fr
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
argument_list|)
expr_stmt|;
name|src
operator|=
name|dst_fr
expr_stmt|;
block|}
else|else
name|src
operator|<<=
literal|1
expr_stmt|;
switch|switch
condition|(
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|SLJIT_MOVD
case|:
if|if
condition|(
name|src
operator|!=
name|dst_fr
operator|&&
name|dst_fr
operator|!=
name|TMP_FREG1
condition|)
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|MOV_fmt
operator||
name|FMT
argument_list|(
name|op
argument_list|)
operator||
name|FS
argument_list|(
name|src
argument_list|)
operator||
name|FD
argument_list|(
name|dst_fr
argument_list|)
argument_list|,
name|MOVABLE_INS
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_NEGD
case|:
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|NEG_fmt
operator||
name|FMT
argument_list|(
name|op
argument_list|)
operator||
name|FS
argument_list|(
name|src
argument_list|)
operator||
name|FD
argument_list|(
name|dst_fr
argument_list|)
argument_list|,
name|MOVABLE_INS
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_ABSD
case|:
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|ABS_fmt
operator||
name|FMT
argument_list|(
name|op
argument_list|)
operator||
name|FS
argument_list|(
name|src
argument_list|)
operator||
name|FD
argument_list|(
name|dst_fr
argument_list|)
argument_list|,
name|MOVABLE_INS
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|dst_fr
operator|==
name|TMP_FREG1
condition|)
block|{
if|if
condition|(
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
operator|==
name|SLJIT_MOVD
condition|)
name|dst_fr
operator|=
name|src
expr_stmt|;
name|FAIL_IF
argument_list|(
name|emit_op_mem2
argument_list|(
name|compiler
argument_list|,
name|FLOAT_DATA
argument_list|(
name|op
argument_list|)
argument_list|,
name|dst_fr
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_fop2
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_fop2
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src1
parameter_list|,
name|sljit_sw
name|src1w
parameter_list|,
name|sljit_si
name|src2
parameter_list|,
name|sljit_sw
name|src2w
parameter_list|)
block|{
name|sljit_si
name|dst_fr
decl_stmt|,
name|flags
init|=
literal|0
decl_stmt|;
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|check_sljit_emit_fop2
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
name|compiler
operator|->
name|cache_arg
operator|=
literal|0
expr_stmt|;
name|compiler
operator|->
name|cache_argw
operator|=
literal|0
expr_stmt|;
name|dst_fr
operator|=
name|FAST_IS_REG
argument_list|(
name|dst
argument_list|)
condition|?
operator|(
name|dst
operator|<<
literal|1
operator|)
else|:
name|TMP_FREG2
expr_stmt|;
if|if
condition|(
name|src1
operator|&
name|SLJIT_MEM
condition|)
block|{
if|if
condition|(
name|getput_arg_fast
argument_list|(
name|compiler
argument_list|,
name|FLOAT_DATA
argument_list|(
name|op
argument_list|)
operator||
name|LOAD_DATA
argument_list|,
name|TMP_FREG1
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
condition|)
block|{
name|FAIL_IF
argument_list|(
name|compiler
operator|->
name|error
argument_list|)
expr_stmt|;
name|src1
operator|=
name|TMP_FREG1
expr_stmt|;
block|}
else|else
name|flags
operator||=
name|SLOW_SRC1
expr_stmt|;
block|}
else|else
name|src1
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|src2
operator|&
name|SLJIT_MEM
condition|)
block|{
if|if
condition|(
name|getput_arg_fast
argument_list|(
name|compiler
argument_list|,
name|FLOAT_DATA
argument_list|(
name|op
argument_list|)
operator||
name|LOAD_DATA
argument_list|,
name|TMP_FREG2
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
condition|)
block|{
name|FAIL_IF
argument_list|(
name|compiler
operator|->
name|error
argument_list|)
expr_stmt|;
name|src2
operator|=
name|TMP_FREG2
expr_stmt|;
block|}
else|else
name|flags
operator||=
name|SLOW_SRC2
expr_stmt|;
block|}
else|else
name|src2
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|SLOW_SRC1
operator||
name|SLOW_SRC2
operator|)
operator|)
operator|==
operator|(
name|SLOW_SRC1
operator||
name|SLOW_SRC2
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|can_cache
argument_list|(
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
operator|&&
name|can_cache
argument_list|(
name|src1
argument_list|,
name|src1w
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
condition|)
block|{
name|FAIL_IF
argument_list|(
name|getput_arg
argument_list|(
name|compiler
argument_list|,
name|FLOAT_DATA
argument_list|(
name|op
argument_list|)
operator||
name|LOAD_DATA
argument_list|,
name|TMP_FREG2
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|getput_arg
argument_list|(
name|compiler
argument_list|,
name|FLOAT_DATA
argument_list|(
name|op
argument_list|)
operator||
name|LOAD_DATA
argument_list|,
name|TMP_FREG1
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|FAIL_IF
argument_list|(
name|getput_arg
argument_list|(
name|compiler
argument_list|,
name|FLOAT_DATA
argument_list|(
name|op
argument_list|)
operator||
name|LOAD_DATA
argument_list|,
name|TMP_FREG1
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|getput_arg
argument_list|(
name|compiler
argument_list|,
name|FLOAT_DATA
argument_list|(
name|op
argument_list|)
operator||
name|LOAD_DATA
argument_list|,
name|TMP_FREG2
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|SLOW_SRC1
condition|)
name|FAIL_IF
argument_list|(
name|getput_arg
argument_list|(
name|compiler
argument_list|,
name|FLOAT_DATA
argument_list|(
name|op
argument_list|)
operator||
name|LOAD_DATA
argument_list|,
name|TMP_FREG1
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|SLOW_SRC2
condition|)
name|FAIL_IF
argument_list|(
name|getput_arg
argument_list|(
name|compiler
argument_list|,
name|FLOAT_DATA
argument_list|(
name|op
argument_list|)
operator||
name|LOAD_DATA
argument_list|,
name|TMP_FREG2
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SLOW_SRC1
condition|)
name|src1
operator|=
name|TMP_FREG1
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SLOW_SRC2
condition|)
name|src2
operator|=
name|TMP_FREG2
expr_stmt|;
switch|switch
condition|(
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|SLJIT_ADDD
case|:
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|ADD_fmt
operator||
name|FMT
argument_list|(
name|op
argument_list|)
operator||
name|FT
argument_list|(
name|src2
argument_list|)
operator||
name|FS
argument_list|(
name|src1
argument_list|)
operator||
name|FD
argument_list|(
name|dst_fr
argument_list|)
argument_list|,
name|MOVABLE_INS
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_SUBD
case|:
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|SUB_fmt
operator||
name|FMT
argument_list|(
name|op
argument_list|)
operator||
name|FT
argument_list|(
name|src2
argument_list|)
operator||
name|FS
argument_list|(
name|src1
argument_list|)
operator||
name|FD
argument_list|(
name|dst_fr
argument_list|)
argument_list|,
name|MOVABLE_INS
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_MULD
case|:
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|MUL_fmt
operator||
name|FMT
argument_list|(
name|op
argument_list|)
operator||
name|FT
argument_list|(
name|src2
argument_list|)
operator||
name|FS
argument_list|(
name|src1
argument_list|)
operator||
name|FD
argument_list|(
name|dst_fr
argument_list|)
argument_list|,
name|MOVABLE_INS
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_DIVD
case|:
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|DIV_fmt
operator||
name|FMT
argument_list|(
name|op
argument_list|)
operator||
name|FT
argument_list|(
name|src2
argument_list|)
operator||
name|FS
argument_list|(
name|src1
argument_list|)
operator||
name|FD
argument_list|(
name|dst_fr
argument_list|)
argument_list|,
name|MOVABLE_INS
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|dst_fr
operator|==
name|TMP_FREG2
condition|)
name|FAIL_IF
argument_list|(
name|emit_op_mem2
argument_list|(
name|compiler
argument_list|,
name|FLOAT_DATA
argument_list|(
name|op
argument_list|)
argument_list|,
name|TMP_FREG2
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_comment
comment|/*  Other instructions                                                   */
end_comment
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_function
DECL|function|sljit_emit_fast_enter
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_fast_enter
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|)
block|{
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|check_sljit_emit_fast_enter
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|ADJUST_LOCAL_OFFSET
argument_list|(
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
comment|/* For UNUSED dst. Uncommon, but possible. */
if|if
condition|(
name|dst
operator|==
name|SLJIT_UNUSED
condition|)
return|return
name|SLJIT_SUCCESS
return|;
if|if
condition|(
name|FAST_IS_REG
argument_list|(
name|dst
argument_list|)
condition|)
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|ADDU_W
operator||
name|SA
argument_list|(
name|RETURN_ADDR_REG
argument_list|)
operator||
name|TA
argument_list|(
literal|0
argument_list|)
operator||
name|D
argument_list|(
name|dst
argument_list|)
argument_list|,
name|DR
argument_list|(
name|dst
argument_list|)
argument_list|)
return|;
comment|/* Memory. */
return|return
name|emit_op_mem
argument_list|(
name|compiler
argument_list|,
name|WORD_DATA
argument_list|,
name|RETURN_ADDR_REG
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_fast_return
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_fast_return
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|)
block|{
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|check_sljit_emit_fast_return
argument_list|(
name|compiler
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|ADJUST_LOCAL_OFFSET
argument_list|(
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
if|if
condition|(
name|FAST_IS_REG
argument_list|(
name|src
argument_list|)
condition|)
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|ADDU_W
operator||
name|S
argument_list|(
name|src
argument_list|)
operator||
name|TA
argument_list|(
literal|0
argument_list|)
operator||
name|DA
argument_list|(
name|RETURN_ADDR_REG
argument_list|)
argument_list|,
name|RETURN_ADDR_REG
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|src
operator|&
name|SLJIT_MEM
condition|)
name|FAIL_IF
argument_list|(
name|emit_op_mem
argument_list|(
name|compiler
argument_list|,
name|WORD_DATA
operator||
name|LOAD_DATA
argument_list|,
name|RETURN_ADDR_REG
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|src
operator|&
name|SLJIT_IMM
condition|)
name|FAIL_IF
argument_list|(
name|load_immediate
argument_list|(
name|compiler
argument_list|,
name|RETURN_ADDR_REG
argument_list|,
name|srcw
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|JR
operator||
name|SA
argument_list|(
name|RETURN_ADDR_REG
argument_list|)
argument_list|,
name|UNMOVABLE_INS
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|NOP
argument_list|,
name|UNMOVABLE_INS
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_comment
comment|/*  Conditional instructions                                             */
end_comment
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_function
DECL|function|sljit_emit_label
name|SLJIT_API_FUNC_ATTRIBUTE
name|struct
name|sljit_label
modifier|*
name|sljit_emit_label
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|)
block|{
name|struct
name|sljit_label
modifier|*
name|label
decl_stmt|;
name|CHECK_ERROR_PTR
argument_list|()
expr_stmt|;
name|check_sljit_emit_label
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
if|if
condition|(
name|compiler
operator|->
name|last_label
operator|&&
name|compiler
operator|->
name|last_label
operator|->
name|size
operator|==
name|compiler
operator|->
name|size
condition|)
return|return
name|compiler
operator|->
name|last_label
return|;
name|label
operator|=
operator|(
expr|struct
name|sljit_label
operator|*
operator|)
name|ensure_abuf
argument_list|(
name|compiler
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sljit_label
argument_list|)
argument_list|)
expr_stmt|;
name|PTR_FAIL_IF
argument_list|(
operator|!
name|label
argument_list|)
expr_stmt|;
name|set_label
argument_list|(
name|label
argument_list|,
name|compiler
argument_list|)
expr_stmt|;
name|compiler
operator|->
name|delay_slot
operator|=
name|UNMOVABLE_INS
expr_stmt|;
return|return
name|label
return|;
block|}
end_function
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_MIPS_32
operator|&&
name|SLJIT_CONFIG_MIPS_32
operator|)
end_if
begin_define
DECL|macro|JUMP_LENGTH
define|#
directive|define
name|JUMP_LENGTH
value|4
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|JUMP_LENGTH
define|#
directive|define
name|JUMP_LENGTH
value|8
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|BR_Z
define|#
directive|define
name|BR_Z
parameter_list|(
name|src
parameter_list|)
define|\
value|inst = BEQ | SA(src) | TA(0) | JUMP_LENGTH; \ 	flags = IS_BIT26_COND; \ 	delay_check = src;
end_define
begin_define
DECL|macro|BR_NZ
define|#
directive|define
name|BR_NZ
parameter_list|(
name|src
parameter_list|)
define|\
value|inst = BNE | SA(src) | TA(0) | JUMP_LENGTH; \ 	flags = IS_BIT26_COND; \ 	delay_check = src;
end_define
begin_define
DECL|macro|BR_T
define|#
directive|define
name|BR_T
parameter_list|()
define|\
value|inst = BC1T | JUMP_LENGTH; \ 	flags = IS_BIT16_COND; \ 	delay_check = FCSR_FCC;
end_define
begin_define
DECL|macro|BR_F
define|#
directive|define
name|BR_F
parameter_list|()
define|\
value|inst = BC1F | JUMP_LENGTH; \ 	flags = IS_BIT16_COND; \ 	delay_check = FCSR_FCC;
end_define
begin_function
DECL|function|sljit_emit_jump
name|SLJIT_API_FUNC_ATTRIBUTE
name|struct
name|sljit_jump
modifier|*
name|sljit_emit_jump
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|type
parameter_list|)
block|{
name|struct
name|sljit_jump
modifier|*
name|jump
decl_stmt|;
name|sljit_ins
name|inst
decl_stmt|;
name|sljit_si
name|flags
init|=
literal|0
decl_stmt|;
name|sljit_si
name|delay_check
init|=
name|UNMOVABLE_INS
decl_stmt|;
name|CHECK_ERROR_PTR
argument_list|()
expr_stmt|;
name|check_sljit_emit_jump
argument_list|(
name|compiler
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|jump
operator|=
operator|(
expr|struct
name|sljit_jump
operator|*
operator|)
name|ensure_abuf
argument_list|(
name|compiler
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sljit_jump
argument_list|)
argument_list|)
expr_stmt|;
name|PTR_FAIL_IF
argument_list|(
operator|!
name|jump
argument_list|)
expr_stmt|;
name|set_jump
argument_list|(
name|jump
argument_list|,
name|compiler
argument_list|,
name|type
operator|&
name|SLJIT_REWRITABLE_JUMP
argument_list|)
expr_stmt|;
name|type
operator|&=
literal|0xff
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SLJIT_C_EQUAL
case|:
case|case
name|SLJIT_C_FLOAT_NOT_EQUAL
case|:
name|BR_NZ
argument_list|(
name|EQUAL_FLAG
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_C_NOT_EQUAL
case|:
case|case
name|SLJIT_C_FLOAT_EQUAL
case|:
name|BR_Z
argument_list|(
name|EQUAL_FLAG
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_C_LESS
case|:
case|case
name|SLJIT_C_FLOAT_LESS
case|:
name|BR_Z
argument_list|(
name|ULESS_FLAG
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_C_GREATER_EQUAL
case|:
case|case
name|SLJIT_C_FLOAT_GREATER_EQUAL
case|:
name|BR_NZ
argument_list|(
name|ULESS_FLAG
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_C_GREATER
case|:
case|case
name|SLJIT_C_FLOAT_GREATER
case|:
name|BR_Z
argument_list|(
name|UGREATER_FLAG
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_C_LESS_EQUAL
case|:
case|case
name|SLJIT_C_FLOAT_LESS_EQUAL
case|:
name|BR_NZ
argument_list|(
name|UGREATER_FLAG
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_C_SIG_LESS
case|:
name|BR_Z
argument_list|(
name|LESS_FLAG
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_C_SIG_GREATER_EQUAL
case|:
name|BR_NZ
argument_list|(
name|LESS_FLAG
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_C_SIG_GREATER
case|:
name|BR_Z
argument_list|(
name|GREATER_FLAG
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_C_SIG_LESS_EQUAL
case|:
name|BR_NZ
argument_list|(
name|GREATER_FLAG
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_C_OVERFLOW
case|:
case|case
name|SLJIT_C_MUL_OVERFLOW
case|:
name|BR_Z
argument_list|(
name|OVERFLOW_FLAG
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_C_NOT_OVERFLOW
case|:
case|case
name|SLJIT_C_MUL_NOT_OVERFLOW
case|:
name|BR_NZ
argument_list|(
name|OVERFLOW_FLAG
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_C_FLOAT_UNORDERED
case|:
name|BR_F
argument_list|()
expr_stmt|;
break|break;
case|case
name|SLJIT_C_FLOAT_ORDERED
case|:
name|BR_T
argument_list|()
expr_stmt|;
break|break;
default|default:
comment|/* Not conditional branch. */
name|inst
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|jump
operator|->
name|flags
operator||=
name|flags
expr_stmt|;
if|if
condition|(
name|compiler
operator|->
name|delay_slot
operator|==
name|MOVABLE_INS
operator|||
operator|(
name|compiler
operator|->
name|delay_slot
operator|!=
name|UNMOVABLE_INS
operator|&&
name|compiler
operator|->
name|delay_slot
operator|!=
name|delay_check
operator|)
condition|)
name|jump
operator|->
name|flags
operator||=
name|IS_MOVABLE
expr_stmt|;
if|if
condition|(
name|inst
condition|)
name|PTR_FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|inst
argument_list|,
name|UNMOVABLE_INS
argument_list|)
argument_list|)
expr_stmt|;
name|PTR_FAIL_IF
argument_list|(
name|emit_const
argument_list|(
name|compiler
argument_list|,
name|TMP_REG2
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|<=
name|SLJIT_JUMP
condition|)
block|{
name|PTR_FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|JR
operator||
name|S
argument_list|(
name|TMP_REG2
argument_list|)
argument_list|,
name|UNMOVABLE_INS
argument_list|)
argument_list|)
expr_stmt|;
name|jump
operator|->
name|addr
operator|=
name|compiler
operator|->
name|size
expr_stmt|;
name|PTR_FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|NOP
argument_list|,
name|UNMOVABLE_INS
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SLJIT_ASSERT
argument_list|(
name|DR
argument_list|(
name|PIC_ADDR_REG
argument_list|)
operator|==
literal|25
operator|&&
name|PIC_ADDR_REG
operator|==
name|TMP_REG2
argument_list|)
expr_stmt|;
comment|/* Cannot be optimized out if type is>= CALL0. */
name|jump
operator|->
name|flags
operator||=
name|IS_JAL
operator||
operator|(
name|type
operator|>=
name|SLJIT_CALL0
condition|?
name|IS_CALL
else|:
literal|0
operator|)
expr_stmt|;
name|PTR_FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|JALR
operator||
name|S
argument_list|(
name|TMP_REG2
argument_list|)
operator||
name|DA
argument_list|(
name|RETURN_ADDR_REG
argument_list|)
argument_list|,
name|UNMOVABLE_INS
argument_list|)
argument_list|)
expr_stmt|;
name|jump
operator|->
name|addr
operator|=
name|compiler
operator|->
name|size
expr_stmt|;
comment|/* A NOP if type< CALL1. */
name|PTR_FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|ADDU_W
operator||
name|S
argument_list|(
name|SLJIT_SCRATCH_REG1
argument_list|)
operator||
name|TA
argument_list|(
literal|0
argument_list|)
operator||
name|DA
argument_list|(
literal|4
argument_list|)
argument_list|,
name|UNMOVABLE_INS
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|jump
return|;
block|}
end_function
begin_define
DECL|macro|RESOLVE_IMM1
define|#
directive|define
name|RESOLVE_IMM1
parameter_list|()
define|\
value|if (src1& SLJIT_IMM) { \ 		if (src1w) { \ 			PTR_FAIL_IF(load_immediate(compiler, DR(TMP_REG1), src1w)); \ 			src1 = TMP_REG1; \ 		} \ 		else \ 			src1 = 0; \ 	}
end_define
begin_define
DECL|macro|RESOLVE_IMM2
define|#
directive|define
name|RESOLVE_IMM2
parameter_list|()
define|\
value|if (src2& SLJIT_IMM) { \ 		if (src2w) { \ 			PTR_FAIL_IF(load_immediate(compiler, DR(TMP_REG2), src2w)); \ 			src2 = TMP_REG2; \ 		} \ 		else \ 			src2 = 0; \ 	}
end_define
begin_function
DECL|function|sljit_emit_cmp
name|SLJIT_API_FUNC_ATTRIBUTE
name|struct
name|sljit_jump
modifier|*
name|sljit_emit_cmp
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|type
parameter_list|,
name|sljit_si
name|src1
parameter_list|,
name|sljit_sw
name|src1w
parameter_list|,
name|sljit_si
name|src2
parameter_list|,
name|sljit_sw
name|src2w
parameter_list|)
block|{
name|struct
name|sljit_jump
modifier|*
name|jump
decl_stmt|;
name|sljit_si
name|flags
decl_stmt|;
name|sljit_ins
name|inst
decl_stmt|;
name|CHECK_ERROR_PTR
argument_list|()
expr_stmt|;
name|check_sljit_emit_cmp
argument_list|(
name|compiler
argument_list|,
name|type
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
name|ADJUST_LOCAL_OFFSET
argument_list|(
name|src1
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
name|ADJUST_LOCAL_OFFSET
argument_list|(
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
name|compiler
operator|->
name|cache_arg
operator|=
literal|0
expr_stmt|;
name|compiler
operator|->
name|cache_argw
operator|=
literal|0
expr_stmt|;
name|flags
operator|=
operator|(
operator|(
name|type
operator|&
name|SLJIT_INT_OP
operator|)
condition|?
name|INT_DATA
else|:
name|WORD_DATA
operator|)
operator||
name|LOAD_DATA
expr_stmt|;
if|if
condition|(
name|src1
operator|&
name|SLJIT_MEM
condition|)
block|{
name|PTR_FAIL_IF
argument_list|(
name|emit_op_mem2
argument_list|(
name|compiler
argument_list|,
name|flags
argument_list|,
name|DR
argument_list|(
name|TMP_REG1
argument_list|)
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
argument_list|)
expr_stmt|;
name|src1
operator|=
name|TMP_REG1
expr_stmt|;
block|}
if|if
condition|(
name|src2
operator|&
name|SLJIT_MEM
condition|)
block|{
name|PTR_FAIL_IF
argument_list|(
name|emit_op_mem2
argument_list|(
name|compiler
argument_list|,
name|flags
argument_list|,
name|DR
argument_list|(
name|TMP_REG2
argument_list|)
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|src2
operator|=
name|TMP_REG2
expr_stmt|;
block|}
name|jump
operator|=
operator|(
expr|struct
name|sljit_jump
operator|*
operator|)
name|ensure_abuf
argument_list|(
name|compiler
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sljit_jump
argument_list|)
argument_list|)
expr_stmt|;
name|PTR_FAIL_IF
argument_list|(
operator|!
name|jump
argument_list|)
expr_stmt|;
name|set_jump
argument_list|(
name|jump
argument_list|,
name|compiler
argument_list|,
name|type
operator|&
name|SLJIT_REWRITABLE_JUMP
argument_list|)
expr_stmt|;
name|type
operator|&=
literal|0xff
expr_stmt|;
if|if
condition|(
name|type
operator|<=
name|SLJIT_C_NOT_EQUAL
condition|)
block|{
name|RESOLVE_IMM1
argument_list|()
expr_stmt|;
name|RESOLVE_IMM2
argument_list|()
expr_stmt|;
name|jump
operator|->
name|flags
operator||=
name|IS_BIT26_COND
expr_stmt|;
if|if
condition|(
name|compiler
operator|->
name|delay_slot
operator|==
name|MOVABLE_INS
operator|||
operator|(
name|compiler
operator|->
name|delay_slot
operator|!=
name|UNMOVABLE_INS
operator|&&
name|compiler
operator|->
name|delay_slot
operator|!=
name|DR
argument_list|(
name|src1
argument_list|)
operator|&&
name|compiler
operator|->
name|delay_slot
operator|!=
name|DR
argument_list|(
name|src2
argument_list|)
operator|)
condition|)
name|jump
operator|->
name|flags
operator||=
name|IS_MOVABLE
expr_stmt|;
name|PTR_FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
operator|(
name|type
operator|==
name|SLJIT_C_EQUAL
condition|?
name|BNE
else|:
name|BEQ
operator|)
operator||
name|S
argument_list|(
name|src1
argument_list|)
operator||
name|T
argument_list|(
name|src2
argument_list|)
operator||
name|JUMP_LENGTH
argument_list|,
name|UNMOVABLE_INS
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|>=
name|SLJIT_C_SIG_LESS
operator|&&
operator|(
operator|(
operator|(
name|src1
operator|&
name|SLJIT_IMM
operator|)
operator|&&
operator|(
name|src1w
operator|==
literal|0
operator|)
operator|)
operator|||
operator|(
operator|(
name|src2
operator|&
name|SLJIT_IMM
operator|)
operator|&&
operator|(
name|src2w
operator|==
literal|0
operator|)
operator|)
operator|)
condition|)
block|{
name|inst
operator|=
name|NOP
expr_stmt|;
if|if
condition|(
operator|(
name|src1
operator|&
name|SLJIT_IMM
operator|)
operator|&&
operator|(
name|src1w
operator|==
literal|0
operator|)
condition|)
block|{
name|RESOLVE_IMM2
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SLJIT_C_SIG_LESS
case|:
name|inst
operator|=
name|BLEZ
expr_stmt|;
name|jump
operator|->
name|flags
operator||=
name|IS_BIT26_COND
expr_stmt|;
break|break;
case|case
name|SLJIT_C_SIG_GREATER_EQUAL
case|:
name|inst
operator|=
name|BGTZ
expr_stmt|;
name|jump
operator|->
name|flags
operator||=
name|IS_BIT26_COND
expr_stmt|;
break|break;
case|case
name|SLJIT_C_SIG_GREATER
case|:
name|inst
operator|=
name|BGEZ
expr_stmt|;
name|jump
operator|->
name|flags
operator||=
name|IS_BIT16_COND
expr_stmt|;
break|break;
case|case
name|SLJIT_C_SIG_LESS_EQUAL
case|:
name|inst
operator|=
name|BLTZ
expr_stmt|;
name|jump
operator|->
name|flags
operator||=
name|IS_BIT16_COND
expr_stmt|;
break|break;
block|}
name|src1
operator|=
name|src2
expr_stmt|;
block|}
else|else
block|{
name|RESOLVE_IMM1
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SLJIT_C_SIG_LESS
case|:
name|inst
operator|=
name|BGEZ
expr_stmt|;
name|jump
operator|->
name|flags
operator||=
name|IS_BIT16_COND
expr_stmt|;
break|break;
case|case
name|SLJIT_C_SIG_GREATER_EQUAL
case|:
name|inst
operator|=
name|BLTZ
expr_stmt|;
name|jump
operator|->
name|flags
operator||=
name|IS_BIT16_COND
expr_stmt|;
break|break;
case|case
name|SLJIT_C_SIG_GREATER
case|:
name|inst
operator|=
name|BLEZ
expr_stmt|;
name|jump
operator|->
name|flags
operator||=
name|IS_BIT26_COND
expr_stmt|;
break|break;
case|case
name|SLJIT_C_SIG_LESS_EQUAL
case|:
name|inst
operator|=
name|BGTZ
expr_stmt|;
name|jump
operator|->
name|flags
operator||=
name|IS_BIT26_COND
expr_stmt|;
break|break;
block|}
block|}
name|PTR_FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|inst
operator||
name|S
argument_list|(
name|src1
argument_list|)
operator||
name|JUMP_LENGTH
argument_list|,
name|UNMOVABLE_INS
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|type
operator|==
name|SLJIT_C_LESS
operator|||
name|type
operator|==
name|SLJIT_C_GREATER_EQUAL
operator|||
name|type
operator|==
name|SLJIT_C_SIG_LESS
operator|||
name|type
operator|==
name|SLJIT_C_SIG_GREATER_EQUAL
condition|)
block|{
name|RESOLVE_IMM1
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|src2
operator|&
name|SLJIT_IMM
operator|)
operator|&&
name|src2w
operator|<=
name|SIMM_MAX
operator|&&
name|src2w
operator|>=
name|SIMM_MIN
condition|)
name|PTR_FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
operator|(
name|type
operator|<=
name|SLJIT_C_LESS_EQUAL
condition|?
name|SLTIU
else|:
name|SLTI
operator|)
operator||
name|S
argument_list|(
name|src1
argument_list|)
operator||
name|T
argument_list|(
name|TMP_REG1
argument_list|)
operator||
name|IMM
argument_list|(
name|src2w
argument_list|)
argument_list|,
name|DR
argument_list|(
name|TMP_REG1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|RESOLVE_IMM2
argument_list|()
expr_stmt|;
name|PTR_FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
operator|(
name|type
operator|<=
name|SLJIT_C_LESS_EQUAL
condition|?
name|SLTU
else|:
name|SLT
operator|)
operator||
name|S
argument_list|(
name|src1
argument_list|)
operator||
name|T
argument_list|(
name|src2
argument_list|)
operator||
name|D
argument_list|(
name|TMP_REG1
argument_list|)
argument_list|,
name|DR
argument_list|(
name|TMP_REG1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|type
operator|=
operator|(
name|type
operator|==
name|SLJIT_C_LESS
operator|||
name|type
operator|==
name|SLJIT_C_SIG_LESS
operator|)
condition|?
name|SLJIT_C_NOT_EQUAL
else|:
name|SLJIT_C_EQUAL
expr_stmt|;
block|}
else|else
block|{
name|RESOLVE_IMM2
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|src1
operator|&
name|SLJIT_IMM
operator|)
operator|&&
name|src1w
operator|<=
name|SIMM_MAX
operator|&&
name|src1w
operator|>=
name|SIMM_MIN
condition|)
name|PTR_FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
operator|(
name|type
operator|<=
name|SLJIT_C_LESS_EQUAL
condition|?
name|SLTIU
else|:
name|SLTI
operator|)
operator||
name|S
argument_list|(
name|src2
argument_list|)
operator||
name|T
argument_list|(
name|TMP_REG1
argument_list|)
operator||
name|IMM
argument_list|(
name|src1w
argument_list|)
argument_list|,
name|DR
argument_list|(
name|TMP_REG1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|RESOLVE_IMM1
argument_list|()
expr_stmt|;
name|PTR_FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
operator|(
name|type
operator|<=
name|SLJIT_C_LESS_EQUAL
condition|?
name|SLTU
else|:
name|SLT
operator|)
operator||
name|S
argument_list|(
name|src2
argument_list|)
operator||
name|T
argument_list|(
name|src1
argument_list|)
operator||
name|D
argument_list|(
name|TMP_REG1
argument_list|)
argument_list|,
name|DR
argument_list|(
name|TMP_REG1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|type
operator|=
operator|(
name|type
operator|==
name|SLJIT_C_GREATER
operator|||
name|type
operator|==
name|SLJIT_C_SIG_GREATER
operator|)
condition|?
name|SLJIT_C_NOT_EQUAL
else|:
name|SLJIT_C_EQUAL
expr_stmt|;
block|}
name|jump
operator|->
name|flags
operator||=
name|IS_BIT26_COND
expr_stmt|;
name|PTR_FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
operator|(
name|type
operator|==
name|SLJIT_C_EQUAL
condition|?
name|BNE
else|:
name|BEQ
operator|)
operator||
name|S
argument_list|(
name|TMP_REG1
argument_list|)
operator||
name|TA
argument_list|(
literal|0
argument_list|)
operator||
name|JUMP_LENGTH
argument_list|,
name|UNMOVABLE_INS
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|PTR_FAIL_IF
argument_list|(
name|emit_const
argument_list|(
name|compiler
argument_list|,
name|TMP_REG2
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|PTR_FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|JR
operator||
name|S
argument_list|(
name|TMP_REG2
argument_list|)
argument_list|,
name|UNMOVABLE_INS
argument_list|)
argument_list|)
expr_stmt|;
name|jump
operator|->
name|addr
operator|=
name|compiler
operator|->
name|size
expr_stmt|;
name|PTR_FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|NOP
argument_list|,
name|UNMOVABLE_INS
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|jump
return|;
block|}
end_function
begin_undef
DECL|macro|RESOLVE_IMM1
undef|#
directive|undef
name|RESOLVE_IMM1
end_undef
begin_undef
DECL|macro|RESOLVE_IMM2
undef|#
directive|undef
name|RESOLVE_IMM2
end_undef
begin_function
DECL|function|sljit_emit_fcmp
name|SLJIT_API_FUNC_ATTRIBUTE
name|struct
name|sljit_jump
modifier|*
name|sljit_emit_fcmp
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|type
parameter_list|,
name|sljit_si
name|src1
parameter_list|,
name|sljit_sw
name|src1w
parameter_list|,
name|sljit_si
name|src2
parameter_list|,
name|sljit_sw
name|src2w
parameter_list|)
block|{
name|struct
name|sljit_jump
modifier|*
name|jump
decl_stmt|;
name|sljit_ins
name|inst
decl_stmt|;
name|sljit_si
name|if_true
decl_stmt|;
name|CHECK_ERROR_PTR
argument_list|()
expr_stmt|;
name|check_sljit_emit_fcmp
argument_list|(
name|compiler
argument_list|,
name|type
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
name|compiler
operator|->
name|cache_arg
operator|=
literal|0
expr_stmt|;
name|compiler
operator|->
name|cache_argw
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|src1
operator|&
name|SLJIT_MEM
condition|)
block|{
name|PTR_FAIL_IF
argument_list|(
name|emit_op_mem2
argument_list|(
name|compiler
argument_list|,
name|FLOAT_DATA
argument_list|(
name|type
argument_list|)
operator||
name|LOAD_DATA
argument_list|,
name|TMP_FREG1
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
argument_list|)
expr_stmt|;
name|src1
operator|=
name|TMP_FREG1
expr_stmt|;
block|}
else|else
name|src1
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|src2
operator|&
name|SLJIT_MEM
condition|)
block|{
name|PTR_FAIL_IF
argument_list|(
name|emit_op_mem2
argument_list|(
name|compiler
argument_list|,
name|FLOAT_DATA
argument_list|(
name|type
argument_list|)
operator||
name|LOAD_DATA
argument_list|,
name|TMP_FREG2
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|src2
operator|=
name|TMP_FREG2
expr_stmt|;
block|}
else|else
name|src2
operator|<<=
literal|1
expr_stmt|;
name|jump
operator|=
operator|(
expr|struct
name|sljit_jump
operator|*
operator|)
name|ensure_abuf
argument_list|(
name|compiler
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sljit_jump
argument_list|)
argument_list|)
expr_stmt|;
name|PTR_FAIL_IF
argument_list|(
operator|!
name|jump
argument_list|)
expr_stmt|;
name|set_jump
argument_list|(
name|jump
argument_list|,
name|compiler
argument_list|,
name|type
operator|&
name|SLJIT_REWRITABLE_JUMP
argument_list|)
expr_stmt|;
name|jump
operator|->
name|flags
operator||=
name|IS_BIT16_COND
expr_stmt|;
switch|switch
condition|(
name|type
operator|&
literal|0xff
condition|)
block|{
case|case
name|SLJIT_C_FLOAT_EQUAL
case|:
name|inst
operator|=
name|C_UEQ_fmt
expr_stmt|;
name|if_true
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|SLJIT_C_FLOAT_NOT_EQUAL
case|:
name|inst
operator|=
name|C_UEQ_fmt
expr_stmt|;
name|if_true
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SLJIT_C_FLOAT_LESS
case|:
name|inst
operator|=
name|C_ULT_fmt
expr_stmt|;
name|if_true
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|SLJIT_C_FLOAT_GREATER_EQUAL
case|:
name|inst
operator|=
name|C_ULT_fmt
expr_stmt|;
name|if_true
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SLJIT_C_FLOAT_GREATER
case|:
name|inst
operator|=
name|C_ULE_fmt
expr_stmt|;
name|if_true
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SLJIT_C_FLOAT_LESS_EQUAL
case|:
name|inst
operator|=
name|C_ULE_fmt
expr_stmt|;
name|if_true
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|SLJIT_C_FLOAT_UNORDERED
case|:
name|inst
operator|=
name|C_UN_fmt
expr_stmt|;
name|if_true
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|SLJIT_C_FLOAT_ORDERED
case|:
default|default:
comment|/* Make compilers happy. */
name|inst
operator|=
name|C_UN_fmt
expr_stmt|;
name|if_true
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|PTR_FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|inst
operator||
name|FMT
argument_list|(
name|type
argument_list|)
operator||
name|FT
argument_list|(
name|src2
argument_list|)
operator||
name|FS
argument_list|(
name|src1
argument_list|)
argument_list|,
name|UNMOVABLE_INS
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Intentionally the other opcode. */
name|PTR_FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
operator|(
name|if_true
condition|?
name|BC1F
else|:
name|BC1T
operator|)
operator||
name|JUMP_LENGTH
argument_list|,
name|UNMOVABLE_INS
argument_list|)
argument_list|)
expr_stmt|;
name|PTR_FAIL_IF
argument_list|(
name|emit_const
argument_list|(
name|compiler
argument_list|,
name|TMP_REG2
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|PTR_FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|JR
operator||
name|S
argument_list|(
name|TMP_REG2
argument_list|)
argument_list|,
name|UNMOVABLE_INS
argument_list|)
argument_list|)
expr_stmt|;
name|jump
operator|->
name|addr
operator|=
name|compiler
operator|->
name|size
expr_stmt|;
name|PTR_FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|NOP
argument_list|,
name|UNMOVABLE_INS
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|jump
return|;
block|}
end_function
begin_undef
DECL|macro|JUMP_LENGTH
undef|#
directive|undef
name|JUMP_LENGTH
end_undef
begin_undef
DECL|macro|BR_Z
undef|#
directive|undef
name|BR_Z
end_undef
begin_undef
DECL|macro|BR_NZ
undef|#
directive|undef
name|BR_NZ
end_undef
begin_undef
DECL|macro|BR_T
undef|#
directive|undef
name|BR_T
end_undef
begin_undef
DECL|macro|BR_F
undef|#
directive|undef
name|BR_F
end_undef
begin_undef
DECL|macro|FLOAT_DATA
undef|#
directive|undef
name|FLOAT_DATA
end_undef
begin_undef
DECL|macro|FMT
undef|#
directive|undef
name|FMT
end_undef
begin_function
DECL|function|sljit_emit_ijump
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_ijump
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|type
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|)
block|{
name|sljit_si
name|src_r
init|=
name|TMP_REG2
decl_stmt|;
name|struct
name|sljit_jump
modifier|*
name|jump
init|=
name|NULL
decl_stmt|;
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|check_sljit_emit_ijump
argument_list|(
name|compiler
argument_list|,
name|type
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|ADJUST_LOCAL_OFFSET
argument_list|(
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
if|if
condition|(
name|FAST_IS_REG
argument_list|(
name|src
argument_list|)
condition|)
block|{
if|if
condition|(
name|DR
argument_list|(
name|src
argument_list|)
operator|!=
literal|4
condition|)
name|src_r
operator|=
name|src
expr_stmt|;
else|else
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|ADDU_W
operator||
name|S
argument_list|(
name|src
argument_list|)
operator||
name|TA
argument_list|(
literal|0
argument_list|)
operator||
name|D
argument_list|(
name|TMP_REG2
argument_list|)
argument_list|,
name|DR
argument_list|(
name|TMP_REG2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|>=
name|SLJIT_CALL0
condition|)
block|{
name|SLJIT_ASSERT
argument_list|(
name|DR
argument_list|(
name|PIC_ADDR_REG
argument_list|)
operator|==
literal|25
operator|&&
name|PIC_ADDR_REG
operator|==
name|TMP_REG2
argument_list|)
expr_stmt|;
if|if
condition|(
name|src
operator|&
operator|(
name|SLJIT_IMM
operator||
name|SLJIT_MEM
operator|)
condition|)
block|{
if|if
condition|(
name|src
operator|&
name|SLJIT_IMM
condition|)
name|FAIL_IF
argument_list|(
name|load_immediate
argument_list|(
name|compiler
argument_list|,
name|DR
argument_list|(
name|PIC_ADDR_REG
argument_list|)
argument_list|,
name|srcw
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|SLJIT_ASSERT
argument_list|(
name|src_r
operator|==
name|TMP_REG2
operator|&&
operator|(
name|src
operator|&
name|SLJIT_MEM
operator|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MOV
argument_list|,
name|WORD_DATA
argument_list|,
name|TMP_REG2
argument_list|,
literal|0
argument_list|,
name|TMP_REG1
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|JALR
operator||
name|S
argument_list|(
name|PIC_ADDR_REG
argument_list|)
operator||
name|DA
argument_list|(
name|RETURN_ADDR_REG
argument_list|)
argument_list|,
name|UNMOVABLE_INS
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We need an extra instruction in any case. */
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|ADDU_W
operator||
name|S
argument_list|(
name|SLJIT_SCRATCH_REG1
argument_list|)
operator||
name|TA
argument_list|(
literal|0
argument_list|)
operator||
name|DA
argument_list|(
literal|4
argument_list|)
argument_list|,
name|UNMOVABLE_INS
argument_list|)
return|;
block|}
comment|/* Register input. */
if|if
condition|(
name|type
operator|>=
name|SLJIT_CALL1
condition|)
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|ADDU_W
operator||
name|S
argument_list|(
name|SLJIT_SCRATCH_REG1
argument_list|)
operator||
name|TA
argument_list|(
literal|0
argument_list|)
operator||
name|DA
argument_list|(
literal|4
argument_list|)
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|JALR
operator||
name|S
argument_list|(
name|src_r
argument_list|)
operator||
name|DA
argument_list|(
name|RETURN_ADDR_REG
argument_list|)
argument_list|,
name|UNMOVABLE_INS
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|ADDU_W
operator||
name|S
argument_list|(
name|src_r
argument_list|)
operator||
name|TA
argument_list|(
literal|0
argument_list|)
operator||
name|D
argument_list|(
name|PIC_ADDR_REG
argument_list|)
argument_list|,
name|UNMOVABLE_INS
argument_list|)
return|;
block|}
if|if
condition|(
name|src
operator|&
name|SLJIT_IMM
condition|)
block|{
name|jump
operator|=
operator|(
expr|struct
name|sljit_jump
operator|*
operator|)
name|ensure_abuf
argument_list|(
name|compiler
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sljit_jump
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|jump
argument_list|)
expr_stmt|;
name|set_jump
argument_list|(
name|jump
argument_list|,
name|compiler
argument_list|,
name|JUMP_ADDR
operator||
operator|(
operator|(
name|type
operator|>=
name|SLJIT_FAST_CALL
operator|)
condition|?
name|IS_JAL
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|jump
operator|->
name|u
operator|.
name|target
operator|=
name|srcw
expr_stmt|;
if|if
condition|(
name|compiler
operator|->
name|delay_slot
operator|!=
name|UNMOVABLE_INS
condition|)
name|jump
operator|->
name|flags
operator||=
name|IS_MOVABLE
expr_stmt|;
name|FAIL_IF
argument_list|(
name|emit_const
argument_list|(
name|compiler
argument_list|,
name|TMP_REG2
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|src
operator|&
name|SLJIT_MEM
condition|)
name|FAIL_IF
argument_list|(
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MOV
argument_list|,
name|WORD_DATA
argument_list|,
name|TMP_REG2
argument_list|,
literal|0
argument_list|,
name|TMP_REG1
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|JR
operator||
name|S
argument_list|(
name|src_r
argument_list|)
argument_list|,
name|UNMOVABLE_INS
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|jump
condition|)
name|jump
operator|->
name|addr
operator|=
name|compiler
operator|->
name|size
expr_stmt|;
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|NOP
argument_list|,
name|UNMOVABLE_INS
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_op_flags
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_op_flags
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|,
name|sljit_si
name|type
parameter_list|)
block|{
name|sljit_si
name|sugg_dst_ar
decl_stmt|,
name|dst_ar
decl_stmt|;
name|sljit_si
name|flags
init|=
name|GET_ALL_FLAGS
argument_list|(
name|op
argument_list|)
decl_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_MIPS_32
operator|&&
name|SLJIT_CONFIG_MIPS_32
operator|)
DECL|macro|mem_type
define|#
directive|define
name|mem_type
value|WORD_DATA
else|#
directive|else
name|sljit_si
name|mem_type
init|=
operator|(
name|op
operator|&
name|SLJIT_INT_OP
operator|)
condition|?
operator|(
name|INT_DATA
operator||
name|SIGNED_DATA
operator|)
else|:
name|WORD_DATA
decl_stmt|;
endif|#
directive|endif
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|check_sljit_emit_op_flags
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|ADJUST_LOCAL_OFFSET
argument_list|(
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|==
name|SLJIT_UNUSED
condition|)
return|return
name|SLJIT_SUCCESS
return|;
name|op
operator|=
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_MIPS_64
operator|&&
name|SLJIT_CONFIG_MIPS_64
operator|)
if|if
condition|(
name|op
operator|==
name|SLJIT_MOV_SI
operator|||
name|op
operator|==
name|SLJIT_MOV_UI
condition|)
name|mem_type
operator|=
name|INT_DATA
operator||
name|SIGNED_DATA
expr_stmt|;
endif|#
directive|endif
name|sugg_dst_ar
operator|=
name|DR
argument_list|(
operator|(
name|op
operator|<
name|SLJIT_ADD
operator|&&
name|FAST_IS_REG
argument_list|(
name|dst
argument_list|)
operator|)
condition|?
name|dst
else|:
name|TMP_REG2
argument_list|)
expr_stmt|;
name|compiler
operator|->
name|cache_arg
operator|=
literal|0
expr_stmt|;
name|compiler
operator|->
name|cache_argw
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|op
operator|>=
name|SLJIT_ADD
operator|&&
operator|(
name|src
operator|&
name|SLJIT_MEM
operator|)
condition|)
block|{
name|ADJUST_LOCAL_OFFSET
argument_list|(
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|emit_op_mem2
argument_list|(
name|compiler
argument_list|,
name|mem_type
operator||
name|LOAD_DATA
argument_list|,
name|DR
argument_list|(
name|TMP_REG1
argument_list|)
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
argument_list|)
expr_stmt|;
name|src
operator|=
name|TMP_REG1
expr_stmt|;
name|srcw
operator|=
literal|0
expr_stmt|;
block|}
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SLJIT_C_EQUAL
case|:
case|case
name|SLJIT_C_NOT_EQUAL
case|:
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|SLTIU
operator||
name|SA
argument_list|(
name|EQUAL_FLAG
argument_list|)
operator||
name|TA
argument_list|(
name|sugg_dst_ar
argument_list|)
operator||
name|IMM
argument_list|(
literal|1
argument_list|)
argument_list|,
name|sugg_dst_ar
argument_list|)
argument_list|)
expr_stmt|;
name|dst_ar
operator|=
name|sugg_dst_ar
expr_stmt|;
break|break;
case|case
name|SLJIT_C_LESS
case|:
case|case
name|SLJIT_C_GREATER_EQUAL
case|:
case|case
name|SLJIT_C_FLOAT_LESS
case|:
case|case
name|SLJIT_C_FLOAT_GREATER_EQUAL
case|:
name|dst_ar
operator|=
name|ULESS_FLAG
expr_stmt|;
break|break;
case|case
name|SLJIT_C_GREATER
case|:
case|case
name|SLJIT_C_LESS_EQUAL
case|:
case|case
name|SLJIT_C_FLOAT_GREATER
case|:
case|case
name|SLJIT_C_FLOAT_LESS_EQUAL
case|:
name|dst_ar
operator|=
name|UGREATER_FLAG
expr_stmt|;
break|break;
case|case
name|SLJIT_C_SIG_LESS
case|:
case|case
name|SLJIT_C_SIG_GREATER_EQUAL
case|:
name|dst_ar
operator|=
name|LESS_FLAG
expr_stmt|;
break|break;
case|case
name|SLJIT_C_SIG_GREATER
case|:
case|case
name|SLJIT_C_SIG_LESS_EQUAL
case|:
name|dst_ar
operator|=
name|GREATER_FLAG
expr_stmt|;
break|break;
case|case
name|SLJIT_C_OVERFLOW
case|:
case|case
name|SLJIT_C_NOT_OVERFLOW
case|:
name|dst_ar
operator|=
name|OVERFLOW_FLAG
expr_stmt|;
break|break;
case|case
name|SLJIT_C_MUL_OVERFLOW
case|:
case|case
name|SLJIT_C_MUL_NOT_OVERFLOW
case|:
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|SLTIU
operator||
name|SA
argument_list|(
name|OVERFLOW_FLAG
argument_list|)
operator||
name|TA
argument_list|(
name|sugg_dst_ar
argument_list|)
operator||
name|IMM
argument_list|(
literal|1
argument_list|)
argument_list|,
name|sugg_dst_ar
argument_list|)
argument_list|)
expr_stmt|;
name|dst_ar
operator|=
name|sugg_dst_ar
expr_stmt|;
name|type
operator|^=
literal|0x1
expr_stmt|;
comment|/* Flip type bit for the XORI below. */
break|break;
case|case
name|SLJIT_C_FLOAT_EQUAL
case|:
case|case
name|SLJIT_C_FLOAT_NOT_EQUAL
case|:
name|dst_ar
operator|=
name|EQUAL_FLAG
expr_stmt|;
break|break;
case|case
name|SLJIT_C_FLOAT_UNORDERED
case|:
case|case
name|SLJIT_C_FLOAT_ORDERED
case|:
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|CFC1
operator||
name|TA
argument_list|(
name|sugg_dst_ar
argument_list|)
operator||
name|DA
argument_list|(
name|FCSR_REG
argument_list|)
argument_list|,
name|sugg_dst_ar
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|SRL
operator||
name|TA
argument_list|(
name|sugg_dst_ar
argument_list|)
operator||
name|DA
argument_list|(
name|sugg_dst_ar
argument_list|)
operator||
name|SH_IMM
argument_list|(
literal|23
argument_list|)
argument_list|,
name|sugg_dst_ar
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|ANDI
operator||
name|SA
argument_list|(
name|sugg_dst_ar
argument_list|)
operator||
name|TA
argument_list|(
name|sugg_dst_ar
argument_list|)
operator||
name|IMM
argument_list|(
literal|1
argument_list|)
argument_list|,
name|sugg_dst_ar
argument_list|)
argument_list|)
expr_stmt|;
name|dst_ar
operator|=
name|sugg_dst_ar
expr_stmt|;
break|break;
default|default:
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
name|dst_ar
operator|=
name|sugg_dst_ar
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|type
operator|&
literal|0x1
condition|)
block|{
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|XORI
operator||
name|SA
argument_list|(
name|dst_ar
argument_list|)
operator||
name|TA
argument_list|(
name|sugg_dst_ar
argument_list|)
operator||
name|IMM
argument_list|(
literal|1
argument_list|)
argument_list|,
name|sugg_dst_ar
argument_list|)
argument_list|)
expr_stmt|;
name|dst_ar
operator|=
name|sugg_dst_ar
expr_stmt|;
block|}
if|if
condition|(
name|op
operator|>=
name|SLJIT_ADD
condition|)
block|{
if|if
condition|(
name|DR
argument_list|(
name|TMP_REG2
argument_list|)
operator|!=
name|dst_ar
condition|)
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|ADDU_W
operator||
name|SA
argument_list|(
name|dst_ar
argument_list|)
operator||
name|TA
argument_list|(
literal|0
argument_list|)
operator||
name|D
argument_list|(
name|TMP_REG2
argument_list|)
argument_list|,
name|DR
argument_list|(
name|TMP_REG2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|op
operator||
name|flags
argument_list|,
name|mem_type
operator||
name|CUMULATIVE_OP
operator||
name|LOGICAL_OP
operator||
name|IMM_OP
operator||
name|ALT_KEEP_CACHE
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|,
name|TMP_REG2
argument_list|,
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|dst
operator|&
name|SLJIT_MEM
condition|)
return|return
name|emit_op_mem
argument_list|(
name|compiler
argument_list|,
name|mem_type
argument_list|,
name|dst_ar
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
return|;
if|if
condition|(
name|sugg_dst_ar
operator|!=
name|dst_ar
condition|)
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|ADDU_W
operator||
name|SA
argument_list|(
name|dst_ar
argument_list|)
operator||
name|TA
argument_list|(
literal|0
argument_list|)
operator||
name|DA
argument_list|(
name|sugg_dst_ar
argument_list|)
argument_list|,
name|sugg_dst_ar
argument_list|)
return|;
return|return
name|SLJIT_SUCCESS
return|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_MIPS_32
operator|&&
name|SLJIT_CONFIG_MIPS_32
operator|)
DECL|macro|mem_type
undef|#
directive|undef
name|mem_type
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|sljit_emit_const
name|SLJIT_API_FUNC_ATTRIBUTE
name|struct
name|sljit_const
modifier|*
name|sljit_emit_const
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_sw
name|init_value
parameter_list|)
block|{
name|struct
name|sljit_const
modifier|*
name|const_
decl_stmt|;
name|sljit_si
name|reg
decl_stmt|;
name|CHECK_ERROR_PTR
argument_list|()
expr_stmt|;
name|check_sljit_emit_const
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|init_value
argument_list|)
expr_stmt|;
name|ADJUST_LOCAL_OFFSET
argument_list|(
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|const_
operator|=
operator|(
expr|struct
name|sljit_const
operator|*
operator|)
name|ensure_abuf
argument_list|(
name|compiler
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sljit_const
argument_list|)
argument_list|)
expr_stmt|;
name|PTR_FAIL_IF
argument_list|(
operator|!
name|const_
argument_list|)
expr_stmt|;
name|set_const
argument_list|(
name|const_
argument_list|,
name|compiler
argument_list|)
expr_stmt|;
name|reg
operator|=
name|SLOW_IS_REG
argument_list|(
name|dst
argument_list|)
condition|?
name|dst
else|:
name|TMP_REG2
expr_stmt|;
name|PTR_FAIL_IF
argument_list|(
name|emit_const
argument_list|(
name|compiler
argument_list|,
name|reg
argument_list|,
name|init_value
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|&
name|SLJIT_MEM
condition|)
name|PTR_FAIL_IF
argument_list|(
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MOV
argument_list|,
name|WORD_DATA
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REG1
argument_list|,
literal|0
argument_list|,
name|TMP_REG2
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|const_
return|;
block|}
end_function
end_unit
