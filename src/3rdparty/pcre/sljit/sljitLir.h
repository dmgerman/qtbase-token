begin_unit
begin_comment
comment|/*  *    Stack-less Just-In-Time compiler  *  *    Copyright 2009-2012 Zoltan Herczeg (hzmester@freemail.hu). All rights reserved.  *  * Redistribution and use in source and binary forms, with or without modification, are  * permitted provided that the following conditions are met:  *  *   1. Redistributions of source code must retain the above copyright notice, this list of  *      conditions and the following disclaimer.  *  *   2. Redistributions in binary form must reproduce the above copyright notice, this list  *      of conditions and the following disclaimer in the documentation and/or other materials  *      provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER(S) AND CONTRIBUTORS ``AS IS'' AND ANY  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT  * SHALL THE COPYRIGHT HOLDER(S) OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED  * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR  * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|_SLJIT_LIR_H_
end_ifndef
begin_define
DECL|macro|_SLJIT_LIR_H_
define|#
directive|define
name|_SLJIT_LIR_H_
end_define
begin_comment
comment|/*    ------------------------------------------------------------------------     Stack-Less JIT compiler for multiple architectures (x86, ARM, PowerPC)    ------------------------------------------------------------------------     Short description     Advantages:       - The execution can be continued from any LIR instruction. In other         words, it is possible to jump to any label from anywhere, even from         a code fragment, which is compiled later, if both compiled code         shares the same context. See sljit_emit_enter for more details       - Supports self modifying code: target of (conditional) jump and call         instructions and some constant values can be dynamically modified         during runtime         - although it is not suggested to do it frequently         - can be used for inline caching: save an important value once           in the instruction stream         - since this feature limits the optimization possibilities, a           special flag must be passed at compile time when these           instructions are emitted       - A fixed stack space can be allocated for local variables       - The compiler is thread-safe       - The compiler is highly configurable through preprocessor macros.         You can disable unneeded features (multithreading in single         threaded applications), and you can use your own system functions         (including memory allocators). See sljitConfig.h     Disadvantages:       - No automatic register allocation, and temporary results are         not stored on the stack. (hence the name comes)     In practice:       - This approach is very effective for interpreters         - One of the saved registers typically points to a stack interface         - It can jump to any exception handler anytime (even if it belongs           to another function)         - Hot paths can be modified during runtime reflecting the changes           of the fastest execution path of the dynamic language         - SLJIT supports complex memory addressing modes         - mainly position and context independent code (except some cases)      For valgrind users:       - pass --smc-check=all argument to valgrind, since JIT is a "self-modifying code" */
end_comment
begin_if
if|#
directive|if
operator|!
operator|(
name|defined
name|SLJIT_NO_DEFAULT_CONFIG
operator|&&
name|SLJIT_NO_DEFAULT_CONFIG
operator|)
end_if
begin_include
include|#
directive|include
file|"sljitConfig.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* The following header file defines useful macros for fine tuning sljit based code generators. They are listed in the beginning of sljitConfigInternal.h */
end_comment
begin_include
include|#
directive|include
file|"sljitConfigInternal.h"
end_include
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_comment
comment|/*  Error codes                                                          */
end_comment
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_comment
comment|/* Indicates no error. */
end_comment
begin_define
DECL|macro|SLJIT_SUCCESS
define|#
directive|define
name|SLJIT_SUCCESS
value|0
end_define
begin_comment
comment|/* After the call of sljit_generate_code(), the error code of the compiler    is set to this value to avoid future sljit calls (in debug mode at least).    The complier should be freed after sljit_generate_code(). */
end_comment
begin_define
DECL|macro|SLJIT_ERR_COMPILED
define|#
directive|define
name|SLJIT_ERR_COMPILED
value|1
end_define
begin_comment
comment|/* Cannot allocate non executable memory. */
end_comment
begin_define
DECL|macro|SLJIT_ERR_ALLOC_FAILED
define|#
directive|define
name|SLJIT_ERR_ALLOC_FAILED
value|2
end_define
begin_comment
comment|/* Cannot allocate executable memory.    Only for sljit_generate_code() */
end_comment
begin_define
DECL|macro|SLJIT_ERR_EX_ALLOC_FAILED
define|#
directive|define
name|SLJIT_ERR_EX_ALLOC_FAILED
value|3
end_define
begin_comment
comment|/* Return value for SLJIT_CONFIG_UNSUPPORTED placeholder architecture. */
end_comment
begin_define
DECL|macro|SLJIT_ERR_UNSUPPORTED
define|#
directive|define
name|SLJIT_ERR_UNSUPPORTED
value|4
end_define
begin_comment
comment|/* An ivalid argument is passed to any SLJIT function. */
end_comment
begin_define
DECL|macro|SLJIT_ERR_BAD_ARGUMENT
define|#
directive|define
name|SLJIT_ERR_BAD_ARGUMENT
value|5
end_define
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_comment
comment|/*  Registers                                                            */
end_comment
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_comment
comment|/*   Scratch (R) registers: registers whose may not preserve their values   across function calls.    Saved (S) registers: registers whose preserve their values across   function calls.    The scratch and saved register sets are overlap. The last scratch register   is the first saved register, the one before the last is the second saved   register, and so on.    If an architecture provides two scratch and three saved registers,   its scratch and saved register sets are the following:       R0   |  [S4]  |   R0 and S4 represent the same physical register      R1   |  [S3]  |   R1 and S3 represent the same physical register     [R2]  |   S2   |   R2 and S2 represent the same physical register     [R3]  |   S1   |   R3 and S1 represent the same physical register     [R4]  |   S0   |   R4 and S0 represent the same physical register    Note: SLJIT_NUMBER_OF_SCRATCH_REGISTERS would be 2 and         SLJIT_NUMBER_OF_SAVED_REGISTERS would be 3 for this architecture.    Note: On all supported architectures SLJIT_NUMBER_OF_REGISTERS>= 10         and SLJIT_NUMBER_OF_SAVED_REGISTERS>= 5. However, 4 registers         are virtual on x86-32. See below.    The purpose of this definition is convenience. Although a register   is either scratch register or saved register, SLJIT allows accessing   them from the other set. For example, four registers can be used as   scratch registers and the fifth one as saved register on the architecture   above. Of course the last two scratch registers (R2 and R3) from this   four will be saved on the stack, because they are defined as saved   registers in the application binary interface. Still R2 and R3 can be   used for referencing to these registers instead of S2 and S1, which   makes easier to write platform independent code. Scratch registers   can be saved registers in a similar way, but these extra saved   registers will not be preserved across function calls! Hence the   application must save them on those platforms, where the number of   saved registers is too low. This can be done by copy them onto   the stack and restore them after a function call.    Note: To emphasize that registers assigned to R2-R4 are saved         registers, they are enclosed by square brackets. S3-S4         are marked in a similar way.    Note: sljit_emit_enter and sljit_set_context defines whether a register         is S or R register. E.g: when 3 scratches and 1 saved is mapped         by sljit_emit_enter, the allowed register set will be: R0-R2 and         S0. Although S2 is mapped to the same position as R2, it does not         available in the current configuration. Furthermore the R3 (S1)         register does not available as well. */
end_comment
begin_comment
comment|/* When SLJIT_UNUSED is specified as destination, the result is discarded. */
end_comment
begin_define
DECL|macro|SLJIT_UNUSED
define|#
directive|define
name|SLJIT_UNUSED
value|0
end_define
begin_comment
comment|/* Scratch registers. */
end_comment
begin_define
DECL|macro|SLJIT_R0
define|#
directive|define
name|SLJIT_R0
value|1
end_define
begin_define
DECL|macro|SLJIT_R1
define|#
directive|define
name|SLJIT_R1
value|2
end_define
begin_define
DECL|macro|SLJIT_R2
define|#
directive|define
name|SLJIT_R2
value|3
end_define
begin_comment
comment|/* Note: on x86-32, R3 - R6 (same as S3 - S6) are emulated (they    are allocated on the stack). These registers are called virtual    and cannot be used for memory addressing (cannot be part of    any SLJIT_MEM1, SLJIT_MEM2 construct). There is no such    limitation on other CPUs. See sljit_get_register_index(). */
end_comment
begin_define
DECL|macro|SLJIT_R3
define|#
directive|define
name|SLJIT_R3
value|4
end_define
begin_define
DECL|macro|SLJIT_R4
define|#
directive|define
name|SLJIT_R4
value|5
end_define
begin_define
DECL|macro|SLJIT_R5
define|#
directive|define
name|SLJIT_R5
value|6
end_define
begin_define
DECL|macro|SLJIT_R6
define|#
directive|define
name|SLJIT_R6
value|7
end_define
begin_define
DECL|macro|SLJIT_R7
define|#
directive|define
name|SLJIT_R7
value|8
end_define
begin_define
DECL|macro|SLJIT_R8
define|#
directive|define
name|SLJIT_R8
value|9
end_define
begin_define
DECL|macro|SLJIT_R9
define|#
directive|define
name|SLJIT_R9
value|10
end_define
begin_comment
comment|/* All R registers provided by the architecture can be accessed by SLJIT_R(i)    The i parameter must be>= 0 and< SLJIT_NUMBER_OF_REGISTERS. */
end_comment
begin_define
DECL|macro|SLJIT_R
define|#
directive|define
name|SLJIT_R
parameter_list|(
name|i
parameter_list|)
value|(1 + (i))
end_define
begin_comment
comment|/* Saved registers. */
end_comment
begin_define
DECL|macro|SLJIT_S0
define|#
directive|define
name|SLJIT_S0
value|(SLJIT_NUMBER_OF_REGISTERS)
end_define
begin_define
DECL|macro|SLJIT_S1
define|#
directive|define
name|SLJIT_S1
value|(SLJIT_NUMBER_OF_REGISTERS - 1)
end_define
begin_define
DECL|macro|SLJIT_S2
define|#
directive|define
name|SLJIT_S2
value|(SLJIT_NUMBER_OF_REGISTERS - 2)
end_define
begin_comment
comment|/* Note: on x86-32, S3 - S6 (same as R3 - R6) are emulated (they    are allocated on the stack). These registers are called virtual    and cannot be used for memory addressing (cannot be part of    any SLJIT_MEM1, SLJIT_MEM2 construct). There is no such    limitation on other CPUs. See sljit_get_register_index(). */
end_comment
begin_define
DECL|macro|SLJIT_S3
define|#
directive|define
name|SLJIT_S3
value|(SLJIT_NUMBER_OF_REGISTERS - 3)
end_define
begin_define
DECL|macro|SLJIT_S4
define|#
directive|define
name|SLJIT_S4
value|(SLJIT_NUMBER_OF_REGISTERS - 4)
end_define
begin_define
DECL|macro|SLJIT_S5
define|#
directive|define
name|SLJIT_S5
value|(SLJIT_NUMBER_OF_REGISTERS - 5)
end_define
begin_define
DECL|macro|SLJIT_S6
define|#
directive|define
name|SLJIT_S6
value|(SLJIT_NUMBER_OF_REGISTERS - 6)
end_define
begin_define
DECL|macro|SLJIT_S7
define|#
directive|define
name|SLJIT_S7
value|(SLJIT_NUMBER_OF_REGISTERS - 7)
end_define
begin_define
DECL|macro|SLJIT_S8
define|#
directive|define
name|SLJIT_S8
value|(SLJIT_NUMBER_OF_REGISTERS - 8)
end_define
begin_define
DECL|macro|SLJIT_S9
define|#
directive|define
name|SLJIT_S9
value|(SLJIT_NUMBER_OF_REGISTERS - 9)
end_define
begin_comment
comment|/* All S registers provided by the architecture can be accessed by SLJIT_S(i)    The i parameter must be>= 0 and< SLJIT_NUMBER_OF_SAVED_REGISTERS. */
end_comment
begin_define
DECL|macro|SLJIT_S
define|#
directive|define
name|SLJIT_S
parameter_list|(
name|i
parameter_list|)
value|(SLJIT_NUMBER_OF_REGISTERS - (i))
end_define
begin_comment
comment|/* Registers>= SLJIT_FIRST_SAVED_REG are saved registers. */
end_comment
begin_define
DECL|macro|SLJIT_FIRST_SAVED_REG
define|#
directive|define
name|SLJIT_FIRST_SAVED_REG
value|(SLJIT_S0 - SLJIT_NUMBER_OF_SAVED_REGISTERS + 1)
end_define
begin_comment
comment|/* The SLJIT_SP provides direct access to the linear stack space allocated by    sljit_emit_enter. It can only be used in the following form: SLJIT_MEM1(SLJIT_SP).    The immediate offset is extended by the relative stack offset automatically.    The sljit_get_local_base can be used to obtain the absolute offset. */
end_comment
begin_define
DECL|macro|SLJIT_SP
define|#
directive|define
name|SLJIT_SP
value|(SLJIT_NUMBER_OF_REGISTERS + 1)
end_define
begin_comment
comment|/* Return with machine word. */
end_comment
begin_define
DECL|macro|SLJIT_RETURN_REG
define|#
directive|define
name|SLJIT_RETURN_REG
value|SLJIT_R0
end_define
begin_comment
comment|/* x86 prefers specific registers for special purposes. In case of shift    by register it supports only SLJIT_R2 for shift argument    (which is the src2 argument of sljit_emit_op2). If another register is    used, sljit must exchange data between registers which cause a minor    slowdown. Other architectures has no such limitation. */
end_comment
begin_define
DECL|macro|SLJIT_PREF_SHIFT_REG
define|#
directive|define
name|SLJIT_PREF_SHIFT_REG
value|SLJIT_R2
end_define
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_comment
comment|/*  Floating point registers                                             */
end_comment
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_comment
comment|/* Each floating point register can store a double or single precision    value. The FR and FS register sets are overlap in the same way as R    and S register sets. See above. */
end_comment
begin_comment
comment|/* Note: SLJIT_UNUSED as destination is not valid for floating point    operations, since they cannot be used for setting flags. */
end_comment
begin_comment
comment|/* Floating point scratch registers. */
end_comment
begin_define
DECL|macro|SLJIT_FR0
define|#
directive|define
name|SLJIT_FR0
value|1
end_define
begin_define
DECL|macro|SLJIT_FR1
define|#
directive|define
name|SLJIT_FR1
value|2
end_define
begin_define
DECL|macro|SLJIT_FR2
define|#
directive|define
name|SLJIT_FR2
value|3
end_define
begin_define
DECL|macro|SLJIT_FR3
define|#
directive|define
name|SLJIT_FR3
value|4
end_define
begin_define
DECL|macro|SLJIT_FR4
define|#
directive|define
name|SLJIT_FR4
value|5
end_define
begin_define
DECL|macro|SLJIT_FR5
define|#
directive|define
name|SLJIT_FR5
value|6
end_define
begin_comment
comment|/* All FR registers provided by the architecture can be accessed by SLJIT_FR(i)    The i parameter must be>= 0 and< SLJIT_NUMBER_OF_FLOAT_REGISTERS. */
end_comment
begin_define
DECL|macro|SLJIT_FR
define|#
directive|define
name|SLJIT_FR
parameter_list|(
name|i
parameter_list|)
value|(1 + (i))
end_define
begin_comment
comment|/* Floating point saved registers. */
end_comment
begin_define
DECL|macro|SLJIT_FS0
define|#
directive|define
name|SLJIT_FS0
value|(SLJIT_NUMBER_OF_FLOAT_REGISTERS)
end_define
begin_define
DECL|macro|SLJIT_FS1
define|#
directive|define
name|SLJIT_FS1
value|(SLJIT_NUMBER_OF_FLOAT_REGISTERS - 1)
end_define
begin_define
DECL|macro|SLJIT_FS2
define|#
directive|define
name|SLJIT_FS2
value|(SLJIT_NUMBER_OF_FLOAT_REGISTERS - 2)
end_define
begin_define
DECL|macro|SLJIT_FS3
define|#
directive|define
name|SLJIT_FS3
value|(SLJIT_NUMBER_OF_FLOAT_REGISTERS - 3)
end_define
begin_define
DECL|macro|SLJIT_FS4
define|#
directive|define
name|SLJIT_FS4
value|(SLJIT_NUMBER_OF_FLOAT_REGISTERS - 4)
end_define
begin_define
DECL|macro|SLJIT_FS5
define|#
directive|define
name|SLJIT_FS5
value|(SLJIT_NUMBER_OF_FLOAT_REGISTERS - 5)
end_define
begin_comment
comment|/* All S registers provided by the architecture can be accessed by SLJIT_FS(i)    The i parameter must be>= 0 and< SLJIT_NUMBER_OF_SAVED_FLOAT_REGISTERS. */
end_comment
begin_define
DECL|macro|SLJIT_FS
define|#
directive|define
name|SLJIT_FS
parameter_list|(
name|i
parameter_list|)
value|(SLJIT_NUMBER_OF_FLOAT_REGISTERS - (i))
end_define
begin_comment
comment|/* Float registers>= SLJIT_FIRST_SAVED_FLOAT_REG are saved registers. */
end_comment
begin_define
DECL|macro|SLJIT_FIRST_SAVED_FLOAT_REG
define|#
directive|define
name|SLJIT_FIRST_SAVED_FLOAT_REG
value|(SLJIT_FS0 - SLJIT_NUMBER_OF_SAVED_FLOAT_REGISTERS + 1)
end_define
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_comment
comment|/*  Main structures and functions                                        */
end_comment
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_comment
comment|/* 	The following structures are private, and can be changed in the 	future. Keeping them here allows code inlining. */
end_comment
begin_struct
DECL|struct|sljit_memory_fragment
struct|struct
name|sljit_memory_fragment
block|{
DECL|member|next
name|struct
name|sljit_memory_fragment
modifier|*
name|next
decl_stmt|;
DECL|member|used_size
name|sljit_uw
name|used_size
decl_stmt|;
comment|/* Must be aligned to sljit_sw. */
DECL|member|memory
name|sljit_ub
name|memory
index|[
literal|1
index|]
decl_stmt|;
block|}
struct|;
end_struct
begin_struct
DECL|struct|sljit_label
struct|struct
name|sljit_label
block|{
DECL|member|next
name|struct
name|sljit_label
modifier|*
name|next
decl_stmt|;
DECL|member|addr
name|sljit_uw
name|addr
decl_stmt|;
comment|/* The maximum size difference. */
DECL|member|size
name|sljit_uw
name|size
decl_stmt|;
block|}
struct|;
end_struct
begin_struct
DECL|struct|sljit_jump
struct|struct
name|sljit_jump
block|{
DECL|member|next
name|struct
name|sljit_jump
modifier|*
name|next
decl_stmt|;
DECL|member|addr
name|sljit_uw
name|addr
decl_stmt|;
DECL|member|flags
name|sljit_sw
name|flags
decl_stmt|;
union|union
block|{
DECL|member|target
name|sljit_uw
name|target
decl_stmt|;
DECL|member|label
name|struct
name|sljit_label
modifier|*
name|label
decl_stmt|;
block|}
DECL|member|u
name|u
union|;
block|}
struct|;
end_struct
begin_struct
DECL|struct|sljit_const
struct|struct
name|sljit_const
block|{
DECL|member|next
name|struct
name|sljit_const
modifier|*
name|next
decl_stmt|;
DECL|member|addr
name|sljit_uw
name|addr
decl_stmt|;
block|}
struct|;
end_struct
begin_struct
DECL|struct|sljit_compiler
struct|struct
name|sljit_compiler
block|{
DECL|member|error
name|sljit_si
name|error
decl_stmt|;
DECL|member|options
name|sljit_si
name|options
decl_stmt|;
DECL|member|labels
name|struct
name|sljit_label
modifier|*
name|labels
decl_stmt|;
DECL|member|jumps
name|struct
name|sljit_jump
modifier|*
name|jumps
decl_stmt|;
DECL|member|consts
name|struct
name|sljit_const
modifier|*
name|consts
decl_stmt|;
DECL|member|last_label
name|struct
name|sljit_label
modifier|*
name|last_label
decl_stmt|;
DECL|member|last_jump
name|struct
name|sljit_jump
modifier|*
name|last_jump
decl_stmt|;
DECL|member|last_const
name|struct
name|sljit_const
modifier|*
name|last_const
decl_stmt|;
DECL|member|allocator_data
name|void
modifier|*
name|allocator_data
decl_stmt|;
DECL|member|buf
name|struct
name|sljit_memory_fragment
modifier|*
name|buf
decl_stmt|;
DECL|member|abuf
name|struct
name|sljit_memory_fragment
modifier|*
name|abuf
decl_stmt|;
comment|/* Used scratch registers. */
DECL|member|scratches
name|sljit_si
name|scratches
decl_stmt|;
comment|/* Used saved registers. */
DECL|member|saveds
name|sljit_si
name|saveds
decl_stmt|;
comment|/* Used float scratch registers. */
DECL|member|fscratches
name|sljit_si
name|fscratches
decl_stmt|;
comment|/* Used float saved registers. */
DECL|member|fsaveds
name|sljit_si
name|fsaveds
decl_stmt|;
comment|/* Local stack size. */
DECL|member|local_size
name|sljit_si
name|local_size
decl_stmt|;
comment|/* Code size. */
DECL|member|size
name|sljit_uw
name|size
decl_stmt|;
comment|/* For statistical purposes. */
DECL|member|executable_size
name|sljit_uw
name|executable_size
decl_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_32
operator|&&
name|SLJIT_CONFIG_X86_32
operator|)
DECL|member|args
name|sljit_si
name|args
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
DECL|member|mode32
name|sljit_si
name|mode32
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86
operator|&&
name|SLJIT_CONFIG_X86
operator|)
DECL|member|flags_saved
name|sljit_si
name|flags_saved
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_ARM_V5
operator|&&
name|SLJIT_CONFIG_ARM_V5
operator|)
comment|/* Constant pool handling. */
DECL|member|cpool
name|sljit_uw
modifier|*
name|cpool
decl_stmt|;
DECL|member|cpool_unique
name|sljit_ub
modifier|*
name|cpool_unique
decl_stmt|;
DECL|member|cpool_diff
name|sljit_uw
name|cpool_diff
decl_stmt|;
DECL|member|cpool_fill
name|sljit_uw
name|cpool_fill
decl_stmt|;
comment|/* Other members. */
comment|/* Contains pointer, "ldr pc, [...]" pairs. */
DECL|member|patches
name|sljit_uw
name|patches
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_ARM_V5
operator|&&
name|SLJIT_CONFIG_ARM_V5
operator|)
operator|||
operator|(
name|defined
name|SLJIT_CONFIG_ARM_V7
operator|&&
name|SLJIT_CONFIG_ARM_V7
operator|)
comment|/* Temporary fields. */
DECL|member|shift_imm
name|sljit_uw
name|shift_imm
decl_stmt|;
DECL|member|cache_arg
name|sljit_si
name|cache_arg
decl_stmt|;
DECL|member|cache_argw
name|sljit_sw
name|cache_argw
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_ARM_THUMB2
operator|&&
name|SLJIT_CONFIG_ARM_THUMB2
operator|)
DECL|member|cache_arg
name|sljit_si
name|cache_arg
decl_stmt|;
DECL|member|cache_argw
name|sljit_sw
name|cache_argw
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_ARM_64
operator|&&
name|SLJIT_CONFIG_ARM_64
operator|)
DECL|member|cache_arg
name|sljit_si
name|cache_arg
decl_stmt|;
DECL|member|cache_argw
name|sljit_sw
name|cache_argw
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_PPC
operator|&&
name|SLJIT_CONFIG_PPC
operator|)
DECL|member|imm
name|sljit_sw
name|imm
decl_stmt|;
DECL|member|cache_arg
name|sljit_si
name|cache_arg
decl_stmt|;
DECL|member|cache_argw
name|sljit_sw
name|cache_argw
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_MIPS
operator|&&
name|SLJIT_CONFIG_MIPS
operator|)
DECL|member|delay_slot
name|sljit_si
name|delay_slot
decl_stmt|;
DECL|member|cache_arg
name|sljit_si
name|cache_arg
decl_stmt|;
DECL|member|cache_argw
name|sljit_sw
name|cache_argw
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_SPARC_32
operator|&&
name|SLJIT_CONFIG_SPARC_32
operator|)
DECL|member|delay_slot
name|sljit_si
name|delay_slot
decl_stmt|;
DECL|member|cache_arg
name|sljit_si
name|cache_arg
decl_stmt|;
DECL|member|cache_argw
name|sljit_sw
name|cache_argw
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_TILEGX
operator|&&
name|SLJIT_CONFIG_TILEGX
operator|)
DECL|member|cache_arg
name|sljit_si
name|cache_arg
decl_stmt|;
DECL|member|cache_argw
name|sljit_sw
name|cache_argw
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
name|SLJIT_VERBOSE
operator|&&
name|SLJIT_VERBOSE
operator|)
DECL|member|verbose
name|FILE
modifier|*
name|verbose
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
name|SLJIT_ARGUMENT_CHECKS
operator|&&
name|SLJIT_ARGUMENT_CHECKS
operator|)
expr|\
operator|||
operator|(
name|defined
name|SLJIT_DEBUG
operator|&&
name|SLJIT_DEBUG
operator|)
comment|/* Local size passed to the functions. */
DECL|member|logical_local_size
name|sljit_si
name|logical_local_size
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
name|SLJIT_ARGUMENT_CHECKS
operator|&&
name|SLJIT_ARGUMENT_CHECKS
operator|)
expr|\
operator|||
operator|(
name|defined
name|SLJIT_DEBUG
operator|&&
name|SLJIT_DEBUG
operator|)
expr|\
operator|||
operator|(
name|defined
name|SLJIT_VERBOSE
operator|&&
name|SLJIT_VERBOSE
operator|)
DECL|member|skip_checks
name|sljit_si
name|skip_checks
decl_stmt|;
endif|#
directive|endif
block|}
struct|;
end_struct
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_comment
comment|/*  Main functions                                                       */
end_comment
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_comment
comment|/* Creates an sljit compiler. The allocator_data is required by some    custom memory managers. This pointer is passed to SLJIT_MALLOC    and SLJIT_FREE macros. Most allocators (including the default    one) ignores this value, and it is recommended to pass NULL    as a dummy value for allocator_data.     Returns NULL if failed. */
end_comment
begin_function_decl
name|SLJIT_API_FUNC_ATTRIBUTE
name|struct
name|sljit_compiler
modifier|*
name|sljit_create_compiler
parameter_list|(
name|void
modifier|*
name|allocator_data
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/* Frees everything except the compiled machine code. */
end_comment
begin_function_decl
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
name|sljit_free_compiler
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/* Returns the current error code. If an error is occurred, future sljit    calls which uses the same compiler argument returns early with the same    error code. Thus there is no need for checking the error after every    call, it is enough to do it before the code is compiled. Removing    these checks increases the performance of the compiling process. */
end_comment
begin_function
DECL|function|sljit_get_compiler_error
specifier|static
name|SLJIT_INLINE
name|sljit_si
name|sljit_get_compiler_error
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|)
block|{
return|return
name|compiler
operator|->
name|error
return|;
block|}
end_function
begin_comment
comment|/* Sets the compiler error code to SLJIT_ERR_ALLOC_FAILED except    if an error was detected before. After the error code is set    the compiler behaves as if the allocation failure happened    during an sljit function call. This can greatly simplify error    checking, since only the compiler status needs to be checked    after the compilation. */
end_comment
begin_function_decl
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
name|sljit_set_compiler_memory_error
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/*    Allocate a small amount of memory. The size must be<= 64 bytes on 32 bit,    and<= 128 bytes on 64 bit architectures. The memory area is owned by the    compiler, and freed by sljit_free_compiler. The returned pointer is    sizeof(sljit_sw) aligned. Excellent for allocating small blocks during    the compiling, and no need to worry about freeing them. The size is    enough to contain at most 16 pointers. If the size is outside of the range,    the function will return with NULL. However, this return value does not    indicate that there is no more memory (does not set the current error code    of the compiler to out-of-memory status). */
end_comment
begin_function_decl
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
modifier|*
name|sljit_alloc_memory
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|size
parameter_list|)
function_decl|;
end_function_decl
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_VERBOSE
operator|&&
name|SLJIT_VERBOSE
operator|)
end_if
begin_comment
comment|/* Passing NULL disables verbose. */
end_comment
begin_function_decl
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
name|sljit_compiler_verbose
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|FILE
modifier|*
name|verbose
parameter_list|)
function_decl|;
end_function_decl
begin_endif
endif|#
directive|endif
end_endif
begin_function_decl
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
modifier|*
name|sljit_generate_code
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
name|sljit_free_code
parameter_list|(
name|void
modifier|*
name|code
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/*    After the machine code generation is finished we can retrieve the allocated    executable memory size, although this area may not be fully filled with    instructions depending on some optimizations. This function is useful only    for statistical purposes.     Before a successful code generation, this function returns with 0. */
end_comment
begin_function
DECL|function|sljit_get_generated_code_size
specifier|static
name|SLJIT_INLINE
name|sljit_uw
name|sljit_get_generated_code_size
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|)
block|{
return|return
name|compiler
operator|->
name|executable_size
return|;
block|}
end_function
begin_comment
comment|/* Instruction generation. Returns with any error code. If there is no    error, they return with SLJIT_SUCCESS. */
end_comment
begin_comment
comment|/*    The executable code is a function call from the viewpoint of the C    language. The function calls must obey to the ABI (Application    Binary Interface) of the platform, which specify the purpose of    all machine registers and stack handling among other things. The    sljit_emit_enter function emits the necessary instructions for    setting up a new context for the executable code and moves function    arguments to the saved registers. Furthermore the options argument    can be used to pass configuration options to the compiler. The    available options are listed before sljit_emit_enter.     The number of sljit_sw arguments passed to the generated function    are specified in the "args" parameter. The number of arguments must    be less than or equal to 3. The first argument goes to SLJIT_S0,    the second goes to SLJIT_S1 and so on. The register set used by    the function must be declared as well. The number of scratch and    saved registers used by the function must be passed to sljit_emit_enter.    Only R registers between R0 and "scratches" argument can be used    later. E.g. if "scratches" is set to 2, the register set will be    limited to R0 and R1. The S registers and the floating point    registers ("fscratches" and "fsaveds") are specified in a similar    way. The sljit_emit_enter is also capable of allocating a stack    space for local variables. The "local_size" argument contains the    size in bytes of this local area and its staring address is stored    in SLJIT_SP. The memory area between SLJIT_SP (inclusive) and    SLJIT_SP + local_size (exclusive) can be modified freely until    the function returns. The stack space is not initialized.     Note: the following conditions must met:          0<= scratches<= SLJIT_NUMBER_OF_REGISTERS          0<= saveds<= SLJIT_NUMBER_OF_REGISTERS          scratches + saveds<= SLJIT_NUMBER_OF_REGISTERS          0<= fscratches<= SLJIT_NUMBER_OF_FLOAT_REGISTERS          0<= fsaveds<= SLJIT_NUMBER_OF_FLOAT_REGISTERS          fscratches + fsaveds<= SLJIT_NUMBER_OF_FLOAT_REGISTERS     Note: every call of sljit_emit_enter and sljit_set_context          overwrites the previous context. */
end_comment
begin_comment
comment|/* The absolute address returned by sljit_get_local_base with offset 0 is aligned to sljit_d. Otherwise it is aligned to sljit_uw. */
end_comment
begin_define
DECL|macro|SLJIT_DOUBLE_ALIGNMENT
define|#
directive|define
name|SLJIT_DOUBLE_ALIGNMENT
value|0x00000001
end_define
begin_comment
comment|/* The local_size must be>= 0 and<= SLJIT_MAX_LOCAL_SIZE. */
end_comment
begin_define
DECL|macro|SLJIT_MAX_LOCAL_SIZE
define|#
directive|define
name|SLJIT_MAX_LOCAL_SIZE
value|65536
end_define
begin_function_decl
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_enter
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|options
parameter_list|,
name|sljit_si
name|args
parameter_list|,
name|sljit_si
name|scratches
parameter_list|,
name|sljit_si
name|saveds
parameter_list|,
name|sljit_si
name|fscratches
parameter_list|,
name|sljit_si
name|fsaveds
parameter_list|,
name|sljit_si
name|local_size
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/* The machine code has a context (which contains the local stack space size,    number of used registers, etc.) which initialized by sljit_emit_enter. Several    functions (like sljit_emit_return) requres this context to be able to generate    the appropriate code. However, some code fragments (like inline cache) may have    no normal entry point so their context is unknown for the compiler. Their context    can be provided to the compiler by the sljit_set_context function.     Note: every call of sljit_emit_enter and sljit_set_context overwrites          the previous context. */
end_comment
begin_function_decl
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_set_context
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|options
parameter_list|,
name|sljit_si
name|args
parameter_list|,
name|sljit_si
name|scratches
parameter_list|,
name|sljit_si
name|saveds
parameter_list|,
name|sljit_si
name|fscratches
parameter_list|,
name|sljit_si
name|fsaveds
parameter_list|,
name|sljit_si
name|local_size
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/* Return from machine code.  The op argument can be SLJIT_UNUSED which means the    function does not return with anything or any opcode between SLJIT_MOV and    SLJIT_MOV_P (see sljit_emit_op1). As for src and srcw they must be 0 if op    is SLJIT_UNUSED, otherwise see below the description about source and    destination arguments. */
end_comment
begin_function_decl
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_return
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/* Fast calling mechanism for utility functions (see SLJIT_FAST_CALL). All registers and    even the stack frame is passed to the callee. The return address is preserved in    dst/dstw by sljit_emit_fast_enter (the type of the value stored by this function    is sljit_p), and sljit_emit_fast_return can use this as a return value later. */
end_comment
begin_comment
comment|/* Note: only for sljit specific, non ABI compilant calls. Fast, since only a few machine    instructions are needed. Excellent for small uility functions, where saving registers    and setting up a new stack frame would cost too much performance. However, it is still    possible to return to the address of the caller (or anywhere else). */
end_comment
begin_comment
comment|/* Note: flags are not changed (unlike sljit_emit_enter / sljit_emit_return). */
end_comment
begin_comment
comment|/* Note: although sljit_emit_fast_return could be replaced by an ijump, it is not suggested,    since many architectures do clever branch prediction on call / return instruction pairs. */
end_comment
begin_function_decl
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_fast_enter
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_fast_return
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/*    Source and destination values for arithmetical instructions     imm              - a simple immediate value (cannot be used as a destination)     reg              - any of the registers (immediate argument must be 0)     [imm]            - absolute immediate memory address     [reg+imm]        - indirect memory address     [reg+(reg<<imm)] - indirect indexed memory address (shift must be between 0 and 3)                        useful for (byte, half, int, sljit_sw) array access                        (fully supported by both x86 and ARM architectures, and cheap operation on others) */
end_comment
begin_comment
comment|/*    IMPORATNT NOTE: memory access MUST be naturally aligned except                    SLJIT_UNALIGNED macro is defined and its value is 1.       length | alignment    ---------+-----------      byte   | 1 byte (any physical_address is accepted)      half   | 2 byte (physical_address& 0x1 == 0)      int    | 4 byte (physical_address& 0x3 == 0)      word   | 4 byte if SLJIT_32BIT_ARCHITECTURE is defined and its value is 1             | 8 byte if SLJIT_64BIT_ARCHITECTURE is defined and its value is 1     pointer | size of sljit_p type (4 byte on 32 bit machines, 4 or 8 byte             | on 64 bit machines)     Note:   Different architectures have different addressing limitations.            A single instruction is enough for the following addressing            modes. Other adrressing modes are emulated by instruction            sequences. This information could help to improve those code            generators which focuses only a few architectures.     x86:    [reg+imm], -2^32+1<= imm<= 2^32-1 (full address space on x86-32)            [reg+(reg<<imm)] is supported            [imm], -2^32+1<= imm<= 2^32-1 is supported            Write-back is not supported    arm:    [reg+imm], -4095<= imm<= 4095 or -255<= imm<= 255 for signed                 bytes, any halfs or floating point values)            [reg+(reg<<imm)] is supported            Write-back is supported    arm-t2: [reg+imm], -255<= imm<= 4095            [reg+(reg<<imm)] is supported            Write back is supported only for [reg+imm], where -255<= imm<= 255    ppc:    [reg+imm], -65536<= imm<= 65535. 64 bit loads/stores and 32 bit                 signed load on 64 bit requires immediates divisible by 4.                 [reg+imm] is not supported for signed 8 bit values.            [reg+reg] is supported            Write-back is supported except for one instruction: 32 bit signed                 load with [reg+imm] addressing mode on 64 bit.    mips:   [reg+imm], -65536<= imm<= 65535    sparc:  [reg+imm], -4096<= imm<= 4095            [reg+reg] is supported */
end_comment
begin_comment
comment|/* Register output: simply the name of the register.    For destination, you can use SLJIT_UNUSED as well. */
end_comment
begin_define
DECL|macro|SLJIT_MEM
define|#
directive|define
name|SLJIT_MEM
value|0x80
end_define
begin_define
DECL|macro|SLJIT_MEM0
define|#
directive|define
name|SLJIT_MEM0
parameter_list|()
value|(SLJIT_MEM)
end_define
begin_define
DECL|macro|SLJIT_MEM1
define|#
directive|define
name|SLJIT_MEM1
parameter_list|(
name|r1
parameter_list|)
value|(SLJIT_MEM | (r1))
end_define
begin_define
DECL|macro|SLJIT_MEM2
define|#
directive|define
name|SLJIT_MEM2
parameter_list|(
name|r1
parameter_list|,
name|r2
parameter_list|)
value|(SLJIT_MEM | (r1) | ((r2)<< 8))
end_define
begin_define
DECL|macro|SLJIT_IMM
define|#
directive|define
name|SLJIT_IMM
value|0x40
end_define
begin_comment
comment|/* Set 32 bit operation mode (I) on 64 bit CPUs. The flag is totally ignored on    32 bit CPUs. If this flag is set for an arithmetic operation, it uses only the    lower 32 bit of the input register(s), and set the CPU status flags according    to the 32 bit result. The higher 32 bits are undefined for both the input and    output. However, the CPU might not ignore those higher 32 bits, like MIPS, which    expects it to be the sign extension of the lower 32 bit. All 32 bit operations    are undefined, if this condition is not fulfilled. Therefore, when SLJIT_INT_OP    is specified, all register arguments must be the result of other operations with    the same SLJIT_INT_OP flag. In other words, although a register can hold either    a 64 or 32 bit value, these values cannot be mixed. The only exceptions are    SLJIT_IMOV and SLJIT_IMOVU (SLJIT_MOV_SI/SLJIT_MOVU_SI with SLJIT_INT_OP flag)    which can convert any source argument to SLJIT_INT_OP compatible result. This    conversion might be unnecessary on some CPUs like x86-64, since the upper 32    bit is always ignored. In this case SLJIT is clever enough to not generate any    instructions if the source and destination operands are the same registers.    Affects sljit_emit_op0, sljit_emit_op1 and sljit_emit_op2. */
end_comment
begin_define
DECL|macro|SLJIT_INT_OP
define|#
directive|define
name|SLJIT_INT_OP
value|0x100
end_define
begin_comment
comment|/* Single precision mode (SP). This flag is similar to SLJIT_INT_OP, just    it applies to floating point registers (it is even the same bit). When    this flag is passed, the CPU performs single precision floating point    operations. Similar to SLJIT_INT_OP, all register arguments must be the    result of other floating point operations with this flag. Affects    sljit_emit_fop1, sljit_emit_fop2 and sljit_emit_fcmp. */
end_comment
begin_define
DECL|macro|SLJIT_SINGLE_OP
define|#
directive|define
name|SLJIT_SINGLE_OP
value|0x100
end_define
begin_comment
comment|/* Common CPU status flags for all architectures (x86, ARM, PPC)     - carry flag     - overflow flag     - zero flag     - negative/positive flag (depends on arc)    On mips, these flags are emulated by software. */
end_comment
begin_comment
comment|/* By default, the instructions may, or may not set the CPU status flags.    Forcing to set or keep status flags can be done with the following flags: */
end_comment
begin_comment
comment|/* Note: sljit tries to emit the minimum number of instructions. Using these    flags can increase them, so use them wisely to avoid unnecessary code generation. */
end_comment
begin_comment
comment|/* Set Equal (Zero) status flag (E). */
end_comment
begin_define
DECL|macro|SLJIT_SET_E
define|#
directive|define
name|SLJIT_SET_E
value|0x0200
end_define
begin_comment
comment|/* Set unsigned status flag (U). */
end_comment
begin_define
DECL|macro|SLJIT_SET_U
define|#
directive|define
name|SLJIT_SET_U
value|0x0400
end_define
begin_comment
comment|/* Set signed status flag (S). */
end_comment
begin_define
DECL|macro|SLJIT_SET_S
define|#
directive|define
name|SLJIT_SET_S
value|0x0800
end_define
begin_comment
comment|/* Set signed overflow flag (O). */
end_comment
begin_define
DECL|macro|SLJIT_SET_O
define|#
directive|define
name|SLJIT_SET_O
value|0x1000
end_define
begin_comment
comment|/* Set carry flag (C).    Note: Kinda unsigned overflow, but behaves differently on various cpus. */
end_comment
begin_define
DECL|macro|SLJIT_SET_C
define|#
directive|define
name|SLJIT_SET_C
value|0x2000
end_define
begin_comment
comment|/* Do not modify the flags (K).    Note: This flag cannot be combined with any other SLJIT_SET_* flag. */
end_comment
begin_define
DECL|macro|SLJIT_KEEP_FLAGS
define|#
directive|define
name|SLJIT_KEEP_FLAGS
value|0x4000
end_define
begin_comment
comment|/* Notes:      - you cannot postpone conditional jump instructions except if noted that        the instruction does not set flags (See: SLJIT_KEEP_FLAGS).      - flag combinations: '|' means 'logical or'. */
end_comment
begin_comment
comment|/* Starting index of opcodes for sljit_emit_op0. */
end_comment
begin_define
DECL|macro|SLJIT_OP0_BASE
define|#
directive|define
name|SLJIT_OP0_BASE
value|0
end_define
begin_comment
comment|/* Flags: - (never set any flags)    Note: breakpoint instruction is not supported by all architectures (e.g. ppc)          It falls back to SLJIT_NOP in those cases. */
end_comment
begin_define
DECL|macro|SLJIT_BREAKPOINT
define|#
directive|define
name|SLJIT_BREAKPOINT
value|(SLJIT_OP0_BASE + 0)
end_define
begin_comment
comment|/* Flags: - (never set any flags)    Note: may or may not cause an extra cycle wait          it can even decrease the runtime in a few cases. */
end_comment
begin_define
DECL|macro|SLJIT_NOP
define|#
directive|define
name|SLJIT_NOP
value|(SLJIT_OP0_BASE + 1)
end_define
begin_comment
comment|/* Flags: - (may destroy flags)    Unsigned multiplication of SLJIT_R0 and SLJIT_R1.    Result is placed into SLJIT_R1:SLJIT_R0 (high:low) word */
end_comment
begin_define
DECL|macro|SLJIT_LUMUL
define|#
directive|define
name|SLJIT_LUMUL
value|(SLJIT_OP0_BASE + 2)
end_define
begin_comment
comment|/* Flags: - (may destroy flags)    Signed multiplication of SLJIT_R0 and SLJIT_R1.    Result is placed into SLJIT_R1:SLJIT_R0 (high:low) word */
end_comment
begin_define
DECL|macro|SLJIT_LSMUL
define|#
directive|define
name|SLJIT_LSMUL
value|(SLJIT_OP0_BASE + 3)
end_define
begin_comment
comment|/* Flags: I - (may destroy flags)    Unsigned divide of the value in SLJIT_R0 by the value in SLJIT_R1.    The result is placed into SLJIT_R0 and the remainder into SLJIT_R1.    Note: if SLJIT_R1 is 0, the behaviour is undefined. */
end_comment
begin_define
DECL|macro|SLJIT_UDIVMOD
define|#
directive|define
name|SLJIT_UDIVMOD
value|(SLJIT_OP0_BASE + 4)
end_define
begin_define
DECL|macro|SLJIT_IUDIVMOD
define|#
directive|define
name|SLJIT_IUDIVMOD
value|(SLJIT_UDIVMOD | SLJIT_INT_OP)
end_define
begin_comment
comment|/* Flags: I - (may destroy flags)    Signed divide of the value in SLJIT_R0 by the value in SLJIT_R1.    The result is placed into SLJIT_R0 and the remainder into SLJIT_R1.    Note: if SLJIT_R1 is 0, the behaviour is undefined.    Note: if SLJIT_R1 is -1 and SLJIT_R0 is integer min (0x800..00),          the behaviour is undefined. */
end_comment
begin_define
DECL|macro|SLJIT_SDIVMOD
define|#
directive|define
name|SLJIT_SDIVMOD
value|(SLJIT_OP0_BASE + 5)
end_define
begin_define
DECL|macro|SLJIT_ISDIVMOD
define|#
directive|define
name|SLJIT_ISDIVMOD
value|(SLJIT_SDIVMOD | SLJIT_INT_OP)
end_define
begin_comment
comment|/* Flags: I - (may destroy flags)    Unsigned divide of the value in SLJIT_R0 by the value in SLJIT_R1.    The result is placed into SLJIT_R0. SLJIT_R1 preserves its value.    Note: if SLJIT_R1 is 0, the behaviour is undefined.    Note: SLJIT_SDIV is single precision divide. */
end_comment
begin_define
DECL|macro|SLJIT_UDIVI
define|#
directive|define
name|SLJIT_UDIVI
value|(SLJIT_OP0_BASE + 6)
end_define
begin_define
DECL|macro|SLJIT_IUDIVI
define|#
directive|define
name|SLJIT_IUDIVI
value|(SLJIT_UDIVI | SLJIT_INT_OP)
end_define
begin_comment
comment|/* Flags: I - (may destroy flags)    Signed divide of the value in SLJIT_R0 by the value in SLJIT_R1.    The result is placed into SLJIT_R0. SLJIT_R1 preserves its value.    Note: if SLJIT_R1 is 0, the behaviour is undefined.    Note: if SLJIT_R1 is -1 and SLJIT_R0 is integer min (0x800..00),          the behaviour is undefined.    Note: SLJIT_SDIV is single precision divide. */
end_comment
begin_define
DECL|macro|SLJIT_SDIVI
define|#
directive|define
name|SLJIT_SDIVI
value|(SLJIT_OP0_BASE + 7)
end_define
begin_define
DECL|macro|SLJIT_ISDIVI
define|#
directive|define
name|SLJIT_ISDIVI
value|(SLJIT_SDIVI | SLJIT_INT_OP)
end_define
begin_function_decl
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_op0
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/* Starting index of opcodes for sljit_emit_op1. */
end_comment
begin_define
DECL|macro|SLJIT_OP1_BASE
define|#
directive|define
name|SLJIT_OP1_BASE
value|32
end_define
begin_comment
comment|/* Notes for MOV instructions:    U = Mov with update (pre form). If source or destination defined as SLJIT_MEM1(r1)        or SLJIT_MEM2(r1, r2), r1 is increased by the sum of r2 and the constant argument    UB = unsigned byte (8 bit)    SB = signed byte (8 bit)    UH = unsigned half (16 bit)    SH = signed half (16 bit)    UI = unsigned int (32 bit)    SI = signed int (32 bit)    P  = pointer (sljit_p) size */
end_comment
begin_comment
comment|/* Flags: - (never set any flags) */
end_comment
begin_define
DECL|macro|SLJIT_MOV
define|#
directive|define
name|SLJIT_MOV
value|(SLJIT_OP1_BASE + 0)
end_define
begin_comment
comment|/* Flags: I - (never set any flags) */
end_comment
begin_define
DECL|macro|SLJIT_MOV_UB
define|#
directive|define
name|SLJIT_MOV_UB
value|(SLJIT_OP1_BASE + 1)
end_define
begin_define
DECL|macro|SLJIT_IMOV_UB
define|#
directive|define
name|SLJIT_IMOV_UB
value|(SLJIT_MOV_UB | SLJIT_INT_OP)
end_define
begin_comment
comment|/* Flags: I - (never set any flags) */
end_comment
begin_define
DECL|macro|SLJIT_MOV_SB
define|#
directive|define
name|SLJIT_MOV_SB
value|(SLJIT_OP1_BASE + 2)
end_define
begin_define
DECL|macro|SLJIT_IMOV_SB
define|#
directive|define
name|SLJIT_IMOV_SB
value|(SLJIT_MOV_SB | SLJIT_INT_OP)
end_define
begin_comment
comment|/* Flags: I - (never set any flags) */
end_comment
begin_define
DECL|macro|SLJIT_MOV_UH
define|#
directive|define
name|SLJIT_MOV_UH
value|(SLJIT_OP1_BASE + 3)
end_define
begin_define
DECL|macro|SLJIT_IMOV_UH
define|#
directive|define
name|SLJIT_IMOV_UH
value|(SLJIT_MOV_UH | SLJIT_INT_OP)
end_define
begin_comment
comment|/* Flags: I - (never set any flags) */
end_comment
begin_define
DECL|macro|SLJIT_MOV_SH
define|#
directive|define
name|SLJIT_MOV_SH
value|(SLJIT_OP1_BASE + 4)
end_define
begin_define
DECL|macro|SLJIT_IMOV_SH
define|#
directive|define
name|SLJIT_IMOV_SH
value|(SLJIT_MOV_SH | SLJIT_INT_OP)
end_define
begin_comment
comment|/* Flags: I - (never set any flags)    Note: see SLJIT_INT_OP for further details. */
end_comment
begin_define
DECL|macro|SLJIT_MOV_UI
define|#
directive|define
name|SLJIT_MOV_UI
value|(SLJIT_OP1_BASE + 5)
end_define
begin_comment
comment|/* No SLJIT_INT_OP form, since it is the same as SLJIT_IMOV. */
end_comment
begin_comment
comment|/* Flags: I - (never set any flags)    Note: see SLJIT_INT_OP for further details. */
end_comment
begin_define
DECL|macro|SLJIT_MOV_SI
define|#
directive|define
name|SLJIT_MOV_SI
value|(SLJIT_OP1_BASE + 6)
end_define
begin_define
DECL|macro|SLJIT_IMOV
define|#
directive|define
name|SLJIT_IMOV
value|(SLJIT_MOV_SI | SLJIT_INT_OP)
end_define
begin_comment
comment|/* Flags: - (never set any flags) */
end_comment
begin_define
DECL|macro|SLJIT_MOV_P
define|#
directive|define
name|SLJIT_MOV_P
value|(SLJIT_OP1_BASE + 7)
end_define
begin_comment
comment|/* Flags: - (never set any flags) */
end_comment
begin_define
DECL|macro|SLJIT_MOVU
define|#
directive|define
name|SLJIT_MOVU
value|(SLJIT_OP1_BASE + 8)
end_define
begin_comment
comment|/* Flags: I - (never set any flags) */
end_comment
begin_define
DECL|macro|SLJIT_MOVU_UB
define|#
directive|define
name|SLJIT_MOVU_UB
value|(SLJIT_OP1_BASE + 9)
end_define
begin_define
DECL|macro|SLJIT_IMOVU_UB
define|#
directive|define
name|SLJIT_IMOVU_UB
value|(SLJIT_MOVU_UB | SLJIT_INT_OP)
end_define
begin_comment
comment|/* Flags: I - (never set any flags) */
end_comment
begin_define
DECL|macro|SLJIT_MOVU_SB
define|#
directive|define
name|SLJIT_MOVU_SB
value|(SLJIT_OP1_BASE + 10)
end_define
begin_define
DECL|macro|SLJIT_IMOVU_SB
define|#
directive|define
name|SLJIT_IMOVU_SB
value|(SLJIT_MOVU_SB | SLJIT_INT_OP)
end_define
begin_comment
comment|/* Flags: I - (never set any flags) */
end_comment
begin_define
DECL|macro|SLJIT_MOVU_UH
define|#
directive|define
name|SLJIT_MOVU_UH
value|(SLJIT_OP1_BASE + 11)
end_define
begin_define
DECL|macro|SLJIT_IMOVU_UH
define|#
directive|define
name|SLJIT_IMOVU_UH
value|(SLJIT_MOVU_UH | SLJIT_INT_OP)
end_define
begin_comment
comment|/* Flags: I - (never set any flags) */
end_comment
begin_define
DECL|macro|SLJIT_MOVU_SH
define|#
directive|define
name|SLJIT_MOVU_SH
value|(SLJIT_OP1_BASE + 12)
end_define
begin_define
DECL|macro|SLJIT_IMOVU_SH
define|#
directive|define
name|SLJIT_IMOVU_SH
value|(SLJIT_MOVU_SH | SLJIT_INT_OP)
end_define
begin_comment
comment|/* Flags: I - (never set any flags)    Note: see SLJIT_INT_OP for further details. */
end_comment
begin_define
DECL|macro|SLJIT_MOVU_UI
define|#
directive|define
name|SLJIT_MOVU_UI
value|(SLJIT_OP1_BASE + 13)
end_define
begin_comment
comment|/* No SLJIT_INT_OP form, since it is the same as SLJIT_IMOVU. */
end_comment
begin_comment
comment|/* Flags: I - (never set any flags)    Note: see SLJIT_INT_OP for further details. */
end_comment
begin_define
DECL|macro|SLJIT_MOVU_SI
define|#
directive|define
name|SLJIT_MOVU_SI
value|(SLJIT_OP1_BASE + 14)
end_define
begin_define
DECL|macro|SLJIT_IMOVU
define|#
directive|define
name|SLJIT_IMOVU
value|(SLJIT_MOVU_SI | SLJIT_INT_OP)
end_define
begin_comment
comment|/* Flags: - (never set any flags) */
end_comment
begin_define
DECL|macro|SLJIT_MOVU_P
define|#
directive|define
name|SLJIT_MOVU_P
value|(SLJIT_OP1_BASE + 15)
end_define
begin_comment
comment|/* Flags: I | E | K */
end_comment
begin_define
DECL|macro|SLJIT_NOT
define|#
directive|define
name|SLJIT_NOT
value|(SLJIT_OP1_BASE + 16)
end_define
begin_define
DECL|macro|SLJIT_INOT
define|#
directive|define
name|SLJIT_INOT
value|(SLJIT_NOT | SLJIT_INT_OP)
end_define
begin_comment
comment|/* Flags: I | E | O | K */
end_comment
begin_define
DECL|macro|SLJIT_NEG
define|#
directive|define
name|SLJIT_NEG
value|(SLJIT_OP1_BASE + 17)
end_define
begin_define
DECL|macro|SLJIT_INEG
define|#
directive|define
name|SLJIT_INEG
value|(SLJIT_NEG | SLJIT_INT_OP)
end_define
begin_comment
comment|/* Count leading zeroes    Flags: I | E | K    Important note! Sparc 32 does not support K flag, since    the required popc instruction is introduced only in sparc 64. */
end_comment
begin_define
DECL|macro|SLJIT_CLZ
define|#
directive|define
name|SLJIT_CLZ
value|(SLJIT_OP1_BASE + 18)
end_define
begin_define
DECL|macro|SLJIT_ICLZ
define|#
directive|define
name|SLJIT_ICLZ
value|(SLJIT_CLZ | SLJIT_INT_OP)
end_define
begin_function_decl
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_op1
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/* Starting index of opcodes for sljit_emit_op2. */
end_comment
begin_define
DECL|macro|SLJIT_OP2_BASE
define|#
directive|define
name|SLJIT_OP2_BASE
value|96
end_define
begin_comment
comment|/* Flags: I | E | O | C | K */
end_comment
begin_define
DECL|macro|SLJIT_ADD
define|#
directive|define
name|SLJIT_ADD
value|(SLJIT_OP2_BASE + 0)
end_define
begin_define
DECL|macro|SLJIT_IADD
define|#
directive|define
name|SLJIT_IADD
value|(SLJIT_ADD | SLJIT_INT_OP)
end_define
begin_comment
comment|/* Flags: I | C | K */
end_comment
begin_define
DECL|macro|SLJIT_ADDC
define|#
directive|define
name|SLJIT_ADDC
value|(SLJIT_OP2_BASE + 1)
end_define
begin_define
DECL|macro|SLJIT_IADDC
define|#
directive|define
name|SLJIT_IADDC
value|(SLJIT_ADDC | SLJIT_INT_OP)
end_define
begin_comment
comment|/* Flags: I | E | U | S | O | C | K */
end_comment
begin_define
DECL|macro|SLJIT_SUB
define|#
directive|define
name|SLJIT_SUB
value|(SLJIT_OP2_BASE + 2)
end_define
begin_define
DECL|macro|SLJIT_ISUB
define|#
directive|define
name|SLJIT_ISUB
value|(SLJIT_SUB | SLJIT_INT_OP)
end_define
begin_comment
comment|/* Flags: I | C | K */
end_comment
begin_define
DECL|macro|SLJIT_SUBC
define|#
directive|define
name|SLJIT_SUBC
value|(SLJIT_OP2_BASE + 3)
end_define
begin_define
DECL|macro|SLJIT_ISUBC
define|#
directive|define
name|SLJIT_ISUBC
value|(SLJIT_SUBC | SLJIT_INT_OP)
end_define
begin_comment
comment|/* Note: integer mul    Flags: I | O (see SLJIT_C_MUL_*) | K */
end_comment
begin_define
DECL|macro|SLJIT_MUL
define|#
directive|define
name|SLJIT_MUL
value|(SLJIT_OP2_BASE + 4)
end_define
begin_define
DECL|macro|SLJIT_IMUL
define|#
directive|define
name|SLJIT_IMUL
value|(SLJIT_MUL | SLJIT_INT_OP)
end_define
begin_comment
comment|/* Flags: I | E | K */
end_comment
begin_define
DECL|macro|SLJIT_AND
define|#
directive|define
name|SLJIT_AND
value|(SLJIT_OP2_BASE + 5)
end_define
begin_define
DECL|macro|SLJIT_IAND
define|#
directive|define
name|SLJIT_IAND
value|(SLJIT_AND | SLJIT_INT_OP)
end_define
begin_comment
comment|/* Flags: I | E | K */
end_comment
begin_define
DECL|macro|SLJIT_OR
define|#
directive|define
name|SLJIT_OR
value|(SLJIT_OP2_BASE + 6)
end_define
begin_define
DECL|macro|SLJIT_IOR
define|#
directive|define
name|SLJIT_IOR
value|(SLJIT_OR | SLJIT_INT_OP)
end_define
begin_comment
comment|/* Flags: I | E | K */
end_comment
begin_define
DECL|macro|SLJIT_XOR
define|#
directive|define
name|SLJIT_XOR
value|(SLJIT_OP2_BASE + 7)
end_define
begin_define
DECL|macro|SLJIT_IXOR
define|#
directive|define
name|SLJIT_IXOR
value|(SLJIT_XOR | SLJIT_INT_OP)
end_define
begin_comment
comment|/* Flags: I | E | K    Let bit_length be the length of the shift operation: 32 or 64.    If src2 is immediate, src2w is masked by (bit_length - 1).    Otherwise, if the content of src2 is outside the range from 0    to bit_length - 1, the result is undefined. */
end_comment
begin_define
DECL|macro|SLJIT_SHL
define|#
directive|define
name|SLJIT_SHL
value|(SLJIT_OP2_BASE + 8)
end_define
begin_define
DECL|macro|SLJIT_ISHL
define|#
directive|define
name|SLJIT_ISHL
value|(SLJIT_SHL | SLJIT_INT_OP)
end_define
begin_comment
comment|/* Flags: I | E | K    Let bit_length be the length of the shift operation: 32 or 64.    If src2 is immediate, src2w is masked by (bit_length - 1).    Otherwise, if the content of src2 is outside the range from 0    to bit_length - 1, the result is undefined. */
end_comment
begin_define
DECL|macro|SLJIT_LSHR
define|#
directive|define
name|SLJIT_LSHR
value|(SLJIT_OP2_BASE + 9)
end_define
begin_define
DECL|macro|SLJIT_ILSHR
define|#
directive|define
name|SLJIT_ILSHR
value|(SLJIT_LSHR | SLJIT_INT_OP)
end_define
begin_comment
comment|/* Flags: I | E | K    Let bit_length be the length of the shift operation: 32 or 64.    If src2 is immediate, src2w is masked by (bit_length - 1).    Otherwise, if the content of src2 is outside the range from 0    to bit_length - 1, the result is undefined. */
end_comment
begin_define
DECL|macro|SLJIT_ASHR
define|#
directive|define
name|SLJIT_ASHR
value|(SLJIT_OP2_BASE + 10)
end_define
begin_define
DECL|macro|SLJIT_IASHR
define|#
directive|define
name|SLJIT_IASHR
value|(SLJIT_ASHR | SLJIT_INT_OP)
end_define
begin_function_decl
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_op2
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src1
parameter_list|,
name|sljit_sw
name|src1w
parameter_list|,
name|sljit_si
name|src2
parameter_list|,
name|sljit_sw
name|src2w
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/* The following function is a helper function for sljit_emit_op_custom.    It returns with the real machine register index (>=0 ) of any SLJIT_R,    SLJIT_S and SLJIT_SP registers.     Note: it returns with -1 for virtual registers (only on x86-32). */
end_comment
begin_function_decl
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_get_register_index
parameter_list|(
name|sljit_si
name|reg
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/* The following function is a helper function for sljit_emit_op_custom.    It returns with the real machine register index of any SLJIT_FLOAT register.     Note: the index is always an even number on ARM (except ARM-64), MIPS, and SPARC. */
end_comment
begin_function_decl
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_get_float_register_index
parameter_list|(
name|sljit_si
name|reg
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/* Any instruction can be inserted into the instruction stream by    sljit_emit_op_custom. It has a similar purpose as inline assembly.    The size parameter must match to the instruction size of the target    architecture:           x86: 0< size<= 15. The instruction argument can be byte aligned.       Thumb2: if size == 2, the instruction argument must be 2 byte aligned.               if size == 4, the instruction argument must be 4 byte aligned.    Otherwise: size must be 4 and instruction argument must be 4 byte aligned. */
end_comment
begin_function_decl
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_op_custom
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|void
modifier|*
name|instruction
parameter_list|,
name|sljit_si
name|size
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/* Returns with non-zero if fpu is available. */
end_comment
begin_function_decl
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_is_fpu_available
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/* Starting index of opcodes for sljit_emit_fop1. */
end_comment
begin_define
DECL|macro|SLJIT_FOP1_BASE
define|#
directive|define
name|SLJIT_FOP1_BASE
value|128
end_define
begin_comment
comment|/* Flags: SP - (never set any flags) */
end_comment
begin_define
DECL|macro|SLJIT_DMOV
define|#
directive|define
name|SLJIT_DMOV
value|(SLJIT_FOP1_BASE + 0)
end_define
begin_define
DECL|macro|SLJIT_SMOV
define|#
directive|define
name|SLJIT_SMOV
value|(SLJIT_DMOV | SLJIT_SINGLE_OP)
end_define
begin_comment
comment|/* Convert opcodes: CONV[DST_TYPE].FROM[SRC_TYPE]    SRC/DST TYPE can be: D - double, S - single, W - signed word, I - signed int    Rounding mode when the destination is W or I: round towards zero. */
end_comment
begin_comment
comment|/* Flags: SP - (never set any flags) */
end_comment
begin_define
DECL|macro|SLJIT_CONVD_FROMS
define|#
directive|define
name|SLJIT_CONVD_FROMS
value|(SLJIT_FOP1_BASE + 1)
end_define
begin_define
DECL|macro|SLJIT_CONVS_FROMD
define|#
directive|define
name|SLJIT_CONVS_FROMD
value|(SLJIT_CONVD_FROMS | SLJIT_SINGLE_OP)
end_define
begin_comment
comment|/* Flags: SP - (never set any flags) */
end_comment
begin_define
DECL|macro|SLJIT_CONVW_FROMD
define|#
directive|define
name|SLJIT_CONVW_FROMD
value|(SLJIT_FOP1_BASE + 2)
end_define
begin_define
DECL|macro|SLJIT_CONVW_FROMS
define|#
directive|define
name|SLJIT_CONVW_FROMS
value|(SLJIT_CONVW_FROMD | SLJIT_SINGLE_OP)
end_define
begin_comment
comment|/* Flags: SP - (never set any flags) */
end_comment
begin_define
DECL|macro|SLJIT_CONVI_FROMD
define|#
directive|define
name|SLJIT_CONVI_FROMD
value|(SLJIT_FOP1_BASE + 3)
end_define
begin_define
DECL|macro|SLJIT_CONVI_FROMS
define|#
directive|define
name|SLJIT_CONVI_FROMS
value|(SLJIT_CONVI_FROMD | SLJIT_SINGLE_OP)
end_define
begin_comment
comment|/* Flags: SP - (never set any flags) */
end_comment
begin_define
DECL|macro|SLJIT_CONVD_FROMW
define|#
directive|define
name|SLJIT_CONVD_FROMW
value|(SLJIT_FOP1_BASE + 4)
end_define
begin_define
DECL|macro|SLJIT_CONVS_FROMW
define|#
directive|define
name|SLJIT_CONVS_FROMW
value|(SLJIT_CONVD_FROMW | SLJIT_SINGLE_OP)
end_define
begin_comment
comment|/* Flags: SP - (never set any flags) */
end_comment
begin_define
DECL|macro|SLJIT_CONVD_FROMI
define|#
directive|define
name|SLJIT_CONVD_FROMI
value|(SLJIT_FOP1_BASE + 5)
end_define
begin_define
DECL|macro|SLJIT_CONVS_FROMI
define|#
directive|define
name|SLJIT_CONVS_FROMI
value|(SLJIT_CONVD_FROMI | SLJIT_SINGLE_OP)
end_define
begin_comment
comment|/* Note: dst is the left and src is the right operand for SLJIT_CMPD.    Note: NaN check is always performed. If SLJIT_C_FLOAT_UNORDERED flag          is set, the comparison result is unpredictable.    Flags: SP | E | S (see SLJIT_C_FLOAT_*) */
end_comment
begin_define
DECL|macro|SLJIT_DCMP
define|#
directive|define
name|SLJIT_DCMP
value|(SLJIT_FOP1_BASE + 6)
end_define
begin_define
DECL|macro|SLJIT_SCMP
define|#
directive|define
name|SLJIT_SCMP
value|(SLJIT_DCMP | SLJIT_SINGLE_OP)
end_define
begin_comment
comment|/* Flags: SP - (never set any flags) */
end_comment
begin_define
DECL|macro|SLJIT_DNEG
define|#
directive|define
name|SLJIT_DNEG
value|(SLJIT_FOP1_BASE + 7)
end_define
begin_define
DECL|macro|SLJIT_SNEG
define|#
directive|define
name|SLJIT_SNEG
value|(SLJIT_DNEG | SLJIT_SINGLE_OP)
end_define
begin_comment
comment|/* Flags: SP - (never set any flags) */
end_comment
begin_define
DECL|macro|SLJIT_DABS
define|#
directive|define
name|SLJIT_DABS
value|(SLJIT_FOP1_BASE + 8)
end_define
begin_define
DECL|macro|SLJIT_SABS
define|#
directive|define
name|SLJIT_SABS
value|(SLJIT_DABS | SLJIT_SINGLE_OP)
end_define
begin_function_decl
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_fop1
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/* Starting index of opcodes for sljit_emit_fop2. */
end_comment
begin_define
DECL|macro|SLJIT_FOP2_BASE
define|#
directive|define
name|SLJIT_FOP2_BASE
value|160
end_define
begin_comment
comment|/* Flags: SP - (never set any flags) */
end_comment
begin_define
DECL|macro|SLJIT_DADD
define|#
directive|define
name|SLJIT_DADD
value|(SLJIT_FOP2_BASE + 0)
end_define
begin_define
DECL|macro|SLJIT_SADD
define|#
directive|define
name|SLJIT_SADD
value|(SLJIT_DADD | SLJIT_SINGLE_OP)
end_define
begin_comment
comment|/* Flags: SP - (never set any flags) */
end_comment
begin_define
DECL|macro|SLJIT_DSUB
define|#
directive|define
name|SLJIT_DSUB
value|(SLJIT_FOP2_BASE + 1)
end_define
begin_define
DECL|macro|SLJIT_SSUB
define|#
directive|define
name|SLJIT_SSUB
value|(SLJIT_DSUB | SLJIT_SINGLE_OP)
end_define
begin_comment
comment|/* Flags: SP - (never set any flags) */
end_comment
begin_define
DECL|macro|SLJIT_DMUL
define|#
directive|define
name|SLJIT_DMUL
value|(SLJIT_FOP2_BASE + 2)
end_define
begin_define
DECL|macro|SLJIT_SMUL
define|#
directive|define
name|SLJIT_SMUL
value|(SLJIT_DMUL | SLJIT_SINGLE_OP)
end_define
begin_comment
comment|/* Flags: SP - (never set any flags) */
end_comment
begin_define
DECL|macro|SLJIT_DDIV
define|#
directive|define
name|SLJIT_DDIV
value|(SLJIT_FOP2_BASE + 3)
end_define
begin_define
DECL|macro|SLJIT_SDIV
define|#
directive|define
name|SLJIT_SDIV
value|(SLJIT_DDIV | SLJIT_SINGLE_OP)
end_define
begin_function_decl
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_fop2
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src1
parameter_list|,
name|sljit_sw
name|src1w
parameter_list|,
name|sljit_si
name|src2
parameter_list|,
name|sljit_sw
name|src2w
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/* Label and jump instructions. */
end_comment
begin_function_decl
name|SLJIT_API_FUNC_ATTRIBUTE
name|struct
name|sljit_label
modifier|*
name|sljit_emit_label
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/* Invert (negate) conditional type: xor (^) with 0x1 */
end_comment
begin_comment
comment|/* Integer comparison types. */
end_comment
begin_define
DECL|macro|SLJIT_EQUAL
define|#
directive|define
name|SLJIT_EQUAL
value|0
end_define
begin_define
DECL|macro|SLJIT_I_EQUAL
define|#
directive|define
name|SLJIT_I_EQUAL
value|(SLJIT_EQUAL | SLJIT_INT_OP)
end_define
begin_define
DECL|macro|SLJIT_ZERO
define|#
directive|define
name|SLJIT_ZERO
value|0
end_define
begin_define
DECL|macro|SLJIT_I_ZERO
define|#
directive|define
name|SLJIT_I_ZERO
value|(SLJIT_ZERO | SLJIT_INT_OP)
end_define
begin_define
DECL|macro|SLJIT_NOT_EQUAL
define|#
directive|define
name|SLJIT_NOT_EQUAL
value|1
end_define
begin_define
DECL|macro|SLJIT_I_NOT_EQUAL
define|#
directive|define
name|SLJIT_I_NOT_EQUAL
value|(SLJIT_NOT_EQUAL | SLJIT_INT_OP)
end_define
begin_define
DECL|macro|SLJIT_NOT_ZERO
define|#
directive|define
name|SLJIT_NOT_ZERO
value|1
end_define
begin_define
DECL|macro|SLJIT_I_NOT_ZERO
define|#
directive|define
name|SLJIT_I_NOT_ZERO
value|(SLJIT_NOT_ZERO | SLJIT_INT_OP)
end_define
begin_define
DECL|macro|SLJIT_LESS
define|#
directive|define
name|SLJIT_LESS
value|2
end_define
begin_define
DECL|macro|SLJIT_I_LESS
define|#
directive|define
name|SLJIT_I_LESS
value|(SLJIT_LESS | SLJIT_INT_OP)
end_define
begin_define
DECL|macro|SLJIT_GREATER_EQUAL
define|#
directive|define
name|SLJIT_GREATER_EQUAL
value|3
end_define
begin_define
DECL|macro|SLJIT_I_GREATER_EQUAL
define|#
directive|define
name|SLJIT_I_GREATER_EQUAL
value|(SLJIT_GREATER_EQUAL | SLJIT_INT_OP)
end_define
begin_define
DECL|macro|SLJIT_GREATER
define|#
directive|define
name|SLJIT_GREATER
value|4
end_define
begin_define
DECL|macro|SLJIT_I_GREATER
define|#
directive|define
name|SLJIT_I_GREATER
value|(SLJIT_GREATER | SLJIT_INT_OP)
end_define
begin_define
DECL|macro|SLJIT_LESS_EQUAL
define|#
directive|define
name|SLJIT_LESS_EQUAL
value|5
end_define
begin_define
DECL|macro|SLJIT_I_LESS_EQUAL
define|#
directive|define
name|SLJIT_I_LESS_EQUAL
value|(SLJIT_LESS_EQUAL | SLJIT_INT_OP)
end_define
begin_define
DECL|macro|SLJIT_SIG_LESS
define|#
directive|define
name|SLJIT_SIG_LESS
value|6
end_define
begin_define
DECL|macro|SLJIT_I_SIG_LESS
define|#
directive|define
name|SLJIT_I_SIG_LESS
value|(SLJIT_SIG_LESS | SLJIT_INT_OP)
end_define
begin_define
DECL|macro|SLJIT_SIG_GREATER_EQUAL
define|#
directive|define
name|SLJIT_SIG_GREATER_EQUAL
value|7
end_define
begin_define
DECL|macro|SLJIT_I_SIG_GREATER_EQUAL
define|#
directive|define
name|SLJIT_I_SIG_GREATER_EQUAL
value|(SLJIT_SIG_GREATER_EQUAL | SLJIT_INT_OP)
end_define
begin_define
DECL|macro|SLJIT_SIG_GREATER
define|#
directive|define
name|SLJIT_SIG_GREATER
value|8
end_define
begin_define
DECL|macro|SLJIT_I_SIG_GREATER
define|#
directive|define
name|SLJIT_I_SIG_GREATER
value|(SLJIT_SIG_GREATER | SLJIT_INT_OP)
end_define
begin_define
DECL|macro|SLJIT_SIG_LESS_EQUAL
define|#
directive|define
name|SLJIT_SIG_LESS_EQUAL
value|9
end_define
begin_define
DECL|macro|SLJIT_I_SIG_LESS_EQUAL
define|#
directive|define
name|SLJIT_I_SIG_LESS_EQUAL
value|(SLJIT_SIG_LESS_EQUAL | SLJIT_INT_OP)
end_define
begin_define
DECL|macro|SLJIT_OVERFLOW
define|#
directive|define
name|SLJIT_OVERFLOW
value|10
end_define
begin_define
DECL|macro|SLJIT_I_OVERFLOW
define|#
directive|define
name|SLJIT_I_OVERFLOW
value|(SLJIT_OVERFLOW | SLJIT_INT_OP)
end_define
begin_define
DECL|macro|SLJIT_NOT_OVERFLOW
define|#
directive|define
name|SLJIT_NOT_OVERFLOW
value|11
end_define
begin_define
DECL|macro|SLJIT_I_NOT_OVERFLOW
define|#
directive|define
name|SLJIT_I_NOT_OVERFLOW
value|(SLJIT_NOT_OVERFLOW | SLJIT_INT_OP)
end_define
begin_define
DECL|macro|SLJIT_MUL_OVERFLOW
define|#
directive|define
name|SLJIT_MUL_OVERFLOW
value|12
end_define
begin_define
DECL|macro|SLJIT_I_MUL_OVERFLOW
define|#
directive|define
name|SLJIT_I_MUL_OVERFLOW
value|(SLJIT_MUL_OVERFLOW | SLJIT_INT_OP)
end_define
begin_define
DECL|macro|SLJIT_MUL_NOT_OVERFLOW
define|#
directive|define
name|SLJIT_MUL_NOT_OVERFLOW
value|13
end_define
begin_define
DECL|macro|SLJIT_I_MUL_NOT_OVERFLOW
define|#
directive|define
name|SLJIT_I_MUL_NOT_OVERFLOW
value|(SLJIT_MUL_NOT_OVERFLOW | SLJIT_INT_OP)
end_define
begin_comment
comment|/* Floating point comparison types. */
end_comment
begin_define
DECL|macro|SLJIT_D_EQUAL
define|#
directive|define
name|SLJIT_D_EQUAL
value|14
end_define
begin_define
DECL|macro|SLJIT_S_EQUAL
define|#
directive|define
name|SLJIT_S_EQUAL
value|(SLJIT_D_EQUAL | SLJIT_SINGLE_OP)
end_define
begin_define
DECL|macro|SLJIT_D_NOT_EQUAL
define|#
directive|define
name|SLJIT_D_NOT_EQUAL
value|15
end_define
begin_define
DECL|macro|SLJIT_S_NOT_EQUAL
define|#
directive|define
name|SLJIT_S_NOT_EQUAL
value|(SLJIT_D_NOT_EQUAL | SLJIT_SINGLE_OP)
end_define
begin_define
DECL|macro|SLJIT_D_LESS
define|#
directive|define
name|SLJIT_D_LESS
value|16
end_define
begin_define
DECL|macro|SLJIT_S_LESS
define|#
directive|define
name|SLJIT_S_LESS
value|(SLJIT_D_LESS | SLJIT_SINGLE_OP)
end_define
begin_define
DECL|macro|SLJIT_D_GREATER_EQUAL
define|#
directive|define
name|SLJIT_D_GREATER_EQUAL
value|17
end_define
begin_define
DECL|macro|SLJIT_S_GREATER_EQUAL
define|#
directive|define
name|SLJIT_S_GREATER_EQUAL
value|(SLJIT_D_GREATER_EQUAL | SLJIT_SINGLE_OP)
end_define
begin_define
DECL|macro|SLJIT_D_GREATER
define|#
directive|define
name|SLJIT_D_GREATER
value|18
end_define
begin_define
DECL|macro|SLJIT_S_GREATER
define|#
directive|define
name|SLJIT_S_GREATER
value|(SLJIT_D_GREATER | SLJIT_SINGLE_OP)
end_define
begin_define
DECL|macro|SLJIT_D_LESS_EQUAL
define|#
directive|define
name|SLJIT_D_LESS_EQUAL
value|19
end_define
begin_define
DECL|macro|SLJIT_S_LESS_EQUAL
define|#
directive|define
name|SLJIT_S_LESS_EQUAL
value|(SLJIT_D_LESS_EQUAL | SLJIT_SINGLE_OP)
end_define
begin_define
DECL|macro|SLJIT_D_UNORDERED
define|#
directive|define
name|SLJIT_D_UNORDERED
value|20
end_define
begin_define
DECL|macro|SLJIT_S_UNORDERED
define|#
directive|define
name|SLJIT_S_UNORDERED
value|(SLJIT_D_UNORDERED | SLJIT_SINGLE_OP)
end_define
begin_define
DECL|macro|SLJIT_D_ORDERED
define|#
directive|define
name|SLJIT_D_ORDERED
value|21
end_define
begin_define
DECL|macro|SLJIT_S_ORDERED
define|#
directive|define
name|SLJIT_S_ORDERED
value|(SLJIT_D_ORDERED | SLJIT_SINGLE_OP)
end_define
begin_comment
comment|/* Unconditional jump types. */
end_comment
begin_define
DECL|macro|SLJIT_JUMP
define|#
directive|define
name|SLJIT_JUMP
value|22
end_define
begin_define
DECL|macro|SLJIT_FAST_CALL
define|#
directive|define
name|SLJIT_FAST_CALL
value|23
end_define
begin_define
DECL|macro|SLJIT_CALL0
define|#
directive|define
name|SLJIT_CALL0
value|24
end_define
begin_define
DECL|macro|SLJIT_CALL1
define|#
directive|define
name|SLJIT_CALL1
value|25
end_define
begin_define
DECL|macro|SLJIT_CALL2
define|#
directive|define
name|SLJIT_CALL2
value|26
end_define
begin_define
DECL|macro|SLJIT_CALL3
define|#
directive|define
name|SLJIT_CALL3
value|27
end_define
begin_comment
comment|/* Fast calling method. See sljit_emit_fast_enter / sljit_emit_fast_return. */
end_comment
begin_comment
comment|/* The target can be changed during runtime (see: sljit_set_jump_addr). */
end_comment
begin_define
DECL|macro|SLJIT_REWRITABLE_JUMP
define|#
directive|define
name|SLJIT_REWRITABLE_JUMP
value|0x1000
end_define
begin_comment
comment|/* Emit a jump instruction. The destination is not set, only the type of the jump.     type must be between SLJIT_EQUAL and SLJIT_CALL3     type can be combined (or'ed) with SLJIT_REWRITABLE_JUMP    Flags: - (never set any flags) for both conditional and unconditional jumps.    Flags: destroy all flags for calls. */
end_comment
begin_function_decl
name|SLJIT_API_FUNC_ATTRIBUTE
name|struct
name|sljit_jump
modifier|*
name|sljit_emit_jump
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|type
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/* Basic arithmetic comparison. In most architectures it is implemented as    an SLJIT_SUB operation (with SLJIT_UNUSED destination and setting    appropriate flags) followed by a sljit_emit_jump. However some    architectures (i.e: ARM64 or MIPS) may employ special optimizations here.    It is suggested to use this comparison form when appropriate.     type must be between SLJIT_EQUAL and SLJIT_I_SIG_LESS_EQUAL     type can be combined (or'ed) with SLJIT_REWRITABLE_JUMP    Flags: destroy flags. */
end_comment
begin_function_decl
name|SLJIT_API_FUNC_ATTRIBUTE
name|struct
name|sljit_jump
modifier|*
name|sljit_emit_cmp
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|type
parameter_list|,
name|sljit_si
name|src1
parameter_list|,
name|sljit_sw
name|src1w
parameter_list|,
name|sljit_si
name|src2
parameter_list|,
name|sljit_sw
name|src2w
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/* Basic floating point comparison. In most architectures it is implemented as    an SLJIT_FCMP operation (setting appropriate flags) followed by a    sljit_emit_jump. However some architectures (i.e: MIPS) may employ    special optimizations here. It is suggested to use this comparison form    when appropriate.     type must be between SLJIT_D_EQUAL and SLJIT_S_ORDERED     type can be combined (or'ed) with SLJIT_REWRITABLE_JUMP    Flags: destroy flags.    Note: if either operand is NaN, the behaviour is undefined for          types up to SLJIT_S_LESS_EQUAL. */
end_comment
begin_function_decl
name|SLJIT_API_FUNC_ATTRIBUTE
name|struct
name|sljit_jump
modifier|*
name|sljit_emit_fcmp
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|type
parameter_list|,
name|sljit_si
name|src1
parameter_list|,
name|sljit_sw
name|src1w
parameter_list|,
name|sljit_si
name|src2
parameter_list|,
name|sljit_sw
name|src2w
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/* Set the destination of the jump to this label. */
end_comment
begin_function_decl
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
name|sljit_set_label
parameter_list|(
name|struct
name|sljit_jump
modifier|*
name|jump
parameter_list|,
name|struct
name|sljit_label
modifier|*
name|label
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/* Set the destination address of the jump to this label. */
end_comment
begin_function_decl
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
name|sljit_set_target
parameter_list|(
name|struct
name|sljit_jump
modifier|*
name|jump
parameter_list|,
name|sljit_uw
name|target
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/* Call function or jump anywhere. Both direct and indirect form     type must be between SLJIT_JUMP and SLJIT_CALL3     Direct form: set src to SLJIT_IMM() and srcw to the address     Indirect form: any other valid addressing mode    Flags: - (never set any flags) for unconditional jumps.    Flags: destroy all flags for calls. */
end_comment
begin_function_decl
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_ijump
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|type
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/* Perform the operation using the conditional flags as the second argument.    Type must always be between SLJIT_EQUAL and SLJIT_S_ORDERED. The value    represented by the type is 1, if the condition represented by the type    is fulfilled, and 0 otherwise.     If op == SLJIT_MOV, SLJIT_MOV_SI, SLJIT_MOV_UI:      Set dst to the value represented by the type (0 or 1).      Src must be SLJIT_UNUSED, and srcw must be 0      Flags: - (never set any flags)    If op == SLJIT_OR, op == SLJIT_AND, op == SLJIT_XOR      Performs the binary operation using src as the first, and the value      represented by type as the second argument.      Important note: only dst=src and dstw=srcw is supported at the moment!      Flags: I | E | K    Note: sljit_emit_op_flags does nothing, if dst is SLJIT_UNUSED (regardless of op). */
end_comment
begin_function_decl
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_op_flags
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|,
name|sljit_si
name|type
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/* Copies the base address of SLJIT_SP + offset to dst.    Flags: - (never set any flags) */
end_comment
begin_function_decl
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_get_local_base
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_sw
name|offset
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/* The constant can be changed runtime (see: sljit_set_const)    Flags: - (never set any flags) */
end_comment
begin_function_decl
name|SLJIT_API_FUNC_ATTRIBUTE
name|struct
name|sljit_const
modifier|*
name|sljit_emit_const
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_sw
name|init_value
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/* After the code generation the address for label, jump and const instructions    are computed. Since these structures are freed by sljit_free_compiler, the    addresses must be preserved by the user program elsewere. */
end_comment
begin_function
DECL|function|sljit_get_label_addr
specifier|static
name|SLJIT_INLINE
name|sljit_uw
name|sljit_get_label_addr
parameter_list|(
name|struct
name|sljit_label
modifier|*
name|label
parameter_list|)
block|{
return|return
name|label
operator|->
name|addr
return|;
block|}
end_function
begin_function
DECL|function|sljit_get_jump_addr
specifier|static
name|SLJIT_INLINE
name|sljit_uw
name|sljit_get_jump_addr
parameter_list|(
name|struct
name|sljit_jump
modifier|*
name|jump
parameter_list|)
block|{
return|return
name|jump
operator|->
name|addr
return|;
block|}
end_function
begin_function
DECL|function|sljit_get_const_addr
specifier|static
name|SLJIT_INLINE
name|sljit_uw
name|sljit_get_const_addr
parameter_list|(
name|struct
name|sljit_const
modifier|*
name|const_
parameter_list|)
block|{
return|return
name|const_
operator|->
name|addr
return|;
block|}
end_function
begin_comment
comment|/* Only the address is required to rewrite the code. */
end_comment
begin_function_decl
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
name|sljit_set_jump_addr
parameter_list|(
name|sljit_uw
name|addr
parameter_list|,
name|sljit_uw
name|new_addr
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
name|sljit_set_const
parameter_list|(
name|sljit_uw
name|addr
parameter_list|,
name|sljit_sw
name|new_constant
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_comment
comment|/*  Miscellaneous utility functions                                      */
end_comment
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_define
DECL|macro|SLJIT_MAJOR_VERSION
define|#
directive|define
name|SLJIT_MAJOR_VERSION
value|0
end_define
begin_define
DECL|macro|SLJIT_MINOR_VERSION
define|#
directive|define
name|SLJIT_MINOR_VERSION
value|93
end_define
begin_comment
comment|/* Get the human readable name of the platform. Can be useful on platforms    like ARM, where ARM and Thumb2 functions can be mixed, and    it is useful to know the type of the code generator. */
end_comment
begin_function_decl
name|SLJIT_API_FUNC_ATTRIBUTE
name|SLJIT_CONST
name|char
modifier|*
name|sljit_get_platform_name
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/* Portable helper function to get an offset of a member. */
end_comment
begin_define
DECL|macro|SLJIT_OFFSETOF
define|#
directive|define
name|SLJIT_OFFSETOF
parameter_list|(
name|base
parameter_list|,
name|member
parameter_list|)
value|((sljit_sw)(&((base*)0x10)->member) - 0x10)
end_define
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_UTIL_GLOBAL_LOCK
operator|&&
name|SLJIT_UTIL_GLOBAL_LOCK
operator|)
end_if
begin_comment
comment|/* This global lock is useful to compile common functions. */
end_comment
begin_function_decl
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
name|SLJIT_CALL
name|sljit_grab_lock
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
name|SLJIT_CALL
name|sljit_release_lock
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_UTIL_STACK
operator|&&
name|SLJIT_UTIL_STACK
operator|)
end_if
begin_comment
comment|/* The sljit_stack is a utiliy feature of sljit, which allocates a    writable memory region between base (inclusive) and limit (exclusive).    Both base and limit is a pointer, and base is always<= than limit.    This feature uses the "address space reserve" feature    of modern operating systems. Basically we don't need to allocate a    huge memory block in one step for the worst case, we can start with    a smaller chunk and extend it later. Since the address space is    reserved, the data never copied to other regions, thus it is safe    to store pointers here. */
end_comment
begin_comment
comment|/* Note: The base field is aligned to PAGE_SIZE bytes (usually 4k or more).    Note: stack growing should not happen in small steps: 4k, 16k or even      bigger growth is better.    Note: this structure may not be supported by all operating systems.      Some kind of fallback mechanism is suggested when SLJIT_UTIL_STACK      is not defined. */
end_comment
begin_struct
DECL|struct|sljit_stack
struct|struct
name|sljit_stack
block|{
comment|/* User data, anything can be stored here. 	   Starting with the same value as base. */
DECL|member|top
name|sljit_uw
name|top
decl_stmt|;
comment|/* These members are read only. */
DECL|member|base
name|sljit_uw
name|base
decl_stmt|;
DECL|member|limit
name|sljit_uw
name|limit
decl_stmt|;
DECL|member|max_limit
name|sljit_uw
name|max_limit
decl_stmt|;
block|}
struct|;
end_struct
begin_comment
comment|/* Returns NULL if unsuccessful.    Note: limit and max_limit contains the size for stack allocation.    Note: the top field is initialized to base.    Note: see sljit_create_compiler for the explanation of allocator_data. */
end_comment
begin_function_decl
name|SLJIT_API_FUNC_ATTRIBUTE
name|struct
name|sljit_stack
modifier|*
name|SLJIT_CALL
name|sljit_allocate_stack
parameter_list|(
name|sljit_uw
name|limit
parameter_list|,
name|sljit_uw
name|max_limit
parameter_list|,
name|void
modifier|*
name|allocator_data
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
name|SLJIT_CALL
name|sljit_free_stack
parameter_list|(
name|struct
name|sljit_stack
modifier|*
name|stack
parameter_list|,
name|void
modifier|*
name|allocator_data
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/* Can be used to increase (allocate) or decrease (free) the memory area.    Returns with a non-zero value if unsuccessful. If new_limit is greater than    max_limit, it will fail. It is very easy to implement a stack data structure,    since the growth ratio can be added to the current limit, and sljit_stack_resize    will do all the necessary checks. The fields of the stack are not changed if    sljit_stack_resize fails. */
end_comment
begin_function_decl
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_sw
name|SLJIT_CALL
name|sljit_stack_resize
parameter_list|(
name|struct
name|sljit_stack
modifier|*
name|stack
parameter_list|,
name|sljit_uw
name|new_limit
parameter_list|)
function_decl|;
end_function_decl
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* (defined SLJIT_UTIL_STACK&& SLJIT_UTIL_STACK) */
end_comment
begin_if
if|#
directive|if
operator|!
operator|(
name|defined
name|SLJIT_INDIRECT_CALL
operator|&&
name|SLJIT_INDIRECT_CALL
operator|)
end_if
begin_comment
comment|/* Get the entry address of a given function. */
end_comment
begin_define
DECL|macro|SLJIT_FUNC_OFFSET
define|#
directive|define
name|SLJIT_FUNC_OFFSET
parameter_list|(
name|func_name
parameter_list|)
value|((sljit_sw)func_name)
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* !(defined SLJIT_INDIRECT_CALL&& SLJIT_INDIRECT_CALL) */
end_comment
begin_comment
comment|/* All JIT related code should be placed in the same context (library, binary, etc.). */
end_comment
begin_define
DECL|macro|SLJIT_FUNC_OFFSET
define|#
directive|define
name|SLJIT_FUNC_OFFSET
parameter_list|(
name|func_name
parameter_list|)
value|(*(sljit_sw*)(void*)func_name)
end_define
begin_comment
comment|/* For powerpc64, the function pointers point to a context descriptor. */
end_comment
begin_struct
DECL|struct|sljit_function_context
struct|struct
name|sljit_function_context
block|{
DECL|member|addr
name|sljit_sw
name|addr
decl_stmt|;
DECL|member|r2
name|sljit_sw
name|r2
decl_stmt|;
DECL|member|r11
name|sljit_sw
name|r11
decl_stmt|;
block|}
struct|;
end_struct
begin_comment
comment|/* Fill the context arguments using the addr and the function.    If func_ptr is NULL, it will not be set to the address of context    If addr is NULL, the function address also comes from the func pointer. */
end_comment
begin_function_decl
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
name|sljit_set_function_context
parameter_list|(
name|void
modifier|*
modifier|*
name|func_ptr
parameter_list|,
name|struct
name|sljit_function_context
modifier|*
name|context
parameter_list|,
name|sljit_sw
name|addr
parameter_list|,
name|void
modifier|*
name|func
parameter_list|)
function_decl|;
end_function_decl
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* !(defined SLJIT_INDIRECT_CALL&& SLJIT_INDIRECT_CALL) */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* _SLJIT_LIR_H_ */
end_comment
end_unit
