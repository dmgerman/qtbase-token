begin_unit
begin_comment
comment|/*  *    Stack-less Just-In-Time compiler  *  *    Copyright 2009-2012 Zoltan Herczeg (hzmester@freemail.hu). All rights reserved.  *  * Redistribution and use in source and binary forms, with or without modification, are  * permitted provided that the following conditions are met:  *  *   1. Redistributions of source code must retain the above copyright notice, this list of  *      conditions and the following disclaimer.  *  *   2. Redistributions in binary form must reproduce the above copyright notice, this list  *      of conditions and the following disclaimer in the documentation and/or other materials  *      provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER(S) AND CONTRIBUTORS ``AS IS'' AND ANY  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT  * SHALL THE COPYRIGHT HOLDER(S) OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED  * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR  * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|_SLJIT_LIR_H_
end_ifndef
begin_define
DECL|macro|_SLJIT_LIR_H_
define|#
directive|define
name|_SLJIT_LIR_H_
end_define
begin_comment
comment|/*    ------------------------------------------------------------------------     Stack-Less JIT compiler for multiple architectures (x86, ARM, PowerPC)    ------------------------------------------------------------------------     Short description     Advantages:       - The execution can be continued from any LIR instruction. In other         words, it is possible to jump to any label from anywhere, even from         a code fragment, which is compiled later, if both compiled code         shares the same context. See sljit_emit_enter for more details       - Supports self modifying code: target of (conditional) jump and call         instructions and some constant values can be dynamically modified         during runtime         - although it is not suggested to do it frequently         - can be used for inline caching: save an important value once           in the instruction stream         - since this feature limits the optimization possibilities, a           special flag must be passed at compile time when these           instructions are emitted       - A fixed stack space can be allocated for local variables       - The compiler is thread-safe       - The compiler is highly configurable through preprocessor macros.         You can disable unneeded features (multithreading in single         threaded applications), and you can use your own system functions         (including memory allocators). See sljitConfig.h     Disadvantages:       - No automatic register allocation, and temporary results are         not stored on the stack. (hence the name comes)       - Limited number of registers (only 6+4 integer registers, max 3+2         scratch, max 3+2 saved and 6 floating point registers)     In practice:       - This approach is very effective for interpreters         - One of the saved registers typically points to a stack interface         - It can jump to any exception handler anytime (even if it belongs           to another function)         - Hot paths can be modified during runtime reflecting the changes           of the fastest execution path of the dynamic language         - SLJIT supports complex memory addressing modes         - mainly position and context independent code (except some cases)      For valgrind users:       - pass --smc-check=all argument to valgrind, since JIT is a "self-modifying code" */
end_comment
begin_if
if|#
directive|if
operator|!
operator|(
name|defined
name|SLJIT_NO_DEFAULT_CONFIG
operator|&&
name|SLJIT_NO_DEFAULT_CONFIG
operator|)
end_if
begin_include
include|#
directive|include
file|"sljitConfig.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* The following header file defines useful macros for fine tuning sljit based code generators. They are listed in the begining of sljitConfigInternal.h */
end_comment
begin_include
include|#
directive|include
file|"sljitConfigInternal.h"
end_include
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_comment
comment|/*  Error codes                                                          */
end_comment
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_comment
comment|/* Indicates no error. */
end_comment
begin_define
DECL|macro|SLJIT_SUCCESS
define|#
directive|define
name|SLJIT_SUCCESS
value|0
end_define
begin_comment
comment|/* After the call of sljit_generate_code(), the error code of the compiler    is set to this value to avoid future sljit calls (in debug mode at least).    The complier should be freed after sljit_generate_code(). */
end_comment
begin_define
DECL|macro|SLJIT_ERR_COMPILED
define|#
directive|define
name|SLJIT_ERR_COMPILED
value|1
end_define
begin_comment
comment|/* Cannot allocate non executable memory. */
end_comment
begin_define
DECL|macro|SLJIT_ERR_ALLOC_FAILED
define|#
directive|define
name|SLJIT_ERR_ALLOC_FAILED
value|2
end_define
begin_comment
comment|/* Cannot allocate executable memory.    Only for sljit_generate_code() */
end_comment
begin_define
DECL|macro|SLJIT_ERR_EX_ALLOC_FAILED
define|#
directive|define
name|SLJIT_ERR_EX_ALLOC_FAILED
value|3
end_define
begin_comment
comment|/* return value for SLJIT_CONFIG_UNSUPPORTED empty architecture. */
end_comment
begin_define
DECL|macro|SLJIT_ERR_UNSUPPORTED
define|#
directive|define
name|SLJIT_ERR_UNSUPPORTED
value|4
end_define
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_comment
comment|/*  Registers                                                            */
end_comment
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_define
DECL|macro|SLJIT_UNUSED
define|#
directive|define
name|SLJIT_UNUSED
value|0
end_define
begin_comment
comment|/* Scratch (temporary) registers whose may not preserve their values    across function calls. */
end_comment
begin_define
DECL|macro|SLJIT_SCRATCH_REG1
define|#
directive|define
name|SLJIT_SCRATCH_REG1
value|1
end_define
begin_define
DECL|macro|SLJIT_SCRATCH_REG2
define|#
directive|define
name|SLJIT_SCRATCH_REG2
value|2
end_define
begin_define
DECL|macro|SLJIT_SCRATCH_REG3
define|#
directive|define
name|SLJIT_SCRATCH_REG3
value|3
end_define
begin_comment
comment|/* Note: extra registers cannot be used for memory addressing. */
end_comment
begin_comment
comment|/* Note: on x86-32, these registers are emulated (using stack    loads& stores). */
end_comment
begin_define
DECL|macro|SLJIT_TEMPORARY_EREG1
define|#
directive|define
name|SLJIT_TEMPORARY_EREG1
value|4
end_define
begin_define
DECL|macro|SLJIT_TEMPORARY_EREG2
define|#
directive|define
name|SLJIT_TEMPORARY_EREG2
value|5
end_define
begin_comment
comment|/* Saved registers whose preserve their values across function calls. */
end_comment
begin_define
DECL|macro|SLJIT_SAVED_REG1
define|#
directive|define
name|SLJIT_SAVED_REG1
value|6
end_define
begin_define
DECL|macro|SLJIT_SAVED_REG2
define|#
directive|define
name|SLJIT_SAVED_REG2
value|7
end_define
begin_define
DECL|macro|SLJIT_SAVED_REG3
define|#
directive|define
name|SLJIT_SAVED_REG3
value|8
end_define
begin_comment
comment|/* Note: extra registers cannot be used for memory addressing. */
end_comment
begin_comment
comment|/* Note: on x86-32, these registers are emulated (using stack    loads& stores). */
end_comment
begin_define
DECL|macro|SLJIT_SAVED_EREG1
define|#
directive|define
name|SLJIT_SAVED_EREG1
value|9
end_define
begin_define
DECL|macro|SLJIT_SAVED_EREG2
define|#
directive|define
name|SLJIT_SAVED_EREG2
value|10
end_define
begin_comment
comment|/* Read-only register (cannot be the destination of an operation).    Only SLJIT_MEM1(SLJIT_LOCALS_REG) addressing mode is allowed since    several ABIs has certain limitations about the stack layout. However    sljit_get_local_base() can be used to obtain the offset of a value    on the stack. */
end_comment
begin_define
DECL|macro|SLJIT_LOCALS_REG
define|#
directive|define
name|SLJIT_LOCALS_REG
value|11
end_define
begin_comment
comment|/* Number of registers. */
end_comment
begin_define
DECL|macro|SLJIT_NO_TMP_REGISTERS
define|#
directive|define
name|SLJIT_NO_TMP_REGISTERS
value|5
end_define
begin_define
DECL|macro|SLJIT_NO_GEN_REGISTERS
define|#
directive|define
name|SLJIT_NO_GEN_REGISTERS
value|5
end_define
begin_define
DECL|macro|SLJIT_NO_REGISTERS
define|#
directive|define
name|SLJIT_NO_REGISTERS
value|11
end_define
begin_comment
comment|/* Return with machine word. */
end_comment
begin_define
DECL|macro|SLJIT_RETURN_REG
define|#
directive|define
name|SLJIT_RETURN_REG
value|SLJIT_SCRATCH_REG1
end_define
begin_comment
comment|/* x86 prefers specific registers for special purposes. In case of shift    by register it supports only SLJIT_SCRATCH_REG3 for shift argument    (which is the src2 argument of sljit_emit_op2). If another register is    used, sljit must exchange data between registers which cause a minor    slowdown. Other architectures has no such limitation. */
end_comment
begin_define
DECL|macro|SLJIT_PREF_SHIFT_REG
define|#
directive|define
name|SLJIT_PREF_SHIFT_REG
value|SLJIT_SCRATCH_REG3
end_define
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_comment
comment|/*  Floating point registers                                             */
end_comment
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_comment
comment|/* Note: SLJIT_UNUSED as destination is not valid for floating point      operations, since they cannot be used for setting flags. */
end_comment
begin_comment
comment|/* Floating point operations are performed on double or    single precision values. */
end_comment
begin_define
DECL|macro|SLJIT_FLOAT_REG1
define|#
directive|define
name|SLJIT_FLOAT_REG1
value|1
end_define
begin_define
DECL|macro|SLJIT_FLOAT_REG2
define|#
directive|define
name|SLJIT_FLOAT_REG2
value|2
end_define
begin_define
DECL|macro|SLJIT_FLOAT_REG3
define|#
directive|define
name|SLJIT_FLOAT_REG3
value|3
end_define
begin_define
DECL|macro|SLJIT_FLOAT_REG4
define|#
directive|define
name|SLJIT_FLOAT_REG4
value|4
end_define
begin_define
DECL|macro|SLJIT_FLOAT_REG5
define|#
directive|define
name|SLJIT_FLOAT_REG5
value|5
end_define
begin_define
DECL|macro|SLJIT_FLOAT_REG6
define|#
directive|define
name|SLJIT_FLOAT_REG6
value|6
end_define
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_comment
comment|/*  Main structures and functions                                        */
end_comment
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_struct
DECL|struct|sljit_memory_fragment
struct|struct
name|sljit_memory_fragment
block|{
DECL|member|next
name|struct
name|sljit_memory_fragment
modifier|*
name|next
decl_stmt|;
DECL|member|used_size
name|sljit_uw
name|used_size
decl_stmt|;
comment|/* Must be aligned to sljit_sw. */
DECL|member|memory
name|sljit_ub
name|memory
index|[
literal|1
index|]
decl_stmt|;
block|}
struct|;
end_struct
begin_struct
DECL|struct|sljit_label
struct|struct
name|sljit_label
block|{
DECL|member|next
name|struct
name|sljit_label
modifier|*
name|next
decl_stmt|;
DECL|member|addr
name|sljit_uw
name|addr
decl_stmt|;
comment|/* The maximum size difference. */
DECL|member|size
name|sljit_uw
name|size
decl_stmt|;
block|}
struct|;
end_struct
begin_struct
DECL|struct|sljit_jump
struct|struct
name|sljit_jump
block|{
DECL|member|next
name|struct
name|sljit_jump
modifier|*
name|next
decl_stmt|;
DECL|member|addr
name|sljit_uw
name|addr
decl_stmt|;
DECL|member|flags
name|sljit_sw
name|flags
decl_stmt|;
union|union
block|{
DECL|member|target
name|sljit_uw
name|target
decl_stmt|;
DECL|member|label
name|struct
name|sljit_label
modifier|*
name|label
decl_stmt|;
block|}
DECL|member|u
name|u
union|;
block|}
struct|;
end_struct
begin_struct
DECL|struct|sljit_const
struct|struct
name|sljit_const
block|{
DECL|member|next
name|struct
name|sljit_const
modifier|*
name|next
decl_stmt|;
DECL|member|addr
name|sljit_uw
name|addr
decl_stmt|;
block|}
struct|;
end_struct
begin_struct
DECL|struct|sljit_compiler
struct|struct
name|sljit_compiler
block|{
DECL|member|error
name|sljit_si
name|error
decl_stmt|;
DECL|member|labels
name|struct
name|sljit_label
modifier|*
name|labels
decl_stmt|;
DECL|member|jumps
name|struct
name|sljit_jump
modifier|*
name|jumps
decl_stmt|;
DECL|member|consts
name|struct
name|sljit_const
modifier|*
name|consts
decl_stmt|;
DECL|member|last_label
name|struct
name|sljit_label
modifier|*
name|last_label
decl_stmt|;
DECL|member|last_jump
name|struct
name|sljit_jump
modifier|*
name|last_jump
decl_stmt|;
DECL|member|last_const
name|struct
name|sljit_const
modifier|*
name|last_const
decl_stmt|;
DECL|member|buf
name|struct
name|sljit_memory_fragment
modifier|*
name|buf
decl_stmt|;
DECL|member|abuf
name|struct
name|sljit_memory_fragment
modifier|*
name|abuf
decl_stmt|;
comment|/* Used local registers. */
DECL|member|scratches
name|sljit_si
name|scratches
decl_stmt|;
comment|/* Used saved registers. */
DECL|member|saveds
name|sljit_si
name|saveds
decl_stmt|;
comment|/* Local stack size. */
DECL|member|local_size
name|sljit_si
name|local_size
decl_stmt|;
comment|/* Code size. */
DECL|member|size
name|sljit_uw
name|size
decl_stmt|;
comment|/* For statistical purposes. */
DECL|member|executable_size
name|sljit_uw
name|executable_size
decl_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_32
operator|&&
name|SLJIT_CONFIG_X86_32
operator|)
DECL|member|args
name|sljit_si
name|args
decl_stmt|;
DECL|member|locals_offset
name|sljit_si
name|locals_offset
decl_stmt|;
DECL|member|scratches_start
name|sljit_si
name|scratches_start
decl_stmt|;
DECL|member|saveds_start
name|sljit_si
name|saveds_start
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
DECL|member|mode32
name|sljit_si
name|mode32
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_X86_32
operator|&&
name|SLJIT_CONFIG_X86_32
operator|)
operator|||
operator|(
name|defined
name|SLJIT_CONFIG_X86_64
operator|&&
name|SLJIT_CONFIG_X86_64
operator|)
DECL|member|flags_saved
name|sljit_si
name|flags_saved
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_ARM_V5
operator|&&
name|SLJIT_CONFIG_ARM_V5
operator|)
comment|/* Constant pool handling. */
DECL|member|cpool
name|sljit_uw
modifier|*
name|cpool
decl_stmt|;
DECL|member|cpool_unique
name|sljit_ub
modifier|*
name|cpool_unique
decl_stmt|;
DECL|member|cpool_diff
name|sljit_uw
name|cpool_diff
decl_stmt|;
DECL|member|cpool_fill
name|sljit_uw
name|cpool_fill
decl_stmt|;
comment|/* Other members. */
comment|/* Contains pointer, "ldr pc, [...]" pairs. */
DECL|member|patches
name|sljit_uw
name|patches
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_ARM_V5
operator|&&
name|SLJIT_CONFIG_ARM_V5
operator|)
operator|||
operator|(
name|defined
name|SLJIT_CONFIG_ARM_V7
operator|&&
name|SLJIT_CONFIG_ARM_V7
operator|)
comment|/* Temporary fields. */
DECL|member|shift_imm
name|sljit_uw
name|shift_imm
decl_stmt|;
DECL|member|cache_arg
name|sljit_si
name|cache_arg
decl_stmt|;
DECL|member|cache_argw
name|sljit_sw
name|cache_argw
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_ARM_THUMB2
operator|&&
name|SLJIT_CONFIG_ARM_THUMB2
operator|)
DECL|member|cache_arg
name|sljit_si
name|cache_arg
decl_stmt|;
DECL|member|cache_argw
name|sljit_sw
name|cache_argw
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_PPC_32
operator|&&
name|SLJIT_CONFIG_PPC_32
operator|)
operator|||
operator|(
name|defined
name|SLJIT_CONFIG_PPC_64
operator|&&
name|SLJIT_CONFIG_PPC_64
operator|)
DECL|member|imm
name|sljit_sw
name|imm
decl_stmt|;
DECL|member|cache_arg
name|sljit_si
name|cache_arg
decl_stmt|;
DECL|member|cache_argw
name|sljit_sw
name|cache_argw
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_MIPS_32
operator|&&
name|SLJIT_CONFIG_MIPS_32
operator|)
DECL|member|delay_slot
name|sljit_si
name|delay_slot
decl_stmt|;
DECL|member|cache_arg
name|sljit_si
name|cache_arg
decl_stmt|;
DECL|member|cache_argw
name|sljit_sw
name|cache_argw
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_SPARC_32
operator|&&
name|SLJIT_CONFIG_SPARC_32
operator|)
DECL|member|delay_slot
name|sljit_si
name|delay_slot
decl_stmt|;
DECL|member|cache_arg
name|sljit_si
name|cache_arg
decl_stmt|;
DECL|member|cache_argw
name|sljit_sw
name|cache_argw
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
name|SLJIT_VERBOSE
operator|&&
name|SLJIT_VERBOSE
operator|)
DECL|member|verbose
name|FILE
modifier|*
name|verbose
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
name|SLJIT_DEBUG
operator|&&
name|SLJIT_DEBUG
operator|)
comment|/* Local size passed to the functions. */
DECL|member|logical_local_size
name|sljit_si
name|logical_local_size
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
name|SLJIT_VERBOSE
operator|&&
name|SLJIT_VERBOSE
operator|)
operator|||
operator|(
name|defined
name|SLJIT_DEBUG
operator|&&
name|SLJIT_DEBUG
operator|)
DECL|member|skip_checks
name|sljit_si
name|skip_checks
decl_stmt|;
endif|#
directive|endif
block|}
struct|;
end_struct
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_comment
comment|/*  Main functions                                                       */
end_comment
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_comment
comment|/* Creates an sljit compiler.    Returns NULL if failed. */
end_comment
begin_function_decl
name|SLJIT_API_FUNC_ATTRIBUTE
name|struct
name|sljit_compiler
modifier|*
name|sljit_create_compiler
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/* Free everything except the compiled machine code. */
end_comment
begin_function_decl
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
name|sljit_free_compiler
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/* Returns the current error code. If an error is occured, future sljit    calls which uses the same compiler argument returns early with the same    error code. Thus there is no need for checking the error after every    call, it is enough to do it before the code is compiled. Removing    these checks increases the performance of the compiling process. */
end_comment
begin_function
DECL|function|sljit_get_compiler_error
specifier|static
name|SLJIT_INLINE
name|sljit_si
name|sljit_get_compiler_error
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|)
block|{
return|return
name|compiler
operator|->
name|error
return|;
block|}
end_function
begin_comment
comment|/*    Allocate a small amount of memory. The size must be<= 64 bytes on 32 bit,    and<= 128 bytes on 64 bit architectures. The memory area is owned by the    compiler, and freed by sljit_free_compiler. The returned pointer is    sizeof(sljit_sw) aligned. Excellent for allocating small blocks during    the compiling, and no need to worry about freeing them. The size is    enough to contain at most 16 pointers. If the size is outside of the range,    the function will return with NULL. However, this return value does not    indicate that there is no more memory (does not set the current error code    of the compiler to out-of-memory status). */
end_comment
begin_function_decl
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
modifier|*
name|sljit_alloc_memory
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|size
parameter_list|)
function_decl|;
end_function_decl
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_VERBOSE
operator|&&
name|SLJIT_VERBOSE
operator|)
end_if
begin_comment
comment|/* Passing NULL disables verbose. */
end_comment
begin_function_decl
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
name|sljit_compiler_verbose
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|FILE
modifier|*
name|verbose
parameter_list|)
function_decl|;
end_function_decl
begin_endif
endif|#
directive|endif
end_endif
begin_function_decl
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
modifier|*
name|sljit_generate_code
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
name|sljit_free_code
parameter_list|(
name|void
modifier|*
name|code
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/*    After the machine code generation is finished we can retrieve the allocated    executable memory size, although this area may not be fully filled with    instructions depending on some optimizations. This function is useful only    for statistical purposes.     Before a successful code generation, this function returns with 0. */
end_comment
begin_function
DECL|function|sljit_get_generated_code_size
specifier|static
name|SLJIT_INLINE
name|sljit_uw
name|sljit_get_generated_code_size
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|)
block|{
return|return
name|compiler
operator|->
name|executable_size
return|;
block|}
end_function
begin_comment
comment|/* Instruction generation. Returns with any error code. If there is no    error, they return with SLJIT_SUCCESS. */
end_comment
begin_comment
comment|/*    The executable code is basically a function call from the viewpoint of    the C language. The function calls must obey to the ABI (Application    Binary Interface) of the platform, which specify the purpose of machine    registers and stack handling among other things. The sljit_emit_enter    function emits the necessary instructions for setting up a new context    for the executable code and moves function arguments to the saved    registers. The number of arguments are specified in the "args"    parameter and the first argument goes to SLJIT_SAVED_REG1, the second    goes to SLJIT_SAVED_REG2 and so on. The number of scratch and    saved registers are passed in "scratches" and "saveds" arguments    respectively. Since the saved registers contains the arguments,    "args" must be less or equal than "saveds". The sljit_emit_enter    is also capable of allocating a stack space for local variables. The    "local_size" argument contains the size in bytes of this local area    and its staring address is stored in SLJIT_LOCALS_REG. However    the SLJIT_LOCALS_REG is not necessary the machine stack pointer.    The memory bytes between SLJIT_LOCALS_REG (inclusive) and    SLJIT_LOCALS_REG + local_size (exclusive) can be modified freely    until the function returns. The stack space is uninitialized.     Note: every call of sljit_emit_enter and sljit_set_context          overwrites the previous context. */
end_comment
begin_define
DECL|macro|SLJIT_MAX_LOCAL_SIZE
define|#
directive|define
name|SLJIT_MAX_LOCAL_SIZE
value|65536
end_define
begin_function_decl
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_enter
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|args
parameter_list|,
name|sljit_si
name|scratches
parameter_list|,
name|sljit_si
name|saveds
parameter_list|,
name|sljit_si
name|local_size
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/* The machine code has a context (which contains the local stack space size,    number of used registers, etc.) which initialized by sljit_emit_enter. Several    functions (like sljit_emit_return) requres this context to be able to generate    the appropriate code. However, some code fragments (like inline cache) may have    no normal entry point so their context is unknown for the compiler. Using the    function below we can specify their context.     Note: every call of sljit_emit_enter and sljit_set_context overwrites          the previous context. */
end_comment
begin_function_decl
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
name|sljit_set_context
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|args
parameter_list|,
name|sljit_si
name|scratches
parameter_list|,
name|sljit_si
name|saveds
parameter_list|,
name|sljit_si
name|local_size
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/* Return from machine code.  The op argument can be SLJIT_UNUSED which means the    function does not return with anything or any opcode between SLJIT_MOV and    SLJIT_MOV_P (see sljit_emit_op1). As for src and srcw they must be 0 if op    is SLJIT_UNUSED, otherwise see below the description about source and    destination arguments. */
end_comment
begin_function_decl
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_return
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/* Fast calling mechanism for utility functions (see SLJIT_FAST_CALL). All registers and    even the stack frame is passed to the callee. The return address is preserved in    dst/dstw by sljit_emit_fast_enter (the type of the value stored by this function    is sljit_p), and sljit_emit_fast_return can use this as a return value later. */
end_comment
begin_comment
comment|/* Note: only for sljit specific, non ABI compilant calls. Fast, since only a few machine    instructions are needed. Excellent for small uility functions, where saving registers    and setting up a new stack frame would cost too much performance. However, it is still    possible to return to the address of the caller (or anywhere else). */
end_comment
begin_comment
comment|/* Note: flags are not changed (unlike sljit_emit_enter / sljit_emit_return). */
end_comment
begin_comment
comment|/* Note: although sljit_emit_fast_return could be replaced by an ijump, it is not suggested,    since many architectures do clever branch prediction on call / return instruction pairs. */
end_comment
begin_function_decl
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_fast_enter
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_fast_return
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/*    Source and destination values for arithmetical instructions     imm              - a simple immediate value (cannot be used as a destination)     reg              - any of the registers (immediate argument must be 0)     [imm]            - absolute immediate memory address     [reg+imm]        - indirect memory address     [reg+(reg<<imm)] - indirect indexed memory address (shift must be between 0 and 3)                        useful for (byte, half, int, sljit_sw) array access                        (fully supported by both x86 and ARM architectures, and cheap operation on others) */
end_comment
begin_comment
comment|/*    IMPORATNT NOTE: memory access MUST be naturally aligned except                    SLJIT_UNALIGNED macro is defined and its value is 1.       length | alignment    ---------+-----------      byte   | 1 byte (any physical_address is accepted)      half   | 2 byte (physical_address& 0x1 == 0)      int    | 4 byte (physical_address& 0x3 == 0)      word   | 4 byte if SLJIT_32BIT_ARCHITECTURE is defined and its value is 1             | 8 byte if SLJIT_64BIT_ARCHITECTURE is defined and its value is 1     pointer | size of sljit_p type (4 byte on 32 bit machines, 4 or 8 byte             | on 64 bit machines)     Note:   Different architectures have different addressing limitations.            A single instruction is enough for the following addressing            modes. Other adrressing modes are emulated by instruction            sequences. This information could help to improve those code            generators which focuses only a few architectures.     x86:    [reg+imm], -2^32+1<= imm<= 2^32-1 (full adress space on x86-32)            [reg+(reg<<imm)] is supported            [imm], -2^32+1<= imm<= 2^32-1 is supported            Write-back is not supported    arm:    [reg+imm], -4095<= imm<= 4095 or -255<= imm<= 255 for signed                 bytes, any halfs or floating point values)            [reg+(reg<<imm)] is supported            Write-back is supported    arm-t2: [reg+imm], -255<= imm<= 4095            [reg+(reg<<imm)] is supported            Write back is supported only for [reg+imm], where -255<= imm<= 255    ppc:    [reg+imm], -65536<= imm<= 65535. 64 bit loads/stores and 32 bit                 signed load on 64 bit requires immediates divisible by 4.                 [reg+imm] is not supported for signed 8 bit values.            [reg+reg] is supported            Write-back is supported except for one instruction: 32 bit signed                 load with [reg+imm] addressing mode on 64 bit.    mips:   [reg+imm], -65536<= imm<= 65535    sparc:  [reg+imm], -4096<= imm<= 4095            [reg+reg] is supported */
end_comment
begin_comment
comment|/* Register output: simply the name of the register.    For destination, you can use SLJIT_UNUSED as well. */
end_comment
begin_define
DECL|macro|SLJIT_MEM
define|#
directive|define
name|SLJIT_MEM
value|0x100
end_define
begin_define
DECL|macro|SLJIT_MEM0
define|#
directive|define
name|SLJIT_MEM0
parameter_list|()
value|(SLJIT_MEM)
end_define
begin_define
DECL|macro|SLJIT_MEM1
define|#
directive|define
name|SLJIT_MEM1
parameter_list|(
name|r1
parameter_list|)
value|(SLJIT_MEM | (r1))
end_define
begin_define
DECL|macro|SLJIT_MEM2
define|#
directive|define
name|SLJIT_MEM2
parameter_list|(
name|r1
parameter_list|,
name|r2
parameter_list|)
value|(SLJIT_MEM | (r1) | ((r2)<< 4))
end_define
begin_define
DECL|macro|SLJIT_IMM
define|#
directive|define
name|SLJIT_IMM
value|0x200
end_define
begin_comment
comment|/* Set 32 bit operation mode (I) on 64 bit CPUs. The flag is totally ignored on    32 bit CPUs. If this flag is set for an arithmetic operation, it uses only the    lower 32 bit of the input register(s), and set the CPU status flags according    to the 32 bit result. The higher 32 bits are undefined for both the input and    output. However, the CPU might not ignore those higher 32 bits, like MIPS, which    expects it to be the sign extension of the lower 32 bit. All 32 bit operations    are undefined, if this condition is not fulfilled. Therefore, when SLJIT_INT_OP    is specified, all register arguments must be the result of other operations with    the same SLJIT_INT_OP flag. In other words, although a register can hold either    a 64 or 32 bit value, these values cannot be mixed. The only exceptions are    SLJIT_IMOV and SLJIT_IMOVU (SLJIT_MOV_SI/SLJIT_MOV_UI/SLJIT_MOVU_SI/SLJIT_MOV_UI    with SLJIT_INT_OP flag) which can convert any source argument to SLJIT_INT_OP    compatible result. This conversion might be unnecessary on some CPUs like x86-64,    since the upper 32 bit is always ignored. In this case SLJIT is clever enough    to not generate any instructions if the source and destination operands are the    same registers. Affects sljit_emit_op0, sljit_emit_op1 and sljit_emit_op2. */
end_comment
begin_define
DECL|macro|SLJIT_INT_OP
define|#
directive|define
name|SLJIT_INT_OP
value|0x100
end_define
begin_comment
comment|/* Single precision mode (SP). This flag is similar to SLJIT_INT_OP, just    it applies to floating point registers (it is even the same bit). When    this flag is passed, the CPU performs single precision floating point    operations. Similar to SLJIT_INT_OP, all register arguments must be the    result of other floating point operations with this flag. Affects    sljit_emit_fop1, sljit_emit_fop2 and sljit_emit_fcmp. */
end_comment
begin_define
DECL|macro|SLJIT_SINGLE_OP
define|#
directive|define
name|SLJIT_SINGLE_OP
value|0x100
end_define
begin_comment
comment|/* Common CPU status flags for all architectures (x86, ARM, PPC)     - carry flag     - overflow flag     - zero flag     - negative/positive flag (depends on arc)    On mips, these flags are emulated by software. */
end_comment
begin_comment
comment|/* By default, the instructions may, or may not set the CPU status flags.    Forcing to set or keep status flags can be done with the following flags: */
end_comment
begin_comment
comment|/* Note: sljit tries to emit the minimum number of instructions. Using these    flags can increase them, so use them wisely to avoid unnecessary code generation. */
end_comment
begin_comment
comment|/* Set Equal (Zero) status flag (E). */
end_comment
begin_define
DECL|macro|SLJIT_SET_E
define|#
directive|define
name|SLJIT_SET_E
value|0x0200
end_define
begin_comment
comment|/* Set signed status flag (S). */
end_comment
begin_define
DECL|macro|SLJIT_SET_S
define|#
directive|define
name|SLJIT_SET_S
value|0x0400
end_define
begin_comment
comment|/* Set unsgined status flag (U). */
end_comment
begin_define
DECL|macro|SLJIT_SET_U
define|#
directive|define
name|SLJIT_SET_U
value|0x0800
end_define
begin_comment
comment|/* Set signed overflow flag (O). */
end_comment
begin_define
DECL|macro|SLJIT_SET_O
define|#
directive|define
name|SLJIT_SET_O
value|0x1000
end_define
begin_comment
comment|/* Set carry flag (C).    Note: Kinda unsigned overflow, but behaves differently on various cpus. */
end_comment
begin_define
DECL|macro|SLJIT_SET_C
define|#
directive|define
name|SLJIT_SET_C
value|0x2000
end_define
begin_comment
comment|/* Do not modify the flags (K).    Note: This flag cannot be combined with any other SLJIT_SET_* flag. */
end_comment
begin_define
DECL|macro|SLJIT_KEEP_FLAGS
define|#
directive|define
name|SLJIT_KEEP_FLAGS
value|0x4000
end_define
begin_comment
comment|/* Notes:      - you cannot postpone conditional jump instructions except if noted that        the instruction does not set flags (See: SLJIT_KEEP_FLAGS).      - flag combinations: '|' means 'logical or'. */
end_comment
begin_comment
comment|/* Flags: - (never set any flags)    Note: breakpoint instruction is not supported by all architectures (namely ppc)          It falls back to SLJIT_NOP in those cases. */
end_comment
begin_define
DECL|macro|SLJIT_BREAKPOINT
define|#
directive|define
name|SLJIT_BREAKPOINT
value|0
end_define
begin_comment
comment|/* Flags: - (never set any flags)    Note: may or may not cause an extra cycle wait          it can even decrease the runtime in a few cases. */
end_comment
begin_define
DECL|macro|SLJIT_NOP
define|#
directive|define
name|SLJIT_NOP
value|1
end_define
begin_comment
comment|/* Flags: - (may destroy flags)    Unsigned multiplication of SLJIT_SCRATCH_REG1 and SLJIT_SCRATCH_REG2.    Result goes to SLJIT_SCRATCH_REG2:SLJIT_SCRATCH_REG1 (high:low) word */
end_comment
begin_define
DECL|macro|SLJIT_UMUL
define|#
directive|define
name|SLJIT_UMUL
value|2
end_define
begin_comment
comment|/* Flags: - (may destroy flags)    Signed multiplication of SLJIT_SCRATCH_REG1 and SLJIT_SCRATCH_REG2.    Result goes to SLJIT_SCRATCH_REG2:SLJIT_SCRATCH_REG1 (high:low) word */
end_comment
begin_define
DECL|macro|SLJIT_SMUL
define|#
directive|define
name|SLJIT_SMUL
value|3
end_define
begin_comment
comment|/* Flags: I - (may destroy flags)    Unsigned divide of the value in SLJIT_SCRATCH_REG1 by the value in SLJIT_SCRATCH_REG2.    The result is placed in SLJIT_SCRATCH_REG1 and the remainder goes to SLJIT_SCRATCH_REG2.    Note: if SLJIT_SCRATCH_REG2 contains 0, the behaviour is undefined. */
end_comment
begin_define
DECL|macro|SLJIT_UDIV
define|#
directive|define
name|SLJIT_UDIV
value|4
end_define
begin_define
DECL|macro|SLJIT_IUDIV
define|#
directive|define
name|SLJIT_IUDIV
value|(SLJIT_UDIV | SLJIT_INT_OP)
end_define
begin_comment
comment|/* Flags: I - (may destroy flags)    Signed divide of the value in SLJIT_SCRATCH_REG1 by the value in SLJIT_SCRATCH_REG2.    The result is placed in SLJIT_SCRATCH_REG1 and the remainder goes to SLJIT_SCRATCH_REG2.    Note: if SLJIT_SCRATCH_REG2 contains 0, the behaviour is undefined. */
end_comment
begin_define
DECL|macro|SLJIT_SDIV
define|#
directive|define
name|SLJIT_SDIV
value|5
end_define
begin_define
DECL|macro|SLJIT_ISDIV
define|#
directive|define
name|SLJIT_ISDIV
value|(SLJIT_SDIV | SLJIT_INT_OP)
end_define
begin_function_decl
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_op0
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/* Notes for MOV instructions:    U = Mov with update (post form). If source or destination defined as SLJIT_MEM1(r1)        or SLJIT_MEM2(r1, r2), r1 is increased by the sum of r2 and the constant argument    UB = unsigned byte (8 bit)    SB = signed byte (8 bit)    UH = unsigned half (16 bit)    SH = signed half (16 bit)    UI = unsigned int (32 bit)    SI = signed int (32 bit)    P  = pointer (sljit_p) size */
end_comment
begin_comment
comment|/* Flags: - (never set any flags) */
end_comment
begin_define
DECL|macro|SLJIT_MOV
define|#
directive|define
name|SLJIT_MOV
value|6
end_define
begin_comment
comment|/* Flags: I - (never set any flags) */
end_comment
begin_define
DECL|macro|SLJIT_MOV_UB
define|#
directive|define
name|SLJIT_MOV_UB
value|7
end_define
begin_define
DECL|macro|SLJIT_IMOV_UB
define|#
directive|define
name|SLJIT_IMOV_UB
value|(SLJIT_MOV_UB | SLJIT_INT_OP)
end_define
begin_comment
comment|/* Flags: I - (never set any flags) */
end_comment
begin_define
DECL|macro|SLJIT_MOV_SB
define|#
directive|define
name|SLJIT_MOV_SB
value|8
end_define
begin_define
DECL|macro|SLJIT_IMOV_SB
define|#
directive|define
name|SLJIT_IMOV_SB
value|(SLJIT_MOV_SB | SLJIT_INT_OP)
end_define
begin_comment
comment|/* Flags: I - (never set any flags) */
end_comment
begin_define
DECL|macro|SLJIT_MOV_UH
define|#
directive|define
name|SLJIT_MOV_UH
value|9
end_define
begin_define
DECL|macro|SLJIT_IMOV_UH
define|#
directive|define
name|SLJIT_IMOV_UH
value|(SLJIT_MOV_UH | SLJIT_INT_OP)
end_define
begin_comment
comment|/* Flags: I - (never set any flags) */
end_comment
begin_define
DECL|macro|SLJIT_MOV_SH
define|#
directive|define
name|SLJIT_MOV_SH
value|10
end_define
begin_define
DECL|macro|SLJIT_IMOV_SH
define|#
directive|define
name|SLJIT_IMOV_SH
value|(SLJIT_MOV_SH | SLJIT_INT_OP)
end_define
begin_comment
comment|/* Flags: I - (never set any flags)    Note: see SLJIT_INT_OP for further details. */
end_comment
begin_define
DECL|macro|SLJIT_MOV_UI
define|#
directive|define
name|SLJIT_MOV_UI
value|11
end_define
begin_comment
comment|/* No SLJIT_INT_OP form, since it the same as SLJIT_IMOVU. */
end_comment
begin_comment
comment|/* Flags: I - (never set any flags)    Note: see SLJIT_INT_OP for further details. */
end_comment
begin_define
DECL|macro|SLJIT_MOV_SI
define|#
directive|define
name|SLJIT_MOV_SI
value|12
end_define
begin_define
DECL|macro|SLJIT_IMOV
define|#
directive|define
name|SLJIT_IMOV
value|(SLJIT_MOV_SI | SLJIT_INT_OP)
end_define
begin_comment
comment|/* Flags: - (never set any flags) */
end_comment
begin_define
DECL|macro|SLJIT_MOV_P
define|#
directive|define
name|SLJIT_MOV_P
value|13
end_define
begin_comment
comment|/* Flags: - (never set any flags) */
end_comment
begin_define
DECL|macro|SLJIT_MOVU
define|#
directive|define
name|SLJIT_MOVU
value|14
end_define
begin_comment
comment|/* Flags: I - (never set any flags) */
end_comment
begin_define
DECL|macro|SLJIT_MOVU_UB
define|#
directive|define
name|SLJIT_MOVU_UB
value|15
end_define
begin_define
DECL|macro|SLJIT_IMOVU_UB
define|#
directive|define
name|SLJIT_IMOVU_UB
value|(SLJIT_MOVU_UB | SLJIT_INT_OP)
end_define
begin_comment
comment|/* Flags: I - (never set any flags) */
end_comment
begin_define
DECL|macro|SLJIT_MOVU_SB
define|#
directive|define
name|SLJIT_MOVU_SB
value|16
end_define
begin_define
DECL|macro|SLJIT_IMOVU_SB
define|#
directive|define
name|SLJIT_IMOVU_SB
value|(SLJIT_MOVU_SB | SLJIT_INT_OP)
end_define
begin_comment
comment|/* Flags: I - (never set any flags) */
end_comment
begin_define
DECL|macro|SLJIT_MOVU_UH
define|#
directive|define
name|SLJIT_MOVU_UH
value|17
end_define
begin_define
DECL|macro|SLJIT_IMOVU_UH
define|#
directive|define
name|SLJIT_IMOVU_UH
value|(SLJIT_MOVU_UH | SLJIT_INT_OP)
end_define
begin_comment
comment|/* Flags: I - (never set any flags) */
end_comment
begin_define
DECL|macro|SLJIT_MOVU_SH
define|#
directive|define
name|SLJIT_MOVU_SH
value|18
end_define
begin_define
DECL|macro|SLJIT_IMOVU_SH
define|#
directive|define
name|SLJIT_IMOVU_SH
value|(SLJIT_MOVU_SH | SLJIT_INT_OP)
end_define
begin_comment
comment|/* Flags: I - (never set any flags)    Note: see SLJIT_INT_OP for further details. */
end_comment
begin_define
DECL|macro|SLJIT_MOVU_UI
define|#
directive|define
name|SLJIT_MOVU_UI
value|19
end_define
begin_comment
comment|/* No SLJIT_INT_OP form, since it the same as SLJIT_IMOVU. */
end_comment
begin_comment
comment|/* Flags: I - (never set any flags)    Note: see SLJIT_INT_OP for further details. */
end_comment
begin_define
DECL|macro|SLJIT_MOVU_SI
define|#
directive|define
name|SLJIT_MOVU_SI
value|20
end_define
begin_define
DECL|macro|SLJIT_IMOVU
define|#
directive|define
name|SLJIT_IMOVU
value|(SLJIT_MOVU_SI | SLJIT_INT_OP)
end_define
begin_comment
comment|/* Flags: - (never set any flags) */
end_comment
begin_define
DECL|macro|SLJIT_MOVU_P
define|#
directive|define
name|SLJIT_MOVU_P
value|21
end_define
begin_comment
comment|/* Flags: I | E | K */
end_comment
begin_define
DECL|macro|SLJIT_NOT
define|#
directive|define
name|SLJIT_NOT
value|22
end_define
begin_define
DECL|macro|SLJIT_INOT
define|#
directive|define
name|SLJIT_INOT
value|(SLJIT_NOT | SLJIT_INT_OP)
end_define
begin_comment
comment|/* Flags: I | E | O | K */
end_comment
begin_define
DECL|macro|SLJIT_NEG
define|#
directive|define
name|SLJIT_NEG
value|23
end_define
begin_define
DECL|macro|SLJIT_INEG
define|#
directive|define
name|SLJIT_INEG
value|(SLJIT_NEG | SLJIT_INT_OP)
end_define
begin_comment
comment|/* Count leading zeroes    Flags: I | E | K    Important note! Sparc 32 does not support K flag, since    the required popc instruction is introduced only in sparc 64. */
end_comment
begin_define
DECL|macro|SLJIT_CLZ
define|#
directive|define
name|SLJIT_CLZ
value|24
end_define
begin_define
DECL|macro|SLJIT_ICLZ
define|#
directive|define
name|SLJIT_ICLZ
value|(SLJIT_CLZ | SLJIT_INT_OP)
end_define
begin_function_decl
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_op1
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/* Flags: I | E | O | C | K */
end_comment
begin_define
DECL|macro|SLJIT_ADD
define|#
directive|define
name|SLJIT_ADD
value|25
end_define
begin_define
DECL|macro|SLJIT_IADD
define|#
directive|define
name|SLJIT_IADD
value|(SLJIT_ADD | SLJIT_INT_OP)
end_define
begin_comment
comment|/* Flags: I | C | K */
end_comment
begin_define
DECL|macro|SLJIT_ADDC
define|#
directive|define
name|SLJIT_ADDC
value|26
end_define
begin_define
DECL|macro|SLJIT_IADDC
define|#
directive|define
name|SLJIT_IADDC
value|(SLJIT_ADDC | SLJIT_INT_OP)
end_define
begin_comment
comment|/* Flags: I | E | S | U | O | C | K */
end_comment
begin_define
DECL|macro|SLJIT_SUB
define|#
directive|define
name|SLJIT_SUB
value|27
end_define
begin_define
DECL|macro|SLJIT_ISUB
define|#
directive|define
name|SLJIT_ISUB
value|(SLJIT_SUB | SLJIT_INT_OP)
end_define
begin_comment
comment|/* Flags: I | C | K */
end_comment
begin_define
DECL|macro|SLJIT_SUBC
define|#
directive|define
name|SLJIT_SUBC
value|28
end_define
begin_define
DECL|macro|SLJIT_ISUBC
define|#
directive|define
name|SLJIT_ISUBC
value|(SLJIT_SUBC | SLJIT_INT_OP)
end_define
begin_comment
comment|/* Note: integer mul    Flags: I | O (see SLJIT_C_MUL_*) | K */
end_comment
begin_define
DECL|macro|SLJIT_MUL
define|#
directive|define
name|SLJIT_MUL
value|29
end_define
begin_define
DECL|macro|SLJIT_IMUL
define|#
directive|define
name|SLJIT_IMUL
value|(SLJIT_MUL | SLJIT_INT_OP)
end_define
begin_comment
comment|/* Flags: I | E | K */
end_comment
begin_define
DECL|macro|SLJIT_AND
define|#
directive|define
name|SLJIT_AND
value|30
end_define
begin_define
DECL|macro|SLJIT_IAND
define|#
directive|define
name|SLJIT_IAND
value|(SLJIT_AND | SLJIT_INT_OP)
end_define
begin_comment
comment|/* Flags: I | E | K */
end_comment
begin_define
DECL|macro|SLJIT_OR
define|#
directive|define
name|SLJIT_OR
value|31
end_define
begin_define
DECL|macro|SLJIT_IOR
define|#
directive|define
name|SLJIT_IOR
value|(SLJIT_OR | SLJIT_INT_OP)
end_define
begin_comment
comment|/* Flags: I | E | K */
end_comment
begin_define
DECL|macro|SLJIT_XOR
define|#
directive|define
name|SLJIT_XOR
value|32
end_define
begin_define
DECL|macro|SLJIT_IXOR
define|#
directive|define
name|SLJIT_IXOR
value|(SLJIT_XOR | SLJIT_INT_OP)
end_define
begin_comment
comment|/* Flags: I | E | K    Let bit_length be the length of the shift operation: 32 or 64.    If src2 is immediate, src2w is masked by (bit_length - 1).    Otherwise, if the content of src2 is outside the range from 0    to bit_length - 1, the operation is undefined. */
end_comment
begin_define
DECL|macro|SLJIT_SHL
define|#
directive|define
name|SLJIT_SHL
value|33
end_define
begin_define
DECL|macro|SLJIT_ISHL
define|#
directive|define
name|SLJIT_ISHL
value|(SLJIT_SHL | SLJIT_INT_OP)
end_define
begin_comment
comment|/* Flags: I | E | K    Let bit_length be the length of the shift operation: 32 or 64.    If src2 is immediate, src2w is masked by (bit_length - 1).    Otherwise, if the content of src2 is outside the range from 0    to bit_length - 1, the operation is undefined. */
end_comment
begin_define
DECL|macro|SLJIT_LSHR
define|#
directive|define
name|SLJIT_LSHR
value|34
end_define
begin_define
DECL|macro|SLJIT_ILSHR
define|#
directive|define
name|SLJIT_ILSHR
value|(SLJIT_LSHR | SLJIT_INT_OP)
end_define
begin_comment
comment|/* Flags: I | E | K    Let bit_length be the length of the shift operation: 32 or 64.    If src2 is immediate, src2w is masked by (bit_length - 1).    Otherwise, if the content of src2 is outside the range from 0    to bit_length - 1, the operation is undefined. */
end_comment
begin_define
DECL|macro|SLJIT_ASHR
define|#
directive|define
name|SLJIT_ASHR
value|35
end_define
begin_define
DECL|macro|SLJIT_IASHR
define|#
directive|define
name|SLJIT_IASHR
value|(SLJIT_ASHR | SLJIT_INT_OP)
end_define
begin_function_decl
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_op2
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src1
parameter_list|,
name|sljit_sw
name|src1w
parameter_list|,
name|sljit_si
name|src2
parameter_list|,
name|sljit_sw
name|src2w
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/* The following function is a helper function for sljit_emit_op_custom.    It returns with the real machine register index of any SLJIT_SCRATCH    SLJIT_SAVED or SLJIT_LOCALS register.    Note: it returns with -1 for virtual registers (all EREGs on x86-32).    Note: register returned by SLJIT_LOCALS_REG is not necessary the real          stack pointer register of the target architecture. */
end_comment
begin_function_decl
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_get_register_index
parameter_list|(
name|sljit_si
name|reg
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/* Any instruction can be inserted into the instruction stream by    sljit_emit_op_custom. It has a similar purpose as inline assembly.    The size parameter must match to the instruction size of the target    architecture:           x86: 0< size<= 15. The instruction argument can be byte aligned.       Thumb2: if size == 2, the instruction argument must be 2 byte aligned.               if size == 4, the instruction argument must be 4 byte aligned.    Otherwise: size must be 4 and instruction argument must be 4 byte aligned. */
end_comment
begin_function_decl
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_op_custom
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|void
modifier|*
name|instruction
parameter_list|,
name|sljit_si
name|size
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/* Returns with non-zero if fpu is available. */
end_comment
begin_function_decl
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_is_fpu_available
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/* Note: dst is the left and src is the right operand for SLJIT_FCMP.    Note: NaN check is always performed. If SLJIT_C_FLOAT_UNORDERED is set,          the comparison result is unpredictable.    Flags: SP | E | S (see SLJIT_C_FLOAT_*) */
end_comment
begin_define
DECL|macro|SLJIT_CMPD
define|#
directive|define
name|SLJIT_CMPD
value|36
end_define
begin_define
DECL|macro|SLJIT_CMPS
define|#
directive|define
name|SLJIT_CMPS
value|(SLJIT_CMPD | SLJIT_SINGLE_OP)
end_define
begin_comment
comment|/* Flags: SP - (never set any flags) */
end_comment
begin_define
DECL|macro|SLJIT_MOVD
define|#
directive|define
name|SLJIT_MOVD
value|37
end_define
begin_define
DECL|macro|SLJIT_MOVS
define|#
directive|define
name|SLJIT_MOVS
value|(SLJIT_MOVD | SLJIT_SINGLE_OP)
end_define
begin_comment
comment|/* Flags: SP - (never set any flags) */
end_comment
begin_define
DECL|macro|SLJIT_NEGD
define|#
directive|define
name|SLJIT_NEGD
value|38
end_define
begin_define
DECL|macro|SLJIT_NEGS
define|#
directive|define
name|SLJIT_NEGS
value|(SLJIT_NEGD | SLJIT_SINGLE_OP)
end_define
begin_comment
comment|/* Flags: SP - (never set any flags) */
end_comment
begin_define
DECL|macro|SLJIT_ABSD
define|#
directive|define
name|SLJIT_ABSD
value|39
end_define
begin_define
DECL|macro|SLJIT_ABSS
define|#
directive|define
name|SLJIT_ABSS
value|(SLJIT_ABSD | SLJIT_SINGLE_OP)
end_define
begin_function_decl
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_fop1
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/* Flags: SP - (never set any flags) */
end_comment
begin_define
DECL|macro|SLJIT_ADDD
define|#
directive|define
name|SLJIT_ADDD
value|40
end_define
begin_define
DECL|macro|SLJIT_ADDS
define|#
directive|define
name|SLJIT_ADDS
value|(SLJIT_ADDD | SLJIT_SINGLE_OP)
end_define
begin_comment
comment|/* Flags: SP - (never set any flags) */
end_comment
begin_define
DECL|macro|SLJIT_SUBD
define|#
directive|define
name|SLJIT_SUBD
value|41
end_define
begin_define
DECL|macro|SLJIT_SUBS
define|#
directive|define
name|SLJIT_SUBS
value|(SLJIT_SUBD | SLJIT_SINGLE_OP)
end_define
begin_comment
comment|/* Flags: SP - (never set any flags) */
end_comment
begin_define
DECL|macro|SLJIT_MULD
define|#
directive|define
name|SLJIT_MULD
value|42
end_define
begin_define
DECL|macro|SLJIT_MULS
define|#
directive|define
name|SLJIT_MULS
value|(SLJIT_MULD | SLJIT_SINGLE_OP)
end_define
begin_comment
comment|/* Flags: SP - (never set any flags) */
end_comment
begin_define
DECL|macro|SLJIT_DIVD
define|#
directive|define
name|SLJIT_DIVD
value|43
end_define
begin_define
DECL|macro|SLJIT_DIVS
define|#
directive|define
name|SLJIT_DIVS
value|(SLJIT_DIVD | SLJIT_SINGLE_OP)
end_define
begin_function_decl
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_fop2
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src1
parameter_list|,
name|sljit_sw
name|src1w
parameter_list|,
name|sljit_si
name|src2
parameter_list|,
name|sljit_sw
name|src2w
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/* Label and jump instructions. */
end_comment
begin_function_decl
name|SLJIT_API_FUNC_ATTRIBUTE
name|struct
name|sljit_label
modifier|*
name|sljit_emit_label
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/* Invert conditional instruction: xor (^) with 0x1 */
end_comment
begin_define
DECL|macro|SLJIT_C_EQUAL
define|#
directive|define
name|SLJIT_C_EQUAL
value|0
end_define
begin_define
DECL|macro|SLJIT_C_ZERO
define|#
directive|define
name|SLJIT_C_ZERO
value|0
end_define
begin_define
DECL|macro|SLJIT_C_NOT_EQUAL
define|#
directive|define
name|SLJIT_C_NOT_EQUAL
value|1
end_define
begin_define
DECL|macro|SLJIT_C_NOT_ZERO
define|#
directive|define
name|SLJIT_C_NOT_ZERO
value|1
end_define
begin_define
DECL|macro|SLJIT_C_LESS
define|#
directive|define
name|SLJIT_C_LESS
value|2
end_define
begin_define
DECL|macro|SLJIT_C_GREATER_EQUAL
define|#
directive|define
name|SLJIT_C_GREATER_EQUAL
value|3
end_define
begin_define
DECL|macro|SLJIT_C_GREATER
define|#
directive|define
name|SLJIT_C_GREATER
value|4
end_define
begin_define
DECL|macro|SLJIT_C_LESS_EQUAL
define|#
directive|define
name|SLJIT_C_LESS_EQUAL
value|5
end_define
begin_define
DECL|macro|SLJIT_C_SIG_LESS
define|#
directive|define
name|SLJIT_C_SIG_LESS
value|6
end_define
begin_define
DECL|macro|SLJIT_C_SIG_GREATER_EQUAL
define|#
directive|define
name|SLJIT_C_SIG_GREATER_EQUAL
value|7
end_define
begin_define
DECL|macro|SLJIT_C_SIG_GREATER
define|#
directive|define
name|SLJIT_C_SIG_GREATER
value|8
end_define
begin_define
DECL|macro|SLJIT_C_SIG_LESS_EQUAL
define|#
directive|define
name|SLJIT_C_SIG_LESS_EQUAL
value|9
end_define
begin_define
DECL|macro|SLJIT_C_OVERFLOW
define|#
directive|define
name|SLJIT_C_OVERFLOW
value|10
end_define
begin_define
DECL|macro|SLJIT_C_NOT_OVERFLOW
define|#
directive|define
name|SLJIT_C_NOT_OVERFLOW
value|11
end_define
begin_define
DECL|macro|SLJIT_C_MUL_OVERFLOW
define|#
directive|define
name|SLJIT_C_MUL_OVERFLOW
value|12
end_define
begin_define
DECL|macro|SLJIT_C_MUL_NOT_OVERFLOW
define|#
directive|define
name|SLJIT_C_MUL_NOT_OVERFLOW
value|13
end_define
begin_define
DECL|macro|SLJIT_C_FLOAT_EQUAL
define|#
directive|define
name|SLJIT_C_FLOAT_EQUAL
value|14
end_define
begin_define
DECL|macro|SLJIT_C_FLOAT_NOT_EQUAL
define|#
directive|define
name|SLJIT_C_FLOAT_NOT_EQUAL
value|15
end_define
begin_define
DECL|macro|SLJIT_C_FLOAT_LESS
define|#
directive|define
name|SLJIT_C_FLOAT_LESS
value|16
end_define
begin_define
DECL|macro|SLJIT_C_FLOAT_GREATER_EQUAL
define|#
directive|define
name|SLJIT_C_FLOAT_GREATER_EQUAL
value|17
end_define
begin_define
DECL|macro|SLJIT_C_FLOAT_GREATER
define|#
directive|define
name|SLJIT_C_FLOAT_GREATER
value|18
end_define
begin_define
DECL|macro|SLJIT_C_FLOAT_LESS_EQUAL
define|#
directive|define
name|SLJIT_C_FLOAT_LESS_EQUAL
value|19
end_define
begin_define
DECL|macro|SLJIT_C_FLOAT_UNORDERED
define|#
directive|define
name|SLJIT_C_FLOAT_UNORDERED
value|20
end_define
begin_define
DECL|macro|SLJIT_C_FLOAT_ORDERED
define|#
directive|define
name|SLJIT_C_FLOAT_ORDERED
value|21
end_define
begin_define
DECL|macro|SLJIT_JUMP
define|#
directive|define
name|SLJIT_JUMP
value|22
end_define
begin_define
DECL|macro|SLJIT_FAST_CALL
define|#
directive|define
name|SLJIT_FAST_CALL
value|23
end_define
begin_define
DECL|macro|SLJIT_CALL0
define|#
directive|define
name|SLJIT_CALL0
value|24
end_define
begin_define
DECL|macro|SLJIT_CALL1
define|#
directive|define
name|SLJIT_CALL1
value|25
end_define
begin_define
DECL|macro|SLJIT_CALL2
define|#
directive|define
name|SLJIT_CALL2
value|26
end_define
begin_define
DECL|macro|SLJIT_CALL3
define|#
directive|define
name|SLJIT_CALL3
value|27
end_define
begin_comment
comment|/* Fast calling method. See sljit_emit_fast_enter / sljit_emit_fast_return. */
end_comment
begin_comment
comment|/* The target can be changed during runtime (see: sljit_set_jump_addr). */
end_comment
begin_define
DECL|macro|SLJIT_REWRITABLE_JUMP
define|#
directive|define
name|SLJIT_REWRITABLE_JUMP
value|0x1000
end_define
begin_comment
comment|/* Emit a jump instruction. The destination is not set, only the type of the jump.     type must be between SLJIT_C_EQUAL and SLJIT_CALL3     type can be combined (or'ed) with SLJIT_REWRITABLE_JUMP    Flags: - (never set any flags) for both conditional and unconditional jumps.    Flags: destroy all flags for calls. */
end_comment
begin_function_decl
name|SLJIT_API_FUNC_ATTRIBUTE
name|struct
name|sljit_jump
modifier|*
name|sljit_emit_jump
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|type
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/* Basic arithmetic comparison. In most architectures it is implemented as    an SLJIT_SUB operation (with SLJIT_UNUSED destination and setting    appropriate flags) followed by a sljit_emit_jump. However some    architectures (i.e: MIPS) may employ special optimizations here. It is    suggested to use this comparison form when appropriate.     type must be between SLJIT_C_EQUAL and SLJIT_C_SIG_LESS_EQUAL     type can be combined (or'ed) with SLJIT_REWRITABLE_JUMP or SLJIT_INT_OP    Flags: destroy flags. */
end_comment
begin_function_decl
name|SLJIT_API_FUNC_ATTRIBUTE
name|struct
name|sljit_jump
modifier|*
name|sljit_emit_cmp
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|type
parameter_list|,
name|sljit_si
name|src1
parameter_list|,
name|sljit_sw
name|src1w
parameter_list|,
name|sljit_si
name|src2
parameter_list|,
name|sljit_sw
name|src2w
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/* Basic floating point comparison. In most architectures it is implemented as    an SLJIT_FCMP operation (setting appropriate flags) followed by a    sljit_emit_jump. However some architectures (i.e: MIPS) may employ    special optimizations here. It is suggested to use this comparison form    when appropriate.     type must be between SLJIT_C_FLOAT_EQUAL and SLJIT_C_FLOAT_ORDERED     type can be combined (or'ed) with SLJIT_REWRITABLE_JUMP and SLJIT_SINGLE_OP    Flags: destroy flags.    Note: if either operand is NaN, the behaviour is undefined for          type<= SLJIT_C_FLOAT_LESS_EQUAL. */
end_comment
begin_function_decl
name|SLJIT_API_FUNC_ATTRIBUTE
name|struct
name|sljit_jump
modifier|*
name|sljit_emit_fcmp
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|type
parameter_list|,
name|sljit_si
name|src1
parameter_list|,
name|sljit_sw
name|src1w
parameter_list|,
name|sljit_si
name|src2
parameter_list|,
name|sljit_sw
name|src2w
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/* Set the destination of the jump to this label. */
end_comment
begin_function_decl
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
name|sljit_set_label
parameter_list|(
name|struct
name|sljit_jump
modifier|*
name|jump
parameter_list|,
name|struct
name|sljit_label
modifier|*
name|label
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/* Only for jumps defined with SLJIT_REWRITABLE_JUMP flag.    Note: use sljit_emit_ijump for fixed jumps. */
end_comment
begin_function_decl
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
name|sljit_set_target
parameter_list|(
name|struct
name|sljit_jump
modifier|*
name|jump
parameter_list|,
name|sljit_uw
name|target
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/* Call function or jump anywhere. Both direct and indirect form     type must be between SLJIT_JUMP and SLJIT_CALL3     Direct form: set src to SLJIT_IMM() and srcw to the address     Indirect form: any other valid addressing mode    Flags: - (never set any flags) for unconditional jumps.    Flags: destroy all flags for calls. */
end_comment
begin_function_decl
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_ijump
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|type
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/* Perform the operation using the conditional flags as the second argument.    Type must always be between SLJIT_C_EQUAL and SLJIT_C_FLOAT_ORDERED. The    value represented by the type is 1, if the condition represented by the type    is fulfilled, and 0 otherwise.     If op == SLJIT_MOV, SLJIT_MOV_SI, SLJIT_MOV_UI:      Set dst to the value represented by the type (0 or 1).      Src must be SLJIT_UNUSED, and srcw must be 0      Flags: - (never set any flags)    If op == SLJIT_OR, op == SLJIT_AND, op == SLJIT_XOR      Performs the binary operation using src as the first, and the value      represented by type as the second argument.      Important note: only dst=src and dstw=srcw is supported at the moment!      Flags: I | E | K    Note: sljit_emit_op_flags does nothing, if dst is SLJIT_UNUSED (regardless of op). */
end_comment
begin_function_decl
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_op_flags
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|,
name|sljit_si
name|type
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/* Copies the base address of SLJIT_LOCALS_REG+offset to dst.    Flags: - (never set any flags) */
end_comment
begin_function_decl
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_get_local_base
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_sw
name|offset
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/* The constant can be changed runtime (see: sljit_set_const)    Flags: - (never set any flags) */
end_comment
begin_function_decl
name|SLJIT_API_FUNC_ATTRIBUTE
name|struct
name|sljit_const
modifier|*
name|sljit_emit_const
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_sw
name|init_value
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/* After the code generation the address for label, jump and const instructions    are computed. Since these structures are freed by sljit_free_compiler, the    addresses must be preserved by the user program elsewere. */
end_comment
begin_function
DECL|function|sljit_get_label_addr
specifier|static
name|SLJIT_INLINE
name|sljit_uw
name|sljit_get_label_addr
parameter_list|(
name|struct
name|sljit_label
modifier|*
name|label
parameter_list|)
block|{
return|return
name|label
operator|->
name|addr
return|;
block|}
end_function
begin_function
DECL|function|sljit_get_jump_addr
specifier|static
name|SLJIT_INLINE
name|sljit_uw
name|sljit_get_jump_addr
parameter_list|(
name|struct
name|sljit_jump
modifier|*
name|jump
parameter_list|)
block|{
return|return
name|jump
operator|->
name|addr
return|;
block|}
end_function
begin_function
DECL|function|sljit_get_const_addr
specifier|static
name|SLJIT_INLINE
name|sljit_uw
name|sljit_get_const_addr
parameter_list|(
name|struct
name|sljit_const
modifier|*
name|const_
parameter_list|)
block|{
return|return
name|const_
operator|->
name|addr
return|;
block|}
end_function
begin_comment
comment|/* Only the address is required to rewrite the code. */
end_comment
begin_function_decl
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
name|sljit_set_jump_addr
parameter_list|(
name|sljit_uw
name|addr
parameter_list|,
name|sljit_uw
name|new_addr
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
name|sljit_set_const
parameter_list|(
name|sljit_uw
name|addr
parameter_list|,
name|sljit_sw
name|new_constant
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_comment
comment|/*  Miscellaneous utility functions                                      */
end_comment
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_define
DECL|macro|SLJIT_MAJOR_VERSION
define|#
directive|define
name|SLJIT_MAJOR_VERSION
value|0
end_define
begin_define
DECL|macro|SLJIT_MINOR_VERSION
define|#
directive|define
name|SLJIT_MINOR_VERSION
value|90
end_define
begin_comment
comment|/* Get the human readable name of the platform. Can be useful on platforms    like ARM, where ARM and Thumb2 functions can be mixed, and    it is useful to know the type of the code generator. */
end_comment
begin_function_decl
name|SLJIT_API_FUNC_ATTRIBUTE
name|SLJIT_CONST
name|char
modifier|*
name|sljit_get_platform_name
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/* Portable helper function to get an offset of a member. */
end_comment
begin_define
DECL|macro|SLJIT_OFFSETOF
define|#
directive|define
name|SLJIT_OFFSETOF
parameter_list|(
name|base
parameter_list|,
name|member
parameter_list|)
value|((sljit_sw)(&((base*)0x10)->member) - 0x10)
end_define
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_UTIL_GLOBAL_LOCK
operator|&&
name|SLJIT_UTIL_GLOBAL_LOCK
operator|)
end_if
begin_comment
comment|/* This global lock is useful to compile common functions. */
end_comment
begin_function_decl
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
name|SLJIT_CALL
name|sljit_grab_lock
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
name|SLJIT_CALL
name|sljit_release_lock
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_UTIL_STACK
operator|&&
name|SLJIT_UTIL_STACK
operator|)
end_if
begin_comment
comment|/* The sljit_stack is a utiliy feature of sljit, which allocates a    writable memory region between base (inclusive) and limit (exclusive).    Both base and limit is a pointer, and base is always<= than limit.    This feature uses the "address space reserve" feature    of modern operating systems. Basically we don't need to allocate a    huge memory block in one step for the worst case, we can start with    a smaller chunk and extend it later. Since the address space is    reserved, the data never copied to other regions, thus it is safe    to store pointers here. */
end_comment
begin_comment
comment|/* Note: The base field is aligned to PAGE_SIZE bytes (usually 4k or more).    Note: stack growing should not happen in small steps: 4k, 16k or even      bigger growth is better.    Note: this structure may not be supported by all operating systems.      Some kind of fallback mechanism is suggested when SLJIT_UTIL_STACK      is not defined. */
end_comment
begin_struct
DECL|struct|sljit_stack
struct|struct
name|sljit_stack
block|{
comment|/* User data, anything can be stored here. 	   Starting with the same value as base. */
DECL|member|top
name|sljit_uw
name|top
decl_stmt|;
comment|/* These members are read only. */
DECL|member|base
name|sljit_uw
name|base
decl_stmt|;
DECL|member|limit
name|sljit_uw
name|limit
decl_stmt|;
DECL|member|max_limit
name|sljit_uw
name|max_limit
decl_stmt|;
block|}
struct|;
end_struct
begin_comment
comment|/* Returns NULL if unsuccessful.    Note: limit and max_limit contains the size for stack allocation    Note: the top field is initialized to base. */
end_comment
begin_function_decl
name|SLJIT_API_FUNC_ATTRIBUTE
name|struct
name|sljit_stack
modifier|*
name|SLJIT_CALL
name|sljit_allocate_stack
parameter_list|(
name|sljit_uw
name|limit
parameter_list|,
name|sljit_uw
name|max_limit
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
name|SLJIT_CALL
name|sljit_free_stack
parameter_list|(
name|struct
name|sljit_stack
modifier|*
name|stack
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/* Can be used to increase (allocate) or decrease (free) the memory area.    Returns with a non-zero value if unsuccessful. If new_limit is greater than    max_limit, it will fail. It is very easy to implement a stack data structure,    since the growth ratio can be added to the current limit, and sljit_stack_resize    will do all the necessary checks. The fields of the stack are not changed if    sljit_stack_resize fails. */
end_comment
begin_function_decl
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_sw
name|SLJIT_CALL
name|sljit_stack_resize
parameter_list|(
name|struct
name|sljit_stack
modifier|*
name|stack
parameter_list|,
name|sljit_uw
name|new_limit
parameter_list|)
function_decl|;
end_function_decl
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* (defined SLJIT_UTIL_STACK&& SLJIT_UTIL_STACK) */
end_comment
begin_if
if|#
directive|if
operator|!
operator|(
name|defined
name|SLJIT_INDIRECT_CALL
operator|&&
name|SLJIT_INDIRECT_CALL
operator|)
end_if
begin_comment
comment|/* Get the entry address of a given function. */
end_comment
begin_define
DECL|macro|SLJIT_FUNC_OFFSET
define|#
directive|define
name|SLJIT_FUNC_OFFSET
parameter_list|(
name|func_name
parameter_list|)
value|((sljit_sw)func_name)
end_define
begin_else
else|#
directive|else
end_else
begin_comment
comment|/* !(defined SLJIT_INDIRECT_CALL&& SLJIT_INDIRECT_CALL) */
end_comment
begin_comment
comment|/* All JIT related code should be placed in the same context (library, binary, etc.). */
end_comment
begin_define
DECL|macro|SLJIT_FUNC_OFFSET
define|#
directive|define
name|SLJIT_FUNC_OFFSET
parameter_list|(
name|func_name
parameter_list|)
value|(*(sljit_sw*)(void*)func_name)
end_define
begin_comment
comment|/* For powerpc64, the function pointers point to a context descriptor. */
end_comment
begin_struct
DECL|struct|sljit_function_context
struct|struct
name|sljit_function_context
block|{
DECL|member|addr
name|sljit_sw
name|addr
decl_stmt|;
DECL|member|r2
name|sljit_sw
name|r2
decl_stmt|;
DECL|member|r11
name|sljit_sw
name|r11
decl_stmt|;
block|}
struct|;
end_struct
begin_comment
comment|/* Fill the context arguments using the addr and the function.    If func_ptr is NULL, it will not be set to the address of context    If addr is NULL, the function address also comes from the func pointer. */
end_comment
begin_function_decl
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
name|sljit_set_function_context
parameter_list|(
name|void
modifier|*
modifier|*
name|func_ptr
parameter_list|,
name|struct
name|sljit_function_context
modifier|*
name|context
parameter_list|,
name|sljit_sw
name|addr
parameter_list|,
name|void
modifier|*
name|func
parameter_list|)
function_decl|;
end_function_decl
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* !(defined SLJIT_INDIRECT_CALL&& SLJIT_INDIRECT_CALL) */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* _SLJIT_LIR_H_ */
end_comment
end_unit
