begin_unit
begin_comment
comment|/*  *    Stack-less Just-In-Time compiler  *  *    Copyright 2013-2013 Tilera Corporation(jiwang@tilera.com). All rights reserved.  *    Copyright 2009-2012 Zoltan Herczeg (hzmester@freemail.hu). All rights reserved.  *  * Redistribution and use in source and binary forms, with or without modification, are  * permitted provided that the following conditions are met:  *  *   1. Redistributions of source code must retain the above copyright notice, this list of  *      conditions and the following disclaimer.  *  *   2. Redistributions in binary form must reproduce the above copyright notice, this list  *      of conditions and the following disclaimer in the documentation and/or other materials  *      provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER(S) AND CONTRIBUTORS ``AS IS'' AND ANY  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT  * SHALL THE COPYRIGHT HOLDER(S) OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED  * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR  * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment
begin_comment
comment|/* TileGX architecture. */
end_comment
begin_comment
comment|/* Contributed by Tilera Corporation. */
end_comment
begin_include
include|#
directive|include
file|"sljitNativeTILEGX-encoder.c"
end_include
begin_define
DECL|macro|SIMM_8BIT_MAX
define|#
directive|define
name|SIMM_8BIT_MAX
value|(0x7f)
end_define
begin_define
DECL|macro|SIMM_8BIT_MIN
define|#
directive|define
name|SIMM_8BIT_MIN
value|(-0x80)
end_define
begin_define
DECL|macro|SIMM_16BIT_MAX
define|#
directive|define
name|SIMM_16BIT_MAX
value|(0x7fff)
end_define
begin_define
DECL|macro|SIMM_16BIT_MIN
define|#
directive|define
name|SIMM_16BIT_MIN
value|(-0x8000)
end_define
begin_define
DECL|macro|SIMM_17BIT_MAX
define|#
directive|define
name|SIMM_17BIT_MAX
value|(0xffff)
end_define
begin_define
DECL|macro|SIMM_17BIT_MIN
define|#
directive|define
name|SIMM_17BIT_MIN
value|(-0x10000)
end_define
begin_define
DECL|macro|SIMM_32BIT_MIN
define|#
directive|define
name|SIMM_32BIT_MIN
value|(-0x80000000)
end_define
begin_define
DECL|macro|SIMM_32BIT_MAX
define|#
directive|define
name|SIMM_32BIT_MAX
value|(0x7fffffff)
end_define
begin_define
DECL|macro|SIMM_48BIT_MIN
define|#
directive|define
name|SIMM_48BIT_MIN
value|(0x800000000000L)
end_define
begin_define
DECL|macro|SIMM_48BIT_MAX
define|#
directive|define
name|SIMM_48BIT_MAX
value|(0x7fffffff0000L)
end_define
begin_define
DECL|macro|IMM16
define|#
directive|define
name|IMM16
parameter_list|(
name|imm
parameter_list|)
value|((imm)& 0xffff)
end_define
begin_define
DECL|macro|UIMM_16BIT_MAX
define|#
directive|define
name|UIMM_16BIT_MAX
value|(0xffff)
end_define
begin_define
DECL|macro|TMP_REG1
define|#
directive|define
name|TMP_REG1
value|(SLJIT_NO_REGISTERS + 1)
end_define
begin_define
DECL|macro|TMP_REG2
define|#
directive|define
name|TMP_REG2
value|(SLJIT_NO_REGISTERS + 2)
end_define
begin_define
DECL|macro|TMP_REG3
define|#
directive|define
name|TMP_REG3
value|(SLJIT_NO_REGISTERS + 3)
end_define
begin_define
DECL|macro|ADDR_TMP
define|#
directive|define
name|ADDR_TMP
value|(SLJIT_NO_REGISTERS + 4)
end_define
begin_define
DECL|macro|PIC_ADDR_REG
define|#
directive|define
name|PIC_ADDR_REG
value|TMP_REG2
end_define
begin_decl_stmt
DECL|variable|reg_map
specifier|static
name|SLJIT_CONST
name|sljit_ub
name|reg_map
index|[
name|SLJIT_NO_REGISTERS
operator|+
literal|5
index|]
init|=
block|{
literal|63
block|,
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|30
block|,
literal|31
block|,
literal|32
block|,
literal|33
block|,
literal|34
block|,
literal|54
block|,
literal|5
block|,
literal|16
block|,
literal|6
block|,
literal|7
block|}
decl_stmt|;
end_decl_stmt
begin_define
DECL|macro|SLJIT_LOCALS_REG_mapped
define|#
directive|define
name|SLJIT_LOCALS_REG_mapped
value|54
end_define
begin_define
DECL|macro|TMP_REG1_mapped
define|#
directive|define
name|TMP_REG1_mapped
value|5
end_define
begin_define
DECL|macro|TMP_REG2_mapped
define|#
directive|define
name|TMP_REG2_mapped
value|16
end_define
begin_define
DECL|macro|TMP_REG3_mapped
define|#
directive|define
name|TMP_REG3_mapped
value|6
end_define
begin_define
DECL|macro|ADDR_TMP_mapped
define|#
directive|define
name|ADDR_TMP_mapped
value|7
end_define
begin_define
DECL|macro|SLJIT_SAVED_REG1_mapped
define|#
directive|define
name|SLJIT_SAVED_REG1_mapped
value|30
end_define
begin_define
DECL|macro|SLJIT_SAVED_REG2_mapped
define|#
directive|define
name|SLJIT_SAVED_REG2_mapped
value|31
end_define
begin_define
DECL|macro|SLJIT_SAVED_REG3_mapped
define|#
directive|define
name|SLJIT_SAVED_REG3_mapped
value|32
end_define
begin_define
DECL|macro|SLJIT_SAVED_EREG1_mapped
define|#
directive|define
name|SLJIT_SAVED_EREG1_mapped
value|33
end_define
begin_define
DECL|macro|SLJIT_SAVED_EREG2_mapped
define|#
directive|define
name|SLJIT_SAVED_EREG2_mapped
value|34
end_define
begin_comment
comment|/* Flags are keept in volatile registers. */
end_comment
begin_define
DECL|macro|EQUAL_FLAG
define|#
directive|define
name|EQUAL_FLAG
value|8
end_define
begin_comment
comment|/* And carry flag as well. */
end_comment
begin_define
DECL|macro|ULESS_FLAG
define|#
directive|define
name|ULESS_FLAG
value|9
end_define
begin_define
DECL|macro|UGREATER_FLAG
define|#
directive|define
name|UGREATER_FLAG
value|10
end_define
begin_define
DECL|macro|LESS_FLAG
define|#
directive|define
name|LESS_FLAG
value|11
end_define
begin_define
DECL|macro|GREATER_FLAG
define|#
directive|define
name|GREATER_FLAG
value|12
end_define
begin_define
DECL|macro|OVERFLOW_FLAG
define|#
directive|define
name|OVERFLOW_FLAG
value|13
end_define
begin_define
DECL|macro|ZERO
define|#
directive|define
name|ZERO
value|63
end_define
begin_define
DECL|macro|RA
define|#
directive|define
name|RA
value|55
end_define
begin_define
DECL|macro|TMP_EREG1
define|#
directive|define
name|TMP_EREG1
value|14
end_define
begin_define
DECL|macro|TMP_EREG2
define|#
directive|define
name|TMP_EREG2
value|15
end_define
begin_define
DECL|macro|LOAD_DATA
define|#
directive|define
name|LOAD_DATA
value|0x01
end_define
begin_define
DECL|macro|WORD_DATA
define|#
directive|define
name|WORD_DATA
value|0x00
end_define
begin_define
DECL|macro|BYTE_DATA
define|#
directive|define
name|BYTE_DATA
value|0x02
end_define
begin_define
DECL|macro|HALF_DATA
define|#
directive|define
name|HALF_DATA
value|0x04
end_define
begin_define
DECL|macro|INT_DATA
define|#
directive|define
name|INT_DATA
value|0x06
end_define
begin_define
DECL|macro|SIGNED_DATA
define|#
directive|define
name|SIGNED_DATA
value|0x08
end_define
begin_define
DECL|macro|DOUBLE_DATA
define|#
directive|define
name|DOUBLE_DATA
value|0x10
end_define
begin_comment
comment|/* Separates integer and floating point registers */
end_comment
begin_define
DECL|macro|GPR_REG
define|#
directive|define
name|GPR_REG
value|0xf
end_define
begin_define
DECL|macro|MEM_MASK
define|#
directive|define
name|MEM_MASK
value|0x1f
end_define
begin_define
DECL|macro|WRITE_BACK
define|#
directive|define
name|WRITE_BACK
value|0x00020
end_define
begin_define
DECL|macro|ARG_TEST
define|#
directive|define
name|ARG_TEST
value|0x00040
end_define
begin_define
DECL|macro|ALT_KEEP_CACHE
define|#
directive|define
name|ALT_KEEP_CACHE
value|0x00080
end_define
begin_define
DECL|macro|CUMULATIVE_OP
define|#
directive|define
name|CUMULATIVE_OP
value|0x00100
end_define
begin_define
DECL|macro|LOGICAL_OP
define|#
directive|define
name|LOGICAL_OP
value|0x00200
end_define
begin_define
DECL|macro|IMM_OP
define|#
directive|define
name|IMM_OP
value|0x00400
end_define
begin_define
DECL|macro|SRC2_IMM
define|#
directive|define
name|SRC2_IMM
value|0x00800
end_define
begin_define
DECL|macro|UNUSED_DEST
define|#
directive|define
name|UNUSED_DEST
value|0x01000
end_define
begin_define
DECL|macro|REG_DEST
define|#
directive|define
name|REG_DEST
value|0x02000
end_define
begin_define
DECL|macro|REG1_SOURCE
define|#
directive|define
name|REG1_SOURCE
value|0x04000
end_define
begin_define
DECL|macro|REG2_SOURCE
define|#
directive|define
name|REG2_SOURCE
value|0x08000
end_define
begin_define
DECL|macro|SLOW_SRC1
define|#
directive|define
name|SLOW_SRC1
value|0x10000
end_define
begin_define
DECL|macro|SLOW_SRC2
define|#
directive|define
name|SLOW_SRC2
value|0x20000
end_define
begin_define
DECL|macro|SLOW_DEST
define|#
directive|define
name|SLOW_DEST
value|0x40000
end_define
begin_comment
comment|/* Only these flags are set. UNUSED_DEST is not set when no flags should be set.  */
end_comment
begin_define
DECL|macro|CHECK_FLAGS
define|#
directive|define
name|CHECK_FLAGS
parameter_list|(
name|list
parameter_list|)
value|(!(flags& UNUSED_DEST) || (op& GET_FLAGS(~(list))))
end_define
begin_function
DECL|function|sljit_get_platform_name
name|SLJIT_API_FUNC_ATTRIBUTE
name|SLJIT_CONST
name|char
modifier|*
name|sljit_get_platform_name
parameter_list|(
name|void
parameter_list|)
block|{
return|return
literal|"TileGX"
name|SLJIT_CPUINFO
return|;
block|}
end_function
begin_comment
comment|/* Length of an instruction word */
end_comment
begin_typedef
DECL|typedef|sljit_ins
typedef|typedef
name|sljit_uw
name|sljit_ins
typedef|;
end_typedef
begin_struct
DECL|struct|jit_instr
struct|struct
name|jit_instr
block|{
DECL|member|opcode
specifier|const
name|struct
name|tilegx_opcode
modifier|*
name|opcode
decl_stmt|;
DECL|member|pipe
name|tilegx_pipeline
name|pipe
decl_stmt|;
DECL|member|input_registers
name|unsigned
name|long
name|input_registers
decl_stmt|;
DECL|member|output_registers
name|unsigned
name|long
name|output_registers
decl_stmt|;
DECL|member|operand_value
name|int
name|operand_value
index|[
literal|4
index|]
decl_stmt|;
DECL|member|line
name|int
name|line
decl_stmt|;
block|}
struct|;
end_struct
begin_comment
comment|/* Opcode Helper Macros */
end_comment
begin_define
DECL|macro|TILEGX_X_MODE
define|#
directive|define
name|TILEGX_X_MODE
value|0
end_define
begin_define
DECL|macro|X_MODE
define|#
directive|define
name|X_MODE
value|create_Mode(TILEGX_X_MODE)
end_define
begin_define
DECL|macro|FNOP_X0
define|#
directive|define
name|FNOP_X0
define|\
value|create_Opcode_X0(RRR_0_OPCODE_X0) | \ 	create_RRROpcodeExtension_X0(UNARY_RRR_0_OPCODE_X0) | \ 	create_UnaryOpcodeExtension_X0(FNOP_UNARY_OPCODE_X0)
end_define
begin_define
DECL|macro|FNOP_X1
define|#
directive|define
name|FNOP_X1
define|\
value|create_Opcode_X1(RRR_0_OPCODE_X1) | \ 	create_RRROpcodeExtension_X1(UNARY_RRR_0_OPCODE_X1) | \ 	create_UnaryOpcodeExtension_X1(FNOP_UNARY_OPCODE_X1)
end_define
begin_define
DECL|macro|NOP
define|#
directive|define
name|NOP
define|\
value|create_Mode(TILEGX_X_MODE) | FNOP_X0 | FNOP_X1
end_define
begin_define
DECL|macro|ANOP_X0
define|#
directive|define
name|ANOP_X0
define|\
value|create_Opcode_X0(RRR_0_OPCODE_X0) | \ 	create_RRROpcodeExtension_X0(UNARY_RRR_0_OPCODE_X0) | \ 	create_UnaryOpcodeExtension_X0(NOP_UNARY_OPCODE_X0)
end_define
begin_define
DECL|macro|BPT
define|#
directive|define
name|BPT
value|create_Mode(TILEGX_X_MODE) | create_Opcode_X1(RRR_0_OPCODE_X1) | \ 	create_RRROpcodeExtension_X1(UNARY_RRR_0_OPCODE_X1) | \ 	create_UnaryOpcodeExtension_X1(ILL_UNARY_OPCODE_X1) | \ 	create_Dest_X1(0x1C) | create_SrcA_X1(0x25) | ANOP_X0
end_define
begin_define
DECL|macro|ADD_X1
define|#
directive|define
name|ADD_X1
define|\
value|create_Mode(TILEGX_X_MODE) | create_Opcode_X1(RRR_0_OPCODE_X1) | \ 	create_RRROpcodeExtension_X1(ADD_RRR_0_OPCODE_X1) | FNOP_X0
end_define
begin_define
DECL|macro|ADDI_X1
define|#
directive|define
name|ADDI_X1
define|\
value|create_Mode(TILEGX_X_MODE) | create_Opcode_X1(IMM8_OPCODE_X1) | \ 	create_Imm8OpcodeExtension_X1(ADDI_IMM8_OPCODE_X1) | FNOP_X0
end_define
begin_define
DECL|macro|SUB_X1
define|#
directive|define
name|SUB_X1
define|\
value|create_Mode(TILEGX_X_MODE) | create_Opcode_X1(RRR_0_OPCODE_X1) | \ 	create_RRROpcodeExtension_X1(SUB_RRR_0_OPCODE_X1) | FNOP_X0
end_define
begin_define
DECL|macro|NOR_X1
define|#
directive|define
name|NOR_X1
define|\
value|create_Mode(TILEGX_X_MODE) | create_Opcode_X1(RRR_0_OPCODE_X1) | \ 	create_RRROpcodeExtension_X1(NOR_RRR_0_OPCODE_X1) | FNOP_X0
end_define
begin_define
DECL|macro|OR_X1
define|#
directive|define
name|OR_X1
define|\
value|create_Mode(TILEGX_X_MODE) | create_Opcode_X1(RRR_0_OPCODE_X1) | \ 	create_RRROpcodeExtension_X1(OR_RRR_0_OPCODE_X1) | FNOP_X0
end_define
begin_define
DECL|macro|AND_X1
define|#
directive|define
name|AND_X1
define|\
value|create_Mode(TILEGX_X_MODE) | create_Opcode_X1(RRR_0_OPCODE_X1) | \ 	create_RRROpcodeExtension_X1(AND_RRR_0_OPCODE_X1) | FNOP_X0
end_define
begin_define
DECL|macro|XOR_X1
define|#
directive|define
name|XOR_X1
define|\
value|create_Mode(TILEGX_X_MODE) | create_Opcode_X1(RRR_0_OPCODE_X1) | \ 	create_RRROpcodeExtension_X1(XOR_RRR_0_OPCODE_X1) | FNOP_X0
end_define
begin_define
DECL|macro|CMOVNEZ_X0
define|#
directive|define
name|CMOVNEZ_X0
define|\
value|create_Mode(TILEGX_X_MODE) | create_Opcode_X0(RRR_0_OPCODE_X0) | \ 	create_RRROpcodeExtension_X0(CMOVNEZ_RRR_0_OPCODE_X0) | FNOP_X1
end_define
begin_define
DECL|macro|CMOVEQZ_X0
define|#
directive|define
name|CMOVEQZ_X0
define|\
value|create_Mode(TILEGX_X_MODE) | create_Opcode_X0(RRR_0_OPCODE_X0) | \ 	create_RRROpcodeExtension_X0(CMOVEQZ_RRR_0_OPCODE_X0) | FNOP_X1
end_define
begin_define
DECL|macro|ADDLI_X1
define|#
directive|define
name|ADDLI_X1
define|\
value|create_Mode(TILEGX_X_MODE) | create_Opcode_X1(ADDLI_OPCODE_X1) | FNOP_X0
end_define
begin_define
DECL|macro|V4INT_L_X1
define|#
directive|define
name|V4INT_L_X1
define|\
value|create_Mode(TILEGX_X_MODE) | create_Opcode_X1(RRR_0_OPCODE_X1) | \ 	create_RRROpcodeExtension_X1(V4INT_L_RRR_0_OPCODE_X1) | FNOP_X0
end_define
begin_define
DECL|macro|BFEXTU_X0
define|#
directive|define
name|BFEXTU_X0
define|\
value|create_Mode(TILEGX_X_MODE) | create_Opcode_X0(BF_OPCODE_X0) | \ 	create_BFOpcodeExtension_X0(BFEXTU_BF_OPCODE_X0) | FNOP_X1
end_define
begin_define
DECL|macro|BFEXTS_X0
define|#
directive|define
name|BFEXTS_X0
define|\
value|create_Mode(TILEGX_X_MODE) | create_Opcode_X0(BF_OPCODE_X0) | \ 	create_BFOpcodeExtension_X0(BFEXTS_BF_OPCODE_X0) | FNOP_X1
end_define
begin_define
DECL|macro|SHL16INSLI_X1
define|#
directive|define
name|SHL16INSLI_X1
define|\
value|create_Mode(TILEGX_X_MODE) | create_Opcode_X1(SHL16INSLI_OPCODE_X1) | FNOP_X0
end_define
begin_define
DECL|macro|ST_X1
define|#
directive|define
name|ST_X1
define|\
value|create_Mode(TILEGX_X_MODE) | create_Opcode_X1(RRR_0_OPCODE_X1) | \ 	create_RRROpcodeExtension_X1(ST_RRR_0_OPCODE_X1) | create_Dest_X1(0x0) | FNOP_X0
end_define
begin_define
DECL|macro|LD_X1
define|#
directive|define
name|LD_X1
define|\
value|create_Mode(TILEGX_X_MODE) | create_Opcode_X1(RRR_0_OPCODE_X1) | \ 	create_RRROpcodeExtension_X1(UNARY_RRR_0_OPCODE_X1) | \ 	create_UnaryOpcodeExtension_X1(LD_UNARY_OPCODE_X1) | FNOP_X0
end_define
begin_define
DECL|macro|JR_X1
define|#
directive|define
name|JR_X1
define|\
value|create_Mode(TILEGX_X_MODE) | create_Opcode_X1(RRR_0_OPCODE_X1) | \ 	create_RRROpcodeExtension_X1(UNARY_RRR_0_OPCODE_X1) | \ 	create_UnaryOpcodeExtension_X1(JR_UNARY_OPCODE_X1) | FNOP_X0
end_define
begin_define
DECL|macro|JALR_X1
define|#
directive|define
name|JALR_X1
define|\
value|create_Mode(TILEGX_X_MODE) | create_Opcode_X1(RRR_0_OPCODE_X1) | \ 	create_RRROpcodeExtension_X1(UNARY_RRR_0_OPCODE_X1) | \ 	create_UnaryOpcodeExtension_X1(JALR_UNARY_OPCODE_X1) | FNOP_X0
end_define
begin_define
DECL|macro|CLZ_X0
define|#
directive|define
name|CLZ_X0
define|\
value|create_Mode(TILEGX_X_MODE) | create_Opcode_X0(RRR_0_OPCODE_X0) | \ 	create_RRROpcodeExtension_X0(UNARY_RRR_0_OPCODE_X0) | \ 	create_UnaryOpcodeExtension_X0(CNTLZ_UNARY_OPCODE_X0) | FNOP_X1
end_define
begin_define
DECL|macro|CMPLTUI_X1
define|#
directive|define
name|CMPLTUI_X1
define|\
value|create_Mode(TILEGX_X_MODE) | create_Opcode_X1(IMM8_OPCODE_X1) | \ 	create_Imm8OpcodeExtension_X1(CMPLTUI_IMM8_OPCODE_X1) | FNOP_X0
end_define
begin_define
DECL|macro|CMPLTU_X1
define|#
directive|define
name|CMPLTU_X1
define|\
value|create_Mode(TILEGX_X_MODE) | create_Opcode_X1(RRR_0_OPCODE_X1) | \ 	create_RRROpcodeExtension_X1(CMPLTU_RRR_0_OPCODE_X1) | FNOP_X0
end_define
begin_define
DECL|macro|CMPLTS_X1
define|#
directive|define
name|CMPLTS_X1
define|\
value|create_Mode(TILEGX_X_MODE) | create_Opcode_X1(RRR_0_OPCODE_X1) | \ 	create_RRROpcodeExtension_X1(CMPLTS_RRR_0_OPCODE_X1) | FNOP_X0
end_define
begin_define
DECL|macro|XORI_X1
define|#
directive|define
name|XORI_X1
define|\
value|create_Mode(TILEGX_X_MODE) | create_Opcode_X1(IMM8_OPCODE_X1) | \ 	create_Imm8OpcodeExtension_X1(XORI_IMM8_OPCODE_X1) | FNOP_X0
end_define
begin_define
DECL|macro|ORI_X1
define|#
directive|define
name|ORI_X1
define|\
value|create_Mode(TILEGX_X_MODE) | create_Opcode_X1(IMM8_OPCODE_X1) | \ 	create_Imm8OpcodeExtension_X1(ORI_IMM8_OPCODE_X1) | FNOP_X0
end_define
begin_define
DECL|macro|ANDI_X1
define|#
directive|define
name|ANDI_X1
define|\
value|create_Mode(TILEGX_X_MODE) | create_Opcode_X1(IMM8_OPCODE_X1) | \ 	create_Imm8OpcodeExtension_X1(ANDI_IMM8_OPCODE_X1) | FNOP_X0
end_define
begin_define
DECL|macro|SHLI_X1
define|#
directive|define
name|SHLI_X1
define|\
value|create_Mode(TILEGX_X_MODE) | create_Opcode_X1(SHIFT_OPCODE_X1) | \ 	create_ShiftOpcodeExtension_X1(SHLI_SHIFT_OPCODE_X1) | FNOP_X0
end_define
begin_define
DECL|macro|SHL_X1
define|#
directive|define
name|SHL_X1
define|\
value|create_Mode(TILEGX_X_MODE) | create_Opcode_X1(RRR_0_OPCODE_X1) | \ 	create_RRROpcodeExtension_X1(SHL_RRR_0_OPCODE_X1) | FNOP_X0
end_define
begin_define
DECL|macro|SHRSI_X1
define|#
directive|define
name|SHRSI_X1
define|\
value|create_Mode(TILEGX_X_MODE) | create_Opcode_X1(SHIFT_OPCODE_X1) | \ 	create_ShiftOpcodeExtension_X1(SHRSI_SHIFT_OPCODE_X1) | FNOP_X0
end_define
begin_define
DECL|macro|SHRS_X1
define|#
directive|define
name|SHRS_X1
define|\
value|create_Mode(TILEGX_X_MODE) | create_Opcode_X1(RRR_0_OPCODE_X1) | \ 	create_RRROpcodeExtension_X1(SHRS_RRR_0_OPCODE_X1) | FNOP_X0
end_define
begin_define
DECL|macro|SHRUI_X1
define|#
directive|define
name|SHRUI_X1
define|\
value|create_Mode(TILEGX_X_MODE) | create_Opcode_X1(SHIFT_OPCODE_X1) | \ 	create_ShiftOpcodeExtension_X1(SHRUI_SHIFT_OPCODE_X1) | FNOP_X0
end_define
begin_define
DECL|macro|SHRU_X1
define|#
directive|define
name|SHRU_X1
define|\
value|create_Mode(TILEGX_X_MODE) | create_Opcode_X1(RRR_0_OPCODE_X1) | \ 	create_RRROpcodeExtension_X1(SHRU_RRR_0_OPCODE_X1) | FNOP_X0
end_define
begin_define
DECL|macro|BEQZ_X1
define|#
directive|define
name|BEQZ_X1
define|\
value|create_Mode(TILEGX_X_MODE) | create_Opcode_X1(BRANCH_OPCODE_X1) | \ 	create_BrType_X1(BEQZ_BRANCH_OPCODE_X1) | FNOP_X0
end_define
begin_define
DECL|macro|BNEZ_X1
define|#
directive|define
name|BNEZ_X1
define|\
value|create_Mode(TILEGX_X_MODE) | create_Opcode_X1(BRANCH_OPCODE_X1) | \ 	create_BrType_X1(BNEZ_BRANCH_OPCODE_X1) | FNOP_X0
end_define
begin_define
DECL|macro|J_X1
define|#
directive|define
name|J_X1
define|\
value|create_Mode(TILEGX_X_MODE) | create_Opcode_X1(JUMP_OPCODE_X1) | \ 	create_JumpOpcodeExtension_X1(J_JUMP_OPCODE_X1) | FNOP_X0
end_define
begin_define
DECL|macro|JAL_X1
define|#
directive|define
name|JAL_X1
define|\
value|create_Mode(TILEGX_X_MODE) | create_Opcode_X1(JUMP_OPCODE_X1) | \ 	create_JumpOpcodeExtension_X1(JAL_JUMP_OPCODE_X1) | FNOP_X0
end_define
begin_define
DECL|macro|DEST_X0
define|#
directive|define
name|DEST_X0
parameter_list|(
name|x
parameter_list|)
value|create_Dest_X0(x)
end_define
begin_define
DECL|macro|SRCA_X0
define|#
directive|define
name|SRCA_X0
parameter_list|(
name|x
parameter_list|)
value|create_SrcA_X0(x)
end_define
begin_define
DECL|macro|SRCB_X0
define|#
directive|define
name|SRCB_X0
parameter_list|(
name|x
parameter_list|)
value|create_SrcB_X0(x)
end_define
begin_define
DECL|macro|DEST_X1
define|#
directive|define
name|DEST_X1
parameter_list|(
name|x
parameter_list|)
value|create_Dest_X1(x)
end_define
begin_define
DECL|macro|SRCA_X1
define|#
directive|define
name|SRCA_X1
parameter_list|(
name|x
parameter_list|)
value|create_SrcA_X1(x)
end_define
begin_define
DECL|macro|SRCB_X1
define|#
directive|define
name|SRCB_X1
parameter_list|(
name|x
parameter_list|)
value|create_SrcB_X1(x)
end_define
begin_define
DECL|macro|IMM16_X1
define|#
directive|define
name|IMM16_X1
parameter_list|(
name|x
parameter_list|)
value|create_Imm16_X1(x)
end_define
begin_define
DECL|macro|IMM8_X1
define|#
directive|define
name|IMM8_X1
parameter_list|(
name|x
parameter_list|)
value|create_Imm8_X1(x)
end_define
begin_define
DECL|macro|BFSTART_X0
define|#
directive|define
name|BFSTART_X0
parameter_list|(
name|x
parameter_list|)
value|create_BFStart_X0(x)
end_define
begin_define
DECL|macro|BFEND_X0
define|#
directive|define
name|BFEND_X0
parameter_list|(
name|x
parameter_list|)
value|create_BFEnd_X0(x)
end_define
begin_define
DECL|macro|SHIFTIMM_X1
define|#
directive|define
name|SHIFTIMM_X1
parameter_list|(
name|x
parameter_list|)
value|create_ShAmt_X1(x)
end_define
begin_define
DECL|macro|JOFF_X1
define|#
directive|define
name|JOFF_X1
parameter_list|(
name|x
parameter_list|)
value|create_JumpOff_X1(x)
end_define
begin_define
DECL|macro|BOFF_X1
define|#
directive|define
name|BOFF_X1
parameter_list|(
name|x
parameter_list|)
value|create_BrOff_X1(x)
end_define
begin_decl_stmt
DECL|variable|data_transfer_insts
specifier|static
name|SLJIT_CONST
name|tilegx_mnemonic
name|data_transfer_insts
index|[
literal|16
index|]
init|=
block|{
comment|/* u w s */
name|TILEGX_OPC_ST
comment|/* st */
block|,
comment|/* u w l */
name|TILEGX_OPC_LD
comment|/* ld */
block|,
comment|/* u b s */
name|TILEGX_OPC_ST1
comment|/* st1 */
block|,
comment|/* u b l */
name|TILEGX_OPC_LD1U
comment|/* ld1u */
block|,
comment|/* u h s */
name|TILEGX_OPC_ST2
comment|/* st2 */
block|,
comment|/* u h l */
name|TILEGX_OPC_LD2U
comment|/* ld2u */
block|,
comment|/* u i s */
name|TILEGX_OPC_ST4
comment|/* st4 */
block|,
comment|/* u i l */
name|TILEGX_OPC_LD4U
comment|/* ld4u */
block|,
comment|/* s w s */
name|TILEGX_OPC_ST
comment|/* st */
block|,
comment|/* s w l */
name|TILEGX_OPC_LD
comment|/* ld */
block|,
comment|/* s b s */
name|TILEGX_OPC_ST1
comment|/* st1 */
block|,
comment|/* s b l */
name|TILEGX_OPC_LD1S
comment|/* ld1s */
block|,
comment|/* s h s */
name|TILEGX_OPC_ST2
comment|/* st2 */
block|,
comment|/* s h l */
name|TILEGX_OPC_LD2S
comment|/* ld2s */
block|,
comment|/* s i s */
name|TILEGX_OPC_ST4
comment|/* st4 */
block|,
comment|/* s i l */
name|TILEGX_OPC_LD4S
comment|/* ld4s */
block|, }
decl_stmt|;
end_decl_stmt
begin_ifdef
ifdef|#
directive|ifdef
name|TILEGX_JIT_DEBUG
end_ifdef
begin_function
DECL|function|push_inst_debug
specifier|static
name|sljit_si
name|push_inst_debug
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_ins
name|ins
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|sljit_ins
modifier|*
name|ptr
init|=
operator|(
name|sljit_ins
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
sizeof|sizeof
argument_list|(
name|sljit_ins
argument_list|)
argument_list|)
decl_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|ptr
argument_list|)
expr_stmt|;
operator|*
name|ptr
operator|=
name|ins
expr_stmt|;
name|compiler
operator|->
name|size
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"|%04d|S0|:\t\t"
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|print_insn_tilegx
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_function
DECL|function|push_inst_nodebug
specifier|static
name|sljit_si
name|push_inst_nodebug
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_ins
name|ins
parameter_list|)
block|{
name|sljit_ins
modifier|*
name|ptr
init|=
operator|(
name|sljit_ins
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
sizeof|sizeof
argument_list|(
name|sljit_ins
argument_list|)
argument_list|)
decl_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|ptr
argument_list|)
expr_stmt|;
operator|*
name|ptr
operator|=
name|ins
expr_stmt|;
name|compiler
operator|->
name|size
operator|++
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_define
DECL|macro|push_inst
define|#
directive|define
name|push_inst
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|push_inst_debug(a, b, __LINE__)
end_define
begin_else
else|#
directive|else
end_else
begin_function
DECL|function|push_inst
specifier|static
name|sljit_si
name|push_inst
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_ins
name|ins
parameter_list|)
block|{
name|sljit_ins
modifier|*
name|ptr
init|=
operator|(
name|sljit_ins
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
sizeof|sizeof
argument_list|(
name|sljit_ins
argument_list|)
argument_list|)
decl_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|ptr
argument_list|)
expr_stmt|;
operator|*
name|ptr
operator|=
name|ins
expr_stmt|;
name|compiler
operator|->
name|size
operator|++
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|BUNDLE_FORMAT_MASK
define|#
directive|define
name|BUNDLE_FORMAT_MASK
parameter_list|(
name|p0
parameter_list|,
name|p1
parameter_list|,
name|p2
parameter_list|)
define|\
value|((p0) | ((p1)<< 8) | ((p2)<< 16))
end_define
begin_define
DECL|macro|BUNDLE_FORMAT
define|#
directive|define
name|BUNDLE_FORMAT
parameter_list|(
name|p0
parameter_list|,
name|p1
parameter_list|,
name|p2
parameter_list|)
define|\
value|{ \ 		{ \ 			(tilegx_pipeline)(p0), \ 			(tilegx_pipeline)(p1), \ 			(tilegx_pipeline)(p2) \ 		}, \ 		BUNDLE_FORMAT_MASK(1<< (p0), 1<< (p1), (1<< (p2))) \ 	}
end_define
begin_define
DECL|macro|NO_PIPELINE
define|#
directive|define
name|NO_PIPELINE
value|TILEGX_NUM_PIPELINE_ENCODINGS
end_define
begin_define
DECL|macro|tilegx_is_x_pipeline
define|#
directive|define
name|tilegx_is_x_pipeline
parameter_list|(
name|p
parameter_list|)
value|((int)(p)<= (int)TILEGX_PIPELINE_X1)
end_define
begin_define
DECL|macro|PI
define|#
directive|define
name|PI
parameter_list|(
name|encoding
parameter_list|)
define|\
value|push_inst(compiler, encoding)
end_define
begin_define
DECL|macro|PB3
define|#
directive|define
name|PB3
parameter_list|(
name|opcode
parameter_list|,
name|dst
parameter_list|,
name|srca
parameter_list|,
name|srcb
parameter_list|)
define|\
value|push_3_buffer(compiler, opcode, dst, srca, srcb, __LINE__)
end_define
begin_define
DECL|macro|PB2
define|#
directive|define
name|PB2
parameter_list|(
name|opcode
parameter_list|,
name|dst
parameter_list|,
name|src
parameter_list|)
define|\
value|push_2_buffer(compiler, opcode, dst, src, __LINE__)
end_define
begin_define
DECL|macro|JR
define|#
directive|define
name|JR
parameter_list|(
name|reg
parameter_list|)
define|\
value|push_jr_buffer(compiler, TILEGX_OPC_JR, reg, __LINE__)
end_define
begin_define
DECL|macro|ADD
define|#
directive|define
name|ADD
parameter_list|(
name|dst
parameter_list|,
name|srca
parameter_list|,
name|srcb
parameter_list|)
define|\
value|push_3_buffer(compiler, TILEGX_OPC_ADD, dst, srca, srcb, __LINE__)
end_define
begin_define
DECL|macro|SUB
define|#
directive|define
name|SUB
parameter_list|(
name|dst
parameter_list|,
name|srca
parameter_list|,
name|srcb
parameter_list|)
define|\
value|push_3_buffer(compiler, TILEGX_OPC_SUB, dst, srca, srcb, __LINE__)
end_define
begin_define
DECL|macro|NOR
define|#
directive|define
name|NOR
parameter_list|(
name|dst
parameter_list|,
name|srca
parameter_list|,
name|srcb
parameter_list|)
define|\
value|push_3_buffer(compiler, TILEGX_OPC_NOR, dst, srca, srcb, __LINE__)
end_define
begin_define
DECL|macro|OR
define|#
directive|define
name|OR
parameter_list|(
name|dst
parameter_list|,
name|srca
parameter_list|,
name|srcb
parameter_list|)
define|\
value|push_3_buffer(compiler, TILEGX_OPC_OR, dst, srca, srcb, __LINE__)
end_define
begin_define
DECL|macro|XOR
define|#
directive|define
name|XOR
parameter_list|(
name|dst
parameter_list|,
name|srca
parameter_list|,
name|srcb
parameter_list|)
define|\
value|push_3_buffer(compiler, TILEGX_OPC_XOR, dst, srca, srcb, __LINE__)
end_define
begin_define
DECL|macro|AND
define|#
directive|define
name|AND
parameter_list|(
name|dst
parameter_list|,
name|srca
parameter_list|,
name|srcb
parameter_list|)
define|\
value|push_3_buffer(compiler, TILEGX_OPC_AND, dst, srca, srcb, __LINE__)
end_define
begin_define
DECL|macro|CLZ
define|#
directive|define
name|CLZ
parameter_list|(
name|dst
parameter_list|,
name|src
parameter_list|)
define|\
value|push_2_buffer(compiler, TILEGX_OPC_CLZ, dst, src, __LINE__)
end_define
begin_define
DECL|macro|SHLI
define|#
directive|define
name|SHLI
parameter_list|(
name|dst
parameter_list|,
name|srca
parameter_list|,
name|srcb
parameter_list|)
define|\
value|push_3_buffer(compiler, TILEGX_OPC_SHLI, dst, srca, srcb, __LINE__)
end_define
begin_define
DECL|macro|SHRUI
define|#
directive|define
name|SHRUI
parameter_list|(
name|dst
parameter_list|,
name|srca
parameter_list|,
name|imm
parameter_list|)
define|\
value|push_3_buffer(compiler, TILEGX_OPC_SHRUI, dst, srca, imm, __LINE__)
end_define
begin_define
DECL|macro|XORI
define|#
directive|define
name|XORI
parameter_list|(
name|dst
parameter_list|,
name|srca
parameter_list|,
name|imm
parameter_list|)
define|\
value|push_3_buffer(compiler, TILEGX_OPC_XORI, dst, srca, imm, __LINE__)
end_define
begin_define
DECL|macro|ORI
define|#
directive|define
name|ORI
parameter_list|(
name|dst
parameter_list|,
name|srca
parameter_list|,
name|imm
parameter_list|)
define|\
value|push_3_buffer(compiler, TILEGX_OPC_ORI, dst, srca, imm, __LINE__)
end_define
begin_define
DECL|macro|CMPLTU
define|#
directive|define
name|CMPLTU
parameter_list|(
name|dst
parameter_list|,
name|srca
parameter_list|,
name|srcb
parameter_list|)
define|\
value|push_3_buffer(compiler, TILEGX_OPC_CMPLTU, dst, srca, srcb, __LINE__)
end_define
begin_define
DECL|macro|CMPLTS
define|#
directive|define
name|CMPLTS
parameter_list|(
name|dst
parameter_list|,
name|srca
parameter_list|,
name|srcb
parameter_list|)
define|\
value|push_3_buffer(compiler, TILEGX_OPC_CMPLTS, dst, srca, srcb, __LINE__)
end_define
begin_define
DECL|macro|CMPLTUI
define|#
directive|define
name|CMPLTUI
parameter_list|(
name|dst
parameter_list|,
name|srca
parameter_list|,
name|imm
parameter_list|)
define|\
value|push_3_buffer(compiler, TILEGX_OPC_CMPLTUI, dst, srca, imm, __LINE__)
end_define
begin_define
DECL|macro|CMOVNEZ
define|#
directive|define
name|CMOVNEZ
parameter_list|(
name|dst
parameter_list|,
name|srca
parameter_list|,
name|srcb
parameter_list|)
define|\
value|push_3_buffer(compiler, TILEGX_OPC_CMOVNEZ, dst, srca, srcb, __LINE__)
end_define
begin_define
DECL|macro|CMOVEQZ
define|#
directive|define
name|CMOVEQZ
parameter_list|(
name|dst
parameter_list|,
name|srca
parameter_list|,
name|srcb
parameter_list|)
define|\
value|push_3_buffer(compiler, TILEGX_OPC_CMOVEQZ, dst, srca, srcb, __LINE__)
end_define
begin_define
DECL|macro|ADDLI
define|#
directive|define
name|ADDLI
parameter_list|(
name|dst
parameter_list|,
name|srca
parameter_list|,
name|srcb
parameter_list|)
define|\
value|push_3_buffer(compiler, TILEGX_OPC_ADDLI, dst, srca, srcb, __LINE__)
end_define
begin_define
DECL|macro|SHL16INSLI
define|#
directive|define
name|SHL16INSLI
parameter_list|(
name|dst
parameter_list|,
name|srca
parameter_list|,
name|srcb
parameter_list|)
define|\
value|push_3_buffer(compiler, TILEGX_OPC_SHL16INSLI, dst, srca, srcb, __LINE__)
end_define
begin_define
DECL|macro|LD_ADD
define|#
directive|define
name|LD_ADD
parameter_list|(
name|dst
parameter_list|,
name|addr
parameter_list|,
name|adjust
parameter_list|)
define|\
value|push_3_buffer(compiler, TILEGX_OPC_LD_ADD, dst, addr, adjust, __LINE__)
end_define
begin_define
DECL|macro|ST_ADD
define|#
directive|define
name|ST_ADD
parameter_list|(
name|src
parameter_list|,
name|addr
parameter_list|,
name|adjust
parameter_list|)
define|\
value|push_3_buffer(compiler, TILEGX_OPC_ST_ADD, src, addr, adjust, __LINE__)
end_define
begin_define
DECL|macro|LD
define|#
directive|define
name|LD
parameter_list|(
name|dst
parameter_list|,
name|addr
parameter_list|)
define|\
value|push_2_buffer(compiler, TILEGX_OPC_LD, dst, addr, __LINE__)
end_define
begin_define
DECL|macro|BFEXTU
define|#
directive|define
name|BFEXTU
parameter_list|(
name|dst
parameter_list|,
name|src
parameter_list|,
name|start
parameter_list|,
name|end
parameter_list|)
define|\
value|push_4_buffer(compiler, TILEGX_OPC_BFEXTU, dst, src, start, end, __LINE__)
end_define
begin_define
DECL|macro|BFEXTS
define|#
directive|define
name|BFEXTS
parameter_list|(
name|dst
parameter_list|,
name|src
parameter_list|,
name|start
parameter_list|,
name|end
parameter_list|)
define|\
value|push_4_buffer(compiler, TILEGX_OPC_BFEXTS, dst, src, start, end, __LINE__)
end_define
begin_define
DECL|macro|ADD_SOLO
define|#
directive|define
name|ADD_SOLO
parameter_list|(
name|dest
parameter_list|,
name|srca
parameter_list|,
name|srcb
parameter_list|)
define|\
value|push_inst(compiler, ADD_X1 | DEST_X1(dest) | SRCA_X1(srca) | SRCB_X1(srcb))
end_define
begin_define
DECL|macro|ADDI_SOLO
define|#
directive|define
name|ADDI_SOLO
parameter_list|(
name|dest
parameter_list|,
name|srca
parameter_list|,
name|imm
parameter_list|)
define|\
value|push_inst(compiler, ADDI_X1 | DEST_X1(dest) | SRCA_X1(srca) | IMM8_X1(imm))
end_define
begin_define
DECL|macro|ADDLI_SOLO
define|#
directive|define
name|ADDLI_SOLO
parameter_list|(
name|dest
parameter_list|,
name|srca
parameter_list|,
name|imm
parameter_list|)
define|\
value|push_inst(compiler, ADDLI_X1 | DEST_X1(dest) | SRCA_X1(srca) | IMM16_X1(imm))
end_define
begin_define
DECL|macro|SHL16INSLI_SOLO
define|#
directive|define
name|SHL16INSLI_SOLO
parameter_list|(
name|dest
parameter_list|,
name|srca
parameter_list|,
name|imm
parameter_list|)
define|\
value|push_inst(compiler, SHL16INSLI_X1 | DEST_X1(dest) | SRCA_X1(srca) | IMM16_X1(imm))
end_define
begin_define
DECL|macro|JALR_SOLO
define|#
directive|define
name|JALR_SOLO
parameter_list|(
name|reg
parameter_list|)
define|\
value|push_inst(compiler, JALR_X1 | SRCA_X1(reg))
end_define
begin_define
DECL|macro|JR_SOLO
define|#
directive|define
name|JR_SOLO
parameter_list|(
name|reg
parameter_list|)
define|\
value|push_inst(compiler, JR_X1 | SRCA_X1(reg))
end_define
begin_struct
DECL|struct|Format
struct|struct
name|Format
block|{
comment|/* Mapping of bundle issue slot to assigned pipe. */
DECL|member|pipe
name|tilegx_pipeline
name|pipe
index|[
name|TILEGX_MAX_INSTRUCTIONS_PER_BUNDLE
index|]
decl_stmt|;
comment|/* Mask of pipes used by this bundle. */
DECL|member|pipe_mask
name|unsigned
name|int
name|pipe_mask
decl_stmt|;
block|}
struct|;
end_struct
begin_decl_stmt
DECL|variable|formats
specifier|const
name|struct
name|Format
name|formats
index|[]
init|=
block|{
comment|/* In Y format we must always have something in Y2, since it has 	* no fnop, so this conveys that Y2 must always be used. */
name|BUNDLE_FORMAT
argument_list|(
name|TILEGX_PIPELINE_Y0
argument_list|,
name|TILEGX_PIPELINE_Y2
argument_list|,
name|NO_PIPELINE
argument_list|)
block|,
name|BUNDLE_FORMAT
argument_list|(
name|TILEGX_PIPELINE_Y1
argument_list|,
name|TILEGX_PIPELINE_Y2
argument_list|,
name|NO_PIPELINE
argument_list|)
block|,
name|BUNDLE_FORMAT
argument_list|(
name|TILEGX_PIPELINE_Y2
argument_list|,
name|TILEGX_PIPELINE_Y0
argument_list|,
name|NO_PIPELINE
argument_list|)
block|,
name|BUNDLE_FORMAT
argument_list|(
name|TILEGX_PIPELINE_Y2
argument_list|,
name|TILEGX_PIPELINE_Y1
argument_list|,
name|NO_PIPELINE
argument_list|)
block|,
comment|/* Y format has three instructions. */
name|BUNDLE_FORMAT
argument_list|(
name|TILEGX_PIPELINE_Y0
argument_list|,
name|TILEGX_PIPELINE_Y1
argument_list|,
name|TILEGX_PIPELINE_Y2
argument_list|)
block|,
name|BUNDLE_FORMAT
argument_list|(
name|TILEGX_PIPELINE_Y0
argument_list|,
name|TILEGX_PIPELINE_Y2
argument_list|,
name|TILEGX_PIPELINE_Y1
argument_list|)
block|,
name|BUNDLE_FORMAT
argument_list|(
name|TILEGX_PIPELINE_Y1
argument_list|,
name|TILEGX_PIPELINE_Y0
argument_list|,
name|TILEGX_PIPELINE_Y2
argument_list|)
block|,
name|BUNDLE_FORMAT
argument_list|(
name|TILEGX_PIPELINE_Y1
argument_list|,
name|TILEGX_PIPELINE_Y2
argument_list|,
name|TILEGX_PIPELINE_Y0
argument_list|)
block|,
name|BUNDLE_FORMAT
argument_list|(
name|TILEGX_PIPELINE_Y2
argument_list|,
name|TILEGX_PIPELINE_Y0
argument_list|,
name|TILEGX_PIPELINE_Y1
argument_list|)
block|,
name|BUNDLE_FORMAT
argument_list|(
name|TILEGX_PIPELINE_Y2
argument_list|,
name|TILEGX_PIPELINE_Y1
argument_list|,
name|TILEGX_PIPELINE_Y0
argument_list|)
block|,
comment|/* X format has only two instructions. */
name|BUNDLE_FORMAT
argument_list|(
name|TILEGX_PIPELINE_X0
argument_list|,
name|TILEGX_PIPELINE_X1
argument_list|,
name|NO_PIPELINE
argument_list|)
block|,
name|BUNDLE_FORMAT
argument_list|(
argument|TILEGX_PIPELINE_X1
argument_list|,
argument|TILEGX_PIPELINE_X0
argument_list|,
argument|NO_PIPELINE
argument_list|)
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|inst_buf
name|struct
name|jit_instr
name|inst_buf
index|[
name|TILEGX_MAX_INSTRUCTIONS_PER_BUNDLE
index|]
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|inst_buf_index
name|unsigned
name|long
name|inst_buf_index
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|get_any_valid_pipe
name|tilegx_pipeline
name|get_any_valid_pipe
parameter_list|(
specifier|const
name|struct
name|tilegx_opcode
modifier|*
name|opcode
parameter_list|)
block|{
comment|/* FIXME: tile: we could pregenerate this. */
name|int
name|pipe
decl_stmt|;
for|for
control|(
name|pipe
operator|=
literal|0
init|;
operator|(
operator|(
name|opcode
operator|->
name|pipes
operator|&
operator|(
literal|1
operator|<<
name|pipe
operator|)
operator|)
operator|==
literal|0
operator|&&
name|pipe
operator|<
name|TILEGX_NUM_PIPELINE_ENCODINGS
operator|)
condition|;
name|pipe
operator|++
control|)
empty_stmt|;
return|return
call|(
name|tilegx_pipeline
call|)
argument_list|(
name|pipe
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|insert_nop
name|void
name|insert_nop
parameter_list|(
name|tilegx_mnemonic
name|opc
parameter_list|,
name|int
name|line
parameter_list|)
block|{
specifier|const
name|struct
name|tilegx_opcode
modifier|*
name|opcode
init|=
name|NULL
decl_stmt|;
name|memmove
argument_list|(
operator|&
name|inst_buf
index|[
literal|1
index|]
argument_list|,
operator|&
name|inst_buf
index|[
literal|0
index|]
argument_list|,
name|inst_buf_index
operator|*
sizeof|sizeof
name|inst_buf
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|opcode
operator|=
operator|&
name|tilegx_opcodes
index|[
name|opc
index|]
expr_stmt|;
name|inst_buf
index|[
literal|0
index|]
operator|.
name|opcode
operator|=
name|opcode
expr_stmt|;
name|inst_buf
index|[
literal|0
index|]
operator|.
name|pipe
operator|=
name|get_any_valid_pipe
argument_list|(
name|opcode
argument_list|)
expr_stmt|;
name|inst_buf
index|[
literal|0
index|]
operator|.
name|input_registers
operator|=
literal|0
expr_stmt|;
name|inst_buf
index|[
literal|0
index|]
operator|.
name|output_registers
operator|=
literal|0
expr_stmt|;
name|inst_buf
index|[
literal|0
index|]
operator|.
name|line
operator|=
name|line
expr_stmt|;
operator|++
name|inst_buf_index
expr_stmt|;
block|}
end_function
begin_function
DECL|function|compute_format
specifier|const
name|struct
name|Format
modifier|*
name|compute_format
parameter_list|()
block|{
name|unsigned
name|int
name|compatible_pipes
init|=
name|BUNDLE_FORMAT_MASK
argument_list|(
name|inst_buf
index|[
literal|0
index|]
operator|.
name|opcode
operator|->
name|pipes
argument_list|,
name|inst_buf
index|[
literal|1
index|]
operator|.
name|opcode
operator|->
name|pipes
argument_list|,
operator|(
name|inst_buf_index
operator|==
literal|3
condition|?
name|inst_buf
index|[
literal|2
index|]
operator|.
name|opcode
operator|->
name|pipes
else|:
operator|(
literal|1
operator|<<
name|NO_PIPELINE
operator|)
operator|)
argument_list|)
decl_stmt|;
specifier|const
name|struct
name|Format
modifier|*
name|match
init|=
name|NULL
decl_stmt|;
specifier|const
name|struct
name|Format
modifier|*
name|b
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
init|;
name|i
operator|<
sizeof|sizeof
name|formats
operator|/
sizeof|sizeof
name|formats
index|[
literal|0
index|]
condition|;
name|i
operator|++
control|)
block|{
name|b
operator|=
operator|&
name|formats
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|b
operator|->
name|pipe_mask
operator|&
name|compatible_pipes
operator|)
operator|==
name|b
operator|->
name|pipe_mask
condition|)
block|{
name|match
operator|=
name|b
expr_stmt|;
break|break;
block|}
block|}
return|return
name|match
return|;
block|}
end_function
begin_function
DECL|function|assign_pipes
name|sljit_si
name|assign_pipes
parameter_list|()
block|{
name|unsigned
name|long
name|output_registers
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|i
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|inst_buf_index
operator|==
literal|1
condition|)
block|{
name|tilegx_mnemonic
name|opc
init|=
name|inst_buf
index|[
literal|0
index|]
operator|.
name|opcode
operator|->
name|can_bundle
condition|?
name|TILEGX_OPC_FNOP
else|:
name|TILEGX_OPC_NOP
decl_stmt|;
name|insert_nop
argument_list|(
name|opc
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
block|}
specifier|const
name|struct
name|Format
modifier|*
name|match
init|=
name|compute_format
argument_list|()
decl_stmt|;
if|if
condition|(
name|match
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|inst_buf_index
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|i
operator|>
literal|0
operator|)
operator|&&
operator|(
operator|(
name|inst_buf
index|[
name|i
index|]
operator|.
name|input_registers
operator|&
name|output_registers
operator|)
operator|!=
literal|0
operator|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|(
name|i
operator|>
literal|0
operator|)
operator|&&
operator|(
operator|(
name|inst_buf
index|[
name|i
index|]
operator|.
name|output_registers
operator|&
name|output_registers
operator|)
operator|!=
literal|0
operator|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Don't include Rzero in the match set, to avoid triggering 		   needlessly on 'prefetch' instrs. */
name|output_registers
operator||=
name|inst_buf
index|[
name|i
index|]
operator|.
name|output_registers
operator|&
literal|0xFFFFFFFFFFFFFFL
expr_stmt|;
name|inst_buf
index|[
name|i
index|]
operator|.
name|pipe
operator|=
name|match
operator|->
name|pipe
index|[
name|i
index|]
expr_stmt|;
block|}
comment|/* If only 2 instrs, and in Y-mode, insert a nop. */
if|if
condition|(
name|inst_buf_index
operator|==
literal|2
operator|&&
operator|!
name|tilegx_is_x_pipeline
argument_list|(
name|match
operator|->
name|pipe
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|insert_nop
argument_list|(
name|TILEGX_OPC_FNOP
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
comment|/* Select the yet unassigned pipe. */
name|tilegx_pipeline
name|pipe
init|=
call|(
name|tilegx_pipeline
call|)
argument_list|(
operator|(
operator|(
name|TILEGX_PIPELINE_Y0
operator|+
name|TILEGX_PIPELINE_Y1
operator|+
name|TILEGX_PIPELINE_Y2
operator|)
operator|-
operator|(
name|inst_buf
index|[
literal|1
index|]
operator|.
name|pipe
operator|+
name|inst_buf
index|[
literal|2
index|]
operator|.
name|pipe
operator|)
operator|)
argument_list|)
decl_stmt|;
name|inst_buf
index|[
literal|0
index|]
operator|.
name|pipe
operator|=
name|pipe
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|get_bundle_bit
name|tilegx_bundle_bits
name|get_bundle_bit
parameter_list|(
name|struct
name|jit_instr
modifier|*
name|inst
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|val
decl_stmt|;
specifier|const
name|struct
name|tilegx_opcode
modifier|*
name|opcode
init|=
name|inst
operator|->
name|opcode
decl_stmt|;
name|tilegx_bundle_bits
name|bits
init|=
name|opcode
operator|->
name|fixed_bit_values
index|[
name|inst
operator|->
name|pipe
index|]
decl_stmt|;
specifier|const
name|struct
name|tilegx_operand
modifier|*
name|operand
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|opcode
operator|->
name|num_operands
condition|;
name|i
operator|++
control|)
block|{
name|operand
operator|=
operator|&
name|tilegx_operands
index|[
name|opcode
operator|->
name|operands
index|[
name|inst
operator|->
name|pipe
index|]
index|[
name|i
index|]
index|]
expr_stmt|;
name|val
operator|=
name|inst
operator|->
name|operand_value
index|[
name|i
index|]
expr_stmt|;
name|bits
operator||=
name|operand
operator|->
name|insert
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
return|return
name|bits
return|;
block|}
end_function
begin_function
DECL|function|update_buffer
specifier|static
name|sljit_si
name|update_buffer
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|)
block|{
name|int
name|count
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|orig_index
init|=
name|inst_buf_index
decl_stmt|;
name|struct
name|jit_instr
name|inst0
init|=
name|inst_buf
index|[
literal|0
index|]
decl_stmt|;
name|struct
name|jit_instr
name|inst1
init|=
name|inst_buf
index|[
literal|1
index|]
decl_stmt|;
name|struct
name|jit_instr
name|inst2
init|=
name|inst_buf
index|[
literal|2
index|]
decl_stmt|;
name|tilegx_bundle_bits
name|bits
init|=
literal|0
decl_stmt|;
comment|/* If the bundle is valid as is, perform the encoding and return 1. */
if|if
condition|(
name|assign_pipes
argument_list|()
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|inst_buf_index
condition|;
name|i
operator|++
control|)
block|{
name|bits
operator||=
name|get_bundle_bit
argument_list|(
name|inst_buf
operator|+
name|i
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TILEGX_JIT_DEBUG
name|printf
argument_list|(
literal|"|%04d"
argument_list|,
name|inst_buf
index|[
name|i
index|]
operator|.
name|line
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|TILEGX_JIT_DEBUG
if|if
condition|(
name|inst_buf_index
operator|==
literal|3
condition|)
name|printf
argument_list|(
literal|"|M0|:\t"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"|M0|:\t\t"
argument_list|)
expr_stmt|;
name|print_insn_tilegx
argument_list|(
operator|&
name|bits
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|inst_buf_index
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|TILEGX_JIT_DEBUG
return|return
name|push_inst_nodebug
argument_list|(
name|compiler
argument_list|,
name|bits
argument_list|)
return|;
else|#
directive|else
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|bits
argument_list|)
return|;
endif|#
directive|endif
block|}
comment|/* If the bundle is invalid, split it in two. First encode the first two 	   (or possibly 1) instructions, and then the last, separately. Note that 	   assign_pipes may have re-ordered the instrs (by inserting no-ops in 	   lower slots) so we need to reset them. */
name|inst_buf_index
operator|=
name|orig_index
operator|-
literal|1
expr_stmt|;
name|inst_buf
index|[
literal|0
index|]
operator|=
name|inst0
expr_stmt|;
name|inst_buf
index|[
literal|1
index|]
operator|=
name|inst1
expr_stmt|;
name|inst_buf
index|[
literal|2
index|]
operator|=
name|inst2
expr_stmt|;
if|if
condition|(
name|assign_pipes
argument_list|()
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|inst_buf_index
condition|;
name|i
operator|++
control|)
block|{
name|bits
operator||=
name|get_bundle_bit
argument_list|(
name|inst_buf
operator|+
name|i
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TILEGX_JIT_DEBUG
name|printf
argument_list|(
literal|"|%04d"
argument_list|,
name|inst_buf
index|[
name|i
index|]
operator|.
name|line
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|TILEGX_JIT_DEBUG
if|if
condition|(
name|inst_buf_index
operator|==
literal|3
condition|)
name|printf
argument_list|(
literal|"|M1|:\t"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"|M1|:\t\t"
argument_list|)
expr_stmt|;
name|print_insn_tilegx
argument_list|(
operator|&
name|bits
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|orig_index
operator|-
literal|1
operator|)
operator|==
literal|2
condition|)
block|{
name|inst_buf
index|[
literal|0
index|]
operator|=
name|inst2
expr_stmt|;
name|inst_buf_index
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|orig_index
operator|-
literal|1
operator|)
operator|==
literal|1
condition|)
block|{
name|inst_buf
index|[
literal|0
index|]
operator|=
name|inst1
expr_stmt|;
name|inst_buf_index
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|TILEGX_JIT_DEBUG
return|return
name|push_inst_nodebug
argument_list|(
name|compiler
argument_list|,
name|bits
argument_list|)
return|;
else|#
directive|else
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|bits
argument_list|)
return|;
endif|#
directive|endif
block|}
else|else
block|{
comment|/* We had 3 instrs of which the first 2 can't live in the same bundle. 		   Split those two. Note that we don't try to then combine the second 		   and third instr into a single bundle.  First instruction: */
name|inst_buf_index
operator|=
literal|1
expr_stmt|;
name|inst_buf
index|[
literal|0
index|]
operator|=
name|inst0
expr_stmt|;
name|inst_buf
index|[
literal|1
index|]
operator|=
name|inst1
expr_stmt|;
name|inst_buf
index|[
literal|2
index|]
operator|=
name|inst2
expr_stmt|;
if|if
condition|(
name|assign_pipes
argument_list|()
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|inst_buf_index
condition|;
name|i
operator|++
control|)
block|{
name|bits
operator||=
name|get_bundle_bit
argument_list|(
name|inst_buf
operator|+
name|i
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TILEGX_JIT_DEBUG
name|printf
argument_list|(
literal|"|%04d"
argument_list|,
name|inst_buf
index|[
name|i
index|]
operator|.
name|line
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|TILEGX_JIT_DEBUG
if|if
condition|(
name|inst_buf_index
operator|==
literal|3
condition|)
name|printf
argument_list|(
literal|"|M2|:\t"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"|M2|:\t\t"
argument_list|)
expr_stmt|;
name|print_insn_tilegx
argument_list|(
operator|&
name|bits
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|inst_buf
index|[
literal|0
index|]
operator|=
name|inst1
expr_stmt|;
name|inst_buf
index|[
literal|1
index|]
operator|=
name|inst2
expr_stmt|;
name|inst_buf_index
operator|=
name|orig_index
operator|-
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|TILEGX_JIT_DEBUG
return|return
name|push_inst_nodebug
argument_list|(
name|compiler
argument_list|,
name|bits
argument_list|)
return|;
else|#
directive|else
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|bits
argument_list|)
return|;
endif|#
directive|endif
block|}
else|else
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
block|}
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|flush_buffer
specifier|static
name|sljit_si
name|flush_buffer
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|)
block|{
while|while
condition|(
name|inst_buf_index
operator|!=
literal|0
condition|)
name|update_buffer
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|push_4_buffer
specifier|static
name|sljit_si
name|push_4_buffer
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|tilegx_mnemonic
name|opc
parameter_list|,
name|int
name|op0
parameter_list|,
name|int
name|op1
parameter_list|,
name|int
name|op2
parameter_list|,
name|int
name|op3
parameter_list|,
name|int
name|line
parameter_list|)
block|{
if|if
condition|(
name|inst_buf_index
operator|==
name|TILEGX_MAX_INSTRUCTIONS_PER_BUNDLE
condition|)
name|FAIL_IF
argument_list|(
name|update_buffer
argument_list|(
name|compiler
argument_list|)
argument_list|)
expr_stmt|;
specifier|const
name|struct
name|tilegx_opcode
modifier|*
name|opcode
init|=
operator|&
name|tilegx_opcodes
index|[
name|opc
index|]
decl_stmt|;
name|inst_buf
index|[
name|inst_buf_index
index|]
operator|.
name|opcode
operator|=
name|opcode
expr_stmt|;
name|inst_buf
index|[
name|inst_buf_index
index|]
operator|.
name|pipe
operator|=
name|get_any_valid_pipe
argument_list|(
name|opcode
argument_list|)
expr_stmt|;
name|inst_buf
index|[
name|inst_buf_index
index|]
operator|.
name|operand_value
index|[
literal|0
index|]
operator|=
name|op0
expr_stmt|;
name|inst_buf
index|[
name|inst_buf_index
index|]
operator|.
name|operand_value
index|[
literal|1
index|]
operator|=
name|op1
expr_stmt|;
name|inst_buf
index|[
name|inst_buf_index
index|]
operator|.
name|operand_value
index|[
literal|2
index|]
operator|=
name|op2
expr_stmt|;
name|inst_buf
index|[
name|inst_buf_index
index|]
operator|.
name|operand_value
index|[
literal|3
index|]
operator|=
name|op3
expr_stmt|;
name|inst_buf
index|[
name|inst_buf_index
index|]
operator|.
name|input_registers
operator|=
literal|1L
operator|<<
name|op1
expr_stmt|;
name|inst_buf
index|[
name|inst_buf_index
index|]
operator|.
name|output_registers
operator|=
literal|1L
operator|<<
name|op0
expr_stmt|;
name|inst_buf
index|[
name|inst_buf_index
index|]
operator|.
name|line
operator|=
name|line
expr_stmt|;
name|inst_buf_index
operator|++
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_function
DECL|function|push_3_buffer
specifier|static
name|sljit_si
name|push_3_buffer
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|tilegx_mnemonic
name|opc
parameter_list|,
name|int
name|op0
parameter_list|,
name|int
name|op1
parameter_list|,
name|int
name|op2
parameter_list|,
name|int
name|line
parameter_list|)
block|{
if|if
condition|(
name|inst_buf_index
operator|==
name|TILEGX_MAX_INSTRUCTIONS_PER_BUNDLE
condition|)
name|FAIL_IF
argument_list|(
name|update_buffer
argument_list|(
name|compiler
argument_list|)
argument_list|)
expr_stmt|;
specifier|const
name|struct
name|tilegx_opcode
modifier|*
name|opcode
init|=
operator|&
name|tilegx_opcodes
index|[
name|opc
index|]
decl_stmt|;
name|inst_buf
index|[
name|inst_buf_index
index|]
operator|.
name|opcode
operator|=
name|opcode
expr_stmt|;
name|inst_buf
index|[
name|inst_buf_index
index|]
operator|.
name|pipe
operator|=
name|get_any_valid_pipe
argument_list|(
name|opcode
argument_list|)
expr_stmt|;
name|inst_buf
index|[
name|inst_buf_index
index|]
operator|.
name|operand_value
index|[
literal|0
index|]
operator|=
name|op0
expr_stmt|;
name|inst_buf
index|[
name|inst_buf_index
index|]
operator|.
name|operand_value
index|[
literal|1
index|]
operator|=
name|op1
expr_stmt|;
name|inst_buf
index|[
name|inst_buf_index
index|]
operator|.
name|operand_value
index|[
literal|2
index|]
operator|=
name|op2
expr_stmt|;
name|inst_buf
index|[
name|inst_buf_index
index|]
operator|.
name|line
operator|=
name|line
expr_stmt|;
switch|switch
condition|(
name|opc
condition|)
block|{
case|case
name|TILEGX_OPC_ST_ADD
case|:
name|inst_buf
index|[
name|inst_buf_index
index|]
operator|.
name|input_registers
operator|=
operator|(
literal|1L
operator|<<
name|op0
operator|)
operator||
operator|(
literal|1L
operator|<<
name|op1
operator|)
expr_stmt|;
name|inst_buf
index|[
name|inst_buf_index
index|]
operator|.
name|output_registers
operator|=
literal|1L
operator|<<
name|op0
expr_stmt|;
break|break;
case|case
name|TILEGX_OPC_LD_ADD
case|:
name|inst_buf
index|[
name|inst_buf_index
index|]
operator|.
name|input_registers
operator|=
literal|1L
operator|<<
name|op1
expr_stmt|;
name|inst_buf
index|[
name|inst_buf_index
index|]
operator|.
name|output_registers
operator|=
operator|(
literal|1L
operator|<<
name|op0
operator|)
operator||
operator|(
literal|1L
operator|<<
name|op1
operator|)
expr_stmt|;
break|break;
case|case
name|TILEGX_OPC_ADD
case|:
case|case
name|TILEGX_OPC_AND
case|:
case|case
name|TILEGX_OPC_SUB
case|:
case|case
name|TILEGX_OPC_OR
case|:
case|case
name|TILEGX_OPC_XOR
case|:
case|case
name|TILEGX_OPC_NOR
case|:
case|case
name|TILEGX_OPC_SHL
case|:
case|case
name|TILEGX_OPC_SHRU
case|:
case|case
name|TILEGX_OPC_SHRS
case|:
case|case
name|TILEGX_OPC_CMPLTU
case|:
case|case
name|TILEGX_OPC_CMPLTS
case|:
case|case
name|TILEGX_OPC_CMOVEQZ
case|:
case|case
name|TILEGX_OPC_CMOVNEZ
case|:
name|inst_buf
index|[
name|inst_buf_index
index|]
operator|.
name|input_registers
operator|=
operator|(
literal|1L
operator|<<
name|op1
operator|)
operator||
operator|(
literal|1L
operator|<<
name|op2
operator|)
expr_stmt|;
name|inst_buf
index|[
name|inst_buf_index
index|]
operator|.
name|output_registers
operator|=
literal|1L
operator|<<
name|op0
expr_stmt|;
break|break;
case|case
name|TILEGX_OPC_ADDLI
case|:
case|case
name|TILEGX_OPC_XORI
case|:
case|case
name|TILEGX_OPC_ORI
case|:
case|case
name|TILEGX_OPC_SHLI
case|:
case|case
name|TILEGX_OPC_SHRUI
case|:
case|case
name|TILEGX_OPC_SHRSI
case|:
case|case
name|TILEGX_OPC_SHL16INSLI
case|:
case|case
name|TILEGX_OPC_CMPLTUI
case|:
case|case
name|TILEGX_OPC_CMPLTSI
case|:
name|inst_buf
index|[
name|inst_buf_index
index|]
operator|.
name|input_registers
operator|=
literal|1L
operator|<<
name|op1
expr_stmt|;
name|inst_buf
index|[
name|inst_buf_index
index|]
operator|.
name|output_registers
operator|=
literal|1L
operator|<<
name|op0
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"unrecoginzed opc: %s\n"
argument_list|,
name|opcode
operator|->
name|name
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
block|}
name|inst_buf_index
operator|++
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_function
DECL|function|push_2_buffer
specifier|static
name|sljit_si
name|push_2_buffer
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|tilegx_mnemonic
name|opc
parameter_list|,
name|int
name|op0
parameter_list|,
name|int
name|op1
parameter_list|,
name|int
name|line
parameter_list|)
block|{
if|if
condition|(
name|inst_buf_index
operator|==
name|TILEGX_MAX_INSTRUCTIONS_PER_BUNDLE
condition|)
name|FAIL_IF
argument_list|(
name|update_buffer
argument_list|(
name|compiler
argument_list|)
argument_list|)
expr_stmt|;
specifier|const
name|struct
name|tilegx_opcode
modifier|*
name|opcode
init|=
operator|&
name|tilegx_opcodes
index|[
name|opc
index|]
decl_stmt|;
name|inst_buf
index|[
name|inst_buf_index
index|]
operator|.
name|opcode
operator|=
name|opcode
expr_stmt|;
name|inst_buf
index|[
name|inst_buf_index
index|]
operator|.
name|pipe
operator|=
name|get_any_valid_pipe
argument_list|(
name|opcode
argument_list|)
expr_stmt|;
name|inst_buf
index|[
name|inst_buf_index
index|]
operator|.
name|operand_value
index|[
literal|0
index|]
operator|=
name|op0
expr_stmt|;
name|inst_buf
index|[
name|inst_buf_index
index|]
operator|.
name|operand_value
index|[
literal|1
index|]
operator|=
name|op1
expr_stmt|;
name|inst_buf
index|[
name|inst_buf_index
index|]
operator|.
name|line
operator|=
name|line
expr_stmt|;
switch|switch
condition|(
name|opc
condition|)
block|{
case|case
name|TILEGX_OPC_BEQZ
case|:
case|case
name|TILEGX_OPC_BNEZ
case|:
name|inst_buf
index|[
name|inst_buf_index
index|]
operator|.
name|input_registers
operator|=
literal|1L
operator|<<
name|op0
expr_stmt|;
break|break;
case|case
name|TILEGX_OPC_ST
case|:
case|case
name|TILEGX_OPC_ST1
case|:
case|case
name|TILEGX_OPC_ST2
case|:
case|case
name|TILEGX_OPC_ST4
case|:
name|inst_buf
index|[
name|inst_buf_index
index|]
operator|.
name|input_registers
operator|=
operator|(
literal|1L
operator|<<
name|op0
operator|)
operator||
operator|(
literal|1L
operator|<<
name|op1
operator|)
expr_stmt|;
name|inst_buf
index|[
name|inst_buf_index
index|]
operator|.
name|output_registers
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|TILEGX_OPC_CLZ
case|:
case|case
name|TILEGX_OPC_LD
case|:
case|case
name|TILEGX_OPC_LD1U
case|:
case|case
name|TILEGX_OPC_LD1S
case|:
case|case
name|TILEGX_OPC_LD2U
case|:
case|case
name|TILEGX_OPC_LD2S
case|:
case|case
name|TILEGX_OPC_LD4U
case|:
case|case
name|TILEGX_OPC_LD4S
case|:
name|inst_buf
index|[
name|inst_buf_index
index|]
operator|.
name|input_registers
operator|=
literal|1L
operator|<<
name|op1
expr_stmt|;
name|inst_buf
index|[
name|inst_buf_index
index|]
operator|.
name|output_registers
operator|=
literal|1L
operator|<<
name|op0
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"unrecoginzed opc: %s\n"
argument_list|,
name|opcode
operator|->
name|name
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
block|}
name|inst_buf_index
operator|++
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_function
DECL|function|push_0_buffer
specifier|static
name|sljit_si
name|push_0_buffer
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|tilegx_mnemonic
name|opc
parameter_list|,
name|int
name|line
parameter_list|)
block|{
if|if
condition|(
name|inst_buf_index
operator|==
name|TILEGX_MAX_INSTRUCTIONS_PER_BUNDLE
condition|)
name|FAIL_IF
argument_list|(
name|update_buffer
argument_list|(
name|compiler
argument_list|)
argument_list|)
expr_stmt|;
specifier|const
name|struct
name|tilegx_opcode
modifier|*
name|opcode
init|=
operator|&
name|tilegx_opcodes
index|[
name|opc
index|]
decl_stmt|;
name|inst_buf
index|[
name|inst_buf_index
index|]
operator|.
name|opcode
operator|=
name|opcode
expr_stmt|;
name|inst_buf
index|[
name|inst_buf_index
index|]
operator|.
name|pipe
operator|=
name|get_any_valid_pipe
argument_list|(
name|opcode
argument_list|)
expr_stmt|;
name|inst_buf
index|[
name|inst_buf_index
index|]
operator|.
name|input_registers
operator|=
literal|0
expr_stmt|;
name|inst_buf
index|[
name|inst_buf_index
index|]
operator|.
name|output_registers
operator|=
literal|0
expr_stmt|;
name|inst_buf
index|[
name|inst_buf_index
index|]
operator|.
name|line
operator|=
name|line
expr_stmt|;
name|inst_buf_index
operator|++
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_function
DECL|function|push_jr_buffer
specifier|static
name|sljit_si
name|push_jr_buffer
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|tilegx_mnemonic
name|opc
parameter_list|,
name|int
name|op0
parameter_list|,
name|int
name|line
parameter_list|)
block|{
if|if
condition|(
name|inst_buf_index
operator|==
name|TILEGX_MAX_INSTRUCTIONS_PER_BUNDLE
condition|)
name|FAIL_IF
argument_list|(
name|update_buffer
argument_list|(
name|compiler
argument_list|)
argument_list|)
expr_stmt|;
specifier|const
name|struct
name|tilegx_opcode
modifier|*
name|opcode
init|=
operator|&
name|tilegx_opcodes
index|[
name|opc
index|]
decl_stmt|;
name|inst_buf
index|[
name|inst_buf_index
index|]
operator|.
name|opcode
operator|=
name|opcode
expr_stmt|;
name|inst_buf
index|[
name|inst_buf_index
index|]
operator|.
name|pipe
operator|=
name|get_any_valid_pipe
argument_list|(
name|opcode
argument_list|)
expr_stmt|;
name|inst_buf
index|[
name|inst_buf_index
index|]
operator|.
name|operand_value
index|[
literal|0
index|]
operator|=
name|op0
expr_stmt|;
name|inst_buf
index|[
name|inst_buf_index
index|]
operator|.
name|input_registers
operator|=
literal|1L
operator|<<
name|op0
expr_stmt|;
name|inst_buf
index|[
name|inst_buf_index
index|]
operator|.
name|output_registers
operator|=
literal|0
expr_stmt|;
name|inst_buf
index|[
name|inst_buf_index
index|]
operator|.
name|line
operator|=
name|line
expr_stmt|;
name|inst_buf_index
operator|++
expr_stmt|;
return|return
name|flush_buffer
argument_list|(
name|compiler
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|detect_jump_type
specifier|static
name|SLJIT_INLINE
name|sljit_ins
modifier|*
name|detect_jump_type
parameter_list|(
name|struct
name|sljit_jump
modifier|*
name|jump
parameter_list|,
name|sljit_ins
modifier|*
name|code_ptr
parameter_list|,
name|sljit_ins
modifier|*
name|code
parameter_list|)
block|{
name|sljit_sw
name|diff
decl_stmt|;
name|sljit_uw
name|target_addr
decl_stmt|;
name|sljit_ins
modifier|*
name|inst
decl_stmt|;
name|sljit_ins
name|saved_inst
decl_stmt|;
if|if
condition|(
name|jump
operator|->
name|flags
operator|&
name|SLJIT_REWRITABLE_JUMP
condition|)
return|return
name|code_ptr
return|;
if|if
condition|(
name|jump
operator|->
name|flags
operator|&
name|JUMP_ADDR
condition|)
name|target_addr
operator|=
name|jump
operator|->
name|u
operator|.
name|target
expr_stmt|;
else|else
block|{
name|SLJIT_ASSERT
argument_list|(
name|jump
operator|->
name|flags
operator|&
name|JUMP_LABEL
argument_list|)
expr_stmt|;
name|target_addr
operator|=
call|(
name|sljit_uw
call|)
argument_list|(
name|code
operator|+
name|jump
operator|->
name|u
operator|.
name|label
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
name|inst
operator|=
operator|(
name|sljit_ins
operator|*
operator|)
name|jump
operator|->
name|addr
expr_stmt|;
if|if
condition|(
name|jump
operator|->
name|flags
operator|&
name|IS_COND
condition|)
name|inst
operator|--
expr_stmt|;
name|diff
operator|=
operator|(
operator|(
name|sljit_sw
operator|)
name|target_addr
operator|-
operator|(
name|sljit_sw
operator|)
name|inst
operator|)
operator|>>
literal|3
expr_stmt|;
if|if
condition|(
name|diff
operator|<=
name|SIMM_17BIT_MAX
operator|&&
name|diff
operator|>=
name|SIMM_17BIT_MIN
condition|)
block|{
name|jump
operator|->
name|flags
operator||=
name|PATCH_B
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|jump
operator|->
name|flags
operator|&
name|IS_COND
operator|)
condition|)
block|{
if|if
condition|(
name|jump
operator|->
name|flags
operator|&
name|IS_JAL
condition|)
block|{
name|jump
operator|->
name|flags
operator|&=
operator|~
operator|(
name|PATCH_B
operator|)
expr_stmt|;
name|jump
operator|->
name|flags
operator||=
name|PATCH_J
expr_stmt|;
name|inst
index|[
literal|0
index|]
operator|=
name|JAL_X1
expr_stmt|;
ifdef|#
directive|ifdef
name|TILEGX_JIT_DEBUG
name|printf
argument_list|(
literal|"[runtime relocate]%04d:\t"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|print_insn_tilegx
argument_list|(
name|inst
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|inst
index|[
literal|0
index|]
operator|=
name|BEQZ_X1
operator||
name|SRCA_X1
argument_list|(
name|ZERO
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TILEGX_JIT_DEBUG
name|printf
argument_list|(
literal|"[runtime relocate]%04d:\t"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|print_insn_tilegx
argument_list|(
name|inst
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
name|inst
return|;
block|}
name|inst
index|[
literal|0
index|]
operator|=
name|inst
index|[
literal|0
index|]
operator|^
operator|(
literal|0x7L
operator|<<
literal|55
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TILEGX_JIT_DEBUG
name|printf
argument_list|(
literal|"[runtime relocate]%04d:\t"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|print_insn_tilegx
argument_list|(
name|inst
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|jump
operator|->
name|addr
operator|-=
sizeof|sizeof
argument_list|(
name|sljit_ins
argument_list|)
expr_stmt|;
return|return
name|inst
return|;
block|}
if|if
condition|(
name|jump
operator|->
name|flags
operator|&
name|IS_COND
condition|)
block|{
if|if
condition|(
operator|(
name|target_addr
operator|&
operator|~
literal|0x3FFFFFFFL
operator|)
operator|==
operator|(
operator|(
name|jump
operator|->
name|addr
operator|+
sizeof|sizeof
argument_list|(
name|sljit_ins
argument_list|)
operator|)
operator|&
operator|~
literal|0x3FFFFFFFL
operator|)
condition|)
block|{
name|jump
operator|->
name|flags
operator||=
name|PATCH_J
expr_stmt|;
name|inst
index|[
literal|0
index|]
operator|=
operator|(
name|inst
index|[
literal|0
index|]
operator|&
operator|~
operator|(
name|BOFF_X1
argument_list|(
operator|-
literal|1
argument_list|)
operator|)
operator|)
operator||
name|BOFF_X1
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|inst
index|[
literal|1
index|]
operator|=
name|J_X1
expr_stmt|;
return|return
name|inst
operator|+
literal|1
return|;
block|}
return|return
name|code_ptr
return|;
block|}
if|if
condition|(
operator|(
name|target_addr
operator|&
operator|~
literal|0x3FFFFFFFL
operator|)
operator|==
operator|(
operator|(
name|jump
operator|->
name|addr
operator|+
sizeof|sizeof
argument_list|(
name|sljit_ins
argument_list|)
operator|)
operator|&
operator|~
literal|0x3FFFFFFFL
operator|)
condition|)
block|{
name|jump
operator|->
name|flags
operator||=
name|PATCH_J
expr_stmt|;
if|if
condition|(
name|jump
operator|->
name|flags
operator|&
name|IS_JAL
condition|)
block|{
name|inst
index|[
literal|0
index|]
operator|=
name|JAL_X1
expr_stmt|;
ifdef|#
directive|ifdef
name|TILEGX_JIT_DEBUG
name|printf
argument_list|(
literal|"[runtime relocate]%04d:\t"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|print_insn_tilegx
argument_list|(
name|inst
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|inst
index|[
literal|0
index|]
operator|=
name|J_X1
expr_stmt|;
ifdef|#
directive|ifdef
name|TILEGX_JIT_DEBUG
name|printf
argument_list|(
literal|"[runtime relocate]%04d:\t"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|print_insn_tilegx
argument_list|(
name|inst
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
name|inst
return|;
block|}
return|return
name|code_ptr
return|;
block|}
end_function
begin_function
DECL|function|sljit_generate_code
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
modifier|*
name|sljit_generate_code
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|)
block|{
name|struct
name|sljit_memory_fragment
modifier|*
name|buf
decl_stmt|;
name|sljit_ins
modifier|*
name|code
decl_stmt|;
name|sljit_ins
modifier|*
name|code_ptr
decl_stmt|;
name|sljit_ins
modifier|*
name|buf_ptr
decl_stmt|;
name|sljit_ins
modifier|*
name|buf_end
decl_stmt|;
name|sljit_uw
name|word_count
decl_stmt|;
name|sljit_uw
name|addr
decl_stmt|;
name|struct
name|sljit_label
modifier|*
name|label
decl_stmt|;
name|struct
name|sljit_jump
modifier|*
name|jump
decl_stmt|;
name|struct
name|sljit_const
modifier|*
name|const_
decl_stmt|;
name|CHECK_ERROR_PTR
argument_list|()
expr_stmt|;
name|check_sljit_generate_code
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
name|reverse_buf
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
name|code
operator|=
operator|(
name|sljit_ins
operator|*
operator|)
name|SLJIT_MALLOC_EXEC
argument_list|(
name|compiler
operator|->
name|size
operator|*
sizeof|sizeof
argument_list|(
name|sljit_ins
argument_list|)
argument_list|)
expr_stmt|;
name|PTR_FAIL_WITH_EXEC_IF
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|buf
operator|=
name|compiler
operator|->
name|buf
expr_stmt|;
name|code_ptr
operator|=
name|code
expr_stmt|;
name|word_count
operator|=
literal|0
expr_stmt|;
name|label
operator|=
name|compiler
operator|->
name|labels
expr_stmt|;
name|jump
operator|=
name|compiler
operator|->
name|jumps
expr_stmt|;
name|const_
operator|=
name|compiler
operator|->
name|consts
expr_stmt|;
do|do
block|{
name|buf_ptr
operator|=
operator|(
name|sljit_ins
operator|*
operator|)
name|buf
operator|->
name|memory
expr_stmt|;
name|buf_end
operator|=
name|buf_ptr
operator|+
operator|(
name|buf
operator|->
name|used_size
operator|>>
literal|3
operator|)
expr_stmt|;
do|do
block|{
operator|*
name|code_ptr
operator|=
operator|*
name|buf_ptr
operator|++
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
operator|!
name|label
operator|||
name|label
operator|->
name|size
operator|>=
name|word_count
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
operator|!
name|jump
operator|||
name|jump
operator|->
name|addr
operator|>=
name|word_count
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
operator|!
name|const_
operator|||
name|const_
operator|->
name|addr
operator|>=
name|word_count
argument_list|)
expr_stmt|;
comment|/* These structures are ordered by their address. */
if|if
condition|(
name|label
operator|&&
name|label
operator|->
name|size
operator|==
name|word_count
condition|)
block|{
comment|/* Just recording the address. */
name|label
operator|->
name|addr
operator|=
operator|(
name|sljit_uw
operator|)
name|code_ptr
expr_stmt|;
name|label
operator|->
name|size
operator|=
name|code_ptr
operator|-
name|code
expr_stmt|;
name|label
operator|=
name|label
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|jump
operator|&&
name|jump
operator|->
name|addr
operator|==
name|word_count
condition|)
block|{
if|if
condition|(
name|jump
operator|->
name|flags
operator|&
name|IS_JAL
condition|)
name|jump
operator|->
name|addr
operator|=
call|(
name|sljit_uw
call|)
argument_list|(
name|code_ptr
operator|-
literal|4
argument_list|)
expr_stmt|;
else|else
name|jump
operator|->
name|addr
operator|=
call|(
name|sljit_uw
call|)
argument_list|(
name|code_ptr
operator|-
literal|3
argument_list|)
expr_stmt|;
name|code_ptr
operator|=
name|detect_jump_type
argument_list|(
name|jump
argument_list|,
name|code_ptr
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|jump
operator|=
name|jump
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|const_
operator|&&
name|const_
operator|->
name|addr
operator|==
name|word_count
condition|)
block|{
comment|/* Just recording the address. */
name|const_
operator|->
name|addr
operator|=
operator|(
name|sljit_uw
operator|)
name|code_ptr
expr_stmt|;
name|const_
operator|=
name|const_
operator|->
name|next
expr_stmt|;
block|}
name|code_ptr
operator|++
expr_stmt|;
name|word_count
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|buf_ptr
operator|<
name|buf_end
condition|)
do|;
name|buf
operator|=
name|buf
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|buf
condition|)
do|;
if|if
condition|(
name|label
operator|&&
name|label
operator|->
name|size
operator|==
name|word_count
condition|)
block|{
name|label
operator|->
name|addr
operator|=
operator|(
name|sljit_uw
operator|)
name|code_ptr
expr_stmt|;
name|label
operator|->
name|size
operator|=
name|code_ptr
operator|-
name|code
expr_stmt|;
name|label
operator|=
name|label
operator|->
name|next
expr_stmt|;
block|}
name|SLJIT_ASSERT
argument_list|(
operator|!
name|label
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
operator|!
name|jump
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
operator|!
name|const_
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|code_ptr
operator|-
name|code
operator|<=
operator|(
name|sljit_sw
operator|)
name|compiler
operator|->
name|size
argument_list|)
expr_stmt|;
name|jump
operator|=
name|compiler
operator|->
name|jumps
expr_stmt|;
while|while
condition|(
name|jump
condition|)
block|{
do|do
block|{
name|addr
operator|=
operator|(
name|jump
operator|->
name|flags
operator|&
name|JUMP_LABEL
operator|)
condition|?
name|jump
operator|->
name|u
operator|.
name|label
operator|->
name|addr
else|:
name|jump
operator|->
name|u
operator|.
name|target
expr_stmt|;
name|buf_ptr
operator|=
operator|(
name|sljit_ins
operator|*
operator|)
name|jump
operator|->
name|addr
expr_stmt|;
if|if
condition|(
name|jump
operator|->
name|flags
operator|&
name|PATCH_B
condition|)
block|{
name|addr
operator|=
call|(
name|sljit_sw
call|)
argument_list|(
name|addr
operator|-
operator|(
name|jump
operator|->
name|addr
operator|)
argument_list|)
operator|>>
literal|3
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
operator|(
name|sljit_sw
operator|)
name|addr
operator|<=
name|SIMM_17BIT_MAX
operator|&&
operator|(
name|sljit_sw
operator|)
name|addr
operator|>=
name|SIMM_17BIT_MIN
argument_list|)
expr_stmt|;
name|buf_ptr
index|[
literal|0
index|]
operator|=
operator|(
name|buf_ptr
index|[
literal|0
index|]
operator|&
operator|~
operator|(
name|BOFF_X1
argument_list|(
operator|-
literal|1
argument_list|)
operator|)
operator|)
operator||
name|BOFF_X1
argument_list|(
name|addr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TILEGX_JIT_DEBUG
name|printf
argument_list|(
literal|"[runtime relocate]%04d:\t"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|print_insn_tilegx
argument_list|(
name|buf_ptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
if|if
condition|(
name|jump
operator|->
name|flags
operator|&
name|PATCH_J
condition|)
block|{
name|SLJIT_ASSERT
argument_list|(
operator|(
name|addr
operator|&
operator|~
literal|0x3FFFFFFFL
operator|)
operator|==
operator|(
operator|(
name|jump
operator|->
name|addr
operator|+
sizeof|sizeof
argument_list|(
name|sljit_ins
argument_list|)
operator|)
operator|&
operator|~
literal|0x3FFFFFFFL
operator|)
argument_list|)
expr_stmt|;
name|addr
operator|=
call|(
name|sljit_sw
call|)
argument_list|(
name|addr
operator|-
operator|(
name|jump
operator|->
name|addr
operator|)
argument_list|)
operator|>>
literal|3
expr_stmt|;
name|buf_ptr
index|[
literal|0
index|]
operator|=
operator|(
name|buf_ptr
index|[
literal|0
index|]
operator|&
operator|~
operator|(
name|JOFF_X1
argument_list|(
operator|-
literal|1
argument_list|)
operator|)
operator|)
operator||
name|JOFF_X1
argument_list|(
name|addr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TILEGX_JIT_DEBUG
name|printf
argument_list|(
literal|"[runtime relocate]%04d:\t"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|print_insn_tilegx
argument_list|(
name|buf_ptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
name|SLJIT_ASSERT
argument_list|(
operator|!
operator|(
name|jump
operator|->
name|flags
operator|&
name|IS_JAL
operator|)
argument_list|)
expr_stmt|;
comment|/* Set the fields of immediate loads. */
name|buf_ptr
index|[
literal|0
index|]
operator|=
operator|(
name|buf_ptr
index|[
literal|0
index|]
operator|&
operator|~
operator|(
literal|0xFFFFL
operator|<<
literal|43
operator|)
operator|)
operator||
operator|(
operator|(
operator|(
name|addr
operator|>>
literal|32
operator|)
operator|&
literal|0xFFFFL
operator|)
operator|<<
literal|43
operator|)
expr_stmt|;
name|buf_ptr
index|[
literal|1
index|]
operator|=
operator|(
name|buf_ptr
index|[
literal|1
index|]
operator|&
operator|~
operator|(
literal|0xFFFFL
operator|<<
literal|43
operator|)
operator|)
operator||
operator|(
operator|(
operator|(
name|addr
operator|>>
literal|16
operator|)
operator|&
literal|0xFFFFL
operator|)
operator|<<
literal|43
operator|)
expr_stmt|;
name|buf_ptr
index|[
literal|2
index|]
operator|=
operator|(
name|buf_ptr
index|[
literal|2
index|]
operator|&
operator|~
operator|(
literal|0xFFFFL
operator|<<
literal|43
operator|)
operator|)
operator||
operator|(
operator|(
name|addr
operator|&
literal|0xFFFFL
operator|)
operator|<<
literal|43
operator|)
expr_stmt|;
block|}
do|while
condition|(
literal|0
condition|)
do|;
name|jump
operator|=
name|jump
operator|->
name|next
expr_stmt|;
block|}
name|compiler
operator|->
name|error
operator|=
name|SLJIT_ERR_COMPILED
expr_stmt|;
name|compiler
operator|->
name|executable_size
operator|=
operator|(
name|code_ptr
operator|-
name|code
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|sljit_ins
argument_list|)
expr_stmt|;
name|SLJIT_CACHE_FLUSH
argument_list|(
name|code
argument_list|,
name|code_ptr
argument_list|)
expr_stmt|;
return|return
name|code
return|;
block|}
end_function
begin_function
DECL|function|load_immediate
specifier|static
name|sljit_si
name|load_immediate
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|dst_ar
parameter_list|,
name|sljit_sw
name|imm
parameter_list|)
block|{
if|if
condition|(
name|imm
operator|<=
name|SIMM_16BIT_MAX
operator|&&
name|imm
operator|>=
name|SIMM_16BIT_MIN
condition|)
return|return
name|ADDLI
argument_list|(
name|dst_ar
argument_list|,
name|ZERO
argument_list|,
name|imm
argument_list|)
return|;
if|if
condition|(
name|imm
operator|<=
name|SIMM_32BIT_MAX
operator|&&
name|imm
operator|>=
name|SIMM_32BIT_MIN
condition|)
block|{
name|FAIL_IF
argument_list|(
name|ADDLI
argument_list|(
name|dst_ar
argument_list|,
name|ZERO
argument_list|,
name|imm
operator|>>
literal|16
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SHL16INSLI
argument_list|(
name|dst_ar
argument_list|,
name|dst_ar
argument_list|,
name|imm
argument_list|)
return|;
block|}
if|if
condition|(
name|imm
operator|<=
name|SIMM_48BIT_MAX
operator|&&
name|imm
operator|>=
name|SIMM_48BIT_MIN
condition|)
block|{
name|FAIL_IF
argument_list|(
name|ADDLI
argument_list|(
name|dst_ar
argument_list|,
name|ZERO
argument_list|,
name|imm
operator|>>
literal|32
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|SHL16INSLI
argument_list|(
name|dst_ar
argument_list|,
name|dst_ar
argument_list|,
name|imm
operator|>>
literal|16
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SHL16INSLI
argument_list|(
name|dst_ar
argument_list|,
name|dst_ar
argument_list|,
name|imm
argument_list|)
return|;
block|}
name|FAIL_IF
argument_list|(
name|ADDLI
argument_list|(
name|dst_ar
argument_list|,
name|ZERO
argument_list|,
name|imm
operator|>>
literal|48
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|SHL16INSLI
argument_list|(
name|dst_ar
argument_list|,
name|dst_ar
argument_list|,
name|imm
operator|>>
literal|32
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|SHL16INSLI
argument_list|(
name|dst_ar
argument_list|,
name|dst_ar
argument_list|,
name|imm
operator|>>
literal|16
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SHL16INSLI
argument_list|(
name|dst_ar
argument_list|,
name|dst_ar
argument_list|,
name|imm
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|emit_const
specifier|static
name|sljit_si
name|emit_const
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|dst_ar
parameter_list|,
name|sljit_sw
name|imm
parameter_list|,
name|int
name|flush
parameter_list|)
block|{
comment|/* Should *not* be optimized as load_immediate, as pcre relocation 	   mechanism will match this fixed 4-instruction pattern. */
if|if
condition|(
name|flush
condition|)
block|{
name|FAIL_IF
argument_list|(
name|ADDLI_SOLO
argument_list|(
name|dst_ar
argument_list|,
name|ZERO
argument_list|,
name|imm
operator|>>
literal|32
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|SHL16INSLI_SOLO
argument_list|(
name|dst_ar
argument_list|,
name|dst_ar
argument_list|,
name|imm
operator|>>
literal|16
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SHL16INSLI_SOLO
argument_list|(
name|dst_ar
argument_list|,
name|dst_ar
argument_list|,
name|imm
argument_list|)
return|;
block|}
name|FAIL_IF
argument_list|(
name|ADDLI
argument_list|(
name|dst_ar
argument_list|,
name|ZERO
argument_list|,
name|imm
operator|>>
literal|32
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|SHL16INSLI
argument_list|(
name|dst_ar
argument_list|,
name|dst_ar
argument_list|,
name|imm
operator|>>
literal|16
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SHL16INSLI
argument_list|(
name|dst_ar
argument_list|,
name|dst_ar
argument_list|,
name|imm
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|emit_const_64
specifier|static
name|sljit_si
name|emit_const_64
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|dst_ar
parameter_list|,
name|sljit_sw
name|imm
parameter_list|,
name|int
name|flush
parameter_list|)
block|{
comment|/* Should *not* be optimized as load_immediate, as pcre relocation 	   mechanism will match this fixed 4-instruction pattern. */
if|if
condition|(
name|flush
condition|)
block|{
name|FAIL_IF
argument_list|(
name|ADDLI_SOLO
argument_list|(
name|reg_map
index|[
name|dst_ar
index|]
argument_list|,
name|ZERO
argument_list|,
name|imm
operator|>>
literal|48
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|SHL16INSLI_SOLO
argument_list|(
name|reg_map
index|[
name|dst_ar
index|]
argument_list|,
name|reg_map
index|[
name|dst_ar
index|]
argument_list|,
name|imm
operator|>>
literal|32
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|SHL16INSLI_SOLO
argument_list|(
name|reg_map
index|[
name|dst_ar
index|]
argument_list|,
name|reg_map
index|[
name|dst_ar
index|]
argument_list|,
name|imm
operator|>>
literal|16
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SHL16INSLI_SOLO
argument_list|(
name|reg_map
index|[
name|dst_ar
index|]
argument_list|,
name|reg_map
index|[
name|dst_ar
index|]
argument_list|,
name|imm
argument_list|)
return|;
block|}
name|FAIL_IF
argument_list|(
name|ADDLI
argument_list|(
name|reg_map
index|[
name|dst_ar
index|]
argument_list|,
name|ZERO
argument_list|,
name|imm
operator|>>
literal|48
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|SHL16INSLI
argument_list|(
name|reg_map
index|[
name|dst_ar
index|]
argument_list|,
name|reg_map
index|[
name|dst_ar
index|]
argument_list|,
name|imm
operator|>>
literal|32
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|SHL16INSLI
argument_list|(
name|reg_map
index|[
name|dst_ar
index|]
argument_list|,
name|reg_map
index|[
name|dst_ar
index|]
argument_list|,
name|imm
operator|>>
literal|16
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SHL16INSLI
argument_list|(
name|reg_map
index|[
name|dst_ar
index|]
argument_list|,
name|reg_map
index|[
name|dst_ar
index|]
argument_list|,
name|imm
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_enter
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_enter
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|args
parameter_list|,
name|sljit_si
name|scratches
parameter_list|,
name|sljit_si
name|saveds
parameter_list|,
name|sljit_si
name|local_size
parameter_list|)
block|{
name|sljit_ins
name|base
decl_stmt|;
name|sljit_ins
name|bundle
init|=
literal|0
decl_stmt|;
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|check_sljit_emit_enter
argument_list|(
name|compiler
argument_list|,
name|args
argument_list|,
name|scratches
argument_list|,
name|saveds
argument_list|,
name|local_size
argument_list|)
expr_stmt|;
name|compiler
operator|->
name|scratches
operator|=
name|scratches
expr_stmt|;
name|compiler
operator|->
name|saveds
operator|=
name|saveds
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_DEBUG
operator|&&
name|SLJIT_DEBUG
operator|)
name|compiler
operator|->
name|logical_local_size
operator|=
name|local_size
expr_stmt|;
endif|#
directive|endif
name|local_size
operator|+=
operator|(
name|saveds
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
expr_stmt|;
name|local_size
operator|=
operator|(
name|local_size
operator|+
literal|7
operator|)
operator|&
operator|~
literal|7
expr_stmt|;
name|compiler
operator|->
name|local_size
operator|=
name|local_size
expr_stmt|;
if|if
condition|(
name|local_size
operator|<=
name|SIMM_16BIT_MAX
condition|)
block|{
comment|/* Frequent case. */
name|FAIL_IF
argument_list|(
name|ADDLI
argument_list|(
name|SLJIT_LOCALS_REG_mapped
argument_list|,
name|SLJIT_LOCALS_REG_mapped
argument_list|,
operator|-
name|local_size
argument_list|)
argument_list|)
expr_stmt|;
name|base
operator|=
name|SLJIT_LOCALS_REG_mapped
expr_stmt|;
block|}
else|else
block|{
name|FAIL_IF
argument_list|(
name|load_immediate
argument_list|(
name|compiler
argument_list|,
name|TMP_REG1_mapped
argument_list|,
name|local_size
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|ADD
argument_list|(
name|TMP_REG2_mapped
argument_list|,
name|SLJIT_LOCALS_REG_mapped
argument_list|,
name|ZERO
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|SUB
argument_list|(
name|SLJIT_LOCALS_REG_mapped
argument_list|,
name|SLJIT_LOCALS_REG_mapped
argument_list|,
name|TMP_REG1_mapped
argument_list|)
argument_list|)
expr_stmt|;
name|base
operator|=
name|TMP_REG2_mapped
expr_stmt|;
name|local_size
operator|=
literal|0
expr_stmt|;
block|}
name|FAIL_IF
argument_list|(
name|ADDLI
argument_list|(
name|ADDR_TMP_mapped
argument_list|,
name|base
argument_list|,
name|local_size
operator|-
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|ST_ADD
argument_list|(
name|ADDR_TMP_mapped
argument_list|,
name|RA
argument_list|,
operator|-
literal|8
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|saveds
operator|>=
literal|1
condition|)
name|FAIL_IF
argument_list|(
name|ST_ADD
argument_list|(
name|ADDR_TMP_mapped
argument_list|,
name|SLJIT_SAVED_REG1_mapped
argument_list|,
operator|-
literal|8
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|saveds
operator|>=
literal|2
condition|)
name|FAIL_IF
argument_list|(
name|ST_ADD
argument_list|(
name|ADDR_TMP_mapped
argument_list|,
name|SLJIT_SAVED_REG2_mapped
argument_list|,
operator|-
literal|8
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|saveds
operator|>=
literal|3
condition|)
name|FAIL_IF
argument_list|(
name|ST_ADD
argument_list|(
name|ADDR_TMP_mapped
argument_list|,
name|SLJIT_SAVED_REG3_mapped
argument_list|,
operator|-
literal|8
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|saveds
operator|>=
literal|4
condition|)
name|FAIL_IF
argument_list|(
name|ST_ADD
argument_list|(
name|ADDR_TMP_mapped
argument_list|,
name|SLJIT_SAVED_EREG1_mapped
argument_list|,
operator|-
literal|8
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|saveds
operator|>=
literal|5
condition|)
name|FAIL_IF
argument_list|(
name|ST_ADD
argument_list|(
name|ADDR_TMP_mapped
argument_list|,
name|SLJIT_SAVED_EREG2_mapped
argument_list|,
operator|-
literal|8
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|>=
literal|1
condition|)
name|FAIL_IF
argument_list|(
name|ADD
argument_list|(
name|SLJIT_SAVED_REG1_mapped
argument_list|,
literal|0
argument_list|,
name|ZERO
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|>=
literal|2
condition|)
name|FAIL_IF
argument_list|(
name|ADD
argument_list|(
name|SLJIT_SAVED_REG2_mapped
argument_list|,
literal|1
argument_list|,
name|ZERO
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|>=
literal|3
condition|)
name|FAIL_IF
argument_list|(
name|ADD
argument_list|(
name|SLJIT_SAVED_REG3_mapped
argument_list|,
literal|2
argument_list|,
name|ZERO
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_function
DECL|function|sljit_set_context
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
name|sljit_set_context
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|args
parameter_list|,
name|sljit_si
name|scratches
parameter_list|,
name|sljit_si
name|saveds
parameter_list|,
name|sljit_si
name|local_size
parameter_list|)
block|{
name|CHECK_ERROR_VOID
argument_list|()
expr_stmt|;
name|check_sljit_set_context
argument_list|(
name|compiler
argument_list|,
name|args
argument_list|,
name|scratches
argument_list|,
name|saveds
argument_list|,
name|local_size
argument_list|)
expr_stmt|;
name|compiler
operator|->
name|scratches
operator|=
name|scratches
expr_stmt|;
name|compiler
operator|->
name|saveds
operator|=
name|saveds
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_DEBUG
operator|&&
name|SLJIT_DEBUG
operator|)
name|compiler
operator|->
name|logical_local_size
operator|=
name|local_size
expr_stmt|;
endif|#
directive|endif
name|local_size
operator|+=
operator|(
name|saveds
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
expr_stmt|;
name|compiler
operator|->
name|local_size
operator|=
operator|(
name|local_size
operator|+
literal|7
operator|)
operator|&
operator|~
literal|7
expr_stmt|;
block|}
end_function
begin_function
DECL|function|sljit_emit_return
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_return
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|)
block|{
name|sljit_si
name|local_size
decl_stmt|;
name|sljit_ins
name|base
decl_stmt|;
name|int
name|addr_initialized
init|=
literal|0
decl_stmt|;
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|check_sljit_emit_return
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|emit_mov_before_return
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
argument_list|)
expr_stmt|;
name|local_size
operator|=
name|compiler
operator|->
name|local_size
expr_stmt|;
if|if
condition|(
name|local_size
operator|<=
name|SIMM_16BIT_MAX
condition|)
name|base
operator|=
name|SLJIT_LOCALS_REG_mapped
expr_stmt|;
else|else
block|{
name|FAIL_IF
argument_list|(
name|load_immediate
argument_list|(
name|compiler
argument_list|,
name|TMP_REG1_mapped
argument_list|,
name|local_size
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|ADD
argument_list|(
name|TMP_REG1_mapped
argument_list|,
name|SLJIT_LOCALS_REG_mapped
argument_list|,
name|TMP_REG1_mapped
argument_list|)
argument_list|)
expr_stmt|;
name|base
operator|=
name|TMP_REG1_mapped
expr_stmt|;
name|local_size
operator|=
literal|0
expr_stmt|;
block|}
name|FAIL_IF
argument_list|(
name|ADDLI
argument_list|(
name|ADDR_TMP_mapped
argument_list|,
name|base
argument_list|,
name|local_size
operator|-
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|LD
argument_list|(
name|RA
argument_list|,
name|ADDR_TMP_mapped
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|compiler
operator|->
name|saveds
operator|>=
literal|5
condition|)
block|{
name|FAIL_IF
argument_list|(
name|ADDLI
argument_list|(
name|ADDR_TMP_mapped
argument_list|,
name|base
argument_list|,
name|local_size
operator|-
literal|48
argument_list|)
argument_list|)
expr_stmt|;
name|addr_initialized
operator|=
literal|1
expr_stmt|;
name|FAIL_IF
argument_list|(
name|LD_ADD
argument_list|(
name|SLJIT_SAVED_EREG2_mapped
argument_list|,
name|ADDR_TMP_mapped
argument_list|,
literal|8
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|compiler
operator|->
name|saveds
operator|>=
literal|4
condition|)
block|{
if|if
condition|(
name|addr_initialized
operator|==
literal|0
condition|)
block|{
name|FAIL_IF
argument_list|(
name|ADDLI
argument_list|(
name|ADDR_TMP_mapped
argument_list|,
name|base
argument_list|,
name|local_size
operator|-
literal|40
argument_list|)
argument_list|)
expr_stmt|;
name|addr_initialized
operator|=
literal|1
expr_stmt|;
block|}
name|FAIL_IF
argument_list|(
name|LD_ADD
argument_list|(
name|SLJIT_SAVED_EREG1_mapped
argument_list|,
name|ADDR_TMP_mapped
argument_list|,
literal|8
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|compiler
operator|->
name|saveds
operator|>=
literal|3
condition|)
block|{
if|if
condition|(
name|addr_initialized
operator|==
literal|0
condition|)
block|{
name|FAIL_IF
argument_list|(
name|ADDLI
argument_list|(
name|ADDR_TMP_mapped
argument_list|,
name|base
argument_list|,
name|local_size
operator|-
literal|32
argument_list|)
argument_list|)
expr_stmt|;
name|addr_initialized
operator|=
literal|1
expr_stmt|;
block|}
name|FAIL_IF
argument_list|(
name|LD_ADD
argument_list|(
name|SLJIT_SAVED_REG3_mapped
argument_list|,
name|ADDR_TMP_mapped
argument_list|,
literal|8
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|compiler
operator|->
name|saveds
operator|>=
literal|2
condition|)
block|{
if|if
condition|(
name|addr_initialized
operator|==
literal|0
condition|)
block|{
name|FAIL_IF
argument_list|(
name|ADDLI
argument_list|(
name|ADDR_TMP_mapped
argument_list|,
name|base
argument_list|,
name|local_size
operator|-
literal|24
argument_list|)
argument_list|)
expr_stmt|;
name|addr_initialized
operator|=
literal|1
expr_stmt|;
block|}
name|FAIL_IF
argument_list|(
name|LD_ADD
argument_list|(
name|SLJIT_SAVED_REG2_mapped
argument_list|,
name|ADDR_TMP_mapped
argument_list|,
literal|8
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|compiler
operator|->
name|saveds
operator|>=
literal|1
condition|)
block|{
if|if
condition|(
name|addr_initialized
operator|==
literal|0
condition|)
block|{
name|FAIL_IF
argument_list|(
name|ADDLI
argument_list|(
name|ADDR_TMP_mapped
argument_list|,
name|base
argument_list|,
name|local_size
operator|-
literal|16
argument_list|)
argument_list|)
expr_stmt|;
comment|/* addr_initialized = 1; no need to initialize as it's the last one. */
block|}
name|FAIL_IF
argument_list|(
name|LD_ADD
argument_list|(
name|SLJIT_SAVED_REG1_mapped
argument_list|,
name|ADDR_TMP_mapped
argument_list|,
literal|8
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|compiler
operator|->
name|local_size
operator|<=
name|SIMM_16BIT_MAX
condition|)
name|FAIL_IF
argument_list|(
name|ADDLI
argument_list|(
name|SLJIT_LOCALS_REG_mapped
argument_list|,
name|SLJIT_LOCALS_REG_mapped
argument_list|,
name|compiler
operator|->
name|local_size
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|FAIL_IF
argument_list|(
name|ADD
argument_list|(
name|SLJIT_LOCALS_REG_mapped
argument_list|,
name|TMP_REG1_mapped
argument_list|,
name|ZERO
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|JR
argument_list|(
name|RA
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/* reg_ar is an absoulute register! */
end_comment
begin_comment
comment|/* Can perform an operation using at most 1 instruction. */
end_comment
begin_function
DECL|function|getput_arg_fast
specifier|static
name|sljit_si
name|getput_arg_fast
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|flags
parameter_list|,
name|sljit_si
name|reg_ar
parameter_list|,
name|sljit_si
name|arg
parameter_list|,
name|sljit_sw
name|argw
parameter_list|)
block|{
name|SLJIT_ASSERT
argument_list|(
name|arg
operator|&
name|SLJIT_MEM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
operator|(
name|flags
operator|&
name|WRITE_BACK
operator|)
operator|||
operator|!
operator|(
name|arg
operator|&
name|REG_MASK
operator|)
operator|)
operator|&&
operator|!
operator|(
name|arg
operator|&
name|OFFS_REG_MASK
operator|)
operator|&&
name|argw
operator|<=
name|SIMM_16BIT_MAX
operator|&&
name|argw
operator|>=
name|SIMM_16BIT_MIN
condition|)
block|{
comment|/* Works for both absoulte and relative addresses. */
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|flags
operator|&
name|ARG_TEST
argument_list|)
condition|)
return|return
literal|1
return|;
name|FAIL_IF
argument_list|(
name|ADDLI
argument_list|(
name|ADDR_TMP_mapped
argument_list|,
name|reg_map
index|[
name|arg
operator|&
name|REG_MASK
index|]
argument_list|,
name|argw
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|LOAD_DATA
condition|)
name|FAIL_IF
argument_list|(
name|PB2
argument_list|(
name|data_transfer_insts
index|[
name|flags
operator|&
name|MEM_MASK
index|]
argument_list|,
name|reg_ar
argument_list|,
name|ADDR_TMP_mapped
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|FAIL_IF
argument_list|(
name|PB2
argument_list|(
name|data_transfer_insts
index|[
name|flags
operator|&
name|MEM_MASK
index|]
argument_list|,
name|ADDR_TMP_mapped
argument_list|,
name|reg_ar
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/* See getput_arg below.    Note: can_cache is called only for binary operators. Those    operators always uses word arguments without write back. */
end_comment
begin_function
DECL|function|can_cache
specifier|static
name|sljit_si
name|can_cache
parameter_list|(
name|sljit_si
name|arg
parameter_list|,
name|sljit_sw
name|argw
parameter_list|,
name|sljit_si
name|next_arg
parameter_list|,
name|sljit_sw
name|next_argw
parameter_list|)
block|{
name|SLJIT_ASSERT
argument_list|(
operator|(
name|arg
operator|&
name|SLJIT_MEM
operator|)
operator|&&
operator|(
name|next_arg
operator|&
name|SLJIT_MEM
operator|)
argument_list|)
expr_stmt|;
comment|/* Simple operation except for updates. */
if|if
condition|(
name|arg
operator|&
name|OFFS_REG_MASK
condition|)
block|{
name|argw
operator|&=
literal|0x3
expr_stmt|;
name|next_argw
operator|&=
literal|0x3
expr_stmt|;
if|if
condition|(
name|argw
operator|&&
name|argw
operator|==
name|next_argw
operator|&&
operator|(
name|arg
operator|==
name|next_arg
operator|||
operator|(
name|arg
operator|&
name|OFFS_REG_MASK
operator|)
operator|==
operator|(
name|next_arg
operator|&
name|OFFS_REG_MASK
operator|)
operator|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|arg
operator|==
name|next_arg
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|next_argw
operator|-
name|argw
operator|)
operator|<=
name|SIMM_16BIT_MAX
operator|&&
operator|(
name|next_argw
operator|-
name|argw
operator|)
operator|>=
name|SIMM_16BIT_MIN
operator|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/* Emit the necessary instructions. See can_cache above. */
end_comment
begin_function
DECL|function|getput_arg
specifier|static
name|sljit_si
name|getput_arg
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|flags
parameter_list|,
name|sljit_si
name|reg_ar
parameter_list|,
name|sljit_si
name|arg
parameter_list|,
name|sljit_sw
name|argw
parameter_list|,
name|sljit_si
name|next_arg
parameter_list|,
name|sljit_sw
name|next_argw
parameter_list|)
block|{
name|sljit_si
name|tmp_ar
decl_stmt|,
name|base
decl_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|arg
operator|&
name|SLJIT_MEM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|next_arg
operator|&
name|SLJIT_MEM
operator|)
condition|)
block|{
name|next_arg
operator|=
literal|0
expr_stmt|;
name|next_argw
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|MEM_MASK
operator|)
operator|<=
name|GPR_REG
operator|&&
operator|(
name|flags
operator|&
name|LOAD_DATA
operator|)
condition|)
name|tmp_ar
operator|=
name|reg_ar
expr_stmt|;
else|else
name|tmp_ar
operator|=
name|TMP_REG1_mapped
expr_stmt|;
name|base
operator|=
name|arg
operator|&
name|REG_MASK
expr_stmt|;
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|arg
operator|&
name|OFFS_REG_MASK
argument_list|)
condition|)
block|{
name|argw
operator|&=
literal|0x3
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|WRITE_BACK
operator|)
operator|&&
name|reg_ar
operator|==
name|reg_map
index|[
name|base
index|]
condition|)
block|{
name|SLJIT_ASSERT
argument_list|(
operator|!
operator|(
name|flags
operator|&
name|LOAD_DATA
operator|)
operator|&&
name|reg_map
index|[
name|TMP_REG1
index|]
operator|!=
name|reg_ar
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|ADD
argument_list|(
name|TMP_REG1_mapped
argument_list|,
name|reg_ar
argument_list|,
name|ZERO
argument_list|)
argument_list|)
expr_stmt|;
name|reg_ar
operator|=
name|TMP_REG1_mapped
expr_stmt|;
block|}
comment|/* Using the cache. */
if|if
condition|(
name|argw
operator|==
name|compiler
operator|->
name|cache_argw
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|WRITE_BACK
operator|)
condition|)
block|{
if|if
condition|(
name|arg
operator|==
name|compiler
operator|->
name|cache_arg
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|LOAD_DATA
condition|)
return|return
name|PB2
argument_list|(
name|data_transfer_insts
index|[
name|flags
operator|&
name|MEM_MASK
index|]
argument_list|,
name|reg_ar
argument_list|,
name|TMP_REG3_mapped
argument_list|)
return|;
else|else
return|return
name|PB2
argument_list|(
name|data_transfer_insts
index|[
name|flags
operator|&
name|MEM_MASK
index|]
argument_list|,
name|TMP_REG3_mapped
argument_list|,
name|reg_ar
argument_list|)
return|;
block|}
if|if
condition|(
operator|(
name|SLJIT_MEM
operator||
operator|(
name|arg
operator|&
name|OFFS_REG_MASK
operator|)
operator|)
operator|==
name|compiler
operator|->
name|cache_arg
condition|)
block|{
if|if
condition|(
name|arg
operator|==
name|next_arg
operator|&&
name|argw
operator|==
operator|(
name|next_argw
operator|&
literal|0x3
operator|)
condition|)
block|{
name|compiler
operator|->
name|cache_arg
operator|=
name|arg
expr_stmt|;
name|compiler
operator|->
name|cache_argw
operator|=
name|argw
expr_stmt|;
name|FAIL_IF
argument_list|(
name|ADD
argument_list|(
name|TMP_REG3_mapped
argument_list|,
name|reg_map
index|[
name|base
index|]
argument_list|,
name|TMP_REG3_mapped
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|LOAD_DATA
condition|)
return|return
name|PB2
argument_list|(
name|data_transfer_insts
index|[
name|flags
operator|&
name|MEM_MASK
index|]
argument_list|,
name|reg_ar
argument_list|,
name|TMP_REG3_mapped
argument_list|)
return|;
else|else
return|return
name|PB2
argument_list|(
name|data_transfer_insts
index|[
name|flags
operator|&
name|MEM_MASK
index|]
argument_list|,
name|TMP_REG3_mapped
argument_list|,
name|reg_ar
argument_list|)
return|;
block|}
name|FAIL_IF
argument_list|(
name|ADD
argument_list|(
name|tmp_ar
argument_list|,
name|reg_map
index|[
name|base
index|]
argument_list|,
name|TMP_REG3_mapped
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|LOAD_DATA
condition|)
return|return
name|PB2
argument_list|(
name|data_transfer_insts
index|[
name|flags
operator|&
name|MEM_MASK
index|]
argument_list|,
name|reg_ar
argument_list|,
name|tmp_ar
argument_list|)
return|;
else|else
return|return
name|PB2
argument_list|(
name|data_transfer_insts
index|[
name|flags
operator|&
name|MEM_MASK
index|]
argument_list|,
name|tmp_ar
argument_list|,
name|reg_ar
argument_list|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|SLJIT_MEM
operator||
operator|(
name|arg
operator|&
name|OFFS_REG_MASK
operator|)
operator|)
operator|==
name|compiler
operator|->
name|cache_arg
condition|)
block|{
name|FAIL_IF
argument_list|(
name|ADD
argument_list|(
name|reg_map
index|[
name|base
index|]
argument_list|,
name|reg_map
index|[
name|base
index|]
argument_list|,
name|TMP_REG3_mapped
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|LOAD_DATA
condition|)
return|return
name|PB2
argument_list|(
name|data_transfer_insts
index|[
name|flags
operator|&
name|MEM_MASK
index|]
argument_list|,
name|reg_ar
argument_list|,
name|reg_map
index|[
name|base
index|]
argument_list|)
return|;
else|else
return|return
name|PB2
argument_list|(
name|data_transfer_insts
index|[
name|flags
operator|&
name|MEM_MASK
index|]
argument_list|,
name|reg_map
index|[
name|base
index|]
argument_list|,
name|reg_ar
argument_list|)
return|;
block|}
block|}
block|}
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|argw
argument_list|)
condition|)
block|{
name|compiler
operator|->
name|cache_arg
operator|=
name|SLJIT_MEM
operator||
operator|(
name|arg
operator|&
name|OFFS_REG_MASK
operator|)
expr_stmt|;
name|compiler
operator|->
name|cache_argw
operator|=
name|argw
expr_stmt|;
name|FAIL_IF
argument_list|(
name|SHLI
argument_list|(
name|TMP_REG3_mapped
argument_list|,
name|reg_map
index|[
name|OFFS_REG
argument_list|(
name|arg
argument_list|)
index|]
argument_list|,
name|argw
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|WRITE_BACK
operator|)
condition|)
block|{
if|if
condition|(
name|arg
operator|==
name|next_arg
operator|&&
name|argw
operator|==
operator|(
name|next_argw
operator|&
literal|0x3
operator|)
condition|)
block|{
name|compiler
operator|->
name|cache_arg
operator|=
name|arg
expr_stmt|;
name|compiler
operator|->
name|cache_argw
operator|=
name|argw
expr_stmt|;
name|FAIL_IF
argument_list|(
name|ADD
argument_list|(
name|TMP_REG3_mapped
argument_list|,
name|reg_map
index|[
name|base
index|]
argument_list|,
name|reg_map
index|[
operator|!
name|argw
condition|?
name|OFFS_REG
argument_list|(
name|arg
argument_list|)
else|:
name|TMP_REG3
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|tmp_ar
operator|=
name|TMP_REG3_mapped
expr_stmt|;
block|}
else|else
name|FAIL_IF
argument_list|(
name|ADD
argument_list|(
name|tmp_ar
argument_list|,
name|reg_map
index|[
name|base
index|]
argument_list|,
name|reg_map
index|[
operator|!
name|argw
condition|?
name|OFFS_REG
argument_list|(
name|arg
argument_list|)
else|:
name|TMP_REG3
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|LOAD_DATA
condition|)
return|return
name|PB2
argument_list|(
name|data_transfer_insts
index|[
name|flags
operator|&
name|MEM_MASK
index|]
argument_list|,
name|reg_ar
argument_list|,
name|tmp_ar
argument_list|)
return|;
else|else
return|return
name|PB2
argument_list|(
name|data_transfer_insts
index|[
name|flags
operator|&
name|MEM_MASK
index|]
argument_list|,
name|tmp_ar
argument_list|,
name|reg_ar
argument_list|)
return|;
block|}
name|FAIL_IF
argument_list|(
name|ADD
argument_list|(
name|reg_map
index|[
name|base
index|]
argument_list|,
name|reg_map
index|[
name|base
index|]
argument_list|,
name|reg_map
index|[
operator|!
name|argw
condition|?
name|OFFS_REG
argument_list|(
name|arg
argument_list|)
else|:
name|TMP_REG3
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|LOAD_DATA
condition|)
return|return
name|PB2
argument_list|(
name|data_transfer_insts
index|[
name|flags
operator|&
name|MEM_MASK
index|]
argument_list|,
name|reg_ar
argument_list|,
name|reg_map
index|[
name|base
index|]
argument_list|)
return|;
else|else
return|return
name|PB2
argument_list|(
name|data_transfer_insts
index|[
name|flags
operator|&
name|MEM_MASK
index|]
argument_list|,
name|reg_map
index|[
name|base
index|]
argument_list|,
name|reg_ar
argument_list|)
return|;
block|}
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|flags
operator|&
name|WRITE_BACK
argument_list|)
operator|&&
name|base
condition|)
block|{
comment|/* Update only applies if a base register exists. */
if|if
condition|(
name|reg_ar
operator|==
name|reg_map
index|[
name|base
index|]
condition|)
block|{
name|SLJIT_ASSERT
argument_list|(
operator|!
operator|(
name|flags
operator|&
name|LOAD_DATA
operator|)
operator|&&
name|TMP_REG1_mapped
operator|!=
name|reg_ar
argument_list|)
expr_stmt|;
if|if
condition|(
name|argw
operator|<=
name|SIMM_16BIT_MAX
operator|&&
name|argw
operator|>=
name|SIMM_16BIT_MIN
condition|)
block|{
name|FAIL_IF
argument_list|(
name|ADDLI
argument_list|(
name|ADDR_TMP_mapped
argument_list|,
name|reg_map
index|[
name|base
index|]
argument_list|,
name|argw
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|LOAD_DATA
condition|)
name|FAIL_IF
argument_list|(
name|PB2
argument_list|(
name|data_transfer_insts
index|[
name|flags
operator|&
name|MEM_MASK
index|]
argument_list|,
name|reg_ar
argument_list|,
name|ADDR_TMP_mapped
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|FAIL_IF
argument_list|(
name|PB2
argument_list|(
name|data_transfer_insts
index|[
name|flags
operator|&
name|MEM_MASK
index|]
argument_list|,
name|ADDR_TMP_mapped
argument_list|,
name|reg_ar
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|argw
condition|)
return|return
name|ADDLI
argument_list|(
name|reg_map
index|[
name|base
index|]
argument_list|,
name|reg_map
index|[
name|base
index|]
argument_list|,
name|argw
argument_list|)
return|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
name|FAIL_IF
argument_list|(
name|ADD
argument_list|(
name|TMP_REG1_mapped
argument_list|,
name|reg_ar
argument_list|,
name|ZERO
argument_list|)
argument_list|)
expr_stmt|;
name|reg_ar
operator|=
name|TMP_REG1_mapped
expr_stmt|;
block|}
if|if
condition|(
name|argw
operator|<=
name|SIMM_16BIT_MAX
operator|&&
name|argw
operator|>=
name|SIMM_16BIT_MIN
condition|)
block|{
if|if
condition|(
name|argw
condition|)
name|FAIL_IF
argument_list|(
name|ADDLI
argument_list|(
name|reg_map
index|[
name|base
index|]
argument_list|,
name|reg_map
index|[
name|base
index|]
argument_list|,
name|argw
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|compiler
operator|->
name|cache_arg
operator|==
name|SLJIT_MEM
operator|&&
name|argw
operator|-
name|compiler
operator|->
name|cache_argw
operator|<=
name|SIMM_16BIT_MAX
operator|&&
name|argw
operator|-
name|compiler
operator|->
name|cache_argw
operator|>=
name|SIMM_16BIT_MIN
condition|)
block|{
if|if
condition|(
name|argw
operator|!=
name|compiler
operator|->
name|cache_argw
condition|)
block|{
name|FAIL_IF
argument_list|(
name|ADD
argument_list|(
name|TMP_REG3_mapped
argument_list|,
name|TMP_REG3_mapped
argument_list|,
name|argw
operator|-
name|compiler
operator|->
name|cache_argw
argument_list|)
argument_list|)
expr_stmt|;
name|compiler
operator|->
name|cache_argw
operator|=
name|argw
expr_stmt|;
block|}
name|FAIL_IF
argument_list|(
name|ADD
argument_list|(
name|reg_map
index|[
name|base
index|]
argument_list|,
name|reg_map
index|[
name|base
index|]
argument_list|,
name|TMP_REG3_mapped
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|compiler
operator|->
name|cache_arg
operator|=
name|SLJIT_MEM
expr_stmt|;
name|compiler
operator|->
name|cache_argw
operator|=
name|argw
expr_stmt|;
name|FAIL_IF
argument_list|(
name|load_immediate
argument_list|(
name|compiler
argument_list|,
name|TMP_REG3_mapped
argument_list|,
name|argw
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|ADD
argument_list|(
name|reg_map
index|[
name|base
index|]
argument_list|,
name|reg_map
index|[
name|base
index|]
argument_list|,
name|TMP_REG3_mapped
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|flags
operator|&
name|LOAD_DATA
condition|)
return|return
name|PB2
argument_list|(
name|data_transfer_insts
index|[
name|flags
operator|&
name|MEM_MASK
index|]
argument_list|,
name|reg_ar
argument_list|,
name|reg_map
index|[
name|base
index|]
argument_list|)
return|;
else|else
return|return
name|PB2
argument_list|(
name|data_transfer_insts
index|[
name|flags
operator|&
name|MEM_MASK
index|]
argument_list|,
name|reg_map
index|[
name|base
index|]
argument_list|,
name|reg_ar
argument_list|)
return|;
block|}
if|if
condition|(
name|compiler
operator|->
name|cache_arg
operator|==
name|arg
operator|&&
name|argw
operator|-
name|compiler
operator|->
name|cache_argw
operator|<=
name|SIMM_16BIT_MAX
operator|&&
name|argw
operator|-
name|compiler
operator|->
name|cache_argw
operator|>=
name|SIMM_16BIT_MIN
condition|)
block|{
if|if
condition|(
name|argw
operator|!=
name|compiler
operator|->
name|cache_argw
condition|)
block|{
name|FAIL_IF
argument_list|(
name|ADDLI
argument_list|(
name|TMP_REG3_mapped
argument_list|,
name|TMP_REG3_mapped
argument_list|,
name|argw
operator|-
name|compiler
operator|->
name|cache_argw
argument_list|)
argument_list|)
expr_stmt|;
name|compiler
operator|->
name|cache_argw
operator|=
name|argw
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|LOAD_DATA
condition|)
return|return
name|PB2
argument_list|(
name|data_transfer_insts
index|[
name|flags
operator|&
name|MEM_MASK
index|]
argument_list|,
name|reg_ar
argument_list|,
name|TMP_REG3_mapped
argument_list|)
return|;
else|else
return|return
name|PB2
argument_list|(
name|data_transfer_insts
index|[
name|flags
operator|&
name|MEM_MASK
index|]
argument_list|,
name|TMP_REG3_mapped
argument_list|,
name|reg_ar
argument_list|)
return|;
block|}
if|if
condition|(
name|compiler
operator|->
name|cache_arg
operator|==
name|SLJIT_MEM
operator|&&
name|argw
operator|-
name|compiler
operator|->
name|cache_argw
operator|<=
name|SIMM_16BIT_MAX
operator|&&
name|argw
operator|-
name|compiler
operator|->
name|cache_argw
operator|>=
name|SIMM_16BIT_MIN
condition|)
block|{
if|if
condition|(
name|argw
operator|!=
name|compiler
operator|->
name|cache_argw
condition|)
name|FAIL_IF
argument_list|(
name|ADDLI
argument_list|(
name|TMP_REG3_mapped
argument_list|,
name|TMP_REG3_mapped
argument_list|,
name|argw
operator|-
name|compiler
operator|->
name|cache_argw
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|compiler
operator|->
name|cache_arg
operator|=
name|SLJIT_MEM
expr_stmt|;
name|FAIL_IF
argument_list|(
name|load_immediate
argument_list|(
name|compiler
argument_list|,
name|TMP_REG3_mapped
argument_list|,
name|argw
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|compiler
operator|->
name|cache_argw
operator|=
name|argw
expr_stmt|;
if|if
condition|(
operator|!
name|base
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|LOAD_DATA
condition|)
return|return
name|PB2
argument_list|(
name|data_transfer_insts
index|[
name|flags
operator|&
name|MEM_MASK
index|]
argument_list|,
name|reg_ar
argument_list|,
name|TMP_REG3_mapped
argument_list|)
return|;
else|else
return|return
name|PB2
argument_list|(
name|data_transfer_insts
index|[
name|flags
operator|&
name|MEM_MASK
index|]
argument_list|,
name|TMP_REG3_mapped
argument_list|,
name|reg_ar
argument_list|)
return|;
block|}
if|if
condition|(
name|arg
operator|==
name|next_arg
operator|&&
name|next_argw
operator|-
name|argw
operator|<=
name|SIMM_16BIT_MAX
operator|&&
name|next_argw
operator|-
name|argw
operator|>=
name|SIMM_16BIT_MIN
condition|)
block|{
name|compiler
operator|->
name|cache_arg
operator|=
name|arg
expr_stmt|;
name|FAIL_IF
argument_list|(
name|ADD
argument_list|(
name|TMP_REG3_mapped
argument_list|,
name|TMP_REG3_mapped
argument_list|,
name|reg_map
index|[
name|base
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|LOAD_DATA
condition|)
return|return
name|PB2
argument_list|(
name|data_transfer_insts
index|[
name|flags
operator|&
name|MEM_MASK
index|]
argument_list|,
name|reg_ar
argument_list|,
name|TMP_REG3_mapped
argument_list|)
return|;
else|else
return|return
name|PB2
argument_list|(
name|data_transfer_insts
index|[
name|flags
operator|&
name|MEM_MASK
index|]
argument_list|,
name|TMP_REG3_mapped
argument_list|,
name|reg_ar
argument_list|)
return|;
block|}
name|FAIL_IF
argument_list|(
name|ADD
argument_list|(
name|tmp_ar
argument_list|,
name|TMP_REG3_mapped
argument_list|,
name|reg_map
index|[
name|base
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|LOAD_DATA
condition|)
return|return
name|PB2
argument_list|(
name|data_transfer_insts
index|[
name|flags
operator|&
name|MEM_MASK
index|]
argument_list|,
name|reg_ar
argument_list|,
name|tmp_ar
argument_list|)
return|;
else|else
return|return
name|PB2
argument_list|(
name|data_transfer_insts
index|[
name|flags
operator|&
name|MEM_MASK
index|]
argument_list|,
name|tmp_ar
argument_list|,
name|reg_ar
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|emit_op_mem
specifier|static
name|SLJIT_INLINE
name|sljit_si
name|emit_op_mem
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|flags
parameter_list|,
name|sljit_si
name|reg_ar
parameter_list|,
name|sljit_si
name|arg
parameter_list|,
name|sljit_sw
name|argw
parameter_list|)
block|{
if|if
condition|(
name|getput_arg_fast
argument_list|(
name|compiler
argument_list|,
name|flags
argument_list|,
name|reg_ar
argument_list|,
name|arg
argument_list|,
name|argw
argument_list|)
condition|)
return|return
name|compiler
operator|->
name|error
return|;
name|compiler
operator|->
name|cache_arg
operator|=
literal|0
expr_stmt|;
name|compiler
operator|->
name|cache_argw
operator|=
literal|0
expr_stmt|;
return|return
name|getput_arg
argument_list|(
name|compiler
argument_list|,
name|flags
argument_list|,
name|reg_ar
argument_list|,
name|arg
argument_list|,
name|argw
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|emit_op_mem2
specifier|static
name|SLJIT_INLINE
name|sljit_si
name|emit_op_mem2
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|flags
parameter_list|,
name|sljit_si
name|reg
parameter_list|,
name|sljit_si
name|arg1
parameter_list|,
name|sljit_sw
name|arg1w
parameter_list|,
name|sljit_si
name|arg2
parameter_list|,
name|sljit_sw
name|arg2w
parameter_list|)
block|{
if|if
condition|(
name|getput_arg_fast
argument_list|(
name|compiler
argument_list|,
name|flags
argument_list|,
name|reg
argument_list|,
name|arg1
argument_list|,
name|arg1w
argument_list|)
condition|)
return|return
name|compiler
operator|->
name|error
return|;
return|return
name|getput_arg
argument_list|(
name|compiler
argument_list|,
name|flags
argument_list|,
name|reg
argument_list|,
name|arg1
argument_list|,
name|arg1w
argument_list|,
name|arg2
argument_list|,
name|arg2w
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_fast_enter
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_fast_enter
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|)
block|{
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|check_sljit_emit_fast_enter
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|ADJUST_LOCAL_OFFSET
argument_list|(
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
comment|/* For UNUSED dst. Uncommon, but possible. */
if|if
condition|(
name|dst
operator|==
name|SLJIT_UNUSED
condition|)
return|return
name|SLJIT_SUCCESS
return|;
if|if
condition|(
name|FAST_IS_REG
argument_list|(
name|dst
argument_list|)
condition|)
return|return
name|ADD
argument_list|(
name|reg_map
index|[
name|dst
index|]
argument_list|,
name|RA
argument_list|,
name|ZERO
argument_list|)
return|;
comment|/* Memory. */
return|return
name|emit_op_mem
argument_list|(
name|compiler
argument_list|,
name|WORD_DATA
argument_list|,
name|RA
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_fast_return
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_fast_return
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|)
block|{
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|check_sljit_emit_fast_return
argument_list|(
name|compiler
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|ADJUST_LOCAL_OFFSET
argument_list|(
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
if|if
condition|(
name|FAST_IS_REG
argument_list|(
name|src
argument_list|)
condition|)
name|FAIL_IF
argument_list|(
name|ADD
argument_list|(
name|RA
argument_list|,
name|reg_map
index|[
name|src
index|]
argument_list|,
name|ZERO
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|src
operator|&
name|SLJIT_MEM
condition|)
name|FAIL_IF
argument_list|(
name|emit_op_mem
argument_list|(
name|compiler
argument_list|,
name|WORD_DATA
operator||
name|LOAD_DATA
argument_list|,
name|RA
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|src
operator|&
name|SLJIT_IMM
condition|)
name|FAIL_IF
argument_list|(
name|load_immediate
argument_list|(
name|compiler
argument_list|,
name|RA
argument_list|,
name|srcw
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|JR
argument_list|(
name|RA
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|emit_single_op
specifier|static
name|SLJIT_INLINE
name|sljit_si
name|emit_single_op
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|flags
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_si
name|src1
parameter_list|,
name|sljit_sw
name|src2
parameter_list|)
block|{
name|sljit_si
name|overflow_ra
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|SLJIT_MOV
case|:
case|case
name|SLJIT_MOV_P
case|:
name|SLJIT_ASSERT
argument_list|(
name|src1
operator|==
name|TMP_REG1
operator|&&
operator|!
operator|(
name|flags
operator|&
name|SRC2_IMM
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|!=
name|src2
condition|)
return|return
name|ADD
argument_list|(
name|reg_map
index|[
name|dst
index|]
argument_list|,
name|reg_map
index|[
name|src2
index|]
argument_list|,
name|ZERO
argument_list|)
return|;
return|return
name|SLJIT_SUCCESS
return|;
case|case
name|SLJIT_MOV_UI
case|:
case|case
name|SLJIT_MOV_SI
case|:
name|SLJIT_ASSERT
argument_list|(
name|src1
operator|==
name|TMP_REG1
operator|&&
operator|!
operator|(
name|flags
operator|&
name|SRC2_IMM
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|REG_DEST
operator||
name|REG2_SOURCE
operator|)
operator|)
operator|==
operator|(
name|REG_DEST
operator||
name|REG2_SOURCE
operator|)
condition|)
block|{
if|if
condition|(
name|op
operator|==
name|SLJIT_MOV_SI
condition|)
return|return
name|BFEXTS
argument_list|(
name|reg_map
index|[
name|dst
index|]
argument_list|,
name|reg_map
index|[
name|src2
index|]
argument_list|,
literal|0
argument_list|,
literal|31
argument_list|)
return|;
return|return
name|BFEXTU
argument_list|(
name|reg_map
index|[
name|dst
index|]
argument_list|,
name|reg_map
index|[
name|src2
index|]
argument_list|,
literal|0
argument_list|,
literal|31
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|dst
operator|!=
name|src2
condition|)
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
case|case
name|SLJIT_MOV_UB
case|:
case|case
name|SLJIT_MOV_SB
case|:
name|SLJIT_ASSERT
argument_list|(
name|src1
operator|==
name|TMP_REG1
operator|&&
operator|!
operator|(
name|flags
operator|&
name|SRC2_IMM
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|REG_DEST
operator||
name|REG2_SOURCE
operator|)
operator|)
operator|==
operator|(
name|REG_DEST
operator||
name|REG2_SOURCE
operator|)
condition|)
block|{
if|if
condition|(
name|op
operator|==
name|SLJIT_MOV_SB
condition|)
return|return
name|BFEXTS
argument_list|(
name|reg_map
index|[
name|dst
index|]
argument_list|,
name|reg_map
index|[
name|src2
index|]
argument_list|,
literal|0
argument_list|,
literal|7
argument_list|)
return|;
return|return
name|BFEXTU
argument_list|(
name|reg_map
index|[
name|dst
index|]
argument_list|,
name|reg_map
index|[
name|src2
index|]
argument_list|,
literal|0
argument_list|,
literal|7
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|dst
operator|!=
name|src2
condition|)
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
case|case
name|SLJIT_MOV_UH
case|:
case|case
name|SLJIT_MOV_SH
case|:
name|SLJIT_ASSERT
argument_list|(
name|src1
operator|==
name|TMP_REG1
operator|&&
operator|!
operator|(
name|flags
operator|&
name|SRC2_IMM
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|REG_DEST
operator||
name|REG2_SOURCE
operator|)
operator|)
operator|==
operator|(
name|REG_DEST
operator||
name|REG2_SOURCE
operator|)
condition|)
block|{
if|if
condition|(
name|op
operator|==
name|SLJIT_MOV_SH
condition|)
return|return
name|BFEXTS
argument_list|(
name|reg_map
index|[
name|dst
index|]
argument_list|,
name|reg_map
index|[
name|src2
index|]
argument_list|,
literal|0
argument_list|,
literal|15
argument_list|)
return|;
return|return
name|BFEXTU
argument_list|(
name|reg_map
index|[
name|dst
index|]
argument_list|,
name|reg_map
index|[
name|src2
index|]
argument_list|,
literal|0
argument_list|,
literal|15
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|dst
operator|!=
name|src2
condition|)
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
case|case
name|SLJIT_NOT
case|:
name|SLJIT_ASSERT
argument_list|(
name|src1
operator|==
name|TMP_REG1
operator|&&
operator|!
operator|(
name|flags
operator|&
name|SRC2_IMM
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|&
name|SLJIT_SET_E
condition|)
name|FAIL_IF
argument_list|(
name|NOR
argument_list|(
name|EQUAL_FLAG
argument_list|,
name|reg_map
index|[
name|src2
index|]
argument_list|,
name|reg_map
index|[
name|src2
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|CHECK_FLAGS
argument_list|(
name|SLJIT_SET_E
argument_list|)
condition|)
name|FAIL_IF
argument_list|(
name|NOR
argument_list|(
name|reg_map
index|[
name|dst
index|]
argument_list|,
name|reg_map
index|[
name|src2
index|]
argument_list|,
name|reg_map
index|[
name|src2
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
case|case
name|SLJIT_CLZ
case|:
name|SLJIT_ASSERT
argument_list|(
name|src1
operator|==
name|TMP_REG1
operator|&&
operator|!
operator|(
name|flags
operator|&
name|SRC2_IMM
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|&
name|SLJIT_SET_E
condition|)
name|FAIL_IF
argument_list|(
name|CLZ
argument_list|(
name|EQUAL_FLAG
argument_list|,
name|reg_map
index|[
name|src2
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|CHECK_FLAGS
argument_list|(
name|SLJIT_SET_E
argument_list|)
condition|)
name|FAIL_IF
argument_list|(
name|CLZ
argument_list|(
name|reg_map
index|[
name|dst
index|]
argument_list|,
name|reg_map
index|[
name|src2
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
case|case
name|SLJIT_ADD
case|:
if|if
condition|(
name|flags
operator|&
name|SRC2_IMM
condition|)
block|{
if|if
condition|(
name|op
operator|&
name|SLJIT_SET_O
condition|)
block|{
name|FAIL_IF
argument_list|(
name|SHRUI
argument_list|(
name|TMP_EREG1
argument_list|,
name|reg_map
index|[
name|src1
index|]
argument_list|,
literal|63
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|src2
operator|<
literal|0
condition|)
name|FAIL_IF
argument_list|(
name|XORI
argument_list|(
name|TMP_EREG1
argument_list|,
name|TMP_EREG1
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|op
operator|&
name|SLJIT_SET_E
condition|)
name|FAIL_IF
argument_list|(
name|ADDLI
argument_list|(
name|EQUAL_FLAG
argument_list|,
name|reg_map
index|[
name|src1
index|]
argument_list|,
name|src2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|&
name|SLJIT_SET_C
condition|)
block|{
if|if
condition|(
name|src2
operator|>=
literal|0
condition|)
name|FAIL_IF
argument_list|(
name|ORI
argument_list|(
name|ULESS_FLAG
argument_list|,
name|reg_map
index|[
name|src1
index|]
argument_list|,
name|src2
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|FAIL_IF
argument_list|(
name|ADDLI
argument_list|(
name|ULESS_FLAG
argument_list|,
name|ZERO
argument_list|,
name|src2
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|OR
argument_list|(
name|ULESS_FLAG
argument_list|,
name|reg_map
index|[
name|src1
index|]
argument_list|,
name|ULESS_FLAG
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* dst may be the same as src1 or src2. */
if|if
condition|(
name|CHECK_FLAGS
argument_list|(
name|SLJIT_SET_E
argument_list|)
condition|)
name|FAIL_IF
argument_list|(
name|ADDLI
argument_list|(
name|reg_map
index|[
name|dst
index|]
argument_list|,
name|reg_map
index|[
name|src1
index|]
argument_list|,
name|src2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|&
name|SLJIT_SET_O
condition|)
block|{
name|FAIL_IF
argument_list|(
name|SHRUI
argument_list|(
name|OVERFLOW_FLAG
argument_list|,
name|reg_map
index|[
name|dst
index|]
argument_list|,
literal|63
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|src2
operator|<
literal|0
condition|)
name|FAIL_IF
argument_list|(
name|XORI
argument_list|(
name|OVERFLOW_FLAG
argument_list|,
name|OVERFLOW_FLAG
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|op
operator|&
name|SLJIT_SET_O
condition|)
block|{
name|FAIL_IF
argument_list|(
name|XOR
argument_list|(
name|TMP_EREG1
argument_list|,
name|reg_map
index|[
name|src1
index|]
argument_list|,
name|reg_map
index|[
name|src2
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|SHRUI
argument_list|(
name|TMP_EREG1
argument_list|,
name|TMP_EREG1
argument_list|,
literal|63
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|src1
operator|!=
name|dst
condition|)
name|overflow_ra
operator|=
name|reg_map
index|[
name|src1
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|src2
operator|!=
name|dst
condition|)
name|overflow_ra
operator|=
name|reg_map
index|[
name|src2
index|]
expr_stmt|;
else|else
block|{
comment|/* Rare ocasion. */
name|FAIL_IF
argument_list|(
name|ADD
argument_list|(
name|TMP_EREG2
argument_list|,
name|reg_map
index|[
name|src1
index|]
argument_list|,
name|ZERO
argument_list|)
argument_list|)
expr_stmt|;
name|overflow_ra
operator|=
name|TMP_EREG2
expr_stmt|;
block|}
block|}
if|if
condition|(
name|op
operator|&
name|SLJIT_SET_E
condition|)
name|FAIL_IF
argument_list|(
name|ADD
argument_list|(
name|EQUAL_FLAG
argument_list|,
name|reg_map
index|[
name|src1
index|]
argument_list|,
name|reg_map
index|[
name|src2
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|&
name|SLJIT_SET_C
condition|)
name|FAIL_IF
argument_list|(
name|OR
argument_list|(
name|ULESS_FLAG
argument_list|,
name|reg_map
index|[
name|src1
index|]
argument_list|,
name|reg_map
index|[
name|src2
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* dst may be the same as src1 or src2. */
if|if
condition|(
name|CHECK_FLAGS
argument_list|(
name|SLJIT_SET_E
argument_list|)
condition|)
name|FAIL_IF
argument_list|(
name|ADD
argument_list|(
name|reg_map
index|[
name|dst
index|]
argument_list|,
name|reg_map
index|[
name|src1
index|]
argument_list|,
name|reg_map
index|[
name|src2
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|&
name|SLJIT_SET_O
condition|)
block|{
name|FAIL_IF
argument_list|(
name|XOR
argument_list|(
name|OVERFLOW_FLAG
argument_list|,
name|reg_map
index|[
name|dst
index|]
argument_list|,
name|overflow_ra
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|SHRUI
argument_list|(
name|OVERFLOW_FLAG
argument_list|,
name|OVERFLOW_FLAG
argument_list|,
literal|63
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* a + b>= a | b (otherwise, the carry should be set to 1). */
if|if
condition|(
name|op
operator|&
name|SLJIT_SET_C
condition|)
name|FAIL_IF
argument_list|(
name|CMPLTU
argument_list|(
name|ULESS_FLAG
argument_list|,
name|reg_map
index|[
name|dst
index|]
argument_list|,
name|ULESS_FLAG
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|&
name|SLJIT_SET_O
condition|)
return|return
name|CMOVNEZ
argument_list|(
name|OVERFLOW_FLAG
argument_list|,
name|TMP_EREG1
argument_list|,
name|ZERO
argument_list|)
return|;
return|return
name|SLJIT_SUCCESS
return|;
case|case
name|SLJIT_ADDC
case|:
if|if
condition|(
name|flags
operator|&
name|SRC2_IMM
condition|)
block|{
if|if
condition|(
name|op
operator|&
name|SLJIT_SET_C
condition|)
block|{
if|if
condition|(
name|src2
operator|>=
literal|0
condition|)
name|FAIL_IF
argument_list|(
name|ORI
argument_list|(
name|TMP_EREG1
argument_list|,
name|reg_map
index|[
name|src1
index|]
argument_list|,
name|src2
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|FAIL_IF
argument_list|(
name|ADDLI
argument_list|(
name|TMP_EREG1
argument_list|,
name|ZERO
argument_list|,
name|src2
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|OR
argument_list|(
name|TMP_EREG1
argument_list|,
name|reg_map
index|[
name|src1
index|]
argument_list|,
name|TMP_EREG1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|FAIL_IF
argument_list|(
name|ADDLI
argument_list|(
name|reg_map
index|[
name|dst
index|]
argument_list|,
name|reg_map
index|[
name|src1
index|]
argument_list|,
name|src2
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|op
operator|&
name|SLJIT_SET_C
condition|)
name|FAIL_IF
argument_list|(
name|OR
argument_list|(
name|TMP_EREG1
argument_list|,
name|reg_map
index|[
name|src1
index|]
argument_list|,
name|reg_map
index|[
name|src2
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* dst may be the same as src1 or src2. */
name|FAIL_IF
argument_list|(
name|ADD
argument_list|(
name|reg_map
index|[
name|dst
index|]
argument_list|,
name|reg_map
index|[
name|src1
index|]
argument_list|,
name|reg_map
index|[
name|src2
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|op
operator|&
name|SLJIT_SET_C
condition|)
name|FAIL_IF
argument_list|(
name|CMPLTU
argument_list|(
name|TMP_EREG1
argument_list|,
name|reg_map
index|[
name|dst
index|]
argument_list|,
name|TMP_EREG1
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|ADD
argument_list|(
name|reg_map
index|[
name|dst
index|]
argument_list|,
name|reg_map
index|[
name|dst
index|]
argument_list|,
name|ULESS_FLAG
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|op
operator|&
name|SLJIT_SET_C
operator|)
condition|)
return|return
name|SLJIT_SUCCESS
return|;
comment|/* Set TMP_EREG2 (dst == 0)&& (ULESS_FLAG == 1). */
name|FAIL_IF
argument_list|(
name|CMPLTUI
argument_list|(
name|TMP_EREG2
argument_list|,
name|reg_map
index|[
name|dst
index|]
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|AND
argument_list|(
name|TMP_EREG2
argument_list|,
name|TMP_EREG2
argument_list|,
name|ULESS_FLAG
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set carry flag. */
return|return
name|OR
argument_list|(
name|ULESS_FLAG
argument_list|,
name|TMP_EREG2
argument_list|,
name|TMP_EREG1
argument_list|)
return|;
case|case
name|SLJIT_SUB
case|:
if|if
condition|(
operator|(
name|flags
operator|&
name|SRC2_IMM
operator|)
operator|&&
operator|(
operator|(
name|op
operator|&
operator|(
name|SLJIT_SET_U
operator||
name|SLJIT_SET_S
operator|)
operator|)
operator|||
name|src2
operator|==
name|SIMM_16BIT_MIN
operator|)
condition|)
block|{
name|FAIL_IF
argument_list|(
name|ADDLI
argument_list|(
name|TMP_REG2_mapped
argument_list|,
name|ZERO
argument_list|,
name|src2
argument_list|)
argument_list|)
expr_stmt|;
name|src2
operator|=
name|TMP_REG2
expr_stmt|;
name|flags
operator|&=
operator|~
name|SRC2_IMM
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|SRC2_IMM
condition|)
block|{
if|if
condition|(
name|op
operator|&
name|SLJIT_SET_O
condition|)
block|{
name|FAIL_IF
argument_list|(
name|SHRUI
argument_list|(
name|TMP_EREG1
argument_list|,
name|reg_map
index|[
name|src1
index|]
argument_list|,
literal|63
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|src2
operator|<
literal|0
condition|)
name|FAIL_IF
argument_list|(
name|XORI
argument_list|(
name|TMP_EREG1
argument_list|,
name|TMP_EREG1
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|src1
operator|!=
name|dst
condition|)
name|overflow_ra
operator|=
name|reg_map
index|[
name|src1
index|]
expr_stmt|;
else|else
block|{
comment|/* Rare ocasion. */
name|FAIL_IF
argument_list|(
name|ADD
argument_list|(
name|TMP_EREG2
argument_list|,
name|reg_map
index|[
name|src1
index|]
argument_list|,
name|ZERO
argument_list|)
argument_list|)
expr_stmt|;
name|overflow_ra
operator|=
name|TMP_EREG2
expr_stmt|;
block|}
block|}
if|if
condition|(
name|op
operator|&
name|SLJIT_SET_E
condition|)
name|FAIL_IF
argument_list|(
name|ADDLI
argument_list|(
name|EQUAL_FLAG
argument_list|,
name|reg_map
index|[
name|src1
index|]
argument_list|,
operator|-
name|src2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|&
name|SLJIT_SET_C
condition|)
block|{
name|FAIL_IF
argument_list|(
name|load_immediate
argument_list|(
name|compiler
argument_list|,
name|ADDR_TMP_mapped
argument_list|,
name|src2
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|CMPLTU
argument_list|(
name|ULESS_FLAG
argument_list|,
name|reg_map
index|[
name|src1
index|]
argument_list|,
name|ADDR_TMP_mapped
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* dst may be the same as src1 or src2. */
if|if
condition|(
name|CHECK_FLAGS
argument_list|(
name|SLJIT_SET_E
argument_list|)
condition|)
name|FAIL_IF
argument_list|(
name|ADDLI
argument_list|(
name|reg_map
index|[
name|dst
index|]
argument_list|,
name|reg_map
index|[
name|src1
index|]
argument_list|,
operator|-
name|src2
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|op
operator|&
name|SLJIT_SET_O
condition|)
block|{
name|FAIL_IF
argument_list|(
name|XOR
argument_list|(
name|TMP_EREG1
argument_list|,
name|reg_map
index|[
name|src1
index|]
argument_list|,
name|reg_map
index|[
name|src2
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|SHRUI
argument_list|(
name|TMP_EREG1
argument_list|,
name|TMP_EREG1
argument_list|,
literal|63
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|src1
operator|!=
name|dst
condition|)
name|overflow_ra
operator|=
name|reg_map
index|[
name|src1
index|]
expr_stmt|;
else|else
block|{
comment|/* Rare ocasion. */
name|FAIL_IF
argument_list|(
name|ADD
argument_list|(
name|TMP_EREG2
argument_list|,
name|reg_map
index|[
name|src1
index|]
argument_list|,
name|ZERO
argument_list|)
argument_list|)
expr_stmt|;
name|overflow_ra
operator|=
name|TMP_EREG2
expr_stmt|;
block|}
block|}
if|if
condition|(
name|op
operator|&
name|SLJIT_SET_E
condition|)
name|FAIL_IF
argument_list|(
name|SUB
argument_list|(
name|EQUAL_FLAG
argument_list|,
name|reg_map
index|[
name|src1
index|]
argument_list|,
name|reg_map
index|[
name|src2
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|&
operator|(
name|SLJIT_SET_U
operator||
name|SLJIT_SET_C
operator|)
condition|)
name|FAIL_IF
argument_list|(
name|CMPLTU
argument_list|(
name|ULESS_FLAG
argument_list|,
name|reg_map
index|[
name|src1
index|]
argument_list|,
name|reg_map
index|[
name|src2
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|&
name|SLJIT_SET_U
condition|)
name|FAIL_IF
argument_list|(
name|CMPLTU
argument_list|(
name|UGREATER_FLAG
argument_list|,
name|reg_map
index|[
name|src2
index|]
argument_list|,
name|reg_map
index|[
name|src1
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|&
name|SLJIT_SET_S
condition|)
block|{
name|FAIL_IF
argument_list|(
name|CMPLTS
argument_list|(
name|LESS_FLAG
argument_list|,
name|reg_map
index|[
name|src1
index|]
argument_list|,
name|reg_map
index|[
name|src2
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|CMPLTS
argument_list|(
name|GREATER_FLAG
argument_list|,
name|reg_map
index|[
name|src2
index|]
argument_list|,
name|reg_map
index|[
name|src1
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* dst may be the same as src1 or src2. */
if|if
condition|(
name|CHECK_FLAGS
argument_list|(
name|SLJIT_SET_E
operator||
name|SLJIT_SET_U
operator||
name|SLJIT_SET_S
operator||
name|SLJIT_SET_C
argument_list|)
condition|)
name|FAIL_IF
argument_list|(
name|SUB
argument_list|(
name|reg_map
index|[
name|dst
index|]
argument_list|,
name|reg_map
index|[
name|src1
index|]
argument_list|,
name|reg_map
index|[
name|src2
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|op
operator|&
name|SLJIT_SET_O
condition|)
block|{
name|FAIL_IF
argument_list|(
name|XOR
argument_list|(
name|OVERFLOW_FLAG
argument_list|,
name|reg_map
index|[
name|dst
index|]
argument_list|,
name|overflow_ra
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|SHRUI
argument_list|(
name|OVERFLOW_FLAG
argument_list|,
name|OVERFLOW_FLAG
argument_list|,
literal|63
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|CMOVEQZ
argument_list|(
name|OVERFLOW_FLAG
argument_list|,
name|TMP_EREG1
argument_list|,
name|ZERO
argument_list|)
return|;
block|}
return|return
name|SLJIT_SUCCESS
return|;
case|case
name|SLJIT_SUBC
case|:
if|if
condition|(
operator|(
name|flags
operator|&
name|SRC2_IMM
operator|)
operator|&&
name|src2
operator|==
name|SIMM_16BIT_MIN
condition|)
block|{
name|FAIL_IF
argument_list|(
name|ADDLI
argument_list|(
name|TMP_REG2_mapped
argument_list|,
name|ZERO
argument_list|,
name|src2
argument_list|)
argument_list|)
expr_stmt|;
name|src2
operator|=
name|TMP_REG2
expr_stmt|;
name|flags
operator|&=
operator|~
name|SRC2_IMM
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|SRC2_IMM
condition|)
block|{
if|if
condition|(
name|op
operator|&
name|SLJIT_SET_C
condition|)
block|{
name|FAIL_IF
argument_list|(
name|load_immediate
argument_list|(
name|compiler
argument_list|,
name|ADDR_TMP_mapped
argument_list|,
operator|-
name|src2
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|CMPLTU
argument_list|(
name|TMP_EREG1
argument_list|,
name|reg_map
index|[
name|src1
index|]
argument_list|,
name|ADDR_TMP_mapped
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* dst may be the same as src1 or src2. */
name|FAIL_IF
argument_list|(
name|ADDLI
argument_list|(
name|reg_map
index|[
name|dst
index|]
argument_list|,
name|reg_map
index|[
name|src1
index|]
argument_list|,
operator|-
name|src2
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|op
operator|&
name|SLJIT_SET_C
condition|)
name|FAIL_IF
argument_list|(
name|CMPLTU
argument_list|(
name|TMP_EREG1
argument_list|,
name|reg_map
index|[
name|src1
index|]
argument_list|,
name|reg_map
index|[
name|src2
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* dst may be the same as src1 or src2. */
name|FAIL_IF
argument_list|(
name|SUB
argument_list|(
name|reg_map
index|[
name|dst
index|]
argument_list|,
name|reg_map
index|[
name|src1
index|]
argument_list|,
name|reg_map
index|[
name|src2
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|op
operator|&
name|SLJIT_SET_C
condition|)
name|FAIL_IF
argument_list|(
name|CMOVEQZ
argument_list|(
name|TMP_EREG1
argument_list|,
name|reg_map
index|[
name|dst
index|]
argument_list|,
name|ULESS_FLAG
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|SUB
argument_list|(
name|reg_map
index|[
name|dst
index|]
argument_list|,
name|reg_map
index|[
name|dst
index|]
argument_list|,
name|ULESS_FLAG
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|&
name|SLJIT_SET_C
condition|)
name|FAIL_IF
argument_list|(
name|ADD
argument_list|(
name|ULESS_FLAG
argument_list|,
name|TMP_EREG1
argument_list|,
name|ZERO
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
DECL|macro|EMIT_LOGICAL
define|#
directive|define
name|EMIT_LOGICAL
parameter_list|(
name|op_imm
parameter_list|,
name|op_norm
parameter_list|)
define|\
value|if (flags& SRC2_IMM) { \ 		FAIL_IF(load_immediate(compiler, ADDR_TMP_mapped, src2)); \ 		if (op& SLJIT_SET_E) \ 			FAIL_IF(push_3_buffer( \ 				compiler, op_norm, EQUAL_FLAG, reg_map[src1], \ 				ADDR_TMP_mapped, __LINE__)); \ 		if (CHECK_FLAGS(SLJIT_SET_E)) \ 			FAIL_IF(push_3_buffer( \ 				compiler, op_norm, reg_map[dst], reg_map[src1], \ 				ADDR_TMP_mapped, __LINE__)); \ 	} else { \ 		if (op& SLJIT_SET_E) \ 			FAIL_IF(push_3_buffer( \ 				compiler, op_norm, EQUAL_FLAG, reg_map[src1], \ 				reg_map[src2], __LINE__)); \ 		if (CHECK_FLAGS(SLJIT_SET_E)) \ 			FAIL_IF(push_3_buffer( \ 				compiler, op_norm, reg_map[dst], reg_map[src1], \ 				reg_map[src2], __LINE__)); \ 	}
case|case
name|SLJIT_AND
case|:
name|EMIT_LOGICAL
argument_list|(
name|TILEGX_OPC_ANDI
argument_list|,
name|TILEGX_OPC_AND
argument_list|)
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
case|case
name|SLJIT_OR
case|:
name|EMIT_LOGICAL
argument_list|(
name|TILEGX_OPC_ORI
argument_list|,
name|TILEGX_OPC_OR
argument_list|)
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
case|case
name|SLJIT_XOR
case|:
name|EMIT_LOGICAL
argument_list|(
name|TILEGX_OPC_XORI
argument_list|,
name|TILEGX_OPC_XOR
argument_list|)
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
DECL|macro|EMIT_SHIFT
define|#
directive|define
name|EMIT_SHIFT
parameter_list|(
name|op_imm
parameter_list|,
name|op_norm
parameter_list|)
define|\
value|if (flags& SRC2_IMM) { \ 		if (op& SLJIT_SET_E) \ 			FAIL_IF(push_3_buffer( \ 				compiler, op_imm, EQUAL_FLAG, reg_map[src1], \ 				src2& 0x3F, __LINE__)); \ 		if (CHECK_FLAGS(SLJIT_SET_E)) \ 			FAIL_IF(push_3_buffer( \ 				compiler, op_imm, reg_map[dst], reg_map[src1], \ 				src2& 0x3F, __LINE__)); \ 	} else { \ 		if (op& SLJIT_SET_E) \ 			FAIL_IF(push_3_buffer( \ 				compiler, op_imm, reg_map[dst], reg_map[src1], \ 				src2& 0x3F, __LINE__)); \ 		if (CHECK_FLAGS(SLJIT_SET_E)) \ 			FAIL_IF(push_3_buffer( \ 				compiler, op_norm, reg_map[dst], reg_map[src1], \ 				reg_map[src2], __LINE__)); \ 	}
case|case
name|SLJIT_SHL
case|:
name|EMIT_SHIFT
argument_list|(
name|TILEGX_OPC_SHLI
argument_list|,
name|TILEGX_OPC_SHL
argument_list|)
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
case|case
name|SLJIT_LSHR
case|:
name|EMIT_SHIFT
argument_list|(
name|TILEGX_OPC_SHRUI
argument_list|,
name|TILEGX_OPC_SHRU
argument_list|)
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
case|case
name|SLJIT_ASHR
case|:
name|EMIT_SHIFT
argument_list|(
name|TILEGX_OPC_SHRSI
argument_list|,
name|TILEGX_OPC_SHRS
argument_list|)
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_function
DECL|function|emit_op
specifier|static
name|sljit_si
name|emit_op
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|flags
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src1
parameter_list|,
name|sljit_sw
name|src1w
parameter_list|,
name|sljit_si
name|src2
parameter_list|,
name|sljit_sw
name|src2w
parameter_list|)
block|{
comment|/* arg1 goes to TMP_REG1 or src reg. 	   arg2 goes to TMP_REG2, imm or src reg. 	   TMP_REG3 can be used for caching. 	   result goes to TMP_REG2, so put result can use TMP_REG1 and TMP_REG3. */
name|sljit_si
name|dst_r
init|=
name|TMP_REG2
decl_stmt|;
name|sljit_si
name|src1_r
decl_stmt|;
name|sljit_sw
name|src2_r
init|=
literal|0
decl_stmt|;
name|sljit_si
name|sugg_src2_r
init|=
name|TMP_REG2
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|ALT_KEEP_CACHE
operator|)
condition|)
block|{
name|compiler
operator|->
name|cache_arg
operator|=
literal|0
expr_stmt|;
name|compiler
operator|->
name|cache_argw
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|dst
operator|==
name|SLJIT_UNUSED
argument_list|)
condition|)
block|{
if|if
condition|(
name|op
operator|>=
name|SLJIT_MOV
operator|&&
name|op
operator|<=
name|SLJIT_MOVU_SI
operator|&&
operator|!
operator|(
name|src2
operator|&
name|SLJIT_MEM
operator|)
condition|)
return|return
name|SLJIT_SUCCESS
return|;
if|if
condition|(
name|GET_FLAGS
argument_list|(
name|op
argument_list|)
condition|)
name|flags
operator||=
name|UNUSED_DEST
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|FAST_IS_REG
argument_list|(
name|dst
argument_list|)
condition|)
block|{
name|dst_r
operator|=
name|dst
expr_stmt|;
name|flags
operator||=
name|REG_DEST
expr_stmt|;
if|if
condition|(
name|op
operator|>=
name|SLJIT_MOV
operator|&&
name|op
operator|<=
name|SLJIT_MOVU_SI
condition|)
name|sugg_src2_r
operator|=
name|dst_r
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|dst
operator|&
name|SLJIT_MEM
operator|)
operator|&&
operator|!
name|getput_arg_fast
argument_list|(
name|compiler
argument_list|,
name|flags
operator||
name|ARG_TEST
argument_list|,
name|TMP_REG1_mapped
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
condition|)
name|flags
operator||=
name|SLOW_DEST
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|IMM_OP
condition|)
block|{
if|if
condition|(
operator|(
name|src2
operator|&
name|SLJIT_IMM
operator|)
operator|&&
name|src2w
condition|)
block|{
if|if
condition|(
operator|(
operator|!
operator|(
name|flags
operator|&
name|LOGICAL_OP
operator|)
operator|&&
operator|(
name|src2w
operator|<=
name|SIMM_16BIT_MAX
operator|&&
name|src2w
operator|>=
name|SIMM_16BIT_MIN
operator|)
operator|)
operator|||
operator|(
operator|(
name|flags
operator|&
name|LOGICAL_OP
operator|)
operator|&&
operator|!
operator|(
name|src2w
operator|&
operator|~
name|UIMM_16BIT_MAX
operator|)
operator|)
condition|)
block|{
name|flags
operator||=
name|SRC2_IMM
expr_stmt|;
name|src2_r
operator|=
name|src2w
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SRC2_IMM
operator|)
operator|&&
operator|(
name|flags
operator|&
name|CUMULATIVE_OP
operator|)
operator|&&
operator|(
name|src1
operator|&
name|SLJIT_IMM
operator|)
operator|&&
name|src1w
condition|)
block|{
if|if
condition|(
operator|(
operator|!
operator|(
name|flags
operator|&
name|LOGICAL_OP
operator|)
operator|&&
operator|(
name|src1w
operator|<=
name|SIMM_16BIT_MAX
operator|&&
name|src1w
operator|>=
name|SIMM_16BIT_MIN
operator|)
operator|)
operator|||
operator|(
operator|(
name|flags
operator|&
name|LOGICAL_OP
operator|)
operator|&&
operator|!
operator|(
name|src1w
operator|&
operator|~
name|UIMM_16BIT_MAX
operator|)
operator|)
condition|)
block|{
name|flags
operator||=
name|SRC2_IMM
expr_stmt|;
name|src2_r
operator|=
name|src1w
expr_stmt|;
comment|/* And swap arguments. */
name|src1
operator|=
name|src2
expr_stmt|;
name|src1w
operator|=
name|src2w
expr_stmt|;
name|src2
operator|=
name|SLJIT_IMM
expr_stmt|;
comment|/* src2w = src2_r unneeded. */
block|}
block|}
block|}
comment|/* Source 1. */
if|if
condition|(
name|FAST_IS_REG
argument_list|(
name|src1
argument_list|)
condition|)
block|{
name|src1_r
operator|=
name|src1
expr_stmt|;
name|flags
operator||=
name|REG1_SOURCE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|src1
operator|&
name|SLJIT_IMM
condition|)
block|{
if|if
condition|(
name|src1w
condition|)
block|{
name|FAIL_IF
argument_list|(
name|load_immediate
argument_list|(
name|compiler
argument_list|,
name|TMP_REG1_mapped
argument_list|,
name|src1w
argument_list|)
argument_list|)
expr_stmt|;
name|src1_r
operator|=
name|TMP_REG1
expr_stmt|;
block|}
else|else
name|src1_r
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|getput_arg_fast
argument_list|(
name|compiler
argument_list|,
name|flags
operator||
name|LOAD_DATA
argument_list|,
name|TMP_REG1_mapped
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
condition|)
name|FAIL_IF
argument_list|(
name|compiler
operator|->
name|error
argument_list|)
expr_stmt|;
else|else
name|flags
operator||=
name|SLOW_SRC1
expr_stmt|;
name|src1_r
operator|=
name|TMP_REG1
expr_stmt|;
block|}
comment|/* Source 2. */
if|if
condition|(
name|FAST_IS_REG
argument_list|(
name|src2
argument_list|)
condition|)
block|{
name|src2_r
operator|=
name|src2
expr_stmt|;
name|flags
operator||=
name|REG2_SOURCE
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|REG_DEST
operator|)
operator|&&
name|op
operator|>=
name|SLJIT_MOV
operator|&&
name|op
operator|<=
name|SLJIT_MOVU_SI
condition|)
name|dst_r
operator|=
name|src2_r
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|src2
operator|&
name|SLJIT_IMM
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SRC2_IMM
operator|)
condition|)
block|{
if|if
condition|(
name|src2w
condition|)
block|{
name|FAIL_IF
argument_list|(
name|load_immediate
argument_list|(
name|compiler
argument_list|,
name|reg_map
index|[
name|sugg_src2_r
index|]
argument_list|,
name|src2w
argument_list|)
argument_list|)
expr_stmt|;
name|src2_r
operator|=
name|sugg_src2_r
expr_stmt|;
block|}
else|else
block|{
name|src2_r
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|op
operator|>=
name|SLJIT_MOV
operator|&&
name|op
operator|<=
name|SLJIT_MOVU_SI
operator|)
operator|&&
operator|(
name|dst
operator|&
name|SLJIT_MEM
operator|)
condition|)
name|dst_r
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|getput_arg_fast
argument_list|(
name|compiler
argument_list|,
name|flags
operator||
name|LOAD_DATA
argument_list|,
name|reg_map
index|[
name|sugg_src2_r
index|]
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
condition|)
name|FAIL_IF
argument_list|(
name|compiler
operator|->
name|error
argument_list|)
expr_stmt|;
else|else
name|flags
operator||=
name|SLOW_SRC2
expr_stmt|;
name|src2_r
operator|=
name|sugg_src2_r
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|SLOW_SRC1
operator||
name|SLOW_SRC2
operator|)
operator|)
operator|==
operator|(
name|SLOW_SRC1
operator||
name|SLOW_SRC2
operator|)
condition|)
block|{
name|SLJIT_ASSERT
argument_list|(
name|src2_r
operator|==
name|TMP_REG2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|can_cache
argument_list|(
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
operator|&&
name|can_cache
argument_list|(
name|src1
argument_list|,
name|src1w
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
condition|)
block|{
name|FAIL_IF
argument_list|(
name|getput_arg
argument_list|(
name|compiler
argument_list|,
name|flags
operator||
name|LOAD_DATA
argument_list|,
name|TMP_REG2_mapped
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|getput_arg
argument_list|(
name|compiler
argument_list|,
name|flags
operator||
name|LOAD_DATA
argument_list|,
name|TMP_REG1_mapped
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|FAIL_IF
argument_list|(
name|getput_arg
argument_list|(
name|compiler
argument_list|,
name|flags
operator||
name|LOAD_DATA
argument_list|,
name|TMP_REG1_mapped
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|getput_arg
argument_list|(
name|compiler
argument_list|,
name|flags
operator||
name|LOAD_DATA
argument_list|,
name|TMP_REG2_mapped
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|SLOW_SRC1
condition|)
name|FAIL_IF
argument_list|(
name|getput_arg
argument_list|(
name|compiler
argument_list|,
name|flags
operator||
name|LOAD_DATA
argument_list|,
name|TMP_REG1_mapped
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|SLOW_SRC2
condition|)
name|FAIL_IF
argument_list|(
name|getput_arg
argument_list|(
name|compiler
argument_list|,
name|flags
operator||
name|LOAD_DATA
argument_list|,
name|reg_map
index|[
name|sugg_src2_r
index|]
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|emit_single_op
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|flags
argument_list|,
name|dst_r
argument_list|,
name|src1_r
argument_list|,
name|src2_r
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|&
name|SLJIT_MEM
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SLOW_DEST
operator|)
condition|)
block|{
name|getput_arg_fast
argument_list|(
name|compiler
argument_list|,
name|flags
argument_list|,
name|reg_map
index|[
name|dst_r
index|]
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
return|return
name|compiler
operator|->
name|error
return|;
block|}
return|return
name|getput_arg
argument_list|(
name|compiler
argument_list|,
name|flags
argument_list|,
name|reg_map
index|[
name|dst_r
index|]
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_op_flags
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_op_flags
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|,
name|sljit_si
name|type
parameter_list|)
block|{
name|sljit_si
name|sugg_dst_ar
decl_stmt|,
name|dst_ar
decl_stmt|;
name|sljit_si
name|flags
init|=
name|GET_ALL_FLAGS
argument_list|(
name|op
argument_list|)
decl_stmt|;
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|check_sljit_emit_op_flags
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|ADJUST_LOCAL_OFFSET
argument_list|(
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|==
name|SLJIT_UNUSED
condition|)
return|return
name|SLJIT_SUCCESS
return|;
name|op
operator|=
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|sugg_dst_ar
operator|=
name|reg_map
index|[
operator|(
name|op
operator|<
name|SLJIT_ADD
operator|&&
name|FAST_IS_REG
argument_list|(
name|dst
argument_list|)
operator|)
condition|?
name|dst
else|:
name|TMP_REG2
index|]
expr_stmt|;
name|compiler
operator|->
name|cache_arg
operator|=
literal|0
expr_stmt|;
name|compiler
operator|->
name|cache_argw
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|op
operator|>=
name|SLJIT_ADD
operator|&&
operator|(
name|src
operator|&
name|SLJIT_MEM
operator|)
condition|)
block|{
name|ADJUST_LOCAL_OFFSET
argument_list|(
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|emit_op_mem2
argument_list|(
name|compiler
argument_list|,
name|WORD_DATA
operator||
name|LOAD_DATA
argument_list|,
name|TMP_REG1_mapped
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
argument_list|)
expr_stmt|;
name|src
operator|=
name|TMP_REG1
expr_stmt|;
name|srcw
operator|=
literal|0
expr_stmt|;
block|}
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SLJIT_C_EQUAL
case|:
case|case
name|SLJIT_C_NOT_EQUAL
case|:
name|FAIL_IF
argument_list|(
name|CMPLTUI
argument_list|(
name|sugg_dst_ar
argument_list|,
name|EQUAL_FLAG
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|dst_ar
operator|=
name|sugg_dst_ar
expr_stmt|;
break|break;
case|case
name|SLJIT_C_LESS
case|:
case|case
name|SLJIT_C_GREATER_EQUAL
case|:
case|case
name|SLJIT_C_FLOAT_LESS
case|:
case|case
name|SLJIT_C_FLOAT_GREATER_EQUAL
case|:
name|dst_ar
operator|=
name|ULESS_FLAG
expr_stmt|;
break|break;
case|case
name|SLJIT_C_GREATER
case|:
case|case
name|SLJIT_C_LESS_EQUAL
case|:
case|case
name|SLJIT_C_FLOAT_GREATER
case|:
case|case
name|SLJIT_C_FLOAT_LESS_EQUAL
case|:
name|dst_ar
operator|=
name|UGREATER_FLAG
expr_stmt|;
break|break;
case|case
name|SLJIT_C_SIG_LESS
case|:
case|case
name|SLJIT_C_SIG_GREATER_EQUAL
case|:
name|dst_ar
operator|=
name|LESS_FLAG
expr_stmt|;
break|break;
case|case
name|SLJIT_C_SIG_GREATER
case|:
case|case
name|SLJIT_C_SIG_LESS_EQUAL
case|:
name|dst_ar
operator|=
name|GREATER_FLAG
expr_stmt|;
break|break;
case|case
name|SLJIT_C_OVERFLOW
case|:
case|case
name|SLJIT_C_NOT_OVERFLOW
case|:
name|dst_ar
operator|=
name|OVERFLOW_FLAG
expr_stmt|;
break|break;
case|case
name|SLJIT_C_MUL_OVERFLOW
case|:
case|case
name|SLJIT_C_MUL_NOT_OVERFLOW
case|:
name|FAIL_IF
argument_list|(
name|CMPLTUI
argument_list|(
name|sugg_dst_ar
argument_list|,
name|OVERFLOW_FLAG
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|dst_ar
operator|=
name|sugg_dst_ar
expr_stmt|;
name|type
operator|^=
literal|0x1
expr_stmt|;
comment|/* Flip type bit for the XORI below. */
break|break;
case|case
name|SLJIT_C_FLOAT_EQUAL
case|:
case|case
name|SLJIT_C_FLOAT_NOT_EQUAL
case|:
name|dst_ar
operator|=
name|EQUAL_FLAG
expr_stmt|;
break|break;
default|default:
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
name|dst_ar
operator|=
name|sugg_dst_ar
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|type
operator|&
literal|0x1
condition|)
block|{
name|FAIL_IF
argument_list|(
name|XORI
argument_list|(
name|sugg_dst_ar
argument_list|,
name|dst_ar
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|dst_ar
operator|=
name|sugg_dst_ar
expr_stmt|;
block|}
if|if
condition|(
name|op
operator|>=
name|SLJIT_ADD
condition|)
block|{
if|if
condition|(
name|TMP_REG2_mapped
operator|!=
name|dst_ar
condition|)
name|FAIL_IF
argument_list|(
name|ADD
argument_list|(
name|TMP_REG2_mapped
argument_list|,
name|dst_ar
argument_list|,
name|ZERO
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|op
operator||
name|flags
argument_list|,
name|CUMULATIVE_OP
operator||
name|LOGICAL_OP
operator||
name|IMM_OP
operator||
name|ALT_KEEP_CACHE
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|,
name|TMP_REG2
argument_list|,
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|dst
operator|&
name|SLJIT_MEM
condition|)
return|return
name|emit_op_mem
argument_list|(
name|compiler
argument_list|,
name|WORD_DATA
argument_list|,
name|dst_ar
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
return|;
if|if
condition|(
name|sugg_dst_ar
operator|!=
name|dst_ar
condition|)
return|return
name|ADD
argument_list|(
name|sugg_dst_ar
argument_list|,
name|dst_ar
argument_list|,
name|ZERO
argument_list|)
return|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_op0
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_op0
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|)
block|{
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|check_sljit_emit_op0
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|op
operator|=
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|SLJIT_NOP
case|:
return|return
name|push_0_buffer
argument_list|(
name|compiler
argument_list|,
name|TILEGX_OPC_FNOP
argument_list|,
name|__LINE__
argument_list|)
return|;
case|case
name|SLJIT_BREAKPOINT
case|:
return|return
name|PI
argument_list|(
name|BPT
argument_list|)
return|;
case|case
name|SLJIT_UMUL
case|:
case|case
name|SLJIT_SMUL
case|:
case|case
name|SLJIT_UDIV
case|:
case|case
name|SLJIT_SDIV
case|:
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
block|}
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_op1
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_op1
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|)
block|{
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|check_sljit_emit_op1
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|ADJUST_LOCAL_OFFSET
argument_list|(
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|ADJUST_LOCAL_OFFSET
argument_list|(
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|SLJIT_MOV
case|:
case|case
name|SLJIT_MOV_P
case|:
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MOV
argument_list|,
name|WORD_DATA
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REG1
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
return|;
case|case
name|SLJIT_MOV_UI
case|:
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MOV_UI
argument_list|,
name|INT_DATA
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REG1
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
return|;
case|case
name|SLJIT_MOV_SI
case|:
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MOV_SI
argument_list|,
name|INT_DATA
operator||
name|SIGNED_DATA
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REG1
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
return|;
case|case
name|SLJIT_MOV_UB
case|:
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MOV_UB
argument_list|,
name|BYTE_DATA
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REG1
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
operator|(
name|src
operator|&
name|SLJIT_IMM
operator|)
condition|?
operator|(
name|sljit_ub
operator|)
name|srcw
else|:
name|srcw
argument_list|)
return|;
case|case
name|SLJIT_MOV_SB
case|:
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MOV_SB
argument_list|,
name|BYTE_DATA
operator||
name|SIGNED_DATA
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REG1
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
operator|(
name|src
operator|&
name|SLJIT_IMM
operator|)
condition|?
operator|(
name|sljit_sb
operator|)
name|srcw
else|:
name|srcw
argument_list|)
return|;
case|case
name|SLJIT_MOV_UH
case|:
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MOV_UH
argument_list|,
name|HALF_DATA
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REG1
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
operator|(
name|src
operator|&
name|SLJIT_IMM
operator|)
condition|?
operator|(
name|sljit_uh
operator|)
name|srcw
else|:
name|srcw
argument_list|)
return|;
case|case
name|SLJIT_MOV_SH
case|:
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MOV_SH
argument_list|,
name|HALF_DATA
operator||
name|SIGNED_DATA
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REG1
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
operator|(
name|src
operator|&
name|SLJIT_IMM
operator|)
condition|?
operator|(
name|sljit_sh
operator|)
name|srcw
else|:
name|srcw
argument_list|)
return|;
case|case
name|SLJIT_MOVU
case|:
case|case
name|SLJIT_MOVU_P
case|:
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MOV
argument_list|,
name|WORD_DATA
operator||
name|WRITE_BACK
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REG1
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
return|;
case|case
name|SLJIT_MOVU_UI
case|:
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MOV_UI
argument_list|,
name|INT_DATA
operator||
name|WRITE_BACK
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REG1
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
return|;
case|case
name|SLJIT_MOVU_SI
case|:
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MOV_SI
argument_list|,
name|INT_DATA
operator||
name|SIGNED_DATA
operator||
name|WRITE_BACK
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REG1
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
return|;
case|case
name|SLJIT_MOVU_UB
case|:
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MOV_UB
argument_list|,
name|BYTE_DATA
operator||
name|WRITE_BACK
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REG1
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
operator|(
name|src
operator|&
name|SLJIT_IMM
operator|)
condition|?
operator|(
name|sljit_ub
operator|)
name|srcw
else|:
name|srcw
argument_list|)
return|;
case|case
name|SLJIT_MOVU_SB
case|:
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MOV_SB
argument_list|,
name|BYTE_DATA
operator||
name|SIGNED_DATA
operator||
name|WRITE_BACK
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REG1
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
operator|(
name|src
operator|&
name|SLJIT_IMM
operator|)
condition|?
operator|(
name|sljit_sb
operator|)
name|srcw
else|:
name|srcw
argument_list|)
return|;
case|case
name|SLJIT_MOVU_UH
case|:
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MOV_UH
argument_list|,
name|HALF_DATA
operator||
name|WRITE_BACK
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REG1
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
operator|(
name|src
operator|&
name|SLJIT_IMM
operator|)
condition|?
operator|(
name|sljit_uh
operator|)
name|srcw
else|:
name|srcw
argument_list|)
return|;
case|case
name|SLJIT_MOVU_SH
case|:
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MOV_SH
argument_list|,
name|HALF_DATA
operator||
name|SIGNED_DATA
operator||
name|WRITE_BACK
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REG1
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
operator|(
name|src
operator|&
name|SLJIT_IMM
operator|)
condition|?
operator|(
name|sljit_sh
operator|)
name|srcw
else|:
name|srcw
argument_list|)
return|;
case|case
name|SLJIT_NOT
case|:
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
literal|0
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REG1
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
return|;
case|case
name|SLJIT_NEG
case|:
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_SUB
operator||
name|GET_ALL_FLAGS
argument_list|(
name|op
argument_list|)
argument_list|,
name|IMM_OP
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
return|;
case|case
name|SLJIT_CLZ
case|:
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
literal|0
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REG1
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
return|;
block|}
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_op2
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_op2
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src1
parameter_list|,
name|sljit_sw
name|src1w
parameter_list|,
name|sljit_si
name|src2
parameter_list|,
name|sljit_sw
name|src2w
parameter_list|)
block|{
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|check_sljit_emit_op2
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
name|ADJUST_LOCAL_OFFSET
argument_list|(
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|ADJUST_LOCAL_OFFSET
argument_list|(
name|src1
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
name|ADJUST_LOCAL_OFFSET
argument_list|(
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|SLJIT_ADD
case|:
case|case
name|SLJIT_ADDC
case|:
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|CUMULATIVE_OP
operator||
name|IMM_OP
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
return|;
case|case
name|SLJIT_SUB
case|:
case|case
name|SLJIT_SUBC
case|:
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|IMM_OP
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
return|;
case|case
name|SLJIT_MUL
case|:
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|CUMULATIVE_OP
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
return|;
case|case
name|SLJIT_AND
case|:
case|case
name|SLJIT_OR
case|:
case|case
name|SLJIT_XOR
case|:
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|CUMULATIVE_OP
operator||
name|LOGICAL_OP
operator||
name|IMM_OP
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
return|;
case|case
name|SLJIT_SHL
case|:
case|case
name|SLJIT_LSHR
case|:
case|case
name|SLJIT_ASHR
case|:
if|if
condition|(
name|src2
operator|&
name|SLJIT_IMM
condition|)
name|src2w
operator|&=
literal|0x3f
expr_stmt|;
if|if
condition|(
name|op
operator|&
name|SLJIT_INT_OP
condition|)
name|src2w
operator|&=
literal|0x1f
expr_stmt|;
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|IMM_OP
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
return|;
block|}
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_label
name|SLJIT_API_FUNC_ATTRIBUTE
name|struct
name|sljit_label
modifier|*
name|sljit_emit_label
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|)
block|{
name|struct
name|sljit_label
modifier|*
name|label
decl_stmt|;
name|flush_buffer
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
name|CHECK_ERROR_PTR
argument_list|()
expr_stmt|;
name|check_sljit_emit_label
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
if|if
condition|(
name|compiler
operator|->
name|last_label
operator|&&
name|compiler
operator|->
name|last_label
operator|->
name|size
operator|==
name|compiler
operator|->
name|size
condition|)
return|return
name|compiler
operator|->
name|last_label
return|;
name|label
operator|=
operator|(
expr|struct
name|sljit_label
operator|*
operator|)
name|ensure_abuf
argument_list|(
name|compiler
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sljit_label
argument_list|)
argument_list|)
expr_stmt|;
name|PTR_FAIL_IF
argument_list|(
operator|!
name|label
argument_list|)
expr_stmt|;
name|set_label
argument_list|(
name|label
argument_list|,
name|compiler
argument_list|)
expr_stmt|;
return|return
name|label
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_ijump
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_ijump
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|type
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|)
block|{
name|sljit_si
name|src_r
init|=
name|TMP_REG2
decl_stmt|;
name|struct
name|sljit_jump
modifier|*
name|jump
init|=
name|NULL
decl_stmt|;
name|flush_buffer
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|check_sljit_emit_ijump
argument_list|(
name|compiler
argument_list|,
name|type
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|ADJUST_LOCAL_OFFSET
argument_list|(
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
if|if
condition|(
name|FAST_IS_REG
argument_list|(
name|src
argument_list|)
condition|)
block|{
if|if
condition|(
name|reg_map
index|[
name|src
index|]
operator|!=
literal|0
condition|)
name|src_r
operator|=
name|src
expr_stmt|;
else|else
name|FAIL_IF
argument_list|(
name|ADD_SOLO
argument_list|(
name|TMP_REG2_mapped
argument_list|,
name|reg_map
index|[
name|src
index|]
argument_list|,
name|ZERO
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|>=
name|SLJIT_CALL0
condition|)
block|{
name|SLJIT_ASSERT
argument_list|(
name|reg_map
index|[
name|PIC_ADDR_REG
index|]
operator|==
literal|16
operator|&&
name|PIC_ADDR_REG
operator|==
name|TMP_REG2
argument_list|)
expr_stmt|;
if|if
condition|(
name|src
operator|&
operator|(
name|SLJIT_IMM
operator||
name|SLJIT_MEM
operator|)
condition|)
block|{
if|if
condition|(
name|src
operator|&
name|SLJIT_IMM
condition|)
name|FAIL_IF
argument_list|(
name|emit_const
argument_list|(
name|compiler
argument_list|,
name|reg_map
index|[
name|PIC_ADDR_REG
index|]
argument_list|,
name|srcw
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|SLJIT_ASSERT
argument_list|(
name|src_r
operator|==
name|TMP_REG2
operator|&&
operator|(
name|src
operator|&
name|SLJIT_MEM
operator|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MOV
argument_list|,
name|WORD_DATA
argument_list|,
name|TMP_REG2
argument_list|,
literal|0
argument_list|,
name|TMP_REG1
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|FAIL_IF
argument_list|(
name|ADD_SOLO
argument_list|(
literal|0
argument_list|,
name|reg_map
index|[
name|SLJIT_SCRATCH_REG1
index|]
argument_list|,
name|ZERO
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|ADDI_SOLO
argument_list|(
literal|54
argument_list|,
literal|54
argument_list|,
operator|-
literal|16
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|JALR_SOLO
argument_list|(
name|reg_map
index|[
name|PIC_ADDR_REG
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ADDI_SOLO
argument_list|(
literal|54
argument_list|,
literal|54
argument_list|,
literal|16
argument_list|)
return|;
block|}
comment|/* Register input. */
if|if
condition|(
name|type
operator|>=
name|SLJIT_CALL1
condition|)
name|FAIL_IF
argument_list|(
name|ADD_SOLO
argument_list|(
literal|0
argument_list|,
name|reg_map
index|[
name|SLJIT_SCRATCH_REG1
index|]
argument_list|,
name|ZERO
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|ADD_SOLO
argument_list|(
name|reg_map
index|[
name|PIC_ADDR_REG
index|]
argument_list|,
name|reg_map
index|[
name|src_r
index|]
argument_list|,
name|ZERO
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|ADDI_SOLO
argument_list|(
literal|54
argument_list|,
literal|54
argument_list|,
operator|-
literal|16
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|JALR_SOLO
argument_list|(
name|reg_map
index|[
name|src_r
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ADDI_SOLO
argument_list|(
literal|54
argument_list|,
literal|54
argument_list|,
literal|16
argument_list|)
return|;
block|}
if|if
condition|(
name|src
operator|&
name|SLJIT_IMM
condition|)
block|{
name|jump
operator|=
operator|(
expr|struct
name|sljit_jump
operator|*
operator|)
name|ensure_abuf
argument_list|(
name|compiler
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sljit_jump
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|jump
argument_list|)
expr_stmt|;
name|set_jump
argument_list|(
name|jump
argument_list|,
name|compiler
argument_list|,
name|JUMP_ADDR
operator||
operator|(
operator|(
name|type
operator|>=
name|SLJIT_FAST_CALL
operator|)
condition|?
name|IS_JAL
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|jump
operator|->
name|u
operator|.
name|target
operator|=
name|srcw
expr_stmt|;
name|FAIL_IF
argument_list|(
name|emit_const
argument_list|(
name|compiler
argument_list|,
name|TMP_REG2_mapped
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|>=
name|SLJIT_FAST_CALL
condition|)
block|{
name|FAIL_IF
argument_list|(
name|ADD_SOLO
argument_list|(
name|ZERO
argument_list|,
name|ZERO
argument_list|,
name|ZERO
argument_list|)
argument_list|)
expr_stmt|;
name|jump
operator|->
name|addr
operator|=
name|compiler
operator|->
name|size
expr_stmt|;
name|FAIL_IF
argument_list|(
name|JR_SOLO
argument_list|(
name|reg_map
index|[
name|src_r
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|jump
operator|->
name|addr
operator|=
name|compiler
operator|->
name|size
expr_stmt|;
name|FAIL_IF
argument_list|(
name|JR_SOLO
argument_list|(
name|reg_map
index|[
name|src_r
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SLJIT_SUCCESS
return|;
block|}
elseif|else
if|if
condition|(
name|src
operator|&
name|SLJIT_MEM
condition|)
name|FAIL_IF
argument_list|(
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MOV
argument_list|,
name|WORD_DATA
argument_list|,
name|TMP_REG2
argument_list|,
literal|0
argument_list|,
name|TMP_REG1
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|JR_SOLO
argument_list|(
name|reg_map
index|[
name|src_r
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|jump
condition|)
name|jump
operator|->
name|addr
operator|=
name|compiler
operator|->
name|size
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_define
DECL|macro|BR_Z
define|#
directive|define
name|BR_Z
parameter_list|(
name|src
parameter_list|)
define|\
value|inst = BEQZ_X1 | SRCA_X1(src); \ 	flags = IS_COND;
end_define
begin_define
DECL|macro|BR_NZ
define|#
directive|define
name|BR_NZ
parameter_list|(
name|src
parameter_list|)
define|\
value|inst = BNEZ_X1 | SRCA_X1(src); \ 	flags = IS_COND;
end_define
begin_function
DECL|function|sljit_emit_jump
name|SLJIT_API_FUNC_ATTRIBUTE
name|struct
name|sljit_jump
modifier|*
name|sljit_emit_jump
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|type
parameter_list|)
block|{
name|struct
name|sljit_jump
modifier|*
name|jump
decl_stmt|;
name|sljit_ins
name|inst
decl_stmt|;
name|sljit_si
name|flags
init|=
literal|0
decl_stmt|;
name|flush_buffer
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
name|CHECK_ERROR_PTR
argument_list|()
expr_stmt|;
name|check_sljit_emit_jump
argument_list|(
name|compiler
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|jump
operator|=
operator|(
expr|struct
name|sljit_jump
operator|*
operator|)
name|ensure_abuf
argument_list|(
name|compiler
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sljit_jump
argument_list|)
argument_list|)
expr_stmt|;
name|PTR_FAIL_IF
argument_list|(
operator|!
name|jump
argument_list|)
expr_stmt|;
name|set_jump
argument_list|(
name|jump
argument_list|,
name|compiler
argument_list|,
name|type
operator|&
name|SLJIT_REWRITABLE_JUMP
argument_list|)
expr_stmt|;
name|type
operator|&=
literal|0xff
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SLJIT_C_EQUAL
case|:
case|case
name|SLJIT_C_FLOAT_NOT_EQUAL
case|:
name|BR_NZ
argument_list|(
name|EQUAL_FLAG
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_C_NOT_EQUAL
case|:
case|case
name|SLJIT_C_FLOAT_EQUAL
case|:
name|BR_Z
argument_list|(
name|EQUAL_FLAG
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_C_LESS
case|:
case|case
name|SLJIT_C_FLOAT_LESS
case|:
name|BR_Z
argument_list|(
name|ULESS_FLAG
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_C_GREATER_EQUAL
case|:
case|case
name|SLJIT_C_FLOAT_GREATER_EQUAL
case|:
name|BR_NZ
argument_list|(
name|ULESS_FLAG
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_C_GREATER
case|:
case|case
name|SLJIT_C_FLOAT_GREATER
case|:
name|BR_Z
argument_list|(
name|UGREATER_FLAG
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_C_LESS_EQUAL
case|:
case|case
name|SLJIT_C_FLOAT_LESS_EQUAL
case|:
name|BR_NZ
argument_list|(
name|UGREATER_FLAG
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_C_SIG_LESS
case|:
name|BR_Z
argument_list|(
name|LESS_FLAG
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_C_SIG_GREATER_EQUAL
case|:
name|BR_NZ
argument_list|(
name|LESS_FLAG
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_C_SIG_GREATER
case|:
name|BR_Z
argument_list|(
name|GREATER_FLAG
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_C_SIG_LESS_EQUAL
case|:
name|BR_NZ
argument_list|(
name|GREATER_FLAG
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_C_OVERFLOW
case|:
case|case
name|SLJIT_C_MUL_OVERFLOW
case|:
name|BR_Z
argument_list|(
name|OVERFLOW_FLAG
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_C_NOT_OVERFLOW
case|:
case|case
name|SLJIT_C_MUL_NOT_OVERFLOW
case|:
name|BR_NZ
argument_list|(
name|OVERFLOW_FLAG
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Not conditional branch. */
name|inst
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|jump
operator|->
name|flags
operator||=
name|flags
expr_stmt|;
if|if
condition|(
name|inst
condition|)
block|{
name|inst
operator|=
name|inst
operator||
operator|(
operator|(
name|type
operator|<=
name|SLJIT_JUMP
operator|)
condition|?
name|BOFF_X1
argument_list|(
literal|5
argument_list|)
else|:
name|BOFF_X1
argument_list|(
literal|6
argument_list|)
operator|)
expr_stmt|;
name|PTR_FAIL_IF
argument_list|(
name|PI
argument_list|(
name|inst
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|PTR_FAIL_IF
argument_list|(
name|emit_const
argument_list|(
name|compiler
argument_list|,
name|TMP_REG2_mapped
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|<=
name|SLJIT_JUMP
condition|)
block|{
name|jump
operator|->
name|addr
operator|=
name|compiler
operator|->
name|size
expr_stmt|;
name|PTR_FAIL_IF
argument_list|(
name|JR_SOLO
argument_list|(
name|TMP_REG2_mapped
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SLJIT_ASSERT
argument_list|(
name|reg_map
index|[
name|PIC_ADDR_REG
index|]
operator|==
literal|16
operator|&&
name|PIC_ADDR_REG
operator|==
name|TMP_REG2
argument_list|)
expr_stmt|;
comment|/* Cannot be optimized out if type is>= CALL0. */
name|jump
operator|->
name|flags
operator||=
name|IS_JAL
operator||
operator|(
name|type
operator|>=
name|SLJIT_CALL0
condition|?
name|SLJIT_REWRITABLE_JUMP
else|:
literal|0
operator|)
expr_stmt|;
name|PTR_FAIL_IF
argument_list|(
name|ADD_SOLO
argument_list|(
literal|0
argument_list|,
name|reg_map
index|[
name|SLJIT_SCRATCH_REG1
index|]
argument_list|,
name|ZERO
argument_list|)
argument_list|)
expr_stmt|;
name|jump
operator|->
name|addr
operator|=
name|compiler
operator|->
name|size
expr_stmt|;
name|PTR_FAIL_IF
argument_list|(
name|JALR_SOLO
argument_list|(
name|TMP_REG2_mapped
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|jump
return|;
block|}
end_function
begin_function
DECL|function|sljit_is_fpu_available
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_is_fpu_available
parameter_list|(
name|void
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_fop1
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_fop1
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|)
block|{
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|sljit_emit_fop2
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_fop2
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src1
parameter_list|,
name|sljit_sw
name|src1w
parameter_list|,
name|sljit_si
name|src2
parameter_list|,
name|sljit_sw
name|src2w
parameter_list|)
block|{
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|sljit_emit_const
name|SLJIT_API_FUNC_ATTRIBUTE
name|struct
name|sljit_const
modifier|*
name|sljit_emit_const
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_sw
name|init_value
parameter_list|)
block|{
name|struct
name|sljit_const
modifier|*
name|const_
decl_stmt|;
name|sljit_si
name|reg
decl_stmt|;
name|flush_buffer
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
name|CHECK_ERROR_PTR
argument_list|()
expr_stmt|;
name|check_sljit_emit_const
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|init_value
argument_list|)
expr_stmt|;
name|ADJUST_LOCAL_OFFSET
argument_list|(
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|const_
operator|=
operator|(
expr|struct
name|sljit_const
operator|*
operator|)
name|ensure_abuf
argument_list|(
name|compiler
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sljit_const
argument_list|)
argument_list|)
expr_stmt|;
name|PTR_FAIL_IF
argument_list|(
operator|!
name|const_
argument_list|)
expr_stmt|;
name|set_const
argument_list|(
name|const_
argument_list|,
name|compiler
argument_list|)
expr_stmt|;
name|reg
operator|=
name|FAST_IS_REG
argument_list|(
name|dst
argument_list|)
condition|?
name|dst
else|:
name|TMP_REG2
expr_stmt|;
name|PTR_FAIL_IF
argument_list|(
name|emit_const_64
argument_list|(
name|compiler
argument_list|,
name|reg
argument_list|,
name|init_value
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|&
name|SLJIT_MEM
condition|)
name|PTR_FAIL_IF
argument_list|(
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MOV
argument_list|,
name|WORD_DATA
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REG1
argument_list|,
literal|0
argument_list|,
name|TMP_REG2
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|const_
return|;
block|}
end_function
begin_function
DECL|function|sljit_set_jump_addr
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
name|sljit_set_jump_addr
parameter_list|(
name|sljit_uw
name|addr
parameter_list|,
name|sljit_uw
name|new_addr
parameter_list|)
block|{
name|sljit_ins
modifier|*
name|inst
init|=
operator|(
name|sljit_ins
operator|*
operator|)
name|addr
decl_stmt|;
name|inst
index|[
literal|0
index|]
operator|=
operator|(
name|inst
index|[
literal|0
index|]
operator|&
operator|~
operator|(
literal|0xFFFFL
operator|<<
literal|43
operator|)
operator|)
operator||
operator|(
operator|(
operator|(
name|new_addr
operator|>>
literal|32
operator|)
operator|&
literal|0xffff
operator|)
operator|<<
literal|43
operator|)
expr_stmt|;
name|inst
index|[
literal|1
index|]
operator|=
operator|(
name|inst
index|[
literal|1
index|]
operator|&
operator|~
operator|(
literal|0xFFFFL
operator|<<
literal|43
operator|)
operator|)
operator||
operator|(
operator|(
operator|(
name|new_addr
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
operator|)
operator|<<
literal|43
operator|)
expr_stmt|;
name|inst
index|[
literal|2
index|]
operator|=
operator|(
name|inst
index|[
literal|2
index|]
operator|&
operator|~
operator|(
literal|0xFFFFL
operator|<<
literal|43
operator|)
operator|)
operator||
operator|(
operator|(
name|new_addr
operator|&
literal|0xffff
operator|)
operator|<<
literal|43
operator|)
expr_stmt|;
name|SLJIT_CACHE_FLUSH
argument_list|(
name|inst
argument_list|,
name|inst
operator|+
literal|3
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|sljit_set_const
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
name|sljit_set_const
parameter_list|(
name|sljit_uw
name|addr
parameter_list|,
name|sljit_sw
name|new_constant
parameter_list|)
block|{
name|sljit_ins
modifier|*
name|inst
init|=
operator|(
name|sljit_ins
operator|*
operator|)
name|addr
decl_stmt|;
name|inst
index|[
literal|0
index|]
operator|=
operator|(
name|inst
index|[
literal|0
index|]
operator|&
operator|~
operator|(
literal|0xFFFFL
operator|<<
literal|43
operator|)
operator|)
operator||
operator|(
operator|(
operator|(
name|new_constant
operator|>>
literal|48
operator|)
operator|&
literal|0xFFFFL
operator|)
operator|<<
literal|43
operator|)
expr_stmt|;
name|inst
index|[
literal|1
index|]
operator|=
operator|(
name|inst
index|[
literal|1
index|]
operator|&
operator|~
operator|(
literal|0xFFFFL
operator|<<
literal|43
operator|)
operator|)
operator||
operator|(
operator|(
operator|(
name|new_constant
operator|>>
literal|32
operator|)
operator|&
literal|0xFFFFL
operator|)
operator|<<
literal|43
operator|)
expr_stmt|;
name|inst
index|[
literal|2
index|]
operator|=
operator|(
name|inst
index|[
literal|2
index|]
operator|&
operator|~
operator|(
literal|0xFFFFL
operator|<<
literal|43
operator|)
operator|)
operator||
operator|(
operator|(
operator|(
name|new_constant
operator|>>
literal|16
operator|)
operator|&
literal|0xFFFFL
operator|)
operator|<<
literal|43
operator|)
expr_stmt|;
name|inst
index|[
literal|3
index|]
operator|=
operator|(
name|inst
index|[
literal|3
index|]
operator|&
operator|~
operator|(
literal|0xFFFFL
operator|<<
literal|43
operator|)
operator|)
operator||
operator|(
operator|(
name|new_constant
operator|&
literal|0xFFFFL
operator|)
operator|<<
literal|43
operator|)
expr_stmt|;
name|SLJIT_CACHE_FLUSH
argument_list|(
name|inst
argument_list|,
name|inst
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
end_function
end_unit
