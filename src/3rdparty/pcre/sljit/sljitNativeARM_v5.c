begin_unit
begin_comment
comment|/*  *    Stack-less Just-In-Time compiler  *  *    Copyright 2009-2012 Zoltan Herczeg (hzmester@freemail.hu). All rights reserved.  *  * Redistribution and use in source and binary forms, with or without modification, are  * permitted provided that the following conditions are met:  *  *   1. Redistributions of source code must retain the above copyright notice, this list of  *      conditions and the following disclaimer.  *  *   2. Redistributions in binary form must reproduce the above copyright notice, this list  *      of conditions and the following disclaimer in the documentation and/or other materials  *      provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER(S) AND CONTRIBUTORS ``AS IS'' AND ANY  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT  * SHALL THE COPYRIGHT HOLDER(S) OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED  * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR  * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment
begin_function
DECL|function|sljit_get_platform_name
name|SLJIT_API_FUNC_ATTRIBUTE
name|SLJIT_CONST
name|char
modifier|*
name|sljit_get_platform_name
parameter_list|(
name|void
parameter_list|)
block|{
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_ARM_V7
operator|&&
name|SLJIT_CONFIG_ARM_V7
operator|)
return|return
literal|"ARMv7"
name|SLJIT_CPUINFO
return|;
elif|#
directive|elif
operator|(
name|defined
name|SLJIT_CONFIG_ARM_V5
operator|&&
name|SLJIT_CONFIG_ARM_V5
operator|)
return|return
literal|"ARMv5"
name|SLJIT_CPUINFO
return|;
else|#
directive|else
error|#
directive|error
literal|"Internal error: Unknown ARM architecture"
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/* Last register + 1. */
end_comment
begin_define
DECL|macro|TMP_REG1
define|#
directive|define
name|TMP_REG1
value|(SLJIT_NO_REGISTERS + 1)
end_define
begin_define
DECL|macro|TMP_REG2
define|#
directive|define
name|TMP_REG2
value|(SLJIT_NO_REGISTERS + 2)
end_define
begin_define
DECL|macro|TMP_REG3
define|#
directive|define
name|TMP_REG3
value|(SLJIT_NO_REGISTERS + 3)
end_define
begin_define
DECL|macro|TMP_PC
define|#
directive|define
name|TMP_PC
value|(SLJIT_NO_REGISTERS + 4)
end_define
begin_define
DECL|macro|TMP_FREG1
define|#
directive|define
name|TMP_FREG1
value|(0)
end_define
begin_define
DECL|macro|TMP_FREG2
define|#
directive|define
name|TMP_FREG2
value|(SLJIT_FLOAT_REG6 + 1)
end_define
begin_comment
comment|/* In ARM instruction words.    Cache lines are usually 32 byte aligned. */
end_comment
begin_define
DECL|macro|CONST_POOL_ALIGNMENT
define|#
directive|define
name|CONST_POOL_ALIGNMENT
value|8
end_define
begin_define
DECL|macro|CONST_POOL_EMPTY
define|#
directive|define
name|CONST_POOL_EMPTY
value|0xffffffff
end_define
begin_define
DECL|macro|ALIGN_INSTRUCTION
define|#
directive|define
name|ALIGN_INSTRUCTION
parameter_list|(
name|ptr
parameter_list|)
define|\
value|(sljit_uw*)(((sljit_uw)(ptr) + (CONST_POOL_ALIGNMENT * sizeof(sljit_uw)) - 1)& ~((CONST_POOL_ALIGNMENT * sizeof(sljit_uw)) - 1))
end_define
begin_define
DECL|macro|MAX_DIFFERENCE
define|#
directive|define
name|MAX_DIFFERENCE
parameter_list|(
name|max_diff
parameter_list|)
define|\
value|(((max_diff) / (sljit_si)sizeof(sljit_uw)) - (CONST_POOL_ALIGNMENT - 1))
end_define
begin_comment
comment|/* See sljit_emit_enter and sljit_emit_op0 if you want to change them. */
end_comment
begin_decl_stmt
DECL|variable|reg_map
specifier|static
name|SLJIT_CONST
name|sljit_ub
name|reg_map
index|[
name|SLJIT_NO_REGISTERS
operator|+
literal|5
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|10
block|,
literal|11
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|13
block|,
literal|3
block|,
literal|12
block|,
literal|14
block|,
literal|15
block|}
decl_stmt|;
end_decl_stmt
begin_define
DECL|macro|RM
define|#
directive|define
name|RM
parameter_list|(
name|rm
parameter_list|)
value|(reg_map[rm])
end_define
begin_define
DECL|macro|RD
define|#
directive|define
name|RD
parameter_list|(
name|rd
parameter_list|)
value|(reg_map[rd]<< 12)
end_define
begin_define
DECL|macro|RN
define|#
directive|define
name|RN
parameter_list|(
name|rn
parameter_list|)
value|(reg_map[rn]<< 16)
end_define
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_comment
comment|/*  Instrucion forms                                                     */
end_comment
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_comment
comment|/* The instruction includes the AL condition.    INST_NAME - CONDITIONAL remove this flag. */
end_comment
begin_define
DECL|macro|COND_MASK
define|#
directive|define
name|COND_MASK
value|0xf0000000
end_define
begin_define
DECL|macro|CONDITIONAL
define|#
directive|define
name|CONDITIONAL
value|0xe0000000
end_define
begin_define
DECL|macro|PUSH_POOL
define|#
directive|define
name|PUSH_POOL
value|0xff000000
end_define
begin_comment
comment|/* DP - Data Processing instruction (use with EMIT_DATA_PROCESS_INS). */
end_comment
begin_define
DECL|macro|ADC_DP
define|#
directive|define
name|ADC_DP
value|0x5
end_define
begin_define
DECL|macro|ADD_DP
define|#
directive|define
name|ADD_DP
value|0x4
end_define
begin_define
DECL|macro|AND_DP
define|#
directive|define
name|AND_DP
value|0x0
end_define
begin_define
DECL|macro|B
define|#
directive|define
name|B
value|0xea000000
end_define
begin_define
DECL|macro|BIC_DP
define|#
directive|define
name|BIC_DP
value|0xe
end_define
begin_define
DECL|macro|BL
define|#
directive|define
name|BL
value|0xeb000000
end_define
begin_define
DECL|macro|BLX
define|#
directive|define
name|BLX
value|0xe12fff30
end_define
begin_define
DECL|macro|BX
define|#
directive|define
name|BX
value|0xe12fff10
end_define
begin_define
DECL|macro|CLZ
define|#
directive|define
name|CLZ
value|0xe16f0f10
end_define
begin_define
DECL|macro|CMP_DP
define|#
directive|define
name|CMP_DP
value|0xa
end_define
begin_define
DECL|macro|BKPT
define|#
directive|define
name|BKPT
value|0xe1200070
end_define
begin_define
DECL|macro|EOR_DP
define|#
directive|define
name|EOR_DP
value|0x1
end_define
begin_define
DECL|macro|MOV_DP
define|#
directive|define
name|MOV_DP
value|0xd
end_define
begin_define
DECL|macro|MUL
define|#
directive|define
name|MUL
value|0xe0000090
end_define
begin_define
DECL|macro|MVN_DP
define|#
directive|define
name|MVN_DP
value|0xf
end_define
begin_define
DECL|macro|NOP
define|#
directive|define
name|NOP
value|0xe1a00000
end_define
begin_define
DECL|macro|ORR_DP
define|#
directive|define
name|ORR_DP
value|0xc
end_define
begin_define
DECL|macro|PUSH
define|#
directive|define
name|PUSH
value|0xe92d0000
end_define
begin_define
DECL|macro|POP
define|#
directive|define
name|POP
value|0xe8bd0000
end_define
begin_define
DECL|macro|RSB_DP
define|#
directive|define
name|RSB_DP
value|0x3
end_define
begin_define
DECL|macro|RSC_DP
define|#
directive|define
name|RSC_DP
value|0x7
end_define
begin_define
DECL|macro|SBC_DP
define|#
directive|define
name|SBC_DP
value|0x6
end_define
begin_define
DECL|macro|SMULL
define|#
directive|define
name|SMULL
value|0xe0c00090
end_define
begin_define
DECL|macro|SUB_DP
define|#
directive|define
name|SUB_DP
value|0x2
end_define
begin_define
DECL|macro|UMULL
define|#
directive|define
name|UMULL
value|0xe0800090
end_define
begin_define
DECL|macro|VABS_F32
define|#
directive|define
name|VABS_F32
value|0xeeb00ac0
end_define
begin_define
DECL|macro|VADD_F32
define|#
directive|define
name|VADD_F32
value|0xee300a00
end_define
begin_define
DECL|macro|VCMP_F32
define|#
directive|define
name|VCMP_F32
value|0xeeb40a40
end_define
begin_define
DECL|macro|VDIV_F32
define|#
directive|define
name|VDIV_F32
value|0xee800a00
end_define
begin_define
DECL|macro|VMOV_F32
define|#
directive|define
name|VMOV_F32
value|0xeeb00a40
end_define
begin_define
DECL|macro|VMRS
define|#
directive|define
name|VMRS
value|0xeef1fa10
end_define
begin_define
DECL|macro|VMUL_F32
define|#
directive|define
name|VMUL_F32
value|0xee200a00
end_define
begin_define
DECL|macro|VNEG_F32
define|#
directive|define
name|VNEG_F32
value|0xeeb10a40
end_define
begin_define
DECL|macro|VSTR_F32
define|#
directive|define
name|VSTR_F32
value|0xed000a00
end_define
begin_define
DECL|macro|VSUB_F32
define|#
directive|define
name|VSUB_F32
value|0xee300a40
end_define
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_ARM_V7
operator|&&
name|SLJIT_CONFIG_ARM_V7
operator|)
end_if
begin_comment
comment|/* Arm v7 specific instructions. */
end_comment
begin_define
DECL|macro|MOVW
define|#
directive|define
name|MOVW
value|0xe3000000
end_define
begin_define
DECL|macro|MOVT
define|#
directive|define
name|MOVT
value|0xe3400000
end_define
begin_define
DECL|macro|SXTB
define|#
directive|define
name|SXTB
value|0xe6af0070
end_define
begin_define
DECL|macro|SXTH
define|#
directive|define
name|SXTH
value|0xe6bf0070
end_define
begin_define
DECL|macro|UXTB
define|#
directive|define
name|UXTB
value|0xe6ef0070
end_define
begin_define
DECL|macro|UXTH
define|#
directive|define
name|UXTH
value|0xe6ff0070
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_ARM_V5
operator|&&
name|SLJIT_CONFIG_ARM_V5
operator|)
end_if
begin_function
DECL|function|push_cpool
specifier|static
name|sljit_si
name|push_cpool
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|)
block|{
comment|/* Pushing the constant pool into the instruction stream. */
name|sljit_uw
modifier|*
name|inst
decl_stmt|;
name|sljit_uw
modifier|*
name|cpool_ptr
decl_stmt|;
name|sljit_uw
modifier|*
name|cpool_end
decl_stmt|;
name|sljit_si
name|i
decl_stmt|;
comment|/* The label could point the address after the constant pool. */
if|if
condition|(
name|compiler
operator|->
name|last_label
operator|&&
name|compiler
operator|->
name|last_label
operator|->
name|size
operator|==
name|compiler
operator|->
name|size
condition|)
name|compiler
operator|->
name|last_label
operator|->
name|size
operator|+=
name|compiler
operator|->
name|cpool_fill
operator|+
operator|(
name|CONST_POOL_ALIGNMENT
operator|-
literal|1
operator|)
operator|+
literal|1
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|compiler
operator|->
name|cpool_fill
operator|>
literal|0
operator|&&
name|compiler
operator|->
name|cpool_fill
operator|<=
name|CPOOL_SIZE
argument_list|)
expr_stmt|;
name|inst
operator|=
operator|(
name|sljit_uw
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
sizeof|sizeof
argument_list|(
name|sljit_uw
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
name|compiler
operator|->
name|size
operator|++
expr_stmt|;
operator|*
name|inst
operator|=
literal|0xff000000
operator||
name|compiler
operator|->
name|cpool_fill
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CONST_POOL_ALIGNMENT
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|inst
operator|=
operator|(
name|sljit_uw
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
sizeof|sizeof
argument_list|(
name|sljit_uw
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
name|compiler
operator|->
name|size
operator|++
expr_stmt|;
operator|*
name|inst
operator|=
literal|0
expr_stmt|;
block|}
name|cpool_ptr
operator|=
name|compiler
operator|->
name|cpool
expr_stmt|;
name|cpool_end
operator|=
name|cpool_ptr
operator|+
name|compiler
operator|->
name|cpool_fill
expr_stmt|;
while|while
condition|(
name|cpool_ptr
operator|<
name|cpool_end
condition|)
block|{
name|inst
operator|=
operator|(
name|sljit_uw
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
sizeof|sizeof
argument_list|(
name|sljit_uw
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
name|compiler
operator|->
name|size
operator|++
expr_stmt|;
operator|*
name|inst
operator|=
operator|*
name|cpool_ptr
operator|++
expr_stmt|;
block|}
name|compiler
operator|->
name|cpool_diff
operator|=
name|CONST_POOL_EMPTY
expr_stmt|;
name|compiler
operator|->
name|cpool_fill
operator|=
literal|0
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_function
DECL|function|push_inst
specifier|static
name|sljit_si
name|push_inst
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_uw
name|inst
parameter_list|)
block|{
name|sljit_uw
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|compiler
operator|->
name|cpool_diff
operator|!=
name|CONST_POOL_EMPTY
operator|&&
name|compiler
operator|->
name|size
operator|-
name|compiler
operator|->
name|cpool_diff
operator|>=
name|MAX_DIFFERENCE
argument_list|(
literal|4092
argument_list|)
argument_list|)
condition|)
name|FAIL_IF
argument_list|(
name|push_cpool
argument_list|(
name|compiler
argument_list|)
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|(
name|sljit_uw
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
sizeof|sizeof
argument_list|(
name|sljit_uw
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|ptr
argument_list|)
expr_stmt|;
name|compiler
operator|->
name|size
operator|++
expr_stmt|;
operator|*
name|ptr
operator|=
name|inst
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_function
DECL|function|push_inst_with_literal
specifier|static
name|sljit_si
name|push_inst_with_literal
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_uw
name|inst
parameter_list|,
name|sljit_uw
name|literal
parameter_list|)
block|{
name|sljit_uw
modifier|*
name|ptr
decl_stmt|;
name|sljit_uw
name|cpool_index
init|=
name|CPOOL_SIZE
decl_stmt|;
name|sljit_uw
modifier|*
name|cpool_ptr
decl_stmt|;
name|sljit_uw
modifier|*
name|cpool_end
decl_stmt|;
name|sljit_ub
modifier|*
name|cpool_unique_ptr
decl_stmt|;
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|compiler
operator|->
name|cpool_diff
operator|!=
name|CONST_POOL_EMPTY
operator|&&
name|compiler
operator|->
name|size
operator|-
name|compiler
operator|->
name|cpool_diff
operator|>=
name|MAX_DIFFERENCE
argument_list|(
literal|4092
argument_list|)
argument_list|)
condition|)
name|FAIL_IF
argument_list|(
name|push_cpool
argument_list|(
name|compiler
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|compiler
operator|->
name|cpool_fill
operator|>
literal|0
condition|)
block|{
name|cpool_ptr
operator|=
name|compiler
operator|->
name|cpool
expr_stmt|;
name|cpool_end
operator|=
name|cpool_ptr
operator|+
name|compiler
operator|->
name|cpool_fill
expr_stmt|;
name|cpool_unique_ptr
operator|=
name|compiler
operator|->
name|cpool_unique
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|(
operator|*
name|cpool_ptr
operator|==
name|literal
operator|)
operator|&&
operator|!
operator|(
operator|*
name|cpool_unique_ptr
operator|)
condition|)
block|{
name|cpool_index
operator|=
name|cpool_ptr
operator|-
name|compiler
operator|->
name|cpool
expr_stmt|;
break|break;
block|}
name|cpool_ptr
operator|++
expr_stmt|;
name|cpool_unique_ptr
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|cpool_ptr
operator|<
name|cpool_end
condition|)
do|;
block|}
if|if
condition|(
name|cpool_index
operator|==
name|CPOOL_SIZE
condition|)
block|{
comment|/* Must allocate a new entry in the literal pool. */
if|if
condition|(
name|compiler
operator|->
name|cpool_fill
operator|<
name|CPOOL_SIZE
condition|)
block|{
name|cpool_index
operator|=
name|compiler
operator|->
name|cpool_fill
expr_stmt|;
name|compiler
operator|->
name|cpool_fill
operator|++
expr_stmt|;
block|}
else|else
block|{
name|FAIL_IF
argument_list|(
name|push_cpool
argument_list|(
name|compiler
argument_list|)
argument_list|)
expr_stmt|;
name|cpool_index
operator|=
literal|0
expr_stmt|;
name|compiler
operator|->
name|cpool_fill
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|SLJIT_ASSERT
argument_list|(
operator|(
name|inst
operator|&
literal|0xfff
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|(
name|sljit_uw
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
sizeof|sizeof
argument_list|(
name|sljit_uw
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|ptr
argument_list|)
expr_stmt|;
name|compiler
operator|->
name|size
operator|++
expr_stmt|;
operator|*
name|ptr
operator|=
name|inst
operator||
name|cpool_index
expr_stmt|;
name|compiler
operator|->
name|cpool
index|[
name|cpool_index
index|]
operator|=
name|literal
expr_stmt|;
name|compiler
operator|->
name|cpool_unique
index|[
name|cpool_index
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|compiler
operator|->
name|cpool_diff
operator|==
name|CONST_POOL_EMPTY
condition|)
name|compiler
operator|->
name|cpool_diff
operator|=
name|compiler
operator|->
name|size
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_function
DECL|function|push_inst_with_unique_literal
specifier|static
name|sljit_si
name|push_inst_with_unique_literal
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_uw
name|inst
parameter_list|,
name|sljit_uw
name|literal
parameter_list|)
block|{
name|sljit_uw
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
operator|(
name|compiler
operator|->
name|cpool_diff
operator|!=
name|CONST_POOL_EMPTY
operator|&&
name|compiler
operator|->
name|size
operator|-
name|compiler
operator|->
name|cpool_diff
operator|>=
name|MAX_DIFFERENCE
argument_list|(
literal|4092
argument_list|)
operator|)
operator|||
name|compiler
operator|->
name|cpool_fill
operator|>=
name|CPOOL_SIZE
argument_list|)
condition|)
name|FAIL_IF
argument_list|(
name|push_cpool
argument_list|(
name|compiler
argument_list|)
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|compiler
operator|->
name|cpool_fill
operator|<
name|CPOOL_SIZE
operator|&&
operator|(
name|inst
operator|&
literal|0xfff
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|(
name|sljit_uw
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
sizeof|sizeof
argument_list|(
name|sljit_uw
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|ptr
argument_list|)
expr_stmt|;
name|compiler
operator|->
name|size
operator|++
expr_stmt|;
operator|*
name|ptr
operator|=
name|inst
operator||
name|compiler
operator|->
name|cpool_fill
expr_stmt|;
name|compiler
operator|->
name|cpool
index|[
name|compiler
operator|->
name|cpool_fill
index|]
operator|=
name|literal
expr_stmt|;
name|compiler
operator|->
name|cpool_unique
index|[
name|compiler
operator|->
name|cpool_fill
index|]
operator|=
literal|1
expr_stmt|;
name|compiler
operator|->
name|cpool_fill
operator|++
expr_stmt|;
if|if
condition|(
name|compiler
operator|->
name|cpool_diff
operator|==
name|CONST_POOL_EMPTY
condition|)
name|compiler
operator|->
name|cpool_diff
operator|=
name|compiler
operator|->
name|size
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_function
DECL|function|prepare_blx
specifier|static
name|SLJIT_INLINE
name|sljit_si
name|prepare_blx
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|)
block|{
comment|/* Place for at least two instruction (doesn't matter whether the first has a literal). */
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|compiler
operator|->
name|cpool_diff
operator|!=
name|CONST_POOL_EMPTY
operator|&&
name|compiler
operator|->
name|size
operator|-
name|compiler
operator|->
name|cpool_diff
operator|>=
name|MAX_DIFFERENCE
argument_list|(
literal|4088
argument_list|)
argument_list|)
condition|)
return|return
name|push_cpool
argument_list|(
name|compiler
argument_list|)
return|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_function
DECL|function|emit_blx
specifier|static
name|SLJIT_INLINE
name|sljit_si
name|emit_blx
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|)
block|{
comment|/* Must follow tightly the previous instruction (to be able to convert it to bl instruction). */
name|SLJIT_ASSERT
argument_list|(
name|compiler
operator|->
name|cpool_diff
operator|==
name|CONST_POOL_EMPTY
operator|||
name|compiler
operator|->
name|size
operator|-
name|compiler
operator|->
name|cpool_diff
operator|<
name|MAX_DIFFERENCE
argument_list|(
literal|4092
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|BLX
operator||
name|RM
argument_list|(
name|TMP_REG1
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|patch_pc_relative_loads
specifier|static
name|sljit_uw
name|patch_pc_relative_loads
parameter_list|(
name|sljit_uw
modifier|*
name|last_pc_patch
parameter_list|,
name|sljit_uw
modifier|*
name|code_ptr
parameter_list|,
name|sljit_uw
modifier|*
name|const_pool
parameter_list|,
name|sljit_uw
name|cpool_size
parameter_list|)
block|{
name|sljit_uw
name|diff
decl_stmt|;
name|sljit_uw
name|ind
decl_stmt|;
name|sljit_uw
name|counter
init|=
literal|0
decl_stmt|;
name|sljit_uw
modifier|*
name|clear_const_pool
init|=
name|const_pool
decl_stmt|;
name|sljit_uw
modifier|*
name|clear_const_pool_end
init|=
name|const_pool
operator|+
name|cpool_size
decl_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|const_pool
operator|-
name|code_ptr
operator|<=
name|CONST_POOL_ALIGNMENT
argument_list|)
expr_stmt|;
comment|/* Set unused flag for all literals in the constant pool. 	   I.e.: unused literals can belong to branches, which can be encoded as B or BL. 	   We can "compress" the constant pool by discarding these literals. */
while|while
condition|(
name|clear_const_pool
operator|<
name|clear_const_pool_end
condition|)
operator|*
name|clear_const_pool
operator|++
operator|=
call|(
name|sljit_uw
call|)
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|last_pc_patch
operator|<
name|code_ptr
condition|)
block|{
comment|/* Data transfer instruction with Rn == r15. */
if|if
condition|(
operator|(
operator|*
name|last_pc_patch
operator|&
literal|0x0c0f0000
operator|)
operator|==
literal|0x040f0000
condition|)
block|{
name|diff
operator|=
name|const_pool
operator|-
name|last_pc_patch
expr_stmt|;
name|ind
operator|=
operator|(
operator|*
name|last_pc_patch
operator|)
operator|&
literal|0xfff
expr_stmt|;
comment|/* Must be a load instruction with immediate offset. */
name|SLJIT_ASSERT
argument_list|(
name|ind
operator|<
name|cpool_size
operator|&&
operator|!
operator|(
operator|*
name|last_pc_patch
operator|&
operator|(
literal|1
operator|<<
literal|25
operator|)
operator|)
operator|&&
operator|(
operator|*
name|last_pc_patch
operator|&
operator|(
literal|1
operator|<<
literal|20
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sljit_si
operator|)
name|const_pool
index|[
name|ind
index|]
operator|<
literal|0
condition|)
block|{
name|const_pool
index|[
name|ind
index|]
operator|=
name|counter
expr_stmt|;
name|ind
operator|=
name|counter
expr_stmt|;
name|counter
operator|++
expr_stmt|;
block|}
else|else
name|ind
operator|=
name|const_pool
index|[
name|ind
index|]
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|diff
operator|>=
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|diff
operator|>=
literal|2
operator|||
name|ind
operator|>
literal|0
condition|)
block|{
name|diff
operator|=
operator|(
name|diff
operator|+
name|ind
operator|-
literal|2
operator|)
operator|<<
literal|2
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|diff
operator|<=
literal|0xfff
argument_list|)
expr_stmt|;
operator|*
name|last_pc_patch
operator|=
operator|(
operator|*
name|last_pc_patch
operator|&
operator|~
literal|0xfff
operator|)
operator||
name|diff
expr_stmt|;
block|}
else|else
operator|*
name|last_pc_patch
operator|=
operator|(
operator|*
name|last_pc_patch
operator|&
operator|~
operator|(
literal|0xfff
operator||
operator|(
literal|1
operator|<<
literal|23
operator|)
operator|)
operator|)
operator||
literal|0x004
expr_stmt|;
block|}
name|last_pc_patch
operator|++
expr_stmt|;
block|}
return|return
name|counter
return|;
block|}
end_function
begin_comment
comment|/* In some rare ocasions we may need future patches. The probability is close to 0 in practice. */
end_comment
begin_struct
DECL|struct|future_patch
struct|struct
name|future_patch
block|{
DECL|member|next
name|struct
name|future_patch
modifier|*
name|next
decl_stmt|;
DECL|member|index
name|sljit_si
name|index
decl_stmt|;
DECL|member|value
name|sljit_si
name|value
decl_stmt|;
block|}
struct|;
end_struct
begin_function
DECL|function|resolve_const_pool_index
specifier|static
name|SLJIT_INLINE
name|sljit_si
name|resolve_const_pool_index
parameter_list|(
name|struct
name|future_patch
modifier|*
modifier|*
name|first_patch
parameter_list|,
name|sljit_uw
name|cpool_current_index
parameter_list|,
name|sljit_uw
modifier|*
name|cpool_start_address
parameter_list|,
name|sljit_uw
modifier|*
name|buf_ptr
parameter_list|)
block|{
name|sljit_si
name|value
decl_stmt|;
name|struct
name|future_patch
modifier|*
name|curr_patch
decl_stmt|,
modifier|*
name|prev_patch
decl_stmt|;
comment|/* Using the values generated by patch_pc_relative_loads. */
if|if
condition|(
operator|!
operator|*
name|first_patch
condition|)
name|value
operator|=
operator|(
name|sljit_si
operator|)
name|cpool_start_address
index|[
name|cpool_current_index
index|]
expr_stmt|;
else|else
block|{
name|curr_patch
operator|=
operator|*
name|first_patch
expr_stmt|;
name|prev_patch
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|curr_patch
condition|)
block|{
name|value
operator|=
operator|(
name|sljit_si
operator|)
name|cpool_start_address
index|[
name|cpool_current_index
index|]
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|sljit_uw
operator|)
name|curr_patch
operator|->
name|index
operator|==
name|cpool_current_index
condition|)
block|{
name|value
operator|=
name|curr_patch
operator|->
name|value
expr_stmt|;
if|if
condition|(
name|prev_patch
condition|)
name|prev_patch
operator|->
name|next
operator|=
name|curr_patch
operator|->
name|next
expr_stmt|;
else|else
operator|*
name|first_patch
operator|=
name|curr_patch
operator|->
name|next
expr_stmt|;
name|SLJIT_FREE
argument_list|(
name|curr_patch
argument_list|)
expr_stmt|;
break|break;
block|}
name|prev_patch
operator|=
name|curr_patch
expr_stmt|;
name|curr_patch
operator|=
name|curr_patch
operator|->
name|next
expr_stmt|;
block|}
block|}
if|if
condition|(
name|value
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|sljit_uw
operator|)
name|value
operator|>
name|cpool_current_index
condition|)
block|{
name|curr_patch
operator|=
operator|(
expr|struct
name|future_patch
operator|*
operator|)
name|SLJIT_MALLOC
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|future_patch
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|curr_patch
condition|)
block|{
while|while
condition|(
operator|*
name|first_patch
condition|)
block|{
name|curr_patch
operator|=
operator|*
name|first_patch
expr_stmt|;
operator|*
name|first_patch
operator|=
operator|(
operator|*
name|first_patch
operator|)
operator|->
name|next
expr_stmt|;
name|SLJIT_FREE
argument_list|(
name|curr_patch
argument_list|)
expr_stmt|;
block|}
return|return
name|SLJIT_ERR_ALLOC_FAILED
return|;
block|}
name|curr_patch
operator|->
name|next
operator|=
operator|*
name|first_patch
expr_stmt|;
name|curr_patch
operator|->
name|index
operator|=
name|value
expr_stmt|;
name|curr_patch
operator|->
name|value
operator|=
name|cpool_start_address
index|[
name|value
index|]
expr_stmt|;
operator|*
name|first_patch
operator|=
name|curr_patch
expr_stmt|;
block|}
name|cpool_start_address
index|[
name|value
index|]
operator|=
operator|*
name|buf_ptr
expr_stmt|;
block|}
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_else
else|#
directive|else
end_else
begin_function
DECL|function|push_inst
specifier|static
name|sljit_si
name|push_inst
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_uw
name|inst
parameter_list|)
block|{
name|sljit_uw
modifier|*
name|ptr
decl_stmt|;
name|ptr
operator|=
operator|(
name|sljit_uw
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
sizeof|sizeof
argument_list|(
name|sljit_uw
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|ptr
argument_list|)
expr_stmt|;
name|compiler
operator|->
name|size
operator|++
expr_stmt|;
operator|*
name|ptr
operator|=
name|inst
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_function
DECL|function|emit_imm
specifier|static
name|SLJIT_INLINE
name|sljit_si
name|emit_imm
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|reg
parameter_list|,
name|sljit_sw
name|imm
parameter_list|)
block|{
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|MOVW
operator||
name|RD
argument_list|(
name|reg
argument_list|)
operator||
operator|(
operator|(
name|imm
operator|<<
literal|4
operator|)
operator|&
literal|0xf0000
operator|)
operator||
operator|(
name|imm
operator|&
literal|0xfff
operator|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|MOVT
operator||
name|RD
argument_list|(
name|reg
argument_list|)
operator||
operator|(
operator|(
name|imm
operator|>>
literal|12
operator|)
operator|&
literal|0xf0000
operator|)
operator||
operator|(
operator|(
name|imm
operator|>>
literal|16
operator|)
operator|&
literal|0xfff
operator|)
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|detect_jump_type
specifier|static
name|SLJIT_INLINE
name|sljit_si
name|detect_jump_type
parameter_list|(
name|struct
name|sljit_jump
modifier|*
name|jump
parameter_list|,
name|sljit_uw
modifier|*
name|code_ptr
parameter_list|,
name|sljit_uw
modifier|*
name|code
parameter_list|)
block|{
name|sljit_sw
name|diff
decl_stmt|;
if|if
condition|(
name|jump
operator|->
name|flags
operator|&
name|SLJIT_REWRITABLE_JUMP
condition|)
return|return
literal|0
return|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_ARM_V5
operator|&&
name|SLJIT_CONFIG_ARM_V5
operator|)
if|if
condition|(
name|jump
operator|->
name|flags
operator|&
name|IS_BL
condition|)
name|code_ptr
operator|--
expr_stmt|;
if|if
condition|(
name|jump
operator|->
name|flags
operator|&
name|JUMP_ADDR
condition|)
name|diff
operator|=
operator|(
operator|(
name|sljit_sw
operator|)
name|jump
operator|->
name|u
operator|.
name|target
operator|-
call|(
name|sljit_sw
call|)
argument_list|(
name|code_ptr
operator|+
literal|2
argument_list|)
operator|)
expr_stmt|;
else|else
block|{
name|SLJIT_ASSERT
argument_list|(
name|jump
operator|->
name|flags
operator|&
name|JUMP_LABEL
argument_list|)
expr_stmt|;
name|diff
operator|=
operator|(
call|(
name|sljit_sw
call|)
argument_list|(
name|code
operator|+
name|jump
operator|->
name|u
operator|.
name|label
operator|->
name|size
argument_list|)
operator|-
call|(
name|sljit_sw
call|)
argument_list|(
name|code_ptr
operator|+
literal|2
argument_list|)
operator|)
expr_stmt|;
block|}
comment|/* Branch to Thumb code has not been optimized yet. */
if|if
condition|(
name|diff
operator|&
literal|0x3
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|jump
operator|->
name|flags
operator|&
name|IS_BL
condition|)
block|{
if|if
condition|(
name|diff
operator|<=
literal|0x01ffffff
operator|&&
name|diff
operator|>=
operator|-
literal|0x02000000
condition|)
block|{
operator|*
name|code_ptr
operator|=
operator|(
name|BL
operator|-
name|CONDITIONAL
operator|)
operator||
operator|(
operator|*
operator|(
name|code_ptr
operator|+
literal|1
operator|)
operator|&
name|COND_MASK
operator|)
expr_stmt|;
name|jump
operator|->
name|flags
operator||=
name|PATCH_B
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|diff
operator|<=
literal|0x01ffffff
operator|&&
name|diff
operator|>=
operator|-
literal|0x02000000
condition|)
block|{
operator|*
name|code_ptr
operator|=
operator|(
name|B
operator|-
name|CONDITIONAL
operator|)
operator||
operator|(
operator|*
name|code_ptr
operator|&
name|COND_MASK
operator|)
expr_stmt|;
name|jump
operator|->
name|flags
operator||=
name|PATCH_B
expr_stmt|;
block|}
block|}
else|#
directive|else
if|if
condition|(
name|jump
operator|->
name|flags
operator|&
name|JUMP_ADDR
condition|)
name|diff
operator|=
operator|(
operator|(
name|sljit_sw
operator|)
name|jump
operator|->
name|u
operator|.
name|target
operator|-
operator|(
name|sljit_sw
operator|)
name|code_ptr
operator|)
expr_stmt|;
else|else
block|{
name|SLJIT_ASSERT
argument_list|(
name|jump
operator|->
name|flags
operator|&
name|JUMP_LABEL
argument_list|)
expr_stmt|;
name|diff
operator|=
operator|(
call|(
name|sljit_sw
call|)
argument_list|(
name|code
operator|+
name|jump
operator|->
name|u
operator|.
name|label
operator|->
name|size
argument_list|)
operator|-
operator|(
name|sljit_sw
operator|)
name|code_ptr
operator|)
expr_stmt|;
block|}
comment|/* Branch to Thumb code has not been optimized yet. */
if|if
condition|(
name|diff
operator|&
literal|0x3
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|diff
operator|<=
literal|0x01ffffff
operator|&&
name|diff
operator|>=
operator|-
literal|0x02000000
condition|)
block|{
name|code_ptr
operator|-=
literal|2
expr_stmt|;
operator|*
name|code_ptr
operator|=
operator|(
operator|(
name|jump
operator|->
name|flags
operator|&
name|IS_BL
operator|)
condition|?
operator|(
name|BL
operator|-
name|CONDITIONAL
operator|)
else|:
operator|(
name|B
operator|-
name|CONDITIONAL
operator|)
operator|)
operator||
operator|(
name|code_ptr
index|[
literal|2
index|]
operator|&
name|COND_MASK
operator|)
expr_stmt|;
name|jump
operator|->
name|flags
operator||=
name|PATCH_B
expr_stmt|;
return|return
literal|1
return|;
block|}
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|inline_set_jump_addr
specifier|static
name|SLJIT_INLINE
name|void
name|inline_set_jump_addr
parameter_list|(
name|sljit_uw
name|addr
parameter_list|,
name|sljit_uw
name|new_addr
parameter_list|,
name|sljit_si
name|flush
parameter_list|)
block|{
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_ARM_V5
operator|&&
name|SLJIT_CONFIG_ARM_V5
operator|)
name|sljit_uw
modifier|*
name|ptr
init|=
operator|(
name|sljit_uw
operator|*
operator|)
name|addr
decl_stmt|;
name|sljit_uw
modifier|*
name|inst
init|=
operator|(
name|sljit_uw
operator|*
operator|)
name|ptr
index|[
literal|0
index|]
decl_stmt|;
name|sljit_uw
name|mov_pc
init|=
name|ptr
index|[
literal|1
index|]
decl_stmt|;
name|sljit_si
name|bl
init|=
operator|(
name|mov_pc
operator|&
literal|0x0000f000
operator|)
operator|!=
name|RD
argument_list|(
name|TMP_PC
argument_list|)
decl_stmt|;
name|sljit_sw
name|diff
init|=
call|(
name|sljit_sw
call|)
argument_list|(
operator|(
operator|(
name|sljit_sw
operator|)
name|new_addr
operator|-
call|(
name|sljit_sw
call|)
argument_list|(
name|inst
operator|+
literal|2
argument_list|)
operator|)
operator|>>
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
name|diff
operator|<=
literal|0x7fffff
operator|&&
name|diff
operator|>=
operator|-
literal|0x800000
condition|)
block|{
comment|/* Turn to branch. */
if|if
condition|(
operator|!
name|bl
condition|)
block|{
name|inst
index|[
literal|0
index|]
operator|=
operator|(
name|mov_pc
operator|&
name|COND_MASK
operator|)
operator||
operator|(
name|B
operator|-
name|CONDITIONAL
operator|)
operator||
operator|(
name|diff
operator|&
literal|0xffffff
operator|)
expr_stmt|;
if|if
condition|(
name|flush
condition|)
block|{
name|SLJIT_CACHE_FLUSH
argument_list|(
name|inst
argument_list|,
name|inst
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|inst
index|[
literal|0
index|]
operator|=
operator|(
name|mov_pc
operator|&
name|COND_MASK
operator|)
operator||
operator|(
name|BL
operator|-
name|CONDITIONAL
operator|)
operator||
operator|(
name|diff
operator|&
literal|0xffffff
operator|)
expr_stmt|;
name|inst
index|[
literal|1
index|]
operator|=
name|NOP
expr_stmt|;
if|if
condition|(
name|flush
condition|)
block|{
name|SLJIT_CACHE_FLUSH
argument_list|(
name|inst
argument_list|,
name|inst
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* Get the position of the constant. */
if|if
condition|(
name|mov_pc
operator|&
operator|(
literal|1
operator|<<
literal|23
operator|)
condition|)
name|ptr
operator|=
name|inst
operator|+
operator|(
operator|(
name|mov_pc
operator|&
literal|0xfff
operator|)
operator|>>
literal|2
operator|)
operator|+
literal|2
expr_stmt|;
else|else
name|ptr
operator|=
name|inst
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|inst
operator|!=
name|mov_pc
condition|)
block|{
name|inst
index|[
literal|0
index|]
operator|=
name|mov_pc
expr_stmt|;
if|if
condition|(
operator|!
name|bl
condition|)
block|{
if|if
condition|(
name|flush
condition|)
block|{
name|SLJIT_CACHE_FLUSH
argument_list|(
name|inst
argument_list|,
name|inst
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|inst
index|[
literal|1
index|]
operator|=
name|BLX
operator||
name|RM
argument_list|(
name|TMP_REG1
argument_list|)
expr_stmt|;
if|if
condition|(
name|flush
condition|)
block|{
name|SLJIT_CACHE_FLUSH
argument_list|(
name|inst
argument_list|,
name|inst
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
block|}
operator|*
name|ptr
operator|=
name|new_addr
expr_stmt|;
block|}
else|#
directive|else
name|sljit_uw
modifier|*
name|inst
init|=
operator|(
name|sljit_uw
operator|*
operator|)
name|addr
decl_stmt|;
name|SLJIT_ASSERT
argument_list|(
operator|(
name|inst
index|[
literal|0
index|]
operator|&
literal|0xfff00000
operator|)
operator|==
name|MOVW
operator|&&
operator|(
name|inst
index|[
literal|1
index|]
operator|&
literal|0xfff00000
operator|)
operator|==
name|MOVT
argument_list|)
expr_stmt|;
name|inst
index|[
literal|0
index|]
operator|=
name|MOVW
operator||
operator|(
name|inst
index|[
literal|0
index|]
operator|&
literal|0xf000
operator|)
operator||
operator|(
operator|(
name|new_addr
operator|<<
literal|4
operator|)
operator|&
literal|0xf0000
operator|)
operator||
operator|(
name|new_addr
operator|&
literal|0xfff
operator|)
expr_stmt|;
name|inst
index|[
literal|1
index|]
operator|=
name|MOVT
operator||
operator|(
name|inst
index|[
literal|1
index|]
operator|&
literal|0xf000
operator|)
operator||
operator|(
operator|(
name|new_addr
operator|>>
literal|12
operator|)
operator|&
literal|0xf0000
operator|)
operator||
operator|(
operator|(
name|new_addr
operator|>>
literal|16
operator|)
operator|&
literal|0xfff
operator|)
expr_stmt|;
if|if
condition|(
name|flush
condition|)
block|{
name|SLJIT_CACHE_FLUSH
argument_list|(
name|inst
argument_list|,
name|inst
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function
begin_function_decl
specifier|static
name|sljit_uw
name|get_imm
parameter_list|(
name|sljit_uw
name|imm
parameter_list|)
function_decl|;
end_function_decl
begin_function
DECL|function|inline_set_const
specifier|static
name|SLJIT_INLINE
name|void
name|inline_set_const
parameter_list|(
name|sljit_uw
name|addr
parameter_list|,
name|sljit_sw
name|new_constant
parameter_list|,
name|sljit_si
name|flush
parameter_list|)
block|{
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_ARM_V5
operator|&&
name|SLJIT_CONFIG_ARM_V5
operator|)
name|sljit_uw
modifier|*
name|ptr
init|=
operator|(
name|sljit_uw
operator|*
operator|)
name|addr
decl_stmt|;
name|sljit_uw
modifier|*
name|inst
init|=
operator|(
name|sljit_uw
operator|*
operator|)
name|ptr
index|[
literal|0
index|]
decl_stmt|;
name|sljit_uw
name|ldr_literal
init|=
name|ptr
index|[
literal|1
index|]
decl_stmt|;
name|sljit_uw
name|src2
decl_stmt|;
name|src2
operator|=
name|get_imm
argument_list|(
name|new_constant
argument_list|)
expr_stmt|;
if|if
condition|(
name|src2
condition|)
block|{
operator|*
name|inst
operator|=
literal|0xe3a00000
operator||
operator|(
name|ldr_literal
operator|&
literal|0xf000
operator|)
operator||
name|src2
expr_stmt|;
if|if
condition|(
name|flush
condition|)
block|{
name|SLJIT_CACHE_FLUSH
argument_list|(
name|inst
argument_list|,
name|inst
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|src2
operator|=
name|get_imm
argument_list|(
operator|~
name|new_constant
argument_list|)
expr_stmt|;
if|if
condition|(
name|src2
condition|)
block|{
operator|*
name|inst
operator|=
literal|0xe3e00000
operator||
operator|(
name|ldr_literal
operator|&
literal|0xf000
operator|)
operator||
name|src2
expr_stmt|;
if|if
condition|(
name|flush
condition|)
block|{
name|SLJIT_CACHE_FLUSH
argument_list|(
name|inst
argument_list|,
name|inst
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|ldr_literal
operator|&
operator|(
literal|1
operator|<<
literal|23
operator|)
condition|)
name|ptr
operator|=
name|inst
operator|+
operator|(
operator|(
name|ldr_literal
operator|&
literal|0xfff
operator|)
operator|>>
literal|2
operator|)
operator|+
literal|2
expr_stmt|;
else|else
name|ptr
operator|=
name|inst
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|inst
operator|!=
name|ldr_literal
condition|)
block|{
operator|*
name|inst
operator|=
name|ldr_literal
expr_stmt|;
if|if
condition|(
name|flush
condition|)
block|{
name|SLJIT_CACHE_FLUSH
argument_list|(
name|inst
argument_list|,
name|inst
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|ptr
operator|=
name|new_constant
expr_stmt|;
else|#
directive|else
name|sljit_uw
modifier|*
name|inst
init|=
operator|(
name|sljit_uw
operator|*
operator|)
name|addr
decl_stmt|;
name|SLJIT_ASSERT
argument_list|(
operator|(
name|inst
index|[
literal|0
index|]
operator|&
literal|0xfff00000
operator|)
operator|==
name|MOVW
operator|&&
operator|(
name|inst
index|[
literal|1
index|]
operator|&
literal|0xfff00000
operator|)
operator|==
name|MOVT
argument_list|)
expr_stmt|;
name|inst
index|[
literal|0
index|]
operator|=
name|MOVW
operator||
operator|(
name|inst
index|[
literal|0
index|]
operator|&
literal|0xf000
operator|)
operator||
operator|(
operator|(
name|new_constant
operator|<<
literal|4
operator|)
operator|&
literal|0xf0000
operator|)
operator||
operator|(
name|new_constant
operator|&
literal|0xfff
operator|)
expr_stmt|;
name|inst
index|[
literal|1
index|]
operator|=
name|MOVT
operator||
operator|(
name|inst
index|[
literal|1
index|]
operator|&
literal|0xf000
operator|)
operator||
operator|(
operator|(
name|new_constant
operator|>>
literal|12
operator|)
operator|&
literal|0xf0000
operator|)
operator||
operator|(
operator|(
name|new_constant
operator|>>
literal|16
operator|)
operator|&
literal|0xfff
operator|)
expr_stmt|;
if|if
condition|(
name|flush
condition|)
block|{
name|SLJIT_CACHE_FLUSH
argument_list|(
name|inst
argument_list|,
name|inst
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|sljit_generate_code
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
modifier|*
name|sljit_generate_code
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|)
block|{
name|struct
name|sljit_memory_fragment
modifier|*
name|buf
decl_stmt|;
name|sljit_uw
modifier|*
name|code
decl_stmt|;
name|sljit_uw
modifier|*
name|code_ptr
decl_stmt|;
name|sljit_uw
modifier|*
name|buf_ptr
decl_stmt|;
name|sljit_uw
modifier|*
name|buf_end
decl_stmt|;
name|sljit_uw
name|size
decl_stmt|;
name|sljit_uw
name|word_count
decl_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_ARM_V5
operator|&&
name|SLJIT_CONFIG_ARM_V5
operator|)
name|sljit_uw
name|cpool_size
decl_stmt|;
name|sljit_uw
name|cpool_skip_alignment
decl_stmt|;
name|sljit_uw
name|cpool_current_index
decl_stmt|;
name|sljit_uw
modifier|*
name|cpool_start_address
decl_stmt|;
name|sljit_uw
modifier|*
name|last_pc_patch
decl_stmt|;
name|struct
name|future_patch
modifier|*
name|first_patch
decl_stmt|;
endif|#
directive|endif
name|struct
name|sljit_label
modifier|*
name|label
decl_stmt|;
name|struct
name|sljit_jump
modifier|*
name|jump
decl_stmt|;
name|struct
name|sljit_const
modifier|*
name|const_
decl_stmt|;
name|CHECK_ERROR_PTR
argument_list|()
expr_stmt|;
name|check_sljit_generate_code
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
name|reverse_buf
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
comment|/* Second code generation pass. */
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_ARM_V5
operator|&&
name|SLJIT_CONFIG_ARM_V5
operator|)
name|size
operator|=
name|compiler
operator|->
name|size
operator|+
operator|(
name|compiler
operator|->
name|patches
operator|<<
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|compiler
operator|->
name|cpool_fill
operator|>
literal|0
condition|)
name|size
operator|+=
name|compiler
operator|->
name|cpool_fill
operator|+
name|CONST_POOL_ALIGNMENT
operator|-
literal|1
expr_stmt|;
else|#
directive|else
name|size
operator|=
name|compiler
operator|->
name|size
expr_stmt|;
endif|#
directive|endif
name|code
operator|=
operator|(
name|sljit_uw
operator|*
operator|)
name|SLJIT_MALLOC_EXEC
argument_list|(
name|size
operator|*
sizeof|sizeof
argument_list|(
name|sljit_uw
argument_list|)
argument_list|)
expr_stmt|;
name|PTR_FAIL_WITH_EXEC_IF
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|buf
operator|=
name|compiler
operator|->
name|buf
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_ARM_V5
operator|&&
name|SLJIT_CONFIG_ARM_V5
operator|)
name|cpool_size
operator|=
literal|0
expr_stmt|;
name|cpool_skip_alignment
operator|=
literal|0
expr_stmt|;
name|cpool_current_index
operator|=
literal|0
expr_stmt|;
name|cpool_start_address
operator|=
name|NULL
expr_stmt|;
name|first_patch
operator|=
name|NULL
expr_stmt|;
name|last_pc_patch
operator|=
name|code
expr_stmt|;
endif|#
directive|endif
name|code_ptr
operator|=
name|code
expr_stmt|;
name|word_count
operator|=
literal|0
expr_stmt|;
name|label
operator|=
name|compiler
operator|->
name|labels
expr_stmt|;
name|jump
operator|=
name|compiler
operator|->
name|jumps
expr_stmt|;
name|const_
operator|=
name|compiler
operator|->
name|consts
expr_stmt|;
if|if
condition|(
name|label
operator|&&
name|label
operator|->
name|size
operator|==
literal|0
condition|)
block|{
name|label
operator|->
name|addr
operator|=
operator|(
name|sljit_uw
operator|)
name|code
expr_stmt|;
name|label
operator|->
name|size
operator|=
literal|0
expr_stmt|;
name|label
operator|=
name|label
operator|->
name|next
expr_stmt|;
block|}
do|do
block|{
name|buf_ptr
operator|=
operator|(
name|sljit_uw
operator|*
operator|)
name|buf
operator|->
name|memory
expr_stmt|;
name|buf_end
operator|=
name|buf_ptr
operator|+
operator|(
name|buf
operator|->
name|used_size
operator|>>
literal|2
operator|)
expr_stmt|;
do|do
block|{
name|word_count
operator|++
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_ARM_V5
operator|&&
name|SLJIT_CONFIG_ARM_V5
operator|)
if|if
condition|(
name|cpool_size
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|cpool_skip_alignment
operator|>
literal|0
condition|)
block|{
name|buf_ptr
operator|++
expr_stmt|;
name|cpool_skip_alignment
operator|--
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|resolve_const_pool_index
argument_list|(
operator|&
name|first_patch
argument_list|,
name|cpool_current_index
argument_list|,
name|cpool_start_address
argument_list|,
name|buf_ptr
argument_list|)
argument_list|)
condition|)
block|{
name|SLJIT_FREE_EXEC
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|compiler
operator|->
name|error
operator|=
name|SLJIT_ERR_ALLOC_FAILED
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|buf_ptr
operator|++
expr_stmt|;
if|if
condition|(
operator|++
name|cpool_current_index
operator|>=
name|cpool_size
condition|)
block|{
name|SLJIT_ASSERT
argument_list|(
operator|!
name|first_patch
argument_list|)
expr_stmt|;
name|cpool_size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|label
operator|&&
name|label
operator|->
name|size
operator|==
name|word_count
condition|)
block|{
comment|/* Points after the current instruction. */
name|label
operator|->
name|addr
operator|=
operator|(
name|sljit_uw
operator|)
name|code_ptr
expr_stmt|;
name|label
operator|->
name|size
operator|=
name|code_ptr
operator|-
name|code
expr_stmt|;
name|label
operator|=
name|label
operator|->
name|next
expr_stmt|;
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|buf_ptr
operator|&
literal|0xff000000
operator|)
operator|!=
name|PUSH_POOL
condition|)
block|{
endif|#
directive|endif
operator|*
name|code_ptr
operator|=
operator|*
name|buf_ptr
operator|++
expr_stmt|;
comment|/* These structures are ordered by their address. */
name|SLJIT_ASSERT
argument_list|(
operator|!
name|label
operator|||
name|label
operator|->
name|size
operator|>=
name|word_count
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
operator|!
name|jump
operator|||
name|jump
operator|->
name|addr
operator|>=
name|word_count
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
operator|!
name|const_
operator|||
name|const_
operator|->
name|addr
operator|>=
name|word_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|jump
operator|&&
name|jump
operator|->
name|addr
operator|==
name|word_count
condition|)
block|{
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_ARM_V5
operator|&&
name|SLJIT_CONFIG_ARM_V5
operator|)
if|if
condition|(
name|detect_jump_type
argument_list|(
name|jump
argument_list|,
name|code_ptr
argument_list|,
name|code
argument_list|)
condition|)
name|code_ptr
operator|--
expr_stmt|;
name|jump
operator|->
name|addr
operator|=
operator|(
name|sljit_uw
operator|)
name|code_ptr
expr_stmt|;
else|#
directive|else
name|jump
operator|->
name|addr
operator|=
call|(
name|sljit_uw
call|)
argument_list|(
name|code_ptr
operator|-
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|detect_jump_type
argument_list|(
name|jump
argument_list|,
name|code_ptr
argument_list|,
name|code
argument_list|)
condition|)
name|code_ptr
operator|-=
literal|2
expr_stmt|;
endif|#
directive|endif
name|jump
operator|=
name|jump
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|label
operator|&&
name|label
operator|->
name|size
operator|==
name|word_count
condition|)
block|{
comment|/* code_ptr can be affected above. */
name|label
operator|->
name|addr
operator|=
call|(
name|sljit_uw
call|)
argument_list|(
name|code_ptr
operator|+
literal|1
argument_list|)
expr_stmt|;
name|label
operator|->
name|size
operator|=
operator|(
name|code_ptr
operator|+
literal|1
operator|)
operator|-
name|code
expr_stmt|;
name|label
operator|=
name|label
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|const_
operator|&&
name|const_
operator|->
name|addr
operator|==
name|word_count
condition|)
block|{
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_ARM_V5
operator|&&
name|SLJIT_CONFIG_ARM_V5
operator|)
name|const_
operator|->
name|addr
operator|=
operator|(
name|sljit_uw
operator|)
name|code_ptr
expr_stmt|;
else|#
directive|else
name|const_
operator|->
name|addr
operator|=
call|(
name|sljit_uw
call|)
argument_list|(
name|code_ptr
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|const_
operator|=
name|const_
operator|->
name|next
expr_stmt|;
block|}
name|code_ptr
operator|++
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_ARM_V5
operator|&&
name|SLJIT_CONFIG_ARM_V5
operator|)
block|}
else|else
block|{
comment|/* Fortunately, no need to shift. */
name|cpool_size
operator|=
operator|*
name|buf_ptr
operator|++
operator|&
operator|~
name|PUSH_POOL
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|cpool_size
operator|>
literal|0
argument_list|)
expr_stmt|;
name|cpool_start_address
operator|=
name|ALIGN_INSTRUCTION
argument_list|(
name|code_ptr
operator|+
literal|1
argument_list|)
expr_stmt|;
name|cpool_current_index
operator|=
name|patch_pc_relative_loads
argument_list|(
name|last_pc_patch
argument_list|,
name|code_ptr
argument_list|,
name|cpool_start_address
argument_list|,
name|cpool_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpool_current_index
operator|>
literal|0
condition|)
block|{
comment|/* Unconditional branch. */
operator|*
name|code_ptr
operator|=
name|B
operator||
operator|(
operator|(
operator|(
name|cpool_start_address
operator|-
name|code_ptr
operator|)
operator|+
name|cpool_current_index
operator|-
literal|2
operator|)
operator|&
operator|~
name|PUSH_POOL
operator|)
expr_stmt|;
name|code_ptr
operator|=
name|cpool_start_address
operator|+
name|cpool_current_index
expr_stmt|;
block|}
name|cpool_skip_alignment
operator|=
name|CONST_POOL_ALIGNMENT
operator|-
literal|1
expr_stmt|;
name|cpool_current_index
operator|=
literal|0
expr_stmt|;
name|last_pc_patch
operator|=
name|code_ptr
expr_stmt|;
block|}
endif|#
directive|endif
block|}
do|while
condition|(
name|buf_ptr
operator|<
name|buf_end
condition|)
do|;
name|buf
operator|=
name|buf
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|buf
condition|)
do|;
name|SLJIT_ASSERT
argument_list|(
operator|!
name|label
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
operator|!
name|jump
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
operator|!
name|const_
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_ARM_V5
operator|&&
name|SLJIT_CONFIG_ARM_V5
operator|)
name|SLJIT_ASSERT
argument_list|(
name|cpool_size
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|compiler
operator|->
name|cpool_fill
operator|>
literal|0
condition|)
block|{
name|cpool_start_address
operator|=
name|ALIGN_INSTRUCTION
argument_list|(
name|code_ptr
argument_list|)
expr_stmt|;
name|cpool_current_index
operator|=
name|patch_pc_relative_loads
argument_list|(
name|last_pc_patch
argument_list|,
name|code_ptr
argument_list|,
name|cpool_start_address
argument_list|,
name|compiler
operator|->
name|cpool_fill
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpool_current_index
operator|>
literal|0
condition|)
name|code_ptr
operator|=
name|cpool_start_address
operator|+
name|cpool_current_index
expr_stmt|;
name|buf_ptr
operator|=
name|compiler
operator|->
name|cpool
expr_stmt|;
name|buf_end
operator|=
name|buf_ptr
operator|+
name|compiler
operator|->
name|cpool_fill
expr_stmt|;
name|cpool_current_index
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|buf_ptr
operator|<
name|buf_end
condition|)
block|{
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|resolve_const_pool_index
argument_list|(
operator|&
name|first_patch
argument_list|,
name|cpool_current_index
argument_list|,
name|cpool_start_address
argument_list|,
name|buf_ptr
argument_list|)
argument_list|)
condition|)
block|{
name|SLJIT_FREE_EXEC
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|compiler
operator|->
name|error
operator|=
name|SLJIT_ERR_ALLOC_FAILED
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|buf_ptr
operator|++
expr_stmt|;
name|cpool_current_index
operator|++
expr_stmt|;
block|}
name|SLJIT_ASSERT
argument_list|(
operator|!
name|first_patch
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|jump
operator|=
name|compiler
operator|->
name|jumps
expr_stmt|;
while|while
condition|(
name|jump
condition|)
block|{
name|buf_ptr
operator|=
operator|(
name|sljit_uw
operator|*
operator|)
name|jump
operator|->
name|addr
expr_stmt|;
if|if
condition|(
name|jump
operator|->
name|flags
operator|&
name|PATCH_B
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|jump
operator|->
name|flags
operator|&
name|JUMP_ADDR
operator|)
condition|)
block|{
name|SLJIT_ASSERT
argument_list|(
name|jump
operator|->
name|flags
operator|&
name|JUMP_LABEL
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
operator|(
operator|(
name|sljit_sw
operator|)
name|jump
operator|->
name|u
operator|.
name|label
operator|->
name|addr
operator|-
call|(
name|sljit_sw
call|)
argument_list|(
name|buf_ptr
operator|+
literal|2
argument_list|)
operator|)
operator|<=
literal|0x01ffffff
operator|&&
operator|(
operator|(
name|sljit_sw
operator|)
name|jump
operator|->
name|u
operator|.
name|label
operator|->
name|addr
operator|-
call|(
name|sljit_sw
call|)
argument_list|(
name|buf_ptr
operator|+
literal|2
argument_list|)
operator|)
operator|>=
operator|-
literal|0x02000000
argument_list|)
expr_stmt|;
operator|*
name|buf_ptr
operator||=
operator|(
operator|(
operator|(
name|sljit_sw
operator|)
name|jump
operator|->
name|u
operator|.
name|label
operator|->
name|addr
operator|-
call|(
name|sljit_sw
call|)
argument_list|(
name|buf_ptr
operator|+
literal|2
argument_list|)
operator|)
operator|>>
literal|2
operator|)
operator|&
literal|0x00ffffff
expr_stmt|;
block|}
else|else
block|{
name|SLJIT_ASSERT
argument_list|(
operator|(
operator|(
name|sljit_sw
operator|)
name|jump
operator|->
name|u
operator|.
name|target
operator|-
call|(
name|sljit_sw
call|)
argument_list|(
name|buf_ptr
operator|+
literal|2
argument_list|)
operator|)
operator|<=
literal|0x01ffffff
operator|&&
operator|(
operator|(
name|sljit_sw
operator|)
name|jump
operator|->
name|u
operator|.
name|target
operator|-
call|(
name|sljit_sw
call|)
argument_list|(
name|buf_ptr
operator|+
literal|2
argument_list|)
operator|)
operator|>=
operator|-
literal|0x02000000
argument_list|)
expr_stmt|;
operator|*
name|buf_ptr
operator||=
operator|(
operator|(
operator|(
name|sljit_sw
operator|)
name|jump
operator|->
name|u
operator|.
name|target
operator|-
call|(
name|sljit_sw
call|)
argument_list|(
name|buf_ptr
operator|+
literal|2
argument_list|)
operator|)
operator|>>
literal|2
operator|)
operator|&
literal|0x00ffffff
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|jump
operator|->
name|flags
operator|&
name|SLJIT_REWRITABLE_JUMP
condition|)
block|{
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_ARM_V5
operator|&&
name|SLJIT_CONFIG_ARM_V5
operator|)
name|jump
operator|->
name|addr
operator|=
operator|(
name|sljit_uw
operator|)
name|code_ptr
expr_stmt|;
name|code_ptr
index|[
literal|0
index|]
operator|=
operator|(
name|sljit_uw
operator|)
name|buf_ptr
expr_stmt|;
name|code_ptr
index|[
literal|1
index|]
operator|=
operator|*
name|buf_ptr
expr_stmt|;
name|inline_set_jump_addr
argument_list|(
operator|(
name|sljit_uw
operator|)
name|code_ptr
argument_list|,
operator|(
name|jump
operator|->
name|flags
operator|&
name|JUMP_LABEL
operator|)
condition|?
name|jump
operator|->
name|u
operator|.
name|label
operator|->
name|addr
else|:
name|jump
operator|->
name|u
operator|.
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|code_ptr
operator|+=
literal|2
expr_stmt|;
else|#
directive|else
name|inline_set_jump_addr
argument_list|(
operator|(
name|sljit_uw
operator|)
name|buf_ptr
argument_list|,
operator|(
name|jump
operator|->
name|flags
operator|&
name|JUMP_LABEL
operator|)
condition|?
name|jump
operator|->
name|u
operator|.
name|label
operator|->
name|addr
else|:
name|jump
operator|->
name|u
operator|.
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_ARM_V5
operator|&&
name|SLJIT_CONFIG_ARM_V5
operator|)
if|if
condition|(
name|jump
operator|->
name|flags
operator|&
name|IS_BL
condition|)
name|buf_ptr
operator|--
expr_stmt|;
if|if
condition|(
operator|*
name|buf_ptr
operator|&
operator|(
literal|1
operator|<<
literal|23
operator|)
condition|)
name|buf_ptr
operator|+=
operator|(
operator|(
operator|*
name|buf_ptr
operator|&
literal|0xfff
operator|)
operator|>>
literal|2
operator|)
operator|+
literal|2
expr_stmt|;
else|else
name|buf_ptr
operator|+=
literal|1
expr_stmt|;
operator|*
name|buf_ptr
operator|=
operator|(
name|jump
operator|->
name|flags
operator|&
name|JUMP_LABEL
operator|)
condition|?
name|jump
operator|->
name|u
operator|.
name|label
operator|->
name|addr
else|:
name|jump
operator|->
name|u
operator|.
name|target
expr_stmt|;
else|#
directive|else
name|inline_set_jump_addr
argument_list|(
operator|(
name|sljit_uw
operator|)
name|buf_ptr
argument_list|,
operator|(
name|jump
operator|->
name|flags
operator|&
name|JUMP_LABEL
operator|)
condition|?
name|jump
operator|->
name|u
operator|.
name|label
operator|->
name|addr
else|:
name|jump
operator|->
name|u
operator|.
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|jump
operator|=
name|jump
operator|->
name|next
expr_stmt|;
block|}
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_ARM_V5
operator|&&
name|SLJIT_CONFIG_ARM_V5
operator|)
name|const_
operator|=
name|compiler
operator|->
name|consts
expr_stmt|;
while|while
condition|(
name|const_
condition|)
block|{
name|buf_ptr
operator|=
operator|(
name|sljit_uw
operator|*
operator|)
name|const_
operator|->
name|addr
expr_stmt|;
name|const_
operator|->
name|addr
operator|=
operator|(
name|sljit_uw
operator|)
name|code_ptr
expr_stmt|;
name|code_ptr
index|[
literal|0
index|]
operator|=
operator|(
name|sljit_uw
operator|)
name|buf_ptr
expr_stmt|;
name|code_ptr
index|[
literal|1
index|]
operator|=
operator|*
name|buf_ptr
expr_stmt|;
if|if
condition|(
operator|*
name|buf_ptr
operator|&
operator|(
literal|1
operator|<<
literal|23
operator|)
condition|)
name|buf_ptr
operator|+=
operator|(
operator|(
operator|*
name|buf_ptr
operator|&
literal|0xfff
operator|)
operator|>>
literal|2
operator|)
operator|+
literal|2
expr_stmt|;
else|else
name|buf_ptr
operator|+=
literal|1
expr_stmt|;
comment|/* Set the value again (can be a simple constant). */
name|inline_set_const
argument_list|(
operator|(
name|sljit_uw
operator|)
name|code_ptr
argument_list|,
operator|*
name|buf_ptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|code_ptr
operator|+=
literal|2
expr_stmt|;
name|const_
operator|=
name|const_
operator|->
name|next
expr_stmt|;
block|}
endif|#
directive|endif
name|SLJIT_ASSERT
argument_list|(
name|code_ptr
operator|-
name|code
operator|<=
operator|(
name|sljit_si
operator|)
name|size
argument_list|)
expr_stmt|;
name|compiler
operator|->
name|error
operator|=
name|SLJIT_ERR_COMPILED
expr_stmt|;
name|compiler
operator|->
name|executable_size
operator|=
operator|(
name|code_ptr
operator|-
name|code
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|sljit_uw
argument_list|)
expr_stmt|;
name|SLJIT_CACHE_FLUSH
argument_list|(
name|code
argument_list|,
name|code_ptr
argument_list|)
expr_stmt|;
return|return
name|code
return|;
block|}
end_function
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_comment
comment|/*  Entry, exit                                                          */
end_comment
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_comment
comment|/* emit_op inp_flags.    WRITE_BACK must be the first, since it is a flag. */
end_comment
begin_define
DECL|macro|WRITE_BACK
define|#
directive|define
name|WRITE_BACK
value|0x01
end_define
begin_define
DECL|macro|ALLOW_IMM
define|#
directive|define
name|ALLOW_IMM
value|0x02
end_define
begin_define
DECL|macro|ALLOW_INV_IMM
define|#
directive|define
name|ALLOW_INV_IMM
value|0x04
end_define
begin_define
DECL|macro|ALLOW_ANY_IMM
define|#
directive|define
name|ALLOW_ANY_IMM
value|(ALLOW_IMM | ALLOW_INV_IMM)
end_define
begin_define
DECL|macro|ARG_TEST
define|#
directive|define
name|ARG_TEST
value|0x08
end_define
begin_comment
comment|/* Creates an index in data_transfer_insts array. */
end_comment
begin_define
DECL|macro|WORD_DATA
define|#
directive|define
name|WORD_DATA
value|0x00
end_define
begin_define
DECL|macro|BYTE_DATA
define|#
directive|define
name|BYTE_DATA
value|0x10
end_define
begin_define
DECL|macro|HALF_DATA
define|#
directive|define
name|HALF_DATA
value|0x20
end_define
begin_define
DECL|macro|SIGNED_DATA
define|#
directive|define
name|SIGNED_DATA
value|0x40
end_define
begin_define
DECL|macro|LOAD_DATA
define|#
directive|define
name|LOAD_DATA
value|0x80
end_define
begin_define
DECL|macro|EMIT_INSTRUCTION
define|#
directive|define
name|EMIT_INSTRUCTION
parameter_list|(
name|inst
parameter_list|)
define|\
value|FAIL_IF(push_inst(compiler, (inst)))
end_define
begin_comment
comment|/* Condition: AL. */
end_comment
begin_define
DECL|macro|EMIT_DATA_PROCESS_INS
define|#
directive|define
name|EMIT_DATA_PROCESS_INS
parameter_list|(
name|opcode
parameter_list|,
name|set_flags
parameter_list|,
name|dst
parameter_list|,
name|src1
parameter_list|,
name|src2
parameter_list|)
define|\
value|(0xe0000000 | ((opcode)<< 21) | (set_flags) | RD(dst) | RN(src1) | (src2))
end_define
begin_function_decl
specifier|static
name|sljit_si
name|emit_op
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|inp_flags
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src1
parameter_list|,
name|sljit_sw
name|src1w
parameter_list|,
name|sljit_si
name|src2
parameter_list|,
name|sljit_sw
name|src2w
parameter_list|)
function_decl|;
end_function_decl
begin_function
DECL|function|sljit_emit_enter
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_enter
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|args
parameter_list|,
name|sljit_si
name|scratches
parameter_list|,
name|sljit_si
name|saveds
parameter_list|,
name|sljit_si
name|local_size
parameter_list|)
block|{
name|sljit_si
name|size
decl_stmt|;
name|sljit_uw
name|push
decl_stmt|;
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|check_sljit_emit_enter
argument_list|(
name|compiler
argument_list|,
name|args
argument_list|,
name|scratches
argument_list|,
name|saveds
argument_list|,
name|local_size
argument_list|)
expr_stmt|;
name|compiler
operator|->
name|scratches
operator|=
name|scratches
expr_stmt|;
name|compiler
operator|->
name|saveds
operator|=
name|saveds
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_DEBUG
operator|&&
name|SLJIT_DEBUG
operator|)
name|compiler
operator|->
name|logical_local_size
operator|=
name|local_size
expr_stmt|;
endif|#
directive|endif
comment|/* Push saved registers, temporary registers 	   stmdb sp!, {..., lr} */
name|push
operator|=
name|PUSH
operator||
operator|(
literal|1
operator|<<
literal|14
operator|)
expr_stmt|;
if|if
condition|(
name|scratches
operator|>=
literal|5
condition|)
name|push
operator||=
literal|1
operator|<<
literal|11
expr_stmt|;
if|if
condition|(
name|scratches
operator|>=
literal|4
condition|)
name|push
operator||=
literal|1
operator|<<
literal|10
expr_stmt|;
if|if
condition|(
name|saveds
operator|>=
literal|5
condition|)
name|push
operator||=
literal|1
operator|<<
literal|8
expr_stmt|;
if|if
condition|(
name|saveds
operator|>=
literal|4
condition|)
name|push
operator||=
literal|1
operator|<<
literal|7
expr_stmt|;
if|if
condition|(
name|saveds
operator|>=
literal|3
condition|)
name|push
operator||=
literal|1
operator|<<
literal|6
expr_stmt|;
if|if
condition|(
name|saveds
operator|>=
literal|2
condition|)
name|push
operator||=
literal|1
operator|<<
literal|5
expr_stmt|;
if|if
condition|(
name|saveds
operator|>=
literal|1
condition|)
name|push
operator||=
literal|1
operator|<<
literal|4
expr_stmt|;
name|EMIT_INSTRUCTION
argument_list|(
name|push
argument_list|)
expr_stmt|;
comment|/* Stack must be aligned to 8 bytes: */
name|size
operator|=
operator|(
literal|1
operator|+
name|saveds
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|sljit_uw
argument_list|)
expr_stmt|;
if|if
condition|(
name|scratches
operator|>=
literal|4
condition|)
name|size
operator|+=
operator|(
name|scratches
operator|-
literal|3
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|sljit_uw
argument_list|)
expr_stmt|;
name|local_size
operator|+=
name|size
expr_stmt|;
name|local_size
operator|=
operator|(
name|local_size
operator|+
literal|7
operator|)
operator|&
operator|~
literal|7
expr_stmt|;
name|local_size
operator|-=
name|size
expr_stmt|;
name|compiler
operator|->
name|local_size
operator|=
name|local_size
expr_stmt|;
if|if
condition|(
name|local_size
operator|>
literal|0
condition|)
name|FAIL_IF
argument_list|(
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_SUB
argument_list|,
name|ALLOW_IMM
argument_list|,
name|SLJIT_LOCALS_REG
argument_list|,
literal|0
argument_list|,
name|SLJIT_LOCALS_REG
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|local_size
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|>=
literal|1
condition|)
name|EMIT_INSTRUCTION
argument_list|(
name|EMIT_DATA_PROCESS_INS
argument_list|(
name|MOV_DP
argument_list|,
literal|0
argument_list|,
name|SLJIT_SAVED_REG1
argument_list|,
name|SLJIT_UNUSED
argument_list|,
name|RM
argument_list|(
name|SLJIT_SCRATCH_REG1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|>=
literal|2
condition|)
name|EMIT_INSTRUCTION
argument_list|(
name|EMIT_DATA_PROCESS_INS
argument_list|(
name|MOV_DP
argument_list|,
literal|0
argument_list|,
name|SLJIT_SAVED_REG2
argument_list|,
name|SLJIT_UNUSED
argument_list|,
name|RM
argument_list|(
name|SLJIT_SCRATCH_REG2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|>=
literal|3
condition|)
name|EMIT_INSTRUCTION
argument_list|(
name|EMIT_DATA_PROCESS_INS
argument_list|(
name|MOV_DP
argument_list|,
literal|0
argument_list|,
name|SLJIT_SAVED_REG3
argument_list|,
name|SLJIT_UNUSED
argument_list|,
name|RM
argument_list|(
name|SLJIT_SCRATCH_REG3
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_function
DECL|function|sljit_set_context
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
name|sljit_set_context
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|args
parameter_list|,
name|sljit_si
name|scratches
parameter_list|,
name|sljit_si
name|saveds
parameter_list|,
name|sljit_si
name|local_size
parameter_list|)
block|{
name|sljit_si
name|size
decl_stmt|;
name|CHECK_ERROR_VOID
argument_list|()
expr_stmt|;
name|check_sljit_set_context
argument_list|(
name|compiler
argument_list|,
name|args
argument_list|,
name|scratches
argument_list|,
name|saveds
argument_list|,
name|local_size
argument_list|)
expr_stmt|;
name|compiler
operator|->
name|scratches
operator|=
name|scratches
expr_stmt|;
name|compiler
operator|->
name|saveds
operator|=
name|saveds
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_DEBUG
operator|&&
name|SLJIT_DEBUG
operator|)
name|compiler
operator|->
name|logical_local_size
operator|=
name|local_size
expr_stmt|;
endif|#
directive|endif
name|size
operator|=
operator|(
literal|1
operator|+
name|saveds
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|sljit_uw
argument_list|)
expr_stmt|;
if|if
condition|(
name|scratches
operator|>=
literal|4
condition|)
name|size
operator|+=
operator|(
name|scratches
operator|-
literal|3
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|sljit_uw
argument_list|)
expr_stmt|;
name|local_size
operator|+=
name|size
expr_stmt|;
name|local_size
operator|=
operator|(
name|local_size
operator|+
literal|7
operator|)
operator|&
operator|~
literal|7
expr_stmt|;
name|local_size
operator|-=
name|size
expr_stmt|;
name|compiler
operator|->
name|local_size
operator|=
name|local_size
expr_stmt|;
block|}
end_function
begin_function
DECL|function|sljit_emit_return
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_return
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|)
block|{
name|sljit_uw
name|pop
decl_stmt|;
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|check_sljit_emit_return
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|emit_mov_before_return
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|compiler
operator|->
name|local_size
operator|>
literal|0
condition|)
name|FAIL_IF
argument_list|(
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_ADD
argument_list|,
name|ALLOW_IMM
argument_list|,
name|SLJIT_LOCALS_REG
argument_list|,
literal|0
argument_list|,
name|SLJIT_LOCALS_REG
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|compiler
operator|->
name|local_size
argument_list|)
argument_list|)
expr_stmt|;
name|pop
operator|=
name|POP
operator||
operator|(
literal|1
operator|<<
literal|15
operator|)
expr_stmt|;
comment|/* Push saved registers, temporary registers 	   ldmia sp!, {..., pc} */
if|if
condition|(
name|compiler
operator|->
name|scratches
operator|>=
literal|5
condition|)
name|pop
operator||=
literal|1
operator|<<
literal|11
expr_stmt|;
if|if
condition|(
name|compiler
operator|->
name|scratches
operator|>=
literal|4
condition|)
name|pop
operator||=
literal|1
operator|<<
literal|10
expr_stmt|;
if|if
condition|(
name|compiler
operator|->
name|saveds
operator|>=
literal|5
condition|)
name|pop
operator||=
literal|1
operator|<<
literal|8
expr_stmt|;
if|if
condition|(
name|compiler
operator|->
name|saveds
operator|>=
literal|4
condition|)
name|pop
operator||=
literal|1
operator|<<
literal|7
expr_stmt|;
if|if
condition|(
name|compiler
operator|->
name|saveds
operator|>=
literal|3
condition|)
name|pop
operator||=
literal|1
operator|<<
literal|6
expr_stmt|;
if|if
condition|(
name|compiler
operator|->
name|saveds
operator|>=
literal|2
condition|)
name|pop
operator||=
literal|1
operator|<<
literal|5
expr_stmt|;
if|if
condition|(
name|compiler
operator|->
name|saveds
operator|>=
literal|1
condition|)
name|pop
operator||=
literal|1
operator|<<
literal|4
expr_stmt|;
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|pop
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_comment
comment|/*  Operators                                                            */
end_comment
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_comment
comment|/* s/l - store/load (1 bit)    u/s - signed/unsigned (1 bit)    w/b/h/N - word/byte/half/NOT allowed (2 bit)    It contans 16 items, but not all are different. */
end_comment
begin_decl_stmt
DECL|variable|data_transfer_insts
specifier|static
name|sljit_sw
name|data_transfer_insts
index|[
literal|16
index|]
init|=
block|{
comment|/* s u w */
literal|0xe5000000
comment|/* str */
block|,
comment|/* s u b */
literal|0xe5400000
comment|/* strb */
block|,
comment|/* s u h */
literal|0xe10000b0
comment|/* strh */
block|,
comment|/* s u N */
literal|0x00000000
comment|/* not allowed */
block|,
comment|/* s s w */
literal|0xe5000000
comment|/* str */
block|,
comment|/* s s b */
literal|0xe5400000
comment|/* strb */
block|,
comment|/* s s h */
literal|0xe10000b0
comment|/* strh */
block|,
comment|/* s s N */
literal|0x00000000
comment|/* not allowed */
block|,
comment|/* l u w */
literal|0xe5100000
comment|/* ldr */
block|,
comment|/* l u b */
literal|0xe5500000
comment|/* ldrb */
block|,
comment|/* l u h */
literal|0xe11000b0
comment|/* ldrh */
block|,
comment|/* l u N */
literal|0x00000000
comment|/* not allowed */
block|,
comment|/* l s w */
literal|0xe5100000
comment|/* ldr */
block|,
comment|/* l s b */
literal|0xe11000d0
comment|/* ldrsb */
block|,
comment|/* l s h */
literal|0xe11000f0
comment|/* ldrsh */
block|,
comment|/* l s N */
literal|0x00000000
comment|/* not allowed */
block|, }
decl_stmt|;
end_decl_stmt
begin_define
DECL|macro|EMIT_DATA_TRANSFER
define|#
directive|define
name|EMIT_DATA_TRANSFER
parameter_list|(
name|type
parameter_list|,
name|add
parameter_list|,
name|wb
parameter_list|,
name|target
parameter_list|,
name|base1
parameter_list|,
name|base2
parameter_list|)
define|\
value|(data_transfer_insts[(type)>> 4] | ((add)<< 23) | ((wb)<< 21) | (reg_map[target]<< 12) | (reg_map[base1]<< 16) | (base2))
end_define
begin_comment
comment|/* Normal ldr/str instruction.    Type2: ldrsb, ldrh, ldrsh */
end_comment
begin_define
DECL|macro|IS_TYPE1_TRANSFER
define|#
directive|define
name|IS_TYPE1_TRANSFER
parameter_list|(
name|type
parameter_list|)
define|\
value|(data_transfer_insts[(type)>> 4]& 0x04000000)
end_define
begin_define
DECL|macro|TYPE2_TRANSFER_IMM
define|#
directive|define
name|TYPE2_TRANSFER_IMM
parameter_list|(
name|imm
parameter_list|)
define|\
value|(((imm)& 0xf) | (((imm)& 0xf0)<< 4) | (1<< 22))
end_define
begin_comment
comment|/* flags: */
end_comment
begin_comment
comment|/* Arguments are swapped. */
end_comment
begin_define
DECL|macro|ARGS_SWAPPED
define|#
directive|define
name|ARGS_SWAPPED
value|0x01
end_define
begin_comment
comment|/* Inverted immediate. */
end_comment
begin_define
DECL|macro|INV_IMM
define|#
directive|define
name|INV_IMM
value|0x02
end_define
begin_comment
comment|/* Source and destination is register. */
end_comment
begin_define
DECL|macro|REG_DEST
define|#
directive|define
name|REG_DEST
value|0x04
end_define
begin_define
DECL|macro|REG_SOURCE
define|#
directive|define
name|REG_SOURCE
value|0x08
end_define
begin_comment
comment|/* One instruction is enough. */
end_comment
begin_define
DECL|macro|FAST_DEST
define|#
directive|define
name|FAST_DEST
value|0x10
end_define
begin_comment
comment|/* Multiple instructions are required. */
end_comment
begin_define
DECL|macro|SLOW_DEST
define|#
directive|define
name|SLOW_DEST
value|0x20
end_define
begin_comment
comment|/* SET_FLAGS must be (1<< 20) as it is also the value of S bit (can be used for optimization). */
end_comment
begin_define
DECL|macro|SET_FLAGS
define|#
directive|define
name|SET_FLAGS
value|(1<< 20)
end_define
begin_comment
comment|/* dst: reg    src1: reg    src2: reg or imm (if allowed)    SRC2_IMM must be (1<< 25) as it is also the value of I bit (can be used for optimization). */
end_comment
begin_define
DECL|macro|SRC2_IMM
define|#
directive|define
name|SRC2_IMM
value|(1<< 25)
end_define
begin_define
DECL|macro|EMIT_DATA_PROCESS_INS_AND_RETURN
define|#
directive|define
name|EMIT_DATA_PROCESS_INS_AND_RETURN
parameter_list|(
name|opcode
parameter_list|)
define|\
value|return push_inst(compiler, EMIT_DATA_PROCESS_INS(opcode, flags& SET_FLAGS, dst, src1, (src2& SRC2_IMM) ? src2 : RM(src2)))
end_define
begin_define
DECL|macro|EMIT_FULL_DATA_PROCESS_INS_AND_RETURN
define|#
directive|define
name|EMIT_FULL_DATA_PROCESS_INS_AND_RETURN
parameter_list|(
name|opcode
parameter_list|,
name|dst
parameter_list|,
name|src1
parameter_list|,
name|src2
parameter_list|)
define|\
value|return push_inst(compiler, EMIT_DATA_PROCESS_INS(opcode, flags& SET_FLAGS, dst, src1, src2))
end_define
begin_define
DECL|macro|EMIT_SHIFT_INS_AND_RETURN
define|#
directive|define
name|EMIT_SHIFT_INS_AND_RETURN
parameter_list|(
name|opcode
parameter_list|)
define|\
value|SLJIT_ASSERT(!(flags& INV_IMM)&& !(src2& SRC2_IMM)); \ 	if (compiler->shift_imm != 0x20) { \ 		SLJIT_ASSERT(src1 == TMP_REG1); \ 		SLJIT_ASSERT(!(flags& ARGS_SWAPPED)); \ 		if (compiler->shift_imm != 0) \ 			return push_inst(compiler, EMIT_DATA_PROCESS_INS(MOV_DP, flags& SET_FLAGS, dst, SLJIT_UNUSED, (compiler->shift_imm<< 7) | (opcode<< 5) | reg_map[src2])); \ 		return push_inst(compiler, EMIT_DATA_PROCESS_INS(MOV_DP, flags& SET_FLAGS, dst, SLJIT_UNUSED, reg_map[src2])); \ 	} \ 	return push_inst(compiler, EMIT_DATA_PROCESS_INS(MOV_DP, flags& SET_FLAGS, dst, SLJIT_UNUSED, (reg_map[(flags& ARGS_SWAPPED) ? src1 : src2]<< 8) | (opcode<< 5) | 0x10 | ((flags& ARGS_SWAPPED) ? reg_map[src2] : reg_map[src1])));
end_define
begin_function
DECL|function|emit_single_op
specifier|static
name|SLJIT_INLINE
name|sljit_si
name|emit_single_op
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|flags
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_si
name|src1
parameter_list|,
name|sljit_si
name|src2
parameter_list|)
block|{
name|sljit_sw
name|mul_inst
decl_stmt|;
switch|switch
condition|(
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|SLJIT_MOV
case|:
name|SLJIT_ASSERT
argument_list|(
name|src1
operator|==
name|TMP_REG1
operator|&&
operator|!
operator|(
name|flags
operator|&
name|ARGS_SWAPPED
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|!=
name|src2
condition|)
block|{
if|if
condition|(
name|src2
operator|&
name|SRC2_IMM
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|INV_IMM
condition|)
name|EMIT_FULL_DATA_PROCESS_INS_AND_RETURN
argument_list|(
name|MVN_DP
argument_list|,
name|dst
argument_list|,
name|SLJIT_UNUSED
argument_list|,
name|src2
argument_list|)
expr_stmt|;
name|EMIT_FULL_DATA_PROCESS_INS_AND_RETURN
argument_list|(
name|MOV_DP
argument_list|,
name|dst
argument_list|,
name|SLJIT_UNUSED
argument_list|,
name|src2
argument_list|)
expr_stmt|;
block|}
name|EMIT_FULL_DATA_PROCESS_INS_AND_RETURN
argument_list|(
name|MOV_DP
argument_list|,
name|dst
argument_list|,
name|SLJIT_UNUSED
argument_list|,
name|reg_map
index|[
name|src2
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|SLJIT_SUCCESS
return|;
case|case
name|SLJIT_MOV_UB
case|:
case|case
name|SLJIT_MOV_SB
case|:
name|SLJIT_ASSERT
argument_list|(
name|src1
operator|==
name|TMP_REG1
operator|&&
operator|!
operator|(
name|flags
operator|&
name|ARGS_SWAPPED
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|REG_DEST
operator||
name|REG_SOURCE
operator|)
operator|)
operator|==
operator|(
name|REG_DEST
operator||
name|REG_SOURCE
operator|)
condition|)
block|{
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_ARM_V5
operator|&&
name|SLJIT_CONFIG_ARM_V5
operator|)
if|if
condition|(
name|op
operator|==
name|SLJIT_MOV_UB
condition|)
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|EMIT_DATA_PROCESS_INS
argument_list|(
name|AND_DP
argument_list|,
literal|0
argument_list|,
name|dst
argument_list|,
name|src2
argument_list|,
name|SRC2_IMM
operator||
literal|0xff
argument_list|)
argument_list|)
return|;
name|EMIT_INSTRUCTION
argument_list|(
name|EMIT_DATA_PROCESS_INS
argument_list|(
name|MOV_DP
argument_list|,
literal|0
argument_list|,
name|dst
argument_list|,
name|SLJIT_UNUSED
argument_list|,
operator|(
literal|24
operator|<<
literal|7
operator|)
operator||
name|reg_map
index|[
name|src2
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|EMIT_DATA_PROCESS_INS
argument_list|(
name|MOV_DP
argument_list|,
literal|0
argument_list|,
name|dst
argument_list|,
name|SLJIT_UNUSED
argument_list|,
operator|(
literal|24
operator|<<
literal|7
operator|)
operator||
operator|(
name|op
operator|==
name|SLJIT_MOV_UB
condition|?
literal|0x20
else|:
literal|0x40
operator|)
operator||
name|reg_map
index|[
name|dst
index|]
argument_list|)
argument_list|)
return|;
else|#
directive|else
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
operator|(
name|op
operator|==
name|SLJIT_MOV_UB
condition|?
name|UXTB
else|:
name|SXTB
operator|)
operator||
name|RD
argument_list|(
name|dst
argument_list|)
operator||
name|RM
argument_list|(
name|src2
argument_list|)
argument_list|)
return|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|dst
operator|!=
name|src2
condition|)
block|{
name|SLJIT_ASSERT
argument_list|(
name|src2
operator|&
name|SRC2_IMM
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|INV_IMM
condition|)
name|EMIT_FULL_DATA_PROCESS_INS_AND_RETURN
argument_list|(
name|MVN_DP
argument_list|,
name|dst
argument_list|,
name|SLJIT_UNUSED
argument_list|,
name|src2
argument_list|)
expr_stmt|;
name|EMIT_FULL_DATA_PROCESS_INS_AND_RETURN
argument_list|(
name|MOV_DP
argument_list|,
name|dst
argument_list|,
name|SLJIT_UNUSED
argument_list|,
name|src2
argument_list|)
expr_stmt|;
block|}
return|return
name|SLJIT_SUCCESS
return|;
case|case
name|SLJIT_MOV_UH
case|:
case|case
name|SLJIT_MOV_SH
case|:
name|SLJIT_ASSERT
argument_list|(
name|src1
operator|==
name|TMP_REG1
operator|&&
operator|!
operator|(
name|flags
operator|&
name|ARGS_SWAPPED
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|REG_DEST
operator||
name|REG_SOURCE
operator|)
operator|)
operator|==
operator|(
name|REG_DEST
operator||
name|REG_SOURCE
operator|)
condition|)
block|{
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_ARM_V5
operator|&&
name|SLJIT_CONFIG_ARM_V5
operator|)
name|EMIT_INSTRUCTION
argument_list|(
name|EMIT_DATA_PROCESS_INS
argument_list|(
name|MOV_DP
argument_list|,
literal|0
argument_list|,
name|dst
argument_list|,
name|SLJIT_UNUSED
argument_list|,
operator|(
literal|16
operator|<<
literal|7
operator|)
operator||
name|reg_map
index|[
name|src2
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|EMIT_DATA_PROCESS_INS
argument_list|(
name|MOV_DP
argument_list|,
literal|0
argument_list|,
name|dst
argument_list|,
name|SLJIT_UNUSED
argument_list|,
operator|(
literal|16
operator|<<
literal|7
operator|)
operator||
operator|(
name|op
operator|==
name|SLJIT_MOV_UH
condition|?
literal|0x20
else|:
literal|0x40
operator|)
operator||
name|reg_map
index|[
name|dst
index|]
argument_list|)
argument_list|)
return|;
else|#
directive|else
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
operator|(
name|op
operator|==
name|SLJIT_MOV_UH
condition|?
name|UXTH
else|:
name|SXTH
operator|)
operator||
name|RD
argument_list|(
name|dst
argument_list|)
operator||
name|RM
argument_list|(
name|src2
argument_list|)
argument_list|)
return|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|dst
operator|!=
name|src2
condition|)
block|{
name|SLJIT_ASSERT
argument_list|(
name|src2
operator|&
name|SRC2_IMM
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|INV_IMM
condition|)
name|EMIT_FULL_DATA_PROCESS_INS_AND_RETURN
argument_list|(
name|MVN_DP
argument_list|,
name|dst
argument_list|,
name|SLJIT_UNUSED
argument_list|,
name|src2
argument_list|)
expr_stmt|;
name|EMIT_FULL_DATA_PROCESS_INS_AND_RETURN
argument_list|(
name|MOV_DP
argument_list|,
name|dst
argument_list|,
name|SLJIT_UNUSED
argument_list|,
name|src2
argument_list|)
expr_stmt|;
block|}
return|return
name|SLJIT_SUCCESS
return|;
case|case
name|SLJIT_NOT
case|:
if|if
condition|(
name|src2
operator|&
name|SRC2_IMM
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|INV_IMM
condition|)
name|EMIT_FULL_DATA_PROCESS_INS_AND_RETURN
argument_list|(
name|MOV_DP
argument_list|,
name|dst
argument_list|,
name|SLJIT_UNUSED
argument_list|,
name|src2
argument_list|)
expr_stmt|;
name|EMIT_FULL_DATA_PROCESS_INS_AND_RETURN
argument_list|(
name|MVN_DP
argument_list|,
name|dst
argument_list|,
name|SLJIT_UNUSED
argument_list|,
name|src2
argument_list|)
expr_stmt|;
block|}
name|EMIT_FULL_DATA_PROCESS_INS_AND_RETURN
argument_list|(
name|MVN_DP
argument_list|,
name|dst
argument_list|,
name|SLJIT_UNUSED
argument_list|,
name|RM
argument_list|(
name|src2
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|SLJIT_CLZ
case|:
name|SLJIT_ASSERT
argument_list|(
operator|!
operator|(
name|flags
operator|&
name|INV_IMM
operator|)
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
operator|!
operator|(
name|src2
operator|&
name|SRC2_IMM
operator|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|CLZ
operator||
name|RD
argument_list|(
name|dst
argument_list|)
operator||
name|RM
argument_list|(
name|src2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SET_FLAGS
condition|)
name|EMIT_FULL_DATA_PROCESS_INS_AND_RETURN
argument_list|(
name|CMP_DP
argument_list|,
name|SLJIT_UNUSED
argument_list|,
name|dst
argument_list|,
name|SRC2_IMM
argument_list|)
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
case|case
name|SLJIT_ADD
case|:
name|SLJIT_ASSERT
argument_list|(
operator|!
operator|(
name|flags
operator|&
name|INV_IMM
operator|)
argument_list|)
expr_stmt|;
name|EMIT_DATA_PROCESS_INS_AND_RETURN
argument_list|(
name|ADD_DP
argument_list|)
expr_stmt|;
case|case
name|SLJIT_ADDC
case|:
name|SLJIT_ASSERT
argument_list|(
operator|!
operator|(
name|flags
operator|&
name|INV_IMM
operator|)
argument_list|)
expr_stmt|;
name|EMIT_DATA_PROCESS_INS_AND_RETURN
argument_list|(
name|ADC_DP
argument_list|)
expr_stmt|;
case|case
name|SLJIT_SUB
case|:
name|SLJIT_ASSERT
argument_list|(
operator|!
operator|(
name|flags
operator|&
name|INV_IMM
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|ARGS_SWAPPED
operator|)
condition|)
name|EMIT_DATA_PROCESS_INS_AND_RETURN
argument_list|(
name|SUB_DP
argument_list|)
expr_stmt|;
name|EMIT_DATA_PROCESS_INS_AND_RETURN
argument_list|(
name|RSB_DP
argument_list|)
expr_stmt|;
case|case
name|SLJIT_SUBC
case|:
name|SLJIT_ASSERT
argument_list|(
operator|!
operator|(
name|flags
operator|&
name|INV_IMM
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|ARGS_SWAPPED
operator|)
condition|)
name|EMIT_DATA_PROCESS_INS_AND_RETURN
argument_list|(
name|SBC_DP
argument_list|)
expr_stmt|;
name|EMIT_DATA_PROCESS_INS_AND_RETURN
argument_list|(
name|RSC_DP
argument_list|)
expr_stmt|;
case|case
name|SLJIT_MUL
case|:
name|SLJIT_ASSERT
argument_list|(
operator|!
operator|(
name|flags
operator|&
name|INV_IMM
operator|)
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
operator|!
operator|(
name|src2
operator|&
name|SRC2_IMM
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|op
operator|&
name|SLJIT_SET_O
argument_list|)
condition|)
name|mul_inst
operator|=
name|SMULL
operator||
operator|(
name|reg_map
index|[
name|TMP_REG3
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|reg_map
index|[
name|dst
index|]
operator|<<
literal|12
operator|)
expr_stmt|;
else|else
name|mul_inst
operator|=
name|MUL
operator||
operator|(
name|reg_map
index|[
name|dst
index|]
operator|<<
literal|16
operator|)
expr_stmt|;
if|if
condition|(
name|dst
operator|!=
name|src2
condition|)
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|mul_inst
operator||
operator|(
name|reg_map
index|[
name|src1
index|]
operator|<<
literal|8
operator|)
operator||
name|reg_map
index|[
name|src2
index|]
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|dst
operator|!=
name|src1
condition|)
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|mul_inst
operator||
operator|(
name|reg_map
index|[
name|src2
index|]
operator|<<
literal|8
operator|)
operator||
name|reg_map
index|[
name|src1
index|]
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Rm and Rd must not be the same register. */
name|SLJIT_ASSERT
argument_list|(
name|dst
operator|!=
name|TMP_REG1
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|EMIT_DATA_PROCESS_INS
argument_list|(
name|MOV_DP
argument_list|,
literal|0
argument_list|,
name|TMP_REG1
argument_list|,
name|SLJIT_UNUSED
argument_list|,
name|reg_map
index|[
name|src2
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|mul_inst
operator||
operator|(
name|reg_map
index|[
name|src2
index|]
operator|<<
literal|8
operator|)
operator||
name|reg_map
index|[
name|TMP_REG1
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|op
operator|&
name|SLJIT_SET_O
operator|)
condition|)
return|return
name|SLJIT_SUCCESS
return|;
comment|/* We need to use TMP_REG3. */
name|compiler
operator|->
name|cache_arg
operator|=
literal|0
expr_stmt|;
name|compiler
operator|->
name|cache_argw
operator|=
literal|0
expr_stmt|;
comment|/* cmp TMP_REG2, dst asr #31. */
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|EMIT_DATA_PROCESS_INS
argument_list|(
name|CMP_DP
argument_list|,
name|SET_FLAGS
argument_list|,
name|SLJIT_UNUSED
argument_list|,
name|TMP_REG3
argument_list|,
name|RM
argument_list|(
name|dst
argument_list|)
operator||
literal|0xfc0
argument_list|)
argument_list|)
return|;
case|case
name|SLJIT_AND
case|:
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|INV_IMM
operator|)
condition|)
name|EMIT_DATA_PROCESS_INS_AND_RETURN
argument_list|(
name|AND_DP
argument_list|)
expr_stmt|;
name|EMIT_DATA_PROCESS_INS_AND_RETURN
argument_list|(
name|BIC_DP
argument_list|)
expr_stmt|;
case|case
name|SLJIT_OR
case|:
name|SLJIT_ASSERT
argument_list|(
operator|!
operator|(
name|flags
operator|&
name|INV_IMM
operator|)
argument_list|)
expr_stmt|;
name|EMIT_DATA_PROCESS_INS_AND_RETURN
argument_list|(
name|ORR_DP
argument_list|)
expr_stmt|;
case|case
name|SLJIT_XOR
case|:
name|SLJIT_ASSERT
argument_list|(
operator|!
operator|(
name|flags
operator|&
name|INV_IMM
operator|)
argument_list|)
expr_stmt|;
name|EMIT_DATA_PROCESS_INS_AND_RETURN
argument_list|(
name|EOR_DP
argument_list|)
expr_stmt|;
case|case
name|SLJIT_SHL
case|:
name|EMIT_SHIFT_INS_AND_RETURN
argument_list|(
literal|0
argument_list|)
expr_stmt|;
case|case
name|SLJIT_LSHR
case|:
name|EMIT_SHIFT_INS_AND_RETURN
argument_list|(
literal|1
argument_list|)
expr_stmt|;
case|case
name|SLJIT_ASHR
case|:
name|EMIT_SHIFT_INS_AND_RETURN
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_undef
DECL|macro|EMIT_DATA_PROCESS_INS_AND_RETURN
undef|#
directive|undef
name|EMIT_DATA_PROCESS_INS_AND_RETURN
end_undef
begin_undef
DECL|macro|EMIT_FULL_DATA_PROCESS_INS_AND_RETURN
undef|#
directive|undef
name|EMIT_FULL_DATA_PROCESS_INS_AND_RETURN
end_undef
begin_undef
DECL|macro|EMIT_SHIFT_INS_AND_RETURN
undef|#
directive|undef
name|EMIT_SHIFT_INS_AND_RETURN
end_undef
begin_comment
comment|/* Tests whether the immediate can be stored in the 12 bit imm field.    Returns with 0 if not possible. */
end_comment
begin_function
DECL|function|get_imm
specifier|static
name|sljit_uw
name|get_imm
parameter_list|(
name|sljit_uw
name|imm
parameter_list|)
block|{
name|sljit_si
name|rol
decl_stmt|;
if|if
condition|(
name|imm
operator|<=
literal|0xff
condition|)
return|return
name|SRC2_IMM
operator||
name|imm
return|;
if|if
condition|(
operator|!
operator|(
name|imm
operator|&
literal|0xff000000
operator|)
condition|)
block|{
name|imm
operator|<<=
literal|8
expr_stmt|;
name|rol
operator|=
literal|8
expr_stmt|;
block|}
else|else
block|{
name|imm
operator|=
operator|(
name|imm
operator|<<
literal|24
operator|)
operator||
operator|(
name|imm
operator|>>
literal|8
operator|)
expr_stmt|;
name|rol
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|imm
operator|&
literal|0xff000000
operator|)
condition|)
block|{
name|imm
operator|<<=
literal|8
expr_stmt|;
name|rol
operator|+=
literal|4
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|imm
operator|&
literal|0xf0000000
operator|)
condition|)
block|{
name|imm
operator|<<=
literal|4
expr_stmt|;
name|rol
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|imm
operator|&
literal|0xc0000000
operator|)
condition|)
block|{
name|imm
operator|<<=
literal|2
expr_stmt|;
name|rol
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|imm
operator|&
literal|0x00ffffff
operator|)
condition|)
return|return
name|SRC2_IMM
operator||
operator|(
name|imm
operator|>>
literal|24
operator|)
operator||
operator|(
name|rol
operator|<<
literal|8
operator|)
return|;
else|else
return|return
literal|0
return|;
block|}
end_function
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_ARM_V5
operator|&&
name|SLJIT_CONFIG_ARM_V5
operator|)
end_if
begin_function
DECL|function|generate_int
specifier|static
name|sljit_si
name|generate_int
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|reg
parameter_list|,
name|sljit_uw
name|imm
parameter_list|,
name|sljit_si
name|positive
parameter_list|)
block|{
name|sljit_uw
name|mask
decl_stmt|;
name|sljit_uw
name|imm1
decl_stmt|;
name|sljit_uw
name|imm2
decl_stmt|;
name|sljit_si
name|rol
decl_stmt|;
comment|/* Step1: Search a zero byte (8 continous zero bit). */
name|mask
operator|=
literal|0xff000000
expr_stmt|;
name|rol
operator|=
literal|8
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|imm
operator|&
name|mask
operator|)
condition|)
block|{
comment|/* Rol imm by rol. */
name|imm
operator|=
operator|(
name|imm
operator|<<
name|rol
operator|)
operator||
operator|(
name|imm
operator|>>
operator|(
literal|32
operator|-
name|rol
operator|)
operator|)
expr_stmt|;
comment|/* Calculate arm rol. */
name|rol
operator|=
literal|4
operator|+
operator|(
name|rol
operator|>>
literal|1
operator|)
expr_stmt|;
break|break;
block|}
name|rol
operator|+=
literal|2
expr_stmt|;
name|mask
operator|>>=
literal|2
expr_stmt|;
if|if
condition|(
name|mask
operator|&
literal|0x3
condition|)
block|{
comment|/* rol by 8. */
name|imm
operator|=
operator|(
name|imm
operator|<<
literal|8
operator|)
operator||
operator|(
name|imm
operator|>>
literal|24
operator|)
expr_stmt|;
name|mask
operator|=
literal|0xff00
expr_stmt|;
name|rol
operator|=
literal|24
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|imm
operator|&
name|mask
operator|)
condition|)
block|{
comment|/* Rol imm by rol. */
name|imm
operator|=
operator|(
name|imm
operator|<<
name|rol
operator|)
operator||
operator|(
name|imm
operator|>>
operator|(
literal|32
operator|-
name|rol
operator|)
operator|)
expr_stmt|;
comment|/* Calculate arm rol. */
name|rol
operator|=
operator|(
name|rol
operator|>>
literal|1
operator|)
operator|-
literal|8
expr_stmt|;
break|break;
block|}
name|rol
operator|+=
literal|2
expr_stmt|;
name|mask
operator|>>=
literal|2
expr_stmt|;
if|if
condition|(
name|mask
operator|&
literal|0x3
condition|)
return|return
literal|0
return|;
block|}
break|break;
block|}
block|}
comment|/* The low 8 bit must be zero. */
name|SLJIT_ASSERT
argument_list|(
operator|!
operator|(
name|imm
operator|&
literal|0xff
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|imm
operator|&
literal|0xff000000
operator|)
condition|)
block|{
name|imm1
operator|=
name|SRC2_IMM
operator||
operator|(
operator|(
name|imm
operator|>>
literal|16
operator|)
operator|&
literal|0xff
operator|)
operator||
operator|(
operator|(
operator|(
name|rol
operator|+
literal|4
operator|)
operator|&
literal|0xf
operator|)
operator|<<
literal|8
operator|)
expr_stmt|;
name|imm2
operator|=
name|SRC2_IMM
operator||
operator|(
operator|(
name|imm
operator|>>
literal|8
operator|)
operator|&
literal|0xff
operator|)
operator||
operator|(
operator|(
operator|(
name|rol
operator|+
literal|8
operator|)
operator|&
literal|0xf
operator|)
operator|<<
literal|8
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|imm
operator|&
literal|0xc0000000
condition|)
block|{
name|imm1
operator|=
name|SRC2_IMM
operator||
operator|(
operator|(
name|imm
operator|>>
literal|24
operator|)
operator|&
literal|0xff
operator|)
operator||
operator|(
operator|(
name|rol
operator|&
literal|0xf
operator|)
operator|<<
literal|8
operator|)
expr_stmt|;
name|imm
operator|<<=
literal|8
expr_stmt|;
name|rol
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|imm
operator|&
literal|0xff000000
operator|)
condition|)
block|{
name|imm
operator|<<=
literal|8
expr_stmt|;
name|rol
operator|+=
literal|4
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|imm
operator|&
literal|0xf0000000
operator|)
condition|)
block|{
name|imm
operator|<<=
literal|4
expr_stmt|;
name|rol
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|imm
operator|&
literal|0xc0000000
operator|)
condition|)
block|{
name|imm
operator|<<=
literal|2
expr_stmt|;
name|rol
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|imm
operator|&
literal|0x00ffffff
operator|)
condition|)
name|imm2
operator|=
name|SRC2_IMM
operator||
operator|(
name|imm
operator|>>
literal|24
operator|)
operator||
operator|(
operator|(
name|rol
operator|&
literal|0xf
operator|)
operator|<<
literal|8
operator|)
expr_stmt|;
else|else
return|return
literal|0
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|imm
operator|&
literal|0xf0000000
operator|)
condition|)
block|{
name|imm
operator|<<=
literal|4
expr_stmt|;
name|rol
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|imm
operator|&
literal|0xc0000000
operator|)
condition|)
block|{
name|imm
operator|<<=
literal|2
expr_stmt|;
name|rol
operator|+=
literal|1
expr_stmt|;
block|}
name|imm1
operator|=
name|SRC2_IMM
operator||
operator|(
operator|(
name|imm
operator|>>
literal|24
operator|)
operator|&
literal|0xff
operator|)
operator||
operator|(
operator|(
name|rol
operator|&
literal|0xf
operator|)
operator|<<
literal|8
operator|)
expr_stmt|;
name|imm
operator|<<=
literal|8
expr_stmt|;
name|rol
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|imm
operator|&
literal|0xf0000000
operator|)
condition|)
block|{
name|imm
operator|<<=
literal|4
expr_stmt|;
name|rol
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|imm
operator|&
literal|0xc0000000
operator|)
condition|)
block|{
name|imm
operator|<<=
literal|2
expr_stmt|;
name|rol
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|imm
operator|&
literal|0x00ffffff
operator|)
condition|)
name|imm2
operator|=
name|SRC2_IMM
operator||
operator|(
name|imm
operator|>>
literal|24
operator|)
operator||
operator|(
operator|(
name|rol
operator|&
literal|0xf
operator|)
operator|<<
literal|8
operator|)
expr_stmt|;
else|else
return|return
literal|0
return|;
block|}
name|EMIT_INSTRUCTION
argument_list|(
name|EMIT_DATA_PROCESS_INS
argument_list|(
name|positive
condition|?
name|MOV_DP
else|:
name|MVN_DP
argument_list|,
literal|0
argument_list|,
name|reg
argument_list|,
name|SLJIT_UNUSED
argument_list|,
name|imm1
argument_list|)
argument_list|)
expr_stmt|;
name|EMIT_INSTRUCTION
argument_list|(
name|EMIT_DATA_PROCESS_INS
argument_list|(
name|positive
condition|?
name|ORR_DP
else|:
name|BIC_DP
argument_list|,
literal|0
argument_list|,
name|reg
argument_list|,
name|reg
argument_list|,
name|imm2
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|load_immediate
specifier|static
name|sljit_si
name|load_immediate
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|reg
parameter_list|,
name|sljit_uw
name|imm
parameter_list|)
block|{
name|sljit_uw
name|tmp
decl_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_ARM_V7
operator|&&
name|SLJIT_CONFIG_ARM_V7
operator|)
if|if
condition|(
operator|!
operator|(
name|imm
operator|&
operator|~
literal|0xffff
operator|)
condition|)
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|MOVW
operator||
name|RD
argument_list|(
name|reg
argument_list|)
operator||
operator|(
operator|(
name|imm
operator|<<
literal|4
operator|)
operator|&
literal|0xf0000
operator|)
operator||
operator|(
name|imm
operator|&
literal|0xfff
operator|)
argument_list|)
return|;
endif|#
directive|endif
comment|/* Create imm by 1 inst. */
name|tmp
operator|=
name|get_imm
argument_list|(
name|imm
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
condition|)
block|{
name|EMIT_INSTRUCTION
argument_list|(
name|EMIT_DATA_PROCESS_INS
argument_list|(
name|MOV_DP
argument_list|,
literal|0
argument_list|,
name|reg
argument_list|,
name|SLJIT_UNUSED
argument_list|,
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
name|tmp
operator|=
name|get_imm
argument_list|(
operator|~
name|imm
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
condition|)
block|{
name|EMIT_INSTRUCTION
argument_list|(
name|EMIT_DATA_PROCESS_INS
argument_list|(
name|MVN_DP
argument_list|,
literal|0
argument_list|,
name|reg
argument_list|,
name|SLJIT_UNUSED
argument_list|,
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_ARM_V5
operator|&&
name|SLJIT_CONFIG_ARM_V5
operator|)
comment|/* Create imm by 2 inst. */
name|FAIL_IF
argument_list|(
name|generate_int
argument_list|(
name|compiler
argument_list|,
name|reg
argument_list|,
name|imm
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|generate_int
argument_list|(
name|compiler
argument_list|,
name|reg
argument_list|,
operator|~
name|imm
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Load integer. */
return|return
name|push_inst_with_literal
argument_list|(
name|compiler
argument_list|,
name|EMIT_DATA_TRANSFER
argument_list|(
name|WORD_DATA
operator||
name|LOAD_DATA
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|reg
argument_list|,
name|TMP_PC
argument_list|,
literal|0
argument_list|)
argument_list|,
name|imm
argument_list|)
return|;
else|#
directive|else
return|return
name|emit_imm
argument_list|(
name|compiler
argument_list|,
name|reg
argument_list|,
name|imm
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/* Helper function. Dst should be reg + value, using at most 1 instruction, flags does not set. */
end_comment
begin_function
DECL|function|emit_set_delta
specifier|static
name|sljit_si
name|emit_set_delta
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_si
name|reg
parameter_list|,
name|sljit_sw
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|>=
literal|0
condition|)
block|{
name|value
operator|=
name|get_imm
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
condition|)
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|EMIT_DATA_PROCESS_INS
argument_list|(
name|ADD_DP
argument_list|,
literal|0
argument_list|,
name|dst
argument_list|,
name|reg
argument_list|,
name|value
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
name|value
operator|=
name|get_imm
argument_list|(
operator|-
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
condition|)
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|EMIT_DATA_PROCESS_INS
argument_list|(
name|SUB_DP
argument_list|,
literal|0
argument_list|,
name|dst
argument_list|,
name|reg
argument_list|,
name|value
argument_list|)
argument_list|)
return|;
block|}
return|return
name|SLJIT_ERR_UNSUPPORTED
return|;
block|}
end_function
begin_comment
comment|/* Can perform an operation using at most 1 instruction. */
end_comment
begin_function
DECL|function|getput_arg_fast
specifier|static
name|sljit_si
name|getput_arg_fast
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|inp_flags
parameter_list|,
name|sljit_si
name|reg
parameter_list|,
name|sljit_si
name|arg
parameter_list|,
name|sljit_sw
name|argw
parameter_list|)
block|{
name|sljit_uw
name|imm
decl_stmt|;
if|if
condition|(
name|arg
operator|&
name|SLJIT_IMM
condition|)
block|{
name|imm
operator|=
name|get_imm
argument_list|(
name|argw
argument_list|)
expr_stmt|;
if|if
condition|(
name|imm
condition|)
block|{
if|if
condition|(
name|inp_flags
operator|&
name|ARG_TEST
condition|)
return|return
literal|1
return|;
name|EMIT_INSTRUCTION
argument_list|(
name|EMIT_DATA_PROCESS_INS
argument_list|(
name|MOV_DP
argument_list|,
literal|0
argument_list|,
name|reg
argument_list|,
name|SLJIT_UNUSED
argument_list|,
name|imm
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|imm
operator|=
name|get_imm
argument_list|(
operator|~
name|argw
argument_list|)
expr_stmt|;
if|if
condition|(
name|imm
condition|)
block|{
if|if
condition|(
name|inp_flags
operator|&
name|ARG_TEST
condition|)
return|return
literal|1
return|;
name|EMIT_INSTRUCTION
argument_list|(
name|EMIT_DATA_PROCESS_INS
argument_list|(
name|MVN_DP
argument_list|,
literal|0
argument_list|,
name|reg
argument_list|,
name|SLJIT_UNUSED
argument_list|,
name|imm
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
operator|(
name|inp_flags
operator|&
name|ARG_TEST
operator|)
condition|?
name|SLJIT_SUCCESS
else|:
literal|0
return|;
block|}
name|SLJIT_ASSERT
argument_list|(
name|arg
operator|&
name|SLJIT_MEM
argument_list|)
expr_stmt|;
comment|/* Fast loads/stores. */
if|if
condition|(
name|arg
operator|&
literal|0xf
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|arg
operator|&
literal|0xf0
operator|)
condition|)
block|{
if|if
condition|(
name|IS_TYPE1_TRANSFER
argument_list|(
name|inp_flags
argument_list|)
condition|)
block|{
if|if
condition|(
name|argw
operator|>=
literal|0
operator|&&
name|argw
operator|<=
literal|0xfff
condition|)
block|{
if|if
condition|(
name|inp_flags
operator|&
name|ARG_TEST
condition|)
return|return
literal|1
return|;
name|EMIT_INSTRUCTION
argument_list|(
name|EMIT_DATA_TRANSFER
argument_list|(
name|inp_flags
argument_list|,
literal|1
argument_list|,
name|inp_flags
operator|&
name|WRITE_BACK
argument_list|,
name|reg
argument_list|,
name|arg
operator|&
literal|0xf
argument_list|,
name|argw
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|argw
operator|<
literal|0
operator|&&
name|argw
operator|>=
operator|-
literal|0xfff
condition|)
block|{
if|if
condition|(
name|inp_flags
operator|&
name|ARG_TEST
condition|)
return|return
literal|1
return|;
name|EMIT_INSTRUCTION
argument_list|(
name|EMIT_DATA_TRANSFER
argument_list|(
name|inp_flags
argument_list|,
literal|0
argument_list|,
name|inp_flags
operator|&
name|WRITE_BACK
argument_list|,
name|reg
argument_list|,
name|arg
operator|&
literal|0xf
argument_list|,
operator|-
name|argw
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|argw
operator|>=
literal|0
operator|&&
name|argw
operator|<=
literal|0xff
condition|)
block|{
if|if
condition|(
name|inp_flags
operator|&
name|ARG_TEST
condition|)
return|return
literal|1
return|;
name|EMIT_INSTRUCTION
argument_list|(
name|EMIT_DATA_TRANSFER
argument_list|(
name|inp_flags
argument_list|,
literal|1
argument_list|,
name|inp_flags
operator|&
name|WRITE_BACK
argument_list|,
name|reg
argument_list|,
name|arg
operator|&
literal|0xf
argument_list|,
name|TYPE2_TRANSFER_IMM
argument_list|(
name|argw
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|argw
operator|<
literal|0
operator|&&
name|argw
operator|>=
operator|-
literal|0xff
condition|)
block|{
if|if
condition|(
name|inp_flags
operator|&
name|ARG_TEST
condition|)
return|return
literal|1
return|;
name|argw
operator|=
operator|-
name|argw
expr_stmt|;
name|EMIT_INSTRUCTION
argument_list|(
name|EMIT_DATA_TRANSFER
argument_list|(
name|inp_flags
argument_list|,
literal|0
argument_list|,
name|inp_flags
operator|&
name|WRITE_BACK
argument_list|,
name|reg
argument_list|,
name|arg
operator|&
literal|0xf
argument_list|,
name|TYPE2_TRANSFER_IMM
argument_list|(
name|argw
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|argw
operator|&
literal|0x3
operator|)
operator|==
literal|0
operator|||
name|IS_TYPE1_TRANSFER
argument_list|(
name|inp_flags
argument_list|)
condition|)
block|{
if|if
condition|(
name|inp_flags
operator|&
name|ARG_TEST
condition|)
return|return
literal|1
return|;
name|EMIT_INSTRUCTION
argument_list|(
name|EMIT_DATA_TRANSFER
argument_list|(
name|inp_flags
argument_list|,
literal|1
argument_list|,
name|inp_flags
operator|&
name|WRITE_BACK
argument_list|,
name|reg
argument_list|,
name|arg
operator|&
literal|0xf
argument_list|,
name|RM
argument_list|(
operator|(
name|arg
operator|>>
literal|4
operator|)
operator|&
literal|0xf
argument_list|)
operator||
operator|(
name|IS_TYPE1_TRANSFER
argument_list|(
name|inp_flags
argument_list|)
condition|?
name|SRC2_IMM
else|:
literal|0
operator|)
operator||
operator|(
operator|(
name|argw
operator|&
literal|0x3
operator|)
operator|<<
literal|7
operator|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
return|return
operator|(
name|inp_flags
operator|&
name|ARG_TEST
operator|)
condition|?
name|SLJIT_SUCCESS
else|:
literal|0
return|;
block|}
end_function
begin_comment
comment|/* See getput_arg below.    Note: can_cache is called only for binary operators. Those    operators always uses word arguments without write back. */
end_comment
begin_function
DECL|function|can_cache
specifier|static
name|sljit_si
name|can_cache
parameter_list|(
name|sljit_si
name|arg
parameter_list|,
name|sljit_sw
name|argw
parameter_list|,
name|sljit_si
name|next_arg
parameter_list|,
name|sljit_sw
name|next_argw
parameter_list|)
block|{
comment|/* Immediate caching is not supported as it would be an operation on constant arguments. */
if|if
condition|(
name|arg
operator|&
name|SLJIT_IMM
condition|)
return|return
literal|0
return|;
comment|/* Always a simple operation. */
if|if
condition|(
name|arg
operator|&
literal|0xf0
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
operator|(
name|arg
operator|&
literal|0xf
operator|)
condition|)
block|{
comment|/* Immediate access. */
if|if
condition|(
operator|(
name|next_arg
operator|&
name|SLJIT_MEM
operator|)
operator|&&
operator|(
operator|(
name|sljit_uw
operator|)
name|argw
operator|-
operator|(
name|sljit_uw
operator|)
name|next_argw
operator|<=
literal|0xfff
operator|||
operator|(
name|sljit_uw
operator|)
name|next_argw
operator|-
operator|(
name|sljit_uw
operator|)
name|argw
operator|<=
literal|0xfff
operator|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|argw
operator|<=
literal|0xfffff
operator|&&
name|argw
operator|>=
operator|-
literal|0xfffff
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|argw
operator|==
name|next_argw
operator|&&
operator|(
name|next_arg
operator|&
name|SLJIT_MEM
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|arg
operator|==
name|next_arg
operator|&&
operator|(
operator|(
name|sljit_uw
operator|)
name|argw
operator|-
operator|(
name|sljit_uw
operator|)
name|next_argw
operator|<=
literal|0xfff
operator|||
operator|(
name|sljit_uw
operator|)
name|next_argw
operator|-
operator|(
name|sljit_uw
operator|)
name|argw
operator|<=
literal|0xfff
operator|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function
begin_define
DECL|macro|GETPUT_ARG_DATA_TRANSFER
define|#
directive|define
name|GETPUT_ARG_DATA_TRANSFER
parameter_list|(
name|add
parameter_list|,
name|wb
parameter_list|,
name|target
parameter_list|,
name|base
parameter_list|,
name|imm
parameter_list|)
define|\
value|if (max_delta& 0xf00) \ 		FAIL_IF(push_inst(compiler, EMIT_DATA_TRANSFER(inp_flags, add, wb, target, base, imm))); \ 	else \ 		FAIL_IF(push_inst(compiler, EMIT_DATA_TRANSFER(inp_flags, add, wb, target, base, TYPE2_TRANSFER_IMM(imm))));
end_define
begin_define
DECL|macro|TEST_WRITE_BACK
define|#
directive|define
name|TEST_WRITE_BACK
parameter_list|()
define|\
value|if (inp_flags& WRITE_BACK) { \ 		tmp_r = arg& 0xf; \ 		if (reg == tmp_r) { \
comment|/* This can only happen for stores */
value|\
comment|/* since ldr reg, [reg, ...]! has no meaning */
value|\ 			SLJIT_ASSERT(!(inp_flags& LOAD_DATA)); \ 			EMIT_INSTRUCTION(EMIT_DATA_PROCESS_INS(MOV_DP, 0, TMP_REG3, SLJIT_UNUSED, RM(reg))); \ 			reg = TMP_REG3; \ 		} \ 	}
end_define
begin_comment
comment|/* Emit the necessary instructions. See can_cache above. */
end_comment
begin_function
DECL|function|getput_arg
specifier|static
name|sljit_si
name|getput_arg
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|inp_flags
parameter_list|,
name|sljit_si
name|reg
parameter_list|,
name|sljit_si
name|arg
parameter_list|,
name|sljit_sw
name|argw
parameter_list|,
name|sljit_si
name|next_arg
parameter_list|,
name|sljit_sw
name|next_argw
parameter_list|)
block|{
name|sljit_si
name|tmp_r
decl_stmt|;
name|sljit_sw
name|max_delta
decl_stmt|;
name|sljit_sw
name|sign
decl_stmt|;
name|sljit_uw
name|imm
decl_stmt|;
if|if
condition|(
name|arg
operator|&
name|SLJIT_IMM
condition|)
block|{
name|SLJIT_ASSERT
argument_list|(
name|inp_flags
operator|&
name|LOAD_DATA
argument_list|)
expr_stmt|;
return|return
name|load_immediate
argument_list|(
name|compiler
argument_list|,
name|reg
argument_list|,
name|argw
argument_list|)
return|;
block|}
name|SLJIT_ASSERT
argument_list|(
name|arg
operator|&
name|SLJIT_MEM
argument_list|)
expr_stmt|;
name|tmp_r
operator|=
operator|(
name|inp_flags
operator|&
name|LOAD_DATA
operator|)
condition|?
name|reg
else|:
name|TMP_REG3
expr_stmt|;
name|max_delta
operator|=
name|IS_TYPE1_TRANSFER
argument_list|(
name|inp_flags
argument_list|)
condition|?
literal|0xfff
else|:
literal|0xff
expr_stmt|;
if|if
condition|(
operator|(
name|arg
operator|&
literal|0xf
operator|)
operator|==
name|SLJIT_UNUSED
condition|)
block|{
comment|/* Write back is not used. */
name|imm
operator|=
call|(
name|sljit_uw
call|)
argument_list|(
name|argw
operator|-
name|compiler
operator|->
name|cache_argw
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|compiler
operator|->
name|cache_arg
operator|&
name|SLJIT_IMM
operator|)
operator|&&
operator|(
name|imm
operator|<=
operator|(
name|sljit_uw
operator|)
name|max_delta
operator|||
name|imm
operator|>=
operator|(
name|sljit_uw
operator|)
operator|-
name|max_delta
operator|)
condition|)
block|{
if|if
condition|(
name|imm
operator|<=
operator|(
name|sljit_uw
operator|)
name|max_delta
condition|)
block|{
name|sign
operator|=
literal|1
expr_stmt|;
name|argw
operator|=
name|argw
operator|-
name|compiler
operator|->
name|cache_argw
expr_stmt|;
block|}
else|else
block|{
name|sign
operator|=
literal|0
expr_stmt|;
name|argw
operator|=
name|compiler
operator|->
name|cache_argw
operator|-
name|argw
expr_stmt|;
block|}
name|GETPUT_ARG_DATA_TRANSFER
argument_list|(
name|sign
argument_list|,
literal|0
argument_list|,
name|reg
argument_list|,
name|TMP_REG3
argument_list|,
name|argw
argument_list|)
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
comment|/* With write back, we can create some sophisticated loads, but 		   it is hard to decide whether we should convert downward (0s) or upward (1s). */
name|imm
operator|=
call|(
name|sljit_uw
call|)
argument_list|(
name|argw
operator|-
name|next_argw
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|next_arg
operator|&
name|SLJIT_MEM
operator|)
operator|&&
operator|(
name|imm
operator|<=
operator|(
name|sljit_uw
operator|)
name|max_delta
operator|||
name|imm
operator|>=
operator|(
name|sljit_uw
operator|)
operator|-
name|max_delta
operator|)
condition|)
block|{
name|SLJIT_ASSERT
argument_list|(
name|inp_flags
operator|&
name|LOAD_DATA
argument_list|)
expr_stmt|;
name|compiler
operator|->
name|cache_arg
operator|=
name|SLJIT_IMM
expr_stmt|;
name|compiler
operator|->
name|cache_argw
operator|=
name|argw
expr_stmt|;
name|tmp_r
operator|=
name|TMP_REG3
expr_stmt|;
block|}
name|FAIL_IF
argument_list|(
name|load_immediate
argument_list|(
name|compiler
argument_list|,
name|tmp_r
argument_list|,
name|argw
argument_list|)
argument_list|)
expr_stmt|;
name|GETPUT_ARG_DATA_TRANSFER
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
name|reg
argument_list|,
name|tmp_r
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
if|if
condition|(
name|arg
operator|&
literal|0xf0
condition|)
block|{
name|SLJIT_ASSERT
argument_list|(
operator|(
name|argw
operator|&
literal|0x3
operator|)
operator|&&
operator|!
operator|(
name|max_delta
operator|&
literal|0xf00
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp_flags
operator|&
name|WRITE_BACK
condition|)
name|tmp_r
operator|=
name|arg
operator|&
literal|0xf
expr_stmt|;
name|EMIT_INSTRUCTION
argument_list|(
name|EMIT_DATA_PROCESS_INS
argument_list|(
name|ADD_DP
argument_list|,
literal|0
argument_list|,
name|tmp_r
argument_list|,
name|arg
operator|&
literal|0xf
argument_list|,
name|RM
argument_list|(
operator|(
name|arg
operator|>>
literal|4
operator|)
operator|&
literal|0xf
argument_list|)
operator||
operator|(
operator|(
name|argw
operator|&
literal|0x3
operator|)
operator|<<
literal|7
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|EMIT_INSTRUCTION
argument_list|(
name|EMIT_DATA_TRANSFER
argument_list|(
name|inp_flags
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|reg
argument_list|,
name|tmp_r
argument_list|,
name|TYPE2_TRANSFER_IMM
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
name|imm
operator|=
call|(
name|sljit_uw
call|)
argument_list|(
name|argw
operator|-
name|compiler
operator|->
name|cache_argw
argument_list|)
expr_stmt|;
if|if
condition|(
name|compiler
operator|->
name|cache_arg
operator|==
name|arg
operator|&&
name|imm
operator|<=
operator|(
name|sljit_uw
operator|)
name|max_delta
condition|)
block|{
name|SLJIT_ASSERT
argument_list|(
operator|!
operator|(
name|inp_flags
operator|&
name|WRITE_BACK
operator|)
argument_list|)
expr_stmt|;
name|GETPUT_ARG_DATA_TRANSFER
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
name|reg
argument_list|,
name|TMP_REG3
argument_list|,
name|imm
argument_list|)
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
if|if
condition|(
name|compiler
operator|->
name|cache_arg
operator|==
name|arg
operator|&&
name|imm
operator|>=
operator|(
name|sljit_uw
operator|)
operator|-
name|max_delta
condition|)
block|{
name|SLJIT_ASSERT
argument_list|(
operator|!
operator|(
name|inp_flags
operator|&
name|WRITE_BACK
operator|)
argument_list|)
expr_stmt|;
name|imm
operator|=
operator|(
name|sljit_uw
operator|)
operator|-
operator|(
name|sljit_sw
operator|)
name|imm
expr_stmt|;
name|GETPUT_ARG_DATA_TRANSFER
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|reg
argument_list|,
name|TMP_REG3
argument_list|,
name|imm
argument_list|)
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
name|imm
operator|=
name|get_imm
argument_list|(
name|argw
operator|&
operator|~
name|max_delta
argument_list|)
expr_stmt|;
if|if
condition|(
name|imm
condition|)
block|{
name|TEST_WRITE_BACK
argument_list|()
expr_stmt|;
name|EMIT_INSTRUCTION
argument_list|(
name|EMIT_DATA_PROCESS_INS
argument_list|(
name|ADD_DP
argument_list|,
literal|0
argument_list|,
name|tmp_r
argument_list|,
name|arg
operator|&
literal|0xf
argument_list|,
name|imm
argument_list|)
argument_list|)
expr_stmt|;
name|GETPUT_ARG_DATA_TRANSFER
argument_list|(
literal|1
argument_list|,
name|inp_flags
operator|&
name|WRITE_BACK
argument_list|,
name|reg
argument_list|,
name|tmp_r
argument_list|,
name|argw
operator|&
name|max_delta
argument_list|)
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
name|imm
operator|=
name|get_imm
argument_list|(
operator|-
name|argw
operator|&
operator|~
name|max_delta
argument_list|)
expr_stmt|;
if|if
condition|(
name|imm
condition|)
block|{
name|argw
operator|=
operator|-
name|argw
expr_stmt|;
name|TEST_WRITE_BACK
argument_list|()
expr_stmt|;
name|EMIT_INSTRUCTION
argument_list|(
name|EMIT_DATA_PROCESS_INS
argument_list|(
name|SUB_DP
argument_list|,
literal|0
argument_list|,
name|tmp_r
argument_list|,
name|arg
operator|&
literal|0xf
argument_list|,
name|imm
argument_list|)
argument_list|)
expr_stmt|;
name|GETPUT_ARG_DATA_TRANSFER
argument_list|(
literal|0
argument_list|,
name|inp_flags
operator|&
name|WRITE_BACK
argument_list|,
name|reg
argument_list|,
name|tmp_r
argument_list|,
name|argw
operator|&
name|max_delta
argument_list|)
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
if|if
condition|(
operator|(
name|compiler
operator|->
name|cache_arg
operator|&
name|SLJIT_IMM
operator|)
operator|&&
name|compiler
operator|->
name|cache_argw
operator|==
name|argw
condition|)
block|{
name|TEST_WRITE_BACK
argument_list|()
expr_stmt|;
name|EMIT_INSTRUCTION
argument_list|(
name|EMIT_DATA_TRANSFER
argument_list|(
name|inp_flags
argument_list|,
literal|1
argument_list|,
name|inp_flags
operator|&
name|WRITE_BACK
argument_list|,
name|reg
argument_list|,
name|arg
operator|&
literal|0xf
argument_list|,
name|RM
argument_list|(
name|TMP_REG3
argument_list|)
operator||
operator|(
name|max_delta
operator|&
literal|0xf00
condition|?
name|SRC2_IMM
else|:
literal|0
operator|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
if|if
condition|(
name|argw
operator|==
name|next_argw
operator|&&
operator|(
name|next_arg
operator|&
name|SLJIT_MEM
operator|)
condition|)
block|{
name|SLJIT_ASSERT
argument_list|(
name|inp_flags
operator|&
name|LOAD_DATA
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|load_immediate
argument_list|(
name|compiler
argument_list|,
name|TMP_REG3
argument_list|,
name|argw
argument_list|)
argument_list|)
expr_stmt|;
name|compiler
operator|->
name|cache_arg
operator|=
name|SLJIT_IMM
expr_stmt|;
name|compiler
operator|->
name|cache_argw
operator|=
name|argw
expr_stmt|;
name|TEST_WRITE_BACK
argument_list|()
expr_stmt|;
name|EMIT_INSTRUCTION
argument_list|(
name|EMIT_DATA_TRANSFER
argument_list|(
name|inp_flags
argument_list|,
literal|1
argument_list|,
name|inp_flags
operator|&
name|WRITE_BACK
argument_list|,
name|reg
argument_list|,
name|arg
operator|&
literal|0xf
argument_list|,
name|RM
argument_list|(
name|TMP_REG3
argument_list|)
operator||
operator|(
name|max_delta
operator|&
literal|0xf00
condition|?
name|SRC2_IMM
else|:
literal|0
operator|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
name|imm
operator|=
call|(
name|sljit_uw
call|)
argument_list|(
name|argw
operator|-
name|next_argw
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|==
name|next_arg
operator|&&
operator|!
operator|(
name|inp_flags
operator|&
name|WRITE_BACK
operator|)
operator|&&
operator|(
name|imm
operator|<=
operator|(
name|sljit_uw
operator|)
name|max_delta
operator|||
name|imm
operator|>=
operator|(
name|sljit_uw
operator|)
operator|-
name|max_delta
operator|)
condition|)
block|{
name|SLJIT_ASSERT
argument_list|(
name|inp_flags
operator|&
name|LOAD_DATA
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|load_immediate
argument_list|(
name|compiler
argument_list|,
name|TMP_REG3
argument_list|,
name|argw
argument_list|)
argument_list|)
expr_stmt|;
name|EMIT_INSTRUCTION
argument_list|(
name|EMIT_DATA_PROCESS_INS
argument_list|(
name|ADD_DP
argument_list|,
literal|0
argument_list|,
name|TMP_REG3
argument_list|,
name|TMP_REG3
argument_list|,
name|reg_map
index|[
name|arg
operator|&
literal|0xf
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|compiler
operator|->
name|cache_arg
operator|=
name|arg
expr_stmt|;
name|compiler
operator|->
name|cache_argw
operator|=
name|argw
expr_stmt|;
name|GETPUT_ARG_DATA_TRANSFER
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
name|reg
argument_list|,
name|TMP_REG3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
if|if
condition|(
operator|(
name|arg
operator|&
literal|0xf
operator|)
operator|==
name|tmp_r
condition|)
block|{
name|compiler
operator|->
name|cache_arg
operator|=
name|SLJIT_IMM
expr_stmt|;
name|compiler
operator|->
name|cache_argw
operator|=
name|argw
expr_stmt|;
name|tmp_r
operator|=
name|TMP_REG3
expr_stmt|;
block|}
name|FAIL_IF
argument_list|(
name|load_immediate
argument_list|(
name|compiler
argument_list|,
name|tmp_r
argument_list|,
name|argw
argument_list|)
argument_list|)
expr_stmt|;
name|EMIT_INSTRUCTION
argument_list|(
name|EMIT_DATA_TRANSFER
argument_list|(
name|inp_flags
argument_list|,
literal|1
argument_list|,
name|inp_flags
operator|&
name|WRITE_BACK
argument_list|,
name|reg
argument_list|,
name|arg
operator|&
literal|0xf
argument_list|,
name|reg_map
index|[
name|tmp_r
index|]
operator||
operator|(
name|max_delta
operator|&
literal|0xf00
condition|?
name|SRC2_IMM
else|:
literal|0
operator|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_function
DECL|function|emit_op_mem
specifier|static
name|SLJIT_INLINE
name|sljit_si
name|emit_op_mem
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|flags
parameter_list|,
name|sljit_si
name|reg
parameter_list|,
name|sljit_si
name|arg
parameter_list|,
name|sljit_sw
name|argw
parameter_list|)
block|{
if|if
condition|(
name|getput_arg_fast
argument_list|(
name|compiler
argument_list|,
name|flags
argument_list|,
name|reg
argument_list|,
name|arg
argument_list|,
name|argw
argument_list|)
condition|)
return|return
name|compiler
operator|->
name|error
return|;
name|compiler
operator|->
name|cache_arg
operator|=
literal|0
expr_stmt|;
name|compiler
operator|->
name|cache_argw
operator|=
literal|0
expr_stmt|;
return|return
name|getput_arg
argument_list|(
name|compiler
argument_list|,
name|flags
argument_list|,
name|reg
argument_list|,
name|arg
argument_list|,
name|argw
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|emit_op_mem2
specifier|static
name|SLJIT_INLINE
name|sljit_si
name|emit_op_mem2
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|flags
parameter_list|,
name|sljit_si
name|reg
parameter_list|,
name|sljit_si
name|arg1
parameter_list|,
name|sljit_sw
name|arg1w
parameter_list|,
name|sljit_si
name|arg2
parameter_list|,
name|sljit_sw
name|arg2w
parameter_list|)
block|{
if|if
condition|(
name|getput_arg_fast
argument_list|(
name|compiler
argument_list|,
name|flags
argument_list|,
name|reg
argument_list|,
name|arg1
argument_list|,
name|arg1w
argument_list|)
condition|)
return|return
name|compiler
operator|->
name|error
return|;
return|return
name|getput_arg
argument_list|(
name|compiler
argument_list|,
name|flags
argument_list|,
name|reg
argument_list|,
name|arg1
argument_list|,
name|arg1w
argument_list|,
name|arg2
argument_list|,
name|arg2w
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|emit_op
specifier|static
name|sljit_si
name|emit_op
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|inp_flags
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src1
parameter_list|,
name|sljit_sw
name|src1w
parameter_list|,
name|sljit_si
name|src2
parameter_list|,
name|sljit_sw
name|src2w
parameter_list|)
block|{
comment|/* arg1 goes to TMP_REG1 or src reg 	   arg2 goes to TMP_REG2, imm or src reg 	   TMP_REG3 can be used for caching 	   result goes to TMP_REG2, so put result can use TMP_REG1 and TMP_REG3. */
comment|/* We prefers register and simple consts. */
name|sljit_si
name|dst_r
decl_stmt|;
name|sljit_si
name|src1_r
decl_stmt|;
name|sljit_si
name|src2_r
init|=
literal|0
decl_stmt|;
name|sljit_si
name|sugg_src2_r
init|=
name|TMP_REG2
decl_stmt|;
name|sljit_si
name|flags
init|=
name|GET_FLAGS
argument_list|(
name|op
argument_list|)
condition|?
name|SET_FLAGS
else|:
literal|0
decl_stmt|;
name|compiler
operator|->
name|cache_arg
operator|=
literal|0
expr_stmt|;
name|compiler
operator|->
name|cache_argw
operator|=
literal|0
expr_stmt|;
comment|/* Destination check. */
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|dst
operator|==
name|SLJIT_UNUSED
argument_list|)
condition|)
block|{
if|if
condition|(
name|op
operator|>=
name|SLJIT_MOV
operator|&&
name|op
operator|<=
name|SLJIT_MOVU_SI
operator|&&
operator|!
operator|(
name|src2
operator|&
name|SLJIT_MEM
operator|)
condition|)
return|return
name|SLJIT_SUCCESS
return|;
name|dst_r
operator|=
name|TMP_REG2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dst
operator|<=
name|TMP_REG3
condition|)
block|{
name|dst_r
operator|=
name|dst
expr_stmt|;
name|flags
operator||=
name|REG_DEST
expr_stmt|;
if|if
condition|(
name|op
operator|>=
name|SLJIT_MOV
operator|&&
name|op
operator|<=
name|SLJIT_MOVU_SI
condition|)
name|sugg_src2_r
operator|=
name|dst_r
expr_stmt|;
block|}
else|else
block|{
name|SLJIT_ASSERT
argument_list|(
name|dst
operator|&
name|SLJIT_MEM
argument_list|)
expr_stmt|;
if|if
condition|(
name|getput_arg_fast
argument_list|(
name|compiler
argument_list|,
name|inp_flags
operator||
name|ARG_TEST
argument_list|,
name|TMP_REG2
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
condition|)
block|{
name|flags
operator||=
name|FAST_DEST
expr_stmt|;
name|dst_r
operator|=
name|TMP_REG2
expr_stmt|;
block|}
else|else
block|{
name|flags
operator||=
name|SLOW_DEST
expr_stmt|;
name|dst_r
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Source 1. */
if|if
condition|(
name|src1
operator|<=
name|TMP_REG3
condition|)
name|src1_r
operator|=
name|src1
expr_stmt|;
elseif|else
if|if
condition|(
name|src2
operator|<=
name|TMP_REG3
condition|)
block|{
name|flags
operator||=
name|ARGS_SWAPPED
expr_stmt|;
name|src1_r
operator|=
name|src2
expr_stmt|;
name|src2
operator|=
name|src1
expr_stmt|;
name|src2w
operator|=
name|src1w
expr_stmt|;
block|}
else|else
do|do
block|{
comment|/* do { } while(0) is used because of breaks. */
name|src1_r
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|inp_flags
operator|&
name|ALLOW_ANY_IMM
operator|)
operator|&&
operator|(
name|src1
operator|&
name|SLJIT_IMM
operator|)
condition|)
block|{
comment|/* The second check will generate a hit. */
name|src2_r
operator|=
name|get_imm
argument_list|(
name|src1w
argument_list|)
expr_stmt|;
if|if
condition|(
name|src2_r
condition|)
block|{
name|flags
operator||=
name|ARGS_SWAPPED
expr_stmt|;
name|src1
operator|=
name|src2
expr_stmt|;
name|src1w
operator|=
name|src2w
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|inp_flags
operator|&
name|ALLOW_INV_IMM
condition|)
block|{
name|src2_r
operator|=
name|get_imm
argument_list|(
operator|~
name|src1w
argument_list|)
expr_stmt|;
if|if
condition|(
name|src2_r
condition|)
block|{
name|flags
operator||=
name|ARGS_SWAPPED
operator||
name|INV_IMM
expr_stmt|;
name|src1
operator|=
name|src2
expr_stmt|;
name|src1w
operator|=
name|src2w
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
operator|==
name|SLJIT_ADD
condition|)
block|{
name|src2_r
operator|=
name|get_imm
argument_list|(
operator|-
name|src1w
argument_list|)
expr_stmt|;
if|if
condition|(
name|src2_r
condition|)
block|{
comment|/* Note: ARGS_SWAPPED is intentionally not applied! */
name|src1
operator|=
name|src2
expr_stmt|;
name|src1w
operator|=
name|src2w
expr_stmt|;
name|op
operator|=
name|SLJIT_SUB
operator||
name|GET_ALL_FLAGS
argument_list|(
name|op
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|getput_arg_fast
argument_list|(
name|compiler
argument_list|,
name|inp_flags
operator||
name|LOAD_DATA
argument_list|,
name|TMP_REG1
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
condition|)
block|{
name|FAIL_IF
argument_list|(
name|compiler
operator|->
name|error
argument_list|)
expr_stmt|;
name|src1_r
operator|=
name|TMP_REG1
expr_stmt|;
block|}
block|}
do|while
condition|(
literal|0
condition|)
do|;
comment|/* Source 2. */
if|if
condition|(
name|src2_r
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|src2
operator|<=
name|TMP_REG3
condition|)
block|{
name|src2_r
operator|=
name|src2
expr_stmt|;
name|flags
operator||=
name|REG_SOURCE
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|REG_DEST
operator|)
operator|&&
name|op
operator|>=
name|SLJIT_MOV
operator|&&
name|op
operator|<=
name|SLJIT_MOVU_SI
condition|)
name|dst_r
operator|=
name|src2_r
expr_stmt|;
block|}
else|else
do|do
block|{
comment|/* do { } while(0) is used because of breaks. */
if|if
condition|(
operator|(
name|inp_flags
operator|&
name|ALLOW_ANY_IMM
operator|)
operator|&&
operator|(
name|src2
operator|&
name|SLJIT_IMM
operator|)
condition|)
block|{
name|src2_r
operator|=
name|get_imm
argument_list|(
name|src2w
argument_list|)
expr_stmt|;
if|if
condition|(
name|src2_r
condition|)
break|break;
if|if
condition|(
name|inp_flags
operator|&
name|ALLOW_INV_IMM
condition|)
block|{
name|src2_r
operator|=
name|get_imm
argument_list|(
operator|~
name|src2w
argument_list|)
expr_stmt|;
if|if
condition|(
name|src2_r
condition|)
block|{
name|flags
operator||=
name|INV_IMM
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
operator|==
name|SLJIT_ADD
condition|)
block|{
name|src2_r
operator|=
name|get_imm
argument_list|(
operator|-
name|src2w
argument_list|)
expr_stmt|;
if|if
condition|(
name|src2_r
condition|)
block|{
name|op
operator|=
name|SLJIT_SUB
operator||
name|GET_ALL_FLAGS
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|flags
operator|&=
operator|~
name|ARGS_SWAPPED
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
operator|==
name|SLJIT_SUB
operator|&&
operator|!
operator|(
name|flags
operator|&
name|ARGS_SWAPPED
operator|)
condition|)
block|{
name|src2_r
operator|=
name|get_imm
argument_list|(
operator|-
name|src2w
argument_list|)
expr_stmt|;
if|if
condition|(
name|src2_r
condition|)
block|{
name|op
operator|=
name|SLJIT_ADD
operator||
name|GET_ALL_FLAGS
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|flags
operator|&=
operator|~
name|ARGS_SWAPPED
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* src2_r is 0. */
if|if
condition|(
name|getput_arg_fast
argument_list|(
name|compiler
argument_list|,
name|inp_flags
operator||
name|LOAD_DATA
argument_list|,
name|sugg_src2_r
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
condition|)
block|{
name|FAIL_IF
argument_list|(
name|compiler
operator|->
name|error
argument_list|)
expr_stmt|;
name|src2_r
operator|=
name|sugg_src2_r
expr_stmt|;
block|}
block|}
do|while
condition|(
literal|0
condition|)
do|;
block|}
comment|/* src1_r, src2_r and dst_r can be zero (=unprocessed) or non-zero. 	   If they are zero, they must not be registers. */
if|if
condition|(
name|src1_r
operator|==
literal|0
operator|&&
name|src2_r
operator|==
literal|0
operator|&&
name|dst_r
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|can_cache
argument_list|(
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
operator|&&
name|can_cache
argument_list|(
name|src1
argument_list|,
name|src1w
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
condition|)
block|{
name|SLJIT_ASSERT
argument_list|(
operator|!
operator|(
name|flags
operator|&
name|ARGS_SWAPPED
operator|)
argument_list|)
expr_stmt|;
name|flags
operator||=
name|ARGS_SWAPPED
expr_stmt|;
name|FAIL_IF
argument_list|(
name|getput_arg
argument_list|(
name|compiler
argument_list|,
name|inp_flags
operator||
name|LOAD_DATA
argument_list|,
name|TMP_REG1
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|getput_arg
argument_list|(
name|compiler
argument_list|,
name|inp_flags
operator||
name|LOAD_DATA
argument_list|,
name|TMP_REG2
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|FAIL_IF
argument_list|(
name|getput_arg
argument_list|(
name|compiler
argument_list|,
name|inp_flags
operator||
name|LOAD_DATA
argument_list|,
name|TMP_REG1
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|getput_arg
argument_list|(
name|compiler
argument_list|,
name|inp_flags
operator||
name|LOAD_DATA
argument_list|,
name|TMP_REG2
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|src1_r
operator|=
name|TMP_REG1
expr_stmt|;
name|src2_r
operator|=
name|TMP_REG2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|src1_r
operator|==
literal|0
operator|&&
name|src2_r
operator|==
literal|0
condition|)
block|{
name|FAIL_IF
argument_list|(
name|getput_arg
argument_list|(
name|compiler
argument_list|,
name|inp_flags
operator||
name|LOAD_DATA
argument_list|,
name|TMP_REG1
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
argument_list|)
expr_stmt|;
name|src1_r
operator|=
name|TMP_REG1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|src1_r
operator|==
literal|0
operator|&&
name|dst_r
operator|==
literal|0
condition|)
block|{
name|FAIL_IF
argument_list|(
name|getput_arg
argument_list|(
name|compiler
argument_list|,
name|inp_flags
operator||
name|LOAD_DATA
argument_list|,
name|TMP_REG1
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
argument_list|)
expr_stmt|;
name|src1_r
operator|=
name|TMP_REG1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|src2_r
operator|==
literal|0
operator|&&
name|dst_r
operator|==
literal|0
condition|)
block|{
name|FAIL_IF
argument_list|(
name|getput_arg
argument_list|(
name|compiler
argument_list|,
name|inp_flags
operator||
name|LOAD_DATA
argument_list|,
name|sugg_src2_r
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
argument_list|)
expr_stmt|;
name|src2_r
operator|=
name|sugg_src2_r
expr_stmt|;
block|}
if|if
condition|(
name|dst_r
operator|==
literal|0
condition|)
name|dst_r
operator|=
name|TMP_REG2
expr_stmt|;
if|if
condition|(
name|src1_r
operator|==
literal|0
condition|)
block|{
name|FAIL_IF
argument_list|(
name|getput_arg
argument_list|(
name|compiler
argument_list|,
name|inp_flags
operator||
name|LOAD_DATA
argument_list|,
name|TMP_REG1
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|src1_r
operator|=
name|TMP_REG1
expr_stmt|;
block|}
if|if
condition|(
name|src2_r
operator|==
literal|0
condition|)
block|{
name|FAIL_IF
argument_list|(
name|getput_arg
argument_list|(
name|compiler
argument_list|,
name|inp_flags
operator||
name|LOAD_DATA
argument_list|,
name|sugg_src2_r
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|src2_r
operator|=
name|sugg_src2_r
expr_stmt|;
block|}
name|FAIL_IF
argument_list|(
name|emit_single_op
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|flags
argument_list|,
name|dst_r
argument_list|,
name|src1_r
argument_list|,
name|src2_r
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
operator|(
name|FAST_DEST
operator||
name|SLOW_DEST
operator|)
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|FAST_DEST
condition|)
name|FAIL_IF
argument_list|(
name|getput_arg_fast
argument_list|(
name|compiler
argument_list|,
name|inp_flags
argument_list|,
name|dst_r
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|FAIL_IF
argument_list|(
name|getput_arg
argument_list|(
name|compiler
argument_list|,
name|inp_flags
argument_list|,
name|dst_r
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef
begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
specifier|extern
name|unsigned
name|int
name|__aeabi_uidivmod
parameter_list|(
name|unsigned
name|int
name|numerator
parameter_list|,
name|unsigned
name|int
name|denominator
parameter_list|)
function_decl|;
specifier|extern
name|int
name|__aeabi_idivmod
parameter_list|(
name|int
name|numerator
parameter_list|,
name|int
name|denominator
parameter_list|)
function_decl|;
else|#
directive|else
error|#
directive|error
literal|"Software divmod functions are needed"
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|sljit_emit_op0
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_op0
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|)
block|{
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|check_sljit_emit_op0
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|op
operator|=
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|SLJIT_BREAKPOINT
case|:
name|EMIT_INSTRUCTION
argument_list|(
name|BKPT
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_NOP
case|:
name|EMIT_INSTRUCTION
argument_list|(
name|NOP
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_UMUL
case|:
case|case
name|SLJIT_SMUL
case|:
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_ARM_V7
operator|&&
name|SLJIT_CONFIG_ARM_V7
operator|)
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
operator|(
name|op
operator|==
name|SLJIT_UMUL
condition|?
name|UMULL
else|:
name|SMULL
operator|)
operator||
operator|(
name|reg_map
index|[
name|SLJIT_SCRATCH_REG2
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|reg_map
index|[
name|SLJIT_SCRATCH_REG1
index|]
operator|<<
literal|12
operator|)
operator||
operator|(
name|reg_map
index|[
name|SLJIT_SCRATCH_REG1
index|]
operator|<<
literal|8
operator|)
operator||
name|reg_map
index|[
name|SLJIT_SCRATCH_REG2
index|]
argument_list|)
return|;
else|#
directive|else
name|EMIT_INSTRUCTION
argument_list|(
name|EMIT_DATA_PROCESS_INS
argument_list|(
name|MOV_DP
argument_list|,
literal|0
argument_list|,
name|TMP_REG1
argument_list|,
name|SLJIT_UNUSED
argument_list|,
name|RM
argument_list|(
name|SLJIT_SCRATCH_REG2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
operator|(
name|op
operator|==
name|SLJIT_UMUL
condition|?
name|UMULL
else|:
name|SMULL
operator|)
operator||
operator|(
name|reg_map
index|[
name|SLJIT_SCRATCH_REG2
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|reg_map
index|[
name|SLJIT_SCRATCH_REG1
index|]
operator|<<
literal|12
operator|)
operator||
operator|(
name|reg_map
index|[
name|SLJIT_SCRATCH_REG1
index|]
operator|<<
literal|8
operator|)
operator||
name|reg_map
index|[
name|TMP_REG1
index|]
argument_list|)
return|;
endif|#
directive|endif
case|case
name|SLJIT_UDIV
case|:
case|case
name|SLJIT_SDIV
case|:
if|if
condition|(
name|compiler
operator|->
name|scratches
operator|>=
literal|3
condition|)
name|EMIT_INSTRUCTION
argument_list|(
literal|0xe52d2008
comment|/* str r2, [sp, #-8]! */
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
name|FAIL_IF
argument_list|(
name|sljit_emit_ijump
argument_list|(
name|compiler
argument_list|,
name|SLJIT_FAST_CALL
argument_list|,
name|SLJIT_IMM
argument_list|,
operator|(
name|op
operator|==
name|SLJIT_UDIV
condition|?
name|SLJIT_FUNC_OFFSET
argument_list|(
name|__aeabi_uidivmod
argument_list|)
else|:
name|SLJIT_FUNC_OFFSET
argument_list|(
name|__aeabi_idivmod
argument_list|)
operator|)
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
error|#
directive|error
literal|"Software divmod functions are needed"
endif|#
directive|endif
if|if
condition|(
name|compiler
operator|->
name|scratches
operator|>=
literal|3
condition|)
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
literal|0xe49d2008
comment|/* ldr r2, [sp], #8 */
argument_list|)
return|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_op1
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_op1
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|)
block|{
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|check_sljit_emit_op1
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|ADJUST_LOCAL_OFFSET
argument_list|(
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|ADJUST_LOCAL_OFFSET
argument_list|(
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|SLJIT_MOV
case|:
case|case
name|SLJIT_MOV_UI
case|:
case|case
name|SLJIT_MOV_SI
case|:
case|case
name|SLJIT_MOV_P
case|:
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MOV
argument_list|,
name|ALLOW_ANY_IMM
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REG1
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
return|;
case|case
name|SLJIT_MOV_UB
case|:
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MOV_UB
argument_list|,
name|ALLOW_ANY_IMM
operator||
name|BYTE_DATA
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REG1
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
operator|(
name|src
operator|&
name|SLJIT_IMM
operator|)
condition|?
operator|(
name|sljit_ub
operator|)
name|srcw
else|:
name|srcw
argument_list|)
return|;
case|case
name|SLJIT_MOV_SB
case|:
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MOV_SB
argument_list|,
name|ALLOW_ANY_IMM
operator||
name|SIGNED_DATA
operator||
name|BYTE_DATA
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REG1
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
operator|(
name|src
operator|&
name|SLJIT_IMM
operator|)
condition|?
operator|(
name|sljit_sb
operator|)
name|srcw
else|:
name|srcw
argument_list|)
return|;
case|case
name|SLJIT_MOV_UH
case|:
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MOV_UH
argument_list|,
name|ALLOW_ANY_IMM
operator||
name|HALF_DATA
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REG1
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
operator|(
name|src
operator|&
name|SLJIT_IMM
operator|)
condition|?
operator|(
name|sljit_uh
operator|)
name|srcw
else|:
name|srcw
argument_list|)
return|;
case|case
name|SLJIT_MOV_SH
case|:
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MOV_SH
argument_list|,
name|ALLOW_ANY_IMM
operator||
name|SIGNED_DATA
operator||
name|HALF_DATA
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REG1
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
operator|(
name|src
operator|&
name|SLJIT_IMM
operator|)
condition|?
operator|(
name|sljit_sh
operator|)
name|srcw
else|:
name|srcw
argument_list|)
return|;
case|case
name|SLJIT_MOVU
case|:
case|case
name|SLJIT_MOVU_UI
case|:
case|case
name|SLJIT_MOVU_SI
case|:
case|case
name|SLJIT_MOVU_P
case|:
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MOV
argument_list|,
name|ALLOW_ANY_IMM
operator||
name|WRITE_BACK
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REG1
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
return|;
case|case
name|SLJIT_MOVU_UB
case|:
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MOV_UB
argument_list|,
name|ALLOW_ANY_IMM
operator||
name|BYTE_DATA
operator||
name|WRITE_BACK
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REG1
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
operator|(
name|src
operator|&
name|SLJIT_IMM
operator|)
condition|?
operator|(
name|sljit_ub
operator|)
name|srcw
else|:
name|srcw
argument_list|)
return|;
case|case
name|SLJIT_MOVU_SB
case|:
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MOV_SB
argument_list|,
name|ALLOW_ANY_IMM
operator||
name|SIGNED_DATA
operator||
name|BYTE_DATA
operator||
name|WRITE_BACK
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REG1
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
operator|(
name|src
operator|&
name|SLJIT_IMM
operator|)
condition|?
operator|(
name|sljit_sb
operator|)
name|srcw
else|:
name|srcw
argument_list|)
return|;
case|case
name|SLJIT_MOVU_UH
case|:
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MOV_UH
argument_list|,
name|ALLOW_ANY_IMM
operator||
name|HALF_DATA
operator||
name|WRITE_BACK
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REG1
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
operator|(
name|src
operator|&
name|SLJIT_IMM
operator|)
condition|?
operator|(
name|sljit_uh
operator|)
name|srcw
else|:
name|srcw
argument_list|)
return|;
case|case
name|SLJIT_MOVU_SH
case|:
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MOV_SH
argument_list|,
name|ALLOW_ANY_IMM
operator||
name|SIGNED_DATA
operator||
name|HALF_DATA
operator||
name|WRITE_BACK
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REG1
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
operator|(
name|src
operator|&
name|SLJIT_IMM
operator|)
condition|?
operator|(
name|sljit_sh
operator|)
name|srcw
else|:
name|srcw
argument_list|)
return|;
case|case
name|SLJIT_NOT
case|:
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|ALLOW_ANY_IMM
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REG1
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
return|;
case|case
name|SLJIT_NEG
case|:
if|#
directive|if
operator|(
name|defined
name|SLJIT_VERBOSE
operator|&&
name|SLJIT_VERBOSE
operator|)
operator|||
operator|(
name|defined
name|SLJIT_DEBUG
operator|&&
name|SLJIT_DEBUG
operator|)
name|compiler
operator|->
name|skip_checks
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
return|return
name|sljit_emit_op2
argument_list|(
name|compiler
argument_list|,
name|SLJIT_SUB
operator||
name|GET_ALL_FLAGS
argument_list|(
name|op
argument_list|)
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|SLJIT_IMM
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
return|;
case|case
name|SLJIT_CLZ
case|:
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
literal|0
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REG1
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
return|;
block|}
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_op2
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_op2
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src1
parameter_list|,
name|sljit_sw
name|src1w
parameter_list|,
name|sljit_si
name|src2
parameter_list|,
name|sljit_sw
name|src2w
parameter_list|)
block|{
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|check_sljit_emit_op2
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
name|ADJUST_LOCAL_OFFSET
argument_list|(
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|ADJUST_LOCAL_OFFSET
argument_list|(
name|src1
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
name|ADJUST_LOCAL_OFFSET
argument_list|(
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|SLJIT_ADD
case|:
case|case
name|SLJIT_ADDC
case|:
case|case
name|SLJIT_SUB
case|:
case|case
name|SLJIT_SUBC
case|:
case|case
name|SLJIT_OR
case|:
case|case
name|SLJIT_XOR
case|:
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|ALLOW_IMM
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
return|;
case|case
name|SLJIT_MUL
case|:
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
literal|0
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
return|;
case|case
name|SLJIT_AND
case|:
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|ALLOW_ANY_IMM
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
return|;
case|case
name|SLJIT_SHL
case|:
case|case
name|SLJIT_LSHR
case|:
case|case
name|SLJIT_ASHR
case|:
if|if
condition|(
name|src2
operator|&
name|SLJIT_IMM
condition|)
block|{
name|compiler
operator|->
name|shift_imm
operator|=
name|src2w
operator|&
literal|0x1f
expr_stmt|;
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
literal|0
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REG1
argument_list|,
literal|0
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
return|;
block|}
else|else
block|{
name|compiler
operator|->
name|shift_imm
operator|=
literal|0x20
expr_stmt|;
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
literal|0
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
return|;
block|}
block|}
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_function
DECL|function|sljit_get_register_index
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_get_register_index
parameter_list|(
name|sljit_si
name|reg
parameter_list|)
block|{
name|check_sljit_get_register_index
argument_list|(
name|reg
argument_list|)
expr_stmt|;
return|return
name|reg_map
index|[
name|reg
index|]
return|;
block|}
end_function
begin_function
DECL|function|sljit_get_float_register_index
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_get_float_register_index
parameter_list|(
name|sljit_si
name|reg
parameter_list|)
block|{
name|check_sljit_get_float_register_index
argument_list|(
name|reg
argument_list|)
expr_stmt|;
return|return
name|reg
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_op_custom
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_op_custom
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|void
modifier|*
name|instruction
parameter_list|,
name|sljit_si
name|size
parameter_list|)
block|{
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|check_sljit_emit_op_custom
argument_list|(
name|compiler
argument_list|,
name|instruction
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|size
operator|==
literal|4
argument_list|)
expr_stmt|;
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
operator|*
operator|(
name|sljit_uw
operator|*
operator|)
name|instruction
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_comment
comment|/*  Floating point operators                                             */
end_comment
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_ARM_V5
operator|&&
name|SLJIT_CONFIG_ARM_V5
operator|)
end_if
begin_comment
comment|/* 0 - no fpu    1 - vfp */
end_comment
begin_decl_stmt
DECL|variable|arm_fpu_type
specifier|static
name|sljit_si
name|arm_fpu_type
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|init_compiler
specifier|static
name|void
name|init_compiler
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|arm_fpu_type
operator|!=
operator|-
literal|1
condition|)
return|return;
comment|/* TODO: Only the OS can help to determine the correct fpu type. */
name|arm_fpu_type
operator|=
literal|1
expr_stmt|;
block|}
end_function
begin_function
DECL|function|sljit_is_fpu_available
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_is_fpu_available
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|arm_fpu_type
operator|==
operator|-
literal|1
condition|)
name|init_compiler
argument_list|()
expr_stmt|;
return|return
name|arm_fpu_type
return|;
block|}
end_function
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|arm_fpu_type
define|#
directive|define
name|arm_fpu_type
value|1
end_define
begin_function
DECL|function|sljit_is_fpu_available
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_is_fpu_available
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Always available. */
return|return
literal|1
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|FPU_LOAD
define|#
directive|define
name|FPU_LOAD
value|(1<< 20)
end_define
begin_define
DECL|macro|EMIT_FPU_DATA_TRANSFER
define|#
directive|define
name|EMIT_FPU_DATA_TRANSFER
parameter_list|(
name|inst
parameter_list|,
name|add
parameter_list|,
name|base
parameter_list|,
name|freg
parameter_list|,
name|offs
parameter_list|)
define|\
value|((inst) | ((add)<< 23) | (reg_map[base]<< 16) | (freg<< 12) | (offs))
end_define
begin_define
DECL|macro|EMIT_FPU_OPERATION
define|#
directive|define
name|EMIT_FPU_OPERATION
parameter_list|(
name|opcode
parameter_list|,
name|mode
parameter_list|,
name|dst
parameter_list|,
name|src1
parameter_list|,
name|src2
parameter_list|)
define|\
value|((opcode) | (mode) | ((dst)<< 12) | (src1) | ((src2)<< 16))
end_define
begin_function
DECL|function|emit_fop_mem
specifier|static
name|sljit_si
name|emit_fop_mem
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|flags
parameter_list|,
name|sljit_si
name|reg
parameter_list|,
name|sljit_si
name|arg
parameter_list|,
name|sljit_sw
name|argw
parameter_list|)
block|{
name|sljit_sw
name|tmp
decl_stmt|;
name|sljit_uw
name|imm
decl_stmt|;
name|sljit_sw
name|inst
init|=
name|VSTR_F32
operator||
operator|(
name|flags
operator|&
operator|(
name|SLJIT_SINGLE_OP
operator||
name|FPU_LOAD
operator|)
operator|)
decl_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|arg
operator|&
name|SLJIT_MEM
argument_list|)
expr_stmt|;
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|arg
operator|&
literal|0xf0
argument_list|)
condition|)
block|{
name|EMIT_INSTRUCTION
argument_list|(
name|EMIT_DATA_PROCESS_INS
argument_list|(
name|ADD_DP
argument_list|,
literal|0
argument_list|,
name|TMP_REG1
argument_list|,
name|arg
operator|&
literal|0xf
argument_list|,
name|RM
argument_list|(
operator|(
name|arg
operator|>>
literal|4
operator|)
operator|&
literal|0xf
argument_list|)
operator||
operator|(
operator|(
name|argw
operator|&
literal|0x3
operator|)
operator|<<
literal|7
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|arg
operator|=
name|SLJIT_MEM
operator||
name|TMP_REG1
expr_stmt|;
name|argw
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Fast loads and stores. */
if|if
condition|(
operator|(
name|arg
operator|&
literal|0xf
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|argw
operator|&
operator|~
literal|0x3fc
operator|)
condition|)
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|EMIT_FPU_DATA_TRANSFER
argument_list|(
name|inst
argument_list|,
literal|1
argument_list|,
name|arg
operator|&
literal|0xf
argument_list|,
name|reg
argument_list|,
name|argw
operator|>>
literal|2
argument_list|)
argument_list|)
return|;
if|if
condition|(
operator|!
operator|(
operator|-
name|argw
operator|&
operator|~
literal|0x3fc
operator|)
condition|)
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|EMIT_FPU_DATA_TRANSFER
argument_list|(
name|inst
argument_list|,
literal|0
argument_list|,
name|arg
operator|&
literal|0xf
argument_list|,
name|reg
argument_list|,
operator|(
operator|-
name|argw
operator|)
operator|>>
literal|2
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|compiler
operator|->
name|cache_arg
operator|==
name|arg
condition|)
block|{
name|tmp
operator|=
name|argw
operator|-
name|compiler
operator|->
name|cache_argw
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tmp
operator|&
operator|~
literal|0x3fc
operator|)
condition|)
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|EMIT_FPU_DATA_TRANSFER
argument_list|(
name|inst
argument_list|,
literal|1
argument_list|,
name|TMP_REG3
argument_list|,
name|reg
argument_list|,
name|tmp
operator|>>
literal|2
argument_list|)
argument_list|)
return|;
if|if
condition|(
operator|!
operator|(
operator|-
name|tmp
operator|&
operator|~
literal|0x3fc
operator|)
condition|)
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|EMIT_FPU_DATA_TRANSFER
argument_list|(
name|inst
argument_list|,
literal|0
argument_list|,
name|TMP_REG3
argument_list|,
name|reg
argument_list|,
operator|-
name|tmp
operator|>>
literal|2
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|emit_set_delta
argument_list|(
name|compiler
argument_list|,
name|TMP_REG3
argument_list|,
name|TMP_REG3
argument_list|,
name|tmp
argument_list|)
operator|!=
name|SLJIT_ERR_UNSUPPORTED
condition|)
block|{
name|FAIL_IF
argument_list|(
name|compiler
operator|->
name|error
argument_list|)
expr_stmt|;
name|compiler
operator|->
name|cache_argw
operator|=
name|argw
expr_stmt|;
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|EMIT_FPU_DATA_TRANSFER
argument_list|(
name|inst
argument_list|,
literal|1
argument_list|,
name|TMP_REG3
argument_list|,
name|reg
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|arg
operator|&
literal|0xf
condition|)
block|{
if|if
condition|(
name|emit_set_delta
argument_list|(
name|compiler
argument_list|,
name|TMP_REG1
argument_list|,
name|arg
operator|&
literal|0xf
argument_list|,
name|argw
argument_list|)
operator|!=
name|SLJIT_ERR_UNSUPPORTED
condition|)
block|{
name|FAIL_IF
argument_list|(
name|compiler
operator|->
name|error
argument_list|)
expr_stmt|;
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|EMIT_FPU_DATA_TRANSFER
argument_list|(
name|inst
argument_list|,
literal|1
argument_list|,
name|TMP_REG1
argument_list|,
name|reg
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
name|imm
operator|=
name|get_imm
argument_list|(
name|argw
operator|&
operator|~
literal|0x3fc
argument_list|)
expr_stmt|;
if|if
condition|(
name|imm
condition|)
block|{
name|EMIT_INSTRUCTION
argument_list|(
name|EMIT_DATA_PROCESS_INS
argument_list|(
name|ADD_DP
argument_list|,
literal|0
argument_list|,
name|TMP_REG1
argument_list|,
name|arg
operator|&
literal|0xf
argument_list|,
name|imm
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|EMIT_FPU_DATA_TRANSFER
argument_list|(
name|inst
argument_list|,
literal|1
argument_list|,
name|TMP_REG1
argument_list|,
name|reg
argument_list|,
operator|(
name|argw
operator|&
literal|0x3fc
operator|)
operator|>>
literal|2
argument_list|)
argument_list|)
return|;
block|}
name|imm
operator|=
name|get_imm
argument_list|(
operator|-
name|argw
operator|&
operator|~
literal|0x3fc
argument_list|)
expr_stmt|;
if|if
condition|(
name|imm
condition|)
block|{
name|argw
operator|=
operator|-
name|argw
expr_stmt|;
name|EMIT_INSTRUCTION
argument_list|(
name|EMIT_DATA_PROCESS_INS
argument_list|(
name|SUB_DP
argument_list|,
literal|0
argument_list|,
name|TMP_REG1
argument_list|,
name|arg
operator|&
literal|0xf
argument_list|,
name|imm
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|EMIT_FPU_DATA_TRANSFER
argument_list|(
name|inst
argument_list|,
literal|0
argument_list|,
name|TMP_REG1
argument_list|,
name|reg
argument_list|,
operator|(
name|argw
operator|&
literal|0x3fc
operator|)
operator|>>
literal|2
argument_list|)
argument_list|)
return|;
block|}
block|}
name|compiler
operator|->
name|cache_arg
operator|=
name|arg
expr_stmt|;
name|compiler
operator|->
name|cache_argw
operator|=
name|argw
expr_stmt|;
if|if
condition|(
name|arg
operator|&
literal|0xf
condition|)
block|{
name|FAIL_IF
argument_list|(
name|load_immediate
argument_list|(
name|compiler
argument_list|,
name|TMP_REG1
argument_list|,
name|argw
argument_list|)
argument_list|)
expr_stmt|;
name|EMIT_INSTRUCTION
argument_list|(
name|EMIT_DATA_PROCESS_INS
argument_list|(
name|ADD_DP
argument_list|,
literal|0
argument_list|,
name|TMP_REG3
argument_list|,
name|arg
operator|&
literal|0xf
argument_list|,
name|reg_map
index|[
name|TMP_REG1
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|FAIL_IF
argument_list|(
name|load_immediate
argument_list|(
name|compiler
argument_list|,
name|TMP_REG3
argument_list|,
name|argw
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|EMIT_FPU_DATA_TRANSFER
argument_list|(
name|inst
argument_list|,
literal|1
argument_list|,
name|TMP_REG3
argument_list|,
name|reg
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_fop1
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_fop1
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|)
block|{
name|sljit_si
name|dst_fr
decl_stmt|;
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|check_sljit_emit_fop1
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|SLJIT_COMPILE_ASSERT
argument_list|(
operator|(
name|SLJIT_SINGLE_OP
operator|==
literal|0x100
operator|)
argument_list|,
name|float_transfer_bit_error
argument_list|)
expr_stmt|;
name|compiler
operator|->
name|cache_arg
operator|=
literal|0
expr_stmt|;
name|compiler
operator|->
name|cache_argw
operator|=
literal|0
expr_stmt|;
name|op
operator|^=
name|SLJIT_SINGLE_OP
expr_stmt|;
if|if
condition|(
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
operator|==
name|SLJIT_CMPD
condition|)
block|{
if|if
condition|(
name|dst
operator|>
name|SLJIT_FLOAT_REG6
condition|)
block|{
name|FAIL_IF
argument_list|(
name|emit_fop_mem
argument_list|(
name|compiler
argument_list|,
operator|(
name|op
operator|&
name|SLJIT_SINGLE_OP
operator|)
operator||
name|FPU_LOAD
argument_list|,
name|TMP_FREG1
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
argument_list|)
expr_stmt|;
name|dst
operator|=
name|TMP_FREG1
expr_stmt|;
block|}
if|if
condition|(
name|src
operator|>
name|SLJIT_FLOAT_REG6
condition|)
block|{
name|FAIL_IF
argument_list|(
name|emit_fop_mem
argument_list|(
name|compiler
argument_list|,
operator|(
name|op
operator|&
name|SLJIT_SINGLE_OP
operator|)
operator||
name|FPU_LOAD
argument_list|,
name|TMP_FREG2
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
argument_list|)
expr_stmt|;
name|src
operator|=
name|TMP_FREG2
expr_stmt|;
block|}
name|EMIT_INSTRUCTION
argument_list|(
name|EMIT_FPU_OPERATION
argument_list|(
name|VCMP_F32
argument_list|,
name|op
operator|&
name|SLJIT_SINGLE_OP
argument_list|,
name|dst
argument_list|,
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|EMIT_INSTRUCTION
argument_list|(
name|VMRS
argument_list|)
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
name|dst_fr
operator|=
operator|(
name|dst
operator|>
name|SLJIT_FLOAT_REG6
operator|)
condition|?
name|TMP_FREG1
else|:
name|dst
expr_stmt|;
if|if
condition|(
name|src
operator|>
name|SLJIT_FLOAT_REG6
condition|)
block|{
name|FAIL_IF
argument_list|(
name|emit_fop_mem
argument_list|(
name|compiler
argument_list|,
operator|(
name|op
operator|&
name|SLJIT_SINGLE_OP
operator|)
operator||
name|FPU_LOAD
argument_list|,
name|dst_fr
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
argument_list|)
expr_stmt|;
name|src
operator|=
name|dst_fr
expr_stmt|;
block|}
switch|switch
condition|(
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|SLJIT_MOVD
case|:
if|if
condition|(
name|src
operator|!=
name|dst_fr
operator|&&
name|dst_fr
operator|!=
name|TMP_FREG1
condition|)
name|EMIT_INSTRUCTION
argument_list|(
name|EMIT_FPU_OPERATION
argument_list|(
name|VMOV_F32
argument_list|,
name|op
operator|&
name|SLJIT_SINGLE_OP
argument_list|,
name|dst_fr
argument_list|,
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_NEGD
case|:
name|EMIT_INSTRUCTION
argument_list|(
name|EMIT_FPU_OPERATION
argument_list|(
name|VNEG_F32
argument_list|,
name|op
operator|&
name|SLJIT_SINGLE_OP
argument_list|,
name|dst_fr
argument_list|,
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_ABSD
case|:
name|EMIT_INSTRUCTION
argument_list|(
name|EMIT_FPU_OPERATION
argument_list|(
name|VABS_F32
argument_list|,
name|op
operator|&
name|SLJIT_SINGLE_OP
argument_list|,
name|dst_fr
argument_list|,
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|dst_fr
operator|==
name|TMP_FREG1
condition|)
block|{
if|if
condition|(
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
operator|==
name|SLJIT_MOVD
condition|)
name|dst_fr
operator|=
name|src
expr_stmt|;
name|FAIL_IF
argument_list|(
name|emit_fop_mem
argument_list|(
name|compiler
argument_list|,
operator|(
name|op
operator|&
name|SLJIT_SINGLE_OP
operator|)
argument_list|,
name|dst_fr
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_fop2
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_fop2
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src1
parameter_list|,
name|sljit_sw
name|src1w
parameter_list|,
name|sljit_si
name|src2
parameter_list|,
name|sljit_sw
name|src2w
parameter_list|)
block|{
name|sljit_si
name|dst_fr
decl_stmt|;
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|check_sljit_emit_fop2
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
name|compiler
operator|->
name|cache_arg
operator|=
literal|0
expr_stmt|;
name|compiler
operator|->
name|cache_argw
operator|=
literal|0
expr_stmt|;
name|op
operator|^=
name|SLJIT_SINGLE_OP
expr_stmt|;
name|dst_fr
operator|=
operator|(
name|dst
operator|>
name|SLJIT_FLOAT_REG6
operator|)
condition|?
name|TMP_FREG1
else|:
name|dst
expr_stmt|;
if|if
condition|(
name|src2
operator|>
name|SLJIT_FLOAT_REG6
condition|)
block|{
name|FAIL_IF
argument_list|(
name|emit_fop_mem
argument_list|(
name|compiler
argument_list|,
operator|(
name|op
operator|&
name|SLJIT_SINGLE_OP
operator|)
operator||
name|FPU_LOAD
argument_list|,
name|TMP_FREG2
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
argument_list|)
expr_stmt|;
name|src2
operator|=
name|TMP_FREG2
expr_stmt|;
block|}
if|if
condition|(
name|src1
operator|>
name|SLJIT_FLOAT_REG6
condition|)
block|{
name|FAIL_IF
argument_list|(
name|emit_fop_mem
argument_list|(
name|compiler
argument_list|,
operator|(
name|op
operator|&
name|SLJIT_SINGLE_OP
operator|)
operator||
name|FPU_LOAD
argument_list|,
name|TMP_FREG1
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
argument_list|)
expr_stmt|;
name|src1
operator|=
name|TMP_FREG1
expr_stmt|;
block|}
switch|switch
condition|(
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|SLJIT_ADDD
case|:
name|EMIT_INSTRUCTION
argument_list|(
name|EMIT_FPU_OPERATION
argument_list|(
name|VADD_F32
argument_list|,
name|op
operator|&
name|SLJIT_SINGLE_OP
argument_list|,
name|dst_fr
argument_list|,
name|src2
argument_list|,
name|src1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_SUBD
case|:
name|EMIT_INSTRUCTION
argument_list|(
name|EMIT_FPU_OPERATION
argument_list|(
name|VSUB_F32
argument_list|,
name|op
operator|&
name|SLJIT_SINGLE_OP
argument_list|,
name|dst_fr
argument_list|,
name|src2
argument_list|,
name|src1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_MULD
case|:
name|EMIT_INSTRUCTION
argument_list|(
name|EMIT_FPU_OPERATION
argument_list|(
name|VMUL_F32
argument_list|,
name|op
operator|&
name|SLJIT_SINGLE_OP
argument_list|,
name|dst_fr
argument_list|,
name|src2
argument_list|,
name|src1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_DIVD
case|:
name|EMIT_INSTRUCTION
argument_list|(
name|EMIT_FPU_OPERATION
argument_list|(
name|VDIV_F32
argument_list|,
name|op
operator|&
name|SLJIT_SINGLE_OP
argument_list|,
name|dst_fr
argument_list|,
name|src2
argument_list|,
name|src1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|dst_fr
operator|==
name|TMP_FREG1
condition|)
name|FAIL_IF
argument_list|(
name|emit_fop_mem
argument_list|(
name|compiler
argument_list|,
operator|(
name|op
operator|&
name|SLJIT_SINGLE_OP
operator|)
argument_list|,
name|TMP_FREG1
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_undef
DECL|macro|FPU_LOAD
undef|#
directive|undef
name|FPU_LOAD
end_undef
begin_undef
DECL|macro|EMIT_FPU_DATA_TRANSFER
undef|#
directive|undef
name|EMIT_FPU_DATA_TRANSFER
end_undef
begin_undef
DECL|macro|EMIT_FPU_OPERATION
undef|#
directive|undef
name|EMIT_FPU_OPERATION
end_undef
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_comment
comment|/*  Other instructions                                                   */
end_comment
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_function
DECL|function|sljit_emit_fast_enter
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_fast_enter
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|)
block|{
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|check_sljit_emit_fast_enter
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|ADJUST_LOCAL_OFFSET
argument_list|(
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
comment|/* For UNUSED dst. Uncommon, but possible. */
if|if
condition|(
name|dst
operator|==
name|SLJIT_UNUSED
condition|)
return|return
name|SLJIT_SUCCESS
return|;
if|if
condition|(
name|dst
operator|<=
name|TMP_REG3
condition|)
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|EMIT_DATA_PROCESS_INS
argument_list|(
name|MOV_DP
argument_list|,
literal|0
argument_list|,
name|dst
argument_list|,
name|SLJIT_UNUSED
argument_list|,
name|RM
argument_list|(
name|TMP_REG3
argument_list|)
argument_list|)
argument_list|)
return|;
comment|/* Memory. */
if|if
condition|(
name|getput_arg_fast
argument_list|(
name|compiler
argument_list|,
name|WORD_DATA
argument_list|,
name|TMP_REG3
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
condition|)
return|return
name|compiler
operator|->
name|error
return|;
comment|/* TMP_REG3 is used for caching. */
name|EMIT_INSTRUCTION
argument_list|(
name|EMIT_DATA_PROCESS_INS
argument_list|(
name|MOV_DP
argument_list|,
literal|0
argument_list|,
name|TMP_REG2
argument_list|,
name|SLJIT_UNUSED
argument_list|,
name|RM
argument_list|(
name|TMP_REG3
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|compiler
operator|->
name|cache_arg
operator|=
literal|0
expr_stmt|;
name|compiler
operator|->
name|cache_argw
operator|=
literal|0
expr_stmt|;
return|return
name|getput_arg
argument_list|(
name|compiler
argument_list|,
name|WORD_DATA
argument_list|,
name|TMP_REG2
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_fast_return
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_fast_return
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|)
block|{
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|check_sljit_emit_fast_return
argument_list|(
name|compiler
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|ADJUST_LOCAL_OFFSET
argument_list|(
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
if|if
condition|(
name|src
operator|<=
name|TMP_REG3
condition|)
name|EMIT_INSTRUCTION
argument_list|(
name|EMIT_DATA_PROCESS_INS
argument_list|(
name|MOV_DP
argument_list|,
literal|0
argument_list|,
name|TMP_REG3
argument_list|,
name|SLJIT_UNUSED
argument_list|,
name|RM
argument_list|(
name|src
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|src
operator|&
name|SLJIT_MEM
condition|)
block|{
if|if
condition|(
name|getput_arg_fast
argument_list|(
name|compiler
argument_list|,
name|WORD_DATA
operator||
name|LOAD_DATA
argument_list|,
name|TMP_REG3
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
condition|)
name|FAIL_IF
argument_list|(
name|compiler
operator|->
name|error
argument_list|)
expr_stmt|;
else|else
block|{
name|compiler
operator|->
name|cache_arg
operator|=
literal|0
expr_stmt|;
name|compiler
operator|->
name|cache_argw
operator|=
literal|0
expr_stmt|;
name|FAIL_IF
argument_list|(
name|getput_arg
argument_list|(
name|compiler
argument_list|,
name|WORD_DATA
operator||
name|LOAD_DATA
argument_list|,
name|TMP_REG2
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|EMIT_INSTRUCTION
argument_list|(
name|EMIT_DATA_PROCESS_INS
argument_list|(
name|MOV_DP
argument_list|,
literal|0
argument_list|,
name|TMP_REG3
argument_list|,
name|SLJIT_UNUSED
argument_list|,
name|RM
argument_list|(
name|TMP_REG2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|src
operator|&
name|SLJIT_IMM
condition|)
name|FAIL_IF
argument_list|(
name|load_immediate
argument_list|(
name|compiler
argument_list|,
name|TMP_REG3
argument_list|,
name|srcw
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|BLX
operator||
name|RM
argument_list|(
name|TMP_REG3
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_comment
comment|/*  Conditional instructions                                             */
end_comment
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_function
DECL|function|get_cc
specifier|static
name|sljit_uw
name|get_cc
parameter_list|(
name|sljit_si
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SLJIT_C_EQUAL
case|:
case|case
name|SLJIT_C_MUL_NOT_OVERFLOW
case|:
case|case
name|SLJIT_C_FLOAT_EQUAL
case|:
return|return
literal|0x00000000
return|;
case|case
name|SLJIT_C_NOT_EQUAL
case|:
case|case
name|SLJIT_C_MUL_OVERFLOW
case|:
case|case
name|SLJIT_C_FLOAT_NOT_EQUAL
case|:
return|return
literal|0x10000000
return|;
case|case
name|SLJIT_C_LESS
case|:
case|case
name|SLJIT_C_FLOAT_LESS
case|:
return|return
literal|0x30000000
return|;
case|case
name|SLJIT_C_GREATER_EQUAL
case|:
case|case
name|SLJIT_C_FLOAT_GREATER_EQUAL
case|:
return|return
literal|0x20000000
return|;
case|case
name|SLJIT_C_GREATER
case|:
case|case
name|SLJIT_C_FLOAT_GREATER
case|:
return|return
literal|0x80000000
return|;
case|case
name|SLJIT_C_LESS_EQUAL
case|:
case|case
name|SLJIT_C_FLOAT_LESS_EQUAL
case|:
return|return
literal|0x90000000
return|;
case|case
name|SLJIT_C_SIG_LESS
case|:
return|return
literal|0xb0000000
return|;
case|case
name|SLJIT_C_SIG_GREATER_EQUAL
case|:
return|return
literal|0xa0000000
return|;
case|case
name|SLJIT_C_SIG_GREATER
case|:
return|return
literal|0xc0000000
return|;
case|case
name|SLJIT_C_SIG_LESS_EQUAL
case|:
return|return
literal|0xd0000000
return|;
case|case
name|SLJIT_C_OVERFLOW
case|:
case|case
name|SLJIT_C_FLOAT_UNORDERED
case|:
return|return
literal|0x60000000
return|;
case|case
name|SLJIT_C_NOT_OVERFLOW
case|:
case|case
name|SLJIT_C_FLOAT_ORDERED
case|:
return|return
literal|0x70000000
return|;
default|default:
comment|/* SLJIT_JUMP */
return|return
literal|0xe0000000
return|;
block|}
block|}
end_function
begin_function
DECL|function|sljit_emit_label
name|SLJIT_API_FUNC_ATTRIBUTE
name|struct
name|sljit_label
modifier|*
name|sljit_emit_label
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|)
block|{
name|struct
name|sljit_label
modifier|*
name|label
decl_stmt|;
name|CHECK_ERROR_PTR
argument_list|()
expr_stmt|;
name|check_sljit_emit_label
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
if|if
condition|(
name|compiler
operator|->
name|last_label
operator|&&
name|compiler
operator|->
name|last_label
operator|->
name|size
operator|==
name|compiler
operator|->
name|size
condition|)
return|return
name|compiler
operator|->
name|last_label
return|;
name|label
operator|=
operator|(
expr|struct
name|sljit_label
operator|*
operator|)
name|ensure_abuf
argument_list|(
name|compiler
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sljit_label
argument_list|)
argument_list|)
expr_stmt|;
name|PTR_FAIL_IF
argument_list|(
operator|!
name|label
argument_list|)
expr_stmt|;
name|set_label
argument_list|(
name|label
argument_list|,
name|compiler
argument_list|)
expr_stmt|;
return|return
name|label
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_jump
name|SLJIT_API_FUNC_ATTRIBUTE
name|struct
name|sljit_jump
modifier|*
name|sljit_emit_jump
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|type
parameter_list|)
block|{
name|struct
name|sljit_jump
modifier|*
name|jump
decl_stmt|;
name|CHECK_ERROR_PTR
argument_list|()
expr_stmt|;
name|check_sljit_emit_jump
argument_list|(
name|compiler
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|jump
operator|=
operator|(
expr|struct
name|sljit_jump
operator|*
operator|)
name|ensure_abuf
argument_list|(
name|compiler
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sljit_jump
argument_list|)
argument_list|)
expr_stmt|;
name|PTR_FAIL_IF
argument_list|(
operator|!
name|jump
argument_list|)
expr_stmt|;
name|set_jump
argument_list|(
name|jump
argument_list|,
name|compiler
argument_list|,
name|type
operator|&
name|SLJIT_REWRITABLE_JUMP
argument_list|)
expr_stmt|;
name|type
operator|&=
literal|0xff
expr_stmt|;
comment|/* In ARM, we don't need to touch the arguments. */
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_ARM_V5
operator|&&
name|SLJIT_CONFIG_ARM_V5
operator|)
if|if
condition|(
name|type
operator|>=
name|SLJIT_FAST_CALL
condition|)
name|PTR_FAIL_IF
argument_list|(
name|prepare_blx
argument_list|(
name|compiler
argument_list|)
argument_list|)
expr_stmt|;
name|PTR_FAIL_IF
argument_list|(
name|push_inst_with_unique_literal
argument_list|(
name|compiler
argument_list|,
operator|(
operator|(
name|EMIT_DATA_TRANSFER
argument_list|(
name|WORD_DATA
operator||
name|LOAD_DATA
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|type
operator|<=
name|SLJIT_JUMP
condition|?
name|TMP_PC
else|:
name|TMP_REG1
argument_list|,
name|TMP_PC
argument_list|,
literal|0
argument_list|)
operator|)
operator|&
operator|~
name|COND_MASK
operator|)
operator||
name|get_cc
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|jump
operator|->
name|flags
operator|&
name|SLJIT_REWRITABLE_JUMP
condition|)
block|{
name|jump
operator|->
name|addr
operator|=
name|compiler
operator|->
name|size
expr_stmt|;
name|compiler
operator|->
name|patches
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|>=
name|SLJIT_FAST_CALL
condition|)
block|{
name|jump
operator|->
name|flags
operator||=
name|IS_BL
expr_stmt|;
name|PTR_FAIL_IF
argument_list|(
name|emit_blx
argument_list|(
name|compiler
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|jump
operator|->
name|flags
operator|&
name|SLJIT_REWRITABLE_JUMP
operator|)
condition|)
name|jump
operator|->
name|addr
operator|=
name|compiler
operator|->
name|size
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|type
operator|>=
name|SLJIT_FAST_CALL
condition|)
name|jump
operator|->
name|flags
operator||=
name|IS_BL
expr_stmt|;
name|PTR_FAIL_IF
argument_list|(
name|emit_imm
argument_list|(
name|compiler
argument_list|,
name|TMP_REG1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|PTR_FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
operator|(
operator|(
operator|(
name|type
operator|<=
name|SLJIT_JUMP
condition|?
name|BX
else|:
name|BLX
operator|)
operator||
name|RM
argument_list|(
name|TMP_REG1
argument_list|)
operator|)
operator|&
operator|~
name|COND_MASK
operator|)
operator||
name|get_cc
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|jump
operator|->
name|addr
operator|=
name|compiler
operator|->
name|size
expr_stmt|;
endif|#
directive|endif
return|return
name|jump
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_ijump
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_ijump
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|type
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|)
block|{
name|struct
name|sljit_jump
modifier|*
name|jump
decl_stmt|;
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|check_sljit_emit_ijump
argument_list|(
name|compiler
argument_list|,
name|type
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|ADJUST_LOCAL_OFFSET
argument_list|(
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
comment|/* In ARM, we don't need to touch the arguments. */
if|if
condition|(
name|src
operator|&
name|SLJIT_IMM
condition|)
block|{
name|jump
operator|=
operator|(
expr|struct
name|sljit_jump
operator|*
operator|)
name|ensure_abuf
argument_list|(
name|compiler
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sljit_jump
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|jump
argument_list|)
expr_stmt|;
name|set_jump
argument_list|(
name|jump
argument_list|,
name|compiler
argument_list|,
name|JUMP_ADDR
operator||
operator|(
operator|(
name|type
operator|>=
name|SLJIT_FAST_CALL
operator|)
condition|?
name|IS_BL
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|jump
operator|->
name|u
operator|.
name|target
operator|=
name|srcw
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_ARM_V5
operator|&&
name|SLJIT_CONFIG_ARM_V5
operator|)
if|if
condition|(
name|type
operator|>=
name|SLJIT_FAST_CALL
condition|)
name|FAIL_IF
argument_list|(
name|prepare_blx
argument_list|(
name|compiler
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|push_inst_with_unique_literal
argument_list|(
name|compiler
argument_list|,
name|EMIT_DATA_TRANSFER
argument_list|(
name|WORD_DATA
operator||
name|LOAD_DATA
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|type
operator|<=
name|SLJIT_JUMP
condition|?
name|TMP_PC
else|:
name|TMP_REG1
argument_list|,
name|TMP_PC
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|>=
name|SLJIT_FAST_CALL
condition|)
name|FAIL_IF
argument_list|(
name|emit_blx
argument_list|(
name|compiler
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|FAIL_IF
argument_list|(
name|emit_imm
argument_list|(
name|compiler
argument_list|,
name|TMP_REG1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
operator|(
name|type
operator|<=
name|SLJIT_JUMP
condition|?
name|BX
else|:
name|BLX
operator|)
operator||
name|RM
argument_list|(
name|TMP_REG1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|jump
operator|->
name|addr
operator|=
name|compiler
operator|->
name|size
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|src
operator|<=
name|TMP_REG3
condition|)
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
operator|(
name|type
operator|<=
name|SLJIT_JUMP
condition|?
name|BX
else|:
name|BLX
operator|)
operator||
name|RM
argument_list|(
name|src
argument_list|)
argument_list|)
return|;
name|SLJIT_ASSERT
argument_list|(
name|src
operator|&
name|SLJIT_MEM
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|emit_op_mem
argument_list|(
name|compiler
argument_list|,
name|WORD_DATA
operator||
name|LOAD_DATA
argument_list|,
name|TMP_REG2
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
operator|(
name|type
operator|<=
name|SLJIT_JUMP
condition|?
name|BX
else|:
name|BLX
operator|)
operator||
name|RM
argument_list|(
name|TMP_REG2
argument_list|)
argument_list|)
return|;
block|}
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_op_flags
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_op_flags
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|,
name|sljit_si
name|type
parameter_list|)
block|{
name|sljit_si
name|dst_r
decl_stmt|,
name|flags
init|=
name|GET_ALL_FLAGS
argument_list|(
name|op
argument_list|)
decl_stmt|;
name|sljit_uw
name|cc
decl_stmt|,
name|ins
decl_stmt|;
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|check_sljit_emit_op_flags
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|ADJUST_LOCAL_OFFSET
argument_list|(
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|ADJUST_LOCAL_OFFSET
argument_list|(
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|==
name|SLJIT_UNUSED
condition|)
return|return
name|SLJIT_SUCCESS
return|;
name|op
operator|=
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|cc
operator|=
name|get_cc
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|dst_r
operator|=
operator|(
name|dst
operator|<=
name|TMP_REG3
operator|)
condition|?
name|dst
else|:
name|TMP_REG2
expr_stmt|;
if|if
condition|(
name|op
operator|<
name|SLJIT_ADD
condition|)
block|{
name|EMIT_INSTRUCTION
argument_list|(
name|EMIT_DATA_PROCESS_INS
argument_list|(
name|MOV_DP
argument_list|,
literal|0
argument_list|,
name|dst_r
argument_list|,
name|SLJIT_UNUSED
argument_list|,
name|SRC2_IMM
operator||
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|EMIT_INSTRUCTION
argument_list|(
operator|(
name|EMIT_DATA_PROCESS_INS
argument_list|(
name|MOV_DP
argument_list|,
literal|0
argument_list|,
name|dst_r
argument_list|,
name|SLJIT_UNUSED
argument_list|,
name|SRC2_IMM
operator||
literal|1
argument_list|)
operator|&
operator|~
name|COND_MASK
operator|)
operator||
name|cc
argument_list|)
expr_stmt|;
return|return
operator|(
name|dst_r
operator|==
name|TMP_REG2
operator|)
condition|?
name|emit_op_mem
argument_list|(
name|compiler
argument_list|,
name|WORD_DATA
argument_list|,
name|TMP_REG2
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
else|:
name|SLJIT_SUCCESS
return|;
block|}
name|ins
operator|=
operator|(
name|op
operator|==
name|SLJIT_AND
condition|?
name|AND_DP
else|:
operator|(
name|op
operator|==
name|SLJIT_OR
condition|?
name|ORR_DP
else|:
name|EOR_DP
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|op
operator|==
name|SLJIT_OR
operator|||
name|op
operator|==
name|SLJIT_XOR
operator|)
operator|&&
name|dst
operator|<=
name|TMP_REG3
operator|&&
name|dst
operator|==
name|src
condition|)
block|{
name|EMIT_INSTRUCTION
argument_list|(
operator|(
name|EMIT_DATA_PROCESS_INS
argument_list|(
name|ins
argument_list|,
literal|0
argument_list|,
name|dst
argument_list|,
name|dst
argument_list|,
name|SRC2_IMM
operator||
literal|1
argument_list|)
operator|&
operator|~
name|COND_MASK
operator|)
operator||
name|cc
argument_list|)
expr_stmt|;
comment|/* The condition must always be set, even if the ORR/EOR is not executed above. */
return|return
operator|(
name|flags
operator|&
name|SLJIT_SET_E
operator|)
condition|?
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|EMIT_DATA_PROCESS_INS
argument_list|(
name|MOV_DP
argument_list|,
name|SET_FLAGS
argument_list|,
name|TMP_REG1
argument_list|,
name|SLJIT_UNUSED
argument_list|,
name|RM
argument_list|(
name|dst
argument_list|)
argument_list|)
argument_list|)
else|:
name|SLJIT_SUCCESS
return|;
block|}
name|compiler
operator|->
name|cache_arg
operator|=
literal|0
expr_stmt|;
name|compiler
operator|->
name|cache_argw
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|src
operator|&
name|SLJIT_MEM
condition|)
block|{
name|FAIL_IF
argument_list|(
name|emit_op_mem2
argument_list|(
name|compiler
argument_list|,
name|WORD_DATA
operator||
name|LOAD_DATA
argument_list|,
name|TMP_REG1
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
argument_list|)
expr_stmt|;
name|src
operator|=
name|TMP_REG1
expr_stmt|;
name|srcw
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|src
operator|&
name|SLJIT_IMM
condition|)
block|{
name|FAIL_IF
argument_list|(
name|load_immediate
argument_list|(
name|compiler
argument_list|,
name|TMP_REG1
argument_list|,
name|srcw
argument_list|)
argument_list|)
expr_stmt|;
name|src
operator|=
name|TMP_REG1
expr_stmt|;
name|srcw
operator|=
literal|0
expr_stmt|;
block|}
name|EMIT_INSTRUCTION
argument_list|(
operator|(
name|EMIT_DATA_PROCESS_INS
argument_list|(
name|ins
argument_list|,
literal|0
argument_list|,
name|dst_r
argument_list|,
name|src
argument_list|,
name|SRC2_IMM
operator||
literal|1
argument_list|)
operator|&
operator|~
name|COND_MASK
operator|)
operator||
name|cc
argument_list|)
expr_stmt|;
name|EMIT_INSTRUCTION
argument_list|(
operator|(
name|EMIT_DATA_PROCESS_INS
argument_list|(
name|ins
argument_list|,
literal|0
argument_list|,
name|dst_r
argument_list|,
name|src
argument_list|,
name|SRC2_IMM
operator||
literal|0
argument_list|)
operator|&
operator|~
name|COND_MASK
operator|)
operator||
operator|(
name|cc
operator|^
literal|0x10000000
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst_r
operator|==
name|TMP_REG2
condition|)
name|FAIL_IF
argument_list|(
name|emit_op_mem2
argument_list|(
name|compiler
argument_list|,
name|WORD_DATA
argument_list|,
name|TMP_REG2
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|flags
operator|&
name|SLJIT_SET_E
operator|)
condition|?
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|EMIT_DATA_PROCESS_INS
argument_list|(
name|MOV_DP
argument_list|,
name|SET_FLAGS
argument_list|,
name|TMP_REG1
argument_list|,
name|SLJIT_UNUSED
argument_list|,
name|RM
argument_list|(
name|dst_r
argument_list|)
argument_list|)
argument_list|)
else|:
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_const
name|SLJIT_API_FUNC_ATTRIBUTE
name|struct
name|sljit_const
modifier|*
name|sljit_emit_const
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_sw
name|init_value
parameter_list|)
block|{
name|struct
name|sljit_const
modifier|*
name|const_
decl_stmt|;
name|sljit_si
name|reg
decl_stmt|;
name|CHECK_ERROR_PTR
argument_list|()
expr_stmt|;
name|check_sljit_emit_const
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|init_value
argument_list|)
expr_stmt|;
name|ADJUST_LOCAL_OFFSET
argument_list|(
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|const_
operator|=
operator|(
expr|struct
name|sljit_const
operator|*
operator|)
name|ensure_abuf
argument_list|(
name|compiler
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sljit_const
argument_list|)
argument_list|)
expr_stmt|;
name|PTR_FAIL_IF
argument_list|(
operator|!
name|const_
argument_list|)
expr_stmt|;
name|reg
operator|=
operator|(
name|dst
operator|<=
name|TMP_REG3
operator|)
condition|?
name|dst
else|:
name|TMP_REG2
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_ARM_V5
operator|&&
name|SLJIT_CONFIG_ARM_V5
operator|)
name|PTR_FAIL_IF
argument_list|(
name|push_inst_with_unique_literal
argument_list|(
name|compiler
argument_list|,
name|EMIT_DATA_TRANSFER
argument_list|(
name|WORD_DATA
operator||
name|LOAD_DATA
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|reg
argument_list|,
name|TMP_PC
argument_list|,
literal|0
argument_list|)
argument_list|,
name|init_value
argument_list|)
argument_list|)
expr_stmt|;
name|compiler
operator|->
name|patches
operator|++
expr_stmt|;
else|#
directive|else
name|PTR_FAIL_IF
argument_list|(
name|emit_imm
argument_list|(
name|compiler
argument_list|,
name|reg
argument_list|,
name|init_value
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|set_const
argument_list|(
name|const_
argument_list|,
name|compiler
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|==
name|TMP_REG2
operator|&&
name|dst
operator|!=
name|SLJIT_UNUSED
condition|)
name|PTR_FAIL_IF
argument_list|(
name|emit_op_mem
argument_list|(
name|compiler
argument_list|,
name|WORD_DATA
argument_list|,
name|TMP_REG2
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|const_
return|;
block|}
end_function
begin_function
DECL|function|sljit_set_jump_addr
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
name|sljit_set_jump_addr
parameter_list|(
name|sljit_uw
name|addr
parameter_list|,
name|sljit_uw
name|new_addr
parameter_list|)
block|{
name|inline_set_jump_addr
argument_list|(
name|addr
argument_list|,
name|new_addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|sljit_set_const
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
name|sljit_set_const
parameter_list|(
name|sljit_uw
name|addr
parameter_list|,
name|sljit_sw
name|new_constant
parameter_list|)
block|{
name|inline_set_const
argument_list|(
name|addr
argument_list|,
name|new_constant
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function
end_unit
