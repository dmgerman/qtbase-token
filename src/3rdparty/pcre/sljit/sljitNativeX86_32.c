begin_unit
begin_comment
comment|/*  *    Stack-less Just-In-Time compiler  *  *    Copyright 2009-2012 Zoltan Herczeg (hzmester@freemail.hu). All rights reserved.  *  * Redistribution and use in source and binary forms, with or without modification, are  * permitted provided that the following conditions are met:  *  *   1. Redistributions of source code must retain the above copyright notice, this list of  *      conditions and the following disclaimer.  *  *   2. Redistributions in binary form must reproduce the above copyright notice, this list  *      of conditions and the following disclaimer in the documentation and/or other materials  *      provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER(S) AND CONTRIBUTORS ``AS IS'' AND ANY  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT  * SHALL THE COPYRIGHT HOLDER(S) OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED  * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR  * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment
begin_comment
comment|/* x86 32-bit arch dependent functions. */
end_comment
begin_function
DECL|function|emit_do_imm
specifier|static
name|sljit_si
name|emit_do_imm
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_ub
name|opcode
parameter_list|,
name|sljit_sw
name|imm
parameter_list|)
block|{
name|sljit_ub
modifier|*
name|inst
decl_stmt|;
name|inst
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|1
operator|+
literal|1
operator|+
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
name|INC_SIZE
argument_list|(
literal|1
operator|+
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|opcode
expr_stmt|;
operator|*
operator|(
name|sljit_sw
operator|*
operator|)
name|inst
operator|=
name|imm
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_function
DECL|function|generate_far_jump_code
specifier|static
name|sljit_ub
modifier|*
name|generate_far_jump_code
parameter_list|(
name|struct
name|sljit_jump
modifier|*
name|jump
parameter_list|,
name|sljit_ub
modifier|*
name|code_ptr
parameter_list|,
name|sljit_si
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
name|SLJIT_JUMP
condition|)
block|{
operator|*
name|code_ptr
operator|++
operator|=
name|JMP_i32
expr_stmt|;
name|jump
operator|->
name|addr
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|>=
name|SLJIT_FAST_CALL
condition|)
block|{
operator|*
name|code_ptr
operator|++
operator|=
name|CALL_i32
expr_stmt|;
name|jump
operator|->
name|addr
operator|++
expr_stmt|;
block|}
else|else
block|{
operator|*
name|code_ptr
operator|++
operator|=
name|GROUP_0F
expr_stmt|;
operator|*
name|code_ptr
operator|++
operator|=
name|get_jump_code
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|jump
operator|->
name|addr
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|jump
operator|->
name|flags
operator|&
name|JUMP_LABEL
condition|)
name|jump
operator|->
name|flags
operator||=
name|PATCH_MW
expr_stmt|;
else|else
operator|*
operator|(
name|sljit_sw
operator|*
operator|)
name|code_ptr
operator|=
name|jump
operator|->
name|u
operator|.
name|target
operator|-
operator|(
name|jump
operator|->
name|addr
operator|+
literal|4
operator|)
expr_stmt|;
name|code_ptr
operator|+=
literal|4
expr_stmt|;
return|return
name|code_ptr
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_enter
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_enter
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|args
parameter_list|,
name|sljit_si
name|scratches
parameter_list|,
name|sljit_si
name|saveds
parameter_list|,
name|sljit_si
name|local_size
parameter_list|)
block|{
name|sljit_si
name|size
decl_stmt|;
name|sljit_si
name|locals_offset
decl_stmt|;
name|sljit_ub
modifier|*
name|inst
decl_stmt|;
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|check_sljit_emit_enter
argument_list|(
name|compiler
argument_list|,
name|args
argument_list|,
name|scratches
argument_list|,
name|saveds
argument_list|,
name|local_size
argument_list|)
expr_stmt|;
name|compiler
operator|->
name|scratches
operator|=
name|scratches
expr_stmt|;
name|compiler
operator|->
name|saveds
operator|=
name|saveds
expr_stmt|;
name|compiler
operator|->
name|args
operator|=
name|args
expr_stmt|;
name|compiler
operator|->
name|flags_saved
operator|=
literal|0
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_DEBUG
operator|&&
name|SLJIT_DEBUG
operator|)
name|compiler
operator|->
name|logical_local_size
operator|=
name|local_size
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
name|SLJIT_X86_32_FASTCALL
operator|&&
name|SLJIT_X86_32_FASTCALL
operator|)
name|size
operator|=
literal|1
operator|+
operator|(
name|saveds
operator|<=
literal|3
condition|?
name|saveds
else|:
literal|3
operator|)
operator|+
operator|(
name|args
operator|>
literal|0
condition|?
operator|(
name|args
operator|*
literal|2
operator|)
else|:
literal|0
operator|)
operator|+
operator|(
name|args
operator|>
literal|2
condition|?
literal|2
else|:
literal|0
operator|)
expr_stmt|;
else|#
directive|else
name|size
operator|=
literal|1
operator|+
operator|(
name|saveds
operator|<=
literal|3
condition|?
name|saveds
else|:
literal|3
operator|)
operator|+
operator|(
name|args
operator|>
literal|0
condition|?
operator|(
literal|2
operator|+
name|args
operator|*
literal|3
operator|)
else|:
literal|0
operator|)
expr_stmt|;
endif|#
directive|endif
name|inst
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|1
operator|+
name|size
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
name|INC_SIZE
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|PUSH_REG
argument_list|(
name|reg_map
index|[
name|TMP_REGISTER
index|]
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
operator|(
name|defined
name|SLJIT_X86_32_FASTCALL
operator|&&
name|SLJIT_X86_32_FASTCALL
operator|)
if|if
condition|(
name|args
operator|>
literal|0
condition|)
block|{
operator|*
name|inst
operator|++
operator|=
name|MOV_r_rm
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|MOD_REG
operator||
operator|(
name|reg_map
index|[
name|TMP_REGISTER
index|]
operator|<<
literal|3
operator|)
operator||
literal|0x4
comment|/* esp */
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|saveds
operator|>
literal|2
condition|)
name|PUSH_REG
argument_list|(
name|reg_map
index|[
name|SLJIT_SAVED_REG3
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|saveds
operator|>
literal|1
condition|)
name|PUSH_REG
argument_list|(
name|reg_map
index|[
name|SLJIT_SAVED_REG2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|saveds
operator|>
literal|0
condition|)
name|PUSH_REG
argument_list|(
name|reg_map
index|[
name|SLJIT_SAVED_REG1
index|]
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_X86_32_FASTCALL
operator|&&
name|SLJIT_X86_32_FASTCALL
operator|)
if|if
condition|(
name|args
operator|>
literal|0
condition|)
block|{
operator|*
name|inst
operator|++
operator|=
name|MOV_r_rm
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|MOD_REG
operator||
operator|(
name|reg_map
index|[
name|SLJIT_SAVED_REG1
index|]
operator|<<
literal|3
operator|)
operator||
name|reg_map
index|[
name|SLJIT_SCRATCH_REG3
index|]
expr_stmt|;
block|}
if|if
condition|(
name|args
operator|>
literal|1
condition|)
block|{
operator|*
name|inst
operator|++
operator|=
name|MOV_r_rm
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|MOD_REG
operator||
operator|(
name|reg_map
index|[
name|SLJIT_SAVED_REG2
index|]
operator|<<
literal|3
operator|)
operator||
name|reg_map
index|[
name|SLJIT_SCRATCH_REG2
index|]
expr_stmt|;
block|}
if|if
condition|(
name|args
operator|>
literal|2
condition|)
block|{
operator|*
name|inst
operator|++
operator|=
name|MOV_r_rm
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|MOD_DISP8
operator||
operator|(
name|reg_map
index|[
name|SLJIT_SAVED_REG3
index|]
operator|<<
literal|3
operator|)
operator||
literal|0x4
comment|/* esp */
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
literal|0x24
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
operator|*
operator|(
literal|3
operator|+
literal|2
operator|)
expr_stmt|;
comment|/* saveds>= 3 as well. */
block|}
else|#
directive|else
if|if
condition|(
name|args
operator|>
literal|0
condition|)
block|{
operator|*
name|inst
operator|++
operator|=
name|MOV_r_rm
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|MOD_DISP8
operator||
operator|(
name|reg_map
index|[
name|SLJIT_SAVED_REG1
index|]
operator|<<
literal|3
operator|)
operator||
name|reg_map
index|[
name|TMP_REGISTER
index|]
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
operator|*
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|args
operator|>
literal|1
condition|)
block|{
operator|*
name|inst
operator|++
operator|=
name|MOV_r_rm
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|MOD_DISP8
operator||
operator|(
name|reg_map
index|[
name|SLJIT_SAVED_REG2
index|]
operator|<<
literal|3
operator|)
operator||
name|reg_map
index|[
name|TMP_REGISTER
index|]
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
operator|*
literal|3
expr_stmt|;
block|}
if|if
condition|(
name|args
operator|>
literal|2
condition|)
block|{
operator|*
name|inst
operator|++
operator|=
name|MOV_r_rm
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|MOD_DISP8
operator||
operator|(
name|reg_map
index|[
name|SLJIT_SAVED_REG3
index|]
operator|<<
literal|3
operator|)
operator||
name|reg_map
index|[
name|TMP_REGISTER
index|]
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
operator|*
literal|4
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
name|SLJIT_X86_32_FASTCALL
operator|&&
name|SLJIT_X86_32_FASTCALL
operator|)
name|locals_offset
operator|=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|sljit_uw
argument_list|)
expr_stmt|;
else|#
directive|else
name|SLJIT_COMPILE_ASSERT
argument_list|(
name|FIXED_LOCALS_OFFSET
operator|>=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|sljit_uw
argument_list|)
argument_list|,
name|require_at_least_two_words
argument_list|)
expr_stmt|;
name|locals_offset
operator|=
name|FIXED_LOCALS_OFFSET
expr_stmt|;
endif|#
directive|endif
name|compiler
operator|->
name|scratches_start
operator|=
name|locals_offset
expr_stmt|;
if|if
condition|(
name|scratches
operator|>
literal|3
condition|)
name|locals_offset
operator|+=
operator|(
name|scratches
operator|-
literal|3
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|sljit_uw
argument_list|)
expr_stmt|;
name|compiler
operator|->
name|saveds_start
operator|=
name|locals_offset
expr_stmt|;
if|if
condition|(
name|saveds
operator|>
literal|3
condition|)
name|locals_offset
operator|+=
operator|(
name|saveds
operator|-
literal|3
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|sljit_uw
argument_list|)
expr_stmt|;
name|compiler
operator|->
name|locals_offset
operator|=
name|locals_offset
expr_stmt|;
name|local_size
operator|=
name|locals_offset
operator|+
operator|(
operator|(
name|local_size
operator|+
sizeof|sizeof
argument_list|(
name|sljit_uw
argument_list|)
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
sizeof|sizeof
argument_list|(
name|sljit_uw
argument_list|)
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|compiler
operator|->
name|local_size
operator|=
name|local_size
expr_stmt|;
ifdef|#
directive|ifdef
name|_WIN32
if|if
condition|(
name|local_size
operator|>
literal|1024
condition|)
block|{
if|#
directive|if
operator|(
name|defined
name|SLJIT_X86_32_FASTCALL
operator|&&
name|SLJIT_X86_32_FASTCALL
operator|)
name|FAIL_IF
argument_list|(
name|emit_do_imm
argument_list|(
name|compiler
argument_list|,
name|MOV_r_i32
operator|+
name|reg_map
index|[
name|SLJIT_SCRATCH_REG1
index|]
argument_list|,
name|local_size
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|local_size
operator|-=
name|FIXED_LOCALS_OFFSET
expr_stmt|;
name|FAIL_IF
argument_list|(
name|emit_do_imm
argument_list|(
name|compiler
argument_list|,
name|MOV_r_i32
operator|+
name|reg_map
index|[
name|SLJIT_SCRATCH_REG1
index|]
argument_list|,
name|local_size
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|emit_non_cum_binary
argument_list|(
name|compiler
argument_list|,
name|SUB_r_rm
argument_list|,
name|SUB_rm_r
argument_list|,
name|SUB
argument_list|,
name|SUB_EAX_i32
argument_list|,
name|SLJIT_LOCALS_REG
argument_list|,
literal|0
argument_list|,
name|SLJIT_LOCALS_REG
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|FIXED_LOCALS_OFFSET
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|FAIL_IF
argument_list|(
name|sljit_emit_ijump
argument_list|(
name|compiler
argument_list|,
name|SLJIT_CALL1
argument_list|,
name|SLJIT_IMM
argument_list|,
name|SLJIT_FUNC_OFFSET
argument_list|(
name|sljit_grow_stack
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|SLJIT_ASSERT
argument_list|(
name|local_size
operator|>
literal|0
argument_list|)
expr_stmt|;
return|return
name|emit_non_cum_binary
argument_list|(
name|compiler
argument_list|,
name|SUB_r_rm
argument_list|,
name|SUB_rm_r
argument_list|,
name|SUB
argument_list|,
name|SUB_EAX_i32
argument_list|,
name|SLJIT_LOCALS_REG
argument_list|,
literal|0
argument_list|,
name|SLJIT_LOCALS_REG
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|local_size
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|sljit_set_context
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
name|sljit_set_context
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|args
parameter_list|,
name|sljit_si
name|scratches
parameter_list|,
name|sljit_si
name|saveds
parameter_list|,
name|sljit_si
name|local_size
parameter_list|)
block|{
name|sljit_si
name|locals_offset
decl_stmt|;
name|CHECK_ERROR_VOID
argument_list|()
expr_stmt|;
name|check_sljit_set_context
argument_list|(
name|compiler
argument_list|,
name|args
argument_list|,
name|scratches
argument_list|,
name|saveds
argument_list|,
name|local_size
argument_list|)
expr_stmt|;
name|compiler
operator|->
name|scratches
operator|=
name|scratches
expr_stmt|;
name|compiler
operator|->
name|saveds
operator|=
name|saveds
expr_stmt|;
name|compiler
operator|->
name|args
operator|=
name|args
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_DEBUG
operator|&&
name|SLJIT_DEBUG
operator|)
name|compiler
operator|->
name|logical_local_size
operator|=
name|local_size
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
name|SLJIT_X86_32_FASTCALL
operator|&&
name|SLJIT_X86_32_FASTCALL
operator|)
name|locals_offset
operator|=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|sljit_uw
argument_list|)
expr_stmt|;
else|#
directive|else
name|locals_offset
operator|=
name|FIXED_LOCALS_OFFSET
expr_stmt|;
endif|#
directive|endif
name|compiler
operator|->
name|scratches_start
operator|=
name|locals_offset
expr_stmt|;
if|if
condition|(
name|scratches
operator|>
literal|3
condition|)
name|locals_offset
operator|+=
operator|(
name|scratches
operator|-
literal|3
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|sljit_uw
argument_list|)
expr_stmt|;
name|compiler
operator|->
name|saveds_start
operator|=
name|locals_offset
expr_stmt|;
if|if
condition|(
name|saveds
operator|>
literal|3
condition|)
name|locals_offset
operator|+=
operator|(
name|saveds
operator|-
literal|3
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|sljit_uw
argument_list|)
expr_stmt|;
name|compiler
operator|->
name|locals_offset
operator|=
name|locals_offset
expr_stmt|;
name|compiler
operator|->
name|local_size
operator|=
name|locals_offset
operator|+
operator|(
operator|(
name|local_size
operator|+
sizeof|sizeof
argument_list|(
name|sljit_uw
argument_list|)
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
sizeof|sizeof
argument_list|(
name|sljit_uw
argument_list|)
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|sljit_emit_return
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_return
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|)
block|{
name|sljit_si
name|size
decl_stmt|;
name|sljit_ub
modifier|*
name|inst
decl_stmt|;
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|check_sljit_emit_return
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|compiler
operator|->
name|args
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|compiler
operator|->
name|flags_saved
operator|=
literal|0
expr_stmt|;
name|FAIL_IF
argument_list|(
name|emit_mov_before_return
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|compiler
operator|->
name|local_size
operator|>
literal|0
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|emit_cum_binary
argument_list|(
name|compiler
argument_list|,
name|ADD_r_rm
argument_list|,
name|ADD_rm_r
argument_list|,
name|ADD
argument_list|,
name|ADD_EAX_i32
argument_list|,
name|SLJIT_LOCALS_REG
argument_list|,
literal|0
argument_list|,
name|SLJIT_LOCALS_REG
argument_list|,
literal|0
argument_list|,
name|SLJIT_IMM
argument_list|,
name|compiler
operator|->
name|local_size
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|=
literal|2
operator|+
operator|(
name|compiler
operator|->
name|saveds
operator|<=
literal|3
condition|?
name|compiler
operator|->
name|saveds
else|:
literal|3
operator|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_X86_32_FASTCALL
operator|&&
name|SLJIT_X86_32_FASTCALL
operator|)
if|if
condition|(
name|compiler
operator|->
name|args
operator|>
literal|2
condition|)
name|size
operator|+=
literal|2
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|compiler
operator|->
name|args
operator|>
literal|0
condition|)
name|size
operator|+=
literal|2
expr_stmt|;
endif|#
directive|endif
name|inst
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|1
operator|+
name|size
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
name|INC_SIZE
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|compiler
operator|->
name|saveds
operator|>
literal|0
condition|)
name|POP_REG
argument_list|(
name|reg_map
index|[
name|SLJIT_SAVED_REG1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|compiler
operator|->
name|saveds
operator|>
literal|1
condition|)
name|POP_REG
argument_list|(
name|reg_map
index|[
name|SLJIT_SAVED_REG2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|compiler
operator|->
name|saveds
operator|>
literal|2
condition|)
name|POP_REG
argument_list|(
name|reg_map
index|[
name|SLJIT_SAVED_REG3
index|]
argument_list|)
expr_stmt|;
name|POP_REG
argument_list|(
name|reg_map
index|[
name|TMP_REGISTER
index|]
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_X86_32_FASTCALL
operator|&&
name|SLJIT_X86_32_FASTCALL
operator|)
if|if
condition|(
name|compiler
operator|->
name|args
operator|>
literal|2
condition|)
name|RET_I16
argument_list|(
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|RET
argument_list|()
expr_stmt|;
else|#
directive|else
name|RET
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_comment
comment|/*  Operators                                                            */
end_comment
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_comment
comment|/* Size contains the flags as well. */
end_comment
begin_function
DECL|function|emit_x86_instruction
specifier|static
name|sljit_ub
modifier|*
name|emit_x86_instruction
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|size
parameter_list|,
comment|/* The register or immediate operand. */
name|sljit_si
name|a
parameter_list|,
name|sljit_sw
name|imma
parameter_list|,
comment|/* The general operand (not immediate). */
name|sljit_si
name|b
parameter_list|,
name|sljit_sw
name|immb
parameter_list|)
block|{
name|sljit_ub
modifier|*
name|inst
decl_stmt|;
name|sljit_ub
modifier|*
name|buf_ptr
decl_stmt|;
name|sljit_si
name|flags
init|=
name|size
operator|&
operator|~
literal|0xf
decl_stmt|;
name|sljit_si
name|inst_size
decl_stmt|;
comment|/* Both cannot be switched on. */
name|SLJIT_ASSERT
argument_list|(
operator|(
name|flags
operator|&
operator|(
name|EX86_BIN_INS
operator||
name|EX86_SHIFT_INS
operator|)
operator|)
operator|!=
operator|(
name|EX86_BIN_INS
operator||
name|EX86_SHIFT_INS
operator|)
argument_list|)
expr_stmt|;
comment|/* Size flags not allowed for typed instructions. */
name|SLJIT_ASSERT
argument_list|(
operator|!
operator|(
name|flags
operator|&
operator|(
name|EX86_BIN_INS
operator||
name|EX86_SHIFT_INS
operator|)
operator|)
operator|||
operator|(
name|flags
operator|&
operator|(
name|EX86_BYTE_ARG
operator||
name|EX86_HALF_ARG
operator|)
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* Both size flags cannot be switched on. */
name|SLJIT_ASSERT
argument_list|(
operator|(
name|flags
operator|&
operator|(
name|EX86_BYTE_ARG
operator||
name|EX86_HALF_ARG
operator|)
operator|)
operator|!=
operator|(
name|EX86_BYTE_ARG
operator||
name|EX86_HALF_ARG
operator|)
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_SSE2
operator|&&
name|SLJIT_SSE2
operator|)
comment|/* SSE2 and immediate is not possible. */
name|SLJIT_ASSERT
argument_list|(
operator|!
operator|(
name|a
operator|&
name|SLJIT_IMM
operator|)
operator|||
operator|!
operator|(
name|flags
operator|&
name|EX86_SSE2
operator|)
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
operator|(
name|flags
operator|&
operator|(
name|EX86_PREF_F2
operator||
name|EX86_PREF_F3
operator|)
operator|)
operator|!=
operator|(
name|EX86_PREF_F2
operator||
name|EX86_PREF_F3
operator|)
operator|&&
operator|(
name|flags
operator|&
operator|(
name|EX86_PREF_F2
operator||
name|EX86_PREF_66
operator|)
operator|)
operator|!=
operator|(
name|EX86_PREF_F2
operator||
name|EX86_PREF_66
operator|)
operator|&&
operator|(
name|flags
operator|&
operator|(
name|EX86_PREF_F3
operator||
name|EX86_PREF_66
operator|)
operator|)
operator|!=
operator|(
name|EX86_PREF_F3
operator||
name|EX86_PREF_66
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|size
operator|&=
literal|0xf
expr_stmt|;
name|inst_size
operator|=
name|size
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_SSE2
operator|&&
name|SLJIT_SSE2
operator|)
if|if
condition|(
name|flags
operator|&
operator|(
name|EX86_PREF_F2
operator||
name|EX86_PREF_F3
operator|)
condition|)
name|inst_size
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|flags
operator|&
name|EX86_PREF_66
condition|)
name|inst_size
operator|++
expr_stmt|;
comment|/* Calculate size of b. */
name|inst_size
operator|+=
literal|1
expr_stmt|;
comment|/* mod r/m byte. */
if|if
condition|(
name|b
operator|&
name|SLJIT_MEM
condition|)
block|{
if|if
condition|(
operator|(
name|b
operator|&
literal|0x0f
operator|)
operator|==
name|SLJIT_UNUSED
condition|)
name|inst_size
operator|+=
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|immb
operator|!=
literal|0
operator|&&
operator|!
operator|(
name|b
operator|&
literal|0xf0
operator|)
condition|)
block|{
comment|/* Immediate operand. */
if|if
condition|(
name|immb
operator|<=
literal|127
operator|&&
name|immb
operator|>=
operator|-
literal|128
condition|)
name|inst_size
operator|+=
sizeof|sizeof
argument_list|(
name|sljit_sb
argument_list|)
expr_stmt|;
else|else
name|inst_size
operator|+=
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|b
operator|&
literal|0xf
operator|)
operator|==
name|SLJIT_LOCALS_REG
operator|&&
operator|!
operator|(
name|b
operator|&
literal|0xf0
operator|)
condition|)
name|b
operator||=
name|SLJIT_LOCALS_REG
operator|<<
literal|4
expr_stmt|;
if|if
condition|(
operator|(
name|b
operator|&
literal|0xf0
operator|)
operator|!=
name|SLJIT_UNUSED
condition|)
name|inst_size
operator|+=
literal|1
expr_stmt|;
comment|/* SIB byte. */
block|}
comment|/* Calculate size of a. */
if|if
condition|(
name|a
operator|&
name|SLJIT_IMM
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|EX86_BIN_INS
condition|)
block|{
if|if
condition|(
name|imma
operator|<=
literal|127
operator|&&
name|imma
operator|>=
operator|-
literal|128
condition|)
block|{
name|inst_size
operator|+=
literal|1
expr_stmt|;
name|flags
operator||=
name|EX86_BYTE_ARG
expr_stmt|;
block|}
else|else
name|inst_size
operator|+=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|EX86_SHIFT_INS
condition|)
block|{
name|imma
operator|&=
literal|0x1f
expr_stmt|;
if|if
condition|(
name|imma
operator|!=
literal|1
condition|)
block|{
name|inst_size
operator|++
expr_stmt|;
name|flags
operator||=
name|EX86_BYTE_ARG
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|EX86_BYTE_ARG
condition|)
name|inst_size
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|EX86_HALF_ARG
condition|)
name|inst_size
operator|+=
sizeof|sizeof
argument_list|(
name|short
argument_list|)
expr_stmt|;
else|else
name|inst_size
operator|+=
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
expr_stmt|;
block|}
else|else
name|SLJIT_ASSERT
argument_list|(
operator|!
operator|(
name|flags
operator|&
name|EX86_SHIFT_INS
operator|)
operator|||
name|a
operator|==
name|SLJIT_PREF_SHIFT_REG
argument_list|)
expr_stmt|;
name|inst
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|1
operator|+
name|inst_size
argument_list|)
expr_stmt|;
name|PTR_FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
comment|/* Encoding the byte. */
name|INC_SIZE
argument_list|(
name|inst_size
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_SSE2
operator|&&
name|SLJIT_SSE2
operator|)
if|if
condition|(
name|flags
operator|&
name|EX86_PREF_F2
condition|)
operator|*
name|inst
operator|++
operator|=
literal|0xf2
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|EX86_PREF_F3
condition|)
operator|*
name|inst
operator|++
operator|=
literal|0xf3
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|flags
operator|&
name|EX86_PREF_66
condition|)
operator|*
name|inst
operator|++
operator|=
literal|0x66
expr_stmt|;
name|buf_ptr
operator|=
name|inst
operator|+
name|size
expr_stmt|;
comment|/* Encode mod/rm byte. */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|EX86_SHIFT_INS
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|flags
operator|&
name|EX86_BIN_INS
operator|)
operator|&&
operator|(
name|a
operator|&
name|SLJIT_IMM
operator|)
condition|)
operator|*
name|inst
operator|=
operator|(
name|flags
operator|&
name|EX86_BYTE_ARG
operator|)
condition|?
name|GROUP_BINARY_83
else|:
name|GROUP_BINARY_81
expr_stmt|;
if|if
condition|(
operator|(
name|a
operator|&
name|SLJIT_IMM
operator|)
operator|||
operator|(
name|a
operator|==
literal|0
operator|)
condition|)
operator|*
name|buf_ptr
operator|=
literal|0
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_SSE2
operator|&&
name|SLJIT_SSE2
operator|)
elseif|else
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|EX86_SSE2
operator|)
condition|)
operator|*
name|buf_ptr
operator|=
name|reg_map
index|[
name|a
index|]
operator|<<
literal|3
expr_stmt|;
else|else
operator|*
name|buf_ptr
operator|=
name|a
operator|<<
literal|3
expr_stmt|;
else|#
directive|else
else|else
operator|*
name|buf_ptr
operator|=
name|reg_map
index|[
name|a
index|]
operator|<<
literal|3
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
if|if
condition|(
name|a
operator|&
name|SLJIT_IMM
condition|)
block|{
if|if
condition|(
name|imma
operator|==
literal|1
condition|)
operator|*
name|inst
operator|=
name|GROUP_SHIFT_1
expr_stmt|;
else|else
operator|*
name|inst
operator|=
name|GROUP_SHIFT_N
expr_stmt|;
block|}
else|else
operator|*
name|inst
operator|=
name|GROUP_SHIFT_CL
expr_stmt|;
operator|*
name|buf_ptr
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|b
operator|&
name|SLJIT_MEM
operator|)
condition|)
if|#
directive|if
operator|(
name|defined
name|SLJIT_SSE2
operator|&&
name|SLJIT_SSE2
operator|)
operator|*
name|buf_ptr
operator|++
operator||=
name|MOD_REG
operator|+
operator|(
operator|(
operator|!
operator|(
name|flags
operator|&
name|EX86_SSE2
operator|)
operator|)
condition|?
name|reg_map
index|[
name|b
index|]
else|:
name|b
operator|)
expr_stmt|;
else|#
directive|else
operator|*
name|buf_ptr
operator|++
operator||=
name|MOD_REG
operator|+
name|reg_map
index|[
name|b
index|]
expr_stmt|;
endif|#
directive|endif
elseif|else
if|if
condition|(
operator|(
name|b
operator|&
literal|0x0f
operator|)
operator|!=
name|SLJIT_UNUSED
condition|)
block|{
if|if
condition|(
operator|(
name|b
operator|&
literal|0xf0
operator|)
operator|==
name|SLJIT_UNUSED
operator|||
operator|(
name|b
operator|&
literal|0xf0
operator|)
operator|==
operator|(
name|SLJIT_LOCALS_REG
operator|<<
literal|4
operator|)
condition|)
block|{
if|if
condition|(
name|immb
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|immb
operator|<=
literal|127
operator|&&
name|immb
operator|>=
operator|-
literal|128
condition|)
operator|*
name|buf_ptr
operator||=
literal|0x40
expr_stmt|;
else|else
operator|*
name|buf_ptr
operator||=
literal|0x80
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|b
operator|&
literal|0xf0
operator|)
operator|==
name|SLJIT_UNUSED
condition|)
operator|*
name|buf_ptr
operator|++
operator||=
name|reg_map
index|[
name|b
operator|&
literal|0x0f
index|]
expr_stmt|;
else|else
block|{
operator|*
name|buf_ptr
operator|++
operator||=
literal|0x04
expr_stmt|;
operator|*
name|buf_ptr
operator|++
operator|=
name|reg_map
index|[
name|b
operator|&
literal|0x0f
index|]
operator||
operator|(
name|reg_map
index|[
operator|(
name|b
operator|>>
literal|4
operator|)
operator|&
literal|0x0f
index|]
operator|<<
literal|3
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|immb
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|immb
operator|<=
literal|127
operator|&&
name|immb
operator|>=
operator|-
literal|128
condition|)
operator|*
name|buf_ptr
operator|++
operator|=
name|immb
expr_stmt|;
comment|/* 8 bit displacement. */
else|else
block|{
operator|*
operator|(
name|sljit_sw
operator|*
operator|)
name|buf_ptr
operator|=
name|immb
expr_stmt|;
comment|/* 32 bit displacement. */
name|buf_ptr
operator|+=
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
operator|*
name|buf_ptr
operator|++
operator||=
literal|0x04
expr_stmt|;
operator|*
name|buf_ptr
operator|++
operator|=
name|reg_map
index|[
name|b
operator|&
literal|0x0f
index|]
operator||
operator|(
name|reg_map
index|[
operator|(
name|b
operator|>>
literal|4
operator|)
operator|&
literal|0x0f
index|]
operator|<<
literal|3
operator|)
operator||
operator|(
name|immb
operator|<<
literal|6
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
operator|*
name|buf_ptr
operator|++
operator||=
literal|0x05
expr_stmt|;
operator|*
operator|(
name|sljit_sw
operator|*
operator|)
name|buf_ptr
operator|=
name|immb
expr_stmt|;
comment|/* 32 bit displacement. */
name|buf_ptr
operator|+=
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|a
operator|&
name|SLJIT_IMM
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|EX86_BYTE_ARG
condition|)
operator|*
name|buf_ptr
operator|=
name|imma
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|EX86_HALF_ARG
condition|)
operator|*
operator|(
name|short
operator|*
operator|)
name|buf_ptr
operator|=
name|imma
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|EX86_SHIFT_INS
operator|)
condition|)
operator|*
operator|(
name|sljit_sw
operator|*
operator|)
name|buf_ptr
operator|=
name|imma
expr_stmt|;
block|}
return|return
operator|!
operator|(
name|flags
operator|&
name|EX86_SHIFT_INS
operator|)
condition|?
name|inst
else|:
operator|(
name|inst
operator|+
literal|1
operator|)
return|;
block|}
end_function
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_comment
comment|/*  Call / return instructions                                           */
end_comment
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_function
DECL|function|call_with_args
specifier|static
name|SLJIT_INLINE
name|sljit_si
name|call_with_args
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|type
parameter_list|)
block|{
name|sljit_ub
modifier|*
name|inst
decl_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_X86_32_FASTCALL
operator|&&
name|SLJIT_X86_32_FASTCALL
operator|)
name|inst
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
name|type
operator|>=
name|SLJIT_CALL3
condition|?
literal|1
operator|+
literal|2
operator|+
literal|1
else|:
literal|1
operator|+
literal|2
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
name|INC_SIZE
argument_list|(
name|type
operator|>=
name|SLJIT_CALL3
condition|?
literal|2
operator|+
literal|1
else|:
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|>=
name|SLJIT_CALL3
condition|)
name|PUSH_REG
argument_list|(
name|reg_map
index|[
name|SLJIT_SCRATCH_REG3
index|]
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|MOV_r_rm
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|MOD_REG
operator||
operator|(
name|reg_map
index|[
name|SLJIT_SCRATCH_REG3
index|]
operator|<<
literal|3
operator|)
operator||
name|reg_map
index|[
name|SLJIT_SCRATCH_REG1
index|]
expr_stmt|;
else|#
directive|else
name|inst
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|1
operator|+
literal|4
operator|*
operator|(
name|type
operator|-
name|SLJIT_CALL0
operator|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
name|INC_SIZE
argument_list|(
literal|4
operator|*
operator|(
name|type
operator|-
name|SLJIT_CALL0
operator|)
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|MOV_rm_r
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|MOD_DISP8
operator||
operator|(
name|reg_map
index|[
name|SLJIT_SCRATCH_REG1
index|]
operator|<<
literal|3
operator|)
operator||
literal|0x4
comment|/* SIB */
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
operator|(
literal|0x4
comment|/* none*/
operator|<<
literal|3
operator|)
operator||
name|reg_map
index|[
name|SLJIT_LOCALS_REG
index|]
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|type
operator|>=
name|SLJIT_CALL2
condition|)
block|{
operator|*
name|inst
operator|++
operator|=
name|MOV_rm_r
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|MOD_DISP8
operator||
operator|(
name|reg_map
index|[
name|SLJIT_SCRATCH_REG2
index|]
operator|<<
literal|3
operator|)
operator||
literal|0x4
comment|/* SIB */
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
operator|(
literal|0x4
comment|/* none*/
operator|<<
literal|3
operator|)
operator||
name|reg_map
index|[
name|SLJIT_LOCALS_REG
index|]
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|>=
name|SLJIT_CALL3
condition|)
block|{
operator|*
name|inst
operator|++
operator|=
name|MOV_rm_r
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|MOD_DISP8
operator||
operator|(
name|reg_map
index|[
name|SLJIT_SCRATCH_REG3
index|]
operator|<<
literal|3
operator|)
operator||
literal|0x4
comment|/* SIB */
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
operator|(
literal|0x4
comment|/* none*/
operator|<<
literal|3
operator|)
operator||
name|reg_map
index|[
name|SLJIT_LOCALS_REG
index|]
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_fast_enter
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_fast_enter
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|)
block|{
name|sljit_ub
modifier|*
name|inst
decl_stmt|;
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|check_sljit_emit_fast_enter
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|ADJUST_LOCAL_OFFSET
argument_list|(
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|CHECK_EXTRA_REGS
argument_list|(
name|dst
argument_list|,
name|dstw
argument_list|,
operator|(
name|void
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* For UNUSED dst. Uncommon, but possible. */
if|if
condition|(
name|dst
operator|==
name|SLJIT_UNUSED
condition|)
name|dst
operator|=
name|TMP_REGISTER
expr_stmt|;
if|if
condition|(
name|dst
operator|<=
name|TMP_REGISTER
condition|)
block|{
comment|/* Unused dest is possible here. */
name|inst
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|1
operator|+
literal|1
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
name|INC_SIZE
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|POP_REG
argument_list|(
name|reg_map
index|[
name|dst
index|]
argument_list|)
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
comment|/* Memory. */
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|POP_rm
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_fast_return
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_fast_return
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|)
block|{
name|sljit_ub
modifier|*
name|inst
decl_stmt|;
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|check_sljit_emit_fast_return
argument_list|(
name|compiler
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|ADJUST_LOCAL_OFFSET
argument_list|(
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|CHECK_EXTRA_REGS
argument_list|(
name|src
argument_list|,
name|srcw
argument_list|,
operator|(
name|void
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|src
operator|<=
name|TMP_REGISTER
condition|)
block|{
name|inst
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|1
operator|+
literal|1
operator|+
literal|1
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
name|INC_SIZE
argument_list|(
literal|1
operator|+
literal|1
argument_list|)
expr_stmt|;
name|PUSH_REG
argument_list|(
name|reg_map
index|[
name|src
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|src
operator|&
name|SLJIT_MEM
condition|)
block|{
name|inst
operator|=
name|emit_x86_instruction
argument_list|(
name|compiler
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|GROUP_FF
expr_stmt|;
operator|*
name|inst
operator||=
name|PUSH_rm
expr_stmt|;
name|inst
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|1
operator|+
literal|1
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
name|INC_SIZE
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* SLJIT_IMM. */
name|inst
operator|=
operator|(
name|sljit_ub
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
literal|1
operator|+
literal|5
operator|+
literal|1
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|inst
argument_list|)
expr_stmt|;
name|INC_SIZE
argument_list|(
literal|5
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|*
name|inst
operator|++
operator|=
name|PUSH_i32
expr_stmt|;
operator|*
operator|(
name|sljit_sw
operator|*
operator|)
name|inst
operator|=
name|srcw
expr_stmt|;
name|inst
operator|+=
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
expr_stmt|;
block|}
name|RET
argument_list|()
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
end_unit
