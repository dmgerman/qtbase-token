begin_unit
begin_comment
comment|/*  *    Stack-less Just-In-Time compiler  *  *    Copyright 2009-2012 Zoltan Herczeg (hzmester@freemail.hu). All rights reserved.  *  * Redistribution and use in source and binary forms, with or without modification, are  * permitted provided that the following conditions are met:  *  *   1. Redistributions of source code must retain the above copyright notice, this list of  *      conditions and the following disclaimer.  *  *   2. Redistributions in binary form must reproduce the above copyright notice, this list  *      of conditions and the following disclaimer in the documentation and/or other materials  *      provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER(S) AND CONTRIBUTORS ``AS IS'' AND ANY  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT  * SHALL THE COPYRIGHT HOLDER(S) OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED  * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR  * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment
begin_function
DECL|function|sljit_get_platform_name
name|SLJIT_API_FUNC_ATTRIBUTE
name|SLJIT_CONST
name|char
modifier|*
name|sljit_get_platform_name
parameter_list|(
name|void
parameter_list|)
block|{
return|return
literal|"PowerPC"
name|SLJIT_CPUINFO
return|;
block|}
end_function
begin_comment
comment|/* Length of an instruction word.    Both for ppc-32 and ppc-64. */
end_comment
begin_typedef
DECL|typedef|sljit_ins
typedef|typedef
name|sljit_ui
name|sljit_ins
typedef|;
end_typedef
begin_ifdef
ifdef|#
directive|ifdef
name|_AIX
end_ifdef
begin_include
include|#
directive|include
file|<sys/cache.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|ppc_cache_flush
specifier|static
name|void
name|ppc_cache_flush
parameter_list|(
name|sljit_ins
modifier|*
name|from
parameter_list|,
name|sljit_ins
modifier|*
name|to
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|_AIX
name|_sync_cache_range
argument_list|(
operator|(
name|caddr_t
operator|)
name|from
argument_list|,
call|(
name|int
call|)
argument_list|(
operator|(
name|size_t
operator|)
name|to
operator|-
operator|(
name|size_t
operator|)
name|from
argument_list|)
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|||
operator|(
name|defined
argument_list|(
name|__IBM_GCC_ASM
argument_list|)
operator|&&
name|__IBM_GCC_ASM
operator|)
if|#
directive|if
name|defined
argument_list|(
name|_ARCH_PWR
argument_list|)
operator|||
name|defined
argument_list|(
name|_ARCH_PWR2
argument_list|)
comment|/* Cache flush for POWER architecture. */
while|while
condition|(
name|from
operator|<
name|to
condition|)
block|{
asm|__asm__
specifier|volatile
asm|( 			"clf 0, %0\n" 			"dcs\n" 			: : "r"(from) 		);
name|from
operator|++
expr_stmt|;
block|}
asm|__asm__
specifier|volatile
asm|( "ics" );
elif|#
directive|elif
name|defined
argument_list|(
name|_ARCH_COM
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|_ARCH_PPC
argument_list|)
error|#
directive|error
literal|"Cache flush is not implemented for PowerPC/POWER common mode."
else|#
directive|else
comment|/* Cache flush for PowerPC architecture. */
while|while
condition|(
name|from
operator|<
name|to
condition|)
block|{
asm|__asm__
specifier|volatile
asm|( 			"dcbf 0, %0\n" 			"sync\n" 			"icbi 0, %0\n" 			: : "r"(from) 		);
name|from
operator|++
expr_stmt|;
block|}
asm|__asm__
specifier|volatile
asm|( "isync" );
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__xlc__
warning|#
directive|warning
literal|"This file may fail to compile if -qfuncsect is used"
endif|#
directive|endif
elif|#
directive|elif
name|defined
argument_list|(
name|__xlc__
argument_list|)
error|#
directive|error
literal|"Please enable GCC syntax for inline assembly statements with -qasm=gcc"
else|#
directive|else
error|#
directive|error
literal|"This platform requires a cache flush implementation."
endif|#
directive|endif
comment|/* _AIX */
block|}
end_function
begin_define
DECL|macro|TMP_REG1
define|#
directive|define
name|TMP_REG1
value|(SLJIT_NO_REGISTERS + 1)
end_define
begin_define
DECL|macro|TMP_REG2
define|#
directive|define
name|TMP_REG2
value|(SLJIT_NO_REGISTERS + 2)
end_define
begin_define
DECL|macro|TMP_REG3
define|#
directive|define
name|TMP_REG3
value|(SLJIT_NO_REGISTERS + 3)
end_define
begin_define
DECL|macro|ZERO_REG
define|#
directive|define
name|ZERO_REG
value|(SLJIT_NO_REGISTERS + 4)
end_define
begin_define
DECL|macro|TMP_FREG1
define|#
directive|define
name|TMP_FREG1
value|(0)
end_define
begin_define
DECL|macro|TMP_FREG2
define|#
directive|define
name|TMP_FREG2
value|(SLJIT_FLOAT_REG6 + 1)
end_define
begin_decl_stmt
DECL|variable|reg_map
specifier|static
name|SLJIT_CONST
name|sljit_ub
name|reg_map
index|[
name|SLJIT_NO_REGISTERS
operator|+
literal|5
index|]
init|=
block|{
literal|0
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|30
block|,
literal|29
block|,
literal|28
block|,
literal|27
block|,
literal|26
block|,
literal|1
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|31
block|}
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_comment
comment|/*  Instrucion forms                                                     */
end_comment
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_define
DECL|macro|D
define|#
directive|define
name|D
parameter_list|(
name|d
parameter_list|)
value|(reg_map[d]<< 21)
end_define
begin_define
DECL|macro|S
define|#
directive|define
name|S
parameter_list|(
name|s
parameter_list|)
value|(reg_map[s]<< 21)
end_define
begin_define
DECL|macro|A
define|#
directive|define
name|A
parameter_list|(
name|a
parameter_list|)
value|(reg_map[a]<< 16)
end_define
begin_define
DECL|macro|B
define|#
directive|define
name|B
parameter_list|(
name|b
parameter_list|)
value|(reg_map[b]<< 11)
end_define
begin_define
DECL|macro|C
define|#
directive|define
name|C
parameter_list|(
name|c
parameter_list|)
value|(reg_map[c]<< 6)
end_define
begin_define
DECL|macro|FD
define|#
directive|define
name|FD
parameter_list|(
name|fd
parameter_list|)
value|((fd)<< 21)
end_define
begin_define
DECL|macro|FA
define|#
directive|define
name|FA
parameter_list|(
name|fa
parameter_list|)
value|((fa)<< 16)
end_define
begin_define
DECL|macro|FB
define|#
directive|define
name|FB
parameter_list|(
name|fb
parameter_list|)
value|((fb)<< 11)
end_define
begin_define
DECL|macro|FC
define|#
directive|define
name|FC
parameter_list|(
name|fc
parameter_list|)
value|((fc)<< 6)
end_define
begin_define
DECL|macro|IMM
define|#
directive|define
name|IMM
parameter_list|(
name|imm
parameter_list|)
value|((imm)& 0xffff)
end_define
begin_define
DECL|macro|CRD
define|#
directive|define
name|CRD
parameter_list|(
name|d
parameter_list|)
value|((d)<< 21)
end_define
begin_comment
comment|/* Instruction bit sections.    OE and Rc flag (see ALT_SET_FLAGS). */
end_comment
begin_define
DECL|macro|OERC
define|#
directive|define
name|OERC
parameter_list|(
name|flags
parameter_list|)
value|(((flags& ALT_SET_FLAGS)>> 10) | (flags& ALT_SET_FLAGS))
end_define
begin_comment
comment|/* Rc flag (see ALT_SET_FLAGS). */
end_comment
begin_define
DECL|macro|RC
define|#
directive|define
name|RC
parameter_list|(
name|flags
parameter_list|)
value|((flags& ALT_SET_FLAGS)>> 10)
end_define
begin_define
DECL|macro|HI
define|#
directive|define
name|HI
parameter_list|(
name|opcode
parameter_list|)
value|((opcode)<< 26)
end_define
begin_define
DECL|macro|LO
define|#
directive|define
name|LO
parameter_list|(
name|opcode
parameter_list|)
value|((opcode)<< 1)
end_define
begin_define
DECL|macro|ADD
define|#
directive|define
name|ADD
value|(HI(31) | LO(266))
end_define
begin_define
DECL|macro|ADDC
define|#
directive|define
name|ADDC
value|(HI(31) | LO(10))
end_define
begin_define
DECL|macro|ADDE
define|#
directive|define
name|ADDE
value|(HI(31) | LO(138))
end_define
begin_define
DECL|macro|ADDI
define|#
directive|define
name|ADDI
value|(HI(14))
end_define
begin_define
DECL|macro|ADDIC
define|#
directive|define
name|ADDIC
value|(HI(13))
end_define
begin_define
DECL|macro|ADDIS
define|#
directive|define
name|ADDIS
value|(HI(15))
end_define
begin_define
DECL|macro|ADDME
define|#
directive|define
name|ADDME
value|(HI(31) | LO(234))
end_define
begin_define
DECL|macro|AND
define|#
directive|define
name|AND
value|(HI(31) | LO(28))
end_define
begin_define
DECL|macro|ANDI
define|#
directive|define
name|ANDI
value|(HI(28))
end_define
begin_define
DECL|macro|ANDIS
define|#
directive|define
name|ANDIS
value|(HI(29))
end_define
begin_define
DECL|macro|Bx
define|#
directive|define
name|Bx
value|(HI(18))
end_define
begin_define
DECL|macro|BCx
define|#
directive|define
name|BCx
value|(HI(16))
end_define
begin_define
DECL|macro|BCCTR
define|#
directive|define
name|BCCTR
value|(HI(19) | LO(528) | (3<< 11))
end_define
begin_define
DECL|macro|BLR
define|#
directive|define
name|BLR
value|(HI(19) | LO(16) | (0x14<< 21))
end_define
begin_define
DECL|macro|CNTLZD
define|#
directive|define
name|CNTLZD
value|(HI(31) | LO(58))
end_define
begin_define
DECL|macro|CNTLZW
define|#
directive|define
name|CNTLZW
value|(HI(31) | LO(26))
end_define
begin_define
DECL|macro|CMP
define|#
directive|define
name|CMP
value|(HI(31) | LO(0))
end_define
begin_define
DECL|macro|CMPI
define|#
directive|define
name|CMPI
value|(HI(11))
end_define
begin_define
DECL|macro|CMPL
define|#
directive|define
name|CMPL
value|(HI(31) | LO(32))
end_define
begin_define
DECL|macro|CMPLI
define|#
directive|define
name|CMPLI
value|(HI(10))
end_define
begin_define
DECL|macro|CROR
define|#
directive|define
name|CROR
value|(HI(19) | LO(449))
end_define
begin_define
DECL|macro|DIVD
define|#
directive|define
name|DIVD
value|(HI(31) | LO(489))
end_define
begin_define
DECL|macro|DIVDU
define|#
directive|define
name|DIVDU
value|(HI(31) | LO(457))
end_define
begin_define
DECL|macro|DIVW
define|#
directive|define
name|DIVW
value|(HI(31) | LO(491))
end_define
begin_define
DECL|macro|DIVWU
define|#
directive|define
name|DIVWU
value|(HI(31) | LO(459))
end_define
begin_define
DECL|macro|EXTSB
define|#
directive|define
name|EXTSB
value|(HI(31) | LO(954))
end_define
begin_define
DECL|macro|EXTSH
define|#
directive|define
name|EXTSH
value|(HI(31) | LO(922))
end_define
begin_define
DECL|macro|EXTSW
define|#
directive|define
name|EXTSW
value|(HI(31) | LO(986))
end_define
begin_define
DECL|macro|FABS
define|#
directive|define
name|FABS
value|(HI(63) | LO(264))
end_define
begin_define
DECL|macro|FADD
define|#
directive|define
name|FADD
value|(HI(63) | LO(21))
end_define
begin_define
DECL|macro|FADDS
define|#
directive|define
name|FADDS
value|(HI(59) | LO(21))
end_define
begin_define
DECL|macro|FCMPU
define|#
directive|define
name|FCMPU
value|(HI(63) | LO(0))
end_define
begin_define
DECL|macro|FDIV
define|#
directive|define
name|FDIV
value|(HI(63) | LO(18))
end_define
begin_define
DECL|macro|FDIVS
define|#
directive|define
name|FDIVS
value|(HI(59) | LO(18))
end_define
begin_define
DECL|macro|FMR
define|#
directive|define
name|FMR
value|(HI(63) | LO(72))
end_define
begin_define
DECL|macro|FMUL
define|#
directive|define
name|FMUL
value|(HI(63) | LO(25))
end_define
begin_define
DECL|macro|FMULS
define|#
directive|define
name|FMULS
value|(HI(59) | LO(25))
end_define
begin_define
DECL|macro|FNEG
define|#
directive|define
name|FNEG
value|(HI(63) | LO(40))
end_define
begin_define
DECL|macro|FSUB
define|#
directive|define
name|FSUB
value|(HI(63) | LO(20))
end_define
begin_define
DECL|macro|FSUBS
define|#
directive|define
name|FSUBS
value|(HI(59) | LO(20))
end_define
begin_define
DECL|macro|LD
define|#
directive|define
name|LD
value|(HI(58) | 0)
end_define
begin_define
DECL|macro|LWZ
define|#
directive|define
name|LWZ
value|(HI(32))
end_define
begin_define
DECL|macro|MFCR
define|#
directive|define
name|MFCR
value|(HI(31) | LO(19))
end_define
begin_define
DECL|macro|MFLR
define|#
directive|define
name|MFLR
value|(HI(31) | LO(339) | 0x80000)
end_define
begin_define
DECL|macro|MFXER
define|#
directive|define
name|MFXER
value|(HI(31) | LO(339) | 0x10000)
end_define
begin_define
DECL|macro|MTCTR
define|#
directive|define
name|MTCTR
value|(HI(31) | LO(467) | 0x90000)
end_define
begin_define
DECL|macro|MTLR
define|#
directive|define
name|MTLR
value|(HI(31) | LO(467) | 0x80000)
end_define
begin_define
DECL|macro|MTXER
define|#
directive|define
name|MTXER
value|(HI(31) | LO(467) | 0x10000)
end_define
begin_define
DECL|macro|MULHD
define|#
directive|define
name|MULHD
value|(HI(31) | LO(73))
end_define
begin_define
DECL|macro|MULHDU
define|#
directive|define
name|MULHDU
value|(HI(31) | LO(9))
end_define
begin_define
DECL|macro|MULHW
define|#
directive|define
name|MULHW
value|(HI(31) | LO(75))
end_define
begin_define
DECL|macro|MULHWU
define|#
directive|define
name|MULHWU
value|(HI(31) | LO(11))
end_define
begin_define
DECL|macro|MULLD
define|#
directive|define
name|MULLD
value|(HI(31) | LO(233))
end_define
begin_define
DECL|macro|MULLI
define|#
directive|define
name|MULLI
value|(HI(7))
end_define
begin_define
DECL|macro|MULLW
define|#
directive|define
name|MULLW
value|(HI(31) | LO(235))
end_define
begin_define
DECL|macro|NEG
define|#
directive|define
name|NEG
value|(HI(31) | LO(104))
end_define
begin_define
DECL|macro|NOP
define|#
directive|define
name|NOP
value|(HI(24))
end_define
begin_define
DECL|macro|NOR
define|#
directive|define
name|NOR
value|(HI(31) | LO(124))
end_define
begin_define
DECL|macro|OR
define|#
directive|define
name|OR
value|(HI(31) | LO(444))
end_define
begin_define
DECL|macro|ORI
define|#
directive|define
name|ORI
value|(HI(24))
end_define
begin_define
DECL|macro|ORIS
define|#
directive|define
name|ORIS
value|(HI(25))
end_define
begin_define
DECL|macro|RLDICL
define|#
directive|define
name|RLDICL
value|(HI(30))
end_define
begin_define
DECL|macro|RLWINM
define|#
directive|define
name|RLWINM
value|(HI(21))
end_define
begin_define
DECL|macro|SLD
define|#
directive|define
name|SLD
value|(HI(31) | LO(27))
end_define
begin_define
DECL|macro|SLW
define|#
directive|define
name|SLW
value|(HI(31) | LO(24))
end_define
begin_define
DECL|macro|SRAD
define|#
directive|define
name|SRAD
value|(HI(31) | LO(794))
end_define
begin_define
DECL|macro|SRADI
define|#
directive|define
name|SRADI
value|(HI(31) | LO(413<< 1))
end_define
begin_define
DECL|macro|SRAW
define|#
directive|define
name|SRAW
value|(HI(31) | LO(792))
end_define
begin_define
DECL|macro|SRAWI
define|#
directive|define
name|SRAWI
value|(HI(31) | LO(824))
end_define
begin_define
DECL|macro|SRD
define|#
directive|define
name|SRD
value|(HI(31) | LO(539))
end_define
begin_define
DECL|macro|SRW
define|#
directive|define
name|SRW
value|(HI(31) | LO(536))
end_define
begin_define
DECL|macro|STD
define|#
directive|define
name|STD
value|(HI(62) | 0)
end_define
begin_define
DECL|macro|STDU
define|#
directive|define
name|STDU
value|(HI(62) | 1)
end_define
begin_define
DECL|macro|STDUX
define|#
directive|define
name|STDUX
value|(HI(31) | LO(181))
end_define
begin_define
DECL|macro|STW
define|#
directive|define
name|STW
value|(HI(36))
end_define
begin_define
DECL|macro|STWU
define|#
directive|define
name|STWU
value|(HI(37))
end_define
begin_define
DECL|macro|STWUX
define|#
directive|define
name|STWUX
value|(HI(31) | LO(183))
end_define
begin_define
DECL|macro|SUBF
define|#
directive|define
name|SUBF
value|(HI(31) | LO(40))
end_define
begin_define
DECL|macro|SUBFC
define|#
directive|define
name|SUBFC
value|(HI(31) | LO(8))
end_define
begin_define
DECL|macro|SUBFE
define|#
directive|define
name|SUBFE
value|(HI(31) | LO(136))
end_define
begin_define
DECL|macro|SUBFIC
define|#
directive|define
name|SUBFIC
value|(HI(8))
end_define
begin_define
DECL|macro|XOR
define|#
directive|define
name|XOR
value|(HI(31) | LO(316))
end_define
begin_define
DECL|macro|XORI
define|#
directive|define
name|XORI
value|(HI(26))
end_define
begin_define
DECL|macro|XORIS
define|#
directive|define
name|XORIS
value|(HI(27))
end_define
begin_define
DECL|macro|SIMM_MAX
define|#
directive|define
name|SIMM_MAX
value|(0x7fff)
end_define
begin_define
DECL|macro|SIMM_MIN
define|#
directive|define
name|SIMM_MIN
value|(-0x8000)
end_define
begin_define
DECL|macro|UIMM_MAX
define|#
directive|define
name|UIMM_MAX
value|(0xffff)
end_define
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_INDIRECT_CALL
operator|&&
name|SLJIT_INDIRECT_CALL
operator|)
end_if
begin_function
DECL|function|sljit_set_function_context
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
name|sljit_set_function_context
parameter_list|(
name|void
modifier|*
modifier|*
name|func_ptr
parameter_list|,
name|struct
name|sljit_function_context
modifier|*
name|context
parameter_list|,
name|sljit_sw
name|addr
parameter_list|,
name|void
modifier|*
name|func
parameter_list|)
block|{
name|sljit_sw
modifier|*
name|ptrs
decl_stmt|;
if|if
condition|(
name|func_ptr
condition|)
operator|*
name|func_ptr
operator|=
operator|(
name|void
operator|*
operator|)
name|context
expr_stmt|;
name|ptrs
operator|=
operator|(
name|sljit_sw
operator|*
operator|)
name|func
expr_stmt|;
name|context
operator|->
name|addr
operator|=
name|addr
condition|?
name|addr
else|:
name|ptrs
index|[
literal|0
index|]
expr_stmt|;
name|context
operator|->
name|r2
operator|=
name|ptrs
index|[
literal|1
index|]
expr_stmt|;
name|context
operator|->
name|r11
operator|=
name|ptrs
index|[
literal|2
index|]
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|push_inst
specifier|static
name|sljit_si
name|push_inst
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_ins
name|ins
parameter_list|)
block|{
name|sljit_ins
modifier|*
name|ptr
init|=
operator|(
name|sljit_ins
operator|*
operator|)
name|ensure_buf
argument_list|(
name|compiler
argument_list|,
sizeof|sizeof
argument_list|(
name|sljit_ins
argument_list|)
argument_list|)
decl_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|ptr
argument_list|)
expr_stmt|;
operator|*
name|ptr
operator|=
name|ins
expr_stmt|;
name|compiler
operator|->
name|size
operator|++
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_function
DECL|function|optimize_jump
specifier|static
name|SLJIT_INLINE
name|sljit_si
name|optimize_jump
parameter_list|(
name|struct
name|sljit_jump
modifier|*
name|jump
parameter_list|,
name|sljit_ins
modifier|*
name|code_ptr
parameter_list|,
name|sljit_ins
modifier|*
name|code
parameter_list|)
block|{
name|sljit_sw
name|diff
decl_stmt|;
name|sljit_uw
name|target_addr
decl_stmt|;
if|if
condition|(
name|jump
operator|->
name|flags
operator|&
name|SLJIT_REWRITABLE_JUMP
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|jump
operator|->
name|flags
operator|&
name|JUMP_ADDR
condition|)
name|target_addr
operator|=
name|jump
operator|->
name|u
operator|.
name|target
expr_stmt|;
else|else
block|{
name|SLJIT_ASSERT
argument_list|(
name|jump
operator|->
name|flags
operator|&
name|JUMP_LABEL
argument_list|)
expr_stmt|;
name|target_addr
operator|=
call|(
name|sljit_uw
call|)
argument_list|(
name|code
operator|+
name|jump
operator|->
name|u
operator|.
name|label
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
name|diff
operator|=
operator|(
operator|(
name|sljit_sw
operator|)
name|target_addr
operator|-
call|(
name|sljit_sw
call|)
argument_list|(
name|code_ptr
argument_list|)
operator|)
operator|&
operator|~
literal|0x3l
expr_stmt|;
if|if
condition|(
name|jump
operator|->
name|flags
operator|&
name|UNCOND_B
condition|)
block|{
if|if
condition|(
name|diff
operator|<=
literal|0x01ffffff
operator|&&
name|diff
operator|>=
operator|-
literal|0x02000000
condition|)
block|{
name|jump
operator|->
name|flags
operator||=
name|PATCH_B
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|target_addr
operator|<=
literal|0x03ffffff
condition|)
block|{
name|jump
operator|->
name|flags
operator||=
name|PATCH_B
operator||
name|ABSOLUTE_B
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|diff
operator|<=
literal|0x7fff
operator|&&
name|diff
operator|>=
operator|-
literal|0x8000
condition|)
block|{
name|jump
operator|->
name|flags
operator||=
name|PATCH_B
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|target_addr
operator|<=
literal|0xffff
condition|)
block|{
name|jump
operator|->
name|flags
operator||=
name|PATCH_B
operator||
name|ABSOLUTE_B
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|sljit_generate_code
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
modifier|*
name|sljit_generate_code
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|)
block|{
name|struct
name|sljit_memory_fragment
modifier|*
name|buf
decl_stmt|;
name|sljit_ins
modifier|*
name|code
decl_stmt|;
name|sljit_ins
modifier|*
name|code_ptr
decl_stmt|;
name|sljit_ins
modifier|*
name|buf_ptr
decl_stmt|;
name|sljit_ins
modifier|*
name|buf_end
decl_stmt|;
name|sljit_uw
name|word_count
decl_stmt|;
name|sljit_uw
name|addr
decl_stmt|;
name|struct
name|sljit_label
modifier|*
name|label
decl_stmt|;
name|struct
name|sljit_jump
modifier|*
name|jump
decl_stmt|;
name|struct
name|sljit_const
modifier|*
name|const_
decl_stmt|;
name|CHECK_ERROR_PTR
argument_list|()
expr_stmt|;
name|check_sljit_generate_code
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
name|reverse_buf
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_INDIRECT_CALL
operator|&&
name|SLJIT_INDIRECT_CALL
operator|)
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_PPC_64
operator|&&
name|SLJIT_CONFIG_PPC_64
operator|)
name|compiler
operator|->
name|size
operator|+=
operator|(
name|compiler
operator|->
name|size
operator|&
literal|0x1
operator|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sljit_function_context
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|sljit_ins
argument_list|)
operator|)
expr_stmt|;
else|#
directive|else
name|compiler
operator|->
name|size
operator|+=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sljit_function_context
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|sljit_ins
argument_list|)
operator|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|code
operator|=
operator|(
name|sljit_ins
operator|*
operator|)
name|SLJIT_MALLOC_EXEC
argument_list|(
name|compiler
operator|->
name|size
operator|*
sizeof|sizeof
argument_list|(
name|sljit_ins
argument_list|)
argument_list|)
expr_stmt|;
name|PTR_FAIL_WITH_EXEC_IF
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|buf
operator|=
name|compiler
operator|->
name|buf
expr_stmt|;
name|code_ptr
operator|=
name|code
expr_stmt|;
name|word_count
operator|=
literal|0
expr_stmt|;
name|label
operator|=
name|compiler
operator|->
name|labels
expr_stmt|;
name|jump
operator|=
name|compiler
operator|->
name|jumps
expr_stmt|;
name|const_
operator|=
name|compiler
operator|->
name|consts
expr_stmt|;
do|do
block|{
name|buf_ptr
operator|=
operator|(
name|sljit_ins
operator|*
operator|)
name|buf
operator|->
name|memory
expr_stmt|;
name|buf_end
operator|=
name|buf_ptr
operator|+
operator|(
name|buf
operator|->
name|used_size
operator|>>
literal|2
operator|)
expr_stmt|;
do|do
block|{
operator|*
name|code_ptr
operator|=
operator|*
name|buf_ptr
operator|++
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
operator|!
name|label
operator|||
name|label
operator|->
name|size
operator|>=
name|word_count
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
operator|!
name|jump
operator|||
name|jump
operator|->
name|addr
operator|>=
name|word_count
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
operator|!
name|const_
operator|||
name|const_
operator|->
name|addr
operator|>=
name|word_count
argument_list|)
expr_stmt|;
comment|/* These structures are ordered by their address. */
if|if
condition|(
name|label
operator|&&
name|label
operator|->
name|size
operator|==
name|word_count
condition|)
block|{
comment|/* Just recording the address. */
name|label
operator|->
name|addr
operator|=
operator|(
name|sljit_uw
operator|)
name|code_ptr
expr_stmt|;
name|label
operator|->
name|size
operator|=
name|code_ptr
operator|-
name|code
expr_stmt|;
name|label
operator|=
name|label
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|jump
operator|&&
name|jump
operator|->
name|addr
operator|==
name|word_count
condition|)
block|{
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_PPC_32
operator|&&
name|SLJIT_CONFIG_PPC_32
operator|)
name|jump
operator|->
name|addr
operator|=
call|(
name|sljit_uw
call|)
argument_list|(
name|code_ptr
operator|-
literal|3
argument_list|)
expr_stmt|;
else|#
directive|else
name|jump
operator|->
name|addr
operator|=
call|(
name|sljit_uw
call|)
argument_list|(
name|code_ptr
operator|-
literal|6
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|optimize_jump
argument_list|(
name|jump
argument_list|,
name|code_ptr
argument_list|,
name|code
argument_list|)
condition|)
block|{
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_PPC_32
operator|&&
name|SLJIT_CONFIG_PPC_32
operator|)
name|code_ptr
index|[
operator|-
literal|3
index|]
operator|=
name|code_ptr
index|[
literal|0
index|]
expr_stmt|;
name|code_ptr
operator|-=
literal|3
expr_stmt|;
else|#
directive|else
name|code_ptr
index|[
operator|-
literal|6
index|]
operator|=
name|code_ptr
index|[
literal|0
index|]
expr_stmt|;
name|code_ptr
operator|-=
literal|6
expr_stmt|;
endif|#
directive|endif
block|}
name|jump
operator|=
name|jump
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|const_
operator|&&
name|const_
operator|->
name|addr
operator|==
name|word_count
condition|)
block|{
comment|/* Just recording the address. */
name|const_
operator|->
name|addr
operator|=
operator|(
name|sljit_uw
operator|)
name|code_ptr
expr_stmt|;
name|const_
operator|=
name|const_
operator|->
name|next
expr_stmt|;
block|}
name|code_ptr
operator|++
expr_stmt|;
name|word_count
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|buf_ptr
operator|<
name|buf_end
condition|)
do|;
name|buf
operator|=
name|buf
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|buf
condition|)
do|;
if|if
condition|(
name|label
operator|&&
name|label
operator|->
name|size
operator|==
name|word_count
condition|)
block|{
name|label
operator|->
name|addr
operator|=
operator|(
name|sljit_uw
operator|)
name|code_ptr
expr_stmt|;
name|label
operator|->
name|size
operator|=
name|code_ptr
operator|-
name|code
expr_stmt|;
name|label
operator|=
name|label
operator|->
name|next
expr_stmt|;
block|}
name|SLJIT_ASSERT
argument_list|(
operator|!
name|label
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
operator|!
name|jump
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
operator|!
name|const_
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_INDIRECT_CALL
operator|&&
name|SLJIT_INDIRECT_CALL
operator|)
name|SLJIT_ASSERT
argument_list|(
name|code_ptr
operator|-
name|code
operator|<=
operator|(
name|sljit_sw
operator|)
name|compiler
operator|->
name|size
operator|-
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sljit_function_context
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|sljit_ins
argument_list|)
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|SLJIT_ASSERT
argument_list|(
name|code_ptr
operator|-
name|code
operator|<=
operator|(
name|sljit_sw
operator|)
name|compiler
operator|->
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|jump
operator|=
name|compiler
operator|->
name|jumps
expr_stmt|;
while|while
condition|(
name|jump
condition|)
block|{
do|do
block|{
name|addr
operator|=
operator|(
name|jump
operator|->
name|flags
operator|&
name|JUMP_LABEL
operator|)
condition|?
name|jump
operator|->
name|u
operator|.
name|label
operator|->
name|addr
else|:
name|jump
operator|->
name|u
operator|.
name|target
expr_stmt|;
name|buf_ptr
operator|=
operator|(
name|sljit_ins
operator|*
operator|)
name|jump
operator|->
name|addr
expr_stmt|;
if|if
condition|(
name|jump
operator|->
name|flags
operator|&
name|PATCH_B
condition|)
block|{
if|if
condition|(
name|jump
operator|->
name|flags
operator|&
name|UNCOND_B
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|jump
operator|->
name|flags
operator|&
name|ABSOLUTE_B
operator|)
condition|)
block|{
name|addr
operator|=
name|addr
operator|-
name|jump
operator|->
name|addr
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
operator|(
name|sljit_sw
operator|)
name|addr
operator|<=
literal|0x01ffffff
operator|&&
operator|(
name|sljit_sw
operator|)
name|addr
operator|>=
operator|-
literal|0x02000000
argument_list|)
expr_stmt|;
operator|*
name|buf_ptr
operator|=
name|Bx
operator||
operator|(
name|addr
operator|&
literal|0x03fffffc
operator|)
operator||
operator|(
operator|(
operator|*
name|buf_ptr
operator|)
operator|&
literal|0x1
operator|)
expr_stmt|;
block|}
else|else
block|{
name|SLJIT_ASSERT
argument_list|(
name|addr
operator|<=
literal|0x03ffffff
argument_list|)
expr_stmt|;
operator|*
name|buf_ptr
operator|=
name|Bx
operator||
operator|(
name|addr
operator|&
literal|0x03fffffc
operator|)
operator||
literal|0x2
operator||
operator|(
operator|(
operator|*
name|buf_ptr
operator|)
operator|&
literal|0x1
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|jump
operator|->
name|flags
operator|&
name|ABSOLUTE_B
operator|)
condition|)
block|{
name|addr
operator|=
name|addr
operator|-
name|jump
operator|->
name|addr
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
operator|(
name|sljit_sw
operator|)
name|addr
operator|<=
literal|0x7fff
operator|&&
operator|(
name|sljit_sw
operator|)
name|addr
operator|>=
operator|-
literal|0x8000
argument_list|)
expr_stmt|;
operator|*
name|buf_ptr
operator|=
name|BCx
operator||
operator|(
name|addr
operator|&
literal|0xfffc
operator|)
operator||
operator|(
operator|(
operator|*
name|buf_ptr
operator|)
operator|&
literal|0x03ff0001
operator|)
expr_stmt|;
block|}
else|else
block|{
name|addr
operator|=
name|addr
operator|&
operator|~
literal|0x3l
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|addr
operator|<=
literal|0xffff
argument_list|)
expr_stmt|;
operator|*
name|buf_ptr
operator|=
name|BCx
operator||
operator|(
name|addr
operator|&
literal|0xfffc
operator|)
operator||
literal|0x2
operator||
operator|(
operator|(
operator|*
name|buf_ptr
operator|)
operator|&
literal|0x03ff0001
operator|)
expr_stmt|;
block|}
block|}
break|break;
block|}
comment|/* Set the fields of immediate loads. */
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_PPC_32
operator|&&
name|SLJIT_CONFIG_PPC_32
operator|)
name|buf_ptr
index|[
literal|0
index|]
operator|=
operator|(
name|buf_ptr
index|[
literal|0
index|]
operator|&
literal|0xffff0000
operator|)
operator||
operator|(
operator|(
name|addr
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|buf_ptr
index|[
literal|1
index|]
operator|=
operator|(
name|buf_ptr
index|[
literal|1
index|]
operator|&
literal|0xffff0000
operator|)
operator||
operator|(
name|addr
operator|&
literal|0xffff
operator|)
expr_stmt|;
else|#
directive|else
name|buf_ptr
index|[
literal|0
index|]
operator|=
operator|(
name|buf_ptr
index|[
literal|0
index|]
operator|&
literal|0xffff0000
operator|)
operator||
operator|(
operator|(
name|addr
operator|>>
literal|48
operator|)
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|buf_ptr
index|[
literal|1
index|]
operator|=
operator|(
name|buf_ptr
index|[
literal|1
index|]
operator|&
literal|0xffff0000
operator|)
operator||
operator|(
operator|(
name|addr
operator|>>
literal|32
operator|)
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|buf_ptr
index|[
literal|3
index|]
operator|=
operator|(
name|buf_ptr
index|[
literal|3
index|]
operator|&
literal|0xffff0000
operator|)
operator||
operator|(
operator|(
name|addr
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|buf_ptr
index|[
literal|4
index|]
operator|=
operator|(
name|buf_ptr
index|[
literal|4
index|]
operator|&
literal|0xffff0000
operator|)
operator||
operator|(
name|addr
operator|&
literal|0xffff
operator|)
expr_stmt|;
endif|#
directive|endif
block|}
do|while
condition|(
literal|0
condition|)
do|;
name|jump
operator|=
name|jump
operator|->
name|next
expr_stmt|;
block|}
name|SLJIT_CACHE_FLUSH
argument_list|(
name|code
argument_list|,
name|code_ptr
argument_list|)
expr_stmt|;
name|compiler
operator|->
name|error
operator|=
name|SLJIT_ERR_COMPILED
expr_stmt|;
name|compiler
operator|->
name|executable_size
operator|=
name|compiler
operator|->
name|size
operator|*
sizeof|sizeof
argument_list|(
name|sljit_ins
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_INDIRECT_CALL
operator|&&
name|SLJIT_INDIRECT_CALL
operator|)
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_PPC_64
operator|&&
name|SLJIT_CONFIG_PPC_64
operator|)
if|if
condition|(
operator|(
operator|(
name|sljit_sw
operator|)
name|code_ptr
operator|)
operator|&
literal|0x4
condition|)
name|code_ptr
operator|++
expr_stmt|;
name|sljit_set_function_context
argument_list|(
name|NULL
argument_list|,
operator|(
expr|struct
name|sljit_function_context
operator|*
operator|)
name|code_ptr
argument_list|,
operator|(
name|sljit_sw
operator|)
name|code
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sljit_generate_code
argument_list|)
expr_stmt|;
return|return
name|code_ptr
return|;
else|#
directive|else
name|sljit_set_function_context
argument_list|(
name|NULL
argument_list|,
operator|(
expr|struct
name|sljit_function_context
operator|*
operator|)
name|code_ptr
argument_list|,
operator|(
name|sljit_sw
operator|)
name|code
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sljit_generate_code
argument_list|)
expr_stmt|;
return|return
name|code_ptr
return|;
endif|#
directive|endif
else|#
directive|else
return|return
name|code
return|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_comment
comment|/*  Entry, exit                                                          */
end_comment
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_comment
comment|/* inp_flags: */
end_comment
begin_comment
comment|/* Creates an index in data_transfer_insts array. */
end_comment
begin_define
DECL|macro|LOAD_DATA
define|#
directive|define
name|LOAD_DATA
value|0x01
end_define
begin_define
DECL|macro|INDEXED
define|#
directive|define
name|INDEXED
value|0x02
end_define
begin_define
DECL|macro|WRITE_BACK
define|#
directive|define
name|WRITE_BACK
value|0x04
end_define
begin_define
DECL|macro|WORD_DATA
define|#
directive|define
name|WORD_DATA
value|0x00
end_define
begin_define
DECL|macro|BYTE_DATA
define|#
directive|define
name|BYTE_DATA
value|0x08
end_define
begin_define
DECL|macro|HALF_DATA
define|#
directive|define
name|HALF_DATA
value|0x10
end_define
begin_define
DECL|macro|INT_DATA
define|#
directive|define
name|INT_DATA
value|0x18
end_define
begin_define
DECL|macro|SIGNED_DATA
define|#
directive|define
name|SIGNED_DATA
value|0x20
end_define
begin_comment
comment|/* Separates integer and floating point registers */
end_comment
begin_define
DECL|macro|GPR_REG
define|#
directive|define
name|GPR_REG
value|0x3f
end_define
begin_define
DECL|macro|DOUBLE_DATA
define|#
directive|define
name|DOUBLE_DATA
value|0x40
end_define
begin_define
DECL|macro|MEM_MASK
define|#
directive|define
name|MEM_MASK
value|0x7f
end_define
begin_comment
comment|/* Other inp_flags. */
end_comment
begin_define
DECL|macro|ARG_TEST
define|#
directive|define
name|ARG_TEST
value|0x000100
end_define
begin_comment
comment|/* Integer opertion and set flags -> requires exts on 64 bit systems. */
end_comment
begin_define
DECL|macro|ALT_SIGN_EXT
define|#
directive|define
name|ALT_SIGN_EXT
value|0x000200
end_define
begin_comment
comment|/* This flag affects the RC() and OERC() macros. */
end_comment
begin_define
DECL|macro|ALT_SET_FLAGS
define|#
directive|define
name|ALT_SET_FLAGS
value|0x000400
end_define
begin_define
DECL|macro|ALT_KEEP_CACHE
define|#
directive|define
name|ALT_KEEP_CACHE
value|0x000800
end_define
begin_define
DECL|macro|ALT_FORM1
define|#
directive|define
name|ALT_FORM1
value|0x010000
end_define
begin_define
DECL|macro|ALT_FORM2
define|#
directive|define
name|ALT_FORM2
value|0x020000
end_define
begin_define
DECL|macro|ALT_FORM3
define|#
directive|define
name|ALT_FORM3
value|0x040000
end_define
begin_define
DECL|macro|ALT_FORM4
define|#
directive|define
name|ALT_FORM4
value|0x080000
end_define
begin_define
DECL|macro|ALT_FORM5
define|#
directive|define
name|ALT_FORM5
value|0x100000
end_define
begin_define
DECL|macro|ALT_FORM6
define|#
directive|define
name|ALT_FORM6
value|0x200000
end_define
begin_comment
comment|/* Source and destination is register. */
end_comment
begin_define
DECL|macro|REG_DEST
define|#
directive|define
name|REG_DEST
value|0x000001
end_define
begin_define
DECL|macro|REG1_SOURCE
define|#
directive|define
name|REG1_SOURCE
value|0x000002
end_define
begin_define
DECL|macro|REG2_SOURCE
define|#
directive|define
name|REG2_SOURCE
value|0x000004
end_define
begin_comment
comment|/* getput_arg_fast returned true. */
end_comment
begin_define
DECL|macro|FAST_DEST
define|#
directive|define
name|FAST_DEST
value|0x000008
end_define
begin_comment
comment|/* Multiple instructions are required. */
end_comment
begin_define
DECL|macro|SLOW_DEST
define|#
directive|define
name|SLOW_DEST
value|0x000010
end_define
begin_comment
comment|/* ALT_SIGN_EXT		0x000200 ALT_SET_FLAGS		0x000400 ALT_FORM1		0x010000 ... ALT_FORM6		0x200000 */
end_comment
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_PPC_32
operator|&&
name|SLJIT_CONFIG_PPC_32
operator|)
end_if
begin_include
include|#
directive|include
file|"sljitNativePPC_32.c"
end_include
begin_else
else|#
directive|else
end_else
begin_include
include|#
directive|include
file|"sljitNativePPC_64.c"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_PPC_32
operator|&&
name|SLJIT_CONFIG_PPC_32
operator|)
end_if
begin_define
DECL|macro|STACK_STORE
define|#
directive|define
name|STACK_STORE
value|STW
end_define
begin_define
DECL|macro|STACK_LOAD
define|#
directive|define
name|STACK_LOAD
value|LWZ
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|STACK_STORE
define|#
directive|define
name|STACK_STORE
value|STD
end_define
begin_define
DECL|macro|STACK_LOAD
define|#
directive|define
name|STACK_LOAD
value|LD
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|sljit_emit_enter
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_enter
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|args
parameter_list|,
name|sljit_si
name|scratches
parameter_list|,
name|sljit_si
name|saveds
parameter_list|,
name|sljit_si
name|local_size
parameter_list|)
block|{
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|check_sljit_emit_enter
argument_list|(
name|compiler
argument_list|,
name|args
argument_list|,
name|scratches
argument_list|,
name|saveds
argument_list|,
name|local_size
argument_list|)
expr_stmt|;
name|compiler
operator|->
name|scratches
operator|=
name|scratches
expr_stmt|;
name|compiler
operator|->
name|saveds
operator|=
name|saveds
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_DEBUG
operator|&&
name|SLJIT_DEBUG
operator|)
name|compiler
operator|->
name|logical_local_size
operator|=
name|local_size
expr_stmt|;
endif|#
directive|endif
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|MFLR
operator||
name|D
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|STACK_STORE
operator||
name|S
argument_list|(
name|ZERO_REG
argument_list|)
operator||
name|A
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
operator||
name|IMM
argument_list|(
operator|-
call|(
name|sljit_si
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|saveds
operator|>=
literal|1
condition|)
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|STACK_STORE
operator||
name|S
argument_list|(
name|SLJIT_SAVED_REG1
argument_list|)
operator||
name|A
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
operator||
name|IMM
argument_list|(
operator|-
literal|2
operator|*
call|(
name|sljit_si
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|saveds
operator|>=
literal|2
condition|)
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|STACK_STORE
operator||
name|S
argument_list|(
name|SLJIT_SAVED_REG2
argument_list|)
operator||
name|A
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
operator||
name|IMM
argument_list|(
operator|-
literal|3
operator|*
call|(
name|sljit_si
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|saveds
operator|>=
literal|3
condition|)
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|STACK_STORE
operator||
name|S
argument_list|(
name|SLJIT_SAVED_REG3
argument_list|)
operator||
name|A
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
operator||
name|IMM
argument_list|(
operator|-
literal|4
operator|*
call|(
name|sljit_si
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|saveds
operator|>=
literal|4
condition|)
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|STACK_STORE
operator||
name|S
argument_list|(
name|SLJIT_SAVED_EREG1
argument_list|)
operator||
name|A
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
operator||
name|IMM
argument_list|(
operator|-
literal|5
operator|*
call|(
name|sljit_si
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|saveds
operator|>=
literal|5
condition|)
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|STACK_STORE
operator||
name|S
argument_list|(
name|SLJIT_SAVED_EREG2
argument_list|)
operator||
name|A
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
operator||
name|IMM
argument_list|(
operator|-
literal|6
operator|*
call|(
name|sljit_si
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|STACK_STORE
operator||
name|S
argument_list|(
literal|0
argument_list|)
operator||
name|A
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
operator||
name|IMM
argument_list|(
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|ADDI
operator||
name|D
argument_list|(
name|ZERO_REG
argument_list|)
operator||
name|A
argument_list|(
literal|0
argument_list|)
operator||
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|>=
literal|1
condition|)
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|OR
operator||
name|S
argument_list|(
name|SLJIT_SCRATCH_REG1
argument_list|)
operator||
name|A
argument_list|(
name|SLJIT_SAVED_REG1
argument_list|)
operator||
name|B
argument_list|(
name|SLJIT_SCRATCH_REG1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|>=
literal|2
condition|)
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|OR
operator||
name|S
argument_list|(
name|SLJIT_SCRATCH_REG2
argument_list|)
operator||
name|A
argument_list|(
name|SLJIT_SAVED_REG2
argument_list|)
operator||
name|B
argument_list|(
name|SLJIT_SCRATCH_REG2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|>=
literal|3
condition|)
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|OR
operator||
name|S
argument_list|(
name|SLJIT_SCRATCH_REG3
argument_list|)
operator||
name|A
argument_list|(
name|SLJIT_SAVED_REG3
argument_list|)
operator||
name|B
argument_list|(
name|SLJIT_SCRATCH_REG3
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_INDIRECT_CALL
operator|&&
name|SLJIT_INDIRECT_CALL
operator|)
name|compiler
operator|->
name|local_size
operator|=
operator|(
literal|1
operator|+
name|saveds
operator|+
literal|6
operator|+
literal|8
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
operator|+
name|local_size
expr_stmt|;
else|#
directive|else
name|compiler
operator|->
name|local_size
operator|=
operator|(
literal|1
operator|+
name|saveds
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
operator|+
name|local_size
expr_stmt|;
endif|#
directive|endif
name|compiler
operator|->
name|local_size
operator|=
operator|(
name|compiler
operator|->
name|local_size
operator|+
literal|15
operator|)
operator|&
operator|~
literal|0xf
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_PPC_32
operator|&&
name|SLJIT_CONFIG_PPC_32
operator|)
if|if
condition|(
name|compiler
operator|->
name|local_size
operator|<=
name|SIMM_MAX
condition|)
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|STWU
operator||
name|S
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
operator||
name|A
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
operator||
name|IMM
argument_list|(
operator|-
name|compiler
operator|->
name|local_size
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|FAIL_IF
argument_list|(
name|load_immediate
argument_list|(
name|compiler
argument_list|,
literal|0
argument_list|,
operator|-
name|compiler
operator|->
name|local_size
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|STWUX
operator||
name|S
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
operator||
name|A
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
operator||
name|B
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|compiler
operator|->
name|local_size
operator|<=
name|SIMM_MAX
condition|)
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|STDU
operator||
name|S
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
operator||
name|A
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
operator||
name|IMM
argument_list|(
operator|-
name|compiler
operator|->
name|local_size
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|FAIL_IF
argument_list|(
name|load_immediate
argument_list|(
name|compiler
argument_list|,
literal|0
argument_list|,
operator|-
name|compiler
operator|->
name|local_size
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|STDUX
operator||
name|S
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
operator||
name|A
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
operator||
name|B
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_function
DECL|function|sljit_set_context
name|SLJIT_API_FUNC_ATTRIBUTE
name|void
name|sljit_set_context
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|args
parameter_list|,
name|sljit_si
name|scratches
parameter_list|,
name|sljit_si
name|saveds
parameter_list|,
name|sljit_si
name|local_size
parameter_list|)
block|{
name|CHECK_ERROR_VOID
argument_list|()
expr_stmt|;
name|check_sljit_set_context
argument_list|(
name|compiler
argument_list|,
name|args
argument_list|,
name|scratches
argument_list|,
name|saveds
argument_list|,
name|local_size
argument_list|)
expr_stmt|;
name|compiler
operator|->
name|scratches
operator|=
name|scratches
expr_stmt|;
name|compiler
operator|->
name|saveds
operator|=
name|saveds
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_DEBUG
operator|&&
name|SLJIT_DEBUG
operator|)
name|compiler
operator|->
name|logical_local_size
operator|=
name|local_size
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
name|SLJIT_INDIRECT_CALL
operator|&&
name|SLJIT_INDIRECT_CALL
operator|)
name|compiler
operator|->
name|local_size
operator|=
operator|(
literal|1
operator|+
name|saveds
operator|+
literal|6
operator|+
literal|8
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
operator|+
name|local_size
expr_stmt|;
else|#
directive|else
name|compiler
operator|->
name|local_size
operator|=
operator|(
literal|1
operator|+
name|saveds
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
operator|+
name|local_size
expr_stmt|;
endif|#
directive|endif
name|compiler
operator|->
name|local_size
operator|=
operator|(
name|compiler
operator|->
name|local_size
operator|+
literal|15
operator|)
operator|&
operator|~
literal|0xf
expr_stmt|;
block|}
end_function
begin_function
DECL|function|sljit_emit_return
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_return
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|)
block|{
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|check_sljit_emit_return
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|emit_mov_before_return
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|compiler
operator|->
name|local_size
operator|<=
name|SIMM_MAX
condition|)
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|ADDI
operator||
name|D
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
operator||
name|A
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
operator||
name|IMM
argument_list|(
name|compiler
operator|->
name|local_size
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|FAIL_IF
argument_list|(
name|load_immediate
argument_list|(
name|compiler
argument_list|,
literal|0
argument_list|,
name|compiler
operator|->
name|local_size
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|ADD
operator||
name|D
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
operator||
name|A
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
operator||
name|B
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|STACK_LOAD
operator||
name|D
argument_list|(
literal|0
argument_list|)
operator||
name|A
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
operator||
name|IMM
argument_list|(
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|compiler
operator|->
name|saveds
operator|>=
literal|5
condition|)
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|STACK_LOAD
operator||
name|D
argument_list|(
name|SLJIT_SAVED_EREG2
argument_list|)
operator||
name|A
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
operator||
name|IMM
argument_list|(
operator|-
literal|6
operator|*
call|(
name|sljit_si
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|compiler
operator|->
name|saveds
operator|>=
literal|4
condition|)
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|STACK_LOAD
operator||
name|D
argument_list|(
name|SLJIT_SAVED_EREG1
argument_list|)
operator||
name|A
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
operator||
name|IMM
argument_list|(
operator|-
literal|5
operator|*
call|(
name|sljit_si
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|compiler
operator|->
name|saveds
operator|>=
literal|3
condition|)
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|STACK_LOAD
operator||
name|D
argument_list|(
name|SLJIT_SAVED_REG3
argument_list|)
operator||
name|A
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
operator||
name|IMM
argument_list|(
operator|-
literal|4
operator|*
call|(
name|sljit_si
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|compiler
operator|->
name|saveds
operator|>=
literal|2
condition|)
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|STACK_LOAD
operator||
name|D
argument_list|(
name|SLJIT_SAVED_REG2
argument_list|)
operator||
name|A
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
operator||
name|IMM
argument_list|(
operator|-
literal|3
operator|*
call|(
name|sljit_si
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|compiler
operator|->
name|saveds
operator|>=
literal|1
condition|)
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|STACK_LOAD
operator||
name|D
argument_list|(
name|SLJIT_SAVED_REG1
argument_list|)
operator||
name|A
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
operator||
name|IMM
argument_list|(
operator|-
literal|2
operator|*
call|(
name|sljit_si
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|STACK_LOAD
operator||
name|D
argument_list|(
name|ZERO_REG
argument_list|)
operator||
name|A
argument_list|(
name|SLJIT_LOCALS_REG
argument_list|)
operator||
name|IMM
argument_list|(
operator|-
call|(
name|sljit_si
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|sljit_sw
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|MTLR
operator||
name|S
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|BLR
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_undef
DECL|macro|STACK_STORE
undef|#
directive|undef
name|STACK_STORE
end_undef
begin_undef
DECL|macro|STACK_LOAD
undef|#
directive|undef
name|STACK_LOAD
end_undef
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_comment
comment|/*  Operators                                                            */
end_comment
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_comment
comment|/* i/x - immediate/indexed form    n/w - no write-back / write-back (1 bit)    s/l - store/load (1 bit)    u/s - signed/unsigned (1 bit)    w/b/h/i - word/byte/half/int allowed (2 bit)    It contans 32 items, but not all are different. */
end_comment
begin_comment
comment|/* 64 bit only: [reg+imm] must be aligned to 4 bytes. */
end_comment
begin_define
DECL|macro|ADDR_MODE2
define|#
directive|define
name|ADDR_MODE2
value|0x10000
end_define
begin_comment
comment|/* 64-bit only: there is no lwau instruction. */
end_comment
begin_define
DECL|macro|UPDATE_REQ
define|#
directive|define
name|UPDATE_REQ
value|0x20000
end_define
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_PPC_32
operator|&&
name|SLJIT_CONFIG_PPC_32
operator|)
end_if
begin_define
DECL|macro|ARCH_32_64
define|#
directive|define
name|ARCH_32_64
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|a
end_define
begin_define
DECL|macro|INST_CODE_AND_DST
define|#
directive|define
name|INST_CODE_AND_DST
parameter_list|(
name|inst
parameter_list|,
name|flags
parameter_list|,
name|reg
parameter_list|)
define|\
value|((inst) | (((flags)& MEM_MASK)<= GPR_REG ? D(reg) : FD(reg)))
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|ARCH_32_64
define|#
directive|define
name|ARCH_32_64
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|b
end_define
begin_define
DECL|macro|INST_CODE_AND_DST
define|#
directive|define
name|INST_CODE_AND_DST
parameter_list|(
name|inst
parameter_list|,
name|flags
parameter_list|,
name|reg
parameter_list|)
define|\
value|(((inst)& ~(ADDR_MODE2 | UPDATE_REQ)) | (((flags)& MEM_MASK)<= GPR_REG ? D(reg) : FD(reg)))
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_decl_stmt
DECL|variable|data_transfer_insts
specifier|static
name|SLJIT_CONST
name|sljit_ins
name|data_transfer_insts
index|[
literal|64
operator|+
literal|8
index|]
init|=
block|{
comment|/* -------- Unsigned -------- */
comment|/* Word. */
comment|/* u w n i s */
name|ARCH_32_64
argument_list|(
name|HI
argument_list|(
literal|36
argument_list|)
comment|/* stw */
argument_list|,
name|HI
argument_list|(
literal|62
argument_list|)
operator||
name|ADDR_MODE2
operator||
literal|0x0
comment|/* std */
argument_list|)
block|,
comment|/* u w n i l */
name|ARCH_32_64
argument_list|(
name|HI
argument_list|(
literal|32
argument_list|)
comment|/* lwz */
argument_list|,
name|HI
argument_list|(
literal|58
argument_list|)
operator||
name|ADDR_MODE2
operator||
literal|0x0
comment|/* ld */
argument_list|)
block|,
comment|/* u w n x s */
name|ARCH_32_64
argument_list|(
name|HI
argument_list|(
literal|31
argument_list|)
operator||
name|LO
argument_list|(
literal|151
argument_list|)
comment|/* stwx */
argument_list|,
name|HI
argument_list|(
literal|31
argument_list|)
operator||
name|LO
argument_list|(
literal|149
argument_list|)
comment|/* stdx */
argument_list|)
block|,
comment|/* u w n x l */
name|ARCH_32_64
argument_list|(
name|HI
argument_list|(
literal|31
argument_list|)
operator||
name|LO
argument_list|(
literal|23
argument_list|)
comment|/* lwzx */
argument_list|,
name|HI
argument_list|(
literal|31
argument_list|)
operator||
name|LO
argument_list|(
literal|21
argument_list|)
comment|/* ldx */
argument_list|)
block|,
comment|/* u w w i s */
name|ARCH_32_64
argument_list|(
name|HI
argument_list|(
literal|37
argument_list|)
comment|/* stwu */
argument_list|,
name|HI
argument_list|(
literal|62
argument_list|)
operator||
name|ADDR_MODE2
operator||
literal|0x1
comment|/* stdu */
argument_list|)
block|,
comment|/* u w w i l */
name|ARCH_32_64
argument_list|(
name|HI
argument_list|(
literal|33
argument_list|)
comment|/* lwzu */
argument_list|,
name|HI
argument_list|(
literal|58
argument_list|)
operator||
name|ADDR_MODE2
operator||
literal|0x1
comment|/* ldu */
argument_list|)
block|,
comment|/* u w w x s */
name|ARCH_32_64
argument_list|(
name|HI
argument_list|(
literal|31
argument_list|)
operator||
name|LO
argument_list|(
literal|183
argument_list|)
comment|/* stwux */
argument_list|,
name|HI
argument_list|(
literal|31
argument_list|)
operator||
name|LO
argument_list|(
literal|181
argument_list|)
comment|/* stdux */
argument_list|)
block|,
comment|/* u w w x l */
name|ARCH_32_64
argument_list|(
name|HI
argument_list|(
literal|31
argument_list|)
operator||
name|LO
argument_list|(
literal|55
argument_list|)
comment|/* lwzux */
argument_list|,
name|HI
argument_list|(
literal|31
argument_list|)
operator||
name|LO
argument_list|(
literal|53
argument_list|)
comment|/* ldux */
argument_list|)
block|,
comment|/* Byte. */
comment|/* u b n i s */
name|HI
argument_list|(
literal|38
argument_list|)
comment|/* stb */
block|,
comment|/* u b n i l */
name|HI
argument_list|(
literal|34
argument_list|)
comment|/* lbz */
block|,
comment|/* u b n x s */
name|HI
argument_list|(
literal|31
argument_list|)
operator||
name|LO
argument_list|(
literal|215
argument_list|)
comment|/* stbx */
block|,
comment|/* u b n x l */
name|HI
argument_list|(
literal|31
argument_list|)
operator||
name|LO
argument_list|(
literal|87
argument_list|)
comment|/* lbzx */
block|,
comment|/* u b w i s */
name|HI
argument_list|(
literal|39
argument_list|)
comment|/* stbu */
block|,
comment|/* u b w i l */
name|HI
argument_list|(
literal|35
argument_list|)
comment|/* lbzu */
block|,
comment|/* u b w x s */
name|HI
argument_list|(
literal|31
argument_list|)
operator||
name|LO
argument_list|(
literal|247
argument_list|)
comment|/* stbux */
block|,
comment|/* u b w x l */
name|HI
argument_list|(
literal|31
argument_list|)
operator||
name|LO
argument_list|(
literal|119
argument_list|)
comment|/* lbzux */
block|,
comment|/* Half. */
comment|/* u h n i s */
name|HI
argument_list|(
literal|44
argument_list|)
comment|/* sth */
block|,
comment|/* u h n i l */
name|HI
argument_list|(
literal|40
argument_list|)
comment|/* lhz */
block|,
comment|/* u h n x s */
name|HI
argument_list|(
literal|31
argument_list|)
operator||
name|LO
argument_list|(
literal|407
argument_list|)
comment|/* sthx */
block|,
comment|/* u h n x l */
name|HI
argument_list|(
literal|31
argument_list|)
operator||
name|LO
argument_list|(
literal|279
argument_list|)
comment|/* lhzx */
block|,
comment|/* u h w i s */
name|HI
argument_list|(
literal|45
argument_list|)
comment|/* sthu */
block|,
comment|/* u h w i l */
name|HI
argument_list|(
literal|41
argument_list|)
comment|/* lhzu */
block|,
comment|/* u h w x s */
name|HI
argument_list|(
literal|31
argument_list|)
operator||
name|LO
argument_list|(
literal|439
argument_list|)
comment|/* sthux */
block|,
comment|/* u h w x l */
name|HI
argument_list|(
literal|31
argument_list|)
operator||
name|LO
argument_list|(
literal|311
argument_list|)
comment|/* lhzux */
block|,
comment|/* Int. */
comment|/* u i n i s */
name|HI
argument_list|(
literal|36
argument_list|)
comment|/* stw */
block|,
comment|/* u i n i l */
name|HI
argument_list|(
literal|32
argument_list|)
comment|/* lwz */
block|,
comment|/* u i n x s */
name|HI
argument_list|(
literal|31
argument_list|)
operator||
name|LO
argument_list|(
literal|151
argument_list|)
comment|/* stwx */
block|,
comment|/* u i n x l */
name|HI
argument_list|(
literal|31
argument_list|)
operator||
name|LO
argument_list|(
literal|23
argument_list|)
comment|/* lwzx */
block|,
comment|/* u i w i s */
name|HI
argument_list|(
literal|37
argument_list|)
comment|/* stwu */
block|,
comment|/* u i w i l */
name|HI
argument_list|(
literal|33
argument_list|)
comment|/* lwzu */
block|,
comment|/* u i w x s */
name|HI
argument_list|(
literal|31
argument_list|)
operator||
name|LO
argument_list|(
literal|183
argument_list|)
comment|/* stwux */
block|,
comment|/* u i w x l */
name|HI
argument_list|(
literal|31
argument_list|)
operator||
name|LO
argument_list|(
literal|55
argument_list|)
comment|/* lwzux */
block|,
comment|/* -------- Signed -------- */
comment|/* Word. */
comment|/* s w n i s */
name|ARCH_32_64
argument_list|(
name|HI
argument_list|(
literal|36
argument_list|)
comment|/* stw */
argument_list|,
name|HI
argument_list|(
literal|62
argument_list|)
operator||
name|ADDR_MODE2
operator||
literal|0x0
comment|/* std */
argument_list|)
block|,
comment|/* s w n i l */
name|ARCH_32_64
argument_list|(
name|HI
argument_list|(
literal|32
argument_list|)
comment|/* lwz */
argument_list|,
name|HI
argument_list|(
literal|58
argument_list|)
operator||
name|ADDR_MODE2
operator||
literal|0x0
comment|/* ld */
argument_list|)
block|,
comment|/* s w n x s */
name|ARCH_32_64
argument_list|(
name|HI
argument_list|(
literal|31
argument_list|)
operator||
name|LO
argument_list|(
literal|151
argument_list|)
comment|/* stwx */
argument_list|,
name|HI
argument_list|(
literal|31
argument_list|)
operator||
name|LO
argument_list|(
literal|149
argument_list|)
comment|/* stdx */
argument_list|)
block|,
comment|/* s w n x l */
name|ARCH_32_64
argument_list|(
name|HI
argument_list|(
literal|31
argument_list|)
operator||
name|LO
argument_list|(
literal|23
argument_list|)
comment|/* lwzx */
argument_list|,
name|HI
argument_list|(
literal|31
argument_list|)
operator||
name|LO
argument_list|(
literal|21
argument_list|)
comment|/* ldx */
argument_list|)
block|,
comment|/* s w w i s */
name|ARCH_32_64
argument_list|(
name|HI
argument_list|(
literal|37
argument_list|)
comment|/* stwu */
argument_list|,
name|HI
argument_list|(
literal|62
argument_list|)
operator||
name|ADDR_MODE2
operator||
literal|0x1
comment|/* stdu */
argument_list|)
block|,
comment|/* s w w i l */
name|ARCH_32_64
argument_list|(
name|HI
argument_list|(
literal|33
argument_list|)
comment|/* lwzu */
argument_list|,
name|HI
argument_list|(
literal|58
argument_list|)
operator||
name|ADDR_MODE2
operator||
literal|0x1
comment|/* ldu */
argument_list|)
block|,
comment|/* s w w x s */
name|ARCH_32_64
argument_list|(
name|HI
argument_list|(
literal|31
argument_list|)
operator||
name|LO
argument_list|(
literal|183
argument_list|)
comment|/* stwux */
argument_list|,
name|HI
argument_list|(
literal|31
argument_list|)
operator||
name|LO
argument_list|(
literal|181
argument_list|)
comment|/* stdux */
argument_list|)
block|,
comment|/* s w w x l */
name|ARCH_32_64
argument_list|(
name|HI
argument_list|(
literal|31
argument_list|)
operator||
name|LO
argument_list|(
literal|55
argument_list|)
comment|/* lwzux */
argument_list|,
name|HI
argument_list|(
literal|31
argument_list|)
operator||
name|LO
argument_list|(
literal|53
argument_list|)
comment|/* ldux */
argument_list|)
block|,
comment|/* Byte. */
comment|/* s b n i s */
name|HI
argument_list|(
literal|38
argument_list|)
comment|/* stb */
block|,
comment|/* s b n i l */
name|HI
argument_list|(
literal|34
argument_list|)
comment|/* lbz */
comment|/* EXTS_REQ */
block|,
comment|/* s b n x s */
name|HI
argument_list|(
literal|31
argument_list|)
operator||
name|LO
argument_list|(
literal|215
argument_list|)
comment|/* stbx */
block|,
comment|/* s b n x l */
name|HI
argument_list|(
literal|31
argument_list|)
operator||
name|LO
argument_list|(
literal|87
argument_list|)
comment|/* lbzx */
comment|/* EXTS_REQ */
block|,
comment|/* s b w i s */
name|HI
argument_list|(
literal|39
argument_list|)
comment|/* stbu */
block|,
comment|/* s b w i l */
name|HI
argument_list|(
literal|35
argument_list|)
comment|/* lbzu */
comment|/* EXTS_REQ */
block|,
comment|/* s b w x s */
name|HI
argument_list|(
literal|31
argument_list|)
operator||
name|LO
argument_list|(
literal|247
argument_list|)
comment|/* stbux */
block|,
comment|/* s b w x l */
name|HI
argument_list|(
literal|31
argument_list|)
operator||
name|LO
argument_list|(
literal|119
argument_list|)
comment|/* lbzux */
comment|/* EXTS_REQ */
block|,
comment|/* Half. */
comment|/* s h n i s */
name|HI
argument_list|(
literal|44
argument_list|)
comment|/* sth */
block|,
comment|/* s h n i l */
name|HI
argument_list|(
literal|42
argument_list|)
comment|/* lha */
block|,
comment|/* s h n x s */
name|HI
argument_list|(
literal|31
argument_list|)
operator||
name|LO
argument_list|(
literal|407
argument_list|)
comment|/* sthx */
block|,
comment|/* s h n x l */
name|HI
argument_list|(
literal|31
argument_list|)
operator||
name|LO
argument_list|(
literal|343
argument_list|)
comment|/* lhax */
block|,
comment|/* s h w i s */
name|HI
argument_list|(
literal|45
argument_list|)
comment|/* sthu */
block|,
comment|/* s h w i l */
name|HI
argument_list|(
literal|43
argument_list|)
comment|/* lhau */
block|,
comment|/* s h w x s */
name|HI
argument_list|(
literal|31
argument_list|)
operator||
name|LO
argument_list|(
literal|439
argument_list|)
comment|/* sthux */
block|,
comment|/* s h w x l */
name|HI
argument_list|(
literal|31
argument_list|)
operator||
name|LO
argument_list|(
literal|375
argument_list|)
comment|/* lhaux */
block|,
comment|/* Int. */
comment|/* s i n i s */
name|HI
argument_list|(
literal|36
argument_list|)
comment|/* stw */
block|,
comment|/* s i n i l */
name|ARCH_32_64
argument_list|(
name|HI
argument_list|(
literal|32
argument_list|)
comment|/* lwz */
argument_list|,
name|HI
argument_list|(
literal|58
argument_list|)
operator||
name|ADDR_MODE2
operator||
literal|0x2
comment|/* lwa */
argument_list|)
block|,
comment|/* s i n x s */
name|HI
argument_list|(
literal|31
argument_list|)
operator||
name|LO
argument_list|(
literal|151
argument_list|)
comment|/* stwx */
block|,
comment|/* s i n x l */
name|ARCH_32_64
argument_list|(
name|HI
argument_list|(
literal|31
argument_list|)
operator||
name|LO
argument_list|(
literal|23
argument_list|)
comment|/* lwzx */
argument_list|,
name|HI
argument_list|(
literal|31
argument_list|)
operator||
name|LO
argument_list|(
literal|341
argument_list|)
comment|/* lwax */
argument_list|)
block|,
comment|/* s i w i s */
name|HI
argument_list|(
literal|37
argument_list|)
comment|/* stwu */
block|,
comment|/* s i w i l */
name|ARCH_32_64
argument_list|(
name|HI
argument_list|(
literal|33
argument_list|)
comment|/* lwzu */
argument_list|,
name|HI
argument_list|(
literal|58
argument_list|)
operator||
name|ADDR_MODE2
operator||
name|UPDATE_REQ
operator||
literal|0x2
comment|/* lwa */
argument_list|)
block|,
comment|/* s i w x s */
name|HI
argument_list|(
literal|31
argument_list|)
operator||
name|LO
argument_list|(
literal|183
argument_list|)
comment|/* stwux */
block|,
comment|/* s i w x l */
name|ARCH_32_64
argument_list|(
name|HI
argument_list|(
literal|31
argument_list|)
operator||
name|LO
argument_list|(
literal|55
argument_list|)
comment|/* lwzux */
argument_list|,
name|HI
argument_list|(
literal|31
argument_list|)
operator||
name|LO
argument_list|(
literal|373
argument_list|)
comment|/* lwaux */
argument_list|)
block|,
comment|/* -------- Double -------- */
comment|/* d   n i s */
name|HI
argument_list|(
literal|54
argument_list|)
comment|/* stfd */
block|,
comment|/* d   n i l */
name|HI
argument_list|(
literal|50
argument_list|)
comment|/* lfd */
block|,
comment|/* d   n x s */
name|HI
argument_list|(
literal|31
argument_list|)
operator||
name|LO
argument_list|(
literal|727
argument_list|)
comment|/* stfdx */
block|,
comment|/* d   n x l */
name|HI
argument_list|(
literal|31
argument_list|)
operator||
name|LO
argument_list|(
literal|599
argument_list|)
comment|/* lfdx */
block|,
comment|/* s   n i s */
name|HI
argument_list|(
literal|52
argument_list|)
comment|/* stfs */
block|,
comment|/* s   n i l */
name|HI
argument_list|(
literal|48
argument_list|)
comment|/* lfs */
block|,
comment|/* s   n x s */
name|HI
argument_list|(
literal|31
argument_list|)
operator||
name|LO
argument_list|(
literal|663
argument_list|)
comment|/* stfsx */
block|,
comment|/* s   n x l */
name|HI
argument_list|(
literal|31
argument_list|)
operator||
name|LO
argument_list|(
literal|535
argument_list|)
comment|/* lfsx */
block|,  }
decl_stmt|;
end_decl_stmt
begin_undef
DECL|macro|ARCH_32_64
undef|#
directive|undef
name|ARCH_32_64
end_undef
begin_comment
comment|/* Simple cases, (no caching is required). */
end_comment
begin_function
DECL|function|getput_arg_fast
specifier|static
name|sljit_si
name|getput_arg_fast
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|inp_flags
parameter_list|,
name|sljit_si
name|reg
parameter_list|,
name|sljit_si
name|arg
parameter_list|,
name|sljit_sw
name|argw
parameter_list|)
block|{
name|sljit_ins
name|inst
decl_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_PPC_64
operator|&&
name|SLJIT_CONFIG_PPC_64
operator|)
name|sljit_si
name|tmp_reg
decl_stmt|;
endif|#
directive|endif
name|SLJIT_ASSERT
argument_list|(
name|arg
operator|&
name|SLJIT_MEM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|arg
operator|&
literal|0xf
operator|)
condition|)
block|{
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_PPC_32
operator|&&
name|SLJIT_CONFIG_PPC_32
operator|)
if|if
condition|(
name|argw
operator|<=
name|SIMM_MAX
operator|&&
name|argw
operator|>=
name|SIMM_MIN
condition|)
block|{
if|if
condition|(
name|inp_flags
operator|&
name|ARG_TEST
condition|)
return|return
literal|1
return|;
name|inst
operator|=
name|data_transfer_insts
index|[
operator|(
name|inp_flags
operator|&
operator|~
name|WRITE_BACK
operator|)
operator|&
name|MEM_MASK
index|]
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
operator|!
operator|(
name|inst
operator|&
operator|(
name|ADDR_MODE2
operator||
name|UPDATE_REQ
operator|)
operator|)
argument_list|)
expr_stmt|;
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|INST_CODE_AND_DST
argument_list|(
name|inst
argument_list|,
name|inp_flags
argument_list|,
name|reg
argument_list|)
operator||
name|IMM
argument_list|(
name|argw
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|#
directive|else
name|inst
operator|=
name|data_transfer_insts
index|[
operator|(
name|inp_flags
operator|&
operator|~
name|WRITE_BACK
operator|)
operator|&
name|MEM_MASK
index|]
expr_stmt|;
if|if
condition|(
name|argw
operator|<=
name|SIMM_MAX
operator|&&
name|argw
operator|>=
name|SIMM_MIN
operator|&&
operator|(
operator|!
operator|(
name|inst
operator|&
name|ADDR_MODE2
operator|)
operator|||
operator|(
name|argw
operator|&
literal|0x3
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|inp_flags
operator|&
name|ARG_TEST
condition|)
return|return
literal|1
return|;
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|INST_CODE_AND_DST
argument_list|(
name|inst
argument_list|,
name|inp_flags
argument_list|,
name|reg
argument_list|)
operator||
name|IMM
argument_list|(
name|argw
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
endif|#
directive|endif
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|arg
operator|&
literal|0xf0
operator|)
condition|)
block|{
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_PPC_32
operator|&&
name|SLJIT_CONFIG_PPC_32
operator|)
if|if
condition|(
name|argw
operator|<=
name|SIMM_MAX
operator|&&
name|argw
operator|>=
name|SIMM_MIN
condition|)
block|{
if|if
condition|(
name|inp_flags
operator|&
name|ARG_TEST
condition|)
return|return
literal|1
return|;
name|inst
operator|=
name|data_transfer_insts
index|[
name|inp_flags
operator|&
name|MEM_MASK
index|]
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
operator|!
operator|(
name|inst
operator|&
operator|(
name|ADDR_MODE2
operator||
name|UPDATE_REQ
operator|)
operator|)
argument_list|)
expr_stmt|;
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|INST_CODE_AND_DST
argument_list|(
name|inst
argument_list|,
name|inp_flags
argument_list|,
name|reg
argument_list|)
operator||
name|A
argument_list|(
name|arg
operator|&
literal|0xf
argument_list|)
operator||
name|IMM
argument_list|(
name|argw
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|#
directive|else
name|inst
operator|=
name|data_transfer_insts
index|[
name|inp_flags
operator|&
name|MEM_MASK
index|]
expr_stmt|;
if|if
condition|(
name|argw
operator|<=
name|SIMM_MAX
operator|&&
name|argw
operator|>=
name|SIMM_MIN
operator|&&
operator|(
operator|!
operator|(
name|inst
operator|&
name|ADDR_MODE2
operator|)
operator|||
operator|(
name|argw
operator|&
literal|0x3
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|inp_flags
operator|&
name|ARG_TEST
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|inp_flags
operator|&
name|WRITE_BACK
operator|)
operator|&&
operator|(
name|inst
operator|&
name|UPDATE_REQ
operator|)
condition|)
block|{
name|tmp_reg
operator|=
operator|(
name|inp_flags
operator|&
name|LOAD_DATA
operator|)
condition|?
operator|(
name|arg
operator|&
literal|0xf
operator|)
else|:
name|TMP_REG3
expr_stmt|;
if|if
condition|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|ADDI
operator||
name|D
argument_list|(
name|tmp_reg
argument_list|)
operator||
name|A
argument_list|(
name|arg
operator|&
literal|0xf
argument_list|)
operator||
name|IMM
argument_list|(
name|argw
argument_list|)
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|arg
operator|=
name|tmp_reg
operator||
name|SLJIT_MEM
expr_stmt|;
name|argw
operator|=
literal|0
expr_stmt|;
block|}
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|INST_CODE_AND_DST
argument_list|(
name|inst
argument_list|,
name|inp_flags
argument_list|,
name|reg
argument_list|)
operator||
name|A
argument_list|(
name|arg
operator|&
literal|0xf
argument_list|)
operator||
name|IMM
argument_list|(
name|argw
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|argw
operator|&
literal|0x3
operator|)
condition|)
block|{
if|if
condition|(
name|inp_flags
operator|&
name|ARG_TEST
condition|)
return|return
literal|1
return|;
name|inst
operator|=
name|data_transfer_insts
index|[
operator|(
name|inp_flags
operator||
name|INDEXED
operator|)
operator|&
name|MEM_MASK
index|]
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
operator|!
operator|(
name|inst
operator|&
operator|(
name|ADDR_MODE2
operator||
name|UPDATE_REQ
operator|)
operator|)
argument_list|)
expr_stmt|;
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|INST_CODE_AND_DST
argument_list|(
name|inst
argument_list|,
name|inp_flags
argument_list|,
name|reg
argument_list|)
operator||
name|A
argument_list|(
name|arg
operator|&
literal|0xf
argument_list|)
operator||
name|B
argument_list|(
operator|(
name|arg
operator|>>
literal|4
operator|)
operator|&
literal|0xf
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/* See getput_arg below.    Note: can_cache is called only for binary operators. Those operator always    uses word arguments without write back. */
end_comment
begin_function
DECL|function|can_cache
specifier|static
name|sljit_si
name|can_cache
parameter_list|(
name|sljit_si
name|arg
parameter_list|,
name|sljit_sw
name|argw
parameter_list|,
name|sljit_si
name|next_arg
parameter_list|,
name|sljit_sw
name|next_argw
parameter_list|)
block|{
name|SLJIT_ASSERT
argument_list|(
operator|(
name|arg
operator|&
name|SLJIT_MEM
operator|)
operator|&&
operator|(
name|next_arg
operator|&
name|SLJIT_MEM
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|arg
operator|&
literal|0xf
operator|)
condition|)
return|return
operator|(
name|next_arg
operator|&
name|SLJIT_MEM
operator|)
operator|&&
operator|(
operator|(
name|sljit_uw
operator|)
name|argw
operator|-
operator|(
name|sljit_uw
operator|)
name|next_argw
operator|<=
name|SIMM_MAX
operator|||
operator|(
name|sljit_uw
operator|)
name|next_argw
operator|-
operator|(
name|sljit_uw
operator|)
name|argw
operator|<=
name|SIMM_MAX
operator|)
return|;
if|if
condition|(
name|arg
operator|&
literal|0xf0
condition|)
return|return
operator|(
operator|(
name|arg
operator|&
literal|0xf0
operator|)
operator|==
operator|(
name|next_arg
operator|&
literal|0xf0
operator|)
operator|&&
operator|(
name|argw
operator|&
literal|0x3
operator|)
operator|==
operator|(
name|next_argw
operator|&
literal|0x3
operator|)
operator|)
return|;
if|if
condition|(
name|argw
operator|<=
name|SIMM_MAX
operator|&&
name|argw
operator|>=
name|SIMM_MIN
condition|)
block|{
if|if
condition|(
name|arg
operator|==
name|next_arg
operator|&&
operator|(
name|next_argw
operator|>=
name|SIMM_MAX
operator|&&
name|next_argw
operator|<=
name|SIMM_MIN
operator|)
condition|)
return|return
literal|1
return|;
block|}
if|if
condition|(
name|arg
operator|==
name|next_arg
operator|&&
operator|(
operator|(
name|sljit_uw
operator|)
name|argw
operator|-
operator|(
name|sljit_uw
operator|)
name|next_argw
operator|<=
name|SIMM_MAX
operator|||
operator|(
name|sljit_uw
operator|)
name|next_argw
operator|-
operator|(
name|sljit_uw
operator|)
name|argw
operator|<=
name|SIMM_MAX
operator|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_PPC_64
operator|&&
name|SLJIT_CONFIG_PPC_64
operator|)
end_if
begin_define
DECL|macro|ADJUST_CACHED_IMM
define|#
directive|define
name|ADJUST_CACHED_IMM
parameter_list|(
name|imm
parameter_list|)
define|\
value|if ((inst& ADDR_MODE2)&& (imm& 0x3)) { \
comment|/* Adjust cached value. Fortunately this is really a rare case */
value|\ 		compiler->cache_argw += imm& 0x3; \ 		FAIL_IF(push_inst(compiler, ADDI | D(TMP_REG3) | A(TMP_REG3) | (imm& 0x3))); \ 		imm&= ~0x3; \ 	}
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|ADJUST_CACHED_IMM
define|#
directive|define
name|ADJUST_CACHED_IMM
parameter_list|(
name|imm
parameter_list|)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/* Emit the necessary instructions. See can_cache above. */
end_comment
begin_function
DECL|function|getput_arg
specifier|static
name|sljit_si
name|getput_arg
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|inp_flags
parameter_list|,
name|sljit_si
name|reg
parameter_list|,
name|sljit_si
name|arg
parameter_list|,
name|sljit_sw
name|argw
parameter_list|,
name|sljit_si
name|next_arg
parameter_list|,
name|sljit_sw
name|next_argw
parameter_list|)
block|{
name|sljit_si
name|tmp_r
decl_stmt|;
name|sljit_ins
name|inst
decl_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|arg
operator|&
name|SLJIT_MEM
argument_list|)
expr_stmt|;
name|tmp_r
operator|=
operator|(
operator|(
name|inp_flags
operator|&
name|LOAD_DATA
operator|)
operator|&&
operator|(
operator|(
name|inp_flags
operator|)
operator|&
name|MEM_MASK
operator|)
operator|<=
name|GPR_REG
operator|)
condition|?
name|reg
else|:
name|TMP_REG1
expr_stmt|;
comment|/* Special case for "mov reg, [reg, ... ]". */
if|if
condition|(
operator|(
name|arg
operator|&
literal|0xf
operator|)
operator|==
name|tmp_r
condition|)
name|tmp_r
operator|=
name|TMP_REG1
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|arg
operator|&
literal|0xf
operator|)
condition|)
block|{
name|inst
operator|=
name|data_transfer_insts
index|[
operator|(
name|inp_flags
operator|&
operator|~
name|WRITE_BACK
operator|)
operator|&
name|MEM_MASK
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|compiler
operator|->
name|cache_arg
operator|&
name|SLJIT_IMM
operator|)
operator|&&
operator|(
operator|(
operator|(
name|sljit_uw
operator|)
name|argw
operator|-
operator|(
name|sljit_uw
operator|)
name|compiler
operator|->
name|cache_argw
operator|)
operator|<=
name|SIMM_MAX
operator|||
operator|(
operator|(
name|sljit_uw
operator|)
name|compiler
operator|->
name|cache_argw
operator|-
operator|(
name|sljit_uw
operator|)
name|argw
operator|)
operator|<=
name|SIMM_MAX
operator|)
condition|)
block|{
name|argw
operator|=
name|argw
operator|-
name|compiler
operator|->
name|cache_argw
expr_stmt|;
name|ADJUST_CACHED_IMM
argument_list|(
name|argw
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
operator|!
operator|(
name|inst
operator|&
name|UPDATE_REQ
operator|)
argument_list|)
expr_stmt|;
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|INST_CODE_AND_DST
argument_list|(
name|inst
argument_list|,
name|inp_flags
argument_list|,
name|reg
argument_list|)
operator||
name|A
argument_list|(
name|TMP_REG3
argument_list|)
operator||
name|IMM
argument_list|(
name|argw
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
operator|(
name|next_arg
operator|&
name|SLJIT_MEM
operator|)
operator|&&
operator|(
name|argw
operator|-
name|next_argw
operator|<=
name|SIMM_MAX
operator|||
name|next_argw
operator|-
name|argw
operator|<=
name|SIMM_MAX
operator|)
condition|)
block|{
name|SLJIT_ASSERT
argument_list|(
name|inp_flags
operator|&
name|LOAD_DATA
argument_list|)
expr_stmt|;
name|compiler
operator|->
name|cache_arg
operator|=
name|SLJIT_IMM
expr_stmt|;
name|compiler
operator|->
name|cache_argw
operator|=
name|argw
expr_stmt|;
name|tmp_r
operator|=
name|TMP_REG3
expr_stmt|;
block|}
name|FAIL_IF
argument_list|(
name|load_immediate
argument_list|(
name|compiler
argument_list|,
name|tmp_r
argument_list|,
name|argw
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|INST_CODE_AND_DST
argument_list|(
name|inst
argument_list|,
name|inp_flags
argument_list|,
name|reg
argument_list|)
operator||
name|A
argument_list|(
name|tmp_r
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|arg
operator|&
literal|0xf0
argument_list|)
condition|)
block|{
name|argw
operator|&=
literal|0x3
expr_stmt|;
comment|/* Otherwise getput_arg_fast would capture it. */
name|SLJIT_ASSERT
argument_list|(
name|argw
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|SLJIT_MEM
operator||
operator|(
name|arg
operator|&
literal|0xf0
operator|)
operator|)
operator|==
name|compiler
operator|->
name|cache_arg
operator|&&
name|argw
operator|==
name|compiler
operator|->
name|cache_argw
condition|)
name|tmp_r
operator|=
name|TMP_REG3
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|arg
operator|&
literal|0xf0
operator|)
operator|==
operator|(
name|next_arg
operator|&
literal|0xf0
operator|)
operator|&&
name|argw
operator|==
operator|(
name|next_argw
operator|&
literal|0x3
operator|)
condition|)
block|{
name|compiler
operator|->
name|cache_arg
operator|=
name|SLJIT_MEM
operator||
operator|(
name|arg
operator|&
literal|0xf0
operator|)
expr_stmt|;
name|compiler
operator|->
name|cache_argw
operator|=
name|argw
expr_stmt|;
name|tmp_r
operator|=
name|TMP_REG3
expr_stmt|;
block|}
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_PPC_32
operator|&&
name|SLJIT_CONFIG_PPC_32
operator|)
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|RLWINM
operator||
name|S
argument_list|(
operator|(
name|arg
operator|>>
literal|4
operator|)
operator|&
literal|0xf
argument_list|)
operator||
name|A
argument_list|(
name|tmp_r
argument_list|)
operator||
operator|(
name|argw
operator|<<
literal|11
operator|)
operator||
operator|(
operator|(
literal|31
operator|-
name|argw
operator|)
operator|<<
literal|1
operator|)
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|RLDI
argument_list|(
name|tmp_r
argument_list|,
operator|(
name|arg
operator|>>
literal|4
operator|)
operator|&
literal|0xf
argument_list|,
name|argw
argument_list|,
literal|63
operator|-
name|argw
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|inst
operator|=
name|data_transfer_insts
index|[
operator|(
name|inp_flags
operator||
name|INDEXED
operator|)
operator|&
name|MEM_MASK
index|]
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
operator|!
operator|(
name|inst
operator|&
operator|(
name|ADDR_MODE2
operator||
name|UPDATE_REQ
operator|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|INST_CODE_AND_DST
argument_list|(
name|inst
argument_list|,
name|inp_flags
argument_list|,
name|reg
argument_list|)
operator||
name|A
argument_list|(
name|arg
operator|&
literal|0xf
argument_list|)
operator||
name|B
argument_list|(
name|tmp_r
argument_list|)
argument_list|)
return|;
block|}
name|inst
operator|=
name|data_transfer_insts
index|[
name|inp_flags
operator|&
name|MEM_MASK
index|]
expr_stmt|;
if|if
condition|(
name|compiler
operator|->
name|cache_arg
operator|==
name|arg
operator|&&
operator|(
operator|(
name|sljit_uw
operator|)
name|argw
operator|-
operator|(
name|sljit_uw
operator|)
name|compiler
operator|->
name|cache_argw
operator|<=
name|SIMM_MAX
operator|||
operator|(
name|sljit_uw
operator|)
name|compiler
operator|->
name|cache_argw
operator|-
operator|(
name|sljit_uw
operator|)
name|argw
operator|<=
name|SIMM_MAX
operator|)
condition|)
block|{
name|SLJIT_ASSERT
argument_list|(
operator|!
operator|(
name|inp_flags
operator|&
name|WRITE_BACK
operator|)
argument_list|)
expr_stmt|;
name|argw
operator|=
name|argw
operator|-
name|compiler
operator|->
name|cache_argw
expr_stmt|;
name|ADJUST_CACHED_IMM
argument_list|(
name|argw
argument_list|)
expr_stmt|;
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|INST_CODE_AND_DST
argument_list|(
name|inst
argument_list|,
name|inp_flags
argument_list|,
name|reg
argument_list|)
operator||
name|A
argument_list|(
name|TMP_REG3
argument_list|)
operator||
name|IMM
argument_list|(
name|argw
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
operator|(
name|compiler
operator|->
name|cache_arg
operator|&
name|SLJIT_IMM
operator|)
operator|&&
name|compiler
operator|->
name|cache_argw
operator|==
name|argw
condition|)
block|{
name|inst
operator|=
name|data_transfer_insts
index|[
operator|(
name|inp_flags
operator||
name|INDEXED
operator|)
operator|&
name|MEM_MASK
index|]
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
operator|!
operator|(
name|inst
operator|&
operator|(
name|ADDR_MODE2
operator||
name|UPDATE_REQ
operator|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|INST_CODE_AND_DST
argument_list|(
name|inst
argument_list|,
name|inp_flags
argument_list|,
name|reg
argument_list|)
operator||
name|A
argument_list|(
name|arg
operator|&
literal|0xf
argument_list|)
operator||
name|B
argument_list|(
name|TMP_REG3
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|argw
operator|==
name|next_argw
operator|&&
operator|(
name|next_arg
operator|&
name|SLJIT_MEM
operator|)
condition|)
block|{
name|SLJIT_ASSERT
argument_list|(
name|inp_flags
operator|&
name|LOAD_DATA
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|load_immediate
argument_list|(
name|compiler
argument_list|,
name|TMP_REG3
argument_list|,
name|argw
argument_list|)
argument_list|)
expr_stmt|;
name|compiler
operator|->
name|cache_arg
operator|=
name|SLJIT_IMM
expr_stmt|;
name|compiler
operator|->
name|cache_argw
operator|=
name|argw
expr_stmt|;
name|inst
operator|=
name|data_transfer_insts
index|[
operator|(
name|inp_flags
operator||
name|INDEXED
operator|)
operator|&
name|MEM_MASK
index|]
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
operator|!
operator|(
name|inst
operator|&
operator|(
name|ADDR_MODE2
operator||
name|UPDATE_REQ
operator|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|INST_CODE_AND_DST
argument_list|(
name|inst
argument_list|,
name|inp_flags
argument_list|,
name|reg
argument_list|)
operator||
name|A
argument_list|(
name|arg
operator|&
literal|0xf
argument_list|)
operator||
name|B
argument_list|(
name|TMP_REG3
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|arg
operator|==
name|next_arg
operator|&&
operator|!
operator|(
name|inp_flags
operator|&
name|WRITE_BACK
operator|)
operator|&&
operator|(
operator|(
name|sljit_uw
operator|)
name|argw
operator|-
operator|(
name|sljit_uw
operator|)
name|next_argw
operator|<=
name|SIMM_MAX
operator|||
operator|(
name|sljit_uw
operator|)
name|next_argw
operator|-
operator|(
name|sljit_uw
operator|)
name|argw
operator|<=
name|SIMM_MAX
operator|)
condition|)
block|{
name|SLJIT_ASSERT
argument_list|(
name|inp_flags
operator|&
name|LOAD_DATA
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|load_immediate
argument_list|(
name|compiler
argument_list|,
name|TMP_REG3
argument_list|,
name|argw
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|ADD
operator||
name|D
argument_list|(
name|TMP_REG3
argument_list|)
operator||
name|A
argument_list|(
name|TMP_REG3
argument_list|)
operator||
name|B
argument_list|(
name|arg
operator|&
literal|0xf
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|compiler
operator|->
name|cache_arg
operator|=
name|arg
expr_stmt|;
name|compiler
operator|->
name|cache_argw
operator|=
name|argw
expr_stmt|;
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|INST_CODE_AND_DST
argument_list|(
name|inst
argument_list|,
name|inp_flags
argument_list|,
name|reg
argument_list|)
operator||
name|A
argument_list|(
name|TMP_REG3
argument_list|)
argument_list|)
return|;
block|}
comment|/* Get the indexed version instead of the normal one. */
name|inst
operator|=
name|data_transfer_insts
index|[
operator|(
name|inp_flags
operator||
name|INDEXED
operator|)
operator|&
name|MEM_MASK
index|]
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
operator|!
operator|(
name|inst
operator|&
operator|(
name|ADDR_MODE2
operator||
name|UPDATE_REQ
operator|)
operator|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|load_immediate
argument_list|(
name|compiler
argument_list|,
name|tmp_r
argument_list|,
name|argw
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|INST_CODE_AND_DST
argument_list|(
name|inst
argument_list|,
name|inp_flags
argument_list|,
name|reg
argument_list|)
operator||
name|A
argument_list|(
name|arg
operator|&
literal|0xf
argument_list|)
operator||
name|B
argument_list|(
name|tmp_r
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|emit_op_mem2
specifier|static
name|SLJIT_INLINE
name|sljit_si
name|emit_op_mem2
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|flags
parameter_list|,
name|sljit_si
name|reg
parameter_list|,
name|sljit_si
name|arg1
parameter_list|,
name|sljit_sw
name|arg1w
parameter_list|,
name|sljit_si
name|arg2
parameter_list|,
name|sljit_sw
name|arg2w
parameter_list|)
block|{
if|if
condition|(
name|getput_arg_fast
argument_list|(
name|compiler
argument_list|,
name|flags
argument_list|,
name|reg
argument_list|,
name|arg1
argument_list|,
name|arg1w
argument_list|)
condition|)
return|return
name|compiler
operator|->
name|error
return|;
return|return
name|getput_arg
argument_list|(
name|compiler
argument_list|,
name|flags
argument_list|,
name|reg
argument_list|,
name|arg1
argument_list|,
name|arg1w
argument_list|,
name|arg2
argument_list|,
name|arg2w
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|emit_op
specifier|static
name|sljit_si
name|emit_op
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|input_flags
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src1
parameter_list|,
name|sljit_sw
name|src1w
parameter_list|,
name|sljit_si
name|src2
parameter_list|,
name|sljit_sw
name|src2w
parameter_list|)
block|{
comment|/* arg1 goes to TMP_REG1 or src reg 	   arg2 goes to TMP_REG2, imm or src reg 	   TMP_REG3 can be used for caching 	   result goes to TMP_REG2, so put result can use TMP_REG1 and TMP_REG3. */
name|sljit_si
name|dst_r
decl_stmt|;
name|sljit_si
name|src1_r
decl_stmt|;
name|sljit_si
name|src2_r
decl_stmt|;
name|sljit_si
name|sugg_src2_r
init|=
name|TMP_REG2
decl_stmt|;
name|sljit_si
name|flags
init|=
name|input_flags
operator|&
operator|(
name|ALT_FORM1
operator||
name|ALT_FORM2
operator||
name|ALT_FORM3
operator||
name|ALT_FORM4
operator||
name|ALT_FORM5
operator||
name|ALT_FORM6
operator||
name|ALT_SIGN_EXT
operator||
name|ALT_SET_FLAGS
operator|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|input_flags
operator|&
name|ALT_KEEP_CACHE
operator|)
condition|)
block|{
name|compiler
operator|->
name|cache_arg
operator|=
literal|0
expr_stmt|;
name|compiler
operator|->
name|cache_argw
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Destination check. */
if|if
condition|(
name|SLJIT_UNLIKELY
argument_list|(
name|dst
operator|==
name|SLJIT_UNUSED
argument_list|)
condition|)
block|{
if|if
condition|(
name|op
operator|>=
name|SLJIT_MOV
operator|&&
name|op
operator|<=
name|SLJIT_MOVU_SI
operator|&&
operator|!
operator|(
name|src2
operator|&
name|SLJIT_MEM
operator|)
condition|)
return|return
name|SLJIT_SUCCESS
return|;
name|dst_r
operator|=
name|TMP_REG2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dst
operator|<=
name|ZERO_REG
condition|)
block|{
name|dst_r
operator|=
name|dst
expr_stmt|;
name|flags
operator||=
name|REG_DEST
expr_stmt|;
if|if
condition|(
name|op
operator|>=
name|SLJIT_MOV
operator|&&
name|op
operator|<=
name|SLJIT_MOVU_SI
condition|)
name|sugg_src2_r
operator|=
name|dst_r
expr_stmt|;
block|}
else|else
block|{
name|SLJIT_ASSERT
argument_list|(
name|dst
operator|&
name|SLJIT_MEM
argument_list|)
expr_stmt|;
if|if
condition|(
name|getput_arg_fast
argument_list|(
name|compiler
argument_list|,
name|input_flags
operator||
name|ARG_TEST
argument_list|,
name|TMP_REG2
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
condition|)
block|{
name|flags
operator||=
name|FAST_DEST
expr_stmt|;
name|dst_r
operator|=
name|TMP_REG2
expr_stmt|;
block|}
else|else
block|{
name|flags
operator||=
name|SLOW_DEST
expr_stmt|;
name|dst_r
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Source 1. */
if|if
condition|(
name|src1
operator|<=
name|ZERO_REG
condition|)
block|{
name|src1_r
operator|=
name|src1
expr_stmt|;
name|flags
operator||=
name|REG1_SOURCE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|src1
operator|&
name|SLJIT_IMM
condition|)
block|{
name|FAIL_IF
argument_list|(
name|load_immediate
argument_list|(
name|compiler
argument_list|,
name|TMP_REG1
argument_list|,
name|src1w
argument_list|)
argument_list|)
expr_stmt|;
name|src1_r
operator|=
name|TMP_REG1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|getput_arg_fast
argument_list|(
name|compiler
argument_list|,
name|input_flags
operator||
name|LOAD_DATA
argument_list|,
name|TMP_REG1
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
condition|)
block|{
name|FAIL_IF
argument_list|(
name|compiler
operator|->
name|error
argument_list|)
expr_stmt|;
name|src1_r
operator|=
name|TMP_REG1
expr_stmt|;
block|}
else|else
name|src1_r
operator|=
literal|0
expr_stmt|;
comment|/* Source 2. */
if|if
condition|(
name|src2
operator|<=
name|ZERO_REG
condition|)
block|{
name|src2_r
operator|=
name|src2
expr_stmt|;
name|flags
operator||=
name|REG2_SOURCE
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|REG_DEST
operator|)
operator|&&
name|op
operator|>=
name|SLJIT_MOV
operator|&&
name|op
operator|<=
name|SLJIT_MOVU_SI
condition|)
name|dst_r
operator|=
name|src2_r
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|src2
operator|&
name|SLJIT_IMM
condition|)
block|{
name|FAIL_IF
argument_list|(
name|load_immediate
argument_list|(
name|compiler
argument_list|,
name|sugg_src2_r
argument_list|,
name|src2w
argument_list|)
argument_list|)
expr_stmt|;
name|src2_r
operator|=
name|sugg_src2_r
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|getput_arg_fast
argument_list|(
name|compiler
argument_list|,
name|input_flags
operator||
name|LOAD_DATA
argument_list|,
name|sugg_src2_r
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
condition|)
block|{
name|FAIL_IF
argument_list|(
name|compiler
operator|->
name|error
argument_list|)
expr_stmt|;
name|src2_r
operator|=
name|sugg_src2_r
expr_stmt|;
block|}
else|else
name|src2_r
operator|=
literal|0
expr_stmt|;
comment|/* src1_r, src2_r and dst_r can be zero (=unprocessed). 	   All arguments are complex addressing modes, and it is a binary operator. */
if|if
condition|(
name|src1_r
operator|==
literal|0
operator|&&
name|src2_r
operator|==
literal|0
operator|&&
name|dst_r
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|can_cache
argument_list|(
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
operator|&&
name|can_cache
argument_list|(
name|src1
argument_list|,
name|src1w
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
condition|)
block|{
name|FAIL_IF
argument_list|(
name|getput_arg
argument_list|(
name|compiler
argument_list|,
name|input_flags
operator||
name|LOAD_DATA
argument_list|,
name|TMP_REG2
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|getput_arg
argument_list|(
name|compiler
argument_list|,
name|input_flags
operator||
name|LOAD_DATA
argument_list|,
name|TMP_REG1
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|FAIL_IF
argument_list|(
name|getput_arg
argument_list|(
name|compiler
argument_list|,
name|input_flags
operator||
name|LOAD_DATA
argument_list|,
name|TMP_REG1
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|getput_arg
argument_list|(
name|compiler
argument_list|,
name|input_flags
operator||
name|LOAD_DATA
argument_list|,
name|TMP_REG2
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|src1_r
operator|=
name|TMP_REG1
expr_stmt|;
name|src2_r
operator|=
name|TMP_REG2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|src1_r
operator|==
literal|0
operator|&&
name|src2_r
operator|==
literal|0
condition|)
block|{
name|FAIL_IF
argument_list|(
name|getput_arg
argument_list|(
name|compiler
argument_list|,
name|input_flags
operator||
name|LOAD_DATA
argument_list|,
name|TMP_REG1
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
argument_list|)
expr_stmt|;
name|src1_r
operator|=
name|TMP_REG1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|src1_r
operator|==
literal|0
operator|&&
name|dst_r
operator|==
literal|0
condition|)
block|{
name|FAIL_IF
argument_list|(
name|getput_arg
argument_list|(
name|compiler
argument_list|,
name|input_flags
operator||
name|LOAD_DATA
argument_list|,
name|TMP_REG1
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
argument_list|)
expr_stmt|;
name|src1_r
operator|=
name|TMP_REG1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|src2_r
operator|==
literal|0
operator|&&
name|dst_r
operator|==
literal|0
condition|)
block|{
name|FAIL_IF
argument_list|(
name|getput_arg
argument_list|(
name|compiler
argument_list|,
name|input_flags
operator||
name|LOAD_DATA
argument_list|,
name|sugg_src2_r
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
argument_list|)
expr_stmt|;
name|src2_r
operator|=
name|sugg_src2_r
expr_stmt|;
block|}
if|if
condition|(
name|dst_r
operator|==
literal|0
condition|)
name|dst_r
operator|=
name|TMP_REG2
expr_stmt|;
if|if
condition|(
name|src1_r
operator|==
literal|0
condition|)
block|{
name|FAIL_IF
argument_list|(
name|getput_arg
argument_list|(
name|compiler
argument_list|,
name|input_flags
operator||
name|LOAD_DATA
argument_list|,
name|TMP_REG1
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|src1_r
operator|=
name|TMP_REG1
expr_stmt|;
block|}
if|if
condition|(
name|src2_r
operator|==
literal|0
condition|)
block|{
name|FAIL_IF
argument_list|(
name|getput_arg
argument_list|(
name|compiler
argument_list|,
name|input_flags
operator||
name|LOAD_DATA
argument_list|,
name|sugg_src2_r
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|src2_r
operator|=
name|sugg_src2_r
expr_stmt|;
block|}
name|FAIL_IF
argument_list|(
name|emit_single_op
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|flags
argument_list|,
name|dst_r
argument_list|,
name|src1_r
argument_list|,
name|src2_r
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
operator|(
name|FAST_DEST
operator||
name|SLOW_DEST
operator|)
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|FAST_DEST
condition|)
name|FAIL_IF
argument_list|(
name|getput_arg_fast
argument_list|(
name|compiler
argument_list|,
name|input_flags
argument_list|,
name|dst_r
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|FAIL_IF
argument_list|(
name|getput_arg
argument_list|(
name|compiler
argument_list|,
name|input_flags
argument_list|,
name|dst_r
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_op0
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_op0
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|)
block|{
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|check_sljit_emit_op0
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|SLJIT_BREAKPOINT
case|:
case|case
name|SLJIT_NOP
case|:
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|NOP
argument_list|)
return|;
break|break;
case|case
name|SLJIT_UMUL
case|:
case|case
name|SLJIT_SMUL
case|:
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|OR
operator||
name|S
argument_list|(
name|SLJIT_SCRATCH_REG1
argument_list|)
operator||
name|A
argument_list|(
name|TMP_REG1
argument_list|)
operator||
name|B
argument_list|(
name|SLJIT_SCRATCH_REG1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_PPC_64
operator|&&
name|SLJIT_CONFIG_PPC_64
operator|)
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|MULLD
operator||
name|D
argument_list|(
name|SLJIT_SCRATCH_REG1
argument_list|)
operator||
name|A
argument_list|(
name|TMP_REG1
argument_list|)
operator||
name|B
argument_list|(
name|SLJIT_SCRATCH_REG2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
operator|(
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
operator|==
name|SLJIT_UMUL
condition|?
name|MULHDU
else|:
name|MULHD
operator|)
operator||
name|D
argument_list|(
name|SLJIT_SCRATCH_REG2
argument_list|)
operator||
name|A
argument_list|(
name|TMP_REG1
argument_list|)
operator||
name|B
argument_list|(
name|SLJIT_SCRATCH_REG2
argument_list|)
argument_list|)
return|;
else|#
directive|else
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|MULLW
operator||
name|D
argument_list|(
name|SLJIT_SCRATCH_REG1
argument_list|)
operator||
name|A
argument_list|(
name|TMP_REG1
argument_list|)
operator||
name|B
argument_list|(
name|SLJIT_SCRATCH_REG2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
operator|(
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
operator|==
name|SLJIT_UMUL
condition|?
name|MULHWU
else|:
name|MULHW
operator|)
operator||
name|D
argument_list|(
name|SLJIT_SCRATCH_REG2
argument_list|)
operator||
name|A
argument_list|(
name|TMP_REG1
argument_list|)
operator||
name|B
argument_list|(
name|SLJIT_SCRATCH_REG2
argument_list|)
argument_list|)
return|;
endif|#
directive|endif
case|case
name|SLJIT_UDIV
case|:
case|case
name|SLJIT_SDIV
case|:
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|OR
operator||
name|S
argument_list|(
name|SLJIT_SCRATCH_REG1
argument_list|)
operator||
name|A
argument_list|(
name|TMP_REG1
argument_list|)
operator||
name|B
argument_list|(
name|SLJIT_SCRATCH_REG1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_PPC_64
operator|&&
name|SLJIT_CONFIG_PPC_64
operator|)
if|if
condition|(
name|op
operator|&
name|SLJIT_INT_OP
condition|)
block|{
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
operator|(
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
operator|==
name|SLJIT_UDIV
condition|?
name|DIVWU
else|:
name|DIVW
operator|)
operator||
name|D
argument_list|(
name|SLJIT_SCRATCH_REG1
argument_list|)
operator||
name|A
argument_list|(
name|TMP_REG1
argument_list|)
operator||
name|B
argument_list|(
name|SLJIT_SCRATCH_REG2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|MULLW
operator||
name|D
argument_list|(
name|SLJIT_SCRATCH_REG2
argument_list|)
operator||
name|A
argument_list|(
name|SLJIT_SCRATCH_REG1
argument_list|)
operator||
name|B
argument_list|(
name|SLJIT_SCRATCH_REG2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|SUBF
operator||
name|D
argument_list|(
name|SLJIT_SCRATCH_REG2
argument_list|)
operator||
name|A
argument_list|(
name|SLJIT_SCRATCH_REG2
argument_list|)
operator||
name|B
argument_list|(
name|TMP_REG1
argument_list|)
argument_list|)
return|;
block|}
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
operator|(
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
operator|==
name|SLJIT_UDIV
condition|?
name|DIVDU
else|:
name|DIVD
operator|)
operator||
name|D
argument_list|(
name|SLJIT_SCRATCH_REG1
argument_list|)
operator||
name|A
argument_list|(
name|TMP_REG1
argument_list|)
operator||
name|B
argument_list|(
name|SLJIT_SCRATCH_REG2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|MULLD
operator||
name|D
argument_list|(
name|SLJIT_SCRATCH_REG2
argument_list|)
operator||
name|A
argument_list|(
name|SLJIT_SCRATCH_REG1
argument_list|)
operator||
name|B
argument_list|(
name|SLJIT_SCRATCH_REG2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|SUBF
operator||
name|D
argument_list|(
name|SLJIT_SCRATCH_REG2
argument_list|)
operator||
name|A
argument_list|(
name|SLJIT_SCRATCH_REG2
argument_list|)
operator||
name|B
argument_list|(
name|TMP_REG1
argument_list|)
argument_list|)
return|;
else|#
directive|else
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
operator|(
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
operator|==
name|SLJIT_UDIV
condition|?
name|DIVWU
else|:
name|DIVW
operator|)
operator||
name|D
argument_list|(
name|SLJIT_SCRATCH_REG1
argument_list|)
operator||
name|A
argument_list|(
name|TMP_REG1
argument_list|)
operator||
name|B
argument_list|(
name|SLJIT_SCRATCH_REG2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|MULLW
operator||
name|D
argument_list|(
name|SLJIT_SCRATCH_REG2
argument_list|)
operator||
name|A
argument_list|(
name|SLJIT_SCRATCH_REG1
argument_list|)
operator||
name|B
argument_list|(
name|SLJIT_SCRATCH_REG2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|SUBF
operator||
name|D
argument_list|(
name|SLJIT_SCRATCH_REG2
argument_list|)
operator||
name|A
argument_list|(
name|SLJIT_SCRATCH_REG2
argument_list|)
operator||
name|B
argument_list|(
name|TMP_REG1
argument_list|)
argument_list|)
return|;
endif|#
directive|endif
block|}
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_define
DECL|macro|EMIT_MOV
define|#
directive|define
name|EMIT_MOV
parameter_list|(
name|type
parameter_list|,
name|type_flags
parameter_list|,
name|type_cast
parameter_list|)
define|\
value|emit_op(compiler, (src& SLJIT_IMM) ? SLJIT_MOV : type, flags | (type_flags), dst, dstw, TMP_REG1, 0, src, (src& SLJIT_IMM) ? type_cast srcw : srcw)
end_define
begin_function
DECL|function|sljit_emit_op1
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_op1
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|)
block|{
name|sljit_si
name|flags
init|=
name|GET_FLAGS
argument_list|(
name|op
argument_list|)
condition|?
name|ALT_SET_FLAGS
else|:
literal|0
decl_stmt|;
name|sljit_si
name|op_flags
init|=
name|GET_ALL_FLAGS
argument_list|(
name|op
argument_list|)
decl_stmt|;
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|check_sljit_emit_op1
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|ADJUST_LOCAL_OFFSET
argument_list|(
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|ADJUST_LOCAL_OFFSET
argument_list|(
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|op
operator|=
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|src
operator|&
name|SLJIT_IMM
operator|)
operator|&&
name|srcw
operator|==
literal|0
condition|)
name|src
operator|=
name|ZERO_REG
expr_stmt|;
if|if
condition|(
name|op_flags
operator|&
name|SLJIT_SET_O
condition|)
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|MTXER
operator||
name|S
argument_list|(
name|ZERO_REG
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|op_flags
operator|&
name|SLJIT_INT_OP
condition|)
block|{
if|if
condition|(
name|op
operator|>=
name|SLJIT_MOV
operator|&&
name|op
operator|<=
name|SLJIT_MOVU_P
condition|)
block|{
if|if
condition|(
name|src
operator|<=
name|ZERO_REG
operator|&&
name|src
operator|==
name|dst
condition|)
block|{
if|if
condition|(
operator|!
name|TYPE_CAST_NEEDED
argument_list|(
name|op
argument_list|)
condition|)
return|return
name|SLJIT_SUCCESS
return|;
block|}
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_PPC_64
operator|&&
name|SLJIT_CONFIG_PPC_64
operator|)
if|if
condition|(
name|op
operator|==
name|SLJIT_MOV_SI
operator|&&
operator|(
name|src
operator|&
name|SLJIT_MEM
operator|)
condition|)
name|op
operator|=
name|SLJIT_MOV_UI
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|SLJIT_MOVU_SI
operator|&&
operator|(
name|src
operator|&
name|SLJIT_MEM
operator|)
condition|)
name|op
operator|=
name|SLJIT_MOVU_UI
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|SLJIT_MOV_UI
operator|&&
operator|(
name|src
operator|&
name|SLJIT_IMM
operator|)
condition|)
name|op
operator|=
name|SLJIT_MOV_SI
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|SLJIT_MOVU_UI
operator|&&
operator|(
name|src
operator|&
name|SLJIT_IMM
operator|)
condition|)
name|op
operator|=
name|SLJIT_MOVU_SI
expr_stmt|;
endif|#
directive|endif
block|}
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_PPC_64
operator|&&
name|SLJIT_CONFIG_PPC_64
operator|)
else|else
block|{
comment|/* Most operations expect sign extended arguments. */
name|flags
operator||=
name|INT_DATA
operator||
name|SIGNED_DATA
expr_stmt|;
if|if
condition|(
name|src
operator|&
name|SLJIT_IMM
condition|)
name|srcw
operator|=
operator|(
name|sljit_si
operator|)
name|srcw
expr_stmt|;
block|}
endif|#
directive|endif
block|}
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|SLJIT_MOV
case|:
case|case
name|SLJIT_MOV_P
case|:
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_PPC_32
operator|&&
name|SLJIT_CONFIG_PPC_32
operator|)
case|case
name|SLJIT_MOV_UI
case|:
case|case
name|SLJIT_MOV_SI
case|:
endif|#
directive|endif
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MOV
argument_list|,
name|flags
operator||
name|WORD_DATA
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REG1
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
return|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_PPC_64
operator|&&
name|SLJIT_CONFIG_PPC_64
operator|)
case|case
name|SLJIT_MOV_UI
case|:
return|return
name|EMIT_MOV
argument_list|(
name|SLJIT_MOV_UI
argument_list|,
name|INT_DATA
argument_list|,
operator|(
name|sljit_ui
operator|)
argument_list|)
return|;
case|case
name|SLJIT_MOV_SI
case|:
return|return
name|EMIT_MOV
argument_list|(
name|SLJIT_MOV_SI
argument_list|,
name|INT_DATA
operator||
name|SIGNED_DATA
argument_list|,
operator|(
name|sljit_si
operator|)
argument_list|)
return|;
endif|#
directive|endif
case|case
name|SLJIT_MOV_UB
case|:
return|return
name|EMIT_MOV
argument_list|(
name|SLJIT_MOV_UB
argument_list|,
name|BYTE_DATA
argument_list|,
operator|(
name|sljit_ub
operator|)
argument_list|)
return|;
case|case
name|SLJIT_MOV_SB
case|:
return|return
name|EMIT_MOV
argument_list|(
name|SLJIT_MOV_SB
argument_list|,
name|BYTE_DATA
operator||
name|SIGNED_DATA
argument_list|,
operator|(
name|sljit_sb
operator|)
argument_list|)
return|;
case|case
name|SLJIT_MOV_UH
case|:
return|return
name|EMIT_MOV
argument_list|(
name|SLJIT_MOV_UH
argument_list|,
name|HALF_DATA
argument_list|,
operator|(
name|sljit_uh
operator|)
argument_list|)
return|;
case|case
name|SLJIT_MOV_SH
case|:
return|return
name|EMIT_MOV
argument_list|(
name|SLJIT_MOV_SH
argument_list|,
name|HALF_DATA
operator||
name|SIGNED_DATA
argument_list|,
operator|(
name|sljit_sh
operator|)
argument_list|)
return|;
case|case
name|SLJIT_MOVU
case|:
case|case
name|SLJIT_MOVU_P
case|:
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_PPC_32
operator|&&
name|SLJIT_CONFIG_PPC_32
operator|)
case|case
name|SLJIT_MOVU_UI
case|:
case|case
name|SLJIT_MOVU_SI
case|:
endif|#
directive|endif
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MOV
argument_list|,
name|flags
operator||
name|WORD_DATA
operator||
name|WRITE_BACK
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REG1
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
return|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_PPC_64
operator|&&
name|SLJIT_CONFIG_PPC_64
operator|)
case|case
name|SLJIT_MOVU_UI
case|:
return|return
name|EMIT_MOV
argument_list|(
name|SLJIT_MOV_UI
argument_list|,
name|INT_DATA
operator||
name|WRITE_BACK
argument_list|,
operator|(
name|sljit_ui
operator|)
argument_list|)
return|;
case|case
name|SLJIT_MOVU_SI
case|:
return|return
name|EMIT_MOV
argument_list|(
name|SLJIT_MOV_SI
argument_list|,
name|INT_DATA
operator||
name|SIGNED_DATA
operator||
name|WRITE_BACK
argument_list|,
operator|(
name|sljit_si
operator|)
argument_list|)
return|;
endif|#
directive|endif
case|case
name|SLJIT_MOVU_UB
case|:
return|return
name|EMIT_MOV
argument_list|(
name|SLJIT_MOV_UB
argument_list|,
name|BYTE_DATA
operator||
name|WRITE_BACK
argument_list|,
operator|(
name|sljit_ub
operator|)
argument_list|)
return|;
case|case
name|SLJIT_MOVU_SB
case|:
return|return
name|EMIT_MOV
argument_list|(
name|SLJIT_MOV_SB
argument_list|,
name|BYTE_DATA
operator||
name|SIGNED_DATA
operator||
name|WRITE_BACK
argument_list|,
operator|(
name|sljit_sb
operator|)
argument_list|)
return|;
case|case
name|SLJIT_MOVU_UH
case|:
return|return
name|EMIT_MOV
argument_list|(
name|SLJIT_MOV_UH
argument_list|,
name|HALF_DATA
operator||
name|WRITE_BACK
argument_list|,
operator|(
name|sljit_uh
operator|)
argument_list|)
return|;
case|case
name|SLJIT_MOVU_SH
case|:
return|return
name|EMIT_MOV
argument_list|(
name|SLJIT_MOV_SH
argument_list|,
name|HALF_DATA
operator||
name|SIGNED_DATA
operator||
name|WRITE_BACK
argument_list|,
operator|(
name|sljit_sh
operator|)
argument_list|)
return|;
case|case
name|SLJIT_NOT
case|:
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_NOT
argument_list|,
name|flags
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REG1
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
return|;
case|case
name|SLJIT_NEG
case|:
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_NEG
argument_list|,
name|flags
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REG1
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
return|;
case|case
name|SLJIT_CLZ
case|:
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_PPC_64
operator|&&
name|SLJIT_CONFIG_PPC_64
operator|)
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_CLZ
argument_list|,
name|flags
operator||
operator|(
operator|!
operator|(
name|op_flags
operator|&
name|SLJIT_INT_OP
operator|)
condition|?
literal|0
else|:
name|ALT_FORM1
operator|)
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REG1
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
return|;
else|#
directive|else
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_CLZ
argument_list|,
name|flags
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REG1
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
return|;
endif|#
directive|endif
block|}
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_undef
DECL|macro|EMIT_MOV
undef|#
directive|undef
name|EMIT_MOV
end_undef
begin_define
DECL|macro|TEST_SL_IMM
define|#
directive|define
name|TEST_SL_IMM
parameter_list|(
name|src
parameter_list|,
name|srcw
parameter_list|)
define|\
value|(((src)& SLJIT_IMM)&& (srcw)<= SIMM_MAX&& (srcw)>= SIMM_MIN)
end_define
begin_define
DECL|macro|TEST_UL_IMM
define|#
directive|define
name|TEST_UL_IMM
parameter_list|(
name|src
parameter_list|,
name|srcw
parameter_list|)
define|\
value|(((src)& SLJIT_IMM)&& !((srcw)& ~0xffff))
end_define
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_PPC_64
operator|&&
name|SLJIT_CONFIG_PPC_64
operator|)
end_if
begin_define
DECL|macro|TEST_SH_IMM
define|#
directive|define
name|TEST_SH_IMM
parameter_list|(
name|src
parameter_list|,
name|srcw
parameter_list|)
define|\
value|(((src)& SLJIT_IMM)&& !((srcw)& 0xffff)&& (srcw)<= SLJIT_W(0x7fffffff)&& (srcw)>= SLJIT_W(-0x80000000))
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|TEST_SH_IMM
define|#
directive|define
name|TEST_SH_IMM
parameter_list|(
name|src
parameter_list|,
name|srcw
parameter_list|)
define|\
value|(((src)& SLJIT_IMM)&& !((srcw)& 0xffff))
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|TEST_UH_IMM
define|#
directive|define
name|TEST_UH_IMM
parameter_list|(
name|src
parameter_list|,
name|srcw
parameter_list|)
define|\
value|(((src)& SLJIT_IMM)&& !((srcw)& ~0xffff0000))
end_define
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_PPC_64
operator|&&
name|SLJIT_CONFIG_PPC_64
operator|)
end_if
begin_define
DECL|macro|TEST_ADD_IMM
define|#
directive|define
name|TEST_ADD_IMM
parameter_list|(
name|src
parameter_list|,
name|srcw
parameter_list|)
define|\
value|(((src)& SLJIT_IMM)&& (srcw)<= SLJIT_W(0x7fff7fff)&& (srcw)>= SLJIT_W(-0x80000000))
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|TEST_ADD_IMM
define|#
directive|define
name|TEST_ADD_IMM
parameter_list|(
name|src
parameter_list|,
name|srcw
parameter_list|)
define|\
value|((src)& SLJIT_IMM)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_PPC_64
operator|&&
name|SLJIT_CONFIG_PPC_64
operator|)
end_if
begin_define
DECL|macro|TEST_UI_IMM
define|#
directive|define
name|TEST_UI_IMM
parameter_list|(
name|src
parameter_list|,
name|srcw
parameter_list|)
define|\
value|(((src)& SLJIT_IMM)&& !((srcw)& ~0xffffffff))
end_define
begin_else
else|#
directive|else
end_else
begin_define
DECL|macro|TEST_UI_IMM
define|#
directive|define
name|TEST_UI_IMM
parameter_list|(
name|src
parameter_list|,
name|srcw
parameter_list|)
define|\
value|((src)& SLJIT_IMM)
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|sljit_emit_op2
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_op2
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src1
parameter_list|,
name|sljit_sw
name|src1w
parameter_list|,
name|sljit_si
name|src2
parameter_list|,
name|sljit_sw
name|src2w
parameter_list|)
block|{
name|sljit_si
name|flags
init|=
name|GET_FLAGS
argument_list|(
name|op
argument_list|)
condition|?
name|ALT_SET_FLAGS
else|:
literal|0
decl_stmt|;
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|check_sljit_emit_op2
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
name|ADJUST_LOCAL_OFFSET
argument_list|(
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|ADJUST_LOCAL_OFFSET
argument_list|(
name|src1
argument_list|,
name|src1w
argument_list|)
expr_stmt|;
name|ADJUST_LOCAL_OFFSET
argument_list|(
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|src1
operator|&
name|SLJIT_IMM
operator|)
operator|&&
name|src1w
operator|==
literal|0
condition|)
name|src1
operator|=
name|ZERO_REG
expr_stmt|;
if|if
condition|(
operator|(
name|src2
operator|&
name|SLJIT_IMM
operator|)
operator|&&
name|src2w
operator|==
literal|0
condition|)
name|src2
operator|=
name|ZERO_REG
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_PPC_64
operator|&&
name|SLJIT_CONFIG_PPC_64
operator|)
if|if
condition|(
name|op
operator|&
name|SLJIT_INT_OP
condition|)
block|{
comment|/* Most operations expect sign extended arguments. */
name|flags
operator||=
name|INT_DATA
operator||
name|SIGNED_DATA
expr_stmt|;
if|if
condition|(
name|src1
operator|&
name|SLJIT_IMM
condition|)
name|src1w
operator|=
call|(
name|sljit_si
call|)
argument_list|(
name|src1w
argument_list|)
expr_stmt|;
if|if
condition|(
name|src2
operator|&
name|SLJIT_IMM
condition|)
name|src2w
operator|=
call|(
name|sljit_si
call|)
argument_list|(
name|src2w
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_FLAGS
argument_list|(
name|op
argument_list|)
condition|)
name|flags
operator||=
name|ALT_SIGN_EXT
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|op
operator|&
name|SLJIT_SET_O
condition|)
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|MTXER
operator||
name|S
argument_list|(
name|ZERO_REG
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|src2
operator|==
name|TMP_REG2
condition|)
name|flags
operator||=
name|ALT_KEEP_CACHE
expr_stmt|;
switch|switch
condition|(
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|SLJIT_ADD
case|:
if|if
condition|(
operator|!
name|GET_FLAGS
argument_list|(
name|op
argument_list|)
operator|&&
operator|(
operator|(
name|src1
operator||
name|src2
operator|)
operator|&
name|SLJIT_IMM
operator|)
condition|)
block|{
if|if
condition|(
name|TEST_SL_IMM
argument_list|(
name|src2
argument_list|,
name|src2w
argument_list|)
condition|)
block|{
name|compiler
operator|->
name|imm
operator|=
name|src2w
operator|&
literal|0xffff
expr_stmt|;
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_ADD
argument_list|,
name|flags
operator||
name|ALT_FORM1
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|TMP_REG2
argument_list|,
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|TEST_SL_IMM
argument_list|(
name|src1
argument_list|,
name|src1w
argument_list|)
condition|)
block|{
name|compiler
operator|->
name|imm
operator|=
name|src1w
operator|&
literal|0xffff
expr_stmt|;
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_ADD
argument_list|,
name|flags
operator||
name|ALT_FORM1
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|,
name|TMP_REG2
argument_list|,
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|TEST_SH_IMM
argument_list|(
name|src2
argument_list|,
name|src2w
argument_list|)
condition|)
block|{
name|compiler
operator|->
name|imm
operator|=
operator|(
name|src2w
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
expr_stmt|;
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_ADD
argument_list|,
name|flags
operator||
name|ALT_FORM2
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|TMP_REG2
argument_list|,
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|TEST_SH_IMM
argument_list|(
name|src1
argument_list|,
name|src1w
argument_list|)
condition|)
block|{
name|compiler
operator|->
name|imm
operator|=
operator|(
name|src1w
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
expr_stmt|;
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_ADD
argument_list|,
name|flags
operator||
name|ALT_FORM2
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|,
name|TMP_REG2
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/* Range between -1 and -32768 is covered above. */
if|if
condition|(
name|TEST_ADD_IMM
argument_list|(
name|src2
argument_list|,
name|src2w
argument_list|)
condition|)
block|{
name|compiler
operator|->
name|imm
operator|=
name|src2w
operator|&
literal|0xffffffff
expr_stmt|;
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_ADD
argument_list|,
name|flags
operator||
name|ALT_FORM4
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|TMP_REG2
argument_list|,
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|TEST_ADD_IMM
argument_list|(
name|src1
argument_list|,
name|src1w
argument_list|)
condition|)
block|{
name|compiler
operator|->
name|imm
operator|=
name|src1w
operator|&
literal|0xffffffff
expr_stmt|;
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_ADD
argument_list|,
name|flags
operator||
name|ALT_FORM4
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|,
name|TMP_REG2
argument_list|,
literal|0
argument_list|)
return|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|GET_FLAGS
argument_list|(
name|op
argument_list|)
operator|&
operator|(
name|SLJIT_SET_E
operator||
name|SLJIT_SET_O
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|TEST_SL_IMM
argument_list|(
name|src2
argument_list|,
name|src2w
argument_list|)
condition|)
block|{
name|compiler
operator|->
name|imm
operator|=
name|src2w
operator|&
literal|0xffff
expr_stmt|;
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_ADD
argument_list|,
name|flags
operator||
name|ALT_FORM3
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|TMP_REG2
argument_list|,
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|TEST_SL_IMM
argument_list|(
name|src1
argument_list|,
name|src1w
argument_list|)
condition|)
block|{
name|compiler
operator|->
name|imm
operator|=
name|src1w
operator|&
literal|0xffff
expr_stmt|;
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_ADD
argument_list|,
name|flags
operator||
name|ALT_FORM3
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|,
name|TMP_REG2
argument_list|,
literal|0
argument_list|)
return|;
block|}
block|}
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_ADD
argument_list|,
name|flags
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
return|;
case|case
name|SLJIT_ADDC
case|:
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_ADDC
argument_list|,
name|flags
operator||
operator|(
operator|!
operator|(
name|op
operator|&
name|SLJIT_KEEP_FLAGS
operator|)
condition|?
literal|0
else|:
name|ALT_FORM1
operator|)
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
return|;
case|case
name|SLJIT_SUB
case|:
if|if
condition|(
operator|!
name|GET_FLAGS
argument_list|(
name|op
argument_list|)
operator|&&
operator|(
operator|(
name|src1
operator||
name|src2
operator|)
operator|&
name|SLJIT_IMM
operator|)
condition|)
block|{
if|if
condition|(
name|TEST_SL_IMM
argument_list|(
name|src2
argument_list|,
operator|-
name|src2w
argument_list|)
condition|)
block|{
name|compiler
operator|->
name|imm
operator|=
operator|(
operator|-
name|src2w
operator|)
operator|&
literal|0xffff
expr_stmt|;
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_ADD
argument_list|,
name|flags
operator||
name|ALT_FORM1
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|TMP_REG2
argument_list|,
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|TEST_SL_IMM
argument_list|(
name|src1
argument_list|,
name|src1w
argument_list|)
condition|)
block|{
name|compiler
operator|->
name|imm
operator|=
name|src1w
operator|&
literal|0xffff
expr_stmt|;
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_SUB
argument_list|,
name|flags
operator||
name|ALT_FORM1
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|,
name|TMP_REG2
argument_list|,
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|TEST_SH_IMM
argument_list|(
name|src2
argument_list|,
operator|-
name|src2w
argument_list|)
condition|)
block|{
name|compiler
operator|->
name|imm
operator|=
operator|(
operator|(
operator|-
name|src2w
operator|)
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
expr_stmt|;
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_ADD
argument_list|,
name|flags
operator||
name|ALT_FORM2
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|TMP_REG2
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/* Range between -1 and -32768 is covered above. */
if|if
condition|(
name|TEST_ADD_IMM
argument_list|(
name|src2
argument_list|,
operator|-
name|src2w
argument_list|)
condition|)
block|{
name|compiler
operator|->
name|imm
operator|=
operator|-
name|src2w
operator|&
literal|0xffffffff
expr_stmt|;
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_ADD
argument_list|,
name|flags
operator||
name|ALT_FORM4
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|TMP_REG2
argument_list|,
literal|0
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|dst
operator|==
name|SLJIT_UNUSED
operator|&&
operator|(
name|op
operator|&
operator|(
name|SLJIT_SET_E
operator||
name|SLJIT_SET_S
operator||
name|SLJIT_SET_U
operator|)
operator|)
operator|&&
operator|!
operator|(
name|op
operator|&
operator|(
name|SLJIT_SET_O
operator||
name|SLJIT_SET_C
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|op
operator|&
name|SLJIT_SET_U
operator|)
condition|)
block|{
comment|/* We know ALT_SIGN_EXT is set if it is an SLJIT_INT_OP on 64 bit systems. */
if|if
condition|(
name|TEST_SL_IMM
argument_list|(
name|src2
argument_list|,
name|src2w
argument_list|)
condition|)
block|{
name|compiler
operator|->
name|imm
operator|=
name|src2w
operator|&
literal|0xffff
expr_stmt|;
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_SUB
argument_list|,
name|flags
operator||
name|ALT_FORM2
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|TMP_REG2
argument_list|,
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|GET_FLAGS
argument_list|(
name|op
argument_list|)
operator|==
name|SLJIT_SET_E
operator|&&
name|TEST_SL_IMM
argument_list|(
name|src1
argument_list|,
name|src1w
argument_list|)
condition|)
block|{
name|compiler
operator|->
name|imm
operator|=
name|src1w
operator|&
literal|0xffff
expr_stmt|;
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_SUB
argument_list|,
name|flags
operator||
name|ALT_FORM2
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|,
name|TMP_REG2
argument_list|,
literal|0
argument_list|)
return|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|op
operator|&
operator|(
name|SLJIT_SET_E
operator||
name|SLJIT_SET_S
operator|)
operator|)
condition|)
block|{
comment|/* We know ALT_SIGN_EXT is set if it is an SLJIT_INT_OP on 64 bit systems. */
if|if
condition|(
name|TEST_UL_IMM
argument_list|(
name|src2
argument_list|,
name|src2w
argument_list|)
condition|)
block|{
name|compiler
operator|->
name|imm
operator|=
name|src2w
operator|&
literal|0xffff
expr_stmt|;
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_SUB
argument_list|,
name|flags
operator||
name|ALT_FORM3
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|TMP_REG2
argument_list|,
literal|0
argument_list|)
return|;
block|}
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_SUB
argument_list|,
name|flags
operator||
name|ALT_FORM4
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
return|;
block|}
if|if
condition|(
operator|(
name|src2
operator|&
name|SLJIT_IMM
operator|)
operator|&&
name|src2w
operator|>=
literal|0
operator|&&
name|src2w
operator|<=
literal|0x7fff
condition|)
block|{
name|compiler
operator|->
name|imm
operator|=
name|src2w
expr_stmt|;
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_SUB
argument_list|,
name|flags
operator||
name|ALT_FORM2
operator||
name|ALT_FORM3
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|TMP_REG2
argument_list|,
literal|0
argument_list|)
return|;
block|}
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_SUB
argument_list|,
name|flags
operator||
operator|(
operator|(
name|op
operator|&
name|SLJIT_SET_U
operator|)
condition|?
name|ALT_FORM4
else|:
literal|0
operator|)
operator||
operator|(
operator|(
name|op
operator|&
operator|(
name|SLJIT_SET_E
operator||
name|SLJIT_SET_S
operator|)
operator|)
condition|?
name|ALT_FORM5
else|:
literal|0
operator|)
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|op
operator|&
operator|(
name|SLJIT_SET_E
operator||
name|SLJIT_SET_S
operator||
name|SLJIT_SET_U
operator||
name|SLJIT_SET_O
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|TEST_SL_IMM
argument_list|(
name|src2
argument_list|,
operator|-
name|src2w
argument_list|)
condition|)
block|{
name|compiler
operator|->
name|imm
operator|=
operator|(
operator|-
name|src2w
operator|)
operator|&
literal|0xffff
expr_stmt|;
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_ADD
argument_list|,
name|flags
operator||
name|ALT_FORM3
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|TMP_REG2
argument_list|,
literal|0
argument_list|)
return|;
block|}
block|}
comment|/* We know ALT_SIGN_EXT is set if it is an SLJIT_INT_OP on 64 bit systems. */
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_SUB
argument_list|,
name|flags
operator||
operator|(
operator|!
operator|(
name|op
operator|&
name|SLJIT_SET_U
operator|)
condition|?
literal|0
else|:
name|ALT_FORM6
operator|)
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
return|;
case|case
name|SLJIT_SUBC
case|:
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_SUBC
argument_list|,
name|flags
operator||
operator|(
operator|!
operator|(
name|op
operator|&
name|SLJIT_KEEP_FLAGS
operator|)
condition|?
literal|0
else|:
name|ALT_FORM1
operator|)
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
return|;
case|case
name|SLJIT_MUL
case|:
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_PPC_64
operator|&&
name|SLJIT_CONFIG_PPC_64
operator|)
if|if
condition|(
name|op
operator|&
name|SLJIT_INT_OP
condition|)
name|flags
operator||=
name|ALT_FORM2
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|GET_FLAGS
argument_list|(
name|op
argument_list|)
condition|)
block|{
if|if
condition|(
name|TEST_SL_IMM
argument_list|(
name|src2
argument_list|,
name|src2w
argument_list|)
condition|)
block|{
name|compiler
operator|->
name|imm
operator|=
name|src2w
operator|&
literal|0xffff
expr_stmt|;
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MUL
argument_list|,
name|flags
operator||
name|ALT_FORM1
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|TMP_REG2
argument_list|,
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|TEST_SL_IMM
argument_list|(
name|src1
argument_list|,
name|src1w
argument_list|)
condition|)
block|{
name|compiler
operator|->
name|imm
operator|=
name|src1w
operator|&
literal|0xffff
expr_stmt|;
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MUL
argument_list|,
name|flags
operator||
name|ALT_FORM1
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|,
name|TMP_REG2
argument_list|,
literal|0
argument_list|)
return|;
block|}
block|}
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MUL
argument_list|,
name|flags
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
return|;
case|case
name|SLJIT_AND
case|:
case|case
name|SLJIT_OR
case|:
case|case
name|SLJIT_XOR
case|:
comment|/* Commutative unsigned operations. */
if|if
condition|(
operator|!
name|GET_FLAGS
argument_list|(
name|op
argument_list|)
operator|||
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
operator|==
name|SLJIT_AND
condition|)
block|{
if|if
condition|(
name|TEST_UL_IMM
argument_list|(
name|src2
argument_list|,
name|src2w
argument_list|)
condition|)
block|{
name|compiler
operator|->
name|imm
operator|=
name|src2w
expr_stmt|;
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
argument_list|,
name|flags
operator||
name|ALT_FORM1
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|TMP_REG2
argument_list|,
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|TEST_UL_IMM
argument_list|(
name|src1
argument_list|,
name|src1w
argument_list|)
condition|)
block|{
name|compiler
operator|->
name|imm
operator|=
name|src1w
expr_stmt|;
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
argument_list|,
name|flags
operator||
name|ALT_FORM1
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|,
name|TMP_REG2
argument_list|,
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|TEST_UH_IMM
argument_list|(
name|src2
argument_list|,
name|src2w
argument_list|)
condition|)
block|{
name|compiler
operator|->
name|imm
operator|=
operator|(
name|src2w
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
expr_stmt|;
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
argument_list|,
name|flags
operator||
name|ALT_FORM2
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|TMP_REG2
argument_list|,
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|TEST_UH_IMM
argument_list|(
name|src1
argument_list|,
name|src1w
argument_list|)
condition|)
block|{
name|compiler
operator|->
name|imm
operator|=
operator|(
name|src1w
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
expr_stmt|;
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
argument_list|,
name|flags
operator||
name|ALT_FORM2
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|,
name|TMP_REG2
argument_list|,
literal|0
argument_list|)
return|;
block|}
block|}
if|if
condition|(
operator|!
name|GET_FLAGS
argument_list|(
name|op
argument_list|)
operator|&&
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
operator|!=
name|SLJIT_AND
condition|)
block|{
if|if
condition|(
name|TEST_UI_IMM
argument_list|(
name|src2
argument_list|,
name|src2w
argument_list|)
condition|)
block|{
name|compiler
operator|->
name|imm
operator|=
name|src2w
expr_stmt|;
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
argument_list|,
name|flags
operator||
name|ALT_FORM3
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|TMP_REG2
argument_list|,
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|TEST_UI_IMM
argument_list|(
name|src1
argument_list|,
name|src1w
argument_list|)
condition|)
block|{
name|compiler
operator|->
name|imm
operator|=
name|src1w
expr_stmt|;
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
argument_list|,
name|flags
operator||
name|ALT_FORM3
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|,
name|TMP_REG2
argument_list|,
literal|0
argument_list|)
return|;
block|}
block|}
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
argument_list|,
name|flags
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
return|;
case|case
name|SLJIT_ASHR
case|:
if|if
condition|(
name|op
operator|&
name|SLJIT_KEEP_FLAGS
condition|)
name|flags
operator||=
name|ALT_FORM3
expr_stmt|;
comment|/* Fall through. */
case|case
name|SLJIT_SHL
case|:
case|case
name|SLJIT_LSHR
case|:
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_PPC_64
operator|&&
name|SLJIT_CONFIG_PPC_64
operator|)
if|if
condition|(
name|op
operator|&
name|SLJIT_INT_OP
condition|)
name|flags
operator||=
name|ALT_FORM2
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|src2
operator|&
name|SLJIT_IMM
condition|)
block|{
name|compiler
operator|->
name|imm
operator|=
name|src2w
expr_stmt|;
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
argument_list|,
name|flags
operator||
name|ALT_FORM1
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|TMP_REG2
argument_list|,
literal|0
argument_list|)
return|;
block|}
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
argument_list|,
name|flags
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
return|;
block|}
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_function
DECL|function|sljit_get_register_index
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_get_register_index
parameter_list|(
name|sljit_si
name|reg
parameter_list|)
block|{
name|check_sljit_get_register_index
argument_list|(
name|reg
argument_list|)
expr_stmt|;
return|return
name|reg_map
index|[
name|reg
index|]
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_op_custom
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_op_custom
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|void
modifier|*
name|instruction
parameter_list|,
name|sljit_si
name|size
parameter_list|)
block|{
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|check_sljit_emit_op_custom
argument_list|(
name|compiler
argument_list|,
name|instruction
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|SLJIT_ASSERT
argument_list|(
name|size
operator|==
literal|4
argument_list|)
expr_stmt|;
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
operator|*
operator|(
name|sljit_ins
operator|*
operator|)
name|instruction
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_comment
comment|/*  Floating point operators                                             */
end_comment
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_function
DECL|function|sljit_is_fpu_available
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_is_fpu_available
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Always available. */
return|return
literal|1
return|;
block|}
end_function
begin_define
DECL|macro|FLOAT_DATA
define|#
directive|define
name|FLOAT_DATA
parameter_list|(
name|op
parameter_list|)
value|(DOUBLE_DATA | ((op& SLJIT_SINGLE_OP)>> 6))
end_define
begin_define
DECL|macro|SELECT_FOP
define|#
directive|define
name|SELECT_FOP
parameter_list|(
name|op
parameter_list|,
name|single
parameter_list|,
name|double
parameter_list|)
value|((op& SLJIT_SINGLE_OP) ? single : double)
end_define
begin_function
DECL|function|sljit_emit_fop1
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_fop1
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|)
block|{
name|sljit_si
name|dst_fr
decl_stmt|;
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|check_sljit_emit_fop1
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|SLJIT_COMPILE_ASSERT
argument_list|(
operator|(
name|SLJIT_SINGLE_OP
operator|==
literal|0x100
operator|)
operator|&&
operator|!
operator|(
name|DOUBLE_DATA
operator|&
literal|0x4
operator|)
argument_list|,
name|float_transfer_bit_error
argument_list|)
expr_stmt|;
name|compiler
operator|->
name|cache_arg
operator|=
literal|0
expr_stmt|;
name|compiler
operator|->
name|cache_argw
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
operator|==
name|SLJIT_CMPD
condition|)
block|{
if|if
condition|(
name|dst
operator|>
name|SLJIT_FLOAT_REG6
condition|)
block|{
name|FAIL_IF
argument_list|(
name|emit_op_mem2
argument_list|(
name|compiler
argument_list|,
name|FLOAT_DATA
argument_list|(
name|op
argument_list|)
operator||
name|LOAD_DATA
argument_list|,
name|TMP_FREG1
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
argument_list|)
expr_stmt|;
name|dst
operator|=
name|TMP_FREG1
expr_stmt|;
block|}
if|if
condition|(
name|src
operator|>
name|SLJIT_FLOAT_REG6
condition|)
block|{
name|FAIL_IF
argument_list|(
name|emit_op_mem2
argument_list|(
name|compiler
argument_list|,
name|FLOAT_DATA
argument_list|(
name|op
argument_list|)
operator||
name|LOAD_DATA
argument_list|,
name|TMP_FREG2
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|src
operator|=
name|TMP_FREG2
expr_stmt|;
block|}
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|FCMPU
operator||
name|CRD
argument_list|(
literal|4
argument_list|)
operator||
name|FA
argument_list|(
name|dst
argument_list|)
operator||
name|FB
argument_list|(
name|src
argument_list|)
argument_list|)
return|;
block|}
name|dst_fr
operator|=
operator|(
name|dst
operator|>
name|SLJIT_FLOAT_REG6
operator|)
condition|?
name|TMP_FREG1
else|:
name|dst
expr_stmt|;
if|if
condition|(
name|src
operator|>
name|SLJIT_FLOAT_REG6
condition|)
block|{
name|FAIL_IF
argument_list|(
name|emit_op_mem2
argument_list|(
name|compiler
argument_list|,
name|FLOAT_DATA
argument_list|(
name|op
argument_list|)
operator||
name|LOAD_DATA
argument_list|,
name|dst_fr
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
argument_list|)
expr_stmt|;
name|src
operator|=
name|dst_fr
expr_stmt|;
block|}
switch|switch
condition|(
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|SLJIT_MOVD
case|:
if|if
condition|(
name|src
operator|!=
name|dst_fr
operator|&&
name|dst_fr
operator|!=
name|TMP_FREG1
condition|)
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|FMR
operator||
name|FD
argument_list|(
name|dst_fr
argument_list|)
operator||
name|FB
argument_list|(
name|src
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_NEGD
case|:
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|FNEG
operator||
name|FD
argument_list|(
name|dst_fr
argument_list|)
operator||
name|FB
argument_list|(
name|src
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_ABSD
case|:
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|FABS
operator||
name|FD
argument_list|(
name|dst_fr
argument_list|)
operator||
name|FB
argument_list|(
name|src
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|dst_fr
operator|==
name|TMP_FREG1
condition|)
block|{
if|if
condition|(
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
operator|==
name|SLJIT_MOVD
condition|)
name|dst_fr
operator|=
name|src
expr_stmt|;
name|FAIL_IF
argument_list|(
name|emit_op_mem2
argument_list|(
name|compiler
argument_list|,
name|FLOAT_DATA
argument_list|(
name|op
argument_list|)
argument_list|,
name|dst_fr
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_fop2
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_fop2
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src1
parameter_list|,
name|sljit_sw
name|src1w
parameter_list|,
name|sljit_si
name|src2
parameter_list|,
name|sljit_sw
name|src2w
parameter_list|)
block|{
name|sljit_si
name|dst_fr
decl_stmt|,
name|flags
init|=
literal|0
decl_stmt|;
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|check_sljit_emit_fop2
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
expr_stmt|;
name|compiler
operator|->
name|cache_arg
operator|=
literal|0
expr_stmt|;
name|compiler
operator|->
name|cache_argw
operator|=
literal|0
expr_stmt|;
name|dst_fr
operator|=
operator|(
name|dst
operator|>
name|SLJIT_FLOAT_REG6
operator|)
condition|?
name|TMP_FREG2
else|:
name|dst
expr_stmt|;
if|if
condition|(
name|src1
operator|>
name|SLJIT_FLOAT_REG6
condition|)
block|{
if|if
condition|(
name|getput_arg_fast
argument_list|(
name|compiler
argument_list|,
name|FLOAT_DATA
argument_list|(
name|op
argument_list|)
operator||
name|LOAD_DATA
argument_list|,
name|TMP_FREG1
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
condition|)
block|{
name|FAIL_IF
argument_list|(
name|compiler
operator|->
name|error
argument_list|)
expr_stmt|;
name|src1
operator|=
name|TMP_FREG1
expr_stmt|;
block|}
else|else
name|flags
operator||=
name|ALT_FORM1
expr_stmt|;
block|}
if|if
condition|(
name|src2
operator|>
name|SLJIT_FLOAT_REG6
condition|)
block|{
if|if
condition|(
name|getput_arg_fast
argument_list|(
name|compiler
argument_list|,
name|FLOAT_DATA
argument_list|(
name|op
argument_list|)
operator||
name|LOAD_DATA
argument_list|,
name|TMP_FREG2
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
condition|)
block|{
name|FAIL_IF
argument_list|(
name|compiler
operator|->
name|error
argument_list|)
expr_stmt|;
name|src2
operator|=
name|TMP_FREG2
expr_stmt|;
block|}
else|else
name|flags
operator||=
name|ALT_FORM2
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|ALT_FORM1
operator||
name|ALT_FORM2
operator|)
operator|)
operator|==
operator|(
name|ALT_FORM1
operator||
name|ALT_FORM2
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|can_cache
argument_list|(
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
operator|&&
name|can_cache
argument_list|(
name|src1
argument_list|,
name|src1w
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
condition|)
block|{
name|FAIL_IF
argument_list|(
name|getput_arg
argument_list|(
name|compiler
argument_list|,
name|FLOAT_DATA
argument_list|(
name|op
argument_list|)
operator||
name|LOAD_DATA
argument_list|,
name|TMP_FREG2
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|getput_arg
argument_list|(
name|compiler
argument_list|,
name|FLOAT_DATA
argument_list|(
name|op
argument_list|)
operator||
name|LOAD_DATA
argument_list|,
name|TMP_FREG1
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|FAIL_IF
argument_list|(
name|getput_arg
argument_list|(
name|compiler
argument_list|,
name|FLOAT_DATA
argument_list|(
name|op
argument_list|)
operator||
name|LOAD_DATA
argument_list|,
name|TMP_FREG1
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|getput_arg
argument_list|(
name|compiler
argument_list|,
name|FLOAT_DATA
argument_list|(
name|op
argument_list|)
operator||
name|LOAD_DATA
argument_list|,
name|TMP_FREG2
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|ALT_FORM1
condition|)
name|FAIL_IF
argument_list|(
name|getput_arg
argument_list|(
name|compiler
argument_list|,
name|FLOAT_DATA
argument_list|(
name|op
argument_list|)
operator||
name|LOAD_DATA
argument_list|,
name|TMP_FREG1
argument_list|,
name|src1
argument_list|,
name|src1w
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|ALT_FORM2
condition|)
name|FAIL_IF
argument_list|(
name|getput_arg
argument_list|(
name|compiler
argument_list|,
name|FLOAT_DATA
argument_list|(
name|op
argument_list|)
operator||
name|LOAD_DATA
argument_list|,
name|TMP_FREG2
argument_list|,
name|src2
argument_list|,
name|src2w
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|ALT_FORM1
condition|)
name|src1
operator|=
name|TMP_FREG1
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|ALT_FORM2
condition|)
name|src2
operator|=
name|TMP_FREG2
expr_stmt|;
switch|switch
condition|(
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|SLJIT_ADDD
case|:
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|SELECT_FOP
argument_list|(
name|op
argument_list|,
name|FADDS
argument_list|,
name|FADD
argument_list|)
operator||
name|FD
argument_list|(
name|dst_fr
argument_list|)
operator||
name|FA
argument_list|(
name|src1
argument_list|)
operator||
name|FB
argument_list|(
name|src2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_SUBD
case|:
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|SELECT_FOP
argument_list|(
name|op
argument_list|,
name|FSUBS
argument_list|,
name|FSUB
argument_list|)
operator||
name|FD
argument_list|(
name|dst_fr
argument_list|)
operator||
name|FA
argument_list|(
name|src1
argument_list|)
operator||
name|FB
argument_list|(
name|src2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_MULD
case|:
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|SELECT_FOP
argument_list|(
name|op
argument_list|,
name|FMULS
argument_list|,
name|FMUL
argument_list|)
operator||
name|FD
argument_list|(
name|dst_fr
argument_list|)
operator||
name|FA
argument_list|(
name|src1
argument_list|)
operator||
name|FC
argument_list|(
name|src2
argument_list|)
comment|/* FMUL use FC as src2 */
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_DIVD
case|:
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|SELECT_FOP
argument_list|(
name|op
argument_list|,
name|FDIVS
argument_list|,
name|FDIV
argument_list|)
operator||
name|FD
argument_list|(
name|dst_fr
argument_list|)
operator||
name|FA
argument_list|(
name|src1
argument_list|)
operator||
name|FB
argument_list|(
name|src2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|dst_fr
operator|==
name|TMP_FREG2
condition|)
name|FAIL_IF
argument_list|(
name|emit_op_mem2
argument_list|(
name|compiler
argument_list|,
name|FLOAT_DATA
argument_list|(
name|op
argument_list|)
argument_list|,
name|TMP_FREG2
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SLJIT_SUCCESS
return|;
block|}
end_function
begin_undef
DECL|macro|FLOAT_DATA
undef|#
directive|undef
name|FLOAT_DATA
end_undef
begin_undef
DECL|macro|SELECT_FOP
undef|#
directive|undef
name|SELECT_FOP
end_undef
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_comment
comment|/*  Other instructions                                                   */
end_comment
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_function
DECL|function|sljit_emit_fast_enter
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_fast_enter
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|)
block|{
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|check_sljit_emit_fast_enter
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|ADJUST_LOCAL_OFFSET
argument_list|(
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
comment|/* For UNUSED dst. Uncommon, but possible. */
if|if
condition|(
name|dst
operator|==
name|SLJIT_UNUSED
condition|)
return|return
name|SLJIT_SUCCESS
return|;
if|if
condition|(
name|dst
operator|<=
name|ZERO_REG
condition|)
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|MFLR
operator||
name|D
argument_list|(
name|dst
argument_list|)
argument_list|)
return|;
comment|/* Memory. */
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|MFLR
operator||
name|D
argument_list|(
name|TMP_REG2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MOV
argument_list|,
name|WORD_DATA
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REG1
argument_list|,
literal|0
argument_list|,
name|TMP_REG2
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_fast_return
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_fast_return
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|)
block|{
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|check_sljit_emit_fast_return
argument_list|(
name|compiler
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|ADJUST_LOCAL_OFFSET
argument_list|(
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
if|if
condition|(
name|src
operator|<=
name|ZERO_REG
condition|)
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|MTLR
operator||
name|S
argument_list|(
name|src
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|src
operator|&
name|SLJIT_MEM
condition|)
name|FAIL_IF
argument_list|(
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MOV
argument_list|,
name|WORD_DATA
argument_list|,
name|TMP_REG2
argument_list|,
literal|0
argument_list|,
name|TMP_REG1
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|src
operator|&
name|SLJIT_IMM
condition|)
name|FAIL_IF
argument_list|(
name|load_immediate
argument_list|(
name|compiler
argument_list|,
name|TMP_REG2
argument_list|,
name|srcw
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|MTLR
operator||
name|S
argument_list|(
name|TMP_REG2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|BLR
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_comment
comment|/*  Conditional instructions                                             */
end_comment
begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment
begin_function
DECL|function|sljit_emit_label
name|SLJIT_API_FUNC_ATTRIBUTE
name|struct
name|sljit_label
modifier|*
name|sljit_emit_label
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|)
block|{
name|struct
name|sljit_label
modifier|*
name|label
decl_stmt|;
name|CHECK_ERROR_PTR
argument_list|()
expr_stmt|;
name|check_sljit_emit_label
argument_list|(
name|compiler
argument_list|)
expr_stmt|;
if|if
condition|(
name|compiler
operator|->
name|last_label
operator|&&
name|compiler
operator|->
name|last_label
operator|->
name|size
operator|==
name|compiler
operator|->
name|size
condition|)
return|return
name|compiler
operator|->
name|last_label
return|;
name|label
operator|=
operator|(
expr|struct
name|sljit_label
operator|*
operator|)
name|ensure_abuf
argument_list|(
name|compiler
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sljit_label
argument_list|)
argument_list|)
expr_stmt|;
name|PTR_FAIL_IF
argument_list|(
operator|!
name|label
argument_list|)
expr_stmt|;
name|set_label
argument_list|(
name|label
argument_list|,
name|compiler
argument_list|)
expr_stmt|;
return|return
name|label
return|;
block|}
end_function
begin_function
DECL|function|get_bo_bi_flags
specifier|static
name|sljit_ins
name|get_bo_bi_flags
parameter_list|(
name|sljit_si
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SLJIT_C_EQUAL
case|:
return|return
operator|(
literal|12
operator|<<
literal|21
operator|)
operator||
operator|(
literal|2
operator|<<
literal|16
operator|)
return|;
case|case
name|SLJIT_C_NOT_EQUAL
case|:
return|return
operator|(
literal|4
operator|<<
literal|21
operator|)
operator||
operator|(
literal|2
operator|<<
literal|16
operator|)
return|;
case|case
name|SLJIT_C_LESS
case|:
case|case
name|SLJIT_C_FLOAT_LESS
case|:
return|return
operator|(
literal|12
operator|<<
literal|21
operator|)
operator||
operator|(
operator|(
literal|4
operator|+
literal|0
operator|)
operator|<<
literal|16
operator|)
return|;
case|case
name|SLJIT_C_GREATER_EQUAL
case|:
case|case
name|SLJIT_C_FLOAT_GREATER_EQUAL
case|:
return|return
operator|(
literal|4
operator|<<
literal|21
operator|)
operator||
operator|(
operator|(
literal|4
operator|+
literal|0
operator|)
operator|<<
literal|16
operator|)
return|;
case|case
name|SLJIT_C_GREATER
case|:
case|case
name|SLJIT_C_FLOAT_GREATER
case|:
return|return
operator|(
literal|12
operator|<<
literal|21
operator|)
operator||
operator|(
operator|(
literal|4
operator|+
literal|1
operator|)
operator|<<
literal|16
operator|)
return|;
case|case
name|SLJIT_C_LESS_EQUAL
case|:
case|case
name|SLJIT_C_FLOAT_LESS_EQUAL
case|:
return|return
operator|(
literal|4
operator|<<
literal|21
operator|)
operator||
operator|(
operator|(
literal|4
operator|+
literal|1
operator|)
operator|<<
literal|16
operator|)
return|;
case|case
name|SLJIT_C_SIG_LESS
case|:
return|return
operator|(
literal|12
operator|<<
literal|21
operator|)
operator||
operator|(
literal|0
operator|<<
literal|16
operator|)
return|;
case|case
name|SLJIT_C_SIG_GREATER_EQUAL
case|:
return|return
operator|(
literal|4
operator|<<
literal|21
operator|)
operator||
operator|(
literal|0
operator|<<
literal|16
operator|)
return|;
case|case
name|SLJIT_C_SIG_GREATER
case|:
return|return
operator|(
literal|12
operator|<<
literal|21
operator|)
operator||
operator|(
literal|1
operator|<<
literal|16
operator|)
return|;
case|case
name|SLJIT_C_SIG_LESS_EQUAL
case|:
return|return
operator|(
literal|4
operator|<<
literal|21
operator|)
operator||
operator|(
literal|1
operator|<<
literal|16
operator|)
return|;
case|case
name|SLJIT_C_OVERFLOW
case|:
case|case
name|SLJIT_C_MUL_OVERFLOW
case|:
return|return
operator|(
literal|12
operator|<<
literal|21
operator|)
operator||
operator|(
literal|3
operator|<<
literal|16
operator|)
return|;
case|case
name|SLJIT_C_NOT_OVERFLOW
case|:
case|case
name|SLJIT_C_MUL_NOT_OVERFLOW
case|:
return|return
operator|(
literal|4
operator|<<
literal|21
operator|)
operator||
operator|(
literal|3
operator|<<
literal|16
operator|)
return|;
case|case
name|SLJIT_C_FLOAT_EQUAL
case|:
return|return
operator|(
literal|12
operator|<<
literal|21
operator|)
operator||
operator|(
operator|(
literal|4
operator|+
literal|2
operator|)
operator|<<
literal|16
operator|)
return|;
case|case
name|SLJIT_C_FLOAT_NOT_EQUAL
case|:
return|return
operator|(
literal|4
operator|<<
literal|21
operator|)
operator||
operator|(
operator|(
literal|4
operator|+
literal|2
operator|)
operator|<<
literal|16
operator|)
return|;
case|case
name|SLJIT_C_FLOAT_UNORDERED
case|:
return|return
operator|(
literal|12
operator|<<
literal|21
operator|)
operator||
operator|(
operator|(
literal|4
operator|+
literal|3
operator|)
operator|<<
literal|16
operator|)
return|;
case|case
name|SLJIT_C_FLOAT_ORDERED
case|:
return|return
operator|(
literal|4
operator|<<
literal|21
operator|)
operator||
operator|(
operator|(
literal|4
operator|+
literal|3
operator|)
operator|<<
literal|16
operator|)
return|;
default|default:
name|SLJIT_ASSERT
argument_list|(
name|type
operator|>=
name|SLJIT_JUMP
operator|&&
name|type
operator|<=
name|SLJIT_CALL3
argument_list|)
expr_stmt|;
return|return
operator|(
literal|20
operator|<<
literal|21
operator|)
return|;
block|}
block|}
end_function
begin_function
DECL|function|sljit_emit_jump
name|SLJIT_API_FUNC_ATTRIBUTE
name|struct
name|sljit_jump
modifier|*
name|sljit_emit_jump
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|type
parameter_list|)
block|{
name|struct
name|sljit_jump
modifier|*
name|jump
decl_stmt|;
name|sljit_ins
name|bo_bi_flags
decl_stmt|;
name|CHECK_ERROR_PTR
argument_list|()
expr_stmt|;
name|check_sljit_emit_jump
argument_list|(
name|compiler
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|bo_bi_flags
operator|=
name|get_bo_bi_flags
argument_list|(
name|type
operator|&
literal|0xff
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bo_bi_flags
condition|)
return|return
name|NULL
return|;
name|jump
operator|=
operator|(
expr|struct
name|sljit_jump
operator|*
operator|)
name|ensure_abuf
argument_list|(
name|compiler
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sljit_jump
argument_list|)
argument_list|)
expr_stmt|;
name|PTR_FAIL_IF
argument_list|(
operator|!
name|jump
argument_list|)
expr_stmt|;
name|set_jump
argument_list|(
name|jump
argument_list|,
name|compiler
argument_list|,
name|type
operator|&
name|SLJIT_REWRITABLE_JUMP
argument_list|)
expr_stmt|;
name|type
operator|&=
literal|0xff
expr_stmt|;
comment|/* In PPC, we don't need to touch the arguments. */
if|if
condition|(
name|type
operator|>=
name|SLJIT_JUMP
condition|)
name|jump
operator|->
name|flags
operator||=
name|UNCOND_B
expr_stmt|;
name|PTR_FAIL_IF
argument_list|(
name|emit_const
argument_list|(
name|compiler
argument_list|,
name|TMP_REG1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|PTR_FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|MTCTR
operator||
name|S
argument_list|(
name|TMP_REG1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|jump
operator|->
name|addr
operator|=
name|compiler
operator|->
name|size
expr_stmt|;
name|PTR_FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|BCCTR
operator||
name|bo_bi_flags
operator||
operator|(
name|type
operator|>=
name|SLJIT_FAST_CALL
condition|?
literal|1
else|:
literal|0
operator|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|jump
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_ijump
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_ijump
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|type
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|)
block|{
name|struct
name|sljit_jump
modifier|*
name|jump
init|=
name|NULL
decl_stmt|;
name|sljit_si
name|src_r
decl_stmt|;
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|check_sljit_emit_ijump
argument_list|(
name|compiler
argument_list|,
name|type
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
name|ADJUST_LOCAL_OFFSET
argument_list|(
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
if|if
condition|(
name|src
operator|<=
name|ZERO_REG
condition|)
name|src_r
operator|=
name|src
expr_stmt|;
elseif|else
if|if
condition|(
name|src
operator|&
name|SLJIT_IMM
condition|)
block|{
name|jump
operator|=
operator|(
expr|struct
name|sljit_jump
operator|*
operator|)
name|ensure_abuf
argument_list|(
name|compiler
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sljit_jump
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL_IF
argument_list|(
operator|!
name|jump
argument_list|)
expr_stmt|;
name|set_jump
argument_list|(
name|jump
argument_list|,
name|compiler
argument_list|,
name|JUMP_ADDR
operator||
name|UNCOND_B
argument_list|)
expr_stmt|;
name|jump
operator|->
name|u
operator|.
name|target
operator|=
name|srcw
expr_stmt|;
name|FAIL_IF
argument_list|(
name|emit_const
argument_list|(
name|compiler
argument_list|,
name|TMP_REG2
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|src_r
operator|=
name|TMP_REG2
expr_stmt|;
block|}
else|else
block|{
name|FAIL_IF
argument_list|(
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MOV
argument_list|,
name|WORD_DATA
argument_list|,
name|TMP_REG2
argument_list|,
literal|0
argument_list|,
name|TMP_REG1
argument_list|,
literal|0
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|)
argument_list|)
expr_stmt|;
name|src_r
operator|=
name|TMP_REG2
expr_stmt|;
block|}
name|FAIL_IF
argument_list|(
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|MTCTR
operator||
name|S
argument_list|(
name|src_r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|jump
condition|)
name|jump
operator|->
name|addr
operator|=
name|compiler
operator|->
name|size
expr_stmt|;
return|return
name|push_inst
argument_list|(
name|compiler
argument_list|,
name|BCCTR
operator||
operator|(
literal|20
operator|<<
literal|21
operator|)
operator||
operator|(
name|type
operator|>=
name|SLJIT_FAST_CALL
condition|?
literal|1
else|:
literal|0
operator|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/* Get a bit from CR, all other bits are zeroed. */
end_comment
begin_define
DECL|macro|GET_CR_BIT
define|#
directive|define
name|GET_CR_BIT
parameter_list|(
name|bit
parameter_list|,
name|dst
parameter_list|)
define|\
value|FAIL_IF(push_inst(compiler, MFCR | D(dst))); \ 	FAIL_IF(push_inst(compiler, RLWINM | S(dst) | A(dst) | ((1 + (bit))<< 11) | (31<< 6) | (31<< 1)));
end_define
begin_define
DECL|macro|INVERT_BIT
define|#
directive|define
name|INVERT_BIT
parameter_list|(
name|dst
parameter_list|)
define|\
value|FAIL_IF(push_inst(compiler, XORI | S(dst) | A(dst) | 0x1));
end_define
begin_function
DECL|function|sljit_emit_op_flags
name|SLJIT_API_FUNC_ATTRIBUTE
name|sljit_si
name|sljit_emit_op_flags
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|op
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_si
name|src
parameter_list|,
name|sljit_sw
name|srcw
parameter_list|,
name|sljit_si
name|type
parameter_list|)
block|{
name|sljit_si
name|reg
decl_stmt|,
name|input_flags
decl_stmt|;
name|sljit_si
name|flags
init|=
name|GET_ALL_FLAGS
argument_list|(
name|op
argument_list|)
decl_stmt|;
name|CHECK_ERROR
argument_list|()
expr_stmt|;
name|check_sljit_emit_op_flags
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|ADJUST_LOCAL_OFFSET
argument_list|(
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|==
name|SLJIT_UNUSED
condition|)
return|return
name|SLJIT_SUCCESS
return|;
name|op
operator|=
name|GET_OPCODE
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|reg
operator|=
operator|(
name|op
operator|<
name|SLJIT_ADD
operator|&&
name|dst
operator|<=
name|ZERO_REG
operator|)
condition|?
name|dst
else|:
name|TMP_REG2
expr_stmt|;
name|compiler
operator|->
name|cache_arg
operator|=
literal|0
expr_stmt|;
name|compiler
operator|->
name|cache_argw
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|op
operator|>=
name|SLJIT_ADD
operator|&&
operator|(
name|src
operator|&
name|SLJIT_MEM
operator|)
condition|)
block|{
name|ADJUST_LOCAL_OFFSET
argument_list|(
name|src
argument_list|,
name|srcw
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_PPC_64
operator|&&
name|SLJIT_CONFIG_PPC_64
operator|)
name|input_flags
operator|=
operator|(
name|flags
operator|&
name|SLJIT_INT_OP
operator|)
condition|?
name|INT_DATA
else|:
name|WORD_DATA
expr_stmt|;
else|#
directive|else
name|input_flags
operator|=
name|WORD_DATA
expr_stmt|;
endif|#
directive|endif
name|FAIL_IF
argument_list|(
name|emit_op_mem2
argument_list|(
name|compiler
argument_list|,
name|input_flags
operator||
name|LOAD_DATA
argument_list|,
name|TMP_REG1
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|)
argument_list|)
expr_stmt|;
name|src
operator|=
name|TMP_REG1
expr_stmt|;
name|srcw
operator|=
literal|0
expr_stmt|;
block|}
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SLJIT_C_EQUAL
case|:
name|GET_CR_BIT
argument_list|(
literal|2
argument_list|,
name|reg
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_C_NOT_EQUAL
case|:
name|GET_CR_BIT
argument_list|(
literal|2
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|INVERT_BIT
argument_list|(
name|reg
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_C_LESS
case|:
case|case
name|SLJIT_C_FLOAT_LESS
case|:
name|GET_CR_BIT
argument_list|(
literal|4
operator|+
literal|0
argument_list|,
name|reg
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_C_GREATER_EQUAL
case|:
case|case
name|SLJIT_C_FLOAT_GREATER_EQUAL
case|:
name|GET_CR_BIT
argument_list|(
literal|4
operator|+
literal|0
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|INVERT_BIT
argument_list|(
name|reg
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_C_GREATER
case|:
case|case
name|SLJIT_C_FLOAT_GREATER
case|:
name|GET_CR_BIT
argument_list|(
literal|4
operator|+
literal|1
argument_list|,
name|reg
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_C_LESS_EQUAL
case|:
case|case
name|SLJIT_C_FLOAT_LESS_EQUAL
case|:
name|GET_CR_BIT
argument_list|(
literal|4
operator|+
literal|1
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|INVERT_BIT
argument_list|(
name|reg
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_C_SIG_LESS
case|:
name|GET_CR_BIT
argument_list|(
literal|0
argument_list|,
name|reg
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_C_SIG_GREATER_EQUAL
case|:
name|GET_CR_BIT
argument_list|(
literal|0
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|INVERT_BIT
argument_list|(
name|reg
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_C_SIG_GREATER
case|:
name|GET_CR_BIT
argument_list|(
literal|1
argument_list|,
name|reg
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_C_SIG_LESS_EQUAL
case|:
name|GET_CR_BIT
argument_list|(
literal|1
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|INVERT_BIT
argument_list|(
name|reg
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_C_OVERFLOW
case|:
case|case
name|SLJIT_C_MUL_OVERFLOW
case|:
name|GET_CR_BIT
argument_list|(
literal|3
argument_list|,
name|reg
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_C_NOT_OVERFLOW
case|:
case|case
name|SLJIT_C_MUL_NOT_OVERFLOW
case|:
name|GET_CR_BIT
argument_list|(
literal|3
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|INVERT_BIT
argument_list|(
name|reg
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_C_FLOAT_EQUAL
case|:
name|GET_CR_BIT
argument_list|(
literal|4
operator|+
literal|2
argument_list|,
name|reg
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_C_FLOAT_NOT_EQUAL
case|:
name|GET_CR_BIT
argument_list|(
literal|4
operator|+
literal|2
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|INVERT_BIT
argument_list|(
name|reg
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_C_FLOAT_UNORDERED
case|:
name|GET_CR_BIT
argument_list|(
literal|4
operator|+
literal|3
argument_list|,
name|reg
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLJIT_C_FLOAT_ORDERED
case|:
name|GET_CR_BIT
argument_list|(
literal|4
operator|+
literal|3
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|INVERT_BIT
argument_list|(
name|reg
argument_list|)
expr_stmt|;
break|break;
default|default:
name|SLJIT_ASSERT_STOP
argument_list|()
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|op
operator|<
name|SLJIT_ADD
condition|)
block|{
if|#
directive|if
operator|(
name|defined
name|SLJIT_CONFIG_PPC_64
operator|&&
name|SLJIT_CONFIG_PPC_64
operator|)
if|if
condition|(
name|op
operator|==
name|SLJIT_MOV
condition|)
name|input_flags
operator|=
name|WORD_DATA
expr_stmt|;
else|else
block|{
name|op
operator|=
name|SLJIT_MOV_UI
expr_stmt|;
name|input_flags
operator|=
name|INT_DATA
expr_stmt|;
block|}
else|#
directive|else
name|op
operator|=
name|SLJIT_MOV
expr_stmt|;
name|input_flags
operator|=
name|WORD_DATA
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|reg
operator|==
name|TMP_REG2
operator|)
condition|?
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|op
argument_list|,
name|input_flags
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REG1
argument_list|,
literal|0
argument_list|,
name|TMP_REG2
argument_list|,
literal|0
argument_list|)
else|:
name|SLJIT_SUCCESS
return|;
block|}
if|#
directive|if
operator|(
name|defined
name|SLJIT_VERBOSE
operator|&&
name|SLJIT_VERBOSE
operator|)
operator|||
operator|(
name|defined
name|SLJIT_DEBUG
operator|&&
name|SLJIT_DEBUG
operator|)
name|compiler
operator|->
name|skip_checks
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
return|return
name|sljit_emit_op2
argument_list|(
name|compiler
argument_list|,
name|op
operator||
name|flags
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|src
argument_list|,
name|srcw
argument_list|,
name|TMP_REG2
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|sljit_emit_const
name|SLJIT_API_FUNC_ATTRIBUTE
name|struct
name|sljit_const
modifier|*
name|sljit_emit_const
parameter_list|(
name|struct
name|sljit_compiler
modifier|*
name|compiler
parameter_list|,
name|sljit_si
name|dst
parameter_list|,
name|sljit_sw
name|dstw
parameter_list|,
name|sljit_sw
name|init_value
parameter_list|)
block|{
name|struct
name|sljit_const
modifier|*
name|const_
decl_stmt|;
name|sljit_si
name|reg
decl_stmt|;
name|CHECK_ERROR_PTR
argument_list|()
expr_stmt|;
name|check_sljit_emit_const
argument_list|(
name|compiler
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|init_value
argument_list|)
expr_stmt|;
name|ADJUST_LOCAL_OFFSET
argument_list|(
name|dst
argument_list|,
name|dstw
argument_list|)
expr_stmt|;
name|const_
operator|=
operator|(
expr|struct
name|sljit_const
operator|*
operator|)
name|ensure_abuf
argument_list|(
name|compiler
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sljit_const
argument_list|)
argument_list|)
expr_stmt|;
name|PTR_FAIL_IF
argument_list|(
operator|!
name|const_
argument_list|)
expr_stmt|;
name|set_const
argument_list|(
name|const_
argument_list|,
name|compiler
argument_list|)
expr_stmt|;
name|reg
operator|=
operator|(
name|dst
operator|<=
name|ZERO_REG
operator|)
condition|?
name|dst
else|:
name|TMP_REG2
expr_stmt|;
name|PTR_FAIL_IF
argument_list|(
name|emit_const
argument_list|(
name|compiler
argument_list|,
name|reg
argument_list|,
name|init_value
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|&
name|SLJIT_MEM
condition|)
name|PTR_FAIL_IF
argument_list|(
name|emit_op
argument_list|(
name|compiler
argument_list|,
name|SLJIT_MOV
argument_list|,
name|WORD_DATA
argument_list|,
name|dst
argument_list|,
name|dstw
argument_list|,
name|TMP_REG1
argument_list|,
literal|0
argument_list|,
name|TMP_REG2
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|const_
return|;
block|}
end_function
end_unit
